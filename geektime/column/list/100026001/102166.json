{"id":102166,"title":"25 | 冒险和预测（四）：今天下雨了，明天还会下雨么？","content":"<p>过去三讲，我主要为你介绍了结构冒险和数据冒险，以及增加资源、流水线停顿、操作数前推、乱序执行，这些解决各种“冒险”的技术方案。</p><p>在结构冒险和数据冒险中，你会发现，所有的流水线停顿操作都要从<strong>指令执行阶段</strong>开始。流水线的前两个阶段，也就是取指令（IF）和指令译码（ID）的阶段，是不需要停顿的。CPU会在流水线里面直接去取下一条指令，然后进行译码。</p><p>取指令和指令译码不会需要遇到任何停顿，这是基于一个假设。这个假设就是，所有的指令代码都是顺序加载执行的。不过这个假设，在执行的代码中，一旦遇到 if…else 这样的条件分支，或者 for/while 循环，就会不成立。</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/fa/b439cebb2d85496ad6eef2f61071aefa.jpeg?wh=2716*1330\" alt=\"\"></p><center><span class=\"reference\">回顾一下第6讲的条件跳转流程</span></center><p>我们先来回顾一下，<a href=\"https://time.geekbang.org/column/article/94075\">第6讲</a>里讲的cmp比较指令、jmp和jle这样的条件跳转指令。可以看到，在jmp指令发生的时候，CPU可能会跳转去执行其他指令。jmp后的那一条指令是否应该顺序加载执行，在流水线里面进行取指令的时候，我们没法知道。要等jmp指令执行完成，去更新了PC寄存器之后，我们才能知道，是否执行下一条指令，还是跳转到另外一个内存地址，去取别的指令。</p><p>这种为了确保能取到正确的指令，而不得不进行等待延迟的情况，就是今天我们要讲的<strong>控制冒险</strong>（Control Harzard）。这也是流水线设计里最后一种冒险。</p><!-- [[[read_end]]] --><h2>分支预测：今天下雨了，明天还会继续下雨么？</h2><p>在遇到了控制冒险之后，我们的CPU具体会怎么应对呢？除了流水线停顿，等待前面的jmp指令执行完成之后，再去取最新的指令，还有什么好办法吗？当然是有的。我们一起来看一看。</p><h3>缩短分支延迟</h3><p>第一个办法，叫作<strong>缩短分支延迟</strong>。回想一下我们的条件跳转指令，条件跳转指令其实进行了两种电路操作。</p><p>第一种，是进行条件比较。这个条件比较，需要的输入是，根据指令的opcode，就能确认的条件码寄存器。</p><p>第二种，是进行实际的跳转，也就是把要跳转的地址信息写入到PC寄存器。无论是opcode，还是对应的条件码寄存器，还是我们跳转的地址，都是在指令译码（ID）的阶段就能获得的。而对应的条件码比较的电路，只要是简单的逻辑门电路就可以了，并不需要一个完整而复杂的ALU。</p><p>所以，我们可以将条件判断、地址跳转，都提前到指令译码阶段进行，而不需要放在指令执行阶段。对应的，我们也要在CPU里面设计对应的旁路，在指令译码阶段，就提供对应的判断比较的电路。</p><p>这种方式，本质上和前面数据冒险的操作数前推的解决方案类似，就是在硬件电路层面，把一些计算结果更早地反馈到流水线中。这样反馈变得更快了，后面的指令需要等待的时间就变短了。</p><p>不过只是改造硬件，并不能彻底解决问题。跳转指令的比较结果，仍然要在指令执行的时候才能知道。在流水线里，第一条指令进行指令译码的时钟周期里，我们其实就要去取下一条指令了。这个时候，我们其实还没有开始指令执行阶段，自然也就不知道比较的结果。</p><h3>分支预测</h3><p>所以，这个时候，我们就引入了一个新的解决方案，叫作<strong>分支预测</strong>（Branch Prediction）技术，也就是说，让我们的CPU来猜一猜，条件跳转后执行的指令，应该是哪一条。</p><p>最简单的分支预测技术，叫作“<strong>假装分支不发生</strong>”。顾名思义，自然就是仍然按照顺序，把指令往下执行。其实就是CPU预测，条件跳转一定不发生。这样的预测方法，其实也是一种<strong>静态预测</strong>技术。就好像猜硬币的时候，你一直猜正面，会有50%的正确率。</p><p>如果分支预测是正确的，我们自然赚到了。这个意味着，我们节省下来本来需要停顿下来等待的时间。如果分支预测失败了呢？那我们就把后面已经取出指令已经执行的部分，给丢弃掉。这个丢弃的操作，在流水线里面，叫作Zap或者Flush。CPU不仅要执行后面的指令，对于这些已经在流水线里面执行到一半的指令，我们还需要做对应的清除操作。比如，清空已经使用的寄存器里面的数据等等，这些清除操作，也有一定的开销。</p><p>所以，CPU需要提供对应的丢弃指令的功能，通过控制信号清除掉已经在流水线中执行的指令。只要对应的清除开销不要太大，我们就是划得来的。</p><p><img src=\"https://static001.geekbang.org/resource/image/39/c3/39d114b3e37fe7fbad98ef0322b876c3.jpeg?wh=2389*871\" alt=\"\"></p><h3>动态分支预测</h3><p>第三个办法，叫作<strong>动态分支预测</strong>。</p><p>上面的静态预测策略，看起来比较简单，预测的准确率也许有50%。但是如果运气不好，可能就会特别差。于是，工程师们就开始思考，我们有没有更好的办法呢？比如，根据之前条件跳转的比较结果来预测，是不是会更准一点？</p><p>我们日常生活里，最经常会遇到的预测就是天气预报。如果没有气象台给你天气预报，你想要猜一猜明天是不是下雨，你会怎么办？</p><p>有一个简单的策略，就是完全根据今天的天气来猜。如果今天下雨，我们就预测明天下雨。如果今天天晴，就预测明天也不会下雨。这是一个很符合我们日常生活经验的预测。因为一般下雨天，都是连着下几天，不断地间隔地发生“天晴-下雨-天晴-下雨”的情况并不多见。</p><p>那么，把这样的实践拿到生活中来是不是有效呢？我在这里给了一张2019年1月上海的天气情况的表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/d8/2f83d82e417f1d37cb9ddb253a0b6cd8.png?wh=600*479\" alt=\"\"></p><p>我们用前一天的是不是下雨，直接来预测后一天会不会下雨。这个表格里一共有31天，那我们就可以预测30次。你可以数一数，按照这种预测方式，我们可以预测正确23次，正确率是76.7%，比随机预测的50%要好上不少。</p><p>而同样的策略，我们一样可以放在分支预测上。这种策略，我们叫<strong>一级分支预测</strong>（One Level Branch Prediction），或者叫<strong>1比特饱和计数</strong>（1-bit saturating counter）。这个方法，其实就是用一个比特，去记录当前分支的比较情况，直接用当前分支的比较情况，来预测下一次分支时候的比较情况。</p><p>只用一天下雨，就预测第二天下雨，这个方法还是有些“草率”，我们可以用更多的信息，而不只是一次的分支信息来进行预测。于是，我们可以引入一个<strong>状态机</strong>（State Machine）来做这个事情。</p><p>如果连续发生下雨的情况，我们就认为更有可能下雨。之后如果只有一天放晴了，我们仍然认为会下雨。在连续下雨之后，要连续两天放晴，我们才会认为之后会放晴。整个状态机的流转，可以参考我在文稿里放的图。</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/5d/ea82f279b48c10ad95027c91ed62ab5d.jpeg?wh=2803*1753\" alt=\"\"></p><p>这个状态机里，我们一共有4个状态，所以我们需要2个比特来记录对应的状态。这样这整个策略，就可以叫作<strong>2比特饱和计数</strong>，或者叫<strong>双模态预测器</strong>（Bimodal Predictor）。</p><p>好了，现在你可以用这个策略，再去对照一下上面的天气情况。如果天气的初始状态我们放在“多半放晴”的状态下，我们预测的结果的正确率会是22次，也就是73.3%的正确率。可以看到，并不是更复杂的算法，效果一定就更好。实际的预测效果，和实际执行的指令高度相关。</p><p>如果想对各种分支预测技术有所了解，<a href=\"https://en.wikipedia.org/wiki/Branch_predictor\">Wikipedia</a>里面有更详细的内容和更多的分支预测算法，你可以看看。</p><h2>为什么循环嵌套的改变会影响性能？</h2><p>说完了分支预测，现在我们先来看一个Java程序。</p><pre><code>public class BranchPrediction {\n    public static void main(String args[]) {        \n        long start = System.currentTimeMillis();\n        for (int i = 0; i &lt; 100; i++) {\n            for (int j = 0; j &lt;1000; j ++) {\n                for (int k = 0; k &lt; 10000; k++) {\n                }\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;Time spent is &quot; + (end - start));\n                \n        start = System.currentTimeMillis();\n        for (int i = 0; i &lt; 10000; i++) {\n            for (int j = 0; j &lt;1000; j ++) {\n                for (int k = 0; k &lt; 100; k++) {\n                }\n            }\n        }\n        end = System.currentTimeMillis();\n        System.out.println(&quot;Time spent is &quot; + (end - start) + &quot;ms&quot;);\n    }\n}\n</code></pre><p>这是一个简单的三重循环，里面没有任何逻辑代码。我们用两种不同的循环顺序各跑一次。第一次，最外重循环循环了100次，第二重循环1000次，最内层的循环了10000次。第二次，我们把顺序倒过来，最外重循环10000次，第二重还是1000次，最内层100次。</p><p>事实上，这段代码在这个专栏一开始的几讲里面，就有同学来提问，想要弄明白这里面的关窍。</p><p>你可以先猜一猜，这样两次运行，花费的时间是一样的么？结果应该会让你大吃一惊。我们可以看看对应的命令行输出。</p><pre><code>Time spent in first loop is 5ms\nTime spent in second loop is 15ms\n</code></pre><p>同样循环了十亿次，第一段程序只花了5毫秒，而第二段程序则花了15毫秒，足足多了2倍。</p><p>这个差异就来自我们上面说的分支预测。我们在前面讲过，循环其实也是利用cmp和jle这样先比较后跳转的指令来实现的。如果对for循环的汇编代码或者机器代码的实现不太清楚，你可以回头去复习一下第6讲。</p><p>这里的代码，每一次循环都有一个cmp和jle指令。每一个 jle 就意味着，要比较条件码寄存器的状态，决定是顺序执行代码，还是要跳转到另外一个地址。也就是说，在每一次循环发生的时候，都会有一次“分支”。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/a5/69c0cb32d5b7139e0f993855104e55a5.jpeg?wh=2788*2206\" alt=\"\"></p><p>分支预测策略最简单的一个方式，自然是“<strong>假定分支不发生</strong>”。对应到上面的循环代码，就是循环始终会进行下去。在这样的情况下，上面的第一段循环，也就是内层 k 循环10000次的代码。每隔10000次，才会发生一次预测上的错误。而这样的错误，在第二层 j 的循环发生的次数，是1000次。</p><p>最外层的 i 的循环是100次。每个外层循环一次里面，都会发生1000次最内层 k 的循环的预测错误，所以一共会发生 100 × 1000 = 10万次预测错误。</p><p>上面的第二段循环，也就是内存k的循环100次的代码，则是每100次循环，就会发生一次预测错误。这样的错误，在第二层j的循环发生的次数，还是1000次。最外层 i 的循环是10000次，所以一共会发生 1000 × 10000 = 1000万次预测错误。</p><p>到这里，相信你能猜到为什么同样空转次数相同的循环代码，第一段代码运行的时间要少得多了。因为第一段代码发生“分支预测”错误的情况比较少，更多的计算机指令，在流水线里顺序运行下去了，而不需要把运行到一半的指令丢弃掉，再去重新加载新的指令执行。</p><h2>总结延伸</h2><p>好了，这一讲，我给你讲解了什么是控制冒险，以及应对控制冒险的三个方式。</p><p>第一种方案，类似我们的操作数前推，其实是在改造我们的CPU功能，通过增加对应的电路的方式，来缩短分支带来的延迟。另外两种解决方案，无论是“假装分支不发生”，还是“动态分支预测”，其实都是在进行“分支预测”。只是，“假装分支不发生”是一种简单的静态预测方案而已。</p><p>在动态分支预测技术里，我给你介绍了一级分支预测，或者叫1比特饱和计数的方法。其实就是认为，预测结果和上一次的条件跳转是一致的。在此基础上，我还介绍了利用更多信息的，就是2比特饱和计数，或者叫双模态预测器的方法。这个方法其实也只是通过一个状态机，多看了一步过去的跳转比较结果。</p><p>这个方法虽然简单，但是却非常有效。在 SPEC 89 版本的测试当中，使用这样的饱和计数方法，预测的准确率能够高达93.5%。Intel的CPU，一直到Pentium时代，在还没有使用MMX指令集的时候，用的就是这种分支预测方式。</p><p>这一讲的最后，我给你看了一个有意思的例子。通过交换内外循环的顺序，我们体验了一把控制冒险导致的性能差异。虽然执行的指令数是一样的，但是分支预测失败得多的程序，性能就要差上几倍。</p><h2>推荐阅读</h2><p>想要进一步了解控制冒险和分支预测技术，可以去读一读《计算机组成与设计：硬件/软件接口》的4.8章节。</p><p>如果想对各种分支预测技术有所了解，<a href=\"https://en.wikipedia.org/wiki/Branch_predictor\">Wikipedia</a>里面有更详细的内容和更多的分支预测算法。</p><h2>课后思考</h2><p>我在上面用一个三重循环的Java程序，验证了“分支预测”出错会对程序带来的性能影响。你可以用你自己惯用的语言来试一试，看一看是否会有同样的效果。如果没有的话，原因是什么呢？</p><p>欢迎留言和我分享你的疑惑和见解。你也可以把今天的内容，分享给你的朋友，和他一起学习和进步。</p><p></p>","comments":[{"had_liked":false,"id":109635,"user_name":"鱼向北游","can_delete":false,"product_type":"c1","uid":1439908,"ip_address":"","ucode":"580EC7DCE57E9A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IPdZZXuHVMibwfZWmm7NiawzeEFGsaRoWjhuN99iaoj5amcRkiaOePo6rH1KJ3jictmNlic4OibkF4I20vOGfwDqcBxfA/132","comment_is_top":false,"comment_ctime":1562069806,"is_pvip":false,"discussion_count":22,"race_medal":0,"score":"388109126446","product_id":100026001,"comment_content":"徐老师 这个for循环的原理是对的，但是例子可能不恰当，因为这个例子耗时最长的不是cpu分支冒险，而是最后一层循环的临时变量创建次数，属于栈的问题，如果要测试分支预测，需要int i，j，k在循环外初始化好，但是这样的话目前100，1000，10000次的循环是几乎看不到差异的，甚至得出的结果会相反，在最大的循环扩充到1000万次(总量为10万亿次，才能感受到冒险的差异)。希望老师能看到，顺便改下例子","like_count":91,"discussions":[{"author":{"id":1243906,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fb/02/1b74615c.jpg","nickname":"树军","note":"","ucode":"7BC6F00B94FB2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296688,"discussion_content":"例子应该说是非常不恰当，这种对比一定要使用汇编代码来比较，要抛开编译器的影响，那怕不用汇编也至少得用C语言吧，JAVA隔着一层虚拟机，产生差异的因素太多了。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1596622165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/9c/91dc7fc4.jpg","nickname":"IDo","note":"","ucode":"BCF7BFBE35E390","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337898,"discussion_content":"我把老师给的Java代码用c语言写出来，用arm64的gcc编译出来，看了一下，两个函数的汇编是一样的。跟栈没得关系啊","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1609120895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006849,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/01/9cd84003.jpg","nickname":"栋能","note":"","ucode":"8BD9C939D3E8E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1077,"discussion_content":"在我看来是没有问题的，为什么呢？因为两个比较都做了相同的总深度循环和相同数量的临时变量创建","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1562312566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006849,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/01/9cd84003.jpg","nickname":"栋能","note":"","ucode":"8BD9C939D3E8E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254426,"discussion_content":"应该不是，换个写法，情况1：\nint i = 0;\nfor(; i < 100; ++i){\n    int j = 0;\n    for(; j < 1000; ++j){\n        int k = 0;\n        for(; k < 10000; ++k){}\n     }\n}\n情况2：\nint i = 0;\nfor(; i < 10000; ++i){\n    int j = 0;\n    for(; j < 1000; ++j){\n        int k = 0;\n        for(; k < 100; ++k){}\n     }\n}\n明显是不一样，当然有可能编译器优化？这方面不太了解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588325447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1077,"ip_address":""},"score":254426,"extra":""}]},{"author":{"id":1116159,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/ff/b3fe9903.jpg","nickname":"lisimmy","note":"","ucode":"288507E785B433","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390741,"discussion_content":"这个同学for循环没学好，😄！\n\n初始化条件只执行一次，都是迭代运行…好好学基础吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630023284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1116159,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/ff/b3fe9903.jpg","nickname":"lisimmy","note":"","ucode":"288507E785B433","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":573595,"discussion_content":"是你没有理解题主的意思，i循环100次，那么j就要创建 100次临时变量，k就要创建1000次临时变量，总共创建 100*1000次\n如果i,j,k反方向，那么创建临时变量数就是10000*1000次","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1653533807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":390741,"ip_address":""},"score":573595,"extra":""}]},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375763,"discussion_content":"编译应该有优化的，i,j,k放里面还是外面差别不大","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621844226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2023574,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/FXUzj6S2tq6iabBMGM6Z1DJTrGaroYECkD8Cictv4Xya0PvyqLicoNsk2KUEpaxoAC3iaPCxsUjgG9JslJk15iaK8icQ/132","nickname":"孙立","note":"","ucode":"7AB3E34DEA6D6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374635,"discussion_content":"汇编一样，编译器优化了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621297712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1608643,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8b/c3/bf036d99.jpg","nickname":"砥砺奋进","note":"","ucode":"2F12FD10F749AD","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577824,"discussion_content":"从学过的编译原理理解这种情况编译器都会优化的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656376410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573599,"discussion_content":"先给题主说明的例子解释下为什么这里是临时变量次数起的作用而不是分支预测，下面很多人没明白。（是你没有理解题主的意思，i循环100次，那么j就要创建 100次临时变量，k就要创建1000次临时变量，总共创建 100*1000次\n如果i,j,k反方向，那么创建临时变量数就是10000*1000次）\n接下来在回答一下题主说的分支预测只有数量大的时候才能体现出来，我的理解是，理论上第一种循环预测错误次数少于第二种100倍，但是实际上，流水线深度就10几，FU单元也不会很多，导致实际预测错误很快就能改正过来，那么就不会达到理论上的 100 倍，这样实际运行结果基本就看不到差异，如果把循环次数在增加，使得理论上预测错误次数增加到 100000 倍，那么此时我觉得实际跑程序时，真实预测错误次数也就10000倍，那么这个时候运行时间上就会看出来点差异了。\n结论：我觉得分之预测在这个例子当中起的作用很少，实际中需要大数据情况才会有看到所差异","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653535967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1528160,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/vopk2JZ3QqRytUbiaiacj1yIytM4VTvE9xxaLnv5ozYug77KcC2gDzgEcd0Gu9L871ibfErFGC725Ria14xXqUdYibg/132","nickname":"千锤百炼的大器","note":"","ucode":"4DE6083592C80D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383495,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626135711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0f/70/f59db672.jpg","nickname":"槑·先生","note":"","ucode":"897F0475592E3A","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352588,"discussion_content":"楼主这个问题反馈得好，引人思考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614776539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007330,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/e2/1fad3052.jpg","nickname":"Jemmy","note":"","ucode":"A979F4A5210225","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349456,"discussion_content":"C/C++ 不加任编译优化的汇编代码中 i, j, k 这三个局部变量在函数调用时只在栈上分配一次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613220405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007330,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/e2/1fad3052.jpg","nickname":"Jemmy","note":"","ucode":"A979F4A5210225","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349452,"discussion_content":"这个问题老师不回答下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613219114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260141,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","nickname":"Wheat","note":"","ucode":"7D99EA149B6DE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343128,"discussion_content":"第一个创建了1000次k和100次j，第二个创建了1000次k和10000次j，确实会有这样的损耗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610953933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2296545,"avatar":"","nickname":"范小曼","note":"","ucode":"E7F896BB78D7AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332366,"discussion_content":"留个坑，老师回复的话能收到通知","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607172917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325297,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg","nickname":"LW","note":"","ucode":"89820332658E98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307831,"discussion_content":"肉测了一下，确实如楼主所说，楼主牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600768223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065849,"avatar":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","nickname":"test","note":"","ucode":"9A4973E591DD12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276091,"discussion_content":"我试验了一下，还真是啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590814689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000060,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","nickname":"🄽🄸🅇🅄🅂","note":"","ucode":"853763C229A5AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255276,"discussion_content":"这么写，好像还是在for中声明变量，感觉和把变量写在括号中，没有什么区别，是不是应该把i、j、k三个变量，写在记录开始时间之前会更合适？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588388608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243901,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","nickname":"fcb的鱼","note":"","ucode":"88667EBF09CEC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161236,"discussion_content":"确实是创建了相同数量的临时变量啊，层主能否说的再明白一点.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580879458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1243901,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","nickname":"fcb的鱼","note":"","ucode":"88667EBF09CEC0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254422,"discussion_content":"因为采用了for(int..)这种类型的定义，for里面定义的变量的生存周期只有外部的一次循环，于是情况1：i生成1次，j生成100次，k生成100*1000=100000次，对于情况2：i生成1次，j生成10000次，k生成10000*1000=10000000次，临时变量都是存在栈中，确实情况2的出入栈次数要高得多","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1588325284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":161236,"ip_address":""},"score":254422,"extra":""}]},{"author":{"id":1012528,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/73/30/fd602742.jpg","nickname":"大马猴","note":"","ucode":"E3482CBDF43CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67211,"discussion_content":"希望老师回答一下，大家顶起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575125037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115532,"user_name":"焰火","can_delete":false,"product_type":"c1","uid":1244606,"ip_address":"","ucode":"D3353B386DE3B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg","comment_is_top":false,"comment_ctime":1563613384,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"113232763080","product_id":100026001,"comment_content":"以后写代码的时候养成良好习惯，按事件概率高低在分支中升序或降序安排，争取让状态机少判断","like_count":26,"discussions":[{"author":{"id":1713744,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/htzC3ImxibzOia06PkhxmHib8aXnFXqOSjbHiaveNkh26EtFDFxlAoXzyBdibDtGIIlmZhqumnAAaSGYGTPopY0kZicw/132","nickname":"boss_pi","note":"","ucode":"5EED6D9BA7F061","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378513,"discussion_content":"状态机状态迁移次数/判断次数是省不了的吧，即使是自转。而且这里应该更建议升序，虽然有分支预测，但降序还是会有更多判断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623252364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1221341,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a2/dd/1f426079.jpg","nickname":"风野","note":"","ucode":"BA1DA2AAC26C39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258068,"discussion_content":"好像按照概率高低对分支进行升序还是降序排列没什么用处，就像if - else 如果 else的概率高，分支预测器会记住else的选择，那么下次CPU还是会预加载else的内的指令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588643847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142025,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/09/ffeabc27.jpg","nickname":"任鑫","note":"","ucode":"9803EB15B634C3","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230726,"discussion_content":"这里有一个前提是需要清除自己使用机器的分支预测机制。然后根据这个机制决定优化代码逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586767115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16265,"discussion_content":"是让判断失误减少次数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568880284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1244606,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg","nickname":"焰火","note":"","ucode":"D3353B386DE3B5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18183,"discussion_content":"你说的只是包含了其中一种情况，真正的分支预测是根据前面的情况来推断后面的要发生的事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569030022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":16265,"ip_address":""},"score":18183,"extra":""}]}]},{"had_liked":false,"id":134137,"user_name":"韩俊臣","can_delete":false,"product_type":"c1","uid":1475340,"ip_address":"","ucode":"D6A15C025570D5","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/0c/b9e39db4.jpg","comment_is_top":false,"comment_ctime":1568766236,"is_pvip":false,"replies":[{"id":"52614","content":"韩俊臣同学，<br><br>你好，最内层的循环，要执行10000次，前面的9999次都是继续执行下一次循环指令，最后一次是结束循环。预测的话，前面9999次都会预测会继续执行指令，到最后一次的预测会出错。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1569653525,"ip_address":"","comment_id":134137,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57403341084","product_id":100026001,"comment_content":"”在这样的情况下，上面的第一段循环，也就是内层 k 循环 10000 次的代码。每隔 10000 次，才会发生一次预测上的错误。而这样的错误，在第二层 j 的循环发生的次数，是 1000 次。” <br>求老师和各位大佬指点下，这句没太看明白，为啥每隔10000次才出现一次预测错误","like_count":13,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467626,"discussion_content":"韩俊臣同学，\n\n你好，最内层的循环，要执行10000次，前面的9999次都是继续执行下一次循环指令，最后一次是结束循环。预测的话，前面9999次都会预测会继续执行指令，到最后一次的预测会出错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569653525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/fe/00ddeb81.jpg","nickname":"learn more","note":"","ucode":"0EF628B2E0F95E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39916,"discussion_content":"谢谢老师，这样子解释一下感觉舒服多了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572016604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222506,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1590822732,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"53130430284","product_id":100026001,"comment_content":"实验结果，首先是根据与“鱼向北游”同学的一致，把i j k放在循环外面，必须增大一万倍才有明显的性能差距（10倍左右）；<br>其次是那个循环的解释，我理解是，最内层的错误预测是一次，但是“底层循环”因为中层执行了1000次，所以是1000次错误判断，而中层的错误判断是一次，但是因为最外层循环导致“中层循环”执行了100次，所以是100次错误判断。","like_count":12,"discussions":[{"author":{"id":1241121,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f0/21/7168f973.jpg","nickname":"JStFs","note":"","ucode":"636E85653555DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315398,"discussion_content":"感谢这位仁兄，解释了我卡了半天的问题，确实是这样，所有的错误都是因为最内层的那一次而来的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603269155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200029,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4f/9d/72461b25.jpg","nickname":"子青","note":"","ucode":"F6D22EB15325FD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553498,"discussion_content":"计算中层错误判断次数时，是中层循环次数*底层错误次数。那中层本身还要错误一次，不应该再+1吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645932535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415283,"avatar":"https://static001.geekbang.org/account/avatar/00/24/da/b3/35859560.jpg","nickname":"Ciao🌚","note":"","ucode":"B048EC8A4A4D77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349224,"discussion_content":"6666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612980279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171662,"user_name":"许先森","can_delete":false,"product_type":"c1","uid":1795371,"ip_address":"","ucode":"1F42D4A6B5C6AF","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","comment_is_top":false,"comment_ctime":1578987671,"is_pvip":false,"replies":[{"id":"68099","content":"许先森同学，<br><br>你好，这里没有错哦。<br><br>cmp指令执行完之后，仍然是顺序执行下一条jmp指令。<br>但是jmp指令执行完之后，不一定是顺序执行jmp后面的指令，而是要看跳转是否发生，发生的话，执行的就是跳转地址之后的指令了。如果跳转没有发生，才是继续执行jmp后面地址的指令。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1580635402,"ip_address":"","comment_id":171662,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31643758743","product_id":100026001,"comment_content":"“要等 jmp 指令执行完成，去更新了 PC 寄存器之后，我们才能知道，是否执行下一条指令，还是跳转到另外一个内存地址，去取别的指令。”<br>这一段说错了吧？应该是cmp执行完，更新条件码寄存器，才能知道是否执行下一条还是跳转到另一个内存地址，取别的指令","like_count":7,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481459,"discussion_content":"许先森同学，\n\n你好，这里没有错哦。\n\ncmp指令执行完之后，仍然是顺序执行下一条jmp指令。\n但是jmp指令执行完之后，不一定是顺序执行jmp后面的指令，而是要看跳转是否发生，发生的话，执行的就是跳转地址之后的指令了。如果跳转没有发生，才是继续执行jmp后面地址的指令。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580635402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3010398,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/ef/5e/b6388859.jpg","nickname":"zoe1","note":"","ucode":"B9C29E05DD3FE2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":575203,"discussion_content":"决定要跳转的话，这样jmp指令执行的同时后面取指，译指，执行的指令就全部丢弃对吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654666095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":481459,"ip_address":""},"score":575203,"extra":""}]}]},{"had_liked":false,"id":106003,"user_name":"喜欢吃鱼","can_delete":false,"product_type":"c1","uid":1250205,"ip_address":"","ucode":"02F41572F53E3C","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/9d/d91dc762.jpg","comment_is_top":false,"comment_ctime":1561124061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31625895133","product_id":100026001,"comment_content":"哈哈，之前问今天这个程序问题的是我，明白了，谢谢老师的讲解。","like_count":7},{"had_liked":false,"id":207187,"user_name":"七色凉橙","can_delete":false,"product_type":"c1","uid":1241939,"ip_address":"","ucode":"8F39B511B15C57","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/53/c5a17618.jpg","comment_is_top":false,"comment_ctime":1587021556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27356825332","product_id":100026001,"comment_content":"可以对比陈皓博客里面CPU cache这篇文章一起理解一下：https:&#47;&#47;coolshell.cn&#47;articles&#47;10249.html","like_count":6},{"had_liked":false,"id":105793,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1004755,"ip_address":"","ucode":"9BB9A170023CD8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/d3/46fd4aa3.jpg","comment_is_top":false,"comment_ctime":1561084453,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18740953637","product_id":100026001,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tstart := time.Now()<br>\tfor i := 0; i &lt; 100; i++ {<br>\t\tfor j := 0; j &lt; 1000; j++ {<br>\t\t\tfor k := 0; k &lt; 10000; k++ {<br><br>\t\t\t}<br>\t\t}<br>\t}<br><br>\tfmt.Println(time.Since(start))<br><br>\tstart = time.Now()<br>\tfor i := 0; i &lt; 10000; i++ {<br>\t\tfor j := 0; j &lt; 1000; j++ {<br>\t\t\tfor k := 0; k &lt; 100; k++ {<br><br>\t\t\t}<br>\t\t}<br>\t}<br>\tfmt.Println(time.Since(start))<br><br>}<br>417.9044ms<br>544.5435ms","like_count":4,"discussions":[{"author":{"id":1143338,"avatar":"https://static001.geekbang.org/account/avatar/00/11/72/2a/c4042a20.jpg","nickname":"骑蜗牛的勇士","note":"","ucode":"2702AEEA14BC4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385131,"discussion_content":"数量级小呀，文中是5ms和15ms不看倍数差了10ms，这里如果算倍数是不到一倍，但是基数大544-417, 是27ms","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626915457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048356,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/24/29d5c610.jpg","nickname":"tina","note":"","ucode":"9F110914D7EB00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286288,"discussion_content":"为什么 go 语言不会出现像 Java 这么大的性能差异呢，求指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593101314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134316,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/ec/0340146a.jpg","nickname":"天涯咫尺间","note":"","ucode":"87D13B0C3FC35C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54091,"discussion_content":"Golang大法好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574258483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105752,"user_name":"pebble","can_delete":false,"product_type":"c1","uid":1022021,"ip_address":"","ucode":"871930CB227C68","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/45/318ba48a.jpg","comment_is_top":false,"comment_ctime":1561080864,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18740950048","product_id":100026001,"comment_content":"你的机子好厉害，第一个例子语言五毫秒，我测试，c语言需要4337跟4492毫秒，c#需要5367跟5585毫秒，看来cpu的分支预测机制有大的改进了，不知道是什么机制","like_count":4,"discussions":[{"author":{"id":1637933,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fe/2d/e23fc6ee.jpg","nickname":"深水蓝","note":"","ucode":"3E3B195DE54DE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182758,"discussion_content":"不会吧，差了将近1000倍的性能？你的CPU是什么CPU啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582455108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239710,"user_name":"树军","can_delete":false,"product_type":"c1","uid":1243906,"ip_address":"","ucode":"7BC6F00B94FB2F","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/02/1b74615c.jpg","comment_is_top":false,"comment_ctime":1596621594,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14481523482","product_id":100026001,"comment_content":"用Java来解释分支预测是不是不太合适，中间有一层虚拟机，和机器码完全对不上，影响性能的可能根本不是分支预测。","like_count":3,"discussions":[{"author":{"id":1143338,"avatar":"https://static001.geekbang.org/account/avatar/00/11/72/2a/c4042a20.jpg","nickname":"骑蜗牛的勇士","note":"","ucode":"2702AEEA14BC4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385132,"discussion_content":"有道理，可能被虚拟机优化掉了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626915542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313459,"user_name":"易飞","can_delete":false,"product_type":"c1","uid":2630424,"ip_address":"","ucode":"32AC28754237F7","user_header":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","comment_is_top":false,"comment_ctime":1632450993,"is_pvip":false,"replies":[{"id":"113914","content":"哈哈，这还真在我意料之外，不过作为解释性语言，也的确有可能发生这样的事情，回头我研究研究。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1633163074,"ip_address":"","comment_id":313459,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10222385585","product_id":100026001,"comment_content":"python，第一个例子60s,第二个例子53s","like_count":2,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527360,"discussion_content":"哈哈，这还真在我意料之外，不过作为解释性语言，也的确有可能发生这样的事情，回头我研究研究。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633163074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2285861,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/25/4b4e8c69.jpg","nickname":"liuzhijie","note":"","ucode":"5D475A9FF41E10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558842,"discussion_content":"我用C#的测试也是第一次更耗时，不知道什么原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648481520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107478,"user_name":"开心","can_delete":false,"product_type":"c1","uid":1517457,"ip_address":"","ucode":"C8E08E8724C7CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkzrezV2dOBAgickt9DLzabz3dNFYyDEVXENMQ5ibrWhFbFqXIOia3ZaR21pozvB7UfoxJx4Ar688sA/132","comment_is_top":false,"comment_ctime":1561542587,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10151477179","product_id":100026001,"comment_content":"如何检查是否执行错了指令，以及执行错指令如何处理还讲吗？","like_count":2},{"had_liked":false,"id":106091,"user_name":"haer","can_delete":false,"product_type":"c1","uid":1146728,"ip_address":"","ucode":"0216267E645431","user_header":"","comment_is_top":false,"comment_ctime":1561172274,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10151106866","product_id":100026001,"comment_content":"用Python实验的结果分别是165秒，139秒，后者的速度更快，为什么呢？<br><br>“许童童”的js实验，第二个循环的k应该&lt;100而不是&lt;1000","like_count":2,"discussions":[{"author":{"id":2192255,"avatar":"","nickname":"嘻嘻嘻","note":"","ucode":"84ED79E03135E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532110,"discussion_content":"python这种解释器语言不要拿来做这种实验了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637520432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316082,"user_name":"人什么人","can_delete":false,"product_type":"c1","uid":1983034,"ip_address":"","ucode":"052538EFD0B1D6","user_header":"https://static001.geekbang.org/account/avatar/00/1e/42/3a/bca96a7f.jpg","comment_is_top":false,"comment_ctime":1634126910,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5929094206","product_id":100026001,"comment_content":"老师，这句话我不太理解：不过只是改造硬件，并不能彻底解决问题。跳转指令的比较结果，仍然要在指令执行的时候才能知道。我们都已经在译码阶段做了比较了，为什么还是不知道结果？那译码阶段比较有啥意义？？？出不来结果的？","like_count":1},{"had_liked":false,"id":216790,"user_name":"吴贤龙","can_delete":false,"product_type":"c1","uid":1220566,"ip_address":"","ucode":"45085FE86D6030","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","comment_is_top":false,"comment_ctime":1589343188,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5884310484","product_id":100026001,"comment_content":"我用js和c#测试，怎么测出来的结果跟老师说的相反啊？ 而且再加多嵌套循环，相差越大，也还是跟老师说的相反呢？","like_count":1,"discussions":[{"author":{"id":2625245,"avatar":"https://static001.geekbang.org/account/avatar/00/28/0e/dd/4d468ad7.jpg","nickname":"__Alucard","note":"","ucode":"8766ECCC8C7283","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384051,"discussion_content":"数据量大上去会得到理想的结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626345403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2285861,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/25/4b4e8c69.jpg","nickname":"liuzhijie","note":"","ucode":"5D475A9FF41E10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337731,"discussion_content":"我用C#也是得到相反的结果。\n我用JS和老是的结果一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609060865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144735,"user_name":"learn more","can_delete":false,"product_type":"c1","uid":1128702,"ip_address":"","ucode":"0EF628B2E0F95E","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/fe/00ddeb81.jpg","comment_is_top":false,"comment_ctime":1572016781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866984077","product_id":100026001,"comment_content":"这个循环优化和数据库优化的小表驱动大表好像，原理应该不同哈！","like_count":1},{"had_liked":false,"id":109578,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1562060741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5857028037","product_id":100026001,"comment_content":"分支预测的状态流转图最左侧那个指向自身的箭头旁边的文字应该是Not Taken","like_count":1},{"had_liked":false,"id":105911,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1561103200,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5856070496","product_id":100026001,"comment_content":"用js写了一下，分别是343和3345毫秒，差了10倍<br>let prev = Date.now()<br>for (let i = 0; i &lt; 100; i ++) {<br>  for (let j = 0; j &lt; 1000; j ++) {<br>    for (let k = 0; k &lt; 10000; k ++) {<br><br>    }<br>  }<br>}<br>console.log(Date.now() - prev)<br><br>prev = Date.now()<br>for (let i = 0; i &lt; 10000; i ++) {<br>  for (let j = 0; j &lt; 1000; j ++) {<br>    for (let k = 0; k &lt; 1000; k ++) {<br><br>    }<br>  }<br>}<br>console.log(Date.now() - prev)","like_count":1,"discussions":[{"author":{"id":1169314,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d7/a2/5f6b90a9.jpg","nickname":"wuqilv","note":"","ucode":"B9C4A2C2FF32AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":134,"discussion_content":"第二段最内层多了个零。。。。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561133322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188905,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/29/041fb46a.jpg","nickname":"Yeah","note":"","ucode":"8B9EEE9C6975B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290121,"discussion_content":"老哥，你写错程序了，第二段最里面的k多了个零","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594349855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105702,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1561077087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856044383","product_id":100026001,"comment_content":"第一种，是进行条件比较。这个条件比较，需要的输入是，根据指令的 opcode，就能确认的条件码寄存器。这里的确认条件码寄存器不太理解，是不是比较确定条件码寄存器的值?","like_count":1},{"had_liked":false,"id":358572,"user_name":"woodie","can_delete":false,"product_type":"c1","uid":2004783,"ip_address":"北京","ucode":"1C2925AD8191DA","user_header":"","comment_is_top":false,"comment_ctime":1664435020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664435020","product_id":100026001,"comment_content":"冒险包括：结构冒险(资源层面解决)，数据冒险(停顿、操作数前推、乱序执行)，控制冒险(分之预测)","like_count":0},{"had_liked":false,"id":349636,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1096652,"ip_address":"","ucode":"E79CEA70430449","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","comment_is_top":false,"comment_ctime":1656169427,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656169427","product_id":100026001,"comment_content":"最后的for循环例子，妙啊！","like_count":0},{"had_liked":false,"id":321321,"user_name":"Geek_506cc6","can_delete":false,"product_type":"c1","uid":2812527,"ip_address":"","ucode":"3C02AD160C46DD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItGXkjpqnJ7hIl5bY3U6a8zicG3s641N9c1fuib05SZz4HysNvS1icTh98yN0ibmcicliaT8pKaN1WY4cw/132","comment_is_top":false,"comment_ctime":1636791231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636791231","product_id":100026001,"comment_content":"文中英文的状态转移图标注错了吧，最左侧的应该是not taken而非taken才对吧","like_count":0},{"had_liked":false,"id":313461,"user_name":"lanco","can_delete":false,"product_type":"c1","uid":1188352,"ip_address":"","ucode":"C24A0A8716C78C","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/00/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1632451401,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632451401","product_id":100026001,"comment_content":"长见识了，赞","like_count":0},{"had_liked":false,"id":311164,"user_name":"Geek_f4fb8b","can_delete":false,"product_type":"c1","uid":2756819,"ip_address":"","ucode":"32114B90BF7060","user_header":"","comment_is_top":false,"comment_ctime":1631092575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631092575","product_id":100026001,"comment_content":"start := time.Now()<br>\tfor i := 0; i &lt; 100; i++ {<br>\t\tfor j := 0; j &lt; 1000; j++ {<br>\t\t\tfor k := 0; k &lt; 10000; k++ {<br>\t\t\t}<br>\t\t}<br>\t}<br>\tfmt.Printf(&quot;first time spent:%f\\n&quot;, time.Since(start).Seconds())<br>\tstart2 := time.Now()<br>\tfor i := 0; i &lt; 10000; i++ {<br>\t\tfor j := 0; j &lt; 1000; j++ {<br>\t\t\tfor k := 0; k &lt; 100; k++ {<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\tfmt.Printf(&quot;second time spent:%f&quot;, time.Since(start2).Seconds())<br><br>=== RUN   TestBranchPrediction<br>first time spent:0.267257<br>second time spent:0.592444--- PASS: TestBranchPrediction (0.86s)<br>PASS","like_count":0},{"had_liked":false,"id":238815,"user_name":"Ethan","can_delete":false,"product_type":"c1","uid":1810189,"ip_address":"","ucode":"75F613D58909DB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ZHw73tgCqGKhvticUWGRz4icgicu4hFWfKtacoFJeItH7maNuNUmjnEgDTJvOibwUWgGV0p6guNPibMVWDV4BUmEmlA/132","comment_is_top":false,"comment_ctime":1596330722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596330722","product_id":100026001,"comment_content":"老师你好，那我们现在的CPU是【静态预测方案】还是【动态预测方案】？还是说两种都有？","like_count":0},{"had_liked":false,"id":237754,"user_name":"Geek_bb8d16","can_delete":false,"product_type":"c1","uid":1735740,"ip_address":"","ucode":"964BD4DB3D9653","user_header":"","comment_is_top":false,"comment_ctime":1595943401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595943401","product_id":100026001,"comment_content":"想到了股票的涨跌","like_count":0},{"had_liked":false,"id":231085,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1593578382,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593578382","product_id":100026001,"comment_content":"做分支预测时，都是以不跳转作为下一步操作的默认选项，当状态机中统计的被打断次数达到3次，就会预测下条指令也是打断指令，从而减少因指令打断得抛弃之前的操作的overhead","like_count":0},{"had_liked":false,"id":213110,"user_name":"简玉","can_delete":false,"product_type":"c1","uid":1013401,"ip_address":"","ucode":"C7F9471C7BFC7F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/99/00597feb.jpg","comment_is_top":false,"comment_ctime":1588303709,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588303709","product_id":100026001,"comment_content":"本机js的执行结果：<br>459ms<br>544ms<br>没有很大的差距<br><br>加一层10的循环，执行时间：<br>function firstLoop() {<br>    const start = new Date();<br>    for (let m = 0; m &lt; 10; m++) {<br>        for (let i = 0; i &lt; 100; i++) {<br>            for (let j = 0; j &lt; 1000; j++) {<br>                for (let k = 0; k &lt; 10000; k++) {<br>                }<br>            }<br>        }<br>    }<br>    const end = new Date();<br>    console.log(end - start);<br>}<br><br><br>function secondLoop() {<br>    const start = new Date();<br>    for (let i = 0; i &lt; 10000; i++) {<br>        for (let j = 0; j &lt; 1000; j++) {<br>            for (let k = 0; k &lt; 100; k++) {<br>                for (let m = 0; m &lt; 10; m++) {<br>                }<br>            }<br>        }<br>    }<br>    const end = new Date();<br>    console.log(end - start);<br>}<br>firstLoop()<br>secondLoop()<br><br>4555ms<br>5101ms<br>也没有拉开差距。猜测 V8引擎分支冒险采用了不同的策略（查不到相关资料）。","like_count":0,"discussions":[{"author":{"id":2582653,"avatar":"","nickname":"Geek_70a0ec","note":"","ucode":"74C7E58BBCA27F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378173,"discussion_content":"为啥我在chrome里边复制你的代码出来的是3578与6866","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623078068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209094,"user_name":"大俊stan","can_delete":false,"product_type":"c1","uid":1125370,"ip_address":"","ucode":"BD0CB5FC790DDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/fa/1cde88d4.jpg","comment_is_top":false,"comment_ctime":1587489403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587489403","product_id":100026001,"comment_content":"即时编译java的","like_count":0},{"had_liked":false,"id":207935,"user_name":"WENMURAN","can_delete":false,"product_type":"c1","uid":1915404,"ip_address":"","ucode":"5D1CE8B41937C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXNhbTULKiakib8lYXrvGF2zPwfedooBzC2EtSv1nt1MwV1KUvTkcJrvCBFvcdwJicnr3OEXnk9GUCg/132","comment_is_top":false,"comment_ctime":1587219018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587219018","product_id":100026001,"comment_content":"冒险和预测四:<br>数据冒险和结构冒险中的流水线停顿都是在指令执行阶段，而在之前的取指令和译指令阶段没有停顿，这是基于一个所有指令都顺序执行的假设，但如果是if条件或是for循环，就不行了。这就是控制冒险。<br>解决方案:一就是缩短分支迟延，类似于数据冒险中的操作数前堆，也是硬件改造。<br>二，分支预测，我们假装分支不存在，如果猜对，就剩下了停顿的时间，如果没猜对，那就清除","like_count":0},{"had_liked":false,"id":152516,"user_name":"Richard","can_delete":false,"product_type":"c1","uid":1316758,"ip_address":"","ucode":"893F958B9DD161","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","comment_is_top":false,"comment_ctime":1574038676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574038676","product_id":100026001,"comment_content":"因为分支预测失败，内外循环顺序不同导致性能表现的差异，让我联想到了SQL join两张表驱动表一定是行数较小的小表，驱动表的设计原理是否也是基于分支预测会失败这个底层原因呢？","like_count":0},{"had_liked":false,"id":142255,"user_name":"川云","can_delete":false,"product_type":"c1","uid":1265438,"ip_address":"","ucode":"3D56399A7C5BDF","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/1e/e2b7a9ba.jpg","comment_is_top":false,"comment_ctime":1571320922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571320922","product_id":100026001,"comment_content":"写完代码测试之前要先echo 3去 drop_cache，否则时间只有第一次运行是对的，后面就不对了","like_count":0},{"had_liked":false,"id":138941,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1570514269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570514269","product_id":100026001,"comment_content":"java 的例子受教了，之前都不知道这个。从代码上看 似乎没有太大的区别，性能上已经产生了3倍的差距，这就是差距。","like_count":0},{"had_liked":false,"id":135317,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1569124545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569124545","product_id":100026001,"comment_content":"1  因为在程序执行的时候存在for  while等跳转指令，所以指令在执行过程中会发生跳转，为了取到正确的指令，产生了控制冒险策略。<br>2  控制冒险策略，有缩短分支延迟，分支预测，动态分支预测。","like_count":0},{"had_liked":false,"id":106556,"user_name":"木偶人King","can_delete":false,"product_type":"c1","uid":1028805,"ip_address":"","ucode":"0BDCA51E6F0B76","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b2/c5/6ae0be56.jpg","comment_is_top":false,"comment_ctime":1561343182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561343182","product_id":100026001,"comment_content":"我跑了三次<br>            5     5ms<br>            4     6ms<br>            4      5ms<br>后续都是4   6和4   5交替出现<br><br>估计是<br><br>System Model:              HP Z440 Workstation<br>System Type:               x64-based PC<br>Processor(s):              1 Processor(s) Installed.<br>                           [01]: Intel64 Family 6 Model 79 Stepping 1 GenuineIntel ~3601 Mhz<br>BIOS Version:              Hewlett-Packard M60 v02.38, 11&#47;8&#47;2017<br>Windows Directory:         C:\\WINDOWS<br>System Directory:          C:\\WINDOWS\\system32<br>Boot Device:               \\Device\\HarddiskVolume2<br>System Locale:             en-us;English (United States)<br>Input Locale:              en-us;English (United States)<br>Time Zone:                 (UTC+08:00) Beijing, Chongqing, Hong Kong SAR, Urumqi<br>Total Physical Memory:     32,684 MB<br>Available Physical Memory: 19,554 MB<br>Virtual Memory: Max Size:  37,548 MB<br>Virtual Memory: Available: 23,509 MB<br>Virtual Memory: In Use:    14,039 MB","like_count":0}]}