{"id":380723,"title":"108 | Rust异步编程之生成器（一）","content":"<p><strong>课件及Demo下载链接</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geektime-Rust\">https://gitee.com/geektime-geekbang/geektime-Rust</a></p>","comments":[{"had_liked":false,"id":303990,"user_name":"蓬蒿","can_delete":false,"product_type":"c3","uid":1316758,"ip_address":"","ucode":"893F958B9DD161","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/96/a10524f5.jpg","comment_is_top":false,"comment_ctime":1627172147,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":2,"product_id":100060601,"comment_content":"张老师你好，关于yield后resume的时候，有个问题我一直不明白，就是在这种无栈协程模式下，resume的时候是如何恢复寄存器和函数栈帧的？我能理解协程无栈只是说协程这个执行体没有单独的栈，承载众多协程的线程是有栈的，我的理解是协程仍然使用的线程栈，协程本身包含在线程执行流里面。那么，在yield和resume的时候，协程的栈帧是如何被保存和恢复的呢？是不是我对无栈协程的理解有误？还请老师解惑！","like_count":0,"discussions":[{"author":{"id":1016404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/54/b9cd3674.jpg","nickname":"小可爱(`へ´*)ノ","note":"","ucode":"E75189846F6616","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619859,"discussion_content":"我觉得有可能是全部加载到线程栈里的，毕竟yied只是出让协程代码的执行，等于说yield后面的代码延迟执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685582165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1316758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/96/a10524f5.jpg","nickname":"蓬蒿","note":"","ucode":"893F958B9DD161","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/54/b9cd3674.jpg","nickname":"小可爱(`へ´*)ノ","note":"","ucode":"E75189846F6616","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620390,"discussion_content":"我看完了rust圣经之后，没有继续学rust，但是一直比较好奇rust的异步编程原理，因为它号称无栈协程嘛，但是它的协程调度和go的goroutine调度非常不同，goroutine调度非常类似于操作系统的线程调度，修改ip和sp就能改变cpu上的执行流。chatgpt大火之后，我问过它这个问题，大概明白了其原理，其实类似于tokio之类的异步运行时在调度协程时并没有我惯性思维中以为的那种保存寄存器恢复寄存器的过程，它的核心在于每个异步函数都会被编译为一个状态机，这个状态机是玄机所在，再加上一个pin的结构来保存和恢复一些中间变量或者说状态，这样一来，依靠epoll事件，调度器和执行器的配合，不停地去poll这个状态机就行了，事件的发生会导致状态的改变，从而执行不同状态下的代码。这种架构理解起来不算直观，不如go的协程好理解，但是个人认为在拥有大量并发的网络连接时，tokio的性能应该会比go有优势，因为执行器的线程是有限的，而go为每一个连接创建一个协程，即便是用户态调度，在拥有大量网络连接时必将会在调度上耗费过多的指令。一点浅见，未必正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686127577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":619859,"ip_address":"江苏","group_id":0},"score":620390,"extra":""}]}]}]}