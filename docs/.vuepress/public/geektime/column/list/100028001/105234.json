{"id":105234,"title":"20 | 答疑课堂：模块三热点问题解答","content":"<p>你好，我是刘超。</p><p>不知不觉“多线程性能优化“已经讲完了，今天这讲我来解答下各位同学在这个模块集中提出的两大问题，<span class=\"orange\">第一个是有关监测上下文切换异常的命令排查工具，第二个是有关blockingQueue的内容。</span></p><p>也欢迎你积极留言给我，让我知晓你想了解的内容，或者说出你的困惑，我们共同探讨。下面我就直接切入今天的主题了。</p><h2>使用系统命令查看上下文切换</h2><p>在第15讲中我提到了上下文切换，其中有用到一些工具进行监测，由于篇幅关系就没有详细介绍，今天我就补充总结几个常用的工具给你。</p><h3>1. Linux命令行工具之vmstat命令</h3><p>vmstat是一款指定采样周期和次数的功能性监测工具，我们可以<span class=\"orange\">使用它监控进程上下文切换的情况。</span></p><p><img src=\"https://static001.geekbang.org/resource/image/13/71/13eeee053c553863b3bdd95c07cb3b71.jpg?wh=1362*166\" alt=\"\"></p><p>vmstat 1 3  命令行代表每秒收集一次性能指标，总共获取3次。以下为上图中各个性能指标的注释：</p><ul>\n<li><strong>procs</strong><br>\nr：等待运行的进程数<br>\nb：处于非中断睡眠状态的进程数</li>\n<li><strong>memory</strong><br>\nswpd：虚拟内存使用情况<br>\nfree：空闲的内存<br>\nbuff：用来作为缓冲的内存数<br>\ncache：缓存大小</li>\n<li><strong>swap</strong><br>\nsi：从磁盘交换到内存的交换页数量<br>\nso：从内存交换到磁盘的交换页数量</li>\n<li><strong>io</strong><br>\nbi：发送到块设备的块数<br>\nbo：从块设备接收到的块数</li>\n<li><strong>system</strong><br>\nin：每秒中断数<br>\ncs：每秒上下文切换次数</li>\n<li><strong>cpu</strong><br>\nus：用户CPU使用时间<br>\nsy：内核CPU系统使用时间<br>\nid：空闲时间<br>\nwa：等待I/O时间<br>\nst：运行虚拟机窃取的时间</li>\n</ul><!-- [[[read_end]]] --><h3>2. Linux命令行工具之pidstat命令</h3><p>我们通过上述的vmstat命令只能观察到哪个进程的上下文切换出现了异常，那如果是要查看哪个线程的上下文出现了异常呢？</p><p><span class=\"orange\">pidstat命令就可以帮助我们监测到具体线程的上下文切换。</span>pidstat是Sysstat中一个组件，也是一款功能强大的性能监测工具。我们可以通过命令  yum install sysstat  安装该监控组件。</p><p>通过pidstat -help命令，我们可以查看到有以下几个常用参数可以监测线程的性能：</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/d1/7a93cba1673119e4c9162a29e9875dd1.jpg?wh=1316*170\" alt=\"\"></p><p>常用参数：</p><ul>\n<li>-u：默认参数，显示各个进程的cpu使用情况；</li>\n<li>-r：显示各个进程的内存使用情况；</li>\n<li>-d：显示各个进程的I/O使用情况；</li>\n<li>-w：显示每个进程的上下文切换情况；</li>\n<li>-p：指定进程号；</li>\n<li>-t：显示进程中线程的统计信息</li>\n</ul><p>首先，通过pidstat -w -p pid 命令行，我们可以查看到进程的上下文切换：</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/4f/3e6cee25e85826aa5d4f8f480535234f.jpg?wh=1524*140\" alt=\"\"></p><ul>\n<li>cswch/s：每秒主动任务上下文切换数量</li>\n<li>nvcswch/s：每秒被动任务上下文切换数量</li>\n</ul><p>之后，通过pidstat -w -p pid -t 命令行，我们可以查看到具体线程的上下文切换：</p><p><img src=\"https://static001.geekbang.org/resource/image/72/6f/728b1634e3e9971307264b5736cb1c6f.jpg?wh=1572*918\" alt=\"\"></p><h3>3. JDK工具之jstack命令</h3><p>查看具体线程的上下文切换异常，我们还<span class=\"orange\">可以使用jstack命令查看线程堆栈的运行情况</span>。jstack是JDK自带的线程堆栈分析工具，使用该命令可以查看或导出 Java 应用程序中的线程堆栈信息。</p><p>jstack最常用的功能就是使用 jstack pid 命令查看线程堆栈信息，通常是结合pidstat -p pid -t一起查看具体线程的状态，也经常用来排查一些死锁的异常。</p><p><img src=\"https://static001.geekbang.org/resource/image/0e/1d/0e61a2f4eb945f5a26bd7987d0babd1d.jpg?wh=2224*382\" alt=\"\"></p><p>每个线程堆栈的信息中，都可以查看到线程ID、线程状态（wait、sleep、running等状态）以及是否持有锁等。</p><p>我们可以通过jstack 16079 &gt; /usr/dump将线程堆栈信息日志dump下来，之后打开dump文件，通过查看线程的状态变化，就可以找出导致上下文切换异常的具体原因。例如，系统出现了大量处于BLOCKED状态的线程，我们就需要立刻分析代码找出原因。</p><h2>多线程队列</h2><p>针对这讲的第一个问题，一份上下文切换的命令排查工具就总结完了。下面我来解答第二个问题，是在17讲中呼声比较高的有关blockingQueue的内容。</p><p>在Java多线程应用中，特别是在线程池中，队列的使用率非常高。Java提供的线程安全队列又分为了阻塞队列和非阻塞队列。</p><h3>1.阻塞队列</h3><p>我们先来看下阻塞队列。阻塞队列可以很好地支持生产者和消费者模式的相互等待，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线程会阻塞直到队列不满。</p><p>在Java线程池中，也用到了阻塞队列。当创建的线程数量超过核心线程数时，新建的任务将会被放到阻塞队列中。我们可以根据自己的业务需求来选择使用哪一种阻塞队列，阻塞队列通常包括以下几种：</p><ul>\n<li><strong> ArrayBlockingQueue：</strong>一个基于数组结构实现的有界阻塞队列，按 FIFO（先进先出）原则对元素进行排序，使用ReentrantLock、Condition来实现线程安全；</li>\n<li><strong> LinkedBlockingQueue：</strong>一个基于链表结构实现的阻塞队列，同样按FIFO （先进先出） 原则对元素进行排序，使用ReentrantLock、Condition来实现线程安全，吞吐量通常要高于ArrayBlockingQueue；</li>\n<li><strong>PriorityBlockingQueue：</strong>一个具有优先级的无限阻塞队列，基于二叉堆结构实现的无界限（最大值Integer.MAX_VALUE - 8）阻塞队列，队列没有实现排序，但每当有数据变更时，都会将最小或最大的数据放在堆最上面的节点上，该队列也是使用了ReentrantLock、Condition实现的线程安全；</li>\n<li><strong>DelayQueue：</strong>一个支持延时获取元素的无界阻塞队列，基于PriorityBlockingQueue扩展实现，与其不同的是实现了Delay延时接口；</li>\n<li><strong>SynchronousQueue：</strong>一个不存储多个元素的阻塞队列，每次进行放入数据时, 必须等待相应的消费者取走数据后，才可以再次放入数据，该队列使用了两种模式来管理元素，一种是使用先进先出的队列，一种是使用后进先出的栈，使用哪种模式可以通过构造函数来指定。</li>\n</ul><p>Java线程池Executors还实现了以下四种类型的ThreadPoolExecutor，分别对应以上队列，详情如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/59/da/59e1d01c8a60fe722aae01db86a913da.jpg?wh=958*332\" alt=\"\"></p><h3>2.非阻塞队列</h3><p>我们常用的线程安全的非阻塞队列是ConcurrentLinkedQueue，它是一种无界线程安全队列(FIFO)，基于链表结构实现，利用CAS乐观锁来保证线程安全。</p><p>下面我们通过源码来分析下该队列的构造、入列以及出列的具体实现。</p><p><strong>构造函数：</strong>ConcurrentLinkedQueue由head 、tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用 (next) 组成，节点与节点之间通过 next 关联，从而组成一张链表结构的队列。在队列初始化时， head  节点存储的元素为空，tail 节点等于 head 节点。</p><pre><code>public ConcurrentLinkedQueue() {\n   head = tail = new Node&lt;E&gt;(null);\n}\n\nprivate static class Node&lt;E&gt; {\n        volatile E item;\n        volatile Node&lt;E&gt; next;\n            .\n            .\n}\n</code></pre><p><strong>入列：</strong>当一个线程入列一个数据时，会将该数据封装成一个Node节点，并先获取到队列的队尾节点，当确定此时队尾节点的next值为null之后，再通过CAS将新队尾节点的next值设为新节点。此时p != t，也就是设置next值成功，然后再通过CAS将队尾节点设置为当前节点即可。</p><pre><code>public boolean offer(E e) {\n        checkNotNull(e);\n        //创建入队节点\n        final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);\n        //t，p为尾节点，默认相等，采用失败即重试的方式，直到入队成功         \n        for (Node&lt;E&gt; t = tail, p = t;;) {\n            //获取队尾节点的下一个节点\n            Node&lt;E&gt; q = p.next;\n            //如果q为null，则代表p就是队尾节点\n            if (q == null) {\n                //将入列节点设置为当前队尾节点的next节点\n                if (p.casNext(null, newNode)) {\n                    //判断tail节点和p节点距离达到两个节点\n                    if (p != t) // hop two nodes at a time\n                        //如果tail不是尾节点则将入队节点设置为tail。\n                        // 如果失败了，那么说明有其他线程已经把tail移动过 \n                        casTail(t, newNode);  // Failure is OK.\n                    return true;\n                }\n            }\n            // 如果p节点等于p的next节点，则说明p节点和q节点都为空，表示队列刚初始化，所以返回  \n            else if (p == q)\n                p = (t != (t = tail)) ? t : head;\n            else\n                // Check for tail updates after two hops.\n                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;\n        }\n    }\n</code></pre><p><strong>出列：</strong>首先获取head节点，并判断item是否为null，如果为空，则表示已经有一个线程刚刚进行了出列操作，然后更新head节点；如果不为空，则使用CAS操作将head节点设置为null，CAS就会成功地直接返回节点元素，否则还是更新head节点。</p><pre><code>    public E poll() {\n        // 设置起始点\n        restartFromHead:\n        for (;;) {\n            //p获取head节点\n            for (Node&lt;E&gt; h = head, p = h, q;;) {\n                //获取头节点元素\n                E item = p.item;\n                //如果头节点元素不为null，通过cas设置p节点引用的元素为null\n                if (item != null &amp;&amp; p.casItem(item, null)) {\n                    // Successful CAS is the linearization point\n                    // for item to be removed from this queue.\n                    if (p != h) // hop two nodes at a time\n                        updateHead(h, ((q = p.next) != null) ? q : p);\n                    return item;\n                }\n                //如果p节点的下一个节点为null，则说明这个队列为空，更新head结点\n                else if ((q = p.next) == null) {\n                    updateHead(h, p);\n                    return null;\n                }\n                //节点出队失败，重新跳到restartFromHead来进行出队\n                else if (p == q)\n                    continue restartFromHead;\n                else\n                    p = q;\n            }\n        }\n    }\n</code></pre><p>ConcurrentLinkedQueue是基于CAS乐观锁实现的，在并发时的性能要好于其它阻塞队列，因此<span class=\"orange\">很适合作为高并发场景下的排队队列。</span></p><p>今天的答疑就到这里，如果你还有其它问题，请在留言区中提出，我会一一解答。最后欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他加入讨论。</p><p></p>","neighbors":{"left":{"article_title":"19 | 如何用协程来优化多线程业务？","id":104521},"right":{"article_title":"加餐 | 什么是数据的强、弱一致性？","id":105756}},"comments":[{"had_liked":false,"id":113812,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1563160227,"is_pvip":false,"replies":[{"id":"43541","content":"对的，Disruptor是一款性能更高的有界队列，利用了生产者消费者模式实现，并采用无锁算法、避免伪共享、RingBuffer等优化手段提升该队列框架性能。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564450689,"ip_address":"","comment_id":113812,"utype":1}],"discussion_count":1,"race_medal":0,"score":"83167538851","product_id":100028001,"comment_content":"老师  Disruptor是不是比ConcurrentLinkedQueue性能更强呢???","like_count":20,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458396,"discussion_content":"对的，Disruptor是一款性能更高的有界队列，利用了生产者消费者模式实现，并采用无锁算法、避免伪共享、RingBuffer等优化手段提升该队列框架性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564450689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110308,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1562227965,"is_pvip":false,"replies":[{"id":"40170","content":"GC在核心业务应用服务中越久发生越合适，且GC的时间不要太长。一般生产环境的FGC几天一次是比较正常的。40个线程是不是设置太大了，建议调小一些，当然需要你们具体压测验证下调小后的性能情况。<br><br>年轻代可以调大一些，如果年轻代太小，当MinorGC时，发现年轻代依然存活满对象，新的对象可能将无法放入到年轻代，则会通过分配担保机制提前转移年轻代的存活对象到老年代中，这样反而会增加老年代的负担。默认情况下老年代和新生代是2:1。建议没有特殊情况，不要固定设置老年代和新生代。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562290588,"ip_address":"","comment_id":110308,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74576671997","product_id":100028001,"comment_content":"老师好!FGC正常情况多久一次比较合适啊?我们项目1.2天一次FGC老年代给了3G年轻代1G想吧年轻代给多点。有个定时任务，2小时一次用的线程池。给了40个线程并发请求4K次。设置了空闲回收策略回收核心线程。现在就是定时任务，每次都新建40个线程一张吃老年代内存。不设置回收这些线程不实用的那个吧小时就一直阻塞。怎么处理比较合适","like_count":18,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456809,"discussion_content":"GC在核心业务应用服务中越久发生越合适，且GC的时间不要太长。一般生产环境的FGC几天一次是比较正常的。40个线程是不是设置太大了，建议调小一些，当然需要你们具体压测验证下调小后的性能情况。\n\n年轻代可以调大一些，如果年轻代太小，当MinorGC时，发现年轻代依然存活满对象，新的对象可能将无法放入到年轻代，则会通过分配担保机制提前转移年轻代的存活对象到老年代中，这样反而会增加老年代的负担。默认情况下老年代和新生代是2:1。建议没有特殊情况，不要固定设置老年代和新生代。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562290588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110123,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1562199109,"is_pvip":false,"replies":[{"id":"40176","content":"CPU消耗过高会引起上下文切换的增加，但并不代表这个就不正常了。正常情况下上下文切换在几百到几千，高峰时段会上升至几万，甚至几十万。<br><br>如果上下文长时间处于高位，这个时候我们就要注意了，这种情况有可能是某个线程长期占用CPU，例如之前我提到过的正则表达式出现的严重的回溯问题，就会在某一次回溯时，一直占用CPU，CPU的使用率高居不下，会导致上下文切换激增。<br><br>另外一种情况，就是之前你们的业务在高峰值出现的上下文切换在某个值，但是在业务迭代之后，高峰期的上下文切换的值异常高于之前的监控值。比如，我之前说的线程大小调整，导致了高峰期的上下文高出了十几倍之多。<br><br>ConcurrentLinkedQueue CAS操作会消耗CPU，但会及时释放，这不足以影响到系统的整体性能。<br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562291501,"ip_address":"","comment_id":110123,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31626970181","product_id":100028001,"comment_content":"我有2个问题想请教老师：<br><br>1 系统出现问题时我们一般会首先关注资源的使用情况，什么情况下可能是是上下文切换过多导致的呢？CPU消耗过高？<br><br>2 ConcurrentLinkedQueue是非阻塞的，是否意味着它会消耗过多的CPu","like_count":7,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456731,"discussion_content":"CPU消耗过高会引起上下文切换的增加，但并不代表这个就不正常了。正常情况下上下文切换在几百到几千，高峰时段会上升至几万，甚至几十万。\n\n如果上下文长时间处于高位，这个时候我们就要注意了，这种情况有可能是某个线程长期占用CPU，例如之前我提到过的正则表达式出现的严重的回溯问题，就会在某一次回溯时，一直占用CPU，CPU的使用率高居不下，会导致上下文切换激增。\n\n另外一种情况，就是之前你们的业务在高峰值出现的上下文切换在某个值，但是在业务迭代之后，高峰期的上下文切换的值异常高于之前的监控值。比如，我之前说的线程大小调整，导致了高峰期的上下文高出了十几倍之多。\n\nConcurrentLinkedQueue CAS操作会消耗CPU，但会及时释放，这不足以影响到系统的整体性能。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562291501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189252,"user_name":"Dowen Liu","can_delete":false,"product_type":"c1","uid":1440423,"ip_address":"","ucode":"DD072D44AD353D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLCrJQ4AZe8VrDkR6IO03V4Tda9WexVT4zZiahBjLSYOnZb1Y49JvD2f70uQwYSMibUMQvib9NmGxEiag/132","comment_is_top":false,"comment_ctime":1584493239,"is_pvip":false,"replies":[{"id":"73032","content":"LinkedBlockingQueue实现了读写锁分离，所以在一些场景下要比ArrayBlockingQueue快。ArrayBlockingQueue就是正常的锁实现，没有使用复制","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584533784,"ip_address":"","comment_id":189252,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23059329719","product_id":100028001,"comment_content":"LinkedBlockingQueue为什么会比ArrayBlockingQueue 快？我记得ArrayBlockingQueue内部应该是循环数组的方式，没有数据搬移和复制的。","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487650,"discussion_content":"LinkedBlockingQueue实现了读写锁分离，所以在一些场景下要比ArrayBlockingQueue快。ArrayBlockingQueue就是正常的锁实现，没有使用复制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584533784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110183,"user_name":"咬你","can_delete":false,"product_type":"c1","uid":1205131,"ip_address":"","ucode":"20936552FFE31B","user_header":"https://static001.geekbang.org/account/avatar/00/12/63/8b/e94448be.jpg","comment_is_top":false,"comment_ctime":1562204505,"is_pvip":false,"replies":[{"id":"40396","content":"一般系统出现性能瓶颈，可以结果上下文切换指标进行分析。在之前15讲中，我已经通过一个真实案例讲解了，可以参考下，有什么问题欢迎沟通。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562466009,"ip_address":"","comment_id":110183,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10152139097","product_id":100028001,"comment_content":"老师，通过vmstat参数获取的参数，可否结合一些真实场景，分析下什么样的数据范围属于正常范围，出现什么样的参数，我们就需要重点关注","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456763,"discussion_content":"一般系统出现性能瓶颈，可以结果上下文切换指标进行分析。在之前15讲中，我已经通过一个真实案例讲解了，可以参考下，有什么问题欢迎沟通。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562466009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320786,"user_name":"徐云天","can_delete":false,"product_type":"c1","uid":1212091,"ip_address":"","ucode":"D48DBF0B3C2CA3","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/bb/019c18fc.jpg","comment_is_top":false,"comment_ctime":1636511001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5931478297","product_id":100028001,"comment_content":"云里雾里的：有篇文章详解了ConcurrentLinkedQueue<br><br>https:&#47;&#47;www.jianshu.com&#47;p&#47;08e8b0c424c0","like_count":2},{"had_liked":false,"id":132430,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568120246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863087542","product_id":100028001,"comment_content":"打卡+点赞","like_count":1},{"had_liked":false,"id":338049,"user_name":"白不吃","can_delete":false,"product_type":"c1","uid":1033578,"ip_address":"","ucode":"F019914D8819C2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","comment_is_top":false,"comment_ctime":1647255986,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1647255986","product_id":100028001,"comment_content":"CAS是不是比加锁的方案，更消耗CPU资源一些","like_count":0},{"had_liked":false,"id":301125,"user_name":"书策稠浊","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1625545827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625545827","product_id":100028001,"comment_content":"一个不存储多个元素的阻塞队列，每次进行放入数据时, 必须等待相应的消费者取走数据后，才可以再次放入数据。都不存储多个了，还哪来的先进先出？","like_count":0},{"had_liked":false,"id":270668,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609211296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609211296","product_id":100028001,"comment_content":"Node t = tail, p = t;<br>p和t都是指向的tail指向的堆空间.<br>p.casNext  修改的是tail节点的下一个节点.<br>为什么修改下一个节点之后就会出现p!=t的情况呢?这俩不还是tail指向的堆内存空间吗?<br>我好晕啊老师...","like_count":0},{"had_liked":false,"id":270666,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609211027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609211027","product_id":100028001,"comment_content":"老师代码里的 if (p != t) 不太明白. Node t = tail, p = t; 这样的话 p不是永远都等于t吗?   ","like_count":0},{"had_liked":false,"id":270663,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609210395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609210395","product_id":100028001,"comment_content":"SynchronousQueue：一个不存储多个元素的阻塞队列，每次进行放入数据时, 必须等待相应的消费者取走数据后，才可以再次放入数据，该队列使用了两种模式来管理元素，一种是使用先进先出的队列，一种是使用后进先出的栈，使用哪种模式可以通过构造函数来指定。<br>老师这个队列就存放一个元素,先进先出还是先进后出有意义吗?","like_count":1},{"had_liked":false,"id":110125,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1562199298,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562199298","product_id":100028001,"comment_content":"性能好是一方面，如果是抢购应用在需要用有界队列","like_count":0,"discussions":[{"author":{"id":1584786,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2e/92/e1c38ca6.jpg","nickname":"KamTo  Hung","note":"","ucode":"00D5A6479DB784","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364477,"discussion_content":"Linked也能设置容量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617500870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}