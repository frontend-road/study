{"id":92524,"title":"26 | Fork/Join：单机版的MapReduce","content":"<p>前面几篇文章我们介绍了线程池、Future、CompletableFuture和CompletionService，仔细观察你会发现这些工具类都是在帮助我们站在任务的视角来解决并发问题，而不是让我们纠缠在线程之间如何协作的细节上（比如线程之间如何实现等待、通知等）。<strong>对于简单的并行任务，你可以通过“线程池+Future”的方案来解决；如果任务之间有聚合关系，无论是AND聚合还是OR聚合，都可以通过CompletableFuture来解决；而批量的并行任务，则可以通过CompletionService来解决。</strong></p><p>我们一直讲，并发编程可以分为三个层面的问题，分别是分工、协作和互斥，当你关注于任务的时候，你会发现你的视角已经从并发编程的细节中跳出来了，你应用的更多的是现实世界的思维模式，类比的往往是现实世界里的分工，所以我把线程池、Future、CompletableFuture和CompletionService都列到了分工里面。</p><p>下面我用现实世界里的工作流程图描述了并发编程领域的简单并行任务、聚合任务和批量并行任务，辅以这些流程图，相信你一定能将你的思维模式转换到现实世界里来。</p><p><img src=\"https://static001.geekbang.org/resource/image/47/2d/47f3e1e8834c99d9a1933fb496ffde2d.png?wh=1142*706\" alt=\"\"></p><center><span class=\"reference\">从上到下，依次为简单并行任务、聚合任务和批量并行任务示意图</span></center><!-- [[[read_end]]] --><p>上面提到的简单并行、聚合、批量并行这三种任务模型，基本上能够覆盖日常工作中的并发场景了，但还是不够全面，因为还有一种“分治”的任务模型没有覆盖到。<strong>分治</strong>，顾名思义，即分而治之，是一种解决复杂问题的思维方法和模式；具体来讲，指的是<strong>把一个复杂的问题分解成多个相似的子问题，然后再把子问题分解成更小的子问题，直到子问题简单到可以直接求解</strong>。理论上来讲，解决每一个问题都对应着一个任务，所以对于问题的分治，实际上就是对于任务的分治。</p><p>分治思想在很多领域都有广泛的应用，例如算法领域有分治算法（归并排序、快速排序都属于分治算法，二分法查找也是一种分治算法）；大数据领域知名的计算框架MapReduce背后的思想也是分治。既然分治这种任务模型如此普遍，那Java显然也需要支持，Java并发包里提供了一种叫做Fork/Join的并行计算框架，就是用来支持分治这种任务模型的。</p><h2>分治任务模型</h2><p>这里你需要先深入了解一下分治任务模型，分治任务模型可分为两个阶段：一个阶段是<strong>任务分解</strong>，也就是将任务迭代地分解为子任务，直至子任务可以直接计算出结果；另一个阶段是<strong>结果合并</strong>，即逐层合并子任务的执行结果，直至获得最终结果。下图是一个简化的分治任务模型图，你可以对照着理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/6a/d2649d8db8e5642703aa5563d76eb86a.png?wh=1142*711\" alt=\"\"></p><center><span class=\"reference\">简版分治任务模型图</span></center><p>在这个分治任务模型里，任务和分解后的子任务具有相似性，这种相似性往往体现在任务和子任务的算法是相同的，但是计算的数据规模是不同的。具备这种相似性的问题，我们往往都采用递归算法。</p><h2>Fork/Join的使用</h2><p>Fork/Join是一个并行计算的框架，主要就是用来支持分治任务模型的，这个计算框架里的<strong>Fork对应的是分治任务模型里的任务分解，Join对应的是结果合并</strong>。Fork/Join计算框架主要包含两部分，一部分是<strong>分治任务的线程池ForkJoinPool</strong>，另一部分是<strong>分治任务ForkJoinTask</strong>。这两部分的关系类似于ThreadPoolExecutor和Runnable的关系，都可以理解为提交任务到线程池，只不过分治任务有自己独特类型ForkJoinTask。</p><p>ForkJoinTask是一个抽象类，它的方法有很多，最核心的是fork()方法和join()方法，其中fork()方法会异步地执行一个子任务，而join()方法则会阻塞当前线程来等待子任务的执行结果。ForkJoinTask有两个子类——RecursiveAction和RecursiveTask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法compute()，不过区别是RecursiveAction定义的compute()没有返回值，而RecursiveTask定义的compute()方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。</p><p>接下来我们就来实现一下，看看如何用Fork/Join这个并行计算框架计算斐波那契数列（下面的代码源自Java官方示例）。首先我们需要创建一个分治任务线程池以及计算斐波那契数列的分治任务，之后通过调用分治任务线程池的 invoke() 方法来启动分治任务。由于计算斐波那契数列需要有返回值，所以Fibonacci 继承自RecursiveTask。分治任务Fibonacci 需要实现compute()方法，这个方法里面的逻辑和普通计算斐波那契数列非常类似，区别之处在于计算 <code>Fibonacci(n - 1)</code> 使用了异步子任务，这是通过 <code>f1.fork()</code> 这条语句实现的。</p><pre><code>static void main(String[] args){\n  //创建分治任务线程池  \n  ForkJoinPool fjp = \n    new ForkJoinPool(4);\n  //创建分治任务\n  Fibonacci fib = \n    new Fibonacci(30);   \n  //启动分治任务  \n  Integer result = \n    fjp.invoke(fib);\n  //输出结果  \n  System.out.println(result);\n}\n//递归任务\nstatic class Fibonacci extends \n    RecursiveTask&lt;Integer&gt;{\n  final int n;\n  Fibonacci(int n){this.n = n;}\n  protected Integer compute(){\n    if (n &lt;= 1)\n      return n;\n    Fibonacci f1 = \n      new Fibonacci(n - 1);\n    //创建子任务  \n    f1.fork();\n    Fibonacci f2 = \n      new Fibonacci(n - 2);\n    //等待子任务结果，并合并结果  \n    return f2.compute() + f1.join();\n  }\n}\n</code></pre><h2>ForkJoinPool工作原理</h2><p>Fork/Join并行计算的核心组件是ForkJoinPool，所以下面我们就来简单介绍一下ForkJoinPool的工作原理。</p><p>通过专栏前面文章的学习，你应该已经知道ThreadPoolExecutor本质上是一个生产者-消费者模式的实现，内部有一个任务队列，这个任务队列是生产者和消费者通信的媒介；ThreadPoolExecutor可以有多个工作线程，但是这些工作线程都共享一个任务队列。</p><p>ForkJoinPool本质上也是一个生产者-消费者的实现，但是更加智能，你可以参考下面的ForkJoinPool工作原理图来理解其原理。ThreadPoolExecutor内部只有一个任务队列，而ForkJoinPool内部有多个任务队列，当我们通过ForkJoinPool的invoke()或者submit()方法提交任务时，ForkJoinPool根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。</p><p>如果工作线程对应的任务队列空了，是不是就没活儿干了呢？不是的，ForkJoinPool支持一种叫做“<strong>任务窃取</strong>”的机制，如果工作线程空闲了，那它可以“窃取”其他工作任务队列里的任务，例如下图中，线程T2对应的任务队列已经空了，它可以“窃取”线程T1对应的任务队列的任务。如此一来，所有的工作线程都不会闲下来了。</p><p>ForkJoinPool中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。我们这里介绍的仅仅是简化后的原理，ForkJoinPool的实现远比我们这里介绍的复杂，如果你感兴趣，建议去看它的源码。</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/31/e75988bd5a79652d8325ca63fcd55131.png?wh=1142*677\" alt=\"\"></p><center><span class=\"reference\">ForkJoinPool工作原理图</span></center><h2>模拟MapReduce统计单词数量</h2><p>学习MapReduce有一个入门程序，统计一个文件里面每个单词的数量，下面我们来看看如何用Fork/Join并行计算框架来实现。</p><p>我们可以先用二分法递归地将一个文件拆分成更小的文件，直到文件里只有一行数据，然后统计这一行数据里单词的数量，最后再逐级汇总结果，你可以对照前面的简版分治任务模型图来理解这个过程。</p><p>思路有了，我们马上来实现。下面的示例程序用一个字符串数组 <code>String[] fc</code> 来模拟文件内容，fc里面的元素与文件里面的行数据一一对应。关键的代码在 <code>compute()</code> 这个方法里面，这是一个递归方法，前半部分数据fork一个递归任务去处理（关键代码mr1.fork()），后半部分数据则在当前任务中递归处理（mr2.compute()）。</p><pre><code>static void main(String[] args){\n  String[] fc = {&quot;hello world&quot;,\n          &quot;hello me&quot;,\n          &quot;hello fork&quot;,\n          &quot;hello join&quot;,\n          &quot;fork join in world&quot;};\n  //创建ForkJoin线程池    \n  ForkJoinPool fjp = \n      new ForkJoinPool(3);\n  //创建任务    \n  MR mr = new MR(\n      fc, 0, fc.length);  \n  //启动任务    \n  Map&lt;String, Long&gt; result = \n      fjp.invoke(mr);\n  //输出结果    \n  result.forEach((k, v)-&gt;\n    System.out.println(k+&quot;:&quot;+v));\n}\n//MR模拟类\nstatic class MR extends \n  RecursiveTask&lt;Map&lt;String, Long&gt;&gt; {\n  private String[] fc;\n  private int start, end;\n  //构造函数\n  MR(String[] fc, int fr, int to){\n    this.fc = fc;\n    this.start = fr;\n    this.end = to;\n  }\n  @Override protected \n  Map&lt;String, Long&gt; compute(){\n    if (end - start == 1) {\n      return calc(fc[start]);\n    } else {\n      int mid = (start+end)/2;\n      MR mr1 = new MR(\n          fc, start, mid);\n      mr1.fork();\n      MR mr2 = new MR(\n          fc, mid, end);\n      //计算子任务，并返回合并的结果    \n      return merge(mr2.compute(),\n          mr1.join());\n    }\n  }\n  //合并结果\n  private Map&lt;String, Long&gt; merge(\n      Map&lt;String, Long&gt; r1, \n      Map&lt;String, Long&gt; r2) {\n    Map&lt;String, Long&gt; result = \n        new HashMap&lt;&gt;();\n    result.putAll(r1);\n    //合并结果\n    r2.forEach((k, v) -&gt; {\n      Long c = result.get(k);\n      if (c != null)\n        result.put(k, c+v);\n      else \n        result.put(k, v);\n    });\n    return result;\n  }\n  //统计单词数量\n  private Map&lt;String, Long&gt; \n      calc(String line) {\n    Map&lt;String, Long&gt; result =\n        new HashMap&lt;&gt;();\n    //分割单词    \n    String [] words = \n        line.split(&quot;\\\\s+&quot;);\n    //统计单词数量    \n    for (String w : words) {\n      Long v = result.get(w);\n      if (v != null) \n        result.put(w, v+1);\n      else\n        result.put(w, 1L);\n    }\n    return result;\n  }\n}\n</code></pre><h2>总结</h2><p>Fork/Join并行计算框架主要解决的是分治任务。分治的核心思想是“分而治之”：将一个大的任务拆分成小的子任务去解决，然后再把子任务的结果聚合起来从而得到最终结果。这个过程非常类似于大数据处理中的MapReduce，所以你可以把Fork/Join看作单机版的MapReduce。</p><p>Fork/Join并行计算框架的核心组件是ForkJoinPool。ForkJoinPool支持任务窃取机制，能够让所有线程的工作量基本均衡，不会出现有的线程很忙，而有的线程很闲的状况，所以性能很好。Java 1.8提供的Stream API里面并行流也是以ForkJoinPool为基础的。不过需要你注意的是，默认情况下所有的并行流计算都共享一个ForkJoinPool，这个共享的ForkJoinPool默认的线程数是CPU的核数；如果所有的并行流计算都是CPU密集型计算的话，完全没有问题，但是如果存在I/O密集型的并行流计算，那么很可能会因为一个很慢的I/O计算而拖慢整个系统的性能。所以<strong>建议用不同的ForkJoinPool执行不同类型的计算任务</strong>。</p><p>如果你对ForkJoinPool详细的实现细节感兴趣，也可以参考<a href=\"http://gee.cs.oswego.edu/dl/papers/fj.pdf\">Doug Lea的论文</a>。</p><h2>课后思考</h2><p>对于一个CPU密集型计算程序，在单核CPU上，使用Fork/Join并行计算框架是否能够提高性能呢？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"25 | CompletionService：如何批量执行异步任务？","id":92245},"right":{"article_title":"27 | 并发工具类模块热点问题答疑","id":92849}},"comments":[{"had_liked":false,"id":90130,"user_name":"爱吃回锅肉的瘦子","can_delete":false,"product_type":"c1","uid":1233867,"ip_address":"","ucode":"24DBDDC62B2276","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/cb/f8157ad8.jpg","comment_is_top":false,"comment_ctime":1556421884,"is_pvip":false,"replies":[{"id":"32319","content":"用两次fork()在join的时候，需要用这样的顺序：a.fork(); b.fork(); b.join(); a.join();这个要求在JDK官方文档里有说明。<br><br>如果是一不小心写成a.fork(); b.fork(); a.join(); b.join();就会有大神廖雪峰说的问题。<br><br>建议还是用fork()+compute()，这种方式的执行过程普通人还是能理解的，fork()+fork()内部做了很多优化，我这个普通人看的实在是头痛。<br><br>感谢分享啊。我觉得讲的挺好的。用这篇文章的例子理解fork()+compute()很到位。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556462347,"ip_address":"","comment_id":90130,"utype":1}],"discussion_count":8,"race_medal":0,"score":"452527987964","product_id":100023901,"comment_content":"https:&#47;&#47;www.liaoxuefeng.com&#47;article&#47;001493522711597674607c7f4f346628a76145477e2ff82000，老师，您好，我在廖雪峰网站中也看到forkjoin使用方式。讲解了，为啥不使用两次fork，分享出来给大家看看。","like_count":106,"discussions":[{"author":{"id":1088710,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","nickname":"苗","note":"","ucode":"5ECCC6C855E541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278838,"discussion_content":"感觉还是invokeAll比较容易理解。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1591240126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49742,"discussion_content":"回锅肉很好吃","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573628460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448400,"discussion_content":"用两次fork()在join的时候，需要用这样的顺序：a.fork(); b.fork(); b.join(); a.join();这个要求在JDK官方文档里有说明。\n\n如果是一不小心写成a.fork(); b.fork(); a.join(); b.join();就会有大神廖雪峰说的问题。\n\n建议还是用fork()+compute()，这种方式的执行过程普通人还是能理解的，fork()+fork()内部做了很多优化，我这个普通人看的实在是头痛。\n\n感谢分享啊。我觉得讲的挺好的。用这篇文章的例子理解fork()+compute()很到位。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1556462347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408831,"discussion_content":"这个在官网找一圈没找到啊，为啥要a.fork(); b.fork(); b.join(); a.join();","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635329099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2154554,"avatar":"","nickname":"koby","note":"","ucode":"16F596A9A963DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542859,"discussion_content":"仔细想了想大神廖雪峰说得没问题，如果任务被其他线程切取走了，tryRemoveAndExe遍历也找不到了，就只能成为包工头阻塞了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640865619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2154554,"avatar":"","nickname":"koby","note":"","ucode":"16F596A9A963DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542853,"discussion_content":"join方法会尝试取栈顶，如果正好是自己就取出，a.fork(); b.fork(); b.join(); a.join();就刚好保证刚好是自己（如果没被窃取），否则poll.waitJoin，此方法会调用tryRemoveAndExe遍历查找当前任务，这样性能会差很多。大神廖雪峰说这种a.fork(); b.fork(); a.join(); b.join();当前线程会成为包工头阻塞，实际上不会阻塞，但是确实性能差很多。如果真成为包工头，正写反写都没有。此文中写法，其实就是invokeALL方法拆开的简化版","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640864176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1095136,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b5/e0/fc3ac264.jpg","nickname":"stronger.","note":"","ucode":"AD0F2BE338824C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534050,"discussion_content":"最近在项目中使用，原来用错了，我就是用了两次fork()，感谢评论能让我看到问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638079397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532989,"discussion_content":"看了下这篇文章确实写得很好，工作模式解释的很清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637747933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89907,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1556326796,"is_pvip":false,"replies":[{"id":"32402","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556519526,"ip_address":"","comment_id":89907,"utype":1}],"discussion_count":4,"race_medal":0,"score":"280729201036","product_id":100023901,"comment_content":"CPU同一时间只能处理一个线程，所以理论上，纯cpu密集型计算任务单线程就够了。多线程的话，线程上下文切换带来的线程现场保存和恢复也会带来额外开销。但实际上可能要经过测试才知道。","like_count":66,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448315,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556519526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026448,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","nickname":"颇忒妥","note":"","ucode":"AA86AD1049BC2E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287523,"discussion_content":"我觉得不存在线程上下文切换的开销。因为按照前面的架构图，这个Pool里只有一个线程，而这个线程只有一个队列，所以无非是这个线程自己生产消费这个队列而已，额外开销有入队出队操作，任务分解操作，任务对象创建的开销，垃圾回收的开销。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593475077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338380,"discussion_content":"不是每个core都可以并行执行线程吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609252177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1468298,"avatar":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","nickname":"锦","note":"","ucode":"CB0EB4B68C468B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346545,"discussion_content":"对，我说的cpu跟你说的core是同一个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611988935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338380,"ip_address":""},"score":346545,"extra":""}]}]},{"had_liked":false,"id":90538,"user_name":"尹圣","can_delete":false,"product_type":"c1","uid":1163547,"ip_address":"","ucode":"C276A01B4910F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/c1/1b/e08d42f8.jpg","comment_is_top":false,"comment_ctime":1556550517,"is_pvip":false,"replies":[{"id":"32447","content":"👍👍👍举一反三了😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556590645,"ip_address":"","comment_id":90538,"utype":1}],"discussion_count":5,"race_medal":0,"score":"169060275061","product_id":100023901,"comment_content":"看到分治任务立马就想到归并排序，用Fork&#47;Join又重新实现了一遍，<br> &#47;**<br>  * Ryzen 1700 8核16线程 3.0 GHz<br>  *&#47;<br> @Test<br> public void mergeSort() {<br>     long[] arrs = new long[100000000];<br>     for (int i = 0; i &lt; 100000000; i++) {<br>         arrs[i] = (long) (Math.random() * 100000000);<br>     }<br>     long startTime = System.currentTimeMillis();<br>     ForkJoinPool forkJoinPool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());<br>     MergeSort mergeSort = new MergeSort(arrs);<br>     arrs = forkJoinPool.invoke(mergeSort);<br>     &#47;&#47;传统递归<br>     &#47;&#47;arrs = mergeSort(arrs);<br>     long endTime = System.currentTimeMillis();<br>     System.out.println(&quot;耗时：&quot; + (endTime - startTime));<br> }<br> &#47;**<br>  * fork&#47;join<br>  * 耗时：13903ms<br>  *&#47;<br> class MergeSort extends RecursiveTask&lt;long[]&gt; {<br>     long[] arrs;<br>     public MergeSort(long[] arrs) {<br>         this.arrs = arrs;<br>     }<br>     @Override<br>     protected long[] compute() {<br>         if (arrs.length &lt; 2) return arrs;<br>         int mid = arrs.length &#47; 2;<br>         MergeSort left = new MergeSort(Arrays.copyOfRange(arrs, 0, mid));<br>         left.fork();<br>         MergeSort right = new MergeSort(Arrays.copyOfRange(arrs, mid, arrs.length));<br>         return merge(right.compute(), left.join());<br>     }<br> }<br> &#47;**<br>  * 传统递归<br>  * 耗时：30508ms<br>  *&#47;<br> public static long[] mergeSort(long[] arrs) {<br>     if (arrs.length &lt; 2) return arrs;<br>     int mid = arrs.length &#47; 2;<br>     long[] left = Arrays.copyOfRange(arrs, 0, mid);<br>     long[] right = Arrays.copyOfRange(arrs, mid, arrs.length);<br>     return merge(mergeSort(left), mergeSort(right));<br> }<br> public static long[] merge(long[] left, long[] right) {<br>     long[] result = new long[left.length + right.length];<br>     for (int i = 0, m = 0, j = 0; m &lt; result.length; m++) {<br>         if (i &gt;= left.length) {<br>             result[m] = right[j++];<br>         } else if (j &gt;= right.length) {<br>             result[m] = left[i++];<br>         } else if (left[i] &gt; right[j]) {<br>             result[m] = right[j++];<br>         } else result[m] = left[i++];<br>     }<br>     return result;<br> }","like_count":40,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448558,"discussion_content":"👍👍👍举一反三了😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556590645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561710,"discussion_content":"这样感觉话，ForkJoin就是多开了线程进行排序；假如传统的递归排序也用多线程排序尼？结果会怎么样？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649698100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1533266,"avatar":"https://static001.geekbang.org/account/avatar/00/17/65/52/07c09c7f.jpg","nickname":"josancpp","note":"","ucode":"0CDC39B3E716A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276612,"discussion_content":"为啥要拷贝数组，直接用同一个数组就行，传起始位置就行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590914110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2040574,"avatar":"","nickname":"戴岩","note":"","ucode":"5D71D79C70E59E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286112,"discussion_content":"8C提升不到3倍？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593061767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039466,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dc/6a/b5478b65.jpg","nickname":"Ab","note":"","ucode":"8E9261782F025D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6120,"discussion_content":"这个厉害了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566714429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97469,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1558678156,"is_pvip":false,"replies":[{"id":"34878","content":"👍说明你很有悟性😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558699490,"ip_address":"","comment_id":97469,"utype":1}],"discussion_count":1,"race_medal":0,"score":"143292598924","product_id":100023901,"comment_content":"学习了老师的分享，现在就已经在工作用到了，的确是在同事面前好好装了一次逼","like_count":33,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451288,"discussion_content":"👍说明你很有悟性😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558699490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89932,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1556334782,"is_pvip":false,"replies":[{"id":"32331","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556463314,"ip_address":"","comment_id":89932,"utype":1}],"discussion_count":1,"race_medal":0,"score":"113225484478","product_id":100023901,"comment_content":"以前在面蚂蚁金服时，也做过类似的题目，从一个目录中，找出所有文件里面单词出现的top100，那时也是使用服务提供者，从目录中找出一个或者多个文件（防止所有文件一次性加载内存溢出，也为了防止文件内容过小，所以每次都确保读出的行数10万行左右），然后使用fork&#47;join进行单词的统计处理，设置处理的阈值为20000。<br>课后习题：单核的话，使用单线程会比多线程快，线程的切换，恢复等都会耗时，并且要是机器不允许，单线程可以保证安全，可见性（cpu缓存，单个CPU数据可见），线程切换（单线程不会出现原子性）","like_count":27,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448324,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556463314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89921,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1556331280,"is_pvip":false,"replies":[{"id":"32316","content":"我觉得不可以，如果join在前面会先首先让当前线程阻塞在join()上。当join()执行完才会执行mr2.compute(),这样并行度就下来了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556456341,"ip_address":"","comment_id":89921,"utype":1}],"discussion_count":6,"race_medal":0,"score":"100340579088","product_id":100023901,"comment_content":"请教老师一个问题，merge函数里的mr2.compute先执行还是mr1.join先执行，这两个参数是否可交换位置","like_count":24,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448319,"discussion_content":"我觉得不可以，如果join在前面会先首先让当前线程阻塞在join()上。当join()执行完才会执行mr2.compute(),这样并行度就下来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556456341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391937,"discussion_content":"return merge(mr2.compute(), mr1.join()); // ①原始代码\nreturn merge(mr1.join(), mr2.compute()); // ②能正常执行\nreturn merge(mr2.join(), mr1.compute()); // ③会阻塞\n同学问的是情况②吧，但老师回答的应该是情况③。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630720962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1313115,"avatar":"https://static001.geekbang.org/account/avatar/00/14/09/5b/e9ee3b41.jpg","nickname":"音为","note":"","ucode":"D78E4CBCE6BF45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533603,"discussion_content":"你理解的不对，2会阻塞，3代码都不对，mr2都没fork哪来的join","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1637915347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":391937,"ip_address":""},"score":533603,"extra":""}]},{"author":{"id":1254012,"avatar":"https://static001.geekbang.org/account/avatar/00/13/22/7c/7169323f.jpg","nickname":"飘逸的翔云","note":"","ucode":"0E756D3AC3D889","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311941,"discussion_content":"mr1和mr2可以换过来吗？mr1.compute，mr2.join","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602549210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2402801,"avatar":"https://static001.geekbang.org/account/avatar/00/24/a9/f1/791d0f5e.jpg","nickname":"程志强","note":"","ucode":"5FDBC60AD960E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1254012,"avatar":"https://static001.geekbang.org/account/avatar/00/13/22/7c/7169323f.jpg","nickname":"飘逸的翔云","note":"","ucode":"0E756D3AC3D889","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575047,"discussion_content":"不行吧，楼上已经说了，3是错误的，没有fork，无可join","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654569951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311941,"ip_address":""},"score":575047,"extra":""}]},{"author":{"id":1351012,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/64/272dc1b7.jpg","nickname":"圆滚滚","note":"","ucode":"E4D81822A87D50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94424,"discussion_content":"使用compute方法是让当前线程保持在计算的状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576943571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94044,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1557709475,"is_pvip":false,"replies":[{"id":"33581","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557719718,"ip_address":"","comment_id":94044,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48802349731","product_id":100023901,"comment_content":"如果所有的并行流计算都是 CPU 密集型计算的话，完全没有问题，但是如果存在 I&#47;O 密集型的并行流计算，那么很可能会因为一个很慢的 I&#47;O 计算而拖慢整个系统的性能。<br><br>老师这里的意思是不是，如果有耗时的i&#47;o计算，需要用单独的forkjoin pool 来处理这个计算，在程序设计的时候就要跟其他cpu密集计算的任务分开处理？","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449887,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557719718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90077,"user_name":"王伟","can_delete":false,"product_type":"c1","uid":1445561,"ip_address":"","ucode":"22D0188425E839","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/b9/7866f19d.jpg","comment_is_top":false,"comment_ctime":1556410792,"is_pvip":false,"replies":[{"id":"32297","content":"可以加redis缓存看看，也可以加本地缓存。不要让流量直接打到数据库上","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556427016,"ip_address":"","comment_id":90077,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40211116456","product_id":100023901,"comment_content":"老师，我现在碰到一个生产问题：用户通过微信小程序进入我们平台，我们只能需要使用用户的手机号去我们商家库中查取该用户的注册信息。在只知道用户手机号的情况下我们需要切换到所有的商家库去查询。这样非常耗时。ps：我们商家库做了分库处理而且数量很多。想请教一下您，这种查询该如何做？","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448381,"discussion_content":"可以加redis缓存看看，也可以加本地缓存。不要让流量直接打到数据库上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556427016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101760,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/c0/8e4c1135.jpg","nickname":"ddup","note":"","ucode":"D8EC573DA46A10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584782,"discussion_content":"completionService为你量身打造","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661135173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89944,"user_name":"êｗěｎ","can_delete":false,"product_type":"c1","uid":1066707,"ip_address":"","ucode":"5000233111BEFA","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d3/e25d104a.jpg","comment_is_top":false,"comment_ctime":1556342708,"is_pvip":true,"replies":[{"id":"32366","content":"fork是fork调用者这个子任务加入到任务队列里","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556500193,"ip_address":"","comment_id":89944,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27326146484","product_id":100023901,"comment_content":"老师，fork是fork调用者的子任务还是表示下面new出来的任务是子任务？","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448329,"discussion_content":"fork是fork调用者这个子任务加入到任务队列里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556500193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90232,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1556454980,"is_pvip":false,"replies":[{"id":"32320","content":"compute+compute相当于没用forkjoin，都在一个线程里跑的。如果用join+join也可以，不过jdk官方有个建议，顺序要用：a.fork(); b.fork(); b.join(); a.join();否则性能有问题。所以还是用fork+compute更简单。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556462519,"ip_address":"","comment_id":90232,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23031291460","product_id":100023901,"comment_content":"老师，请问为什么不能merge mr1.compute和mr2..compute或者mr1.join和mr2的join呢？<br>","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448431,"discussion_content":"compute+compute相当于没用forkjoin，都在一个线程里跑的。如果用join+join也可以，不过jdk官方有个建议，顺序要用：a.fork(); b.fork(); b.join(); a.join();否则性能有问题。所以还是用fork+compute更简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556462519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327573,"discussion_content":"为什么 a.fork(); b.fork(); b.join(); a.join() 性能要好？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605864974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101202,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1507000,"ip_address":"","ucode":"192C47B2CF1426","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/b8/24a6e0cb.jpg","comment_is_top":false,"comment_ctime":1559740569,"is_pvip":false,"replies":[{"id":"36785","content":"递归程序，如果语言层面没有办法优化，都会的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1560128803,"ip_address":"","comment_id":101202,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18739609753","product_id":100023901,"comment_content":"简易的MapReduce的程序跑下来不会栈溢出吗？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452850,"discussion_content":"递归程序，如果语言层面没有办法优化，都会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560128803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169099,"user_name":"王彬-Antonio","can_delete":false,"product_type":"c1","uid":1261653,"ip_address":"","ucode":"14D448904243A1","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/55/fccafd61.jpg","comment_is_top":false,"comment_ctime":1578273770,"is_pvip":false,"replies":[{"id":"65671","content":"操作系统负责调度，在操作系统眼里，都一样，都是线程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1578311055,"ip_address":"","comment_id":169099,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14463175658","product_id":100023901,"comment_content":"老师，您在文中提到io密集型和计算密集型最好区分开不同线程池。假设两个线程池如果都在运行，它们之间怎么竞争CPU线程？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480424,"discussion_content":"操作系统负责调度，在操作系统眼里，都一样，都是线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578311055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98378,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1558971328,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14443873216","product_id":100023901,"comment_content":"@王伟童鞋的问题，我们也有这场景：通过手机号查询商家信息。<br>我们是在 redis 里维护(手机号，商家号)关联关系，在 redis 里通过手机号查询商家号，就知道该去哪个库表查询商家具体信息了。<br><br>内存开销：<br>手机号，11 个字符，占用 11B；<br>商家号，4 个字符，占用 4B；<br>一条记录占用 15B，100 万条记录，就 15*100万B，大概是：<br>15*1,000,000B&#47;1000&#47;1000=15M","like_count":3,"discussions":[{"author":{"id":2301750,"avatar":"https://static001.geekbang.org/account/avatar/00/23/1f/36/10187a2e.jpg","nickname":"工具人","note":"","ucode":"4B513441BE5222","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540708,"discussion_content":"一条记录不仅仅是15B吧，还有Redsi自己的一些内存占用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640141879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90522,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1556545784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14441447672","product_id":100023901,"comment_content":"ForkJoinTask这个抽象类的 fork() 和 join（）底层是怎么实现的呢？","like_count":3},{"had_liked":false,"id":322343,"user_name":"Black Jack","can_delete":false,"product_type":"c1","uid":2845977,"ip_address":"","ucode":"CB16C8F44EF422","user_header":"https://static001.geekbang.org/account/avatar/00/2b/6d/19/204b0900.jpg","comment_is_top":false,"comment_ctime":1637311043,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10227245635","product_id":100023901,"comment_content":"return f2.compute() + f1.join();<br>对这行代码的理解是 当前线程把 f1的工作分配出去,并等待其完成，然后自己进行f2的工作。如果使用f2.fork,f2.join.相当于当前线程空闲了，存在资源浪费了","like_count":3},{"had_liked":false,"id":245718,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1599034548,"is_pvip":false,"replies":[{"id":"90436","content":"我没有详细看jdk相关的源码，推断当前线程(main)是会参与执行的，否则当前线程只能阻塞，就浪费了，这样的设计对性能影响挺大的。应该不会这样设计。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1599176202,"ip_address":"","comment_id":245718,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10188969140","product_id":100023901,"comment_content":"老师，您好，有个问题想请教您一下<br><br>问题：使用 fork&#47;join 框架，ForkJoinTask 不是只提交给 ForkJoinPool 线程池里的线程执行么？为什么 main 主线程也参与了运算？<br><br><br>验证如下：<br>public static void main(String[] args) {<br>        IntStream.range(1, 3).parallel().forEach(i -&gt; System.out.println(Thread.currentThread().getName() + &quot;##&quot; + i));<br>    }<br><br>输出：<br>ForkJoinPool.commonPool-worker-1##1<br>main##2<br><br>除了 ForkJoinPool.commonPool-worker，还有 main 的输出。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504968,"discussion_content":"我没有详细看jdk相关的源码，推断当前线程(main)是会参与执行的，否则当前线程只能阻塞，就浪费了，这样的设计对性能影响挺大的。应该不会这样设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599176202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90431,"user_name":"狂风骤雨","can_delete":false,"product_type":"c1","uid":1305749,"ip_address":"","ucode":"5CE9B9438FAB3F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZSibeTatZ2ImL5Xu3QqdTWQs5nyQAxDlsm3m0KicP3TN6icJqYricvhjOFfTB2B3oLInU45CC9LtqMA/132","comment_is_top":false,"comment_ctime":1556519244,"is_pvip":false,"replies":[{"id":"32448","content":"我知道的就这些，都写出来了😂，显然我不是大牛😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556590906,"ip_address":"","comment_id":90431,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10146453836","product_id":100023901,"comment_content":"好希望工作当中能有老师这样一位大牛，能为我答疑解惑","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448522,"discussion_content":"我知道的就这些，都写出来了😂，显然我不是大牛😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556590906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477324,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8a/cc/da9adc82.jpg","nickname":"小太阳","note":"","ucode":"3B1C90425E485D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241878,"discussion_content":"看来大牛都很谦虚！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587445220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90246,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1556458715,"is_pvip":false,"replies":[{"id":"32355","content":"我觉得会","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556499400,"ip_address":"","comment_id":90246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10146393307","product_id":100023901,"comment_content":"这里用的递归调用，数据量大的时候会不会粘溢出，虽然这里用的二分，时间复杂度为logn","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448438,"discussion_content":"我觉得会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556499400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89896,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1556322926,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10146257518","product_id":100023901,"comment_content":"单核cpu上多线程会导致线程的上下文切换，还不如单核单线程处理的效率高。","like_count":2,"discussions":[{"author":{"id":1104012,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d8/8c/5855acbb.jpg","nickname":"Xu","note":"","ucode":"3CE4D3228FE1E0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84390,"discussion_content":"也分io密集型，cpu密集型，io等待多的场景下，单核多线程是可以提高效率的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576495943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205441,"user_name":"夏目","can_delete":false,"product_type":"c1","uid":1297590,"ip_address":"","ucode":"B5ADB94734BA6B","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/b6/8fb15749.jpg","comment_is_top":false,"comment_ctime":1586617729,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5881585025","product_id":100023901,"comment_content":"请教一下：return merge(mr2.compute(), mr1.join());<br>这样写mr2又会被分割为mr3、mr4，mr3又会被分割为mr5、mr6.....,无线分割下去吗？<br>","like_count":1,"discussions":[{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576819,"discussion_content":"有if (end - start != 1) 这个条件的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655799128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204541,"user_name":"Geek_c40c24","can_delete":false,"product_type":"c1","uid":1538268,"ip_address":"","ucode":"AEAE60CEBE8B3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3qfPEnr4rIVUicypRp4tlZUh8fliaZgJWHDOxxSia1ShPCxK61cpWCgN2piaf5xksTr3jic0YypSvsgM6u5sop9FlsQ/132","comment_is_top":false,"comment_ctime":1586418951,"is_pvip":false,"replies":[{"id":"76706","content":"你这个实质上是普通的递归程序，单线程执行的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1586601058,"ip_address":"","comment_id":204541,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881386247","product_id":100023901,"comment_content":"static class Fibonacci extends RecursiveTask&lt;Integer&gt; {<br>        final int n;<br><br>        Fibonacci(int n) {<br>            this.n = n;<br>        }<br><br><br>        @Override<br>        protected Integer compute() {<br>            if (n &lt;= 1) {<br>                return n;<br>            }<br>            Fibonacci f1 = new Fibonacci(n-1);<br><br><br><br>            Fibonacci f2 = new Fibonacci(n-2);<br><br><br>            return f2.compute() +  f1.compute();<br>        }<br>    }<br>这样和老师你的例子有什么区别呀 ，我还不不理解深层次的含义","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491211,"discussion_content":"你这个实质上是普通的递归程序，单线程执行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586601058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176457,"user_name":"Chuan","can_delete":false,"product_type":"c1","uid":1438352,"ip_address":"","ucode":"FACEC5DAC36A7A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4akcIyIOXB2OqibTe7FF90hwsBicxkjdicUNTMorGeIictdr3OoMxhc20yznmZWwAvQVThKPFWgOyMw/132","comment_is_top":false,"comment_ctime":1581063787,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5876031083","product_id":100023901,"comment_content":"关于使用两次fork，官方的建议如下：<br>```<br> * &lt;p&gt;In the most typical usages, a fork-join pair act like a call<br> * (fork) and return (join) from a parallel recursive function. As is<br> * the case with other forms of recursive calls, returns (joins)<br> * should be performed innermost-first. For example, {@code a.fork();<br> * b.fork(); b.join(); a.join();} is likely to be substantially more<br> * efficient than joining {@code a} before {@code b}.<br>```<br><br>先join a再join b，确实会出现类似监工的问题，当前线程并没有执行计算任务。但请教下老师，如果先join b再join a，当前线程好像也没有执行计算任务，一样会存在“监工问题”而影响性能，不知道这块老师是怎么看的？","like_count":1,"discussions":[{"author":{"id":1571460,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","nickname":"Simple life","note":"","ucode":"1902D7F72FB43F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298728,"discussion_content":"RecursiveAction 就是定义了一个complate方法来执行逻辑，你可以自己在task里面当前线程负责部分计算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597388812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104648,"user_name":"林伊","can_delete":false,"product_type":"c1","uid":1068957,"ip_address":"","ucode":"09ADBE454FE6E3","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/9d/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1560813777,"is_pvip":false,"replies":[{"id":"38257","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561077019,"ip_address":"","comment_id":104648,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855781073","product_id":100023901,"comment_content":"1.8中对fork()方法做了改进，会先判断是不是当前线程，如果是则放入当前线程的任务队列中的。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454360,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561077019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100229,"user_name":"蓝天白云看大海","can_delete":false,"product_type":"c1","uid":1302670,"ip_address":"","ucode":"02EF13FE37174B","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/8e/2376cd87.jpg","comment_is_top":false,"comment_ctime":1559487971,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5854455267","product_id":100023901,"comment_content":"join会阻塞线程吗？如果阻塞线程，而线程池里的线程个数又有线，那么递归几次之后所有线程不都全阻塞了吗！","like_count":1,"discussions":[{"author":{"id":1758825,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d6/69/f59d4f6f.jpg","nickname":"Ryan","note":"","ucode":"387955FD53E98C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549974,"discussion_content":"看源码里面是当线程执行到join的时候，会循环尝试窃取其他任务执行，也就是说线程不会直接阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644315050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409111,"discussion_content":"不是有任务队列吗？会放进队列等待被拉取执行的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635382747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90070,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1556408094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851375390","product_id":100023901,"comment_content":"我记得之前提到过，使用线程数目大小的方法。如果io耗时过长可以多加线程数量，能够提升性能。如果io耗时过短，增加线程数量就不能，提升性能了？不知道是否能够对应，这个题目的答案？","like_count":1},{"had_liked":false,"id":90025,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1556370514,"is_pvip":false,"replies":[{"id":"32301","content":"前提是有很多请求并发访问这个很慢的I&#47;O计算，我们这的并发程序，往往都有很多请求同时访问的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556428374,"ip_address":"","comment_id":90025,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851337810","product_id":100023901,"comment_content":"“如果存在 I&#47;O 密集型的并行流计算，那么很可能会因为一个很慢的 I&#47;O 计算而拖慢整个系统的性能。”<br><br>老师这个问题，这句话前面的文字也看到，但是不太懂。如果共用一个线程池，但是不是有多个线程，如果一个线程操作I&#47;O，应该不影响其他线程吧，其他线程还能继续执行，我不太理解为什么会拖慢整个系统，求老师帮我解答这个疑问。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448359,"discussion_content":"前提是有很多请求并发访问这个很慢的I/O计算，我们这的并发程序，往往都有很多请求同时访问的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556428374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89918,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1556331079,"is_pvip":false,"replies":[{"id":"32333","content":"不是一半被主线程执行了，fork()任务之后，这个任务会被一个线程X执行，这个线程X会就是你理解的主线程，但它不是线程池里的固定的一个，而是线程池里所有线程都有可能。我这样说不知道能不能回答到你的点上","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556463585,"ip_address":"","comment_id":89918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851298375","product_id":100023901,"comment_content":"对于单核CPU而言，FJ线程池默认1个线程，由于是CPU密集型，失去了线程切换的意义，平白带来上下文切换的性能损耗。<br>老师我想请教下前文斐波那契数列的例子，一个30的斐波那契递归展开后是一个深度30的二叉树，每一层的一个分支由主线程执行，另一个提交FJ的线程池执行，那么可不可以理解为最后一半的任务被主线程执行了，另一半的任务被FJ 的线程池执行了呢。如果是的话，提交给FJ任务队列的任务会进入不同的任务队列吗？我对于FJ分多个任务队列的目的和原理都不太了解。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448318,"discussion_content":"不是一半被主线程执行了，fork()任务之后，这个任务会被一个线程X执行，这个线程X会就是你理解的主线程，但它不是线程池里的固定的一个，而是线程池里所有线程都有可能。我这样说不知道能不能回答到你的点上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556463585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89905,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1556326225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851293521","product_id":100023901,"comment_content":"打卡！","like_count":1},{"had_liked":false,"id":343164,"user_name":"张潇赟","can_delete":false,"product_type":"c1","uid":1132192,"ip_address":"","ucode":"1A45B57F9E0723","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/a0/aa6d4ecd.jpg","comment_is_top":false,"comment_ctime":1650684345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650684345","product_id":100023901,"comment_content":"f2.compute() + f1.join();  斐波那契数列示例中，为什么f1不需要调用compute方法？","like_count":0},{"had_liked":false,"id":343162,"user_name":"张潇赟","can_delete":false,"product_type":"c1","uid":1132192,"ip_address":"","ucode":"1A45B57F9E0723","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/a0/aa6d4ecd.jpg","comment_is_top":false,"comment_ctime":1650684313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650684313","product_id":100023901,"comment_content":"f2.compute() + f1.join();","like_count":0},{"had_liked":false,"id":341481,"user_name":"开心","can_delete":false,"product_type":"c1","uid":1517457,"ip_address":"","ucode":"C8E08E8724C7CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkzrezV2dOBAgickt9DLzabz3dNFYyDEVXENMQ5ibrWhFbFqXIOia3ZaR21pozvB7UfoxJx4Ar688sA/132","comment_is_top":false,"comment_ctime":1649653877,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649653877","product_id":100023901,"comment_content":"如果递归很深，线程不足了，此时被阻塞的线程没法工作，也没有新的线程去执行新任务？","like_count":0},{"had_liked":false,"id":316569,"user_name":"卢","can_delete":false,"product_type":"c1","uid":1542037,"ip_address":"","ucode":"B6A9F41AEE348C","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/95/cba0a896.jpg","comment_is_top":false,"comment_ctime":1634394802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634394802","product_id":100023901,"comment_content":"https:&#47;&#47;ifeve.com&#47;java-%E5%B9%B6%E5%8F%91%E4%B9%8B-fork-join-%E6%A1%86%E6%9E%B6","like_count":0},{"had_liked":false,"id":316566,"user_name":"卢","can_delete":false,"product_type":"c1","uid":1542037,"ip_address":"","ucode":"B6A9F41AEE348C","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/95/cba0a896.jpg","comment_is_top":false,"comment_ctime":1634394554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634394554","product_id":100023901,"comment_content":"https:&#47;&#47;ifeve.com&#47;forkjoinpool-%E6%8E%A2%E7%B4%A2","like_count":0},{"had_liked":false,"id":309232,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1629991907,"is_pvip":true,"discussion_count":-1,"race_medal":1,"score":"1629991907","product_id":100023901,"comment_content":"有没有推荐的博文我看看啊<br>java.util.stream.ForEachOps.ForEachTask.compute<br>我看不懂，很沮丧。。。感觉看懂还要先懂ForkJoinTask  我是傻比","like_count":0},{"had_liked":false,"id":287887,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1618208470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618208470","product_id":100023901,"comment_content":"CPU密集型任务在单核的CPU上没必要使用Fork&#47;Join了，增加线程对于单核CPU来讲多线程的上下文切换反倒是可能影响性能。","like_count":0},{"had_liked":false,"id":286125,"user_name":"盛权_vinc","can_delete":false,"product_type":"c1","uid":1459845,"ip_address":"","ucode":"4688DD06587CE2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LPnuO9GleKEwso2rSbibmbEwn49hnGl9qTQDBv2xLOOWOflQsc9oVEEuZgNBt7TrqRKvk8CX7Tc8iakhEicBCCfFg/132","comment_is_top":false,"comment_ctime":1617161094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617161094","product_id":100023901,"comment_content":"老师，ForkJoin这个框架是不是就是理解成同步递归和异步递归？调用fork()方法启动子任务就是异步递归，直接调用compute()方法就是同步递归，在斐波那契的例子里面怎么感觉是重复计算了，比如要计算第12位数的值，就拆分成异步算第11位数和同步算第10位数，在子任务异步算第11位数的时候，又拆分成异步算第10位数和同算第9位数，那这里被拆出来的异步算第10位数和最开始的同步算第10位数不就重复计算了？相比MapReduce是用2分法来拆分子任务的，所有的子任务就不存在重复了。","like_count":0},{"had_liked":false,"id":282809,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1615426101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615426101","product_id":100023901,"comment_content":"单核cpu如果处理cpu密集型任务的话常规情况还是单线程并行处理比较好，多线程涉及线程上下文切换比较耗性能，如果中间存在一部分的io操作，结合具体情况测试","like_count":0},{"had_liked":false,"id":277554,"user_name":"嘉莹","can_delete":false,"product_type":"c1","uid":1180407,"ip_address":"","ucode":"B6E3667AD436AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/02/f7/0ca6cf20.jpg","comment_is_top":false,"comment_ctime":1612454399,"is_pvip":false,"replies":[{"id":"100823","content":"都可以，n&lt;=1 对应的是0，1，1，2...；n&lt;=2对应的是1，1，2...","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1612602756,"ip_address":"","comment_id":277554,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612454399","product_id":100023901,"comment_content":"老师，计算Fibonacci那个例子里，compute方法中条件if (n &lt;= 1)应该是if (n &lt;= 2)吧？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515092,"discussion_content":"都可以，n&amp;lt;=1 对应的是0，1，1，2...；n&amp;lt;=2对应的是1，1，2...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612602756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270486,"user_name":"Spring4J","can_delete":false,"product_type":"c1","uid":1645430,"ip_address":"","ucode":"06F056085A2564","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","comment_is_top":false,"comment_ctime":1609144356,"is_pvip":false,"replies":[{"id":"98121","content":"������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1609163775,"ip_address":"","comment_id":270486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1609144356","product_id":100023901,"comment_content":"统计单词的merge函数里面，感觉应该先比较两个map的size，然后循环小的那个，应该会更快","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512646,"discussion_content":"������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609163775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240898,"user_name":"关羽","can_delete":false,"product_type":"c1","uid":1057179,"ip_address":"","ucode":"6FC2CDA20191DB","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/9b/347301f6.jpg","comment_is_top":false,"comment_ctime":1597112718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597112718","product_id":100023901,"comment_content":"forkjoin框架要谨慎使用，问题还是很多的。我们在生产上曾经发生过forkjoin框架和Apache dubbo2.7.x版本同时使用造成cpu100%宕机的事故","like_count":0},{"had_liked":false,"id":199840,"user_name":"😜哈哈","can_delete":false,"product_type":"c1","uid":1069001,"ip_address":"","ucode":"1FF58FB3A91135","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/c9/88837387.jpg","comment_is_top":false,"comment_ctime":1585496804,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585496804","product_id":100023901,"comment_content":"可以研究下Hadoop","like_count":0},{"had_liked":false,"id":184500,"user_name":"missed","can_delete":false,"product_type":"c1","uid":1670935,"ip_address":"","ucode":"89D0016FAEE0D0","user_header":"https://static001.geekbang.org/account/avatar/00/19/7f/17/181c8d6f.jpg","comment_is_top":false,"comment_ctime":1583329579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583329579","product_id":100023901,"comment_content":"老师Fork&#47;join实现的斐波拉契，和单独递归实现的斐波拉契，在求前40次循环的时候Fork&#47;join时间还领先，但是我到求45层的时候，Fork&#47;join的时间是37S，单独递归实现的斐波拉契只需要7S钟，不知道啥情况","like_count":0},{"had_liked":false,"id":164355,"user_name":"圆滚滚","can_delete":false,"product_type":"c1","uid":1351012,"ip_address":"","ucode":"E4D81822A87D50","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/64/272dc1b7.jpg","comment_is_top":false,"comment_ctime":1576943676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576943676","product_id":100023901,"comment_content":"可以尝试下用fork&#47;join获取一个组织树下，某个节点下的所有子节点","like_count":0},{"had_liked":false,"id":150918,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1573628363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573628363","product_id":100023901,"comment_content":"学习了双端队列在什么场景下使用","like_count":0},{"had_liked":false,"id":148606,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1573037572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573037572","product_id":100023901,"comment_content":"感觉理解ForkJoin还是有些吃力，欠的算法债太多了，还是得多学些，多敲代码！","like_count":0},{"had_liked":false,"id":142047,"user_name":"陌臣","can_delete":false,"product_type":"c1","uid":1643898,"ip_address":"","ucode":"EC1B2DA7483F11","user_header":"https://static001.geekbang.org/account/avatar/00/19/15/7a/db9879e1.jpg","comment_is_top":false,"comment_ctime":1571283389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571283389","product_id":100023901,"comment_content":"对于文中提到的用fork&#47;join计算斐波拉契数列，应该存在重复计算，不知道能不能用老师之前讲到的concurrenthashmap或者原子类数组来保存已经计算过的值，避免重复计算呢？","like_count":0},{"had_liked":false,"id":137459,"user_name":"小予","can_delete":false,"product_type":"c1","uid":1442580,"ip_address":"","ucode":"3F5EAEE1746074","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/14/e9ca2d09.jpg","comment_is_top":false,"comment_ctime":1569746169,"is_pvip":false,"replies":[{"id":"52833","content":"我也发现这个问题了，主要原因是计算太简单，时间都花在调度上了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569759132,"ip_address":"","comment_id":137459,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1569746169","product_id":100023901,"comment_content":"我测试了一下Fork&#47;Join计算Fibonacci数列的性能，用Fork&#47;Join的耗时是直接用递归方法的几十倍，是Fork&#47;Join不适合这样的场景呢，还是我的用法有问题啊，希望老师可以抽时间看下。 代码如下：<br>public class TestForkJoin {<br>    public static void main(String[] args) {<br>        long n = 50;<br>        long start = System.currentTimeMillis();<br>        System.out.println(&quot;递归结算结果：&quot; + fibonacciN(n) + &quot; 耗时：&quot; + (System.currentTimeMillis() - start));<br>        System.out.println(&quot;================================&quot;);<br><br>        start = System.currentTimeMillis();<br>        ForkJoinPool forkJoinPool = new ForkJoinPool(4);<br>        &#47;&#47; 创建分治任务<br>        Fibonacci fibonacci = new Fibonacci(n);<br>        &#47;&#47; 启动分治任务<br>        Long result = forkJoinPool.invoke(fibonacci);<br>        System.out.println(&quot;Fork&#47;Join结果：&quot; + result + &quot; 耗时：&quot; + (System.currentTimeMillis() - start));<br>    }<br><br>    public static long fibonacciN(long n) {<br>        if (n &lt; 1)<br>            return n;<br>        if (n == 1 || n == 2)<br>            return 1;<br>        return fibonacciN(n - 1) + fibonacciN(n - 2);<br>    }<br><br>    static class Fibonacci extends RecursiveTask&lt;Long&gt; {<br>        private final long n;<br><br>        public Fibonacci(long n) {<br>            this.n = n;<br>        }<br><br>        @Override<br>        protected Long compute() {<br>            if (n &lt;= 1)<br>                return n;<br>            Fibonacci f1 = new Fibonacci(n - 1);<br>            &#47;&#47; 创建子任务<br>            f1.fork();<br>            Fibonacci f2 = new Fibonacci(n - 2);<br>            &#47;&#47; 等待子任务结果，并合并结果<br>            return f2.compute() + f1.join();<br>        }<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469105,"discussion_content":"我也发现这个问题了，主要原因是计算太简单，时间都花在调度上了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569759132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2143963,"avatar":"https://static001.geekbang.org/account/avatar/00/20/b6/db/ffaed7bf.jpg","nickname":"刘鹏","note":"","ucode":"EA8BD8810350C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553870,"discussion_content":"我曾经也有层主这个疑问，对统计单词个数的单线程统计和ForkJoin统计的对比，即使我把测试数据集加到300w了，ForkJoin还是比不上单线程统计，后来看到老师的回复，我就在cal()方法里遍历数组时sleep()一下，差距就很明显的看到了；我理解Fork/Join模型或者多线程模型可以提升有大量慢IO操作的程序，为了缓解CPU的高速运算和IO等耗时操作的矛盾 避免串行造成的无用等待，虽然这句话也背过，但还不能应用自如，感觉自己理解得深刻了一点点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646123063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126782,"user_name":"夏日雨","can_delete":false,"product_type":"c1","uid":1117422,"ip_address":"","ucode":"D8066F89D3A8A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/ee/7667642c.jpg","comment_is_top":false,"comment_ctime":1566474409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566474409","product_id":100023901,"comment_content":"老师您好，文中有提到 ForkJoinPool 内部有多个任务队列，想问一下任务队列数是和ForkJoinPool中的线程数相等吗？","like_count":0},{"had_liked":false,"id":100152,"user_name":"蓝天白云看大海","can_delete":false,"product_type":"c1","uid":1302670,"ip_address":"","ucode":"02EF13FE37174B","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/8e/2376cd87.jpg","comment_is_top":false,"comment_ctime":1559462158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559462158","product_id":100023901,"comment_content":"join()如果阻塞线程的话，就不是并行任务了，任务有可能永远都完不成了吧","like_count":0},{"had_liked":false,"id":100083,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1559440498,"is_pvip":false,"replies":[{"id":"36142","content":"所有任务都会创建子任务，如果只有一个任务会创建子任务，那就只能steal了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559542802,"ip_address":"","comment_id":100083,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559440498","product_id":100023901,"comment_content":"“如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。”<br>抱歉来得晚了些。<br>上面这句话不太理解。如果“创建子任务”指的是fork的话，是不是应该提交到其他任务队列中？否则岂不是全部在一个队列中，被一个线程处理，其他线程对应的队列都是空，全靠steal？<br>那样的话有什么办法利用其他线程？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452404,"discussion_content":"所有任务都会创建子任务，如果只有一个任务会创建子任务，那就只能steal了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559542802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89970,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1556351588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556351588","product_id":100023901,"comment_content":"对于思考题， 老师在最早期的文章有说过， 在早期多线程解决的是 减少等待io时间 ，提高cpu计算能力。 计算密集型的程序，在单核中只有一个cpu能处理计算， 就算分出多个线程也只能等待一个cpu去处理。 不但不能提高性能，反而因为大量的线程切换导致操作系统资源的浪费","like_count":0},{"had_liked":false,"id":89968,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1556351331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556351331","product_id":100023901,"comment_content":"哈哈哈， 感觉从异步编程开始就有些吃力了。 五一好好抠一下， 尽量跟紧老师的脚步","like_count":0},{"had_liked":false,"id":89910,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1556327770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556327770","product_id":100023901,"comment_content":"可以的吧，主要是fork","like_count":0},{"had_liked":false,"id":89906,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1556326376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556326376","product_id":100023901,"comment_content":"按照老师上面讲的，forkjoin线程数是按cpu核数设置的，那单核理论上只会设置一个线程，达不到并行的任务效果","like_count":0},{"had_liked":false,"id":89886,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1556299649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556299649","product_id":100023901,"comment_content":"不能","like_count":0}]}