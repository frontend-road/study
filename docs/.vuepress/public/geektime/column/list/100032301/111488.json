{"id":111488,"title":"05 | 如何确保消息不会丢失?","content":"<p>你好，我是李玥。这节课我们来聊聊丢消息的事儿。</p><p>对于刚刚接触消息队列的同学，最常遇到的问题，也是最头痛的问题就是丢消息了。对于大部分业务系统来说，丢消息意味着数据丢失，是完全无法接受的。</p><p>其实，现在主流的消息队列产品都提供了非常完善的消息可靠性保证机制，完全可以做到在消息传递过程中，即使发生网络中断或者硬件故障，也能确保消息的可靠传递，不丢消息。</p><p>绝大部分丢消息的原因都是由于开发者不熟悉消息队列，没有正确使用和配置消息队列导致的。虽然不同的消息队列提供的API不一样，相关的配置项也不同，但是在保证消息可靠传递这块儿，它们的实现原理是一样的。</p><p>这节课我们就来讲一下，消息队列是怎么保证消息可靠传递的，这里面的实现原理是怎么样的。当你熟知原理以后，无论你使用任何一种消息队列，再简单看一下它的API和相关配置项，就能很快知道该如何配置消息队列，写出可靠的代码，避免消息丢失。</p><h2>检测消息丢失的方法</h2><p>我们说，用消息队列最尴尬的情况不是丢消息，而是消息丢了还不知道。一般而言，一个新的系统刚刚上线，各方面都不太稳定，需要一个磨合期，这个时候，特别需要监控到你的系统中是否有消息丢失的情况。</p><p>如果是IT基础设施比较完善的公司，一般都有分布式链路追踪系统，使用类似的追踪系统可以很方便地追踪每一条消息。如果没有这样的追踪系统，这里我提供一个比较简单的方法，来检查是否有消息丢失的情况。</p><!-- [[[read_end]]] --><p><strong>我们可以利用消息队列的有序性来验证是否有消息丢失。</strong>原理非常简单，在Producer端，我们给每个发出的消息附加一个连续递增的序号，然后在Consumer端来检查这个序号的连续性。</p><p>如果没有消息丢失，Consumer收到消息的序号必然是连续递增的，或者说收到的消息，其中的序号必然是上一条消息的序号+1。如果检测到序号不连续，那就是丢消息了。还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因。</p><p>大多数消息队列的客户端都支持拦截器机制，你可以利用这个拦截器机制，在Producer发送消息之前的拦截器中将序号注入到消息中，在Consumer收到消息的拦截器中检测序号的连续性，这样实现的好处是消息检测的代码不会侵入到你的业务代码中，待你的系统稳定后，也方便将这部分检测的逻辑关闭或者删除。</p><p>如果是在一个分布式系统中实现这个检测方法，有几个问题需要你注意。</p><p>首先，像Kafka和RocketMQ这样的消息队列，它是不保证在Topic上的严格顺序的，只能保证分区上的消息是有序的，所以我们在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。</p><p>如果你的系统中Producer是多实例的，由于并不好协调多个Producer之间的发送顺序，所以也需要每个Producer分别生成各自的消息序号，并且需要附加上Producer的标识，在Consumer端按照每个Producer分别来检测序号的连续性。</p><p>Consumer实例的数量最好和分区数量一致，做到Consumer和分区一一对应，这样会比较方便地在Consumer内检测消息序号的连续性。</p><h2>确保消息可靠传递</h2><p>讲完了检测消息丢失的方法，接下来我们一起来看一下，整个消息从生产到消费的过程中，哪些地方可能会导致丢消息，以及应该如何避免消息丢失。</p><p>你可以看下这个图，一条消息从生产到消费完成这个过程，可以划分三个阶段，为了方便描述，我给每个阶段分别起了个名字。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/05/81a01f5218614efea2838b0808709205.jpg?wh=3268*1447\" alt=\"\"></p><ul>\n<li><strong>生产阶段</strong>: 在这个阶段，从消息在Producer创建出来，经过网络传输发送到Broker端。</li>\n<li><strong>存储阶段</strong>: 在这个阶段，消息在Broker端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。</li>\n<li><strong>消费阶段</strong>: 在这个阶段，Consumer从Broker上拉取消息，经过网络传输发送到Consumer上。</li>\n</ul><p><strong>1. 生产阶段</strong></p><p>在生产阶段，消息队列通过最常用的请求确认机制，来保证消息的可靠传递：当你的代码调用发消息方法时，消息队列的客户端会把消息发送到Broker，Broker收到消息后，会给客户端返回一个确认响应，表明消息已经收到了。客户端收到响应后，完成了一次正常消息的发送。</p><p>只要Producer收到了Broker的确认响应，就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户。</p><p><strong>你在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失。</strong>以Kafka为例，我们看一下如何可靠地发送消息：</p><p>同步发送时，只要注意捕获异常即可。</p><pre><code>try {\n    RecordMetadata metadata = producer.send(record).get();\n    System.out.println(&quot;消息发送成功。&quot;);\n} catch (Throwable e) {\n    System.out.println(&quot;消息发送失败！&quot;);\n    System.out.println(e);\n}\n</code></pre><p>异步发送时，则需要在回调方法里进行检查。这个地方是需要特别注意的，很多丢消息的原因就是，我们使用了异步发送，却没有在回调中检查发送结果。</p><pre><code>producer.send(record, (metadata, exception) -&gt; {\n    if (metadata != null) {\n        System.out.println(&quot;消息发送成功。&quot;);\n    } else {\n        System.out.println(&quot;消息发送失败！&quot;);\n        System.out.println(exception);\n    }\n});\n</code></pre><p><strong>2. 存储阶段</strong></p><p>在存储阶段正常情况下，只要Broker在正常运行，就不会出现丢失消息的问题，但是如果Broker出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的。</p><p><strong>如果对消息的可靠性要求非常高，可以通过配置Broker参数来避免因为宕机丢消息。</strong></p><p>对于单个节点的Broker，需要配置Broker参数，在收到消息后，将消息写入磁盘后再给Producer返回确认响应，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息，恢复后还可以继续消费。例如，在RocketMQ中，需要将刷盘方式flushDiskType配置为SYNC_FLUSH同步刷盘。</p><p>如果是Broker是由多个节点组成的集群，需要将Broker集群配置成：至少将消息发送到2个以上的节点，再给客户端回复发送确认响应。这样当某个Broker宕机时，其他的Broker可以替代宕机的Broker，也不会发生消息丢失。后面我会专门安排一节课，来讲解在集群模式下，消息队列是如何通过消息复制来确保消息的可靠性的。</p><p><strong>3. 消费阶段</strong></p><p>消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递，客户端从Broker拉取消息后，执行用户的消费业务逻辑，成功后，才会给Broker发送消费确认响应。如果Broker没有收到消费确认响应，下次拉消息的时候还会返回同一条消息，确保消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失。</p><p>你在编写消费代码时需要注意的是，<strong>不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。</strong></p><p>同样，我们以用Python语言消费RabbitMQ消息为例，来看一下如何实现一段可靠的消费代码：</p><pre><code>def callback(ch, method, properties, body):\n    print(&quot; [x] 收到消息 %r&quot; % body)\n    # 在这儿处理收到的消息\n    database.save(body)\n    print(&quot; [x] 消费完成&quot;)\n    # 完成消费业务逻辑后发送消费确认响应\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\nchannel.basic_consume(queue='hello', on_message_callback=callback)\n</code></pre><p>你可以看到，在消费的回调方法callback中，正确的顺序是，先是把消息保存到数据库中，然后再发送消费确认响应。这样如果保存消息到数据库失败了，就不会执行消费确认的代码，下次拉到的还是这条消息，直到消费成功。</p><h2>小结</h2><p>这节课我带大家分析了一条消息从发送到消费整个流程中，消息队列是如何确保消息的可靠性，不会丢失的。这个过程可以分为分三个阶段，每个阶段都需要正确的编写代码并且设置正确的配置项，才能配合消息队列的可靠性机制，确保消息不会丢失。</p><ul>\n<li>在生产阶段，你需要捕获消息发送的错误，并重发消息。</li>\n<li>在存储阶段，你可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个Broker宕机或者磁盘损坏而丢失。</li>\n<li>在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认。</li>\n</ul><p>你在理解了这几个阶段的原理后，如果再出现丢消息的情况，应该可以通过在代码中加一些日志的方式，很快定位到是哪个阶段出了问题，然后再进一步深入分析，快速找到问题原因。</p><h2>思考题</h2><p>我刚刚讲到，如果消息在网络传输过程中发送错误，由于发送方收不到确认，会通过重发来保证消息不丢失。但是，如果确认响应在网络传输时丢失，也会导致重发消息。也就是说，<strong>无论是Broker还是Consumer都是有可能收到重复消息的，</strong>那我们在编写消费代码时，就需要考虑这种情况，你可以想一下，在消费消息的代码中，该如何处理这种重复消息，才不会影响业务逻辑的正确性？欢迎在留言区与我分享讨论。</p><p>感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给你的朋友。</p><p></p>","neighbors":{"left":{"article_title":"04 | 如何利用事务消息实现分布式事务？","id":111269},"right":{"article_title":"06 | 如何处理消费过程中的重复消息？","id":111552}},"comments":[{"had_liked":false,"id":119499,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1564619799,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"761773831191","product_id":100032301,"comment_content":"一句话，消费做好幂等性即可！","like_count":178,"discussions":[{"author":{"id":2296382,"avatar":"https://static001.geekbang.org/account/avatar/00/23/0a/3e/5b1b1b75.jpg","nickname":"流年","note":"","ucode":"8B579C6E466CB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335308,"discussion_content":"最简单经济的办法：数据库里存消息发送的msg_id设置为唯一索引，或者有业务参数比如订单号设置唯一索引也行。或者将msg_id存储到缓存里判断是否消费过了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1608165193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133918,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/5e/c5c62933.jpg","nickname":"lmtoo","note":"","ucode":"FCD5B9C941D448","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3779,"discussion_content":"你只说了消费的丢失，却没有说生产环节的丢失","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564805000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1133918,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/5e/c5c62933.jpg","nickname":"lmtoo","note":"","ucode":"FCD5B9C941D448","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16512,"discussion_content":"生产的丢失由生产者配合消息队列来保证！正是因为有了这层保证才有了可能出现重复消息的一种情况，所以我感觉最重要的还是要做好消费幂等性","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1568897434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3779,"ip_address":""},"score":16512,"extra":""},{"author":{"id":1434066,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","nickname":"今夜秋风和","note":"","ucode":"453C8197FFC81D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577579,"discussion_content":"还有一种情况是消费失败导致了重复消费的场景，消费幂等性保证很重要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656214600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":16512,"ip_address":""},"score":577579,"extra":""}]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115724,"discussion_content":"如果幂等操作代价很大，那么利用递增序列判断消息是否消费则是比较好的办法。比如消费操作是更新数据库中的一条记录，虽然多次更新也是幂等的，但毕竟IO、内存开销在那，而且是不必要的，那么在操作前做判断就是比较好的做法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578030764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1437292,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/6c/246fa0d1.jpg","nickname":"Mr.差不多","note":"","ucode":"946555FCAE710B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289562,"discussion_content":"比如 RockerMQ 只能保证在一个队列中是顺序发送，不保证在一个 Topic 中是顺序发送的，这时候再利用递增来判断就不合适了吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594134275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":115724,"ip_address":""},"score":289562,"extra":""},{"author":{"id":1952625,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/cb/71/2b58660a.jpg","nickname":"Ss","note":"","ucode":"38FF6695D1461B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1437292,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/6c/246fa0d1.jpg","nickname":"Mr.差不多","note":"","ucode":"946555FCAE710B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397102,"discussion_content":"那consumer可不可以针对某一个分区拉取的消息分别做递增序号\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632562596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289562,"ip_address":""},"score":397102,"extra":""}]},{"author":{"id":1318914,"avatar":"https://static001.geekbang.org/account/avatar/00/14/20/02/df2bfda9.jpg","nickname":"公共号","note":"","ucode":"4759B517D4CD5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52529,"discussion_content":"异步发送，produce宕机怎么操作？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574062783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1252813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","nickname":"徐同学呀","note":"","ucode":"03383EE820514D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318914,"avatar":"https://static001.geekbang.org/account/avatar/00/14/20/02/df2bfda9.jpg","nickname":"公共号","note":"","ucode":"4759B517D4CD5E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410331,"discussion_content":"producer宕机了那就是源头故障，给producer对应的客户端返回异常，由最前置的调用方决定如何处理，是故障转移还是重试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635666383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52529,"ip_address":""},"score":410331,"extra":""}]}]},{"had_liked":false,"id":126068,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566305333,"is_pvip":false,"replies":[{"id":"46513","content":"没毛病，很多底层的方法和技术就是通用的","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566351478,"ip_address":"","comment_id":126068,"utype":1}],"discussion_count":3,"race_medal":0,"score":"469717740597","product_id":100032301,"comment_content":"如何确保消息不会丢失<br>1：WAL<br>2：分布式WAL<br>除非地球爆炸，否则问题不大。<br>猜测各种消息队列或者数据库，确保消息不丢只能这么玩，就连人也一样，脑袋记不住那就写下来，怕本子弄潮啦！那就光盘、U盘、磁盘、布头、木头、石头北京、上海、深圳都各写一份。<br>consumer接到重复消息，那就业务去重，怎么去？<br>1：业务处理逻辑本身就是幂等的，那天然就去掉了<br>2：业务处理逻辑非幂等，那就消息先去重，根据业务ID(标识消息唯一性的就行)，去查询是否消费过此消息了，消费了，则抛弃，否则就消费","like_count":110,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463810,"discussion_content":"没毛病，很多底层的方法和技术就是通用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566351478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1487584,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","nickname":"鱼","note":"","ucode":"89EC9CE3AD0281","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289698,"discussion_content":"WAL主要应用场景是使用缓存以规避同步写磁盘的性能问题，由于缓存易丢失所以先写日志（writeing ahead log）以便与系统crash时恢复，例如MySQL的redo log。并不是所有场景都使用WAL，在没有使用缓存（性能要求不高）的场景，Sync刷到磁盘也是一个合理的选择。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1594184183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1642581,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/55/a854dc46.jpg","nickname":"刘知昊","note":"","ucode":"F493ADA56ECD3F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1487584,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","nickname":"鱼","note":"","ucode":"89EC9CE3AD0281","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383920,"discussion_content":"writing","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626308603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289698,"ip_address":""},"score":383920,"extra":""}]}]},{"had_liked":false,"id":119800,"user_name":"ly","can_delete":false,"product_type":"c1","uid":1221628,"ip_address":"","ucode":"5E2B85252DABF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/fc/379387a4.jpg","comment_is_top":false,"comment_ctime":1564705355,"is_pvip":false,"replies":[{"id":"43990","content":"两个消费者先后去拉消息是否能拉到同一条消息？<br><br>首先，消息队列一般都会有协调机制，不会让这种情况出现，但是由于网络不确定性，这种情况还是在极小概率下会出现的。<br><br>在同一个消费组内，A消费者拉走了index=10的这条消息，还没返回确认，这时候这个分区的消费位置还是10，B消费者来拉消息，可能有2种情况：<br><br>1. 超时前，Broker认为这个分区还被A占用着，会拒绝B的请求。<br>2. 超时后，Broker认为A已经超时没返回，这次消费失败，当前消费位置还是10，B再来拉消息，会给它返回10这条消息。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564709445,"ip_address":"","comment_id":119800,"utype":1}],"discussion_count":5,"race_medal":0,"score":"280737579595","product_id":100032301,"comment_content":"老师，我有几个理解：<br>当produer发送消息给blocker的时候（send方法），此方法会在blocker收到消息并正常储存后才返回，此期间应该会阻塞，也就是如果blocker配置同步刷盘，可能会增加调用时间（只能出现对消息敏感的场景）。<br>另外拉消息的时候，消费者A进行pull后，没有返回确认给blocker就挂了（或者因代码问题导致一直阻塞），这时消息应该还在blocker的，消费者B如果此时pull消息，是否会拉取到刚刚那条给消费者A的消息？衍生的疑问就是两个消费者先后去拉消息是否能拉到同一条消息（在前者未给blocker发确认的前提下）。<br>对于消费者处理重复消息的问题：一般消息中都会存在一个唯一性的东西，不管是消息队列本身的msgId还是业务订单号之类的，可以在db中存在一个消费表，对这个唯一性东西建立唯一索引，每次处理消费者逻辑之前先insert进去，让数据库来帮我们排重我觉得是最保险的。","like_count":66,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461078,"discussion_content":"两个消费者先后去拉消息是否能拉到同一条消息？\n\n首先，消息队列一般都会有协调机制，不会让这种情况出现，但是由于网络不确定性，这种情况还是在极小概率下会出现的。\n\n在同一个消费组内，A消费者拉走了index=10的这条消息，还没返回确认，这时候这个分区的消费位置还是10，B消费者来拉消息，可能有2种情况：\n\n1. 超时前，Broker认为这个分区还被A占用着，会拒绝B的请求。\n2. 超时后，Broker认为A已经超时没返回，这次消费失败，当前消费位置还是10，B再来拉消息，会给它返回10这条消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564709445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581390,"avatar":"https://static001.geekbang.org/account/avatar/00/18/21/4e/363b1e65.jpg","nickname":"Andrew胖虎","note":"","ucode":"ED70A22E7DF733","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343957,"discussion_content":"多个消费者同一时间不能消费同一个队列，但是可以分时消费同一个队列，一个消费者内部可以多线程并发消费多个队列也可以单线程消费多个或者一个队列，不同的消费者组可以订阅同一个topic。老师分析的没毛病。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1611217694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1315147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","nickname":"xfan","note":"","ucode":"48ED8D498D7F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40093,"discussion_content":"原来分区会被消费者占用住","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572077126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253634,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/02/a691a1d2.jpg","nickname":"mangoliu","note":"","ucode":"B065A045A806C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82035,"discussion_content":"所以多个消费者消费同一个分区，是在分区里顺序消费消息的？index=10的消息没被消费则不会消费index=11的消息？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576312119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1459891,"avatar":"https://static001.geekbang.org/account/avatar/00/16/46/b3/dbc107c3.jpg","nickname":"尤未悔","note":"","ucode":"52651CA44D491A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1253634,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/02/a691a1d2.jpg","nickname":"mangoliu","note":"","ucode":"B065A045A806C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165441,"discussion_content":"你说的应该没错，\nhttps://rocketmq.apache.org/docs/best-practice-consumer/\nOrderly\nThe Consumer will lock each MessageQueue to make sure it is consumed one by one in order. This will cause a performance loss, but it is useful when you care about the order of the messages. It is not recommended to throw exceptions, you can return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT instead.","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1581295280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":82035,"ip_address":""},"score":165441,"extra":""}]}]},{"had_liked":false,"id":124110,"user_name":"王立光","can_delete":false,"product_type":"c1","uid":1058836,"ip_address":"","ucode":"3890B19E124960","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/14/875e8513.jpg","comment_is_top":false,"comment_ctime":1565827537,"is_pvip":false,"replies":[{"id":"45719","content":"是的。<br><br>rocketmq为了解决这个问题，增加了一个死信队列，对于这种反复投递都无法成功的消息，会被移动到死信队列中，避免卡住其他消息。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565917257,"ip_address":"","comment_id":124110,"utype":1}],"discussion_count":5,"race_medal":0,"score":"212019225041","product_id":100032301,"comment_content":"假如消费时由于某种原因，一直没发ack。rocketmq是不是会一直发这条消息，这样导致下面消息都无法被消费？","like_count":50,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463015,"discussion_content":"是的。\n\nrocketmq为了解决这个问题，增加了一个死信队列，对于这种反复投递都无法成功的消息，会被移动到死信队列中，避免卡住其他消息。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565917257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1496415,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d5/5f/f83f60fa.jpg","nickname":"沙海拾贝","note":"","ucode":"258BE5BAA6D277","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305867,"discussion_content":"使用这种方式，那就会打乱消息的顺序了？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600097100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1505221,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f7/c5/ffe52e87.jpg","nickname":"阿拉西恩木","note":"","ucode":"A3A62175137D3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1496415,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d5/5f/f83f60fa.jpg","nickname":"沙海拾贝","note":"","ucode":"258BE5BAA6D277","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308986,"discussion_content":"可能要看消息的顺序是否那么重要","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601148533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305867,"ip_address":""},"score":308986,"extra":""}]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6988,"discussion_content":"老师请问下kafka有类似死信队列的处理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567242061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1952625,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/cb/71/2b58660a.jpg","nickname":"Ss","note":"","ucode":"38FF6695D1461B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397103,"discussion_content":"我也想问一下 kafka是怎么操作的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632562753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6988,"ip_address":""},"score":397103,"extra":""}]}]},{"had_liked":false,"id":119540,"user_name":"kane","can_delete":false,"product_type":"c1","uid":1121849,"ip_address":"","ucode":"1B2735A33AF53E","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/39/923ed5b7.jpg","comment_is_top":false,"comment_ctime":1564623716,"is_pvip":false,"discussion_count":14,"race_medal":0,"score":"164773380964","product_id":100032301,"comment_content":"产生重复消息原因：<br>(1).发送消息阶段，发送重复的消息<br>(2)  消费消息阶段，消费重复的消息。<br>解决办法：<br>业务端去重<br>1）建立一个消息表，consumer消费之前，拿到消息做insert操作，用消息id做唯一主键，重复消费会导致主键冲突。<br>2）利用redis，给消息分配一个全局id，只要消费过该消息，将消息以K-V（&lt; id,message&gt;）形式写入redis，消费消息之前，根据key去redis查询是否有对应记录。","like_count":39,"discussions":[{"author":{"id":1121849,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/39/923ed5b7.jpg","nickname":"kane","note":"","ucode":"1B2735A33AF53E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3847,"discussion_content":"上亿数据也可以处理的，redis只是用来做判重用的，只需要一个bit就可以表示，不知道是否用过redis位运算存储，1亿的数据占用内存才几十兆。至于数据库存储的话可以采用分库分表策略。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1564880564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1333094,"avatar":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","nickname":"liliumss","note":"","ucode":"A52AC5042F3115","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121849,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/39/923ed5b7.jpg","nickname":"kane","note":"","ucode":"1B2735A33AF53E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4423,"discussion_content":"赞一个 是否在生成环境中使用过次方案呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565409986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3847,"ip_address":""},"score":4423,"extra":""},{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1333094,"avatar":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","nickname":"liliumss","note":"","ucode":"A52AC5042F3115","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325784,"discussion_content":"qmq就是这两种级别的幂等处理，都支持注解指定了，携程集团都在用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605430320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4423,"ip_address":""},"score":325784,"extra":""},{"author":{"id":1004593,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/31/b4f14b84.jpg","nickname":"James","note":"","ucode":"94920E60C5936E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1333094,"avatar":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","nickname":"liliumss","note":"","ucode":"A52AC5042F3115","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347413,"discussion_content":"我用过bitmap过滤","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612228307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4423,"ip_address":""},"score":347413,"extra":""}]},{"author":{"id":1635388,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f4/3c/60bf7a17.jpg","nickname":"快乐的平头哥","note":"","ucode":"D7D2FA5DA6D8BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260638,"discussion_content":"这样搞 引入分布式事务了 你如何保证 redis操作 和你 消息操作 原子性","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588870203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1208163,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","nickname":"扬～","note":"","ucode":"6FA7D8FE188341","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4278,"discussion_content":"采用时间段过期吧，一段时间后该id的消息必然在网络中失效啊，异常情况概率极低！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565267958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366632,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/68/11ab05f3.jpg","nickname":"user","note":"","ucode":"D8C53679C24B61","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340828,"discussion_content":"连续ID  时间排期 redis bitmap过滤","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610172250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1159647,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b1/df/e7f5ea7f.jpg","nickname":"攀攀","note":"","ucode":"217AFD7620D24E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53806,"discussion_content":"redis 成本太高了   数据量一上来  保准老板来找你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574218879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/5f/f583b09f.jpg","nickname":"Esun","note":"","ucode":"27A8B8AA573186","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32434,"discussion_content":"如果是非关系型数据库可以用布隆过滤器来做判断。，关系型数据可，直接根据id让其自己处理即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571036714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1315147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","nickname":"xfan","note":"","ucode":"48ED8D498D7F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/5f/f583b09f.jpg","nickname":"Esun","note":"","ucode":"27A8B8AA573186","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40094,"discussion_content":"布隆过滤器并不能用于数据量过大的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572077276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":32434,"ip_address":""},"score":40094,"extra":""},{"author":{"id":1881153,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/b4/41/82ac102c.jpg","nickname":"Geek","note":"","ucode":"740790D3686F8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1315147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","nickname":"xfan","note":"","ucode":"48ED8D498D7F56","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296471,"discussion_content":"不能用于数据量过大是因为误判率随着时间推移会升高，只要定时清除过滤器即可，同时可用布隆过滤器反向判断，只要不存在，那就是一定不存在，这样就可以保证幂等性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596551200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40094,"ip_address":""},"score":296471,"extra":""}]},{"author":{"id":1473875,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7d/53/23a1f93e.jpg","nickname":"康华","note":"","ucode":"E0BC22AB32735B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3807,"discussion_content":"亿级的数据应该都分块处理了吧，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564826825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131956,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","nickname":"oscarwin","note":"","ucode":"492430BA342593","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3741,"discussion_content":"还有一个问题，如果写入消费记录失败了怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564745168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1617635,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/UjJxt7s40XpVpzhOjLia40EVhPTna0jCkxBbiby3lp8HNdKFRlEo54uTaUic0HlXEcjLmVJxMYVoVFmzEV3llv5Fg/132","nickname":"Geek_刀子","note":"","ucode":"70A814C7A1EBEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3646,"discussion_content":"不管是存数据库还是redis，当数量达到亿级的时候，该怎么处理呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564656648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142730,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1571482498,"is_pvip":true,"replies":[{"id":"55242","content":"Broker不知道ack有没有送达到producer，它也不管是不是送达了。<br><br>因为，这个阶段的消息可靠性是由producer来保证的，它发了消息，收到了ack，那消息就一定送达了。如果没收到ack，那消息有可能送达了（ack丢失），也有可能没送达（消息丢失），对于这种情况，producer一般会重发消息，确保消息送达。这也就是为什么消息会有重复的原因之一。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1571619973,"ip_address":"","comment_id":142730,"utype":1}],"discussion_count":2,"race_medal":0,"score":"126125534082","product_id":100032301,"comment_content":"老师，再看一次这个的时候有个疑问: <br>1，broker给producer发送ack，网络原因或者其他原因producer没收到，这种情况broker这条消息怎么办？<br>2，broker给producer发送ack，broker怎么知道producer有没有成功收到这条ack信息呢？","like_count":30,"discussions":[{"author":{"id":1138821,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","nickname":"与路同飞","note":"","ucode":"2985F1440A1962","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311556,"discussion_content":"因为这个信息是单向的，不需要类似tcp链接那种三次握手","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602399062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471248,"discussion_content":"Broker不知道ack有没有送达到producer，它也不管是不是送达了。\n\n因为，这个阶段的消息可靠性是由producer来保证的，它发了消息，收到了ack，那消息就一定送达了。如果没收到ack，那消息有可能送达了（ack丢失），也有可能没送达（消息丢失），对于这种情况，producer一般会重发消息，确保消息送达。这也就是为什么消息会有重复的原因之一。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571619973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142648,"user_name":"陈天柱","can_delete":false,"product_type":"c1","uid":1696225,"ip_address":"","ucode":"917BFDC845760D","user_header":"https://static001.geekbang.org/account/avatar/00/19/e1/e1/441df85d.jpg","comment_is_top":false,"comment_ctime":1571447447,"is_pvip":false,"replies":[{"id":"55234","content":"你这个例子中，最终一致性应该是指：“经过一段时间后，订单状态和优惠券状态最终会保持一致。”<br><br>但是，你这个场景不太适合使用事务消息来解决，虽然和我们上节课中的例子相比，只是把购物车换成了优惠券。但你有没有考虑到，有人会恶意利用这个短暂的不一致时间来刷优惠券？比如，利用下单成功，但优惠券还没来得及扣减这个时间差，一个优惠券反复下单？<br>","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1571619721,"ip_address":"","comment_id":142648,"utype":1}],"discussion_count":4,"race_medal":0,"score":"96060727959","product_id":100032301,"comment_content":"老师您好，我最近处理一个分布式事务场景，就是支付成功以后回调处理刷新订单状态和刷新优惠券状态的分布式事务问题。我有一个疑问就是，假如刷新订单状态失败，就没有发消息到队列中，而是在刷新订单状态成功了以后，再发消息到队列中，只要保证消息不丢的前提下，分布式事务能得到保证吗？换言之，就是消息不丢的话，可以保证最终一致性，事务消息的回查也能保证最终一致性，两者的概念感觉有一些交集。所以希望老师能抽空帮忙分析一下，万分感谢🙏","like_count":23,"discussions":[{"author":{"id":1696225,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e1/e1/441df85d.jpg","nickname":"陈天柱","note":"","ucode":"917BFDC845760D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39578,"discussion_content":"老师指出了我之前的一个误解，在订单和优惠券这个场景，是强一致性场景，最好不要用事务消息来做。老师太赞了","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1571962453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763466,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e8/8a/803a42e0.jpg","nickname":"junmawang","note":"","ucode":"977E9E25CE6C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289865,"discussion_content":"在支付完未收到成功通知之前，也可以将优惠券和支付状态设置一个中间状态，这样可以避免刷优惠券，将支付中的订单加入到延时队列，比如半小时未收到成功通知，则取消订单并恢复优惠券","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1594254911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471211,"discussion_content":"你这个例子中，最终一致性应该是指：“经过一段时间后，订单状态和优惠券状态最终会保持一致。”\n\n但是，你这个场景不太适合使用事务消息来解决，虽然和我们上节课中的例子相比，只是把购物车换成了优惠券。但你有没有考虑到，有人会恶意利用这个短暂的不一致时间来刷优惠券？比如，利用下单成功，但优惠券还没来得及扣减这个时间差，一个优惠券反复下单？\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571619721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1158603,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ad/cb/3391d24c.jpg","nickname":"Halo","note":"","ucode":"12CFC7DFF250AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270993,"discussion_content":"那解决方案是？支付成功后，同时请求优惠券系统，冻结优惠券。待订单处理完成后发送消息最终决定优惠券是否消费成功吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590072533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119696,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1564656226,"is_pvip":false,"replies":[{"id":"43977","content":"不用加餐，这是教学大纲内的内容，下节课就会讲到滴。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564708483,"ip_address":"","comment_id":119696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"65989165666","product_id":100032301,"comment_content":"建议老师加餐如何做幂等性","like_count":15,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461023,"discussion_content":"不用加餐，这是教学大纲内的内容，下节课就会讲到滴。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564708483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120505,"user_name":"lis","can_delete":false,"product_type":"c1","uid":1610208,"ip_address":"","ucode":"B7FBED7F2555DA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2xoGmvlQ9qfSibVpPJyyaEiaibtVdbp1ibiboW174W4kHXLatN5E22s5cialsdc7xPTf4ZC03icFGVlfAV3MmicPt4ybkg/132","comment_is_top":false,"comment_ctime":1564918307,"is_pvip":false,"replies":[{"id":"44270","content":"放到私信队列中，人工处理。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564968034,"ip_address":"","comment_id":120505,"utype":1}],"discussion_count":4,"race_medal":0,"score":"48809558563","product_id":100032301,"comment_content":"rocketmq默认失败重试次数是2，如果2次均失败，或者说重试次数都失败了，这种情况一般在实际生产中是怎么处理的？","like_count":11,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461365,"discussion_content":"放到私信队列中，人工处理。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564968034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1402254,"avatar":"https://static001.geekbang.org/account/avatar/00/15/65/8e/d0c3bed3.jpg","nickname":"kg200704","note":"","ucode":"C58729CE07CCA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564922,"discussion_content":"kafka原生不支持死信队列，可以创建一个单独的topic做死信队列。所有消费失败并达到最大重试次数的消息统一发到这个topic里。而后做定时补偿或者人工补偿。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650355597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/10/4d2d6e64.jpg","nickname":"劳动维权","note":"","ucode":"1D5CEB96618E01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341183,"discussion_content":"kafka没有设计失败时的重试队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610344013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6987,"discussion_content":"kafka也有相关的重试失败处理队列？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567241672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125847,"user_name":"angel😇txy🤓","can_delete":false,"product_type":"c1","uid":1133702,"ip_address":"","ucode":"C0AEE0D8BAF7ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","comment_is_top":false,"comment_ctime":1566264682,"is_pvip":true,"replies":[{"id":"46237","content":"这个总结非常到位！","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566266731,"ip_address":"","comment_id":125847,"utype":1}],"discussion_count":7,"race_medal":0,"score":"44515937642","product_id":100032301,"comment_content":"思考题，从两个环节展开，生产端到broker，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据，这个内部消息ID的特性是：<br><br>（1）全局唯一<br><br>（2）MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽<br>有了这个inner-msg-id，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等。<br>broker到consumer，由消费端做好幂等性，比如根据业务流水号去重","like_count":11,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463717,"discussion_content":"这个总结非常到位！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566266731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087488,"avatar":"https://static001.geekbang.org/account/avatar/00/10/98/00/beef9f34.jpg","nickname":"半个菠萝蜜","note":"","ucode":"F548BC61CA9BDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285801,"discussion_content":"有个疑问请教下：inner-msg-id 是MQ内部生产，那么生产端到broker消息重发的时候，新生成的inner-msg-id会一样么？如何确保只有1条信息落到MQ-server的DB中呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592957452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2344609,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c6/a1/3bdcde91.jpg","nickname":"向陽花开花向陽🌸","note":"","ucode":"9FDD01BE0E42CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1087488,"avatar":"https://static001.geekbang.org/account/avatar/00/10/98/00/beef9f34.jpg","nickname":"半个菠萝蜜","note":"","ucode":"F548BC61CA9BDD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335807,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608339259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285801,"ip_address":""},"score":335807,"extra":""},{"author":{"id":1182383,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/af/6f244997.jpg","nickname":"lee","note":"","ucode":"CD672BDB1B58F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1087488,"avatar":"https://static001.geekbang.org/account/avatar/00/10/98/00/beef9f34.jpg","nickname":"半个菠萝蜜","note":"","ucode":"F548BC61CA9BDD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381283,"discussion_content":"我觉得可以用CRC32或者CRC64对消息内容做摘要即可作为全局唯一id","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624980368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285801,"ip_address":""},"score":381283,"extra":""},{"author":{"id":1272996,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6c/a4/7f7c1955.jpg","nickname":"死磕郎一世","note":"","ucode":"86C1197C3FB2A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1087488,"avatar":"https://static001.geekbang.org/account/avatar/00/10/98/00/beef9f34.jpg","nickname":"半个菠萝蜜","note":"","ucode":"F548BC61CA9BDD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544829,"discussion_content":"一样的疑问，生产者重发，这个inner-msg-id就无法保证幂等性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641726966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285801,"ip_address":""},"score":544829,"extra":""}]},{"author":{"id":2891918,"avatar":"","nickname":"黄欢","note":"","ucode":"9E244E76A908EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548915,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643444913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6992,"discussion_content":"请问这个全局 inner-msg-id 要如何生成呢？有没有成熟的方案推荐下？ 这个全局id是有序的？ 通过它可以保证分布式节点下应用的顺序性消费？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567243763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119707,"user_name":"TH","can_delete":false,"product_type":"c1","uid":1053413,"ip_address":"","ucode":"C5EA20546DC09C","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/e5/592d9324.jpg","comment_is_top":false,"comment_ctime":1564660147,"is_pvip":true,"replies":[{"id":"43985","content":"不用，Producer发消息的时候带着ProducerId并要指定分区发送，Consumer消费的时候，需要按照每个Producer来检查序号的连续性。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564708858,"ip_address":"","comment_id":119707,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35924398515","product_id":100032301,"comment_content":"幂等性是一种办法，如果做不到幂等性，那么在消费端需要存储消费的消息ID，关键这个ID什么时候存？如果是消费前就存，那么消费失败了，下次消费同样的消息，是否会认为上次已经成功了？如果在消费成功后再存，那么消费会不会出现部分成功的情况？除非满足事务ACID特性。<br><br>关于消息丢失检查还有一点疑问：如果靠ID连续性来检查，是不是说一个producer只能对应一个consumer？","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461028,"discussion_content":"不用，Producer发消息的时候带着ProducerId并要指定分区发送，Consumer消费的时候，需要按照每个Producer来检查序号的连续性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564708858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119700,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1564658527,"is_pvip":false,"replies":[{"id":"43982","content":"思路是没问题的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564708623,"ip_address":"","comment_id":119700,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35924396895","product_id":100032301,"comment_content":"1、消费端支持幂等操作，业务上一般有难度；<br>2、消费端增加去冗余机制，例如缓存最新消费成功的N条消息的SN，收到消息后，先确认是否是消费过的消息，如果是，直接应该ACK，并放弃消费。","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461025,"discussion_content":"思路是没问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564708623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119624,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1564640197,"is_pvip":true,"replies":[{"id":"43969","content":"非常好！但你需要考虑一下，在分布式环境中“Consumer接受消息前判断是否有相同标识的消息”该如何实现呢？","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564708016,"ip_address":"","comment_id":119624,"utype":1}],"discussion_count":3,"race_medal":0,"score":"35924378565","product_id":100032301,"comment_content":"对于思考题，我认为也可以像老师说的那样查看消息是否丢失的方法，如果Producer的某条消息ack相应因为网络故障丢失，那么Producer此时重发消息的唯一标识应该和之前那条消息是一样的，那么只需要在Consumer接受消息前判断是否有相同标识的消息，如果有则拦截。还可以在消费端业务逻辑接口中做幂等判断，前面那种可以做到不侵入到业务代码中，老师看看有没有什么问题","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460986,"discussion_content":"非常好！但你需要考虑一下，在分布式环境中“Consumer接受消息前判断是否有相同标识的消息”该如何实现呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564708016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115728,"discussion_content":"其实用本课中判断消息丢失的方法来判断消息重复也是一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578031152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087945,"avatar":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","nickname":"冰激凌的眼泪","note":"","ucode":"5DCB974667E93A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3953,"discussion_content":"用redis做标识共享是否可以？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565003860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119548,"user_name":"芥末小龙","can_delete":false,"product_type":"c1","uid":1176417,"ip_address":"","ucode":"387D01880867AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/61/8f7fca5b.jpg","comment_is_top":false,"comment_ctime":1564624773,"is_pvip":false,"replies":[{"id":"43880","content":"你这结论都是用无数bug换来的呀。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564629526,"ip_address":"","comment_id":119548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31629395845","product_id":100032301,"comment_content":"玥哥好，我jio着只要在消费端做好幂等就可以，业务借口最好都要做幂等性校验，","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460948,"discussion_content":"你这结论都是用无数bug换来的呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564629526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129778,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1567247079,"is_pvip":false,"replies":[{"id":"48720","content":"A1： 关于第一个问题，你可以看一下“08疑难解答”这节课，里面有专门的一个小结来讲如何用消息队列实现严格顺序。<br><br>A2：你的理解是正确的。关于参数配置，只要你明白了收发消息的原理，再去看一下配置的说明，应该很容易就理解了。每个消息队列的文档中，都会有专门的一篇文档，列出所有的配置以及每个配置的含义，你可以参考。<br><br>A3：自动提交或者手动提交不是关键问题，关键的问题就是“先执行消费逻辑，再提交消费确认”。比如，RocketMQ Consumer的OnMessage方法，它会在成功执行完这个方法后提交消费确认，如果抛出异常就不会提交消费确认。你只要在这个方法中执行你的消费逻辑，消费错误的时候抛出异常，即使自动提交也能保证我们说的“先执行消费逻辑，再提交消费确认”。<br><br>","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1567490430,"ip_address":"","comment_id":129778,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18747116263","product_id":100032301,"comment_content":"老师您好我看了这篇文章有几个疑惑希望您帮忙解答下:<br>1.kafka 和 rocketmq 都不能保证全局topic的顺序性，只能保证 partition 分区的消息顺序性，那我需要保证全局唯一性的场景要如何处理比较好，都有哪些方式可以保证消息的全局顺序性?<br>文章里您说 可以在 Producer 分别生成各自的消息序号,并且需要附加上 Producer 的标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续性。<br>这个句话的意识是说 在 producer 生产消息时要生成一个 全局有序递增的消息id? 然后再 consumer消费时 通过这个id进行消费控制?<br>因为一个 consumer group 可能包含 多个 consumer ，这个要怎么控制分布式环境下多个consumer消费的顺序呢？ 还有consumer也可能发送 reblance操作导致消费分区发生变化<br>2.确保消息可靠传递方面<br>#1.如果 存储阶段 发生极端情况: broker 在收到 消息后还未来得及写入磁盘就发生 broker 掉电宕机情况, 这个消息会丢失? <br>   还是producer端先进行自动重试处理，broker都挂了，重试肯定会超时失败，如果达到producer端重试最大次数还是失败，才会向producer端抛出异常<br>   而 producer端 可以捕获这个异常 进行业务的补偿重试 或 降级 保证消息不丢 (入队列 or redis or 入库) , 再进行 后续处理。是这样? 不知道我理解的是否正确<br>   提个建议: 希望老师把关键参数 列一下 或者 给个参考链接 我们去看下不熟悉现找确实比较费劲 不同版本差异也比较大<br><br>#2.对于消费阶段   <br>在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认-&gt; <br>这个是要求在生产阶段都采用 手动 提交方式处理? consumer 每次pull 过程中自动提交会有问题？<br>比如 文章中例子，在自动提交情况下 保存db出异常，在下次 拉取消息时会自动提交刚才的消息，所以才要求手动提交消费进度?","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465644,"discussion_content":"A1： 关于第一个问题，你可以看一下“08疑难解答”这节课，里面有专门的一个小结来讲如何用消息队列实现严格顺序。\n\nA2：你的理解是正确的。关于参数配置，只要你明白了收发消息的原理，再去看一下配置的说明，应该很容易就理解了。每个消息队列的文档中，都会有专门的一篇文档，列出所有的配置以及每个配置的含义，你可以参考。\n\nA3：自动提交或者手动提交不是关键问题，关键的问题就是“先执行消费逻辑，再提交消费确认”。比如，RocketMQ Consumer的OnMessage方法，它会在成功执行完这个方法后提交消费确认，如果抛出异常就不会提交消费确认。你只要在这个方法中执行你的消费逻辑，消费错误的时候抛出异常，即使自动提交也能保证我们说的“先执行消费逻辑，再提交消费确认”。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567490430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125841,"user_name":"angel😇txy🤓","can_delete":false,"product_type":"c1","uid":1133702,"ip_address":"","ucode":"C0AEE0D8BAF7ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","comment_is_top":false,"comment_ctime":1566264499,"is_pvip":true,"replies":[{"id":"46236","content":"一般来说，消费都是采用pull的模式，消费者主动去broker来拉消息，如果消费者返回ack，Broker就会更新消费位置，如果消费者不返回ack，broker就什么都不做，直到下次消费者再来拉消息，因为消费位置没有更新，所以拉到的还是之前的那批消息，这样就实现了“重试”的效果。<br><br>在kafka中，消费位置都是用户代码来手动提交消费位置，所以，也就不存在“消费端消费时抛异常后，卡夫卡处理的”的问题，因为这完全取决于你的代码如何来编写了。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566266628,"ip_address":"","comment_id":125841,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18746133683","product_id":100032301,"comment_content":"消费端消息丢失，请老师再展开讲一下，比如broker一直收不到消费者的ack，会怎么办？还有消费端消费时抛异常后，卡夫卡处理的？","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463715,"discussion_content":"一般来说，消费都是采用pull的模式，消费者主动去broker来拉消息，如果消费者返回ack，Broker就会更新消费位置，如果消费者不返回ack，broker就什么都不做，直到下次消费者再来拉消息，因为消费位置没有更新，所以拉到的还是之前的那批消息，这样就实现了“重试”的效果。\n\n在kafka中，消费位置都是用户代码来手动提交消费位置，所以，也就不存在“消费端消费时抛异常后，卡夫卡处理的”的问题，因为这完全取决于你的代码如何来编写了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566266628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6995,"discussion_content":"我觉得他是想问 kafka cosumer消费时 pull一批数据, 对齐进行业务消费时出现异常 导致consumer无法向broker发送 消费成功ack时，消费offset一直不会更新，后续的消息也不会被处理而出现积压情况，这种情况kafka 是否提供了相关策略进行处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567244155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6993,"discussion_content":"请问老师kafka在消费时，我们是该手动提交还是自动提交这个 消费offset","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567243948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119993,"user_name":"skyun","can_delete":false,"product_type":"c1","uid":1002658,"ip_address":"","ucode":"38097F3FF1045C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/a2/00241866.jpg","comment_is_top":false,"comment_ctime":1564747290,"is_pvip":false,"replies":[{"id":"44106","content":"。如果Broker是集群模式，其他的Broker会替代宕机的Broker来继续进行反查。如果Broker是单节点，只能等到Broker恢复后再继续进行反查。无论哪种模式，消息不会丢，是保存在磁盘上的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564799258,"ip_address":"","comment_id":119993,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18744616474","product_id":100032301,"comment_content":"老师，我关于事务消息有个疑问：如果生产者在执行完本地事务后向broke提交确认，但是此时broke挂了，提交失败，broke因为挂了也无法进行回查，那么此时这条消息是不是就丢了，从而导致两个系统中数据不一致，还是说这个不一致只是暂时的，等broke重启后，依旧会根据halfMessage进行回查？望解答","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461168,"discussion_content":"。如果Broker是集群模式，其他的Broker会替代宕机的Broker来继续进行反查。如果Broker是单节点，只能等到Broker恢复后再继续进行反查。无论哪种模式，消息不会丢，是保存在磁盘上的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564799258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607328,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/fy6KTCIk6JPGdOYbvsXJ4h1zq8a6P6sHiau0t2hBxxZfSeE2ymJmWsnb7YzxUO3byr1n30UoYD2XrXDwlrQa6lQ/132","nickname":"Ericens","note":"","ucode":"95AB0416F8EF7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31412,"discussion_content":"我的观点你的流程错了，应该是先发送broker消息，再提交本地事务，再有向broker的发送commit消息。基于此流程你的说问题也不再是问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570919596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165321,"user_name":"虚竹","can_delete":false,"product_type":"c1","uid":1691109,"ip_address":"","ucode":"8D8C96C793724E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJIocn8OMjfSGqyeSJEV3ID2rquLR0S6xo0ibdNYQgzicib6L6VlqWjhgxOqD2iaicX1KhbWXWCsmBTskA/132","comment_is_top":false,"comment_ctime":1577200199,"is_pvip":false,"replies":[{"id":"65567","content":"增加一个服务也不能解决这个问题，如果调用这个服务失败了怎么办？所以理论上，这个问题是无解的。<br><br>实际生产中，还是靠发送方检查发消息的响应来确认消息是否发成功了，并且，还要决定发失败的消息该如何处理。<br><br>比如，某些监控类应用，可以把发失败的消息直接丢掉。<br><br>再比如，重要的订单类的应用，他们会做多重的降级方案，一般建二个topic，第一个发失败了，换第二个发，再发失败了写数据库。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1578274645,"ip_address":"","comment_id":165321,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14462102087","product_id":100032301,"comment_content":"老师好，关于消息丢失问题，不止发mq，也可能是发es、钉钉、短信、邮件等，如果需要每个业务自己保证消息发出，是比较困难的，<br>在考虑应该以微服务的形式提供这些发消息的接口，微服务内部保证消息发送成功，可以通过时间递减等方式重试，一直不成功则<br>持久化存储提醒人工操作，这里还可以加一些监控阈值报警异常发送情况，同时这里需要支持web搜索查看某个消息是否发送成功或失败，因为涉及到业务判罚，业务人员比较重视，<br>想问下目前业界是否有开源的相关的实现？<br>京东内部是如何处理这个问题的？<br>另外我的思路是否有可行？<br>期待老师帮忙解惑~","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479119,"discussion_content":"增加一个服务也不能解决这个问题，如果调用这个服务失败了怎么办？所以理论上，这个问题是无解的。\n\n实际生产中，还是靠发送方检查发消息的响应来确认消息是否发成功了，并且，还要决定发失败的消息该如何处理。\n\n比如，某些监控类应用，可以把发失败的消息直接丢掉。\n\n再比如，重要的订单类的应用，他们会做多重的降级方案，一般建二个topic，第一个发失败了，换第二个发，再发失败了写数据库。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578274645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603030,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/d6/259e6ba2.jpg","nickname":"杜劲松","note":"","ucode":"36A213BD2DF424","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550581,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644601210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407033,"discussion_content":"目前分布式解决问题的方式就是两阶段提交保证消息是可达broker的 除非网络不通 或者broker宕机","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634897269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119828,"user_name":"王麒","can_delete":false,"product_type":"c1","uid":1265260,"ip_address":"","ucode":"330017C5A911B6","user_header":"https://static001.geekbang.org/account/avatar/00/13/4e/6c/71020c59.jpg","comment_is_top":false,"comment_ctime":1564708988,"is_pvip":false,"replies":[{"id":"44095","content":"一般的建议是用多台Broker配置成集群，异步刷盘，复制后再返回发送成功确认，性能比同步刷盘要好一些。<br>","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564797985,"ip_address":"","comment_id":119828,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14449610876","product_id":100032301,"comment_content":"每次将消息刷磁盘会不会有性能损耗，有其他持久化方式吗？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461089,"discussion_content":"一般的建议是用多台Broker配置成集群，异步刷盘，复制后再返回发送成功确认，性能比同步刷盘要好一些。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564797985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367857,"discussion_content":"性能损耗针对rocketmq与kafka 来说已经做了优化。他们都采用追加方式 不支持修改 操作系统这块的写盘策略还是很成熟的 顺便提一句 这对这种场景ssd在这里优势不会太明显","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618487246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593141,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/35/7828e961.jpg","nickname":"Geek_20e78b","note":"","ucode":"647D06E867469A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326108,"discussion_content":"可是老师难道不是说在单节点的Broker,只能使用同步刷盘的么，所以如果是Kafka的化，单节点的同步刷盘又该怎么刷呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605523783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119658,"user_name":"DC","can_delete":false,"product_type":"c1","uid":1250344,"ip_address":"","ucode":"EC0E7E86056FA6","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/28/9e3edef0.jpg","comment_is_top":false,"comment_ctime":1564647709,"is_pvip":false,"replies":[{"id":"43975","content":"且听下回分解。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564708339,"ip_address":"","comment_id":119658,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449549597","product_id":100032301,"comment_content":"对于重复消息风险的处理代码，必须做好幂等。<br>有一种场景，消息发出后因为网络问题没有得到响应，此时服务挂掉，也无法重新发起消息，这种情况这个消息算丢失了吧。<br>思路是在发消息前需要记录消息发送记录，发送完成后标记完成，重启服务后查看发送消息，确无响应的消息，进行重发。不知道我提到的场景是否有问题","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461002,"discussion_content":"且听下回分解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564708339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119552,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1564624953,"is_pvip":false,"replies":[{"id":"43883","content":"发送失败后如何处理需要看业务逻辑，当然主动重试也是一种方式。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564629810,"ip_address":"","comment_id":119552,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449526841","product_id":100032301,"comment_content":"请教下，在生产阶段，你需要捕获消息发送的错误，并重发消息。<br>那是在catch块里，再次调用发送消息的接口吧？如下<br>try {<br>    RecordMetadata metadata = producer.send(record).get();<br>    System.out.println(&quot; 消息发送成功。&quot;);<br>} catch (Throwable e) {<br>    producer.send(record).get();&#47;&#47;  再次发送<br>    System.out.println(&quot; 消息发送失败！&quot;);<br>    System.out.println(e);<br>}<br>","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460951,"discussion_content":"发送失败后如何处理需要看业务逻辑，当然主动重试也是一种方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564629810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119537,"user_name":"月下独酌","can_delete":false,"product_type":"c1","uid":1612635,"ip_address":"","ucode":"E79579ACEE25DF","user_header":"https://static001.geekbang.org/account/avatar/00/18/9b/5b/eee80536.jpg","comment_is_top":false,"comment_ctime":1564623448,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14449525336","product_id":100032301,"comment_content":"消息需要入库可以靠唯一索引或主键约束，判断为重复的数据无法插入","like_count":3},{"had_liked":false,"id":190486,"user_name":"凌空飞起的剪刀腿","can_delete":false,"product_type":"c1","uid":1243680,"ip_address":"","ucode":"16FBBF4A3B54C6","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/20/0f06b080.jpg","comment_is_top":false,"comment_ctime":1584664026,"is_pvip":false,"replies":[{"id":"73507","content":"是的，常见的消息队列，比如RockMQ、Kafka都是一直轮询的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1584845070,"ip_address":"","comment_id":190486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174598618","product_id":100032301,"comment_content":"李老师您好，我想知道订阅者怎么知道broker有他订阅的消息的，不能一直轮询吧？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487991,"discussion_content":"是的，常见的消息队列，比如RockMQ、Kafka都是一直轮询的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584845070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140684,"user_name":"指尖凉","can_delete":false,"product_type":"c1","uid":1563687,"ip_address":"","ucode":"D6405BD431B8CC","user_header":"https://static001.geekbang.org/account/avatar/00/17/dc/27/e70a44fe.jpg","comment_is_top":false,"comment_ctime":1571029156,"is_pvip":false,"replies":[{"id":"54388","content":"使用死信队列就不能保证严格顺序了。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1571033963,"ip_address":"","comment_id":140684,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10160963748","product_id":100032301,"comment_content":"如果同一个操作的几个消息需要顺序消费，但第一个消息一直消费失败，放到了死信队列，那为了保证顺序性，后面的几条消息要怎么处理？是要直接放入到死信队列还是怎么样？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470509,"discussion_content":"使用死信队列就不能保证严格顺序了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571033963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120869,"user_name":"其","can_delete":false,"product_type":"c1","uid":1486367,"ip_address":"","ucode":"93A2EBA79E3066","user_header":"https://static001.geekbang.org/account/avatar/00/16/ae/1f/43b13ef0.jpg","comment_is_top":false,"comment_ctime":1565007426,"is_pvip":false,"replies":[{"id":"44469","content":"A1：消费失败可以通过重试来保证，需要做的是在消费者，消费成功计数器才+1.<br><br>A2：是的，这种方法很难做到自动兼容扩容的情况。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565054540,"ip_address":"","comment_id":120869,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10154942018","product_id":100032301,"comment_content":"老师，通过consumer验证序号的连续性，我这边有两个问题<br>第一，消费失败的情况，是不是就无法保证了<br>第二，broker扩容的时候，那么之前发送到同一个队列的producer是不是也无法保证在发送到相同的队列了","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461510,"discussion_content":"A1：消费失败可以通过重试来保证，需要做的是在消费者，消费成功计数器才+1.\n\nA2：是的，这种方法很难做到自动兼容扩容的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565054540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120239,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1564813406,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"10154747998","product_id":100032301,"comment_content":"我在使用 rabbitmq 的时候，消费端开启了消息消费后的ack机制，当一条消息处理业务比较复杂的时候，处理的时间比较长，broker端长时间收不到该消息的ack确定信息，队列中后面的消息就无法继续消费，这样就会严重拉下 rabbitmq 的处理性能","like_count":2},{"had_liked":false,"id":119656,"user_name":"敬艺","can_delete":false,"product_type":"c1","uid":1109680,"ip_address":"","ucode":"08B559B123A1BB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/b0/fb5bad5c.jpg","comment_is_top":false,"comment_ctime":1564647444,"is_pvip":false,"replies":[{"id":"43974","content":"在消费端，即使同一个消费组里面有多个实例，只要你的消费代码是按照我们这节课中讲的：“先处理消费业务逻辑，再提交消费成功确认”，就可以保证消费顺序，你可以想一下为什么。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564708311,"ip_address":"","comment_id":119656,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10154582036","product_id":100032301,"comment_content":"一个队列对应多个消费实例的话该如何保证顺序性检查？还是使用reidis 缓存起来，每个实例都去get出来判断？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461000,"discussion_content":"在消费端，即使同一个消费组里面有多个实例，只要你的消费代码是按照我们这节课中讲的：“先处理消费业务逻辑，再提交消费成功确认”，就可以保证消费顺序，你可以想一下为什么。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564708311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119565,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1564626786,"is_pvip":false,"replies":[{"id":"43884","content":"这个检测逻辑可以在线上做，不会影响业务的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564629887,"ip_address":"","comment_id":119565,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10154561378","product_id":100032301,"comment_content":"1、老师有个疑问检测消息丢失是在还没上线之前做的测试，但是会不会可能在线下没出现消息不一致，但是在线上的时候出现消息丢失了？线上<br>检测消息丢失逻辑会关闭，那线上是会有其他的检测机制么？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460957,"discussion_content":"这个检测逻辑可以在线上做，不会影响业务的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564629887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119534,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1564623075,"is_pvip":true,"replies":[{"id":"43879","content":"就是这个意思，同学你这个表述非常清楚明白。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564629389,"ip_address":"","comment_id":119534,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10154557667","product_id":100032301,"comment_content":"『有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户』是否应该改为『有些消息队列的Producer在长时间没收到消息队列发送的确认响应后，....』","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460944,"discussion_content":"就是这个意思，同学你这个表述非常清楚明白。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564629389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3673,"discussion_content":"应该是“有些消息队列的Producer在长时间没收到broker发送的确认响应后”吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564701539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119498,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1564619799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10154554391","product_id":100032301,"comment_content":"一句话，消费做好幂等性即可！","like_count":2},{"had_liked":false,"id":119485,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1564618496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10154553088","product_id":100032301,"comment_content":"首先看消费端业务是否可以保证幂等，比如审核流程通过的消息需要修改流程状态，这种业务可以保证幂等得业务只需要保证业务当幂等就可以。<br>如果业务无法设计成幂等可以看消息是否有唯一标识，如果没有可以在消费端通过CRC算法计算出一个代表消息标识的属性，以此来判断消息是否消费过。","like_count":2},{"had_liked":false,"id":220635,"user_name":"杨超越","can_delete":false,"product_type":"c1","uid":1200867,"ip_address":"","ucode":"D115EDC04B6E1F","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/e3/594f7e34.jpg","comment_is_top":false,"comment_ctime":1590301020,"is_pvip":false,"replies":[{"id":"81458","content":"一般常规的几种做法：<br><br>1. 无限重试；<br>2. 双主题：A主题发送失败，向B主题发送；<br>3. 记录错误：反复发送失败的消息，记录到数据库或日志中，后续定时任务或者人工处理。<br>4. 如果是在微服务中，回滚事务（如果有的话），返回失败，让调用方来处理。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1590368083,"ip_address":"","comment_id":220635,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5885268316","product_id":100032301,"comment_content":"“在生产阶段，你需要捕获消息发送的错误，并重发消息。” 重发一直失败，这个时候一般如何处理呢？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496193,"discussion_content":"一般常规的几种做法：\n\n1. 无限重试；\n2. 双主题：A主题发送失败，向B主题发送；\n3. 记录错误：反复发送失败的消息，记录到数据库或日志中，后续定时任务或者人工处理。\n4. 如果是在微服务中，回滚事务（如果有的话），返回失败，让调用方来处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590368083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603030,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/d6/259e6ba2.jpg","nickname":"杜劲松","note":"","ucode":"36A213BD2DF424","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550582,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644601472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140746,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1571041153,"is_pvip":false,"replies":[{"id":"54544","content":"不会自动重启，如果服务端是集群模式，客户端会自动连接到其它服务端上继续生产消费。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1571101654,"ip_address":"","comment_id":140746,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5866008449","product_id":100032301,"comment_content":"老师 消息队列如果意外退出了了 心跳机制能帮我重新启动吗 还是需要我们控制自动重启啊","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470537,"discussion_content":"不会自动重启，如果服务端是集群模式，客户端会自动连接到其它服务端上继续生产消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571101654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367860,"discussion_content":"不需要 以kafka为例 都是先从broker controller中取出分区信息再开始发送，这部分再kafka客户端里。顺便一说 2.8以后我们拿掉了zk选主 改用raft选主 不过流程一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618487369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123258,"user_name":"瑶瑶笑哈哈","can_delete":false,"product_type":"c1","uid":1598794,"ip_address":"","ucode":"4D887242C0DF0F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyOzptz27UiatycBFguBrz0gjLiauywzBNqwuRVuuCyQPn4Th0sDibWpMo0owGHqfFG9vFX0bJVicdsg/132","comment_is_top":false,"comment_ctime":1565655573,"is_pvip":false,"replies":[{"id":"45327","content":"使用场景不一样：tcp只要确保点对点可靠传输，消息队列还要考虑收发双方宕机的情况。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565743668,"ip_address":"","comment_id":123258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5860622869","product_id":100032301,"comment_content":"老师，思考题里面为什么不使用类似tcp的三次握手机制来保证不丢消息呢？而是响应异常了消费者要重新发送呢？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462599,"discussion_content":"使用场景不一样：tcp只要确保点对点可靠传输，消息队列还要考虑收发双方宕机的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565743668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121260,"user_name":"Nike","can_delete":false,"product_type":"c1","uid":1615132,"ip_address":"","ucode":"29DA84B41F8E90","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/1c/42cdcb48.jpg","comment_is_top":false,"comment_ctime":1565088860,"is_pvip":false,"replies":[{"id":"46921","content":"这个建议好，后面我们会尽量满足这个要求。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566521660,"ip_address":"","comment_id":121260,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5860056156","product_id":100032301,"comment_content":"我觉得每节课后老师留下的问题，能不能在下节课开始的时候把解决方案的思路也讲解一下？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461710,"discussion_content":"这个建议好，后面我们会尽量满足这个要求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566521660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119924,"user_name":"chief","can_delete":false,"product_type":"c1","uid":1036072,"ip_address":"","ucode":"DF9EDDDA883A41","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/28/fe15914b.jpg","comment_is_top":false,"comment_ctime":1564731661,"is_pvip":false,"replies":[{"id":"44097","content":"对于咱们这个问题，最好的办法肯定是优化消费者的消费性能，如果做不到的话，也可以选择你提出的第一个方案。如果我没记错的话，RocketMQ的客户端配置中是可以配置客户端拉取消息的时间间隔的，应该也可以满足你的需求。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564798764,"ip_address":"","comment_id":119924,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859698957","product_id":100032301,"comment_content":"我是消费方，吞吐量比较低，可能需要执行5秒才能确定业务执行是否正确或不正确。<br>但是这个过程中又重新拉取了消息，把我上一次没有返回确认的消息又拉取来了，就会发生重复消费消息了。<br><br>解决方法:<br>1.比如说rocketmq有没有这种配置：配置拉取消息的间隔时间；<br>但是如果配置了，每个消费的业务不一定时间都相近；<br>是把我把时间放到很大就可以吗？如果放到很大的话，数据就会发生延迟，就可能造成数据不一致性情况严重；<br>还是说有针对不同的topic可以配置拉取时间；<br><br>2.每个业务消费侧自己根据自己的业务消费情况做幂等；<br><br>我只想到了以上两种解决方法，前提是我认为rocketmq可以配置拉取时间才有的第一种解决方法；<br><br>老师您觉得哪一种更好，还是说根据不同的情况去选择不同的解决方法;<br><br><br>","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461133,"discussion_content":"对于咱们这个问题，最好的办法肯定是优化消费者的消费性能，如果做不到的话，也可以选择你提出的第一个方案。如果我没记错的话，RocketMQ的客户端配置中是可以配置客户端拉取消息的时间间隔的，应该也可以满足你的需求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564798764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119645,"user_name":"落尘kira","can_delete":false,"product_type":"c1","uid":1092169,"ip_address":"","ucode":"D203B519E43F85","user_header":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","comment_is_top":false,"comment_ctime":1564644908,"is_pvip":false,"replies":[{"id":"43973","content":"上一节课“事务消息”我们讲的就是这个问题啊，快去补课吧，同学。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564708145,"ip_address":"","comment_id":119645,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859612204","product_id":100032301,"comment_content":"有个超纲的业务问题想咨询一下李老师：<br>   假设生产阶段在业务完成后发送消息，此时刚好业务服务宕机没有执行到发送消息，此时有什么比较有效的方式去处理这种情况？比如定时任务轮询等等？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460994,"discussion_content":"上一节课“事务消息”我们讲的就是这个问题啊，快去补课吧，同学。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564708145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119621,"user_name":"sun留白","can_delete":false,"product_type":"c1","uid":1531348,"ip_address":"","ucode":"53FEEA5E244C9A","user_header":"https://static001.geekbang.org/account/avatar/00/17/5d/d4/e5ea1c25.jpg","comment_is_top":false,"comment_ctime":1564639788,"is_pvip":false,"replies":[{"id":"43966","content":"也是一种解决思路。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564707954,"ip_address":"","comment_id":119621,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859607084","product_id":100032301,"comment_content":"依托消息防丢失做的序号，在消费者处理时，先检查序号是否在数据库存在，若存在直接返回。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460984,"discussion_content":"也是一种解决思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564707954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119587,"user_name":"lmtoo","can_delete":false,"product_type":"c1","uid":1133918,"ip_address":"","ucode":"FCD5B9C941D448","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/5e/c5c62933.jpg","comment_is_top":false,"comment_ctime":1564630759,"is_pvip":false,"replies":[{"id":"43955","content":"只能保证打印出“消费发送成功。”的消息不丢失。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564707244,"ip_address":"","comment_id":119587,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5859598055","product_id":100032301,"comment_content":"try {<br>    RecordMetadata metadata = producer.send(record).get();<br>    System.out.println(&quot; 消息发送成功。&quot;);<br>} catch (Throwable e) {<br>    System.out.println(&quot; 消息发送失败！&quot;);<br>    System.out.println(e);<br>}<br>这段代码是如何保证异常的情况下消息不丢失的？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460968,"discussion_content":"只能保证打印出“消费发送成功。”的消息不丢失。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564707244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1040584,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e0/c8/4ad13219.jpg","nickname":"啥也不会","note":"","ucode":"2E0F593B237C59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3614,"discussion_content":"这个代码只是样例告诉我们应该处理异常，最基本的就是打日志，别丢了都不知道。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564640649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6983,"discussion_content":"catch 里还是需要你自己做一些业务降级处理的 比如 如库 或重试处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567240937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1617635,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/UjJxt7s40XpVpzhOjLia40EVhPTna0jCkxBbiby3lp8HNdKFRlEo54uTaUic0HlXEcjLmVJxMYVoVFmzEV3llv5Fg/132","nickname":"Geek_刀子","note":"","ucode":"70A814C7A1EBEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3648,"discussion_content":"如果到异常里，说明发送失败，可以在捕获异常里重新发送吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564656901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119581,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1564629907,"is_pvip":false,"replies":[{"id":"43954","content":"且听下回分解。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564707199,"ip_address":"","comment_id":119581,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859597203","product_id":100032301,"comment_content":"消费时，做好幂等性即可。老师可以具体讲一下怎么做幂等性吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460965,"discussion_content":"且听下回分解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564707199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119579,"user_name":"Geek_e7834d","can_delete":false,"product_type":"c1","uid":1530493,"ip_address":"","ucode":"ABAF1B1B7E6490","user_header":"","comment_is_top":false,"comment_ctime":1564629742,"is_pvip":false,"replies":[{"id":"43953","content":"且听下回分解，哈。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564707189,"ip_address":"","comment_id":119579,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859597038","product_id":100032301,"comment_content":"broker出现重复消息无所谓，最终是consumer来处理。使用Kafka之类的消息队列， 很大原因是速度够快。 所以去重的处理需要速度很快。否则会严重拉低性能。业务逻辑有去重最好。 如果没有。 对于Kafka而言，按照一个consumer一个分区。重复可能出现在一个consumer端, 而可能是重复消息分布在不同的consumer。 对于一个consumer收到重复消息， 有唯一ID容易判断，小于当前ID的可以丢弃（用crc之类的感觉不可行， 重复消息有可能和当前消息隔的很远， 那样要保留多个消息）。 如果不同consumer收到了重复消息， 感觉去重的成本挺高的。要把一段时间内消费过的都记录下来，然后查询。 不知道怎么能以最小的代价来去重。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460963,"discussion_content":"且听下回分解，哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564707189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119575,"user_name":"Geek_e7834d","can_delete":false,"product_type":"c1","uid":1530493,"ip_address":"","ucode":"ABAF1B1B7E6490","user_header":"","comment_is_top":false,"comment_ctime":1564628427,"is_pvip":false,"replies":[{"id":"43951","content":"我们的课程还是以讲实现原理为主，没法面面俱到的来讲每一种消息队列的各种配置项，只要掌握了原理，仔细看一下官方文档的配置说明，很容易就知道该怎么配置了。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564706999,"ip_address":"","comment_id":119575,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859595723","product_id":100032301,"comment_content":"1. 不丢消息是以系统的performance下降为前提的， Kafka中的至少投递两个broker模式打开后， 会比一个broker确认慢不少。事务对参数似乎做了更多的限制<br>2. max.in.flight.requests.per.connection 不等于1就有可能导致失败后重发的无序性。等于1性能又慢了不少。还有别的参数会导致一个partition里的消息也可能不是严格按顺序的吗？  <br>3. 后面是会有参数调优结合这些需求来进行的主题吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460961,"discussion_content":"我们的课程还是以讲实现原理为主，没法面面俱到的来讲每一种消息队列的各种配置项，只要掌握了原理，仔细看一下官方文档的配置说明，很容易就知道该怎么配置了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564706999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119556,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1564625586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859592882","product_id":100032301,"comment_content":"对rocketmq比较熟悉，以rocketmq为例说一下。<br>发送方构建Message对象的时候，要设置messageKey,它表示业务上的唯一键。<br>消费方处理业务逻辑前，首先校验是否已经处理过该messageKey对应的消息（可以使用redis存储），如果已经处理过，则直接返回commit。保证同一条消息只被处理一次。","like_count":1},{"had_liked":false,"id":119538,"user_name":"撒旦的堕落","can_delete":false,"product_type":"c1","uid":1116864,"ip_address":"","ucode":"15F6AA41EE556F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/c0/401c240e.jpg","comment_is_top":false,"comment_ctime":1564623499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859590795","product_id":100032301,"comment_content":"对于幂等 我们项目中有一个 学生报名学习课程  的业务在报名成功后 会往队列中发送消息  消费者接受到消息会进行分配作业 首先我们会往缓存中写入业务的唯一标识  然后进行业务处理  业务处理成功后  发送确认  如果业务处理失败 则删除缓存  当有消息来的时候 我们查询缓存数据库 判断业务是否已经做过 没有 则执行上面流程  有就直接确认消息","like_count":1},{"had_liked":false,"id":119527,"user_name":"撒旦的堕落","can_delete":false,"product_type":"c1","uid":1116864,"ip_address":"","ucode":"15F6AA41EE556F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/c0/401c240e.jpg","comment_is_top":false,"comment_ctime":1564622418,"is_pvip":false,"replies":[{"id":"43878","content":"要保证消息不丢失，需要写入到队列中再返回确认。<br><br>具体的配置你可以看一下RabbitMQ中的确认机制：<br><br>https:&#47;&#47;www.rabbitmq.com&#47;confirms.html#publisher-confirms","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564629085,"ip_address":"","comment_id":119527,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5859589714","product_id":100032301,"comment_content":"老师  我们在使用rabbitmq  为了保证高可用 使用了镜像队列  消息是在发送到单个交换机中 就返回应答信息 还是同步到镜像的交换机中才返回确认？  这个是有参数配置  还是在集群模式下 默认就会这样 一直没有找到相关文档  还望老师解惑","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460941,"discussion_content":"要保证消息不丢失，需要写入到队列中再返回确认。\n\n具体的配置你可以看一下RabbitMQ中的确认机制：\n\nhttps://www.rabbitmq.com/confirms.html#publisher-confirms","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564629085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367862,"discussion_content":"简单的说应该是after sync还是after commit 就像老师说的：存储介质这套老古董都是一回事。不过具体使用时 要结合ISR+半同步一起考虑 没有绝对的套路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618487457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119500,"user_name":"微微一笑","can_delete":false,"product_type":"c1","uid":1250327,"ip_address":"","ucode":"CFA7ABE81D0B99","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","comment_is_top":false,"comment_ctime":1564619903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859587199","product_id":100032301,"comment_content":"老师早啊，下面是我对问题的思考：<br>由于在消息队列无法保证消息的重复，需要在业务上去控制重复消费。①首先要保证消费的幂等性；②有可能由于并发，导致重复消费，所以，分布式系统需要根据消息的某个字段信息去做分布式锁，防止并发。","like_count":1},{"had_liked":false,"id":119496,"user_name":"稳","can_delete":false,"product_type":"c1","uid":1207298,"ip_address":"","ucode":"11D3604DADD31F","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/02/cdeeea90.jpg","comment_is_top":false,"comment_ctime":1564619644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859586940","product_id":100032301,"comment_content":"1、使用全局递增的唯一键，在broker端如果最新的键值大等于当前消息的唯一键，则丢弃<br>2、在消费端可以在db中保存这个消息键或者使用redis的Bloom Filter，在消费时判断下该消息键是否消费过。<br>重在参与，见谅","like_count":1},{"had_liked":false,"id":119472,"user_name":"滴流乱转小胖儿","can_delete":false,"product_type":"c1","uid":1231250,"ip_address":"","ucode":"4689236E65FE4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/92/6361802a.jpg","comment_is_top":false,"comment_ctime":1564615900,"is_pvip":false,"replies":[{"id":"43876","content":"我先卖个关子，且听下节课分解。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564628102,"ip_address":"","comment_id":119472,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859583196","product_id":100032301,"comment_content":"消费端代码一定保持幂等性，一个操作无论执行一次还是多次结果都是一样的，保证数据的一致性。<br><br>具体操作:在作更新或删除或增加的操作之前，先查询是否此业务操作已经操作过，如果操作过直接返回确认信息，反之正常消费<br><br>老师不知我理解的对不，请指导","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460917,"discussion_content":"我先卖个关子，且听下节课分解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564628102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119448,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1564591204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859558500","product_id":100032301,"comment_content":"第一  消息唯一键 存储在表里面   第二  基于消息唯一键的分布式锁加上存储到mongodb","like_count":1},{"had_liked":false,"id":349379,"user_name":"渊鱼","can_delete":false,"product_type":"c1","uid":1611886,"ip_address":"","ucode":"EC52C7F6863FA7","user_header":"https://static001.geekbang.org/account/avatar/00/18/98/6e/38b4a4ce.jpg","comment_is_top":false,"comment_ctime":1655917157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655917157","product_id":100032301,"comment_content":"1 双端 ack机制  <br>2 消息队列broker持久化<br>3 幂等处理（至少发送一次）","like_count":0},{"had_liked":false,"id":349040,"user_name":"Geek_cc7bf3","can_delete":false,"product_type":"c1","uid":3010442,"ip_address":"","ucode":"3BB263DBEC04E5","user_header":"","comment_is_top":false,"comment_ctime":1655688226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655688226","product_id":100032301,"comment_content":"给消费端增加一个记录收到消息的次数，如果第二次收到消息就不执行业务逻辑，直接再次返回结果","like_count":0},{"had_liked":false,"id":347120,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1653726511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653726511","product_id":100032301,"comment_content":"消费消息时候 应该先查，然后根据是否被处理过了，在决定是否消费以及ack，也就是所谓的幂等。","like_count":0},{"had_liked":false,"id":346342,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1653035785,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653035785","product_id":100032301,"comment_content":"在发送消息的时候 生成一个递增的消息序列<br>\t如果说中间有跳 那么说明丢消息了<br>但是topic中有多分区、队列的情况下是不行的 需要指定队列才可以 单独检测<br>而如果生产者是多实例的也不行 发消息的时候也要加上product的标识<br>发送阶段<br>\t同步发送要捕获异常 异步发送要在回调方法中捕获 <br>\t\t有了异常再会有重试机制 不然会认为消费成功了<br>存储阶段<br>\t可能出现broker宕机 如果对可靠性要求比较高 那么就设置为同步刷盘即可<br>\t\t保证消息的可靠性 等磁盘中的数据都被写入 唤醒线程发送成功消息<br>\t还可以单点变集群 这样丢失的概率就小了<br>消费阶段<br>\t不要在收到消息后立刻发送确认 而应该等处理完相关逻辑后再发送消息确认","like_count":0},{"had_liked":false,"id":341028,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649301210,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649301210","product_id":100032301,"comment_content":"分阶段保证消息队列的丢失，在生产者发送给broker时进行确认，在broker发送给消费者时进行确认。两阶段确认。任何一个环节都不会丢失","like_count":0},{"had_liked":false,"id":340983,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649253262,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649253262","product_id":100032301,"comment_content":"和请求类型，每个请求都有一个唯一的requestid. 这里假设每个消息都有一个唯一的messageid,接收方每次收到消息时，都判断这个messageid 是否处理过。","like_count":0},{"had_liked":false,"id":340704,"user_name":"再见理想","can_delete":false,"product_type":"c1","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1649061495,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649061495","product_id":100032301,"comment_content":"确保消息不会丢失，需要考虑三个不同的阶段，生产阶段，存储阶段，消费阶段。<br>生产阶段：采用请求确认模式，生产者发送消息后，得到服务端返回失败或者出现异常时，要重发消息，异步发送消息时，需注册回调函数处理失败重发的逻辑。<br>存储阶段：单机情况下，服务端在接收到生产者的消息，将消息写入磁盘后，才给生产者返回成功的应答。<br>集群模式下，服务端需要保证两台以上的节点将消息写入磁盘后，给生产者返回成功的应答。<br>消费阶段：服务端将消息发送给消费者后，需等消费者返回处理成功的ack后，才能删除消息，否则需要重发消息，消费者的处理逻辑需要保证数据处理的幂等性！","like_count":0},{"had_liked":false,"id":339324,"user_name":"郎思明","can_delete":false,"product_type":"c1","uid":2353023,"ip_address":"","ucode":"16A6DA0FBEA0E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPK6DZqNE1YZmght5wicmXS9wrB2YSPdCgs8XZhvAHCCVInGt2CcF3t5owevHomzliamkrIRrLugnw/132","comment_is_top":false,"comment_ctime":1648036781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648036781","product_id":100032301,"comment_content":"消息重试时，可要考虑消息的时序的问题。因为你重试的消息可能已经是旧数据了","like_count":0},{"had_liked":false,"id":333885,"user_name":"邱邱邱","can_delete":false,"product_type":"c1","uid":2611827,"ip_address":"","ucode":"828318EB2316EB","user_header":"https://static001.geekbang.org/account/avatar/00/27/da/73/7e7593a7.jpg","comment_is_top":false,"comment_ctime":1644570349,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1644570349","product_id":100032301,"comment_content":"对于已经正常消费的消息，应当记录其消息id，当收到重复消息时，先判断该消息是否被消费过，如果已消费，则丢弃并返回消费成功","like_count":0},{"had_liked":false,"id":332653,"user_name":"黄欢","can_delete":false,"product_type":"c1","uid":2891918,"ip_address":"","ucode":"9E244E76A908EE","user_header":"","comment_is_top":false,"comment_ctime":1643441426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643441426","product_id":100032301,"comment_content":"老师，在回调中检查消息是否发送成功，怎么避免同一消息发送两次？比如第一次发送由于网络原因没有收到确认响应，重试成功后第一次也返回了确认响应，是怎么避免同一消息往Broker发多次的情况？希望老师解答疑惑","like_count":0},{"had_liked":false,"id":328409,"user_name":"曼巴","can_delete":false,"product_type":"c1","uid":1185400,"ip_address":"","ucode":"794BACF765E2A8","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/78/3f4a2104.jpg","comment_is_top":false,"comment_ctime":1640706544,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640706544","product_id":100032301,"comment_content":"请问大家，购物车系统没有必要串行消费吧，个人认为这个场景不适合用消息队列来实现。","like_count":0},{"had_liked":false,"id":322623,"user_name":"褚雪超","can_delete":false,"product_type":"c1","uid":2823300,"ip_address":"","ucode":"C02217EF0DF915","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicyLHyiamFl3CoWBHsERicBftibXWVLUa8UIN1f9bykkkfrbWEwaNzxHncdEWJHiaic2lAuueFtCibRunQ/132","comment_is_top":false,"comment_ctime":1637503743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637503743","product_id":100032301,"comment_content":"发送者异常捕获以及异步回调检查似乎解决不了 在发送产生异常，进行异常捕获或者回调时，未来得及执行任何逻辑，节点down掉的场景","like_count":0},{"had_liked":false,"id":322544,"user_name":"Sam Fu","can_delete":false,"product_type":"c1","uid":1112676,"ip_address":"","ucode":"EA285A4943271F","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","comment_is_top":false,"comment_ctime":1637478573,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1637478573","product_id":100032301,"comment_content":"如何确保消息不会丢失:<br>Broker改为同步刷盘 + 集群部署<br><br>如何解决收到重复消息:<br>幂等处理","like_count":0},{"had_liked":false,"id":310690,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1630841770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630841770","product_id":100032301,"comment_content":"确认响应在网络传输中丢失，producer会重试发送消息，如发送成功，broker中就有两条一样的消息，这时可以在消费端按消息的唯一id做幂等性判断，过滤已经消费过的重复消息。","like_count":0},{"had_liked":false,"id":298228,"user_name":"pengshao","can_delete":false,"product_type":"c1","uid":1161377,"ip_address":"","ucode":"3D001993C6854C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/a1/72397ba5.jpg","comment_is_top":false,"comment_ctime":1623976174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623976174","product_id":100032301,"comment_content":"可以用redis 记录已消费的消息，防止重复消费","like_count":0},{"had_liked":false,"id":293990,"user_name":"芋头","can_delete":false,"product_type":"c1","uid":1227492,"ip_address":"","ucode":"A9C875548E4EE5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ba/e4/6df89add.jpg","comment_is_top":false,"comment_ctime":1621671240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621671240","product_id":100032301,"comment_content":"总结一下：如何确保消息不会丢失？<br>1.生产阶段  捕获消息发送的错误，并且重发消息（同步调用采用get方法，异步调用需要检查发送结果）<br>2.存储阶段 配置相关存储参数 比如同步刷盘、多个副本写入<br>3.消费阶段 在消费逻辑结束之后再发送确认消息<br>思考题：<br>消费做好幂等性<br>1.业务天然幂等则不需要考虑<br>2.消费之前去重，记录消息ID查询之前是否消费过<br>","like_count":0},{"had_liked":false,"id":289252,"user_name":"快乐的平头哥","can_delete":false,"product_type":"c1","uid":1635388,"ip_address":"","ucode":"D7D2FA5DA6D8BF","user_header":"https://static001.geekbang.org/account/avatar/00/18/f4/3c/60bf7a17.jpg","comment_is_top":false,"comment_ctime":1618935179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618935179","product_id":100032301,"comment_content":"异步发送时，则需要在回调方法里进行检查.并不能保证消息不丢 假设消息刚好发送出去（channel.write） 然后给前端的响应是success。接下来 自己挂掉了 这时候 根本不知道 broker是否成功。","like_count":0},{"had_liked":false,"id":283961,"user_name":"weDrink.fun","can_delete":false,"product_type":"c1","uid":1793096,"ip_address":"","ucode":"377A6D7B73A83A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5c/48/3f7d9ff6.jpg","comment_is_top":false,"comment_ctime":1616005595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616005595","product_id":100032301,"comment_content":"老师你好，文章前部分提到的有序性校验中可以为消息加上序号，但是消费端如果是分布式多台实例，如何做到高效的有序性校验呢？毕竟每台实例不会重复消费单条消息。","like_count":0},{"had_liked":false,"id":277309,"user_name":"晨曦","can_delete":false,"product_type":"c1","uid":2003953,"ip_address":"","ucode":"99802B94C40092","user_header":"https://static001.geekbang.org/account/avatar/00/1e/93/f1/2a867832.jpg","comment_is_top":false,"comment_ctime":1612350985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612350985","product_id":100032301,"comment_content":"老师好，Producer 数量和 consumer 数量不一致的时候 拦截器需要几个呢。 跟producer数量一致的话， 那每个consumer需要去每一个拦截器里check序列号嘛","like_count":0},{"had_liked":false,"id":276333,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1611887895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611887895","product_id":100032301,"comment_content":"简单来说下实现,可以在生产者端来提供一个唯一标识,消费者端有识别并检查标识是否已经处理过的能力,比如在Reids或者本地维护一个集合来确保数据是否已经由处理,如果数据量过大,还可以利用布隆表达式来进行第一层的过滤","like_count":0},{"had_liked":false,"id":265660,"user_name":"风","can_delete":false,"product_type":"c1","uid":1147929,"ip_address":"","ucode":"AFDBEFA49F269E","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/19/7ed2ffa6.jpg","comment_is_top":false,"comment_ctime":1606974876,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606974876","product_id":100032301,"comment_content":"老师,有个问题想问下您,如果发送事务消息还没有commit的时候,其他生成者有发送了一条完整的消息(可以被消费者进行消费),这种情况下kafka和rocketmq是怎么处理的,比如kafka需要记录消费位移,这种情况下如果kafka拉取到了后面的消息进行消费并且提交了位移,那么后面生产者提交事务消息,就会导致这些数据无法被消费","like_count":0},{"had_liked":false,"id":261785,"user_name":"Geek_20e78b","can_delete":false,"product_type":"c1","uid":1593141,"ip_address":"","ucode":"647D06E867469A","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/35/7828e961.jpg","comment_is_top":false,"comment_ctime":1605523326,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605523326","product_id":100032301,"comment_content":"老师您好，文章中说在存储阶段，对于单节点的Broker，RocketMQ使用flushDiskType设置成SYNC_FLUSH来达到杜绝消息丢失的目的；您又说过，Kafka和RocketMQ有非常多相似之处，但是我在kafka的文档中，并没有找到相关的设置，只有两个类似的：flush.messages和flush.ms分别设置了同步前的条数和间隔时间，但文档在这两个设置的说明中马上说，“我们建议您不要设置它，而是通过使用replication机制来持久化数据，和允许更高效的操作系统后台刷新功能”。我看您后面说“后面我们会安排一节课，来讲解集群模式下消息队列是如何通过消息复制来确保消息的可靠性的”，那么如此说来，这种所谓的replication只是针对Broker是多节点的集群模式下的设置方式，好像并不适用于单节点的Broker情况。那么请问，Kafka的单节点模式下，如何实现同步刷新从而避免消息丢失呢？如果按上面提到的flush.messages和flush.ms来说，就算这两个值设置的再小，那原则上一旦恰好在第二条数据或者第2毫秒就正好Broker就出故障了，那理论上依旧是丢掉一条数据的呀。所以是说，Kafka本来就根本达不到一条数据也不丢失这种程度，而只能是通过所谓的Kafka调优使得丢失的数据，无线接近0值？","like_count":0},{"had_liked":false,"id":254754,"user_name":"debugable","can_delete":false,"product_type":"c1","uid":1113497,"ip_address":"","ucode":"4CBF0A64E19BE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/99/6e05432a.jpg","comment_is_top":false,"comment_ctime":1603181205,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603181205","product_id":100032301,"comment_content":"老师，如果consumer处理超时，broker重复发送一条消息， 此时如何做判断呢？<br>目前我的做法是<br>1.redis分布式锁判断消息的key是否处理中,如果处理中返回rocketmqRECONSUME_LATER<br>2.业务主键判断消息是否已处理，如果已处理则返回CONSUME_SUCCESS","like_count":0},{"had_liked":false,"id":253002,"user_name":"Sruby","can_delete":false,"product_type":"c1","uid":1016232,"ip_address":"","ucode":"A7D1B93F41DA0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/a8/559afe8b.jpg","comment_is_top":false,"comment_ctime":1602559301,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1602559301","product_id":100032301,"comment_content":"你在编写消费代码时需要注意的是，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。<br>---------------------------------------------------<br>取决于业务场景，有的业务场景很难做幂等，但是能够接受消息丢失，（再采取其他方式补充重新拉取消息）可以先消费确认，把消息放到另外一个线程中处理，还可以提升消息的处理速度。<br>","like_count":0},{"had_liked":false,"id":251014,"user_name":"Sruby","can_delete":false,"product_type":"c1","uid":1016232,"ip_address":"","ucode":"A7D1B93F41DA0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/a8/559afe8b.jpg","comment_is_top":false,"comment_ctime":1601307704,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1601307704","product_id":100032301,"comment_content":"如果是 Broker 是由多个节点组成的集群，需要将 Broker 集群配置成：至少将消息发送到 2 个以上的节点，再给客户端回复发送确认响应。<br>---------------------------------<br>如果集群的主从broker之间通讯出现了问题，无法将消息发送给其他节点，那broker会给生产者返回系统出错的信息？这样是不是就导致broker不可用了？","like_count":0},{"had_liked":false,"id":250988,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1601299455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601299455","product_id":100032301,"comment_content":"老师，rocketMq的同步复制机制是不是master和slave还没有刷盘就返回producer成功了","like_count":0},{"had_liked":false,"id":238912,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1530125,"ip_address":"","ucode":"B1FDC170E5E698","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/0d/e0b64fbb.jpg","comment_is_top":false,"comment_ctime":1596366734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596366734","product_id":100032301,"comment_content":"老师，请教个问题：broker同时发给两个consumer，怎么保证只有一个consumer进行消费，同时从broker中删除这条已被消费的信息?","like_count":0},{"had_liked":false,"id":231182,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1593603202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593603202","product_id":100032301,"comment_content":"先看业务是否允许重复消费的情况，如果允许，那我管他干嘛？浪费青春！如果不允许，那就是需要做幂等，分布式锁吧。首推zk，其次redis。redis的话主推Redisson（Redis的son    Redis的儿子）","like_count":0},{"had_liked":false,"id":228740,"user_name":"肖大保健","can_delete":false,"product_type":"c1","uid":1306868,"ip_address":"","ucode":"E3209A00C1B954","user_header":"https://static001.geekbang.org/account/avatar/00/13/f0/f4/22dbe2d9.jpg","comment_is_top":false,"comment_ctime":1592797106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592797106","product_id":100032301,"comment_content":"消息的推拉模式，事务模式通篇都没有讲，这种文章，随便百度一下，博客到处都有","like_count":0},{"had_liked":false,"id":228564,"user_name":"刘凯","can_delete":false,"product_type":"c1","uid":1350608,"ip_address":"","ucode":"EFDC932CAE61A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg","comment_is_top":false,"comment_ctime":1592736790,"is_pvip":false,"replies":[{"id":"84528","content":"事实上，Broker无论是否收到来自Consumer的ACK，都不会删除这条消息。即使Broker收到ACK，也只是把记录消费位置的指针向队尾移动而已。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1592917007,"ip_address":"","comment_id":228564,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592736790","product_id":100032301,"comment_content":"broker 向  customer 发送了  message 如果得不到customer的消费确认 broker的消息会从partition或topic中移除吗？我认为不移除会影响到下一条消息的发送，还有如果可以正确得到customer的消息确认，那么partition中的消息是在得到消息确认后移除的吗，这样也会影响第二条消息的发送时机","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499078,"discussion_content":"事实上，Broker无论是否收到来自Consumer的ACK，都不会删除这条消息。即使Broker收到ACK，也只是把记录消费位置的指针向队尾移动而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592917007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225394,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1591750428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591750428","product_id":100032301,"comment_content":"1. 生产者通过判断返回值，决定是否重发，但上一条可能已经丢了。重发是一种补偿机制。<br><br>2. broker 接收消息后，如果在刷盘前掉电，并且在发送给集群里其它 broker 时失败，也一样丢。也是依赖生产者重发。反过来说，一旦开启同步刷盘，或者消息同步给了其他 broker，就可以保证消息不丢了。<br><br>3. 消费者这边，网络抖动、业务处理失败或者异常，都可以认为消费失败，这时不要响应。只有成功才响应。<br><br><br>思考题<br><br>broker 可以对每条消息生成唯一ID，入队时先判断是否消息重复。<br><br>消费端也可以通过消息入库，使用数据库唯一索引约束，来实现幂等。<br><br>","like_count":0},{"had_liked":false,"id":217632,"user_name":"Echo","can_delete":false,"product_type":"c1","uid":1409357,"ip_address":"","ucode":"F04C6BC4E288A7","user_header":"https://static001.geekbang.org/account/avatar/00/15/81/4d/5f892de2.jpg","comment_is_top":false,"comment_ctime":1589552741,"is_pvip":false,"replies":[{"id":"80854","content":"一般会自动重试","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1589869222,"ip_address":"","comment_id":217632,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589552741","product_id":100032301,"comment_content":"老师，消费消息的时候，要是超时了会怎么样呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495197,"discussion_content":"一般会自动重试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589869222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216117,"user_name":"LiYanbin","can_delete":false,"product_type":"c1","uid":1129976,"ip_address":"","ucode":"2F50493F818909","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/f8/b13674e6.jpg","comment_is_top":false,"comment_ctime":1589191623,"is_pvip":false,"replies":[{"id":"80337","content":"我分析，理论上是可行的，实际执行会稍微有些麻烦。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1589462664,"ip_address":"","comment_id":216117,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589191623","product_id":100032301,"comment_content":"玥哥，关于检测消息是否丢失的方法，我想到了另外一种方式：<br>如果消息模型是一对一的，加+消息确认机制（比如返回响应消息，不是回给Broker，回给生产者），那么生产者这边做下消息的时序性保证（等收到了消息的响应消息再去发下一条消息），就可以检测到消息是否丢失了<br>当然，返回的响应消息也可能丢失，那么可能会导致消息重复，那么再做下消息重复的异常处理就可以了<br>这种方式可行吧，是否会有哪里欠缺考虑，麻烦玥哥指导指导 ，谢谢！","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494675,"discussion_content":"我分析，理论上是可行的，实际执行会稍微有些麻烦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589462664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211183,"user_name":"skying","can_delete":false,"product_type":"c1","uid":1041865,"ip_address":"","ucode":"E7CFF50AB64BB1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","comment_is_top":false,"comment_ctime":1587910891,"is_pvip":true,"replies":[{"id":"78784","content":"不同队列之间是没有影响的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1588048816,"ip_address":"","comment_id":211183,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587910891","product_id":100032301,"comment_content":"老师你好，请教个问题<br>1.rabbitmq的消息队列，如果一个队列 中的消息消费失败，抛出异常，导致消息一直重复投递，<br> 这会影响其它队列的正常消费吗","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493213,"discussion_content":"不同队列之间是没有影响的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588048816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210813,"user_name":"skying","can_delete":false,"product_type":"c1","uid":1041865,"ip_address":"","ucode":"E7CFF50AB64BB1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","comment_is_top":false,"comment_ctime":1587828191,"is_pvip":true,"replies":[{"id":"78568","content":"如果不做任何配置，这个坏消息会一直卡住队列。RabbitMQ提供了DLX机制来解决这个问题：https:&#47;&#47;www.rabbitmq.com&#47;dlx.html","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1587951775,"ip_address":"","comment_id":210813,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1587828191","product_id":100032301,"comment_content":"老师你好，请教个问题<br>1.rabbitmq消息队列，如果一个队列 消息消费失败,抛出异常，导致消息 一致重复投递。<br>  这样会影响 其它消息队列的 正常消费吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493116,"discussion_content":"如果不做任何配置，这个坏消息会一直卡住队列。RabbitMQ提供了DLX机制来解决这个问题：https://www.rabbitmq.com/dlx.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587951775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","nickname":"skying","note":"","ucode":"E7CFF50AB64BB1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250924,"discussion_content":"好的👌，多谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588050322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208844,"user_name":"Shen","can_delete":false,"product_type":"c1","uid":1182167,"ip_address":"","ucode":"CFF7609A754392","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","comment_is_top":false,"comment_ctime":1587448234,"is_pvip":false,"replies":[{"id":"78319","content":"是的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1587691344,"ip_address":"","comment_id":208844,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587448234","product_id":100032301,"comment_content":"老师你好，这节课上面提到了分区，这个分区和上一节课讲到的队列是一回事吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492644,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587691344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207443,"user_name":"AlfredLover","can_delete":false,"product_type":"c1","uid":1042354,"ip_address":"","ucode":"A3A998F362CC37","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/b2/334bc992.jpg","comment_is_top":false,"comment_ctime":1587086974,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587086974","product_id":100032301,"comment_content":"保证消息的有序性这里，实现起来感觉太复杂了。","like_count":0},{"had_liked":false,"id":201689,"user_name":"Katherine","can_delete":false,"product_type":"c1","uid":1898758,"ip_address":"","ucode":"C57AB0B17DA1A1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f9/06/dea695ea.jpg","comment_is_top":false,"comment_ctime":1585821106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585821106","product_id":100032301,"comment_content":"消费过的消息做一个记录就行啦","like_count":0},{"had_liked":false,"id":198707,"user_name":"smily","can_delete":false,"product_type":"c1","uid":1099875,"ip_address":"","ucode":"E2FDA059724A02","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/63/f94f9fda.jpg","comment_is_top":false,"comment_ctime":1585464942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585464942","product_id":100032301,"comment_content":"能有图例，把事务消息说明白就好了。例如发消息先到服务端broker server，什么时间写入内存，写入内存用的什么机制以及采取什么策略对应配置参数是什么起到什么效果；，什么时间写入文件系统用的什么机制以及采取什么策略对应配置参数是什么起到什么效果，什么时间写入磁盘用的什么机制以及采取什么策略对应配置参数是什么起到什么效果，这才能讲明白。","like_count":0},{"had_liked":false,"id":188422,"user_name":"进击的小明","can_delete":false,"product_type":"c1","uid":1737846,"ip_address":"","ucode":"7C9A774C504177","user_header":"https://static001.geekbang.org/account/avatar/00/1a/84/76/6091523d.jpg","comment_is_top":false,"comment_ctime":1584352448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584352448","product_id":100032301,"comment_content":"我理解consumer 在消费消息的时候，也做一个和producer 对应的消息标号，记录所有消费的消息，如果有重复的，会有标号冲突。","like_count":0},{"had_liked":false,"id":185427,"user_name":"这菜真香呀","can_delete":false,"product_type":"c1","uid":1046661,"ip_address":"","ucode":"13692E295A6A47","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/85/3c072e6f.jpg","comment_is_top":false,"comment_ctime":1583581780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583581780","product_id":100032301,"comment_content":"消费端RocketMQ 还有个持久化消费offset机制，保证Cconsumer即使挂了，他消费的消息也不会飘散在口中。","like_count":0},{"had_liked":false,"id":182611,"user_name":"火娃儿","can_delete":false,"product_type":"c1","uid":1252132,"ip_address":"","ucode":"2704841763FD70","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/24/1006c208.jpg","comment_is_top":false,"comment_ctime":1582815392,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582815392","product_id":100032301,"comment_content":"用幂等性 来 在业务端处理。","like_count":0},{"had_liked":false,"id":181614,"user_name":"Geek_498c16","can_delete":false,"product_type":"c1","uid":1716617,"ip_address":"","ucode":"616913785EFF06","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL6ibvATzI5FKR6r71GU3CjdlPkZYYSBYBtNibIGENFZDnqajW7LOPKZXUPWSsjt8OiaxTZ0neT8LwQQ/132","comment_is_top":false,"comment_ctime":1582596355,"is_pvip":false,"replies":[{"id":"70560","content":"一般来说都没有去重的机制。<br><br>Kafka 的Broker有一个生产幂等的功能，开启后，可以保证从Producer到Broker，这一段的传输幂等性，也就是说，Broker会做去重。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1582766434,"ip_address":"","comment_id":181614,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582596355","product_id":100032301,"comment_content":"老师，broker内部有对收到的消息做去重处理吗？他会把收到的重复消息都存储下来吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485053,"discussion_content":"一般来说都没有去重的机制。\n\nKafka 的Broker有一个生产幂等的功能，开启后，可以保证从Producer到Broker，这一段的传输幂等性，也就是说，Broker会做去重。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582766434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172972,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1579400648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579400648","product_id":100032301,"comment_content":"如何保证消息不丢失?<br><br>生产端与消费做好异常处理，mq配置刷盘等保证消息先持久化后发送ack。","like_count":0},{"had_liked":false,"id":170235,"user_name":"Hale","can_delete":false,"product_type":"c1","uid":1129731,"ip_address":"","ucode":"1925955343FE94","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/03/b2d9a084.jpg","comment_is_top":false,"comment_ctime":1578554885,"is_pvip":true,"replies":[{"id":"67105","content":"是的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1579411250,"ip_address":"","comment_id":170235,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578554885","product_id":100032301,"comment_content":"kafka 中也存在consumer消费消息后，发送ACK给Broker吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480898,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579411250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169626,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1024763,"ip_address":"","ucode":"F6B5C64BC99FB7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/fb/94af9cf1.jpg","comment_is_top":false,"comment_ctime":1578392238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578392238","product_id":100032301,"comment_content":"两种方式保证 1）去重  2）下游实现密等。根据不同情况选择不同的方案。","like_count":0},{"had_liked":false,"id":166043,"user_name":"夏目","can_delete":false,"product_type":"c1","uid":1212750,"ip_address":"","ucode":"67C075A01CF4D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","comment_is_top":false,"comment_ctime":1577369168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577369168","product_id":100032301,"comment_content":"如果业务天然幂等或者能够改造为幂等当然最好，否则需要在消费的时候记录一段时间消费的消息来保证不会重复消费。","like_count":0},{"had_liked":false,"id":161187,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1576140582,"is_pvip":false,"replies":[{"id":"61577","content":"几乎所有的消息队列，实现的时候采用的都是pull模式。<br>但是，给业务系统提供的API的表现形式，更多是push模式，这样方便业务系统使用。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1576299528,"ip_address":"","comment_id":161187,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576140582","product_id":100032301,"comment_content":"Kafka 消息是采用 Pull 模式，还是 Push 模式？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477632,"discussion_content":"几乎所有的消息队列，实现的时候采用的都是pull模式。\n但是，给业务系统提供的API的表现形式，更多是push模式，这样方便业务系统使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576299528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154531,"user_name":"wgcris","can_delete":false,"product_type":"c1","uid":1527666,"ip_address":"","ucode":"842B76EB6B8320","user_header":"","comment_is_top":false,"comment_ctime":1574475047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574475047","product_id":100032301,"comment_content":"producer端做幂等性处理保证生产消息不重复；消费端保留消息的offset，每次处理一条消息都做一次判断判断，是否已经处理。","like_count":0},{"had_liked":false,"id":146634,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1572590086,"is_pvip":false,"replies":[{"id":"56818","content":"使用消息序号的方法检测是否丢消息时，如果数据量不大，可以只使用一个consumer实例进行消费，来检测消息序号的连续性。<br><br>如果使用多个consumer实例消费，需要一个一致性的存储系统来保存和更新消息序号，可以使用数据库，也可以用Redis。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1572830730,"ip_address":"","comment_id":146634,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1572590086","product_id":100032301,"comment_content":"老师，请问下，在检测消息丢失的那部分，Consumer 方是需要用到 DB 保存接收的消息数据吗？消费消息时 Consumer 再按每个 Producer 分别检测已接收消息序列号的连续性。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472950,"discussion_content":"使用消息序号的方法检测是否丢消息时，如果数据量不大，可以只使用一个consumer实例进行消费，来检测消息序号的连续性。\n\n如果使用多个consumer实例消费，需要一个一致性的存储系统来保存和更新消息序号，可以使用数据库，也可以用Redis。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572830730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201260,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/6c/1fecd912.jpg","nickname":"唯。💍👑🍭","note":"","ucode":"3990B160474F92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50381,"discussion_content":"消费者消费消息不一定有序啊，怎么判断这个消息序号一定是后面的比前面的加1呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573714404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1153455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","nickname":"饭粒","note":"","ucode":"4C3220B0D43997","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1201260,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/6c/1fecd912.jpg","nickname":"唯。💍👑🍭","note":"","ucode":"3990B160474F92","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50713,"discussion_content":"发送消息的时候指定队列/分区，如果是多个 producer 发往同一队列/分区，就附加 producer 标识。consumer 取这个队列/分区的消息只能按这个队列/分区的顺序来吧。更方便的做法是做到 consumer 与队列/分区一一对应。个人理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573745996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50381,"ip_address":""},"score":50713,"extra":""}]}]},{"had_liked":false,"id":142947,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571593815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571593815","product_id":100032301,"comment_content":"创建一个消费日志表就好了，每次消息确认之前创建一条消费日志记录。","like_count":0},{"had_liked":false,"id":142220,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1571314304,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571314304","product_id":100032301,"comment_content":"请推荐些分布式链路追踪系统的资源","like_count":0},{"had_liked":false,"id":140077,"user_name":"吴林","can_delete":false,"product_type":"c1","uid":1667170,"ip_address":"","ucode":"0FA952BC9BDE8F","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/62/662a5740.jpg","comment_is_top":false,"comment_ctime":1570802815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570802815","product_id":100032301,"comment_content":"我是这样想的，因为消费的时候是按序消费的，而且一般消息重发的时间也很短，能不能将最近消费的几条消息保存起来，consumer从broker取消息时，先对比有没有重复，没有则消费，有则跳过。","like_count":0},{"had_liked":false,"id":132883,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1568259113,"is_pvip":false,"replies":[{"id":"50953","content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1568339630,"ip_address":"","comment_id":132883,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568259113","product_id":100032301,"comment_content":"总结下老师讲的内容:<br>1、肯定会出现消息丢失的情况<br>2、定位丢失的消息最简单的方法是给每个消息结构中增加一个自增的ID,这是利用了队列(分区)严格按照”先进先出“的特性实现的,但是比较麻烦的地方就是,”发布-订阅”这种模式的消息队列,会存在多分区(队列)、多主题的概念,因此Producer在生产消息的时候,需要在者两个纬度分别有一套独立的消息编号生成逻辑,生产消息的时候还要指定唯一的队列<br>3、消息丢失会出现在消息整个生命周期: 生产阶段、Broker保存阶段、消费阶段<br>生产阶段,防止丢失的解决办法是增加重试机制<br>Broker阶段,防止丢失的解决办法是如果只有一个Broker,可以设置消息的保存方式为直接保存到硬盘,但是这样会让消息队列的性能受影响,如果是多个Broker,可以配置成多个Broker分别保存消息<br>消费阶段,需要注意代码编写的正确顺序为: 先处理业务逻辑,再发送“消息收到”确认<br>当然,以上生产、消费两个阶段增加业务日志是必不可少的","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467160,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568339630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132879,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1568258014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568258014","product_id":100032301,"comment_content":"broker收到重复消息不管,consumer可以在收到消息之后,在处理业务逻辑前加个setnx分布式锁,屡试不爽...","like_count":0},{"had_liked":false,"id":131968,"user_name":"C BD","can_delete":false,"product_type":"c1","uid":1023604,"ip_address":"","ucode":"2CEA3E95EA3DCD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/74/d439bb1e.jpg","comment_is_top":false,"comment_ctime":1567995415,"is_pvip":false,"replies":[{"id":"50558","content":"幂等key是如何生成的呢？也跟小伙伴儿们分享一下吧。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1568077411,"ip_address":"","comment_id":131968,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567995415","product_id":100032301,"comment_content":"课后题: 在消息的payload里加入幂等的key. 有两种策略, 一个是直接忽略重复的幂等key对应的消息, 一个是更新相同幂等key之前的消息, 我们的系统里选择前者.","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466700,"discussion_content":"幂等key是如何生成的呢？也跟小伙伴儿们分享一下吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568077411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130553,"user_name":"黄卫江","can_delete":false,"product_type":"c1","uid":1648492,"ip_address":"","ucode":"D1C9DDE327AB0F","user_header":"https://static001.geekbang.org/account/avatar/00/19/27/6c/7f0fb881.jpg","comment_is_top":false,"comment_ctime":1567482215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567482215","product_id":100032301,"comment_content":"思考题，这就是和TCP机制一样，目前最终的方案是编号和建立滑动窗口来解决网络导致的重发和漏发","like_count":0},{"had_liked":false,"id":127590,"user_name":"好好学习","can_delete":false,"product_type":"c1","uid":1258789,"ip_address":"","ucode":"63A002997462E3","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/25/bab760a1.jpg","comment_is_top":false,"comment_ctime":1566745381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566745381","product_id":100032301,"comment_content":"能不能讲讲如何避免脑裂？","like_count":0},{"had_liked":false,"id":125536,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1566200224,"is_pvip":true,"replies":[{"id":"46221","content":"确保数据可靠性有很多种方式，Raft只是其中一种，比如RocketMQ采用的主备方式，只需要2个节点就可以保证消息不丢失。<br><br>","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566264777,"ip_address":"","comment_id":125536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566200224","product_id":100032301,"comment_content":"关于重复消息的问题，我有两个想法：<br>1、如果可以确定消息的顺序性，全局有序或者部分有序都行，那么可以在接收方维持一个watermark,重复数据就可以丢弃。<br>2、我们业务这边的消息都会存储在接收方做一个备份，消息量不大的时候可以直接查询数据库，但是这肯定不能适用于双十一和618这种时候，那样会存储大量的消息，冗余多了。这个方案可以考虑涉及到金融这一类需要备份消息。<br>老师，有个问题，在消费可靠性那里说道至少消息发送到了2个以上的Broker节点才可以确定成功收到，我记得raft算法中有这样一个描述：超过半数节点都同步了数据——在这里应该就是指收到消息，才可以对外确认这次的数据成功收到，这两个有什么关系吗？超过半数好像和2+都是一种防止某一个节点突然宕机采取的策略？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463598,"discussion_content":"确保数据可靠性有很多种方式，Raft只是其中一种，比如RocketMQ采用的主备方式，只需要2个节点就可以保证消息不丢失。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566264777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125516,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1566197886,"is_pvip":false,"replies":[{"id":"46217","content":"下节课我们讲这个哦","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566264461,"ip_address":"","comment_id":125516,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566197886","product_id":100032301,"comment_content":"你好 生产者这块重发消息，这么避免队列里出现重复消息呢?谢谢解答","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463592,"discussion_content":"下节课我们讲这个哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566264461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124508,"user_name":"赵小洛","can_delete":false,"product_type":"c1","uid":1592232,"ip_address":"","ucode":"A326C12B1A1ABA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/a8/14b8a860.jpg","comment_is_top":false,"comment_ctime":1565914957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565914957","product_id":100032301,"comment_content":"做好消息幂等性处理  判断rocketmq消息ID是否在消费端重复。","like_count":0},{"had_liked":false,"id":122509,"user_name":"liliumss","can_delete":false,"product_type":"c1","uid":1333094,"ip_address":"","ucode":"A52AC5042F3115","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","comment_is_top":false,"comment_ctime":1565409809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565409809","product_id":100032301,"comment_content":"保证消费者消费消息接口得幂等性，保存消息到消费者本地库，随消费执行逻辑持久化消费消息，遇到重复执行消息则判断库是否执行过，执行过则丢弃","like_count":0},{"had_liked":false,"id":122500,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1565408703,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1565408703","product_id":100032301,"comment_content":"生产消息中包含业务主键信息，消费方通过业务主键来判断该条消息对应的业务逻辑是否已经处理过，如果处理过就只对消息进行确认，不需要再处理。关键是消费方如何做好幂等，如果还要考虑性能和分布式情况，又是一个复杂对问题。","like_count":0},{"had_liked":false,"id":121311,"user_name":"亚洲舞王.尼古拉斯赵四","can_delete":false,"product_type":"c1","uid":1443078,"ip_address":"","ucode":"7159F5D7232696","user_header":"https://static001.geekbang.org/account/avatar/00/16/05/06/f5979d65.jpg","comment_is_top":false,"comment_ctime":1565097531,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565097531","product_id":100032301,"comment_content":"用幂等性可以解决。broker可以根据消息id去确认集群中是否已经存在了这个消息id的消息，如果存在的话就认为这个消息时重复接受的消息，否则就不是重复的，至于消费者每处理一条消息就在库中插入消息的唯一标识，如果消发现重复插入的话就是重复消费的消息","like_count":0},{"had_liked":false,"id":120986,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1565025823,"is_pvip":true,"replies":[{"id":"44475","content":"A1：差不多，只要能在分布式系统中追踪到每条数据即可。<br><br>2： 是需要业务代码来控制的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565054934,"ip_address":"","comment_id":120986,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565025823","product_id":100032301,"comment_content":"在看了一遍又发现几个问题不理解，希望老师有时间看下<br>1、这里的分布式链路追踪系统和Clould的zipkin实现的功能有什么区别么？<br>2、Producer端因为长时间没收到消息确认，<br>重试再失败时，捕获异常后是业务代码控制消息重发的么？<br>","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461564,"discussion_content":"A1：差不多，只要能在分布式系统中追踪到每条数据即可。\n\n2： 是需要业务代码来控制的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565054934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120772,"user_name":"梅云霞","can_delete":false,"product_type":"c1","uid":1400992,"ip_address":"","ucode":"01C8F85B59A202","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/a0/dc0bf77c.jpg","comment_is_top":false,"comment_ctime":1564992715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564992715","product_id":100032301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":120547,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1564927325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564927325","product_id":100032301,"comment_content":"用业务id来做幂等","like_count":0},{"had_liked":false,"id":120532,"user_name":"Mark Yao","can_delete":false,"product_type":"c1","uid":1091768,"ip_address":"","ucode":"0535CEB691F618","user_header":"https://static001.geekbang.org/account/avatar/00/10/a8/b8/73ef30ed.jpg","comment_is_top":false,"comment_ctime":1564924260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564924260","product_id":100032301,"comment_content":"业务做业务放做幂等操作","like_count":0},{"had_liked":false,"id":120426,"user_name":"老杨在努力","can_delete":false,"product_type":"c1","uid":1614410,"ip_address":"","ucode":"AA541B3BAD53A7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","comment_is_top":false,"comment_ctime":1564889995,"is_pvip":false,"replies":[{"id":"44193","content":"你可以想一下，在多个Producer和多个Broker的情况下，你如何来做这个检测呢？","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564916204,"ip_address":"","comment_id":120426,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564889995","product_id":100032301,"comment_content":"针对这个思考题我这面有一个方案，这个方案是我之前在阿里天池中间比赛消息队列中用到的，大致的思路就是在写入的时候首先检测一下内存中是否有该消息的索引（前提我这是采用WAL+全量索引），如果有的化直接根据索引的信息去更新消息，这样就能做到producer阶段没有重复的消息？为什么RocketMQ没有可以采用这种方式去做？辛苦老师帮忙分析一下","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461331,"discussion_content":"你可以想一下，在多个Producer和多个Broker的情况下，你如何来做这个检测呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564916204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120335,"user_name":"XIII","can_delete":false,"product_type":"c1","uid":1197964,"ip_address":"","ucode":"14ACE12BF06D64","user_header":"https://static001.geekbang.org/account/avatar/00/12/47/8c/9708a8c5.jpg","comment_is_top":false,"comment_ctime":1564836086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564836086","product_id":100032301,"comment_content":"老师讲的太好都没疑问了？点我右上角表示在看！","like_count":0},{"had_liked":false,"id":120243,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1564814223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564814223","product_id":100032301,"comment_content":"我学起来，我自己都害怕。我买了所有的课程！https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;hyUK90cTobHfzdw97QYrhg","like_count":0},{"had_liked":false,"id":120030,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1564758755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564758755","product_id":100032301,"comment_content":"消息发送时，会有一个唯一的id，消费者，收到时，现在自己已经消费的，消息表里查下，有就不消费，没有就消费，再发送确认","like_count":0},{"had_liked":false,"id":119990,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1564746999,"is_pvip":false,"replies":[{"id":"44104","content":"不会过滤掉。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1564799139,"ip_address":"","comment_id":119990,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564746999","product_id":100032301,"comment_content":"老师，broker端如果出现重复消息，会过滤掉吗？还是不管重复不重复都投递<br>","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461165,"discussion_content":"不会过滤掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564799139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119859,"user_name":"DAV 🍃","can_delete":false,"product_type":"c1","uid":1614531,"ip_address":"","ucode":"47A6A7B1D997FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/a2/c3/83545c57.jpg","comment_is_top":false,"comment_ctime":1564714303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564714303","product_id":100032301,"comment_content":"老师可以加快点节奏了","like_count":0},{"had_liked":false,"id":119802,"user_name":"陈泽坛","can_delete":false,"product_type":"c1","uid":1394861,"ip_address":"","ucode":"C81B402868E9E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/ad/8be724da.jpg","comment_is_top":false,"comment_ctime":1564705792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564705792","product_id":100032301,"comment_content":"太棒啦  目前还跟得上  ","like_count":0},{"had_liked":false,"id":119737,"user_name":"二雷","can_delete":false,"product_type":"c1","uid":1044483,"ip_address":"","ucode":"2E5F304CE7DA18","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f0/03/e80481e6.jpg","comment_is_top":false,"comment_ctime":1564668558,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564668558","product_id":100032301,"comment_content":"每条消息设置一个唯一业务主键，业务实现幂等性逻辑","like_count":0},{"had_liked":false,"id":119717,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1564662787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564662787","product_id":100032301,"comment_content":"消息防重还是要靠消费者端自己做。最简单的应该就是缓存MsgId，判断收到的消息是否是已经消费过的。","like_count":0},{"had_liked":false,"id":119709,"user_name":"13W3H","can_delete":false,"product_type":"c1","uid":1046497,"ip_address":"","ucode":"83189FD92DC082","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/e1/36676a49.jpg","comment_is_top":false,"comment_ctime":1564660553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564660553","product_id":100032301,"comment_content":"对于重复消息，需要保证消息处理的幂等性。在处理消息前，进行前置状态检查，若已经处理过消息，则不再进行处理，并返回消息确认。","like_count":0},{"had_liked":false,"id":119641,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1564643708,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564643708","product_id":100032301,"comment_content":"思考题：<br>1、如果是单点的Broker或者Consumer，可以在本地维护一个具有唯一性约束的消息id列表，id重复就不需要重复消费<br><br>2、如果是集群的Broker或者Consumer可以依靠其他的分布式框架来维护一个全局统一的唯一性约束，如在redis里维护一个已消费消息id的hash，每次重发消息前先检查id是否已消费<br><br>3、最简单的是如果数据库能保证一致性，交由数据库的唯一性约束来保证不重复消费","like_count":0},{"had_liked":false,"id":119588,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1564630945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564630945","product_id":100032301,"comment_content":"消费幂等。比如：往消息中存入key。在消费方法通过redis超时key的方式实现消费幂等，值得注意的是，消费失败最好手动删除。","like_count":0},{"had_liked":false,"id":119564,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1564626757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564626757","product_id":100032301,"comment_content":"尝试回答下课后习题，①因为每个消息都会有唯一标识，可以在消费端使用filter维护一个消费过的消息标识，然后这些标识可以隔一段时间清空②感觉也可以先执行查询操作，查缓存和数据库，但是感觉这样的话耗费一些性能③可以在数据库中将消息的唯一标识建唯一索引","like_count":0},{"had_liked":false,"id":119547,"user_name":"豆沙包","can_delete":false,"product_type":"c1","uid":1223954,"ip_address":"","ucode":"7C62E546E6786A","user_header":"https://static001.geekbang.org/account/avatar/00/12/ad/12/d4d54dd2.jpg","comment_is_top":false,"comment_ctime":1564624444,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564624444","product_id":100032301,"comment_content":"能否在broker和consumer处理完逻辑，返回确认收到消息前，临时缓存消息的唯一标识一段时间，如果再来了重复消息直接确认即可","like_count":0},{"had_liked":false,"id":119541,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1564623887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564623887","product_id":100032301,"comment_content":"如果是单点consumer，可在consumer端维护一个值来保存最新一个消费成功的从某broker来的消息Hash，拿到下个待消费待消息先用Hash对比下，不一致才消费，否则丢掉。<br>如果是集群consumer，在集群dispatcher做上述操作来保证不消费重复消息。<br>不通过在业务逻辑里保证幂等来规避重复消息消费问题的好处是，可以避免重复消费消息的开销。设想下，如果消费一次消息需要连接数据库，提交分布式事务，写文件，那在消费前检验的开销会远小于消费开销。<br>当然，如果消费消息的开销很小，通过业务逻辑保证幂等也足以解决重复消息问题。具体情况具体分析，还要考虑后续的业务逻辑变动，比如现在是幂等的，但某个需求会导致不幂等，这时用幂等来解决重复消息的方法的缺点就暴露了。","like_count":0},{"had_liked":false,"id":119539,"user_name":"木小柒","can_delete":false,"product_type":"c1","uid":1000802,"ip_address":"","ucode":"947439CDD0B5B1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/45/62/3c6041e7.jpg","comment_is_top":false,"comment_ctime":1564623579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564623579","product_id":100032301,"comment_content":"如果业务支持幂等那是最简单的了，收到消息时先查询是否已有目标值，如果有直接丢弃消息，回复成功即可。<br><br>不过有些业务就不好处理了。尤其是跨多个topic或者多种消息队列，重试时可能下游的消息还在路上。目前的业务就遇到这种，有些消息推送延迟还比较久，推送快的消息无法正确消费就频繁重试报异常。目前也是给一个最大重试次数，失败的消息就进入失败队列，可以查看消息和重新手动补偿。虽然能解决最终一致性，但是还是有一些业务上的问题。比如退款了，但是因为消息的原因，用户的订单可能还在退款申请或者退款中，时不时就会有，还时不时就有用户问我的钱退了吗！其实也挺浪费时间的。","like_count":0},{"had_liked":false,"id":119516,"user_name":"古夜","can_delete":false,"product_type":"c1","uid":1341612,"ip_address":"","ucode":"0A82D3CFCEDF07","user_header":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","comment_is_top":false,"comment_ctime":1564621141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564621141","product_id":100032301,"comment_content":"没有代码实践吗","like_count":0},{"had_liked":false,"id":119505,"user_name":"a、","can_delete":false,"product_type":"c1","uid":1532404,"ip_address":"","ucode":"590FE8DB111492","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","comment_is_top":false,"comment_ctime":1564620183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564620183","product_id":100032301,"comment_content":"1.消费端保证消费的幂等性<br>2.服务端保证消息的顺序性(通过老师讲的)，如果消费端消费的时候，发现消息不是顺序的，那就是可能存在相同的消息。","like_count":0},{"had_liked":false,"id":119491,"user_name":"浩瀚有边","can_delete":false,"product_type":"c1","uid":1087384,"ip_address":"","ucode":"B4540E94EAFFE0","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/98/5ef15aa0.jpg","comment_is_top":false,"comment_ctime":1564619071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564619071","product_id":100032301,"comment_content":"可以在生产端设置消息序号，并且在消费端的Redis保存每一个分区下最近一次成功消费的那批消息ID，如果接收到了相同ID的消息就不处理","like_count":0},{"had_liked":false,"id":119481,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1564617980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564617980","product_id":100032301,"comment_content":"      最近的学习中其实在结合陶辉老师的网络协议在一起学习：是不是网络层可以做一些监控。<br>      毕竟任何的丢包都会在网络方面留下痕迹：对于类似数据库的DML操作我们是否可以捕获日志，日志异常则报警或者留痕。<br>       最近总碰到一些完全不负责的信息录入人员，导致了部分极其奇葩的错误；我正在思考这些问题，老师今天的课程刚好有点类似：能几个环节连续发各种增删改奇葩的错误。<br>       三个环节都会有异常：是否可以在捕获异常后报警或者rollback。","like_count":0},{"had_liked":false,"id":119479,"user_name":"白小白","can_delete":false,"product_type":"c1","uid":1400416,"ip_address":"","ucode":"143F1C8294818A","user_header":"https://static001.geekbang.org/account/avatar/00/15/5e/60/1c13626b.jpg","comment_is_top":false,"comment_ctime":1564617852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564617852","product_id":100032301,"comment_content":"消息幂等性，在之前工作中遇到过重复消费的问题，当时是用业务逻辑解决了重复消费的问题。再有可以利用唯一标识id去做，分上半场和下半场去重。","like_count":0},{"had_liked":false,"id":119473,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1564616284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564616284","product_id":100032301,"comment_content":"打卡06 老师的专栏配合kafka专栏一起看 体会和收获更大了","like_count":0},{"had_liked":false,"id":119470,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1564612588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564612588","product_id":100032301,"comment_content":"可以在db中加一个全局唯一值，这样当消息重试时，到执行db更新操作会报唯一键冲突，表明已经消费过一次 不必重复消费","like_count":0}]}