{"id":185043,"title":"19 | 组件设计原则：组件的边界在哪里？","content":"<p>软件的复杂度和它的规模成<strong>指数</strong>关系，一个复杂度为100的软件系统，如果能拆分成两个互不相关、同等规模的子系统，那么每个子系统的复杂度应该是25，而不是50。软件开发这个行业很久之前就形成了一个共识，应该将复杂的软件系统进行拆分，拆成多个更低复杂度的子系统，子系统还可以继续拆分成更小粒度的组件。也就是说，软件需要进行模块化、组件化设计。</p><p>事实上，早在打孔纸带编程时代，程序员们就开始尝试进行软件的组件化设计。那些相对独立，可以被复用的程序被打在纸带卡片上，放在一个盒子里。当某个程序需要复用这个程序组件的时候，就把这一摞纸带卡片从盒子里拿出来，放在要运行的其他纸带的前面或者后面，被光电读卡器一起扫描，一起执行。</p><p>其实我们现在的组件开发与复用跟这个也差不多。比如我们用Java开发，会把独立的组件编译成一个一个的jar包，相当于这些组件被封装在一个一个的盒子里。需要复用的时候，程序只需要依赖这些jar包，运行的时候，只需要把这些依赖的jar包放在<code>classpath</code>路径下，最后被JVM统一装载，一起执行。</p><p>现在，稍有规模的软件系统一定被拆分成很多组件。正是因为组件化设计，我们才能开发出复杂的系统。</p><p>那么如何进行组件的设计呢？组件的粒度应该多大？如何对组件的功能进行划分？组件的边界又在哪里？</p><!-- [[[read_end]]] --><p>我们之前说过，软件设计的核心目标就是<strong>高内聚、低耦合</strong>。那么今天我们从这两个维度，看组件的设计原则。</p><h2>组件内聚原则</h2><p><strong>组件内聚原则</strong>主要讨论哪些类应该聚合在同一个组件中，以便组件既能提供相对完整的功能，又不至于太过庞大。在具体设计中，可以遵循以下三个原则。</p><h3>复用发布等同原则</h3><p>复用发布等同原则是说，<strong>软件复用的最小粒度应该等同于其发布的最小粒度</strong>。也就是说，如果你希望别人以怎样的粒度复用你的软件，你就应该以怎样的粒度发布你的软件。这其实就是组件的定义了，组件是软件复用和发布的最小粒度软件单元。这个粒度既是复用的粒度，也是发布的粒度。</p><p>同时，如果你发布的组件会不断变更，那么你就应该用版本号做好组件的版本管理，以使组件的使用者能够知道自己是否需要升级组件版本，以及是否会出现组件不兼容的情况。因此，组件的版本号应该遵循一些大家都接受的约定。</p><p>这里有一个版本号约定建议供你参考，版本号格式：主版本号.次版本号.修订号。比如1.3.12，在这个版本号中，主版本号是1，次版本号是3，修订号是12。主版本号升级，表示组件发生了不向前兼容的重大修订；次版本号升级，表示组件进行了重要的功能修订或者bug修复，但是组件是向前兼容的；修订号升级，表示组件进行了不重要的功能修订或者bug修复。</p><h3>共同封闭原则</h3><p>共同封闭原则是说，<strong>我们应该将那些会同时修改，并且为了相同目的而修改的类放到同一个组件中</strong>。而将不会同时修改，并且不会为了相同目的而修改的类放到不同的组件中。</p><p>组件的目的虽然是为了复用，然而开发中常常引发问题的，恰恰在于组件本身的可维护性。如果组件在自己的生命周期中必须经历各种变更，那么最好不要涉及其他组件，相关的变更都在同一个组件中。这样，当变更发生的时候，只需要重新发布这个组件就可以了，而不是一大堆组件都受到牵连。</p><p>也许将某些类放入这个组件中对于复用是便利的、合理的，但如果组件的复用与维护发生冲突，比如这些类将来的变更和整个组件将来的变更是不同步的，不会由于相同的原因发生变更，那么为了可维护性，应该谨慎考虑，是不是应该将这些类和组件放在一起。</p><h3>共同复用原则</h3><p>共同复用原则是说，<strong>不要强迫一个组件的用户依赖他们不需要的东西</strong>。</p><p>这个原则一方面是说，我们应该将互相依赖，共同复用的类放在一个组件中。比如说，一个数据结构容器组件，提供数组、Hash表等各种数据结构容器，那么对数据结构遍历的类、排序的类也应该放在这个组件中，以使这个组件中的类共同对外提供服务。</p><p>另一方面，这个原则也说明，如果不是被共同依赖的类，就不应该放在同一个组件中。如果不被依赖的类发生变更，就会引起组件变更，进而引起使用组件的程序发生变更。这样就会导致组件的使用者产生不必要的困扰，甚至讨厌使用这样的组件，也造成了组件复用的困难。</p><p>其实，以上三个组件内聚原则相互之间也存在一些冲突，比如共同复用原则和共同闭包原则，一个强调易复用，一个强调易维护，而这两者是有冲突的。因此这些原则可以用来指导组件设计时的考量，但要想真正做出正确的设计决策，还需要架构师自己的经验和对场景的理解，对这些原则进行权衡。</p><h2>组件耦合原则</h2><p>组件内聚原则讨论的是组件应该包含哪些功能和类，而组件耦合原则讨论组件之间的耦合关系应该如何设计。组件耦合关系设计也应该遵循三个原则。</p><h3>无循环依赖原则</h3><p>无循环依赖原则说，<strong>组件依赖关系中不应该出现环</strong>。如果组件A依赖组件B，组件B依赖组件C，组件C又依赖组件A，就形成了循环依赖。</p><p>很多时候，循环依赖是在组件的变更过程中逐渐形成的，组件A版本1.0依赖组件B版本1.0，后来组件B升级到1.1，升级的某个功能依赖组件A的1.0版本，于是形成了循环依赖。如果组件设计的边界不清晰，组件开发设计缺乏评审，开发者只关注自己开发的组件，整个项目对组件依赖管理没有统一的规则，很有可能出现循环依赖。</p><p>而一旦系统内出现组件循环依赖，系统就会变得非常不稳定。一个微小的bug都可能导致连锁反应，在其他地方出现莫名其妙的问题，有时候甚至什么都没做，头一天还好好的系统，第二天就启动不了了。</p><p>在有严重循环依赖的系统内开发代码，整个技术团队就好像在焦油坑里编程，什么也不敢动，也动不了，只有焦躁和沮丧。</p><h3>稳定依赖原则</h3><p>稳定依赖原则说，<strong>组件依赖关系必须指向更稳定的方向</strong>。很少有变更的组件是稳定的，也就是说，经常变更的组件是不稳定的。根据稳定依赖原则，不稳定的组件应该依赖稳定的组件，而不是反过来。</p><p>反过来说，如果一个组件被更多组件依赖，那么它需要相对是稳定的，因为想要变更一个被很多组件依赖的组件，本身就是一件困难的事。相对应的，如果一个组件依赖了很多的组件，那么它相对也是不稳定的，因为它依赖的任何组件变更，都可能导致自己的变更。</p><p>稳定依赖原则通俗地说就是，<strong>组件不应该依赖一个比自己还不稳定的组件</strong>。</p><h3>稳定抽象原则</h3><p>稳定抽象原则说，<strong>一个组件的抽象化程度应该与其稳定性程度一致</strong>。也就是说，一个稳定的组件应该是抽象的，而不稳定的组件应该是具体的。</p><p>这个原则对具体开发的指导意义就是：如果你设计的组件是具体的、不稳定的，那么可以为这个组件对外提供服务的类设计一组接口，并把这组接口封装在一个专门的组件中，那么这个组件相对就比较抽象、稳定。</p><p>在具体实践中，这个抽象接口的组件设计，也应该遵循前面专栏讲到的<a href=\"https://time.geekbang.org/column/article/179282\">依赖倒置原则</a>。也就是说，抽象的接口组件不应该由低层具体实现组件定义，而应该由高层使用组件定义。高层使用组件依赖接口组件进行编程，而低层实现组件实现接口组件。</p><p>Java中的JDBC就是这样一个例子，在JDK中定义JDBC接口组件，这个接口组件位于<code>java.sql</code>包，我们开发应用程序的时候只需要使用JDBC的接口编程就可以了。而发布应用的时候，我们指定具体的实现组件，可以是MySQL实现的JDBC组件，也可以是Oracle实现的JDBC组件。</p><h2>小结</h2><p>组件的边界与依赖关系划分，不仅需要考虑技术问题，也要考虑业务场景问题。易变与稳定，依赖与被依赖，都需要放在业务场景中去考察。有的时候，甚至不只是技术和业务的问题，还需要考虑人的问题，在一个复杂的组织中，组件的依赖与设计需要考虑人的因素，如果组件的功能划分涉及到部门的职责边界，甚至会和公司内的政治关联起来。</p><p>因此，公司的技术沉淀与实力，公司的业务情况，部门与团队的人情世故，甚至公司的过往历史，都可能会对组件的设计产生影响。而能够深刻了解这些情况的，通常都是公司的一些“老人”。所以，年龄大的程序员并不一定要和年轻程序员拼技术甚至拼体力，应该发挥自己的所长，去做一些对自己、对公司更有价值的事。</p><h2>思考题</h2><p>在稳定抽象原则里，类似JDBC的例子还有很多，你能举几个吗？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","neighbors":{"left":{"article_title":"18 | 反应式编程框架设计：如何使程序调用不阻塞等待，立即响应？","id":184379},"right":{"article_title":"20 | 领域驱动设计：35岁的程序员应该写什么样的代码？","id":185352}},"comments":[{"had_liked":false,"id":168518,"user_name":"草原上的奔跑","can_delete":false,"product_type":"c1","uid":1120348,"ip_address":"","ucode":"D69C617F767736","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/5c/1a58e8f6.jpg","comment_is_top":false,"comment_ctime":1578103255,"is_pvip":false,"replies":[{"id":"65451","content":"👍 我期待的答案","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1578198555,"ip_address":"","comment_id":168518,"utype":1}],"discussion_count":3,"race_medal":0,"score":"83182481879","product_id":100040201,"comment_content":"slf4j也是稳定抽象原则的一个例子，具体实现有log4j、logback","like_count":20,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480237,"discussion_content":"👍 我期待的答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578198555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263977,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/69/c0fcf4e8.jpg","nickname":"def","note":"","ucode":"39BDBEA0560C13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351052,"discussion_content":"我也是第一个就想到这个","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614136630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1493907,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","nickname":"努力努力再努力","note":"","ucode":"0C6EEA28FCE8C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558958,"discussion_content":"我也第一个想到这个 哈哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648530083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238970,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1596385399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18776254583","product_id":100040201,"comment_content":"这个专栏对于在程序设计上的指导意义，在我心中是NO.1。","like_count":4},{"had_liked":false,"id":171384,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1578914847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18758784031","product_id":100040201,"comment_content":"其关键在于针对业务做正交分解。<br>","like_count":4},{"had_liked":false,"id":172197,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1579127988,"is_pvip":false,"replies":[{"id":"66810","content":"👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1579137356,"ip_address":"","comment_id":172197,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14464029876","product_id":100040201,"comment_content":"Linux的文件结构就是抽象稳定的，具体的实现可以分为两大类块设备和流设备，细分为无数硬件驱动。","like_count":3,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481659,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579137356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109389,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ed/8d/377c106a.jpg","nickname":"KW💤","note":"","ucode":"290DD7016F4EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393333,"discussion_content":"vfs可不是这个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631362644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168458,"user_name":"Geek_8c5f9c","can_delete":false,"product_type":"c1","uid":1596047,"ip_address":"","ucode":"70CD441EAF490F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","comment_is_top":false,"comment_ctime":1578071755,"is_pvip":false,"replies":[{"id":"65455","content":"👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1578198819,"ip_address":"","comment_id":168458,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14462973643","product_id":100040201,"comment_content":"JMS API<br>RabbitMQ，tibco, ActiveMQ 作为jms client 都实现了jms api.","like_count":3,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480227,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578198819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169790,"user_name":"Zend","can_delete":false,"product_type":"c1","uid":1053921,"ip_address":"","ucode":"80EBB0B6772E27","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","comment_is_top":false,"comment_ctime":1578447099,"is_pvip":false,"replies":[{"id":"65990","content":"👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1578532157,"ip_address":"","comment_id":169790,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10168381691","product_id":100040201,"comment_content":"JSR-303 是Java EE 6 中的一项子规范，叫做BeanValidation，<br>javax.validation包设计相应的Bean Validation API，<br>官方参考实现是hibernate-validator。","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480720,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578532157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172195,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1579127700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874094996","product_id":100040201,"comment_content":"组件内聚原则，提供相对完整的功能。<br>组件发布等同原则，同时被复用的类放在一起，同时发布。<br>组件共同封闭原则，同时被修改的类放在一起。<br>组件共同复用原则，不必须同时依赖的类不要放在一起。<br><br>组件耦合原则<br>无循环依赖 <br>不稳定的组件依赖稳定的组件，不然所有组件都会变得不稳定。<br> 组件的抽象化程度应该与其稳定性一致，越抽象的组件应该越稳定，不然抽象就没有意义。<br>组件的依赖关系会形成一个有向无环图，越是那些被很多其他节点依赖的节点必须要越稳定。","like_count":1},{"had_liked":false,"id":168190,"user_name":"转折点","can_delete":false,"product_type":"c1","uid":1358797,"ip_address":"","ucode":"DE1EEEF7A5569A","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/cd/6e74b954.jpg","comment_is_top":false,"comment_ctime":1578031047,"is_pvip":false,"replies":[{"id":"65318","content":"自己用java命令行亲手启动一个Java程序就知道了~","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1578039641,"ip_address":"","comment_id":168190,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5872998343","product_id":100040201,"comment_content":"李老师好，一直纠结的一个问题，classpath具体在哪里？我怎么知道jar有没有被放到classpath下面？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480166,"discussion_content":"自己用java命令行亲手启动一个Java程序就知道了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578039641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168061,"user_name":"七七的首席铲屎官","can_delete":false,"product_type":"c1","uid":1350773,"ip_address":"","ucode":"28D7A1AE62C070","user_header":"https://static001.geekbang.org/account/avatar/00/14/9c/75/b9683f39.jpg","comment_is_top":false,"comment_ctime":1578009496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872976792","product_id":100040201,"comment_content":"spring beanfactory 和 applicationcontext也算是吧...","like_count":1},{"had_liked":false,"id":350061,"user_name":"java小霸王","can_delete":false,"product_type":"c1","uid":1168540,"ip_address":"","ucode":"7094BCD9F25E1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/9c/030e80d3.jpg","comment_is_top":false,"comment_ctime":1656551560,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656551560","product_id":100040201,"comment_content":"参考jsr相关的实现，jms(jmq框架) jta(分布式事务) jmm(内存模型)等。或者常见框架，像dubbo里面的spi，为了实现插件化都是依赖稳定抽象，由使用者实现抽象扩展","like_count":0},{"had_liked":false,"id":339996,"user_name":"努力努力再努力","can_delete":false,"product_type":"c1","uid":1493907,"ip_address":"","ucode":"0C6EEA28FCE8C7","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","comment_is_top":false,"comment_ctime":1648530558,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648530558","product_id":100040201,"comment_content":"组件职责类划分<br>1. 发布复用共同原则 意思是说你想别人如何使用你提供的功能，你就只暴露什么功能出去。<br>2. 共同依赖原则 意思是说 相互依赖的类应该放在同一个组件中，不被共同依赖的类，不应该放在同一个组件中<br><br>组件耦合原则<br>3.  禁止循环依赖，组件之间不可以循环依赖，这样会导致维护困难<br>4.  依赖稳定，不稳定的组件应该依赖稳定的组件，而不是反过来，而稳定的组件通常是抽象的组件，不稳定的通常是具体的组件<br>","like_count":0},{"had_liked":false,"id":250386,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1601044782,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1601044782","product_id":100040201,"comment_content":"其实我觉的组件设计原则更像是大粒度的面向对象设计原则和设计模式的应用。<br><br>复用发布等同原则：单一职责<br>共同封闭原则：开闭原则<br>共同复用原则：接口隔离<br><br>无循环依赖原则：环状依赖在面向对象设计也需要避免<br>稳定依赖原则：依赖倒置<br>稳定抽象原则：开闭原则，面向接口编程<br><br>有一点好奇，一般情况下，谁来决定组件设计，或者说如何划分组件？是架构师还是高级程序员。","like_count":0},{"had_liked":false,"id":175253,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1580632327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580632327","product_id":100040201,"comment_content":"SQL语法 是稳定且抽象的","like_count":0},{"had_liked":false,"id":174133,"user_name":"王沛","can_delete":false,"product_type":"c1","uid":1161614,"ip_address":"","ucode":"1423F792D73413","user_header":"https://static001.geekbang.org/account/avatar/00/11/b9/8e/c77e3099.jpg","comment_is_top":false,"comment_ctime":1580018427,"is_pvip":false,"replies":[{"id":"67835","content":"组件很多时候是物理上的，独立的jar什么的，模块很多时候逻辑上的，订单模块什么的，不过也有很多场合指代同一个东西。<br><br>组件中的类变更了，组件不可能不变更的。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1580270340,"ip_address":"","comment_id":174133,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580018427","product_id":100040201,"comment_content":"李老师，组件与模块的区别是什么？是组件可以复用吗？还是别的？另外您在共同复用原则里提的，如果不被依赖的类发生变更，就会引起组件变更进而引起使用组件的程序变更，这怎么理解呢？感觉上不被依赖的类即使变更了按说对组件也不该有影响才对","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482302,"discussion_content":"组件很多时候是物理上的，独立的jar什么的，模块很多时候逻辑上的，订单模块什么的，不过也有很多场合指代同一个东西。\n\n组件中的类变更了，组件不可能不变更的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580270340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161614,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b9/8e/c77e3099.jpg","nickname":"王沛","note":"","ucode":"1423F792D73413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269288,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589890593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172366,"user_name":"Farewell丶","can_delete":false,"product_type":"c1","uid":1179565,"ip_address":"","ucode":"A0D69893C5375C","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","comment_is_top":false,"comment_ctime":1579161955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579161955","product_id":100040201,"comment_content":"spring cloud 其实确切的说核心包含commons和context两个子模块，作为整体的框架性存在。而cloud netfilx, alibaba, kubernetes等都是针对这一套微服务架构标准的实现。","like_count":0},{"had_liked":false,"id":168889,"user_name":"你的美","can_delete":false,"product_type":"c1","uid":1529298,"ip_address":"","ucode":"71B97BDBA3CDC3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","comment_is_top":false,"comment_ctime":1578211205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578211205","product_id":100040201,"comment_content":"李老师好！我是一家新创科技公司的，认为像老师这么厉害的技术师们，除了培训还有一件更值得做的事，那就是助力新创的科技公司，赋能他们技术方面的支持与合作（从而获得更大的回报，做价值最大化）。意思是说：<br>我有一个特别的项目，资质都已备好，准备做项目的一系列申报，还准备和阿里巴巴的蚂蚁资本、洪泰资本等做投资对接，在这些事之前需要邀请几个像老师这么厉害的技术师们做技术合作，无论是技术开发合作还是股份参与合作都行，考虑到时间的问题，那最少的参与是，只需要答应和不定期的和内部员工做技术交流指导就行。<br>我们认为聘请老师做技术合伙人最好（用技术指导～入股）对老师来说是最好的无风险合作方式，怎么个合作法好，也听听老师的建议。老师留个邮箱或者加微信我们再多沟通吧！<br>13811289148","like_count":1},{"had_liked":false,"id":168487,"user_name":"奔奔奔跑","can_delete":false,"product_type":"c1","uid":1210265,"ip_address":"","ucode":"F86EC205DCAACE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Gswh7ibY4tubXhp0BXOmV2pXZ3XsXic1d942ZMAEgWrRSF99bDskOTsG1g172ibORXxSCWTn9HWUX5vSSUVWU5I4A/132","comment_is_top":false,"comment_ctime":1578098236,"is_pvip":false,"replies":[{"id":"65454","content":"我的理解是恰恰相反，微服务架构下会放大依赖关系导致的问题，而依赖关系是业务复杂度和微服务模块设计方法决定的，并不是用了微服务，依赖关系就减少了。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1578198783,"ip_address":"","comment_id":168487,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578098236","product_id":100040201,"comment_content":"李老师您好，在微服务架构下，业务开发应该不需要依赖导致原则来实现业务了吧，因为依赖关系大大减少了，这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480230,"discussion_content":"我的理解是恰恰相反，微服务架构下会放大依赖关系导致的问题，而依赖关系是业务复杂度和微服务模块设计方法决定的，并不是用了微服务，依赖关系就减少了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578198783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}