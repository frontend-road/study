{"id":8799,"title":"第15讲 | synchronized和ReentrantLock有什么区别呢？","content":"<p>从今天开始，我们将进入Java并发学习阶段。软件并发已经成为现代软件开发的基础能力，而Java精心设计的高效并发机制，正是构建大规模应用的基础之一，所以考察并发基本功也成为各个公司面试Java工程师的必选项。</p>\n<p>今天我要问你的问题是， <span class=\"orange\">synchronized和ReentrantLock有什么区别？有人说synchronized最慢，这话靠谱吗？</span></p>\n<!-- [[[read_end]]] -->\n<h2>典型回答</h2>\n<p>synchronized是Java内建的同步机制，所以也有人称其为Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</p>\n<p>在Java 5以前，synchronized是仅有的同步手段，在代码中， synchronized可以用来修饰方法，也可以使用在特定的代码块儿上，本质上synchronized方法等同于把方法全部语句用synchronized块包起来。</p>\n<p>ReentrantLock，通常翻译为再入锁，是Java 5提供的锁实现，它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取，代码书写也更加灵活。与此同时，ReentrantLock提供了很多实用的方法，能够实现很多synchronized无法做到的细节控制，比如可以控制fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用unlock()方法释放，不然就会一直持有该锁。</p>\n<p>synchronized和ReentrantLock的性能不能一概而论，早期版本synchronized在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于ReentrantLock。</p>\n<h2>考点分析</h2>\n<p>今天的题目是考察并发编程的常见基础题，我给出的典型回答算是一个相对全面的总结。</p>\n<p>对于并发编程，不同公司或者面试官面试风格也不一样，有个别大厂喜欢一直追问你相关机制的扩展或者底层，有的喜欢从实用角度出发，所以你在准备并发编程方面需要一定的耐心。</p>\n<p>我认为，锁作为并发的基础工具之一，你至少需要掌握：</p>\n<ul>\n<li>\n<p>理解什么是线程安全。</p>\n</li>\n<li>\n<p>synchronized、ReentrantLock等机制的基本使用与案例。</p>\n</li>\n</ul>\n<p>更进一步，你还需要：</p>\n<ul>\n<li>\n<p>掌握synchronized、ReentrantLock底层实现；理解锁膨胀、降级；理解偏斜锁、自旋锁、轻量级锁、重量级锁等概念。</p>\n</li>\n<li>\n<p>掌握并发包中java.util.concurrent.lock各种不同实现和案例分析。</p>\n</li>\n</ul>\n<h2>知识扩展</h2>\n<p>专栏前面几期穿插了一些并发的概念，有同学反馈理解起来有点困难，尤其对一些并发相关概念比较陌生，所以在这一讲，我也对会一些基础的概念进行补充。</p>\n<p>首先，我们需要理解什么是线程安全。</p>\n<p>我建议阅读Brain Goetz等专家撰写的《Java并发编程实战》（Java Concurrency in Practice），虽然可能稍显学究，但不可否认这是一本非常系统和全面的Java并发编程书籍。按照其中的定义，线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下<strong>共享的</strong>、<strong>可修改的</strong>状态的正确性，这里的状态反映在程序中其实可以看作是数据。</p>\n<p>换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，进而可以推理出保证线程安全的两个办法：</p>\n<ul>\n<li>\n<p>封装：通过封装，我们可以将对象内部状态隐藏、保护起来。</p>\n</li>\n<li>\n<p>不可变：还记得我们在<a href=\"http://time.geekbang.org/column/article/6906\">专栏第3讲</a>强调的final和immutable吗，就是这个道理，Java语言目前还没有真正意义上的原生不可变，但是未来也许会引入。</p>\n</li>\n</ul>\n<p>线程安全需要保证几个基本特性：</p>\n<ul>\n<li>\n<p><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</p>\n</li>\n<li>\n<p><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。</p>\n</li>\n<li>\n<p><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</p>\n</li>\n</ul>\n<p>可能有点晦涩，那么我们看看下面的代码段，分析一下原子性需求体现在哪里。这个例子通过取两次数值然后进行对比，来模拟两次对共享状态的操作。</p>\n<p>你可以编译并执行，可以看到，仅仅是两个线程的低度并发，就非常容易碰到former和latter不相等的情况。这是因为，在两次取值的过程中，其他线程可能已经修改了sharedState。</p>\n<pre><code>public class ThreadSafeSample {\n\tpublic int sharedState;\n\tpublic void nonSafeAction() {\n    \twhile (sharedState &lt; 100000) {\n        \tint former = sharedState++;\n        \tint latter = sharedState;\n        \tif (former != latter - 1) {\n            \tSystem.out.printf(&quot;Observed data race, former is &quot; +\n                    \tformer + &quot;, &quot; + &quot;latter is &quot; + latter);\n        \t}\n    \t}\n\t}\n\n\tpublic static void main(String[] args) throws InterruptedException {\n    \tThreadSafeSample sample = new ThreadSafeSample();\n    \tThread threadA = new Thread(){\n        \tpublic void run(){\n            \tsample.nonSafeAction();\n        \t}\n    \t};\n    \tThread threadB = new Thread(){\n        \tpublic void run(){\n            \tsample.nonSafeAction();\n        \t}\n \t   };\n    \tthreadA.start();\n    \tthreadB.start();\n    \tthreadA.join();\n    \tthreadB.join();\n\t}\n}\n</code></pre>\n<p>下面是在我的电脑上的运行结果：</p>\n<pre><code>C:\\&gt;c:\\jdk-9\\bin\\java ThreadSafeSample\nObserved data race, former is 13097, latter is 13099\n</code></pre>\n<p>将两次赋值过程用synchronized保护起来，使用this作为互斥单元，就可以避免别的线程并发的去修改sharedState。</p>\n<pre><code>synchronized (this) {\n\tint former = sharedState ++;\n\tint latter = sharedState;\n\t// …\n}\n</code></pre>\n<p>如果用javap反编译，可以看到类似片段，利用monitorenter/monitorexit对实现了同步的语义：</p>\n<p></p>\n<pre><code>11: astore_1\n12: monitorenter\n13: aload_0\n14: dup\n15: getfield  \t#2              \t// Field sharedState:I\n18: dup_x1\n…\n56: monitorexit\n</code></pre>\n<p>我会在下一讲，对synchronized和其他锁实现的更多底层细节进行深入分析。</p>\n<p>代码中使用synchronized非常便利，如果用来修饰静态方法，其等同于利用下面代码将方法体囊括进来：</p>\n<pre><code>synchronized (ClassName.class) {}\n</code></pre>\n<p>再来看看ReentrantLock。你可能好奇什么是再入？它是表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，这是对锁获取粒度的一个概念，也就是锁的持有是以线程为单位而不是基于调用次数。Java锁实现强调再入性是为了和pthread的行为进行区分。</p>\n<p>再入锁可以设置公平性（fairness），我们可在创建再入锁时选择是否是公平的。</p>\n<pre><code>ReentrantLock fairLock = new ReentrantLock(true);\n</code></pre>\n<p>这里所谓的公平性是指在竞争场景中，当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程“饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法。</p>\n<p>如果使用synchronized，我们根本<strong>无法进行</strong>公平性的选择，其永远是不公平的，这也是主流操作系统线程调度的选择。通用场景中，公平性未必有想象中的那么重要，Java默认的调度策略很少会导致 “饥饿”发生。与此同时，若要保证公平性则会引入额外开销，自然会导致一定的吞吐量下降。所以，我建议<strong>只有</strong>当你的程序确实有公平性需要的时候，才有必要指定它。</p>\n<p>我们再从日常编码的角度学习下再入锁。为保证锁释放，每一个lock()动作，我建议都立即对应一个try-catch-finally，典型的代码结构如下，这是个良好的习惯。</p>\n<pre><code>ReentrantLock fairLock = new ReentrantLock(true);// 这里是演示创建公平锁，一般情况不需要。\nfairLock.lock();\ntry {\n\t// do something\n} finally {\n \tfairLock.unlock();\n}\n</code></pre>\n<p>ReentrantLock相比synchronized，因为可以像普通对象一样使用，所以可以利用其提供的各种便利方法，进行精细的同步操作，甚至是实现synchronized难以表达的用例，如：</p>\n<ul>\n<li>\n<p>带超时的获取锁尝试。</p>\n</li>\n<li>\n<p>可以判断是否有线程，或者某个特定线程，在排队等待获取锁。</p>\n</li>\n<li>\n<p>可以响应中断请求。</p>\n</li>\n<li>\n<p>...</p>\n</li>\n</ul>\n<p>这里我特别想强调<strong>条件变量</strong>（java.util.concurrent.Condition），如果说ReentrantLock是synchronized的替代选择，Condition则是将wait、notify、notifyAll等操作转化为相应的对象，将复杂而晦涩的同步操作转变为直观可控的对象行为。</p>\n<p>条件变量最为典型的应用场景就是标准类库中的ArrayBlockingQueue等。</p>\n<p>我们参考下面的源码，首先，通过再入锁获取条件变量：</p>\n<pre><code>/** Condition for waiting takes */\nprivate final Condition notEmpty;\n\n/** Condition for waiting puts */\nprivate final Condition notFull;\n \npublic ArrayBlockingQueue(int capacity, boolean fair) {\n\tif (capacity &lt;= 0)\n    \tthrow new IllegalArgumentException();\n\tthis.items = new Object[capacity];\n\tlock = new ReentrantLock(fair);\n\tnotEmpty = lock.newCondition();\n\tnotFull =  lock.newCondition();\n}\n</code></pre>\n<p>两个条件变量是从<strong>同一再入锁</strong>创建出来，然后使用在特定操作中，如下面的take方法，判断和等待条件满足：</p>\n<pre><code>public E take() throws InterruptedException {\n\tfinal ReentrantLock lock = this.lock;\n\tlock.lockInterruptibly();\n\ttry {\n    \twhile (count == 0)\n        \tnotEmpty.await();\n    \treturn dequeue();\n\t} finally {\n    \tlock.unlock();\n\t}\n}\n</code></pre>\n<p>当队列为空时，试图take的线程的正确行为应该是等待入队发生，而不是直接返回，这是BlockingQueue的语义，使用条件notEmpty就可以优雅地实现这一逻辑。</p>\n<p>那么，怎么保证入队触发后续take操作呢？请看enqueue实现：</p>\n<pre><code>private void enqueue(E e) {\n\t// assert lock.isHeldByCurrentThread();\n\t// assert lock.getHoldCount() == 1;\n\t// assert items[putIndex] == null;\n\tfinal Object[] items = this.items;\n\titems[putIndex] = e;\n\tif (++putIndex == items.length) putIndex = 0;\n\tcount++;\n\tnotEmpty.signal(); // 通知等待的线程，非空条件已经满足\n}\n</code></pre>\n<p>通过signal/await的组合，完成了条件判断和通知等待线程，非常顺畅就完成了状态流转。注意，signal和await成对调用非常重要，不然假设只有await动作，线程会一直等待直到被打断（interrupt）。</p>\n<p>从性能角度，synchronized早期的实现比较低效，对比ReentrantLock，大多数场景性能都相差较大。但是在Java 6中对其进行了非常多的改进，可以参考性能<a href=\"https://dzone.com/articles/synchronized-vs-lock\">对比</a>，在高竞争情况下，ReentrantLock仍然有一定优势。我在下一讲进行详细分析，会更有助于理解性能差异产生的内在原因。在大多数情况下，无需纠结于性能，还是考虑代码书写结构的便利性、可维护性等。</p>\n<p>今天，作为专栏进入并发阶段的第一讲，我介绍了什么是线程安全，对比和分析了synchronized和ReentrantLock，并针对条件变量等方面结合案例代码进行了介绍。下一讲，我将对锁的进阶内容进行源码和案例分析。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的synchronized和ReentrantLock你做到心中有数了吗？思考一下，你使用过ReentrantLock中的哪些方法呢？分别解决什么问题？</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n","comments":[{"had_liked":false,"id":11720,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1528330334,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"1118219827294","product_id":100006701,"comment_content":"ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。<br><br>1 用法比较<br>Lock使用起来比较灵活，但是必须有释放锁的配合动作<br>Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁<br>Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等 <br><br>2 特性比较<br>\tReentrantLock的优势体现在：<br>\t  具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁<br>\t  能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放<br>\t  超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回<br><br>3 注意事项<br>在使用ReentrantLock类的时，一定要注意三点：<br>\t 在finally中释放锁，目的是保证在获取锁之后，最终能够被释放<br>\t 不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。<br>\t ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。","like_count":261,"discussions":[{"author":{"id":1943690,"avatar":"","nickname":"Geek_1b42a9","note":"","ucode":"79AF29855A53D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302644,"discussion_content":"嗯，我理解的有偏差。也可以是获取到锁然后响应中断。我一直以为是只有尝试获取锁阶段才能响应中断的。抱歉~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598977954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2355521,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f1/41/76c0758f.jpg","nickname":"君战","note":"","ucode":"A8619A79A5CED9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1943690,"avatar":"","nickname":"Geek_1b42a9","note":"","ucode":"79AF29855A53D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373485,"discussion_content":"要不怎么叫可中断锁~，synchronized无法响应中断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620741127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302644,"ip_address":""},"score":373485,"extra":""}]},{"author":{"id":1943690,"avatar":"","nickname":"Geek_1b42a9","note":"","ucode":"79AF29855A53D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302643,"discussion_content":"第二个特性，“...当获取到锁的线程被中断时..”这段里你这个理解是错误的，应该是等待获取锁的线程被中断，而不是已经获取到锁的线程被中断。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598977369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2938089,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/V71ITElU4RwprR74pPXB6LhIMrfeAHuHjicZmS7smy2tibBSMoA9awaTe86wziatYzoy3qVOGs0DnSTy6ah5L6bKA/132","nickname":"四喜丸子","note":"","ucode":"33D46CC1B747BA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573348,"discussion_content":"到底谁说的是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653374185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11829,"user_name":"冬青树","can_delete":false,"product_type":"c1","uid":1067720,"ip_address":"","ucode":"3DC219F6EE3046","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/c8/7679cd2a.jpg","comment_is_top":false,"comment_ctime":1528379543,"is_pvip":true,"replies":[{"id":"3895","content":"正解","user_name":"作者回复","comment_id":11829,"uid":"1009360","ip_address":"","utype":1,"ctime":1528444854,"user_name_real":"杨晓峰"}],"discussion_count":9,"race_medal":0,"score":"534104324247","product_id":100006701,"comment_content":"一直在研究JUC方面的。所有的Lock都是基于AQS来实现了。AQS和Condition各自维护了不同的队列，在使用lock和condition的时候，其实就是两个队列的互相移动。如果我们想自定义一个同步器，可以实现AQS。它提供了获取共享锁和互斥锁的方式，都是基于对state操作而言的。ReentranLock这个是可重入的。其实要弄明白它为啥可重入的呢，咋实现的呢。其实它内部自定义了同步器Sync，这个又实现了AQS，同时又实现了AOS，而后者就提供了一种互斥锁持有的方式。其实就是每次获取锁的时候，看下当前维护的那个线程和当前请求的线程是否一样，一样就可重入了。","like_count":125,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419017,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528444854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181486,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/2e/878d3c92.jpg","nickname":"木木","note":"","ucode":"E82C58AF2604ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41458,"discussion_content":"我看了源码才知道你说的AQS和AOS说的是什么，哈哈，开心。又长知识了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572430621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2550337,"avatar":"https://static001.geekbang.org/account/avatar/00/26/ea/41/1f7b900b.jpg","nickname":"蓝色天空","note":"","ucode":"26B21D49EAD1E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181486,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/2e/878d3c92.jpg","nickname":"木木","note":"","ucode":"E82C58AF2604ED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365890,"discussion_content":"我还没听过AOS。。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617896495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41458,"ip_address":""},"score":365890,"extra":""}]},{"author":{"id":2550337,"avatar":"https://static001.geekbang.org/account/avatar/00/26/ea/41/1f7b900b.jpg","nickname":"蓝色天空","note":"","ucode":"26B21D49EAD1E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365885,"discussion_content":"哪位来稍微讲下ReentrantLock里面怎么使用AOS的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617895947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1179101,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/dd/baeda83e.jpg","nickname":"Monster!","note":"","ucode":"74F1D3BB5E3915","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2550337,"avatar":"https://static001.geekbang.org/account/avatar/00/26/ea/41/1f7b900b.jpg","nickname":"蓝色天空","note":"","ucode":"26B21D49EAD1E7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384714,"discussion_content":"Sync extends AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer，AQS继承了AOS，AOS就两个方法第一个是设置当前拥有独占访问的线程。锁的拥有线程，null 参数表示没有线程拥有访问；第二个方法是返回第一个方法最后一次设置地访问线程","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1626708078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365885,"ip_address":""},"score":384714,"extra":""}]},{"author":{"id":2052476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Qq6oLfOTgKzjiculoUDicdv7WoY1iabPfOTumibWeInVP2Mnod9XVPrNSClvIiaLbvtDlIjRnWUNaXcYwREGzlcaDog/132","nickname":"Geek_在下蟑螂王","note":"","ucode":"E1F5BBB5BC5962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289512,"discussion_content":"有丶东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594127826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125281,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2b/a1/d40cc39d.jpg","nickname":"煜城骁特","note":"","ucode":"F4939490CF38FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206696,"discussion_content":"讲得很透彻，结合源码，果然理解起来，就比较方便了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584429797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129317,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/65/203298ce.jpg","nickname":"小名叫大明","note":"","ucode":"4804D68A396B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105735,"discussion_content":"讲得透彻，感谢大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577466381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1097836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","nickname":"随心而至","note":"","ucode":"31866865255101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14625,"discussion_content":"这或许就是看源码的重要性，而不是强行记忆，理解记忆要好得多，要不然是过不了夺命连环问的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568773560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65000,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1548996369,"is_pvip":false,"replies":[{"id":"23347","content":"非常感谢反馈","user_name":"作者回复","comment_id":65000,"uid":"1009360","ip_address":"","utype":1,"ctime":1549818265,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"207707426577","product_id":100006701,"comment_content":"先说说点学习感受：<br>并发领域的知识点很多也很散，并且知识点之间交错的。比如：synchronized，这个小小的关键字，能够彻底理解它，需要的知识储备有：基本使用场景、对锁的理解、对线程安全的理解、对同步语义的理解、对JMM的理解等等。有时候，一个知识点暂时做不到透彻理解，可能是正常的，需要再继续学习其它的知识点，等到一定时候，回过头来重新学习，会有一种柳暗花明又一村的感觉。我想，这也可能是老师提到的：并发领域相关知识的准备，需要点耐心。<br><br>再说说这篇专栏：<br>这篇专栏，在知识扩展部分，我觉得结构不是太清晰。我读了很多遍之后，还是有这种感觉：文章讲了很多东西，但是我却很难说出文章的主题。<br>为此，我自己总结了一下知识扩展部分的主线：<br>1. 进入并发领域，首先需要理解什么是线程安全，为什么会存在线程不安全，又为什么需要线程安全。这个知识点可参考《Java并发编程实践》，并且我也认为对于线程安全的讲解，这本书堪称权威；<br>2. 老师在讲解线程安全这个点的时候，顺其自然地使用了synchronized和ReentrantLock来保证线程安全（即：Java提供的锁机制）同时，老师也稍微讲解了一下synchronized和ReentrantLock的使用和区别；<br>3. 最后，老师举了一个ReentrantLock的典型使用场景：ArrayBlockingQueue。ArrayBlockingQueue使用ReentrantLock来实现加锁机制，保证队列的安全读取，并且使用Condition来实现队列阻塞的条件判断和读写端唤醒，特别提一句：具体的实现代码是相当的优雅！<br>","like_count":49,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438267,"discussion_content":"非常感谢反馈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549818265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11738,"user_name":"BY","can_delete":false,"product_type":"c1","uid":1119827,"ip_address":"","ucode":"9FFA0F414A978D","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/53/03930a6b.jpg","comment_is_top":false,"comment_ctime":1528333176,"is_pvip":false,"replies":[{"id":"3896","content":"加油","user_name":"作者回复","comment_id":11738,"uid":"1009360","ip_address":"","utype":1,"ctime":1528444902,"user_name_real":"杨晓峰"}],"discussion_count":3,"race_medal":0,"score":"130377352056","product_id":100006701,"comment_content":"要是早看到这篇文章，我上次面试就过了。。","like_count":31,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418975,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528444902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232980,"avatar":"http://thirdwx.qlogo.cn/mmopen/ajNVdqHZLLAg1foYiaSOhElhVOwcKJRYNiaqzR38ibb78Ytj9rTXj9TJzAM1phdoVibUrNvEWia2z35sf6tbt7Srjhh4o5iaxBt62icGnvkB28x9aI/132","nickname":"hugl","note":"","ucode":"101C66E747C935","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301379,"discussion_content":"那你得面多垃圾的公司啊  这人讲的很一般 后悔买这个专栏了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598509050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1046545,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/11/c62a583d.jpg","nickname":"333","note":"","ucode":"A0BA53EBAD81EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1232980,"avatar":"http://thirdwx.qlogo.cn/mmopen/ajNVdqHZLLAg1foYiaSOhElhVOwcKJRYNiaqzR38ibb78Ytj9rTXj9TJzAM1phdoVibUrNvEWia2z35sf6tbt7Srjhh4o5iaxBt62icGnvkB28x9aI/132","nickname":"hugl","note":"","ucode":"101C66E747C935","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311374,"discussion_content":"确实，说的不够全面。都是只说一点点概念。原理什么的压根没有讲，相当于就抛出问题，然后剩下的你自己玩去吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602319753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301379,"ip_address":""},"score":311374,"extra":""}]}]},{"had_liked":false,"id":11833,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1528380984,"is_pvip":false,"replies":[{"id":"3894","content":"嗯，并发库里都是靠自己的synchronizer","user_name":"作者回复","comment_id":11833,"uid":"1009360","ip_address":"","utype":1,"ctime":1528436305,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"78837792312","product_id":100006701,"comment_content":"ReentrantLock 加锁的时候通过cas算法，将线程对象放到一个双向链表中，然后每次取出链表中的头节点，看这个节点是否和当前线程相等。是否相等比较的是线程的ID。<br>老师我理解的对不对啊？","like_count":17,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419020,"discussion_content":"嗯，并发库里都是靠自己的synchronizer","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528436305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11763,"user_name":"Kyle","can_delete":false,"product_type":"c1","uid":1106079,"ip_address":"","ucode":"44198A0BEC5FB2","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/9f/9259a6b9.jpg","comment_is_top":false,"comment_ctime":1528339662,"is_pvip":true,"replies":[{"id":"3868","content":"后面会对实现做些源码分析，其实还有各种不同的锁...","user_name":"作者回复","comment_id":11763,"uid":"1009360","ip_address":"","utype":1,"ctime":1528380364,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"65952849102","product_id":100006701,"comment_content":"最近刚看完《Java 并发编程实战》，所以今天看这篇文章觉得丝毫不费力气。开始觉得，极客时间上老师讲的内容毕竟篇幅有限，更多的还是需要我们课后去深入钻研。希望老师以后讲完课也能够适当提供些参考书目，谢谢。","like_count":16,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418987,"discussion_content":"后面会对实现做些源码分析，其实还有各种不同的锁...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528380364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12388,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1528791388,"is_pvip":false,"replies":[{"id":"4081","content":"你看到的很对，如果从单个线程做的事来看，也许并没有优势，不管是空间还是时间，但ReentrantLock这种所谓cas，或者叫lock-free，方式的好处，在于高竞争情况的扩展性，而原来那种频繁的上下文切换则会导致吞吐量迅速下降","user_name":"作者回复","comment_id":12388,"uid":"1009360","ip_address":"","utype":1,"ctime":1528818161,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"57363366236","product_id":100006701,"comment_content":"杨老师，问个问题，看网上有说Condition的await和signal方法，等同于Object的wait和notify，看了一下源码，没有直接的关系。<br>ReentractLock是基于双向链表的对接和CAS实现的，感觉比Object增加了很多逻辑，怎么会比Synchronized效率高？有疑惑。","like_count":13,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419240,"discussion_content":"你看到的很对，如果从单个线程做的事来看，也许并没有优势，不管是空间还是时间，但ReentrantLock这种所谓cas，或者叫lock-free，方式的好处，在于高竞争情况的扩展性，而原来那种频繁的上下文切换则会导致吞吐量迅速下降","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1528818161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129317,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/65/203298ce.jpg","nickname":"小名叫大明","note":"","ucode":"4804D68A396B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105739,"discussion_content":"欣赏深度思考\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577466623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13147,"user_name":"木瓜芒果","can_delete":false,"product_type":"c1","uid":1104784,"ip_address":"","ucode":"60075A12D65DF8","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/90/a0f2d021.jpg","comment_is_top":false,"comment_ctime":1529405410,"is_pvip":false,"replies":[{"id":"4373","content":"这个精确的标准我还真不知道，我觉得可以这么理解：如果大部分情况，每个线程都不需要真的获取锁，就是低竞争；反之，大部分都要获取锁才能正常工作，就是高竞争","user_name":"作者回复","comment_id":13147,"uid":"1009360","ip_address":"","utype":1,"ctime":1529420955,"user_name_real":"杨晓峰"}],"discussion_count":3,"race_medal":0,"score":"48774045666","product_id":100006701,"comment_content":"杨老师，您好，synchronized在低竞争场景下可能优于retrantlock，这里的什么程度算是低竞争场景呢？","like_count":12,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419554,"discussion_content":"这个精确的标准我还真不知道，我觉得可以这么理解：如果大部分情况，每个线程都不需要真的获取锁，就是低竞争；反之，大部分都要获取锁才能正常工作，就是高竞争","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529420955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116807,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0a/87/56b07589.jpg","nickname":"nearzk","note":"","ucode":"CDEA6841E5F54C","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584369,"discussion_content":"我知道降低锁的竞争程度有三种方式：\n1、减少锁的持有时间（如：缩小锁范围）\n2、降低锁的请求频率（如：锁分解，锁分段）\n3、使用带有协调机制的独占锁（如：分段锁，读写锁）\n\n所以这么理解，低竞争场景是锁的持有时间短、请求频率低、锁定力度小的场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660791230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1943690,"avatar":"","nickname":"Geek_1b42a9","note":"","ucode":"79AF29855A53D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302759,"discussion_content":"为啥synchronized就适合低竞争？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599024053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70268,"user_name":"加载中……","can_delete":false,"product_type":"c1","uid":1366948,"ip_address":"","ucode":"3E59A0A0784D0A","user_header":"https://static001.geekbang.org/account/avatar/00/14/db/a4/191be6ad.jpg","comment_is_top":false,"comment_ctime":1551061549,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40205767213","product_id":100006701,"comment_content":"看到留言区，有个同学问：new ReentrantLock()能不能写到里面，我看了回复，不是很认同，不知道到对不对。其实：new lock和lock api的调用得写到try外面，写到里面会有问题，如下：<br>lock() api 可能会抛出异常，如果放到try里面，在finally里面unlock会再抛出异常(因为当前状态不对)，这个时候 &quot;解锁异常&quot;会隐藏&quot;加锁异常&quot;，也就是异常堆栈只有“解锁异常”没有&quot;加锁异常&quot;，而这样会误导程序员吧？，模拟代码如下：<br>try {<br>            &#47;&#47;如果lock在try里，且lock抛出异常<br>            throw new RuntimeException(&quot;加锁异常&quot;);<br>        } finally {<br>            &#47;&#47;调用unlock如果lock没有获取到锁会抛出异常，这个在堆栈会隐藏“加锁异常”<br>            throw new RuntimeException(&quot;解锁异常&quot;);<br>        }","like_count":9,"discussions":[{"author":{"id":1154783,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9e/df/ac5c60b5.jpg","nickname":"jiahua","note":"","ucode":"A2B85DA49DC69D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331051,"discussion_content":"请问一下，写外面不也会执行finally吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606752755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12531,"user_name":"Daydayup","can_delete":false,"product_type":"c1","uid":1114245,"ip_address":"","ucode":"A03996E942CDFD","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/85/21e1a720.jpg","comment_is_top":false,"comment_ctime":1528894338,"is_pvip":false,"replies":[{"id":"4129","content":"非常感谢","user_name":"作者回复","comment_id":12531,"uid":"1009360","ip_address":"","utype":1,"ctime":1528901633,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"40183600002","product_id":100006701,"comment_content":"我用过读写分离锁，读锁保证速度，写锁保证安全问题。再入锁还是挺好用的。老师写的很棒，学到不少知识。感谢","like_count":9,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419288,"discussion_content":"非常感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528901633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14253,"user_name":"猪哥灰","can_delete":false,"product_type":"c1","uid":1056113,"ip_address":"","ucode":"5682FB624D7795","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/71/4d3d2a62.jpg","comment_is_top":false,"comment_ctime":1530243530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31595014602","product_id":100006701,"comment_content":"为了研究java的并发，我先把考研时候的操作系统教材拿出来再仔细研读一下，可见基础之重要性，而不管是什么语言，万变不离其宗","like_count":8},{"had_liked":false,"id":182710,"user_name":"豆子高","can_delete":false,"product_type":"c1","uid":1326166,"ip_address":"","ucode":"C84B1081E40A08","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLxDV4VqTISMDBPgnjDAicCnWbjE3FeFv4eNWdITw6aib82iasfb63vJCU6bxRB4zN6eaGztZPmlpWdg/132","comment_is_top":false,"comment_ctime":1582854268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27352658044","product_id":100006701,"comment_content":"看了杨老师的讲解，其实也不是很理解，这块儿平时也不怎么注意学习，每次都是要面试了临时抱佛脚，不过这次算是一次比较全面的学习，下面记录一下我的学习结果（比较简略，算是一个要点大纲，说错的的地方希望各位老师同学给个指点）：<br>Synchronize与ReentrantLock都是属于阻塞式同步，即当前线程正在执行时，其他线程都会阻塞在同步块外等待。（因为线程的唤起和阻塞代价都比较高，所以一般锁的优化都是往这方面考虑）<br><br>Synchronize（以下简称S）<br>S是一个关键字，用于修饰方法和代码块，加锁和释放锁都是通过JVM的编译器来自动实现的，所以属于JVM层面的锁机制；<br><br>S竞争锁的时候无法设置超时时间，所以是一直等待的，这样会导致死锁，不过这是S优化前会出现的问题，优化后，S引入了偏向锁、轻量级锁，就好用很多。S的优化借鉴了R的CAS技术（无锁算法），在用户态就试图进行加锁；<br><br>S控制等待和唤醒线程需要结合Object对象的wait()当前线程休眠且释放锁;和notify()获得锁;和notifyAll();方法；<br><br>S在代码块完成或出现异常的时候自动释放锁。<br><br> <br><br>ReentrantLock（以下简称R）<br>R是一种再入锁，手动上锁，通过实现JDK的API接口lock方法和unlock来实现加锁和释放锁，所以是一种JDK层面的锁机制；<br><br>R竞争锁的时候可以设置超时时间，会尝试获得锁，若线程长时间得不到锁会选择放弃等待（通过lockInterruptibly来实现）（等待可中断）；<br><br>R可实现公平锁，针对等待的线程采取先到先得的措施；<br><br>R控制等待和唤醒线程需要结合Condition的await();和signal();和signalAll();方法；<br><br>R不会自动释放锁，需要使用finally{}手动释放unlock；<br><br>R提供了一些高级功能：<br><br>1、等待可中断；<br><br>2、公平锁；<br><br>R是基于AQS（AbstractQueueSynchronize）和LockSupport，AQS主要利用CAS实现轻量级的同步，AQS本质是一个同步器&#47;阻塞锁的基础框架，主要提供加锁和释放锁。在内部维护一个FIFO的等待队列，用于存储由于锁竞争而阻塞的线程，使用链表作为队列，volatile作为变量，state作为锁状态标识。<br><br>CAS是一种无锁算法，一种可以实现线程同步的原子操作。有三个参数，内存地址V，旧的预期值A，即将要更新的目标值B，当且仅当V=A的时候，才会将V修改成B。","like_count":7},{"had_liked":false,"id":11869,"user_name":"xinfangke","can_delete":false,"product_type":"c1","uid":1142403,"ip_address":"","ucode":"F6459459089BF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/83/a912bfb4.jpg","comment_is_top":false,"comment_ctime":1528418610,"is_pvip":false,"replies":[{"id":"3898","content":"这个我没用过，哪位读者熟悉？","user_name":"作者回复","comment_id":11869,"uid":"1009360","ip_address":"","utype":1,"ctime":1528445090,"user_name_real":"杨晓峰"}],"discussion_count":3,"race_medal":0,"score":"27298222386","product_id":100006701,"comment_content":"老师 问你个问题 在spring中 如果标注一个方法的事务隔离级别为序列化 而数据库的隔离级别是默认的隔离级别 此时此方法中的更新 插入语句是如何执行的？能保证并发不出错吗","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419034,"discussion_content":"这个我没用过，哪位读者熟悉？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528445090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074333,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/9d/00cc43c0.jpg","nickname":"hlwzjc","note":"","ucode":"2E15475F9EF1AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210096,"discussion_content":"以spring的事务隔离级别为准\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584707240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129317,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/65/203298ce.jpg","nickname":"小名叫大明","note":"","ucode":"4804D68A396B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105737,"discussion_content":"老铁你这个是数据库锁，隔离级别的原理。 \n\n和Java的并发没有关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577466554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11926,"user_name":"鲲鹏飞九万里","can_delete":false,"product_type":"c1","uid":1093920,"ip_address":"","ucode":"82BD0C789DF612","user_header":"https://static001.geekbang.org/account/avatar/00/10/b1/20/8718252f.jpg","comment_is_top":false,"comment_ctime":1528440170,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23003276650","product_id":100006701,"comment_content":"老师，可以问您一个课外题吗。具备怎样的能力才算是java高级开发","like_count":5,"discussions":[{"author":{"id":1079811,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/03/c9b43b21.jpg","nickname":"BewhY","note":"","ucode":"4BC26D47A79967","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7588,"discussion_content":"这36讲中的内容，面试官随便抽一个问，你都能对答如流并且延伸扩展的时候，就是真正的高级开发了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567579803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1406090,"avatar":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","nickname":"kyl","note":"","ucode":"DBDFD0FEB5A135","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298519,"discussion_content":"那我还只是初级开发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597316247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57725,"user_name":"Neil","can_delete":false,"product_type":"c1","uid":1206345,"ip_address":"","ucode":"909A2103DFEE1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/49/418a9486.jpg","comment_is_top":false,"comment_ctime":1546875743,"is_pvip":false,"replies":[{"id":"23314","content":"基本如此，乐观、悲观是两种不同的处理策略","user_name":"作者回复","comment_id":57725,"uid":"1009360","ip_address":"","utype":1,"ctime":1549806817,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"18726744927","product_id":100006701,"comment_content":"可以理解为synchronized是悲观锁 另一个是乐观锁","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435723,"discussion_content":"基本如此，乐观、悲观是两种不同的处理策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549806817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11714,"user_name":"sunlight001","can_delete":false,"product_type":"c1","uid":1126975,"ip_address":"","ucode":"A72C4274D5DE8A","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/3f/fa4ac035.jpg","comment_is_top":false,"comment_ctime":1528329566,"is_pvip":false,"replies":[{"id":"3870","content":"还真不知道有没有具体标准，但从逻辑上，低业务量不一定是“低竞争”，可能因为程序设计原因变成了“高竞争”","user_name":"作者回复","comment_id":11714,"uid":"1009360","ip_address":"","utype":1,"ctime":1528384643,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"14413231454","product_id":100006701,"comment_content":"老师这里说的低并发和高并发的场景，大致什么数量级的算低并发？我们做管理系统中用到锁的情况基本都算低并发吧","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418968,"discussion_content":"还真不知道有没有具体标准，但从逻辑上，低业务量不一定是“低竞争”，可能因为程序设计原因变成了“高竞争”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528384643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50125,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1544874595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10134809187","product_id":100006701,"comment_content":"没有可修改，不用担心状态会改变，有没有多线程无所谓。<br>有可修改，只有一个线程，不用担心状态会被修改错。<br>有可修，有多线程，就存在修改错乱的情况，就需要加锁。锁，到底是啥东西呢？锁，本质是啥呢？经常说获取锁，到底是获取的啥呢？用完锁，要释放，释放啥？释放的动作是啥呢？<br><br>锁-本质上就是一种同步机制，能够保证多线程环境下，对共享数据的正确修改。<br>同步机制，是什么机制呢？怎么保证的呢？到这里是否就需要操作系统相关的知识才能理解了，能理解锁的作用和特点，但对锁本身认识还是模糊的，不太清楚他是怎么起作用的，他的特点是他内部的什么因素的外在表现？<br>恩，先继续，然后再回头看看，也许能领悟出的点什么🤔","like_count":2},{"had_liked":false,"id":18540,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1533437249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10123371841","product_id":100006701,"comment_content":"所有的Lock都是基于AQS来实现了。AQS和Condition各自维护了不同的队列，在使用lock和condition的时候，其实就是两个队列的互相移动。如果我们想自定义一个同步器，可以实现AQS。它提供了获取共享锁和互斥锁的方式，都是基于对state操作而言的。ReentranLock这个是可重入的。其实要弄明白它为啥可重入的呢，咋实现的呢。其实它内部自定义了同步器Sync，这个又实现了AQS，同时又实现了AOS，而后者就提供了一种互斥锁持有的方式。其实就是每次获取锁的时候，看下当前维护的那个线程和当前请求的线程是否一样，一样就可重入了。<br>杨老师，我一直是这样用rerentlock的，在使用的类中定义一个static的rerentlock，然后哪个方法中需要用到再 try 中 xx.lock,然后finally中xx.unlock。这样用有没有问题？","like_count":2},{"had_liked":false,"id":149747,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1573365502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868332798","product_id":100006701,"comment_content":"synchronized:<br>语法简单<br>monitor enter monitor exit<br>作用于方法和代码块<br>偏向锁 轻量级锁 自旋锁<br>唤醒通知所有线程+当前线程<br><br><br>ReentrantLock:<br>语法灵活lock unlock<br>公平-非公平<br>响应中断<br>超时获取锁<br>多条件<br>唤醒通知1个线程+当前线程<br><br><br>选型:<br>竞争不激烈用synchronized<br>竞争很激烈用ReentrantLock","like_count":1},{"had_liked":false,"id":148752,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573074580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868041876","product_id":100006701,"comment_content":"反应式编程出来以后，很多的带锁的代码都可以改写成异步的无锁代码，rxjava这种类库又让反应式的编程门槛大降，请问杨老师，rxjava这种类库将来会不会基本替代带锁的代码，多谢.","like_count":1},{"had_liked":false,"id":129539,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1567151579,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5862118875","product_id":100006701,"comment_content":"每次在开发中，对并发知识点理解感觉又前进了一步的时候，我就会想起这个专栏。<br>今天，我有点疑问，希望老师能够回复：<br>Object.wait() 和 LockSupport.park()都能实现，让线程阻塞，它们之间的区别是什么？ 实现原理又是怎么样的？","like_count":1,"discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29659,"discussion_content":"希望老师指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570777996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29658,"discussion_content":"我自行研究了下，底层原理都是中断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570777984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59218,"user_name":"风吹过wu","can_delete":false,"product_type":"c1","uid":1338531,"ip_address":"","ucode":"27E3133A52EA7D","user_header":"https://static001.geekbang.org/account/avatar/00/14/6c/a3/11df679f.jpg","comment_is_top":false,"comment_ctime":1547340098,"is_pvip":false,"replies":[{"id":"23327","content":"加油","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549812871,"ip_address":"","comment_id":59218,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5842307394","product_id":100006701,"comment_content":"希望能够通过借此为契机，深入了解java并发。由于以前自学的java，不系统，借此风水宝地，好好的理理脉络，形成系统","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436312,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549812871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36489,"user_name":"leleba","can_delete":false,"product_type":"c1","uid":1281735,"ip_address":"","ucode":"C868F6ABF509B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/c7/f05f9fd0.jpg","comment_is_top":false,"comment_ctime":1541127905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836095201","product_id":100006701,"comment_content":"这里怎么没有精彩的留言了呢？很难吗，反正我觉得难，但必须要学","like_count":1},{"had_liked":false,"id":19517,"user_name":"时间总漫不经心","can_delete":false,"product_type":"c1","uid":1017829,"ip_address":"","ucode":"1D184BB0D564E9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/e5/67495b10.jpg","comment_is_top":false,"comment_ctime":1533865643,"is_pvip":false,"replies":[{"id":"6857","content":"volatile读写、同步块这种","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1533995602,"ip_address":"","comment_id":19517,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5828832939","product_id":100006701,"comment_content":"老师，jmm什么时候将工作内存的值写入到主内存中呢？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421877,"discussion_content":"volatile读写、同步块这种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533995602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12530,"user_name":"Daydayup","can_delete":false,"product_type":"c1","uid":1114245,"ip_address":"","ucode":"A03996E942CDFD","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/85/21e1a720.jpg","comment_is_top":false,"comment_ctime":1528894337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5823861633","product_id":100006701,"comment_content":"我用过读写分离锁，读锁保证速度，写锁保证安全问题。再入锁还是挺好用的。老师写的很棒，学到不少知识。感谢","like_count":1},{"had_liked":false,"id":12343,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1528769330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5823736626","product_id":100006701,"comment_content":"Reentrant Lock的示例的代码好像不完整。","like_count":1},{"had_liked":false,"id":11853,"user_name":"一个帅哥","can_delete":false,"product_type":"c1","uid":1129350,"ip_address":"","ucode":"4AC1BFAA42DBBA","user_header":"https://static001.geekbang.org/account/avatar/00/11/3b/86/170e58ae.jpg","comment_is_top":false,"comment_ctime":1528388620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5823355916","product_id":100006701,"comment_content":"从书写角度：reentrantlock 需要手动获取和释放锁，而syncgeonised不需要手动获取和释放<br>所以，此外，reentrantlock有trylock 和lockinterruptly ，所以对锁的操作更灵活。从功能的角度看，reentrantlock支持公平锁和非公平锁 而synchronized 仅支持非公平锁。","like_count":2},{"had_liked":false,"id":11838,"user_name":"Libra","can_delete":false,"product_type":"c1","uid":1114307,"ip_address":"","ucode":"30356CFF4C8E35","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/c3/266f9e8d.jpg","comment_is_top":false,"comment_ctime":1528381870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5823349166","product_id":100006701,"comment_content":"希望后面能讲下lock源码整个的设计思想。","like_count":1},{"had_liked":false,"id":11712,"user_name":"wangbo","can_delete":false,"product_type":"c1","uid":1125722,"ip_address":"","ucode":"3F0C9C320F0A1D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/5a/d965c147.jpg","comment_is_top":false,"comment_ctime":1528329345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5823296641","product_id":100006701,"comment_content":"该怎么系统学习java并发？","like_count":1},{"had_liked":false,"id":281812,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1614911165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614911165","product_id":100006701,"comment_content":"“Java 锁实现强调再入性是为了和 pthread 的行为进行区分”<br>比如ReentrantLock的语义，可以类比pthread_mutex, pthread_cond_signal来理解。Doug Lea设计的时候好多就参考了Unix中的已有的实现（比如pthread类库）。<br>Richard Stevens三卷套学完，再打实其他计科的基础知识，懂C,C++，你会发现理解Java并不会太难。","like_count":0},{"had_liked":false,"id":281339,"user_name":"杰里米","can_delete":false,"product_type":"c1","uid":1035748,"ip_address":"","ucode":"D63387DE9A3A05","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e4/53e00c82.jpg","comment_is_top":false,"comment_ctime":1614695180,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1614695180","product_id":100006701,"comment_content":"多台服务器用什么锁","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384687,"discussion_content":"分布式锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626701444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279659,"user_name":"民工597","can_delete":false,"product_type":"c1","uid":1529858,"ip_address":"","ucode":"DB6857E21E9318","user_header":"https://static001.geekbang.org/account/avatar/00/17/58/02/2b7ccf09.jpg","comment_is_top":false,"comment_ctime":1613893193,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1613893193","product_id":100006701,"comment_content":"参考操作系统实现了一套管程模型吧","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384688,"discussion_content":"对的，管程是并发编程的 万 能 钥 匙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626701573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271042,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1609380041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609380041","product_id":100006701,"comment_content":"synchronized 是JVM内部实现的锁, 结合老师的老师的两篇文章以及看了一些资料，之前写了一篇文章总结。https:&#47;&#47;yellowstar5.cn&#47;synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%8F%8A%E5%AE%9E%E7%8E%B0&#47;#more<br><br>ReentrantLock 等锁是基于AQS实现的，可以联系结合pthread_mutex, pthread_cond_signal, 以及pthread_rwlock_rdlock加以理解语义，都是相同的。<br><br>不一定对，还请大家指正","like_count":0},{"had_liked":false,"id":204947,"user_name":"友人","can_delete":false,"product_type":"c1","uid":1217901,"ip_address":"","ucode":"F16456F0A4F73E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ6a62xdMTZ3ntibDXwJv7OXLj4231ENfmaK01EbZfu961oKt07mFehoibRQctnlFkrrMcsG9TIicrwg/132","comment_is_top":false,"comment_ctime":1586498096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586498096","product_id":100006701,"comment_content":"老师您好，想请教一个问题，ReentrantLock是如何保证其加锁与解锁之间的代码块中的共享变量的可见性的？<br><br>我在网上看到不少说法是说，因为AQS中的state是volatile的，而在加锁时会读取state的值，在解锁时会写state的值，对volatile变量的写操作会使线程的工作内存刷到主内存，对volatile变量的读操作会使线程的工作内存失效、然后从主内存读取，因此可以保证代码块中共享变量的可见性。<br><br>可是volatile的语义不是只保证对volatile修饰的<br>变量的可见性吗，为了实现这个语义没有必要将整个线程的工作内存失效吧，最多将部分工作内存失效就可以了(对应到硬件层面就是缓存行？通过缓存一致性协议？)，将全部工作内存失效代价是不是太大了？<br><br>还有，网上都说volatile只能保证对象引用的可见性，如果volatile变量的读取是将整个工作内存失效，那应该是可以保证整个对象的可见性了？<br><br>如果对volatile变量的读取不是将整个线程的工作内存置为无效，那ReentrantLock又是如何保证加锁与解锁之间的代码块中共享变量的可见性的呢<br><br>不好意思，描述的有些乱，希望老师能讲解一下，谢谢！","like_count":0},{"had_liked":false,"id":196524,"user_name":"ilovealt","can_delete":false,"product_type":"c1","uid":1113180,"ip_address":"","ucode":"35CB4FD836135B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/5c/a3d42cdb.jpg","comment_is_top":false,"comment_ctime":1585289996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585289996","product_id":100006701,"comment_content":"这个主题是我们不能错过的技术点。","like_count":0},{"had_liked":false,"id":193254,"user_name":"丁","can_delete":false,"product_type":"c1","uid":1130108,"ip_address":"","ucode":"33E94956454A3D","user_header":"","comment_is_top":false,"comment_ctime":1584887216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584887216","product_id":100006701,"comment_content":"很用心的专栏，一字一句都很值得思考和学习。","like_count":0},{"had_liked":false,"id":192697,"user_name":"护爽使者","can_delete":false,"product_type":"c1","uid":1275464,"ip_address":"","ucode":"12DC35DD74671C","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/48/5ab89daa.jpg","comment_is_top":false,"comment_ctime":1584868835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584868835","product_id":100006701,"comment_content":"ReentrantLock 显示锁，sync是隐式锁","like_count":0},{"had_liked":false,"id":158931,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1575503239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575503239","product_id":100006701,"comment_content":"15 synchronized和reentrantlock区别 1 synchronized java内建的同步机制，又称为intrinsic locking，提供了互斥的语义，当一个线程获取到锁时，其他线程只能等待或者阻塞，synchronized可以修饰方法，也可以修饰语句，reentrantlock 再入锁，语义和synchronized基本相同，通过内部调用lock方法获取再入锁，可以实现很多synchronized无法实现的细节，比如保持公平性，synchronized在低竞争场景中要优于reentrantlock。 2 线程安全 保证多线程下状态共享的可修改的状态的正确性，保证线程安全，2个办法，一个封装，一个不可变。线程安全的3个特性，原子性，相关操作中途不会被其他线程中断，可见性，是一个线程改了状态，可以被其他线程立刻获取到，有序性，保证线程内串行语义，避免指令重排。3 原子性的例子  定义一个类，for循环，操作同一个字段，在多线程下，就会被另一个线程修改，用synchronized(this)，用this作为互斥单元，就可以避免别的线程修改，用javap编译，可以看到monitorenter和monitorexit实现了同步的语义，reentrantlock 再入锁，是一个线程在获取它已经获取的锁时，自动索取到锁，也就是锁的持有粒度是以线程为单位，再入锁可以设置公平性，再入锁，每一个lock在finally的时候，都要unlock，ReentrantLock可以像对象一样使用，可以调用一些方法，如带超时的索取锁尝试，判断是否有线程在等待获取锁，new ReentrantLock.newCondition()方法，Condition的await和signal方法实现等待和通知","like_count":0},{"had_liked":false,"id":145626,"user_name":"zaab","can_delete":false,"product_type":"c1","uid":1683063,"ip_address":"","ucode":"EE846895FF0C85","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QYKSUV20DMgBHAPLfgngdw4N8FHRCSBLCJueVRu9Ya1Ba2x4icx70zoVVFOZtG1K6TkHj5CFbuztQhRFyCjWXHQ/132","comment_is_top":false,"comment_ctime":1572333506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572333506","product_id":100006701,"comment_content":"重入：JVM实现: 当一个线程拿到锁后, 将锁的计数器记为1，当同一个线程再次请求同一个锁后，<br>锁计数器会累加，然后当程序退出某个代码块的时候，计数器就会减1，当计数器为0的时候释放锁。","like_count":0},{"had_liked":false,"id":143151,"user_name":"斜杠青年","can_delete":false,"product_type":"c1","uid":1177739,"ip_address":"","ucode":"D7AF02B8588549","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/8b/74d2ab6b.jpg","comment_is_top":false,"comment_ctime":1571639240,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1571639240","product_id":100006701,"comment_content":"样例代码的ThreadSafeSample类 我这边定义为类final的ThreadSafeSample实例会有影响吗？","like_count":0},{"had_liked":false,"id":136299,"user_name":"Geek_382ccc","can_delete":false,"product_type":"c1","uid":1520267,"ip_address":"","ucode":"3E40727B8772AA","user_header":"","comment_is_top":false,"comment_ctime":1569404736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569404736","product_id":100006701,"comment_content":"为什么我看过之后脑子里完全没有知识图谱，自己也无法很好的复述出来。文中刚开始的问题也没有自己的思路","like_count":0},{"had_liked":false,"id":132432,"user_name":"木易杨","can_delete":false,"product_type":"c1","uid":1128629,"ip_address":"","ucode":"F46DD5AFD29DC0","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/b5/fe066d0c.jpg","comment_is_top":false,"comment_ctime":1568120690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568120690","product_id":100006701,"comment_content":"发现评论中都是人才啊，我用了这么长时间的并发，也没研究透，感觉差的太多了。什么自旋锁、偏向锁都不知道 ","like_count":0},{"had_liked":false,"id":103877,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1560558350,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560558350","product_id":100006701,"comment_content":"lock能够响应中断，指的是在获取锁的等待过程中响应中断吧(未获取到锁)，而非已获取到锁后响应中断（已获取到锁）。不知理解的是否正确？","like_count":0},{"had_liked":false,"id":100334,"user_name":"LeyN","can_delete":false,"product_type":"c1","uid":1179844,"ip_address":"","ucode":"F61707D7F197A8","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/c4/16159a67.jpg","comment_is_top":false,"comment_ctime":1559530116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559530116","product_id":100006701,"comment_content":"马克，来留言区学习","like_count":0},{"had_liked":false,"id":93472,"user_name":"敏捷","can_delete":false,"product_type":"c1","uid":1209404,"ip_address":"","ucode":"E4954E428035CC","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/3c/e8bba8c0.jpg","comment_is_top":false,"comment_ctime":1557476742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557476742","product_id":100006701,"comment_content":"ReentrantLock的signal和signalAll也需要lock才可以调用，否则会抛异常","like_count":0},{"had_liked":false,"id":91859,"user_name":"小一","can_delete":false,"product_type":"c1","uid":1240201,"ip_address":"","ucode":"E92DB9907C2076","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/89/681d9b13.jpg","comment_is_top":false,"comment_ctime":1557121314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557121314","product_id":100006701,"comment_content":"讲的很透彻，赞","like_count":0},{"had_liked":false,"id":90986,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1556769031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556769031","product_id":100006701,"comment_content":"老师你好，请问在使用synchronized需要一个锁对象，我看到有的是object,有this,有其他的，这些其实区别在哪里呢？多谢了","like_count":0},{"had_liked":false,"id":90600,"user_name":"后端进阶","can_delete":false,"product_type":"c1","uid":1125656,"ip_address":"","ucode":"480F48F5378307","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/18/918eaecf.jpg","comment_is_top":false,"comment_ctime":1556586255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556586255","product_id":100006701,"comment_content":"回来再看一遍，又有了不同的收获。","like_count":0},{"had_liked":false,"id":73911,"user_name":"贤蛋蛋","can_delete":false,"product_type":"c1","uid":1046118,"ip_address":"","ucode":"0FCBCB15E94770","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/66/991b7e3a.jpg","comment_is_top":false,"comment_ctime":1552031120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552031120","product_id":100006701,"comment_content":"它是表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，这是对锁获取粒度的一个概念，也就是锁的持有是以线程为单位而不是基于调用次数。<br>根据这样的描述，感觉再入和偏向锁很像？或者再入是偏向的一个父集？","like_count":0},{"had_liked":false,"id":67999,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1550380783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550380783","product_id":100006701,"comment_content":"没在生产中使用过，但使用的组件activemq中看到这个锁的应用","like_count":0},{"had_liked":false,"id":65109,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1549064407,"is_pvip":false,"replies":[{"id":"23348","content":"没有Android经验，最好领域专家回答","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549818511,"ip_address":"","comment_id":65109,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549064407","product_id":100006701,"comment_content":"@老师  ReentrantLock 和 synchronized的在JDK 6.0之前的在高度竞争场景下的性能差异，在Android虚拟机中也同样适用吗？ 或者说：在Android开发中，又该如何正确使用ReentrantLock呢？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438322,"discussion_content":"没有Android经验，最好领域专家回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549818511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55290,"user_name":"志超","can_delete":false,"product_type":"c1","uid":1036048,"ip_address":"","ucode":"4043753B229784","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/10/af87006f.jpg","comment_is_top":false,"comment_ctime":1546091063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546091063","product_id":100006701,"comment_content":"学习了。","like_count":0},{"had_liked":false,"id":41979,"user_name":"猿工匠","can_delete":false,"product_type":"c1","uid":1112986,"ip_address":"","ucode":"82FA8DE6C28936","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/9a/72f7b184.jpg","comment_is_top":false,"comment_ctime":1542885534,"is_pvip":false,"replies":[{"id":"15385","content":"很欣慰","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1543156300,"ip_address":"","comment_id":41979,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542885534","product_id":100006701,"comment_content":"刚好在熟悉ArrayBlockingQueue的源码。通过老师的例子，对 ReentrantLock 的概念和实践，有了点感觉。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429960,"discussion_content":"很欣慰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543156300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32322,"user_name":"吴浩","can_delete":false,"product_type":"c1","uid":1142224,"ip_address":"","ucode":"EA91647FF05EA7","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/d0/6c2b8877.jpg","comment_is_top":false,"comment_ctime":1539530300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539530300","product_id":100006701,"comment_content":"同步代码块是使用monitorenter和monitorexit指令来实现的，同步方法块依靠的是方法修饰符上的ACC_SYNCHRONIZED实现，老师对于同步方法块这块原理可以讲讲","like_count":0},{"had_liked":false,"id":30870,"user_name":"john-jy","can_delete":false,"product_type":"c1","uid":1116514,"ip_address":"","ucode":"6B5884409B52C9","user_header":"","comment_is_top":false,"comment_ctime":1539018747,"is_pvip":false,"replies":[{"id":"11442","content":"事例有点精简过度，容易歧义；需要成对的是lock、unlock这种，从这个角度看，写里面没有特别意义","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1539274384,"ip_address":"","comment_id":30870,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539018747","product_id":100006701,"comment_content":"ReentrantLock fairLock = new ReentrantLock(true);<br>try {<br>\t&#47;&#47; do something<br>} finally {<br> \tfairLock.unlock();<br>}<br>请问ReentrantLock fairLock = new ReentrantLock(true);这一行可以写在try里面吗？我看别人有些代码写在try里面，会不会有问题呢，比如发生new异常","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426121,"discussion_content":"事例有点精简过度，容易歧义；需要成对的是lock、unlock这种，从这个角度看，写里面没有特别意义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539274384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20413,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1534427522,"is_pvip":false,"replies":[{"id":"7379","content":"语义一致，差别不止公平性，例如synchronized不能中断","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1534860184,"ip_address":"","comment_id":20413,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1534427522","product_id":100006701,"comment_content":"老师sychronized应该也是再去锁吧？只是不能实现公平性","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422239,"discussion_content":"语义一致，差别不止公平性，例如synchronized不能中断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534860184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19862,"user_name":"时间总漫不经心","can_delete":false,"product_type":"c1","uid":1017829,"ip_address":"","ucode":"1D184BB0D564E9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/e5/67495b10.jpg","comment_is_top":false,"comment_ctime":1534126011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534126011","product_id":100006701,"comment_content":"老师，没有同步块和volatile修饰的情况下，什么时候工作内存的结果同步到主内存？如果不同步，那多个线程读取的都是一个值的备份，然后在多线程间运算，就像ThreadLocal 那样，有时候不会影响结果。我认为会不定时进行同步吧，这样会保证线程的最低安全性，不知道我这种理解对不对？","like_count":0},{"had_liked":false,"id":15262,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1162307,"ip_address":"","ucode":"0E0D44ABB35DBB","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/43/11acdc02.jpg","comment_is_top":false,"comment_ctime":1531051808,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1531051808","product_id":100006701,"comment_content":"为什么ReentranLock会如此高效？","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384692,"discussion_content":"cas","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626701984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14497,"user_name":"Geek_af3d01","can_delete":false,"product_type":"c1","uid":1107401,"ip_address":"","ucode":"58C5FDD61C955E","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/c9/fa9199d0.jpg","comment_is_top":false,"comment_ctime":1530495281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530495281","product_id":100006701,"comment_content":"杨老师 很感谢 在您这了解到了很多以前没注意的知识点 时刻关注着您 希望您会一直讲下去","like_count":0},{"had_liked":false,"id":12981,"user_name":"飞鱼","can_delete":false,"product_type":"c1","uid":1102465,"ip_address":"","ucode":"F26A7B10FB32CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/81/db154f5f.jpg","comment_is_top":false,"comment_ctime":1529233099,"is_pvip":false,"replies":[{"id":"4422","content":"synchronized已经介绍了，后面我会介绍AQS，reentrantlock等多种同步结构都是利用它实现的；其实你说的靠计算机之类也对，我想你的意思是cas的实现？","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529423747,"ip_address":"","comment_id":12981,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529233099","product_id":100006701,"comment_content":"之前有被问到synchronize和ReetrantLock底层实现上的区别，笼统的答了下前者是基于JVM实现的，后者依赖于CPU底层指令的实现，关于这个，请问有更详细的解答吗？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419488,"discussion_content":"synchronized已经介绍了，后面我会介绍AQS，reentrantlock等多种同步结构都是利用它实现的；其实你说的靠计算机之类也对，我想你的意思是cas的实现？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529423747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12758,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1529021723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1529021723","product_id":100006701,"comment_content":"锁是针对数据的，不是针对代码，一个数据一把锁，syncrise似乎违背了这一原则","like_count":0},{"had_liked":false,"id":12680,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1528954848,"is_pvip":false,"replies":[{"id":"4204","content":"互相影响，底层也有很多一致的地方，类似jmm之类也是c++掉的坑，别人吸取了教训","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990080,"ip_address":"","comment_id":12680,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528954848","product_id":100006701,"comment_content":"看完还是觉得c++11的Lockguard比较优雅，难怪耗子哥说学习java是为了更好的用c++","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419365,"discussion_content":"互相影响，底层也有很多一致的地方，类似jmm之类也是c++掉的坑，别人吸取了教训","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11971,"user_name":"liyaocai","can_delete":false,"product_type":"c1","uid":1117572,"ip_address":"","ucode":"F99B033C0825B0","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/84/f844d245.jpg","comment_is_top":false,"comment_ctime":1528471448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528471448","product_id":100006701,"comment_content":"老师，最近在看并发包的源码，发现8与9的源码改了不少，应该以哪个版本为重呢","like_count":0},{"had_liked":false,"id":11969,"user_name":"liyaocai","can_delete":false,"product_type":"c1","uid":1117572,"ip_address":"","ucode":"F99B033C0825B0","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/84/f844d245.jpg","comment_is_top":false,"comment_ctime":1528471336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528471336","product_id":100006701,"comment_content":"在阅读代码时发现 ReentrantLock中nonfairTryAcquire 中 对state做了溢出判断，我想问一下，除了死循环，还有什么情况会导致溢出呢？<br>if (current == getExclusiveOwnerThread()) {<br>int nextc = c + acquires;<br>if (nextc &lt; 0) &#47;&#47; overflow<br>throw new Error(&quot;Maximum lock count exceeded&quot;);<br>setState(nextc);<br>return true;<br>}","like_count":0},{"had_liked":false,"id":11955,"user_name":"徐金铎","can_delete":false,"product_type":"c1","uid":1080462,"ip_address":"","ucode":"E13FD19FD27869","user_header":"https://static001.geekbang.org/account/avatar/00/10/7c/8e/73581062.jpg","comment_is_top":false,"comment_ctime":1528462793,"is_pvip":false,"replies":[{"id":"3951","content":"对，字节码不一样，但语义是一样","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528593399,"ip_address":"","comment_id":11955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528462793","product_id":100006701,"comment_content":"补充一点，Syc的静态方法和syc(.class)确实是一样的，但是前者是在方法前加syc的flag，后者在反编译后的代码中看不到。所以我查阅了hotspot的文档和代码，确定这一个细节处理是有jvm做的。两者实际运行，确实是一样的处理。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419061,"discussion_content":"对，字节码不一样，但语义是一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528593399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11867,"user_name":"java爱好者","can_delete":false,"product_type":"c1","uid":1127813,"ip_address":"","ucode":"320E8F96AB04FF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/9IUbqCCa3zXkSibzoPc8CgLELkMEbibUxrv8gdicySKeYttf2VG3lHNhU4ia61ibdQbGT556rI1sFgO9lxH9XPTjK2Q/132","comment_is_top":false,"comment_ctime":1528417323,"is_pvip":false,"replies":[{"id":"3906","content":"这个每个queue的javadoc都明确说明了，有什么疑问？","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528446474,"ip_address":"","comment_id":11867,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528417323","product_id":100006701,"comment_content":"老师，怎么判断一个队列是有界或无界，arrayblockingqueue是有界","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419033,"discussion_content":"这个每个queue的javadoc都明确说明了，有什么疑问？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528446474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11857,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1528401747,"is_pvip":true,"replies":[{"id":"3897","content":"有些场景，就类似blockingQueue，用sync表达要吃力些，甚至有时候是表达不出来的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528445034,"ip_address":"","comment_id":11857,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528401747","product_id":100006701,"comment_content":"真不记得自己用过，诚如老师所讲，其有特殊语义能力，如超时，公平性等，但窃以为别给自己添乱最好，万一忘了unlock，话说他这玩意儿为啥不设计个类似try…with…resource的语法糖？估计就是为了把加锁解锁的语法能力分散在不同子例程里撰写使用的考虑？可问题是如果都写成那样了，是否有说明自己程序设计上内聚性不够呢？嗯，再看点源码来找答案吧…话说JCIP真是好书，学不学究的读读资本论之后就释然了，如果真能顺着它仔细读下来，发现它针对特定栗子还会随着内容深入给出不同解法，不禁感叹，也许在利用较低级别的通信原语时，很有可能是对并发包里面一些现成工具类缺乏了解或者是对真正的并发问题缺乏深入理解造成的…虽然自己看起来也就是个CRUD开发的老佃户命了，还是非常期待老师后面的主题，毕竟咱还是有颗通向地主阶层的心","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419031,"discussion_content":"有些场景，就类似blockingQueue，用sync表达要吃力些，甚至有时候是表达不出来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528445034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11823,"user_name":"kai","can_delete":false,"product_type":"c1","uid":1109197,"ip_address":"","ucode":"A5413B7B0C916A","user_header":"","comment_is_top":false,"comment_ctime":1528376171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528376171","product_id":100006701,"comment_content":"<br>在大部分并发编程资料都是将ReentrantLock翻译为&quot;重入锁&quot;。","like_count":0},{"had_liked":false,"id":11722,"user_name":"谢","can_delete":false,"product_type":"c1","uid":1114349,"ip_address":"","ucode":"ADEB5DE33ADC0D","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/ed/5ae3ba7f.jpg","comment_is_top":false,"comment_ctime":1528330839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528330839","product_id":100006701,"comment_content":"ReentranLock相比Synchronized，可以实现更多的锁细节。<br>超时的锁获取<br>可以判断是否有线程在等待锁<br>可以响应中断请求","like_count":0},{"had_liked":false,"id":11717,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1528329995,"is_pvip":false,"replies":[{"id":"3869","content":"有点类似；使用并发库，大部分情况下不再需要调用Object的nitify wait之类，简化了很多；<br>后面的问题我没太看明白","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528380662,"ip_address":"","comment_id":11717,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528329995","product_id":100006701,"comment_content":"老师，signal和await和notify wait有啥区别呢？<br>还有lock方式放入双向链表中的node，是不是按照线程对象（对象地址）进行比较的啊？<br>就是如何判断当前线程是否获得锁是不是按照线程对象地址啊。谢谢老师","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418969,"discussion_content":"有点类似；使用并发库，大部分情况下不再需要调用Object的nitify wait之类，简化了很多；\n后面的问题我没太看明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528380662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}