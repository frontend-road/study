{"id":620893,"title":"22｜物料组件的编译和管理：如何处理组件的多种模块格式？","content":"<p>你好，我是杨文坚。</p><p>我们课程的平台项目，在数据设计环节，把平台的数据划分成了三个数据维度：用户、物料和页面，对应的运营搭建平台功能就有三种功能维度：用户、物料和页面。</p><p>上节课我们学习了用户的注册和登录，也就是用户数据的操作，属于用户功能维度。从这节课开始，我们进入物料功能维度，对运营搭建平台的物料体系进行功能分析、方案设计、技术解构和代码实现。</p><p>“物料”功能，核心就是操作物料的静态资源和数据库数据。其中，物料静态资源指的是每个物料组件的产物，也就是JavaScript和CSS文件，可以独立在浏览器或者Node.js环境中进行渲染或者执行。</p><p>而运营搭建平台，底层功能里最核心就是用物料搭建页面。<strong>如何搭建，其实就是把这些物料的JavaScript和CSS文件组装起来运行。用前端技术视角看，就是用组件（物料）来组装页面</strong>。</p><p>想用组件组装成页面，首先要把组件模块化，方便后续组装，而且，要让组件在不同的环境（浏览器或者Node.js）里的运行，把组件编译成对应模块化格式后才能运行。那么前端组件有哪些模块化方案呢？</p><h2>前端组件有哪些模块化方案？</h2><p>前端组件模块化方案，其实归根结底就是JavaScript的模块化方案。因为不管是Vue.js组件、React.js组件或其他前端框架组件，最终要在浏览器或者Node.js环境运行，都需要编译成JavaScript代码。</p><!-- [[[read_end]]] --><p>那么，我们现在的关注点就是<strong>JavaScript的模块化方案</strong>。</p><p>JavaScript 作为一门“动态脚本语言”，在ES6草案确定前，没有“官方标准”的模快化方案。如果要对跨JavaScript文件的方法和数据进行“联动”，只能靠全局变量进行“通信联通”。后来经过技术社区的探索，基于ES5规范的JavaScript能力，实现了多种模块化方案。比较出名的有AMD模块化方案、CJS模块化方案。</p><p>JavaScrip 在ES6草案确定后，确定了在JavaScript原生语言层面的标准模块化方案，ES Modules，简称ESM。</p><p>很多人疑惑，ESM 既然是JavaScript语言官方的模块化方案，那ES6规范之前的“野生”模块化方案是不是就不适用了呢？其实并不是的，很多以前的模块化方案依然有适用场景，常用的主要有四个。</p><ul>\n<li>ESM 模块化方案</li>\n<li>AMD模块化方案</li>\n<li>IIFE（全局变量）模块化方案</li>\n<li>CJS模块化方案</li>\n</ul><p>来看每个模块化方案的优缺点和使用场景，我也会用代码演示具体原理和实现过程。</p><h3>1. ESM模块化方案</h3><p>这个ES官方规范的模块化方案，在高版本浏览器和高版本Node.js环境下才能直接使用。Node.js在服务端开发可以统一约定使用高版本，但是浏览器是用户自行选择的，控制不了版本，所以ESM在实际工作中要面临浏览器兼容问题。</p><p>ESM的浏览器兼容情况（来自 <a href=\"https://caniuse.com/es6-module\">https://caniuse.com/es6-module</a> ）。</p><p><img src=\"https://static001.geekbang.org/resource/image/31/0f/31ce6dccc5f06085e70d5c0340d77c0f.png?wh=1920x443\" alt=\"图片\"></p><p>ESM在Node.js环境下的支持情况截图（来自 <a href=\"https://nodejs.org/api/esm.html#modules-ecmascript-modules\">https://nodejs.org/api/esm.html#modules-ecmascript-modules</a> ）。</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/2f/b59faf73125012a76828ea3ac74f452f.png?wh=1920x1169\" alt=\"图片\"></p><p>总结一下ESM的几种场景特性。</p><p><img src=\"https://static001.geekbang.org/resource/image/37/dc/377e9e0b1dd543e9a995680d16b527dc.jpg?wh=1920x1395\" alt=\"图片\"></p><p>我们这节课主要是学习组件的模块化方案，因为物料组价的拼装是在浏览器操作进行的，那就优先考虑在浏览器里使用。看一个代码案例，用ESM组装渲染一个Vue.js应用。</p><p>首先是代码的目录。</p><pre><code class=\"language-shell\">. # packages/mock-cdn/demos/esm/ \n├── index.html\n├── index.js\n└── material\n&nbsp; &nbsp; ├── counter-decrease.js\n&nbsp; &nbsp; └── counter-increase.js\n</code></pre><p>其中有两个物料组件 counter-decrease.js 和 counter-increase.js。</p><pre><code class=\"language-typescript\">// packages/mock-cdn/demos/esm/material/counter-decrease.js\nimport { h, ref, toDisplayString } from 'vue';\nconst Counter = {\n  setup() {\n    const num = ref(0);\n    const click = () =&gt; {\n      num.value -= 1;\n    };\n    return () =&gt; {\n      return h('div', { class: 'v-counter' }, [\n        h('div', { class: 'v-text' }, toDisplayString(num.value)),\n        h(\n          'button',\n          {\n            class: 'v-btn',\n            onClick: click\n          },\n          '点击减1'\n        )\n      ]);\n    };\n  }\n};\nexport default Counter;\n</code></pre><pre><code class=\"language-typescript\">// packages/mock-cdn/demos/esm/material/counter-increase.js\nimport { h, ref, toDisplayString } from 'vue';\nconst Counter = {\n  setup() {\n    const num = ref(0);\n    const click = () =&gt; {\n      num.value += 1;\n    };\n    return () =&gt; {\n      return h('div', { class: 'v-counter' }, [\n        h('div', { class: 'v-text' }, toDisplayString(num.value)),\n        h(\n          'button',\n          {\n            class: 'v-btn',\n            onClick: click\n          },\n          '点击加1'\n        )\n      ]);\n    };\n  }\n};\nexport default Counter;\n</code></pre><p>有了ESM物料产物，接下来就是物料的组装和渲染。</p><pre><code class=\"language-xml\">&lt;!-- packages/mock-cdn/demos/esm/index.html --&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\" /&gt;\n    &lt;script type=\"importmap\"&gt;\n      {\n        \"imports\": {\n          \"vue\": \"/public/pkg/vue/3.2.45/dist/vue.runtime.esm-browser.js\",\n          \"vue-router\": \"/public/pkg/vue/3.2.45/dist/vue.runtime.esm-browser.js\"\n        }\n      }\n    &lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;页面加载中...&lt;/div&gt;\n    &lt;script type=\"module\" src=\"./index.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><pre><code class=\"language-typescript\">// packages/mock-cdn/demos/esm/index.js\nimport { createApp, h } from 'vue';\nconst layout = {\n  materials: [\n    { name: 'counter-increase' },\n    { name: 'counter-decrease' }\n  ]\n};\n\nasync function runtime() {\n  const children = [];\n  for (const m of layout.materials) {\n    const Module = await import(`/demos/esm/material/${m.name}.js`);\n    children.push(h(Module?.default || Module));\n  }\n  const App = h('div', {}, children);\n  const app = createApp({\n    render() {\n      return h(App, {});\n    }\n  });\n  app.mount('#app');\n}\n\nruntime();\n</code></pre><p>代码中，我们在index.html文件里用了importmap的特性，方便ESM里直接用 import vue的方式来调用；在index.js用import()，也就是ESM的异步调用模块方法，获取依赖的物料组件。最终基于Vue.js的非编译模式的语法，我们成功把两个组件组装一起渲染。</p><h3>2. AMD模块化方案</h3><p>AMD，全称是Asynchronous Module Definition，“异步模块定义”，是一种面向浏览器运行的模块化方案。</p><p>AMD在ES6还没出现之前，是ES5环境下常见用的模块化方案。这里提到的“异步模块”，是指按模块的依赖来异步加载AMD模块，等待依赖模块异步加载完，就开始执行主体代码。全程的运行时执行过程，都是基于ES5的语法能力来实现的。但是，AMD只是一种技术方案，也就是规范，具体技术实现需要根据规范，实现其运行时。目前主流的AMD技术框架有RequireJS。</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/1a/f01011e7aaec82203f166c84e4889c1a.jpg?wh=1920x1450\" alt=\"图片\"></p><p>看一个代码案例，基于RequireJS用AMD规范来组装物料，渲染一个Vue.js应用。</p><p>代码的目录。</p><pre><code class=\"language-shell\">. # packages/mock-cdn/demos/amd/ \n├── index.html\n├── index.js\n└── material\n&nbsp; &nbsp; ├── counter-decrease.js\n&nbsp; &nbsp; └── counter-increase.js\n</code></pre><p>两个AMD模块格式的物料组件 counter-decrease.js 和 counter-increase.js。</p><pre><code class=\"language-typescript\">// packages/mock-cdn/demos/amd/material/counter-decrease.js\ndefine('counter-decrease', ['vue'], function (Vue) {\n  const { h, ref, toDisplayString } = Vue;\n  const Counter = {\n    setup() {\n      const num = ref(0);\n      const click = () =&gt; {\n        num.value -= 1;\n      };\n      return () =&gt; {\n        return h('div', { class: 'v-counter' }, [\n          h('div', { class: 'v-text' }, toDisplayString(num.value)),\n          h(\n            'button',\n            {\n              class: 'v-btn',\n              onClick: click\n            },\n            '点击减1'\n          )\n        ]);\n      };\n    }\n  };\n  return Counter;\n});\n</code></pre><pre><code class=\"language-typescript\">// packages/mock-cdn/demos/amd/material/counter-increase.js\ndefine('counter-increase', ['vue'], function (Vue) {\n  const { h, ref, toDisplayString } = Vue;\n  const Counter = {\n    setup() {\n      const num = ref(0);\n      const click = () =&gt; {\n        num.value += 1;\n      };\n      return () =&gt; {\n        return h('div', { class: 'v-counter' }, [\n          h('div', { class: 'v-text' }, toDisplayString(num.value)),\n          h(\n            'button',\n            {\n              class: 'v-btn',\n              onClick: click\n            },\n            '点击加1'\n          )\n        ]);\n      };\n    }\n  };\n  return Counter;\n});\n</code></pre><p>AMD格式物料的组装和渲染。</p><pre><code class=\"language-xml\">&lt;!-- packages/mock-cdn/demos/amd/index.html --&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\" /&gt;\n    &lt;script src=\"/public/pkg/requirejs/2.3.6/require.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/public/pkg/vue/3.2.45/dist/vue.runtime.global.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;页面加载中...&lt;/div&gt;\n    &lt;script src=\"./index.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><pre><code class=\"language-typescript\">// packages/mock-cdn/demos/amd/index.js\nconst layout = {\n  materials: [\n    { name: 'counter-increase'  },\n    { name: 'counter-decrease' }\n  ]\n};\n\nwindow.requirejs.config({\n  baseUrl: '/demos/amd/material/',\n  paths: {}\n});\n\nwindow.define('vue', [], function () {\n  return window.Vue;\n});\n\nfunction runtime() {\n  window.require(\n    ['vue', 'require', ...layout.materials.map((m) =&gt; m.name)],\n    function (Vue, require) {\n      const { createApp, h } = Vue;\n      const children = [];\n      for (const m of layout.materials) {\n        const Module = require(m.name);\n        children.push(h(Module?.default || Module));\n      }\n      const App = h('div', {}, children);\n      const app = createApp({\n        render() {\n          return h(App, {});\n        }\n      });\n      app.mount('#app');\n    }\n  );\n}\n\nruntime();\n</code></pre><p>从上面代码中，你可以看到AMD模块的运行依赖了RequireJS的运行，RequireJS提供一个define的全局方法，给开发者用来定义模块。</p><p>这里的RequireJS，是一种AMD模块化规范的代码实现，看定义过程。</p><pre><code class=\"language-typescript\">define('模块id', [\n // 模块依赖id\n], function( /*模块依赖的获取*/ ) {\n  // 模块主体代码\n})\n</code></pre><p>RequireJS通过解析依赖，来异步加载所有的依赖的AMD模块，等待依赖加载完后，就执行模块主体代码。</p><h3>3. IIFE模块化方案</h3><p>IIFE，全称是Immediately Invoked Function Expression，“立即执行函数”的意思。如果要实现模块化，就需要在IIFE中，把代码挂载在全局变量上。</p><p>这也是早期JavaScript的模块化方案，根据不同环境，把模块全部挂载在对应环境的全局变量上，浏览器就挂载在“window”对象上，Node.js就挂载在global全局变量上。</p><p><img src=\"https://static001.geekbang.org/resource/image/31/d1/318bc1393a3401a9c83d405f349333d1.jpg?wh=1920x1398\" alt=\"图片\"></p><p>关于IIFE全局变量模块化方案的代码案例，我们就不多讲了，非常简单，具体你可以参考代码案例所在目录（packages/mock-cdn/demos/iife/）。</p><h3>4. CJS模块化方案</h3><p>CJS，全称是CommonJS模块化规范，目前用的比较广泛是在Node.js环境里，因为Node.js刚诞生的时候，模块化方案是基于CommonJS规范来实现的，而且，CJS规范也是在ES6草案确定之前诞生的、兼容ES5的环境。</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/40/f7c62dce3e186255d8ed29fc95f3c440.jpg?wh=1920x1385\" alt=\"图片\"></p><p>CJS比较适合在Node.js环境中使用，在Node.js服务端中拼接物料产物，在服务端组装成页面的HTML。</p><p>今天我们主要讲物料产物的编译和前端浏览器里物料运行，关于Node.js服务端物料产物组装，不多讲，后面会专门分析搭建平台的物料SSR渲染。</p><p>前端组件的四种常见模块化方案我们就都了解了，每个模块化方案都有优缺点和适用场景，可以根据不同场景，选择对应的模块化方案。</p><p>我们日常开发Vue.js组件都是TypeScript语法来开发的，那么如何编译成多种模块化格式呢？</p><h2>Vue.js组件如何编译成多种模块？</h2><p>目前主流的构建工具，比如Webpack、Rollup和Vite，都可以基于其插件体系，来把TypeScript的Vue.js组件编译成多种模块化格式文件。既然都可以渲染，我们就优先选用Vue.js官方标配的构建工具Vite，进行多种模块化编译。</p><p>目前，Vite默认支持ESM、AMD、IIFE和CJS。那么Vite如何实现AMD模块编译呢？</p><p>其实Vite底层生产模式是基于Rollup来进行编译的，我们可以强行传入AMD的配置来执行编译。看具体配置代码。</p><pre><code class=\"language-typescript\">// scripts/build-materials.ts\nimport { build } from 'vite';\nimport pluginVue from '@vitejs/plugin-vue';\nimport pluginVueJsx from '@vitejs/plugin-vue-jsx';\nimport { resolvePackagePath, readFile } from './util';\nimport type { InlineConfig } from 'vite';\n\nfunction getBuildConfig(opts: {\n  name: string;\n  version: string;\n  dirName: string;\n  libName: string;\n}): InlineConfig {\n  const { dirName, libName } = opts;\n  const config: InlineConfig = {\n    plugins: [pluginVue(), pluginVueJsx()],\n    build: {\n      target: 'esnext',\n      minify: false,\n      emptyOutDir: true,\n      outDir: resolvePackagePath(dirName, 'dist'),\n      lib: {\n        name: libName,\n        entry: resolvePackagePath(dirName, 'src', 'index.ts'),\n        formats: ['es', 'cjs', 'iife'],\n        fileName: (format) =&gt; {\n          if (format === 'es') {\n            format = 'esm';\n          }\n          return `index.${format}.js`;\n        }\n      },\n      rollupOptions: {\n        preserveEntrySignatures: 'strict',\n        external: ['vue', '@vue/components'],\n        output: {\n          globals: {\n            vue: 'Vue',\n            '@vue/components': 'MyVueComponents'\n          },\n          assetFileNames: 'index[extname]'\n        }\n      }\n    }\n  };\n  return config;\n}\n\nfunction getBuildAMDConfig(opts: {\n  name: string;\n  version: string;\n  dirName: string;\n  libName: string;\n}): InlineConfig {\n  const { dirName, name, libName } = opts;\n  const config: InlineConfig = {\n    plugins: [pluginVue(), pluginVueJsx()],\n    build: {\n      // target: 'esnext',\n      minify: false,\n      emptyOutDir: false,\n      outDir: resolvePackagePath(dirName, 'dist'),\n      lib: {\n        name: libName,\n        entry: resolvePackagePath(dirName, 'src', 'index.ts'),\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        formats: ['amd'],\n        fileName: () =&gt; {\n          return 'index.amd.js';\n        }\n      },\n      rollupOptions: {\n        preserveEntrySignatures: 'strict',\n        external: ['vue', '@vue/components'],\n        output: {\n          name: name,\n          format: 'amd',\n          amd: {\n            id: name\n          },\n          globals: {\n            vue: 'vue',\n            '@vue/components': '@vue/components'\n          },\n          assetFileNames: 'index.amd[extname]'\n        }\n      }\n    }\n  };\n  return config;\n}\n\nasync function main() {\n  console.log('执行物料编译...');\n  const materialList = [\n    {\n      name: require('../packages/material-product-list/package.json').name,\n      version: require('../packages/material-product-list/package.json')\n        .version,\n      dirName: 'material-product-list',\n      libName: 'MyMaterialProdcutList'\n    },\n    {\n      name: require('../packages/material-banner-slides/package.json').name,\n      version: require('../packages/material-banner-slides/package.json')\n        .version,\n      dirName: 'material-banner-slides',\n      libName: 'MyMaterialBannerSlides'\n    }\n  ];\n  for (const opts of materialList) {\n    console.log(`开始编译物料 ${opts.dirName}`);\n    const config = getBuildConfig(opts);\n    const configAMD = getBuildAMDConfig(opts);\n    await build(config);\n    await build(configAMD);\n  }\n}\n\nmain();\n\n</code></pre><p>在Vite编译代码中，我用一个Vite配置编译出ESM、CJS和IIFE的模块化格式代码，用另一个独立的Vite配置编译AMD模块代码。如果以后Vite不支持强行编译AMD的方式，我们可以独立用Rollup来进行编译。</p><p>在今天案例的&nbsp;scripts/build-materials.ts 文件里，我就用一个Vite 编译脚本，编译了案例的两个物料组件，形成多种模块化格式，具体你可以课后看案例代码实现。</p><p>现在我们编译出了多种模块格式，在搭建平台项目中，如何实现物料产物的管理和运行呢？</p><h2>如何管理和运行各种模块化的物料组件？</h2><p>既然我们实现了物料，也就是Vue.js组件各种模块化格式的编译产物。接下来对产物的管理和运行，主要有四步。</p><ul>\n<li>第一步，把物料的Vue.js组件编译多种模块化格式。</li>\n<li>第二步，把各种模块化文件发布到私有NPM站点或者CDN服务。</li>\n<li>第三步，前台和后台服务各自读取CDN上的物料，进行拼接页面。</li>\n<li>第四步，实现各种模块化代码执行的运行时。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/b9/11/b9f3ca16a6473e31fbf486a53a0b8111.jpg?wh=1920x1033\" alt=\"图片\"></p><p>我们逐步分析。</p><p>第一步，编译Vue.js组件，需要你根据自己企业的技术基建做选择，我为了演示方便，就在课程代码案例的monorepo仓库中，管理了两个物料组件material-banner-slides和material-product-list，然后进行Vite的构建编译。</p><p>第二步，把各种模块化文件发布到CDN上。如果你自己企业内部有私有NPM站点，就发布到私有NPM站点，如果有CDN服务，就发布到CDN服务上。某种意义上讲，NPM也是一种CDN服务。</p><p>这里你需要注意，<strong>每次发布物料模块文件，都需要修改组件的版本</strong>，因为每次生产的物料文件都是不会被覆盖的，会随着版本增加，方便后续物料出问题后可以进行快速回滚处理。</p><p>在课程的代码案例里，为了演示方便，我在monorepo项目中用一个子项目mock-cdn，模拟了一个CDN来存储公共物料。之后我把两个物料发布到monorepo的“模拟CDN” 中。</p><p>第三步，前台和后台服务，根据自己所需要用到的物料产物，各自读取CDN上的物料，方便后续浏览器获取对应服务的物料产物。课程的代码案例，我就从mock-cdn这个模拟CDN来获取公共物料文件。</p><p>第四步，实现各种模块化代码执行的运行时，根据页面的配置文件，也就是页面用了哪些物料，进行拼接渲染页面。</p><p>我在课程的代码案例中，基于前台场景，在浏览器中，实现了ESM模块化的运行时、AMD模块化运行时和IIFE模块化运行时。先定义了公用的页面物料配置数据。</p><pre><code class=\"language-typescript\">// packages/portal-front/src/demos/util.ts\nexport interface LayoutConfig {\n  materials: Array&lt;{\n    name: string;\n    globalName: string;\n    version: string;\n    props: Record&lt;string, any&gt;;\n  }&gt;;\n}\n\nexport const layout: LayoutConfig = {\n  materials: [\n    {\n      name: '@my/material-banner-slides',\n      version: '0.1.0',\n      globalName: 'MyMaterialBannerSlides',\n      props: {\n        style: { height: 100 }\n      }\n    },\n    {\n      name: '@my/material-product-list',\n      version: '0.1.0',\n      globalName: 'MyMaterialProdcutList',\n      props: {}\n    }\n  ]\n};\n</code></pre><p>然后实现了一些公共工具方法和公用配置。</p><pre><code class=\"language-typescript\">// packages/portal-front/src/demos/util.ts\nexport const CDN_BASE_URL = '/public/cdn/';\n\nexport async function loadMaterialStyle(params: {\n  name: string;\n  version: string;\n}) {\n  const { name, version } = params;\n  const materialId = `${name}/${version}`;\n  if (\n    document.querySelectorAll(`style[data-material-id=\"${materialId}\"]`)\n      ?.length &gt; 0\n  ) {\n    return;\n  }\n  const url = `${CDN_BASE_URL}/material/${name}/${version}/index.css`;\n  const text = await fetch(url).then((res) =&gt; res.text());\n  const style = document.createElement('style');\n  style.setAttribute('data-material-id', materialId);\n  style.innerHTML = text;\n  const head =\n    document.querySelector('head') ||\n    document.querySelector('body') ||\n    document.querySelector('html');\n\n  head?.appendChild(style);\n}\n\nexport function loadScript(url: string): Promise&lt;void&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    const script = document.createElement('script');\n    script.src = url;\n    document.body.appendChild(script);\n    script.onload = () =&gt; {\n      resolve();\n    };\n    script.onerror = () =&gt; {\n      reject();\n    };\n  });\n}\n\nexport async function render(opts: {\n  Vue: any;\n  moduleMap: { [id: string]: any | { default: any } };\n  layout: LayoutConfig;\n}) {\n  const { moduleMap, layout, Vue } = opts;\n  const { h, createApp } = Vue;\n  const children = layout.materials.map((item: any) =&gt; {\n    return h(\n      moduleMap[item.name]?.default || moduleMap[item.name],\n      item?.props || {}\n    );\n  });\n  const App = {\n    setup() {\n      return () =&gt; {\n        return h('div', {}, children);\n      };\n    }\n  };\n\n  const app = createApp({\n    render() {\n      return h(App, {});\n    }\n  });\n  app.mount('#app');\n}\n\n</code></pre><p>最后实现ESM、AMD和IIFE三种模块格式在浏览器的运行时。</p><p>ESM物料组装运行时。</p><pre><code class=\"language-typescript\">import { CDN_BASE_URL, render, loadMaterialStyle, layout } from '../util';\n\nasync function loadMaterialESModule(params: { name: string; version: string }) {\n  const { name, version } = params;\n  return import(\n    /* @vite-ignore */\n    `${CDN_BASE_URL}material/${name}/${version}/index.esm.js`\n  );\n}\n\nasync function loadESModule(name: string) {\n  return import(\n    /* @vite-ignore */\n    `${name}`\n  );\n}\n\nasync function runtime() {\n  const moduleMap: any = {};\n  for (const item of layout.materials) {\n    const { name, version } = item;\n    const Module = await loadMaterialESModule({\n      name,\n      version\n    });\n    await loadMaterialStyle({ name, version });\n    moduleMap[name] = Module;\n  }\n  const Vue: any = await loadESModule('vue');\n  await render({ Vue, moduleMap, layout });\n}\n\nruntime();\n</code></pre><p>AMD物料组装运行时。</p><pre><code class=\"language-typescript\">import { CDN_BASE_URL, render, loadMaterialStyle, layout } from '../util';\n\nasync function runtime() {\n  const paths: Record&lt;string, string&gt; = {};\n  layout.materials.forEach((m) =&gt; {\n    paths[m.name] = `material/${m.name}/${m.version}/index.amd`;\n  });\n \n  window.requirejs.config({\n    baseUrl: CDN_BASE_URL,\n    paths\n  });\n \n  window.require(\n    ['vue', 'require', ...layout.materials.map((m) =&gt; m.name)],\n    (Vue: any, require: any) =&gt; {\n      const moduleMap: any = {};\n      for (const m of layout.materials) {\n        const { name, version } = m;\n        loadMaterialStyle({ name, version });\n        moduleMap[name] = require(name);\n      }\n      render({ Vue, moduleMap, layout });\n    }\n  );\n}\n\nruntime();\n</code></pre><p>这里要注意一点，<strong>AMD运行时需要依赖RequireJS，来实现AMD模块的加载和运行</strong>。</p><p>IIFE物料组装运行时。</p><pre><code class=\"language-typescript\">import {\n  CDN_BASE_URL,\n  render,\n  loadMaterialStyle,\n  layout,\n  loadScript\n} from '../util';\n\nasync function runtime() {\n  const moduleMap: any = {};\n  for (const item of layout.materials) {\n    const { name, version, globalName } = item;\n    await loadScript(\n      `${CDN_BASE_URL}/material/${name}/${version}/index.iife.js`\n    );\n    await loadMaterialStyle({ name, version });\n    moduleMap[name] = window[globalName] as any;\n  }\n\n  const Vue: any = window.Vue;\n  await render({ Vue, moduleMap, layout });\n}\n\nruntime();\n\n</code></pre><p>在所有组装物料的运行时代码中，你要注意，<strong>我们需要在运行时中，用JavaScript来手动加载CSS文件</strong>。这个CSS是没有模块化区分的，面向所有模块化格式，都是通用的。</p><p>代码中最终组装物料的效果图。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/ec/c1cd75cb16447df0d57e5234fae5edec.png?wh=1920x1385\" alt=\"图片\"></p><h2>总结</h2><p>今天我们学习了前端组件的模块化和运营搭建平台物料的产物管理，也就是Vue.js组件的模块化管理，为后面物料搭建页面打好基础。</p><p>总结一下不同模块格式的优缺点。</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/40/f7c62dce3e186255d8ed29fc95f3c440.jpg?wh=1920x1385\" alt=\"图片\"></p><p>如果现在需要你做个终极选择，我们平台项目中要选择哪种模块方式呢？</p><p>答案是全都要。因为浏览器端把握在用户手里，我们无法预测实际代码在运行过程中会出现什么兼容问题，如果平台渲染能支持多重模块格式，就意味着可以做一些优化策略，在低版本浏览器中，就可以优先选择对应能支持的模块格式。</p><p>在实现运营搭建平台的物料产物管理时，有两点要注意：</p><ul>\n<li>平台不是独立的一个工程，你需要根据自身企业技术基建，进行工程能力整合，例如对企业内部的CDN服务或者NPM私有服务的对接。</li>\n<li>物料产物需要版本化管理，也就是Vue.js组件每次迭代编译，都需要发布一个新版本，方便出问题后快速回滚线上代码。</li>\n</ul><h2>思考题</h2><p>前台场景运行页面时，通过ESM或者AMD格式进行异步加载物料的代码文件，如果页面依赖的物料变多了，物料文件请求也会变多，这会影响页面打开时间吗？有什么办法可以提高页面打开时间吗？</p><p>欢迎留言参与讨论，我们下节课再见。</p><h3><a href=\"https://github.com/FE-star/vue3-course/tree/main/chapter/18\">完整的</a><a href=\"https://github.com/FE-star/vue3-course/tree/main/chapter/22\">代码在这里</a></h3>","comments":[{"had_liked":false,"id":370359,"user_name":"娘娘驾到***皇上跪下","can_delete":false,"product_type":"c1","uid":3228146,"ip_address":"浙江","ucode":"F1D195163AD9BC","user_header":"https://static001.geekbang.org/account/avatar/00/31/41/f2/32934b5a.jpg","comment_is_top":false,"comment_ctime":1678757090,"is_pvip":false,"replies":[{"id":135254,"content":"您好，这是基于pnpm来管理整个monorepo项目，先配置pnpm-workspace.yaml，然后用pnpm在项目根目录安装依赖，会有“软件链”对子项目间的依赖进行内部模块的引用。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1679123194,"ip_address":"浙江","comment_id":370359,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"老师提个问题：这个@my&#47;component是怎么被作为依赖安装到node_modules下的，package下子应用之间的相互引用么？这个具体看哪一块？","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609694,"discussion_content":"您好，这是基于pnpm来管理整个monorepo项目，先配置pnpm-workspace.yaml，然后用pnpm在项目根目录安装依赖，会有“软件链”对子项目间的依赖进行内部模块的引用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679123194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394523,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1727068802,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100311101,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":393825,"user_name":"前端WLOP","can_delete":false,"product_type":"c1","uid":1800417,"ip_address":"上海","ucode":"23258059979352","user_header":"https://static001.geekbang.org/account/avatar/00/1b/78/e1/c6a3f7d0.jpg","comment_is_top":false,"comment_ctime":1725001715,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"ESM的import不支持路径的动态导入啊\n\nconst Module = await import(`&#47;demos&#47;esm&#47;material&#47;${m.name}.js`)","like_count":0},{"had_liked":false,"id":368841,"user_name":"Akili","can_delete":false,"product_type":"c1","uid":1388437,"ip_address":"云南","ucode":"286D58069F7D86","user_header":"https://static001.geekbang.org/account/avatar/00/15/2f/95/db8dedde.jpg","comment_is_top":false,"comment_ctime":1676795211,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"学习了。","like_count":0}]}