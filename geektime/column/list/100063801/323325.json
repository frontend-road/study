{"id":323325,"title":"16 | 容器网络配置（1）：容器网络不通了要怎么调试?","content":"<p>你好，我是程远。</p><p>在上一讲，我们讲了Network Namespace隔离了网络设备，IP协议栈和路由表，以及防火墙规则，那容器Network Namespace里的参数怎么去配置，我们现在已经很清楚了。</p><p>其实对于网络配置的问题，我们还有一个最需要关心的内容，那就是容器和外面的容器或者节点是怎么通讯的，这就涉及到了容器网络接口配置的问题了。</p><p>所以这一讲呢，我们就来聊一聊，容器Network Namespace里如何配置网络接口，还有当容器网络不通的时候，我们应该怎么去做一个简单调试。</p><h2>问题再现</h2><p>在前面的课程里，我们一直是用 <code>docker run</code> 这个命令来启动容器的。容器启动了之后，我们也可以看到，在容器里面有一个\"eth0\"的网络接口，接口上也配置了一个IP地址。</p><p>不过呢，如果我们想从容器里访问外面的一个IP地址，比如说39.106.233.176（这个是极客时间网址对应的IP），结果就发现是不能ping通的。</p><p>这时我们可能会想到，到底是不是容器内出了问题，在容器里无法访问，会不会宿主机也一样不行呢？</p><p>所以我们需要验证一下，首先我们退出容器，然后在宿主机的Network Namespace下，再运行 <code>ping 39.106.233.176</code>，结果就会发现在宿主机上，却是可以连通这个地址的。</p><!-- [[[read_end]]] --><pre><code class=\"language-shell\"># docker run -d --name if-test centos:8.1.1911 sleep 36000\n244d44f94dc2931626194c6fd3f99cec7b7c4bf61aafc6c702551e2c5ca2a371\n# docker exec -it if-test bash\n \n[root@244d44f94dc2 /]# ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n808: eth0@if809: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default\n    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n \n[root@244d44f94dc2 /]# ping 39.106.233.176       ### 容器中无法ping通\nPING 39.106.233.176 (39.106.233.176) 56(84) bytes of data.\n^C\n--- 39.106.233.176 ping statistics ---\n9 packets transmitted, 0 received, 100% packet loss, time 185ms\n \n[root@244d44f94dc2 /]# exit             ###退出容器\nexit\n \n# ping 39.106.233.176                        ### 宿主机上可以ping通\nPING 39.106.233.176 (39.106.233.176) 56(84) bytes of data.\n64 bytes from 39.106.233.176: icmp_seq=1 ttl=78 time=296 ms\n64 bytes from 39.106.233.176: icmp_seq=2 ttl=78 time=306 ms\n64 bytes from 39.106.233.176: icmp_seq=3 ttl=78 time=303 ms\n^C\n--- 39.106.233.176 ping statistics ---\n4 packets transmitted, 3 received, 25% packet loss, time 7ms\nrtt min/avg/max/mdev = 296.059/301.449/305.580/4.037 ms\n</code></pre><p>那么碰到这种容器内网络不通的问题，我们应该怎么分析调试呢？我们还是需要先来理解一下，容器Network Namespace里的网络接口是怎么配置的。</p><h2>基本概念</h2><p>在讲解容器的网络接口配置之前，我们需要先建立一个整体的认识，搞清楚容器网络接口在系统架构中处于哪个位置。</p><p>你可以看一下我给你画的这张图，图里展示的是容器有自己的Network Namespace，eth0 是这个Network Namespace里的网络接口。而宿主机上也有自己的eth0，宿主机上的eth0对应着真正的物理网卡，可以和外面通讯。</p><p><img src=\"https://static001.geekbang.org/resource/image/68/98/6848619c9d4db810560fe1a712fb2d98.jpeg?wh=1920*1408\" alt=\"\"></p><p>那你可以先想想，我们要让容器Network Namespace中的数据包最终发送到物理网卡上，需要完成哪些步骤呢？从图上看，我们大致可以知道应该包括这两步。</p><p><strong>第一步，就是要让数据包从容器的Network Namespace发送到Host Network Namespace上。</strong></p><p><strong>第二步，数据包发到了Host Network Namespace之后，还要解决数据包怎么从宿主机上的eth0发送出去的问题。</strong></p><p>好，整体的思路已经理清楚了，接下来我们做具体分析。我们先来看第一步，怎么让数据包从容器的Network Namespace发送到Host Network Namespace上面。</p><p>你可以查看一下<a href=\"https://docs.docker.com/network/\">Docker 网络的文档</a>或者<a href=\"https://kubernetes.io/docs/concepts/cluster-administration/networking/\">Kubernetes网络的文档</a>，这些文档里面介绍了很多种容器网络配置的方式。</p><p>不过对于容器从自己的Network Namespace连接到Host Network Namespace的方法，一般来说就只有两类设备接口：一类是<a href=\"https://man7.org/linux/man-pages/man4/veth.4.html\">veth</a>，另外一类是macvlan/ipvlan。</p><p>在这些方法中，我们使用最多的就是veth的方式，用Docker启动的容器缺省的网络接口用的也是这个veth。既然它这么常见，所以我们就用veth作为例子来详细讲解。至于另外一类macvlan/ipvlan的方式，我们在下一讲里会讲到。</p><p>那什么是veth呢？为了方便你更好地理解，我们先来模拟一下Docker为容器建立eth0网络接口的过程，动手操作一下，这样呢，你就可以很快明白什么是veth了。</p><p>对于这个模拟操作呢，我们主要用到的是<a href=\"https://man7.org/linux/man-pages/man8/ip-netns.8.html\">ip netns</a> 这个命令，通过它来对Network Namespace做操作。</p><p>首先，我们先启动一个不带网络配置的容器，和我们之前的命令比较，主要是多加上了\"--network none\"参数。我们可以看到，这样在启动的容器中，Network Namespace里就只有loopback一个网络设备，而没有了eth0网络设备了。</p><pre><code class=\"language-shell\"># docker run -d --name if-test --network none centos:8.1.1911 sleep 36000\ncf3d3105b11512658a025f5b401a09c888ed3495205f31e0a0d78a2036729472\n# docker exec -it if-test ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n</code></pre><p>完成刚才的设置以后，我们就在这个容器的Network Namespace里建立veth，你可以执行一下后面的这个脚本。</p><pre><code class=\"language-shell\">pid=$(ps -ef | grep \"sleep 36000\" | grep -v grep | awk '{print $2}')\necho $pid\nln -s /proc/$pid/ns/net /var/run/netns/$pid\n \n# Create a pair of veth interfaces\nip link add name veth_host type veth peer name veth_container\n# Put one of them in the new net ns\nip link set veth_container netns $pid\n \n# In the container, setup veth_container\nip netns exec $pid ip link set veth_container name eth0\nip netns exec $pid ip addr add 172.17.1.2/16 dev eth0\nip netns exec $pid ip link set eth0 up\nip netns exec $pid ip route add default via 172.17.0.1\n \n# In the host, set veth_host up\nip link set veth_host up\n</code></pre><p>我在这里解释一下，这个veth的建立过程是什么样的。</p><p>首先呢，我们先找到这个容器里运行的进程\"sleep 36000\"的pid，通过 \"/proc/$pid/ns/net\"这个文件得到Network Namespace的ID，这个Network Namespace ID既是这个进程的，也同时属于这个容器。</p><p>然后我们在\"/var/run/netns/\"的目录下建立一个符号链接，指向这个容器的Network Namespace。完成这步操作之后，在后面的\"ip netns\"操作里，就可以用pid的值作为这个容器的Network Namesapce的标识了。</p><p>接下来呢，我们用 <code>ip link</code> 命令来建立一对veth的虚拟设备接口，分别是veth_container和veth_host。从名字就可以看出来，veth_container这个接口会被放在容器Network Namespace里，而veth_host会放在宿主机的Host Network Namespace。</p><p>所以我们后面的命令也很好理解了，就是用 <code>ip link set veth_container netns $pid</code> 把veth_container这个接口放入到容器的Network Namespace中。</p><p>再然后我们要把veth_container重新命名为eth0，因为这时候接口已经在容器的Network Namesapce里了，eth0就不会和宿主机上的eth0冲突了。</p><p>最后对容器内的eht0，我们还要做基本的网络IP和缺省路由配置。因为veth_host已经在宿主机的Host Network Namespace了，就不需要我们做什么了，这时我们只需要up一下这个接口就可以了。</p><p>那刚才这些操作完成以后，我们就建立了一对veth虚拟设备接口。我给你画了一张示意图，图里直观展示了这对接口在容器和宿主机上的位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/56/89/569287c365c99d3778858b7bc42b5989.jpeg?wh=1920*1339\" alt=\"\"></p><p>现在，我们再来看看veth的定义了，其实它也很简单。veth就是一个虚拟的网络设备，一般都是成对创建，而且这对设备是相互连接的。当每个设备在不同的Network Namespaces的时候，Namespace之间就可以用这对veth设备来进行网络通讯了。</p><p>比如说，你可以执行下面的这段代码，试试在veth_host上加上一个IP，172.17.1.1/16，然后从容器里就可以ping通这个IP了。这也证明了从容器到宿主机可以利用这对veth接口来通讯了。</p><pre><code class=\"language-shell\"># ip addr add 172.17.1.1/16 dev veth_host\n# docker exec -it if-test ping 172.17.1.1\nPING 172.17.1.1 (172.17.1.1) 56(84) bytes of data.\n64 bytes from 172.17.1.1: icmp_seq=1 ttl=64 time=0.073 ms\n64 bytes from 172.17.1.1: icmp_seq=2 ttl=64 time=0.092 ms\n^C\n--- 172.17.1.1 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 30ms\nrtt min/avg/max/mdev = 0.073/0.082/0.092/0.013 ms\n</code></pre><p>好了，这样我们完成了第一步，通过一对veth虚拟设备，可以让数据包从容器的 Network Namespace发送到Host Network Namespace上。</p><p>那下面我们再来看第二步， 数据包到了Host Network Namespace之后呢，怎么把它从宿主机上的eth0发送出去?</p><p>其实这一步呢，就是一个普通Linux节点上数据包转发的问题了。这里我们解决问题的方法有很多种，比如说用nat来做个转发，或者建立Overlay网络发送，也可以通过配置proxy arp加路由的方法来实现。</p><p>因为考虑到网络环境的配置，同时Docker缺省使用的是 <strong>bridge + nat</strong>的转发方式， 那我们就在刚才讲的第一步基础上，再手动实现一下bridge+nat的转发方式。对于其他的配置方法，你可以看一下Docker或者Kubernetes相关的文档。</p><p>Docker程序在节点上安装完之后，就会自动建立了一个docker0的bridge interface。所以我们只需要把第一步中建立的veth_host这个设备，接入到docker0这个bridge上。</p><p>这里我要提醒你注意一下，如果之前你在veth_host上设置了IP的，就需先运行一下\"ip addr delete 172.17.1.1/16 dev veth_host\"，把IP从veth_host上删除。</p><pre><code># ip addr delete 172.17.1.1/16 dev veth_host \nip link set veth_host master docker0\n</code></pre><p>这个命令执行完之后，容器和宿主机的网络配置就会发生变化，这种配置是什么样呢？你可以参考一下面这张图的描述。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/69/a006f0707d02d38917983523c9356869.jpeg?wh=1920*1331\" alt=\"\"></p><p>从这张示意图中，我们可以看出来，容器和docker0组成了一个子网，docker0上的IP就是这个子网的网关IP。</p><p>如果我们要让子网通过宿主机上eth0去访问外网的话，那么加上iptables的规则就可以了，也就是下面这条规则。</p><pre><code>iptables -P FORWARD ACCEPT\n</code></pre><p>好了，进行到这里，我们通过bridge+nat的配置，似乎已经完成了第二步——让数据从宿主机的eth0发送出去。</p><p>那么我们这样配置，真的可以让容器里发送数据包到外网了吗？这需要我们做个测试，再重新尝试下这一讲开始的操作，从容器里ping外网的IP，这时候，你会发现还是ping不通。</p><p>其实呢，做到这一步，我们通过自己的逐步操作呢，重现了这一讲了最开始的问题。</p><h2>解决问题</h2><p>既然现在我们清楚了，在这个节点上容器和宿主机上的网络配置是怎么一回事。那么要调试这个问题呢，也有了思路，关键就是找到数据包传到哪个环节时发生了中断。</p><p>那最直接的方法呢，就是在容器中继续ping外网的IP 39.106.233.176，然后在容器的eth0 (veth_container)，容器外的veth_host，docker0，宿主机的eth0这一条数据包的路径上运行tcpdump。</p><p>这样就可以查到，到底在哪个设备接口上没有收到ping的icmp包。我把tcpdump运行的结果我列到了下面。</p><p>容器的eth0：</p><pre><code class=\"language-shell\"># ip netns exec $pid tcpdump -i eth0 host 39.106.233.176 -nn\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes\n00:47:29.934294 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 1, length 64\n00:47:30.934766 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 2, length 64\n00:47:31.958875 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 3, length 64\n</code></pre><p>veth_host：</p><pre><code class=\"language-shell\"># tcpdump -i veth_host host 39.106.233.176 -nn\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on veth_host, link-type EN10MB (Ethernet), capture size 262144 bytes\n00:48:01.654720 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 32, length 64\n00:48:02.678752 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 33, length 64\n00:48:03.702827 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 34, length 64\n</code></pre><p>docker0：</p><pre><code class=\"language-shell\"># tcpdump -i docker0 host 39.106.233.176 -nn\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on docker0, link-type EN10MB (Ethernet), capture size 262144 bytes\n00:48:20.086841 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 50, length 64\n00:48:21.110765 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 51, length 64\n00:48:22.134839 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 52, length 64\n</code></pre><p>host eth0：</p><pre><code class=\"language-shell\"># tcpdump -i eth0 host 39.106.233.176 -nn\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes\n^C\n0 packets captured\n0 packets received by filter\n0 packets dropped by kernel\n</code></pre><p>通过上面的输出结果，我们发现icmp包到达了docker0，但是没有到达宿主机上的eth0。</p><p>因为我们已经配置了iptables nat的转发，这个也可以通过查看iptables的nat表确认一下，是没有问题的，具体的操作命令如下：</p><pre><code class=\"language-shell\"># iptables -L  -t nat\nChain PREROUTING (policy ACCEPT)\ntarget     prot opt source               destination\nDOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL\n \nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination\n \nChain POSTROUTING (policy ACCEPT)\ntarget     prot opt source               destination\nMASQUERADE  all  --  172.17.0.0/16        anywhere\n \nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination\nDOCKER     all  --  anywhere            !127.0.0.0/8          ADDRTYPE match dst-type LOCAL\n \nChain DOCKER (2 references)\ntarget     prot opt source               destination\nRETURN     all  --  anywhere             anywhere\n</code></pre><p>那么会是什么问题呢？因为这里需要做两个网络设备接口之间的数据包转发，也就是从docker0把数据包转发到eth0上，你可能想到了Linux协议栈里的一个常用参数ip_forward。</p><p>我们可以看一下，它的值是0，当我们把它改成1之后，那么我们就可以从容器中ping通外网39.106.233.176这个IP了！</p><pre><code class=\"language-shell\"># cat /proc/sys/net/ipv4/ip_forward\n0\n# echo 1 &gt; /proc/sys/net/ipv4/ip_forward\n \n# docker exec -it if-test ping 39.106.233.176\nPING 39.106.233.176 (39.106.233.176) 56(84) bytes of data.\n64 bytes from 39.106.233.176: icmp_seq=1 ttl=77 time=359 ms\n64 bytes from 39.106.233.176: icmp_seq=2 ttl=77 time=346 ms\n^C\n--- 39.106.233.176 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1ms\nrtt min/avg/max/mdev = 345.889/352.482/359.075/6.593 ms\n</code></pre><h2>重点小结</h2><p>这一讲，我们主要解决的问题是如何给容器配置网络接口，让容器可以和外面通讯；同时我们还学习了当容器网络不通的时候，我们应该怎么来做一个简单调试。</p><p>解决容器与外界通讯的问题呢，一共需要完成两步。第一步是，怎么让数据包从容器的Network Namespace发送到Host Network Namespace上；第二步，数据包到了Host Network Namespace之后，还需要让它可以从宿主机的eth0发送出去。</p><p>我们想让数据从容器Netowrk Namespace发送到Host Network Namespace，可以用配置一对veth虚拟网络设备的方法实现。而让数据包从宿主机的eth0发送出去，就用可bridge+nat的方式完成。</p><p>这里我讲的是最基本的一种配置，但它也是很常用的一个网络配置。针对其他不同需要，容器网络还有很多种。那你学习完这一讲，了解了基本的概念和操作之后呢，还可以查看更多的网上资料，学习不同的网络配置。</p><p>遇到容器中网络不通的情况，我们先要理解自己的容器以及容器在宿主机上的配置，通过对主要设备上做tcpdump可以找到具体在哪一步数据包停止了转发。</p><p>然后我们结合内核网络配置参数，路由表信息，防火墙规则，一般都可以定位出根本原因，最终解决这种网络完全不通的问题。</p><p>但是如果是网络偶尔丢包的问题，这个就需要用到其他的一些工具来做分析了，这个我们会在之后的章节做讲解。</p><h2>思考题</h2><p>我们这一讲的例子呢，实现了从容器访问外面的IP。那么如果要实现节点外的程序来访问容器的IP，我们应该怎么配置网络呢？</p><p>欢迎你在留言区分享你的思考和问题。如果这篇文章对你有启发，也欢迎分享给你的朋友，一起学习进步。</p>","comments":[{"had_liked":false,"id":269052,"user_name":"良凯尔","can_delete":false,"product_type":"c1","uid":1806492,"ip_address":"","ucode":"8204DA338BA8F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/90/9c/288e4db2.jpg","comment_is_top":false,"comment_ctime":1608511428,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"96097791940","product_id":100063801,"comment_content":"实现节点外的程序来访问容器：<br><br>iptables -t nat -A PREROUTING -d 【宿主机ip】 -p tcp -m tcp --dport 【宿主机映射端口】 -j DNAT --to-destination 【容器ip】:【容器端口】<br><br>利用DNAT，访问宿主机ip+宿主机映射端口，即可访问容器<br>","like_count":21},{"had_liked":false,"id":271750,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1609776024,"is_pvip":false,"replies":[{"id":"98642","content":"@我来也<br>把调试工具都放到一个基础容器中也挺好的。<br>","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1609939922,"ip_address":"","comment_id":271750,"utype":1}],"discussion_count":4,"race_medal":0,"score":"40264481688","product_id":100063801,"comment_content":"老师一路tcpdump的操作很犀利，特别是抓容器中的数据包的那个操作：<br><br>  ip netns exec $pid tcpdump -i eth0 host 39.106.233.176 -nn<br><br>以前为了在容器中抓包，还要在容器中安装tcpdump，从国外的源拉数据又慢，即使换了国内的源，但每次重建容器后又得再来一次。<br>搞的我专门准备了一个调试用的基础容器，把各种常用的工具都给装上，包括我的vim。😄","like_count":10,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513032,"discussion_content":"@我来也\n把调试工具都放到一个基础容器中也挺好的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609939922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2314854,"avatar":"https://static001.geekbang.org/account/avatar/00/23/52/66/3e4d4846.jpg","nickname":"includestdio.h","note":"","ucode":"5027BACE9319CD","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576218,"discussion_content":"k8s场景下可以插入debug容器进行调试，这样基础镜像也不用变动了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1655358054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2314854,"avatar":"https://static001.geekbang.org/account/avatar/00/23/52/66/3e4d4846.jpg","nickname":"includestdio.h","note":"","ucode":"5027BACE9319CD","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":576311,"discussion_content":"嗯，好像是最近几个版本才加入的功能？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655426139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":576218,"ip_address":""},"score":576311,"extra":""}]},{"author":{"id":1262144,"avatar":"https://static001.geekbang.org/account/avatar/00/13/42/40/c7444091.jpg","nickname":"tofu","note":"","ucode":"93BFF835968A03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572376,"discussion_content":"还有这种思路 学到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652752536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277490,"user_name":"陈斯佳","can_delete":false,"product_type":"c1","uid":1259323,"ip_address":"","ucode":"C236F874FC767A","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/3b/495e2ce6.jpg","comment_is_top":false,"comment_ctime":1612429902,"is_pvip":false,"replies":[{"id":"100827","content":"@陈斯佳<br>是这样的！","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1612620761,"ip_address":"","comment_id":277490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23087266382","product_id":100063801,"comment_content":"这篇网络调试太硬核了！！一直觉得，容器就是Linux的高级知识，容器通了，Linux的内容你就所向披靡了","like_count":6,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515069,"discussion_content":"@陈斯佳\n是这样的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612620761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270239,"user_name":"争光 Alan","can_delete":false,"product_type":"c1","uid":1336328,"ip_address":"","ucode":"338534F909AF03","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/08/0287f41f.jpg","comment_is_top":false,"comment_ctime":1608999328,"is_pvip":false,"replies":[{"id":"98084","content":"&gt; 1<br>对的你可以理解为docker0是一个L2交换机。<br><br>&gt; 2<br>ip_forward就是打开Linux类似路由器的功能，允许数据包从一个接口进入，根据路由从另外一个接口出去。这个和你说的iptables里的postrouting&#47;forward链没有关系","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1609130252,"ip_address":"","comment_id":270239,"utype":1}],"discussion_count":4,"race_medal":0,"score":"23083835808","product_id":100063801,"comment_content":"你好，老师，我网络比较弱，看了文章有两个地方没看懂<br>1.docker0 和veth连接，是可以理解为docker0是个交换机，所有连接docker0的网卡可以二层通信？<br><br>2.为什么连接到docker0，开启forward就通了？能讲一下原理吗？ 是到达docker0的包会经过postrouting链，然后经过本地路由后，需要走forward链出去，所以需要开forward为accept并且开启forward吗？","like_count":6,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512566,"discussion_content":"&amp;gt; 1\n对的你可以理解为docker0是一个L2交换机。\n\n&amp;gt; 2\nip_forward就是打开Linux类似路由器的功能，允许数据包从一个接口进入，根据路由从另外一个接口出去。这个和你说的iptables里的postrouting/forward链没有关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609130252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/61/b1/1261c177.jpg","nickname":"胖胖虎","note":"","ucode":"9CA8F99CC82944","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337910,"discussion_content":"bridge本身是一个二层设备，不会参与到路由过程中。以Docker0为例，如果docker0仅仅是一个单纯的网桥，那么所有连接到docker0上面的veth相互之间是可以通讯的，但是他们的流量是无法到172.18.0.0/16网络之外的。如果想实现向外通讯其实有两种方法：\n1. 将主机物理网卡也加入到桥上来，实现二层交换。不过这样的话，由于veth都是172.18.0.0/16网段，这要求外面通讯的地址也是这个网段，有较大限制。\n2. 网桥docker0上其实有一个隐藏的虚拟网络设备，名字也是docker0。\n~$ ifconfig docker0\ndocker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500\n        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255\n        inet6 fe80::42:e7ff:fef2:61e1  prefixlen 64  scopeid 0x20<link>\n        ether 02:42:e7:f2:61:e1  txqueuelen 0  (Ethernet)\n        RX packets 300291  bytes 22659457 (22.6 MB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 452412  bytes 541108573 (541.1 MB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\n当docker0上设置了地址之后，它就成为了一个可以参与路由的网络接口节点。通过route -n可以看到：\n~$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         172.17.1.1      0.0.0.0         UG    0      0        0 ens160\n172.17.1.0      0.0.0.0         255.255.255.0   U     0      0        0 ens160\n172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n\n网桥设备的转发规则如下：\n1. 包目的MAC为Bridge本身MAC地址(当docker0设置有IP地址)，从MAC地址这一层来看，收到发往主机自身的数据包，交给上层协议栈\n2. 广播包，转发到Bridge上的所有接口(docker0,tap0,tap1,tap…)\n3. 单播&amp;&amp;存在于MAC端口映射表，查表直接转发到对应接口\n4. 单播&amp;&amp;不存在于MAC端口映射表，泛洪到Bridge连接的所有接口(docker0,tap0,tap1,tap…)\n5. 数据包目的地址接口不是网桥接口，桥不处理，交给上层协议栈\n\n有了这个网络接口以后，通过docker0通联的虚拟网卡的网络包就可以通过虚拟设备docker0参与到3层路由上了。\n当然，还是需要打开iptables中的转发规则：iptables -P FORWARD ACCEPT\n","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1609122724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/61/b1/1261c177.jpg","nickname":"胖胖虎","note":"","ucode":"9CA8F99CC82944","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337911,"discussion_content":"再往上层就是宿主机自己的路由和NAT设置了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609123153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2384580,"avatar":"https://static001.geekbang.org/account/avatar/00/24/62/c4/be92518b.jpg","nickname":"🐭","note":"","ucode":"E5CA01ACAEDFC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387154,"discussion_content":"为啥需要打开iptables转发么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628006715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269202,"user_name":"谢哈哈","can_delete":false,"product_type":"c1","uid":2326880,"ip_address":"","ucode":"5AADE70B5AFE27","user_header":"https://static001.geekbang.org/account/avatar/00/23/81/60/71ed6ac7.jpg","comment_is_top":false,"comment_ctime":1608555961,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14493457849","product_id":100063801,"comment_content":"1，宿主机上配置容器网段的路由<br>2，DNAT，在nat表的PREROUTING链做好包伪装到达容器","like_count":3,"discussions":[{"author":{"id":1138499,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5f/43/3799a0f3.jpg","nickname":"magina","note":"","ucode":"9546701896A09F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338675,"discussion_content":"docker run默认是挂在docker0网桥上的，ping外面接就是通的呀？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609336848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298537,"user_name":"kissingers","can_delete":false,"product_type":"c1","uid":1135299,"ip_address":"","ucode":"615151808CF628","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKzqiaZnBw2myRWY802u48Rw3W2zDtKoFQ6vN63m4FdyjibM21FfaOYe8MbMpemUdxXJeQH6fRdVbZA/132","comment_is_top":false,"comment_ctime":1624181080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5919148376","product_id":100063801,"comment_content":"如果eth0 也加到docker0 bridge，那么这个时候是通过二层转发或者洪泛的方式连通外网。如果eth0不加到docker0的话那么利用的是host 的路由转发了。这样理解对吗？","like_count":1},{"had_liked":false,"id":282501,"user_name":"Geek_c2089d","can_delete":false,"product_type":"c1","uid":1489545,"ip_address":"","ucode":"C66D345042525F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4Lprf2mIWpJOPibgibbFCicMtp5bpIibyLFOnyOhnBGbusrLZC0frG0FGWqdcdCkcKunKxqiaOHvXbCFE7zKJ8TmvIA/132","comment_is_top":false,"comment_ctime":1615282049,"is_pvip":false,"replies":[{"id":"102734","content":"127.0.0.1 是 localhost IP, 每个namespace里都有一个。如果从宿主机的host network namespace里去访问127.0.0.1只是 host network namespace里的，不会访问到容器 network namespace的127.0.0.1","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1615640087,"ip_address":"","comment_id":282501,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5910249345","product_id":100063801,"comment_content":"老师有个问题想咨询一下你，我有个FTP的容器，ftp的配置是配置了127.0.0.1地址，而我宿主机是192.168.1.21的ip，我连接ftp服务的时候用宿主机的ip去连接会有问题？？？我现在有一个问题是被动模式连接上去但LIST命令数据没返回，但是主动模式可以，想问下和上面配置有关系？？如果没关系我上面的配置会引起什么问题？？","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516766,"discussion_content":"127.0.0.1 是 localhost IP, 每个namespace里都有一个。如果从宿主机的host network namespace里去访问127.0.0.1只是 host network namespace里的，不会访问到容器 network namespace的127.0.0.1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615640087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281131,"user_name":"moonberry","can_delete":false,"product_type":"c1","uid":1106785,"ip_address":"","ucode":"4A8EF8705AC2A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqzh2c5OGpQSPx4SNC9L7q2bgnncjlPfUXk48FuE8ud7LzkH4fhrPw0ENwueqh7UkuU8DibhoCz5iaw/132","comment_is_top":false,"comment_ctime":1614589944,"is_pvip":false,"replies":[{"id":"102399","content":"需要自己加一条 “iptables -P FORWARD ACCEPT”， 其它的是默认的配置。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1615038954,"ip_address":"","comment_id":281131,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5909557240","product_id":100063801,"comment_content":"老师您好，请问iptables 列出的NAT表是docker默认配置的吗？","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516301,"discussion_content":"需要自己加一条 “iptables -P FORWARD ACCEPT”， 其它的是默认的配置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615038954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271566,"user_name":"Geek_ba556d","can_delete":false,"product_type":"c1","uid":2187528,"ip_address":"","ucode":"FF3A00C32D2874","user_header":"","comment_is_top":false,"comment_ctime":1609716268,"is_pvip":false,"replies":[{"id":"98647","content":"@Geek_ba556d<br>不好意思，这个需要看到现场环境才能进一步分析。不过，你说arp出问题，那么可以先在主要接口dump一下arp request 或者 arp reply的包。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1609941627,"ip_address":"","comment_id":271566,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5904683564","product_id":100063801,"comment_content":"老师，能帮忙解决一下，我在两台vmwarework虚拟机安装centos7.6，分别创建物理网卡子接口，并关联了macvlan，但是ARP传输一直出问题，绑定静态就可以ping通，不知是什么原因，能帮忙解答一下吗？","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512962,"discussion_content":"@Geek_ba556d\n不好意思，这个需要看到现场环境才能进一步分析。不过，你说arp出问题，那么可以先在主要接口dump一下arp request 或者 arp reply的包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609941627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2187528,"avatar":"","nickname":"Geek_ba556d","note":"","ucode":"FF3A00C32D2874","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340318,"discussion_content":"网络出接口是ARP加VLANID没问题，但是传到入接口就成了无效包了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609975254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354460,"user_name":"JianXu","can_delete":false,"product_type":"c1","uid":1033219,"ip_address":"上海","ucode":"2A61BDBB573BDC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/03/f753fda7.jpg","comment_is_top":false,"comment_ctime":1660440282,"is_pvip":false,"replies":[{"id":"129206","content":"我们用bpf trace 主要的内核stack的收发函数，dump出network namespace id和device name， 就可以看出这条路径了。","user_name":"作者回复","user_name_real":"编辑","uid":"2070138","ctime":1661084784,"ip_address":"上海","comment_id":354460,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1660440282","product_id":100063801,"comment_content":"以我们设计的system diagnostics 为例子，我们是怎么自动推算出 数据路径是 container veth—&gt; host veth —&gt; docker 0 —&gt; host eth0 呢？从而在这条路径上做消息提取呢？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584754,"discussion_content":"我们用bpf trace 主要的内核stack的收发函数，dump出network namespace id和device name， 就可以看出这条路径了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661084784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345740,"user_name":"PageNotFound","can_delete":false,"product_type":"c1","uid":2070840,"ip_address":"","ucode":"43AE16F29EFEBD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/99/38/37b8a8c8.jpg","comment_is_top":false,"comment_ctime":1652539668,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652539668","product_id":100063801,"comment_content":"外部网络访问容器内服务：<br>sudo iptables -t nat -A DOCKER ! -i docker0 -p tcp -m tcp --dport [hostPort] -j DNAT --to-destination [containerIP]:[containerPort]","like_count":0},{"had_liked":false,"id":325854,"user_name":"徐喆","can_delete":false,"product_type":"c1","uid":1202663,"ip_address":"","ucode":"E83AAD2D6338FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhKicPfmH6FDtria1aViaaiaDC0n9nwsuh5LnSJlVvLkMrVZYoXnYT19ZdJ3lh8BUyYSDox1ibTAxnzjw/132","comment_is_top":false,"comment_ctime":1639197806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639197806","product_id":100063801,"comment_content":"老师，我做实验的时候跟着做发现ping不通外网，后来把veth_host桥接到docker0网络通了，是老师在课程里没写上还是其他原因，求教一下","like_count":0},{"had_liked":false,"id":311624,"user_name":"超级芒果冰","can_delete":false,"product_type":"c1","uid":1188976,"ip_address":"","ucode":"97480FBFA4F699","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/70/4e7751f3.jpg","comment_is_top":false,"comment_ctime":1631348181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631348181","product_id":100063801,"comment_content":"老师，veth是怎么配对的，创建之后自动配对吗。如果建了4个veth，配对规则是怎么样的","like_count":0},{"had_liked":false,"id":305637,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1628079836,"is_pvip":false,"replies":[{"id":"110966","content":"@Demon.Lee<br>你描述了k8s 集群节点，不过没有描述pod网络配置方式。在分析这个问题前，你可以把集群的网络拓扑和pod在节点上的网络拓扑分析一遍，然后再分析具体的问题。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1628598879,"ip_address":"","comment_id":305637,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1628079836","product_id":100063801,"comment_content":"请教老师和小伙伴们一个问题，不知道你们是否遇到过：<br>一个简单的 k8s 集群（1个 master ，2个 worker） ，master 的 ip 为 10.5.xx.xx，2 个 worker 的 ip 为 192.168.100.xx。<br><br>有一个 pod 暴露了一个 https 端口（比如443），然后 通过 curl https:&#47;&#47;xxx:443&#47;apis&#47;xxx 访问（调用是会带上token），如果这个 pod 不在 master 节点上，那么在 master 节点上发起请求后一直没反应，直到超时。而在 2 个 worker 节点发起请求，则可以正常返回。<br>如果将这个 pod 强制调度到 master 节点上，那么在 master 节点上发起请求，可以正常返回，但在  2 个 worker 节点发起请求，会超时无响应。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524460,"discussion_content":"@Demon.Lee\n你描述了k8s 集群节点，不过没有描述pod网络配置方式。在分析这个问题前，你可以把集群的网络拓扑和pod在节点上的网络拓扑分析一遍，然后再分析具体的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628598879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301295,"user_name":"徐少文","can_delete":false,"product_type":"c1","uid":1670331,"ip_address":"","ucode":"8E35B10DA44EE3","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/bb/635a2710.jpg","comment_is_top":false,"comment_ctime":1625624204,"is_pvip":false,"replies":[{"id":"111139","content":"@徐少文<br>可以找一些iptables相关的文档看一下。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1628774130,"ip_address":"","comment_id":301295,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625624204","product_id":100063801,"comment_content":"老师的思路我看明白了。我已经自己实现了一个容器沙箱，用net namespace进行了网络的隔离，现在想配置它的网络功能。宿主机已经可以连通外网，我在host上创建了一个网桥，然后在host和沙箱里放置了veth0和veth1。但是还没有设置host上的SNAT和DNAT。现在沙箱和host已经可以ping通，也可以通过tcp通信。但是沙箱内还是无法访问外网，但是不知道具体如何设置SNAT和DNAT，老师能给点指导吗？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522960,"discussion_content":"@徐少文\n可以找一些iptables相关的文档看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628774130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293660,"user_name":"百里英骐","can_delete":false,"product_type":"c1","uid":2323212,"ip_address":"","ucode":"236C3F51967EDE","user_header":"https://static001.geekbang.org/account/avatar/00/23/73/0c/214bbd5e.jpg","comment_is_top":false,"comment_ctime":1621480825,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1621480825","product_id":100063801,"comment_content":"节点外访问容器内ip：<br>1. 前提是正常启动容器和宿主机可以通过VETH和docker0网桥互通，两个节点之间互通<br>2. 在外部的节点配置iptables(DNAT)规则：<br>sudo iptables -t nat -A PREROUTING -d 172.17.0.10(容器的真实ip) -j DNAT --to-destination 172.31.27.61(节点的真实ip)<br>3.之后即可从外部机器直接与container内ip交互<br><br>反过来需要，容器节点本地做SNAT，否则数据包只能过去回不来","like_count":0},{"had_liked":false,"id":289856,"user_name":"Geek_c2089d","can_delete":false,"product_type":"c1","uid":1489545,"ip_address":"","ucode":"C66D345042525F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4Lprf2mIWpJOPibgibbFCicMtp5bpIibyLFOnyOhnBGbusrLZC0frG0FGWqdcdCkcKunKxqiaOHvXbCFE7zKJ8TmvIA/132","comment_is_top":false,"comment_ctime":1619232399,"is_pvip":false,"replies":[{"id":"105121","content":"用&quot;ip link show type bridge&quot;命令看一下 docker0 interface是不是存在。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1619269518,"ip_address":"","comment_id":289856,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1619232399","product_id":100063801,"comment_content":"老师，这段时间遇到这样一个问题，想问下遇到这种问题应该怎么找原因:什么日志都看不了<br><br>adding interface vethbad9e82 to bridge docker0 failed: could not find bridge docker0: no such network interface&quot;","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519033,"discussion_content":"用&amp;quot;ip link show type bridge&amp;quot;命令看一下 docker0 interface是不是存在。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619269518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1489545,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/4Lprf2mIWpJOPibgibbFCicMtp5bpIibyLFOnyOhnBGbusrLZC0frG0FGWqdcdCkcKunKxqiaOHvXbCFE7zKJ8TmvIA/132","nickname":"Geek_c2089d","note":"","ucode":"C66D345042525F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370147,"discussion_content":"查看docker0是存在的，每次docker restart 就会出现，但是reboot机器就好了，docker版本是1.3,内核版本是2.6","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619312841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285986,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1617093635,"is_pvip":false,"replies":[{"id":"104447","content":"赞！","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1618058547,"ip_address":"","comment_id":285986,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617093635","product_id":100063801,"comment_content":"用tcpdump抓包排查问题的思路值得参考，同时理解了示意图上的数据链路中每一个节点的作用","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517841,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618058547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281490,"user_name":"Geek_41a96e","can_delete":false,"product_type":"c1","uid":2346399,"ip_address":"","ucode":"48095B46C0A63C","user_header":"","comment_is_top":false,"comment_ctime":1614763875,"is_pvip":false,"replies":[{"id":"102398","content":"是的，如果&#47;var&#47;run&#47;netns 不存在，事先建一下。 `mkdir -p &#47;var&#47;run&#47;netns`","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1615036610,"ip_address":"","comment_id":281490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1614763875","product_id":100063801,"comment_content":"[root@tyy-node06 ~]# ln -s &#47;proc&#47;$pid&#47;ns&#47;net &#47;var&#47;run&#47;netns&#47;$pid<br>ln: failed to create symbolic link ‘&#47;var&#47;run&#47;netns&#47;24847’: No such file or directory，目录&#47;var&#47;run&#47;netns&#47;不存在要手动创建吗？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516416,"discussion_content":"是的，如果/var/run/netns 不存在，事先建一下。 `mkdir -p /var/run/netns`","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615036610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270240,"user_name":"争光 Alan","can_delete":false,"product_type":"c1","uid":1336328,"ip_address":"","ucode":"338534F909AF03","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/08/0287f41f.jpg","comment_is_top":false,"comment_ctime":1609000195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609000195","product_id":100063801,"comment_content":"我的理解<br>外部访问容器，一个包在主机上的处理大概是<br>经过postrouting链，本地路由，input&#47;forword。。。<br><br>所以如果需要主机访问容器<br>方案一<br>1.可以在postrouting链增加目的地是docker0的网络接收<br>2.经过路由的时候，存在docker0直通路由，会接收处理<br>但这样只能是本主机访问，如果是其他主机，还需要在其他主机配置，把到该docker0的包发过来(比如借助overlay等)<br><br>方案二<br>做nat，访问主机某端口的流量转给容器的某个端口，则<br>1.在postrouting链增加dnat即可<br><br>老师对吗？","like_count":0},{"had_liked":false,"id":269824,"user_name":"Geek_ba556d","can_delete":false,"product_type":"c1","uid":2187528,"ip_address":"","ucode":"FF3A00C32D2874","user_header":"","comment_is_top":false,"comment_ctime":1608800178,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1608800178","product_id":100063801,"comment_content":"[root@localhost ~]# route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>0.0.0.0         192.168.128.2   0.0.0.0         UG    0      0        0 ens33<br>169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 ens33<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 veth_host<br>192.168.128.0   0.0.0.0         255.255.255.0   U     0      0        0 ens33<br><br>如果veth_host本地网卡配置都是16位，会出现ping不通的情况","like_count":0,"discussions":[{"author":{"id":3166673,"avatar":"https://static001.geekbang.org/account/avatar/00/30/51/d1/ad847b1d.jpg","nickname":"二阶导","note":"","ucode":"4B09AA0875224B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585546,"discussion_content":"确实，我也遇到了这种情况。veth_host配置成24位倒是可以ping通","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661674903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269551,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1608699325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608699325","product_id":100063801,"comment_content":"以前虚拟机时代，在路由器上配置某个网段的设备都发送给一台机器，然后由这个机器在做路由转发","like_count":0}]}