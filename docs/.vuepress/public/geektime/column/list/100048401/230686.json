{"id":230686,"title":"15 | 最近邻检索（上）：如何用局部敏感哈希快速过滤相似文章？","content":"<p>你好，我是陈东。</p><p>在搜索引擎和推荐引擎中，往往有很多文章的内容是非常相似的，它们可能只有一些修饰词不同。如果在搜索结果或者推荐结果中，我们将这些文章不加过滤就全部展现出来，那用户可能在第一页看到的都是几乎相同的内容。这样的话，用户的使用体验就会非常糟糕。因此，在搜索引擎和推荐引擎中，对相似文章去重是一个非常重要的环节。</p><p>对相似文章去重，本质上就是把相似的文章都检索出来。今天，我们就来聊聊如何快速检索相似的文章。</p><h2>如何在向量空间中进行近邻检索？</h2><p>既然是要讨论相似文章的检索，那我们就得知道，一篇文章是怎么用计算机能理解的形式表示出来的，以及怎么计算两篇文章的相似性。最常见的方式就是使用<strong>向量空间模型</strong>（Vector Space Model）。所谓向量空间模型，就是将所有文档中出现过的所有关键词都提取出来。如果一共有n个关键词，那每个关键词就是一个维度，这就组成了一个n维的向量空间。</p><p>那一篇文档具体该如何表示呢？我们可以假设，一篇文章中有k（0&lt;k&lt;=n）个关键词，如果第k个关键词在这个文档中的权重是w，那这个文档在第k维上的值就是w。一般来说，我们会以一个关键词在这篇文档中的TF-IDF值作为w的值。而如果文章不包含第k个关键词，那它在第k维上的值就是0，那我们也可以认为这个维度的权重就是0。这样，我们就可以用一个n维的向量来表示一个文档了，也就是&lt;w<sub>1</sub>,w<sub>2</sub>,w<sub>3</sub>,……w<sub>n</sub>&gt;。这样一来，每一个文档就都是n维向量空间中的一个点。<br>\n<img src=\"https://static001.geekbang.org/resource/image/f4/78/f486531c01fd62d0cfbc529f58fd1878.jpg?wh=1920*1080\" alt=\"\" title=\"一个文档的向量化表示\"></p><!-- [[[read_end]]] --><p>那接下来，计算两个文章相似度就变成了计算两个向量的相似度。计算向量相似度实际上就是计算两个向量的距离，距离越小，它们就越相似。具体在计算的时候，我们可以使用很多种距离度量方式。比如说，我们可以采用余弦距离，或者采用欧氏距离等。一般来说，我们会采用余弦距离来计算向量相似度。</p><p>拓展到搜索引擎和推荐引擎中，因为每个文档都是n维向量中的一个点，所以查询相似文章的问题，就变成了在n维空间中，查询离一个点距离最近的k个点的问题。如果把这些“点”想象成“人”，这不就和我们在二维空间中查询附近的人的问题非常类似了吗？这就给了我们一个启发，我们是不是也能用类似的检索技术来解决它呢？下面，我们一起来看一下。</p><p>首先，在十几维量级的低维空间中，我们可以使用k-d树进行k维空间的近邻检索，它的性能还是不错的。但随着维度的增加， 如果我们还要精准找到最邻近的k个点，k-d需要不停递归来探索邻接区域，检索效率就会急剧下降，甚至接近于遍历代价。当关键词是几万乃至百万级别时，文档的向量空间可能是一个上万维甚至是百万维的超高维空间，使用k-d树就更难以完成检索工作了。因此，我们需要寻找更简单、高效的方案。</p><p>这个时候，使用非精准Top K检索代替精准Top K检索的方案就又可以派上用场了。这是为什么呢？因为高维空间本身就很抽象，在用向量空间中的一个点表示一个对象的过程中，如果我们选择了不同的权重计算方式，那得到的向量就会不同，所以这种表示方法本身就已经损失了一定的精确性。</p><p>因此，对于高维空间的近邻检索问题，我们可以使用<strong>近似最近邻检索</strong>（Approximate Nearest Neighbor）来实现。你可以先想一想查询附近的人是怎么实现的，然后再和我一起来看高维空间的近似最近邻检索是怎么做的。</p><h2>什么是局部敏感哈希？</h2><p>借助非精准检索的思路，我们可以将高维空间的点也进行区域划分，然后为每个区域都生成一个简单的一维编码。这样，当我们要查找一个点最邻近的k个点的时候，直接计算出区域编码就能高效检索出同一个区域的所有对象了。</p><p>也因此，我们就能得出一个结论，那就是同一个区域中的不同的点，通过统一的计算过程，都能得到相同的区域编码。这种将复杂对象映射成简单编码的过程，是不是很像哈希的思路？</p><p>所以，我们可以利用哈希的思路，将高维空间中的点映射成低维空间中的一维编码。换句话说，我们通过计算不同文章的哈希值，就能得到一维哈希编码。如果两篇文章内容100%相同，那它们的哈希值就是相同的，也就相当于编码相同。</p><p>不过，如果我们用的是普通的哈希函数，只要文档中的关键词有一些轻微的变化（如改变了一个字），哈希值就会有很大的差异。但我们又希望，整体相似度高的两篇文档，通过哈希计算以后得到的值也是相近的。因此，工业界设计了一种哈希函数，它可以让相似的数据通过哈希计算后，生成的哈希值是相近的（甚至是相等的）。这种哈希函数就叫作<strong>局部敏感哈希</strong>（Locality-Sensitive Hashing）。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ca/f3/ca5e8c281594b8813d1700c8e04badf3.jpg?wh=1920*746\" alt=\"\" title=\"普通哈希 VS 局部敏感哈希\"></p><p>其实局部敏感哈希并不神秘。让我们以熟悉的二维空间为例来进一步解释一下。</p><p>在二维空间中，我们随意划一条直线就能将它一分为二，我们把直线上方的点的哈希值定为1，把直线下方的点的哈希值定为0。这样就完成一个简单的哈希映射。通过这样的随机划分，两个很接近的点被同时划入同一边的概率，就会远大于其他节点。也就是说，这两个节点的哈希值相同的概率会远大于其他节点。<br>\n<img src=\"https://static001.geekbang.org/resource/image/d9/78/d9b56935c705f1ee82dfa6402ccd3a78.jpg?wh=1920*793\" alt=\"\" title=\"二维空间的随机划分\"></p><p>当然，这样的划分有很大的随机性，不一定可靠。但是，如果我们连续做了n次这样的随机划分，这两个点每次都在同一边，那我们就可以认为它们在很大概率上是相近的。因此，我们只要在n次随机划分的过程中，记录下每一个点在每次划分后的值是0还是1，就能得到一个n位的包含0和1的序列了。这个序列就是我们得到的哈希值，也就是区域编码。<br>\n<img src=\"https://static001.geekbang.org/resource/image/d6/9d/d63a7eefc4de1702b4008af74f3f519d.jpeg?wh=1920*1080\" alt=\"\" title=\"将二维空间划分n次，生成n位的比特位哈希值作为区域编码\"></p><p>因此，对于高维空间，我们构造局部敏感哈希函数的方案是，随机地生成n个超平面，每个超平面都将高维空间划分为两部分。位于超平面上面的点的哈希值为1，位于超平面下方的点的哈希值为0。由于有n个超平面，因此一个点会被判断n次，生成一个n位的包含0和1的序列，它就是这个点的哈希值。这就是一个基于超平面划分的局部敏感哈希构造方法。（为了方便你直观理解，我简单说成了判断一个点位于超平面的上面还是下面。在更严谨的数学表示中，其实是求一个点的向量和超平面上法向量的余弦值，通过余弦值的正负判断是1还是0。这里，你理解原理就可以了，严谨的数学分析我就不展开了。）</p><p>如果有两个点的哈希值是完全一样的，就说明它们被n个超平面都划分到了同一边，它们有很大的概率是相近的。即使哈希值不完全一样，只要它们在n个比特位中有大部分是相同的，也能说明它们有很高的相近概率。</p><p>上面我们说的判断标准都比较笼统，实际上，在利用局部敏感哈希值来判断文章相似性的时候，我们会以表示比特位差异数的<strong>海明距离</strong>（Hamming Distance）为标准。我们可以认为如果两个对象的哈希值的海明距离低于k，它们就是相近的。举个例子，如果有两个哈希值，比特位分别为00000和10000。你可以看到，它们只有第一个比特位不一样，那它们的海明距离就是1。如果我们认为海明距离在2之内的哈希值都是相似的，那它们就是相似的。</p><h2>SimHash是怎么构造的？</h2><p>不过，这种构造局部敏感哈希函数的方式也有一些缺陷：在原来的空间中，不同维度本来是有着不同权重的，权重代表了不同关键词的重要性，是一个很重要的信息。但是空间被n个超平面随机划分以后，权重信息在某种程度上就被丢弃了。</p><p>那为了保留维度上的权重，并且简化整个函数的生成过程，Google提出了一种简单有效的局部敏感哈希函数，叫作<strong>SimHash</strong>。它其实是使用一个普通哈希函数代替了n次随机超平面划分，并且这个普通哈希函数的作用对象也不是文档，而是文档中的每一个关键词。这样一来，我们就能在计算的时候保留下关键词的权重了。这么说有些抽象，让我们一起来看看SimHash的实现细节。</p><p>方便起见，我们就以Google官方介绍的64位的SimHash为例，来说一说它构造过程。整个过程，我们可以总结为5步。</p><ol>\n<li>选择一个能将关键词映射到64位正整数的普通哈希函数。</li>\n<li>使用该哈希函数给文档中的每个关键词生成一个64位的哈希值，并将该哈希值中的0修改为-1。比如说，关键词A的哈希值编码为&lt;1,0,1,1,0&gt;，那我们做完转换以后，编码就变成了&lt;1,-1,1,1,-1&gt;。</li>\n<li>将关键词的编码乘上关键词自己的权重。如果关键词编码为&lt;1,-1,1,1,-1&gt;，关键词的权重为2，最后我们得到的关键词编码就变成了&lt;2,-2,2,2,-2&gt;。</li>\n<li>将所有关键词的编码按位相加，合成一个编码。如果两个关键词的编码分别为&lt;2,-2,2,2,-2&gt;和&lt;3,3,-3,3,3&gt;，那它们相加以后就会得到&lt;5,1,-1,5,1&gt;。</li>\n<li>将最终得到的编码中大于0的值变为1，小于等于0的变为0。这样，编码&lt;5,1,-1,5, 1&gt;就会被转换为&lt;1,1,0,1,1&gt;。<br>\n<img src=\"https://static001.geekbang.org/resource/image/3b/05/3b224142a044a6fdebeb128f2df7a605.jpg?wh=1920*875\" alt=\"\" title=\"SimHash生成过程\"></li>\n</ol><p>通过这样巧妙的构造，SimHash将每个关键词的权重保留并且叠加，一直留到最后，从而使得高权重的关键词的影响能被保留。从上图中你可以看到，整个文档的SimHash值和权重最大的关键词word 2的哈希值是一样的。这就体现了高权重的关键词对文档的最终哈希值的影响。此外，SimHash通过一个简单的普通哈希函数就能生成64位哈希值，这替代了随机划分64个超平面的复杂工作，也让整个函数的实现更简单。</p><h2>如何对局部敏感哈希值进行相似检索？</h2><p>和其他局部敏感哈希函数一样，如果两个文档的SimHash值的海明距离小于k，我们就认为它们是相似的。举个例子，在Google的实现中，k的取值为3。这个时候，检索相似文章的问题变成了要找出海明距离在3之内的所有文档。如果是一个个文档比对的话，这就是一个遍历过程，效率很低。有没有更高效的检索方案呢？</p><p>一个直观的想法是，我们可以针对每一个比特位做索引。由于每个比特位只有0和1这2个值，一共有64个比特位，也就一共有2*64共128个不同的Key。因此我们可以使用倒排索引，将所有的文档根据自己每个比特位的值，加入到对应的倒排索引的posting list中。这样，当要查询和一个文档相似的其他文档的时候，我们只需要通过3步就可以实现了，具体的步骤如下：</p><ol>\n<li>计算出待查询文档的SimHash值；</li>\n<li>以该SimHash值中每个比特位的值作为Key，去倒排索引中查询，将相同位置具有相同值的文档都召回；</li>\n<li>合并这些文档，并一一判断它们和要查询的文档之间的海明距离是否在3之内，留下满足条件的。</li>\n</ol><p>我们发现，在这个过程中，只要有一个比特位的值相同，文档就会被召回。也就是说，这个方案和遍历所有文档相比，其实只能排除掉“比特位完全不同的文档”。因此，这种方法的检索效率并不高。</p><p>这又该怎么优化呢？Google利用<strong>抽屉原理</strong>设计了一个更高效的检索方法。什么是抽屉原理呢？简单来说，如果我们有3个苹果要放入4个抽屉，就至少有一个抽屉会是空的。那应用到检索上，Google会将哈希值平均切为4段，如果两个哈希值的比特位差异不超过3个，那这三个差异的比特位最多出现在3个段中，也就是说至少有一个段的比特位是完全相同的！因此，我们可以将前面的查询优化为“有一段比特位完全相同的文档会被召回”。<br>\n<img src=\"https://static001.geekbang.org/resource/image/e5/5f/e566d9735f25c51fd50dbbd089c7035f.jpg?wh=1920*701\" alt=\"\" title=\"如果海明距离小于3，那么4段中至少有一段完全相同\"></p><p>根据这个思路，我们可以将每一个文档都根据比特位划分为4段，以每一段的16个比特位的值作为Key，建立4个倒排索引。检索的时候，我们会把要查询文档的SimHash值也分为4段，然后分别去对应的倒排索引中，查询和自己这一段比特位完全相同的文档。最后，将返回的四个posting list合并，并一一判断它们的的海明距离是否在3之内。<br>\n<img src=\"https://static001.geekbang.org/resource/image/37/d0/375295f5ac305500205c06322a7c8ed0.jpeg?wh=1920*1080\" alt=\"\" title=\"分段查询\"></p><p>通过使用SimHash函数和分段检索（抽屉原理），使得Google能在百亿级别的网页中快速完成过滤相似网页的功能，从而保证了搜索结果的质量。</p><h2>重点回顾</h2><p>今天，我们重点学习了使用局部敏感哈希的方法过滤相似文章。</p><p>我们可以使用向量空间模型将文章表示为高维空间中的点，从而将相似文章过滤问题转为高维空间的最近邻检索问题。对于高维空间的最近邻检索问题，我们可以使用非精准的检索思路，使用局部敏感哈希为高维空间的点生成低维的哈希值。</p><p>局部敏感哈希有许多构造方法，我们主要讲了随机超平面划分和SimHash两种方法。相比于随机超平面划分，SimHash能保留每一个关键词的权重，并且它的函数实现也更简单。</p><p>那对于局部敏感哈希的相似检索，我们可以使用海明距离定义相似度，用抽屉原理进行分段划分，从而可以建立对应的倒排索引，完成高效检索。<br>\n<img src=\"https://static001.geekbang.org/resource/image/32/cd/32c0cc283e8aee0fe7173587ca469ccd.jpg?wh=1920*895\" alt=\"\" title=\"知识总结\"></p><p>实际上，不仅过滤相似文章可以使用局部敏感哈希，在拍照识图和摇一摇搜歌等应用场景中，我们都可以使用它来快速检索。以图像检索为例，我们可以对图像进行特征分析，用向量来表示一张图片，这样一张图片就是高维空间中的一个点了，图像检索就也抽象成了高维空间中的近邻检索问题，也就可以使用局部敏感哈希来完成了。</p><p>当然基于局部敏感哈希的检索也有它的局限性。以相似文章检索为例，局部敏感哈希更擅长处理字面上的相似而不是语义上的相似。比如，一篇文章介绍的是随机超平面划分，另一篇文章介绍的是SimHash，两篇文章可能在字面上差距很大，但内容领域其实是相似的。好的推荐系统在用户看完随机超平面划分的文章后，还可以推荐SimHash这篇文章，但局部敏感哈希在这种语义相似的推荐系统中就不适用了。</p><p>因此，对于更灵活的相似检索问题，工业界还有许多的解决方法，我们后面再详细介绍。</p><h2>课堂讨论</h2><p>1.对于SimHash，如果将海明距离在4之内的文章都定义为相似的，那我们应该将哈希值分为几段进行索引和查询呢？</p><p>2.SimHash的算法能否应用到文章以外的其他对象？你能举个例子吗？</p><p>欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这一讲分享给你的朋友。</p>","neighbors":{"left":{"article_title":"14 | 空间检索（下）：“查找最近的加油站”和“查找附近的人”有何不同？","id":230018},"right":{"article_title":"16 | 最近邻检索（下）：如何用乘积量化实现“拍照识花”功能？","id":231760}},"comments":[{"had_liked":false,"id":212736,"user_name":"paulhaoyi","can_delete":false,"product_type":"c1","uid":1105619,"ip_address":"","ucode":"C972F4B459E7D6","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/d3/2aa0177f.jpg","comment_is_top":false,"comment_ctime":1588205405,"is_pvip":false,"replies":[{"id":"79042","content":"你说的很对。其实局部敏感哈希和embedding，都是对高维空间的点进行降维，用更低维的向量来表示，但又要保留原来的核心特征。从这个角度来说，它们的思路是一致的。<br>你可以认为局部敏感哈希是基于规则的embedding。因此在一些应用中，是有可能可以替换使用的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1588215067,"ip_address":"","comment_id":212736,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35947943773","product_id":100048401,"comment_content":"感觉局部敏感hash和深度学习中的embedding好相近啊，都是临近点的向量表示很相近。不知道应用中有没有相互替换的场景。","like_count":9,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493595,"discussion_content":"你说的很对。其实局部敏感哈希和embedding，都是对高维空间的点进行降维，用更低维的向量来表示，但又要保留原来的核心特征。从这个角度来说，它们的思路是一致的。\n你可以认为局部敏感哈希是基于规则的embedding。因此在一些应用中，是有可能可以替换使用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588215067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213704,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1588517197,"is_pvip":true,"replies":[{"id":"79214","content":"1.其实从抽屉原理来看，五段以上都可以。比如说五段的比特位个数分为13，13，13，13，12。但是从计算机的实现来看，读取和处理13个比特位的效率并不高。不如读取和处理8个比特位(一个字节)高效。因此可以以8个比特位为单位处理。<br>然后，这个相似度判断的流程是分为召回和排序两阶段。分成八段只是方便召回，召回了候选集以后，我们还需要基于海明距离进行排序，海明距离小于k的元素才会被留下。因此，分段的多少只会影响检索效率，不会影响最后判断相似性的精准度。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1588560976,"ip_address":"","comment_id":213704,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27358320973","product_id":100048401,"comment_content":"对于思考题：<br>1：利用抽屉性原理，可以分为 5段保证，至少有一段是相等的，但是我看下面的老师评论说，最好分为 8段，但是这样的话相似度准确性是不是会降低很多？  因为分为 8段 的话至少要有 4个是相等的， 还是分为8段的时候进行了特殊处理？<br>2: 还可以对其他东西，比如图片，歌曲进行特征向量提取，再利用局部敏感哈希函数，这里还不用考虑语义上的相似","like_count":7,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493848,"discussion_content":"1.其实从抽屉原理来看，五段以上都可以。比如说五段的比特位个数分为13，13，13，13，12。但是从计算机的实现来看，读取和处理13个比特位的效率并不高。不如读取和处理8个比特位(一个字节)高效。因此可以以8个比特位为单位处理。\n然后，这个相似度判断的流程是分为召回和排序两阶段。分成八段只是方便召回，召回了候选集以后，我们还需要基于海明距离进行排序，海明距离小于k的元素才会被留下。因此，分段的多少只会影响检索效率，不会影响最后判断相似性的精准度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588560976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257345,"discussion_content":"清晰了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588561109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212404,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1588119228,"is_pvip":false,"replies":[{"id":"78966","content":"minhash的确也是另一种局部敏感哈希算法。它是基于Jaccard距离的一种算法。而不是基于余弦距离。因此它更适合做集合相似度这类的判断。<br>包括计算过程的确比simhash更复杂。<br><br>关于课后题:<br>1.根据抽屉原理，的确使用五段以上的分割都可以。不能整除其实问题不大，不过考虑到代码简洁性和空间平衡划分，分成8段是不错的答案。<br>2.其实我文中已经举了一个例子，就是判断图片相似度，我们可以将每个维度的特征取出，用Simhash的思路进行处理即可。因此simhash不仅仅可用于文章相似度判断，而是可以用于抽象的物品相似度判断。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1588155831,"ip_address":"","comment_id":212404,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27357923004","product_id":100048401,"comment_content":"与simHash类似的还有个minHash，查了资料对比了下，貌似是minHash对于权重处理不是很好，而且处理时候因为要计算多个hash函数，占用更多CPU资源，而superminhash在处理速度上更胜一筹。不知理解是否正确？<br><br>讨论问题：<br>1. 最开始想法是对于4位不同，采用5段分割，但是对于64bit，5段不能整除。可以增大分割的段数，可采用8段分割来计算。<br>2. 暂时没想到其它具体应用","like_count":7,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493497,"discussion_content":"minhash的确也是另一种局部敏感哈希算法。它是基于Jaccard距离的一种算法。而不是基于余弦距离。因此它更适合做集合相似度这类的判断。\n包括计算过程的确比simhash更复杂。\n\n关于课后题:\n1.根据抽屉原理，的确使用五段以上的分割都可以。不能整除其实问题不大，不过考虑到代码简洁性和空间平衡划分，分成8段是不错的答案。\n2.其实我文中已经举了一个例子，就是判断图片相似度，我们可以将每个维度的特征取出，用Simhash的思路进行处理即可。因此simhash不仅仅可用于文章相似度判断，而是可以用于抽象的物品相似度判断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588155831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214044,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1588644424,"is_pvip":false,"replies":[{"id":"79295","content":"simhash的设计和检索的确都很巧妙。不得不说，Google的搜索引擎中的确有着许多亮点。这些技术可以说是Google帝国的地基。<br>1.分组以后，每组并不是只有16个key，而是2^8共256个key。这样如果两篇文章有一段8个比特位是相同的，它们就会在这个key对应的posting list中。<br>2.相似路径，图片，音乐，这些都是很好地使用局部敏感哈希的场景，因为它们都是字面相似的。好友推荐和文章推荐可能会更重视语意推荐一些。不过局部敏感哈希也是可以尝试的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1588656470,"ip_address":"","comment_id":214044,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14473546312","product_id":100048401,"comment_content":"这篇文章干货很多，这是很好的思路。说下我的理解，局部敏感hash关注点在于保持相似性的原文hash也相似，我一般用hash多是检验是否修改过了，或者判断是否存在比如布隆过滤器。谷歌的那个算法更是让我开了眼界，通过计算词的hash得到64bit序列，为叠加权重将0改成-1，我们如果不修改那和权重相乘的结果是0，叠加成文章权重的时候，权重很小的关键词和权重很大的关键词在这一位的影响是一样的了，然后将所有的关键词叠加保证了大权重关键词影响大，比如大关键词在一位中为-1，那最终结果很可能这一位为负数，最终为了方便比较可以说做了另外一个映射，映射成0和1这种64位比特流，因为这样和二进制对应。后面的海明距离的就更巧妙了，分割数据看成多个段，回答下问题吧：<br>1. 海明距离4为区分度，那分割成五段的话，至少有一段是完全相同的，不过这样分割不太好分割，分割成8段，我理解的过程为0-7为一组8-15 16-23一次类推分成8个组后，每个组都有8位，那每组就有16个不同的key因为2*8，后面postlist为哪些文章的哪些位对应这组key，查询文章过来后，找到相同的key的所有文章，这样我们得到8组文章，然后既然距离为4，我们可以每两个组求交集，每求三次仍然保留的满足条件，抽出来作为结果集，这个求的过程好好设计。<br>2.  这种算法可以用在推荐爱好相似的好友上，比如我们给用户打不同的标签，所有的标签组成一个文章，按照上述算法求相近的用户，推荐为好友；相似路径是不是可以，我们把一段距离之间的几个关键经过点标记出来作为词，然后比较相似性。图片音乐这种也适合；图书如果打上标签，或者用图书关键词也合适","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493937,"discussion_content":"simhash的设计和检索的确都很巧妙。不得不说，Google的搜索引擎中的确有着许多亮点。这些技术可以说是Google帝国的地基。\n1.分组以后，每组并不是只有16个key，而是2^8共256个key。这样如果两篇文章有一段8个比特位是相同的，它们就会在这个key对应的posting list中。\n2.相似路径，图片，音乐，这些都是很好地使用局部敏感哈希的场景，因为它们都是字面相似的。好友推荐和文章推荐可能会更重视语意推荐一些。不过局部敏感哈希也是可以尝试的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588656470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262255,"discussion_content":"尴尬，竟然错了谢谢老师指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589068580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213702,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1588516636,"is_pvip":true,"replies":[{"id":"79213","content":"首先，“四个倒排索引”不是“只有四个posting list”。每个倒排索引中，都会有多个key和对应的posting list。<br>然后分段查询的图，你的理解是对的。我再详细描述一下。<br>我们将16个比特位看着是一个值。这样，就可以用这个值作为key来建立倒排索引。<br>比如说，我们有100个元素，我们先看它们哈希值的前16个比特位，如果这100个元素的前16个比特位几乎都是相同的，比如说只有两种情况，那么倒排索引就只有两个key，然后这100个元素就会根据自己的值，加入到对应的key的posting list中。<br>同理，再看下一个16个比特位，如果这100个元素在这一段上，一共有k种值的话，那么就会生成k个key，然后将这100个元素加入对应的key后面的posting list中。依此类推。<br><br>希望这样的分析能解答你的疑惑。<br>","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1588560418,"ip_address":"","comment_id":213702,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14473418524","product_id":100048401,"comment_content":"每一个文档都根据比特位划分为 4 段，以每一段的 16 个比特位的值作为 Key，建立 4 个倒排索引<br>-------------------------------<br>这里是怎么 以 16 个比特位的值作为 Key 建立倒排索引的呢？ 怎么把文档分配到这四个 posting list 中的？ 这里没有理解<br><br>还有下面的分段查询的图中，怎么每个倒排索引里面 还有以key建的倒排索引？ 这里的key是每一段的 位取值吗？0- 2^16-1 个倒排索引？","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493847,"discussion_content":"首先，“四个倒排索引”不是“只有四个posting list”。每个倒排索引中，都会有多个key和对应的posting list。\n然后分段查询的图，你的理解是对的。我再详细描述一下。\n我们将16个比特位看着是一个值。这样，就可以用这个值作为key来建立倒排索引。\n比如说，我们有100个元素，我们先看它们哈希值的前16个比特位，如果这100个元素的前16个比特位几乎都是相同的，比如说只有两种情况，那么倒排索引就只有两个key，然后这100个元素就会根据自己的值，加入到对应的key的posting list中。\n同理，再看下一个16个比特位，如果这100个元素在这一段上，一共有k种值的话，那么就会生成k个key，然后将这100个元素加入对应的key后面的posting list中。依此类推。\n\n希望这样的分析能解答你的疑惑。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588560418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257344,"discussion_content":"明白了，这里也就是每一段最多会生成2^16个posting list。再查询的时候会根据某一段的值找到对应相等的key的posting list就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588560831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":257357,"discussion_content":"对的。就是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588561976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":257344,"ip_address":""},"score":257357,"extra":""}]}]},{"had_liked":false,"id":212390,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1588115813,"is_pvip":false,"replies":[{"id":"78964","content":"你对局部敏感哈希归纳得挺好。包括ann(近似最近邻)的算法，本质都是建立在对全空间的不断划分上，在子空间进行检索。你会发现，这其实和我们在第一讲就提到过的二分查找的核心思想是一致的。<br>关于思考题:<br>1.根据抽屉原理，五段以上其实都可以。当然从代码简洁程度和空间均匀划分角度来看，八段是比较简洁的。<br>2.的确是这样的。有这么一句话“万物皆可embedding”。其实许多事物都可以抽象成高维向量空间的点，都可以使用局部敏感哈希的思路检索。只要把每个维度的特征拿出来，用Simhash的方法处理即可。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1588154926,"ip_address":"","comment_id":212390,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14473017701","product_id":100048401,"comment_content":"1.距离相近的点比距离相远的点更容易发生Hash碰撞，这是局部敏感哈希的理论根据<br>2. LSH family有hyperplane和crosspoltye的，同样SimHash也是一种方法<br>3.文章中的例子都是关键词的，实际上现在可以做成embedding的比较吧，这样关键信息的丢失会更少<br>4.所有的ANN相关算法，都是建立在对全空间的不断划分上，将全空间划分为若干子空间，然后在子空间里搜索最近邻.<br><br>思考题目:<br>1.如果4位以内的不同，都可以认为比较相似，那么划分的时候64位应该划分成8段比较合适。<br><br>2.除了文章，其他的embedding的相似性求解也可以。<br>","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493491,"discussion_content":"你对局部敏感哈希归纳得挺好。包括ann(近似最近邻)的算法，本质都是建立在对全空间的不断划分上，在子空间进行检索。你会发现，这其实和我们在第一讲就提到过的二分查找的核心思想是一致的。\n关于思考题:\n1.根据抽屉原理，五段以上其实都可以。当然从代码简洁程度和空间均匀划分角度来看，八段是比较简洁的。\n2.的确是这样的。有这么一句话“万物皆可embedding”。其实许多事物都可以抽象成高维向量空间的点，都可以使用局部敏感哈希的思路检索。只要把每个维度的特征拿出来，用Simhash的方法处理即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588154926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216305,"user_name":"王坤祥","can_delete":false,"product_type":"c1","uid":1003327,"ip_address":"","ucode":"FB988B9F381A33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","comment_is_top":false,"comment_ctime":1589239045,"is_pvip":false,"replies":[{"id":"80076","content":"哈哈，既然是联想，那怎么想都可以。你这个联想的关键词是映射，的确计算机的世界中，会有许多映射关系。<br>你举的这个例子，是一一映射的关系，一个虚拟地址对应一个物理地址。<br>而文章中的例子，就不是一一映射了，这种高维到低维的映射，会将多个高维的地址映射到低维的同一个地址中。这样会起到降维和压缩的作用。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1589254660,"ip_address":"","comment_id":216305,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179173637","product_id":100048401,"comment_content":"通过学习这一讲，我联想到了虚拟内存到物理内存的页表映射方法。在映射时，虚拟内存的高位用于从映射到物理内存，低位作为偏移量，然后得到真实的物理地址。<br><br>老师，我联想的对吗？","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494763,"discussion_content":"哈哈，既然是联想，那怎么想都可以。你这个联想的关键词是映射，的确计算机的世界中，会有许多映射关系。\n你举的这个例子，是一一映射的关系，一个虚拟地址对应一个物理地址。\n而文章中的例子，就不是一一映射了，这种高维到低维的映射，会将多个高维的地址映射到低维的同一个地址中。这样会起到降维和压缩的作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589254660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217024,"user_name":"innocent","can_delete":false,"product_type":"c1","uid":1197455,"ip_address":"","ucode":"368659A0DDE7E4","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/8f/a56b2214.jpg","comment_is_top":false,"comment_ctime":1589387264,"is_pvip":false,"replies":[{"id":"80321","content":"并不是哦。我在文章结尾也说了局部敏感哈希更多的是用来判断字面上是否有大范围重复，但是对于语义上的相似处理得并不好。<br><br>业界主流的文本相似度计算是这样的:<br>1.最基础的是基于tf-idf的向量空间，用余弦距离来求相似度。<br>2.但原始的向量空间维度太高，效果也不好，因此之前业界会采用分析潜在语义的PLSA和LDA主题模型进行文本分析，得到降维的向量，从而更好地计算向量相似度。<br>3.而现在，随着深度学习的普及，业界会使用dssm-lstm，还有doc2vec来将文本学习成低维的向量，从而可以计算向量相似度。<br>","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1589459876,"ip_address":"","comment_id":217024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884354560","product_id":100048401,"comment_content":"请问老师，业界主流的文本相似度计算就是采用局部哈希么","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495010,"discussion_content":"并不是哦。我在文章结尾也说了局部敏感哈希更多的是用来判断字面上是否有大范围重复，但是对于语义上的相似处理得并不好。\n\n业界主流的文本相似度计算是这样的:\n1.最基础的是基于tf-idf的向量空间，用余弦距离来求相似度。\n2.但原始的向量空间维度太高，效果也不好，因此之前业界会采用分析潜在语义的PLSA和LDA主题模型进行文本分析，得到降维的向量，从而更好地计算向量相似度。\n3.而现在，随着深度学习的普及，业界会使用dssm-lstm，还有doc2vec来将文本学习成低维的向量，从而可以计算向量相似度。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589459876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215453,"user_name":"时隐时现","can_delete":false,"product_type":"c1","uid":1111899,"ip_address":"","ucode":"DA4D622FF84920","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","comment_is_top":false,"comment_ctime":1588994451,"is_pvip":false,"replies":[{"id":"79767","content":"1. 如果是你这个case，的确是9比2吃亏。但整体来看，一篇文章中是有多个关键词的，各个位都有正有负，因此会相互抵消，最终权重大的关键词对相应的位的贡献会更大。你可以想象成拔河比赛，最终只看标志被拉到左边还是右边，两队人数均等，但是在拉扯的过程中，出力大的一方会获胜。<br>2.代码实现的话，每个位是一个数值，那当然不能用一个bit来表示，其实就是一个int的数组。因此，当然可以累加值是两位数","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1589012197,"ip_address":"","comment_id":215453,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5883961747","product_id":100048401,"comment_content":"多谢老师的精彩分享，有2个小问题：<br>1、SimHash的前4步都可以理解，但是最后一步 “将最终得到的编码中大于 0 的值变为 1，小于等于 0 的变为 0。这样，编码 &lt;5,1,-1,5, 1&gt; 就会被转换为 &lt;1,1,0,1,1&gt;。”<br>似懂非懂，多少还是不太能理解，这样当真不会让最高权重的关键词影响受损吗？那么2和9，最后都变成1，感觉9&quot;吃亏了&quot;,^—^...<br>2、还有1个小问题，SimHash表示的hash编码，在计算过程中，&lt;3,3,-3,3,3&gt;，会不会出现单个数值变成2位甚至是3位数的情况，如果会，在算法具体实现时，每个数值用1bit还是1byte来表示？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494442,"discussion_content":"1. 如果是你这个case，的确是9比2吃亏。但整体来看，一篇文章中是有多个关键词的，各个位都有正有负，因此会相互抵消，最终权重大的关键词对相应的位的贡献会更大。你可以想象成拔河比赛，最终只看标志被拉到左边还是右边，两队人数均等，但是在拉扯的过程中，出力大的一方会获胜。\n2.代码实现的话，每个位是一个数值，那当然不能用一个bit来表示，其实就是一个int的数组。因此，当然可以累加值是两位数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589012197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213002,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1588259679,"is_pvip":false,"replies":[{"id":"79076","content":"哈哈哈哈，上万维的神经网络，还真可以简称为万维网。<br><br>ps:万维网是www(world wide web)的翻译，这是我觉得非常符合“信达雅”标准的翻译。不过没想到还能被你赋予了新含义~<br>","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1588264724,"ip_address":"","comment_id":213002,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5883226975","product_id":100048401,"comment_content":"当关键词是几万乃至百万级别时，文档的向量空间可能是一个上万维甚至是百万维的超高维空间，使用 k-d 树就更难以完成检索工作了。<br>——这是不是就是万维网这个名称的由来？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493665,"discussion_content":"哈哈哈哈，上万维的神经网络，还真可以简称为万维网。\n\nps:万维网是www(world wide web)的翻译，这是我觉得非常符合“信达雅”标准的翻译。不过没想到还能被你赋予了新含义~\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588264724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256814,"discussion_content":"这个理解 可以可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588514108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315849,"user_name":"Ignite","can_delete":false,"product_type":"c1","uid":2324973,"ip_address":"","ucode":"813754E25AC505","user_header":"https://static001.geekbang.org/account/avatar/00/23/79/ed/b8486f49.jpg","comment_is_top":false,"comment_ctime":1634021407,"is_pvip":false,"replies":[{"id":"116695","content":"因为我们现在是在构造倒排索引，因此每个比特位上值相同的数都在一个posting list中。每个比特位会产生2个posting list（0和1各有一个posting list），因此一共有128个","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1636814114,"ip_address":"","comment_id":315849,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634021407","product_id":100048401,"comment_content":"由于每个比特位只有 0 和 1 这 2 个值，一共有 64 个比特位，也就一共有 2*64 共 128 个不同的 Key。为啥是2*64而不是2^64","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528184,"discussion_content":"因为我们现在是在构造倒排索引，因此每个比特位上值相同的数都在一个posting list中。每个比特位会产生2个posting list（0和1各有一个posting list），因此一共有128个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636814114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315727,"user_name":"armatrix","can_delete":false,"product_type":"c1","uid":2803119,"ip_address":"","ucode":"CCBF1181DDCD23","user_header":"https://static001.geekbang.org/account/avatar/00/2a/c5/af/174261ab.jpg","comment_is_top":false,"comment_ctime":1633954658,"is_pvip":false,"replies":[{"id":"116694","content":"不是。的确就是2*64共128个。因为我们现在是在构造倒排索引，因此每个比特位上值相同的数都在一个posting list中。每个比特位会产生2个posting list（0和1各有一个posting list），因此一共有128个","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1636814073,"ip_address":"","comment_id":315727,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633954658","product_id":100048401,"comment_content":"“由于每个比特位只有 0 和 1 这 2 个值，一共有 64 个比特位，也就一共有 2*64 共 128 个不同的 Key”这个应该是2^64个？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528151,"discussion_content":"不是。的确就是2*64共128个。因为我们现在是在构造倒排索引，因此每个比特位上值相同的数都在一个posting list中。每个比特位会产生2个posting list（0和1各有一个posting list），因此一共有128个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636814073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306301,"user_name":"anker","can_delete":false,"product_type":"c1","uid":1218937,"ip_address":"","ucode":"6EDF1FB9D45238","user_header":"https://static001.geekbang.org/account/avatar/00/12/99/79/74d4f24f.jpg","comment_is_top":false,"comment_ctime":1628489150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628489150","product_id":100048401,"comment_content":"1. 对于 SimHash，如果将海明距离在 4 之内的文章都定义为相似的，那我们应该将哈希值分为几段进行索引和查询呢？<br>答：k = 4时，可以采取分割为八份，为啥不选择5呢，CPU计算对于2的倍数计算天然友好。<br>分割为八份的时候，posting list 可以采取B+树存储，进行多路归并，把N路中，相同的key才需要进行海明距离的计算，可以减少很多计算量<br><br>2.SimHash 的算法能否应用到文章以外的其他对象？你能举个例子吗？<br>答：可以处理人的声音识别用于刑侦技术","like_count":0},{"had_liked":false,"id":269721,"user_name":"Bachue Zhou","can_delete":false,"product_type":"c1","uid":1494491,"ip_address":"","ucode":"3175754775CA32","user_header":"https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg","comment_is_top":false,"comment_ctime":1608771462,"is_pvip":false,"replies":[{"id":"98008","content":"其实你可以参考一下前面介绍过的跳表，跳表也是通过随机来完成近似二分查找的效果，并且维护代价很低。<br>局部敏感哈希也是类似的思路，通过简单的随机划分，来从概率上完成快速划分查找空间的效果。<br>当然，局部敏感哈希的确不够精确，因此我们才会有更多的更复杂，但是也更精准的高维检索技术。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1609077271,"ip_address":"","comment_id":269721,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608771462","product_id":100048401,"comment_content":"我对局部敏感哈希还是抱有怀疑，这个和二分搜索不同，二分搜索每次比较都能排除掉一半的数据，但是随机划分超平面却不一定，可能一开始 n 较小的时候，每次划分都能排除近一半的可能，但随着 n 的提高，排除的概率越来越低，我无法计算当 n 要达到什么程度的时候，两点哈希相同距离确实较近的概率能高于百分之九十九。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512363,"discussion_content":"其实你可以参考一下前面介绍过的跳表，跳表也是通过随机来完成近似二分查找的效果，并且维护代价很低。\n局部敏感哈希也是类似的思路，通过简单的随机划分，来从概率上完成快速划分查找空间的效果。\n当然，局部敏感哈希的确不够精确，因此我们才会有更多的更复杂，但是也更精准的高维检索技术。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609077271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225892,"user_name":"benny","can_delete":false,"product_type":"c1","uid":1123043,"ip_address":"","ucode":"E2F30AF0C808D9","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","comment_is_top":false,"comment_ctime":1591884205,"is_pvip":false,"replies":[{"id":"83259","content":"这是一个好问题，分成八段以后，是否有啥特殊的处理技巧?其实是可以有的。<br>我们先看看不做特殊处理是怎么做的。常规情况下，我们只需要将这八段作为八个key去检索倒排表，然后将倒排表中的结果取并集，并对集合中的每个结果和查询的值进行比较，计算海明距离。<br>但如果考虑到，如果有一个文档有至少四段都是相同的才是符合条件的，而只有三段相同或者两段相同的都应该被过滤掉，那么我们可以做这么一个优化:在合并集合的时候，对每个结果进行计数，看看它在这八段中有几段是相同的。然后，我们根据这个计数，将少于四段相同的都快速过滤掉。对于剩下的结果，再来精确计算海明距离。这就是一个“粗排+精排”的两阶段排序过程了。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1591937590,"ip_address":"","comment_id":225892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591884205","product_id":100048401,"comment_content":"分八段后，要找至少四段相同的吧？这块处理有啥特殊技巧？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498030,"discussion_content":"这是一个好问题，分成八段以后，是否有啥特殊的处理技巧?其实是可以有的。\n我们先看看不做特殊处理是怎么做的。常规情况下，我们只需要将这八段作为八个key去检索倒排表，然后将倒排表中的结果取并集，并对集合中的每个结果和查询的值进行比较，计算海明距离。\n但如果考虑到，如果有一个文档有至少四段都是相同的才是符合条件的，而只有三段相同或者两段相同的都应该被过滤掉，那么我们可以做这么一个优化:在合并集合的时候，对每个结果进行计数，看看它在这八段中有几段是相同的。然后，我们根据这个计数，将少于四段相同的都快速过滤掉。对于剩下的结果，再来精确计算海明距离。这就是一个“粗排+精排”的两阶段排序过程了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591937590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215459,"user_name":"时隐时现","can_delete":false,"product_type":"c1","uid":1111899,"ip_address":"","ucode":"DA4D622FF84920","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","comment_is_top":false,"comment_ctime":1588995195,"is_pvip":false,"replies":[{"id":"79776","content":"直接使用Simhash对论文进行判重并不是太合适。<br>因为论文其实整体相似度有30%就算是抄袭了。甚至有连续20个字都相同就算抄袭。这个重复率对simhash而言太低。<br>不过，对于那种把句子重写，关键词换汤不换药的改写论文而言，说不定simhash会有意想不到的效果。它能将关键词词提炼出来(或者我们可以扩大范围，提炼关键句子)，然后加权求和。这样其实是能有一定效果的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1589013330,"ip_address":"","comment_id":215459,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588995195","product_id":100048401,"comment_content":"<br>刚刚发了2个小问题，系统还没放出来，再追加第3个小问题，希望老师有空解答一下。<br>3、这种依靠关键词过滤查找相似文章的算法，能不能用到论文放抄袭上？但是一篇论文有太多的字和关键字，就算用SimHash和抽屉优化，也要对每个字或者关键字挨个比对一遍吗？有没有更优化的算法？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494444,"discussion_content":"直接使用Simhash对论文进行判重并不是太合适。\n因为论文其实整体相似度有30%就算是抄袭了。甚至有连续20个字都相同就算抄袭。这个重复率对simhash而言太低。\n不过，对于那种把句子重写，关键词换汤不换药的改写论文而言，说不定simhash会有意想不到的效果。它能将关键词词提炼出来(或者我们可以扩大范围，提炼关键句子)，然后加权求和。这样其实是能有一定效果的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589013330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}