{"id":724942,"title":"11｜常见trait解析：标准库中的常见trait应该怎么用？","content":"<p>你好，我是Mike，今天我们一起来学习Rust中的常见trait。</p><p>前面两节课我们已经讲过trait在Rust中的重要性了，这节课就是trait在Rust标准库中的应用。Rust标准库中包含大量的trait定义，甚至Rust自身的某些语言特性就是在这些trait的帮助下实现的。这些trait和标准库里的各种类型一起，构成了整个Rust生态的根基，只有了解它们才算真正了解Rust。</p><p><span class=\"reference\">注：这节课大量代码来自 <a href=\"https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md\">Tour of Rust’s Standard Library Traits</a>，我加了必要的注解和分析。</span></p><p>学习完这节课的内容，你会对很多问题都豁然开朗。下面就让我们来学习标准库里一些比较常用的trait。</p><h2>标准库中的常用trait</h2><h3>Default</h3><p>我们来看Default trait的定义以及对Default trait的实现和使用。</p><pre><code class=\"language-plain\">trait Default {\n    fn default() -&gt; Self;\n}\n</code></pre><pre><code class=\"language-plain\">struct Color(u8, u8, u8);\nimpl Default for Color {\n    // 默认颜色是黑色 (0, 0, 0)\n    fn default() -&gt; Self {\n        Color(0, 0, 0)\n    }\n}\n\nfn main() {\n    let color = Color::default();\n    // 或\n    let color: Color = Default::default();\n}\n</code></pre><!-- [[[read_end]]] --><p>还有其他一些地方用到了Default，比如 <code>Option&lt;T&gt;</code> 的 <code>unwrap_or_default()</code>，在类型参数上调用 <code>default()</code> 函数。</p><pre><code class=\"language-plain\">fn paint(color: Option&lt;Color&gt;) {\n    // 如果没有颜色参数传进来，就用默认颜色\n    let color = color.unwrap_or_default();\n    // ...\n}\n\n// 由于default()是在trait中定义的关联函数，因此可方便的由类型参数调用\nfn guarantee_length&lt;T: Default&gt;(mut vec: Vec&lt;T&gt;, min_len: usize) -&gt; Vec&lt;T&gt; {\n    for _ in 0..min_len.saturating_sub(vec.len()) {\n        vec.push(T::default());  // 这里用了 T::default() 这种形式\n    }\n    vec\n}\n</code></pre><p>前面讲过，如果是struct，还可以使用部分更新语法，这个时候其实是Default在发挥作用。</p><pre><code class=\"language-plain\">#[derive(Default)]\nstruct Color {\n&nbsp; &nbsp; r: u8,\n&nbsp; &nbsp; g: u8,\n&nbsp; &nbsp; b: u8,\n}\nimpl Color {\n&nbsp; &nbsp; fn new(r: u8, g: u8, b: u8) -&gt; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; Color {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b,\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\nimpl Color {\n&nbsp; &nbsp; fn red(r: u8) -&gt; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; Color {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ..Color::default()&nbsp; &nbsp; // 注意这一句\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; fn green(g: u8) -&gt; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; Color {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ..Color::default()&nbsp; &nbsp; // 注意这一句\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; fn blue(b: u8) -&gt; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; Color {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ..Color::default()&nbsp; &nbsp; // 注意这一句\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>Rust标准库实际给我们提供了一个标注，也就是 <code>#[derive()]</code> 里面放 Default，方便我们为结构体自动实现Default trait。</p><pre><code class=\"language-plain\">#[derive(Default)]\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8\n}\n\n#[derive(Default)]\nstruct Color2(u8, u8, u8);\n</code></pre><p>注意这里的细节，我们用 <code>#[derive()]</code> 在两个结构体上作了标注，这里面出现的这个 Default 不是trait，它是一个同名的派生宏（我们后面会讲到）。这种派生宏标注帮助我们实现了 Default trait。Rustc能正确区分Default到底是宏还是trait，因为它们出现的位置不一样。</p><p>为什么可以自动实现Default trait呢？因为Color里面的类型是基础类型u8，而u8是实现了Default trait的，默认值为 0。</p><h3>Display</h3><p>我们看Display trait的定义。</p><pre><code class=\"language-plain\">trait Display {\n    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;\n}\n</code></pre><p>Display trait对应于格式化符号 <code>\"{}\"</code>，比如 <code>println!(\"{}\", s)</code>，用于决定一个类型如何显示，其实就是把类型转换成字符串表达。Display需要我们自己手动去实现。</p><p>示例：</p><pre><code class=\"language-plain\">use std::fmt;\n#[derive(Default)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n// 为Point实现 Display\nimpl fmt::Display for Point {\n    // 实现唯一的fmt方法，这里定义用户自定义的格式\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)  // write!宏向stdout写入\n    }\n}\n\nfn main() {\n    println!(\"origin: {}\", Point::default());\n    // 打印出 \"origin: (0, 0)\"\n    // 在 format! 中用 \"{}\" 将类型表示/转换为 String\n    let stringified = format!(\"{}\", Point::default());\n    assert_eq!(\"(0, 0)\", stringified); // ✅\n}\n</code></pre><h3>ToString</h3><p>我们来看ToString trait 定义。</p><pre><code class=\"language-plain\">trait ToString {\n    fn to_string(&amp;self) -&gt; String;\n}\n</code></pre><p>它提供了一个 to_string() 方法，方便把各种类型实例转换成字符串。但实际上不需要自己去给类型实现ToString trait，因为标准库已经给我们做了总实现（<a href=\"https://time.geekbang.org/column/article/723496\">第 9 讲</a>提到过），像下面这个样子。</p><pre><code class=\"language-plain\">impl&lt;T: Display&gt; ToString for T\n</code></pre><p>也就是说，凡是实现了Display的就实现了ToString。这两个功能本质是一样的，就是把类型转换成字符串表达。只不过Display侧重于展现，ToString侧重于类型转换。下面这个示例证明这两者是等价的。</p><pre><code class=\"language-plain\">#[test] // ✅\nfn display_point() {\n    let origin = Point::default();\n    assert_eq!(format!(\"{}\", origin), \"(0, 0)\");\n}\n#[test] // ✅\nfn point_to_string() {\n    let origin = Point::default();\n    assert_eq!(origin.to_string(), \"(0, 0)\");\n}\n#[test] // ✅\nfn display_equals_to_string() {\n    let origin = Point::default();\n    assert_eq!(format!(\"{}\", origin), origin.to_string());\n}\n</code></pre><p>所以把一个符合条件的类型实例转换成字符串有两种常用方法。</p><pre><code class=\"language-plain\">let s = format!(\"{}\", obj);\n// 或\nlet s = obj.to_string();\n</code></pre><h3>Debug</h3><p>Debug 跟 Display 很像，也主要是用于调试打印。打印就需要指定格式，区别在于Debug trait 是配对 <code>\"{:?}\"</code> 格式的，Display是配对 <code>\"{}\"</code> 的。它们本身都是将类型表示或转换成 String 类型。一般来说，Debug的排版信息比Display要多一点，因为它是给程序员调试用的，不是给最终用户看的。Debug还配套了一个美化版本格式 <code>\"{:#?}\"</code>，用来把类型打印得更具结构化一些，适合调试的时候查看，比如json结构会展开打印。</p><p>Rust标准库提供了Debug宏。一般来说，我们都是以这个宏为目标类型自动生成Debug trait，而不是由我们自己手动去实现，这一点和Display正好相对，std标准库里并没有提供一个 Display 宏，来帮助我们自动实现 Display trait，需要我们手动实现它。</p><p>再提醒你一下，Rust的类型能够自动被derive的条件是，它里面的每个元素都能被derive，比如下面这个结构体里的每个字段，都是i32类型的，这种基础类型在标准库里已经被实现过Debug trait了，所以可以直接在Point上做derive为Point类型实现Debug trait。这个原则适用于所有trait，后面不再赘述。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n</code></pre><h3>PartialEq和Eq</h3><p>如果一个类型上实现了PartialEq，那么它就能比较两个值是否相等。这种可比较性满足数学上的对称性和传递性，我们通过两个例子具体来看。</p><ul>\n<li>对称性（symmetry）：<code>a == b</code> 导出 <code>b == a</code>。</li>\n<li>传递性（transitivity）：<code>a == b &amp;&amp; b == c</code> 导出 <code>a == c</code>。</li>\n</ul><p>而Eq定义为PartialEq的subtrait，在PartialEq的对称性和传递性的基础上，又添加了自反性，也就是对所有 <code>a</code> 都有 <code>a == a</code>。最典型的就是Rust中的浮点数只实现了PartialEq，没实现Eq，因为根据IEEE的规范，浮点数中存在一个NaN，它不等于自己，也就是 NaN ≠ NaN。而对整数来说，PartialEq和Eq都实现了。</p><p>如果一个类型，它的所有字段都实现了PartialEq，那么使用标准库中定义的PartialEq派生宏，我们可以为目标类型自动实现可比较能力，用==号，或者用 <code>assert_eq!()</code> 做判断。</p><pre><code class=\"language-plain\">#[derive(PartialEq, Debug)]    // 注意这一句\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn example_assert(p1: Point, p2: Point) {\n    assert_eq!(p1, p2);        // 比较\n}\n\nfn example_compare_collections&lt;T: PartialEq&gt;(vec1: Vec&lt;T&gt;, vec2: Vec&lt;T&gt;) {\n    if vec1 == vec2 {    // 比较\n        // some code\n    } else {\n        // other code\n    }\n}\n</code></pre><h3>PartialOrd和Ord</h3><p>PartialOrd和PartialEq差不多，PartialEq只判断相等或不相等，PartialOrd在这个基础上进一步判断是小于、小于等于、大于还是大于等于。可以看到，它就是为排序功能准备的。</p><p>PartialOrd被定义为 PartialEq的subtrait。它们在类型上可以用过程宏一起derive实现。</p><pre><code class=\"language-plain\">#[derive(PartialEq, PartialOrd)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\n#[derive(PartialEq, PartialOrd)]\nenum Stoplight {\n    Red,\n    Yellow,\n    Green,\n}\n</code></pre><p>类似的，Ord 定义为 Eq + PartialOrd 的 subtrait。如果我们为一个类型实现了 Ord，那么对那个类型的所有值，我们可以做出一个严格的总排序，比如u8，我们可以严格地从0排到255，形成一个确定的从小到大的序列。</p><p>同样的，浮点数实现了 PartialOrd，但是没实现 Ord。</p><p>由于Ord严格的顺序性，如果一个类型实现了Ord，那么这个类型可以被用作BTreeMap或BTreeSet的key。</p><blockquote>\n<p>BTreeMap、BTreeSet：相对于HashMap和HashSet，是两种可排序结构。</p>\n</blockquote><p>示例：</p><pre><code class=\"language-plain\">use std::collections::BTreeSet;\n\n#[derive(Ord, PartialOrd, PartialEq, Eq)]  // 注意这一句，4个都写上\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn example_btreeset() {\n    let mut points = BTreeSet::new();\n    points.insert(Point { x: 0, y: 0 }); // 作key值插入\n}\n\n// 实现了Ord trait的类型的集合，可调用 .sort() 排序方法\nfn example_sort&lt;T: Ord&gt;(mut sortable: Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {\n    sortable.sort();\n    sortable\n}\n</code></pre><h3>运算符重载</h3><p>Rust提供了一个Add trait，用来对加号（+）做自定义，也就是运算符重载。</p><p>你可以看一下Add的定义，它带一个类型参数Rhs，这里的类型参数可以是任意名字，默认类型是Self，一个关联类型Output，一个方法add()。</p><pre><code class=\"language-plain\">trait Add&lt;Rhs = Self&gt; {\n    type Output;\n    fn add(self, rhs: Rhs) -&gt; Self::Output;\n}\n</code></pre><p>像下面我给出的这个示例一样去使用它就可以，非常简单。</p><pre><code class=\"language-plain\">struct Point {\n    x: i32,\n    y: i32,\n}\n\n// 为 Point 类型实现 Add trait，这样两个Point实例就可以直接相加\nimpl Add for Point {\n    type Output = Point;\n    fn add(self, rhs: Point) -&gt; Point {\n        Point {\n            x: self.x + rhs.x,\n            y: self.y + rhs.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 1, y: 2 };\n    let p2 = Point { x: 3, y: 4 };\n    let p3 = p1 + p2; // 这里直接用+号作用在两个Point实例上\n    assert_eq!(p3.x, p1.x + p2.x); // ✅\n    assert_eq!(p3.y, p1.y + p2.y); // ✅\n}\n</code></pre><p>实际上，Rust标准库提供了一套完整的与运算符对应的trait，你在<a href=\"https://doc.rust-lang.org/std/ops/index.html\">这里</a>可以找到可重载的运算符。你可以按类似的方式练习如何自定义各种运算符。</p><h3>Clone</h3><p>定义：</p><pre><code class=\"language-plain\">trait Clone {\n    fn clone(&amp;self) -&gt; Self;\n}\n</code></pre><p>这个trait给目标类型提供了clone()方法用来完整地克隆实例。使用标准库里面提供的Clone派生宏可以方便地为目标类型实现Clone trait。</p><p>比如：</p><pre><code class=\"language-plain\">#[derive(Clone)]\nstruct Point {\n    x: u32,\n    y: u32,\n}\n</code></pre><p>因为每一个字段（u32类型）都实现了Clone，所以通过derive，自动为Point类型实现了Clone trait。实现后，Point的实例 point 使用 point.clone() 就可以把自己克隆一份了。</p><p>通过方法的签名，可以看到方法使用的是实例的不可变引用。</p><pre><code class=\"language-plain\">    fn clone(&amp;self) -&gt; Self;\n</code></pre><p>这里面有两种情况。</p><ul>\n<li>第一种是已经拿到实例的所有权，clone一份生成一个新的所有权并被局部变量所持有。</li>\n<li>第二种是只拿到一个实例的引用，想拿到它的所有权，如果这个类型实现了Clone trait，那么就可以clone一份拿到这个所有权。</li>\n</ul><p>clone() 是对象的深度拷贝，可能会有比较大的额外负载，但是就大多数情况来说其实还好。不要担心在Rust中使用clone()，先把程序功能跑通最重要。Rust的代码，性能一般都不会太差，毕竟起点很高。</p><p><span class=\"reference\">注：浅拷贝是按值拷贝一块连续的内存，只复制一层，不会去深究这个值里面是否有到其它内存资源的引用。与之相对，深拷贝就会把这些引用对象递归全部拷贝。</span></p><p>在Rust生态的代码中，我们经常看到clone()。为什么呢？因为它把对实例引用的持有转换成了对对象所有权的持有。一旦我们拿到了所有权，很多代码写起来就比较轻松了。</p><h3>Copy</h3><p>接下来，我们看Copy trait的定义。</p><pre><code class=\"language-plain\">trait Copy: Clone {}\n</code></pre><p>定义为Clone的subtrait，并且不包含任何内容，仅仅是一个标记（marker）。有趣的是，我们不能自己为自定义类型实现这个trait。比如下面这个示例就是不行的。</p><pre><code class=\"language-plain\">impl Copy for Point {} // 这是不行的\n</code></pre><p>但是Rust标准库提供了Copy过程宏，可以让我们自动为目标类型实现Copy trait。</p><pre><code class=\"language-plain\">#[derive(Copy, Clone)]\nstruct SomeType;\n</code></pre><p>因为Copy是Clone的subtrait。所以理所当然要把Clone trait也一起实现，我们在这里一次性derive过来。</p><p>Copy和Clone的区别是，Copy是浅拷贝只复制一层，不会去深究这个值里面是否有到其他内存资源的引用，比如一个字符串的动态数组。</p><pre><code class=\"language-plain\">struct Atype {\n&nbsp; &nbsp; num: u32,\n&nbsp; &nbsp; a_vec: Vec&lt;u32&gt;,\n}\nfn main() {\n&nbsp; &nbsp; let a = Atype {\n&nbsp; &nbsp; &nbsp; &nbsp; num: 100,&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; a_vec: vec![10, 20, 30],\n&nbsp; &nbsp; };\n&nbsp; &nbsp; let b = a;  // 这里发生了移动\n}\n</code></pre><p>代码第10行的操作是将a的所有权移动给b（<a href=\"https://time.geekbang.org/column/article/718916\">第 2 讲</a>的内容）。<br>\n如果我们给这个结构体实现了Clone trait的话，我们可以调用.clone() 来产生一份新的所有权。</p><pre><code class=\"language-plain\">#[derive(Clone, Debug)]\nstruct Atype {\n&nbsp; &nbsp; num: u32,\n&nbsp; &nbsp; a_vec: Vec&lt;u32&gt;,    // 动态数组资源在堆内存中\n}\nfn main() {\n&nbsp; &nbsp; let a = Atype {\n&nbsp; &nbsp; &nbsp; &nbsp; num: 100,&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; a_vec: vec![10, 20, 30],\n&nbsp; &nbsp; };\n&nbsp; &nbsp; let mut b = a.clone();  // 克隆，也将堆内存中的Vec资源部分克隆了一份\n&nbsp; &nbsp; b.num = 200;            // 更改b的值\n&nbsp; &nbsp; b.a_vec[0] = 11;\n&nbsp; &nbsp; b.a_vec[1] = 21;\n&nbsp; &nbsp; b.a_vec[2] = 31;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; println!(\"{a:?}\");  // 对比两份值\n&nbsp; &nbsp; println!(\"{b:?}\");\n}\n// 输出 \nAtype { num: 100, a_vec: [10, 20, 30] }\nAtype { num: 200, a_vec: [11, 21, 31] }\n</code></pre><p>通过例子可以看到，clone()一份新的所有权出来，b改动的值不影响a的值。</p><p>而一旦你想在 Atype 上实现 Copy trait的话，就会报错。</p><pre><code class=\"language-plain\">error[E0204]: the trait `Copy` cannot be implemented for this type\n&nbsp;--&gt; src/main.rs:1:10\n&nbsp; |\n1 | #[derive(Copy, Clone, Debug)]\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^\n...\n4 |&nbsp; &nbsp; &nbsp;a_vec: Vec&lt;u32&gt;,&nbsp; &nbsp; // 动态数组资源在堆内存中\n&nbsp; |&nbsp; &nbsp; &nbsp;--------------- this field does not implement `Copy`\n</code></pre><p>它说动态数组字段 a_vec 没有实现Copy trait，所以你不能对Atype实现Copy trait。原因也好理解，Vec是一种所有权结构，如果你在它上面实现了Copy，那再赋值的时候，就会出现对同一份资源的两个指向，冲突了！</p><p>一旦一个类型实现了Copy，它就会具备一个特别重要的特性：<strong>再赋值的时候会复制一份自身</strong>。那么就相当于新创建一份所有权。我们来看下面这个值全在栈上的类型。</p><pre><code class=\"language-plain\">#[derive(Clone)]\nstruct Point {\n    x: u32,\n    y: u32,\n}\n\nfn main() {\n  let a = Point {x: 10, y: 10};\n  let b = a; // 这里发生了所有权move，a在后续不能使用了\n}\n</code></pre><p>我们对 Point 实现Clone和Copy。</p><pre><code class=\"language-plain\">#[derive(Copy, Clone)]\nstruct Point {\n    x: u32,\n    y: u32,\n}\n\nfn main() {\n  let a = Point {x: 10, y: 10};\n  let b = a; // 这里发生了复制，a在后续可以继续使用\n  let c = a; // 这里又复制了一份，这下有3份了\n}\n</code></pre><p>仔细体会一下，现在你知道我们在第2讲里面讲到的复制与移动的语义区别根源在哪里了吧！</p><p>你可能会问，Point结构体里面的字段其实全都是固定尺寸的，并且u32是copy语义的，按理说Point也是编译时已知固定尺寸的，为什么它默认不实现copy语义呢？</p><p>这其实是Rust设计者故意这么做的。因为Copy trait其实关联到赋值语法，仅仅从这个语法（let a = b;），很难一下子看出来这到底是copy还是move，它是一种<strong>隐式行为</strong>。</p><p>而在所有权的第一设计原则框架下，Rust默认选择了move语义。所以方便起见，Rust设计者就只让最基础的那些类型，比如u32、bool等具有copy语义。而用户自定义的类型，一概默认move语义。如果用户想给自定义类型赋予copy语义内涵，那么他需要显式地在那个类型上添加Copy的derive。</p><p>我们再回过头来看Clone，一个类型实现了Clone后，需要显式地调用 .clone() 方法才会导致对象克隆，这就在代码里面留下了足迹。而如果一个类型实现了Copy，那么它在用 = 号对实例再赋值的时候就发生了复制，这里缺少了附加的足迹。这就为潜在的Bug以及性能的降低埋下了隐患，并且由于没有附加足迹，导致后面再回头来审查的时候非常困难。</p><p>试想，如果是.clone()，那么我们只需要用代码搜索工具搜索代码哪些地方出现了clone函数就可以了。这个设计，在 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 的 <code>unwrap()</code> 系列函数上也有体现。</p><p><strong>显式地留下足迹，是Rust语言设计重要的哲学之一</strong>。</p><p>至于Copy为什么要定义成Clone的subtrait，而不是反过来，也是跟这个设计哲学相关。可以这么说，一般情况下，Rust鼓励优先使用Clone而不鼓励使用Copy，于是让开发者在derive Copy的时候，也必须derive Clone，相当于多打了几个字符，多付出了一点代价。也许开发者这时会想，可能Clone就能满足我的要求了，能在结构体上的derive宏里面少打几个字符，也是一件好事儿。</p><p>还有一个原因其实是，Clone和Copy在本质上其实是一样的，都是内存的按位复制，只是复制的规则有一些区别。</p><h3>ToOwned</h3><p>ToOwned相当于是Clone更宽泛的版本。ToOwned给类型提供了一个 <code>to_owned()</code> 方法，可以将引用转换为所有权实例。</p><p>常见的比如：</p><pre><code class=\"language-plain\">let a: &amp;str = \"123456\";\nlet s: String = a.to_owned();\n</code></pre><p>通过查看标准库和第三方库接口文档，你可以确定有没实现这个trait。</p><h3>Deref</h3><p>Deref trait可以用来把一种类型转换成另一种类型，但是要在引用符号&amp;、点号操作符 . 或其他智能指针的触发下才会产生转换。比如标准库里最常见的 &amp;String 可以自动转换到 &amp;str（请回顾<a href=\"https://time.geekbang.org/column/article/720426\">第 4 讲</a>），就是因为String类型实现了Deref trait。</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/46/6ec1b4f409fe430b14884d66a9354d46.jpg?wh=1931x981\" alt=\"11-2\"></p><p>还有 <code>&Vec&lt;T&gt;</code> 可以自动转换为 <code>&[T]</code>，也是因为 <code>Vec[T]</code> 实现了Deref。</p><p><img src=\"https://static001.geekbang.org/resource/image/80/58/801214ebaf258a873326b7cc047c1b58.jpg?wh=2101x1282\" alt=\"11-1\"></p><p>到这里，Rust里很多魔法就开始揭开神秘面纱了。有了这些trait以及在各种类型上的实现，Rust让我们可以写出顺应直觉、赏心悦目、功能强大的代码。</p><p>你还可以在标准库文档中搜索Deref，查阅所有实现了Deref trait的 <a href=\"https://doc.rust-lang.org/std/ops/trait.Deref.html#implementors\">implementors</a>。</p><p>这里需要提醒你一下，有人尝试<a href=\"https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md#deref--derefmut\">用 Deref 机制去实现 OOP 继承</a>，但是那是徒劳和不完整的，有兴趣的话你可以看一下我给出的链接。</p><h3>Drop</h3><p>Drop trait用于给类型做自定义垃圾清理（回收）。</p><pre><code class=\"language-plain\">trait Drop {\n    fn drop(&amp;mut self);\n}\n</code></pre><p>实现了这个trait的类型的实例在走出作用域的时候，触发调用drop()方法，这个调用发生在这个实例被销毁之前。你可以看一下它的使用方式。</p><pre><code class=\"language-plain\">struct A;\nimpl Drop for A {\n  fn drop(&amp;mut self){\n    // 可以尝试在这里打印点东西看看什么时候调用\n  }\n}\n</code></pre><p>一般来说，我们不需要为自己的类型实现这个trait，除非遇到特殊情况，比如我们要调用外部的C库函数，然后在C那边分配了资源，由C库里的函数负责释放，这个时候我们就要在Rust的包装类型（对C库中类型的包装）上实现Drop，并调用那个C库中释放资源的函数。课程最后两讲FFI编程中，你会看到Drop的具体使用。</p><h3>闭包相关trait</h3><p>标准库中有3个trait与闭包相关，分别是FnOnce、FnMut、Fn。你可以看一下它们的定义。</p><pre><code class=\"language-plain\">trait FnOnce&lt;Args&gt; {\n    type Output;\n    fn call_once(self, args: Args) -&gt; Self::Output;\n}\ntrait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {\n    fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;\n}\ntrait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {\n    fn call(&amp;self, args: Args) -&gt; Self::Output;\n}\n</code></pre><p>前面我们也讲过，闭包就是一种能捕获上下文环境变量的函数。</p><pre><code class=\"language-plain\">let range = 0..10;\nlet get_range_count = || range.count();  \n</code></pre><p>代码里的这个 get_range_count 就是闭包，range是被这个闭包捕获的环境变量。</p><p>虽然说它是一种函数，但是不通过fn进行定义。在Rust中，并不把这个闭包的类型处理成fn这种函数指针类型，而是有单独的类型定义。</p><p>那么，具体是什么类型呢？其实我们也不知道。闭包的类型是由Rust编译器在编译时确定的，并且在确定类型的时候要根据这个闭包捕获上下文环境变量时的行为来确定。</p><p>总的来说有三种行为（⚠️ 所有权三态再现）。</p><ol>\n<li>获取了上下文环境变量的所有权，对应 FnOnce。</li>\n<li>只获取了上下文环境变量的&amp;mut引用，对应 FnMut。</li>\n<li>只获取了上下文环境变量的&amp;引用，对应 Fn。</li>\n</ol><p>根据这三种不同的行为，Rust编译器在编译时把闭包生成为这三种不同类型中的一种。这三种不同类型的闭包，具体类型形式我们不知道，Rust没有暴露给我们。但是Rust给我们暴露了FnOnce、FnMut、Fn这3个trait，就刚好对应于那三种类型。结合我们前面讲到的trait object，就能在我们的代码中对那些类型进行描述了。</p><p>FnOnce代表的闭包类型只能被调用一次，比如；</p><pre><code class=\"language-plain\">fn main() {\n    let range = 0..10;\n    let get_range_count = || range.count();\n    assert_eq!(get_range_count(), 10); // ✅\n    get_range_count(); // ❌\n}\n</code></pre><p>再调用就报错了。</p><p>FnMut代表的闭包类型能被调用多次，并且能修改上下文环境变量的值，不过有一些副作用，在某些情况下可能会导致错误或者不可预测的行为。比如：</p><pre><code class=\"language-plain\">fn main() {\n    let nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13];\n    let mut min = i32::MIN;\n    let ascending = nums.into_iter().filter(|&amp;n| {\n        if n &lt;= min {\n            false\n        } else {\n            min = n;  // 这里修改了环境变量min的值\n            true\n        }\n    }).collect::&lt;Vec&lt;_&gt;&gt;();\n    assert_eq!(vec![0, 4, 8, 10, 15, 18], ascending); // ✅\n}\n</code></pre><p>Fn 代表的这类闭包能被调用多次，但是对上下文环境变量没有副作用。比如：</p><pre><code class=\"language-plain\">fn main() {\n    let nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13];\n    let min = 9;\n    let greater_than_9 = nums.into_iter().filter(|&amp;n| n &gt; min).collect::&lt;Vec&lt;_&gt;&gt;();\n    assert_eq!(vec![10, 15, 18, 13], greater_than_9); // ✅\n}\n</code></pre><p>另外，fn这种函数指针，用在不需要捕获上下文环境变量的场景，比如：</p><pre><code class=\"language-plain\">fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\nfn main() {\n    let mut fn_ptr: fn(i32) -&gt; i32 = add_one;  // 注意这里的类型定义\n    assert_eq!(fn_ptr(1), 2); // ✅\n    \n    // 如果一个闭包没有捕捉环境变量，它可以通过类型转换转成 fn 类型\n    fn_ptr = |x| x + 1; // same as add_one\n    assert_eq!(fn_ptr(1), 2); // ✅\n}\n</code></pre><h3><code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code></h3><p>接下来，我们看 Rust 标准库中的两个关联的 trait <code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code>，它们用于类型转换。<code>From&lt;T&gt;</code> 可以把类型T转为自己，而<code>Into&lt;T&gt;</code> 可以把自己转为类型T。</p><pre><code class=\"language-plain\">trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\ntrait Into&lt;T&gt; {\n    fn into(self) -&gt; T;\n}\n</code></pre><p>可以看到它们是互逆的trait。实际上，Rust只允许我们实现 <code>From&lt;T&gt;</code>，因为实现了From后，自动就实现了Into，请看标准库里的这个实现。</p><pre><code class=\"language-plain\">impl&lt;T, U&gt; Into&lt;U&gt; for T\nwhere\n    U: From&lt;T&gt;,\n{\n    fn into(self) -&gt; U {\n        U::from(self)\n    }\n}\n</code></pre><p>对一个类型实现了From后，就可以像下面这样约束和使用。</p><pre><code class=\"language-plain\">fn function&lt;T&gt;(t: T)\nwhere\n    // 下面这两种约束是等价的\n    T: From&lt;i32&gt;,\n    i32: Into&lt;T&gt;\n{\n    // 等价\n    let example: T = T::from(0);\n    let example: T = 0.into();\n}\n</code></pre><p>我们来举一个具体的例子。</p><pre><code class=\"language-plain\">struct Point {\n    x: i32,\n    y: i32,\n}\nimpl From&lt;(i32, i32)&gt; for Point {    // 实现从(i32, i32)到Point的转换\n    fn from((x, y): (i32, i32)) -&gt; Self {\n        Point { x, y }\n    }\n}\nimpl From&lt;[i32; 2]&gt; for Point {      // 实现从[i32; 2]到Point的转换\n    fn from([x, y]: [i32; 2]) -&gt; Self {\n        Point { x, y }\n    }\n}\nfn example() {\n    // 使用from()转换不同类型\n    let origin = Point::from((0, 0));\n    let origin = Point::from([0, 0]);\n    // 使用into()转换不同类型\n    let origin: Point = (0, 0).into();\n    let origin: Point = [0, 0].into();\n}\n</code></pre><p>其实From是单向的。对于两个类型要互相转的话，是需要互相实现From的。</p><p>本身，<code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code> 都隐含了所有权，<code>From&lt;T&gt;</code> 的Self是具有所有权的，<code>Into&lt;T&gt;</code> 的T也是具有所有权的。<code>Into&lt;T&gt;</code> 有个常用的比 <code>From&lt;T&gt;</code> 更自然的场景是，如果你已经拿到了一个变量，想把它变成具有所有权的值，Into写起来更顺手。因为 <code>into()</code> 是方法，而 <code>from()</code> 是关联函数。</p><p>比如：</p><pre><code class=\"language-plain\">struct Person {\n    name: String,\n}\nimpl Person {\n    // 这个方法只接收String参数\n    fn new1(name: String) -&gt; Person {\n        Person { name }\n    }\n    // 这个方法可接收 \n    // - String\n    // - &amp;String\n    // - &amp;str\n    // - Box&lt;str&gt;\n    // - char\n    // 这几种参数，因为它们都实现了Into&lt;String&gt;\n    fn new2&lt;N: Into&lt;String&gt;&gt;(name: N) -&gt; Person {\n        Person { name: name.into() }  // 调用into()，写起来很简洁\n    }\n}\n</code></pre><h3>TryFrom TryInto</h3><p><code>TryFrom&lt;T&gt;</code> 和 <code>TryInto&lt;T&gt;</code> 是 <code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code> 的可失败版本。如果你认为转换可能会出现失败的情况，就选择这两个trait来实现。</p><pre><code class=\"language-plain\">trait TryFrom&lt;T&gt; {\n    type Error;\n    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;\n}\n\ntrait TryInto&lt;T&gt; {\n    type Error;\n    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;\n}\n</code></pre><p>可以看到，调用 <code>try_from()</code> 和 <code>try_into()</code> 后返回的是Result，你需要对Result进行处理。</p><h3>FromStr</h3><p>从字符串类型转换到自身。</p><pre><code class=\"language-plain\">trait FromStr {\n    type Err;\n    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;\n}\n</code></pre><p>其实我们前面已经遇到过这个trait，它就是字符串的 <code>parse()</code> 方法背后的trait。</p><pre><code class=\"language-plain\">use std::str::FromStr;\n\nfn example&lt;T: FromStr&gt;(s: &amp;str) {\n    // 下面4种表达等价\n    let t: Result&lt;T, _&gt; = FromStr::from_str(s);\n    let t = T::from_str(s);\n    let t: Result&lt;T, _&gt; = s.parse();\n    let t = s.parse::&lt;T&gt;(); // 最常用的写法\n}\n</code></pre><h3><code>AsRef&lt;T&gt;</code></h3><p><code>AsRef&lt;T&gt;</code> 的定义类似下面这个样子：</p><pre><code class=\"language-plain\">trait AsRef&lt;T&gt; {\n    fn as_ref(&amp;self) -&gt; &amp;T;\n}\n</code></pre><p>它把自身的引用转换成目标类型的引用。和Deref的区别是，<code>**deref()</code>是隐式调用的，而<code>as_ref()</code>需要你显式地调用**。所以代码会更清晰，出错的机会也会更少。</p><p><code>AsRef&lt;T&gt;</code> 可以让函数参数中传入的类型更加多样化，不管是引用类型还是具有所有权的类型，都可以传递。比如；</p><pre><code class=\"language-plain\">// 使用 &amp;str 作为参数可以接收下面两种类型\n//  - &amp;str\n//  - &amp;String\nfn takes_str(s: &amp;str) {\n    // use &amp;str\n}\n// 使用 AsRef&lt;str&gt; 作为参数可以接受下面三种类型\n//  - &amp;str\n//  - &amp;String\n//  - String\nfn takes_asref_str&lt;S: AsRef&lt;str&gt;&gt;(s: S) {\n    let s: &amp;str = s.as_ref();\n    // use &amp;str\n}\nfn example(slice: &amp;str, borrow: &amp;String, owned: String) {\n    takes_str(slice);\n    takes_str(borrow);\n    takes_str(owned); // ❌\n    takes_asref_str(slice);\n    takes_asref_str(borrow);\n    takes_asref_str(owned); // ✅\n}\n</code></pre><p>在这个例子里，具有所有权的String字符串也可以直接传入参数中了，相对于 &amp;str 的参数类型表达更加扩展了一步。</p><p>你可以把 Deref 看成是隐式化（或自动化）+弱化版本的 <code>AsRef&lt;T&gt;</code>。</p><h2>小结</h2><p>这节课我们快速过了一遍标准库里最常见的一些trait，内容比较多。你可以先有个印象，后面遇到的时候再回过头来查阅。</p><p><img src=\"https://static001.geekbang.org/resource/image/18/70/189778d381ce4bbe1e25e0426fc82a70.jpg?wh=2972x1472\" alt=\"\"></p><p>这些trait非常重要，它们一起构成了Rust生态宏伟蓝图的基础。很多前面讲到的一些神奇的“魔法”都在这节课揭开了面纱。trait这种设计真的给Rust带来了强大的表达力和灵活性，对它理解越深刻，越能体会Rust的厉害。trait完全解构了从C++、Java以来编程语言的发展范式，从紧耦合转换成松散的平铺式，让新特性的添加不会对语言本身造成沉重的负担。</p><p>到这节课为止，我们的第一阶段基础篇的学习就完成了。我们用11讲的内容详细介绍了Rust语言里最重要的部分，然而还有很多Rust的细节没办法展开，这需要你借助我提供的链接还有已有的资料持续学习。</p><p>基础篇相当于苦练内功，从下节课开始我们进入进阶篇，学习Rust语言及生态中面向实际场景的外功招式。</p><h2>思考题</h2><p>请举例说明 <code>Deref</code> 与 <code>AsRef&lt;T&gt;</code> 的区别。欢迎你把你思考后的答案分享到评论区，我们一起讨论，也欢迎你把这节课的内容分享给其他朋友，邀他一起学习Rust，我们下节课再见！</p>","neighbors":{"left":{"article_title":"10｜再探trait：带类型参数的trait及trait object","id":724776},"right":{"article_title":"12｜智能指针：从所有权看智能指针","id":725815}},"comments":[{"had_liked":false,"id":387065,"user_name":"飞了的鸭子被煮了","can_delete":false,"product_type":"c1","uid":3813080,"ip_address":"美国","ucode":"5781D69934D956","user_header":"https://static001.geekbang.org/account/avatar/00/3a/2e/d8/7beb49a4.jpg","comment_is_top":false,"comment_ctime":1706344281,"is_pvip":false,"replies":[{"id":141123,"content":"🈶意思👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1706771761,"ip_address":"重庆","comment_id":387065,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"asref: A 到 B，\nderef：B回到A","like_count":4,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636707,"discussion_content":"🈶意思👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706771762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385753,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1003156,"ip_address":"上海","ucode":"4060B4E2EF1D13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/94/0b22b6a2.jpg","comment_is_top":false,"comment_ctime":1703239765,"is_pvip":false,"replies":[{"id":140630,"content":"👏","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703577698,"ip_address":"重庆","comment_id":385753,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"Deref 和 AsRef&lt;T&gt; 是 Rust 中用于类型转换的 trait。\n\nDeref trait 允许你重载解引用操作符 *，使得一个类型可以被像指针一样解引用。这样可以方便地访问类型内部的数据。当你对一个实现了 Deref trait 的类型使用解引用操作符时，编译器会自动调用 Deref trait 中的 deref 方法来获取对应的值。\n\nAsRef&lt;T&gt; trait 则是用于将一个类型转换为另一个类型的引用。它提供了一个 as_ref 方法，该方法返回一个指向目标类型的引用。这在需要将一个类型转换为另一个类型的引用时非常有用，例如将字符串转换为字节切片。\n\n总结一下区别：\n\nDeref trait 用于重载解引用操作符 *，使得一个类型可以被像指针一样解引用。\nAsRef&lt;T&gt; trait 用于将一个类型转换为另一个类型的引用。\n在使用上，如果你需要对一个类型进行解引用操作，你可以实现 Deref trait。如果你需要将一个类型转换为另一个类型的引用，你可以实现 AsRef&lt;T&gt; trait。","like_count":3,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634496,"discussion_content":"👏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703577698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386246,"user_name":"Zoom 6","can_delete":false,"product_type":"c1","uid":3247738,"ip_address":"江苏","ucode":"377A1D3ABCD705","user_header":"","comment_is_top":false,"comment_ctime":1704377701,"is_pvip":false,"replies":[{"id":140791,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704435661,"ip_address":"重庆","comment_id":386246,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"Deref 是重载了运算符，AsRef是做的类型转换","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635129,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704435661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387806,"user_name":"兰天白云","can_delete":false,"product_type":"c1","uid":1009155,"ip_address":"海南","ucode":"D41F1C52A7BFBC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/03/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1708595858,"is_pvip":false,"replies":[{"id":141260,"content":"方法由实例调用，用 . ，关联函数由类型调用，用 :: ，区别不在有没有返回值。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1708815259,"ip_address":"加拿大","comment_id":387806,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师，您在讲到from和into的时候，说“因为 into() 是方法，而 from() 是关联函数。”，而在trait声明里都是有返回值的呀？该怎样理解呢？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637681,"discussion_content":"方法由实例调用，用 . ，关联函数由类型调用，用 :: ，区别不在有没有返回值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708815259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386040,"user_name":"My dream","can_delete":false,"product_type":"c1","uid":1077733,"ip_address":"四川","ucode":"2FEFB344230C17","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/e5/bcdc382a.jpg","comment_is_top":false,"comment_ctime":1703890065,"is_pvip":false,"replies":[{"id":140730,"content":"可以看看这篇. https:&#47;&#47;blog.rust-lang.org&#47;inside-rust&#47;2023&#47;05&#47;03&#47;stabilizing-async-fn-in-trait.html  \n还有刚发布的稳定版本: https:&#47;&#47;blog.rust-lang.org&#47;2023&#47;12&#47;28&#47;Rust-1.75.0.html\n用法跟单独写 async fn 现在是一样的.","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704171062,"ip_address":"重庆","comment_id":386040,"utype":1}],"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"能讲一下在trait中如何使用async fn吗？我还不会使用","like_count":0},{"had_liked":false,"id":385458,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1702637644,"is_pvip":false,"replies":[{"id":140564,"content":"哈哈。gpt4有趣的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703123366,"ip_address":"重庆","comment_id":385458,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"as_ref 没印象了， 找gpt4看了看， 总结了下核心就这俩：\n\n- implicit vs explicit\n    - Deref trait 自动运行， `*T` 直接触发 deref()， 看起来像是隐式触发\n    - AsRef trait 需要显式调用 as_ref()\n- 功能不同（我看到这条的时候都愣了， 这谁不知道， 为撒还算是 key diff）\n    - Deref 是解引用的\n    - AsRef 是创建引用的","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634240,"discussion_content":"哈哈。gpt4有趣的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703123366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383862,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"广东","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1699837299,"is_pvip":false,"replies":[{"id":139988,"content":"不能，Rust编译器就是要让你多写一点。文中有说明类似的原因。主要是怕你滥用。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699846542,"ip_address":"重庆","comment_id":383862,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"请问下面这一句，能否只写Ord和Eq？Ord是PartialOrd的超集, Eq是PartialEq的超集。 编译器应该可以判断出，已经实现了Ord和Eq，当然也肯定实现了PartialOrd和PartialEq。\n#[derive(Ord, PartialOrd, PartialEq, Eq)] &#47;&#47; 注意这一句，4个都写上","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631616,"discussion_content":"不能，Rust编译器就是要让你多写一点。文中有说明类似的原因。主要是怕你滥用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699846542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383856,"user_name":"杨赛军","can_delete":false,"product_type":"c1","uid":1050917,"ip_address":"北京","ucode":"12F314F9E6F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/25/2db95c79.jpg","comment_is_top":false,"comment_ctime":1699830290,"is_pvip":false,"replies":[{"id":139986,"content":"有这个意思在里面，Deref需要通过其它操作符隐式触发，如 &amp;, . 等，并且做的是自动 &amp; 操作。 ","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699846474,"ip_address":"重庆","comment_id":383856,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"Deref 不能传递所有权变量，Asref可以传递所有权变量","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631614,"discussion_content":"有这个意思在里面，Deref需要通过其它操作符隐式触发，如 &amp;, . 等，并且做的是自动 &amp; 操作。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699846474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385457,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1702637034,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"笔记\n\n1. Deref trait =&gt; 给 typeA 实现了 Deref trait 之后就可以 *typeAinstance 了\n\n2. deref coercion =&gt; 我们要对 obj_0 做一些事情的时候， 如果发现 obj_0 不适配， 就试一下 *obj_0, 看看它的 deref 是否适配， 如果适配， 就对 deref result 搞事， 如果不适配， 就继续找 deref, 直到当前 obj 没有 deref 为止\n","like_count":2},{"had_liked":false,"id":392867,"user_name":"Logical_Monster","can_delete":false,"product_type":"c1","uid":3896502,"ip_address":"美国","ucode":"2FA30CED203261","user_header":"https://static001.geekbang.org/account/avatar/00/3b/74/b6/42e74b6d.jpg","comment_is_top":false,"comment_ctime":1722002417,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"运算符重载那里的代码应该改为，直接那样写main函数会有所有权问题：\nuse std::ops::Add;\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\n&#47;&#47; 为 Point 类型实现 Add trait，这样两个Point实例就可以直接相加\nimpl Add for Point {\n    type Output = Point;\n    fn add(self, rhs: Point) -&gt; Point {\n        Point {\n            x: self.x + rhs.x,\n            y: self.y + rhs.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 1, y: 2 };\n    let p2 = Point { x: 3, y: 4 };\n    let p3 = p1 + p2;\n    \n    println!(&quot;{:?}&quot;, p3); &#47;&#47; Output: Point { x: 4, y: 6 }\n    assert_eq!(p3, Point { x: 4, y: 6 });\n}","like_count":0},{"had_liked":false,"id":389215,"user_name":"周鹏","can_delete":false,"product_type":"c1","uid":1301143,"ip_address":"福建","ucode":"3BDD7C9785AEC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/da/97/e421b1ae.jpg","comment_is_top":false,"comment_ctime":1711867727,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"struct Point {\n    x: i32,\n    y: i32,\n}\n\n&#47;&#47; 为 Point 类型实现 Add trait，这样两个Point实例就可以直接相加\nimpl Add for Point {\n    type Output = Point;\n    fn add(self, rhs: Point) -&gt; Point {\n        Point {\n            x: self.x + rhs.x,\n            y: self.y + rhs.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 1, y: 2 };\n    let p2 = Point { x: 3, y: 4 };\n    let p3 = p1 + p2; &#47;&#47; 这里直接用+号作用在两个Point实例上\n&#47;&#47;这里move了\n    assert_eq!(p3.x, p1.x + p2.x); &#47;&#47; ✅\n&#47;&#47;这里不能再用会报错\n    assert_eq!(p3.y, p1.y + p2.y); &#47;&#47; ✅\n&#47;&#47;这里不能用\n}","like_count":0},{"had_liked":false,"id":389213,"user_name":"周鹏","can_delete":false,"product_type":"c1","uid":1301143,"ip_address":"福建","ucode":"3BDD7C9785AEC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/da/97/e421b1ae.jpg","comment_is_top":false,"comment_ctime":1711867298,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"struct Point {\n    x: i32,\n    y: i32,\n}\n\n&#47;&#47; 为 Point 类型实现 Add trait，这样两个Point实例就可以直接相加\n&#47;&#47; 建议加上\nimpl std::ops::Add for Point {\n    type Output = Point;\n    fn add(self, rhs: Point) -&gt; Point {\n        Point {\n            x: self.x + rhs.x,\n            y: self.y + rhs.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 1, y: 2 };\n    let p2 = Point { x: 3, y: 4 };\n    let p3 = p1 + p2; &#47;&#47; 这里直接用+号作用在两个Point实例上\n    assert_eq!(p3.x, p1.x + p2.x); &#47;&#47; ✅\n    assert_eq!(p3.y, p1.y + p2.y); &#47;&#47; ✅\n}","like_count":0}]}