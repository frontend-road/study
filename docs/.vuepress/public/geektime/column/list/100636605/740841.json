{"id":740841,"title":"第 4 章 条件分支控制流","content":"\n<p>从某种角度来看，编程这件事，其实就是把真实世界里的逻辑用代码的方式书写出来。</p>\n<p>而真实世界里的逻辑通常很复杂，包含许许多多先决条件和结果分支，无法用一句简单的“因为……所以……”来概括。如果画成地图，这些逻辑不会是只有几条高速公路的郊区，而更像是包含无数个岔路口的闹市区。</p>\n<p>为了表现这些真实世界里的复杂逻辑，程序员们写出了一条条分支语句。比如简单的“如果用户是会员，跳过广告播放”：</p>\n<pre class=\"code-rows\"><code>if user.is_active_member():\n    skip_ads()\n    return True\nelse:\n    print('你不是会员，无法跳过广告。')\n    return False</code></pre>\n<p>或者复杂一些的：</p>\n<pre class=\"code-rows\"><code>if user.is_active_member():\n    if user.membership_expires_in(30):\n        print('会员将在 30 天内过期，请及时续费，将在 3 秒后跳过广告')\n        skip_ads_with_delay(3)\n        return True\n\n    skip_ads()\n    return True\nelif user.region != 'CN':\n    print('非中国区无法跳过广告')\n    return False\nelse:\n    print('你不是会员，无法跳过广告。')\n    return False</code></pre>\n<p>当条件分支变得越来越复杂，代码的可读性也会变得越来越差。所以，掌握如何写出好的条件分支代码非常重要，它可以帮助我们用更简洁、更清晰的代码来表达复杂逻辑。本章将会谈谈如何在 Python 中写出更好的条件分支代码。</p>\n<h2 id=\"nav_point_71\">4.1　基础知识</h2>\n<h3 id=\"nav_point_72\">4.1.1　分支惯用写法</h3>\n<p>在 Python 里写条件分支语句，听上去是件挺简单的事。这是因为严格说来 Python 只有一种条件分支语法——<code>if</code>/<code>elif</code>/<code>else</code><span class=\"comment-number\">1</span>：</p>\n\n<pre class=\"code-rows\"><code># 标准条件分支语句\nif condition:\n    ...\nelif another_condition:\n    ...\nelse:\n    ...</code></pre>\n<p>当我们编写分支时，第一件要注意的事情，就是不要显式地和布尔值做比较：</p>\n<pre class=\"code-rows\"><code># 不推荐的写法\n# if user.is_active_member() == True:\n\n# 推荐写法\nif user.is_active_member():</code></pre>\n<p>绝大多数情况下，在分支判断语句里写 <code>== True</code> 都没有必要，删掉它代码会更短也更易读。但这条原则也有例外，比如你确实想让分支仅当值是 <code>True</code> 时才执行。不过即便这样，写 <code>if &lt;expression&gt; == True</code> 仍然是有问题的，我会在 4.1.3 节解释这一点。</p>\n<ol>\n<li><p><strong>省略零值判断</strong></p>\n<p>当你编写 <code>if</code> 分支时，如果需要判断某个类型的对象是否是零值，可能会把代码写成下面这样：</p>\n<pre class=\"code-rows\"><code>if containers_count == 0:\n    ...\n\nif fruits_list != []:\n    ...</code></pre>\n<p>这种判断语句其实可以变得更简单，因为当某个对象作为主角出现在 <code>if</code> 分支里时，解释器会主动对它进行“真值测试”，也就是调用 <code>bool()</code> 函数获取它的布尔值。而在计算布尔值时，每类对象都有着各自的规则，比如整型和列表的规则如下：</p>\n<pre class=\"code-rows\"><code># 数字 0 的布尔值为 False，其他值为 True\n&gt;&gt;&gt; bool(0), bool(123)\n(False, True)\n\n# 空列表的布尔值为 False，其他值为 True\n&gt;&gt;&gt; bool([]), bool([1, 2, 3])\n(False, True)</code></pre>\n<p>正因如此，当我们需要在条件语句里做空值判断时，可以直接把代码简写成下面这样：</p>\n<pre class=\"code-rows\"><code>if not containers_count:\n    ...\n\nif fruits_list:\n    ...</code></pre>\n<p>这样的条件判断更简洁，也更符合 Python 社区的习惯。不过在你使用这种写法时，请不要忘记一点，这样写其实隐晦地放宽了分支判断的成立条件：</p>\n<pre class=\"code-rows\"><code># 更精准：只有为 0 的时候，才会满足分支条件\nif containers_count == 0:\n    ....\n\n# 更宽泛：当 containers_count 的值为 0、None、空字符串等时，都可以满足分支条件\nif not containers_count:\n    ...</code></pre>\n<p>请时刻注意，不要因为过度追求简写而引入其他逻辑问题。</p>\n<p>除整型外，其他内置类型的布尔值规则如下。</p>\n<ul>\n<li><strong>布尔值为假</strong>：<code>None</code>、<code>0</code>、<code>False</code>、<code>[]</code>、<code>()</code>、<code>{}</code>、<code>set()</code>、<code>frozenset()</code>，等等。</li>\n<li><strong>布尔值为真</strong>：非 <code>0</code> 的数值、<code>True</code>，非空的序列、元组、字典，用户定义的类和实例，等等。</li>\n</ul>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>把否定逻辑移入表达式内</strong></p>\n<p>在构造布尔逻辑表达式时，你可以用 <code>not</code> 关键字来表达“否定”含义：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; i = 10\n&gt;&gt;&gt; i &gt; 8\nTrue\n&gt;&gt;&gt; not i &gt; 8\nFalse</code></pre>\n<p>不过在写代码时，我们有时会过于喜欢用 <code>not</code> 关键字，反倒忘记了运算符本身就可以表达否定逻辑。最后，代码里会出现许多下面这种判断语句：</p>\n<pre class=\"code-rows\"><code>if not number &lt; 10:\n    ...\n\nif not current_user is None:\n    ...\n\nif not index == 1:\n    ...</code></pre>\n<p>这样的代码，就好比你在看到一个人沿着楼梯往上走时，不说“他在上楼”，而非说“他在做和下楼相反的事情”。如果把否定逻辑移入表达式内，它们通通可以改成下面这样：</p>\n<pre class=\"code-rows\"><code>if number &gt;= 10:\n    ...\n\nif current_user is not None:\n    ...\n\nif index != 1:\n    ...</code></pre>\n<p>这样的代码逻辑表达得更直接，也更好理解。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>尽可能让三元表达式保持简单</strong></p>\n<p>除了标准分支外，Python 还为我们提供了一种浓缩版的条件分支——三元表达式：</p>\n<pre class=\"code-rows\"><code># 语法：\n# true_value if &lt;expression&gt; else false_value\nlanguage = \"python\" if you.favor(\"dynamic\") else \"golang\"</code></pre>\n<p>当你在编写三元表达式时，请参考 3.3.6 节的两个“不要”里的建议，不要盲目追求用一个表达式来表达过于复杂的逻辑。有时，平淡普通的分支语句远远胜过花哨复杂的三元表达式。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_73\">4.1.2　修改对象的布尔值</h3>\n<p>上一节提过，当我们把某个对象用于分支判断时，解释器会对它进行“真值测试”，计算出它的布尔值，而所有用户自定义的类和类实例的计算结果都是 <code>True</code>：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; class Foo:\n...     pass\n...\n&gt;&gt;&gt; bool(Foo)\nTrue\n&gt;&gt;&gt; bool(Foo())\nTrue</code></pre>\n<p>这个现象符合逻辑，但有时会显得有点儿死板。如果我们稍微改动一下这个默认行为，就能写出更优雅的代码。</p>\n<p>看看下面这个例子：</p>\n<pre class=\"code-rows\"><code>class UserCollection:\n    \"\"\"用于保存多个用户的集合工具类\"\"\"\n\n    def __init__(self, users):\n        self.items = users\n\nusers = UserCollection(['piglei', 'raymond'])\n\n# 仅当用户列表里面有数据时，打印语句\nif len(users.items) &gt; 0:\n    print(\"There's some users in collection!\")</code></pre>\n<p>在上面这段代码里，我需要判断 <code>users</code> 对象是否真的有内容，因此里面的分支判断语句用到了 <code>len(users.items) &gt; 0</code> 这样的表达式：判断对象内 <code>items</code> 的长度是否大于 0。</p>\n<p>但其实，上面的分支判断语句可以变得更简单。只要给 <code>UserCollection</code> 类实现 <code>__len__</code> 魔法方法，<code>users</code> 对象就可以直接用于“真值测试”：</p>\n<pre class=\"code-rows\"><code>class UserCollection:\n    \"\"\"用于保存多个用户的集合工具类\"\"\"\n\n    def __init__(self, users):\n        self.items = users\n\n    def __len__(self):\n        return len(self.items)\n\nusers = UserCollection(['piglei', 'raymond'])\n\n# 不再需要手动判断对象内部 items 的长度\nif users:\n    print(\"There's some users in collection!\")</code></pre>\n<p>为类定义 <code>__len__</code> 魔法方法，实际上就是为它实现了 Python 世界的长度协议：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; users = UserCollection([])\n&gt;&gt;&gt; len(users)\n0\n&gt;&gt;&gt; users = UserCollection(['piglei', 'raymond'])\n&gt;&gt;&gt; len(users)\n2</code></pre>\n<p>Python 在计算这类对象的布尔值时，会受 <code>len(users)</code> 的结果影响——假如长度为 <code>0</code>，布尔值为 <code>False</code>，反之为 <code>True</code>。因此当例子中的 <code>UserCollection</code> 类实现了 <code>__len__</code> 后，整个条件判断语句就得到了简化。</p>\n<p>不过，定义 <code>__len__</code> 并非影响布尔值结果的唯一办法。除了 <code>__len__</code> 以外，还有一个魔法方法 <code>__bool__</code> 和对象的布尔值息息相关。</p>\n<p>为对象定义 <code>__bool__</code> 方法后，对它进行布尔值运算会直接返回该方法的调用结果。举个例子：</p>\n<pre class=\"code-rows\"><code>class ScoreJudger:\n    \"\"\"仅当分数大于 60 时为真\"\"\"\n\n    def __init__(self, score):\n        self.score = score\n\n    def __bool__(self):\n        return self.score &gt;= 60</code></pre>\n<p>执行结果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; bool(ScoreJudger(60))\nTrue\n&gt;&gt;&gt; bool(ScoreJudger(59))\nFalse</code></pre>\n<p>假如一个类同时定义了 <code>__len__</code> 和 <code>__bool__</code> 两个方法，解释器会优先使用 <code>__bool__</code> 方法的执行结果。</p>\n<h3 id=\"nav_point_74\">4.1.3　与 <code>None</code> 比较时使用 <code>is</code> 运算符</h3>\n<p>当我们需要判断两个对象是否相等时，通常会使用双等号运算符 <code>==</code>，它会对比两个值是否一致，然后返回一个布尔值结果，示例如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; x, y, z = 1, 1, 2\n&gt;&gt;&gt; x == y\nTrue\n&gt;&gt;&gt; x == z\nFalse</code></pre>\n<p>但对于自定义对象来说，它们在进行 <code>==</code> 运算时行为是可操纵的：只要实现类型的 <code>__eq__</code> 魔法方法就行。</p>\n<p>举个例子：</p>\n<pre class=\"code-rows\"><code>class EqualWithAnything:\n    \"\"\"与任何对象相等\"\"\"\n\n    def __eq__(self, other):\n        # 方法里的 other 方法代表 == 操作时右边的对象，比如\n        # x == y 会调用 x 的 __eq__ 方法，other 的参数为 y\n        return True</code></pre>\n<p>上面定义的 <code>EqualWithAnything</code> 对象，在和任何东西做 <code>==</code> 计算时都会返回 <code>True</code>：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; foo = EqualWithAnything()\n&gt;&gt;&gt; foo == 'string'\nTrue</code></pre>\n<p>当然也包括 <code>None</code>：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; foo == None\nTrue</code></pre>\n<p>既然 <code>==</code> 的行为可被魔法方法改变，那我们如何严格检查某个对象是否为 <code>None</code> 呢？答案是使用 <code>is</code> 运算符。虽然二者看上去差不多，但有着本质上的区别：</p>\n<p>(1) <code>==</code> 对比两个对象的值是否相等，行为可被 <code>__eq__</code> 方法重载；</p>\n<p>(2) <code>is</code> 判断两个对象是否是内存里的同一个东西，<strong>无法被重载</strong>。</p>\n<p>换句话说，当你在执行 <code>x is y</code> 时，其实就是在判断 <code>id(x)</code> 和 <code>id(y)</code> 的结果是否相等，二者是否是同一个对象。</p>\n<p>因此，当你想要判断某个对象是否为 <code>None</code> 时，应该使用 <code>is</code> 运算符：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; foo = EqualWithAnything()\n&gt;&gt;&gt; foo == None\nTrue\n\n# is 的行为无法被重载\n&gt;&gt;&gt; foo is None\nFalse\n\n# 有且仅有真正的 None 才能通过 is 判断\n&gt;&gt;&gt; x = None\n&gt;&gt;&gt; x is None\nTrue</code></pre>\n<p>到这里也许你想问，既然 <code>is</code> 在进行比较时更严格，为什么不把所有相等判断都用 <code>is</code> 来替代呢？</p>\n<p>这是因为，除了 <code>None</code>、<code>True</code> 和 <code>False</code> 这三个内置对象以外，其他类型的对象在 Python 中并不是严格以单例模式存在的。换句话说，即便值一致，它们在内存中仍然是完全不同的两个对象。</p>\n<p>拿整型举例：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; x = 6300\n&gt;&gt;&gt; y = 6300\n&gt;&gt;&gt; x is y\nFalse\n\n# 它们在内存中是不同的两个对象\n&gt;&gt;&gt; id(x), id(y)\n(4412016144, 4412015856)\n\n# 进行值判断会返回相等\n&gt;&gt;&gt; x == y\nTrue</code></pre>\n<p>因此，仅当你需要判断某个对象是否是 <code>None</code>、<code>True</code>、<code>False</code> 时，使用 <code>is</code>，其他情况下，请使用 <code>==</code>。</p>\n<blockquote>\n<p><strong>令人迷惑的整型驻留技术</strong></p>\n<p>假如我们稍微调整一下上面的代码，把数字从 6300 改成 100，会获得完全相反的执行结果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; x = 100\n&gt;&gt;&gt; y = 100\n&gt;&gt;&gt; x is y\nTrue\n\n# 二者 id 相等，在内存中是同一个对象\n&gt;&gt;&gt; id(x), id(y)\n(4302453136, 4302453136)</code></pre>\n<p>为什么会这样？这是因为 Python 语言使用了一种名为“整型驻留”（integer interning）的底层优化技术。</p>\n<p>对于从 -5 到 256 的这些常用小整数，Python 会将它们缓存在内存里的一个数组中。当你的程序需要用到这些数字时，Python 不会创建任何新的整型对象，而是会返回缓存中的对象。这样能为程序节约可观的内存。</p>\n<p>除了整型以外，Python 对字符串也有类似的“驻留”操作。如果你对这方面感兴趣，可自行搜索“Python integer/string interning”关键字了解更多内容。</p>\n</blockquote>\n<h2 id=\"nav_point_75\">4.2　案例故事</h2>\n<p>假如把写代码比喻成翻译文章，那么我们在代码中写下许多 <code>if</code>/<code>else</code> 分支，就仅仅是在对真实逻辑做一种不假思索的“直译”。此时如果转换一下思路，这些直译的分支代码也许能完全消失，代码会变得更紧凑、更具扩展性，整个编码过程更像一种巧妙的“意译”，而非“直译”。</p>\n<p>在下面这个故事里，我会通过重构一个电影评分脚本，向你展示从“直译”变为“意译”的有趣过程。</p>\n<h3 id=\"nav_point_76\">消失的分支</h3>\n<p>我是一名狂热的电影评分爱好者。一天，我从一个电影论坛上下载了一份数据文件，其中包含了许多新老电影的名称、年份、IMDB<span class=\"comment-number\">2</span> 评分信息。</p>\n\n<p>我用 Python 提取出了文件里的电影信息数据，将其转换成了字典类型，数据格式如代码清单 4-1 所示。</p>\n<blockquote>\n<p><strong>代码清单 4-1</strong>　电影评分数据</p>\n</blockquote>\n<pre class=\"code-rows\"><code>movies = [\n    {'name': 'The Dark Knight', 'year': 2008, 'rating': '9'},\n    {'name': 'Kaili Blues', 'year': 2015, 'rating': '7.3'},\n...\n]</code></pre>\n<p>为了更好地利用这份数据，我想要编写一个小工具，它可以做到：</p>\n<p>(1) 按评分 <code>rating</code> 的值把电影划分为 S、A、B、C 等不同级别；</p>\n<p>(2) 按照指定顺序，比如年份从新到旧、评分从高到低等，打印这些电影信息。</p>\n<p>工具的功能确定后，接下来进行编码实现。</p>\n<p>现在的电影数据是<strong>字典</strong>（dict）格式的，处理起来不是很方便。于是，我首先创建了一个类：<code>Movie</code>，用来存放与电影数据和封装电影有关的操作。有了 <code>Movie</code> 类后，我在里面定义了 <code>rank</code> 属性对象，并在 <code>rank</code> 内实现了按评分计算级别的逻辑。</p>\n<p><code>Movie</code> 类的代码如代码清单 4-2 所示。</p>\n<blockquote>\n<p><strong>代码清单 4-2</strong>　电影评分脚本中 <code>Movie</code> 类的代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>class Movie:\n    \"\"\"电影对象数据类\"\"\"\n\n    def __init__(self, name, year, rating):\n        self.name = name\n        self.year = year\n        self.rating = rating\n\n    @property\n    def rank(self):\n        \"\"\"按照评分对电影分级：\n\n        - S: 8.5 分及以上\n        - A：8 ~ 8.5 分\n        - B：7 ~ 8 分\n        - C：6 ~ 7 分\n        - D：6 分以下\n        \"\"\"\n        rating_num = float(self.rating)\n        if rating_num &gt;= 8.5:\n            return 'S'\n        elif rating_num &gt;= 8:\n            return 'A'\n        elif rating_num &gt;= 7:\n            return 'B'\n        elif rating_num &gt;= 6:\n            return 'C'\n        else:\n            return 'D'</code></pre>\n<p>实现了按照分数评级后，接下来便是排序功能。</p>\n<p>对电影列表排序，这件事乍听上去很难，但好在 Python 为我们提供了一个好用的内置函数：<code>sorted()</code>。借助它，我可以很便捷地完成排序操作。我新建了一个名为 <code>get_sorted_movies()</code> 的排序函数，它接收两个参数：电影列表（<code>movies</code>）和排序选项（<code>sorting_type</code>），返回排序后的电影列表作为结果。</p>\n<p><code>get_sorted_movies()</code> 函数的代码如代码清单 4-3 所示。</p>\n<blockquote>\n<p><strong>代码清单 4-3</strong>　电影评分脚本中的 <code>get_sorted_movies()</code> 函数</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def get_sorted_movies(movies, sorting_type):\n    \"\"\"对电影列表进行排序并返回\n\n    :param movies: Movie 对象列表\n    :param sorting_type: 排序选项，可选值\n        name（名称）、rating（评分）、year（年份）、random（随机乱序）\n    \"\"\"\n    if sorting_type == 'name':\n        sorted_movies = sorted(movies, key=lambda movie: movie.name.lower())\n    elif sorting_type == 'rating':\n        sorted_movies = sorted(\n            movies, key=lambda movie: float(movie.rating), reverse=True\n        )\n    elif sorting_type == 'year':\n        sorted_movies = sorted(\n            movies, key=lambda movie: movie.year, reverse=True\n        )\n    elif sorting_type == 'random':\n        sorted_movies = sorted(movies, key=lambda movie: random.random())\n    else:\n        raise RuntimeError(f'Unknown sorting type: ')\n    return sorted_movies</code></pre>\n<p>为了把上面这些代码串起来，我在 <code>main()</code> 函数里实现了接收排序选项、解析电影数据、排序并打印电影列表等功能，如代码清单 4-4 所示。</p>\n<blockquote>\n<p><strong>代码清单 4-4</strong>　电影评分脚本中的 <code>main()</code> 函数</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def main():\n    # 接收用户输入的排序选项\n    sorting_type = input('Please input sorting type: ')\n    if sorting_type not in all_sorting_types:\n        print(\n            'Sorry, \"{}\" is not a valid sorting type, please choose from '\n            '\"{}\", exit now'.format(\n                sorting_type,\n                '/'.join(all_sorting_types),\n            )\n        )\n        return\n\n    # 初始化电影数据对象\n    movie_items = []\n    for movie_json in movies:\n        movie = Movie(**movie_json)\n        movie_items.append(movie)\n\n    # 排序并输出电影列表\n    sorted_movies = get_sorted_movies(movie_items, sorting_type)\n    for movie in sorted_movies:\n        print(\n            f'- [] () | rating: '\n        )</code></pre>\n<p>这个脚本的最终执行效果如下：</p>\n<pre class=\"code-rows\"><code># 按评分排序，每一行结果的 [S] 代表电影评分级别\n$ python movies_ranker.py\nPlease input sorting type: rating\n- [S] The Shawshank Redemption (1994) | rating: 9.3\n- [S] The Dark Knight(2008) | rating: 9\n- [A] Citizen Kane(1941) | rating: 8.3\n\n# 按年份排序\n$ python movies_ranker.py\nPlease input sorting type: year\n- [C] Project Gutenberg(2018) | rating: 6.9\n- [B] Burning(2018) | rating: 7.5\n- [B] Kaili Blues(2015) | rating: 7.3</code></pre>\n<p>看上去还不错，对吧？只要短短的 100 行不到的代码，一个小工具就完成了。不过，虽然这个工具实现了我最初设想的功能，在它的源码里却藏着<strong>两大段可以简化的条件分支代码</strong>。如果使用恰当的方式，这些分支语句可以彻底从代码中消失。</p>\n<p>我们来看看怎么做吧。</p>\n<ol>\n<li><p><strong>使用 <code>bisect</code> 优化范围类分支判断</strong></p>\n<p>第一个需要优化的分支，藏在 <code>Movie</code> 类的 <code>rank</code> 方法属性中：</p>\n<pre class=\"code-rows\"><code>@property\ndef rank(self):\n    rating_num = float(self.rating)\n    if rating_num &gt;= 8.5:\n        return 'S'\n    elif rating_num &gt;= 8:\n        return 'A'\n    elif rating_num &gt;= 7:\n        return 'B'\n    elif rating_num &gt;= 6:\n        return 'C'\n    else:\n        return 'D'</code></pre>\n<p>仔细观察这段分支代码，你会发现它里面藏着一个明显的规律。</p>\n<p>在每个 <code>if</code>/<code>elif</code> 语句后，都跟着一个评分的分界点。这些分界点把评分划分成不同的分段，当 <code>rating_num</code> 落在某个分段时，函数就会返回该分段所代表的“S/A/B/C”等级。简而言之，这十几行分支代码的主要任务，就是为 <code>rating_num</code> 在这些分段里寻找正确的位置。</p>\n<p>要优化这段代码，我们得先把所有分界点收集起来，放在一个元组里：</p>\n<pre class=\"code-rows\"><code># 已经排好序的评级分界点\nbreakpoints = (6, 7, 8, 8.5)</code></pre>\n<p>接下来要做的事，就是根据 <code>rating</code> 的值，判断它在 <code>breakpoints</code> 里的位置。</p>\n<p>要实现这个功能，最直接的做法是编写一个循环——通过遍历元组 <code>breakpoints</code> 里的所有分界点，我们就能找到 <code>rating</code> 在其中的位置。但除此之外，其实还有更简单的办法。因为 <code>breakpoints</code> 已经是一个排好序的元组，所以我们可以直接使用 <code>bisect</code> 模块来实现查找功能。</p>\n<p><code>bisect</code> 是 Python 内置的二分算法模块，它有一个同名函数 <code>bisect</code>，可以用来在有序列表里做二分查找：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; import bisect\n# 注意：用来做二分查找的容器必须是已经排好序的\n&gt;&gt;&gt; breakpoints = [10, 20, 30]\n\n# bisect 函数会返回值在列表中的位置，0 代表相应的值位于第一个元素 10 之前\n&gt;&gt;&gt; bisect.bisect(breakpoints, 1)\n0\n# 3 代表相应的值位于第三个元素 30 之后\n&gt;&gt;&gt; bisect.bisect(breakpoints, 35)\n3</code></pre>\n<p>将分界点定义成元组，并引入 <code>bisect</code> 模块后，之前的十几行分支代码可以简化成下面这样：</p>\n<pre class=\"code-rows\"><code>@property\ndef rank(self):\n    # 已经排好序的评级分界点\n    breakpoints = (6, 7, 8, 8.5)\n    # 各评分区间级别名\n    grades = ('D', 'C', 'B', 'A', 'S')\n\n    index = bisect.bisect(breakpoints, float(self.rating))\n    return grades[index]</code></pre>\n<p>优化完 <code>rank</code> 方法后，程序中还有另一段待优化的条件分支代码—— <code>get_sorted_movies()</code> 函数里的排序方式选择逻辑。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用字典优化分支代码</strong></p>\n<p>在 <code>get_sorted_movies()</code> 函数里，同样有一大段条件分支代码。它们负责根据 <code>sorting_type</code> 的值，为函数选择不同的排序方式：</p>\n<pre class=\"code-rows\"><code>def get_sorted_movies(movies, sorting_type):\n    if sorting_type == 'name':\n        sorted_movies = sorted(movies, key=lambda movie: movie.name.lower())\n    elif sorting_type == 'rating':\n        sorted_movies = sorted(\n            movies, key=lambda movie: float(movie.rating), reverse=True\n        )\n    elif sorting_type == 'year':\n        sorted_movies = sorted(\n            movies, key=lambda movie: movie.year, reverse=True\n        )\n    elif sorting_type == 'random':\n        sorted_movies = sorted(movies, key=lambda movie: random.random())\n    else:\n        raise RuntimeError(f'Unknown sorting type: ')\n    return sorted_movies</code></pre>\n<p>这段代码有两个非常明显的特点。</p>\n<p>(1) 它用到的条件表达式都非常类似，都是对 <code>sorting_type</code> 做等值判断（<code>sorting_type == 'name'</code>）。</p>\n<p>(2) 它的每个分支的内部逻辑也大同小异——都是调用 <code>sorted()</code> 函数，只是 <code>key</code> 和 <code>reverse</code> 参数略有不同。</p>\n<p>如果一段条件分支代码同时满足这两个特点，我们就可以用字典类型来简化它。因为 Python 的字典可以装下任何对象，所以我们可以把各个分支下不同的东西——排序的 <code>key</code> 函数和 <code>reverse</code> 参数，直接放进字典里：</p>\n<pre class=\"code-rows\"><code>sorting_algos = {\n    # sorting_type: (key_func, reverse)\n    'name': (lambda movie: movie.name.lower(), False),\n    'rating': (lambda movie: float(movie.rating), True),\n    'year': (lambda movie: movie.year, True),\n    'random': (lambda movie: random.random(), False),\n}</code></pre>\n<p>有了这份字典以后，我们的 <code>get_sorted_movies()</code> 函数就可以改写成下面这样：</p>\n<pre class=\"code-rows\"><code>def get_sorted_movies(movies, sorting_type):\n    \"\"\"对电影列表进行排序并返回\n\n    :param movies: Movie 对象列表\n    :param sorting_type: 排序选项，可选值\n        name（名称）、rating（评分）、year（年份）、random（随机乱序）\n    \"\"\"\n    sorting_algos = {\n        # sorting_type: (key_func, reverse)\n        'name': (lambda movie: movie.name.lower(), False),\n        'rating': (lambda movie: float(movie.rating), True),\n        'year': (lambda movie: movie.year, True),\n        'random': (lambda movie: random.random(), False),\n    }\n    try:\n        key_func, reverse = sorting_algos[sorting_type]\n    except KeyError:\n        raise RuntimeError(f'Unknown sorting type: ')\n\n    sorted_movies = sorted(movies, key=key_func, reverse=reverse)\n    return sorted_movie</code></pre>\n<p>相比之前的大段 <code>if</code>/<code>elif</code>，新代码变得整齐了许多，扩展性也更强。如果要增加新的排序算法，我们只需要在 <code>sorting_algos</code> 字典里增加新成员即可。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>优化成果</strong></p>\n<p>通过引入 <code>bisect</code> 模块和算法字典，案例开头的小工具代码最终优化成了代码清单 4-5。</p>\n<blockquote>\n<p><strong>代码清单 4-5</strong>　重构后的电影评分脚本 movies_ranker_v2.py</p>\n</blockquote>\n<pre class=\"code-rows\"><code>import bisect\nimport random\n\nclass Movie:\n    \"\"\"电影对象数据类\"\"\"\n\n    def __init__(self, name, year, rating):\n        self.name = name\n        self.year = year\n        self.rating = rating\n\n    @property\n    def rank(self):\n        \"\"\"\n        按照评分对电影分级\n        \"\"\"\n        # 已经排好序的评级分界点\n        breakpoints = (6, 7, 8, 8.5)\n        # 各评分区间级别名\n        grades = ('D', 'C', 'B', 'A', 'S')\n\n        index = bisect.bisect(breakpoints, float(self.rating))\n        return grades[index]\n　\n　\ndef get_sorted_movies(movies, sorting_type):\n    \"\"\"对电影列表进行排序并返回\n\n    :param movies: Movie 对象列表\n    :param sorting_type: 排序选项，可选值\n        name（名称）、rating（评分）、year（年份）、random（随机乱序）\n    \"\"\"\n    sorting_algos = {\n        # sorting_type: (key_func, reverse)\n        'name': (lambda movie: movie.name.lower(), False),\n        'rating': (lambda movie: float(movie.rating), True),\n        'year': (lambda movie: movie.year, True),\n        'random': (lambda movie: random.random(), False),\n    }\n    try:\n        key_func, reverse = sorting_algos[sorting_type]\n    except KeyError:\n        raise RuntimeError(f'Unknown sorting type: ')\n\n    sorted_movies = sorted(movies, key=key_func, reverse=reverse)\n    return sorted_movies</code></pre>\n<p>在这个案例中，我们一共用到了两种优化分支的方法。虽然它们看上去不太一样，但代表的思想其实是类似的。</p>\n<p>当我们编写代码时，有时会下意识地编写一段段大同小异的条件分支语句。多数情况下，它们只是对业务逻辑的一种“直译”，是我们对业务逻辑的理解尚处在第一层的某种拙劣表现。</p>\n<p>如果进一步深入业务逻辑，尝试从中总结规律，那么这些条件分支代码也许就可以被另一种更精简、更易扩展的方式替代。当你在编写条件分支时，请多多思考这些分支背后所代表的深层需求，寻找简化它们的办法，进而写出更好的代码。</p>\n</li>\n</ol>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　除了这个故事中展示的两种方式外，面向对象的多态也是消除条件分支代码的一大利器。在 9.3.2 节中，你可以找到一个用多态来替代分支代码的例子。</p>\n</blockquote>\n<h2 id=\"nav_point_77\">4.3　编程建议</h2>\n<h3 id=\"nav_point_78\">4.3.1　尽量避免多层分支嵌套</h3>\n<p>如果你看完本章内容后，最终只能记住一句话，那么我希望那句话是：<strong>要竭尽所能地避免分支嵌套</strong>。</p>\n<p>在大家编写代码时，每当业务逻辑变得越来越复杂，条件分支通常也会越来越多、越嵌越深。以下面这段代码为例：</p>\n<pre class=\"code-rows\"><code>def buy_fruit(nerd, store):\n    \"\"\"去水果店买苹果操作手册：\n\n    - 先得看看店是不是在营业\n    - 如果有苹果，就买 1 个\n    - 如果钱不够，就回家取钱再来\n    \"\"\"\n    if store.is_open():\n        if store.has_stocks(\"apple\"):\n            if nerd.can_afford(store.price(\"apple\", amount=1)):\n                nerd.buy(store, \"apple\", amount=1)\n                return\n            else:\n                nerd.go_home_and_get_money()\n                return buy_fruit(nerd, store)\n        else:\n            raise MadAtNoFruit(\"no apple in store!\")\n    else:\n        raise MadAtNoFruit(\"store is closed!\")</code></pre>\n<p>这个 <code>buy_fruit()</code> 函数直接翻译了原始需求，短短十几行代码里就包含了三层分支嵌套。</p>\n<p>当代码有了多层分支嵌套后，可读性和可维护性就会直线下降。这是因为，读代码的人很难在深层嵌套里搞清楚，如果不满足某个条件到底会发生什么。此外，因为 Python 使用了空格缩进来表示分支语句，所以过深的嵌套也会占用过多的字符数，导致代码极易超过 PEP 8 所规定的每行字数限制。</p>\n<p>幸运的是，这些多层嵌套可以用一个简单的技巧来优化——“提前返回”。“提前返回”指的是：当你在编写分支时，首先找到那些会中断执行的条件，把它们移到函数的最前面，然后在分支里直接使用 <code>return</code> 或 <code>raise</code> 结束执行。</p>\n<p>使用这个技巧，前面的代码可以优化成下面这样：</p>\n<pre class=\"code-rows\"><code>def buy_fruit(nerd, store):\n    if not store.is_open():\n        raise MadAtNoFruit(\"store is closed!\")\n\n    if not store.has_stocks(\"apple\"):\n        raise MadAtNoFruit(\"no apple in store!\")\n\n    if nerd.can_afford(store.price(\"apple\", amount=1)):\n        nerd.buy(store, \"apple\", amount=1)\n        return\n    else:\n        nerd.go_home_and_get_money()\n        return buy_fruit(nerd, store)</code></pre>\n<p>实践“提前返回”后，<code>buy_fruit()</code> 函数变得更扁平了，整个逻辑也变得更直接、更容易理解了。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　在“Python 之禅”里有一句：“扁平优于嵌套”（Flat is better than nested），这刚好说明了把嵌套分支改为扁平的重要性。</p>\n</blockquote>\n<h3 id=\"nav_point_79\">4.3.2　别写太复杂的条件表达式</h3>\n<p>假如某个分支的成立条件非常复杂，就连直接用文字描述都需要一大段，那当我们把它翻译成代码时，一个包含大量 <code>not</code>/<code>and</code>/<code>or</code> 的复杂表达式就会横空出世，看起来就像一个难懂的高等数学公式。</p>\n<p>下面这段代码就是一个例子：</p>\n<pre class=\"code-rows\"><code># 如果活动还在开放，并且活动剩余名额大于 10，为所有性别为女或者级别大于 3\n# 的活跃用户发放 10 000 个金币\nif (\n    activity.is_active\n    and activity.remaining &gt; 10\n    and user.is_active\n    and (user.sex == 'female' or user.level &gt; 3)\n):\n    user.add_coins(10000)\n    return</code></pre>\n<p>针对这种代码，我们需要对条件表达式进行简化，把它们封装成函数或者对应的类方法，这样才能提升分支代码的可读性：</p>\n<pre class=\"code-rows\"><code>if activity.allow_new_user() and user.match_activity_condition():\n    user.add_coins(10000)\n    return</code></pre>\n<p>进行恰当的封装后，之前大段的注释文字甚至可以直接删掉了，因为优化后的条件表达式已经表意明确了。至于“什么情况下允许新用户参与活动”“什么样的用户满足活动条件”这种更具体的问题，就交由 <code>allow_new_user()</code> / <code>match_activity_condition()</code> 这些方法来回答吧。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　封装不仅仅是用来提升可读性的可选操作，有时甚至是必须要做的事情。举个例子，当上面的活动判断逻辑在项目中多次出现时，假设缺少封装，那些复杂的条件表达式就会被不断地“复制粘贴”，彻底让代码变得不可维护。</p>\n</blockquote>\n<h3 id=\"nav_point_80\">4.3.3　尽量降低分支内代码的相似性</h3>\n<p>程序员们编写条件分支语句，是为了让代码在不同情况下执行不同的操作。</p>\n<p>但很多时候，这些不同的操作会因为一些逻辑上的相似性，导致代码也很类似。这种“类似”有几种表现形式，有时是完全重复的语句，有时则是调用函数时的重复参数。</p>\n<p>假如不同分支下的代码过于相似，读者就会很难理解代码的含义，因为他需要非常细心地区分不同分支下的行为究竟有什么差异。如果作者可以在编写代码时尽量降低这种相似性，就能有效提升可读性。</p>\n<p>举个简单的例子，下面代码里的不同分支下出现了重复语句：</p>\n<pre class=\"code-rows\"><code># 仅当分组处于活跃状态时，允许用户加入分组并记录操作日志\nif group.is_active:\n    user = get_user_by_id(request.user_id)\n    user.join(group)\n    log_user_activiry(user, target=group, type=ActivityType.JOINED_GROUP)\nelse:\n    user = get_user_by_id(request.user_id)\n    log_user_activiry(user, target=group, type=ActivityType.JOIN_GROUP_FAILED)</code></pre>\n<p>我们可以把重复代码移到分支外，尽量降低分支内代码的相似性：</p>\n<pre class=\"code-rows\"><code>user = get_user_by_id(request.user_id)\n\nif group.is_active:\n    user.join(group)\n    activity_type = UserActivityType.JOINED_GROUP\nelse:\n    activity_type = UserActivityType.JOIN_GROUP_FAILED\n\nlog_user_activiry(user, target=group, type=activity_type)</code></pre>\n<p>像上面这种重复的语句很容易发现，下面是一个隐蔽性更强的例子：</p>\n<pre class=\"code-rows\"><code># 创建或更新用户资料数据\n# 如果是新用户，创建新 Profile 数据，否则更新已有数据\nif user.no_profile_exists:\n    create_user_profile(\n        username=data.username,\n        gender=data.gender,\n        email=data.email,\n        age=data.age,\n        address=data.address,\n        points=0,\n        created=now(),\n    )\nelse:\n    update_user_profile(\n        username=data.username,\n        gender=data.gender,\n        email=data.email,\n        age=data.age,\n        address=data.address,\n        updated=now(),\n    )</code></pre>\n<p>在上面这段代码里，我们可以一眼看出，程序在两个分支下调用了不同的函数，做了不一样的事情。但因为那些重复的函数参数，我们很难一下看出二者的核心不同点到底是什么。</p>\n<p>为了降低这种相似性，我们可以使用 Python 函数的动态关键字参数（<code>**kwargs</code>）特性，简单优化一下上面的代码：</p>\n<pre class=\"code-rows\"><code>if user.no_profile_exists:\n    _update_or_create = create_user_profile\n    extra_args = {'points': 0, 'created': now()}\nelse:\n    _update_or_create = update_user_profile\n    extra_args = {'updated': now()}\n\n_update_or_create(\n    username=user.username,\n    gender=user.gender,\n    email=user.email,\n    age=user.age,\n    address=user.address,\n    **extra_args,\n)</code></pre>\n<p>降低不同分支内代码的相似性，可以帮助读者更快地领会它们之间的差异，进而更容易理解分支的存在意义。</p>\n<h3 id=\"nav_point_81\">4.3.4　使用“德摩根定律”</h3>\n<p>当我们需要表达包含许多“否定”的逻辑时，经常会写出下面这样的条件判断代码：</p>\n<pre class=\"code-rows\"><code># 如果用户没有登录或者用户没有使用 Chrome，拒绝提供服务\nif not user.has_logged_in or not user.is_from_chrome:\n    return \"our service is only available for chrome logged in user\"</code></pre>\n<p>当你第一眼看到代码时，是不是需要思考好一会儿，才能弄明白它想干什么？这是正常的，因为上面的逻辑表达式里同时用了 2 个 <code>not</code> 和 1 个 <code>or</code>，而人类恰巧不擅长处理这种有着过多“否定”的逻辑关系。</p>\n<p>这时就该“德摩根定律”闪亮登场了。简单来说，“德摩根定律”告诉了我们这么一件事：<strong><code>not A or not B</code> 等价于 <code>not (A and B)</code></strong>。</p>\n<p>因此，上面的代码可以改写成下面这样：</p>\n<pre class=\"code-rows\"><code>if not (user.has_logged_in and user.is_from_chrome):\n    return \"our service is only available for chrome logged in user\"</code></pre>\n<p>相比之前，新代码少了一个 <code>not</code> 关键字，变得好理解了不少。当你的代码出现太多“否定”时，请尝试用“德摩根定律”来化繁为简吧。</p>\n<h3 id=\"nav_point_82\">4.3.5　使用 <code>all()</code>/<code>any()</code> 函数构建条件表达式</h3>\n<p>在 Python 的众多内置函数中，有两个特别适合在构建条件表达式时使用，它们就是 <code>all()</code> 和 <code>any()</code>。这两个函数接收一个可迭代对象作为参数，返回一个布尔值结果。顾名思义，这两个函数的行为如下。</p>\n<ul>\n<li><code>all(iterable)</code>：仅当 <code>iterable</code> 中所有成员的布尔值都为真时返回 <code>True</code>，否则返回 <code>False</code>。</li>\n<li><code>any(iterable)</code>：只要 <code>iterable</code> 中任何一个成员的布尔值为真就返回 <code>True</code>，否则返回 <code>False</code>。</li>\n</ul>\n<p>举个例子，我需要判断一个列表里的所有数字是不是都大于 10，如果使用普通循环，代码得写成下面这样：</p>\n<pre class=\"code-rows\"><code>def all_numbers_gt_10(numbers):\n    \"\"\"仅当序列中所有数字都大于 10 时，返回 True\"\"\"\n    if not numbers:\n        return False\n\n    for n in numbers:\n        if n &lt;= 10:\n            return False\n    return True</code></pre>\n<p>但如果使用 <code>all()</code> 内置函数，同时配合一个简单的生成器表达式，上面的代码就可以简化成下面这样：</p>\n<pre class=\"code-rows\"><code>def all_numbers_gt_10_2(numbers):\n    return bool(numbers) and all(n &gt; 10 for n in numbers)</code></pre>\n<p>简单、高效，同时没有损失可读性。</p>\n<h3 id=\"nav_point_83\">4.3.6　留意 <code>and</code> 和 <code>or</code> 的运算优先级</h3>\n<p>我们经常用 <code>and</code> 和 <code>or</code> 运算符来构建逻辑表达式，那么你对它们足够了解吗？看看下面这两个表达式，猜猜它们返回的结果一样吗？</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; (True or False) and False\n&gt;&gt;&gt; True or False and False</code></pre>\n<p>答案是：不一样。这两个表达式的值分别是 <code>False</code> 和 <code>True</code>，你猜对了吗？</p>\n<p>出现这个结果的原因是：<code>and</code> 运算符的优先级高于 <code>or</code>。因此在 Python 看来，上面第二个表达式实际上等同于 <code>True or (False and False)</code>，所以最终结果是 <code>True</code> 而不是 <code>False</code>。</p>\n<p>当你要编写包含多个 <code>and</code> 和 <code>or</code> 运算符的复杂逻辑表达式时，请留意运算优先级问题。如果加上一些括号可以让逻辑变得更清晰，那就不要吝啬。</p>\n<h3 id=\"nav_point_84\">4.3.7　避开 <code>or</code> 运算符的陷阱</h3>\n<p><code>or</code> 运算符是构建逻辑表达式时的常客。<code>or</code> 最有趣的地方是它的“短路求值”特性。比如在下面的例子里，<code>1 / 0</code> 永远不会被执行，也就意味着不会抛出 <code>ZeroDivisionError</code> 异常：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; True or (1 / 0)\nTrue</code></pre>\n<p>正因为这个“短路求值”特性，在很多场景下，我们经常使用 <code>or</code> 来替代一些简单的条件判断语句，比如下面这个例子：</p>\n<pre class=\"code-rows\"><code>context = {}\n# 仅当 extra_context 不为 None 时，将其追加进 context 中\nif extra_context:\n    context.update(extra_context)</code></pre>\n<p>在上面这段代码里，<code>extra_context</code> 的值一般情况下会是一个字典，但有时也可能是 <code>None</code>。因此我加了一个条件判断语句：仅当值不为 <code>None</code> 时才做 <code>context.update()</code> 操作。</p>\n<p>如果使用 <code>or</code> 运算符，上面三行语句可以变得更简练：</p>\n<pre class=\"code-rows\"><code>context.update(extra_context or {})</code></pre>\n<p>因为 <code>a or b or c or ...</code> 这样的表达式，会返回这些变量里第一个布尔值为真的对象，直到最末一个为止，所以 <code>extra_context or {}</code> 表达式在对象不为空时就是 <code>extra_context</code> 自身，而当 <code>extra_context</code> 为 <code>None</code> 时就变成 <code>{}</code>。</p>\n<p>使用 <code>a or b</code> 来表示“ <code>a</code> 为空时用 <code>b</code> 代替”的写法非常常见，你在各种编程语言、各类项目源码里都能发现它的影子，但在这种写法下，其实藏着一个陷阱。</p>\n<p>因为 <code>or</code> 计算的是变量的布尔真假值，所以不光是 <code>None</code>，<code>0</code>、<code>[]</code>、<code>{}</code> 以及其他所有布尔值为假的东西，都会在 <code>or</code> 运算中被忽略：</p>\n<pre class=\"code-rows\"><code># 所有的 0、空列表、空字符串等，都是布尔假值\n&gt;&gt;&gt; bool(None), bool(0), bool([]), bool({}), bool(''), bool(set())\n(False, False, False, False, False, False)</code></pre>\n<p>如果忘记了 <code>or</code> 的这个特点，你可能就会碰到一些很奇怪的问题。拿下面这段代码来说：</p>\n<pre class=\"code-rows\"><code>timeout = config.timeout or 60</code></pre>\n<p>虽然它的目的是判断当 <code>config.timeout</code> 为 <code>None</code> 时，使用 <code>60</code> 作为默认值。但假如 <code>config.timeout</code> 的值被主动配置成 0 秒，<code>timeout</code> 也会因为上面的 <code>0 or 60 = 60</code> 运算被重新赋值为 60，正确的配置反而被忽略了。</p>\n<p>所以，这时使用 <code>if</code> 来进行精确的判断会更稳妥一些：</p>\n<pre class=\"code-rows\"><code>if config.timeout is None:\n    timeout = 60</code></pre>\n<h2 id=\"nav_point_85\">4.4　总结</h2>\n<p>本章我们学习了在 Python 中编写条件分支语句时的一些注意事项。基础知识部分介绍了分支语句的一些惯用写法，比如不要显式地和空值做比较，和 <code>None</code> 做相等判断时使用 <code>is</code> 运算符，等等。</p>\n<p>在编写分支代码时，最重要的一点是尽量避免多层分支嵌套，请谨记“扁平优于嵌套”。</p>\n<p>虽然这么说不一定准确，但错综复杂的分支语句，确实是让许多代码变得难以维护的罪魁祸首。有时，如果你在写代码时转换一下思路，也许会发现恼人的 <code>if</code>/<code>else</code> 分支其实可以被其他东西替代。当代码里的分支越少、分支越扁平、分支的判断条件越简单时，代码就越容易维护。</p>\n<p>以下是本章要点知识总结。</p>\n<p>(1) 条件分支语句惯用写法</p>\n<ul>\n<li>不要显式地和布尔值做比较</li>\n<li>利用类型本身的布尔值规则，省略零值判断</li>\n<li>把 <code>not</code> 代表的否定逻辑移入表达式内部</li>\n<li>仅在需要判断某个对象是否是 <code>None</code>、<code>True</code>、<code>False</code> 时，使用 <code>is</code> 运算符</li>\n</ul>\n<p>(2) Python 数据模型</p>\n<ul>\n<li>定义 <code>__len__</code> 和 <code>__bool__</code> 魔法方法，可以自定义对象的布尔值规则</li>\n<li>定义 <code>__eq__</code> 方法，可以修改对象在进行 <code>==</code> 运算时的行为</li>\n</ul>\n<p>(3) 代码可读性技巧</p>\n<ul>\n<li>不同分支内容易出现重复或类似的代码，把它们抽到分支外可提升代码的可读性</li>\n<li>使用“德摩根定律”可以让有多重否定的表达式变得更容易理解</li>\n</ul>\n<p>(4) 代码可维护性技巧</p>\n<ul>\n<li>尽可能让三元表达式保持简单</li>\n<li>扁平优于嵌套：使用“提前返回”优化代码里的多层分支嵌套</li>\n<li>当条件表达式变得特别复杂时，可以尝试封装新的函数和方法来简化</li>\n<li><code>and</code> 的优先级比 <code>or</code> 高，不要忘记使用括号来让逻辑更清晰</li>\n<li>在使用 <code>or</code> 运算符替代条件分支时，请注意避开因布尔值运算导致的陷阱</li>\n</ul>\n<p>(5) 代码组织技巧</p>\n<ul>\n<li><code>bisect</code> 模块可以用来优化范围类分支判断</li>\n<li>字典类型可以用来替代简单的条件分支语句</li>\n<li>尝试总结条件分支代码里的规律，用更精简、更易扩展的方式改写它们</li>\n<li>使用 <code>any()</code> 和 <code>all()</code> 内置函数可以让条件表达式变得更精简</li>\n</ul>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 3 章 容器类型(2)","id":740840},"right":{"article_title":"第 5 章 异常与错误处理","id":740842}},"comments":[{"had_liked":false,"id":390096,"user_name":"老巫","can_delete":false,"product_type":"c1","uid":1163803,"ip_address":"上海","ucode":"2EAD9D6FADCD97","user_header":"https://static001.geekbang.org/account/avatar/00/11/c2/1b/869727a5.jpg","comment_is_top":false,"comment_ctime":1714348017,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636605,"comment_content":"python 3.10以后不是有 match case 的写法吗。让多个条件判断可读性更好","like_count":0}]}