{"id":415988,"title":"08｜所有权：值的借用是如何工作的？","content":"<p>你好，我是陈天。</p><p>上一讲我们学习了 Rust 所有权的基本规则，在 Rust 下，值有单一的所有者。</p><p>当我们进行变量赋值、传参和函数返回时，如果涉及的数据结构没有实现 Copy trait，就会默认使用 Move 语义转移值的所有权，失去所有权的变量将无法继续访问原来的数据；如果数据结构实现了 Copy trait，就会使用 Copy 语义，自动把值复制一份，原有的变量还能继续访问。</p><p>虽然，单一所有权解决了其它语言中值被任意共享带来的问题，但也引发了一些不便。我们上一讲提到：<strong>当你不希望值的所有权被转移，又因为没有实现 Copy trait 而无法使用 Copy 语义，怎么办</strong>？你可以“借用”数据，也就是这一讲我们要继续介绍的 Borrow 语义。</p><h2>Borrow 语义</h2><p>顾名思义，Borrow 语义允许一个值的所有权，在不发生转移的情况下，被其它上下文使用。就好像住酒店或者租房那样，旅客/租客只有房间的临时使用权，但没有它的所有权。另外，Borrow 语义通过引用语法（&amp; 或者 &amp;mut）来实现。</p><p>看到这里，你是不是有点迷惑了，怎么引入了一个“借用”的新概念，但是又写“引用”语法呢？</p><p>其实，<strong>在 Rust 中，“借用”和“引用”是一个概念</strong>，只不过在其他语言中引用的意义和 Rust 不同，所以 Rust 提出了新概念“借用”，便于区分。</p><!-- [[[read_end]]] --><p>在其他语言中，引用是一种别名，你可以简单理解成鲁迅之于周树人，多个引用拥有对值的无差别的访问权限，本质上是共享了所有权；而在 Rust 下，所有的引用都只是借用了“临时使用权”，它并不破坏值的单一所有权约束。</p><p>因此<strong>默认情况下，Rust 的借用都是只读的</strong>，就好像住酒店，退房时要完好无损。但有些情况下，我们也需要可变的借用，就像租房，可以对房屋进行必要的装饰，这一点待会详细讲。</p><p>所以，如果我们想避免 Copy 或者 Move，可以使用借用，或者说引用。</p><h2>只读借用/引用</h2><p>本质上，引用是一个受控的指针，指向某个特定的类型。在学习其他语言的时候，你会注意到函数传参有两种方式：传值（pass-by-value）和传引用（pass-by-reference）。</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/6a/1b4ae03b5152226289092c95fd16786a.jpg?wh=2312x2043\" alt=\"\"></p><p>以 Java 为例，给函数传一个整数，这是传值，和 Rust 里的 Copy 语义一致；而给函数传一个对象，或者任何堆上的数据结构，Java 都会自动隐式地传引用。刚才说过，Java 的引用是对象的别名，这也导致随着程序的执行，同一块内存的引用到处都是，不得不依赖 GC 进行内存回收。</p><p>但 Rust 没有传引用的概念，<strong>Rust 所有的参数传递都是传值</strong>，不管是 Copy 还是 Move。所以在Rust中，你必须显式地把某个数据的引用，传给另一个函数。</p><p>Rust 的引用实现了 Copy trait，所以按照 Copy 语义，这个引用会被复制一份交给要调用的函数。对这个函数来说，它并不拥有数据本身，数据只是临时借给它使用，所有权还在原来的拥有者那里。</p><p>在 Rust里，引用是一等公民，和其他数据类型地位相等。</p><p>还是用上一讲有两处错误的 <a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=3d76a275e808fac6fcc88e21e0a0a05b\">代码2</a> 来演示。</p><pre><code class=\"language-rust\">fn main() {\n    let data = vec![1, 2, 3, 4];\n    let data1 = data;\n    println!(\"sum of data1: {}\", sum(data1));\n    println!(\"data1: {:?}\", data1); // error1\n    println!(\"sum of data: {}\", sum(data)); // error2\n}\n\nfn sum(data: Vec&lt;u32&gt;) -&gt; u32 {\n    data.iter().fold(0, |acc, x| acc + x)\n}\n</code></pre><p>我们把 <a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=3d76a275e808fac6fcc88e21e0a0a05b\">代码2</a> 稍微改变一下，通过添加引用，让编译通过，并查看值和引用的地址（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ce5222622af73c3463a84ba1f9121aa4\">代码3</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let data = vec![1, 2, 3, 4];\n    let data1 = &amp;data;\n    // 值的地址是什么？引用的地址又是什么？\n    println!(\n        \"addr of value: {:p}({:p}), addr of data {:p}, data1: {:p}\",\n        &amp;data, data1, &amp;&amp;data, &amp;data1\n    );\n    println!(\"sum of data1: {}\", sum(data1));\n\n    // 堆上数据的地址是什么？\n    println!(\n        \"addr of items: [{:p}, {:p}, {:p}, {:p}]\",\n        &amp;data[0], &amp;data[1], &amp;data[2], &amp;data[3]\n    );\n}\n\nfn sum(data: &amp;Vec&lt;u32&gt;) -&gt; u32 {\n    // 值的地址会改变么？引用的地址会改变么？\n    println!(\"addr of value: {:p}, addr of ref: {:p}\", data, &amp;data);\n    data.iter().fold(0, |acc, x| acc + x)\n}\n</code></pre><p>在运行这段代码之前，你可以先思考一下，data 对应值的地址是否保持不变，而 data1 引用的地址，在传给 sum() 函数后，是否还指向同一个地址。</p><p>好，如果你有想法了，可以再运行代码验证一下你是否正确，我们再看下图分析：</p><p><img src=\"https://static001.geekbang.org/resource/image/44/39/441678ea9318e9f159cac6b274aef239.jpg?wh=2312x2043\" alt=\"\"></p><p>data1、&amp;data 和传到 sum() 里的 data1’ 都指向 data 本身，这个值的地址是固定的。但是它们引用的地址都是不同的，这印证了我们讲 Copy trait 的时候，介绍过<strong>只读引用实现了 Copy trait，也就意味着引用的赋值、传参都会产生新的浅拷贝</strong>。</p><p>虽然 data 有很多只读引用指向它，但堆上的数据依旧只有 data 一个所有者，所以值的任意多个引用并不会影响所有权的唯一性。</p><p>但我们马上就发现了新问题：一旦 data 离开了作用域被释放，如果还有引用指向 data，岂不是造成我们想极力避免的使用已释放内存（use after free）这样的内存安全问题？怎么办呢？</p><h3>借用的生命周期及其约束</h3><p>所以，我们对值的引用也要有约束，这个约束是：借用不能超过（outlive）值的生存期。</p><p>这个约束很直观，也很好理解。在上面的代码中，sum() 函数处在 main() 函数下一层调用栈中，它结束之后 main() 函数还会继续执行，所以在 main() 函数中定义的 data 生命周期要比 sum() 中对 data 的引用要长，这样不会有任何问题。</p><p>但如果是这样的代码呢（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=fd23517a1666c88834f0d47a564671e7\">情况1</a>）？</p><pre><code class=\"language-rust\">fn main() {\n    let r = local_ref();\n    println!(\"r: {:p}\", r);\n}\n\nfn local_ref&lt;'a&gt;() -&gt; &amp;'a i32 {\n    let a = 42;\n    &amp;a\n}\n</code></pre><p>显然，生命周期更长的 main() 函数变量 r ，引用了生命周期更短的 local_ref() 函数里的局部变量，这违背了有关引用的约束，所以 Rust 不允许这样的代码编译通过。</p><p>那么，如果我们在堆内存中，使用栈内存的引用，可以么？</p><p>根据过去的开发经验，你也许会脱口而出：不行！因为堆内存的生命周期显然比栈内存要更长更灵活，这样做内存不安全。</p><p>我们写段代码试试看，把一个本地变量的引用存入一个可变数组中。从基础知识的学习中我们知道，可变数组存放在堆上，栈上只有一个胖指针指向它，所以这是一个典型的把栈上变量的引用存在堆上的例子（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=1726b8d86610530c22476d1756509208\">情况2</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let mut data: Vec&lt;&amp;u32&gt; = Vec::new();\n    let v = 42;\n    data.push(&amp;v);\n    println!(\"data: {:?}\", data);\n}\n</code></pre><p>竟然编译通过，怎么回事？我们变换一下，看看还能编译不（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=daaefec97e99184460664e658e578ce9\">情况3</a>），又无法通过了！</p><pre><code class=\"language-rust\">fn main() {\n    let mut data: Vec&lt;&amp;u32&gt; = Vec::new();\n    push_local_ref(&amp;mut data);\n    println!(\"data: {:?}\", data);\n}\n\nfn push_local_ref(data: &amp;mut Vec&lt;&amp;u32&gt;) {\n    let v = 42;\n    data.push(&amp;v);\n}\n\n</code></pre><p>到这里，你是不是有点迷糊了，这三种情况，为什么同样是对栈内存的引用，怎么编译结果都不一样？</p><p>这三段代码看似错综复杂，但如果抓住了一个核心要素“在一个作用域下，同一时刻，一个值只能有一个所有者”，你会发现，其实很简单。</p><p>堆变量的生命周期不具备任意长短的灵活性，因为堆上内存的生死存亡，跟栈上的所有者牢牢绑定。而栈上内存的生命周期，又跟栈的生命周期相关，所以我们<strong>核心只需要关心调用栈的生命周期</strong>。</p><p>现在你是不是可以轻易判断出，为什么情况 1 和情况 3 的代码无法编译通过了，因为它们引用了生命周期更短的值，而情况2 的代码虽然在堆内存里引用栈内存，但生命周期是相同的，所以没有问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/56/44/5632f4043c93cd485567e1dc2ebe7e44.jpg?wh=4335x2348\" alt=\"\"></p><p>好，到这里，默认情况下，Rust 的只读借用就讲完了，借用者不能修改被借用的值，简单类比就像住酒店，只有使用权。</p><p>但之前也提到，有些情况下，我们也需要可变借用，想在借用的过程中修改值的内容，就像租房，需要对房屋进行必要的装饰。</p><h2>可变借用/引用</h2><p>在没有引入可变借用之前，因为一个值同一时刻只有一个所有者，所以如果要修改这个值，只能通过唯一的所有者进行。但是，如果允许借用改变值本身，会带来新的问题。</p><p>我们先看第一种情况，<strong>多个可变引用共存</strong>：</p><pre><code class=\"language-rust\">fn main() {\n    let mut data = vec![1, 2, 3];\n\n    for item in data.iter_mut() {\n        data.push(*item + 1);\n    }\n}\n</code></pre><p>这段代码在遍历可变数组 data 的过程中，还往 data 里添加新的数据，这是很危险的动作，因为它破坏了循环的不变性（loop invariant），容易导致死循环甚至系统崩溃。所以，在同一个作用域下有多个可变引用，是不安全的。</p><p>由于 Rust 编译器阻止了这种情况，上述代码会编译出错。我们可以用 Python 来体验一下多个可变引用可能带来的死循环：</p><pre><code class=\"language-python\">if __name__ == \"__main__\":\n    data = [1, 2]\n    for item in data:\n        data.append(item + 1)\n        print(item)\n    # unreachable code\n    print(data)\n</code></pre><p>同一个上下文中多个可变引用是不安全的，那如果<strong>同时有一个可变引用和若干个只读引用</strong>，会有问题吗？我们再看一段代码：</p><pre><code class=\"language-rust\">fn main() {\n    let mut data = vec![1, 2, 3];\n    let data1 = vec![&amp;data[0]];\n    println!(\"data[0]: {:p}\", &amp;data[0]);\n\n    for i in 0..100 {\n        data.push(i);\n    }\n\n    println!(\"data[0]: {:p}\", &amp;data[0]);\n    println!(\"boxed: {:p}\", &amp;data1);\n}\n</code></pre><p>在这段代码里，不可变数组 data1 引用了可变数组 data 中的一个元素，这是个只读引用。后续我们往 data 中添加了 100 个元素，在调用  <code>data.push()</code> 时，我们访问了 data 的可变引用。</p><p>这段代码中，data 的只读引用和可变引用共存，似乎没有什么影响，因为 data1 引用的元素并没有任何改动。</p><p>如果你仔细推敲，就会发现这里有内存不安全的潜在操作：如果继续添加元素，堆上的数据预留的空间不够了，就会重新分配一片足够大的内存，把之前的值拷过来，然后释放旧的内存。这样就会让 data1 中保存的 &amp;data[0] 引用失效，导致内存安全问题。</p><h3>Rust的限制</h3><p>多个可变引用共存、可变引用和只读引用共存这两种问题，通过 GC 等自动内存管理方案可以避免第二种，但是第一个问题 GC 也无济于事。</p><p>所以为了保证内存安全，Rust 对可变引用的使用也做了严格的约束：</p><ul>\n<li><strong>在一个作用域内，仅允许一个活跃的可变引用</strong>。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。</li>\n<li>在一个作用域内，<strong>活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在</strong>。</li>\n</ul><p>这个约束你是不是觉得看上去似曾相识？对，它和数据在并发下的读写访问（比如 RwLock）规则非常类似，你可以类比学习。</p><p>从可变引用的约束我们也可以看到，Rust 不光解决了 GC 可以解决的内存安全问题，还解决了 GC 无法解决的问题。在编写代码的时候， Rust 编译器就像你的良师益友，不断敦促你采用最佳实践来撰写安全的代码。</p><p>学完今天的内容，我们再回看<a href=\"https://time.geekbang.org/column/article/408400\">开篇词</a>展示的第一性原理图，你的理解是不是更透彻了？</p><p><img src=\"https://static001.geekbang.org/resource/image/60/51/605094c2dc6992997e31f687dc908751.jpg?wh=2646x3048\" alt=\"\"></p><p>其实，我们拨开表层的众多所有权规则，一层层深究下去，触及最基础的概念，搞清楚堆或栈中值到底是如何存放的、在内存中值是如何访问的，然后从这些概念出发，或者扩展其外延，或者限制其使用，从根本上寻找解决之道，这才是我们处理复杂问题的最佳手段，也是Rust的设计思路。</p><h2>小结</h2><p>今天我们学习了 Borrow 语义，搞清楚了只读引用和可变引用的原理，结合上一讲学习的 Move / Copy 语义，Rust 编译器会通过检查，来确保代码没有违背这一系列的规则：</p><ol>\n<li>一个值在同一时刻只有一个所有者。当所有者离开作用域，其拥有的值会被丢弃。赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。</li>\n<li>如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝，产生新的值。</li>\n<li>一个值可以有多个只读引用。</li>\n<li>一个值可以有唯一一个活跃的可变引用。可变引用（写）和只读引用（读）是互斥的关系，就像并发下数据的读写互斥那样。</li>\n<li>引用的生命周期不能超出值的生命周期。</li>\n</ol><p>你也可以看这张图快速回顾：</p><p><img src=\"https://static001.geekbang.org/resource/image/94/30/94b4311f2b384f91dfb051bb84884c30.jpg?wh=6927x3821\" alt=\"\"></p><p>但总有一些特殊情况，比如DAG，我们想绕过“一个值只有一个所有者”的限制，怎么办？下一讲我们继续学习……</p><h3>思考题</h3><ol>\n<li>上一讲我们在讲 Copy trait 时说到，可变引用没有实现 Copy trait。结合这一讲的内容，想想为什么？</li>\n<li>下面这段代码，如何修改才能使其编译通过，避免同时有只读引用和可变引用？</li>\n</ol><pre><code class=\"language-rust\">fn main() {\n&nbsp; let mut arr = vec![1, 2, 3];\n&nbsp; // cache the last item\n&nbsp; let last = arr.last();\n&nbsp; arr.push(4);\n&nbsp; // consume previously stored last item\n&nbsp; println!(\"last: {:?}\", last);\n}\n</code></pre><p>欢迎在留言区分享你的思考。今天你完成了 Rust 学习的第八次打卡！如果你觉得有收获，也欢迎你分享给身边的朋友，邀TA一起讨论。</p><h2>参考资料</h2><p>有同学评论,好奇可变引用是如何导致堆内存重新分配的，我们看一个例子。我先分配一个 capacity 为 1 的 Vec<i32>，然后放入 32 个元素，此时它会重新分配，然后打印重新分配前后 &amp;v[0] 的堆地址时，会看到发生了变化。</i32></p><p>所以，如果我们有指向旧的 &amp;v[0] 的地址，就会读到已释放内存，这就是我在文中说为什么在同一个作用域下，可变引用和只读引用不能共存（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=3027c5f5751f9ec4c45d7b918fec34f3\">代码</a>）。</p><pre><code>use std::mem;\n\nfn main() {\n    // capacity 是 1, len 是 0\n    let mut v = vec![1];\n    // capacity 是 8, len 是 0\n    let v1: Vec&lt;i32&gt; = Vec::with_capacity(8);\n\n    print_vec(&quot;v1&quot;, v1);\n\n    // 我们先打印 heap 地址，然后看看添加内容是否会导致堆重分配\n    println!(&quot;heap start: {:p}&quot;, &amp;v[0] as *const i32);\n\n    extend_vec(&amp;mut v);\n\n    // heap 地址改变了！这就是为什么可变引用和不可变引用不能共存的原因\n    println!(&quot;new heap start: {:p}&quot;, &amp;v[0] as *const i32);\n\n    print_vec(&quot;v&quot;, v);\n}\n\nfn extend_vec(v: &amp;mut Vec&lt;i32&gt;) {\n    // Vec&lt;T&gt; 堆内存里 T 的个数是指数增长的，我们让它恰好 push 33 个元素\n    // capacity 会变成 64\n    (2..34).into_iter().for_each(|i| v.push(i));\n}\n\nfn print_vec&lt;T&gt;(name: &amp;str, data: Vec&lt;T&gt;) {\n    let p: [usize; 3] = unsafe { mem::transmute(data) };\n    // 打印 Vec&lt;T&gt; 的堆地址，capacity，len\n    println!(&quot;{}: 0x{:x}, {}, {}&quot;, name, p[0], p[1], p[2]);\n}\n</code></pre><p>打印结果（地址在你机器上会不一样）：</p><pre><code>v1: 0x7f8a2f405e00, 8, 0\nheap start: 0x7f8a2f405df0\nnew heap start: 0x7f8a2f405e20\nv: 0x7f8a2f405e20, 64, 33\n</code></pre><p>如果你运行了这段代码，你可能会注意到一个很有意思的细节：我在 playground 代码链接中给出的代码和文中的代码稍微有些不同。</p><p>在文中我的环境是 OS X，很少量的数据就会让堆内存重新分配，而 playground 是 Linux 环境，我一直试到 &gt; 128KB 内存才让 Vec<t> 的堆内存重分配。</t></p>","neighbors":{"left":{"article_title":"07｜所有权：值的生杀大权到底在谁手上？","id":415098},"right":{"article_title":"09｜所有权：一个值可以有多个所有者么？","id":416722}},"comments":[{"had_liked":false,"id":311081,"user_name":"woshidag","can_delete":false,"product_type":"c1","uid":1026057,"ip_address":"","ucode":"772A12D1386BBF","user_header":"","comment_is_top":true,"comment_ctime":1631066968,"is_pvip":false,"replies":[{"id":"112734","content":"非常棒！<br><br>第二题也可以先使用，后 push。<br><br>```rust<br>fn main() {<br>  let mut arr = vec![1, 2, 3];<br>  &#47;&#47; cache the last item<br>  let last = arr.last();<br>  &#47;&#47; consume previously stored last item<br>  println!(&quot;last: {:?}&quot;, last);<br>  arr.push(4);<br>}<br>```","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631069828,"ip_address":"","comment_id":311081,"utype":1}],"discussion_count":2,"race_medal":0,"score":"9.2233721200902001e+18","product_id":100085301,"comment_content":"第一题<br>可变引用可copy trait的话，相当于多个地方可以修改同一块数据，违背“一个值在同一时刻只有一个所有者”<br>第二题，用数组下标取值，i32实现了copy trait<br>fn main() {<br>    let mut arr = vec![1, 2, 3];<br>    &#47;&#47; cache the last item<br>    let last = arr[arr.len()-1];<br>    &#47;&#47; let last = arr.last();<br>    arr.push(4);<br>    &#47;&#47; consume previously stored last item<br>    println!(&quot;last: {:?}&quot;, last);<br>  }","like_count":20,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526466,"discussion_content":"非常棒！\n\n第二题也可以先使用，后 push。\n\n```rust\nfn main() {\n  let mut arr = vec![1, 2, 3];\n  // cache the last item\n  let last = arr.last();\n  // consume previously stored last item\n  println!(&amp;quot;last: {:?}&amp;quot;, last);\n  arr.push(4);\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631069828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392637,"discussion_content":"可变引用的move看不懂？https://stackoverflow.com/questions/32154387/why-is-the-mutable-reference-not-moved-here","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631083900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311067,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":true,"comment_ctime":1631062786,"is_pvip":false,"replies":[{"id":"112738","content":"非常正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631070169,"ip_address":"","comment_id":311067,"utype":1}],"discussion_count":5,"race_medal":0,"score":"9.2233720986154004e+18","product_id":100085301,"comment_content":"1. 上一讲我们在讲 Copy trait 时说到，可变引用没有实现 Copy trait。结合这一讲的内容，想想为什么？<br><br>在一个作用域内，仅允许一个活跃的可变引用，如果可以被 Copy，那还怎么玩。<br><br>下面这段代码，如何修改才能使其编译通过，避免同时有只读引用和可变引用？<br><br>究其根本原因在于，可变与不可变借用相互交缠，破坏了：活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在的原则，因此修改也很简单，把 arr.push 上移，或者下移，如下：<br><br>fn main() {<br>  let mut arr = vec![1,2,3];<br>  let last = arr.last();<br>  println!(&quot;last: {:?}&quot;, last);<br>  arr.push(4);<br>}<br><br>当然也可以上移到 last 前面。","like_count":15,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526456,"discussion_content":"非常正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631070169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1580803,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1f/03/e4e15f95.jpg","nickname":"DustyBun","note":"","ucode":"546D2E89B2E96E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406496,"discussion_content":"有点不理解，活跃的可变与只读也还是在同一个作用域呀，这个不能同时存在的原则到底是是什么，不能挨着?","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1634780890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1208393,"avatar":"https://static001.geekbang.org/account/avatar/00/12/70/49/d7690979.jpg","nickname":"tommyCmd","note":"","ucode":"4ADBB1FA44668D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1580803,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1f/03/e4e15f95.jpg","nickname":"DustyBun","note":"","ucode":"546D2E89B2E96E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578027,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656474070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":406496,"ip_address":""},"score":578027,"extra":""},{"author":{"id":1933174,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/7f/76/51137a97.jpg","nickname":"一一","note":"","ucode":"F552F21A538D6F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1208393,"avatar":"https://static001.geekbang.org/account/avatar/00/12/70/49/d7690979.jpg","nickname":"tommyCmd","note":"","ucode":"4ADBB1FA44668D","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":586385,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662177160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":578027,"ip_address":"浙江"},"score":586385,"extra":""}]},{"author":{"id":2835285,"avatar":"","nickname":"Geek_ad4600","note":"","ucode":"D1B55BF41EAF01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553910,"discussion_content":"^_^  “当然也可以上移到 last 前面。”  程序正确性不就变了吗，需要的是3不是4 ^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646130379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311050,"user_name":"Ryan","can_delete":false,"product_type":"c1","uid":2739803,"ip_address":"","ucode":"026C66ED684E00","user_header":"","comment_is_top":true,"comment_ctime":1631034479,"is_pvip":false,"replies":[{"id":"112741","content":"你可以用 Box::leak &#47; Box:into_raw &#47; ManuallyDrop 让堆内存完全脱离自动管理。按照你的需求，你可以使用 ManuallyDrop。代码如下：<br><br>```rust<br>use std::mem::ManuallyDrop;<br><br>fn main() {<br>    &#47;&#47; 使用 ManuallyDrop 封装数据结构使其不进行自动 drop<br>    let mut s = ManuallyDrop::new(String::from(&quot;Hello World!&quot;));<br><br>    &#47;&#47; ManuallyDrop 使用了 Deref trait 指向 T，所以可以当 String 使用<br>    s.truncate(5);<br>    println!(&quot;s: {:?}&quot;, s);<br><br>    &#47;&#47; 如果没有这句，s 不会在 scope 结束时被自动 drop（你可以注掉试一下）<br>    &#47;&#47; 如果我们想让它可以自动 drop，可以用 into_inner<br>    let _: String = ManuallyDrop::into_inner(s);<br>}<br>```<br><br>更详细的代码可以看 playground（我实现了个 MyString，在 Drop trait 中加了打印，这样可以更清楚地看到 drop 是否被调用）：<br><br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4362bb2f45d252b01822d9206b988019<br><br>至于 Box::leak &#47; Box::into_raw，我们后续会慢慢讲到。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631072145,"ip_address":"","comment_id":311050,"utype":1}],"discussion_count":3,"race_medal":0,"score":"9.2233720771405005e+18","product_id":100085301,"comment_content":"堆变量的生命周期不具备任意长短的灵活性，因为堆上内存的生死存亡，跟栈上的所有者牢牢绑定。<br>这应该算是一个很强的限制，如果我希望有一段内存的生命周期是由我的业务逻辑决定的，在rust中要如何实现呢？这种情况下又如何让rust帮助我管理生命周期，减少错误呢？","like_count":10,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526448,"discussion_content":"你可以用 Box::leak / Box:into_raw / ManuallyDrop 让堆内存完全脱离自动管理。按照你的需求，你可以使用 ManuallyDrop。代码如下：\n\n```rust\nuse std::mem::ManuallyDrop;\n\nfn main() {\n    // 使用 ManuallyDrop 封装数据结构使其不进行自动 drop\n    let mut s = ManuallyDrop::new(String::from(&amp;quot;Hello World!&amp;quot;));\n\n    // ManuallyDrop 使用了 Deref trait 指向 T，所以可以当 String 使用\n    s.truncate(5);\n    println!(&amp;quot;s: {:?}&amp;quot;, s);\n\n    // 如果没有这句，s 不会在 scope 结束时被自动 drop（你可以注掉试一下）\n    // 如果我们想让它可以自动 drop，可以用 into_inner\n    let _: String = ManuallyDrop::into_inner(s);\n}\n```\n\n更详细的代码可以看 playground（我实现了个 MyString，在 Drop trait 中加了打印，这样可以更清楚地看到 drop 是否被调用）：\n\nhttps://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=4362bb2f45d252b01822d9206b988019\n\n至于 Box::leak / Box::into_raw，我们后续会慢慢讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631072145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018673,"avatar":"http://thirdwx.qlogo.cn/mmopen/ajNVdqHZLLDoDeeNST87MZEdfT8n7yEWp06KsFCTs2ssFh2tbHu413nibrRObOia1Zn9pqiaHgIicVkSHRZM3LHOEA/132","nickname":"葡萄","note":"","ucode":"6E8597D1B09807","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392554,"discussion_content":"控制业务逻辑内栈上所有者的存活？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631059170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1018673,"avatar":"http://thirdwx.qlogo.cn/mmopen/ajNVdqHZLLDoDeeNST87MZEdfT8n7yEWp06KsFCTs2ssFh2tbHu413nibrRObOia1Zn9pqiaHgIicVkSHRZM3LHOEA/132","nickname":"葡萄","note":"","ucode":"6E8597D1B09807","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392620,"discussion_content":"堆。栈上数据的存活与否任何语言都管不了，否则就失去了栈的意义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631073239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":392554,"ip_address":""},"score":392620,"extra":""}]}]},{"had_liked":false,"id":311616,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":true,"comment_ctime":1631341339,"is_pvip":false,"replies":[{"id":"113007","content":"非常赞！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631516696,"ip_address":"","comment_id":311616,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720556659999e+18","product_id":100085301,"comment_content":"1. 这篇也是常看常新: https:&#47;&#47;manishearth.github.io&#47;blog&#47;2015&#47;05&#47;17&#47;the-problem-with-shared-mutability&#47;; 这也能解释为什么就算单线程, 某个code entry只能有一个mutable reference<br>2. 第二题引出了non lexical lifetime; 感觉还是第一性原理 shared mutability: 某个code entry运行时, 有且只有一个mutable reference; 不违反, 就能work;<br>3. 租房那个例子太棒了! 房子到期了, 租户不能白嫖;","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526681,"discussion_content":"非常赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631516696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311219,"user_name":"bekyiu","can_delete":false,"product_type":"c1","uid":1119328,"ip_address":"","ucode":"3C43208719FD72","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/60/1f55d565.jpg","comment_is_top":false,"comment_ctime":1631110481,"is_pvip":false,"replies":[{"id":"112809","content":"好问题。这涉及到 reborrow。在函数调用时，sum(b) 实际上等价于 sum(&amp;mut *b)。reborrow 以后我们看有没有机会和 NLL (non-lexical lifetime) 加餐一起介绍一下。目前我们先理解好基本的所有权&#47;借用&#47;生命周期规则。reborrow &#47; NLL 是为了让代码更简单易写而做的改进。<br><br>你可以通过下面的代码看 reborrow 和普通借用的区别：<br>```rust<br>fn main() {<br>    let mut x = 42;<br><br>    let r1 = &amp;mut x;<br>    &#47;&#47; reborrow 可以通过<br>    let r2 = &amp;*r1;<br>    &#47;&#47; &amp;x 不可以<br>    &#47;&#47; let r2 = &amp;x;<br><br>    println!(&quot;r1: {:p}, r2: {:p}&quot;, &amp;r1, &amp;r2);<br><br>    *r1 += 1;<br>}<br>```","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631159720,"ip_address":"","comment_id":311219,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44580783441","product_id":100085301,"comment_content":"    let mut data = vec![1, 2, 3, 4];<br>    let b = &amp;mut data;<br>    println!(&quot;sum of data1: {}&quot;, sum(b));<br>    &#47;&#47; ok<br>    println!(&quot;{:?}&quot;, b);<br><br><br>可变引用没有实现copy trait，为啥这样不会转移所有权呢","like_count":11,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526525,"discussion_content":"好问题。这涉及到 reborrow。在函数调用时，sum(b) 实际上等价于 sum(&amp;amp;mut *b)。reborrow 以后我们看有没有机会和 NLL (non-lexical lifetime) 加餐一起介绍一下。目前我们先理解好基本的所有权/借用/生命周期规则。reborrow / NLL 是为了让代码更简单易写而做的改进。\n\n你可以通过下面的代码看 reborrow 和普通借用的区别：\n```rust\nfn main() {\n    let mut x = 42;\n\n    let r1 = &amp;amp;mut x;\n    // reborrow 可以通过\n    let r2 = &amp;amp;*r1;\n    // &amp;amp;x 不可以\n    // let r2 = &amp;amp;x;\n\n    println!(&amp;quot;r1: {:p}, r2: {:p}&amp;quot;, &amp;amp;r1, &amp;amp;r2);\n\n    *r1 += 1;\n}\n```","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631159720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318062,"user_name":"彭亚伦","can_delete":false,"product_type":"c1","uid":2425378,"ip_address":"","ucode":"77A32C73A23F72","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/22/19585900.jpg","comment_is_top":false,"comment_ctime":1635135518,"is_pvip":true,"replies":[{"id":"116592","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636644109,"ip_address":"","comment_id":318062,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27404939294","product_id":100085301,"comment_content":"第一题<br>可变引用如果实现Copy  Trait的话, 容易造成同一作用域内出现多个可变引用, 本质上会对同一数据有多个修改权限, 形成数据竞争, 会导致未定义行为，难以在运行时追踪，并且难以诊断和修复相当于同一时刻同一数据有多个所有者, 数据安全完全不可控, 因此可变引用不能实现Copy Trait.<br><br>第二题, 解决方案有不少<br>第一种, 把`arr.push(4)` 移动到打印下方<br>```rsut<br>fn main() {<br><br>  let mut arr = vec![1, 2, 3];<br><br>  let last = arr.last();<br>  println!(&quot;last: {:?}&quot;, last);<br><br>  arr.push(4);<br><br><br>}<br>```<br>这样做一开始是比较难以理解的,  因为可变引用和不可引用似乎都在main函数这同一个作用域内, 但是看过死灵书还是啥的大致就明白了, 其实是编译器自己做了优化, 添加了一些生命周期标志, 使得不可变引用的生命周期在打印调用完之后就提前结束了,  之后再使用可变引用就没问题了.  新版Book里面有: 编译器在作用域结束之前判断不再使用的引用的能力被称为非词法作用域生命周期（Non-Lexical Lifetimes，简称NLL）.<br> <br>还有一个是调用`Option`的方法cloned, 也算行的通吧, 哈哈:<br><br>```rsut<br>fn main() {<br><br>  let mut arr = vec![1, 2, 3];<br><br>  let last = arr.last().cloned();<br>  arr.push(4);<br>  println!(&quot;last: {:?}&quot;, last);<br>}<br>```","like_count":7,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529084,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636644109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243961,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/VLB1WPGVDnicKaMGUcFZdtDQOXSib3LhFv6YqCZA16qfy2KHUAGL0ichSEE6rSu8HXSibGdg8vzIQ7qWlk9BZOeJjQ/132","nickname":"Curricane","note":"","ucode":"3778B96444874E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543164,"discussion_content":"&#34; 其实是编译器自己做了优化, 添加了一些生命周期标志, 使得不可变引用的生命周期在打印调用完之后就提前结束了, 之后再使用可变引用就没问题了&#34; 突然就理解了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640967326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311077,"user_name":"gnu","can_delete":false,"product_type":"c1","uid":1631832,"ip_address":"","ucode":"B598402D9377D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/e6/58/a0f74927.jpg","comment_is_top":false,"comment_ctime":1631065061,"is_pvip":false,"replies":[{"id":"112735","content":"嗯，这样也可以。这里隐含着使用了 i32 的 Copy trait，让 last 拷贝了一份。它对 Vec&lt;String&gt; 就不适用，因为 String 会做 move。你可以试着在 playground 运行这端代码看看出什么错误：<br><br>```rust<br>fn main() {<br>    let mut arr = vec![String::from(&quot;a&quot;), String::from(&quot;b&quot;)];<br>    &#47;&#47; cache the last item<br>    let last = *arr.last().unwrap();<br>    arr.push(String::from(&quot;c&quot;));<br>    &#47;&#47; consume previously stored last item<br>    println!(&quot;last: {:?}&quot;, last);<br>}<br>```<br><br>还有其它解法，可以参考我之前的回答。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631070054,"ip_address":"","comment_id":311077,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27400868837","product_id":100085301,"comment_content":"fn main() {<br>    let mut arr = vec![1, 2, 3];<br>    &#47;&#47; cache the last item<br>    let last = *arr.last().unwrap();<br>    arr.push(4);<br>    &#47;&#47; consume previously stored last item<br>    println!(&quot;last: {:?}&quot;, last);<br>}<br><br>通过 解引用 让 last 成为分配在栈上的值，而不是指向堆上 arr 数组元素的指针，可以编译通过","like_count":6,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526465,"discussion_content":"嗯，这样也可以。这里隐含着使用了 i32 的 Copy trait，让 last 拷贝了一份。它对 Vec&amp;lt;String&amp;gt; 就不适用，因为 String 会做 move。你可以试着在 playground 运行这端代码看看出什么错误：\n\n```rust\nfn main() {\n    let mut arr = vec![String::from(&amp;quot;a&amp;quot;), String::from(&amp;quot;b&amp;quot;)];\n    // cache the last item\n    let last = *arr.last().unwrap();\n    arr.push(String::from(&amp;quot;c&amp;quot;));\n    // consume previously stored last item\n    println!(&amp;quot;last: {:?}&amp;quot;, last);\n}\n```\n\n还有其它解法，可以参考我之前的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631070054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313666,"user_name":"thanq","can_delete":false,"product_type":"c1","uid":1064799,"ip_address":"","ucode":"E71A52137F36CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/5f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1632588126,"is_pvip":false,"replies":[{"id":"113742","content":"非常棒！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632798685,"ip_address":"","comment_id":313666,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23107424606","product_id":100085301,"comment_content":"第一题: 可变引用(eg:  let mut v = vec![1] ; let mut r = v ), 如果实现了 Copy trait, 就会导致变量 r 创建时, 在栈上再复制一个胖指针, 该胖指针也会指向相同的堆内存, 且这两个胖指针所有权独立, 都可以发起该份堆内存数据的修改操作, 这样就无法保证内存安全. 所以, 出于内存安全的考虑, Rust对可变引用没有实现 Copy trait<br><br>第二题:  实例代码编译报错的原因是在变量 last 为对 arr 的只读借用还生效的情况下, 又尝试进行 arr 的可变借用, 而这两个操作是互斥的<br>解决方式有两个: <br>  1 提前归还变量 last 对 arr 的只读借用<br>```<br>fn main() {<br>  let mut arr = vec![1, 2, 3];<br>  let last = arr.last();<br>  println!(&quot;last: {:?}&quot;, last);<br>  &#47;&#47; last 作用域结束, 归还arr的只读借用<br>  arr.push(4);<br>}<br>```<br>  2 变量 last 赋值不进行借用操作<br>```<br>fn main() {<br>  let mut arr = vec![1, 2, 3];<br>  &#47;&#47;将整数值赋值给变量last, 此处不发生借用(&amp;)操作<br>  let last = arr[arr.len() - 1];<br>  println!(&quot;last: {:?}&quot;, last);<br>  arr.push(4);<br>  println!(&quot;len: {:?}&quot;, len);<br>}<br>```","like_count":6,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527432,"discussion_content":"非常棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632798685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311500,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1631258418,"is_pvip":false,"replies":[{"id":"112879","content":"嗯，「活跃的」这个定语是 Rust 编译器做的一个优化，可以让我们不用添加不必要的作用域。可以简单这么认为：在撰写代码的时候，如果你在某处使用了一个可变引用之后就再也没用了，那么这处之后的地方这个可变引用就不是活跃的了。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631284578,"ip_address":"","comment_id":311500,"utype":1}],"discussion_count":2,"race_medal":2,"score":"23106094898","product_id":100085301,"comment_content":"有且仅有一个活跃的可变引用存在，对于这句话还是要好好理解一下。","like_count":5,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526636,"discussion_content":"嗯，「活跃的」这个定语是 Rust 编译器做的一个优化，可以让我们不用添加不必要的作用域。可以简单这么认为：在撰写代码的时候，如果你在某处使用了一个可变引用之后就再也没用了，那么这处之后的地方这个可变引用就不是活跃的了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631284578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240106,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","nickname":"曾经瘦过","note":"","ucode":"57C32575A1C1FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557531,"discussion_content":"看到这里才明白为啥第二题可以那么修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647853911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312012,"user_name":"胡小涵","can_delete":false,"product_type":"c1","uid":2004538,"ip_address":"","ucode":"2E750C65EC282C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/96/3a/e06f8367.jpg","comment_is_top":false,"comment_ctime":1631590435,"is_pvip":false,"replies":[{"id":"113074","content":"正确","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631601850,"ip_address":"","comment_id":312012,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14516492323","product_id":100085301,"comment_content":"copy语义和move语义底层实现都是按位浅拷贝，只不过copy语义是产生新的值，move语义是所有权转移，这样理解对吧？","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526831,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631601850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311676,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1631383168,"is_pvip":false,"replies":[{"id":"112994","content":"眼尖，我感觉我 addr of data 是想打 &amp;*data，这个是堆地址。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631515435,"ip_address":"","comment_id":311676,"utype":1}],"discussion_count":7,"race_medal":0,"score":"14516285056","product_id":100085301,"comment_content":"<br>代码3中, 为啥data的addr是&amp;&amp;data? 不应该就是&amp;data嘛?<br>```<br>println!(  &quot;addr of value: {:p}({:p}), addr of data {:p}, data1: {:p}&quot;,  <br>&amp;data, data1, &amp;&amp;data, &amp;data1);<br>```<br><br>我试了下&amp;&amp;data和data1不一样; 怎么感觉是一个temp variable的地址呢?<br>```<br>    println!(<br>        &quot;addr of data {:p}, &amp;&amp;data {:p}, &amp;&amp;&amp;data {:p}&quot;,<br>        &amp;data, &amp;&amp;data, &amp;&amp;&amp;data<br>    );<br>```","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526701,"discussion_content":"眼尖，我感觉我 addr of data 是想打 &amp;amp;*data，这个是堆地址。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631515435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1222445,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Vt2RSNYe0pPmj9J8ncLibuudVlRWYAHxicDTGWtexYXeicibjBfUHicbcYW2bEzGAjiadjaHrFibnAA5MvS14b6p8mV2Q/132","nickname":"Metaer","note":"","ucode":"3B510A1582FF69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399204,"discussion_content":"那为何文档不修改？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1632921117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1076856,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6e/78/500432c2.jpg","nickname":"花落花开","note":"","ucode":"4F9B9805C09FCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541350,"discussion_content":"我的理解，(&#34;{:p}&#34;, &amp;&amp;data) 应该是 &amp;data 的地址。同理，(&#34;{:p}&#34;, &amp;data) 是 data 的地址。如果是 (&#34;{:p}&#34;, &amp;*data) ，那么应该是 data 中的存放的 ptr，也就是堆地址。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640337014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018487,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/77/8a89d0c9.jpg","nickname":"tr1um7h","note":"","ucode":"5BAA01CAADA028","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393581,"discussion_content":"我理解&amp;&amp;data是栈上分配的胖指针的地址，等老师的解答","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631503021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018487,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/77/8a89d0c9.jpg","nickname":"tr1um7h","note":"","ucode":"5BAA01CAADA028","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408329,"discussion_content":"我觉得你说的对，估计是老师回复的时候没注意上下文……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635228442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":393581,"ip_address":""},"score":408329,"extra":""}]},{"author":{"id":2905523,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDqHQQByGiaXcAk94MdDn3ftupZLXyR6bAKibxOzMxy5h3uBwZ7QiaCiaIfbCMK0cIQfGNax8iawoiaQAg/132","nickname":"nuan","note":"","ucode":"55FF98EB85404D","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555473,"discussion_content":"&amp;&amp;data 是栈地址，&amp;*data 是堆地址，这样看代码不用改，addr of data 就应该用 &amp;&amp;data 啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646921138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070043,"avatar":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","nickname":"Ethan Liu","note":"","ucode":"231F944F7CD56A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393592,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631507473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318315,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1635238751,"is_pvip":false,"replies":[{"id":"116582","content":"1. &amp;String 是廋指针，因为指向 String 结构的引用不需要额外的信息，String 就携带了长度等信息。&amp;str 是胖指针，因为 str 类型是 DST（动态长度类型），所以需要额外的长度信息来读取和使用指针指向的内存。<br>2. 有预留，capacity 就是干这个事情的<br>3. 编译器不会自动加引用（但会自动解引用），println! 是一个宏，它可以更改被宏包裹的代码，所以，它会根据需要加引用。<br>4. 不是。reborrow 和 scope 和 lifetime 相关。是编译器的一种优化。更详细的解释可以看：https:&#47;&#47;cotigao.medium.com&#47;mutable-reference-in-rust-995320366e22","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636643412,"ip_address":"","comment_id":318315,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5930206047","product_id":100085301,"comment_content":"1. 一个胖瘦指针的问题：<br>&amp;String &amp;[u8] 是胖指针<br>&amp;Vec&lt;T&gt; 是瘦指针<br>怎么判断是哪个呢，我感觉 &amp;String 和 &amp;Vec&lt;T&gt; 应该是同一种啊……<br><br>2. 文末演示堆内存重新分配的例子，为什么容量到64才重新分配啊，一开始的容量不是1吗，那再push一个容量到2就应该重新分配了啊。我理解可能是一开始就预留了一部分地址空间，这样扩容到时候，只需要改变容量的值就行了。预留的空间不够了才会重新找地方开辟一段新空间。不知道我这样理解对不对。<br><br>3. 这样一个问题：<br>```rust<br>let a = 1;<br>println!(&quot;{}&quot;, a);<br>```<br>这里根据我跟编译器斗争的历史来看，a应该是被借用的。也就是编译器给a前边自动加了一个&amp;。<br><br>```rust<br>let a = 1;<br>&#47;&#47; error, use &amp;a<br>println!(&quot;{:p}&quot;, a);<br>```<br>但是这里好像就不会，得手动加&amp;，才能打印出地址。<br>能不能详细解释下？<br><br>4. 关于 reborrow 的例子：<br>```rust<br>fn main() {<br>    let mut x = 42;<br><br>    let r1 = &amp;mut x;<br>    &#47;&#47; reborrow 可以通过<br>    let r2 = &amp;*r1;<br>    &#47;&#47; &amp;x 不可以<br>    &#47;&#47; let r2 = &amp;x;<br><br>    println!(&quot;r1: {:p}, r2: {:p}&quot;, &amp;r1, &amp;r2);<br><br>    *r1 += 1;<br>}<br>```<br>这里是不是可以这样理解，r2 实际上借用的是 *r1（虽然我们知道 *r1 就是 x，但编译器可以假装不知道？）。<br>所以 *r1 在 r2 的生命周期内无法使用。","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529182,"discussion_content":"1. &amp;amp;String 是廋指针，因为指向 String 结构的引用不需要额外的信息，String 就携带了长度等信息。&amp;amp;str 是胖指针，因为 str 类型是 DST（动态长度类型），所以需要额外的长度信息来读取和使用指针指向的内存。\n2. 有预留，capacity 就是干这个事情的\n3. 编译器不会自动加引用（但会自动解引用），println! 是一个宏，它可以更改被宏包裹的代码，所以，它会根据需要加引用。\n4. 不是。reborrow 和 scope 和 lifetime 相关。是编译器的一种优化。更详细的解释可以看：https://cotigao.medium.com/mutable-reference-in-rust-995320366e22","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636643412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056396,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyJPx4r7mYedM4545Dw4tscPLBQoB7zUbf0RD0sfMyAlZgS1m05u953BYukYBvTHUZnUe7E8Ou8w/132","nickname":"Griffenliu","note":"","ucode":"0A5BFC80B3C0A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411458,"discussion_content":"顶，老师或哪位大神解答下~~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635933196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315976,"user_name":"Lex","can_delete":false,"product_type":"c1","uid":1147270,"ip_address":"","ucode":"4D085735CD9DF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/81/86/3f178c08.jpg","comment_is_top":false,"comment_ctime":1634091439,"is_pvip":false,"replies":[{"id":"115281","content":"禁止继续访问的代码编译。问题在编译期就被揪出来了。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635132420,"ip_address":"","comment_id":315976,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5929058735","product_id":100085301,"comment_content":"当栈上的数据被Move后，栈上原来的内存中的数据有变化吗？rust这里是如何处理的，是仅仅由编译器禁止用户代码访问，还是直接在该块内存上写入了某种标记？","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528220,"discussion_content":"禁止继续访问的代码编译。问题在编译期就被揪出来了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635132420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408324,"discussion_content":"简单说，所有权是写代码和编译代码的时候的概念，运行时是不会有所有权的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635227831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672439,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/tLkC8Fe24CbIFib2tNeAMZGq1aSv6dW5GclccjZSwU6AAFb2TSFiajbq4ZrtFRAibGw4jxNaHmicFxGjm7IibmibG87g/132","nickname":"Geek_a34828","note":"","ucode":"4CA07B90ADF776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588164,"discussion_content":"编译器又是如何知道这个值不能访问的呢？总得做点什么吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663582905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037669,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/65/1c9f1530.jpg","nickname":"NorthWind","note":"","ucode":"459ADF3B0945E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576180,"discussion_content":"也就是被 move 后这个值还是在的，但是编译器就是不允许访问，这样理解对么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655343568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312733,"user_name":"humblelei","can_delete":false,"product_type":"c1","uid":1562245,"ip_address":"","ucode":"4FE89EF54BD9B3","user_header":"https://static001.geekbang.org/account/avatar/00/17/d6/85/7f4f7ada.jpg","comment_is_top":false,"comment_ctime":1631955926,"is_pvip":true,"replies":[{"id":"113317","content":"正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631982100,"ip_address":"","comment_id":312733,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5926923222","product_id":100085301,"comment_content":"打卡。<br>1、违背了一个作用域里只能有一个活跃的可变引用<br>2、先使用后修改<br>```<br>fn main() {<br>    let mut arr = vec![1, 2, 3];<br>    &#47;&#47; cache the last item<br>    let last = arr.last();<br>    &#47;&#47; consume previously stored last item<br>    println!(&quot;last: {:?}&quot;, last);<br>    arr.push(4);<br>}<br><br>```","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527093,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631982100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311105,"user_name":"慢动作","can_delete":false,"product_type":"c1","uid":1133945,"ip_address":"","ucode":"62C944F4A4D8AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","comment_is_top":false,"comment_ctime":1631072575,"is_pvip":true,"replies":[{"id":"112760","content":"思考题正确。<br><br>对于可变引用和不可变引用共存的问题，我们看一个例子。我先分配一个 capacity 为 1 的 Vec&lt;i32&gt;，然后放入 32 个元素，此时它会重新分配。如果打印 &amp;v[0] 的堆地址，会看到发生了变化。所以如果我们有指向旧的 &amp;v[0] 的地址，那么就会读到已释放内存。<br><br>```rust<br>use std::mem;<br><br>fn main() {<br>    &#47;&#47; capacity 是 1, len 是 0<br>    let mut v = vec![1];<br>    &#47;&#47; capacity 是 8, len 是 0<br>    let v1: Vec&lt;i32&gt; = Vec::with_capacity(8);<br><br>    print_vec(&quot;v1&quot;, v1);<br><br>    &#47;&#47; 我们先打印 heap 地址，然后看看添加内容是否会导致堆重分配<br>    println!(&quot;heap start: {:p}&quot;, &amp;v[0] as *const i32);<br>    &#47;&#47; Vec&lt;T&gt; 堆内存里 T 的个数是指数增长的，我们让它恰好 push 33 个元素<br>    &#47;&#47; capacity 会变成 64<br>    (2..34).into_iter().for_each(|i| v.push(i));<br><br>    &#47;&#47; heap 地址改变了！这就是为什么可变引用和不可变引用不能共存的原因<br>    println!(&quot;new heap start: {:p}&quot;, &amp;v[0] as *const i32);<br><br>    print_vec(&quot;v&quot;, v);<br>}<br><br>fn print_vec&lt;T&gt;(name: &amp;str, data: Vec&lt;T&gt;) {<br>    let p: [usize; 3] = unsafe { mem::transmute(data) };<br>    &#47;&#47; 打印 Vec&lt;T&gt; 的堆地址，capacity，len<br>    println!(&quot;{}: 0x{:x}, 0x{:x}, 0x{:x}&quot;, name, p[0], p[1], p[2]);<br>}<br>```<br><br>打印结果（地址在你机器上会不一样）：<br><br>```bash<br>v1: 0x7f962e405e00, 0x8, 0x0<br>heap start: 0x7f962e405df0<br>new heap start: 0x7f962e405e20<br>v: 0x7f962e405e20, 0x40, 0x21<br>```","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631111359,"ip_address":"","comment_id":311105,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5926039871","product_id":100085301,"comment_content":"1、可变引用copy导致可变引用和其它引用共存<br>2、活跃可变引用才会和其它引用冲突，可以调换下4，5两行<br><br>可变引用导致堆上数据重新分配，相应的被借用的栈上变量被修改，不可比引用是通过栈间接指向堆的，这种情况实际上没有问题？而文中例子最后一个，&amp;data[0]是堆上的一个引用指向另一个堆数据，赋值过程中有借用，但最终不存在通过被借用变量指向堆这个关系，和可变引用共存就会出问题？现在不会模拟堆上数据重新分配，堆用的太少","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526477,"discussion_content":"思考题正确。\n\n对于可变引用和不可变引用共存的问题，我们看一个例子。我先分配一个 capacity 为 1 的 Vec&amp;lt;i32&amp;gt;，然后放入 32 个元素，此时它会重新分配。如果打印 &amp;amp;v[0] 的堆地址，会看到发生了变化。所以如果我们有指向旧的 &amp;amp;v[0] 的地址，那么就会读到已释放内存。\n\n```rust\nuse std::mem;\n\nfn main() {\n    // capacity 是 1, len 是 0\n    let mut v = vec![1];\n    // capacity 是 8, len 是 0\n    let v1: Vec&amp;lt;i32&amp;gt; = Vec::with_capacity(8);\n\n    print_vec(&amp;quot;v1&amp;quot;, v1);\n\n    // 我们先打印 heap 地址，然后看看添加内容是否会导致堆重分配\n    println!(&amp;quot;heap start: {:p}&amp;quot;, &amp;amp;v[0] as *const i32);\n    // Vec&amp;lt;T&amp;gt; 堆内存里 T 的个数是指数增长的，我们让它恰好 push 33 个元素\n    // capacity 会变成 64\n    (2..34).into_iter().for_each(|i| v.push(i));\n\n    // heap 地址改变了！这就是为什么可变引用和不可变引用不能共存的原因\n    println!(&amp;quot;new heap start: {:p}&amp;quot;, &amp;amp;v[0] as *const i32);\n\n    print_vec(&amp;quot;v&amp;quot;, v);\n}\n\nfn print_vec&amp;lt;T&amp;gt;(name: &amp;amp;str, data: Vec&amp;lt;T&amp;gt;) {\n    let p: [usize; 3] = unsafe { mem::transmute(data) };\n    // 打印 Vec&amp;lt;T&amp;gt; 的堆地址，capacity，len\n    println!(&amp;quot;{}: 0x{:x}, 0x{:x}, 0x{:x}&amp;quot;, name, p[0], p[1], p[2]);\n}\n```\n\n打印结果（地址在你机器上会不一样）：\n\n```bash\nv1: 0x7f962e405e00, 0x8, 0x0\nheap start: 0x7f962e405df0\nnew heap start: 0x7f962e405e20\nv: 0x7f962e405e20, 0x40, 0x21\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631111359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574826,"discussion_content":"不太能理解这里v1的作用是什么？尝试去掉v1，heap start和new start的地址是一样的！这里v1是为了避免一些编译器对v的优化处理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654393185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392782,"discussion_content":"嗯，理解了。原先只盯着引用看，觉得引用可以正常使用，但引用可以给出地址，地址是不会跟着变的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631115652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311076,"user_name":"gnu","can_delete":false,"product_type":"c1","uid":1631832,"ip_address":"","ucode":"B598402D9377D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/e6/58/a0f74927.jpg","comment_is_top":false,"comment_ctime":1631064865,"is_pvip":false,"replies":[{"id":"112733","content":"哈哈很好的学习习惯，等你下一份作业","user_name":"编辑回复","user_name_real":"叶如芊","uid":"2547771","ctime":1631065942,"ip_address":"","comment_id":311076,"utype":2}],"discussion_count":1,"race_medal":0,"score":"5926032161","product_id":100085301,"comment_content":"fn main() {<br>    let mut arr = vec![1, 2, 3];<br>    &#47;&#47; cache the last item<br>    let last = arr.last();<br>    &#47;&#47; consume previously stored last item<br>    println!(&quot;last: {:?}&quot;, last);<br>    arr.push(4);<br>}<br><br><br>看着 rustc --explain E0502 的例子修改，不过好像还是没有理解原因...在听一遍 借用 的部分😂","like_count":1,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526464,"discussion_content":"哈哈很好的学习习惯，等你下一份作业","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631065942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354929,"user_name":"Qixian","can_delete":false,"product_type":"c1","uid":2078050,"ip_address":"浙江","ucode":"EE4B2A67F44CD4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/uEO3jibbiaWwYLQAIxV9icKG2E5UiaZj1c3GDlczhRrQy8IJHVmicwPAomJdRpUIWyShZpJqkD20icUMMicic5OnXJCRSQ/132","comment_is_top":false,"comment_ctime":1660889189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660889189","product_id":100085301,"comment_content":"关于代码3，有几个疑问想请教一下老师。<br>1. data1的值是 data在栈上的地址？<br>2. data1传参的时候 应该是发生了值的拷贝？那data1&#39;的值也应该是data在栈上的地址？<br>3. 为什么sum函数中输出data1&#39;的值的时候，结果直接是动态数组在堆上的起始地址？","like_count":0},{"had_liked":false,"id":349198,"user_name":"Geek_0ba253","can_delete":false,"product_type":"c1","uid":2612720,"ip_address":"","ucode":"55D6DDECC9AF60","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QvyPibAqLH5uEr7GNL6Lg9jT9sUs9jtub4LvO575nHuT3viagzmvKLCwGQRicsiadic3n9lM62qQ6n5shHfXUYib8Ktg/132","comment_is_top":false,"comment_ctime":1655794244,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1655794244","product_id":100085301,"comment_content":"第一题：可变引用不需要Copy，如果实现Copy之后，变量所有权 的拥有者 在借用出去之后，变量的值变化不能体现到 原变量上，可变引用就没有意义了。<br><br>第二题：不直接读取可变引用的变量，通过复制读取不可变引用的变量 <br>代码如下<br>```rust<br>fn main() {<br>    let mut arr = vec![1, 2, 3];<br>    &#47;&#47; cache the last item<br>    let temp = arr.clone();<br>    let last = temp.last();<br>    arr.push(4);<br>    &#47;&#47; consume previously stored last item<br>    println!(&quot;last: {:?}&quot;, last);<br>}<br>```","like_count":0},{"had_liked":false,"id":348934,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":2853200,"ip_address":"","ucode":"BBDF8E9F348F65","user_header":"https://static001.geekbang.org/account/avatar/00/2b/89/50/aee9fdab.jpg","comment_is_top":false,"comment_ctime":1655568406,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655568406","product_id":100085301,"comment_content":"&#47;&#47; 可变借用没有实现Copy trait。为什么？<br>这样会导致两个可变引用同时存在，或者可变引用和只读引用同时存在<br><br>&#47;&#47; 避免同时有只读引用和可变引用<br>‘’‘rust’’‘<br>fn main() {<br>    let mut arr = vec![1, 2, 3];<br>    arr.push(4);<br>    &#47;&#47; cache the last item<br>    let last = arr.last();<br>    &#47;&#47; consume previously stored last item<br>    println!(&quot;last: {:?}&quot;, last);<br> }<br>‘’‘可以将其移动到上面，让可变引用充分使用完，再切换成只读引用的使用’‘’","like_count":0},{"had_liked":false,"id":346981,"user_name":"廖成","can_delete":false,"product_type":"c1","uid":1015946,"ip_address":"","ucode":"AD98B920AA7DCC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/8a/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1653576094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653576094","product_id":100085301,"comment_content":"第二题：<br>fn main() {<br>  let mut arr = vec![1, 2, 3];<br>  &#47;&#47; cache the last item<br>  let last = arr.last();<br>  let v = match arr.last() {<br>    Some(v) =&gt; Some(*v),<br>    None =&gt; None<br>  };<br>  <br>  arr.push(4);<br>  &#47;&#47; consume previously stored last item<br>  println!(&quot;{:?}&quot;, v.unwrap());<br>}<br>","like_count":0},{"had_liked":false,"id":345893,"user_name":"ELSE","can_delete":false,"product_type":"c1","uid":1172907,"ip_address":"","ucode":"72448D7271C8B0","user_header":"https://static001.geekbang.org/account/avatar/00/11/e5/ab/56f348e5.jpg","comment_is_top":false,"comment_ctime":1652681925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652681925","product_id":100085301,"comment_content":"到这里，有一个疑问，是不是把所有的类型都实现了“copy trait”，就万事大吉了？","like_count":0},{"had_liked":false,"id":345750,"user_name":"gavin","can_delete":false,"product_type":"c1","uid":1171879,"ip_address":"","ucode":"8DAC42D1A564D1","user_header":"http://thirdwx.qlogo.cn/mmopen/KFgDEHIEpnT0EXnh02VHqCETJickQpyszbSo5uFBG1ZwdhnzpM2ibFP3v658Pj1ojOHTygibeXMhyFdl0AzSmZuVO4iacUnal8RV/132","comment_is_top":false,"comment_ctime":1652546483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652546483","product_id":100085301,"comment_content":"fn main() {<br>  let mut arr = vec![1, 2, 3];<br>  &#47;&#47; cache the last item<br><br>  arr.push(4);<br>  let last = arr.last();<br>  &#47;&#47; consume previously stored last item<br>  println!(&quot;last: {:?}&quot;, last);<br>}<br><br>先push后使用，即先写后读，避免同一时候有读和写存在","like_count":0},{"had_liked":false,"id":342343,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1650203138,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1650203138","product_id":100085301,"comment_content":"有个疑问：<br>let last = arr.last(); 这段代码last 引用的是arr 中的一个元素 也算满足”只读和可写引用，同时只能有一个“么，如果是的话为什么let last = arr[arr.len()-1]; 也是引用其中一个元素 为什么却是可以的啊，还请大佬帮忙解答下","like_count":0,"discussions":[{"author":{"id":3177536,"avatar":"https://static001.geekbang.org/account/avatar/00/30/7c/40/c1d837b5.jpg","nickname":"康宝combo","note":"","ucode":"07672F87CA52AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587808,"discussion_content":"pub const fn last(&amp;self) -&gt; Option&lt;&amp;T&gt;。 last方法返回的是一个Option，包裹的是&amp;T。而a[i]，是*a.index(i)的语法糖，因此返回的是切片中的具体类型，而不是引用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663300311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341847,"user_name":"习惯","can_delete":false,"product_type":"c1","uid":2183344,"ip_address":"","ucode":"2E61B2C235B6FE","user_header":"https://static001.geekbang.org/account/avatar/00/21/50/b0/9e80e838.jpg","comment_is_top":false,"comment_ctime":1649859542,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649859542","product_id":100085301,"comment_content":"&amp;*data是什么意思啊，亲爱的老师","like_count":0},{"had_liked":false,"id":341054,"user_name":"SolskGaer","can_delete":false,"product_type":"c1","uid":2217642,"ip_address":"","ucode":"31C42B7A85D5AB","user_header":"https://static001.geekbang.org/account/avatar/00/21/d6/aa/ffa0bd0e.jpg","comment_is_top":false,"comment_ctime":1649316486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649316486","product_id":100085301,"comment_content":"想请教一下老师关于&amp;&amp;data值的问题，&amp;data是会生成一个临时变量，然后&amp;&amp;data取的是这个临时变量的值吗？","like_count":0},{"had_liked":false,"id":335269,"user_name":"2qif49lt","can_delete":false,"product_type":"c1","uid":1061853,"ip_address":"","ucode":"F9AF272776CEDA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6oiaaIrgh7A3gy0FxVx8kIhUVp9U0ibSxIBCZHK9Ivo4PY1gibmBVicKTBGjaDVCUxObDdrYVwzmmwVA/132","comment_is_top":false,"comment_ctime":1645433860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645433860","product_id":100085301,"comment_content":"&quot;而情况 2 的代码虽然在堆内存里引用栈内存，但生命周期是相同的，所以没有问题。&quot;<br><br> 在退出当前函数栈，变量进行析构时，不要考虑谁先谁后吗？","like_count":0},{"had_liked":false,"id":333177,"user_name":"nuan","can_delete":false,"product_type":"c1","uid":2905523,"ip_address":"","ucode":"55FF98EB85404D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDqHQQByGiaXcAk94MdDn3ftupZLXyR6bAKibxOzMxy5h3uBwZ7QiaCiaIfbCMK0cIQfGNax8iawoiaQAg/132","comment_is_top":false,"comment_ctime":1644160769,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1644160769","product_id":100085301,"comment_content":"“而 playground 是 Linux 环境，我一直试到 &gt; 128KB 内存才让 Vec的堆内存重分配。”<br>我的linux环境（windows 10 -&gt; vmware workstation -&gt; ubuntu 20.04 x64)在大于 32KB（即将34变为32770，此时capacity 为65536，len为32769）时Vec的堆内存地址才变的，尝试更改了系统内存，值也不会变小。<br>请问老师，这个值是和编译器实现（CPU架构）有关吗？","like_count":0},{"had_liked":false,"id":333097,"user_name":"侯恩训","can_delete":false,"product_type":"c1","uid":1162376,"ip_address":"","ucode":"F4DC47EECA0F00","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/88/fbb6022e.jpg","comment_is_top":false,"comment_ctime":1644062756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644062756","product_id":100085301,"comment_content":"问题1<br>如果可变引用实现了copy trait，相当于多个地方可以同时修改同一块数据，违背“一个值同一个时刻只有一个所有者”","like_count":0},{"had_liked":false,"id":331392,"user_name":"王彦霖","can_delete":false,"product_type":"c1","uid":2868952,"ip_address":"","ucode":"F9BFDD0C3657AB","user_header":"https://static001.geekbang.org/account/avatar/00/2b/c6/d8/672f1838.jpg","comment_is_top":false,"comment_ctime":1642571718,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642571718","product_id":100085301,"comment_content":"第二题关于上下移动push方法的解题形式，我不是很理解：移上去移下来不都在main里面吗？<br>我的理解是在‘immutable borrow’ used之前（或者说生命周期之内），不能存在‘mutable borrow’？<br>但是last这个变量的生命周期理论上和arr是一样的呀","like_count":0},{"had_liked":false,"id":328205,"user_name":"A 凡","can_delete":false,"product_type":"c1","uid":1197361,"ip_address":"","ucode":"BDC8DB599B8284","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/31/53910b61.jpg","comment_is_top":false,"comment_ctime":1640605194,"is_pvip":false,"replies":[{"id":"120779","content":"对","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642309541,"ip_address":"","comment_id":328205,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640605194","product_id":100085301,"comment_content":"<br>fn main() {<br>  let mut arr = vec![1, 2, 3];<br>  &#47;&#47; cache the last item<br>  let last = arr.last();<br>  arr.push(4);<br>  &#47;&#47; consume previously stored last item<br>  println!(&quot;last: {:?}&quot;, last);<br>}<br>关于这段代码的问题是因为 vec 中 pub const fn last(&amp;self) -&gt; Option&lt;&amp;T&gt; 使用的是只读引用，而vec 中的pub fn push(&amp;mut self, value: T) 使用的是可变引用导致的的错误么","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546418,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642309541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325558,"user_name":"裴晓勇","can_delete":false,"product_type":"c1","uid":1689762,"ip_address":"","ucode":"09D179AAF5EB3A","user_header":"https://static001.geekbang.org/account/avatar/00/19/c8/a2/f7f82bf9.jpg","comment_is_top":false,"comment_ctime":1639020594,"is_pvip":false,"replies":[{"id":"118827","content":"你理解的问题。编译器会决定变量在栈内存中的分配，它并不一定是按照从左到右，从上到下的顺序分配。比如这个代码：<br><br>```rust<br>fn main() {<br>    do_it();<br>}<br><br>fn do_it() -&gt; i32 {<br>    let a = 1;<br>    let b = 2;<br>    let c = 3;<br>    let d = 4;<br>    let e = 5;<br>    3 * (a+b) * (d - c) &#47; e<br>}<br>```<br><br>do_it() 的汇编代码如下（你可以在 playground 下 show assembly 看到）：<br><br>```asm<br>playground::do_it:<br>\tsubq\t$40, %rsp<br>\tmovl\t$1, 20(%rsp)<br>\tmovl\t$2, 24(%rsp)<br>\tmovl\t$3, 28(%rsp)<br>\tmovl\t$4, 32(%rsp)<br>\tmovl\t$5, 36(%rsp)<br>\tmovl\t$4, %eax<br>\tsubl\t$3, %eax<br>\tmovl\t%eax, 16(%rsp)<br>\tseto\t%al<br>\ttestb\t$1, %al<br>\tjne\t.LBB12_2<br>\tmovl\t16(%rsp), %eax<br>\tmovl\t$9, %ecx<br>\timull\t%ecx, %eax<br>\tmovl\t%eax, 12(%rsp)<br>\tseto\t%al<br>\ttestb\t$1, %al<br>\tjne\t.LBB12_4<br>\tjmp\t.LBB12_3<br>```<br>你可以看第一句：subq\t$40, %rsp，它将 stack 向下增长了 40 字节（subq 是减法操作，rsp 是 stack pointer，这句话让 rsp 指向了 rsp - 40）。可以看到栈是向下增长的。然后变量 a 存在 rsp + 20，b 存在 rsp + 24，所以你会看到，后定义的变量 b 的地址比先定义的变量 a 的地址还高。<br>","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639807376,"ip_address":"","comment_id":325558,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639020594","product_id":100085301,"comment_content":"&amp;&amp;data的疑惑<br>println!中打印&amp;&amp;data的话，应该是打印保存&amp;data临时变量的地址<br>我的疑问是，这个地址应该是在println!的栈上，地址应该是在main的栈的下方（地址变低了），但是我打印出来的这个地址居然比main的栈的地址要高<br>addr of value: 0x7fffffffdcb8(0x7fffffffdcb8), addr of data 0x7fffffffdd78, data1: 0x7fffffffdcd0<br>这是为什么？是我理解的有问题？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539703,"discussion_content":"你理解的问题。编译器会决定变量在栈内存中的分配，它并不一定是按照从左到右，从上到下的顺序分配。比如这个代码：\n\n```rust\nfn main() {\n    do_it();\n}\n\nfn do_it() -&gt; i32 {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let d = 4;\n    let e = 5;\n    3 * (a+b) * (d - c) / e\n}\n```\n\ndo_it() 的汇编代码如下（你可以在 playground 下 show assembly 看到）：\n\n```asm\nplayground::do_it:\n\tsubq\t$40, %rsp\n\tmovl\t$1, 20(%rsp)\n\tmovl\t$2, 24(%rsp)\n\tmovl\t$3, 28(%rsp)\n\tmovl\t$4, 32(%rsp)\n\tmovl\t$5, 36(%rsp)\n\tmovl\t$4, %eax\n\tsubl\t$3, %eax\n\tmovl\t%eax, 16(%rsp)\n\tseto\t%al\n\ttestb\t$1, %al\n\tjne\t.LBB12_2\n\tmovl\t16(%rsp), %eax\n\tmovl\t$9, %ecx\n\timull\t%ecx, %eax\n\tmovl\t%eax, 12(%rsp)\n\tseto\t%al\n\ttestb\t$1, %al\n\tjne\t.LBB12_4\n\tjmp\t.LBB12_3\n```\n你可以看第一句：subq\t$40, %rsp，它将 stack 向下增长了 40 字节（subq 是减法操作，rsp 是 stack pointer，这句话让 rsp 指向了 rsp - 40）。可以看到栈是向下增长的。然后变量 a 存在 rsp + 20，b 存在 rsp + 24，所以你会看到，后定义的变量 b 的地址比先定义的变量 a 的地址还高。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639807376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322575,"user_name":"Geek_9d1ee1","can_delete":false,"product_type":"c1","uid":2541935,"ip_address":"","ucode":"D09037B4B3EE53","user_header":"","comment_is_top":false,"comment_ctime":1637485722,"is_pvip":false,"replies":[{"id":"118902","content":"可以啊","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639851837,"ip_address":"","comment_id":322575,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637485722","product_id":100085301,"comment_content":"data.iter().fold(0, |acc, x| acc + x) <br><br>为什么不直接 data.iter().sum()?","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539863,"discussion_content":"可以啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639851838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322481,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1637410055,"is_pvip":false,"replies":[{"id":"118906","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639852004,"ip_address":"","comment_id":322481,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637410055","product_id":100085301,"comment_content":"今天重新回看的时候，重新梳理了一下copy，move和clone的区别，为什么只有一些基本类型实现copy 语义，因为这些类型可以在栈上分配空间直接复制，而clone是深拷贝，把数据和指向数据的指针都新生成一份，而move就是指向堆上的指针每时刻只有一个，保证不会有多个同时指向的。因此如果像vec这些数据分配在堆上的类型也实现copy，那么就出现多个指针同时指向该堆上的数据了，违反所有权了。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539867,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639852004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314254,"user_name":"乱匠","can_delete":false,"product_type":"c1","uid":1197941,"ip_address":"","ucode":"9FAC4E465C3582","user_header":"https://static001.geekbang.org/account/avatar/00/12/47/75/4d59b6b5.jpg","comment_is_top":false,"comment_ctime":1632915380,"is_pvip":false,"replies":[{"id":"113977","content":"嗯，也是一种方法","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633321111,"ip_address":"","comment_id":314254,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632915380","product_id":100085301,"comment_content":"通过将值拷贝走的方式解决第二题<br><br>fn main() {<br>    let mut arr: Vec&lt;i32&gt; = vec![1, 2, 3];<br><br>    let last = if let Some(l) = arr.last() {<br>        Some(*l)<br>    } else {<br>        None<br>    };<br><br>    arr.push(4);<br>    println!(&quot;last: {:?}&quot;, last);<br>}<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527622,"discussion_content":"嗯，也是一种方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633321111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313849,"user_name":"iamasb","can_delete":false,"product_type":"c1","uid":2659298,"ip_address":"","ucode":"EDDAEC1527736A","user_header":"https://static001.geekbang.org/account/avatar/00/28/93/e2/485fb9b9.jpg","comment_is_top":false,"comment_ctime":1632710446,"is_pvip":false,"replies":[{"id":"113631","content":"应该是 &amp;*","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632725927,"ip_address":"","comment_id":313849,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1632710446","product_id":100085301,"comment_content":"老师，在代码2中，println!(        &quot;addr of value: {:p}({:p}), addr of data {:p}, data1: {:p}&quot;,        &amp;data, data1, &amp;&amp;data, &amp;data1    ); 第三个&amp;&amp;data，是不是写多了个&amp;","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527491,"discussion_content":"应该是 &amp;amp;*","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632725927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408322,"discussion_content":"这里应该就是 &amp;&amp; 不是多写了。\n我理解哈：\n&amp;data 是打印 data 的地址\n&amp;&amp;data 是打印 &amp;data 的地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635227651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313133,"user_name":"青样儿","can_delete":false,"product_type":"c1","uid":1531381,"ip_address":"","ucode":"F9618962B74C25","user_header":"https://static001.geekbang.org/account/avatar/00/17/5d/f5/9c21ec45.jpg","comment_is_top":false,"comment_ctime":1632290253,"is_pvip":false,"replies":[{"id":"113467","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632357876,"ip_address":"","comment_id":313133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632290253","product_id":100085301,"comment_content":"使用数组下标取值，或者先push在使用last","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527244,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632357876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312932,"user_name":"liu shuang","can_delete":false,"product_type":"c1","uid":2764804,"ip_address":"","ucode":"2FDAE12D37FE70","user_header":"https://static001.geekbang.org/account/avatar/00/2a/30/04/0c02f030.jpg","comment_is_top":false,"comment_ctime":1632127267,"is_pvip":false,"replies":[{"id":"113364","content":"&amp;&amp;data 表示对引用的引用，你可以这么想：引用是一层 indirection，引用的引用是两层 indirection。实际中 &amp;&amp;data 用的并不多，但 &amp;mut &amp;data 比较常见。参考讲生命周期那堂 strtok 的实现。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632152927,"ip_address":"","comment_id":312932,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632127267","product_id":100085301,"comment_content":"&#47;&#47; 值的地址是什么？引用的地址又是什么？ <br>println!( &quot;addr of value: {:p}({:p}), addr of data {:p}, data1: {:p}&quot;, &amp;data, data1, &amp;&amp;data, &amp;data1 );<br><br>&amp;&amp;data -&gt;  有实际的含义吗？如果写法有问题，麻烦老师也及时修改下。感谢！<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527165,"discussion_content":"&amp;amp;&amp;amp;data 表示对引用的引用，你可以这么想：引用是一层 indirection，引用的引用是两层 indirection。实际中 &amp;amp;&amp;amp;data 用的并不多，但 &amp;amp;mut &amp;amp;data 比较常见。参考讲生命周期那堂 strtok 的实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632152927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312008,"user_name":"胡小涵","can_delete":false,"product_type":"c1","uid":2004538,"ip_address":"","ucode":"2E750C65EC282C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/96/3a/e06f8367.jpg","comment_is_top":false,"comment_ctime":1631589658,"is_pvip":false,"replies":[{"id":"113075","content":"是的","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631601868,"ip_address":"","comment_id":312008,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631589658","product_id":100085301,"comment_content":"“一个值只能有一个所有者”的意思是不是，一个值是必须有一个，而且只能有一个owner？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526829,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631601868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311928,"user_name":"Ethan Liu","can_delete":false,"product_type":"c1","uid":1070043,"ip_address":"","ucode":"231F944F7CD56A","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","comment_is_top":false,"comment_ctime":1631533091,"is_pvip":true,"replies":[{"id":"113076","content":"你可以看看我在别人的留言下的回答，可变引用在使用时会进行 reborrow。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631601922,"ip_address":"","comment_id":311928,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631533091","product_id":100085301,"comment_content":"可变引用没有实现copy trait, 那可变引用如何进行函数参数传递?","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526803,"discussion_content":"你可以看看我在别人的留言下的回答，可变引用在使用时会进行 reborrow。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631601922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311792,"user_name":"bbndd","can_delete":false,"product_type":"c1","uid":1761870,"ip_address":"","ucode":"4333E2E020D4F6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e2/4e/829f321f.jpg","comment_is_top":false,"comment_ctime":1631460822,"is_pvip":false,"replies":[{"id":"112988","content":"可以。clone() 不是很必要，因为 i32 实现了 Copy。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631514842,"ip_address":"","comment_id":311792,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631460822","product_id":100085301,"comment_content":"第2题这样也可以编译通过，vec 换成 String 也可以：<br>```<br>fn main() {<br>  let mut arr = vec![1, 2, 3];<br>  &#47;&#47; cache the last item<br>  let last = arr.last().unwrap().clone();<br>  arr.push(4);<br>  &#47;&#47; consume previously stored last item<br>  println!(&quot;last: {:?}&quot;, last);<br>}<br>```","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526746,"discussion_content":"可以。clone() 不是很必要，因为 i32 实现了 Copy。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631514842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311412,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1631231432,"is_pvip":true,"replies":[{"id":"112852","content":"正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631237711,"ip_address":"","comment_id":311412,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631231432","product_id":100085301,"comment_content":"1. 会出现一块内存，被多个引用修改的情况<br>2. 4，5行换个位置，让arr先做完它的活在被borrow出去。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526592,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631237711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311342,"user_name":"芥末小龙","can_delete":false,"product_type":"c1","uid":1176417,"ip_address":"","ucode":"387D01880867AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/61/8f7fca5b.jpg","comment_is_top":false,"comment_ctime":1631179230,"is_pvip":false,"replies":[{"id":"112837","content":"慢慢来，掌握一些知识，实践；再掌握一些，再实践。随着代码写得越来越多，就会越来越明白的。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631196801,"ip_address":"","comment_id":311342,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631179230","product_id":100085301,"comment_content":"每次学完后都有一种我学了好多东西，又什么东西都没有学好的感觉。第二题两种引用的位置就可以，可变引用（写）和只读引用（读）是互斥的关系，只要保持这两种引用不交叉就可以。在多个只读引用中不能交叉存在可变引用。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526566,"discussion_content":"慢慢来，掌握一些知识，实践；再掌握一些，再实践。随着代码写得越来越多，就会越来越明白的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631196801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311339,"user_name":"亚伦碎语","can_delete":false,"product_type":"c1","uid":1014505,"ip_address":"","ucode":"F32E5E1B63CC90","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/e9/da5c0203.jpg","comment_is_top":false,"comment_ctime":1631178157,"is_pvip":false,"replies":[{"id":"112836","content":"嗯，这个方法可行，也可以简化成：<br><br>```rust<br> let last = arr[arr.len() - 1];<br>```<br><br>但注意这里因为 i32 是 Copy，所以可行。如果是 Vec 里放的是 String，就不能这么做了。只能移动后两行的顺序。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631196730,"ip_address":"","comment_id":311339,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631178157","product_id":100085301,"comment_content":"1. 因为可变引用随着值的变化，有可能发生内存的重新分配和拷贝，copy trait 是个浅拷贝，如果实现了，发生了重新分配的话，导致浅拷贝的引用失效。<br><br>2. 第二题换了另外一个思路，如果非要print在后边，那就先把值存起来，后边再用<br>```<br>fn main(){<br>    let mut arr = vec![1,2,3];<br>    let last: i32 = *arr.last().unwrap();<br>    arr.push(4);<br>    println!(&quot;ir:{:?}&quot;, last);<br><br>}<br>```","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526564,"discussion_content":"嗯，这个方法可行，也可以简化成：\n\n```rust\n let last = arr[arr.len() - 1];\n```\n\n但注意这里因为 i32 是 Copy，所以可行。如果是 Vec 里放的是 String，就不能这么做了。只能移动后两行的顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631196730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311324,"user_name":"noisyes","can_delete":false,"product_type":"c1","uid":2538540,"ip_address":"","ucode":"94EC310B284AD2","user_header":"https://static001.geekbang.org/account/avatar/00/26/bc/2c/963688bb.jpg","comment_is_top":false,"comment_ctime":1631173537,"is_pvip":false,"replies":[{"id":"112835","content":"这里为了代码的撰写方便，会自动做 reborrow，使得之前的可变引用还可以复用。在函数传参时，传给函数的实际是 &amp;mut *v，你可以看看我在之前留言下的回答。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631196563,"ip_address":"","comment_id":311324,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631173537","product_id":100085301,"comment_content":"第一题,可变引用没有实现copy trait的话，当一个可变引用传给类型是可变引用的函数参数时 是move吗，那从函数返回后原来的可变引用失效？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526560,"discussion_content":"这里为了代码的撰写方便，会自动做 reborrow，使得之前的可变引用还可以复用。在函数传参时，传给函数的实际是 &amp;amp;mut *v，你可以看看我在之前留言下的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631196563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311236,"user_name":"kylin","can_delete":false,"product_type":"c1","uid":1351248,"ip_address":"","ucode":"3588B62A4F9534","user_header":"https://static001.geekbang.org/account/avatar/00/14/9e/50/21e0beca.jpg","comment_is_top":false,"comment_ctime":1631113940,"is_pvip":true,"replies":[{"id":"112811","content":"首先引用和裸指针不能画等号。引用有更多的使用限制。引用根据上下文，可以是单个指针，比如 &amp;Vec&lt;T&gt;（地址），也可以是胖指针，比如 &amp;[u8]（地址+长度）。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631160039,"ip_address":"","comment_id":311236,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631113940","product_id":100085301,"comment_content":"老师，java的引用是不是可以理解为就是一个裸指针，传引用就相当于复制了一个裸指针，这时两个裸指针指向同一块堆内空间？而rust通过胖指针指向堆，胖指针的引用可以看做是裸指针，rust中引用的值是胖指针的地址，引用的引用就是裸指针的地址？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526534,"discussion_content":"首先引用和裸指针不能画等号。引用有更多的使用限制。引用根据上下文，可以是单个指针，比如 &amp;amp;Vec&amp;lt;T&amp;gt;（地址），也可以是胖指针，比如 &amp;amp;[u8]（地址+长度）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631160039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311134,"user_name":"茶底","can_delete":false,"product_type":"c1","uid":1188926,"ip_address":"","ucode":"687DD3686A84D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/3e/692a93f7.jpg","comment_is_top":false,"comment_ctime":1631083881,"is_pvip":false,"replies":[{"id":"112775","content":":)","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631148296,"ip_address":"","comment_id":311134,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631083881","product_id":100085301,"comment_content":"已然是抢答环节了","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526487,"discussion_content":":)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631148296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311073,"user_name":"Custer","can_delete":false,"product_type":"c1","uid":1020822,"ip_address":"","ucode":"8AEA5544C94D57","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/96/575d42c3.jpg","comment_is_top":false,"comment_ctime":1631064027,"is_pvip":true,"replies":[{"id":"112736","content":"第一题正确！<br><br>第二题这个解法可行，但改变了原代码的需求，因为它想把 3 这个值打印出来。可以看看我在其他答案上的回复。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631070129,"ip_address":"","comment_id":311073,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631064027","product_id":100085301,"comment_content":"如果可变引用实现了Copy trait，那么一个值就有多个活跃的可变引用，就违背了一个值在同一时刻只有一个所有者。<br><br>fn main() {<br>  let mut arr = vec![1, 2, 3];<br>  arr.push(4);<br>  println!(&quot;last: {:?}&quot;, arr.last());<br>arr<br>}","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526461,"discussion_content":"第一题正确！\n\n第二题这个解法可行，但改变了原代码的需求，因为它想把 3 这个值打印出来。可以看看我在其他答案上的回复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631070129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311069,"user_name":"Christian","can_delete":false,"product_type":"c1","uid":1089000,"ip_address":"","ucode":"D84F866015BA07","user_header":"https://static001.geekbang.org/account/avatar/00/10/9d/e8/39433235.jpg","comment_is_top":false,"comment_ctime":1631063163,"is_pvip":false,"replies":[{"id":"112737","content":"正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631070145,"ip_address":"","comment_id":311069,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631063163","product_id":100085301,"comment_content":"1. 可变引用独占对值的访问。<br>2. 调换第 5 和第 7 行代码。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526458,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631070145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311063,"user_name":"Joseph","can_delete":false,"product_type":"c1","uid":1085994,"ip_address":"","ucode":"B031FACEBEE273","user_header":"https://static001.geekbang.org/account/avatar/00/10/92/2a/bae66865.jpg","comment_is_top":false,"comment_ctime":1631061523,"is_pvip":true,"replies":[{"id":"112739","content":"传值传引用用 Java 这样人尽皆知的语言类比会更容易懂。C++ 毕竟使用的人少。<br><br>后面讲 Box&lt;T&gt; 的时候会和 C++ 的 unique_ptr 对比。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631070387,"ip_address":"","comment_id":311063,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1631061523","product_id":100085301,"comment_content":"使用java类比rust本身就不太恰当，为啥不用c++","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526454,"discussion_content":"传值传引用用 Java 这样人尽皆知的语言类比会更容易懂。C++ 毕竟使用的人少。\n\n后面讲 Box&amp;lt;T&amp;gt; 的时候会和 C++ 的 unique_ptr 对比。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631070387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1085994,"avatar":"https://static001.geekbang.org/account/avatar/00/10/92/2a/bae66865.jpg","nickname":"Joseph","note":"","ucode":"B031FACEBEE273","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392565,"discussion_content":"我个人更倾向于把rust看做改良版本的c++，因为历史负担小，所以可以更大改良，rust如何以二进制格式给别人复用？这个我有点困惑，c++有头文件加库，java是jar，难道rust都要源代码吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631062686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1085994,"avatar":"https://static001.geekbang.org/account/avatar/00/10/92/2a/bae66865.jpg","nickname":"Joseph","note":"","ucode":"B031FACEBEE273","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":392617,"discussion_content":"rust 可以通过cbindgen生成c头文件给c系语言和Swift用。可以通过jni和Java互操作。第6讲已经演示了rust和Java script/Python3的互操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631073042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":392565,"ip_address":""},"score":392617,"extra":""},{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1085994,"avatar":"https://static001.geekbang.org/account/avatar/00/10/92/2a/bae66865.jpg","nickname":"Joseph","note":"","ucode":"B031FACEBEE273","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":392619,"discussion_content":"rust的确是更好的c++，我的意思是讲课的时候不必只和c++看齐，那样就乏味了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631073139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":392565,"ip_address":""},"score":392619,"extra":""},{"author":{"id":1085994,"avatar":"https://static001.geekbang.org/account/avatar/00/10/92/2a/bae66865.jpg","nickname":"Joseph","note":"","ucode":"B031FACEBEE273","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":392627,"discussion_content":"这种复用模式我知道，我是说原生rust库复用模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631079686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":392617,"ip_address":""},"score":392627,"extra":""}]}]}]}