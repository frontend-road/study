{"id":307469,"title":"15 | 内存模型：Go如何保证并发读写的顺序？","content":"<p>你好，我是鸟窝。</p><p>Go官方文档里专门介绍了Go的<a href=\"https://golang.org/ref/mem\">内存模型</a>，你不要误解这里的内存模型的含义，它并不是指Go对象的内存分配、内存回收和内存整理的规范，它描述的是并发环境中多goroutine读相同变量的时候，变量的可见性条件。具体点说，就是指，在什么条件下，goroutine在读取一个变量的值的时候，能够看到其它goroutine对这个变量进行的写的结果。</p><p>由于CPU指令重排和多级Cache的存在，保证多核访问同一个变量这件事儿变得非常复杂。毕竟，不同CPU架构（x86/amd64、ARM、Power等）的处理方式也不一样，再加上编译器的优化也可能对指令进行重排，所以编程语言需要一个规范，来明确多线程同时访问同一个变量的可见性和顺序（ Russ Cox在麻省理工学院 <a href=\"https://pdos.csail.mit.edu/6.824/\">6.824 分布式系统Distributed Systems课程</a> 的一课，专门介绍了相关的<a href=\"http://nil.csail.mit.edu/6.824/2016/notes/gomem.pdf\">知识</a>）。在编程语言中，这个规范被叫做内存模型。</p><p>除了Go，Java、C++、C、C#、Rust等编程语言也有内存模型。为什么这些编程语言都要定义内存模型呢？在我看来，主要是两个目的。</p><ul>\n<li>向广大的程序员提供一种保证，以便他们在做设计和开发程序时，面对同一个数据同时被多个goroutine访问的情况，可以做一些串行化访问的控制，比如使用Channel或者sync包和sync/atomic包中的并发原语。</li>\n<li>允许编译器和硬件对程序做一些优化。这一点其实主要是为编译器开发者提供的保证，这样可以方便他们对Go的编译器做优化。</li>\n</ul><!-- [[[read_end]]] --><p>既然内存模型这么重要，今天，我们就来花一节课的时间学习一下。</p><p>首先，我们要先弄明白重排和可见性的问题，因为它们影响着程序实际执行的顺序关系。</p><h1>重排和可见性的问题</h1><p><strong>由于指令重排，代码并不一定会按照你写的顺序执行</strong>。</p><p>举个例子，当两个goroutine同时对一个数据进行读写时，假设goroutine g1对这个变量进行写操作w，goroutine g2同时对这个变量进行读操作r，那么，如果g2在执行读操作r的时候，已经看到了g1写操作w的结果，那么，也不意味着g2能看到在w之前的其它的写操作。这是一个反直观的结果，不过的确可能会存在。</p><p>接下来，我再举几个具体的例子，带你来感受一下，重排以及多核CPU并发执行导致程序的运行和代码的书写顺序不一样的情况。</p><p>先看第一个例子，代码如下：</p><pre><code>var a, b int\n\nfunc f() {\n\ta = 1 // w之前的写操作\n\tb = 2 // 写操作w\n}\n\nfunc g() {\n\tprint(b) // 读操作r\n\tprint(a) // ???\n}\n\nfunc main() {\n\tgo f() //g1\n\tg() //g2\n}\n</code></pre><p>可以看到，第9行是要打印b的值。需要注意的是，即使这里打印出的值是2，但是依然可能在打印a的值时，打印出初始值0，而不是1。这是因为，程序运行的时候，不能保证g2看到的a和b的赋值有先后关系。</p><p>再来看一个类似的例子。</p><pre><code>var a string\nvar done bool\n\nfunc setup() {\n\ta = &quot;hello, world&quot;\n\tdone = true\n}\n\nfunc main() {\n\tgo setup()\n\tfor !done {\n\t}\n\tprint(a)\n}\n</code></pre><p>在这段代码中，主goroutine main即使观察到done变成true了，最后读取到的a的值仍然可能为空。</p><p>更糟糕的情况是，main根本就观察不到另一个goroutine对done的写操作，这就会导致main程序一直被hang住。甚至可能还会出现<strong>半初始化</strong>的情况，比如：</p><pre><code>type T struct {\n\tmsg string\n}\n\nvar g *T\n\nfunc setup() {\n\tt := new(T)\n\tt.msg = &quot;hello, world&quot;\n\tg = t\n}\n\nfunc main() {\n\tgo setup()\n\tfor g == nil {\n\t}\n\tprint(g.msg)\n}\n</code></pre><p>即使main goroutine观察到g不为nil，也可能打印出空的msg（第17行）。</p><p>看到这里，你可能要说了，我都运行这个程序几百万次了，怎么也没有观察到这种现象？我可以这么告诉你，能不能观察到和提供保证（guarantee）是两码事儿。由于CPU架构和Go编译器的不同，即使你运行程序时没有遇到这些现象，也不代表Go可以100%保证不会出现这些问题。</p><p>刚刚说了，程序在运行的时候，两个操作的顺序可能不会得到保证，那该怎么办呢？接下来，我要带你了解一下Go内存模型中很重要的一个概念：happens-before，这是用来描述两个时间的顺序关系的。如果某些操作能提供happens-before关系，那么，我们就可以100%保证它们之间的顺序。</p><h1>happens-before</h1><p><span class=\"orange\">在一个goroutine内部，程序的执行顺序和它们的代码指定的顺序是一样的，即使编译器或者CPU重排了读写顺序，从行为上来看，也和代码指定的顺序一样</span>。</p><p>这是一个非常重要的保证，我们一定要记住。</p><p>我们来看一个例子。在下面的代码中，即使编译器或者CPU对a、b、c的初始化进行了重排，但是打印结果依然能保证是1、2、3，而不会出现1、0、0或1、0、1等情况。</p><pre><code>func foo() {\n    var a = 1\n    var b = 2\n    var c = 3\n\n    println(a)\n    println(b)\n    println(c)\n}\n</code></pre><p>但是，对于另一个goroutine来说，重排却会产生非常大的影响。<strong>因为Go只保证goroutine内部重排对读写的顺序没有影响</strong>，比如刚刚我们在讲“可见性”问题时提到的三个例子，那该怎么办呢？这就要用到happens-before关系了。</p><p>如果两个action（read 或者 write）有明确的happens-before关系，你就可以确定它们之间的执行顺序（或者是行为表现上的顺序）。</p><p>Go内存模型通过happens-before定义两个事件（读、写action）的顺序：如果事件e1  happens before 事件e2，那么，我们就可以说事件e2在事件e1之后发生（happens after）。如果e1 不是happens before e2， 同时也不happens after e2，那么，我们就可以说事件e1和e2是同时发生的。</p><p>如果要保证对“变量<strong>v</strong>的读操作<strong>r</strong>”能够观察到一个对“变量<strong>v</strong>的写操作<strong>w</strong>”，并且<strong>r</strong>只能观察到<strong>w</strong>对变量<strong>v</strong>的写，没有其它对v的写操作，也就是说，我们要保证<strong>r</strong>绝对能观察到<strong>w</strong>操作的结果，那么就需要同时满足两个条件：</p><ol>\n<li>w happens before r；</li>\n<li>其它对v的写操作（w2、w3、w4, ......） 要么happens before w，要么happens after r，绝对不会和w、r同时发生，或者是在它们之间发生。</li>\n</ol><p>你可能会说，这是很显然的事情啊，但我要和你说的是，这是一个非常严格、严谨的数学定义。</p><p>对于单个的goroutine来说，它有一个特殊的happens-before关系，Go内存模型中是这么讲的：</p><blockquote>\n<p>Within a single goroutine, the happens-before order is the order expressed by the program.</p>\n</blockquote><p>我来解释下这句话。它的意思是，在单个的goroutine内部， happens-before的关系和代码编写的顺序是一致的。</p><p>其实，在这一章的开头我已经用橙色把这句话标注出来了。我再具体解释下。</p><p>在goroutine内部对一个局部变量v的读，一定能观察到最近一次对这个局部变量v的写。如果要保证多个goroutine之间对一个共享变量的读写顺序，在Go语言中，可以使用并发原语为读写操作建立happens-before关系，这样就可以保证顺序了。</p><p>说到这儿，我想先给你补充三个Go语言中和内存模型有关的小知识，掌握了这些，你就能更好地理解下面的内容。</p><ol>\n<li>在Go语言中，对变量进行零值的初始化就是一个写操作。</li>\n<li>如果对超过机器word（64bit、32bit或者其它）大小的值进行读写，那么，就可以看作是对拆成word大小的几个读写无序进行。</li>\n<li>Go并不提供直接的CPU屏障（CPU fence）来提示编译器或者CPU保证顺序性，而是使用不同架构的内存屏障指令来实现统一的并发原语。</li>\n</ol><p>接下来，我就带你学习下Go语言中提供的happens-before关系保证。</p><h1>Go语言中保证的happens-before关系</h1><p>除了单个goroutine内部提供的happens-before保证，Go语言中还提供了一些其它的happens-before关系的保证，下面我来一个一个介绍下。</p><h2>init函数</h2><p>应用程序的初始化是在单一的goroutine执行的。如果包p导入了包q，那么，q的init函数的执行一定 happens before  p的任何初始化代码。</p><p>这里有一个特殊情况需要你记住：<strong>main函数一定在导入的包的init函数之后执行</strong>。</p><p>包级别的变量在同一个文件中是按照声明顺序逐个初始化的，除非初始化它的时候依赖其它的变量。同一个包下的多个文件，会按照文件名的排列顺序进行初始化。这个顺序被定义在<a href=\"https://golang.org/ref/spec#Program_initialization_and_execution\">Go语言规范</a>中，而不是Go的内存模型规范中。你可以看看下面的例子中各个变量的值：</p><pre><code>var (\n\ta = c + b  // == 9\n\tb = f()    // == 4\n\tc = f()    // == 5\n\td = 3      // == 5 全部初始化完成后\n)\n\nfunc f() int {\n\td++\n\treturn d\n}\n</code></pre><p>具体怎么对这些变量进行初始化呢？Go采用的是依赖分析技术。不过，依赖分析技术保证的顺序只是针对同一包下的变量，而且，只有引用关系是本包变量、函数和非接口的方法，才能保证它们的顺序性。</p><p>同一个包下可以有多个init函数，甚至一个文件中也可以包含多个相同签名的init函数。</p><p>刚刚讲的这些都是不同包的init函数执行顺序，下面我举一个具体的例子，把这些内容串起来，你一看就明白了。</p><p>这个例子是一个<strong>main</strong>程序，它依赖包p1，包p1依赖包p2，包p2依赖p3。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/2a/d5059fab1977602934339e18f9eddb2a.jpg?wh=3214*1645\" alt=\"\"></p><p>为了追踪初始化过程，并输出有意义的日志，我定义了一个辅助方法，打印出日志并返回一个用来初始化的整数值：</p><pre><code>func Trace(t string, v int) int {\n    fmt.Println(t, &quot;:&quot;, v)\n    return v\n}\n</code></pre><p>包<strong>p3</strong>包含两个文件，分别定义了一个init函数。第一个文件中定义了两个变量，这两个变量的值还会在init函数中进行修改。</p><p>我们来分别看下包p3的这两个文件：</p><pre><code>// lib1.go in p3\n\nvar V1_p3 = trace.Trace(&quot;init v1_p3&quot;, 3)\nvar V2_p3 = trace.Trace(&quot;init v2_p3&quot;, 3)\n\n\nfunc init() {\n    fmt.Println(&quot;init func in p3&quot;)\n    V1_p3 = 300\n    V2_p3 = 300\n}\n</code></pre><pre><code>// lib2.go in p3\n\nfunc init() {\n    fmt.Println(&quot;another init func in p3&quot;)\n}\n</code></pre><p>下面再来看看包p2。包p2定义了变量和init函数。第一个变量初始化为2，并在init函数中更改为200。第二个变量是复制的p3.V2_p3。</p><pre><code>var V1_p2 = trace.Trace(&quot;init v1_p2&quot;, 2)\nvar V2_p2 = trace.Trace(&quot;init v2_p2&quot;, p3.V2_p3)\n\nfunc init() {\n    fmt.Println(&quot;init func in p2&quot;)\n    V1_p2 = 200\n}\n</code></pre><p>包<strong>p1</strong>定义了变量和init函数。它的两个变量的值是复制的p2对应的两个变量值。</p><pre><code>var V1_p1 = trace.Trace(&quot;init v1_p1&quot;, p2.V1_p2)\nvar V2_p1 = trace.Trace(&quot;init v2_p1&quot;, p2.V2_p2)\n\nfunc init() {\n    fmt.Println(&quot;init func in p1&quot;)\n}\n</code></pre><p><strong>main</strong>定义了init函数和main函数。</p><pre><code>func init() {\n    fmt.Println(&quot;init func in main&quot;)\n}\n\n\nfunc main() {\n    fmt.Println(&quot;V1_p1:&quot;, p1.V1_p1)\n    fmt.Println(&quot;V2_p1:&quot;, p1.V2_p1)\n}\n</code></pre><p>运行main函数会依次输出p3、p2、p1、main的初始化变量时的日志（变量初始化时的日志和init函数调用时的日志）：</p><pre><code>// 包p3的变量初始化\ninit v1_p3 : 3\ninit v2_p3 : 3\n// p3的init函数\ninit func in p3\n// p3的另一个init函数 \nanother init func in p3\n\n// 包p2的变量初始化\ninit v1_p2 : 2\ninit v2_p2 : 300\n// 包p2的init函数\ninit func in p2\n\n// 包p1的变量初始化\ninit v1_p1 : 200\ninit v2_p1 : 300\n// 包p1的init函数\ninit func in p1\n\n// 包main的init函数\ninit func in main\n// main函数\nV1_p1: 200\nV2_p1: 300\n</code></pre><p>下面，我们再来看看goroutine对happens-before关系的保证情况。</p><h2>goroutine</h2><p>首先，我们需要明确一个规则：<strong>启动goroutine的go语句的执行，一定happens before此goroutine内的代码执行。</strong></p><p>根据这个规则，我们就可以知道，如果go语句传入的参数是一个函数执行的结果，那么，这个函数一定先于goroutine内部的代码被执行。</p><p>我们来看一个例子。在下面的代码中，第8行a的赋值和第9行的go语句是在同一个goroutine中执行的，所以，在主goroutine看来，第8行肯定happens before 第9行，又由于刚才的保证，第9行子goroutine的启动happens before 第4行的变量输出，那么，我们就可以推断出，第8行happens before 第4行。也就是说，在第4行打印a的值的时候，肯定会打印出“hello world”。</p><pre><code>var a string\n\nfunc f() {\n\tprint(a)\n}\n\nfunc hello() {\n\ta = &quot;hello, world&quot;\n\tgo f()\n}\n</code></pre><p>刚刚说的是启动goroutine的情况，goroutine退出的时候，是没有任何happens-before保证的。所以，如果你想观察某个goroutine的执行效果，你需要使用同步机制建立happens-before关系，比如Mutex或者Channel。接下来，我会讲Channel的happens-before的关系保证。</p><h2>Channel</h2><p>Channel是goroutine同步交流的主要方法。往一个Channel中发送一条数据，通常对应着另一个goroutine从这个Channel中接收一条数据。</p><p>通用的Channel happens-before关系保证有4条规则，我分别来介绍下。</p><p><strong>第1条规则是</strong>，往Channel中的发送操作，happens before 从该Channel接收相应数据的动作完成之前，即第n个send一定happens before第n个receive的完成。</p><pre><code>var ch = make(chan struct{}, 10) // buffered或者unbuffered\nvar s string\n\nfunc f() {\n\ts = &quot;hello, world&quot;\n\tch &lt;- struct{}{}\n}\n\nfunc main() {\n\tgo f()\n\t&lt;-ch\n\tprint(s)\n}\n</code></pre><p>在这个例子中，s的初始化（第5行）happens before 往ch中发送数据， 往ch发送数据 happens before从ch中读取出一条数据（第11行），第12行打印s的值 happens after第11行，所以，打印的结果肯定是初始化后的s的值“hello world”。</p><p><strong>第2条规则是</strong>，close一个Channel的调用，肯定happens before 从关闭的Channel中读取出一个零值。</p><p>还是拿刚刚的这个例子来说，如果你把第6行替换成 close(ch)，也能保证同样的执行顺序。因为第11行从关闭的ch中读取出零值后，第6行肯定被调用了。</p><p><strong>第3条规则是</strong>，对于unbuffered的Channel，也就是容量是0的Channel，从此Channel中读取数据的调用一定happens before 往此Channel发送数据的调用完成。</p><p>所以，在上面的这个例子中呢，如果想保持同样的执行顺序，也可以写成这样：</p><pre><code>var ch = make(chan int)\nvar s string\n\nfunc f() {\n\ts = &quot;hello, world&quot;\n\t&lt;-ch\n}\n\nfunc main() {\n\tgo f()\n\tch &lt;- struct{}{}\n\tprint(s)\n}\n</code></pre><p>如果第11行发送语句执行成功（完毕），那么根据这个规则，第6行（接收）的调用肯定发生了（执行完成不完成不重要，重要的是这一句“肯定执行了”），那么s也肯定初始化了，所以一定会打印出“hello world”。</p><p>这一条比较晦涩，但是，因为Channel是unbuffered的Channel，所以这个规则也成立。</p><p><strong>第4条规则是</strong>，如果Channel的容量是m（m&gt;0），那么，第n个receive一定happens before 第 n+m 个 send的完成。</p><p>前一条规则是针对unbuffered channel的，这里给出了更广泛的针对buffered channel的保证。利用这个规则，我们可以实现信号量（Semaphore）的并发原语。Channel的容量相当于可用的资源，发送一条数据相当于请求信号量，接收一条数据相当于释放信号。关于信号量这个并发原语，我会在下一讲专门给你介绍一下，这里你只需要知道它可以控制多个资源的并发访问，就可以了。</p><h2>Mutex/RWMutex</h2><p>对于互斥锁Mutex m或者读写锁RWMutex m，有3条happens-before关系的保证。</p><ol>\n<li>第n次的m.Unlock一定happens before第n+1 m.Lock方法的返回；</li>\n<li>对于读写锁RWMutex m，如果它的第n个m.Lock方法的调用已返回，那么它的第n个m.Unlock的方法调用一定happens before 任何一个m.RLock方法调用的返回，只要这些m.RLock方法调用 happens after 第n次m.Lock的调用的返回。这就可以保证，只有释放了持有的写锁，那些等待的读请求才能请求到读锁。</li>\n<li>对于读写锁RWMutex m，如果它的第n个m.RLock方法的调用已返回，那么它的第k （k&lt;=n）个成功的m.RUnlock方法的返回一定happens before 任意的m.RUnlockLock方法调用，只要这些m.Lock方法调用happens after第n次m.RLock。</li>\n</ol><p>读写锁的保证有点绕，我再带你看看官方的描述：</p><blockquote>\n<p>对于读写锁l的 l.RLock方法调用，如果存在一个<strong>n</strong>，这次的l.RLock调用 happens after 第n次的l.Unlock，那么，和这个RLock相对应的l.RUnlock一定happens before 第n+1次l.Lock。意思是，读写锁的Lock必须等待既有的读锁释放后才能获取到。</p>\n</blockquote><p>我再举个例子。在下面的代码中，第6行第一次的Unlock一定happens before第二次的Lock（第12行），所以这也能保证正确地打印出“hello world”。</p><pre><code>var mu sync.Mutex\nvar s string\n\nfunc foo() {\n\ts = &quot;hello, world&quot;\n\tmu.Unlock()\n}\n\nfunc main() {\n\tmu.Lock()\n\tgo foo()\n\tmu.Lock()\n\tprint(s)\n</code></pre><h2>WaitGroup</h2><p>接下来是WaitGroup的保证。</p><p>对于一个WaitGroup实例wg，在某个时刻t0时，它的计数值已经不是零了，假如t0时刻之后调用了一系列的wg.Add(n)或者wg.Done()，并且只有最后一次调用wg的计数值变为了0，那么，可以保证这些wg.Add或者wg.Done()一定 happens before t0时刻之后调用的wg.Wait方法的返回。</p><p>这个保证的通俗说法，就是<strong>Wait方法等到计数值归零之后才返回</strong>。</p><h2>Once</h2><p>我们在<a href=\"https://time.geekbang.org/column/article/301113\">第8讲</a>学过Once了，相信你已经很熟悉它的功能了。它提供的保证是：<strong>对于once.Do(f)调用，f函数的那个单次调用一定happens before 任何once.Do(f)调用的返回</strong>。换句话说，就是函数f一定会在Do方法返回之前执行。</p><p>还是以hello world的例子为例，这次我们使用Once并发原语实现，可以看下下面的代码：</p><pre><code>var s string\nvar once sync.Once\n\nfunc foo() {\n\ts = &quot;hello, world&quot;\n}\n\nfunc twoprint() {\n\tonce.Do(foo)\n\tprint(s)\n}\n</code></pre><p>第5行的执行一定happens before第9行的返回，所以执行到第10行的时候，sd已经初始化了，所以会正确地打印“hello world”。</p><p>最后，我再来说说atomic的保证。</p><h2>atomic</h2><p>其实，Go内存模型的官方文档并没有明确给出atomic的保证，有一个相关的issue <a href=\"https://github.com/golang/go/issues/5045\">go# 5045</a>记录了相关的讨论。光看issue号，就知道这个讨论由来已久了。Russ Cox想让atomic有一个弱保证，这样可以为以后留下充足的可扩展空间，所以，Go内存模型规范上并没有严格的定义。</p><p>对于Go 1.15的官方实现来说，可以保证使用atomic的Load/Store的变量之间的顺序性。</p><p>在下面的例子中，打印出的a的结果总是1，但是官方并没有做任何文档上的说明和保证。</p><p>依照Ian Lance Taylor的说法，Go核心开发组的成员几乎没有关注这个方向上的研究，因为这个问题太复杂，有很多问题需要去研究，所以，现阶段还是不要使用atomic来保证顺序性。</p><pre><code>func main() {\n\tvar a, b int32 = 0, 0\n\n\tgo func() {\n\t\tatomic.StoreInt32(&amp;a, 1)\n\t\tatomic.StoreInt32(&amp;b, 1)\n\t}()\n\n\tfor atomic.LoadInt32(&amp;b) == 0{\n\t\truntime.Gosched()\n\t}\n    fmt.Println(atomic.LoadInt32(&amp;a))\n}\n</code></pre><h1>总结</h1><p>Go的内存模型规范中，一开始有这么一段话：</p><blockquote>\n<p>If you must read the rest of this document to understand the behavior of your program, you are being too clever.</p>\n</blockquote><blockquote>\n<p>Don't be clever.</p>\n</blockquote><p>我来说说我对这句话的理解：你通过学习这节课来理解你的程序的行为是聪明的，但是，不要自作聪明。</p><p>谨慎地使用这些保证，能够让你的程序按照设想的happens-before关系执行，但是不要以为完全理解这些概念和保证，就可以随意地制造所谓的各种技巧，否则就很容易掉进“坑”里，而且会给代码埋下了很多的“定时炸弹”。</p><p>比如，Go里面已经有值得信赖的互斥锁了，如果没有额外的需求，就不要使用Channel创造出自己的互斥锁。</p><p>当然，我也不希望你畏手畏脚地把思想局限住，我还是建议你去做一些有意义的尝试，比如使用Channel实现信号量等扩展并发原语。</p><p><img src=\"https://static001.geekbang.org/resource/image/dc/4d/dc68fc5f93a4af96c8f4d45d6282104d.jpg?wh=2250*2046\" alt=\"\"></p><h1>思考题</h1><p>我们知道，Channel可以实现互斥锁，那么，我想请你思考一下，它是如何利用happens-before关系保证锁的请求和释放的呢？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","neighbors":{"left":{"article_title":"14 | Channel：透过代码看典型的应用模式","id":306614},"right":{"article_title":"16 | Semaphore：一篇文章搞懂信号量","id":308399}},"comments":[{"had_liked":false,"id":262876,"user_name":"坚白同异","can_delete":false,"product_type":"c1","uid":1375143,"ip_address":"","ucode":"4030C4B64068A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajZWFgjupJHhmSN3jJ5o9ibecnOQQmJBTxvjwm5ssJjmG1iaNic8XNR6DvZNwIJdjpjkBibicnJYyZUIAnOkw2wwv8w/132","comment_is_top":false,"comment_ctime":1605865812,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"126159917396","product_id":100061801,"comment_content":"If you must read the rest of this document to understand the behavior of your program, you are being too clever.Don’t be clever. 看完文档之后,年轻人不要再犯这样的聪明,小聪明,程序以和为贵,不要窝里斗,耗子尾汁.","like_count":29,"discussions":[{"author":{"id":1015986,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/b2/2e9f442d.jpg","nickname":"文武木子","note":"","ucode":"348752BDECD65F","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556204,"discussion_content":"差点笑出声。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647245476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/93/ec/985675c8.jpg","nickname":"小高","note":"","ucode":"FCD422249F7355","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383989,"discussion_content":"优秀，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626329866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2111673,"avatar":"https://static001.geekbang.org/account/avatar/00/20/38/b9/b496ff4d.jpg","nickname":"努力努力再努力","note":"","ucode":"8BBA96AE486FE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376973,"discussion_content":"真是个人才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622444948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445504,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/gVfU7icdia3o5ZNaHjaWAdgkSYIpU1rdhIlVYiahYCvRlDZu2K6oPSvVobNjzwZbUaiayQcKjicZ44WjfWJCj5xdlPA/132","nickname":"红尘","note":"","ucode":"CCCD5736755DF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351412,"discussion_content":"一句话概括 优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614261061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337329,"discussion_content":"这个翻译更地道。😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608876095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328608,"user_name":"NULL","can_delete":false,"product_type":"c1","uid":1191550,"ip_address":"","ucode":"2A323DD05352BC","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/7e/ebc28e10.jpg","comment_is_top":false,"comment_ctime":1640788509,"is_pvip":false,"replies":[{"id":"119776","content":"👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1640867522,"ip_address":"","comment_id":328608,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31705559581","product_id":100061801,"comment_content":"补充个go语言圣经8.4.1节的内容：在讨论并发编程时，当我们说x事件在y事件之前发生（happens before），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。<br><br>当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。","like_count":8,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542866,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640867522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1090142,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a2/5e/3871ff79.jpg","nickname":"迷途书童","note":"","ucode":"462BE64D3373DA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583905,"discussion_content":"只问一个问题，如果 x happens before y， x发生的时间点是在y发生的时间点之前还是之后？我相信这个问题只会有一个答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660483138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261325,"user_name":"myrfy","can_delete":false,"product_type":"c1","uid":1169401,"ip_address":"","ucode":"2814BAE5D70098","user_header":"","comment_is_top":false,"comment_ctime":1605272027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23080108507","product_id":100061801,"comment_content":"思考题，以从ch中拿到token为获取到锁，A获取到token后执行被保护的内容，此时B尝试读取ch并阻塞，由于ch的第一条，A放回token的操作 happen before B完成获取token的操作，所以当B获取到token时，可以保证A的代码执行已经离开了临界区。<br><br>第一次遇到内存模型是在阅读rocksdb的源代码时，了解到了c++的内存模型，后来查阅过一些列资料，每次看都有新的体会，这个知识点想理解透真的不容易，不过感觉go对内存模型的抽象比C++简单了好多","like_count":5},{"had_liked":false,"id":261175,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1605234570,"is_pvip":false,"replies":[{"id":"94800","content":"1.有happen before关系<br>2.没有规定，虽然实际是这样的。你肯定也不会也不应该利用这个顺序做点事情","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605247778,"ip_address":"","comment_id":261175,"utype":1}],"discussion_count":1,"race_medal":1,"score":"18785103754","product_id":100061801,"comment_content":"请问老师，文中例子中包P3中lib1先于lib2执行初始化，这个顺序是否是否有happen before呢？同一个package内文件初始化顺序是按照文件名字母序来执行的么？","like_count":4,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509406,"discussion_content":"1.有happen before关系\n2.没有规定，虽然实际是这样的。你肯定也不会也不应该利用这个顺序做点事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605247778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318689,"user_name":"Jamey","can_delete":false,"product_type":"c1","uid":2344373,"ip_address":"","ucode":"449E4F65339CDE","user_header":"https://static001.geekbang.org/account/avatar/00/23/c5/b5/25179772.jpg","comment_is_top":false,"comment_ctime":1635392727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5930360023","product_id":100061801,"comment_content":"看了这篇文章对指令重排、变量可见性、golang内存模型 有了更深的认识","like_count":1},{"had_liked":false,"id":293975,"user_name":"科科","can_delete":false,"product_type":"c1","uid":1647304,"ip_address":"","ucode":"7DAE6FE781172E","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","comment_is_top":false,"comment_ctime":1621666145,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5916633441","product_id":100061801,"comment_content":"果然没有什么东西是理所应当，复杂的硬件运行环境，对于程序员来说应该是透明的。为了达到这一目的，每个语言都要设计出相应的内存模型。其实很好理解，所谓的happens before，就是要根据逻辑和编程顺序来去决定两次操作的一个先后顺序。按照正常逻辑，如果解锁的函数正返回，那就表明这个锁之前肯定是被加上的。所以，lock  Happens before  unlock.","like_count":1},{"had_liked":false,"id":263082,"user_name":"蜉蝣","can_delete":false,"product_type":"c1","uid":1229070,"ip_address":"","ucode":"77CF92496855D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","comment_is_top":false,"comment_ctime":1605973966,"is_pvip":false,"replies":[{"id":"95494","content":"g1看到的顺序和编写顺序效果上看是一致的，但是考虑的多核和乱序执行，真正运行不一定和编写顺序一样","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1606022541,"ip_address":"","comment_id":263082,"utype":1}],"discussion_count":6,"race_medal":0,"score":"5900941262","product_id":100061801,"comment_content":"老师好，我有些不明白，既然“在一个 goroutine 内部，程序的执行顺序和它们的代码指定的顺序是一样的”，那为什么还会有 “程序运行的时候，不能保证 g2 看到的 a 和 b 的赋值有先后关系”？假设 g2 看到了 b=2，说明 “b=2” 一定执行过了，而单个 goroutine 内部顺序是有保证，所以 a=1 也一定执行过了。基于这样的思考，后面所有示例我基本都理解不了……","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510089,"discussion_content":"g1看到的顺序和编写顺序效果上看是一致的，但是考虑的多核和乱序执行，真正运行不一定和编写顺序一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606022541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2035702,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0f/f6/609ded9f.jpg","nickname":"tingting","note":"","ucode":"61E6B0C4EC59C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585283,"discussion_content":"我也卡在了这个地方。 为什么后面的例子里面， 比如这个例子：\n在这个例子中，s 的初始化（第 5 行）happens before 往 ch 中发送数据， 往 ch 发送数据 happens before 从 ch 中读取出一条数据（第 11 行），第 12 行打印 s 的值 happens after 第 11 行，所以，打印的结果肯定是初始化后的 s 的值“hello world”。\ng2就可以看到“s 的初始化（第 5 行）happens before 往 ch 中发送数据”呢？ \n\n非常的困惑，欢迎留言👏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661439746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"新加坡"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380770,"discussion_content":"g1就算执行过，g2也可能看不到啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624693061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2147220,"avatar":"https://static001.geekbang.org/account/avatar/00/20/c3/94/e89ebc50.jpg","nickname":"神毓逍遥","note":"","ucode":"83351CB18B190E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370514,"discussion_content":"我也觉得应该更加深入的回答下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619440065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370424,"discussion_content":"感觉老师没有正面回答同学的问题。难道go提供的顺序保证，在一个协程看来已经是顺序保证，但在另外一个协程看来可能是没有保证的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619406821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1167430,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d0/46/7f9af8de.jpg","nickname":"寻","note":"","ucode":"473B2CC14158A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572460,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652794089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":370424,"ip_address":""},"score":572460,"extra":""}]}]},{"had_liked":false,"id":262256,"user_name":"大漠胡萝卜","can_delete":false,"product_type":"c1","uid":1198953,"ip_address":"","ucode":"FBE51E4A13EF4F","user_header":"https://static001.geekbang.org/account/avatar/00/12/4b/69/c02eac91.jpg","comment_is_top":false,"comment_ctime":1605677341,"is_pvip":false,"replies":[{"id":"95154","content":"第二个lock方法的返回，不是第二个lock方法的调用","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605691237,"ip_address":"","comment_id":262256,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5900644637","product_id":100061801,"comment_content":"没看明白：“第 n 次的 m.Unlock 一定 happens before 第 n+1 m.Lock 方法的返回；”<br>下面的代码第二次加锁可能先于第一次解锁<br>```go<br><br>var mu sync.Mutex<br>var s string<br><br>func foo() {<br>  s = &quot;hello, world&quot;<br>  mu.Unlock()<br>}<br><br>func main() {<br>  mu.Lock()<br>  go foo()<br>  mu.Lock()<br>  print(s)<br>```","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509753,"discussion_content":"第二个lock方法的返回，不是第二个lock方法的调用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605691237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1056807,"avatar":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","nickname":"虢國技醬","note":"","ucode":"5A192262AA037E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345998,"discussion_content":"第n+1 m.Lock阻塞了，必须等第n次对应的m.Unlock后，才能重新上锁，所以 第 n 次的 m.Unlock 一定 happens before 第 n+1 m.Lock 方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611834764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355510,"user_name":"tingting","can_delete":false,"product_type":"c1","uid":2035702,"ip_address":"北京","ucode":"61E6B0C4EC59C5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0f/f6/609ded9f.jpg","comment_is_top":false,"comment_ctime":1661439329,"is_pvip":false,"replies":[{"id":"129585","content":"这是chan保证的，第一个例子没有谁可以保证","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1661945574,"ip_address":"北京","comment_id":355510,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1661439329","product_id":100061801,"comment_content":"在这个例子中，s 的初始化（第 5 行）happens before 往 ch 中发送数据， 往 ch 发送数据 happens before 从 ch 中读取出一条数据（第 11 行），第 12 行打印 s 的值 happens after 第 11 行，所以，打印的结果肯定是初始化后的 s 的值“hello world”。<br><br>为什么另外一个goroutine 这里可以感知到“s 的初始化（第 5 行）happens before 往 ch 中发送数据”?  跟第一个例子类似，这里不是有可能指令重排吗？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586043,"discussion_content":"这是chan保证的，第一个例子没有谁可以保证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661945574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355509,"user_name":"tingting","can_delete":false,"product_type":"c1","uid":2035702,"ip_address":"北京","ucode":"61E6B0C4EC59C5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0f/f6/609ded9f.jpg","comment_is_top":false,"comment_ctime":1661438989,"is_pvip":false,"replies":[{"id":"129584","content":"a=1 happens before b=2这个是推断不出来的。从另一个goroutine看不一定","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1661945489,"ip_address":"北京","comment_id":355509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1661438989","product_id":100061801,"comment_content":"第一个例子：“可以看到，第 9 行是要打印 b 的值。需要注意的是，即使这里打印出的值是 2，但是依然可能在打印 a 的值时，打印出初始值 0，而不是 1。”<br><br>如果打印出来的是2，那是不是说明对于该次执行，b=2 happens before print(b), a=1 happens before b=2,所以打印出来的应该一定是1。 <br><br>","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586042,"discussion_content":"a=1 happens before b=2这个是推断不出来的。从另一个goroutine看不一定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661945489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353204,"user_name":"Geek_a6104e","can_delete":false,"product_type":"c1","uid":1711967,"ip_address":"北京","ucode":"29A56792216DC8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/GJXKh8OG00U5ial64plAIibbIuwkzhPc8uYic9Hibl8SbqvhnS2JImHgCD4JGvTktiaVnCjHQWbA5wicaxRUN5aTEWnQ/132","comment_is_top":false,"comment_ctime":1659258852,"is_pvip":false,"replies":[{"id":"129155","content":"谢谢，马上更新","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1661008522,"ip_address":"北京","comment_id":353204,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1659258852","product_id":100061801,"comment_content":"所以执行到第 10 行的时候，sd 已经     打错字了 应该是s而不是sd","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584659,"discussion_content":"谢谢，马上更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661008522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352918,"user_name":"a","can_delete":false,"product_type":"c1","uid":1417722,"ip_address":"陕西","ucode":"CE9F7FFFE17B38","user_header":"https://static001.geekbang.org/account/avatar/00/15/a1/fa/245bf91e.jpg","comment_is_top":false,"comment_ctime":1659009172,"is_pvip":false,"replies":[{"id":"128368","content":"这是有很大的可能的，文章中说还有别的可能","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1659095988,"ip_address":"陕西","comment_id":352918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1659009172","product_id":100061801,"comment_content":"第一个例子打印一直是0","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581977,"discussion_content":"这是有很大的可能的，文章中说还有别的可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659095988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342608,"user_name":"666","can_delete":false,"product_type":"c1","uid":1062836,"ip_address":"","ucode":"31E15B351A58A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/b4/df897320.jpg","comment_is_top":false,"comment_ctime":1650362742,"is_pvip":false,"replies":[{"id":"126639","content":"因为这本数并没有对&quot;additional invariants&quot;有详细解释，所以这里我也无法理解作者的真正的意义。<br><br>但是stackoverflow 上有一个问答，或许对你有所帮助<br>https:&#47;&#47;stackoverflow.com&#47;questions&#47;66195093&#47;could-someone-explain-the-term-invariants-in-mutex-locking","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1653899558,"ip_address":"","comment_id":342608,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1650362742","product_id":100061801,"comment_content":"GOPl 那本蓝皮书，第九章讲共享变量，9.2 节（英文版 265 页）有下面这段话：<br><br>There is a good reason Go&#39;s mutexes are not re-entrant. The purpose of a mutex is to ensure that certain invariants of the shared variables are maintained at critical points during program execution. One of the invariants is &quot;no goroutine is accessing the shared variables&quot;, but there may be additional invariants specific to the data structures that the mutex guards. When a goroutine acquires a mutex lock, it may assume that the invirants hold. While it holds the lock, it may update the shared variables so that the invariants are temporarily violated. However, when it releases the lock, it must guarantee that the order has been restored and the invariants hold once again. Although a re-entrant mutex would ensure that no other goroutines are accessing the shared variables, it cannot protect the additional invariants of those variables.<br><br>怎么理解这里的 invirants 呢？谢谢老师","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574205,"discussion_content":"因为这本数并没有对&#34;additional invariants&#34;有详细解释，所以这里我也无法理解作者的真正的意义。\n\n但是stackoverflow 上有一个问答，或许对你有所帮助\nhttps://stackoverflow.com/questions/66195093/could-someone-explain-the-term-invariants-in-mutex-locking","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653899558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/37/b4/df897320.jpg","nickname":"666","note":"","ucode":"31E15B351A58A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565007,"discussion_content":"笔误，应该是 invariants，怎么理解这里的 invariants 呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650370997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304764,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1627607153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627607153","product_id":100061801,"comment_content":"Channel的第一条和第四条保证的有缓存的channel作为锁的保证，第一条和第二条保证的无缓存的channel作为锁的保证","like_count":0},{"had_liked":false,"id":290152,"user_name":"小袁","can_delete":false,"product_type":"c1","uid":1811495,"ip_address":"","ucode":"3F5D8721F577D9","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","comment_is_top":false,"comment_ctime":1619405246,"is_pvip":false,"replies":[{"id":"105189","content":"对于调用hello方法的goroutine来说，它看到的结果只能是hello world,不会看到空值","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1619414229,"ip_address":"","comment_id":290152,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1619405246","product_id":100061801,"comment_content":"请问作者，在你的gorotinue的例子中<br>var a string<br>func f() { print(a)}<br>func hello() { a = &quot;hello, world&quot; go f()}<br><br>你说对变量a的复制一定在go语句之前，这是为啥？将对变量a的复制放在go语句之后也是不影响读写的重排？是我理解错了什么？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519126,"discussion_content":"对于调用hello方法的goroutine来说，它看到的结果只能是hello world,不会看到空值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619414229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380767,"discussion_content":"不是这样的，文章里说了为什么。也可以自己测试下https://play.golang.org/p/_VeSlJaIcG3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624692319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1869163,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/85/6b/d77946a5.jpg","nickname":"柯可","note":"","ucode":"3D198F1A90C19A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371667,"discussion_content":"这个地方我也没弄懂，老师可以再讲浅显易懂点吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619890202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277060,"user_name":"K菌无惨","can_delete":false,"product_type":"c1","uid":2194764,"ip_address":"","ucode":"97A532D588FD49","user_header":"","comment_is_top":false,"comment_ctime":1612250011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612250011","product_id":100061801,"comment_content":"type Locker struct {<br>\tch chan struct{}<br>}<br><br>func NewLocker() Locker {<br>\treturn Locker{make(chan struct{}, 1)}<br>}<br><br>func (l *Locker) Lock() {<br>\tl.ch &lt;- struct{}{}<br>}<br><br>func (l *Locker) Unlock() {<br>\t&lt;- l.ch<br>}<br>","like_count":0},{"had_liked":false,"id":277058,"user_name":"K菌无惨","can_delete":false,"product_type":"c1","uid":2194764,"ip_address":"","ucode":"97A532D588FD49","user_header":"","comment_is_top":false,"comment_ctime":1612248366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612248366","product_id":100061801,"comment_content":"怪不得go的并发原语的源码里面有这么多对锁的双重检查,原来是有happens-before的保证","like_count":0},{"had_liked":false,"id":276679,"user_name":"( ･᷄ὢ･᷅ )","can_delete":false,"product_type":"c1","uid":2234129,"ip_address":"","ucode":"E5F5EDEBB74C46","user_header":"https://static001.geekbang.org/account/avatar/00/22/17/11/a63acc6a.jpg","comment_is_top":false,"comment_ctime":1612075739,"is_pvip":false,"replies":[{"id":"100403","content":"无缓冲不行。要buffer=1","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1612090566,"ip_address":"","comment_id":276679,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1612075739","product_id":100061801,"comment_content":"我们知道，Channel 可以实现互斥锁，那么，我想请你思考一下，它是如何利用 happens-before 关系保证锁的请求和释放的呢？<br>答：无缓冲通道做令牌方式，拿到令牌即为Lock，归还令牌即为Unlock，此时和互斥锁的Lock和Unlock的差不多了","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514790,"discussion_content":"无缓冲不行。要buffer=1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612090566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1647304,"avatar":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","nickname":"科科","note":"","ucode":"7DAE6FE781172E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375449,"discussion_content":"如果没有缓存区，调用lock的时候就会被阻塞，要设置缓存区为1，然后在初始化的时候先往里面写一条。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621665856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276218,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1611835579,"is_pvip":false,"replies":[{"id":"100289","content":"对的👍🏻","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1611875936,"ip_address":"","comment_id":276218,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1611835579","product_id":100061801,"comment_content":"继续自我咀嚼：<br>2、“第 n 次的 m.Unlock 一定 happens before 第 n+1 m.Lock 方法的返回；” 响应第 n+1 m.Lock成功，必需保证 m已经解锁或未上锁，不然第 n+1 m.Lock会阻塞等待；所以，第 n 次的 m.Unlock 一定发生在第 n+1 m.Lock之前","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514632,"discussion_content":"对的👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611875936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265430,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1606896000,"is_pvip":false,"replies":[{"id":"96496","content":"由于cpu cache的问题，不承诺main能看到","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1606907485,"ip_address":"","comment_id":265430,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1606896000","product_id":100061801,"comment_content":"请问老师，在“半初始化&quot;的例子中，为什么会”main 根本就观察不到另一个 goroutine 对 done 的写操作“？done是公共变量，main为什么会观察不到对它的改动？如果for循环中加一小段睡眠时间呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510926,"discussion_content":"由于cpu cache的问题，不承诺main能看到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606907485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118228,"avatar":"https://static001.geekbang.org/account/avatar/00/11/10/14/abb7bfe3.jpg","nickname":"建国之后不许成精","note":"","ucode":"8024473644FF41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379256,"discussion_content":"这里说的应该是多核cpu的情况下。如果是单核，main一定能观察到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623775341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2554951,"avatar":"https://static001.geekbang.org/account/avatar/00/26/fc/47/5fb0d905.jpg","nickname":"张健华","note":"","ucode":"577452129C885A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1118228,"avatar":"https://static001.geekbang.org/account/avatar/00/11/10/14/abb7bfe3.jpg","nickname":"建国之后不许成精","note":"","ucode":"8024473644FF41","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394018,"discussion_content":"意思是说，运行在多个cpu的不同go routine，其自身对内存变量的更改，由于cpu 缓存的存在，是更改在本cpu的缓存中，更改后不能立即被运行在其他cpu上的go routine感知到？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631690539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379256,"ip_address":""},"score":394018,"extra":""}]},{"author":{"id":1099379,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","nickname":"疯琴","note":"","ucode":"82ACAA4A27753D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331592,"discussion_content":"谢谢老师，我搜索semi initiate / half initiate没找到这方面的内容，老师有相关的文章推荐么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606909151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265300,"user_name":"benying","can_delete":false,"product_type":"c1","uid":1247522,"ip_address":"","ucode":"DEBAB485F381CC","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/22/22c0c4fa.jpg","comment_is_top":false,"comment_ctime":1606841394,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606841394","product_id":100061801,"comment_content":"之前确实一直疑惑为啥内存模型讲的不是内存分配的东西。。。谢谢大佬解惑","like_count":0},{"had_liked":false,"id":264795,"user_name":"Kepler","can_delete":false,"product_type":"c1","uid":1214303,"ip_address":"","ucode":"0C9CA3DB8B3CF0","user_header":"https://static001.geekbang.org/account/avatar/00/12/87/5f/6bf8b74a.jpg","comment_is_top":false,"comment_ctime":1606652191,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606652191","product_id":100061801,"comment_content":"思考题，使用一个容量为1的buffer channel实现mutex ，利用第n次recv(离坑释放锁)happen before 第n+1次send(占坑上锁)","like_count":0},{"had_liked":false,"id":262783,"user_name":"网管","can_delete":false,"product_type":"c1","uid":1176852,"ip_address":"","ucode":"608175DF616365","user_header":"https://static001.geekbang.org/account/avatar/00/11/f5/14/92b373dd.jpg","comment_is_top":false,"comment_ctime":1605841569,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1605841569","product_id":100061801,"comment_content":"不知道以前的版本是不是，但是在go 1.13里同一个go文件里是可以写多个init函数的。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327476,"discussion_content":"是的，同一个文件中也可以有多个相同签名init函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605847483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262428,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1605716599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605716599","product_id":100061801,"comment_content":"channael，第一条指的是发送这个动作一定在接收这个动作之前，而第三四条指的是接收代码的执行一定在发送这个代码执行的前边，总结下来就是 先执行接收代码，在执行发送代码，先有发送动作再有接收动作。","like_count":0},{"had_liked":false,"id":262226,"user_name":"GoGoGo","can_delete":false,"product_type":"c1","uid":2316381,"ip_address":"","ucode":"D2E10FB7A4008F","user_header":"https://static001.geekbang.org/account/avatar/00/23/58/5d/97f3a6a8.jpg","comment_is_top":false,"comment_ctime":1605668312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605668312","product_id":100061801,"comment_content":"还是比较好理解的","like_count":0},{"had_liked":false,"id":261778,"user_name":"pdf","can_delete":false,"product_type":"c1","uid":1649662,"ip_address":"","ucode":"A44250955878BB","user_header":"https://static001.geekbang.org/account/avatar/00/19/2b/fe/7925eb7e.jpg","comment_is_top":false,"comment_ctime":1605520353,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1605520353","product_id":100061801,"comment_content":"晦涩难懂了~<br>这一章有点难~","like_count":0,"discussions":[{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326351,"discussion_content":"确实有点“玄学”了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605582721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261121,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1605222992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605222992","product_id":100061801,"comment_content":"打卡。","like_count":0}]}