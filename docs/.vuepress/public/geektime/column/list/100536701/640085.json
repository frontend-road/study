{"id":640085,"title":"03｜依赖注入：如何给Bean注入值并解决循环依赖问题？","content":"<p>你好，我是郭屹，今天我们继续手写MiniSpring，探讨Bean的依赖注入。</p><p>上节课，我们定义了在XML配置文件中使用setter注入和构造器注入的配置方式，但同时也留下了一个悬念：这些配置是如何生效的呢？</p><h2>值的注入</h2><p>要理清这个问题，我们要先来看看<strong>Spring是如何解析 <code>&lt;property&gt;</code> 和 <code>&lt;constructor-arg&gt;</code> 标签。</strong></p><p>我们以下面的XML配置为基准进行学习。</p><pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;beans&gt;\n    &lt;bean id=\"aservice\" class=\"com.minis.test.AServiceImpl\"&gt;\n        &lt;constructor-arg type=\"String\" name=\"name\" value=\"abc\"/&gt;\n        &lt;constructor-arg type=\"int\" name=\"level\" value=\"3\"/&gt;\n        &lt;property type=\"String\" name=\"property1\" value=\"Someone says\"/&gt;\n        &lt;property type=\"String\" name=\"property2\" value=\"Hello World!\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre><!-- [[[read_end]]] --><p>和上面的配置属性对应，在测试类AServiceImpl中，要有相应的name、level、property1、property2字段来建立映射关系，这些实现体现在构造函数以及settter、getter等方法中。</p><pre><code class=\"language-java\">public class AServiceImpl implements AService {\n    private String name;\n    private int level;\n    private String property1;\n    private String property2;\n    \n    public AServiceImpl() {\n    }\n    public AServiceImpl(String name, int level) {\n        this.name = name;\n        this.level = level;\n        System.out.println(this.name + \",\" + this.level);\n    }\n    public void sayHello() {\n        System.out.println(this.property1 + \",\" + this.property2);\n    } \n    // 在此省略property1和property2的setter、getter方法   \n}\n</code></pre><p>接着，简化ArgumentValues类，移除暂时未用到的方法。</p><pre><code class=\"language-java\">public class ArgumentValues {\n&nbsp; &nbsp; private final List&lt;ArgumentValue&gt; argumentValueList = new ArrayList&lt;&gt;();\n&nbsp; &nbsp; public ArgumentValues() {\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void addArgumentValue(ArgumentValue argumentValue) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.argumentValueList.add(argumentValue);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public ArgumentValue getIndexedArgumentValue(int index) {\n&nbsp; &nbsp; &nbsp; &nbsp; ArgumentValue argumentValue = this.argumentValueList.get(index);\n&nbsp; &nbsp; &nbsp; &nbsp; return argumentValue;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public int getArgumentCount() {\n&nbsp; &nbsp; &nbsp; &nbsp; return (this.argumentValueList.size());\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public boolean isEmpty() {\n&nbsp; &nbsp; &nbsp; &nbsp; return (this.argumentValueList.isEmpty());\n&nbsp; &nbsp; }\n}\n</code></pre><p>做完准备工作之后，我们重点来看核心工作：解析 <code>&lt;property&gt;</code> 和 <code>&lt;constructor-arg&gt;</code> 两个标签。我们要在XmlBeanDefinitionReader类中处理这两个标签。</p><pre><code class=\"language-java\">&nbsp;public void loadBeanDefinitions(Resource resource) {\n&nbsp; &nbsp; &nbsp; &nbsp; while (resource.hasNext()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Element element = (Element) resource.next();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String beanID = element.attributeValue(\"id\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String beanClassName = element.attributeValue(\"class\");\n            BeanDefinition beanDefinition = new BeanDefinition(beanID,&nbsp;\nbeanClassName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //处理属性\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&lt;Element&gt; propertyElements = element.elements(\"property\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PropertyValues PVS = new PropertyValues();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Element e : propertyElements) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String pType = e.attributeValue(\"type\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String pName = e.attributeValue(\"name\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String pValue = e.attributeValue(\"value\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVS.addPropertyValue(new PropertyValue(pType, pName, pValue));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beanDefinition.setPropertyValues(PVS);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //处理构造器参数\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&lt;Element&gt; constructorElements = element.elements(\"constructor-\narg\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArgumentValues AVS = new ArgumentValues();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Element e : constructorElements) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String aType = e.attributeValue(\"type\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String aName = e.attributeValue(\"name\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String aValue = e.attributeValue(\"value\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AVS.addArgumentValue(new ArgumentValue(aType, aName, aValue));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beanDefinition.setConstructorArgumentValues(AVS);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.simpleBeanFactory.registerBeanDefinition(beanID,&nbsp;\nbeanDefinition);\n        }\n    }\n}\n</code></pre><p>从上述代码可以看出，程序在加载Bean的定义时要获取 <code>&lt;property&gt;</code> 和 <code>&lt;constructor-arg&gt;</code>，只要循环处理它们对应标签的属性：type、name、value即可。随后，我们通过addPropertyValue和addArgumentValue两个方法就能将注入的配置读取进内存。</p><p>那么，将这些配置的值读取进内存之后，我们怎么把它作为Bean的属性注入进去呢？这要求我们在创建Bean的时候就要做相应的处理，给属性赋值。针对XML配置的Value值，我们要按照数据类型分别将它们解析为字符串、整型、浮点型等基本类型。在SimpleBeanFactory类中，调整核心的createBean方法，我们修改一下。</p><pre><code class=\"language-java\">&nbsp; &nbsp; private Object createBean(BeanDefinition beanDefinition) {\n&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; clz = null;\n&nbsp; &nbsp; &nbsp; &nbsp; Object obj = null;\n&nbsp; &nbsp; &nbsp; &nbsp; Constructor&lt;?&gt; con = null;\n&nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clz = Class.forName(beanDefinition.getClassName());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 处理构造器参数\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArgumentValues argumentValues =&nbsp;\nbeanDefinition.getConstructorArgumentValues();\n            //如果有参数\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!argumentValues.isEmpty()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt;[] paramTypes = new Class&lt;?&gt;\n[argumentValues.getArgumentCount()];\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object[] paramValues = new&nbsp;\nObject[argumentValues.getArgumentCount()];\n                //对每一个参数，分数据类型分别处理\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; argumentValues.getArgumentCount(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArgumentValue argumentValue =&nbsp;\nargumentValues.getIndexedArgumentValue(i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (\"String\".equals(argumentValue.getType()) ||&nbsp;\n\"java.lang.String\".equals(argumentValue.getType())) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = String.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[i] = argumentValue.getValue();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (\"Integer\".equals(argumentValue.getType()) ||&nbsp;\n\"java.lang.Integer\".equals(argumentValue.getType())) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = Integer.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[i] =&nbsp;\nInteger.valueOf((String)argumentValue.getValue());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (\"int\".equals(argumentValue.getType())) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = int.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[i] = Integer.valueOf((String)&nbsp;\nargumentValue.getValue());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else { //默认为string\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = String.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[i] = argumentValue.getValue();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n                    //按照特定构造器创建实例\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; con = clz.getConstructor(paramTypes);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj = con.newInstance(paramValues);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else { //如果没有参数，直接创建实例\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj = clz.newInstance();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (Exception e) {\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; // 处理属性\n&nbsp; &nbsp; &nbsp; &nbsp; PropertyValues propertyValues = beanDefinition.getPropertyValues();\n&nbsp; &nbsp; &nbsp; &nbsp; if (!propertyValues.isEmpty()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; propertyValues.size(); i++) {\n                //对每一个属性，分数据类型分别处理\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PropertyValue propertyValue =&nbsp;\npropertyValues.getPropertyValueList().get(i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String pType = propertyValue.getType();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String pName = propertyValue.getName();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object pValue = propertyValue.getValue();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt;[] paramTypes = new Class&lt;?&gt;[1];\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (\"String\".equals(pType) || \"java.lang.String\".equals(pType))&nbsp;\n{\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[0] = String.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (\"Integer\".equals(pType) ||&nbsp;\n\"java.lang.Integer\".equals(pType)) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[0] = Integer.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (\"int\".equals(pType)) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[0] = int.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else { // 默认为string\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[0] = String.class;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object[] paramValues = new Object[1];\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramValues[0] = pValue;\n\n                //按照setXxxx规范查找setter方法，调用setter方法设置属性\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String methodName = \"set\" + pName.substring(0, 1).toUpperCase()&nbsp;\n+ pName.substring(1);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Method method = null;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method = clz.getMethod(methodName, paramTypes);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method.invoke(obj, paramValues);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return obj;\n&nbsp; &nbsp; }\n}\n</code></pre><p>我们这里的代码主要可以分成两个部分：一部分是处理constructor的里面的参数，另外一部分是处理各个property的属性。现在程序的代码是写在一起的，后面我们还会抽出单独的方法。</p><h3>如何处理constructor？</h3><p>首先，获取XML配置中的属性值，这个时候它们都是通用的Object类型，我们需要根据type字段的定义判断不同Value所属的类型，作为一个原始的实现这里我们只提供了String、Integer 和 int三种类型的判断。最终通过反射构造对象，将配置的属性值注入到了Bean对象中，实现构造器注入。</p><h3>如何处理property？</h3><p>和处理constructor相同，我们依然要通过type字段确定Value的归属类型。但不同之处在于，判断好归属类型后，我们还要手动构造setter方法，通过反射将属性值注入到setter方法之中。通过这种方式来实现对属性的赋值。</p><p>可以看出，其实代码的核心是通过Java的反射机制调用构造器及setter方法，在调用过程中根据具体的类型把属性值作为一个参数赋值进去。这也是所有的框架在实现IoC时的思路。<strong>反射技术是IoC容器赖以工作的基础。</strong></p><p>到这里，我们就完成了对XML配置的解析，实现了Spring中Bean的构造器注入与setter注入方式。回到我们开头的问题：配置文件中的属性设置是如何生效的？到这里我们就有答案了，就是<strong>通过反射给Bean里面的属性赋值，就意味着配置文件生效了。</strong></p><p>这里，我还想带你理清一个小的概念问题。在实现过程中，我们经常会用到依赖注入和IoC这两个术语，初学者很容易被这两个术语弄糊涂。其实，一开始只有IoC，也就是控制反转，但是这个术语让人很难快速理解，我们不知道反转了什么东西。但是通过之前的实现过程，我们就可以理解这个词了。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/4b/d508800320aa0f8688b7c986e0148e4b.png?wh=1920x975\" alt=\"图片\"></p><p>一个“正常”的控制过程是由调用者直接创建Bean，但是IoC的过程正好相反，是由框架来创建Bean，然后注入给调用者，这与“正常”的过程是反的，控制反转就是这个意思。但是总的来说，这个术语还是过于隐晦，引发了很长一段时间的争议，直到传奇程序员Martin Fowler一锤定音，将其更名为“依赖注入”，一切才尘埃落定，“依赖注入”从此成为大家最常使用的术语。</p><h2>Bean之间的依赖问题</h2><p>现在我们进一步考虑一个问题。在注入属性值的时候，如果这个属性本身是一个对象怎么办呢？这就是Bean之间的依赖问题了。</p><p>这个场景在我们进行代码开发时还是非常常见的。比如，操作MySQL数据库的时候，经常需要引入Mapper类，而Mapper类本质上也是在IoC容器在启动时加载的一个Bean对象。</p><p>或许有人会说，我们就按照前面的配置方式，在type里配置需要配置Bean的绝对包路径，name里对应Bean的属性，不就好了吗？但这样还是会存在一个问题，<strong>如何用Value这样一个简单的值表示某个对象中所有的域呢？</strong></p><p>为此，Spring做了一个很巧妙的事情，它在<property>标签里增加了<strong>ref属性（引用）</strong>，这个属性就记录了需要引用的另外一个Bean，这就方便多了。你可以参考下面的配置文件。</property></p><pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;beans&gt;\n    &lt;bean id=\"basebaseservice\" class=\"com.minis.test.BaseBaseService\"&gt;\n        &lt;property type=\"com.minis.test.AServiceImpl\" name=\"as\" ref=\"aservice\" /&gt;\n    &lt;/bean&gt;\n    &lt;bean id=\"aservice\" class=\"com.minis.test.AServiceImpl\"&gt;\n        &lt;constructor-arg type=\"String\" name=\"name\" value=\"abc\"/&gt;\n        &lt;constructor-arg type=\"int\" name=\"level\" value=\"3\"/&gt;\n        &lt;property type=\"String\" name=\"property1\" value=\"Someone says\"/&gt;\n        &lt;property type=\"String\" name=\"property2\" value=\"Hello World!\"/&gt;\n        &lt;property type=\"com.minis.test.BaseService\" name=\"ref1\" ref=\"baseservice\"/&gt;\n    &lt;/bean&gt;\n    &lt;bean id=\"baseservice\" class=\"com.minis.test.BaseService\"&gt;\n        &lt;property type=\"com.minis.test.BaseBaseService\" name=\"bbs\" ref=\"basebaseservice\" /&gt;\n    &lt;/bean&gt;\n</code></pre><p>在上面的XML配置文件中，我们配置了一个Bean，ID命名为baseservice，随后在aservice bean的<property>标签中设置ref=“baseservice”，也就是说我们希望此处注入的是一个Bean而不是一个简单的值。所以在对应的AServiceImpl里，也得有类型为BaseService的域ref1。</property></p><pre><code class=\"language-java\">public class AServiceImpl implements AService {\n    private String name;\n    private int level;\n    private String property1;\n    private String property2;\n    private BaseService ref1;\n    \n    public AServiceImpl() {\n    }\n    public AServiceImpl(String name, int level) {\n        this.name = name;\n        this.level = level;\n        System.out.println(this.name + \",\" + this.level);\n    }\n    public void sayHello() {\n        System.out.println(this.property1 + \",\" + this.property2);\n    }\n \n    // 在此省略property1和property2的setter、getter方法   \n}\n</code></pre><p>既然添加了ref属性，接下来我们很自然地会想到，要解析这个属性。下面我们就来解析一下ref，看看Spring是如何将配置的Bean注入到另外一个Bean中的。</p><p>我们为PropertyValue.java程序增加isRef字段，它可以判断属性是引用类型还是普通的值类型，我们看下修改后的代码。</p><pre><code class=\"language-java\">public class PropertyValue {\n&nbsp; &nbsp; private final String type;\n&nbsp; &nbsp; private final String name;\n&nbsp; &nbsp; private final Object value;\n&nbsp; &nbsp; private final boolean isRef;\n&nbsp; &nbsp; public PropertyValue(String type, String name, Object value, boolean isRef)&nbsp;\n{\n&nbsp; &nbsp; &nbsp; &nbsp; this.type = type;\n&nbsp; &nbsp; &nbsp; &nbsp; this.name = name;\n&nbsp; &nbsp; &nbsp; &nbsp; this.value = value;\n&nbsp; &nbsp; &nbsp; &nbsp; this.isRef = isRef;\n}\n</code></pre><p>在这里我们调整了PropertyValue的构造函数，增加了isRef参数。&nbsp; &nbsp;<br>\n接下来我们看看如何解析ref属性，我们还是在XmlBeanDefinitionReader类中来处理。</p><pre><code class=\"language-java\">&nbsp;public void loadBeanDefinitions(Resource resource) {\n&nbsp; &nbsp; &nbsp; &nbsp; while (resource.hasNext()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Element element = (Element) resource.next();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String beanID = element.attributeValue(\"id\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String beanClassName = element.attributeValue(\"class\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BeanDefinition beanDefinition = new BeanDefinition(beanID,&nbsp;\nbeanClassName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // handle constructor\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&lt;Element&gt; constructorElements = element.elements(\"constructor-\narg\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArgumentValues AVS = new ArgumentValues();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Element e : constructorElements) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String aType = e.attributeValue(\"type\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String aName = e.attributeValue(\"name\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String aValue = e.attributeValue(\"value\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AVS.addArgumentValue(new ArgumentValue(aType, aName, aValue));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beanDefinition.setConstructorArgumentValues(AVS);\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // handle properties\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&lt;Element&gt; propertyElements = element.elements(\"property\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PropertyValues PVS = new PropertyValues();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&lt;String&gt; refs = new ArrayList&lt;&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Element e : propertyElements) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String pType = e.attributeValue(\"type\");\n                String pName = e.attributeValue(\"name\");\n              &nbsp; String pValue = e.attributeValue(\"value\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String pRef = e.attributeValue(\"ref\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String pV = \"\";\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean isRef = false;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pValue != null &amp;&amp; !pValue.equals(\"\")) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isRef = false;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pV = pValue;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (pRef != null &amp;&amp; !pRef.equals(\"\")) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isRef = true;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pV = pRef;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refs.add(pRef);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVS.addPropertyValue(new PropertyValue(pType, pName, pV,&nbsp;\nisRef));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beanDefinition.setPropertyValues(PVS);\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String[] refArray = refs.toArray(new String[0]);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beanDefinition.setDependsOn(refArray);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.simpleBeanFactory.registerBeanDefinition(beanID,&nbsp;\nbeanDefinition);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp;}\n</code></pre><p>由上述代码可以看出，程序解析 <code>&lt;property&gt;</code> 标签后，获取了ref的参数，同时有针对性地设置了isRef的值，把它添加到了PropertyValues内，最后程序调用setDependsOn方法，它记录了某一个Bean引用的其他Bean。这样，我们引用ref的配置就定义好了。</p><p>然后，我们改造一下以前的createBean()方法，抽取出一个单独处理属性的方法。</p><pre><code class=\"language-java\">\tprivate Object createBean(BeanDefinition bd) {\n\t\t... ...\n\t\thandleProperties(bd, clz, obj);\n\t\treturn obj;\t\n\t}\n\n\tprivate void handleProperties(BeanDefinition bd, Class&lt;?&gt; clz, Object obj) {\n&nbsp; &nbsp; &nbsp; &nbsp; // 处理属性\n\t\tSystem.out.println(\"handle properties for bean : \" + bd.getId());\n\t\tPropertyValues propertyValues = bd.getPropertyValues();\n        //如果有属性\n\t\tif (!propertyValues.isEmpty()) {\n\t\t\tfor (int i=0; i&lt;propertyValues.size(); i++) {\n\t\t\t\tPropertyValue propertyValue = propertyValues.getPropertyValueList().get(i);\n\t\t\t\tString pName = propertyValue.getName();\n\t\t\t\tString pType = propertyValue.getType();\n&nbsp; &nbsp; \t\t\tObject pValue = propertyValue.getValue();\n&nbsp; &nbsp; \t\t\tboolean isRef = propertyValue.getIsRef();\n&nbsp; &nbsp; \t\t\tClass&lt;?&gt;[] paramTypes = new Class&lt;?&gt;[1];&nbsp; &nbsp; \t\t\t\n\t\t\t\tObject[] paramValues =&nbsp; &nbsp;new Object[1];&nbsp;&nbsp;\n&nbsp; &nbsp; \t\t\tif (!isRef) { //如果不是ref，只是普通属性\n    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //对每一个属性，分数据类型分别处理\n\t\t\t\t\tif (\"String\".equals(pType) || \"java.lang.String\".equals(pType)) {\n\t\t\t\t\t\tparamTypes[0] = String.class;\n\t\t\t\t\t}\n\t\t\t\t\telse if (\"Integer\".equals(pType) || \"java.lang.Integer\".equals(pType)) {\n\t\t\t\t\t\tparamTypes[0] = Integer.class;\n\t\t\t\t\t}\n\t\t\t\t\telse if (\"int\".equals(pType)) {\n\t\t\t\t\t\tparamTypes[0] = int.class;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tparamTypes[0] = String.class;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tparamValues[0] = pValue;\n&nbsp; &nbsp; \t\t\t}\n&nbsp; &nbsp; \t\t\telse { //is ref, create the dependent beans\n&nbsp; &nbsp; \t\t\t\ttry {\n\t\t\t\t\t\tparamTypes[0] = Class.forName(pType);\n\t\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n&nbsp; &nbsp; \t\t\t\ttry {\n                        //再次调用getBean创建ref的bean实例\n\t\t\t\t\t\tparamValues[0] = getBean((String)pValue);\n\t\t\t\t\t} \n&nbsp; &nbsp; \t\t\t}\n \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //按照setXxxx规范查找setter方法，调用setter方法设置属性\n&nbsp; &nbsp; \t\t\tString methodName = \"set\" + pName.substring(0,1).toUpperCase() + pName.substring(1);\t\t\t\t&nbsp; &nbsp; \t\t\t\n&nbsp; &nbsp; \t\t\tMethod method = null;\n\t\t\t\ttry {\n\t\t\t\t\tmethod = clz.getMethod(methodName, paramTypes);\n\t\t\t\t} \n&nbsp; &nbsp; \t\t\ttry {\n\t\t\t\t\tmethod.invoke(obj, paramValues);\n\t\t\t\t} \n\t\t\t}\n\t\t}\t\t\n\t}\n</code></pre><p>这里的重点是处理ref的这几行代码。</p><pre><code class=\"language-plain\">//is ref, create the dependent beans\nparamTypes[0] = Class.forName(pType);\nparamValues[0] = getBean((String)pValue);\n</code></pre><p>这段代码实现的思路就是，对ref所指向的另一个Bean再次调用getBean()方法，这个方法会获取到另一个Bean实例，这样就实现了另一个Bean的注入。</p><p>这样一来，如果有多级引用，就会形成一个多级的getBean()调用链。由于在调用getBean()的时候会判断容器中是否包含了bean instance，没有的话会立即创建，所以XML配置文件中声明Bean的先后次序是任意的。</p><h2>循环依赖问题</h2><p>这又引出了另一个问题，在某个Bean需要注入另一个Bean的时候，如果那个Bean还不存在，该怎么办？</p><p>请你想象一个场景，Spring扫描到了ABean，在解析它并设置内部属性时，发现某个属性是另一个BBean，而此时Spring内部还不存在BBean的实例。这就要求Spring在创建ABean的过程中，能够再去创建一个BBean，继续推衍下去，BBean可能又会依赖第三个CBean。事情还可能进一步复杂化，如果CBean又反过来依赖ABean，就会形成循环依赖。</p><p>在逻辑上，我们好像陷入了一个死结，我们必须想办法打破这个循环。我们来看看Spring是如何解决这个问题的。</p><p>请你回顾一下创建Bean的过程。我们根据Bean的定义配置生成了BeanDefinition，然后根据定义加载Bean类，再进行实例化，最后在Bean中注入属性。</p><p>从这个过程中可以看出，在注入属性之前，其实这个Bean的实例已经生成出来了，只不过此时的实例还不是一个完整的实例，它还有很多属性没有值，可以说是一个早期的毛胚实例。而我们现在讨论的Bean之间的依赖是在属性注入这一阶段，因此我们可以在实例化与属性注入这两个阶段之间增加一个环节，确保给Bean注入属性的时候，Spring内部已经准备好了Bean的实例。</p><p>Spring的做法是在BeanFactory中引入一个结构：<strong>earlySingletonObjects</strong>，这里面存放的就是早期的毛胚实例。创建Bean实例的时候，不用等到所有步骤完成，而是可以在属性还没有注入之前，就把早期的毛胚实例先保存起来，供属性注入时使用。</p><p>这时再回到我们的复杂依赖场景，ABean依赖BBean，BBean又依赖CBean，而CBean反过来还要依赖ABean。现在，我们可以这样实现依赖注入。</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/ee/f4a1a6b8973eae18d9edb54cd8277bee.png?wh=1806x1482\" alt=\"图片\"></p><p>第一步，先实例化ABean，此时它是早期的不完整毛胚实例，好多属性还没被赋值，将实例放置到earlySingletonObjects中备用。然后给ABean注入属性，这个时候发现它还要依赖BBean。</p><p>第二步，实例化BBean，它也是早期的不完整毛胚实例，我们也将实例放到earlySingletonObjects中备用。然后再给BBean注入属性，又发现它依赖CBean。</p><p>第三步，实例化CBean，此时它仍然是早期的不完整的实例，同样将实例放置到earlySingletonObjects中备用，然后再给CBean属性赋值，这个时候又发现它反过来还要依赖ABean。</p><p>第四步，我们从earlySingletonObjects结构中找到ABean的早期毛胚实例，取出来给CBean注入属性，这意味着这时CBean所用的ABean实例是那个早期的毛胚实例。这样就先创建好了CBean。</p><p>第五步，程序控制流回到第二步，完成BBean的属性注入。</p><p>第六步，程序控制流回到第一步，完成ABean的属性注入。至此，所有的Bean就都创建完了。</p><p>通过上述过程可以知道，这一系列的Bean是纠缠在一起创建的，我们不能简单地先后独立创建它们，而是要作为一个整体来创建。</p><p>相应的程序代码，反映在getBean(), createBean() 和 doCreateBean()中。</p><pre><code class=\"language-java\">@Override\npublic Object getBean(String beanName) throws BeansException {\n    //先尝试直接从容器中获取bean实例\n    Object singleton = this.getSingleton(beanName);\n    if (singleton == null) {\n        //如果没有实例，则尝试从毛胚实例中获取\n        singleton = this.earlySingletonObjects.get(beanName);\n        if (singleton == null) {\n            //如果连毛胚都没有，则创建bean实例并注册\n            BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);\n            singleton = createBean(beanDefinition);\n            this.registerSingleton(beanName, singleton);\n            // 预留beanpostprocessor位置\n            // step 1: postProcessBeforeInitialization\n            // step 2: afterPropertiesSet\n            // step 3: init-method\n            // step 4: postProcessAfterInitialization\n        }\n    }\n    return singleton;\n  }\n  \nprivate Object createBean(BeanDefinition beanDefinition) {\n    Class&lt;?&gt; clz = null;\n    //创建毛胚bean实例\n    Object obj = doCreateBean(beanDefinition);\n    //存放到毛胚实例缓存中\n    this.earlySingletonObjects.put(beanDefinition.getId(), obj);\n    try {\n        clz = Class.forName(beanDefinition.getClassName());\n    } \n    //处理属性\n    handleProperties(beanDefinition, clz, obj);\n    return obj;\n}\n\n//doCreateBean创建毛胚实例，仅仅调用构造方法，没有进行属性处理\nprivate Object doCreateBean(BeanDefinition bd) {\n\t\tClass&lt;?&gt; clz = null;\n\t\tObject obj = null;\n\t\tConstructor&lt;?&gt; con = null;\n\n\t\ttry {\n&nbsp; &nbsp; \t\tclz = Class.forName(bd.getClassName());\n&nbsp; &nbsp; \t\t\n&nbsp; &nbsp; \t\t//handle constructor\n&nbsp; &nbsp; \t\tArgumentValues argumentValues = bd.getConstructorArgumentValues();\n&nbsp; &nbsp; \t\tif (!argumentValues.isEmpty()) {\n&nbsp; &nbsp; &nbsp; &nbsp; \t\tClass&lt;?&gt;[] paramTypes = new Class&lt;?&gt;[argumentValues.getArgumentCount()];\n&nbsp; &nbsp; &nbsp; &nbsp; \t\tObject[] paramValues =&nbsp; &nbsp;new Object[argumentValues.getArgumentCount()];&nbsp;&nbsp;\n&nbsp; &nbsp; \t\t\tfor (int i=0; i&lt;argumentValues.getArgumentCount(); i++) {\n&nbsp; &nbsp; \t\t\t\tArgumentValue argumentValue = argumentValues.getIndexedArgumentValue(i);\n&nbsp; &nbsp; \t\t\t\tif (\"String\".equals(argumentValue.getType()) || \"java.lang.String\".equals(argumentValue.getType())) {\n&nbsp; &nbsp; \t\t\t\t\tparamTypes[i] = String.class;\n&nbsp; &nbsp; &nbsp; &nbsp; \t\t\t\tparamValues[i] = argumentValue.getValue();\n&nbsp; &nbsp; \t\t\t\t}\n&nbsp; &nbsp; \t\t\t\telse if (\"Integer\".equals(argumentValue.getType()) || \"java.lang.Integer\".equals(argumentValue.getType())) {\n&nbsp; &nbsp; \t\t\t\t\tparamTypes[i] = Integer.class;\n&nbsp; &nbsp; &nbsp; &nbsp; \t\t\t\tparamValues[i] = Integer.valueOf((String) argumentValue.getValue());\n&nbsp; &nbsp; \t\t\t\t}\n&nbsp; &nbsp; \t\t\t\telse if (\"int\".equals(argumentValue.getType())) {\n&nbsp; &nbsp; \t\t\t\t\tparamTypes[i] = int.class;\n&nbsp; &nbsp; &nbsp; &nbsp; \t\t\t\tparamValues[i] = Integer.valueOf((String) argumentValue.getValue()).intValue();\n&nbsp; &nbsp; \t\t\t\t}\n&nbsp; &nbsp; \t\t\t\telse {\n&nbsp; &nbsp; \t\t\t\t\tparamTypes[i] = String.class;\n&nbsp; &nbsp; &nbsp; &nbsp; \t\t\t\tparamValues[i] = argumentValue.getValue();&nbsp; &nbsp; \t\t\t\t\t\n&nbsp; &nbsp; \t\t\t\t}\n&nbsp; &nbsp; \t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tcon = clz.getConstructor(paramTypes);\n\t\t\t\t\tobj = con.newInstance(paramValues);\n\t\t\t\t} &nbsp;&nbsp;\n&nbsp; &nbsp; \t\t}\n&nbsp; &nbsp; \t\telse {\n&nbsp; &nbsp; \t\t\tobj = clz.newInstance();\n&nbsp; &nbsp; \t\t}\n\t\t} \n\t\t\n\t\tSystem.out.println(bd.getId() + \" bean created. \" + bd.getClassName() + \" : \" + obj.toString());\t\t\n\t\treturn obj;\n\n}\n\n</code></pre><p>createBean()方法中调用了一个<strong>doCreateBean(bd)方法</strong>，专门负责创建早期的毛胚实例。毛胚实例创建好后会放在earlySingletonObjects结构中，然后createBean()方法再调用handleProperties()补齐这些property的值。</p><p>在getBean()方法中，首先要判断有没有已经创建好的bean，有的话直接取出来，如果没有就检查earlySingletonObjects中有没有相应的毛胚Bean，有的话直接取出来，没有的话就去创建，并且会根据Bean之间的依赖关系把相关的Bean全部创建好。</p><p>很多资料把这个过程叫做bean的“三级缓存”，这个术语来自于Spring源代码中的程序注释。实际上我们弄清楚了这个getBean()的过程后就会知道这段注释并不是很恰当。只不过这是Spring发明人自己写下的注释，大家也都这么称呼而已。</p><h2>包装方法refresh()</h2><p>可以看出，在Spring体系中，Bean是结合在一起同时创建完毕的。为了减少它内部的复杂性，Spring对外提供了一个很重要的包装方法：<strong>refresh()</strong>。具体的包装方法也很简单，就是对所有的Bean调用了一次getBean()，利用getBean()方法中的createBean()创建Bean实例，就可以只用一个方法把容器中所有的Bean的实例创建出来了。</p><p>我们先在SimpleBeanFactory中实现一个最简化的refresh()方法。</p><pre><code class=\"language-java\">public void refresh() {\n    for (String beanName : beanDefinitionNames) {\n        try {\n            getBean(beanName);\n        } \n    }\n}\n</code></pre><p>然后我们改造ClassPathXmlApplicationContext，配合我们上一步增加的refresh()方法使用，你可以看下相应的代码。</p><pre><code class=\"language-java\">public class ClassPathXmlApplicationContext implements BeanFactory, ApplicationEventPublisher{\n\n  SimpleBeanFactory beanFactory;\n  public ClassPathXmlApplicationContext(String fileName) {\n      this(fileName, true);\n  }\n  public ClassPathXmlApplicationContext(String fileName, boolean isRefresh) {\n      Resource resource = new ClassPathXmlResource(fileName);\n      SimpleBeanFactory simpleBeanFactory = new SimpleBeanFactory();\n      XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(simpleBeanFactory);\n      reader.loadBeanDefinitions(resource);\n      this.beanFactory = simpleBeanFactory;\n      if (isRefresh) {\n          this.beanFactory.refresh();\n      }\n  }\n  // 省略方法实现\n }\n</code></pre><p>到这里，我们的ClassPAthXmlApplicationContext用一个refresh() 就将整个IoC容器激活了，运行起来，加载所有配置好的Bean。</p><p>你可以试着构建一下的测试代码。</p><pre><code class=\"language-java\">public class BaseBaseService {\n&nbsp; &nbsp; private AServiceImpl as;\n    // 省略 getter、setter方法\n}\n</code></pre><pre><code class=\"language-java\">public class BaseService {\n&nbsp; &nbsp; private BaseBaseService bbs;\n    // 省略 getter、setter方法\n}\n</code></pre><pre><code class=\"language-java\">public class AServiceImpl implements AService {\n&nbsp; &nbsp; private String name;\n&nbsp; &nbsp; private int level;\n&nbsp; &nbsp; private String property1;\n&nbsp; &nbsp; private String property2;\n&nbsp; &nbsp; private BaseService ref1;\n    // 省略 getter、setter方法\n}  \n</code></pre><p>相应的XML配置如下：</p><pre><code class=\"language-java\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;beans&gt;\n&nbsp; &nbsp; &lt;bean id=\"aservice\" class=\"com.minis.test.AServiceImpl\"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;constructor-arg type=\"String\" name=\"name\" value=\"abc\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;constructor-arg type=\"int\" name=\"level\" value=\"3\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"String\" name=\"property1\" value=\"Someone says\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"String\" name=\"property2\" value=\"Hello World!\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"com.minis.test.BaseService\" name=\"ref1\"&nbsp;\nref=\"baseservice\"/&gt;\n&nbsp; &nbsp; &lt;/bean&gt;\n&nbsp; &nbsp; &lt;bean id=\"basebaseservice\" class=\"com.minis.test.BaseBaseService\"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"com.minis.test.AServiceImpl\" name=\"as\" ref=\"aservice\" /&gt;\n&nbsp; &nbsp; &lt;/bean&gt;\n&nbsp; &nbsp; &lt;bean id=\"baseservice\" class=\"com.minis.test.BaseService\"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"com.minis.test.BaseBaseService\" name=\"bbs\"&nbsp;\nref=\"basebaseservice\" /&gt;\n&nbsp; &nbsp; &lt;/bean&gt;\n</code></pre><p>然后运行测试程序，可以看到我们自己的IoC容器运行起来了。</p><h2>小结</h2><p>这节课，我们紧接着上一节课对XML配置的解析，实现了Spring中Bean的构造器注入与setter注入两种方式。</p><p>在将属性注入Bean的过程中，我们还增加了ref属性，它可以在一个Bean对象中引入另外的Bean对象。我们还通过引入“毛胚Bean”的概念解决了循环依赖的问题。</p><p>我们还为容器增加了refresh()方法，这个方法包装了容器启动的各个步骤，从Bean工厂的创建到Bean对象的实例化和初始化，再到完成Spring容器加载，一切Bean的处理都能在这里完成，可以说是Spring中的核心方法了。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课内容，我也给你留一道思考题。你认为能不能在一个Bean的构造器中注入另一个Bean？欢迎你在留言区与我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","comments":[{"had_liked":false,"id":370673,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"北京","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1679095290,"is_pvip":false,"replies":[{"id":135258,"content":"你完全理解了，赞！\n我的三级缓存，最后一级就是直接创建bean实例。我在后面的再回首中章节有说明这个所谓的“缓存”是什么，不用拘泥于名词术语。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679136675,"ip_address":"澳大利亚","comment_id":370673,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"回复BattleMan1994\n\n老师这个用了两个缓存，spring多一个创建bean实例工厂缓存，详细如下\n\n\n三级缓存机制包括以下三个缓存：\n\n1. singletonObjects：用于存储完全创建好的单例bean实例。\n\n2. earlySingletonObjects：用于存储早期创建但未完成初始化的单例bean实例。即老师说的毛坯\n\n3. singletonFactories：用于存储创建单例bean实例的工厂对象。\n\n当Spring发现两个或更多个bean之间存在循环依赖关系时，它会将其中一个bean创建的过程中尚未完成的实例放入earlySingletonObjects缓存中，然后将创建该bean的工厂对象放入singletonFactories缓存中。接着，Spring会暂停当前bean的创建过程，去创建它所依赖的bean。当依赖的bean创建完成后，Spring会将其放入singletonObjects缓存中，并使用它来完成当前bean的创建过程。在创建当前bean的过程中，如果发现它还依赖其他的bean，Spring会重复上述过程，直到所有bean的创建过程都完成为止。\n\n需要注意的是，当使用构造函数注入方式时，循环依赖是无法解决的。因为在创建bean时，必须先创建它所依赖的bean实例，而构造函数注入方式需要在创建bean实例时就将依赖的bean实例传入构造函数中。如果依赖的bean实例尚未创建完成，就无法将其传入构造函数中，从而导致循环依赖无法解决。此时，可以考虑使用setter注入方式来解决循环依赖问题。","like_count":32,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609712,"discussion_content":"你完全理解了，赞！\n我的三级缓存，最后一级就是直接创建bean实例。我在后面的再回首中章节有说明这个所谓的“缓存”是什么，不用拘泥于名词术语。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679136675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1141923,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6c/a3/7d60e2a0.jpg","nickname":"1184507801","note":"","ucode":"930E2F79C5582A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":641840,"discussion_content":"老师 第三点 singletonFactories：用于存储创建单例bean实例的工厂对象。 这个singletonFactories代码里没有看到啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713045865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609712,"ip_address":"广东","group_id":0},"score":641840,"extra":""}]},{"author":{"id":2028951,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/97/9a7ee7b3.jpg","nickname":"Geek4329","note":"","ucode":"D6FB8D1B2D5DAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":638772,"discussion_content":"singletonFactories 这个东西我咋没看到呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1709893587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373056,"user_name":"大胖子呀、","can_delete":false,"product_type":"c1","uid":1258251,"ip_address":"广东","ucode":"4BADF8096254BE","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/0b/fd18c8ab.jpg","comment_is_top":false,"comment_ctime":1681978736,"is_pvip":false,"replies":[{"id":136300,"content":"太对了。Spring 6已经开始限制了。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681991246,"ip_address":"澳大利亚","comment_id":373056,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"个人感觉循环依赖是一种非常糟糕的设计，往往意味着写出这段代码的程序员没有理清层级关系，没有设计好上下层的依赖，是一种非常明显的坏味道。\nSpring对于循环依赖的支持，反而导致了程序员写出了坏味道代码而不自知，或许从一开始Spring就不该支持循环依赖。\n所以Spring官方也建议大家使用构造器注入，一个是避免写出这种层级依赖不清晰的糟糕代码，二是也方便了后续单元测试的编写。","like_count":13,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614987,"discussion_content":"太对了。Spring 6已经开始限制了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681991246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370660,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"北京","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1679060042,"is_pvip":false,"replies":[{"id":135260,"content":"赞","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679136817,"ip_address":"澳大利亚","comment_id":370660,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"思考题\nSpring支持一个Bean构造器注入另一个Bean，工作中也都是尽量通过构造器注入，有很多优点\n\n通过属性注入的方式能解决循环依赖的问题，原理是通过缓存的方式解决的，这里的关键点是属性注入是在bean创建后注入的\n\n而构造器注入不能解决循环依赖问题\n因为需要在创建bean时就需要将依赖的bean传入到构造函数中，如果依赖的bean尚未创建完成，就不能传入到构造函数中，循环依赖就不能解决","like_count":10,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609714,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679136817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2882763,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/fc/cb/9e7f075c.jpg","nickname":"一滴水的波浪","note":"","ucode":"B88A25C2C87B87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609788,"discussion_content":"构造器不能解决循环依赖的问题吗？是不是加上懒加载的注解后就可以了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679213295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1004698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","nickname":"每天晒白牙","note":"","ucode":"A1B102CD933DEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2882763,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/fc/cb/9e7f075c.jpg","nickname":"一滴水的波浪","note":"","ucode":"B88A25C2C87B87","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609861,"discussion_content":"你可以试试，等你的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679269761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609788,"ip_address":"北京","group_id":0},"score":609861,"extra":""}]}]},{"had_liked":false,"id":370774,"user_name":"Geek_320730","can_delete":false,"product_type":"c1","uid":3035552,"ip_address":"北京","ucode":"CF7E6C8E91D2C4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/XWv3mvIFORNgRk9wF8QLb9aXfh1Uz1hADtUmlFwQJVxIzhBf8HWc4QqU7iaTzj8wB5p5QJLRAvlQNrOqXtrg1Og/132","comment_is_top":false,"comment_ctime":1679241284,"is_pvip":false,"replies":[{"id":135289,"content":"你说的对，是这样的，有另外的人也指出了这一点。赞你！\n比较简单的解决方案是一次性先把Definition加载完，然后再getBean，这样保证所有bean的定义都预先准备好了。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679282918,"ip_address":"澳大利亚","comment_id":370774,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"loadBeanDefinitions结束的时候会registerBeanDefinition，看代码中registerBeanDefinition又会根据这个Bean是否是单例来判断要不要getBean。如果getBean的话：如果这个Bean有依赖的Bean,会继续getBean,如果xml中 这个被依赖的Bean定义在这个Bean后面，那么后面被依赖的Bean的BeanDefintion还没有被loadBeanDefinitions，createBean的时候就会报错。","like_count":9,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609893,"discussion_content":"你说的对，是这样的，有另外的人也指出了这一点。赞你！\n比较简单的解决方案是一次性先把Definition加载完，然后再getBean，这样保证所有bean的定义都预先准备好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679282918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370771,"user_name":"木  昜","can_delete":false,"product_type":"c1","uid":2108088,"ip_address":"北京","ucode":"84951C2E0B8DF9","user_header":"https://static001.geekbang.org/account/avatar/00/20/2a/b8/dc924db4.jpg","comment_is_top":false,"comment_ctime":1679239506,"is_pvip":false,"replies":[{"id":135288,"content":"你的思考很好，用心了。\n你说的是对的，赞！","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679282810,"ip_address":"澳大利亚","comment_id":370771,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"您好，目前所写的逻辑是加载一个BeanDefinition，然后放入Map，同时判断是否为懒加载，不是的话就创建该bean，然后加载下一个bean定义。\n如果xml在a的bean定义在b之前，并且a依赖了b。\n此时 加载a的定义，创建a，发现a依赖b，就去getBean（b），但是此时b的定义还没有加载进map，就会抛出异常。\n是否可以改为加载完全部的bean定义之后再进行bean的创建。把两步骤分开？","like_count":5,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609892,"discussion_content":"你的思考很好，用心了。\n你说的是对的，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679282810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3866578,"avatar":"https://static001.geekbang.org/account/avatar/00/3a/ff/d2/c1f5334d.jpg","nickname":"dirtychill","note":"","ucode":"4D3172C60E522A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644297,"discussion_content":"字词","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715158386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370977,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1679417260,"is_pvip":false,"replies":[{"id":135325,"content":"对的，isLazyInit()返回值改为true也可以。这是当时留给学生的扩展练习。你们能提出这些问题，用心了，赞！","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679441546,"ip_address":"澳大利亚","comment_id":370977,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，我看其他同学提了这个问题。就是如果xml中A定义在前，依赖B，但是B定义在后。此时会因为beanDefinitionMap中不存在beanDefinition而报错。我看您给你的解决方案是先将beanDefinition对象一次性全部加载完成。那是不是将SimpleBeanFactory类中的方法registerBeanDefinition中的以下逻辑去掉就可以了。\nif (!bd.isLazyInit()) {\n            getBean(name);\n        }\n我试了试，这样是ok的，因为ClassPathXmlApplicationContext中的refresh方法会执行到getBean","like_count":4,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610174,"discussion_content":"对的，isLazyInit()返回值改为true也可以。这是当时留给学生的扩展练习。你们能提出这些问题，用心了，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679441546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371407,"user_name":"追梦","can_delete":false,"product_type":"c1","uid":2883656,"ip_address":"广东","ucode":"E14C909DDE2603","user_header":"https://static001.geekbang.org/account/avatar/00/2c/00/48/55932a4c.jpg","comment_is_top":false,"comment_ctime":1679906230,"is_pvip":false,"replies":[{"id":135499,"content":"看起来是，其实不是。这是bean的约定。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679916003,"ip_address":"澳大利亚","comment_id":371407,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师好，这个反射构造器和反射setXXX()方法这样写有点硬编码的味道，有没有简洁的写法，如何不硬编码解决基本类型的反射问题","like_count":3,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611065,"discussion_content":"看起来是，其实不是。这是bean的约定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679916003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318633,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","nickname":"Geek_7jwpfc","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618836,"discussion_content":"这个约定属于java Bean，不属于spring bean 很多框架都是通过set方法放入属性的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684608329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372653,"user_name":"康Geek","can_delete":false,"product_type":"c1","uid":2683210,"ip_address":"广东","ucode":"D54F1CFDA9F2D5","user_header":"https://static001.geekbang.org/account/avatar/00/28/f1/4a/bcba0456.jpg","comment_is_top":false,"comment_ctime":1681400161,"is_pvip":false,"replies":[{"id":136012,"content":"多谢提醒。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681433559,"ip_address":"澳大利亚","comment_id":372653,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"文稿中 ClassPathXmlApplicationContext 这个类的构造方法中 isRefresh 有个错误：\nif (!isRefresh) { this.beanFactory.refresh(); } 这个 if 的条件中时取反的，但是在老师 github 仓库中 geek_ioc3 分支的 ClassPathXmlApplicationContext.java 构造方法中是没有取反的：\nif (isRefresh) { this.beanFactory.refresh();}\n","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613623,"discussion_content":"多谢提醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681433559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372543,"user_name":"塵","can_delete":false,"product_type":"c1","uid":2137874,"ip_address":"湖南","ucode":"56C9A3458D57A8","user_header":"https://static001.geekbang.org/account/avatar/00/20/9f/12/58b5609f.jpg","comment_is_top":false,"comment_ctime":1681267601,"is_pvip":false,"replies":[{"id":135995,"content":"文稿是一个主干，还是要读源代码，github上有。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681301320,"ip_address":"澳大利亚","comment_id":372543,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"createBean从哪里冒出来的，上面的课程里面SimpleBeanFactory类里没有看到","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613397,"discussion_content":"文稿是一个主干，还是要读源代码，github上有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681301320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1786951,"avatar":"","nickname":"Geek_50a5cc","note":"","ucode":"0F6C1C2552261F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634068,"discussion_content":"我最开始也遇到了这个问题，Context一直调用的是 registerBean...，后来是为了处理注入，对于getBean..进行了改造，createBean是在getBean里面使用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702968331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214384,"avatar":"https://static001.geekbang.org/account/avatar/00/12/87/b0/b06d25f4.jpg","nickname":"Y～龙。！","note":"","ucode":"21D0AF4DCC880A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633897,"discussion_content":"老师。可以发下github地址吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702733219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375668,"user_name":"Jackwey","can_delete":false,"product_type":"c1","uid":3070473,"ip_address":"广东","ucode":"4C1F673E0778D6","user_header":"https://static001.geekbang.org/account/avatar/00/2e/da/09/a0359f6b.jpg","comment_is_top":false,"comment_ctime":1685795889,"is_pvip":false,"replies":[{"id":137123,"content":"毛坯后来又被填充了，又不是另一个对象。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685919690,"ip_address":"澳大利亚","comment_id":375668,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，Cbean依赖的是A的毛坯实例，那A的属性岂不是没有被Cbean依赖了？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620179,"discussion_content":"毛坯后来又被填充了，又不是另一个对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685919690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3070473,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/da/09/a0359f6b.jpg","nickname":"Jackwey","note":"","ucode":"4C1F673E0778D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":620183,"discussion_content":"原来是这样呀，谢谢老师，也就是相当于说刚开始依赖的是一个引用，这个引用指向的是一个毛坯实例，然后经过一系列的操作之后，这个毛坯实例成长为一个丰满的bean了，而这个引用指向的就是后来的这个丰满的bean了吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685926572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":620179,"ip_address":"广东","group_id":0},"score":620183,"extra":""}]}]},{"had_liked":false,"id":370607,"user_name":"TableBear","can_delete":false,"product_type":"c1","uid":1673990,"ip_address":"广东","ucode":"A2C0562EEA2725","user_header":"https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg","comment_is_top":false,"comment_ctime":1679021469,"is_pvip":false,"replies":[{"id":135239,"content":"你说得对。构造器中注入另一个bean是MiniSpring留给学员的扩展。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679047727,"ip_address":"澳大利亚","comment_id":370607,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"思考题回答：\n在Spring中Bean构造器注入另一个Bean是支持，但是看上面MinSpring的实现好像不支持。\n但是，Bean构造器注入没法用earlySingletonObjects解决循环依赖。\n不知道正不正确😂","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609606,"discussion_content":"你说得对。构造器中注入另一个bean是MiniSpring留给学员的扩展。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679047728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387295,"user_name":"Geek_94fbda","can_delete":false,"product_type":"c1","uid":3305679,"ip_address":"德国","ucode":"F45ACB1A728BE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mfZXPlpx5a7Y3oAWlpFJQxLwlQG2cVEdQ15cNibHEMxQRYlKZVRaGich4uCz9S64kK4UfjU3DBtXn3wVxp6icFBog/132","comment_is_top":false,"comment_ctime":1706876490,"is_pvip":false,"replies":[{"id":141242,"content":"对的，你很仔细。感谢！","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1708491849,"ip_address":"澳大利亚","comment_id":387295,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"BeanDefinition 里面要把lazyInit 的值改成True，这个在文章里没有提到。 否则的话是运行不了的","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637428,"discussion_content":"对的，你很仔细。感谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708491849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387264,"user_name":"Geek_94fbda","can_delete":false,"product_type":"c1","uid":3305679,"ip_address":"德国","ucode":"F45ACB1A728BE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mfZXPlpx5a7Y3oAWlpFJQxLwlQG2cVEdQ15cNibHEMxQRYlKZVRaGich4uCz9S64kK4UfjU3DBtXn3wVxp6icFBog/132","comment_is_top":false,"comment_ctime":1706788599,"is_pvip":false,"replies":[{"id":141245,"content":"pValue里面放的是bean的名字","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1708558112,"ip_address":"澳大利亚","comment_id":387264,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"else { &#47;&#47;is ref, create the dependent beans\n    \t\t\t\ttry {\n\t\t\t\t\t\tparamTypes[0] = Class.forName(pType);\n\t\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n    \t\t\t\ttry {\n\t\t\t\t\t\tparamValues[0] = getBean((String)pValue);\n\t\t\t\t\t} catch (BeansException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n    \t\t\t}\nisRef的类定义 是没有value这个值 的那pValue不是null么？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637484,"discussion_content":"pValue里面放的是bean的名字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708558112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374600,"user_name":"Geek_7jwpfc","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"湖南","ucode":"CBCEA76E9EF33B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","comment_is_top":false,"comment_ctime":1684221800,"is_pvip":false,"replies":[{"id":136736,"content":"很多设计不是非得如此，只是一个设计。Spring是singleton-early-factory三级缓存。MiniSpring是singleton-early两个，一定要说有三级也可以，就是那个new instance操作，只不过没有用factory封装。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684302225,"ip_address":"澳大利亚","comment_id":374600,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"老师写的很清晰，让我对spring有了更清楚的认识了，但是spring为什么要有第三个缓存，我还是没明白！别人博客解释，是代理的对象的原因，需要三级缓存；我的疑惑是，把代理对象直接放入第一个缓存中，不就行了吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618508,"discussion_content":"很多设计不是非得如此，只是一个设计。Spring是singleton-early-factory三级缓存。MiniSpring是singleton-early两个，一定要说有三级也可以，就是那个new instance操作，只不过没有用factory封装。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1684302225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374365,"user_name":"Robert Tsai","can_delete":false,"product_type":"c1","uid":1298711,"ip_address":"广东","ucode":"DB629B958C92ED","user_header":"https://static001.geekbang.org/account/avatar/00/13/d1/17/5f525662.jpg","comment_is_top":false,"comment_ctime":1684033056,"is_pvip":false,"replies":[{"id":136723,"content":"对。先有毛坯，再补上齐。不会影响后续，因为是同一个对象。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684154173,"ip_address":"澳大利亚","comment_id":374365,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"其实解决循环依赖的问题，就是一个办法：把创建bean的过程分成两阶段，第一阶段是一个毛胚的bean，第二阶段补齐属性。所有的毛胚bean都是提前创建出来的，后面面对循环依赖的时候，拿到的是这个提前准备好的毛胚bean。\n---\n老师，我对这个过程还有一点不解。ABean 依赖 BBean，BBean 又依赖 CBean，而 CBean 反过来还要依赖 ABean，此时CBean拿到的却是毛坯的“ABean”，但是拿到这个毛坯Bean其实并不影响整体ABean的创建，因为最终完成创建后，从IOC中getBean()时候就是一个完成的ABean。不知理解是否正确？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618240,"discussion_content":"对。先有毛坯，再补上齐。不会影响后续，因为是同一个对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684154173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372646,"user_name":"人老实话不多","can_delete":false,"product_type":"c1","uid":1798476,"ip_address":"北京","ucode":"9B460F879EB483","user_header":"https://static001.geekbang.org/account/avatar/00/1b/71/4c/50718389.jpg","comment_is_top":false,"comment_ctime":1681386541,"is_pvip":false,"replies":[{"id":136013,"content":"我认为这样违背了bean生命周期。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681433722,"ip_address":"澳大利亚","comment_id":372646,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"在属性注入之前，我们不能都把用到的Bean实例化吗？反正都是单例的，到最后所有的属性都会赋完值的，是吧老师？这样会有什么问题吗？还是说这样违背了Spring管理Bean生命周期的理念？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613625,"discussion_content":"我认为这样违背了bean生命周期。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681433722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371789,"user_name":"彬清","can_delete":false,"product_type":"c1","uid":1220372,"ip_address":"上海","ucode":"04620BAC60F15F","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/14/b9505789.jpg","comment_is_top":false,"comment_ctime":1680323905,"is_pvip":false,"replies":[{"id":135632,"content":"就是同一份","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680352360,"ip_address":"澳大利亚","comment_id":371789,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"完全创建好bean后，没有把毛胚bean从earlySingletonObjects中移出？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611836,"discussion_content":"就是同一份","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680352360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371676,"user_name":"XXG","can_delete":false,"product_type":"c1","uid":1219238,"ip_address":"美国","ucode":"55258F95874BF4","user_header":"https://static001.geekbang.org/account/avatar/00/12/9a/a6/29ac6f6a.jpg","comment_is_top":false,"comment_ctime":1680168397,"is_pvip":false,"replies":[{"id":135600,"content":"现在用ChatGPT可以当辅助，下一步就用GPT-5编程了。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680172539,"ip_address":"澳大利亚","comment_id":371676,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"问题：Spring Bean支持循环依赖吗\n\nFrom ChatGPT：Spring Bean支持循环依赖，但是只支持Singleton的setter循环依赖，即@Autowired形式，不支持构造器注入的循环依赖。如果存在循环依赖A -&gt; B -&gt; A，且都是通过构造函数依赖的，无法支持循环依赖。如果是prototype作用域的bean，则Spring是不支持相关的循环依赖的。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611564,"discussion_content":"现在用ChatGPT可以当辅助，下一步就用GPT-5编程了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680172539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371321,"user_name":"未聞花名","can_delete":false,"product_type":"c1","uid":2142672,"ip_address":"北京","ucode":"8BE87AC2CEA286","user_header":"https://static001.geekbang.org/account/avatar/00/20/b1/d0/8c94d49e.jpg","comment_is_top":false,"comment_ctime":1679798664,"is_pvip":false,"replies":[{"id":135500,"content":"这是一个上下文的配置项，可以在启动的时候立即refresh()。这样就可以扩展到别的时序再此refresh()。只不过MiniSpring没有事贤那种场景。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679916210,"ip_address":"澳大利亚","comment_id":371321,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"构造器注入不能解决循环依赖，因为缺失bean，对象在实例化就会失败，setter方法可以成功在于先有对象，属性是循环依赖中对方的引用，可以是不完全赋值的对象，也就是文章中的毛坯。\n\npublic ClassPathXmlApplicationContext(String fileName, boolean isRefresh)\n老师，这里为什么要判断isRefresh，理论上容器只会启动一次吧，不太明白为什么这么设计。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611068,"discussion_content":"这是一个上下文的配置项，可以在启动的时候立即refresh()。这样就可以扩展到别的时序再此refresh()。只不过MiniSpring没有事贤那种场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679916210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371193,"user_name":"云韵","can_delete":false,"product_type":"c1","uid":1025622,"ip_address":"日本","ucode":"3DE26DBAAAEDE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/56/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1679627054,"is_pvip":false,"replies":[{"id":135426,"content":"应该是ioc3","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679656002,"ip_address":"澳大利亚","comment_id":371193,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"老师 这个代码对应分支是哪个 拉下代码来 没找到对应的分支","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610629,"discussion_content":"应该是ioc3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679656002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370795,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1679290539,"is_pvip":false,"replies":[{"id":135299,"content":"pValue是对简单参数的，如String，Int","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679310307,"ip_address":"澳大利亚","comment_id":370795,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"getBean那个地方，为什么要用pValue?xml 里对应的property 里只有type和ref没有value啊？有点不理解。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609955,"discussion_content":"pValue是对简单参数的，如String，Int","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679310307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370713,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1679127582,"is_pvip":false,"replies":[{"id":135272,"content":"按说都应该带上@Override，文稿中有时候为了排版会删掉一些非关键的，有时候是我没在意。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679222587,"ip_address":"澳大利亚","comment_id":370713,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"前几天看文章，今天看代码，有一个问题请老师指教：\n ioc2目录，有一个问题：\n接口BeanFactory中，有多个方法，其中方法getBean有红色下划线，提示“Overridden methods are not annotated with @Override”。\n类SimpleBeanFactory中，方法getBean有红色下划线，错误提示：“missing @Overrid annotation on getBean”。不过Test1.java中的main方法能正常运行。\n\n接口BeanFactory中有一个方法getType，此方法在SimpleBeanFactory中的实现函数加了@Override。\n请问：\n1 getType方法加了@Override，而getBean方法没有加，为什么？忘记加了吗？\n2 继承接口，实现接口中的方法，我记得是不用加@Override，现在提示错误，为什么？\n    是因为不同的JDK版本或编译器版本吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609808,"discussion_content":"按说都应该带上@Override，文稿中有时候为了排版会删掉一些非关键的，有时候是我没在意。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679222587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370699,"user_name":"浅行","can_delete":false,"product_type":"c1","uid":3567438,"ip_address":"山东","ucode":"E46560808902FC","user_header":"https://static001.geekbang.org/account/avatar/00/36/6f/4e/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1679119614,"is_pvip":false,"replies":[{"id":135257,"content":"是的是的，你这是在做扩展，很好。我前几年给某大学开小班讲这个的时候，就是把别的数据类型当成学生的扩展练习的。MiniSpring是一个原理性质的，它尽量往Spring框架上靠拢，目的是为了学习Spring，而不是做一个实际的Spring出来。三年前，学生们让我传到Github上去的时候，我特意加上了“For Learning”的说明。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679136501,"ip_address":"澳大利亚","comment_id":370699,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"```Java\n PropertyValue propertyValue = propertyValues.getPropertyValueList().get(i);                String pType = propertyValue.getType();                String pName = propertyValue.getName();                Object pValue = propertyValue.getValue();                Class&lt;?&gt;[] paramTypes = new Class&lt;?&gt;[1];               if (&quot;String&quot;.equals(pType) || &quot;java.lang.String&quot;.equals(pType)) {                    paramTypes[0] = String.class;                } else if (&quot;Integer&quot;.equals(pType) || &quot;java.lang.Integer&quot;.equals(pType)) {                    paramTypes[0] = Integer.class;                } else if (&quot;int&quot;.equals(pType)) {                    paramTypes[0] = int.class;                } else { &#47;&#47; 默认为string                    paramTypes[0] = String.class;                }                Object[] paramValues = new Object[1];                paramValues[0] = pValue;\n```\n这一段代码测试的时候发现，如果`AsServiceImpl`里面写了个set方法参数是Integer类型的，会报错`argument type mismatch`。 需要和构造器一样处理，每一种类型都要单独转换。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609711,"discussion_content":"是的是的，你这是在做扩展，很好。我前几年给某大学开小班讲这个的时候，就是把别的数据类型当成学生的扩展练习的。MiniSpring是一个原理性质的，它尽量往Spring框架上靠拢，目的是为了学习Spring，而不是做一个实际的Spring出来。三年前，学生们让我传到Github上去的时候，我特意加上了“For Learning”的说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679136501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370690,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1679111031,"is_pvip":false,"replies":[{"id":135275,"content":"纠结于术语的话，确实不是同一个概念，是不同的方向描述同一个事情。不过历史上，开始大家都叫IoC，这个叫法让新人莫名其妙，争论不休，最后大神Martin Fowler说叫DI吧，于是一锤定音。所以从这个历史过程，可以认为是一回事。我觉得不用纠结术语。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679222913,"ip_address":"澳大利亚","comment_id":370690,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"IoC等于“依赖注入”吗？从文中的描述，好像老师是认为这两个概念是一回事，是描述同一个东西，而且“依赖注入”比“IoC”更贴切。我很早以前学过这两个概念，当时好像是把这两个术语当做不同的概念来理解的。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609811,"discussion_content":"纠结于术语的话，确实不是同一个概念，是不同的方向描述同一个事情。不过历史上，开始大家都叫IoC，这个叫法让新人莫名其妙，争论不休，最后大神Martin Fowler说叫DI吧，于是一锤定音。所以从这个历史过程，可以认为是一回事。我觉得不用纠结术语。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679222913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2342711,"avatar":"https://static001.geekbang.org/account/avatar/00/23/bf/37/10f71592.jpg","nickname":"开车疾如风","note":"","ucode":"84B17E8FC5B0DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618639,"discussion_content":"IOC是目的，为了让程序员不再new对象，而是让框架给你，比较抽象；DI（依赖注入）是手段，对象都被动地接受属性的注入，是抽象的具体实现。\n因此，对于IOC抽象还有不同的实现，依赖查找（DL）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684402373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370650,"user_name":"BattleMan1994","can_delete":false,"product_type":"c1","uid":2446300,"ip_address":"浙江","ucode":"9529E03AE789B0","user_header":"https://static001.geekbang.org/account/avatar/00/25/53/dc/11615706.jpg","comment_is_top":false,"comment_ctime":1679054380,"is_pvip":true,"replies":[{"id":135261,"content":"这个缓存的问题，不用拘泥于名词术语，后面再回首章节我还有说到。我的做法跟Spring是一样的，只不过第三级缓存的实现，在Spring里面是一个factory产生的，我是直接创建的。\n其实解决循环依赖的问题，就是一个办法：把创建bean的过程分成两阶段，第一阶段是一个毛胚的bean，第二阶段补齐属性。所有的毛胚bean都是提前创建出来的，后面面对循环依赖的时候，拿到的是这个提前准备好的毛胚bean。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679137045,"ip_address":"澳大利亚","comment_id":370650,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"为什么老师这里用一个缓存就可以解决循环依赖，而Spring却要用三级缓存呢？看很多博客都有点似懂非懂","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609715,"discussion_content":"这个缓存的问题，不用拘泥于名词术语，后面再回首章节我还有说到。我的做法跟Spring是一样的，只不过第三级缓存的实现，在Spring里面是一个factory产生的，我是直接创建的。\n其实解决循环依赖的问题，就是一个办法：把创建bean的过程分成两阶段，第一阶段是一个毛胚的bean，第二阶段补齐属性。所有的毛胚bean都是提前创建出来的，后面面对循环依赖的时候，拿到的是这个提前准备好的毛胚bean。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1679137045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","nickname":"每天晒白牙","note":"","ucode":"A1B102CD933DEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609671,"discussion_content":"在Spring中，当两个或更多个bean之间存在循环依赖关系时，Spring会使用三级缓存机制来解决这个问题。\n\n三级缓存机制包括以下三个缓存：\n\n1. singletonObjects：用于存储完全创建好的单例bean实例。\n\n2. earlySingletonObjects：用于存储早期创建但未完成初始化的单例bean实例。\n\n3. singletonFactories：用于存储创建单例bean实例的工厂对象。\n\n当Spring发现两个或更多个bean之间存在循环依赖关系时，它会将其中一个bean创建的过程中尚未完成的实例放入earlySingletonObjects缓存中，然后将创建该bean的工厂对象放入singletonFactories缓存中。接着，Spring会暂停当前bean的创建过程，去创建它所依赖的bean。当依赖的bean创建完成后，Spring会将其放入singletonObjects缓存中，并使用它来完成当前bean的创建过程。在创建当前bean的过程中，如果发现它还依赖其他的bean，Spring会重复上述过程，直到所有bean的创建过程都完成为止。\n\n需要注意的是，当使用构造函数注入方式时，循环依赖是无法解决的。因为在创建bean时，必须先创建它所依赖的bean实例，而构造函数注入方式需要在创建bean实例时就将依赖的bean实例传入构造函数中。如果依赖的bean实例尚未创建完成，就无法将其传入构造函数中，从而导致循环依赖无法解决。此时，可以考虑使用setter注入方式来解决循环依赖问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679095089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","nickname":"每天晒白牙","note":"","ucode":"A1B102CD933DEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609670,"discussion_content":"老师这里用了两个缓存，spring用了三个缓存\n1. singletonObjects：用于存储完全创建好的单例bean实例。\n\n2. earlySingletonObjects：用于存储早期创建但未完成初始化的单例bean实例。\n\n3. singletonFactories：用于存储创建单例bean实例的工厂对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679095067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370611,"user_name":"Geek_5d0074","can_delete":false,"product_type":"c1","uid":3223762,"ip_address":"江西","ucode":"C2242E29649529","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6mTy6lgnhkKbaWfs1s0siazVLQFnNmU0YLsRsxyC84aoFP5icuo22qricS62EiaibmVdplmtPbwryHHTA/132","comment_is_top":false,"comment_ctime":1679024587,"is_pvip":false,"replies":[{"id":135240,"content":"我这个应该讲明白了吧？","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679047759,"ip_address":"澳大利亚","comment_id":370611,"utype":1}],"discussion_count":6,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"Spring中的循环依赖，实际工作中真的会用到吗？好多面试题都说这个，但是没有一个能讲明白。每个答案都不同","like_count":0,"discussions":[{"author":{"id":1435389,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e6/fd/9f1c9398.jpg","nickname":"陈 yi 豪","note":"","ucode":"BFBFCF8768A0B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609583,"discussion_content":"1.在实际工作中，基本没人关注Spring是如何处理循环依赖的。这种问题只会出现在面试八股文中。\n2.在实际项目中，服务之间确实有可能出现循环依赖。\n  比如有可能出现这种情况：【订单服务】-&gt;【商品服务】-&gt;【库存服务】-&gt;【财务服务】-&gt;【订单服务】\n3.当业务层面出现循环依赖，通常问题不会暴露，Spring会默默地处理掉，bean还是正常创建，属性还是成功注入，所以一般情况下都不会去关注。\n4.理论上，循环依赖被视作一种“坏味道”，意味着系统设计有问题。因此Spring官方其实更推荐通过构造函数注入，默认情况这种方式不允许循环依赖，系统一启动就会报错并提示循环依赖。这样可以及早暴露问题，及时修改。\n5.但实际工作中，用得最多的注入方式还是Filed注入，要面对的代码可能还是个年代久远的屎山，也许最初的版本是没有问题的，但是经历不知道多少轮迭代之后，终于在某个版本，循环依赖闭环了。此时此刻，牵一发而动全身，不是普通搬砖人能轻易撼动的，反正系统又不是运行不起来，那就只当无事发生了😥\n\n总结：如果真的想在业务层面避免循环依赖，就尽可能用构造函数注入，早发现早处理。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1679039223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3567438,"avatar":"https://static001.geekbang.org/account/avatar/00/36/6f/4e/791d0f5e.jpg","nickname":"浅行","note":"","ucode":"E46560808902FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1435389,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e6/fd/9f1c9398.jpg","nickname":"陈 yi 豪","note":"","ucode":"BFBFCF8768A0B0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609702,"discussion_content":"同样也说明了重构的重要性，不能一味的只新增代码，新增功能。每次新增的时候能重构就重构，避免山上堆山，最终就炸了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679129541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609583,"ip_address":"山东","group_id":0},"score":609702,"extra":""}]},{"author":{"id":2882763,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/fc/cb/9e7f075c.jpg","nickname":"一滴水的波浪","note":"","ucode":"B88A25C2C87B87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609721,"discussion_content":"spring后来的版本默认不支持循环依赖的，也就是不鼓励有相互依赖这种系统设计。\n有时候面试遇到这样的问题，也不奇怪，有些面试官喜欢通过这种问题来考察候选人的知识面，不过我觉得这种问题算不上高阶问题，属于是非题，真正的高阶问题应该是考察逻辑能力和思考能力。 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679140467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609608,"discussion_content":"我这个应该讲明白了吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679047759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3223762,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6mTy6lgnhkKbaWfs1s0siazVLQFnNmU0YLsRsxyC84aoFP5icuo22qricS62EiaibmVdplmtPbwryHHTA/132","nickname":"Geek_5d0074","note":"","ucode":"C2242E29649529","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609821,"discussion_content":"知道了，我也遇到过，SpringBoot2.7.x版本，默认不支持循环依赖，如果有，启动会报错。虽然实际工作中，很少遇到循环依赖，但是有的半桶水面试官会按照八股文去面试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679229702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江西","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1675789,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/0d/849760e3.jpg","nickname":"Alex","note":"","ucode":"B022989B4C0ACA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3223762,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6mTy6lgnhkKbaWfs1s0siazVLQFnNmU0YLsRsxyC84aoFP5icuo22qricS62EiaibmVdplmtPbwryHHTA/132","nickname":"Geek_5d0074","note":"","ucode":"C2242E29649529","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634640,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703759790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609821,"ip_address":"甘肃","group_id":0},"score":634640,"extra":""}]}]},{"had_liked":false,"id":396528,"user_name":"读多多","can_delete":false,"product_type":"c1","uid":2559052,"ip_address":"吉林","ucode":"DF0ECE6A37DCB2","user_header":"https://static001.geekbang.org/account/avatar/00/27/0c/4c/2bbb7c9e.jpg","comment_is_top":false,"comment_ctime":1734833098,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"有个问题，按照这样执行构造器方式注入时，xml的构造器参数的顺序必须要和构造器的参数顺序一致吧？","like_count":0},{"had_liked":false,"id":390934,"user_name":"楚风","can_delete":false,"product_type":"c1","uid":3896587,"ip_address":"新加坡","ucode":"20462A9F3523B8","user_header":"https://static001.geekbang.org/account/avatar/00/3b/75/0b/8a22f70d.jpg","comment_is_top":false,"comment_ctime":1716795001,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"在本地课程的Demo工程中存在两个问题：\n1. 依赖问题。即：ABean 依赖BBean, 但是在xml中优先配置的是ABean,则存在报错!\n2. 循环依赖问题。即： ABean依赖BBean, 但是BBean又依赖ABean, 同样会报错!\n\n不过解决的方法都殊途同归。只需要在原有Demo的基础上做一点点小的改动即可! (改动思路如本文中所描述的，优先构造毛坯实例，再对该实例中的Property属性进行初始化即可)\n\n改动点如下：\n1. 屏蔽SimpleBeanFactory::registerBeanDefinition()方法中对createBean()方法的调用, 其registerBeanDefinition()方法仅实现本方法应该实现的内容,即BeanDefinition的注册;\n\n2. 修改SimpleBeanFactory::createBean(), 使其依次按照如下步骤进行：\n     1) 调用doCreateBean() 创建毛坯实例;\n     2) 从BeanDefinition中获取该Bean的dependsOn(依赖Bean), 并依次创建依赖Bean的毛坯实例;\n     3) 调用handleProperties()方法对毛坯实例的Property属性进行初始化;\n\n说明：上面方案并不能解决通过构造函数进行子对象(依赖Bean)的初始化的场景!!!","like_count":0},{"had_liked":false,"id":390717,"user_name":"edward","can_delete":false,"product_type":"c1","uid":1604798,"ip_address":"湖南","ucode":"09F7A5B8D2E7BD","user_header":"","comment_is_top":false,"comment_ctime":1716097773,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"请问老师 构造器参数和属性参数中的Integer和int这2种类型可以不区分 一起处理吗？","like_count":0},{"had_liked":false,"id":374898,"user_name":"Geek_7jwpfc","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"湖南","ucode":"CBCEA76E9EF33B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","comment_is_top":false,"comment_ctime":1684608099,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100536701,"comment_content":" BaseBaseService这个类，如果属性是Aservice，是一个接口的话，会在SimpleBeanFactory#handleProperties()的method = clz.getMethod(methodName, paramTypes)这行，改成实际的类就行; \n不过不算什么大问题，这门课重点是spring的思路；","like_count":0}]}