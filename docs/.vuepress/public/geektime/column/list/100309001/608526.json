{"id":608526,"title":"17｜业务脚本：为什么说可编程订阅式缓存服务更有用？","content":"<p>你好，我是徐长龙。</p><p>我们已经习惯了使用缓存集群对数据做缓存，但是这种常见的内存缓存服务有很多不方便的地方，比如集群会独占大量的内存、不能原子修改缓存的某一个字段、多次通讯有网络损耗。</p><p>很多时候我们获取数据并不需要全部字段，但因为缓存不支持筛选，批量获取数据的场景下性能就会下降很多。这些问题在读多写多的场景下，会更加明显。</p><p>有什么方式能够解决这些问题呢？这节课，我就带你了解另外一种有趣的数据缓存方式——可编程订阅式缓存服务。学完今天的内容，相信你会对缓存服务如何做产生新的思考。</p><h2>缓存即服务</h2><p>可编程订阅式缓存服务的意思是，我们可以自行实现一个数据缓存服务直接提供给业务服务使用，这种实现能够根据业务的需要，主动缓存数据并提供一些数据整理和计算的服务。</p><p>自实现的数据缓存服务虽然繁琐，但同时也有很多优势，除去吞吐能力的提升，我们还可以实现更多有趣的定制功能，还有更好的计算能力，甚至可以让我们的缓存直接对外提供基础数据的查询服务。</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/f3/effe5afb3ac029f5c21d94d9b2d2a2f3.jpg?wh=1920x1048\" alt=\"图片\" title=\"自实现缓存功能结构图\"></p><p>上图是一个自实现的缓存功能结构，可以说这种缓存的性能和效果更好，这是因为它对数据的处理方式跟传统模式不同。</p><p>传统模式下，缓存服务不会对数据做任何加工，保存的是系列化的字符串，大部分的数据无法直接修改。当我们使用这种缓存对外进行服务时，业务服务需要将所有数据取出到本地内存，然后进行遍历加工方可使用。</p><!-- [[[read_end]]] --><p>而可编程缓存可以把数据结构化地存在map中，相比传统模式序列化的字符串，更节省内存。</p><p>更方便的是，我们的服务无需再从其他服务取数据来做计算，这样会节省大量网络交互耗时，适合用在实时要求极高的场景里。如果我们的热数据量很大，可以结合RocksDB等嵌入式引擎，用有限的内存提供大量数据的服务。</p><p>除了常规的数据缓存服务外，可编程缓存还支持缓存数据的筛选过滤、统计计算、查询、分片、数据拼合。关于查询服务,我补充说明一下，对外的服务建议通过类似Redis的简单文本协议提供服务，这样会比HTTP协议性能会更好。</p><h2>Lua脚本引擎</h2><p>虽然缓存提供业务服务能提高业务灵活度，但是这种方式也有很多缺点，<strong>最大的缺点就是业务修改后，我们需要重启服务才能够更新我们的逻辑</strong>。由于内存中保存了大量的数据，重启一次数据就需要繁琐的预热，同步代价很大。</p><p>为此，我们需要给设计再次做个升级。这种情况下，lua脚本引擎是个不错的选择。lua是一个小巧的嵌入式脚本语言，通过它可以实现一个高性能、可热更新的脚本服务，从而和嵌入的服务高效灵活地互动。</p><p>我画了一张示意图，描述了如何通过lua脚本来具体实现<strong>可编程缓存服务</strong>：</p><p><img src=\"https://static001.geekbang.org/resource/image/29/4b/29c973d1c3f80690a97a327966f6b24b.jpg?wh=1920x1237\" alt=\"图片\" title=\"可编程缓存服务结构图\"></p><p>如上图所示，可以看到我们提供了Kafka消费、周期任务管理、内存缓存、多种数据格式支持、多种数据驱动适配这些服务。不仅仅如此，为了减少由于逻辑变更导致的服务经常重启的情况，我们还以性能损耗为代价，在缓存服务里嵌入了lua脚本引擎，借此实现动态更新业务的逻辑。</p><p>lua引擎使用起来很方便，我们结合后面这个实现例子看一看，这是一个Go语言写的嵌入lua实现，代码如下所示：</p><pre><code class=\"language-go\">package main\n\nimport \"github.com/yuin/gopher-lua\"\n\n// VarChange 用于被lua调用的函数\nfunc VarChange(L *lua.LState) int {\n   lv := L.ToInt(1)            //获取调用函数的第一个参数，并且转成int\n   L.Push(lua.LNumber(lv * 2)) //将参数内容直接x2，并返回结果给lua\n   return 1                    //返回结果参数个数\n}\n\nfunc main() {\n   L := lua.NewState() //新lua线程\n   defer L.Close() //程序执行完毕自动回收\n   \n   // 注册lua脚本可调用函数\n   // 在lua内调用varChange函数会调用这里注册的Go函数 VarChange\n   L.SetGlobal(\"varChange\", L.NewFunction(VarChange))\n   \n   //直接加载lua脚本\n   //脚本内容为：\n   // print \"hello world\"\n   // print(varChange(20)) # lua中调用go声明的函数\n   if err := L.DoFile(\"hello.lua\"); err != nil {\n      panic(err)\n   }\n   \n  // 或者直接执行string内容\n   if err := L.DoString(`print(\"hello\")`); err != nil {\n\t  panic(err)\n   }\n}\n\n// 执行后输出结果：\n//hello world\n//40\n//hello\n</code></pre><p>从这个例子里我们可以看出，lua引擎是可以直接执行lua脚本的，而lua脚本可以和Golang所有注册的函数相互调用，并且可以相互传递交换变量。</p><p>回想一下，我们做的是数据缓存服务，所以需要让lua能够获取修改服务内的缓存数据，那么，lua是如何和嵌入的语言交换数据的呢？我们来看看两者相互调用交换的例子：</p><pre><code class=\"language-go\">package main\n\nimport (\n   \"fmt\"\n   \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n   L := lua.NewState()\n   defer L.Close()\n   //加载脚本\n   err := L.DoFile(\"vardouble.lua\")\n   if err != nil {\n      panic(err)\n   }\n   // 调用lua脚本内函数\n   err = L.CallByParam(lua.P{\n      Fn:      L.GetGlobal(\"varDouble\"), //指定要调用的函数名\n      NRet:    1,                        // 指定返回值数量\n      Protect: true,                     // 错误返回error\n   }, lua.LNumber(15)) //支持多个参数\n   if err != nil {\n      panic(err)\n   }\n   //获取返回结果\n   ret := L.Get(-1)\n   //清理下，等待下次用\n   L.Pop(1)\n   \n   //结果转下类型，方便输出\n   res, ok := ret.(lua.LNumber)\n   if !ok {\n      panic(\"unexpected result\")\n   }\n   fmt.Println(res.String())\n}\n\n// 输出结果：\n// 30\n</code></pre><p>其中vardouble.lua内容为：</p><pre><code class=\"language-lua\">function varDouble(n)\n    return n * 2\nend\n</code></pre><p>通过这个方式，lua和Golang就可以相互交换数据和相互调用。对于这种缓存服务普遍要求性能很好，这时我们可以统一管理加载过lua的脚本及LState脚本对象的实例对象池，这样会更加方便，不用每调用一次lua就加载一次脚本，方便获取和使用多线程、多协程。</p><h2>Lua脚本统一管理</h2><p>通过前面的讲解我们可以发现，在实际使用时，lua会在内存中运行很多实例。为了更好管理并提高效率，我们最好用一个脚本管理系统来管理所有lua的实运行例子，以此实现脚本的统一更新、编译缓存、资源调度和控制单例。</p><p>lua脚本本身是单线程的，但是它十分轻量，一个实例大概是144kb的内存损耗，有些服务平时能跑成百上千个lua实例。</p><p>为了提高服务的并行处理能力，我们可以启动多协程，让每个协程独立运行一个lua线程。为此，gopher-lua库提供了一个类似线程池的实现，通过这个方式我们不需要频繁地创建、关闭lua，官方例子具体如下：</p><pre><code class=\"language-go\">//保存lua的LState的池子\ntype lStatePool struct {\n    m     sync.Mutex\n    saved []*lua.LState\n}\n// 获取一个LState\nfunc (pl *lStatePool) Get() *lua.LState {\n    pl.m.Lock()\n    defer pl.m.Unlock()\n    n := len(pl.saved)\n    if n == 0 {\n        return pl.New()\n    }\n    x := pl.saved[n-1]\n    pl.saved = pl.saved[0 : n-1]\n    return x\n}\n\n//新建一个LState\nfunc (pl *lStatePool) New() *lua.LState {\n    L := lua.NewState()\n    // setting the L up here.\n    // load scripts, set global variables, share channels, etc...\n    //在这里我们可以做一些初始化\n    return L\n}\n\n//把Lstate对象放回到池中，方便下次使用\nfunc (pl *lStatePool) Put(L *lua.LState) {\n    pl.m.Lock()\n    defer pl.m.Unlock()\n    pl.saved = append(pl.saved, L)\n}\n\n//释放所有句柄\nfunc (pl *lStatePool) Shutdown() {\n    for _, L := range pl.saved {\n        L.Close()\n    }\n}\n// Global LState pool\nvar luaPool = &amp;lStatePool{\n    saved: make([]*lua.LState, 0, 4),\n}\n\n//协程内运行的任务\nfunc MyWorker() {\n   //通过pool获取一个LState\n   L := luaPool.Get()\n   //任务执行完毕后，将LState放回pool\n   defer luaPool.Put(L)\n   // 这里可以用LState变量运行各种lua脚本任务\n   //例如 调用之前例子中的的varDouble函数\n   err = L.CallByParam(lua.P{\n      Fn:      L.GetGlobal(\"varDouble\"), //指定要调用的函数名\n      NRet:    1,                        // 指定返回值数量\n      Protect: true,                     // 错误返回error\n   }, lua.LNumber(15)) //这里支持多个参数\n   if err != nil {\n      panic(err) //仅供演示用，实际生产不推荐用panic\n   }\n}\nfunc main() {\n    defer luaPool.Shutdown()\n    go MyWorker() // 启动一个协程\n    go MyWorker() // 启动另外一个协程\n    /* etc... */\n}\n</code></pre><p>通过这个方式我们可以预先创建一批LState，让它们加载好所有需要的lua脚本，当我们执行lua脚本时直接调用它们，即可对外服务，提高我们的资源复用率。</p><h2>变量的交互</h2><p>事实上我们的数据既可以保存在lua内，也可以保存在Go中，通过相互调用来获取对方的数据。个人习惯将数据放在Go中封装，供lua调用，主要是因为这样相对规范、比较好管理，毕竟脚本会有损耗。</p><p>前面提到过，我们会将一些数据用struct和map组合起来，对外提供数据服务。那么lua和Golang如何交换struct一类数据呢？</p><p>这里我选择了官方提供的例子，但额外加上了大量注释，帮助你理解这个交互过程。</p><pre><code class=\"language-go\">// go用于交换的 struct\ntype Person struct {\n    Name string\n}\n\n//为这个类型定义个类型名称\nconst luaPersonTypeName = \"person\"\n\n// 在LState对象中，声明这种类型，这个只会在初始化LState时执行一次\n// Registers my person type to given L.\nfunc registerPersonType(L *lua.LState) {\n    //在LState中声明这个类型\n    mt := L.NewTypeMetatable(luaPersonTypeName)\n    //指定 person 对应 类型type 标识\n    //这样 person在lua内就像一个 类声明\n    L.SetGlobal(\"person\", mt)\n    // static attributes\n    // 在lua中定义person的静态方法\n    // 这句声明后 lua中调用person.new即可调用go的newPerson方法\n    L.SetField(mt, \"new\", L.NewFunction(newPerson))\n    // person new后创建的实例，在lua中是table类型，你可以把table理解为lua内的对象\n    // 下面这句主要是给 table定义一组methods方法，可以在lua中调用\n    // personMethods是个map[string]LGFunction \n    // 用来告诉lua，method和go函数的对应关系\n    L.SetField(mt, \"__index\", L.SetFuncs(L.NewTable(), personMethods))\n}\n// person 实例对象的所有method\nvar personMethods = map[string]lua.LGFunction{\n    \"name\": personGetSetName,\n}\n// Constructor\n// lua内调用person.new时，会触发这个go函数\nfunc newPerson(L *lua.LState) int {\n    //初始化go struct 对象 并设置name为 1\n    person := &amp;Person{L.CheckString(1)}\n    // 创建一个lua userdata对象用于传递数据\n    // 一般 userdata包装的都是go的struct，table是lua自己的对象\n    ud := L.NewUserData() \n    ud.Value = person //将 go struct 放入对象中\n    // 设置这个lua对象类型为 person type\n    L.SetMetatable(ud, L.GetTypeMetatable(luaPersonTypeName))\n    // 将创建对象返回给lua\n    L.Push(ud)\n    //告诉lua脚本，返回了数据个数\n    return 1\n}\n// Checks whether the first lua argument is a *LUserData \n// with *Person and returns this *Person.\nfunc checkPerson(L *lua.LState) *Person {\n    //检测第一个参数是否为其他语言传递的userdata\n    ud := L.CheckUserData(1)\n    // 检测是否转换成功\n    if v, ok := ud.Value.(*Person); ok {\n        return v\n    }\n    L.ArgError(1, \"person expected\")\n    return nil\n}\n// Getter and setter for the Person#Name\nfunc personGetSetName(L *lua.LState) int {\n    // 检测第一个栈，如果就只有一个那么就只有修改值参数\n    p := checkPerson(L)\n    if L.GetTop() == 2 {\n        //如果栈里面是两个，那么第二个是修改值参数\n        p.Name = L.CheckString(2)\n        //代表什么数据不返回，只是修改数据\n        return 0\n    }\n    //如果只有一个在栈，那么是获取name值操作，返回结果\n    L.Push(lua.LString(p.Name))\n    \n    //告诉会返回一个参数\n    return 1\n}\nfunc main() {\n    // 创建一个lua LState\n    L := lua.NewState()\n    defer L.Close()\n    \n    //初始化 注册\n    registerPersonType(L)\n    // 执行lua脚本\n    if err := L.DoString(`\n        //创建person，并设置他的名字\n        p = person.new(\"Steven\")\n        print(p:name()) -- \"Steven\"\n        //修改他的名字\n        p:name(\"Nico\")\n        print(p:name()) -- \"Nico\"\n    `); err != nil {\n        panic(err)\n    }\n}\n</code></pre><p>可以看到，我们通过lua脚本引擎就能很方便地完成相互调用和交换数据，从而实现很多实用的功能，甚至可以用少量数据直接写成lua脚本的方式来加载服务。<br>\n另外，gopher-lua还提供了模块功能，帮助我们更好地管理脚本和代码，有兴趣的话可以自行深入，参考资料在<a href=\"https://github.com/yuin/gopher-lua\">这里</a>。</p><h2>缓存预热与数据来源</h2><p>了解了lua后，我们再看看服务如何加载数据。服务启动时，我们需要将数据缓存加载到缓存中，做<strong>缓存预热</strong>，<strong>待数据全部加载完毕后，再开放对外的API端口对外提供服务</strong>。</p><p>加载过程中如果用上了lua脚本，就可以在服务启动时对不同格式的数据做适配加工，这样做也能让数据来源更加丰富。</p><p>常见的数据来源是大数据挖掘周期生成的全量数据离线文件，通过NFS或HDFS挂载定期刷新、加载最新的文件。这个方式适合数据量大且更新缓慢的数据，缺点则是加载时需要整理数据，如果情况足够复杂，800M大小的数据要花1～10分钟方能加载完毕。</p><p>除了使用文件方式外，我们也可以在程序启动后扫数据表恢复数据，但这么做数据库要承受压力，建议使用专用的从库。但相对磁盘离线文件的方式，<strong>这种方式加载速度更慢</strong>。</p><p>上面两种方式加载都有些慢，我们还可以将 <a href=\"http://rocksdb.org/\">RocksDB</a> 嵌入到进程中，这样做可以大幅度提高我们的数据存储容量，实现内存磁盘高性能读取和写入。不过代价就是相对会降低一些查询性能。</p><p>RocksDB的数据可以通过大数据生成RocksDB格式的数据库文件，拷贝给我们的服务直接加载。这种方式可以大大减少系统启动中整理、加载数据的时间，实现更多的数据查询。</p><p>另外，如果我们对于本地有关系数据查询需求，也可以嵌入 <a href=\"https://www.sqlite.org/docs.html\">SQLite</a> 引擎，通过这个引擎可以做各种关系数据查询，SQLite的数据的生成也可以通过工具提前生成，给我们服务直接使用。但你要注意这个数据库不要超过10w条数据，否则很可能导致服务卡顿。</p><p>最后，对于离线文件加载，最好做一个<strong>CheckSum</strong>一类的文件，用来在加载文件之前检查文件的完整性。由于我们使用的是网络磁盘，不太确定这个文件是否正在拷贝中，需要一些小技巧保证我们的数据完整性，最粗暴的方式就是每次拷贝完毕后生成一个同名的文件，内部记录一下它的CheckSum，方便我们加载前校验。</p><p>离线文件能够帮助我们快速实现多个节点的数据共享和统一，如果我们需要多个节点数据保持最终一致性，就需要通过离线+同步订阅方式来实现数据的同步。</p><h2>订阅式数据同步及启动同步</h2><p>那么，我们的数据是如何同步更新的呢？</p><p>正常情况下，我们的数据来源于多个基础数据服务。如果想实时同步数据的更改，我们一般会通过订阅binlog将变更信息同步到Kafka，再通过Kafka的分组消费来通知分布在不同集群中的缓存。</p><p>收到消息变更的服务会触发lua脚本，对数据进行同步更新。通过lua我们可以触发式同步更新其他相关缓存，比如用户购买一个商品，我们要同步刷新他的积分、订单和消息列表个数。</p><h2>周期任务</h2><p>提到任务管理，不得不提一下周期任务。周期任务一般用于刷新数据的统计，我们通过周期任务结合lua自定义逻辑脚本，就能实现定期统计，这给我们提供了更多的便利。</p><p>定期执行任务或延迟刷新的过程中，常见的方式是用<strong>时间轮来</strong>管理任务，用这个方式可以把定时任务做成事件触发，这样能轻松地管理内存中的待触发任务列表，从而并行多个周期任务，无需使用sleep循环方式不断查询。对时间轮感兴趣的话，你可以点击<a href=\"https://github.com/jhunters/timewheel\">这里</a>查看具体实现。</p><p>另外，前面提到我们的很多数据都是通过离线文件做批量更新的，如果是一小时更新一次，那么一小时内新更新的数据就需要同步。</p><p>一般要这样处理：在我们服务启动加载的离线文件时，保存离线文件生成的时间，通过这个时间来过滤数据更新队列中的消息，等到我们的队列任务进度追到当前时间附近时，再开启对外数据的服务。</p><h2>总结</h2><p>读多写多的服务中，实时交互类服务非常多，对数据的实时性要求也很高，用集中型缓存很难满足服务所需。为此，行业里多数会通过服务内存数据来提供实时交互服务，但这么做维护起来十分麻烦，重启后需要恢复数据。为了实现业务逻辑无重启的更新，行业里通常会使用内嵌脚本的热更新方案。</p><p>常见的通用脚本引擎是lua，这是一个十分流行且方便的脚本引擎，在行业中，很多知名游戏及服务都使用lua来实现高性能服务的定制化业务功能，比如Nginx、Redis等。</p><p>把lua和我们的定制化缓存服务结合起来，即可制作出很多强大的功能来应对不同的场景。由于lua十分节省内存，我们在进程中开启成千上万的lua小线程，甚至一个用户一个LState线程对客户端提供状态机一样的服务。</p><p>用上面的方法，再结合lua和静态语言交换数据相互调用，并配合上我们的任务管理以及各种数据驱动，就能完成一个几乎万能的缓存服务。推荐你在一些小项目中亲自实践一下，相信会让你从不同视角看待已经习惯的服务，这样会有更多收获。</p><h2>思考题</h2><p>如何让Go的协程访问一个LState保存的数据？</p><p>欢迎你在留言区与我交流讨论，我们下节课见！</p>","neighbors":{"left":{"article_title":"16｜本地缓存：用本地缓存做服务会遇到哪些坑？","id":607567},"right":{"article_title":"18｜流量拆分：如何通过架构设计缓解流量压力？","id":609716}},"comments":[{"had_liked":false,"id":387771,"user_name":"黄堃健","can_delete":false,"product_type":"c1","uid":2037522,"ip_address":"广东","ucode":"B4AD5250A41B3A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/YbUxEV3741vKZAiasOXggWucQbmicJwIjg3HDE58oyibYXbSop9QQFqZ7X6OhynDoo6rDHwzK8njSeJjN9hx3pJXg/132","comment_is_top":false,"comment_ctime":1708569550,"is_pvip":false,"replies":[{"id":141255,"content":"你好，堃健，目前我看到的都是内部缓存或者游戏服务端使用，可以关注一下这个 https:&#47;&#47;github.com&#47;yuin&#47;gopher-lua 项目看看是否有帮助","user_name":"作者回复","user_name_real":"编辑","uid":1004527,"ctime":1708676534,"ip_address":"北京","comment_id":387771,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"老师，有什么开源的go服务使用lua来做业务缓存。这样真正看看人家怎么玩，踩坑相对少很多","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637605,"discussion_content":"你好，堃健，目前我看到的都是内部缓存或者游戏服务端使用，可以关注一下这个 https://github.com/yuin/gopher-lua 项目看看是否有帮助","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708676534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370423,"user_name":"普通熊猫 ଘ(੭ˊ꒳​ˋ)੭✧","can_delete":false,"product_type":"c1","uid":1196531,"ip_address":"北京","ucode":"7FEF9C72B4801B","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/f3/8bca4aba.jpg","comment_is_top":false,"comment_ctime":1678800504,"is_pvip":false,"replies":[{"id":135809,"content":"你好，熊猫，lua在redis中使用起来很不简单，实际操作后就会有深切的感受，同时需要lua支持队列等功能，具体有很多事情需要做。这种实现已经从数据层服务变成了应用层，所以有些地方总是会难受一些。","user_name":"作者回复","user_name_real":"编辑","uid":1004527,"ctime":1680774556,"ip_address":"北京","comment_id":370423,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"与其在golang的项目中引进redis，然后对外提供类似于redis的简单协议，并且自己实现一套内存数据的加载逻辑，为什么不考虑直接用lua订制redis？会不会更简单一些😂","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612545,"discussion_content":"你好，熊猫，lua在redis中使用起来很不简单，实际操作后就会有深切的感受，同时需要lua支持队列等功能，具体有很多事情需要做。这种实现已经从数据层服务变成了应用层，所以有些地方总是会难受一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680774556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368182,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"浙江","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1675991019,"is_pvip":false,"replies":[{"id":134060,"content":"你好，zhou，第一个问题：结构化数据确实比序列化后省空间（比如int和字符串保存的int字节大小不一样）同时有内存对齐优势，map只是个容器方便做hash查询对象使用，json是个序列化格式，他会把我们的数据二进制翻译成字符串方便传输结构化数据。第二个问题，使用外缓存缺点是有网络RTT延迟5ms至少，本地内存比网络速度快 能到纳秒微秒级别，另外，这里主要是你不知道什么数据什么时候有更新，所以只能每次请求去拉取才可以达到数据实时生效","user_name":"作者回复","user_name_real":"编辑","uid":1004527,"ctime":1675997347,"ip_address":"北京","comment_id":368182,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"问题1、文中的可编程缓存可以把数据结构化存在map中，相比传统模式序列话串要省内存。我想问下有些对象格式是无法存在map格式中的，另外map的方式跟json的方式存储大小上应该没有很大区别。\n问题2、我是java语言，用redis缓存数据，我认为业务缓存修改后实时生效是可以直接重新拉去即可。","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603162,"discussion_content":"你好，zhou，第一个问题：结构化数据确实比序列化后省空间（比如int和字符串保存的int字节大小不一样）同时有内存对齐优势，map只是个容器方便做hash查询对象使用，json是个序列化格式，他会把我们的数据二进制翻译成字符串方便传输结构化数据。第二个问题，使用外缓存缺点是有网络RTT延迟5ms至少，本地内存比网络速度快 能到纳秒微秒级别，另外，这里主要是你不知道什么数据什么时候有更新，所以只能每次请求去拉取才可以达到数据实时生效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675997347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037522,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/YbUxEV3741vKZAiasOXggWucQbmicJwIjg3HDE58oyibYXbSop9QQFqZ7X6OhynDoo6rDHwzK8njSeJjN9hx3pJXg/132","nickname":"黄堃健","note":"","ucode":"B4AD5250A41B3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637822,"discussion_content":"哥，有哪些对象不能存在map，除了slice等对象几乎可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1709002183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}