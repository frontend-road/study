{"id":42156,"title":"31 | sync.WaitGroup和sync.Once","content":"<p>我们在前几次讲的互斥锁、条件变量和原子操作都是最基本重要的同步工具。在Go语言中，除了通道之外，它们也算是最为常用的并发安全工具了。</p><p>说到通道，不知道你想过没有，之前在一些场合下里，我们使用通道的方式看起来都似乎有些蹩脚。</p><p>比如：<strong>声明一个通道，使它的容量与我们手动启用的goroutine的数量相同，之后再利用这个通道，让主goroutine等待其他goroutine的运行结束。</strong></p><p>这一步更具体地说就是：让其他的goroutine在运行结束之前，都向这个通道发送一个元素值，并且，让主goroutine在最后从这个通道中接收元素值，接收的次数需要与其他的goroutine的数量相同。</p><p>这就是下面的<code>coordinateWithChan</code>函数展示的多goroutine协作流程。</p><pre><code>func coordinateWithChan() {\n sign := make(chan struct{}, 2)\n num := int32(0)\n fmt.Printf(&quot;The number: %d [with chan struct{}]\\n&quot;, num)\n max := int32(10)\n go addNum(&amp;num, 1, max, func() {\n  sign &lt;- struct{}{}\n })\n go addNum(&amp;num, 2, max, func() {\n  sign &lt;- struct{}{}\n })\n &lt;-sign\n &lt;-sign\n}\n</code></pre><p>其中的<code>addNum</code>函数的声明在demo65.go文件中。<code>addNum</code>函数会把它接受的最后一个参数值作为其中的<code>defer</code>函数。</p><p>我手动启用的两个goroutine都会调用<code>addNum</code>函数，而它们传给该函数的最后一个参数值（也就是那个既无参数声明，也无结果声明的函数）都只会做一件事情，那就是向通道<code>sign</code>发送一个元素值。</p><!-- [[[read_end]]] --><p>看到<code>coordinateWithChan</code>函数中最后的那两行代码了吗？重复的两个接收表达式<code>&lt;-sign</code>，是不是看起来很丑陋？</p><h2>前导内容：<code>sync</code>包的<code>WaitGroup</code>类型</h2><p>其实，在这种应用场景下，我们可以选用另外一个同步工具，即：<code>sync</code>包的<code>WaitGroup</code>类型。它比通道更加适合实现这种一对多的goroutine协作流程。</p><p><code>sync.WaitGroup</code>类型（以下简称<code>WaitGroup</code>类型）是开箱即用的，也是并发安全的。同时，与我们前面讨论的几个同步工具一样，它一旦被真正使用就不能被复制了。</p><p><code>WaitGroup</code>类型拥有三个指针方法：<code>Add</code>、<code>Done</code>和<code>Wait</code>。你可以想象该类型中有一个计数器，它的默认值是<code>0</code>。我们可以通过调用该类型值的<code>Add</code>方法来增加，或者减少这个计数器的值。</p><p>一般情况下，我会用这个方法来记录需要等待的goroutine的数量。相对应的，这个类型的<code>Done</code>方法，用于对其所属值中计数器的值进行减一操作。我们可以在需要等待的goroutine中，通过<code>defer</code>语句调用它。</p><p>而此类型的<code>Wait</code>方法的功能是，阻塞当前的goroutine，直到其所属值中的计数器归零。如果在该方法被调用的时候，那个计数器的值就是<code>0</code>，那么它将不会做任何事情。</p><p>你可能已经看出来了，<code>WaitGroup</code>类型的值（以下简称<code>WaitGroup</code>值）完全可以被用来替换<code>coordinateWithChan</code>函数中的通道<code>sign</code>。下面的<code>coordinateWithWaitGroup</code>函数就是它的改造版本。</p><pre><code>func coordinateWithWaitGroup() {\n var wg sync.WaitGroup\n wg.Add(2)\n num := int32(0)\n fmt.Printf(&quot;The number: %d [with sync.WaitGroup]\\n&quot;, num)\n max := int32(10)\n go addNum(&amp;num, 3, max, wg.Done)\n go addNum(&amp;num, 4, max, wg.Done)\n wg.Wait()\n}\n</code></pre><p>很明显，整体代码少了好几行，而且看起来也更加简洁了。这里我先声明了一个<code>WaitGroup</code>类型的变量<code>wg</code>。然后，我调用了它的<code>Add</code>方法并传入了<code>2</code>，因为我会在后面启用两个需要等待的goroutine。</p><p>由于<code>wg</code>变量的<code>Done</code>方法本身就是一个既无参数声明，也无结果声明的函数，所以我在<code>go</code>语句中调用<code>addNum</code>函数的时候，可以直接把该方法作为最后一个参数值传进去。</p><p>在<code>coordinateWithWaitGroup</code>函数的最后，我调用了<code>wg</code>的<code>Wait</code>方法。如此一来，该函数就可以等到那两个goroutine都运行结束之后，再结束执行了。</p><p>以上就是<code>WaitGroup</code>类型最典型的应用场景了。不过不能止步于此，对于这个类型，我们还是有必要再深入了解一下的。我们一起看下面的问题。</p><p><strong>问题：<code>sync.WaitGroup</code>类型值中计数器的值可以小于<code>0</code>吗？</strong></p><p>这里的典型回答是：不可以。</p><h2>问题解析</h2><p>为什么不可以呢，我们解析一下。<strong>之所以说<code>WaitGroup</code>值中计数器的值不能小于<code>0</code>，是因为这样会引发一个panic。</strong> 不适当地调用这类值的<code>Done</code>方法和<code>Add</code>方法都会如此。别忘了，我们在调用<code>Add</code>方法的时候是可以传入一个负数的。</p><p>实际上，导致<code>WaitGroup</code>值的方法抛出panic的原因不只这一种。</p><p>你需要知道，在我们声明了这样一个变量之后，应该首先根据需要等待的goroutine，或者其他事件的数量，调用它的<code>Add</code>方法，以使计数器的值大于<code>0</code>。这是确保我们能在后面正常地使用这类值的前提。</p><p>如果我们对它的<code>Add</code>方法的首次调用，与对它的<code>Wait</code>方法的调用是同时发起的，比如，在同时启用的两个goroutine中，分别调用这两个方法，<strong>那么就有可能会让这里的<code>Add</code>方法抛出一个panic。</strong></p><p>这种情况不太容易复现，也正因为如此，我们更应该予以重视。所以，虽然<code>WaitGroup</code>值本身并不需要初始化，但是尽早地增加其计数器的值，还是非常有必要的。</p><p>另外，你可能已经知道，<code>WaitGroup</code>值是可以被复用的，但需要保证其计数周期的完整性。这里的计数周期指的是这样一个过程：该值中的计数器值由<code>0</code>变为了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了<code>0</code>。</p><p>也就是说，只要计数器的值始于<code>0</code>又归为<code>0</code>，就可以被视为一个计数周期。在一个此类值的生命周期中，它可以经历任意多个计数周期。但是，只有在它走完当前的计数周期之后，才能够开始下一个计数周期。</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/8d/fac7dfa184053d2a95e121aa17141d8d.png?wh=1350*683\" alt=\"\"><br>\n（sync.WaitGroup的计数周期）</p><p>因此，也可以说，如果一个此类值的<code>Wait</code>方法在它的某个计数周期中被调用，那么就会立即阻塞当前的goroutine，直至这个计数周期完成。在这种情况下，该值的下一个计数周期，必须要等到这个<code>Wait</code>方法执行结束之后，才能够开始。</p><p>如果在一个此类值的<code>Wait</code>方法被执行期间，跨越了两个计数周期，<strong>那么就会引发一个panic。</strong></p><p>例如，在当前的goroutine因调用此类值的<code>Wait</code>方法，而被阻塞的时候，另一个goroutine调用了该值的<code>Done</code>方法，并使其计数器的值变为了<code>0</code>。</p><p>这会唤醒当前的goroutine，并使它试图继续执行<code>Wait</code>方法中其余的代码。但在这时，又有一个goroutine调用了它的<code>Add</code>方法，并让其计数器的值又从<code>0</code>变为了某个正整数。<strong>此时，这里的<code>Wait</code>方法就会立即抛出一个panic。</strong></p><p>纵观上述会引发panic的后两种情况，我们可以总结出这样一条关于<code>WaitGroup</code>值的使用禁忌，即：<strong>不要把增加其计数器值的操作和调用其<code>Wait</code>方法的代码，放在不同的goroutine中执行。换句话说，要杜绝对同一个<code>WaitGroup</code>值的两种操作的并发执行。</strong></p><p>除了第一种情况外，我们通常需要反复地实验，才能够让<code>WaitGroup</code>值的方法抛出panic。再次强调，虽然这不是每次都发生，但是在长期运行的程序中，这种情况发生的概率还是不小的，我们必须要重视它们。</p><p>如果你对复现这些异常情况感兴趣，那么可以参看<code>sync</code>代码包中的waitgroup_test.go文件。其中的名称以<code>TestWaitGroupMisuse</code>为前缀的测试函数，很好地展示了这些异常情况的发生条件。你可以模仿这些测试函数自己写一些测试代码，执行一下试试看。</p><h2>知识扩展</h2><h3>问题：<code>sync.Once</code>类型值的<code>Do</code>方法是怎么保证只执行参数函数一次的？</h3><p>与<code>sync.WaitGroup</code>类型一样，<code>sync.Once</code>类型（以下简称<code>Once</code>类型）也属于结构体类型，同样也是开箱即用和并发安全的。由于这个类型中包含了一个<code>sync.Mutex</code>类型的字段，所以，复制该类型的值也会导致功能的失效。</p><p><code>Once</code>类型的<code>Do</code>方法只接受一个参数，这个参数的类型必须是<code>func()</code>，即：无参数声明和结果声明的函数。</p><p>该方法的功能并不是对每一种参数函数都只执行一次，而是只执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数。</p><p>所以，如果你有多个只需要执行一次的函数，那么就应该为它们中的每一个都分配一个<code>sync.Once</code>类型的值（以下简称<code>Once</code>值）。</p><p><code>Once</code>类型中还有一个名叫<code>done</code>的<code>uint32</code>类型的字段。它的作用是记录其所属值的<code>Do</code>方法被调用的次数。不过，该字段的值只可能是<code>0</code>或者<code>1</code>。一旦<code>Do</code>方法的首次调用完成，它的值就会从<code>0</code>变为<code>1</code>。</p><p>你可能会问，既然<code>done</code>字段的值不是<code>0</code>就是<code>1</code>，那为什么还要使用需要四个字节的<code>uint32</code>类型呢？</p><p>原因很简单，因为对它的操作必须是“原子”的。<code>Do</code>方法在一开始就会通过调用<code>atomic.LoadUint32</code>函数来获取该字段的值，并且一旦发现该值为<code>1</code>，就会直接返回。这也初步保证了“<code>Do</code>方法，只会执行首次被调用时传入的函数”。</p><p>不过，单凭这样一个判断的保证是不够的。因为，如果有两个goroutine都调用了同一个新的<code>Once</code>值的<code>Do</code>方法，并且几乎同时执行到了其中的这个条件判断代码，那么它们就都会因判断结果为<code>false</code>，而继续执行<code>Do</code>方法中剩余的代码。</p><p>在这个条件判断之后，<code>Do</code>方法会立即锁定其所属值中的那个<code>sync.Mutex</code>类型的字段<code>m</code>。然后，它会在临界区中再次检查<code>done</code>字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把<code>done</code>的值变为<code>1</code>。</p><p>如果你熟悉GoF设计模式中的单例模式的话，那么肯定能看出来，这个<code>Do</code>方法的实现方式，与那个单例模式有很多相似之处。它们都会先在临界区之外，判断一次关键条件，若条件不满足则立即返回。这通常被称为<strong>“快路径”，或者叫做“快速失败路径”。</strong></p><p>如果条件满足，那么到了临界区中还要再对关键条件进行一次判断，这主要是为了更加严谨。这两次条件判断常被统称为（跨临界区的）“双重检查”。</p><p>由于进入临界区之前，肯定要锁定保护它的互斥锁<code>m</code>，显然会降低代码的执行速度，所以其中的第二次条件判断，以及后续的操作就被称为“慢路径”或者“常规路径”。</p><p>别看<code>Do</code>方法中的代码不多，但它却应用了一个很经典的编程范式。我们在Go语言及其标准库中，还能看到不少这个经典范式及它衍生版本的应用案例。</p><p><strong>下面我再来说说这个<code>Do</code>方法在功能方面的两个特点。</strong></p><p><strong>第一个特点</strong>，由于<code>Do</code>方法只会在参数函数执行结束之后把<code>done</code>字段的值变为<code>1</code>，因此，如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关goroutine的同时阻塞。</p><p>例如，有多个goroutine并发地调用了同一个<code>Once</code>值的<code>Do</code>方法，并且传入的函数都会一直执行而不结束。那么，这些goroutine就都会因调用了这个<code>Do</code>方法而阻塞。因为，除了那个抢先执行了参数函数的goroutine之外，其他的goroutine都会被阻塞在锁定该<code>Once</code>值的互斥锁<code>m</code>的那行代码上。</p><p><strong>第二个特点</strong>，<code>Do</code>方法在参数函数执行结束后，对<code>done</code>字段的赋值用的是原子操作，并且，这一操作是被挂在<code>defer</code>语句中的。因此，不论参数函数的执行会以怎样的方式结束，<code>done</code>字段的值都会变为<code>1</code>。</p><p>也就是说，即使这个参数函数没有执行成功（比如引发了一个panic），我们也无法使用同一个<code>Once</code>值重新执行它了。所以，如果你需要为参数函数的执行设定重试机制，那么就要考虑<code>Once</code>值的适时替换问题。</p><p>在很多时候，我们需要依据<code>Do</code>方法的这两个特点来设计与之相关的流程，以避免不必要的程序阻塞和功能缺失。</p><h2>总结</h2><p><code>sync</code>代码包的<code>WaitGroup</code>类型和<code>Once</code>类型都是非常易用的同步工具。它们都是开箱即用和并发安全的。</p><p>利用<code>WaitGroup</code>值，我们可以很方便地实现一对多的goroutine协作流程，即：一个分发子任务的goroutine，和多个执行子任务的goroutine，共同来完成一个较大的任务。</p><p>在使用<code>WaitGroup</code>值的时候，我们一定要注意，千万不要让其中的计数器的值小于<code>0</code>，否则就会引发panic。</p><p>另外，<strong>我们最好用“先统一<code>Add</code>，再并发<code>Done</code>，最后<code>Wait</code>”这种标准方式，来使用<code>WaitGroup</code>值。</strong> 尤其不要在调用<code>Wait</code>方法的同时，并发地通过调用<code>Add</code>方法去增加其计数器的值，因为这也有可能引发panic。</p><p><code>Once</code>值的使用方式比<code>WaitGroup</code>值更加简单，它只有一个<code>Do</code>方法。同一个<code>Once</code>值的<code>Do</code>方法，永远只会执行第一次被调用时传入的参数函数，不论这个函数的执行会以怎样的方式结束。</p><p>只要传入某个<code>Do</code>方法的参数函数没有结束执行，任何之后调用该方法的goroutine就都会被阻塞。只有在这个参数函数执行结束以后，那些goroutine才会逐一被唤醒。</p><p><code>Once</code>类型使用互斥锁和原子操作实现了功能，而<code>WaitGroup</code>类型中只用到了原子操作。\t所以可以说，它们都是更高层次的同步工具。它们都基于基本的通用工具，实现了某一种特定的功能。<code>sync</code>包中的其他高级同步工具，其实也都是这样的。</p><h2>思考题</h2><p>今天的思考题是：在使用<code>WaitGroup</code>值实现一对多的goroutine协作流程时，怎样才能让分发子任务的goroutine获得各个子任务的具体执行结果？</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p>","comments":[{"had_liked":false,"id":70794,"user_name":"liangjf","can_delete":false,"product_type":"c1","uid":1058812,"ip_address":"","ucode":"681A6CCF098F55","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg","comment_is_top":false,"comment_ctime":1551185349,"is_pvip":false,"replies":[{"id":"25453","content":"Go语言底层内置了内存屏障。它的好处就是不用像C++那样什么都需要自己搞。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551253245,"ip_address":"","comment_id":70794,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74565629381","product_id":100013101,"comment_content":"“双重检查” 貌似也并不是完全安全的吧，像c++11那样加入内存屏障才是真正线性安全的。go有这类接口吗","like_count":17,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440834,"discussion_content":"Go语言底层内置了内存屏障。它的好处就是不用像C++那样什么都需要自己搞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551253245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227377,"discussion_content":"看了老师的回复 我才明白为什么说c++难搞 而且如果c++掌握得好 是很牛逼的  我也要重新审视一下自己的c++了,所以c++难就难在啥都需要了解掌握 并且啥都需要自己搞,我会回过头去好好学习c++ 深入学习c++","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586486782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144375,"user_name":"唐大少在路上。。。","can_delete":false,"product_type":"c1","uid":1049916,"ip_address":"","ucode":"EB8B16FE41364A","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/3c/6f2a4724.jpg","comment_is_top":false,"comment_ctime":1571906536,"is_pvip":true,"replies":[{"id":"56048","content":"这样不行啊，它还得执行你给它的函数啊。怎么能在没执行函数之前就把 done 变成 1 呢，对吧。但如果是在执行之后 swap，那又太晚了，有可能出现重复执行函数的情况。<br><br>所以 Once 中才有两个执行路径，一个是仅包含原子操作的快路径，另一个是真正准备执行函数的慢路径。这样才可以兼顾多种情况，让总体性能更优。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1572253793,"ip_address":"","comment_id":144375,"utype":1}],"discussion_count":3,"race_medal":0,"score":"61701448680","product_id":100013101,"comment_content":"个人感觉Once里面的逻辑设计得不够简洁，既然目的就是只要能够拿到once的锁的gorountine就会消费掉这个once，那其实直接在Do方法的最开始用if atomic.CompareAndSwapUint32(&amp;o.done, 0,1)不就行了，连锁都不用。<br>还请老师指正，哈哈","like_count":15,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471910,"discussion_content":"这样不行啊，它还得执行你给它的函数啊。怎么能在没执行函数之前就把 done 变成 1 呢，对吧。但如果是在执行之后 swap，那又太晚了，有可能出现重复执行函数的情况。\n\n所以 Once 中才有两个执行路径，一个是仅包含原子操作的快路径，另一个是真正准备执行函数的慢路径。这样才可以兼顾多种情况，让总体性能更优。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572253793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740409,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/79/f9d5dd3a.jpg","nickname":"吕超","note":"","ucode":"B36883984BE16B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190969,"discussion_content":"这位兄台是在源代码注释里面找到的这种写法吗？\n\t// Note: Here is an incorrect implementation of Do:\n\t//\n\t//\tif atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) {\n\t//\t\tf()\n\t//\t}\n\t//\n\t// Do guarantees that when it returns, f has finished.\n\t// This implementation would not implement that guarantee:\n\t// given two simultaneous calls, the winner of the cas would\n\t// call f, and the second would return immediately, without\n\t// waiting for the first&#39;s call to f to complete.\n\t// This is why the slow path falls back to a mutex, and why\n\t// the atomic.StoreUint32 must be delayed until after f returns.","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1582983719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1350159,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","nickname":"芒果少侠","note":"","ucode":"98D0BBB52BB80F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1740409,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/79/f9d5dd3a.jpg","nickname":"吕超","note":"","ucode":"B36883984BE16B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318923,"discussion_content":"感谢你的搬运：我这边加一点自己理解：goroutine1优先进入了调用f()的流程，而goroutine2就会直接返回。此时如果f没执行完（比如是一些初始化操作），那么goroutine2就会执行出错，所以他必须等待f()完成。这也是mutex临界区的作用。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1603884272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":190969,"ip_address":""},"score":318923,"extra":""}]}]},{"had_liked":false,"id":160340,"user_name":"ONLY","can_delete":false,"product_type":"c1","uid":1049147,"ip_address":"","ucode":"180990E586D060","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/3b/b4a47f63.jpg","comment_is_top":false,"comment_ctime":1575938542,"is_pvip":false,"replies":[{"id":"61209","content":"它跟单例模式还不太一样。单例模式指的是某类结构的唯一实例，而 once 指的是对某段代码的唯一一次执行。它们的维度不一样。<br><br>连接数据库的代码其实不太适合放到 Do 里面执行，或者说不太恰当。初始化数据库链接的代码可以放到里面。而，断链重连的机制也应该在其中。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1575947976,"ip_address":"","comment_id":160340,"utype":1}],"discussion_count":0,"race_medal":0,"score":"35935676910","product_id":100013101,"comment_content":"可不可以把 sync.once 理解为单例模式，比如连接数据库只需要连接一次，把连接数据库的代码实在once.do()里面","like_count":9},{"had_liked":false,"id":155766,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1574752190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27344555966","product_id":100013101,"comment_content":"二刷走起","like_count":6},{"had_liked":false,"id":75794,"user_name":"超大叮当当","can_delete":false,"product_type":"c1","uid":1203824,"ip_address":"","ucode":"847532DD090D28","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIGMzsqGicBHicmA0xosKibBSmFjrwG8LuRwky3QlZibJt1treDMLPuaKviaC9JrJdQpdJE199ztVMJOGQ/132","comment_is_top":false,"comment_ctime":1552469655,"is_pvip":false,"replies":[{"id":"28885","content":"原子操作是CPU级别的互斥，而且防中断。但是支持的数据类型很少，而且并不灵活。所以如果是对代码块进行保护，还需要用锁。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1553399752,"ip_address":"","comment_id":75794,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27322273431","product_id":100013101,"comment_content":"sync.Once 不用 Mutex ，直接用 atomic.CompareAndSwapUint32 函数也可以安全吧？","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443036,"discussion_content":"原子操作是CPU级别的互斥，而且防中断。但是支持的数据类型很少，而且并不灵活。所以如果是对代码块进行保护，还需要用锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1553399752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291834,"user_name":"moonfox","can_delete":false,"product_type":"c1","uid":1526355,"ip_address":"","ucode":"902BFF40EFA9FA","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","comment_is_top":false,"comment_ctime":1620545406,"is_pvip":false,"replies":[{"id":"105709","content":"这是两码事啊，原子操作还有一个作用是保证被操作值的完整性。比如，done字段的值要么是0要么是1。别忘了，done字段的值是由32个比特位组成的。如果在修改值的过程中（还没改完），其他的代码在读取它，那岂不是会读到一个非0非1的值吗？（这是一个小概率问题，但是万一出了错，复现都没法复现，排查起来就太困难了，所以恰恰需要极力避免）<br><br>就像源码中的<br><br>if atomic.LoadUint32(&amp;o.done) == 0 {<br><br>这里。<br><br>这行代码可没有锁的加持啊，它可不管另一个goroutine执行到doSlow函数中的哪一步了。另外，对一个值的原子操作必须全面覆盖（如果用，就都要用原子操作）。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1620624827,"ip_address":"","comment_id":291834,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23095381886","product_id":100013101,"comment_content":"请问一下，在 sync.Once的源码里， doSlow()方法中，已经用了o.m.Lock()，什么写入o.done=1的时候，还要用原子写入呢？","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519580,"discussion_content":"这是两码事啊，原子操作还有一个作用是保证被操作值的完整性。比如，done字段的值要么是0要么是1。别忘了，done字段的值是由32个比特位组成的。如果在修改值的过程中（还没改完），其他的代码在读取它，那岂不是会读到一个非0非1的值吗？（这是一个小概率问题，但是万一出了错，复现都没法复现，排查起来就太困难了，所以恰恰需要极力避免）\n\n就像源码中的\n\nif atomic.LoadUint32(&amp;amp;o.done) == 0 {\n\n这里。\n\n这行代码可没有锁的加持啊，它可不管另一个goroutine执行到doSlow函数中的哪一步了。另外，对一个值的原子操作必须全面覆盖（如果用，就都要用原子操作）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620624827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41472,"user_name":"蔺晨","can_delete":false,"product_type":"c1","uid":1273010,"ip_address":"","ucode":"FF7E9905DB6AC6","user_header":"https://static001.geekbang.org/account/avatar/00/13/6c/b2/362353ba.jpg","comment_is_top":false,"comment_ctime":1542789002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18722658186","product_id":100013101,"comment_content":"思考题 :<br>func getAllGoroutineResult(){<br>\t\twg := sync.WaitGroup{}<br>\t\twg.Add(3)<br><br>\t\tonce := sync.Once{}<br>\t\tvar aAndb int<br>\t\tvar aStrAndb string<br>\t\tvar gflag int32<br><br>\t\taddNum := func(a,b int, ret *int) {<br>\t\t\tdefer wg.Done()<br>\t\t\ttime.Sleep(time.Millisecond * 2000)<br>\t\t\t*ret = a+b<br>\t\t\tatomic.AddInt32(&amp;gflag,1)<br>\t\t}<br><br>\t\taddStr := func(a,b string, ret *string) {<br>\t\t\tdefer wg.Done()<br>\t\t\ttime.Sleep(time.Millisecond * 1000)<br>\t\t\t*ret = a+b<br>\t\t\tatomic.AddInt32(&amp;gflag,1)<br>\t\t}<br><br>\t\t&#47;&#47; waitRet需要等待 addNum和addStr执行完成后的结果<br>\t\twaitRet := func(ret *int, strRet *string) {<br>\t\t\tdefer wg.Done()<br>\t\t\tonce.Do(func() {<br>\t\t\t\tfor atomic.LoadInt32(&amp;gflag) != 2 {<br>\t\t\t\t\tfmt.Println(&quot;Wait: addNum &amp; addStr&quot;)<br>\t\t\t\t\ttime.Sleep(time.Millisecond * 200)<br>\t\t\t\t}<br>\t\t\t})<br>\t\t\tfmt.Println(fmt.Sprintf(&quot;AddNum&#39;s Ret is: %d\\n&quot;, *ret))<br>\t\t\tfmt.Println(fmt.Sprintf(&quot;AddStr&#39;s Ret is: %s\\n&quot;, *strRet))<br>\t\t}<br><br>\t\t&#47;&#47; waitRet goroutine等待AddNum和AddStr结束<br>\t\tgo waitRet(&amp;aAndb, &amp;aStrAndb)<br>\t\tgo addNum(10, 20, &amp;aAndb)<br>\t\tgo addStr(&quot;测试结果&quot;, &quot;满意不?&quot;, &amp;aStrAndb)<br><br>\t\twg.Wait()<br>}","like_count":4},{"had_liked":false,"id":146974,"user_name":"窗外","can_delete":false,"product_type":"c1","uid":1542520,"ip_address":"","ucode":"3FF86229C97428","user_header":"","comment_is_top":false,"comment_ctime":1572748106,"is_pvip":false,"replies":[{"id":"56867","content":"你在后面 wg.Wait() 了吗？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1572838013,"ip_address":"","comment_id":146974,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14457649994","product_id":100013101,"comment_content":"go func ()  {<br>\t\t wg.Done()<br>\t\tfmt.Println(&quot;send complete&quot;)<br>\t }()<br>老师，为什么在Done()后的代码就不会被执行呢？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473082,"discussion_content":"你在后面 wg.Wait() 了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572838013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1308640,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f7/e0/c0d863cc.jpg","nickname":"芒果大叔","note":"","ucode":"A555DBABC6C75D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96693,"discussion_content":"因为 wg.Done() 操作之后 wg 的值归零了 wg.Wait() 得到了wg的的归零通知 所以结束了任务 但是 go语句是并发执行的 如果主goroutine 执行的速度 比go语句慢 那么有可能会执行fmt.Println(&#34;send complete&#34;) 因为 主goroutine 没有执行到  wg.Wait() 的阻塞操作 go语句中的 wg.Done()先被执行 那么 fmt.Println(&#34;send complete&#34;) 则有执行的机会  如果比go语句块 已经执行了 wg.Wait 那么wg.Done()后面的语句没有执行的机会","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1577087036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45130,"user_name":"ricktian","can_delete":false,"product_type":"c1","uid":1030928,"ip_address":"","ucode":"06F90004164C64","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/10/f01eafe4.jpg","comment_is_top":false,"comment_ctime":1543548570,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14428450458","product_id":100013101,"comment_content":"执行结果如果不用channel实现，还有什么方法？请老师指点～","like_count":3,"discussions":[{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227381,"discussion_content":"还有共享内存 嘿嘿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586487068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1222003,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/73/3ddc7c77.jpg","nickname":"Brave Shine","note":"","ucode":"CBB1BAF89DB936","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4542,"discussion_content":"传递指针的类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565531414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35925,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1540862895,"is_pvip":false,"replies":[{"id":"13303","content":"可以通过通道，但这就不是wg的作用范围了。once一般是执行只应该执行一次的任务，比如初始化连接池等等。你可以在go源码里搜一下，用的地方还是不少的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541481373,"ip_address":"","comment_id":35925,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14425764783","product_id":100013101,"comment_content":"子任务的结果应该用通道来传递吧。另外once的应用场景还是没有理解。郝大能简单说一下么？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427710,"discussion_content":"可以通过通道，但这就不是wg的作用范围了。once一般是执行只应该执行一次的任务，比如初始化连接池等等。你可以在go源码里搜一下，用的地方还是不少的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541481373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34500,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1540191320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14425093208","product_id":100013101,"comment_content":"执行结果用 Callback，放在通道中，在主 goroutine 中接收返回结果","like_count":3},{"had_liked":false,"id":275051,"user_name":"罗峰","can_delete":false,"product_type":"c1","uid":1218501,"ip_address":"","ucode":"5F3D6AF8F28322","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","comment_is_top":false,"comment_ctime":1611286436,"is_pvip":false,"replies":[{"id":"99784","content":"WaitGroup与操作系统的信号灯异曲同工。<br><br>必须要有 wg.Done() 啊，否则计数就无法归零，wg.Wait() 也就无法消除阻塞。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1611293711,"ip_address":"","comment_id":275051,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10201221028","product_id":100013101,"comment_content":"老师，你好，waitgroup的计数周期这个概念是自创的吗？使用上感觉 只要 add操作在wait语句之前执行就可以，使用个例子：<br> for {<br>      select {<br>      case &lt;- cancel:<br>         break;<br>      case &lt;- taskqueue:<br>        go func {<br>             wg.add(1)<br>              ....<br>             defer wg.done()<br>            }<br>     }<br>}<br>wg.wait()","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514194,"discussion_content":"WaitGroup与操作系统的信号灯异曲同工。\n\n必须要有 wg.Done() 啊，否则计数就无法归零，wg.Wait() 也就无法消除阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611293711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139535,"user_name":"手指饼干","can_delete":false,"product_type":"c1","uid":1048607,"ip_address":"","ucode":"1AC502D2B782F0","user_header":"","comment_is_top":false,"comment_ctime":1570674327,"is_pvip":false,"replies":[{"id":"54093","content":"你那么写也可以，我弄一坨只是想引起你们的注意。在不影响程序功能和运行效率的前提下，我会在程序里尽量多展示几种写法。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1570781585,"ip_address":"","comment_id":139535,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10160608919","product_id":100013101,"comment_content":"请问老师，如下deferFunc为什么要用func包装起来，直接使用defer deferFunc()不可以吗？<br>func addNum(numP *int32, id, max int32, deferFunc func()) {<br>\tdefer func() {<br>\t\tdeferFunc()<br>\t}()<br>\t&#47;&#47;...<br>}","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469985,"discussion_content":"你那么写也可以，我弄一坨只是想引起你们的注意。在不影响程序功能和运行效率的前提下，我会在程序里尽量多展示几种写法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570781585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272825,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","nickname":"Onyanga","note":"","ucode":"DF4D22F0D51881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301399,"discussion_content":"老师真幽默，喜欢这个“一坨”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598515573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221010,"user_name":"1287","can_delete":false,"product_type":"c1","uid":1950498,"ip_address":"","ucode":"C91D3AD48298A4","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c3/22/8520be75.jpg","comment_is_top":false,"comment_ctime":1590378603,"is_pvip":false,"replies":[{"id":"81514","content":"同一个 sync.Once 实例的 Do 方法只会被有效调用一次。init 函数是在当前程序中只会被调用一次，而且它的作用域是代码包。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1590399963,"ip_address":"","comment_id":221010,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5885345899","product_id":100013101,"comment_content":"没理解使用once和自己只调用一次有什么区别，类似初始化的操作，我在程序执行前写个init也是只执行一次吧，求教","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496295,"discussion_content":"同一个 sync.Once 实例的 Do 方法只会被有效调用一次。init 函数是在当前程序中只会被调用一次，而且它的作用域是代码包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590399963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364349,"discussion_content":"现在都是在并发场景……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617455188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204886,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1586486654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881453950","product_id":100013101,"comment_content":"今日总结<br>这里主要讲了sync&#47;waitgroup和sync&#47;once这两种同步的方式<br>waitgroup一般用于一对多的同步 例如 主goroutine等待其他goroutine的执行完成<br>唯一要注意的是 add方法和wait方法不要并行执行 也即 wait方法调用过后 不要立即再调用add方法<br>once值 主要还是保证函数只被执行一次 且只有第一次调用Do方法的参数函数会被执行一次 once值底层依赖的是互斥锁 所以操作和互斥锁很类似<br>并且 如果某个Do的参数函数一直不结束 那么其他调用Do方法的goroutine都会被阻塞在获取互斥锁这一步，只有当首次Do方法的参数函数执行结束过后 这些goroutine才会被逐一唤醒<br>所以要注意 Once 在使用死的死锁 ","like_count":1},{"had_liked":false,"id":131459,"user_name":"bluuus","can_delete":false,"product_type":"c1","uid":1218438,"ip_address":"","ucode":"274D5063B5F542","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/86/fb564a19.jpg","comment_is_top":false,"comment_ctime":1567757887,"is_pvip":false,"replies":[{"id":"50356","content":"你对 addNum 函数有改动吗？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1567915720,"ip_address":"","comment_id":131459,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5862725183","product_id":100013101,"comment_content":"func coordinateWithWaitGroup() {<br>\tvar wg sync.WaitGroup<br>\twg.Add(2)<br>\tnum := int32(0)<br>\tfmt.Printf(&quot;The number: %d [with sync.WaitGroup]\\n&quot;, num)<br>\tmax := int32(10)<br>\tgo addNum(&amp;num, 3, max, wg.Done)<br>\t&#47;&#47;go addNum(&amp;num, 4, max, wg.Done)<br>\twg.Wait()<br>}<br><br>run result:<br>The number: 0 [with sync.WaitGroup]<br>The number: 2 [3-0]<br>The number: 4 [3-1]<br>The number: 6 [3-2]<br>The number: 8 [3-3]<br>The number: 10 [3-4]<br>fatal error: all goroutines are asleep - deadlock!<br><br>执行这段代码会死锁，我以为最多在wai()方法那儿阻塞，谁能解释一下？<br>","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466464,"discussion_content":"你对 addNum 函数有改动吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567915720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/86/fb564a19.jpg","nickname":"bluuus","note":"","ucode":"274D5063B5F542","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8360,"discussion_content":"没有改动，就是注释了一条addNum协程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567945173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1218438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/86/fb564a19.jpg","nickname":"bluuus","note":"","ucode":"274D5063B5F542","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143367,"discussion_content":"示例的 addNum 函数就3个参数\nfunc addNum(numP *int32, id int, deferFunc func())\n\n你的代码 go addNum(&amp;num, 3, max, wg.Done)\n这都有4个参数了，能编译通过吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579503280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8360,"ip_address":""},"score":143367,"extra":""}]}]},{"had_liked":false,"id":350979,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1657436720,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657436720","product_id":100013101,"comment_content":"easy case<br>func TestWaitGroup() {<br>\tvar wg sync.WaitGroup<br>\twg.Add(3)<br>\tfor i := 0; i &lt; 3; i++ {<br>\t\tgo func() {<br>\t\t\tdefer wg.Done()<br>\t\t\ttime.Sleep(time.Second * 3)<br>\t\t\tfmt.Println(&quot;done!&quot;)<br>\t\t}()<br>\t}<br><br>\twg.Wait()<br>\tfmt.Println(&quot;over&quot;)<br>}<br><br>func TestOnce() {<br>\tvar o sync.Once<br>\tvar wg sync.WaitGroup<br>\twg.Add(10)<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func() {<br>\t\t\tdefer wg.Done()<br>\t\t\ttime.Sleep(time.Second * 1)<br>\t\t\to.Do(func() {<br>\t\t\t\tfmt.Println(&quot;mclink&quot;)<br>\t\t\t})<br>\t\t}()<br>\t}<br>\twg.Wait()<br>\tfmt.Println(&quot;over&quot;)<br>}","like_count":0},{"had_liked":false,"id":331077,"user_name":"NeoMa","can_delete":false,"product_type":"c1","uid":1228079,"ip_address":"","ucode":"9EABAF2DCF0263","user_header":"","comment_is_top":false,"comment_ctime":1642410928,"is_pvip":false,"replies":[{"id":"121003","content":"1. 当然不能省略了，如果在当前 goroutine 的 atomic.LoadUint32(&amp;o.done) == 0 和 o.doSlow(f) 的执行间隙有其他 goroutine 执行到了 atomic.StoreUint32(&amp;o.done, 1) ，那么再等到当前 goroutine 继续执行的时候 done 可就不是 0 了。<br><br>注意！锁只保证：它保护的某一个临界区内的代码在同一时刻只被某一个 goroutine 执行（也可以说接触到），而不会保证其中代码执行的原子性。所以，在其中代码执行期间也有可能被中断，中断的粒度通常是语句级别的。<br><br>2. 针对同一个共享变量的原子操作必须是完全的，否则就跟没做原子操作没啥区别。就像刚才说的，锁只负责保证串行访问和执行，它没法实现原子性操作。在这里，锁和原子操作是各司其职的。（除非你完全用锁把对 done 的一切操作都保护起来，否则，即然用了原子操作来保证 done 的原子性就要用完全）","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1642486834,"ip_address":"","comment_id":331077,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642410928","product_id":100013101,"comment_content":"您好，关于once.go中 doSlow方法有两个疑问：<br>1. 在拿到m.Lock()锁之后的o.done == 0 的判断能否省略？或者说这个判断针对的是某些可能的未知场景吗？我的理解是，理论上此时这个值一定是0，但为了确保预防未知场景又做了一次判断。<br>2. defer atomic.StoreUint32(&amp;o.done, 1) 这个操作是否可以不用原子操作，只是使用例如 o.done = 1类似的赋值操作？<br>希望您多多指正。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546979,"discussion_content":"1. 当然不能省略了，如果在当前 goroutine 的 atomic.LoadUint32(&amp;o.done) == 0 和 o.doSlow(f) 的执行间隙有其他 goroutine 执行到了 atomic.StoreUint32(&amp;o.done, 1) ，那么再等到当前 goroutine 继续执行的时候 done 可就不是 0 了。\n\n注意！锁只保证：它保护的某一个临界区内的代码在同一时刻只被某一个 goroutine 执行（也可以说接触到），而不会保证其中代码执行的原子性。所以，在其中代码执行期间也有可能被中断，中断的粒度通常是语句级别的。\n\n2. 针对同一个共享变量的原子操作必须是完全的，否则就跟没做原子操作没啥区别。就像刚才说的，锁只负责保证串行访问和执行，它没法实现原子性操作。在这里，锁和原子操作是各司其职的。（除非你完全用锁把对 done 的一切操作都保护起来，否则，即然用了原子操作来保证 done 的原子性就要用完全）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642486834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329586,"user_name":"窝窝头","can_delete":false,"product_type":"c1","uid":1063866,"ip_address":"","ucode":"5C2635ED6484F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/ba/3b30dcde.jpg","comment_is_top":false,"comment_ctime":1641435994,"is_pvip":true,"replies":[{"id":"120074","content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1641460826,"ip_address":"","comment_id":329586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641435994","product_id":100013101,"comment_content":"执行结果可以通过共享内存、channel之类的，如果只是想让其他协程等待所有协程都完成后统一退出的话是不是每个协程里面wg.Done,然后wg.Wait就行了","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544300,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641460826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312240,"user_name":"Harlan","can_delete":false,"product_type":"c1","uid":2134882,"ip_address":"","ucode":"F43595A0A00B19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erpYZalYvFGcBs7zZvYwaQAZwTLiaw0mycJ4PdYpP3VxAYkAtyIRHhjSOrOK0yESaPpgEbVQUwf6LA/132","comment_is_top":false,"comment_ctime":1631699081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631699081","product_id":100013101,"comment_content":"go 里面使用waitGroup后，对多个goroutine 的结果还是得用 ch来处理,比较难受","like_count":0},{"had_liked":false,"id":272741,"user_name":"poettian","can_delete":false,"product_type":"c1","uid":1144021,"ip_address":"","ucode":"26EE408F908D12","user_header":"https://static001.geekbang.org/account/avatar/00/11/74/d5/de9641dc.jpg","comment_is_top":false,"comment_ctime":1610258839,"is_pvip":false,"replies":[{"id":"98919","content":"它同时也用到锁了啊。用原子操作是为了快速判断是不是“条件不满足”，而用锁是为了在“条件满足”的情况下执行操作。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1610342456,"ip_address":"","comment_id":272741,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610258839","product_id":100013101,"comment_content":"老师，once 里的实现为什么要用原子操作呢？不是已经有锁了。这点不是很明白。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513371,"discussion_content":"它同时也用到锁了啊。用原子操作是为了快速判断是不是“条件不满足”，而用锁是为了在“条件满足”的情况下执行操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610342456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265713,"user_name":"我的腿腿","can_delete":false,"product_type":"c1","uid":1239277,"ip_address":"","ucode":"2AAA36A7C3AD75","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/ed/f9347e5e.jpg","comment_is_top":false,"comment_ctime":1606990214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606990214","product_id":100013101,"comment_content":"感觉 sync.WaitGroup 和java的CountDownLatch（）很像。","like_count":0},{"had_liked":false,"id":260379,"user_name":"Godruoyi","can_delete":false,"product_type":"c1","uid":1021785,"ip_address":"","ucode":"62B9BDEC55A983","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/59/6f9c036e.jpg","comment_is_top":false,"comment_ctime":1604994959,"is_pvip":false,"replies":[{"id":"94560","content":"从头保证绝对的并发安全可不是一件容易的事。这需要在充分理解底层并发原理的前提下进行。简单来说，你的 m.a 在这里会成为一个竞态条件（针对 m.a 的读写操作不是并发安全的）。<br><br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1605004716,"ip_address":"","comment_id":260379,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604994959","product_id":100013101,"comment_content":"type myOnce struct {<br>\tdone uint32<br>\tm    sync.Mutex<br><br>\ta bool<br>}<br><br>func (m *myOnce) Do(f func()) {<br>\tif atomic.CompareAndSwapUint32(&amp;m.done, 0, 1) {<br>\t\tf()<br>\t\tm.a = true<br>\t}<br><br>\tfor {<br>\t\tif m.a {<br>\t\t\tbreak<br>\t\t}<br>\t}<br><br>\treturn<br>}<br><br><br>for 循环阻塞和加锁阻塞有什么区别呢","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509181,"discussion_content":"从头保证绝对的并发安全可不是一件容易的事。这需要在充分理解底层并发原理的前提下进行。简单来说，你的 m.a 在这里会成为一个竞态条件（针对 m.a 的读写操作不是并发安全的）。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605004716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234812,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1594802222,"is_pvip":false,"replies":[{"id":"86732","content":"我说了，o.done 是那个“作为参数值的函数”被执行完毕的标志，你在执行这个函数前就让 o.done 变成 1，那如果该函数没有正常执行完毕又该怎么算呢？<br><br>注意，在这个函数执行完毕之前，所以想通过同一个 once 去执行参数函数的goroutine都会被阻塞。这也是加锁的作用之一。<br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1594872288,"ip_address":"","comment_id":234812,"utype":1}],"discussion_count":6,"race_medal":0,"score":"1594802222","product_id":100013101,"comment_content":"个人感觉Once里面的逻辑设计得不够简洁，既然目的就是只要能够拿到once的锁的gorountine就会消费掉这个once，那其实直接在Do方法的最开始用if atomic.CompareAndSwapUint32(&amp;o.done, 0,1)不就行了，连锁都不用。<br>还请老师指正，哈哈<br><br>作者回复: 这样不行啊，它还得执行你给它的函数啊。怎么能在没执行函数之前就把 done 变成 1 呢，对吧。但如果是在执行之后 swap，那又太晚了，有可能出现重复执行函数的情况。<br><br>所以 Once 中才有两个执行路径，一个是仅包含原子操作的快路径，另一个是真正准备执行函数的慢路径。这样才可以兼顾多种情况，让总体性能更优。<br><br>您好，根据这位描述，我也觉得可以直接这么使用呀，类似改成下面这块<br>func (o *once) Do(fn func())  {<br>\tif atomic.CompareAndSwapInt32(&amp;o.done, 0, 1) {<br>\t\tfn()<br>\t}<br>\treturn<br>}<br>只有在交换成功的时候执行这个操作，不知道我这个理解上有什么问题，请指教","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501515,"discussion_content":"我说了，o.done 是那个“作为参数值的函数”被执行完毕的标志，你在执行这个函数前就让 o.done 变成 1，那如果该函数没有正常执行完毕又该怎么算呢？\n\n注意，在这个函数执行完毕之前，所以想通过同一个 once 去执行参数函数的goroutine都会被阻塞。这也是加锁的作用之一。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594872288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291548,"discussion_content":"Do() 的设计思路是当 Do() 返回是， f() 已经执行完毕。很符合初始化连接池这类的应用场景。在 Do() 的后续代码里使用资源时，必须保证资源已经初始化完成。Once() 的设计思路是保证 fn() 的原子操作，这符合应用场景。\n如果不care这一点，那确实可以写，只是使用场景大概比较苛刻，拍脑袋一想没想出。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1594866192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1563985,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","nickname":"Geek_a8be59","note":"","ucode":"BEC0F57B51DC44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291575,"discussion_content":"有道理\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594873593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291548,"ip_address":""},"score":291575,"extra":""},{"author":{"id":1272825,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","nickname":"Onyanga","note":"","ucode":"DF4D22F0D51881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301401,"discussion_content":"fn()不是原子操作，虽然明白你所说的意思，但是表述严谨一些会更好。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1598515937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291548,"ip_address":""},"score":301401,"extra":""}]},{"author":{"id":2100644,"avatar":"","nickname":"Geek_8e2759","note":"","ucode":"EBDBA4D92B5C50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297322,"discussion_content":"Golang 源码中有注释，这么设计是出于 `Do()` 返回时必须保证 `f()` 已经执行完毕了，如果使用  `atomic.CompareAndSwap` 的话如果条件不满足直接返回了，无法保证 `f()` 已经执行完了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596873883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1657421,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJEGRf488zB6kRDic691OicZcr5tbice0wP4xMevdtYEcBJoS5wzG2cUXhicsXLvX8fmLfgvgVibofJM2w/132","nickname":"Geek_ff334e","note":"","ucode":"F35A9BC2B7F6B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295616,"discussion_content":"老师你不是说无论参数函数无论是否执行成功都会通过defer将Done的值设置为1吗？所以即便没有正常执行完毕，将Done设置为1应该也没问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596263293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230456,"user_name":"www","can_delete":false,"product_type":"c1","uid":1898338,"ip_address":"","ucode":"ADC9BC655EA16C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f7/62/947004d0.jpg","comment_is_top":false,"comment_ctime":1593393307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593393307","product_id":100013101,"comment_content":"“Once类型使用互斥锁和原子操作实现了功能，而WaitGroup类型中只用到了原子操作。\t所以可以说，它们都是更高层次的同步工具。它们都基于基本的通用工具，实现了某一种特定的功能。sync包中的其他高级同步工具，其实也都是这样的。“，点出sync包搭积木的基础，类别数据结构中的数组和链表是其他数据结构的基础，精彩","like_count":0},{"had_liked":false,"id":230345,"user_name":"www","can_delete":false,"product_type":"c1","uid":1898338,"ip_address":"","ucode":"ADC9BC655EA16C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f7/62/947004d0.jpg","comment_is_top":false,"comment_ctime":1593352352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593352352","product_id":100013101,"comment_content":"LoadInt32()原子性得到原变量的值，执行操作后，再通过CompareAndSwapInt32()原子性的比较*addr和old，如果相同则将new赋值给*addr并返回真，通过比较来判断原变量在函数运行过程中没有被其他Go程修改，进而保证得到结果是符合预期的。如果被修改则得到失败结果。感觉原子操作比上锁解锁操心的多，老师代码例子写得真好。","like_count":0},{"had_liked":false,"id":229599,"user_name":"Ethan Liu","can_delete":false,"product_type":"c1","uid":1070043,"ip_address":"","ucode":"231F944F7CD56A","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","comment_is_top":false,"comment_ctime":1593071627,"is_pvip":true,"replies":[{"id":"84781","content":"因为已经有锁的保护了啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1593148520,"ip_address":"","comment_id":229599,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1593071627","product_id":100013101,"comment_content":"为什么在慢路径中第二次进行条件判断（if o.done == 0）不对done用原子操作呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499554,"discussion_content":"因为已经有锁的保护了啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593148520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372968,"discussion_content":"那为什么不直接用o.done=1写入，要用原子写入atomic.StoreUint32(&amp;o.done, 1)呢？不是已经有锁保护了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620546133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389317,"discussion_content":"前面的文章说了，锁不能保证原子操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629215494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372968,"ip_address":""},"score":389317,"extra":""}]}]},{"had_liked":false,"id":204888,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1586486831,"is_pvip":false,"replies":[{"id":"76909","content":"可以写出演示代码吗？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1586745733,"ip_address":"","comment_id":204888,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586486831","product_id":100013101,"comment_content":"关于思考题 采用共享内存 或者通道的方式去获取结果","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491318,"discussion_content":"可以写出演示代码吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586745733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198426,"user_name":"给力","can_delete":false,"product_type":"c1","uid":1113645,"ip_address":"","ucode":"646EE4AFC17224","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/2d/2c9177ca.jpg","comment_is_top":false,"comment_ctime":1585450536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585450536","product_id":100013101,"comment_content":"各执行任务的goroutine把执行结果放入带缓冲的chan中，分配任务的goroutine 获取结果","like_count":0},{"had_liked":false,"id":170650,"user_name":"Alan","can_delete":false,"product_type":"c1","uid":1198125,"ip_address":"","ucode":"9C66CBCFB3A109","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/2d/7a3d42fb.jpg","comment_is_top":false,"comment_ctime":1578651667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578651667","product_id":100013101,"comment_content":"哈哈，”快速失败路径“ 这个称呼还可以，有点类似java的fail-fast 机制","like_count":0},{"had_liked":false,"id":141236,"user_name":"nora","can_delete":false,"product_type":"c1","uid":1206539,"ip_address":"","ucode":"3A3EABF27D0261","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/0b/780b0aac.jpg","comment_is_top":false,"comment_ctime":1571130981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571130981","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;sync&quot;<br>)<br><br>&#47;&#47;不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的 goroutine 中执行<br>&#47;&#47;要杜绝对同一个WaitGroup值的两种操作的并发执行<br><br>&#47;&#47;使用WaitGroup值标准方式: 先统一Add，再并发Done，最后Wait<br><br>func main() {<br>\tvar wg sync.WaitGroup<br>\ti := 0<br>\tfor ; i &lt; 2; i++ {<br>\t\twg.Add(1)<br>\t\tgo func(i int) {<br>\t\t\tfmt.Println(&quot;i = &quot;, i)<br>\t\t\tdefer wg.Done()<br>\t\t}(i)<br>\t}<br>\twg.Wait()<br>\treturn<br>}<br>","like_count":0},{"had_liked":false,"id":120695,"user_name":"magina","can_delete":false,"product_type":"c1","uid":1138499,"ip_address":"","ucode":"9546701896A09F","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/43/3799a0f3.jpg","comment_is_top":false,"comment_ctime":1564976897,"is_pvip":false,"replies":[{"id":"44354","content":"本身不能，但是这很容易通过 select 语句和 time.Timer 解决。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1565005083,"ip_address":"","comment_id":120695,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564976897","product_id":100013101,"comment_content":"WaitGroup能不能设置超时","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461440,"discussion_content":"本身不能，但是这很容易通过 select 语句和 time.Timer 解决。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565005083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117670,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1564108582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564108582","product_id":100013101,"comment_content":"不用chan的情况下，<br>传递一个指针变量到go执行的函数中，这样就可以在主goroutine中取到","like_count":0},{"had_liked":false,"id":64876,"user_name":"M","can_delete":false,"product_type":"c1","uid":1117633,"ip_address":"","ucode":"88F6F1433A01A3","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/c1/d36816df.jpg","comment_is_top":false,"comment_ctime":1548936088,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1548936088","product_id":100013101,"comment_content":"看了一下源码，Once是先将done值置为1后再执行的参数函数。所以应该不会阻塞等待函数执行的情况。<br>        if atomic.LoadUint32(&amp;o.done) == 1 {<br>\t\treturn<br>\t}<br>\t&#47;&#47; Slow-path.<br>\to.m.Lock()<br>\tdefer o.m.Unlock()<br>\tif o.done == 0 {<br>\t\tdefer atomic.StoreUint32(&amp;o.done, 1)<br>\t\tf()<br>\t}","like_count":0,"discussions":[{"author":{"id":1014615,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/57/18b61282.jpg","nickname":"dullduck","note":"","ucode":"25293558309704","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1466,"discussion_content":"对defer有误解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562640397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1417824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a2/60/f3939ab4.jpg","nickname":"哈哼","note":"","ucode":"C1108406573D49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22639,"discussion_content":"会。锁住，是0，执行fun，设置1，解锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569663009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50471,"user_name":"jacke","can_delete":false,"product_type":"c1","uid":1161209,"ip_address":"","ucode":"05F355E1FF88C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/f9/a8f26b10.jpg","comment_is_top":false,"comment_ctime":1544975349,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1544975349","product_id":100013101,"comment_content":"问下为什么：Add方法和Wait方法的调用是在两个goroutine里面同时调用，Add会panic?<br>wait不是在计数器为零的时候什么都不做吗？Add先执行后执行没问题啊","like_count":0,"discussions":[{"author":{"id":1206539,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/0b/780b0aac.jpg","nickname":"nora","note":"","ucode":"3A3EABF27D0261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33494,"discussion_content":"个人理解是： 不建议ADD 和 Wait方法并发操作，是为了避免  当计数器为0的瞬间 有goroutine 调用Add 使计数器+1，此时会抛出panic\n原因： 当计数器为0是，本应该执行wait之后的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571129350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41473,"user_name":"蔺晨","can_delete":false,"product_type":"c1","uid":1273010,"ip_address":"","ucode":"FF7E9905DB6AC6","user_header":"https://static001.geekbang.org/account/avatar/00/13/6c/b2/362353ba.jpg","comment_is_top":false,"comment_ctime":1542789030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542789030","product_id":100013101,"comment_content":"func getAllGoroutineResult(){<br>\t\twg := sync.WaitGroup{}<br>\t\twg.Add(3)<br><br>\t\tonce := sync.Once{}<br>\t\tvar aAndb int<br>\t\tvar aStrAndb string<br>\t\tvar gflag int32<br><br>\t\taddNum := func(a,b int, ret *int) {<br>\t\t\tdefer wg.Done()<br>\t\t\ttime.Sleep(time.Millisecond * 2000)<br>\t\t\t*ret = a+b<br>\t\t\tatomic.AddInt32(&amp;gflag,1)<br>\t\t}<br><br>\t\taddStr := func(a,b string, ret *string) {<br>\t\t\tdefer wg.Done()<br>\t\t\ttime.Sleep(time.Millisecond * 1000)<br>\t\t\t*ret = a+b<br>\t\t\tatomic.AddInt32(&amp;gflag,1)<br>\t\t}<br><br>\t\t&#47;&#47; waitRet需要等待 addNum和addStr执行完成后的结果<br>\t\twaitRet := func(ret *int, strRet *string) {<br>\t\t\tdefer wg.Done()<br>\t\t\tonce.Do(func() {<br>\t\t\t\tfor atomic.LoadInt32(&amp;gflag) != 2 {<br>\t\t\t\t\tfmt.Println(&quot;Wait: addNum &amp; addStr&quot;)<br>\t\t\t\t\ttime.Sleep(time.Millisecond * 200)<br>\t\t\t\t}<br>\t\t\t})<br>\t\t\tfmt.Println(fmt.Sprintf(&quot;AddNum&#39;s Ret is: %d\\n&quot;, *ret))<br>\t\t\tfmt.Println(fmt.Sprintf(&quot;AddStr&#39;s Ret is: %s\\n&quot;, *strRet))<br>\t\t}<br><br>\t\t&#47;&#47; waitRet goroutine等待AddNum和AddStr结束<br>\t\tgo waitRet(&amp;aAndb, &amp;aStrAndb)<br>\t\tgo addNum(10, 20, &amp;aAndb)<br>\t\tgo addStr(&quot;测试结果&quot;, &quot;满意不?&quot;, &amp;aStrAndb)<br><br>\t\twg.Wait()<br>}","like_count":0},{"had_liked":false,"id":40977,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1542707851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542707851","product_id":100013101,"comment_content":"通过wait阻塞的协程的函数的参数传入指针，然后等wait()执行结束后，通过对应变量来收取值<br>var wg sync.WaitGroup<br>var a int<br>wg.add(1)<br>go func(a *int) {<br>  *a= 3<br>}<br>wg.Wait()<br>使用a获取值<br>是这样吗，老师","like_count":0},{"had_liked":false,"id":36748,"user_name":"xian","can_delete":false,"product_type":"c1","uid":1044145,"ip_address":"","ucode":"3F88DC504887A2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/b1/4af0e26c.jpg","comment_is_top":false,"comment_ctime":1541304506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541304506","product_id":100013101,"comment_content":"1. 可以使用通道来传递<br>2. 在主协程中事先申请足够大的数组，按顺序来存储每个子协程的返回结果","like_count":0},{"had_liked":false,"id":34939,"user_name":"zs阿帅","can_delete":false,"product_type":"c1","uid":1141173,"ip_address":"","ucode":"07A54AE7F1CAFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/b5/1e1731cc.jpg","comment_is_top":false,"comment_ctime":1540363140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540363140","product_id":100013101,"comment_content":"受教了！","like_count":0},{"had_liked":false,"id":34547,"user_name":"AlittleChange","can_delete":false,"product_type":"c1","uid":1098519,"ip_address":"","ucode":"4098171B9EEF18","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/17/01652c3e.jpg","comment_is_top":false,"comment_ctime":1540202451,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1540202451","product_id":100013101,"comment_content":"大家都用啥go开发工具","like_count":0,"discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143380,"discussion_content":"Goland","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579503831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}