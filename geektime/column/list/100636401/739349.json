{"id":739349,"title":"10｜Servlet Wrapper：如何维护Servlet生命周期及实现容器管理？","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上节课我们把Request和Response从无状态变成了有状态，实现了Session和Cookie的管理，还实现了同一页面的资源请求复用Socket，减少了性能消耗。</p><p>到目前为止，我们已经基本将浏览器与服务器之间的通信处理完毕。接下来我们再看后端服务器，现在我们还是使用ServletProcessor简单地调用Servlet的service方法，接下来我们考虑将其扩展，对Servlet进行管理，这就引入了Container容器的概念。<strong>我们计划让Container和Connector配合在一起工作，前者负责后端Servlet管理，而后者则负责通信管理。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/6e/42/6e0069a19d16f6ddf482820a06b8d242.png?wh=1920x998\" alt=\"图片\"></p><p>初步构建容器后，我们还会考虑使用Wrapper进行包装，用于维护Servlet的生命周期：初始化、提供服务、销毁这个全过程，把Servlet完全纳入程序自动管理之中，让应用程序员更少地感知到底层的配置，更专注于业务逻辑本身。</p><p>接下来我们一起来动手实现。</p><h2>项目结构</h2><p>这节课我们新增ServletContainer与ServletWrapper两个类，分别定义Container与Wrapper，你可以看一下现在的程序结构。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ server\n│  │  │  │  ├─ CookieTools.java\n│  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  ├─ HttpConnector.java\n│  │  │  │  ├─ HttpHeader.java\n│  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  ├─ HttpRequest.java\n│  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  ├─ HttpResponse.java\n│  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  ├─ HttpServer.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ ServletContainer.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  ├─ ServletWrapper.java\n│  │  │  │  ├─ Session.java\n│  │  │  │  ├─ SessionFacade.java\n│  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  ├─ StatisResourceProcessor.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  │  │  ├─ TestServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  │  ├─ TestServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><h2>Container——Servlet管理容器</h2><p>在改造之前，我们先关注一下整个Server的启动类——HttpServer。目前，我们的启动类是比较简单的，main函数内只有两行。</p><pre><code class=\"language-java\">package server;\npublic class HttpServer {\n&nbsp; &nbsp; public static void main(String[] args) {\n&nbsp; &nbsp; &nbsp; &nbsp; HttpConnector connector = new HttpConnector();\n&nbsp; &nbsp; &nbsp; &nbsp; connector.start();\n&nbsp; &nbsp; }\n}\n</code></pre><p>通过代码可以知道，我们Server的起点就是HttpConnector，所以之前对Servlet的管理也全是交由Connector进行处理，不过这并不好，角色混合了。所以接下来我们要做的，就是引入Container容器这个概念，将Servlet管理和网络通信功能一分为二。</p><p>首先是定义ServletContainer类。</p><pre><code class=\"language-java\">package server;\n//Servlet容器\npublic class ServletContainer {\n    HttpConnector connector = null;\n    ClassLoader loader = null;\n    //包含servlet类和实例的map\n    Map&lt;String,String&gt; servletClsMap = new ConcurrentHashMap&lt;&gt;(); //servletName - ServletClassName\n    Map&lt;String,Servlet&gt; servletInstanceMap = new ConcurrentHashMap&lt;&gt;();//servletName - servlet\n    public ServletContainer() {\n        try {\n            // create a URLClassLoader\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(HttpServer.WEB_ROOT);\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            urls[0] = new URL(null, repository, streamHandler);\n            loader = new URLClassLoader(urls);\n        } catch (IOException e) {\n            System.out.println(e.toString() );\n        }\n    }\n    public String getInfo() {\n        return null;\n    }\n    public ClassLoader getLoader(){\n        return this.loader;\n    }\n    public void setLoader(ClassLoader loader) {\n        this.loader = loader;\n    }\n    public HttpConnector getConnector() {\n        return connector;\n    }\n    public void setConnector(HttpConnector connector) {\n        this.connector = connector;\n    }\n    public String getName() {\n        return null;\n    }\n    public void setName(String name) {\n    }\n    //invoke方法用于从map中找到相关的servlet，然后调用\n    public void invoke(HttpRequest request, HttpResponse response)\n            throws IOException, ServletException {\n        Servlet servlet = null;\n        ClassLoader loader = getLoader();\n        String uri = request.getUri();\n        String servletName = uri.substring(uri.lastIndexOf(\"/\") + 1);\n        String servletClassName = servletName;\n        servlet = servletInstanceMap.get(servletName);\n        //如果容器内没有这个servlet，先要load类，创建新实例\n        if (servlet == null) {\n            Class&lt;?&gt; servletClass = null;\n            try {\n                servletClass = loader.loadClass(servletClassName);\n            } catch (ClassNotFoundException e) {\n                System.out.println(e.toString());\n            }\n            try {\n                servlet = (Servlet) servletClass.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n            servletClsMap.put(servletName, servletClassName);\n            servletInstanceMap.put(servletName, servlet);\n            //按照规范，创建新实例的时候需要调用init()\n            servlet.init(null);\n        }\n        //然后调用service()\n        try {\n            HttpRequestFacade requestFacade = new HttpRequestFacade(request);\n            HttpResponseFacade responseFacade = new HttpResponseFacade(response);\n            System.out.println(\"Call service()\");\n            servlet.service(requestFacade, responseFacade);\n        }\n        catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        catch (Throwable e) {\n            System.out.println(e.toString());\n        }\n    }\n}\n</code></pre><p>从ServletContainer的代码里，我们又看到了熟悉的面孔——ClassLoader，此前将ClassLoader直接交由HttpConnector管理，定义了域。</p><pre><code class=\"language-java\">public static URLClassLoader loader = null;\n</code></pre><p>现在进行改造，用新创建的ServletContainer类管理ClassLoader，并提供对应的 <code>getLoader()</code> 和 <code>setLoader()</code> 方法，同时也将原来在ServletProcessor内调用Servlet的代码挪到ServletContainer的 <code>invoke()</code> 方法中。</p><p>之前在调用 <code>invoke()</code> 方法时，每次都是加载Servlet的类进行实例化，并调用service方法，在这里我们进一步把Servlet放到Map中存起来，包含多Servlet实例，其中servletClsMap用于存储Servlet名称与Servlet类名的映射关系，而servletInstanceMap用于存储Servlet名称与具体Servlet对象的映射关系。</p><p>这样改造后，当 <code>invoke()</code> 方法被调用时，如果有Servlet实例，就直接调用 <code>service()</code>，如果没有实例，就加载并创建实例，并调用 <code>init()</code> 进行初始化工作。</p><p>现在ServletProcessor可以尽可能地简化了，你可以看一下简化后的代码。</p><pre><code class=\"language-java\">package server;\npublic class ServletProcessor {\n    private HttpConnector connector;\n    public ServletProcessor(HttpConnector connector) {\n        this.connector = connector;\n    }\n    public void process(HttpRequest request, HttpResponse response) throws IOException, ServletException {\n        this.connector.getContainer().invoke(request, response);\n    }\n}\n</code></pre><p>在ServletProcessor中我们定义了传入Connector的构造函数，所以在Processor代码中，需要调整初始化Processor的代码。</p><pre><code class=\"language-java\">if (request.getUri().startsWith(\"/servlet/\")) {\n    ServletProcessor processor = new ServletProcessor(this.connector);\n    processor.process(request, response);\n}\n</code></pre><p>接下来，我们再转向HttpConnector。在定义了Container之后，自然地，要把Container和Connector结合起来，我们在HttpConnector中改一下代码。</p><pre><code class=\"language-java\">package server;\npublic class HttpConnector implements Runnable {\n    int minProcessors = 3;\n    int maxProcessors = 10;\n    int curProcessors = 0;\n    Deque&lt;HttpProcessor&gt; processors = new ArrayDeque&lt;&gt;();\n    public static Map&lt;String, HttpSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();\n    //这是与connector相关联的container\n    ServletContainer container = null;\n    public void run() {\n        ServerSocket serverSocket = null;\n        int port = 8080;\n        try {\n            serverSocket = new ServerSocket(port, 1, InetAddress.getByName(\"127.0.0.1\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n        // initialize processors pool\n        for (int i = 0; i &lt; minProcessors; i++) {\n            HttpProcessor initprocessor = new HttpProcessor(this);\n            initprocessor.start();\n            processors.push(initprocessor);\n        }\n        curProcessors = minProcessors;\n        while (true) {\n            Socket socket = null;\n            try {\n                socket = serverSocket.accept();\n                HttpProcessor processor = createProcessor();\n                if (processor == null) {\n                    socket.close();\n                    continue;\n                }\n                processor.assign(socket);\n                // Close the socket\n//                socket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public void start() {\n        Thread thread = new Thread(this);\n        thread.start();\n    }\n    public ServletContainer getContainer() {\n        return container;\n    }\n    public void setContainer(ServletContainer container) {\n        this.container = container;\n    }\n}\n</code></pre><p>上述代码中，新增了ServletContainer类型的container属性，添加了对应 <code>getContainer()</code> 与 <code>setContainer()</code> 方法，移除了原本处理Classloader的相关代码。</p><p>这个时候，我们就可以调整HttpServer里的代码，拆分功能了。</p><pre><code class=\"language-java\">package server;\npublic class HttpServer {\n    public static final String WEB_ROOT =\n            System.getProperty(\"user.dir\") + File.separator + \"webroot\";\n    public static void main(String[] args) {\n        //创建connector和container\n        HttpConnector connector = new HttpConnector();\n        ServletContainer container = new ServletContainer();\n        //connector和container互相指引\n        connector.setContainer(container);\n        container.setConnector(connector);\n        connector.start();\n    }\n}\n</code></pre><p>这里我们进一步拆分了HttpConnector，做到了ServletContainer管理Servlet，HttpConnector负责通信管理，各司其职。</p><p>到这里，我想多说几句。软件结构应该怎么进行拆分？我们可以直观地将一个软件当成一个公司或者一个团体，里面有很多岗位和人，如果在公司里需要将某一个工作专门交由专人负责，就可以设置一个岗位，类比软件结构，就是在软件中新添加一个类，一个类就是一个岗位。这种拟人化的思考方式对我们分析软件结构很有帮助。</p><h2>Wrapper——增强Servlet管理</h2><p>刚刚我们已经使用Container实现了Servlet的管理，我们继续关注这一部分，<strong>采用Wrapper包装，用来维护Servlet的生命周期</strong>。</p><p>为什么需要这么一个Wrapper呢？从功能角度，不引入它也是没有问题的。但是如果没有Wrapper，我们就得在Container这个容器里直接管理Servlet，这相当于在一个大的纸盒子中直接放上很多小玩具，比较繁琐。</p><p>所以超市给了我们一个方案：每个小玩具外面套一个包装，比如小盒子或者是塑料袋子，再将这些小盒子或者袋子放在大纸盒中，方便人们拿取。这个Wrapper也是同样的思路。</p><p>首先我们来定义ServletWrapper类。</p><pre><code class=\"language-java\">package server;\npublic class ServletWrapper {\n    private Servlet instance = null;\n    private String servletClass;\n    private ClassLoader loader;\n    private String name;\n    protected ServletContainer parent = null;\n    public ServletWrapper(String servletClass, ServletContainer parent) {\n        this.parent = parent;\n        this.servletClass = servletClass;\n        try {\n            loadServlet();\n        } catch (ServletException e) {\n            e.printStackTrace();\n        }\n    }\n    public ClassLoader getLoader() {\n        if (loader != null)\n            return loader;\n        return parent.getLoader();\n    }\n    public String getServletClass() {\n        return servletClass;\n    }\n    public void setServletClass(String servletClass) {\n        this.servletClass = servletClass;\n    }\n    public ServletContainer getParent() {\n        return parent;\n    }\n    public void setParent(ServletContainer container) {\n        parent = container;\n    }\n    public Servlet getServlet(){\n        return this.instance;\n    }\n    public Servlet loadServlet() throws ServletException {\n        if (instance!=null)\n            return instance;\n        Servlet servlet = null;\n        String actualClass = servletClass;\n        if (actualClass == null) {\n            throw new ServletException(\"servlet class has not been specified\");\n        }\n        ClassLoader classLoader = getLoader();\n        Class classClass = null;\n        try {\n            if (classLoader!=null) {\n                classClass = classLoader.loadClass(actualClass);\n            }\n        }\n        catch (ClassNotFoundException e) {\n            throw new ServletException(\"Servlet class not found\");\n        }\n        try {\n            servlet = (Servlet) classClass.newInstance();\n        }\n        catch (Throwable e) {\n            throw new ServletException(\"Failed to instantiate servlet\");\n        }\n        try {\n            servlet.init(null);\n        }\n        catch (Throwable f) {\n            throw new ServletException(\"Failed initialize servlet.\");\n        }\n        instance =servlet;\n        return servlet;\n    }\n    public void invoke(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        if (instance != null) {\n            instance.service(request, response);\n        }\n    }\n}\n</code></pre><p>在ServletWrapper类中，核心在于 <code>loadServlet()</code> 方法，主要是通过一个Classloader加载并实例化Servlet，然后调用 <code>init()</code> 方法进行初始化工作，其实也是刚刚我们在ServletContainer中的处理。所以在ServletContainer类里，我们可以进一步改造，将一些对Servlet的处理交给ServletWrapper进行。</p><p>首先是servletInstanceMap，Value类型可设置成更高层次的ServletWrapper，你可以看一下修改后的样子。</p><pre><code class=\"language-java\">Map&lt;String,ServletWrapper&gt; servletInstanceMap = new ConcurrentHashMap&lt;&gt;();\n</code></pre><p>其次是调整invoke方法，你可以看一下调整后的invoke方法。</p><pre><code class=\"language-java\">public void invoke(HttpRequest request, HttpResponse response)\n        throws IOException, ServletException {\n    ServletWrapper servletWrapper = null;\n    String uri = request.getUri();\n    String servletName = uri.substring(uri.lastIndexOf(\"/\") + 1);\n    String servletClassName = servletName;\n    servletWrapper = servletInstanceMap.get(servletName);\n    if ( servletWrapper == null) {\n        servletWrapper = new ServletWrapper(servletClassName,this);\n        //servletWrapper.setParent(this);\n        this.servletClsMap.put(servletName, servletClassName);\n        this.servletInstanceMap.put(servletName, servletWrapper);\n    }\n    try {\n        HttpServletRequest requestFacade = new HttpRequestFacade(request);\n        HttpServletResponse responseFacade = new HttpResponseFacade(response);\n        System.out.println(\"Call service()\");\n        servletWrapper.invoke(requestFacade, responseFacade);\n    }\n    catch (Exception e) {\n        System.out.println(e.toString());\n    }\n    catch (Throwable e) {\n        System.out.println(e.toString());\n    }\n}\n</code></pre><p>这样在ServletContainer中，只是获取到ServletWrapper的实例，调用ServletWrapper内的 <code>invoke()</code> 方法，进一步进行了解耦。</p><h2>测试</h2><p>这节课并没有功能性的变化，所以没有新增测试类，还是和之前的测试方式保持一致。这里就不重复说了。</p><h2>小结</h2><p>这节课我们实现了ServletContainer管理全部的Servlet，将原本的管理功能从Connector内抽离，让Connector专注服务器通信管理。这个Container就是我们MiniTomcat初始容器，它里面有一个map，包含了管理的Servlet实例。有了这个Container，Processor就变得简单了，它里面的新方法 <code>process()</code> 只需要调用Container的 <code>invoke()</code> 就可以了。</p><p>同时，我们引入ServletWrapper，对ServletContainer做了更进一步的拆分，更加方便对Servlet进行管理。今后，我们会把Container进一步拆成多层。</p><p>本节课代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter10\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter10</a></p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：现在这个HttpServer仅仅只是创建Connector和Container，只是一个壳子了，按照拟人化的思路，HttpServer应该是一个公司，那么这个类从道理上还应该分工负责做些什么？</p><p>欢迎你把你思考后的结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":386066,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1703948052,"is_pvip":false,"replies":[{"id":140779,"content":"应该是Cookie比较简单吧，javax.servlet.http里面就直接实现了。\nC++服务器一样多得很，Apache，Nginx，微软的IIS，还有很多游戏服务器，为了性能都用的C&#47;C++写的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1704328233,"ip_address":"湖南","comment_id":386066,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师两个问题：\nQ1：为什么Cookie有实现而Session没有实现？\n代码中的Session类实现了HttpSession接口，但代码中用的Cookie是系统提供的。为什么Session就没有系统提供的实现类？\n\nQ2：C++服务器有哪些？\n看到一篇介绍用C++开发服务器的文章，说明有C++开发的服务器。Tomcat是用Java开发的。那么，有什么C++开发的服务器产品？用在什么场景下？互联网公司一般不用C++服务器吧。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635025,"discussion_content":"应该是Cookie比较简单吧，javax.servlet.http里面就直接实现了。\nC++服务器一样多得很，Apache，Nginx，微软的IIS，还有很多游戏服务器，为了性能都用的C/C++写的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704328233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386008,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1703834484,"is_pvip":false,"replies":[{"id":140708,"content":"各自都有各自的解决方案。我是这么想的，connector相当于公司的销售部门，把客户引进到公司，container是客户服务部门，满足客户需求。所以作为一个公司，还要有一些管理职能的部门，以及支撑销售部和客户服务部的部门。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1704027207,"ip_address":"湖南","comment_id":386008,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请一个副总吧， 管理每个部门的 Connector 和 Container， 负责他们两个创建和相互引用","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634825,"discussion_content":"各自都有各自的解决方案。我是这么想的，connector相当于公司的销售部门，把客户引进到公司，container是客户服务部门，满足客户需求。所以作为一个公司，还要有一些管理职能的部门，以及支撑销售部和客户服务部的部门。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1704027208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1133678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","nickname":"HH🐷🐠","note":"","ucode":"C50172BDA604D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634837,"discussion_content":"明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704067933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634825,"ip_address":"广东","group_id":0},"score":634837,"extra":""}]}]},{"had_liked":false,"id":391625,"user_name":"silentyears","can_delete":false,"product_type":"c1","uid":1061748,"ip_address":"北京","ucode":"6E137BFEB874CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/74/d9d143fa.jpg","comment_is_top":false,"comment_ctime":1718691883,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"老师，connector和container互相指引，这种类的依赖关系是不是不太好？像在spring中就是循环依赖","like_count":0},{"had_liked":false,"id":386113,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1704117819,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"发的留言怎么没有显示出来，再发一次：\nQ1：为什么Cookie有实现而Session没有实现？\n代码中的Session类实现了HttpSession接口，但代码中用的Cookie是系统提供的。为什么Session就没有系统提供的实现类？\n\nQ2：C++服务器有哪些？\n看到一篇介绍用C++开发服务器的文章，说明有C++开发的服务器。Tomcat是用Java开发的。那么，有什么C++开发的服务器产品？用在什么场景下？互联网公司一般不用C++服务器吧。","like_count":0,"discussions":[{"author":{"id":1126661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/31/05/9028e9ac.jpg","nickname":"ctt","note":"","ucode":"FA87B9E86FD308","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635008,"discussion_content":"Cookie遵循了HTTP标准，且功能单一；不同的Web服务器可能会以不同的方式管理会话数据或优化性能，接口是为了方便扩展","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704275787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}