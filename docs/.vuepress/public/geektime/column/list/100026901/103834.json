{"id":103834,"title":"23 | 你真的懂Python GIL（全局解释器锁）吗？","content":"<p>你好，我是景霄。</p><p>前面几节课，我们学习了Python的并发编程特性，也了解了多线程编程。事实上，Python多线程另一个很重要的话题——GIL（Global Interpreter Lock，即全局解释器锁）却鲜有人知，甚至连很多Python“老司机”都觉得GIL就是一个谜。今天我就来为你解谜，带你一起来看GIL。</p><h2>一个不解之谜</h2><p>耳听为虚，眼见为实。我们不妨先来看一个例子，让你感受下GIL为什么会让人不明所以。</p><p>比如下面这段很简单的cpu-bound代码：</p><pre><code>def CountDown(n):\n    while n &gt; 0:\n        n -= 1\n</code></pre><p>现在，假设一个很大的数字n = 100000000，我们先来试试单线程的情况下执行CountDown(n)。在我手上这台号称8核的MacBook上执行后，我发现它的耗时为5.4s。</p><p>这时，我们想要用多线程来加速，比如下面这几行操作：</p><pre><code>from threading import Thread\n\nn = 100000000\n\nt1 = Thread(target=CountDown, args=[n // 2])\nt2 = Thread(target=CountDown, args=[n // 2])\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n</code></pre><p>我又在同一台机器上跑了一下，结果发现，这不仅没有得到速度的提升，反而让运行变慢，总共花了9.6s。</p><p>我还是不死心，决定使用四个线程再试一次，结果发现运行时间还是9.8s，和2个线程的结果几乎一样。</p><p>这是怎么回事呢？难道是我买了假的MacBook吗？你可以先自己思考一下这个问题，也可以在自己电脑上测试一下。我当然也要自我反思一下，并且提出了下面两个猜想。</p><!-- [[[read_end]]] --><p>第一个怀疑：我的机器出问题了吗？</p><p>这不得不说也是一个合理的猜想。因此我又找了一个单核CPU的台式机，跑了一下上面的实验。这次我发现，在单核CPU电脑上，单线程运行需要11s时间，2个线程运行也是11s时间。虽然不像第一台机器那样，多线程反而比单线程更慢，但是这两次整体效果几乎一样呀！</p><p>看起来，这不像是电脑的问题，而是Python的线程失效了，没有起到并行计算的作用。</p><p>顺理成章，我又有了第二个怀疑：Python的线程是不是假的线程？</p><p>Python的线程，的的确确封装了底层的操作系统线程，在Linux系统里是Pthread（全称为POSIX Thread），而在Windows系统里是Windows Thread。另外，Python的线程，也完全受操作系统管理，比如协调何时执行、管理内存资源、管理中断等等。</p><p>所以，虽然Python的线程和C++的线程本质上是不同的抽象，但它们的底层并没有什么不同。</p><h2>为什么有GIL？</h2><p>看来我的两个猜想，都不能解释开头的这个未解之谜。那究竟谁才是“罪魁祸首”呢？事实上，正是我们今天的主角，也就是GIL，导致了Python线程的性能并不像我们期望的那样。</p><p>GIL，是最流行的Python解释器CPython中的一个技术术语。它的意思是全局解释器锁，本质上是类似操作系统的Mutex。每一个Python线程，在CPython解释器中执行时，都会先锁住自己的线程，阻止别的线程执行。</p><p>当然，CPython会做一些小把戏，轮流执行Python线程。这样一来，用户看到的就是“伪并行”——Python线程在交错执行，来模拟真正并行的线程。</p><p>那么，为什么CPython需要GIL呢？这其实和CPython的实现有关。下一节我们会讲Python的内存管理机制，今天先稍微提一下。</p><p>CPython使用引用计数来管理内存，所有Python脚本中创建的实例，都会有一个引用计数，来记录有多少个指针指向它。当引用计数只有0时，则会自动释放内存。</p><p>什么意思呢？我们来看下面这个例子：</p><pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; a = []\n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; sys.getrefcount(a)\n3\n</code></pre><p>这个例子中，a的引用计数是3，因为有a、b和作为参数传递的getrefcount这三个地方，都引用了一个空列表。</p><p>这样一来，如果有两个Python线程同时引用了a，就会造成引用计数的race condition，引用计数可能最终只增加1，这样就会造成内存被污染。因为第一个线程结束时，会把引用计数减少1，这时可能达到条件释放内存，当第二个线程再试图访问a时，就找不到有效的内存了。</p><p>所以说，CPython  引进 GIL 其实主要就是这么两个原因：</p><ul>\n<li>一是设计者为了规避类似于内存管理这样的复杂的竞争风险问题（race condition）；</li>\n<li>二是因为CPython大量使用C语言库，但大部分C语言库都不是原生线程安全的（线程安全会降低性能和增加复杂度）。</li>\n</ul><h2>GIL是如何工作的？</h2><p>下面这张图，就是一个GIL在Python程序的工作示例。其中，Thread 1、2、3轮流执行，每一个线程在开始执行时，都会锁住GIL，以阻止别的线程执行；同样的，每一个线程执行完一段后，会释放GIL，以允许别的线程开始利用资源。</p><p><img src=\"https://static001.geekbang.org/resource/image/db/8d/dba8e4a107829d0b72ea513be34fe18d.png?wh=720*272\" alt=\"\"></p><p>细心的你可能会发现一个问题：为什么Python线程会去主动释放GIL呢？毕竟，如果仅仅是要求Python线程在开始执行时锁住GIL，而永远不去释放GIL，那别的线程就都没有了运行的机会。</p><p>没错，CPython中还有另一个机制，叫做check_interval，意思是CPython解释器会去轮询检查线程GIL的锁住情况。每隔一段时间，Python解释器就会强制当前线程去释放GIL，这样别的线程才能有执行的机会。</p><p>不同版本的Python中，check interval的实现方式并不一样。早期的Python是100个ticks，大致对应了1000个bytecodes；而 Python 3以后，interval是15毫秒。当然，我们不必细究具体多久会强制释放GIL，这不应该成为我们程序设计的依赖条件，我们只需明白，CPython解释器会在一个“合理”的时间范围内释放GIL就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/42/88/42791f4cf34c0a784f466be22efeb388.png?wh=646*160\" alt=\"\"></p><p>整体来说，每一个Python线程都是类似这样循环的封装，我们来看下面这段代码：</p><pre><code>for (;;) {\n    if (--ticker &lt; 0) {\n        ticker = check_interval;\n    \n        /* Give another thread a chance */\n        PyThread_release_lock(interpreter_lock);\n    \n        /* Other threads may run now */\n    \n        PyThread_acquire_lock(interpreter_lock, 1);\n    }\n\n    bytecode = *next_instr++;\n    switch (bytecode) {\n        /* execute the next instruction ... */ \n    }\n}\n</code></pre><p>从这段代码中，我们可以看到，每个Python线程都会先检查ticker计数。只有在ticker大于0的情况下，线程才会去执行自己的bytecode。</p><h2>Python的线程安全</h2><p>不过，有了GIL，并不意味着我们Python编程者就不用去考虑线程安全了。即使我们知道，GIL仅允许一个Python线程执行，但前面我也讲到了，Python还有check interval这样的抢占机制。我们来考虑这样一段代码：</p><pre><code>import threading\n\nn = 0\n\ndef foo():\n    global n\n    n += 1\n\nthreads = []\nfor i in range(100):\n    t = threading.Thread(target=foo)\n    threads.append(t)\n\nfor t in threads:\n    t.start()\n\nfor t in threads:\n    t.join()\n\nprint(n)\n</code></pre><p>如果你执行的话，就会发现，尽管大部分时候它能够打印100，但有时侯也会打印99或者98。</p><p>这其实就是因为，<code>n+=1</code>这一句代码让线程并不安全。如果你去翻译foo这个函数的bytecode，就会发现，它实际上由下面四行bytecode组成：</p><pre><code>&gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(foo)\nLOAD_GLOBAL              0 (n)\nLOAD_CONST               1 (1)\nINPLACE_ADD\nSTORE_GLOBAL             0 (n)\n</code></pre><p>而这四行bytecode中间都是有可能被打断的！</p><p>所以，千万别想着，有了GIL你的程序就可以高枕无忧了，我们仍然需要去注意线程安全。正如我开头所说，<strong>GIL的设计，主要是为了方便CPython解释器层面的编写者，而不是Python应用层面的程序员</strong>。作为Python的使用者，我们还是需要lock等工具，来确保线程安全。比如我下面的这个例子：</p><pre><code>n = 0\nlock = threading.Lock()\n\ndef foo():\n    global n\n    with lock:\n        n += 1\n</code></pre><h2>如何绕过GIL？</h2><p>学到这里，估计有的Python使用者感觉自己像被废了武功一样，觉得降龙十八掌只剩下了一掌。其实大可不必，你并不需要太沮丧。Python的GIL，是通过CPython的解释器加的限制。如果你的代码并不需要CPython解释器来执行，就不再受GIL的限制。</p><p>事实上，很多高性能应用场景都已经有大量的C实现的Python库，例如NumPy的矩阵运算，就都是通过C来实现的，并不受GIL影响。</p><p>所以，大部分应用情况下，你并不需要过多考虑GIL。因为如果多线程计算成为性能瓶颈，往往已经有Python库来解决这个问题了。</p><p>换句话说，如果你的应用真的对性能有超级严格的要求，比如100us就对你的应用有很大影响，那我必须要说，Python可能不是你的最优选择。</p><p>当然，可以理解的是，我们难以避免的有时候就是想临时给自己松松绑，摆脱GIL，比如在深度学习应用里，大部分代码就都是Python的。在实际工作中，如果我们想实现一个自定义的微分算子，或者是一个特定硬件的加速器，那我们就不得不把这些关键性能（performance-critical）代码在C++中实现（不再受GIL所限），然后再提供Python的调用接口。</p><p>总的来说，你只需要重点记住，绕过GIL的大致思路有这么两种就够了：</p><ol>\n<li>绕过CPython，使用JPython（Java实现的Python解释器）等别的实现；</li>\n<li>把关键性能代码，放到别的语言（一般是C++）中实现。</li>\n</ol><h2>总结</h2><p>今天这节课，我们先通过一个实际的例子，了解了GIL对于应用的影响；之后我们适度剖析了GIL的实现原理，你不必深究一些原理的细节，明白其主要机制和存在的隐患即可。</p><p>自然，我也为你提供了绕过GIL的两种思路。不过还是那句话，很多时候，我们并不需要过多纠结GIL的影响。</p><h2>思考题</h2><p>最后，我给你留下两道思考题。</p><p>第一问，在我们处理cpu-bound的任务（文中第一个例子）时，为什么有时候使用多线程会比单线程还要慢些？</p><p>第二问，你觉得GIL是一个好的设计吗？事实上，在Python 3之后，确实有很多关于GIL改进甚至是取消的讨论，你的看法是什么呢？你在平常工作中有被GIL困扰过的场景吗？</p><p>欢迎在留言区写下你的想法，也欢迎你把今天的内容分享给你的同事朋友，我们一起交流、一起进步。</p><p></p>","neighbors":{"left":{"article_title":"22 | 并发编程之Asyncio","id":103358},"right":{"article_title":"24 | 带你解析 Python 垃圾回收机制","id":104265}},"comments":[{"had_liked":false,"id":111020,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1562423939,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"547023270531","product_id":100026901,"comment_content":"先mark一下学到的知识点：<br>一、查看引用计数的方法：sys.getrefcount(a)<br>二、CPython引进GIL的主要原因是：<br>1. 设计者为了规避类似内存管理这样的复杂竞争风险问题（race condition）；<br>2. CPython大量使用C语言库，但大部分C语言库都不是线程安全的（线程安全会降低性能和增加复杂度）。<br>三、绕过GIL的两种思路：<br>1. 绕过CPython，使用JPython等别的实现；<br>2. 把关键性能代码放到其他语言中实现，比如C++。<br><br><br>问答老师的问题：<br>1. cpu-bound属于计算密集型程序，用多线程运行时，每个线程在开始执行时都会锁住GIL、执行完会释放GIL，这两个步骤比较费时。相比单线程就没有切换线程的问题，所以更快。<br>相反，在处理多阻塞高延迟的IO密集型程序时，因为多线程有check interval机制，若遇阻塞，CPython会强制当前线程让出（释放）GIL，给其他线程执行的机会。所以能提高程序的执行效率。<br>2. 第二个问题摘抄了知乎上的讨论：<br>在python3中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后interval=15毫秒，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低。<br>经常会听到老手说：“python下想要充分利用多核CPU，就用多进程”，原因是什么呢？原因是：每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。所以我们能够得出结论：多核下，想做并行提升效率，比较通用的方法是使用多进程，能够有效提高执行效率。","like_count":128,"discussions":[{"author":{"id":1528751,"avatar":"https://static001.geekbang.org/account/avatar/00/17/53/af/e5bf5d08.jpg","nickname":"lllong33","note":"","ucode":"5D012385994C3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3113,"discussion_content":"多核多线程比单核多线程更差...\n但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低。\n-------------------\n有疑问，多核怎么出现GIL的竞争？有点不能理解为啥多核的情况，还去抢别的cpu的线程，是因为线程不够？有什么场景嘛? \n我的理解是：cpu0的线程不应该去cpu1拿资源。这样很奇怪。我的认知是单进程对应很多线程，单线程对应多协程。。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564197126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1371633,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132","nickname":"程序水果宝","note":"","ucode":"1700DDFE073A56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75678,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575765212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108975,"user_name":"leixin","can_delete":false,"product_type":"c1","uid":1318291,"ip_address":"","ucode":"9885DF5FB2E136","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/szNEybCR1Al4p6eDyT8atNjen7ZY9cBJSXOQl1EnrTM2efiaHlPtL7X44JeibXs9qEFLWv6HJWBwq5tVlNahGDGQ/132","comment_is_top":false,"comment_ctime":1561943331,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"156180765987","product_id":100026901,"comment_content":"有重要的一点没讲，GIL会在遇到io的时候自动释放，给其他线程执行的机会，这样Python多线程在io阻塞的多任务中有效。","like_count":37,"discussions":[{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310419,"discussion_content":"老师之前的说法：21讲\n“事实上，Python 的解释器并不是线程安全的，为了解决由此带来的 race condition 等问题，Python 便引入了全局解释器锁，也就是同一时刻，只允许一个线程执行。当然，在执行 I/O 操作时，如果一个线程被 block 了，全局解释器锁便会被释放，从而让另一个线程能够继续执行。”\n\n我是感觉自己有点混淆 block 和 lock，什么叫一个线程被block了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601822423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531768,"discussion_content":"阻塞。一般是因为缺少了某种资源/条件，即使给这个线程CPU，它也无法执行下去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637411147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310419,"ip_address":""},"score":531768,"extra":"{\"user_type\":1}"}]},{"author":{"id":2023589,"avatar":"","nickname":"苏泽敏","note":"","ucode":"E88B6B535BF04C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394546,"discussion_content":"block指的是lock的反义词？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631932027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108958,"user_name":"leixin","can_delete":false,"product_type":"c1","uid":1318291,"ip_address":"","ucode":"9885DF5FB2E136","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/szNEybCR1Al4p6eDyT8atNjen7ZY9cBJSXOQl1EnrTM2efiaHlPtL7X44JeibXs9qEFLWv6HJWBwq5tVlNahGDGQ/132","comment_is_top":false,"comment_ctime":1561942185,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"147590830249","product_id":100026901,"comment_content":"老师，我曾经去某大厂面试。人家问了我几个问题，比说说，你知道元类吗？Python是如何解决循环引用的？换句话说，Python的垃圾回收机制是如何？我后来自己找了些资料看了，还是，不是理解的特别明白。老师后面的课程能帮我们讲解下吗？","like_count":33,"discussions":[{"author":{"id":1914504,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","nickname":"Simon","note":"","ucode":"A8A2E3E57BD029","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220627,"discussion_content":"元类就是metaclass，已讲过","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585909033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144637,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1571987755,"is_pvip":false,"replies":[{"id":"63092","content":"讲的不错","user_name":"作者回复","user_name_real":"Yuannan蔡元楠","uid":"1257426","ctime":1577248136,"ip_address":"","comment_id":144637,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48816628011","product_id":100026901,"comment_content":"思考题1：<br>由于GIL采用轮流运行线程的机制，GIL需要在线程之间不断轮流进行切换，线程如果较多或运行时间较长，切换带来的性能损失可能会超过单线程。<br><br>思考题2：<br>个人觉得GIL仍然是一种好的设计，虽然损失了一些性能，但在保证资源不发生冲突，预防死锁方面还是有一定作用的。<br><br>以上是个人的一点肤浅理解，请老师指正。","like_count":11,"discussions":[{"author":{"id":1257426,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/d2/0b6a8945.jpg","nickname":"Yuannan蔡元楠","note":"","ucode":"695E183CE496A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472045,"discussion_content":"讲的不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577248136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757369,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d0/b9/f89ce558.jpg","nickname":"kingsley","note":"","ucode":"B5C86B601A25AA","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540187,"discussion_content":"实际有遇到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639984580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108905,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1561920310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44511593270","product_id":100026901,"comment_content":"python的单线程和多线程同时都只能利用一颗cpu核心，对于纯cpu heavy任务场景，不涉及到io耗时环节，cpu都是充分利用的，多线程和单线程相比反倒是多了线程切换的成本，所以性能反而不如单线程。","like_count":10},{"had_liked":false,"id":109101,"user_name":"SCAR","can_delete":false,"product_type":"c1","uid":1031209,"ip_address":"","ucode":"38C0927FA3C5FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/29/022905e6.jpg","comment_is_top":false,"comment_ctime":1561962589,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35921700957","product_id":100026901,"comment_content":"1.cpu-bound任务的多线程相比单线程，时间的增加在于锁添加的获取和释放的开销结果。<br>2.返回到python诞生的年代，GIL相对来说是合理而且有效率的，它易于实现，很容易就添加到python中，而且它为单线程程序提供了性能提升。以至于Guido在“It isn&#39;t Easy to Remove the GIL”里面说“ I&#39;d welcome a set of patches into Py3k only if the performance for a single-threaded program (and for a multi-threaded but I&#47;O-bound program) does not decrease”。而到现在为止，任何尝试都没有达到这一条件。<br><br>","like_count":8,"discussions":[{"author":{"id":1524797,"avatar":"https://static001.geekbang.org/account/avatar/00/17/44/3d/35d6670d.jpg","nickname":"Claywoow","note":"","ucode":"1F1C70BCE33536","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1176,"discussion_content":"优秀的同学可以多说一些呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562332277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171840,"user_name":"jackstraw","can_delete":false,"product_type":"c1","uid":1137207,"ip_address":"","ucode":"C967D2D6158F99","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/37/8775d714.jpg","comment_is_top":false,"comment_ctime":1579045136,"is_pvip":false,"replies":[{"id":"66785","content":"对","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1579135570,"ip_address":"","comment_id":171840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27348848912","product_id":100026901,"comment_content":"关于绕过GIL的第二个方式：将关键的性能代码放到别的语言中（通常C++）实现；这种解决方式指的是在别的语言中使用多线程的方式处理任务么？就是不用python的多线程，而是在别的语言中使用多线程？","like_count":7,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481531,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579135570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108921,"user_name":"farFlight","can_delete":false,"product_type":"c1","uid":1245211,"ip_address":"","ucode":"B0872D3ECBEC38","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbRibsic15KXfGEN3SSjnLhXGyhK2Uyrj5ibBJsKAjicNqtafDaQOLH4xpSJRZD1vmibFPJER1ySmwP9A/132","comment_is_top":false,"comment_ctime":1561937580,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14446839468","product_id":100026901,"comment_content":"另外，在测试不加锁的 foo 函数的时候，我这里循环测试10000次也不会见到n!=100的情况，这是为什么呢？","like_count":3,"discussions":[{"author":{"id":1276373,"avatar":"https://static001.geekbang.org/account/avatar/00/13/79/d5/4a7971fc.jpg","nickname":"Ethan","note":"","ucode":"016F1DEBA895B8","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16189,"discussion_content":"可以使用 Python2 进行测试，Python 3 做了相应的优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568875405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221419,"user_name":"Kfreer","can_delete":false,"product_type":"c1","uid":1114448,"ip_address":"","ucode":"0B6BA0603963C3","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/50/9ac4905e.jpg","comment_is_top":false,"comment_ctime":1590496738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10180431330","product_id":100026901,"comment_content":"1在我们处理 cpu-bound 的任务（文中第一个例子）时，为什么有时候使用多线程会比单线程还要慢些？<br>答：由于CPython中GIL的存在（运行线程前需要先获取GIL），所以即便是多线程运行，同一时刻也只能有一个线程处于运行状态，且切线程之间切换时还要消耗一部分资源。这就导致cpu密集型任务下多线程反而没有单线程运行的快。<br><br>2你觉得 GIL 是一个好的设计吗？事实上，在 Python 3 之后，确实有很多关于 GIL 改进甚至是取消的讨论，你的看法是什么呢？你在平常工作中有被 GIL 困扰过的场景吗？<br>答：不是一个好的设计，仅仅是简化了解释器的设计，且并没有解决线程安全的问题。<br><br>总结：CPU密集型任务用多进程并行处理（CPU需多核），I&#47;O密集型任务用协程，理论上协程比多线程的效率还要高。","like_count":2},{"had_liked":false,"id":109125,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1561966946,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"10151901538","product_id":100026901,"comment_content":"t1 = Thread(target=CountDown, args=[n &#47;&#47; 2]) 老师，这段代码里面n&#47;&#47;2是什么意思？","like_count":2,"discussions":[{"author":{"id":1199670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4e/36/de029ebf.jpg","nickname":"🐬Innocence","note":"","ucode":"7CBAB4976FACE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38664,"discussion_content":"因为Thread后的args接受的参数必须是个iterator，也就是可迭代对象，所以可以用list包裹起来里面，再在里面分成两份做两个线程的处理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571815382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1199670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4e/36/de029ebf.jpg","nickname":"🐬Innocence","note":"","ucode":"7CBAB4976FACE0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310443,"discussion_content":"我不太懂为什么 Thread 后的 args 必须是迭代器，我查了官方文档好像是说“args is the argument tuple”\nclass threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)\nargs is the argument tuple for the target invocation. Defaults to ().","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601852919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":38664,"ip_address":""},"score":310443,"extra":""}]},{"author":{"id":1126441,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","nickname":"小侠龙旋风","note":"","ucode":"073F3924A99835","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1232,"discussion_content":"地板除，向下取整","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562420930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113668,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","nickname":"程序员人生","note":"","ucode":"C5C5073D89AAA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":977,"discussion_content":"自己回答：//算术运算符是 取整除 - 向下取接近除数的整数\n例子：\n>>> 9//2\n4\n>>> -9//2\n-5","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562216718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1914504,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","nickname":"Simon","note":"","ucode":"A8A2E3E57BD029","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220626,"discussion_content":"本来总的任务是n，开启了两个线程，每个线程的任务量就是总的一半：n//2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585908914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341402,"avatar":"https://static001.geekbang.org/account/avatar/00/14/77/da/54c663f3.jpg","nickname":"Wing·三金","note":"","ucode":"6B9F5822C3717F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":962,"discussion_content":"a // b 相当于 numpy.ceil(a / b)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562209842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242702,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f6/4e/0066303c.jpg","nickname":"cuikt","note":"","ucode":"9A1DB426CEFEEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":849,"discussion_content":"// 表示取绝对值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562121008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":701,"discussion_content":"平均分成两份数据，用来给两个线程分别执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561970174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247964,"user_name":"张巡","can_delete":false,"product_type":"c1","uid":1984969,"ip_address":"","ucode":"500B6A68C325B9","user_header":"","comment_is_top":false,"comment_ctime":1599958143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894925439","product_id":100026901,"comment_content":"这是mackbook被黑的最惨的一次，哈哈哈","like_count":2},{"had_liked":false,"id":141115,"user_name":"自由民","can_delete":false,"product_type":"c1","uid":1346236,"ip_address":"","ucode":"435C67531697F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/bc/cb39ed38.jpg","comment_is_top":false,"comment_ctime":1571116803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866084099","product_id":100026901,"comment_content":"思考题<br>1.线程切换有开销成本，另外最主要是由于GIL的存在使python的并行为伪并行。<br>2.我觉得不是好设计，像戴着镣铐跳舞，好处仅仅是简化了解释器的设计。而且它并不能完全解决线程安全问题。但我平时很少用多线程编程，所以还没有实际体会。而像解释器这样的基础设施应该是把脏活留给自己，尽量减少用户的复杂性。类似还有从python2到python3的大变动。","like_count":1},{"had_liked":false,"id":109122,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1561966475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856933771","product_id":100026901,"comment_content":"通过老师的讲解，我觉得GIL有点像java的Synchronized 监视器锁，同一时刻只有一个线程获得监视器锁。所以线程的频繁切换，会增加CPU开销，导致多线程反而速度变慢。","like_count":1},{"had_liked":false,"id":346995,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1653609977,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653609977","product_id":100026901,"comment_content":"如果是通过Threading创建多线程，多线程跑python API封装的C++程序，这样是受限GIL的。而把创建多线程的工作放到C++程序里，就不被GIL所累了。","like_count":0},{"had_liked":false,"id":310219,"user_name":"锋","can_delete":false,"product_type":"c1","uid":1948762,"ip_address":"","ucode":"61A3ACB1D14CAF","user_header":"https://static001.geekbang.org/account/avatar/00/1d/bc/5a/855160ca.jpg","comment_is_top":false,"comment_ctime":1630551901,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1630551901","product_id":100026901,"comment_content":"check_interval有可能导致线程饿死吗","like_count":0},{"had_liked":false,"id":283813,"user_name":"sugar","can_delete":false,"product_type":"c1","uid":2184057,"ip_address":"","ucode":"491906283FC13B","user_header":"https://static001.geekbang.org/account/avatar/00/21/53/79/327ef30e.jpg","comment_is_top":false,"comment_ctime":1615945723,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1615945723","product_id":100026901,"comment_content":"处理计算密集任务，多线程的来回切换消耗资源，所以不及单线程","like_count":0},{"had_liked":false,"id":282887,"user_name":"zys","can_delete":false,"product_type":"c1","uid":2508685,"ip_address":"","ucode":"594399D8EA484D","user_header":"https://static001.geekbang.org/account/avatar/00/26/47/8d/5d2f4acd.jpg","comment_is_top":false,"comment_ctime":1615452341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615452341","product_id":100026901,"comment_content":"一核心的cpu对应一个完美的python执行.<br>需要多核心并行,多开,或者调用,其他库来使用就行了,,本质来讲,gil习惯了,也没什么啊 ","like_count":0},{"had_liked":false,"id":175629,"user_name":"苹果","can_delete":false,"product_type":"c1","uid":1761988,"ip_address":"","ucode":"5D0FA9D8560FD8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e2/c4/25acaa38.jpg","comment_is_top":false,"comment_ctime":1580785886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580785886","product_id":100026901,"comment_content":"自己的比喻理解<br>1，单线程，有语文（1），数学（2），英语（3）作业，按照顺序123写问作业<br>2，多线程，在Cpython解释器种，有GIL存在，按照check interval 机制，是语文作业写5分钟，换着数学作业写5分钟，英语5分钟，在换着语文写：线程阻塞的情况，理解为数学有道题目很难，（I&#47;O密集）提前不做，释放出来，<br>3，多进程，找两个人帮忙做，三个人分别做语文，数学，英语，最后完成的算终止时间，<br>线程安全理解为，做语文作业时，不需要用到数学作业里的资料，工具，","like_count":0},{"had_liked":false,"id":153899,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574327887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574327887","product_id":100026901,"comment_content":"GIL在Python作为脚本或者客户端程序没问题，作为高性能程序多少有点问题。当引入协程后，并发被很好处理，现在只剩下并行不太理想，用的是多进程模型，没有利用操作系统最小调度单元。","like_count":0},{"had_liked":false,"id":153892,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574326622,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574326622","product_id":100026901,"comment_content":"Python 多线程是伪多线程。","like_count":0},{"had_liked":false,"id":140418,"user_name":"扶幽","can_delete":false,"product_type":"c1","uid":1322612,"ip_address":"","ucode":"1400EDFF8970D3","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/74/88c613e0.jpg","comment_is_top":false,"comment_ctime":1570935766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570935766","product_id":100026901,"comment_content":"第一问：因为Python中有GIL的存在，使得在每一个时刻都只能有一个线程在运行。如果强行使用多线程的话，线程的切换回耗费额外的资源，所有运行更慢；<br>第二问：有，使用Python编写的有限元数值程序运算很慢，而且当时也不懂什么线程安不安全，也不会加锁，最后算出来的结果怎么都跟标准答案对不上。<br>:-P","like_count":0},{"had_liked":false,"id":135986,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1569321055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569321055","product_id":100026901,"comment_content":"1、线程切换对性能有消耗      2、GIL的设计方便了CPython的编写，但是对使用者不太友好","like_count":0},{"had_liked":false,"id":134477,"user_name":"Hector","can_delete":false,"product_type":"c1","uid":1496889,"ip_address":"","ucode":"110CAF87ADDC01","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","comment_is_top":false,"comment_ctime":1568854210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568854210","product_id":100026901,"comment_content":"我有个问题，多核cpu下的多线程比单核cpu下的多线程(假设一个进程)的效率是更低的，原因是线程颠簸。老师能解释下线程颠簸么?多核cpu下的多线程GIL是怎么释放的，其他线程是怎么争夺的?","like_count":0},{"had_liked":false,"id":122572,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1621048,"ip_address":"","ucode":"F6AF580DC1DCBB","user_header":"https://static001.geekbang.org/account/avatar/00/18/bc/38/de0b8d90.jpg","comment_is_top":false,"comment_ctime":1565426374,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1565426374","product_id":100026901,"comment_content":"老师，想请教一下：文中在“Python 的线程安全”的一节中，以foo函数的字节码为例，说“这四行 bytecode 中间都是有可能被打断的”。我觉得，即使比如在某行bytecode执行完之后线程被打断了，等这个线程重新获得GIL后不是会继续接着执行后面的bytecode吗，因此从结果看，最终每一条bytecode都被执行完了，那么对结果应该是不会有影响的呀？","like_count":0,"discussions":[{"author":{"id":1200713,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/49/23a6ea52.jpg","nickname":"叶子","note":"","ucode":"4B043DE31345C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307574,"discussion_content":"对的。同意楼上。有可能是还在寄存器中，没有来得及存到内存，比如99，另一个线程读取的值就是之前线程没加之前的值88，然后处理完，存到了内存为99，而之前的线程就将之前没存的值99存进去了。这个时候结果就不对了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600689246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019736,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/58/08e4d923.jpg","nickname":"麻花","note":"","ucode":"67721A5F0C9EC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6755,"discussion_content":">>> import dis\n>>> dis.dis(foo)\nLOAD_GLOBAL 0 (n)\nLOAD_CONST 1 (1)\nINPLACE_ADD\nSTORE_GLOBAL 0 (n)\n\n比如当前n=98 加1后为99，运行到store_global的时候被打断，99的值没有保存到n，新线程跑的时候n还是98，那么新线程跑完，n是99，gil给到被中断的线程，要保存的值也是99","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567084703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117486,"user_name":"taoist","can_delete":false,"product_type":"c1","uid":1195004,"ip_address":"","ucode":"D70AFE25CD8F10","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/fc/04a75cd0.jpg","comment_is_top":false,"comment_ctime":1564058410,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564058410","product_id":100026901,"comment_content":"1. 线程切换需要成本（CPU资源） ，CPU密集场合使用多线程会更慢<br>2. 刚开始是一个好设计，可以更快更简洁更高效的实现代码，后来就成了历史的遗留的包袱，有大量的库依赖GIL 带来的线程安全，废除的成本非常高，因此CPython 只能不断改进 GIL，很难一次性彻底取消。","like_count":0},{"had_liked":false,"id":114605,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1563348555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563348555","product_id":100026901,"comment_content":"1. pyhton的多线程按照文中所说的实际上还是单线程的实现，表面上使用了python的多线程，但实际还是单线运行，相比较单线程而言还多了许多进程切换的锁的开销，因此多线程版本反而比单线程版本要慢。","like_count":0},{"had_liked":false,"id":113862,"user_name":"贺宇","can_delete":false,"product_type":"c1","uid":1445040,"ip_address":"","ucode":"55854825CC4AD2","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/b0/26c0e53f.jpg","comment_is_top":false,"comment_ctime":1563174727,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1563174727","product_id":100026901,"comment_content":"和ruby一样","like_count":0},{"had_liked":false,"id":110528,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1252353,"ip_address":"","ucode":"70351D4FAE47F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","comment_is_top":false,"comment_ctime":1562290102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562290102","product_id":100026901,"comment_content":"1. 多线程适合处理多个独立的子任务, 如果n是列表, 那么多线程&#47;多进程可以大大减少执行时间. 但是针对单个数字n的计算, 多线程计算时变量n, 可以视为被竞争的资源, 会lock住非执行线程, GIL机制会check_interval, 强制更换为其他线程, 额外增加了执行时间. 形象来说, 就是一个人要干的活, 非要几个人一起干, 一个人干的时候. 其他人只能干看着, GIL换人时, 还要额外的时间.<br>2. 每一种设计都是为了解决问题设计的, I&#47;O慢时使用asyncio, 也就是GIL适合的场景. 但是I&#47;O快时, 适合多线程, 此时GIL能去掉就好了","like_count":0},{"had_liked":false,"id":110515,"user_name":"汪zZ","can_delete":false,"product_type":"c1","uid":1234757,"ip_address":"","ucode":"8B93062A683902","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/45/d1621188.jpg","comment_is_top":false,"comment_ctime":1562288931,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1562288931","product_id":100026901,"comment_content":"1.在第一例子中多线程间切换需要时间，所以多线程比单线程慢。<br>2.关于思考题2，我最近在写一个GUI，左边需要实时显示摄像头，右边做一些常规处理。用的是tk，左边摄像头多线程显示，直接用多线程摄像头视频会闪，然后用tk的update更新摄像头显示，图像会稍微卡顿。<br>能不能指点一下，怎么才能在界面上左边显示摄像头不卡不闪？","like_count":0},{"had_liked":false,"id":109934,"user_name":"Redevil","can_delete":false,"product_type":"c1","uid":1527609,"ip_address":"","ucode":"21C90472DC6357","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PrKSgib1DcguTZYoOAqNw8tpLKylQU6dQPwI4NLJkd6344EWHaLF5yHe6PpAD6fsxSm0no7qiakiaEHUYw4nzTEyw/132","comment_is_top":false,"comment_ctime":1562136606,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1562136606","product_id":100026901,"comment_content":"老师您好，问个一直想问的问题：<br>假设有一个最简单的python程序，cpu-bound，比如循环print从零到10亿。<br>我的机器是Linux系统，4核心CPU。<br>我开两个terminal窗口，每个窗口都跑这个程序。<br>这个时候两个程序会相互影响吗？这个涉及到了GIL吗？<br>两个程序同时跑和只跑一个程序，执行时间上会有很大增加吗？<br>谢谢！","like_count":0,"discussions":[{"author":{"id":2467189,"avatar":"https://static001.geekbang.org/account/avatar/00/25/a5/75/123bab9e.jpg","nickname":"einslssac","note":"","ucode":"BE4D19B6F30E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356133,"discussion_content":"Linux下面的shell，每单独开个shell其运行环境都是独立的，尽管你两个shell运行的是源码一样的程序，你认为是同一个进程，实际上相当于在不同环境里面跑不同程序，两个程序完全没关系，既不是多线程也不是多进程，仅仅是两个程序而已；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615537826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346236,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/bc/cb39ed38.jpg","nickname":"自由民","note":"","ucode":"435C67531697F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33373,"discussion_content":"开两个终端窗口是两个独立的进程，互不影响吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571118126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109432,"user_name":"18646333118","can_delete":false,"product_type":"c1","uid":1202411,"ip_address":"","ucode":"35576AC4E5ADDD","user_header":"https://static001.geekbang.org/account/avatar/00/12/58/eb/cf3608bd.jpg","comment_is_top":false,"comment_ctime":1562031944,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1562031944","product_id":100026901,"comment_content":"import sys<br>a = []<br>b = a<br>c = b<br>sys.getrefcount(a)<br>结果:4<br>老师请教下，在16课将的变量赋值那章说 a =b 这样相当于a指向对象，b也指向对象 。那这里为什么存在引用关系那<br><br>","like_count":0,"discussions":[{"author":{"id":1914504,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","nickname":"Simon","note":"","ucode":"A8A2E3E57BD029","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220628,"discussion_content":"另外，sys.getrefcount(a)执行完成后，a的引用计数重回到3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585909247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1200713,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/49/23a6ea52.jpg","nickname":"叶子","note":"","ucode":"4B043DE31345C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1914504,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","nickname":"Simon","note":"","ucode":"A8A2E3E57BD029","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":307583,"discussion_content":"我想请问下这里如果同时引用a，为什么引用计数只可能增加1？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600691527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":220628,"ip_address":""},"score":307583,"extra":""}]},{"author":{"id":1276373,"avatar":"https://static001.geekbang.org/account/avatar/00/13/79/d5/4a7971fc.jpg","nickname":"Ethan","note":"","ucode":"016F1DEBA895B8","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16187,"discussion_content":"这里的引用是对于 &#34;对象&#34; 来说的，你所说的 a,b,c 可以理解成别名。注意区分一下引用和对象的概念。这里的结果是 4，可以看一下 sys.getrefcount() 的定义，本身也会临时引用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568875348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109219,"user_name":"Fergus","can_delete":false,"product_type":"c1","uid":1277066,"ip_address":"","ucode":"3A8AC741C49CEB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","comment_is_top":false,"comment_ctime":1561983152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561983152","product_id":100026901,"comment_content":"答1、线程切换也是消耗资源的，对于cpu-bound的任务，不停的切换过程中不能提升效率，反而消耗了更多资源；<br><br>答2、感觉不应该取消，文中老师提到cpython的底层c不是线程安全的，如果取消，可能会提升一定的入门难度。没有受到困扰。路过ヽ( ￣д￣;)ノ","like_count":0},{"had_liked":false,"id":109098,"user_name":"响雨","can_delete":false,"product_type":"c1","uid":1581705,"ip_address":"","ucode":"C5FB3A3BC68F92","user_header":"https://static001.geekbang.org/account/avatar/00/18/22/89/73397ccb.jpg","comment_is_top":false,"comment_ctime":1561962009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561962009","product_id":100026901,"comment_content":"CPU heavy 的任务多线程还要有切换线程的消耗，所以时间比单线程还要多。<br>平时工作没有用到多线程，异步执行任务都是采用celery的。","like_count":0},{"had_liked":false,"id":108962,"user_name":"Hoo-Ah","can_delete":false,"product_type":"c1","uid":1306913,"ip_address":"","ucode":"823093A6C7DEE7","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/21/52e8267b.jpg","comment_is_top":false,"comment_ctime":1561942557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561942557","product_id":100026901,"comment_content":"第一个问题：因为线程切换需要耗费一定的cpu资源；<br>第二个问题：多个线程需要对同样的数据进行修改的时候加锁，为了提高效率，同一个线程修改的时候可以改为可重入锁。","like_count":0},{"had_liked":false,"id":108920,"user_name":"","can_delete":false,"product_type":"c1","uid":1322330,"ip_address":"","ucode":"FA2983C5AD320C","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/5a/cc637589.jpg","comment_is_top":false,"comment_ctime":1561937211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561937211","product_id":100026901,"comment_content":"python还是属于单线程执行，cpu密集型属于大量计算，多线程反而会增加线程切换开销，效果不如单线程。 老师:有个问题，我在写flask接口登陆时，我用的selenium，分为两步，一模拟获取短信验证码，二模拟输入验证码登陆，我怎么断开这两个请求呢，防止获取验证码后用户关闭浏览器，我selenium没关闭？","like_count":0},{"had_liked":false,"id":108917,"user_name":"farFlight","can_delete":false,"product_type":"c1","uid":1245211,"ip_address":"","ucode":"B0872D3ECBEC38","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbRibsic15KXfGEN3SSjnLhXGyhK2Uyrj5ibBJsKAjicNqtafDaQOLH4xpSJRZD1vmibFPJER1ySmwP9A/132","comment_is_top":false,"comment_ctime":1561937145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561937145","product_id":100026901,"comment_content":"第一个例子切换进程还需要时间，导致速度更慢吧","like_count":0}]}