{"id":771336,"title":"09｜函数签名与传统的类（构造器）","content":"","comments":[{"had_liked":false,"id":391646,"user_name":"周星星","can_delete":false,"product_type":"c3","uid":1387107,"ip_address":"广东","ucode":"DCDC36580EA643","user_header":"https://static001.geekbang.org/account/avatar/00/15/2a/63/4d06890c.jpg","comment_is_top":false,"comment_ctime":1718725204,"is_pvip":false,"replies":[{"id":142413,"content":"先确定f1中“() =&gt; void”的意思，它指的是f1的类型为“函数”。因为f1的类型是函数，所以能赋一个函数表达式（匿名函数）给它。\n\n在TypeScript中，“() =&gt; void”是函数类型，它不限制任何函数，也就是说赋一个生成器给f1，或者赋一个callback给f1，都行。\n\n再说f2的问题。f2中的“() =&gt; ...”是一个JS中的箭头函数。而在JS中，箭头函数是不能用作构造器的，也就是不能调用new f1。所以你的测试中f2会报错，这个错是JS的语法&#47;语言设计决定的。\n\nf1和f2中的这个“箭头格式的东西”看起来相似，但指的是不同的东西。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1718771214,"ip_address":"江苏","comment_id":391646,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"老师：\n问：为什么我在 vscode 中尝试以下代码，发现只有箭头函数才会编译报错——f2 is not a constructor。\n\n```ts\nlet f0 = function () {console.log(&#39;----0----&#39;)};\nlet f1: () =&gt; void = function () {console.log(&#39;----1----&#39;)};\nlet f2 = () =&gt; {console.log(&#39;----2----&#39;)};\nfunction f3 () { console.log(&#39;----3----&#39;) }\nlet xx = new f0();\nlet xx1 = new f1();\nlet xx2 = new f2();\nlet xx3 = new f3();\n```","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646810,"discussion_content":"先确定f1中“() =&gt; void”的意思，它指的是f1的类型为“函数”。因为f1的类型是函数，所以能赋一个函数表达式（匿名函数）给它。\n\n在TypeScript中，“() =&gt; void”是函数类型，它不限制任何函数，也就是说赋一个生成器给f1，或者赋一个callback给f1，都行。\n\n再说f2的问题。f2中的“() =&gt; ...”是一个JS中的箭头函数。而在JS中，箭头函数是不能用作构造器的，也就是不能调用new f1。所以你的测试中f2会报错，这个错是JS的语法/语言设计决定的。\n\nf1和f2中的这个“箭头格式的东西”看起来相似，但指的是不同的东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1718771214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390761,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1716197171,"is_pvip":false,"replies":[{"id":142117,"content":"Q1：函数f()的声明。这个其实比较简单，你给函数f()添加一行签名就行了，如下：\n```\nfunction f(x: string | number): void;\nfunction f() {\n  ... \n}\n···\nJS的函数f()在TS中缺省既是声明也是实现，所以它相当于只声明了一空参数表的函数类型。如果在它前面添加签名，那么签名就是它的声明，而f()本身就是一个实现，“空参数表的函数”可以“实现”任意的签名。\n\nQ2：疑问: 是不是 as IF1 要比 as any 更好?\n====\n都不好。只要是使用as，都可以将任何的东西断言成别的东西从而绕过ts的类型检查。即使单个as不行，还能多次as，通过as any或as unknown来做多次as，最终结果都能绕过ts。然而这样的结果是js运行过程中会出错。\n总之，如同之间的章节中说的“尽量不要用as”。\n\nQ3：疑问: 是否存在 可以在不借助 as 断言 的情况下使 function 完全 模拟 class ？\n====\n不存在。在ts的内部库代码中也是使用as断言，来将传统的Object&#47;Number&#47;Function等等构造器模拟成class的。\n\n而且，事实上你的理解方向反了，从ts的类型系统的角度上来看，并不存在“模拟成class”，而是将“class声明”表达成“构造函数类型+接口类型”这样两个声明。在TS的类型系统中，严格来讲是没有“类(class)类型”的，例如后面要讲的工具类型，就只有取函数和构造器的参数、返回值，而没有操作“类”的。\n\n所谓不推荐使用function来模拟class，不是拒绝使用class&#47;function，而是在类型系统构建的角度上来看，最好明确的使用某一种，来提升“库”的一致性，这样就可使库更加稳定和易于维护。我向来是主张使用class的，但许多OOP的“天然敌视者”向来拒绝class，用function来搞定一切，也不是不可以。呵呵~ ：）","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1716264781,"ip_address":"江苏","comment_id":390761,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"function f(s: string): void;\nfunction f(n: number): void;\n&#47;&#47; 空参数表 格式\nfunction f() {\n    const arg = arguments[0];\n    switch (typeof arg) {\n        case &#39;string&#39;: {\n            console.log(&#39;current word is:&#39;, arg);\n            break;\n        };\n        case &#39;number&#39;: {\n            console.log(&#39;current number is:&#39;, arg);\n            break;\n        };\n        default:\n            break;\n    }\n}\n&#47;&#47; 剩余参数 格式\n&#47;&#47; function f(...args: any[]): any {\n&#47;&#47;     const arg = args[0];\n&#47;&#47;     switch (typeof arg) {\n&#47;&#47;         case &#39;string&#39;: {\n&#47;&#47;             console.log(&#39;current word is:&#39;, arg);\n&#47;&#47;             break;\n&#47;&#47;         };\n&#47;&#47;         case &#39;number&#39;: {\n&#47;&#47;             console.log(&#39;current number is:&#39;, arg);\n&#47;&#47;             break;\n&#47;&#47;         };\n&#47;&#47;         default:\n&#47;&#47;             break;\n&#47;&#47;     }\n&#47;&#47; }\nconst res = f(1);\n&#47;&#47;    ^?\nconst res2 = f(&#39;2&#39;);\n&#47;&#47;    ^?\n&#47;**\n * 使用 对象类型 描述了 一个具有多个重载签名 的函数\n *&#47;\ntype TF = {\n    (s: string): void;\n    (n: number): void;\n}\n&#47;**\n * 使用 接口类型 描述了 一个具有多个重载签名 的函数\n *&#47;\ninterface IF {\n    (s: string): void;\n    (n: number): void;\n}\n\ninterface IF1 {\n    (s: string): void;\n    (n: number): void;\n    a: string;\n}\nlet f1: IF1 = (\n    (s: string) =&gt; {}\n) as IF1;\nf1.a = &#39;1&#39;;\n&#47;&#47; 疑问: 是不是 as IF1 要比 as any 更好?\nlet ff1: IF1 = null as any;\n&#47;&#47; 当前场景下 可以通过类型检查\n&#47;&#47; 但实际运行时会报错\nff1.a = &#39;1&#39;;\ninterface ClassA {\n    a: number;\n}\ntype ClassAConstructor = {\n    new(): ClassA;\n    (this: ClassA): void;\n    prototype: ClassA;\n};\nconst ClassAF = function () {\n    this.a = 1;\n} as ClassAConstructor;\n&#47;&#47; 疑问: 是否存在 可以在不借助 as 断言 的情况下使 function 完全 模拟 class ？\n&#47;&#47; 从这个issue (https:&#47;&#47;github.com&#47;Microsoft&#47;TypeScript&#47;issues&#47;2310)里得到的答案是 不推荐使用 function 来模拟 class. 是否意味着 我前面疑问的 答案就是 不存在\nlet abc = new ClassAF()","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645497,"discussion_content":"Q1：函数f()的声明。这个其实比较简单，你给函数f()添加一行签名就行了，如下：\n```\nfunction f(x: string | number): void;\nfunction f() {\n  ... \n}\n···\nJS的函数f()在TS中缺省既是声明也是实现，所以它相当于只声明了一空参数表的函数类型。如果在它前面添加签名，那么签名就是它的声明，而f()本身就是一个实现，“空参数表的函数”可以“实现”任意的签名。\n\nQ2：疑问: 是不是 as IF1 要比 as any 更好?\n====\n都不好。只要是使用as，都可以将任何的东西断言成别的东西从而绕过ts的类型检查。即使单个as不行，还能多次as，通过as any或as unknown来做多次as，最终结果都能绕过ts。然而这样的结果是js运行过程中会出错。\n总之，如同之间的章节中说的“尽量不要用as”。\n\nQ3：疑问: 是否存在 可以在不借助 as 断言 的情况下使 function 完全 模拟 class ？\n====\n不存在。在ts的内部库代码中也是使用as断言，来将传统的Object/Number/Function等等构造器模拟成class的。\n\n而且，事实上你的理解方向反了，从ts的类型系统的角度上来看，并不存在“模拟成class”，而是将“class声明”表达成“构造函数类型+接口类型”这样两个声明。在TS的类型系统中，严格来讲是没有“类(class)类型”的，例如后面要讲的工具类型，就只有取函数和构造器的参数、返回值，而没有操作“类”的。\n\n所谓不推荐使用function来模拟class，不是拒绝使用class/function，而是在类型系统构建的角度上来看，最好明确的使用某一种，来提升“库”的一致性，这样就可使库更加稳定和易于维护。我向来是主张使用class的，但许多OOP的“天然敌视者”向来拒绝class，用function来搞定一切，也不是不可以。呵呵~ ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716264782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390565,"user_name":"Geek_bc2516","can_delete":false,"product_type":"c3","uid":2707349,"ip_address":"湖北","ucode":"D21822498443BE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Kn4AtheuVQXREBkibJHuALzon1HhtkCquYyelQaTAvneM2vREae0CxicsxAyLIxKVp1GmVbYRmKlDAumE8ZsNmVw/132","comment_is_top":false,"comment_ctime":1715670417,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"学到了","like_count":0}]}