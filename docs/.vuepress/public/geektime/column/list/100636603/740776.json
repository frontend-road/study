{"id":740776,"title":"第 13 章 异步组件与函数式组件","content":"<p>在第 12 章中，我们详细讨论了组件的基本含义与实现。本章，我们将继续讨论组件的两个重要概念，即异步组件和函数式组件。在异步组件中，“异步”二字指的是，以异步的方式加载并渲染一个组件。这在代码分割、服务端下发组件等场景中尤为重要。而函数式组件允许使用一个普通函数定义组件，并使用该函数的返回值作为组件要渲染的内容。函数式组件的特点是：无状态、编写简单且直观。在 Vue.js 2 中，相比有状态组件来说，函数式组件具有明显的性能优势。但在 Vue.js 3 中，函数式组件与有状态组件的性能差距不大，都非常好。正如 Vue.js RFC 的原文所述：“在 Vue.js 3 中使用函数式组件，主要是因为它的简单性，而不是因为它的性能好。”</p>\n<h2 id=\"nav_point_120\">13.1　异步组件要解决的问题</h2>\n<p>从根本上来说，异步组件的实现不需要任何框架层面的支持，用户完全可以自行实现。渲染 App 组件到页面的示例如下：</p>\n<pre class=\"code-rows\"><code> import App from 'App.vue'\n createApp(App).mount('#app')\n</code></pre>\n<p>上面这段代码所展示的就是同步渲染。我们可以轻易地将其修改为异步渲染，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const loader = () =&gt; import('App.vue')\n loader().then(App =&gt; {\n   createApp(App).mount('#app')\n })\n</code></pre>\n<p>这里我们使用动态导入语句 <code>import()</code> 来加载组件，它会返回一个 <code>Promise</code> 实例。组件加载成功后，会调用 <code>createApp</code> 函数完成挂载，这样就实现了以异步的方式来渲染页面。</p>\n<p>上面的例子实现了整个页面的异步渲染。通常一个页面会由多个组件构成，每个组件负责渲染页面的一部分。那么，如果只想异步渲染部分页面，要怎么办呢？这时，只需要有能力异步加载某一个组件就可以了。假设下面的代码是 <code>App.vue</code> 组件的代码：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code> &lt;template&gt;\n   &lt;CompA /&gt;\n   &lt;component :is=\"asyncComp\" /&gt;\n &lt;/template&gt;\n &lt;script&gt;\n import { shallowRef } from 'vue'\n import CompA from 'CompA.vue'\n<p>export default {<br />\ncomponents: { CompA },<br />\nsetup() {<br />\nconst asyncComp = shallowRef(null)</p>\n<pre><code> // 异步加载 CompB 组件\n import('CompB.vue').then(CompB =&amp;gt; asyncComp.value = CompB)\n\n return {\n   asyncComp\n }\n</code></pre>\n<p>}<br />\n}<br />\n&lt;/script&gt;<br />\n</code></pre></p>\n<p>从这段代码的模板中可以看出，页面由 <code>&lt;CompA /&gt;</code> 组件和动态组件 <code>&lt;component&gt;</code> 构成。其中，<code>CompA</code> 组件是同步渲染的，而动态组件绑定了 <code>asyncComp</code> 变量。再看脚本块，我们通过动态导入语句 <code>import()</code> 来异步加载 <code>CompB</code> 组件，当加载成功后，将 <code>asyncComp</code> 变量的值设置为 <code>CompB</code>。这样就实现了 <code>CompB</code> 组件的异步加载和渲染。</p>\n<p>不过，虽然用户可以自行实现组件的异步加载和渲染，但整体实现还是比较复杂的，因为一个完善的异步组件的实现，所涉及的内容要比上面的例子复杂得多。通常在异步加载组件时，我们还要考虑以下几个方面。</p>\n<ul>\n<li>如果组件加载失败或加载超时，是否要渲染 Error 组件？</li>\n<li>组件在加载时，是否要展示占位的内容？例如渲染一个 Loading 组件。</li>\n<li>组件加载的速度可能很快，也可能很慢，是否要设置一个延迟展示 Loading 组件的时间？如果组件在 200ms 内没有加载成功才展示 Loading 组件，这样可以避免由组件加载过快所导致的闪烁。</li>\n<li>组件加载失败后，是否需要重试？</li>\n</ul>\n<p>为了替用户更好地解决上述问题，我们需要在框架层面为异步组件提供更好的封装支持，与之对应的能力如下。</p>\n<ul>\n<li>允许用户指定加载出错时要渲染的组件。</li>\n<li>允许用户指定 Loading 组件，以及展示该组件的延迟时间。</li>\n<li>允许用户设置加载组件的超时时长。</li>\n<li>组件加载失败时，为用户提供重试的能力。</li>\n</ul>\n<p>以上这些内容就是异步组件真正要解决的问题。</p>\n<h2 id=\"nav_point_121\">13.2　异步组件的实现原理</h2>\n<h3 id=\"nav_point_122\">13.2.1　封装 <code>defineAsyncComponent</code> 函数</h3>\n<p>异步组件本质上是通过封装手段来实现友好的用户接口，从而降低用户层面的使用复杂度，如下面的用户代码所示：</p>\n<pre class=\"code-rows\"><code> &lt;template&gt;\n   &lt;AsyncComp /&gt;\n &lt;/template&gt;\n &lt;script&gt;\n export default {\n   components: {\n     // 使用 defineAsyncComponent 定义一个异步组件，它接收一个加载器作为参数\n     AsyncComp: defineAsyncComponent(() =&gt; import('CompA'))\n   }\n }\n &lt;/script&gt;\n</code></pre>\n<p>在上面这段代码中，我们使用 <code>defineAsyncComponent</code> 来定义异步组件，并直接使用 <code>components</code> 组件选项来注册它。这样，在模板中就可以像使用普通组件一样使用异步组件了。可以看到，使用 <code>defineAsyncComponent</code> 函数定义异步组件的方式，比我们在 13.1 节中自行实现的异步组件方案要简单直接得多。</p>\n<p><code>defineAsyncComponent</code> 是一个高阶组件，它最基本的实现如下：</p>\n<pre class=\"code-rows\"><code> // defineAsyncComponent 函数用于定义一个异步组件，接收一个异步组件加载器作为参数\n function defineAsyncComponent(loader) {\n   // 一个变量，用来存储异步加载的组件\n   let InnerComp = null\n   // 返回一个包装组件\n   return {\n     name: 'AsyncComponentWrapper',\n     setup() {\n       // 异步组件是否加载成功\n       const loaded = ref(false)\n       // 执行加载器函数，返回一个 Promise 实例\n       // 加载成功后，将加载成功的组件赋值给 InnerComp，并将 loaded 标记为 true，代表加载成功\n       loader().then(c =&gt; {\n         InnerComp = c\n         loaded.value = true\n       })\n<pre><code>   return () =&amp;gt; {\n     // 如果异步组件加载成功，则渲染该组件，否则渲染一个占位内容\n     return loaded.value ? { type: InnerComp } : { type: Text, children: '' }\n   }\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>这里有以下几个关键点。</p>\n<ul>\n<li><code>defineAsyncComponent</code> 函数本质上是一个高阶组件，它的返回值是一个包装组件。</li>\n<li>包装组件会根据加载器的状态来决定渲染什么内容。如果加载器成功地加载了组件，则渲染被加载的组件，否则会渲染一个占位内容。</li>\n<li>通常占位内容是一个注释节点。组件没有被加载成功时，页面中会渲染一个注释节点来占位。但这里我们使用了一个空文本节点来占位。</li>\n</ul>\n<h3 id=\"nav_point_123\">13.2.2　超时与 Error 组件</h3>\n<p>异步组件通常以网络请求的形式进行加载。前端发送一个 HTTP 请求，请求下载组件的 JavaScript 资源，或者从服务端直接获取组件数据。既然存在网络请求，那么必然要考虑网速较慢的情况，尤其是在弱网环境下，加载一个组件可能需要很长时间。因此，我们需要为用户提供指定超时时长的能力，当加载组件的时间超过了指定时长后，会触发超时错误。这时如果用户配置了 Error 组件，则会渲染该组件。</p>\n<p>首先，我们来设计用户接口。为了让用户能够指定超时时长，<code>defineAsyncComponent</code> 函数需要接收一个配置对象作为参数：</p>\n<pre class=\"code-rows\"><code> const AsyncComp = defineAsyncComponent({\n   loader: () =&gt; import('CompA.vue'),\n   timeout: 2000, // 超时时长，其单位为 ms\n   errorComponent: MyErrorComp // 指定出错时要渲染的组件\n })\n</code></pre>\n<ul>\n<li><code>loader</code>：指定异步组件的加载器。</li>\n<li><code>timeout</code>：单位为 <code>ms</code>，指定超时时长。</li>\n<li><code>errorComponent</code>：指定一个 Error 组件，当错误发生时会渲染它。</li>\n</ul>\n<p>设计好用户接口后，我们就可以给出具体实现了，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function defineAsyncComponent(options) {\n   // options 可以是配置项，也可以是加载器\n   if (typeof options === 'function') {\n     // 如果 options 是加载器，则将其格式化为配置项形式\n     options = {\n       loader: options\n     }\n   }\n<p>const { loader } = options</p>\n<p>let InnerComp = null</p>\n<p>return {<br />\nname: ‘AsyncComponentWrapper’,<br />\nsetup() {<br />\nconst loaded = ref(false)<br />\n// 代表是否超时，默认为 false，即没有超时<br />\nconst timeout = ref(false)</p>\n<pre><code>   loader().then(c =&amp;gt; {\n     InnerComp = c\n     loaded.value = true\n   })\n\n   let timer = null\n   if (options.timeout) {\n     // 如果指定了超时时长，则开启一个定时器计时\n     timer = setTimeout(() =&amp;gt; {\n       // 超时后将 timeout 设置为 true\n       timeout.value = true\n     }, options.timeout)\n   }\n   // 包装组件被卸载时清除定时器\n   onUmounted(() =&amp;gt; clearTimeout(timer))\n\n   // 占位内容\n   const placeholder = { type: Text, children: '' }\n\n   return () =&amp;gt; {\n     if (loaded.value) {\n       // 如果组件异步加载成功，则渲染被加载的组件\n       return { type: InnerComp }\n     } else if (timeout.value) {\n       // 如果加载超时，并且用户指定了 Error 组件，则渲染该组件\n       return options.errorComponent ? { type: options.errorComponent } : placeholder\n     }\n     return placeholder\n   }\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>整体实现并不复杂，关键点如下。</p>\n<ul>\n<li>需要一个标志变量来标识异步组件的加载是否已经超时，即 <code>timeout.value</code>。</li>\n<li>开始加载组件的同时，开启一个定时器进行计时。当加载超时后，将 <code>timeout.value</code> 的值设置为 <code>true</code>，代表加载已经超时。这里需要注意的是，当包装组件被卸载时，需要清除定时器。</li>\n<li>包装组件根据 <code>loaded</code> 变量的值以及 <code>timeout</code> 变量的值来决定具体的渲染内容。如果异步组件加载成功，则渲染被加载的组件；如果异步组件加载超时，并且用户指定了 Error 组件，则渲染 Error 组件。</li>\n</ul>\n<p>这样，我们就实现了对加载超时的兼容，以及对 Error 组件的支持。除此之外，我们希望有更加完善的机制来处理异步组件加载过程中发生的错误，超时只是错误的原因之一。基于此，我们还希望为用户提供以下能力。</p>\n<ul>\n<li>当错误发生时，把错误对象作为 Error 组件的 <code>props</code> 传递过去，以便用户后续能自行进行更细粒度的处理。</li>\n<li>除了超时之外，有能力处理其他原因导致的加载错误，例如网络失败等。</li>\n</ul>\n<p>为了实现这两个目标，我们需要对代码做一些调整，如下所示：</p>\n<pre class=\"code-rows\"><code> function defineAsyncComponent(options) {\n   if (typeof options === 'function') {\n     options = {\n       loader: options\n     }\n   }\n<p>const { loader } = options</p>\n<p>let InnerComp = null</p>\n<p>return {<br />\nname: ‘AsyncComponentWrapper’,<br />\nsetup() {<br />\nconst loaded = ref(false)<br />\n// 定义 error，当错误发生时，用来存储错误对象<br />\nconst error = shallowRef(null)</p>\n<pre><code>   loader()\n     .then(c =&amp;gt; {\n       InnerComp = c\n       loaded.value = true\n     })\n     // 添加 catch 语句来捕获加载过程中的错误\n     .catch((err) =&amp;gt; error.value = err)\n\n   let timer = null\n   if (options.timeout) {\n     timer = setTimeout(() =&amp;gt; {\n       // 超时后创建一个错误对象，并复制给 error.value\n       const err = new Error(`Async component timed out after $ms.`)\n       error.value = err\n     }, options.timeout)\n   }\n\n   const placeholder = { type: Text, children: '' }\n\n   return () =&amp;gt; {\n     if (loaded.value) {\n       return { type: InnerComp }\n     } else if (error.value &amp;amp;&amp;amp; options.errorComponent) {\n       // 只有当错误存在且用户配置了 errorComponent 时才展示 Error 组件，同时将 error 作为 props 传递\n       return { type: options.errorComponent, props: { error: error.value } }\n     } else {\n       return placeholder\n     }\n   }\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>观察上面的代码，我们对之前的实现做了一些调整。首先，为加载器添加 <code>catch</code> 语句来捕获所有加载错误。接着，当加载超时后，我们会创建一个新的错误对象，并将其赋值给 <code>error.value</code> 变量。在组件渲染时，只要 <code>error.value</code> 的值存在，且用户配置了 <code>errorComponent</code> 组件，就直接渲染 <code>errorComponent</code> 组件并将 <code>error.value</code> 的值作为该组件的 <code>props</code> 传递。这样，用户就可以在自己的 Error 组件上，通过定义名为 <code>error</code> 的 <code>props</code> 来接收错误对象，从而实现细粒度的控制。</p>\n<h3 id=\"nav_point_124\">13.2.3　延迟与 Loading 组件</h3>\n<p>异步加载的组件受网络影响较大，加载过程可能很慢，也可能很快。这时我们就会很自然地想到，对于第一种情况，我们能否通过展示 Loading 组件来提供更好的用户体验。这样，用户就不会有“卡死”的感觉了。这是一个好想法，但展示 Loading 组件的时机是一个需要仔细考虑的问题。通常，我们会从加载开始的那一刻起就展示 Loading 组件。但在网络状况良好的情况下，异步组件的加载速度会非常快，这会导致 Loading 组件刚完成渲染就立即进入卸载阶段，于是出现闪烁的情况。对于用户来说这是非常不好的体验。因此，我们需要为 Loading 组件设置一个延迟展示的时间。例如，当超过 200ms 没有完成加载，才展示 Loading 组件。这样，对于在 200ms 内能够完成加载的情况来说，就避免了闪烁问题的出现。</p>\n<p>不过，我们首先要考虑的仍然是用户接口的设计，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> defineAsyncComponent({\n   loader: () =&gt; new Promise(r =&gt; { /* ... */ }),\n   // 延迟 200ms 展示 Loading 组件\n   delay: 200,\n   // Loading 组件\n   loadingComponent: {\n     setup() {\n       return () =&gt; {\n         return { type: 'h2', children: 'Loading...' }\n       }\n     }\n   }\n })\n</code></pre>\n<ul>\n<li><code>delay</code>，用于指定延迟展示 Loading 组件的时长。</li>\n<li><code>loadingComponent</code>，类似于 <code>errorComponent</code> 选项，用于配置 Loading 组件。</li>\n</ul>\n<p>用户接口设计完成后，我们就可以着手实现了。延迟时间与 Loading 组件的具体实现如下：</p>\n<pre class=\"code-rows\"><code> function defineAsyncComponent(options) {\n   if (typeof options === 'function') {\n     options = {\n       loader: options\n     }\n   }\n<p>const { loader } = options</p>\n<p>let InnerComp = null</p>\n<p>return {<br />\nname: ‘AsyncComponentWrapper’,<br />\nsetup() {<br />\nconst loaded = ref(false)<br />\nconst error = shallowRef(null)<br />\n// 一个标志，代表是否正在加载，默认为 false<br />\nconst loading = ref(false)</p>\n<pre><code>   let loadingTimer = null\n   // 如果配置项中存在 delay，则开启一个定时器计时，当延迟到时后将 loading.value 设置为 true\n   if (options.delay) {\n     loadingTimer = setTimeout(() =&amp;gt; {\n       loading.value = true\n     }, options.delay);\n   } else {\n     // 如果配置项中没有 delay，则直接标记为加载中\n     loading.value = true\n   }\n   loader()\n     .then(c =&amp;gt; {\n       InnerComp = c\n       loaded.value = true\n     })\n     .catch((err) =&amp;gt; error.value = err)\n     .finally(() =&amp;gt; {\n       loading.value = false\n       // 加载完毕后，无论成功与否都要清除延迟定时器\n       clearTimeout(loadingTimer)\n     })\n\n   let timer = null\n   if (options.timeout) {\n     timer = setTimeout(() =&amp;gt; {\n       const err = new Error(`Async component timed out after $ms.`)\n       error.value = err\n     }, options.timeout)\n   }\n\n   const placeholder = { type: Text, children: '' }\n\n   return () =&amp;gt; {\n     if (loaded.value) {\n       return { type: InnerComp }\n     } else if (error.value &amp;amp;&amp;amp; options.errorComponent) {\n       return { type: options.errorComponent, props: { error: error.value } }\n     } else if (loading.value &amp;amp;&amp;amp; options.loadingComponent) {\n       // 如果异步组件正在加载，并且用户指定了 Loading 组件，则渲染 Loading 组件\n       return { type: options.loadingComponent }\n     } else {\n       return placeholder\n     }\n   }\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>整体实现思路类似于超时时长与 Error 组件，有以下几个关键点。</p>\n<ul>\n<li>需要一个标记变量 <code>loading</code> 来代表组件是否正在加载。</li>\n<li>如果用户指定了延迟时间，则开启延迟定时器。定时器到时后，再将 <code>loading.value</code> 的值设置为 <code>true</code>。</li>\n<li>无论组件加载成功与否，都要清除延迟定时器，否则会出现组件已经加载成功，但仍然展示 Loading 组件的问题。</li>\n<li>在渲染函数中，如果组件正在加载，并且用户指定了 Loading 组件，则渲染该 Loading 组件。</li>\n</ul>\n<p>另外有一点需要注意，当异步组件加载成功后，会卸载 Loading 组件并渲染异步加载的组件。为了支持 Loading 组件的卸载，我们需要修改 <code>unmount</code> 函数，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> function unmount(vnode) {\n   if (vnode.type === Fragment) {\n     vnode.children.forEach(c =&gt; unmount(c))\n     return\n   } else if (typeof vnode.type === 'object') {\n     // 对于组件的卸载，本质上是要卸载组件所渲染的内容，即 subTree\n     unmount(vnode.component.subTree)\n     return\n   }\n   const parent = vnode.el.parentNode\n   if (parent) {\n     parent.removeChild(vnode.el)\n   }\n }\n</code></pre>\n<p>对于组件的卸载，本质上是要卸载组件所渲染的内容，即 <code>subTree</code>。所以在上面的代码中，我们通过组件实例的 <code>vnode.component</code> 属性得到组件实例，再递归地调用 <code>unmount</code> 函数完成 <code>vnode.component.subTree</code> 的卸载。</p>\n<h3 id=\"nav_point_125\">13.2.4　重试机制</h3>\n<p>重试指的是当加载出错时，有能力重新发起加载组件的请求。在加载组件的过程中，发生错误的情况非常常见，尤其是在网络不稳定的情况下。因此，提供开箱即用的重试机制，会提升用户的开发体验。</p>\n<p>异步组件加载失败后的重试机制，与请求服务端接口失败后的重试机制一样。所以，我们先来讨论接口请求失败后的重试机制是如何实现的。为此，我们需要封装一个 <code>fetch</code> 函数，用来模拟接口请求：</p>\n<pre class=\"code-rows\"><code> function fetch() {\n   return new Promise((resolve, reject) =&gt; {\n     // 请求会在 1 秒后失败\n     setTimeout(() =&gt; {\n       reject('err')\n     }, 1000);\n   })\n }\n</code></pre>\n<p>假设调用 <code>fetch</code> 函数会发送 HTTP 请求，并且该请求会在 1 秒后失败。为了实现失败后的重试，我们需要封装一个 <code>load</code> 函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // load 函数接收一个 onError 回调函数\n function load(onError) {\n   // 请求接口，得到 Promise 实例\n   const p = fetch()\n   // 捕获错误\n   return p.catch(err =&gt; {\n     // 当错误发生时，返回一个新的 Promise 实例，并调用 onError 回调，\n     // 同时将 retry 函数作为 onError 回调的参数\n     return new Promise((resolve, reject) =&gt; {\n       // retry 函数，用来执行重试的函数，执行该函数会重新调用 load 函数并发送请求\n       const retry = () =&gt; resolve(load(onError))\n       const fail = () =&gt; reject(err)\n       onError(retry, fail)\n     })\n   })\n }\n</code></pre>\n<p><code>load</code> 函数内部调用了 <code>fetch</code> 函数来发送请求，并得到一个 <code>Promise</code> 实例。接着，添加 <code>catch</code> 语句块来捕获该实例的错误。当捕获到错误时，我们有两种选择：要么抛出错误，要么返回一个新的 <code>Promise</code> 实例，并把该实例的 <code>resolve</code> 和 <code>reject</code> 方法暴露给用户，让用户来决定下一步应该怎么做。这里，我们将新的 <code>Promise</code> 实例的 <code>resolve</code> 和 <code>reject</code> 分别封装为 <code>retry</code> 函数和 <code>fail</code> 函数，并将它们作为 <code>onError</code> 回调函数的参数。这样，用户就可以在错误发生时主动选择重试或直接抛出错误。下面的代码展示了用户是如何进行重试加载的：</p>\n<pre class=\"code-rows\"><code> // 调用 load 函数加载资源\n load(\n   // onError 回调\n   (retry) =&gt; {\n     // 失败后重试\n     retry()\n   }\n ).then(res =&gt; {\n   // 成功\n   console.log(res)\n })\n</code></pre>\n<p>基于这个原理，我们可以很容易地将它整合到异步组件的加载流程中。具体实现如下：</p>\n<pre class=\"code-rows\"><code> function defineAsyncComponent(options) {\n   if (typeof options === 'function') {\n     options = {\n       loader: options\n     }\n   }\n<p>const { loader } = options</p>\n<p>let InnerComp = null</p>\n<p>// 记录重试次数<br />\nlet retries = 0<br />\n// 封装 load 函数用来加载异步组件<br />\nfunction load() {<br />\nreturn loader()<br />\n// 捕获加载器的错误<br />\n.catch((err) =&gt; {<br />\n// 如果用户指定了 onError 回调，则将控制权交给用户<br />\nif (options.onError) {<br />\n// 返回一个新的 Promise 实例<br />\nreturn new Promise((resolve, reject) =&gt; {<br />\n// 重试<br />\nconst retry = () =&gt; {<br />\nresolve(load())<br />\nretries++<br />\n}<br />\n// 失败<br />\nconst fail = () =&gt; reject(err)<br />\n// 作为 onError 回调函数的参数，让用户来决定下一步怎么做<br />\noptions.onError(retry, fail, retries)<br />\n})<br />\n} else {<br />\nthrow error<br />\n}<br />\n})<br />\n}</p>\n<p>return {<br />\nname: ‘AsyncComponentWrapper’,<br />\nsetup() {<br />\nconst loaded = ref(false)<br />\nconst error = shallowRef(null)<br />\nconst loading = ref(false)</p>\n<pre><code>   let loadingTimer = null\n   if (options.delay) {\n     loadingTimer = setTimeout(() =&amp;gt; {\n       loading.value = true\n     }, options.delay);\n   } else {\n     loading.value = true\n   }\n   // 调用 load 函数加载组件\n   load()\n     .then(c =&amp;gt; {\n       InnerComp = c\n       loaded.value = true\n     })\n     .catch((err) =&amp;gt; {\n       error.value = err\n     })\n     .finally(() =&amp;gt; {\n       loading.value = false\n       clearTimeout(loadingTimer)\n     })\n\n   // 省略部分代码\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码及注释所示，其整体思路与普通接口请求的重试机制类似。</p>\n<h2 id=\"nav_point_126\">13.3　函数式组件</h2>\n<p>函数式组件的实现相对容易。一个函数式组件本质上就是一个普通函数，该函数的返回值是虚拟 DOM。本章章首曾提到：“在 Vue.js 3 中使用函数式组件，主要是因为它的简单性，而不是因为它的性能好。”这是因为在 Vue.js 3 中，即使是有状态组件，其初始化性能消耗也非常小。</p>\n<p>在用户接口层面，一个函数式组件就是一个返回虚拟 DOM 的函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function MyFuncComp(props) {\n   return { type: 'h1', children: props.title }\n }\n</code></pre>\n<p>函数式组件没有自身状态，但它仍然可以接收由外部传入的 <code>props</code>。为了给函数式组件定义 <code>props</code>，我们需要在组件函数上添加静态的 <code>props</code> 属性，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function MyFuncComp(props) {\n   return { type: 'h1', children: props.title }\n }\n // 定义 props\n MyFuncComp.props = {\n   title: String\n }\n</code></pre>\n<p>在有状态组件的基础上，实现函数式组件将变得非常简单，因为挂载组件的逻辑可以复用 <code>mountComponent</code> 函数。为此，我们需要在 <code>patch</code> 函数内支持函数类型的 <code>vnode.type</code>，如下面 <code>patch</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function patch(n1, n2, container, anchor) {\n   if (n1 &amp;&amp; n1.type !== n2.type) {\n     unmount(n1)\n     n1 = null\n   }\n<p>const { type } = n2</p>\n<p>if (typeof type === ‘string’) {<br />\n// 省略部分代码<br />\n} else if (type === Text) {<br />\n// 省略部分代码<br />\n} else if (type === Fragment) {<br />\n// 省略部分代码<br />\n} else if (<br />\n// type 是对象 --&gt; 有状态组件<br />\n// type 是函数 --&gt; 函数式组件<br />\ntypeof type === ‘object’ || typeof type === ‘function’<br />\n) {<br />\n// component<br />\nif (!n1) {<br />\nmountComponent(n2, container, anchor)<br />\n} else {<br />\npatchComponent(n1, n2, anchor)<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>在 <code>patch</code> 函数内部，通过检测 <code>vnode.type</code> 的类型来判断组件的类型：</p>\n<ul>\n<li>如果 <code>vnode.type</code> 是一个对象，则它是一个有状态组件，并且 <code>vnode.type</code> 是组件选项对象；</li>\n<li>如果 <code>vnode.type</code> 是一个函数，则它是一个函数式组件。</li>\n</ul>\n<p>但无论是有状态组件，还是函数式组件，我们都可以通过 <code>mountComponent</code> 函数来完成挂载，也都可以通过 <code>patchComponent</code> 函数来完成更新。</p>\n<p>下面是修改后的 <code>mountComponent</code> 函数，它支持挂载函数式组件：</p>\n<pre class=\"code-rows\"><code> function mountComponent(vnode, container, anchor) {\n   // 检查是否是函数式组件\n   const isFunctional = typeof vnode.type === 'function'\n<p>let componentOptions = vnode.type<br />\nif (isFunctional) {<br />\n// 如果是函数式组件，则将 vnode.type 作为渲染函数，将 vnode.type.props 作为 props 选项定义即可<br />\ncomponentOptions = {<br />\nrender: vnode.type,<br />\nprops: vnode.type.props<br />\n}<br />\n}</p>\n<p>// 省略部分代码<br />\n}<br />\n</code></pre></p>\n<p>可以看到，实现对函数式组件的兼容非常简单。首先，在 <code>mountComponent</code> 函数内检查组件的类型，如果是函数式组件，则直接将组件函数作为组件选项对象的 <code>render</code> 选项，并将组件函数的静态 <code>props</code> 属性作为组件的 <code>props</code> 选项即可，其他逻辑保持不变。当然，出于更加严谨的考虑，我们需要通过 <code>isFunctional</code> 变量实现选择性地执行初始化逻辑，因为对于函数式组件来说，它无须初始化 <code>data</code> 以及生命周期钩子。从这一点可以看出，函数式组件的初始化性能消耗小于有状态组件。</p>\n<h2 id=\"nav_point_127\">13.4　总结</h2>\n<p>在本章中，我们首先讨论了异步组件要解决的问题。异步组件在页面性能、拆包以及服务端下发组件等场景中尤为重要。从根本上来说，异步组件的实现可以完全在用户层面实现，而无须框架支持。但一个完善的异步组件仍需要考虑诸多问题，例如：</p>\n<ul>\n<li>允许用户指定加载出错时要渲染的组件；</li>\n<li>允许用户指定 Loading 组件，以及展示该组件的延迟时间；</li>\n<li>允许用户设置加载组件的超时时长；</li>\n<li>组件加载失败时，为用户提供重试的能力。</li>\n</ul>\n<p>因此，框架有必要内建异步组件的实现。</p>\n<p>Vue.js 3 提供了 <code>defineAsyncComponent</code> 函数，用来定义异步组件。</p>\n<p>接着，我们讲解了异步组件的加载超时问题，以及当加载错误发生时，如何指定 Error 组件。通过为 <code>defineAsyncComponent</code> 函数指定选项参数，允许用户通过 <code>timeout</code> 选项设置超时时长。当加载超时后，会触发加载错误，这时会渲染用户通过 <code>errorComponent</code> 选项指定的 Error 组件。</p>\n<p>在加载异步组件的过程中，受网络状况的影响较大。当网络状况较差时，加载过程可能很漫长。为了提供更好的用户体验，我们需要在加载时展示 Loading 组件。所以，我们设计了 <code>loadingComponent</code> 选项，以允许用户配置自定义的 Loading 组件。但展示 Loading 组件的时机是一个需要仔细考虑的问题。为了避免 Loading 组件导致的闪烁问题，我们还需要设计一个接口，让用户能指定延迟展示 Loading 组件的时间，即 <code>delay</code> 选项。</p>\n<p>在加载组件的过程中，发生错误的情况非常常见。所以，我们设计了组件加载发生错误后的重试机制。在讲解异步组件的重试加载机制时，我们类比了接口请求发生错误时的重试机制，两者的思路类似。</p>\n<p>最后，我们讨论了函数式组件。它本质上是一个函数，其内部实现逻辑可以复用有状态组件的实现逻辑。为了给函数式组件定义 <code>props</code>，我们允许开发者在函数式组件的主函数上添加静态的 <code>props</code> 属性。出于更加严谨的考虑，函数式组件没有自身状态，也没有生命周期的概念。所以，在初始化函数式组件时，需要选择性地复用有状态组件的初始化逻辑。</p>\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 12 章 组件的实现原理","id":740775},"right":{"article_title":"第 14 章 内建组件和模块","id":740777}},"comments":[]}