{"id":40520,"title":"30 | Java虚拟机的监控及诊断工具（命令行篇）","content":"<p>今天，我们来一起了解一下JDK中用于监控及诊断工具。本篇中我将使用刚刚发布的Java 11版本的工具进行示范。</p>\n<h2>jps</h2>\n<p>你可能用过<code>ps</code>命令，打印所有正在运行的进程的相关信息。JDK中的<code>jps</code>命令（<a href=\"https://docs.oracle.com/en/java/javase/11/tools/jps.html\">帮助文档</a>）沿用了同样的概念：它将打印所有正在运行的Java进程的相关信息。</p>\n<p>在默认情况下，<code>jps</code>的输出信息包括Java进程的进程ID以及主类名。我们还可以通过追加参数，来打印额外的信息。例如，<code>-l</code>将打印模块名以及包名；<code>-v</code>将打印传递给Java虚拟机的参数（如<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>）；<code>-m</code>将打印传递给主类的参数。</p>\n<p>具体的示例如下所示：</p>\n<pre><code>$ jps -mlv\n18331 org.example.Foo Hello World\n18332 jdk.jcmd/sun.tools.jps.Jps -mlv -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home -Xms8m -Djdk.module.main=jdk.jcmd\n</code></pre><!-- [[[read_end]]] -->\n<p>需要注意的是，如果某Java进程关闭了默认开启的<code>UsePerfData</code>参数（即使用参数<code>-XX:-UsePerfData</code>），那么<code>jps</code>命令（以及下面介绍的<code>jstat</code>）将无法探知该Java进程。</p>\n<p>当获得Java进程的进程ID之后，我们便可以调用接下来介绍的各项监控及诊断工具了。</p>\n<h2>jstat</h2>\n<p><code>jstat</code>命令（<a href=\"https://docs.oracle.com/en/java/javase/11/tools/jstat.html\">帮助文档</a>）可用来打印目标Java进程的性能数据。它包括多条子命令，如下所示：</p>\n<pre><code>$ jstat -options\n-class\n-compiler\n-gc\n-gccapacity\n-gccause\n-gcmetacapacity\n-gcnew\n-gcnewcapacity\n-gcold\n-gcoldcapacity\n-gcutil\n-printcompilation\n</code></pre>\n<p>在这些子命令中，<code>-class</code>将打印类加载相关的数据，<code>-compiler</code>和<code>-printcompilation</code>将打印即时编译相关的数据。剩下的都是以<code>-gc</code>为前缀的子命令，它们将打印垃圾回收相关的数据。</p>\n<p>默认情况下，<code>jstat</code>只会打印一次性能数据。我们可以将它配置为每隔一段时间打印一次，直至目标Java进程终止，或者达到我们所配置的最大打印次数。具体示例如下所示：</p>\n<pre><code># Usage: jstat -outputOptions [-t] [-hlines] VMID [interval [count]]\n$ jstat -gc 22126 1s 4\nS0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   \n17472,0 17472,0  0,0    0,0   139904,0 47146,4   349568,0   21321,0   30020,0 28001,8 4864,0 4673,4     22    0,080   3      0,270   0      0,000    0,350\n17472,0 17472,0 420,6   0,0   139904,0 11178,4   349568,0   21321,0   30020,0 28090,1 4864,0 4674,2     28    0,084   3      0,270   0      0,000    0,354\n17472,0 17472,0  0,0   403,9  139904,0 139538,4  349568,0   21323,4   30020,0 28137,2 4864,0 4674,2     34    0,088   4      0,359   0      0,000    0,446\n17472,0 17472,0  0,0    0,0   139904,0   0,0     349568,0   21326,1   30020,0 28093,6 4864,0 4673,4     38    0,091   5      0,445   0      0,000    0,536\n</code></pre>\n<blockquote>\n<p>当监控本地环境的Java进程时，VMID可以简单理解为PID。如果需要监控远程环境的Java进程，你可以参考jstat的帮助文档。</p>\n</blockquote>\n<p>在上面这个示例中，22126进程是一个使用了CMS垃圾回收器的Java进程。我们利用<code>jstat</code>的<code>-gc</code>子命令，来打印该进程垃圾回收相关的数据。命令最后的<code>1s 4</code>表示每隔1秒打印一次，共打印4次。</p>\n<p>在<code>-gc</code>子命令的输出中，前四列分别为两个Survivor区的容量（Capacity）和已使用量（Utility）。我们可以看到，这两个Survivor区的容量相等，而且始终有一个Survivor区的内存使用量为0。</p>\n<p>当使用默认的G1 GC时，输出结果则有另一些特征：</p>\n<pre><code>$ jstat -gc 22208 1s\nS0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   \n0,0   16384,0  0,0   16384,0 210944,0 192512,0  133120,0    5332,5   28848,0 26886,4 4864,0 4620,5     19    0,067   1      0,016   2      0,002    0,084\n0,0   16384,0  0,0   16384,0 210944,0 83968,0   133120,0    5749,9   29104,0 27132,8 4864,0 4621,0     21    0,078   1      0,016   2      0,002    0,095\n0,0    0,0    0,0    0,0   71680,0  18432,0   45056,0    20285,1   29872,0 27952,4 4864,0 4671,6     23    0,089   2      0,063   2      0,002    0,153\n0,0   2048,0  0,0   2048,0 69632,0  28672,0   45056,0    18608,1   30128,0 28030,4 4864,0 4672,4     32    0,093   2      0,063   2      0,002    0,158\n...\n</code></pre>\n<p>在上面这个示例中，<code>jstat</code>每隔1s便会打印垃圾回收的信息，并且不断重复下去。</p>\n<p>你可能已经留意到，<code>S0C</code>和<code>S0U</code>始终为0，而且另一个Survivor区的容量（S1C）可能会下降至0。</p>\n<p>这是因为，当使用G1 GC时，Java虚拟机不再设置Eden区、Survivor区，老年代区的内存边界，而是将堆划分为若干个等长内存区域。</p>\n<p>每个内存区域都可以作为Eden区、Survivor区以及老年代区中的任一种，并且可以在不同区域类型之间来回切换。（<a href=\"https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html\">参考链接</a>）</p>\n<p>换句话说，逻辑上我们只有一个Survivor区。当需要迁移Survivor区中的数据时（即Copying GC），我们只需另外申请一个或多个内存区域，作为新的Survivor区。</p>\n<p>因此，Java虚拟机决定在使用G1 GC时，将所有Survivor内存区域的总容量以及已使用量存放至S1C和S1U中，而S0C和S0U则被设置为0。</p>\n<p>当发生垃圾回收时，Java虚拟机可能出现Survivor内存区域内的对象<strong>全</strong>被回收或晋升的现象。</p>\n<p>在这种情况下，Java虚拟机会将这块内存区域回收，并标记为可分配的状态。这样子做的结果是，堆中可能完全没有Survivor内存区域，因而相应的S1C和S1U将会是0。</p>\n<p><code>jstat</code>还有一个非常有用的参数<code>-t</code>，它将在每行数据之前打印目标Java进程的启动时间。例如，在下面这个示例中，第一列代表该Java进程已经启动了10.7秒。</p>\n<pre><code>$ jstat -gc -t 22407\nTimestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   \n           10,7  0,0    0,0    0,0    0,0   55296,0  45056,0   34816,0    20267,8   30128,0 27975,3 4864,0 4671,6     33    0,086   3      0,111   2      0,001    0,198\n</code></pre>\n<p>我们可以比较Java进程的启动时间以及总GC时间（GCT列），或者两次测量的间隔时间以及总GC时间的增量，来得出GC时间占运行时间的比例。</p>\n<p>如果该比例超过20%，则说明目前堆的压力较大；如果该比例超过90%，则说明堆里几乎没有可用空间，随时都可能抛出OOM异常。</p>\n<p><code>jstat</code>还可以用来判断是否出现内存泄漏。在长时间运行的Java程序中，我们可以运行<code>jstat</code>命令连续获取多行性能数据，并取这几行数据中OU列（即已占用的老年代内存）的最小值。</p>\n<p>然后，我们每隔一段较长的时间重复一次上述操作，来获得多组OU最小值。如果这些值呈上涨趋势，则说明该Java程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p>\n<blockquote>\n<p>上面没有涉及的列（或者其他子命令的输出），你可以查阅帮助文档了解具体含义。至于文档中漏掉的CGC和CGCT，它们分别代表并发GC Stop-The-World的次数和时间。</p>\n</blockquote>\n<h2>jmap</h2>\n<p>在这种情况下，我们便可以请<code>jmap</code>命令（<a href=\"https://docs.oracle.com/en/java/javase/11/tools/jmap.html\">帮助文档</a>）出马，分析Java虚拟机堆中的对象。</p>\n<p><code>jmap</code>同样包括多条子命令。</p>\n<ol>\n<li><code>-clstats</code>，该子命令将打印被加载类的信息。</li>\n<li><code>-finalizerinfo</code>，该子命令将打印所有待finalize的对象。</li>\n<li><code>-histo</code>，该子命令将统计各个类的实例数目以及占用内存，并按照内存使用量从多至少的顺序排列。此外，<code>-histo:live</code>只统计堆中的存活对象。</li>\n<li><code>-dump</code>，该子命令将导出Java虚拟机堆的快照。同样，<code>-dump:live</code>只保存堆中的存活对象。</li>\n</ol>\n<p>我们通常会利用<code>jmap -dump:live,format=b,file=filename.bin</code>命令，将堆中所有存活对象导出至一个文件之中。</p>\n<p>这里<code>format=b</code>将使<code>jmap</code>导出与<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr008.html\">hprof</a>（在Java 9中已被移除）、<code>-XX:+HeapDumpAfterFullGC</code>、<code>-XX:+HeapDumpOnOutOfMemoryError</code>格式一致的文件。这种格式的文件可以被其他GUI工具查看，具体我会在下一篇中进行演示。</p>\n<p>下面我贴了一段<code>-histo</code>子命令的输出：</p>\n<pre><code>$ jmap -histo 22574\n num     #instances         #bytes  class name (module)\n-------------------------------------------------------\n   1:        500004       20000160  org.python.core.PyComplex\n   2:        570866       18267712  org.python.core.PyFloat\n   3:        360295       18027024  [B (java.base@11)\n   4:        339394       11429680  [Lorg.python.core.PyObject;\n   5:        308637       11194264  [Ljava.lang.Object; (java.base@11)\n   6:        301378        9291664  [I (java.base@11)\n   7:        225103        9004120  java.math.BigInteger (java.base@11)\n   8:        507362        8117792  org.python.core.PySequence$1\n   9:        285009        6840216  org.python.core.PyLong\n  10:        282908        6789792  java.lang.String (java.base@11)\n  ...\n2281:             1             16  traceback$py\n2282:             1             16  unicodedata$py\nTotal       5151277      167944400\n</code></pre>\n<p>由于<code>jmap</code>将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，<code>jmap</code>需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。</p>\n<p>也就是说，由<code>jmap</code>导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么<code>:live</code>选项将无法探知到这些对象。</p>\n<p>另外，如果某个线程长时间无法跑到安全点，<code>jmap</code>将一直等下去。上一小节的<code>jstat</code>则不同。这是因为垃圾回收器会主动将<code>jstat</code>所需要的摘要数据保存至固定位置之中，而<code>jstat</code>只需直接读取即可。</p>\n<p>关于这种长时间等待的情况，你可以通过下面这段程序来复现：</p>\n<pre><code>// 暂停时间较长，约为二三十秒，可酌情调整。\n// CTRL+C的SIGINT信号无法停止，需要SIGKILL。\nstatic double sum = 0;\n\npublic static void main(String[] args) {\n  for (int i = 0; i &lt; 0x77777777; i++) { // counted loop\n    sum += Math.log(i); // Math.log is an intrinsic\n  }\n}\n</code></pre>\n<p><code>jmap</code>（以及接下来的<code>jinfo</code>、<code>jstack</code>和<code>jcmd</code>）依赖于Java虚拟机的<a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/jdk.attach/com/sun/tools/attach/package-summary.html\">Attach API</a>，因此只能监控本地Java进程。</p>\n<p>一旦开启Java虚拟机参数<code>DisableAttachMechanism</code>（即使用参数<code>-XX:+DisableAttachMechanism</code>），基于Attach API的命令将无法执行。反过来说，如果你不想被其他进程监控，那么你需要开启该参数。</p>\n<h2>jinfo</h2>\n<p><code>jinfo</code>命令（<a href=\"https://docs.oracle.com/en/java/javase/11/tools/jinfo.html\">帮助文档</a>）可用来查看目标Java进程的参数，如传递给Java虚拟机的<code>-X</code>（即输出中的jvm_args）、<code>-XX</code>参数（即输出中的VM Flags），以及可在Java层面通过<code>System.getProperty</code>获取的<code>-D</code>参数（即输出中的System Properties）。</p>\n<p>具体的示例如下所示：</p>\n<pre><code>$ jinfo 31185\nJava System Properties:\n\ngopherProxySet=false\nawt.toolkit=sun.lwawt.macosx.LWCToolkit\njava.specification.version=11\nsun.cpu.isalist=\nsun.jnu.encoding=UTF-8\n...\n\nVM Flags:\n-XX:CICompilerCount=4 -XX:ConcGCThreads=3 -XX:G1ConcRefinementThreads=10 -XX:G1HeapRegionSize=2097152 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=536870912 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=8589934592 -XX:MaxNewSize=5152702464 -XX:MinHeapDeltaBytes=2097152 -XX:NonNMethodCodeHeapSize=5835340 -XX:NonProfiledCodeHeapSize=122911450 -XX:ProfiledCodeHeapSize=122911450 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC\n\nVM Arguments:\njvm_args: -Xlog:gc -Xmx1024m\njava_command: org.example.Foo\njava_class_path (initial): .\nLauncher Type: SUN_STANDARD\n</code></pre>\n<p><code>jinfo</code>还可以用来修改目标Java进程的“manageable”虚拟机参数。</p>\n<p>举个例子，我们可以使用<code>jinfo -flag +HeapDumpAfterFullGC &lt;PID&gt;</code>命令，开启<code>&lt;PID&gt;</code>所指定的Java进程的<code>HeapDumpAfterFullGC</code>参数。</p>\n<p>你可以通过下述命令查看其他&quot;manageable&quot;虚拟机参数：</p>\n<pre><code>$ java -XX:+PrintFlagsFinal -version | grep manageable   \n     intx CMSAbortablePrecleanWaitMillis           = 100                                    {manageable} {default}\n     intx CMSTriggerInterval                       = -1                                     {manageable} {default}\n     intx CMSWaitDuration                          = 2000                                   {manageable} {default}\n     bool HeapDumpAfterFullGC                      = false                                  {manageable} {default}\n     bool HeapDumpBeforeFullGC                     = false                                  {manageable} {default}\n     bool HeapDumpOnOutOfMemoryError               = false                                  {manageable} {default}\n    ccstr HeapDumpPath                             =                                        {manageable} {default}\n    uintx MaxHeapFreeRatio                         = 70                                     {manageable} {default}\n    uintx MinHeapFreeRatio                         = 40                                     {manageable} {default}\n     bool PrintClassHistogram                      = false                                  {manageable} {default}\n     bool PrintConcurrentLocks                     = false                                  {manageable} {default}\njava version &quot;11&quot; 2018-09-25\nJava(TM) SE Runtime Environment 18.9 (build 11+28)\nJava HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)\n</code></pre>\n<h2>jstack</h2>\n<p><code>jstack</code>命令（<a href=\"https://docs.oracle.com/en/java/javase/11/tools/jstack.html\">帮助文档</a>）可以用来打印目标Java进程中各个线程的栈轨迹，以及这些线程所持有的锁。</p>\n<p><code>jstack</code>的其中一个应用场景便是死锁检测。这里我用<code>jstack</code>获取一个已经死锁了的Java程序的栈信息。具体输出如下所示：</p>\n<pre><code>$ jstack 31634\n...\n\n&quot;Thread-0&quot; #12 prio=5 os_prio=31 cpu=1.32ms elapsed=34.24s tid=0x00007fb08601c800 nid=0x5d03 waiting for monitor entry  [0x000070000bc7e000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n at DeadLock.foo(DeadLock.java:18)\n - waiting to lock &lt;0x000000061ff904c0&gt; (a java.lang.Object)\n - locked &lt;0x000000061ff904b0&gt; (a java.lang.Object)\n at DeadLock$$Lambda$1/0x0000000800060840.run(Unknown Source)\n at java.lang.Thread.run(java.base@11/Thread.java:834)\n\n&quot;Thread-1&quot; #13 prio=5 os_prio=31 cpu=1.43ms elapsed=34.24s tid=0x00007fb08601f800 nid=0x5f03 waiting for monitor entry  [0x000070000bd81000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n at DeadLock.bar(DeadLock.java:33)\n - waiting to lock &lt;0x000000061ff904b0&gt; (a java.lang.Object)\n - locked &lt;0x000000061ff904c0&gt; (a java.lang.Object)\n at DeadLock$$Lambda$2/0x0000000800063040.run(Unknown Source)\n at java.lang.Thread.run(java.base@11/Thread.java:834)\n\n...\n\nJNI global refs: 6, weak refs: 0\n\n\nFound one Java-level deadlock:\n=============================\n&quot;Thread-0&quot;:\n  waiting to lock monitor 0x00007fb083015900 (object 0x000000061ff904c0, a java.lang.Object),\n  which is held by &quot;Thread-1&quot;\n&quot;Thread-1&quot;:\n  waiting to lock monitor 0x00007fb083015800 (object 0x000000061ff904b0, a java.lang.Object),\n  which is held by &quot;Thread-0&quot;\n\nJava stack information for the threads listed above:\n===================================================\n&quot;Thread-0&quot;:\n at DeadLock.foo(DeadLock.java:18)\n - waiting to lock &lt;0x000000061ff904c0&gt; (a java.lang.Object)\n - locked &lt;0x000000061ff904b0&gt; (a java.lang.Object)\n at DeadLock$$Lambda$1/0x0000000800060840.run(Unknown Source)\n at java.lang.Thread.run(java.base@11/Thread.java:834)\n&quot;Thread-1&quot;:\n at DeadLock.bar(DeadLock.java:33)\n - waiting to lock &lt;0x000000061ff904b0&gt; (a java.lang.Object)\n - locked &lt;0x000000061ff904c0&gt; (a java.lang.Object)\n at DeadLock$$Lambda$2/0x0000000800063040.run(Unknown Source)\n at java.lang.Thread.run(java.base@11/Thread.java:834)\n\nFound 1 deadlock.\n</code></pre>\n<p>我们可以看到，<code>jstack</code>不仅会打印线程的栈轨迹、线程状态（BLOCKED）、持有的锁（locked …）以及正在请求的锁（waiting to lock …），而且还会分析出具体的死锁。</p>\n<h2>jcmd</h2>\n<p>你还可以直接使用<code>jcmd</code>命令（<a href=\"https://docs.oracle.com/en/java/javase/11/tools/jcmd.html\">帮助文档</a>），来替代前面除了<code>jstat</code>之外的所有命令。具体的替换规则你可以参考下表。</p>\n<p>至于<code>jstat</code>的功能，虽然<code>jcmd</code>复制了<code>jstat</code>的部分代码，并支持通过<code>PerfCounter.print</code>子命令来打印所有的Performance Counter，但是它没有保留<code>jstat</code>的输出格式，也没有重复打印的功能。因此，感兴趣的同学可以自行整理。</p>\n<p>另外，我们将在下一篇中介绍<code>jcmd</code>中Java Flight Recorder相关的子命令。</p>\n<h2>总结与实践</h2>\n<p>今天我介绍了JDK中用于监控及诊断的命令行工具。我们再来回顾一下。</p>\n<ol>\n<li><code>jps</code>将打印所有正在运行的Java进程。</li>\n<li><code>jstat</code>允许用户查看目标Java进程的类加载、即时编译以及垃圾回收相关的信息。它常用于检测垃圾回收问题以及内存泄漏问题。</li>\n<li><code>jmap</code>允许用户统计目标Java进程的堆中存放的Java对象，并将它们导出成二进制文件。</li>\n<li><code>jinfo</code>将打印目标Java进程的配置参数，并能够改动其中manageabe的参数。</li>\n<li><code>jstack</code>将打印目标Java进程中各个线程的栈轨迹、线程状态、锁状况等信息。它还将自动检测死锁。</li>\n<li><code>jcmd</code>则是一把瑞士军刀，可以用来实现前面除了<code>jstat</code>之外所有命令的功能。</li>\n</ol>\n<hr />\n<p>今天的实践环节，你可以探索<code>jcmd</code>中的下述功能，看看有没有适合你项目的监控项：</p>\n<pre><code>Compiler.CodeHeap_Analytics\nCompiler.codecache\nCompiler.codelist\nCompiler.directives_add\nCompiler.directives_clear\nCompiler.directives_print\nCompiler.directives_remove\nCompiler.queue\nGC.class_histogram\nGC.class_stats\nGC.finalizer_info\nGC.heap_dump\nGC.heap_info\nGC.run\nGC.run_finalization\nVM.class_hierarchy\nVM.classloader_stats\nVM.classloaders\nVM.command_line\nVM.dynlibs\nVM.flags\nVM.info\nVM.log\nVM.metaspace\nVM.native_memory\nVM.print_touched_methods\nVM.set_flag\nVM.stringtable\nVM.symboltable\nVM.system_properties\nVM.systemdictionary\nVM.unlock_commercial_features\nVM.uptime\nVM.version\n</code></pre>\n<p></p>\n","neighbors":{"left":{"article_title":"29 | 基准测试框架JMH（下）","id":40281},"right":{"article_title":"31 | Java虚拟机的监控及诊断工具（GUI篇）","id":40821}},"comments":[{"had_liked":false,"id":29131,"user_name":"杨晓峰","can_delete":false,"product_type":"c1","uid":1009360,"ip_address":"","ucode":"2BF255467A978F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","comment_is_top":false,"comment_ctime":1538272519,"is_pvip":false,"replies":[{"id":"10612","content":"谢谢峰哥！","user_name":"作者回复","comment_id":29131,"uid":"1176688","ip_address":"","utype":1,"ctime":1538405245,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"74552716551","product_id":100010301,"comment_content":"jmc早openjdk网站单独下载，目前需要7 ea版处理jdk11<br>http:&#47;&#47;jdk.java.net&#47;jmc&#47;","like_count":18,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425500,"discussion_content":"谢谢峰哥！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538405245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36763,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1541315369,"is_pvip":false,"replies":[{"id":"13341","content":"翻译过来就是”我们不对结果负责” ;)","user_name":"作者回复","comment_id":36763,"uid":"1176688","ip_address":"","utype":1,"ctime":1541498056,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"40196021033","product_id":100010301,"comment_content":"老师为什么官方文档介绍工具开头都有&quot;This command is experimental and unsupported&quot;这句话？","like_count":10,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428005,"discussion_content":"翻译过来就是”我们不对结果负责” ;)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541498056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326460,"discussion_content":"免责声明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605598735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31407,"user_name":"美滋滋","can_delete":false,"product_type":"c1","uid":1180783,"ip_address":"","ucode":"20E5E8F92EFEFA","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/6f/55d943e6.jpg","comment_is_top":false,"comment_ctime":1539173710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27308977486","product_id":100010301,"comment_content":"null那位朋友 oom killer了解一下","like_count":6},{"had_liked":false,"id":37570,"user_name":"田斌","can_delete":false,"product_type":"c1","uid":1066601,"ip_address":"","ucode":"EA3E7B4D851AC3","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/69/78f18991.jpg","comment_is_top":false,"comment_ctime":1541642506,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23016478986","product_id":100010301,"comment_content":"Jstack -F会导致Java进程一直挂起吗，说是jdk的bug，什么情况下会一直挂起呢","like_count":5,"discussions":[{"author":{"id":1716801,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/32/41/c1a7840b.jpg","nickname":"着迷","note":"","ucode":"429F1D4015A195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297052,"discussion_content":"斌哥没想到在这碰到你了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596762283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28807,"user_name":"null","can_delete":false,"product_type":"c1","uid":1181408,"ip_address":"","ucode":"D7B05E5B60A18D","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/e0/fa7e80da.jpg","comment_is_top":false,"comment_ctime":1538147770,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18718016954","product_id":100010301,"comment_content":"老师， 你好<br>我想请教一个问题，<br>我们线上环境有一台tomcat偶尔会莫名的挂掉，<br>而且没有任何错误信息，日志都是正常的，<br>就像被kill -9一样。<br>请问这个怎么排查问题？<br>不会是人为的。<br>谢谢。","like_count":5,"discussions":[{"author":{"id":1965699,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","nickname":"慎独明强","note":"","ucode":"DC2F7F2C0C8F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378220,"discussion_content":"OS的kill机制？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623116285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28425,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1538092924,"is_pvip":false,"replies":[{"id":"10283","content":"记得很多是通过MXBeans的。然后JVM有个专门存放perf data的，JVM组件会将东西存在那，而jstat会从那里读取。<br><br>实现起来不复杂的，可以参考一下工具的源代码<br>https:&#47;&#47;hg.openjdk.java.net&#47;jdk&#47;jdk11&#47;file&#47;1ddf9a99e4ad&#47;src&#47;jdk.jcmd&#47;share&#47;classes&#47;sun&#47;tools","user_name":"作者回复","comment_id":28425,"uid":"1176688","ip_address":"","utype":1,"ctime":1538114505,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"18717962108","product_id":100010301,"comment_content":"嘿嘿，就喜欢这样的简单拿来主义，随学随用。老师能否深入讲一下这些命令的底层实现，对应的信息都是怎么获取到的？都是从哪里获取到的？如果说都是从JVM中感觉范围有点大，往细了讲是从JVM的什么地方获取的呢？","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425263,"discussion_content":"记得很多是通过MXBeans的。然后JVM有个专门存放perf data的，JVM组件会将东西存在那，而jstat会从那里读取。\n\n实现起来不复杂的，可以参考一下工具的源代码\nhttps://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538114505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200395,"user_name":"wkq2786130","can_delete":false,"product_type":"c1","uid":1256821,"ip_address":"","ucode":"0F3A9DF9928C67","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/75/e7c29de4.jpg","comment_is_top":false,"comment_ctime":1585580272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175514864","product_id":100010301,"comment_content":"自己做的笔记，请大家斧正  http:&#47;&#47;weikeqin.com&#47;2020&#47;03&#47;28&#47;jvm-performance-tuning-monitoring-tool&#47; ","like_count":3},{"had_liked":false,"id":28387,"user_name":"Axis","can_delete":false,"product_type":"c1","uid":1033046,"ip_address":"","ucode":"84ADBCF5893049","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c3/56/0ad8772a.jpg","comment_is_top":false,"comment_ctime":1538066544,"is_pvip":false,"replies":[{"id":"10284","content":"怎么说呢，大佬们决定JMC应该另外下载。我揣测是为了减少JDK的编译时间，不确定哈","user_name":"作者回复","comment_id":28387,"uid":"1176688","ip_address":"","utype":1,"ctime":1538114594,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"10128001136","product_id":100010301,"comment_content":"Jdk11下开源了jfr但是没有jmc这个工具查看性能文件  是为什么？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425254,"discussion_content":"怎么说呢，大佬们决定JMC应该另外下载。我揣测是为了减少JDK的编译时间，不确定哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538114594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240148,"user_name":"。。。。","can_delete":false,"product_type":"c1","uid":1107784,"ip_address":"","ucode":"0163FD085D4293","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/48/df149c8d.jpg","comment_is_top":false,"comment_ctime":1596770680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596770680","product_id":100010301,"comment_content":"jmap导出是不是会很久很慢啊，有好的方法吗","like_count":0},{"had_liked":false,"id":200408,"user_name":"wkq2786130","can_delete":false,"product_type":"c1","uid":1256821,"ip_address":"","ucode":"0F3A9DF9928C67","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/75/e7c29de4.jpg","comment_is_top":false,"comment_ctime":1585580809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585580809","product_id":100010301,"comment_content":"```<br> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT<br>28096.0 28096.0  0.0   28096.0 225024.0 225024.0  562560.0   562560.0  90916.0 88514.2 10304.0 9660.5     53   11.859  248   348.108  359.967<br>28096.0 28096.0  0.0   28095.9 225024.0 225024.0  562560.0   562560.0  90916.0 88514.2 10304.0 9660.5     53   11.859  249   349.650  361.510<br>28096.0 28096.0  0.0   28095.9 225024.0 225024.0  562560.0   562560.0  90916.0 88514.2 10304.0 9660.5     53   11.859  249   349.650  361.510<br>28096.0 28096.0  0.0   28096.0 225024.0 225024.0  562560.0   562560.0  90916.0 88514.2 10304.0 9660.5     53   11.859  250   351.329  363.189<br>28096.0 28096.0  0.0   28096.0 225024.0 225024.0  562560.0   562560.0  90916.0 88514.2 10304.0 9660.5     53   11.859  250   351.329  363.189<br> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT<br>28096.0 28096.0  0.0   28096.0 225024.0 225024.0  562560.0   562560.0  90916.0 88514.2 10304.0 9660.5     53   11.859  251   352.853  364.713<br>28096.0 28096.0  0.0   28096.0 225024.0 225024.0  562560.0   562560.0  90916.0 88514.2 10304.0 9660.5     53   11.859  253   354.598  366.457<br>28096.0 28096.0  0.0   28096.0 225024.0 225024.0  562560.0   562560.0  90916.0 88514.2 10304.0 9660.5     53   11.859  253   354.598  366.457<br>28096.0 28096.0  0.0   28096.0 225024.0 225024.0  562560.0   562560.0  90916.0 88514.2 10304.0 9660.5     53   11.859  253   354.598  366.457<br>28096.0 28096.0  0.0   28096.0 225024.0 225024.0  562560.0   562560.0  90916.0 88514.2 10304.0 9660.5     53   11.859  254   356.826  368.685<br>```<br><br>像这种 Old Space已经满了，但是还没有 OOM，大家知道是什么原因吗？","like_count":0},{"had_liked":false,"id":146123,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1572436920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572436920","product_id":100010301,"comment_content":"linux 下man 对应的command，结合老师给的文档，都会用了","like_count":0},{"had_liked":false,"id":138904,"user_name":"Geek_c991f2","can_delete":false,"product_type":"c1","uid":1624538,"ip_address":"","ucode":"0FDE8CE24B8E32","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jAsPmqra89uLYer998tsdAmHIxy9iaVfLIkzkTB3ITfUZg21Yiadf73TqmcFZXTEv2wuQicDA2uvqXvicHJ9HckBWg/132","comment_is_top":false,"comment_ctime":1570502490,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1570502490","product_id":100010301,"comment_content":"如果某个服务启动后,发现cpu使用率很高,这种问题怎么找出问题","like_count":0,"discussions":[{"author":{"id":1206365,"avatar":"https://static001.geekbang.org/account/avatar/00/12/68/5d/1ccee378.jpg","nickname":"茫农","note":"","ucode":"71F7143644C9CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268365,"discussion_content":"这种最好找了，直接看哪个线程cpu有问题，然后看堆栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589765895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107591,"user_name":"Roway","can_delete":false,"product_type":"c1","uid":1060967,"ip_address":"","ucode":"65AF589142AB6C","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/67/a1e9aaba.jpg","comment_is_top":false,"comment_ctime":1561561436,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1561561436","product_id":100010301,"comment_content":"老师， 您好！<br>我想请教一个问题，我们线上环境有一台tomcat偶尔会莫名的挂掉，<br>而且没有任何错误信息(tomcat bin目录下生成了文件hs_err_pid20894.log)，日志都是正常的，就像被kill -9一样。<br>请问这个怎么排查问题？<br>不会是人为的。<br>谢谢。","like_count":0},{"had_liked":false,"id":105174,"user_name":"believe me","can_delete":false,"product_type":"c1","uid":1101427,"ip_address":"","ucode":"7BF9A3C7BF6A9B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/73/cded8343.jpg","comment_is_top":false,"comment_ctime":1560933222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560933222","product_id":100010301,"comment_content":"老师，为什么我用jstat命令查看：发现S0C和S1C的大小不一样，JDK版本是1.7","like_count":0},{"had_liked":false,"id":103206,"user_name":"子不语","can_delete":false,"product_type":"c1","uid":1123186,"ip_address":"","ucode":"907AB44706467B","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/72/70190bc1.jpg","comment_is_top":false,"comment_ctime":1560396632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560396632","product_id":100010301,"comment_content":"老师，咨询个问题，我通过jinfo -flag +PrintGC PID  jinfo -flag +PrintGCDetails PID，没办法指定路径，gc日志输出在哪里的，找不到。","like_count":0},{"had_liked":false,"id":101049,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1559705664,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559705664","product_id":100010301,"comment_content":"jps将打印所有正在运行的 Java 进程。 jstat允许...<br>","like_count":0},{"had_liked":false,"id":94948,"user_name":"Warren","can_delete":false,"product_type":"c1","uid":1041381,"ip_address":"","ucode":"64A3C45BABC6A2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e3/e5/7b2586cb.jpg","comment_is_top":false,"comment_ctime":1557927760,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1557927760","product_id":100010301,"comment_content":"我在使用jfr后发现method profiling为空，请问知道怎么解决吗","like_count":0},{"had_liked":false,"id":83658,"user_name":"witluo","can_delete":false,"product_type":"c1","uid":1443117,"ip_address":"","ucode":"3D9608C3DDDD95","user_header":"","comment_is_top":false,"comment_ctime":1554691404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554691404","product_id":100010301,"comment_content":"为什么没有Gcplot，一般参数调整，有计算公式么？这个可以根据自己的业务流量和现有服务进行动态调整。<br>动态调整原则：调整理论合适值，再压测，将产生的gc.og,得出图形报表进行进一步分析，调整再压测，得出相对优参数值！<br>（个人意见）","like_count":0},{"had_liked":false,"id":77466,"user_name":"啸风","can_delete":false,"product_type":"c1","uid":1043892,"ip_address":"","ucode":"C8737C40E3FB94","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/b4/2f485987.jpg","comment_is_top":false,"comment_ctime":1552951915,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1552951915","product_id":100010301,"comment_content":"最近在分析was的JVM运行情况，好像没有jstack，和jmap，用的是javacore和heapdump分析，但用的不熟练，老师能否给适当的指导说明？","like_count":0,"discussions":[{"author":{"id":1205682,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/b2/5e5d1b3d.jpg","nickname":"Silence_雨","note":"","ucode":"F48FE6C0B367F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2389,"discussion_content":"可以通过was控制台在应用启动参数里配置jmx开始远程监控","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563532084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31665,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1539259709,"is_pvip":false,"replies":[{"id":"11544","content":"都是命令行程序，没有GUI界面的","user_name":"作者回复","comment_id":31665,"uid":"1176688","ip_address":"","utype":1,"ctime":1539333070,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1539259709","product_id":100010301,"comment_content":"为什么我双击这些.exe，直接就闪退。","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426457,"discussion_content":"都是命令行程序，没有GUI界面的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539333070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28476,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1538095808,"is_pvip":false,"replies":[{"id":"10280","content":"嗯，以前版本都有这些工具。<br><br>只不过我使用了JDK11版本的这些工具，这句”注意”是用来避免结果有出入的。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1538114014,"ip_address":"","comment_id":28476,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1538095808","product_id":100010301,"comment_content":"老师讲的好像和jdk11 没啥关系吧","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425276,"discussion_content":"嗯，以前版本都有这些工具。\n\n只不过我使用了JDK11版本的这些工具，这句”注意”是用来避免结果有出入的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538114014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37989,"discussion_content":"老师这是谨言慎行，这就是专家的说话风格吧，不像商人或者网上的那些“大牛”一样信口开河，满嘴跑火车","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571710537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}