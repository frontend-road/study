{"id":258666,"title":"20 | 如何解决微服务的数据一致性分发问题？","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geektime-distributed\">https://gitee.com/geektime-geekbang/geektime-distributed</a></p>","comments":[{"had_liked":false,"id":251153,"user_name":"hunterlodge","can_delete":false,"product_type":"c3","uid":1069755,"ip_address":"","ucode":"5B83A79E784161","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/bb/225e70a6.jpg","comment_is_top":false,"comment_ctime":1601382408,"is_pvip":false,"replies":[{"id":91884,"content":"这里头有一个设计折中，如果所有节点无状态都采用抢占方式，那么当数据量大的时候，所有节点抢占DB造成的锁压力就会很大，这个无法线性扩展。所以killbill-queue采用粘性(sticky)处理方式 ～ 一个节点只处理从自己这个节点写入的事件，这样就没有争抢锁的问题，但是这样节点就有状态，节点有状态就会有节点挂的问题，节点挂了谁来负责原来由该节点负责的事件，这时候就需要一个单独的角色在后台监控处理，这个角色就是reaper。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1601476713,"ip_address":"","comment_id":251153,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"老师，为什么要引入reaper这么复杂的机制呢？如果reaper可以抢占，何不干脆让所有节点处理所有的事件呢？谢谢！","like_count":8,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506397,"discussion_content":"这里头有一个设计折中，如果所有节点无状态都采用抢占方式，那么当数据量大的时候，所有节点抢占DB造成的锁压力就会很大，这个无法线性扩展。所以killbill-queue采用粘性(sticky)处理方式 ～ 一个节点只处理从自己这个节点写入的事件，这样就没有争抢锁的问题，但是这样节点就有状态，节点有状态就会有节点挂的问题，节点挂了谁来负责原来由该节点负责的事件，这时候就需要一个单独的角色在后台监控处理，这个角色就是reaper。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601476713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280409,"user_name":"superFan","can_delete":false,"product_type":"c3","uid":1103116,"ip_address":"","ucode":"AA0FFEF391488D","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/0c/8dd1791d.jpg","comment_is_top":false,"comment_ctime":1614180876,"is_pvip":false,"replies":[{"id":102206,"content":"我记得我在google查找&quot;DB based queue&quot; 或者 &quot;DB based event bus&quot;时找到了killbill-commons这个项目。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1614786017,"ip_address":"","comment_id":280409,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"比较好奇老师是怎么检索到killbill-commons这个项目的","like_count":6,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516087,"discussion_content":"我记得我在google查找&amp;quot;DB based queue&amp;quot; 或者 &amp;quot;DB based event bus&amp;quot;时找到了killbill-commons这个项目。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614786017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280821,"user_name":"tenyears","can_delete":false,"product_type":"c3","uid":1855229,"ip_address":"","ucode":"0CACA3D408FBBE","user_header":"https://static001.geekbang.org/account/avatar/00/1c/4e/fd/bce64518.jpg","comment_is_top":false,"comment_ctime":1614408183,"is_pvip":false,"replies":[{"id":102210,"content":"中小规模的企业应用，用基于DB的事务性发件箱来实现异步可靠消息，比较简单。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1614786555,"ip_address":"","comment_id":280821,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"忽然发现上家公司用的就是事务性发件箱模式，那时候还不明白为啥不直接写到mq","like_count":4,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516216,"discussion_content":"中小规模的企业应用，用基于DB的事务性发件箱来实现异步可靠消息，比较简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614786555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237303,"user_name":"Geek_jm95v6","can_delete":false,"product_type":"c3","uid":1154286,"ip_address":"","ucode":"291F1A4DAA3DB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/ee/f5cb8bd3.jpg","comment_is_top":false,"comment_ctime":1595773242,"is_pvip":false,"replies":[{"id":87840,"content":"用事务性MQ解决也是一种办法，也可以。\n\n用canal&#47;CDC解决的话，耦合性更低，性能会更好。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1595955712,"ip_address":"","comment_id":237303,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"事务双写问题 视频当中说网络抖动 那可以用事务性mq不就可以解决吗？例如rocktmq或者rabbitmq ？如果能解决 是不是直接发送到mq也可以解决？用canal解决和用mq有啥区别吗","like_count":3,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502367,"discussion_content":"用事务性MQ解决也是一种办法，也可以。\n\n用canal/CDC解决的话，耦合性更低，性能会更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595955712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234312,"user_name":"高峰","can_delete":false,"product_type":"c3","uid":1046111,"ip_address":"","ucode":"2DFE77FE4970B8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/5f/85e82813.jpg","comment_is_top":false,"comment_ctime":1594641614,"is_pvip":false,"replies":[{"id":86550,"content":"业务报错，具体情况还是需要根据业务上下文来处理，有些是可以立即重试的，有些立即重试也不行的，将消息发回死信队列，待后续再重试或人工干预。\n\nMQ有主动推消息和消费端拉消息两种消费模式。对于消费端拉模式，例如Kafka，MQ中的消息始终存在，可以按需重复消费（调整偏移量即可）","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1594745011,"ip_address":"","comment_id":234312,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"老师，假如billing 或者 customer 微服务消费MQ数据的时候 处理业务报错了 如何处理？需要报警or人工处理？\n感觉MQ应该不会再次发送同样的message给业务方消费了。","like_count":3,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501346,"discussion_content":"业务报错，具体情况还是需要根据业务上下文来处理，有些是可以立即重试的，有些立即重试也不行的，将消息发回死信队列，待后续再重试或人工干预。\n\nMQ有主动推消息和消费端拉消息两种消费模式。对于消费端拉模式，例如Kafka，MQ中的消息始终存在，可以按需重复消费（调整偏移量即可）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594745011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592308,"discussion_content":"是担心消息会丢吗？可以在执行完所有消息业务逻辑后，再发送消费确认","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667296433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233388,"user_name":"名贤集","can_delete":false,"product_type":"c3","uid":1033131,"ip_address":"","ucode":"220A754095BECE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c3/ab/c2ca35e6.jpg","comment_is_top":false,"comment_ctime":1594305499,"is_pvip":false,"replies":[{"id":86264,"content":"如果只有一张订单表，如果订单修改了，比如调整了单价，或者添加了购物项，这种数据的变更你怎么记录呢？\n\n发件箱主要用于记录数据变更事件的，其它消费者感兴趣的也是数据变更事件。变更包括新建&#47;更新和删除。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1594395247,"ip_address":"","comment_id":233388,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"感觉事物性发件箱直接读订单表也可以，可以加一个数据读取记录表，拆成两张表的目的是什么呢？","like_count":3,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501005,"discussion_content":"如果只有一张订单表，如果订单修改了，比如调整了单价，或者添加了购物项，这种数据的变更你怎么记录呢？\n\n发件箱主要用于记录数据变更事件的，其它消费者感兴趣的也是数据变更事件。变更包括新建/更新和删除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594395247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1391463,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3b/67/c188d3bc.jpg","nickname":"tingye","note":"","ucode":"54F7A44066DF5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290075,"discussion_content":"直接使用订单表可能对业务有影响，增加订单表读写负担，单独使用发件箱表跟业务耦合相对小一些","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594338447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1033131,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/ab/c2ca35e6.jpg","nickname":"名贤集","note":"","ucode":"220A754095BECE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1391463,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3b/67/c188d3bc.jpg","nickname":"tingye","note":"","ucode":"54F7A44066DF5D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290132,"discussion_content":"读表有什么影响呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594352611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290075,"ip_address":"","group_id":0},"score":290132,"extra":""}]}]},{"had_liked":false,"id":241285,"user_name":"pinocc","can_delete":false,"product_type":"c3","uid":1112428,"ip_address":"","ucode":"163321B38AC6FA","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/6c/4d5a65ae.jpg","comment_is_top":false,"comment_ctime":1597237434,"is_pvip":false,"replies":[{"id":89250,"content":"但是对这个事件的处理可能会失败，如果要重试的话，还是需要DB来记录重试状态(否则机器挂状态就丢失了)，所以光靠它也不能解决一致性分发问题。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1597417838,"ip_address":"","comment_id":241285,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"Spring 的 TransactionalEventListener 可以实现事务提交之后才抛出事件","like_count":2,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503697,"discussion_content":"但是对这个事件的处理可能会失败，如果要重试的话，还是需要DB来记录重试状态(否则机器挂状态就丢失了)，所以光靠它也不能解决一致性分发问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597417838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233257,"user_name":"Jxin","can_delete":false,"product_type":"c3","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1594273001,"is_pvip":false,"replies":[{"id":86099,"content":"对。rocketMq的方式也可以采用，国内用得比较多的，能解决问题。虽然架构上不太优雅，对应用有侵入性，而且mq本身也会搞复杂。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1594310187,"ip_address":"","comment_id":233257,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"1.本地消息表除了视频所述，还可以用rocketMq的事务消息实现（得写反查接口）。但业务侵入问题可能还更严重。","like_count":2,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500963,"discussion_content":"对。rocketMq的方式也可以采用，国内用得比较多的，能解决问题。虽然架构上不太优雅，对应用有侵入性，而且mq本身也会搞复杂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594310187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286949,"user_name":"leehan","can_delete":false,"product_type":"c3","uid":1316438,"ip_address":"","ucode":"AE2AA3EB25269A","user_header":"https://static001.geekbang.org/account/avatar/00/14/16/56/f0c2f7aa.jpg","comment_is_top":false,"comment_ctime":1617697852,"is_pvip":false,"replies":[{"id":104794,"content":"写DB超时了，会抛出exception，这时候不管写DB成不成功，都会触发rollback回滚，不会commit提交。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1618668471,"ip_address":"","comment_id":286949,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"举例提到了写DB成功，但是发消息失败（实际成功）的例子，如果是第一步写DB就碰到类似的问题写DB的时候网络抖动认为超时了，但是实际又更新成功了，这种是否需要考虑或是解决呢？","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518142,"discussion_content":"写DB超时了，会抛出exception，这时候不管写DB成不成功，都会触发rollback回滚，不会commit提交。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618668471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234560,"user_name":"陈皮","can_delete":false,"product_type":"c3","uid":1103516,"ip_address":"","ucode":"42088EF5264280","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/9c/c48fd38a.jpg","comment_is_top":false,"comment_ctime":1594719770,"is_pvip":false,"replies":[{"id":86549,"content":"1. 每一个应用实例上面的Dispather线程，只消费处理从本实例(creating_owner是自己)写入的事件，而且因为一个应用实例只有一个消费线程，消息取走后DB状态变成处理中，可以保证不会重复消费。\n\n请看killbill common queue的文档说明：\nThe claiming mechanism is lock free: a first query looks for entries to be processed (10 at a time by default, see getMaxEntriesClaimed in the config) then mark them as IN_PROCESSING. Because each node only looks at entries it created (creating_owner column), there is no conflict between several nodes processing the same entry.\n\n2. 消费慢，就需要更多的消费者(Dispather)，但是每一个应用实例只有一个Dispather，所以需要更多应用实例，也就是需要对整个集群进行扩容，以分摊消费负载。\n\n\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1594744564,"ip_address":"","comment_id":234560,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"Killbill Commons Queue 是嵌入到业务服务部署的，一般业务服务需要集群部署。\n1. 多应用实例情况下，对于数据库的一个节点，每一个应用实例都会有一个 Dispatcher 线程消费，怎么保证消息不被重复消费？ \n2. create_owner 是在消息写入时定义的，消息消费慢的情况下怎么实现扩容？","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501423,"discussion_content":"1. 每一个应用实例上面的Dispather线程，只消费处理从本实例(creating_owner是自己)写入的事件，而且因为一个应用实例只有一个消费线程，消息取走后DB状态变成处理中，可以保证不会重复消费。\n\n请看killbill common queue的文档说明：\nThe claiming mechanism is lock free: a first query looks for entries to be processed (10 at a time by default, see getMaxEntriesClaimed in the config) then mark them as IN_PROCESSING. Because each node only looks at entries it created (creating_owner column), there is no conflict between several nodes processing the same entry.\n\n2. 消费慢，就需要更多的消费者(Dispather)，但是每一个应用实例只有一个Dispather，所以需要更多应用实例，也就是需要对整个集群进行扩容，以分摊消费负载。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594744564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103516,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d6/9c/c48fd38a.jpg","nickname":"陈皮","note":"","ucode":"42088EF5264280","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291276,"discussion_content":"\n1. 一个节点（应用实例）有且仅有一个 Dispathcer 线程消费。\n2. 消息写入时会保存该机器的唯一标识（org.killbill.CreatorName#get）, Dispatcher 线程读时根据该标识处理。\n3. 节点在较短时间内重启，如果这个标识获取函数获取到的标识是一致的，\b那么消息仍由该节点消费，如果不一致，则进行收割。\n4. 节点长时间不可用，则发生收割，消息由其他节点抢注消费。\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594767077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300167,"user_name":"Geek8819","can_delete":false,"product_type":"c3","uid":2028950,"ip_address":"","ucode":"521AEDAB2EED81","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/96/e963b41b.jpg","comment_is_top":false,"comment_ctime":1625030904,"is_pvip":false,"replies":[{"id":110363,"content":"本节课后面有讲解事务性发件箱和CDC的差异比对，binlog也是一种CDC技术。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1627832235,"ip_address":"","comment_id":300167,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"请问事务性发件箱模式和下游直接接 binlog 有什么区别？","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522660,"discussion_content":"本节课后面有讲解事务性发件箱和CDC的差异比对，binlog也是一种CDC技术。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627832235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278485,"user_name":"吴","can_delete":false,"product_type":"c3","uid":2141505,"ip_address":"","ucode":"B2B3C9B914F953","user_header":"https://static001.geekbang.org/account/avatar/00/20/ad/41/832174de.jpg","comment_is_top":false,"comment_ctime":1612969476,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"一致性，其实是时间上的相对，实时性要求高的场景，某种程度来说就是不一致。理解的波波老师说的方案都是最终一致性，也就是末尾说的single source of truth","like_count":1},{"had_liked":false,"id":373491,"user_name":"stg609","can_delete":false,"product_type":"c3","uid":1073025,"ip_address":"浙江","ucode":"FB70A75A891BB8","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/81/1c614f4a.jpg","comment_is_top":false,"comment_ctime":1682571383,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"有两个问题:1. 出了双写，有没有其他方案实现数据分发。2. CDC为什么适合大企业？事务发件箱有什么劣势？","like_count":0},{"had_liked":false,"id":353151,"user_name":"茵陈","can_delete":false,"product_type":"c3","uid":1184470,"ip_address":"浙江","ucode":"058C4BAEFEC0EC","user_header":"https://static001.geekbang.org/account/avatar/00/12/12/d6/65446a67.jpg","comment_is_top":false,"comment_ctime":1659193552,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"killbill 和spring boot 如何集成呢 \nkillbill queue和db-scheduler类似吗 是不是都是事件发件箱","like_count":0},{"had_liked":false,"id":349663,"user_name":"gregorius","can_delete":false,"product_type":"c3","uid":1055659,"ip_address":"","ucode":"107429DE0B1A72","user_header":"https://static001.geekbang.org/account/avatar/00/10/1b/ab/452c2053.jpg","comment_is_top":false,"comment_ctime":1656212640,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"请问对于垂直分库的情况下跨库or一般怎么解决的","like_count":0},{"had_liked":false,"id":344808,"user_name":"满心","can_delete":false,"product_type":"c3","uid":2078544,"ip_address":"","ucode":"CDBC39F0344C8B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/b7/50/0628cac8.jpg","comment_is_top":false,"comment_ctime":1651802241,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"老师，关于killbill项目的设计，每个节点只处理自己写入的记录，最终把事件写入EventBus，那EventBus中数据的顺序如何保证呢？比如新增和删除两个操作，被AB两个节点分别处理，如果B先把删除记录记录写入EventBus，之后A再把新增记录写入EventBus。这样下游业务顺序消费时，就会出现数据不一致","like_count":0},{"had_liked":false,"id":337165,"user_name":"piboye","can_delete":false,"product_type":"c3","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1646657290,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"不可变架构","like_count":0},{"had_liked":false,"id":337164,"user_name":"piboye","can_delete":false,"product_type":"c3","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1646657239,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"棒","like_count":0},{"had_liked":false,"id":335818,"user_name":"dog_brother","can_delete":false,"product_type":"c3","uid":1619597,"ip_address":"","ucode":"9F64D3C6D815FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","comment_is_top":false,"comment_ctime":1645700619,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"老师好，关于MQ网络抖动会导致双写逻辑异常没有理解，如果出现了网络抖动抛了异常，这种情况下有可能数据已经发到MQ了？","like_count":0},{"had_liked":false,"id":323803,"user_name":"刘嘿嘿","can_delete":false,"product_type":"c3","uid":2041767,"ip_address":"","ucode":"42E38062F9A214","user_header":"https://static001.geekbang.org/account/avatar/00/1f/27/a7/9514c072.jpg","comment_is_top":false,"comment_ctime":1638168934,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"事务发件箱这有个疑问，对于订单系统来说，如果对时效性要求不高是可以用视频说的通过 message relay 离线拉取的方式推送数据。但对于支付回调这种对实时性要求比较高的方式是否就不适合了？\n\n能否通过下列方案解决呢？\n1. 写db 事务\n2. 发送mq \n3. 若mq发送成功修改db状态为已发送\n4. 离线通过message relay 补推待发送的数据到mq中\n","like_count":0}]}