{"id":410038,"title":"02｜串讲：编程开发中，那些你需要掌握的基本概念","content":"<p>你好，我是陈天。</p><p>上一讲我们了解了内存的基本运作方式，简单回顾一下：栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期。</p><p>今天我们来继续梳理，编程开发中经常接触到的其它基本概念。需要掌握的小概念点比较多，为了方便你学习，我把它们分为四大类来讲解：<strong>数据</strong>（值和类型、指针和引用）、<strong>代码</strong>（函数、方法、闭包、接口和虚表）、<strong>运行方式</strong>（并发并行、同步异步和 Promise / async / await ），以及<strong>编程范式</strong>（泛型编程）。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/ee/41bd5a23d4a7ba61c4477bb8699320ee.jpg?wh=1920x1068\" alt=\"图片\"></p><p>希望通过重温这些概念，你能够夯实软件开发领域的基础知识，这对你后续理解 Rust 里面的很多难点至关重要，比如所有权、动态分派、并发处理等。</p><p>好了，废话不多说，我们马上开始。</p><h2>数据</h2><p>数据是程序操作的对象，不进行数据处理的程序是没有意义的，我们先来重温和数据有关的概念，包括值和类型、指针和引用。</p><h3>值和类型</h3><p>严谨地说，类型是对值的区分，它包含了值在内存中的<strong>长度</strong>、<strong>对齐以及值可以进行的操作等信息</strong>。一个值是符合一个特定类型的数据的某个实体。比如 64u8，它是 u8 类型，对应一个字节大小、取值范围在 0～255 的某个整数实体，这个实体是 64。</p><p>值以类型规定的表达方式（representation）被存储成一组字节流进行访问。比如 64，存储在内存中的表现形式是 0x40，或者 0b 0100 0000。</p><!-- [[[read_end]]] --><p>这里你要注意，<strong>值是无法脱离具体的类型讨论的</strong>。同样是内存中的一个字节 0x40，如果其类型是 ASCII char，那么其含义就不是 64，而是 @ 符号。</p><p>不管是强类型的语言还是弱类型的语言，语言内部都有其类型的具体表述。一般而言，编程语言的类型可以分为原生类型和组合类型两大类。</p><p>原生类型（primitive type）是编程语言提供的最基础的数据类型。比如字符、整数、浮点数、布尔值、数组（array）、元组（tuple）、指针、引用、函数、闭包等。<strong>所有原生类型的大小都是固定的，因此它们可以被分配到栈上</strong>。</p><p>组合类型（composite type）或者说复合类型，是指由一组原生类型和其它类型组合而成的类型。组合类型也可以细分为两类：</p><ul>\n<li>结构体（structure type）：<strong>多个类型组合在一起共同表达一个值的复杂数据结构</strong>。比如 Person 结构体，内部包含 name、age、email 等信息。用代数数据类型（algebraic data type）的说法，结构体是 product type。</li>\n<li>标签联合（tagged union）：也叫不相交并集（disjoint union），<strong>可以存储一组不同但固定的类型中的某个类型的对象，具体是哪个类型由其标签决定</strong>。比如 Haskell 里的 Maybe 类型，或者 Swift 中的 Optional 就是标签联合。用代数数据类型的说法，标签联合是 sum type。</li>\n</ul><p>另外不少语言不支持标签联合，只取其标签部分，提供了枚举类型（enumerate）。枚举是标签联合的子类型，但功能比较弱，无法表达复杂的结构。</p><p>看定义可能不是太好理解，你可以看这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/11/b291acc8e6a1f890668334cea2919211.jpg?wh=1920x1108\" alt=\"图片\"></p><h3>指针和引用</h3><p>在内存中，一个值被存储到内存中的某个位置，这个位置对应一个内存地址。而指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址，理论上可以解引用到任意数据类型。</p><p>引用（reference）和指针非常类似，不同的是，<strong>引用的解引用访问是受限的，它只能解引用到它引用数据的类型，不能用作它用</strong>。比如，指向 42u8 这个值的一个引用，它解引用的时候只能使用 u8 数据类型。</p><p>所以，指针的使用限制更少，但也会带来更多的危害。如果没有用正确的类型解引用一个指针，那么会引发各种各样的内存问题，造成系统崩溃或者潜在的安全漏洞。</p><p>刚刚讲过，<strong>指针和引用是原生类型，它们可以分配在栈上</strong>。</p><p>根据指向数据的不同，某些引用除了需要一个指针指向内存地址之外，还需要内存地址的长度和其它信息。</p><p>如上一讲提到的指向 “hello world” 字符串的指针，还包含字符串长度和字符串的容量，一共使用了 3 个 word，在 64 位 CPU 下占用 24 个字节，这样<strong>比正常指针携带更多信息的指针，我们称之为胖指针（fat pointer）</strong>。很多数据结构的引用，内部都是由胖指针实现的。</p><h2>代码</h2><p>数据是程序操作的对象，而代码是程序运行的主体，也是我们开发者把物理世界中的需求转换成数字世界中逻辑的载体。我们会讨论函数和闭包、接口和虚表。</p><h3>函数、方法和闭包</h3><p>函数是编程语言的基本要素，它是对完成某个功能的一组相关语句和表达式的封装。<strong>函数也是对代码中重复行为的抽象</strong>。在现代编程语言中，函数往往是一等公民，这意味着函数可以作为参数传递，或者作为返回值返回，也可以作为复合类型中的一个组成部分。</p><p>在面向对象的编程语言中，在类或者对象中定义的函数，被称为方法（method）。方法往往和对象的指针发生关系，比如 Python 对象的 self 引用，或者 Java 对象的 this 引用。</p><p>而闭包是将函数，或者说代码和其环境一起存储的一种数据结构。<strong>闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分</strong>。</p><p>一般来说，如果一门编程语言，其函数是一等公民，那么它必然会支持闭包（closure），因为函数作为返回值往往需要返回一个闭包。</p><p>你可以看这张图辅助理解，图中展示了一个闭包对上下文环境的捕获。可以 <a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=34b218b50497b266a42411c4b1aada1a\">在这里</a> 运行这段代码：</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/ee/5de48717de85670yy7fac479c7a7aeee.jpg?wh=1920x1010\" alt=\"图片\"></p><h3>接口和虚表</h3><p>接口是一个软件系统开发的核心部分，它反映了系统的设计者对系统的抽象理解。<strong>作为一个抽象层，接口将使用方和实现方隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性</strong>。</p><p>很多编程语言都有接口的概念，允许开发者面向接口设计，比如 Java 的 interface、Elixir 的 behaviour、Swift 的 protocol 和 Rust 的 trait。</p><p>比如说，在 HTTP 中，Request/Response 的服务处理模型其实就是一个典型的接口，我们只需要按照服务接口定义出不同输入下，从 Request 到 Response 具体该如何映射，通过这个接口，系统就可以在合适的场景下，把符合要求的 Request 分派给我们的服务。</p><p>面向接口的设计是软件开发中的重要能力，而 Rust 尤其重视接口的能力。在后续讲到 Trait 的章节，我们会详细介绍如何用 Trait 来进行接口设计。</p><p>当我们在运行期使用接口来引用具体类型的时候，代码就具备了运行时多态的能力。但是，在运行时，一旦使用了关于接口的引用，变量原本的类型被抹去，我们无法单纯从一个指针分析出这个引用具备什么样的能力。</p><p>因此，<strong>在生成这个引用的时候，我们需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表</strong>。这个列表，就是我们熟知的虚表（virtual table）。</p><p>下图展示了一个 Vec<u8> 数据在运行期被抹去类型，生成一个指向 Write 接口引用的过程：</u8></p><p><img src=\"https://static001.geekbang.org/resource/image/27/f9/27f671936d44d08d837fbf68baee21f9.jpg?wh=1920x1409\" alt=\"图片\"></p><p>由于虚表记录了数据能够执行的接口，所以在运行期，我们想对一个接口有不同实现，可以根据上下文动态分派。</p><p>比如我想为一个编辑器的 Formatter  接口实现不同语言的格式化工具。我们可以在编辑器加载时，把所有支持的语言和其格式化工具放入一个哈希表中，哈希表的 key 为语言类型，value 为每种格式化工具 Formatter 接口的引用。这样，当用户在编辑器打开某个文件的时候，我们可以根据文件类型，找到对应 Formatter 的引用，来进行格式化操作。</p><h2>运行方式</h2><p>程序在加载后，<strong>代码以何种方式运行，往往决定着程序的执行效率</strong>。所以我们接下来讨论并发、并行、同步、异步以及异步中的几个重要概念 Promise/async/await。</p><h3>并发（concurrency）与并行（parallel）</h3><p>并发和并行是软件开发中经常遇到的概念。</p><p>并发是同时与多件事情打交道的能力，比如系统可以在任务 1 做到一定程度后，保存该任务的上下文，挂起并切换到任务 2，然后过段时间再切换回任务 1。</p><p>并行是同时处理多件事情的手段。也就是说，任务 1 和任务 2 可以在同一个时间片下工作，无需上下文切换。下图很好地阐释了二者的区别：</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/8c/9d93f6445fb47a58bfb8149752dfe78c.jpg?wh=1920x1510\" alt=\"图片\"></p><p><strong>并发是一种能力，而并行是一种手段</strong>。当我们的系统拥有了并发的能力后，代码如果跑在多个 CPU core 上，就可以并行运行。所以我们平时都谈论高并发处理，而不会说高并行处理。</p><p>很多拥有高并发处理能力的编程语言，会在用户程序中嵌入一个 M:N 的调度器，把 M 个并发任务，合理地分配在 N 个 CPU core 上并行运行，让程序的吞吐量达到最大。</p><h3>同步和异步</h3><p>同步是指一个任务开始执行后，后续的操作会阻塞，直到这个任务结束。在软件中，我们大部分的代码都是同步操作，比如 CPU，只有流水线中的前一条指令执行完成，才会执行下一条指令。一个函数 A 先后调用函数 B 和 C，也会执行完 B 之后才执行 C。</p><p>同步执行保证了代码的因果关系（causality），是程序正确性的保证。</p><p>然而在遭遇 I/O 处理时，高效 CPU 指令和低效 I/O 之间的巨大鸿沟，成为了软件的性能杀手。下图<a href=\"https://gist.github.com/hellerbarde/2843375\">对比了 CPU、内存、I/O 设备、和网络的延迟</a>：</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/27/d49a95ec12608ea4116a78723dd97a27.png?wh=1024x512\" alt=\"图片\"></p><p>我们可以看到和内存访问相比，I/O 操作的访问速度低了两个数量级，一旦遇到 I/O 操作，CPU 就只能闲置来等待 I/O 设备运行完毕。因此，操作系统为应用程序提供了异步 I/O，让应用可以在当前 I/O 处理完毕之前，将 CPU 时间用作其它任务的处理。</p><p>所以，<strong>异步是指一个任务开始执行后，与它没有因果关系的其它任务可以正常执行，不必等待前一个任务结束</strong>。</p><p>在异步操作里，异步处理完成后的结果，一般用 Promise 来保存，它是一个对象，用来描述在未来的某个时刻才能获得的结果的值，一般存在三个状态；</p><ol>\n<li>初始状态，Promise 还未运行；</li>\n<li>等待（pending）状态，Promise 已运行，但还未结束；</li>\n<li>结束状态， Promise 成功解析出一个值，或者执行失败。</li>\n</ol><p>如果你对 Promise 这个词不太熟悉，在很多支持异步的语言中，Promise 也叫 Future / Delay / Deferred 等。除了这个词以外，我们也经常看到 async/await 这对关键字。</p><p>一般而言，<strong>async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行</strong>。大多数语言中，async/await 是一个语法糖（syntactic sugar），它使用状态机将 Promise 包装起来，让异步调用的使用感觉和同步调用非常类似，也让代码更容易阅读。</p><h2>编程范式</h2><p>为了在不断迭代时，更好地维护代码，我们还会<strong>引入各种各样的编程范式，来提升代码的质量</strong>。所以最后来谈谈泛型编程。</p><p>如果你来自于弱类型语言，如 C / Python / JavaScript，那泛型编程是你需要重点掌握的概念和技能。泛型编程包含两个层面，数据结构的泛型和使用泛型结构代码的泛型化。</p><h3>数据结构的泛型</h3><p>首先是数据结构的泛型，它也往往被称为参数化类型或者参数多态，比如下面这个数据结构：</p><pre><code class=\"language-rust\">struct Connection&lt;S&gt; {\n  io: S,\n  state: State,\n}\n</code></pre><p>它有一个参数 S，其内部的域 io 的类型是 S，S 具体的类型只有在使用 Connection 的上下文中才得到绑定。<br>\n你可以把参数化数据结构理解成一个产生类型的函数，<strong>在“调用”时，它接受若干个使用了具体类型的参数，返回携带这些类型的类型</strong>。比如我们为 S 提供 TcpStream 这个类型，那么就产生 Connection<tcpstream> 这个类型，其中 io 的类型是 TcpStream。</tcpstream></p><p>这里你可能会疑惑，如果 S 可以是任意类型，那我们怎么知道 S 有什么行为？如果我们要调用  <code>io.send()</code> 发送数据，编译器怎么知道 S 包含这个方法？</p><p>这是个好问题，<strong>我们需要用接口对 S 进行约束</strong>。所以我们经常看到，支持泛型编程的语言，会提供强大的接口编程能力，在后续的课程中在讲 Rust 的 trait 时，我会再详细探讨这个问题。</p><p>数据结构的泛型是一种高级抽象，就像我们人类用数字抽象具体事物的数量，又发明了代数来进一步抽象具体的数字一样。它带来的好处是我们可以延迟绑定，让数据结构的通用性更强，适用场合更广阔；也大大减少了代码的重复，提高了可维护性。</p><h3>代码的泛型化</h3><p>泛型编程的另一个层面是使用泛型结构后代码的泛型化。当我们使用泛型结构编写代码时，相关的代码也需要额外的抽象。</p><p>这里用我们熟悉的二分查找的例子解释会比较清楚：<br>\n<img src=\"https://static001.geekbang.org/resource/image/b4/7f/b49604fa5bf1d88fc05a22a1yy3b267f.jpg?wh=3569x1702\" alt=\"\"></p><p>左边用 C 撰写的二分查找，标记的几处操作隐含着和 int[] 有关，所以如果对不同的数据类型做二分查找，实现也要跟着改变。右边 C++ 的实现，对这些地方做了抽象，让我们可以用同一套代码二分查找迭代器（iterator）的数据类型。</p><p>同样的，这样的代码可以在更广阔的场合使用，更简洁容易维护。</p><h2>小结</h2><p>今天我们讨论了四大类基础概念：数据、代码、运行方式和编程范式。</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/c6/9abef11d349bbcefbb07e39191e7cec6.jpg?wh=1920x1298\" alt=\"图片\"></p><p><strong>值</strong>无法离开类型单独讨论，<strong>类型</strong>一般分为原生类型和组合类型。<strong>指针和引用</strong>都指向值的内存地址，只不过二者在解引用时的行为不一样。引用只能解引用到原来的数据类型，而指针没有这个限制，然而，不受约束的指针解引用，会带来内存安全方面的问题。</p><p><strong>函数</strong>是代码中重复行为的抽象，<strong>方法</strong>是对象内部定义的函数，而<strong>闭包</strong>是一种特殊的函数，它会捕获函数体内使用到的上下文中的自由变量，作为闭包成员的一部分。</p><p>而<strong>接口</strong>将调用者和实现者隔离开，大大促进了代码的复用和扩展。面向接口编程可以让系统变得灵活，当使用接口去引用具体的类型时，我们就需要<strong>虚表</strong>来辅助运行时代码的执行。有了虚表，我们可以很方便地进行动态分派，它是运行时多态的基础。</p><p>在代码的运行方式中，<strong>并发</strong>是<strong>并行</strong>的基础，是同时与多个任务打交道的能力；并行是并发的体现，是同时处理多个任务的手段。<strong>同步</strong>阻塞后续操作，<strong>异步</strong>允许后续操作。被广泛用于异步操作的 Promise 代表未来某个时刻会得到的结果，async/await 是 Promise 的封装，一般用状态机来实现。</p><p><strong>泛型编程</strong>通过参数化让数据结构像函数一样延迟绑定，提升其通用性，类型的参数可以用接口约束，使类型满足一定的行为，同时，在使用泛型结构时，我们的代码也需要更高的抽象度。</p><p>这些基础概念，这对于后续理解 Rust 的很多概念至关重要。如果你对某些概念还是有些模糊，务必留言，我们可以进一步讨论。</p><h3>思考题</h3><p>（现在我们还没有讲到 Rust 的具体语法，所以你可以用自己平时常用的语言来思考这几道题，巩固你对基本概念的理解）</p><p>1.有一个指向某个函数的指针，如果将其解引用成一个列表，然后往列表中插入一个元素，请问会发生什么？（对比不同语言，看看这种操作是否允许，如果允许会发生什么）</p><p>2.要构造一个数据结构 Shape，可以是 Rectangle、 Circle 或是 Triangle，这三种结构见如下代码。请问 Shape 类型该用什么数据结构实现？怎么实现？</p><pre><code class=\"language-rust\">struct Rectangle {\n   a: f64,\n   b: f64,\n}\n\nstruct Circle {\n  r: f64,\n}\n\nstruct Triangle {\n  a: f64,\n  b: f64,\n  c: f64,\n}\n</code></pre><p>3.对于上面的三种结构，如果我们要定义一个接口，可以计算周长和面积，怎么计算？</p><p>欢迎在留言区分享你的思考。今天是我们打卡学习的第二讲，如果你觉得有收获，也欢迎你分享给你身边的朋友，邀TA一起讨论。</p><h3>参考资料</h3><p>Latency numbers every programmer should know，<a href=\"https://gist.github.com/hellerbarde/2843375\">对比了 CPU、内存、I/O 设备、和网络的延迟</a></p>","comments":[{"had_liked":false,"id":308801,"user_name":"Geek_5b5ca4","can_delete":false,"product_type":"c1","uid":1693342,"ip_address":"","ucode":"85FFD3976D9D1A","user_header":"https://static001.geekbang.org/account/avatar/00/19/d6/9e/d847c1f0.jpg","comment_is_top":true,"comment_ctime":1629804337,"is_pvip":false,"replies":[{"id":"111784","content":"这里我写的不太严谨。强类型和弱类型的定义一直不太明确，wikipedia 上也没有一个标准的说法。https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Strong_and_weak_typing。我一般是看类型在调用时是否会发生隐式转换，所以说 python 是弱类型。不过 wikipedia 在介绍 python 时确实说它是 strongly typed：https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Python_(programming_language)。<br><br>但如果按照类型是否会隐式转换，Rust 是强类型，Python 和 C 是弱类型：<br><br>```rust<br>fn main() {<br>    let a = 42u8;<br>    let b = 42.0f64;<br>    <br>    &#47;&#47; 不会做隐式转换<br>    println!(&quot;a+b = {}&quot;, a+b);<br>}<br>```<br><br>Python 会做类型的隐式转换：<br><br>```python<br>def add_numbers(a, b):<br>    return a + b<br><br>if __name__ == &#39;__main__&#39;:<br>    a = 42<br>    b = 42.0<br>    print(add_numbers(a,b))<br>```<br><br>C 也会：<br><br>```C<br>#include &lt;stdio.h&gt;<br><br>int add_numbers(int a, int b) {<br>    int result = a + b;<br>    return result;<br>}<br><br>int main() {<br>    char c = &quot;42&quot;;<br>    int n = 42;<br><br>    &#47;&#47; 为什么说 C 是 weakly typed<br>    int result = add_numbers(c, n);<br>    printf(&quot;%d\\n&quot;, result);<br><br>    return 0;<br>}<br>```","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629848892,"ip_address":"","comment_id":308801,"utype":1}],"discussion_count":5,"race_medal":0,"score":"9.2233721630385992e+18","product_id":100085301,"comment_content":"Python 是强类型动态语言","like_count":30,"discussions":[{"author":{"id":2150011,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJwhuiaWy0E1xoq2o6Qdfast5ibtmib0zvvUOpbibrjBNeegwoR2O9HxSvwTIRYTR49Q1eEqNlkQWLqaA/132","nickname":"随便取一个","note":"","ucode":"CBCE93E49F2A5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546152,"discussion_content":"如果具有隐式转换的为弱类型，也很多语言都是了，至少主流的编程语言绝大多数都是","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642177916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525628,"discussion_content":"这里我写的不太严谨。强类型和弱类型的定义一直不太明确，wikipedia 上也没有一个标准的说法。https://en.wikipedia.org/wiki/Strong_and_weak_typing。我一般是看类型在调用时是否会发生隐式转换，所以说 python 是弱类型。不过 wikipedia 在介绍 python 时确实说它是 strongly typed：https://en.wikipedia.org/wiki/Python_(programming_language)。\n\n但如果按照类型是否会隐式转换，Rust 是强类型，Python 和 C 是弱类型：\n\n```rust\nfn main() {\n    let a = 42u8;\n    let b = 42.0f64;\n    \n    // 不会做隐式转换\n    println!(&amp;quot;a+b = {}&amp;quot;, a+b);\n}\n```\n\nPython 会做类型的隐式转换：\n\n```python\ndef add_numbers(a, b):\n    return a + b\n\nif __name__ == &amp;#39;__main__&amp;#39;:\n    a = 42\n    b = 42.0\n    print(add_numbers(a,b))\n```\n\nC 也会：\n\n```C\n#include &amp;lt;stdio.h&amp;gt;\n\nint add_numbers(int a, int b) {\n    int result = a + b;\n    return result;\n}\n\nint main() {\n    char c = &amp;quot;42&amp;quot;;\n    int n = 42;\n\n    // 为什么说 C 是 weakly typed\n    int result = add_numbers(c, n);\n    printf(&amp;quot;%d\\n&amp;quot;, result);\n\n    return 0;\n}\n```","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629848892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2077869,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/b4/ad/94c0ae00.jpg","nickname":"Nlife","note":"","ucode":"BD075AD4EB9ECE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":556645,"discussion_content":"c语言char类型，第一次见赋值字符串&#34;42&#34;这操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647435807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":525628,"ip_address":""},"score":556645,"extra":""},{"author":{"id":2839988,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/55/b4/5fd0fc40.jpg","nickname":"BrandonH","note":"","ucode":"51ABE1EC0A8255","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2077869,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/b4/ad/94c0ae00.jpg","nickname":"Nlife","note":"","ucode":"BD075AD4EB9ECE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589348,"discussion_content":"这里的变量c是字符指针吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664723018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":556645,"ip_address":"湖南"},"score":589348,"extra":""}]},{"author":{"id":1886468,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjzOFKRWQ1iagtXTAYsPUfdtbPKnYnwXc3ahSjLJrxXib4bq76Z9r39aRa4eMib59YR9ibicI2IRP1fnw/132","nickname":"Geek_1240ce","note":"","ucode":"29ECE58F80A793","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408328,"discussion_content":"按照老师的观点，C# 也属于弱类型语言。某些类型之间也可以发生隐式转换","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635228317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308682,"user_name":"无名氏","can_delete":false,"product_type":"c1","uid":1256121,"ip_address":"","ucode":"584E697AE276AB","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/b9/2bf8cc89.jpg","comment_is_top":true,"comment_ctime":1629733246,"is_pvip":false,"replies":[{"id":"111788","content":"虚表相当于在运行时生成的一个涵盖了一系列函数指针的数据结构。有时候对于不同类型但是满足相同接口的数据，我们希望可以抹去他们的原始类型，让它们有相同的接口类型，以便于统一处理，这样更加灵活，但此时需要为每个数据构造他们各自对接口实现的虚表，这样可以依旧调用到属于该类型的实现。<br><br>虚表一般存储在堆上。Rust 下也有虚表的栈实现：https:&#47;&#47;github.com&#47;archshift&#47;dynstack","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629850064,"ip_address":"","comment_id":308682,"utype":1}],"discussion_count":3,"race_medal":0,"score":"9.2233721114989998e+18","product_id":100085301,"comment_content":"虚表没有理解，虚表会存储在哪里","like_count":17,"discussions":[{"author":{"id":2186045,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/3d/634776c9.jpg","nickname":"蟋蟀大叔","note":"","ucode":"0FB40046EC3596","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395072,"discussion_content":"最早出自C++,  深入理解C++对象模型","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1632215537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525588,"discussion_content":"虚表相当于在运行时生成的一个涵盖了一系列函数指针的数据结构。有时候对于不同类型但是满足相同接口的数据，我们希望可以抹去他们的原始类型，让它们有相同的接口类型，以便于统一处理，这样更加灵活，但此时需要为每个数据构造他们各自对接口实现的虚表，这样可以依旧调用到属于该类型的实现。\n\n虚表一般存储在堆上。Rust 下也有虚表的栈实现：https://github.com/archshift/dynstack","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629850064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037669,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/65/1c9f1530.jpg","nickname":"NorthWind","note":"","ucode":"459ADF3B0945E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576065,"discussion_content":"感觉是信息终归不可以丢失的，换个地方存储罢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655266226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308555,"user_name":"Christian","can_delete":false,"product_type":"c1","uid":1089000,"ip_address":"","ucode":"D84F866015BA07","user_header":"https://static001.geekbang.org/account/avatar/00/10/9d/e8/39433235.jpg","comment_is_top":false,"comment_ctime":1629685199,"is_pvip":false,"replies":[{"id":"111797","content":"正确！非常棒！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629851765,"ip_address":"","comment_id":308555,"utype":1}],"discussion_count":5,"race_medal":0,"score":"293687461327","product_id":100085301,"comment_content":"1. 函数放在代码段中，通常是只读的，往只读段写入数据会触发保护异常。<br><br>2. 使用 enum：<br>```rust<br>enum Shape {<br>    Rectangle(Rectangle),<br>    Circle(Circle),<br>    Triangle(Triangle),<br>}<br>```<br><br>3. 定义一个 trait 并为三种结构都实现该 trait：<br>```rust<br>trait SomeInterface {<br>    fn area(&amp;self) -&gt; f64;<br>    fn circumference(&amp;self) -&gt; f64;<br>}<br><br>impl Rectangle for SomeInterface {<br>    fn area(&amp;self) -&gt; f64 {<br>        ...<br>    }<br><br>    fn circumference(&amp;self) -&gt; f64 {<br>        ...<br>    }<br>}<br><br>impl Circle for SomeInterface {<br>    ...<br>}<br><br>impl Triangle for SomeInterface {<br>    ...<br>}<br>```","like_count":69,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525535,"discussion_content":"正确！非常棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629851765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2745265,"avatar":"","nickname":"Geek_5cb04f","note":"","ucode":"E687EE27D350DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390352,"discussion_content":"impl xxxtrait for  xxxstruct {\n\n}","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1629795037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2738622,"avatar":"https://static001.geekbang.org/account/avatar/00/29/c9/be/1949917d.jpg","nickname":"🔥神山 | 雷神山","note":"","ucode":"1552CB73E89381","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390367,"discussion_content":"impl Triangle for SomeInterface  反了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1629801417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403574,"discussion_content":"有一点缺憾：无法直接在 Shape 上调用 area 和 circumference，所以应该为 Shape 也 impl 这个 trait","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634112157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1086649,"avatar":"https://static001.geekbang.org/account/avatar/00/10/94/b9/77e7119c.jpg","nickname":"大象","note":"","ucode":"B943C3921F1F1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405869,"discussion_content":"类似面向对象的父类抽象定义方法，子类重写方法实现面积与周长计算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634654518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308793,"user_name":"🔥神山 | 雷神山","can_delete":false,"product_type":"c1","uid":2738622,"ip_address":"","ucode":"1552CB73E89381","user_header":"https://static001.geekbang.org/account/avatar/00/29/c9/be/1949917d.jpg","comment_is_top":false,"comment_ctime":1629800509,"is_pvip":false,"replies":[{"id":"111809","content":"非常棒！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629853744,"ip_address":"","comment_id":308793,"utype":1}],"discussion_count":8,"race_medal":0,"score":"100414048317","product_id":100085301,"comment_content":"1. 有一个指向某个函数的指针，如果将其解引用成一个列表，然后往列表中插入一个元素，请问会发生什么？<br>对于强类型语言（如：rust），无法解引用成一个列表，rust会提示类型不匹配错误。<br>对于弱类型语言(如：python, javascript)，解引用成一个列表后，可以正常插入元素。<br>```javascript<br>let fn = function (title) { console.log(title); }<br>    fn(&quot;test&quot;);<br>    fn = [1, 2, 3, 4, 5, 6, 7, 8];<br>    fn.push(9);<br>    console.log(fn);<br>```<br>```rust<br>let func = |x| x;<br>    func(1);<br>    func = vec![1, 2, 3];<br>    println!(func);<br>```<br>2. 要构造一个数据结构 Shape，可以是 Rectangle、 Circle 或是 Triangle，这三种结构见如下代码。请问 Shape 类型该用什么数据结构实现？怎么实现？<br>```rust<br>use std::f64::consts;<br>trait Calculator {<br>    fn perimeter(&amp;self) -&gt; f64;<br>    fn area(&amp;self) -&gt; f64;<br>}<br><br>struct Rectangle {<br>    a: f64,<br>    b: f64,<br>}<br><br>struct Circle {<br>    r: f64,<br>}<br><br>struct Triangle {<br>    a: f64,<br>    b: f64,<br>    c: f64,<br>}<br><br>#[derive(Debug)]<br>enum EShape {<br>    Rectangle(f64, f64),<br>    Circle(f64),<br>    Triangle(f64, f64, f64),<br>}<br><br>#[derive(Debug)]<br>struct Shape {<br>    shape: EShape,<br>}<br>impl Shape {<br>    fn new(shape: EShape) -&gt; Shape {<br>        Shape { shape }<br>    }<br>}<br><br>impl Calculator for Shape {<br>    fn perimeter(&amp;self) -&gt; f64 {<br>        match self.shape {<br>            EShape::Rectangle(a, b) =&gt; (a + b) * 2.0,<br>            EShape::Circle(r) =&gt; 2.0 * consts::PI * r,<br>            EShape::Triangle(a, b, c) =&gt; a + b + c,<br>        }<br>    }<br>    fn area(&amp;self) -&gt; f64 {<br>        match self.shape {<br>            EShape::Rectangle(a, b) =&gt; a * b,<br>            EShape::Circle(r) =&gt; consts::PI * r * r,<br>            EShape::Triangle(a, b, c) =&gt; {<br>                let p = (a + b + c) &#47; 2.0;<br>                (p * (p - a) * (p - b) * (p - c)).sqrt()<br>            }<br>        }<br>    }<br>}<br><br>fn main() {<br>    let shape = Shape::new(EShape::Triangle(3.0, 4.0, 5.0));<br>    println!(&quot;shape:{:#?}&quot;, shape);<br>    println!(&quot;perimeter: {}&quot;, shape.perimeter());<br>    println!(&quot;area: {}&quot;, shape.area());<br>}<br>```<br>3. 对于上面的三种结构，如果我们要定义一个接口，可以计算周长和面积，怎么计算？<br>只需要将上述代码中的Rectangle ，Circle ，Triangle 三个结构体分别实现Calculator trait即可。","like_count":23,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525625,"discussion_content":"非常棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629853744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1176417,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f3/61/8f7fca5b.jpg","nickname":"芥末小龙","note":"","ucode":"387D01880867AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391682,"discussion_content":"这个操作就有点6了，最起码研究了好久rust了 。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1630573909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1080653,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7d/4d/d98865b2.jpg","nickname":"老实人Honey","note":"","ucode":"EA4AB5C0C33090","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541480,"discussion_content":"fn = [1, 2, 3, 4, 5, 6, 7, 8]; //这个做法是重新赋值了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1640400947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403578,"discussion_content":"问题1是解引用，不是重新赋值吧……","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1634112410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3017100,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIHgYiaBZz5RRCibgCQFJB9EHVBKA2HsRdsV0Nv04SVtnK5oUBG3shC6jVlFLZrobJSicAEBRjjb0YGg/132","nickname":"HelloWorld","note":"","ucode":"E7AEFF7DD618BB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576768,"discussion_content":"是一种实现方式，但这种实现方式并没有用到题目中的3个struct，那3个struct的代码完全可以注释掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655782194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1159530,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b1/6a/b1e05143.jpg","nickname":"inmo","note":"","ucode":"A9590E563C93CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559967,"discussion_content":"有经验","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649084036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142350,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/4e/034e2943.jpg","nickname":"翅膀","note":"","ucode":"F5169AD26A41B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550264,"discussion_content":"在c 中这个shape 通过 union 实现.   在 go 中这个shape 怎么实现? ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644461536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403580,"discussion_content":"看不太明白为什么要多一层EShape……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634112432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310544,"user_name":"虾","can_delete":false,"product_type":"c1","uid":1480118,"ip_address":"","ucode":"AD2E4C1EA4A946","user_header":"https://static001.geekbang.org/account/avatar/00/16/95/b6/9aff520e.jpg","comment_is_top":false,"comment_ctime":1630731400,"is_pvip":false,"replies":[{"id":"112514","content":"好问题。这个在讲 trait 的那一课有讲到。虚表是每个 impl TraitA for TypeB {} 时就会编译出一份。比如 String 的 Debug 实现, String 的 Display 实现各有一份虚表，它们在编译时就生成并放在了二进制文件中（大多是 RODATA 段中）。<br><br>所以虚表是每个 (Trait, Type) 一份。并且在编译时就生成好了。<br><br>如果你感兴趣，可以在 playground 里运行这段代码（这是后面讲 trait 时使用的代码）：https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=89311eb50772982723a39b23874b20d6。限于篇幅，代码就不贴了。<br>","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630777294,"ip_address":"","comment_id":310544,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53170338952","product_id":100085301,"comment_content":"请问一个关于虚表的问题。虚表是每个类有一份，还是每个对象有一份，还是每个胖指针有一份？","like_count":12,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526269,"discussion_content":"好问题。这个在讲 trait 的那一课有讲到。虚表是每个 impl TraitA for TypeB {} 时就会编译出一份。比如 String 的 Debug 实现, String 的 Display 实现各有一份虚表，它们在编译时就生成并放在了二进制文件中（大多是 RODATA 段中）。\n\n所以虚表是每个 (Trait, Type) 一份。并且在编译时就生成好了。\n\n如果你感兴趣，可以在 playground 里运行这段代码（这是后面讲 trait 时使用的代码）：https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=89311eb50772982723a39b23874b20d6。限于篇幅，代码就不贴了。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630777294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308727,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1629772552,"is_pvip":true,"replies":[{"id":"111786","content":"嗯，前两篇都是每个程序员最好掌握的基础知识。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629849097,"ip_address":"","comment_id":308727,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53169380104","product_id":100085301,"comment_content":"这一篇是对编程语言的高度抽象呀，这一篇的知识完全可以应用到任何一门编程语言上。","like_count":12,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525605,"discussion_content":"嗯，前两篇都是每个程序员最好掌握的基础知识。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629849097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308750,"user_name":"太子长琴","can_delete":false,"product_type":"c1","uid":1090266,"ip_address":"","ucode":"0627D0FA370AD4","user_header":"https://static001.geekbang.org/account/avatar/00/10/a2/da/a8a32113.jpg","comment_is_top":false,"comment_ctime":1629781598,"is_pvip":false,"replies":[{"id":"111806","content":"1 的题意可以看这个代码：<br><br>```C<br>#include &quot;stdio.h&quot;<br><br>void hello() {<br>    printf(&quot;Hello world!\\n&quot;);<br>}<br><br>int main() {<br>    char buf[1024];<br>    void (* p)() = &amp;hello;<br>    (*p)();<br>    int *p1 = (int *) p;<br>    p1[1] = 0xdeadbeef;<br>}<br>```<br><br>在 C 语言中，这种操作是允许的，但会造成内存访问越界，导致崩溃；在 Rust 中，编译器会拒绝这样的操作。<br><br>2&#47;3 正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629853096,"ip_address":"","comment_id":308750,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31694552670","product_id":100085301,"comment_content":"第一个题意不是特别理解<br>后面的倾向于用 match，每个 struct 重复 impl 看着就觉得烦<br><br>pub enum ShapeEnum {<br>    Rectangle(f64, f64),<br>    Circle(f64),<br>    Triangle(f64, f64, f64),<br>}<br><br>#[derive(Debug)]<br>pub struct Shape {<br>    pub shape: ShapeEnum,<br>}<br><br>impl Shape {<br>    pub fn new(shape: ShapeEnum) -&gt; Shape {<br>        Shape { shape: shape }<br>    }<br>}<br><br>pub trait Calculate {<br>    fn perimeter(&amp;self) -&gt; f64;<br>    fn area(&amp;self) -&gt; f64;<br>}<br><br>impl Calculate for Shape {<br>    fn perimeter(&amp;self) -&gt; f64 {<br>        match self.shape {<br>            ShapeEnum::Rectangle(a, b) =&gt; 2.0 * (a + b),<br>            ShapeEnum::Circle(r) =&gt; 2.0 * 3.14 * r,<br>            ShapeEnum::Triangle(a, b, c) =&gt; a + b + c,<br>        }<br>    }<br>    fn area(&amp;self) -&gt; f64 {<br>        match self.shape {<br>            ShapeEnum::Rectangle(a, b) =&gt; a * b,<br>            ShapeEnum::Circle(r) =&gt; 3.14 * r * r,<br>            ShapeEnum::Triangle(a, b, c) =&gt; {<br>                let p = (a + b + c) &#47; 2.0;<br>                (p * (p - a) * (p - b) * (p - c)).sqrt()<br>            }<br>        }<br>    }<br>}","like_count":7,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525611,"discussion_content":"1 的题意可以看这个代码：\n\n```C\n#include &amp;quot;stdio.h&amp;quot;\n\nvoid hello() {\n    printf(&amp;quot;Hello world!\\n&amp;quot;);\n}\n\nint main() {\n    char buf[1024];\n    void (* p)() = &amp;amp;hello;\n    (*p)();\n    int *p1 = (int *) p;\n    p1[1] = 0xdeadbeef;\n}\n```\n\n在 C 语言中，这种操作是允许的，但会造成内存访问越界，导致崩溃；在 Rust 中，编译器会拒绝这样的操作。\n\n2/3 正确！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629853096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1090266,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a2/da/a8a32113.jpg","nickname":"太子长琴","note":"","ucode":"0627D0FA370AD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390470,"discussion_content":"理解了，哈，谢谢解疑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629855797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309683,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":2056379,"ip_address":"","ucode":"0394736BADF597","user_header":"https://static001.geekbang.org/account/avatar/00/1f/60/bb/69cc96cb.jpg","comment_is_top":false,"comment_ctime":1630301809,"is_pvip":false,"replies":[{"id":"112157","content":"虚表你可以理解成一张指向若干个函数地址的表。这样在运行时，可以通过这张表找出要执行的函数，进而执行。比如 w.write()，如果 w 是一个类型被抹去的引用，指向了一块地址，此时 w 如何能够执行到 write() 方法？只能通过运行时构造的虚表来解决。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630303959,"ip_address":"","comment_id":309683,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27400105585","product_id":100085301,"comment_content":"作为一个只写过脚本语言的前端，看虚表那部分基本上等于是在看天书，太菜了呜呜呜","like_count":6,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525965,"discussion_content":"虚表你可以理解成一张指向若干个函数地址的表。这样在运行时，可以通过这张表找出要执行的函数，进而执行。比如 w.write()，如果 w 是一个类型被抹去的引用，指向了一块地址，此时 w 如何能够执行到 write() 方法？只能通过运行时构造的虚表来解决。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630303959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2401741,"avatar":"","nickname":"canloop","note":"","ucode":"0042CE27486600","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546617,"discussion_content":"虚表可以用数据库表来理解吗，\n主建为w的write方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642349780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":525965,"ip_address":""},"score":546617,"extra":""}]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403583,"discussion_content":"加油，我也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634113072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308582,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1629690293,"is_pvip":false,"replies":[{"id":"111802","content":"对是 error lens。感谢 coer 的解答。https:&#47;&#47;marketplace.visualstudio.com&#47;items?itemName=usernamehw.errorlens","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629852809,"ip_address":"","comment_id":308582,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27399494069","product_id":100085301,"comment_content":"我想问问B站油管视频里那个vscode直接在出错的那一行显示错误信息怎么弄的，我装了ra，但是出错信息还是显示在底部。","like_count":6,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525548,"discussion_content":"对是 error lens。感谢 coer 的解答。https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629852809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2738707,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ca/13/5d18834a.jpg","nickname":"coer","note":"","ucode":"8067F14BC50F48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390267,"discussion_content":"Error Lens插件","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629733366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311224,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1631111747,"is_pvip":false,"replies":[{"id":"112791","content":"嗯。限于篇幅，确实有好多东西无法都讲到。状态机在讲 async&#47;await 的时候会具体介绍。<br><br>单态化在具体讲泛型时会介绍。<br><br>虚表会在讲 trait 时具体介绍。<br><br>动态分发的性能比静态分发差很多，可能是数量级的差别。静态分发单态化后直接跳转到方法执行；动态分发会先找到虚表，再找到虚表中对应的方法，再跳转到对应的方法执行。这个过程会大概率有两次 cache miss。<br><br>代码倒并不太会不好理解吧，尤其是现在不加 dyn 会有编译器 warning，dyn T 还是一目了然知道是哪个 trait 的 trait object。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631150946,"ip_address":"","comment_id":311224,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23105948227","product_id":100085301,"comment_content":"首先建议这里补充一下状态机的概念，这个也是很核心的但是平时不太重视。另外虚表和泛型那里的例子，rust编程之道的书上提到实现加法这个功能，那里数字有整型和浮点型，如果正常实现要一一列举出来，使用泛型就可以很抽象地弄出来了。而这个背后，编译器其实会有一个叫单态化的操作，也就是把具体类型实现编译出来，那样会导致编译文件变大一点，但不是不可接受。<br>另外虚表这里涉及到rust的动态分发概念，就是当没有使用where这些约束的时候，那么编译时无法知道具体类型就需要用到虚表这些了，而一般来说，静态抽象的成本还是低一点的，动态分发有性能成本存在，而且有时候代码不好理解？","like_count":5,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526527,"discussion_content":"嗯。限于篇幅，确实有好多东西无法都讲到。状态机在讲 async/await 的时候会具体介绍。\n\n单态化在具体讲泛型时会介绍。\n\n虚表会在讲 trait 时具体介绍。\n\n动态分发的性能比静态分发差很多，可能是数量级的差别。静态分发单态化后直接跳转到方法执行；动态分发会先找到虚表，再找到虚表中对应的方法，再跳转到对应的方法执行。这个过程会大概率有两次 cache miss。\n\n代码倒并不太会不好理解吧，尤其是现在不加 dyn 会有编译器 warning，dyn T 还是一目了然知道是哪个 trait 的 trait object。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631150946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308617,"user_name":"kimi","can_delete":false,"product_type":"c1","uid":1014643,"ip_address":"","ucode":"4DBCA231850D6A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/73/e5b46aa9.jpg","comment_is_top":false,"comment_ctime":1629706073,"is_pvip":false,"replies":[{"id":"111803","content":"正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629852839,"ip_address":"","comment_id":308617,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23104542553","product_id":100085301,"comment_content":"1. C 语言是可以把一个函数指针解引用为一个列表的，往列表中插入一个元素会报错，这是因为函数是代码，在内存中通常会存放在只读区域，对这部分内存写会报错；<br>2. 定义一个 Shape 接口；<br>3. 在 Shape 接口中定义一个计算周长和面积的方案；<br><br>还不会写 Rust 代码，只能用 Java 的思路来考虑，希望学完本课程能用 Rust 的思路来思考和编程；","like_count":5,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525562,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629852839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320160,"user_name":"TheLudlows","can_delete":false,"product_type":"c1","uid":1069346,"ip_address":"","ucode":"64895727505014","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/22/d12f7a72.jpg","comment_is_top":false,"comment_ctime":1636102960,"is_pvip":false,"replies":[{"id":"116350","content":"宏的语法提示很难做，基本上支持宏的语言，自动提示都做得不好，尤其是像 tokio::select! 宏这样子里面还能有复杂的代码逻辑。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636526576,"ip_address":"","comment_id":320160,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14521004848","product_id":100085301,"comment_content":"习惯了写Java那种自动提示，Rust一碰到宏就没法提示就特别慌张，不知道其他人有没有这种感觉","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529899,"discussion_content":"宏的语法提示很难做，基本上支持宏的语言，自动提示都做得不好，尤其是像 tokio::select! 宏这样子里面还能有复杂的代码逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636526576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/a2/721ae4c6.jpg","nickname":"Jervis","note":"","ucode":"86C02C483449CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588979,"discussion_content":"没提示会让我有种倒退的感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664284567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308580,"user_name":"你好梦梦","can_delete":false,"product_type":"c1","uid":1259578,"ip_address":"","ucode":"17A25B7AE62549","user_header":"https://static001.geekbang.org/account/avatar/00/13/38/3a/102afd91.jpg","comment_is_top":false,"comment_ctime":1629689968,"is_pvip":false,"replies":[{"id":"111801","content":"对。如果要覆盖的话，程序会崩溃，因为 TEXT 段不可泄，而且在这个过程中，可能会出现 aligment 错误。我也用 C 写了个例子：<br><br>```C<br>#include &quot;stdio.h&quot;<br><br>void hello() {<br>    printf(&quot;Hello world!\\n&quot;);<br>}<br><br>int main() {<br>    char buf[1024];<br>    void (* p)() = &amp;hello;<br>    (*p)();<br>    int *p1 = (int *) p;<br>    p1[1] = 0xdeadbeef;<br>}<br>```","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629852741,"ip_address":"","comment_id":308580,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14514591856","product_id":100085301,"comment_content":"我用简单c++代码描述一下老师这个问题，不知道是不是这个意思：<br>typedef void (*funptr)(int,int);<br>void funtest(int,int){}<br>funptr p = funtest;<br>int* parr = (int*)p;  &#47;&#47;转成数组指针<br>parr[0] = 1; parr[1]=2<br>如果是这样的话，parr[0]、parr[1]会引发未知错误，因为他会覆盖原有内存区域的值。<br>对于Java、C#这些语言，在他们提供了Lambda、委托这种函数，其实是无法做强制转换的，<br>Rust还在学习，但我感觉应该不行，如果行的话，他就不强调自己安全啦。","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525547,"discussion_content":"对。如果要覆盖的话，程序会崩溃，因为 TEXT 段不可泄，而且在这个过程中，可能会出现 aligment 错误。我也用 C 写了个例子：\n\n```C\n#include &amp;quot;stdio.h&amp;quot;\n\nvoid hello() {\n    printf(&amp;quot;Hello world!\\n&amp;quot;);\n}\n\nint main() {\n    char buf[1024];\n    void (* p)() = &amp;amp;hello;\n    (*p)();\n    int *p1 = (int *) p;\n    p1[1] = 0xdeadbeef;\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629852741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308566,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1629687216,"is_pvip":false,"replies":[{"id":"111799","content":"可以看我之前的回复。强类型弱类型的定义并不算太明确，我接受的定义是类型是否会在使用过程中发生隐式转换，比如 char 如果和 int 相加被转换成 int，和 string 相加被转换成 string。这样的转换往往会超出开发者的预期，导致逻辑bug。Rust 甚至不允许 u8 + u32 这样的操作，而是需要你使用显式的类型转换统一类型后再处理，所以是强类型。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629852045,"ip_address":"","comment_id":308566,"utype":1}],"discussion_count":6,"race_medal":0,"score":"14514589104","product_id":100085301,"comment_content":"老师， 请教一下，<br>强类型语言  和  弱类型语言的 定义是什么，区别是什么。<br>","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525541,"discussion_content":"可以看我之前的回复。强类型弱类型的定义并不算太明确，我接受的定义是类型是否会在使用过程中发生隐式转换，比如 char 如果和 int 相加被转换成 int，和 string 相加被转换成 string。这样的转换往往会超出开发者的预期，导致逻辑bug。Rust 甚至不允许 u8 + u32 这样的操作，而是需要你使用显式的类型转换统一类型后再处理，所以是强类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629852045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731977,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6d/89/14031273.jpg","nickname":"Direction","note":"","ucode":"298D5109EA28EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390241,"discussion_content":"https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629725325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390200,"discussion_content":"编译期是否检查","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629711279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390222,"discussion_content":"大佬， 那静态语言 和 动态语言呢， 感觉有点乱了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629717902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":390200,"ip_address":""},"score":390222,"extra":""},{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390236,"discussion_content":"抱歉我说错了，强弱的区别在于一个变量被定义为一个类型后，变量类型就不可更变，而动态静态才在于编译期是否检查","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629724430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":390222,"ip_address":""},"score":390236,"extra":""},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390298,"discussion_content":"明白了，感谢大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629767390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":390236,"ip_address":""},"score":390298,"extra":""}]}]},{"had_liked":false,"id":317009,"user_name":"脑洞太大补不上","can_delete":false,"product_type":"c1","uid":1062808,"ip_address":"","ucode":"ABB5BA9AE6D50A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIf1t1D3ictrpgeFuIukNLUdicibnibk7GCO4KAv63ffNYbZPPibeTkhcKPpV7XCYpmaGGKsDKN2Miaephg/132","comment_is_top":false,"comment_ctime":1634639727,"is_pvip":false,"replies":[{"id":"115270","content":"👍 非常棒！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635131008,"ip_address":"","comment_id":317009,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10224574319","product_id":100085301,"comment_content":"1. 有一个指向某个函数的指针，如果将其解引用成一个列表，然后往列表中插入一个元素，请问会发生什么？（对比不同语言，看看这种操作是否允许，如果允许会发生什么）<br><br>- C <br>    编译器允许把指针类型转换成列表, 这一步不会引起错误<br>    但在调用插入列表元素函数时应该会出错误, 因为函数指针是在只读段, 真的要去往内存里去写东西的时候, 大概率那个计算出来的被写地址也同样会落在只读段, 写的时候会报错..<br>    不过这如果不是一个函数指针而是别的什么指针, 有可能是不会报错的, 这就更恐怖了..<br><br>- Java &#47; C#<br>    应该没有函数指针这个东西..<br>    不过假如是别的什么类型, 强制类型转换到列表这一步会在运行时报错<br><br>- Python &#47; Javascript &#47; Elixir<br>    不存在类型转换这一步, 直接调用列表插入元素时会在报运行时报错<br><br>- Rust<br>    目前还确定, 猜测应该也是类型转换时会在运行时报错<br><br><br>2, 3 就不重复了","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528612,"discussion_content":"👍 非常棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635131008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311571,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1631299519,"is_pvip":false,"replies":[{"id":"113000","content":"嗯，有意思，不过还是 gdb 更趁手。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631516264,"ip_address":"","comment_id":311571,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10221234111","product_id":100085301,"comment_content":"virtual table check 神器 https:&#47;&#47;godbolt.org&#47;","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526663,"discussion_content":"嗯，有意思，不过还是 gdb 更趁手。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631516264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2206794,"avatar":"","nickname":"Geek3847","note":"","ucode":"5EC8E975EFB1D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393319,"discussion_content":"如何使用这个工具去查看虚表呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631354920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311475,"user_name":"水口行舟入她心","can_delete":false,"product_type":"c1","uid":1039465,"ip_address":"","ucode":"A6876A6DCBD55B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dc/69/4e534d3d.jpg","comment_is_top":false,"comment_ctime":1631248557,"is_pvip":false,"replies":[{"id":"112872","content":"加油！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631283891,"ip_address":"","comment_id":311475,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10221183149","product_id":100085301,"comment_content":"半路出家的Java开发，来学一学面向未来的语言，同时在老师的带领下，夯实基础，做更优秀的开发者","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526623,"discussion_content":"加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631283891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308526,"user_name":"MILI","can_delete":false,"product_type":"c1","uid":1585568,"ip_address":"","ucode":"E16CC7C5495093","user_header":"https://static001.geekbang.org/account/avatar/00/18/31/a0/4a6352ae.jpg","comment_is_top":false,"comment_ctime":1629677577,"is_pvip":false,"replies":[{"id":"111795","content":"1. 在 C 语言中，这种操作是允许的，但会造成内存访问越界，导致崩溃；在 Rust 中，编译器会拒绝这样的操作。<br><br>2&#47;3: 非常棒。enum 的定义可以这样：<br><br>```rust<br>enum Shape {<br>    Rec(Rectangle),<br>    Cir(Circle),<br>    Tri(Triangle),<br>}<br>```<br>我也写了个参考版本，见 https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9bde037aa71319fc88852cdfecc1ac35","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629851598,"ip_address":"","comment_id":308526,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10219612169","product_id":100085301,"comment_content":"1 没找到呀 <br>2.3.<br>fn main() {<br>    struct Rectangle { a: f64, b: f64 }<br>    struct Circle { r: f64 }<br>    struct Triangle { a: f64, b: f64, c: f64 }<br>    enum Shape {<br>        Rectangle,<br>        Circle,<br>        Triangle,<br>    }<br>    pub trait Graphics {<br>        fn perimeter(&amp;self) -&gt; f64;<br>        fn area(&amp;self) -&gt; f64;<br>    }<br>    impl Graphics for Rectangle {<br>        fn perimeter(&amp;self) -&gt; f64 {<br>            (self.a + self.b) * 2 as f64<br>        }<br><br>        fn area(&amp;self) -&gt; f64 {<br>            self.a * self.b<br>        }<br>    }<br>    impl Graphics for Circle {<br>        fn perimeter(&amp;self) -&gt; f64 {<br>            2 * 3.14 * self.r<br>        }<br><br>        fn area(&amp;self) -&gt; f64 {<br>            3.14 * self.r * self.r<br>        }<br>    }<br>    impl Graphics for Triangle {<br>        fn perimeter(&amp;self) -&gt; f64 {<br>            self.a + self.b + self.c<br>        }<br><br>        fn area(&amp;self) -&gt; f64 {<br>            let p = self.a + self.b + self.c;<br>            p * (p - self.a)(p - self.b)(p - self.c).sqrt()<br>        }<br>    }<br>}","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525521,"discussion_content":"1. 在 C 语言中，这种操作是允许的，但会造成内存访问越界，导致崩溃；在 Rust 中，编译器会拒绝这样的操作。\n\n2/3: 非常棒。enum 的定义可以这样：\n\n```rust\nenum Shape {\n    Rec(Rectangle),\n    Cir(Circle),\n    Tri(Triangle),\n}\n```\n我也写了个参考版本，见 https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=9bde037aa71319fc88852cdfecc1ac35","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629851598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347870,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":2853200,"ip_address":"","ucode":"BBDF8E9F348F65","user_header":"https://static001.geekbang.org/account/avatar/00/2b/89/50/aee9fdab.jpg","comment_is_top":false,"comment_ctime":1654523525,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5949490821","product_id":100085301,"comment_content":"&#47;&#47; 第二个问题，用rust还是很方便实现的<br>struct Rectangle{<br>    a: f64,<br>    b: f64,<br>}<br><br>struct Circle{<br>    r: f64<br>}<br><br>struct Triangle{<br>    a: f64,<br>    b: f64,<br>    c: f64<br>}<br><br>enum Shape{<br>    a(Rectangle),<br>    b(Circle),<br>    c(Triangle)<br>}<br><br>fn main() {<br>    <br>}<br><br>第三个问题，还没有写过这个","like_count":1},{"had_liked":false,"id":340328,"user_name":"青山","can_delete":false,"product_type":"c1","uid":1131070,"ip_address":"","ucode":"749BAD1834AC0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/3e/c1f76202.jpg","comment_is_top":false,"comment_ctime":1648741978,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5943709274","product_id":100085301,"comment_content":"看了评论我在想第二个是否可以用泛型解决?","like_count":1},{"had_liked":false,"id":330549,"user_name":"Geek_551d8e","can_delete":false,"product_type":"c1","uid":2892072,"ip_address":"","ucode":"163E260B4A67B7","user_header":"","comment_is_top":false,"comment_ctime":1642038207,"is_pvip":false,"replies":[{"id":"120695","content":"Typescript 和 Rust 在类型系统上有很多可以类比的地方","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642293187,"ip_address":"","comment_id":330549,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937005503","product_id":100085301,"comment_content":"javascript程序员快学哭了，还好前几天学了typescript，感觉这两个语言之间的设计很多地方都想到一块了，这就是语言的现代性吗？","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546304,"discussion_content":"Typescript 和 Rust 在类型系统上有很多可以类比的地方","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642293188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330521,"user_name":"chyuwei","can_delete":false,"product_type":"c1","uid":1361377,"ip_address":"","ucode":"19687765E6DE5D","user_header":"","comment_is_top":false,"comment_ctime":1642008637,"is_pvip":false,"replies":[{"id":"120693","content":"编译时构建的，不是运行时。在编译到具体的使用 dyn Trait 的代码时，会构建出来","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642293118,"ip_address":"","comment_id":330521,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5936975933","product_id":100085301,"comment_content":"虚表是运行时构建的吗？感觉可以在编译时构建。<br>比如一个struct A实现了trait B。 <br>如果在代码中存在 &amp;A -&gt; &amp;B的类型变换，应该可以提前准备好对应的虚表，不用运行时构建。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546302,"discussion_content":"编译时构建的，不是运行时。在编译到具体的使用 dyn Trait 的代码时，会构建出来","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642293118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/a2/721ae4c6.jpg","nickname":"Jervis","note":"","ucode":"86C02C483449CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588980,"discussion_content":"不知道rust有没有反射，运行时创建类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664284895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330336,"user_name":"楼大海","can_delete":false,"product_type":"c1","uid":1020607,"ip_address":"","ucode":"DDF1AB81F1B140","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/bf/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1641917781,"is_pvip":false,"replies":[{"id":"120688","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642292819,"ip_address":"","comment_id":330336,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5936885077","product_id":100085301,"comment_content":"问题1指向了类型系统中【正确性 soundness】、【完备性 completeness】和可停机的不可能三角。引申下去就是著名的协变&#47;逆变猫笼问题。那些允许赋值的语言比如Java就是为了完备性的便利而牺牲掉了正确性，就不得不把正确性检查延后到运行时了。而如果想要在编译期满足正确性的前提下尽可能提升完备性，就需要用到幽灵类型&#47;依赖类型等高级类型系统，它们目前还不很流行（编译期运算效率也不算好），但可以预见这将是编程语言类型系统的未来。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546297,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642292819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330160,"user_name":"鹅帮逮","can_delete":false,"product_type":"c1","uid":2755534,"ip_address":"","ucode":"A6DB1BEFDA5D9A","user_header":"https://static001.geekbang.org/account/avatar/00/2a/0b/ce/f0c520d1.jpg","comment_is_top":false,"comment_ctime":1641821544,"is_pvip":false,"replies":[{"id":"120699","content":"Tag Union - enum 是若干个 tag + 数据的联合体","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642293564,"ip_address":"","comment_id":330160,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5936788840","product_id":100085301,"comment_content":"请问老师标签联合的联合是什么意思","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546308,"discussion_content":"Tag Union - enum 是若干个 tag + 数据的联合体","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642293564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317975,"user_name":"码农阿甘","can_delete":false,"product_type":"c1","uid":2823671,"ip_address":"","ucode":"202FDAAA3BB393","user_header":"https://static001.geekbang.org/account/avatar/00/2b/15/f7/9a55e72b.jpg","comment_is_top":false,"comment_ctime":1635081892,"is_pvip":false,"replies":[{"id":"115222","content":"因为 enum 表述的就是不相交集","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635120757,"ip_address":"","comment_id":317975,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5930049188","product_id":100085301,"comment_content":"第2题为什么可以用enum？我只知道C#或者Java可以用接口","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529051,"discussion_content":"因为 enum 表述的就是不相交集","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635120757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316046,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1634115043,"is_pvip":false,"replies":[{"id":"115277","content":"嗯，不错。<br><br>1. * const 后需要带一个类型，() 是 unit，代表不关心它的类型。如果你要转换成函数指针，可以用：<br><br>```<br>fn main() {<br>    println!(&quot;addr: {:p}&quot;, hello as *const fn(&amp;str));<br>}<br><br>fn hello(name: &amp;str) {<br>    println!(&quot;hello {}&quot;, name);<br>}<br>```<br><br>2. 虚表是在编译时生成的。但虚表不是在 impl TraitA for typeB 时生成（之前在知乎的文章里对这个地方理解有些问题），它是在编译时遇到 trait object 时（比如遇见把某个 File 数据结构转换成 dyn Write 时）生成，它是编译期生成的。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635131994,"ip_address":"","comment_id":316046,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5929082339","product_id":100085301,"comment_content":"先回答课后题：<br>1. JS没有解引用<br>2&#47;3. 没有 markdown 真是不方便啊…… 也不能贴图…… 什么破平台（算了😂<br>class Shape {<br>  get area () {<br>    throw new Error(&#39;you should overwrite this&#39;)<br>  }<br>  get circumference () {<br>    throw new Error(&#39;you should overwrite this&#39;)<br>  }<br>}<br>class Rectangle extends Shape {<br>  a;<br>  b;<br>  constructor (a, b) { this.a = a; this.b = b; }<br>  get area () {}<br>  get circumference () {}<br>}<br>class Circle extends Shape {<br>  r;<br>  constructor (r) { this.r = r; }<br>  get area () {}<br>  get circumference () {}<br>}<br>class Triangle extends Shape {<br>  a; b; c;<br>  constructor (a, b, c) { this.a = a; this.b = b;  this.c = c; }<br>  get area () {}<br>  get circumference () {}<br>}<br><br>再提出我的两点疑问：<br>1. a_function as *const () 在这个类型转换中 &quot;()&quot; 是什么意思啊？会随 a_function 的签名变化还是总是 &quot;()&quot;<br>2. “虚表相当于在运行时生成的一个涵盖了一系列函数指针的数据结构。有时候对于不同类型但是满足相同接口的数据，我们希望可以抹去他们的原始类型，让它们有相同的接口类型，以便于统一处理，这样更加灵活，但此时需要为每个数据构造他们各自对接口实现的虚表，这样可以依旧调用到属于该类型的实现。” 老师某个回复里这样说。<br>“虚表是每个 impl TraitA for TypeB {} 时就会编译出一份。比如 String 的 Debug 实现, String 的 Display 实现各有一份虚表，它们在编译时就生成并放在了二进制文件中（大多是 RODATA 段中）。所以虚表是每个 (Trait, Type) 一份。并且在编译时就生成好了。“ 老师在另一个回复里这样说。<br>那么虚表到底是运行时生成的还是编译时生成的呢？难道说标准库和用户代码区别对待？<br>","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528247,"discussion_content":"嗯，不错。\n\n1. * const 后需要带一个类型，() 是 unit，代表不关心它的类型。如果你要转换成函数指针，可以用：\n\n```\nfn main() {\n    println!(&amp;quot;addr: {:p}&amp;quot;, hello as *const fn(&amp;amp;str));\n}\n\nfn hello(name: &amp;amp;str) {\n    println!(&amp;quot;hello {}&amp;quot;, name);\n}\n```\n\n2. 虚表是在编译时生成的。但虚表不是在 impl TraitA for typeB 时生成（之前在知乎的文章里对这个地方理解有些问题），它是在编译时遇到 trait object 时（比如遇见把某个 File 数据结构转换成 dyn Write 时）生成，它是编译期生成的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635131994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308787,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1629798052,"is_pvip":false,"replies":[{"id":"111785","content":"嗯，我们先把一些基本概念扫一下，可以更好地学习后续的内容。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629848970,"ip_address":"","comment_id":308787,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5924765348","product_id":100085301,"comment_content":"这是站在另外的角度看编程语言。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525623,"discussion_content":"嗯，我们先把一些基本概念扫一下，可以更好地学习后续的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629848970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308586,"user_name":"只吃无籽西瓜","can_delete":false,"product_type":"c1","uid":1244498,"ip_address":"","ucode":"F2F7954236CDAB","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/52/47fff845.jpg","comment_is_top":false,"comment_ctime":1629690988,"is_pvip":false,"replies":[{"id":"111705","content":"嗯如果想过之后还是有点不太明白，可以先在留言区看看各位同学的思路，也可以直接问下老师具体是哪里不太明白。<br><br>另外，每一讲的思考题，会挑重点普遍的问题，把参考思路都整理到后续加餐中的～","user_name":"编辑回复","user_name_real":"叶如芊","uid":"2547771","ctime":1629696378,"ip_address":"","comment_id":308586,"utype":2}],"discussion_count":3,"race_medal":0,"score":"5924658284","product_id":100085301,"comment_content":"这一章的课后问题不会，希望有人能够解答。","like_count":1,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525552,"discussion_content":"嗯如果想过之后还是有点不太明白，可以先在留言区看看各位同学的思路，也可以直接问下老师具体是哪里不太明白。\n\n另外，每一讲的思考题，会挑重点普遍的问题，把参考思路都整理到后续加餐中的～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629696378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2186863,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5e/6f/33df5665.jpg","nickname":"彭海波","note":"","ucode":"2FDE003F642BBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390317,"discussion_content":"微信群在哪里？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629774797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":2186863,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5e/6f/33df5665.jpg","nickname":"彭海波","note":"","ucode":"2FDE003F642BBD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390428,"discussion_content":"课程简介跟开篇词末尾。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629821924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":390317,"ip_address":""},"score":390428,"extra":""}]}]},{"had_liked":false,"id":308518,"user_name":"小样","can_delete":false,"product_type":"c1","uid":1075443,"ip_address":"","ucode":"0D05E1D31150F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/f3/22481a37.jpg","comment_is_top":false,"comment_ctime":1629675701,"is_pvip":true,"replies":[{"id":"111793","content":"C 是典型的弱类型。我们看代码，这里 char 被隐式转换为：<br><br>```C<br>#include &lt;stdio.h&gt;<br><br>int add_numbers(int a, int b) {<br>    int result = a + b;<br>    return result;<br>}<br><br>int main() {<br>    char c = &quot;42&quot;;<br>    int n = 42;<br><br>    &#47;&#47; 为什么说 C 是 weakly typed<br>    int result = add_numbers(c, n);<br>    printf(&quot;%d\\n&quot;, result);<br><br>    return 0;<br>}<br>```","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629850780,"ip_address":"","comment_id":308518,"utype":1}],"discussion_count":6,"race_medal":0,"score":"5924642997","product_id":100085301,"comment_content":"“如果你来自于弱类型语言，如 C &#47; Python &#47; JavaScript”，c是弱类型语言？","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525515,"discussion_content":"C 是典型的弱类型。我们看代码，这里 char 被隐式转换为：\n\n```C\n#include &amp;lt;stdio.h&amp;gt;\n\nint add_numbers(int a, int b) {\n    int result = a + b;\n    return result;\n}\n\nint main() {\n    char c = &amp;quot;42&amp;quot;;\n    int n = 42;\n\n    // 为什么说 C 是 weakly typed\n    int result = add_numbers(c, n);\n    printf(&amp;quot;%d\\n&amp;quot;, result);\n\n    return 0;\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629850780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1089000,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9d/e8/39433235.jpg","nickname":"Christian","note":"","ucode":"D84F866015BA07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390135,"discussion_content":"C 是弱类型静态类型。需要区别强/弱类型和动/静态类型。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629683682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2888176,"avatar":"","nickname":"无下限HENTAI","note":"","ucode":"8D45A12C25861A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544955,"discussion_content":"弱类型是这样，假如说你定义了一个char和一个int，在强类型中，没有显式转换的话它们是不能相加的，但弱类型（比如C）就可以，只是会给你一个警告小心数据溢出而已。C\\C++都是典型的弱类型静态语言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641790260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731977,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6d/89/14031273.jpg","nickname":"Direction","note":"","ucode":"298D5109EA28EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390242,"discussion_content":"强类型的基本定义即为，禁止错误类型的参数继续运算。C语言的类型转换即为缺乏强类型的证例；如果编写者用C语言对一个值转换类型，不仅令编译器允许这个代码，而且在运行时期中也同样允许。这使得C代码可更为紧密和快速，不过也使调试变的更为困难。\n\n\n弱类型意指一个语言可以隐式的转换类型（或直接转型）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629725491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030862,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","nickname":"bearlu","note":"","ucode":"14F260C8B24E27","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390116,"discussion_content":"不是把","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629679174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2708009,"avatar":"https://static001.geekbang.org/account/avatar/00/29/52/29/51b5ca75.jpg","nickname":"alexd","note":"","ucode":"7815D35C4CFA0A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390115,"discussion_content":"不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629678777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358606,"user_name":"BrandonH","can_delete":false,"product_type":"c1","uid":2839988,"ip_address":"北京","ucode":"51ABE1EC0A8255","user_header":"https://static001.geekbang.org/account/avatar/00/2b/55/b4/5fd0fc40.jpg","comment_is_top":false,"comment_ctime":1664462232,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1664462232","product_id":100085301,"comment_content":"讲到指针和引用的时候，为什么说指针可以解引用dereference到任何数据类型呢？指针能指向的类型在初始化指针的时候就已经定下来了吧","like_count":0},{"had_liked":false,"id":353180,"user_name":"Geek_fc611b","can_delete":false,"product_type":"c1","uid":1368638,"ip_address":"上海","ucode":"1BCC8D705EACFD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/1EmbCRZwGAPibaibOUDoI87OwxFoDOL2tYnZ9aumKesgXd5nxXl6k7vOqpwR6R0IEwy5tic9jtqkYnfgmUeq2MMrQ/132","comment_is_top":false,"comment_ctime":1659237985,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659237985","product_id":100085301,"comment_content":"hello，老师，我看书上以及其他教程上描述的元组是复合类型，为什么你这里说是原生类型，能解释一下吗？","like_count":0},{"had_liked":false,"id":348748,"user_name":"三思","can_delete":false,"product_type":"c1","uid":1517127,"ip_address":"","ucode":"53CF2ADB17D823","user_header":"https://static001.geekbang.org/account/avatar/00/17/26/47/cdef54cc.jpg","comment_is_top":false,"comment_ctime":1655367166,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655367166","product_id":100085301,"comment_content":"```typescript<br>interface Shape {<br>  area: () =&gt; number<br>}<br>class Rectangle implements Shape {<br>  a: number<br>  b: number<br>  area() {<br>    return this.a * this.b<br>  }<br>}<br>class Circle implements Shape {<br>  r: number<br>  area() {<br>    return Math.PI * this.r * this.r<br>  }<br>}<br>class Triangle implements Shape {<br>  a: number<br>  b: number<br>  area() {<br>    &#47;&#47; (底 * 高) &#47; 2<br>    return (this.a * this.b) &#47; 2<br>  }<br>}<br>```","like_count":0},{"had_liked":false,"id":347944,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":2853200,"ip_address":"","ucode":"BBDF8E9F348F65","user_header":"https://static001.geekbang.org/account/avatar/00/2b/89/50/aee9fdab.jpg","comment_is_top":false,"comment_ctime":1654595630,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654595630","product_id":100085301,"comment_content":"昨天看的这篇文章，之前没有搞懂的地方，今天网上搜索之后，过来做个总结。1、闭包：在其他地方可以调用函数内部参数，切其函数实例化之后，里面的数据依然会被保存。2、接口：定义名称、类型和返回（可选），具体的实现，每一个人可能不一样。3、虚表：一个指针，里面包含函数的各种属性（不知道对不对）4、泛型：比接口更高一级的抽象，数据的类型都是可以自己定义的，比如arrayList&lt;T&gt;.","like_count":0},{"had_liked":false,"id":347869,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":2853200,"ip_address":"","ucode":"BBDF8E9F348F65","user_header":"https://static001.geekbang.org/account/avatar/00/2b/89/50/aee9fdab.jpg","comment_is_top":false,"comment_ctime":1654523471,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654523471","product_id":100085301,"comment_content":"#include &lt;stdio.h&gt;<br><br>void hello(){<br>    printf(&quot;hello&quot;);<br>}<br><br>int main(){<br>    void *a = &amp;hello;<br>    int *b = (int*)(a);<br>    b[1] = 1;<br>    return 0;<br>}","like_count":0},{"had_liked":false,"id":347863,"user_name":"含章","can_delete":false,"product_type":"c1","uid":1434831,"ip_address":"","ucode":"A7CA116D5275C9","user_header":"https://static001.geekbang.org/account/avatar/00/15/e4/cf/906f47c9.jpg","comment_is_top":false,"comment_ctime":1654520544,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654520544","product_id":100085301,"comment_content":"只会点Python基础的，看这个专栏能学得会吗","like_count":0},{"had_liked":false,"id":345944,"user_name":"十四有四而志于学","can_delete":false,"product_type":"c1","uid":2682384,"ip_address":"","ucode":"D3952E7CBCECCA","user_header":"https://static001.geekbang.org/account/avatar/00/28/ee/10/e910853d.jpg","comment_is_top":false,"comment_ctime":1652708596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652708596","product_id":100085301,"comment_content":"&quot;在软件中，我们大部分的代码都是同步操作，比如 CPU，只有流水线中的前一条指令执行完成，才会执行下一条指令。&quot;<br><br>这里有点问题<br>这种指令执行的同步关系是一种CPU向上提供的假象。<br>现代CPU为了效率，会同时执行多条指令的不同阶段。更进一步，会使用分支判断，提前执行后续指令，等到当前指令出结果后，会对提前执行的指令整体做取舍。","like_count":0},{"had_liked":false,"id":345941,"user_name":"十四有四而志于学","can_delete":false,"product_type":"c1","uid":2682384,"ip_address":"","ucode":"D3952E7CBCECCA","user_header":"https://static001.geekbang.org/account/avatar/00/28/ee/10/e910853d.jpg","comment_is_top":false,"comment_ctime":1652706388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652706388","product_id":100085301,"comment_content":"相见恨晚","like_count":0},{"had_liked":false,"id":336560,"user_name":"窝窝头","can_delete":false,"product_type":"c1","uid":1063866,"ip_address":"","ucode":"5C2635ED6484F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/ba/3b30dcde.jpg","comment_is_top":false,"comment_ctime":1646213971,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646213971","product_id":100085301,"comment_content":"1.感觉会报错，强类型语言这块多少应该有些限制才对<br>2. 用枚举吧<br>3. 语法还不会，定义一个interface，然后注册一个area函数再对这个接口进行实现吧","like_count":0},{"had_liked":false,"id":331066,"user_name":"Geek_a76a82","can_delete":false,"product_type":"c1","uid":2067497,"ip_address":"","ucode":"FC5F5F6F7B05C9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLCxCicqmeiaOmHStZ4OsOYk9QAE176Uf1Wg20myCseTHCPluF5LS5Nzibu3icdN40qFPGkibcp2gD7xjwA/132","comment_is_top":false,"comment_ctime":1642407135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642407135","product_id":100085301,"comment_content":"js学习rust会不会难度很大","like_count":0},{"had_liked":false,"id":330164,"user_name":"鹅帮逮","can_delete":false,"product_type":"c1","uid":2755534,"ip_address":"","ucode":"A6DB1BEFDA5D9A","user_header":"https://static001.geekbang.org/account/avatar/00/2a/0b/ce/f0c520d1.jpg","comment_is_top":false,"comment_ctime":1641823275,"is_pvip":false,"replies":[{"id":"120700","content":"后面还会具体讲","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642293579,"ip_address":"","comment_id":330164,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641823275","product_id":100085301,"comment_content":"虚表好难理解","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546309,"discussion_content":"后面还会具体讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642293580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321449,"user_name":"杜文斌","can_delete":false,"product_type":"c1","uid":1995167,"ip_address":"","ucode":"FCE0FFFED46253","user_header":"https://static001.geekbang.org/account/avatar/00/1e/71/9f/9a0da80c.jpg","comment_is_top":false,"comment_ctime":1636881520,"is_pvip":false,"replies":[{"id":"118924","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639853196,"ip_address":"","comment_id":321449,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636881520","product_id":100085301,"comment_content":"1.  JS 中指针从函数解引用为一个数组，push 元素功能正常<br>2. TS 实现：type Shape = Rectangle | Circle | Triangle<br>3. TS 实现面积和周长计算<br>interface IGetPerimeterAndArea: (shape: Shape) =&gt; &lt;{ perimeter: number, area: number }&gt;","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539885,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639853196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318834,"user_name":"鲜于伯德","can_delete":false,"product_type":"c1","uid":1550951,"ip_address":"","ucode":"CF9E7E8E3F695D","user_header":"https://static001.geekbang.org/account/avatar/00/17/aa/67/1c474c6d.jpg","comment_is_top":false,"comment_ctime":1635462136,"is_pvip":false,"replies":[{"id":"116405","content":"解引用是取指针（引用）地址对应的内容的一个操作。它会根据指针的类型，来决定访问多大的内存，以及将这个内存中的数据当做什么类型来处理。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636557956,"ip_address":"","comment_id":318834,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635462136","product_id":100085301,"comment_content":"第一个问题，对于文章里面和评论中的答案来看，解引用能理解成给指针重新赋值吗？感觉没有丰富指针操作的人，有点难理解。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529393,"discussion_content":"解引用是取指针（引用）地址对应的内容的一个操作。它会根据指针的类型，来决定访问多大的内存，以及将这个内存中的数据当做什么类型来处理。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636557956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317254,"user_name":"Steve","can_delete":false,"product_type":"c1","uid":1002255,"ip_address":"","ucode":"243D10F2DC065A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/0f/d747ed96.jpg","comment_is_top":false,"comment_ctime":1634722591,"is_pvip":false,"replies":[{"id":"115242","content":"不是我的定义，而是我引用了维基百科的定义，而且它也声明了这个并没有一个特别清晰的界定，只有一些约定俗成的界定。其实没必要纠结下去，纠结下去，就是和了解茴字的四种写法一样，意义不大。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635122457,"ip_address":"","comment_id":317254,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634722591","product_id":100085301,"comment_content":"请问老师：看到留言里您对于强弱类型的定义是可否发生隐式转换，而 Java 语言在字节提升时（）可以发生隐式转换，而由大到小时是必须是强制转换的。那该如何定义Java是强类型，还是弱类型呢？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528735,"discussion_content":"不是我的定义，而是我引用了维基百科的定义，而且它也声明了这个并没有一个特别清晰的界定，只有一些约定俗成的界定。其实没必要纠结下去，纠结下去，就是和了解茴字的四种写法一样，意义不大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635122457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317198,"user_name":"彭亚伦","can_delete":false,"product_type":"c1","uid":2425378,"ip_address":"","ucode":"77A32C73A23F72","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/22/19585900.jpg","comment_is_top":false,"comment_ctime":1634706672,"is_pvip":true,"replies":[{"id":"115246","content":"没有遍历虚表的方式。Rust 不支持反射（reflection）。不过在编译期可以知道这一信息，因为显然 rust doc 生成时可以把一个类型实现的 trait 都列举出来。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635123276,"ip_address":"","comment_id":317198,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634706672","product_id":100085301,"comment_content":"请教一个问题: 关于接口和虚表, 当拿到一个特定类型, 是否能通过某种方法历遍虚表, 从而知道这个类型具体实现了哪些接口?<br><br>换句话说, 在rust中代码能否列举出某个type实现了哪些trait?  ","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528711,"discussion_content":"没有遍历虚表的方式。Rust 不支持反射（reflection）。不过在编译期可以知道这一信息，因为显然 rust doc 生成时可以把一个类型实现的 trait 都列举出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635123276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316006,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1634105315,"is_pvip":false,"replies":[{"id":"115279","content":"比如 <br><br>```<br>let s = &quot;hello&quot;.to_string();<br>let s1 = &amp;s;<br>```<br><br>这里 s1 就是一个胖指针，它包含地址和长度。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635132180,"ip_address":"","comment_id":316006,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1634105315","product_id":100085301,"comment_content":"“很多数据结构的引用，内部都是由胖指针实现的。”<br><br>这里不太清楚，是指Vec String这样的智能指针吗？<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528233,"discussion_content":"比如 \n\n```\nlet s = &amp;quot;hello&amp;quot;.to_string();\nlet s1 = &amp;amp;s;\n```\n\n这里 s1 就是一个胖指针，它包含地址和长度。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635132180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409171,"discussion_content":"这里作者回复好像错了...\n&amp;String应该是瘦指针，只包含地址\n&amp;str才是胖指针，包含地址和长度信息\nString也是一种胖智能指针，包含地址长度和容量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635387412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313792,"user_name":"猪小擎","can_delete":false,"product_type":"c1","uid":1370959,"ip_address":"","ucode":"D9552746AE3327","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","comment_is_top":false,"comment_ctime":1632667552,"is_pvip":true,"replies":[{"id":"113632","content":"你可以自己看 wikipedia：https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Strong_and_weak_typing<br><br>there is no precise technical definition of what the terms mean and different authors disagree about the implied meaning of the terms and the relative rankings of the &quot;strength&quot; of the type systems of mainstream programming languages.<br><br>A weakly typed language has looser typing rules and may produce unpredictable or even erroneous results or **may perform implicit type conversion at runtime**.<br><br>按照这个定义，C++ 是弱类型，它有类型的隐式转换。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632726126,"ip_address":"","comment_id":313792,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1632667552","product_id":100085301,"comment_content":"隐士类型转换不是是不是弱类型的标志，如果是隐士类型转换就是弱类型了，那cpp不也是弱类型了？<br>var a=1<br>a=“1”<br>这样的代码成立，就是弱类型，变量类型运行时可以变了。python，js，php是弱类型，c是强类型。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527474,"discussion_content":"你可以自己看 wikipedia：https://en.wikipedia.org/wiki/Strong_and_weak_typing\n\nthere is no precise technical definition of what the terms mean and different authors disagree about the implied meaning of the terms and the relative rankings of the &amp;quot;strength&amp;quot; of the type systems of mainstream programming languages.\n\nA weakly typed language has looser typing rules and may produce unpredictable or even erroneous results or **may perform implicit type conversion at runtime**.\n\n按照这个定义，C++ 是弱类型，它有类型的隐式转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632726126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313063,"user_name":"Geek_5244fa","can_delete":false,"product_type":"c1","uid":1072743,"ip_address":"","ucode":"B87A550526F74C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/67/133d2da6.jpg","comment_is_top":false,"comment_ctime":1632237871,"is_pvip":true,"replies":[{"id":"113459","content":"String 结构是个智能指针","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632356843,"ip_address":"","comment_id":313063,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632237871","product_id":100085301,"comment_content":"&gt; 如上一讲提到的指向 “hello world” 字符串的指针，还包含字符串长度和字符串的容量，一共使用了 3 个 word，在 64 位 CPU 下占用 24 个字节，这样比正常指针携带更多信息的指针，我们称之为胖指针（fat pointer）。<br><br>这里说这个指针用了 3 个 word，应该是指 String，String （结构体）也算是（胖）指针吗？我以为胖指针都是指引用。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527216,"discussion_content":"String 结构是个智能指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632356843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311634,"user_name":"Geek_e1d25e","can_delete":false,"product_type":"c1","uid":1637705,"ip_address":"","ucode":"6C30CDE3CB18C4","user_header":"","comment_is_top":false,"comment_ctime":1631354457,"is_pvip":false,"replies":[{"id":"113005","content":"非常正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631516555,"ip_address":"","comment_id":311634,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631354457","product_id":100085301,"comment_content":"1. 有一个指向某个函数的指针，如果将其解引用成一个列表，然后往列表中插入一个元素，请问会发生什么？（对比不同语言，看看这种操作是否允许，如果允许会发生什么）<br>这种操作有悖于内存安全，会破坏函数指针原本指向的调用栈，像c语言会对指针的操作比较宽松，应该允许这样操作，但是会产生不可预期的结果<br>2. 要构造一个数据结构 Shape，可以是 Rectangle、 Circle 或是 Triangle，这三种结构见如下代码。请问 Shape 类型该用什么数据结构实现？怎么实现？<br>这种我认为可以使用rust的枚举类型，Rectangle，Circle和Triangle都是Shape的枚举值<br>3. 对于上面的三种结构，如果我们要定义一个接口，可以计算周长和面积，怎么计算？<br>可以定义一个接口输入参数限定为Shape类型，输出周长和面积，然后Rectangle，Circle和Triangle各自实现这个接口，计算周长和面积","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526689,"discussion_content":"非常正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631516555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308752,"user_name":"Xi","can_delete":false,"product_type":"c1","uid":2315717,"ip_address":"","ucode":"0758A29D7581BF","user_header":"https://static001.geekbang.org/account/avatar/00/23/55/c5/7b0278df.jpg","comment_is_top":false,"comment_ctime":1629784123,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629784123","product_id":100085301,"comment_content":"一直用c,现在用go,想两者都要就用rust,泛型，闭包是弱项","like_count":0,"discussions":[{"author":{"id":2613603,"avatar":"https://static001.geekbang.org/account/avatar/00/27/e1/63/b127d174.jpg","nickname":"Ray","note":"","ucode":"2513037DB5F2AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390357,"discussion_content":"请教一下，第二问用Go来实现，该用什么结构来定义Shape？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629797036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308712,"user_name":"Thyyyy","can_delete":false,"product_type":"c1","uid":2066246,"ip_address":"","ucode":"EF90097F54784E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/87/46/125e5997.jpg","comment_is_top":false,"comment_ctime":1629768743,"is_pvip":false,"replies":[{"id":"111805","content":"1. 在访问列表，或者修改列表的时候会挂掉。<br>2&#47;3 对！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629853021,"ip_address":"","comment_id":308712,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629768743","product_id":100085301,"comment_content":"1 在C里面可以这样搞，但是会在函数使用的时候挂掉； 2 在很多面向对象的语言里可以定义成有虚函数的基类，像其他同学那样定成enum也是个方法； 3. interface或者虚函数继承都可以；","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525598,"discussion_content":"1. 在访问列表，或者修改列表的时候会挂掉。\n2/3 对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629853021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308683,"user_name":"Pure White","can_delete":false,"product_type":"c1","uid":1000780,"ip_address":"","ucode":"9E5D7BCB6E08EE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/45/4c/cdf337ac.jpg","comment_is_top":false,"comment_ctime":1629733379,"is_pvip":false,"replies":[{"id":"111772","content":"编辑代回答一下这条，用自己常用的语言来写作业就可以啦。<br><br>其实咱们这篇在梳理编程语言中要了解的一些基础知识，所以思考题重点只是为了巩固今天学到的基础概念，不需要用 Rust 来写噢～<br><br>等前置知识都铺垫好了，再到后面具体 Rust 的语法学习。","user_name":"编辑回复","user_name_real":"叶如芊","uid":"2547771","ctime":1629794279,"ip_address":"","comment_id":308683,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1629733379","product_id":100085301,"comment_content":"作为 Rust 第一课，感觉课后习题难了点，很多都需要起码会 Rust 才行。<br>对于一个 Rust 基本语法知识都不会的同学，课后习题不可能做得出来。","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525589,"discussion_content":"编辑代回答一下这条，用自己常用的语言来写作业就可以啦。\n\n其实咱们这篇在梳理编程语言中要了解的一些基础知识，所以思考题重点只是为了巩固今天学到的基础概念，不需要用 Rust 来写噢～\n\n等前置知识都铺垫好了，再到后面具体 Rust 的语法学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629794279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308664,"user_name":"官","can_delete":false,"product_type":"c1","uid":1696727,"ip_address":"","ucode":"E3FF6D04B9846B","user_header":"https://static001.geekbang.org/account/avatar/00/19/e3/d7/d7b3505f.jpg","comment_is_top":false,"comment_ctime":1629725346,"is_pvip":false,"replies":[{"id":"111804","content":"对！2 也可以用 enum 来定义，可以看我之前的回答。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629852962,"ip_address":"","comment_id":308664,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629725346","product_id":100085301,"comment_content":"1.引用的解引用访问是受限，只能解引用到它引用数据的类型，插入的元素无法确定是否能保证与源数据类型一致。<br>2.还没有接触到RUST的语法，感觉需要定义一个Shape的接口 、<br>3.在回答2的基础上，在Shape中加入计算周长和面积的接口并在相应的子类实现。<br><br>感觉只在大学接触过C++98的人来说好多东西需要补课。。。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525577,"discussion_content":"对！2 也可以用 enum 来定义，可以看我之前的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629852962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308577,"user_name":"王硕尧","can_delete":false,"product_type":"c1","uid":1743072,"ip_address":"","ucode":"8E5ED0B869C213","user_header":"https://static001.geekbang.org/account/avatar/00/1a/98/e0/8c814c13.jpg","comment_is_top":false,"comment_ctime":1629688292,"is_pvip":false,"replies":[{"id":"111703","content":"感谢捉虫，已经修改过来了👍","user_name":"编辑回复","user_name_real":"叶如芊","uid":"2547771","ctime":1629696084,"ip_address":"","comment_id":308577,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1629688292","product_id":100085301,"comment_content":"&quot;比如 Python 对象的 self 应用，或者 Java 对象的 this 引用&quot;  是 self 引用吧？","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525546,"discussion_content":"感谢捉虫，已经修改过来了👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629696084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308569,"user_name":"小样","can_delete":false,"product_type":"c1","uid":1075443,"ip_address":"","ucode":"0D05E1D31150F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/f3/22481a37.jpg","comment_is_top":false,"comment_ctime":1629687515,"is_pvip":true,"replies":[{"id":"111800","content":"对，把指针指向的地址强制解引用成一个列表。在 C 里这是可行的，但访问时可能会造成 segment fault","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629852494,"ip_address":"","comment_id":308569,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629687515","product_id":100085301,"comment_content":"不理解第一题的意思，“有一个指向某个函数的指针，如果将其解引用成一个列表”，函数指针解引用然后赋值给一个vector或者数组？这怎么编译的过去，还是说指针强制类型转换成列表指针，再解引用？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525544,"discussion_content":"对，把指针指向的地址强制解引用成一个列表。在 C 里这是可行的，但访问时可能会造成 segment fault","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629852494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308557,"user_name":"Kerry","can_delete":false,"product_type":"c1","uid":2061524,"ip_address":"","ucode":"92F809EC998FC6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/74/d4/38d813f0.jpg","comment_is_top":false,"comment_ctime":1629685355,"is_pvip":false,"replies":[{"id":"111798","content":"1&#47;3 正确！2. 也可以用 enum 定义 Shape","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629851790,"ip_address":"","comment_id":308557,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1629685355","product_id":100085301,"comment_content":"课后思考题：<br><br>1. 没记错的话，程序的代码保存在只读的.text段，问题1里的操作很可能会造成coredump。为什么是“很可能”呢？因为对于这种与实现相关的东西，C++标准一般是不会做出明确的规定，而是统一称为未定义行为。<br>2. 用接口定义Shape。<br>3. Shape里定义周长和面积方法，三个具体类型继承Shape并实现这两个方法。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525537,"discussion_content":"1/3 正确！2. 也可以用 enum 定义 Shape","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629851790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2061524,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/74/d4/38d813f0.jpg","nickname":"Kerry","note":"","ucode":"92F809EC998FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390457,"discussion_content":"对哦，rust里的enum好像跟类C语言的enum不同😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629853522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308553,"user_name":"Kerry","can_delete":false,"product_type":"c1","uid":2061524,"ip_address":"","ucode":"92F809EC998FC6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/74/d4/38d813f0.jpg","comment_is_top":false,"comment_ctime":1629684934,"is_pvip":false,"replies":[{"id":"111796","content":"对，是 C++ 的版本。你看的很仔细啊，我图里的 f&#47;l 确实应该换成 first&#47;last。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629851706,"ip_address":"","comment_id":308553,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629684934","product_id":100085301,"comment_content":"二分查找配图右边的例子是C++写的吧？变量名好像有错，不应该是first和last吗？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525534,"discussion_content":"对，是 C++ 的版本。你看的很仔细啊，我图里的 f/l 确实应该换成 first/last。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629851706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308538,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1629680092,"is_pvip":false,"replies":[{"id":"111794","content":"数组在大部分编程语言中都算原生类型（primitive type）","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1629851319,"ip_address":"","comment_id":308538,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1629680092","product_id":100085301,"comment_content":"请假老师，<br>数组算不算类型， 如果算的话 应该是哪种类型","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525525,"discussion_content":"数组在大部分编程语言中都算原生类型（primitive type）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629851319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1348586,"avatar":"https://static001.geekbang.org/account/avatar/00/14/93/ea/5aae2f50.jpg","nickname":"frendguo","note":"","ucode":"704EFF58E4447A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390333,"discussion_content":"组合类型吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629786402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}