{"id":734199,"title":"03｜动态Response：按照规范构造返回流","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上节课我们初步构造了一个最原始的可运行的 HTTP Server，做到了将文件内容输出到浏览器。但我们也发现，这个原始版本的HTTP Server局限性很大，只能使用静态资源，不能组装Response返回结果，竟然还要求静态资源本身的文本格式符合HTTP协议中Response的规范，而且也不满足不同异常场景下的Response返回。这个服务需要业务程序员自行准备完整的满足HTTP Response规范格式的静态资源，非常不友好。</p><p>其次，一个正常的 HTTP 服务响应请求不应只有静态资源，也应存在动态资源。这就是这节课我们要引入的一个重要概念——<strong>Servlet，它是实现动态资源返回的好工具</strong>。总体结构图如下，现在就让我们一起来动手实现。</p><p><img src=\"https://static001.geekbang.org/resource/image/yy/39/yy5870c90fbb711ae8667cabf5c5c839.png?wh=1920x852\" alt=\"图片\"></p><h2>项目结构</h2><p>这节课我们计划采用Maven结构对项目的包依赖进行管理，省去了手工导入jar包的环节。但有一点我们始终坚持，就是<strong>引入最少的依赖包，一切功能尽可能用最原生的JDK来实现</strong>。</p><p>这节课项目结构变化如下：</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ server\n│  │  │  │  ├─ HttpServer.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ Servlet.java\n│  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  ├─ StatisResourceProcessor.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><!-- [[[read_end]]] --><p>我们按照Maven项目规范，把server目录整体移动到 <code>src/main/java</code> 目录下，新增test模块和pom模块。其他类的具体功能我们会放在后面慢慢介绍。</p><p>你可以先看一下这节课pom.xml配置内容，现在只引用了Apache commons-lang3这个依赖包。</p><pre><code class=\"language-xml\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;day2&lt;/groupId&gt;\n    &lt;artifactId&gt;day2&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n            &lt;version&gt;3.4&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre><h2>Response请求规范</h2><p>我们先动手改造上一节课的Response，不能再要求在静态资源文本中写死格式了，而是服务器自己进行封装。既然要封装Response请求，自然我们得了解一点HTTP这个协议对返回内容的规定。根据规定，Response由四部分组成：状态行、Header头、空行与响应体。而状态行又由HTTP协议及其版本、状态码、状态名称组成。我们看一下上一节课的静态资源hello.txt。</p><pre><code class=\"language-plain\">HTTP/1.1 200 OK\nContent-Type: text/html\nContent-Length: 12\n\nHello World!\n</code></pre><p>由上述内容可看出，第一行是状态行，表示使用HTTP协议、版本（1.1）、返回状态码（200）以及返回状态名称（OK），中间由一个空格分隔。Content-Type: text/html和Content-Length: 12则是以键值对的形式展示的返回头（Header），依行排列，这里面包含对服务器和返回数据的描述。常用键的取值还有Cookie、Authorization等。</p><p>之后空一行，随后写入返回的内容（Hello World!），这些是服务器返回给客户端的具体数据，包括但不限于文本、文件、图片等。我们把它叫做响应体。</p><p>由这些内容可以看出，<strong>只有响应体是需要业务程序员关心的</strong>，说明除响应体之外的内容，我们都可以把它封装到Response里。</p><h2>Response封装</h2><p>在MiniTomcat项目中，我们规定响应格式如下，接下来我们会根据这个格式对Response进行封装。</p><pre><code class=\"language-plain\">HTTP/1.1 ${StatusCode} ${StatusName}\nContent-Type: ${ContentType}\nContent-Length: ${ContentLength}\nServer: minit\nDate: ${ZonedDateTime}\n</code></pre><p>上述 <code>${StatusCode}</code>、<code>${StatusName}</code> 等占位符，我们会利用到apache commons-lang包里的StringUtils工具进行占位符填充，这里我们不再自己造轮子进行替换工作，commons-lang包默认已由pom.xml引入。</p><p>在这一节课的内容中，<strong>我们引入 StaticResourceProcessor.java，专用于处理 Response 的返回值</strong>，原有的Response.java只作为返回实体类存在。</p><p>参考代码：</p><pre><code class=\"language-java\">public class Response {\n    Request request;\n    OutputStream output;\n    public Response(OutputStream output) {\n        this.output = output;\n    }\n    public void setRequest(Request request) {\n        this.request = request;\n    }\n    public OutputStream getOutput() {\n        return this.output;\n    }\n}\n</code></pre><p>既然如此，寻找静态资源文件的任务，自然就得由<strong> StaticResourceProcessor.java </strong>承担。</p><pre><code class=\"language-java\">public class StaticResourceProcessor {\n    private static final int BUFFER_SIZE = 1024;\n    //下面的字符串是当文件没有找到时返回的404错误描述\n    private static String fileNotFoundMessage = \"HTTP/1.1 404 File Not Found\\r\\n\" +\n            \"Content-Type: text/html\\r\\n\" +\n            \"Content-Length: 23\\r\\n\" +\n            \"\\r\\n\" +\n            \"&lt;h1&gt;File Not Found&lt;/h1&gt;\";\n    //下面的字符串是正常情况下返回的，根据http协议，里面包含了相应的变量。\n    private static String OKMessage = \"HTTP/1.1 ${StatusCode} ${StatusName}\\r\\n\"+\n            \"Content-Type: ${ContentType}\\r\\n\"+\n            \"Content-Length: ${ContentLength}\\r\\n\"+\n            \"Server: minit\\r\\n\"+\n            \"Date: ${ZonedDateTime}\\r\\n\"+\n            \"\\r\\n\";\n    //处理过程很简单，先将响应头写入输出流，然后从文件中读取内容写入输出流\n    public void process(Request request, Response response) throws IOException {\n        byte[] bytes = new byte[BUFFER_SIZE];\n        FileInputStream fis = null;\n        OutputStream output = null;\n        try {\n            output = response.getOutput();\n            File file = new File(HttpServer.WEB_ROOT, request.getUri());\n            if (file.exists()) {\n                //拼响应头\n                String head = composeResponseHead(file);\n                output.write(head.getBytes(\"utf-8\"));\n                //读取文件内容，写入输出流\n                fis = new FileInputStream(file);\n                int ch = fis.read(bytes, 0, BUFFER_SIZE);\n                while (ch != -1) {\n                    output.write(bytes, 0, ch);\n                    ch = fis.read(bytes, 0, BUFFER_SIZE);\n                }\n                output.flush();\n            }\n            else {\n                output.write(fileNotFoundMessage.getBytes());\n            }\n        } catch (IOException e) {\n            System.out.println(e.toString());\n        } finally {\n            if (fis != null) {\n                fis.close();\n            }\n        }\n    }\n    //拼响应头，填充变量值\n    private String composeResponseHead(File file) {\n        long fileLength = file.length();\n        Map&lt;String, Object&gt; valuesMap = new HashMap&lt;&gt;();\n        valuesMap.put(\"StatusCode\", \"200\");\n        valuesMap.put(\"StatusName\", \"OK\");\n        valuesMap.put(\"ContentType\", \"text/html;charset=utf-8\");\n        valuesMap.put(\"ContentLength\", fileLength);\n        valuesMap.put(\"ZonedDateTime\", DateTimeFormatter.ISO_ZONED_DATE_TIME.format(ZonedDateTime.now()));\n        StrSubstitutor sub = new StrSubstitutor(valuesMap);\n        String responseHead = sub.replace(OKMessage);\n        return responseHead;\n    }\n}\n</code></pre><p>从上面的代码可以看出，核心代码就是 <code>process()</code> 这个方法，它做了两件事情，一是拼响应头，二是从文本文件中读取字节流，这两部分内容都输出到Response的output stream中。这里额外判断了一下文件存不存在，如果不存在就返回404。</p><p>相比上一节课的Response返回类，它最大的变化在于引入了composeResponseHead方法对返回的状态行以及返回头Header进行动态组装。StrSubstitutor是commons-lang包中提供的一个字符串处理工具，传入MAP类型的数据结构后，会根据MAP里的Key值对比，用Value值把占位符替换掉。</p><p>改造之后，在hello.txt文件中，我们只需要写上返回体的内容，不需要自己手写响应头，就可以在浏览器内渲染出相关内容。</p><h2>引入动态资源</h2><p>上面我们就针对静态资源进行了改造，接下来我们开始考虑<strong>如何处理动态资源</strong>。在Java中，提到Web服务器绕不开一个概念——Servlet。Servlet是一个接口，一般我们认为实现了这个接口的类，都可以统称为Servlet。它的主要的功能在于交互式地浏览以及修改数据，随后动态地生成网页端展示的内容。</p><p>接下来我们开始逐步实现Servlet的调用。这节课我们简单地以 <code>/servlet/</code> 这个路径来区分是否要调用Servlet获取动态资源。如果包含这个路径，就调用对应Servlet；反之，就判断为是调用静态资源。今后我们再慢慢地改进路径匹配的方式。</p><p>通过这种方式，我们只需要在获取Request请求后调用 <code>getUri()</code>，就可以判断使用哪一种方式进行处理。</p><p>定义Servlet接口，按照Servlet的规范应该实现javax.servlet.Servlet。但这里我们希望能简单一点，自己定义一个接口，作为起步来探讨。</p><pre><code class=\"language-java\">package server;\n\npublic interface Servlet {\n    public void service(Request req, Response res) throws IOException;\n}\n</code></pre><p>这个接口中只有一个service方法，可以留给业务程序员自行实现。每次调用Servlet的时候，其实都是在调用这个方法，根据这里方法内的实现动态生成Web上的内容。</p><p>接下来我们看看ServletProcessor.java的定义。</p><pre><code class=\"language-java\">public class ServletProcessor {\n    //响应头定义，里面包含变量\n    private static String OKMessage = \"HTTP/1.1 ${StatusCode} ${StatusName}\\r\\n\"+\n            \"Content-Type: ${ContentType}\\r\\n\"+\n            \"Server: minit\\r\\n\"+\n            \"Date: ${ZonedDateTime}\\r\\n\"+\n            \"\\r\\n\";\n\n    public void process(Request request, Response response) {\n        //首先根据uri最后一个/号来定位，后面的字符串认为是servlet名字\n        String uri = request.getUri();\n        String servletName = uri.substring(uri.lastIndexOf(\"/\") + 1);\n        URLClassLoader loader = null;\n        OutputStream output = null;\n\n        try {\n            // create a URLClassLoader\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(HttpServer.WEB_ROOT);\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            urls[0] = new URL(null, repository, streamHandler);\n            loader = new URLClassLoader(urls);\n        }\n        catch (IOException e) {\n            System.out.println(e.toString() );\n        }\n        //由上面的URLClassLoader加载这个servlet\n        Class&lt;?&gt; servletClass = null;\n        try {\n            servletClass = loader.loadClass(servletName);\n        }\n        catch (ClassNotFoundException e) {\n            System.out.println(e.toString());\n        }\n        //写响应头\n        output = response.getOutput();\n        String head = composeResponseHead();\n        try {\n            output.write(head.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e1) {\n            e1.printStackTrace();\n        } catch (IOException e1) {\n            e1.printStackTrace();\n        }\n        //创建servlet新实例，然后调用service()，由它来写动态内容到响应体\n        Servlet servlet = null;\n        try {\n            servlet = (Servlet) servletClass.newInstance();\n            servlet.service(request, response);\n        }\n        catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        catch (Throwable e) {\n            System.out.println(e.toString());\n        }\n\n        try {\n            output.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n    //生成响应头，填充变量值\n    private String composeResponseHead() {\n        Map&lt;String,Object&gt; valuesMap = new HashMap&lt;&gt;();\n        valuesMap.put(\"StatusCode\",\"200\");\n        valuesMap.put(\"StatusName\",\"OK\");\n        valuesMap.put(\"ContentType\",\"text/html;charset=uft-8\");\n        valuesMap.put(\"ZonedDateTime\", DateTimeFormatter.ISO_ZONED_DATE_TIME.format(ZonedDateTime.now()));\n        StrSubstitutor sub = new StrSubstitutor(valuesMap);\n        String responseHead = sub.replace(OKMessage);\n        return responseHead;\n    }\n}\n</code></pre><p>composeResponseHead方法不多介绍了，与StaticResourceProcessor中一致。这里我们重点关注一下process方法，它的核心在于通过URI中的<code>\"/\"</code>定位到对应的Servlet名称，通过反射获取到对应的Servlet实现类并加载，调用service方法获取动态资源返回体，结合组装的返回头一并返回给客户端。</p><p>看代码的细节，需要先创建一个ClassLoader，就是这一句：</p><pre><code class=\"language-java\">loader = new URLClassLoader(urls);\n</code></pre><p>这是因为Servlet是由应用程序员编写的，我们写服务器的时候不知道路径，所以我们就规定一个目录，让程序员将Servlet放到这个目录下。为了将这些应用程序类和服务器自身的类分开，我们引入一个URLClassLoader来进行加载。后面涉及到多应用的时候，会再详细介绍Java的类加载机制。</p><p>之后，创建调用Servlet对象，然后调用它的 <code>service()</code> 方法，调用的时候，将Request和Response作为参数传进去。应用程序员写Servlet的时候，就可以用这个Request获取参数，然后将结果写入到Response中。</p><p>最后，服务器会自动加上 <code>flush()</code>，保证输出。</p><p>这个过程与实际的Servlet服务器规范大体一致，主要的区别在于单例模式。按照Servlet规范，一个Servlet应当是单对象多线程的。而我们现在每次都是创建一个新的Servlet对象，后面需要进一步修正。</p><h2>调整服务器程序</h2><p>好了，现在我们已经准备好了动态资源与静态资源的处理类，接下来就需要调整服务端的处理代码了，主要需要调整HTTP Server类里的await方法，你可以看一下调整过后的HTTP Server类。</p><pre><code class=\"language-java\">public class HttpServer {\n    public static final String WEB_ROOT = System.getProperty(\"user.dir\") + File.separator + \"webroot\";\n    public static void main(String[] args) {\n        HttpServer server = new HttpServer();\n        server.await();\n    }\n    public void await() {\n        ServerSocket serverSocket = null;\n        int port = 8080;\n        try {\n            serverSocket = new ServerSocket(port, 1, InetAddress.getByName(\"127.0.0.1\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n        while (true) {\n            Socket socket = null;\n            InputStream input = null;\n            OutputStream output = null;\n            try {\n                socket = serverSocket.accept();\n                input = socket.getInputStream();\n                output = socket.getOutputStream();\n                // create Request object and parse\n                Request request = new Request(input);\n                request.parse();\n                // create Response object\n                Response response = new Response(output);\n                response.setRequest(request);\n                if (request.getUri().startsWith(\"/servlet/\")) {\n                    ServletProcessor processor = new ServletProcessor();\n                    processor.process(request, response);\n                }\n                else {\n                    StaticResourceProcessor processor = new StaticResourceProcessor();\n                    processor.process(request, response);\n                }\n                // close the socket\n                socket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre><p>和上一节课相比，唯一的变化在于新增了对是否为Servlet的判断。</p><pre><code class=\"language-java\">if (request.getUri().startsWith(\"/servlet/\")) {\n    ServletProcessor processor = new ServletProcessor();\n    processor.process(request, response);\n}\nelse {\n    StaticResourceProcessor processor = new StaticResourceProcessor();\n    processor.process(request, response);\n}\n</code></pre><p>如果是Servlet，就启用ServletProcessor，如果不是Servlet，就认为是一个静态资源。</p><p>现在改造工作就完成了，接下来我们模拟客户端，编写一段测试代码对我们的功能进行测试。</p><h2>测试</h2><p>在 <code>src/test/java/test</code> 目录下，定义HelloServlet.java，实现我们自己定义的Servlet接口。</p><pre><code class=\"language-java\">package test;\nimport server.Request;\nimport server.Response;\nimport server.Servlet;\nimport java.io.IOException;\npublic class HelloServlet implements Servlet {\n    @Override\n    public void service(Request req, Response res) throws IOException {\n        String doc = \"&lt;!DOCTYPE html&gt; \\n\" +\n                \"&lt;html&gt;\\n\" +\n                \"&lt;head&gt;&lt;meta charset=\\\"utf-8\\\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;\\n\"+\n                \"&lt;body bgcolor=\\\"#f0f0f0\\\"&gt;\\n\" +\n                \"&lt;h1 align=\\\"center\\\"&gt;\" + \"Hello World 你好\" + \"&lt;/h1&gt;\\n\";\n        res.getOutput().write(doc.getBytes(\"utf-8\"));\n    }\n}\n</code></pre><p>可以看到，返回的内容都是纯HTML语法，只编写了返回体，不再关心返回头的内容。在编写完毕后，我们需要单独编译这个类，生成HelloServlet.class，把编译后的文件放到 <code>/webroot/test</code> 目录下，原因在于我们的服务器需要从webroot目录下获取资源文件。</p><p>在准备工作进行完毕之后，我们运行HttpServer服务器，键入 <code>http://localhost:8080/hello.txt</code> 后，可以发现hello.txt里所有的文本内容，都作为返回体展示在浏览器页面上了。我们再输入 <code>http://localhost:8080/servlet/test.HelloServlet</code> 就可以看到浏览器显示：Hello World 你好，这也是我们在HelloServlet中定义的返回资源内容。</p><p>这表明整体功能改造成功。</p><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/d3/e3/d3a4341ef3a5b7f0153c9a179c7f74e3.jpg?wh=3547x2572\" alt=\"\"></p><p>这节课我们基于前面最小可用的HttpServer服务器进行了改造，主要包括对HTTP协议返回内容中的状态行和返回头进行封装，还有引入动态资源和Servlet的概念，对Web端返回内容进行了扩充。但是我们要注意的一点在于<strong>目前我们并没有遵守 Servlet 的规范，只是简单引入了这一概念而已，对此我们还有许多改进优化的空间。</strong></p><p>本节课代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter03\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter03</a></p><h2><strong>思考题</strong></h2><p>学完了这节课的内容，我们来思考一个问题：我们现在是简单地通过URI中包含 <code>/servlet/</code> 来判别是否是一个动态Servlet，有什么更好的办法呢？</p><p>欢迎你把你的方法分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":385536,"user_name":"so long","can_delete":false,"product_type":"c1","uid":1449679,"ip_address":"浙江","ucode":"2A6B47BB32FC18","user_header":"https://static001.geekbang.org/account/avatar/00/16/1e/cf/97cd8be1.jpg","comment_is_top":false,"comment_ctime":1702892599,"is_pvip":false,"replies":[{"id":140510,"content":"好问题啊。这个情况记住三点，一，要设置content-length 二，或者指定transfer-encoding为chunked，三，都不指定，可用短连接，即服务器关闭连接。 不符合三点的情况，大概率出问题。MiniTomcat是简化教学版本，是短连接，只是探讨了一下chunked方式。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702970812,"ip_address":"北京","comment_id":385536,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"老师请教一个问题，ServletProcessor没有设置响应头Content-Length，浏览器不会有拆包或者粘包的问题吗？","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634075,"discussion_content":"好问题啊。这个情况记住三点，一，要设置content-length 二，或者指定transfer-encoding为chunked，三，都不指定，可用短连接，即服务器关闭连接。 不符合三点的情况，大概率出问题。MiniTomcat是简化教学版本，是短连接，只是探讨了一下chunked方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702970812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385347,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1702467035,"is_pvip":false,"replies":[{"id":140437,"content":"web.xml是经典方法","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702521482,"ip_address":"北京","comment_id":385347,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"🤪匹配 web.xml 或注解定义的 servlet 名称， 找到就可以当做动态 servlet。 不知道对不对， 想法比较单调， 希望老师和朋友给出点评和意见","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633708,"discussion_content":"web.xml是经典方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702521482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387052,"user_name":"Xiaosong","can_delete":false,"product_type":"c1","uid":1883431,"ip_address":"美国","ucode":"28A03027343F9D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/bd/27/e653a220.jpg","comment_is_top":false,"comment_ctime":1706326698,"is_pvip":false,"replies":[{"id":141107,"content":"你用IDEA，把Gitee上的项目拉下来，然后编译。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1706574422,"ip_address":"澳大利亚","comment_id":387052,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"欸 从来没 单独编译过单独的 java文件，我看target里面不编译test dir底下的文件，请教一下怎么操作","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636608,"discussion_content":"你用IDEA，把Gitee上的项目拉下来，然后编译。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706574422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385450,"user_name":"Geek_50a5cc","can_delete":false,"product_type":"c1","uid":1786951,"ip_address":"北京","ucode":"0F6C1C2552261F","user_header":"","comment_is_top":false,"comment_ctime":1702630993,"is_pvip":false,"replies":[{"id":140467,"content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702688067,"ip_address":"北京","comment_id":385450,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"所以 Servlet 动态资源的 classloader 都是去 编译后的classes定位需要的Servlet，对吗","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633862,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702688067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385414,"user_name":"彩笔采购","can_delete":false,"product_type":"c1","uid":3508556,"ip_address":"河南","ucode":"1619359E489AF7","user_header":"https://static001.geekbang.org/account/avatar/00/35/89/4c/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1702608643,"is_pvip":false,"replies":[{"id":140466,"content":"恭喜啊！希望分享一下。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702687986,"ip_address":"北京","comment_id":385414,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"啊我悟了","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633861,"discussion_content":"恭喜啊！希望分享一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702687987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385395,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1702558115,"is_pvip":false,"replies":[{"id":140479,"content":"Q1，代码再IDEA上都是可编译运行的，你是再Gitee上拿的完整代码吗？文本中的代码只是主体部分，因为篇幅原因，不完整。\nQ2，学到这节课，Response只有这么一点点。Mini系列课程的风格都是从无到有一点点长大，后面的章节回逐步完善它。\nQ3，request和response都可以处理文件，Multipart&#47;form-data，你可以看看http协议的规定。MiniTomcat没有实现。我们的主要目标是servlet容器。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702776906,"ip_address":"北京","comment_id":385395,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：老师开发用的IDE是Idea吗？\n我用Idea2019，打开老师的第三课代码，打开HttpServer.java,运行main函数，提示编译错误：“Error:java: 错误: 不支持发行版本 5”。\n我的电脑上java版本是java8。老师的代码只有三部分：src目录、webroot目录、pom.xml，都没有包含Java版本信息啊。\nNote1:其中一部分代码是： if (index2 &gt; index1) return requestString.substring(index1 + 1, index2);  对于这个代码，idea2019的提示是：&#39;if&#39;没有加大括号。）\nNote2:\nimport java.time.ZonedDateTime;\n对于此导包，有红色下划线，Idea2019提示“Usage of API documented as @since 1.8+ ”。这个有影响吗？\n\nQ2：Response类只有这些内容吗？\n本课中，Response只当做实体类处理，实体类的话，应该包含响应的多个字段，比如状态行、响应头等字段，但本文只有Request和OutputStream，是没有全部列出来吗？\n\nQ3：对于图片，Response是怎么处理的？\n把图片也当做文件，读取文件，读出的结果应该是二进制数据，然后把二进制数据放到response的响应体中，是这样吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633912,"discussion_content":"Q1，代码再IDEA上都是可编译运行的，你是再Gitee上拿的完整代码吗？文本中的代码只是主体部分，因为篇幅原因，不完整。\nQ2，学到这节课，Response只有这么一点点。Mini系列课程的风格都是从无到有一点点长大，后面的章节回逐步完善它。\nQ3，request和response都可以处理文件，Multipart/form-data，你可以看看http协议的规定。MiniTomcat没有实现。我们的主要目标是servlet容器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702776906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","nickname":"HH🐷🐠","note":"","ucode":"C50172BDA604D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633789,"discussion_content":"兄弟， Q1应该是你本地工具环境问题；  Q2 Response 传递给 ResourceProcessor 进行处理， 你看看 StaticResourceProcessor 这个类他就是有处理响应头的代码， 你可以看一下； Q3 就跟你说的一样， 读取图片然后输出，StaticResourceProcessor 就是一个例子。  ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1702622139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393980,"user_name":"wild wings.Luv","can_delete":false,"product_type":"c1","uid":3790749,"ip_address":"上海","ucode":"D76D40B24B4998","user_header":"https://static001.geekbang.org/account/avatar/00/39/d7/9d/73390cc0.jpg","comment_is_top":false,"comment_ctime":1725494287,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请问老师，在02处理静态资源的时候，contenttype设置为12，hello.txt是整个http报文的内容，此时会解析前面的内容作为响应头。但是在03处理静态资源，是拼接响应头，所以hello.txt整个文件都被当成了响应体。此时hello.txt就不需要是整个报文了。","like_count":0},{"had_liked":false,"id":385616,"user_name":"Martito","can_delete":false,"product_type":"c1","uid":3171426,"ip_address":"山东","ucode":"6C29938DB2A92B","user_header":"https://static001.geekbang.org/account/avatar/00/30/64/62/8b20c551.jpg","comment_is_top":false,"comment_ctime":1702979189,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"为什么我编译这个HelloServlet.java报错呢 idea中也没有提示错误呀","like_count":0,"discussions":[{"author":{"id":1004852,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIOalZv4nwJSuZbjicJAia6zYzRXRs969HRD8H3fmGIUbhhmDkVHUwWjVqs6LlzprWrplXKUpBbW1gA/132","nickname":"临海听风","note":"","ucode":"F6A18E3668DCC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634252,"discussion_content":"同编译报错，请问解决了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703129953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}