{"id":635593,"title":"18｜其他重要标准库特性：还有哪些库变更值得关注？","content":"<p>你好，我是卢誉声。</p><p>在第二章的开头，我们曾提到过，通常意义上所讲的C++，其实是由核心语言特性和标准库（C++ Standard Library）共同构成的。</p><p>在学习了Ranges库和Formatting库之后，还有一些比较重要的标准库变更值得我们关注，包括jthread、source location、Sync stream和u8string。今天，我会带你了解它们的用法和注意事项。</p><p>好，话不多说，就让我们从jthread开始今天的学习之旅吧（课程配套代码可以从<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>获取）。</p><h2>jthread</h2><p>长久以来，在C++中实现多线程都需要借助于操作系统API或者第三方库。好在这一情况在C++11中得以扭转，C++11为标准库带来了并发库，即标准的thread类。</p><p>但是，我们在工程中使用C++11的thread类，仍然存在一些问题。</p><p>首先是线程运行时默认行为不够灵活。thread的内部线程是进程的子线程，当thread还关联着一个活动线程时，C++运行时会调用terminate()中断整个程序的执行，这种行为对于很多没有认真管理线程资源的程序，不但非常危险，而且难以追踪。</p><p>另外，thread类还缺乏强制取消或通知取消线程的功能，在很多使用线程的场景中，这都是经常需要使用到的功能。还记得么？在第七讲至第十讲中讨论C++ coroutines的时候，我们就不得不自己实现了请求取消线程特性。</p><!-- [[[read_end]]] --><p>那时候我们的实现非常粗糙。比如说，没有考虑确保请求线程的线程安全，也无法告知请求方是否成功发送请求。如果要实现这些特性需要考虑很多边界条件，还真不容易。</p><p>由于这些问题的存在，我们在实际开发过程中使用C++11标准thread类时，就需要非常小心谨慎，说白了就是不但难用，而且容易出错。为此，C++20终于增加了jthread类来解决这些问题。</p><p>我们先结合后面这段示例代码，对jthread建立初步的认识。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n#include &lt;string&gt;\n&nbsp;\nvoid simpleSleep() {\n&nbsp;&nbsp;&nbsp; using namespace std::literals::chrono_literals;\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[SIMPLE] Before simple sleep\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(2000ms);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[SIMPLE] After simple sleep\" &lt;&lt; std::endl;\n}\n&nbsp;\n// jthread的工作函数可以通过第一个类型为stop_token的参数获取线程中断请求\nvoid stopTokenSleep(std::stop_token stoken, std::string workerName) {\n&nbsp;&nbsp;&nbsp; using namespace std::literals::chrono_literals;\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Worker name: \" &lt;&lt; workerName &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; while (true) {\n&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;std::cout &lt;&lt; \"[STOP_TOKEN] Before sleep\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(100ms);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[STOP_TOKEN] After sleep\" &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 调用stop_requested可以得知是否有其他线程请求中断本线程\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (stoken.stop_requested()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[STOP_TOKEN] Received stop request\" &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n}\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; // ms等自定义文字量定义在std::literals::chrono_literals名称空间中\n&nbsp;&nbsp;&nbsp; using namespace std::literals::chrono_literals;\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[MAIN] Before create simple thread\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; // 创建线程\n&nbsp;&nbsp;&nbsp; std::jthread simpleWorker(simpleSleep);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[MAIN] After create simple thread\" &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[MAIN] Before create stop token thread\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; // 创建线程\n&nbsp;&nbsp;&nbsp; std::jthread stopTokenWorker(stopTokenSleep, \"Worker1\");\n&nbsp;&nbsp;&nbsp; // 注册request_stop成功后的回调\n&nbsp;&nbsp;&nbsp; std::stop_callback callback(stopTokenWorker.get_stop_token(), [] {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[MAIN] Called after thread stop requested\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; });\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[MAIN] After create stop token thread\" &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(500ms);\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[MAIN] Request stop\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; stopTokenWorker.request_stop();\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[MAIN] Main function exited\" &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>在这段代码中，我们没有使用thread类，而是通过jthread类来创建线程。</p><p>代码中创建了两个子线程，从第39行到42行创建了第1个子线程对象simpleWorker，从第44到56行创建了第2个子线程对象stopTokenWorker。</p><p>这里我们并没有像thread类一样，调用join主动等待线程结束。但是，程序会自动等待所有线程停止后才会退出，这是如何实现的呢？</p><p>这一切的玄机，都在 <strong>jthread类的析构函数</strong>中！</p><p>在jthread对象析构时，如果jthread依然关联了活动线程（线程为joinable），会自动调用关联线程的request_stop，并调用join等待线程结束。线程结束后才会继续执行析构。</p><p>现在回到我们的代码，main函数在return前，会自动依次调用两个jthread对象的析构函数，销毁线程对象。这时主线程就会自动join这两个线程，确保线程对象销毁之前，子线程已经结束。这种默认行为可以确保主线程结束前，子线程必定都已经结束，不会引发不可预期的错误。</p><p>如果不希望jthread自动join，可以不在栈上直接创建jthread对象、或者直接调用detach解除线程与jthread对象的关联。从C++20开始支持的jthread，既保留了灵活性，又确保了默认行为的安全性，更符合一般使用线程的场景。</p><p>另外，stopTokenWorker演示了jthread的第二个重要特性—— <strong>stop_token</strong>。</p><p>每个jthread的工作函数的第一个参数，都可以定义为std::stop_token类型。这时，其他线程可以调用该jthread对象的request_stop成员函数，向jthread绑定的线程发送中断请求。</p><p>实际上request_stop并不会真的中断线程，而是将stop_token对象的stop_requested设置为true。jthread绑定的线程可以通过stop_requested获知是否有线程通知其中断，并自行决定是否结束线程。</p><p>按照标准规定，调用request_stop的过程是线程安全的——只有一个线程可以成功发送请求，一个线程发送请求成功后，其他线程调用request_token会失败，但不会引发异常。还有一个作用相同的类型是stop_source，如果你感兴趣，可以自己阅读相关文档了解如何使用。</p><p>代码的第48到50行还演示了 <strong>stop_callback</strong> 的用法，该类用于在一个jthread上注册一个成功调用request_stop后的回调函数——如果其他线程已经成功request_stop了一个jthread线程，那么，这个线程调用request_stop是不会触发本线程注册的回调函数的。</p><p>另外我们需要注意的是，一个线程可以注册多个stop_callback，标准只能保证所有的stop_callback会被同步依次调用，不能保证stop_callback的调用顺序（也就是并不一定按照注册顺序调用）。</p><p>综上所述，我们可以看到jthread提供了安全的默认行为，具备线程中断机制，可以根据实际情况调整具体行为，在确保安全的前提下支持灵活调用，在大多数场景中是更符合实际需求的设计。</p><h2>source location</h2><p>了解了jthread后，我们继续了解下一个相当重要的标准库变更——source location。</p><p>在C++中，如果我们希望获取当前行的源代码位置，一直都需要使用C预处理指令中预设的__FILE__和__LINE__两个宏。</p><p>但在C++中，这两个宏并不足以支持我们对程序跟踪调试的需求。</p><ul>\n<li>__LINE__无法自动包含函数名等关键信息，需要采用#line指令手动控制输出的标记。</li>\n<li>__FILE__和__LINE__都会在预处理阶段被替换为特定的字符串。但是，对于C++中使用的模板函数来说，只有在编译阶段，才能获知当前行所在函数的参数实例化信息。因此，使用__LINE__也无法获取所在行的模板实例化情况。</li>\n</ul><p>C++20终于提出了source_location这个标准类，可以获取当前行更完整的源代码信息。我们结合这段示例代码来看看。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;source_location&gt;\n#include &lt;string&gt;\n&nbsp;\nvoid logInnerLocation(const std::string&amp; message);\nvoid logLocation(\n&nbsp;&nbsp;&nbsp; const std::string&amp; message,\n&nbsp;&nbsp;&nbsp; std::source_location location = std::source_location::current()\n);\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; logInnerLocation(\"Inner location message\");\n&nbsp;&nbsp;&nbsp; // 通过默认参数通过current获取source_location对象\n&nbsp;&nbsp;&nbsp; // 这时source_location包含的信息就是在main内\n&nbsp;&nbsp;&nbsp; logLocation(\"Location message\");\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n&nbsp;\nvoid logInnerLocation(const std::string&amp; message) {\n&nbsp;&nbsp;&nbsp; // 在logInnerLocation内部通过current获取source_location对象\n&nbsp;&nbsp;&nbsp; // 这时source_location包含的信息就是在logInnerLocation内\n&nbsp;&nbsp;&nbsp; std::source_location location = std::source_location::current();\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; message &lt;&lt; std::endl &lt;&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"&nbsp; [\" &lt;&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; location.file_name() &lt;&lt; \"(\" &lt;&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; location.line() &lt;&lt; \":\" &lt;&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; location.column() &lt;&lt; \")@\" &lt;&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; location.function_name() &lt;&lt; \"]\" &lt;&lt; std::endl;\n}\n&nbsp;\nvoid logLocation(\n&nbsp;&nbsp;&nbsp; const std::string&amp; message,\n&nbsp;&nbsp;&nbsp; std::source_location location\n) {\n&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; message &lt;&lt; std::endl &lt;&lt; \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"&nbsp; [\" &lt;&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; location.file_name() &lt;&lt; \"(\" &lt;&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; location.line() &lt;&lt; \":\" &lt;&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; location.column() &lt;&lt; \")@\" &lt;&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; location.function_name() &lt;&lt; \"]\" &lt;&lt; std::endl;\n}\n</code></pre><p>代码中通过source_location的静态成员函数current，获取了当前位置的源代码信息。其中，获取到的信息包含file_name、line、column和function_name这几个字段，每个字段的含义你可以参考下表。</p><p><img src=\"https://static001.geekbang.org/resource/image/36/d7/36eb5f29e2ec5ed9c0284ec2fb383cd7.jpg?wh=1792x782\" alt=\"\"></p><p>可以看到，source_location这一标准类，能为我们提供精确的编译时源代码信息，涵盖了普通函数调用和模板函数所有使用场景。这对于发布用于调试的程序极为有用。</p><h2>sync stream</h2><p>在多线程场景中，使用C++传统输出流接口会存在一个问题：多个线程直接向同一个输出流对象输出内容时，会得到无法预估的错乱输出。</p><p>因此，我们一般需要自己通过互斥锁等方式，实现输出的线程同步。这种方式虽然能够解决问题，但是编程效率低下，运行时也会有潜在的性能问题。</p><p>C++20提出的sync stream解决了这个问题。先来看一段代码。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;syncstream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n#include &lt;cstdint&gt;\n&nbsp;\nnamespace chrono = std::chrono;\n&nbsp;\n// 普通stream版本\nvoid coutPrinter(const std::string message1, const std::string message2);\n// syncstream版本\nvoid syncStreamPrinter(const std::string message1, const std::string message2);\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Cout workers:\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; // 创建多个thread\n&nbsp;&nbsp;&nbsp; std::vector&lt;std::thread&gt; coutWorkers;\n&nbsp;&nbsp;&nbsp; for (int32_t workerIndex = 0; workerIndex &lt; 10; ++workerIndex) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::thread coutWorker(coutPrinter,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"abcdefghijklmnopqrstuvwxyz\"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coutWorkers.push_back(std::move(coutWorker));\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; \n&nbsp;&nbsp;&nbsp; // 普通thread需要手动join\n&nbsp;&nbsp;&nbsp; for (auto&amp; worker : coutWorkers) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (worker.joinable()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worker.join();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"SyncStream workers:\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; // 创建多个jthread，会在析构时自动join\n&nbsp;&nbsp;&nbsp; std::vector&lt;std::jthread&gt; syncStreamWorkers;\n&nbsp;&nbsp;&nbsp; for (int32_t workerIndex = 0; workerIndex &lt; 10; ++workerIndex) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::jthread syncStreamWorker(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syncStreamPrinter,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"abcdefghijklmnopqrstuvwxyz\"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syncStreamWorkers.push_back(std::move(syncStreamWorker));\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n&nbsp;\nvoid coutPrinter(const std::string message1, const std::string message2) {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; message1 &lt;&lt; \" \" &lt;&lt; message2 &lt;&lt; std::endl;\n}\n&nbsp;\nvoid syncStreamPrinter(const std::string message1, const std::string message2) {\n&nbsp;&nbsp;&nbsp; // 使用std::osyncstream包装输出流对象即可\n&nbsp;&nbsp;&nbsp; std::osyncstream(std::cout) &lt;&lt; message1 &lt;&lt; \" \" &lt;&lt; message2 &lt;&lt; std::endl;\n}\n</code></pre><p>我们在代码18到32行，创建了多个thread对象，并以coutPrinter为入口函数，创建线程后逐个调用join等待线程完成。coutPrinter中直接调用cout输出字符串，这样可以方便我们看到，同时调用相同的输出流对象输出时会发生什么。</p><p>在代码36到44行，创建了多个jthread对象，并以syncStreamPrinter为入口函数。由于jthread会在析构时自动join，因此，这里就不需要手动等待线程完成了。syncStreamPrinter中调用 std::osyncstream将cout包装成一个syncstream，然后将字符串输出到osyncstream对象中。</p><p>运行这段程序，你可能会看到下图这样的输出。</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/a4/8a7be39cb07cca19416e6c4508e5cba4.jpg?wh=1940x829\" alt=\"\"></p><p>很明显，并发输出到cout时出现了无法预期的混乱输出。然而，输出到osyncstream时没有出现直接使用cout输出时的混乱。为什么会出现这样的情况呢？</p><p>这是因为osyncstream会包装输出流对象的内部缓冲区，确保通过osyncstream输出时每次输出都具备原子性，因此也就不会出现错乱的输出了。</p><h2>u8string</h2><p>在C++11中，引入了std::u16string和std::u32string，用于描述utf-16和utf-32的字符串。它们分别使用char16_t和char32_t两个新的字符类型，描述UTF-16与UTF-32代码点。但奇怪的是，标准始终没有提供对utf-8字符描述方式。</p><p>好在C++20中终于引入了u8string，用于描述UTF-8字符串。在引入u8string的同时，C++20还定义了一个新的字符类型char8_t，用于描述UTF-8的代码点。u8string就是类型为char8_t的序列。</p><p>但是这里有一个问题，<strong>为什么C++20要引入新的字符类型，而不是用char呢？</strong></p><p>这是因为，C++标准定义的char存在两个比较大的坑。</p><p>首先，与其他整数类型不同，标准没有定义char是signed char还是unsigned char，有无符号具体由实现决定。</p><p>其次，标准只为char定义了最小长度为8位，实际长度也由实现决定（虽然事实标准的确是8位），这就导致我们无法严格采用char来描述UTF-8的代码点（UTF-8代码点固定为8位）。</p><p>因此，标准必须引入char8_t这个新类型。不过需要注意的是，char8_t和char是无法直接隐式转换的，而标准库的很多标准函数都是基于char这个类型定义的，如果需要转换，必须要强制类型转换。</p><p>后面这段代码演示了如何定义u8string，以及如何处理输出与转码。</p><pre><code class=\"language-c++\">#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;clocale&gt;\n#include &lt;cuchar&gt;\n#include &lt;cstdint&gt;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; std::setlocale(LC_ALL, \"en_US.utf8\");\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 使用u8创建u8string字面量\n&nbsp;&nbsp;&nbsp; std::u8string utf8String = u8\"你好，这是UTF-8\";&nbsp;&nbsp;&nbsp; \n&nbsp;&nbsp;&nbsp; // 调用size()获取UTF-8代码点数量\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Processing \" &lt;&lt; utf8String.size() &lt;&lt; \" bytes: [ \" &lt;&lt; std::showbase;\n&nbsp;&nbsp;&nbsp; for (char8_t c : utf8String) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::hex &lt;&lt; +c &lt;&lt; ' ';\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"]\\n\";\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 获取UTF-8代码点序列的起始位置与结束位置\n&nbsp;&nbsp;&nbsp; const char* utf8Current = reinterpret_cast&lt;char*&gt;(&amp;utf8String[0]);\n&nbsp;&nbsp;&nbsp; const char* utf8End = reinterpret_cast&lt;char*&gt;(&amp;utf8String[0] + utf8String.size());\n&nbsp;&nbsp;&nbsp; char16_t c16;\n&nbsp;&nbsp;&nbsp; std::mbstate_t convertState{};\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 定义UTF-16字符串\n&nbsp;&nbsp;&nbsp; std::u16string utf16String;\n&nbsp;&nbsp;&nbsp; // 调用mbrtoc16执行转码\n&nbsp;&nbsp;&nbsp; while (std::size_t rc = std::mbrtoc16(&amp;c16, utf8Current, utf8End - utf8Current + 1, &amp;convertState)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Next UTF-16 char: \" &lt;&lt; std::hex\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; static_cast&lt;int32_t&gt;(c16) &lt;&lt; \" obtained from \";\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rc == (std::size_t)-3)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"earlier surrogate pair\\n\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (rc == (std::size_t)-2)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (rc == (std::size_t)-1)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::dec &lt;&lt; rc &lt;&lt; \" bytes [ \";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (std::size_t n = 0; n &lt; rc; ++n)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::hex &lt;&lt; +static_cast&lt;unsigned char&gt;(utf8Current[n]) &lt;&lt; ' ';\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"]\\n\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utf8Current += rc;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utf16String.push_back(c16);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 输出UTF-8编码字符串\n&nbsp;&nbsp;&nbsp; std::ofstream u8OutputFile(\"out.utf8.txt\", std::ios::binary);\n&nbsp;&nbsp;&nbsp; u8OutputFile.write(reinterpret_cast&lt;char*&gt;(utf8String.data()), utf8String.size() * sizeof(char8_t));\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 输出UTF-16编码字符串\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::dec &lt;&lt; utf16String.size() &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::ofstream u16OutputFile(\"out.utf16.txt\", std::ios::binary);\n&nbsp;&nbsp;&nbsp; u16OutputFile.write(reinterpret_cast&lt;char*&gt;(utf16String.data()), utf16String.size() * sizeof(char16_t));\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>在代码第12行使用了u8创建u8string的字面量字符串。</p><p>在代码14到18行，首先输出了u8string的代码点数量，然后使用十六进制输出了u8string内的代码点数量。我们处理UTF-8字符串的时候，必须要知道UTF-8是变长编码，所以一个真正的字符可能包含不同数量的代码点，就像代码中字符串包含10个字符，但是包含20个代码点。</p><p>在代码第29到47行，我们演示如何调用mbrtoc16函数，完成UTF-8编码向UTF-16编码的转换。</p><p><img src=\"https://static001.geekbang.org/resource/image/25/56/25f47bc09b8a937732f93668d7478356.jpg?wh=1801x716\" alt=\"\"></p><p>由于UTF-8是变长编码集，因此我们需要多次调用mbrtoc16将UTF-8的字符逐个转换成UTF-16的代码点。</p><p>每次调用时，会将第二个参数（类型为const char*，这里相当于UTF-8字符串的开始位置）开始的特定数量代码点，转换成一个UTF-16中对应的代码点，写入到该函数的第一个参数中（类型为char16_t*）。</p><p>这里需要注意mbrtoc16的返回值rc，我画了一张表，帮你梳理了rc可能的返回值。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/df/84c5e524bb05dd534d9c8254f1e86ddf.jpg?wh=1817x996\" alt=\"\"></p><p>遗憾的是，这种标准库支持的编码转换方式依赖于C的locale。但是，C的locale实现支持完全取决于具体的C/C++运行时环境（也会进一步依赖于操作系统）。</p><p>因此，我们的代码虽然可以运行在主流系统与运行时环境中，但不能保证兼容性。</p><p>另外，C的locale还有C标准库经常遇到的多线程环境问题，因为setlocale是全局的，所以在一个线程中setlocale对其他线程中行为的影响是未知的。也就是说，setlocale并非线程隔离，也不是线程安全的，所以在多线程程序中使用C的locale，我们需要慎之又慎。</p><p>因此，在大部分场景下，我还是建议你使用iconv之类的第三方编码转换库执行编码转换。希望C++能在日后标准中，进一步脱离C的locale，然后彻底解决编码问题吧。</p><p>此外，与C++11加入的u16string一样，C++20的u8string也缺乏输入输出流的直接支持（根本原因是C++17废弃了codecvt的具体实现）。因此，在代码50到56行中，我们不得不使用二进制的方式将其输出到文件中。</p><p>不得不说，C++针对语言编码的支持，依然任重而道远！我们期待着在后续演进标准中逐步解决这些问题。</p><h2>总结</h2><p>我们在这一讲中，进一步补充了C++20标准中重要的库变更，包括它们的用法和注意事项。</p><p>jthread是自C++11之后对标准的并发编程的一次重要补充，它支持了安全的默认行为，具备线程中断机制，可以根据实际情况调整具体行为，在确保安全的前提下支持灵活的调整，在大多数场景中是更符合实际需求的设计。</p><p>source location对输出代码的准确位置提供了有力支撑，同时解决了模板函数中长久以来存在的问题——无法输出准确代码执行位置。这为调试复杂程序和输出信息提供了新工具。</p><p>另外，我们还讨论了u8string，以及C++针对语言编码支持的问题。标准库支持的编码转换方式仍然依赖于C的locale，我们期待着在后续演进标准中逐步解决这些问题。</p><h2>思考题</h2><p>请你结合char的宽度问题，思考一下u8string转换示例代码中可能还会出现什么兼容性问题。</p><p>欢迎说出你的看法，与大家一起分享。我们一同交流。下一讲见！</p>","neighbors":{"left":{"article_title":"17｜Bit library（二）：如何利用新bit操作库释放编程生产力？","id":633504},"right":{"article_title":"19｜其他重要标准库特性实战：利用日历应用熟悉新特性","id":635706}},"comments":[{"had_liked":false,"id":369788,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1677939146,"is_pvip":false,"replies":[{"id":134891,"content":"1.\tpthread_create不属于thread类。Pthread是POSIX的Thread标准，是支持POSIX标准的系统提供的线程库，并不属于C++标准的一部分，而是属于实现部分（也就是C++标准库可能在某些支持POSIX标准的系统中使用pthread实现thread类）。\n2.\tstop_requested设置为true，线程本身不退出不会发生什么，stop_requested只是一种线程安全的中止线程的通知手段而已。\n3.\t一个线程向一个jthread对象发送request_stop成功后其他的线程就不会发送成功了，因为标准中规定的就是有且只有一个线程可以发送request_stop成功，因为发送成功后stop_token就设置成true了，其他的线程再发送也就没啥意义了，你可以把request_token发送成功理解为“成功将jthread的stop_token从false修改成true”，如果stop_token本来就是true了，那肯定就不用修改了，就是发送失败。\n","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1678249488,"ip_address":"上海","comment_id":369788,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"请教老师几个问题：\nQ1：pthread_create属于thread类吗？\n我从网上搜到了一个安卓代码，有C++代码。线程部分，用的是pthread_create、pthread_join、pthread_exit等函数。能正常工作，但不太了解这套东西。这套东西属于C++类库中的thread类吗？还是类似于系统调用一类的API？\nQ2：stop_requested设置为true，但线程本身不退出，会发生什么？\nQ3：一个线程发送request_stop成功后，什么时候其他线程才能发送？ 文中提到“一个线程发送请求成功后，其他线程调用 request_token 会失败，但不会引发异常”，发送成功后，按道理其他线程就可以发送了啊；不能发送的话，何时才能发送？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608073,"discussion_content":"1.\tpthread_create不属于thread类。Pthread是POSIX的Thread标准，是支持POSIX标准的系统提供的线程库，并不属于C++标准的一部分，而是属于实现部分（也就是C++标准库可能在某些支持POSIX标准的系统中使用pthread实现thread类）。\n2.\tstop_requested设置为true，线程本身不退出不会发生什么，stop_requested只是一种线程安全的中止线程的通知手段而已。\n3.\t一个线程向一个jthread对象发送request_stop成功后其他的线程就不会发送成功了，因为标准中规定的就是有且只有一个线程可以发送request_stop成功，因为发送成功后stop_token就设置成true了，其他的线程再发送也就没啥意义了，你可以把request_token发送成功理解为“成功将jthread的stop_token从false修改成true”，如果stop_token本来就是true了，那肯定就不用修改了，就是发送失败。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678249488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}