{"id":89845,"title":"14 | 临近 OOM，如何获取详细内存分配信息，分析内存问题？","content":"<p>你好，我是戴铭。今天我们来聊聊，临近OOM，如何获取详细的内存分配信息，分析内存问题的话题。</p><p>OOM，是Out of Memory的缩写，指的是App占用的内存达到了iOS系统对单个App占用内存上限后，而被系统强杀掉的现象。这么说的话，OOM其实也属于我们在第12篇文章“<a href=\"https://time.geekbang.org/column/article/88600\">iOS 崩溃千奇百怪，如何全面监控？</a>”中提到的应用“崩溃”中的一种，是由iOS的Jetsam机制导致的一种“另类”崩溃，并且日志无法通过信号捕捉到。</p><p>JetSam机制，指的就是操作系统为了控制内存资源过度使用而采用的一种资源管控机制。</p><p>我们都知道，物理内存和 CPU 对于手机这样的便携设备来说，可谓稀缺资源。所以说，在iOS 系统的虚拟内存管理中，内存压力的管控就是一项很重要的内容。</p><p>接下来，我就跟你介绍一下如何获取内存上限值，以及如何监控到App因为占用内存过大而被强杀的问题？</p><h2>通过 JetsamEvent 日志计算内存限制值</h2><p>想要了解不同机器在不同系统版本的情况下，对 App 的内存限制是怎样的，有一种方法就是查看手机中以 JetsamEvent 开头的系统日志（我们可以从设置-&gt;隐私-&gt;分析中看到这些日志）。</p><p>在这些系统日志中，查找崩溃原因时我们需要关注 per-process-limit 部分的 rpages。rpages 表示的是 ，App 占用的内存页数量；per-process-limit 表示的是，App 占用的内存超过了系统对单个App 的内存限制。</p><!-- [[[read_end]]] --><p>这部分日志的结构如下：</p><pre><code>&quot;rpages&quot; : 89600,\n&quot;reason&quot; : &quot;per-process-limit&quot;,\n</code></pre><p>现在，我们已经知道了内存页数量  rpages 为 89600，只要再知道内存页大小的值，就可以计算出系统对单个App限制的内存是多少了。</p><p>内存页大小的值，我们也可以在 JetsamEvent 开头的系统日志里找到，也就是pageSize的值。如下图红框部分所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/2a/f60391e3109494b411cef7d936b4792a.png?wh=1354*1256\" alt=\"\"><br>\n可以看到，内存页大小 pageSize 的值是16384。接下来，我们就可以计算出当前 App 的内存限制值：pageSize * rpages / 1024 /1024 =16384 * 89600 / 1024 / 1024 得到的值是 1400 MB，即 1.4G。</p><p>这些 JetsamEvent 日志，都是系统在杀掉 App 后留在手机里的。在查看这些日志时，我们就会发现，很多日志都是 iOS 系统内核强杀掉那些优先级不高，并且占用的内存超过限制的 App 后留下的。</p><p>这些日志属于系统级的，会存在系统目录下。App上线后开发者是没有权限获取到系统目录内容的，也就是说，被强杀掉的 App 是无法获取到系统级日志的，只能线下设备通过连接 Xcode 获取到这部分日志。获取到Jetsam 后，就能够算出系统对 App 设置的内存限制值。</p><p>那么，<strong>iOS系统是怎么发现 Jetsam 的呢？</strong></p><p>iOS 系统会开启优先级最高的线程 vm_pressure_monitor 来监控系统的内存压力情况，并通过一个堆栈来维护所有 App 的进程。另外，iOS系统还会维护一个内存快照表，用于保存每个进程内存页的消耗情况。</p><p>当监控系统内存的线程发现某 App 内存有压力了，就发出通知，内存有压力的 App 就会去执行对应的代理，也就是你所熟悉的 didReceiveMemoryWarning 代理。通过这个代理，你可以获得最后一个编写逻辑代码释放内存的机会。这段代码的执行，就有可能会避免你的App被系统强杀。</p><p>系统在强杀App前，会先做优先级判断。那么，这个<strong>优先级判断的依据是什么呢？</strong></p><p>iOS系统内核里有一个数组，专门用于维护线程的优先级。这个优先级规定就是：内核用线程的优先级是最高的，操作系统的优先级其次，App 的优先级排在最后。并且，前台 App 程序的优先级是高于后台运行 App 的；线程使用优先级时，CPU 占用多的线程的优先级会被降低。</p><p>iOS系统在因为内存占用原因强杀掉App前，至少有6秒钟的时间可以用来做优先级判断。同时，JetSamEvent日志也是在这6秒内生成的。</p><p>除了JetSamEvent日志外，我们还可以通过XNU来获取内存的限制值。</p><h2>通过 XNU 获取内存限制值</h2><p>在 XNU 中，有专门用于获取内存上限值的函数和宏。我们可以通过 memorystatus_priority_entry 这个结构体，得到进程的优先级和内存限制值。结构体代码如下：</p><pre><code>typedef struct memorystatus_priority_entry {\n\tpid_t pid;\n\tint32_t priority;\n\tuint64_t user_data;\n\tint32_t limit;\n\tuint32_t state;\n} memorystatus_priority_entry_t;\n</code></pre><p>在这个结构体中，priority 表示的是进程的优先级，limit就是我们想要的进程内存限制值。</p><h2>通过内存警告获取内存限制值</h2><p>通过XNU 的宏获取内存限制，需要有 root 权限，而App 内的权限是不够的，所以正常情况下，作为App开发者你是看不到这个信息的。那么，如果你不想越狱去获取这个权限的话，还可以利用 didReceiveMemoryWarning 这个内存压力代理事件来动态地获取内存限制值。</p><p>iOS系统在强杀掉App之前还有6秒钟的时间，足够你去获取记录内存信息了。那么，<strong>如何获取当前内存使用情况呢？</strong></p><p>iOS系统提供了一个函数 task_info， 可以帮助我们获取到当前任务的信息。关键代码如下：</p><pre><code>struct mach_task_basic_info info;\nmach_msg_type_number_t size = sizeof(info);\nkern_return_t kl = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);\n</code></pre><p>代码中，task_info_t 结构里包含了一个resident_size 字段，用于表示使用了多少内存。这样，我们就可以获取到发生内存警告时，当前App 占用了多少内存。代码如下：</p><pre><code>float used_mem = info.resident_size;\nNSLog(@&quot;使用了 %f MB 内存&quot;, used_mem / 1024.0f / 1024.0f)\n</code></pre><h2>定位内存问题信息收集</h2><p>现在，我们已经可以通过三种方法来获取内存上限值了，而且通过内存警告的方式还能够动态地获取到这个值。有了这个内存上限值以后，你就可以进行内存问题的信息收集工作了。</p><p>要想精确地定位问题，我们就需要 dump 出完整的内存信息，包括所有对象及其内存占用值，在内存接近上限值的时候，收集并记录下所需信息，并在合适的时机上报到服务器里，方便分析问题。</p><p>获取到了每个对象的内存占用量还不够，你还需要知道是谁分配的内存，这样才可以精确定位到问题的关键所在。一个对象可能会在不同的函数里被分配了内存并被创建了出来，当这个对象内存占用过大时，如果不知道是在哪个函数里创建的话，问题依然很难精确定位出来。那么，<strong>怎样才能知道是谁分配的内存呢？</strong></p><p>这个问题，我觉得应该从根儿上去找答案。内存分配函数 malloc 和 calloc 等默认使用的是 nano_zone。nano_zone 是256B以下小内存的分配，大于256B 的时候会使用 scalable_zone 来分配。</p><p>在这里，我主要是针对大内存的分配监控，所以只针对 scalable_zone 进行分析，同时也可以过滤掉很多小内存分配监控。比如，malloc函数用的是 malloc_zone_malloc，calloc 用的是 malloc_zone_calloc。</p><p>使用scalable_zone 分配内存的函数都会调用 malloc_logger 函数，因为系统总是需要有一个地方来统计并管理内存的分配情况。</p><p>具体实现的话，你可以查看 malloc_zone_malloc 函数的实现，代码如下：</p><pre><code>void *malloc_zone_malloc(malloc_zone_t *zone, size_t size)\n{\n\tMALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0);\n\tvoid *ptr;\n\tif (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) {\n\t\tinternal_check();\n\t}\n\tif (size &gt; MALLOC_ABSOLUTE_MAX_SIZE) {\n\t\treturn NULL;\n\t}\n\tptr = zone-&gt;malloc(zone, size);\n\t// 在 zone 分配完内存后就开始使用 malloc_logger 进行进行记录\n\tif (malloc_logger) {\n\t\tmalloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (uintptr_t)zone, (uintptr_t)size, 0, (uintptr_t)ptr, 0);\n\t}\n\tMALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0);\n\treturn ptr;\n}\n</code></pre><p>其他使用 scalable_zone 分配内存的函数的方法也类似，所有大内存的分配，不管外部函数是怎么包装的，最终都会调用 malloc_logger 函数。这样的话，问题就好解决了，你可以使用 fishhook 去 Hook 这个函数，加上自己的统计记录就能够通盘掌握内存的分配情况。出现问题时，将内存分配记录的日志捞上来，你就能够跟踪到导致内存不合理增大的原因了。</p><h2>小结</h2><p>为了达到监控内存的目的，我们需要做两件事情：一是，能够根据不同机器和系统获取到内存有问题的那个时间点；二是，到了出现内存问题的那个时间点时，还能要取到足够多的可以分析内存问题的信息。</p><p>针对这两件事，我在今天这篇文章里和你分享了在 JetsamEvent 日志里、在 XNU 代码里、在 task_info 函数中怎么去找内存的上限值。然后，我和你一起分析了在内存到达上限值时，怎么通过内存分配时都会经过的 malloc_logger 函数来掌握内存分配的详细信息，从而精确定位内存问题。</p><p>说到这里你可能会回过头来想，为什么用于占用内存过大时会被系统强杀呢？macOS 打开一堆应用也会远超物理内存，怎么没见系统去强杀 macOS 的应用呢？</p><p>其实，这里涉及到的是设备资源的问题。苹果公司考虑到手持设备存储空间小的问题，在 iOS 系统里去掉了交换空间，这样虚拟内存就没有办法记录到外部的存储上。于是，苹果公司引入了 MemoryStatus 机制。</p><p>这个机制的主要思路就是，在 iOS 系统上弹出尽可能多的内存供当前应用使用。把这个机制落到优先级上，就是先强杀后台应用；如果内存还不够多就强杀掉当前应用。而在macOS 系统里，MemoryStatus 只会强杀掉标记为空闲退出的进程。</p><p>在实现上，MemoryStatus 机制会开启一个memorystatus_jetsam_thread 的线程。这个线程，和内存压力监测线程 vm_pressure_monitor 没有联系，只负责强杀应用和记录日志，不会发送消息，所以内存压力检测线程无法获取到强杀应用的消息。</p><p>除内存过大被系统强杀这种内存问题以外，还有以下三种内存问题：</p><ul>\n<li>访问未分配的内存： XNU 会报 EXC_BAD_ACCESS错误，信号为 SIGSEGV Signal #11 。</li>\n<li>访问已分配但未提交的内存：XNU 会拦截分配物理内存，出现问题的线程分配内存页时会被冻结。</li>\n<li>没有遵守权限访问内存：内存页面的权限标准类似 UNIX 文件权限。如果去写只读权限的内存页面就会出现错误，XNU 会发出 SIGBUS Signal #7 信号。</li>\n</ul><p>第一种和第三种问题都可以通过崩溃信息获取到，在收集崩溃信息时如果发现是这两类，我们就可以把内存分配的记录同时传过来进行分析，对于不合理的内存分配进行优化和修改。</p><h2>课后小作业</h2><p>我今天提到了定位内存问题需要获取更多的信息，比如内存分配。那么，请你来根据我们今天所讲的 hook malloc_logger 的方法，来实现一个记录内存分配的小工具吧。</p><p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。</p>","comments":[{"had_liked":false,"id":84897,"user_name":"白开了杯水","can_delete":false,"product_type":"c1","uid":1156672,"ip_address":"","ucode":"F0328577343AB5","user_header":"https://static001.geekbang.org/account/avatar/00/11/a6/40/6518a188.jpg","comment_is_top":false,"comment_ctime":1554943692,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"61684485836","product_id":100024501,"comment_content":"一直不知道内存分配最大值获取和怎么获取当前内存分配，看了文章豁然开朗，想问的是，老师这些知识都是通过分析源码得来的吗？","like_count":15,"discussions":[{"author":{"id":1785940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rWMGIQG1z13nekorr9I4PY1w7rlskssf949IQ24SvIewpM7mmZoH2QEZ2aKHu5tkmicGQ7KTGrN9vFYhrDsdp9w/132","nickname":"Geek_9dbcb4","note":"","ucode":"BB92D5E844A743","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230981,"discussion_content":"内功深厚，加上查阅资料","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586783662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219652,"user_name":"欢乐的小马驹","can_delete":false,"product_type":"c1","uid":1078951,"ip_address":"","ucode":"B594106688CEE7","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/a7/374e86a7.jpg","comment_is_top":false,"comment_ctime":1590056090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48834696346","product_id":100024501,"comment_content":"我建议，以后写这样的专栏，最后把所有参考的原始资料都下。你觉得呢？","like_count":12},{"had_liked":false,"id":85705,"user_name":"drunkenMouse","can_delete":false,"product_type":"c1","uid":1454037,"ip_address":"","ucode":"AA8CEA703ECBE8","user_header":"","comment_is_top":false,"comment_ctime":1555208016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35914946384","product_id":100024501,"comment_content":"iOS通过堆栈管理所有的app进程，通过一个优先级最高的线程去监控系统内存的压力，还有一个快速对照表记录所有app的内存使用情况。如果内存有压力了，就按照优先级去释放优先级低还使用内存多的。<br><br>所以app得内存阈值是没有固定大小的。我一直以为每个app可以使用的内存大小是固定的。。","like_count":9},{"had_liked":false,"id":87386,"user_name":"我唔知点死啊","can_delete":false,"product_type":"c1","uid":1454319,"ip_address":"","ucode":"032CCE72B8F848","user_header":"","comment_is_top":false,"comment_ctime":1555580691,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18735449875","product_id":100024501,"comment_content":"fishhook初学者提问：<br>关于fishhook malloc_logger，在libmalloc中找到malloc_logger是一个结构体：<br>typedef void(malloc_logger_t)(uint32_t type,<br>\t\tuintptr_t arg1,<br>\t\tuintptr_t arg2,<br>\t\tuintptr_t arg3,<br>\t\tuintptr_t result,<br>\t\tuint32_t num_hot_frames_to_skip);<br><br>fishhook malloc_logger没有任何作用，然后在_malloc_initialize方法里面，找到这句malloc_logger = __disk_stack_logging_log_stack;<br>fishhhok __disk_stack_logging_log_stack同样不起作用，现在无从下手，请指教。<br><br>我的fishhook方法如下：<br>static void (*original_disk_stack_logging_log_stack)(uint32_t type_flags,<br>                               uintptr_t zone_ptr,<br>                               uintptr_t arg2,<br>                               uintptr_t arg3,<br>                               uintptr_t return_val,<br>                                  uint32_t num_hot_to_skip);<br>void new_disk_stack_logging_log_stack(uint32_t type_flags,<br>                               uintptr_t zone_ptr,<br>                               uintptr_t arg2,<br>                               uintptr_t arg3,<br>                               uintptr_t return_val,<br>                               uint32_t num_hot_to_skip) {<br>    NSLog(@&quot;========== __disk_stack_logging_log_stack ==========&quot;);<br>}<br><br>        struct rebinding malloc_logger_rebinding = { &quot;__disk_stack_logging_log_stack&quot;, original_disk_stack_logging_log_stack, (void *)&amp;original_disk_stack_logging_log_stack};<br>        rebind_symbols((struct rebinding[1]){malloc_logger_rebinding}, 1);","like_count":4,"discussions":[{"author":{"id":1471806,"avatar":"https://static001.geekbang.org/account/avatar/00/16/75/3e/71b16443.jpg","nickname":"Struggle","note":"","ucode":"C769D8FFD9C1B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283751,"discussion_content":"基础不好的我这个地方理解了超级久，不过最终还是hook到了，正如楼上说的，不需要fishhook,只需要添加实现就可以了\n如下\n\n1:下面这段代码是从libmalloc拷贝的\ntypedef void(malloc_logger_t)(\n        uint32_t type,\n        uintptr_t arg1,\n        uintptr_t arg2,\n        uintptr_t arg3,\n        uintptr_t result,\n        uint32_t num_hot_frames_to_skip);\nextern malloc_logger_t *malloc_logger; \n\na:这代码的意思是定义了一个这样的函数\nvoid()(uint32_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uint32_t),函数的别名是malloc_logger_t;\nb:extern表示后面的是从其他地方引用的,其他的地方定义了一个malloc_logger_t类型的函数指针malloc_logger\n上面这段代码有点类似于 \ntypedef int A; //给int添加一个别名\nA a; //定义一个A类型的变量,就是int 类型的变量\n\n2:我们定义一个函数实现\nvoid malloc_logger_impl(uint32_t type,uintptr_t arg1,uintptr_t arg2,uintptr_t arg3,uintptr_t result,uint32_t num_hot_frames_to_skip){\n    printf(&#34;%d-%lu-%lu-%lu-%lu-%d\\n&#34;,type,arg1,arg2,arg3,result,num_hot_frames_to_skip);\n}\n3:在你的入口添加代码,可以看到libmalloc里面的malloc_logger=NULL的，这个地方我们给一个我们自己的函数实现,在if(malloc_logger)的时候就能执行到if里面了\nmalloc_logger = malloc_logger_impl\n这样就能够成功hook\n\n\n---------------完整代码\n\n#import <UIKit/UIKit.h>\n#import &#34;AppDelegate.h&#34;\n#import &#34;SyxDemo.h&#34;\ntypedef void(malloc_logger_t)(\n        uint32_t type,\n        uintptr_t arg1,\n        uintptr_t arg2,\n        uintptr_t arg3,\n        uintptr_t result,\n        uint32_t num_hot_frames_to_skip);\nextern malloc_logger_t *malloc_logger;\nvoid malloc_logger_impl(uint32_t type,uintptr_t arg1,uintptr_t arg2,uintptr_t arg3,uintptr_t result,uint32_t num_hot_frames_to_skip){\n    printf(&#34;%d-%lu-%lu-%lu-%lu-%d\\n&#34;,type,arg1,arg2,arg3,result,num_hot_frames_to_skip);\n}\nint main(int argc, char * argv[]) {\n    NSString * appDelegateClassName;\n    @autoreleasepool {\n        appDelegateClassName = NSStringFromClass([AppDelegate class]);\n        malloc_logger = malloc_logger_impl;\n        SyxDemo *demo = [[SyxDemo alloc]init];\n    }\n    return UIApplicationMain(argc, argv, nil, appDelegateClassName);\n}","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1592356185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1029592,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b5/d8/56148446.jpg","nickname":"张英杰","note":"","ucode":"4EC0B6D787EBF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7518,"discussion_content":"可以看一下libmalloc源码，malloc_logger本身就是一个钩子函数，不需要用fishhook","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567526344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107176,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1110113,"ip_address":"","ucode":"2D2E877CF97138","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg","comment_is_top":false,"comment_ctime":1561473573,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14446375461","product_id":100024501,"comment_content":"我问这个问题的原因是看到SDWebImage 2.6版本的源码中释放内存缓存有两种方式：<br>第一种：监听到内存不足时，释放所有内存缓存；<br>第二种：当系统剩余内存小于12M时，释放内存缓存。<br><br>刚开始版本是没有加第二种判断的。我的疑问是加上第二种判断有必要吗？如果有必要的话，那么就是，当系统只剩12M内存都还没有触发内存不足的通知。<br><br>所以说这个内存不足通知是否在应用能给它分配的最大内存都全部使用完了才发出通知还是？<br>如：当前app能使用的最大内存为2G，系统总共内存为4G。那是否说不管系统是否还剩余多少内存，只要app的内存达到2G就发出内存警告通知？还是说快到2G,如达到最大可用内存的百分之95以上就发出内存警告通知。有哪里可以看到这个值吗？","like_count":3,"discussions":[{"author":{"id":1460977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/f1/e3b02c6d.jpg","nickname":"莫言","note":"","ucode":"3B5782B58BFD18","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216529,"discussion_content":"你可以简单测试一下，写给for循环获取不停的maclloc不释放内存，你看内存达到啥程度能收到内存警告","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585461010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1785940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rWMGIQG1z13nekorr9I4PY1w7rlskssf949IQ24SvIewpM7mmZoH2QEZ2aKHu5tkmicGQ7KTGrN9vFYhrDsdp9w/132","nickname":"Geek_9dbcb4","note":"","ucode":"BB92D5E844A743","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230983,"discussion_content":"达到最大值时，发通知吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586783830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86988,"user_name":"徐秀滨","can_delete":false,"product_type":"c1","uid":1457337,"ip_address":"","ucode":"36895D00A181FB","user_header":"https://static001.geekbang.org/account/avatar/00/16/3c/b9/42b228f8.jpg","comment_is_top":false,"comment_ctime":1555493001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14440394889","product_id":100024501,"comment_content":"老师，我没找到malloc_logger这个方法，没法hook，咋搞？","like_count":3},{"had_liked":false,"id":84930,"user_name":"鼠辈","can_delete":false,"product_type":"c1","uid":1457947,"ip_address":"","ucode":"F8CD6602D9320E","user_header":"https://static001.geekbang.org/account/avatar/00/16/3f/1b/40293181.jpg","comment_is_top":false,"comment_ctime":1554946216,"is_pvip":false,"replies":[{"id":"30719","content":"使用的字段不同，task_vm_info_data_t 还有个 phys_footprint 代表的实际使用的物理内存","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555139750,"ip_address":"","comment_id":84930,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14439848104","product_id":100024501,"comment_content":"info.resident_size这个获取的内存和xcode上显示的内存是对不上的。不知道您怎么看这个问题？","like_count":3,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446501,"discussion_content":"使用的字段不同，task_vm_info_data_t 还有个 phys_footprint 代表的实际使用的物理内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555139750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1785940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rWMGIQG1z13nekorr9I4PY1w7rlskssf949IQ24SvIewpM7mmZoH2QEZ2aKHu5tkmicGQ7KTGrN9vFYhrDsdp9w/132","nickname":"Geek_9dbcb4","note":"","ucode":"BB92D5E844A743","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230987,"discussion_content":"其他章节里，有提到phys_footprint，代表实际使用的物理内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586783933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86501,"user_name":"Jaker","can_delete":false,"product_type":"c1","uid":1460817,"ip_address":"","ucode":"61FCEDE3B94F49","user_header":"https://static001.geekbang.org/account/avatar/00/16/4a/51/02678317.jpg","comment_is_top":false,"comment_ctime":1555384496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10145319088","product_id":100024501,"comment_content":"接上面的问题，问一下老师，task_vm_info_data_t的phys_footprint 打印输出的内存值和xcode的显示内存还是不一致啊，这是怎么回事，望解惑，谢谢。","like_count":2},{"had_liked":false,"id":85437,"user_name":"drunkenMouse","can_delete":false,"product_type":"c1","uid":1454037,"ip_address":"","ucode":"AA8CEA703ECBE8","user_header":"","comment_is_top":false,"comment_ctime":1555060099,"is_pvip":false,"replies":[{"id":"30671","content":"在你设置相同优先级的线程中，系统会有更细的优先级策略，这个策略就是哪个线程 CPU 占用高，优先级会比降低","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555123482,"ip_address":"","comment_id":85437,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10144994691","product_id":100024501,"comment_content":"线程使用优先级时，CPU 占用多的线程的优先级会被降低。这句话怎么读不懂呢？<br><br>利用didReceivedMemoryWarning 这个代理时间，看得我一愣。。应该是代理事件，我这算不算鸡蛋里面挑骨头？<br><br>task_infk的使用需要导入&lt;mach&#47;mach.h&gt; <br><br>最后一段意思是，系统通过malloc_logger来统计并管理内存的分配情况？","like_count":2,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446668,"discussion_content":"在你设置相同优先级的线程中，系统会有更细的优先级策略，这个策略就是哪个线程 CPU 占用高，优先级会比降低","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555123482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307448,"user_name":"D","can_delete":false,"product_type":"c1","uid":2681398,"ip_address":"","ucode":"4112DE94C80A5B","user_header":"https://static001.geekbang.org/account/avatar/00/28/ea/36/7d088c63.jpg","comment_is_top":false,"comment_ctime":1629106121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5924073417","product_id":100024501,"comment_content":"腾讯的OOMDetector就是干这个事的https:&#47;&#47;github.com&#47;Tencent&#47;OOMDetector","like_count":2},{"had_liked":false,"id":219955,"user_name":"will","can_delete":false,"product_type":"c1","uid":1457442,"ip_address":"","ucode":"93DC3993A50CBB","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/22/c6ff6e02.jpg","comment_is_top":false,"comment_ctime":1590125551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885092847","product_id":100024501,"comment_content":"监控内存分配的核心，在于使用libmalloc库的malloc_logger指针实现的","like_count":1},{"had_liked":false,"id":186560,"user_name":"Master","can_delete":false,"product_type":"c1","uid":1454833,"ip_address":"","ucode":"642F865923C98A","user_header":"https://static001.geekbang.org/account/avatar/00/16/32/f1/54575096.jpg","comment_is_top":false,"comment_ctime":1583882674,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5878849970","product_id":100024501,"comment_content":"有个疑问，就算 hook 了malloc_logger ，知晓了内存分配地址和大小，又如何知道是代码中哪块或者哪个对象申请的呢？望各位大佬不吝赐教！","like_count":2,"discussions":[{"author":{"id":2153689,"avatar":"https://static001.geekbang.org/account/avatar/00/20/dc/d9/129f569f.jpg","nickname":"forping","note":"","ucode":"7495E250F0A017","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340091,"discussion_content":"函数调用堆栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609901881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125877,"user_name":"RichardJ","can_delete":false,"product_type":"c1","uid":1460444,"ip_address":"","ucode":"24DC2494614DC1","user_header":"","comment_is_top":false,"comment_ctime":1566267021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5861234317","product_id":100024501,"comment_content":"小结里说到访问未分配内存、向只读内存进行写操作的问题，戴老师可以举些例子说明下这两种情况怎么排查原因吗？","like_count":1},{"had_liked":false,"id":85630,"user_name":"Calabash_Boy","can_delete":false,"product_type":"c1","uid":1453760,"ip_address":"","ucode":"19E4D819792983","user_header":"","comment_is_top":false,"comment_ctime":1555148573,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5850115869","product_id":100024501,"comment_content":"老师好,读完后有几个问题不得其解:<br>(1) 在相同的设备和系统版本下,每个App的内存限制是不一样的么?我查看了手机的jetsamEvent,在per-process-limit中发现一个rpages是196.<br>(2) 在vm_pressure_monitor线程的检测下,发现某App有了内存压力(理解为即将达到内存限制),然后会给该App发通知,然后您又讲到了优先级机制,这就有疑惑了,当某个App有压力的时候,是强杀这个App呢还是根据优先级去强杀后台的App呢?<br>(3) 在测试struct mach_task_basic_info info;这段代码的时候,编译会报错Definition of &#39;mach_task_basic_info&#39; must be imported from module &#39;Darwin.Mach.task_info&#39; before it is required,是我没有导入某个头文件么?","like_count":1,"discussions":[{"author":{"id":1409087,"avatar":"https://static001.geekbang.org/account/avatar/00/15/80/3f/bc65b009.jpg","nickname":"Yest","note":"","ucode":"1E82B6355890C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3416,"discussion_content":"(3) #include <Mach/task_info.h>","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564470044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85555,"user_name":"drunkenMouse","can_delete":false,"product_type":"c1","uid":1454037,"ip_address":"","ucode":"AA8CEA703ECBE8","user_header":"","comment_is_top":false,"comment_ctime":1555124038,"is_pvip":false,"replies":[{"id":"30747","content":"是在 didReceiveMemoryWarning 回调里去获取当前 App内存使用值","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555146892,"ip_address":"","comment_id":85555,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850091334","product_id":100024501,"comment_content":"didReceivedMemory 动态获取内存值的方法，没有找到啊 大佬能说一下吗？","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446712,"discussion_content":"是在 didReceiveMemoryWarning 回调里去获取当前 App内存使用值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555146892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85008,"user_name":"浩","can_delete":false,"product_type":"c1","uid":1338784,"ip_address":"","ucode":"B29FFC5B489C8C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/a0/75cdae30.jpg","comment_is_top":false,"comment_ctime":1554954919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849922215","product_id":100024501,"comment_content":"一直不知道内存分配最大值获取和怎么获取当前内存分配，看了文章豁然开朗，想问的是，老师这些知识都是通过分析源码得来的吗？","like_count":1},{"had_liked":false,"id":292352,"user_name":"...","can_delete":false,"product_type":"c1","uid":1020427,"ip_address":"","ucode":"35C881D8AA1C5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/0b/2ccf7908.jpg","comment_is_top":false,"comment_ctime":1620789661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620789661","product_id":100024501,"comment_content":"hook 内存分配的性能开销应该很大 这块线上环境怎么处理呢？","like_count":0},{"had_liked":false,"id":281827,"user_name":"天空很蓝","can_delete":false,"product_type":"c1","uid":1456247,"ip_address":"","ucode":"16B88BEDA8E24F","user_header":"https://static001.geekbang.org/account/avatar/00/16/38/77/5849fbcf.jpg","comment_is_top":false,"comment_ctime":1614915794,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1614915794","product_id":100024501,"comment_content":"出现OOM前一定会出现Memory Warning么？这个应该是不一定吧大佬；既然不一定的话那上面三种情况就都不能很好的获取到邻近OOM的时候内存的分配信息吧；还有其他更好的方式吗？还是我理解的有问题呢？麻烦知道的大佬解答一下谢谢！","like_count":1,"discussions":[{"author":{"id":2681398,"avatar":"https://static001.geekbang.org/account/avatar/00/28/ea/36/7d088c63.jpg","nickname":"D","note":"","ucode":"4112DE94C80A5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388983,"discussion_content":"确实不是不一定出现Memory Warning","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629083913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114159,"user_name":"夜空繁星","can_delete":false,"product_type":"c1","uid":1454291,"ip_address":"","ucode":"6DA00EDEE62FA4","user_header":"https://static001.geekbang.org/account/avatar/00/16/30/d3/b3516304.jpg","comment_is_top":false,"comment_ctime":1563244437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563244437","product_id":100024501,"comment_content":"除了膜拜，没别的。","like_count":0},{"had_liked":false,"id":107080,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1110113,"ip_address":"","ucode":"2D2E877CF97138","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg","comment_is_top":false,"comment_ctime":1561455025,"is_pvip":false,"replies":[{"id":"38772","content":"本文都是围绕这个问题在说呢。会根据系统和硬件不同而定","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1561472691,"ip_address":"","comment_id":107080,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561455025","product_id":100024501,"comment_content":"当系统还剩多少内存时，会发出内存不足的通知。","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455357,"discussion_content":"本文都是围绕这个问题在说呢。会根据系统和硬件不同而定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561472691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106978,"user_name":"亡命之徒","can_delete":false,"product_type":"c1","uid":1096669,"ip_address":"","ucode":"5B0ADD558F9712","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/dd/5d473145.jpg","comment_is_top":false,"comment_ctime":1561430843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561430843","product_id":100024501,"comment_content":"线上使用这种方式监控内存，苹果审核会通过嘛","like_count":0},{"had_liked":false,"id":100231,"user_name":"mersa","can_delete":false,"product_type":"c1","uid":1330156,"ip_address":"","ucode":"A9F0B2FF9457C9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epzwbJGbUmgEC77J6QY6A5pLPdPbw7sqk4DcsHK8qPw7OiaiaMD7pjzb8uHlkY5uLZRibWVvPDDAgM5A/132","comment_is_top":false,"comment_ctime":1559488071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559488071","product_id":100024501,"comment_content":"怎么知道谁调用了 malloc，来指导对应的堆栈信息","like_count":0},{"had_liked":false,"id":89395,"user_name":"二木又土","can_delete":false,"product_type":"c1","uid":1296963,"ip_address":"","ucode":"7D939045990B4D","user_header":"https://static001.geekbang.org/account/avatar/00/13/ca/43/63bdc516.jpg","comment_is_top":false,"comment_ctime":1556163316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556163316","product_id":100024501,"comment_content":"JetsamEvent文件中搜索rpages，为什么有很多值，不同app能使用的最大内存大小是不一样的？","like_count":0},{"had_liked":false,"id":85558,"user_name":"drunkenMouse","can_delete":false,"product_type":"c1","uid":1454037,"ip_address":"","ucode":"AA8CEA703ECBE8","user_header":"","comment_is_top":false,"comment_ctime":1555124337,"is_pvip":false,"replies":[{"id":"30746","content":"强杀前系统会根据文后的策略判断应该优先强杀谁","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555146794,"ip_address":"","comment_id":85558,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555124337","product_id":100024501,"comment_content":"系统在强杀App前，会先做优先级判断。意思是：如果优先级高的话，本来会强杀的也不强杀了，而去强杀那些没有达到limit的进程？","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446714,"discussion_content":"强杀前系统会根据文后的策略判断应该优先强杀谁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555146794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85352,"user_name":"Hy","can_delete":false,"product_type":"c1","uid":1239531,"ip_address":"","ucode":"BF6AC9AA9B26A7","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/eb/2394e520.jpg","comment_is_top":false,"comment_ctime":1555042123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555042123","product_id":100024501,"comment_content":"👌","like_count":0},{"had_liked":false,"id":85017,"user_name":"mαnajay","can_delete":false,"product_type":"c1","uid":1067450,"ip_address":"","ucode":"6DE9FBD1BEC8AD","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/ba/23c9246a.jpg","comment_is_top":false,"comment_ctime":1554956945,"is_pvip":false,"replies":[{"id":"30717","content":"OOM 是内存超标被系统强杀时","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555139256,"ip_address":"","comment_id":85017,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554956945","product_id":100024501,"comment_content":"hook malloc_logger aop收集日志，然后在OOM那6秒内收集所有内存分配信息，然后在再次启动应用时 上报这两部分日志吗？ <br>oom那一刻是指的哪个时机，接受内存警告？ didReceiveMemoryWarning 中判断 是否靠近 limit吗 ","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446531,"discussion_content":"OOM 是内存超标被系统强杀时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555139256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}