{"id":7810,"title":"第8讲 | 对比Vector、ArrayList、LinkedList有何区别？","content":"<p>我们在日常的工作中，能够高效地管理和操作数据是非常重要的。由于每个编程语言支持的数据结构不尽相同，比如我最早学习的C语言，需要自己实现很多基础数据结构，管理和操作会比较麻烦。相比之下，Java则要方便的多，针对通用场景的需求，Java提供了强大的集合框架，大大提高了开发者的生产力。</p>\n<p>今天我要问你的是有关集合框架方面的问题，<span class=\"orange\">对比Vector、ArrayList、LinkedList有何区别？</span></p>\n<h2>典型回答</h2>\n<p>这三者都是实现集合框架中的List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p>\n<p>Vector是Java早期提供的<strong>线程安全的动态数组</strong>，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</p>\n<p>ArrayList是应用更加广泛的<strong>动态数组</strong>实现，它本身不是线程安全的，所以性能要好很多。与Vector近似，ArrayList也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector在扩容时会提高1倍，而ArrayList则是增加50%。</p>\n<p>LinkedList顾名思义是Java提供的<strong>双向链表</strong>，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</p>\n<h2>考点分析</h2>\n<p>似乎从我接触Java开始，这个问题就一直是经典的面试题，前面我的回答覆盖了三者的一些基本的设计和实现。</p>\n<!-- [[[read_end]]] -->\n<p>一般来说，也可以补充一下不同容器类型适合的场景：</p>\n<ul>\n<li>\n<p>Vector和ArrayList作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。</p>\n</li>\n<li>\n<p>而LinkedList进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。</p>\n</li>\n</ul>\n<p>所以，在应用开发中，如果事先可以估计到，应用操作是偏向于插入、删除，还是随机访问较多，就可以针对性的进行选择。这也是面试最常见的一个考察角度，给定一个场景，选择适合的数据结构，所以对于这种典型选择一定要掌握清楚。</p>\n<p>考察Java集合框架，我觉得有很多方面需要掌握：</p>\n<ul>\n<li>\n<p>Java集合框架的设计结构，至少要有一个整体印象。</p>\n</li>\n<li>\n<p>Java提供的主要容器（集合和Map）类型，了解或掌握对应的<strong>数据结构、算法</strong>，思考具体技术选择。</p>\n</li>\n<li>\n<p>将问题扩展到性能、并发等领域。</p>\n</li>\n<li>\n<p>集合框架的演进与发展。</p>\n</li>\n</ul>\n<p>作为Java专栏，我会在尽量围绕Java相关进行扩展，否则光是罗列集合部分涉及的数据结构就要占用很大篇幅。这并不代表那些不重要，数据结构和算法是基本功，往往也是必考的点，有些公司甚至以考察这些方面而非常知名（甚至是“臭名昭著”）。我这里以需要掌握典型排序算法为例，你至少需要熟知：</p>\n<ul>\n<li>\n<p>内部排序，至少掌握基础算法如归并排序、交换排序（冒泡、快排）、选择排序、插入排序等。</p>\n</li>\n<li>\n<p>外部排序，掌握利用内存和外部存储处理超大数据集，至少要理解过程和思路。</p>\n</li>\n</ul>\n<p>考察算法不仅仅是如何简单实现，面试官往往会刨根问底，比如哪些是排序是不稳定的呢（快排、堆排），或者思考稳定意味着什么；对不同数据集，各种排序的最好或最差情况；从某个角度如何进一步优化（比如空间占用，假设业务场景需要最小辅助空间，这个角度堆排序就比归并优异）等，从简单的了解，到进一步的思考，面试官通常还会观察面试者处理问题和沟通时的思路。</p>\n<p>以上只是一个方面的例子，建议学习相关书籍，如《算法导论》《编程珠玑》等，或相关<a href=\"https://www.coursera.org/learn/algorithms-part1\">教程</a>。对于特定领域，比如推荐系统，建议咨询领域专家。单纯从面试的角度，很多朋友推荐使用一些算法网站如LeetCode等，帮助复习和准备面试，但坦白说我并没有刷过这些算法题，这也是仁者见仁智者见智的事情，招聘时我更倾向于考察面试者自身最擅长的东西，免得招到纯面试高手。</p>\n<h2>知识扩展</h2>\n<p>我们先一起来理解集合框架的整体设计，为了有个直观的印象，我画了一个简要的类图。注意，为了避免混淆，我这里没有把java.util.concurrent下面的线程安全容器添加进来；也没有列出Map容器，虽然通常概念上我们也会把Map作为集合框架的一部分，但是它本身并不是真正的集合（Collection）。</p>\n<p>所以，我今天主要围绕狭义的集合框架，其他都会在专栏后面的内容进行讲解。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/67/c7/675536edf1563b11ab7ead0def1215c7.png?wh=835*444\" alt=\"\" /></p>\n<p>我们可以看到Java的集合框架，Collection接口是所有集合的根，然后扩展开提供了三大类集合，分别是：</p>\n<ul>\n<li>\n<p>List，也就是我们前面介绍最多的有序集合，它提供了方便的访问、插入、删除等操作。</p>\n</li>\n<li>\n<p>Set，Set是不允许重复元素的，这是和List最明显的区别，也就是不存在两个对象equals返回true。我们在日常开发中有很多需要保证元素唯一性的场合。</p>\n</li>\n<li>\n<p>Queue/Deque，则是Java提供的标准队列结构的实现，除了集合的基本功能，它还支持类似先入先出（FIFO， First-in-First-Out）或者后入先出（LIFO，Last-In-First-Out）等特定行为。这里不包括BlockingQueue，因为通常是并发编程场合，所以被放置在并发包里。</p>\n</li>\n</ul>\n<p>每种集合的通用逻辑，都被抽象到相应的抽象类之中，比如AbstractList就集中了各种List操作的通用部分。这些集合不是完全孤立的，比如，LinkedList本身，既是List，也是Deque哦。</p>\n<p>如果阅读过更多<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/bf9177eac58d/src/java.base/share/classes/java/util/TreeSet.java\">源码</a>，你会发现，其实，TreeSet代码里实际默认是利用TreeMap实现的，Java类库创建了一个Dummy对象“PRESENT”作为value，然后所有插入的元素其实是以键的形式放入了TreeMap里面；同理，HashSet其实也是以HashMap为基础实现的，原来他们只是Map类的马甲！</p>\n<p>就像前面提到过的，我们需要对各种具体集合实现，至少了解基本特征和典型使用场景，以Set的几个实现为例：</p>\n<ul>\n<li>\n<p>TreeSet支持自然顺序访问，但是添加、删除、包含等操作要相对低效（log(n)时间）。</p>\n</li>\n<li>\n<p>HashSet则是利用哈希算法，理想情况下，如果哈希散列正常，可以提供常数时间的添加、删除、包含等操作，但是它不保证有序。</p>\n</li>\n<li>\n<p>LinkedHashSet，内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序遍历的能力，与此同时，也保证了常数时间的添加、删除、包含等操作，这些操作性能略低于HashSet，因为需要维护链表的开销。</p>\n</li>\n<li>\n<p>在遍历元素时，HashSet性能受自身容量影响，所以初始化时，除非有必要，不然不要将其背后的HashMap容量设置过大。而对于LinkedHashSet，由于其内部链表提供的方便，遍历性能只和元素多少有关系。</p>\n</li>\n</ul>\n<p>我今天介绍的这些集合类，都不是线程安全的，对于java.util.concurrent里面的线程安全容器，我在专栏后面会去介绍。但是，并不代表这些集合完全不能支持并发编程的场景，在Collections工具类中，提供了一系列的synchronized方法，比如</p>\n<pre><code>static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)\n</code></pre>\n<p>我们完全可以利用类似方法来实现基本的线程安全集合：</p>\n<pre><code>List list = Collections.synchronizedList(new ArrayList());\n</code></pre>\n<p>它的实现，基本就是将每个基本方法，比如get、set、add之类，都通过synchronized添加基本的同步支持，非常简单粗暴，但也非常实用。注意这些方法创建的线程安全集合，都符合迭代时fail-fast行为，当发生意外的并发修改时，尽早抛出ConcurrentModificationException异常，以避免不可预计的行为。</p>\n<p>另外一个经常会被考察到的问题，就是理解Java提供的默认排序算法，具体是什么排序方式以及设计思路等。</p>\n<p>这个问题本身就是有点陷阱的意味，因为需要区分是Arrays.sort()还是Collections.sort() （底层是调用Arrays.sort()）；什么数据类型；多大的数据集（太小的数据集，复杂排序是没必要的，Java会直接进行二分插入排序）等。</p>\n<ul>\n<li>\n<p>对于原始数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序，你可以阅读<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/util/DualPivotQuicksort.java\">源码</a>。</p>\n</li>\n<li>\n<p>而对于对象数据类型，目前则是使用<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/util/TimSort.java\">TimSort</a>，思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法。TimSort并不是Java的独创，简单说它的思路是查找数据集中已经排好序的分区（这里叫run），然后合并这些分区来达到排序的目的。</p>\n</li>\n</ul>\n<p>另外，Java 8引入了并行排序算法（直接使用parallelSort方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于fork-join框架（专栏后面会对fork-join进行相对详细的介绍），当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。</p>\n<p>排序算法仍然在不断改进，最近双轴快速排序实现的作者提交了一个更进一步的改进，历时多年的研究，目前正在审核和验证阶段。根据作者的性能测试对比，相比于基于归并排序的实现，新改进可以提高随机数据排序速度提高10%～20%，甚至在其他特征的数据集上也有几倍的提高，有兴趣的话你可以参考具体代码和介绍：<br />\n<a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-January/051000.html\">http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-January/051000.html</a> 。</p>\n<p>在Java 8之中，Java平台支持了Lambda和Stream，相应的Java集合框架也进行了大范围的增强，以支持类似为集合创建相应stream或者parallelStream的方法实现，我们可以非常方便的实现函数式代码。</p>\n<p>阅读Java源代码，你会发现，这些API的设计和实现比较独特，它们并不是实现在抽象类里面，而是以<strong>默认方法</strong>的形式实现在Collection这样的接口里！这是Java 8在语言层面的新特性，允许接口实现默认方法，理论上来说，我们原来实现在类似Collections这种工具类中的方法，大多可以转换到相应的接口上。针对这一点，我在面向对象主题，会专门梳理Java语言面向对象基本机制的演进。</p>\n<p>在Java 9中，Java标准类库提供了一系列的静态工厂方法，比如，List.of()、Set.of()，大大简化了构建小的容器实例的代码量。根据业界实践经验，我们发现相当一部分集合实例都是容量非常有限的，而且在生命周期中并不会进行修改。但是，在原有的Java类库中，我们可能不得不写成：</p>\n<pre><code>ArrayList&lt;String&gt;  list = new ArrayList&lt;&gt;();\nlist.add(&quot;Hello&quot;);\nlist.add(&quot;World&quot;);\n</code></pre>\n<p>而利用新的容器静态工厂方法，一句代码就够了，并且保证了不可变性。</p>\n<pre><code>List&lt;String&gt; simpleList = List.of(&quot;Hello&quot;,&quot;world&quot;);\n</code></pre>\n<p>更进一步，通过各种of静态工厂方法创建的实例，还应用了一些我们所谓的最佳实践，比如，它是不可变的，符合我们对线程安全的需求；它因为不需要考虑扩容，所以空间上更加紧凑等。</p>\n<p>如果我们去看of方法的源码，你还会发现一个特别有意思的地方：我们知道Java已经支持所谓的可变参数（varargs），但是官方类库还是提供了一系列特定参数长度的方法，看起来似乎非常不优雅，为什么呢？这其实是为了最优的性能，JVM在处理变长参数的时候会有明显的额外开销，如果你需要实现性能敏感的API，也可以进行参考。</p>\n<p>今天我从Verctor、ArrayList、LinkedList开始，逐步分析其设计实现区别、适合的应用场景等，并进一步对集合框架进行了简单的归纳，介绍了集合框架从基础算法到API设计实现的各种改进，希望能对你的日常开发和API设计能够有帮助。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？留一道思考题给你，先思考一个应用场景，比如你需要实现一个云计算任务调度系统，希望可以保证VIP客户的任务被优先处理，你可以利用哪些数据结构或者标准的集合类型呢？更进一步讲，类似场景大多是基于什么数据结构呢？</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n","comments":[{"had_liked":false,"id":9554,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":true,"comment_ctime":1526951366,"is_pvip":true,"replies":[{"id":"2956","content":"赞","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527008253,"ip_address":"","comment_id":9554,"utype":1}],"discussion_count":2,"race_medal":0,"score":"9.2233724893533e+18","product_id":100006701,"comment_content":"在这个题目下，自然就会想到优先级队列了，但还需要额外考虑vip再分级，即同等级vip的平权的问题，所以应该考虑除了直接的和vip等级相关的优先级队列优先级规则问题，还得考虑同等级多个客户互相不被单一客户大量任务阻塞的问题，数据结构确实是基础，即便这个思考题考虑的这个场景，待调度数据估计会放在redis里面吧","like_count":105,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418114,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527008253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63063,"discussion_content":"这个问题之前也遇到过，在下载队列中，除了通用队列意外，还会留有VIP队列，也会考虑某个VIP恶意占用的问题，不过数据结构确实很重要","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574866107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9594,"user_name":"孙晓刚","can_delete":false,"product_type":"c1","uid":1126276,"ip_address":"","ucode":"339D87B48AE2E9","user_header":"https://static001.geekbang.org/account/avatar/00/11/2f/84/62b4afaf.jpg","comment_is_top":true,"comment_ctime":1526975567,"is_pvip":false,"replies":[{"id":"2953","content":"嗯，我文中特意强调了不包括尾部","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527007534,"ip_address":"","comment_id":9594,"utype":1}],"discussion_count":5,"race_medal":0,"score":"9.2233722101803991e+18","product_id":100006701,"comment_content":"精选第一个对于读写效率问题，我觉得表述有问欠缺，或者说不能那么绝对。 <br>1、并不是所有的增删都会开辟新内存，没有开辟新内存的尾部增，效率也是杠杠的。<br>2、尾部删除也不需要开辟新内存，只是移出最后一个对象。<br>之前我也是接收了ArrayList的特性随机访问快，增删效率差。直到看到源码才知道，没那么绝对。<br>直接导致结果就是本身适合使用ArrayList的场景会因为这个笼统的说法而选LinkedList","like_count":40,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418130,"discussion_content":"嗯，我文中特意强调了不包括尾部","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527007534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030842,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ba/83de3488.jpg","nickname":"Carter","note":"","ucode":"1FD476D8F2BE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380227,"discussion_content":"任何时候都不用LinkedList","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624379790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542081,"avatar":"","nickname":"miaoch","note":"","ucode":"00CC7A3E21452D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389784,"discussion_content":"LinkedList增删快，是在已经持有这个引用的情况下。如果要按下标去删，那定位的时间就不如ArrayList了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629429672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1848364,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/34/2c/cd158db1.jpg","nickname":"小刘","note":"","ucode":"F50BCF1E9D285A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346139,"discussion_content":"感觉linkedlist越来越不被用在list里面了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611881393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215784,"discussion_content":"也许是因为。ArrayList 也在进化吧。。。\n所以，固有思想 可能不准确了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585383176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9723,"user_name":"L.B.Q.Y","can_delete":false,"product_type":"c1","uid":1069325,"ip_address":"","ucode":"5567989D1CDBBE","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/0d/14d9364a.jpg","comment_is_top":true,"comment_ctime":1527047339,"is_pvip":false,"replies":[{"id":"2987","content":"按照javadoc，我觉得这个方法设计目的，就是让调用者精确控制类型；里面声明了，toArray(new Object[0])等同于toArray()","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527051736,"ip_address":"","comment_id":9723,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.223372098511401e+18","product_id":100006701,"comment_content":"请教老师个问题，Collection接口的声明是带范型的，其中定义的Object[ ] toArray()方法为什么不是范型方式的？有什么原因吗？","like_count":14,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418179,"discussion_content":"按照javadoc，我觉得这个方法设计目的，就是让调用者精确控制类型；里面声明了，toArray(new Object[0])等同于toArray()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527051736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9534,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1526949085,"is_pvip":true,"discussion_count":9,"race_medal":0,"score":"1126808380637","product_id":100006701,"comment_content":"Vector、ArrayList、LinkedList均为线型的数据结构，但是从实现方式与应用场景中又存在差别。<br><br>1 底层实现方式<br>ArrayList内部用数组来实现；LinkedList内部采用双向链表实现；Vector内部用数组实现。<br><br>2 读写机制<br>ArrayList在执行插入元素是超过当前数组预定义的最大值时，数组需要扩容，扩容过程需要调用底层System.arraycopy()方法进行大量的数组复制操作；在删除元素时并不会减少数组的容量（如果需要缩小数组容量，可以调用trimToSize()方法）；在查找元素时要遍历数组，对于非null的元素采取equals的方式寻找。<br><br>LinkedList在插入元素时，须创建一个新的Entry对象，并更新相应元素的前后元素的引用；在查找元素时，需遍历链表；在删除元素时，要遍历链表，找到要删除的元素，然后从链表上将此元素删除即可。<br>Vector与ArrayList仅在插入元素时容量扩充机制不一致。对于Vector，默认创建一个大小为10的Object数组，并将capacityIncrement设置为0；当插入元素数组大小不够时，如果capacityIncrement大于0，则将Object数组的大小扩大为现有size+capacityIncrement；如果capacityIncrement&lt;=0,则将Object数组的大小扩大为现有大小的2倍。<br><br>3 读写效率<br><br>ArrayList对元素的增加和删除都会引起数组的内存分配空间动态发生变化。因此，对其进行插入和删除速度较慢，但检索速度很快。<br><br>LinkedList由于基于链表方式存放数据，增加和删除元素的速度较快，但是检索速度较慢。<br><br>4 线程安全性<br><br>ArrayList、LinkedList为非线程安全；Vector是基于synchronized实现的线程安全的ArrayList。<br><br>需要注意的是：单线程应尽量使用ArrayList，Vector因为同步会有性能损耗；即使在多线程环境下，我们可以利用Collections这个类中为我们提供的synchronizedList(List list)方法返回一个线程安全的同步列表对象。<br><br>问题回答<br><br>利用PriorityBlockingQueue或Disruptor可实现基于任务优先级为调度策略的执行调度系统。","like_count":263,"discussions":[{"author":{"id":1225820,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b4/5c/bfea5bf7.jpg","nickname":"哈神","note":"","ucode":"D3168E6E70CA44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51040,"discussion_content":"大佬的每次总结我觉得比老师还通俗易懂","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1573802940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215787,"discussion_content":"这里所谓的检索，指的是 根据下标，随机访问 某个元素（数组 可以通过 偏移直接计算出 对应元素的内存地址。）\n如果都是遍历，数组和链表  一样的性能","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1585383480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1563245,"avatar":"https://static001.geekbang.org/account/avatar/00/17/da/6d/7c8fdb14.jpg","nickname":"嗯。","note":"","ucode":"30FC6EF9A01070","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291888,"discussion_content":"极客时间应该请你讲课","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594987005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784292,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/39/e4/7a69cf88.jpg","nickname":"茹Winnie","note":"","ucode":"D349E55893C94F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154351,"discussion_content":"读完文章后感觉一团云，只知道作者提了不少概念出来，但是又没有解释太清楚，然后读到您的总结之后才感觉清晰了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580133907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2712589,"avatar":"https://static001.geekbang.org/account/avatar/00/29/64/0d/13a0d933.jpg","nickname":"Geek_93ebde","note":"","ucode":"EFDA0389B1422C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":1784292,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/39/e4/7a69cf88.jpg","nickname":"茹Winnie","note":"","ucode":"D349E55893C94F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581589,"discussion_content":"是的，一直让看源码，我要是能看懂源码就不来看面试题了。。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658863955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":154351,"ip_address":""},"score":581589,"extra":""}]},{"author":{"id":1110461,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f1/bd/049a06b0.jpg","nickname":"ziven","note":"","ucode":"D13AC3D2D27A6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357305,"discussion_content":"集合总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615782766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1505014,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f6/f6/9512c15f.jpg","nickname":"AntXiao","note":"","ucode":"9B1A4A0DAB4B44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304782,"discussion_content":"看文章必看评论，看评论必看课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599662260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2088059,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/FQQA0icGXUvJZicd7jX1r85KureDSfICkzc261GJmCXmGglBKu0icuf31d2ctyIH5oDY9mVwXeq0VBllloLiaEfWcw/132","nickname":"鹏鹏要努力","note":"","ucode":"CF9061D7C7C23D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295127,"discussion_content":"课代表厉害了������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596096808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234280,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/68/af1682f1.jpg","nickname":"jackLee","note":"","ucode":"720304AB76D9FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157906,"discussion_content":"课代表list总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580529839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9530,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1526948875,"is_pvip":false,"replies":[{"id":"2962","content":"有道理","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527010264,"ip_address":"","comment_id":9530,"utype":1}],"discussion_count":3,"race_medal":0,"score":"366599169035","product_id":100006701,"comment_content":"既然是Java的主题，那就用PriorityBlockingQueue吧。<br>如果是真实场景肯定会考虑高可用能持久化的方案。<br>其实我觉得应该参考银行窗口，同时三个窗口，就是三个队列，银台就是消费者线程，某一个窗口vip优先，没有vip时也为普通客户服务。要实现，要么有个dispatcher，要么保持vip通道不许普通进入，vip柜台闲时从其他队列偷","like_count":86,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418102,"discussion_content":"有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527010264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298119,"discussion_content":"VIP队列为普通用户服务，当vip任务来了，刚好还有普通任务没执行完呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597196951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1179740,"avatar":"https://static001.geekbang.org/account/avatar/00/12/00/5c/a44f998d.jpg","nickname":"Shane","note":"","ucode":"B9232FD9881881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326123,"discussion_content":"挂起，vip优先级高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605527413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298119,"ip_address":""},"score":326123,"extra":""}]}]},{"had_liked":false,"id":57545,"user_name":"linco_66","can_delete":false,"product_type":"c1","uid":1332200,"ip_address":"","ucode":"8C79B1605F7720","user_header":"https://static001.geekbang.org/account/avatar/00/14/53/e8/137a75f5.jpg","comment_is_top":false,"comment_ctime":1546831326,"is_pvip":false,"replies":[{"id":"23313","content":"非常不错的总结","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549806496,"ip_address":"","comment_id":57545,"utype":1}],"discussion_count":1,"race_medal":0,"score":"203410294238","product_id":100006701,"comment_content":"由于要处理的任务有前后顺序关系，所以首先想到使用优先队列。使用 PriorityQueue，将VIP用户的优先级设置为最高，优先处理。借鉴操作系统中的调度算法，对于其他用户，我们还可以设计各种公平的优先级选择算法（基于排队先后顺序，基于调度任务所需的时间长短（操作系统中的短作业优先算法）排序、高响应比（（所用时间+等待时间）&#47;等待时间）优先进行排序），与 PriorityQueue 结合使用。<br>类似场景大多就是基于队列的数据结构了。实际工具的话，消息队列（MQ）就是很直接的例子了。可以使用消息队列对用户请求进行削锋操作，前台快速响应，后台私下进行处理操作。<br>除此之外可以想到优化：利用分布式系统的优点，将VIP用户的请求分发到运算力更高的服务器上进行处理。达到高可用的特点！","like_count":48,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435636,"discussion_content":"非常不错的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549806496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40874,"user_name":"jackyz","can_delete":false,"product_type":"c1","uid":1194712,"ip_address":"","ucode":"12DB13FCF0C02F","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/d8/44023f1f.jpg","comment_is_top":false,"comment_ctime":1542686209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"169046410753","product_id":100006701,"comment_content":"集合：就像是一种容器。用于存储、获取、操作对象的容器。<br><br>1. 数组的弊端<br>①数组的长度不可变     ②数组没有提供可以查看有效元素个数的方法<br><br>2. 集合的特点<br>①集合的长度是可变的<br>②集合可以存储任意类型的对象<br>③集合只能存储对象<br><br>3. 集合框架<br>java.util.Collection : 集合层次的根接口<br>    |--- java.util.List: 有序的，可以重复的。<br>        |--- ArrayList: 采用数组结构存储元素。 查询操作多时选择<br>        |--- LinkedList: 采用链表结构存储元素。 增删操作多时选择<br>        |--- Vector:<br>    |--- java.util.Set: 无序的，不允许重复。<br>        |--- HashSet : 是 Set 接口的典型实现类。<br>            判断元素是否存在的依据是：先比较 hashCode 值，若 hashCode 存在，再通过 equals() 比较内容<br>                                     若 hashCode 值不存在，则直接存储<br><br>            注意：重写 hashCode 和 equals 二者需要保持一致！<br>            |--- LinkedHashSet: 相较于 HashSet 多了链表维护元素的顺序。遍历效率高于 HashSet ， 增删效率低于 HashSet<br>        |--- TreeSet : 拥有自己排序方式<br>            |-- 自然排序（Comparable）：<br>                ①需要添加 TreeSet 集合中对象的类实现  Comparable 接口<br>                ②实现 compareTo(Object o) 方法<br>            |-- 定制排序（Comparator）<br>                ①创建一个类实现 Comparator 接口<br>                ②实现 compare(Object o1, Object o2) 方法<br>                ③将该实现类的实例作为参数传递给 TreeSet 的构造器       ","like_count":39},{"had_liked":false,"id":10199,"user_name":"zjh","can_delete":false,"product_type":"c1","uid":1125747,"ip_address":"","ucode":"3AB3862247BEF9","user_header":"","comment_is_top":false,"comment_ctime":1527343531,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104606558635","product_id":100006701,"comment_content":"比较片面的说，java集合类底层基本上就是基于数组或者链表来实现的，数组的地址连续性决定了其随机存取速度较快，但是涉及到扩容则比较耗时，而链表则不存在扩容的性能消耗，但随机访问需要遍历地址因此相对数组要慢，所以判断一个集合的特点可以先判断是基于数组还是链表。","like_count":24},{"had_liked":false,"id":10364,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1527506799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65952016239","product_id":100006701,"comment_content":"今天看了一下PriorityQueue的源码，发现其是使用最小堆结构(二叉堆)，存放在数组中(数组索引对应树的从上到下，从左到右)。采用上面最小，每插入一个数据，就先与根节点比较，如果小于根节，依次换位置；大于根节点，就放在最后一个位置。","like_count":15},{"had_liked":false,"id":49621,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1544747582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40199453246","product_id":100006701,"comment_content":"深入到底层数据的存储基本绕不出数组和链表，要么依赖数组，要么依赖链表，要么数组和链表的结合。<br>其他语言估计类似，所以，看集合的底层实现基本就确定了它的特点，这是数据结构的本质决定的。另外，就是多线程的加持与否啦！<br>支持，则需加锁，加锁则影响性能，当然，不同的锁，还有不同的特点，比如：是否阻塞、是否可重入、锁是轻量级还是重量级。<br>这篇也需要反复读，加看源码！","like_count":9},{"had_liked":false,"id":185352,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1583566067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31648337139","product_id":100006701,"comment_content":"实现一个云计算任务调度系统，希望可以保证 VIP 客户的任务被优先处理，你可以利用哪些数据结构或者标准的集合类型呢？<br>优先级，第一个想到的就是PriorityQueue来实现，自定义权重比较， 优先处理VIP请求。<br>但是，会有一个问题，就是VIP请求如果过多，那么普通客户的请求就没法处理，一致等待。<br>改造：<br>利用不同的队列来保存不同的客户等级请求，然后用两个不同的线程池来处理请求：<br>第一个线程池只处理普通用户的请求<br>第二个线程池来处理VIP请求，如果没有VIP请求，则参与处理普通用户请求<br>也就是客户等级之间是平等的，也达到VIP优先处理，这个时候的队列不一定用PriorityQueue来实现，普通的队列也可以，或者普通的队列都可以。","like_count":7},{"had_liked":false,"id":87065,"user_name":"郑泽洲","can_delete":false,"product_type":"c1","uid":1447496,"ip_address":"","ucode":"EA1B540A040875","user_header":"https://static001.geekbang.org/account/avatar/00/16/16/48/01567df1.jpg","comment_is_top":false,"comment_ctime":1555506501,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27325310277","product_id":100006701,"comment_content":"杨老师，请教2个一直困扰我的问题：<br>1.ArrayList是继承了AbstractArrayList，其中AbstractArrayList已经实现了List接口，ArrayList自然隐含实现了List接口。可是为什么ArrayList还显式声明实现了List接口？<br>2. Arrays.asList返回的是List类型，其内部是Arrays.ArrayList为什么不直接用java.util.ArrayList<br>","like_count":6},{"had_liked":false,"id":30004,"user_name":"小笨蛋","can_delete":false,"product_type":"c1","uid":1118331,"ip_address":"","ucode":"7065FB157C4B70","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/7b/eed9d6d6.jpg","comment_is_top":false,"comment_ctime":1538622520,"is_pvip":true,"replies":[{"id":"12428","content":"例如，介绍项目过程中，随机问某些细节方面，可能就比较陌生，判断下是忘了还是就参与有限","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1540312095,"ip_address":"","comment_id":30004,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23013459000","product_id":100006701,"comment_content":"招聘时我更倾向于考察面试者自身最擅长的东西，免得招到纯面试高手?这个你一般会怎么面试？纯面试感受是一个什么样的表现？","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425809,"discussion_content":"例如，介绍项目过程中，随机问某些细节方面，可能就比较陌生，判断下是忘了还是就参与有限","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540312095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2579468,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIXSaPK9TbPulxWO4lyNnfSib3q282iclr590NiaxFjkx6rmheZnfNpsiaK8BRXfDTI5kT0otuPDiaoLpA/132","nickname":"Geek_84a4f9","note":"","ucode":"59971188B4C4E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411021,"discussion_content":"擅长的都写在简历上了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635831413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59974,"user_name":"马建超","can_delete":false,"product_type":"c1","uid":1359903,"ip_address":"","ucode":"6759B5C25B829F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK8hCUT5pssp9t18pzQVSvXUefMreLvRV7xgVpuWR1oBwLnncouQOWiaBCMZQobW5d1ibfZicflARYxQ/132","comment_is_top":false,"comment_ctime":1547434475,"is_pvip":false,"replies":[{"id":"23325","content":"加油","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549811866,"ip_address":"","comment_id":59974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18727303659","product_id":100006701,"comment_content":"每天看一集，不断提高自己，加油","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436428,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549811866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10118,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1527300917,"is_pvip":false,"replies":[{"id":"3241","content":"三个都是Collection，总还是有共同行为的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527481031,"ip_address":"","comment_id":10118,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18707170101","product_id":100006701,"comment_content":"杨老师，问个问题，Collection接口下面已细化了List,Set和Queue子接口，未什么又定义了AbstractCollection这个抽象类？具体是什么考虑？以为我发现3个接口的子类都是集成这个抽象类。","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418348,"discussion_content":"三个都是Collection，总还是有共同行为的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527481031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9677,"user_name":"呵呵","can_delete":false,"product_type":"c1","uid":1052862,"ip_address":"","ucode":"986CC73CFBBC67","user_header":"","comment_is_top":false,"comment_ctime":1527034989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18706904173","product_id":100006701,"comment_content":"阅读速度太快了","like_count":4},{"had_liked":false,"id":9519,"user_name":"王宁","can_delete":false,"product_type":"c1","uid":1048061,"ip_address":"","ucode":"4E6258270B7BE9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/fd/1e3d14ee.jpg","comment_is_top":false,"comment_ctime":1526947317,"is_pvip":true,"replies":[{"id":"2959","content":"下两篇就是","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527010111,"ip_address":"","comment_id":9519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18706816501","product_id":100006701,"comment_content":"面试的重点HashMap,实现原理，扩展什么的，1.7和1.8的区别。还有和hashtable的异同。还有juc下面集合的熟悉程度。<br>","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418097,"discussion_content":"下两篇就是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527010111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91178,"user_name":"码上Java","can_delete":false,"product_type":"c1","uid":1295726,"ip_address":"","ucode":"C616EC77DE6695","user_header":"https://static001.geekbang.org/account/avatar/00/13/c5/6e/82ef354b.jpg","comment_is_top":false,"comment_ctime":1556890159,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14441792047","product_id":100006701,"comment_content":"对比 Vector、ArrayList、LinkedList有何区别？<br>Vector是Java早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数据已满时，会创建新的数组，并拷贝原有数组数据。<br>ArrayList是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多，与Vector近似，ArrayList也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector在扩容时会提高1倍，而ArrayList则是增加50%。<br>LinkedList顾名思义是Java提供的双向链表，所以它不需要像上面那样调整容量，它也不是线程安全的。<br>-Vector和ArrrayList作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。<br>-而ArrayList进行结点插入、删除却要高效很多，但是随机访问性能则要比动态数组慢。<br>","like_count":3,"discussions":[{"author":{"id":1116106,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/ca/3feccf32.jpg","nickname":"Berton.Yip.","note":"","ucode":"DB6C45FD67CDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145985,"discussion_content":"哥们, 最后一句话应该是LinkedList , 你估计是打错了.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579592126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15375,"user_name":"且以深情共白头","can_delete":false,"product_type":"c1","uid":1113192,"ip_address":"","ucode":"812E00CD9413A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/68/9491468e.jpg","comment_is_top":false,"comment_ctime":1531147646,"is_pvip":false,"replies":[{"id":"5312","content":"和优先队列相比，不那么紧凑，例如treeset用的树比堆要多了节点开销","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1531321982,"ip_address":"","comment_id":15375,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10121082238","product_id":100006701,"comment_content":"之前一直以为Verctor不属于集合，只是数组。学习了。针对VIP客户任务优先处理场景，认为采用SortSet进行，按照默认排序即可，数值越小优先级越高，和线程的优先级级别一致","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420358,"discussion_content":"和优先队列相比，不那么紧凑，例如treeset用的树比堆要多了节点开销","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531321982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9575,"user_name":"我奋斗去了","can_delete":false,"product_type":"c1","uid":1017931,"ip_address":"","ucode":"C13918E425F595","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/4b/4fb10188.jpg","comment_is_top":false,"comment_ctime":1526954472,"is_pvip":false,"replies":[{"id":"2955","content":"为什么用两个队列，PriorityQueue不是有优先级了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527008202,"ip_address":"","comment_id":9575,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10116889064","product_id":100006701,"comment_content":"可以使用priority queue ，维护两个队列 一个VIP队列 一个普通用户队列 。当VIP队列有人的情况优先处理","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418121,"discussion_content":"为什么用两个队列，PriorityQueue不是有优先级了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527008202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9548,"user_name":"webwombat","can_delete":false,"product_type":"c1","uid":1122172,"ip_address":"","ucode":"64155832D53986","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/7c/f0e808b9.jpg","comment_is_top":false,"comment_ctime":1526950824,"is_pvip":false,"replies":[{"id":"2958","content":"yes，人家可能进一步提出更多场景继续考","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527008325,"ip_address":"","comment_id":9548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10116885416","product_id":100006701,"comment_content":"那个问题，应该是priority queue吧？操作系统的进程调度一般都是基于优先级队列来实现的。","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418111,"discussion_content":"yes，人家可能进一步提出更多场景继续考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527008325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235498,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":2063751,"ip_address":"","ucode":"7D63AC09AF79BA","user_header":"","comment_is_top":false,"comment_ctime":1595063510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890030806","product_id":100006701,"comment_content":"&quot;LinkedList 进行节点插入、删除却要高效得多&quot; 这个还真不一定，和数据多少有很大关系。主要是数据组扩容复制和list new一个对象索引插入这两者之间哪个效率高的一个判断。例如，容量大的时候一次数组扩容，就可以插入很多次，此时只需复制移动元素，而list每次都要new，前者效率高","like_count":1},{"had_liked":false,"id":87083,"user_name":"请叫我华仔","can_delete":false,"product_type":"c1","uid":1465300,"ip_address":"","ucode":"307D39B12CEF61","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/d4/f4a2888a.jpg","comment_is_top":false,"comment_ctime":1555509221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5850476517","product_id":100006701,"comment_content":"# 集合<br>Vector 线程安全的动态数组。<br>ArrayList 动态数组。扩容时复制原数组。随机访问效率高。<br>LinkedList 双向链表，插入删除效率高。<br><br>内部排序：归并，冒泡，快排，选择，插入<br>外部排序：借助外部存储排序<br><br>java集合框架：list set queue<br>java提供的默认排序算法：双轴快排，TimSort<br><br>思考题：优先级队列，操作系统就用了优先级队列。<br><br>","like_count":1},{"had_liked":false,"id":31661,"user_name":"要离刺荆轲","can_delete":false,"product_type":"c1","uid":1107380,"ip_address":"","ucode":"3405ED1580A19D","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/b4/a12edf06.jpg","comment_is_top":false,"comment_ctime":1539258171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834225467","product_id":100006701,"comment_content":"ArrayList和LinkedList在数据量比较大时，指定位置插入，不一定ArrayList慢，LinkedList插入时需要遍历位置。我实际实验过，你不能直说因为链表，插入就快","like_count":1},{"had_liked":false,"id":10345,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1527490368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5822457664","product_id":100006701,"comment_content":"杨老师，有个问题，TreeSet为什么不支持正序，只支持倒序(DescendingIteractor)？Tree本身支持正序列.","like_count":1},{"had_liked":false,"id":9802,"user_name":"Lawt","can_delete":false,"product_type":"c1","uid":1140033,"ip_address":"","ucode":"6F44A0C77F19AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/41/ffe48d0c.jpg","comment_is_top":false,"comment_ctime":1527095089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5822062385","product_id":100006701,"comment_content":"写得还挺不错的，担心36期能讲那么多没容吗？持续关注，相信您，期待","like_count":1},{"had_liked":false,"id":9559,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1038811,"ip_address":"","ucode":"BFAF83E23199DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d9/db/66d5b3f4.jpg","comment_is_top":false,"comment_ctime":1526952016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821919312","product_id":100006701,"comment_content":"使用优先级队列实现堆，可以根据优先级进行操作","like_count":1},{"had_liked":false,"id":9526,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1526948515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821915811","product_id":100006701,"comment_content":"使用优先级队列，按照任务按照优先级排好序，这样优先级高的任务被优先处理。","like_count":1},{"had_liked":false,"id":9518,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1526947249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821914545","product_id":100006701,"comment_content":"我觉得使用queue来实现VIP业务就行了，检查这个队列深度，大于0时就优先先处理。分布式环境下用MQ实现。","like_count":1},{"had_liked":false,"id":9516,"user_name":"王宁","can_delete":false,"product_type":"c1","uid":1048061,"ip_address":"","ucode":"4E6258270B7BE9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/fd/1e3d14ee.jpg","comment_is_top":false,"comment_ctime":1526946866,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5821914162","product_id":100006701,"comment_content":"面试重点HashMap，1.7和1.8然后还有hashtable,还有juc下面的集合","like_count":1},{"had_liked":false,"id":353149,"user_name":"| ~浑蛋~","can_delete":false,"product_type":"c1","uid":3024820,"ip_address":"广东","ucode":"B6904B44DFA805","user_header":"https://static001.geekbang.org/account/avatar/00/2e/27/b4/df65c0f7.jpg","comment_is_top":false,"comment_ctime":1659191442,"is_pvip":true,"discussion_count":0,"race_medal":3,"score":"1659191442","product_id":100006701,"comment_content":"linkedlist发明者在Twitter上说他从来不使用linkedlist","like_count":0},{"had_liked":false,"id":337372,"user_name":"枫林血舞","can_delete":false,"product_type":"c1","uid":2809867,"ip_address":"","ucode":"EE7F6DA78D21EA","user_header":"https://static001.geekbang.org/account/avatar/00/2a/e0/0b/6f667b2c.jpg","comment_is_top":false,"comment_ctime":1646793414,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646793414","product_id":100006701,"comment_content":"这题下意识的想到了优先队列，但是实现上我觉着redis的跳表也可以考虑一下。","like_count":0},{"had_liked":false,"id":293350,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1621347040,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1621347040","product_id":100006701,"comment_content":"我想到优先队列😂","like_count":0},{"had_liked":false,"id":288542,"user_name":"王晓敏diyai","can_delete":false,"product_type":"c1","uid":1018794,"ip_address":"","ucode":"864B640C6C2F27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/aa/a7909dc2.jpg","comment_is_top":false,"comment_ctime":1618533884,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618533884","product_id":100006701,"comment_content":"实际使用时，我会使用Redis的Zset数据类型，根据业务公式计算出分值","like_count":0},{"had_liked":false,"id":287810,"user_name":"Rorchachl","can_delete":false,"product_type":"c1","uid":1895320,"ip_address":"","ucode":"7AABFF65A0033C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/KiaBJsepm9fHHicfPxiahhR3RqRaR4QH6YFibIHV5o5VspTIXmH72iaiaotb4cRpWtRvLC7mnh5KH1KlSNLGWlI7wUicQ/132","comment_is_top":false,"comment_ctime":1618155539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618155539","product_id":100006701,"comment_content":"尾部插入 是什么意思  我觉得应该是指定位置插入  内部会有ArrayCopy的操作 所以性能会相对比较差","like_count":0},{"had_liked":false,"id":277423,"user_name":"麦苗","can_delete":false,"product_type":"c1","uid":2419335,"ip_address":"","ucode":"F3EE4592E2179B","user_header":"","comment_is_top":false,"comment_ctime":1612408986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612408986","product_id":100006701,"comment_content":"写的不错，我觉得还可以写的更系统点，辛苦作者","like_count":0},{"had_liked":false,"id":268826,"user_name":"acqierement","can_delete":false,"product_type":"c1","uid":1234980,"ip_address":"","ucode":"AC8DA74B9CB924","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/24/f48a38f4.jpg","comment_is_top":false,"comment_ctime":1608364174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608364174","product_id":100006701,"comment_content":"ArrayList：底层是一个object[]，采用的是延迟加载，只有第一次add原数时，才分配空间。扩容成原来的1.5倍。实现了RandomAccess接口，标识它支持随机访问。适用于查询较多，或者尾部插入的场景。不是线程安全的。<br>LinkedList: 底层是一个双向链表，查找，插入，删除都是对应的链表操作。适用于插入删除场景。不是线程安全的。<br>Vector: 底层也是数组，扩容是为原来的2倍。是线程安全的。","like_count":0},{"had_liked":false,"id":263613,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1606197995,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1606197995","product_id":100006701,"comment_content":"刚开始写 Java 代码的时候，其实我就有奇怪，vector 和数组有什么区别，“线程安全的动态数组”，还是挺高大上大的。<br><br>ArrayList 和 LinkedList 感觉从名字上就能推断出来，一个类似数组（动态数组，不是线程安全的，容量自增），一个类似链表（双向链表，不是线程安全的）。<br><br>Collection 接口是所有集合的根，三大类集合：List、Set、Queue&#47;Deque","like_count":0},{"had_liked":false,"id":238850,"user_name":"吴备","can_delete":false,"product_type":"c1","uid":1865356,"ip_address":"","ucode":"47808627279AB8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL3UicUedUgydoiadXuOFaOpIhOicrMbGUBEGBRkbbQibgVgRTYEIP4QFCzeicaRO8Br8icnvzic1ic1tUR8Q/132","comment_is_top":false,"comment_ctime":1596342313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596342313","product_id":100006701,"comment_content":"请问删除ArrayList数组中间的元素，数组是如何重组的？直接移动位置，还是System.arrayCopy?","like_count":0},{"had_liked":false,"id":207072,"user_name":"mickey","can_delete":false,"product_type":"c1","uid":1051663,"ip_address":"","ucode":"8B490C2DDE4010","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg","comment_is_top":false,"comment_ctime":1587002774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587002774","product_id":100006701,"comment_content":"设计一个可从两头插入和读取的队列","like_count":0},{"had_liked":false,"id":151250,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1573691648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573691648","product_id":100006701,"comment_content":"8 Vector，ArrayList，LinkedList 区别 三者都是实现集合框架的List，都提供了定位，删除和增加的方法，都提供了迭代器遍历集合的方法，8.1 Vector是线程安全的对象数组，如果内存不够，会动态扩容，ArrayList是动态数组实现，不是线程安全的，也是会自动扩容，Vector会扩容一倍，ArrayList会扩容50%，内存中连续存储，LinkedList是java提供的双向链表，不需要扩容 8.2 Vector和ArrayList适合随机访问，插入和删除除了数据头和尾，都比较麻烦，LinkedList删除和增加因为不需要扩容，性能比较高，随机访问的效率低，8.3 狭义的集合框架 Collection是所有集合的根，下面有三大类List，Set不允许重复的集合，Queue提供了先进先出的结构，TreeSet支持随机访问，但删除，增加性能比较差 HashSet随机访问，增加和删除比较快，但不保证顺序，LinkedHashSet内部记录了一个插入顺序的双向链表，增加和删除是常量开销，性能低于HashSet，因为要维护链表的开销 8.4 这些集合类都不是线程安全的，如果要线程安全，Collections.synchronizedList(new ArrayList())，内部实现是将add delete等方法加上synchronized关键字","like_count":0},{"had_liked":false,"id":145975,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1211713,"ip_address":"","ucode":"E3AD8BF42E19DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/41/3c5b770b.jpg","comment_is_top":false,"comment_ctime":1572410215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572410215","product_id":100006701,"comment_content":"打卡！","like_count":0},{"had_liked":false,"id":145486,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1572296057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572296057","product_id":100006701,"comment_content":"思考题，用户按照优先级排序，应该选用优先队列。","like_count":0},{"had_liked":false,"id":145485,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1572295981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572295981","product_id":100006701,"comment_content":"现在响应式的编程多了，vector之类的线程安全类反而用的少了。","like_count":0},{"had_liked":false,"id":98116,"user_name":"大象佩奇","can_delete":false,"product_type":"c1","uid":1070165,"ip_address":"","ucode":"EAFB4FA3B9CFEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/55/f686c2ed.jpg","comment_is_top":false,"comment_ctime":1558917432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558917432","product_id":100006701,"comment_content":"第一时间考虑的是优先队列，但如果仅仅是针对题目的要求，直接多个FIFO的队列就可以，优先队列每次插入都需要O(lg(n))，而队列是O(1)。不过感觉这道题和操作系统的任务调度挺像，可以参考搞一下","like_count":0},{"had_liked":false,"id":92780,"user_name":"PoL","can_delete":false,"product_type":"c1","uid":1416147,"ip_address":"","ucode":"72BA3C2D50D463","user_header":"https://static001.geekbang.org/account/avatar/00/15/9b/d3/41d04923.jpg","comment_is_top":false,"comment_ctime":1557324971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557324971","product_id":100006701,"comment_content":"集合 LinkedList 基于双链表实现的，Vector Arraylist 基于数组，<br>Vector是线程安全，会有性能开销<br>Arraylist 可以转换成线程安全Cellections.synchronizedList（）<br>Linkedlist add delete 较快，查询效率低点， ArrayList 查询较快，非尾部增删效率低","like_count":0},{"had_liked":false,"id":90000,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1556361584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556361584","product_id":100006701,"comment_content":"我也想到优先队列了， 没看评论哦～","like_count":0},{"had_liked":false,"id":86874,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1555468988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555468988","product_id":100006701,"comment_content":"那为何List.of()要设计成不可变的形式呢？设计成普通的list岂不是更好？<br>这个和int[]转List，感觉并没有很大进步？","like_count":0},{"had_liked":false,"id":83195,"user_name":"李春恒","can_delete":false,"product_type":"c1","uid":1033066,"ip_address":"","ucode":"F2DCA19EC66DC1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c3/6a/3272e095.jpg","comment_is_top":false,"comment_ctime":1554456313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554456313","product_id":100006701,"comment_content":"Arrays.asList()<br>List.of()<br>","like_count":0},{"had_liked":false,"id":81298,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1553852326,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553852326","product_id":100006701,"comment_content":"不是很理解有的同学提到用MQ  MQ虽然异步操作强大，但是先进先出很难完成vip优先啊，数据结构的话就是优先队列了，只是比较简单粗暴，可以设定具体的调度算法，可以参看os的调度算法，","like_count":0},{"had_liked":false,"id":77391,"user_name":"Lh","can_delete":false,"product_type":"c1","uid":1102951,"ip_address":"","ucode":"19CA4286A49DB7","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/67/0eaa81a4.jpg","comment_is_top":false,"comment_ctime":1552917691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552917691","product_id":100006701,"comment_content":"Vector、ArrayList、LinkedList均为线型的数据结构，但是从实现方式与应用场景中又存在差别。<br><br>1 底层实现方式<br>ArrayList内部用数组来实现；LinkedList内部采用双向链表实现；Vector内部用数组实现。<br><br>2 读写机制<br>ArrayList在执行插入元素是超过当前数组预定义的最大值时，数组需要扩容，扩容过程需要调用底层System.arraycopy()方法进行大量的数组复制操作；在删除元素时并不会减少数组的容量（如果需要缩小数组容量，可以调用trimToSize()方法）；在查找元素时要遍历数组，对于非null的元素采取equals的方式寻找。<br><br>LinkedList在插入元素时，须创建一个新的Entry对象，并更新相应元素的前后元素的引用；在查找元素时，需遍历链表；在删除元素时，要遍历链表，找到要删除的元素，然后从链表上将此元素删除即可。<br>Vector与ArrayList仅在插入元素时容量扩充机制不一致。对于Vector，默认创建一个大小为10的Object数组，并将capacityIncrement设置为0；当插入元素数组大小不够时，如果capacityIncrement大于0，则将Object数组的大小扩大为现有size+capacityIncrement；如果capacityIncrement&lt;=0,则将Object数组的大小扩大为现有大小的2倍。<br><br>3 读写效率<br><br>ArrayList对元素的增加和删除都会引起数组的内存分配空间动态发生变化。因此，对其进行插入和删除速度较慢，但检索速度很快。<br><br>LinkedList由于基于链表方式存放数据，增加和删除元素的速度较快，但是检索速度较慢。<br><br>4 线程安全性<br><br>ArrayList、LinkedList为非线程安全；Vector是基于synchronized实现的线程安全的ArrayList。<br><br>需要注意的是：单线程应尽量使用ArrayList，Vector因为同步会有性能损耗；即使在多线程环境下，我们可以利用Collections这个类中为我们提供的synchronizedList(List list)方法返回一个线程安全的同步列表对象。<br><br>问题回答<br><br>利用PriorityBlockingQueue或Disruptor可实现基于任务优先级为调度策略的执行调度系统。","like_count":0},{"had_liked":false,"id":63536,"user_name":"听风","can_delete":false,"product_type":"c1","uid":1065845,"ip_address":"","ucode":"29C71A605FE12A","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/75/7057e997.jpg","comment_is_top":false,"comment_ctime":1548395001,"is_pvip":false,"replies":[{"id":"23360","content":"谢谢反馈","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549821260,"ip_address":"","comment_id":63536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548395001","product_id":100006701,"comment_content":"讲这种东西其实我很想知道它的内部结构以及在内存中的结构","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437625,"discussion_content":"谢谢反馈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549821260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55217,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1546067664,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1546067664","product_id":100006701,"comment_content":"Linklist 不是 数组➕链表么？<br>","like_count":0},{"had_liked":false,"id":47654,"user_name":"Geek_fb3db2","can_delete":false,"product_type":"c1","uid":1218254,"ip_address":"","ucode":"8089B8311B6C80","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/ce/8c3bdbe5.jpg","comment_is_top":false,"comment_ctime":1544172999,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544172999","product_id":100006701,"comment_content":"因为提到了优先级，那应该是要用到优先队列了","like_count":0},{"had_liked":false,"id":23557,"user_name":"yutian1012","can_delete":false,"product_type":"c1","uid":1112460,"ip_address":"","ucode":"BD02ABBE0CF98B","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/8c/15d7be4e.jpg","comment_is_top":false,"comment_ctime":1536484544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536484544","product_id":100006701,"comment_content":"杨老师你好，查看list接口代码时，发现接口中重复定义了collection接口的很多方法，为什么这样做，直接继承过来，定义自己的扩展方法就可以了。这么做有什么特殊的意义吗？","like_count":0},{"had_liked":false,"id":19380,"user_name":"July","can_delete":false,"product_type":"c1","uid":1005384,"ip_address":"","ucode":"553873BE26CDA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/48/3da605c6.jpg","comment_is_top":false,"comment_ctime":1533796761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533796761","product_id":100006701,"comment_content":"老师好，集合框架图是根据最新的jdk画的吗？jdk1.8里List extends Collection 虚线箭头是implements ，实线箭头是extends，按照jdk1.8，有几个画反了...","like_count":0},{"had_liked":false,"id":17847,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1532996845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532996845","product_id":100006701,"comment_content":"mark<br><br>利用优先队列PriorityQueue或Disruptor可实现基于任务优先级为调度策略的执行调度系统。<br><br>","like_count":0},{"had_liked":false,"id":16611,"user_name":"鲁班大师","can_delete":false,"product_type":"c1","uid":1179156,"ip_address":"","ucode":"4F9615DF87B031","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/14/f1532dec.jpg","comment_is_top":false,"comment_ctime":1532051585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532051585","product_id":100006701,"comment_content":"关于linkedlist,get和remove都会先调用entry方法,那为什么remove性能要好于get呢","like_count":0},{"had_liked":false,"id":14376,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1162307,"ip_address":"","ucode":"0E0D44ABB35DBB","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/43/11acdc02.jpg","comment_is_top":false,"comment_ctime":1530342641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530342641","product_id":100006701,"comment_content":"多级反馈队列","like_count":0},{"had_liked":false,"id":10378,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1527512916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527512916","product_id":100006701,"comment_content":"再问个问题，为什么ArrayDeque类中的存储对象Object数组，数组的长度必须是2的n次方。","like_count":0},{"had_liked":false,"id":9912,"user_name":"L.B.Q.Y","can_delete":false,"product_type":"c1","uid":1069325,"ip_address":"","ucode":"5567989D1CDBBE","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/0d/14d9364a.jpg","comment_is_top":false,"comment_ctime":1527156655,"is_pvip":false,"replies":[{"id":"3089","content":"感谢指出，已经记录下来去修正一下","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527197004,"ip_address":"","comment_id":9912,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527156655","product_id":100006701,"comment_content":"集合框架的那张图，SortedSet应该是接口，图里面画成类了，TreeSet看起来有两个父类了。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418250,"discussion_content":"感谢指出，已经记录下来去修正一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527197004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9759,"user_name":"悬崖丶","can_delete":false,"product_type":"c1","uid":1107471,"ip_address":"","ucode":"DF750C832723C3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/0f/470c6487.jpg","comment_is_top":false,"comment_ctime":1527072475,"is_pvip":false,"replies":[{"id":"3014","content":"覆盖（override），面向对象多态的基本方面","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527108608,"ip_address":"","comment_id":9759,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527072475","product_id":100006701,"comment_content":"想问一个小白问题，List接口继承了Collection接口，为什么List接口还要重写一遍Collection接口中的一些方法","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418197,"discussion_content":"覆盖（override），面向对象多态的基本方面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527108608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9755,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1527069880,"is_pvip":false,"replies":[{"id":"3012","content":"下一篇就是","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527104570,"ip_address":"","comment_id":9755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527069880","product_id":100006701,"comment_content":"最近学习过程中，感觉看原代码比较吃力。一个Hash Map没有看明白，这么对Key的Set赋值，这么对value的Collection赋值。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418194,"discussion_content":"下一篇就是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527104570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}