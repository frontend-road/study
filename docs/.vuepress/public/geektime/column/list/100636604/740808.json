{"id":740808,"title":"第 8 章 crate 与模块(2)","content":"<h2 id=\"nav_point_142\">8.6　测试与文档</h2>\n<p>正如 2.3 节所述，Rust 中内置了一个简单的单元测试框架。测试是标有 <code>#[test]</code> 属性的普通函数：</p>\n<pre class=\"code-rows\"><code>#[test]\nfn math_works() {\n    let x: i32 = 1;\n    assert!(x.is_positive());\n    assert_eq!(x + 1, 2);\n}</code></pre>\n<p><code>cargo test</code> 会运行项目中的所有测试：</p>\n<pre class=\"code-rows\"><code>$ cargo test\n   Compiling math_test v0.1.0 (file:///.../math_test)\n     Running target/release/math_test-e31ed91ae51ebf22\n\nrunning 1 test\ntest math_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</code></pre>\n<p>（你还会看到一些关于“文档测试”的输出，我们稍后会讲到。）</p>\n<p>无论你的 crate 是可执行文件还是库，你都可以通过将参数传给 Cargo 来运行特定测试：<code>cargo test math</code> 会运行名称中包含 <code>math</code> 的所有测试。</p>\n<p>测试通常会使用 <code>assert!</code> 和 <code>assert_eq!</code> 这两个来自 Rust 标准库的宏。如果 <code>expr</code> 为真，那么 <code>assert!(expr)</code> 就会成功；否则，它会 panic，导致测试失败。<code>assert_eq!(v1, v2)</code> 和 <code>assert!(v1 == v2)</code> 基本等效，但当断言失败时，其错误消息会展示两个值。</p>\n<p>你可以在普通代码中使用这些宏来检查不变条件，但请注意 <code>assert!</code> 和 <code>assert_eq!</code> 会包含在发布构建中。因此，可以改用 <code>debug_assert!</code> 和 <code>debug_assert_eq!</code> 来编写仅在调试构建中检查的断言。</p>\n<p>要测试各种出错情况，请将 <code>#[should_panic]</code> 属性添加到你的测试中：</p>\n<pre class=\"code-rows\"><code>/// 正如我们在第7章中所讲的那样，只有当除以零导致panic时，这个测试才能通过\n#[test]\n#[allow(unconditional_panic, unused_must_use)]\n#[should_panic(expected=\"divide by zero\")]\nfn test_divide_by_zero_error() {\n    1 / 0;  // 应该panic！\n}</code></pre>\n<p>在这个例子中，还需要添加一个 <code>allow</code> 属性，以让编译器允许我们做一些它本可以静态证明而无法触发 panic 的事情，然后才能执行除法并丢弃答案，因为在正常情况下，它会试图阻止这种愚蠢行为。</p>\n<p>还可以从测试中返回 <code>Result&lt;(), E&gt;</code>。只要错误变体实现了 <code>Debug</code> 特型（通常都实现了），你就可以简单地使用 <code>?</code> 抛弃 <code>Ok</code> 变体以返回 <code>Result</code>：</p>\n<pre class=\"code-rows\"><code>use std::num::ParseIntError;\n\n/// 如果\"1024\"是一个有效的数值（这里正是如此），那么本测试就会通过\n#[test]\nfn explicit_radix() -&gt; Result&lt;(), ParseIntError&gt; {\n  i32::from_str_radix(\"1024\", 10)?;\n  Ok(())\n}</code></pre>\n<p>标有 <code>#[test]</code> 的函数是有条件编译的。普通的 <code>cargo build</code> 或 <code>cargo build --release</code> 会跳过测试代码。但是当你运行 <code>cargo test</code> 时，Cargo 会分两次来构建你的程序：一次以普通方式，一次带着你的测试和已启用的测试工具。这意味着你的单元测试可以与它们所测试的代码一起使用，按需访问内部实现细节，而且没有运行期成本。但是，这可能会导致一些警告。</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code>fn roughly_equal(a: f64, b: f64) -&gt; bool {\n    (a - b).abs() &lt; 1e-6\n}\n\n#[test]\nfn trig_works() {\n    use std::f64::consts::PI;\n    assert!(roughly_equal(PI.sin(), 0.0));\n}</code></pre>\n<p>在省略了测试代码的构建中，<code>roughly_equal</code> 似乎从未使用过，于是 Rust 会报错：</p>\n<pre class=\"code-rows\"><code>$ cargo build\n   Compiling math_test v0.1.0 (file:///.../math_test)\nwarning: function is never used: `roughly_equal`\n  |\n7 | / fn roughly_equal(a: f64, b: f64) -&gt; bool {\n8 | |     (a - b).abs() &lt; 1e-6\n9 | | }\n  | |_^\n  |\n   = note: #[warn(dead_code)] on by default</code></pre>\n<p>因此，当你的测试变得很庞大以至于需要支撑性代码时，应该按照惯例将它们放在 <code>tests</code> 模块中，并使用 <code>#[cfg]</code> 属性声明整个模块仅用于测试：</p>\n<pre class=\"code-rows\"><code>#[cfg(test)]   // 只有在测试时才包含此模块\nmod tests {\n    fn roughly_equal(a: f64, b: f64) -&gt; bool {\n        (a - b).abs() &lt; 1e-6\n    }\n\n    #[test]\n    fn trig_works() {\n        use std::f64::consts::PI;\n        assert!(roughly_equal(PI.sin(), 0.0));\n    }\n}</code></pre>\n<p>Rust 的测试工具会使用多个线程同时运行好几个测试，这是 Rust 代码默认线程安全的附带好处之一。要禁用此功能，请运行单个测试 <code>cargo test <i>testname</i></code> 或运行 <code>cargo test -- --test-threads 1</code>。（第一个 <code>--</code> 确保 <code>cargo test</code> 将 <code>--test-threads</code> 选项透传给实际执行测试的可执行文件。）这意味着，从严格意义上说，我们在第 2 章中展示的曼德博程序不是该章中第二个而是第三个多线程程序。2.3 节的 <code>cargo test</code> 运行的才是第一个多线程程序。</p>\n<p>通常，测试工具只会显示失败测试的输出。如果也想展示成功测试的输出，请运行 <code>cargo test -- --nocapture</code>。</p>\n<h3 id=\"nav_point_143\">8.6.1　集成测试</h3>\n<p>你的蕨类植物模拟器继续“成长”。你已决定将所有主要功能放入可供多个可执行文件使用的库中。如果能从最终使用者的视角编写一些测试，把 fern_sim.rlib 像外部 crate 那样链接进来，那仿真度就更高了。此外，你有一些测试是通过从二进制文件加载已保存的模拟记录开始的，同时把这些大型测试文件放在 src 目录中会很棘手。集成测试有助于解决这两个问题。</p>\n<p>集成测试是 .rs 文件，位于项目的 src 目录旁边的 tests 目录中。当你运行 <code>cargo test</code> 时，Cargo 会将每个集成测试编译为一个独立的 crate，与你的库和 Rust 测试工具链接在一起。下面是一个例子：</p>\n<pre class=\"code-rows\"><code>// tests/unfurl.rs——蕨菜在阳光下舒展开\n\nuse fern_sim::Terrarium;\nuse std::time::Duration;\n\n#[test]\nfn test_fiddlehead_unfurling() {\n    let mut world = Terrarium::load(\"tests/unfurl_files/fiddlehead.tm\");\n    assert!(world.fern(0).is_furled());\n    let one_hour = Duration::from_secs(60 * 60);\n    world.apply_sunlight(one_hour);\n    assert!(world.fern(0).is_fully_unfurled());\n}</code></pre>\n<p>集成测试之所以有价值，部分原因在于它们会从外部视角看待你的 crate，就像用户的做法一样。集成测试会测试你的 crate 的公共 API。</p>\n<p><code>cargo test</code> 会运行单元测试和集成测试。如果仅运行某个特定文件（如 tests/unfurl.rs）中的集成测试，请使用命令 <code>cargo test --test unfurl</code>。</p>\n<h3 id=\"nav_point_144\">8.6.2　文档</h3>\n<p>命令 <code>cargo doc</code> 会为你的库创建 HTML 文档：</p>\n<pre class=\"code-rows\"><code>$ cargo doc --no-deps --open\n Documenting fern_sim v0.1.0 (file:///.../fern_sim)</code></pre>\n<p><code>--no-deps</code> 选项会要求 Cargo 只为 <code>fern_sim</code> 本身生成文档，而不会为它依赖的所有 crate 生成文档。</p>\n<p><code>--open</code> 选项会要求 Cargo 随后在浏览器中打开此文档。</p>\n<p>你可以在图 8-2 中看到结果。Cargo 会将这个新文档文件保存在 target/doc 中。起始页是 target/doc/fern_sim/index.html。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00846.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8-2：<code>rustdoc</code> 生成的文档示例</strong></p>\n<p>该文档是根据你库中的 <code>pub</code> 特性以及附加的所有<strong>文档型注释</strong>生成的。我们已经在本章中看到了一些文档型注释。它们看起来很像注释：</p>\n<pre class=\"code-rows\"><code>/// 模拟减数分裂产生孢子\npub fn produce_spore(factory: &amp;mut Sporangium) -&gt; Spore {\n    ...\n}</code></pre>\n<p>但是当 Rust 看到以 3 个斜杠开头的注释时，会将它们视为 <code>#[doc]</code> 属性。如下代码的效果和 Rust 处理前面那个例子的效果完全一样：</p>\n<pre class=\"code-rows\"><code>#[doc = \"模拟减数分裂产生孢子。\"]\npub fn produce_spore(factory: &amp;mut Sporangium) -&gt; Spore {\n    ...\n}</code></pre>\n<p>当你编译一个库或二进制文件时，这些属性不会改变任何东西，但是当你生成文档时，关于公共特性的文档型注释会包含在其输出中。</p>\n<p>同样，以 <code>//!</code> 开头的注释会被视为 <code>#![doc]</code> 属性并附着到封闭块一级的特性（通常是模块或 crate）上。例如，你的 fern_sim/src/lib.rs 文件可能从这句话开始：</p>\n<pre class=\"code-rows\"><code>//! 模拟蕨类植物从单个细胞开始的生长过程</code></pre>\n<p>文档型注释的内容是 Markdown 格式的，这是一种等效于简单 HTML 格式的简写法。星号用于表示 <code>*</code>斜体<code>*</code> 和 <code>**</code>粗体<code>**</code>，空行用于表示分段符，等等。你还可以使用 HTML 标记，这些标记会原样复制到格式化后的文档中。</p>\n<p>Rust 中文档型注释的一大特色是，Markdown 链接中可以使用 Rust 语法项路径（如 <code>leaves::Leaf</code>），而不是相对 URL，来指示它们所指的内容。Cargo 会查找路径所指的内容，并在相应的文档页面中将其替换为正确的链接。例如，从如下代码生成的文档会链接到 <code>VascularPath</code>、<code>Leaf</code> 和 <code>Root</code> 的文档页面：</p>\n<pre class=\"code-rows\"><code>/// 创建并返回一个[`VascularPath`]，它表示从给定的[`Root`][r]到\n/// 给定的[`Leaf`](leaves::Leaf)之间的营养路径\n///\n/// [r]: roots::Root\npub fn trace_path(leaf: &amp;leaves::Leaf, root: &amp;roots::Root) -&gt; VascularPath {\n    ...\n}</code></pre>\n<p>你还可以添加搜索别名，以便使用内置搜索功能更轻松地查找内容。在此 crate 的文档中搜索“<code>path</code>”或“<code>route</code>”都能找到 <code>VascularPath</code>：</p>\n<pre class=\"code-rows\"><code>#[doc(alias = \"route\")]\npub struct VascularPath {\n    ...\n}</code></pre>\n<p>为了处理较长的文档块或者简化工作流，还可以在文档中包含外部文件。如果存储库的 README.md 文件中包含与准备用作 crate 的顶层文档相同的文本，那么可以将下面这句话放在 lib.rs 或 main.rs 的顶部：</p>\n<pre class=\"code-rows\"><code>#![doc = include_str!(\"../README.md\")]</code></pre>\n<p>你可以使用反引号（<code>`</code>）来标出文本中的少量代码。在输出中，这些片段会格式化为等宽字体。还可以通过“4 空格缩进”来添加更大的代码示例：</p>\n<pre class=\"code-rows\"><code>/// 文档型注释里的代码块：\n///\n///     if samples::everything().works() {\n///         println!(\"ok\");\n///     }</code></pre>\n<p>也可以使用 Markdown 的三重反引号（<code>```</code>）来标记代码块。效果完全一样：</p>\n<pre>\n/// 另一种代码片段，代码一样，但写法不同：\n///\n/// ```\n/// if samples::everything().works() {\n///     println!(\"ok\");\n/// }\n/// ```\n</pre>\n\n<p>无论使用哪种格式，当你在文档型注释里包含一段代码时，都会发生一些有意思的事。Rust 会自动将它转成一个测试。</p>\n<h3 id=\"nav_point_145\">8.6.3　文档测试</h3>\n<p>当你在 Rust 库 crate 中运行测试时，Rust 会检查文档中出现的所有代码是否真能如预期般工作。为此，Rust 会获取文档型注释中出现的每个代码块，然后将其编译为单独的可执行包，再与你的库链接在一起，最后运行。</p>\n<p>这是一个独立的文档测试示例。通过运行 <code>cargo new --lib ranges</code> 创建一个新项目（<code>--lib</code> 标志告诉 Cargo 我们正在创建一个库 crate，而不是一个可执行 crate）并将以下代码放入 ranges/src/lib.rs 中：</p>\n<pre class=\"code-rows\"><code>use std::ops::Range;\n\n/// 如果两个范围重叠，就返回true\n///\n///     assert_eq!(ranges::overlap(0..7, 3..10), true);\n///     assert_eq!(ranges::overlap(1..5, 101..105), false);\n///\n/// 如果任何一个范围为空，则它们不会被看作是重叠的\n///\n///     assert_eq!(ranges::overlap(0..0, 0..10), false);\n///\npub fn overlap(r1: Range&lt;usize&gt;, r2: Range&lt;usize&gt;) -&gt; bool {\n    r1.start &lt; r1.end &amp;&amp; r2.start &lt; r2.end &amp;&amp;\n        r1.start &lt; r2.end &amp;&amp; r2.start &lt; r1.end\n}</code></pre>\n<p>文档型注释中的这两小段代码会出现在 <code>cargo doc</code> 生成的文档中，如图 8-3 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00847.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8-3：展示一些文档测试的文档</strong></p>\n<p>它们也会成为两个独立的测试：</p>\n<pre class=\"code-rows\"><code>$ cargo test\n   Compiling ranges v0.1.0 (file:///.../ranges)\n...\n   Doc-tests ranges\n\nrunning 2 tests\ntest overlap_0 ... ok\ntest overlap_1 ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</code></pre>\n<p>如果将 <code>--verbose</code> 标志传给 Cargo，你会看到它正在使用 <code>rustdoc --test</code> 运行这两个测试。<code>rustdoc</code> 会将每个代码示例存储在一个单独的文件中，并给它们添加几行样板代码，以生成两个程序。这是第一个：</p>\n<pre class=\"code-rows\"><code>use ranges;\nfn main() {\n    assert_eq!(ranges::overlap(0..7, 3..10), true);\n    assert_eq!(ranges::overlap(1..5, 101..105), false);\n}</code></pre>\n<p>这是第二个：</p>\n<pre class=\"code-rows\"><code>use ranges;\nfn main() {\n    assert_eq!(ranges::overlap(0..0, 0..10), false);\n}</code></pre>\n<p>如果这些程序能成功编译并运行，则测试通过。</p>\n<p>这两个代码示例都包含一些断言，但这只是因为在这种情况下，断言构成了不错的文档。文档测试背后的理念并不是将所有测试都放入注释中。相反，你应该编写尽可能好的文档，Rust 只会帮你确保文档中的代码示例能实际编译和运行。</p>\n<p>通常，哪怕一个最小的工作示例都会包含一些细节，像导入或设置代码这样的细节是编译代码所必需的，只是还没重要到值得在文档中展示。要隐藏代码示例中的一行，请在该行的开头放置一个 <code>#</code>，后跟一个空格：</p>\n<pre class=\"code-rows\"><code>/// 让阳光照进来，并运行模拟器一段时间\n///\n///     # use fern_sim::Terrarium;\n///     # use std::time::Duration;\n///     # let mut tm = Terrarium::new();\n///     tm.apply_sunlight(Duration::from_secs(60));\n///\npub fn apply_sunlight(&amp;mut self, time: Duration) {\n    ...\n}</code></pre>\n<p>有时在文档中展示完整的示例程序（包含 <code>main</code> 函数）会很有帮助。显然，如果这些代码片段出现在代码示例中，你也不希望 <code>rustdoc</code> 自动添加包装代码，因为那样会导致编译无法通过。因此，<code>rustdoc</code> 会将所有精确包含字符串 <code>fn main</code> 的代码块视为一个完整的程序，不向其中添加任何代码。</p>\n<p>可以针对特定的代码块禁用测试。要告诉 Rust 编译你的示例，但不实际运行它，请使用带有 <code>no_run</code> 注释的多行代码块：</p>\n<pre>\n/// 将本地玻璃栽培箱的所有照片上传到在线画廊\n///\n/// ```no_run\n/// let mut session = fern_sim::connect();\n/// session.upload_all();\n/// ```\npub fn upload_all(&amp;mut self) {\n    ...\n}\n</pre>\n\n<p>如果代码甚至都不希望编译，请改用 <code>ignore</code> 而不是 <code>no_run</code>。标记为 <code>ignore</code> 的块不会出现在 <code>cargo run</code> 的输出中，但 <code>no_run</code> 测试如果编译了就会显示为已通过。如果代码块根本不是 Rust 代码，请使用语言的名称，比如 <code>c++</code> 或 <code>sh</code>，或用 <code>text</code> 表示纯文本。<code>rustdoc</code> 并不了解数百种编程语言的名称，相反，它将任何自己无法识别的注解都理解为该代码块不是 Rust。这会禁用代码的高亮显示和文档测试功能。</p>\n<h2 id=\"nav_point_146\">8.7　指定依赖项</h2>\n<p>前面我们看到过告诉 Cargo 从哪里获取项目所依赖的 crate 源代码的一种方法：通过版本号。</p>\n<pre class=\"code-rows\"><code>image = \"0.6.1\"</code></pre>\n<p>还有几种指定依赖项的方法，以及一些关于要使用哪个版本的微妙细节，因此值得在这上面花一些时间来讲一下。</p>\n<p>首先，你可能想要使用根本没发布在 crates.io 上的依赖项。一种方法是指定 Git 存储库 URL 和修订号：</p>\n<pre class=\"code-rows\"><code>image = { git = \"https://github.com/Piston/image.git\", rev = \"528f19c\" }</code></pre>\n<p>这个特定的 crate 是开源的，托管在 GitHub 上，但你也可以轻松地指向托管在公司内网上的私有 Git 存储库。如上述代码所示，你可以指定要使用的特定版本（<code>rev</code>）、标签（<code>tag</code>）或分支名（<code>branch</code>）。（这些都是告诉 Git 要检出哪个源代码版本的方法。）</p>\n<p>另一种方法是指定一个包含 crate 源代码的目录：</p>\n<pre class=\"code-rows\"><code>image = { path = \"vendor/image\" }</code></pre>\n<p>如果你的团队有个做版本控制的单一存储库，而且其中包含多个 crate 的源代码，或者可能包含整个依赖图，那么这种方法就很方便。每个 crate 都可以使用相对路径指定其依赖项。</p>\n<p>对依赖项进行这种层级的控制是一项非常强大的特性。如果你要使用的任何开源 crate 都不完全符合你的喜好，那么可以简单地对其进行分叉：只需点击 GitHub 上的 Fork 按钮并更改 Cargo.toml 文件中的一行即可。你的下一次 <code>cargo build</code> 将自然使用此 crate 的分叉版本而非官方版本。</p>\n<h3 id=\"nav_point_147\">8.7.1　版本</h3>\n<p>当你在 Cargo.toml 文件中写入类似 <code>image = \"0.13.0\"</code> 这样的内容时，Cargo 会相当宽松地理解它。它会使用自认为与版本 0.13.0 兼容的最新版本的 <code>image</code>。</p>\n<p>这些兼容性规则改编自语义化版本规范。</p>\n<ul>\n<li>以 0.0 开头的版本号还非常原始，所以 Cargo 永远不会假定它能与任何其他版本兼容。</li>\n<li>以 0.<em>x</em>（<em>x</em> 不为 0）开头的版本号，可认为与 0.<em>x</em> 系列的版本兼容。前面我们指定了 <code>image</code> 版本为 0.6.1，但如果可用，则 Cargo 会使用 0.6.3。（这跟语义化版本规范所说的 0.<em>x</em> 版本号规则不太一样，但事实证明这条规则太有用了，不能遗漏。）</li>\n<li>一旦项目达到 1.0，只有出现新的主版本号时才会破坏兼容性。因此，如果你要求版本为 2.0.1，那么 Cargo 可能会使用 2.17.99，但不会使用 3.0。</li>\n</ul>\n<p>默认情况下版本号是灵活的，否则使用哪个版本的问题很快就会变成过度的束缚。假设一个库 <code>libA</code> 使用 <code>num = \"0.1.31\"</code>，而另一个库 <code>libB</code> 使用 <code>num = \"0.1.29\"</code>。如果版本号需要完全匹配，则没有项目能够同时使用这两个库。允许 Cargo 使用任何兼容版本是一个更实用的默认设定。</p>\n<p>不过，不同的项目在依赖性和版本控制方面有不同的需求。你可以使用一些运算符来指定确切的版本或版本范围，如表 8-3 所示。</p>\n<p><strong>表 8-3：在 Cargo.toml 文件中指定版本</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>Cargo.toml 行</p></th>\n<th><p>含义</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>image = \"=0.10.0\"</code></p></td>\n<td><p>仅使用确切的版本 0.10.0</p></td>\n</tr>\n<tr>\n<td><p><code>image = \"&gt;=1.0.5\"</code></p></td>\n<td><p>使用 1.0.5 或更高版本（甚至 2.9，如果其可用的话）</p></td>\n</tr>\n<tr>\n<td><p><code>image = \"&gt;1.0.5 &lt;1.1.9\"</code></p></td>\n<td><p>使用高于 1.0.5 但低于 1.1.9 的版本</p></td>\n</tr>\n<tr>\n<td><p><code>image = \"&lt;=2.7.10\"</code></p></td>\n<td><p>使用 2.7.10 或更早的任何版本</p></td>\n</tr>\n</tbody>\n</table>\n<p>你偶尔会看到的另一种版本规范是使用通配符 <code>*</code>。它会告诉 Cargo 任何版本都可以。除非其他 Cargo.toml 文件包含更具体的约束，否则 Cargo 将使用最新的可用版本。doc.crates.io 上的 Cargo 文档更详细地介绍了这些版本规范。</p>\n<p>请注意，兼容性规则意味着不能纯粹出于营销目的而选择版本号。这实际上意味着它们是 crate 的维护者与其用户之间的契约。如果你维护一个版本为 1.7 的 crate，并且决定移除一个函数或进行任何其他不完全向后兼容的更改，则必须将版本号提高到 2.0。如果你将其称为 1.8，就相当于声称这个新版本与 1.7 兼容，而用户可能会发现构建失败了。</p>\n<h3 id=\"nav_point_148\">8.7.2　Cargo.lock</h3>\n<p>Cargo.toml 中的版本号是刻意保持灵活的，但我们不希望每次构建 Cargo 时都将其升级到最新的库版本。想象一下，当你正处于紧张的调试过程中时，<code>cargo build</code> 突然升级到了新版本的库。这可能带来难以估量的破坏性。调试过程中引入的任何变数都是坏事。事实上，对库而言，从来就没有什么好的时机进行意料之外的改变。</p>\n<p>因此，Cargo 有一种内置机制来防止发生这种情况。当第一次构建项目时，Cargo 会输出一个 Cargo.lock 文件，以记录它使用的每个 crate 的确切版本。以后的构建都将参考此文件并继续使用相同的版本。仅当你要求 Cargo 升级时它才会升级到更新版本，方法是手动增加 Cargo.toml 文件中的版本号或运行 <code>cargo update</code>：</p>\n<pre class=\"code-rows\"><code>$ cargo update\n    Updating registry `https://github.com/rust-lang/crates.io-index`\n    Updating libc v0.2.7 -&gt; v0.2.11\n    Updating png v0.4.2 -&gt; v0.4.3</code></pre>\n<p><code>cargo update</code> 只会升级到与你在 Cargo.toml 中指定的内容兼容的最新版本。如果你指定了 <code>image = \"0.6.1\"</code>，并且想要升级到版本 0.10.0，则必须自己在 Cargo.toml 中进行更改。下次构建时，Cargo 会将 <code>image</code> 库更新到这个新版本并将新版本号存储在 Cargo.lock 中。</p>\n<p>前面的示例展示 Cargo 更新了托管在 crates.io 上的两个 crate。存储在 Git 中的依赖项会发生非常相似的情况。假设 Cargo.toml 文件包含以下内容：</p>\n<pre class=\"code-rows\"><code>image = { git = \"https://github.com/Piston/image.git\", branch = \"master\" }</code></pre>\n<p>如果 <code>cargo build</code> 发现我们有一个 Cargo.lock 文件，那么它将不会从 Git 存储库中拉取新的更改。相反，它会读取 Cargo.lock 并使用与上次相同的修订版。但是 <code>cargo update</code> 会重新从 <code>master</code> 中拉取，以便我们的下一个构建使用最新版本。</p>\n<p>Cargo.lock 是自动生成的，通常不用手动编辑。不过，如果此项目是可执行文件，那你就应该将 Cargo.lock 提交到版本控制。这样，构建项目的每个人总是会获得相同的版本。Cargo.lock 文件的版本历史中会记录这些依赖项更新。</p>\n<p>如果你的项目是一个普通的 Rust 库，请不要费心提交 Cargo.lock。你的库的下游用户拥有包含其整个依赖图版本信息的 Cargo.lock 文件，他们将忽略这个库的 Cargo.lock 文件。在极少数情况下，你的项目是一个共享库（比如输出是 .dll 文件、.dylib 文件或 .so 文件），它没有这样的下游 <code>cargo</code> 用户，这时候就应该提交 Cargo.lock。</p>\n<p>Cargo.toml 灵活的版本说明符使你可以轻松地在项目中使用 Rust 库，并最大限度地提高库之间的兼容性。Cargo.lock 中的这些详尽记录可以支持跨机器的一致且可重现的构建。它们会共同帮你避开“依赖地狱”的问题。</p>\n<h2 id=\"nav_point_149\">8.8　将 crate 发布到 crates.io</h2>\n<p>如果你已决定将这个蕨类植物模拟库作为开源软件发布，那么，恭喜！这部分很简单。</p>\n<p>首先，确保 Cargo 可以为你打包 crate。</p>\n<pre class=\"code-rows\"><code>$ cargo package\nwarning: manifest has no description, license, license-file, documentation,\nhomepage or repository. See http://doc.crates.io/manifest.html#package-metadata\nfor more info.\n   Packaging fern_sim v0.1.0 (file:///.../fern_sim)\n   Verifying fern_sim v0.1.0 (file:///.../fern_sim)\n   Compiling fern_sim v0.1.0 (file:///.../fern_sim/target/package/fern_sim-0.1.0)</code></pre>\n<p><code>cargo package</code> 命令会创建一个文件（在本例中为 target/package/fern_sim-0.1.0.crate），其中包含所有库的源文件（包括 Cargo.toml）。这是你要上传到 crates.io 以便与全世界分享的文件。（可以使用 <code>cargo package --list</code> 来查看包含哪些文件。）然后 Cargo 会像最终用户一样，从 .crate 文件构建这个库，以仔细检查其工作。</p>\n<p>Cargo 会警告 Cargo.toml 的 <code>[package]</code> 部分缺少一些对下游用户很重要的信息，比如你分发代码所依据的许可证。警告中给出的 URL 是一个很好的资源，因此我们不会在这里详细解释所有字段。简而言之，你可以通过向 Cargo.toml 添加几行代码来修复此警告。</p>\n<pre class=\"code-rows\"><code>[package]\nname = \"fern_sim\"\nversion = \"0.1.0\"\nedition = \"2021\"\nauthors = [\"You &lt;you@example.com&gt;\"]\nlicense = \"MIT\"\nhomepage = \"https://fernsim.example.com/\"\nrepository = \"https://gitlair.com/sporeador/fern_sim\"\ndocumentation = \"http://fernsim.example.com/docs\"\ndescription = \"\"\"\nFern simulation, from the cellular level up.\n\"\"\"</code></pre>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00808.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　一旦在 crates.io 上发布了这个 crate，任何下载你的 crate 的人都能看到此 Cargo.toml 文件。因此，如果 <code>authors</code> 字段包含你希望保密的电子邮件地址，那么现在是更改它的时候了。</p>\n</blockquote>\n<p>这个阶段有时会出现的另一个问题是你的 Cargo.toml 文件可能通过 <code>path</code> 指定其他 crate 的位置，如 8.7 节所示：</p>\n<pre class=\"code-rows\"><code>image = { path = \"vendor/image\" }</code></pre>\n<p>对你和你的团队来说，这可能没什么问题。但当其他人下载 <code>fern_sim</code> 库时，他们的计算机上可能不会有与你一样的文件和目录。因此，Cargo 会<strong>忽略</strong>自动下载的库中的 <code>path</code> 键，而这可能会导致构建错误。解决方案一目了然：如果你的库要发布在 crates.io 上，那么它的依赖项也应该在 crates.io 上。应该指定版本号而不是 <code>path</code>：</p>\n<pre class=\"code-rows\"><code>image = \"0.13.0\"</code></pre>\n<p>如果你愿意，可以同时指定一个 <code>path</code>（供你自己在本地构建时优先使用）和一个 <code>version</code>（供所有其他用户使用）：</p>\n<pre class=\"code-rows\"><code>image = { path = \"vendor/image\", version = \"0.13.0\" }</code></pre>\n<p>当然，在这种情况下，你有责任确保两者保持同步。</p>\n<p>最后，在发布 crate 之前，你需要登录 crates.io 并获取 API 密钥。这一步很简单：一旦你在 crates.io 上有了账户，其“账户设置”页面就会展示一条 <code>cargo login</code> 命令，就像这样：</p>\n<pre class=\"code-rows\"><code>$ cargo login 5j0dV54BjlXBpUUbfIj7G9DvNl1vsWW1</code></pre>\n<p>Cargo 会把密钥保存在配置文件中，API 密钥应该像密码一样保密。因此，你应该只在自己控制的计算机上运行此命令。</p>\n<p>这些都完成后，最后一步是运行 <code>cargo publish</code>：</p>\n<pre class=\"code-rows\"><code>$ cargo publish\n    Updating registry `https://github.com/rust-lang/crates.io-index`\n   Uploading fern_sim v0.1.0 (file:///.../fern_sim)</code></pre>\n<p>做完这一步，你的库就成为 crates.io 中成千上万个库中的一员了。</p>\n<h2 id=\"nav_point_150\">8.9　工作空间</h2>\n<p>随着项目不断“成长”，你最终会写出很多 crate。它们并存于同一个源代码存储库中：</p>\n<pre class=\"code-rows\"><code>fernsoft/\n├── .git/...\n├── fern_sim/\n│   ├── Cargo.toml\n│   ├── Cargo.lock\n│   ├── src/...\n│   └── target/...\n├── fern_img/\n│   ├── Cargo.toml\n│   ├── Cargo.lock\n│   ├── src/...\n│   └── target/...\n└── fern_video/\n    ├── Cargo.toml\n    ├── Cargo.lock\n    ├── src/...\n    └── target/...</code></pre>\n<p>Cargo 的工作方式是，每个 crate 都有自己的构建目录 <code>target</code>，其中包含该 crate 的所有依赖项的单独构建。这些构建目录是完全独立的。即使两个 crate 具有共同的依赖项，它们也不能共享任何已编译的代码。这好像有点儿浪费。</p>\n<p>你可以使用 Cargo 工作空间来节省编译时间和磁盘空间。Cargo <strong>工作空间</strong>是一组 crate，它们共享着公共构建目录和 Cargo.lock 文件。</p>\n<p>你需要做的就是在存储库的根目录中创建一个 Cargo.toml 文件，并将下面这两行代码放入其中：</p>\n<pre class=\"code-rows\"><code>[workspace]\nmembers = [\"fern_sim\", \"fern_img\", \"fern_video\"]</code></pre>\n<p>这里的 <code>fern_sim</code> 等是那些包含你的 crate 的子目录名。这些子目录中所有残存的 Cargo.lock 文件和 target 目录都需要删除。</p>\n<p>完成此操作后，任何 crate 中的 <code>cargo build</code> 都会自动在根目录（在本例中为 fernsoft/target）下创建和使用共享构建目录。命令 <code>cargo build --workspace</code> 会构建当前工作空间中的所有 crate。<code>cargo test</code> 和 <code>cargo doc</code> 也能接受 <code>--workspace</code> 选项。</p>\n<h2 id=\"nav_point_151\">8.10　更多好资源</h2>\n<p>如果你仍然意犹未尽，Rust 社区还准备了一些你可能感兴趣的资源。</p>\n<ul>\n<li>当你在 crates.io 上发布一个开源 crate 时，你的文档会自动渲染并托管在 docs.rs 上，这要归功于 Onur Aslan。</li>\n<li><p>如果你的项目在 GitHub 上，那么 Travis CI 可以在每次推送时构建和测试你的代码。设置起来非常容易，有关详细信息，请参阅 travis-ci.org。如果你已经熟悉 Travis，则可以从下面这个 .travis.yml 文件开始。</p>\n<pre class=\"code-rows\"><code>language: rust\nrust:\n  - stable</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p>你可以从 crate 的顶层文档型注释生成 README.md 文件。此特性是由 Livio Ribeiro 作为第三方 Cargo 插件提供的。运行 <code>cargo install cargo-readme</code> 来安装此插件，然后运行 <code>cargo readme --help</code> 来学习如何使用它。</p>\n</li>\n</ul>\n<p>我们将继续前行。</p>\n<p>虽然 Rust 是一门新语言，但它旨在支持大型、雄心勃勃的项目。它有很棒的工具和活跃的社区。系统程序员<strong>也能</strong>享受美好。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 8 章 crate 与模块(1)","id":740807},"right":{"article_title":"第 9 章 结构体","id":740809}},"comments":[]}