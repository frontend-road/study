{"id":522346,"title":"37｜RESTful Web Services（1）：明确架构愿景与架构组件间的交互","content":"<p>你好，我是徐昊。从今天开始，我们就来使用TDD的方式实现RESTful Web Services。</p><p>在上节课，我们展示了需要完成的几大功能块。我们很容易可以发现，RESTful Web Services需要多模块协同完成。而不是像DI Container那样，可以从单一模块入手，在完成几个功能之后再进行重构。</p><p>那么我们可以先简单地规划一下架构愿景（Architecture Vision），以简化后续的工作。</p><h2>规划架构愿景</h2><p>首先，我们需要明确的是，我们将以Servlet的方式来实现RESTful Web Services框架。也就是说，我们将提供一个Servlet作为主入口，在其中完成对资源对象（Resources）的派分，并根据不同的超媒体选择对应的reader和writer进行输入输出处理。大致结构如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/6e/f531cdc180da287d25244d5ea711f36e.jpg?wh=8000x4500\" alt=\"\"></p><p>然而仅仅如此，还不足以让我们顺滑地进入伦敦学派的流程（如果你足够自信，已经可以开始经典学派TDD了），我们需要进一步细化ResourceServlet中的组件与交互：</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/b2/fe218e684cba33a63fa004c76f1ea3b2.jpg?wh=7493x3969\" alt=\"\"></p><p>如上图所示，为大致的组件划分：</p><ul>\n<li>ResourceDispatcher管理所有的Root Resource，并根据Root Resource的标注形成路由表。它可以根据路由表，生产对应的ResourceLocator。</li>\n<li>ResourceLocator表示与URI中某一段相匹配的资源方法（Resource Method），并负责调用它。</li>\n<li>ResourceContext表示Resource上下文，包含所有可注入的组件（通过@Context标注）。</li>\n<li>BodyReader聚合了所有的MessageBodyReader，可以根据所需的类型，从HttpServletRequest中读取对象。</li>\n<li>BodyWriter聚合了所有的MessageBodyWriter，可根据提供的类型，将信息写回到HttpServletResponse中。</li>\n<li>ExceptionMapping聚合了所有的ExceptionMapper，可根据提供的异常，将信息写回到HttpServletResponse中。</li>\n</ul><!-- [[[read_end]]] --><p>在构想中，这些组件所对应的交互可能是这样的：</p><ol>\n<li>Serlvet容器调用ResourceServlet的service方法，并提供HttpServletRequest和HttpServletResponse。</li>\n<li>ResourceServlet调用ResourceDispatcher，将所有的Root Resource注册到ResourceDispatcher上。</li>\n<li>ResourceServlet调用ResourceDispatcher的方法，根据URI查找路由表，生成对应的ReosurceLocator方法。</li>\n<li>ResourceServlet调用ResourceLocator，并提供ResourceContext、BodyReader、BodyWriter和ExceptionMapping。</li>\n<li>ResourceLocator根据Resource Class的需要，从ResourceContext中寻找可注入的组件。初始化Resource对象，并完成注入。</li>\n<li>ResourceLocator根据Resource Method的需要，使用BodyReader从HttpServletRequest中读取信息。</li>\n<li>ResourceLocator调用Resource Method，并通过BodyWriter将结果写回HttpServletResponse中。</li>\n<li>如果有异常，则使用ExceptionMapping将结果写回HttpServletResponse中。</li>\n</ol><p>如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/99/fd/99aa8f2a4d53e96eefb16a3a6c1cd3fd.jpg?wh=8000x4500\" alt=\"\"></p><p>那么至此我们是否可以开始任务分解了呢？还不行。请回想一下<a href=\"https://time.geekbang.org/column/article/496702\">伦敦学派的流程</a>：</p><ul>\n<li>按照功能需求与架构愿景划分对象的角色和职责；</li>\n<li>根据角色与职责，明确对象之间的交互；</li>\n<li>按照调用栈（Call Stack）的顺序，自外向内依次实现不同的对象；</li>\n<li>在实现的过程中，依照交互关系，使用测试替身替换所有与被实现对象直接关联的对象；</li>\n<li>直到所有对象全部实现完成。</li>\n</ul><p>所以我们还需要明确对象（架构组件）之间的交互，明确到<strong>有清晰的调用栈顺序，足以支撑我们使用测试替身构造测试</strong>。</p><h2>明确架构组件间的交互</h2><p>明确架构组件间的交互有三种方法：根据经验设计，通过<a href=\"https://time.geekbang.org/column/article/496702\">经典模式</a>进行定向重构，以及Spike。</p><p>根据经验设计永远是一种<strong>可能的选项</strong>，不过我总觉得这是更难的一种方法（也更为不靠谱）。通过经典模式进行定向重构有个额外的好处，它可以看作是对于<strong>架构愿景的验证</strong>：通过一组典型场景测试，验证架构的<strong>可行性</strong><strong>；</strong>然后在重构过程中，<strong>根据愿景</strong>提炼组件间的交互。具体过程和前一个项目差不多，这里可留给你们自己练习。</p><p>Spike是另一种常用的方法，特别是对遗存代码或需求上下文不够熟悉，不能直接进入经典模式的情况下，经常采用的模式：</p><p><video poster=\"https://media001.geekbang.org/f9864d56e873483b8dca27ea3f3022af/snapshots/d45cf0c023db4514a785e459f2f4bf88-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/1be7e90e-18112dc3a3e-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/1079aa69b71140468c0266eb9e74fd5f/bc0c3290e8cd4268a4510c4f227b75fb-04cc3bf80a6d4319e597e6132d3e9f38-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>Spike可以看作不严格的经典模式，通常只有非常简单的测试，并不限制一定要用重构，重写也可以。那么以最快的方式理解需求上下文，获得架构愿景就可以了。</p><h2>思考题</h2><p>在进入下节课之前，希望你能认真思考如下两个问题。</p><ol>\n<li>根据Spike的结果，我们要如何调整架构愿景？</li>\n<li>学完这节课后，你最大的收获是什么？有没有让你特别惊喜的操作？</li>\n</ol><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码的链接分享出来。相信经过你的思考与实操，学习效果会更好！</p>","comments":[{"had_liked":false,"id":348807,"user_name":"张铁林","can_delete":false,"product_type":"c1","uid":1108258,"ip_address":"","ucode":"4AB8BC6CDAC0A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/22/7606c6ba.jpg","comment_is_top":false,"comment_ctime":1655427583,"is_pvip":false,"replies":[{"id":127877,"content":"可以，小步提交这个方法不错！","user_name":"编辑回复","user_name_real":"编辑","uid":2189689,"ctime":1658043129,"ip_address":"","comment_id":348807,"utype":2}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"https:&#47;&#47;github.com&#47;vfbiby&#47;tdd-restful\n开始提交作业，这次把中间记的操作步骤一起放在项目doc下，还有小步提交，尽量，把每一个改变都提交上来，然后，每一章完成时，再做一个大提交。可以check到小提交处来练习。","like_count":0,"discussions":[{"author":{"id":2189689,"avatar":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","nickname":"🐑","note":"","ucode":"DE34B3B14287D1","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580254,"discussion_content":"可以，小步提交这个方法不错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658043129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347585,"user_name":"人间四月天","can_delete":false,"product_type":"c1","uid":1048314,"ip_address":"","ucode":"11BE219C23EEBC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/fa/2a046821.jpg","comment_is_top":false,"comment_ctime":1654172338,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"非常喜欢这个spike方法，在产品需求领域，叫做mvp最小可行产品，这个应该叫做最小可行设计，对于复杂需求，需求不清晰，或者复杂设计，通过这个方法验证架构愿景的可行性非常好，也能增强前期架构规划的信心。\n","like_count":5},{"had_liked":false,"id":365496,"user_name":"Geek_dcb102","can_delete":false,"product_type":"c1","uid":3251779,"ip_address":"上海","ucode":"4A0E071E453949","user_header":"","comment_is_top":false,"comment_ctime":1672674079,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"spike的过程:\n1. spike过程 需要能够快速反馈结果 所以建议从一个开始可运行的小型框架 逐步替换成自己的代码 \n2. spike中 是需要自己认为的组件 尤其是大的组件 都全员参与的 确定组件之间的关系是否合理\n3. spike中 需要参考现成的规约api 让组件更内聚合理 保证后续的复杂升级的可能性 也可以更好的观察组件的理解和划分是否合理.防止因为一开始的用例简单 造成很多组件相互耦合 职责不清 没有复杂升级的方向 进而没有达到spike应有的效果","like_count":1},{"had_liked":false,"id":349926,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1510910,"ip_address":"","ucode":"FC7849B6F0FA9F","user_header":"https://static001.geekbang.org/account/avatar/00/17/0d/fe/4e5ba578.jpg","comment_is_top":false,"comment_ctime":1656429503,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"第一次直观的感受spike方法","like_count":1},{"had_liked":false,"id":348449,"user_name":"枫中的刀剑","can_delete":false,"product_type":"c1","uid":1322387,"ip_address":"","ucode":"4B086F538184AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/93/0f1cbf44.jpg","comment_is_top":false,"comment_ctime":1655110423,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"最大收获是Spike的方式也可以采取类似TDD的方式，甚至对于暂不关心的细节部分可以使用stub。","like_count":1},{"had_liked":false,"id":356493,"user_name":"大碗","can_delete":false,"product_type":"c1","uid":1027207,"ip_address":"广东","ucode":"F9CDC0C5BE48AC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/87/8ed5880a.jpg","comment_is_top":false,"comment_ctime":1662364421,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"通过实现“现有的接口”去了解组件交互的细节","like_count":0}]}