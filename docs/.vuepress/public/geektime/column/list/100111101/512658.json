{"id":512658,"title":"08 | 代码现代化：你的代码可测吗？","content":"<p>你好，我是姚琪琳。</p><p>从今天开始，我将用三讲来介绍代码现代化的主要模式。它们大体的脉络是这样的：</p><p>1.先对代码做可测试化重构，并添加测试；<br>\n2.在测试的保护下，安全地重构；<br>\n3.在测试的保护下，将代码分层。</p><p>我们今天先来看看如何让代码变得可测，这是遗留系统现代化的基本功，希望你重视起来。</p><p>一个软件的自动化测试，可以从内部表达这个软件的质量，我们通常管它叫做<strong>内建质量（Build Quality In）</strong>。</p><p>然而国内的开发人员普遍缺乏编写自动化测试的能力，一方面是认为没什么技术含量，另一方面是觉得质量是测试人员的工作，与自己无关。然而你有没有想过，正是因为这样的误区，才导致软件的质量越来越差，系统也一步步沦为了遗留系统。</p><p>我虽然在第六节课分享了可以不加测试就重构代码的方法，但添加测试再重构的方法更加扎实，一步一个脚印。</p><h2>你的代码可测吗？</h2><p>我们先来看看不可测的代码都长什么样，分析出它们不可测的原因，再“按方抓药”。</p><p>可测的代码很相似，而不可测的代码各有各的不可测之处。我在<a href=\"https://time.geekbang.org/column/article/506570\">第二节课</a>举过一个不可测代码的例子，现在我们来一起复习一下：</p><pre><code class=\"language-java\">public class EmployeeService {\n  public EmployeeDto getEmployeeDto(long employeeId) {\n    EmployeeDao employeeDao = new EmployeeDao();\n    // 访问数据库获取一个Employee\n    Employee employee = employeeDao.getEmployeeById(employeeId);\n    // 其他代码  \n  }\n}\n</code></pre><!-- [[[read_end]]] --><p>这段代码之所以不可测，是因为在方法内部直接初始化了一个可以访问数据库的Dao类，要想测试这个方法，就必须访问数据库了。倒不是说所有测试都不能连接数据库，但大多数直连数据库的测试跑起来都太慢了，而且数据的准备也会相当麻烦。</p><p>这属于不可测代码的第一种类型：<strong>在方法中构造了不可测的对象</strong>。</p><p>我们再来看一个例子，与上面的代码非常类似：</p><pre><code class=\"language-java\">public class EmployeeService {\n  public EmployeeDto getEmployeeDto(long employeeId) {\n    // 访问数据库获取一个Employee\n    Employee employee = EmploeeDBHelper.getEmployeeById(employeeId);\n    // 其他代码\n  }\n}\n</code></pre><p>这段代码同样是不可测的，它<strong>在方法中调用了不可测的静态方法</strong>，因为这个静态方法跟前面的实例方法一样，也访问了数据库。</p><p>除了不能在测试中访问真实数据库以外，也不要在测试中访问其他需要部署的中间件、服务等，它们也会给测试带来极大的不便。</p><p>在测试中，我们通常把被测的元素（可能是组件、类、方法等）叫做SUT（System Under Test），把SUT所依赖的组件叫做DOC（Depended-on Component）。导致<strong>SUT无法测试的原因</strong>，通常都是<strong>DOC在当前的测试上下文中不可用</strong>。</p><p>DOC不可用的原因通常有三种：</p><p>1.不能访问。比如DOC访问了数据库或其他需要部署的中间件、服务等，而本地环境没有这些组件，也很难部署这些组件。</p><p>2.不是当前测试期望的返回值。即使本地能够访问这些组件，但它们却无法返回我们想要的值。比如我们想要获取ID为1的员工信息，但数据库中却并没有这条数据。</p><p>3.执行这些DOC的方法会引发不想要的副作用。比如更新数据库，会破坏已有数据，影响其他测试。另外连接数据库，还会导致测试执行时间变长，这也是一种副作用。</p><p>要让SUT可测，就得让DOC可用，有哪些办法呢？</p><h2>如何让代码变得可测？</h2><p>其实很简单，就是要让DOC的行为可变。这种变化可以让DOC在测试时不再直接访问数据库或其他组件，从而变得“可以访问”、“能返回期望的值”以及“不会产生副作用”。</p><p>如何才能让DOC的行为可变呢？如果DOC是静态的或是在SUT内构造的，那自然不可改变。所以，我们要让DOC的构造和SUT本身分离，SUT只需使用外部构造好的DOC的实例，而不用关心它的构造。</p><p>这种<strong>可以让DOC的行为发生改变的位置</strong>，叫做<strong>接缝（seam）</strong>，这是Michael Feathers在《修改代码的艺术》这本书里提出来的。</p><p>接缝这个隐喻非常形象，如果是一整块没有接缝的布料，你就无法做任何改动，它始终就是一块平面的布料。有了接缝，你不但可以连接不同的布料，还可以改变一块布的方向，从平面变得立体。有了接缝，身为“裁缝”的我们才可以充分发挥想象力，制作出各种丰富多彩的成品。</p><p>我把这种在<strong>SUT中创建接缝从而使SUT变得可测的方式</strong>，叫做<strong>提取接缝模式</strong>。</p><p>想要用好这个模式，我们需要了解何处下剪子，针法选什么合适。也就是接缝的位置和类型，下面我们就结合代码例子分别看看。</p><h3>接缝的位置</h3><p>我在第二节课介绍了一种提取接缝模式的应用，也就是把EmployeeDao提取成EmployeeService的字段，并通过EmployeeService的<strong>构造函数注入</strong>进来。</p><pre><code class=\"language-java\">public class EmployeeService {\n  private EmployeeDao employeeDao;\n  public EmployeeService(EmployeeDao employeeDao) {\n    this.employeeDao = employeeDao;\n  }\n\n  public EmployeeDto getEmployeeDto(long employeeId) {\n    Employee employee = employeeDao.getEmployeeById(employeeId);\n    // 其他代码\n  }\n}\n</code></pre><p>除了构造函数，接缝也可以位于<strong>方法参数</strong>中，即：</p><pre><code class=\"language-java\">public class EmployeeService {\n  public EmployeeDto getEmployeeDto(long employeeId, EmployeeDao employeeDao) {\n    Employee employee = employeeDao.getEmployeeById(employeeId);\n    // 其他代码\n  }\n}\n</code></pre><p>如果你使用了依赖注入工具（比如Spring），也可以给字段加@Autowired注解，这样接缝的位置就成了<strong>字段</strong>。对于这三种接缝位置，我更倾向于构造函数，因为它更方便，而且与具体的工具无关。</p><p>学习完接缝的位置，我们再来看看接缝的类型。</p><h3>接缝的类型</h3><p><strong>接缝的类型</strong>是指，<strong>通过什么样的方式来改变DOC的行为</strong>。第二节课中，提取完接缝后，我创建了一个EmployeeDao的子类，这个子类重写了getEmployeeById的默认行为，从而让这个DOC返回了我们“期望的值”。</p><pre><code class=\"language-java\">public class InMemoryEmployeeDao extends EmployeeDao {\n  @Override\n  public Employee getEmployeeById(long employeeId) {\n    return null;\n  }\n}\n</code></pre><p>我把这种<strong>通过继承DOC来改变默认行为</strong>的接缝类型叫做<strong>对象接缝</strong>。</p><p>除此之外，还可以将原来的EmployeeDao类重命名为DatabaseEmployeeDao，并提取出一个EmployeeDao接口。然后再让InMemoryEmployeeDao类实现EmployeeDao接口。</p><pre><code class=\"language-java\">public interface EmployeeDao {\n    Employee getEmployeeById(long employeeId);\n}\n</code></pre><p>在EmployeeService中，我们仍然通过构造函数来提供这个接缝，代码基本上可以保持不变。这样，我们和对象接缝一样，只需要在构造EmployeeService的时候传入InMemoryEmployeeDao就可以改变默认的行为，之后的测试也更方便。</p><p>这种<strong>通过将DOC提取为接口，并用其他实现类来改变默认行为</strong>的接缝类型，就叫做<strong>接口接缝</strong>。</p><p>如果你的代码依赖的是一个接口，那么这种依赖或者说耦合就是很松散的。在接口本身不发生改变的前提下，不管是修改实现了该接口的类，还是添加了新的实现类，使用接口的代码都不会受到影响。</p><h3>新生和外覆</h3><p>提取了接缝，你就可以对遗留代码添加测试了。但这时你可能会说，虽然接缝很好，但是很多复杂的代码依赖了太多东西，一个个都提取接缝的话，需要很长时间，但无奈工期太紧，不允许这么做啊。</p><p>不要紧，《修改代码的艺术》中还介绍了两种不用提取接缝就能编写可测代码的模式，也就是<strong>新生（sprout）<strong>和</strong>外覆（wrap）</strong>。</p><p>假设我们有这样一段代码，根据传入的开始和结束时间，计算这段时间内所有员工的工作时间：</p><pre><code class=\"language-java\">public class EmployeeService {\n    public Map&lt;Long, Integer&gt; getWorkTime(LocalDate startDate, LocalDate endDate) {\n        EmployeeDao employeeDao = new EmployeeDao();\n        List&lt;Employee&gt; employees = employeeDao.getAllEmployees();\n        Map&lt;Long, Integer&gt; workTimes = new HashMap&lt;&gt;();\n        for(Employee employee : employees) {\n            WorkTimeDao workTimeDao = new WorkTimeDao();\n            int workTime = workTimeDao.getWorkTimeByEmployeeId(employee.getEmployeeId(), startDate, endDate);\n            workTimes.put(employee.getEmployeeId(), workTime);\n        }\n        return workTimes;\n    }\n}\n</code></pre><p>我知道这段代码有很多槽点，但更痛的现实状况是：你根本没有时间去优化，因为新的需求已经来了，并且明天就要提测。</p><p>需求是这样的，业务人员拿到工时的报表后发现，有很多员工的工时都是0，原来他们早就离职了。现在要求你修改一下代码，过滤掉那些离职的员工。</p><p>如果不需要写测试，这样的需求对你来说就是小事一桩，你一定轻车熟路。</p><p>你可以在EmployeeDao中添加一个新的查询数据库的方法getAllActiveEmployees，只返回在职的Employee。也可以仍然使用getAllEmployees，并在内存中进行过滤。</p><pre><code class=\"language-java\">public class EmployeeService {\n    public Map&lt;Long, Integer&gt; getWorkTime(LocalDate startDate, LocalDate endDate) {\n        EmployeeDao employeeDao = new EmployeeDao();\n        List&lt;Employee&gt; employees = employeeDao.getAllEmployees()\n                .stream()\n                .filter(e -&gt; e.isActive())\n                .collect(toList());\n        // 其他代码\n    }\n}\n</code></pre><p>这样的修改不仅在遗留系统中，即使在所谓的新系统中，也是十分常见的。需求要求加一个过滤条件，那我就加一个过滤条件就好了。</p><p>然而，这样的代码仍然是不可测的，你加了几行代码，但你加的代码也是不可测的，系统没有因你的代码而变得更好，反而更糟了。</p><p>更好的做法是添加一个<strong>新生方法</strong>，去执行过滤操作，而不是在原来的方法内去过滤。</p><pre><code class=\"language-java\">public class EmployeeService {\n    public Map&lt;Long, Integer&gt; getWorkTime(LocalDate startDate, LocalDate endDate) {\n        EmployeeDao employeeDao = new EmployeeDao();\n        List&lt;Employee&gt; employees = filterInactiveEmployees(employeeDao.getAllEmployees());\n        // 其他代码\n    }\n    public List&lt;Employee&gt; filterInactiveEmployees(List&lt;Employee&gt; employees) {\n        return employees.stream().filter(e -&gt; e.isActive()).collect(toList());\n    }\n}\n</code></pre><p>这样一来，新生方法是可测的，你可以对它添加测试，以验证过滤逻辑的正确性。原来的方法虽然仍然不可测，但我们也没有让它变得更糟。</p><p>除了<strong>新生</strong>，你还可以使用<strong>外覆</strong>的方式来让新增加的功能可测。比如下面这段计算员工薪水的代码。</p><pre><code class=\"language-java\">public class EmployeeService {\n    public BigDecimal calculateSalary(long employeeId) {\n        EmployeeDao employeeDao = new EmployeeDao();\n        Employee employee = employeeDao.getEmployeeById();\n        return SalaryEngine.calculateSalaryForEmployee(employee);\n    }\n}\n</code></pre><p>如果我们现在要添加一个新的功能，有些调用端在计算完薪水后，需要立即给员工发短信提醒，而且其他调用端则保持不变。你脑子里可能有无数种实现方式，但最简单的还是直接在这段代码里添加一个<strong>新生</strong>方法，用来通知员工。</p><pre><code class=\"language-java\">public class EmployeeService {\n    public BigDecimal calculateSalary(long employeeId, bool needToNotify) {\n        EmployeeDao employeeDao = new EmployeeDao();\n        Employee employee = employeeDao.getEmployeeById();\n        BigDecimal salary = SalaryEngine.calculateSalaryForEmployee(employee);\n        notifyEmployee(employee, salary, needToNotify);\n        return salary;\n    }\n}\n</code></pre><p>这的确非常方便，但将needToNotify这种标志位一层层地传递下去，是典型的代码坏味道<a href=\"https://martinfowler.com/bliki/FlagArgument.html\">FlagArgument</a>。你也可以在调用端根据情况去通知员工，但那样对调用端的修改又太多太重，是典型的霰弹式修改。</p><p>最好的方式是在原有方法的基础上<strong>外覆</strong>一个新的方法calculateSalaryAndNotify，它会先调用原有方法，然后再调用通知方法。</p><pre><code class=\"language-java\">public BigDecimal calculateSalary(long employeeId) {\n    // ...\n}\npublic BigDecimal calculateSalaryAndNotify(long employeeId) {\n    BigDecimal salary = calculateSalary(employeeId);\n    notifyEmployee(employeeId, salary);\n    return salary;\n}\npublic void notifyEmployee(long employeeId, BigDecimal salary) {\n    // 通知员工\n}\n</code></pre><p>通过这样的修改，调用端只需要根据情况选择调用哪个方法即可，这样的改动量最少。同时你还可以单独测试notifyEmployee，以确保这部分逻辑是正确的。</p><p>通过新生和外覆两种模式，我们新编写的代码就是可测的了。而通过提取接缝，旧代码的可测试化重构也可以基本搞定。接下来，我将通过构造函数注入和接口接缝演示一下，如何为这个EmployeeService编写测试。</p><h2>为代码添加测试</h2><p>我们先来回顾一下现在EmployeeService的完整代码：</p><pre><code class=\"language-java\">public class EmployeeService {\n    private EmployeeDao employeeDao;\n    public EmployeeService(EmployeeDao employeeDao) {\n        this.employeeDao = employeeDao;\n    }\n    public EmployeeDto getEmployeeDto(long employeeId) {\n        Employee employee = employeeDao.getEmployeeById(employeeId);\n        if (employee == null) {\n            throw new EmployeeNotFoundException(employeeId);\n        }\n        return convertToEmployeeDto(employee);\n    }\n}\n</code></pre><p>我们要添加的测试是当EmployeeDao的getEmployeeById方法返回一个null的时候，EmployeeService的getEmployeeDto方法会抛出一个异常。</p><pre><code class=\"language-java\">public class EmployeeServiceTest {\n    @Test\n    public void should_throw_employee_not_found_exception_when_employee_not_exists() {\n        EmployeeService employeeService = new EmployeeService(new InMemoryEmployeeDao());\n        EmployeeNotFoundException exception = assertThrows(EmployeeNotFoundException.class,\n            () -&gt; employeeService.getEmployeeDto(1L));\n        assertEquals(exception.getEmployeeId(), 1L);\n    }\n}\n</code></pre><p>我们在测试中使用的InMemoryEmployeeDao，实际上就是一种<strong>测试替身（Test Double）</strong>。但是它只返回了null，有点单一，想测试正常的情况就没法用了。如果想让这个方法返回不同的值，再添加一个EmployeeDao的实现着实有点麻烦。这时可以使用Mock框架，让它可以针对不同的测试场景返回不同的值。</p><pre><code class=\"language-java\">@Test\npublic void should_return_correct_employee_when_employee_exists() {\n    EmployeeDao mockEmployeeDao = Mockito.mock(EmployeeDao.class);\n    when(mockEmployeeDao.getEmployeeById(1L)).thenReturn(givenEmployee(\"John Smith\"));\n    EmployeeService employeeService = new EmployeeService(mockEmployeeDao);\n    EmployeeDto employeeDto = employeeService.getEmployeeDto(1L);\n    \n    assertEquals(1L, employeeDto.getEmployeeId());\n    assertEquals(\"John Smith\", employeeDto.getName());\n}\n</code></pre><p>这里我们使用了Mockito这个Java中最流行的Mock框架。想了解更多关于测试替身和Mock框架的知识，可以参考郑晔老师的<a href=\"https://time.geekbang.org/column/article/408762\">专栏文章</a>。</p><p>好了，代码也可测了，我们也知道怎么写测试了，那么应该按什么样的思路去添加测试呢？上面这种简单的例子，我相信你肯定是知道要怎么加测试，但是遗留系统中的那些“祖传”代码真的是什么样的都有，对于这种复杂代码，应该怎么去添加测试呢？</p><h3>决策表模式</h3><p>我们以著名的<a href=\"https://github.com/emilybache/GildedRose-Refactoring-Kata\">镶金玫瑰重构道场</a>的代码为例，来说明如何为复杂遗留代码添加测试。</p><pre><code class=\"language-java\">public void updateQuality() {\n   for (int i = 0; i &lt; items.length; i++) {\n       if (!items[i].name.equals(\"Aged Brie\")\n               &amp;&amp; !items[i].name.equals(\"Backstage passes to a TAFKAL80ETC concert\")) {\n           if (items[i].quality &gt; 0) {\n               if (!items[i].name.equals(\"Sulfuras, Hand of Ragnaros\")) {\n                   items[i].quality = items[i].quality - 1;\n               }\n           }\n       } else {\n           if (items[i].quality &lt; 50) {\n               items[i].quality = items[i].quality + 1;\n\n               if (items[i].name.equals(\"Backstage passes to a TAFKAL80ETC concert\")) {\n                   if (items[i].sellIn &lt; 11) {\n                       if (items[i].quality &lt; 50) {\n                           items[i].quality = items[i].quality + 1;\n                       }\n                   }\n\n                   if (items[i].sellIn &lt; 6) {\n                       if (items[i].quality &lt; 50) {\n                           items[i].quality = items[i].quality + 1;\n                       }\n                   }\n               }\n           }\n       }\n\n       if (!items[i].name.equals(\"Sulfuras, Hand of Ragnaros\")) {\n           items[i].sellIn = items[i].sellIn - 1;\n       }\n\n       if (items[i].sellIn &lt; 0) {\n           if (!items[i].name.equals(\"Aged Brie\")) {\n               if (!items[i].name.equals(\"Backstage passes to a TAFKAL80ETC concert\")) {\n                   if (items[i].quality &gt; 0) {\n                       if (!items[i].name.equals(\"Sulfuras, Hand of Ragnaros\")) {\n                           items[i].quality = items[i].quality - 1;\n                       }\n                   }\n               } else {\n                   items[i].quality = items[i].quality - items[i].quality;\n               }\n           } else {\n               if (items[i].quality &lt; 50) {\n                   items[i].quality = items[i].quality + 1;\n               }\n           }\n       }\n   }\n}\n</code></pre><p>这是非常典型的遗留代码，if/else满天飞，可谓眼花缭乱；而且分支的规则不统一，有的按名字去判断，有的按数量去判断。</p><p>对于这种分支条件较多的代码，我们可以梳理需求文档（如果有的话）和代码，找出所有的路径，根据每个路径下各个字段的数据和最终的值，制定一张决策表，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/63/d1/6357f689162820db3d22623e38aacbd1.jpg?wh=1920x1667\" alt=\"图片\"></p><p>比如第一行，我们要测的是，系统每天会自动给所有商品的保质期和品质都减1，那么给出的条件是商品类型为normal，保质期为4天，品质为1，所期望的行为是保质期和品质都减少1。而第二行则是测试，当保质期减为0之后，品质会双倍地减少。以此类推，我们一共梳理出18个测试场景。</p><p>你会看到，这种决策表不但清晰地提供了所有测试用例，而且给出了相应的数据，你可以很轻松地基于它来构建整个方法的测试。</p><h2>测试的类型和组织</h2><p>说完了如何添加测试，我们接下来看看可以添加哪些类型的测试。</p><p>Mike Cohn在十几年前曾经提出过著名的“<a href=\"https://martinfowler.com/bliki/TestPyramid.html\">测试金字塔</a>”理论，将测试划分为三个层次。从上到下分别是：UI测试、服务测试和单元测试。它们累加在一起，就像一个金字塔一样。需要指出的是，遗留系统很难应用测试金字塔，但我们还是有必要先来看看这三层测试都包含哪些内容。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/48/4da7cb2739ac48ff731184f91c728f48.jpg?wh=1920x1106\" alt=\"图片\"></p><p>其中，最顶层的UI测试是指从页面点击到数据库访问的端到端测试，用自动化的方式去模拟用户或测试人员的行为。</p><p>早年间的所谓自动化测试大多都属于这种。但这样的测试十分不稳定，一个简单的页面调整就可能导致测试失败。</p><p>尽管现在很多工具推出了headless的方式，可以绕开页面，但它们仍然运行得很慢。而且还需要与很多服务、工具集成起来，环境的搭建也是个问题。所以UI测试位于测试金字塔的顶端，即只需要少量的这种测试，来验证服务和中间件等相互之间的访问是正常的。</p><p>需要指出的是，UI测试并不是针对前端元素或组件的测试。后者其实是前端的单元测试。</p><p>中间这层的服务测试也是某种意义的端到端测试，但它避开了UI的复杂性，而是直接去测试UI会访问的API。也有人管这种测试叫集成测试。它可以直接访问数据库，也可以用H2或SQLite等文件或内存数据库代替；它也可以直接访问其他服务，也可以用<a href=\"https://github.com/dreamhead/moco\">Moco</a>等工具来模拟服务的行为。</p><p>这种测试的好处是，可以测试API级别的端到端行为，不管内部的代码如何重构，只要API的契约保持不变，测试就不需要修改。</p><p>最底层的单元测试就是对某个方法的测试，平时开发同学写的大多是这方面的测试。测试金字塔的建议是，尽可能多地写单元测试，它编写成本低、运行速度快，是整个测试金字塔的基座。</p><p>对于方法内用到的DOC，你可以用测试替身来替换。对于在多大程度上使用测试替身，有两种不同的观点。</p><p>一种观点认为不管任何依赖都应该使用测试替身来代替；一种观点则认为只要DOC不访问数据库、不访问文件系统、不访问进程外的服务或中间件，就可以不用测试替身。前者的学名叫solitary unit test，我管它叫“<strong>社恐症单元测试</strong>”；后者学名叫做sociable unit test，我管它叫“<strong>交际花单元测试</strong>”。</p><p>到底应该使用哪种类型的单元测试呢？这一点并没有定论，支持每种类型的人都不少。我个人更倾向于交际花单测，因为这样写起来更容易，而且对重构很友好。</p><h2>遗留系统中的测试策略</h2><p>学完了测试金字塔，你是不是已经准备按照由少到多的关系，在遗留系统中补测试了呢？先别急，遗留代码有很多特点，导致它们并不适合完全应用测试金字塔来组织测试。</p><p>首先，遗留系统的很多业务逻辑位于数据库的存储过程或函数中，代码只是用来传递参数而已。这样一来单元测试根本测不到什么东西。你也不能在服务测试（或API测试）中使用内存数据库，因为要在这些数据库中复制原数据库中的存储过程或函数，可能会有很多语法不兼容。</p><p>其次，遗留系统的很多业务还位于前端页面中，位于JSP、PHP、ASP的标签之中。这部分逻辑也是没法用单元测试来覆盖的。而服务测试脱离了页面，显然也无法覆盖。</p><p>因此，如果你的遗留系统在前端和数据库中都有不少业务逻辑，就可以多写一些UI测试，它们可以端到端地覆盖这些业务逻辑。你可以从系统中最重要的业务开始编写UI测试。</p><p>然而，UI测试毕竟十分不稳定，运行起来也很慢，当数量上来后这些缺点就会被放大。这时候你可以多编写一些服务测试。</p><p>对于数据库中的业务逻辑，你可以搭建一些基础设施，让开发人员可以在测试中直连数据库，并方便地编写集成测试。这些基础设施包括：</p><ul>\n<li>一个数据库镜像，可以快速在本地或远端做初始化；需要将数据库容器化，满足开发和测试人员使用个人数据库的需求。</li>\n<li>一个数据复制工具，可以方便地从其他测试环境拉取数据到这个镜像，以方便数据的准备；可以考虑通过CI/CD来实现数据的复制。</li>\n</ul><p>除此之外，你可能还需要一个数据对比工具，用来帮你在重构完代码后，比较数据库的状态。比如将一个存储过程或函数中的逻辑迁移到Java代码中的时候，要验证迁移的正确性，只跑通集成测试是远远不够的，还要全方位地比较数据库中相关表的数据，以防漏掉一些不起眼的地方。</p><p>对于前端中的业务逻辑，你可以先重构这些逻辑，将它们迁移到后端中（我将在第十三节课详细讲解如何迁移），然后再编写单元测试或服务测试。</p><p>这时的测试策略有点像一个钻石的形状。</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/c5/5ea17f429b5b6f1a3397238448b49ac5.jpg?wh=1920x1066\" alt=\"图片\"></p><p>确定好了测试的类型，还有一些测试编写方面的小细节我想跟你分享。</p><p>第一个细节是测试的命名。关于测试命名，不同书籍中都有不同的推荐，但我更倾向于像<a href=\"https://time.geekbang.org/column/article/508559\">第四节课</a>中介绍的那样，用“实例化需求”的方式，从业务角度来命名测试，使得测试可以和代码一起演进，成为活文档。</p><p>第二个细节是测试的组织。当测试变多时，如果不好好对测试进行分组，很快就会变得杂乱无章。这样的测试即使是活文档，也会增加认知负载。</p><p>最好的方法是，将单个类的测试都放在同一个包中，将不同方法的测试放在单独的测试类里。而对于同一个方法，要先写它Happy path的测试，再写Sad path。记住一个口诀：<strong>先简单，再复杂；先正常，再异常</strong>。也就是测试的场景要先从简单的开始，逐步递进到复杂的情况；而测试的用例要先写正常的Case，再逐步递进到异常的Case。</p><h2>小结</h2><p>今天学习的知识比较密集，需要好好总结一下。</p><p>我们首先学习了<strong>接缝的位置</strong>和<strong>接缝的类型</strong>。接缝的位置是指那些可以让DOC的行为发生改变的位置，有构造函数、方法参数、字段三种；而接缝的类型则是说改变DOC行为的方式，包括对象接缝和接口接缝。</p><p>遗留代码中有了接缝，就可以着手写测试了。然而复杂的遗留代码很难去梳理清楚头绪，我想你推荐用<strong>决策表</strong>的方式，将测试用例一一列出来。</p><p>在遗留系统中，如果存储过程中包含大量的业务逻辑，传统的金字塔型的测试策略可能并不适合，你可以多写一些端到端的UI测试，以及与数据库交互的集成测试（服务测试）。这时的测试策略呈现一个钻石的形状。</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/c5/5ea17f429b5b6f1a3397238448b49ac5.jpg?wh=1920x1066\" alt=\"图片\"></p><p>最后我想说的是，自动化测试是代码不可或缺的一部分，忽视了测试，即使是新系统，也在向着遗留系统的不归路上冲刺。然而技术社区对于测试的态度总是十分漠视，多年来不曾改观。</p><p>有一次我的同事在某语言群里询问，是否有人愿意给一个开源框架添加测试，然而大家想的却是什么“技术进步性”。</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/2f/9dbed940418bc71d3ebc11fbc0a3d02f.jpg?wh=1920x1351\" alt=\"图片\"></p><p>开发人员如果忽视编写自动化测试，就放弃了将质量内建到软件（也就是自己证明自己质量）的机会，把质量的控制完全托付给了测试人员。这种靠人力去保证质量的方式，永远也不可能代表“技术先进性”。</p><p>有的时候你可能觉得，我就是写了一行代码，加不加测试无所谓吧？反正原来也没有测试。但是，希望你不要这么想，更不要这么做。犯罪心理学中有一个“破窗效应”，意思是说如果一栋楼有几扇窗户是破的，用不了几天所有的窗户都会破掉。这是一个加速熵增的过程，没有测试的系统，就是那座破了窗户的大楼。</p><p>你要记住的是“童子军原则”，也就是当露营结束离开的时候，要打扫营地，让它比你来的时候更干净。你写了一行代码，并把这一行代码的测试加上，你就没有去打破一扇新的窗户，而是让系统比你写代码之前变得更好了。这便是引入了一个负熵，让你的系统从无序向着有序迈出了一步。</p><p>莫以恶小而为之，莫以善小而不为。</p><h2>思考题</h2><p>感谢你听完我的絮絮叨叨，希望今天的课程能唤醒你写测试的意愿。今天的思考题请你分享一段你项目中的代码，并聊一聊你准备如何给它添加测试，别忘了给代码脱敏。</p><p>如果你觉得今天的课程对你有帮助，请把它分享给你的同事和朋友，我们一起来写测试吧。</p>","comments":[{"had_liked":false,"id":343921,"user_name":"黄叶","can_delete":false,"product_type":"c1","uid":2332411,"ip_address":"","ucode":"8D8C566F7772A6","user_header":"https://static001.geekbang.org/account/avatar/00/23/96/fb/af39abb1.jpg","comment_is_top":false,"comment_ctime":1651119428,"is_pvip":false,"replies":[{"id":125598,"content":"感谢分享。","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1651189303,"ip_address":"","comment_id":343921,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"老师的课很棒，这里可以的话可以参考一下下面资料：\n 1.《重构2》3.8，关于霰弹式修改的问题\n 2.关于祖传代码：可以去这个网站看看，这是一个针对祖传代码的练习，看他是如何对祖传代码做重构的：https:&#47;&#47;linesh.gitbook.io&#47;refactoring&#47;xiang-jin-mei-gui&#47;2-project-analyze\n 3.感觉老师的课，和TDD项目实战70讲很搭，可以结合看看","like_count":9,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568613,"discussion_content":"感谢分享。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651189303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344664,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1651716599,"is_pvip":false,"replies":[{"id":125832,"content":"感谢分享。\n不过这里面一共测试了3个场景，应该把它们分解到三个不同的测试中，并用测试名称进行区分","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1651753675,"ip_address":"","comment_id":344664,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"再分享一个测试\n\npublic class SplitUtil {\n    public static final List&lt;Long&gt; toLongList(String str) {\n        return Arrays.stream(StringUtils.split(str, &quot;,&quot;))\n                .map(Long::parseLong)\n                .collect(Collectors.toList());\n    }\n}\n\nclass SplitUtilTest {\n    @Test\n    void to_long_list() {\n        List&lt;Long&gt; list = SplitUtil.toLongList(&quot;&quot;);\n        assertThat(list).asList();\n\n        list = SplitUtil.toLongList(&quot;1&quot;);\n        assertThat(list.size() == 1).isTrue();\n        assertThat(list.contains(1L)).isTrue();\n\n        list = SplitUtil.toLongList(&quot;1,2&quot;);\n        assertThat(list.size() == 2).isTrue();\n        assertThat(list.contains(1L)).isTrue();\n        assertThat(list.contains(2L)).isTrue();\n    }\n}","like_count":1,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570393,"discussion_content":"感谢分享。\n不过这里面一共测试了3个场景，应该把它们分解到三个不同的测试中，并用测试名称进行区分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651753675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570522,"discussion_content":"谢谢老师指点，我又改了一下\n\n@Test\nvoid should_return_empty_list_if_string_is_blank() {\n    List&lt;Long&gt; list = SplitUtil.toLongList(&#34;&#34;);\n    assertThat(list).asList().isEmpty();\n}\n\n@Test\nvoid should_return_list_containing_one_element_if_string_with_a_number_in_it() {\n    List&lt;Long&gt; list = SplitUtil.toLongList(&#34;1&#34;);\n    assertThat(list.size() == 1).isTrue();\n    assertThat(list.contains(1L)).isTrue();\n}\n\n@Test\nvoid should_return_list_containing_multiple_element_if_string_with_multiple_number_in_it() {\n    List&lt;Long&gt; list = SplitUtil.toLongList(&#34;1,2&#34;);\n    assertThat(list.size() == 2).isTrue();\n    assertThat(list.contains(1L)).isTrue();\n    assertThat(list.contains(2L)).isTrue();\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651804952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343989,"user_name":"2022","can_delete":false,"product_type":"c1","uid":1837401,"ip_address":"","ucode":"FF4ACF782DCD32","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/0G5nUhs4Isl9DicqZczPQt51OibNcmfjVxhXdpCoAibvyoOPnK7ZvVBgA3A3Shw08hcmMcuhSer3dmQruJ9xibTb7g/132","comment_is_top":false,"comment_ctime":1651157185,"is_pvip":false,"replies":[{"id":125597,"content":"涉及硬件的端到端测试，如果数据发送给了另一个设备，你可以看看该设备有没有接口可以获取这些数据，就能验证了；如果没有，测的时候就把设备隔离，分开测，系统这边的测试可以测数据被发给了一个设备（的mock），设备那边的测试去测接到什么样的数据之后会有什么样的变化。两个测试合起来就是一个端到端测试了（除了连通性没有测到）。","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1651189276,"ip_address":"","comment_id":343989,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"老师，请教一下，如果是端到端的自动化测试，怎么保证结果的正确性呢？ 比如，从UI修改配置后，下发到另外一个设备，有什么好的办法得到期望的结果？","like_count":1,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568612,"discussion_content":"涉及硬件的端到端测试，如果数据发送给了另一个设备，你可以看看该设备有没有接口可以获取这些数据，就能验证了；如果没有，测的时候就把设备隔离，分开测，系统这边的测试可以测数据被发给了一个设备（的mock），设备那边的测试去测接到什么样的数据之后会有什么样的变化。两个测试合起来就是一个端到端测试了（除了连通性没有测到）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651189276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343707,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1651016045,"is_pvip":false,"replies":[{"id":125442,"content":"1. 我目前没有看到专门用于A&#47;B测试的数据对比工具，即使有也不太能适配你自己的数据库，不如自己按项目需要开发一个\n2. Cypress是目前比较流行的E2E测试工具","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1651021188,"ip_address":"","comment_id":343707,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"请教老师两个问题：\nQ1：数据比较，有开源工具吗？\nQ2：网站测试，有比较通用的自动化测试工具吗？","like_count":1,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567865,"discussion_content":"1. 我目前没有看到专门用于A/B测试的数据对比工具，即使有也不太能适配你自己的数据库，不如自己按项目需要开发一个\n2. Cypress是目前比较流行的E2E测试工具","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651021188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376321,"user_name":"Geek_682837","can_delete":false,"product_type":"c1","uid":1715823,"ip_address":"广东","ucode":"55C29E9EDD9265","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaxhA2xdIRKQ0rXZhrjcWPYp4hR1mjST6lcBeuYTg0Omf0hyREfr8VH8JWXEyEVq82ht7wdzWsyA/132","comment_is_top":false,"comment_ctime":1686703924,"is_pvip":false,"replies":[{"id":138480,"content":"如果是单元测试，不应该有需要mock这么多数据的场景，你可以具体说说看你的场景是什么样的。","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1693284438,"ip_address":"北京","comment_id":376321,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"如果遇到需要mock的数据比较多，怎么比较方便构建mock数据，比如我需要mock一个List，可能有几十条数据的大小，自己mock的话就比较麻烦，如果直接访问数据库就可以比较方便拿到，但此时就依赖数据库了","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626694,"discussion_content":"如果是单元测试，不应该有需要mock这么多数据的场景，你可以具体说说看你的场景是什么样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693284438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372524,"user_name":"跫音","can_delete":false,"product_type":"c1","uid":1959666,"ip_address":"上海","ucode":"E700CF1E8BCB15","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e6/f2/f72e2399.jpg","comment_is_top":false,"comment_ctime":1681256361,"is_pvip":false,"replies":[{"id":138481,"content":"都可以，测试类和包多本身并不是问题","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1693284518,"ip_address":"北京","comment_id":372524,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"老师，请教一个问题，将单个类的测试都放在同一个包中，将不同方法的测试放在单独的测试类里。这样会不会导致测试类以及包很多？目前我们都是一个类对应一个测试类","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626696,"discussion_content":"都可以，测试类和包多本身并不是问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693284518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352303,"user_name":"Geek_70dc13","can_delete":false,"product_type":"c1","uid":3048379,"ip_address":"河北","ucode":"CCA16FCE49811A","user_header":"","comment_is_top":false,"comment_ctime":1658537873,"is_pvip":false,"replies":[{"id":128815,"content":"如果没有存储过程，那么用内存数据库是可以测试SQL语句的，一般的工具都做好了SQL方言的适配。但如果有存储过程，就只能访问真实数据库了。\n\n集成测试是指需要和当前SUT的外部进行交互的，数据库和其他服务都算，因此直接访问数据库或其他服务的测试都属于集成测试；而只要没有访问这些外部的东西，在我看来都属于单元测试。当然，这一点很多人有不同观点，没必要纠结，重要的是把测试写出来。","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1660142692,"ip_address":"河北","comment_id":352303,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"既然访问 db 的操作都是 mock ，那我如何保障 sql 那部分的正确性呢？看老师给的方案是集成测试。然而我一般使用的策略就是起 inmemory db，通过塞测试数据的方式，也会测 sql 那部分，缺点就是造数据和运行稍慢。\n\n另外单元测试和集成测试的界限我可能并没有分的很清，单元测试是指每一层只测自己层的功能吗？比如：service 只测 service 的逻辑，mock掉 dao就是单元测试，不mock 掉dao也算是集成测试，还是说集成测试一定要构造 request 的方式","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583491,"discussion_content":"如果没有存储过程，那么用内存数据库是可以测试SQL语句的，一般的工具都做好了SQL方言的适配。但如果有存储过程，就只能访问真实数据库了。\n\n集成测试是指需要和当前SUT的外部进行交互的，数据库和其他服务都算，因此直接访问数据库或其他服务的测试都属于集成测试；而只要没有访问这些外部的东西，在我看来都属于单元测试。当然，这一点很多人有不同观点，没必要纠结，重要的是把测试写出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660142692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"河北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350870,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1657265000,"is_pvip":false,"replies":[{"id":127743,"content":"根据原有代码的分支逻辑一步一步推导出来的","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1657593768,"ip_address":"","comment_id":350870,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"老师 有没有手把手教怎么创建决策表 还是不是很理解怎么创造出来的","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579647,"discussion_content":"根据原有代码的分支逻辑一步一步推导出来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657593768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350868,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1657264921,"is_pvip":false,"replies":[{"id":127742,"content":"好眼力，如果只是重构，可以不加throw error的测试，但这一部分其实是原有代码中缺失的逻辑，后面需要补上。","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1657593723,"ip_address":"","comment_id":350868,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"老师 决策表里边throw error的测试 在原code中没有throw error的逻辑呀","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579646,"discussion_content":"好眼力，如果只是重构，可以不加throw error的测试，但这一部分其实是原有代码中缺失的逻辑，后面需要补上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657593723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347895,"user_name":"IanFaye","can_delete":false,"product_type":"c1","uid":1101552,"ip_address":"","ucode":"C86BC8F06DDB38","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/f0/9a137d87.jpg","comment_is_top":false,"comment_ctime":1654565106,"is_pvip":false,"replies":[{"id":126829,"content":"一般来说，前端的测试框架都是headless的，无法测试浏览器。可以用Selenium等工具编写E2E测试，并指定浏览器。但E2E测试跑起来很慢，又不能写太多，所以最好针对你觉得容易产生问题的点写少量测试。","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1654670594,"ip_address":"","comment_id":347895,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"老师，请问浏览器兼容性问题如何测试定位问题呢？","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575219,"discussion_content":"一般来说，前端的测试框架都是headless的，无法测试浏览器。可以用Selenium等工具编写E2E测试，并指定浏览器。但E2E测试跑起来很慢，又不能写太多，所以最好针对你觉得容易产生问题的点写少量测试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654670594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101552,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/f0/9a137d87.jpg","nickname":"IanFaye","note":"","ucode":"C86BC8F06DDB38","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575298,"discussion_content":"谢谢老师指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654736891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347162,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1653753897,"is_pvip":false,"replies":[{"id":126585,"content":"有没有返回值跟如何重构没有关系啊，你指的是如何写测试，并在测试的保护下安全重构吧？一个方法如果没有返回值，那也必然会产生一些副作用，如修改了当前类中的某些字段，或传入参数的某些数据，这些都是可以验证和测试的。","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1653802193,"ip_address":"","comment_id":347162,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100111101,"comment_content":"请教老师一个问题，如果说我有一个方法它的逻辑很复杂，但是我这个方法没有返回值，这种情况应该怎么去重构呢？","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574027,"discussion_content":"有没有返回值跟如何重构没有关系啊，你指的是如何写测试，并在测试的保护下安全重构吧？一个方法如果没有返回值，那也必然会产生一些副作用，如修改了当前类中的某些字段，或传入参数的某些数据，这些都是可以验证和测试的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653802193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576523,"discussion_content":"您说的对，有没有返回值跟重构没啥关系。是的，我指的就是如何写测试，我的理解是：一个方法没有返回值确实也会产生一些副作用，但是其实按照我司的约定，我们按照三层架构，主要的业务逻辑都在service层，但是我们对于service层是不写集成测试的，只会写单元测试，我这里所说的集成测试是指需要启动spring容器，连接数据库之类的，当然也可以去启动数据库或者spring容器，但是我的理解是还是想尽量在单元测试里去做测试，因为集成测试毕竟还是会拖慢整个CI build的时间，所以才会有我问的那个问题。所以矛盾点在于，我们的业务逻辑其实在service层，service层不会去写集成测试，那测试复杂逻辑就比较难受，我现在的做法是把复杂逻辑给分到一个单独的组件，现有的service的方法只是调用新的组件，拿到结果，保存。这样我就可以去给单独拆分的组件写单元测试来测试复杂逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655626935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344609,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1651669046,"is_pvip":false,"replies":[{"id":125765,"content":"感谢分享，不过严格说这并不是一个单元测试，因为它没有测任何功能，而是测了PayWayEnum这个枚举的定义。","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1651672519,"ip_address":"","comment_id":344609,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100111101,"comment_content":"分享一个简单但却非常重要的测试，因为如果数据重复了，将导致支付功能异常\n\n@Getter\npublic enum PayWayEnum {\n    APPLE(1, &quot;Apple支付&quot;),\n    HUAWEI(2, &quot;华为支付&quot;),\n    ALI_APP(3, &quot;支付宝App支付&quot;),\n    WX_APP(4, &quot;微信App支付&quot;),\n    ;\n\n    private int value;\n    private String name;\n\n    PayWayEnum(int value, String name) {\n        this.value = value;\n        this.name = name;\n    }\n}\n\nclass PayWayEnumTest {\n    @Test\n    void no_duplicate_value(){\n        PayWayEnum[] values = PayWayEnum.values();\n        long size = Arrays.stream(values)\n                .map(PayWayEnum::getValue)\n                .distinct().count();\n        assertEquals(values.length, size);\n    }\n}","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570131,"discussion_content":"感谢分享，不过严格说这并不是一个单元测试，因为它没有测任何功能，而是测了PayWayEnum这个枚举的定义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651672519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"discussion":{"id":570237,"discussion_content":"谢谢老师点评，我再去找一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651714206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":570131,"ip_address":"","group_id":0},"score":570237,"extra":""}]}]},{"had_liked":false,"id":367861,"user_name":"fliyu","can_delete":false,"product_type":"c1","uid":1588873,"ip_address":"广东","ucode":"E80D318348CA47","user_header":"https://static001.geekbang.org/account/avatar/00/18/3e/89/77829168.jpg","comment_is_top":false,"comment_ctime":1675686512,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100111101,"comment_content":"mock框架整起来，GoConvey、GoStub、GoMock、GoMonkey和Sqlmock","like_count":1},{"had_liked":false,"id":395160,"user_name":"Stay_Gold","can_delete":false,"product_type":"c1","uid":1119904,"ip_address":"湖北","ucode":"ACB8DCD2EF8F95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2NTTABPFibg2k9tZscOOKx9wu80a85d5HspCorO9Nibj7Z7q9v1icPTVm5ia52r0RCzEaA/132","comment_is_top":false,"comment_ctime":1729645974,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":3,"product_id":100111101,"comment_content":"看了老师的课程真的惊为天人，从各种细节都可以看出老师是踩过重构和测试的各种坑，然后总结的一套适用于实际工作的修改遗留系统方法。\n之前也都给看过《重构》，《修改代码的艺术》这些大名鼎鼎的书籍，但是看完后虽然也感觉很有收获，但是总是再结合实际项目操作的时候达不到想要的感觉。\n看到老师的很多描述和实际代码的例子，让自己有了更加深刻的理解。\n当然要达到灵活运用还是需要更多的练习，这是逃避不了的。\n但是老师的课程真的给我一种豁然开朗的感觉，这也许就是真实项目和真实经验心心相通的原因。","like_count":0},{"had_liked":false,"id":363044,"user_name":"pcz","can_delete":false,"product_type":"c1","uid":2367637,"ip_address":"上海","ucode":"D528F5CFF4A5C9","user_header":"https://static001.geekbang.org/account/avatar/00/24/20/95/89bd2c38.jpg","comment_is_top":false,"comment_ctime":1669182451,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100111101,"comment_content":"不能同意更多，越是高手，越注重单元测试","like_count":0},{"had_liked":false,"id":358885,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"江苏","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1664969111,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100111101,"comment_content":"怎么说呢？单元测试在国内公司，目前基本是很难推行的，第一点，代码规范千奇百怪的，另外一点随着时间的流逝，项目代码也是一言难尽；另外就算有写单元测试的硬性要求并设设置的覆盖率指标，大部分都是为了完成指标数据，真的说要好好考虑如何写单元测试然后有效率的写，并且在实际的工作中反向帮助到项目开发的质量，真的是少之又少，我接触到的大部分都是质量团队设立覆盖率指标，开发团队就无脑的完成指标就好，真的是浪费人力与物力成本！！","like_count":0}]}