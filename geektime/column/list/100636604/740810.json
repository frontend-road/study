{"id":740810,"title":"第 10 章 枚举与模式","content":"\n<blockquote>\n<p>在计算机领域，总和类型（sum type）长期悲剧性缺位，很多事情却依然行得通，这简直不可思议（参见 Lambda 的缺位）。<span class=\"comment-number\">1</span></p>\n<p style=\"text-align: right\">——Graydon Hoare</p>\n</blockquote>\n\n<p>&nbsp;</p>\n<p>本章的第一个主题强劲有力且非常“古老”，它能帮助你在短期内完成很多事（但要付出一定代价），并且许多文化中有关于它的传说。我要说的不是“恶魔”，而是一种用户定义数据类型，长期以来被 ML 社区和 Haskell 社区的黑客们称为总和类型、可区分的联合体（union）或代数数据类型。在 Rust 中，它们被称为<strong>枚举</strong>。与“恶魔”不同，它们相当安全，而且也不用付出多少代价。</p>\n<p>C++ 和 C# 都有枚举，你可以使用它们来定义自己的类型，其值是一组命名常量。例如，你可以定义一个名为 <code>Color</code> 的类型，其值为 <code>Red</code>、<code>Orange</code>、<code>Yellow</code> 等。这种枚举也适用于 Rust，但是 Rust 的枚举远不止于此。Rust 枚举还可以包含数据，甚至是不同类型的数据。例如，Rust 的 <code>Result&lt;String, io::Error&gt;</code> 类型就是一个枚举，这样的值要么是包含 <code>String</code> 型的 <code>Ok</code> 值，要么是包含 <code>io::Error</code> 的 <code>Err</code> 值。C++ 枚举和 C# 枚举则不具备这样的能力。Rust 枚举更像是 C 的联合体，但不同之处在于它是类型安全的。</p><!-- [[[read_end]]] -->\n<p>只要值可能代表多种事物，枚举就很有用。使用枚举的“代价”是你必须通过模式匹配安全地访问数据，这是本章后半部分的主题。</p>\n<p>如果你用过 Python 中的解包或 JavaScript 中的解构，那么应该很熟悉“模式”这个词，但 Rust 的模式不止于此。Rust 模式有点儿像针对所有数据的正则表达式。它们用于测试一个值是否具有特定的目标形态，可以一次从结构体或元组中把多个字段提取到局部变量中。</p>\n<p>和正则表达式一样，模式很简洁，通常能在一行代码中完成全部工作。</p>\n<p>本章从枚举的基础知识讲起，首先展示数据如何关联到枚举的各个变体，以及枚举如何存储在内存中；然后展示 Rust 的模式和 <code>match</code>（匹配）语句如何基于枚举、结构体、数组和切片简洁地表达逻辑。模式中还可以包含引用、移动和 <code>if</code> 条件，来让自己更加强大。</p>\n<h2 id=\"nav_point_167\">10.1　枚举</h2>\n<p>Rust 中简单的 C 风格枚举很直观：</p>\n<pre class=\"code-rows\"><code>enum Ordering {\n    Less,\n    Equal,\n    Greater,\n}</code></pre>\n<p>这声明了一个具有 3 个可能值的 <code>Ordering</code> 类型，称为<strong>变体</strong>或<strong>构造器</strong>：<code>Ordering::Less</code>、<code>Ordering::Equal</code> 和 <code>Ordering::Greater</code>。这个特殊的枚举是标准库的一部分，因此 Rust 代码能够直接导入它：</p>\n<pre class=\"code-rows\"><code>use std::cmp::Ordering;\n\nfn compare(n: i32, m: i32) -&gt; Ordering {\n    if n &lt; m {\n        Ordering::Less\n    } else if n &gt; m {\n        Ordering::Greater\n    } else {\n        Ordering::Equal\n    }\n}</code></pre>\n<p>或连同其所有构造器一同导入：</p>\n<pre class=\"code-rows\"><code>use std::cmp::Ordering::;    // `*`导入所有子项\n\nfn compare(n: i32, m: i32) -&gt; Ordering {\n    if n &lt; m {\n        Less\n    } else if n &gt; m {\n        Greater\n    } else {\n        Equal\n    }\n}</code></pre>\n<p>导入构造器后，我们就可以写成 <code>Less</code> 而非 <code>Ordering::Less</code>，等等，但是因为这样写意思不太明确，所以通常认为<strong>不导入</strong>构造器的那种风格更好，除非导入它们能让你的代码更具可读性。</p>\n<p>要导入当前模块中声明的枚举的构造器，请使用 <code>self</code>：</p>\n<pre class=\"code-rows\"><code>enum Pet {\n    Orca,\n    Giraffe,\n    ...\n}\n\nuse self::Pet::*;</code></pre>\n<p>在内存中，C 风格枚举的各个值会存储为整数。有时告诉 Rust 要使用哪几个整数是很有用的：</p>\n<pre class=\"code-rows\"><code>enum HttpStatus {\n    Ok = 200,\n    NotModified = 304,\n    NotFound = 404,\n    ...\n}</code></pre>\n<p>否则 Rust 会从 0 开始帮你分配数值。</p>\n<p>默认情况下，Rust 会使用可以容纳它们的最小内置整数类型来存储 C 风格枚举。最适合的是单字节：</p>\n<pre class=\"code-rows\"><code>use std::mem::size_of;\nassert_eq!(size_of::&lt;Ordering&gt;(), 1);\nassert_eq!(size_of::&lt;HttpStatus&gt;(), 2);  // 404不适合存入u8</code></pre>\n<p>你可以通过向枚举添加 <code>#[repr]</code> 属性来覆盖 Rust 对内存中表示法的默认选择。有关详细信息，请参阅 23.1 节。</p>\n<p>可以将 C 风格枚举转换为整数：</p>\n<pre class=\"code-rows\"><code>assert_eq!(HttpStatus::Ok as i32, 200);</code></pre>\n<p>从整数到枚举的反向转换则行不通。与 C 和 C++ 不同，Rust 会保证枚举值必然是 <code>enum</code> 声明中阐明的值之一。从整数类型到枚举类型的非检查转换可能会破坏此保证，因此不允许这样做。你可以编写自己的“检查完再转换”逻辑：</p>\n<pre class=\"code-rows\"><code>fn http_status_from_u32(n: u32) -&gt; Option&lt;HttpStatus&gt; {\n    match n {\n        200 =&gt; Some(HttpStatus::Ok),\n        304 =&gt; Some(HttpStatus::NotModified),\n        404 =&gt; Some(HttpStatus::NotFound),\n        ...\n        _ =&gt; None,\n    }\n}</code></pre>\n<p>或者借助 <code>enum_primitive</code> crate。它包含一个宏，可以帮你自动生成这类转换代码。</p>\n<p>与结构体一样，编译器能为你实现 <code>==</code> 运算符等特性，但你必须明确提出要求：</p>\n<pre class=\"code-rows\"><code>#[derive(Copy, Clone, Debug, PartialEq, Eq)]\nenum TimeUnit {\n    Seconds, Minutes, Hours, Days, Months, Years,\n}</code></pre>\n<p>枚举可以有方法，就像结构体一样：</p>\n<pre class=\"code-rows\"><code>impl TimeUnit {\n    /// 返回此时间单位的复数名词\n    fn plural(self) -&gt; &amp;'static str {\n        match self {\n            TimeUnit::Seconds =&gt; \"seconds\",\n            TimeUnit::Minutes =&gt; \"minutes\",\n            TimeUnit::Hours =&gt; \"hours\",\n            TimeUnit::Days =&gt; \"days\",\n            TimeUnit::Months =&gt; \"months\",\n            TimeUnit::Years =&gt; \"years\",\n        }\n    }\n\n    /// 返回此时间单位的单数名词\n    fn singular(self) -&gt; &amp;'static str {\n        self.plural().trim_end_matches('s')\n    }\n}</code></pre>\n<p>至此，C 风格枚举就介绍完了。更有趣的 Rust 枚举类型是其变体中能持有数据的类型。我们将展示如何将它们存储在内存中、如何通过添加类型参数来泛化它们，以及如何运用枚举构建复杂的数据结构。</p>\n<h3 id=\"nav_point_168\">10.1.1　带数据的枚举</h3>\n<p>有些程序总是要显示精确到毫秒的完整日期和时间，但对大多数应用程序来说，使用粗略的近似值（比如“两个月前”）对用户更友好。我们可以使用之前定义的枚举来编写一个新的 <code>enum</code>，以帮忙解决此问题：</p>\n<pre class=\"code-rows\"><code>/// 刻意四舍五入后的时间戳，所以程序会显示“6个月前”\n/// 而非“2016年2月9日上午9点49分”\n#[derive(Copy, Clone, Debug, PartialEq)]\nenum RoughTime {\n    InThePast(TimeUnit, u32),\n    JustNow,\n    InTheFuture(TimeUnit, u32),\n}</code></pre>\n<p>此枚举中的两个变体 <code>InThePast</code> 和 <code>InTheFuture</code> 能接受参数。这种变体叫作<strong>元组型变体</strong>。与元组型结构体一样，这些构造器也是可创建新 <code>RoughTime</code> 值的函数：</p>\n<pre class=\"code-rows\"><code>let four_score_and_seven_years_ago =\n    RoughTime::InThePast(TimeUnit::Years, 4 * 20 + 7);\n\nlet three_hours_from_now =\n    RoughTime::InTheFuture(TimeUnit::Hours, 3);</code></pre>\n<p>枚举还可以有<strong>结构体型变体</strong>，就像普通结构体一样包含一些具名字段：</p>\n<pre class=\"code-rows\"><code>enum Shape {\n    Sphere { center: Point3d, radius: f32 },\n    Cuboid { corner1: Point3d, corner2: Point3d },\n}\n\nlet unit_sphere = Shape::Sphere {\n    center: ORIGIN,\n    radius: 1.0,\n};</code></pre>\n<p>总而言之，Rust 有 3 种枚举变体，这与我们在第 9 章中展示的 3 种结构体相呼应。没有数据的变体对应于单元型结构体。元组型变体的外观和功能很像元组型结构体。结构体型变体具有花括号和具名字段。单个枚举中可以同时有 3 种类型的变体：</p>\n<pre class=\"code-rows\"><code>enum RelationshipStatus {\n    Single,\n    InARelationship,\n    ItsComplicated(Option&lt;String&gt;),\n    ItsExtremelyComplicated {\n        car: DifferentialEquation,\n        cdr: EarlyModernistPoem,\n    },\n}</code></pre>\n<p>枚举的所有构造器和字段都与枚举本身具有相同的可见性。</p>\n<h3 id=\"nav_point_169\">10.1.2　内存中的枚举</h3>\n<p>在内存中，带有数据的枚举会以一个小型整数<strong>标签</strong>加上足以容纳最大变体中所有字段的内存块的格式进行存储。标签字段供 Rust 内部使用。它会区分由哪个构造器创建了值，进而决定这个值应该有哪些字段。</p>\n<p>从 Rust 1.50 开始，<code>RoughTime</code> 会占用 8 字节，如图 10-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00849.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-1：内存中的 <code>RoughTime</code> 值</strong></p>\n<p>不过，为了给将来的优化留下余地，Rust 并没有对枚举的内存布局做出任何承诺。在某些情况下，Rust 可以比图 10-1 中展示的布局更有效地打包枚举。例如，有些泛型结构体可以在不需要标签的情况下存储，稍后我们会介绍。</p>\n<h3 id=\"nav_point_170\">10.1.3　用枚举表示富数据结构</h3>\n<p>枚举对于快速实现树形数据结构也很有用。假设一个 Rust 程序需要处理任意 JSON 数据。在内存中，任何 JSON 文档都可以表示为这种 Rust 类型的值：</p>\n<pre class=\"code-rows\"><code>use std::collections::HashMap;\n\nenum Json {\n    Null,\n    Boolean(bool),\n    Number(f64),\n    String(String),\n    Array(Vec&lt;Json&gt;),\n    Object(Box&lt;HashMap&lt;String, Json&gt;&gt;),\n}</code></pre>\n<p>用自然语言解释这种数据结构还不如直接看 Rust 代码。JSON 标准指定了可以出现在 JSON 文档中的不同数据类型：<code>null</code>、布尔值、数值、字符串、各种 JSON 值的数组以及具有字符串键名和 JSON 值的对象。这里的 <code>Json</code> 枚举只是简单地列出了这些类型而已。</p>\n<p>这不是一个假想的例子。可以在 <code>serde_json</code> 中找到一个非常相似的枚举，<code>serde_json</code> 是 Rust 的结构体序列化库，是 crates.io 上最常下载的 crate 之一。</p>\n<p>这里在表示 <code>Object</code> 的 <code>HashMap</code> 周围加 <code>Box</code> 只是为了让所有 <code>Json</code> 值更紧凑。在内存中，<code>Json</code> 类型的值占用 4 个机器字。而 <code>String</code> 值和 <code>Vec</code> 值占用 3 个机器字，Rust 又添加了一个标签字节。<code>Null</code> 值和 <code>Boolean</code> 值中没有足够的数据来用完所有空间，但所有 <code>Json</code> 值的大小必须相同。因此，额外的空间就用不上了。图 10-2 展示了 <code>Json</code> 值在内存中的实际布局的一些示例。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00850.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-2：内存中的 <code>Json</code> 值</strong></p>\n<p><code>HashMap</code> 则更大。如果必须在每个 <code>Json</code> 值中为它留出空间，那么将会非常大，在 8 个机器字左右。但是 <code>Box&lt;HashMap&gt;</code> 是 1 个机器字：它只是指向堆中分配的数据的指针。我们甚至可以通过装箱更多字段来让 <code>Json</code> 更加紧凑。</p>\n<p>这里值得注意的是用 Rust 建立这个结构有多么容易。在 C++ 中，可能要为此编写一个类：</p>\n<pre class=\"code-rows\"><code>class JSON {\nprivate:\n    enum Tag {\n        Null, Boolean, Number, String, Array, Object\n    };\n    union Data {\n        bool boolean;\n        double number;\n        shared_ptr&lt;string&gt; str;\n        shared_ptr&lt;vector&lt;JSON&gt;&gt; array;\n        shared_ptr&lt;unordered_map&lt;string, JSON&gt;&gt; object;\n\n        Data() {}\n        ~Data() {}\n        ...\n    };\n\n    Tag tag;\n    Data data;\n\npublic:\n    bool is_null() const { return tag == Null; }\n    bool is_boolean() const { return tag == Boolean; }\n    bool get_boolean() const {\n        assert(is_boolean());\n        return data.boolean;\n    }\n    void set_boolean(bool value) {\n        this-&gt;~JSON();  // 清理string/array/object值\n        tag = Boolean;\n        data.boolean = value;\n    }\n    ...\n};</code></pre>\n<p>写了 30 行代码，我们才刚开了个头。这个类将需要构造函数、析构函数和赋值运算符。还有一种方法是创建一个具有基类 <code>JSON</code> 和子类 <code>JSONBoolean</code>、<code>JSONString</code> 等的类层次结构。无论采用哪种方法，操作完成时，我们的 C++ 版 JSON 库都将有十几个方法。其他程序员需要阅读一定的内容才能掌握并使用它。而整个 Rust 枚举才 8 行代码。</p>\n<h3 id=\"nav_point_171\">10.1.4　泛型枚举</h3>\n<p>枚举可以是泛型的。Rust 标准库中的两个例子是该语言中最常用的数据类型：</p>\n<pre class=\"code-rows\"><code>enum Option&lt;T&gt; {\n    None,\n    Some(T),\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}</code></pre>\n<p>现在你已经很熟悉这些类型了，泛型枚举的语法与泛型结构体是一样的。</p>\n<p>一个不太明显的细节是，当类型 <code>T</code> 是引用、<code>Box</code> 或其他智能指针类型时，Rust 可以省掉 <code>Option&lt;T&gt;</code> 的标签字段。由于这些指针类型都不允许为 0，因此 Rust 可以将 <code>Option&lt;Box&lt;i32&gt;&gt;</code> 表示为单个机器字：0 表示 <code>None</code>，非零表示 <code>Some</code> 指针。这能让 <code>Option</code> 类型的值尽量接近于可能为空的 C 或 C++ 指针。不同之处在于 Rust 的类型系统要求你在使用其内容之前检查 <code>Option</code> 是否为 <code>Some</code>。这有效地避免了对空指针解引用。</p>\n<p>只需几行代码就可以构建出泛型数据结构：</p>\n<pre class=\"code-rows\"><code>// `T`组成的有序集合\nenum BinaryTree&lt;T&gt; {\n    Empty,\n    NonEmpty(Box&lt;TreeNode&lt;T&gt;&gt;),\n}\n\n// BinaryTree的部件\nstruct TreeNode&lt;T&gt; {\n    element: T,\n    left: BinaryTree&lt;T&gt;,\n    right: BinaryTree&lt;T&gt;,\n}</code></pre>\n<p>这几行代码定义了一个 <code>BinaryTree</code> 类型，它可以存储任意数量的 <code>T</code> 类型的值。</p>\n<p>这两个定义中包含了大量信息，因此我们需要花点儿时间逐字解释这些代码。每个 <code>BinaryTree</code> 值要么是 <code>Empty</code>，要么是 <code>NonEmpty</code>。如果是 <code>Empty</code>，那它根本不含任何数据。如果是 <code>NonEmpty</code>，那它就会有一个 <code>Box</code>，即一个指向堆上分配的 <code>TreeNode</code> 的指针。</p>\n<p>每个 <code>TreeNode</code> 值包含一个实际元素以及另外两个 <code>BinaryTree</code> 值。这意味着树可以包含子树，因此 <code>NonEmpty</code> 树可以有任意数量的后代。</p>\n<p><code>BinaryTree&lt;&amp;str&gt;</code> 类型值的示意图如图 10-3 所示。与 <code>Option&lt;Box&lt;T&gt;&gt;</code> 一样，Rust 在这里也省略了标签字段，因此 <code>BinaryTree</code> 值占用一个机器字。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00851.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-3：包含 6 个字符串的 <code>BinaryTree</code></strong></p>\n<p>在此树中构建任何特定节点都很简明直观：</p>\n<pre class=\"code-rows\"><code>use self::BinaryTree::*;\nlet jupiter_tree = NonEmpty(Box::new(TreeNode {\n    element: \"Jupiter\",\n    left: Empty,\n    right: Empty,\n}));</code></pre>\n<p>较大的树可以基于较小的树来构建：</p>\n<pre class=\"code-rows\"><code>let mars_tree = NonEmpty(Box::new(TreeNode {\n    element: \"Mars\",\n    left: jupiter_tree,\n    right: mercury_tree,\n}));</code></pre>\n<p>自然，此赋值会将 <code>jupiter_node</code> 和 <code>mercury_node</code> 的所有权转移给它们的新父节点。</p>\n<p>树的其余部分都遵循同样的模式。根节点与其他节点没有什么区别：</p>\n<pre class=\"code-rows\"><code>let tree = NonEmpty(Box::new(TreeNode {\n    element: \"Saturn\",\n    left: mars_tree,\n    right: uranus_tree,\n}));</code></pre>\n<p>稍后本章将展示如何在 <code>BinaryTree</code> 类型上实现一个 <code>add</code> 方法，以便像下面这样写：</p>\n<pre class=\"code-rows\"><code>let mut tree = BinaryTree::Empty;\nfor planet in planets {\n    tree.add(planet);\n}</code></pre>\n<p>无论你的语言背景如何，在 Rust 中创建像 <code>BinaryTree</code> 这样的数据结构都可能需要做一些练习。起初并不容易看出应该把这些 <code>Box</code> 放在哪里。找到可行设计方案的方法之一是画出图 10-3 那样的图，展示你希望这些数据在内存中如何布局。然后从图片倒推出代码。每组方块都表示一个结构体或元组，每个箭头都是一个 <code>Box</code> 或其他智能指针。弄清楚每个字段的类型虽然有点儿难，但仍然是可以解决的。解决此难题的回报是对程序内存进行了更好的控制。</p>\n<p>现在再来说一下本章开头提过的“代价”。枚举的标签字段会占用一点儿内存，最坏情况下可达 8 字节，但这通常可以忽略不计。枚举的真正缺点（如果一定要算的话）是，虽然这些字段真的存在于值中，但 Rust 代码不允许你直接访问它们：</p>\n<pre class=\"code-rows\"><code>let r = shape.radius;  // 错误：在`Shape`类型上没有`radius`字段</code></pre>\n<p>只能用一种安全的方式来访问枚举中的数据，即使用模式。</p>\n<h2 id=\"nav_point_172\">10.2　模式</h2>\n<p>回忆一下本章前面定义过的 <code>RoughTime</code> 类型：</p>\n<pre class=\"code-rows\"><code>enum RoughTime {\n    InThePast(TimeUnit, u32),\n    JustNow,\n    InTheFuture(TimeUnit, u32),\n}</code></pre>\n<p>假设你有一个 <code>RoughTime</code> 值并希望把它显示在网页上。你需要访问值内的 <code>TimeUnit</code> 字段和 <code>u32</code> 字段。Rust 不允许你通过编写 <code>rough_time.0</code> 和 <code>rough_time.1</code> 来直接访问它们，因为毕竟 <code>rough_time</code> 也可能是没有字段的，比如 <code>RoughTime::JustNow</code>。那么，怎样才能获得数据呢？</p>\n<p>你需要一个 <code>match</code> 表达式：</p>\n<pre class=\"code-rows\"><code> 1  fn rough_time_to_english(rt: RoughTime) -&gt; String {\n 2      match rt {\n 3          RoughTime::InThePast(units, count) =&gt;\n 4              format!(\"{} {} ago\", count, units.plural()),\n 5          RoughTime::JustNow =&gt;\n 6              format!(\"just now\"),\n 7          RoughTime::InTheFuture(units, count) =&gt;\n 8              format!(\"{} {} from now\", count, units.plural()),\n 9      }\n10  }</code></pre>\n<p><code>match</code> 会执行模式匹配，在此示例中，<strong>模式</strong>就是第 3 行、第 5 行和第 7 行中出现在 <code>=&gt;</code> 符号前面的部分。匹配 <code>RoughTime</code> 值的模式很像用于创建 <code>RoughTime</code> 值的表达式。这是刻意的设计。表达式会<strong>生成</strong>值，模式会<strong>消耗</strong>值。两者刻意使用了很多相同的语法。</p>\n<p>我们分步了解一下此 <code>match</code> 表达式在运行期会发生什么。假设 <code>rt</code> 是 <code>RoughTime::InTheFuture(TimeUnit::Months, 1)</code> 的值。Rust 会首先尝试将这个值与第 3 行的模式相匹配。如图 10-4 所示，二者不匹配。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00852.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-4：不匹配的 <code>RoughTime</code> 值和模式</strong></p>\n<p>对于枚举、结构体或元组类型的匹配，Rust 的工作方式就像简单地从左到右进行扫描一样，会检查模式的每个组件以查看该值是否与之匹配。如果不匹配，Rust 就会接着尝试下一个模式。</p>\n<p>第 3 行和第 5 行的模式都不匹配，但是第 7 行的模式匹配成功了，如图 10-5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00853.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-5：一次成功的匹配</strong></p>\n<p>模式中包含的简单标识符（如 <code>units</code> 和 <code>count</code>）会成为模式后面代码中的局部变量。值中存在的任何内容都会复制或移动到新变量中。Rust 会在 <code>units</code> 中存储 <code>TimeUnit::Months</code>，在 <code>count</code> 中存储 <code>1</code>，然后运行第 <code>8</code> 行代码，并返回字符串 <code>\"1 months from now\"</code>。</p>\n<p>该输出有一个小小的英语语法问题（未处理复数），可以通过在 <code>match</code> 中添加另一个分支来解决：</p>\n<pre class=\"code-rows\"><code>RoughTime::InTheFuture(unit, 1) =&gt;\n    format!(\"a {} from now\", unit.singular()),</code></pre>\n<p>仅当 <code>count</code> 字段恰好为 <code>1</code> 时，才会匹配此分支。请注意，这行新代码必须添加到第 7 行之前。如果将其添加到末尾，那么 Rust 将永远无法访问它，因为第 7 行的模式会匹配所有 <code>InTheFuture</code> 值。如果你犯了这种错误，那么 Rust 编译器将警告发现了 <code>\"unreachable pattern\"</code>（无法抵达的模式）。</p>\n<p>即使用了新代码，<code>RoughTime::InTheFuture(TimeUnit::Hours, 1)</code> 仍然存在问题：<code>\"a hour from now\"</code> 这个结果不太正确。唉，这就是英语啊。这也可以通过在 <code>match</code> 中添加另一个分支来解决。</p>\n<p>如本示例所示，模式匹配可以和枚举协同工作，甚至可以测试它们包含的数据，这让 <code>match</code> 成了 C 的 <code>switch</code> 语句的强大而灵活的替代品。迄今为止，我们只看到了匹配枚举值的模式。但模式的类型不止于此，Rust 模式还有它们自己的小型语言，如表 10-1 所示。我们将用本章剩余的大部分内容来介绍此表中展示的特性。</p>\n<p><strong>表 10-1：模式</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>模式类型</p></th>\n<th><p>例子</p></th>\n<th><p>注意事项</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>字面量</p></td>\n<td><p><code>100</code><br /><code>\"name\"</code></p></td>\n<td><p>匹配一个确切的值；也允许匹配常量名称</p></td>\n</tr>\n<tr>\n<td><p>范围</p></td>\n<td><p><code>0 ..= 100</code><br /><code>'a' ..= 'k'</code><br /><code>256..</code></p></td>\n<td><p>匹配范围内的任何值，包括可能给定的结束值</p></td>\n</tr>\n<tr>\n<td><p>通配符</p></td>\n<td><p><code>_</code></p></td>\n<td><p>匹配任何值并忽略它</p></td>\n</tr>\n<tr>\n<td><p>变量</p></td>\n<td><p><code>name</code><br /><code>mut count</code></p></td>\n<td><p>类似于 <code>_</code>，但会把值移动或复制到新的局部变量中</p></td>\n</tr>\n<tr>\n<td><p>引用变量</p></td>\n<td><p><code>ref field</code><br /><code>ref mut field</code></p></td>\n<td><p>借用对匹配值的引用，而不是移动或复制它</p></td>\n</tr>\n<tr>\n<td><p>与子模式绑定</p></td>\n<td><p><code>val @ 0 ..= 99</code><br /><code>ref circle @ Shape::Circle { .. }</code></p></td>\n<td><p>使用 <code>@</code> 左边的变量名，匹配其右边的模式</p></td>\n</tr>\n<tr>\n<td><p>枚举型模式</p></td>\n<td><p><code>Some(value)</code><br /><code>None</code><br /><code>Pet::Orca</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>元组型模式</p></td>\n<td><p><code>(key, value)</code><br /><code>(r, g, b)</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>数组型模式</p></td>\n<td><p><code>[a, b, c, d, e, f, g]</code><br /><code>[heading, carom, correction]</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>切片型模式</p></td>\n<td><p><code>[first, second]</code><br /><code>[first, _, third]</code><br /><code>[first, .., nth]</code><br /><code>[ ]</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>结构体型模式</p></td>\n<td><p><code>Color(r, g, b)</code><br /><code>Point { x, y }</code><br /><code>Card { suit: Clubs, rank: n }</code><br /><code>Account { id, name, .. }</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>引用</p></td>\n<td><p><code>&amp;value</code><br /><code>&amp;(k, v)</code></p></td>\n<td><p>仅匹配引用值</p></td>\n</tr>\n<tr>\n<td><p>或多个模式</p></td>\n<td><p><code>'a' | 'A'</code><br /><code>Some(\"left\" | \"right\")</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>守卫表达式</p></td>\n<td><p><code>x if x * x &lt;= r2</code></p></td>\n<td><p>只用在 <code>match</code> 表达式中（不能用在 <code>let</code> 语句等处）</p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_173\">10.2.1　模式中的字面量、变量和通配符</h3>\n<p>迄今为止，我们已经展示了如何借助 <code>match</code> 表达式来使用枚举。<code>match</code> 也可用来匹配其他类型。当你需要类似 C 语言的 <code>switch</code> 语句的内容时，可以使用针对整数值的 <code>match</code>。像 <code>0</code> 和 <code>1</code> 这样的整型字面量都可以作为模式使用：</p>\n<pre class=\"code-rows\"><code>match meadow.count_rabbits() {\n    0 =&gt; {}  // 无话可说\n    1 =&gt; println!(\"A rabbit is nosing around in the clover.\"),\n    n =&gt; println!(\"There are {} rabbits hopping about in the meadow\", n),\n}</code></pre>\n<p>如果草地上没有兔子，就匹配模式 <code>0</code>；如果只有一只兔子，就匹配模式 <code>1</code>；如果有两只或更多的兔子，就匹配第三个模式，即模式 <code>n</code>。模式 <code>n</code> 只是一个变量名，它可以匹配任何值，匹配的值会移动或复制到一个新的局部变量中。所以在这种情况下，<code>meadow.count_rabbits()</code> 的值会存储在一个新的局部变量 <code>n</code> 中，然后打印出来。</p>\n<p>其他字面量也可以用作模式，包括布尔值、字符，甚至字符串：</p>\n<pre class=\"code-rows\"><code>let calendar = match settings.get_string(\"calendar\") {\n    \"gregorian\" =&gt; Calendar::Gregorian,\n    \"chinese\" =&gt; Calendar::Chinese,\n    \"ethiopian\" =&gt; Calendar::Ethiopian,\n    other =&gt; return parse_error(\"calendar\", other),\n};</code></pre>\n<p>在这个例子中，<code>other</code> 就像上个例子中的 <code>n</code> 一样充当了包罗万象的模式。这些模式与 <code>switch</code> 语句中的 <code>default</code> 分支起着相同的作用，用于匹配与任何其他模式都无法匹配的值。</p>\n<p>如果你需要一个包罗万象的模式，但又不关心匹配到的值，那么可以用单个下划线 <code>_</code> 作为模式，这就是<strong>通配符模式</strong>：</p>\n<pre class=\"code-rows\"><code>let caption = match photo.tagged_pet() {\n    Pet::Tyrannosaur =&gt; \"RRRAAAAAHHHHHH\",\n    Pet::Samoyed =&gt; \"*dog thoughts*\",\n    _ =&gt; \"I'm cute, love me\", // 一般性捕获，对任意Pet都生效\n};</code></pre>\n<p>这里的通配符模式能匹配任意值，但不会将其存储到任何地方。由于 Rust 要求每个 <code>match</code> 表达式都必须处理所有可能的值，因此最后往往需要一个通配符模式。即使你非常确定其他情况不会发生，也必须至少添加一个后备分支，也许是 panic 的分支。</p>\n<pre class=\"code-rows\"><code>// 有很多种形状（Shape），但我们只支持“选中”一些文本框\n// 或者矩形区域中的所有内容。不能选择椭圆或梯形\nmatch document.selection() {\n    Shape::TextSpan(start, end) =&gt; paint_text_selection(start, end),\n    Shape::Rectangle(rect) =&gt; paint_rect_selection(rect),\n    _ =&gt; panic!(\"unexpected selection type\"),\n}</code></pre>\n<h3 id=\"nav_point_174\">10.2.2　元组型模式与结构体型模式</h3>\n<p>元组型模式匹配元组。每当你想要在单次 <code>match</code> 中获取多条数据时，元组型模式都非常有用：</p>\n<pre class=\"code-rows\"><code>fn describe_point(x: i32, y: i32) -&gt; &amp;'static str {\n    use std::cmp::Ordering::*;\n    match (x.cmp(&amp;0), y.cmp(&amp;0)) {\n        (Equal, Equal) =&gt; \"at the origin\",\n        (_, Equal) =&gt; \"on the x axis\",\n        (Equal, _) =&gt; \"on the y axis\",\n        (Greater, Greater) =&gt; \"in the first quadrant\",\n        (Less, Greater) =&gt; \"in the second quadrant\",\n        _ =&gt; \"somewhere else\",\n    }\n}</code></pre>\n<p>结构体型模式使用花括号，就像结构体表达式一样。结构体型模式包含每个字段的子模式：</p>\n<pre class=\"code-rows\"><code>match balloon.location {\n    Point { x: 0, y: height } =&gt;\n        println!(\"straight up {} meters\", height),\n    Point { x: x, y: y } =&gt;\n        println!(\"at ({}m, {}m)\", x, y),\n}</code></pre>\n<p>在此示例中，如果匹配了第一个分支，则 <code>balloon.location.y</code> 会存储在新的局部变量 <code>height</code> 中。</p>\n<p>假设 <code>balloon.location</code> 的值是 <code>Point { x: 30, y: 40 }</code>。像往常一样，Rust 会依次检查每个模式的每个组件，如图 10-6 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00854.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-6：与结构体的模式匹配</strong></p>\n<p>这会匹配第二个分支，所以输出是 <code>at (30m, 40m)</code>。</p>\n<p>像 <code>Point { x: x, y: y }</code> 这样的模式在匹配结构体时很常见，而冗余的名称会造成视觉上的混乱，所以 Rust 对此有一个简写形式：<code>Point </code>。二者的含义是一样的。<code>Point </code> 仍会将某个点的 <code>x</code> 字段和 <code>y</code> 字段分别存储在新的本地变量 <code>x</code> 和 <code>y</code> 中。</p>\n<p>即使用了简写形式，当我们只关心几个字段时，匹配大型结构体仍然很麻烦：</p>\n<pre class=\"code-rows\"><code>match get_account(id) {\n    ...\n    Some(Account {\n            name, language,  // &lt;---这两个变量才是我们关心的\n            id: _, status: _, address: _, birthday: _, eye_color: _,\n            pet: _, security_question: _, hashed_innermost_secret: _,\n            is_adamantium_preferred_customer: _, }) =&gt;\n        language.show_custom_greeting(name),\n}</code></pre>\n<p>为避免这种情况，可以使用 <code>..</code> 告诉 Rust 你不关心任何其他字段。</p>\n<pre class=\"code-rows\"><code>Some(Account { name, language, .. }) =&gt;\n    language.show_custom_greeting(name),</code></pre>\n<h3 id=\"nav_point_175\">10.2.3　数组型模式与切片型模式</h3>\n<p>数组型模式匹配数组。数组型模式通常用于过滤一些特殊情况的值，并且在处理那些不同位置的值具有不同含义的数组时也非常有用。</p>\n<p>例如，在将 HSL（色相、饱和度和亮度）颜色值转换为 RGB（红色、绿色和蓝色）颜色值时，具有零亮度或全亮度的颜色只会是黑色或白色。可以使用 <code>match</code> 表达式来简单地处理这些情况。</p>\n<pre class=\"code-rows\"><code>fn hsl_to_rgb(hsl: [u8; 3]) -&gt; [u8; 3] {\n    match hsl {\n        [_, _, 0] =&gt; [0, 0, 0],\n        [_, _, 255] =&gt; [255, 255, 255],\n        ...\n    }\n}</code></pre>\n<p>切片型模式也与此相似，但与数组不同，切片具有可变长度，因此切片型模式不仅匹配值，还匹配长度。<code>..</code> 在切片型模式中能匹配任意数量的元素。</p>\n<pre class=\"code-rows\"><code>fn greet_people(names: &amp;[&amp;str]) {\n    match names {\n        [] =&gt; { println!(\"Hello, nobody.\") },\n        [a] =&gt; { println!(\"Hello, {}.\", a) },\n        [a, b] =&gt; { println!(\"Hello, {} and {}.\", a, b) },\n        [a, .., b] =&gt; { println!(\"Hello, everyone from {} to {}.\", a, b) }\n    }\n}</code></pre>\n<h3 id=\"nav_point_176\">10.2.4　引用型模式</h3>\n<p>Rust 模式提供了两种特性来支持引用。<code>ref</code> 模式会借用已匹配值的一部分。<code>&amp;</code> 模式会匹配引用。我们会先介绍 <code>ref</code> 模式。</p>\n<p>匹配不可复制的值会移动该值。继续以 <code>account</code> 为例，以下代码是无效的：</p>\n<pre class=\"code-rows\"><code>match account {\n    Account { name, language, .. } =&gt; {\n        ui.greet(&amp;name, &amp;language);\n        ui.show_settings(&amp;account);  // 错误：借用已移动的值`account`\n    }\n}</code></pre>\n<p>在这里，字段 <code>account.name</code> 和 <code>account.language</code> 会移动到局部变量 <code>name</code> 和 <code>language</code> 中。<code>account</code> 的其余部分均已丢弃。这就是为什么我们之后不能再借用它的引用。</p>\n<p>如果 <code>name</code> 和 <code>language</code> 都是可复制的值，则 Rust 会复制字段而非移动它们，这时上述代码就是有效的。但假设这些是 <code>String</code> 类型，那我们可以做些什么呢？</p>\n<p>我们需要一种<strong>借用</strong>而非移动匹配值的模式。<code>ref</code> 关键字就是这样做的：</p>\n<pre class=\"code-rows\"><code>match account {\n    Account { ref name, ref language, .. } =&gt; {\n        ui.greet(name, language);\n        ui.show_settings(&amp;account);  // 正确\n    }\n}</code></pre>\n<p>现在局部变量 <code>name</code> 和 <code>language</code> 是对 <code>account</code> 中相应字段的引用。由于 <code>account</code> 只是被借入而没有被消耗，因此继续调用它的方法是没问题的。</p>\n<p>还可以使用 <code>ref mut</code> 来借入可变引用：</p>\n<pre class=\"code-rows\"><code>match line_result {\n    Err(ref err) =&gt; log_error(err),  // `err`是&amp;Error类型的（共享引用）\n    Ok(ref mut line) =&gt; {            // `line`是&amp;mut String类型的（可变引用）\n        trim_comments(line);         // 就地修改此字符串\n        handle(line);\n    }\n}</code></pre>\n<p>模式 <code>Ok(ref mut line)</code> 能匹配任何成功的结果，并借入其成功值的可变引用。</p>\n<p>与 <code>ref</code> 模式相对<span class=\"comment-number\">2</span>的引用型模式是 <code>&amp;</code> 模式。以 <code>&amp;</code> 开头的模式会匹配引用：</p>\n\n<pre class=\"code-rows\"><code>match sphere.center() {\n    &amp;Point3d { x, y, z } =&gt; ...\n}</code></pre>\n<p>在此示例中，假设 <code>sphere.center()</code> 会返回对 <code>sphere</code> 中的私有字段的引用，这是 Rust 中的常见模式。返回的值是 <code>Point3d</code> 的地址。如果中心位于原点，则 <code>sphere.center()</code> 会返回 <code>&amp;Point3d { x: 0.0, y: 0.0, z: 0.0 }</code>。</p>\n<p>模式匹配过程如图 10-7 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00855.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-7：与引用的模式匹配</strong></p>\n<p>这有点儿棘手，因为 Rust 在这里会追踪一个指针，我们通常会将追踪指针的操作与 <code>*</code> 运算符而不是 <code>&amp;</code> 运算符联系起来。但要记住，模式和表达式是恰恰相反的。表达式 <code>(x, y)</code> 会把两个值放入一个新的元组中，而模式 <code>(x, y)</code> 则会匹配一个元组并分解成两个值。<code>&amp;</code> 的逻辑也是如此。在表达式中，<code>&amp;</code> 会创建一个引用。在模式中，<code>&amp;</code> 则会匹配一个引用。</p>\n<p>匹配引用时会遵循我们所期望的一切规则。生命周期规则仍然有效。你不能通过共享引用获得可变访问权限，而且不能将值从引用中移动出去，即使对可变引用也是如此。当我们匹配 <code>&amp;Point3d { x, y, z }</code> 时，变量 <code>x</code>、<code>y</code> 和 <code>z</code> 会接受坐标的副本，而原始 <code>Point3d</code> 的值保持不变。这种写法之所以有效，是因为这些字段都是可复制的。如果试图在具有不可复制字段的结构体上这么做，就会出错：</p>\n<pre class=\"code-rows\"><code>match friend.borrow_car() {\n    Some(&amp;Car { engine, .. }) =&gt;  // 错误：不能把借用的值移动出去\n        ...\n    None =&gt; {}\n}</code></pre>\n<p>从借来的汽车上搜刮零件可不是君子所为，Rust 同样不会容忍这么做。你可以使用 <code>ref</code> 模式来借用对部件的引用，但并不拥有它：</p>\n<pre class=\"code-rows\"><code>    Some(&amp;Car { ref engine, .. }) =&gt;  // 正确，engine是一个引用</code></pre>\n<p>再来看一个 <code>&amp;</code> 模式的例子。假设我们有一个遍历字符串中各字符的迭代器 <code>chars</code>，并且它有一个返回 <code>Option&lt;&amp;char&gt;</code>（如果有，则是对下一个字符的引用）的方法 <code>chars.peek()</code>。（<code>Peekable</code> 迭代器实际上会返回 <code>Option&lt;&amp;ItemType&gt;</code>，我们在第 15 章中会看到。）</p>\n<p>程序可以使用 <code>&amp;</code> 模式来获取它所指向的字符。</p>\n<pre class=\"code-rows\"><code>match chars.peek() {\n    Some(&amp;c) =&gt; println!(\"coming up: {:?}\", c),\n    None =&gt; println!(\"end of chars\"),\n}</code></pre>\n<h3 id=\"nav_point_177\">10.2.5　匹配守卫</h3>\n<p>有时，匹配分支会有一些额外的条件，必须满足这些条件才能视为匹配成功。假设我们正在实现一款棋类游戏，它的棋盘是由六边形组成的，而玩家刚刚通过点击移动了一枚棋子。为了确认点击是有效的，我们可能会做如下尝试：</p>\n<pre class=\"code-rows\"><code>fn check_move(current_hex: Hex, click: Point) -&gt; game::Result&lt;Hex&gt; {\n    match point_to_hex(click) {\n        None =&gt;\n            Err(\"That's not a game space.\"),\n        Some(current_hex) =&gt;  // 如果用户单击current_hex，就会尝试匹配\n                              //（其实它不起作用：请参见下面的解释）\n            Err(\"You are already there! You must click somewhere else.\"),\n        Some(other_hex) =&gt;\n            Ok(other_hex)\n    }\n}</code></pre>\n<p>这失败了，因为模式中的标识符引入了<strong>新变量</strong>。这里的模式 <code>Some(current_hex)</code> 创建了一个新的局部变量 <code>current_hex</code>，它遮蔽了同名参数 <code>current_hex</code>。Rust 发出了几个关于此代码的警告——特别是，<code>match</code> 的最后一个分支是不可达的。解决此问题的一种简单方式是在匹配分支中使用 <code>if</code> 表达式：</p>\n<pre class=\"code-rows\"><code>match point_to_hex(click) {\n    None =&gt; Err(\"That's not a game space.\"),\n    Some(hex) =&gt; {\n        if hex == current_hex {\n            Err(\"You are already there! You must click somewhere else\")\n        } else {\n            Ok(hex)\n        }\n    }\n}</code></pre>\n<p>但 Rust 还提供了<strong>匹配守卫</strong>，额外的条件必须为真时才能应用此匹配分支，在模式及其分支的 <code>=&gt;</code> 标记之间写上 <code>if CONDITION</code>：</p>\n<pre class=\"code-rows\"><code>match point_to_hex(click) {\n    None =&gt; Err(\"That's not a game space.\"),\n    Some(hex) if hex == current_hex =&gt;\n        Err(\"You are already there! You must click somewhere else\"),\n    Some(hex) =&gt; Ok(hex)\n}</code></pre>\n<p>如果模式匹配成功，但此条件为假，就会继续尝试匹配下一个分支。</p>\n<h3 id=\"nav_point_178\">10.2.6　匹配多种可能性</h3>\n<p>对于形如 <code><i>pat1</i> | <i>pat2</i></code> 的模式，如果能匹配其中的任何一个子模式，则认为匹配成功：</p>\n<pre class=\"code-rows\"><code>let at_end = match chars.peek() {\n    Some(&amp;'\\r' | &amp;'\\n') | None =&gt; true,\n    _ =&gt; false,\n};</code></pre>\n<p>在表达式中，<code>|</code> 是按位或运算符，但在这里，它更像正则表达式中的 <code>|</code> 符号。如果 <code>chars. peek()</code> 为 <code>None</code>，或者是某个持有回车符、换行符的 <code>Some</code>，则把 <code>at_end</code> 设置为 <code>true</code>。</p>\n<p>使用 <code>..=</code> 匹配整个范围的值。范围型模式包括开始值和结束值，因此 <code>'0' ..= '9'</code> 会匹配所有 ASCII 数字：</p>\n<pre class=\"code-rows\"><code>match next_char {\n    '0'..='9' =&gt; self.read_number(),\n    'a'..='z' | 'A'..='Z' =&gt; self.read_word(),\n    ' ' | '\\t' | '\\n' =&gt; self.skip_whitespace(),\n    _ =&gt; self.handle_punctuation(),\n}</code></pre>\n<p>Rust 中还允许使用像 <code>x..</code> 这样的范围型模式，该模式会匹配从 <code>x</code> 到其类型最大值的任何值。但是，目前模式中还不允许使用其他的开区间范围（如 <code>0..100</code> 或 <code>..100</code>）以及无限范围（如 <code>..</code>）。</p>\n<h3 id=\"nav_point_179\">10.2.7　使用@模式绑定</h3>\n<p>最后，<code><i>x</i> @ <i>pattern</i></code> 会与给定的 <em><code>pattern</code></em> 精确匹配，但成功时，它不会为匹配到的值的各个部分创建变量，而是会创建单个变量 <em><code>x</code></em> 并将整个值移动或复制到其中。假设你有如下代码：</p>\n<pre class=\"code-rows\"><code>match self.get_selection() {\n    Shape::Rect(top_left, bottom_right) =&gt; {\n        optimized_paint(&amp;Shape::Rect(top_left, bottom_right))\n    }\n    other_shape =&gt; {\n        paint_outline(other_shape.get_outline())\n    }\n}</code></pre>\n<p>请注意，第一个分支解包出一个 <code>Shape::Rect</code> 值，却只是为了在下一行重建一个相同的 <code>Shape::Rect</code> 值。像这种代码可以用 <code>@</code> 模式重写：</p>\n<pre class=\"code-rows\"><code>    rect @ Shape::Rect(..) =&gt; {\n        optimized_paint(&amp;rect)\n    }</code></pre>\n<p><code>@</code> 模式对于各种范围模式也很有用。</p>\n<pre class=\"code-rows\"><code>match chars.next() {\n    Some(digit @ '0'..='9') =&gt; read_number(digit, chars),\n    ...\n},</code></pre>\n<h3 id=\"nav_point_180\">10.2.8　模式能用在哪里</h3>\n<p>尽管模式在 <code>match</code> 表达式中作用最为突出，但它们也可以出现在其他一些地方，通常用于代替标识符。但无论出现在哪里，其含义都是一样的：Rust 不是要将值存储到单个变量中，而是使用模式匹配来拆分值。</p>\n<p>这意味着模式可用于：</p>\n<pre class=\"code-rows\"><code>// 把结构体解包成3个局部变量……\nlet Track { album, track_number, title, .. } = song;\n\n// ……解包某个作为函数参数传入的元组\nfn distance_to((x, y): (f64, f64)) -&gt; f64 { ... }\n\n// ……迭代某个HashMap上的键和值\nfor (id, document) in &amp;cache_map {\n    println!(\"Document #{}: {}\", id, document.title);\n}\n\n// ……自动对闭包参数解引用（当其他代码给你传入引用，\n// 而你更想要一个副本时会很有用）\nlet sum = numbers.fold(0, |a, &amp;num| a + num);</code></pre>\n<p>上述示例中的每一个都节省了两三行样板代码。同样的概念也存在于其他一些语言中：JavaScript 中叫作<strong>解构</strong>，而 Python 中叫作<strong>解包</strong>。</p>\n<p>请注意，上述 4 个示例中都使用了确保匹配的模式。模式 <code>Point3d { x, y, z }</code> 会匹配 <code>Point3d</code> 结构体类型的每个可能值，<code>(x, y)</code> 会匹配任何一个 <code>(f64, f64)</code> 值对，等等。这种始终都可以匹配的模式在 Rust 中是很特殊的，它们叫作<strong>不可反驳模式</strong>，是唯一能同时用于此处展示的 4 个位置（<code>let</code> 之后、函数参数中、<code>for</code> 之后，以及闭包参数中）的模式。</p>\n<p><strong>可反驳模式</strong>是一种可能不会匹配的模式，比如 <code>Ok(x)</code> 不会匹配错误结果，而 <code>'0' ..= '9'</code> 不会匹配字符 <code>'Q'</code>。可反驳模式可以用在 <code>match</code> 的分支中，因为 <code>match</code> 就是为此而设计的：如果一个模式无法匹配，那么很清楚接下来会发生什么。在 Rust 程序中，前面的 4 个示例确实是模式可以派上用场的地方，但在这些地方语言不允许匹配失败。</p>\n<p><code>if let</code> 表达式和 <code>while let</code> 表达式中也允许使用可反驳模式，这些模式可用于：</p>\n<pre class=\"code-rows\"><code>// ……处理只有一个枚举值的特例\nif let RoughTime::InTheFuture(_, _) = user.date_of_birth() {\n    user.set_time_traveler(true);\n}\n\n// ……只有当查表成功时才运行某些代码\nif let Some(document) = cache_map.get(&amp;id) {\n    return send_cached_response(document);\n}\n\n// ……重复尝试某些事，直到成功\nwhile let Err(err) = present_cheesy_anti_robot_task() {\n    log_robot_attempt(err);\n    // 让用户再试一次（此用户仍然可能是人类）\n}\n\n// ……在某个迭代器上手动循环\nwhile let Some(_) = lines.peek() {\n    read_paragraph(&amp;mut lines);\n}</code></pre>\n<p>有关这些表达式的详细信息，请参阅 6.5.1 节和 6.5.2 节。</p>\n<h3 id=\"nav_point_181\">10.2.9　填充二叉树</h3>\n<p>早些时候我们曾承诺要展示如何实现方法 <code>BinaryTree::add()</code>，它能将一个节点添加到如下的 <code>BinaryTree</code> 类型中：</p>\n<pre class=\"code-rows\"><code>// `T`的有序集合\nenum BinaryTree&lt;T&gt; {\n    Empty,\n    NonEmpty(Box&lt;TreeNode&lt;T&gt;&gt;),\n}\n\n// BinaryTree的部件\nstruct TreeNode&lt;T&gt; {\n    element: T,\n    left: BinaryTree&lt;T&gt;,\n    right: BinaryTree&lt;T&gt;,\n}</code></pre>\n<p>你现在对模式的了解已经足以写出此方法了。对二叉搜索树的解释超出了本书的范畴，如果你已经很熟悉这个主题，可以自己看看它在 Rust 中的表现。</p>\n<pre class=\"code-rows\"><code> 1  impl&lt;T: Ord&gt; BinaryTree&lt;T&gt; {\n 2      fn add(&amp;mut self, value: T) {\n 3          match *self {\n 4              BinaryTree::Empty =&gt; {\n 5                  *self = BinaryTree::NonEmpty(Box::new(TreeNode {\n 6                      element: value,\n 7                      left: BinaryTree::Empty,\n 8                      right: BinaryTree::Empty,\n 9                  }))\n10              }\n11              BinaryTree::NonEmpty(ref mut node) =&gt; {\n12                  if value &lt;= node.element {\n13                      node.left.add(value);\n14                  } else {\n15                      node.right.add(value);\n16                  }\n17              }\n18          }\n19      }\n20  }</code></pre>\n<p>第 1 行告诉 Rust 我们正在为有序类型的 <code>BinaryTree</code> 定义一个方法。这与我们在泛型结构体上定义方法的语法是完全相同的，详见 9.5 节。</p>\n<p>如果现有的树 <code>*self</code> 是空的，那就很简单了。运行第 5~9 行代码，将 <code>Empty</code> 树更改为 <code>NonEmpty</code> 树即可。此处对 <code>Box::new()</code> 的调用在堆中分配了一个新的 <code>TreeNode</code>。当完成时，树就会包含一个元素。它的左右子树都是 <code>Empty</code>。</p>\n<p>如果 <code>*self</code> 不为空，那么我们就会匹配第 11 行代码的模式：</p>\n<pre class=\"code-rows\"><code>BinaryTree::NonEmpty(ref mut node) =&gt; {</code></pre>\n<p>该模式借用了对 <code>Box&lt;TreeNode&lt;T&gt;&gt;</code> 的可变引用，因此我们可以访问和修改该树节点中的数据。该引用名为 <code>node</code>，位于第 12~16 行代码的作用域内。由于此节点中已经有了一个元素，因此代码必须递归调用 <code>.add()</code> 以将此新元素添加到左子树或右子树中。</p>\n<p>新方法可以像下面这样使用。</p>\n<pre class=\"code-rows\"><code>let mut tree = BinaryTree::Empty;\ntree.add(\"Mercury\");\ntree.add(\"Venus\");\n...</code></pre>\n<h2 id=\"nav_point_182\">10.3　大局观</h2>\n<p>Rust 的枚举对系统编程来说可能是新的，但它并不是新思想。它一直顶着各种听起来就很学术的名字（比如<strong>代数数据类型</strong>）在传播，已经在函数式编程语言中存在四十多年了。目前还不清楚为什么在 C 系列的传承中很少有其他语言支持这种枚举。或许只是因为对编程语言的设计者来说，要将变体、引用、可变性和内存安全这 4 项内容结合使用极具挑战性。函数式编程语言抵触可变性。与之相反，C 的联合体具有变体、指针和可变性——但非常不安全，即使在 C 中，它们也只会在迫不得已时使用。Rust 的借用检查器简直就是魔法，它不必做丝毫妥协就能将上述 4 项内容结合起来。</p>\n<p>编程就是数据处理。一个小巧、快速、优雅的程序与一个庞大、缓慢、杂乱无章、充斥着各种补丁和虚拟方法调用的程序之间的区别在于，数据是否被转换成了正确的形态。</p>\n<p>这就是枚举所针对的“问题空间”。它们是将数据表达为正确形态的设计工具。对于值可能是 A、可能是 B，也可能两者都不是的情况，枚举在每个维度上都比类层次结构表现得要好：更快、更安全、代码更少且更容易文档化。</p>\n<p>这里的限制因素是灵活性。枚举的最终用户无法通过扩展枚举来添加新变体，只能通过更改枚举声明来添加。当这种情况发生时，现有代码就会被破坏。我们必须重新审视任何单独匹配枚举的每个变体的 <code>match</code> 表达式，因为它需要一个新的分支来处理这个新变体。在某些情况下，为了简单性而牺牲灵活性是很明智的。毕竟，JSON 的语法结构已经定型，不需要灵活性了。在另外一些情况下，当枚举发生变化时，重新审视枚举的所有使用场合正是我们应该做的。例如，当在编译器中使用 <code>enum</code> 来表示编程语言的各种运算符时，添加新运算符<strong>本来就应该</strong>涉及处理运算符的所有代码。</p>\n<p>但有时确实需要更大的灵活性。针对这些情况，Rust 设计了一些特型，这就是第 11 章的主题。</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}