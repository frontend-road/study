{"id":741032,"title":"第 10 章 shell基础知识","content":"\n<p>shell脚本在日常的Linux系统管理工作中是必不可少的。如果不会写shell脚本，你就不算是一个合格的管理员。目前，很多单位在招聘Linux系统管理员时，shell脚本的编写是必考的题目。有的单位甚至用shell脚本的编写能力来衡量这个Linux系统管理员的经验是否丰富。所以，你必须认真学习shell脚本并不断练习。只要shell脚本写得好，那么相信你的Linux求职之路就会轻松得多。阿铭在这一章中只是带你进入shell脚本的世界，如果你很感兴趣，可以到网上下载相关的资料或者到书店购买shell相关的图书。</p>\n<p>在学习shell脚本之前，需要你了解很多相关的知识，这些知识是编写shell脚本的基础，希望你能够熟练掌握。</p>\n<h2 id=\"nav_point_164\">10.1 什么是shell</h2>\n<p>shell是系统跟计算机硬件交互时使用的中间介质，它只是系统的一个工具。实际上，在shell和计算机硬件之间还有一层东西——系统内核。如果把计算机硬件比作一个人的躯体，那系统内核就是人的大脑。至于shell，把它比作人的五官似乎更贴切些。言归正传，用户直接面对的不是计算机硬件而是shell，用户把指令告诉shell，然后shell传输给系统内核，接着内核再去支配计算机硬件去执行各种操作。</p><!-- [[[read_end]]] -->\n<p>阿铭接触的Linux发布版本（Red Hat/CentOS）默认安装的shell版本是bash（即Bourne Again Shell），它是sh（即Bourne Shell）的增强版本。Bourn Shell是最早流行起来的一个shell版本。其创始人是Steven Bourne，为了纪念他而将其命名为Bourn Shell，简称sh。那么，这个bash有什么特点呢？</p>\n<h3 id=\"nav_point_165\">10.1.1 记录命令历史</h3>\n<p>我们执行过的命令Linux都会记录，预设可以记录1000条历史命令。这些命令保存在用户的家目录的.bash_history文件中。但需要注意的是，只有当用户正常退出当前shell时，在当前shell中运行的命令才会保存至 .bash_history文件中。那什么情况才算正常退出？敲exit命令或者按Ctrl＋D快捷键都可以正常退出。而意外断电或者断网就不算正常退出。</p>\n<p><code>!</code>是与命令有关的一个特殊字符，该字符常用的应用有以下3个。</p>\n<ul>\n<li><p><strong><code>!!</code></strong>：连续两个<code>!</code>表示执行上一条指令。示例命令如下：</p>\n<pre class=\"code-rows\"><code># pwd\n/root\n# !!\npwd\n/root</code></pre>\n</li>\n<li><p><strong><code>!n</code></strong>：这里的<code>n</code>是数字，表示执行命令历史中的第<em>n</em>条指令。例如，<code>!1002</code>表示执行命令历史中的第1002个命令，如下所示：</p>\n<pre class=\"code-rows\"><code># history |grep 1002\n 1002 pwd\n 1015 history |grep 1002\n# !1002\npwd\n/root</code></pre>\n<p>上例中的<code>history</code>命令如果未改动过环境变量，默认可以把最近执行的1000条命令历史打印出来。</p>\n</li>\n<li><p><strong><code>!</code>字符串（字符串大于等于1）</strong>：例如<code>!pw</code>表示执行命令历史中最近一次以pw开头的命令。示例代码如下：</p>\n<pre class=\"code-rows\"><code># !pw\npwd\n/root</code></pre>\n</li>\n</ul>\n<h3 id=\"nav_point_166\">10.1.2 命令和文件名补全</h3>\n<p>最开始阿铭就介绍过，按tab键可以帮我们补全一个指令、一个路径或者一个文件名。连续按两次tab键，系统则会把所有的命令或者文件名都列出来。</p>\n<h3 id=\"nav_point_167\">10.1.3 别名</h3>\n<p>前面的章节中也曾提到过alias，它也是bash所特有的功能之一。我们可以通过alias把一个常用的并且很长的指令另取名为一个简单易记的指令。如果不想用此功能了，还可以使用<code>unalias</code>命令解除别名功能。直接执行<code>alias</code>命令，会看到目前系统预设的别名，如下所示：</p>\n<pre class=\"code-rows\"><code># alias\nalias cp='cp -i'\nalias egrep='egrep --color=auto'\nalias fgrep='fgrep --color=auto'\nalias grep='grep --color=auto'\nalias l.='ls -d .* --color=auto'\nalias ll='ls -l --color=auto'\nalias ls='ls --color=auto'\nalias mv='mv -i'\nalias rm='rm -i'\nalias which='(alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions\n --show-tilde --show-dot'\nalias xzegrep='xzegrep --color=auto'\nalias xzfgrep='xzfgrep --color=auto'\nalias xzgrep='xzgrep --color=auto'\nalias zegrep='zegrep --color=auto'\nalias zfgrep='zfgrep --color=auto'\nalias zgrep='zgrep --color=auto'</code></pre>\n<p>另外，你也可以自定义命令的别名，其格式为<code>alias [命令别名]=['具体的命令']</code>，示例命令如下：</p>\n<pre class=\"code-rows\"><code># alias aming='pwd'\n# aming\n/root\n# unalias aming\n# aming\nbash: aming: command not found...\nFailed to search for file: Cannot update read-only repo</code></pre>\n<h3 id=\"nav_point_168\">10.1.4 通配符</h3>\n<p>在bash下，可以使用<code>*</code>来匹配零个或多个字符，用<code>?</code>匹配一个字符。示例命令如下：</p>\n<pre class=\"code-rows\"><code># ls -d /tmp/4_6/test*\n/tmp/4_6/test1 /tmp/4_6/test4 /tmp/4_6/test5\n# touch /tmp/4_6/test111\n# ls -d /tmp/4_6/test?\n/tmp/4_6/test1 /tmp/4_6/test4 /tmp/4_6/test5</code></pre>\n<h3 id=\"nav_point_169\">10.1.5 输入/输出重定向</h3>\n<p>输入重定向用于改变命令的输入，输出重定向用于改变命令的输出。输出重定向更为常用，它经常用于将命令的结果输入到文件中，而不是屏幕上。输入重定向的命令是<code>&lt;</code>，输出重定向的命令是<code>&gt;</code>。另外，还有错误重定向命令<code>2&gt;</code>以及追加重定向命令<code>&gt;&gt;</code>，示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir /tmp/10\n# cd /tmp/10\n# echo \"123\" &gt; 1.txt\n# echo \"123\" &gt;&gt; 1.txt\n# cat 1.txt\n123\n123</code></pre>\n<h3 id=\"nav_point_170\">10.1.6 管道符</h3>\n<p>前面已经提过管道符<code>|</code>，它用于将前一个指令的输出作为后一个指令的输入，如下所示：</p>\n<pre class=\"code-rows\"><code># cat /etc/passwd|wc -l</code></pre>\n<h3 id=\"nav_point_171\">10.1.7 作业控制</h3>\n<p>当运行进程时，你可以暂停（按Ctrl+Z组合键）它，然后使用<code>fg</code>（foreground的简写）命令恢复它，或是利用<code>bg</code>（background的简写）命令使它到后台运行。此外，你也可以使它终止（按Ctrl+C组合键）。示例命令如下：</p>\n<pre class=\"code-rows\"><code># vi test1.txt\ntesttestsstststst</code></pre>\n<p>接下来阿铭使用<code>vi</code>命令编辑test1.txt，随便输入一些内容，按Esc键后，使用Ctrl+Z组合键暂停任务，如下所示：</p>\n<pre class=\"code-rows\"><code># vi test1.txt\n\n[1]+ 已停止 vi test1.txt</code></pre>\n<p>此时提示<code>vi test1.txt</code>已经停止了，然后使用<code>fg</code>命令恢复它，此时就又进入刚才的<code>vi</code>窗口了。再次使其暂停，然后输入<code>jobs</code>，可以看到被暂停或者在后台运行的任务，如下所示：</p>\n<pre class=\"code-rows\"><code># jobs\n[1]+ 已停止 vi test1.txt</code></pre>\n<p>如果想把暂停的任务放在后台重新运行，就使用<code>bg</code>命令，如下所示：</p>\n<pre class=\"code-rows\"><code># bg\n[1]+ vi test1.txt &amp;\n\n[1]+ 已停止 vi test1.txt</code></pre>\n<p>但是<code>vi</code>似乎并不支持在后台运行，那阿铭换一个其他的命令，如下所示：</p>\n<pre class=\"code-rows\"><code># vmstat 1 &gt; /tmp/1.log\n^Z //此处按ctrl + z\n[2]+ 已停止 vmstat 1 &gt; /tmp/1.log\n# jobs\n[1]- 已停止 vi test1.txt\n[2]+ 已停止 vmstat 1 &gt; /tmp/1.log\n# bg 2\n[2]+ vmstat 1 &gt; /tmp/1.log &amp;</code></pre>\n<p>在上面的例子中，又出现了一个新的知识点，那就是多个被暂停的任务会有编号，使用<code>jobs</code>命令可以看到两个任务，使用<code>bg</code>命令或者<code>fg</code>命令时，则需要在任务后面加编号。这里阿铭使用命令<code>bg 2</code>把第2个暂停的任务放到后台重新运行（需要在命令后边加符号<code>&amp;</code>，且中间有个空格）。本例中的<code>vmstat 1</code>是用来观察系统状态的一个命令，阿铭在13.1.2节中再介绍。</p>\n<p>如何关掉在后台运行的任务呢？如果你没有退出刚才的shell，那么应该先使用命令“<code>fg 编号</code>”把任务调到前台，然后按Ctrl+C组合键结束任务。如下所示：</p>\n<pre class=\"code-rows\"><code># fg 2\nvmstat 1 &gt; /tmp/1.log\n^C //此处按 ctrl + c</code></pre>\n<p>另一种情况则是，关闭了当前的shell，再次打开另一个shell时，使用<code>jobs</code>命令并不会显示在后台运行或者被暂停的任务。要想关闭这些任务，则需要先知道它们的<code>pid</code>。如下所示：</p>\n<pre class=\"code-rows\"><code># vmstat 1 &gt; /tmp/1.log &amp;\n[1] 32689\n[root@localhost 10]# ps aux |grep vmstat\nroot 32689 0.1 0.0 41192 2012 pts/2 S 22:14 0:00 vmstat 1\nroot 32691 0.0 0.0 9184 1084 pts/2 R+ 22:14 0:00 grep --color=auto vmstat</code></pre>\n<p>使用<code>&amp;</code>把任务放到后台运行时，会显示<code>pid</code>信息。如果忘记这个<code>pid</code>，还可以使用<code>ps aux</code>命令找到那个进程（关于<code>ps</code>命令，阿铭会在13.1.7节中讲解）。如果想结束该进程，需要使用<code>kill</code>命令，如下所示：</p>\n<pre class=\"code-rows\"><code># kill 32689\n# jobs\n[1]+ Terminated vmstat 1 &gt; /tmp/1.log</code></pre>\n<p><code>kill</code>命令很简单，直接在后面加<code>pid</code>即可。如果遇到结束不了的进程时，可以在<code>kill</code>后面加一个选项，即<code>kill -9 [pid]</code>。</p>\n<p>在该节结束时，大家要记得把后台的<code>vi</code>给结束掉，免得以后遇到一些困扰。具体怎么结束，阿铭相信，经过前面的学习，你应该知道答案了。</p>\n<h2 id=\"nav_point_172\">10.2 变量</h2>\n<p>阿铭在前面介绍过环境变量<code>PATH</code>，它是shell预设的一个变量。通常，shell预设的变量都是大写的。变量就是使用一个较简单的字符串来替代某些具有特殊意义的设定以及数据。就拿<code>PATH</code>来讲，它就代替了所有常用命令的绝对路径的设定。有了<code>PATH</code>这个变量，我们运行某个命令时，就不再需要输入全局路径，直接输入命令名即可。你可以使用<code>echo</code>命令显示变量的值，如下所示：</p>\n<pre class=\"code-rows\"><code># echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n# echo $HOME\n/root\n# echo $PWD\n/root\n# echo $LOGNAME\nroot</code></pre>\n<p>除了<code>PATH</code>、<code>HOME</code>和<code>LOGNAME</code>外，系统预设的环境变量还有哪些呢？</p>\n<h3 id=\"nav_point_173\">10.2.1 命令<code>env</code></h3>\n<p>使用<code>env</code>命令，可列出系统预设的全部系统变量，如下所示：</p>\n<pre class=\"code-rows\"><code># env\nLS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.m4a=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.oga=01;36:*.opus=01;36:*.spx=01;36:*.xspf=01;36:\nSSH_CONNECTION=192.168.18.1 62926 192.168.18.119 22\nLANG=zh_CN.UTF-8\nHISTCONTROL=ignoredups\nHOSTNAME=localhost.localdomain\nXDG_SESSION_ID=15\nUSER=root\nSELINUX_ROLE_REQUESTED=\nPWD=/tmp/10\nHOME=/root\nSSH_CLIENT=192.168.18.1 62926 22\nSELINUX_LEVEL_REQUESTED=\nXDG_DATA_DIRS=/root/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share\nSSH_TTY=/dev/pts/2\nMAIL=/var/spool/mail/root\nTERM=xterm\nSHELL=/bin/bash\nSELINUX_USE_CURRENT_RANGE=\nSHLVL=1\nLOGNAME=root\nDBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/bus\nXDG_RUNTIME_DIR=/run/user/0\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\nHISTSIZE=1000\nLESSOPEN=||/usr/bin/lesspipe.sh %s\n_=/usr/bin/env\nOLDPWD=/root</code></pre>\n<p>登录不同的用户，这些环境变量的值也不同。当前显示的是root用户的环境变量。下面阿铭简单介绍一下常见的环境变量。</p>\n<ul>\n<li><strong><code>HOSTNAME</code></strong>：表示主机的名称。</li>\n<li><strong><code>SHELL</code></strong>：表示当前用户的shell类型。</li>\n<li><strong><code>HISTSIZE</code></strong>：表示历史记录数。</li>\n<li><strong><code>MAIL</code></strong>：表示当前用户的邮件存放目录。</li>\n<li><strong><code>PATH</code></strong>：该变量决定了shell将到哪些目录中寻找命令或程序。</li>\n<li><strong><code>PWD</code></strong>：表示当前目录。</li>\n<li><strong><code>LANG</code></strong>：这是与语言相关的环境变量，多语言环境可以修改此环境变量。</li>\n<li><strong><code>HOME</code></strong>：表示当前用户的家目录。</li>\n<li><strong><code>LOGNAME</code></strong>：表示当前用户的登录名。</li>\n</ul>\n<p><code>env</code>命令显示的变量只是环境变量，系统预设的变量其实还有很多，你可以使用<code>set</code>命令把系统预设的全部变量都显示出来。</p>\n<h3 id=\"nav_point_174\">10.2.2 命令<code>set</code></h3>\n<p><code>set</code>命令和<code>env</code>命令类似，也可以输出环境变量，如下所示：</p>\n<pre class=\"code-rows\"><code># set\nBASH=/bin/bash\nBASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:\n histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath\nBASHRCSOURCED=Y\nBASH_ALIASES=()\nBASH_ARGC=()\nBASH_ARGV=()\nBASH_CMDS=()\nBASH_COMPLETION_VERSINFO=([0]=\"2\" [1]=\"7\")\nBASH_LINENO=()\nBASH_REMATCH=()\nBASH_SOURCE=()\nBASH_VERSINFO=([0]=\"4\" [1]=\"4\" [2]=\"19\" [3]=\"1\" [4]=\"release\" [5]=\"x86_64-redhat-linux-gnu\")\nBASH_VERSION='4.4.19(1)-release'\nCOLUMNS=189\nCOMP_WORDBREAKS=$' \\t\\n\"\\'&gt;&lt;=;|&amp;(:'\nDBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/bus\nDIRSTACK=()\nEUID=0\nFINAL_LIST=\nGLUSTER_BARRIER_OPTIONS=$'\\n ,\\n \\n'</code></pre>\n<p>阿铭并没有把全部内容都列出来，<code>set</code>命令不仅可以显示系统预设的变量，还可以显示用户自定义的变量。比如，我们自定义一个变量，如下所示：</p>\n<pre class=\"code-rows\"><code># myname=Aming\n# echo $myname\nAming\n# set |grep myname\nmyname=Aming</code></pre>\n<p>虽然你可以自定义变量，但是该变量只能在当前shell中生效，如下所示：</p>\n<pre class=\"code-rows\"><code># echo $myname\nAming\n# bash // 执行该命令，会进入一个子shell环境中\n# echo $myname\n\n# exit\nexit\n# echo $myname\nAming</code></pre>\n<p>使用<code>bash</code>命令可以再打开一个shell，此时先前设置的<code>myname</code>变量已经不存在了，退出当前shell回到原来的shell，<code>myname</code>变量还在。如果想让设置的环境变量一直生效，该怎么做呢？这分以下两种情况。</p>\n<ul>\n<li><p>允许系统内所有用户登录后都能使用该变量。具体的操作方法是：在/etc/profile文件的最后一行加入<code>export myname=Aming</code>，然后运行<code>source /etc/profile</code>就可以生效了。此时再运行<code>bash</code>命令或者切换到其他用户（如<code>su - test</code>）就可以看到效果。如下所示：</p>\n<pre class=\"code-rows\"><code># echo \"export myname=Aming\" &gt;&gt; /etc/profile\n# source !$\nsource /etc/profile\n# bash\n# echo $myname\nAming\n# exit\nexit\n# su - test\n$ echo $myname\nAming</code></pre>\n</li>\n<li><p>仅允许当前用户使用该变量。具体的操作方法是：在用户主目录下的.bashrc文件的最后一行加入<code>export myname=Aming</code>，然后运行<code>source .bashrc</code>就可以生效了。这时再登录test用户，<code>myname</code>变量则不会生效了。这里<code>source</code>命令的作用是将目前设定的配置刷新，即不用注销再登录也能生效。</p>\n</li>\n</ul>\n<p>阿铭在上例中使用<code>myname=Aming</code>来设置变量<code>myname</code>，那么，在Linux下设置自定义变量，有哪些规则呢？</p>\n<ul>\n<li>设定变量的格式为<code>a=b</code>，其中<code>a</code>为变量名，<code>b</code>为变量的内容，等号两边不能有空格。</li>\n<li>变量名只能由字母、数字以及下划线组成，而且不能以数字开头。</li>\n<li><p>当变量内容带有特殊字符（如空格）时，需要加上单引号。示例命令如下：</p>\n<pre class=\"code-rows\"><code># myname='Aming Li'\n# echo $myname\nAming Li</code></pre>\n</li>\n</ul>\n<p>有一种情况需要你注意，就是变量内容中本身带有单引号，这时就需要加双引号了。示例命令如下：</p>\n<pre class=\"code-rows\"><code># myname=\"Aming's\"\n# echo $myname\nAming's</code></pre>\n<p>如果变量内容中需要用到其他命令，则运行结果可以使用反引号。示例命令如下：</p>\n<pre class=\"code-rows\"><code># myname=`pwd`\n# echo $myname\n/root</code></pre>\n<p>变量内容可以累加其他变量的内容，但需要加双引号。示例命令如下：</p>\n<pre class=\"code-rows\"><code># myname=\"$LOGNAME\"Aming\n# echo $myname\nrootAming</code></pre>\n<p>如果你不小心把双引号错加为了单引号，则得不到你想要的结果。示例命令如下：</p>\n<pre class=\"code-rows\"><code># myname='$LOGNAME'Aming\n# echo $myname\n$LOGNAMEAming</code></pre>\n<p>通过上面几个例子，也许你已经看出了使用单引号和双引号的区别。使用双引号时，不会取消双引号中特殊字符本身的作用（这里是<code>$</code>），而使用单引号时，里面的特殊字符将全部失去其本身的作用。</p>\n<p>在前面的例子中，阿铭多次使用了<code>bash</code>命令，如果在当前shell中运行<code>bash</code>指令，则会进入一个新的shell，这个shell就是原来shell的子shell。你不妨用<code>pstree</code>指令来查看一下，示例命令如下：</p>\n<pre class=\"code-rows\"><code># pstree |grep bash\n |-login---bash\n |-sshd---sshd---bash-+-grep\n# bash\n# pstree |grep bash\n |-login---bash\n |-sshd---sshd---bash---bash-+-grep</code></pre>\n<p>如果没有该命令，请运行<code>yum install psmisc</code>命令安装，<code>pstree</code>命令会把Linux系统中的所有进程以树结构显示出来。限于篇幅，阿铭没有全部列出，你可以直接输入<code>pstree</code>查看。在父shell中设定变量后，进入子shell时，该变量是不会生效的。如果想让这个变量在子shell中生效，则要用到<code>export</code>指令。示例命令如下：</p>\n<pre class=\"code-rows\"><code># abc=123\n# echo $abc\n123\n# bash\n# echo $abc\n\n# exit\nexit\n# export abc\n# echo $abc\n123\n# bash\n# echo $abc\n123</code></pre>\n<p>其实<code>export</code>命令就是声明一下这个变量，让该shell的子shell也知道变量<code>abc</code>的值是<code>123</code>。设置变量之后，如果想取消某个变量，只要输入<code>unset变量名</code>即可。示例命令如下：</p>\n<pre class=\"code-rows\"><code># echo $abc\n123\n# unset abc\n# echo $abc</code></pre>\n<h2 id=\"nav_point_175\">10.3 系统环境变量与个人环境变量的配置文件</h2>\n<p>上面讲了很多系统变量，那么在Linux系统中，这些变量存在哪里呢？为什么用户一登录shell就自动有了这些变量呢？我们先来看看下面几个文件。</p>\n<ul>\n<li><strong>/etc/profile</strong>：这个文件预设了几个重要的变量，例如<code>PATH</code>、<code>USER</code>、<code>LOGNAME</code>、<code>MAIL</code>、<code>INPUTRC</code>、<code>HOSTNAME</code>、<code>HISTSIZE</code>、<code>umask</code>等。</li>\n<li><p><strong>/etc/bashrc</strong>：这个文件主要预设<code>umask</code>以及<code>PS1</code>。这个<code>PS1</code>就是我们在输入命令时前面的那串字符。例如，阿铭的Linux系统的<code>PS1</code>就是<code>[root@localhost ~]#</code>，我们不妨看一下<code>PS1</code>的值，如下所示：</p>\n<pre class=\"code-rows\"><code># echo $PS1\n[\\u@\\h \\W]\\$</code></pre>\n<p>其中，<code>\\u</code>指用户，<code>\\h</code>指主机名，<code>\\W</code>指当前目录，<code>\\$</code>指字符<code>#</code>（如果是普通用户，则显示为<code>$</code>）。</p>\n</li>\n</ul>\n<p>除了以上两个系统级别的配置文件外，每个用户的主目录下还有以下几个隐藏文件。</p>\n<ul>\n<li><strong>.bash_profile</strong>：该文件定义了用户的个人化路径与环境变量的文件名称。每个用户都可使用该文件输入专属于自己的shell信息，当用户登录时，该文件仅执行一次。</li>\n<li><strong>.bashrc</strong>：该文件包含专属于自己的shell的bash信息，当登录或每次打开新的shell时，会读取该文件。例如，你可以将用户自定义的别名或者自定义变量写到这个文件中。</li>\n<li><strong>.bash_history</strong>：该文件用于记录命令历史。</li>\n<li><strong>.bash_logout</strong>：当退出shell时，会执行该文件。你可以将一些清理工作放到这个文件中。</li>\n</ul>\n<h2 id=\"nav_point_176\">10.4 Linux shell中的特殊符号</h2>\n<p>在学习Linux的过程中，也许你已经接触过某个特殊符号，例如<code>*</code>，它是一个通配符，代表零个或多个字符或数字。下面阿铭就介绍一下常用的特殊字符。</p>\n<h3 id=\"nav_point_177\">10.4.1 <code>*</code>代表零个或多个任意字符</h3>\n<p>这个字符前面已经介绍过，这里再次提到，它的用法如下：</p>\n<pre class=\"code-rows\"><code># ls /tmp/4_6/test*\n/tmp/4_6/test1 /tmp/4_6/test111 /tmp/4_6/test4 /tmp/4_6/test5</code></pre>\n<h3 id=\"nav_point_178\">10.4.2 <code>?</code>只代表一个任意的字符</h3>\n<p>这个字符的用法如下：</p>\n<pre class=\"code-rows\"><code># touch /tmp/4_6/testa\n# ls -d /tmp/4_6/test?\n/tmp/4_6/test1 /tmp/4_6/test4 /tmp/4_6/test5 /tmp/4_6/testa</code></pre>\n<p>不管是数字还是字母，只要是一个字符，都能匹配出来。</p>\n<h3 id=\"nav_point_179\">10.4.3 注释符号<code>#</code></h3>\n<p>这个符号在Linux中表示注释说明，即<code>#</code>后面的内容都会被忽略。用法如下：</p>\n<pre class=\"code-rows\"><code># abc=123 #aaaaa\n# echo $abc\n123</code></pre>\n<h3 id=\"nav_point_180\">10.4.4 脱义字符<code>\\</code></h3>\n<p>这个字符会将后面的特殊符号（如<code>*</code>）还原为普通字符。用法如下：</p>\n<pre class=\"code-rows\"><code># ls -d test\\*\nls: cannot access 'test*': No such file or directory</code></pre>\n<h3 id=\"nav_point_181\">10.4.5 再说管道符<code>|</code></h3>\n<p>这个字符前面曾多次出现过，它的作用是将前面命令的输出作为后面命令的输入。注意这里提到的后面的命令，并不是所有的命令都可以，一般针对文档操作的命令比较常用。例如<code>cat</code>、<code>less</code>、<code>head</code>、<code>tail</code>、<code>grep</code>、<code>cut</code>、<code>sort</code>、<code>wc</code>、<code>uniq</code>、<code>tee</code>、<code>tr</code>、<code>split</code>、<code>sed</code>、<code>awk</code>等，其中<code>grep</code>、<code>sed</code>和<code>awk</code>是正则表达式必须掌握的工具，在第11章中会详细介绍。管道符的用法如下：</p>\n<pre class=\"code-rows\"><code># cat testb.txt |wc -l\n0</code></pre>\n<p>在上例中，<code>wc -l</code>用来计算一个文档有多少行。上面阿铭列出了很多陌生的命令，这些命令在日常的文档处理工作中非常实用，所以阿铭需要先简单介绍一下它们，如果你记不住，也没有关系，以后用到的时候再进一步了解即可。</p>\n<ol>\n<li><p><strong>命令<code>cut</code></strong></p>\n<p><code>cut</code>命令用来截取某一个字段，其格式为<code>cut -d '分隔字符' [-cf] n</code>，这里的<code>n</code>是数字。该命令有如下几个可用选项。</p>\n<ul>\n<li><strong><code>-d</code></strong>：后面跟分隔字符，分隔字符要用单引号括起来。</li>\n<li><strong><code>-c</code></strong>：后面接的是第几个字符。</li>\n<li><strong><code>-f</code></strong>：后面接的是第几个区块。</li>\n</ul>\n<p><code>cut</code>命令的用法如下：</p>\n<pre class=\"code-rows\"><code># cat /etc/passwd|cut -d ':' -f 1 |head -5\nroot\nbin\ndaemon\nadm\nlp</code></pre>\n<p>通过上例可以看出，<code>-d</code>选项后面加冒号作为分隔字符，<code>-f 1</code>表示截取第一段，<code>-f</code>和<code>1</code>之间的空格可有可无。示例命令如下：</p>\n<pre class=\"code-rows\"><code># head -n2 /etc/passwd|cut -c2\no\ni\n# head -n2 /etc/passwd|cut -c1\nr\nb\n# head -n2 /etc/passwd|cut -c1-10\nroot:x:0:0\nbin:x:1:1:\n# head -n2 /etc/passwd|cut -c5-10\n:x:0:0\nx:1:1:</code></pre>\n<p>通过上例可以看出，<code>-c</code>选项后面可以是一个数字<code>n</code>，也可以是一个区间<code>n1-n2</code>，还可以是多个数字<code>n1</code>、<code>n2</code>和<code>n3</code>。示例命令如下：</p>\n<pre class=\"code-rows\"><code># head -n2 /etc/passwd|cut -c1,3,10\nro0\nbn:</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>命令<code>sort</code></strong></p>\n<p><code>sort</code>命令用作排序，其格式为<code>sort [-t 分隔符] [-kn1,n2] [-nru]</code>，这里<code>n1</code>和<code>n2</code>指的是数字，其他选项的含义如下。</p>\n<ul>\n<li><strong><code>-t</code></strong>：后面跟分隔字符，作用跟<code>cut</code>命令的<code>-d</code>选项一样。</li>\n<li><strong><code>-n</code></strong>：表示使用纯数字排序。</li>\n<li><strong><code>-r</code></strong>：表示反向排序。</li>\n<li><strong><code>-u</code></strong>：表示去重复。</li>\n<li><strong><code>-kn1,n2</code></strong>：表示由<code>n1</code>区间排序到<code>n2</code>区间，可以只写<code>-kn1</code>，即对<code>n1</code>字段排序。</li>\n</ul>\n<p>如果<code>sort</code>不加任何选项，则从首字符向后依次按ASCII码值进行比较，最后将它们按升序输出。示例命令如下：</p>\n<pre class=\"code-rows\"><code># head -n5 /etc/passwd|sort\nadm:x:3:4:adm:/var/adm:/sbin/nologin\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\nroot:x:0:0:root:/root:/bin/bash</code></pre>\n<p><code>-t</code>选项后面跟分隔符，<code>-k</code>选项后面跟单个数字表示对第几个区域的字符串排序，<code>-n</code>选项则表示使用纯数字排序。示例命令如下：</p>\n<pre class=\"code-rows\"><code># head -n5 /etc/passwd |sort -t: -k3 -n\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\nadm:x:3:4:adm:/var/adm:/sbin/nologin\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</code></pre>\n<p><code>-k</code>选项后面跟数字<code>n1</code>和<code>n2</code>表示对第<code>n1</code>和<code>n2</code>区域内的字符串排序，<code>-r</code>选项则表示反向排序。示例命令如下：</p>\n<pre class=\"code-rows\"><code># head -n5 /etc/passwd |sort -t: -k3,5 -r\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\nadm:x:3:4:adm:/var/adm:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\nbin:x:1:1:bin:/bin:/sbin/nologin\nroot:x:0:0:root:/root:/bin/bash</code></pre>\n<p>这里的<code>-k3,5</code>表示对第3区域至第5区域间的字符串排序。<br />&nbsp;</p>\n</li>\n<li><p><strong>命令<code>wc</code></strong></p>\n<p><code>wc</code>命令用于统计文档的行数、字符数或词数。该命令的常用选项有<code>-l</code>（统计行数）、<code>-m</code>（统计字符数）和<code>-w</code>（统计词数）。示例命令如下：</p>\n<pre class=\"code-rows\"><code># wc /etc/passwd\n 45 103 2499 /etc/passwd\n# wc -l /etc/passwd\n45 /etc/passwd\n# wc -m /etc/passwd\n2499 /etc/passwd\n# wc -w /etc/passwd\n103 /etc/passwd</code></pre>\n<p>如果<code>wc</code>不跟任何选项，直接跟文档，则会把行数、词数和字符数依次输出。<br />&nbsp;</p>\n</li>\n<li><p><strong>命令<code>uniq</code></strong></p>\n<p><code>uniq</code>命令用来删除重复的行，该命令只有<code>-c</code>选项比较常用，它表示统计重复的行数，并把行数写在前面。我们先来编写一个文件，示例命令如下：</p>\n<pre class=\"code-rows\"><code># vim testb.txt // 把下面的内容写入testb.txt并保存\n111\n222\n111\n333</code></pre>\n<p>使用<code>uniq</code>前，必须先给文件排序，否则不管用。示例命令如下：</p>\n<pre class=\"code-rows\"><code># uniq testb.txt\n111\n222\n111\n333\n# sort testb.txt |uniq\n111\n222\n333\n# sort testb.txt |uniq -c\n2 111\n1 222\n1 333</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>命令<code>tee</code></strong></p>\n<p><code>tee</code>命令后面跟文件名，其作用类似于重定向<code>&gt;</code>，但它比重定向多一个功能，即在把文件写入后面所跟文件的同时，还将其显示在屏幕上。该命令常用于管道符<code>|</code>后。示例命令如下：</p>\n<pre class=\"code-rows\"><code># echo \"aaaaaaaaaaaaaaaaaaaaaaaaaaa\" |tee testb.txt\naaaaaaaaaaaaaaaaaaaaaaaaaaa\n# cat testb.txt\naaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>命令<code>tr</code></strong></p>\n<p><code>tr</code>命令用于替换字符，常用来处理文档中出现的特殊符号，如DOS文档中出现的符号<code>^M</code>。该命令常用的选项有以下两个。</p>\n<ul>\n<li><strong><code>-d</code></strong>：表示删除某个字符，后面跟要删除的字符。</li>\n<li><strong><code>-s</code></strong>：表示删除重复的字符。</li>\n</ul>\n<p><code>tr</code>命令常用于把小写字母变成大写字母，如<code>tr '[a-z]' '[A-Z]'</code>。示例命令如下：</p>\n<pre class=\"code-rows\"><code># head -n2 /etc/passwd |tr '[a-z]' '[A-Z]'\nROOT:X:0:0:ROOT:/ROOT:/BIN/BASH\nBIN:X:1:1:BIN:/BIN:/SBIN/NOLOGIN</code></pre>\n<p><code>tr</code>命令还可以替换一个字符，示例命令如下：</p>\n<pre class=\"code-rows\"><code># grep 'root' /etc/passwd |tr 'r' 'R'\nRoot:x:0:0:Root:/Root:/bin/bash\nopeRatoR:x:11:0:opeRatoR:/Root:/sbin/nologin</code></pre>\n<p>不过替换、删除以及去重复等操作都是针对一个字符来讲的，有一定的局限性。如果是针对一个字符串，<code>tr</code>命令就不能再使用了，所以你只需简单了解一下即可。以后，你还会学到更多可以实现字符串操作的工具。<br />&nbsp;</p>\n</li>\n<li><p><strong>命令<code>split</code></strong></p>\n<p><code>split</code>命令用于切割文档，常用的选项为<code>-b</code>和<code>-l</code>。</p>\n<ul>\n<li><p><strong><code>-b</code></strong>：表示依据大小来分割文档，单位为B。示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir split_dir\n# cd !$\ncd split_dir\n# cp /etc/passwd ./\n# split -b 500 passwd\n# ls\npasswd xaa xab xac xad xae</code></pre>\n<p>如果<code>split</code>不指定目标文件名，则会以<code>xaa</code>、<code>xab</code>...这样的文件名来存取切割后的文件。当然，我们也可以指定目标文件名，如下所示：</p>\n<pre class=\"code-rows\"><code># rm –f xa*\n# split -b 500 passwd 123\n# ls\n123aa 123ab 123ac 123ad 123ae passwd</code></pre>\n</li>\n<li><p><strong><code>-l</code></strong>：表示依据行数来分割文档。示例命令如下：</p>\n<pre class=\"code-rows\"><code># rm -f 123a*\n# split -l 10 passwd\n# wc -l *\n 45 passwd\n 10 xaa\n 10 xab\n 10 xac\n 10 xad\n 5 xae\n 90 total</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"nav_point_182\">10.4.6 特殊符号<code>$</code></h3>\n<p>符号<code>$</code>可以用作变量前面的标识符，还可以和<code>!</code>结合起来使用。示例命令如下：</p>\n<pre class=\"code-rows\"><code># cd ..\n# ls testb.txt\ntestb.txt\n# ls !$\nls testb.txt\ntestb.txt</code></pre>\n<p><code>!$</code>表示上条命令中的最后一个变量，本例中上条命令的最后是testb.txt，那么在当前命令下输入<code>!$</code>就代表testb.txt。</p>\n<h3 id=\"nav_point_183\">10.4.7 特殊符号<code>;</code></h3>\n<p>通常，我们都是在一行中输入一个命令，然后回车就表示运行了。如果想在一行中运行两个或两个以上的命令，则需要在命令之间加符号<code>;</code>。示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir testdir ; touch test1.txt ; touch test2.txt; ls -d test*\ntest1.txt test2.txt testb.txt testdir</code></pre>\n<h3 id=\"nav_point_184\">10.4.8 特殊符号<code>~</code></h3>\n<p>符号<code>~</code>表示用户的家目录，root用户的家目录是 /root，普通用户的是 /home/username。示例命令如下：</p>\n<pre class=\"code-rows\"><code># cd ~\n# pwd\n/root\n# su aming\n$ cd ~\n$ pwd\n/home/aming</code></pre>\n<h3 id=\"nav_point_185\">10.4.9 特殊符号<code>&amp;</code></h3>\n<p>如果想把一条命令放到后台执行，则需要加上符号<code>&amp;</code>，它通常用于命令运行时间较长的情况。比如，可以用在<code>sleep</code>后，如下所示：</p>\n<pre class=\"code-rows\"><code># sleep 30 &amp;\n[1] 3808\n# jobs\n[1]+ 运行中 sleep 30 &amp;</code></pre>\n<h3 id=\"nav_point_186\">10.4.10 重定向符号<code>&gt;</code>、<code>&gt;&gt;</code>、<code>2&gt;</code>和<code>2&gt;&gt;</code></h3>\n<p>前面讲过重定向符号<code>&gt;</code>和<code>&gt;&gt;</code>，它们分别表示取代和追加的意思。当我们运行一个命令报错时，报错信息会输出到当前屏幕。如果想重定向到一个文本，则要用重定向符号<code>2&gt;</code>或者<code>2&gt;&gt;</code>，它们分别表示错误重定向和错误追加重定向。示例命令如下：</p>\n<pre class=\"code-rows\"><code># ls aaaa\nls: cannot access 'aaaa': No such file or directory\n# ls aaaa 2&gt; /tmp/error\n# cat /tmp/error\nls: cannot access 'aaaa': No such file or directory\n# ls aaaa 2&gt;&gt; /tmp/error\n# cat /tmp/error\nls: cannot access 'aaaa': No such file or directory\nls: cannot access 'aaaa': No such file or directory</code></pre>\n<h3 id=\"nav_point_187\">10.4.11 中括号<code>[]</code></h3>\n<p>中括号内为字符组合，代表字符组合中的任意一个，可以是一个范围（<code>1-3</code>，<code>a-z</code>），用法如下：</p>\n<pre class=\"code-rows\"><code># cd /tmp/10\n# ls -d test*\ntest1.txt test2.txt testb.txt testdir\n# ls -d test[1-3].txt\ntest1.txt test2.txt\n# ls -d test[12b].txt\ntest1.txt test2.txt testb.txt\n# ls -d test[1-9].txt\ntest1.txt test2.txt\n# ls -d test[1-9a-z].txt\ntest1.txt test2.txt testb.txt</code></pre>\n<h3 id=\"nav_point_188\">10.4.12 特殊符号<code>&amp;&amp;</code>和<code>||</code></h3>\n<p>前面提到了分号可作为多条命令间的分隔符，其实还有两个可以用于多条命令中间的特殊符号，那就是<code>&amp;&amp;</code>和<code>||</code>。下面阿铭列出以下几种情况：</p>\n<ul>\n<li><code>command1 ; command2</code></li>\n<li><code>command1 &amp;&amp; command2</code></li>\n<li><code>command1 || command2</code></li>\n</ul>\n<p>使用<code>;</code>时，不管<code>command1</code>是否执行成功，都会执行<code>command2</code>。</p>\n<p>使用<code>&amp;&amp;</code>时，只有<code>command1</code>执行成功后，<code>command2</code>才会执行，否则<code>command2</code>不执行。</p>\n<p>使用<code>||</code>时，若<code>command1</code>执行成功，则<code>command2</code>不执行，否则执行<code>command2</code>，即<code>command1</code>和<code>command2</code>中总有一条命令会执行。接下来，阿铭要通过做试验来说明<code>&amp;&amp;</code>与<code>||</code>这两个特殊符号的作用：</p>\n<pre class=\"code-rows\"><code># rm -rf test*\n# touch test1 test3\n# ls test2 &amp;&amp; touch test2\nls: cannot access 'test2': No such file or directory\n# ls test2\nls: cannot access 'test2': No such file or directory</code></pre>\n<p>在本例中，只有当<code>ls test2</code>成功执行后，才会执行<code>touch test2</code>。因为test2不存在，<code>ls test2</code>没有执行成功，所以<code>&amp;&amp;</code>后面的<code>touch test2</code>并没有执行。</p>\n<pre class=\"code-rows\"><code># ls test2 || touch test2\nls: cannot access 'test2': No such file or directory\n# ls test*\ntest1 test2 test3</code></pre>\n<p>本例中，若<code>ls test2</code>执行不成功，则会执行<code>touch test2</code>。因为test2不存在，所以<code>ls test2</code>没有执行成功，转而执行<code>||</code>后面的<code>touch test2</code>，然后增加了test2这个文件。</p>\n<h2 id=\"nav_point_189\">10.5 课后习题</h2>\n<p>(1) 请设置环境变量<code>HISTSIZE</code>，使其能够保存10 000条命令历史。</p>\n<p>(2) 如果设置<code>PS1=\"[\\u@\\h \\W]\\$ \"</code>，为什么显示的结果和我们预想的不一样？如何才能恢复默认设置？</p>\n<p>(3) 如何把当前目录下文件的文件名中的小写字母全部替换为大写字母？</p>\n<p>(4) 以<code>:</code>为分隔符，使用<code>sort</code>命令对/etc/passwd文件的第5段排序。</p>\n<p>(5) 以<code>:</code>为分隔符，使用<code>cut</code>命令截出/etc/passwd的第3段字符。</p>\n<p>(6) 简述这几个文件的作用：/etc/profile、/etc/bashrc、.bashrc和.bash_profile。</p>\n<p>(7) <code>export</code>的作用是什么？</p>\n<p>(8) Linux下自定义变量要符合什么样的规则？</p>\n<p>(9) 如何把要运行的命令放到后台运行？如何把后台运行的进程调到前台？</p>\n<p>(10) 列出当前目录下以test开头的文件和目录。</p>\n<p>(11) 如何把一个命令的输出内容打印到屏幕上，并重定向到一个文件内？</p>\n<p>(12) 假如有个命令很长，如何用一个简单的字符串代替这个复杂的命令呢？请举例说明。</p>\n<p>(13) 如何把一个命令放到后台运行，并将其正确输出和错误输出同时重定向到一个文件内？</p>\n<p>(14) 如何按照大小（如10 MB）分隔一个大文件？又如何按照行数（如10 000行）分隔呢？</p>\n<p>(15) 做试验弄清楚<code>;</code>、<code>&amp;&amp;</code>以及<code>||</code>这3个符号的含义。</p>\n<p>(16) 如果只想让某个用户使用某个变量，如何做？</p>\n<p>(17) 使用哪个命令能把系统当中所有的变量以及当前用户定义的自定义变量列出来？</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}