{"id":89494,"title":"13 | 如何利用 RunLoop 原理去监控卡顿？","content":"<p>你好，我是戴铭。今天，我来和你说说如何监控卡顿。</p><p>卡顿问题，就是在主线程上无法响应用户交互的问题。如果一个 App 时不时地就给你卡一下，有时还长时间无响应，这时你还愿意继续用它吗？所以说，卡顿问题对App的伤害是巨大的，也是我们必须要重点解决的一个问题。</p><p>现在，我们先来看一下导致卡顿问题的几种原因：</p><ul>\n<li>复杂 UI 、图文混排的绘制量过大；</li>\n<li>在主线程上做网络同步请求；</li>\n<li>在主线程做大量的IO 操作；</li>\n<li>运算量过大，CPU持续高占用；</li>\n<li>死锁和主子线程抢锁。</li>\n</ul><p>那么，我们如何监控到什么时候会出现卡顿呢？是要监视 FPS 吗？</p><p>以前，我特别喜欢一本叫作《24格》的杂志，它主要介绍的是动画片制作的相关内容。那么，它为啥叫24格呢？这是因为，动画片中1秒钟会用到24张图片，这样肉眼看起来就是流畅的。</p><p>FPS 是一秒显示的帧数，也就是一秒内画面变化数量。如果按照动画片来说，动画片的 FPS 就是24，是达不到60满帧的。也就是说，对于动画片来说，24帧时虽然没有60帧时流畅，但也已经是连贯的了，所以并不能说24帧时就算是卡住了。</p><p>由此可见，简单地通过监视 FPS 是很难确定是否会出现卡顿问题了，所以我就果断弃了通过监视FPS 来监控卡顿的方案。</p><p>那么，我们到底应该使用什么方案来监控卡顿呢？</p><!-- [[[read_end]]] --><h2>RunLoop 原理</h2><p>对于iOS开发来说，监控卡顿就是要去找到主线程上都做了哪些事儿。我们都知道，线程的消息事件是依赖于NSRunLoop 的，所以从NSRunLoop入手，就可以知道主线程上都调用了哪些方法。我们通过监听 NSRunLoop 的状态，就能够发现调用方法是否执行时间过长，从而判断出是否会出现卡顿。</p><p>所以，我推荐的监控卡顿的方案是：通过监控 RunLoop 的状态来判断是否会出现卡顿。</p><p>RunLoop是iOS开发中的一个基础概念，为了帮助你理解并用好这个对象，接下来我会先和你介绍一下它可以做哪些事儿，以及它为什么可以做成这些事儿。</p><p>RunLoop这个对象，在 iOS 里由CFRunLoop实现。简单来说，RunLoop 是用来监听输入源，进行调度处理的。这里的输入源可以是输入设备、网络、周期性或者延迟时间、异步回调。RunLoop 会接收两种类型的输入源：一种是来自另一个线程或者来自不同应用的异步消息；另一种是来自预订时间或者重复间隔的同步事件。</p><p>RunLoop 的目的是，当有事件要去处理时保持线程忙，当没有事件要处理时让线程进入休眠。所以，了解 RunLoop 原理不光能够运用到监控卡顿上，还可以提高用户的交互体验。通过将那些繁重而不紧急会大量占用 CPU 的任务（比如图片加载），放到空闲的 RunLoop 模式里执行，就可以避开在 UITrackingRunLoopMode 这个 RunLoop 模式时是执行。UITrackingRunLoopMode 是用户进行滚动操作时会切换到的 RunLoop 模式，避免在这个 RunLoop 模式执行繁重的 CPU 任务，就能避免影响用户交互操作上体验。</p><p>接下来，我就通过 CFRunLoop 的源码来跟你分享下 RunLoop 的原理吧。</p><h3>第一步</h3><p>通知 observers：RunLoop 要开始进入 loop 了。紧接着就进入 loop。代码如下：</p><pre><code>//通知 observers\nif (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) \n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);\n//进入 loop\nresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);\n</code></pre><h3>第二步</h3><p>开启一个 do while 来保活线程。通知 Observers：RunLoop 会触发 Timer 回调、Source0 回调，接着执行加入的 block。代码如下：</p><pre><code>// 通知 Observers RunLoop 会触发 Timer 回调\nif (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);\n// 通知 Observers RunLoop 会触发 Source0 回调\nif (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeSources)\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);\n// 执行 block\n__CFRunLoopDoBlocks(runloop, currentMode);\n</code></pre><p>接下来，触发 Source0 回调，如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg去处理消息。代码如下：</p><pre><code>if (MACH_PORT_NULL != dispatchPort ) {\n    Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)\n    if (hasMsg) goto handle_msg;\n}\n</code></pre><h3>第三步</h3><p>回调触发后，通知 Observers：RunLoop的线程将进入休眠（sleep）状态。代码如下：</p><pre><code>Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);\nif (!poll &amp;&amp; (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) {\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);\n}\n</code></pre><h3>第四步</h3><p>进入休眠后，会等待 mach_port 的消息，以再次唤醒。只有在下面四个事件出现时才会被再次唤醒：</p><ul>\n<li>基于 port 的 Source 事件；</li>\n<li>Timer 时间到；</li>\n<li>RunLoop 超时；</li>\n<li>被调用者唤醒。</li>\n</ul><p>等待唤醒的代码如下：</p><pre><code>do {\n    __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) {\n        // 基于 port 的 Source 事件、调用者唤醒\n        if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) {\n            break;\n        }\n        // Timer 时间到、RunLoop 超时\n        if (currentMode-&gt;_timerFired) {\n            break;\n        }\n} while (1);\n</code></pre><h3>第五步</h3><p>唤醒时通知 Observer：RunLoop 的线程刚刚被唤醒了。代码如下：</p><pre><code>if (!poll &amp;&amp; (currentMode-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);\n</code></pre><h3>第六步</h3><p>RunLoop 被唤醒后就要开始处理消息了：</p><ul>\n<li>如果是 Timer 时间到的话，就触发 Timer 的回调；</li>\n<li>如果是 dispatch 的话，就执行 block；</li>\n<li>如果是 source1事件的话，就处理这个事件。</li>\n</ul><p>消息执行完后，就执行加到 loop 里的 block。代码如下：</p><pre><code>handle_msg:\n// 如果 Timer 时间到，就触发 Timer 回调\nif (msg-is-timer) {\n    __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())\n} \n// 如果 dispatch 就执行 block\nelse if (msg_is_dispatch) {\n    __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n} \n\n// Source1 事件的话，就处理这个事件\nelse {\n    CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);\n    sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);\n    if (sourceHandledThisLoop) {\n        mach_msg(reply, MACH_SEND_MSG, reply);\n    }\n}\n</code></pre><h3>第七步</h3><p>根据当前 RunLoop 的状态来判断是否需要走下一个 loop。当被外部强制停止或loop 超时时，就不继续下一个 loop 了，否则继续走下一个 loop 。代码如下：</p><pre><code>if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {\n     // 事件已处理完\n    retVal = kCFRunLoopRunHandledSource;\n} else if (timeout) {\n    // 超时\n    retVal = kCFRunLoopRunTimedOut;\n} else if (__CFRunLoopIsStopped(runloop)) {\n    // 外部调用者强制停止\n    retVal = kCFRunLoopRunStopped;\n} else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {\n    // mode 为空，RunLoop 结束\n    retVal = kCFRunLoopRunFinished;\n}\n</code></pre><p>整个 RunLoop 过程，我们可以总结为如下所示的一张图片。<br>\n<img src=\"https://static001.geekbang.org/resource/image/5f/7d/5f51c5e05085badb689f01b1e63e1c7d.png?wh=1920*1080\" alt=\"\"></p><p>这里只列出了 CFRunLoop 的关键代码，你可以点击<a href=\"https://opensource.apple.com/source/CF/CF-1153.18/CFRunLoop.c.auto.html\">这个链接</a>查看完整代码。</p><h3>loop 的六个状态</h3><p>通过对RunLoop原理的分析，我们可以看出在整个过程中，loop的状态包括6个，其代码定义如下：</p><pre><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry , // 进入 loop\n    kCFRunLoopBeforeTimers , // 触发 Timer 回调\n    kCFRunLoopBeforeSources , // 触发 Source0 回调\n    kCFRunLoopBeforeWaiting , // 等待 mach_port 消息\n    kCFRunLoopAfterWaiting ), // 接收 mach_port 消息\n    kCFRunLoopExit , // 退出 loop\n    kCFRunLoopAllActivities  // loop 所有状态改变\n}\n</code></pre><p>如果RunLoop的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。</p><p>所以，如果我们要利用RunLoop原理来监控卡顿的话，就是要关注这两个阶段。RunLoop在进入睡眠之前和唤醒后的两个 loop 状态定义的值，分别是 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting ，也就是要触发 Source0 回调和接收 mach_port 消息两个状态。</p><p>接下来，我们就一起分析一下，如何对loop的这两个状态进行监听，以及监控的时间值如何设置才合理。</p><h2>如何检查卡顿？</h2><p>要想监听 RunLoop，你就首先需要创建一个 CFRunLoopObserverContext 观察者，代码如下：</p><pre><code>CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\nrunLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;runLoopObserverCallBack,&amp;context);\n</code></pre><p>将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。</p><p>一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，我们就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长。</p><p>开启一个子线程监控的代码如下：</p><pre><code>//创建子线程监控\ndispatch_async(dispatch_get_global_queue(0, 0), ^{\n    //子线程开启一个持续的 loop 用来进行监控\n    while (YES) {\n        long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));\n        if (semaphoreWait != 0) {\n            if (!runLoopObserver) {\n                timeoutCount = 0;\n                dispatchSemaphore = 0;\n                runLoopActivity = 0;\n                return;\n            }\n            //BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿\n            if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) {\n                //将堆栈信息上报服务器的代码放到这里\n            } //end activity\n        }// end semaphore wait\n        timeoutCount = 0;\n    }// end while\n});\n</code></pre><p>代码中的 NSEC_PER_SEC，代表的是触发卡顿的时间阈值，单位是秒。可以看到，我们把这个阈值设置成了3秒。那么，这个3秒的阈值是从何而来呢？这样设置合理吗？</p><p>其实，触发卡顿的时间阈值，我们可以根据 WatchDog 机制来设置。WatchDog 在不同状态下设置的不同时间，如下所示：</p><ul>\n<li>启动（Launch）：20s；</li>\n<li>恢复（Resume）：10s；</li>\n<li>挂起（Suspend）：10s；</li>\n<li>退出（Quit）：6s；</li>\n<li>后台（Background）：3min（在iOS 7之前，每次申请10min； 之后改为每次申请3min，可连续申请，最多申请到10min）。</li>\n</ul><p>通过WatchDog 设置的时间，我认为可以把启动的阈值设置为10秒，其他状态则都默认设置为3秒。总的原则就是，要小于 WatchDog的限制时间。当然了，这个阈值也不用小得太多，原则就是要优先解决用户感知最明显的体验问题。</p><h2>如何获取卡顿的方法堆栈信息？</h2><p>子线程监控发现卡顿后，还需要记录当前出现卡顿的方法堆栈信息，并适时推送到服务端供开发者分析，从而解决卡顿问题。那么，在这个过程中，如何获取卡顿的方法堆栈信息呢？</p><p><strong>获取堆栈信息的一种方法是直接调用系统函数。</strong>这种方法的优点在于，性能消耗小。但是，它只能够获取简单的信息，也没有办法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限。这种方法，因为性能比较好，所以适用于观察大盘统计卡顿情况，而不是想要找到卡顿原因的场景。</p><p>直接调用系统函数方法的主要思路是：用 signal 进行错误信息的获取。具体代码如下：</p><pre><code>static int s_fatal_signals[] = {\n    SIGABRT,\n    SIGBUS,\n    SIGFPE,\n    SIGILL,\n    SIGSEGV,\n    SIGTRAP,\n    SIGTERM,\n    SIGKILL,\n};\n\nstatic int s_fatal_signal_num = sizeof(s_fatal_signals) / sizeof(s_fatal_signals[0]);\n\nvoid UncaughtExceptionHandler(NSException *exception) {\n    NSArray *exceptionArray = [exception callStackSymbols]; //得到当前调用栈信息\n    NSString *exceptionReason = [exception reason];       //非常重要，就是崩溃的原因\n    NSString *exceptionName = [exception name];           //异常类型\n}\n\nvoid SignalHandler(int code)\n{\n    NSLog(@&quot;signal handler = %d&quot;,code);\n}\n\nvoid InitCrashReport()\n{\n    //系统错误信号捕获\n    for (int i = 0; i &lt; s_fatal_signal_num; ++i) {\n        signal(s_fatal_signals[i], SignalHandler);\n    }\n    \n    //oc未捕获异常的捕获\n    NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);\n}\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        InitCrashReport();\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n</code></pre><p><strong>另一种方法是，直接用</strong> <a href=\"https://opensource.plausible.coop/src/projects/PLCR/repos/plcrashreporter/browse\"><strong>PLCrashReporter</strong></a><strong>这个开源的第三方库来获取堆栈信息。</strong>这种方法的特点是，能够定位到问题代码的具体位置，而且性能消耗也不大。所以，也是我推荐的获取堆栈信息的方法。</p><p>具体如何使用 PLCrashReporter 来获取堆栈信息，代码如下所示：</p><pre><code>// 获取数据\nNSData *lagData = [[[PLCrashReporter alloc]\n                                          initWithConfiguration:[[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]] generateLiveReport];\n// 转换成 PLCrashReport 对象\nPLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:NULL];\n// 进行字符串格式化处理\nNSString *lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];\n//将字符串上传服务器\nNSLog(@&quot;lag happen, detail below: \\n %@&quot;,lagReportString);\n</code></pre><p>搜集到卡顿的方法堆栈信息以后，就是由开发者来分析并解决卡顿问题了。</p><p>在今天这篇文章中，我们用到的从监控卡顿到收集卡顿问题信息的完整代码，你都可以点击<a href=\"https://github.com/ming1016/DecoupleDemo/blob/master/DecoupleDemo/SMLagMonitor.m\">这个链接</a>查看。</p><h2>小结</h2><p>今天我给你介绍了使用 RunLoop 监控卡顿的方案，我还跟你说了下 RunLoop 的原理，希望能够帮助你更好地理解 RunLoop 监控卡顿的方案。</p><p>读到这里你可能会想，为什么要将卡顿监控放到线上做呢？其实这样做主要是为了能够更大范围的收集问题，如果仅仅通过线下收集卡顿的话，场景无法被全面覆盖。因为，总有一些卡顿问题，是由于少数用户的数据异常导致的。</p><p>而用户反馈的卡顿问题往往都是说在哪个页面卡住了，而具体是执行哪个方法时卡主了，我们是无从得知的。在碰到这样问题时，你一定会感觉手足无措，心中反问一百遍：“我怎么在这个页面不卡，测试也不卡，就你卡”。而且，通过日志我们也很难查出个端倪。这时候，线上监控卡顿的重要性就凸显出来了。</p><p>有时，某个问题看似对 App 的影响不大，但如果这个问题在某个版本中爆发出来了就会变得难以收场。所以，你需要对这样的问题进行有预见性的监控，一方面可以早发现、早解决，另一方面在遇到问题时能够快速定位原因，不至于过于被动。要知道，面对问题的响应速度往往是评判基础建设优劣的一个重要的标准。</p><p>以上就是我们今天的内容了。接下来，我想请你回顾一下你都碰到过哪些卡顿问题，又是如何解决的呢？</p><p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。</p><p></p>","comments":[{"had_liked":false,"id":84064,"user_name":"Geek_a03ab1","can_delete":false,"product_type":"c1","uid":1453971,"ip_address":"","ucode":"28E093FF890033","user_header":"","comment_is_top":false,"comment_ctime":1554776573,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"212008174077","product_id":100024501,"comment_content":"为什么监控 kCFRunLoopBeforeSources、kCFRunLoopAfterWaiting这两个事件就能判断出卡顿呢？为什么不是kCFRunLoopBeforeWaiting、kCFRunLoopAfterWaiting这两个事件呢？没想明白，老师能展开说下吗？","like_count":50,"discussions":[{"author":{"id":1247201,"avatar":"https://static001.geekbang.org/account/avatar/00/13/07/e1/005460c4.jpg","nickname":"凯凯","note":"","ucode":"04A6ECD20B3F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":931,"discussion_content":"第一问题： RunLoop 进入睡眠前会执行source0等方法，唤醒后要接收 mach_port 消息。所以如果执行source0或者接收 mach_port 消息，太耗时，就会导致卡顿。所以监控这两个就可以了。\n\n第二个问题：kCFRunLoopBeforeWaiting（能进这里，说明已经执行完了source0，且不知道source0耗不耗时），所以没监控这个。\n最后：我写了一个适用线下debug性能的工具。大家可以看下。https://juejin.im/post/5d146490f265da1bc37f2065 ","likes_number":20,"is_delete":false,"is_hidden":false,"ctime":1562154991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201998,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/4e/302bfe22.jpg","nickname":"啊波次的额佛哥～","note":"","ucode":"6F31255207CB17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41446,"discussion_content":"因为source0主要是处理App内部事件，如UIEvent等。kCFRunLoopBeforeSources、kCFRunLoopBeforeWaiting之间正好是source0执行时长。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572429197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1932704,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/7d/a0/323dea01.jpg","nickname":"Donkeyman","note":"","ucode":"A24ED814252FC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578087,"discussion_content":"个人认为是戴铭老师的方法有问题，触摸事件等都在kCFRunLoopBeforeSources之后，如果以kCFRunLoopBeforeSources为终点必然会导致很多卡顿监控不到，只能监控到timer触发的，应该是kCFRunLoopBeforeWaiting为终点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656501259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2681398,"avatar":"https://static001.geekbang.org/account/avatar/00/28/ea/36/7d088c63.jpg","nickname":"D","note":"","ucode":"4112DE94C80A5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382979,"discussion_content":"因为timer计时是不耗runloop的时间的，所以并不会在befroreTimer状态卡住","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625814918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1455023,"avatar":"https://static001.geekbang.org/account/avatar/00/16/33/af/29865f56.jpg","nickname":"陈某某","note":"","ucode":"386830645A00A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295443,"discussion_content":"不是应该监听kCFRunloopbeforeTimer吗？timer不回耗时吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596196843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2153689,"avatar":"https://static001.geekbang.org/account/avatar/00/20/dc/d9/129f569f.jpg","nickname":"forping","note":"","ucode":"7495E250F0A017","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1455023,"avatar":"https://static001.geekbang.org/account/avatar/00/16/33/af/29865f56.jpg","nickname":"陈某某","note":"","ucode":"386830645A00A4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319552,"discussion_content":"我理解的是收到beforesource通知发出后开始处理事件，处理完之后状态会改变成beforewaiting。收到afterwaiting也会开始处理事件，处理完之后变成beforetimer。\n也就是说如果长时间停留在beforesource和afterwaiting状态，那么就发生了卡顿。","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1604048898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295443,"ip_address":""},"score":319552,"extra":""},{"author":{"id":1456673,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WRDNkcjDzpFZiaZAXkSED3OlZPeoFY25OqSlK1mdG7T8L7SspDmCQarHo5k7szy0ib4TuTCia8AN9XN7HLdQ8ZicGw/132","nickname":"白成慧","note":"","ucode":"DA1812C8DC05B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1455023,"avatar":"https://static001.geekbang.org/account/avatar/00/16/33/af/29865f56.jpg","nickname":"陈某某","note":"","ucode":"386830645A00A4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361949,"discussion_content":"就是因为要耗时所以才是after waiting 到 before source","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616810037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295443,"ip_address":""},"score":361949,"extra":""}]},{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33990,"discussion_content":"其实不一定的，如果有地方注册了 kCFRunLoopBeforeWaiting 的回调，并做耗时操作，就监控不到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571151668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84455,"user_name":"WeZZard","can_delete":false,"product_type":"c1","uid":1471692,"ip_address":"","ucode":"7499FC0D624F08","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/cc/5ff05eb3.jpg","comment_is_top":false,"comment_ctime":1554866092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"91749179308","product_id":100024501,"comment_content":"單純監控 FPS 確實不行，因為很多卡頓其實是 FPS 變化率的大幅變化（既 FPS 一階導數的波動）所造成的。<br><br>比如說點 A 花一秒匀速位移至點 B，秒間平均幀率 60FPS，但是前 59&#47;60 秒才跑了一幀出來，剩下 59 幀都在後 1&#47;60 秒跑出來，那麼用戶必然看到的是點 A 花了 59&#47;60 秒停在 A + ((B - A)&#47;60) 這個位置上，然後突然「飛」到了 B 點上。<br><br>所以監控 FPS &gt; 24 的同時還要監控 FPS 變化率的波動。而這個波動的成因其實就是主線程上計算任務的性能衝擊。","like_count":22},{"had_liked":false,"id":119221,"user_name":"金阳","can_delete":false,"product_type":"c1","uid":1057331,"ip_address":"","ucode":"5DA949C5970F24","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/33/6b9a7719.jpg","comment_is_top":false,"comment_ctime":1564539285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"87463885205","product_id":100024501,"comment_content":"https:&#47;&#47;blog.ibireme.com&#47;2015&#47;05&#47;18&#47;runloop&#47;  这篇文章讲的更清晰些","like_count":21},{"had_liked":false,"id":84044,"user_name":"鼠辈","can_delete":false,"product_type":"c1","uid":1457947,"ip_address":"","ucode":"F8CD6602D9320E","user_header":"https://static001.geekbang.org/account/avatar/00/16/3f/1b/40293181.jpg","comment_is_top":false,"comment_ctime":1554773597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65979283037","product_id":100024501,"comment_content":"这个3秒是不是太长了，1秒60帧，每帧16.67ms。runlooo会在每次sleep之前去刷新ui，这样的话如果掉了30帧，就是500ms左右，用户的体验就已经下去了，能感觉到卡顿了.<br>","like_count":15},{"had_liked":false,"id":83982,"user_name":"Keep-Moving","can_delete":false,"product_type":"c1","uid":1182631,"ip_address":"","ucode":"76F33C06E07A27","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","comment_is_top":false,"comment_ctime":1554764365,"is_pvip":false,"replies":[{"id":"30353","content":"卡顿后收集造成卡顿的原因","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1554791492,"ip_address":"","comment_id":83982,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57389339213","product_id":100024501,"comment_content":"PLCrashReporter怎么和卡顿检测结合起来呢？我理解它是收集崩溃信息的，但卡顿又不是一定会崩溃","like_count":14,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446201,"discussion_content":"卡顿后收集造成卡顿的原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554791492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1455599,"avatar":"https://static001.geekbang.org/account/avatar/00/16/35/ef/6c177b8a.jpg","nickname":"李刚","note":"","ucode":"78DFB64CAAE200","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128492,"discussion_content":"它是用来收集堆栈信息，卡顿的时候用这个工具来获取堆栈信息，并上报服务端","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578644051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85042,"user_name":"drunkenMouse","can_delete":false,"product_type":"c1","uid":1454037,"ip_address":"","ucode":"AA8CEA703ECBE8","user_header":"","comment_is_top":false,"comment_ctime":1554965070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23029801550","product_id":100024501,"comment_content":"想起以前遇到过的卡顿效果，真的是坑啊。<br><br>印象最深的一次卡顿：在TableView的Cell里访问了数据库。<br><br>其次是在一个答题系统里，多选单选与判断题，一个Cell从最少两个选项、一个选项三到N行，到最多九个选项。然后使用了TableViewCell的高度自动计算，后来换成了自己手动计算并缓存。<br><br>还有Cell的样式太多，后来把尽可能相同的都放到一个Cell里，也就是：一个Cell有七行，如果有四行不显示，那就移除四行，如果需要九行就再加两行。还有就是网络请求同步操作，结果数据过大，然后就做了异步和无数据的默认显示。<br><br>其实我就是从这几个方面下手的：页面重叠部分、简单的动画与显示用CALayer自己画、对象释放与创建的次数、高度自动缓存、autoRelease使用、static使用部分（如单列对象）、UI刷新前的数据处理部分、页面刷新次数、通知和监听的移除、数据的不合理读取、复杂操作尽量异步、<br><br>最后想说下：线程的消息传递依赖于NSRunLoop，函数的调用依赖runtime。感觉二者挺像的。","like_count":6},{"had_liked":false,"id":84946,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":1456901,"ip_address":"","ucode":"8C1AD026C1AC84","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/05/b2776d73.jpg","comment_is_top":false,"comment_ctime":1554948394,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23029784874","product_id":100024501,"comment_content":"卡顿的原因讲的可以，但是讲的RunLoop让我听的头大，有几个疑问请教老师，<br>1，线程与run loop是什么关系。<br>2，mach_port是什么，第一次进入runloop，也是mach_port触发的吗，<br>3.进入休眠状态的runloop为什么要等mach_port.<br>4,系统会有多个runloop吗，不同runloop之间是串行还是并行执行的？","like_count":5,"discussions":[{"author":{"id":1454319,"avatar":"","nickname":"我唔知点死啊","note":"","ucode":"032CCE72B8F848","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2253,"discussion_content":"试着回答你的问题，供参考：\n1. RunLoop和线程是一一对应的关系，RunLoop负责帮线程处理事件，也可以让线程休眠或运行。主线程会默认开启RunLoop，而子线程的RunLoop需要我们手动开启。\n2. mach_port可以简单理解为内核的端口，基于port的事件属于source1类型；RunLoop在创建时就开始跑起来，然后处理timer、source0、source1等事件，而不是由mach_port触发的RunLoop。\n3. 相当于“你睡着了，有人喊你去吃小龙虾，你才愿意起来”。\n4. 每个线程都有RunLoop，包括主线程和子线程。","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1563415944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1370803,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqjE1jnLSxBgqqOqLjAWmcebaT54HdTdQphUI6u739EN8iaeuI4ITfacdT4jjrYyCgFicb26h12jptQ/132","nickname":"王荣荣","note":"","ucode":"58E5BF932D56C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1454319,"avatar":"","nickname":"我唔知点死啊","note":"","ucode":"032CCE72B8F848","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214087,"discussion_content":"第四点不全对。主线程是会创建runloop的，子线程要去主动获取才会创建runloop","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1585145627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2253,"ip_address":""},"score":214087,"extra":""}]},{"author":{"id":1263832,"avatar":"https://static001.geekbang.org/account/avatar/00/13/48/d8/51ab657d.jpg","nickname":"Sun0010","note":"","ucode":"92B35625DCEB9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46565,"discussion_content":"其实是在主线程里面注入一个 runloop监听， 在子线程检查是否卡顿。检查卡顿方法 就是通过 信号量 的 signal 和 wait(时间阀)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573182171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225818,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1591866378,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18771735562","product_id":100024501,"comment_content":"点击事件超时，kCFRunLoopBeforeSources、kCFRunLoopAfterWaiting  监控不了","like_count":4,"discussions":[{"author":{"id":1456297,"avatar":"https://static001.geekbang.org/account/avatar/00/16/38/a9/c8fa9fe0.jpg","nickname":"宇","note":"","ucode":"948E989CC39A5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336592,"discussion_content":"是的，而且文章中timeoutCount的作用也忽略了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608630657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91358,"user_name":"董仕卿","can_delete":false,"product_type":"c1","uid":1455438,"ip_address":"","ucode":"4A6C4947B381B7","user_header":"https://static001.geekbang.org/account/avatar/00/16/35/4e/5095f5b6.jpg","comment_is_top":false,"comment_ctime":1557014559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18736883743","product_id":100024501,"comment_content":"你这不是在讲runloop的源码嘛","like_count":4},{"had_liked":false,"id":84731,"user_name":"Wechat Team","can_delete":false,"product_type":"c1","uid":1040836,"ip_address":"","ucode":"7283FEFF36E89E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e1/c4/15f70de2.jpg","comment_is_top":false,"comment_ctime":1554899868,"is_pvip":false,"replies":[{"id":"30721","content":"获取堆栈的方法任何时候都可以调的。闪退只是一个时机","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555139942,"ip_address":"","comment_id":84731,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14439801756","product_id":100024501,"comment_content":"文章提到可以『直接调用系统函数』来获取堆栈，但是通过注册那几个信号的方式获取堆栈，一般不是在闪退的情况下才可以触发回调吗？<br>请老师指点","like_count":3,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446431,"discussion_content":"获取堆栈的方法任何时候都可以调的。闪退只是一个时机","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555139942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89154,"user_name":"天涯","can_delete":false,"product_type":"c1","uid":1456119,"ip_address":"","ucode":"A55EFE95E8B09D","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/f7/12a952a0.jpg","comment_is_top":false,"comment_ctime":1556093165,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10146027757","product_id":100024501,"comment_content":"runloop监听kCFRunLoopBeforeSources做ui刷新，为什么还需要监听kCFRunLoopAfterWaiting来判定卡顿","like_count":3,"discussions":[{"author":{"id":1454319,"avatar":"","nickname":"我唔知点死啊","note":"","ucode":"032CCE72B8F848","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2258,"discussion_content":"kCFRunLoopAfterWaiting的意思是：唤醒线程，准备处理事件。如果一直是这个状态，表示线程一直处于准备阶段，长期的表现就是卡顿。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1563416783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079152,"avatar":"https://static001.geekbang.org/account/avatar/00/10/77/70/466368e1.jpg","nickname":"杰森莫玛","note":"","ucode":"A29AEC27270657","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325162,"discussion_content":"后者的意思是线程唤醒了，该起来干活了，但不能一直干下去","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605249130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84000,"user_name":"鹏哥","can_delete":false,"product_type":"c1","uid":1459217,"ip_address":"","ucode":"FFF5EBDF4606CA","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/11/37ec1136.jpg","comment_is_top":false,"comment_ctime":1554768293,"is_pvip":false,"replies":[{"id":"30735","content":"图片少感觉不出，当图片大、列表长、快速滚动时会有区别","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555145617,"ip_address":"","comment_id":84000,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10144702885","product_id":100024501,"comment_content":"老师，请问下，如果我在用户滑动界面的时候不去加载图片，等停止滑动的时候再去加载图片，这个场景用runloop或者scrollview的代理来实现，和使用sdwebimage异步下载图片有什么区别，这几种方式貌似都没有影响用户滑动体验！","like_count":2,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446210,"discussion_content":"图片少感觉不出，当图片大、列表长、快速滚动时会有区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555145617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296036,"user_name":"Geek_a6d9b0","can_delete":false,"product_type":"c1","uid":1672136,"ip_address":"","ucode":"269F95C1AE78AF","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUmLkzxSWpS3I74CcHegN1SRQ3L000oUazjnk7KGwJN98vmibZkpogxiaqYoEEJ5zFfWXSwXjAw4Uw/132","comment_is_top":false,"comment_ctime":1622712699,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5917679995","product_id":100024501,"comment_content":" 戴老大， CFRunLoopObserverCreate 创建观察者的时候 order 传 0 对于点击 tableViewCell 造成的卡顿检测不到，要改成LONG_MAX 才以后可以检测到了。 ","like_count":1,"discussions":[{"author":{"id":2808238,"avatar":"","nickname":"Geek_323ea0","note":"","ucode":"683F200933C88B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579399,"discussion_content":"为什么我可以监听到？好奇怪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657429142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1233474,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJaWphQ3iaZnYfRrWuWtwTFibaZMjJ7d87oHTStU8iaVyhn6WBOPCtickE8PsOGtoe9pX9dX3bjMA9NFQ/132","nickname":"sellseal","note":"","ucode":"50A68FD08313E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532977,"discussion_content":"用于其他测试用例时确实也有这个问题，LONG_MAX比较有效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637745330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233333,"user_name":"夏至","can_delete":false,"product_type":"c1","uid":1004276,"ip_address":"","ucode":"AEC901AB1637D7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLDW0y0ZHYVRgkrGt16ylsklKoZEGiaalibWBjIDUKZtY3PeMpZckTsoKEetWRSkxrS2fLgibxJA4WtIw/132","comment_is_top":false,"comment_ctime":1594289903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889257199","product_id":100024501,"comment_content":"swift 版本CFRunLoopObserver创建，通过runloopObserverHandle处理超时判断<br>        self.runloopObserver = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, CFRunLoopActivity.allActivities.rawValue, true, 0, { [weak self] (observer, activity) in<br>            guard let strongSelf = self else {<br>                return<br>            }<br>            <br>            strongSelf.runloopObserverHandle(observer: observer, activity: activity)<br>        })<br>        <br>        CFRunLoopAddObserver(CFRunLoopGetMain(), self.runloopObserver, CFRunLoopMode.commonModes)<br>","like_count":1},{"had_liked":false,"id":94416,"user_name":"菲夜","can_delete":false,"product_type":"c1","uid":1458588,"ip_address":"","ucode":"5801988425CAB7","user_header":"https://static001.geekbang.org/account/avatar/00/16/41/9c/47d390e6.jpg","comment_is_top":false,"comment_ctime":1557804820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852772116","product_id":100024501,"comment_content":"作者认为并不能说 24 帧时就算是卡住了，确实 24 帧确实算不上卡，但是24 帧是用在观看电影上的，而APP或者游戏因为显示机制并不一样，24 帧在视觉观感其实还是会感觉有卡顿，用户体验不佳。<br><br>","like_count":1},{"had_liked":false,"id":89077,"user_name":"Xcode","can_delete":false,"product_type":"c1","uid":1486793,"ip_address":"","ucode":"A02514CE1B6408","user_header":"","comment_is_top":false,"comment_ctime":1556072335,"is_pvip":false,"replies":[{"id":"32670","content":"我觉跨平台的话优先选择使用 RN 或者 Flutter ","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1556891929,"ip_address":"","comment_id":89077,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5851039631","product_id":100024501,"comment_content":"谢谢老师的文章，受益匪浅，尽管好多RunLoop的代码没怎么看懂，但是会去啃的，眼前有个问题想请教下：关于现在跨平台混合开发，怎么看待？基本都不用原生代码了，我现在的团队都是用ionic+Cordova，每天都是用前端Angular写代码，我担心这样下去会废了，谢谢老师","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448005,"discussion_content":"我觉跨平台的话优先选择使用 RN 或者 Flutter ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556891929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1416371,"avatar":"https://static001.geekbang.org/account/avatar/00/15/9c/b3/d1653155.jpg","nickname":"张松超","note":"","ucode":"A1FC90C38AF017","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381172,"discussion_content":"你不会是花旗的吧 哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624936586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88564,"user_name":"Geek__b82782469097","can_delete":false,"product_type":"c1","uid":1457785,"ip_address":"","ucode":"50BD88CB50531C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK9ma0nrF2yicbQ079mTDd6RdN6hOEnLL1ePEY3arqxQSc1EAGQTJjqSHaFlRtnB3YzXpp8kPdXu9w/132","comment_is_top":false,"comment_ctime":1555943006,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5850910302","product_id":100024501,"comment_content":"请问swift是如何检测卡顿的呢？也是runloop么？","like_count":1,"discussions":[{"author":{"id":1243460,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/44/1a5e5992.jpg","nickname":"Tracy.li","note":"","ucode":"0338DEC133CC9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302154,"discussion_content":"Swift性能极高 不会卡顿的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598800664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84381,"user_name":"庞佳星","can_delete":false,"product_type":"c1","uid":1165842,"ip_address":"","ucode":"CA1070E4AA5716","user_header":"https://static001.geekbang.org/account/avatar/00/11/ca/12/de485542.jpg","comment_is_top":false,"comment_ctime":1554856470,"is_pvip":false,"replies":[{"id":"30726","content":"后面会专门说","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555144014,"ip_address":"","comment_id":84381,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849823766","product_id":100024501,"comment_content":"老大，啥时候讲讲，resct native  和iOS的关系。谢谢啦，","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446339,"discussion_content":"后面会专门说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555144014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332072,"user_name":"Geek_ea2f98","can_delete":false,"product_type":"c1","uid":1467400,"ip_address":"","ucode":"FA715D80F5BBB1","user_header":"","comment_is_top":false,"comment_ctime":1643006793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643006793","product_id":100024501,"comment_content":"大佬你好，我试过写一个tableview列表，然后cell加载上面写sleep(1)来模拟卡顿问题，他这样确实也导致了FPS帧率下降了很多，保持在10-20帧率，很卡，但是activity太的枚举一直在kCFRunLoopBeforeWaiting上面，kCFRunLoopBeforeSources和kCFRunLoopAfterWaiting这两个枚举根本就没走，这是为何呢，我查阅了好些博客，对比了跟别人写的代码，甚至拷贝别人代码出来，结果都是一样的。","like_count":0},{"had_liked":false,"id":331453,"user_name":"Evan","can_delete":false,"product_type":"c1","uid":1467900,"ip_address":"","ucode":"DF28E8B4CA1FD1","user_header":"https://static001.geekbang.org/account/avatar/00/16/65/fc/a2247327.jpg","comment_is_top":false,"comment_ctime":1642591213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642591213","product_id":100024501,"comment_content":"我在看源码的同时看你的这章课程，有一个疑惑，你把do while保活线程的执行顺序放在了进入loop之后。但是源码中CFRunLoopRun函数里执行了第一个do while，条件是不等于stop后者finish。然后在__CFRunLoopRun函数执行了第二个do while()，条件是等于0，在__CFRunLoopRun函数即将走完的时候可能会更新这个retVal值，跳出第二个循环，然后来到第一个循环里继续执行。按照代码的执行逻辑，是否可以说先开启do while保活线程，然后开始进入loop；","like_count":0},{"had_liked":false,"id":301694,"user_name":"D","can_delete":false,"product_type":"c1","uid":2681398,"ip_address":"","ucode":"4112DE94C80A5B","user_header":"https://static001.geekbang.org/account/avatar/00/28/ea/36/7d088c63.jpg","comment_is_top":false,"comment_ctime":1625814760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625814760","product_id":100024501,"comment_content":"第四步里面的被调用者唤醒，这里的调用者指的是什么呢？","like_count":0},{"had_liked":false,"id":285688,"user_name":"xilie","can_delete":false,"product_type":"c1","uid":1013805,"ip_address":"","ucode":"AFCC4E157F7830","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVegfjqa0gM4hcRrBhZkIf7Uc5oeTMYsg6o5pd76IQlUoIIh2ic6P22xVEFtRnAzjyLtiaPVstkKug/132","comment_is_top":false,"comment_ctime":1616979711,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616979711","product_id":100024501,"comment_content":"为什么run loop的死循环不会导致卡死或闪退","like_count":0,"discussions":[{"author":{"id":1040432,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e0/30/44b742ca.jpg","nickname":"LJ","note":"","ucode":"ACDBF87220B376","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389429,"discussion_content":"查查这个就知道了 mach_msg() -> mach_msg_trap()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629274609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284084,"user_name":"大梦","can_delete":false,"product_type":"c1","uid":1457976,"ip_address":"","ucode":"57C82D847792B7","user_header":"https://static001.geekbang.org/account/avatar/00/16/3f/38/eb83055b.jpg","comment_is_top":false,"comment_ctime":1616059259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616059259","product_id":100024501,"comment_content":"有几个问题：<br>1. 采用这种方式在iOS 14上 没监测到卡顿","like_count":0},{"had_liked":false,"id":257141,"user_name":"Geek_ea6a61","can_delete":false,"product_type":"c1","uid":2039289,"ip_address":"","ucode":"4E88FCA3B77B3E","user_header":"","comment_is_top":false,"comment_ctime":1603860708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603860708","product_id":100024501,"comment_content":"因为我学习 iOS 都在英语语境下学的。看老师的文章稍微有点吃力。我刚刚发现了这个文章好像有人将您的文章翻译成了英文。<br><br>https:&#47;&#47;www.programmersought.com&#47;article&#47;17734733623&#47;","like_count":0},{"had_liked":false,"id":213498,"user_name":"毛成方","can_delete":false,"product_type":"c1","uid":1459289,"ip_address":"","ucode":"DFBF3D464D8D7C","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/59/9cc7d8cd.jpg","comment_is_top":false,"comment_ctime":1588434202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588434202","product_id":100024501,"comment_content":"再次学习 有新的收获 因为前段时间在项目的坑中爬上来  ","like_count":0},{"had_liked":false,"id":205812,"user_name":"Geek_9dbcb4","can_delete":false,"product_type":"c1","uid":1785940,"ip_address":"","ucode":"BB92D5E844A743","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rWMGIQG1z13nekorr9I4PY1w7rlskssf949IQ24SvIewpM7mmZoH2QEZ2aKHu5tkmicGQ7KTGrN9vFYhrDsdp9w/132","comment_is_top":false,"comment_ctime":1586742661,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1586742661","product_id":100024501,"comment_content":"是不是也存在这种可能：当前状态是BeforeSources，3s时检测的状态是BeforeSources，这个BeforeSources有没有可能是下一次的runloop的BeforeSources？","like_count":0,"discussions":[{"author":{"id":1453696,"avatar":"https://static001.geekbang.org/account/avatar/00/16/2e/80/825426e0.jpg","nickname":"绍清","note":"","ucode":"4B6D8B964691A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263142,"discussion_content":"没有可能，有信号量进行同步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589179787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1974740,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/wDycDxGlaMDlyH1UXlPaXPCgFDuibzwKcSL5f3525BWBUsYWc74URrI2esibvOSkPh4jZg9tcUH40mnk721by1EA/132","nickname":"Geek_106aee","note":"","ucode":"A5F196F3EFE3D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1453696,"avatar":"https://static001.geekbang.org/account/avatar/00/16/2e/80/825426e0.jpg","nickname":"绍清","note":"","ucode":"4B6D8B964691A3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274947,"discussion_content":"能讲细点吗，大佬，这里就能保证监听的是之前的BeforeSources？不是其他触发的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590636460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263142,"ip_address":""},"score":274947,"extra":""}]}]},{"had_liked":false,"id":195554,"user_name":"Snow同學","can_delete":false,"product_type":"c1","uid":1390875,"ip_address":"","ucode":"231E98C721E4D2","user_header":"https://static001.geekbang.org/account/avatar/00/15/39/1b/bcabd223.jpg","comment_is_top":false,"comment_ctime":1585196506,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1585196506","product_id":100024501,"comment_content":"线上app，可以一直用子线程，检测主线程嘛。会不会很大性能消耗","like_count":0,"discussions":[{"author":{"id":1079152,"avatar":"https://static001.geekbang.org/account/avatar/00/10/77/70/466368e1.jpg","nickname":"杰森莫玛","note":"","ucode":"A29AEC27270657","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586240,"discussion_content":"感觉是会有这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662053479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1453696,"avatar":"https://static001.geekbang.org/account/avatar/00/16/2e/80/825426e0.jpg","nickname":"绍清","note":"","ucode":"4B6D8B964691A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263143,"discussion_content":"不会，有信号量进行同步，当被锁上时，线程处于挂起状态，性能消耗很少的，获取调用堆栈可能消耗点性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589179865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1455023,"avatar":"https://static001.geekbang.org/account/avatar/00/16/33/af/29865f56.jpg","nickname":"陈某某","note":"","ucode":"386830645A00A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1453696,"avatar":"https://static001.geekbang.org/account/avatar/00/16/2e/80/825426e0.jpg","nickname":"绍清","note":"","ucode":"4B6D8B964691A3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298010,"discussion_content":"信号量不是设置了超时吗，循环会一直循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597144295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263143,"ip_address":""},"score":298010,"extra":""}]}]},{"had_liked":false,"id":176599,"user_name":"魅影","can_delete":false,"product_type":"c1","uid":1360952,"ip_address":"","ucode":"F26F7F1331A4DA","user_header":"https://static001.geekbang.org/account/avatar/00/14/c4/38/e0fefa2b.jpg","comment_is_top":false,"comment_ctime":1581095796,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1581095796","product_id":100024501,"comment_content":"long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));  初始化了一个信号量为0，dispatch_semaphore_wait 肯定会阻塞，不太理解这个地方的逻辑？大家帮我梳理下","like_count":0,"discussions":[{"author":{"id":2046550,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLqxY3fx9Cs0BCxyuOqdlMY8UFZul9TEVp1rAKD16z3VHncBpfHAficsdHrxN6wUqH4xWFiby31iaZWA/132","nickname":"guoran","note":"","ucode":"D16D9F97219D9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294156,"discussion_content":"初始化了一个信号量为0，dispatch_semaphore_wait确实是会被阻塞，但是阻塞的时间是20*NSEC_PER_MSEC，过了这个时间就是超时，超时后就不再阻塞，返回码为非0的一个数字，同时因为注册了观察者，并且将观察者加入了common标记的mode中，所以，原则上说所有的事件（如进入runloop、处理timer、处理source0、睡眠前、唤醒前、退出前等事件）都会被观察者进行回调，即调用runLoopObserverCallBack，而这个方法里面会对信号量+1，因此刚才你疑问的loop就不再阻塞，并且返回值为0（即成功不阻塞），从作者的代码来看，意图其实是监控每次两次事件之间的时间是否超过作者设定的阈值，超过即为阻塞，作者进行的dispatch_semaphore_signal和dispatch_semaphore_wait就不会配对出现（当然这里也不是真正的配对）只是在作者设定的时间段如20 * NSEC_PER_MSEC 内，dispatch_semaphore_signal一定要使信号+1，否则就会超时，但是信号+1的前提是runloop进行了某些事件如进入runloop、处理timer、处理source0、睡眠前、唤醒前、退出前等事件，这些事件都会被观察者监听到从而使信号量+1，而这些事件之间的间隔不能超过20 * NSEC_PER_MSEC，如果超过则dispatch_semaphore_wait超时，从作者的代码上看超时后就直接退出（不知道作者的代码是有问题还是后来误改造成的，抑或是我等理解不到位？）个人觉得超时才应该监听是否是是kCFRunLoopBeforeSources和kCFRunLoopAfterWaiting，如果是就证明和下个事件之间的事件间隔过长可能是出现的卡顿事件，也希望作者能解答一下……","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595812045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1596295,"avatar":"","nickname":"Geek_ca0e74","note":"","ucode":"EEE4BEAFF1238B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2046550,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLqxY3fx9Cs0BCxyuOqdlMY8UFZul9TEVp1rAKD16z3VHncBpfHAficsdHrxN6wUqH4xWFiby31iaZWA/132","nickname":"guoran","note":"","ucode":"D16D9F97219D9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310114,"discussion_content":"超时之后，dispatch_semaphore_wait返回一个非0的值，然后判断当前的runLoopActivity，没有直接退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601623945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294156,"ip_address":""},"score":310114,"extra":""}]}]},{"had_liked":false,"id":165905,"user_name":"小宇","can_delete":false,"product_type":"c1","uid":1453781,"ip_address":"","ucode":"EB9C1E955434A2","user_header":"https://static001.geekbang.org/account/avatar/00/16/2e/d5/fa9300aa.jpg","comment_is_top":false,"comment_ctime":1577343822,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577343822","product_id":100024501,"comment_content":"为什么监控 kCFRunLoopBeforeSources、kCFRunLoopAfterWaiting这两个事件就能判断出卡顿呢？kCFRunLoopBeforeWaiting不是也做一些UI的刷新吗，这个时间过长不也是会造成卡顿吗","like_count":1},{"had_liked":false,"id":158870,"user_name":"hwacdx","can_delete":false,"product_type":"c1","uid":1759590,"ip_address":"","ucode":"F921C10D05F576","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d9/66/0c9a6cf0.jpg","comment_is_top":false,"comment_ctime":1575467539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575467539","product_id":100024501,"comment_content":"请问 DecoupleDemo 允许之后，以下句话是在哪里打印的？<br><br>[UIWorkIntervalTiming] workIntervalStart: startTimestamp &gt; targetTimestamp; rolling forward by 0.250000<br><br>而且 DecoupleDemo 中并没有打印 卡顿的方法堆栈信息啊","like_count":0},{"had_liked":false,"id":155904,"user_name":"Donovan Mitchell Sr.","can_delete":false,"product_type":"c1","uid":1463473,"ip_address":"","ucode":"CC914095E67D99","user_header":"https://static001.geekbang.org/account/avatar/00/16/54/b1/326c743b.jpg","comment_is_top":false,"comment_ctime":1574776840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574776840","product_id":100024501,"comment_content":"老师请问方法调用死循环可以用这个原理来监控吗？试了一下一旦子线程是有间隔地去监控的话就会被死循环给打断","like_count":0},{"had_liked":false,"id":150032,"user_name":"吃土豆的Panda      🍀","can_delete":false,"product_type":"c1","uid":1453954,"ip_address":"","ucode":"DAD58CC74191CE","user_header":"https://static001.geekbang.org/account/avatar/00/16/2f/82/7eb12afb.jpg","comment_is_top":false,"comment_ctime":1573450631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573450631","product_id":100024501,"comment_content":"怎么区分是ui操作，还是io操作，还是计算呢？如果不区分是不是信息数据很难维护，很难排查问题？","like_count":0},{"had_liked":false,"id":147197,"user_name":"Master","can_delete":false,"product_type":"c1","uid":1454833,"ip_address":"","ucode":"642F865923C98A","user_header":"https://static001.geekbang.org/account/avatar/00/16/32/f1/54575096.jpg","comment_is_top":false,"comment_ctime":1572836221,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1572836221","product_id":100024501,"comment_content":"开启子线程监控那段代码看不懂：<br>1、为什么只有 wait 没有 signal 这样的结果不就是 wait 返回结果一直不为 0；<br>2、为什么是 while 死循环，每次监听回调都有一个死循环，n 次监听回调过来是否同时有 n 个死循环在检测；<br>3、activity 为什么非得是那两个（ kCFRunLoopBeforeSources、kCFRunLoopAfterWaiting）；<br>3、","like_count":0,"discussions":[{"author":{"id":1461375,"avatar":"","nickname":"liuhongwei","note":"","ucode":"A6AE4517623D0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196582,"discussion_content":"signal在观察者中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583342655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145608,"user_name":"矮个子先生😝","can_delete":false,"product_type":"c1","uid":1147205,"ip_address":"","ucode":"2242A457B0E10D","user_header":"https://static001.geekbang.org/account/avatar/00/11/81/45/9aa91b75.jpg","comment_is_top":false,"comment_ctime":1572327930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572327930","product_id":100024501,"comment_content":"老师,看git上的代码,在监控回调里,有个if (++timeoutCount &lt; 3)这个被注掉了,我想本来是需要的吧,但我改成 if (++timeoutCount &lt; 2) ,两次监听都维持同一个状态,说明卡顿","like_count":0},{"had_liked":false,"id":124223,"user_name":"茄菲","can_delete":false,"product_type":"c1","uid":1596762,"ip_address":"","ucode":"9C90F25B997FE3","user_header":"https://static001.geekbang.org/account/avatar/00/18/5d/5a/152d792e.jpg","comment_is_top":false,"comment_ctime":1565837080,"is_pvip":false,"replies":[{"id":"45992","content":"这样可以避免影响用户操作的流畅","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1566154700,"ip_address":"","comment_id":124223,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1565837080","product_id":100024501,"comment_content":"&quot;将那些繁重而不紧急会大量占用 CPU 的任务（比如图片加载）放到空闲的 RunLoop 模式里执行就可以避开在 UITrackingRunLoopMode这个 RunLoop 模式时是执行&quot;<br>这样和将任务放置在异步线程里执行有什么区别呢？或者是这样有什么好处吗","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463067,"discussion_content":"这样可以避免影响用户操作的流畅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566154700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014258,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/f2/465a80c0.jpg","nickname":"往来谁是白丁","note":"","ucode":"C33D34C638B6E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59447,"discussion_content":"线程和runloop是一对一的关系。空闲的runloop可以简单理解为放在子线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574689022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123745,"user_name":"茄菲","can_delete":false,"product_type":"c1","uid":1596762,"ip_address":"","ucode":"9C90F25B997FE3","user_header":"https://static001.geekbang.org/account/avatar/00/18/5d/5a/152d792e.jpg","comment_is_top":false,"comment_ctime":1565749873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565749873","product_id":100024501,"comment_content":"如何检查卡顿<br>CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL}; <br>CFRunLoopObserverContext 创建少了一个参数","like_count":0},{"had_liked":false,"id":117698,"user_name":"摇摆迈克","can_delete":false,"product_type":"c1","uid":1010399,"ip_address":"","ucode":"721F2046C8D6BB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLLMGCcYZHdAJg7CpoO4kF7srVDkyO2yXRMia9ck74nMbGwjzXYicVfAuYDqz6oUeOswm4Z78CWkPVQ/132","comment_is_top":false,"comment_ctime":1564113388,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1564113388","product_id":100024501,"comment_content":"前面12章说到卡顿的时候是不会有signal信号捕获，这篇提到卡顿时通过signal获取堆栈信息，搞不懂了老师","like_count":0,"discussions":[{"author":{"id":1458931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","nickname":"蹦哒","note":"","ucode":"56591A657DE7C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4539,"discussion_content":"这里主要关注的是UncaughtExceptionHandler","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565529505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104889,"user_name":"亡命之徒","can_delete":false,"product_type":"c1","uid":1096669,"ip_address":"","ucode":"5B0ADD558F9712","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/dd/5d473145.jpg","comment_is_top":false,"comment_ctime":1560864040,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1560864040","product_id":100024501,"comment_content":" if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) {<br>                    &#47;&#47;出现三次出结果<br>&#47;&#47;                    if (++timeoutCount &lt; 3) {<br>&#47;&#47;                        continue;<br>&#47;&#47;                    }<br>                    NSLog(@&quot;monitor trigger&quot;);<br>                    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{<br>&#47;&#47;                        [SMCallStack callStackWithType:SMCallStackTypeAll];<br>                    });<br>                }<br><br>这里打印堆栈的信息始终执行啊，是不是有问题","like_count":0,"discussions":[{"author":{"id":1642151,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0e/a7/9b79c245.jpg","nickname":"null","note":"","ucode":"B0ACD1B5CA541B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352476,"discussion_content":"我也发现这个问题了,注释掉了usleep,dispatch_semaphore_wait返回一直都是49，进入了状态判断.按道理不是信号量超时才会进入下面这段吗?\nif (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) {\n}\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614750186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1454319,"avatar":"","nickname":"我唔知点死啊","note":"","ucode":"032CCE72B8F848","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2254,"discussion_content":"把&#34;if&#34;那段的注释关掉试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563416077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96277,"user_name":"凡","can_delete":false,"product_type":"c1","uid":1041878,"ip_address":"","ucode":"BCF83BE1D434D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/d6/37a1be71.jpg","comment_is_top":false,"comment_ctime":1558378049,"is_pvip":false,"replies":[{"id":"35009","content":"可以，监控是监控主线程，获取到卡顿时的信息是全部线程的方法调用堆栈信息，这样就能看到卡顿时其他线程的情况。也需要结合线程 CPU 使用率和一些用户所在场景的埋点进行综合判断。","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1558846559,"ip_address":"","comment_id":96277,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558378049","product_id":100024501,"comment_content":"您好，我请教一个问题，我看好像大多数监控卡顿都是UI主线程上，我想知道音视频播放以及直播的这种卡顿能否用这种方式监测到！通常直播这种流畅程度都是通过服务器端监控的，但是对于小公司来说，对接的直播基本都是第三方的库和服务平台，所以不太好太太去三方服务平台拉日志！所以如果我这种对接第三方直播库的app，如果我想把这种监控放到客户端来做，应该如何处理呢？谢谢，期待您解决我的疑问","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450808,"discussion_content":"可以，监控是监控主线程，获取到卡顿时的信息是全部线程的方法调用堆栈信息，这样就能看到卡顿时其他线程的情况。也需要结合线程 CPU 使用率和一些用户所在场景的埋点进行综合判断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558846559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94728,"user_name":"PEI LIANG","can_delete":false,"product_type":"c1","uid":1501372,"ip_address":"","ucode":"F6D60FB4F54E4E","user_header":"https://static001.geekbang.org/account/avatar/00/16/e8/bc/5a90f882.jpg","comment_is_top":false,"comment_ctime":1557886173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557886173","product_id":100024501,"comment_content":"kCFRunLoopBeforeSources、kCFRunLoopAfterWaiting 用这两个状态来判断，个人理解是runloop处于这两个状，都有可能存在需要执行的工作，所以存在超时的可能，而且这种超时跟程序员的操作有关系。根据这种理解的话kCFRunLoopBeforeTimers 也应该加入在内，带来的好处是如果因为在该状态下执行耗时操作会被捕捉到，如果没有就什么也不影响。","like_count":0},{"had_liked":false,"id":92213,"user_name":"yyx","can_delete":false,"product_type":"c1","uid":1373845,"ip_address":"","ucode":"BF391916EB910C","user_header":"","comment_is_top":false,"comment_ctime":1557202077,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1557202077","product_id":100024501,"comment_content":"我在用runloop做线程保活，使用defaultRunLoopMode可以，但是换成CommonRunLoopMode就不行了，这是为什么啊","like_count":0,"discussions":[{"author":{"id":1344488,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/e8/f726c635.jpg","nickname":"加温后的啤酒","note":"","ucode":"5F30978CDB1606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42130,"discussion_content":"[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; 这里是不能用commonModes的，因为CommonModes不是一个真的的Mode，只是一个标记。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572595611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2151092,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Z8t0JKFjnmfO8eyXnIMoqBpl27qUw9s1wPFnDJ7ybgporNJS78Xrib3HP3LwuuUUC2gqXOA7WvMCouS3bwP964g/132","nickname":"Geek_e5560a","note":"","ucode":"7FC3ED69F80000","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568744,"discussion_content":"同一时间RunLoop只能在一种mode下运行，切换mode要先退出当前RunLoop。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651218031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1454319,"avatar":"","nickname":"我唔知点死啊","note":"","ucode":"032CCE72B8F848","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2256,"discussion_content":"我试过可以，我是这样写的：\n// 给子线程添加一个port\nNSRunLoop* runLoop = [NSRunLoop currentRunLoop];\n[runLoop addPort:[NSPort port] forMode:NSRunLoopCommonModes];\n[runLoop run];","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563416508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92184,"user_name":"三刀流剑客","can_delete":false,"product_type":"c1","uid":1453977,"ip_address":"","ucode":"B958771DE190BB","user_header":"https://static001.geekbang.org/account/avatar/00/16/2f/99/918e9b2a.jpg","comment_is_top":false,"comment_ctime":1557197389,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1557197389","product_id":100024501,"comment_content":"上报卡顿信息的时候、如果这时候用户手动杀掉进程、还没来及上报的数据是不是就丢了呢？","like_count":0,"discussions":[{"author":{"id":1454319,"avatar":"","nickname":"我唔知点死啊","note":"","ucode":"032CCE72B8F848","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2257,"discussion_content":"先保存下来，在合适时机再上传，比如打开App的时候。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563416557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89700,"user_name":"啊波次的额佛哥～","can_delete":false,"product_type":"c1","uid":1201998,"ip_address":"","ucode":"6F31255207CB17","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/4e/302bfe22.jpg","comment_is_top":false,"comment_ctime":1556246376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556246376","product_id":100024501,"comment_content":"我怎么不卡，就你卡，哈哈哈","like_count":0},{"had_liked":false,"id":89388,"user_name":"xilie","can_delete":false,"product_type":"c1","uid":1013805,"ip_address":"","ucode":"AFCC4E157F7830","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVegfjqa0gM4hcRrBhZkIf7Uc5oeTMYsg6o5pd76IQlUoIIh2ic6P22xVEFtRnAzjyLtiaPVstkKug/132","comment_is_top":false,"comment_ctime":1556162509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556162509","product_id":100024501,"comment_content":"为什么是3秒，还是不太理解，好像1个0.5秒的卡顿，用户都能感知。而watch dog，比如启动20秒，我觉得那是容忍的极限，不应该按这个标准吧。我觉得应该设置为0.5秒比较好，我理解有错吗？","like_count":0},{"had_liked":false,"id":89387,"user_name":"二木又土","can_delete":false,"product_type":"c1","uid":1296963,"ip_address":"","ucode":"7D939045990B4D","user_header":"https://static001.geekbang.org/account/avatar/00/13/ca/43/63bdc516.jpg","comment_is_top":false,"comment_ctime":1556162160,"is_pvip":false,"replies":[{"id":"32665","content":"不用纠结，这种情况直接异步操作","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1556891331,"ip_address":"","comment_id":89387,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556162160","product_id":100024501,"comment_content":"刚IM项目中遇到一个实际卡顿的情景，程序启动后，需要从服务端获取3w条会话列表，web收到数据后，需要排序后显示，排序操作需要700ms，加上列表显示大概要2秒的时间，想过排序放子线程操作，又要处理多线程的问题，很纠结。<br>","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448112,"discussion_content":"不用纠结，这种情况直接异步操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556891331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89100,"user_name":"Xqqq0","can_delete":false,"product_type":"c1","uid":1335462,"ip_address":"","ucode":"38C05366ACB23B","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a6/3614094e.jpg","comment_is_top":false,"comment_ctime":1556076824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556076824","product_id":100024501,"comment_content":"老师您好，watchdog能否解释一下，或者提供一些相关文档，谢谢<br>","like_count":0},{"had_liked":false,"id":88800,"user_name":"Snow同學","can_delete":false,"product_type":"c1","uid":1390875,"ip_address":"","ucode":"231E98C721E4D2","user_header":"https://static001.geekbang.org/account/avatar/00/15/39/1b/bcabd223.jpg","comment_is_top":false,"comment_ctime":1556003086,"is_pvip":false,"replies":[{"id":"32671","content":"这种方法不适合做线上监控","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1556892061,"ip_address":"","comment_id":88800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556003086","product_id":100024501,"comment_content":"觉得使用：02 | App 启动速度怎么做优化与监控？  讲的内容，设置方法的执行最短时间，也是可以查找那些在主线程长时间执行的方法的","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447906,"discussion_content":"这种方法不适合做线上监控","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556892061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87358,"user_name":"三刀流剑客","can_delete":false,"product_type":"c1","uid":1453977,"ip_address":"","ucode":"B958771DE190BB","user_header":"https://static001.geekbang.org/account/avatar/00/16/2f/99/918e9b2a.jpg","comment_is_top":false,"comment_ctime":1555575661,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1555575661","product_id":100024501,"comment_content":"看了老师讲的 runloop 的原理 , runloop 有不同的mode,当需要切换mode 的时候,我不明白的是不同mode 的任务状态是如何记录呢?","like_count":1,"discussions":[{"author":{"id":1454319,"avatar":"","nickname":"我唔知点死啊","note":"","ucode":"032CCE72B8F848","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2259,"discussion_content":"如果要从mode1切换到mode2，必须先退出当前RunLoop，然后再以mode2进入RunLoop。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563416943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85097,"user_name":"子嘉","can_delete":false,"product_type":"c1","uid":1252422,"ip_address":"","ucode":"CF0DC72E2B6B9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/46/a141c7e6.jpg","comment_is_top":false,"comment_ctime":1554979506,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554979506","product_id":100024501,"comment_content":"系统事件是通过source1传递激活app的 然后通过source0分发吗 还是直接通过source0分发？ 比如点击屏幕 到响应  如果是第二个 那么应该激活不了啊..","like_count":0,"discussions":[{"author":{"id":1454319,"avatar":"","nickname":"我唔知点死啊","note":"","ucode":"032CCE72B8F848","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2260,"discussion_content":"不会经过source0，参考：https://blog.ibireme.com/2015/05/18/runloop/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563417081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85048,"user_name":"drunkenMouse","can_delete":false,"product_type":"c1","uid":1454037,"ip_address":"","ucode":"AA8CEA703ECBE8","user_header":"","comment_is_top":false,"comment_ctime":1554966958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554966958","product_id":100024501,"comment_content":"触发Source0回调，如果有Source1是ready状态的话，就会跳转到handle_msg去处理消息。为啥？？拿sources0当备胎？其实是为了消息分流，让sources1也跟着处理吗？<br><br>基于port的Source事件？这是什么事件与什么原因。。<br>","like_count":0},{"had_liked":false,"id":84987,"user_name":"kidzss","can_delete":false,"product_type":"c1","uid":1197423,"ip_address":"","ucode":"8CF7F7A678139A","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/6f/e3e180b7.jpg","comment_is_top":false,"comment_ctime":1554952125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554952125","product_id":100024501,"comment_content":"老师你好，我之前做了一个卡顿监控，也是使用了PL库，但是发现PL库有Crash的问题。<br>Out of memory。。。。。<br><br>GoodTransport +[PLCrashReportTextFormatter stringValueForCrashReport:withTextFormat:] (PLCrashReportTextFormatter.m:)","like_count":0},{"had_liked":false,"id":84234,"user_name":"Ant","can_delete":false,"product_type":"c1","uid":1079563,"ip_address":"","ucode":"07E6374F91F61E","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/0b/4346a253.jpg","comment_is_top":false,"comment_ctime":1554810848,"is_pvip":false,"replies":[{"id":"30727","content":"有啊，😁<br>我想请你回顾一下你都碰到过哪些卡顿问题，又是如何解决的呢？","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555144101,"ip_address":"","comment_id":84234,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554810848","product_id":100024501,"comment_content":"今天没作业真是爽歪歪","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446284,"discussion_content":"有啊，😁\n我想请你回顾一下你都碰到过哪些卡顿问题，又是如何解决的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555144101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83997,"user_name":"大官人","can_delete":false,"product_type":"c1","uid":1459215,"ip_address":"","ucode":"ED9C341D51C03F","user_header":"","comment_is_top":false,"comment_ctime":1554768110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554768110","product_id":100024501,"comment_content":"一直跟着听，受益匪浅，学到很多也了解很多，如果只听不做，感觉都会了，都知道，一动手，卡住了……，动手才会思考，","like_count":0},{"had_liked":false,"id":83986,"user_name":"Geek_cc73f2","can_delete":false,"product_type":"c1","uid":1426946,"ip_address":"","ucode":"364AD3A7AFFCF5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aiaSrhS44dUCfpycicJ6UWANe3aEkdibMFOOX2oXRo0amNwYxQM1dCKZpzfMdy3Z2ibwSSPu6ibFxnTvuDGzKiaLIClA/132","comment_is_top":false,"comment_ctime":1554766042,"is_pvip":false,"replies":[{"id":"30352","content":"文章最开头部分又说到容易造成卡顿的原因","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1554791455,"ip_address":"","comment_id":83986,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554766042","product_id":100024501,"comment_content":"老师你好，从文章真的受益匪浅，以前只会用第三方的，现在能从本质看出端倪，另外能不能从源头给一些建议呢，比如怎么避免卡顿，哪些操作容易卡顿，然后怎么处理呢，感谢","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446202,"discussion_content":"文章最开头部分又说到容易造成卡顿的原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554791455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83981,"user_name":"🏀Ceezy","can_delete":false,"product_type":"c1","uid":1454017,"ip_address":"","ucode":"BD57EF6DB13868","user_header":"https://static001.geekbang.org/account/avatar/00/16/2f/c1/ea40a9a9.jpg","comment_is_top":false,"comment_ctime":1554748559,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1554748559","product_id":100024501,"comment_content":"对于那个 GCD 的 dispatchPort，我看源码貌似是 GCD 提交给主线程的任务，这一事件源能称为 source1 吗？","like_count":0,"discussions":[{"author":{"id":1188627,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/13/6ba35b43.jpg","nickname":"leejunhui","note":"","ucode":"A957C0034B9F4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205426,"discussion_content":"我觉得不算，因为有单独的主队列回调函数，而 doSource1 中并没有去处理主队列任务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584300111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}