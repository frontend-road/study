{"id":220609,"title":"18 | 分布式存储：你知道对象存储是如何保存图片文件的吗？","content":"<p>你好，我是李玥。</p><p>我们都知道，保存像图片、音视频这类大文件，最佳的选择就是对象存储。对象存储不仅有很好的大文件读写性能，还可以通过水平扩展实现近乎无限的容量，并且可以兼顾服务高可用、数据高可靠这些特性。</p><p>对象存储之所以能做到这么“全能”，最主要的原因是，<strong>对象存储是原生的分布式存储系统</strong>。这里我们讲的“原生分布式存储系统”，是相对于MySQL、Redis这类单机存储系统来说的。虽然这些非原生的存储系统，也具备一定的集群能力，但你也能感受到，用它们构建大规模分布式集群的时候，其实是非常不容易的。</p><p>随着云计算的普及，很多新生代的存储系统，都是原生的分布式系统，它们一开始设计的目标之一就是分布式存储集群，比如说<a href=\"https://www.elastic.co/cn/\">Elasticsearch</a>、<a href=\"http://about:blank\">Ceph</a>和国内很多大厂推出的新一代数据库，大多都可以做到：</p><ul>\n<li>近乎无限的存储容量；</li>\n<li>超高的读写性能；</li>\n<li>数据高可靠：节点磁盘损毁不会丢数据；</li>\n<li>实现服务高可用：节点宕机不会影响集群对外提供服务。</li>\n</ul><p>那这些原生分布式存储是如何实现这些特性的呢？</p><p>实际上不用我说，你也能猜得到，这里面同样存在严重的“互相抄作业”的情况。这个也可以理解，除了存储的数据结构不一样，提供的查询服务不一样以外，这些分布式存储系统，它们面临的很多问题都是一样的，那实现方法差不多也是可以理解。</p><!-- [[[read_end]]] --><p>对象存储它的查询服务和数据结构都非常简单，是最简单的原生分布式存储系统。这节课，我们就来一起来研究一下对象存储这种最简单的原生分布式存储，通过对象存储来认识一下分布式存储系统的一些共性。掌握了这些共性之后，你再去认识和学习其他的分布式存储系统，也会感觉特别容易。</p><h2>对象存储数据是如何保存大文件的？</h2><p>对象存储对外提供的服务，其实就是一个近乎无限容量的大文件KV存储，所以对象存储和分布式文件系统之间，没有那么明确的界限。对象存储的内部，肯定有很多的存储节点，用于保存这些大文件，这个就是数据节点的集群。</p><p>另外，我们为了管理这些数据节点和节点中的文件，还需要一个存储系统保存集群的节点信息、文件信息和它们的映射关系。这些为了管理集群而存储的数据，叫做元数据(Metadata)。</p><p>元数据对于一个存储集群来说是非常重要的，所以保存元数据的存储系统必须也是一个集群。但是元数据集群存储的数据量比较少，数据的变动不是很频繁，加之客户端或者网关都会缓存一部分元数据，所以元数据集群对并发要求也不高。一般使用类似<a href=\"https://zookeeper.apache.org/\">ZooKeeper</a>或者<a href=\"https://github.com/etcd-io/etcd\">etcd</a>这类分布式存储就可以满足要求。</p><p>另外，存储集群为了对外提供访问服务，还需要一个网关集群，对外接收外部请求，对内访问元数据和数据节点。网关集群中的每个节点不需要保存任何数据，都是无状态的节点。有些对象存储没有网关，取而代之的是客户端，它们的功能和作用都是一样的。</p><p><img src=\"https://static001.geekbang.org/resource/image/92/0b/925a6309372b30f660c9b8bc198f860b.jpg?wh=805*614\" alt=\"\"></p><p>那么，对象存储是如何来处理对象读写请求的呢？这里面处理读和写请求的流程是一样的，我们一起来说。网关收到对象读写请求后，首先拿着请求中的Key，去元数据集群查找这个Key在哪个数据节点上，然后再去访问对应的数据节点读写数据，最后把结果返回给客户端。</p><p>以上是一个比较粗略的大致流程，实际上这里面包含很多的细节，我们暂时没有展开讲。目的是让你在整体上对对象存储，以至于分布式存储系统，有一个清晰的认知。</p><p>上面这张图，虽然我画的是对象存储集群的结构，但是把图上的名词改一改，完全可以套用到绝大多数分布式文件系统和数据库上去，比如说HDFS。</p><h2>对象是如何拆分和保存的？</h2><p>接下来我们说一下对象存储到底是如何来保存大文件对象的。一般来说，对象存储中保存的文件都是图片、视频这类大文件。在对象存储中，每一个大文件都会被拆成多个大小相等的<strong>块儿（Block）</strong>，拆分的方法很简单，就是把文件从头到尾按照固定的块儿大小，切成一块儿一块儿，最后一块儿长度有可能不足一个块儿的大小，也按一块儿来处理。块儿的大小一般配置为几十KB到几个MB左右。</p><p>把大对象文件拆分成块儿的目的有两个：</p><ol>\n<li>第一是为了提升读写性能，这些块儿可以分散到不同的数据节点上，这样就可以并行读写。</li>\n<li>第二是把文件分成大小相等块儿，便于维护管理。</li>\n</ol><p>对象被拆成块儿之后，还是太过于碎片化了，如果直接管理这些块儿，会导致元数据的数据量会非常大，也没必要管理到这么细的粒度。所以一般都会再把块儿聚合一下，放到块儿的容器里面。这里的“容器”就是存放一组块儿的逻辑单元。容器这个名词，没有统一的叫法，比如在<a href=\"https://ceph.io/\">ceph</a>中称为Data Placement，你理解这个含义就行。容器内的块儿数大多是固定的，所以容器的大小也是固定的。</p><p>到这里，这个容器的概念，就比较类似于我们之前讲MySQL和Redis时提到的“分片”的概念了，都是复制、迁移数据的基本单位。每个容器都会有N个副本，这些副本的数据都是一样的。其中有一个主副本，其他是从副本，主副本负责数据读写，从副本去到主副本上去复制数据，保证主从数据一致。</p><p>这里面有一点儿和我们之前讲的不一样的是，对象存储一般都不记录类似MySQL的Binlog这样的日志。主从复制的时候，复制的不是日志，而是整块儿的数据。这么做有两个原因：</p><ol>\n<li>第一个原因是基于性能的考虑。我们知道操作日志里面，实际上就包含着数据。在更新数据的时候，先记录操作日志，再更新存储引擎中的数据，相当于在磁盘上串行写了2次数据。对于像数据库这种，每次更新的数据都很少的存储系统，这个开销是可以接受的。但是对于对象存储来说，它每次写入的块儿很大，两次磁盘IO的开销就有些不太值得了。</li>\n<li>第二个原因是它的存储结构简单，即使没有日志，只要按照顺序，整块儿的复制数据，仍然可以保证主从副本的数据一致性。</li>\n</ol><p>以上我们说的对象（也就是文件）、块儿和容器，都是逻辑层面的概念，数据落实到副本上，这些副本就是真正物理存在了。这些副本再被分配到数据节点上保存起来。这里的数据节点就是运行在服务器上的服务进程，负责在本地磁盘上保存副本的数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/8d/0b/8d6616675ca90df023d1622aa1f2ef0b.jpg?wh=809*846\" alt=\"\"></p><p>了解了对象是如何被拆分并存储在数据节点上之后，我们再来回顾一下数据访问的流程。当我们请求一个Key的时候，网关首先去元数据中查找这个Key的元数据。然后根据元数据中记录的对象长度，计算出对象有多少块儿。接下来的过程就可以分块儿并行处理了。对于每个块儿，还需要再去元数据中，找到它被放在哪个容器中。</p><p>我刚刚讲过，容器就是分片，怎么把块儿映射到容器中，这个方法就是我们在《<a href=\"https://time.geekbang.org/column/article/217568\">15 | MySQL存储海量数据的最后一招：分库分表</a>》这节课中讲到的几种分片算法。不同的系统选择实现的方式也不一样，有用哈希分片的，也有用查表法把对应关系保存在元数据中的。找到容器之后，再去元数据中查找容器的N个副本都分布在哪些数据节点上。然后，网关直接访问对应的数据节点读写数据就可以了。</p><h2>小结</h2><p>对象存储是最简单的分布式存储系统，主要由数据节点集群、元数据集群和网关集群（或者客户端）三部分构成。数据节点集群负责保存对象数据，元数据集群负责保存集群的元数据，网关集群和客户端对外提供简单的访问API，对内访问元数据和数据节点读写数据。</p><p>为了便于维护和管理，大的对象被拆分为若干固定大小的块儿，块儿又被封装到容器（也就分片）中，每个容器有一主N从多个副本，这些副本再被分散到集群的数据节点上保存。</p><p>对象存储虽然简单，但是它具备一个分布式存储系统的全部特征。所有分布式存储系统共通的一些特性，对象存储也都具备，比如说数据如何分片，如何通过多副本保证数据可靠性，如何在多个副本间复制数据，确保数据一致性等等。</p><p>希望你通过这节课的学习，不仅是学会对象存储，还要对比分析一下，对象存储和其他分布式存储系统，比如MySQL集群、HDFS、Elasticsearch等等这些，它们之间有什么共同的地方，差异在哪儿。想通了这些问题，你对分布式存储系统的认知，绝对会上升到一个全新的高度。然后你再去看一些之前不了解的存储系统，就非常简单了。</p><h2>思考题</h2><p>我们刚刚说到过，对象存储并不是基于日志来进行主从复制的。假设我们的对象存储是一主二从三个副本，采用半同步方式复制数据，也就是主副本和任意一个从副本更新成功后，就给客户端返回成功响应。主副本所在节点宕机之后，这两个从副本中，至少有一个副本上的数据是和宕机的主副本上一样的，我们需要找到这个副本作为新的主副本，才能保证宕机不丢数据。</p><p>但是没有了日志，如果这两个从副本上的数据不一样，我们如何确定哪个上面的数据是和主副本一样新呢？欢迎你在留言区与我交流讨论。</p><p>感谢你的阅读，如果你觉得今天的内容对你有帮助，也欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"17 | 大厂都是怎么做MySQL to Redis同步的?","id":217593},"right":{"article_title":"19 | 跨系统实时同步数据，分布式事务是唯一的解决方案吗？","id":221567}},"comments":[{"had_liked":false,"id":203565,"user_name":"李玥","can_delete":false,"product_type":"c1","uid":1501046,"ip_address":"","ucode":"B19E91EE248591","user_header":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","comment_is_top":true,"comment_ctime":1586233809,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"9.2233721715849994e+18","product_id":100046801,"comment_content":"Hi，我是李玥。<br><br>这里回顾一下上节课的思考题：<br><br>如果出现缓存不同步的情况，在你负责的业务场景下，该如何降级或者补偿？<br><br>这个问题我看到留言区有一些同学给出了非常好的答案，比如说，设置一个合理的缓存过期时间，这样即使出现缓存不同步，等缓存过期后就会自动恢复。再比如，识别用户手动刷新操作，强制重新加载缓存数据（但要注意防止大量缓存穿透）。还可以在管理员的后台系统中，预留一个手动清除缓存的功能，必要的时候人工干预。","like_count":32,"discussions":[{"author":{"id":2040309,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epq2AfJ26y9tHb6z7kyRyF9MoBgAJf3ia6Fu8GMpZjNY8sfyaAiaYjZ1HxaibDw0ErUS8goFuOuuHTpw/132","nickname":"大灰羊君","note":"","ucode":"49C91668AFB2CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291287,"discussion_content":"对于强制刷新缓存的方法，如果是mysql到canal到redis链路发生了时延，导致了几个修改堆积，刷新缓存后刷新为最新，但是后来收到了堆积修改，又会把redis改回一段时间之前的状态。应该担心这种情况吗？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1594773344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1481979,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/fb/7fe6df5b.jpg","nickname":"陈卧虫","note":"","ucode":"44BB84712436AB","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":2040309,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epq2AfJ26y9tHb6z7kyRyF9MoBgAJf3ia6Fu8GMpZjNY8sfyaAiaYjZ1HxaibDw0ErUS8goFuOuuHTpw/132","nickname":"大灰羊君","note":"","ucode":"49C91668AFB2CA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590603,"discussion_content":"这个就是ABA问题，可以通过在数据中增加version字段，每次更新时判断version是否大于redis中数据的version","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665913901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291287,"ip_address":"浙江"},"score":590603,"extra":""}]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366476,"discussion_content":"全量缓存的情况下，缓存过期/手动清除缓存如何加载数据库的数据至缓存呢？\n设置一个定时任务嘛？该如何实现呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618069166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366480,"discussion_content":"这些解决方案感觉更偏向于Cache Aside策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618069227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1126938,"avatar":"https://static001.geekbang.org/account/avatar/00/11/32/1a/78fce652.jpg","nickname":"铁血骑士","note":"","ucode":"490EC62B9ADABF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294242,"discussion_content":"我觉得高并发下是有这种情况发生的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595837643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205040,"user_name":"L","can_delete":false,"product_type":"c1","uid":1310518,"ip_address":"","ucode":"C18B98D3DC3387","user_header":"https://static001.geekbang.org/account/avatar/00/13/ff/36/83281758.jpg","comment_is_top":false,"comment_ctime":1586513652,"is_pvip":false,"replies":[{"id":"77036","content":"建议你使用公有云的对象存储服务，小规模的公司自建对象存储维护成本太高，不是太划算。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1586833248,"ip_address":"","comment_id":205040,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74600957684","product_id":100046801,"comment_content":"老师，我问一个小问题。公司是做素材库的，现在自建对象服务器，对象服务器里面大多都是图片素材，场景是读多写少。选择Ceph可以用于生成环境吗？或者有没有更好的方案选择？谢谢老师","like_count":18,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491363,"discussion_content":"建议你使用公有云的对象存储服务，小规模的公司自建对象存储维护成本太高，不是太划算。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586833248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003205,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4e/c5/78626367.jpg","nickname":"型火🔥","note":"","ucode":"C2322918B31E60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378451,"discussion_content":"用开源fastDFS\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623227574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203496,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1586221804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70305698540","product_id":100046801,"comment_content":"如果是基于 Raft 协议的，会根据任期的编号大小决定谁是领导者","like_count":17},{"had_liked":false,"id":220922,"user_name":"喆里","can_delete":false,"product_type":"c1","uid":1125033,"ip_address":"","ucode":"0B4B38104645CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/a9/83684d4a.jpg","comment_is_top":false,"comment_ctime":1590337322,"is_pvip":true,"replies":[{"id":"81455","content":"一个容器就是一个分片，是数据复制的基本单位。也就是说，每个分片都有n个 副本。<br><br>分片不能做的太小的原因是，分片越小，意味着存储同样容量的数据，分片的数量越多。分片数量过多，查找分片时，需要查找的元数据就会太多，影响查找效率。<br><br>另外，对于数据复制，同样要有一定的开销，比如记录日志位置，维护数据一致性的开销。分片太小，相对的，这些开销就会比较大。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1590367924,"ip_address":"","comment_id":220922,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57424912170","product_id":100046801,"comment_content":"请教个问题，为什么分块后又聚合到容器中，直接一个容器一个块不行吗？这块设计思路没看明白<br>","like_count":14,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496266,"discussion_content":"一个容器就是一个分片，是数据复制的基本单位。也就是说，每个分片都有n个 副本。\n\n分片不能做的太小的原因是，分片越小，意味着存储同样容量的数据，分片的数量越多。分片数量过多，查找分片时，需要查找的元数据就会太多，影响查找效率。\n\n另外，对于数据复制，同样要有一定的开销，比如记录日志位置，维护数据一致性的开销。分片太小，相对的，这些开销就会比较大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590367924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217649,"user_name":"于海涛","can_delete":false,"product_type":"c1","uid":1986401,"ip_address":"","ucode":"5302F093E4648A","user_header":"","comment_is_top":false,"comment_ctime":1589556646,"is_pvip":false,"replies":[{"id":"80853","content":"CDN缓存的文件一般是保存在CDN节点的磁盘上，当然不排除某些CDN会用节点的内存缓存文件，加速访问。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1589869203,"ip_address":"","comment_id":217649,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31654327718","product_id":100046801,"comment_content":"老师，有一个问题想问您，对象存储的cdn缓存是怎么做的？是每次要访问这些元数据，还是直接把这些源数据所有都放在内存里？数据量这么大感觉不适合放内存里吧？感谢老师","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495205,"discussion_content":"CDN缓存的文件一般是保存在CDN节点的磁盘上，当然不排除某些CDN会用节点的内存缓存文件，加速访问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589869203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986401,"avatar":"","nickname":"于海涛","note":"","ucode":"5302F093E4648A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271249,"discussion_content":"理解了，感谢老师回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590109955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238592,"user_name":"Kevin Wang","can_delete":false,"product_type":"c1","uid":1042073,"ip_address":"","ucode":"D4BC9EFCB086EE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e6/99/276eaeaa.jpg","comment_is_top":false,"comment_ctime":1596208000,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"18776077184","product_id":100046801,"comment_content":"老师讲得很好，提一点建议。<br><br>数据冗余技术主要由两种：<br>1. 传统副本复制<br>2. 纠删码，基于纠删算法，时间换空间 （著名开源对象存储MinIO就是基于纠删码的）<br><br>建议文中也提一下第2种。<br>","like_count":5,"discussions":[{"author":{"id":1016596,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/14/bcc58354.jpg","nickname":"li3huo","note":"","ucode":"171363C3BE3E8E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576609,"discussion_content":"minio 是个维护代价更小的对象存储服务，新服务选型推荐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655701558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366497,"discussion_content":"但感觉第2种场景用的较少，而且会单点故障","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618071182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203523,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1586226902,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"18766096086","product_id":100046801,"comment_content":"对象存储 不是一般都有版本控制的吗 ？ 最新的版本就是最新的数据","like_count":5,"discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538912,"discussion_content":"对的 用选主协议选主版本号将其作为最新即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639555983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256704,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1082132,"ip_address":"","ucode":"483350A630625E","user_header":"https://static001.geekbang.org/account/avatar/00/10/83/14/099742ae.jpg","comment_is_top":false,"comment_ctime":1603711987,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10193646579","product_id":100046801,"comment_content":"请假下老师，对象存储和分布式文件系统的区别在哪？另外对象存储底层是否也是依赖的文件系统，谢谢","like_count":2,"discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366496,"discussion_content":"https://www.zhihu.com/question/21536660\n块存储的用户是可以读写块设备的软件系统，例如传统的文件系统、数据库；\n对象存储的用户则是其它计算机软件；\n文件存储的用户是自然人；\n底层都是块存储，做了一定程度的封装","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618070993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204176,"user_name":"世纪猛男","can_delete":false,"product_type":"c1","uid":1532566,"ip_address":"","ucode":"DEF34472DEB00B","user_header":"","comment_is_top":false,"comment_ctime":1586346783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176281375","product_id":100046801,"comment_content":"Zookeeper transaction id","like_count":3},{"had_liked":false,"id":203445,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1586191349,"is_pvip":false,"replies":[{"id":"76069","content":"那这个时间从哪儿来呢？如果都从本机的时钟获取，怎么保证集群中所有节点的时钟是一致的呢？","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1586224486,"ip_address":"","comment_id":203445,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10176125941","product_id":100046801,"comment_content":"每次操作都更新操作时间。谁的操作时间最新谁就是最接近主节点的副节点。","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490866,"discussion_content":"那这个时间从哪儿来呢？如果都从本机的时钟获取，怎么保证集群中所有节点的时钟是一致的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586224486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223452,"discussion_content":"额，考虑不周了。将时间用一个更新版本替换。版本的值为累加值。这样值最大的最靠近主节点。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586225055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326537,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1639555929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5934523225","product_id":100046801,"comment_content":"有些同学对于为什么不适用操作日志可能有疑惑 这里简单说一下：<br>1.文件系统为了保证一致性与原子性 需要使用journal（又被称为write ahead logging,即WAL）技术来实现。<br>写入时或者更新时 要先写index node日志 数据日志，而这些对于文件系统来说会有两个问题：<br>  a)通常文件系统保存的文件都很大 所以无论怎么分割块 index node 天生就多，这样journal日志写入反而是个负担<br>  b)分布式存储不像文件系统需要支持很多的搜索场景 所以内部存储不是用B树 而是KV ，故写入反而简单，如果同步失败也可以快速发现重做即可<br>2.binlog文件的增大 会导致每次写操作必须保证原子性 因为宿主机linux文件系统还是以一页 16KB来做一次原子写 ，这就会衍生出其他的问题。<br><br>最后回答下老师的问题<br>可以使用版本号来维护 将其作为epoch，在根据其大小用raft选主即可","like_count":2},{"had_liked":false,"id":207440,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1587086875,"is_pvip":false,"replies":[{"id":"77850","content":"容器内存放的就是实际的数据。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1587353070,"ip_address":"","comment_id":207440,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5882054171","product_id":100046801,"comment_content":"老师，有个地方不清楚，这里的每个容器一般只存储对象的一部分块，那么首先应该是从元数据集群中根据key找到这个对象对应的所有容器，第二步，因为多个容器中的块组成一个完整对象，而每个容器又被存到某个数据节点中了，所以此时应该再去元数据集群中找多个容器所对应的数据节点。总之，只要找到了容器的存储位置，容器内块就找到了。文章中提到的块的聚合指的是容器来聚合块吗？这样元数据集群就是管理容器了。容器内存的是块的索引还是实际数据呢？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492127,"discussion_content":"容器内存放的就是实际的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587353070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366498,"discussion_content":"容器应该存的是所有的块，因为对象存储系统以容器为复制和迁移数据的基本单位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618071268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203482,"user_name":"特种流氓","can_delete":false,"product_type":"c1","uid":1248825,"ip_address":"","ucode":"D9985CBA8B4AAD","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/39/174741d1.jpg","comment_is_top":false,"comment_ctime":1586219961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881187257","product_id":100046801,"comment_content":"容器里面的主副本信息存放在元数据集群还是数据管理集群<br>对于容器的概念还是有点模糊","like_count":1},{"had_liked":false,"id":203471,"user_name":"Mq","can_delete":false,"product_type":"c1","uid":1178359,"ip_address":"","ucode":"041F572AFAB275","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg","comment_is_top":false,"comment_ctime":1586218450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881185746","product_id":100046801,"comment_content":"可以设置2个从节点监听主节点的心跳时间不同，可以把跟主节点一致的设置的小些，当监控到主节点挂了后发起选举升级成主节点。","like_count":1},{"had_liked":false,"id":342555,"user_name":"Geek_dc693e","can_delete":false,"product_type":"c1","uid":2955163,"ip_address":"","ucode":"A81514CE758135","user_header":"","comment_is_top":false,"comment_ctime":1650340020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650340020","product_id":100046801,"comment_content":"没看懂呀，这个容器是一些块的集合？类似分片，就是说每个容器都有全量数据？那这个容器有和一个副本是啥区别","like_count":0},{"had_liked":false,"id":339941,"user_name":"Jay","can_delete":false,"product_type":"c1","uid":1592078,"ip_address":"","ucode":"42669FDE25765B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIM0sj0oP7bZwm2dWHq1n1XIsJLwGr122Qb1S2EytzAp62YZKJsiaNHTQayolevlBJGiaq7eBRHCGrg/132","comment_is_top":false,"comment_ctime":1648476728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648476728","product_id":100046801,"comment_content":"为何需要网关，这个能否解释一下","like_count":0},{"had_liked":false,"id":336734,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1646323020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646323020","product_id":100046801,"comment_content":"一个大文件会先拆分为多个大小相等的块，最后一块长度不足，也当做一个相同长度的块。<br><br>把这些文件块，按指定数量，放到若干个分片中。<br><br>每个分片为了高可用，都会有主副本，从副本，每个副本对应数据节点。<br><br>读取文件时，先用key找到所有的分片，然后通过分片找到分片副本，再通过分片副本找到对应的数据节点获取数据。最后把多个分片的数据整合，返回。","like_count":0},{"had_liked":false,"id":336393,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1646126637,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646126637","product_id":100046801,"comment_content":"通过一个地方记录：更新成功的是哪一个从机器。比如版本号","like_count":0},{"had_liked":false,"id":304662,"user_name":"林铭铭","can_delete":false,"product_type":"c1","uid":1068499,"ip_address":"","ucode":"AB392BEE7CD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/d3/67bdcca9.jpg","comment_is_top":false,"comment_ctime":1627543321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627543321","product_id":100046801,"comment_content":"通俗易懂","like_count":1},{"had_liked":false,"id":267320,"user_name":"于途","can_delete":false,"product_type":"c1","uid":1669343,"ip_address":"","ucode":"70300C6CCCEAF1","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/df/424bdc4a.jpg","comment_is_top":false,"comment_ctime":1607679465,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607679465","product_id":100046801,"comment_content":"网关集群中的每个节点不需要保存任何数据，都是无状态的节点。<br><br>老师，请问这里的“无状态”应该怎么理解？","like_count":0},{"had_liked":false,"id":249187,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1600496292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600496292","product_id":100046801,"comment_content":"更新容器里块的时候记录版本号，版本号是递增的，这样版本号最大的那个副本肯定是最新的。","like_count":0},{"had_liked":false,"id":203790,"user_name":"陶金","can_delete":false,"product_type":"c1","uid":1647666,"ip_address":"","ucode":"14ECFE57ABC162","user_header":"https://static001.geekbang.org/account/avatar/00/19/24/32/c712d415.jpg","comment_is_top":false,"comment_ctime":1586266992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586266992","product_id":100046801,"comment_content":"通过序列号来确定谁新谁旧？","like_count":0},{"had_liked":false,"id":203589,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1586237796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586237796","product_id":100046801,"comment_content":"应该有类似kafka isr的机制，每个分片都会有一个序号，通过序号大小来分辨吧","like_count":0},{"had_liked":false,"id":203497,"user_name":"小祺","can_delete":false,"product_type":"c1","uid":1193548,"ip_address":"","ucode":"2819BCA9E71C9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/4c/46c43cce.jpg","comment_is_top":false,"comment_ctime":1586221847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586221847","product_id":100046801,"comment_content":"元数据里存一下校验码？","like_count":0},{"had_liked":false,"id":203465,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1586216324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586216324","product_id":100046801,"comment_content":"比较同步时间？","like_count":0}]}