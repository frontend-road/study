{"id":619503,"title":"36｜测试的艺术：依赖注入、表格测试与压力测试","content":"<p>你好，我是郑建勋。</p><p>对代码的功能与逻辑进行测试是项目开发中非常重要的一部分。这节课，我们一起来看几个在Go中进行代码测试的核心技术：单元测试、压力测试与基准测试。它们共同保证了代码的准确性、可靠性与高效性。</p><h2>单元测试</h2><p>单元测试又叫做模块测试，它会对程序模块（软件设计的最小单位）进行正确性检验，通常，单元测试是对一个函数封装起来的最小功能进行测试。</p><p>在Go中，testing包为我们提供了测试的支持。进行代码测试需要将测试函数放置到xxx_test.go文件中，测试函数以TestXxx开头，其中Xxx是测试函数的名称，以大写字母开头。测试函数以 testing.T 类型的指针作为参数，你可以使用这一参数在测试中打印日志、报告测试结果，或者跳过指定测试。</p><pre><code class=\"language-plain\">func TestXxx(t *testing.T)\n</code></pre><p>我们用下面这个简单的加法例子来说明一下。首先，在add.go文件中，写入一个Add函数实现简单的加法功能。</p><pre><code class=\"language-plain\">// add.go\npackage add\n\nfunc Add(a,b int) int{\n\treturn a+b\n}\n</code></pre><p>接下来在add_test.go文件中，书写TestAdd测试函数，并将执行结果与预期进行对比。如果执行结果与预期相符，t.Log打印日志。默认情况下测试是没问题的。但是如果执行结果与预期不符，t.Fatal会报告测试失败。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">// add_test.go\npackage add\n\nimport (\n\t\"testing\"\n)\nfunc TestAdd(t *testing.T) {\n\tsum := Add(1, 2)\n\tif sum == 3 {\n\t\tt.Log(\"the result is ok\")\n\t} else {\n\t\tt.Fatal(\"the result is wrong\")\n\t}\n}\n</code></pre><p>要执行测试文件，可以执行go test，如果测试成功，测试结果如下。</p><pre><code class=\"language-plain\">» go test                                                                                                      jackson@bogon\nPASS\nok      github.com/dreamerjackson/xxx/add    0.013s\n</code></pre><p>如果测试结果不符合预期，输出如下。</p><pre><code class=\"language-plain\">=== RUN   TestAdd\n    add_test.go:13: the result is wrong\n--- FAIL: TestAdd (0.00s)\n\nFAIL\n</code></pre><p>根据上面的Add函数，我们再回顾一下测试需要遵守的规范。</p><ol>\n<li>含有单元测试代码的Go文件必须以_test.go结尾，Go语言的测试工具只认符合这个规则的文件。</li>\n<li>单元测试文件名_test.go前面的部分，最好是被测试的方法所在Go文件的文件名。我们这个例子中，单元测试文件名是add_test.go，这是因为测试的Add函数在add.go文件里。</li>\n<li>单元测试的函数名必须以Test开头，是可导出公开的函数。</li>\n<li>测试函数的签名必须接收一个指向testing.T类型的指针，并且不能返回任何值。</li>\n<li>函数名最好是Test + 要测试的方法函数名，在我们这个例子中，函数名是TestAdd，表示测试的是Add这个函数。</li>\n</ol><p>下面让我们在项目中对数据库操作的 <code>sqldb</code> 做单元测试，测试一下创建表的功能是否正常。</p><pre><code class=\"language-plain\">func TestSqldb_CreateTable(t *testing.T) {\n\tsqldb, err := New(\n\t\tWithConnURL(\"root:123456@tcp(127.0.0.1:3326)/crawler?charset=utf8\"),\n\t)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, sqldb)\n\t// 测试对于无效的配置返回错误\n\tname := \"test_create_table\"\n\tvar notValidTable = TableData{\n\t\tTableName: name,\n\t\tColumnNames: []Field{\n\t\t\t{Title: \"书名\", Type: \"notValid\"},\n\t\t\t{Title: \"URL\", Type: \"VARCHAR(255)\"},\n\t\t},\n\t\tAutoKey: true,\n\t}\n // 延迟删除表\n\tdefer func() {\n\t\terr := sqldb.DropTable(notValidTable)\n\t\tassert.Nil(t, err)\n\t}()\n  // 测试对于有效的配置返回错误\n\terr = sqldb.CreateTable(notValidTable)\n\tassert.NotNil(t, err)\n\t// 测试对于无效的配置返回错误\n\tvar validTable = TableData{\n\t\tTableName: name,\n\t\tColumnNames: []Field{\n\t\t\t{Title: \"书名\", Type: \"MEDIUMTEXT\"},\n\t\t\t{Title: \"URL\", Type: \"VARCHAR(255)\"},\n\t\t},\n\t\tAutoKey: true,\n\t}\n\terr = sqldb.CreateTable(validTable)\n\tassert.Nil(t, err)\n}\n</code></pre><p>在这个单元测试中，我们主要测试了创建表的 CreateTable 函数的两个功能，包括“在正常情况下能够创建表”和“在异常情况下不能够创建表”。在这里我们没有直接使用t.Fatal来报告测试失败，而是借助第三方包github.com/stretchr/testify/assert来完成测试。</p><p><code>assert</code>库对testing.T进行了封装，例如函数assert.Nil 预期传入的参数为nil，而函数assert.NotNil 预期传入的参数不为nil。如果结果不符合预期，则立即报告测试失败。</p><p>不过，这样的单元测试其实并不够清晰，特别是当测试的功能逐渐变多的时候，代码还会变得冗余。那么有没有一种测试方法可以优雅地测试多种功能呢？这就不得不提到表格驱动测试了。</p><h3>表格驱动测试</h3><p>表格驱动测试也是单元测试的一种，我们直接用一个例子来说明它。下面是我们写的一个字符串分割函数，它的功能类似于strings.Split函数。</p><pre><code class=\"language-plain\">// split.go\npackage split\n\nimport \"strings\"\nfunc Split(s, sep string) []string {\n\tvar result []string\n\ti := strings.Index(s, sep)\n\tfor i &gt; -1 {\n\t\tresult = append(result, s[:i])\n\t\ts = s[i+len(sep):]\n\t\ti = strings.Index(s, sep)\n\t}\n\treturn append(result, s)\n}\n</code></pre><p>我们如果要对这个函数进行上述所讲的这种单元测试，测试代码是下面的样子。<br>\nreflect.DeepEqual是Go标准库提供的深度对比函数，它可以对比两个结构是否一致。而如果有多个要测试的用例，reflect.DeepEqual这段对比函数就会重复多次。</p><pre><code class=\"language-plain\">package split\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\n//单元测试\nfunc TestSplit(t *testing.T) {\n\tgot := Split(\"a/b/c\", \"/\")\n\twant := []string{\"a\", \"b\", \"c\"}\n\tif !reflect.DeepEqual(want, got) {\n\t\tt.Fatalf(\"expected: %v, got: %v\", want, got)\n\t}\n}\n</code></pre><p>为了解决这个问题，我们来看看表格驱动测试的做法。在表格驱动中，我们使用Map或者数组来组织用例，我们只需要输入值和期望值，在下面的for循环中就能够复用对比的函数，这就让表格驱动测试在实践中非常受欢迎了。</p><pre><code class=\"language-plain\">// split_test.go\npackage split\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSplit(t *testing.T) {\n\ttests := map[string]struct {\n\t\tinput string\n\t\tsep   string\n\t\twant  []string\n\t}{\n\t\t\"simple\":       {input: \"a/b/c\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n\t\t\"wrong sep\":    {input: \"a/b/c\", sep: \",\", want: []string{\"a/b/c\"}},\n\t\t\"no sep\":       {input: \"abc\", sep: \"/\",   want: []string{\"abc\"}},\n\t\t\"trailing sep\": {input: \"a/b/c/\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n\t}\n\n\tfor name, tc := range tests {\n\t\tgot := Split(tc.input, tc.sep)\n\t\tif !reflect.DeepEqual(tc.want, got) {\n\t\t\tt.Fatalf(\"%s: expected: %v, got: %v\", name, tc.want, got)\n\t\t}\n\t}\n}\n</code></pre><p>我们也可以把之前测试CreateTable的函数修改为表格驱动测试。</p><pre><code class=\"language-plain\">func TestSqldb_CreateTableDriver(t *testing.T) {\n\ttype args struct {\n\t\tt TableData\n\t}\n\tname := \"test_create_table\"\n\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"create_not_valid_table\",\n\t\t\targs: args{TableData{\n\t\t\t\tTableName: name,\n\t\t\t\tColumnNames: []Field{\n\t\t\t\t\t{Title: \"书名\", Type: \"not_valid\"},\n\t\t\t\t\t{Title: \"URL\", Type: \"VARCHAR(255)\"},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"create_valid_table\",\n\t\t\targs: args{TableData{\n\t\t\t\tTableName: name,\n\t\t\t\tColumnNames: []Field{\n\t\t\t\t\t{Title: \"书名\", Type: \"MEDIUMTEXT\"},\n\t\t\t\t\t{Title: \"URL\", Type: \"VARCHAR(255)\"},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"create_valid_table_with_primary_key\",\n\t\t\targs: args{TableData{\n\t\t\t\tTableName: name,\n\t\t\t\tColumnNames: []Field{\n\t\t\t\t\t{Title: \"书名\", Type: \"MEDIUMTEXT\"},\n\t\t\t\t\t{Title: \"URL\", Type: \"VARCHAR(255)\"},\n\t\t\t\t},\n\t\t\t\tAutoKey: true,\n\t\t\t}},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tsqldb, err := New(\n\t\tWithConnURL(\"root:123456@tcp(127.0.0.1:3326)/crawler?charset=utf8\"),\n\t)\n\n\tfor _, tt := range tests {\n\t\terr = sqldb.CreateTable(tt.args.t)\n\t\tif tt.wantErr {\n\t\t\tassert.NotNil(t, err, tt.name)\n\t\t} else {\n\t\t\tassert.Nil(t, err, tt.name)\n\t\t}\n\t\tsqldb.DropTable(tt.args.t)\n\t}\n}\n</code></pre><p>一般来说，我们会给每一个测试加上名字，方便我们在测试出错时打印出具体的用例。在上例中，我们在assert.NotNil的第三个参数中加上了测试的名字，假如测试出错，打印的结果如下所示。</p><pre><code class=\"language-plain\">=== RUN   TestSqldb_CreateTableDriver\n    sqldb_test.go:98: \n        \tError Trace:\t/Users/jackson/career/crawler/sqldb/sqldb_test.go:98\n        \tError:      \tExpected nil, but got: &amp;mysql.MySQLError{Number:0x428, Message:\"You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'not_valid,URL VARCHAR(255)) ENGINE=MyISAM DEFAULT CHARSET=utf8' at line 1\"}\n        \tTest:       \tTestSqldb_CreateTableDriver\n        \tMessages:   \tcreate_not_valid_table\n--- FAIL: TestSqldb_CreateTableDriver (0.06s)\n\nFAIL\n</code></pre><p>错误信息清晰可见，其中的Messages就是相关测试用例的名字。</p><h3><strong>子测试</strong></h3><p>前面我们看到的例子都是串行调用的，CreateTable的例子也确实不太适合使用并发调用。但是在一些场景下，我们需要通过并发调用来加速测试，这就是子测试为我们做的事情。</p><p>使用子测试可以调用testing.T 的Run函数，子测试会新开一个协程，实现并行。除此之外，子测试还有一个特点，就是会运行所有的测试用例（即使某一个测试用例失败了）。这样在出错时，就可以将多个错误都打印出来。</p><p>如下所示，我们用 t.Run 子测试来测试之前的Split函数，并发测试所有用例。</p><pre><code class=\"language-plain\">func TestSplit(t *testing.T) {\n\ttests := map[string]struct {\n\t\tinput string\n\t\tsep   string\n\t\twant  []string\n\t}{\n\t\t\"simple\":       {input: \"a/b/c\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n\t\t\"wrong sep\":    {input: \"a/b/c\", sep: \",\", want: []string{\"a/b/c\"}},\n\t\t\"no sep\":       {input: \"abc\", sep: \"/\", want: []string{\"abc\"}},\n\t\t\"trailing sep\": {input: \"a/b/c/\", sep: \"/\", want: []string{\"a\", \"b\", \"c\"}},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := Split(tc.input, tc.sep)\n\t\t\tif !reflect.DeepEqual(tc.want, got) {\n\t\t\t\tt.Fatalf(\"expected: %#v, got: %#v\", tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n</code></pre><p>下面让我们用子测试来测试我们MySQL库的插入功能。这里我并发测试了四个测试用例，t.run的第一个参数为测试用例的名字。</p><pre><code class=\"language-plain\">func TestSqldb_InsertTable(t *testing.T) {\n\ttype args struct {\n\t\tt TableData\n\t}\n\ttableName := \"test_create_table\"\n\tcolumnNames := []Field{{Title: \"书名\", Type: \"MEDIUMTEXT\"}, {Title: \"price\", Type: \"TINYINT\"}}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"insert_data\",\n\t\t\targs: args{TableData{\n\t\t\t\tTableName:   tableName,\n\t\t\t\tColumnNames: columnNames,\n\t\t\t\tArgs:        []interface{}{\"book1\", 2},\n\t\t\t\tDataCount:   1,\n\t\t\t}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"insert_multi_data\",\n\t\t\targs: args{TableData{\n\t\t\t\tTableName:   tableName,\n\t\t\t\tColumnNames: columnNames,\n\t\t\t\tArgs:        []interface{}{\"book3\", 88.88, \"book4\", 99.99},\n\t\t\t\tDataCount:   2,\n\t\t\t}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"insert_multi_data_wrong_count\",\n\t\t\targs: args{TableData{\n\t\t\t\tTableName:   tableName,\n\t\t\t\tColumnNames: columnNames,\n\t\t\t\tArgs:        []interface{}{\"book3\", 88.88, \"book4\", 99.99},\n\t\t\t\tDataCount:   1,\n\t\t\t}},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"insert_wrong_data_type\",\n\t\t\targs: args{TableData{\n\t\t\t\tTableName:   tableName,\n\t\t\t\tColumnNames: columnNames,\n\t\t\t\tArgs:        []interface{}{\"book2\", \"rrr\"},\n\t\t\t\tDataCount:   1,\n\t\t\t}},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tsqldb, err := New(\n\t\tWithConnURL(\"root:123456@tcp(127.0.0.1:3326)/crawler?charset=utf8\"),\n\t)\n\terr = sqldb.CreateTable(tests[0].args.t)\n\tdefer sqldb.DropTable(tests[0].args.t)\n\tassert.Nil(t, err)\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr = sqldb.Insert(tt.args.t)\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.NotNil(t, err, tt.name)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, tt.name)\n\t\t\t}\n\t\t})\n\t}\n}\n</code></pre><p>测试结果如下所示。</p><pre><code class=\"language-plain\">» go test -run=TestSqldb_InsertTable                                                                                    jackson@bogon\n--- FAIL: TestSqldb_InsertTable (0.07s)\n    --- FAIL: TestSqldb_InsertTable/insert_wrong_data_type (0.01s)\n        sqldb_test.go:171: \n                Error Trace:    /Users/jackson/career/crawler/sqldb/sqldb_test.go:171\n                Error:          Expected nil, but got: &amp;mysql.MySQLError{Number:0x556, Message:\"Incorrect integer value: 'rrr' for column 'price' at row 1\"}\n                Test:           TestSqldb_InsertTable/insert_wrong_data_type\n                Messages:       insert_wrong_data_type\nFAIL\nexit status 1\nFAIL    github.com/dreamerjackson/crawler/sqldb 0.085s\n</code></pre><p>可以看到，当检测到错误时，能够清晰展示出错误用例的信息。</p><p>在这里，我们使用了go test -run xxx参数来指定我们要运行的程序。-run后面跟的是要测试的函数名，测试时会模糊匹配该函数名，符合条件的函数都将被测试。所以在这个例子中，go test -run=TestSqldb_InsertTable 与go test -run=InsertTable的执行效果是一致的。</p><p>当然，我们还可以加入-v参数打印出详细的信息。</p><pre><code class=\"language-plain\">» go test -run=InsertTable -v                                                                                           jackson@bogon\n=== RUN   TestSqldb_InsertTable\n=== RUN   TestSqldb_InsertTable/insert_data\n=== RUN   TestSqldb_InsertTable/insert_multi_data\n=== RUN   TestSqldb_InsertTable/insert_multi_data_wrong_count\n=== RUN   TestSqldb_InsertTable/insert_wrong_data_type\n    sqldb_test.go:171: \n                Error Trace:    /Users/jackson/career/crawler/sqldb/sqldb_test.go:171\n                Error:          Expected nil, but got: &amp;mysql.MySQLError{Number:0x556, Message:\"Incorrect integer value: 'rrr' for column 'price' at row 1\"}\n                Test:           TestSqldb_InsertTable/insert_wrong_data_type\n                Messages:       insert_wrong_data_type\n--- FAIL: TestSqldb_InsertTable (0.07s)\n    --- PASS: TestSqldb_InsertTable/insert_data (0.01s)\n    --- PASS: TestSqldb_InsertTable/insert_multi_data (0.01s)\n    --- PASS: TestSqldb_InsertTable/insert_multi_data_wrong_count (0.00s)\n    --- FAIL: TestSqldb_InsertTable/insert_wrong_data_type (0.01s)\nFAIL\nexit status 1\nFAIL    github.com/dreamerjackson/crawler/sqldb 0.084s\n</code></pre><p>-run后还可以只指定运行某一个特定的子测试。例如，我们可以只运行TestSqldb_InsertTable测试函数下的insert_multi_data_wrong_count子测试。</p><pre><code class=\"language-plain\">» go test -run=TestSqldb_InsertTable/insert_multi_data_wrong_count  -v                                                  jackson@bogon\n=== RUN   TestSqldb_InsertTable\n=== RUN   TestSqldb_InsertTable/insert_multi_data_wrong_count\n--- PASS: TestSqldb_InsertTable (0.04s)\n    --- PASS: TestSqldb_InsertTable/insert_multi_data_wrong_count (0.00s)\nPASS\nok      github.com/dreamerjackson/crawler/sqldb 0.055s\n</code></pre><h3>依赖注入</h3><p>前面我们介绍了单元测试的几种技术。当我们进行单元测试的时候，可能还会遇到一些棘手的依赖问题。例如一个函数需要从下游的多个服务中获取信息并完成后续的操作。在测试时，如果我们需要启动这些依赖，步骤会非常繁琐，有时候甚至无法在本地实现。因此，我们可以使用依赖注入的方式对这些依赖进行Mock，这种方式也能够让我们灵活地控制下游返回的数据。</p><p>我们以项目中的Flush()为例，在这个例子中，最后的 s.db.Insert 需要我们把数据插入数据库。</p><pre><code class=\"language-plain\">func (s *SQLStorage) Flush() error {\n\tif len(s.dataDocker) == 0 {\n\t\treturn nil\n\t}\n\n\tdefer func() {\n\t\ts.dataDocker = nil\n\t}()\n\t...\n\treturn s.db.Insert(sqldb.TableData{\n\t\tTableName:   s.dataDocker[0].GetTableName(),\n\t\tColumnNames: getFields(s.dataDocker[0]),\n\t\tArgs:        args,\n\t\tDataCount:   len(s.dataDocker),\n\t})\n}\n</code></pre><p>但我们其实并不是真的需要一个数据库。让我们新建一个测试文件sqlstorage_test.go，然后实现数据库DBer接口。</p><pre><code class=\"language-plain\">// sqlstorage_test.go\ntype mysqldb struct {\n}\n\nfunc (m mysqldb) CreateTable(t sqldb.TableData) error {\n\treturn nil\n}\n\nfunc (m mysqldb) Insert(t sqldb.TableData) error {\n\treturn nil\n}\n</code></pre><p>接着，我们就可以将mysqldb注入到SQLStorage结构中，单元测试如下所示。</p><pre><code class=\"language-plain\">func TestSQLStorage_Flush(t *testing.T) {\n\ttype fields struct {\n\t\tdataDocker []*spider.DataCell\n\t\toptions    options\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\tfields  fields\n\t\twantErr bool\n\t}{\n\t\t{name: \"empty\", wantErr: false},\n\t\t{name: \"no Rule filed\", fields: fields{dataDocker: []*spider.DataCell{\n\t\t\t{Data: map[string]interface{}{\"url\": \"&lt;http://xxx.com&gt;\"}},\n\t\t}}, wantErr: true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ts := &amp;SQLStorage{\n\t\t\t\tdataDocker: tt.fields.dataDocker,\n\t\t\t\tdb:         mysqldb{},\n\t\t\t\toptions:    tt.fields.options,\n\t\t\t}\n\t\t\tif err := s.Flush(); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Flush() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t\tassert.Nil(t, s.dataDocker)\n\t\t})\n\t}\n}\n</code></pre><p>测试用例中测试了没有Rule字段时的情形，但是程序却直接panic了。这就是单元测试的意义所在，它可以为我们找到一些特殊的输入，确认它们是否仍然符合预期。</p><p>经过测试我们发现，由于我们将接口强制转换为了string，当接口类型不匹配时就会直接panic。</p><pre><code class=\"language-plain\">ruleName := datacell.Data[\"Rule\"].(string)\ntaskName := datacell.Data[\"Task\"].(string)\n</code></pre><p>要避免这种情况，我们可以对异常情况进行判断，完整的测试你可以查看<a href=\"https://github.com/dreamerjackson/crawler\">最新的项目代码</a>。</p><pre><code class=\"language-plain\">if ruleName, ok = datacell.Data[\"Rule\"].(string); !ok {\n\t\t\treturn errors.New(\"no rule field\")\n\t\t}\n\n\tif taskName, ok = datacell.Data[\"Task\"].(string); !ok {\n\t\treturn errors.New(\"no task field\")\n\t}\n</code></pre><h2>压力测试</h2><p>有时候，我们还希望对程序进行压力测试，它可以测试随机场景、排除偶然因素、测试函数稳定性等等。</p><p>实现压力测试的方法和工具有很多，例如ab、wrk。合理的压力测试通常需要结合实际项目来设计。我们也可以通过书写Shell脚本来进行压力测试，如下脚本中， 我们可以用go test -c 为测试函数生成二进制文件，并循环调用测试函数。</p><pre><code class=\"language-plain\"># pressure.sh\ngo test -c # -c会生成可执行文件\n\nPKG=$(basename $(pwd))  # 获取当前路径的最后一个名字，即为文件夹的名字\necho $PKG\nwhile true ; do\n        export GOMAXPROCS=$[ 1 + $[ RANDOM % 128 ]] # 随机的GOMAXPROCS\n        ./$PKG.test $@ 2&gt;&amp;1   # $@代表可以加入参数   2&gt;&amp;1代表错误输出到控制台\ndone\n</code></pre><p>以之前的加法函数为例，执行下面的命令即可对测试函数进行压力测试。其中，-test.v 为运行参数，用于输出详细信息。</p><pre><code class=\"language-plain\">&gt; /pressure.sh -test.v\n\nPASS\n=== RUN   TestAdd\n--- PASS: TestAdd (0.00s)\n    add_test.go:17: the result is ok\nPASS\n=== RUN   TestAdd\n--- PASS: TestAdd (0.00s)\n    add_test.go:17: the result is ok\n</code></pre><h2>基准测试</h2><p>Go测试包中内置了Benchmarks基准测试，它可以对比改进后和改进前的函数，查看性能提升效果，也可以供我们探索一些Go的特性。</p><p>我们可以用基准测试来对比之前的接口调用与直接函数调用。</p><pre><code class=\"language-plain\">package escape\n\nimport \"testing\"\n\ntype Sumifier interface{ Add(a, b int32) int32 }\n\ntype Sumer struct{ id int32 }\n\nfunc (math Sumer) Add(a, b int32) int32 { return a + b }\n\ntype SumerPointer struct{ id int32 }\n\nfunc (math *SumerPointer) Add(a, b int32) int32 { return a + b }\n\nfunc BenchmarkDirect(b *testing.B) {\n\tadder := Sumer{id: 6754}\n\tb.ResetTimer()\n\tfor i := 0; i &lt; b.N; i++ {\n\t\tadder.Add(10, 12)\n\t}\n}\n\nfunc BenchmarkInterface(b *testing.B) {\n\tadder := Sumer{id: 6754}\n\tb.ResetTimer()\n\tfor i := 0; i &lt; b.N; i++ {\n\t\tSumifier(adder).Add(10, 12)\n\t}\n}\n\nfunc BenchmarkInterfacePointer(b *testing.B) {\n\tadder := &amp;SumerPointer{id: 6754}\n\tb.ResetTimer()\n\tfor i := 0; i &lt; b.N; i++ {\n\t\tSumifier(adder).Add(10, 12)\n\t}\n}\n</code></pre><p>go test 可以加入-gcflags 指定编译器的行为。例如这里的-gcflags “-N -l” 表示禁止编译器的优化与内联，-bench=. 表示执行基准测试，这样我们就可以对比前后几个函数的性能差异了。</p><pre><code class=\"language-plain\">» go test -gcflags \"-N -l\"   -bench=.\nBenchmarkDirect-12                      535487740                1.95 ns/op\nBenchmarkInterface-12                   76026812                 14.6 ns/op\nBenchmarkInterfacePointer-12            517756519                2.37 ns/op\n</code></pre><p>BenchMark测试时还可以指定一些其他运行参数，例如-benchmem可以打印每次函数的内存分配情况，-cpuprofile、-memprofile还能收集程序的 CPU 和内存的 profile 文件。</p><pre><code class=\"language-plain\">go test ./fibonacci \\\\\n  -bench BenchmarkSuite \\\\\n  -benchmem \\\\\n  -cpuprofile=cpu.out \\\\\n  -memprofile=mem.out\n</code></pre><p>这些生成的样本文件我们可以使用pprof工具进行可视化分析。关于pprof工具，我们在之后还会做详细介绍。</p><h2>总结</h2><p>这节课，我们介绍了Go中的多种测试技术，包括单元测试、表格驱动测试、子测试、基准测试、压力测试、依赖注入等。灵活地使用这些测试技术可以提前发现系统存在的性能问题，在后面的课程中，我们还会介绍代码覆盖率和模糊测试等新的测试技术。</p><h2>课后题</h2><p>你觉得reflect.DeepEqual的缺点是什么，有其他的替代方案吗？对于一个复杂的结构，如果reflect.DeepEqual返回了fasle，怎么知道是哪一个字段不一致呢？</p><p>欢迎你在留言区与我交流讨论，我们下节课见！</p>","comments":[{"had_liked":false,"id":365961,"user_name":"拾掇拾掇","can_delete":false,"product_type":"c1","uid":1051873,"ip_address":"浙江","ucode":"D775F374C2A1D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","comment_is_top":false,"comment_ctime":1673270461,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":2,"product_id":100124001,"comment_content":"goland 会自动帮你建好表格测试","like_count":1},{"had_liked":false,"id":370142,"user_name":"Yaney","can_delete":false,"product_type":"c1","uid":2988784,"ip_address":"浙江","ucode":"A25377A77DA01D","user_header":"","comment_is_top":false,"comment_ctime":1678426510,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"有没有推荐的代码自动生成工具呀，比如mockery","like_count":0},{"had_liked":false,"id":368709,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"北京","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1676606004,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"我了解的 reflect.DeepEqual 的缺点是不能比较不导出的key（小写key）。可以使用 `github.com&#47;google&#47;go-cmp`代替，这个库可以输出不一样的字段值，缺点是不能用于production，可以用于测试环境。","like_count":0}]}