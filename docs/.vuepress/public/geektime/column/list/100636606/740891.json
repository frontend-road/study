{"id":740891,"title":"第 15 章 服务容错保护(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>几种常见的服务容错模式</li>\n<li>Resilience4j 的基本用法</li>\n<li>Spring Cloud CircuitBreaker 的抽象与应用</li>\n</ul>\n</blockquote>\n<p>在微服务系统中，业务操作由多个服务协作完成，在这个过程中涉及的服务多了，出问题的概率自然也就变高了。如果下游服务出问题了，上游又不设防，就会被拖累；如果请求量陡增，超过服务的承受能力，也会引发问题……当我们遇到的问题多了，自然就会沉淀出不少经验，本章就让我们来看看如何基于常见的容错模式，使用一些框架来保护我们的系统。</p>\n<h2 id=\"nav_point_229\">15.1　常见的服务容错模式</h2>\n<p>一开始，我们不急于去介绍和使用那些帮助处理故障的工具，在知道如何借助外部力量之前，先来了解一下：为什么要实现服务容错，别人都是怎么做的，没有工具时我们又能怎么办。</p>\n<blockquote>\n<p><strong>请注意</strong>　本章所涉及的故障都是微服务链路中依赖的上下游之间发生的故障，系统本身内部的代码问题不在我们讨论的范畴内。</p>\n</blockquote>\n<h3 id=\"nav_point_230\">15.1.1　几种常见的容错模式</h3>\n<p>在编写代码时，我们会用设计模式，最知名的就是 GoF 23。在故障处理方面其实也有模式可以遵循（或者通俗一点说，也有自己的“套路”），我们把这些模式搬出来就能应付不少问题了。</p>\n<ol>\n<li><p><strong>重试模式</strong></p>\n<p>最简单粗暴的容错模式，可能就是重试（Retry）了。重试，简单而言就是出错后再试一次。但<strong>重试不是万灵药，系统支持重试有很多先决条件</strong>，例如，我们的下游服务要能保证幂等性，否则很容易造成一些重复请求的问题，而如果这笔请求是转账操作，调用一次转一笔钱，无脑重试可能会给不支持幂等的下游系统带来无穷无尽的问题。由此就不难理解，为什么在很多支持重试的框架（例如 HTTP Client）中，我们要关闭重试功能。</p><!-- [[[read_end]]] -->\n<p>而且，这里所说的重试也不能仅仅是简单地将操作放到一个有限次数的循环里。设想这样一个场景，由于突发流量，我们的下游系统无法正常提供服务，响应很慢；上游收到了访问超时的报错，直接发起重试，于是本就不堪重负的下游将会收到更多请求，而无数的重试会造成更大的流量洪峰。为此，我们可以设计一些重试策略，这些策略可以相互结合使用。</p>\n<ul>\n<li>限制重试次数，不要无限制重试，例如最多重试 3 次。</li>\n<li>一旦失败不要立刻重试，延迟一段时间后再重试。</li>\n<li>增加重试的间隔时间，可以是固定的间隔，也可以是递增的时间。</li>\n</ul>\n<p>除此以外，为了减少不必要的重试，还可以对错误进行分类。对于短时间里重试也明显不会成功的请求，直接取消，不再重试；而对于那些通过重试可能会成功的请求，可以考虑重试。例如，HTTP 请求遇到了 <code>404 Not Found</code> 错误码，找不到想要访问的资源，那就不用重试了；而像网络超时这种请求错误，则可以重试。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>断路器模式</strong></p>\n<p>断路器（Circuit Breaker）模式是 Michael Nygard 在 <em>Release It!</em><span class=\"comment-number\">1</span> 一书中提出的，而 Martin Fowler 的文章 <span class=\"comment-number\">2</span> 更是让它名声大作。如果说重试模式是为了让系统能够重复执行那些可能成功的操作，那断路器模式则是为了避免系统去执行那些可能失败的操作。其背后的思想如图 15-1 所示，大概的意思就是将我们要执行的操作用断路器封装起来，断路器会监控报错情况，如果报错达到阈值，断路器在一段时间内就不会再执行该操作，而是走预先设定好的逻辑，例如直接抛出异常，或者是返回一个准备好的结果。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00797.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-1　Martin Fowler 博客中描述的断路器工作示意图</strong></p>\n<p>通常，断路器会有自己的状态机，它就是在以下这几种状态下工作的。</p>\n<ul>\n<li><strong>关闭</strong>，正常进行操作，过程中记录下一段时间内的报错情况，如果达到阈值则将断路器切换至“打开”状态。</li>\n<li><strong>打开</strong>，不再发起操作，直接执行预置逻辑，抛出异常或者返回准备好的结果；断路器打开一段时间后（通常会有个计时器之类的东西）会进入“半开”状态。</li>\n<li><strong>半开</strong>，在拦截大部分操作的同时，有少数操作会得到执行；如果这些操作执行成功则代表问题大概率已经解决了，断路器会切换至“关闭”状态，否则切换至“打开”状态。</li>\n</ul>\n<p>在实际使用过程中，断路器模式同样也有不少注意事项，例如，上游要能正确处理断路器打开时的异常或者返回结果；与重试模式一样，针对下游抛出的异常，可以区别对待，有些严重的异常已经携带了足够的信息，可以快速打开断路器。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>舱壁模式</strong></p>\n<p><strong>舱壁</strong>（Bulkhead）一词源自造船技术，根据用途分成好几种，我们一般说的都是水密舱壁。它将船舱严密地分成了好几个独立的部分，就算有一两个舱破损进水，由于舱壁的存在，水不会进入其他舱，以此来保证船不会沉。</p>\n<p>同样的设计思路可以运用到微服务的可用性保障上。设想这样一个场景，我们的系统会同时处理业务 A 和业务 B，两者的下游服务链路不同，在 A 的链路出现问题时，如果两者使用同一个线程池，所有线程资源有可能全都被拖死，导致原本可以不受影响的业务 B 也无法处理了。这时就可以考虑将两者的线程池分开，假设一共 100 个线程，A 分到 50 个，B 分到 50 个，虽然业务 A 依然有问题，但至少我们保住了业务 B。</p>\n<p>如果一个系统中会依赖多个下游，为它们分别配置线程池或者客户端就能起到舱壁的作用。对于同一个下游服务，如果它由集群构成，甚至可以为集群中的不同实例分别构建客户端。但即使如此，我们的代码还是要处理超时等问题，而且需要能正确地处理下游的各种异常。对于向上提供服务的系统，可以通过部署多套隔离的集群来实现舱壁隔离。如果是处理消息的系统，则可以考虑不同的集群消费不同的消息队列。</p>\n<p>当然，舱壁模式也是有成本的，我们需要根据业务与架构合理地规划舱壁。怎么进行隔离？无论是客户端、连接池，还是进程、线程、信号量，这些资源对系统来说都是昂贵的开销，应该尽量让它们物有所值。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>限流器模式</strong></p>\n<p>系统的容量不是无限的——虽然容器技术已经十分成熟，在 Kubernetes 中按需弹性提供 Pod 很方便，但应用背后的数据库却没办法像应用那样快速伸缩；又或者是一些请求需要使用昂贵的资源，但本身并不能提供太高的并发量。在这些情况下，我们能做的不是来者不拒地接受所有的请求，而是尽量将请求数量控制在能力范围内，这就是<strong>限流器</strong>（Rate Limiter）模式要做的事，简单来说，限制上游请求的数量，避免服务资源被滥用。如果要和断路器做个对比，断路器是在下游服务发生故障时保证服务调用方的安全，而限流器则是要保护服务提供方的安全，避免它被上游洪峰压垮。</p>\n<p>限流也有很多门道，我们可以根据不同的情况在不同的维度上进行控制，例如：</p>\n<ul>\n<li>基于全局流量进行限流，这是比较粗放的模式，也比较容易实现，通过一个全局的计数器就能决定拦还是不拦；</li>\n<li>基于特定接口进行限流，我们可以针对不同的接口设置不同的阈值，分别计数，一个接口被限流不会影响别的接口，这里还有一些变种，例如基于接口的特定参数进行限流等；</li>\n<li>基于特定请求来源限流，一个系统会接收多个上游系统的请求，也许某个系统由于 Bug 或者业务量陡增发起了大量请求，这时限制它的请求就好，其他上游可以正常访问系统。</li>\n</ul>\n<p>在阈值的设置方面，可以选择周期时间内接收多少请求，如果这个周期是秒，那就是通常所说的 <strong>TPS</strong>（Transaction Per Second）或 QPS（Query Per Second）；还可以是并发请求数，也就是同一时间可以接收的请求数量，即<strong>并发数</strong>。</p>\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_231\">15.1.2　通过 AOP 实现简单的容错</h3>\n<p>在了解了几种常见的模式后，我们可以先自己动手，在二进制奶茶店的某些场景下实现其中的一些服务容错的模式，而非直接套用现成的框架。也许我们写的代码会有这样或那样的考虑不周，但这对理解这些服务容错的模式很有帮助。</p>\n<blockquote>\n<p><strong>需求描述</strong>　之前的奶茶店只能下单，但下单后并没有支付，不付钱自然也就不能出货，所以当务之急就是要为二进制奶茶店增加一个付款功能。现在收单通常会用智能 POS 机，而 POS 机偶尔会因为网络等因素付款不成功，这时只能麻烦客人再重新付几次，连续失败的话，就先等等再说，不要急于反复支付。</p>\n</blockquote>\n<ol>\n<li><p><strong>业务逻辑调整</strong></p>\n<p>先来理解一下这个需求，跳过各种对接第三方支付的环节，我们直接把支付简化成修改订单状态。7.1 节里定义了 <code>OrderStatus</code> 枚举，里面的五种状态分别是已下单、已支付、制作中、已完成和已取货，这五种状态只能单向变化。为了方便做判断，我们为每个枚举值增加一个索引值，如代码示例 15-1<span class=\"comment-number\">3</span> 所示。变更时只需要判断索引值大小就好了。<span class=\"comment-number\">4</span></p>\n<blockquote>\n<p><strong>代码示例 15-1</strong>　修改后的 <code>OrderStatus</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public enum OrderStatus {\n    ORDERED(0), PAID(1), MAKING(2), FINISHED(3), TAKEN(4);\n\n    private int index;\n\n    OrderStatus(int index) {\n        this.index = index;\n    }\n\n    public int getIndex() {\n        return this.index;\n    }\n}</code></pre>\n<p>修改订单对象的状态，在 <code>REST</code> 接口中通常用 HTTP 的 <code>PUT</code> 方法实现，因此在 <code>OrderController</code> 中增加一个带有 <code>@PutMapping</code> 注解的 <code>modifyOrderStatus()</code> 方法，具体定义如代码示例 15-2 所示。它的主要逻辑并不复杂，先检查提交的 <code>StatusForm</code> 对象内容是否正确，随后获得订单的目标状态，用它来调用 <code>OrderService</code> 的 <code>modifyOrderStatus()</code> 方法（该方法的返回值就是修改了状态的订单对象）。</p>\n<blockquote>\n<p><strong>代码示例 15-2</strong>　负责修改订单状态的 <code>modifyOrderStatus()</code> 方法代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Controller\n@RequestMapping(\"/order\")\n@Slf4j\npublic class OrderController {\n    @ResponseBody\n    @PutMapping(consumes = MediaType.APPLICATION_JSON_VALUE,\n                produces = MediaType.APPLICATION_JSON_VALUE)\n    public ResponseEntity&lt;Order&gt; modifyOrderStatus(@RequestBody @Valid StatusForm form,\n                                                   BindingResult result) {\n        if (result.hasErrors()) {\n            return ResponseEntity.badRequest().body(null);\n        }\n        log.info(\"计划将ID={}的订单状态更新为{}\", form.getId(), form.getStatus());\n        OrderStatus status = OrderStatus.valueOf(form.getStatus());\n        if (status == null) {\n            log.warn(\"状态{}不正确\", form.getStatus());\n            return ResponseEntity.badRequest().body(null);\n        }\n        Order order = orderService.modifyOrderStatus(form.getId(), status);\n        return order == null ? ResponseEntity.badRequest().body(null) : ResponseEntity.ok(order);\n    }\n    // 省略其他代码\n}</code></pre>\n<p><code>StatusForm</code> 对象就比较简单了，就传一个订单号和目标状态。通常表单对象里状态枚举都会用字符串或者其他基础类型来表示，后续用代码将它再转成对应的枚举值。另外，类的定义上还增加了校验相关的注解，方便进行判断。具体如代码示例 15-3 所示。</p>\n<blockquote>\n<p><strong>代码示例 15-3</strong>　表示订单状态修改请求的 <code>StatusForm</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Getter\n@Setter\n@Builder\npublic class StatusForm {\n    @NotNull\n    private Long id;\n    @NotBlank\n    private String status;\n}</code></pre>\n<p>服务端拼图里的最后一块就是 <code>OrderService</code> 中修改订单状态的方法。代码示例 15-4 写得比较简单，或者说过于简单了，只加载了指定订单号的数据，判断了之前的状态，如果满足修改的条件就修改状态并返回修改后的对象。在实际工作中，我们为了避免订单被并发修改，通常会都会对数据加锁，例如用悲观锁先锁住订单，再修改状态 <span class=\"comment-number\">5</span>；或者用乐观锁，带状态更新，如果更新失败就说明订单被其他人修改了。此外，更新数据一定要修改记录的更新时间字段，此处是通过 <code>Order.updateTime</code> 属性上的 <code>@UpdateTimestamp</code> 注解来实现更新时自动修改时间戳的。如果你用的是 MyBatis 等其他 ORM 框架，或者直接使用了 JDBC，记得要做一定的修改。</p>\n<blockquote>\n<p><strong>代码示例 15-4</strong>　修改订单状态的 <code>modifyOrderStatus()</code> 方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Transactional\n@Slf4j\npublic class OrderService {\n    public Order modifyOrderStatus(Long id, OrderStatus status) {\n           Optional&lt;Order&gt; order = orderRepository.findById(id);\n        if (!order.isPresent()) {\n            log.warn(\"订单{}不存在\", id);\n            return null;\n        }\n        OrderStatus old = order.get().getStatus();\n        if (status.getIndex() != old.getIndex() + 1) {\n            log.warn(\"订单{}无法从状态{}改为{}\", id, old, status);\n            return null;\n        }\n        order.get().setStatus(status);\n        return orderRepository.save(order.get());\n    }\n    // 省略其他代码\n}</code></pre>\n<p>完成服务端的调整后，接下来就是调整对应的客户端，先是实现将订单修改为已支付状态的操作，再来添加容错功能（主要是重试和断路）。此处，以之前使用 OpenFeign 的例子作为基础进行修改，在 <code>OrderService</code> 中增加 <code>modifyOrderStatus()</code>，如代码示例 15-5 所示。其中用到的 <code>StatusForm</code> 与代码示例 15-3 基本一致，只是不需要在属性上添加校验的注解，也就是不需要 <code>@NotNull</code> 和 <code>@NotBlank</code>。</p>\n<blockquote>\n<p><strong>代码示例 15-5</strong>　增加了修改订单状态方法的 Feign 客户端接口代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@FeignClient(contextId = \"orderService\", name = \"binarytea\", path = \"/order\")\npublic interface OrderService {\n    @PutMapping(consumes = MediaType.APPLICATION_JSON_VALUE,\n                produces = MediaType.APPLICATION_JSON_VALUE)\n    ResponseEntity&lt;Order&gt; modifyOrderStatus(@RequestBody StatusForm form);\n    // 省略其他代码\n}</code></pre>\n<p>随后，在处理订单的 <code>OrderRunner</code> 中增加支付的逻辑，其实就是拼装 <code>StatusForm</code>，把它传给 <code>modifyOrderStatus()</code>，具体如代码示例 15-6 所示。</p>\n<blockquote>\n<p><strong>代码示例 15-6</strong>　增加了支付逻辑的 <code>OrderRunner</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Order(5)\n@Setter\n@Slf4j\npublic class OrderRunner implements ApplicationRunner {\n    @Autowired\n    private OrderService orderService;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        // 省略之前创建订单的代码\n        // response的类型是ResponseEntity&lt;learning.spring.customer.model.Order&gt;\n        log.info(\"开始支付订单：{}\", response.getBody().getId());\n        StatusForm sf = StatusForm.builder()\n            .id(response.getBody().getId())\n            .status(\"PAID\").build();\n        response = orderService.modifyOrderStatus(sf);\n        log.info(\"HTTP Status: {}, Headers: {}\", response.getStatusCode(), response.getHeaders());\n        log.info(\"Body: {}\", response.getBody());\n    }\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>开发容错功能</strong></p>\n<p>前面是最基本的先下单后支付的业务逻辑代码，现在要开始动手实现一些正常业务逻辑之外的东西了——我们打算在客户端增加简单的重试与熔断功能，以此来应对异常情况。为了能够对业务代码无侵入，并且具有通用性，我们将用 Spring AOP 的切面来实现所需的功能。由于集成服务端的 OpenFeign 接口都放在了 <code>learning.spring.customer.integration</code> 包下面，直接拦截其中的方法执行过程就可以了。</p>\n<blockquote>\n<p><strong>请注意</strong>　这里需要强调一下，简单起见，此处的两个 AOP 切面只是用来演示重试和熔断思路的，具体在生产中使用的逻辑会更加复杂，需要考虑大量的异常场景，做很多针对性的优化。因此，千万不要简单地将它们搬去生产，而应该使用成熟的框架。</p>\n</blockquote>\n<p>先来看看重试切面 <code>RetryAspect</code>，设定一个最大重试阈值和间隔时间，例如代码示例 15-7 中设置的就是重试 3 次，每次间隔 100 毫秒。将具体的方法调用放在一个循环体内，如果成功执行则直接返回；抛异常的话则记录异常，在重试次数用完后抛出最后记录的异常。</p>\n<blockquote>\n<p><strong>代码示例 15-7</strong>　简单的重试切面代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Aspect\n@Slf4j\n@Order(0)\npublic class RetryAspect {\n    private static final int THRESHOLD = 3;\n    private static final int DURATION = 100;\n\n    @Around(\"execution(* learning.spring.customer.integration..*(..))\")\n    public Object doWithRetry(ProceedingJoinPoint pjp) throws Throwable {\n        String signature = pjp.getSignature().toLongString();\n        log.info(\"带重试机制调用{}方法\", signature);\n        Object ret = null;\n        Exception lastEx = null;\n        for (int i = 1; i &lt;= THRESHOLD; i++) {\n            try {\n                ret = pjp.proceed();\n                log.info(\"在第{}次完成了{}调用\", i, signature);\n                return ret;\n            } catch (Exception e) {\n                log.warn(\"执行失败\", e);\n                lastEx = e;\n                try {\n                    TimeUnit.MILLISECONDS.sleep(DURATION);\n                } catch (InterruptedException ie) {\n                }\n            }\n        }\n        log.error(\"{}方法最终执行失败，抛出异常{}\", signature, lastEx);\n        throw lastEx;\n    }\n}</code></pre>\n<p>再来看看断路器 <code>CircuitBreakerAspect</code>。它的逻辑会复杂一些：我们要记录当前方法的连续失败次数，一旦它超过阈值，就直接返回 <code>503 Service Unavailable</code> 报文，不发起调用；熔断期间再记录一下熔断的次数，隔几次做个探测，如果调通了，重置所有计数器。具体如代码示例 15-8 所示。之所以选择连续失败次数作为标准，是因为它的实现最简单，但时好时坏的情况它就有可能无法应对，所以也可以考虑用一段时间内的失败次数作为打开断路器的标准。</p>\n<blockquote>\n<p><strong>代码示例 15-8</strong>　断路器切面代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Aspect\n@Slf4j\n@Order(1)\npublic class CircuitBreakerAspect {\n    private static final Integer THRESHOLD = 3;\n    private Map&lt;String, AtomicInteger&gt; errorCounter = new ConcurrentHashMap&lt;&gt;();\n    private Map&lt;String, AtomicInteger&gt; probeCounter = new ConcurrentHashMap&lt;&gt;();\n\n    @Around(\"execution(* learning.spring.customer.integration..*(..))\")\n    public Object doWithCircuitBreaker(ProceedingJoinPoint pjp) throws Throwable {\n        String signature = pjp.getSignature().toLongString();\n        log.info(\"带断路保护执行{}方法\", signature);\n        Object retVal;\n\n        try {\n            if (!errorCounter.containsKey(signature)) {\n                resetCounter(signature);\n            }\n            if (errorCounter.get(signature).get() &gt;= THRESHOLD &amp;&amp;\n                probeCounter.get(signature).get() &lt; THRESHOLD) {\n                log.warn(\"断路器打开，第{}次直接返回503\",probeCounter.get(signature).incrementAndGet());\n                return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).build();\n            }\n            retVal = pjp.proceed();\n            resetCounter(signature);\n        } catch (Throwable t) {\n            log.warn(\"错误计数{}次，抛出{}异常\", errorCounter.get(signature).incrementAndGet(),\n                t.getMessage());\n            probeCounter.get(signature).set(0);\n            throw t;\n        }\n        return retVal;\n    }\n\n    private void resetCounter(String signature) {\n        errorCounter.put(signature, new AtomicInteger(0));\n        probeCounter.put(signature, new AtomicInteger(0));\n    }\n}</code></pre>\n<p>以上就是两个切面。为了精确地控制切面的行为，我们在类上增加了 <code>@Order</code> 注解来指定它们的顺序，<code>@Order</code> 的值<strong>越小</strong>，执行时的优先级就<strong>越高</strong>，也就是先执行。在这个例子里就是先进入 <code>RetryAspect</code> 的重试逻辑，会执行 3 次调用，每次调用又是被 <code>CircuitBreakerAspect</code> 增强过的。</p>\n<p>最后，将我们的两个 AOP 切面配置成 Bean，也就是在 <code>CustomerApplication</code> 里增加对应的 <code>@Bean</code> 方法，具体如代码示例 15-9 所示。</p>\n<blockquote>\n<p><strong>代码示例 15-9</strong>　包含容错切面配置的 <code>CustomerApplication</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@Slf4j\n@EnableFeignClients\npublic class CustomerApplication {\n    @Bean\n    public RetryAspect retryAspect() {\n        return new RetryAspect();\n    }\n\n    @Bean\n    public CircuitBreakerAspect circuitBreakerAspect() {\n        return new CircuitBreakerAspect();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>测试容错功能</strong></p>\n<p>现在运行客户端，理论上来说是包含一定的容错能力的，不过还是要证明一下。粗暴一点的做法是直接在运行 <code>OrderRunner</code> 的过程中加上一些时间间隔，手动停止服务端应用，看看效果。但这样显然不够优雅，如果能用自动化测试来验证我们的拦截器效果，那就再好不过了。</p>\n<p>为了尽可能地将关注点集中在我们的 AOP 拦截器上，我们要排除各种其他依赖项和不需要的 Bean，例如就不要让 OpenFeign 真的创建一个 Bean 了，可以用 Mockito 来模拟接口实现，把模拟的对象变成 Bean，让 <code>RetryAspect</code> 来拦截它。代码示例 15-10 是针对 <code>RetryAspect</code> 的一个单元测试，不用 <code>SpringBootTest</code> 来启动并加载整个应用，我们回归最原始的 Spring 程序单元测试。<code>RetryTestConfig</code> 作为内部测试配置类，上面加了 <code>@TestConfiguration</code>，开启了 AspectJ 自动代理支持，配置类里声明了两个 Bean，<code>orderService</code> 就是用 <code>Mockito.mock()</code> 创建的 Mock 对象。</p>\n<blockquote>\n<p><strong>代码示例 15-10</strong>　包含了单元测试配置的 <code>RetryAspectTest</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringJUnitConfig(RetryAspectTest.RetryTestConfig.class)\nclass RetryAspectTest {\n    @TestConfiguration\n    @EnableAspectJAutoProxy\n    static class RetryTestConfig {\n        @Bean\n        public RetryAspect retryAspect() {\n            return new RetryAspect();\n        }\n\n        @Bean\n        public OrderService orderService() {\n            return mock(OrderService.class);\n        }\n    }\n    // 省略其他代码\n}</code></pre>\n<p>有了可以运行的最小 Spring 环境后，开始编写测试用例，可以设计两个简单的场景。</p>\n<p>(1) 被调用的方法正常返回，没有发生重试，直接拿到结果，Mock 对象的方法只调用了一次。对应了代码示例 15-11 中的 <code>testSuccessInvoke()</code> 方法。</p>\n<p>(2) 被调用的方法抛出异常，发生了重试，重试最终成功返回了，Mock 对象的方法被调用了好几次。对应了代码示例 15-11 中的 <code>testDoWithRetry()</code> 方法。</p>\n<p>代码示例 15-11 中用的 <code>BDDMockito</code> 中的很多静态方法，可以用 BDD<span class=\"comment-number\">6</span> 的形式描述我们的测试用例。为了方便描述，我们直接把所有方法都 <code>import static</code> 了进来。在实际开发中，如有必要可以按照编码规范导入用到的方法。以 <code>testSuccessInvoke()</code> 为例，BDD 的描述是给定（<code>given()</code>）调用 <code>mockService.listOrders()</code>，将返回（<code>willReturn()</code>）<code>Collections.emptyList()</code>；实际调用了 <code>listOrders()</code> 后，那么（<code>then()</code>）<code>mockService</code> 的 <code>listOrders()</code> 应该（<code>should()</code>）只被调用了一次（<code>once()</code>）；再结合一些别的简单断言，这就是一个测试用例了。<code>testDoWithRetry()</code> 的逻辑也是类似的，<code>CircuitBreakerAspect</code> 的测试也可以用这样的方法，这里就不再赘述了。</p>\n<blockquote>\n<p><strong>代码示例 15-11</strong>　针对重试切面的测试用例代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>import static org.mockito.BDDMockito.*;\n\n@SpringJUnitConfig(RetryAspectTest.RetryTestConfig.class)\nclass RetryAspectTest {\n    // 省略Spring内部配置类，见代码示例15-10\n    @Autowired\n    private OrderService orderService;\n    private OrderService mockService;\n\n    @BeforeEach\n    public void setUp() {\n        mockService = AopTestUtils.getUltimateTargetObject(orderService);\n        reset(mockService);\n    }\n\n    @Test\n    void testSuccessInvoke() {\n        given(mockService.listOrders()).willReturn(Collections.emptyList());\n        List&lt;Order&gt; orders = orderService.listOrders();\n        then(mockService).should(only()).listOrders();\n        assertTrue(orders.isEmpty());\n    }\n\n    @Test\n    void testDoWithRetry() {\n        given(mockService.listOrders())\n        .willThrow(new RuntimeException())\n        .willThrow(new RuntimeException())\n        .willReturn(Collections.emptyList());\n        List&lt;Order&gt; orders = orderService.listOrders();\n        then(mockService).should(times(3)).listOrders();\n        assertTrue(orders.isEmpty());\n    }\n}</code></pre>\n</li>\n</ol>\n\n\n\n\n","comments":[{"had_liked":false,"id":391572,"user_name":"Geek_1cc6d1","can_delete":false,"product_type":"c1","uid":1850248,"ip_address":"北京","ucode":"3E083616DD0742","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZCyXaP2gbxwFHxvtnyaaF2Pyy5KkSMsk9kh7SJl8icp1CD6wicb6VJibiblGibbpDo6IuHrdST6AnWQg/132","comment_is_top":false,"comment_ctime":1718584281,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636606,"comment_content":"后面没有对应的文本了？","like_count":0}]}