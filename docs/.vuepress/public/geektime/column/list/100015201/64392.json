{"id":64392,"title":"31 | 容器存储实践：CSI插件编写指南","content":"<p>你好，我是张磊。今天我和你分享的主题是：容器存储实践之CSI插件编写指南。</p><p>在上一篇文章中，我已经为你详细讲解了CSI插件机制的设计原理。今天我将继续和你一起实践一个CSI插件的编写过程。</p><p>为了能够覆盖到CSI插件的所有功能，我这一次选择了DigitalOcean的块存储（Block Storage）服务，来作为实践对象。</p><p>DigitalOcean是业界知名的“最简”公有云服务，即：它只提供虚拟机、存储、网络等为数不多的几个基础功能，其他功能一概不管。而这，恰恰就使得DigitalOcean成了我们在公有云上实践Kubernetes的最佳选择。</p><p><span class=\"orange\">我们这次编写的CSI插件的功能，就是：让我们运行在DigitalOcean上的Kubernetes集群能够使用它的块存储服务，作为容器的持久化存储。</span></p><blockquote>\n<p>备注：在DigitalOcean上部署一个Kubernetes集群的过程，也很简单。你只需要先在DigitalOcean上创建几个虚拟机，然后按照我们在第11篇文章<a href=\"https://time.geekbang.org/column/article/39724\">《从0到1：搭建一个完整的Kubernetes集群》</a>中从0到1的步骤直接部署即可。</p>\n</blockquote><p>而有了CSI插件之后，持久化存储的用法就非常简单了，你只需要创建一个如下所示的StorageClass对象即可：</p><!-- [[[read_end]]] --><pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\n  name: do-block-storage\n  namespace: kube-system\n  annotations:\n    storageclass.kubernetes.io/is-default-class: &quot;true&quot;\nprovisioner: com.digitalocean.csi.dobs\n</code></pre><p>有了这个StorageClass，External Provisoner就会为集群中新出现的PVC自动创建出PV，然后调用CSI插件创建出这个PV对应的Volume，这正是CSI体系中Dynamic Provisioning的实现方式。</p><blockquote>\n<p>备注：<code>storageclass.kubernetes.io/is-default-class: \"true\"</code>的意思，是使用这个StorageClass作为默认的持久化存储提供者。</p>\n</blockquote><p>不难看到，这个StorageClass里唯一引人注意的，是provisioner=com.digitalocean.csi.dobs这个字段。显然，这个字段告诉了Kubernetes，请使用名叫com.digitalocean.csi.dobs的CSI插件来为我处理这个StorageClass相关的所有操作。</p><p>那么，<span class=\"orange\">Kubernetes又是如何知道一个CSI插件的名字的呢？</span></p><p><strong>这就需要从CSI插件的第一个服务CSI Identity说起了。</strong></p><p>其实，一个CSI插件的代码结构非常简单，如下所示：</p><pre><code>tree $GOPATH/src/github.com/digitalocean/csi-digitalocean/driver  \n$GOPATH/src/github.com/digitalocean/csi-digitalocean/driver \n├── controller.go\n├── driver.go\n├── identity.go\n├── mounter.go\n└── node.go\n</code></pre><p>其中，CSI Identity服务的实现，就定义在了driver目录下的identity.go文件里。</p><p>当然，为了能够让Kubernetes访问到CSI Identity服务，我们需要先在driver.go文件里，定义一个标准的gRPC Server，如下所示：</p><pre><code>// Run starts the CSI plugin by communication over the given endpoint\nfunc (d *Driver) Run() error {\n ...\n \n listener, err := net.Listen(u.Scheme, addr)\n ...\n \n d.srv = grpc.NewServer(grpc.UnaryInterceptor(errHandler))\n csi.RegisterIdentityServer(d.srv, d)\n csi.RegisterControllerServer(d.srv, d)\n csi.RegisterNodeServer(d.srv, d)\n \n d.ready = true // we're now ready to go!\n ...\n return d.srv.Serve(listener)\n}\n</code></pre><p>可以看到，只要把编写好的gRPC Server注册给CSI，它就可以响应来自External Components的CSI请求了。</p><p><strong>CSI Identity服务中，最重要的接口是GetPluginInfo</strong>，它返回的就是这个插件的名字和版本号，如下所示：</p><blockquote>\n<p>备注：CSI各个服务的接口我在上一篇文章中已经介绍过，你也可以在这里找到<a href=\"https://github.com/container-storage-interface/spec/blob/master/csi.proto\">它的protoc文件</a>。</p>\n</blockquote><pre><code>func (d *Driver) GetPluginInfo(ctx context.Context, req *csi.GetPluginInfoRequest) (*csi.GetPluginInfoResponse, error) {\n resp := &amp;csi.GetPluginInfoResponse{\n  Name:          driverName,\n  VendorVersion: version,\n }\n ...\n}\n</code></pre><p>其中，driverName的值，正是\"com.digitalocean.csi.dobs\"。所以说，Kubernetes正是通过GetPluginInfo的返回值，来找到你在StorageClass里声明要使用的CSI插件的。</p><blockquote>\n<p>备注：CSI要求插件的名字遵守<a href=\"https://en.wikipedia.org/wiki/Reverse_domain_name_notation\">“反向DNS”格式</a>。</p>\n</blockquote><p>另外一个<strong>GetPluginCapabilities接口也很重要</strong>。这个接口返回的是这个CSI插件的“能力”。</p><p>比如，当你编写的CSI插件不准备实现“Provision阶段”和“Attach阶段”（比如，一个最简单的NFS存储插件就不需要这两个阶段）时，你就可以通过这个接口返回：本插件不提供CSI Controller服务，即：没有csi.PluginCapability_Service_CONTROLLER_SERVICE这个“能力”。这样，Kubernetes就知道这个信息了。</p><p>最后，<strong>CSI Identity服务还提供了一个Probe接口</strong>。Kubernetes会调用它来检查这个CSI插件是否正常工作。</p><p>一般情况下，我建议你在编写插件时给它设置一个Ready标志，当插件的gRPC Server停止的时候，把这个Ready标志设置为false。或者，你可以在这里访问一下插件的端口，类似于健康检查的做法。</p><blockquote>\n<p>备注：关于健康检查的问题，你可以再回顾一下第15篇文章<a href=\"https://time.geekbang.org/column/article/40466\">《深入解析Pod对象（二）：使用进阶》</a>中的相关内容。</p>\n</blockquote><p>然后，<span class=\"orange\">我们要开始编写CSI 插件的第二个服务，即CSI Controller服务了。</span>它的代码实现，在controller.go文件里。</p><p>在上一篇文章中我已经为你讲解过，这个服务主要实现的就是Volume管理流程中的“Provision阶段”和“Attach阶段”。</p><p><strong>“Provision阶段”对应的接口，是CreateVolume和DeleteVolume</strong>，它们的调用者是External Provisoner。以CreateVolume为例，它的主要逻辑如下所示：</p><pre><code>func (d *Driver) CreateVolume(ctx context.Context, req *csi.CreateVolumeRequest) (*csi.CreateVolumeResponse, error) {\n ...\n \n volumeReq := &amp;godo.VolumeCreateRequest{\n  Region:        d.region,\n  Name:          volumeName,\n  Description:   createdByDO,\n  SizeGigaBytes: size / GB,\n }\n \n ...\n \n vol, _, err := d.doClient.Storage.CreateVolume(ctx, volumeReq)\n \n ...\n \n resp := &amp;csi.CreateVolumeResponse{\n  Volume: &amp;csi.Volume{\n   Id:            vol.ID,\n   CapacityBytes: size,\n   AccessibleTopology: []*csi.Topology{\n    {\n     Segments: map[string]string{\n      &quot;region&quot;: d.region,\n     },\n    },\n   },\n  },\n }\n \n return resp, nil\n}\n</code></pre><p>可以看到，对于DigitalOcean这样的公有云来说，CreateVolume需要做的操作，就是调用DigitalOcean块存储服务的API，创建出一个存储卷（d.doClient.Storage.CreateVolume）。如果你使用的是其他类型的块存储（比如Cinder、Ceph RBD等），对应的操作也是类似地调用创建存储卷的API。</p><p>而“<strong>Attach阶段”对应的接口是ControllerPublishVolume和ControllerUnpublishVolume</strong>，它们的调用者是External Attacher。以ControllerPublishVolume为例，它的逻辑如下所示：</p><pre><code>func (d *Driver) ControllerPublishVolume(ctx context.Context, req *csi.ControllerPublishVolumeRequest) (*csi.ControllerPublishVolumeResponse, error) {\n ...\n \n  dropletID, err := strconv.Atoi(req.NodeId)\n  \n  // check if volume exist before trying to attach it\n  _, resp, err := d.doClient.Storage.GetVolume(ctx, req.VolumeId)\n \n ...\n \n  // check if droplet exist before trying to attach the volume to the droplet\n  _, resp, err = d.doClient.Droplets.Get(ctx, dropletID)\n \n ...\n \n  action, resp, err := d.doClient.StorageActions.Attach(ctx, req.VolumeId, dropletID)\n\n ...\n \n if action != nil {\n  ll.Info(&quot;waiting until volume is attached&quot;)\n if err := d.waitAction(ctx, req.VolumeId, action.ID); err != nil {\n  return nil, err\n  }\n  }\n  \n  ll.Info(&quot;volume is attached&quot;)\n return &amp;csi.ControllerPublishVolumeResponse{}, nil\n}\n</code></pre><p>可以看到，对于DigitalOcean来说，ControllerPublishVolume在“Attach阶段”需要做的工作，是调用DigitalOcean的API，将我们前面创建的存储卷，挂载到指定的虚拟机上（d.doClient.StorageActions.Attach）。</p><p>其中，存储卷由请求中的VolumeId来指定。而虚拟机，也就是将要运行Pod的宿主机，则由请求中的NodeId来指定。这些参数，都是External Attacher在发起请求时需要设置的。</p><p>我在上一篇文章中已经为你介绍过，External Attacher的工作原理，是监听（Watch）了一种名叫VolumeAttachment的API对象。这种API对象的主要字段如下所示：</p><pre><code>// VolumeAttachmentSpec is the specification of a VolumeAttachment request.\ntype VolumeAttachmentSpec struct {\n // Attacher indicates the name of the volume driver that MUST handle this\n // request. This is the name returned by GetPluginName().\n Attacher string\n \n // Source represents the volume that should be attached.\n Source VolumeAttachmentSource\n \n // The node that the volume should be attached to.\n NodeName string\n}\n</code></pre><p>而这个对象的生命周期，正是由AttachDetachController负责管理的（这里，你可以再回顾一下第28篇文章<a href=\"https://time.geekbang.org/column/article/42698\">《PV、PVC、StorageClass，这些到底在说啥？》</a>中的相关内容）。</p><p>这个控制循环的职责，是不断检查Pod所对应的PV，在它所绑定的宿主机上的挂载情况，从而决定是否需要对这个PV进行Attach（或者Dettach）操作。</p><p>而这个Attach操作，在CSI体系里，就是创建出上面这样一个VolumeAttachment对象。可以看到，Attach操作所需的PV的名字（Source）、宿主机的名字（NodeName）、存储插件的名字（Attacher），都是这个VolumeAttachment对象的一部分。</p><p>而当External Attacher监听到这样的一个对象出现之后，就可以立即使用VolumeAttachment里的这些字段，封装成一个gRPC请求调用CSI Controller的ControllerPublishVolume方法。</p><p>最后，<span class=\"orange\">我们就可以编写CSI Node服务了。</span></p><p>CSI Node服务对应的，是Volume管理流程里的“Mount阶段”。它的代码实现，在node.go文件里。</p><p>我在上一篇文章里曾经提到过，kubelet的VolumeManagerReconciler控制循环会直接调用CSI Node服务来完成Volume的“Mount阶段”。</p><p>不过，在具体的实现中，这个“Mount阶段”的处理其实被细分成了NodeStageVolume和NodePublishVolume这两个接口。</p><p>这里的原因其实也很容易理解：我在第28篇文章<a href=\"https://time.geekbang.org/column/article/42698\">《PV、PVC、StorageClass，这些到底在说啥？》</a>中曾经介绍过，对于磁盘以及块设备来说，它们被Attach到宿主机上之后，就成为了宿主机上的一个待用存储设备。而到了“Mount阶段”，我们首先需要格式化这个设备，然后才能把它挂载到Volume对应的宿主机目录上。</p><p>在kubelet的VolumeManagerReconciler控制循环中，这两步操作分别叫作<strong>MountDevice和SetUp。</strong></p><p>其中，MountDevice操作，就是直接调用了CSI Node服务里的NodeStageVolume接口。顾名思义，这个接口的作用，就是格式化Volume在宿主机上对应的存储设备，然后挂载到一个临时目录（Staging目录）上。</p><p>对于DigitalOcean来说，它对NodeStageVolume接口的实现如下所示：</p><pre><code>func (d *Driver) NodeStageVolume(ctx context.Context, req *csi.NodeStageVolumeRequest) (*csi.NodeStageVolumeResponse, error) {\n ...\n \n vol, resp, err := d.doClient.Storage.GetVolume(ctx, req.VolumeId)\n \n ...\n \n source := getDiskSource(vol.Name)\n target := req.StagingTargetPath\n \n ...\n \n if !formatted {\n  ll.Info(&quot;formatting the volume for staging&quot;)\n  if err := d.mounter.Format(source, fsType); err != nil {\n   return nil, status.Error(codes.Internal, err.Error())\n  }\n } else {\n  ll.Info(&quot;source device is already formatted&quot;)\n }\n \n...\n\n if !mounted {\n  if err := d.mounter.Mount(source, target, fsType, options...); err != nil {\n   return nil, status.Error(codes.Internal, err.Error())\n  }\n } else {\n  ll.Info(&quot;source device is already mounted to the target path&quot;)\n }\n \n ...\n return &amp;csi.NodeStageVolumeResponse{}, nil\n}\n</code></pre><p>可以看到，在NodeStageVolume的实现里，我们首先通过DigitalOcean的API获取到了这个Volume对应的设备路径（getDiskSource）；然后，我们把这个设备格式化成指定的格式（ d.mounter.Format）；最后，我们把格式化后的设备挂载到了一个临时的Staging目录（StagingTargetPath）下。</p><p>而SetUp操作则会调用CSI Node服务的NodePublishVolume接口。有了上述对设备的预处理工作后，它的实现就非常简单了，如下所示：</p><pre><code>func (d *Driver) NodePublishVolume(ctx context.Context, req *csi.NodePublishVolumeRequest) (*csi.NodePublishVolumeResponse, error) {\n ...\n source := req.StagingTargetPath\n target := req.TargetPath\n \n mnt := req.VolumeCapability.GetMount()\n options := mnt.MountFlag\n    ...\n    \n if !mounted {\n  ll.Info(&quot;mounting the volume&quot;)\n  if err := d.mounter.Mount(source, target, fsType, options...); err != nil {\n   return nil, status.Error(codes.Internal, err.Error())\n  }\n } else {\n  ll.Info(&quot;volume is already mounted&quot;)\n }\n \n return &amp;csi.NodePublishVolumeResponse{}, nil\n}\n</code></pre><p>可以看到，在这一步实现中，我们只需要做一步操作，即：将Staging目录，绑定挂载到Volume对应的宿主机目录上。</p><p>由于Staging目录，正是Volume对应的设备被格式化后挂载在宿主机上的位置，所以当它和Volume的宿主机目录绑定挂载之后，这个Volume宿主机目录的“持久化”处理也就完成了。</p><p>当然，我在前面也曾经提到过，对于文件系统类型的存储服务来说，比如NFS和GlusterFS等，它们并没有一个对应的磁盘“设备”存在于宿主机上，所以kubelet在VolumeManagerReconciler控制循环中，会跳过MountDevice操作而直接执行SetUp操作。所以对于它们来说，也就不需要实现NodeStageVolume接口了。</p><p><span class=\"orange\">在编写完了CSI插件之后，我们就可以把这个插件和External Components一起部署起来。</span></p><p>首先，我们需要创建一个DigitalOcean client授权需要使用的Secret对象，如下所示：</p><pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: digitalocean\n  namespace: kube-system\nstringData:\n  access-token: &quot;a05dd2f26b9b9ac2asdas__REPLACE_ME____123cb5d1ec17513e06da&quot;\n</code></pre><p>接下来，我们通过一句指令就可以将CSI插件部署起来：</p><pre><code>$ kubectl apply -f https://raw.githubusercontent.com/digitalocean/csi-digitalocean/master/deploy/kubernetes/releases/csi-digitalocean-v0.2.0.yaml\n</code></pre><p>这个CSI插件的YAML文件的主要内容如下所示（其中，非重要的内容已经被略去）：</p><pre><code>kind: DaemonSet\napiVersion: apps/v1beta2\nmetadata:\n  name: csi-do-node\n  namespace: kube-system\nspec:\n  selector:\n    matchLabels:\n      app: csi-do-node\n  template:\n    metadata:\n      labels:\n        app: csi-do-node\n        role: csi-do\n    spec:\n      serviceAccount: csi-do-node-sa\n      hostNetwork: true\n      containers:\n        - name: driver-registrar\n          image: quay.io/k8scsi/driver-registrar:v0.3.0\n          ...\n        - name: csi-do-plugin\n          image: digitalocean/do-csi-plugin:v0.2.0\n          args :\n            - &quot;--endpoint=$(CSI_ENDPOINT)&quot;\n            - &quot;--token=$(DIGITALOCEAN_ACCESS_TOKEN)&quot;\n            - &quot;--url=$(DIGITALOCEAN_API_URL)&quot;\n          env:\n            - name: CSI_ENDPOINT\n              value: unix:///csi/csi.sock\n            - name: DIGITALOCEAN_API_URL\n              value: https://api.digitalocean.com/\n            - name: DIGITALOCEAN_ACCESS_TOKEN\n              valueFrom:\n                secretKeyRef:\n                  name: digitalocean\n                  key: access-token\n          imagePullPolicy: &quot;Always&quot;\n          securityContext:\n            privileged: true\n            capabilities:\n              add: [&quot;SYS_ADMIN&quot;]\n            allowPrivilegeEscalation: true\n          volumeMounts:\n            - name: plugin-dir\n              mountPath: /csi\n            - name: pods-mount-dir\n              mountPath: /var/lib/kubelet\n              mountPropagation: &quot;Bidirectional&quot;\n            - name: device-dir\n              mountPath: /dev\n      volumes:\n        - name: plugin-dir\n          hostPath:\n            path: /var/lib/kubelet/plugins/com.digitalocean.csi.dobs\n            type: DirectoryOrCreate\n        - name: pods-mount-dir\n          hostPath:\n            path: /var/lib/kubelet\n            type: Directory\n        - name: device-dir\n          hostPath:\n            path: /dev\n---\nkind: StatefulSet\napiVersion: apps/v1beta1\nmetadata:\n  name: csi-do-controller\n  namespace: kube-system\nspec:\n  serviceName: &quot;csi-do&quot;\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: csi-do-controller\n        role: csi-do\n    spec:\n      serviceAccount: csi-do-controller-sa\n      containers:\n        - name: csi-provisioner\n          image: quay.io/k8scsi/csi-provisioner:v0.3.0\n          ...\n        - name: csi-attacher\n          image: quay.io/k8scsi/csi-attacher:v0.3.0\n          ...\n        - name: csi-do-plugin\n          image: digitalocean/do-csi-plugin:v0.2.0\n          args :\n            - &quot;--endpoint=$(CSI_ENDPOINT)&quot;\n            - &quot;--token=$(DIGITALOCEAN_ACCESS_TOKEN)&quot;\n            - &quot;--url=$(DIGITALOCEAN_API_URL)&quot;\n          env:\n            - name: CSI_ENDPOINT\n              value: unix:///var/lib/csi/sockets/pluginproxy/csi.sock\n            - name: DIGITALOCEAN_API_URL\n              value: https://api.digitalocean.com/\n            - name: DIGITALOCEAN_ACCESS_TOKEN\n              valueFrom:\n                secretKeyRef:\n                  name: digitalocean\n                  key: access-token\n          imagePullPolicy: &quot;Always&quot;\n          volumeMounts:\n            - name: socket-dir\n              mountPath: /var/lib/csi/sockets/pluginproxy/\n      volumes:\n        - name: socket-dir\n          emptyDir: {}\n</code></pre><p>可以看到，我们编写的CSI插件只有一个二进制文件，它的镜像是digitalocean/do-csi-plugin:v0.2.0。</p><p>而我们<strong>部署CSI插件的常用原则是：</strong></p><p><strong>第一，通过DaemonSet在每个节点上都启动一个CSI插件，来为kubelet提供CSI Node服务</strong>。这是因为，CSI Node服务需要被kubelet直接调用，所以它要和kubelet“一对一”地部署起来。</p><p>此外，在上述DaemonSet的定义里面，除了CSI插件，我们还以sidecar的方式运行着driver-registrar这个外部组件。它的作用，是向kubelet注册这个CSI插件。这个注册过程使用的插件信息，则通过访问同一个Pod里的CSI插件容器的Identity服务获取到。</p><p>需要注意的是，由于CSI插件运行在一个容器里，那么CSI Node服务在“Mount阶段”执行的挂载操作，实际上是发生在这个容器的Mount Namespace里的。可是，我们真正希望执行挂载操作的对象，都是宿主机/var/lib/kubelet目录下的文件和目录。</p><p>所以，在定义DaemonSet Pod的时候，我们需要把宿主机的/var/lib/kubelet以Volume的方式挂载进CSI插件容器的同名目录下，然后设置这个Volume的mountPropagation=Bidirectional，即开启双向挂载传播，从而将容器在这个目录下进行的挂载操作“传播”给宿主机，反之亦然。</p><p><strong>第二，通过StatefulSet在任意一个节点上再启动一个CSI插件，为External Components提供CSI Controller服务</strong>。所以，作为CSI Controller服务的调用者，External Provisioner和External Attacher这两个外部组件，就需要以sidecar的方式和这次部署的CSI插件定义在同一个Pod里。</p><p>你可能会好奇，为什么我们会用StatefulSet而不是Deployment来运行这个CSI插件呢。</p><p>这是因为，由于StatefulSet需要确保应用拓扑状态的稳定性，所以它对Pod的更新，是严格保证顺序的，即：只有在前一个Pod停止并删除之后，它才会创建并启动下一个Pod。</p><p>而像我们上面这样将StatefulSet的replicas设置为1的话，StatefulSet就会确保Pod被删除重建的时候，永远有且只有一个CSI插件的Pod运行在集群中。这对CSI插件的正确性来说，至关重要。</p><p>而在今天这篇文章一开始，我们就已经定义了这个CSI插件对应的StorageClass（即：do-block-storage），所以你接下来只需要定义一个声明使用这个StorageClass的PVC即可，如下所示：</p><pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: csi-pvc\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n  storageClassName: do-block-storage\n</code></pre><p>当你把上述PVC提交给Kubernetes之后，你就可以在Pod里声明使用这个csi-pvc来作为持久化存储了。这一部分使用PV和PVC的内容，我就不再赘述了。</p><h2>总结</h2><p>在今天这篇文章中，我以一个DigitalOcean的CSI插件为例，和你分享了编写CSI插件的具体流程。</p><p>基于这些讲述，你现在应该已经对Kubernetes持久化存储体系有了一个更加全面和深入的认识。</p><p>举个例子，对于一个部署了CSI存储插件的Kubernetes集群来说：</p><p>当用户创建了一个PVC之后，你前面部署的StatefulSet里的External Provisioner容器，就会监听到这个PVC的诞生，然后调用同一个Pod里的CSI插件的CSI Controller服务的CreateVolume方法，为你创建出对应的PV。</p><p>这时候，运行在Kubernetes Master节点上的Volume Controller，就会通过PersistentVolumeController控制循环，发现这对新创建出来的PV和PVC，并且看到它们声明的是同一个StorageClass。所以，它会把这一对PV和PVC绑定起来，使PVC进入Bound状态。</p><p>然后，用户创建了一个声明使用上述PVC的Pod，并且这个Pod被调度器调度到了宿主机A上。这时候，Volume Controller的AttachDetachController控制循环就会发现，上述PVC对应的Volume，需要被Attach到宿主机A上。所以，AttachDetachController会创建一个VolumeAttachment对象，这个对象携带了宿主机A和待处理的Volume的名字。</p><p>这样，StatefulSet里的External Attacher容器，就会监听到这个VolumeAttachment对象的诞生。于是，它就会使用这个对象里的宿主机和Volume名字，调用同一个Pod里的CSI插件的CSI Controller服务的ControllerPublishVolume方法，完成“Attach阶段”。</p><p>上述过程完成后，运行在宿主机A上的kubelet，就会通过VolumeManagerReconciler控制循环，发现当前宿主机上有一个Volume对应的存储设备（比如磁盘）已经被Attach到了某个设备目录下。于是kubelet就会调用同一台宿主机上的CSI插件的CSI Node服务的NodeStageVolume和NodePublishVolume方法，完成这个Volume的“Mount阶段”。</p><p>至此，一个完整的持久化Volume的创建和挂载流程就结束了。</p><h2>思考题</h2><p>请你根据编写FlexVolume和CSI插件的流程，分析一下什么时候该使用FlexVolume，什么时候应该使用CSI？</p><p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p>","comments":[{"had_liked":false,"id":235876,"user_name":"开心哥","can_delete":false,"product_type":"c1","uid":1705468,"ip_address":"","ucode":"D44C1F03B23C5A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/05/fc/bceb3f2b.jpg","comment_is_top":false,"comment_ctime":1595232500,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"143329153268","product_id":100015201,"comment_content":"果然是云原生技术，听的云里雾里。","like_count":33,"discussions":[{"author":{"id":2147220,"avatar":"https://static001.geekbang.org/account/avatar/00/20/c3/94/e89ebc50.jpg","nickname":"神毓逍遥","note":"","ucode":"83351CB18B190E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390968,"discussion_content":"文字太多，图太少，逻辑线展示的不清晰","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1630204187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488020,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","nickname":"追风筝的人","note":"","ucode":"2993D60F94C396","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536389,"discussion_content":"天书","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638776405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014285,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNv880TlsNuKaWcKbxiaAZTQIBWfJAddC8wfOROnwRPRwJXaEGSTBH2sic4jK7IGpxZn79tTDcREjw/132","nickname":"Geek_7482f6","note":"","ucode":"F3565F78525D30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591335,"discussion_content":"应用开发其实了解一下就好了，devops开发程序才需要详细了解并弄懂这部分的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666516192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488020,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","nickname":"追风筝的人","note":"","ucode":"2993D60F94C396","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536388,"discussion_content":"hh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638776396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625340,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","nickname":"骑着驴读着书的谢小夕","note":"","ucode":"56F0A469B630A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378267,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623135055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207457,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/a1/80d83f0a.jpg","nickname":"Ellison","note":"","ucode":"A2FB94D4F6A332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346317,"discussion_content":"哈哈啊哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611906652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151906,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1573810645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"139012764117","product_id":100015201,"comment_content":"flexVolume插件只负责attach和mount，使用简单。而CSI插件包括了一部分原来kubernetes中存储管理的功能，实现、部署起来比较复杂。所以，如果场景简单，不需要Dynamic Provisioning，则可以使用flexVolume；如果场景复杂，需要支持Dynamic Provisioning，则用CSI插件。","like_count":32},{"had_liked":false,"id":257305,"user_name":"ch_ort","can_delete":false,"product_type":"c1","uid":1580926,"ip_address":"","ucode":"B79746E687F29E","user_header":"","comment_is_top":false,"comment_ctime":1603934308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53143541860","product_id":100015201,"comment_content":"CSI的工作原理： 步骤分为存储插件注册、创建磁盘、挂载磁盘到虚拟机、挂载磁盘到Volume。其中<br><br>插件注册： Driver Register调用CSI的CSI Identify来完成注册，将插件注册到kubelet里面（这可以类比，将可执行文件放在插件目录下）。<br>存储创建：External Provisioner调用CSI的CSI Controller来创建PV和(远程)存储Volume，PV和PVC绑定之后，需要经过Attach和Mount这两阶段之后才能变成宿主机可用的Volume。所以，PV和PVC绑定之后，在Pod所在的宿主机上，执行Attach和Mount，即：<br><br>挂载磁盘到虚拟机： External Attacher调用CSI Controller来将新创建的存储卷挂载到虚拟机上（Attach）<br>格式化并挂载到Volume：k8s的Node节点调用CSI Node 将虚拟机上的存储卷格式化并挂载到容器的Volume上（Mount）<br><br>例：<br><br>当用户创建了一个PVC之后，External Provisioner会监听到这个PVC的诞生，然后调用同一个Pod里的CSI插件的CSI Controller服务的CreateVolume方法，为你创建出对应的PV。这时候，运行在Kubernetes Master节点上的Volume Controller就会通过PersistentVolumeController控制循环，发现这对新创建出来的PV和PVC，并且看到它们声明的是同一个StorageClass。所以，它会把这一对PV和PVC绑定，使PVC进入Bound状态。然后，用户创建一个声明使用上述PVC的Pod，并且这个Pod被调度到了宿主机A上，这时，Volume Controller的AttachDetachController控制循环就会发现，上述PVC对应的Volume，需要被Attach到宿主机A上。所以，AttachDetachController就会创建一个VolumeAttachment对象，这个对象携带了宿主机A和待处理的Volume名字。External  Attacher监听到VolumeAttachment对象的诞生。于是，它就会使用这个对象里的宿主机和Volume名字，调用同一个Pod里的CSI插件的CSI Controller服务的ControllerPublishVolume，完成Attach阶段。上述过程完成后，运行在宿主机A的kubelet，就会通过VolumeManagerReconciler控制循环，发现当前宿主机上有一个Volume对应的存储设备（比如磁盘）已经被Attach到了某个设备目录下。于是kubelet就会调用同一宿主机上的CSI插件的CSI Node服务的NodeStageVolume和NodePublishVolume完成这个Volume的“Mount阶段”。至此，一个完成的持久化Volume的创建和挂载就结束了。<br>","like_count":12},{"had_liked":false,"id":152189,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1573908194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53113515746","product_id":100015201,"comment_content":"老师对k8s的理解真心让人敬佩","like_count":12},{"had_liked":false,"id":37303,"user_name":"初学者","can_delete":false,"product_type":"c1","uid":1042833,"ip_address":"","ucode":"9471A905D07CE1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/91/4219d305.jpg","comment_is_top":false,"comment_ctime":1541526911,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"44491199871","product_id":100015201,"comment_content":"一般来说一个块存储在被宿主机使用之前，需要先将该块存储load 到宿主机的&#47;dev 下成为linux 的设备文件，然后format还设备文件，然后挂载到一个目录下就可以使用了，我觉得nodestagevolume这步挂载操作更像是为了同一台宿主机上的pod 可以共享一块盘","like_count":10},{"had_liked":false,"id":36548,"user_name":"DJH","can_delete":false,"product_type":"c1","uid":1256740,"ip_address":"","ucode":"2BDEF123B3DB6A","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/24/28acca15.jpg","comment_is_top":false,"comment_ctime":1541147278,"is_pvip":false,"replies":[{"id":"13043","content":"预处理完成前volume并不是可用的，直接挂载目的目录上显然太早了。","user_name":"作者回复","comment_id":36548,"uid":"1218095","ip_address":"","utype":1,"ctime":1541339355,"user_name_real":"Geek_6ef93d"}],"discussion_count":4,"race_medal":0,"score":"23015983758","product_id":100015201,"comment_content":"大师，请教一个问题：&quot;将Staging目录，绑定挂载到Volume对应的宿主机目录上&quot;这个绑定挂载是指mount -bind吗？ 为什么要挂载到一个临时目录，再绑定挂载Volume对应的宿主机目录上，而不是一步挂载到目标目录上？另外Staging目录具体是哪个目录？<br>谢谢！","like_count":5,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427906,"discussion_content":"预处理完成前volume并不是可用的，直接挂载目的目录上显然太早了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541339355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018611,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/f3/fc992148.jpg","nickname":"kitsdk","note":"","ucode":"A3570300D8A48C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574846,"discussion_content":"举个例子，linux增加一块盘即一个块设备比如/dev/vdb，这时候你能直接通过命令格式化mkfs.xfs /dev/vdb吗？答案是不能。你需要先分区初始化一个分区比如/dev/vdb1然后就可以mkfs.xfs /dev/vdb1了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654402262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1350159,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","nickname":"芒果少侠","note":"","ucode":"98D0BBB52BB80F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":197776,"discussion_content":"将目录暂存起来可能是为了最终挂载之前一些可扩展步骤。比如说用这个暂存的目录做一些别的事情，到时遇到了具体问题再进行分析即可。\n\nhttps://github.com/container-storage-interface/spec/blob/da3002f2908656e6387aa91d72ac77441900b974/spec.md\n这是CSI的NoticeStageVolumeRequest中的字段，推测是用于辅助开发者先暂存到该目录。后续可以基于该暂存目录继续进一步处理。\n\n其实，在这个digitalOcean的CSI插件例子中，完全可以在stagevolume步骤中不进行这步操作（只执行格式化），而在publishVolumn步骤中，再利用vol直接挂载即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583432317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218347,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLvdWoCic6ItzibF8ia8vrUTRuyj6AT3tg5f4QicIK0jTIFheJ6274ZkibuRLFP1NXG3jibv5TiaSKNoJpLw/132","nickname":"Geek_37984c","note":"","ucode":"7A319AE28599B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163256,"discussion_content":"为什么太早了？另外Staging目录具体是哪个目录？同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581065008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286192,"user_name":"朱东辉","can_delete":false,"product_type":"c1","uid":1983157,"ip_address":"","ucode":"D9EA5C37A1B386","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIh7iatqAeGsJuDNxsDlmCQx64ktJl7ATAkBtDO6iczIqsLFPXkF6GPGJpMBCxbl4DJ5obHwAK0bSAQ/132","comment_is_top":false,"comment_ctime":1617182888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18797052072","product_id":100015201,"comment_content":"张大佬真的天花板一样的存储，二刷依然收获满满，多谢大佬提供的这么好的学习资料","like_count":4},{"had_liked":false,"id":63180,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1548294073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14433195961","product_id":100015201,"comment_content":"找到了，文中有出现。是在 https:&#47;&#47;raw.githubusercontent.com&#47;digitalocean&#47;csi-digitalocean<br>","like_count":3},{"had_liked":false,"id":36827,"user_name":"silver","can_delete":false,"product_type":"c1","uid":1186740,"ip_address":"","ucode":"908E3C8560D6E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/1b/b4/a6db1c1e.jpg","comment_is_top":false,"comment_ctime":1541363328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14426265216","product_id":100015201,"comment_content":"块处理设备从挂载到staging，到挂载到宿主机目录具体做了哪些预处理呢？我和前面几位一样，对需要分两部挂载不是很理解","like_count":3},{"had_liked":false,"id":38618,"user_name":"车小勺的男神","can_delete":false,"product_type":"c1","uid":1285577,"ip_address":"","ucode":"6D5C959139D40B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJutT9JkFAcOk1JxOBdPuLgROpvcuxD9ROP9ACILAHITjcaYGNrZ5lHMZORYM6ibCuScDibYlgRvAIw/132","comment_is_top":false,"comment_ctime":1542086615,"is_pvip":false,"replies":[{"id":"13873","content":"可以啊 你搜下S3的Kubernetes 存储插件","user_name":"作者回复","comment_id":38618,"uid":"1218095","ip_address":"","utype":1,"ctime":1542122207,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"10132021207","product_id":100015201,"comment_content":"请教一下 能用对象存储来作为持久化存储么","like_count":2,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428758,"discussion_content":"可以啊 你搜下S3的Kubernetes 存储插件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542122207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339111,"user_name":"ryan","can_delete":false,"product_type":"c1","uid":1596005,"ip_address":"","ucode":"845DAC632BF51B","user_header":"https://static001.geekbang.org/account/avatar/00/18/5a/65/b80035a6.jpg","comment_is_top":false,"comment_ctime":1647920885,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5942888181","product_id":100015201,"comment_content":"好像看懂了，又好像没看懂","like_count":1},{"had_liked":false,"id":199944,"user_name":"Geek_f1b96b","can_delete":false,"product_type":"c1","uid":1940893,"ip_address":"","ucode":"9B05B56BEB0EA5","user_header":"","comment_is_top":false,"comment_ctime":1585504507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880471803","product_id":100015201,"comment_content":"老师，你好：  ControllerPublishVolume 这个方法是如何将 块设备map到node上的？ 它应该是external-attacher （deployment 或daemonset）中的方法，它和node中的哪个进程通信nodeplugin or kubelet？tks","like_count":1},{"had_liked":false,"id":172753,"user_name":"Podman","can_delete":false,"product_type":"c1","uid":1801003,"ip_address":"","ucode":"1C9C7EA8C28ED7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7b/2b/97e4d599.jpg","comment_is_top":false,"comment_ctime":1579273668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874240964","product_id":100015201,"comment_content":"请教一下，glusterfs+heketi+k8s实现的自动绑定PV的模式 我是否可以理解为与ceph+rook+k8s模式一致？CSI实现的自定义存储插件与rook的角色有何不同？glusterfs+heketi+k8s的架构是不是也可以通过CSI来实现？","like_count":1},{"had_liked":false,"id":47356,"user_name":"Alery","can_delete":false,"product_type":"c1","uid":1156557,"ip_address":"","ucode":"08F3F49181E67B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/cd/3aff5d57.jpg","comment_is_top":false,"comment_ctime":1544113336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5839080632","product_id":100015201,"comment_content":"对于文件系统类型的存储服务，例如: NFS，它并没有对一个的磁盘设备存在与宿主机上，有些nfs类型的csi driver上并没有实现ControllerPublishVolume这个操作，是不是可以理解这里nfs存储卷的attach阶段只是创建了VolumeAttachment对象，并不需要通过ControllerPublishVolume完成nfs volume挂载到虚拟机上？","like_count":1},{"had_liked":false,"id":36660,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1541222943,"is_pvip":false,"replies":[{"id":"13038","content":"csi自己有一套types.go，这跟kubernetes已经没关系了","user_name":"作者回复","comment_id":36660,"uid":"1218095","ip_address":"","utype":1,"ctime":1541338885,"user_name_real":"Geek_6ef93d"}],"discussion_count":2,"race_medal":0,"score":"5836190239","product_id":100015201,"comment_content":"请问在上一节里提到 “ CSI 的 api 不会直接使用 Kubernetes 定义的 PV 类型， 而是会自己定义一个单独的 volume 类型。 这个在digitalocean csi 里具体体现是什么？是一个cdr吗，我好像没找到。","like_count":1,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427960,"discussion_content":"csi自己有一套types.go，这跟kubernetes已经没关系了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541338885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1904954,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoGJtWol6dEq1uIZ9lEAc0WH7MFdlKFe3tYVNyl3ibfIXcMGS7XS85mDTbIY30JticsydYtLDhM9kIw/132","nickname":"大漠狂潮","note":"","ucode":"C3A589B82A35BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215173,"discussion_content":"请问老师，用k8s + rook + ceph 来搭建一个海量的图片、视频的存储服务器可行吗？不想用hadoop hdfs 那一套","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585295791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36655,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1541220026,"is_pvip":false,"replies":[{"id":"13042","content":"块存储设备不经过预处理就能直接挂载使用的情况，我还真想不出来。","user_name":"作者回复","comment_id":36655,"uid":"1218095","ip_address":"","utype":1,"ctime":1541339214,"user_name_real":"Geek_6ef93d"}],"discussion_count":3,"race_medal":0,"score":"5836187322","product_id":100015201,"comment_content":"DJH 竟然和我的问题一模一样，握手！<br>为什么不直接把设备挂载到 volume宿主机目录？在pv&#47;pvc到底讲什么那么一节里就是这么讲的。<br>在这里有什么特殊的考虑吗？<br>","like_count":1,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427958,"discussion_content":"块存储设备不经过预处理就能直接挂载使用的情况，我还真想不出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541339214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51083,"discussion_content":"块设备肯定要先经过格式化，构建文件系统的，才能再去挂载啊，所以预处理这一步不能省略","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573808951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4e/36/de029ebf.jpg","nickname":"🐬Innocence","note":"","ucode":"7CBAB4976FACE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273109,"discussion_content":"还是不是很理解，设备路径应该是类似于/dev/disk1这路径，经过格式化成指定格式后，应该是可以直接挂在到对应的目录上的？求指教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590412282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360595,"user_name":"🍊 🐱","can_delete":false,"product_type":"c1","uid":3207939,"ip_address":"北京","ucode":"D73A27E7427D7C","user_header":"https://static001.geekbang.org/account/avatar/00/30/f3/03/24a0e652.jpg","comment_is_top":false,"comment_ctime":1666679342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666679342","product_id":100015201,"comment_content":"有的同学跟我有一样的疑惑，就是 staging 这一步为什么需要再格式化后挂载到一个临时目录，而不是直接留给 publish 阶段挂在到 pod 中，根据作者给其他小伙伴的回复和我阅读 sample 代码的理解如下：kubelet 的 VolumeManagerReconciler 分两步 mount 的原因是假如直接一步 format 的过程非常久，可能会导致 reconciler 阻塞，而分开两步可以解决这个问题，另外在第一步 staging 后挂载到临时目录（由 req 获取）的目的是方便 reconciler 判断 volum（通过传给第一步 req 的临时目录） 是否 format 完毕，可以进入第二步挂载到 pod 中。如果理解错了还希望作者指出。","like_count":0},{"had_liked":false,"id":360267,"user_name":"linyy","can_delete":false,"product_type":"c1","uid":1198286,"ip_address":"上海","ucode":"F54A20D17DD5DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/ce/9978ed21.jpg","comment_is_top":false,"comment_ctime":1666356214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666356214","product_id":100015201,"comment_content":"老师问下 存储插件本身的高可用怎么处理呢","like_count":0},{"had_liked":false,"id":348238,"user_name":"Double f","can_delete":false,"product_type":"c1","uid":2750411,"ip_address":"","ucode":"C4DCFDF0A9CA36","user_header":"https://static001.geekbang.org/account/avatar/00/29/f7/cb/771876e5.jpg","comment_is_top":false,"comment_ctime":1654856757,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654856757","product_id":100015201,"comment_content":"一章看了4遍，感觉每一遍收获都不一样，感谢大师","like_count":0},{"had_liked":false,"id":344610,"user_name":"怀揣梦想的学渣","can_delete":false,"product_type":"c1","uid":1916685,"ip_address":"","ucode":"2349B9F4F6FDE3","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3f/0d/1e8dbb2c.jpg","comment_is_top":false,"comment_ctime":1651669737,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651669737","product_id":100015201,"comment_content":"有种需要补Go lang基础知识的感受","like_count":0},{"had_liked":false,"id":324999,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1638776342,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1638776342","product_id":100015201,"comment_content":"懵逼了  天书          只有之前的namespace, cgroups,rootfs 听明白了","like_count":0,"discussions":[{"author":{"id":2850687,"avatar":"","nickname":"Geek_3635b2","note":"","ucode":"46674380343EEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585635,"discussion_content":"这两节，放弃了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661740767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322091,"user_name":"Wall-Eve","can_delete":false,"product_type":"c1","uid":2108027,"ip_address":"","ucode":"FBF2FED8F13BD3","user_header":"https://static001.geekbang.org/account/avatar/00/20/2a/7b/2092e1fd.jpg","comment_is_top":false,"comment_ctime":1637161991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637161991","product_id":100015201,"comment_content":"请问对于生产集群当中in-tree和out-of-tree类型的存储方式更为适合","like_count":0},{"had_liked":false,"id":312398,"user_name":"kissrain","can_delete":false,"product_type":"c1","uid":1120583,"ip_address":"","ucode":"2177C53E3B2DCC","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/47/b27f1314.jpg","comment_is_top":false,"comment_ctime":1631785606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631785606","product_id":100015201,"comment_content":"看了好几遍，进过实践终于看懂了","like_count":0},{"had_liked":false,"id":279006,"user_name":"zlel","can_delete":false,"product_type":"c1","uid":2139471,"ip_address":"","ucode":"D98D44B933D6D5","user_header":"https://static001.geekbang.org/account/avatar/00/20/a5/4f/772dd0f3.jpg","comment_is_top":false,"comment_ctime":1613538702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613538702","product_id":100015201,"comment_content":"① 创建PVC &lt;--监听-- External Provisioner --调用 --&gt; CSI Controller(CreateVolume) --&gt; 创建PV<br>② PVC&amp;PV状态 &lt;--观察-- Volume Controller(PersistentVolumeController) --&gt;绑定PVC&amp;PV<br>③ 创建Pod(使用PVC) --&gt; 调度Pod &lt;--观察PVC Volume-- Volume Controller(AttachDetachController)  --&gt; 创建VolumeAttachment(含有Pod被调度Node和PVC Volume)  &lt;--监听-- External Attacher --调用--&gt; CSI Controller(ControllerPublishVolume) --&gt; Node Attach Volume<br>④ Node Attach Volume的设备目录 &lt;--观察-- kubelet(VolumeManagerReconciler) --调用--&gt; CSI Node(NodeStageVolume) --&gt; 格式化Attach设备 --&gt; CSI Node(NodePublishVolume) --&gt; Mount到Node的指定目录","like_count":0},{"had_liked":false,"id":272001,"user_name":"小寞子。(≥3≤)","can_delete":false,"product_type":"c1","uid":1206545,"ip_address":"","ucode":"6D978BDCBB2862","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/11/831cec7d.jpg","comment_is_top":false,"comment_ctime":1609905357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609905357","product_id":100015201,"comment_content":"不知道2021年这一套是否还这样。 我手上有个openshift的cluster 里面的实现好像并不太一样  ","like_count":0},{"had_liked":false,"id":245695,"user_name":"Geek_da8747","can_delete":false,"product_type":"c1","uid":2106619,"ip_address":"","ucode":"992F8F92664386","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIvc0wApgEPKZu9SqlyGcrj2l42bJezgicKficl7kaBA8MJx6Cbcl92YqVJ1BTTdibR9gcbrtqjpKskA/132","comment_is_top":false,"comment_ctime":1599028970,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599028970","product_id":100015201,"comment_content":"请教一个问题，当我创建完StorageClass、PVC、Pod之后，我的CSI插件没有调用ControllerServer的CreateVolume。<br>identityserver的GetPluginCapabilities中使用了 PluginCapability_Service_CONTROLLER_SERVICE<br>并且也在适当的位置声明了ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME<br>边车也没有出现问题<br>还有什么原因能产生这个问题？","like_count":0},{"had_liked":false,"id":230899,"user_name":"Mr.Brooks","can_delete":false,"product_type":"c1","uid":1118650,"ip_address":"","ucode":"D47A6B0236A79F","user_header":"https://static001.geekbang.org/account/avatar/00/11/11/ba/2175bc50.jpg","comment_is_top":false,"comment_ctime":1593518532,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1593518532","product_id":100015201,"comment_content":"external provisioner是以sidecar的方式部署在worker node上的pod吧？ 那么当有一个PVC出现的时候，是谁决定用哪一个node上的provisioner呢？","like_count":0,"discussions":[{"author":{"id":1207457,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/a1/80d83f0a.jpg","nickname":"Ellison","note":"","ucode":"A2FB94D4F6A332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346320,"discussion_content":"预选和优选调度的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611906704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207457,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/a1/80d83f0a.jpg","nickname":"Ellison","note":"","ucode":"A2FB94D4F6A332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346319,"discussion_content":"schduler啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611906692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184219,"user_name":"胖达","can_delete":false,"product_type":"c1","uid":1348090,"ip_address":"","ucode":"84E23DB84F258A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIwWPicOxyL0sIVicLOcFI5IIEkffn56gOzRWfFY6exEmUUbxPicHyWC579SM6jga3oxcLzRibGHoA9Qw/132","comment_is_top":false,"comment_ctime":1583248613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583248613","product_id":100015201,"comment_content":"老师，请教下NodePublishVolume可以从请求参数中获取namespaces等信息么","like_count":0},{"had_liked":false,"id":115309,"user_name":"数字记忆","can_delete":false,"product_type":"c1","uid":1227797,"ip_address":"","ucode":"26E16F65F559A1","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/15/23ce17f9.jpg","comment_is_top":false,"comment_ctime":1563529250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563529250","product_id":100015201,"comment_content":"写的太好了","like_count":0},{"had_liked":false,"id":61065,"user_name":"JZY","can_delete":false,"product_type":"c1","uid":1228072,"ip_address":"","ucode":"6115708DAB8E33","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/28/df2b8cee.jpg","comment_is_top":false,"comment_ctime":1547610701,"is_pvip":false,"replies":[{"id":"22064","content":"文中已经给出了啊","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1548053733,"ip_address":"","comment_id":61065,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547610701","product_id":100015201,"comment_content":"请问哪里有完整的示例呢，我看文中有部分是...省略的","like_count":0,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436730,"discussion_content":"文中已经给出了啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548053733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38807,"user_name":"车小勺的男神","can_delete":false,"product_type":"c1","uid":1285577,"ip_address":"","ucode":"6D5C959139D40B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJutT9JkFAcOk1JxOBdPuLgROpvcuxD9ROP9ACILAHITjcaYGNrZ5lHMZORYM6ibCuScDibYlgRvAIw/132","comment_is_top":false,"comment_ctime":1542131639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542131639","product_id":100015201,"comment_content":"s3的存储插件大多是通过s3fs这类的工具实现的，请问s3可以直接用做持久化存储嘛","like_count":0},{"had_liked":false,"id":37169,"user_name":"圣诞使者","can_delete":false,"product_type":"c1","uid":1028183,"ip_address":"","ucode":"E59436F6392122","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b0/57/a84d633e.jpg","comment_is_top":false,"comment_ctime":1541471924,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1541471924","product_id":100015201,"comment_content":"看了别人的评论，我也不是很懂这个 NodeStageVolume，NodePublishVolume 这个两阶段处理，我下载了 digitalocean 的源码，看到这个句话 driver&#47;node.go (200)： #Perform a bind mount to the full path to allow duplicate mounts of the same PD，感觉NodePublishVolume主要就是这个作用，PD没理解什么意思，猜测是physical driver。还请老师解惑。","like_count":0,"discussions":[{"author":{"id":1227797,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/15/23ce17f9.jpg","nickname":"数字记忆","note":"","ucode":"26E16F65F559A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2385,"discussion_content":"NodeStageVolume是将块设备从远端挂载到本地，NodePublishVolume是将挂载到本地并格式化后的盘挂载绑定到容器的目录上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563529392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36672,"user_name":"每日都想上班","can_delete":false,"product_type":"c1","uid":1060466,"ip_address":"","ucode":"1DE64120C8B14A","user_header":"https://static001.geekbang.org/account/avatar/00/10/2e/72/145c10db.jpg","comment_is_top":false,"comment_ctime":1541227733,"is_pvip":false,"replies":[{"id":"13041","content":"见service部分。","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1541339157,"ip_address":"","comment_id":36672,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541227733","product_id":100015201,"comment_content":"有个问题：service后挂载多个pod，service的调度是轮询的还是怎么样的呢","like_count":0,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427963,"discussion_content":"见service部分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541339157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}