{"id":84017,"title":"02 | Java内存模型：看Java如何解决可见性和有序性问题","content":"<p>上一期我们讲到在并发场景中，因可见性、原子性、有序性导致的问题常常会违背我们的直觉，从而成为并发编程的Bug之源。这三者在编程领域属于共性问题，所有的编程语言都会遇到，Java在诞生之初就支持多线程，自然也有针对这三者的技术方案，而且在编程语言领域处于领先地位。理解Java解决并发问题的解决方案，对于理解其他语言的解决方案有触类旁通的效果。</p><p>那我们就先来聊聊如何解决其中的可见性和有序性导致的问题，这也就引出来了今天的主角——<strong>Java内存模型</strong>。</p><p>Java内存模型这个概念，在职场的很多面试中都会考核到，是一个热门的考点，也是一个人并发水平的具体体现。原因是当并发程序出问题时，需要一行一行地检查代码，这个时候，只有掌握Java内存模型，才能慧眼如炬地发现问题。</p><h2>什么是Java内存模型？</h2><p>你已经知道，导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong>，但是这样问题虽然解决了，我们程序的性能可就堪忧了。</p><p>合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>。那么，如何做到“按需禁用”呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。</p><!-- [[[read_end]]] --><p>Java内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final </strong>三个关键字，以及六项 <strong>Happens-Before 规则</strong>，这也正是本期的重点内容。</p><h2>使用volatile的困惑</h2><p>volatile关键字并不是Java语言的特产，古老的C语言里也有，它最原始的意义就是禁用CPU缓存。</p><p>例如，我们声明一个volatile变量 <code>volatile int x = 0</code>，它表达的是：告诉编译器，对这个变量的读写，不能使用CPU缓存，必须从内存中读取或者写入。这个语义看上去相当明确，但是在实际使用的时候却会带来困惑。</p><p>例如下面的示例代码，假设线程A执行writer()方法，按照 volatile 语义，会把变量 “v=true” 写入内存；假设线程B执行reader()方法，同样按照 volatile 语义，线程B会从内存中读取变量v，如果线程B看到 “v == true” 时，那么线程B看到的变量x是多少呢？</p><p>直觉上看，应该是42，那实际应该是多少呢？这个要看Java的版本，如果在低于1.5版本上运行，x可能是42，也有可能是0；如果在1.5以上的版本上运行，x就是等于42。</p><pre><code>// 以下代码来源于【参考1】\nclass VolatileExample {\n  int x = 0;\n  volatile boolean v = false;\n  public void writer() {\n    x = 42;\n    v = true;\n  }\n  public void reader() {\n    if (v == true) {\n      // 这里x会是多少呢？\n    }\n  }\n}\n</code></pre><p>分析一下，为什么1.5以前的版本会出现x = 0的情况呢？我相信你一定想到了，变量x可能被CPU缓存而导致可见性问题。这个问题在1.5版本已经被圆满解决了。Java内存模型在1.5版本对volatile语义进行了增强。怎么增强的呢？答案是一项 Happens-Before 规则。</p><h2>Happens-Before 规则</h2><p>如何理解 Happens-Before 呢？如果望文生义（很多网文也都爱按字面意思翻译成“先行发生”），那就南辕北辙了，Happens-Before 并不是说前面一个操作发生在后续操作的前面，它真正要表达的是：<strong>前面一个操作的结果对后续操作是可见的</strong>。就像有心灵感应的两个人，虽然远隔千里，一个人心之所想，另一个人都看得到。Happens-Before 规则就是要保证线程之间的这种“心灵感应”。所以比较正式的说法是：Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。</p><p>Happens-Before 规则应该是Java内存模型里面最晦涩的内容了，和程序员相关的规则一共有如下六项，都是关于可见性的。</p><p>恰好前面示例代码涉及到这六项规则中的前三项，为便于你理解，我也会分析上面的示例代码，来看看规则1、2和3到底该如何理解。至于其他三项，我也会结合其他例子作以说明。</p><h3>1. 程序的顺序性规则</h3><p>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。这还是比较容易理解的，比如刚才那段示例代码，按照程序的顺序，第6行代码 “x = 42;” Happens-Before 于第7行代码 “v = true;”，这就是规则1的内容，也比较符合单线程里面的思维：程序前面对某个变量的修改一定是对后续操作可见的。</p><p><span class=\"orange\">（为方便你查看，我将那段示例代码在这儿再呈现一遍）</span></p><pre><code>// 以下代码来源于【参考1】\nclass VolatileExample {\n  int x = 0;\n  volatile boolean v = false;\n  public void writer() {\n    x = 42;\n    v = true;\n  }\n  public void reader() {\n    if (v == true) {\n      // 这里x会是多少呢？\n    }\n  }\n}\n</code></pre><h3>2. volatile变量规则</h3><p>这条规则是指对一个volatile变量的写操作， Happens-Before 于后续对这个volatile变量的读操作。</p><p>这个就有点费解了，对一个volatile变量的写操作相对于后续对这个volatile变量的读操作可见，这怎么看都是禁用缓存的意思啊，貌似和1.5版本以前的语义没有变化啊？如果单看这个规则，的确是这样，但是如果我们关联一下规则3，就有点不一样的感觉了。</p><h3>3. 传递性</h3><p>这条规则是指如果A Happens-Before B，且B Happens-Before C，那么A Happens-Before C。</p><p>我们将规则3的传递性应用到我们的例子中，会发生什么呢？可以看下面这幅图：</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/e1/b1fa541e98c74bc2a033d9ac5ae7fbe1.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">示例代码中的传递性规则</span></center><p>从图中，我们可以看到：</p><ol>\n<li>“x=42” Happens-Before 写变量 “v=true” ，这是规则1的内容；</li>\n<li>写变量“v=true” Happens-Before 读变量 “v=true”，这是规则2的内容 。</li>\n</ol><p>再根据这个传递性规则，我们得到结果：“x=42” Happens-Before 读变量“v=true”。这意味着什么呢？</p><p>如果线程B读到了“v=true”，那么线程A设置的“x=42”对线程B是可见的。也就是说，线程B能看到 “x == 42” ，有没有一种恍然大悟的感觉？这就是1.5版本对volatile语义的增强，这个增强意义重大，1.5版本的并发工具包（java.util.concurrent）就是靠volatile语义来搞定可见性的，这个在后面的内容中会详细介绍。</p><h3>4. 管程中锁的规则</h3><p>这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p><p>要理解这个规则，就首先要了解“管程指的是什么”。<strong>管程</strong>是一种通用的同步原语，在Java中指的就是synchronized，synchronized是Java里对管程的实现。</p><p>管程中的锁在Java里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。</p><pre><code>synchronized (this) { //此处自动加锁\n  // x是共享变量,初始值=10\n  if (this.x &lt; 12) {\n    this.x = 12; \n  }  \n} //此处自动解锁\n</code></pre><p>所以结合规则4——管程中锁的规则，可以这样理解：假设x的初始值是10，线程A执行完代码块后x的值会变成12（执行完自动释放锁），线程B进入代码块时，能够看到线程A对x的写操作，也就是线程B能够看到x==12。这个也是符合我们直觉的，应该不难理解。</p><h3>5. 线程 start() 规则</h3><p>这条是关于线程启动的。它是指主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作。</p><p>换句话说就是，如果线程A调用线程B的 start() 方法（即在线程A中启动线程B），那么该start()操作 Happens-Before 于线程B中的任意操作。具体可参考下面示例代码。</p><pre><code>Thread B = new Thread(()-&gt;{\n  // 主线程调用B.start()之前\n  // 所有对共享变量的修改，此处皆可见\n  // 此例中，var==77\n});\n// 此处对共享变量var修改\nvar = 77;\n// 主线程启动子线程\nB.start();\n</code></pre><h3>6. 线程 join() 规则</h3><p>这条是关于线程等待的。它是指主线程A等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join()方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对<strong>共享变量</strong>的操作。</p><p>换句话说就是，如果在线程A中，调用线程B的 join() 并成功返回，那么线程B中的任意操作Happens-Before 于该 join() 操作的返回。具体可参考下面示例代码。</p><pre><code>Thread B = new Thread(()-&gt;{\n  // 此处对共享变量var修改\n  var = 66;\n});\n// 例如此处对共享变量修改，\n// 则这个修改结果对线程B可见\n// 主线程启动子线程\nB.start();\nB.join()\n// 子线程所有对共享变量的修改\n// 在主线程调用B.join()之后皆可见\n// 此例中，var==66\n</code></pre><h2>被我们忽视的final</h2><p>前面我们讲volatile为的是禁用缓存以及编译优化，我们再从另外一个方面来看，有没有办法告诉编译器优化得更好一点呢？这个可以有，就是<strong>final关键字</strong>。</p><p><strong>final修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。</strong>Java编译器在1.5以前的版本的确优化得很努力，以至于都优化错了。</p><p>问题类似于上一期提到的利用双重检查方法创建单例，构造函数的错误重排导致线程可能看到final变量的值会变化。详细的案例可以参考<a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong\">这个文档</a>。</p><p>当然了，在1.5以后Java内存模型对final类型变量的重排进行了约束。现在只要我们提供正确构造函数没有“逸出”，就不会出问题了。</p><p>“逸出”有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将this赋值给了全局变量global.obj，这就是“逸出”，线程通过global.obj读取x是有可能读到0的。因此我们一定要避免“逸出”。</p><pre><code>// 以下代码来源于【参考1】\nfinal int x;\n// 错误的构造函数\npublic FinalFieldExample() { \n  x = 3;\n  y = 4;\n  // 此处就是讲this逸出，\n  global.obj = this;\n}\n</code></pre><h2>总结</h2><p>Java的内存模型是并发编程领域的一次重要创新，之后C++、C#、Golang等高级语言都开始支持内存模型。Java内存模型里面，最晦涩的部分就是Happens-Before规则了，Happens-Before规则最初是在一篇叫做<strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong>的论文中提出来的，在这篇论文中，Happens-Before的语义是一种因果关系。在现实世界里，如果A事件是导致B事件的起因，那么A事件一定是先于（Happens-Before）B事件发生的，这个就是Happens-Before语义的现实理解。</p><p>在Java语言里面，Happens-Before的语义本质上是一种可见性，A Happens-Before B 意味着A事件对B事件来说是可见的，无论A事件和B事件是否发生在同一个线程里。例如A事件发生在线程1上，B事件发生在线程2上，Happens-Before规则保证线程2上也能看到A事件的发生。</p><p>Java内存模型主要分为两部分，一部分面向你我这种编写并发程序的应用开发人员，另一部分是面向JVM的实现人员的，我们可以重点关注前者，也就是和编写并发程序相关的部分，这部分内容的核心就是Happens-Before规则。相信经过本章的介绍，你应该对这部分内容已经有了深入的认识。</p><h2>课后思考</h2><p>有一个共享变量 abc，在一个线程里设置了abc的值 <code>abc=3</code>，你思考一下，有哪些办法可以让其他线程能够看到<code>abc==3</code>？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><h2>参考</h2><ol>\n<li><a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html\">JSR 133 (Java Memory Model) FAQ</a></li>\n<li><a href=\"http://ifeve.com/jmm-faq/\">Java内存模型FAQ</a></li>\n<li><a href=\"https://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf\">JSR-133: Java<sup>TM</sup> Memory Model and Thread Specification</a></li>\n</ol><p></p>","comments":[{"had_liked":false,"id":72054,"user_name":"Healtheon","can_delete":false,"product_type":"c1","uid":1206751,"ip_address":"","ucode":"B564B1FC4456E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","comment_is_top":false,"comment_ctime":1551508339,"is_pvip":false,"replies":[{"id":"26106","content":"厉害厉害！！！","user_name":"作者回复","comment_id":72054,"uid":"1269969","ip_address":"","utype":1,"ctime":1551522887,"user_name_real":"王宝令"}],"discussion_count":31,"race_medal":0,"score":"4086065406835","product_id":100023901,"comment_content":"老师，还差两个规则，分别是：<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。<br>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。<br><br>所以，个人对于Java内存模型总结起来就是：<br>1. 为什么定义Java内存模型？现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。<br>2. 三个基本原则：原子性、可见性、有序性。<br>3. Java内存模型涉及的几个关键词：锁、volatile字段、final修饰符与对象的安全发布。其中：第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。<br>4. Happens-Before的7个规则：<br>\t(1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。<br>\t(2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而&quot;后面&quot;是指时间上的先后顺序。<br>\t(3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的&quot;后面&quot;同样是指时间上的先后顺序。<br>\t(4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。<br>\t(5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。<br>\t(6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。<br>\t(7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。<br>5. Happens-Before的1个特性：传递性。<br>6. Java内存模型底层怎么实现的？主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。","like_count":952,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441440,"discussion_content":"厉害厉害！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551522887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2286802,"avatar":"","nickname":"Geek_072f8a","note":"","ucode":"830D4594E19D45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320863,"discussion_content":"这好像是抄的深入java虚拟机里面的","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1604493196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581294,"avatar":"","nickname":"Geek_be4cec","note":"","ucode":"C87642D655EAC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3413,"discussion_content":"讲的没有老师讲的清楚、易懂。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1564469152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1275497,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNDbT0BpwkVNAuCWeRoibnvT2xoItdPv8I1ITzpCu8JFibSXVYGDeGwScDxtOJSDib4f8kHPoJHiaOKg/132","nickname":"鲲之大","note":"","ucode":"FF99A15F644261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1798,"discussion_content":"interrupt() 用于中断另一个线程\nisInterrupted()，用来判断当前线程的中断状态(true or false)。\ninterrupted()是个Thread的static方法，用来恢复中断状态。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1562916397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1488931,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b8/23/85c7911c.jpg","nickname":"天斓海琼","note":"","ucode":"0BD579B063C72C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1275497,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNDbT0BpwkVNAuCWeRoibnvT2xoItdPv8I1ITzpCu8JFibSXVYGDeGwScDxtOJSDib4f8kHPoJHiaOKg/132","nickname":"鲲之大","note":"","ucode":"FF99A15F644261","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541331,"discussion_content":"确实是，看了底层代码才知道的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640334230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1798,"ip_address":""},"score":541331,"extra":""}]},{"author":{"id":1181913,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/d9/6e0ee07f.jpg","nickname":"xiaoli","note":"","ucode":"49B5F1BD2B723A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311976,"discussion_content":"明显比某老师讲的好多了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602554653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1654600,"avatar":"","nickname":"xanxus","note":"","ucode":"FFF1EFD2ABCBAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179935,"discussion_content":"处理器的乱序应该是处理的不同指令处理时间长短不一样，为了最大限度提高处理器流水线的性能，处理器对指令做了一定程度的指令重排","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582262495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2761427,"avatar":"","nickname":"Geek_b5b334","note":"","ucode":"AACE658AC4CBA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394592,"discussion_content":"mark一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631951058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207153,"avatar":"","nickname":"liulei3","note":"","ucode":"C869F663AF4B42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347644,"discussion_content":"赞 感觉比作者梳理的好","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612271940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286672,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/10/c2efb5ac.jpg","nickname":"张金帅","note":"","ucode":"6A2A2B0226B287","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1207153,"avatar":"","nickname":"liulei3","note":"","ucode":"C869F663AF4B42","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365180,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617721495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":347644,"ip_address":""},"score":365180,"extra":""}]},{"author":{"id":2029485,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","nickname":"数学汤家凤","note":"","ucode":"DE84E777C384AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289959,"discussion_content":"mark","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594281576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2057627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c38aFXkgKzcaEnz56Zyib5yE88NvzKrnYpJFTe9aodn0cXR2CwA1vs1sP7luwFHeSXuoJlreBtkq3YAFPlmibdibw/132","nickname":"Geek_9ad555","note":"","ucode":"50852723A22788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2029485,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","nickname":"数学汤家凤","note":"","ucode":"DE84E777C384AD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":290640,"discussion_content":"你也在啊，架构群看到你了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594556193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289959,"ip_address":""},"score":290640,"extra":""}]},{"author":{"id":1196339,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/33/d1064f9a.jpg","nickname":"Sun","note":"","ucode":"1BC2741DC07FC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198832,"discussion_content":"你好，请问是只有volatile这种底层使用内存屏障（jvm层级）和lock指令（os层级），还是所有的happens-before规则都使用内存屏障和lock指令来保证可见性和有序性？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583516394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1440025,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f9/19/7c3b12ee.jpg","nickname":"Geek_deb968","note":"","ucode":"2305597B009AF3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1196339,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/33/d1064f9a.jpg","nickname":"Sun","note":"","ucode":"1BC2741DC07FC5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302167,"discussion_content":"屏障这个词真好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598803712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198832,"ip_address":""},"score":302167,"extra":""}]},{"author":{"id":1096652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","nickname":"xxx","note":"","ucode":"E79CEA70430449","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124185,"discussion_content":"happens before 被你译为 先行发生，而老师说的是这样理解有问题，应理解为前者对后者可见。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578411918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1206751,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","nickname":"Healtheon","note":"","ucode":"B564B1FC4456E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1096652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","nickname":"xxx","note":"","ucode":"E79CEA70430449","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":134250,"discussion_content":"你再看看文中的总结部分。不做争论，自己感悟即可。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579013625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":124185,"ip_address":""},"score":134250,"extra":""},{"author":{"id":2410444,"avatar":"https://static001.geekbang.org/account/avatar/00/24/c7/cc/92a3ef15.jpg","nickname":"桔橘橙辣，","note":"","ucode":"A0E5BE7852CA09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1096652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","nickname":"xxx","note":"","ucode":"E79CEA70430449","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":340998,"discussion_content":"我觉得也是，老师讲的这种，前面的操作产生的影响对后续操作是可见的很好理解，说成先行发生是有问题的，happens-before解决的问题就是有序性和可见性，并不是强调发生的先后顺序，而是操作结果的影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610255811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":124185,"ip_address":""},"score":340998,"extra":""}]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5493,"discussion_content":"总结的真棒，学习了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566305513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1392431,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","nickname":"a(๑≖ิټ≖ิ)✌","note":"","ucode":"AEF9B5CA1605DF","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365,"discussion_content":"你的第四条线程启动规则和老师的线程start规则讲的完全不一样，老师的join规则你总结的里面没有，为什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561491175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1282575,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/0f/cff30522.jpg","nickname":"江湖夜雨","note":"","ucode":"C64913C7000899","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1392431,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","nickname":"a(๑≖ิټ≖ิ)✌","note":"","ucode":"AEF9B5CA1605DF","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":2336,"discussion_content":"这么理解，A.start之前操作在B线程中可见","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563496612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365,"ip_address":""},"score":2336,"extra":""}]},{"author":{"id":2459923,"avatar":"https://static001.geekbang.org/account/avatar/00/25/89/13/0d3c5008.jpg","nickname":"最好不过","note":"","ucode":"C7DBCD08402DF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387567,"discussion_content":"先后发生顺序有问题，还是老师讲的前面的操作对后面可见这个准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628256252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2637531,"avatar":"https://static001.geekbang.org/account/avatar/00/28/3e/db/a6478127.jpg","nickname":"无问西东","note":"","ucode":"905A4CBF0AC944","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379215,"discussion_content":"java内存模型 CY","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623757341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e8/32/f44f163e.jpg","nickname":"海涛","note":"","ucode":"02B0E09EE84868","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378534,"discussion_content":"学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623279505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1167120,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/10/9fa2e5ba.jpg","nickname":"进击的巨人","note":"","ucode":"DB62D77D460BF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345530,"discussion_content":"程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。这句话的准确性有待商榷","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611735959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136480,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/60/65b006a6.jpg","nickname":"Chief","note":"","ucode":"CAFB24CBA215A8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341158,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610333309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120997,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","nickname":"favorlm","note":"","ucode":"CFD52127AA6E1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340123,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609908409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2067031,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIGGBhiaUAJpeBxmzQCVrSiboPfwUSTOzcibaokLuxtG0IuibIH8ED6nK8Heicm0L7GI1W6W7SU0S0FwOg/132","nickname":"炎霏","note":"","ucode":"D77DDEF3DA68B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296907,"discussion_content":"mark一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596702417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214578,"discussion_content":"你字多，厉害大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585210384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125986,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2e/62/ea49480e.jpg","nickname":"Zain Zhu","note":"","ucode":"5402E6FF76333A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211511,"discussion_content":"厉害啊！这些知识在什么类型的工作中会经常用到呢？如果一般工作中不会直接涉及到，那自己学习的话要以什么样的方式去练习巩固呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584859844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338584,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6c/d8/68fec932.jpg","nickname":"花花young","note":"","ucode":"95AD30303C2B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63774,"discussion_content":"66666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574909159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33658,"discussion_content":"厉害厉害，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571139729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71882,"user_name":"senekis","can_delete":false,"product_type":"c1","uid":1446025,"ip_address":"","ucode":"CD88681F0278FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erTlRJ6skf7iawAeqNfIT1PPgjD7swUdRIRkX1iczjj97GNrxnsnn3QuOhkVbCLgFYAm7sMZficNTSbA/132","comment_is_top":false,"comment_ctime":1551460297,"is_pvip":true,"replies":[{"id":"26082","content":"这三种方式都正确，理解的不错！","user_name":"作者回复","comment_id":71882,"uid":"1269969","ip_address":"","utype":1,"ctime":1551519783,"user_name_real":"王宝令"}],"discussion_count":10,"race_medal":0,"score":"929264396233","product_id":100023901,"comment_content":"<br>我思考下认为有三种方式可以实现:<br>1.声明共享变量abc，并使用volatile关键字修饰abc<br>2.声明共享变量abc，在synchronized关键字对abc的赋值代码块加锁，由于Happen-before管程锁的规则，可以使得后续的线程可以看到abc的值。<br>3.A线程启动后，使用A.JOIN()方法来完成运行，后续线程再启动，则一定可以看到abc==3<br><br>如有错误，请给指出错误所在！谢谢大家！谢谢老师！<br><br>听课后感觉对我帮助好大，以前零碎的知识被重新系统的整理。错误的理解也得到修正，感谢老师！","like_count":216,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441376,"discussion_content":"这三种方式都正确，理解的不错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551519783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227252,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b9/f4/cc519a9f.jpg","nickname":"お金💪","note":"","ucode":"210C44553ABFDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304914,"discussion_content":"第二点不对吧，对abc赋值的线程代码块加锁，其他线程读的时候还是得不到最新值，锁规则应该针对的是同一个代码，同一个代码多个不同线程执行时的Happends-Before规则。\n比如：\npublic class HappensBeforeMain {\n\n    private static int num = 0;\n\n    public static void main(String[] args) throws Exception {\n        CountDownLatch cdl = new CountDownLatch(2);\n        new Thread(() -> {\n            while (num != 3)\n                ;\n            cdl.countDown();\n        }).start();\n\n        Thread.sleep(500);\n\n        new Thread(() -> {\n            synchronized (HappensBeforeMain.class) {\n                num = 3;\n            }\n            cdl.countDown();\n        }).start();\n\n        cdl.await();\n    }\n\n}\n这种方式第一个线程依然读取不到num = 3的操作结果。\n\n\npublic class HappensBeforeMain {\n\n    private static int num = 0;\n\n    public static void main(String[] args) throws Exception {\n        CountDownLatch cdl = new CountDownLatch(2);\n        new Thread(() -> {\n            while (num != 3) {\n                synchronized (HappensBeforeMain.class) {\n                }\n            }\n            cdl.countDown();\n        }).start();\n\n        Thread.sleep(500);\n\n        new Thread(() -> {\n            num = 3;\n            cdl.countDown();\n        }).start();\n\n        cdl.await();\n    }\n\n}\n\n只有在读的循环操作里加上锁，之前其他线程的操作，在循环里重新获取锁时，才是可见的。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1599710197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2076251,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/5b/4bd42286.jpg","nickname":"宋计洋","note":"","ucode":"9A34E8F71C6CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1227252,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b9/f4/cc519a9f.jpg","nickname":"お金💪","note":"","ucode":"210C44553ABFDF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567274,"discussion_content":"这个确实好神奇呀，可以理解为在读的时候使用synchronized会刷新缓存吗？我使用System.out.println()也可以获取到新值，因为内部也包含synchronized","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650873135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304914,"ip_address":""},"score":567274,"extra":""}]},{"author":{"id":1119991,"avatar":"https://static001.geekbang.org/account/avatar/00/11/16/f7/43253c3f.jpg","nickname":"秋林","note":"","ucode":"22E0CBC3665AE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185306,"discussion_content":"第2种方式，是不是读的代码块也要加锁才行？","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1582614325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1703832,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ff/98/a9a68fc6.jpg","nickname":"NaN🎃","note":"","ucode":"69D6A99871A6FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54887,"discussion_content":" start()","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574322026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3520,"discussion_content":"利用传递性也可以啊","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564550303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533642,"discussion_content":"这么多人说第二种方式有问题，是你们没理解正确好吧。人家这里就只有赋值一个代码块加锁而已，哪里来的什么读数据的代码？上一个线程加锁修改后，下一个线程加锁进来再修改，可不得先把数据从内存中读到CPU缓存吗？读的时候不就读到上一个线程解锁后产生的结果了吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637922246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532982,"discussion_content":"个人认为加final也是可以的 因为JSR133里明确说了个场景String的char数组就是利用这个特性让所有线程可见","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637746160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028945,"avatar":"","nickname":"Geek5198","note":"","ucode":"2BEBE6A39D9A0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405948,"discussion_content":"厉害👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634660391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2329635,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8c/23/f1c5bee0.jpg","nickname":"wang.yu","note":"","ucode":"CCA775784B3EB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382768,"discussion_content":"我认为第二种方式需要在读的线程里也加锁才可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625715684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72204,"user_name":"小和尚笨南北","can_delete":false,"product_type":"c1","uid":1204628,"ip_address":"","ucode":"17C9BBB6DD25D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg","comment_is_top":false,"comment_ctime":1551534140,"is_pvip":false,"replies":[{"id":"26189","content":"这个我称为炫技！","user_name":"作者回复","comment_id":72204,"uid":"1269969","ip_address":"","utype":1,"ctime":1551584274,"user_name_real":"王宝令"}],"discussion_count":10,"race_medal":0,"score":"491177805884","product_id":100023901,"comment_content":"补充一个： 在abc赋值后对一个volatile变量A进行赋值操作，然后在其他线程读取abc之前读取A的值，通过volatile的可见性和happen-before的传递性实现abc修改后对其他线程立即可见","like_count":114,"discussions":[{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626,"discussion_content":"这个方案是不是缺了一个条件：其他线程读取A的操作必须发生在当前线程给A赋值的操作之后","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1561822107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1920896,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4f/80/19f946ba.jpg","nickname":"Zain","note":"","ucode":"03EDF7B1BE9CF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374401,"discussion_content":"z.l说的很对，这里看不到有两个原因，一可能是因为线程改了abc但是没刷新到缓存中，但我感觉这个时间是非常短的，我做实验没测试出来，二是可能因为线程本身就还没进行赋值abc=3。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621165311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":626,"ip_address":""},"score":374401,"extra":""}]},{"author":{"id":1639787,"avatar":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","nickname":"Vettel","note":"","ucode":"FB3E71DD1E8E7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35706,"discussion_content":"这个不就是老师提到的例子嘛  但你得保证读取A的操作发生在赋值之后","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1571299429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1639787,"avatar":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","nickname":"Vettel","note":"","ucode":"FB3E71DD1E8E7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98115,"discussion_content":"我觉得可见性隐藏的含义就是读的时间就是要在写时间之后","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577144449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":35706,"ip_address":""},"score":98115,"extra":""}]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441493,"discussion_content":"这个我称为炫技！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1551584274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1768332,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epmeqHLQOicylub5ry45OWrmELHA9IqtFMcLE2fmI6kaOiayghg2qZ8lxmWwXPPPouNyn1Rr9KRl3OQ/132","nickname":"Geek_a06702","note":"","ucode":"F210AA49980B25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387681,"discussion_content":"那我为什么不直接使用volatile关键字修饰abc呢，这样做有什么优点吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628340940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1392431,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","nickname":"a(๑≖ิټ≖ิ)✌","note":"","ucode":"AEF9B5CA1605DF","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281646,"discussion_content":"你名字是不是雪中悍刀行里来的啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591783179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1386201,"avatar":"https://static001.geekbang.org/account/avatar/00/15/26/d9/f7e96590.jpg","nickname":"yes","note":"","ucode":"612BF6884ED6CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2038,"discussion_content":"小姑娘李东西","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563194362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2709634,"avatar":"https://static001.geekbang.org/account/avatar/00/29/58/82/f186a477.jpg","nickname":"佐智","note":"","ucode":"493638FC1AF876","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547722,"discussion_content":"一般不会这么写吧，这个还是要从设计线程安全的类的规范出发，这个abc逸出了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642838516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031181,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bc/0d/00424e81.jpg","nickname":"到道可道","note":"","ucode":"12B94B6C26BE0D","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391247,"discussion_content":"活学活用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630371530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72456,"user_name":"Junzi","can_delete":false,"product_type":"c1","uid":1004612,"ip_address":"","ucode":"4AC663769C1873","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/44/4e541a86.jpg","comment_is_top":false,"comment_ctime":1551630896,"is_pvip":false,"discussion_count":30,"race_medal":0,"score":"366623851056","product_id":100023901,"comment_content":"参考1中write()方法代码：<br>x=45;  &#47;&#47; 1<br>v=true;  &#47;&#47; 2<br>这两行会不会导致指令重排？<br><br>因为volatile关键字应该只保证了变量v的可见性，happen-before第一条原则在单线程中，1与2重排并不影响结果，那应该有可能出现重排的情况，这样线程B读取到read()的时候也有可能出现x=0。还请老师解答。","like_count":85,"discussions":[{"author":{"id":1004342,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/36/2c449c71.jpg","nickname":"叶玉林","note":"","ucode":"C72E88613DB992","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48013,"discussion_content":"volatile修饰的字段在汇编后会有一个lock的指令，这个指令简单来说做到两件事，1：修改后，其他CPU立即可见，2：不允许lock之前的指令重排序到lock后面","likes_number":32,"is_delete":false,"is_hidden":false,"ctime":1573441712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332293,"discussion_content":"课文已经说清楚了，程序顺序性规则、volatile 变量规则、传递性这 3 条规则，共同限定了范例程序里面，当线程 B 见到 v 为 true 的时候，它也要能见到 x 正确的值(原文值为 42, 楼主帖子是 45)。楼主的疑问是：1. 范例程序会不会有指令重排的编译优化?  2. 如果不能有指令重排，是由什么规则决定的？如果有指令重排，线程 B 为什么能看到正确的 x 值？\n\n我的理解如下：\n\n1. 范例程序不会有指令重排，而且这就是由 程序顺序性规则、volatile 变量规则、传递性 这 3 条规则共同决定的\n\n2. 那么如何理解上述 3 条 happens-before 规则共同禁止了范例程序的指令重排呢？有这个疑问的同学，往往是没有完全理解 程序顺序性规则 的含义。这条规则通俗地说，就是同一线程内，编译后数据的可见性是要符合源程序要表达的逻辑顺序和语义的。也就是，对于单线程，编译后的代码，要保证符合程序员预期的结果。只要达到这个目标，编译器可以做任何它认为必要的优化。所以，如果只考虑单线程，范例代码是可以被编译器进行指令重排优化的。因为这两个紧邻的变量的赋值语句，不存在依赖关系。把它们的顺序对调，不影响程序的语义和结果。\n\n3. 上面说明了，程序顺序性规则是针对单线程的。如果只考虑单线程，那么编译器可以对范例代码就行指令重排优化。但是对于多线程，volatile 变量规则、传递性这 2 条规则，就附加了新的限制。由课文可知道，对于多线程，这 3 条 happens-before 规则要求，线程 B 在读到 v = true 的时候，也能见到 x = 42。如果编译器仍然按照单线程的情况，对这两条语句进行指令重排，把 v = true 放到 x = 42 之前。那么，线程 B 就有可能看不到 x 的值为 42。这显然违背了 happens-before 的规定。编译器为了符合规则，只能不进行指令重排优化了。\n\n4. 上面说到，为了符合 happens-before 规定，对于示例代码，编译器不能进行指令重排的编译优化。但实际上，仅仅不进行指令重排编译优化，并不能保证编译后的代码的执行结果，符合 happnes-before 规定。因为指令重排这一优化措施，并不仅仅是编译器会做。现代 cpu 在执行机器指令的时候，同样会做指令重排的优化。所以，如果 cpu 在执行机器指令时，发生了机器指令的重排序。上述实例代码的结果，仍然有机会不符合 happens-before 规定\n\n5. 为了令到编译后的代码的执行结果，能够符合 happens-before 规定。编译器除了不能做指令重排序编译优化之外，还要在生成的机器代码中。加入特定 cpu 指令，令到 cpu 只会执行完这条特定指令之后，才会执行后续的其它机器指令。而这种特定指令，是通过建立 &#34;内存屏障&#34; 来禁止 cpu 的指令重排序的。那为什么叫 &#34;内存屏障&#34; 呢？这方面我还没有很深入的了解。目前我的理解是，这种特殊指令，都要求 cpu 把缓存数据写回到主内存中。这就像在内存中建立了一道屏障，令到后面的代码不能越过屏障，提前执行。\n\n6. jmm 是一个规范，它用于指导编译器的行为。但它本身不会限制编译器所使用的具体编译技术。所以，在 jmm 规范中，不会提到 &#34;指令重排&#34; 或者 &#34;内存屏障” 这些具体的实现技术。这是我们在学习规范类知识的时候，需要注意的。","likes_number":28,"is_delete":false,"is_hidden":false,"ctime":1607151518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1133194,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","nickname":"makermade","note":"","ucode":"03386B90CB8F20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574156,"discussion_content":"niu pi 谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653875167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332293,"ip_address":""},"score":574156,"extra":""}]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301421,"discussion_content":"1.5 之前，这俩行代码，是可能会出现重排序的，volatile 的出现就是为了禁用缓存，意思就是，代码执行带volatile 修饰的这一行代码，会将目前缓存的刷进内存，同时，通过总线机制，让别的cpu缓存失效，这样就保证了，volatile这个变量的写操作对别的线程一定是可见的，这时候别的线程读取X的值，如果x的赋值没有被重排序到v后面，那么别的线程是能读到42的，但是如果被编译重排序了，这时候，这行代码还没执行，别的线程读到的是0，但是从代码的顺序来看，x的赋值操作是发生了。所以就造成了错误，代码的执行顺序没有按照程序员的意志就行执行。\n1.5之后，加入hb规则，也就是内存模型中的内存屏障技术，保证了，v变量之前的写不会被重排序到v的写之后，这也就是避免了上面的问题","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1598521137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1400810,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/ea/3b2b8bf9.jpg","nickname":"TY副本","note":"","ucode":"FB29711ADCEEE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324972,"discussion_content":"具体来讲，在1.5及之后。对于volatile的重排规则还加了两个。一个是如果第一个语句是对volatile的读，那么不能与它后面的语句重排；如果第二个操作是对volatile写，那么不能与它的前面操作重排。在原来的只约束volatile写与volatile的读来讲，增强了。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1605195876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301421,"ip_address":""},"score":324972,"extra":""},{"author":{"id":2536451,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b4/03/677fd301.jpg","nickname":"孤傲的虎王","note":"","ucode":"FE9B90D6EEBAFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1400810,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/ea/3b2b8bf9.jpg","nickname":"TY副本","note":"","ucode":"FB29711ADCEEE4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369274,"discussion_content":"透彻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618994018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324972,"ip_address":""},"score":369274,"extra":""}]},{"author":{"id":1024565,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a2/35/04536ff4.jpg","nickname":"随欣所遇","note":"","ucode":"9A5F6D61DEFBD3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251148,"discussion_content":"在新的内存模型中，volatile周围的普通字段不能随便重排；编译器生成字节码时，会在volatile写操作的前面和后面分别插入内存屏障（StoreStore屏障｜volatile写｜StoreLoad屏障），其中StoreStore屏障：禁止上面的普通写和下面的volatile写重排序；StoreLoad屏障：防止上面的volatile写与下面可能有的volatile读/写重排序。ps:具体可参考《java并发编程的艺术》volatile写插入内存屏障示意图","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1588069542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1179898,"avatar":"https://static001.geekbang.org/account/avatar/00/12/00/fa/5863be21.jpg","nickname":"Outside","note":"","ucode":"E04CA55407FF37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1024565,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a2/35/04536ff4.jpg","nickname":"随欣所遇","note":"","ucode":"9A5F6D61DEFBD3","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":273140,"discussion_content":"这个老师内容 “按照程序的顺序，第 6 行代码 “x = 42;” Happens-Before 于第 7 行代码 “v = true;”，这就是规则 1 的内容” 这句话是有问题的吧，单线程中，导致这两行代码\nx=45; //1\nv=true; // 2\n不重排序的原因是volatile的语义，而不是程序的顺序性规则","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1590415597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":251148,"ip_address":""},"score":273140,"extra":""},{"author":{"id":1161200,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b7/f0/a570f68a.jpg","nickname":"wang","note":"","ucode":"5D569805C6A923","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179898,"avatar":"https://static001.geekbang.org/account/avatar/00/12/00/fa/5863be21.jpg","nickname":"Outside","note":"","ucode":"E04CA55407FF37","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299978,"discussion_content":"嗯，这个其实不是用规则一，是volatile的语义，防止指令重排","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597892511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273140,"ip_address":""},"score":299978,"extra":""}]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280161,"discussion_content":"多线程对于程序员来说，难点是可见性问题，因为java保证的单线程as is serial是特别符合人类思维的，程序员开发中并不需要知道多线程协作时，两个线程是顺序执行还是交叉执行，所有代码执行的顺序又是什么，因为程序员只需要知道多线程是并发执行的，实际上线程的执行本身就是随机的无序的。那么为什么说程序员只需要关注可见性问题呢？这是存在共享变量的读写，如果全是局部变量，程序员根本不需要考虑并发问题可见性问题。程序员会发现多线程中简单直接的对共享变量的读写的结果不符合预期，所以Java为了帮助程序员正确编码，总结出happens before 规则，这些规则更加实用，不需要程序员理解什么是编译重排序、处理器重排序、内存重排序还有内存屏障。volatile 写 happens before 读，这条规则在java 1.5中添加，可能有人疑惑的是这条规则不就是volatile 原本语义么？原本就是从能读到最新值啊，之所以声明这是一条happens before 规则，这是因为传递性，不是happens before 规则，volatile的语义是单一的孤独的，成为happens before 之后就可以和其他规则组合使用了。\n线程A\nx=45     1\nV=true 2\n线程B\nIf v   3\nx   4\n\n因为2 happens before 3\n所以1 happens before 4\n\n\n至于1和2是不是重排序并不需要程序员考虑，程序员关注happens before规则就好了\n\n\n实际上Java1.5之后会通过插入内存屏障来禁止该重排序\n\n","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1591506583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1621793,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bf/21/44eb3aee.jpg","nickname":"Hou","note":"","ucode":"92BF011EF961B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3811,"discussion_content":"volatile会禁止指令的重排序 并且在volatile变量写回内存的时候存在于写缓冲区的普通变量也会刷回内存  所以线程B读到的x是42","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1564832963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1533266,"avatar":"https://static001.geekbang.org/account/avatar/00/17/65/52/07c09c7f.jpg","nickname":"josancpp","note":"","ucode":"0CDC39B3E716A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1621793,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bf/21/44eb3aee.jpg","nickname":"Hou","note":"","ucode":"92BF011EF961B4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":147743,"discussion_content":"答非所问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579671508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3811,"ip_address":""},"score":147743,"extra":""}]},{"author":{"id":1018240,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/80/3666ced3.jpg","nickname":"黄浩特","note":"","ucode":"C3A4BBF4FB8519","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32632,"discussion_content":"老师说过允许编译优化, 但是 Happens-Before 原则的同一线程顺序性和传递性 规则保证了 x = 42 对 v = true 是可见的. 这里只要保证可见性, 没有保证执行顺序, 具体实现可见性应该是虚拟机开发人员做的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1571053859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196234,"avatar":"https://static001.geekbang.org/account/avatar/00/12/40/ca/1313a90b.jpg","nickname":"退役的球童","note":"","ucode":"CD5157830D9606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26723,"discussion_content":"我跟你有同样的疑问，希望老师能回复下","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1570615324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1693414,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d6/e6/87234c32.jpg","nickname":"木心云影","note":"","ucode":"5F7244D779AD9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51100,"discussion_content":"这两句怎么可能指令重排呢？只有像x++这种才会出现指令重排吧？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573811104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1693414,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d6/e6/87234c32.jpg","nickname":"木心云影","note":"","ucode":"5F7244D779AD9F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301422,"discussion_content":"如果不加volatile修饰，是会发生重排序的，cpu指令执行时，会时分复用，这俩行代码对应的指令，谁先谁后，不加volatile，还真保证不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598521260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51100,"ip_address":""},"score":301422,"extra":""}]},{"author":{"id":1555565,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","nickname":"汤小高","note":"","ucode":"D4AB7766273D52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141177,"discussion_content":"这个是因为java内存模型限制了volatile写之前的操作重排序到它之后，所以不用考虑重排序会影响传递性。因为这种情况不会重排序。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579400459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1135604,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","nickname":"bin.chen","note":"","ucode":"5BA49358AB8A1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1555565,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","nickname":"汤小高","note":"","ucode":"D4AB7766273D52","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192796,"discussion_content":"这个应该就是在编译的时候知道这一块有volatile关键字，在其前后插上了内存屏障，禁止重排以及强制刷新到主存中","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583086820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":141177,"ip_address":""},"score":192796,"extra":""},{"author":{"id":1442230,"avatar":"https://static001.geekbang.org/account/avatar/00/16/01/b6/5b297fef.jpg","nickname":"Gray","note":"","ucode":"7725C335978662","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135604,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","nickname":"bin.chen","note":"","ucode":"5BA49358AB8A1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206726,"discussion_content":"是的，插上了内存屏障","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584434759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":192796,"ip_address":""},"score":206726,"extra":""}]},{"author":{"id":1897434,"avatar":"","nickname":"流星","note":"","ucode":"322220E4695128","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239224,"discussion_content":"其实老师一开始就给出了结论：对于Happens-Before原则Java内存模型就只保证了可见性，没保证顺序性。所以网上很多文章这个关键点没有点名，让人觉得一直是互相矛盾的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587285578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179952,"avatar":"https://static001.geekbang.org/account/avatar/00/12/01/30/cb3a729e.jpg","nickname":"XHH","note":"","ucode":"3EF89099982977","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192792,"discussion_content":"如果执行顺序是 1 ，2 ，3（if (v == true) ）的话，1和2不会重排，由于程序顺序性规则 1 happen-before 于 2，监视器锁规则可知 2 happen-before于3，根据传递性规则，1 happen-before 于 3，而编译器优化需要遵守 happen-before规则，所以1和2不会重排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583084133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2872,"discussion_content":"按照程序的顺序，第 6 行代码 “x = 42;” Happens-Before 于第 7 行代码 “v = true;”，这就是规则 1 的内容，也比较符合单线程里面的思维：程序前面对某个变量的修改一定是对后续操作可见的。\n\n第二个就是传递性在多线程的情况下依然适用（例子中已经用两个线程举例子了，不言自明），结合规则1、规则2，就不会出现你说的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564005331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1188517,"avatar":"http://thirdwx.qlogo.cn/mmopen/g7TWmGqjoiaSFWknFpTPAia5rPOmzEZiaGK8icd5HGEXlfaYJBoKvLn5BkqGkyTZOqDTC3NMHXUbH3tdLJzicAyickRYdP4xcM3ajia/132","nickname":"sudo","note":"","ucode":"EA0F8116999557","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6942,"discussion_content":"主要还是volatile 限制了编译器指令重排序。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1567182110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2872,"ip_address":""},"score":6942,"extra":""},{"author":{"id":1196234,"avatar":"https://static001.geekbang.org/account/avatar/00/12/40/ca/1313a90b.jpg","nickname":"退役的球童","note":"","ucode":"CD5157830D9606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26716,"discussion_content":"顺序性规则是保证串行逻辑语义的，而示例中的代码即使指令重拍也无任何影响。一旦重排，即v = true先执行。那规则适用的对象都变了。后面的传递性也无法保证reader中读到的x一定是42。只能得到a先于b，a先于c，但b是否先于c就无从可知了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570615015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2872,"ip_address":""},"score":26716,"extra":""}]},{"author":{"id":1115284,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/94/c04ddcf6.jpg","nickname":"helloworld","note":"","ucode":"D412FB8BF1CEB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321,"discussion_content":"传递性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561447769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1196234,"avatar":"https://static001.geekbang.org/account/avatar/00/12/40/ca/1313a90b.jpg","nickname":"退役的球童","note":"","ucode":"CD5157830D9606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1115284,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/94/c04ddcf6.jpg","nickname":"helloworld","note":"","ucode":"D412FB8BF1CEB8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26717,"discussion_content":"你这个传递性的前提是没有指令重排。一旦指令重拍，传递性的链条也就变了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570615085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321,"ip_address":""},"score":26717,"extra":""},{"author":{"id":1043789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/4d/1d1a1a00.jpg","nickname":"magict4","note":"","ucode":"CB6F063D881AAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1196234,"avatar":"https://static001.geekbang.org/account/avatar/00/12/40/ca/1313a90b.jpg","nickname":"退役的球童","note":"","ucode":"CD5157830D9606","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103852,"discussion_content":"我仔细查了一下 Oracle 的文档，引用如下：\n> If x and y are actions of the same thread and x comes before y in program order, then hb(x, y).\n\n这里强调了 &#34;program order&#34; 而非 “execution order&#34;。在推导 happen-before  关系时，我的理解是无需考虑指令重排问题。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577402902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":26717,"ip_address":""},"score":103852,"extra":""},{"author":{"id":1196339,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/33/d1064f9a.jpg","nickname":"Sun","note":"","ucode":"1BC2741DC07FC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/4d/1d1a1a00.jpg","nickname":"magict4","note":"","ucode":"CB6F063D881AAC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198813,"discussion_content":"那请问按这个Oracle的文档来说，单线程情况下永远不会发生指令重排序吗？那指令重排序的意义是什么呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583513430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":103852,"ip_address":""},"score":198813,"extra":""}]}]},{"had_liked":false,"id":72027,"user_name":"狂战俄洛伊","can_delete":false,"product_type":"c1","uid":1213269,"ip_address":"","ucode":"F6EACA321E6180","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUzv6S9wroydkGP6m3OsQ8QuI4jAibv21tNkm7KVGPffJibj8Y29yIdKl4qkDGd3iaGJCSGVarfxoibQ/132","comment_is_top":false,"comment_ctime":1551501790,"is_pvip":false,"replies":[{"id":"26102","content":"感谢回复！","user_name":"作者回复","comment_id":72027,"uid":"1269969","ip_address":"","utype":1,"ctime":1551522224,"user_name_real":"王宝令"}],"discussion_count":7,"race_medal":0,"score":"315084114398","product_id":100023901,"comment_content":"回复tracer的问题@tracer，你说的这个问题其实就是一个happens-before原则。例如有以下代码：<br>     int a = 1;&#47;&#47;代码1<br>     int b = 2;&#47;&#47;代码2<br>     volatile int c = 3;&#47;&#47;代码3<br>     int d = 4;&#47;&#47;代码4<br>     int e = 5;&#47;&#47;代码5<br>编译器解释这5行代码的时候，会保证代码1和代码2会在代码3之前执行，而代码1和代码2的执行顺序则不一定（这就是重排序，在不影响执行结果的情况下，虚拟机可能会对命令重排。当然所谓的不影响执行结果，java只保证在单线程中不影响执行结果）。代码4和代码5也一定会在代码3之后执行，同理代码4和代码5的执行顺序也是不一定的。<br>    所以这篇文章中你说的那段代码，由于v是volatile修饰的，对v的赋值永远在对x的赋值之后。所以在reader中输出的x一定是42","like_count":73,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441428,"discussion_content":"感谢回复！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551522224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1288640,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a9/c0/ed3be464.jpg","nickname":"唐代斯","note":"","ucode":"8F336BB3689DDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199207,"discussion_content":"那这个禁止重排序的范围是多少？比如如果出现了volatile修饰的变量，在它之前（以及之后）所有的代码都禁止重排序吗？（比如一个方法里面有200行代码，中间有个volatile修饰的变量）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583570207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288640,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a9/c0/ed3be464.jpg","nickname":"唐代斯","note":"","ucode":"8F336BB3689DDA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289236,"discussion_content":"我也有这样的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594037017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199207,"ip_address":""},"score":289236,"extra":""},{"author":{"id":1170670,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dc/ee/8fb92613.jpg","nickname":"晏鹏","note":"","ucode":"D23BC3B61C257E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288640,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a9/c0/ed3be464.jpg","nickname":"唐代斯","note":"","ucode":"8F336BB3689DDA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346092,"discussion_content":"不是说前面的代码禁止重排序，而是说前面的普通写重排序之后不能排到volatile之后","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611872730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199207,"ip_address":""},"score":346092,"extra":""},{"author":{"id":2220763,"avatar":"https://static001.geekbang.org/account/avatar/00/21/e2/db/97c6f756.jpg","nickname":"_patrick","note":"","ucode":"B24C6EEBCABB94","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1288640,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a9/c0/ed3be464.jpg","nickname":"唐代斯","note":"","ucode":"8F336BB3689DDA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571819,"discussion_content":"没有什么范围。 你就把volatile 那一行理解为屏障，在它前后的命令 可以重排序。但不管怎么重排序，都不能跨过这个屏障。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652421849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199207,"ip_address":""},"score":571819,"extra":""}]},{"author":{"id":2573722,"avatar":"","nickname":"Geek_36e4bb","note":"","ucode":"90E84F8CC8A410","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368541,"discussion_content":"你这个结论是根据结果往前推导的,你凭什么证明你是对的? 在第一章int x=4,int y=5,会可能指令重排,但是你说的代码1,2和代码3有什么联系,为什么就不能指令重排了?你说了这么多都是你的结论有什么说服力啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618746755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1693414,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d6/e6/87234c32.jpg","nickname":"木心云影","note":"","ucode":"5F7244D779AD9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51102,"discussion_content":"长知识了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573811184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72043,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1551504821,"is_pvip":false,"replies":[{"id":"26104","content":"很全面了!","user_name":"作者回复","comment_id":72043,"uid":"1269969","ip_address":"","utype":1,"ctime":1551522368,"user_name_real":"王宝令"}],"discussion_count":17,"race_medal":0,"score":"246364640693","product_id":100023901,"comment_content":"思考题的通用性表述为：如何保证一个共享变量的可见性？<br>有以下方法：<br>1. 保证共享变量的可见性，使用volatile关键字修饰即可<br>2. 保证共享变量是private，访问变量使用set&#47;get方法，使用synchronized对方法加锁，此种方法不仅保证了可见性，也保证了线程安全<br>3. 使用原子变量，例如：AtomicInteger等<br>4. 最后一种不是办法的办法：保证多个线程是「串行执行」^_^","like_count":57,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441434,"discussion_content":"很全面了!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551522368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2029333,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erLujLByemCGmjp9rIicdoC59XUh99WiargBmxOMtsLlmntyEklh3LyiahtzAz3fnUu0tWwvibTqOFt5A/132","nickname":"hammer","note":"","ucode":"D98A31ACE2158F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291177,"discussion_content":"只加volatile关键字：只能保证A线程成功执行完完整的CPU指令后B线程可以读到正确的值，符合题解。但是我们实际上遇到的问题更多是，如果保证A操作的CPU指令被中断时，B如何正确的操作。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594724016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1987202,"avatar":"","nickname":"Geek_783cc7","note":"","ucode":"C43F76B1978FA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2029333,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erLujLByemCGmjp9rIicdoC59XUh99WiargBmxOMtsLlmntyEklh3LyiahtzAz3fnUu0tWwvibTqOFt5A/132","nickname":"hammer","note":"","ucode":"D98A31ACE2158F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319970,"discussion_content":"同样疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604216880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291177,"ip_address":""},"score":319970,"extra":""}]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129762,"discussion_content":"如果get语句没有synchronized。那么在set语句拿到锁执行的时候，get语句可以读变量。然后set语句释放锁。此时如果get语句再次读变量那么读到的值会跟之前不一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578736262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129955,"discussion_content":"没get到你要表达的点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578746097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":129762,"ip_address":""},"score":129955,"extra":""},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":130019,"discussion_content":"点错了按钮。回复给下面这位同学的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578748628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":129955,"ip_address":""},"score":130019,"extra":""}]},{"author":{"id":1448750,"avatar":"","nickname":"cloud_melon","note":"","ucode":"8C86694B9B129D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394949,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632143808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332296,"discussion_content":"AtomicInteger 这种原子类实例，只能保证操作的原子性。它如何保证可见性呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607151953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1758825,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d6/69/f59d4f6f.jpg","nickname":"Ryan","note":"","ucode":"387955FD53E98C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553866,"discussion_content":"AtomicInteger对象里的 value 属性用 volatile 保证可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646121628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332296,"ip_address":""},"score":553866,"extra":""},{"author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1758825,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d6/69/f59d4f6f.jpg","nickname":"Ryan","note":"","ucode":"387955FD53E98C","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":555073,"discussion_content":"谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646733258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553866,"ip_address":""},"score":555073,"extra":""}]},{"author":{"id":1494880,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cf/60/9100ad4f.jpg","nickname":"周星平","note":"","ucode":"1FDCB487392B03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288198,"discussion_content":"共享变量为什么要设置成private","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593676082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1392431,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","nickname":"a(๑≖ิټ≖ิ)✌","note":"","ucode":"AEF9B5CA1605DF","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363,"discussion_content":"set/get方法使用synchronized这个，是不是只要给set加synchronized就足够了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561483749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1392431,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","nickname":"a(๑≖ิټ≖ิ)✌","note":"","ucode":"AEF9B5CA1605DF","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":29593,"discussion_content":"不行的。你可以再想想","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570775242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363,"ip_address":""},"score":29593,"extra":""},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1392431,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","nickname":"a(๑≖ิټ≖ิ)✌","note":"","ucode":"AEF9B5CA1605DF","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":29615,"discussion_content":"\n我再从另一个侧面提示一下：为什么JAVA并发包里会提供读写锁？\n\n按照你的想法，get方法相当于读操作，而读操作不用加锁的话，那JAVA并发包里面为什么提供单独的写锁呢？\n2019-10-11\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570776560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363,"ip_address":""},"score":29615,"extra":""},{"author":{"id":1639787,"avatar":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","nickname":"Vettel","note":"","ucode":"FB3E71DD1E8E7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1392431,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","nickname":"a(๑≖ิټ≖ิ)✌","note":"","ucode":"AEF9B5CA1605DF","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":35801,"discussion_content":"除非加上volatile 否则还是会出现脏读问题","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1571306027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363,"ip_address":""},"score":35801,"extra":""}]}]},{"had_liked":false,"id":71943,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1551490948,"is_pvip":false,"replies":[{"id":"26088","content":"你分析的比我还要好！","user_name":"作者回复","comment_id":71943,"uid":"1269969","ip_address":"","utype":1,"ctime":1551520447,"user_name_real":"王宝令"}],"discussion_count":11,"race_medal":0,"score":"190530051972","product_id":100023901,"comment_content":"感悟 ： <br>老师用第一篇介绍了造成并发问题的由来引出了此文如果解决其中的 可见性、排序性问题 。 有了第一篇做铺垫让此篇看起来更加的流畅 。 <br><br>尤其以前看书中讲解 happens-before原则只是单单把六个规则点列了出来，很难吃透。此篇文章给出详细的事例逐点分析，使得更好的去理解每个点。 <br><br>例如 我之前看到的文章都说 在单线程中不会出现有序性问题 ，在多线程中会出现有序性问题。 之前很难理解单线程中没有有序性的问题是什么原因， 原来是happens-before第一条规则限制住了编译器的优化<br><br>问题： <br>第一个例子中添加了 volatile 关键字， 如果例子中 ， v变量没有使用volatile ，那么x会是什么呢 ？？<br>答案： 42<br><br>我的思考是， 没有了volatile那么规则二就不满足 ， 但是规则一和规则三还是满足 ，虽然 writer()方法修改 v不能让其他立即可见，但是如果是循环调用reader()方法 ，等到可见到 v == true，根据第一条原则 ， x happens-before v ，所以能读到 x=42 <br><br>老师请问我的判断正确么？<br><br><br>思考题 ：<br><br>一个共享变量在一个线程中修改让另其他线程可见， 那就是解决可见性（缓存）的问题 , happens-before的规则就是用于对可见性进行约束的<br><br>按照老师课中所讲 ：<br>思考如下：<br><br>  1. 第一条规则同线程中编译会保证顺序性 ， 和问题不符合 <br><br> 2. 第二条规则 ， 使用volatile关键字 ， 这个关键字可以让其他线程写之前先读最新的值，所以保证读到的是最新的值 ，可行<br><br>3. 第三条规则 ，传递性， 和问题不符<br><br>4. 第四条规则， 使用管程，由于是访问共享变量，如果是在syn中修改值只能保证当前线程下一次进入syn可以看见最新的值，其他线程直接访问还可能不是最新值 ， 不行<br><br>5. 第五条规则 ， 如果前提是其他线程都在 主线程修改abc变量后 start()，则可见<br><br>6. 第六条规则 ，如果前提是其他线程等 修改abc变量线程 join()执行，则可见<br><br>  7.   Final关键字， 由于final关键字表示已经定义了常量，任意线程都不可以修改， 不可用 <br><br>综上总结 ： <br><br>使用2 添加volatile可行 。在符合某些场景下时，56可让其他线程可见<br><br><br>","like_count":44,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441406,"discussion_content":"你分析的比我还要好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551520447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332308,"discussion_content":"1. 简单地说，规则 1 是要保证，单线程执行的时候，程序的结果是要符合源代码表达的执行顺序和语义的。更通俗地说，单线程执行的结果，是要符合程序员的预期的。只要符合这个规则，编译器可以进行任何编译优化。而 x=42, v=true 这两个语句没有依赖关系。所以在单线程内，如果编译器通过指令重排序，把这两个语句的顺序对调执行，并不会影响程序执行的结果。所以在这种情况下，规则 1 是允许这两个语句的编译后的执行顺序，与源代码不同的。\n\n2. 规则 1 导致的一个现象是，只要编译后的代码符合规则 1，那么在执行编译后代码的单一线程内，一切都像是和源代码表达的执行流程一致的。在单一线程内，是感觉不到编译器做的指令重排序优化的影响的。\n\n3. 但是想象一下如下情况。如果我们从存在指令重排序的线程以外，去观察这个线程的执行，却是会感受到被观察线程的指令重排序的。所以，对于其它线程来说，是会受到这个线程的指令重排序的影响的。楼主说光是规则 1, 规则 3 就可以保证第二个线程读到 x == 42，这是不对的。\n\n4. synchronized 是可以保证共享变量的可见性的。不但如此，它还可以保证 原子性 和 有序性。synchronized 对可见性的保证，是由 管程锁规则, 程序顺序性规则 和 传递性 共同限定的。\n\n5. 但是，只有当所有访问共享变量的线程，都是通过同一个锁的 synchronized 代码去访问此变量，才能保证其可见性。如果有线程用非 synchronzied 保护的代码，或者其它锁的 synchronized 代码去访问此变量，那么所有线程都可能看不到此变量的最新值。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1607155653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87657,"discussion_content":"第四点好像不对吧，如果是在syn中修改值，那么在syn过后会释放锁，且刷新cpu缓存，那么其他线程再次进入syn时，就会从内存中读取最新的值。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576676591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1183424,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0e/c0/95fa2666.jpg","nickname":"山楂树","note":"","ucode":"1D59FC0C560BCD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5524,"discussion_content":"我是这么理解的，规则1的顺序性，是指的单线程内的顺序性，而多线程之间观察则不能保证这一点。如果v不用volatile修饰，在线程A中，x=42 happens-before v=true，但是这两条指令存在重排序的可能性，v=true在时间上可能先于x=42执行。如果此时进行线程切换，在线程B中，v==true，但是不能保证x=42。\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1566344794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102629,"discussion_content":"分析的明显有错误。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577357498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282575,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/0f/cff30522.jpg","nickname":"江湖夜雨","note":"","ucode":"C64913C7000899","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2335,"discussion_content":"如果v不用volatile修饰，B线程中x有可能为0或42，因为指令会使得变量x,v重排序","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563496405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1182200,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/f8/5f74ff5b.jpg","nickname":"Owen","note":"","ucode":"ADE38F8D446860","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1282575,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/0f/cff30522.jpg","nickname":"江湖夜雨","note":"","ucode":"C64913C7000899","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267089,"discussion_content":"那第一条规则何在？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589599260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2335,"ip_address":""},"score":267089,"extra":""},{"author":{"id":1424609,"avatar":"https://static001.geekbang.org/account/avatar/00/15/bc/e1/cb5ffddf.jpg","nickname":"药味","note":"","ucode":"8D894D423BBB54","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1182200,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/f8/5f74ff5b.jpg","nickname":"Owen","note":"","ucode":"ADE38F8D446860","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559612,"discussion_content":"没有违反规则一\n例如：\n1：int a = 1;\n2：int b = 2;\n3：System.out.println(a);\n\n一定会保证3在1之后执行，即输出1,。但不能保证2一定在1之后（重排序后），因为2没有依赖1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648833393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":267089,"ip_address":""},"score":559612,"extra":""}]},{"author":{"id":1044841,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bDlEdYdNiaPq1X0tt9wO4lSzOepddjPobjLW7YWpUd8MHDicVbt5kXE0SicvkvjRCNqreAthuqlyibLuGfXUvGoFbA/132","nickname":"曹丽杰","note":"","ucode":"D702455FFD2C92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387157,"discussion_content":"是不是这里即使没有指令重排序，当线程B 看到v=true时，在线程A的方法堆栈里x=42的值可能还在CPU缓存中，还没刷入内存中，这时线程B也就看不到x=42.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628007240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213058,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/82/d8e03843.jpg","nickname":"再做羽哲","note":"","ucode":"5A081440FC3363","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194516,"discussion_content":"我不明白为什么第四条不行，在syn中 每次只可以进入一个线程进行写操作 当前线程写完了以后 其他线程再进入 就可以读到最新的值了啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583227474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1928441,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/cfNtHoAbHvia1O0jIopiafYbnppEPiawgicKa8vdI2FxMMEdqORB4VLzkYTuGJGA7HibustnU0hDTOD7YSDAWuxhmrg/132","nickname":"Geek_299a34","note":"","ucode":"79AECE06F08E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1213058,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/82/d8e03843.jpg","nickname":"再做羽哲","note":"","ucode":"5A081440FC3363","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309583,"discussion_content":"读线程没加互斥锁，读到的可能就不是最新值","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601358090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":194516,"ip_address":""},"score":309583,"extra":""}]}]},{"had_liked":false,"id":72277,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1551569434,"is_pvip":true,"replies":[{"id":"26183","content":"可以重排，但是要保证符合Happens-Before规则，Happens-Before规则关注的是可见性，<br>x=5;<br>y=6;<br>z=x+y;<br>上面的代码重排成这样：<br>y=6;<br>x=5;<br>z=x+y;<br>也是可以的。<br><br>所谓顺序，指的是你可以用顺序的方式推演程序的执行，但是程序的执行不一定是完全顺序的。编译器保证结果一定 == 顺序方式推演的结果<br><br>这几条规则，都是告诉你，可以按照这个规则推演程序的执行。但是编译怎么优化，那就百花齐放了。","user_name":"作者回复","comment_id":72277,"uid":"1269969","ip_address":"","utype":1,"ctime":1551583339,"user_name_real":"王宝令"}],"discussion_count":6,"race_medal":0,"score":"181940195866","product_id":100023901,"comment_content":"老师，第一章里提到程序中x=5；x=6可能被重排。可是今天第一个规则里提到，同一个线程里，是顺序的。这两个不就矛盾了吗？","like_count":42,"discussions":[{"author":{"id":1636795,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f9/bb/25c08b00.jpg","nickname":"Jason","note":"","ucode":"D29C93256F4A37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":90906,"discussion_content":"关于这个问题，你可以看看这个问题https://stackoverflow.com/questions/16213443/instruction-reordering-happens-before-relationship-in-java，还有这篇文章https://preshing.com/20130702/the-happens-before-relation/。happens-before不代表时间上的先发生，只要程序的执行结果能够保证consistency就行。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1576802778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1043789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/4d/1d1a1a00.jpg","nickname":"magict4","note":"","ucode":"CB6F063D881AAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1636795,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f9/bb/25c08b00.jpg","nickname":"Jason","note":"","ucode":"D29C93256F4A37","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103878,"discussion_content":"这两个链接实在太棒了，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577404952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":90906,"ip_address":""},"score":103878,"extra":""}]},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102637,"discussion_content":"文中的程序的顺序性规则不如这里说的明白","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577357921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441520,"discussion_content":"可以重排，但是要保证符合Happens-Before规则，Happens-Before规则关注的是可见性，\nx=5;\ny=6;\nz=x+y;\n上面的代码重排成这样：\ny=6;\nx=5;\nz=x+y;\n也是可以的。\n\n所谓顺序，指的是你可以用顺序的方式推演程序的执行，但是程序的执行不一定是完全顺序的。编译器保证结果一定 == 顺序方式推演的结果\n\n这几条规则，都是告诉你，可以按照这个规则推演程序的执行。但是编译怎么优化，那就百花齐放了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1551583339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1552006,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ae/86/47c9d7f3.jpg","nickname":"伤心的火车","note":"","ucode":"9CF33A4F91C252","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213788,"discussion_content":"可以的，这个解释的很清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585122489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033240,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkwbyTYtSCx6Qc7cQPnnRWv38Jybh3etziaPmuP8gHcgS6FMxcdftrKgWiamH6fc2iciaicDKDVEwcEibQ/132","nickname":"sami","note":"","ucode":"9A66FCA00D8A37","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209955,"discussion_content":"没有依赖的情况可能会重新排序，因为命令发送到处理器的话是批量发的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584694284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72017,"user_name":"tracer","can_delete":false,"product_type":"c1","uid":1124766,"ip_address":"","ucode":"AE2BC047DB7D7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg","comment_is_top":false,"comment_ctime":1551498941,"is_pvip":false,"replies":[{"id":"26100","content":"终于理解了！","user_name":"作者回复","comment_id":72017,"uid":"1269969","ip_address":"","utype":1,"ctime":1551522098,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":1,"score":"156170321597","product_id":100023901,"comment_content":"我明白了，写先于读指的是不会因为cpu缓存，导致a线程已经写了，但是b线程没读到的情况。我错误理解成了b要读，一定要等a写完才行","like_count":36,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441426,"discussion_content":"终于理解了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551522098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1594508,"avatar":"https://static001.geekbang.org/account/avatar/00/18/54/8c/a3b98f6c.jpg","nickname":"denofiend","note":"","ucode":"FC9A750C96E01C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531259,"discussion_content":"读之前 共享变量改 读之后 做个实验","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637253497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503063,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ef/57/0e128187.jpg","nickname":"菜鸟啊菜鸟","note":"","ucode":"2F764CEBD3FDAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415268,"discussion_content":"我理解是：线程A写了一定会会被线程B读到这个数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637043319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72469,"user_name":"magict4","can_delete":false,"product_type":"c1","uid":1043789,"ip_address":"","ucode":"CB6F063D881AAC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/4d/1d1a1a00.jpg","comment_is_top":false,"comment_ctime":1551650070,"is_pvip":false,"replies":[{"id":"26358","content":"“x=42” Happens-Before 写变量 “v=true”<br>是因为程序顺序就是这么写的：x=42；v=true<br><br>这个案例是综合了 程序的顺序规则+传递规则+volatile 规则<br><br>这三这个规则组合在一起就是你所谓的：“而是有 volatile 决定的”。编译器优化要遵循所有的HB规则。所有，不是一条。所以只有把他们组合在一起才有意义。<br>","user_name":"作者回复","comment_id":72469,"uid":"1269969","ip_address":"","utype":1,"ctime":1551711470,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"104630865174","product_id":100023901,"comment_content":"老师你好，<br><br>我对『3. 传递性』中您的解释，还是有点疑惑。感觉许多留言的小伙伴们也都有类似的疑惑，还请老师再耐心回答一次。<br><br>您提到：<br>&gt; “x=42” Happens-Before 写变量 “v=true” ，这是规则 1 的内容；<br>我的疑惑：变量 x 和 v 没有任何依赖关系，为什么对 x 的赋值 Happens-Before 对 v 的赋值呢？<br><br>这个 Happens-Before 关系，根据我的理解，不是由规则 1 决定的，而是有 volatile 决定的。如果 v 没有被 volatile 修饰，编译器是可以对 x、v 的赋值语句进行重排的。 不知道我的理解是否有问题？","like_count":24,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441603,"discussion_content":"“x=42” Happens-Before 写变量 “v=true”\n是因为程序顺序就是这么写的：x=42；v=true\n\n这个案例是综合了 程序的顺序规则+传递规则+volatile 规则\n\n这三这个规则组合在一起就是你所谓的：“而是有 volatile 决定的”。编译器优化要遵循所有的HB规则。所有，不是一条。所以只有把他们组合在一起才有意义。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551711470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/4d/1d1a1a00.jpg","nickname":"magict4","note":"","ucode":"CB6F063D881AAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103896,"discussion_content":"二刷中……，谢谢老师的回复！\n\n看到很多同学一直在纠结指令重排的问题，对于顺序规则来说，是无需考虑指令重排问题的。\n\n引用自 Oracle 文档：https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5\n> If x and y are actions of the same thread and x comes before y in program order, then hb(x, y)\n注意文中的 &#34;program order&#34;，就是源代码顺序的意思。\n\n如果大家还是好奇“指令重排”与“happen-before”之间的区别跟联系，强烈推荐@Jason在评论区贴的一篇文章：https://preshing.com/20130702/the-happens-before-relation/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577405817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1172145,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/b1/d00399c0.jpg","nickname":"心有林夕","note":"","ucode":"BC6E1AE557BFF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/4d/1d1a1a00.jpg","nickname":"magict4","note":"","ucode":"CB6F063D881AAC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":113149,"discussion_content":"那么如果v不是votatile变量，那么会重排序么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577890509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":103896,"ip_address":""},"score":113149,"extra":""}]}]},{"had_liked":false,"id":72001,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1551497136,"is_pvip":false,"replies":[{"id":"26098","content":"有可能通过global.obj 可能访问到还没有初始化的this对象<br>将this赋值给global.obj时，this还没有初始化完，this还没有初始化完，this还没有初始化完。","user_name":"作者回复","comment_id":72001,"uid":"1269969","ip_address":"","utype":1,"ctime":1551521969,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"104630712240","product_id":100023901,"comment_content":"想问一下老师最后关于逸出的例子，是因为有可能通过global.obj 可能访问到还没有初始化的this对象吗，但是将this赋值给global.obj不也是初始化时才赋值的吗，这部分不太理解，请老师指点一下","like_count":24,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441422,"discussion_content":"有可能通过global.obj 可能访问到还没有初始化的this对象\n将this赋值给global.obj时，this还没有初始化完，this还没有初始化完，this还没有初始化完。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551521969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532984,"discussion_content":"是的 这就是经典的this逃逸 这些在kafka的producer构造函数里还是存在的。但是consumer构造函数里还有 \n我个人感觉最初不是一批人同时写的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637746280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/a0/d308434e.jpg","nickname":"StarKing","note":"","ucode":"EB825CFA70AC1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14598,"discussion_content":"简单的说,此魔童在别的区域(医院)出生了,但这个受访的医院根本不知道(对其不可见),而 global.obj指向了一个未知的区域(医院).不能保证所有的医院都能及时得知.  如果 global.obj显示声明volatile 则问题解决.所有的医院从某个信息中心同步刷新获取消息,得关此童的信息.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568772656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71960,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1551492465,"is_pvip":false,"replies":[{"id":"26092","content":"你的理解是对的，volatile的实现就是这样的。指导JVM这么实现的规范就是内存模型。这个专栏的侧重点是让大家学会写并发程序，至于底层是怎么实现的，有精力和兴趣的同学，可以自己来把握。","user_name":"作者回复","comment_id":71960,"uid":"1269969","ip_address":"","utype":1,"ctime":1551521149,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"96040772977","product_id":100023901,"comment_content":"&#47;&#47; 以下代码来源于【参考 1】<br>class VolatileExample {<br>  int x = 0;<br>  volatile boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      &#47;&#47; 这里 x 会是多少呢？<br>    }<br>  }<br>}<br><br><br>感觉老师对这个volatile变量规则这块讲的有点草率，volatile变量的写对于读是可见的，对于程序来说，也就是线程A执行write中的v=true对于reader中的v==true是可见的 ，但是这对于x有什么关系？x并没有被volatile修饰。<br>根据我的理解，volatile强制所修饰的变量及它前边的变量刷新至内存，并且volatile禁止了指令的重排序。<br> <br>望指正<br>","like_count":22,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441411,"discussion_content":"你的理解是对的，volatile的实现就是这样的。指导JVM这么实现的规范就是内存模型。这个专栏的侧重点是让大家学会写并发程序，至于底层是怎么实现的，有精力和兴趣的同学，可以自己来把握。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551521149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282575,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/0f/cff30522.jpg","nickname":"江湖夜雨","note":"","ucode":"C64913C7000899","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2334,"discussion_content":"是的，按照老师的说法，如果volatile不修饰变量v，根据1，3也会导致x=42,这样让我们理解存在误区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563496214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1407983,"avatar":"https://static001.geekbang.org/account/avatar/00/15/7b/ef/ae5458c7.jpg","nickname":"王骞","note":"","ucode":"E5A88F3BA2634E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1282575,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/0f/cff30522.jpg","nickname":"江湖夜雨","note":"","ucode":"C64913C7000899","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70922,"discussion_content":"如果volatile不修饰变量v，x有时候是0有时候是42，无法保证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575383358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2334,"ip_address":""},"score":70922,"extra":""},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1282575,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/0f/cff30522.jpg","nickname":"江湖夜雨","note":"","ucode":"C64913C7000899","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87678,"discussion_content":"x v可能会发生指令重排","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576676963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2334,"ip_address":""},"score":87678,"extra":""}]}]},{"had_liked":false,"id":72727,"user_name":"小麦","can_delete":false,"product_type":"c1","uid":1216881,"ip_address":"","ucode":"55C7199A0D5659","user_header":"https://static001.geekbang.org/account/avatar/00/12/91/71/0b16655d.jpg","comment_is_top":false,"comment_ctime":1551706437,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"83156085061","product_id":100023901,"comment_content":"@发条橙子 ... <br>有问题吧，我是这样理解的，第一条规则是串行语义，在单线程的场景下，优化后的结果会与顺序执行一致，但是不代表对x的写操作会比对v的写先执行，所以多线程下会出现问题。加volatile关键字后，volatile变量在写操作之后会插入一个store屏障（Store屏障，是x86的”sfence“指令，强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存。这会使得程序状态对其它CPU可见，这样其它CPU可以根据需要介入。--并发编程网），所以禁止了重排序，这才保证了对x的写操作会比对v的写先执行，然后再根据volatile变量规则跟传递性原则，才保证了x=42对线程B可见。<br><br>","like_count":19,"discussions":[{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88278,"discussion_content":"把store缓冲区的数据都刷到CPU缓存。这会使得程序状态对其它CPU可见。这句话有误导，最后应该会把数据刷到“内存”中，这样才 使得程序状态对其它CPU可见","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576684901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72082,"user_name":"强哥","can_delete":false,"product_type":"c1","uid":1206726,"ip_address":"","ucode":"3B8DC780FE4EF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/c6/513df085.jpg","comment_is_top":false,"comment_ctime":1551516472,"is_pvip":false,"replies":[{"id":"26109","content":"咱们这个专栏还是专注于并发相关的部分，我怕有人说挂羊头卖狗肉","user_name":"作者回复","comment_id":72082,"uid":"1269969","ip_address":"","utype":1,"ctime":1551523225,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"61681058616","product_id":100023901,"comment_content":"关于java内存模型、jvm内存结构及java对象模型分别深入讲解一下，这样效果更好一些。","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441452,"discussion_content":"咱们这个专栏还是专注于并发相关的部分，我怕有人说挂羊头卖狗肉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551523225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213078,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","nickname":"mghio","note":"","ucode":"74883EDE4FD0DC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552963,"discussion_content":"Java 内存模型可以看看 Doug Lea 并发大师的这个 http://www.cs.umd.edu/~pugh/java/memoryModel","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645670466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252034,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0qUU5bc3kVeO0ZTJliau1dHMZglMib72gelIgKXew4RFDdAHsicodWgdaCwSAWetIuVaFwIzb2fFHw/132","nickname":"广安门下","note":"","ucode":"553A6B40FB3C9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37434,"discussion_content":"我也觉得是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571618500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72716,"user_name":"鸠翱","can_delete":false,"product_type":"c1","uid":1116568,"ip_address":"","ucode":"7D498AF2BC4289","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/98/b11c372b.jpg","comment_is_top":false,"comment_ctime":1551701713,"is_pvip":false,"replies":[{"id":"26356","content":"是这样。","user_name":"作者回复","comment_id":72716,"uid":"1269969","ip_address":"","utype":1,"ctime":1551710244,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"57386276561","product_id":100023901,"comment_content":"对于@Junzi的问题：<br>x=45; &#47;&#47; 1<br>v=true; &#47;&#47; 2<br>这两行会不会导致指令重排？ 答：不会<br>如果这两行重排序了，那么线程B读取到read()的时候也有可能出现x=0，也就是说线程B看到了v=true却没又看到x=45，这不符合第一条规则（请问老师 这么理解对不对）<br>我课外查询了一下，从实现方法上，volatile的读写前后会插入内存屏障，保证一些操作是无法没重排序的，其中就有对于volatile的写操作之前的动作不会被重排序到之后","like_count":13,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441706,"discussion_content":"是这样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551710244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188517,"avatar":"http://thirdwx.qlogo.cn/mmopen/g7TWmGqjoiaSFWknFpTPAia5rPOmzEZiaGK8icd5HGEXlfaYJBoKvLn5BkqGkyTZOqDTC3NMHXUbH3tdLJzicAyickRYdP4xcM3ajia/132","nickname":"sudo","note":"","ucode":"EA0F8116999557","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6944,"discussion_content":"其实不是因为规则1,假设重排了\nV=ture\nX=45\n\n线程b看到v=true x=0也去可能的。并没有打破volatile hb规则。规则1说的顺序性，我个人理解是编译后的顺序，而不是我们肉眼看到的顺序。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567182842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1585829,"avatar":"https://static001.geekbang.org/account/avatar/00/18/32/a5/9868cd56.jpg","nickname":"southday","note":"","ucode":"4A8FB63D35F6E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2028,"discussion_content":"“对于volatile的写操作之前的动作不会被重排序到之后”，这句话怎么理解呢？这些动作的作用对象仅限于被volatile修饰的变量，还是包括其他内容呢？能不能贴一下所查资料的链接呀，谢谢 :-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563185273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87367,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1555578004,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"48800218260","product_id":100023901,"comment_content":"对于hb的第一条规则：程序的顺序性规则理解了好久，终于明白了。<br>在一个线程中，按照程序顺序，前面的操作hb于后面的操作，这里的程序顺序是指<br>程序一定是按照顺序执行的（也可能是排序之后的顺序）,并不是指代码书写的先后顺序；<br>比如：x = 42; v = true; 因为v是volatile修饰的，所以x=42一定是先于v=true执行，所以x=42操作hb于v=true;<br>如果v不是volatile修饰的，则由于指令重排指向顺序可能是：x=42;v=true;（1）或者v=true;x=42;（2）<br>如果是第一种顺序则按照规则1，x=42 hb于v=true;第二种顺序则按照规则1，v=true hb于x=42，所以当v=true时，x不一定是42","like_count":11,"discussions":[{"author":{"id":1050114,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoG7YWJ0WsYoLalnJvPmKktLlfMicFg1fEzzgDgCcBgYoiaqILD4yAGwicWVC7iberRlAqNflL67Ju1g/132","nickname":"无意","note":"","ucode":"BD1A58F6F981BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345611,"discussion_content":"赞同这种理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611753586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1367048,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","nickname":"陈斌","note":"","ucode":"B639AB5F6AA03D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342900,"discussion_content":"@作者 对不对呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610872353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82763,"user_name":"王位庆","can_delete":false,"product_type":"c1","uid":1180978,"ip_address":"","ucode":"D480AEA92894FE","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/32/7440d47d.jpg","comment_is_top":false,"comment_ctime":1554302139,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48798942395","product_id":100023901,"comment_content":"@Junzi，您提的问题刚开始我也很疑惑，但查看了java并发编程的艺术，书上写了jdk1.5之后，增强了volatile的内存含义，限制了编译器和处理器对volatile变量和普通变量的重排序。p47页","like_count":11,"discussions":[{"author":{"id":1124766,"avatar":"https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg","nickname":"tracer","note":"","ucode":"AE2BC047DB7D7D","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128439,"discussion_content":"原来如此，JSR133之前会对下面代码进行重排序，之后增强了volatile的内存语义，严格限制编译器和处理器对volatile变量与普通变量的重排序\nx=45; // 1\nv=true; // 2","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578639860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71945,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1551491155,"is_pvip":true,"replies":[{"id":"26089","content":"多谢鼓励啊！","user_name":"作者回复","comment_id":71945,"uid":"1269969","ip_address":"","utype":1,"ctime":1551520488,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"48796131411","product_id":100023901,"comment_content":"我觉得课后题其实就是利用happenbefore规则去构建abc的写入happenfore于另外一个线程的读取。而6条规则中传递性规则是纽带，然后采用比如规则4，就是把abc的赋值加入一同步块，并先执行，同时另外一个线程申请同一把锁即可。其他的也类似。<br><br>java内存模型对程序员来说提供了按需禁止缓存禁止指令重排的方法。这是我第一次看到这么简单又深刻的解释，老师棒棒哒！！！","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441407,"discussion_content":"多谢鼓励啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551520488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72118,"user_name":"wang","can_delete":false,"product_type":"c1","uid":1161200,"ip_address":"","ucode":"5D569805C6A923","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/f0/a570f68a.jpg","comment_is_top":false,"comment_ctime":1551524331,"is_pvip":false,"replies":[{"id":"26157","content":"不加volatile，多线程会有问题","user_name":"作者回复","comment_id":72118,"uid":"1269969","ip_address":"","utype":1,"ctime":1551544906,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"40206229995","product_id":100023901,"comment_content":"老师。对呀 发条橙子 提到如果不加 volatile，当读到v的时候，x就一定能读到42，使用的是使用的是规则1。<br>我认为不对呀，规则一不是只适用于单线程吗？而读取v是在另一个线程，所以不能使用规则一判断吧。<br>希望老师可以解释一下，谢谢","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441468,"discussion_content":"不加volatile，多线程会有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551544906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71996,"user_name":"飞翔的花狸猫","can_delete":false,"product_type":"c1","uid":1143473,"ip_address":"","ucode":"F3BA6126E02059","user_header":"https://static001.geekbang.org/account/avatar/00/11/72/b1/a8b272ef.jpg","comment_is_top":false,"comment_ctime":1551495910,"is_pvip":false,"replies":[{"id":"26097","content":"那小说得写的有多烂！","user_name":"作者回复","comment_id":71996,"uid":"1269969","ip_address":"","utype":1,"ctime":1551521883,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"40206201574","product_id":100023901,"comment_content":"Happen-before 这个知识点终于理解了，追并发专栏比以前看小说还勤快，盼老师速更啊","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441421,"discussion_content":"那小说得写的有多烂！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551521883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2756739,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/10/83/0facd0eb.jpg","nickname":"利威尔兵长","note":"","ucode":"FDE0BD5BFB1B4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":535921,"discussion_content":"是老师您写的太好啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638607396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":441421,"ip_address":""},"score":535921,"extra":""}]}]},{"had_liked":false,"id":72370,"user_name":"青冰白夜","can_delete":false,"product_type":"c1","uid":1307569,"ip_address":"","ucode":"3F71F1027E8374","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/b1/0429aa3b.jpg","comment_is_top":false,"comment_ctime":1551599891,"is_pvip":false,"replies":[{"id":"26209","content":"int func() {<br>  int i=0;<br>  int j=1;<br>  return i+j;<br>} <br>对于上面这个函数，前面两行的顺序，对于执行结果没有影响。所以编译器可以优化。<br><br>这里所有的happens-before规则，只是说你可以利用他们推演程序运行的结果。编译器优化后的结果一定==你推演的结果。至于中间过程，编译器还是可以优化的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551602996,"ip_address":"","comment_id":72370,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35911338259","product_id":100023901,"comment_content":"那老师，就我的那个问题，<br>int i=0 ;<br>int j=1;<br>您也说了，可能重排序成<br>int j=1;<br>int i=0;<br>那int i=0明明是在前面，这重排序在后面，不就不符合happens-befor的程序顺序性规则了吗？","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441560,"discussion_content":"int func() {\n  int i=0;\n  int j=1;\n  return i+j;\n} \n对于上面这个函数，前面两行的顺序，对于执行结果没有影响。所以编译器可以优化。\n\n这里所有的happens-before规则，只是说你可以利用他们推演程序运行的结果。编译器优化后的结果一定==你推演的结果。至于中间过程，编译器还是可以优化的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551602996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72536,"user_name":"柳絮飞","can_delete":false,"product_type":"c1","uid":1443478,"ip_address":"","ucode":"FD3823B3482A1C","user_header":"https://static001.geekbang.org/account/avatar/00/16/06/96/6ae77c39.jpg","comment_is_top":false,"comment_ctime":1551666158,"is_pvip":true,"replies":[{"id":"26346","content":"内存模型的叫法，是指定jsr规范的人定的。堆栈可以叫内存结构","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551709645,"ip_address":"","comment_id":72536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31616437230","product_id":100023901,"comment_content":"王老师，请教一下，为什么这些编译优化规则叫内存模型？jvm的堆和栈应该叫什么？多谢！这样叫是不是容易让人误解","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441637,"discussion_content":"内存模型的叫法，是指定jsr规范的人定的。堆栈可以叫内存结构","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551709645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78108,"user_name":"tracer","can_delete":false,"product_type":"c1","uid":1124766,"ip_address":"","ucode":"AE2BC047DB7D7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg","comment_is_top":false,"comment_ctime":1553071708,"is_pvip":false,"replies":[{"id":"28485","content":"厉害👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553081388,"ip_address":"","comment_id":78108,"utype":1}],"discussion_count":1,"race_medal":1,"score":"27322875484","product_id":100023901,"comment_content":"测试重排序可以使用OpenJDK CodeTools 项目的jcstress 工具, 详细见极客时间深入拆解虚拟机13讲和https:&#47;&#47;wiki.openjdk.java.net&#47;display&#47;CodeTools&#47;jcstress","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443969,"discussion_content":"厉害👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553081388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77161,"user_name":"life is short, enjoy more.","can_delete":false,"product_type":"c1","uid":1074805,"ip_address":"","ucode":"3B5F37D30790A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg","comment_is_top":false,"comment_ctime":1552873413,"is_pvip":false,"replies":[{"id":"28134","content":"指令可能会重排，把x=3排到后面<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552882229,"ip_address":"","comment_id":77161,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23027709893","product_id":100023901,"comment_content":"新学生对本门课程的第一次留言~<br>&#47;&#47; 以下代码来源于【参考 1】<br>final int x;<br>&#47;&#47; 错误的构造函数<br>public FinalFieldExample() { <br>  x = 3;<br>  y = 4;<br>  &#47;&#47; 此处就是讲 this 逸出，<br>  global.obj = this;<br>}<br><br>老师你好，这个例子我不是很理解，看到你给其他同学的答复是，this可能没有初始化完。但是这不就是一个构造函数吗，this位于构造函数的最后一行，而且x已经赋值了，为什么可能存在其他线程读到x==0的情况呢？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443611,"discussion_content":"指令可能会重排，把x=3排到后面\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552882229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73913,"user_name":"Geek_faf1c5","can_delete":false,"product_type":"c1","uid":1446395,"ip_address":"","ucode":"E297E4E3487CE4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9kA8IicSJFKtglFv10EHGmLgCRGET22HylnXB7pT0xibjOYtDia0cib4uuSnvOJSINeoF71LAKU1F4A/132","comment_is_top":false,"comment_ctime":1552031558,"is_pvip":true,"replies":[{"id":"27009","content":"网上是有这么说法，你可以理解为cpu缓存和线程本地内存是一回事。但是我没有找到线程本地内存的官方出处。不敢人云亦云，所以专栏里就没有用这个概念。如果你感兴趣，可以找找。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552059028,"ip_address":"","comment_id":73913,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23026868038","product_id":100023901,"comment_content":"老师您好：<br>cpu缓存导致的可见性  cpu运行的单位是线程 而每个线程有本地内存 因为有线程本地内存的存在 也会导致可见性问题  那么线程的本地内存和cpu缓存是一会事吗  有什么关联？？？？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442334,"discussion_content":"网上是有这么说法，你可以理解为cpu缓存和线程本地内存是一回事。但是我没有找到线程本地内存的官方出处。不敢人云亦云，所以专栏里就没有用这个概念。如果你感兴趣，可以找找。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552059028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72777,"user_name":"Geek_c42505","can_delete":false,"product_type":"c1","uid":1232899,"ip_address":"","ucode":"6421EB85640C44","user_header":"https://static001.geekbang.org/account/avatar/00/12/d0/03/2e632d36.jpg","comment_is_top":false,"comment_ctime":1551715519,"is_pvip":false,"replies":[{"id":"26449","content":"很全面了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551787425,"ip_address":"","comment_id":72777,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23026551999","product_id":100023901,"comment_content":"1. 使用volatile修饰abc -禁止cpu缓存直接从内存获取和volatile写 happens before volatile读。<br>2. synchronized 代码块中操作abc 解锁happens before 加锁。<br>3. 线程A操作共享变量abc然后start方法启动B线程 B线程中可见abc操作。<br>4. 线程A操作共享变量abc，B join A 对于B线程可见。<br>不知道叙述的是否准确，忘老师指正","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441740,"discussion_content":"很全面了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551787425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72763,"user_name":"Yesterday","can_delete":false,"product_type":"c1","uid":1010409,"ip_address":"","ucode":"6A416B7906C1E0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/e9/d76511d8.jpg","comment_is_top":false,"comment_ctime":1551712578,"is_pvip":false,"replies":[{"id":"26448","content":"别想禁用指令重排的事，就用顺序性规则+传递行规则+volatile规则来推断就可以了<br>边界就是只要给volatile赋值成功，那么这个赋值语句之前所有代码的执行结果都对其他线程可见<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551787373,"ip_address":"","comment_id":72763,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23026549058","product_id":100023901,"comment_content":"我有一个问题一直弄不明白，volatile 禁用指令重排的边界如何确定？synchornzied 包裹的代码块有明确的边界，不管是否在临界区内的代码是否调用其他方法。<br><br>而对 volatile 类型变量前后的变量的操作并没有明确的语义上的边界？查了很多资料，仍然没有找到答案，希望老师解答一下。<br>","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441731,"discussion_content":"别想禁用指令重排的事，就用顺序性规则+传递行规则+volatile规则来推断就可以了\n边界就是只要给volatile赋值成功，那么这个赋值语句之前所有代码的执行结果都对其他线程可见\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551787373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289379,"discussion_content":"其实这么说的话应该不叫“禁止指令重排”；而是保证重排后的效果能保证赋值成功时，前面语句的执行结果对其他线程可见。重不重排，如何实现这个是另外的问题了。老师讲的是规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594083954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72464,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1551634908,"is_pvip":false,"replies":[{"id":"26338","content":"在CPU层面，可能会锁总线，将其他核里的缓存置失效。但是在Java里面volatile 除了这些之外，还涉及到H-B规则。所以volatile 不仅仅是你理解的这些。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551708746,"ip_address":"","comment_id":72464,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23026471388","product_id":100023901,"comment_content":"我理解的volatile 在操作系统层面，在修改变量的值时候，cpu缓存锁还是要加锁，修改完成后从缓存写入内存，锁才释放，锁的过程中，其他线程读是要等待写入完成，只不过这个锁的时间很短，所以一般感受不出来吧，不然线程a写入还没完成，线程b读取变量值不是最新的，这才能保证写对读可见性，望指正","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441600,"discussion_content":"在CPU层面，可能会锁总线，将其他核里的缓存置失效。但是在Java里面volatile 除了这些之外，还涉及到H-B规则。所以volatile 不仅仅是你理解的这些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551708746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326235,"discussion_content":"老的cpu架构应该是锁的总线，而现在的应该是使用的自动“嗅探”技术，是cpu实时检测数据总线，自己缓存的变量值是否变化，如果变了，就把缓存置位无效，然后在读书时就去主内存中读取","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605568616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149745,"user_name":"FATMAN89","can_delete":false,"product_type":"c1","uid":1175430,"ip_address":"","ucode":"48A67FB47B3C5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/86/12f95d66.jpg","comment_is_top":false,"comment_ctime":1573364980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18753234164","product_id":100023901,"comment_content":"我只能说留言区的大神太多了","like_count":4},{"had_liked":false,"id":90050,"user_name":"王二北","can_delete":false,"product_type":"c1","uid":1100655,"ip_address":"","ucode":"D9090E28B3E1F0","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/6f/c78ef1cf.jpg","comment_is_top":false,"comment_ctime":1556379144,"is_pvip":false,"replies":[{"id":"32336","content":"你说的是对的！！！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556464329,"ip_address":"","comment_id":90050,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18736248328","product_id":100023901,"comment_content":"&quot;分析一下，为什么 1.5 以前的版本会出现 x = 0 的情况呢？我相信你一定想到了，变量 x 可能被 CPU 缓存而导致可见性问题。”， 这句话是不是有问题，线程B读取到变量x为0，不是因为cpu缓存导致的可见性问题，而应该是 指令重排导致的。","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448369,"discussion_content":"你说的是对的！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556464329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2220763,"avatar":"https://static001.geekbang.org/account/avatar/00/21/e2/db/97c6f756.jpg","nickname":"_patrick","note":"","ucode":"B24C6EEBCABB94","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571823,"discussion_content":"如果对JMM 内存模型理解的再深入一点，就会发现老师说的也是对的。 读到x=0 是因为可见性问题，而重排序又引发了可见性的问题。 还有重排序 包括 cpu指令重排序、编译器编译时重排， 内存系统重排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652423504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84790,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1554907885,"is_pvip":false,"replies":[{"id":"30459","content":"synchronized 的分析没有问题，其他线程直接访问还可能不是最新值，我理解直接就是没有使用任何同步手段。<br>即便用 synchronized，用法不对，也达不到效果。<br>语言本来就不准确，留言的同学，写的都很随意，实在不太适合以批判的眼光来看待。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554910369,"ip_address":"","comment_id":84790,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18734777069","product_id":100023901,"comment_content":"@发条橙子… 的思考题分析，有些不太准确吧，例如评论里指出的程序顺序性。还有 synchronized 的分析也不太准确吧，synchronized(abc) 可能保证后续操作可见。<br><br>老师是否应该在回复评论时指正，否则童鞋们看到“分析得比我好”的回复，很大可能就照着分析来理解了。","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446448,"discussion_content":"synchronized 的分析没有问题，其他线程直接访问还可能不是最新值，我理解直接就是没有使用任何同步手段。\n即便用 synchronized，用法不对，也达不到效果。\n语言本来就不准确，留言的同学，写的都很随意，实在不太适合以批判的眼光来看待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554910369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102659,"discussion_content":"语言本来就不准确，留言的同学，写的都很随意 -》 但老师的回复还是要指出问题 不能太简单 不然真的是“很大可能就照着分析来理解”","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577359042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74930,"user_name":"Hello,Hello,Hello Kitty","can_delete":false,"product_type":"c1","uid":1185329,"ip_address":"","ucode":"8769FB28FE6399","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/31/929f811e.jpg","comment_is_top":false,"comment_ctime":1552314585,"is_pvip":false,"replies":[{"id":"27300","content":"这方面，我也很难通透地讲清楚从Java代码到CPU指令的过程，单线程保证x可见很容易，多线程x跟v不能都同时在一个寄存器里。voatile v刷新回内存的时候，所有CPU缓存里的值都会失效。下次访问就能访问到新的了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552316317,"ip_address":"","comment_id":74930,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18732183769","product_id":100023901,"comment_content":"x = 42;<br>v = true;<br>老师 我想请假一下 x并没有加volatile修饰 JVM是如何保证x的结果也是被可见呢 是因为x跟v都在同一个寄存器中 voatile修饰的v被刷新回内存的时候 整个寄存器中的值都被刷新到内存中了吗？<br>","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442746,"discussion_content":"这方面，我也很难通透地讲清楚从Java代码到CPU指令的过程，单线程保证x可见很容易，多线程x跟v不能都同时在一个寄存器里。voatile v刷新回内存的时候，所有CPU缓存里的值都会失效。下次访问就能访问到新的了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552316317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72952,"user_name":"zyl","can_delete":false,"product_type":"c1","uid":1100717,"ip_address":"","ucode":"2F872341AC8D7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq65BWyJb39rq0Qgx1fnELVSZGGuLY6oBmYcmFj2Oqy9iauAWfbqO5U63I22Uo1POrrTp7tFWXibxvg/132","comment_is_top":false,"comment_ctime":1551758582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18731627766","product_id":100023901,"comment_content":"底层都是加store屏障 load屏障来保障可见性，立即从写缓冲区刷新数据到cache或主内存，立即重新read数据，写缓冲区没刷新触发写缓冲区刷新，拉取新数据。<br>加acquire和release屏障来禁止重排序","like_count":4},{"had_liked":false,"id":72302,"user_name":"封万里","can_delete":false,"product_type":"c1","uid":1439905,"ip_address":"","ucode":"5DD447B5DAFA3A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/a1/8780f900.jpg","comment_is_top":false,"comment_ctime":1551581966,"is_pvip":false,"replies":[{"id":"26201","content":"没有禁止指令重排，要求编译器重排后的结果==顺序执行的结果。所以你可以用顺序执行来推断结果。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551591260,"ip_address":"","comment_id":72302,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18731451150","product_id":100023901,"comment_content":"happens-before的第一个规则实际上禁止了指令重排序，可以这么理解吗？希望老师解答一下呢","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441531,"discussion_content":"没有禁止指令重排，要求编译器重排后的结果==顺序执行的结果。所以你可以用顺序执行来推断结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551591260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71989,"user_name":"倚梦流","can_delete":false,"product_type":"c1","uid":1435045,"ip_address":"","ucode":"7CB442D629534B","user_header":"https://static001.geekbang.org/account/avatar/00/15/e5/a5/fae40ac3.jpg","comment_is_top":false,"comment_ctime":1551495220,"is_pvip":false,"replies":[{"id":"26096","content":"是这样的，多个线程操作一个实例。<br>共享变量不一定用static修饰<br>结果都一样","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551521832,"ip_address":"","comment_id":71989,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18731364404","product_id":100023901,"comment_content":"这里实例里的共享变量为什么没有用static修饰？是因为这里的线程操作的都是同一个实例，所以共享变量不需要用static修饰吗？如果用了static，结果应该也是一样的吧","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441419,"discussion_content":"是这样的，多个线程操作一个实例。\n共享变量不一定用static修饰\n结果都一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551521832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72803,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1551740325,"is_pvip":false,"replies":[{"id":"26467","content":"如果不加 volatile，在单线程里<br> x = 42;<br> v = true;<br> if (v==true) { <br>    &#47;&#47;这里x一定===42<br> }<br><br>多线程里没办法确定x是0还是42<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551793188,"ip_address":"","comment_id":72803,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14436642213","product_id":100023901,"comment_content":"老师有个问题是关于A happen before B的判断，在第一个例子中x与v虽然一个在前一个在后，但并没有直接关联，仅仅是根据代码的前后就能判断happen before吗？如果v不加volati修饰又是如何呢？<br>&#47;&#47; 以下代码来源于【参考 1】<br>class VolatileExample {<br>  int x = 0;<br>  volatile boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      &#47;&#47; 这里 x 会是多少呢？<br>    }<br>  }<br>}<br>","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441757,"discussion_content":"如果不加 volatile，在单线程里\n x = 42;\n v = true;\n if (v==true) { \n    //这里x一定===42\n }\n\n多线程里没办法确定x是0还是42\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551793188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71985,"user_name":"7","can_delete":false,"product_type":"c1","uid":1114093,"ip_address":"","ucode":"10A6E57A027D42","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","comment_is_top":false,"comment_ctime":1551494901,"is_pvip":false,"replies":[{"id":"26095","content":"太全面了！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551521686,"ip_address":"","comment_id":71985,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14436396789","product_id":100023901,"comment_content":"volatile标记改变量，<br>syn加锁，<br>lock加锁，<br>join，<br>变为final的静态变量？<br>忘老师点评，谢谢","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441417,"discussion_content":"太全面了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551521686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1313164,"avatar":"https://static001.geekbang.org/account/avatar/00/14/09/8c/daaee028.jpg","nickname":"Shaozw","note":"","ucode":"E749A517A9A904","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242045,"discussion_content":"变为final修饰的静态变量，emmm，如果是Java基础类型，那就没法改变值了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587460917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245733,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1599036742,"is_pvip":false,"replies":[{"id":"90435","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1599176019,"ip_address":"","comment_id":245733,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10188971334","product_id":100023901,"comment_content":"逸出：<br>在构造方法中将this 复制给别的变量，意味着，构造方法还没结束，对象this 就给别人使用了。对象还没初始化完成，别人就使用，类似双层校验创建单例的例子。<br>逸出要避免，要避免这种写法。<br>同时，如果在构造方法中对成员变量赋初始值，比如this.x = x，这样的代码在编译的时候，也会被重排序，将赋值操作重排序到构造方法之外，那么也就是，构造方法结束了，初始化完成了，这时候，别的线程先后可能会读取到俩个不同的值，一个没初始化的，一个初始化后的值。要避免这种情况的发送，就要用fianl，final修饰的变量，可以保证，不会被抽排序到构造方法之外，那么就保证了，只要别的线程拿到该对象的引用，那么改对象的fianl修饰的变量，别的线程一定是能读到在构造方法中初始化的值的，避免了上面同一变量，读取值俩次不一样的问题。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504972,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599176019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149635,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1125259,"ip_address":"","ucode":"7BF52ADBFD4F5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/8b/dd02189a.jpg","comment_is_top":false,"comment_ctime":1573296022,"is_pvip":false,"replies":[{"id":"57606","content":"用同步关键字解决","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573382270,"ip_address":"","comment_id":149635,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10163230614","product_id":100023901,"comment_content":"宝令老师，我查了一下，volatile在jdk1.5之前就存在了，您上文中说到的“直觉上看，应该是 42，那实际应该是多少呢？这个要看 Java 的版本，如果在低于 1.5 版本上运行，x 可能是 42，也有可能是 0；如果在 1.5 以上的版本上运行，x 就是等于 42。”，volatile 在JDK1.5之前并没有实现HB原则，那在JDK1.5之前volatile 的存在意义是什么呢，以及JDK1.5之前怎么解决这种问题呢","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473921,"discussion_content":"用同步关键字解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573382270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141097,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1571114228,"is_pvip":false,"replies":[{"id":"54604","content":"也是这样，线程才是CPU最小的调度单元","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571142304,"ip_address":"","comment_id":141097,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10161048820","product_id":100023901,"comment_content":"在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。<br>王老师，这个标记为休眠状态，并让出CPU是在一个时间片结束的时候，还是在一个时间片内呢？<br>作者回复: 时间片内主动释放CPU使用权，无需等到结束<br><br>王老师，这个讲的是进程，线程也是这样吗？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470668,"discussion_content":"也是这样，线程才是CPU最小的调度单元","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571142304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138059,"user_name":"delete is create","can_delete":false,"product_type":"c1","uid":1147979,"ip_address":"","ucode":"A8C751219A7746","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/4b/e4738ba8.jpg","comment_is_top":false,"comment_ctime":1570004057,"is_pvip":true,"replies":[{"id":"53086","content":"只是java写的伪码，不保证可以执行","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570010747,"ip_address":"","comment_id":138059,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159938649","product_id":100023901,"comment_content":"老师  为什么有的实例代码复制到我本地是报错的，比如最后一段实例代码，final int x ； 不初始化会报错的，我本地jdk是1.8的","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469366,"discussion_content":"只是java写的伪码，不保证可以执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570010747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129905,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1618607,"ip_address":"","ucode":"8179D167D99CB9","user_header":"https://static001.geekbang.org/account/avatar/00/18/b2/af/81303f5a.jpg","comment_is_top":false,"comment_ctime":1567322918,"is_pvip":false,"replies":[{"id":"48630","content":"官方的是要加上这俩的，这个不是别人的个人总结","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567426567,"ip_address":"","comment_id":129905,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157257510","product_id":100023901,"comment_content":"请问老师，在有的文章中看到还有两个规则：<br><br>1.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>2.对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始<br><br>这两个规则可否算是对老师所讲的六个规则的补充，还是说这只是别人的个人理解的总结","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465708,"discussion_content":"官方的是要加上这俩的，这个不是别人的个人总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567426567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90647,"user_name":"后端学长","can_delete":false,"product_type":"c1","uid":1178011,"ip_address":"","ucode":"7E82F2B5930CD5","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/9b/dc074a7e.jpg","comment_is_top":false,"comment_ctime":1556598111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10146532703","product_id":100023901,"comment_content":"老师有个疑问?被volatile关键字修饰的变量，做写操作的时候，文章中的意思直接操作内存，而相关书籍中会说操作缓存，只是Cpu立马会发出指令将缓存中的数据刷新到内存中？具体哪一个比较正确呢？","like_count":2},{"had_liked":false,"id":86712,"user_name":"devil","can_delete":false,"product_type":"c1","uid":1259625,"ip_address":"","ucode":"BB6090411BAA23","user_header":"https://static001.geekbang.org/account/avatar/00/13/38/69/864569a4.jpg","comment_is_top":false,"comment_ctime":1555429638,"is_pvip":false,"replies":[{"id":"31309","content":"加上传递性就有关系了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555510895,"ip_address":"","comment_id":86712,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10145364230","product_id":100023901,"comment_content":"规则1和volatile有什么关系？有volatile 变量才会遵循这个规则吗？如果例子中没有volatile是不是就不遵循顺序规则了","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447132,"discussion_content":"加上传递性就有关系了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555510895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76623,"user_name":"sakura","can_delete":false,"product_type":"c1","uid":1449550,"ip_address":"","ucode":"D382C3325F2F59","user_header":"https://static001.geekbang.org/account/avatar/00/16/1e/4e/56a0b904.jpg","comment_is_top":false,"comment_ctime":1552647525,"is_pvip":false,"replies":[{"id":"27949","content":"不是，有序性和指令重排有关，即便没有有序性问题，也有可能存在竞态条件问题<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552653230,"ip_address":"","comment_id":76623,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10142582117","product_id":100023901,"comment_content":"老师 您好<br>我看Java并发编程实践中的竞态条件和有序性的描述很像 请问其中竞态条件就是有序性吗？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443381,"discussion_content":"不是，有序性和指令重排有关，即便没有有序性问题，也有可能存在竞态条件问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552653230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73699,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1551960692,"is_pvip":false,"replies":[{"id":"26905","content":"对于初学者，你的这个解释虽然正确，但是不好理解。volatile在1.5以后不仅仅是禁用缓存<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551962163,"ip_address":"","comment_id":73699,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141895284","product_id":100023901,"comment_content":"文中说到volatile 为的是禁用缓存，这里我个人觉得说法欠妥，volatile 主要的作用应该是当修饰的变量被修改了，会立即刷回主缓存，同时其他cpu缓存改变量会失效，需要重新从主缓存刷新变量的值。所以从这层面上说volatile 其实还是有用缓存，只是效果和禁用缓存一样。个人理解。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442233,"discussion_content":"对于初学者，你的这个解释虽然正确，但是不好理解。volatile在1.5以后不仅仅是禁用缓存\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551962163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73362,"user_name":"乔宇佳","can_delete":false,"product_type":"c1","uid":1449240,"ip_address":"","ucode":"2EFFBDD4EC5907","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epUXpvIbKKeXWGL2l0CQo3Jwo6UUX0Jcia7I80Nd3RJs3aGiczXe81Ea534szRxLKhyAeZOiclzib8f2Q/132","comment_is_top":false,"comment_ctime":1551868386,"is_pvip":false,"replies":[{"id":"26726","content":"是的，我也觉得实际上不会重排。这个例子只是说理论上会出问题。你回答的比我要好。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551882285,"ip_address":"","comment_id":73362,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141802978","product_id":100023901,"comment_content":"关于Junzi的问题，你在自己说的时候已经回答了，因为重排后会影响结果，如果重排之后在读的时候可能会读到0<br>如果v之前有多条指令，那么之前的那多条指令会重排因为那不会影响结果，如果只有这两条，是不会重排的。<br><br>第一次回留言，语言组织的不太好，望老师指正！","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442042,"discussion_content":"是的，我也觉得实际上不会重排。这个例子只是说理论上会出问题。你回答的比我要好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551882285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73038,"user_name":"1620","can_delete":false,"product_type":"c1","uid":1104310,"ip_address":"","ucode":"C9222A5CE4723C","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/b6/4c498c17.jpg","comment_is_top":false,"comment_ctime":1551782453,"is_pvip":false,"replies":[{"id":"26511","content":"早知道我去写小说了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551797327,"ip_address":"","comment_id":73038,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141717045","product_id":100023901,"comment_content":"x=42 这个例子非常好 很炫  有一种追小说的感觉了 😄","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441885,"discussion_content":"早知道我去写小说了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551797327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72949,"user_name":"胡桥","can_delete":false,"product_type":"c1","uid":1055874,"ip_address":"","ucode":"673C3207614010","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/82/74ab79df.jpg","comment_is_top":false,"comment_ctime":1551758493,"is_pvip":false,"replies":[{"id":"26494","content":"并发问题，都是概率性的问题。线程不安全，也不是说每次都能重现。尤其是这种重排的。我也没能重现出来。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551795431,"ip_address":"","comment_id":72949,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141693085","product_id":100023901,"comment_content":"期待解答~<br>对volatile有个疑惑：我对您关于volatile的代码进行了修改，去掉了volatile：<br>public class VolatileExample {<br>\tprivate int x;<br>\tprivate boolean changed = false; <br>\tpublic void set(int x){<br>\t\tthis.x = x;<br>\t\tthis.changed = true;<br>\t}<br>\tpublic int get(){<br>\t\treturn x;<br>\t}<br>\tpublic boolean changed(){<br>\t\treturn changed;<br>\t}<br>}<br>然后我用一个线程A来写，另外一个线程B去读，线程B中如果发现没有没有change就sleep一秒。我发现即使不用volatile，两个线程也能(通过while等待)协调得很好。为什么？<br>这是我的测试代码：<br>public class TestVolatileExample {<br><br>\tstatic int pairCount = 1000;<br>\tstatic VolatileExample[] exps = new VolatileExample[pairCount];<br>\tstatic{<br>\t\tfor(int i = 0;i&lt;pairCount;i++){<br>\t\t\texps[i] = new VolatileExample();<br>\t\t}<br>\t}<br>\t<br>\t@Test<br>\tpublic void test() throws InterruptedException{<br>\t\tfinal int valuePair[][] = new int[pairCount][2];<br>\t\tThread[] threads = new Thread[pairCount*2];<br>\t\tfor(int i = 0;i&lt;pairCount;i++){<br>\t\t\tfinal int index = i;<br>\t\t\t&#47;&#47;final VolatileExample exp = new VolatileExample();<br>\t\t\t&#47;&#47;writer<br>\t\t\tThread writer = new Thread(new Runnable(){<br>\t\t\t\t@Override<br>\t\t\t\tpublic void run() {<br>\t\t\t\t\tVolatileExample exp = exps[index];<br>\t\t\t\t\tint val = new Random().nextInt(100);<br>\t\t\t\t\tvaluePair[index][0] = val;<br>\t\t\t\t\texp.set(val);<br>\t\t\t\t}<br>\t\t\t});<br>\t\t\twriter.start();<br>\t\t\tthreads[i*2] = writer;<br>\t\t\t&#47;&#47;reader<br>\t\t\tThread reader = new Thread(new Runnable(){<br>\t\t\t\t@Override<br>\t\t\t\tpublic void run() {<br>\t\t\t\t\tVolatileExample exp = exps[index];<br>\t\t\t\t\twhile(!exp.changed()){<br>\t\t\t\t\t\ttry {<br>\t\t\t\t\t\t\tThread.sleep(1);<br>\t\t\t\t\t\t} catch (InterruptedException e) {<br>\t\t\t\t\t\t\te.printStackTrace();<br>\t\t\t\t\t\t}<br>\t\t\t\t\t}<br>\t\t\t\t\tint val = exp.get();<br>\t\t\t\t\tvaluePair[index][1] = val;<br>\t\t\t\t}<br>\t\t\t\t<br>\t\t\t});<br>\t\t\treader.start();<br>\t\t\tthreads[i*2+1] = reader;<br>\t\t}<br>\t\tfor(Thread t : threads){<br>\t\t\tt.join();<br>\t\t}<br>\t\tfor(int i = 0;i&lt;pairCount;i++){<br>\t\t\tint write = valuePair[i][0];<br>\t\t\tint read =  valuePair[i][1];<br>\t\t\tSystem.out.println(write+&quot;,&quot; + read);<br>\t\t\tAssert.assertEquals(write,read);<br>\t\t}<br>\t}<br>}<br>","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441841,"discussion_content":"并发问题，都是概率性的问题。线程不安全，也不是说每次都能重现。尤其是这种重排的。我也没能重现出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551795431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72180,"user_name":"Alpha","can_delete":false,"product_type":"c1","uid":1001861,"ip_address":"","ucode":"60CA15A25EC796","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/85/3f161d95.jpg","comment_is_top":false,"comment_ctime":1551531751,"is_pvip":false,"replies":[{"id":"26159","content":"编译器可以调整顺序，但是要满足所有的happens before规则，如果冲突了，就是编译器优化错了。<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551545291,"ip_address":"","comment_id":72180,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141466343","product_id":100023901,"comment_content":"老师，第一条程序的顺序性规则 与 乱序执行是什么关系呢？<br>比如例子中第6行 `x = 42` happens-before 第7行 `v = true`，但是编译器有可能调整这两行语句的执行顺序的呀，这看起来是和这条happens-before规则冲突呢？希望老师能解答我的疑惑。<br>","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441490,"discussion_content":"编译器可以调整顺序，但是要满足所有的happens before规则，如果冲突了，就是编译器优化错了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551545291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72060,"user_name":"Tony Du","can_delete":false,"product_type":"c1","uid":1001661,"ip_address":"","ucode":"F5FCC400E615EA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/bd/6c7d4230.jpg","comment_is_top":false,"comment_ctime":1551509471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10141444063","product_id":100023901,"comment_content":"这篇让我对volatile的理解茅塞顿开，感谢！","like_count":2},{"had_liked":false,"id":71976,"user_name":"tracer","can_delete":false,"product_type":"c1","uid":1124766,"ip_address":"","ucode":"AE2BC047DB7D7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg","comment_is_top":false,"comment_ctime":1551493857,"is_pvip":false,"replies":[{"id":"26094","content":"代码块中有volatile，也挡不住被重排。但是重排后的结果一定符合happens-before规则。<br>b先读v可以啊，只是这个时候v==false","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551521667,"ip_address":"","comment_id":71976,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10141428449","product_id":100023901,"comment_content":"提一个可能比较幼稚的问题，参考1中的代码，volatile能保证不被重排序，但是volatile只修饰了v，意思是代码块中只要有一个volatile，代码块中都不会被重排序？<br>volatile变量规则说写操作对读操作可见，v是有初始值的，线程b先读v不可以吗？那如果线程a中多次修改了v的值呢？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441415,"discussion_content":"代码块中有volatile，也挡不住被重排。但是重排后的结果一定符合happens-before规则。\nb先读v可以啊，只是这个时候v==false","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551521667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71946,"user_name":"Jialin","can_delete":false,"product_type":"c1","uid":1112955,"ip_address":"","ucode":"12583269732A75","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/7b/2d4b38fb.jpg","comment_is_top":false,"comment_ctime":1551491230,"is_pvip":false,"replies":[{"id":"26090","content":"是这样!","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551520528,"ip_address":"","comment_id":71946,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141425822","product_id":100023901,"comment_content":"我主要从共享变量的状态(是否可以被修改)进行思考它在多线程环境下的可见性问题，如果一个变量仅仅只是可读，那么它本身不会存在线程不安全问题，使用final进行修饰；如果一个共享变量可读可写，那么就使用synchronized和volatile来保证它在多线程环境下的可见性。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441408,"discussion_content":"是这样!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551520528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71932,"user_name":"拨云见天","can_delete":false,"product_type":"c1","uid":1388409,"ip_address":"","ucode":"125FEE7AC7C2FF","user_header":"https://static001.geekbang.org/account/avatar/00/15/2f/79/61794fe2.jpg","comment_is_top":false,"comment_ctime":1551489441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10141424033","product_id":100023901,"comment_content":"@何方妖孽<br>你提的这个问题是java8的新特性之lambda表达式，可以学习下这个新特性，简化代码必备良药哦！","like_count":2},{"had_liked":false,"id":71924,"user_name":"LW","can_delete":false,"product_type":"c1","uid":1325297,"ip_address":"","ucode":"89820332658E98","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg","comment_is_top":false,"comment_ctime":1551487012,"is_pvip":false,"replies":[{"id":"26086","content":"看你这么说，我心情大好。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551519957,"ip_address":"","comment_id":71924,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141421604","product_id":100023901,"comment_content":"传递性规则是讲解让我茅塞顿开","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441397,"discussion_content":"看你这么说，我心情大好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551519957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277406,"user_name":"silence","can_delete":false,"product_type":"c1","uid":1326790,"ip_address":"","ucode":"407F847726B5E7","user_header":"https://static001.geekbang.org/account/avatar/00/14/3e/c6/e19b1008.jpg","comment_is_top":false,"comment_ctime":1612406902,"is_pvip":false,"replies":[{"id":"100815","content":"问题不是出在可见性，而是出在原子性上。volatile不能保证writer()和reader()方法的原子性。例如写线程写完x=i之后，睡了1万年；在这1万年之内，读线程读到的v一定不等于x。同时reader() 也没有原子性，读线程读完v之后，也可能睡了10万年，此时v也一定不等于x。这里的睡，就是线程上下文切换的时间，这个时间的长短是不一定的。<br><br>你要想验证可见性，可以把reader()代码改成下面这样：<br>    public void reader() {<br>        int vv = v;<br>        int xx = x;<br>        &#47;&#47; volatile能保证 vv&lt;=xx<br>        if (vv &gt; xx) {<br>            System.out.println(&quot;x: &quot; + xx + &quot; v: &quot; + vv);<br>        }<br>    }","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1612599120,"ip_address":"","comment_id":277406,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5907374198","product_id":100023901,"comment_content":"作者你好，试看了两节，实际运行代码与文中描述不符，具体代码如下：<br>public class Main {<br>    int x = 0;<br>    volatile int v = 0;<br><br>    public static void main(String[] args) {<br>        Main m = new Main();<br>        new Thread(() -&gt; {<br>            int i = 0;<br>            while (true){<br>                m.writer(i);<br>                i++;<br>            }<br>        }).start();<br>        new Thread(() -&gt; {<br>            while (true) {<br>                m.reader();<br>            }<br>        }).start();<br>    }<br><br>    public void writer(int i) {<br>        x = i;<br>        v = i;<br>    }<br><br>    public void reader() {<br>        if (v != x) {<br>            System.out.println(&quot;x: &quot; + x + &quot; v: &quot; + v);<br>        }<br>    }<br>}<br>以上代码还是会输出x与v不相等，这与文中提到的前三条happen-before原则不符合，请老师百忙之余解答","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515040,"discussion_content":"问题不是出在可见性，而是出在原子性上。volatile不能保证writer()和reader()方法的原子性。例如写线程写完x=i之后，睡了1万年；在这1万年之内，读线程读到的v一定不等于x。同时reader() 也没有原子性，读线程读完v之后，也可能睡了10万年，此时v也一定不等于x。这里的睡，就是线程上下文切换的时间，这个时间的长短是不一定的。\n\n你要想验证可见性，可以把reader()代码改成下面这样：\n    public void reader() {\n        int vv = v;\n        int xx = x;\n        // volatile能保证 vv&amp;lt;=xx\n        if (vv &amp;gt; xx) {\n            System.out.println(&amp;quot;x: &amp;quot; + xx + &amp;quot; v: &amp;quot; + vv);\n        }\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612599120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169974,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1641319,"ip_address":"","ucode":"E1184E76B14431","user_header":"https://static001.geekbang.org/account/avatar/00/19/0b/67/dc49a1a8.jpg","comment_is_top":false,"comment_ctime":1578486260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873453556","product_id":100023901,"comment_content":"我尝试解释一下Junzi的问题<br>首先volatile它可以保证可见性和顺序性，而你这里的问题就是volatile保证的顺序性问题。<br>volatile可以保证的顺序性是指：对volatile修的是变量进行的修改操作的语句，一定在这个语句前面的语句执行后发生。所以x=45;一定发生于v=true;之前。而且这里只有x=45;和v=true;，所以这两条语句不存在重排问题。<br>不知解释的是否正确，请老师看看。","like_count":1},{"had_liked":false,"id":163097,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1576656225,"is_pvip":false,"replies":[{"id":"62025","content":"i++&lt;10000不是原子操作，不是说解决了可见性就没有并发问题了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1576677267,"ip_address":"","comment_id":163097,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5871623521","product_id":100023901,"comment_content":"老师，我有个疑问，麻烦帮我解答下，我先摆以下代码:<br>&#47;**<br> * 计算器<br> * @author eleven<br> * @see<br> * @since<br> *&#47;<br><br>public class Calculator {<br><br>    private volatile long count = 0;<br><br>    public long getCount() {<br>        return count;<br>    }<br><br>    public void add10K() {<br>        int idx = 0;<br>        while(idx++ &lt; 100000) {<br>            count += 1;<br>        }<br>    }<br>}<br><br>&#47;**<br> * 计算器线程<br> * @author eleven<br> * @see<br> * @since<br> *&#47;<br><br>public class CalculatorThread extends Thread {<br><br>    private Calculator calculator;<br><br>    public CalculatorThread(Calculator calculator) {<br>        this.calculator = calculator;<br>    }<br><br>    @Override<br>    public void run() {<br>        calculator.add10K();<br>    }<br>}<br><br>&#47;**<br> * 可见性测试<br> * @author eleven<br> * @see<br> * @since<br> *&#47;<br>public class Test {<br><br>    public static void main(String[] args) {<br>        Calculator calculator = new Calculator();<br>        &#47;&#47; 创建两个线程，执行add()操作<br>        Thread t1 = new CalculatorThread(calculator);<br>        Thread t2 = new CalculatorThread(calculator);<br>        &#47;&#47; 启动两个线程<br>        t1.start();<br>        t2.start();<br>        &#47;&#47; 等待两个线程执行结束<br>        try {<br>            t1.join();<br>            t2.join();<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        System.out.println(&quot;count:&quot; + calculator.getCount());<br>    }<br>}<br><br>这是您第一篇文章中可见性例子的改造版，我在Calculator类的成员变量count前面加了volatile关键字，按道理来说不管在多核CPU还是单核CPU上运行这段代码，答案应该都是20000啊，可是最后的测试结果并不是这样，麻烦老师指教下，问题在哪里？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478246,"discussion_content":"i++&amp;lt;10000不是原子操作，不是说解决了可见性就没有并发问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576677267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168452,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","nickname":"Eleven","note":"","ucode":"FB4A0C8CA732BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88466,"discussion_content":"那刚好就再请教下，您在原子性那栏画了个非原子操作示意图，一直不是很理解。原子操作应该是咋样的，或者借这个案例帮我解答下疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576715826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107536,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1561553554,"is_pvip":false,"replies":[{"id":"38924","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561595275,"ip_address":"","comment_id":107536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856520850","product_id":100023901,"comment_content":"学习并发最好的办法是不断提出合适的问题。老师在上一节提出了好问题。学得非常有目的性！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455551,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561595275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107161,"user_name":"杨鹏程baci","can_delete":false,"product_type":"c1","uid":1205949,"ip_address":"","ucode":"3D22F6B74340A8","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/bd/bd5d503e.jpg","comment_is_top":false,"comment_ctime":1561471054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856438350","product_id":100023901,"comment_content":"老师讲得很好，我想问一个问题，获取单例对象的双检测方法，是不是需要对instance加一个volatile关键字就没问题了？","like_count":1},{"had_liked":false,"id":82051,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1554110243,"is_pvip":false,"replies":[{"id":"29693","content":"工作内存不是物理存在的，别把它当回事<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554126805,"ip_address":"","comment_id":82051,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849077539","product_id":100023901,"comment_content":"老师，你好，重读本章有一个疑问，看过一篇jmm的文章，写到jmm定义了线程和主内存之间的抽象关系，具体如下：共享变量存储于主内存中，线程共享；每个线程都有私有的工作内存；工作内存只存储该线程对共享变量的副本，线程不能直接操作主内存，我的疑问是既然每个线程都有私有的本地内存，那为什么前面一章描述单核cpu不存在可见性问题呢？ ","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445447,"discussion_content":"工作内存不是物理存在的，别把它当回事\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554126805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79932,"user_name":"w w","can_delete":false,"product_type":"c1","uid":1100651,"ip_address":"","ucode":"5EA3550C18F28F","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/6b/acaa5d89.jpg","comment_is_top":false,"comment_ctime":1553576332,"is_pvip":false,"replies":[{"id":"29234","content":"说明测试水平也不低😄<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553647204,"ip_address":"","comment_id":79932,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848543628","product_id":100023901,"comment_content":"这个课程很好，把以前只能看懂字读不懂的知识都串起来了，形成体系化，连测试都读懂了，赞啊","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444694,"discussion_content":"说明测试水平也不低😄\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553647204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79473,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1553492401,"is_pvip":false,"replies":[{"id":"29001","content":"是","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553516094,"ip_address":"","comment_id":79473,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848459697","product_id":100023901,"comment_content":"管程中的锁规则只对synchronized 这个锁有效？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444510,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553516094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78771,"user_name":"shawn","can_delete":false,"product_type":"c1","uid":1101483,"ip_address":"","ucode":"9AF400BBF2E264","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/ab/e9d7811f.jpg","comment_is_top":false,"comment_ctime":1553238548,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5848205844","product_id":100023901,"comment_content":"实在忍不住要来讲几句，老师的课程讲得真的很精彩，受益匪浅。","like_count":1},{"had_liked":false,"id":78757,"user_name":"兔2🐰🍃","can_delete":false,"product_type":"c1","uid":1096984,"ip_address":"","ucode":"1FEDA044BB6CBD","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/18/2af6bf4b.jpg","comment_is_top":false,"comment_ctime":1553232928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848200224","product_id":100023901,"comment_content":"一楼所说的&quot;（6）.线程中断规则：对线程<br>interrupt()方法的调用先行发生于被中<br>断线程的代码检测到中断事件的发生，<br>可以通过Thread.interrupted(）方法检测<br>到是否有中断发生。&quot;<br>对于这个不是很好理解，可以举个例子说明下么，谢谢","like_count":1},{"had_liked":false,"id":78577,"user_name":"江南豆沙包","can_delete":false,"product_type":"c1","uid":1061596,"ip_address":"","ucode":"4B7833260F9F2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/dc/d3e3847f.jpg","comment_is_top":false,"comment_ctime":1553177868,"is_pvip":false,"replies":[{"id":"28661","content":"后面的会覆盖前面的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553263451,"ip_address":"","comment_id":78577,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848145164","product_id":100023901,"comment_content":"老师，有个疑问，有没有可能多个线程在同一时间给volatile修饰的变量赋值，那样最终的值是不是就不确定了？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444149,"discussion_content":"后面的会覆盖前面的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553263451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77468,"user_name":"WP","can_delete":false,"product_type":"c1","uid":1105956,"ip_address":"","ucode":"4A24C6CAA70220","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/24/4529f2a4.jpg","comment_is_top":false,"comment_ctime":1552952523,"is_pvip":false,"replies":[{"id":"28281","content":"看完你也优秀👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552953325,"ip_address":"","comment_id":77468,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847919819","product_id":100023901,"comment_content":"优秀，很增长知识","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443736,"discussion_content":"看完你也优秀👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552953325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76391,"user_name":"math","can_delete":false,"product_type":"c1","uid":1432973,"ip_address":"","ucode":"7EE57777F86058","user_header":"https://static001.geekbang.org/account/avatar/00/15/dd/8d/0396fabe.jpg","comment_is_top":false,"comment_ctime":1552582180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847549476","product_id":100023901,"comment_content":"@junzi:我的理解是，关于第一条程序顺序执行确实发生在单线程中，编译器确实有可能对其进行重排，但是老师说1.5及以后引入happen-before规则可以确定对volitole变量的写对后面该变量的读可见。所以这时候要满足传递性。就不能发生重排","like_count":1},{"had_liked":false,"id":75798,"user_name":"白了少年头","can_delete":false,"product_type":"c1","uid":1053084,"ip_address":"","ucode":"A65E00E05B23BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/9c/4fd6ebe0.jpg","comment_is_top":false,"comment_ctime":1552470387,"is_pvip":false,"replies":[{"id":"27647","content":"读写都要加同步块<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552480664,"ip_address":"","comment_id":75798,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847437683","product_id":100023901,"comment_content":"老师我对思考题有个疑问啊，前面有个同学回答有三种办法，其中第二种是：“声明共享变量abc，在synchronized关键字对abc的赋值代码块加锁，由于Happen-before管程锁的规则，可以使得后续的线程可以看到abc的值”，老师回复是三种方式都正确。我的疑问就是，如果只对abc的赋值代码块同步的话，如果有一个getabc()方法，该方法并没有用synchronized修饰，其他线程在调用该方法获取的abc的值，是不是有可能不等于3呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443039,"discussion_content":"读写都要加同步块\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552480664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75777,"user_name":"你只是看起来很努力","can_delete":false,"product_type":"c1","uid":1449173,"ip_address":"","ucode":"F9340A560D347C","user_header":"https://static001.geekbang.org/account/avatar/00/16/1c/d5/248a9c38.jpg","comment_is_top":false,"comment_ctime":1552467572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847434868","product_id":100023901,"comment_content":"老师，看完你给WL同学解答逸出，终于明白了为什么静态方法中不能使用this了，没有初始化，也就没有这个对象。","like_count":1},{"had_liked":false,"id":75528,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1552409038,"is_pvip":false,"replies":[{"id":"27632","content":"规则一在单线程永远成，不需要触发<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552478667,"ip_address":"","comment_id":75528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847376334","product_id":100023901,"comment_content":"规则4 是需要 结合规则1，3 来理解的。<br>因为规则1 对x的操作的happens-before 解锁，<br>因为规则4 解锁happens-before其他管程的加锁。<br>因为规则3 对x的操作 happens-before 其他管程的加锁。<br><br>那么问题来了，什么情况下触发规则1呢？结合课程所讲，应该是按需的限制缓存和编译优化。所以是在有volatile 或者 synchronized 关键字的时候触发规则1吗？还有没有其他的情况？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442928,"discussion_content":"规则一在单线程永远成，不需要触发\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552478667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75475,"user_name":"你说的灰","can_delete":false,"product_type":"c1","uid":1158981,"ip_address":"","ucode":"650FA935A7741F","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/45/8bacada2.jpg","comment_is_top":false,"comment_ctime":1552402705,"is_pvip":false,"replies":[{"id":"27638","content":"线程1里执行这两行，线程2里执行读。<br>线程1用规则1，线程 2用vo规则，再加上传递性。<br><br>就有结果了，jvm一定要保证遵守规则，所以不会出现你想的问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552479495,"ip_address":"","comment_id":75475,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847370001","product_id":100023901,"comment_content":"参考1中write()方法代码：<br>x=45; &#47;&#47; 1<br>v=true; &#47;&#47; 2<br>这两行会不会导致指令重排？<br><br>因为volatile关键字应该只保证了变量v的可见性，happen-before第一条原则在单线程中，1与2重排并不影响结果，那应该有可能出现重排的情况，这样线程B读取到read()的时候也有可能出现x=0。还请老师解答。<br><br>同问，望解答","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442907,"discussion_content":"线程1里执行这两行，线程2里执行读。\n线程1用规则1，线程 2用vo规则，再加上传递性。\n\n就有结果了，jvm一定要保证遵守规则，所以不会出现你想的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552479495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74952,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1552320489,"is_pvip":false,"replies":[{"id":"27338","content":"就是一旦赋值，就不再变化，线程安全。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552349929,"ip_address":"","comment_id":74952,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847287785","product_id":100023901,"comment_content":"这里关于final的不是很懂，能不能再说明确点。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442754,"discussion_content":"就是一旦赋值，就不再变化，线程安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552349929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74607,"user_name":"老醋","can_delete":false,"product_type":"c1","uid":1308401,"ip_address":"","ucode":"D6DF921AAB9E7A","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/f1/5ccbe3fe.jpg","comment_is_top":false,"comment_ctime":1552266079,"is_pvip":false,"replies":[{"id":"27237","content":"高手！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552277504,"ip_address":"","comment_id":74607,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847233375","product_id":100023901,"comment_content":"还有使用原子变量cas来保障","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442615,"discussion_content":"高手！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552277504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74427,"user_name":"龙哥","can_delete":false,"product_type":"c1","uid":1451669,"ip_address":"","ucode":"E7ED2E7DF759A1","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/95/a4e0f7ab.jpg","comment_is_top":false,"comment_ctime":1552223737,"is_pvip":false,"replies":[{"id":"27235","content":"感谢盛赞<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552277388,"ip_address":"","comment_id":74427,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847191033","product_id":100023901,"comment_content":"关于课程<br>虽说是音频，感觉比视频更有画面感。相关的视频也看过，只是交如何使用，但是没讲原理，讲完就忘。这个课程从原理给大家梳理知识，感觉课程特别赞<br><br>关于思考题<br>1.可以设置abc变量为volatile,那么线程A对abc的写操作都会Happens-before后续线程<br>2.使用synchronized,每次操作时都会加锁，保证每次只有一个线程对abc进行改变，使得其他线程都能正确读到该值<br>3.使用join，线程A改变了abc后，b线程等待A线程完成，A线程对共享变量abc的操作都happens-before后续线程<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442574,"discussion_content":"感谢盛赞\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552277388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74180,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1552135826,"is_pvip":false,"replies":[{"id":"27132","content":"是这样，折腾半天其实就是解决这么个问题。你总结的太到位了！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552142652,"ip_address":"","comment_id":74180,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847103122","product_id":100023901,"comment_content":"我是不是可以通过happen-before那几个规则能够推算出前面一个操作的结果对后续操作是可见性?","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442483,"discussion_content":"是这样，折腾半天其实就是解决这么个问题。你总结的太到位了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552142652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73713,"user_name":"那就这样吧","can_delete":false,"product_type":"c1","uid":1327343,"ip_address":"","ucode":"A1315C5EAF2917","user_header":"https://static001.geekbang.org/account/avatar/00/14/40/ef/52bbadb9.jpg","comment_is_top":false,"comment_ctime":1551962565,"is_pvip":false,"replies":[{"id":"26920","content":"我曾经跟你一样","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551967189,"ip_address":"","comment_id":73713,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846929861","product_id":100023901,"comment_content":"有种恍然大悟的感觉，之前也看过关于happen-before,但一直没能理解。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442239,"discussion_content":"我曾经跟你一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551967189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73599,"user_name":"传葱","can_delete":false,"product_type":"c1","uid":1178023,"ip_address":"","ucode":"18C3641F35003B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/a7/1e69b9a1.jpg","comment_is_top":false,"comment_ctime":1551936719,"is_pvip":false,"replies":[{"id":"26916","content":"太全面了！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551964745,"ip_address":"","comment_id":73599,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846904015","product_id":100023901,"comment_content":"根据老师上面讲的规则，应该是存在6种情况的，happend-before除了第一种情况用于同一个线程之外。后面都可以处理多线程之间的可见性问题。第一个共享变量加上volatile。第二个传递性，除了这个共享变量abc之外，新建一个volitile变量ccc，在abc赋值之后写入ccc，另外一个线程在读取abc之前读取ccc。第三个，加锁，synchronized。第四个，start方法，一个线程必然是在start（）之后才会run的，start在主线程中又可以使用第一条顺序性规则。第五个，join，等待异步线程结束，其实和start差不对，原理基本相同。最后使用final，只能赋值一次，必然是不变的，声明为共享变量，控制一下赋值时间就行，这个体现的不明显。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442176,"discussion_content":"太全面了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551964745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73448,"user_name":"Jaswine","can_delete":false,"product_type":"c1","uid":1243370,"ip_address":"","ucode":"EE39D9629204DB","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/ea/98738420.jpg","comment_is_top":false,"comment_ctime":1551885876,"is_pvip":false,"replies":[{"id":"26857","content":"要是再多转发就更好了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551957100,"ip_address":"","comment_id":73448,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846853172","product_id":100023901,"comment_content":"膝盖收下！！！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442092,"discussion_content":"要是再多转发就更好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551957100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73289,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1551852056,"is_pvip":false,"replies":[{"id":"26723","content":"这个只是告诉你理论上会出问题。实际上也许不会出。这个例子只是告诉你如何深入理解volatile","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551882173,"ip_address":"","comment_id":73289,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5846819352","product_id":100023901,"comment_content":"老师，你这个例子<br>&#47;&#47; 以下代码来源于【参考 1】<br>class VolatileExample {<br>  int x = 0;<br>  volatile boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      &#47;&#47; 这里 x 会是多少呢？<br>    }<br>  }<br>}<br>就算不加volatile，启动两个线程，第一个线程writer(),第二个线程reader(),还是不会出现x=0的情况呀","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442005,"discussion_content":"这个只是告诉你理论上会出问题。实际上也许不会出。这个例子只是告诉你如何深入理解volatile","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551882173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1402570,"avatar":"https://static001.geekbang.org/account/avatar/00/15/66/ca/fb5c3a30.jpg","nickname":"tungSing","note":"","ucode":"F7147EA351BE44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167417,"discussion_content":"我跑了代码也是这个情况，没理解为什么，但是单个变量，比如不加volatile修饰只操作v，A线程改变了v的值B线程是看不到的，加上volatile修饰，A线程改变了v的值B线程是可以看到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581492066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73276,"user_name":"轻歌赋","can_delete":false,"product_type":"c1","uid":1251574,"ip_address":"","ucode":"22F62446208805","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/f6/2ff7bc7a.jpg","comment_is_top":false,"comment_ctime":1551848115,"is_pvip":false,"replies":[{"id":"26721","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551882025,"ip_address":"","comment_id":73276,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846815411","product_id":100023901,"comment_content":"这里考虑的应该是读在写后面发生的情况下是否正确读到了abc的值，所以直接<br>final int abc = 123初始化是最简单的","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441999,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551882025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73191,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1551836707,"is_pvip":false,"replies":[{"id":"26739","content":"单线程里只有规则一是可以的。文中的例子多线程的场景。读写是两个线程的时候，没办法保证正确性。<br><br>即使没有 CPU 缓存，也会有问题。这个不属于可见性的问题，属于原子性的问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551883004,"ip_address":"","comment_id":73191,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846804003","product_id":100023901,"comment_content":"令哥，我不是 Java 程序员，但是对文中的可见性问题有些疑惑。<br><br>上一讲说可见性问题是缓存导致的，我不确定可见性问题，是不是指导致 10000 + 10000 &lt; 20000 的问题。<br><br>因为即使没有 CPU 缓存，这个问题在多核中还是会存在的，比如线程 A 从内存读取变量 x = 0，进行 +1 操作，在写入内存前，线程 B 也读取 x，并做 +1 操作，当两个线程都写入时，x 的值只有 1。<br><br>这个是否属于可见性问题呢？如果不是，出现非预期结果就跟可见性问题没关系；但如果是，这又跟 CPU 缓存没什么关系。<br><br><br>还有这一讲中说 1.5 版本后 volatile 中加入 Happens-Before 规则，防止指令被编译器优化。个人觉得只要满足第一条“程序的顺序性规则”，即 x = 42 先于 v = true 执行，就不会出现 x = 0 的结果。规则 2 和规则 3 对这段代码来说没什么帮助，我不确定是不是会在其它场景有效。<br><br>指望老师能指点一二，感谢。<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441961,"discussion_content":"单线程里只有规则一是可以的。文中的例子多线程的场景。读写是两个线程的时候，没办法保证正确性。\n\n即使没有 CPU 缓存，也会有问题。这个不属于可见性的问题，属于原子性的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551883004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73186,"user_name":"谢特","can_delete":false,"product_type":"c1","uid":1248684,"ip_address":"","ucode":"9C30DBFECFE649","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/ac/09678490.jpg","comment_is_top":false,"comment_ctime":1551836229,"is_pvip":false,"replies":[{"id":"26628","content":"写完后，别的线程能正确读出来","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551846672,"ip_address":"","comment_id":73186,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846803525","product_id":100023901,"comment_content":"可见性怎么定义的","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441957,"discussion_content":"写完后，别的线程能正确读出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551846672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73119,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1551802714,"is_pvip":false,"replies":[{"id":"26581","content":"没太明白你的问题。只是在说hb的事情。volatile不仅是禁用缓存，要综合hb规则来看<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551832190,"ip_address":"","comment_id":73119,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846770010","product_id":100023901,"comment_content":"VolatileExample的意思是因为v是volatile的，所以读取的时候要从主内存拿，这个时候CPU缓存不会有其他变量了吗","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441923,"discussion_content":"没太明白你的问题。只是在说hb的事情。volatile不仅是禁用缓存，要综合hb规则来看\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551832190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72986,"user_name":"陈康康","can_delete":false,"product_type":"c1","uid":1192741,"ip_address":"","ucode":"A34A0DC88D6E77","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/25/eac79a47.jpg","comment_is_top":false,"comment_ctime":1551770726,"is_pvip":false,"replies":[{"id":"26500","content":"final class A{}<br>A x = new A();<br><br>它上面这段的意思，应该是说x的事情。x不是final的，所以需要同步。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551796708,"ip_address":"","comment_id":72986,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846738022","product_id":100023901,"comment_content":"不知道下面这段话怎么理解呢，不可变对象多线程之间还要使用同步（锁），这个没有理解，望回复<br>Now, having said all of this, if, after a thread constructs an immutable object (that is, an object that only contains final fields), you want to ensure that it is seen correctly by all of the other thread, you still typically need to use synchronization. There is no other way to ensure, for example, that the reference to the immutable object will be seen by the second thread.<br><br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441863,"discussion_content":"final class A{}\nA x = new A();\n\n它上面这段的意思，应该是说x的事情。x不是final的，所以需要同步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551796708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72907,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1551753727,"is_pvip":false,"replies":[{"id":"26487","content":"高手在民间","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794694,"ip_address":"","comment_id":72907,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846721023","product_id":100023901,"comment_content":"思考题线程修改后对后续线程可见，我只想到了synchronized关键字，Thread的start( )和join( )使用，没想到评论区人才这么多，方法可以这么多。<br>看完文章感觉对volatile，synchronized和final关键字有了新的了解，<br>首先volatile关键字是禁用缓存（CPU里面那个），保证的是从内存读取，要注意旧版本的线程可见性导致读取结果不正确。<br>synchronized关键字是关于锁，相当于用上就加锁对应的代码块结束就解锁，解锁后，后面的的线程就可以看到之前的内容。<br>final是要注意编译优化双重检查带来的问题（看文档，跟懒汉模式有关），不要想新他真的“生而不变”。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441820,"discussion_content":"高手在民间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72633,"user_name":"Lyre","can_delete":false,"product_type":"c1","uid":1275759,"ip_address":"","ucode":"61AB16508AFFDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/77/6f/454951d2.jpg","comment_is_top":false,"comment_ctime":1551683105,"is_pvip":false,"replies":[{"id":"26349","content":"这算不算饥饿营销?","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551709796,"ip_address":"","comment_id":72633,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846650401","product_id":100023901,"comment_content":"老师 更新的有点慢 哈哈哈","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441668,"discussion_content":"这算不算饥饿营销?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551709796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72509,"user_name":"沙漠里的骆驼","can_delete":false,"product_type":"c1","uid":1012559,"ip_address":"","ucode":"5EC18A71B3A594","user_header":"https://static001.geekbang.org/account/avatar/00/0f/73/4f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1551662449,"is_pvip":true,"replies":[{"id":"26357","content":"能解决。<br>当你用happens-before规则来推算程序运行结果时，是站在Java语言的角度的。里面的语句和赋值语句是 顺序规则保证，顺序规则+传递+volatile 就能推算出来：能够解决。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551710644,"ip_address":"","comment_id":72509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846629745","product_id":100023901,"comment_content":"请教一个问题，使用volatile关键字能解决上一节课中的双重检查问题吗？<br>我的理解是: volatile 本身的语义是禁用缓存，只有结合happens-before规整才有禁用重排序的意义。而对于双重检查的问题，对于变量本身的初始化，里面的语句的重排序是不会禁用的，因此解决不了双重检查的问题。<br>不过我看老师给的链接资料(http:&#47;&#47;ifeve.com&#47;jmm-faq-dcl&#47;)里面说是可以解决的，希望老师能够分析下；<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441622,"discussion_content":"能解决。\n当你用happens-before规则来推算程序运行结果时，是站在Java语言的角度的。里面的语句和赋值语句是 顺序规则保证，顺序规则+传递+volatile 就能推算出来：能够解决。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551710644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72344,"user_name":"Geek_961eed","can_delete":false,"product_type":"c1","uid":1444566,"ip_address":"","ucode":"A62198D96379F5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erWxMXolPylQk8Z6V6yt2LtibksrksC4bHtmxkuCC4Wzw7trl6CfwmsSFMyHFItFnvl21RvQ8fyOBQ/132","comment_is_top":false,"comment_ctime":1551592406,"is_pvip":false,"replies":[{"id":"26208","content":"这部分final和我们正常的理解是一致的，只要保证不要“逸出”，就没问题。没坑，所以就没有详细介绍。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551602598,"ip_address":"","comment_id":72344,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846559702","product_id":100023901,"comment_content":"希望作者，能够深入的讲解下final在并发环境下的应用，final这部分读起来感觉不是太通透，谢谢！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441551,"discussion_content":"这部分final和我们正常的理解是一致的，只要保证不要“逸出”，就没问题。没坑，所以就没有详细介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551602598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72276,"user_name":"青冰白夜","can_delete":false,"product_type":"c1","uid":1307569,"ip_address":"","ucode":"3F71F1027E8374","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/b1/0429aa3b.jpg","comment_is_top":false,"comment_ctime":1551569215,"is_pvip":false,"replies":[{"id":"26182","content":"可以重排，但是重排的结果要保证Happens-Before规则<br>int i=0;<br>int j=1;<br>int k = i+j;<br>如果你的代码是上面这样，那么编译器重排成：<br>int j=1;<br>int i=0;<br>int k = i+j;<br>也是可以的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551582718,"ip_address":"","comment_id":72276,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5846536511","product_id":100023901,"comment_content":"老师问一个纠结的问题<br>如下事例代码假设是在单线程执行。<br>int i=0；&#47;&#47;语句1<br>int j=0； &#47;&#47;语句2<br>这里根据Happens-Before规则，单线程中语句1一定是比语句2先执行。但是我看书上说，这里可能会发生指令重排序，也就是说语句1不一定比语句2先执行。怎么感觉和happens-before规则有点矛盾啊？我知道我可能吗哪儿理解有误区，希望老师给我答疑下。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441519,"discussion_content":"可以重排，但是重排的结果要保证Happens-Before规则\nint i=0;\nint j=1;\nint k = i+j;\n如果你的代码是上面这样，那么编译器重排成：\nint j=1;\nint i=0;\nint k = i+j;\n也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551582718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":89038,"discussion_content":"int i=0;\nint j=1;\nint k = i+j;\n说明 i 对 j是可见的\nint j=1;\nint i=0;\nint k = i+j;\n说明 j 对 i是可见的\n这里的happens-before规则 不是指的代码的书写顺序，而是在于CPU执行指令时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576747038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72049,"user_name":"crazypokerk","can_delete":false,"product_type":"c1","uid":1158383,"ip_address":"","ucode":"9AAD5D9726E503","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/ef/494f56c3.jpg","comment_is_top":false,"comment_ctime":1551506805,"is_pvip":false,"replies":[{"id":"26105","content":"可以这么理解，不过和JVM的优化没关系","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551522604,"ip_address":"","comment_id":72049,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846474101","product_id":100023901,"comment_content":"请问老师，逸出指的是对象逃逸吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441437,"discussion_content":"可以这么理解，不过和JVM的优化没关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551522604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71929,"user_name":"相民","can_delete":false,"product_type":"c1","uid":1288248,"ip_address":"","ucode":"1911950763FE3C","user_header":"https://static001.geekbang.org/account/avatar/00/13/a8/38/6a714398.jpg","comment_is_top":false,"comment_ctime":1551488364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846455660","product_id":100023901,"comment_content":"@何方妖孽 JAVA8引入的Lambda语法","like_count":1},{"had_liked":false,"id":358104,"user_name":"Sammy","can_delete":false,"product_type":"c1","uid":1200058,"ip_address":"上海","ucode":"75F16A25E72598","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/ba/520f2725.jpg","comment_is_top":false,"comment_ctime":1663912670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663912670","product_id":100023901,"comment_content":"思考题：使用volatile关键词","like_count":0},{"had_liked":false,"id":356656,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1476245,"ip_address":"重庆","ucode":"2668A965FA79F2","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/95/b9d960d9.jpg","comment_is_top":false,"comment_ctime":1662474770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662474770","product_id":100023901,"comment_content":"1.给abc加上volatile关键字<br>2.使用传递性规则<br>3.使用abc的代码段加上管程<br>4.在父子线程中，在start方法前使用abc<br>5.在父子线程中，在父线程调用子线程的join方法后使用abc","like_count":0},{"had_liked":false,"id":355913,"user_name":"取经的🐒","can_delete":false,"product_type":"c1","uid":2215442,"ip_address":"北京","ucode":"428BE0D6E6084C","user_header":"https://static001.geekbang.org/account/avatar/00/21/ce/12/7de69c30.jpg","comment_is_top":false,"comment_ctime":1661848552,"is_pvip":true,"replies":[{"id":"129674","content":"工作内存算是个逻辑概念吧，jvm实现层面没这东西","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1662094226,"ip_address":"北京","comment_id":355913,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1661848552","product_id":100023901,"comment_content":"网上有人说，java每个线程都有自己的工作内存，里面存储的是主内存里数据的副本。但我记得jvm线程共享堆，私享栈，所以是共享内存才对吧，没有所谓的工作内存","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586295,"discussion_content":"工作内存算是个逻辑概念吧，jvm实现层面没这东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662094226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351910,"user_name":"漂泊者及其影子","can_delete":false,"product_type":"c1","uid":1119979,"ip_address":"","ucode":"13FE760FE8B111","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/eb/30864e40.jpg","comment_is_top":false,"comment_ctime":1658286613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658286613","product_id":100023901,"comment_content":"synchronized代码块是否可以保证代码块的变量都是可见的，另一个线程不通过代码块更改了共享变量，synchronized代码块是否一定能感知到变量的变更。","like_count":0},{"had_liked":false,"id":351258,"user_name":"Geek_e1fa7e","can_delete":false,"product_type":"c1","uid":2937592,"ip_address":"北京","ucode":"A4F760ECA6BC90","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mYWcQohmLrSmYTneYuRD7FCibkTj9JicVwYRO2qMUeiauUOtBIDyz1G1F4bVLrcXELs9Zz9Orh4JDg5C8jz1GhNug/132","comment_is_top":false,"comment_ctime":1657640046,"is_pvip":false,"replies":[{"id":"130865","content":"是这样的，JVM开发人员要根据不同的硬件架构写不同的实现，我们会用就可以了。","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1665838283,"ip_address":"北京","comment_id":351258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1657640046","product_id":100023901,"comment_content":"老师，对于jvm的开发人员来说，是不是主要是应该如何用内存屏障去实现happens before规则，以及volatile，final，synchronized关键字。而对于我们编程人员来说主要是如何在编程中使用这些规则","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590529,"discussion_content":"是这样的，JVM开发人员要根据不同的硬件架构写不同的实现，我们会用就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665838283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351142,"user_name":"Geek_a88f85","can_delete":false,"product_type":"c1","uid":2904239,"ip_address":"","ucode":"26A1F21EC9D02C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIwxVNotictocRFbU74R724jC8IHibAwap8TL5aialwLJDY0RyXlZkfeUVdBzTntTzOpFuozaaeGHwYg/132","comment_is_top":false,"comment_ctime":1657545624,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657545624","product_id":100023901,"comment_content":"1. volatile 关键字  <br>2. thread.start之前修改<br>3. scyn隐式锁<br>4. join方法之后","like_count":0},{"had_liked":false,"id":347954,"user_name":"皮明强","can_delete":false,"product_type":"c1","uid":2810671,"ip_address":"","ucode":"A643459C69026A","user_header":"","comment_is_top":false,"comment_ctime":1654606433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654606433","product_id":100023901,"comment_content":"老师您好，我测试了一下，不管主线程在哪里修改代码，感觉只要比子线程修改的快，就在子线程中可见。是这样吗？","like_count":0},{"had_liked":false,"id":345735,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652534313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652534313","product_id":100023901,"comment_content":"问题答案：<br>1 volatile 关键字<br>2 happen-befor 原则，比如 a线程中定义 ，启动其他线程，a happen-befor 其他线程<br>3 加锁<br>4 join 先执行赋值的线程，其他线程再join<br><br><br>内存屏障","like_count":0},{"had_liked":false,"id":341150,"user_name":"可乐要加冰","can_delete":false,"product_type":"c1","uid":1546857,"ip_address":"","ucode":"DD5FE1A5BB35EB","user_header":"https://static001.geekbang.org/account/avatar/00/17/9a/69/af90f0c0.jpg","comment_is_top":false,"comment_ctime":1649390648,"is_pvip":false,"replies":[{"id":"124750","content":"是这样","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1649515400,"ip_address":"","comment_id":341150,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649390648","product_id":100023901,"comment_content":"溢出那里，是因为指令重排序导致x在global.obj之后初始化，所以使用global.obj的时候可能x还没有初始化，从而出现使用global.obj读到的x是未初始化的0。是这样嘛","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561024,"discussion_content":"是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649515400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340949,"user_name":"Geek_94fa0e","can_delete":false,"product_type":"c1","uid":2963434,"ip_address":"","ucode":"15BC7D4E130E80","user_header":"","comment_is_top":false,"comment_ctime":1649241293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649241293","product_id":100023901,"comment_content":"但是 final 一般怎么用尼","like_count":0},{"had_liked":false,"id":340636,"user_name":"白不吃","can_delete":false,"product_type":"c1","uid":1033578,"ip_address":"","ucode":"F019914D8819C2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","comment_is_top":false,"comment_ctime":1648983369,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1648983369","product_id":100023901,"comment_content":"那这里的 x=42 和 v=true，有没有可能被cpu重新排序呢，如果重新排序了，那么是不是就存在，读取发生在赋值之前？","like_count":0},{"had_liked":false,"id":340302,"user_name":"小土","can_delete":false,"product_type":"c1","uid":1798467,"ip_address":"","ucode":"2B56E3FF91F732","user_header":"","comment_is_top":false,"comment_ctime":1648732122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648732122","product_id":100023901,"comment_content":"这节讲的还是有些晦涩，特别是happens-before部分","like_count":0},{"had_liked":false,"id":340045,"user_name":"云晴","can_delete":false,"product_type":"c1","uid":1398845,"ip_address":"","ucode":"43A7E9071E50E0","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/3d/ad2bfebf.jpg","comment_is_top":false,"comment_ctime":1648554036,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648554036","product_id":100023901,"comment_content":"volatile int abc = 3;<br>&#47;&#47; or<br>int AtomicInteger abc = new AtomicInteger(3);","like_count":0},{"had_liked":false,"id":331626,"user_name":"云韵","can_delete":false,"product_type":"c1","uid":1025622,"ip_address":"","ucode":"3DE26DBAAAEDE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/56/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1642674726,"is_pvip":true,"replies":[{"id":"122155","content":"只是说明一个全局变量而已，没有这种语法","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1644922852,"ip_address":"","comment_id":331626,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1642674726","product_id":100023901,"comment_content":"王老师，java 中还有这种语法？global.obj = this;<br>可以解释一下global 这种用法吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551197,"discussion_content":"只是说明一个全局变量而已，没有这种语法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644922852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328873,"user_name":"Insomnia","can_delete":false,"product_type":"c1","uid":1751214,"ip_address":"","ucode":"5986A48988D6E3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/ae/085484e7.jpg","comment_is_top":false,"comment_ctime":1640922446,"is_pvip":false,"replies":[{"id":"119891","content":"不确定，有可能是0，也有可能是42","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1641193855,"ip_address":"","comment_id":328873,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640922446","product_id":100023901,"comment_content":"<br>&#47;&#47; 以下代码来源于【参考1】<br>class VolatileExample {<br>  int x = 0;<br>  boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      &#47;&#47; 这里x会是多少呢？<br>    }<br>  }<br>}<br>老师，二刷这个教程，有些想法，上面这个例子，如果变量 v 不是volatile 的，那么并发下，x的值是不是还是不确定的？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543521,"discussion_content":"不确定，有可能是0，也有可能是42","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641193855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310815,"user_name":"王者爱学习","can_delete":false,"product_type":"c1","uid":1249643,"ip_address":"","ucode":"0397A4AB7FE83A","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/6b/0a56da99.jpg","comment_is_top":false,"comment_ctime":1630921487,"is_pvip":false,"replies":[{"id":"113115","content":"理论上可以重排，但是要保证同一线程中第6行的执行结果对第7行可见，例如有可能在他们之间增加一些非内存操作的指令","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1631663556,"ip_address":"","comment_id":310815,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630921487","product_id":100023901,"comment_content":"第 6 行代码 “x = 42;” Happens-Before 于第 7 行代码 “v = true;”，这就是规则 1 的内容，也比较符合单线程里面的思维：程序前面对某个变量的修改一定是对后续操作可见的。<br><br>老师您这里说的第一条规则，是先执行x=42 再执行v = true  请问这两个操作不会发生指令重拍吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526366,"discussion_content":"理论上可以重排，但是要保证同一线程中第6行的执行结果对第7行可见，例如有可能在他们之间增加一些非内存操作的指令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631663556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305912,"user_name":"🌞","can_delete":false,"product_type":"c1","uid":2208565,"ip_address":"","ucode":"EDE31C3E82A4AD","user_header":"https://static001.geekbang.org/account/avatar/00/21/b3/35/64ccd5b0.jpg","comment_is_top":false,"comment_ctime":1628228442,"is_pvip":false,"replies":[{"id":"111202","content":"不同的cpu架构，方式不同，这两种方式都有","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1628857975,"ip_address":"","comment_id":305912,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628228442","product_id":100023901,"comment_content":"老师您好，这个问题您看到后务必解答一下，困扰我很久没有解决：<br><br>在多核CPU保证可见性的问题中，假设CPU1、CPU2、CPU3中有一个缓存行（包含变量x），此时CPU1要对变量x进行写操作：<br>1、到底是CPU1广播的形式，将无效（Invalid）广播发送给其他CPU，其他CPU反应后将缓存行设置为无效。【后面优化引入store buffer和queue，但是就是这个思想】<br>2、还是CPU1在往内存写的时候，其他CPU通过总线嗅探机制感知到的。<br><br>各种博客都说的不是很清楚","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524559,"discussion_content":"不同的cpu架构，方式不同，这两种方式都有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628857975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302110,"user_name":"机车","can_delete":false,"product_type":"c1","uid":1881786,"ip_address":"","ucode":"CD32A645AE310A","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b6/ba/f76d996b.jpg","comment_is_top":false,"comment_ctime":1626085346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626085346","product_id":100023901,"comment_content":"老师请教一个问题，ConcurrentHashMap中 volatail修饰 的 Node数组，获取时为何用unsafe获取？而不是用下标呢？","like_count":0},{"had_liked":false,"id":294406,"user_name":"金鑫","can_delete":false,"product_type":"c1","uid":1116257,"ip_address":"","ucode":"8AA30E8DD736FB","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/61/9e0f8b8d.jpg","comment_is_top":false,"comment_ctime":1621931260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621931260","product_id":100023901,"comment_content":"爆粗，这篇太好了，开启了一个新的视角。","like_count":0},{"had_liked":false,"id":293863,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1621580780,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1621580780","product_id":100023901,"comment_content":"总结一下本篇内容的关键词：“先后”","like_count":0},{"had_liked":false,"id":293718,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1621504457,"is_pvip":true,"replies":[{"id":"106776","content":"你的解释直击要害，相当正确","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1621900622,"ip_address":"","comment_id":293718,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1621504457","product_id":100023901,"comment_content":"老师这个程序输出的结果不是10000 ，是不是可以这么解释volatile修饰了共享变量保证了变量的修改对各个线程是可见的但是 count++不是原子操作<br>public class Demo {<br><br>    private static volatile int count = 0;<br><br>    public static void main(String[] args) throws InterruptedException {<br>        Thread thread1 = new Thread(new MyThread());<br>        Thread thread2 = new Thread(new MyThread());<br>        Thread thread3 = new Thread(new MyThread());<br>        Thread thread4 = new Thread(new MyThread());<br>        Thread thread5 = new Thread(new MyThread());<br>        Thread thread6 = new Thread(new MyThread());<br>        Thread thread7 = new Thread(new MyThread());<br>        Thread thread8 = new Thread(new MyThread());<br>        Thread thread9 = new Thread(new MyThread());<br>        Thread thread10 = new Thread(new MyThread());<br><br>        thread1.start();<br>        thread2.start();<br>        thread3.start();<br>        thread4.start();<br>        thread5.start();<br>        thread6.start();<br>        thread7.start();<br>        thread8.start();<br>        thread9.start();<br>        thread10.start();<br><br><br>        thread1.join();<br>        thread2.join();<br>        thread3.join();<br>        thread4.join();<br>        thread5.join();<br>        thread6.join();<br>        thread7.join();<br>        thread8.join();<br>        thread9.join();<br>        thread10.join();<br><br>        System.out.println(count);<br><br>    }<br><br><br><br>    private static void test() {<br>        for (int i = 0; i &lt; 1000; i++) {<br>            count ++;<br>        }<br>    }<br><br><br>    static class  MyThread implements Runnable {<br>        @Override<br>        public void run() {<br>            test();<br>        }<br>    }<br><br>}","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520327,"discussion_content":"你的解释直击要害，相当正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621900622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289948,"user_name":"雨飞Vee","can_delete":false,"product_type":"c1","uid":1199975,"ip_address":"","ucode":"8AC07868C30E24","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/67/6a7a7534.jpg","comment_is_top":false,"comment_ctime":1619274972,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619274972","product_id":100023901,"comment_content":"凡事有因并有果，像电影《信条》","like_count":0},{"had_liked":false,"id":288346,"user_name":"Focus","can_delete":false,"product_type":"c1","uid":1252104,"ip_address":"","ucode":"AEC14ED09E7D45","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/08/150b6a51.jpg","comment_is_top":false,"comment_ctime":1618415915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618415915","product_id":100023901,"comment_content":"作业：<br>1、根据第二条volatile变量规则，对一个volatile变量的写操作，happen-before于后续对这个变量的读操作：把abc设置成全局变量，且用volatile修饰；<br>2、管程中锁规则，对一个锁的解锁，hanppen-befor于后续对这个锁的加锁：把abc赋值操作放到带有synchronized的代码块中；<br>3、线程join（）规则：在线程中完成abc赋值操作后，调用线程的join（）方法，其他线程就能够“看”到了。","like_count":0},{"had_liked":false,"id":288344,"user_name":"Focus","can_delete":false,"product_type":"c1","uid":1252104,"ip_address":"","ucode":"AEC14ED09E7D45","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/08/150b6a51.jpg","comment_is_top":false,"comment_ctime":1618415440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618415440","product_id":100023901,"comment_content":"老师，这句“final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化“，这句话我不太理解，这句话想表达的意思是一但变量被final修饰了，并且这个变量是基础数据类型的话，就不能改变了，其他线程读到的都不变？","like_count":0},{"had_liked":false,"id":284864,"user_name":"洛奇","can_delete":false,"product_type":"c1","uid":1624355,"ip_address":"","ucode":"662B4005721119","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","comment_is_top":false,"comment_ctime":1616502370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616502370","product_id":100023901,"comment_content":"单例类代码之所以要用volatile修饰instance，是能这样解释吗？new对象在被赋值前就执行好了，那就是在volatile变量的写操作之前就执行了，所以在写操作后的volatile变量的读操作就能happens-before。用到了传递性和volatile这两个happens-before规则，是吗？","like_count":0},{"had_liked":false,"id":284686,"user_name":"水银湖","can_delete":false,"product_type":"c1","uid":1179011,"ip_address":"","ucode":"28BB2E47D8C30A","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/83/48cc0d83.jpg","comment_is_top":false,"comment_ctime":1616416715,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616416715","product_id":100023901,"comment_content":"程序的顺序性规则的描述，不应该是单线程里，指令重拍后的结果与顺序执行结果一致么","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378805,"discussion_content":"就是单线程下的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623407735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284524,"user_name":"洛奇","can_delete":false,"product_type":"c1","uid":1624355,"ip_address":"","ucode":"662B4005721119","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","comment_is_top":false,"comment_ctime":1616316027,"is_pvip":false,"replies":[{"id":"103332","content":"A a=new A()，看上去它在说a的事情，不是说A里面属性的可见性","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1616499875,"ip_address":"","comment_id":284524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616316027","product_id":100023901,"comment_content":"英文文档看不大懂。&quot;Now, having said all of this, if, after a thread constructs an immutable object (that is, an object that only contains final fields), you want to ensure that it is seen correctly by all of the other thread, you still typically need to use synchronization. There is no other way to ensure, for example, that the reference to the immutable object will be seen by the second thread. &quot; 不知道这句是什么意思？老师这节讲的知识点，能解释上一节讲的双重检查法存在的那个new对象时指令重排序的问题吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517377,"discussion_content":"A a=new A()，看上去它在说a的事情，不是说A里面属性的可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616499875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281604,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1614824182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614824182","product_id":100023901,"comment_content":"课后思考题：<br>1:把abc用volatile关键字修饰<br>2:把修改abc变量的代码用synchronized包裹<br>3:把修改abc变量放到子线程中，然后使用join()方法保证可见性","like_count":0},{"had_liked":false,"id":280630,"user_name":"别回头","can_delete":false,"product_type":"c1","uid":2456052,"ip_address":"","ucode":"84DBC3A3F6B4B6","user_header":"https://static001.geekbang.org/account/avatar/00/25/79/f4/e48d897e.jpg","comment_is_top":false,"comment_ctime":1614299538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614299538","product_id":100023901,"comment_content":"老师，我有一个问题，如果两个线程a和b，a在执行x的赋值的时候。b已经执行到if那一行了，那应该输出结果就是0吧","like_count":0},{"had_liked":false,"id":280583,"user_name":"妙手空空","can_delete":false,"product_type":"c1","uid":1107573,"ip_address":"","ucode":"D295481D9BDA75","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/75/86c2a008.jpg","comment_is_top":false,"comment_ctime":1614253517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614253517","product_id":100023901,"comment_content":"Java volatile 解释为禁用缓存是不是太粗暴了？","like_count":0},{"had_liked":false,"id":280517,"user_name":"gaozf","can_delete":false,"product_type":"c1","uid":1256951,"ip_address":"","ucode":"29B879542F24ED","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/f7/36abba57.jpg","comment_is_top":false,"comment_ctime":1614239619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614239619","product_id":100023901,"comment_content":"fina  a；volatile a；结合 大于1.5版本的jdk","like_count":0},{"had_liked":false,"id":278803,"user_name":"Daniel","can_delete":false,"product_type":"c1","uid":1479124,"ip_address":"","ucode":"73EBE735898072","user_header":"https://static001.geekbang.org/account/avatar/00/16/91/d4/4a047e41.jpg","comment_is_top":false,"comment_ctime":1613355824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613355824","product_id":100023901,"comment_content":"老师，我想请教一个问题。<br>文章中提到volatile的作用是禁止用CPU缓存，也就是说起到可见性作用，但是不能保证原子性；<br><br>我看tomcat代码中很多地方都用到了volatile，比如：<br>private volatile int keepAliveLeft = 100;<br>--keepAliveLeft;<br>为什么这里选择volatile而不选择原子类？volatile还能够起到其他什么作用吗？<br><br>代码在tomcat的SocketWrapperBase中。","like_count":0},{"had_liked":false,"id":275699,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1611648947,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1611648947","product_id":100023901,"comment_content":"使用happens-before 原则进行作答；<br>1，顺序性原则+传递性原则：在abc后面 添加一个volatile 变量 然后另一个线程 使用者这个变量，可以拿到 abc 最新变量<br>2，volatile变量规则：直接设置abc 为 volatile <br>3，共享变量+线程start原则：另一个线程在abc=3 之后.start(里面读abc)；<br>4，共享变量+线程join原则：另一个线程 在 a.join 之后再读abc","like_count":0},{"had_liked":false,"id":275452,"user_name":"洛书","can_delete":false,"product_type":"c1","uid":2421848,"ip_address":"","ucode":"4F1C41E4679879","user_header":"https://static001.geekbang.org/account/avatar/00/24/f4/58/383cd3a0.jpg","comment_is_top":false,"comment_ctime":1611547824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611547824","product_id":100023901,"comment_content":"我觉得就volatile是合适的，剩下两种，join,synchronized属于脑筋急转弯","like_count":0},{"had_liked":false,"id":275192,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1611380297,"is_pvip":false,"replies":[{"id":"99878","content":"不会，final是不可变变量，可以优化性能，所以不会禁用缓存","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1611411475,"ip_address":"","comment_id":275192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1611380297","product_id":100023901,"comment_content":"volatile会禁用CPU缓存，final会吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514253,"discussion_content":"不会，final是不可变变量，可以优化性能，所以不会禁用缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611411475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263319,"user_name":"星夜","can_delete":false,"product_type":"c1","uid":1128491,"ip_address":"","ucode":"3B46C09D994CEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","comment_is_top":false,"comment_ctime":1606100570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606100570","product_id":100023901,"comment_content":"课后思考：假设线程A中执行abc赋值操作，线程B中对abc读取<br>1.线程A发生在线程B之前，规则2；<br>2.在线程A中赋值后启动线程B；<br>3.在线程B中调用线程A的join，且join后进行读取操作；<br>总之就是保证线程A赋值操作 happens-before 线程B的读取操作。","like_count":0},{"had_liked":false,"id":260972,"user_name":"超级蛋蛋饭","can_delete":false,"product_type":"c1","uid":1249616,"ip_address":"","ucode":"AD2BECE789B365","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/wiaQmkQdIh84RibSLrDkIA3HtibAR4IibpnP3VEmiaLzvpiaibXJQEb2LLUrCD4dM7DjvOFD65IbdZm2Mn68O71FxiaAow/132","comment_is_top":false,"comment_ctime":1605164430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605164430","product_id":100023901,"comment_content":"使用volatile修饰共享变量 abc，并不能保证读到的是3，还需要保证写操作在读操作之前执行","like_count":0},{"had_liked":false,"id":260945,"user_name":"Geek_c75d82","can_delete":false,"product_type":"c1","uid":2286012,"ip_address":"","ucode":"81202A016FC5D2","user_header":"","comment_is_top":false,"comment_ctime":1605159478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605159478","product_id":100023901,"comment_content":"禁用CPU缓存和禁用编译器优化，来解决可见性和有序性问题。volatile 解决可见性 ,synchronized,final,都是jdk解决有序性问题，为了保证有序，编译器做的优化，需要遵循happens-before原则，即之前发生的对之后发生的是可见的。","like_count":0},{"had_liked":false,"id":260911,"user_name":"Geek_c75d82","can_delete":false,"product_type":"c1","uid":2286012,"ip_address":"","ucode":"81202A016FC5D2","user_header":"","comment_is_top":false,"comment_ctime":1605150979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605150979","product_id":100023901,"comment_content":"1 设置变量valotile 2 控制线程的执行顺序，先执行设置线程，再执行读取线程","like_count":0},{"had_liked":false,"id":253455,"user_name":"Wheres the Love?","can_delete":false,"product_type":"c1","uid":1439120,"ip_address":"","ucode":"8851FB40976AB0","user_header":"https://static001.geekbang.org/account/avatar/00/15/f5/90/e08bbe1f.jpg","comment_is_top":false,"comment_ctime":1602743661,"is_pvip":false,"replies":[{"id":"92657","content":"后续是时间上的，时间点前面的操作完成，时间点后面的能看到结果","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1602845731,"ip_address":"","comment_id":253455,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602743661","product_id":100023901,"comment_content":"volatile规则中的“后续”是指什么呢，比如先读v==true，后写v=true时，如果读操作耗时比较长，先发生的读可能观察到v==true吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507075,"discussion_content":"后续是时间上的，时间点前面的操作完成，时间点后面的能看到结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602845731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253035,"user_name":"平凡的人","can_delete":false,"product_type":"c1","uid":1222818,"ip_address":"","ucode":"16F95555B92D0B","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/a2/cf7dd443.jpg","comment_is_top":false,"comment_ctime":1602573017,"is_pvip":false,"replies":[{"id":"92591","content":"������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1602804217,"ip_address":"","comment_id":253035,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602573017","product_id":100023901,"comment_content":"Synchronized的作用主要有三个：<br><br>原子性：确保线程互斥的访问同步代码；<br>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；<br>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；<br>从语法上讲，Synchronized可以把任何一个非null对象作为&quot;锁&quot;，在HotSpot JVM实现中，锁有个专门的名字：对象监视器（Object Monitor）。<br><br>Synchronized总共有三种用法：<br><br>当synchronized作用在实例方法时，监视器锁（monitor）便是对象实例（this）；<br>当synchronized作用在静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁；<br>当synchronized作用在某一个对象实例时，监视器锁（monitor）便是括号括起来的对象实例；<br>注意，synchronized 内置锁 是一种 对象锁（锁的是对象而非引用变量），作用粒度是对象 ，可以用来实现对 临界资源的同步互斥访问 ，是 可重入 的。其可重入最大的作用是避免死锁，如：<br><br>子类同步方法调用了父类同步方法，如没有可重入的特性，则会发生死锁；<br><br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506950,"discussion_content":"������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602804217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249254,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1600526222,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600526222","product_id":100023901,"comment_content":"共享变量的方式差不多有这些<br>1. volatile, 设置abc为volatile，或者写入abc的值在另外一个volatile变量写入值之前。<br>2. synchronized<br>3. 自行显示创建的读写锁<br>4. 原子变量","like_count":0},{"had_liked":false,"id":247622,"user_name":"蚝不鱿鱼","can_delete":false,"product_type":"c1","uid":1428043,"ip_address":"","ucode":"5DB98E406F1D3E","user_header":"https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg","comment_is_top":false,"comment_ctime":1599781639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599781639","product_id":100023901,"comment_content":"高手在民间","like_count":0},{"had_liked":false,"id":247217,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1599635638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599635638","product_id":100023901,"comment_content":"例子中，在jdk1.5之前，会出现 x=0 的情况，是因为，1.5之前，没有约束volatile 变量 的Happens-Before 规则，导致x=42 会被重排序到 v=true 之后，在1,5之后，会在v=true 之前插入内存屏障，保证x=42不会被重排序到v=true之后，这样也就保证了，只要读到v=true，那么x=42的赋值已经完成了，并且因为volatile的作用，x=42会同步到内存，别的线程也就能读到x=42了","like_count":0},{"had_liked":false,"id":246712,"user_name":"冬天里的懒猫","can_delete":false,"product_type":"c1","uid":1042458,"ip_address":"","ucode":"970E5CEF502828","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/1a/cea701bb.jpg","comment_is_top":false,"comment_ctime":1599460009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599460009","product_id":100023901,"comment_content":"public class VolatileExample {<br><br>\tstatic  int x = 0;<br>\tstatic volatile boolean v = false;<br><br>\tpublic static void main(String[] args) {<br>\t\tThread t1 = new Thread(() -&gt; {<br>\t\t\tx = 42;<br>\t\t\tv = true;<br>\t\t});<br><br>\t\tThread t2 = new Thread(() -&gt; {<br>\t\t\tif(v == true){<br>\t\t\t\tSystem.out.println(x);<br>\t\t\t}else {<br>\t\t\t\tSystem.out.println(x);<br>\t\t\t}<br>\t\t});<br><br>\t\tt1.start();<br>\t\tt2.start();<br>\t\ttry {<br>\t\t\tt1.join();<br>\t\t\tt2.join();<br>\t\t} catch (InterruptedException e) {<br>\t\t\te.printStackTrace();<br>\t\t}<br>\t}<br>}<br>我这个代码，还是有可能输出为0啊","like_count":0},{"had_liked":false,"id":244747,"user_name":"鱼丸粗面","can_delete":false,"product_type":"c1","uid":1785016,"ip_address":"","ucode":"B2F3F75B0D1422","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","comment_is_top":false,"comment_ctime":1598664388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598664388","product_id":100023901,"comment_content":"1、使用volatile修饰 abc<br>2、对volatile的赋值加上 synchronized<br>","like_count":0},{"had_liked":false,"id":244663,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1598606506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598606506","product_id":100023901,"comment_content":"课后的问题，主要方法以及最常见的方法，volatile 和 final 修饰就可","like_count":0},{"had_liked":false,"id":242060,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1597579833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597579833","product_id":100023901,"comment_content":"1:用volatile关键字修饰<br>2:对变量赋值的代码块用synchronized括起来<br>3：在赋值线程中调用另外线程的start()方法<br>4：在线程中调用赋值线程的join()方法","like_count":0},{"had_liked":false,"id":240348,"user_name":"Geek5198","can_delete":false,"product_type":"c1","uid":2028945,"ip_address":"","ucode":"2BEBE6A39D9A0E","user_header":"","comment_is_top":false,"comment_ctime":1596873843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596873843","product_id":100023901,"comment_content":"第5则的代码建议这样<br>package base.newlive.lzm.currentThread;<br><br>import lombok.Data;<br><br>&#47;**<br> * @author lizeming02<br> * @date 2020&#47;8&#47;8<br> *&#47;<br>public class TestStart {<br><br>    public static void main(String[] args) {<br><br>        final Node a = new Node();<br><br>        Thread B = new Thread(() -&gt; {<br>            &#47;&#47; 主线程调用B.start()之前<br>            &#47;&#47; 所有对共享变量的修改，此处皆可见<br>            &#47;&#47; 此例中，a==77<br>            System.out.println(a.getKey());<br>            System.out.println(a.getValue());<br>        });<br>        &#47;&#47; 此处对共享变量var修改<br>        a.setKey(123);<br>        a.setValue(321);<br>        &#47;&#47; 主线程启动子线程<br>        B.start();<br>    }<br>}<br>@Data<br>class Node{<br>    private int value;<br>    private int key;<br>}","like_count":0},{"had_liked":false,"id":239344,"user_name":"林","can_delete":false,"product_type":"c1","uid":1543907,"ip_address":"","ucode":"E1D26D1AB1B14D","user_header":"https://static001.geekbang.org/account/avatar/00/17/8e/e3/a9f4ed7f.jpg","comment_is_top":false,"comment_ctime":1596507526,"is_pvip":false,"replies":[{"id":"88468","content":"可见性是改完变量后，其他线程能立刻看到，你这个程序即便输出1，也不能说明可见了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1596546390,"ip_address":"","comment_id":239344,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596507526","product_id":100023901,"comment_content":"老师好 最近在使用volatile时遇到一些问题很困惑<br>public class VolatileTest {<br>      static boolean flag = true;<br><br>        public static void main(String[] args) throws InterruptedException {<br>            new VolatileTest().test2();<br>            new VolatileTest().test();<br>    }<br><br>    private void test() throws InterruptedException {<br>        Thread t1 = new Thread(() -&gt; {<br>            while(flag){<br>            }<br>            System.out.println(1);<br>        });<br>        t1.start();<br>    }<br>    public void test2(){<br>        Thread t2 = new Thread(() -&gt; {<br>            flag = false;<br>        });<br>        t2.start();<br>    }<br>}<br>为什么在多个对象中 只用static声明也能输出1 不用volatile好像也保证了可见性","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503073,"discussion_content":"可见性是改完变量后，其他线程能立刻看到，你这个程序即便输出1，也不能说明可见了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596546390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235515,"user_name":"卢","can_delete":false,"product_type":"c1","uid":1542037,"ip_address":"","ucode":"B6A9F41AEE348C","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/95/cba0a896.jpg","comment_is_top":false,"comment_ctime":1595070209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595070209","product_id":100023901,"comment_content":"评论区让我意识到自己的渺小与不足","like_count":0},{"had_liked":false,"id":233308,"user_name":"Geek_2f3efa","can_delete":false,"product_type":"c1","uid":2059571,"ip_address":"","ucode":"A5F2BB67C94E60","user_header":"","comment_is_top":false,"comment_ctime":1594283853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594283853","product_id":100023901,"comment_content":"把这个专栏搞明白，看《java concurrency in practice》是不是会好受点了？","like_count":0},{"had_liked":false,"id":231813,"user_name":"sibyl","can_delete":false,"product_type":"c1","uid":1323652,"ip_address":"","ucode":"0D142011860D69","user_header":"","comment_is_top":false,"comment_ctime":1593775779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593775779","product_id":100023901,"comment_content":"曾经一直纠结volatile的禁止重排序的3条规则:<br>volatile写前的代码不能重排序<br>volatile读后的代码不能重排序<br>volatile写后volatile读不能重排序<br>始终在思考为什么会有这些规则？没有这些规则会有什么问题？却一直不得其解😂<br>其实这么思考是本末倒置的，试图从实现推到原因，如果从文中x的值是什么？这个问题出发，然后<br>结合happens-before规则，最后就会明白volatile的本质就是解决x不确定的方法之一！！！我们不需要时刻去分析哪句代码和哪句代码是否能重排序，<br>而是高屋建瓴的根据happens-before规则去思考多线程的交互是否具有可见性，比如文中代码我们希望当判断为真时，可以使用其他线程设置的x值进行操作，如果不是真就忽略然后继续循环。因为需要使用x值，而且是其他线程设置的x值，这就存在交互了，所以我们需要确认这个线程运行到读x的时候能不能见到其他线程设置的x值，或者如何保证能见到，使用volatile关键字则是一个不错的选择。<br><br>再比如说如果read代码如下<br>read(){<br><br>if(v)<br>  sout(&quot;hahahaha&quot;)<br>}<br><br><br>然后在多线程中执行，您说还需要给v增加volatile么？答案是显而易见的，您说这时候再纠结谁对谁可见还有意义么？<br><br><br>其实所有的happens  before规则都是如此","like_count":0},{"had_liked":false,"id":229110,"user_name":"杜总","can_delete":false,"product_type":"c1","uid":2046055,"ip_address":"","ucode":"C6600875A265E7","user_header":"","comment_is_top":false,"comment_ctime":1592899031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592899031","product_id":100023901,"comment_content":"happens-before规则中volatile底层实现感觉没讲深入，还有jmm虽然是虚拟模型，底层也涉及到底层实现，比如缓存一致性协议，也没有深入","like_count":0},{"had_liked":false,"id":226679,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1592184317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592184317","product_id":100023901,"comment_content":"<br>&#47;&#47; 以下代码来源于【参考1】<br>class VolatileExample {<br>  int x = 0;<br>  volatile boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      &#47;&#47; 这里x会是多少呢？<br>    }<br>  }<br>}<br><br>老师有个问题，关于文中这个事例代码，writer 中根据顺序性规则，v=true 一定发生于 x=42 之后，那么 reader 中的 if 语句里一定到的是 42 吧？好像跟 volatile 关键字没什么关系呢？我这边尝试运行了一下感到有些疑惑……","like_count":0},{"had_liked":false,"id":226408,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1236653,"ip_address":"","ucode":"E4ED6A78715512","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/ad/7d8c568e.jpg","comment_is_top":false,"comment_ctime":1592065637,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592065637","product_id":100023901,"comment_content":"老师讲的好棒，通俗易懂","like_count":0},{"had_liked":false,"id":222514,"user_name":"小小代码","can_delete":false,"product_type":"c1","uid":1290642,"ip_address":"","ucode":"F3D4E2C23FC9BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/92/f3dabcb1.jpg","comment_is_top":false,"comment_ctime":1590825514,"is_pvip":false,"replies":[{"id":"94098","content":"������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1604407192,"ip_address":"","comment_id":222514,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590825514","product_id":100023901,"comment_content":"思考题想到了以下三种方法：<br>1.使用volatile修饰，禁止CPU缓存；<br>class Test {<br>    private volatile int abc;<br><br>    public void write() {<br>        abc = 3;<br>    }<br><br>    public int read() {<br>        return abc;<br>    }<br>}<br>2.使用synchronized，加锁；<br>class Test1 {<br>    private int abc;<br><br>    public synchronized void write() {<br>        abc = 3;<br>    }<br><br>    public synchronized int read() {<br>        return abc;<br>    }<br>}<br>3.Happens-Before的传递性规则；<br>class Test2 {<br>    private int abc;<br>    private volatile boolean x;<br><br>    public synchronized void write() {<br>        abc = 3;<br>        x = true;<br>    }<br><br>    public synchronized int read() {<br>        if (x == true) {<br><br>        }<br>        return abc;<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496824,"discussion_content":"������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604407192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220990,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1008071,"ip_address":"","ucode":"9FE5F43055D3AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/c7/b64ac05e.jpg","comment_is_top":false,"comment_ctime":1590373217,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590373217","product_id":100023901,"comment_content":"平时我们写代码的时候 x 要不要也加上volatile呢？还是依赖hapen before","like_count":0},{"had_liked":false,"id":213148,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588314656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588314656","product_id":100023901,"comment_content":"happens-before原则针对数据应该是强刷缓存，不可能只针对某个变量从内存读，其他变量在缓存中读取。同样禁止有序性，比如volatile前的变量不可能排序到后去执行。这样对于cpu内存来说是没办法操作的。","like_count":0},{"had_liked":false,"id":213146,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588314389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588314389","product_id":100023901,"comment_content":"可见性是由于缓存引入的，有序性是编译优化造成的。<br>解决对应的问题自然是按需禁止缓存和优化。提供给程序员的自然是java内存模型的规范。具体就是synchronize volatile final以及happens-before原则，即先发生对后发生共享变量的可见性。volatile synchronize start join 程序有序性  构造函数对析构函数 中断可见性等happens-before原则","like_count":0},{"had_liked":false,"id":210207,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1587697480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587697480","product_id":100023901,"comment_content":"当我看完第一大模块时，才明白happens-before中的线程join()规则。很多知识初次认识时可能比较陌生、不好理解，等你把整块理解差不多时，再回头看，会发现其中的道理，哇，原来是这样。<br>就当生活中遇到了问题，暂时迷失自己，需要出去走走，散散心，回头就会重新认识自己！","like_count":0},{"had_liked":false,"id":209527,"user_name":"NLand","can_delete":false,"product_type":"c1","uid":1172759,"ip_address":"","ucode":"07F7AE58EC68C3","user_header":"https://static001.geekbang.org/account/avatar/00/11/e5/17/084dc246.jpg","comment_is_top":false,"comment_ctime":1587563821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587563821","product_id":100023901,"comment_content":"能否像老师举的栗子一样，使用规则一、二、三组合，使得共享变量 abc，在write线程里设置了 abc 的值 abc=3，read线程能够看到abc=3?这样应该也可以吧？","like_count":0},{"had_liked":false,"id":209517,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1587562343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587562343","product_id":100023901,"comment_content":"利用volatile的可见性选择，volatile int abc，对volatile的变量修改能够保证后续线程访问变量时读取到abc的值，利用synchronize的可见性原则，对abc的修改和读取加锁。<br>文中对volatile部分的例子感觉有点奇怪，利用传递性和volatile的可见性部分，应该是volatile写之前的所有数据对volatile的读的所有数据都可见。利用传递性感觉不是很对，指的是volatile写和它之前的变量操作  与  volatile读与它后续的操作的可见性，但是在volatile之前是可以优化排序的。程序的有序性指的是变量间有依赖关系时有这种程序有序不能重排。","like_count":0},{"had_liked":false,"id":208966,"user_name":"THROW","can_delete":false,"product_type":"c1","uid":1112141,"ip_address":"","ucode":"A3C089A8F5F941","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/4d/4b748ff1.jpg","comment_is_top":false,"comment_ctime":1587474912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587474912","product_id":100023901,"comment_content":"老师您好，请教您下我的理解对不对？：在单核CPU机器保证原子性就可以保证线程安全，在多核CPU机器因为CPU缓存的原因需要同时保证原子性和可见性才能保证线程安全","like_count":0},{"had_liked":false,"id":207182,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1587021372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587021372","product_id":100023901,"comment_content":"使用volatile关键字，保证可见性","like_count":0},{"had_liked":false,"id":202265,"user_name":"Siping","can_delete":false,"product_type":"c1","uid":1487971,"ip_address":"","ucode":"48E685333C663D","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/63/21902253.jpg","comment_is_top":false,"comment_ctime":1585949928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585949928","product_id":100023901,"comment_content":"以前做数据库的，但最近天天 CRUD，好久没看基础理论了。咋感觉还有点模式了","like_count":0},{"had_liked":false,"id":201950,"user_name":"丹诚","can_delete":false,"product_type":"c1","uid":1520747,"ip_address":"","ucode":"001E93D6619F81","user_header":"https://static001.geekbang.org/account/avatar/00/17/34/6b/9119192e.jpg","comment_is_top":false,"comment_ctime":1585880801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585880801","product_id":100023901,"comment_content":"这无非实现共享变量的可见性，只要我设置cpu 缓存失效，让其他线程去加载主内存的数据就好。那么我可以利用volatile，synchronized，以及巧妙利用Happens-Before 规则里的A.JOIN()。","like_count":0},{"had_liked":false,"id":201567,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1585804575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585804575","product_id":100023901,"comment_content":"老师，想请教个问题，<br>1.mintor GC是作用是整个新生代还是仅伊甸园区呢？<br>2.synchronized写在方法上是对象级别的锁么？","like_count":0},{"had_liked":false,"id":198705,"user_name":"Geek_c22199","can_delete":false,"product_type":"c1","uid":1441876,"ip_address":"","ucode":"1CE5B65513E360","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2vn8hyjICTCletGs0omz28lhriaZKX2XX9icYzAEon2IEoRnlXqyOia2bEPP0j7T6xexTnr77JJic8w/132","comment_is_top":false,"comment_ctime":1585464925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585464925","product_id":100023901,"comment_content":"接着上个，多线程参数会加finally 字段修饰保证引用不可变。引用对象的属性如果是引用对象但没有加volatile 字段自然是不能保证修改可见的","like_count":0},{"had_liked":false,"id":198695,"user_name":"Geek_c22199","can_delete":false,"product_type":"c1","uid":1441876,"ip_address":"","ucode":"1CE5B65513E360","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2vn8hyjICTCletGs0omz28lhriaZKX2XX9icYzAEon2IEoRnlXqyOia2bEPP0j7T6xexTnr77JJic8w/132","comment_is_top":false,"comment_ctime":1585464383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585464383","product_id":100023901,"comment_content":"引用类型变量上加volatile 字段是只有该引用被改变的时候才有效吗？如果仅改变对象属性，应该是不可见的，毕竟如果对象属性上没有加的话，是不能保证可见性的","like_count":0},{"had_liked":false,"id":196839,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1585316864,"is_pvip":false,"replies":[{"id":"75068","content":"你可以简单理解为没有中间缓存，所以谁最后写就认谁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1585631293,"ip_address":"","comment_id":196839,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585316864","product_id":100023901,"comment_content":"王老师您好，对于 volatile 变量的使用我一直有一个疑惑。<br><br>比如 volatile 一个变量 x。然后同时有两个线程 A 和 B 在同时写 x 的值，A 和 B 都还没来得及把结果写回主存。<br><br>我的疑惑是：在 A 和 B 都操作完，同时写回主存的时候？会认哪个值呢？还是说同时只能有一个线程在写 volatile 变量？那这不是锁的概念吗？（我这里是对单个 volatile 变量进行写操作，并不是复合操作。）","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489402,"discussion_content":"你可以简单理解为没有中间缓存，所以谁最后写就认谁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585631293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196518,"user_name":"苏暮沉觞","can_delete":false,"product_type":"c1","uid":1577580,"ip_address":"","ucode":"532B816D4EF47B","user_header":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","comment_is_top":false,"comment_ctime":1585289161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585289161","product_id":100023901,"comment_content":"共享变量，因为在一个线程中能设置为3，说明不是final的。要想让其他线程看到，可以有以下几种方式：<br>1、使用volatile修饰这个变量。<br>2、在写这个变量的前后加锁。<br>3、线程修改完后，使用join()","like_count":0},{"had_liked":false,"id":194885,"user_name":"bin.chen","can_delete":false,"product_type":"c1","uid":1135604,"ip_address":"","ucode":"5BA49358AB8A1A","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","comment_is_top":false,"comment_ctime":1585116028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585116028","product_id":100023901,"comment_content":"溢出应该是对象还没有构造完成就让使用者使用了该对象造成的；解决方案就是避免在构造函数内让外部对象使用避免泄漏","like_count":0},{"had_liked":false,"id":190893,"user_name":"大饶Raysir","can_delete":false,"product_type":"c1","uid":1589208,"ip_address":"","ucode":"0AFA191420A30D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTITcwicqBDYzXtLibUtian172tPs7rJpqG1Vab4oGjnguA9ziaYjDCILSGaS6qRiakvRdUEhdmSG0BGPKw/132","comment_is_top":false,"comment_ctime":1584706161,"is_pvip":false,"replies":[{"id":"73434","content":"经典书通俗的不多😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1584792559,"ip_address":"","comment_id":190893,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584706161","product_id":100023901,"comment_content":"与&lt;java并发编程实战&gt;一书相得益彰，书的译本读起来太生硬生涩，老师讲的就通俗易懂的多了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488074,"discussion_content":"经典书通俗的不多😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584792559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186469,"user_name":"cys😁","can_delete":false,"product_type":"c1","uid":1179742,"ip_address":"","ucode":"01A0097B8C4876","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/5e/39db0db9.jpg","comment_is_top":false,"comment_ctime":1583849204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583849204","product_id":100023901,"comment_content":"老师，线程中断规则怎么理解，可以详细举个例子吗","like_count":0},{"had_liked":false,"id":185515,"user_name":"Daiver","can_delete":false,"product_type":"c1","uid":1466447,"ip_address":"","ucode":"9B1A03AFBC79BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","comment_is_top":false,"comment_ctime":1583597451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583597451","product_id":100023901,"comment_content":"老师，为什么逃逸了，global.obj读取到x的值会是0呢？","like_count":0},{"had_liked":false,"id":183841,"user_name":"Airsaid","can_delete":false,"product_type":"c1","uid":1115302,"ip_address":"","ucode":"5B90BC0044F376","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","comment_is_top":false,"comment_ctime":1583144430,"is_pvip":false,"replies":[{"id":"71259","content":"过奖了😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1583234661,"ip_address":"","comment_id":183841,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583144430","product_id":100023901,"comment_content":"老师讲的是真的好，从底层开始讲起，循序渐进，结合一些小例子很容易理解。之前看《Java 并发编程实战》一书，Java 内存模型是最后一章才讲，看完有些琐碎，再结合老师的专栏看，感觉知识点都串联起来了。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485795,"discussion_content":"过奖了😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583234661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183796,"user_name":"Airsaid","can_delete":false,"product_type":"c1","uid":1115302,"ip_address":"","ucode":"5B90BC0044F376","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","comment_is_top":false,"comment_ctime":1583136558,"is_pvip":false,"replies":[{"id":"71261","content":"是的，不包括jvm的实现人员","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1583234714,"ip_address":"","comment_id":183796,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583136558","product_id":100023901,"comment_content":"「Happens-Before 规则应该是 Java 内存模型里面最晦涩的内容了，和程序员相关的规则一共有如下六项，都是关于可见性的。」<br><br>您好老师，这里的程序员指的是并发程序的开发人员是吗？不包括 JVM 的实现人员？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485781,"discussion_content":"是的，不包括jvm的实现人员","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583234714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179599,"user_name":"Geek_bb89c3","can_delete":false,"product_type":"c1","uid":1331828,"ip_address":"","ucode":"0F97B5B0F2DDD6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IZKGetBZDuMEa2VwwtesTELvLORIyV749ItgfAqNPv30n4zEv71wuGNr1aNVIVltG0icvH53DHDuqPuzNpiauWAg/132","comment_is_top":false,"comment_ctime":1582037192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582037192","product_id":100023901,"comment_content":"java内存模型：引起多线程变化的原因有三个。内存可见性，原子性，顺序性。其中原子性是高级语言和低级语言之间的转换。<br>内存可见性和顺序性可以通过happen-before来解决。happen-before主要表示原因一定在结果之前。主要表现是：<br>      1.在程序中共有前后依赖关系的顺序不变。<br>      2.volatile修饰的变量禁用缓存。就是所有在cpu读写都直接在内存中。<br>      3.volatile依赖的传递性，就是如果在volitale修改为某一个状态之前，的状态。如果另外一个线程读到了voltale状态，这个时候也应该读取到前面的那些状态。<br>      4.如果主线程 调用的B线程的start()方法，其中B线程启动后能够看见主线程中所有的操作结果<br>     5. synchronize中，解锁在加锁之后。<br>     6.join()方法，在主线程中调用了join()方法。待join()方法结束后，主线程能够看见 join线程中执行的结果。<br>","like_count":0},{"had_liked":false,"id":177848,"user_name":"林","can_delete":false,"product_type":"c1","uid":1543907,"ip_address":"","ucode":"E1D26D1AB1B14D","user_header":"https://static001.geekbang.org/account/avatar/00/17/8e/e3/a9f4ed7f.jpg","comment_is_top":false,"comment_ctime":1581514630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581514630","product_id":100023901,"comment_content":"final 的这个溢出没太明白 有没有大佬给解释下","like_count":0},{"had_liked":false,"id":171550,"user_name":"Gary","can_delete":false,"product_type":"c1","uid":1208111,"ip_address":"","ucode":"72D438C0EC020A","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/2f/122d41e4.jpg","comment_is_top":false,"comment_ctime":1578965730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578965730","product_id":100023901,"comment_content":"文章能看懂，但是可见性和有序性与java的内存模型有什么关系呢","like_count":0},{"had_liked":false,"id":170054,"user_name":"花子翁","can_delete":false,"product_type":"c1","uid":1073674,"ip_address":"","ucode":"A687441DC6894F","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/0a/26d00cb9.jpg","comment_is_top":false,"comment_ctime":1578498482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578498482","product_id":100023901,"comment_content":"1 加volatile修饰符<br>2  利用管程的锁，即用synchronized<br>3 利用start()和join()方法,实现线程间调用的来关联这两个线程实现可见性","like_count":0},{"had_liked":false,"id":169940,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1641319,"ip_address":"","ucode":"E1184E76B14431","user_header":"https://static001.geekbang.org/account/avatar/00/19/0b/67/dc49a1a8.jpg","comment_is_top":false,"comment_ctime":1578478857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578478857","product_id":100023901,"comment_content":"没有明白单例模式双重检查中为什么用final来代替volatile会出现:可能看到 final 变量的值会变化这种情况 请老师解惑一下","like_count":0},{"had_liked":false,"id":169896,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1578469190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578469190","product_id":100023901,"comment_content":"如果线程 B 读到了“v=true”，那么线程 A 设置的“x=42”对线程 B 是可见的。也就是说，线程 B 能看到 “x == 42” ，这句话的意思是x=42也被禁用缓存了？","like_count":0},{"had_liked":false,"id":168122,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1578016250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578016250","product_id":100023901,"comment_content":"针对本篇的Happens-Before规则：<br>1.程序的顺序性(不适合，这是单线程操作)<br>2.volatile变量和传递性，将共享变量abc在第一个线程写入，Happens-Before对一个volatile变量的写，然后在第二个线程中读volatile变量，然后读共享变量abc。<br>3.管程中锁的规则，对共享变量的写操作放在管程中，第一个线程先写入共享变量abc，然后第二个线程读共享变量abc。<br>4.线程start()规则，在第一个线程中start()第二个线程，在start()之前对共享变量abc的写在第二个线程中应该也是可见的。<br>5.线程join()规则，在第二个线程中join第一个线程，在第一个线程中对共享变量abc的写操作对于第二个线程是可见的。","like_count":0},{"had_liked":false,"id":167662,"user_name":"华刚","can_delete":false,"product_type":"c1","uid":1206409,"ip_address":"","ucode":"19998032377B0B","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/89/f57cbd87.jpg","comment_is_top":false,"comment_ctime":1577888630,"is_pvip":false,"replies":[{"id":"65465","content":"hb规则是要帮助我们不用折腾内存，缓存，寄存器，也能推导出可见性。所以没必要往回折腾，那是jvm的开发人员要考虑的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1578208408,"ip_address":"","comment_id":167662,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577888630","product_id":100023901,"comment_content":"Happen-before的规则1是否可以这么理解<br>线程1执行v=true后，不只是将v的值刷新内存，而是将v=true之前的所有共享变量操作都刷新到内存","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479935,"discussion_content":"hb规则是要帮助我们不用折腾内存，缓存，寄存器，也能推导出可见性。所以没必要往回折腾，那是jvm的开发人员要考虑的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578208408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166049,"user_name":"a(๑≖ิټ≖ิ)✌","can_delete":false,"product_type":"c1","uid":1392431,"ip_address":"","ucode":"AEF9B5CA1605DF","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","comment_is_top":false,"comment_ctime":1577370599,"is_pvip":false,"replies":[{"id":"63412","content":"总结的到位👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1577444984,"ip_address":"","comment_id":166049,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1577370599","product_id":100023901,"comment_content":"看完这篇的理解，Happens-Before原则就是如果一个线程”看到“另一个线程发生的事，那那个线程那个事发生之前的事这个线程也一定可以看到","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479374,"discussion_content":"总结的到位👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577444984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164994,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1577144523,"is_pvip":false,"replies":[{"id":"62980","content":"我只能说，如果写操作完成后，能读到最新值，就说明有可见性。前提这个词大家的理解偏差很大。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1577189031,"ip_address":"","comment_id":164994,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577144523","product_id":100023901,"comment_content":"老师问下，可见性的前提是不是意味着写操作的时间在读操作时间之前？<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478977,"discussion_content":"我只能说，如果写操作完成后，能读到最新值，就说明有可见性。前提这个词大家的理解偏差很大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577189031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164779,"user_name":"沐","can_delete":false,"product_type":"c1","uid":1326537,"ip_address":"","ucode":"678F6A0C778CDD","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/c9/a1e6a307.jpg","comment_is_top":false,"comment_ctime":1577090044,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1577090044","product_id":100023901,"comment_content":"程序顺序性原则指的是运行时实际执行的顺序。<br>由于指令重排序，实际执行的顺序可能跟代码中写的顺序不一致。<br>而volatile禁止了指令重排序。可以保证顺序执行。","like_count":0},{"had_liked":false,"id":164074,"user_name":"遥遥无妻","can_delete":false,"product_type":"c1","uid":1251243,"ip_address":"","ucode":"30A765B411D059","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/ab/c0235b70.jpg","comment_is_top":false,"comment_ctime":1576854572,"is_pvip":false,"replies":[{"id":"62403","content":"这个时候v==false，不会读x","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1576910593,"ip_address":"","comment_id":164074,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576854572","product_id":100023901,"comment_content":"老师问你下，程序就是文中的参考1示例代码，有没有这种情况，程序执行writer方法，按照第一课的秒数，线程切换可能发生在任何一条cpu指令执行完毕，这里有可能刚进入writer方法就发生了线程切换，以至于reader读出x=0的情况是否会发生。<br><br>&#47;&#47; 以下代码来源于【参考1】<br>class VolatileExample {<br>  int x = 0;<br>  volatile boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      &#47;&#47; 这里x会是多少呢？<br>    }<br>  }<br>}","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478634,"discussion_content":"这个时候v==false，不会读x","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576910593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251243,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/ab/c0235b70.jpg","nickname":"遥遥无妻","note":"","ucode":"30A765B411D059","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93675,"discussion_content":"刚开始理解错了，其实是有可能线程切换的，只是说一旦线程A改了值线程b一定看得到，不是说不会发生线程切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576934743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151747,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1573784725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573784725","product_id":100023901,"comment_content":"利用Happens-Before规则 线程 start() 规则 和 线程 join() 规则，在设置 abc=3的线程里面start其它线程，或者在其它线程里面join设置abc=3的线程都可以实现","like_count":0},{"had_liked":false,"id":149504,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1573259994,"is_pvip":false,"replies":[{"id":"67119","content":"伪代码","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579439183,"ip_address":"","comment_id":149504,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573259994","product_id":100023901,"comment_content":"老师，确认一下：里面的var,global.obj是伪代码，为了表达这个意思，还是说这是很多语言通用的，你用的其他函数式语言等写的","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473886,"discussion_content":"伪代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579439183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147497,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1572867021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572867021","product_id":100023901,"comment_content":"并发编程从全局来看，有分工、同步、互斥三个模块组成；<br>而并发编程需要满足的三个特性：可见性、原子性、有序性。<br>可见性指一个线程对共享数据的更改，对另一个线程是可见的。<br>原子性指一个或多个在CPU的操作是不可中断的<br>有序性指在编译优化后，尽管指令的执行顺序被更改，依然不影响相应的数据<br><br>为了解决并发编程中出现的以上几个问题，在Java中引入了内存模型的概念。<br><br>由于在日常开发中可能对内存模型接触的不多，大多数的开发人员并不熟悉这个概念（包括我）。<br><br>Java内存模型需要掌握的是Happen-before规则。","like_count":0},{"had_liked":false,"id":144480,"user_name":"归零","can_delete":false,"product_type":"c1","uid":1103208,"ip_address":"","ucode":"C99B8E93009A46","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/68/2201b6b9.jpg","comment_is_top":false,"comment_ctime":1571934250,"is_pvip":true,"replies":[{"id":"55723","content":"书写顺序是BA，无论如何都不会A hb B的，这些规则，本质上是约束编译优化，尽量按照程序的书写顺序执行。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571976785,"ip_address":"","comment_id":144480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571934250","product_id":100023901,"comment_content":"有一点不太理解，所谓的A happens-before B，那么A对于B是可见的，此时的A和B可能由于重排序，A的代码在后B的代码在前（书写顺序），但是执行A在前B在后，那么也就符合了A对B可见吗？谢谢老师","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471965,"discussion_content":"书写顺序是BA，无论如何都不会A hb B的，这些规则，本质上是约束编译优化，尽量按照程序的书写顺序执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571976785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142062,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1571286343,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571286343","product_id":100023901,"comment_content":"Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译...<br><br>","like_count":0},{"had_liked":false,"id":138173,"user_name":"哈皮宝","can_delete":false,"product_type":"c1","uid":1056059,"ip_address":"","ucode":"8C4DB072758817","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/3b/022773c9.jpg","comment_is_top":false,"comment_ctime":1570075252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570075252","product_id":100023901,"comment_content":"一、Java内存模型<br><br>Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法<br><br>二、Happens Before原则：<br><br>前面一个操作的结果对后续操作是可见的<br><br>Happens-Before约束了编译器的优化行为，虽允许编译器优化，但要求编译器优化后一定遵守Happens-Before规则。<br><br>1.程序的顺序性规则<br><br>在一个线程中，按照程序顺序，前面的操作Happens-Before于后续的任意操作。<br><br>2.volatile变量规则<br><br>对一个volatile变量的写规则，Happens-Before于后续对这个volatile变量的读操作。<br><br>3.传递性<br><br>如果A Happens-Before B，B Happens-Before C，那么A Happens-Before C<br><br>4.管程中锁的规则<br><br>对一个锁的解锁Happens-Before于后续对这个锁的加锁。<br><br>管程是什么？---管程是一种通用的同步原语，在Java中指的就是synchronized，synchronized是Java里对管程的实现。<br><br>5.线程start()规则<br><br>这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。<br><br>6.线程join()规则<br><br>主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。","like_count":0},{"had_liked":false,"id":137277,"user_name":"小氘","can_delete":false,"product_type":"c1","uid":1622109,"ip_address":"","ucode":"DA55B9A02D9EE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","comment_is_top":false,"comment_ctime":1569675216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569675216","product_id":100023901,"comment_content":"关于课后思考题我只想出一个解。用volatile修饰变量，根据规则volatile修饰变量的写操作happens-before该变量的读操作，因此其他线程可以看到abc变量==3。","like_count":0},{"had_liked":false,"id":134413,"user_name":"榴芒科技","can_delete":false,"product_type":"c1","uid":1312485,"ip_address":"","ucode":"EC297012B1B942","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DwZUsQhia0wIWNEfeGZ2srQWzVC04JjLFDwgmicpnNF3mUPdRJD6U6vviceJqMxGYUGtxaiaZWltyNtQ5fZhia7YN3w/132","comment_is_top":false,"comment_ctime":1568820495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568820495","product_id":100023901,"comment_content":"消息总线的方式 通知刷新缓存","like_count":0},{"had_liked":false,"id":133771,"user_name":"铿然","can_delete":false,"product_type":"c1","uid":1162461,"ip_address":"","ucode":"D529242EC2E2EA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/dd/c9413f59.jpg","comment_is_top":false,"comment_ctime":1568649307,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1568649307","product_id":100023901,"comment_content":"@小和尚笨南北  的答案不完全正确，会误导的。<br><br>补充一个： 在abc赋值后对一个volatile变量A进行赋值操作，然后在其他线程读取abc之前读取A的值，通过volatile的可见性和happen-before的传递性实现abc修改后对其他线程立即可见<br><br>这里其他线程只是读取A的值没有用，因为可能abc线程还没执行，就算abc执行了也未必正确，应该加上判断条件，B线程里读取到的A值要等于abc线程里设置的值时才行。<br><br>Happe-before规则并没有说在【不同线程】里读写volatile变量时，写操作一定发生在读操作之前，如果读的线程先运行，写线程还没运行呢？","like_count":0},{"had_liked":false,"id":133081,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1568350132,"is_pvip":false,"replies":[{"id":"50966","content":"我觉得理论上还是可以优化一部分的，没搞过编译器，详情我也不清楚","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568366890,"ip_address":"","comment_id":133081,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568350132","product_id":100023901,"comment_content":"请问老师，Happen-before规则1会不会导致编译器无法进行乱序优化呢？换一个问法就是，编译器的乱序优化与规则1不会有矛盾吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467251,"discussion_content":"我觉得理论上还是可以优化一部分的，没搞过编译器，详情我也不清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568366890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138821,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","nickname":"与路同飞","note":"","ucode":"2985F1440A1962","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298679,"discussion_content":"不会的，happen-before规则1是针对可见性的。\n    加入 a = 2， b = 3。这2个赋值操作没有依赖性的，cpu是可以乱序优化的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597376867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132066,"user_name":"叶鹏","can_delete":false,"product_type":"c1","uid":1253052,"ip_address":"","ucode":"209A8B210C340B","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/bc/6839e3ca.jpg","comment_is_top":false,"comment_ctime":1568018108,"is_pvip":false,"replies":[{"id":"50587","content":"google😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568082922,"ip_address":"","comment_id":132066,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568018108","product_id":100023901,"comment_content":"老师，你好，我看到老师使用的一些案例和参考文档是英文的，请问这些内容一般是从哪里获取的？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466743,"discussion_content":"google😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568082922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1e/bc/6839e3ca.jpg","nickname":"叶鹏","note":"","ucode":"209A8B210C340B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8873,"discussion_content":"哈哈，那这个还是要求英文要不错，看来英语还是要加强学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568088558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128926,"user_name":"东风第一枝","can_delete":false,"product_type":"c1","uid":1402697,"ip_address":"","ucode":"0CD0F62E90DAD8","user_header":"https://static001.geekbang.org/account/avatar/00/15/67/49/864dba17.jpg","comment_is_top":false,"comment_ctime":1566985211,"is_pvip":false,"replies":[{"id":"47869","content":"你可以把volatile变量简单的理解为不允许CPU缓存，所以一个线程更改了，另一个线程之后一定能读到最新的。仔细想想，两种说法都对，变量不读它，他变不变就没有意义。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566989299,"ip_address":"","comment_id":128926,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566985211","product_id":100023901,"comment_content":"请教老师一个问题，线程1和线程2同时读取了volatile变量后，线程1对volatile变量进行了更新，更新完成后线程2中volatile变量是立即更新，还是等下一次读取的时候更新。网上有不同的说法，有点纠结。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465180,"discussion_content":"你可以把volatile变量简单的理解为不允许CPU缓存，所以一个线程更改了，另一个线程之后一定能读到最新的。仔细想想，两种说法都对，变量不读它，他变不变就没有意义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566989299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127736,"user_name":"Geek_ab689a","can_delete":false,"product_type":"c1","uid":1619165,"ip_address":"","ucode":"152D1AE15F0C9E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83equSjO9AVmwhkt5Grf54q4VJFPz8QaYtYvAxxQw9D28touZYcmAIsI0GZxdv0DuFvzyLZA4j57SlQ/132","comment_is_top":false,"comment_ctime":1566786383,"is_pvip":false,"replies":[{"id":"47357","content":"final不能用于双重检查，语法约束","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566793779,"ip_address":"","comment_id":127736,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566786383","product_id":100023901,"comment_content":"王老师您好，根据文章中的&quot;当然了，在 1.5 以后 Java 内存模型对 final类型变量的重排进行了约束&quot;，这也就是说双重校验锁的单例模式，只要使用final来修饰单例对象，就不会发生之前提到过的，先分配内存，之后创建对象引用，最后再实际创建对象(指令重排)这种情况了吧？<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464629,"discussion_content":"final不能用于双重检查，语法约束","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566793779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126894,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1242497,"ip_address":"","ucode":"2521FB6292F304","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/81/92d01e3a.jpg","comment_is_top":false,"comment_ctime":1566518964,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566518964","product_id":100023901,"comment_content":"编译指令优化是CPU指令级别还是应用代码级别的？","like_count":0,"discussions":[{"author":{"id":1196339,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/33/d1064f9a.jpg","nickname":"Sun","note":"","ucode":"1BC2741DC07FC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198825,"discussion_content":"jvm层面和cpu层面都有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583515204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122589,"user_name":"几米阳光","can_delete":false,"product_type":"c1","uid":1157656,"ip_address":"","ucode":"0FE186125049A6","user_header":"https://static001.geekbang.org/account/avatar/00/11/aa/18/dfd867af.jpg","comment_is_top":false,"comment_ctime":1565429419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565429419","product_id":100023901,"comment_content":"1、volatile修饰abc变量<br>2、final修饰abc变量<br>3、synchornize语块中对abc变量设值","like_count":0},{"had_liked":false,"id":117380,"user_name":"Fortune","can_delete":false,"product_type":"c1","uid":1508654,"ip_address":"","ucode":"6B9465AC996523","user_header":"https://static001.geekbang.org/account/avatar/00/17/05/2e/5a6b6b6e.jpg","comment_is_top":false,"comment_ctime":1564036280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564036280","product_id":100023901,"comment_content":"看了评论后，感觉自己还是不确定怎么理解哈，先感谢老师的分享，希望总结这块老师可以对知识点进行一个确切的总结，就是要让我们这些小白知道些什么就可以了，上网看了下HB规则的理解：<br>1：就是说我们编写的程序都要经过优化后（编译器和处理器会对我们的程序进行优化以提高运行效率）才会被运行，优化分为很多种，其中有一种优化叫做重排序，重排序需要遵守happens-before规则，这里参考老师列出的规则，很详细；<br>2：程序顺序规则中所说的每个操作happens-before于该线程中的任意后续操作并不是说前一个操作必须要在后一个操作之前执行，而是指前一个操作的执行结果必须对后一个操作可见，如果不满足这个要求那就不允许这两个操作进行重排序。<br>规则总结：<br>程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！<br><br>管程锁定规则：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）<br><br>volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。<br><br>线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。（线程start规则）<br><br>线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。<br><br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。<br><br>传递规则：这个简单的，就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。<br><br>对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。<br>以及老师说的final规则和线程 join() 规则。","like_count":0},{"had_liked":false,"id":115897,"user_name":"宝石山","can_delete":false,"product_type":"c1","uid":1295061,"ip_address":"","ucode":"3ADF20E12EBF99","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/d5/126eac1a.jpg","comment_is_top":false,"comment_ctime":1563763309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563763309","product_id":100023901,"comment_content":"关于Happens-Before原则的第四条&lt;管程中锁的规则&gt;, 有这样一段代码假设i初始值是0, 两个同步块用了不同的锁, 那么线程A的同步块执行完了执行线程B的同步块这个时候i能看到10吗? 我觉得是能看到10的, 因为线程A执行完了会把i刷入内存, 那么这个时候线程B会拿到新值<br><br>线程A执行<br>...<br>synchronized(lock1){<br>\ti = 10;<br>}<br>...<br><br>线程B执行<br>...<br>synchronized(lock2){<br>\tSystem.out.print(i)<br>}<br>...","like_count":0},{"had_liked":false,"id":115451,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1563590749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563590749","product_id":100023901,"comment_content":"---总结---<br>1.A Happens-before B并非指操作A一定发生在操作B之前，而是指A操作的结果对B操作可见。<br>2.JAVA内存模型主要是针对可见性问题（又称为内存重排序问题）和有序性问题（又称为指令重排序问题）的解决方案。","like_count":0},{"had_liked":false,"id":113459,"user_name":"赵小洛","can_delete":false,"product_type":"c1","uid":1592232,"ip_address":"","ucode":"A326C12B1A1ABA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/a8/14b8a860.jpg","comment_is_top":false,"comment_ctime":1563021354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563021354","product_id":100023901,"comment_content":"思考题：<br>1.可以使用 volatile 修饰共享变量<br>2.可以对修改共享变量的操作或者方法  加上synchronize<br>3.如果一个 是子线程 一个主线程 可以使用子线程的join方法，然后主线程就可见。<br><br>疑问：<br>public static void main(String[] args) {<br><br>        final int[] a = {200};<br>        Thread thread = new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                a[0] = 300;<br>                System.out.println(&quot;我是子线程&quot;+Thread.currentThread().getName()+&quot;  &quot;+a[0]);<br>            }<br>        });<br><br>        Thread thread2 = new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                System.out.println(&quot;我是子线程&quot;+Thread.currentThread().getName()+&quot;  &quot;+a[0]);<br>            }<br>        });<br><br>        thread.start();<br>        thread2.start();<br>        System.out.println(a[0]);<br><br>    }<br><br><br><br><br>输出的结果 <br>200<br>我是子线程Thread-0  300<br>我是子线程Thread-1  300<br><br><br>为什么 两个子线程拿到的结果是一样的？ 为什么主线程和子线程结果不一样<br><br><br><br>","like_count":0},{"had_liked":false,"id":112743,"user_name":"ccf2019","can_delete":false,"product_type":"c1","uid":1260710,"ip_address":"","ucode":"E9D6F4066EB3DD","user_header":"https://static001.geekbang.org/account/avatar/00/13/3c/a6/acaf5a24.jpg","comment_is_top":false,"comment_ctime":1562813252,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562813252","product_id":100023901,"comment_content":"    public static void main(String[] args) {<br><br>        Map&lt;String, Integer&gt; params = new HashMap&lt;&gt;();<br>        params.put(&quot;must_fields&quot;,2);<br>        params.put(&quot;should_fields&quot;,5);<br>        params.put(&quot;must_not_fields&quot;,1);<br><br>        CompletableFuture mustFuture = CompletableFuture.runAsync(() -&gt; {<br>            if(params.containsKey(&quot;must_fields&quot;)){<br>                Integer must = params.get(&quot;must_fields&quot;);<br>                for (int i = 0;i&lt;100000;i++){<br>                    must += 1;<br>                }<br>                params.put(&quot;must_fields&quot;,must);<br>            }<br>        });<br><br>        CompletableFuture shouldFuture = CompletableFuture.runAsync(() -&gt; {<br>            if(params.containsKey(&quot;should_fields&quot;)){<br>                Integer should = params.get(&quot;should_fields&quot;);<br>                for (int i = 0;i&lt;10000;i++){<br>                    should += 1;<br>                }<br>                params.put(&quot;should_fields&quot;,should);<br>            }<br>        });<br><br><br>        CompletableFuture notFuture = CompletableFuture.runAsync(() -&gt; {<br>            if(params.containsKey(&quot;must_not_fields&quot;)){<br>                Integer not = params.get(&quot;must_not_fields&quot;);<br>                for (int i = 0;i&lt;10000;i++){<br>                    not += 1;<br>                }<br>                params.put(&quot;must_not_fields&quot;,not);<br>            }<br>        });<br><br>        mustFuture.join();<br>        shouldFuture.join();<br>        notFuture.join();<br><br>        System.out.println(&quot;完毕&quot;);<br>        System.out.println(params.toString());<br>    }<br>老师，我这样写程序，params这个里面的数据会不会每次都不相同呢？","like_count":0,"discussions":[{"author":{"id":1004192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/a0/d308434e.jpg","nickname":"StarKing","note":"","ucode":"EB825CFA70AC1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14862,"discussion_content":"和 thread.start()一样的.带了join()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568784779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110559,"user_name":"itschenxiang","can_delete":false,"product_type":"c1","uid":1519547,"ip_address":"","ucode":"7D90194AC52435","user_header":"https://static001.geekbang.org/account/avatar/00/17/2f/bb/4236d712.jpg","comment_is_top":false,"comment_ctime":1562294348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562294348","product_id":100023901,"comment_content":"请问ide的debug功能是怎样的机制？主要是想了解debug是不是就不会优化比如语句的前后顺序变了什么的","like_count":0},{"had_liked":false,"id":108356,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1561727467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561727467","product_id":100023901,"comment_content":"对于重排序那里，我的理解是当其他线程看到v为true的时候，必须要保证x已经赋值为42了，这个就是顺序性原则。同时也说明了volatile关键字还是影响了x，并不能说真正意义上的v跟x没关系。","like_count":0},{"had_liked":false,"id":107220,"user_name":"a(๑≖ิټ≖ิ)✌","can_delete":false,"product_type":"c1","uid":1392431,"ip_address":"","ucode":"AEF9B5CA1605DF","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","comment_is_top":false,"comment_ctime":1561489338,"is_pvip":false,"replies":[{"id":"38788","content":"可见性指的是设置了abc=3之后，其他线程是否看得到","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561506525,"ip_address":"","comment_id":107220,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1561489338","product_id":100023901,"comment_content":"我觉得volatile不一定能保证其他线程看到3，除非能保证设置3的线程在其他线程读取abc这个变量之前先执行到设置abc=3的那行，以前没用过volatile关键字，不知道我的理解对不对","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455424,"discussion_content":"可见性指的是设置了abc=3之后，其他线程是否看得到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561506525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107219,"user_name":"a(๑≖ิټ≖ิ)✌","can_delete":false,"product_type":"c1","uid":1392431,"ip_address":"","ucode":"AEF9B5CA1605DF","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","comment_is_top":false,"comment_ctime":1561487293,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1561487293","product_id":100023901,"comment_content":"思考题除了其他同学的回答，我想到用completableFuture不知道算不算，<br><br>        CompletableFuture.supplyAsync(() -&gt; obj.set3()).thenAcceptAsync(obj1 -&gt; {<br>            try {<br>                Assert.assertEquals(0, obj1.get3());<br>            } catch (Exception e) {<br>                log.info(e.getMessage());<br>            }<br>        }).get();<br>    ","like_count":0},{"had_liked":false,"id":107216,"user_name":"a(๑≖ิټ≖ิ)✌","can_delete":false,"product_type":"c1","uid":1392431,"ip_address":"","ucode":"AEF9B5CA1605DF","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","comment_is_top":false,"comment_ctime":1561483421,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1561483421","product_id":100023901,"comment_content":"Thread B = new Thread(()-&gt;{<br>  &#47;&#47; 主线程调用 B.start() 之前<br>  &#47;&#47; 所有对共享变量的修改，此处皆可见<br>  &#47;&#47; 此例中，var==77<br>});<br>&#47;&#47; 此处对共享变量 var 修改<br>var = 77;<br>&#47;&#47; 主线程启动子线程<br>B.start();<br><br>这段代码里，var = 77这个，因为在lambda表达式里用到了，定义时在java里面必须为final吧（我试着改为继承Thread的匿名内部类，也得是final的），也就是说在这不能再次赋值为77，是不是这个例子举错了？","like_count":0},{"had_liked":false,"id":107067,"user_name":"Tomcat","can_delete":false,"product_type":"c1","uid":1399488,"ip_address":"","ucode":"58A9D44991EDB7","user_header":"https://static001.geekbang.org/account/avatar/00/15/5a/c0/e20eb855.jpg","comment_is_top":false,"comment_ctime":1561452180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561452180","product_id":100023901,"comment_content":"我觉得前三条的例子用start原则去理解更加简单一些吧     如果在两个线程中进行读写的话  在启动线程之前x v都已经赋值了  所以主线程的操作对 其余两个线程都是可见的","like_count":0},{"had_liked":false,"id":106522,"user_name":"chuenfaiy","can_delete":false,"product_type":"c1","uid":1291234,"ip_address":"","ucode":"71F1898C8CACA5","user_header":"https://static001.geekbang.org/account/avatar/00/13/b3/e2/7bdc7255.jpg","comment_is_top":false,"comment_ctime":1561339040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561339040","product_id":100023901,"comment_content":"我觉得第一条的顺序性是建立在后面几条规则的基础上的，即依赖于volatile，synchronized，join，start这些操作设置内存屏障","like_count":0},{"had_liked":false,"id":106103,"user_name":"子非鱼","can_delete":false,"product_type":"c1","uid":1146001,"ip_address":"","ucode":"7577222878C1E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/7c/91/0d8e2472.jpg","comment_is_top":false,"comment_ctime":1561175077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561175077","product_id":100023901,"comment_content":"有一点不解，happens-before 原则2那里，被volatile修饰的变量的写操作happens before对这个变量的读操作，意思是被volatile修饰的变量的写操作已经是原子操作了吗，毕竟写操作原本映射成机器指令是需要几步才能完成的","like_count":0},{"had_liked":false,"id":105014,"user_name":"太阳是块坚冰","can_delete":false,"product_type":"c1","uid":1049787,"ip_address":"","ucode":"65248FD55F1DB5","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/bb/dc12831e.jpg","comment_is_top":false,"comment_ctime":1560905630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560905630","product_id":100023901,"comment_content":"第三次看本篇文章，每次都有不同的感悟，感谢老师和各位评论区的大神。","like_count":0},{"had_liked":false,"id":103293,"user_name":"iHelin","can_delete":false,"product_type":"c1","uid":1001364,"ip_address":"","ucode":"B9C15A0674B46D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/94/9682a82e.jpg","comment_is_top":false,"comment_ctime":1560410302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560410302","product_id":100023901,"comment_content":"最后的思考题，如果在一个线程里设置了 abc 的值 为3，那么在这个线程里面创建新的线程，这些新的线程应该就能看到了吧？参考happens-before规则中的线程start规则。","like_count":0},{"had_liked":false,"id":100539,"user_name":"晴天听夜曲","can_delete":false,"product_type":"c1","uid":1245813,"ip_address":"","ucode":"D0099EC299A18C","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/75/96a111c1.jpg","comment_is_top":false,"comment_ctime":1559573192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559573192","product_id":100023901,"comment_content":"之前对java并发总是敬而远之,但是看了老师的课之后,感觉自己确实差了很多.加油吧","like_count":0},{"had_liked":false,"id":100139,"user_name":"Knight²º¹⁸","can_delete":false,"product_type":"c1","uid":1089754,"ip_address":"","ucode":"BDCB830B6A730F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg","comment_is_top":false,"comment_ctime":1559456911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559456911","product_id":100023901,"comment_content":"JMM 中的工作内存对应到物理设备上到底指是哪块内存？CPU Cahce 还是 ARM？这个问题一直没有搞懂。","like_count":0},{"had_liked":false,"id":98753,"user_name":"恪","can_delete":false,"product_type":"c1","uid":1445711,"ip_address":"","ucode":"4DE93FEC0AD403","user_header":"https://static001.geekbang.org/account/avatar/00/16/0f/4f/6c2339f9.jpg","comment_is_top":false,"comment_ctime":1559090917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559090917","product_id":100023901,"comment_content":"程序的顺序性前提是在一个线程中，如果x=42;和v=true不在一个线程中。那么是不是reader方法还是会存在读不到x=42","like_count":0},{"had_liked":false,"id":97696,"user_name":"猴哥一一 cium","can_delete":false,"product_type":"c1","uid":1254801,"ip_address":"","ucode":"38EC64F8D1A0B4","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/91/46600294.jpg","comment_is_top":false,"comment_ctime":1558750649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558750649","product_id":100023901,"comment_content":"看完这篇讲解，让我想起“内存模型是jvm保证线程安全的一系列规范”这句话。不知恰当不","like_count":0},{"had_liked":false,"id":97446,"user_name":"Sam","can_delete":false,"product_type":"c1","uid":1183165,"ip_address":"","ucode":"701948553DB5FE","user_header":"https://static001.geekbang.org/account/avatar/00/12/0d/bd/57ab02f5.jpg","comment_is_top":false,"comment_ctime":1558673454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558673454","product_id":100023901,"comment_content":"volatile变量规则疑惑：<br> 对一个volatile变量的写操作，Happens-Before于后续对这个变量的读操作，对这句话的理解，也就是如果有一个volatile变量，有两个线程一个在写这个变量，一个在读这个变量，那么肯定是写先执行，读后执行，那么我的疑惑是，假如写的这个线程在写之前休眠了一段时间，那么读变量这个线程只能在此时等着它写完才能读到值，这中间一直在等待状态吗？<br>请老师或者同学帮忙解答一下，感谢呢！","like_count":0},{"had_liked":false,"id":97182,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1110113,"ip_address":"","ucode":"2D2E877CF97138","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg","comment_is_top":false,"comment_ctime":1558603128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558603128","product_id":100023901,"comment_content":"关于senekis说对实现方式中：<br>2.声明共享变量abc，在synchronized关键字对abc的赋值代码块加锁，由于Happen-before管程锁的规则，可以使得后续的线程可以看到abc的值。<br><br>我的测试代码为：<br><br>public class TestMemoryBarrier2 {<br><br>\tint abc = 0;<br><br>\tint read() {<br>\t\treturn abc;<br>\t}<br><br>\tsynchronized void write() {<br>\t\tabc = 3;<br>\t}<br><br>\tpublic static void main(String[] args) throws InterruptedException {<br>\t\tTestMemoryBarrier2 instance = new TestMemoryBarrier2();<br><br>\t\tnew Thread(() -&gt; {<br>\t\t\twhile (instance.read() != 3) {<br><br>\t\t\t}<br>\t\t\tSystem.out.println(&quot;Thread 1 读取到了变量abc到值为3.&quot;);<br>\t\t}).start();<br><br>\t\tThread.sleep(1000);<br><br>\t\tnew Thread(() -&gt; {<br>\t\t\tinstance.write();<br>\t\t\tSystem.out.println(&quot;Thread 2 将变量abc改为了3.&quot;);<br>\t\t}).start();<br>\t}<br>}<br>在jdk1.8中运行，一直没有执行：Thread 1 读取到了变量abc到值为3.<br>但是我在线程1中增加了打印：<br>\t\tnew Thread(() -&gt; {<br>\t\t\twhile (instance.read() != 3) {<br>\t\t\t\tSystem.out.println(&quot;Thread 1 没有读取到了变量abc到值为3.&quot;);&#47;&#47;增加到代码<br>\t\t\t}<br>\t\t\tSystem.out.println(&quot;Thread 1 读取到了变量abc到值为3.&quot;);<br>\t\t}).start();<br>线程1又可以读到abc为3了，打印了Thread 1 读取到了变量abc到值为3.<br>然后我将锁放在了读取上，却能读取到3，打印了Thread 1 读取到了变量abc到值为3.<br>具体代码为：<br>public class TestMemoryBarrier2 {<br><br>\tint abc = 0;<br><br>\tsynchronized int read() {<br>\t\treturn abc;<br>\t}<br><br>\tvoid write() {<br>\t\tabc = 3;<br>\t}<br><br>\tpublic static void main(String[] args) throws InterruptedException {<br>\t\tTestMemoryBarrier2 instance = new TestMemoryBarrier2();<br><br>\t\tnew Thread(() -&gt; {<br>\t\t\twhile (instance.read() != 3) {<br>\t\t\t}<br>\t\t\tSystem.out.println(&quot;Thread 1 读取到了变量abc到值为3.&quot;);<br>\t\t}).start();<br><br>\t\tThread.sleep(1000);<br><br>\t\tnew Thread(() -&gt; {<br>\t\t\tinstance.write();<br>\t\t\tSystem.out.println(&quot;Thread 2 将变量abc改为了3.&quot;);<br>\t\t}).start();<br>\t}<br>}<br>这个是什么原因呢？没有想明白。","like_count":0},{"had_liked":false,"id":96454,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1558427905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558427905","product_id":100023901,"comment_content":"@Junzi 是个好问题，write() 方法内不会进行重排序。volitile只是说 对他的读会从主内存读取，而不会缓存拿，另一个作用就是加内存屏障，防止重排。","like_count":0},{"had_liked":false,"id":95895,"user_name":"L","can_delete":false,"product_type":"c1","uid":1357311,"ip_address":"","ucode":"5B847B2378854E","user_header":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","comment_is_top":false,"comment_ctime":1558248276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558248276","product_id":100023901,"comment_content":"<br>Happens-Before 并不是说前面一个操作发生在后续操作的前面，<br>它真正要表达的是：前面一个操作的结果对后续操作是可见的。<br><br><br>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。<br><br><br>这是说一点我自己的理解：既然 JVM 需要遵循 JVM内存模型 的 Happens-Before 规则！！！<br> <br> 那么我大致推导一下：<br> <br> 假如现在只有A、B两个操作，那么 JVM 可能只需遵守 Happens-Before 规则1、2                  ---&gt; 此时称为 编译优化1<br> <br> 而假如现在有A、B、C三个操作，那么 JVM 可能就需遵守 Happens-Before 规则1、2、3、4          ---&gt; 此时称为 编译优化2<br> <br> 那么，这里的 编译优化1 就可能 == 编译优化2，也可能 !=编译优化2  ！！！<br> <br> 这样，我觉得就全部都通了！！！<br><br>不知道以上理解对不对？？？","like_count":0},{"had_liked":false,"id":94695,"user_name":"Geek_477adb","can_delete":false,"product_type":"c1","uid":1288787,"ip_address":"","ucode":"27C071C2C09E74","user_header":"","comment_is_top":false,"comment_ctime":1557882726,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1557882726","product_id":100023901,"comment_content":"按需禁用缓存，这里的缓存是指高速缓存，所谓禁用缓存是指CPU在进行运算前将数据加载到数据寄存器的时候，跳过高速缓存而直接去内存（不是JMM中的主内存）中查找么","like_count":0,"discussions":[{"author":{"id":1004192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/a0/d308434e.jpg","nickname":"StarKing","note":"","ucode":"EB825CFA70AC1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14870,"discussion_content":"强制使用主存中的数据,将本CPU内高速缓存数据作废.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568785341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94478,"user_name":"彭锐","can_delete":false,"product_type":"c1","uid":1179669,"ip_address":"","ucode":"F2CB53DE42026D","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/15/6e399ec7.jpg","comment_is_top":false,"comment_ctime":1557821401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557821401","product_id":100023901,"comment_content":"理解了JMM，但为什么C&#47;C++语言没有内存模型的说法？我已经想了几个原因：<br>1. C是编译型的，直接操作操作系统接口，pthread，直接用操作系统的能力解决问题，而Java定义的Thread对象，在操作系统之上加了一层；<br>2. C语言一定也有可见性和原子性问题，但不会这么冲出，因为Java是面向对象的，对象都是堆的，堆的都是共享的；如本文的例子，用C写都是栈内存；<br>3. C编译优化没有那么多诡异的重排；","like_count":0},{"had_liked":false,"id":94127,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1435138,"ip_address":"","ucode":"2817C6A41C2E53","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/02/65a764fe.jpg","comment_is_top":false,"comment_ctime":1557726983,"is_pvip":false,"replies":[{"id":"33673","content":"不能保证count+=1的原子性","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557757868,"ip_address":"","comment_id":94127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557726983","product_id":100023901,"comment_content":"老师，本节所说的volatile修饰的变量禁止使用cpu缓存，那么上节课中的示例代码count用 volatile修饰，为什么运行的结果还是不正确?<br>public class Test {<br><br>  private volatile int count = 0;<br><br>  private void add() {<br>    int idx = 0;<br>    while (idx++ &lt; 10000000) {<br>      count += 1;<br>    }<br>  }<br><br>  public static int calc() throws Exception {<br>    final Test test = new Test();<br>    Thread th1 = new Thread(() -&gt; {<br>      test.add();<br>    });<br>    Thread th2 = new Thread(() -&gt; {<br>      test.add();<br>    });<br><br>    th1.start();<br>    th2.start();<br>    th1.join();<br>    th2.join();<br>    return test.count;<br>  }<br><br>  public static void main(String[] args) throws Exception {<br>    long c = calc();<br>    System.out.println(c);<br>  }<br>}","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449925,"discussion_content":"不能保证count+=1的原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557757868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93763,"user_name":"smarttime","can_delete":false,"product_type":"c1","uid":1140144,"ip_address":"","ucode":"460ED32D6165ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/b0/9d11054a.jpg","comment_is_top":false,"comment_ctime":1557583566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557583566","product_id":100023901,"comment_content":"为什么会有问题，能不能再详细分析一下，就算我们的语言随意，请老师能否再自己细致讲解一下，看到那么多理解的不同的留言有些甚至还有矛盾，好揪心","like_count":0},{"had_liked":false,"id":93736,"user_name":"smarttime","can_delete":false,"product_type":"c1","uid":1140144,"ip_address":"","ucode":"460ED32D6165ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/b0/9d11054a.jpg","comment_is_top":false,"comment_ctime":1557575166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557575166","product_id":100023901,"comment_content":"我也想问例子中v不加volatile，读到x是多少？HB规则一到底该咋理解？老师这篇文章我读了5遍，在多线程环境下我还是不清楚该咋理解","like_count":0},{"had_liked":false,"id":90180,"user_name":"啊志聪啊","can_delete":false,"product_type":"c1","uid":1024087,"ip_address":"","ucode":"03E189316AEFF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/57/2cf004c7.jpg","comment_is_top":false,"comment_ctime":1556441737,"is_pvip":false,"replies":[{"id":"32321","content":"我觉得应该是：<br>final修饰这个实例对象，然后修改实例对象的abc属性为其他值,另外的线程就不可见了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556462596,"ip_address":"","comment_id":90180,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556441737","product_id":100023901,"comment_content":"final是不变的,所以用final 修饰abc修改为其他值编译都不通过吧?还是意思abc是某实例的成员变量,final修饰这个实例对象?然后修改实例对象的abc属性为其他值,另外的线程就可见的了?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448416,"discussion_content":"我觉得应该是：\nfinal修饰这个实例对象，然后修改实例对象的abc属性为其他值,另外的线程就不可见了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556462596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89880,"user_name":"次郎","can_delete":false,"product_type":"c1","uid":1134620,"ip_address":"","ucode":"446499E130A66A","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/1c/26dc1927.jpg","comment_is_top":false,"comment_ctime":1556293519,"is_pvip":false,"replies":[{"id":"32300","content":"不用背，用到了查一下就可以了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556427817,"ip_address":"","comment_id":89880,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556293519","product_id":100023901,"comment_content":"老师，happed befor规则必须要记住吗？不好背啊","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448302,"discussion_content":"不用背，用到了查一下就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556427817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87518,"user_name":"盛权_vinc","can_delete":false,"product_type":"c1","uid":1459845,"ip_address":"","ucode":"4688DD06587CE2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LPnuO9GleKEwso2rSbibmbEwn49hnGl9qTQDBv2xLOOWOflQsc9oVEEuZgNBt7TrqRKvk8CX7Tc8iakhEicBCCfFg/132","comment_is_top":false,"comment_ctime":1555631651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555631651","product_id":100023901,"comment_content":"老师，在write和read的例子中，如果boolean v没有用volatile修饰，是不是线程A、B就不会遵循happens-before规则？在write中x=42和v=true的执行顺序就可能会由于编译优化而重排，是这样吗？如果是，那是不是说happens-before规则第一条，顺序执行其实也是由volatile限制？我在网上看到提及volatile的特性都是:1,禁用线程本地缓存，直接在内存中读写;2,禁止指令重排。<br>而happens-before把这两个特性分成两个规则说明，是这么理解吗？","like_count":0},{"had_liked":false,"id":87375,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1555579202,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555579202","product_id":100023901,"comment_content":"留言质量一级棒，参考留言和问题一个规则一个规则对照着看很有感觉：<br>1. 采用volatile变量修饰，根据hb规则2可以知道<br>2. 对abc=3的赋值操作加锁，之后其他线程对abc的访问加锁；根据规则4可以知道<br>3. 将设置abc的值为3的线程作为作为主线程，设置完abc=3之后在里面开启一个子线程B并start, 在子线程B里面访问abc,参考规则5<br>4. 将设置abc的值为3的线程作为子线程A，然后在B中调用A.join(),等join返回后再查看abc的值，参考规则6<br><br>对于3,4如果发生设置值的操作和start&#47;join的操作指令重排，可能不一定能得到我们想要的结果！不知道理解的对不对？","like_count":0},{"had_liked":false,"id":86553,"user_name":"笨蛋","can_delete":false,"product_type":"c1","uid":1223680,"ip_address":"","ucode":"D541550F1E5C2A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epic1fC7nrCEic676PpRnT4RnDjbPhbQzIdCiaSY1IFJubmdNBt6K65FHML9AH8LVBfDAcq1O35HEIkQ/132","comment_is_top":false,"comment_ctime":1555398623,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1555398623","product_id":100023901,"comment_content":"@发条橙子 。有点疑问：第四条规则。synchronized同步的代码块在释放锁的时候不是已经将abc的值更新到主内存中去了吗？其他线程再去获取这个值的时候不是已经是最新值了吗？","like_count":0,"discussions":[{"author":{"id":2131766,"avatar":"","nickname":"Geek9458","note":"","ucode":"EF6E589FB92F0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333942,"discussion_content":"其他线程如果是在同步代码块里获取这个值就是最新的，如果没有用synchronized就不符合第4条规则了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607677234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85808,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1555242696,"is_pvip":false,"replies":[{"id":"30877","content":"1. 是这样，规则1必须和传递性还有其他规则结合，才有作用<br>2. 我说的也是@发条橙子的分析没有问题，按照hb规则，读写必须都用synchronized才能确保没有问题。@发条橙子说的“直接”，我理解就是没有使用任何同步手段。<br><br>“synchronized(abc) 是可以保证后续其他线程的操作能够看到 abc 写操作的结果的。”这个根据hb规则是推断不出来的。所以你看早期Vector的实现，所有读操作也都用synchronized修饰，哪怕是size()就返回一个elementCount。这个和abc的问题是一样一样的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555254852,"ip_address":"","comment_id":85808,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555242696","product_id":100023901,"comment_content":"老师，您好。有两个问题没太理解<br>问题一： <br>“程序的顺序性规则”描述的是单线程内，按照程序的书写顺序，前面操作的结果对后续的任意操作可见。即单线程内，第 6 行代码“x = 42;”Happens-Before 于第 7 行代码 “v = true;”。多线程情况下，有可能发生重排，将“v=true;”排到了“x=42;”之前。我们都是在多线程的情况下讨论可见性问题，因此不太理解这条规则的作用。是配合 volatile 规则来使用的么？例如：<br>```<br>int a;<br>int b;<br>volatile int c;<br>int d;<br>int e;<br>```<br>a 和 b 不会重排到 c 的后面（而 b 有可能重排到 a 的前面），同样 d 和 e 不会重排到 c 的前面。<br><br>问题二：<br>之前在留言里提问：<br>&gt;@发条橙子… 的思考题分析，有些不太准确吧，例如评论里指出的程序顺序性。还有 synchronized 的分析也不太准确吧，synchronized(abc) 可能保证后续操作可见。<br>&gt;<br>&gt;作者回复: synchronized 的分析没有问题，其他线程直接访问还可能不是最新值，我理解直接就是没有使用任何同步手段。<br>&gt;即便用 synchronized，用法不对，也达不到效果。<br><br>上述提问“还有 synchronized 的分析也不太准确吧”，不是对文章中的 synchronized 的分析表示疑惑，而是@发条橙子… 的分析有疑惑：<br>&gt;4. 第四条规则， 使用管程，由于是访问共享变量，如果是在syn中修改值只能保证当前线程下一次进入syn可以看见最新的值，其他线程直接访问还可能不是最新值 ， 不行<br><br>自己的理解是：<br>synchronized(abc) 是可以保证后续其他线程的操作能够看到 abc 写操作的结果的，即可以看到 abc 的最新值。不知道理解是否正确。<br><br>谢谢老师！！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446819,"discussion_content":"1. 是这样，规则1必须和传递性还有其他规则结合，才有作用\n2. 我说的也是@发条橙子的分析没有问题，按照hb规则，读写必须都用synchronized才能确保没有问题。@发条橙子说的“直接”，我理解就是没有使用任何同步手段。\n\n“synchronized(abc) 是可以保证后续其他线程的操作能够看到 abc 写操作的结果的。”这个根据hb规则是推断不出来的。所以你看早期Vector的实现，所有读操作也都用synchronized修饰，哪怕是size()就返回一个elementCount。这个和abc的问题是一样一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555254852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85720,"user_name":"LouisLimTJ","can_delete":false,"product_type":"c1","uid":1149462,"ip_address":"","ucode":"E430BC6BE62C22","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/16/10420350.jpg","comment_is_top":false,"comment_ctime":1555212559,"is_pvip":false,"replies":[{"id":"30836","content":"规则1仅仅对单线程有效。没有全部禁止。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555234865,"ip_address":"","comment_id":85720,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555212559","product_id":100023901,"comment_content":"王老师你好，我有个关于happen before的第一条规则。你说到前面的操作可见于后面的操作。对于，可见于之后的操作，是指对于volatile变量的操作呢， 还是什么变量都是？ 如果是后者，那岂不是意味着Java完全禁止了reorder的编译优化了？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446779,"discussion_content":"规则1仅仅对单线程有效。没有全部禁止。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555234865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85614,"user_name":"玉树临枫","can_delete":false,"product_type":"c1","uid":1442090,"ip_address":"","ucode":"B99151418C64CE","user_header":"","comment_is_top":false,"comment_ctime":1555143306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555143306","product_id":100023901,"comment_content":"掌握Java内存模型很重要，特别是里面的一些关键字和一些规则，需着重理解。下面是我对volatile 关键字的理解和总结，欢迎各位参考<br>https:&#47;&#47;www.cnblogs.com&#47;yuanfy008&#47;p&#47;9335168.html","like_count":0},{"had_liked":false,"id":85458,"user_name":"云外有云","can_delete":false,"product_type":"c1","uid":1442569,"ip_address":"","ucode":"E06ECF692935B8","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/09/74acf5ca.jpg","comment_is_top":false,"comment_ctime":1555064101,"is_pvip":false,"replies":[{"id":"30618","content":"出现死锁的时候，把线程栈dump出来，就能知道原因了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555065358,"ip_address":"","comment_id":85458,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555064101","product_id":100023901,"comment_content":"老师，这段代码出现了死锁，但我还是没整明白，帮忙指点一下，谢谢<br><br>锁都是静态object<br><br> public static T GetClient&lt;T&gt;(int clientTimeout = 3, int retryCount = 1, int retryBreak = 1)         {<br><br>            if (isRunOne)<br>            {<br>                lock (m_initlock)<br>                {<br>                    if (isRunOne)<br>                    {<br>                        MicroClientInit(clientDllPath);<br><br>                        if (!ClientDllPathList.Contains(clientDllPath))<br>                        {<br>                            ClientDllPathList.Add(clientDllPath);<br>                        }<br><br>                        isRunOne = false;<br>                    }<br>                }<br>            }<br><br>            if (!ClientDllPathList.Contains(clientDllPath))<br>            {<br>                lock (m_initlock)<br>                {<br>                    if (!ClientDllPathList.Contains(clientDllPath))<br>                    {<br>                        ConsulHelper.Instance.AppendService(clientDllPath);<br>                        ClientDllPathList.Add(clientDllPath);<br>                    }<br>                }<br>            }<br>}","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446674,"discussion_content":"出现死锁的时候，把线程栈dump出来，就能知道原因了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555065358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85007,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1554954805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554954805","product_id":100023901,"comment_content":"感谢老师的讲解，也感谢首评Handongyang的评论，把java对难懂的happens-before讲的这么透彻！","like_count":0},{"had_liked":false,"id":84720,"user_name":"whyoyyx","can_delete":false,"product_type":"c1","uid":1064449,"ip_address":"","ucode":"B111DDAF23AFE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/01/9bb11f13.jpg","comment_is_top":false,"comment_ctime":1554898302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554898302","product_id":100023901,"comment_content":"@胡桥，我把你的sleep(1) ，改成其他耗时计算就能复现。不过在试验之前先保存好相关文件。","like_count":0},{"had_liked":false,"id":83081,"user_name":"Forever","can_delete":false,"product_type":"c1","uid":1200760,"ip_address":"","ucode":"76BE8C9BFD41B2","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/78/4365471c.jpg","comment_is_top":false,"comment_ctime":1554395487,"is_pvip":false,"replies":[{"id":"30003","content":"可以<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554431076,"ip_address":"","comment_id":83081,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554395487","product_id":100023901,"comment_content":"老师 @Handongyang 说当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。 那么是否可以理解为思考题中的abc如果设置为final修饰，他也可以被其他的线程看到？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445850,"discussion_content":"可以\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554431076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82523,"user_name":"王成","can_delete":false,"product_type":"c1","uid":1441460,"ip_address":"","ucode":"29765BBCD3B8B2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fe/b4/6902ac00.jpg","comment_is_top":false,"comment_ctime":1554248448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554248448","product_id":100023901,"comment_content":"普通读写+普通读写 允许指令重排<br>普通读写+volatile读 允许<br>普通读写+volatile写 不允许<br>volatile读+任何 不允许<br>volatile写+普通读写 允许<br>volatile写+volatile读写 不允许<br>希望大家指导","like_count":0},{"had_liked":false,"id":82343,"user_name":"Aaron_涛","can_delete":false,"product_type":"c1","uid":1180617,"ip_address":"","ucode":"067F3CBB1F036C","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/c9/9a9d82ab.jpg","comment_is_top":false,"comment_ctime":1554187963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554187963","product_id":100023901,"comment_content":"最后那个逸出是不是因为指令重排序导致this赋值操作可能第一个执行，这个时候x还没有赋值，所有可能访问到x=0","like_count":0},{"had_liked":false,"id":82007,"user_name":"虎爷","can_delete":false,"product_type":"c1","uid":1024907,"ip_address":"","ucode":"42E8339F183055","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/8b/e7389cf5.jpg","comment_is_top":false,"comment_ctime":1554101590,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554101590","product_id":100023901,"comment_content":"1：可以在abc这个变量前面，加入volatile修饰符；<br>2：可以在abc=3这个语句后面，执行一个被volatile关键字修饰的变量赋值操作；<br>3：可以在abc=3这行代码前后加入synchronized关键字，保证其可见性；<br>","like_count":0},{"had_liked":false,"id":77618,"user_name":"赌神很低调","can_delete":false,"product_type":"c1","uid":1168545,"ip_address":"","ucode":"1066778E1EDF26","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/a1/8bc8e7e1.jpg","comment_is_top":false,"comment_ctime":1552973919,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1552973919","product_id":100023901,"comment_content":"abc定义为volatil变量，写操作定义在同步块中，读线程join写线程","like_count":0},{"had_liked":false,"id":77539,"user_name":"life is short, enjoy more.","can_delete":false,"product_type":"c1","uid":1074805,"ip_address":"","ucode":"3B5F37D30790A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg","comment_is_top":false,"comment_ctime":1552960448,"is_pvip":false,"replies":[{"id":"28390","content":"我不敢揣测jvm和cpu起如何实现，只要能够用hb推断可见性就够了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552997731,"ip_address":"","comment_id":77539,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552960448","product_id":100023901,"comment_content":"好记性不如烂笔头，我是这么理解这篇文章的<br>有序性的保证，是hb原则约束优化的结果。<br>可见性的保证，是被volatile关键字修饰的变量的读操作，会导致其他cpu cache中的变量失效，需要从内存中重新load的结果。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443768,"discussion_content":"我不敢揣测jvm和cpu起如何实现，只要能够用hb推断可见性就够了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552997731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77534,"user_name":"Felix Envy","can_delete":false,"product_type":"c1","uid":1200085,"ip_address":"","ucode":"24E0F2165AD108","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/d5/e23dc965.jpg","comment_is_top":false,"comment_ctime":1552960237,"is_pvip":false,"replies":[{"id":"28450","content":"还是有问题，加volatile可以解决，详细方法可以搜索网文<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553042821,"ip_address":"","comment_id":77534,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552960237","product_id":100023901,"comment_content":"老师你好，基于happen-before规则，是不是可以理解在jdk1.5之后，双检锁不会再有问题？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443763,"discussion_content":"还是有问题，加volatile可以解决，详细方法可以搜索网文\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553042821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77504,"user_name":"xiyuesmiling","can_delete":false,"product_type":"c1","uid":1221692,"ip_address":"","ucode":"2E5AD30B1470D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/3c/121e7f9f.jpg","comment_is_top":false,"comment_ctime":1552957489,"is_pvip":false,"replies":[{"id":"28292","content":"规则一仅仅适用单线程<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552958669,"ip_address":"","comment_id":77504,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552957489","product_id":100023901,"comment_content":"1.5之后，如果有规则一，为什么还会导致变异优化导致的读取变量x不对呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443751,"discussion_content":"规则一仅仅适用单线程\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552958669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77412,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1552920314,"is_pvip":true,"replies":[{"id":"28334","content":"很全面了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552969485,"ip_address":"","comment_id":77412,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552920314","product_id":100023901,"comment_content":"1、直接使用volatile修饰abc，根据happens-before 对volatile的写happens-before于后续对这个变量的读<br>2、使用volatile修饰控制访问abc的标示，并且在修改abc=3之后将访问标示设置为true，在后续访问abc代码处先判断是否可访问abc，根据happens-before 程序有效性和对volatile语义增强，可保证在访问abc标示为true的时候访问abc一定是3<br>3、对abc=3操作加锁，管程中的锁，解锁happens-before于加锁<br>4、主线程设置abc=3，然后调用子线程的start()方法启动子线程，子线程可见abc=3<br>5、子线程设置abc=3，然后启动子线程，并调用子线程的join方法，子线程abc=3对主线程可见<br>感觉老师这题就是用来回顾本章内容的，不知道是否正确？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443715,"discussion_content":"很全面了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552969485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77238,"user_name":"宝石山","can_delete":false,"product_type":"c1","uid":1295061,"ip_address":"","ucode":"3ADF20E12EBF99","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/d5/126eac1a.jpg","comment_is_top":false,"comment_ctime":1552894695,"is_pvip":false,"replies":[{"id":"28172","content":"不适用，后面介绍并发包的时候会说这个问题<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552908993,"ip_address":"","comment_id":77238,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552894695","product_id":100023901,"comment_content":"老师关于HB的第四条管程中锁的规则，适用于ReentrantLock吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443650,"discussion_content":"不适用，后面介绍并发包的时候会说这个问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552908993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77162,"user_name":"life is short, enjoy more.","can_delete":false,"product_type":"c1","uid":1074805,"ip_address":"","ucode":"3B5F37D30790A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg","comment_is_top":false,"comment_ctime":1552873414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552873414","product_id":100023901,"comment_content":"新学生对本门课程的第一次留言~<br>&#47;&#47; 以下代码来源于【参考 1】<br>final int x;<br>&#47;&#47; 错误的构造函数<br>public FinalFieldExample() { <br>  x = 3;<br>  y = 4;<br>  &#47;&#47; 此处就是讲 this 逸出，<br>  global.obj = this;<br>}<br><br>老师你好，这个例子我不是很理解，看到你给其他同学的答复是，this可能没有初始化完。但是这不就是一个构造函数吗，this位于构造函数的最后一行，而且x已经赋值了，为什么可能存在其他线程读到x==0的情况呢？","like_count":0},{"had_liked":false,"id":75532,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1552410254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552410254","product_id":100023901,"comment_content":"思考题：可以利用各种happens-before 规则；或者间接的使用传递性来保证其他线程可见。","like_count":0},{"had_liked":false,"id":75530,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1552409316,"is_pvip":false,"replies":[{"id":"27633","content":"没那么简单，线程栈里都是不共享的数据，天生就安全，问题出在共享变量上<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552478817,"ip_address":"","comment_id":75530,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552409316","product_id":100023901,"comment_content":"对于规则5，依据我对线程启动的理解，自线程b应该在创建之时 拷贝所以线程a的栈。所以规则5是不是线程创建后自然而然的就满足了这个规则？<br><br>我的理解对吗，还是说有其他的机制来保证？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442929,"discussion_content":"没那么简单，线程栈里都是不共享的数据，天生就安全，问题出在共享变量上\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552478817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75522,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1552408080,"is_pvip":false,"replies":[{"id":"27631","content":"规则1只适用到线程，别考虑缓存以及怎么实现的，先理解需求，才能把代码写好，先读懂规范，再来想实现，两者别搞混了。实现没有咱们想的那么简单<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552478590,"ip_address":"","comment_id":75522,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552408080","product_id":100023901,"comment_content":"王老师，您好。文中提到了规则3是1.5以后对volatile的强化。<br><br>但是根据规则1 x=42的赋值一定发生在v=true赋值之前 和 规则2 线程b的读（后续读）一定发生在线程a对变量v的写之后。 那么自然而然的，x=42的写不就一定发生在线程b读x之前了吗？为什么说规则3是1.5的强化，并且有了规则3，就避免读到x=0呢？或者说，有了1，2不就一定保证了3的发生吗？<br><br>在描述这个问题的过程中，我已经自己想到了答案。记录下来供和我有（if have）同样疑惑的同学，或者以后的自己参考把。<br><br>我的理解是：这里还是需要从内存的可见性来分析。<br>规则1 保证了在线程A的cpu缓存中，x=42一定发生在写入v=true之前。<br>规则2 保证了在线程B在读取v这个变量之前，一定是先确保了其他cpu缓存中的v flush到内存中了，并且把v的值同步到自己的缓存里。也就是如果其他线程在此之前写过变量v，那么此时线程B在读v的时候，一定是能看到之前其他线程写v的结果。<br>规则3 的传递性则保证了，在线程B读v之前，线程A对x的写操作对线程B一定可见。其实就是保证把线程A中cpu缓存的x值同步到线程B的cpu缓存中。<br>结论：只有单核的情况下，1，2才能保证3。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442926,"discussion_content":"规则1只适用到线程，别考虑缓存以及怎么实现的，先理解需求，才能把代码写好，先读懂规范，再来想实现，两者别搞混了。实现没有咱们想的那么简单\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552478590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75244,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1552369578,"is_pvip":false,"replies":[{"id":"27466","content":"没有，哪里说保证这个了？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552393281,"ip_address":"","comment_id":75244,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552369578","product_id":100023901,"comment_content":"老师为什么volatile可以保证对他之后的变量修改操作的可见性？happen-before没有这项规则啊","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442835,"discussion_content":"没有，哪里说保证这个了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552393281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75224,"user_name":"你说的灰","can_delete":false,"product_type":"c1","uid":1158981,"ip_address":"","ucode":"650FA935A7741F","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/45/8bacada2.jpg","comment_is_top":false,"comment_ctime":1552366809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552366809","product_id":100023901,"comment_content":"同问","like_count":0},{"had_liked":false,"id":74970,"user_name":"若尘","can_delete":false,"product_type":"c1","uid":1212972,"ip_address":"","ucode":"8C83E47DB797C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/2c/e8cf7f2f.jpg","comment_is_top":false,"comment_ctime":1552327379,"is_pvip":false,"replies":[{"id":"27345","content":"没写过jvm的编译器和解释器，不敢妄谈，你如果感兴趣可以研读一下jsr133 的后半部分，那个是面向jvm的实现人员的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552350336,"ip_address":"","comment_id":74970,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552327379","product_id":100023901,"comment_content":"既然引出了内存模型及happen before原则，那jdk中又是如何保证这些原则的呢？或者说怎么实现了这些原则？谢谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442762,"discussion_content":"没写过jvm的编译器和解释器，不敢妄谈，你如果感兴趣可以研读一下jsr133 的后半部分，那个是面向jvm的实现人员的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552350336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74347,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1136022,"ip_address":"","ucode":"5808CB57A03148","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/96/5160cd31.jpg","comment_is_top":false,"comment_ctime":1552196686,"is_pvip":false,"replies":[{"id":"27180","content":"规范是一码事，具体实现是一码事。这个我也验证不出来，不过还是按照规范办事好些。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552200986,"ip_address":"","comment_id":74347,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552196686","product_id":100023901,"comment_content":"class VolatileExample 中即使变量v不加volatile，由于X86CPU不支持写写重排序，在x86上面操作，这个一定会是x=42（从别的网页看到的，本人没有验证）","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442543,"discussion_content":"规范是一码事，具体实现是一码事。这个我也验证不出来，不过还是按照规范办事好些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552200986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74344,"user_name":" 臣馟飞扬","can_delete":false,"product_type":"c1","uid":1116188,"ip_address":"","ucode":"F2F882B7678055","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","comment_is_top":false,"comment_ctime":1552195936,"is_pvip":false,"replies":[{"id":"27178","content":"多谢盛赞！！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552200837,"ip_address":"","comment_id":74344,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552195936","product_id":100023901,"comment_content":"王老师讲解的happen-before规则甚好，之前以为A happen-before B就是A发生在B之前，这次有了新的认识。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442541,"discussion_content":"多谢盛赞！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552200837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74112,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1552105997,"is_pvip":false,"replies":[{"id":"27111","content":"我认为，各个线程中不会缓存主内存的副本。除非线程被挂起，才会把寄存器的内容复制到线程上下文里面。<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552114805,"ip_address":"","comment_id":74112,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552105997","product_id":100023901,"comment_content":"我有一个问题,  cpu缓存和各个线程中缓存的主内存的本质复本是不是一回事? ","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442451,"discussion_content":"我认为，各个线程中不会缓存主内存的副本。除非线程被挂起，才会把寄存器的内容复制到线程上下文里面。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552114805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73953,"user_name":"马克","can_delete":false,"product_type":"c1","uid":1106597,"ip_address":"","ucode":"C1D35AB8373444","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/a5/05276fad.jpg","comment_is_top":false,"comment_ctime":1552043268,"is_pvip":false,"replies":[{"id":"26972","content":"操作系统随时都可以切换，不管线程执行到哪里。下一期会讲sync，不会有脏数据的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552046581,"ip_address":"","comment_id":73953,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1552043268","product_id":100023901,"comment_content":"老师，有一点不明白：使用volatile关键字修饰的变量，在执行++操作的时候，有取值，计算，赋值的CPU指令，如果在时间分片到达时才执行了计算，此时会继续执行赋值操作再切换吗？同样的，像这种多CPU指令的操作加上synchronize后，中间指令发生切换时，是不是继续执行同步块内的代码？否则，是否会出现脏数据？<br>谢谢指导","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442357,"discussion_content":"操作系统随时都可以切换，不管线程执行到哪里。下一期会讲sync，不会有脏数据的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552046581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289369,"discussion_content":"赋值操作没有执行，锁是不会释放的，其他线程也是等待锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594082854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73878,"user_name":"Owen","can_delete":false,"product_type":"c1","uid":1209023,"ip_address":"","ucode":"C9A406054F3F9E","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/bf/26519889.jpg","comment_is_top":false,"comment_ctime":1552023433,"is_pvip":false,"replies":[{"id":"27019","content":"这个我真不敢确定。做JVM的人远比我们聪明。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552059875,"ip_address":"","comment_id":73878,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552023433","product_id":100023901,"comment_content":"Thread B = new Thread(()-&gt;{<br>  &#47;&#47; 主线程调用 B.start() 之前<br>  &#47;&#47; 所有对共享变量的修改，此处皆可见<br>  &#47;&#47; 此例中，var==77<br>});<br>&#47;&#47; 此处对共享变量 var 修改<br>var = 77;<br>&#47;&#47; 主线程启动子线程<br>B.start();<br><br>Thread B可以访问var是不是意味着主线程在启动Thread B之前要把主存设置为无效，并把var更新到主存?<br><br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442319,"discussion_content":"这个我真不敢确定。做JVM的人远比我们聪明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552059875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73860,"user_name":"Owen","can_delete":false,"product_type":"c1","uid":1209023,"ip_address":"","ucode":"C9A406054F3F9E","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/bf/26519889.jpg","comment_is_top":false,"comment_ctime":1552018345,"is_pvip":false,"replies":[{"id":"27020","content":"是否刷缓存、以及jvm是如何做到是JVM的开发人员要考虑的。你可以参考一些内存屏障之类的东西，我工作中用不到，所以我也只是道听途说，就不敢误导大家了。我觉得更重要的是能利用这些规则，推演程序的执行过程。<br><br>线程C在进入同步块前，也许能看到10，也许能看到12，这个不确定。所以才需要同步。<br><br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552060685,"ip_address":"","comment_id":73860,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552018345","product_id":100023901,"comment_content":"synchronized (this) { &#47;&#47; 此处自动加锁<br>  &#47;&#47; x 是共享变量, 初始值 =10<br>  if (this.x &lt; 12) {<br>    this.x = 12; <br>  }  <br>} &#47;&#47; 此处自动解锁<br><br>Hi，老师我此处不太明白，<br>1.假设A线程进入同步块，执行了  this.x = 12，当自动解锁的时候会把12刷回主存吗？<br>2.按您文章中的说法，当线程B进入同步块的时候才可以访问到x=12，那jvm是如何做到这一点的，<br>3.那如果有一个线程C在进入同步块前拿到的x=10？还是12<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442308,"discussion_content":"是否刷缓存、以及jvm是如何做到是JVM的开发人员要考虑的。你可以参考一些内存屏障之类的东西，我工作中用不到，所以我也只是道听途说，就不敢误导大家了。我觉得更重要的是能利用这些规则，推演程序的执行过程。\n\n线程C在进入同步块前，也许能看到10，也许能看到12，这个不确定。所以才需要同步。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552060685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73824,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1552010528,"is_pvip":false,"replies":[{"id":"26960","content":"是这样的，linux里的线程就是用进程结构实现的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552019351,"ip_address":"","comment_id":73824,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552010528","product_id":100023901,"comment_content":"查了下,切换时事先开辟好的一块固定空间里，比如Linux的task_struct 来存线程信息","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442296,"discussion_content":"是这样的，linux里的线程就是用进程结构实现的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552019351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73399,"user_name":"punchline","can_delete":false,"product_type":"c1","uid":1314136,"ip_address":"","ucode":"32391B470CCD18","user_header":"https://static001.geekbang.org/account/avatar/00/14/0d/58/008173ad.jpg","comment_is_top":false,"comment_ctime":1551878687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551878687","product_id":100023901,"comment_content":"@狂战俄洛伊 有一点不是很明白 根据happens-before 规则第一条，在一个线程中，会按程序代码顺序 前面的代码块对于后面的代码块可见，那为什么int a =1与int b =2的执行顺序不一定呢？ 既然后面的int b =2 可以看见前面的int a=1 那int a=1 不是应该一直在int b=2的前面执行吗? ","like_count":0},{"had_liked":false,"id":73328,"user_name":"陈华","can_delete":false,"product_type":"c1","uid":1082730,"ip_address":"","ucode":"3AF9E8EB39E507","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtS26SJpSF7JLu9pusGsy1Qln0NdQg1eV2YKOJxpX2QXaBuuyXMqZY3fm0rhzKwsqN5aa6CVNOQQ/132","comment_is_top":false,"comment_ctime":1551861929,"is_pvip":false,"replies":[{"id":"26711","content":"这个只是个例子，实际编译器的优化和cpu执行的优化远不是我们想象的。这个例子只是告诉你编译器重排是不是合法，如果合法那就有可能，实际上可能不会。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551880832,"ip_address":"","comment_id":73328,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551861929","product_id":100023901,"comment_content":"老师有一个疑问:<br>第一个顺序性，第6,7行代码<br>x = 42; <br>v = true;<br>会不会被重新排序为<br>v = true;<br>x = 42；<br>这样A线程 执行完 v=true; 后，cpu切换到线程B，B此时读取的x值为0.<br><br>第6,7有重排序的可能吗，为啥呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442026,"discussion_content":"这个只是个例子，实际编译器的优化和cpu执行的优化远不是我们想象的。这个例子只是告诉你编译器重排是不是合法，如果合法那就有可能，实际上可能不会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551880832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73015,"user_name":"tracer","can_delete":false,"product_type":"c1","uid":1124766,"ip_address":"","ucode":"AE2BC047DB7D7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg","comment_is_top":false,"comment_ctime":1551777642,"is_pvip":false,"replies":[{"id":"26512","content":"我也没测出来。因为这个代码编译器压根就没啥好优化的。这个例子只是用来分析问题的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551797397,"ip_address":"","comment_id":73015,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1551777642","product_id":100023901,"comment_content":"class VolatileExample {<br>  int x = 0;<br>  boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br><br>  public void reader() {<br>    if (v == true) {<br>         System.out.println(x);<br>    }<br>  }<br>}<br><br>老师的例子中我删除了volatile，但是并没有测试出输出v=0的情况，这是怎么一回事呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441877,"discussion_content":"我也没测出来。因为这个代码编译器压根就没啥好优化的。这个例子只是用来分析问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551797397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72621,"user_name":"M老立","can_delete":false,"product_type":"c1","uid":1061389,"ip_address":"","ucode":"751A056A0CBA61","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/0d/6e0a440f.jpg","comment_is_top":false,"comment_ctime":1551679809,"is_pvip":false,"replies":[{"id":"26281","content":"每周二四六","user_name":"编辑回复","user_name_real":"郭蕾","uid":"1000473","ctime":1551679895,"ip_address":"","comment_id":72621,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1551679809","product_id":100023901,"comment_content":"王老师 什么时候上新啊 等不及了 这两天反复看已经有的 每一遍都有收获 ","like_count":0,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441664,"discussion_content":"每周二四六","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551679895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72579,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1125189,"ip_address":"","ucode":"0617032294DC43","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg","comment_is_top":false,"comment_ctime":1551670684,"is_pvip":false,"replies":[{"id":"26359","content":"对于volatile变量规则：从时间上，先写入的数据，后面查，一定能查的到。优于这个词我不太理解，感觉不太对。<br><br>这些规则得组合着看，才有意义。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551711886,"ip_address":"","comment_id":72579,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551670684","product_id":100023901,"comment_content":"1. 对于程序的顺序性规则，针对的一个线程中，前面的操作对后面的操作可见，是不是可以理解为，代码重排之后，在前面执行CPU指令执行的结果对后面的执行结果是可见的。<br>2. 同样是对于顺序性规则，如果参考1中，没有加volatile关键字的话，x 和v的初始化很有可能重排，那么当多个线程访问时，就会出现当读的时候出现x=0的情况。volatile保证了修改变量之前的语句按照书写的顺序执行，不能进行排序。同时，保证了修饰变量的可见性。<br>3 对于volatile变量规则，写操作优于读操作，应该是写操作之后的数据会及时更新到内存，其他线程可见，或者理解为写操作优于后续时间对该变量的执行的写操作和读操作<br>不知道这些理解是否正确，请老师指正","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441645,"discussion_content":"对于volatile变量规则：从时间上，先写入的数据，后面查，一定能查的到。优于这个词我不太理解，感觉不太对。\n\n这些规则得组合着看，才有意义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551711886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72465,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1551635146,"is_pvip":false,"replies":[{"id":"26339","content":"有效。当然有关系。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551708827,"ip_address":"","comment_id":72465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551635146","product_id":100023901,"comment_content":"start原则对于非主线程的两个线程有效么，对同一共享变量的赋值顺序跟线程启动顺序有关系不","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441601,"discussion_content":"有效。当然有关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551708827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72378,"user_name":"哈哈哈","can_delete":false,"product_type":"c1","uid":1248876,"ip_address":"","ucode":"C40ABE7161EFAE","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/6c/1f3b1372.jpg","comment_is_top":false,"comment_ctime":1551602814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551602814","product_id":100023901,"comment_content":"思考题答案，volatile或者final","like_count":0},{"had_liked":false,"id":72339,"user_name":"aksonic","can_delete":false,"product_type":"c1","uid":1003633,"ip_address":"","ucode":"B6F3348F6714DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/71/e8229703.jpg","comment_is_top":false,"comment_ctime":1551590980,"is_pvip":false,"replies":[{"id":"26207","content":"的确是这样啊，多谢指正，回头我让小编改过来。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551602400,"ip_address":"","comment_id":72339,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551590980","product_id":100023901,"comment_content":"Thread B = new Thread(()-&gt;{<br>  &#47;&#47; 主线程调用 A.start() 之前<br>  &#47;&#47; 所有对共享变量的修改，此处皆可见<br>  &#47;&#47; 此例中，var==77<br>});<br>&#47;&#47; 此处对共享变量 var 修改<br>var = 77;<br>&#47;&#47; 主线程启动子线程<br>B.start();<br><br>老师，“主线程调用 A.start() 之前”是否写错了，应该是“主线程调用 B.start() 之前”，因为示例代码里面根本没有A。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441549,"discussion_content":"的确是这样啊，多谢指正，回头我让小编改过来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551602400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72168,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1551530914,"is_pvip":false,"replies":[{"id":"26156","content":"这个数学题就交给你自己验算吧，要结合其他规则验证两个命题是否等价<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551544725,"ip_address":"","comment_id":72168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551530914","product_id":100023901,"comment_content":"这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。<br><br><br>请教老师，如果这个描述反过来，加锁happens-before解锁，这么描述会有什么问题？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441489,"discussion_content":"这个数学题就交给你自己验算吧，要结合其他规则验证两个命题是否等价\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551544725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72127,"user_name":"小","can_delete":false,"product_type":"c1","uid":1014256,"ip_address":"","ucode":"B953F6B8BC5662","user_header":"","comment_is_top":false,"comment_ctime":1551526853,"is_pvip":true,"replies":[{"id":"26191","content":"我也那么痛苦过","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551584341,"ip_address":"","comment_id":72127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551526853","product_id":100023901,"comment_content":"早点看到这样的文章就不用那么痛苦了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441472,"discussion_content":"我也那么痛苦过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551584341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72107,"user_name":"木刻","can_delete":false,"product_type":"c1","uid":1157430,"ip_address":"","ucode":"0A3226FEE3983B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","comment_is_top":false,"comment_ctime":1551520953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551520953","product_id":100023901,"comment_content":"@ Nevermore 理解了下这里就是结合了前三条规则，每一个前面的操作的结果对后续是可见的，因此B线程只要读到了v=true，那么必然已经看到了x=42","like_count":0},{"had_liked":false,"id":72098,"user_name":"MaO","can_delete":false,"product_type":"c1","uid":1083238,"ip_address":"","ucode":"3D839733E87435","user_header":"https://static001.geekbang.org/account/avatar/00/10/87/66/31629628.jpg","comment_is_top":false,"comment_ctime":1551519488,"is_pvip":false,"replies":[{"id":"26112","content":"双重检查创建单例，不加volatile会出问题。<br>happen before 不是发生在之前的意思。 这个和线程调度没关系。操作系统乐意调度谁就调度谁，JVM算老几？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551524137,"ip_address":"","comment_id":72098,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551519488","product_id":100023901,"comment_content":"感觉最关键得一点没有解释啊<br><br>violatile 变量写happen before 读，在什么情况下发生?应该是某种并发场景但是有确实有顺序的时候吧，补充下吧？<br>否则会感觉是人为对线程的操控导致的。<br>可能涉及到vm线程调度，希望能讲下不加violatile会出问题的场景","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441460,"discussion_content":"双重检查创建单例，不加volatile会出问题。\nhappen before 不是发生在之前的意思。 这个和线程调度没关系。操作系统乐意调度谁就调度谁，JVM算老几？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551524137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72003,"user_name":"长眉_张永","can_delete":false,"product_type":"c1","uid":1442279,"ip_address":"","ucode":"B3DCA68BDD473E","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/e7/091804b7.jpg","comment_is_top":false,"comment_ctime":1551497457,"is_pvip":false,"replies":[{"id":"26099","content":"话说，第二种，我是没看明白，你自己明白就好","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551522036,"ip_address":"","comment_id":72003,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551497457","product_id":100023901,"comment_content":"volatile关键字，每次都读写入内存。<br>另一种就是happens -before原则，让=3的操作先执行","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441423,"discussion_content":"话说，第二种，我是没看明白，你自己明白就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551522036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71969,"user_name":"Four","can_delete":false,"product_type":"c1","uid":1120854,"ip_address":"","ucode":"9BD8F103B4AFB5","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/56/2f1a8301.jpg","comment_is_top":false,"comment_ctime":1551493035,"is_pvip":false,"replies":[{"id":"26093","content":"单独靠CAS无锁算法，应该搞不定可见性。加上volatile关键字就可以了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551521328,"ip_address":"","comment_id":71969,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551493035","product_id":100023901,"comment_content":"1、共享变量abc使用volatile关键字修饰，volatile关键字可以保证可见性。(但是不能保证原子性)<br><br>2、使用锁，synchronize、ReentrantLock...反正有&quot;互斥&quot;语意就行，锁能够保证操作的原子性<br><br>3、使用CAS无锁算法<br><br>4、Thread#join()","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441413,"discussion_content":"单独靠CAS无锁算法，应该搞不定可见性。加上volatile关键字就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551521328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71951,"user_name":"飞落冰雪","can_delete":false,"product_type":"c1","uid":1053101,"ip_address":"","ucode":"D7D38A2B09FBC3","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/ad/a1c55d98.jpg","comment_is_top":false,"comment_ctime":1551491624,"is_pvip":false,"replies":[{"id":"26091","content":"没写的那俩规则，就参考《Java并发编程实战》的第16章吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551520664,"ip_address":"","comment_id":71951,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1551491624","product_id":100023901,"comment_content":"@senekis 还有一个start规则你没说到","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441410,"discussion_content":"没写的那俩规则，就参考《Java并发编程实战》的第16章吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551520664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105246,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/5e/ddbdde5a.jpg","nickname":"邢宇超","note":"","ucode":"3113F55E60ADE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1353,"discussion_content":"我咋看到文章里有start规则呢  老师你是不是又补充了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562572582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71920,"user_name":"何方妖孽","can_delete":false,"product_type":"c1","uid":1445608,"ip_address":"","ucode":"98B74EE791206B","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/e8/5d2c3e08.jpg","comment_is_top":false,"comment_ctime":1551486493,"is_pvip":false,"replies":[{"id":"26085","content":"Java8里的Lambda表达式","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551519924,"ip_address":"","comment_id":71920,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551486493","product_id":100023901,"comment_content":"thread的构造函数里是一个箭头函数，这是什么语法？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441394,"discussion_content":"Java8里的Lambda表达式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551519924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}