{"id":627635,"title":"25｜泛化的实现（上）：怎样为泛化设计数据库？","content":"<p>你好，我是钟敬。</p><p>前面几节课，我们学习了泛化的建模，今天开始我们继续学习泛化的实现。这节课我们先探讨怎样为泛化进行数据库设计，下节课再讨论怎样为泛化编写代码。</p><p>回忆一下<a href=\"https://time.geekbang.org/column/article/615573\">第 8 节课</a>讲过的数据库设计方法，如果只有实体和关联，那么数据库的设计还是比较直白的。但是泛化就会有些难度了。这是因为，同样的泛化模型，可以有不同的数据库设计方式，需要我们根据情况进行权衡。</p><p>这里又包含两个维度的变化，一个是怎样设计表，一个是怎样确定主键。</p><h2>设计表的策略</h2><p>我们先来讨论设计表的方法。为了说明问题，我们结合一个商家向不同客户售卖商品的例子来讲。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/07/14fa142ba1152a7757345e8813f48507.jpg?wh=3733x2260\" alt=\"\"></p><p>这个领域模型，说的是一个商家可以把商品卖给个人或者企业。也就是说，<strong>个人客户</strong>和<strong>企业客户</strong>都是<strong>客户</strong>。所以可以抽取出泛化关系。<strong>客户</strong>实体里的<strong>送货地址</strong>属性，以及客户和订单之间的一对多关联，都体现了个人客户和企业客户的共性。而个人客户里的姓名、企业客户里的税务号等属性，体现了个人客户和企业客户的区别。</p><p>为泛化体系设计表，有 3 种基本策略。</p><ul>\n<li>每个类一个表。</li>\n<li>每个<strong>子类</strong>一个表。</li>\n<li><strong>整个</strong>泛化体系一个表。</li>\n</ul><p>这三条策略读起来可能有些拗口，没关系，我们一个一个解释。</p><h3>每个类一个表</h3><p>第一种策略是“每个类一个表”，也就是说不管父类还是子类，都各建一个表。对于上面这个关于客户的例子，实际上就要建 3 个表。就是下面这个图的样子。<br>\n<img src=\"https://static001.geekbang.org/resource/image/5a/6c/5a92b8e271d5d63146571a2d9a54926c.jpg?wh=3733x2260\" alt=\"\"></p><!-- [[[read_end]]] --><p>在这个表结构里，表示父类的 client（客户）表中存放公共的属性。从 addr_contry（地址里的国家） 一直到 addr_detail（地址详细描述）5 个字段表示地址，这就是个人客户和公司客户公共的属性。而且，这里是用嵌入式的方式存储的。另外，还有一个 client_type（客户类型）属性，用于区分是个人还是团体客户，主要是为了实现一些逻辑时更加方便。</p><p>两个子类对应的表，各自存放自己的属性。注意，个人客户和团体客户表里都有 name 属性，但一个是个人的姓名，一个是公司名称，所以它们的英文虽然碰巧一样，实际上<strong>不是同一种属性</strong>。</p><p>当新建一个个人客户的时候，会在 client 表和 presonal_client 表里各插一条记录；类似地，当新建一个公司客户的时候，会在 client 表和 corporate_client 表里各插一条记录。从而，父表的记录数量，就是两个子表记录数量的总和。而子表里的每条记录，在父表里都能找到对应的记录。</p><p>最后，对于个人客户表，假设业务需求是必须填写姓名和身份证号，那么我们就可以在name 和 id_num 两个字段加上非空（NOT NULL）约束。企业客户表里的非空约束是同样的道理 。</p><h3>每个子类一个表</h3><p>第二种建表策略，是“每个子类一个表”，也就是说，只为子类建表，父类不单独建表，而是把公共属性分别放在子类。</p><p>对于上面的例子，可以像后面这样建立两个表。<br>\n<img src=\"https://static001.geekbang.org/resource/image/0f/9c/0f9a4239b8da35184c1e5eb55633549c.jpg?wh=3733x2260\" alt=\"\"></p><p>可以看到，在这种方案里，公共属性，也就是有关地址的属性，分别放在两个表里了。因此不再需要单独为父类建表，原来父表中的 client_type（客户类型） 也不需要了。</p><h3>整个泛化体系一个表</h3><p>第三种，是整个泛化体系一个表。在这种方式下，我们只建立一个表，把 3 个类的属性都放到这个表里。<br>\n<img src=\"https://static001.geekbang.org/resource/image/1e/d6/1edfc9cdf84dfb80c08c0aec6cd90ed6.jpg?wh=3733x2260\" alt=\"\"></p><p>我们看到，这个表里包括公共属性，也就是地址相关的属性；个人客户独有的属性，也就是姓名和身份证号，以及企业客户独有的属性，包括企业名称和税务号。由于个人客户姓名和企业客户名称都在同一个表里，所以不能都命名为“name”了，要用 personal_name 和 corporate_name 区分开。另外，client_type（客户类型）也是需要的。</p><p>当 client_type 为 “P”，也就是当前数据是个人客户的时候，企业客户独有的字段都为空。当client_type 为 “C”，也就是企业客户的时候，个人客户独有的字段就为空。</p><p>在前两种方式中，我们可以分别对个人和企业客户的必填属性进行非空约束，而现在这种策略就不能进行非空约束了。</p><h3>建表策略的权衡</h3><p>既然有这 3  种设计表的策略，我们在实践中应该怎么选择呢？这需要考虑若干个维度，没有唯一的答案。</p><p>首先，我们可以从<strong>空间效率</strong>的角度考虑。如果两个子类的属性种类差别很大，比如说，子类A有10个不同的属性，子类B有20个不同的属性，而公共的属性只有一两个。</p><p>这种情况下，如果采用“整个泛化体系一个表”的策略，表里就会有大量空字段，空间的浪费就会比较大，对索引性能也有不良影响。反之，如果子类大部分属性都相同，只有一两个属性不同，那么建一个表可能就是比较好的选择。</p><p>其次，从<strong>时间效率</strong>的角度考虑。比如说，如果要查父类下的所有记录，那么“整个泛化体系一个表”的策略不需要连表查询，而且只需要查一次，从这一点来说，性能是最高的。而“每个子类一个表”，也就是两个表的策略，就至少要查两次。</p><p>对于“每个类一个表”，也就是三个表的策略，有时候只查父表就够了，这时性能不比一个表的策略差。但如果需要查出父表和子表两者的属性，就需要连表查询了。到底哪种策略的查询性能高，取决于具体的查询需求。</p><p>然后，还可以从<strong>系统的可维护性角度</strong>考虑。</p><p>如果采用一个表的策略，一旦控制得不严，难免有人会误用字段。比如说本来应该是子类 A 的属性，但是却“借用”了子类 B 的字段，反正子类 B 的字段也是空的。虽然暂时可以实现正确的功能，但时间久了，必然造成理解上的混乱，使系统腐化，难以维护。</p><p>不过，如果本来父类和子类加起来字段就不多，意义非常明确，不容易混淆的话，那么这种做法也可以接受。</p><p>最后，我们前面还说过，“一个表”的策略，无法进行必要的非空约束，也算是这种策略的一个不足之处。</p><p>我画了一张表，帮你总结了三种策略的优缺点。</p><p><img src=\"https://static001.geekbang.org/resource/image/78/d8/78920710069919yy8945cbaea2yy7cd8.jpg?wh=3600x1805\" alt=\"\"></p><p>总之，对建表策略的选择，需要综合考虑几方面的因素做出权衡，这正是对泛化建表的微妙之处。</p><h2>设计主键的策略</h2><p>说完 3 种建表策略，我们再讨论一下设计主键的策略。共有两种选择：“共享主键”和“不共享主键”。</p><h3>共享主键策略</h3><p>什么是共享主键策略呢？我们再回顾一下前面说的“每个类一个表”的数据库设计。</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/e7/a9a71e60cf1e81df86eeed35853939e7.jpg?wh=3733x2260\" alt=\"\"></p><p>可以看到，子表和父表之间有逻辑上的外键关系。个人客户表和企业客户表的主键，同时也充当指向父表的外键。也就是说，子表和父表，共用了同一套主键。我们把这种策略叫做“共享主键”。</p><p>对于“整个泛化体系一个表”的情况，显然也是共享主键的。至于“每个子类一个表”的情况，虽然是分开的 2 个表，我们也可以让这两个表在逻辑上共享同一套主键。</p><h3>不共享主键策略</h3><p>那么，假如“每个类一个表”的数据库设计采用“不共享主键”的策略，就会是后面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/d6/e414ff486a90590yy53280716b3e29d6.jpg?wh=3733x2260\" alt=\"\"></p><p>个人客户表和公司客户表自己有各自的主键，另外还有一个 client_id。这个 client_id 才是对应于父表中主键的外键。这时候，在子表里面，主键和外键是两个不同的字段，所以我们把这种策略称作“不共享主键”。</p><p>就目前的例子来说，共享主键是一个自然的选择。尽管从技术的角度来说可以不共享主键，但是似乎看不到不共享主键的必要性。不要急，让我们回到工时项的案例，马上就可以看到这种场景的例子了。</p><h2>工时项案例的数据库设计</h2><p>下面我们就运用前面学到的知识，看看在工时项的例子里应该怎么设计数据库。</p><p>我们先回顾一下领域模型图。</p><p><img src=\"https://static001.geekbang.org/resource/image/0c/5d/0cfc224a12ea3cac824e51bf8f67345d.jpg?wh=3733x2260\" alt=\"\"></p><p>我们先思考一下到底应该采用哪种建表策略。</p><p>首先，项目、子项目、普通工时项这几个实体，各自有不同的关注点，而且还处在不同的模块。混在一个表，显然是不合理的，所以“整个泛化体系一个表”的策略显然是不合理的。</p><p>然后，再考虑一下是否要采用“每个类一个表”的策略。关键是要不要为<strong>工时项</strong>这个父类单独建一个表，我们一起分析一下。</p><p>假如为父类建表的话，共享的属性只有“工时项ID”和“工时项名称”两个。而项目、子项目等，自身有名称，重用这些名称就可以了，所以，共享的属性就只剩下“工时项ID”了。</p><p>为这样一个属性建表，最可能的作用就是提高某些场合的查询性能。根据我们的需求，最重要的查询就是在报工时的时候，要给员工列出那些可以报工时的项目。</p><p>而这个功能需要 3 个 SQL 查询。第一个是对<strong>项目</strong>和<strong>项目成员</strong>表进行一个连表查询，找到分配给这个成员的项目；第二个是再查<strong>项目</strong>表，找到不需要分配成员的那些项目；第三个是查“普通工时项”里的所有记录。然后把这三个查询的结果拼起来。对于这样的查询，建立<strong>工时项</strong>这个父类的表，其实是没有帮助的。所以，不需要为父类建表。</p><p>顺便说一下，这种查询方法虽然是一个可行的方案，但未必是最优的。等到第三个迭代，讲到限界上下文和 CQRS 的时候，我们还会进一步优化。</p><p>最终的结论就是，采用每个子类一个表的策略。表结构是下面这样。<br>\n<img src=\"https://static001.geekbang.org/resource/image/b4/59/b40f00469d38cc0c4c859ed569ef1d59.jpg?wh=3427x2260\" alt=\"\"></p><p>我们只列出几个关键的表。</p><p>可以看到，在<strong>项目</strong>（project）、<strong>子项目</strong>（sub_project）和<strong>普通工时项</strong>（common_effort_item）里都有一个<strong>工时项 ID</strong>（effor_item_id）。想象一下，假如我们为<strong>工时项</strong>这个父类建了一个表的话，那么<strong>工时项 ID</strong>就是这个表的主键，而在几个子表里是外键。</p><p>但由于现在我们决定不建<strong>工时项</strong>表，所以从技术的角度看，<strong>工时项 ID</strong> 并不是某个表的主键。但从逻辑上，我们仍然应该认为<strong>工时项 ID</strong> 其实就是<strong>工时项</strong>这个泛化体系的主键。虽然它们在三个不同的表里，但应该用同一套主键生成机制来生成，这样才能保证在三个表之间，<strong>工时项 ID</strong> 都是不重复的。</p><p>再看一下<strong>工时项记录</strong>（effort_record）表。回忆一下，在第一个迭代，这个表里有一个<strong>项目 ID</strong>（project_id），作为虚拟外键，指向<strong>项目</strong>表。</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/78/1bea3bdf121e9b7e99066ffd03192f78.jpg?wh=3500x2293\" alt=\"\"></p><p>现在，我们把<strong>项目 ID</strong> 替换成了<strong>工时项 ID</strong>，以便指向逻辑上的各个工时项。由于这些工时项可能是项目、子项目或普通工时项，为了某些功能下查询的方便，我们用<strong>工时项记录</strong>表里的 source 字段表示工时项的来源，以便区分这三种情况。</p><p>建立好表以后，我们再考虑一下主键策略。由于<strong>项目</strong>、<strong>子项目</strong>、<strong>普通工时</strong>项是三个性质不同的实体，所以有各自的主键。而为了表达泛化体系，又增加了<strong>工时项 ID</strong>，作为泛化体系在逻辑上的主键。这其实就是“不共享主键”的策略了。你可以和前面“共享主键”的策略再比较一下，体会一下两者的不同使用场景。</p><h2>总结</h2><p>好，这节课的主要内容就讲到这，我们来总结一下。</p><p>今天，我们学习了怎样为泛化关系进行数据库设计。主要考虑两个问题：一个是建几张表；另一个是怎样确定主键。</p><p>对于建表来说，有 3 种基本策略：每个类一个表、每个子类一个表、以及整个泛化体系一个表。具体的选择，要根据空间效率、时间效率、可维护性、非空约束等不同的因素综合考虑，做出权衡。假如你实在举棋不定的话，那么可以先用“每个类一个表”的策略。</p><p>设计主键有两种策略：共享主键和不共享主键。如果父类和各个子类在业务概念上，本质上就是一类事物，只是在某些方面有所差别，那么共享主键是比较合理的。反之，如果在业务概念上不是同一类事物，只是由于某些个别方面有共性才造成的泛化关系，那么不共享主键比较合理。</p><p>说到这里，我们可以再想一想。或许和今天这样类似的数据库设计，你之前也能做出来。但是，DDD 方法的特点在于，我们是从领域知识的梳理、到利用领域建模对泛化进行识别、然后再权衡不同的建表策略，这样一步一步地推导出设计结果，而不是仅凭直觉和经验。这样的设计，不仅更有说服力，而且反映了业务的本质，因此设计的可扩展性和可维护性也会更好。</p><h2>思考题</h2><p>下面给你留了两道思考题。</p><p>1.今天我们讨论的时候提到，在报工时的时候，查询一个员工可以对哪些项目报工时的逻辑不是最优的。如果换做你来设计，会怎么做呢？</p><p>2.关于泛化表的设计，我们用客户这个“一父两子”的例子，说了 3 种建表策略。如果一父多子，或者不止两层泛化，那么还可以有什么变化呢？</p><p>好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们讨论泛化的代码实现，敬请期待。</p>","comments":[{"had_liked":false,"id":368248,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"陕西","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1676041991,"is_pvip":false,"replies":[{"id":135174,"content":"假如我们认为个人客户和团队客户都是客户，是同一类东西，那么同一类东西用同一套ID，在逻辑上是合理的。另一方面，其他实体引用客户的时候，可以用统一的ID来引用。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678974975,"ip_address":"广东","comment_id":368248,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"我明白泛化建表的三种策略的考量，但是不太明白“共享主键”在设计里起到的作用，或者说为什么还要考虑共享主键这件事情？老师能不能再展开说说？","like_count":5,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609432,"discussion_content":"假如我们认为个人客户和团队客户都是客户，是同一类东西，那么同一类东西用同一套ID，在逻辑上是合理的。另一方面，其他实体引用客户的时候，可以用统一的ID来引用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1678974975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078251,"avatar":"https://static001.geekbang.org/account/avatar/00/10/73/eb/a3bdb006.jpg","nickname":"Fukans","note":"","ucode":"D0F83FBD64BC18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653016,"discussion_content":"主要是用着比较方便，用户不必考虑分类的细节，用一套ID请求即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730082877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375283,"user_name":"KelperOvO","can_delete":false,"product_type":"c1","uid":1366625,"ip_address":"北京","ucode":"DF8917EB2ED496","user_header":"https://static001.geekbang.org/account/avatar/00/14/da/61/2290be43.jpg","comment_is_top":false,"comment_ctime":1685242005,"is_pvip":false,"replies":[{"id":137138,"content":"这取决于我们是否将项目看作一种工时项","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1685968835,"ip_address":"广东","comment_id":375283,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"我感觉建出来出来的模型是有问题，项目和子项目不应该有工时项id，工时项id不是项目的信息","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620236,"discussion_content":"这取决于我们是否将项目看作一种工时项","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685968835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028951,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/97/9a7ee7b3.jpg","nickname":"Geek4329","note":"","ucode":"D6FB8D1B2D5DAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652520,"discussion_content":"同感，这里项目和子项目有工时项id看着很奇怪\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1729079446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367897,"user_name":"子衿","can_delete":false,"product_type":"c1","uid":1903229,"ip_address":"浙江","ucode":"E76CC673517290","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0a/7d/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1675732118,"is_pvip":false,"replies":[{"id":133996,"content":"嗯，不错","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675831035,"ip_address":"广东","comment_id":367897,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1. 可以考虑新增一个表表示所有员工都可以填报的工事项有哪些，当新增不需要分配员工的项目，或普通工时项时，都冗余插入该表一份，这样原来查询3次就优化为查询两次，本质还是CQRS，从查询角度考虑如何设计，但导致写加重，读减轻\n2. 感觉本质考虑的还是一样的，多个表更灵活更贴合领域模型，但需要关联的场景就会性能下降","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602646,"discussion_content":"嗯，不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675831035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395585,"user_name":"麦耀锋","can_delete":false,"product_type":"c1","uid":1401327,"ip_address":"广东","ucode":"077DA831185C01","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/ef/ac5e914d.jpg","comment_is_top":false,"comment_ctime":1731318032,"is_pvip":false,"replies":[{"id":143628,"content":"说两种name不是同一种属性 ，更深层的原因在于，两者的校验规则不同。如果考虑面向对象编程，两个name 的数据类型就不是“String”了，而是PeronalName 和 CorporateName ，这是两个不同的类，其中用于校验自身的代码不一样。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731397043,"ip_address":"广东","comment_id":395585,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"在“每个类一个表”的例子里，在personal_client和corporate_client表都分别有name字段，理由是client表中如果放name，不能区分是个人姓名还是公司名称。对于此，我有不同的看法。首先，如果从业务角度（一般来看），应该能够有一个比较好的共识，就是对于name，如果用于个人，那么就是姓名，如果用于公司，那么就是公司名称，我觉得这是大部分业务逻辑都能接受的“共识”；其次，如果这种区分是必要的，那么对于“地址”呢，是否也得分“个人家庭住址”和“公司办公地址”？ 这样拆分的话，其实更加重了对模型的理解负担（对于本质上大家都认同的共识做不必要的拆分）从而造成不必要的复杂性。 即使到了实现阶段，假如采用继承，一般而言这个name也会放在基类。","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653681,"discussion_content":"说两种name不是同一种属性 ，更深层的原因在于，两者的校验规则不同。如果考虑面向对象编程，两个name 的数据类型就不是“String”了，而是PeronalName 和 CorporateName ，这是两个不同的类，其中用于校验自身的代码不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731397043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390000,"user_name":"Geek_682837","can_delete":false,"product_type":"c1","uid":1715823,"ip_address":"广东","ucode":"55C29E9EDD9265","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaxhA2xdIRKQ0rXZhrjcWPYp4hR1mjST6lcBeuYTg0Omf0hyREfr8VH8JWXEyEVq82ht7wdzWsyA/132","comment_is_top":false,"comment_ctime":1714053486,"is_pvip":false,"replies":[{"id":143676,"content":"这样也可以，不过不太明确。例如，有了这个键，可以非常明确地看出“项目”“是一种”工时项，否则，这个概念就是隐含的。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731548900,"ip_address":"广东","comment_id":390000,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"在不共享主键的方案中，不一定需要逻辑主键吧，工时项可以用关联表的主键加source作为关联外键，这样也不会重复","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653898,"discussion_content":"这样也可以，不过不太明确。例如，有了这个键，可以非常明确地看出“项目”“是一种”工时项，否则，这个概念就是隐含的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731548901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389375,"user_name":"掂过碌蔗","can_delete":false,"product_type":"c1","uid":2275516,"ip_address":"广东","ucode":"6D9080A2B225AE","user_header":"https://static001.geekbang.org/account/avatar/00/22/b8/bc/5f4c9cb2.jpg","comment_is_top":false,"comment_ctime":1712317304,"is_pvip":false,"replies":[{"id":143683,"content":"考虑一下“工时记录”本身如何参照回项目、自项目和普通工时项？","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731560969,"ip_address":"广东","comment_id":389375,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"工时项id，主要还是看有没有使用全局所有类型工时项的需求吧。比方说，根据工时项id对某个工时项进行一些操作。\n如果所有操作都是基于项目、子项目、普通工时项单一维度进行操作的，工时项id就看上去没什么必要了。","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653908,"discussion_content":"考虑一下“工时记录”本身如何参照回项目、自项目和普通工时项？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731560969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368939,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"北京","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1676940064,"is_pvip":false,"replies":[{"id":134560,"content":"可以随时review前文～","user_name":"编辑回复","user_name_real":"编辑","uid":1501385,"ctime":1677323351,"ip_address":"北京","comment_id":368939,"utype":2}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"学着学着，逐渐吃力起来，前面的好多业务知识都忘了","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606717,"discussion_content":"可以随时review前文～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677323351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]}]}