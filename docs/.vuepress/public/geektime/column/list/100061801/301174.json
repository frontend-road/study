{"id":301174,"title":"09 | map：如何实现线程安全的map类型？","content":"<p>你好，我是鸟窝。</p><p>哈希表（Hash Table）这个数据结构，我们已经非常熟悉了。它实现的就是key-value之间的映射关系，主要提供的方法包括Add、Lookup、Delete等。因为这种数据结构是一个基础的数据结构，每个key都会有一个唯一的索引值，通过索引可以很快地找到对应的值，所以使用哈希表进行数据的插入和读取都是很快的。Go语言本身就内建了这样一个数据结构，也就是<strong>map数据类型</strong>。</p><p>今天呢，我们就先来学习Go语言内建的这个map类型，了解它的基本使用方法和使用陷阱，然后再学习如何实现线程安全的map类型，最后我还会给你介绍Go标准库中线程安全的sync.Map类型。学完了这节课，你可以学会几种可以并发访问的map类型。</p><h2>map的基本使用方法</h2><p>Go内建的map类型如下：</p><pre><code>map[K]V\n</code></pre><p>其中，<strong>key类型的K必须是可比较的</strong>（comparable），也就是可以通过 == 和 !=操作符进行比较；value的值和类型无所谓，可以是任意的类型，或者为nil。</p><p>在Go语言中，bool、整数、浮点数、复数、字符串、指针、Channel、接口都是可比较的，包含可比较元素的struct和数组，这俩也是可比较的，而slice、map、函数值都是不可比较的。</p><!-- [[[read_end]]] --><p>那么，上面这些可比较的数据类型都可以作为map的key吗？显然不是。通常情况下，我们会选择内建的基本类型，比如整数、字符串做key的类型，因为这样最方便。</p><p>这里有一点需要注意，如果使用struct类型做key其实是有坑的，因为如果struct的某个字段值修改了，查询map时无法获取它add进去的值，如下面的例子：</p><pre><code>type mapKey struct {\n    key int\n}\n\nfunc main() {\n    var m = make(map[mapKey]string)\n    var key = mapKey{10}\n\n\n    m[key] = &quot;hello&quot;\n    fmt.Printf(&quot;m[key]=%s\\n&quot;, m[key])\n\n\n    // 修改key的字段的值后再次查询map，无法获取刚才add进去的值\n    key.key = 100\n    fmt.Printf(&quot;再次查询m[key]=%s\\n&quot;, m[key])\n}\n</code></pre><p>那该怎么办呢？如果要使用struct作为key，我们要保证struct对象在逻辑上是不可变的，这样才会保证map的逻辑没有问题。</p><p>以上就是选取key类型的注意点了。接下来，我们看一下使用map[key]函数时需要注意的一个知识点。<strong>在Go中，map[key]函数返回结果可以是一个值，也可以是两个值</strong>，这是容易让人迷惑的地方。原因在于，如果获取一个不存在的key对应的值时，会返回零值。为了区分真正的零值和key不存在这两种情况，可以根据第二个返回值来区分，如下面的代码的第6行、第7行：</p><pre><code>func main() {\n    var m = make(map[string]int)\n    m[&quot;a&quot;] = 0\n    fmt.Printf(&quot;a=%d; b=%d\\n&quot;, m[&quot;a&quot;], m[&quot;b&quot;])\n\n    av, aexisted := m[&quot;a&quot;]\n    bv, bexisted := m[&quot;b&quot;]\n    fmt.Printf(&quot;a=%d, existed: %t; b=%d, existed: %t\\n&quot;, av, aexisted, bv, bexisted)\n}\n</code></pre><p>map是无序的，所以当遍历一个map对象的时候，迭代的元素的顺序是不确定的，无法保证两次遍历的顺序是一样的，也不能保证和插入的顺序一致。那怎么办呢？如果我们想要按照key的顺序获取map的值，需要先取出所有的key进行排序，然后按照这个排序的key依次获取对应的值。而如果我们想要保证元素有序，比如按照元素插入的顺序进行遍历，可以使用辅助的数据结构，比如<a href=\"https://github.com/elliotchance/orderedmap\">orderedmap</a>，来记录插入顺序。</p><p>好了，总结下关于map我们需要掌握的内容：map的类型是map[key]，key类型的K必须是可比较的，通常情况下，我们会选择内建的基本类型，比如整数、字符串做key的类型。如果要使用struct作为key，我们要保证struct对象在逻辑上是不可变的。在Go中，map[key]函数返回结果可以是一个值，也可以是两个值。map是无序的，如果我们想要保证遍历map时元素有序，可以使用辅助的数据结构，比如<a href=\"https://github.com/elliotchance/orderedmap\">orderedmap</a>。</p><h2>使用map的2种常见错误</h2><p>那接下来，我们来看使用map最常犯的两个错误，就是<strong>未初始化</strong>和<strong>并发读写</strong>。</p><h3>常见错误一：未初始化</h3><p>和slice或者Mutex、RWmutex等struct类型不同，map对象必须在使用之前初始化。如果不初始化就直接赋值的话，会出现panic异常，比如下面的例子，m实例还没有初始化就直接进行操作会导致panic（第3行）:</p><pre><code>func main() {\n    var m map[int]int\n    m[100] = 100\n}\n</code></pre><p>解决办法就是在第2行初始化这个实例（m := make(map[int]int)）。</p><p>从一个nil的map对象中获取值不会panic，而是会得到零值，所以下面的代码不会报错:</p><pre><code>func main() {\n    var m map[int]int\n    fmt.Println(m[100])\n}\n</code></pre><p>这个例子很简单，我们可以意识到map的初始化问题。但有时候map作为一个struct字段的时候，就很容易忘记初始化了。</p><pre><code>type Counter struct {\n    Website      string\n    Start        time.Time\n    PageCounters map[string]int\n}\n\nfunc main() {\n    var c Counter\n    c.Website = &quot;baidu.com&quot;\n\n\n    c.PageCounters[&quot;/&quot;]++\n}\n</code></pre><p>所以，关于初始化这一点，我再强调一下，目前还没有工具可以检查，我们只能记住“<strong>别忘记初始化</strong>”这一条规则。</p><h3>常见错误二：并发读写</h3><p>对于map类型，另一个很容易犯的错误就是并发访问问题。这个易错点，相当令人讨厌，如果没有注意到并发问题，程序在运行的时候就有可能出现并发读写导致的panic。</p><p>Go内建的map对象不是线程（goroutine）安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。</p><p>我们一起看一个并发访问map实例导致panic的例子：</p><pre><code>func main() {\n    var m = make(map[int]int,10) // 初始化一个map\n    go func() {\n        for {\n            m[1] = 1 //设置key\n        }\n    }()\n\n    go func() {\n        for {\n            _ = m[2] //访问这个map\n        }\n    }()\n    select {}\n}\n</code></pre><p>虽然这段代码看起来是读写goroutine各自操作不同的元素，貌似map也没有扩容的问题，但是运行时检测到同时对map对象有并发访问，就会直接panic。panic信息会告诉我们代码中哪一行有读写问题，根据这个错误信息你就能快速定位出来是哪一个map对象在哪里出的问题了。</p><p><img src=\"https://static001.geekbang.org/resource/image/82/62/82fb958bb73128cf8afc438de4acc862.png?wh=983*441\" alt=\"\"></p><p>这个错误非常常见，是几乎每个人都会踩到的坑。其实，不只是我们写代码时容易犯这个错，一些知名的项目中也是屡次出现这个问题，比如Docker issue 40772，在删除map对象的元素时忘记了加锁：</p><p><img src=\"https://static001.geekbang.org/resource/image/60/ce/60642481f9707520045991030d0f00ce.png?wh=898*268\" alt=\"\"></p><p>Docker issue 40772，Docker issue 35588、34540、39643等等，也都有并发读写map的问题。</p><p>除了Docker中，Kubernetes的issue 84431、72464、68647、64484、48045、45593、37560等，以及TiDB的issue 14960和17494等，也出现了这个错误。</p><p>这么多人都会踩的坑，有啥解决方案吗？肯定有，那接下来，我们就继续来看如何解决内建map的并发读写问题。</p><h2>如何实现线程安全的map类型？</h2><p>避免map并发读写panic的方式之一就是加锁，考虑到读写性能，可以使用读写锁提供性能。</p><h3>加读写锁：扩展map，支持并发读写</h3><p>比较遗憾的是，目前Go还没有正式发布泛型特性，我们还不能实现一个通用的支持泛型的加锁map。但是，将要发布的泛型方案已经可以验证测试了，离发布也不远了，也许发布之后sync.Map就支持泛型了。</p><p>当然了，如果没有泛型支持，我们也能解决这个问题。我们可以通过interface{}来模拟泛型，但还是要涉及接口和具体类型的转换，比较复杂，还不如将要发布的泛型方案更直接、性能更好。</p><p>这里我以一个具体的map类型为例，来演示利用读写锁实现线程安全的map[int]int类型：</p><pre><code>type RWMap struct { // 一个读写锁保护的线程安全的map\n    sync.RWMutex // 读写锁保护下面的map字段\n    m map[int]int\n}\n// 新建一个RWMap\nfunc NewRWMap(n int) *RWMap {\n    return &amp;RWMap{\n        m: make(map[int]int, n),\n    }\n}\nfunc (m *RWMap) Get(k int) (int, bool) { //从map中读取一个值\n    m.RLock()\n    defer m.RUnlock()\n    v, existed := m.m[k] // 在锁的保护下从map中读取\n    return v, existed\n}\n\nfunc (m *RWMap) Set(k int, v int) { // 设置一个键值对\n    m.Lock()              // 锁保护\n    defer m.Unlock()\n    m.m[k] = v\n}\n\nfunc (m *RWMap) Delete(k int) { //删除一个键\n    m.Lock()                   // 锁保护\n    defer m.Unlock()\n    delete(m.m, k)\n}\n\nfunc (m *RWMap) Len() int { // map的长度\n    m.RLock()   // 锁保护\n    defer m.RUnlock()\n    return len(m.m)\n}\n\nfunc (m *RWMap) Each(f func(k, v int) bool) { // 遍历map\n    m.RLock()             //遍历期间一直持有读锁\n    defer m.RUnlock()\n\n    for k, v := range m.m {\n        if !f(k, v) {\n            return\n        }\n    }\n}\n\n</code></pre><p>正如这段代码所示，对map对象的操作，无非就是增删改查和遍历等几种常见操作。我们可以把这些操作分为读和写两类，其中，查询和遍历可以看做读操作，增加、修改和删除可以看做写操作。如例子所示，我们可以通过读写锁对相应的操作进行保护。</p><h3>分片加锁：更高效的并发map</h3><p>虽然使用读写锁可以提供线程安全的map，但是在大量并发读写的情况下，锁的竞争会非常激烈。我在<a href=\"https://time.geekbang.org/column/article/296793\">第4讲</a>中提到过，锁是性能下降的万恶之源之一。</p><p>在并发编程中，我们的一条原则就是尽量减少锁的使用。一些单线程单进程的应用（比如Redis等），基本上不需要使用锁去解决并发线程访问的问题，所以可以取得很高的性能。但是对于Go开发的应用程序来说，并发是常用的一个特性，在这种情况下，我们能做的就是，<strong>尽量减少锁的粒度和锁的持有时间</strong>。</p><p>你可以优化业务处理的代码，以此来减少锁的持有时间，比如将串行的操作变成并行的子任务执行。不过，这就是另外的故事了，今天我们还是主要讲对同步原语的优化，所以这里我重点讲如何减少锁的粒度。</p><p><strong>减少锁的粒度常用的方法就是分片</strong>（Shard），将一把锁分成几把锁，每个锁控制一个分片。Go比较知名的分片并发map的实现是<a href=\"https://github.com/orcaman/concurrent-map\">orcaman/concurrent-map</a>。</p><p>它默认采用32个分片，<strong>GetShard是一个关键的方法，能够根据key计算出分片索引</strong>。</p><pre><code>\n    var SHARD_COUNT = 32\n\t\n    // 分成SHARD_COUNT个分片的map\n\ttype ConcurrentMap []*ConcurrentMapShared\n\t\n\t// 通过RWMutex保护的线程安全的分片，包含一个map\n\ttype ConcurrentMapShared struct {\n\t\titems        map[string]interface{}\n\t\tsync.RWMutex // Read Write mutex, guards access to internal map.\n\t}\n\t\n\t// 创建并发map\n\tfunc New() ConcurrentMap {\n\t\tm := make(ConcurrentMap, SHARD_COUNT)\n\t\tfor i := 0; i &lt; SHARD_COUNT; i++ {\n\t\t\tm[i] = &amp;ConcurrentMapShared{items: make(map[string]interface{})}\n\t\t}\n\t\treturn m\n\t}\n\t\n\n\t// 根据key计算分片索引\n\tfunc (m ConcurrentMap) GetShard(key string) *ConcurrentMapShared {\n\t\treturn m[uint(fnv32(key))%uint(SHARD_COUNT)]\n\t}\n</code></pre><p>增加或者查询的时候，首先根据分片索引得到分片对象，然后对分片对象加锁进行操作：</p><pre><code>func (m ConcurrentMap) Set(key string, value interface{}) {\n\t\t// 根据key计算出对应的分片\n\t\tshard := m.GetShard(key)\n\t\tshard.Lock() //对这个分片加锁，执行业务操作\n\t\tshard.items[key] = value\n\t\tshard.Unlock()\n}\n\nfunc (m ConcurrentMap) Get(key string) (interface{}, bool) {\n\t\t// 根据key计算出对应的分片\n\t\tshard := m.GetShard(key)\n\t\tshard.RLock()\n\t\t// 从这个分片读取key的值\n\t\tval, ok := shard.items[key]\n\t\tshard.RUnlock()\n\t\treturn val, ok\n}\n</code></pre><p>当然，除了GetShard方法，ConcurrentMap还提供了很多其他的方法。这些方法都是通过计算相应的分片实现的，目的是保证把锁的粒度限制在分片上。</p><p>好了，到这里我们就学会了解决map并发panic的两个方法：加锁和分片。</p><p><strong>在我个人使用并发map的过程中，加锁和分片加锁这两种方案都比较常用，如果是追求更高的性能，显然是分片加锁更好，因为它可以降低锁的粒度，进而提高访问此map对象的吞吐。如果并发性能要求不是那么高的场景，简单加锁方式更简单。</strong></p><p>接下来，我会继续给你介绍sync.Map，这是Go官方线程安全map的标准实现。虽然是官方标准，反而是不常用的，为什么呢？一句话来说就是map要解决的场景很难描述，很多时候在做抉择时根本就不知道该不该用它。但是呢，确实有一些特定的场景，我们需要用到sync.Map来实现，所以还是很有必要学习这个知识点。具体什么场景呢，我慢慢给你道来。</p><h2>应对特殊场景的sync.Map</h2><p>Go内建的map类型不是线程安全的，所以Go 1.9中增加了一个线程安全的map，也就是sync.Map。但是，我们一定要记住，这个sync.Map并不是用来替换内建的map类型的，它只能被应用在一些特殊的场景里。</p><p>那这些特殊的场景是啥呢？<a href=\"https://golang.org/pkg/sync/#Map\">官方的文档</a>中指出，在以下两个场景中使用sync.Map，会比使用map+RWMutex的方式，性能要好得多：</p><ol>\n<li>只会增长的缓存系统中，一个key只写入一次而被读很多次；</li>\n<li>多个goroutine为不相交的键集读、写和重写键值对。</li>\n</ol><p>这两个场景说得都比较笼统，而且，这些场景中还包含了一些特殊的情况。所以，官方建议你针对自己的场景做性能评测，如果确实能够显著提高性能，再使用sync.Map。</p><p>这么来看，我们能用到sync.Map的场景确实不多。即使是sync.Map的作者Bryan C. Mills，也很少使用sync.Map，即便是在使用sync.Map的时候，也是需要临时查询它的API，才能清楚记住它的功能。所以，我们可以把sync.Map看成一个生产环境中很少使用的同步原语。</p><h3>sync.Map的实现</h3><p>那sync.Map是怎么实现的呢？它是如何解决并发问题提升性能的呢？其实sync.Map的实现有几个优化点，这里先列出来，我们后面慢慢分析。</p><ul>\n<li>空间换时间。通过冗余的两个数据结构（只读的read字段、可写的dirty），来减少加锁对性能的影响。对只读字段（read）的操作不需要加锁。</li>\n<li>优先从read字段读取、更新、删除，因为对read字段的读取不需要锁。</li>\n<li>动态调整。miss次数多了之后，将dirty数据提升为read，避免总是从dirty中加锁读取。</li>\n<li>double-checking。加锁之后先还要再检查read字段，确定真的不存在才操作dirty字段。</li>\n<li>延迟删除。删除一个键值只是打标记，只有在提升dirty字段为read字段的时候才清理删除的数据。</li>\n</ul><p>要理解sync.Map这些优化点，我们还是得深入到它的设计和实现上，去学习它的处理方式。</p><p>我们先看一下map的数据结构：</p><pre><code>type Map struct {\n    mu Mutex\n    // 基本上你可以把它看成一个安全的只读的map\n    // 它包含的元素其实也是通过原子操作更新的，但是已删除的entry就需要加锁操作了\n    read atomic.Value // readOnly\n\n    // 包含需要加锁才能访问的元素\n    // 包括所有在read字段中但未被expunged（删除）的元素以及新加的元素\n    dirty map[interface{}]*entry\n\n    // 记录从read中读取miss的次数，一旦miss数和dirty长度一样了，就会把dirty提升为read，并把dirty置空\n    misses int\n}\n\ntype readOnly struct {\n    m       map[interface{}]*entry\n    amended bool // 当dirty中包含read没有的数据时为true，比如新增一条数据\n}\n\n// expunged是用来标识此项已经删掉的指针\n// 当map中的一个项目被删除了，只是把它的值标记为expunged，以后才有机会真正删除此项\nvar expunged = unsafe.Pointer(new(interface{}))\n\n// entry代表一个值\ntype entry struct {\n    p unsafe.Pointer // *interface{}\n}\n</code></pre><p>如果dirty字段非nil的话，map的read字段和dirty字段会包含相同的非expunged的项，所以如果通过read字段更改了这个项的值，从dirty字段中也会读取到这个项的新值，因为本来它们指向的就是同一个地址。</p><p>dirty包含重复项目的好处就是，一旦miss数达到阈值需要将dirty提升为read的话，只需简单地把dirty设置为read对象即可。不好的一点就是，当创建新的dirty对象的时候，需要逐条遍历read，把非expunged的项复制到dirty对象中。</p><p>接下来，我们就深入到源码去看看sync.map的实现。在看这部分源码的过程中，我们只要重点关注Store、Load和Delete这3个核心的方法就可以了。</p><p>Store、Load和Delete这三个核心函数的操作都是先从read字段中处理的，因为读取read字段的时候不用加锁。</p><h4>Store方法</h4><p>我们先来看Store方法，它是用来设置一个键值对，或者更新一个键值对的。</p><pre><code>func (m *Map) Store(key, value interface{}) {\n    read, _ := m.read.Load().(readOnly)\n    // 如果read字段包含这个项，说明是更新，cas更新项目的值即可\n    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {\n        return\n    }\n\n    // read中不存在，或者cas更新失败，就需要加锁访问dirty了\n    m.mu.Lock()\n    read, _ = m.read.Load().(readOnly)\n    if e, ok := read.m[key]; ok { // 双检查，看看read是否已经存在了\n        if e.unexpungeLocked() {\n            // 此项目先前已经被删除了，通过将它的值设置为nil，标记为unexpunged\n            m.dirty[key] = e\n        }\n        e.storeLocked(&amp;value) // 更新\n    } else if e, ok := m.dirty[key]; ok { // 如果dirty中有此项\n        e.storeLocked(&amp;value) // 直接更新\n    } else { // 否则就是一个新的key\n        if !read.amended { //如果dirty为nil\n            // 需要创建dirty对象，并且标记read的amended为true,\n            // 说明有元素它不包含而dirty包含\n            m.dirtyLocked()\n            m.read.Store(readOnly{m: read.m, amended: true})\n        }\n        m.dirty[key] = newEntry(value) //将新值增加到dirty对象中\n    }\n    m.mu.Unlock()\n}\n</code></pre><p>可以看出，Store既可以是新增元素，也可以是更新元素。如果运气好的话，更新的是已存在的未被删除的元素，直接更新即可，不会用到锁。如果运气不好，需要更新（重用）删除的对象、更新还未提升的dirty中的对象，或者新增加元素的时候就会使用到了锁，这个时候，性能就会下降。</p><p>所以从这一点来看，sync.Map适合那些只会增长的缓存系统，可以进行更新，但是不要删除，并且不要频繁地增加新元素。</p><p>新加的元素需要放入到dirty中，如果dirty为nil，那么需要从read字段中复制出来一个dirty对象：</p><pre><code>func (m *Map) dirtyLocked() {\n    if m.dirty != nil { // 如果dirty字段已经存在，不需要创建了\n        return\n    }\n\n    read, _ := m.read.Load().(readOnly) // 获取read字段\n    m.dirty = make(map[interface{}]*entry, len(read.m))\n    for k, e := range read.m { // 遍历read字段\n        if !e.tryExpungeLocked() { // 把非punged的键值对复制到dirty中\n            m.dirty[k] = e\n        }\n    }\n}\n</code></pre><h4>Load方法</h4><p>Load方法用来读取一个key对应的值。它也是从read开始处理，一开始并不需要锁。</p><pre><code>func (m *Map) Load(key interface{}) (value interface{}, ok bool) {\n    // 首先从read处理\n    read, _ := m.read.Load().(readOnly)\n    e, ok := read.m[key]\n    if !ok &amp;&amp; read.amended { // 如果不存在并且dirty不为nil(有新的元素)\n        m.mu.Lock()\n        // 双检查，看看read中现在是否存在此key\n        read, _ = m.read.Load().(readOnly)\n        e, ok = read.m[key]\n        if !ok &amp;&amp; read.amended {//依然不存在，并且dirty不为nil\n            e, ok = m.dirty[key]// 从dirty中读取\n            // 不管dirty中存不存在，miss数都加1\n            m.missLocked()\n        }\n        m.mu.Unlock()\n    }\n    if !ok {\n        return nil, false\n    }\n    return e.load() //返回读取的对象，e既可能是从read中获得的，也可能是从dirty中获得的\n}\n</code></pre><p>如果幸运的话，我们从read中读取到了这个key对应的值，那么就不需要加锁了，性能会非常好。但是，如果请求的key不存在或者是新加的，就需要加锁从dirty中读取。所以，读取不存在的key会因为加锁而导致性能下降，读取还没有提升的新值的情况下也会因为加锁性能下降。</p><p>其中，missLocked增加miss的时候，如果miss数等于dirty长度，会将dirty提升为read，并将dirty置空。</p><pre><code>func (m *Map) missLocked() {\n    m.misses++ // misses计数加一\n    if m.misses &lt; len(m.dirty) { // 如果没达到阈值(dirty字段的长度),返回\n        return\n    }\n    m.read.Store(readOnly{m: m.dirty}) //把dirty字段的内存提升为read字段\n    m.dirty = nil // 清空dirty\n    m.misses = 0  // misses数重置为0\n}\n</code></pre><h4>Delete方法</h4><p>sync.map的第3个核心方法是Delete方法。在Go 1.15中欧长坤提供了一个LoadAndDelete的实现（<a href=\"https://github.com/golang/go/issues/33762\">go#issue 33762</a>），所以Delete方法的核心改在了对LoadAndDelete中实现了。</p><p>同样地，Delete方法是先从read操作开始，原因我们已经知道了，因为不需要锁。</p><pre><code>func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool) {\n    read, _ := m.read.Load().(readOnly)\n    e, ok := read.m[key]\n    if !ok &amp;&amp; read.amended {\n        m.mu.Lock()\n        // 双检查\n        read, _ = m.read.Load().(readOnly)\n        e, ok = read.m[key]\n        if !ok &amp;&amp; read.amended {\n            e, ok = m.dirty[key]\n            // 这一行长坤在1.15中实现的时候忘记加上了，导致在特殊的场景下有些key总是没有被回收\n            delete(m.dirty, key)\n            // miss数加1\n            m.missLocked()\n        }\n        m.mu.Unlock()\n    }\n    if ok {\n        return e.delete()\n    }\n    return nil, false\n}\n\nfunc (m *Map) Delete(key interface{}) {\n    m.LoadAndDelete(key)\n}\nfunc (e *entry) delete() (value interface{}, ok bool) {\n    for {\n        p := atomic.LoadPointer(&amp;e.p)\n        if p == nil || p == expunged {\n            return nil, false\n        }\n        if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {\n            return *(*interface{})(p), true\n        }\n    }\n}\n</code></pre><p>如果read中不存在，那么就需要从dirty中寻找这个项目。最终，如果项目存在就删除（将它的值标记为nil）。如果项目不为nil或者没有被标记为expunged，那么还可以把它的值返回。</p><p>最后，我补充一点，sync.map还有一些LoadAndDelete、LoadOrStore、Range等辅助方法，但是没有Len这样查询sync.Map的包含项目数量的方法，并且官方也不准备提供。如果你想得到sync.Map的项目数量的话，你可能不得不通过Range逐个计数。</p><h2>总结</h2><p>Go内置的map类型使用起来很方便，但是它有一个非常致命的缺陷，那就是它存在着并发问题，所以如果有多个goroutine同时并发访问这个map，就会导致程序崩溃。所以Go官方Blog很早就提供了一种加锁的<a href=\"https://blog.golang.org/maps#TOC_6.\">方法</a>，还有后来提供了适用特定场景的线程安全的sync.Map，还有第三方实现的分片式的map，这些方法都可以应用于并发访问的场景。</p><p>这里我给你的建议，也是Go开发者给的建议，就是通过性能测试，看看某种线程安全的map实现是否满足你的需求。</p><p>当然还有一些扩展其它功能的map实现，比如带有过期功能的<a href=\"https://github.com/zekroTJA/timedmap\">timedmap</a>、使用红黑树实现的key有序的<a href=\"https://godoc.org/github.com/emirpasic/gods/maps/treemap\">treemap</a>等，因为和并发问题没有关系，就不详细介绍了。这里我给你提供了链接，你可以自己探索。</p><p><img src=\"https://static001.geekbang.org/resource/image/a8/03/a80408a137b13f934b0dd6f2b6c5cc03.jpg?wh=2250*1771\" alt=\"\"></p><h2>思考题</h2><ol>\n<li>\n<p>为什么sync.Map中的集合核心方法的实现中，如果read中项目不存在，加锁后还要双检查，再检查一次read？</p>\n</li>\n<li>\n<p>你看到sync.map元素删除的时候只是把它的值设置为nil，那么什么时候这个key才会真正从map对象中删除？</p>\n</li>\n</ol><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","neighbors":{"left":{"article_title":"08 | Once：一个简约而不简单的并发原语","id":301113},"right":{"article_title":"10 | Pool：性能提升大杀器","id":301716}},"comments":[{"had_liked":false,"id":257535,"user_name":"Junes","can_delete":false,"product_type":"c1","uid":1354665,"ip_address":"","ucode":"CD2E829C868970","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/a9/590d6f02.jpg","comment_is_top":false,"comment_ctime":1604022390,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"130453041270","product_id":100061801,"comment_content":"1. 双检查主要是针对高并发的场景：<br>第一次先用CAS快速尝试，失败后进行加锁，然后进行第二次CAS检查，再进行修改；<br>在高并发的情况下，存在多个goroutine在修改同一个Key，第一次CAS都失败了，在竞争锁；如果不进行第二次CAS检查就直接修改，这个Key就会被多次修改；<br><br>2. 真正删除key的操作是在数据从read往dirty迁移的过程中（往dirty写数据时，发现dirty没有数据，就会触发迁移），只迁移没有被标记为删除的KV","like_count":31,"discussions":[{"author":{"id":2854629,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/8e/e5/1a2028e7.jpg","nickname":"GQ","note":"","ucode":"3ABBD41FA87375","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578162,"discussion_content":"第一次m.read.load结束与m.mu.lock开始这段时间内，m.dirty可能已经被提升为m.read(代码里有注释)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656550695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1556358,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bf/86/c0cb35f0.jpg","nickname":"8.13.3.27.30","note":"","ucode":"2DE3CE3E338BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535991,"discussion_content":"真正删除key这个说法不是很恰当,是真正被标记成expunged的操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638627988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385912,"discussion_content":"双检查的时候没有cas啊，只是读取值吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627347950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1095740,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","nickname":"Panda","note":"","ucode":"911A200C7B18BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345549,"discussion_content":"双保险设计   哈哈                   ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611739106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257617,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1604044066,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"53143651618","product_id":100061801,"comment_content":"看到本文的标题,就让我想到之前看过的一篇文章:<br>[踩了 Golang sync.Map 的一个坑](https:&#47;&#47;gocn.vip&#47;topics&#47;10860)<br><br>就是老师文章代码中的一行注释的由来:<br>`这一行长坤在1.15中实现的时候忘记加上了，导致在特殊的场景下有些key总是没有被回收`<br><br>当时我是好好把系统的sync.Map代码看了一下.<br>虽然才短短384行代码,但还是花了不少功夫.<br><br>另外,推荐一个 欧长坤 未完工的开源电子书 [Go 语言原本](https:&#47;&#47;github.com&#47;golang-design&#47;under-the-hood).<br>","like_count":13,"discussions":[{"author":{"id":1433853,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e0/fd/011c5dad.jpg","nickname":"缺席你的过去","note":"","ucode":"08E0452191B714","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337423,"discussion_content":"这书看不懂，整个就是一论文啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608901053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258180,"user_name":"NULL","can_delete":false,"product_type":"c1","uid":1191550,"ip_address":"","ucode":"2A323DD05352BC","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/7e/ebc28e10.jpg","comment_is_top":false,"comment_ctime":1604320447,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35964058815","product_id":100061801,"comment_content":"感觉有两个地方写的有点模糊，导致对后面的内容有些不明所以_(:з」∠)_<br>1是 “通过冗余的两个数据结构（只读的 read 字段、可以 dirty）”，可以 dirty 是笔误吗<br>2是 “动态调整。miss 次数多了之后”，miss是什么？<br><br>查了下其他资料，dirty指 将最新写入的数据则存在 dirty 字段上<br>misses 字段用来统计 read 被穿透的次数（被穿透指需要读 dirty 的情况）<br>这样理解起来好多了_(:з」∠)_","like_count":8,"discussions":[{"author":{"id":1191550,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2e/7e/ebc28e10.jpg","nickname":"NULL","note":"","ucode":"2A323DD05352BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539548,"discussion_content":"一年了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639748771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260810,"user_name":"蜉蝣","can_delete":false,"product_type":"c1","uid":1229070,"ip_address":"","ucode":"77CF92496855D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","comment_is_top":false,"comment_ctime":1605111556,"is_pvip":false,"replies":[{"id":"94802","content":"第一你说的没错：nil和expunged都代表元素被删除了，只不过expunged比较特殊，如果被删除的元素是expunged,代表它只存在于readonly之中，不存在于dirty中。这样如果重新设置这个key的话，需要往dirty增加key","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605253667,"ip_address":"","comment_id":260810,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31669882628","product_id":100061801,"comment_content":"老师好，我看到 read 中 key 被删除会有两个状态：nil 和 expunged。我会有些不明白，要么都用 nil 或者都用 expunged，这样会不会更好一些？","like_count":8,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509294,"discussion_content":"第一你说的没错：nil和expunged都代表元素被删除了，只不过expunged比较特殊，如果被删除的元素是expunged,代表它只存在于readonly之中，不存在于dirty中。这样如果重新设置这个key的话，需要往dirty增加key","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605253667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1350159,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","nickname":"芒果少侠","note":"","ucode":"98D0BBB52BB80F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341338,"discussion_content":"read向dirty复制时，元素转为expunged。此时仅存在于read中。这样从read中就可以知道元素被删除了，不需要再加锁进入dirty判断。可以提高性能","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1610379982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1296804,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c9/a4/0710bbbd.jpg","nickname":"Geek_18858f","note":"","ucode":"391B5F20C2E860","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1350159,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","nickname":"芒果少侠","note":"","ucode":"98D0BBB52BB80F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":576259,"discussion_content":"前半句认同。后半句如果指的是 Store 的情况，如果重新设置那个 key，会进到 unexpungeLocked 的逻辑，往 dirty 增加 key，但其实这个操作也是在锁里面完成的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655378740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":341338,"ip_address":""},"score":576259,"extra":""}]}]},{"had_liked":false,"id":293807,"user_name":"TT","can_delete":false,"product_type":"c1","uid":1466771,"ip_address":"","ucode":"2D8CE3E45DA7A4","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/93/3191eafa.jpg","comment_is_top":false,"comment_ctime":1621563164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23096399644","product_id":100061801,"comment_content":" 1. 为什么说 read 是并发读写安全的？<br> 2. read 为什么可以更新 key 对应的 value？dirty 中会同步更新吗？<br> 3. map 的 misses 是什么？干嘛用的？<br> 4. 什么时候 misses 会变化？<br> 5. readOnly 的 amended 是什么？<br> 6. 什么时候会改变 amended？<br> 7. 定义 expunged 是干什么用的？标记清除到底是怎么标记的？又是怎么清除的？<br><br>自己写了一篇总结 http:&#47;&#47;zero-tt.fun&#47;go&#47;sync-map&#47; ，希望可以和大家讨论","like_count":5},{"had_liked":false,"id":341918,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1649918232,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1649918232","product_id":100061801,"comment_content":"concurrent-map，新知识点get，项目中用起来。","like_count":0},{"had_liked":false,"id":339425,"user_name":"tingting","can_delete":false,"product_type":"c1","uid":2035702,"ip_address":"","ucode":"61E6B0C4EC59C5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0f/f6/609ded9f.jpg","comment_is_top":false,"comment_ctime":1648093471,"is_pvip":false,"replies":[{"id":"124128","content":"会。<br>遇到这样的问题不如写个测试验证一下","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1648255007,"ip_address":"","comment_id":339425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648093471","product_id":100061801,"comment_content":"想问一下老师，以下这种情况会有data race吗？<br>m:=make(map[string]int)<br>Goroutine A: 不停地覆盖m指向新的map值<br>Goroutine B: 不停地读m里面的某个key","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558359,"discussion_content":"会。\n遇到这样的问题不如写个测试验证一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648255007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320362,"user_name":"叶小彬","can_delete":false,"product_type":"c1","uid":1442559,"ip_address":"","ucode":"534D4D416E2EF7","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/ff/e21a97c1.jpg","comment_is_top":false,"comment_ctime":1636277576,"is_pvip":false,"replies":[{"id":"117246","content":"只读不需要加锁，快","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1637682033,"ip_address":"","comment_id":320362,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636277576","product_id":100061801,"comment_content":"老师，我看了sync.Map 源码，有两点不是很懂<br>1、设计read和dirty的想法是什么<br>因为sync.Map里，read结构本身就是atomic.Value，增加和修改有Store方法，本身就可以防止幻读，脏读的问题，如果是为了delete的逻辑（我发现atomic.Value里是没有delete方法的），那完全可以写一个加锁逻辑的delete，个人感觉dirty的没什么用<br>2、源码里的逻辑是，当read 的miss次数大于等于dirty的长度的时候，就将dirty转成read，这个是什么设计想法","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532779,"discussion_content":"只读不需要加锁，快","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637682033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318604,"user_name":"徐改","can_delete":false,"product_type":"c1","uid":1298380,"ip_address":"","ucode":"82276A584AC602","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","comment_is_top":false,"comment_ctime":1635346847,"is_pvip":false,"replies":[{"id":"118196","content":"因为dirty将来可能转为readonly","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1639210073,"ip_address":"","comment_id":318604,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635346847","product_id":100061801,"comment_content":"还是不太明白为什么在创建dirty的时候，要将read中未删除的entry拷贝给dirty.<br>sync.map一个优秀的地方是当我们访问read的时候不需要上锁，访问dirty的时候需要加锁。在Load()方法中，我们每次都是先访问read，如果read中没有的话才访问dirty。那么对于dirty来说，dirty中的数据可能read没有，或者read有。read中有的数据，dirty有；read中没有的数据，dirty可能会有。而我们的程序每次都是先访问read，如果read没有后续才会访问dirty，那这样的话创建dirty的时候，感觉可以不用将read中的entry一个一个拷贝到dirty中，因为我们访问是先访问read的。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537826,"discussion_content":"因为dirty将来可能转为readonly","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639210073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300814,"user_name":"while (1)等;","can_delete":false,"product_type":"c1","uid":1061991,"ip_address":"","ucode":"BAEC7258D65B69","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/67/06a7f9be.jpg","comment_is_top":false,"comment_ctime":1625394747,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625394747","product_id":100061801,"comment_content":"老师好！<br>type RWMap struct { &#47;&#47; 一个读写锁保护的线程安全的map<br>    sync.RWMutex &#47;&#47; 读写锁保护下面的map字段<br>    m map[int]int<br>}<br>&#47;&#47; 新建一个RWMap<br>func NewRWMap(n int) *RWMap {<br>    return &amp;RWMap{<br>        m: make(map[int]int, n),<br>    }<br>}<br>这里初始化map的时候为什么用的是&amp;RWMap","like_count":0},{"had_liked":false,"id":299663,"user_name":"geek_arong2048","can_delete":false,"product_type":"c1","uid":1518310,"ip_address":"","ucode":"AB575BE100E4A9","user_header":"https://static001.geekbang.org/account/avatar/00/17/2a/e6/c788257f.jpg","comment_is_top":false,"comment_ctime":1624786386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624786386","product_id":100061801,"comment_content":"Map并发安全优化：<br>1、读写锁<br>2、CAS、Atomic原子操作<br>3、分段锁","like_count":0},{"had_liked":false,"id":292752,"user_name":"校歌","can_delete":false,"product_type":"c1","uid":2054611,"ip_address":"","ucode":"CD257668BB1A33","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKBENQekdV3e9XwRQ5kpO9Y9d81sEMm52qcwJWbFbWbW2rniaTFYCChoR0ibZ0E3soQqod9rvfmBibmQ/132","comment_is_top":false,"comment_ctime":1620962277,"is_pvip":true,"replies":[{"id":"106039","content":"是的，准确的说可以和nil比较","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1621011295,"ip_address":"","comment_id":292752,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1620962277","product_id":100061801,"comment_content":"老师，发现有个地方不严谨，”map不可比较”。我写了个小程序，提示map只可以跟nil比较，而不是不能比较。（可能有点扣字眼了）<br>.&#47;main.go:11:12: invalid operation: resMap == resMap (map can only be compared to nil)","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519945,"discussion_content":"是的，准确的说可以和nil比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621011295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275991,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1611739043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611739043","product_id":100061801,"comment_content":"map 很常用  有两个问题 <br><br> 1 无序 可以用 第三方 ordermap 解决  <br>2. 并发问题   可以加锁 或者分片<br>PS:  官方的 sync.map  不太常用","like_count":0},{"had_liked":false,"id":270292,"user_name":"( ･᷄ὢ･᷅ )","can_delete":false,"product_type":"c1","uid":2234129,"ip_address":"","ucode":"E5F5EDEBB74C46","user_header":"https://static001.geekbang.org/account/avatar/00/22/17/11/a63acc6a.jpg","comment_is_top":false,"comment_ctime":1609054558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609054558","product_id":100061801,"comment_content":"作业：<br>1.为了防止在第一次检查后加锁前并发运行的其他Store操作对其进行了增加。即把dirty复制给read.m、<br>2.真正删除是在在readonly中没有查询到数据且amended标记为true 的时候进行了删除","like_count":0},{"had_liked":false,"id":267234,"user_name":"Geek_194084","can_delete":false,"product_type":"c1","uid":2342665,"ip_address":"","ucode":"0732E7D5D60EB6","user_header":"","comment_is_top":false,"comment_ctime":1607655376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607655376","product_id":100061801,"comment_content":"大佬，函数的返回值应该可以比较把","like_count":0},{"had_liked":false,"id":265728,"user_name":"不求闻达","can_delete":false,"product_type":"c1","uid":1629565,"ip_address":"","ucode":"B265859B9566D5","user_header":"https://static001.geekbang.org/account/avatar/00/18/dd/7d/5d3ab033.jpg","comment_is_top":false,"comment_ctime":1606995561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606995561","product_id":100061801,"comment_content":"map","like_count":0},{"had_liked":false,"id":264216,"user_name":"新味道","can_delete":false,"product_type":"c1","uid":2227527,"ip_address":"","ucode":"979E3574082CE7","user_header":"https://static001.geekbang.org/account/avatar/00/21/fd/47/499339d1.jpg","comment_is_top":false,"comment_ctime":1606381959,"is_pvip":false,"replies":[{"id":"95814","content":"因为dirty中也要能查到这些值的","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1606391080,"ip_address":"","comment_id":264216,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606381959","product_id":100061801,"comment_content":"新加的元素需要放入到 dirty 中，如果 dirty 为 nil，那么需要从 read 字段中复制出来一个 dirty 对象。<br><br>---<br>为什么需要从 read 字段中复制出来一个 dirty 对象？<br>","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510468,"discussion_content":"因为dirty中也要能查到这些值的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606391080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261219,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1605243035,"is_pvip":false,"replies":[{"id":"94803","content":"nil和expunged都代表元素被删除了，只不过expunged比较特殊，如果被删除的元素是expunged,代表它只存在于readonly之中，不存在于dirty中。这样如果重新设置这个key的话，需要往dirty增加key","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605253688,"ip_address":"","comment_id":261219,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1605243035","product_id":100061801,"comment_content":"应该着重说明一下为什么有expunged这种状态,这点比较迷惑。我能理解expunged的entry代表read中存在而dirty中不存在。但为什么在read向dirty复制时，需要将nil的entry变为expunged？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509422,"discussion_content":"nil和expunged都代表元素被删除了，只不过expunged比较特殊，如果被删除的元素是expunged,代表它只存在于readonly之中，不存在于dirty中。这样如果重新设置这个key的话，需要往dirty增加key","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605253688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325421,"discussion_content":"谢谢回复。这个作用我理解，但不理解这样设计的原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605310915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379942,"discussion_content":"如果在复制时nil直接移除，再次读需要加锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624257361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325421,"ip_address":""},"score":379942,"extra":""}]}]},{"had_liked":false,"id":259341,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1604709407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604709407","product_id":100061801,"comment_content":"没有竞争，就没有伤害！<br>为啥要再次加锁？<br>为了安全，我知道java就有重排序啥的","like_count":0},{"had_liked":false,"id":257861,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1604159134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604159134","product_id":100061801,"comment_content":"看完打卡。","like_count":0},{"had_liked":false,"id":257834,"user_name":"Panmax","can_delete":false,"product_type":"c1","uid":1004871,"ip_address":"","ucode":"9D65E3B84C5519","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/47/d217c45f.jpg","comment_is_top":false,"comment_ctime":1604149136,"is_pvip":false,"replies":[{"id":"93881","content":"这句话应该删除，谢谢指出","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604190012,"ip_address":"","comment_id":257834,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604149136","product_id":100061801,"comment_content":"文章中写到「所以，这里我们就超前一把，我带你直接体验这个即将要发布的泛型方案。」<br><br>是我对泛型的理解有什么误会吗，下文中并没有看到使用泛型的地方������。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508465,"discussion_content":"这句话应该删除，谢谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604190012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257682,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1604056198,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604056198","product_id":100061801,"comment_content":"分片索引值计算也消耗一部分时间的吧？<br>","like_count":0,"discussions":[{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320235,"discussion_content":"和整体加锁相比，应该是可以忽略了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604299923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}