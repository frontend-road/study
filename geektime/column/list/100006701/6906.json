{"id":6906,"title":"第3讲 | 谈谈final、finally、 finalize有什么不同？","content":"<p>Java语言有很多看起来很相似，但是用途却完全不同的语言要素，这些内容往往容易成为面试官考察你知识掌握程度的切入点。</p>\n<p>今天，我要问你的是一个经典的Java基础题目，<span class=\"orange\">谈谈final、finally、 finalize有什么不同？</span></p>\n<h2>典型回答</h2>\n<p>final可以用来修饰类、方法、变量，分别有不同的意义，final修饰的class代表不可以继承扩展，final的变量是不可以修改的，而final的方法也是不可以重写的（override）。</p>\n<p>finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。</p>\n<p>finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK 9开始被标记为deprecated。</p>\n<h2>考点分析</h2>\n<p>这是一个非常经典的Java基础问题，我上面的回答主要是从语法和使用实践角度出发的，其实还有很多方面可以深入探讨，面试官还可以考察你对性能、并发、对象生命周期或垃圾收集基本过程等方面的理解。</p>\n<!-- [[[read_end]]] -->\n<p>推荐使用final关键字来明确表示我们代码的语义、逻辑意图，这已经被证明在很多场景下是非常好的实践，比如：</p>\n<ul>\n<li>我们可以将方法或者类声明为final，这样就可以明确告知别人，这些行为是不许修改的。</li>\n</ul>\n<p>如果你关注过Java核心类库的定义或源码， 有没有发现java.lang包下面的很多类，相当一部分都被声明成为final class？在第三方类库的一些基础类中同样如此，这可以有效避免API使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。</p>\n<ul>\n<li>\n<p>使用final修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成final。</p>\n</li>\n<li>\n<p>final变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值final变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</p>\n</li>\n</ul>\n<p>final也许会有性能的好处，很多文章或者书籍中都介绍了可在特定场景提高性能，比如，利用final可能有助于JVM将方法进行内联，可以改善编译器进行条件编译的能力等等。坦白说，很多类似的结论都是基于假设得出的，比如现代高性能JVM（如HotSpot）判断内联未必依赖final的提示，要相信JVM还是非常智能的。类似的，final字段对性能的影响，大部分情况下，并没有考虑的必要。</p>\n<p>从开发实践的角度，我不想过度强调这一点，这是和JVM的实现很相关的，未经验证比较难以把握。我的建议是，在日常开发中，除非有特别考虑，不然最好不要指望这种小技巧带来的所谓性能好处，程序最好是体现它的语义目的。如果你确实对这方面有兴趣，可以查阅相关资料，我就不再赘述了，不过千万别忘了验证一下。</p>\n<p>对于finally，明确知道怎么使用就足够了。需要关闭的连接等资源，更推荐使用Java 7中添加的try-with-resources语句，因为通常Java平台能够更好地处理异常情况，编码量也要少很多，何乐而不为呢。</p>\n<p>另外，我注意到有一些常被考到的finally问题（也比较偏门），至少需要了解一下。比如，下面代码会输出什么？</p>\n<pre><code>try {\n  // do something\n  System.exit(1);\n} finally{\n  System.out.println(“Print from finally”);\n}\n</code></pre>\n<p>上面finally里面的代码可不会被执行的哦，这是一个特例。</p>\n<p>对于finalize，我们要明确它是不推荐使用的，业界实践一再证明它不是个好的办法，在Java 9中，甚至明确将Object.finalize()标记为deprecated！如果没有特别的原因，不要实现finalize方法，也不要指望利用它来进行资源回收。</p>\n<p>为什么呢？简单说，你无法保证finalize什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。</p>\n<p>通常来说，利用上面的提到的try-with-resources或者try-finally机制，是非常好的回收资源的办法。如果确实需要额外处理，可以考虑Java提供的Cleaner机制或者其他替代方法。接下来，我来介绍更多设计考虑和实践细节。</p>\n<h2>知识扩展</h2>\n<p>1.注意，final不是immutable！</p>\n<p>我在前面介绍了final在实践中的益处，需要注意的是，<strong>final并不等同于immutable</strong>，比如下面这段代码：</p>\n<pre><code> final List&lt;String&gt; strList = new ArrayList&lt;&gt;();\n strList.add(&quot;Hello&quot;);\n strList.add(&quot;world&quot;);  \n List&lt;String&gt; unmodifiableStrList = List.of(&quot;hello&quot;, &quot;world&quot;);\n unmodifiableStrList.add(&quot;again&quot;);\n</code></pre>\n<p>final只能约束strList这个引用不可以被赋值，但是strList对象行为不被final影响，添加元素等操作是完全正常的。如果我们真的希望对象本身是不可变的，那么需要相应的类支持不可变的行为。在上面这个例子中，<a href=\"http://openjdk.java.net/jeps/269\">List.of方法</a>创建的本身就是不可变List，最后那句add是会在运行时抛出异常的。</p>\n<p>Immutable在很多场景是非常棒的选择，某种意义上说，Java语言目前并没有原生的不可变支持，如果要实现immutable的类，我们需要做到：</p>\n<ul>\n<li>\n<p>将class自身声明为final，这样别人就不能扩展来绕过限制了。</p>\n</li>\n<li>\n<p>将所有成员变量定义为private和final，并且不要实现setter方法。</p>\n</li>\n<li>\n<p>通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。</p>\n</li>\n<li>\n<p>如果确实需要实现getter方法，或者其他可能会返回内部状态的方法，使用copy-on-write原则，创建私有的copy。</p>\n</li>\n</ul>\n<p>这些原则是不是在并发编程实践中经常被提到？的确如此。</p>\n<p>关于setter/getter方法，很多人喜欢直接用IDE一次全部生成，建议最好是你确定有需要时再实现。</p>\n<p>2.finalize真的那么不堪？</p>\n<p>前面简单介绍了finalize是一种已经被业界证明了的非常不好的实践，那么为什么会导致那些问题呢？</p>\n<p>finalize的执行是和垃圾收集关联在一起的，一旦实现了非空的finalize方法，就会导致相应对象回收呈现数量级上的变慢，有人专门做过benchmark，大概是40~50倍的下降。</p>\n<p>因为，finalize被设计成在对象<strong>被垃圾收集前</strong>调用，这就意味着实现了finalize方法的对象是个“特殊公民”，JVM要对它进行额外处理。finalize本质上成为了快速回收的阻碍者，可能导致你的对象经过多个垃圾收集周期才能被回收。</p>\n<p>有人也许会问，我用System.runFinalization​()告诉JVM积极一点，是不是就可以了？也许有点用，但是问题在于，这还是不可预测、不能保证的，所以本质上还是不能指望。实践中，因为finalize拖慢垃圾收集，导致大量对象堆积，也是一种典型的导致OOM的原因。</p>\n<p>从另一个角度，我们要确保回收资源就是因为资源都是有限的，垃圾收集时间的不可预测，可能会极大加剧资源占用。这意味着对于消耗非常高频的资源，千万不要指望finalize去承担资源释放的主要职责，最多让finalize作为最后的“守门员”，况且它已经暴露了如此多的问题。这也是为什么我推荐，<strong>资源用完即显式释放，或者利用资源池来尽量重用</strong>。</p>\n<p>finalize还会掩盖资源回收时的出错信息，我们看下面一段JDK的源代码，截取自java.lang.ref.Finalizer</p>\n<pre><code> private void runFinalizer(JavaLangAccess jla) {\n //  ... 省略部分代码\n try {\n    Object finalizee = this.get(); \n    if (finalizee != null &amp;&amp; !(finalizee instanceof java.lang.Enum)) {\n       jla.invokeFinalize(finalizee);\n       // Clear stack slot containing this variable, to decrease\n       // the chances of false retention with a conservative GC\n       finalizee = null;\n    }\n  } catch (Throwable x) { }\n    super.clear(); \n }\n</code></pre>\n<p>结合我上期专栏介绍的异常处理实践，你认为这段代码会导致什么问题？</p>\n<p>是的，你没有看错，这里的<strong>Throwable是被生吞了的！</strong>也就意味着一旦出现异常或者出错，你得不到任何有效信息。况且，Java在finalize阶段也没有好的方式处理任何信息，不然更加不可预测。</p>\n<p>3.有什么机制可以替换finalize吗？</p>\n<p>Java平台目前在逐步使用java.lang.ref.Cleaner来替换掉原有的finalize实现。Cleaner的实现利用了幻象引用（PhantomReference），这是一种常见的所谓post-mortem清理机制。我会在后面的专栏系统介绍Java的各种引用，利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符（操作系统有限的资源），它比finalize更加轻量、更加可靠。</p>\n<p>吸取了finalize里的教训，每个Cleaner的操作都是独立的，它有自己的运行线程，所以可以避免意外死锁等问题。</p>\n<p>实践中，我们可以为自己的模块构建一个Cleaner，然后实现相应的清理逻辑。下面是JDK自身提供的样例程序：</p>\n<pre><code>public class CleaningExample implements AutoCloseable {\n        // A cleaner, preferably one shared within a library\n        private static final Cleaner cleaner = &lt;cleaner&gt;;\n        static class State implements Runnable { \n            State(...) {\n                // initialize State needed for cleaning action\n            }\n            public void run() {\n                // cleanup action accessing State, executed at most once\n            }\n        }\n        private final State;\n        private final Cleaner.Cleanable cleanable\n        public CleaningExample() {\n            this.state = new State(...);\n            this.cleanable = cleaner.register(this, state);\n        }\n        public void close() {\n            cleanable.clean();\n        }\n    }\n</code></pre>\n<p>注意，从可预测性的角度来判断，Cleaner或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致幻象引用堆积，同样会出现问题。所以，Cleaner适合作为一种最后的保证手段，而不是完全依赖Cleaner进行资源回收，不然我们就要再做一遍finalize的噩梦了。</p>\n<p>我也注意到很多第三方库自己直接利用幻象引用定制资源收集，比如广泛使用的MySQL JDBC driver之一的mysql-connector-j，就利用了幻象引用机制。幻象引用也可以进行类似链条式依赖关系的动作，比如，进行总量控制的场景，保证只有连接被关闭，相应资源被回收，连接池才能创建新的连接。</p>\n<p>另外，这种代码如果稍有不慎添加了对资源的强引用关系，就会导致循环引用关系，前面提到的MySQL JDBC就在特定模式下有这种问题，导致内存泄漏。上面的示例代码中，将State定义为static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。</p>\n<p>今天，我从语法角度分析了final、finally、finalize，并从安全、性能、垃圾收集等方面逐步深入，探讨了实践中的注意事项，希望对你有所帮助。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？也许你已经注意到了，JDK自身使用的Cleaner机制仍然是有缺陷的，你有什么更好的建议吗？</p>\n<p>请你在留言区写写你的建议，我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n<p></p>\n","comments":[{"had_liked":false,"id":12271,"user_name":"sharp","can_delete":false,"product_type":"c1","uid":1116855,"ip_address":"","ucode":"1E805CE5CFECF4","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/b7/4d7b6a79.jpg","comment_is_top":false,"comment_ctime":1528739172,"is_pvip":true,"discussion_count":17,"race_medal":0,"score":"3772510025060","product_id":100006701,"comment_content":"这三个就是卡巴斯基和巴基斯坦的关系，有个基巴关系。。。","like_count":879,"discussions":[{"author":{"id":1062070,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","nickname":"我的黄金时代","note":"","ucode":"D7825B45B372F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212962,"discussion_content":"会说话就多说点","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1585037799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1768852,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/94/8704d2b0.jpg","nickname":"spoofer","note":"","ucode":"6723F64ACC3F27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349887,"discussion_content":"正常点的面试官都不会问这么无聊的问题吧？","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1613619226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1393234,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Ko9aHAWDeYicZqElnJEoepIHLTpL8AkeicwQNsIFuZYpKAAkqkYgWmTMyqfQMSXlc5crCQWkpf8CrserhaT9mwsg/132","nickname":"CharlieWong","note":"","ucode":"0299043A439112","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351588,"discussion_content":"雷锋和雷峰塔的关系","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1614337402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1173607,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e8/67/aefd2bf2.jpg","nickname":"很久是多久","note":"","ucode":"88B7AAE876FF34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343668,"discussion_content":"你小子真他娘是个人才","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1611130418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1173607,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e8/67/aefd2bf2.jpg","nickname":"很久是多久","note":"","ucode":"88B7AAE876FF34","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383823,"discussion_content":"云龙兄也转学Java了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626247493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343668,"ip_address":""},"score":383823,"extra":""}]},{"author":{"id":2601013,"avatar":"","nickname":"小玲儿","note":"","ucode":"BB36D727B852A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371303,"discussion_content":"是为了宏观纬度考察我们的基础吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619710431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2645323,"avatar":"","nickname":"Geek_4a9319","note":"","ucode":"1739BD8C922024","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2601013,"avatar":"","nickname":"小玲儿","note":"","ucode":"BB36D727B852A8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376974,"discussion_content":"没有，这种问题都是面试问烂了的问题，问了不知道多少年了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622445232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371303,"ip_address":""},"score":376974,"extra":""}]},{"author":{"id":2116958,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJEbZZ65d5ibziaawPPL3JGCmYEKsJ8EAP70kF1pwlqvOFRGkSDMwnNzh3CibmOFEqdA25ehoBibUILvQ/132","nickname":"Geek_f8c638","note":"","ucode":"663274EDA07E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356764,"discussion_content":"笑死了\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615651774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1594292,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epCnHKhYLefpkm02lnr4SpV5T4ibDQ2e4SlibkcaGu8ZxVDlEmVib6j0TiaDTicMmjrEdiaia8Aeen3nR7dg/132","nickname":"Geek_4a677e","note":"","ucode":"ACE5BD07A232D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538344,"discussion_content":"说得好啊 ，给你点赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639400068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179622,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/e6/4b0ddfcf.jpg","nickname":"李飞","note":"","ucode":"4B23FF72AA4BA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350897,"discussion_content":"人才啊~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614068054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145168,"avatar":"https://static001.geekbang.org/account/avatar/00/11/79/50/93f85cd6.jpg","nickname":"燎沉香","note":"","ucode":"4CA5403FFF3489","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346511,"discussion_content":"六六六","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611976778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1911866,"avatar":"","nickname":"郑德士","note":"","ucode":"083EFB3E183878","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333614,"discussion_content":"真●基巴关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607579408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2169577,"avatar":"","nickname":"Geek_f9d1e9","note":"","ucode":"4336D6A3A957ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324602,"discussion_content":"哈哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605142282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1813119,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/aa/7f/d782c47a.jpg","nickname":"极客_Tenma","note":"","ucode":"F97DC3583C746C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300292,"discussion_content":"巴斯基关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598012090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217603,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/43/6e68c860.jpg","nickname":"ThinkingMan.","note":"","ucode":"722674A8BACA85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4397,"discussion_content":"基吧关系……^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565356554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232210,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cd/52/a2478536.jpg","nickname":"敲键盘的人","note":"","ucode":"59AFFFE9DA5B4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3038,"discussion_content":"可能就是因为大家都是final打头的关键字，实际上并没有任何关系...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564127500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1582144,"avatar":"https://static001.geekbang.org/account/avatar/00/18/24/40/2e637b80.jpg","nickname":"luckyCode","note":"","ucode":"DB724D2FFBE429","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1232210,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cd/52/a2478536.jpg","nickname":"敲键盘的人","note":"","ucode":"59AFFFE9DA5B4E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22479,"discussion_content":"到底是没有关系，还是基巴关系？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569643547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3038,"ip_address":""},"score":22479,"extra":""}]}]},{"had_liked":false,"id":12411,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1528808206,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"937831678734","product_id":100006701,"comment_content":"请问这篇文章中涉及的知识点是java中最重要的吗？我感觉有点剑走偏锋，这种知识了解就好了，应该有很多知识比这更重要的吧，虽说面试中可能会问，但不能以面试为中心，而要把实际应用中最有用的真正核心的东西分享出来，把它讲透彻，不追求面面俱到，也不想成为语言专家，我期望通过这个专栏可以获得java中最核心最实用特性的本质认识，希望有一种醍醐灌顶的感觉，在阅读java开源框架代码时不再困惑。我有多年的c++开发背景，希望通过这个专栏对java也有提纲契领的本质认识。","like_count":219,"discussions":[{"author":{"id":1514157,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1a/ad/faf1bf19.jpg","nickname":"windcaller","note":"","ucode":"1CA3E849805770","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4662,"discussion_content":"其实我就是为了面试才学的~~","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1565630062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102915,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d4/43/2f76e12a.jpg","nickname":"Shuo","note":"","ucode":"1E4DE5BDBE131A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326478,"discussion_content":"杠精，这门课就叫“面试精讲”","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1605604151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897251,"avatar":"","nickname":"刘haha","note":"","ucode":"91827CAC4B1831","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206691,"discussion_content":"没看这个课程的名字就叫做 面试精讲吗？","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1584428699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1434423,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","nickname":"WESTWALL","note":"","ucode":"295A030F9D3BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300194,"discussion_content":"可是这门课就叫面试精讲啊……提纲契领的话从JVM开始看，注重实用的话直接Spring全家桶，不香吗？","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1597982165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1911335,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/2a/27/461d82eb.jpg","nickname":"三岁能言","note":"","ucode":"3A6FF8C830C8B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223698,"discussion_content":"哈哈哈哈 面试真的经常问到这个问题","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1586246816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1134630,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/26/b0a0b6b5.jpg","nickname":"SuperXiong","note":"","ucode":"EA3FF62368DD56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1911335,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/2a/27/461d82eb.jpg","nickname":"三岁能言","note":"","ucode":"3A6FF8C830C8B0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362988,"discussion_content":"异常其实很考察基本功的，深可以到底层，高可以问并发","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1617086005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223698,"ip_address":""},"score":362988,"extra":""}]},{"author":{"id":2008802,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/a6/e2/465eaa08.jpg","nickname":"Jimmy Chen","note":"","ucode":"B9912576885A5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310911,"discussion_content":"我就被问过 ^-^","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602125528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2408132,"avatar":"https://static001.geekbang.org/account/avatar/00/24/be/c4/c4a8198c.jpg","nickname":"大星星和小猩猩","note":"","ucode":"16817D5C063C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389006,"discussion_content":"这不就是面试课嘛搞笑呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629087599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349599,"discussion_content":"我也觉得洗这一篇价值不大，现在很少会问到了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613363300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8233,"user_name":"zjh","can_delete":false,"product_type":"c1","uid":1125747,"ip_address":"","ucode":"3AB3862247BEF9","user_header":"","comment_is_top":false,"comment_ctime":1525999673,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"920649001017","product_id":100006701,"comment_content":"一直不懂为什么这三个经常拿来一起比较，本身就一点关系都没有啊，难道仅仅是长的像。我觉得final倒是可以和volatile一起比较下","like_count":215,"discussions":[{"author":{"id":1476984,"avatar":"https://static001.geekbang.org/account/avatar/00/16/89/78/311dbb8b.jpg","nickname":"这个名字居然都有","note":"","ucode":"8972F5BF888261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8633,"discussion_content":"volatile----一个类型修饰符，其作用是作为指令关键字，确保该条指令不会因编译器的优化而被省略\n①volatile关键字保证了不同线程对变量进行操作时的可见性，即一个线程修改了某个变量的值，新的值对其他线程是立马可见的；\n②禁止进行指令重排序\n③volatile只能保证对单词读写操作的原子性，i++这种操作不能保证原子性","likes_number":23,"is_delete":false,"is_hidden":false,"ctime":1568029166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1993703,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/6b/e7/69000f5d.jpg","nickname":"queena","note":"","ucode":"D7184D35C6B70F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263951,"discussion_content":"volatile一般跟synchronized比较更多一些吧","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1589271229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1630998,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e3/16/5ad78827.jpg","nickname":"大迷毛","note":"","ucode":"34F7860BC0A432","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40754,"discussion_content":"这两个也没得比啊  根本不是一回事","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572265537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2131215,"avatar":"https://static001.geekbang.org/account/avatar/00/20/85/0f/5cb822d6.jpg","nickname":"shadow","note":"","ucode":"64DCFAEC37EFBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301402,"discussion_content":"final本身也能保证一点可见性 只不过是初始化的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598516030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56820,"discussion_content":"套路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574517546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8143,"user_name":"石头狮子","can_delete":false,"product_type":"c1","uid":1118031,"ip_address":"","ucode":"3BABB93E552022","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/4f/c75c4889.jpg","comment_is_top":false,"comment_ctime":1525922317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"800389839373","product_id":100006701,"comment_content":"列几个 fianlly 不会被执行的情况:<br>1. try-cach 异常退出。<br>try{<br>system.exit(1)<br>}finally{<br>print(abc)<br>}<br><br>2. 无限循环<br>try{<br>  while(ture){<br>    print(abc)<br>  }<br>}finally{<br>print(abc)<br>}<br><br>3. 线程被杀死<br>当执行 try，finally 的线程被杀死时。finally 也无法执行。<br><br><br>总结<br>1，不要在 finally 中使用 return 语句。<br>2，finally 总是执行，除非程序或者线程被中断。","like_count":187},{"had_liked":false,"id":8144,"user_name":"WolvesLeader","can_delete":false,"product_type":"c1","uid":1103839,"ip_address":"","ucode":"33610E19CA2E96","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/df/fc0a6709.jpg","comment_is_top":false,"comment_ctime":1525922467,"is_pvip":false,"replies":[{"id":"2398","content":"这个因为Java inner class实际会copy一份，不是去直接使用局部变量，final可以防止出现数据一致性问题","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525965486,"ip_address":"","comment_id":8144,"utype":1}],"discussion_count":4,"race_medal":0,"score":"727375395491","product_id":100006701,"comment_content":"能不能帮我分析一哈，匿名内部累，访问局部变量时，局部变量为啥要用final来修饰吗？","like_count":170,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417595,"discussion_content":"这个因为Java inner class实际会copy一份，不是去直接使用局部变量，final可以防止出现数据一致性问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525965486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476984,"avatar":"https://static001.geekbang.org/account/avatar/00/16/89/78/311dbb8b.jpg","nickname":"这个名字居然都有","note":"","ucode":"8972F5BF888261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8637,"discussion_content":"匿名内部类，就是没有名字的内部类，只能使用一次，\n其前提是必须继承自一个父类或者接口\n其作用是，能够简化代码。比如在继承关系中，有时一个类继承自另一个类，但是只用一次，这时候还专门新建一个类就显得很多余，就可以使用匿名内部类来解决\n感兴趣的也可以参考：https://blog.csdn.net/hellocsz/article/details/81974251","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1568029608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063532,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7c/ac/482c6eb4.jpg","nickname":"老徐","note":"","ucode":"34566E3D28620C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309955,"discussion_content":"这个问题也适用于lambda表达式","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601539683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1076899,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6e/a3/bec136c0.jpg","nickname":"cxzm","note":"","ucode":"E94ACEF9D507A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69241,"discussion_content":"是JDK7之前的才有这种问题吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575275052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8350,"user_name":"★神峰★","can_delete":false,"product_type":"c1","uid":1126159,"ip_address":"","ucode":"646BC1B59426CC","user_header":"https://static001.geekbang.org/account/avatar/00/11/2f/0f/3144a61f.jpg","comment_is_top":false,"comment_ctime":1526107017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"620001397641","product_id":100006701,"comment_content":"你们都看懂了吗？我怎么什么都不知道😂 ","like_count":145},{"had_liked":false,"id":27485,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1537894168,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"375200048920","product_id":100006701,"comment_content":"前提本节听了4遍，看了不下3遍，所花的时间大于4小时，写点心得与疑问。<br>一道如此“简单”的面试题，能够引申出性能、安全、GC的问题，再扩展出一些我以前没接触过或知之甚少的知识点，如Cleaner、try-catch-resources、编写immutable对象、幻象引用等等。<br>还有一些读起来很简单的语句，消化起来却很吃力，如：你无法保证finalize什么时候执行，执行是否符合预期。使用不当会影响性能，导致程序死锁，挂起等。又如：final class可以有效的避免API使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。<br>疑问如下：<br>1、本文中自己不熟悉的知识点，需要每一种都花时间去死扣吗？<br>2、finalize使用不当会影响性能，导致程序死锁，挂起等，可否举几个通俗易懂的案例？<br>3、final class可以有效的避免API使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。可否举知名案例证实若某类不设计为final class会导致更改其原有功能，进而影响平台安全？","like_count":88,"discussions":[{"author":{"id":1621660,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","nickname":"子非鱼","note":"","ucode":"020DA0784E728C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6184,"discussion_content":"授人鱼不如授人以渔，以前我们CTO也是这样教我的。把关键点或者某种方法思想抛出来，然后自己去实现理解。虽然这是一个知识付费的时代，但是完全的让别人嚼碎了喂给自己，反而会让自己失去独立思考的能力，这是很怕的事情。我感觉，讲师已经把点抛出来了，剩下的需要自己去消化了。另一方面，不懂得很正常，我觉得多去看几遍也正常，如果老师讲的都是你会的，说明讲的没有深度，太普遍，那你也就白花钱了。你把这些点明白了，说明你离高级开发又近了一步。以上仅是我，从事两年java开发观点。仅供参考，本人肉鸡一个","likes_number":28,"is_delete":false,"is_hidden":false,"ctime":1566749767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1434423,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","nickname":"WESTWALL","note":"","ucode":"295A030F9D3BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300217,"discussion_content":"1. 不熟悉的东西不一定要“死扣”，但可以去了解个大概，等你需要用到的时候再去“死扣”。以有涯逐无涯，怠矣。\n2.3. 原则性的东西不要问为什么，照着做就好了。等你开发量足够，自然就知道原因了，也就能举出反例了。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1597990095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182406,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/c6/146113c8.jpg","nickname":"闯","note":"","ucode":"F38DCF8F840C11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1644,"discussion_content":"我估计作者是为了抛出来，让你产生好奇心，自己去查资料的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562755218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263466,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UW4tvsLn61NwNc2vlvxLJggTthc1vKTn4ibzeBic2ibiczCj9pDNMKmMFtZ1t7yAiaGFuthZNRkJiao9JC8fGxcuq1w/132","nickname":"xxmodd","note":"","ucode":"98ED0846635E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324738,"discussion_content":"关于 finalize 引起的性能问题或者案例，可以自己百度搜一下，比如：https://baijiahao.baidu.com/s?id=1655232869611610920&amp;wfr=spider&amp;for=pc","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605163356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":146136,"discussion_content":"我估计这是给毕业两年内的准备的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579599394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110662,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg","nickname":"Hank_Yan","note":"","ucode":"86899B561C502B","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282982,"discussion_content":"再写几年代码，你就知道栏主为啥这么讲了。很多东西，踩过坑才会发现原来之前都了解过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592134988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45955,"user_name":"Loong","can_delete":false,"product_type":"c1","uid":1170296,"ip_address":"","ucode":"3B96FC58C9612C","user_header":"","comment_is_top":false,"comment_ctime":1543825026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"263536830082","product_id":100006701,"comment_content":"final、finally、finalize<br><br>1. final<br>\t修饰类：不可被继承<br>\t修饰方法：不可重写<br>\t修饰变量：不可修改，只能约束引用不可以被再次赋值。匿名内部类访问局部变量时需要使用 final，因为 Innerclass 实际会 copy 一份局部变量，final 可以防止出现数据一致性问题<br><br>2. finally：Java 保证重点代码一定要被执行的机制，try - finally，除非在 finally 前执行了 System.exit（1）、try 中死循环、线程被杀死<br>\t<br>3. finalize：基础类 Object 的一个方法，保证对象在被垃圾收集前完成特定的资源回收。由于 finalize 执行时间不确定且可能造成程序死锁、拖慢垃圾收集等问题，Java 9 中将改方法废弃<br>\t\t优化：使用 Cleaner 配合幻想引用","like_count":62},{"had_liked":false,"id":8089,"user_name":"皮卡皮卡丘","can_delete":false,"product_type":"c1","uid":1106062,"ip_address":"","ucode":"6764F465FF975B","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/8e/0e4bc2a9.jpg","comment_is_top":false,"comment_ctime":1525911363,"is_pvip":false,"replies":[{"id":"2414","content":"内部类如果不是static，它本身对外面那个类有引用关系，这一点其实从构造阶段就能看出来，你可以写段代码试试；有强引用就是strong reachable状态","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526009721,"ip_address":"","comment_id":8089,"utype":1}],"discussion_count":1,"race_medal":0,"score":"199094406979","product_id":100006701,"comment_content":"“将 State 定义为 static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。”这个该怎么理解呢？","like_count":47,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417575,"discussion_content":"内部类如果不是static，它本身对外面那个类有引用关系，这一点其实从构造阶段就能看出来，你可以写段代码试试；有强引用就是strong reachable状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526009721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8095,"user_name":"有渔@蔡","can_delete":false,"product_type":"c1","uid":1099829,"ip_address":"","ucode":"4AB669229892C8","user_header":"","comment_is_top":false,"comment_ctime":1525912543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"143259833311","product_id":100006701,"comment_content":"1.你说那异常被生吞，是指没写e.print...语句吧？另外我有个疑惑：super.clear()为什么写在exception里，理论上super方法写第一行，或finally里。2.在一个对象的生命周期里，其finalize方法应该只会被调用1次。3.强软弱虚引用大家都知道，这虚幻引用相比较有什么特别的吗？请再深入点。4.final是不是都在编译后确定位置？比如final List这样的，内存布局是怎样的？谢谢","like_count":34},{"had_liked":false,"id":8456,"user_name":"🎵Children乏","can_delete":false,"product_type":"c1","uid":1117810,"ip_address":"","ucode":"FA7E935A33154E","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/72/2a92a4c1.jpg","comment_is_top":false,"comment_ctime":1526229126,"is_pvip":false,"replies":[{"id":"2510","content":"谢谢反馈","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526273646,"ip_address":"","comment_id":8456,"utype":1}],"discussion_count":1,"race_medal":0,"score":"96015509638","product_id":100006701,"comment_content":"用final修饰的class，这可以有效避免 API 使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。这个地方真的很需要个例子去帮助理解。比如大家都知道String类是被final修饰不可被继承，但假如没有被final修饰，很好奇会出现什么样不安全的后果。","like_count":23,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417729,"discussion_content":"谢谢反馈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526273646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48979,"user_name":"Julian","can_delete":false,"product_type":"c1","uid":1331563,"ip_address":"","ucode":"451287999E982F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcqPrJEUz4PWI9fNOCFwPQ9SYZ9Sk7jcfLBl9IZSa0eCCibqKOO3FoaPZEB6ZiaWO7S1fTJ7nA3dNw/132","comment_is_top":false,"comment_ctime":1544584878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74559028910","product_id":100006701,"comment_content":"第3讲 | 谈谈final、finally、 finalize有什么不同的学习总结：<br>一、final：适合用来在语义方面标识当前的方法、变量、类不可以更改，适合封装一些代码，让用的人知道这些不要随意更改。final标识的变量不等于不可变，对于变量而言这个变量只是不能够在赋值，但是可以做任何增删改查操作。所以从这方面来讲，final在高并发下面的数据一致性起来积极作用，对性能比较好。要想写一个不可变的对象，首先需要对象的类和成员都是private和final；其次对象的赋值不要直接赋值，而是采用深拷贝；然后对象不要随意实现setter方法；在获取当前对象内容或者状态时候要遵守copy-on-write 原则，创建私有的 copy。<br><br>二、深拷贝与浅拷贝；其实这两个概念的区别就是当在给一个变量赋值时候是否直接使用这个值的内存地址；例如，基础类型都是值传递，所以浅拷贝过来的对象赋值后不会影响之前被拷贝的对象。但是对于引用类型的变量，在拷贝的时候就要考虑了，如果你要使新的对象的赋值不会影响之前被拷贝的对象，就要用深拷贝，否则就是copy的内存地址而已。一个类实现拷贝的功能很简单，有两种方式；要么实现Clone~接口，然后在clone方法里面进行拷贝；要是实现序列化，先把对象写到输入流里面，然后在读出来对象，这样就是一个新的对象了。<br><br>三、finally：就是在一些资源处理关闭时候用到，对于try cath 最好即用即关；<br><br>四、finalize：就是java虚拟机在实现gc时候调用的方法，理论上是进行内存回收等操作的地方。但是实际上这个方法调用时机并不固定，可能在处理不当导致程序异常。并且finalize源码实现使用了try cath 但是并没有抛出异常，而是生吞。所以你要是在这里面处理逻辑，你都不知道程序到底哪里出了问题。得出结论就是要放弃这个方法的实现。","like_count":18},{"had_liked":false,"id":8154,"user_name":"Pantheon","can_delete":false,"product_type":"c1","uid":1110487,"ip_address":"","ucode":"D1FF4C18CE3475","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/d7/a52e390d.jpg","comment_is_top":false,"comment_ctime":1525927838,"is_pvip":false,"replies":[{"id":"2391","content":"setAccessible是“流氓”，不问题出在定义为基本数据类型，会被当作constant，可以反编译看看","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525962295,"ip_address":"","comment_id":8154,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74540371870","product_id":100006701,"comment_content":"杨老师，关于final不能修改我想请教下，代码如下，class util {<br>    public final Integer info = 123;<br>}<br><br>@Test<br>public void test() throws NoSuchFieldException, IllegalAccessException {<br>    util util = new util();<br>    Field field = util.getClass().getDeclaredField(&quot;info&quot;);<br>    field.setAccessible(true);<br>    field.set(util,789);<br>    System.out.println(field.get(util));<br>    System.out.println(util.info);<br>}<br>这里final修饰的被改了，如果不加accessible这句会报错，刚刚试了几个，似乎是基本数据类型改不了，封装类型都能改，请杨老师解答下我的疑惑，感谢。","like_count":18,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417603,"discussion_content":"setAccessible是“流氓”，不问题出在定义为基本数据类型，会被当作constant，可以反编译看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525962295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178888,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","nickname":"小鳄鱼","note":"","ucode":"9C30CAFB41A263","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580323,"discussion_content":"联系一下，值传递跟引用传递。作为方法入参，基础数据类型跟引用数据类型的区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658104494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8086,"user_name":"小哥。","can_delete":false,"product_type":"c1","uid":1124748,"ip_address":"","ucode":"0FAFA194204AD4","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/8c/fde60fcf.jpg","comment_is_top":false,"comment_ctime":1525911036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61655453180","product_id":100006701,"comment_content":"copy-on-write 原则，学习了","like_count":14},{"had_liked":false,"id":8094,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1525912398,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"57360487246","product_id":100006701,"comment_content":"见过一些写法是将对象手动赋值为null来让GC更快的回收，不过能起多少作用就不知道了。关于JVM中那几种引用了解不多，平时可以怎么使用呢？","like_count":13,"discussions":[{"author":{"id":2408132,"avatar":"https://static001.geekbang.org/account/avatar/00/24/be/c4/c4a8198c.jpg","nickname":"大星星和小猩猩","note":"","ucode":"16817D5C063C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389024,"discussion_content":"这样写是引用计数的思想吧？可是垃圾回收的算法不是用根搜索算法么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629096210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2074426,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/a7/3a/0b373e97.jpg","nickname":"魔童","note":"","ucode":"C98533EF92D68E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303754,"discussion_content":"99.9%情况下，这种写法没卵用！JVM还是很聪明的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599371919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2281337,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kaic5kfriczX1cBQUQgARHl7PScxic6RRbmaVYJDQnaicBTPMHFFxicAJvsniaGv9BzhubuAmuplUjt1glMJytmQgyNA/132","nickname":"Geek_f6010d","note":"","ucode":"FD75A485630E78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2074426,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/a7/3a/0b373e97.jpg","nickname":"魔童","note":"","ucode":"C98533EF92D68E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322416,"discussion_content":"不是吧 集合还有并发包的源码里好多地方是这么用的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604740340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303754,"ip_address":""},"score":322416,"extra":""}]}]},{"had_liked":false,"id":8418,"user_name":"ls","can_delete":false,"product_type":"c1","uid":1007293,"ip_address":"","ucode":"6C14A1D24DDC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/bd/e28f8ce5.jpg","comment_is_top":false,"comment_ctime":1526200211,"is_pvip":false,"replies":[{"id":"2505","content":"是的，很多资源都是需要使用本地方式获取和释放","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526272127,"ip_address":"","comment_id":8418,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53065807763","product_id":100006701,"comment_content":"Java中有说：finalize 有一种用途：在 Java 中调用非 Java 代码，在非 Java 代码中若调用了C的 malloc 来分配内存，如果不调用 C 的free 函数，会导致内存泄露。所以需要在 finalize 中调用它。<br><br>面试中会有问：为什么 String 会设计成不可变？想听听老师的解释","like_count":13,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417707,"discussion_content":"是的，很多资源都是需要使用本地方式获取和释放","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526272127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19938,"user_name":"ZGX","can_delete":false,"product_type":"c1","uid":1207776,"ip_address":"","ucode":"D3E05C3F992D57","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/e0/ea4d49db.jpg","comment_is_top":false,"comment_ctime":1534171092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40188876756","product_id":100006701,"comment_content":"想听听老师怎么回答 String为什么被设计成final这个问题。经常被问到 但又感觉答的不理想，希望老师看到可以解答下。","like_count":10},{"had_liked":false,"id":14399,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1530373123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35890111491","product_id":100006701,"comment_content":"JDK 自身使用的 Cleaner 机制仍然是有缺陷的，你有什么更好的建议吗？<br><br>1，临时对象，使用完毕后，赋值为null,可以加快对象的回收<br>2，公用资源对象，比如数据库连接，使用连接池<br>3，native调用资源的释放，比如一个进程初始化调用一次，退出调用一次，这类场景可以考虑使用cleaner<br>4，对尽量try-finally中完成资源的释放，即使用完毕就释放，最小化的使用，下次使用在申请。<br>5，可以使用钩子进行程序的正常退出清理操作。<br><br>此为我个人的一点小心得，欢迎老师指正，谢谢","like_count":8},{"had_liked":false,"id":8299,"user_name":"Do","can_delete":false,"product_type":"c1","uid":1121405,"ip_address":"","ucode":"B1B3FD8FF41BA7","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/7d/ecbf84a8.jpg","comment_is_top":false,"comment_ctime":1526058854,"is_pvip":false,"replies":[{"id":"2447","content":"会有","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526102155,"ip_address":"","comment_id":8299,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31590829926","product_id":100006701,"comment_content":"final修饰变量参数的时候，其实理解为内存地址的绑定，这样理解是不是更直观，基本类型指向栈中，引用类型指向堆中。老师后期文章能不能说下java堆栈的区别，还有变量局部变量的生命周期，最好能附上图，加深理解。","like_count":7,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417659,"discussion_content":"会有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526102155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8180,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1525954379,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"31590725451","product_id":100006701,"comment_content":"1定义不可变对象类，当构造函数传入可变对象引用时、当getter函数返回可变对象引用时，容易掉坑。<br>2 在不可变对象类的构造函数中，如果传入值包括了可变对象，则clone先。<br>3 从不可变对象类的getter函数返回前，如果返回值为可变对象，则clone先。<br>4 Java默认的clone方法执行浅拷贝，对于数组、对象引用只是拷贝地址。浅拷贝在业务实现中可能是一个坑，需要多加注意。<br>5 如果步骤2、3中的浅拷贝无法满足不可变对象要求，请实现“深拷贝”。<br>","like_count":7},{"had_liked":false,"id":48981,"user_name":"木偶人King","can_delete":false,"product_type":"c1","uid":1028805,"ip_address":"","ucode":"0BDCA51E6F0B76","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b2/c5/6ae0be56.jpg","comment_is_top":false,"comment_ctime":1544585062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27314388838","product_id":100006701,"comment_content":"List.of()  是Java 9 新特性  .","like_count":6},{"had_liked":false,"id":8136,"user_name":"echo＿陈","can_delete":false,"product_type":"c1","uid":1080794,"ip_address":"","ucode":"EFAEADA8A05906","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/da/780f149e.jpg","comment_is_top":false,"comment_ctime":1525917957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27295721733","product_id":100006701,"comment_content":"回答上面一个人的问题。<br>被final修饰的变量不可变。如果初始化不赋值，后续赋值，就是从null变成你的赋值，违反不可变","like_count":6},{"had_liked":false,"id":8265,"user_name":"张勇","can_delete":false,"product_type":"c1","uid":1120890,"ip_address":"","ucode":"F0C1A539442510","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/7a/5ffb9d63.jpg","comment_is_top":false,"comment_ctime":1526011574,"is_pvip":false,"replies":[{"id":"2423","content":"文中介绍了，它其实实现是会copy一份，final可以避免一致性问题","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526014719,"ip_address":"","comment_id":8265,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23000848054","product_id":100006701,"comment_content":"匿名内部类为什么访问外部类局部变量必须是final的？private Animator createAnimatorView(final View view, final int position) {\r<br>    MyAnimator animator = new MyAnimator();\r<br>    animator.addListener(new AnimatorListener() {\r<br>        @Override\r<br>        public void onAnimationEnd(Animator arg0) {\r<br>            Log.d(TAG, &quot;position=&quot; + position); \r<br>        }\r<br>    });\r<br>    return animator;\r<br>}","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417648,"discussion_content":"文中介绍了，它其实实现是会copy一份，final可以避免一致性问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526014719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53214,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1545616600,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18725485784","product_id":100006701,"comment_content":"<br>ls<br><br><br>7<br>Java中有说：finalize 有一种用途：在 Java 中调用非 Java 代码，在非 Java 代码中若调用了C的 malloc 来分配内存，如果不调用 C 的free 函数，会导致内存泄露。所以需要在 finalize 中调用它。<br><br>面试中会有问：为什么 String 会设计成不可变？想听听老师的解释<br>2018-05-13<br>作者回复<br>是的，很多资源都是需要使用本地方式获取和释放<br><br>我的感觉：看到好几个类似这样的疑问. 但是老师并没有确切回复提问同学的疑惑.<br><br>看了前几章的感想： <br>  感觉干货不是很多嘛 总结性的占大多数.<br><br>可能就像老师说的吧，从面试的角度来说. 而不是剖析细节..","like_count":4},{"had_liked":false,"id":8922,"user_name":"jeff","can_delete":false,"product_type":"c1","uid":1026894,"ip_address":"","ucode":"68456DD035BDF4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/4e/82e9657c.jpg","comment_is_top":false,"comment_ctime":1526521382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18706390566","product_id":100006701,"comment_content":"回答张勇的问题<br>注意你的final 值得作用域 生命周期<br>","like_count":4},{"had_liked":false,"id":8165,"user_name":"说重点丶","can_delete":false,"product_type":"c1","uid":1113940,"ip_address":"","ucode":"0C767E398D07B5","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/54/5e48b2b7.jpg","comment_is_top":false,"comment_ctime":1525935824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18705805008","product_id":100006701,"comment_content":"常被问，string类为什么用final修饰","like_count":4},{"had_liked":false,"id":8103,"user_name":"loveluckystar","can_delete":false,"product_type":"c1","uid":1097877,"ip_address":"","ucode":"370C38AF0E9A43","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/95/6f0aad03.jpg","comment_is_top":false,"comment_ctime":1525912902,"is_pvip":false,"replies":[{"id":"2358","content":"对，有些特别情况需要额外处理，毕竟无法保证编程都按规范来","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525914822,"ip_address":"","comment_id":8103,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18705782086","product_id":100006701,"comment_content":"个人理解，finalize本身就是为了提供类似c或c++析构函数产生的，由于java中gc本身就是自动进行的，是不希望被干扰的，(就像System.gc()，并不一定起作用)所以与其费心研究如何使用这个，不如老老实实在finally中把该做的事情做了来的实惠。","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417581,"discussion_content":"对，有些特别情况需要额外处理，毕竟无法保证编程都按规范来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525914822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22350,"user_name":"zt1106","can_delete":false,"product_type":"c1","uid":1120246,"ip_address":"","ucode":"8973D30EF9DE27","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/f6/df7a9823.jpg","comment_is_top":false,"comment_ctime":1535622487,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14420524375","product_id":100006701,"comment_content":"&#47;**<br> * Cleaner 官方文档代码示例<br> * &lt;p&gt;<br> * Cleaner 是一个用于关闭资源的类，功能类似finalize方法<br> * Cleaner 有自己的线程，在所有清理操作完成后，自己会被GC<br> * 清理中抛出的异常会被忽略<br> * &lt;p&gt;<br> * 清理方法（一个Runnable）只会运行一次。会在两种情况下运行：<br> * 1. 注册的Object处于幻象引用状态<br> * 2. 显式调用 clean 方法<br> * &lt;p&gt;<br> * 通过幻象引用和引用队列实现<br> * &lt;p&gt;<br> * 可以注册多个对象，通常被定义为静态（减少线程数量）<br> * &lt;p&gt;<br> * 注册对象后返回的Cleanable对象用于显式调用 clean 方法<br> * &lt;p&gt;<br> * 实现清理行为的对象（下面的state），不能拥有被清理对象的引用<br> * 如果将下面的State类改为非静态，第二个 CleaningExample 将不会被 clean，<br> * 因为非静态内部类持有外部对象的引用，外部对象无法进入幻象引用状态<br> * &lt;p&gt;<br> *&#47;<br>public class CleaningExample implements AutoCloseable {<br><br>    public static void main(String[] args) {<br>        try {<br>            &#47;&#47; 使用JDK7的try with Resources显式调用clean方法<br>            try (CleaningExample ignored = new CleaningExample()) {<br>                throw new RuntimeException();<br>            }<br>        } catch (RuntimeException ignored) {<br>        }<br><br>        &#47;&#47; 通过GC调用clean方法<br>        new CleaningExample();<br>        System.gc();<br>    }<br><br>    &#47;&#47; 以下是Cleaner文档中的代码示例<br>    private static final Cleaner CLEANER = Cleaner.create();<br><br>    &#47;&#47; 如果是非静态内部类，则会出错<br>    static class State implements Runnable {<br>        State() {<br>        }<br><br>        @Override<br>        public void run() {<br>            System.out.println(&quot;Cleaning called&quot;);<br>        }<br>    }<br><br>    private final State state;<br>    private final Cleaner.Cleanable cleanable;<br><br>    public CleaningExample() {<br>        this.state = new State();<br>        this.cleanable = CLEANER.register(this, state);<br>    }<br><br>    @Override<br>    public void close() {<br>        cleanable.clean();<br>    }<br><br>}","like_count":3},{"had_liked":false,"id":19276,"user_name":"江南小帅","can_delete":false,"product_type":"c1","uid":1195049,"ip_address":"","ucode":"3519F8EA938022","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/29/29d923ce.jpg","comment_is_top":false,"comment_ctime":1533743922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14418645810","product_id":100006701,"comment_content":"我感觉看留言很有意思啊","like_count":3},{"had_liked":false,"id":15553,"user_name":"梅丹隆","can_delete":false,"product_type":"c1","uid":1173209,"ip_address":"","ucode":"9F0F29185CF66E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e6/d9/da4a4691.jpg","comment_is_top":false,"comment_ctime":1531285121,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14416187009","product_id":100006701,"comment_content":"形容词，副词和名词","like_count":3,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383858,"discussion_content":"您高考英语150吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626256542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10167,"user_name":"徐金铎","can_delete":false,"product_type":"c1","uid":1080462,"ip_address":"","ucode":"E13FD19FD27869","user_header":"https://static001.geekbang.org/account/avatar/00/10/7c/8e/73581062.jpg","comment_is_top":false,"comment_ctime":1527319990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14412221878","product_id":100006701,"comment_content":"Final关键字，还有禁止代码前编译器重排序的作用，可以用做构造溢出的解决方案。","like_count":3},{"had_liked":false,"id":8190,"user_name":"小绵羊拉拉","can_delete":false,"product_type":"c1","uid":1123168,"ip_address":"","ucode":"E41D1C66AE6CAF","user_header":"","comment_is_top":false,"comment_ctime":1525960345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14410862233","product_id":100006701,"comment_content":"首先 这篇文章比上一讲明显感觉到由浅入深 很不错 有个问题请教一下finalize方法是用来回收对外内存是不是可以这么理解 类似于本地方法申请的能源 new出来的对象实现了这个方法当垃圾回收的时候会将对象放在fqueue等待被执行 不过是异步不知道啥时候被执行 可能被执行的时候对象已经置空导致不安全 可以这么理解吗 新的jdk引入的clear方法 能完全取代虚拟机中finalize方法吗","like_count":3},{"had_liked":false,"id":8218,"user_name":"老胡","can_delete":false,"product_type":"c1","uid":1101923,"ip_address":"","ucode":"D0DF088B7BD29A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/63/83236814.jpg","comment_is_top":false,"comment_ctime":1525978961,"is_pvip":false,"replies":[{"id":"2419","content":"未必有这么可怕，比finalize有数量级的提高，spring这个不错，但不能解决所有场景","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526013958,"ip_address":"","comment_id":8218,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10115913553","product_id":100006701,"comment_content":"Cleaner机制会对jvm回收造成负担，因为gc回收的时候需要检测这个对象十分是Cleaner，然后处理。如果处理过长，十分影响gc的效率。好点方案，容器管理对象，比如spring的sopce，或者对象单利等等，gc负担是一个致命问题，所以Cleaner谨慎使用，甚至应该禁止","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417637,"discussion_content":"未必有这么可怕，比finalize有数量级的提高，spring这个不错，但不能解决所有场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526013958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8187,"user_name":"增煌","can_delete":false,"product_type":"c1","uid":1100199,"ip_address":"","ucode":"8232937B4C70E1","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/a7/5246d6a1.jpg","comment_is_top":false,"comment_ctime":1525958386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10115892978","product_id":100006701,"comment_content":"final修饰变量表示不能被修改应该是不能被赋值更合适一点吧？对基本类型来说就是不能修改，对string和object只是引用不能修改，引用的对象还是可变的。","like_count":2},{"had_liked":false,"id":8141,"user_name":"Colingo","can_delete":false,"product_type":"c1","uid":1022116,"ip_address":"","ucode":"3DC43E2F2327B2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/a4/c22f3028.jpg","comment_is_top":false,"comment_ctime":1525921128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10115855720","product_id":100006701,"comment_content":"finally 里面的打印为什么不会被调用？","like_count":2},{"had_liked":false,"id":185105,"user_name":"张镇鸿","can_delete":false,"product_type":"c1","uid":1889764,"ip_address":"","ucode":"7648CDED60E718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bca6GH6xIs5DsH4RibBEQh1pZSTkUT4bFP8fkLBC4Jkm6g8VDcOrySNg0icum9pEuUW259vP8Yv7icCW63Ff1J1ag/132","comment_is_top":false,"comment_ctime":1583484354,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5878451650","product_id":100006701,"comment_content":"4、final、finally、finalize有什么不同？<br>    记录：System.exit(1)比较特殊，jvm都被关闭了，因此finally的内容一定不会被关闭  。资源的回收通过try with resources即可，以及java自身的gc机制  <br>        final不等于不可变immutable，比如说Arrays.asLis()，或者List.fo()产生的是不可变的list，无法add，而使用final 修饰的一个list，虽然名称引用不能引用别的，但是引用的对象的内容是可以改变的，比如可以往list中加入东西<br>        不可变的情况是需要的，比如说class以final声明、成员变量设置为private\\final并不实现setter,构造对象通过深拷贝。<br>        可以了解一下copy on write原则，有一个list是copy on wrteList，适合读多写少的场景，写的时候会复制，并发安全的ArrayList。改变lsit内容的地方用了reentrantlock加锁操作，有一定开销，但是线程安全。<br>        资源显式去释放，close，unlock，或者使用资源池，比如线程池<br>        finalize已经被取消或者是不推荐，取而代之的是cleaner机制。finalize 不可预测并有可能拖慢垃圾回收，导致都系爱那个堆积从而导致OOM。<br>    Cleaner这个机制是垃圾回收的兜底，可以了解。（幻象引用）<br>        <br>    阅读：一个有趣的问题，匿名内部类如果使用了局部变量，局部变量应该用final修饰，匿名内部类会copy一份局部变量，要避免数据一致性问题。<br>        首先科普一个闭包的概念，内部的类或者方法需要调用外部的一个变量，然后该外部变量和内部的类都在外部的类里，这就让内部类形成了一个闭包。对于闭包的情况，如果内部类需要访问外部的元素，分为外部函数和外部类。外部类的变量是外部类的全局变量，内部类通过外部类的this来获取，是引用，因此不需要定义为final。但是如果在一个外部类的函数中实例化内部类，而该内部类访问了函数的变量，此时这个变量是外部类的局部变量，需要将局部变量定义为final。为什么？因为我们知道对于一个方法是存在生命周期的，当这个函数实例完内部类后，该函数就会从线程的方法栈弹出，局部变量也会被清除，但是内部类的实例依然存在，这时候起依赖的外部类的函数的变量消失，这就会有异常，因此内部类实际上是会将局部变量复制一份存储到内部类中。这就会导致数据一致性问题，为了避免这个问题，就规定局部变量必须为final，不变。这个问题很有意思，可以看这个： https:&#47;&#47;www.zhihu.com&#47;question&#47;21395848<br>        这是JDK7之前的问题，现在不需要这样子做了，已经满足了。<br>        匿名内部类只能使用一次，且要继承一个父类或者接口，简化代码。<br>        构建一个不可变的对象，对象的类和成员都是private 和final，对象的赋值通过深拷贝（new 一个对象是通过clone来获得）","like_count":1,"discussions":[{"author":{"id":1071945,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/49/90dbe5e5.jpg","nickname":"MOSAIC","note":"","ucode":"6217B689FFC36B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289730,"discussion_content":"clone 默认为浅拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594192782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112517,"user_name":"TANMIYOO","can_delete":false,"product_type":"c1","uid":1375256,"ip_address":"","ucode":"BC3556131D4D61","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/18/8e69f7cf.jpg","comment_is_top":false,"comment_ctime":1562750260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5857717556","product_id":100006701,"comment_content":"finally：使用于try-finally，包裹的是必定执行的代码，一般用于回收资源，unlock，不会执行的情况是，在try代码块中System.exit(1);<br>final：修饰符，修饰类时不可被继承，修饰方法时不可被重写，修饰变量时不可被修改；final 修饰引用类型时，只能防止引用被修改，但不能防止对象中的属性被修改，其概念区别于immutable。若要自定义immutable类要做到：Class 用final修饰；属性用private和final修饰；内部属性赋值时，使用深拷贝，不提供setter方法；若要提供getter方法，遵循copy-on-write原则，创建私有的copy<br>finalize：是Object的方法，用于在垃圾回收之前关闭特定资源，但这刚好成为快速垃圾回收的阻碍，会造成OOM的窘境，所以在java 9 中已被声明为deprecated。程序员不要指望finalize进行资源回收，要在代码中显式的回收资源或者使用资源池重复使用资源；finalize的替代方案--Cleaner，基于幻象引用的资源回收，吧啦吧啦，没看懂就不做总结了<br>吐槽一下评论，学习是取自己所需，而不是关注无关痛痒的内容，不讲这篇文章拓宽了多大的视野，但就学到一个知识点，都是收获","like_count":1},{"had_liked":false,"id":24574,"user_name":"LAMBO","can_delete":false,"product_type":"c1","uid":1214041,"ip_address":"","ucode":"10EDE0FC134FA8","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/59/e8f58a2a.jpg","comment_is_top":false,"comment_ctime":1537148986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5832116282","product_id":100006701,"comment_content":"前面部分看得还津津有味，后面讲幻象引用看得有点懵。后续章节有关于幻象引用相关的讲解吗？","like_count":1},{"had_liked":false,"id":24139,"user_name":"Dee1024","can_delete":false,"product_type":"c1","uid":1158554,"ip_address":"","ucode":"343D9A0F19602E","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/9a/e9d32750.jpg","comment_is_top":false,"comment_ctime":1536820366,"is_pvip":false,"replies":[{"id":"9190","content":"同意","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1537312499,"ip_address":"","comment_id":24139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5831787662","product_id":100006701,"comment_content":"Cleaner机制没有Finalizer机制那样危险，但仍然是不可预测，也是运行缓慢，同样不能保证他们能够及时执行。所以，尽量避免使用。<br>正确的关闭资源的打开方式应该是，使用JDK1.7或者以上版本，里面提供的 AutoCloseable 接口，实现该接口以达目的","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423857,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537312499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21803,"user_name":"SillyBear","can_delete":false,"product_type":"c1","uid":1083654,"ip_address":"","ucode":"5A2F907FBFF3F3","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/06/e8292891.jpg","comment_is_top":false,"comment_ctime":1535345164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5830312460","product_id":100006701,"comment_content":"copy-on-write 原则","like_count":1},{"had_liked":false,"id":16848,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1532253059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5827220355","product_id":100006701,"comment_content":"课后习题，我一般是用完不用的变量，将其设置为Null或者调用响应clear方法 释放引用，让jvm可以进行回收","like_count":1},{"had_liked":false,"id":9963,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1527204588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5822171884","product_id":100006701,"comment_content":"1。final修饰的类，不可被继承，修饰的方法不可被重写，修饰的变量不可多次赋值。通过final能够得到性能上的优化，但是不明显，如果大量使用可能会干扰代码，不能表达出本来具有的含义。故不使用。匿名内部类，访问局部变量要求传入的参数，必须是final是要保证数据一致性问题。<br>2。finally。代码中总是会执行的代码段。除了退出虚拟机外。<br>3。finalize。在虚拟机回收改对象前进行调用。此种方式不可取。因为java虚拟机不知道在什么时候才对对象进行回收。","like_count":1},{"had_liked":false,"id":8849,"user_name":"haoz","can_delete":false,"product_type":"c1","uid":1127301,"ip_address":"","ucode":"10EB0F64A7CC8E","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/85/bbdcf614.jpg","comment_is_top":false,"comment_ctime":1526481975,"is_pvip":false,"replies":[{"id":"2638","content":"Java 9引入的，可能忘了介绍；<br>8已经4、5年了，马上9月份发布jdk 11，下一个长期支持版本，建议开始实验新的了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526517074,"ip_address":"","comment_id":8849,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5821449271","product_id":100006701,"comment_content":"List.of()方法我的jdk1.8中没有 网上也没有相关资料。是不是老师写错了呢?还望老师多多指教！","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417866,"discussion_content":"Java 9引入的，可能忘了介绍；\n8已经4、5年了，马上9月份发布jdk 11，下一个长期支持版本，建议开始实验新的了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526517074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8837,"user_name":"微笑的向日葵","can_delete":false,"product_type":"c1","uid":1099151,"ip_address":"","ucode":"90659BD4413DF1","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/8f/80443115.jpg","comment_is_top":false,"comment_ctime":1526476104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821443400","product_id":100006701,"comment_content":"一般来说在框架中做资源创建和回收，都是通过aop","like_count":1},{"had_liked":false,"id":8615,"user_name":"程序猿的小浣熊","can_delete":false,"product_type":"c1","uid":1118125,"ip_address":"","ucode":"7D26B2F5C4379C","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/ad/19cc513d.jpg","comment_is_top":false,"comment_ctime":1526347230,"is_pvip":false,"replies":[{"id":"2587","content":"用词也许有点歧义，就是只暴露copy","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526370822,"ip_address":"","comment_id":8615,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5821314526","product_id":100006701,"comment_content":"关于copy_on_write实现getter方法可以有例子吗？因为我理解的该原则是懒修改策略，但是不变类不应该不做任何修改么？希望可以解答一下。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417794,"discussion_content":"用词也许有点歧义，就是只暴露copy","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526370822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8219,"user_name":"老胡","can_delete":false,"product_type":"c1","uid":1101923,"ip_address":"","ucode":"D0DF088B7BD29A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/63/83236814.jpg","comment_is_top":false,"comment_ctime":1525979118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5820946414","product_id":100006701,"comment_content":"不可变。最基本是行为不可变，不提供可变的操作。变量私有化，没有增加，修改等方法，final只是保证指针不可变，无法保证内容不可变。","like_count":1},{"had_liked":false,"id":8151,"user_name":"FF","can_delete":false,"product_type":"c1","uid":1001615,"ip_address":"","ucode":"26349F32B406D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/8f/7ecd4eed.jpg","comment_is_top":false,"comment_ctime":1525927416,"is_pvip":false,"replies":[{"id":"2389","content":"IDE有自己的编译实现，如果try里没有显式throw，只是catch那么写，应该是合规的，猜测是idea的bug，你用什么版本？","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525960483,"ip_address":"","comment_id":8151,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5820894712","product_id":100006701,"comment_content":"请教杨老师一个异常处理的问题，我们使用 eclipse 的同学通常这样处理异常：<br>try{<br>。。。。<br>}catch(Exception ex){<br>throw ex;  &#47;&#47;这里抛出异常，<br>}<br><br>但方法并没有声明 throws Exception，而  eclipse  通常也能编译执行，这不是违反了基本语法了吗，为何 eclipse 里面没有任何问题的？<br><br>这是什么原因？但这样的代码在使用 IntellIj  IDEA  的同学那里是完全没法编译执行的，直接就提示语法错误了<br><br>很困惑，网上没找到相关答案，望解答，感谢！","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417600,"discussion_content":"IDE有自己的编译实现，如果try里没有显式throw，只是catch那么写，应该是合规的，猜测是idea的bug，你用什么版本？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525960483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8133,"user_name":"yao","can_delete":false,"product_type":"c1","uid":1106783,"ip_address":"","ucode":"5F8AEDB95B3A01","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/5f/af1b2642.jpg","comment_is_top":false,"comment_ctime":1525916435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5820883731","product_id":100006701,"comment_content":"@mongo  另外可以起到语义上的作用","like_count":1},{"had_liked":false,"id":8132,"user_name":"不吃老鼠的猫","can_delete":false,"product_type":"c1","uid":1126984,"ip_address":"","ucode":"0D87C9F66F57A8","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/48/933ba354.jpg","comment_is_top":false,"comment_ctime":1525916430,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5820883726","product_id":100006701,"comment_content":"我有个这样一个场景，在service方法里，处理自己的逻辑，因为是调用外部接口，所以可能会报错，那么我用try catch补获异常，返回上层结果，但是问题来了，我有个log表，要保存每次请求，响应数据，我补获到外部异常后，处理了下异常，又抛出去，现在我的处理逻辑是在finally里，来保存所有请求和响应的数据，但觉得有点鸡肋，finally理论上不应该涉及到逻辑代码，求老师指正？","like_count":1,"discussions":[{"author":{"id":1101473,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/a1/76f4e230.jpg","nickname":"toyz","note":"","ucode":"47209F04FF8982","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23079,"discussion_content":"我教你个办法，用AOP+ThreadLocal，在Before阶段记录入参放到ThreadLocal中，AfterThrowing和AfterReturning分别记录异常和正常的出参，最后记录，亲测有效","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1569752589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8109,"user_name":"mongo","can_delete":false,"product_type":"c1","uid":1113124,"ip_address":"","ucode":"F39FE783793A17","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/24/7d43d807.jpg","comment_is_top":false,"comment_ctime":1525913195,"is_pvip":false,"replies":[{"id":"2359","content":"引用不希望被修改的时候，仍然有一定保护作用","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525914912,"ip_address":"","comment_id":8109,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5820880491","product_id":100006701,"comment_content":"final修饰引用类型的话，引用值不能被修改。但是引用值指向的内容可以被修改，这样看来修饰引用类型并不是线程安全的。什么场景下会使用final修饰引用类型呢？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417584,"discussion_content":"引用不希望被修改的时候，仍然有一定保护作用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525914912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8090,"user_name":"cxzm","can_delete":false,"product_type":"c1","uid":1076899,"ip_address":"","ucode":"E94ACEF9D507A6","user_header":"https://static001.geekbang.org/account/avatar/00/10/6e/a3/bec136c0.jpg","comment_is_top":false,"comment_ctime":1525911436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5820878732","product_id":100006701,"comment_content":"请问为什么被final修饰的变量需要显示赋值","like_count":1},{"had_liked":false,"id":315731,"user_name":"早睡早起","can_delete":false,"product_type":"c1","uid":1306624,"ip_address":"","ucode":"8E05506604586A","user_header":"https://static001.geekbang.org/account/avatar/00/13/f0/00/4fe369c2.jpg","comment_is_top":false,"comment_ctime":1633955701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633955701","product_id":100006701,"comment_content":"遇到了finalize导致的内存oom，怀疑是使用了jdbc频繁建立连接、关闭连接导致的，但是不知道怎么解决问题","like_count":0},{"had_liked":false,"id":302715,"user_name":"Geek_d3b039","can_delete":false,"product_type":"c1","uid":2685410,"ip_address":"","ucode":"17F033EC71D8A4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/icKUJalOceHxhGvjbV8H2zCKhrcEEhY91pLyLI1581yXRm0sicCSibHEly2mEnxuttBIsKwgWnu4z10I6zku7UibEw/132","comment_is_top":false,"comment_ctime":1626343686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626343686","product_id":100006701,"comment_content":"cleaner机制比finalize更可靠，因而不用finalize，但是cleaner机制也有缺陷，可以用并发编程改善吗","like_count":0},{"had_liked":false,"id":287221,"user_name":"努力的熊","can_delete":false,"product_type":"c1","uid":1504423,"ip_address":"","ucode":"D669AF855D2EF1","user_header":"https://static001.geekbang.org/account/avatar/00/16/f4/a7/1cf57505.jpg","comment_is_top":false,"comment_ctime":1617845266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617845266","product_id":100006701,"comment_content":"看了评论区，才发现，大家跟我有相同的疑问。今年在看这篇文章的时候，是觉得半毛钱关系都没有，但是我还记得去年面试的时候，还有人问到了这个问题-_-、","like_count":0},{"had_liked":false,"id":268782,"user_name":"acqierement","can_delete":false,"product_type":"c1","uid":1234980,"ip_address":"","ucode":"AC8DA74B9CB924","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/24/f48a38f4.jpg","comment_is_top":false,"comment_ctime":1608347873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608347873","product_id":100006701,"comment_content":"final: 可以用来修饰方法、变量和类。修饰方法说明方法不能被重写，修饰变量表明方法不能被修改，修饰类表明不能被继承。final修饰一个对象的时候，只是约束引用不可以被赋值，但是对象行为不被final影响。final修饰的变量在类加载的准备阶段就已经 分配好内存并初始化了。<br>finally: 用于最后必须要执行的操作，常用于关闭资源、释放锁。<br>finalize: 用于垃圾收集，问题较多，已废弃。","like_count":0},{"had_liked":false,"id":263253,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1606060994,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1606060994","product_id":100006701,"comment_content":"这个题目本身是比较“无趣”的，但是通过这样的题目，面试官其实可以引出很多话题，重点似乎还是在 final 上。<br><br>final 修饰 class 表示不可以继续扩展，final 修饰变量表示不可以修改，final 修饰方法表示不可以重写。<br><br>通过 final 可以让别人明确不可修改的意图，避免意外赋值导致的编程错误，产生某种程度的 immutable 效果。<br><br>final 不等同于 immutable。","like_count":0},{"had_liked":false,"id":255100,"user_name":"圈","can_delete":false,"product_type":"c1","uid":1637083,"ip_address":"","ucode":"7926384D7C0B0C","user_header":"","comment_is_top":false,"comment_ctime":1603265809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603265809","product_id":100006701,"comment_content":"读了之后，我感觉自己重来没有学过一样，谢谢老师的分享！","like_count":0},{"had_liked":false,"id":235789,"user_name":"白菜炒五花肉","can_delete":false,"product_type":"c1","uid":1519828,"ip_address":"","ucode":"0D4CBD221C2880","user_header":"https://static001.geekbang.org/account/avatar/00/17/30/d4/6eb8f5af.jpg","comment_is_top":false,"comment_ctime":1595203657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595203657","product_id":100006701,"comment_content":"final 修饰类，类不可以被继承<br>final修饰方法，方法不可以被重写<br>final修饰变量，变量不可以被修改<br>finally用于Java中保证一些重点代码一定会被执行，可使用try...finally和try...catch...finally来关闭JDBC等操作<br>finalize用于对象回收前进行资源回收，不推荐使用，实现了finalize方法，相应对象的回收速度呈数量级下降，目前使用java.lan.ref.Cleaner来代替其功能。Cleaner使用幻象引用和引用队列，相较而言更加轻量级，更可靠，但改善作用仍然有限，适合作为资源回收的最后一种保证手段。","like_count":0},{"had_liked":false,"id":229032,"user_name":"周靖峰","can_delete":false,"product_type":"c1","uid":1830939,"ip_address":"","ucode":"997B9776F923F3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriaoouNOT0uLbN3fondbSTTfWjDJibVuFubGWDvzsgCtYmBpaTwvRMQbS0uXoIsUz6aPf7I1S75Rkg/132","comment_is_top":false,"comment_ctime":1592882439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592882439","product_id":100006701,"comment_content":"为什么一定要用finalize或Cleaner呢？百思不得其解","like_count":0},{"had_liked":false,"id":218384,"user_name":"Geek_42fe44","can_delete":false,"product_type":"c1","uid":1392457,"ip_address":"","ucode":"285EFAA620C07F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eonibS0icXNSL8Nxiau5fAcKzIl7cR1toNkNzoocrmibpv9WDXicvWudl5rvdIPfXxAbwSDaRiaK2cmDibMg/132","comment_is_top":false,"comment_ctime":1589793331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589793331","product_id":100006701,"comment_content":"你无法保证 finalize 什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。<br>finalize的调用时间不确定——导致资源存在延迟释放的现象，资源在内存中越来越多会导致内存空间不够，此时进程会主动从内存换出到外存，即挂起<br>finalize有可能不会被调用，那么资源永远也不会被释放，那么存在两个进程A和B，A持有资源N(不被释放)，申请资源M；B持有资源M(不被释放)，申请资源N，因此导致死锁的发生<br>在使用finalize时存在&quot;诈尸&quot;的情况，所以垃圾回收器只能在每次调用完finalize()之后再次去检查该对象是否还处于失效状态。这无形中又增加了JVM的开销，即影响性能。","like_count":0},{"had_liked":false,"id":212042,"user_name":"Bruce","can_delete":false,"product_type":"c1","uid":1106929,"ip_address":"","ucode":"B2F562F717BD3C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/f1/346bd356.jpg","comment_is_top":false,"comment_ctime":1588051136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588051136","product_id":100006701,"comment_content":"finalize为什么会导致垃圾回收效率变低，没太理解啊","like_count":0},{"had_liked":false,"id":198933,"user_name":"rexcai","can_delete":false,"product_type":"c1","uid":1595589,"ip_address":"","ucode":"E3AEB9A6D94EE8","user_header":"https://static001.geekbang.org/account/avatar/00/18/58/c5/433de59b.jpg","comment_is_top":false,"comment_ctime":1585473819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585473819","product_id":100006701,"comment_content":"final和finally在日常编码使用中，还是比较频繁的。final在并发编程，多线程编程方面，可以起到很好的控制变量不可变的效果；finally则一般都是配合try catch的使用，在异常捕获处理之后，处理一些必要的代码，如资源的释放，文件流关闭之类的。最后说到finalize，可能编程比较浅，至今没有使用到，所以学习了","like_count":0},{"had_liked":false,"id":197433,"user_name":"玩家","can_delete":false,"product_type":"c1","uid":1187094,"ip_address":"","ucode":"75BC2C2B4FC391","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/16/b75d040a.jpg","comment_is_top":false,"comment_ctime":1585377576,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585377576","product_id":100006701,"comment_content":"final修饰 类，方法，变量，finally 是 属于  try-with-resources 或者try-finally 回收资源的方式，推荐使用，使用finalize 会引起不知名的后果","like_count":0},{"had_liked":false,"id":196219,"user_name":"ilovealt","can_delete":false,"product_type":"c1","uid":1113180,"ip_address":"","ucode":"35CB4FD836135B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/5c/a3d42cdb.jpg","comment_is_top":false,"comment_ctime":1585260263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585260263","product_id":100006701,"comment_content":"不用finalize,多用final,合理使用finally。","like_count":0},{"had_liked":false,"id":175169,"user_name":"27182818282","can_delete":false,"product_type":"c1","uid":1796330,"ip_address":"","ucode":"55EB7C0B53C5EF","user_header":"https://static001.geekbang.org/account/avatar/00/1b/68/ea/c5385846.jpg","comment_is_top":false,"comment_ctime":1580598468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580598468","product_id":100006701,"comment_content":"请问什么是Post-Mortem 清理机制？","like_count":0},{"had_liked":false,"id":154783,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1574563725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574563725","product_id":100006701,"comment_content":"通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。老是，这个地方可以举个例子么？","like_count":0},{"had_liked":false,"id":151872,"user_name":"Hey","can_delete":false,"product_type":"c1","uid":1626281,"ip_address":"","ucode":"310FDDC391A9DB","user_header":"https://static001.geekbang.org/account/avatar/00/18/d0/a9/42e79e88.jpg","comment_is_top":false,"comment_ctime":1573803218,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573803218","product_id":100006701,"comment_content":"👍🏻","like_count":0,"discussions":[{"author":{"id":1626281,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d0/a9/42e79e88.jpg","nickname":"Hey","note":"","ucode":"310FDDC391A9DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564928,"discussion_content":"2刷","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650355740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147834,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1572912662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572912662","product_id":100006701,"comment_content":"3 3.1 final 修饰类，表示该类不可以被继承，修饰方法 表示不可以被覆盖，修饰变量赋值后不能被修改。finally 和try 或者 try catch 搭配使用 。finilize ，表示在对象在垃圾回收前完成特定资源的回收。3.2 3.21 final类 用来标记方法和类，表示不可以被修改，避免开发者修改，保证平台安全。3.22 使用final修饰参数和变量，也可以避免意外赋值导致的错误。3.23 final变量产生了某种程度的不可变效果，可以用于保护私有数据，减少并发编程，数据同步的开销，4 4.1 final不是immutable，修饰的变量不可以再初始化，但是可以add。如果想不能add，用list.Of方法创建对象，4.2 immutable实现的原理，4.21 将类用final修饰 ，不能用扩展类了4.22 将所有成员变量定义成private和final 并且不要实现setter，并且将初始化方法定义成private 4.23 构造对象使用深度拷贝，而不是直接赋值，4.24 如果要实现getter方法，使用copy-on-write的原则，创建私有的copy。","like_count":0},{"had_liked":false,"id":146291,"user_name":"第一记忆","can_delete":false,"product_type":"c1","uid":1499365,"ip_address":"","ucode":"2EEBE479FAF245","user_header":"https://static001.geekbang.org/account/avatar/00/16/e0/e5/bdd0161c.jpg","comment_is_top":false,"comment_ctime":1572490342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572490342","product_id":100006701,"comment_content":"final：修饰符；作用于类上，类无法被继承；作用于对象，对象无法被直接赋值（可通过setter对对象内属性进行更改）；作用于方法，方法不能被覆盖、重写。<br>finally：通常与try--catch连用，用于回收资源，try-catch-finally使用时，在try或catch之后执行；try--finally使用时，在获取到异常时才会执行finally。<br>finalize：在资源被CG回收之前执行，不可控，非特殊情况不使用。（淘汰品）","like_count":0},{"had_liked":false,"id":145798,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1211713,"ip_address":"","ucode":"E3AD8BF42E19DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/41/3c5b770b.jpg","comment_is_top":false,"comment_ctime":1572368057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572368057","product_id":100006701,"comment_content":"打卡！","like_count":0},{"had_liked":false,"id":144213,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1571879010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571879010","product_id":100006701,"comment_content":"Java的clean，感觉是用一个队列来排队释放资源，我个人觉得用c++析构函数执行顺序适合简单的场景，例如资源在出作用域的时候，就被自动释放。","like_count":0},{"had_liked":false,"id":144203,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1571878396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571878396","product_id":100006701,"comment_content":"final 表示写的完结，修饰类表示类不可被派生，修饰函数，表示函数不可被派生类重写，修饰参数和变量表示这个变量不可指向其他对象。Kotlin实际上对于参数和类，都选用的默认final。<br><br>finally 表示终将被执行，用于释放此前分配的资源。","like_count":0},{"had_liked":false,"id":135053,"user_name":"d7f5931e-5c2f-11e9-a742-71d9eb","can_delete":false,"product_type":"c1","uid":1498156,"ip_address":"","ucode":"94FD7959E93C28","user_header":"","comment_is_top":false,"comment_ctime":1568990107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568990107","product_id":100006701,"comment_content":"大佬就是大佬，看了一下评论，感觉有一部分是初学者，对大佬抛出的问题，不自己专研就一个劲的问，这。。。杨老师，高人，希望学完以后收获多多。","like_count":0},{"had_liked":false,"id":134913,"user_name":"Ivan","can_delete":false,"product_type":"c1","uid":1670971,"ip_address":"","ucode":"1B8FEE32C4C819","user_header":"https://static001.geekbang.org/account/avatar/00/19/7f/3b/49e2cec8.jpg","comment_is_top":false,"comment_ctime":1568950672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568950672","product_id":100006701,"comment_content":"帮忙贡献数据点， 最近全球校招阿里电面考了这道题一毛一样，没有答好很难受","like_count":0},{"had_liked":false,"id":133350,"user_name":"文俊杰","can_delete":false,"product_type":"c1","uid":1015983,"ip_address":"","ucode":"8045C05DC73442","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/af/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1568524846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568524846","product_id":100006701,"comment_content":"这个课真的是太棒了，相见恨晚，不过还好不算晚！ 谢谢老师！！","like_count":0},{"had_liked":false,"id":129310,"user_name":"Mrnx2004","can_delete":false,"product_type":"c1","uid":1584075,"ip_address":"","ucode":"2B9C99A036FEB8","user_header":"https://static001.geekbang.org/account/avatar/00/18/2b/cb/45ebb433.jpg","comment_is_top":false,"comment_ctime":1567085067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567085067","product_id":100006701,"comment_content":"final应该不能省去防御性拷贝吧，即使将对象申明为final，如果直接拿到这个对象一样可以篡改对象的属性啊。除非你是将对象里面的属性变量声明为final，这样即使拿到对象也不能篡改。希望可以在文章中说明前置条件。","like_count":0},{"had_liked":false,"id":108814,"user_name":"少盐","can_delete":false,"product_type":"c1","uid":1305743,"ip_address":"","ucode":"BCC7E264B75702","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/8f/8299495a.jpg","comment_is_top":false,"comment_ctime":1561888378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561888378","product_id":100006701,"comment_content":"三个单词长得挺像，意思也类似吧","like_count":0},{"had_liked":false,"id":92005,"user_name":"PoL","can_delete":false,"product_type":"c1","uid":1416147,"ip_address":"","ucode":"72BA3C2D50D463","user_header":"https://static001.geekbang.org/account/avatar/00/15/9b/d3/41d04923.jpg","comment_is_top":false,"comment_ctime":1557152449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557152449","product_id":100006701,"comment_content":"final 修饰class 类不可继承扩展，方法 不可重写，变量不可修改（setaccessable 可绕）<br>finally 确保执行 lock，特例，循环，提前退出程序，线程退出，<br>finalize Object 的方法，用来释放资源，一般不用实现，会影响垃圾回收，cleaner幻像应用实现释放资源<br>","like_count":0},{"had_liked":false,"id":87914,"user_name":"傲娇的小宝","can_delete":false,"product_type":"c1","uid":1493922,"ip_address":"","ucode":"C079B19BCC1B7C","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/a2/5e7c557e.jpg","comment_is_top":false,"comment_ctime":1555750719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555750719","product_id":100006701,"comment_content":"没啥好建议，老老实实显示释放资源呗。","like_count":0},{"had_liked":false,"id":87214,"user_name":"苐④飛瀧","can_delete":false,"product_type":"c1","uid":1263918,"ip_address":"","ucode":"1CB6A6D2E72CA5","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/2e/c7165307.jpg","comment_is_top":false,"comment_ctime":1555549469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555549469","product_id":100006701,"comment_content":"受益匪浅，以前只是之所然不知所以然。还是要通过老师的抛砖引玉才理解更多开源SDK中这种写法的用意，评论中有些读者朋友觉得知道这三个东西怎么用就行，其实如果了解了设计者的用意时就会有更多不一样的理解。向：“能用” - “会用” - “好用” 进发。","like_count":0},{"had_liked":false,"id":79812,"user_name":"请叫我华仔","can_delete":false,"product_type":"c1","uid":1465300,"ip_address":"","ucode":"307D39B12CEF61","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/d4/f4a2888a.jpg","comment_is_top":false,"comment_ctime":1553560559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553560559","product_id":100006701,"comment_content":"不可变类的实现方法：声明为final类，成员为private final，构造函数中做深拷贝，无set方法，在get方法中对于可变类要做防御性拷贝。<br><br>jdk9引入的Cleaner机制比finalize机制好一点，可以控制执行clean的线程。cleaner可以用来兜底，但是资源回收还是在显式实现比较好。","like_count":0},{"had_liked":false,"id":76150,"user_name":"骑个隆咚锵老干部","can_delete":false,"product_type":"c1","uid":1172267,"ip_address":"","ucode":"3839C568D85AB9","user_header":"https://static001.geekbang.org/account/avatar/00/11/e3/2b/0ef6cf3e.jpg","comment_is_top":false,"comment_ctime":1552536666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552536666","product_id":100006701,"comment_content":"能否举例本地变量，内部变量声明为 final 的例子","like_count":0},{"had_liked":false,"id":73301,"user_name":"心声","can_delete":false,"product_type":"c1","uid":1448630,"ip_address":"","ucode":"ABFFC9137B0FC8","user_header":"https://static001.geekbang.org/account/avatar/00/16/1a/b6/4777f789.jpg","comment_is_top":false,"comment_ctime":1551854518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551854518","product_id":100006701,"comment_content":"请问老师，因为那样会使外部对象无法进入幻象可达的状态 是什么意思？ 幻象可达？","like_count":0},{"had_liked":false,"id":56066,"user_name":"悠南","can_delete":false,"product_type":"c1","uid":1193711,"ip_address":"","ucode":"333665DB7CFDD6","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/ef/83c2a743.jpg","comment_is_top":false,"comment_ctime":1546391100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546391100","product_id":100006701,"comment_content":"所以呢 finally  但是经常用httpclient.close  final  用于魔法值 标注该值不要变,然后呢 老哥举例说明什么场景下用或者怎么用 现在问基础都不只是让你背了","like_count":0},{"had_liked":false,"id":47942,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1544261981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544261981","product_id":100006701,"comment_content":"深入浅出，娓娓道来，高明。","like_count":0},{"had_liked":false,"id":20065,"user_name":"影子传说","can_delete":false,"product_type":"c1","uid":1031636,"ip_address":"","ucode":"371B72BB5CCB5E","user_header":"","comment_is_top":false,"comment_ctime":1534249294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534249294","product_id":100006701,"comment_content":"关于匿名内部类访问外部类变量，jdk1.6要声明为final jdk1.8不用，jvm层面有什么变化吗","like_count":0},{"had_liked":false,"id":15446,"user_name":"团结屯儿王二狗","can_delete":false,"product_type":"c1","uid":1171468,"ip_address":"","ucode":"C4E0CF37E58773","user_header":"https://static001.geekbang.org/account/avatar/00/11/e0/0c/c6151e22.jpg","comment_is_top":false,"comment_ctime":1531192716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1531192716","product_id":100006701,"comment_content":"前半部分可以看懂，后面涉及幻象引用就不懂了。完全看懂感觉需要看一下那篇引用的文章。文章整体不错，从多个角度分析一个问题。我想这也是一个工程师应该具备的思维之一，希望自己能够不断提高，与君共勉。","like_count":0},{"had_liked":false,"id":13070,"user_name":"待时而发","can_delete":false,"product_type":"c1","uid":1158705,"ip_address":"","ucode":"92104F88D537F9","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/31/2c8a3a66.jpg","comment_is_top":false,"comment_ctime":1529363587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1529363587","product_id":100006701,"comment_content":"有点懵","like_count":0},{"had_liked":false,"id":10376,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1527511971,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1527511971","product_id":100006701,"comment_content":"加final的state为啥还能赋值呢？","like_count":0,"discussions":[{"author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211565,"discussion_content":"这里的state赋值是在构造函数中，此时对象正在被创建，对应的就是被final修饰的成员变量在JVM的类加载机制中的准备阶段（为成员变量分配内存并设置类变量初始值）被赋值，其余未被final修饰的成员变量会被初始化为数据类型的零值，然后在初始化阶段被赋值（如int被初始化为0）。\n\n且，被final修饰的成员变量只是不可被修改，这里的修改当然不包括构造函数中将成员变量初始化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584866026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10277,"user_name":"大大大熊myeh","can_delete":false,"product_type":"c1","uid":1139413,"ip_address":"","ucode":"4832C2E7CEB151","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","comment_is_top":false,"comment_ctime":1527434771,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1527434771","product_id":100006701,"comment_content":"对我这种刚入门的来说 是有点高深了","like_count":0,"discussions":[{"author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211566,"discussion_content":"近两年过去了，开始二刷，现在再看这些文章，觉得可以看懂了。果然这些内容还是需要有一些基础和累积才能更好地吸收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584866096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10171,"user_name":"徐金铎","can_delete":false,"product_type":"c1","uid":1080462,"ip_address":"","ucode":"E13FD19FD27869","user_header":"https://static001.geekbang.org/account/avatar/00/10/7c/8e/73581062.jpg","comment_is_top":false,"comment_ctime":1527321325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527321325","product_id":100006701,"comment_content":"如果是考虑gc回收，推荐大家更关注weakreference, softreference等结合referencequeue来考虑。这样对gc更友好些。","like_count":0},{"had_liked":false,"id":9009,"user_name":"曲水流觞TechRill","can_delete":false,"product_type":"c1","uid":1007735,"ip_address":"","ucode":"96432F9357C700","user_header":"https://static001.geekbang.org/account/avatar/00/0f/60/77/cc2817b9.jpg","comment_is_top":false,"comment_ctime":1526568960,"is_pvip":false,"replies":[{"id":"2765","content":"我理解不是","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526671560,"ip_address":"","comment_id":9009,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526568960","product_id":100006701,"comment_content":"关于匿名内部类访问局部变量必须final的原因，还有一个关键是匿名内部类的生命周期可能比外部类要长，而如果外部类已经被垃圾回收了，那内部类访问的就是一个空变量。final可以防止被回收，老师对么？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417941,"discussion_content":"我理解不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526671560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8822,"user_name":"Z","can_delete":false,"product_type":"c1","uid":1103484,"ip_address":"","ucode":"015891F85A6B9D","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/7c/979429d8.jpg","comment_is_top":false,"comment_ctime":1526466583,"is_pvip":false,"replies":[{"id":"2641","content":"忘了说Java 9新增的，回头修改下","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526517867,"ip_address":"","comment_id":8822,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526466583","product_id":100006701,"comment_content":"有List.of（）方法吗我怎么找不到","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417858,"discussion_content":"忘了说Java 9新增的，回头修改下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526517867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8496,"user_name":"櫻の空","can_delete":false,"product_type":"c1","uid":1112459,"ip_address":"","ucode":"FCB2F7BFC186EC","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/8b/11c87d4e.jpg","comment_is_top":false,"comment_ctime":1526267238,"is_pvip":false,"replies":[{"id":"2514","content":"个人认为static之类主要还是注重反应语义的需求，过早考虑节省资源太片面","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526274675,"ip_address":"","comment_id":8496,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526267238","product_id":100006701,"comment_content":"说到final的话，现在更多的会谈到static.许多代码都会使用到static final来同时修饰一个变量(这里称为常量更合适哈)。从而可以达到一个编译期常量的作用。这可以使得我们不需要初始化一个类就能够直接访问其成员，对节约资源效率上有不少的提升。<br>所以我觉得老师可以顺带提一下static,或者放些补充学习的资料哈。<br>而以上东西其实可以进一步深挖，这就会关系到老师在第一讲提到过的类加载，验证，链接，初始化。这个过程，介于篇幅原因未能进一步展开，有兴趣的同学可以翻看TIJ和深入理解JVM进行学习哈。<br>以上是个人理解，若有错误，还望指正。<br>","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417745,"discussion_content":"个人认为static之类主要还是注重反应语义的需求，过早考虑节省资源太片面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526274675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8260,"user_name":"李润林","can_delete":false,"product_type":"c1","uid":1118463,"ip_address":"","ucode":"E89ACF8F14D9B4","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/ff/dcd5b47e.jpg","comment_is_top":false,"comment_ctime":1526008027,"is_pvip":false,"replies":[{"id":"2416","content":"本身使用场景和需求是存在的，只是存在一些弊端，实在不行也得用，毕竟准确性、可靠性是基础","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526009936,"ip_address":"","comment_id":8260,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526008027","product_id":100006701,"comment_content":"finalize应该是从c++的析构函数那里继承来的一个东西，随着垃圾收集算法的不断改进，变得完全不可控了。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417647,"discussion_content":"本身使用场景和需求是存在的，只是存在一些弊端，实在不行也得用，毕竟准确性、可靠性是基础","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526009936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8250,"user_name":"张勇","can_delete":false,"product_type":"c1","uid":1120890,"ip_address":"","ucode":"F0C1A539442510","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/7a/5ffb9d63.jpg","comment_is_top":false,"comment_ctime":1526003121,"is_pvip":false,"replies":[{"id":"2417","content":"看不出来super内部的逻辑，再说final这东西有太多可以绕过去的方式。比如setaccessible或者配合修改modifier","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526010506,"ip_address":"","comment_id":8250,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526003121","product_id":100006701,"comment_content":"老师咨询下，我小面这段代码String类型的参数用final修饰为啥我每次可以穿不同的参数进去，并且也可以运行成功final不是不可变么，public class MainActivity extends AppCompatActivity {\r<br>private static final String TAG=&quot;MainActivity&quot;;\r<br>    @Override\r<br>    protected void onCreate(Bundle savedInstanceState) {\r<br>        super.onCreate(savedInstanceState);\r<br>        setContentView(R.layout.activity_main);\r<br>        test(&quot;AAAAAAA&quot;);\r<br>        test(&quot;BBBBBBB&quot;);\r<br>        test(&quot;CCCCCCC&quot;);\r<br>        test(&quot;DDDDDDD&quot;);\r<br>    }\r<br>\r<br> public void test(final String  str){\r<br>     Log.d(TAG,str);\r<br> }   \r<br>\r<br>}","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417645,"discussion_content":"看不出来super内部的逻辑，再说final这东西有太多可以绕过去的方式。比如setaccessible或者配合修改modifier","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526010506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8220,"user_name":"冯召坤","can_delete":false,"product_type":"c1","uid":1055887,"ip_address":"","ucode":"2E9A0E7DB3B40A","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/8f/a02d26a2.jpg","comment_is_top":false,"comment_ctime":1525988258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525988258","product_id":100006701,"comment_content":"分析的不错","like_count":0},{"had_liked":false,"id":8211,"user_name":"FF","can_delete":false,"product_type":"c1","uid":1001615,"ip_address":"","ucode":"26349F32B406D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/8f/7ecd4eed.jpg","comment_is_top":false,"comment_ctime":1525968197,"is_pvip":false,"replies":[{"id":"2420","content":"这是rethrow，我理解不存在模棱两可，或者哪位高手有精力去翻spec，谢谢","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526014246,"ip_address":"","comment_id":8211,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525968197","product_id":100006701,"comment_content":"IDEA 的版本是2018.1.2，throw 一个方法没有声明的受检查 ex 也是合规的写法吗？即使 try 里面没有显示 throw","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417632,"discussion_content":"这是rethrow，我理解不存在模棱两可，或者哪位高手有精力去翻spec，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526014246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8205,"user_name":"独嘉记忆","can_delete":false,"product_type":"c1","uid":1112461,"ip_address":"","ucode":"E0FC29077E9F30","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/8d/f56b4cb9.jpg","comment_is_top":false,"comment_ctime":1525966855,"is_pvip":false,"replies":[{"id":"2421","content":"我也在考虑补充一些，很多地方还没展开就3000多了……","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526014369,"ip_address":"","comment_id":8205,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525966855","product_id":100006701,"comment_content":"老师，能否之后多开几讲，两三千字的限制怕知识点后面不够或者没法深入。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417628,"discussion_content":"我也在考虑补充一些，很多地方还没展开就3000多了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526014369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8181,"user_name":"学无止境","can_delete":false,"product_type":"c1","uid":1106950,"ip_address":"","ucode":"F26A10C3ACCFC1","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/06/2d087eaf.jpg","comment_is_top":false,"comment_ctime":1525954853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525954853","product_id":100006701,"comment_content":"老师，您好，我想请教一下finalize或者cleaner使用场景是什么？谢谢。","like_count":0},{"had_liked":false,"id":8178,"user_name":"life is cool","can_delete":false,"product_type":"c1","uid":1104669,"ip_address":"","ucode":"CEAD7893B1F2E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/1d/d9fd9837.jpg","comment_is_top":false,"comment_ctime":1525949881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525949881","product_id":100006701,"comment_content":"老师，final对象变量Jvm是怎么被垃圾回收器回收的呢？","like_count":0},{"had_liked":false,"id":8168,"user_name":"一笑奈何","can_delete":false,"product_type":"c1","uid":1007709,"ip_address":"","ucode":"33FE23DF749936","user_header":"https://static001.geekbang.org/account/avatar/00/0f/60/5d/f6350fce.jpg","comment_is_top":false,"comment_ctime":1525938759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525938759","product_id":100006701,"comment_content":"先说答案在分析挺好😊","like_count":0},{"had_liked":false,"id":8159,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1525930682,"is_pvip":false,"replies":[{"id":"2393","content":"好的，2、3千字篇幅限制大，后面补充吧，你可以看看jdk源码用的内部cleaner","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525962662,"ip_address":"","comment_id":8159,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525930682","product_id":100006701,"comment_content":"之前甚至不知道有cleaner这回事...希望杨老师后面有机会详细说说","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417605,"discussion_content":"好的，2、3千字篇幅限制大，后面补充吧，你可以看看jdk源码用的内部cleaner","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525962662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}