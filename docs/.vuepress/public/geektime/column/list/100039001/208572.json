{"id":208572,"title":"54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？","content":"<p>上一节课中，我们讲了组合模式。组合模式并不常用，主要用在数据能表示成树形结构、能通过树的遍历算法来解决的场景中。今天，我们再来学习一个不那么常用的模式，<strong>享元模式</strong>（Flyweight Design Pattern）。这也是我们要学习的最后一个结构型模式。</p><p>跟其他所有的设计模式类似，享元模式的原理和实现也非常简单。今天，我会通过棋牌游戏和文本编辑器两个实际的例子来讲解。除此之外，我还会讲到它跟单例、缓存、对象池的区别和联系。在下一节课中，我会带你剖析一下享元模式在Java Integer、String中的应用。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>享元模式原理与实现</h2><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p><p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。</p><!-- [[[read_end]]] --><p>这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何set()等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</p><p>接下来，我们通过一个简单的例子解释一下享元模式。</p><p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece类表示棋子，ChessBoard类表示一个棋局，里面保存了象棋中30个棋子的信息。</p><pre><code>public class ChessPiece {//棋子\n  private int id;\n  private String text;\n  private Color color;\n  private int positionX;\n  private int positionY;\n\n  public ChessPiece(int id, String text, Color color, int positionX, int positionY) {\n    this.id = id;\n    this.text = text;\n    this.color = color;\n    this.positionX = positionX;\n    this.positionY = positionX;\n  }\n\n  public static enum Color {\n    RED, BLACK\n  }\n\n  // ...省略其他属性和getter/setter方法...\n}\n\npublic class ChessBoard {//棋局\n  private Map&lt;Integer, ChessPiece&gt; chessPieces = new HashMap&lt;&gt;();\n\n  public ChessBoard() {\n    init();\n  }\n\n  private void init() {\n    chessPieces.put(1, new ChessPiece(1, &quot;車&quot;, ChessPiece.Color.BLACK, 0, 0));\n    chessPieces.put(2, new ChessPiece(2,&quot;馬&quot;, ChessPiece.Color.BLACK, 0, 1));\n    //...省略摆放其他棋子的代码...\n  }\n\n  public void move(int chessPieceId, int toPositionX, int toPositionY) {\n    //...省略...\n  }\n}\n</code></pre><p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个ChessBoard棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？</p><p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的id、text、color都是相同的，唯独positionX、positionY不同。实际上，我们可以将棋子的id、text、color属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：</p><pre><code>// 享元类\npublic class ChessPieceUnit {\n  private int id;\n  private String text;\n  private Color color;\n\n  public ChessPieceUnit(int id, String text, Color color) {\n    this.id = id;\n    this.text = text;\n    this.color = color;\n  }\n\n  public static enum Color {\n    RED, BLACK\n  }\n\n  // ...省略其他属性和getter方法...\n}\n\npublic class ChessPieceUnitFactory {\n  private static final Map&lt;Integer, ChessPieceUnit&gt; pieces = new HashMap&lt;&gt;();\n\n  static {\n    pieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK));\n    pieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK));\n    //...省略摆放其他棋子的代码...\n  }\n\n  public static ChessPieceUnit getChessPiece(int chessPieceId) {\n    return pieces.get(chessPieceId);\n  }\n}\n\npublic class ChessPiece {\n  private ChessPieceUnit chessPieceUnit;\n  private int positionX;\n  private int positionY;\n\n  public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) {\n    this.chessPieceUnit = unit;\n    this.positionX = positionX;\n    this.positionY = positionY;\n  }\n  // 省略getter、setter方法\n}\n\npublic class ChessBoard {\n  private Map&lt;Integer, ChessPiece&gt; chessPieces = new HashMap&lt;&gt;();\n\n  public ChessBoard() {\n    init();\n  }\n\n  private void init() {\n    chessPieces.put(1, new ChessPiece(\n            ChessPieceUnitFactory.getChessPiece(1), 0,0));\n    chessPieces.put(1, new ChessPiece(\n            ChessPieceUnitFactory.getChessPiece(2), 1,0));\n    //...省略摆放其他棋子的代码...\n  }\n\n  public void move(int chessPieceId, int toPositionX, int toPositionY) {\n    //...省略...\n  }\n}\n</code></pre><p>在上面的代码实现中，我们利用工厂类来缓存ChessPieceUnit信息（也就是id、text、color）。通过工厂类获取到的ChessPieceUnit就是享元。所有的ChessBoard对象共享这30个ChessPieceUnit对象（因为象棋中只有30个棋子）。在使用享元模式之前，记录1万个棋局，我们要创建30万（30*1万）个棋子的ChessPieceUnit对象。利用享元模式，我们只需要创建30个享元对象供所有棋局共享使用即可，大大节省了内存。</p><p>那享元模式的原理讲完了，我们来总结一下它的代码结构。实际上，它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的。</p><h2>享元模式在文本编辑器中的应用</h2><p>弄懂了享元模式的原理和实现之后，我们再来看另外一个例子，也就是文章标题中给出的：如何利用享元模式来优化文本编辑器的内存占用？</p><p>你可以把这里提到的文本编辑器想象成Office的Word。不过，为了简化需求背景，我们假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。</p><p>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的代码示例如下所示：</p><pre><code>public class Character {//文字\n  private char c;\n\n  private Font font;\n  private int size;\n  private int colorRGB;\n\n  public Character(char c, Font font, int size, int colorRGB) {\n    this.c = c;\n    this.font = font;\n    this.size = size;\n    this.colorRGB = colorRGB;\n  }\n}\n\npublic class Editor {\n  private List&lt;Character&gt; chars = new ArrayList&lt;&gt;();\n\n  public void appendCharacter(char c, Font font, int size, int colorRGB) {\n    Character character = new Character(c, font, size, colorRGB);\n    chars.add(character);\n  }\n}\n</code></pre><p>在文本编辑器中，我们每敲一个文字，都会调用Editor类中的appendCharacter()方法，创建一个新的Character对象，保存到chars数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多Character对象。那有没有办法可以节省一点内存呢？</p><p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：</p><pre><code>public class CharacterStyle {\n  private Font font;\n  private int size;\n  private int colorRGB;\n\n  public CharacterStyle(Font font, int size, int colorRGB) {\n    this.font = font;\n    this.size = size;\n    this.colorRGB = colorRGB;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    CharacterStyle otherStyle = (CharacterStyle) o;\n    return font.equals(otherStyle.font)\n            &amp;&amp; size == otherStyle.size\n            &amp;&amp; colorRGB == otherStyle.colorRGB;\n  }\n}\n\npublic class CharacterStyleFactory {\n  private static final List&lt;CharacterStyle&gt; styles = new ArrayList&lt;&gt;();\n\n  public static CharacterStyle getStyle(Font font, int size, int colorRGB) {\n    CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);\n    for (CharacterStyle style : styles) {\n      if (style.equals(newStyle)) {\n        return style;\n      }\n    }\n    styles.add(newStyle);\n    return newStyle;\n  }\n}\n\npublic class Character {\n  private char c;\n  private CharacterStyle style;\n\n  public Character(char c, CharacterStyle style) {\n    this.c = c;\n    this.style = style;\n  }\n}\n\npublic class Editor {\n  private List&lt;Character&gt; chars = new ArrayList&lt;&gt;();\n\n  public void appendCharacter(char c, Font font, int size, int colorRGB) {\n    Character character = new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));\n    chars.add(character);\n  }\n}\n</code></pre><h2>享元模式vs单例、缓存、对象池</h2><p>在上面的讲解中，我们多次提到“共享”“缓存”“复用”这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？我们来简单对比一下。</p><p><strong>我们先来看享元模式跟单例的区别。</strong></p><p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。</p><p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。</p><p><strong>我们再来看享元模式跟缓存的区别。</strong></p><p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU缓存”“MemCache缓存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p><p><strong>最后我们来看享元模式跟对象池的区别。</strong></p><p>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？</p><p>你可能对连接池、线程池比较熟悉，对对象池比较陌生，所以，这里我简单解释一下对象池。像C++这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。</p><p>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念。</p><p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p><strong>1.享元模式的原理</strong></p><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p><p><strong>2.享元模式的实现</strong></p><p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个Map或者List来缓存已经创建好的享元对象，以达到复用的目的。</p><p><strong>3.享元模式VS单例、缓存、对象池</strong></p><p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。这里的区别也不例外。</p><p>我们可以用简单几句话来概括一下它们之间的区别。应用单例模式是为了保证对象全局唯一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</p><h2>课堂讨论</h2><ol>\n<li>在棋牌游戏的例子中，有没有必要把ChessPiecePosition设计成享元呢？</li>\n<li>在文本编辑器的例子中，调用CharacterStyleFactory类的getStyle()方法，需要在styles数组中遍历查找，而遍历查找比较耗时，是否可以优化一下呢？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？","id":207456},"right":{"article_title":"55 | 享元模式（下）：剖析享元模式在Java Integer、String中的应用","id":209343}},"comments":[{"had_liked":false,"id":185008,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1583465129,"is_pvip":false,"discussion_count":27,"race_medal":0,"score":"744612807337","product_id":100039001,"comment_content":"1.在棋牌游戏的例子中，有没有必要把 ChessPiecePosition 设计成享元呢？<br>没有必要,设计成享元模式主要是为了节省内存资源.<br>ChessPiece中的positionX和positionY共占用8个字节,而把ChessPiecePosition设计成享元模式,ChessPiecePosition的引用在ChessPiece中也是占用8个字节,反而还需要额外的内存空间来存放棋盘中各个位置的对象,最终就得不偿失了.<br>当启用压缩指针时,ChessPiece对象占用(12+4+4+补4)24个字节,<br>当不启用压缩指针时,ChessPiece对象占用(16+4+补4+8)32个字节.<br>2.在文本编辑器的例子中，调用 CharacterStyleFactory 类的 getStyle() 方法，需要在 styles 数组中遍历查找，而遍历查找比较耗时，是否可以优化一下呢？<br>用map来存储数据CharacterStyle,重写CharacterStyle的hash方法,查找时就创建出新的对象来获取该hash值,用该hash值在map中查找是否存在,如果存在就直接返回,如果不存在就先添加到map中再返回.","like_count":174,"discussions":[{"author":{"id":2317835,"avatar":"","nickname":"Geek_cead38","note":"","ucode":"7F8350E9DB040E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327513,"discussion_content":"按理来说，如果棋盘游戏很庞大，将位置也共享化是不错的选择，但是最主要的是，对于一个棋子频繁移动的话，如果是共享的，那么需要重新选取享元对象，但棋子移动仅仅是位置移动，完全可以直接更改坐标，所以没必要列入享元类","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1605854174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293723,"discussion_content":"我谈谈问题二的看法：\n看到大家都说重写CharacterStyle的hash方法，将其作为HashMap的key来存取。没错，大部分人第一反应应该都是会想到HashMap，毕竟查找效率O(1)是让人难忘的。但这里面有一个问题，重写CharacterStyle的hash方法，也就意味着无论是否服用这个CharacterStyle对象都需要创建这个对象才能获取到hash值，才能判断是否已经存在这个对象了，如果这个对象在HashMap中存在的话，虽然不会引用新创建的这个，但是，这将导致创建了大量不必要的对象仅仅是为了获取它的hash值，那么，导致JVM内存中Eden区的频繁YoungGC的代价也太大了。 \n我觉得可以将生成hash的方法也作为享元，放在工厂类中，就可以解决上述我所说的问题了。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1595648031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1330141,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","nickname":"HomeyLiu","note":"","ucode":"EF4CCB92C369B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538002,"discussion_content":"方法本身就是一个字节码,在jvm的方法区,全局一份. \n将生成hash的方法也作为享元 是多事一举.\n[，但是，这将导致创建了大量不必要的对象仅仅是为了获取它的hash值，] 这句话,创建对象本身多了一个引用的地址的开销,其他的没有多出来,仅此而已.\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639295574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293723,"ip_address":""},"score":538002,"extra":""}]},{"author":{"id":1247277,"avatar":"https://static001.geekbang.org/account/avatar/00/13/08/2d/fb0831a9.jpg","nickname":"拉环","note":"","ucode":"5F81F2746CEF61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281247,"discussion_content":"如果再进一步考虑，因为象棋格子90个，用一个byte类型就足够表示了，是否可以用byte来表示呢？内存里再存一份位置和坐标的映射，比如 值为0的时候代表x=1，y=1 值为1代表x=1，y=2","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1591700162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1247277,"avatar":"https://static001.geekbang.org/account/avatar/00/13/08/2d/fb0831a9.jpg","nickname":"拉环","note":"","ucode":"5F81F2746CEF61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403149,"discussion_content":"这个思路不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634019001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281247,"ip_address":""},"score":403149,"extra":""}]},{"author":{"id":2085090,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","nickname":"写代码的","note":"","ucode":"F58186409A3D65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305610,"discussion_content":"equals 返回 true,  hashcode 一定为相同； hashcode 相同，equals 并不一定返回ture，所以，需要注意的是，千万不能用 hashcode 当 Key，Style 当 Value。正确的方式是让 HashMap key 和 value 存放的都是 Style，同时重写 Style 的 hasocde 方法。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1600019816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1466467,"avatar":"https://static001.geekbang.org/account/avatar/00/16/60/63/d2c91e2b.jpg","nickname":"JoeyforJoy","note":"","ucode":"5598501E71D35D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370563,"discussion_content":"老哥是高手啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619449907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198564,"discussion_content":"如果是象棋，9*10=90，用享元模式不是只要初始化90个位置对象就够了？不太明白你们的意思","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583507455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1306032,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","nickname":"桂城老托尼","note":"","ucode":"139E4B8EE88B79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":220366,"discussion_content":"答主的意思是可以做，但没必要，楼上几个同学还是理解成会不会变，没有考虑到位置是可枚举的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585871067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198564,"ip_address":""},"score":220366,"extra":""},{"author":{"id":1514305,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","nickname":"xk_","note":"","ucode":"DFE1AC38EA78A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":236032,"discussion_content":"我觉得层主说的很好。享元模式是对象缓存，当对象很大的时候，缓存下来，复用可以很好的节省内存。\n\n如果用 ChessPiecePosition 每个棋局都需要有指针呐，一个象棋位置只包含两个int类型，但是一个指针大于两个int类型的存储啊。很多基本类型封装成对象，可以节省内存；但是一两个基本类型就直接使用啊，为啥要封装成对象在去使用呢？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587052312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198564,"ip_address":""},"score":236032,"extra":""},{"author":{"id":1178683,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/3b/c6b5b64f.jpg","nickname":"bboy孙晨杰","note":"","ucode":"D7389FB3368749","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1514305,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","nickname":"xk_","note":"","ucode":"DFE1AC38EA78A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236714,"discussion_content":"一个指针大于两个int类型的存储，到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587117658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":236032,"ip_address":""},"score":236714,"extra":""}]},{"author":{"id":2369438,"avatar":"https://static001.geekbang.org/account/avatar/00/24/27/9e/94aa1721.jpg","nickname":"卢磊","note":"","ucode":"8A5A531C527319","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392910,"discussion_content":"如果把位置信息放到ChessPieceUnit类中作为享元类属性呢？原来享元类会实例化30个对象，现在会实例化30*90（个位置）=2700个对象，然后所有棋盘都复用这个2700个对象，这样在棋盘特别多的场景下，也会节省内存的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631175884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203364,"discussion_content":"最主要的是Position对象，会不断变化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584024794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198135,"discussion_content":"1.补充：int基础类型也不会有new对象的开销。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583479753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198157,"discussion_content":"是的,当初java设计出8种基本类型一方面是为了节省内存开销,另一方面也是为了提升性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583482391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198135,"ip_address":""},"score":198157,"extra":""}]},{"author":{"id":2142423,"avatar":"","nickname":"Geek_7e0e83","note":"","ucode":"554DEE2AAAE33C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573917,"discussion_content":"基本数据类型比对象的内存开销要小。\n\n位置对象使用享元模式 需要创建一定数量的对象 同时还需要在棋子移动的时候进行查找。这个查找可能也需要额外的数据结构进行存储。\n\n从易维护易维护性和易读性的角度 修改位置坐标也会来的更直接一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653728640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446981,"avatar":"https://static001.geekbang.org/account/avatar/00/25/56/85/6da913fa.jpg","nickname":"LIFE l=new LIFE()","note":"","ucode":"729BACA3B7FD42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545485,"discussion_content":"set\nset\nset","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641974775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2703237,"avatar":"","nickname":"sean","note":"","ucode":"B517C6A09A4F07","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401214,"discussion_content":"老哥是高手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633604377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274180,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ3q0LkadjOv0wtVqGas3iaRZX8I2iaEH7GGZwLeibiabfbfZOgCialpMpia8lvrtN5mcic8mUrsVibibDcrag/132","nickname":"千金易","note":"","ucode":"229D8C6BBA535C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333000,"discussion_content":"请问一下，这里不开启指针压缩的计算中“补4”何解？16（对象头）+4+4+8不需要对齐吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607413235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1274180,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ3q0LkadjOv0wtVqGas3iaRZX8I2iaEH7GGZwLeibiabfbfZOgCialpMpia8lvrtN5mcic8mUrsVibibDcrag/132","nickname":"千金易","note":"","ucode":"229D8C6BBA535C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403153,"discussion_content":"java对象内存计算规则，具体可以百度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634020556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":333000,"ip_address":""},"score":403153,"extra":""}]},{"author":{"id":1323102,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","nickname":"Younger Ku","note":"","ucode":"D157DC38BDB515","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312225,"discussion_content":"怎么指针压缩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602634480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1323102,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","nickname":"Younger Ku","note":"","ucode":"D157DC38BDB515","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403154,"discussion_content":"JVM给参数 -XX:+UseCompressedOops 即可开启压缩，默认是关闭的，会进行内存对齐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634020615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312225,"ip_address":""},"score":403154,"extra":""}]},{"author":{"id":1730160,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/O3Uf8dibBnKKzibgEhvvKs9vic0dBavSJzn79fZVtH0AxcUT09bvOAYvr2f7vecmwiao7BBGgE5p8lXHSoBMdmQuBw/132","nickname":"赵","note":"","ucode":"EAC4390FD95EF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300921,"discussion_content":"直接用属性求hash值就可以了吧，没必要创建对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598319883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818287,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/be/af/93e14e9d.jpg","nickname":"扁舟","note":"","ucode":"486C0D0FAB15C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276559,"discussion_content":"满分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590901699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228518,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","nickname":"Edward Lee","note":"","ucode":"156223F1D7E94A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260595,"discussion_content":"大哥，火🔥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588867033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068372,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/54/9c214885.jpg","nickname":"kylexy_0817","note":"","ucode":"392DD9DD5E4B6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202282,"discussion_content":"没必要且不能把位置信息设计成享元吧，因为每个棋局相同棋子的位置会不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583891119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185545,"user_name":"李湘河","can_delete":false,"product_type":"c1","uid":1349528,"ip_address":"","ucode":"DB078B5DAAE82E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","comment_is_top":false,"comment_ctime":1583626960,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"169087351504","product_id":100039001,"comment_content":"补充一下，对于第二个问题，用LinkedHashMap容器并开启它的LRU策略来装CharacterStyle更好，因为根据一个使用者的习惯，常用的字体风格就是自己最近使用的。","like_count":40,"discussions":[{"author":{"id":1330509,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4d/4d/58c2ffa1.jpg","nickname":"smartjia","note":"","ucode":"704BCDE56251D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214601,"discussion_content":"此处只是缓存，好像没有用到 LRU 策略的删除功能。还是用HashMap效率更高吧","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585214030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184946,"user_name":"Xion","can_delete":false,"product_type":"c1","uid":1106053,"ip_address":"","ucode":"C07AA5981247B0","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/85/95ed73ab.jpg","comment_is_top":false,"comment_ctime":1583456872,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"74597900904","product_id":100039001,"comment_content":"1. 没有必要，每局游戏的棋子位置不是完全相同的数据，这取决于用户的输入，随着时间的推移会不断地变化。而使用享元模式保存的数据，应当是那些不变的，会被大量对象复用的数据。<br>2.可以考虑使用哈希表保存文本格式，用多出来的一点点空间占用换取O（1）的查询效率。","like_count":18,"discussions":[{"author":{"id":1651664,"avatar":"https://static001.geekbang.org/account/avatar/00/19/33/d0/962ebe2e.jpg","nickname":"Buring","note":"","ucode":"0AAEA64C63C2F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243623,"discussion_content":"棋盘不是无限大，这些位置都是死的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587553642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306032,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","nickname":"桂城老托尼","note":"","ucode":"139E4B8EE88B79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220368,"discussion_content":"位置是可枚举的，你细品","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585871140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2305812,"avatar":"https://static001.geekbang.org/account/avatar/00/23/2f/14/aaa55557.jpg","nickname":"飞拳","note":"","ucode":"1C51DB575D3156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551926,"discussion_content":"享元模式保存的数据不是死的，而是，棋子都是相同的，至于位置，那是由上下文赋予的，并不是棋子本身所具有的属性。黑棋放到哪里都是都是黑棋，至于其坐标，那个是可以实时计算的，并且该机算量并不大。可以参考我的文章：https://dev-union.cn/2021/12/17/art1217/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645176225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185326,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1583561952,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"66008071392","product_id":100039001,"comment_content":"1. 没有必要。棋盘上位置的点集是有限的，是可以设计成享元的。但我们只需要存两个很小的整数，用上享元代码就会变复杂，另外指针也要存储空间。设计成享元可以，但没有必要。<br><br>2. 用哈希表提高查询速度：将 font, size, style 连接为字符串（比如 &#39;yahei-12-123456&#39;）作为 hash 表的 key。","like_count":16,"discussions":[{"author":{"id":1609051,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","nickname":"charmsongo","note":"","ucode":"4FBEE716E93A1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556592,"discussion_content":"经常这么干","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647422211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538458,"discussion_content":"我也觉得可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639406923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307532,"discussion_content":"可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600679237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185125,"user_name":"Wh1","can_delete":false,"product_type":"c1","uid":1282715,"ip_address":"","ucode":"6D28506B99A285","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","comment_is_top":false,"comment_ctime":1583489756,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40238195420","product_id":100039001,"comment_content":"在避免创建CharacterStyle对象同时，以O(1)的时间复杂度判断CharacterStyle是否已经被创建，代码如下：<br>public class CharacterStyleFactory {<br>    private static final Map&lt;Integer, CharacterStyle&gt; styles = new HashMap&lt;&gt;();<br><br>    public static CharacterStyle getStyle(Font font, int size, int colorRGB) {<br>        &#47;&#47;key = font的哈希值 + size + colorRGB 以保证哈希值唯一性, 同时也避免了重复创建CharacterStyle的开销<br>        int key = font.hashCode() + size + colorRGB;<br>        if (styles.containsKey(key)) {<br>            return styles.get(key);<br>        }<br>        CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);<br>        styles.put(key, newStyle);<br>        return newStyle;<br>    }<br>}","like_count":10,"discussions":[{"author":{"id":1913366,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ZtPzZANysH9BrOAl7tDMBm5HFT2aqHOJGhuTzJkBW06mn64Ec85oCLgug1HgVCU3mTLBmE0dwkgwKdtMLX1Keg/132","nickname":"陈力扬","note":"","ucode":"459D188BC0A905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352809,"discussion_content":" 1 2和 2 1 加起来是一样 但是是两个意思\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614857392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2286788,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e4/c4/065f8c0c.jpg","nickname":"Tom-TTC","note":"","ucode":"36AB0797D6FD3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352418,"discussion_content":"确定算出来的key是唯一的吗？加和相同的三个数的万一出现别的组合呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614733150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185121,"user_name":"Wh1","can_delete":false,"product_type":"c1","uid":1282715,"ip_address":"","ucode":"6D28506B99A285","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","comment_is_top":false,"comment_ctime":1583488235,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"40238193899","product_id":100039001,"comment_content":"小争哥你好，采用享元模式重构的代码中，CharacterStyleFactory的getStyle()函数是不是设计的有问题。无论styles中是否存在已经创建好的享元对象，都会新建一个CharacterStyle对象。照这么看，styles岂不是根本就没有存在的必要了。<br>我认为代码应该改为如下：<br>public static CharacterStyle getStyle(Font font, int size, int colorRGB) {<br>        &#47;&#47;遍历styles, 如果styles中有相同对象, 则返回<br>        for (CharacterStyle style : styles) {<br>            if (style.equals(font, size, colorRGB)) {<br>                return style;<br>            }<br>        }<br>        CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);<br>        styles.add(newStyle);<br>        return newStyle;<br>    }","like_count":10,"discussions":[{"author":{"id":1609051,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","nickname":"charmsongo","note":"","ucode":"4FBEE716E93A1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556594,"discussion_content":"用哈希表提高查询速度：将 font, size, style 连接为字符串（比如 &#39;yahei-12-123456&#39;）作为 hash 表的 key。      直接用这种就不会出现新对象的问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647422331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2870321,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLE9hv64CEabxt76tQQcWDicx0sucpAApFvYoM8eXBViaJgz06EjcfJjiamSFWY9aAuxjILaPoiaa0lNw/132","nickname":"Soil","note":"","ucode":"3B353BC858B5AE","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":1609051,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","nickname":"charmsongo","note":"","ucode":"4FBEE716E93A1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573996,"discussion_content":"字符串的连接也是有对象产生的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653790231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":556594,"ip_address":""},"score":573996,"extra":""}]},{"author":{"id":2577340,"avatar":"https://static001.geekbang.org/account/avatar/00/27/53/bc/f0b23602.jpg","nickname":"无bug,不掉发","note":"","ucode":"1EB829F23BD891","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551497,"discussion_content":"这种写法确实好很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645025737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188906,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","nickname":"汝林外史","note":"","ucode":"3C66C0F0537A99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221923,"discussion_content":"style.equals(font, size, colorRGB)  ????这个编译都通不过吧，这是个啥？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586082149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1282715,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","nickname":"Wh1","note":"","ucode":"6D28506B99A285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1188906,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","nickname":"汝林外史","note":"","ucode":"3C66C0F0537A99","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226194,"discussion_content":"这段代码过了有段时间有点忘了，这里equals我记得我当时好像是重写了。本意是在不创建对象的基础上判断style是否存在相同对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586427671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":221923,"ip_address":""},"score":226194,"extra":""},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1188906,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","nickname":"汝林外史","note":"","ucode":"3C66C0F0537A99","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290292,"discussion_content":"他连equals也改了，入参直接将元数据传入去做比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594397343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":221923,"ip_address":""},"score":290292,"extra":""}]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199002,"discussion_content":"你这样的确是优化了，但是争哥那种写法的话，如果getStyle方法执行结束，没有用到的对象就会被gc，也还可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583547684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1282715,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","nickname":"Wh1","note":"","ucode":"6D28506B99A285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201147,"discussion_content":"我的意思是创建对象这个过程的开销能避免就尽量避免  gc是后面的工作了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583763155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199002,"ip_address":""},"score":201147,"extra":""},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1282715,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","nickname":"Wh1","note":"","ucode":"6D28506B99A285","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201403,"discussion_content":"你的写法的确好点👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583796944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":201147,"ip_address":""},"score":201403,"extra":""}]}]},{"had_liked":false,"id":184964,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1583459227,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"31648230299","product_id":100039001,"comment_content":"前面看的时候就在想感觉有点像连接池，当看到一个“共享使用”，一个“重复使用”时真是有种恍然大悟的感觉","like_count":8,"discussions":[{"author":{"id":1232468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ce/54/c13b1d63.jpg","nickname":"二十四桥仍在","note":"","ucode":"5498FE5949190F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227202,"discussion_content":"你在想一下，其实是一样的😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586477214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1232468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ce/54/c13b1d63.jpg","nickname":"二十四桥仍在","note":"","ucode":"5498FE5949190F","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":306919,"discussion_content":"不一样，前者有点像一个公用件，比如公司的空调。后者是一个资源，重复有先后的使用，比如公司的打印机","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1600418505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227202,"ip_address":""},"score":306919,"extra":""},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1232468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ce/54/c13b1d63.jpg","nickname":"二十四桥仍在","note":"","ucode":"5498FE5949190F","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":346519,"discussion_content":"一个是同时共用，一个是一个个换着使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611979288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227202,"ip_address":""},"score":346519,"extra":""},{"author":{"id":1679661,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a1/2d/599e9051.jpg","nickname":"CycleGAN","note":"","ucode":"9FD04813911A02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541670,"discussion_content":"精准","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640511406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306919,"ip_address":""},"score":541670,"extra":""}]}]},{"had_liked":false,"id":247614,"user_name":"天草二十六","can_delete":false,"product_type":"c1","uid":1360712,"ip_address":"","ucode":"3165EE3007527B","user_header":"https://static001.geekbang.org/account/avatar/00/14/c3/48/3a739da6.jpg","comment_is_top":false,"comment_ctime":1599774412,"is_pvip":false,"replies":[{"id":"91487","content":"������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1600670992,"ip_address":"","comment_id":247614,"utype":1}],"discussion_count":5,"race_medal":0,"score":"27369578188","product_id":100039001,"comment_content":"难道就我一个人有疑问？象棋不是总共32个棋子吗，争哥咋说30个享元对象？","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505453,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600670992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1495977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d3/a9/36e59707.jpg","nickname":"行道有德","note":"","ucode":"92B2A5A6E8E7C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580724,"discussion_content":"你这角度有点刁钻啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658364373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403155,"discussion_content":"细节是魔鬼，老哥厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634020719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359420,"discussion_content":"握爪 我还特意百度是不是30个 哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616173300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322747,"discussion_content":"哈哈哈哈哈哈哈，终于有人问这个问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604812599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187511,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1584149951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23058986431","product_id":100039001,"comment_content":"private void init() {<br>        chessPieces.put(1, new ChessPiece(<br>                ChessPieceUnitFactory.getChessPiece(1), 0,0));<br>        chessPieces.put(1, new ChessPiece(<br>                ChessPieceUnitFactory.getChessPiece(2), 1,0));<br>        &#47;&#47;...省略摆放其他棋子的代码...<br>    }<br><br>这段代码的第2个put的key应该是2吧","like_count":5},{"had_liked":false,"id":186964,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583979895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23058816375","product_id":100039001,"comment_content":"<br>对于问题一,首先说,围棋棋盘有361个点,如果将位置封装成享元模式,要封装361个对象,如果拥有大量的棋盘去共享这些位置,那么是可以节省内存的,但是我个人倾向于不使用享元,我们来表示位置的数据类型是int,有本身自带的享元对象池,做到了一定的复用,不需要占用太多的内存,而且使用享元对象,在查找享元对象的过程,也需要消耗一定的时间,所以没有必要去为了4个字节浪费那么多的事情<br>对于问题二,这就是一个简单的空间换时间的问题,时间耗时长,那么就用一个空间问题来解决,可以使用一个散列表来进行相关的存储,在Java中更是简单,直接使用Map对象即可","like_count":5},{"had_liked":false,"id":184990,"user_name":"hhhh","can_delete":false,"product_type":"c1","uid":1256101,"ip_address":"","ucode":"9E87017424B382","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/a5/625c0a2e.jpg","comment_is_top":false,"comment_ctime":1583463704,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23058300184","product_id":100039001,"comment_content":"课后思考题:<br>1. position可以使用享元模式，但是对于位置信息而言，两个short类型的整数可以表示, 大量的位置信息也不会占据太多的存储空间，使用享元模式一定程度上增加了代码实现的复杂度，造成move() 方法代码不够直观<br>2. 重写CharacterStyle 的hashcode()方法，使用map作为对象池，map的key就是hashcode()的值","like_count":5,"discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199237,"discussion_content":"你好，关于思考题1你的解答，我觉得用short不会更省空间，因为内存要对齐（padding），具体计算方法 16 overhead + 2 + 2 + 4 (padding) = 24字节，和用int表示位置是一样的内存 （6 overhead + 4 + 4 = 24）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583574104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1274180,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ3q0LkadjOv0wtVqGas3iaRZX8I2iaEH7GGZwLeibiabfbfZOgCialpMpia8lvrtN5mcic8mUrsVibibDcrag/132","nickname":"千金易","note":"","ucode":"229D8C6BBA535C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":333006,"discussion_content":"开启了指针压缩就是12+2+2 = 16字节了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607415399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199237,"ip_address":""},"score":333006,"extra":""}]}]},{"had_liked":false,"id":184978,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1583461312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23058297792","product_id":100039001,"comment_content":"打卡 今日学习享元设计模式，收获如下：<br>当某个需求中有大量的对象是相似的（或者对象中的某些属性是类似的），且是不可变的，此时可以使用享元设计模式将其进行缓存起来以达到共享使用，节省内存。<br>个人觉得享元模式体现了DRY原则，DRY原则是说不要写重复的代码，应用到对象存储方面，可以理解为不要存储相同的数据。","like_count":5},{"had_liked":false,"id":296292,"user_name":"百川","can_delete":false,"product_type":"c1","uid":2015066,"ip_address":"","ucode":"BCC9D224C09CD6","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bf/5a/824a5e46.jpg","comment_is_top":false,"comment_ctime":1622886125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18802755309","product_id":100039001,"comment_content":"一万个棋局，虽然只有 30个 ChessPieceUnit 了，但是不是依然有 30万个 ChessPiece呢？","like_count":5},{"had_liked":false,"id":188464,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1584357666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18764226850","product_id":100039001,"comment_content":"关于思考题1，感觉将位置设置成享元也可以啊，因为棋盘的位置是有限且固定的","like_count":4},{"had_liked":false,"id":186216,"user_name":"zx","can_delete":false,"product_type":"c1","uid":1059177,"ip_address":"","ucode":"444F6FF495BC2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/29/69/c1575a7a.jpg","comment_is_top":false,"comment_ctime":1583802951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18763672135","product_id":100039001,"comment_content":"对于百万在线的系统，棋盘的位置数量是有限的，可以设计为享元模式","like_count":4},{"had_liked":false,"id":262820,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1605852369,"is_pvip":false,"replies":[{"id":"96119","content":"嗯嗯 ������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700916,"ip_address":"","comment_id":262820,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14490754257","product_id":100039001,"comment_content":"1. 第一个问题看需求，如果像象棋类的网格棋，可以考虑享元模式<br>2. map存储，减少迭代查找","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509983,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207361,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1587054649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14471956537","product_id":100039001,"comment_content":"像连接池、线程池。我们使用它们的时候，在初始化时会创建好连接或者是线程，在使用的时候就可以直接使用，不需要创建了，节省了创建的时间。<br><br>享元模式是共享对象的，是存在于内存中，在设计模式出来的时候，内存条可是嗷嗷贵的啊！在当时节省一点内存，真的是非常高大上的一件事了！","like_count":3},{"had_liked":false,"id":287326,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1617884163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10207818755","product_id":100039001,"comment_content":"虽然设计模式和设计模式之间非常的相似，但是设计他们的初衷就是为了解决某一个特定问题的，不要用混了。<br>越来越专业的标准是越来越知道边界。","like_count":2},{"had_liked":false,"id":235201,"user_name":"SeamanW","can_delete":false,"product_type":"c1","uid":1683192,"ip_address":"","ucode":"477CE695121A04","user_header":"https://static001.geekbang.org/account/avatar/00/19/ae/f8/2860ac98.jpg","comment_is_top":false,"comment_ctime":1594943872,"is_pvip":true,"replies":[{"id":"87057","content":"是个值得讨论的问题~","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1595205865,"ip_address":"","comment_id":235201,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10184878464","product_id":100039001,"comment_content":"要不要把文字编辑器中的文字设计成享元呢？<br>正方：常用汉字也就3000多个，超过3000字原则上就需要<br>反方：设计成享元能节省多少空间呢？或者会不会更浪费空间？<br>哈哈😄","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501637,"discussion_content":"是个值得讨论的问题~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595205865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197484,"user_name":"change","can_delete":false,"product_type":"c1","uid":1110876,"ip_address":"","ucode":"D78B4B3752B6FE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/5c/8704e784.jpg","comment_is_top":false,"comment_ctime":1585381418,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"5880348714","product_id":100039001,"comment_content":"1、享元即可共享的单元,目的是为了复用对象,节省内存,前提条件是对象不可变;<br>2、借助于工厂模式,用List或Map缓存已经创建的享元对象,以达到复用的目的;<br>3、享元模式 VS 单例模式、缓存、池化技术:不仅看代码实现,还要看设计意图(即解决的问题)<br>    3.1、单例只能创建一个对象,多例虽然可以创建多个对象,其目的是为了限制对象的个数,享元模式可创建多个对象,且一个对象可被代码多个地方调用,其目的是复用对象,节省内存;<br>    3.2、缓存是为了提供访问效率,而不是节省内存够;<br>    3.3、池化技术虽然也是为了复用(重复使用),但是是为了节省时间,而享元模式的复用(共享使用),为了节省空间;","like_count":1},{"had_liked":false,"id":186610,"user_name":"kylexy_0817","can_delete":false,"product_type":"c1","uid":1068372,"ip_address":"","ucode":"392DD9DD5E4B6E","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/54/9c214885.jpg","comment_is_top":false,"comment_ctime":1583891161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878858457","product_id":100039001,"comment_content":"对于第一个问题，个人认为没必要且不能把位置信息设计成享元吧，因为相同棋子在不同的棋局位置都可能不一样","like_count":1},{"had_liked":false,"id":184912,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1583451664,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5878418960","product_id":100039001,"comment_content":"棋牌中的位置也可以设置为享元，因为棋盘上位置个数有限，使用享元也可以节省内存","like_count":1,"discussions":[{"author":{"id":1056982,"avatar":"https://static001.geekbang.org/account/avatar/00/10/20/d6/b9513db0.jpg","nickname":"kingcall","note":"","ucode":"508884DC684B5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219583,"discussion_content":"我也是这么想的，每次棋子的移动，就是选择新的位置享元，但是好像没有什么优势","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585786771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184908,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1583449070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878416366","product_id":100039001,"comment_content":"要点总结<br>1 代码实现主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。<br>2  应用单例模式是为了保证对象全局唯一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。<br>思考题:<br>①位置在棋盘中组合方式比较多变，不适合做成享元<br>② 可以考虑使用map存放style数据","like_count":1},{"had_liked":false,"id":350013,"user_name":"小牛人","can_delete":false,"product_type":"c1","uid":1001700,"ip_address":"","ucode":"D5623BC72BF5F4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/e4/974c38d0.jpg","comment_is_top":false,"comment_ctime":1656504417,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656504417","product_id":100039001,"comment_content":"所以享元模式可以用枚举来替代","like_count":1},{"had_liked":false,"id":348183,"user_name":"Broadm","can_delete":false,"product_type":"c1","uid":1737886,"ip_address":"","ucode":"BEA06300731AE8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/84/9e/d4c0e2c4.jpg","comment_is_top":false,"comment_ctime":1654828438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654828438","product_id":100039001,"comment_content":"象棋中有90个位置, 每个棋子的位置 int x, int y  占用 8个字节<br>如果同时有一万个棋局 <br><br>不使用享元的话, 就是   10000(棋局数) * 32(每个棋局棋子数) * 8(每个棋子位置占8字节) = 2560000 字节 = 2500KB ≈  2.44MB<br><br>使用享元的话 ,  把90个位置做成享元,就是 90 *  8 = 720 字节 (不到1K,可以忽略不计入下面的计算中)<br>10000(棋局数) * 32(每个棋局棋子数) * 4(每个棋子引用享元,存的享元的地址)  ≈  1.22MB<br><br>100万棋局就是  244M  和 122M<br><br>所以要看业务规模情况, 正常棋牌游戏能有1万人同时在线就不错了,所以可以不使用享元模式<br>","like_count":0},{"had_liked":false,"id":337958,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1647181373,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1647181373","product_id":100039001,"comment_content":"棋牌游戏的案例举的太牵强了，棋子和扑克，都是不可变对象，既然不可变。我从事了几年棋牌游戏开发，都是用具体的数字代表某个牌或者棋子。扑克牌的设计非常精妙，使用十六进制表示，例如 01，12，23，34 分别代表红桃A，黑桃2，方块3，梅花4。麻将牌也是类似的，这里的设计用不到享元，也没必要用。","like_count":0},{"had_liked":false,"id":333908,"user_name":"打工人的精神领袖","can_delete":false,"product_type":"c1","uid":2342014,"ip_address":"","ucode":"8EC3864768368D","user_header":"https://static001.geekbang.org/account/avatar/00/23/bc/7e/c1422d90.jpg","comment_is_top":false,"comment_ctime":1644575540,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644575540","product_id":100039001,"comment_content":"例子里边的棋子可以直接用枚举类写吗","like_count":0},{"had_liked":false,"id":318430,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1635298697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635298697","product_id":100039001,"comment_content":"CharacterStyleFactory 类的 getStyle() 方法里面可以使用散列表存储，这样可以快速判断是否存在。","like_count":0},{"had_liked":false,"id":315837,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634018705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634018705","product_id":100039001,"comment_content":"思考题：<br>1.不能。因为享元模式，针对不可变对象，这里位置会不断发生变化。虽然每个位置的坐标是固定的，但是棋子时移动的，根据相对论，这里的位置相对就是变化的。如果把位置设置成享元，棋子对象需要频繁的去position工厂获取新的对象，成本很高。<br>2. 在获取style，因为常用样式不多，可以将style存在hash表中，每次只需要从hash表判断是否存在，不用每次遍历。","like_count":0},{"had_liked":false,"id":314890,"user_name":"嘉兴宁波体检代检绍兴温州体检代检","can_delete":false,"product_type":"c1","uid":2797921,"ip_address":"","ucode":"621B4364B6C6C9","user_header":"https://static001.geekbang.org/account/avatar/00/2a/b1/61/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1633531102,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1633531102","product_id":100039001,"comment_content":"不就是枚举类么","like_count":0,"discussions":[{"author":{"id":2342014,"avatar":"https://static001.geekbang.org/account/avatar/00/23/bc/7e/c1422d90.jpg","nickname":"打工人的精神领袖","note":"","ucode":"8EC3864768368D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550523,"discussion_content":"象棋你可以枚举,但是如果是字符串或者其他不确定对象怎么写枚举类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644575799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302138,"user_name":"cake","can_delete":false,"product_type":"c1","uid":1966533,"ip_address":"","ucode":"55A7FC6CC1204C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/01/c5/b48d25da.jpg","comment_is_top":false,"comment_ctime":1626095988,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1626095988","product_id":100039001,"comment_content":"重写了equal 不重写hash方法吗","like_count":0,"discussions":[{"author":{"id":2699218,"avatar":"","nickname":"Geek_279849","note":"","ucode":"FC6A3514FC955C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556731,"discussion_content":"用map才需要，这里用的list","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647488480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297512,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1623589419,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1623589419","product_id":100039001,"comment_content":"课堂讨论一：没必要，因为享元模式的意图是复用对象，节省内存，而 ChessPiecePosition 不是不可变对象。<br>课堂讨论二：CharacterStyle 重写 hash 方法，用 map 来存储，hash 值为 key，CharacterStyle 为 value，查询时创建新的对象来获取 hash 值，如果该值已存在，那就直接返回，否则就添加到map再返回。","like_count":0},{"had_liked":false,"id":286399,"user_name":"Mirss.zhao","can_delete":false,"product_type":"c1","uid":1330632,"ip_address":"","ucode":"4A8F20B1A9D142","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItudDLPfbZabQLjk1NE8NSibQocdRy88rerQdxHFKx4KzUyaEnSLPbszcKAaPX8NgG3sHbZXib41aQ/132","comment_is_top":false,"comment_ctime":1617280878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617280878","product_id":100039001,"comment_content":"池化技术中的复用对象是可变的吧？","like_count":0},{"had_liked":false,"id":281721,"user_name":"御风","can_delete":false,"product_type":"c1","uid":1812807,"ip_address":"","ucode":"51C8212BE06364","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg","comment_is_top":false,"comment_ctime":1614858926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614858926","product_id":100039001,"comment_content":"&quot;创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，&quot;<br>那么，<br>享元模式的实现通过工厂模式事先创建好对象，达到复用和节省内存目的，应该归为创建型啊。","like_count":0},{"had_liked":false,"id":261433,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1605334504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605334504","product_id":100039001,"comment_content":"棋局变化万千。。 做成享元模式有点违背节省内存的初衷吧","like_count":0},{"had_liked":false,"id":216166,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1589198883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589198883","product_id":100039001,"comment_content":"感觉享元更像创建型","like_count":0},{"had_liked":false,"id":215006,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1588867220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588867220","product_id":100039001,"comment_content":"连接池的对象获取需要考虑并发，享元模式中的共享对象则不需要","like_count":0},{"had_liked":false,"id":214410,"user_name":"Wizard","can_delete":false,"product_type":"c1","uid":1916084,"ip_address":"","ucode":"EEC2AC00BBED06","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3c/b4/60e20977.jpg","comment_is_top":false,"comment_ctime":1588743033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588743033","product_id":100039001,"comment_content":"享元的共享有點類似資料庫為了減少資料冗余範式的概念，透過共通資料提出變成新的表，使在更新，刪除，上有更大的靈活度，例如用戶的個人資料，如果有使用到的地方都要複製一份，那就會變成資料冗余了","like_count":0},{"had_liked":false,"id":213085,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1588298751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588298751","product_id":100039001,"comment_content":"没有必要：如果设置为享元有排列组合的多重性，如果不设置，则是整体与位置组合，能大大的减少组合带来的风险，对于性能，我觉得可以用二分查找，和hash函数（map）存储","like_count":0},{"had_liked":false,"id":212984,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1588255559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588255559","product_id":100039001,"comment_content":"对于问题二，是不是就是Windows下如果安装了太多字体，点击word获取的字体的时候导致过慢的原因？","like_count":0},{"had_liked":false,"id":212551,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1588146641,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588146641","product_id":100039001,"comment_content":"享元大部分场景是等于多例模式，和单例还是有区别的，单例要的是控制进程内唯一对象，享元一般的场景是同一个对象大家一起用，比如扑克牌、棋子。一般都不会只有一个对象","like_count":0},{"had_liked":false,"id":207852,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1587197502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587197502","product_id":100039001,"comment_content":"享元： 共享单元，也就是把大量重复的对象，通过工厂函数创建出来，然后通过引用，达到复用的目的。<br><br><br>我想了一下，好像前端这个模式基本上用不上，因为很少涉及大量的数据（起码我是这样）。也就基本上用不上这个模式。","like_count":0},{"had_liked":false,"id":206914,"user_name":"张钟强","can_delete":false,"product_type":"c1","uid":1586908,"ip_address":"","ucode":"EE0D5CAEDBBAC8","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/dc/97369381.jpg","comment_is_top":false,"comment_ctime":1586956361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586956361","product_id":100039001,"comment_content":"问题1：应该需要看同一时间点的局数，如果局数达到一定量的话，所占用的内存会比棋子位置和棋子样式排列组合占用的内存多。","like_count":0},{"had_liked":false,"id":201685,"user_name":"全炸攻城狮","can_delete":false,"product_type":"c1","uid":1315968,"ip_address":"","ucode":"DB437F9190575C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZIqY4cs6YKNx0OqeMrbjLIicqiafLNtLYJTN2zTtVPlwXZ7qlJ7xrGQictk1xCq5pEsIyqnkiaCib4zQ/132","comment_is_top":false,"comment_ctime":1585820664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585820664","product_id":100039001,"comment_content":"从享元模式的应用来看，是从会大量创建的目标对象里，抽离出了部分属性（他们的特点是固定或者值的类型有限），这部分属性又封装成一个属性对象，通过工厂模式创建后缓存在list或map中。用到对象的时候，从缓存中取出这个属性对象组装成我们需要的目标对象。节省的空间就集中在这个属性对象这里","like_count":0},{"had_liked":false,"id":197833,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1585400109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585400109","product_id":100039001,"comment_content":"JAVASCRIPT中对象共享属性的实现有些类似享元模式，把对象的共有属性放在构造函数的prototype属性引用的对象上。只不过JS中prototype属性的属性是可以动态变化的。推测在C++代码实现时，也是利用Map 或者 List 来缓存已经创建好的共有属性的。","like_count":0},{"had_liked":false,"id":197072,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585356368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585356368","product_id":100039001,"comment_content":"第一个，没必要。<br>第二个，可以考虑使用hashmap，查找效率高一些。","like_count":0},{"had_liked":false,"id":196238,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1585265588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585265588","product_id":100039001,"comment_content":"我看到享元模式的第一反应是原型模式，感觉都是抄作业：享元模式，是看着别人的作业抄都懒得抄，直接拿过来上交。原型模式，抄别人作业，写上自己的名字","like_count":0},{"had_liked":false,"id":193137,"user_name":"辉哥","can_delete":false,"product_type":"c1","uid":1236983,"ip_address":"","ucode":"21A65F4EE6CD04","user_header":"","comment_is_top":false,"comment_ctime":1584884636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584884636","product_id":100039001,"comment_content":"针对于第二个问题，可以重写CharacterStyle的hashCode方法，然后使用hashMap以hashCode为key,CharacterStyle对象为value来缓存。当调用getStyle方法时，先用CharacterStyle对象的hashCode去查找hashMap是否有缓存该对象，有就去判断equals是否为true，为true就返回hashMap中的对象。hashMap查询为null或者equals为false,则把对象加入hashMap中，并返回该对象","like_count":0},{"had_liked":false,"id":189874,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1584579099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584579099","product_id":100039001,"comment_content":"一直以来误解享元模式==单例","like_count":0},{"had_liked":false,"id":189400,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584512356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584512356","product_id":100039001,"comment_content":"关于思考题<br>1. 我觉得没得必要 享元模式 最主要的就是保存和共享不可变的对象 对于position这中随时都在变的对象不合适 而且每个棋局的棋子坐标各不相同(享元模式 主要是通过对共同的不可变的对象或者字段进行抽取已达到节省内存的目的)<br>2. 从代码上来看 可以把三个条件通过一个hash处理 出一个hash值再做映射 即可达到o(1)","like_count":0},{"had_liked":false,"id":188921,"user_name":"茄子","can_delete":false,"product_type":"c1","uid":1333754,"ip_address":"","ucode":"2A3BCB54C445AB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGAv9yLQICso1yfY7HVmRHibl3MHIibhj6eevkUp1eX8UeBjx0kaKzxOibIt9xYHycGmfSGcE1EU2Fw/132","comment_is_top":false,"comment_ctime":1584434202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584434202","product_id":100039001,"comment_content":"getStyle() 方法每次都会创建一个新的 CharacterStyle 对象，这代码难道没有问题吗？","like_count":0},{"had_liked":false,"id":188513,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1584363359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584363359","product_id":100039001,"comment_content":"设计模式_54:<br># 作业<br>1. 不合适，我看到很多留言分析了内存的占用，说的很有道理，只是享元模式的使用场景是不变的内容，position数据是随着时间变化的，本来直接给position赋值即可，现在要在已知position的情况下，找到value就是position的享元对象，毫无必要的步骤。<br>2. 可以使用散列表存储，@李湘河 同学的答案特别好，使用LinkedHashMap并开启LRU策略，很好的细节。<br><br># 感想<br>保证正确的前提下，我们可以根据需求做一些优化：比如为了更快的运行速度多消耗一些内存，也可以为了更小的内存消耗共享不可变对象。","like_count":0},{"had_liked":false,"id":188496,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1584361269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584361269","product_id":100039001,"comment_content":"思考题 1: 没有必要, 因为他们不属于大量重复的对象 2. 可以用 map 存储, 重写 hashcode, 用 hash 作为 key","like_count":0},{"had_liked":false,"id":188461,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1584357185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584357185","product_id":100039001,"comment_content":"1、从业务需求上考虑，每个棋局棋子的位置大都不同，没必要将chessPiecePosition设计成享元。2、用hashmap","like_count":0},{"had_liked":false,"id":185981,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1583736488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583736488","product_id":100039001,"comment_content":"spring的对象注入是复用对象它是用了享元模式么? 感觉文中示例代码中的工厂模式也不是必须的;如果不用工厂模式直接把ChessPiece注入到ChessBoard那么还是享元模式么? <br>","like_count":0},{"had_liked":false,"id":185941,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1583728463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583728463","product_id":100039001,"comment_content":"问题1：没有必要，因为他们不属于大量重复或者相似对象。<br>问题2: map存储最近几种常用的字体（LRU），如果寻找不到，再进行遍历去找。<br>","like_count":0},{"had_liked":false,"id":185904,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1583722811,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583722811","product_id":100039001,"comment_content":"课后题1:没必要,原因是:使用享元模式的目的是节省内存,然而在当前场景下优势并不明显,以下为个人测试所得<br>使用工具类:版本为4.0.0的lucene-core包中的RamUsageEstimator,使用方法为shallowSizeOf()<br>测试环境:64位oracle JDK 1.8.0_181 ,默认开启压缩指针(可以在测试类中打断点,然后用jps找到当前测试类的pid,用 jinfo pid 查看是否有参数-XX:+UseCompressedOops,有此参数则为开启着压缩指针)<br>测试说明:因为引用类型String,Color枚举类已经存在享元模式,所以在以下只计算对象ChessPiece,ChessPieceUnit的大小,不包含他们内部引用类型的大小<br>在开启压缩指针的情况下:int类型长度为4字节,引用类型长度为4字节<br>解释:<br>案例一中的ChessPiece大小为:12(markword+klass)+4+4+4+4+4=32 Bytes<br>案例二中的ChessPieceUnit大小为:12(markword+klass)+4+4+4=24 Bytes<br>案例二中的ChessPiece大小为:12(markword+klass)+4+4+4=24 Bytes<br>基于以上,在有一万场对局的情况下:<br>案例一: 32*30*10000 = 9600000 bytes = 9375 kb<br>案例二: 24*30+24*30*10000 = 7200720 bytes = 7032 kb<br>也就是说,如果以上逻辑没有错的话,案例二只比案例一节省了3mb左右的内存,优势并不明显","like_count":0},{"had_liked":false,"id":185499,"user_name":"李湘河","can_delete":false,"product_type":"c1","uid":1349528,"ip_address":"","ucode":"DB078B5DAAE82E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","comment_is_top":false,"comment_ctime":1583594363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583594363","product_id":100039001,"comment_content":"问题1：没必要，位置信息一直在变，不符合使用享元模式的特征；<br>问题2：由于常用的字体格式就是那么几种，这里可以使用LRU队列存储；","like_count":0},{"had_liked":false,"id":185467,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1583587962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583587962","product_id":100039001,"comment_content":"课堂讨论题<br>第一题，  我的回答是:没必要，这是因为一个指针在64位机器上的大小一般是是8个字节，而棋盘的位置信息，我估计可以用一个短整形来表示，一个短整形占用字节数大概就是2个字节到4个字节，所以一个坐标占用的大小都没超过一个指针的内存大小。 <br>这道题总的来说，要不要用享元模式，主要是看能节约多少内存，如果节约不了或者节约没多少的话就没有这个必要了。<br><br>第二题，万能的散列表又来了，可以把多个属性的内容转成一个哈希，作为key放到跑列表里，这样就能快速访问了。。。😹","like_count":0},{"had_liked":false,"id":185459,"user_name":"Jemmy","can_delete":false,"product_type":"c1","uid":1007330,"ip_address":"","ucode":"A979F4A5210225","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/e2/1fad3052.jpg","comment_is_top":false,"comment_ctime":1583587030,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583587030","product_id":100039001,"comment_content":"最近看在Redis源码，有个这个全局对象，感觉用的就是享元模式：<br>&#47;&#47; server.c<br>struct sharedObjectsStruct shared;","like_count":0,"discussions":[{"author":{"id":1026637,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/4d/c7df89bf.jpg","nickname":"宝宝疯","note":"","ucode":"D86F5A645FE61B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71105,"discussion_content":"在一个大家都只会使用贫血模型的环境里编写充血模型的代码，估计会被鄙视的😂","likes_number":23,"is_delete":false,"is_hidden":false,"ctime":1575386465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1693576,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d7/88/7dcde249.jpg","nickname":"庄周梦蝶","note":"","ucode":"7878ED3EB11E97","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359291,"discussion_content":"如果充血模型中的模型没设计好，有冗余属性，要想完全吃透业务，最终还是要看底层存储层的设计。\n从另一个方面说，存储层结构的设计，决定了项目的底子。DDD玩出花样还是得向底层存储低头，很多时候的难点不是模型的设计，而是各种技术的结合使问题。用，性能问题，效率问题。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1616158777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1611025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","nickname":"沈康","note":"","ucode":"02AFA50738AB8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68011,"discussion_content":"同意，现贫血模型的一条链路的业务代码到处都是，最坑的地方就是多个业务类存在抽取公共的部分复用，导致完全没有业务领域的概念。\nddd的我理解就是把业务逻辑[方法]封装在一个领域内,而不关注业务数据来源[字段],统一由业务层负责组装[与data层交互]","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1575195314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139367,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/a7/3e6fee86.jpg","nickname":"K战神","note":"","ucode":"527E6BB26BB766","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320812,"discussion_content":"想起了马丁福乐的一个观点，如果要用DDD，那就先习惯用充血模型吧。很多业务逻辑在抽离到模型中，会有一些思考，这个属不属于他？这个会不会公用？伴随着这些思考，会让模型边界越来越明显，职责也越来越清晰，自己的代码描述也会越来越优雅。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1604483714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132356,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","nickname":"秋风画扇","note":"","ucode":"5BCBC1422C51EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210876,"discussion_content":"抽象模型使得业务逻辑高内聚，看起来更完整。关于其他交互则由service实现，从代码结构设计上也是很清晰","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1584786610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1270902,"avatar":"https://static001.geekbang.org/account/avatar/00/13/64/76/05049c2f.jpg","nickname":"山下小妖","note":"","ucode":"57FEBC09216A36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82001,"discussion_content":"充血模型是业务的精确抽象，说的太好了。在该抽象的地方用充血模型来处理，在不需要抽象只需要数据传递的地方用贫血模型来处理。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1576308111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1055334,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","nickname":"苦行僧","note":"","ucode":"726024A9A9CF44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1270902,"avatar":"https://static001.geekbang.org/account/avatar/00/13/64/76/05049c2f.jpg","nickname":"山下小妖","note":"","ucode":"57FEBC09216A36","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100430,"discussion_content":"充血模型是业务的精确抽象，说的太好了, 我也非常赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577259606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":82001,"ip_address":""},"score":100430,"extra":""}]},{"author":{"id":1903190,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0a/56/eee89103.jpg","nickname":"罗ྂ杰ྂ","note":"","ucode":"3277C09D7D38C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203204,"discussion_content":"充血模型是业务的精确抽象。赞","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1584009590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334583,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5d/37/061e7fac.jpg","nickname":"小苗晓雪","note":"","ucode":"B15FDF455853D2","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540784,"discussion_content":"完全同意您的看法 , 充血模型说到底就是极致的收敛业务逻辑到该业务逻辑真正该处于的那块业务模型中 , 让每一层每一个 bean 都活起来! 如果一个人真正用心读代码读进去了 , 不可能喜欢那种大块堆叠到service 层的代码 , 那种代码只是你当时读起来比较顺 , service 层方法一多起来 , 你看代码根本捋不过来 , 我看完文章后觉得自己一定要有这种收敛封装的意识 , 各司其职 , 单一职责都要体现出来 , 不能总是向写业务那样一通写 , 那样的代码毫无质量 , 整个人也毫无成就感!","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1640166798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1067933,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4b/9d/e2059bce.jpg","nickname":"时间道","note":"","ucode":"6A8279F2087135","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308206,"discussion_content":"贫血模型中service层如果按照use case的方式实现，也还是很好了解业务的，毕竟case就那么多","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600869312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020529,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/71/9fd7cd7a.jpg","nickname":"Daniel","note":"","ucode":"282E09B3146501","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1067933,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4b/9d/e2059bce.jpg","nickname":"时间道","note":"","ucode":"6A8279F2087135","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364848,"discussion_content":"后期要在service层中，加个幂等性，缓存，RPC... 的一些附加功能，代码就不这么简洁了，可读性会特别差","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617628806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":308206,"ip_address":""},"score":364848,"extra":""}]},{"author":{"id":1386315,"avatar":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","nickname":"Rover","note":"","ucode":"7575EC91F45B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548688,"discussion_content":"业务内聚由领域服务转移到了领域模型中","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643332333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1999235,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/81/83/f93b1e62.jpg","nickname":"peaceForce","note":"","ucode":"98A318930DDC9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374757,"discussion_content":"写得很好, 思路清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621336828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341099,"discussion_content":"有道理\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610289647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242401,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/21/17814610.jpg","nickname":"山东哥哥帅","note":"","ucode":"6BBEA84359262F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327800,"discussion_content":"总结的太到位了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605954758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1443201,"avatar":"https://static001.geekbang.org/account/avatar/00/16/05/81/9d3907f4.jpg","nickname":"Rhinos HiL.","note":"","ucode":"F5EFF01D7ED7A2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305338,"discussion_content":"有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599882982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112490,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","nickname":"龙猫","note":"","ucode":"FD726CC969EF9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296467,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596550197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296152,"discussion_content":"这个思路很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596461739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400902,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/46/711336e6.jpg","nickname":"莫墨默","note":"","ucode":"6E1171B260A4AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295620,"discussion_content":"“精准抽象”，总结精准","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596264512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021539,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","nickname":"捞鱼的搬砖奇","note":"","ucode":"2FD194C4DA26E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294078,"discussion_content":"感谢总结，学习了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595775773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526428,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epMicvN0PDCMibmBvwAyoScCjjgfLBWaQwGic9ialXObicxKib9X0T0gx02gL4jqvibEr1FRzMaiaicN8cgEBg/132","nickname":"Geek_ac4080","note":"","ucode":"E2C480962E6CEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293769,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595663338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287666,"discussion_content":"Redis？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593505563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287660,"discussion_content":"请问虚拟钱包系统，不直接和数据库等媒介交互，虚拟钱包的载体在什么地方呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593505181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301892,"discussion_content":"只在内存中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598699900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287660,"ip_address":""},"score":301892,"extra":""}]},{"author":{"id":1049703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/67/b31afa12.jpg","nickname":"wakie","note":"","ucode":"0533AE496ADFB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281340,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591714284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311947,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/xysT7OH4SrD4sv944ndDv5tnJOk5na37Gxd5owGWsE7ON7AVW0ibnYGNRoZd0ibLWhFVXLLjOB5QFxwjo0EGIkoQ/132","nickname":"雨下不停","note":"","ucode":"0893B9C249E48A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234575,"discussion_content":"有见识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586966618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321016,"avatar":"https://static001.geekbang.org/account/avatar/00/14/28/38/d93928e0.jpg","nickname":"yh","note":"","ucode":"64FFFB8A5DB979","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215829,"discussion_content":"\n精准抽象解释的非常到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585388238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1922242,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/54/c2/17512f7a.jpg","nickname":"banxiaobu","note":"","ucode":"0FC00E5E90ACB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213260,"discussion_content":"总结到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585061942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622209,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c0/c1/414d5d1b.jpg","nickname":"_yh葱","note":"","ucode":"FA899711E91113","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202121,"discussion_content":"精准抽象解释的非常好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583864810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1224708,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZpzZqvib4bzgfFb6Wt7fP2k4wefKYaoPwza1L19UGalddjREELPd6zAjyibdHJ7jxB2xtZmSuJjuA/132","nickname":"seele","note":"","ucode":"1824AA95FF1DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177320,"discussion_content":"谢谢带佬指点一波","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582094373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194535,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/27/6bb0bb01.jpg","nickname":"随机的","note":"","ucode":"D8319136F27CBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71937,"discussion_content":"说的很好，我想试一试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575466033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66765,"discussion_content":"mark,说的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575105413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185397,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1583574143,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583574143","product_id":100039001,"comment_content":"享元模式：复用不变对象节省空间。<br><br>何时使用：系统中存在大量重复对象，考虑使用享元模式。（对象，相同的字段等等）<br><br>如何使用：Java中使用List或者Map缓存创建好的对象。<br><br>与池化的区别：池化：空间换时间，例如连接池提前创建。","like_count":0},{"had_liked":false,"id":185355,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1583566478,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583566478","product_id":100039001,"comment_content":"1. 在棋牌游戏的例子中，有没有必要把 ChessPiecePosition 设计成享元呢？<br>没有必要设计为享元，但是如果从节省存储空间的角度考虑，可以进行压缩，棋盘的大小是有限且固定的（围棋19*19应该是最大的棋盘），可以把x,y二维表示法，变为一维表示，这样有压缩效果，具体如下：以围棋为例 x表示第几行，y表示第几列的话 pos = (x * 19) + y，反推x = pos&#47;19,y=pos%19","like_count":0},{"had_liked":false,"id":185272,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1583550772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583550772","product_id":100039001,"comment_content":"position的位置相对来说，是有限的，也可以设计为享元","like_count":0},{"had_liked":false,"id":185265,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1583549735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583549735","product_id":100039001,"comment_content":"一、定义（理解）：<br>当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。<br>二、使用场景：<br>同上<br>三、实现方式：<br>  享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。<br>四、享元和单例、缓存、对象池<br>应用单例模式是为了保证对象全局唯一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。<br>（区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题）","like_count":0},{"had_liked":false,"id":185263,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1583549661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583549661","product_id":100039001,"comment_content":"之前学设计模式中都说池化技术就是用了享元模式，争哥这里做了更细致化的区分👍。","like_count":0},{"had_liked":false,"id":185187,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1583508391,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1583508391","product_id":100039001,"comment_content":"     &#47;*<br>     * Note that it is generally necessary to override the {@code hashCode}<br>     * method whenever this method is overridden, so as to maintain the<br>     * general contract for the {@code hashCode} method, which states<br>     * that equal objects must have equal hash codes.<br>     *&#47;<br>     public boolean equals(Object obj) {<br>        return (this == obj);<br>    }<br><br>    老师故意只重写了equals方法，没有重写hashCode方法，是为了第二道思考题吧，真的用心良苦，突然被感动了😭。","like_count":0},{"had_liked":false,"id":185117,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1583487782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583487782","product_id":100039001,"comment_content":"1. 在棋牌游戏的例子中，有没有必要把 ChessPiecePosition 设计成享元呢？<br><br>   绝对有必要.棋盘上的position是有限的, 如果通过枚举创建享元对象, 会节省大量的内存.<br><br>   <br><br>2. 在文本编辑器的例子中，调用 CharacterStyleFactory 类的 getStyle() 方法，需要在 styles 数组中遍历查找，而遍历查找比较耗时，是否可以优化一下呢？<br><br>   为CharacterStyle类添加扩展字段, 记录被使用次数. 每次调用getStyle()使用快排按照被使用次数排序遍历.","like_count":0},{"had_liked":false,"id":185066,"user_name":"do it","can_delete":false,"product_type":"c1","uid":1309911,"ip_address":"","ucode":"E0753912E8F2AF","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d7/b102034a.jpg","comment_is_top":false,"comment_ctime":1583476389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583476389","product_id":100039001,"comment_content":"课堂讨论<br>讨论1、没有必要，因为每个棋子的位置可能一样。<br>讨论2、可以采用map","like_count":0},{"had_liked":false,"id":185013,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1583465835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583465835","product_id":100039001,"comment_content":"1.我觉得没必要吧,因为棋子是不断变化的.可以考虑共享一个初始状态.<br>2.可以改成hashMap存储.","like_count":0},{"had_liked":false,"id":184972,"user_name":"阿德","can_delete":false,"product_type":"c1","uid":1602420,"ip_address":"","ucode":"186D5E19E3CB6E","user_header":"https://static001.geekbang.org/account/avatar/00/18/73/74/3bf4b74e.jpg","comment_is_top":false,"comment_ctime":1583460445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583460445","product_id":100039001,"comment_content":"在棋盘中，各个位置都是固定，如果房间数比较大，那么这些位置也是可以作为共享以节省空间的","like_count":0},{"had_liked":false,"id":184941,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1583456208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583456208","product_id":100039001,"comment_content":"位置应该不会被共享使用吧。另外遍历可以改成hashmap。","like_count":0},{"had_liked":false,"id":184936,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1583455776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583455776","product_id":100039001,"comment_content":"1.int占用四个字节，而设计为map或者list需要有容器和指针的消耗，个人认为没有必要做成享元；<br>2.可以做成hashmap","like_count":0},{"had_liked":false,"id":184929,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1583454390,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1583454390","product_id":100039001,"comment_content":"因为享元模式主要是共享那些不可变对像，所以对于position这种会经常变化的属性不适合设计成享元。<br>遍历list耗时，那我们可以使用map来存储characterStyle，map的key可以是font size colorRGB连接成的字符串或者通过它们计算出的hash值，value就是characterStyle对象，当查找时，先判断key是不是存在了，如果已经存在，直接返回value值，反之，将value存到map里。这样查找时间复杂度O(1)。","like_count":0},{"had_liked":false,"id":184928,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1583454271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583454271","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":184924,"user_name":"上善若水","can_delete":false,"product_type":"c1","uid":1122544,"ip_address":"","ucode":"42D2C732E3E6EF","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/f0/84f3cbe0.jpg","comment_is_top":false,"comment_ctime":1583453886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583453886","product_id":100039001,"comment_content":"争哥讲的，的确透彻。","like_count":0},{"had_liked":false,"id":184920,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1583453257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583453257","product_id":100039001,"comment_content":"学习设计模式课程有一段时间了，需要思考和加深学习的东西很多啊，如何能把学习的这些设计模式运用到实际的开发中是我最终想法，无论那种模式，都有你学习的地方😊","like_count":0}]}