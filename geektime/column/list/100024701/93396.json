{"id":93396,"title":"16 | 调度（中）：主动调度是如何发生的？","content":"<p>上一节，我们为调度准备了这么多的数据结构，这一节我们来看调度是如何发生的。</p><p>所谓进程调度，其实就是一个人在做A项目，在某个时刻，换成做B项目去了。发生这种情况，主要有两种方式。</p><p><strong>方式一</strong>：A项目做着做着，发现里面有一条指令sleep，也就是要休息一下，或者在等待某个I/O事件。那没办法了，就要主动让出CPU，然后可以开始做B项目。</p><p><strong>方式二</strong>：A项目做着做着，旷日持久，实在受不了了。项目经理介入了，说这个项目A先停停，B项目也要做一下，要不然B项目该投诉了。</p><h2>主动调度</h2><p>我们这一节先来看方式一，主动调度。</p><p>这里我找了几个代码片段。<strong>第一个片段是Btrfs，等待一个写入</strong>。<a href=\"https://zh.wikipedia.org/wiki/Btrfs\">B</a><a href=\"https://zh.wikipedia.org/wiki/Btrfs\">trfs</a>（B-Tree）是一种文件系统，感兴趣你可以自己去了解一下。</p><p>这个片段可以看作写入块设备的一个典型场景。写入需要一段时间，这段时间用不上CPU，还不如主动让给其他进程。</p><pre><code>static void btrfs_wait_for_no_snapshoting_writes(struct btrfs_root *root)\n{\n......\n\tdo {\n\t\tprepare_to_wait(&amp;root-&gt;subv_writers-&gt;wait, &amp;wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\twriters = percpu_counter_sum(&amp;root-&gt;subv_writers-&gt;counter);\n\t\tif (writers)\n\t\t\tschedule();\n\t\tfinish_wait(&amp;root-&gt;subv_writers-&gt;wait, &amp;wait);\n\t} while (writers);\n}\n</code></pre><p>另外一个例子是，<strong>从Tap网络设备等待一个读取</strong>。Tap网络设备是虚拟机使用的网络设备。当没有数据到来的时候，它也需要等待，所以也会选择把CPU让给其他进程。</p><pre><code>static ssize_t tap_do_read(struct tap_queue *q,\n\t\t\t   struct iov_iter *to,\n\t\t\t   int noblock, struct sk_buff *skb)\n{\n......\n\twhile (1) {\n\t\tif (!noblock)\n\t\t\tprepare_to_wait(sk_sleep(&amp;q-&gt;sk), &amp;wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n......\n\t\t/* Nothing to read, let's sleep */\n\t\tschedule();\n\t}\n......\n}\n</code></pre><p>你应该知道，计算机主要处理计算、网络、存储三个方面。计算主要是CPU和内存的合作；网络和存储则多是和外部设备的合作；在操作外部设备的时候，往往需要让出CPU，就像上面两段代码一样，选择调用schedule()函数。</p><!-- [[[read_end]]] --><p>接下来，我们就来看<strong>schedule函数的调用过程</strong>。</p><pre><code>asmlinkage __visible void __sched schedule(void)\n{\n\tstruct task_struct *tsk = current;\n\n\n\tsched_submit_work(tsk);\n\tdo {\n\t\tpreempt_disable();\n\t\t__schedule(false);\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n}\n</code></pre><p>这段代码的主要逻辑是在__schedule函数中实现的。这个函数比较复杂，我们分几个部分来讲解。</p><pre><code>static void __sched notrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq-&gt;curr;\n......\n</code></pre><p>首先，在当前的CPU上，我们取出任务队列rq。</p><p>task_struct *prev指向这个CPU的任务队列上面正在运行的那个进程curr。为啥是prev？因为一旦将来它被切换下来，那它就成了前任了。</p><p>接下来代码如下：</p><pre><code>next = pick_next_task(rq, prev, &amp;rf);\nclear_tsk_need_resched(prev);\nclear_preempt_need_resched();\n</code></pre><p>第二步，获取下一个任务，task_struct *next指向下一个任务，这就是<strong>继任</strong>。</p><p>pick_next_task的实现如下：</p><pre><code>static inline struct task_struct *\npick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tconst struct sched_class *class;\n\tstruct task_struct *p;\n\t/*\n\t * Optimization: we know that if all tasks are in the fair class we can call that function directly, but only if the @prev task wasn't of a higher scheduling class, because otherwise those loose the opportunity to pull in more work from other CPUs.\n\t */\n\tif (likely((prev-&gt;sched_class == &amp;idle_sched_class ||\n\t\t    prev-&gt;sched_class == &amp;fair_sched_class) &amp;&amp;\n\t\t   rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) {\n\t\tp = fair_sched_class.pick_next_task(rq, prev, rf);\n\t\tif (unlikely(p == RETRY_TASK))\n\t\t\tgoto again;\n\t\t/* Assumes fair_sched_class-&gt;next == idle_sched_class */\n\t\tif (unlikely(!p))\n\t\t\tp = idle_sched_class.pick_next_task(rq, prev, rf);\n\t\treturn p;\n\t}\nagain:\n\tfor_each_class(class) {\n\t\tp = class-&gt;pick_next_task(rq, prev, rf);\n\t\tif (p) {\n\t\t\tif (unlikely(p == RETRY_TASK))\n\t\t\t\tgoto again;\n\t\t\treturn p;\n\t\t}\n\t}\n}\n</code></pre><p>我们来看again这里，就是咱们上一节讲的依次调用调度类。但是这里有了一个优化，因为大部分进程是普通进程，所以大部分情况下会调用上面的逻辑，调用的就是fair_sched_class.pick_next_task。</p><p>根据上一节对于fair_sched_class的定义，它调用的是pick_next_task_fair，代码如下：</p><pre><code>static struct task_struct *\npick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tstruct cfs_rq *cfs_rq = &amp;rq-&gt;cfs;\n\tstruct sched_entity *se;\n\tstruct task_struct *p;\n\tint new_tasks;\n</code></pre><p>对于CFS调度类，取出相应的队列cfs_rq，这就是我们上一节讲的那棵红黑树。</p><pre><code>\t\tstruct sched_entity *curr = cfs_rq-&gt;curr;\n\t\tif (curr) {\n\t\t\tif (curr-&gt;on_rq)\n\t\t\t\tupdate_curr(cfs_rq);\n\t\t\telse\n\t\t\t\tcurr = NULL;\n......\n\t\t}\n\t\tse = pick_next_entity(cfs_rq, curr);\n</code></pre><p>取出当前正在运行的任务curr，如果依然是可运行的状态，也即处于进程就绪状态，则调用update_curr更新vruntime。update_curr咱们上一节就见过了，它会根据实际运行时间算出vruntime来。</p><p>接着，pick_next_entity从红黑树里面，取最左边的一个节点。这个函数的实现我们上一节也讲过了。</p><pre><code>\tp = task_of(se);\n\n\n\tif (prev != p) {\n\t\tstruct sched_entity *pse = &amp;prev-&gt;se;\n......\n\t\tput_prev_entity(cfs_rq, pse);\n\t\tset_next_entity(cfs_rq, se);\n\t}\n\n\n\treturn p\n</code></pre><p>task_of得到下一个调度实体对应的task_struct，如果发现继任和前任不一样，这就说明有一个更需要运行的进程了，就需要更新红黑树了。前面前任的vruntime更新过了，put_prev_entity放回红黑树，会找到相应的位置，然后set_next_entity将继任者设为当前任务。</p><p>第三步，当选出的继任者和前任不同，就要进行上下文切换，继任者进程正式进入运行。</p><pre><code>if (likely(prev != next)) {\n\t\trq-&gt;nr_switches++;\n\t\trq-&gt;curr = next;\n\t\t++*switch_count;\n......\n\t\trq = context_switch(rq, prev, next, &amp;rf);\n</code></pre><h2>进程上下文切换</h2><p>上下文切换主要干两件事情，一是切换进程空间，也即虚拟内存；二是切换寄存器和CPU上下文。</p><p>我们先来看context_switch的实现。</p><pre><code>/*\n * context_switch - switch to the new MM and the new thread's register state.\n */\nstatic __always_inline struct rq *\ncontext_switch(struct rq *rq, struct task_struct *prev,\n\t       struct task_struct *next, struct rq_flags *rf)\n{\n\tstruct mm_struct *mm, *oldmm;\n......\n\tmm = next-&gt;mm;\n\toldmm = prev-&gt;active_mm;\n......\n\tswitch_mm_irqs_off(oldmm, mm, next);\n......\n\t/* Here we just switch the register state and the stack. */\n\tswitch_to(prev, next, prev);\n\tbarrier();\n\treturn finish_task_switch(prev);\n}\n</code></pre><p>这里首先是内存空间的切换，里面涉及内存管理的内容比较多。内存管理后面我们会有专门的章节来讲，这里你先知道有这么一回事就行了。</p><p>接下来，我们看switch_to。它就是寄存器和栈的切换，它调用到了__switch_to_asm。这是一段汇编代码，主要用于栈的切换。</p><p>对于32位操作系统来讲，切换的是栈顶指针esp。</p><pre><code>/*\n * %eax: prev task\n * %edx: next task\n */\nENTRY(__switch_to_asm)\n......\n\t/* switch stack */\n\tmovl\t%esp, TASK_threadsp(%eax)\n\tmovl\tTASK_threadsp(%edx), %esp\n......\n\tjmp\t__switch_to\nEND(__switch_to_asm)\n</code></pre><p>对于64位操作系统来讲，切换的是栈顶指针rsp。</p><pre><code>/*\n * %rdi: prev task\n * %rsi: next task\n */\nENTRY(__switch_to_asm)\n......\n\t/* switch stack */\n\tmovq\t%rsp, TASK_threadsp(%rdi)\n\tmovq\tTASK_threadsp(%rsi), %rsp\n......\n\tjmp\t__switch_to\nEND(__switch_to_asm)\n</code></pre><p>最终，都返回了__switch_to这个函数。这个函数对于32位和64位操作系统虽然有不同的实现，但里面做的事情是差不多的。所以我这里仅仅列出64位操作系统做的事情。</p><pre><code>__visible __notrace_funcgraph struct task_struct *\n__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &amp;prev_p-&gt;thread;\n\tstruct thread_struct *next = &amp;next_p-&gt;thread;\n......\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &amp;per_cpu(cpu_tss, cpu);\n......\n\tload_TLS(next, cpu);\n......\n\tthis_cpu_write(current_task, next_p);\n\n\n\t/* Reload esp0 and ss1.  This changes current_thread_info(). */\n\tload_sp0(tss, next);\n......\n\treturn prev_p;\n}\n</code></pre><p>这里面有一个Per CPU的结构体tss。这是个什么呢？</p><p>在x86体系结构中，提供了一种以硬件的方式进行进程切换的模式，对于每个进程，x86希望在内存里面维护一个TSS（Task State Segment，任务状态段）结构。这里面有所有的寄存器。</p><p>另外，还有一个特殊的寄存器TR（Task Register，任务寄存器），指向某个进程的TSS。更改TR的值，将会触发硬件保存CPU所有寄存器的值到当前进程的TSS中，然后从新进程的TSS中读出所有寄存器值，加载到CPU对应的寄存器中。</p><p>下图就是32位的TSS结构。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/64/dfa9762cfec16822ec74d53350db4664.png?wh=507*613\" alt=\"\"></p><center><span class=\"reference\">图片来自Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes</span></center><p>但是这样有个缺点。我们做进程切换的时候，没必要每个寄存器都切换，这样每个进程一个TSS，就需要全量保存，全量切换，动作太大了。</p><p>于是，Linux操作系统想了一个办法。还记得在系统初始化的时候，会调用cpu_init吗？这里面会给每一个CPU关联一个TSS，然后将TR指向这个TSS，然后在操作系统的运行过程中，TR就不切换了，永远指向这个TSS。TSS用数据结构tss_struct表示，在x86_hw_tss中可以看到和上图相应的结构。</p><pre><code>void cpu_init(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct task_struct *curr = current;\n\tstruct tss_struct *t = &amp;per_cpu(cpu_tss, cpu);\n    ......\n    load_sp0(t, thread);\n\tset_tss_desc(cpu, t);\n\tload_TR_desc();\n    ......\n}\n\n\nstruct tss_struct {\n\t/*\n\t * The hardware state:\n\t */\n\tstruct x86_hw_tss\tx86_tss;\n\tunsigned long\t\tio_bitmap[IO_BITMAP_LONGS + 1];\n} \n</code></pre><p>在Linux中，真的参与进程切换的寄存器很少，主要的就是栈顶寄存器。</p><p>于是，在task_struct里面，还有一个我们原来没有注意的成员变量thread。这里面保留了要切换进程的时候需要修改的寄存器。</p><pre><code>/* CPU-specific state of this task: */\n\tstruct thread_struct\t\tthread;\n</code></pre><p>所谓的进程切换，就是将某个进程的thread_struct里面的寄存器的值，写入到CPU的TR指向的tss_struct，对于CPU来讲，这就算是完成了切换。</p><p>例如__switch_to中的load_sp0，就是将下一个进程的thread_struct的sp0的值加载到tss_struct里面去。</p><h2>指令指针的保存与恢复</h2><p>你是不是觉得，这样真的就完成切换了吗？是的，不信我们来<strong>盘点</strong>一下。</p><p>从进程A切换到进程B，用户栈要不要切换呢？当然要，其实早就已经切换了，就在切换内存空间的时候。每个进程的用户栈都是独立的，都在内存空间里面。</p><p>那内核栈呢？已经在__switch_to里面切换了，也就是将current_task指向当前的task_struct。里面的void *stack指针，指向的就是当前的内核栈。</p><p>内核栈的栈顶指针呢？在__switch_to_asm里面已经切换了栈顶指针，并且将栈顶指针在__switch_to加载到了TSS里面。</p><p>用户栈的栈顶指针呢？如果当前在内核里面的话，它当然是在内核栈顶部的pt_regs结构里面呀。当从内核返回用户态运行的时候，pt_regs里面有所有当时在用户态的时候运行的上下文信息，就可以开始运行了。</p><p>唯一让人不容易理解的是指令指针寄存器，它应该指向下一条指令的，那它是如何切换的呢？这里有点绕，请你仔细看。</p><p>这里我先明确一点，进程的调度都最终会调用到__schedule函数。为了方便你记住，我姑且给它起个名字，就叫“<strong>进程调度第一定律</strong>”。后面我们会多次用到这个定律，你一定要记住。</p><p>我们用最前面的例子仔细分析这个过程。本来一个进程A在用户态是要写一个文件的，写文件的操作用户态没办法完成，就要通过系统调用到达内核态。在这个切换的过程中，用户态的指令指针寄存器是保存在pt_regs里面的，到了内核态，就开始沿着写文件的逻辑一步一步执行，结果发现需要等待，于是就调用__schedule函数。</p><p>这个时候，进程A在内核态的指令指针是指向__schedule了。这里请记住，A进程的内核栈会保存这个__schedule的调用，而且知道这是从btrfs_wait_for_no_snapshoting_writes这个函数里面进去的。</p><p>__schedule里面经过上面的层层调用，到达了context_switch的最后三行指令（其中barrier语句是一个编译器指令，用于保证switch_to和finish_task_switch的执行顺序，不会因为编译阶段优化而改变，这里咱们可以忽略它）。</p><pre><code>switch_to(prev, next, prev);\nbarrier();\nreturn finish_task_switch(prev);\n</code></pre><p>当进程A在内核里面执行switch_to的时候，内核态的指令指针也是指向这一行的。但是在switch_to里面，将寄存器和栈都切换到成了进程B的，唯一没有变的就是指令指针寄存器。当switch_to返回的时候，指令指针寄存器指向了下一条语句finish_task_switch。</p><p>但这个时候的finish_task_switch已经不是进程A的finish_task_switch了，而是进程B的finish_task_switch了。</p><p>这样合理吗？你怎么知道进程B当时被切换下去的时候，执行到哪里了？恢复B进程执行的时候一定在这里呢？这时候就要用到咱的“进程调度第一定律”了。</p><p>当年B进程被别人切换走的时候，也是调用__schedule，也是调用到switch_to，被切换成为C进程的，所以，B进程当年的下一个指令也是finish_task_switch，这就说明指令指针指到这里是没有错的。</p><p>接下来，我们要从finish_task_switch完毕后，返回__schedule的调用了。返回到哪里呢？按照函数返回的原理，当然是从内核栈里面去找，是返回到btrfs_wait_for_no_snapshoting_writes吗？当然不是了，因为btrfs_wait_for_no_snapshoting_writes是在A进程的内核栈里面的，它早就被切换走了，应该从B进程的内核栈里面找。</p><p>假设，B就是最前面例子里面调用tap_do_read读网卡的进程。它当年调用__schedule的时候，是从tap_do_read这个函数调用进去的。</p><p>当然，B进程的内核栈里面放的是tap_do_read。于是，从__schedule返回之后，当然是接着tap_do_read运行，然后在内核运行完毕后，返回用户态。这个时候，B进程内核栈的pt_regs也保存了用户态的指令指针寄存器，就接着在用户态的下一条指令开始运行就可以了。</p><p>假设，我们只有一个CPU，从B切换到C，从C又切换到A。在C切换到A的时候，还是按照“进程调度第一定律”，C进程还是会调用__schedule到达switch_to，在里面切换成为A的内核栈，然后运行finish_task_switch。</p><p>这个时候运行的finish_task_switch，才是A进程的finish_task_switch。运行完毕从__schedule返回的时候，从内核栈上才知道，当年是从btrfs_wait_for_no_snapshoting_writes调用进去的，因而应该返回btrfs_wait_for_no_snapshoting_writes继续执行，最后内核执行完毕返回用户态，同样恢复pt_regs，恢复用户态的指令指针寄存器，从用户态接着运行。</p><p>到这里你是不是有点理解为什么switch_to有三个参数呢？为啥有两个prev呢？其实我们从定义就可以看到。</p><pre><code>#define switch_to(prev, next, last)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tprepare_switch_to(prev, next);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t((last) = __switch_to_asm((prev), (next)));\t\t\t\\\n} while (0)\n</code></pre><p>在上面的例子中，A切换到B的时候，运行到__switch_to_asm这一行的时候，是在A的内核栈上运行的，prev是A，next是B。但是，A执行完__switch_to_asm之后就被切换走了，当C再次切换到A的时候，运行到__switch_to_asm，是从C的内核栈运行的。这个时候，prev是C，next是A，但是__switch_to_asm里面切换成为了A当时的内核栈。</p><p>还记得当年的场景“prev是A，next是B”，__switch_to_asm里面return prev的时候，还没return的时候，prev这个变量里面放的还是C，因而它会把C放到返回结果中。但是，一旦return，就会弹出A当时的内核栈。这个时候，prev变量就变成了A，next变量就变成了B。这就还原了当年的场景，好在返回值里面的last还是C。</p><p>通过三个变量switch_to(prev = A, next=B, last=C)，A进程就明白了，我当时被切换走的时候，是切换成B，这次切换回来，是从C回来的。</p><h2>总结时刻</h2><p>这一节我们讲主动调度的过程，也即一个运行中的进程主动调用__schedule让出CPU。在__schedule里面会做两件事情，第一是选取下一个进程，第二是进行上下文切换。而上下文切换又分用户态进程空间的切换和内核态的切换。</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/64/9f4433e82c78ed5cd4399b4b116a9064.png?wh=2815*671\" alt=\"\"></p><h2>课堂练习</h2><p>你知道应该用什么命令查看进程的运行时间和上下文切换次数吗？</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，<span class=\"orange\">反复研读</span>。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><p></p>","comments":[{"had_liked":false,"id":91176,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1556889962,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"306499567978","product_id":100024701,"comment_content":"- 调度, 切换运行进程, 有两种方式<br>    - 进程调用 sleep 或等待 I&#47;O, 主动让出 CPU<br>    - 进程运行一段时间, 被动让出 CPU<br>- 主动让出 CPU 的方式, 调用 schedule(), schedule() 调用 __schedule()<br>    - __schedule() 取出 rq; 取出当前运行进程的 task_struct<br>    - 调用 pick_next_task 取下一个进程<br>        - 依次调用调度类(优化: 大部分都是普通进程), 因此大多数情况调用 fair_sched_class.pick_next_task[_fair]<br>        - pick_next_task_fair 先取出 cfs_rq 队列, 取出当前运行进程调度实体, 更新 vruntime<br>        - pick_next_entity 取最左节点, 并得到 task_struct, 若与当前进程不一样, 则更新红黑树 cfs_rq<br>    - 进程上下文切换: 切换进程内存空间, 切换寄存器和 CPU 上下文(运行 context_switch)<br>        - context_switch() -&gt; switch_to() -&gt; __switch_to_asm(切换[内核]栈顶指针) -&gt; __switch_to()<br>        - __switch_to() 取出 Per CPU 的 tss(任务状态段) 结构体<br>        - &gt; x86 提供以硬件方式切换进程的模式, 为每个进程在内存中维护一个 tss, tss 有所有寄存器, 同时 TR(任务寄存器)指向某个 tss, 更改 TR 会触发换出 tss(旧进程)和换入 tss(新进程), 但切换进程没必要换所有寄存器<br>        - 因此 Linux 中每个 CPU 关联一个 tss, 同时 TR 不变, Linux 中参与进程切换主要是栈顶寄存器<br>        - task_struct 的 thread 结构体保留切换时需要修改的寄存器, 切换时将新进程 thread 写入 CPU tss 中<br>        - 具体各类指针保存位置和时刻<br>            - 用户栈, 切换进程内存空间时切换<br>            - 用户栈顶指针, 内核栈 pt_regs 中弹出<br>            - 用户指令指针, 从内核栈 pt_regs 中弹出<br>            - 内核栈, 由切换的 task_struct 中的 stack 指针指向<br>            - 内核栈顶指针, __switch_to_asm 函数切换(保存在 thread 中)<br>            - 内核指令指针寄存器: 进程调度最终都会调用 __schedule, 因此在让出(从当前进程)和取得(从其他进程) CPU 时, 该指针都指向同一个代码位置.","like_count":71,"discussions":[{"author":{"id":2218351,"avatar":"https://static001.geekbang.org/account/avatar/00/21/d9/6f/1037fe53.jpg","nickname":"小草","note":"","ucode":"02B5E07BF1ED17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348391,"discussion_content":"不愧是课代表！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1612533436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91038,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1556814232,"is_pvip":false,"replies":[{"id":"49499","content":"是的 finish_task_switch完成清理工作","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567676718,"ip_address":"","comment_id":91038,"utype":1}],"discussion_count":1,"race_medal":0,"score":"113225963928","product_id":100024701,"comment_content":"proc文件系统里面可以看运行时间和切换次数，还可以看自愿切换和非自愿切换次数。 <br><br>老师请教一个问题，A切到B, B切到C，C切到A，当最后切换回A的时候，A要知道自己是从C切换过来的，也就是last，这样做的目的是什么呢？A要对C做什么善后操作吗？","like_count":26,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448773,"discussion_content":"是的 finish_task_switch完成清理工作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567676718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95466,"user_name":"憨人","can_delete":false,"product_type":"c1","uid":1438908,"ip_address":"","ucode":"EFA74A9880B60C","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/bc/f97c2d9d.jpg","comment_is_top":false,"comment_ctime":1558060258,"is_pvip":false,"replies":[{"id":"34090","content":"这句话赞","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1558067317,"ip_address":"","comment_id":95466,"utype":1}],"discussion_count":1,"race_medal":0,"score":"100342308066","product_id":100024701,"comment_content":"进程切换需要搞明白：我从哪里来，我要到哪里去","like_count":23,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450468,"discussion_content":"这句话赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558067317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91070,"user_name":"coyang","can_delete":false,"product_type":"c1","uid":1024805,"ip_address":"","ucode":"563687E0F6A441","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/25/5da16c25.jpg","comment_is_top":false,"comment_ctime":1556846772,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"83161225396","product_id":100024701,"comment_content":"vmstat 、 pidstat 和 &#47;proc&#47;interrupts可以查看进程的上下文切换。","like_count":19},{"had_liked":false,"id":91429,"user_name":"刘強","can_delete":false,"product_type":"c1","uid":1035612,"ip_address":"","ucode":"B2E41BB894A727","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","comment_is_top":false,"comment_ctime":1557036564,"is_pvip":false,"replies":[{"id":"32855","content":"是的，这一点比较绕","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1557154932,"ip_address":"","comment_id":91429,"utype":1}],"discussion_count":4,"race_medal":0,"score":"65981546004","product_id":100024701,"comment_content":"看了三遍，因为有一些基础，大概明白了。我觉得有个地方很巧妙。当函数返回的时候，由于切换了上下文，包括栈指针，所以一个进程函数执行return返回到了另一个进程，也就是完成了进程的切换。由此也可以看出，cpu也是比较&quot;笨的&quot;，它只提供了基本的机制，至于如何利用这种机制，玩出花样，那就是各个操作系统自由发挥了。","like_count":15,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448915,"discussion_content":"是的，这一点比较绕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557154932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1798979,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/73/43/ae139b1f.jpg","nickname":"博","note":"","ucode":"F7CA69FF5D09BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234343,"discussion_content":"蒙圈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586963018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1798979,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/73/43/ae139b1f.jpg","nickname":"博","note":"","ucode":"F7CA69FF5D09BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234856,"discussion_content":"推荐你看于渊写的 一个操作系统的实现。看完后就不蒙圈了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587001769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":234343,"ip_address":""},"score":234856,"extra":""},{"author":{"id":1773471,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/0f/9f/caae319d.jpg","nickname":"max","note":"","ucode":"91DDE86511DCDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275507,"discussion_content":"留一下链接咯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590722437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":234856,"ip_address":""},"score":275507,"extra":""}]}]},{"had_liked":false,"id":92521,"user_name":"尚墨","can_delete":false,"product_type":"c1","uid":1300116,"ip_address":"","ucode":"114EE139168CB9","user_header":"http://thirdwx.qlogo.cn/mmopen/uqaRIfRCAhJ6t1z92XYEzXpqpgpS1veBc5DNGhfRHFsHgE19qHqG0cevcIJRRsjIKxsSEcIPVP1nOkaVKLibb2xFq04A4KMY3/132","comment_is_top":false,"comment_ctime":1557290796,"is_pvip":false,"replies":[{"id":"49427","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567663148,"ip_address":"","comment_id":92521,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35917029164","product_id":100024701,"comment_content":"刘老师，每个用户的进程都会被分配一个内核栈吗？","like_count":8,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449299,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567663148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386948,"discussion_content":"而且可能不止一个，进程里面每个线程都对应一个内核栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627906211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117951,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1564197795,"is_pvip":false,"replies":[{"id":"46403","content":"赞","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566298944,"ip_address":"","comment_id":117951,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27334001571","product_id":100024701,"comment_content":"看起来ps 里面的TIME就是进程的 cpu runtime吧; 查看上下文切换,可以用cat &#47;proc&#47;x&#47;status","like_count":6,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460194,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566298944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117899,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1564186208,"is_pvip":false,"replies":[{"id":"46405","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566298991,"ip_address":"","comment_id":117899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27333989984","product_id":100024701,"comment_content":"补充一下,看了最后的那张图,感觉切换,就是切内核态的 stack&#47;rsp&#47;pc, 这样下一个任务就能找到在哪执行了,以及继续怎么执行, 而内核态共享一片内存空间,所以不需要mm_switch,切换完了,返回用户态,用户态的stack&#47;rsp&#47;pc都被切换了, 而用户态的内存空间需要单独切换<br>老师,我理解的对吧?","like_count":6,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460168,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566298991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229052,"user_name":"李圣悦","can_delete":false,"product_type":"c1","uid":1638427,"ip_address":"","ucode":"C1786C98824E50","user_header":"https://static001.geekbang.org/account/avatar/00/19/00/1b/eee13196.jpg","comment_is_top":false,"comment_ctime":1592888453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23067724933","product_id":100024701,"comment_content":"一直以为内核简直就是一个很实在的艺术品，工作了几年，linux内核是我工作上半个师傅","like_count":5},{"had_liked":false,"id":226520,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592127757,"is_pvip":false,"replies":[{"id":"83454","content":"牛，这是从设计模式专栏过来的吧","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1592185799,"ip_address":"","comment_id":226520,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23066964237","product_id":100024701,"comment_content":"“cpu_init会给每一个 CPU 关联一个 TSS，然后将 TR 指向这个 TSS，然后在操作系统的运行过程中，TR 就不切换了，永远指向这个 TSS”<br><br>看到这里，想到了一个设计模式：享元模式（Flyweight Design Pattern）","like_count":5,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498274,"discussion_content":"牛，这是从设计模式专栏过来的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592185799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253496,"user_name":"AlexS","can_delete":false,"product_type":"c1","uid":1472051,"ip_address":"","ucode":"3DA81A613CE645","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","comment_is_top":false,"comment_ctime":1602754167,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18782623351","product_id":100024701,"comment_content":"有两个小问题，望解答哦~~<br>1.  貌似给出的__switch_to代码片段没有体现出把当前的cpu寄存器状态保存到prev的thread_struct里？<br>2. 再一个操作tss的用意是什么，首先它不能发触发TR的硬件动作吧?（TR的值变了才会有cpu和tss之间的换入换出）; 再来，每个thread都有thread_struct存cpu寄存器状态了，为什么还需要tss？","like_count":4,"discussions":[{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312879,"discussion_content":"厉害了，看看我找到了啥，\nFor each CPU which executes processes possibly wanting to do system calls via interrupts, one TSS is required. The only interesting fields are SS0 and ESP0. Whenever a system call occurs, the CPU gets the SS0 and ESP0-value in its TSS and assigns the stack-pointer to it. So one or more kernel-stacks need to be set up for processes doing system calls. Be aware that a thread&#39;s/process&#39; time-slice may end during a system call, passing control to another thread/process which may as well perform a system call, ending up in the same stack. Solutions are to create a private kernel-stack for each thread/process and re-assign esp0 at any task-switch or to disable scheduling during a system-call.\n\nhttps://wiki.osdev.org/Task_State_Segment#TSS_in_software_multitasking\n超棒哒！\nhttps://stackoverflow.com/questions/2711044/why-doesnt-linux-use-the-hardware-context-switch-via-the-tss#:~:text=The%20x86%20architecture%20includes%20a%20specific%20segment%20type,TSS%20for%20each%20distinct%20CPU%20in%20the%20system.","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602841891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316544,"discussion_content":"为什么没有人给我点赞呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603423726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312869,"discussion_content":"1. 第一个问题有（部分？）答案了，这一步实际上把当前rsp的值保存到current->thread.sp里了。\nENTRY(__switch_to_asm)......  \n/* switch stack */  \nmovq  %rsp, TASK_threadsp(%rdi)\n对第二个问题还是没有答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602839562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117896,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1564185889,"is_pvip":false,"replies":[{"id":"46406","content":"先看总结也挺好的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566299014,"ip_address":"","comment_id":117896,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449087777","product_id":100024701,"comment_content":"关于指令指针的讲解,厉害了...<br>专栏有时候可以反者看, 先看最后总结,然后往上顺藤模块看你的分析<br>同时在读的书:lkd&#47;ulk, 推荐给大家","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460165,"discussion_content":"先看总结也挺好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566299014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206469,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1586865899,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"10176800491","product_id":100024701,"comment_content":"还记得当年的场景“prev 是 A，next 是 B”，__switch_to_asm 里面 return prev 的时候，还没 return 的时候，prev 这个变量里面放的还是 C，因而它会把 C 放到返回结果中。但是，一旦 return，就会弹出 A 当时的内核栈。这个时候，prev 变量就变成了 A，next 变量就变成了 B。这就还原了当年的场景，好在返回值里面的 last 还是 C。  明白了返回结果有个单独的寄存器","like_count":2,"discussions":[{"author":{"id":1446375,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","nickname":"book尾汁","note":"","ucode":"AE2B8DFC643ACC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232362,"discussion_content":"tss加载完寄存器，切换完栈顶指针，此时还在c的内核栈中，返回后才回到a的栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586867523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1446375,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","nickname":"book尾汁","note":"","ucode":"AE2B8DFC643ACC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232357,"discussion_content":"想了一下，是因为内核栈顶指针指向a的栈，所以返回结果会返回到a的栈。在返回之前一直在c的栈中，内核栈 寄存器切换后，所有变量都变成a的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586867379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197586,"user_name":"tupaopao","can_delete":false,"product_type":"c1","uid":1734160,"ip_address":"","ucode":"E5FDFC1C245E82","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiaVde2marotY54km22JYDTrGOrK4PDqwjBrOzT1NtHyadfice3gyciaRvGbDOyVZqA1NCTpcWlTiatA/132","comment_is_top":false,"comment_ctime":1585386731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175321323","product_id":100024701,"comment_content":"TR指向tss_struct，并且不会改变的，但其实tss_struct记录了寄存器的修改，但是操作系统也保存了thread_struct\tthread 结构，主动的告诉硬件，我只需要保存修改这几个值，这样一来load的时候，也是操作系统干涉，从thread_struct中去修改tss_struct的某几个寄存器的值","like_count":2},{"had_liked":false,"id":165706,"user_name":"雨后的夜","can_delete":false,"product_type":"c1","uid":1359202,"ip_address":"","ucode":"0E8C183AEB02EF","user_header":"https://static001.geekbang.org/account/avatar/00/14/bd/62/283e24ab.jpg","comment_is_top":false,"comment_ctime":1577285874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167220466","product_id":100024701,"comment_content":"太精彩了！！！","like_count":2},{"had_liked":false,"id":91086,"user_name":"一笔一画","can_delete":false,"product_type":"c1","uid":1495254,"ip_address":"","ucode":"2B9BC8ADF97106","user_header":"https://static001.geekbang.org/account/avatar/00/16/d0/d6/f335954b.jpg","comment_is_top":false,"comment_ctime":1556851520,"is_pvip":false,"replies":[{"id":"32861","content":"不影响，这里只站在a的角度看问题，从a到b，让后中间经历一万个进程，然后到c再到a，也是这个样子的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1557155164,"ip_address":"","comment_id":91086,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10146786112","product_id":100024701,"comment_content":"老师，我还是对三个参数不解，A-&gt;B-&gt;C，如果再来一个D怎么办？","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448796,"discussion_content":"不影响，这里只站在a的角度看问题，从a到b，让后中间经历一万个进程，然后到c再到a，也是这个样子的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557155164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122150,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","nickname":"万历十五年","note":"","ucode":"3D8CF5DF847AE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288481,"discussion_content":"可以理解为，只要发生了schedule，等到再回到原函数，期间已经经历了沧海桑田","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593758386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351322,"user_name":"wsxzei","can_delete":false,"product_type":"c1","uid":2766280,"ip_address":"","ucode":"8527ED444BFC73","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/JHzZynEKL2CibTaxCZV3XOs1bJJFqbmwhmibd4U5njlaNVWPrbre1Qha2XUx1dcQ99iaYFl13PyjlYQ0rcl9N5vEg/132","comment_is_top":false,"comment_ctime":1657699644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5952666940","product_id":100024701,"comment_content":"补充以下对最后 switch_to 为什么使用三个参数的理解：<br>1、A 切换到 B 的时候，运行到 switch_to_asm 这一行的时候，是在 A 的内核栈上运行的，prev 是 A，next 是 B。<br><br>原因：在swich_to中仍然存在对 prev 和 next 变量的使用，因此 A 在调用`__switch_to_asm`函数前，会将这两个参数放入被调用者保存的寄存器(callee)中，当 __switch_to_asm 返回时会从内核栈中弹出这些值。因此从 进程A切换到进程B失去CPU执行权，到进程C切换回进程A，进程A从 __switch_to_asm 返回前，prev 被恢复为进程 A，next 恢复为进程 B。<br><br>2、`__switch_to_asm`的返回值指向进程 C。<br><br>原因： __switch_to_asm 的返回值存放在寄存器 %rax 中，注意到该函数会跳转到 __switch_to 执行，并且  __switch_to  返回时会执行 return prev_p; 。因此 rax 的值是由局部变量 prev_p 决定，进程 A 重新获得CPU资源是在进程C切换为进程A的情况下，因此 prev_p 为 进程 C。<br><br>总结：通过三个变量  switch_to(prev = A, next=B, last=C) ，A 进程当时被切换走的时候，是切换成 B，这次切换回来，是从 C 回来的。last指向进程 C，也即将prev指针从指向 A 变更为指向 C，next 指向进程 B。(注意switch_to是宏定义，而不是函数调用，因此会更改原先的prev指针)","like_count":1},{"had_liked":false,"id":287126,"user_name":"明天","can_delete":false,"product_type":"c1","uid":2458966,"ip_address":"","ucode":"3E8070C4C8FCD0","user_header":"https://static001.geekbang.org/account/avatar/00/25/85/56/6fe64e92.jpg","comment_is_top":false,"comment_ctime":1617784829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912752125","product_id":100024701,"comment_content":"看了三遍 终于看懂了 A-》B-》C-》A  这整个过程才能让A最后知道我是被谁切走的 又从哪里切回来，其实last就是前一个内核栈的prev,只是需要将prev携带到next内核栈保留到last中","like_count":1},{"had_liked":false,"id":192628,"user_name":"OOK","can_delete":false,"product_type":"c1","uid":1342712,"ip_address":"","ucode":"BE6220D4E922E9","user_header":"https://static001.geekbang.org/account/avatar/00/14/7c/f8/1183f1ac.jpg","comment_is_top":false,"comment_ctime":1584864559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879831855","product_id":100024701,"comment_content":"哈哈哈，有开始变难了，主动调度和非抢占式调度没有关系哈","like_count":1},{"had_liked":false,"id":127892,"user_name":"奔跑的码仔","can_delete":false,"product_type":"c1","uid":1609871,"ip_address":"","ucode":"AB3B02B07B8B8C","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","comment_is_top":false,"comment_ctime":1566805305,"is_pvip":false,"replies":[{"id":"48771","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567495261,"ip_address":"","comment_id":127892,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5861772601","product_id":100024701,"comment_content":"&quot;通过三个变量 switch_to(prev = A, next=B，last = C);A 进程就明白了，我当时被切换走的时候，是切换成 B，这次切换回来，是从 C 回来的&quot;；这段话中，进程A从进程C切换回来时，进程A内核栈中变量的定义:prev=last=C，netxt=B，由于当前就是在进程A的地址空间里，所以，可以进程A可以说，当年我被切换到进程B，现在，由进程C又切换回来了。<br><br><br><br>","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464697,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567495261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476507,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/9b/8bebc8b6.jpg","nickname":"Marshall","note":"","ucode":"0FB004E8163F44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369488,"discussion_content":"您还 有个问题想请教 知道我是被谁切换走 又被谁切换回来的意义在哪？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619054414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115561,"user_name":"garlic","can_delete":false,"product_type":"c1","uid":1019579,"ip_address":"","ucode":"FEB147EDB5774E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg","comment_is_top":false,"comment_ctime":1563625179,"is_pvip":true,"replies":[{"id":"46557","content":"赞","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566356916,"ip_address":"","comment_id":115561,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5858592475","product_id":100024701,"comment_content":"通过ps -o etime= -p &quot;$$&quot; 可以 查看，进程的运行时间， 通过&#47;proc&#47;{pid}&#47;status 中的 voluntary_ctxt_switches: nonvoluntary_ctxt_switches: 可以看到主动调度和抢占调度的次数， 也可以单独安装sysstat 使用pidstat -w 查看相关进程的调度信息 https:&#47;&#47;garlicspace.com&#47;2019&#47;07&#47;20&#47;查看进程运行时间及上下文切换次数&#47;<br><br>","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459163,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566356916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358881,"user_name":"lzh","can_delete":false,"product_type":"c1","uid":1336951,"ip_address":"广东","ucode":"C3D83DF4230109","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","comment_is_top":false,"comment_ctime":1664964375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664964375","product_id":100024701,"comment_content":"为什么switch_to()要3个参数？<br>看了这些链接：<br>1、http:&#47;&#47;www.wowotech.net&#47;process_management&#47;context-switch-arch.html<br>2、http:&#47;&#47;liujunming.top&#47;2018&#47;11&#47;20&#47;%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2switch-to%E5%AE%8F%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90&#47;<br>3、https:&#47;&#47;www.spinics.net&#47;lists&#47;newbies&#47;msg12904.html<br><br>我感觉目的就是为了在switch_to()返回后让进程A的prev接收last的值，而last就是该cpu调度进程A之前正在执行的进程C。只不过每次进程被调度时，从schedule()进入switch_to()都会把prev设置为自己，一方面供switch_to()第1个参数使用，表示“从何而来”，另一方面供switch_to()第3个参数使用，即用于switch_to()返回时我能知道cpu上一个执行的task是谁<br>","like_count":0},{"had_liked":false,"id":358458,"user_name":"赶猪的小仙女","can_delete":false,"product_type":"c1","uid":2842778,"ip_address":"广东","ucode":"1318ACAF2E8A91","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJlJAgxLa4wexQnib95ACD8Dk9u1Gg4Ydshqh9YmHwI3Qs9icp5ndbQqsp16I1Cx4zXE8PI4lK1od3A/132","comment_is_top":false,"comment_ctime":1664332423,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1664332423","product_id":100024701,"comment_content":"有个问题，在主动调度中，即碰到了磁盘IO或者网络IO等待时，为啥不需要阻塞当前线程，从而让其他就绪态的线程上CPU运行呢","like_count":0},{"had_liked":false,"id":357500,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"广东","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1663315956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663315956","product_id":100024701,"comment_content":"建议先介绍下smp，每个cpu独立运行同一块内核代码，协同调度","like_count":0},{"had_liked":false,"id":343552,"user_name":"周博文船长","can_delete":false,"product_type":"c1","uid":2619499,"ip_address":"","ucode":"5115DB65980DD4","user_header":"https://static001.geekbang.org/account/avatar/00/27/f8/6b/02ef74ae.jpg","comment_is_top":false,"comment_ctime":1650902477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650902477","product_id":100024701,"comment_content":"老师，线程切换和进程切换的内核过程是一样的吗？","like_count":0},{"had_liked":false,"id":343526,"user_name":"小鳄鱼","can_delete":false,"product_type":"c1","uid":1178888,"ip_address":"","ucode":"9C30CAFB41A263","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","comment_is_top":false,"comment_ctime":1650892321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650892321","product_id":100024701,"comment_content":"在进程A-&gt;B-C时，其实文章开头的两个例子都用上了。就是文件系统那个例子在等待而让CPU的时候，被Tab网络那个进程抢到CPU了。然后B又因为网络等待，把CPU“让给”C。等C执行完成或者再让出CPU时，又调度给A了","like_count":0},{"had_liked":false,"id":330276,"user_name":"飞翔的罗宾","can_delete":false,"product_type":"c1","uid":1525116,"ip_address":"","ucode":"DBDA8BA3AB4F7A","user_header":"https://static001.geekbang.org/account/avatar/00/17/45/7c/08becae7.jpg","comment_is_top":false,"comment_ctime":1641890436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641890436","product_id":100024701,"comment_content":"一个很好的帖子 可以当做这一课的补充 指令指针寄存器那个部分和本科有点不一样 不知道是不是内核版本不同的原因 https:&#47;&#47;www.cnblogs.com&#47;visayafan&#47;archive&#47;2011&#47;12&#47;10&#47;2283660.html","like_count":0},{"had_liked":false,"id":321550,"user_name":"李进","can_delete":false,"product_type":"c1","uid":1180709,"ip_address":"","ucode":"B7F4F7807BC0C8","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/25/a384ee7a.jpg","comment_is_top":false,"comment_ctime":1636945191,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636945191","product_id":100024701,"comment_content":"指令指针那块看了好久没有太明白，有种感觉是每个任务的切换走的时候都是经过finish_task_switch,切回来的时候也是经过finish_task_switch，有种从哪儿走，又从哪儿回来的意思。","like_count":0},{"had_liked":false,"id":319083,"user_name":"Jia Tiancai","can_delete":false,"product_type":"c1","uid":2548102,"ip_address":"","ucode":"EF2F5FE8A0DF3E","user_header":"","comment_is_top":false,"comment_ctime":1635571257,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1635571257","product_id":100024701,"comment_content":"所谓的进程切换，就是将某个进程的 thread_struct 里面的寄存器的值，写入到 CPU 的 TR 指向的 tss_struct，对于 CPU 来讲，这就算是完成了切换。<br>-- 有个疑问，tss_struct中也包括当前进程中所有寄存器的值，上面步骤也会把整个tss_struct替换，更直接使用X86硬件模式的进程上下文切换相比，优势是什么呢？<br>是因为硬件模式CPU寄存器和内存的数据交换，Linux系统实现的是内存内部的逻辑地址修改？<br>是这样理解的吗？<br>麻烦老师或同学帮忙解答一下呢，非常感谢！","like_count":0},{"had_liked":false,"id":311127,"user_name":"luxuabc","can_delete":false,"product_type":"c1","uid":1642257,"ip_address":"","ucode":"73BAC7A3276743","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJMW3f6jeDLDVaZODBwJmZOrHRT31bZ0bHLibTRF8xBmfQ6PjfbmqWbw5P92vcEFMAoYSkV4Vt1iarg/132","comment_is_top":false,"comment_ctime":1631081535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631081535","product_id":100024701,"comment_content":"老师，进程的调度都是要经过内核态吗？如果某个进程不牵扯系统调用，还是会走到内核态吗？如果是，那是不是就是指进行用户态上下文切换就好了？","like_count":0},{"had_liked":false,"id":281779,"user_name":"Lorry","can_delete":false,"product_type":"c1","uid":1066409,"ip_address":"","ucode":"BD4754D0F1D786","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","comment_is_top":false,"comment_ctime":1614899421,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1614899421","product_id":100024701,"comment_content":"任务太多了，寄存器不够存怎么办，会置换到内存中存储吗？","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386949,"discussion_content":"任务在切换的时候都是存储在内存里面的，寄存器只是保存当前task的数据；所以不存在寄存器不够的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627906723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355190,"discussion_content":"我也想问这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615387969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272986,"user_name":"Grant","can_delete":false,"product_type":"c1","uid":2405026,"ip_address":"","ucode":"5D3AEBC4CC6EB7","user_header":"https://static001.geekbang.org/account/avatar/00/24/b2/a2/1f35b6d2.jpg","comment_is_top":false,"comment_ctime":1610377972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610377972","product_id":100024701,"comment_content":"写的太棒了。","like_count":0},{"had_liked":false,"id":238365,"user_name":"G.S.K","can_delete":false,"product_type":"c1","uid":1222966,"ip_address":"","ucode":"88217F9289EB48","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/36/d054c979.jpg","comment_is_top":false,"comment_ctime":1596153264,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596153264","product_id":100024701,"comment_content":"请教老师，主动调度，执行__schedule函数时，__schedule在哪个内核栈中执行呢？","like_count":0,"discussions":[{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316183,"discussion_content":"当前task的内核栈呀。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603372629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238018,"user_name":"深海极光","can_delete":false,"product_type":"c1","uid":1096111,"ip_address":"","ucode":"331024F7E99C64","user_header":"https://static001.geekbang.org/account/avatar/00/10/b9/af/f59b4c7c.jpg","comment_is_top":false,"comment_ctime":1596028311,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1596028311","product_id":100024701,"comment_content":"系统调用时触发软中断，是不是也把用户线程换出去，去执行内核的具体函数，这里也是主动调度吧","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386950,"discussion_content":"用户线程和内核线程是一个线程啊（线程分为用户线程和内核线程两部分），只不过内存地址反不同而已；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627906813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316185,"discussion_content":"调度指的是切换task。处理中断、执行系统调用时，当前的task上下文还是当前task的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603372772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227893,"user_name":"G.S.K","can_delete":false,"product_type":"c1","uid":1222966,"ip_address":"","ucode":"88217F9289EB48","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/36/d054c979.jpg","comment_is_top":false,"comment_ctime":1592523528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592523528","product_id":100024701,"comment_content":"当进程 A 在内核里面执行 switch_to 的时候，内核态的指令指针也是指向这一行的。但是在 switch_to 里面，将寄存器和栈都切换到成了进程 B 的，唯一没有变的就是指令指针寄存器。当 switch_to 返回的时候，指令指针寄存器指向了下一条语句 finish_task_switch。-----------finish_task_switch在进程A和进程B的位置是一样的吗？","like_count":0},{"had_liked":false,"id":226039,"user_name":"羽","can_delete":false,"product_type":"c1","uid":1316367,"ip_address":"","ucode":"7E329FECE728E4","user_header":"https://static001.geekbang.org/account/avatar/00/14/16/0f/ebdcc4b7.jpg","comment_is_top":false,"comment_ctime":1591933907,"is_pvip":false,"replies":[{"id":"83462","content":"有的场景是不允许抢占的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1592186050,"ip_address":"","comment_id":226039,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1591933907","product_id":100024701,"comment_content":"超哥 请教一下为甚需要使用preempt_disable()呢 我搜了一下说是防止死锁 没太明白","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498089,"discussion_content":"有的场景是不允许抢占的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592186050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002005,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","nickname":"stackWarn","note":"","ucode":"89672E452DEBA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288707,"discussion_content":"非抢占模式也是内核态不能抢占吧 用户态还是可以被少量抢占的 \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593845661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206463,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1586865562,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586865562","product_id":100024701,"comment_content":"不太明白switch_to()的这个，假如A-&gt;B-&gt;C-&gt;A  ,A到B的时候，A的内核栈中（prev=A，next=B，LAST=A），<br>C-A的时候（prev=C，next=A，last=C），__switch_to返回的时候返回的时候不是已经切换到A的内核栈了吗，A的内核栈中prev不是A吗，怎么返回的是C啊，是因为切换完内核栈，指令寄存器依然会继续执行原来的下一条指令返回C吗","like_count":0},{"had_liked":false,"id":193329,"user_name":"Geek_b8928e","can_delete":false,"product_type":"c1","uid":1926597,"ip_address":"","ucode":"96E4ABE3F2F145","user_header":"","comment_is_top":false,"comment_ctime":1584889827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584889827","product_id":100024701,"comment_content":"主动触发__schedule()，选择scheduler后一个进程<br>进行上下文切换context_switch()，一是切换进程空间，也即虚拟内存；二是切换寄存器和 CPU 上下文。<br>Linux的实现中，一个CPU绑定一个TSS<br>  struct thread_struct    thread;<br>中保留了切换时需要修改的寄存器<br>","like_count":0},{"had_liked":false,"id":165730,"user_name":"jssfy","can_delete":false,"product_type":"c1","uid":1137238,"ip_address":"","ucode":"F16353CFE607B7","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/56/115c6433.jpg","comment_is_top":false,"comment_ctime":1577290634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577290634","product_id":100024701,"comment_content":"每个cpu核各自维护队列，请问task是通过什么方式分配到哪个cpu的队列中的，如果不是强制指定的话？","like_count":0},{"had_liked":false,"id":160080,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1575865343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575865343","product_id":100024701,"comment_content":"老师您好，对于进程切换这样理解对吗：<br><br>假设单核环境下，进程切换顺序为：A-&gt;B-&gt;C-&gt;A<br><br>&#47;&#47;A-&gt;B时三个参数的值为prev=A,next=B<br>&#47;&#47;而且这句话是在A里面运行的<br>switch_to(prev, next, prev);<br><br>&#47;&#47;第二句话保证执行顺序<br>barrier();<br><br>&#47;&#47;第一句话与第三句话之间，CPU时间给到B、C进程，A进程等待<br>&#47;&#47;进程C调用了switch_to以后，prev=C<br>&#47;&#47;CPU时间给到A，A继续执行<br>return finish_task_switch(prev);<br><br>另外，其实是内核需要知道切换顺序，并非是用户态的进程需要知道切换顺序，我这样理解对吗？<br>","like_count":0},{"had_liked":false,"id":146102,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1572432954,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1572432954","product_id":100024701,"comment_content":"表示 已经更不上思路了 代码也看不太懂  请刘总指点","like_count":0},{"had_liked":false,"id":137474,"user_name":"JT","can_delete":false,"product_type":"c1","uid":1489942,"ip_address":"","ucode":"36D71949F34FD9","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/16/5ce59343.jpg","comment_is_top":false,"comment_ctime":1569749361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569749361","product_id":100024701,"comment_content":"个人对于最后一部分指令指针的理解：每个进程都会调用schedule函数进行调度，那么在调用schedule函数的时候，相应的调用过程都会被压入内核栈中，schedule切换进程仅仅只是切换内核栈，而当schedule返回的时候，就会返回到内核栈中压入的函数（此内核栈为切换后进程的内核栈，所以会返回到切换后进程调用schedule时候的函数位置）","like_count":0},{"had_liked":false,"id":134964,"user_name":"石将从","can_delete":false,"product_type":"c1","uid":1375617,"ip_address":"","ucode":"12F43E643D1D58","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/81/1864f266.jpg","comment_is_top":false,"comment_ctime":1568963428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568963428","product_id":100024701,"comment_content":"指针指令这块很懵，先跳过吧","like_count":0},{"had_liked":false,"id":130817,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1567556864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567556864","product_id":100024701,"comment_content":"调度中 1 进程调度 做着做着A项目，然后去做B项目去了，主要有2种方式，一种是A项目，sleep休息一会，或者在等待IO操作，让出CPU去做B项目，这种叫主动调度，另一种是另一种是A项目做的时间长，B项目也需要做一下，就把CPU让给A项目。2 主动调度 2.1 常见的2种场景，btrfs btree的文件系统 ，在文件写入的时候，写入需要一段时间，不需要CPU，还不如让给其他线程，另一种场景 从tap网络设备准备一个读取，当没有数据到来，需要等待，也可以把CPU让给其他进程。计算机主要处理计算，网络，存储3个方面，计算主要是CPU和内存，存储和网络，多是和外部设备的合作，在操作外部设备的时候，一般会让出CPU，选择调用schedule函数。3 schedule函数的调用过程 3.1 schedule有一个主函数，_schedule函数，函数定义如下：struct task_struct *prev，*next，long *switch_count，struct rq_flags rf;struct rq *rq;int cpu;cpu=smp_processor_id();rq=cpu_rq(cpu);prev=rq-&gt;curr;3.2 首先在当前CPU上取出任务队列rq，将prev只向当前的进程curr，因为一旦切换下来，就成前任了，3.3取出下一个任务 next=pick_next_task，大部分是普通进程，调用的是fair_schedule_class类，调用的是pick_next_task_fair，cfs_rq ，schedule_entity se，task_struct *p，int new_tasks，对于cfs调度类，取出相应的队列cfs_rq，取出当前正在运行的任务curr，如果进程处于运行状态，则调用update_curr更新vruntime，然后pick_next_entity取出红黑树最左边的节点，se=pick_next_entity(cfs_rq,curr);p=task_of(se);得到下一个调度实体对应的task_struct，如果发现和前任不一样，更新前任的vruntime，put_prev_entity放回红黑树，set_next_entity将设为当前任务，开始进行上下文切换，继任者进程开始正式运行。4 进程上下文切换 进程切换主要干2件事情，一是切换进程空间，二是切换寄存器和CPU上下文，4.1 context_switch函数，主要是内存空间的切换，switch_to 寄存器和栈的切换，他调用到了_switch_to_asm，栈的切换，切换的是栈顶指针。switch_to函数里面有一个Per CPU的结构体tss task state segment，这里面维护着所有的寄存器，还有一个tr 任务寄存器，指向某个进程的TSS，会给每个CPU都关联一个tss，有一个tr一直指向tss，在linux中参与进程切换的只有栈顶指针寄存器，有一个成员变量thread_struct thread，指向进程切换时需要切换的寄存器，进程切换，就是将tss的值更新到cpu里的TR指向的tss_struct。5指令指针的保存与恢复 ，5.1 从进程A切换到进程B，切换内存空间的时候，在内存空间里的用户栈已经切换，_switch_to里面将_curren_task指向当前的task_struct，里面的void * stack指针指向的就是内核栈，_switch_to_asm已经切换了栈顶指针，并且在_switch_to_加载到了tss里面，用户栈的栈顶指针，如果当前在内核栈，那他在内核栈顶部的pt_regs，当从内核返回用户态的时候，pt_regs里面所有的在用户态开始运行的上下文信息，就可以开始运行了。5.2 进程的调度都会调用_schedule函数，进程调度第一定律 ","like_count":0},{"had_liked":false,"id":114253,"user_name":"栋能","can_delete":false,"product_type":"c1","uid":1006849,"ip_address":"","ucode":"8BD9C939D3E8E1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/01/9cd84003.jpg","comment_is_top":false,"comment_ctime":1563261994,"is_pvip":false,"replies":[{"id":"46617","content":"1.如果最左面的节点还是自己，并且自己还能运行，也即还是running状态，那就接着运行，说明时间片用完了，但是没有更加高级的需要运行，如果是等待IO，那就不是running状态，则不在树中。<br><br>2.调度第一定律，B如果当年被调度走，哪怕是时间片到，也是调用了schedule的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566367702,"ip_address":"","comment_id":114253,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1563261994","product_id":100024701,"comment_content":"我有两个问题，希望老师解解惑：<br>1.文中说进程切换会从红黑树中找到最左结点，如果不等于当前进程，则切换。但如果更新vruntime之后，树结构还是没变呢，即最左还是等于当前进程，那我当前进程切换不是又没效果了吗？（这点有疑问，是我理解vruntime是公平的，但主动调度一定存在某种情况，如vruntime变化不大，树结构不变的？）<br>2.在指令指针的恢复与保存这部分内容中，你说A调用__schedule进行切换，在运行到finish_task_switch时进程已经是B了。你觉得这里没有问题，是因为A、B进程都是调用过__schedule方法进行进程切换，最后都执行finish_task_switch就是圆满了。可是进程切换除了主动调用之外，还有时间片用完，如B进程可能并没有调用过__schedule，那如果A进程切换，导致B进程执行finish_task_switch方法，那这是不是个问题呢？本来进程B并不需要执行它的。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458581,"discussion_content":"1.如果最左面的节点还是自己，并且自己还能运行，也即还是running状态，那就接着运行，说明时间片用完了，但是没有更加高级的需要运行，如果是等待IO，那就不是running状态，则不在树中。\n\n2.调度第一定律，B如果当年被调度走，哪怕是时间片到，也是调用了schedule的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566367702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26636,"discussion_content":"看了一下源码，pick_next_entity函数，首先调用\nstruct sched_entity *left = __pick_first_entity(cfs_rq);\n拿到最左边的  sched_entity，接着\t\nif (!left || (curr &amp;&amp; entity_before(curr, left)))\n\t\tleft = curr;\n其中 entity_before(a,b)很简单，就是return (s64)(a->vruntime - b->vruntime) < 0;\n没错，如果当前树中没有其他的进程，亦或者当前的curr小于left的vruntime，那么left就会变成curr。接下来就是判断curr是否是需要skip（也就是要跳过的），或者有没有设置cfs_rq->last，cfs_rq->next。其中cfs_rq->next是优先级最高，也就是真的有一个进程很想被执行，如果这些都没被设置，恭喜curr成为下一个被调度的进程，所以说这种情况时有可能存在的。上面几条评论，我也看了源码，确实在调用set_next_entity(cfs_rq, se); 时，里面调用了__dequeue_entity函数，把它从红黑树移走了，但是这颗红黑树最主要的作用是用来更新，rb_leftmost，也就是 __pick_first_entity(cfs_rq)函数的返回值。上面说了，即使拿到left，还是有可能被curr换掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570611645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142098,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/52/404912c3.jpg","nickname":"...","note":"","ucode":"9D73E00133C236","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5157,"discussion_content":"set net entity会从红黑树移除当前的节点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566013883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142098,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/52/404912c3.jpg","nickname":"...","note":"","ucode":"9D73E00133C236","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5156,"discussion_content":"https://blog.csdn.net/gatieme/article/details/52068016，在拿到下个shedual entity的时候，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566013825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142098,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/52/404912c3.jpg","nickname":"...","note":"","ucode":"9D73E00133C236","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5154,"discussion_content":"我开始也是和你有相同的疑惑，老师也很少回复留言了，所以只能自己去找食吃了，师傅领进门，修行在个人，这篇文章帮我解决了疑惑，附地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566013757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108649,"user_name":"雲至","can_delete":false,"product_type":"c1","uid":1568487,"ip_address":"","ucode":"47E2D099322BB1","user_header":"https://static001.geekbang.org/account/avatar/00/17/ee/e7/4375e97c.jpg","comment_is_top":false,"comment_ctime":1561820332,"is_pvip":false,"replies":[{"id":"48821","content":"编译内核，后面会有相应的章节","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567499456,"ip_address":"","comment_id":108649,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561820332","product_id":100024701,"comment_content":"老师能具体编译一个讲下吗？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456066,"discussion_content":"编译内核，后面会有相应的章节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567499456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98653,"user_name":"youyui","can_delete":false,"product_type":"c1","uid":1501890,"ip_address":"","ucode":"4CBD130E31CAEA","user_header":"https://static001.geekbang.org/account/avatar/00/16/ea/c2/445977ea.jpg","comment_is_top":false,"comment_ctime":1559051111,"is_pvip":false,"replies":[{"id":"35368","content":"不可以","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1559099412,"ip_address":"","comment_id":98653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559051111","product_id":100024701,"comment_content":"用户态可以操作寄存器进行cpu上下文切换么","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451771,"discussion_content":"不可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559099412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94381,"user_name":"周平","can_delete":false,"product_type":"c1","uid":1047936,"ip_address":"","ucode":"CA1869B139A4F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/80/52763d62.jpg","comment_is_top":false,"comment_ctime":1557798283,"is_pvip":false,"replies":[{"id":"33888","content":"没有用到硬件切换","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1557899652,"ip_address":"","comment_id":94381,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1557798283","product_id":100024701,"comment_content":"Linux 为关联一个 TSS用于进程切换，它在最底层有用到X86的x86 体系结构中，提供的以硬件的方式进行进程切换的模式吗？还是纯软件实现的？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450044,"discussion_content":"没有用到硬件切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557899652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312871,"discussion_content":"那为什么还要维护在换个TSS的值呀，，？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602839879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92341,"user_name":"川云","can_delete":false,"product_type":"c1","uid":1265438,"ip_address":"","ucode":"3D56399A7C5BDF","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/1e/e2b7a9ba.jpg","comment_is_top":false,"comment_ctime":1557237240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557237240","product_id":100024701,"comment_content":"这节看出老师真是功力深厚啊","like_count":0},{"had_liked":false,"id":91526,"user_name":"青石","can_delete":false,"product_type":"c1","uid":1215531,"ip_address":"","ucode":"B0056AD6453322","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg","comment_is_top":false,"comment_ctime":1557048973,"is_pvip":false,"replies":[{"id":"32853","content":"不是，tss启动后就不变了，在硬件看来没切换，软件仅仅修改变的几个寄存器","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1557154851,"ip_address":"","comment_id":91526,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557048973","product_id":100024701,"comment_content":"进程切换的过程，可不可以这么理解：<br><br>1. 在task_struct中的tss_struct是记录TSS段内容的，结构与寄存器结构相同，thread中保留了切换进程的时候需要修改的寄存器，当前任务寄存器TR指向的是当前运行进程的tss_struct；<br>2. 进程切换时，将CPU的寄存器TR指向到继任进程的tss_struct，同时触发CPU硬件保存当前寄存器的值到前任进程的tss_struct中，将继任进程的tss_struct中的内容写入到 寄存器中（只更新thread标记的寄存器）；","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448933,"discussion_content":"不是，tss启动后就不变了，在硬件看来没切换，软件仅仅修改变的几个寄存器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557154851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91321,"user_name":"小龙的城堡","can_delete":false,"product_type":"c1","uid":1005727,"ip_address":"","ucode":"7F1F9704548E2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/9f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1556979318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556979318","product_id":100024701,"comment_content":"老师讲的很清楚！👍🏻","like_count":0},{"had_liked":false,"id":91278,"user_name":"tiankonghewo","can_delete":false,"product_type":"c1","uid":1476427,"ip_address":"","ucode":"7A55A9C17DD9DF","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/4b/16ea3997.jpg","comment_is_top":false,"comment_ctime":1556961800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556961800","product_id":100024701,"comment_content":"学习了","like_count":0}]}