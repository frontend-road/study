{"id":293929,"title":"23 | 旁路缓存：Redis是如何工作的？","content":"<p>你好，我是蒋德钧。</p><p>我们知道，Redis提供了高性能的数据存取功能，所以广泛应用在缓存场景中，既能有效地提升业务应用的响应速度，还可以避免把高并发大压力的请求发送到数据库层。</p><p>但是，如果Redis做缓存时出现了问题，比如说缓存失效，那么，大量请求就会直接积压到数据库层，必然会给数据库带来巨大的压力，很可能会导致数据库宕机或是故障，那么，业务应用就没有办法存取数据、响应用户请求了。这种生产事故，肯定不是我们希望看到的。</p><p>正因为Redis用作缓存的普遍性以及它在业务应用中的重要作用，所以，我们需要系统地掌握缓存的一系列内容，包括工作原理、替换策略、异常处理和扩展机制。具体来说，我们需要解决四个关键问题：</p><ul>\n<li>Redis缓存具体是怎么工作的？</li>\n<li>Redis缓存如果满了，该怎么办？</li>\n<li>为什么会有缓存一致性、缓存穿透、缓存雪崩、缓存击穿等异常，该如何应对？</li>\n<li>Redis的内存毕竟有限，如果用快速的固态硬盘来保存数据，可以增加缓存的数据量，那么，Redis缓存可以使用快速固态硬盘吗？</li>\n</ul><p>这节课，我们来了解下缓存的特征和Redis适用于缓存的天然优势，以及Redis缓存的具体工作机制。</p><h2>缓存的特征</h2><p>要想弄明白Redis为什么适合用作缓存，我们得清楚缓存都有什么特征。</p><!-- [[[read_end]]] --><p>首先，你要知道，一个系统中的不同层之间的访问速度不一样，所以我们才需要缓存，这样就可以把一些需要频繁访问的数据放在缓存中，以加快它们的访问速度。</p><p>为了让你能更好地理解，我以计算机系统为例，来解释一下。下图是计算机系统中的三层存储结构，以及它们各自的常用容量和访问性能。最上面是处理器，中间是内存，最下面是磁盘。</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/9c/ac80f6e1714f3e1e8eabcfd8da3d689c.jpg?wh=2128*1280\" alt=\"\"></p><p>从图上可以看到，CPU、内存和磁盘这三层的访问速度从几十ns到100ns，再到几ms，性能的差异很大。</p><p>想象一下，如果每次CPU处理数据时，都要从ms级别的慢速磁盘中读取数据，然后再进行处理，那么，CPU只能等磁盘的数据传输完成。这样一来，高速的CPU就被慢速的磁盘拖累了，整个计算机系统的运行速度会变得非常慢。</p><p>所以，计算机系统中，默认有两种缓存：</p><ul>\n<li>CPU里面的末级缓存，即LLC，用来缓存内存中的数据，避免每次从内存中存取数据；</li>\n<li>内存中的高速页缓存，即page cache，用来缓存磁盘中的数据，避免每次从磁盘中存取数据。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/7d/44/7dyycf727f9396eb9788644474855a44.jpg?wh=2156*1239\" alt=\"\"></p><p>跟内存相比，LLC的访问速度更快，而跟磁盘相比，内存的访问是更快的。所以，我们可以看出来缓存的<strong>第一个特征</strong>：在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。对应到互联网应用来说，Redis就是快速子系统，而数据库就是慢速子系统了。</p><p>知道了这一点，你就能理解，为什么我们必须想尽办法让Redis提供高性能的访问，因为，如果访问速度很慢，Redis作为缓存的价值就不大了。</p><p>我们再看一下刚才的计算机分层结构。LLC的大小是MB级别，page cache的大小是GB级别，而磁盘的大小是TB级别。这其实包含了缓存的<strong>第二个特征：缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中</strong>。</p><p>这个很有意思，它表明，缓存的容量终究是有限的，缓存中的数据量也是有限的，肯定是没法时刻都满足访问需求的。所以，缓存和后端慢速系统之间，必然存在数据写回和再读取的交互过程。简单来说，缓存中的数据需要按一定规则淘汰出去，写回后端系统，而新的数据又要从后端系统中读取进来，写入缓存。</p><p>说到这儿，你肯定会想到，Redis本身是支持按一定规则淘汰数据的，相当于实现了缓存的数据淘汰，其实，这也是Redis适合用作缓存的一个重要原因。</p><p>好了，我们现在了解了缓存的两个重要特征，那么，接下来，我们就来学习下，缓存是怎么处理请求的。实际上，业务应用在访问Redis缓存中的数据时，数据不一定存在，因此，处理的方式也不同。</p><h2>Redis缓存处理请求的两种情况</h2><p>把Redis用作缓存时，我们会把Redis部署在数据库的前端，业务应用在访问数据时，会先查询Redis中是否保存了相应的数据。此时，根据数据是否存在缓存中，会有两种情况。</p><ul>\n<li><strong>缓存命中</strong>：Redis中有相应数据，就直接读取Redis，性能非常快。</li>\n<li><strong>缓存缺失</strong>：Redis中没有保存相应数据，就从后端数据库中读取数据，性能就会变慢。而且，一旦发生缓存缺失，为了让后续请求能从缓存中读取到数据，我们需要把缺失的数据写入Redis，这个过程叫作缓存更新。缓存更新操作会涉及到保证缓存和数据库之间的数据一致性问题，关于这一点，我会在第25讲中再具体介绍。</li>\n</ul><p>我画了一张图，清晰地展示了发生缓存命中或缺失时，应用读取数据的情况，你可以看下这张图片。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/3d/6b0b489ec0c1c5049c8df84d77fa243d.jpg?wh=2750*1631\" alt=\"\"></p><p>假设我们在一个Web应用中，使用Redis作为缓存。用户请求发送给Tomcat，Tomcat负责处理业务逻辑。如果要访问数据，就需要从MySQL中读写数据。那么，我们可以把Redis部署在MySQL前端。如果访问的数据在Redis中，此时缓存命中，Tomcat可以直接从Redis中读取数据，加速应用的访问。否则，Tomcat就需要从慢速的数据库中读取数据了。</p><p>到这里，你可能已经发现了，使用Redis缓存时，我们基本有三个操作：</p><ul>\n<li>应用读取数据时，需要先读取Redis；</li>\n<li>发生缓存缺失时，需要从数据库读取数据；</li>\n<li>发生缓存缺失时，还需要更新缓存。</li>\n</ul><p>那么，这些操作具体是由谁来做的呢？这和Redis缓存的使用方式相关。接下来，我就来和你聊聊Redis作为旁路缓存的使用操作方式。</p><h2>Redis作为旁路缓存的使用操作</h2><p>Redis是一个独立的系统软件，和业务应用程序是两个软件，当我们部署了Redis实例后，它只会被动地等待客户端发送请求，然后再进行处理。所以，如果应用程序想要使用Redis缓存，我们就要在程序中增加相应的缓存操作代码。所以，我们也把Redis称为旁路缓存，也就是说，读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。</p><p>这和我刚才讲的计算机系统中的LLC和page cache不一样。你可以回想下，平时在开发程序时，我们是没有专门在代码中显式地创建LLC或page cache的实例的，也没有显式调用过它们的GET接口。这是因为，我们在构建计算机硬件系统时，已经把LLC和page cache放在了应用程序的数据访问路径上，应用程序访问数据时直接就能用上缓存。</p><p>那么，使用Redis缓存时，具体来说，我们需要在应用程序中增加三方面的代码：</p><ul>\n<li>当应用程序需要读取数据时，我们需要在代码中显式调用Redis的GET操作接口，进行查询；</li>\n<li>如果缓存缺失了，应用程序需要再和数据库连接，从数据库中读取数据；</li>\n<li>当缓存中的数据需要更新时，我们也需要在应用程序中显式地调用SET操作接口，把更新的数据写入缓存。</li>\n</ul><p>那么，代码应该怎么加呢？我给你展示一段Web应用中使用Redis缓存的伪代码示例。</p><pre><code>String cacheKey = “productid_11010003”;\nString cacheValue = redisCache.get(cacheKey)；\n//缓存命中\nif ( cacheValue != NULL)\n   return cacheValue;\n//缓存缺失\nelse\n   cacheValue = getProductFromDB();\n   redisCache.put(cacheValue)  //缓存更新\n</code></pre><p>可以看到，为了使用缓存，Web应用程序需要有一个表示缓存系统的实例对象redisCache，还需要主动调用Redis的GET接口，并且要处理缓存命中和缓存缺失时的逻辑，例如在缓存缺失时，需要更新缓存。</p><p>了解了这一点，我们在使用Redis缓存时，有一个地方就需要注意了：因为需要新增程序代码来使用缓存，所以，Redis并不适用于那些无法获得源码的应用，例如一些很早之前开发的应用程序，它们的源码已经没有再维护了，或者是第三方供应商开发的应用，没有提供源码，所以，我们就没有办法在这些应用中进行缓存操作。</p><p>在使用旁路缓存时，我们需要在应用程序中增加操作代码，增加了使用Redis缓存的额外工作量，但是，也正因为Redis是旁路缓存，是一个独立的系统，我们可以单独对Redis缓存进行扩容或性能优化。而且，只要保持操作接口不变，我们在应用程序中增加的代码就不用再修改了。</p><p>好了，到这里，我们知道了，通过在应用程序中加入Redis的操作代码，我们可以让应用程序使用Redis缓存数据了。不过，除了从Redis缓存中查询、读取数据以外，应用程序还可能会对数据进行修改，这时，我们既可以在缓存中修改，也可以在后端数据库中进行修改，我们该怎么选择呢？</p><p>其实，这就涉及到了Redis缓存的两种类型：只读缓存和读写缓存。只读缓存能加速读请求，而读写缓存可以同时加速读写请求。而且，读写缓存又有两种数据写回策略，可以让我们根据业务需求，在保证性能和保证数据可靠性之间进行选择。所以，接下来，我们来具体了解下Redis的缓存类型和相应的写回策略。</p><h2>缓存的类型</h2><p>按照Redis缓存是否接受写请求，我们可以把它分成只读缓存和读写缓存。先来了解下只读缓存。</p><h3>只读缓存</h3><p>当Redis用作只读缓存时，应用要读取数据的话，会先调用Redis GET接口，查询数据是否存在。而所有的数据写请求，会直接发往后端的数据库，在数据库中增删改。对于删改的数据来说，如果Redis已经缓存了相应的数据，应用需要把这些缓存的数据删除，Redis中就没有这些数据了。</p><p>当应用再次读取这些数据时，会发生缓存缺失，应用会把这些数据从数据库中读出来，并写到缓存中。这样一来，这些数据后续再被读取时，就可以直接从缓存中获取了，能起到加速访问的效果。</p><p>我给你举个例子。假设业务应用要修改数据A，此时，数据A在Redis中也缓存了，那么，应用会先直接在数据库里修改A，并把Redis中的A删除。等到应用需要读取数据A时，会发生缓存缺失，此时，应用从数据库中读取A，并写入Redis，以便后续请求从缓存中直接读取，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/46/cd/464ea24a098c87b9d292cf61a2b2fecd.jpg?wh=3000*1638\" alt=\"\"></p><p>只读缓存直接在数据库中更新数据的好处是，所有最新的数据都在数据库中，而数据库是提供数据可靠性保障的，这些数据不会有丢失的风险。当我们需要缓存图片、短视频这些用户只读的数据时，就可以使用只读缓存这个类型了。</p><h3>读写缓存</h3><p>知道了只读缓存，读写缓存也就很容易理解了。</p><p>对于读写缓存来说，除了读请求会发送到缓存进行处理（直接在缓存中查询数据是否存在)，所有的写请求也会发送到缓存，在缓存中直接对数据进行增删改操作。此时，得益于Redis的高性能访问特性，数据的增删改操作可以在缓存中快速完成，处理结果也会快速返回给业务应用，这就可以提升业务应用的响应速度。</p><p>但是，和只读缓存不一样的是，在使用读写缓存时，最新的数据是在Redis中，而Redis是内存数据库，一旦出现掉电或宕机，内存中的数据就会丢失。这也就是说，应用的最新数据可能会丢失，给应用业务带来风险。</p><p>所以，根据业务应用对数据可靠性和缓存性能的不同要求，我们会有同步直写和异步写回两种策略。其中，同步直写策略优先保证数据可靠性，而异步写回策略优先提供快速响应。学习了解这两种策略，可以帮助我们根据业务需求，做出正确的设计选择。</p><p>接下来，我们来具体看下这两种策略。</p><p>同步直写是指，写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回。这样，即使缓存宕机或发生故障，最新的数据仍然保存在数据库中，这就提供了数据可靠性保证。</p><p>不过，同步直写会降低缓存的访问性能。这是因为缓存中处理写请求的速度是很快的，而数据库处理写请求的速度较慢。即使缓存很快地处理了写请求，也需要等待数据库处理完所有的写请求，才能给应用返回结果，这就增加了缓存的响应延迟。</p><p>而异步写回策略，则是优先考虑了响应延迟。此时，所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库。这样一来，处理这些数据的操作是在缓存中进行的，很快就能完成。只不过，如果发生了掉电，而它们还没有被写回数据库，就会有丢失的风险了。</p><p>为了便于你理解，我也画了下面这张图，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/00/66/009d055bb91d42c28b9316c649f87f66.jpg?wh=2878*1566\" alt=\"\"></p><p>关于是选择只读缓存，还是读写缓存，主要看我们对写请求是否有加速的需求。</p><ul>\n<li>如果需要对写请求进行加速，我们选择读写缓存；</li>\n<li>如果写请求很少，或者是只需要提升读请求的响应速度的话，我们选择只读缓存。</li>\n</ul><p>举个例子，在商品大促的场景中，商品的库存信息会一直被修改。如果每次修改都需到数据库中处理，就会拖慢整个应用，此时，我们通常会选择读写缓存的模式。而在短视频App的场景中，虽然视频的属性有很多，但是，一般确定后，修改并不频繁，此时，在数据库中进行修改对缓存影响不大，所以只读缓存模式是一个合适的选择。</p><h2>小结</h2><p>今天，我们学习了缓存的两个特征，分别是在分层系统中，数据暂存在快速子系统中有助于加速访问；缓存容量有限，缓存写满时，数据需要被淘汰。而Redis天然就具有高性能访问和数据淘汰机制，正好符合缓存的这两个特征的要求，所以非常适合用作缓存。</p><p>另外，我们还学习了Redis作为旁路缓存的特性，旁路缓存就意味着需要在应用程序中新增缓存逻辑处理的代码。当然，如果是无法修改源码的应用场景，就不能使用Redis做缓存了。</p><p>Redis做缓存时，还有两种模式，分别是只读缓存和读写缓存。其中，读写缓存还提供了同步直写和异步写回这两种模式，同步直写模式侧重于保证数据可靠性，而异步写回模式则侧重于提供低延迟访问，我们要根据实际的业务场景需求来进行选择。</p><p>这节课，虽然我提到了Redis有数据淘汰机制，但是并没有展开讲具体的淘汰策略。那么，Redis究竟是怎么淘汰数据的呢？我会在下节课给你具体介绍。</p><h2>每课一问</h2><p>按照惯例，我给你提一个小问题。这节课，我提到了Redis只读缓存和使用直写策略的读写缓存，这两种缓存都会把数据同步写到后端数据库中，你觉得，它们有什么区别吗？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事。我们下节课见。</p>","comments":[{"had_liked":false,"id":252197,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1602173786,"is_pvip":true,"discussion_count":61,"race_medal":0,"score":"1096818834266","product_id":100056701,"comment_content":"Redis只读缓存和使用直写策略的读写缓存，这两种缓存都会把数据同步写到后端数据库中，它们的区别在于：<br><br>1、使用只读缓存时，是先把修改写到后端数据库中，再把缓存中的数据删除。当下次访问这个数据时，会以后端数据库中的值为准，重新加载到缓存中。这样做的优点是，数据库和缓存可以保证完全一致，并且缓存中永远保留的是经常访问的热点数据。缺点是每次修改操作都会把缓存中的数据删除，之后访问时都会先触发一次缓存缺失，然后从后端数据库加载数据到缓存中，这个过程访问延迟会变大。<br><br>2、使用读写缓存时，是同时修改数据库和缓存中的值。这样做的优点是，被修改后的数据永远在缓存中存在，下次访问时，能够直接命中缓存，不用再从后端数据库中查询，这个过程拥有比较好的性能，比较适合先修改又立即访问的业务场景。但缺点是在高并发场景下，如果存在多个操作同时修改同一个值的情况，可能会导致缓存和数据库的不一致。<br><br>3、当使用只读缓存时，如果修改数据库失败了，那么缓存中的数据也不会被删除，此时数据库和缓存中的数据依旧保持一致。而使用读写缓存时，如果是先修改缓存，后修改数据库，如果缓存修改成功，而数据库修改失败了，那么此时数据库和缓存数据就不一致了。如果先修改数据库，再修改缓存，也会产生上面所说的并发场景下的不一致。<br><br>我个人总结，只读缓存是牺牲了一定的性能，优先保证数据库和缓存的一致性，它更适合对于一致性要求比较要高的业务场景。而如果对于数据库和缓存一致性要求不高，或者不存在并发修改同一个值的情况，那么使用读写缓存就比较合适，它可以保证更好的访问性能。","like_count":254,"discussions":[{"author":{"id":2039818,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ECOJ2KphCShZuPK5JTTfAAmvzYscsbWtw2s8Zib1mrf5mOMgIkjlzoDLpV70wCQIGRqrCicv8S3rVmOvHt3MmWJA/132","nickname":"Geek_fbb524","note":"","ucode":"4493CCE9A47777","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318902,"discussion_content":"只读缓存可以采用延迟双删的办法，先删除redis的数据，在修改数据库，在删除redis数据","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1603877833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2131606,"avatar":"","nickname":"Geek_da4cfb","note":"","ucode":"DB59B24A249713","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2039818,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ECOJ2KphCShZuPK5JTTfAAmvzYscsbWtw2s8Zib1mrf5mOMgIkjlzoDLpV70wCQIGRqrCicv8S3rVmOvHt3MmWJA/132","nickname":"Geek_fbb524","note":"","ucode":"4493CCE9A47777","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322263,"discussion_content":"？？没看懂呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604715366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318902,"ip_address":""},"score":322263,"extra":""},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2039818,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ECOJ2KphCShZuPK5JTTfAAmvzYscsbWtw2s8Zib1mrf5mOMgIkjlzoDLpV70wCQIGRqrCicv8S3rVmOvHt3MmWJA/132","nickname":"Geek_fbb524","note":"","ucode":"4493CCE9A47777","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331103,"discussion_content":"意义是啥？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606788822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318902,"ip_address":""},"score":331103,"extra":""},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2039818,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ECOJ2KphCShZuPK5JTTfAAmvzYscsbWtw2s8Zib1mrf5mOMgIkjlzoDLpV70wCQIGRqrCicv8S3rVmOvHt3MmWJA/132","nickname":"Geek_fbb524","note":"","ucode":"4493CCE9A47777","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336735,"discussion_content":"我感觉这哥们可能说的是 读写模式 如何解决并发情况下 db与redis 数据尽可能一致的情况，但实际是延迟双写也没用，高一致性只能分布式锁来搞定了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608690218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318902,"ip_address":""},"score":336735,"extra":""}]},{"author":{"id":1114999,"avatar":"https://static001.geekbang.org/account/avatar/00/11/03/77/3f6a76a9.jpg","nickname":"极客","note":"","ucode":"A4AAA6B4F40E66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312483,"discussion_content":"只读缓存也只能保证最终一致性，比如修改数据库成功，删除缓存失败的时候。就算缓存存在有效期，在有效期内，数据还是不一致的。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1602719889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":15,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1114999,"avatar":"https://static001.geekbang.org/account/avatar/00/11/03/77/3f6a76a9.jpg","nickname":"极客","note":"","ucode":"A4AAA6B4F40E66","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312499,"discussion_content":"是的。需要通过消息队列重试保证最终一致性。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1602723123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312483,"ip_address":""},"score":312499,"extra":""},{"author":{"id":1768852,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/94/8704d2b0.jpg","nickname":"spoofer","note":"","ucode":"6723F64ACC3F27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1114999,"avatar":"https://static001.geekbang.org/account/avatar/00/11/03/77/3f6a76a9.jpg","nickname":"极客","note":"","ucode":"A4AAA6B4F40E66","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323663,"discussion_content":"没法保证一致性，缓存删除后，更新数据库前其他线程读取了旧的数据然后set 了redis，缓存还是旧的，就算是双删（删缓存写db再删一次缓存）也没有办法阻止这种情况的出现。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604979098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312483,"ip_address":""},"score":323663,"extra":""},{"author":{"id":2266823,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTImStnqqs4z5GTm0HX6AibtvFA54RalYHfiaFwZTBEQ5rCfe46FcLsdEtmH8ePuDHGT9eBj4703aJXA/132","nickname":"Geek_691992","note":"","ucode":"0DE462AE9D75A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1768852,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/94/8704d2b0.jpg","nickname":"spoofer","note":"","ucode":"6723F64ACC3F27","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324272,"discussion_content":"为什么没办法阻止啊，第二次删除后在读取不就是新的了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605084288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":323663,"ip_address":""},"score":324272,"extra":""}]},{"author":{"id":1508661,"avatar":"https://static001.geekbang.org/account/avatar/00/17/05/35/970beb60.jpg","nickname":"你微笑时好美","note":"","ucode":"BC18A533DC9410","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390511,"discussion_content":"我觉得使用读写缓存时，写数据库和写缓存这两个操作是不是要保证原子性和加锁，不然那两个操作一个成功一个失败缓存和db肯定就不一致了，并发修改的时候也会有不一致。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1629872600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2764938,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/30/8a/41a1fd6a.jpg","nickname":"大大的沙包","note":"","ucode":"0A2CB16F90ECF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1508661,"avatar":"https://static001.geekbang.org/account/avatar/00/17/05/35/970beb60.jpg","nickname":"你微笑时好美","note":"","ucode":"BC18A533DC9410","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413931,"discussion_content":"捕捉一只Acer","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636613574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":390511,"ip_address":""},"score":413931,"extra":""}]},{"author":{"id":1179560,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/a8/73cd4a30.jpg","nickname":"千万海","note":"","ucode":"941C431A163B83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329725,"discussion_content":"同步直写应该没有一致性问题的，毕竟先写数据库，相当于加锁了。事务在写完redis 后再提交","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606450602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179560,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/a8/73cd4a30.jpg","nickname":"千万海","note":"","ucode":"941C431A163B83","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329928,"discussion_content":"你的意思是开启一个mysql的事务，然后将redis的修改包裹在这个事务中吗？\n这样也是有问题的：比如redis的修改成功了，但是mysql的事务执行失败回滚到之前的状态了，此时redis是无法回滚的。\n\nmysql的事务是有可能执行失败并且回滚的，但是包裹在其中的redis的修改是成功的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606482738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329725,"ip_address":""},"score":329928,"extra":""},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179560,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/a8/73cd4a30.jpg","nickname":"千万海","note":"","ucode":"941C431A163B83","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336734,"discussion_content":"2部不同组件的操作 需要分布式锁解决，但是假如分布式锁要看场景  大概率可能会  得不偿失","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608690152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329725,"ip_address":""},"score":336734,"extra":""},{"author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179560,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/a8/73cd4a30.jpg","nickname":"千万海","note":"","ucode":"941C431A163B83","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338780,"discussion_content":"mysql的事务只能保证表操作正常回滚,想要和redis同时回滚就涉及到分布式事务了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609380929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329725,"ip_address":""},"score":338780,"extra":""}]},{"author":{"id":2037343,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/w5clq5iao6Drk2omjqdcJSVicHLffzwsJnqOdD7HATD4904UgXKr5LCfAa90bNLhr7uia0mjyxcF1HGibKQXzicSB7A/132","nickname":"Geek_7b634a","note":"","ucode":"F7E9652F667C39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389106,"discussion_content":"如果是使用只读缓存，如果是热点数据会存在大量并发击穿redis到DB的可能吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629120514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1093258,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","nickname":"赤云","note":"","ucode":"67476D582D8B6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2037343,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/w5clq5iao6Drk2omjqdcJSVicHLffzwsJnqOdD7HATD4904UgXKr5LCfAa90bNLhr7uia0mjyxcF1HGibKQXzicSB7A/132","nickname":"Geek_7b634a","note":"","ucode":"F7E9652F667C39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397531,"discussion_content":"加分布式锁啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632633081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389106,"ip_address":""},"score":397531,"extra":""},{"author":{"id":1292669,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaaDFHiag4sFcO7JUn028Mtk1YvFpibIibLzcTE7Qak0icJklMpqh7k5dSK27dibicMuNgYMozgaibeYppA/132","nickname":"Bball","note":"","ucode":"E483CAFE50CB99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1093258,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","nickname":"赤云","note":"","ucode":"67476D582D8B6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412228,"discussion_content":"要加锁的，不然很容易数据不一致了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636109036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":397531,"ip_address":""},"score":412228,"extra":""},{"author":{"id":2115387,"avatar":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","nickname":"Aibo","note":"","ucode":"2CE3E77BD2D014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2037343,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/w5clq5iao6Drk2omjqdcJSVicHLffzwsJnqOdD7HATD4904UgXKr5LCfAa90bNLhr7uia0mjyxcF1HGibKQXzicSB7A/132","nickname":"Geek_7b634a","note":"","ucode":"F7E9652F667C39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550797,"discussion_content":"singlefly（进程内锁）或者分布式锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644733524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389106,"ip_address":""},"score":550797,"extra":""}]},{"author":{"id":2105175,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","nickname":"Geek_72b9a7","note":"","ucode":"4C26B79F9F15A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389038,"discussion_content":"读写不一致性 有必要设定过期，下一次让其缓存缺失将新值写入","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629100302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202572,"avatar":"https://static001.geekbang.org/account/avatar/00/12/59/8c/ba81a832.jpg","nickname":"刀斧手何在","note":"","ucode":"B99D7ECC3EE954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311441,"discussion_content":"旁路缓存模式下，保证数据最终一致性。选择直接删除缓存，还是对相应的key设置一个短时间的过期时间。优缺点 如何取舍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602339595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1202572,"avatar":"https://static001.geekbang.org/account/avatar/00/12/59/8c/ba81a832.jpg","nickname":"刀斧手何在","note":"","ucode":"B99D7ECC3EE954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311471,"discussion_content":"一般使用删除缓存。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602345309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311441,"ip_address":""},"score":311471,"extra":""},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1202572,"avatar":"https://static001.geekbang.org/account/avatar/00/12/59/8c/ba81a832.jpg","nickname":"刀斧手何在","note":"","ucode":"B99D7ECC3EE954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336743,"discussion_content":"我理解  一般而言 是 删除缓存 外加 设置一定的过期时间。过期时间带一个较短的随机时间段，防止大面积缓存穿透 即可。这样  热的数据 一直热下去，不热的数据也不会占用内存","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608691068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311441,"ip_address":""},"score":336743,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1202572,"avatar":"https://static001.geekbang.org/account/avatar/00/12/59/8c/ba81a832.jpg","nickname":"刀斧手何在","note":"","ucode":"B99D7ECC3EE954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339772,"discussion_content":"工程上最佳实践是删缓存，关键词搜索cache aside","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609772620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311441,"ip_address":""},"score":339772,"extra":""}]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553555,"discussion_content":"mark，只能保证最终一致性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645966024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192724,"avatar":"https://static001.geekbang.org/account/avatar/00/12/33/14/78104f1f.jpg","nickname":"Just Do IT","note":"","ucode":"1EAD92510FA7BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359206,"discussion_content":"课代表，第二点的这句话可以这么理解吗。\n\n虽然redis是原子性的，但在高并发的写的场景中写请求不一定是有序的，这就导致redis的最终数据可能存在曾经被覆盖的情况。（假如数据库是有序修改的前提下，数据库的数据是准的，redis的数据是错的，事实上，数据库的修改也会存在如redis的问题。所以，如果想避免应该采用阻塞式的内存队列去对请求进行排队）\n\n”但缺点是在高并发场景下，如果存在多个操作同时修改同一个值的情况，可能会导致缓存和数据库的不一致。“","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616138584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1192724,"avatar":"https://static001.geekbang.org/account/avatar/00/12/33/14/78104f1f.jpg","nickname":"Just Do IT","note":"","ucode":"1EAD92510FA7BE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359354,"discussion_content":"高并发指的是多个客户端，对同一条业务数据进行修改，而且不控制资源竞争问题，那谁先改谁后改这是不确定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616166167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":359206,"ip_address":""},"score":359354,"extra":""}]},{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348316,"discussion_content":"好多大厂不都实现的 实时监听  mysql 数据库的日志文件，进行更新缓存吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612510051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1526471,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/c7/0cff4a59.jpg","nickname":"木木夕","note":"","ucode":"EA5D709D0DE50E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363021,"discussion_content":"大部分都是先更新数据，然后删除缓存！如果再严格就是延时双删配合binlog","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617098160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":348316,"ip_address":""},"score":363021,"extra":""},{"author":{"id":1175246,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ee/ce/c024a857.jpg","nickname":"藏锋","note":"","ucode":"D5F811B16725A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1526471,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/c7/0cff4a59.jpg","nickname":"木木夕","note":"","ucode":"EA5D709D0DE50E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367609,"discussion_content":"增加组件订阅binlog完成缓存的更新，就不需要延时双删策略了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618406762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363021,"ip_address":""},"score":367609,"extra":""},{"author":{"id":1641326,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJDdmHm6txEVtEXEDibSdIsRLEpghOoMt2kfZHetY9QLWHygicKCfhVoYiaylAZJoXbcCMBhXqMF4icgw/132","nickname":"洗洗睡吧","note":"","ucode":"DE7F8B4CA512F6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1175246,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ee/ce/c024a857.jpg","nickname":"藏锋","note":"","ucode":"D5F811B16725A0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386444,"discussion_content":"订阅binlog的目的也是删除缓存，是延时双删的实现方式之一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627591773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367609,"ip_address":""},"score":386444,"extra":""}]},{"author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311179,"discussion_content":"只读缓冲可能不只触发一次缓存失效，在协程的环境下，问题会被放大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602244598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311288,"discussion_content":"正常情况下，查询数据库之前，会增加分布式锁，只允许查询DB一次，在DB查询未返回前，其他线程会阻塞着。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602297878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311179,"ip_address":""},"score":311288,"extra":""},{"author":{"id":1977474,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","nickname":"Reborn 2.0","note":"","ucode":"BA506E7455D91C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":325995,"discussion_content":"但是其他线程阻塞过后也会查数据库啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605495611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311288,"ip_address":""},"score":325995,"extra":""},{"author":{"id":1849703,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/39/67/2477b20e.jpg","nickname":"瑞哥","note":"","ucode":"3AE6DCDAE5844F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1977474,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","nickname":"Reborn 2.0","note":"","ucode":"BA506E7455D91C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334812,"discussion_content":"阻塞过后缓存有数据了，就不会查数据库了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607996757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325995,"ip_address":""},"score":334812,"extra":""}]},{"author":{"id":1311172,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/c4/21c2cde4.jpg","nickname":"窗外","note":"","ucode":"1E8F2D9439E7F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311109,"discussion_content":"而使用读写缓存时，如果是先修改缓存，后修改数据库，如果缓存修改成功，而数据库修改失败了，那么此时数据库和缓存数据就不一致了。\n\n这个是异步回写时才可能出现的问题吧，同步直写时至少要保障原子性，那要么都成功，要么都失败，不应该出现这种情况的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602224163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1311172,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/c4/21c2cde4.jpg","nickname":"窗外","note":"","ucode":"1E8F2D9439E7F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311118,"discussion_content":"就是说因为很难保证原子性，所以才有不一致的情况。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602228491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311109,"ip_address":""},"score":311118,"extra":""},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1311172,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/c4/21c2cde4.jpg","nickname":"窗外","note":"","ucode":"1E8F2D9439E7F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374791,"discussion_content":"redis和mysql是两套系统，不在一个事物里面，没办法保证原子性吧，应该可以用两阶段提交保证最终一致性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621348464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311109,"ip_address":""},"score":374791,"extra":""}]},{"author":{"id":2120879,"avatar":"https://static001.geekbang.org/account/avatar/00/20/5c/af/2215f3b6.jpg","nickname":"徐小熊","note":"","ucode":"673D3C055AE5B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311088,"discussion_content":"意思是读写缓存只能保证数据最终一致性，会存在一些时间缓存和数据库数据不一致的情况，不过缓存中的数据都是最新的，所以即使数据库与缓存数据在一定时间不一致应该也不会影响业务的，因为数据都是先从缓存中读取，所以业务应该获取的总是最新最正确的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602217608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2120879,"avatar":"https://static001.geekbang.org/account/avatar/00/20/5c/af/2215f3b6.jpg","nickname":"徐小熊","note":"","ucode":"673D3C055AE5B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311095,"discussion_content":"不是的，数据库和缓存不一致是有问题的，你可以查一下缓存和数据库一致性的问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602219240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311088,"ip_address":""},"score":311095,"extra":""},{"author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2120879,"avatar":"https://static001.geekbang.org/account/avatar/00/20/5c/af/2215f3b6.jpg","nickname":"徐小熊","note":"","ucode":"673D3C055AE5B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311178,"discussion_content":"除非加上自动过期删除，不然没法最终一致性的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602244479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311088,"ip_address":""},"score":311178,"extra":""}]}]},{"had_liked":false,"id":252260,"user_name":"可怜大灰狼","can_delete":false,"product_type":"c1","uid":1928373,"ip_address":"","ucode":"6CA9D6D460B967","user_header":"https://static001.geekbang.org/account/avatar/00/1d/6c/b5/32374f93.jpg","comment_is_top":false,"comment_ctime":1602217151,"is_pvip":true,"discussion_count":22,"race_medal":0,"score":"108976399551","product_id":100056701,"comment_content":"对只读缓存方式的操作，先删redis，再修改db，最后删redis。用双删保证数据一致性。","like_count":26,"discussions":[{"author":{"id":1638541,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/8d/45c1f62f.jpg","nickname":"🇵  🇦  🇼  🇳 ","note":"","ucode":"1F825BACA9FD99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386077,"discussion_content":"感觉前一次删除没有意义，在数据库还没写提交事务时，可以读到旧数据，这是正常的，如果第一次就删除了key，事务在修改数据库，下一个事务去访问同一行，由于MVCC，还是会访问到旧的数据，和Redis删除前的一致，所以说第一次删除没有意义，还增加了一次数据库查询。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1627393710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1733294,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/72/ae/297bef7d.jpg","nickname":"番茄","note":"","ucode":"B570A62BEE85A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1638541,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/8d/45c1f62f.jpg","nickname":"🇵  🇦  🇼  🇳 ","note":"","ucode":"1F825BACA9FD99","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591341,"discussion_content":"我觉得是有意义的。如果不先删除redis：刚修改完db后，这时另一个请求进来发现有redis缓存，就直接返回了。而此时db的数据是最新的，而缓存不是最新的。导致请求到的数据不是最新的。\n这样可以尽可能地保持数据的一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666520593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":386077,"ip_address":"广东"},"score":591341,"extra":""}]},{"author":{"id":1613760,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/c0/86febfff.jpg","nickname":"Master","note":"","ucode":"79D0145B853C9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374162,"discussion_content":"第一次删除其实有点值得商榷，因为删除了，那么如果是热key，而且数据库是个长事务，可能就没写成功，那么其实多余了一次db访问，而且读的还是旧的，没啥意义啊，等于我还是玩了旧的，还费劲做了点花里胡哨的事情；第二次删除没毛病。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1621046217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2676330,"avatar":"https://static001.geekbang.org/account/avatar/00/28/d6/6a/1d844a27.jpg","nickname":"冲冲冲","note":"","ucode":"4DA7596B5AFD51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1613760,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/c0/86febfff.jpg","nickname":"Master","note":"","ucode":"79D0145B853C9E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390944,"discussion_content":"延迟双删是这样的，第一次是必须要删的，你不删数据就不一致了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630165211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":374162,"ip_address":""},"score":390944,"extra":""},{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2676330,"avatar":"https://static001.geekbang.org/account/avatar/00/28/d6/6a/1d844a27.jpg","nickname":"冲冲冲","note":"","ucode":"4DA7596B5AFD51","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577807,"discussion_content":"比如?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656344945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":390944,"ip_address":""},"score":577807,"extra":""},{"author":{"id":3104129,"avatar":"https://static001.geekbang.org/account/avatar/00/2f/5d/81/1a6481df.jpg","nickname":"卢本伟","note":"","ucode":"CA98F61F170624","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2676330,"avatar":"https://static001.geekbang.org/account/avatar/00/28/d6/6a/1d844a27.jpg","nickname":"冲冲冲","note":"","ucode":"4DA7596B5AFD51","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583441,"discussion_content":"你知道你在说啥吗 不对马嘴","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660119970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":390944,"ip_address":"四川"},"score":583441,"extra":""}]},{"author":{"id":2094925,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f7/4d/09554c96.jpg","nickname":"iron bo","note":"","ucode":"4BFB1331637AA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371730,"discussion_content":"我也觉得第一次删除没有必要，考虑到高并发的场景，第一次删除缓存后，若此时db写入没成功，有请求进来，仍然会导致脏缓存在redis中。第二次删除是有必要的，保证了一致性","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1619942994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445369,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0d/f9/af581a47.jpg","nickname":"k","note":"","ucode":"6F28CFC722C3C9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575002,"discussion_content":"从评论里得出延时双删的意义，首次删除可以保证数据尽可能的一致，二次删除只是为了防止并发下的数据不一致，两次删除都是竭尽所能保证更少的数据不一致时间，因为目前还没有完全保证一致的只读缓存解决方案。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654518272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3067096,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/cc/d8/6cdd4b15.jpg","nickname":"一如往常i","note":"","ucode":"C9A5AEA38B3E97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585669,"discussion_content":"你先删缓存，并发情况下，就有可能被读到脏数据,不管怎么样，都保证是最终的数据一致性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661758214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562756,"discussion_content":"第一次删除是多余的。因为整个过程是无法保证原子性的，所以还不如不删。确实存在数据不一致的情况。所以这里就需要根据业务场景做选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649880603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2563368,"avatar":"https://static001.geekbang.org/account/avatar/00/27/1d/28/b4ea7ed7.jpg","nickname":"往事随风","note":"","ucode":"509EE132D433D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374484,"discussion_content":"延迟双删，没有公司在生产环境下使用吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621212870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2147220,"avatar":"https://static001.geekbang.org/account/avatar/00/20/c3/94/e89ebc50.jpg","nickname":"神毓逍遥","note":"","ucode":"83351CB18B190E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339723,"discussion_content":"为什么要双删，大量相同key访问时 都查数据库  不好吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609764727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":9,"child_discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2147220,"avatar":"https://static001.geekbang.org/account/avatar/00/20/c3/94/e89ebc50.jpg","nickname":"神毓逍遥","note":"","ucode":"83351CB18B190E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":348265,"discussion_content":"高并发场景上，会存在删除后，还没有更新数据库，就已经把数据又读到缓存了，一般采用 延迟双删，尽可能的保证数据一致性","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1612494944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339723,"ip_address":""},"score":348265,"extra":""},{"author":{"id":1041278,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e3/7e/a546d86d.jpg","nickname":"追风也曾少年","note":"","ucode":"248D267558E55E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362374,"discussion_content":"如果是先改db, 再删redis呢? 这里并不需要第一步先删redis吧?","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616933248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":348265,"ip_address":""},"score":362374,"extra":""},{"author":{"id":1307457,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/41/30fff133.jpg","nickname":"Feanmy","note":"","ucode":"844C7A72338F11","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1041278,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e3/7e/a546d86d.jpg","nickname":"追风也曾少年","note":"","ucode":"248D267558E55E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365310,"discussion_content":"如果先改db，那么在修改的过程中可能会有更多的请求读到redis的旧值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617768019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":362374,"ip_address":""},"score":365310,"extra":""}]}]},{"had_liked":false,"id":295869,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1622625180,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48867265436","product_id":100056701,"comment_content":"这里有两点问题 老师没有说清楚：<br>1. 缓存更新模式 常见的就是cache aside 就是老师介绍的只读缓存<br>2. 读写缓存 有点类似write through 但从老师的叙述中只是特征部分吻合 所以这里要明确指出<br> 因为这并不是主流的四种更新缓存套路，分别是：cahce aside , write through, read through, write behind.<br><br>读写一般是和只读缓存共用的 用于分担热点压力 比如说eureka","like_count":12,"discussions":[{"author":{"id":1877862,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu3MgZBAyyiavX2CMF2KRib791j3bBGiaQDzuQwBF2k6AKHANV2uTAAss2vVaeC7xcSYYD8vjmibRpTQ/132","nickname":"纵不朽","note":"","ucode":"DB2CA2C46B2EF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590584,"discussion_content":"我怎么感觉老师说的只读缓存和读写缓存都是属于旁路缓存套路下的细分呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665905169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252880,"user_name":"snailshen","can_delete":false,"product_type":"c1","uid":1436839,"ip_address":"","ucode":"C4875C476649B1","user_header":"https://static001.geekbang.org/account/avatar/00/15/ec/a7/7d44c655.jpg","comment_is_top":false,"comment_ctime":1602505999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40257211663","product_id":100056701,"comment_content":"区别在于：只读缓存，是以数据库的数据为基准同步缓存的方案，读写缓存是同时修改数据库和缓存中的数据，这两种方案都存在数据一致性的问题。比如只读缓存在写回数据库删除缓存时这个时间段的读请求交易，读写缓存缓存的并发访问问题。<br>数据一致性问题：1.最终一致性方案，优先修改缓存数据，通过队列解耦修改请求到数据库，后台单独处理队列数据保证数据库数据最终一致性。<br>2.通过分布式事务，把缓存操作和数据库操作通过一个事务完成。这种情况数据能够强一致性<br>这两种情况都没办法保证，数据脏读的情况，只能保缓存和数据库的数据一致性，如何在保证缓存和数据的数据一致性的情况下，避免脏读的问题，还请大家讨论！","like_count":9},{"had_liked":false,"id":255424,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1603341257,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"23078177737","product_id":100056701,"comment_content":"分享一个自己在使用缓存的时候遇到的坑：<br>1、Redis 的缓存数据来自数据库<br>2、在业务系统上快速对数据进行处理，Redis 是一个热点更新对象<br>生产环境会遇到这样一个问题：缓存数据从数据库拉取上来的时候，会和任务数据更新Redis冲突，这时候需要分布式锁救场。","like_count":5,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339773,"discussion_content":"一般用删除","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609772839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2313353,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4c/89/82a3ee04.jpg","nickname":"going","note":"","ucode":"3AA83F9B07BE8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342840,"discussion_content":"这里的redis是热点数据的话不太能用删除策略吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610846077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339773,"ip_address":""},"score":342840,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2313353,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4c/89/82a3ee04.jpg","nickname":"going","note":"","ucode":"3AA83F9B07BE8B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345385,"discussion_content":"工程实践一般用先删后懒加载。write ahead与write through两种策略，这方面文章很多你可以搜索看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611715550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342840,"ip_address":""},"score":345385,"extra":""},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584949,"discussion_content":"write ahead 是啥，能给个文章么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661244728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345385,"ip_address":"湖南"},"score":584949,"extra":""}]}]},{"had_liked":false,"id":290348,"user_name":"刘百万","can_delete":false,"product_type":"c1","uid":1234273,"ip_address":"","ucode":"692E23D070641A","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/61/8ad99e09.jpg","comment_is_top":false,"comment_ctime":1619511702,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"18799380886","product_id":100056701,"comment_content":"我觉得解决所有问题的办法就是给机房配双电源","like_count":4,"discussions":[{"author":{"id":1108924,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/bc/6ccac4bb.jpg","nickname":"武文文武","note":"","ucode":"5288366646A15B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378916,"discussion_content":"双电源都坏了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623508748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1227107,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b9/63/a3b11794.jpg","nickname":"麦抠","note":"","ucode":"875DEA26F38BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1108924,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/bc/6ccac4bb.jpg","nickname":"武文文武","note":"","ucode":"5288366646A15B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381663,"discussion_content":"坏了就坏了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625154355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378916,"ip_address":""},"score":381663,"extra":""},{"author":{"id":3067096,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/cc/d8/6cdd4b15.jpg","nickname":"一如往常i","note":"","ucode":"C9A5AEA38B3E97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1108924,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/bc/6ccac4bb.jpg","nickname":"武文文武","note":"","ucode":"5288366646A15B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585672,"discussion_content":"配个三电源吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661758412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378916,"ip_address":"湖南"},"score":585672,"extra":""},{"author":{"id":1733294,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/72/ae/297bef7d.jpg","nickname":"番茄","note":"","ucode":"B570A62BEE85A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3067096,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/cc/d8/6cdd4b15.jpg","nickname":"一如往常i","note":"","ucode":"C9A5AEA38B3E97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591337,"discussion_content":"三个都坏呢？&gt;&gt;_&lt;&lt;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666516947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":585672,"ip_address":"广东"},"score":591337,"extra":""}]}]},{"had_liked":false,"id":255429,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1603341548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18783210732","product_id":100056701,"comment_content":"针对 Redis 和异步写回策略，等待 Redis 淘汰数据再写回数据库，那 Redis 处理缓存，一定程度上还承担着队列的任务，即向上接受业务的数据，向下把数据写到数据库。<br><br>这个情况下，考虑到 Redis 的掉电带来数据丢失的风险，我觉得可以把 Redis 任务方面的需求转移到专业的消息队列中去使用。<br><br>这样就需要这样处理：<br>1、Obj 写 Redis；<br>2、Obj 入队 Kafka；<br><br>由于 Kafka 可以做到数据不丢失，所以这样数据可以更加安全一点，还可以扩展吞吐量。缺点是：引入一个新的中间件，意味着更多更复杂的业务代码结构。","like_count":4},{"had_liked":false,"id":252215,"user_name":"","can_delete":false,"product_type":"c1","uid":2180805,"ip_address":"","ucode":"","user_header":"","comment_is_top":false,"comment_ctime":1602201078,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14487102966","product_id":100056701,"comment_content":"老师，我们平时经常将缓存一致性中的Cache Aside模式翻译为旁路缓存，具体为：写是更新数据库删除缓存，读是miss后读db+回写。<br>但是专栏里面 “旁路缓存就意味着需要在应用程序中新增缓存逻辑处理的代码”。旁路缓存可以理解为缓存中数据与db中数据的更新需要我们自己通过代码去实现，而不是由缓存自己实现的。<br>也就是 cache aside模式与专栏中的旁路缓存指的不是一个东西，这样理解对吗？","like_count":4,"discussions":[{"author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332503,"discussion_content":"一个东西","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607243278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002252,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4b/0c/dab49a2b.jpg","nickname":"光明","note":"","ucode":"0A5E7CFD91A3CF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311272,"discussion_content":"是一个东西。\n\n操作 DB、Redis 一般是都是由业务层管理的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602295682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584951,"discussion_content":"cache aside模式对应专栏中的旁路缓存的只读模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661245013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277627,"user_name":"小可","can_delete":false,"product_type":"c1","uid":1006735,"ip_address":"","ucode":"8834AF621FA67D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","comment_is_top":false,"comment_ctime":1612495875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10202430467","product_id":100056701,"comment_content":"只读缓存：<br>①写时写db，删redis key，写性能好；<br>②读时读到redis无此key需从db load，只影响修改后首次读性能；<br>③redis+db数据一致<br>④适合读多写少场景<br>直写策略的读写缓存：<br>①写时同时写redis+db，首先保证同时成功，db写慢会阻塞redis，整体写性能有影响；<br>②读数据直接读redis，读性能好；<br>③如果写db成功，写缓存失败，造成数据不一致，但数据可靠性好<br>④适合读多写少场景，感觉还不如用只读缓存，不知道对不对？","like_count":3},{"had_liked":false,"id":261762,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1796510,"ip_address":"","ucode":"C23E3390995D95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKo5jCPQW87sFySwXiaLxibak0qQYuFRTyy8RlNsO9JDyxBk1AYDrsphRskxzXPLPOW8ibWicWlRAnzwg/132","comment_is_top":false,"comment_ctime":1605515581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10195450173","product_id":100056701,"comment_content":"只读就是宏观上的mysql；读写就是微观的mysql操作，数据变更的终点在内存，数据落盘由日志操作","like_count":2},{"had_liked":false,"id":252698,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1602455955,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10192390547","product_id":100056701,"comment_content":"老师，您好，读写缓存无论是先写数据库还是缓存，都有可能出现其中一个失败的情况，造成数据不一致的情况，这个问题你有什么好的方案吗<br>","like_count":2,"discussions":[{"author":{"id":1584786,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2e/92/e1c38ca6.jpg","nickname":"KamTo  Hung","note":"","ucode":"00D5A6479DB784","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346935,"discussion_content":"重试，走队列","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612101761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377387,"discussion_content":"自己做一个状态机修复 或者使用cache asied 前提是下单类场景只以数据库为准 其他场景一致性可取舍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622625320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332500,"discussion_content":"事务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607243082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252285,"user_name":"窗外","can_delete":false,"product_type":"c1","uid":1311172,"ip_address":"","ucode":"1E8F2D9439E7F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/c4/21c2cde4.jpg","comment_is_top":false,"comment_ctime":1602223344,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10192157936","product_id":100056701,"comment_content":"老师好，同步直写时，怎么保障 redis mysql 的操作具有原子性呢?不具有原子性的话两者数据可能就不一致了","like_count":2,"discussions":[{"author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370117,"discussion_content":"无法保证，只能保证最终一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619281738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308422,"user_name":"一缕阳光","can_delete":false,"product_type":"c1","uid":1391255,"ip_address":"","ucode":"19C6BCE47681EE","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/97/c4493e91.jpg","comment_is_top":false,"comment_ctime":1629616695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5924583991","product_id":100056701,"comment_content":"一般业务场景下，先写 DB ，后删缓存 + 删除重试已经可以满足大部分一致性要求了。<br>如果还要说的话，那就是延迟双删，但是具有一定复杂度，至少我们是没有在产线应用的。<br><br>或者是，对于某些场景，也可以在单用户维度做一个简单的分布式锁来限制一下并发，这样也可以降低出现不一致的概率。 <br><br>另外，就是和数据库事务一起的一些思考🤔：由于快照读的存在，事务内不对缓存做写操作，也可以根据业务场景来看事务结束后是否需要额外做一次删除缓存。<br>","like_count":1},{"had_liked":false,"id":300299,"user_name":"喰","can_delete":false,"product_type":"c1","uid":2659564,"ip_address":"","ucode":"6133C265D4D63D","user_header":"https://static001.geekbang.org/account/avatar/00/28/94/ec/8db3f04a.jpg","comment_is_top":false,"comment_ctime":1625101995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920069291","product_id":100056701,"comment_content":"个人觉得只读缓存和读写缓存都会存在一致性问题，只读缓存的优点是强调数据可靠性，而读写缓存的优点是强调响应时间。  一致性问题都会存在。","like_count":1},{"had_liked":false,"id":288321,"user_name":"藏锋","can_delete":false,"product_type":"c1","uid":1175246,"ip_address":"","ucode":"D5F811B16725A0","user_header":"https://static001.geekbang.org/account/avatar/00/11/ee/ce/c024a857.jpg","comment_is_top":false,"comment_ctime":1618407385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5913374681","product_id":100056701,"comment_content":"只读缓存，实际上就是由数据库来驱动缓存的更新，从理论上讲，缓存的数据始终和数据库保持一致，不过如果修改数据库成功，删除缓存失败，那么缓存中的数据在缓存未过期之前就是脏数据；","like_count":1},{"had_liked":false,"id":253157,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1602638693,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5897605989","product_id":100056701,"comment_content":"对于只读缓存这个名字来说，感觉很奇怪，今天学完25讲记笔记的时候，回过头来又看了今天的内容，又想了想这个问题，有了下面的想法，不知道正确不正确？<br><br>这里的只读不是说缓存中的数据不会改变，而是说对于只读缓存来讲，没有更新操作，只有读取和删除操作。在数据更新时，只会写数据库，然后对于缓存来讲，更新操作分解为删除和插入操作，即<br><br>只读缓存的更新 = 删除 + 插入。<br>","like_count":1,"discussions":[{"author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315970,"discussion_content":"只读缓存的意思，写入数据时，不刻意更新缓存以保存最新数据，而是置其失效，在重新查询的时候再写入。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603341069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318156,"discussion_content":"嗯，你说的更准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603669879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":315970,"ip_address":""},"score":318156,"extra":""}]}]},{"had_liked":false,"id":252399,"user_name":"东","can_delete":false,"product_type":"c1","uid":1043947,"ip_address":"","ucode":"0FF5018422CEA9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/eb/88cac7a5.jpg","comment_is_top":false,"comment_ctime":1602290739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897258035","product_id":100056701,"comment_content":"关于cache的写策略，就是write through和write back，维基百科上有完整的介绍。<br>https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Cache_(computing)#&#47;media&#47;File:Write-through_with_no-write-allocation.svg<br>https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Cache_(computing)#&#47;media&#47;File:Write-back_with_write-allocation.svg<br>","like_count":1},{"had_liked":false,"id":252339,"user_name":"Geek_a8489f","can_delete":false,"product_type":"c1","uid":1180154,"ip_address":"","ucode":"AAEF0FF18F736F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5Wh2AdV0pAEOFU7uFJxqjpViaeZayicRBg6fNFShmszP2nqQLJh22HytnBHYXG9gAnYXJmzeF11kA/132","comment_is_top":false,"comment_ctime":1602244340,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5897211636","product_id":100056701,"comment_content":"读写模式+同步直写策略，感觉意义不大吧？写操作仍然需要更新DB，无法实现写操作的加速。","like_count":1,"discussions":[{"author":{"id":1116608,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/c0/3119a4f6.jpg","nickname":"黄栋","note":"","ucode":"6BB8EC43EB87A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311390,"discussion_content":"相对于只读模式 少了一次db查询;","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602323123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180154,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5Wh2AdV0pAEOFU7uFJxqjpViaeZayicRBg6fNFShmszP2nqQLJh22HytnBHYXG9gAnYXJmzeF11kA/132","nickname":"Geek_a8489f","note":"","ucode":"AAEF0FF18F736F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311412,"discussion_content":"但这种双写模式如果不设法保证原子性，很容易引起一致性问题。而保持原子性的代价又很大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602331173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116608,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/c0/3119a4f6.jpg","nickname":"黄栋","note":"","ucode":"6BB8EC43EB87A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311389,"discussion_content":"感觉优点就是下次读数据,不用再用db里面拿数据了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602322876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341856,"user_name":"阿昕","can_delete":false,"product_type":"c1","uid":1012906,"ip_address":"","ucode":"F3AD093B68E074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","comment_is_top":false,"comment_ctime":1649862211,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649862211","product_id":100056701,"comment_content":"区别在于，直写策略的读写缓存是同步进行的，会阻塞处理过程","like_count":0},{"had_liked":false,"id":340447,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":2649276,"ip_address":"","ucode":"CEBAD9CDCFC2A3","user_header":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","comment_is_top":false,"comment_ctime":1648817311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648817311","product_id":100056701,"comment_content":"1. 只读缓存，用的比较多，保证数据库和缓存一致性使用延迟双删策略；<br> 2. 读写缓存，缓存后数据库的修改是分开的，保证最终一致性较难，如果业务中对最终一致性要求不高建议使用；","like_count":0},{"had_liked":false,"id":339923,"user_name":"张潇赟","can_delete":false,"product_type":"c1","uid":1132192,"ip_address":"","ucode":"1A45B57F9E0723","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/a0/aa6d4ecd.jpg","comment_is_top":false,"comment_ctime":1648463271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648463271","product_id":100056701,"comment_content":"只读缓存和读写缓存，这两种从一致性的角度考虑应该是只读缓存更可靠一点。从性能的角度考虑感觉没啥区别，不管是同步写还是异步写都可以用代码的形式搞定。<br>在生产环境中除了考虑一致性和性能两个因素外还需要考虑一个就是维护成本，感觉如果采用读写缓存的方案会给redis集群带来更高的复杂度，也会对后期的扩展带来不变。","like_count":0},{"had_liked":false,"id":331417,"user_name":"1634LM","can_delete":false,"product_type":"c1","uid":1483821,"ip_address":"","ucode":"0F5FA57B69788C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0G3cibDykvgIkomb5QrjBGuiaf5rJG2317JN1sePZ589IjUcMTOF4ZMrKVYU4ywfq1qfREqCW9Zww/132","comment_is_top":false,"comment_ctime":1642580495,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642580495","product_id":100056701,"comment_content":"老师 您好 ，我是小白 对于只读缓存  我有点疑惑：“当应用再次读取这些数据时，会发生缓存缺失，应用会把这些数据从数据库中读出来，并写到缓存中” 并把数据写到缓存中，缓存不是只读的吗  怎么可以把数据写到缓存中呢 ？ 我理解的只读 是 只能读不能更新，删除 和插入啊？ ","like_count":0},{"had_liked":false,"id":328026,"user_name":"‭‭","can_delete":false,"product_type":"c1","uid":1326444,"ip_address":"","ucode":"186811937EE646","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/6c/935bdc7d.jpg","comment_is_top":false,"comment_ctime":1640487306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640487306","product_id":100056701,"comment_content":"读写缓存路径更短一些，少了从数据库加载，会出现并发问题。原子性问题都有","like_count":0},{"had_liked":false,"id":327786,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":2571291,"ip_address":"","ucode":"2B4D0BAAEB5AD4","user_header":"https://static001.geekbang.org/account/avatar/00/27/3c/1b/07c453a7.jpg","comment_is_top":false,"comment_ctime":1640307490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640307490","product_id":100056701,"comment_content":"请问老师，读写缓存为什么会影响redis的性能？感觉也只是响应请求会慢一些啊","like_count":0},{"had_liked":false,"id":327499,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1640151844,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1640151844","product_id":100056701,"comment_content":"这节课老师讲的比较简单，继续下一节～","like_count":0},{"had_liked":false,"id":307555,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1629160021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629160021","product_id":100056701,"comment_content":"只读缓存就好比mysql的缓存层，而MySQL缓存层已经被MySQL抛弃了。","like_count":0},{"had_liked":false,"id":302414,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1626215231,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626215231","product_id":100056701,"comment_content":"还是从场景上去看：<br>只读缓存用于读性能提高的场景，比如常量数据。<br>读写缓存则是用于提升读写性能。<br>读缓存的数据库更新由应用去做，另外一个业务模块去做，同时删除读缓存。<br>读写缓存更新数据库则是直接由当前写操作直接做掉了，同时进行数据库操作及缓存删除。<br>读写缓存实际上是用于存储了，这个在不是同步刷盘的情况可能会丢失数据。","like_count":0},{"had_liked":false,"id":296908,"user_name":"king🐳","can_delete":false,"product_type":"c1","uid":2557346,"ip_address":"","ucode":"88DA7981062AB5","user_header":"https://static001.geekbang.org/account/avatar/00/27/05/a2/24d5e88e.jpg","comment_is_top":false,"comment_ctime":1623220706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623220706","product_id":100056701,"comment_content":"只读缓存观点：<br>1：:高并发场景下<br>2：T1 更新数据库 更新缓存<br>3：T2 更新数据库 更新缓存 T1由于某些原因比T2晚更新缓存<br>4：最终缓存保存T1数据 出现脏数据","like_count":0},{"had_liked":false,"id":295662,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1622537095,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1622537095","product_id":100056701,"comment_content":"有两个点可以提下：<br>1.在 Spring Boot 中可以引入 Spring Cache 组件，添加合适的注解，就不用写操作缓存的代码了。<br>2.商品库存用读写缓存模式的场景，需要考虑分布式系统下，加分布式锁来解决资源竞争的问题。","like_count":0,"discussions":[{"author":{"id":2762186,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/25/ca/96734ade.jpg","nickname":"随机漫步的傻瓜","note":"","ucode":"FBEFB27BF45ED4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400957,"discussion_content":"虽然注解会方便很多，但仍然没有改变需要修改代码的本质","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633501559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292057,"user_name":"good boby","can_delete":false,"product_type":"c1","uid":2387358,"ip_address":"","ucode":"1471E2E499412C","user_header":"https://static001.geekbang.org/account/avatar/00/24/6d/9e/6a82a5ea.jpg","comment_is_top":false,"comment_ctime":1620658332,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1620658332","product_id":100056701,"comment_content":"只读缓存，数据库更新完成后则删除redis的数据。是否更新完成数据库数据后则更新缓存数据？则在下次查询时，则少了一次访问数据库的操作？","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374795,"discussion_content":"更新完后的第一次查询时，需要查询数据库，写入缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621349671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292055,"user_name":"good boby","can_delete":false,"product_type":"c1","uid":2387358,"ip_address":"","ucode":"1471E2E499412C","user_header":"https://static001.geekbang.org/account/avatar/00/24/6d/9e/6a82a5ea.jpg","comment_is_top":false,"comment_ctime":1620657979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620657979","product_id":100056701,"comment_content":"蒋老师，您好！读写同步缓存的处理方式是否有问题？<br>为了保证数据一致性，写操作是否先写数据库再写redis？一旦数据库写过程出现异常，则redis写入会终止，则最终保证数据库与redis数据一致性。","like_count":0},{"had_liked":false,"id":291842,"user_name":"何磊","can_delete":false,"product_type":"c1","uid":1047604,"ip_address":"","ucode":"78934C3ED4A342","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/34/c733b116.jpg","comment_is_top":false,"comment_ctime":1620548179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620548179","product_id":100056701,"comment_content":"同步读写redis对于在线业务，并发高的时候数据一致性很难保证。而且两个不同的存储涉及到分布式事务问题，一致性、可靠性很难处理！","like_count":0},{"had_liked":false,"id":288984,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1618809232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618809232","product_id":100056701,"comment_content":"这里的缓存策略中，后端数据库是指redis自带的存储文件？也就是持久化文件是吧？","like_count":0},{"had_liked":false,"id":288574,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1618542578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618542578","product_id":100056701,"comment_content":"1.为啥需要缓存？<br>一个系统中的不同层之间的访问速度不一样，所以我们才需要缓存，这样就可以把一些需要频繁访问的数据放在缓存中，以加快它们的访问速度。<br>CPU：  20~40ns，1~32MB，快速<br>内存： 100ns，32~96GB，中速<br>磁盘： 3~5ms，1~4TB，慢速<br><br>2.计算机系统中，默认的缓存有哪些？<br>1）CPU中的末级缓存：也就是LLC，用来缓存内存中的数据，避免每次从内存中存取数据。<br>2）内存中的高速页缓存：也就是page cache，用来缓存磁盘中的数据，避免每次从磁盘中存取数据。<br><br>总结下：我们在构建计算机硬件系统时，已经把 LLC 和 page cache 放在了应用程序的数据访问路径上，应用程序访问数据时直接就能用上缓存。<br><br>3.缓存的特征？<br>1）在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。对应到互联网应用来说，Redis 就是快速子系统，而数据库就是慢速子系统了。<br>2）缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。缓存的容量终究是有限的，缓存中的数据量也是有限的，肯定是没法时刻都满足访问需求的。所以，缓存和后端慢速系统之间，必然存在数据写回和再读取的交互过程。简单来说，缓存中的数据需要按一定规则淘汰出去，写回后端系统，而新的数据又要从后端系统中读取进来，写入缓存。Redis本身是支持按一定规则淘汰数据的，相当于实现了缓存的数据淘汰，其实，这也是 Redis 适合用作缓存的一个重要原因。<br><br>4.Redis 缓存处理请求的两种情况<br>1）缓存命中：Redis 中有相应数据，就直接读取 Redis，性能非常快。<br>2）缓存缺失：Redis中没有保存相应数据，就从后端数据库中读取数据，性能就会变慢。而且，一旦发生缓存缺失，为了让后续请求能从缓存中读取到数据，我们需要把缺失的数据写入 Redis，这个过程叫作缓存更新。缓存更新操作会涉及到保证缓存和数据库之间的数据一致性问题。<br><br>总结下：应用读取数据时，需要先读取 Redis；发生缓存缺失时，需要从数据库读取数据，还需要更新缓存。<br><br>5.缓存的类型有哪些？<br>按照 Redis 缓存是否接受写请求，我们可以把它分成只读缓存和读写缓存。<br>1）只读缓存：当 Redis 用作只读缓存时，应用要读取数据的话，会先调用 Redis GET 接口，查询数据是否存在。而所有的数据写请求，会直接发往后端的数据库，在数据库中增删改。对于删改的数据来说，如果 Redis 已经缓存了相应的数据，应用需要把这些缓存的数据删除，Redis 中就没有这些数据了。当应用再次读取这些数据时，会发生缓存缺失，应用会把这些数据从数据库中读出来，并写到缓存中。这样一来，这些数据后续再被读取时，就可以直接从缓存中获取了，能起到加速访问的效果。假设业务应用要修改数据 A，此时，数据 A 在 Redis 中也缓存了，那么，应用会先直接在数据库里修改 A，并把 Redis 中的 A 删除。等到应用需要读取数据 A 时，会发生缓存缺失，此时，应用从数据库中读取 A，并写入 Redis，以便后续请求从缓存中直接读取。<br>2）读写缓存，同步直写，异步写回。","like_count":0},{"had_liked":false,"id":288322,"user_name":"藏锋","can_delete":false,"product_type":"c1","uid":1175246,"ip_address":"","ucode":"D5F811B16725A0","user_header":"https://static001.geekbang.org/account/avatar/00/11/ee/ce/c024a857.jpg","comment_is_top":false,"comment_ctime":1618407774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618407774","product_id":100056701,"comment_content":"对于读写缓存说实在的，不太适合互联网项目，不需要多高的并发就可能导致数据不一致，比如由于网络原因用户第一次请求转了10秒，因为不想继续干等，在这10秒后该用户频繁点击请求了多次，或者在这10秒内，其他用户也对同一个资源发起了请求，那么也是有很大概率造成数据不一致的，这在我实际开发中就遇到过多次，","like_count":0},{"had_liked":false,"id":285642,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1616935837,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1616935837","product_id":100056701,"comment_content":"缓存一般是又快又小。<br><br>Redis 不适合无法获得源码的应用。<br><br>如果可以选的话，我可能会更多的考虑只读缓存模式，毕竟 Redis 主要是为了提高读的性能。<br><br>如果是需要高速读写的场景，比如商品大促、抢红包之类需要修改数据的，那么可以考虑采用读写缓存模式；如果读多写少，比如短视频、图片应用，那么就可以使用只读缓存。<br><br>对于课后题，只读缓存同步写数据库的时候，先写数据库，然后将缓存中的数据失效，如需读取，发生缓存失效，然后再从数据库中读取。<br><br>读写缓存的直写策略是同步把数据写入 Redis 和后台的数据库，都写完之后才返回。<br><br>相对来说两者的写入速度差不多（都是直接写数据库），但是读写缓存的直写策略对于频繁读的应用更友好一点（没有缓存失效的问题）。<br><br>看了课代表 @Kaito的答案，发现自己忽略了读写缓存直写策略有可能造成的缓存和数据库不一致问题，包括高并发和数据库写错误。<br><br>如果考虑更为通用的缓存 write through 和 write back，那么 Redis 似乎就只是一个工程实现的问题，需要根据业务 trade off","like_count":0},{"had_liked":false,"id":282369,"user_name":"蓝萧","can_delete":false,"product_type":"c1","uid":1227606,"ip_address":"","ucode":"DE125B56BF7818","user_header":"https://static001.geekbang.org/account/avatar/00/12/bb/56/a506a165.jpg","comment_is_top":false,"comment_ctime":1615207775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615207775","product_id":100056701,"comment_content":"如何检测redis的key即将淘汰？","like_count":0},{"had_liked":false,"id":281215,"user_name":"灰色","can_delete":false,"product_type":"c1","uid":1178135,"ip_address":"","ucode":"869B400BBD520D","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/17/d0b8135f.jpg","comment_is_top":false,"comment_ctime":1614648320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614648320","product_id":100056701,"comment_content":"只读缓存的方式比较看重一致性，读写缓存直写的方式更看重高性能，但是对于一些特殊情况，只读的方式也会存在不一致的情况：在并发的场景下，A线程修改数据，B线程查询数据，A在完成数据库修改前，缓存刚好失效，B又来查询数据，此时B查到旧数据，在B要回写缓存前，A又将最新的数据写到了缓存，此后，B又将旧数据写到缓存，此时缓存和数据库数据不一致。","like_count":0},{"had_liked":false,"id":277038,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1612242768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612242768","product_id":100056701,"comment_content":"缓存是平衡性能，成本，数据可靠性之间的矛盾。缓存容量小，速度快，易丢失，数据库速度慢，但是容量大，数据可靠。<br><br>缓存读写有三种模式：cache aside,read&#47;write through,write back。使用redis做缓存的系统一般使用cache aside模式。就像文中说的，redis是个单独的系统，让它负责与后端数据的一致性不太合理（后两种模式中数据的一致性问题由缓存系统做保障），所以这个任务也就落在了应用程序的身上。<br><br>缓存分为只读缓存和读写缓存。后者严格来讲是不是应该叫缓冲？","like_count":0},{"had_liked":false,"id":271046,"user_name":"Geek_3d87cb","can_delete":false,"product_type":"c1","uid":2253496,"ip_address":"","ucode":"F09334D60C3BC8","user_header":"","comment_is_top":false,"comment_ctime":1609381504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609381504","product_id":100056701,"comment_content":"只读缓存删除缓存.然后访问的时候再从数据库读取放到缓存;读写缓存直接修改缓存,同步或者异步写回数据库,如果访问这个key频率不大,采用只读缓存会更好,因为只有在需要的时候才会放到缓存,节省了内存","like_count":0},{"had_liked":false,"id":268470,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1211713,"ip_address":"","ucode":"E3AD8BF42E19DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/41/3c5b770b.jpg","comment_is_top":false,"comment_ctime":1608209094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608209094","product_id":100056701,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":266214,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1607243053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607243053","product_id":100056701,"comment_content":"如果使用读写缓存加速写的话 只能选择异步写回数据库吧","like_count":0},{"had_liked":false,"id":263113,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1606010334,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606010334","product_id":100056701,"comment_content":"两种缓存的区别：<br>1. 只读缓存：Redis主要提供数据读场景。数据发生修改，先由应用写至数据库，再从Redis中删除数据。由下次访问重新写至Redis。<br>2. 直写策略的读写缓存：数据发生修改时，缓存和后端数据库同时被修改","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339775,"discussion_content":"使用时区别就是相当于缓存组件代理了数据库操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609772953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260654,"user_name":"数学汤家凤","can_delete":false,"product_type":"c1","uid":2029485,"ip_address":"","ucode":"DE84E777C384AD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","comment_is_top":false,"comment_ctime":1605079050,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605079050","product_id":100056701,"comment_content":"写直达法和写回法","like_count":0},{"had_liked":false,"id":255542,"user_name":"dfuru","can_delete":false,"product_type":"c1","uid":2110772,"ip_address":"","ucode":"0222FADA093D95","user_header":"","comment_is_top":false,"comment_ctime":1603368656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603368656","product_id":100056701,"comment_content":"1.只读缓存，写数据到数据库成功后，返回客户端成功，未更新缓存。下次读请求访问缓存，缓存缺失再从数据库读，才更新缓存。后面读请求在缓存中才能命中。<br>2.读写缓存，同步直写，写缓存和数据库都成功后，返回客户端成功，缓存已经更新。下次读请求访问缓存直接命中返回。与只读缓存相比，减少一次从数据库读操作，可提升读性能。","like_count":0},{"had_liked":false,"id":255417,"user_name":"金时","can_delete":false,"product_type":"c1","uid":1120428,"ip_address":"","ucode":"3491B2367A7238","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/ac/4d68ba46.jpg","comment_is_top":false,"comment_ctime":1603339474,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603339474","product_id":100056701,"comment_content":"读请求比较多： 用只读缓存就可以了。<br>写请求比较多： 用只读缓存（只读缓存和读写缓存的直写方式 写性能差不多）或者读写缓存的异步写回策略，二者选其一。但是若使用读写缓存的异步写，有可能丢失数据风险，需要保证缓存的可靠性。<br>个人感觉 读写缓存的直写方式 增加了复杂性，造成数据不一致时不利于排查问题，收益并不明显，很鸡肋呢。有人见过必须要用读写缓存直写方式 的场景吗？","like_count":0,"discussions":[{"author":{"id":1768852,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/94/8704d2b0.jpg","nickname":"spoofer","note":"","ucode":"6723F64ACC3F27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323672,"discussion_content":"同步直写这个思路很正常，一般没经验的人会用，很难保证原子性，出问题了还要各种回滚，非常复杂。这些其实是 cache aside pattern 的范畴了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604980217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253143,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1602634344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602634344","product_id":100056701,"comment_content":"Redis只读缓存所依赖的最新数据在mysql，对于更新和修改，直接删除redis，我们需要保证这里的数据一致性即删除要成功，否则会出现数据不一致。Redis直写是更新redis和mysql，两者都保存最新的值，redis作为主库，mysql类似于备库。保证redis数据正确，与mysql一致性可以对账去保持最终一致性？","like_count":0},{"had_liked":false,"id":253102,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1602598718,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602598718","product_id":100056701,"comment_content":"两种方式都是需要等待比较慢的后端数据库。区别在对于接下来的刚操作过的 key 的查询请求， ‘读写缓存-同步写’策略可以不用再从数据库中读取一次。<br><br>有一个疑惑：只读缓存在处理写操作后，删除了 Redis 中相关的 key，这个时候为什么不把刚在后端数据库操作的值放到 Redis 中呢？","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339777,"discussion_content":"更新操作在并发时会有一致性问题，删除重新读数据库则不会因为数据库mvcc机制保证读取数据的正确性了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609773359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252936,"user_name":"xueyuan","can_delete":false,"product_type":"c1","uid":1128121,"ip_address":"","ucode":"3DE20A723EBAFE","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/b9/3b28f67c.jpg","comment_is_top":false,"comment_ctime":1602519149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602519149","product_id":100056701,"comment_content":"我提到了 Redis 只读缓存和使用直写策略的读写缓存，这两种缓存都会把数据同步写到后端数据库中<br>只读缓存是数据变动后在Redis缓存中执行删除;重新更新redis的触发时机是下次读缓存的未命中后触发的。<br><br>直接策略触发时机是数据变动在redis缓存和后端数据库一起更新。","like_count":0},{"had_liked":false,"id":252653,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1602422443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602422443","product_id":100056701,"comment_content":"只读缓存和使用直写策略的读写缓存的区别是，只读缓存是删除了redis中的数据，等到下一次读取的时候再从数据库中捞出来回写，而读写缓存是直接修改redis和数据库中的数据。","like_count":0},{"had_liked":false,"id":252407,"user_name":"风萧雨瑟","can_delete":false,"product_type":"c1","uid":1317323,"ip_address":"","ucode":"5E832ABE126393","user_header":"https://static001.geekbang.org/account/avatar/00/14/19/cb/70a2b47e.jpg","comment_is_top":false,"comment_ctime":1602292916,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1602292916","product_id":100056701,"comment_content":"老师，为什么要先删除呢？直接更新不好吗。先删除对于调用比较频繁，并且从数据库获取比较慢的key可能会造成多个请求请求某个key时，redis此时拿不到值，然后请求都会达到数据库，造成数据库压力大，比如count类需求。","like_count":0,"discussions":[{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311408,"discussion_content":"主要是为了保证并发编程中数据的一致性","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602330817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2159835,"avatar":"","nickname":"Geek_9a0c9f","note":"","ucode":"2A6078F740881F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311671,"discussion_content":"数据一致性和淘汰策略内存回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602459858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317323,"avatar":"https://static001.geekbang.org/account/avatar/00/14/19/cb/70a2b47e.jpg","nickname":"风萧雨瑟","note":"","ucode":"5E832ABE126393","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311488,"discussion_content":"谢谢解答，对于可以很短时间就可以从数据库中拿到的值，这个操作没问题，但对于MySQL innodb count类请求，数据量大，获取比较慢，方案上是不是可以改成单独一个线程去更新这个key，先去fromDB，成功后再删除key，再写入key，保证请求不被打到后端数据库。\n2.对于业务上需要count类的操作，由于从数据库层拿数据比较慢，在业务层有什么比较好的方案解决吗？避免对数据库做count类统计操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602372764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311411,"discussion_content":"读库然后再修改缓存要比直接删除缓存慢的多，在这个间隔有可能会读到旧数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602330950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252290,"user_name":"那个谁","can_delete":false,"product_type":"c1","uid":1118325,"ip_address":"","ucode":"43214CAE7062E7","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/75/ff76024c.jpg","comment_is_top":false,"comment_ctime":1602225064,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602225064","product_id":100056701,"comment_content":"有个疑问，对于没有源码的情况，是不是可以用第三方应用把数据同步到redis加速读操作呢","like_count":0,"discussions":[{"author":{"id":1254649,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/f9/b213a5fa.jpg","nickname":"歪文","note":"","ucode":"778231BA3D00D1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311238,"discussion_content":"没有什么问题是通过中间层解决不了的🌚🌚","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602286829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}