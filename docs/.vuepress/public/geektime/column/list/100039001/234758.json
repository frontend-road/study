{"id":234758,"title":"82 | 开源实战三（中）：剖析Google Guava中用到的几种设计模式","content":"<p>上一节课，我们通过Google Guava这样一个优秀的开源类库，讲解了如何在业务开发中，发现跟业务无关、可以复用的通用功能模块，并将它们从业务代码中抽离出来，设计开发成独立的类库、框架或功能组件。</p><p>今天，我们再来学习一下，Google Guava中用到的几种经典设计模式：Builder模式、Wrapper模式，以及之前没讲过的Immutable模式。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>Builder模式在Guava中的应用</h2><p>在项目开发中，我们经常用到缓存。它可以非常有效地提高访问速度。</p><p>常用的缓存系统有Redis、Memcache等。但是，如果要缓存的数据比较少，我们完全没必要在项目中独立部署一套缓存系统。毕竟系统都有一定出错的概率，项目中包含的系统越多，那组合起来，项目整体出错的概率就会升高，可用性就会降低。同时，多引入一个系统就要多维护一个系统，项目维护的成本就会变高。</p><p>取而代之，我们可以在系统内部构建一个内存缓存，跟系统集成在一起开发、部署。那如何构建内存缓存呢？我们可以基于JDK提供的类，比如HashMap，从零开始开发内存缓存。不过，从零开发一个内存缓存，涉及的工作就会比较多，比如缓存淘汰策略等。为了简化开发，我们就可以使用Google Guava提供的现成的缓存工具类com.google.common.cache.*。</p><!-- [[[read_end]]] --><p>使用Google Guava来构建内存缓存非常简单，我写了一个例子贴在了下面，你可以看下。</p><pre><code>public class CacheDemo {\n  public static void main(String[] args) {\n    Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()\n            .initialCapacity(100)\n            .maximumSize(1000)\n            .expireAfterWrite(10, TimeUnit.MINUTES)\n            .build();\n\n    cache.put(&quot;key1&quot;, &quot;value1&quot;);\n    String value = cache.getIfPresent(&quot;key1&quot;);\n    System.out.println(value);\n  }\n}\n</code></pre><p>从上面的代码中，我们可以发现，Cache对象是通过CacheBuilder这样一个Builder类来创建的。为什么要由Builder类来创建Cache对象呢？我想这个问题应该对你来说没难度了吧。</p><p>你可以先想一想，然后再来看我的回答。构建一个缓存，需要配置n多参数，比如过期时间、淘汰策略、最大缓存大小等等。相应地，Cache类就会包含n多成员变量。我们需要在构造函数中，设置这些成员变量的值，但又不是所有的值都必须设置，设置哪些值由用户来决定。为了满足这个需求，我们就需要定义多个包含不同参数列表的构造函数。</p><p>为了避免构造函数的参数列表过长、不同的构造函数过多，我们一般有两种解决方案。其中，一个解决方案是使用Builder模式；另一个方案是先通过无参构造函数创建对象，然后再通过setXXX()方法来逐一设置需要的设置的成员变量。</p><p>那我再问你一个问题，为什么Guava选择第一种而不是第二种解决方案呢？使用第二种解决方案是否也可以呢？答案是不行的。至于为什么，我们看下源码就清楚了。我把CacheBuilder类中的build()函数摘抄到了下面，你可以先看下。</p><pre><code>public &lt;K1 extends K, V1 extends V&gt; Cache&lt;K1, V1&gt; build() {\n  this.checkWeightWithWeigher();\n  this.checkNonLoadingCache();\n  return new LocalManualCache(this);\n}\n\nprivate void checkNonLoadingCache() {\n  Preconditions.checkState(this.refreshNanos == -1L, &quot;refreshAfterWrite requires a LoadingCache&quot;);\n}\n\nprivate void checkWeightWithWeigher() {\n  if (this.weigher == null) {\n    Preconditions.checkState(this.maximumWeight == -1L, &quot;maximumWeight requires weigher&quot;);\n  } else if (this.strictParsing) {\n    Preconditions.checkState(this.maximumWeight != -1L, &quot;weigher requires maximumWeight&quot;);\n  } else if (this.maximumWeight == -1L) {\n    logger.log(Level.WARNING, &quot;ignoring weigher specified without maximumWeight&quot;);\n  }\n\n}\n</code></pre><p>看了代码，你是否有了答案呢？实际上，答案我们在讲Builder模式的时候已经讲过了。现在，我们再结合CacheBuilder的源码重新说下。</p><p>必须使用Builder模式的主要原因是，在真正构造Cache对象的时候，我们必须做一些必要的参数校验，也就是build()函数中前两行代码要做的工作。如果采用无参默认构造函数加setXXX()方法的方案，这两个校验就无处安放了。而不经过校验，创建的Cache对象有可能是不合法、不可用的。</p><h2>Wrapper模式在Guava中的应用</h2><p>在Google Guava的collection包路径下，有一组以Forwarding开头命名的类。我截了这些类中的一部分贴到了下面，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/7d/ac5ce5f711711c0b86149f402e76177d.png?wh=259*420\" alt=\"\"></p><p>这组Forwarding类很多，但实现方式都很相似。我摘抄了其中的ForwardingCollection中的部分代码到这里，你可以下先看下代码，然后思考下这组Forwarding类是干什么用的。</p><pre><code>@GwtCompatible\npublic abstract class ForwardingCollection&lt;E&gt; extends ForwardingObject implements Collection&lt;E&gt; {\n  protected ForwardingCollection() {\n  }\n\n  protected abstract Collection&lt;E&gt; delegate();\n\n  public Iterator&lt;E&gt; iterator() {\n    return this.delegate().iterator();\n  }\n\n  public int size() {\n    return this.delegate().size();\n  }\n\n  @CanIgnoreReturnValue\n  public boolean removeAll(Collection&lt;?&gt; collection) {\n    return this.delegate().removeAll(collection);\n  }\n\n  public boolean isEmpty() {\n    return this.delegate().isEmpty();\n  }\n\n  public boolean contains(Object object) {\n    return this.delegate().contains(object);\n  }\n\n  @CanIgnoreReturnValue\n  public boolean add(E element) {\n    return this.delegate().add(element);\n  }\n\n  @CanIgnoreReturnValue\n  public boolean remove(Object object) {\n    return this.delegate().remove(object);\n  }\n\n  public boolean containsAll(Collection&lt;?&gt; collection) {\n    return this.delegate().containsAll(collection);\n  }\n\n  @CanIgnoreReturnValue\n  public boolean addAll(Collection&lt;? extends E&gt; collection) {\n    return this.delegate().addAll(collection);\n  }\n\n  @CanIgnoreReturnValue\n  public boolean retainAll(Collection&lt;?&gt; collection) {\n    return this.delegate().retainAll(collection);\n  }\n\n  public void clear() {\n    this.delegate().clear();\n  }\n\n  public Object[] toArray() {\n    return this.delegate().toArray();\n  }\n  \n  //...省略部分代码...\n}\n</code></pre><p>光看ForwardingCollection的代码实现，你可能想不到它的作用。我再给点提示，举一个它的用法示例，如下所示：</p><pre><code>public class AddLoggingCollection&lt;E&gt; extends ForwardingCollection&lt;E&gt; {\n  private static final Logger logger = LoggerFactory.getLogger(AddLoggingCollection.class);\n  private Collection&lt;E&gt; originalCollection;\n\n  public AddLoggingCollection(Collection&lt;E&gt; originalCollection) {\n    this.originalCollection = originalCollection;\n  }\n\n  @Override\n  protected Collection delegate() {\n    return this.originalCollection;\n  }\n\n  @Override\n  public boolean add(E element) {\n    logger.info(&quot;Add element: &quot; + element);\n    return this.delegate().add(element);\n  }\n\n  @Override\n  public boolean addAll(Collection&lt;? extends E&gt; collection) {\n    logger.info(&quot;Size of elements to add: &quot; + collection.size());\n    return this.delegate().addAll(collection);\n  }\n\n}\n</code></pre><p>结合源码和示例，我想你应该知道这组Forwarding类的作用了吧？</p><p>在上面的代码中，AddLoggingCollection是基于代理模式实现的一个代理类，它在原始Collection类的基础之上，针对“add”相关的操作，添加了记录日志的功能。</p><p>我们前面讲到，代理模式、装饰器、适配器模式可以统称为Wrapper模式，通过Wrapper类二次封装原始类。它们的代码实现也很相似，都可以通过组合的方式，将Wrapper类的函数实现委托给原始类的函数来实现。</p><pre><code>public interface Interf {\n  void f1();\n  void f2();\n}\npublic class OriginalClass implements Interf {\n  @Override\n  public void f1() { //... }\n  @Override\n  public void f2() { //... }\n}\n\npublic class WrapperClass implements Interf {\n  private OriginalClass oc;\n  public WrapperClass(OriginalClass oc) {\n    this.oc = oc;\n  }\n  @Override\n  public void f1() {\n    //...附加功能...\n    this.oc.f1();\n    //...附加功能...\n  }\n  @Override\n  public void f2() {\n    this.oc.f2();\n  }\n}\n</code></pre><p>实际上，这个ForwardingCollection类是一个“默认Wrapper类”或者叫“缺省Wrapper类”。这类似于在装饰器模式那一节课中，讲到的FilterInputStream缺省装饰器类。你可以再重新看下<a href=\"https://time.geekbang.org/column/article/204845\">第50讲</a>装饰器模式的相关内容。</p><p>如果我们不使用这个ForwardinCollection类，而是让AddLoggingCollection代理类直接实现Collection接口，那Collection接口中的所有方法，都要在AddLoggingCollection类中实现一遍，而真正需要添加日志功能的只有add()和addAll()两个函数，其他函数的实现，都只是类似Wrapper类中f2()函数的实现那样，简单地委托给原始collection类对象的对应函数。</p><p>为了简化Wrapper模式的代码实现，Guava提供一系列缺省的Forwarding类。用户在实现自己的Wrapper类的时候，基于缺省的Forwarding类来扩展，就可以只实现自己关心的方法，其他不关心的方法使用缺省Forwarding类的实现，就像AddLoggingCollection类的实现那样。</p><h2>Immutable模式在Guava中的应用</h2><p>Immutable模式，中文叫作不变模式，它并不属于经典的23种设计模式，但作为一种较常用的设计思路，可以总结为一种设计模式来学习。之前在理论部分，我们只稍微提到过Immutable模式，但没有独立的拿出来详细讲解，我们这里借Google Guava再补充讲解一下。</p><p>一个对象的状态在对象创建之后就不再改变，这就是所谓的不变模式。其中涉及的类就是<strong>不变类</strong>（Immutable Class），对象就是<strong>不变对象</strong>（Immutable Object）。在Java中，最常用的不变类就是String类，String对象一旦创建之后就无法改变。</p><p>不变模式可以分为两类，一类是普通不变模式，另一类是深度不变模式（Deeply Immutable Pattern）。普通的不变模式指的是，对象中包含的引用对象是可以改变的。如果不特别说明，通常我们所说的不变模式，指的就是普通的不变模式。深度不变模式指的是，对象包含的引用对象也不可变。它们两个之间的关系，有点类似之前讲过的浅拷贝和深拷贝之间的关系。我举了一个例子来进一步解释一下，代码如下所示：</p><pre><code>// 普通不变模式\npublic class User {\n  private String name;\n  private int age;\n  private Address addr;\n  \n  public User(String name, int age, Address addr) {\n    this.name = name;\n    this.age = age;\n    this.addr = addr;\n  }\n  // 只有getter方法，无setter方法...\n}\n\npublic class Address {\n  private String province;\n  private String city;\n  public Address(String province, String city) {\n    this.province = province;\n    this.city= city;\n  }\n  // 有getter方法，也有setter方法...\n}\n\n// 深度不变模式\npublic class User {\n  private String name;\n  private int age;\n  private Address addr;\n  \n  public User(String name, int age, Address addr) {\n    this.name = name;\n    this.age = age;\n    this.addr = addr;\n  }\n  // 只有getter方法，无setter方法...\n}\n\npublic class Address {\n  private String province;\n  private String city;\n  public Address(String province, String city) {\n    this.province = province;\n    this.city= city;\n  }\n  // 只有getter方法，无setter方法..\n}\n</code></pre><p>在某个业务场景下，如果一个对象符合创建之后就不会被修改这个特性，那我们就可以把它设计成不变类。显式地强制它不可变，这样能避免意外被修改。那如何将一个类设置为不变类呢？其实方法很简单，只要这个类满足：所有的成员变量都通过构造函数一次性设置好，不暴露任何set等修改成员变量的方法。除此之外，因为数据不变，所以不存在并发读写问题，因此不变模式常用在多线程环境下，来避免线程加锁。所以，不变模式也常被归类为多线程设计模式。</p><p>接下来，我们来看一种特殊的不变类，那就是不变集合。Google Guava针对集合类（Collection、List、Set、Map…）提供了对应的不变集合类（ImmutableCollection、ImmutableList、ImmutableSet、ImmutableMap…）。刚刚我们讲过，不变模式分为两种，普通不变模式和深度不变模式。Google Guava提供的不变集合类属于前者，也就是说，集合中的对象不会增删，但是对象的成员变量（或叫属性值）是可以改变的。</p><p>实际上，Java JDK也提供了不变集合类（UnmodifiableCollection、UnmodifiableList、UnmodifiableSet、UnmodifiableMap…）。那它跟Google Guava提供的不变集合类的区别在哪里呢？我举个例子你就明白了，代码如下所示：</p><pre><code>public class ImmutableDemo {\n  public static void main(String[] args) {\n    List&lt;String&gt; originalList = new ArrayList&lt;&gt;();\n    originalList.add(&quot;a&quot;);\n    originalList.add(&quot;b&quot;);\n    originalList.add(&quot;c&quot;);\n\n    List&lt;String&gt; jdkUnmodifiableList = Collections.unmodifiableList(originalList);\n    List&lt;String&gt; guavaImmutableList = ImmutableList.copyOf(originalList);\n\n    //jdkUnmodifiableList.add(&quot;d&quot;); // 抛出UnsupportedOperationException\n    // guavaImmutableList.add(&quot;d&quot;); // 抛出UnsupportedOperationException\n    originalList.add(&quot;d&quot;);\n\n    print(originalList); // a b c d\n    print(jdkUnmodifiableList); // a b c d\n    print(guavaImmutableList); // a b c\n  }\n\n  private static void print(List&lt;String&gt; list) {\n    for (String s : list) {\n      System.out.print(s + &quot; &quot;);\n    }\n    System.out.println();\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天我们学习了Google Guava中都用到的几个设计模式：Builder模式、Wrapper模式、Immutable模式。还是那句话，内容本身不重要，你也不用死记硬背Google Guava的某某类用到了某某设计模式。实际上，我想通过这些源码的剖析，传达给你下面这些东西。</p><p>我们在阅读源码的时候，要问问自己，为什么它要这么设计？不这么设计行吗？还有更好的设计吗？实际上，很多人缺少这种“质疑”精神，特别是面对权威（经典书籍、著名源码、权威人士）的时候。</p><p>我觉得我本人是最不缺质疑精神的一个人，我喜欢挑战权威，喜欢以理服人。就好比在今天的讲解中，我把ForwardingCollection等类理解为缺省Wrapper类，可以用在装饰器、代理、适配器三种Wrapper模式中，简化代码编写。如果你去看Google Guava在GitHub上的Wiki，你会发现，它对ForwardingCollection类的理解跟我是不一样的。它把ForwardingCollection类单纯地理解为缺省的装饰器类，只用在装饰器模式中。我个人觉得我的理解更加好些，不知道你怎么认为呢？</p><p>除此之外，在专栏的最开始，我也讲到，学习设计模式能让你更好的阅读源码、理解源码。如果我们没有之前的理论学习，那对于很多源码的阅读，可能都只停留在走马观花的层面上，根本学习不到它的精髓。这就好比今天讲到的CacheBuilder。我想大部分人都知道它是利用了Builder模式，但如果对Builder模式没有深入的了解，很少人能讲清楚为什么要用Builder模式，不用构造函数加set方法的方式来实现。</p><h2>课堂讨论</h2><p>从最后一段代码中，我们可以发现，JDK不变集合和Google Guava不变集合都不可增删数据。但是，当原始集合增加数据之后，JDK不变集合的数据随之增加，而Google Guava的不变集合的数据并没有增加。这是两者最大的区别。那这两者底层分别是如何实现不变的呢？</p><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"81 | 开源实战三（上）：借Google Guava学习发现和开发通用功能模块","id":233742},"right":{"article_title":"83 | 开源实战三（下）：借Google Guava学习三大编程范式中的函数式编程","id":235334}},"comments":[{"had_liked":false,"id":215941,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1589156869,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"237812358149","product_id":100039001,"comment_content":"JDK是浅拷贝，Guava使用的是深拷贝。一个复制引用，一个复制值。","like_count":56,"discussions":[{"author":{"id":1049741,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","nickname":"weineel","note":"","ucode":"6DC6EF4F256A53","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266268,"discussion_content":"第76讲说过，JDK的不变集合是用了装饰器模式，内部只是保留了源集合的引用，个人觉得不存在copy。\n\nGuava 里应该只是浅拷贝，因为元素内部的属性是可以改变的。","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1589498364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2343086,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","nickname":"徐志超-Klaus","note":"","ucode":"CF26B39965F2A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557730,"discussion_content":"java拿的是集合引用，guava拿的是集合内元素的引用；guava对于数组来说是深拷贝，对于元素来说，还是浅拷贝。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1647943579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267788,"discussion_content":"guava 中是将原始集合元素先 toArray，然后持有的 Object[]的引用，是深拷贝","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589688583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1866677,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq6pWvKsV4rzQ62z5MDEjaEU5MbDfmzbA62kUgoqia2tgKIIxw4ibkDhF7W48iat5dT8UB9Adky2NuzQ/132","nickname":"小仙","note":"","ucode":"9F94043DFCEC3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552327,"discussion_content":"JDK复制引用，guava复制值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645413976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215914,"user_name":"hhhh","can_delete":false,"product_type":"c1","uid":1256101,"ip_address":"","ucode":"9E87017424B382","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/a5/625c0a2e.jpg","comment_is_top":false,"comment_ctime":1589148802,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"74603592834","product_id":100039001,"comment_content":"猜测jdk中的不变集合保存了原始集合的引用，而guava应该是复制了原始集合的值。","like_count":18,"discussions":[{"author":{"id":1564614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/df/c6/b5e426c8.jpg","nickname":"金金","note":"","ucode":"2BAECB42C9BE80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363451,"discussion_content":"开辟了新的对象空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617197801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216089,"user_name":"不能忍的地精","can_delete":false,"product_type":"c1","uid":1754913,"ip_address":"","ucode":"66A921C0BC8102","user_header":"","comment_is_top":false,"comment_ctime":1589188581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40243894245","product_id":100039001,"comment_content":"Guava里面的引用已经是一个新的集合,Jdk里面的引用还是原来的集合","like_count":10},{"had_liked":false,"id":215922,"user_name":"何用","can_delete":false,"product_type":"c1","uid":1377393,"ip_address":"","ucode":"B0C6E8176AE6FD","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/71/0b949a4c.jpg","comment_is_top":false,"comment_ctime":1589152850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35948891218","product_id":100039001,"comment_content":"我是个特别能关注到细节的人。Memcached 是个开源库，不知道为何好多人都喜欢把它叫做 Memcache，本文也不例外。","like_count":7},{"had_liked":false,"id":217619,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1589549306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23064385786","product_id":100039001,"comment_content":"老师给这个深拷贝和浅拷贝不是太形象。String 本身就是不可变的。<br>从这个例子可以看出的是guava 重新创建了list，jdk 是持有的原list的引用。那么guava 有没有进一步的深copy呢？答案是：没有。里面的对象存储的还是引用<br>也或许老师说的深copy和浅copy只是指collection的引用。","like_count":5},{"had_liked":false,"id":215947,"user_name":"leezer","can_delete":false,"product_type":"c1","uid":1111111,"ip_address":"","ucode":"427DE9CD21E1EC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/TEzJ59GslVXQeZqwFgGhABF7K8bFFlud2pcsEPvEyruP7NGQTuh38IbiajdVYUSViaDJrIkJVnv3vdjPA9YENp5w/132","comment_is_top":false,"comment_ctime":1589158386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23063994866","product_id":100039001,"comment_content":"我觉得我更赞同wrapper类的理解，因为装饰器的主要功能是在原始的类上做功能增强，而代理模式更多关注对非业务功能的关注。通过组合的方式我们能实现更多的Wrapper模式。这时候就不只是算装饰器的设计模式了<br>。","like_count":5},{"had_liked":false,"id":216177,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1589200747,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18769069931","product_id":100039001,"comment_content":"在JDK中只是将list的地址赋给了UnmodifiableList<br>final List&lt;? extends E&gt; list;<br>UnmodifiableList(List&lt;? extends E&gt; list) {<br> super(list);<br> this.list = list;<br>}<br>在Guava中不可变集合是“保护性”拷贝，创建的不可变集合可以理解为常量。<br>要创建真正的不可变集合，集合中的对象还要是真正的不可变。<br>下面我举个反例，各位看看：<br>public static void main(String[] args) {<br>    List&lt;Student&gt; ori = new ArrayList&lt;&gt;();<br>    ori.add(new Student(&quot;xiaoqiang&quot;, 10));<br><br>    Student mutable = new Student(&quot;wangz&quot;, 8);<br>    ori.add(mutable);<br><br>    ori.add(new Student(&quot;lameda&quot;, 12));<br>    List&lt;Student&gt; jdkCopy = Collections.unmodifiableList(ori);<br><br>    List&lt;Student&gt; guavaCopy = ImmutableList.copyOf(ori);<br><br>    ori.add(new Student(&quot;wawa&quot;, 20));<br><br>    System.out.println(jdkCopy);<br>    System.out.println(guavaCopy);<br><br>    mutable.name = &quot;mutable&quot;;<br>    System.out.println(guavaCopy);<br>&#47;&#47;    [Student{age=10, name=&#39;xiaoqiang&#39;}, Student{age=8, name=&#39;mutable&#39;}, Student{age=12, name=&#39;lameda&#39;}]<br><br>  }","like_count":5},{"had_liked":false,"id":215962,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1589159894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18769029078","product_id":100039001,"comment_content":"jdk是浅拷贝，guava是深拷贝，在修改的时候报错","like_count":4},{"had_liked":false,"id":216933,"user_name":"落尘kira","can_delete":false,"product_type":"c1","uid":1092169,"ip_address":"","ucode":"D203B519E43F85","user_header":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","comment_is_top":false,"comment_ctime":1589371098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10179305690","product_id":100039001,"comment_content":"还有一点就是 作者觉得 不可变的例子，我看起来深拷贝和浅拷贝的代码是一摸一样的？深拷贝是对于对象类型的是否要加入 deepCopy（object）方法？","like_count":1},{"had_liked":false,"id":215983,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1589163482,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"10179098074","product_id":100039001,"comment_content":"JDK中的unmodifiableList的构造函数是对原始集合的浅拷贝，而Guava.ImmutableList.copyOf是对原始集合的深拷贝。从source code可以看出来：<br>UnmodifiableList<br>      UnmodifiableList(List&lt;? extends E&gt; list) {<br>            super(list);<br>            this.list = list;<br>        }<br>Guava.ImmutableList.copyOf<br>public static &lt;E&gt; ImmutableList&lt;E&gt; copyOf(Collection&lt;? extends E&gt; elements) {<br>    if (elements instanceof ImmutableCollection) {<br>      @SuppressWarnings(&quot;unchecked&quot;) &#47;&#47; all supported methods are covariant<br>      ImmutableList&lt;E&gt; list = ((ImmutableCollection&lt;E&gt;) elements).asList();<br>      return list.isPartialView() ? ImmutableList.&lt;E&gt;asImmutableList(list.toArray()) : list;<br>    }<br>    return construct(elements.toArray());<br>  }<br>  &#47;** Views the array as an immutable list. Checks for nulls; does not copy. *&#47;<br>  private static &lt;E&gt; ImmutableList&lt;E&gt; construct(Object... elements) {<br>    return asImmutableList(checkElementsNotNull(elements));<br>  }<br><br>  &#47;**<br>   * Views the array as an immutable list. Does not check for nulls; does not copy.<br>   *<br>   * &lt;p&gt;The array must be internally created.<br>   *&#47;<br>  static &lt;E&gt; ImmutableList&lt;E&gt; asImmutableList(Object[] elements) {<br>    return asImmutableList(elements, elements.length);<br>  }<br><br>  &#47;**<br>   * Views the array as an immutable list. Copies if the specified range does not cover the complete<br>   * array. Does not check for nulls.<br>   *&#47;<br>  static &lt;E&gt; ImmutableList&lt;E&gt; asImmutableList(Object[] elements, int length) {<br>    switch (length) {<br>      case 0:<br>        return of();<br>      case 1:<br>        return of((E) elements[0]);<br>      default:<br>        if (length &lt; elements.length) {<br>          elements = Arrays.copyOf(elements, length);<br>        }<br>        return new RegularImmutableList&lt;E&gt;(elements);<br>    }<br>  }","like_count":3},{"had_liked":false,"id":215977,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1589162190,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10179096782","product_id":100039001,"comment_content":"我觉得 ForwardingCollection 类就应该理解为缺省的装饰器类，前面的文章就说过代理模式、装饰器模式、适配器模式代码的写法几乎一样，差别就是各自的使用场景，我觉得ForwardingCollection这些类的使用场景就是作为装饰类来用的，不会应用到代理和适配器的场景，王老师貌似又掉入了以代码写法判断设计模式的自己说的陷阱中。","like_count":2,"discussions":[{"author":{"id":2068684,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotIianb3beTzsGIte6BZxlIhEwc2ryrNBGxZy8ibKbfibVJyUS8d3ZxybAdfJwHPm13ydPC4VJP7Lbw/132","nickname":"taku","note":"","ucode":"B22DA9A4A9DC91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383525,"discussion_content":"模式的运用要看具体的场景，老师的例子中是添加功能之外的代码，是可以理解为代理模式的，如果你自己的代码中实现是对add方法的加强，那么你也可以理解为装饰者模式，这个并不影响的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626144903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220036,"user_name":"yu","can_delete":false,"product_type":"c1","uid":1138645,"ip_address":"","ucode":"56856DCC0C8387","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/d5/2fec2911.jpg","comment_is_top":false,"comment_ctime":1590139596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885106892","product_id":100039001,"comment_content":"JDK与Guava的不可变集合都是属于普通不可变集合，试了一下，无法增减元素，但都是可以对集合中的对像的成员变量修改的。不同的是，原集合改动之后，JDK跟着改变，Guava不跟着变","like_count":1},{"had_liked":false,"id":219369,"user_name":"董大大","can_delete":false,"product_type":"c1","uid":1334181,"ip_address":"","ucode":"5C7299DCB1DD79","user_header":"https://static001.geekbang.org/account/avatar/00/14/5b/a5/7c079c73.jpg","comment_is_top":false,"comment_ctime":1590019676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884986972","product_id":100039001,"comment_content":"深究设计模式，对阅读开源代码大有好处","like_count":1},{"had_liked":false,"id":216930,"user_name":"落尘kira","can_delete":false,"product_type":"c1","uid":1092169,"ip_address":"","ucode":"D203B519E43F85","user_header":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","comment_is_top":false,"comment_ctime":1589370902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884338198","product_id":100039001,"comment_content":"JDK的是不允许在方法级别对不可变集合发生变更（抛出异常），其内部维护的是原集合对象，而原集合对象内部本身是浅拷贝；而Guava除了在方法级别限制不可变更外，其内部使用list.toArray（），该方法每次返回的数组对象都不一样","like_count":1},{"had_liked":false,"id":216588,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1589291010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884258306","product_id":100039001,"comment_content":"java 的设计模式应该出个新版本了。","like_count":1},{"had_liked":false,"id":216238,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1589208287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884175583","product_id":100039001,"comment_content":"当原始集合增加数据之后，JDK 不变集合的数据随之增加，而 Google Guava 的不变集合的数据并没有增加。为啥要设置成跟jdk不一样？换句话说，我觉得应该是，如果jdk和guava功能都一摸一样，就没有存在的必要了。底层的实现，jdk如下：<br>final List&lt;? extends E&gt; list，guava是对集合内容的对象进行逐一拷贝。<br>本来不想查源码，但是不想误导别人，还是把源码看了一下。<br>","like_count":1},{"had_liked":false,"id":216222,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1589206801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884174097","product_id":100039001,"comment_content":"unmodifiableList 内部还是使用了Warpper模式，重新实现了某些方法，比如add,remove等，当调用这些方法时，抛出异常，而有些方法还是委托给原始list进行操作，比如get操作。所以这里在原始类添加元素后，使用不jdk的变类可以打印出新添加的元素。而Guava 中的ImmutableList 时采用拷贝的方式将原始集合中的数据拷贝到一个对象数组中，后续原始集合添加，删除元素，其结果都不会影响该ImmutableList。","like_count":2},{"had_liked":false,"id":216175,"user_name":"do it","can_delete":false,"product_type":"c1","uid":1309911,"ip_address":"","ucode":"E0753912E8F2AF","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d7/b102034a.jpg","comment_is_top":false,"comment_ctime":1589200347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884167643","product_id":100039001,"comment_content":"没看过源码，猜测是浅拷贝与深拷贝的区别","like_count":1},{"had_liked":false,"id":216047,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1589173949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884141245","product_id":100039001,"comment_content":"1.两者都是生成一个新的集合对象。<br>2.前者相当于对原集合采用装饰者模式。通过复合方式限制掉原集合的写操作。实现，封装后的集合，在后续使用中不可变的特性。具有灵活性。<br>3.后者相当于新建一个不可变集合。通过原集合的元素，生成一个不可变集合。语义更加明确。<br><br>4.前者通过按需操作，具备灵活性。但在集合接口加缺省方法时，可能会有bug。毕竟它是以复合实现功能的。后者语义更明确，不具备前者的灵活性。但在集合接口加缺省方法时，一般不会有bug。因为它是操作自身数据结构实现的功能，与原集合无关联。","like_count":1},{"had_liked":false,"id":216004,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1589166211,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5884133507","product_id":100039001,"comment_content":"课后题:<br>jdk的不变集合引用了原始的集合类,所以在原始集合类发生改变的时候他也会改变,他的不可变只是客户端不可变;<br>guava的不变集合,是在重新创建了一个原始集合对象的副本,所以改变原始类并不能改变他的数据","like_count":1},{"had_liked":false,"id":215991,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1589164094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884131390","product_id":100039001,"comment_content":"通过阅读JDK源码, 发现UnmodifiableList内部使用原始List的浅拷贝, 所以当原始list增&#47;删时会影响UnmodifiableList. 额外说一句, UnmodifiableList实现并Override了List接口的add(), remove()等方法, 通过抛出UnsupportedOperationException来抑制add&#47;remove等改变数据源的操作.<br><br>Guava包下的ImmutableList.copyOf(Collection&lt;? extends E&gt; elements)内部调用了construct(elements.toArray())方法, 内部维护了源List的数组copy, 属于深拷贝范畴. 执行construct(elements.toArray())后, ImmutableList内部维护数组作为数据源, 与源List完全隔离, 所以源List的add&#47;remove等操作不会影响到ImmutableList.<br><br>源码参考:<br>java.util.collections 1337行开始;(内部类UnmodifiableList)<br>com.google.common.collect.ImmutableList 238行开始.(copyOf方法)","like_count":1},{"had_liked":false,"id":215975,"user_name":"Snway","can_delete":false,"product_type":"c1","uid":1102888,"ip_address":"","ucode":"0AD31AECA8A8F7","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/28/3b6546e8.jpg","comment_is_top":false,"comment_ctime":1589161871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884129167","product_id":100039001,"comment_content":"Jdk直接引用原来的集合，guava是拷贝了原来的集合","like_count":1},{"had_liked":false,"id":215952,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1589158821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884126117","product_id":100039001,"comment_content":"要多思考背后为什么要用这种设计模式，才能对使用的设计模式有更深刻的理解。打卡！","like_count":1},{"had_liked":false,"id":215928,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1053390,"ip_address":"","ucode":"ABB3F1A63E102A","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","comment_is_top":false,"comment_ctime":1589153865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884121161","product_id":100039001,"comment_content":"思考题：我猜是深拷贝和浅拷贝的区别","like_count":1},{"had_liked":false,"id":328596,"user_name":"idiot","can_delete":false,"product_type":"c1","uid":2526391,"ip_address":"","ucode":"D7A6E980B530B4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fcftgBsticCicEEkuzB0GTkHIocX62YVTSvnhR1c94sccj42lVaYXrmcZyhzUI3l9NcvuN1rXLhXt2eBrZZ0Tw7A/132","comment_is_top":false,"comment_ctime":1640783439,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1640783439","product_id":100039001,"comment_content":"“我们可以在系统内部构建一个内存缓存，跟系统集成在一起开发、部署”，但是这样的话，这个系统&#47;模块就不是无状态的了，不利于扩缩容吧。","like_count":0,"discussions":[{"author":{"id":2630424,"avatar":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","nickname":"易飞","note":"","ucode":"32AC28754237F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389610,"discussion_content":"2021-8-19","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629355816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343485,"discussion_content":"时光匆匆啊，已经2021-1-19了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611060946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344997,"avatar":"https://static001.geekbang.org/account/avatar/00/14/85/e5/eedb0528.jpg","nickname":"Zed","note":"","ucode":"0B1BF15DFB050C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549473,"discussion_content":"都 2202 年啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644023526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1281585,"avatar":"https://static001.geekbang.org/account/avatar/00/13/8e/31/28972804.jpg","nickname":"阿海","note":"","ucode":"2589431F840C42","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377192,"discussion_content":"今天是61儿童节了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622542383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309619,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1630281306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630281306","product_id":100039001,"comment_content":"jdk的不变集合是从原始拿最新的快照，当原始类改变时，就会更新快照。而guava始终只拿一次快照，那就是在构建不变集合的时候，将原始类的快照信息初始化到不变集合中。之后原始类添加或删除元素，guava的不变集合就不再改变元素的个数。","like_count":0},{"had_liked":false,"id":306348,"user_name":"k先生","can_delete":false,"product_type":"c1","uid":1221532,"ip_address":"","ucode":"76D292DC62B52D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/9c/8a14b7db.jpg","comment_is_top":false,"comment_ctime":1628505925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628505925","product_id":100039001,"comment_content":"课堂讨论：<br>1， collections 的 UnmodifiableList 类中是引用了传参list，<br>源码部分<br>final List&lt;? extends E&gt; list;<br><br>        UnmodifiableList(List&lt;? extends E&gt; list) {<br>            super(list);<br>            this.list = list;<br>        }<br><br>2，guava的 ImmutableList 类中，是复制了一份原数组，<br>源码中<br> Object[] elementsWithoutTrailingNulls =<br>            length &lt; elements.length ? Arrays.copyOf(elements, length) : elements;<br>        return new RegularImmutableList&lt;E&gt;(elementsWithoutTrailingNulls);<br><br>即，第一个是前拷贝，第二个是深拷贝；所以对原originalList的新增并不会影响guava中的list","like_count":0},{"had_liked":false,"id":302249,"user_name":"taku","can_delete":false,"product_type":"c1","uid":2068684,"ip_address":"","ucode":"B22DA9A4A9DC91","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotIianb3beTzsGIte6BZxlIhEwc2ryrNBGxZy8ibKbfibVJyUS8d3ZxybAdfJwHPm13ydPC4VJP7Lbw/132","comment_is_top":false,"comment_ctime":1626146288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626146288","product_id":100039001,"comment_content":"jdk 的是直接引用list，可以理解为浅拷贝，guava也是浅拷贝，但是并不是直接引用list，而是通过新建list复制原list中的对象，故在list.add()时jdk结果就是多出来一个，list.add并不影响guava内部维护的list，故数据量不变。但是如果直接修改list中对象的属性，jdk和guava结果是相同的，都会改变。<br><br>测试代码：<br>public static void main(String[] args) {<br>        List&lt;User&gt; list = new ArrayList&lt;&gt;(12);<br>        list.add(new User(&quot;hello&quot;));<br>        User s = new User(&quot;taku&quot;);<br>        list.add(new User(&quot;world&quot;));<br>        list.add(s);<br>        List&lt;User&gt; strings = Collections.unmodifiableList(list);<br>        List guavaImmutableList = ImmutableList.copyOf(list);<br>        System.out.println(strings);<br>        System.out.println(guavaImmutableList);<br>        list.add(new User(&quot;jerry&quot;));<br>        s.name = &quot;hhaha&quot;;<br>        System.out.println(strings);<br>        System.out.println(guavaImmutableList);<br>    }<br><br>    public static class User<br>    {<br>        String name;<br><br>        public User(String name) {<br>            this.name = name;<br>        }<br><br>        @Override<br>        public String toString() {<br>            return &quot;User{&quot; +<br>                    &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +<br>                    &#39;}&#39;;<br>        }<br>    }<br><br>&#47;&#47;  结果如下：<br>[User{name=&#39;hello&#39;}, User{name=&#39;world&#39;}, User{name=&#39;taku&#39;}]<br>[User{name=&#39;hello&#39;}, User{name=&#39;world&#39;}, User{name=&#39;taku&#39;}]<br>[User{name=&#39;hello&#39;}, User{name=&#39;world&#39;}, User{name=&#39;hhaha&#39;}, User{name=&#39;jerry&#39;}]<br>[User{name=&#39;hello&#39;}, User{name=&#39;world&#39;}, User{name=&#39;hhaha&#39;}]","like_count":0},{"had_liked":false,"id":288623,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1618565131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618565131","product_id":100039001,"comment_content":"镜像和非镜像的区别。<br>我感觉 ForwardingCollection 更像模板类的感觉","like_count":0},{"had_liked":false,"id":285957,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1617086846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617086846","product_id":100039001,"comment_content":"思考题：<br>目前没有引入Guava，就没有看源码。我猜测应该是构造时做了处理。<br>看了下jdk的UnmodifiableList类的源码，实际上还是把list交给父类构造了，只是重写了add方法，如下<br> public void add(int index, E element) {<br>            throw new UnsupportedOperationException();<br>        }","like_count":0},{"had_liked":false,"id":274377,"user_name":"T","can_delete":false,"product_type":"c1","uid":1310153,"ip_address":"","ucode":"0B042D818F7541","user_header":"https://static001.geekbang.org/account/avatar/00/13/fd/c9/9453237e.jpg","comment_is_top":false,"comment_ctime":1610983685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610983685","product_id":100039001,"comment_content":"我觉得我本人是最不缺质疑精神的一个人，我喜欢挑战权威，喜欢以理服人。 喜欢这句。","like_count":0},{"had_liked":false,"id":260756,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1605097116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605097116","product_id":100039001,"comment_content":"guava 底层操作，把原collection的内容通过Arrays copy了一遍，所以源collection添加元素不会导致immutable的结果发生改变。<br>源码如下：<br>----------------------------------------------------------------------------<br>&#47;**<br>   * Views the array as an immutable list. Copies if the specified range does not cover the complete<br>   * array. Does not check for nulls.<br>   *&#47;<br>  static &lt;E&gt; ImmutableList&lt;E&gt; asImmutableList(Object[] elements, int length) {<br>    switch (length) {<br>      case 0:<br>        return of();<br>      case 1:<br>        return of((E) elements[0]);<br>      default:<br>        if (length &lt; elements.length) {<br>          elements = Arrays.copyOf(elements, length);<br>        }<br>        return new RegularImmutableList&lt;E&gt;(elements);<br>    }<br>  }","like_count":0},{"had_liked":false,"id":257889,"user_name":"林峰峰","can_delete":false,"product_type":"c1","uid":1457609,"ip_address":"","ucode":"83C2093135BBB8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3B5MoC4DfBt00nnVshEBFHHkNVgbcBrXsd3SxFicdN3XX5ILOe7GJxKvtJKCY53xNCuxSV8ABxNulbhkibm1lXIw/132","comment_is_top":false,"comment_ctime":1604195733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604195733","product_id":100039001,"comment_content":"普通不变和 深度不变代码没有区别呢","like_count":0},{"had_liked":false,"id":253923,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1602947912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602947912","product_id":100039001,"comment_content":"1.JDK只是代理了原始的集合引用，并重写了修改操作的方法，所以对UnmodifiableList的修改操作会抛出异常。但是如果持有了原始集合的引用，可以通过原始结合修改元素，进而绕过不可修改的限制。而guava巧妙的一点是，在创建ImmutableList的时候，使用Arrays.copyOf做了一次拷贝，不再持有原始集合的引用。<br>2. JDK只是对集合功能的增强，是装饰器模式的思路；guava则是不可变模式的思路","like_count":0},{"had_liked":false,"id":221392,"user_name":"被讨厌的勇气","can_delete":false,"product_type":"c1","uid":1547913,"ip_address":"","ucode":"AE3B3CA27D91A2","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","comment_is_top":false,"comment_ctime":1590490274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590490274","product_id":100039001,"comment_content":"在C++中，可以使用const 来使其不变。JDK的做法在C++中可以通过定义const&amp;即const别名来实现。而Guava的做法是拷贝原对象，并将其赋给一个const对象（可以是引用）。","like_count":0},{"had_liked":false,"id":219174,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1589961227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589961227","product_id":100039001,"comment_content":"原始集合改变了, 不变集合跟着改变, 这种可以用wrapper模式实现, 也就是原始集合机器这是被放到不可变集合里面.<br><br>而原始集合改变了不影响不变集合, 这种可以用复制的模式把原始集合的内容先复制到不可变集合里面, 复杂度O(n), O(nlogn)还是可以接受的.","like_count":0}]}