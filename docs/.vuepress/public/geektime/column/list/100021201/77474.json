{"id":77474,"title":"14 | 树的广度优先搜索（下）：为什么双向广度优先搜索的效率更高？","content":"<p>你好，我是黄申。</p><p>上一讲，我们通过社交好友的关系，介绍了为什么需要广度优先策略，以及如何通过队列来实现它。有了广度优先搜索，我们就可以知道某个用户的一度、二度、三度等好友是谁。不过，在社交网络中，还有一个经常碰到的问题，那就是给定两个用户，如何确定他们之间的关系有多紧密？</p><p>最直接的方法是，使用这两人是几度好友，来衡量他们关系的紧密程度。今天，我就这个问题，来聊聊广度优先策略的一种扩展：双向广度优先搜索，以及这种策略在工程中的应用。</p><h2>如何更高效地求出两个用户间的最短路径？</h2><p>基本的做法是，从其中一个人出发，进行广度优先搜索，看看另一个人是否在其中。如果不幸的话，两个人相距六度，那么即使是广度优先搜索，同样要达到万亿级的数量。</p><p>那究竟该如何更高效地求得两个用户的最短路径呢？我们先看看，影响效率的问题在哪里？很显然，随着社会关系的度数增加，好友数量是呈指数级增长的。所以，如果我们可以控制这种指数级的增长，那么就可以控制潜在好友的数量，达到提升效率的目的。</p><p>如何控制这种增长呢？我这里介绍一种“<strong>双向广度优先搜索</strong>”。它巧妙地运用了两个方向的广度优先搜索，大幅降低了搜索的度数。现在我就带你看下，这个方法的核心思想。</p><!-- [[[read_end]]] --><p>假设有两个人$a$、$b$。</p><ul>\n<li>我们首先从$a$出发，进行广度优先搜索，记录$a$的所有一度好友$a_{1}$，然后看点$b$是否出现在集合$a_{1}$中。</li>\n<li>如果没有，就再从$b$出发，进行广度优先搜索，记录所有一度好友$b_{1}$，然后看$a$和$a_{1}$是否出现在$b$和$b_{1}$的并集中。</li>\n<li>如果没有，就回到$a$，继续从它出发的广度优先搜索，记录所有二度好友$a_{2}$，然后看$b$和$b_{1}$是否出现在$a$、$a_{1}$和$a_{2}$三者的并集中。</li>\n<li>如果没有，就回到$b$，继续从它出发的广度优先搜索。</li>\n<li>如此轮流下去，直到找到$a$的好友和$b$的好友的交集。</li>\n</ul><p>如果有交集，就表明这个交集里的点到$a$和$b$都是通路。</p><p>我们假设$c$在这个交集中，那么把$a$到$c$的通路长度和$b$到$c$的通路长度相加，得到的就是从$a$到$b$的最短通路长（这个命题可以用反证法证明），也就是两者为几度好友。这个过程有点复杂，我画了一张图帮助你来理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/0e/b665fdbd81e7d0fb3245fbcd3b21230e.jpg?wh=1142*856\" alt=\"\"></p><p>思路你应该都清楚了，现在我们来看看如何用代码来实现。</p><p>要想实现双向广度优先搜索，首先我们要把结点类Node稍作修改，增加一个变量degrees。这个变量是HashMap类型，用于存放从不同用户出发，到当前用户是第几度结点。比如说，当前结点是4，从结点1到结点4是3度，结点2到结点4是2度，结点3到结点4是4度，那么结点4的degrees变量存放的就是如下映射：</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/47/e27d792a83dbe325ad5d0432910ffb47.png?wh=962*302\" alt=\"\"></p><p>有了变量degrees，我们就能随时知道某个点和两个出发点各自相距多少。所以，在发现交集之后，根据交集中的点和两个出发点各自相距多少，就能很快地算出最短通路的长度。理解了这点之后，我们在原有的Node结点内增加degrees变量的定义和初始化。</p><pre><code>public class Node {\n\t\t......\n\t\tpublic HashMap&lt;Integer, Integer&gt; degrees;\t\t// 存放从不同用户出发，当前用户结点是第几度\n\t\t\n\t\t// 初始化结点\n\t\tpublic Node(int id) {\n\t\t\t......\n\t\t\tdegrees = new HashMap&lt;&gt;();\n\t\t\tdegrees.put(id, 0);\n\t\t}\n\t}\n\n</code></pre><p>为了让双向广度优先搜索的代码可读性更好，我们可以先实现两个模块化的函数：getNextDegreeFriend和hasOverlap。函数getNextDegreeFriend是根据给定的队列，查找和起始点相距度数为指定值的所有好友。而函数hasOverlap用来判断两个集合是不是有交集。有了这些模块化的函数，双向广度优先搜索的代码就更直观了。</p><p>在函数一开始，我们先进行边界条件判断。</p><pre><code>/**\n* @Description:\t通过双向广度优先搜索，查找两人之间最短通路的长度\n* @param user_nodes-用户的结点；user_id_a-用户a的ID；user_id_b-用户b的ID\n* @return void\n*/\n\tpublic static int bi_bfs(Node[] user_nodes, int user_id_a, int user_id_b) {\n\t\t\n\t\tif (user_id_a &gt; user_nodes.length || user_id_b &gt; user_nodes.length) return -1;\t// 防止数组越界的异常\n\t\t\n\t\tif (user_id_a == user_id_b) return 0;\t\t// 两个用户是同一人，直接返回0\n</code></pre><p>由于同时从两个用户的结点出发，对于所有，有两条搜索的路径，我们都需要初始化两个用于广度优先搜索的队列，以及两个用于存放已经被访问结点的HashSet。</p><pre><code>  Queue&lt;Integer&gt; queue_a = new LinkedList&lt;Integer&gt;();\t// 队列a，用于从用户a出发的广度优先搜索\n\t\tQueue&lt;Integer&gt; queue_b = new LinkedList&lt;Integer&gt;();\t// 队列b，用于从用户b出发的广度优先搜索\n\t\t\n\t\tqueue_a.offer(user_id_a);\t\t// 放入初始结点\n\t\tHashSet&lt;Integer&gt; visited_a = new HashSet&lt;&gt;();\t// 存放已经被访问过的结点，防止回路\n\t\tvisited_a.add(user_id_a);\n\t\t\n\t\tqueue_b.offer(user_id_b);\t\t// 放入初始结点\n\t\tHashSet&lt;Integer&gt; visited_b = new HashSet&lt;&gt;();\t// 存放已经被访问过的结点，防止回路\n\t\tvisited_b.add(user_id_b);\n\t\t\n</code></pre><p>接下来要做的是，从两个结点出发，沿着各自的方向，每次广度优先搜索一度，并查找是不是存在重叠的好友。</p><pre><code>int degree_a = 0, degree_b = 0, max_degree = 20;\t\t// max_degree的设置，防止两者之间不存在通路的情况\n\nwhile ((degree_a + degree_b) &lt; max_degree) {\n\t\t\tdegree_a ++;\n\t\t\tgetNextDegreeFriend(user_id_a, user_nodes, queue_a, visited_a, degree_a);\n\t// 沿着a出发的方向，继续广度优先搜索degree + 1的好友\n\t\t\tif (hasOverlap(visited_a, visited_b)) return (degree_a + degree_b);\n\t// 判断到目前为止，被发现的a的好友，和被发现的b的好友，两个集合是否存在交集\n\t\t\t\n\t\t\tdegree_b ++;\n\t\t\tgetNextDegreeFriend(user_id_b, user_nodes, queue_b, visited_b, degree_b);\n\t// 沿着b出发的方向，继续广度优先搜索degree + 1的好友\n\t\t\tif (hasOverlap(visited_a, visited_b)) return (degree_a + degree_b);\n\t// 判断到目前为止，被发现的a的好友，和被发现的b的好友，两个集合是否存在交集\n\t\t\t\n\t\t}\n  \n\t\treturn -1;\t\t\t\n    // 广度优先搜索超过max_degree之后，仍然没有发现a和b的重叠，认为没有通路\n\t\t\n\t}\n</code></pre><p>你可以同时实现单向广度优先搜索和双向广度优先搜索，然后通过实验来比较两者的执行时间，看看哪个更短。如果实验的数据量足够大（比如说结点在1万以上，边在5万以上），你应该能发现，<strong>双向的方法对时间和内存的消耗都更少</strong>。</p><p>为什么双向搜索的效率更高呢？我以平均好友度数为4，给你举例讲解。</p><p>左边的图表示从结点$a$单向搜索走2步，右边的图表示分别从结点$a$和$b$双向搜索各走1步。很明显，左边的结点有16个，明显多于右边的8个结点。而且，随着每人认识的好友数、搜索路径的增加，这种差距会更加明显。</p><p><img src=\"https://static001.geekbang.org/resource/image/15/5b/1518aaa073b379b20ba3dca8dde08d5b.jpg?wh=1142*741\" alt=\"\"></p><p>我们假设每个地球人平均认识100个人，如果两个人相距六度，单向广度优先搜索要遍历100^6=1万亿左右的人。如果是双向广度优先搜索，那么两边各自搜索的人只有100^3=100万。</p><p>当然，你可能会说，单向广度优先搜索之后查找匹配用户的开销更小啊。的确如此，假设我们要知道结点$a$和$b$之间的最短路径，单向搜索意味着要在$a$的1万亿个好友中查找$b$。如果采用双向搜索的策略，从结点$a$和$b$出发进行广度优先搜索，每个方向会产生100万的好友，那么需要比较这两组100万的好友是否有交集。</p><p>假设我们使用哈希表来存储$a$的1万亿个好友，并把搜索$b$是否存在其中的耗时记作x，而把判断两组100万好友是否有交集的耗时记为y，那么通常x&lt;y。</p><p>不过，综合考虑广度优先搜索出来的好友数量，双向广度优先搜索还是更有效。为什么这么说呢？稍后介绍算法复杂度的概念和衡量方法时，我会具体来分析这个例子。</p><p>广度优先搜索的应用场景有很多，下面我来说说这种策略的一个应用。</p><h2>如何实现更有效地嵌套型聚合？</h2><p>广度优先策略可以帮助我们大幅优化数据分析中的聚合操作。聚合是数据分析中一个很常见的操作，它会根据一定的条件把记录聚集成不同的分组，以便我们统计每个分组里的信息。目前，SQL语言中的GROUP BY语句，Python和Spark语言中data frame的groupby函数，Solr的facet查询和ElasticSearch的aggregation查询，都可以实现聚合的功能。</p><p>我们可以嵌套使用不同的聚合，获得层级型的统计结果。但是，实际上，针对一个规模超大的数据集，聚合的嵌套可能会导致性能严重下降。这里我来谈谈如何利用广度优先的策略，对这个问题进行优化。</p><p>首先，我用一个具体的例子来给你讲讲，什么是多级嵌套的聚合，以及为什么它会产生严重的性能问题。</p><p>这里我列举了一个数据表，它描述了一个社交网络中，每个人的职业经历。字段包括项目的ID、用户ID、公司ID和同事的IDs。</p><p><img src=\"https://static001.geekbang.org/resource/image/82/02/8216d39c6bdc3925e5ea139071a41202.png?wh=1548*790\" alt=\"\"></p><p>对于这张表，我们可以进行三层嵌套的聚集。第一级是根据用户ID来聚，获取每位用户一共参与了多少项目。第二级是根据公司ID来聚，获取每位用户在每家公司参与了多少项目。第三级根据同事ID来聚，获取每位用户在每家公司，和每位同事共同参与了多少项目。最终结果应该是类似下面这样的：</p><pre><code>用户u88，总共50个项目（包括在公司c42中的10个，c26中的8个...）\n\t\t在公司c42中，参与10个项目（包括和u120共事的4个，和u99共事的3个...）\n\t\t\t\t和u120共同参与4个项目\n\t\t\t\t和u99共同参与3个项目\n\t\t\t\t和u72共同参与3个项目\n\t\t在公司c26中，参与了8个项目\n\t\t\t\t和u145共同参与5个项目\n\t\t\t\t和u128共同参与3个项目\n\t\t（用户u88在其他公司的项目...）\n\n用户u66，总共47个项目\n\t\t在公司c28中，参与了16个项目\n\t\t  和u65共同参与了5个项目\n(用户u66的剩余数据...）\n...\t\t\n（其他用户的数据...）\n</code></pre><p>为了实现这种嵌套式的聚合统计，你会怎么来设计呢？看起来挺复杂的，其实我们可以用最简单的排列的思想，分别为“每个用户”“每个用户+每个公司”“每个用户+每个公司+每位同事”，生成很多很多的计数器。可是，如果用户的数量非常大，那么这个“很多”就会成为一个可怕的数字。</p><p>我们假设这个社交网有5万用户，每位用户平均在5家公司工作过，而用户在每家公司平均有10名共事的同事，那么针对用户的计数器有5万个，针对“每个用户+每个公司”的计数器有25万个，而到了“每个用户+每个公司+每位同事”的计数器，就已经达到250万个了，三个层级总共需要280万计数器。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/d8/61dc9b211bf5f7e4f33bf24b1dba9cd8.jpg?wh=1142*650\" alt=\"\"></p><p>我们假设一个计数器是4个字节，那么280万个计数器就需要消耗超过10M的内存。对于高并发、低延迟的实时性服务，如果每个请求都要消耗10M内存，很容易就导致服务器崩溃。另外，实时性的服务，往往只需要前若干个结果就足以满足需求了。在这种情况下，完全基于排列的设计就有优化的空间了。</p><p>从刚才那张图中，其实我们就能想到一些优化的思路。</p><p>对于只需要返回前若干结果的应用场景，我们可以对图中的树状结构进行剪枝，去掉绝大部分不需要的结点和边，这样就能节省大量的内存和CPU计算。</p><p>比如，如果我们只需要返回前100个参与项目最多的用户，那么就没有必要按照深度优先的策略，去扩展树中高度为2和3的结点了，而是应该使用广度优先策略，首先找出所有高度为1的结点，根据项目数量进行排序，然后只取出前100个，把计数器的数量从5万个一下子降到100个。</p><p>以此类推，我们还可以控制高度为2和3的结点之数量。如果我们只要看前100位用户，每位用户只看排名第一的公司，而每家公司只看合作最多的3名同事，那么最终计数器数量就只有50000+100x5+100x1x10=51500。只有文字还是不太好懂，我画了一张图，帮你理解这个过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/d6/8183dff98d2f84b053ca103cb26566d6.jpg?wh=1142*856\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/86/25/86e89d1df417e7e1d364e1416855b625.jpg?wh=1142*514\" alt=\"\"></p><p>如果一个项目用到排列组合的思想，我们需要在程序里使用大量的变量，来保存数据或者进行计算，这会导致内存和CPU使用量的急剧增加。在允许的情况下，我们可以考虑使用广度优先策略，对排列组合所生成的树进行优化。这样，我们就可以有效地缩减树中靠近根的结点数量，避免之后树的爆炸性生长。</p><h2>小结</h2><p>广度优先搜索，相对于深度优先搜索，没有函数的嵌套调用和回溯操作，所以运行速度比较快。但是，随着搜索过程的进行，广度优先需要在队列中存放新遇到的所有结点，因此占用的存储空间通常比深度优先搜索多。</p><p>相比之下，深度优先搜索法只保留用于回溯的结点，而扩展完的结点会从栈中弹出并被删除。所以深度优先搜索占用空间相对较少。不过，深度优先搜索的速度比较慢，而并不适合查找结点之间的最短路径这类的应用。</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/64/d735ed146cac3ca1f81df5acbe634664.jpg?wh=1242*1441\" alt=\"\"></p><h2>思考题</h2><p>今天所说的双向广度优先比单向广度优先更高效，其实是要基于一个前提条件的。你能否说出，在什么情况下，单向广度优先更高效呢？针对这种情况，又该如何优化双向广度优先呢？</p><p><span class=\"orange\">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>","neighbors":{"left":{"article_title":"13 | 树的广度优先搜索（上）：人际关系的六度理论是真的吗？","id":77129},"right":{"article_title":"15 | 从树到图：如何让计算机学会看地图？","id":77849}},"comments":[{"had_liked":false,"id":61927,"user_name":"elephant","can_delete":false,"product_type":"c1","uid":1123628,"ip_address":"","ucode":"99C8DF507CDB7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/2c/2bbd84ef.jpg","comment_is_top":false,"comment_ctime":1547859834,"is_pvip":false,"replies":[{"id":"21968","content":"是的","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1547927553,"ip_address":"","comment_id":61927,"utype":1}],"discussion_count":1,"race_medal":0,"score":"169051584378","product_id":100021201,"comment_content":"如果a和b好友分布极不均匀，比如a和a的所有子好友平均都有100个好友，b和b的所有子好友平均有2个好友，这样的情况下，从b开始的单向搜索要高效很多吧","like_count":40,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437039,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547927553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61070,"user_name":"菩提","can_delete":false,"product_type":"c1","uid":1309278,"ip_address":"","ucode":"19586AC50BEF1E","user_header":"","comment_is_top":false,"comment_ctime":1547612502,"is_pvip":false,"replies":[{"id":"21804","content":"逻辑上是对的👌","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1547682550,"ip_address":"","comment_id":61070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48792252758","product_id":100021201,"comment_content":"完善了一下这两个预留的方法<br>private static boolean hasOverlap(HashSet&lt;Integer&gt; visited_a, HashSet&lt;Integer&gt; visited_b) {<br>\t\tif (visited_a.isEmpty() || visited_b.isEmpty())<br>\t\t\treturn false;<br>\t\tfor (int user_id_a : visited_a) {<br>\t\t\tif (visited_b.contains(user_id_a)) {<br>\t\t\t\treturn true;<br>\t\t\t}<br>\t\t}<br>\t\treturn false;<br>\t}<br><br>\tprivate static void getNextDegreeFriend(int user_id_a, Node[] user_nodes, Queue&lt;Integer&gt; queue_a,<br>\t\t\tHashSet&lt;Integer&gt; visited_a, int degree_a) {<br>\t\tif (user_nodes[user_id_a] == null)<br>\t\t\treturn;<br>\t\tNode current_node = user_nodes[user_id_a];<br>\t\tHashSet&lt;Integer&gt; friends = current_node.friends;<br>\t\tif (friends.isEmpty())<br>\t\t\treturn;<br>\t\tHashMap&lt;Integer, Integer&gt; degrees = current_node.degrees;<br>\t\tfor (int f_user_id : friends) {<br>\t\t\tqueue_a.offer(f_user_id);<br>\t\t\tvisited_a.add(f_user_id);<br>\t\t\tdegrees.put(f_user_id, degree_a + 1);<br>\t\t}<br>\t}<br>        &#47;&#47; 初始化节点数组<br>\tpublic static Node[] init(int user_num, int relation_num) {<br>\t\tRandom rand = new Random();<br>\t\tNode[] user_nodes = new Node[user_num];<br><br>\t\t&#47;&#47; 生成所有表示用户的节点<br>\t\tfor (int i = 0; i &lt; user_num; i++) {<br>\t\t\tuser_nodes[i] = new Node(i);<br>\t\t}<br><br>\t\t&#47;&#47; 生成所有表示好友关系的边<br>\t\tfor (int i = 0; i &lt; relation_num; i++) {<br>\t\t\tint friend_a_id = rand.nextInt(user_num);<br>\t\t\tint friend_b_id = rand.nextInt(user_num);<br>\t\t\tif (friend_a_id == friend_b_id)<br>\t\t\t\tcontinue;<br>\t\t\tNode friend_a = user_nodes[friend_a_id];<br>\t\t\tNode friend_b = user_nodes[friend_b_id];<br>\t\t\tfriend_a.friends.add(friend_b_id);<br>\t\t\tfriend_b.friends.add(friend_a_id);<br>\t\t}<br><br>\t\treturn user_nodes;<br>\t}<br>        &#47;&#47; 测试<br>\tpublic static void main(String[] args) {<br>\t\tNode[] user_nodes = init(5, 8);<br>\t\tfor (Node d : user_nodes) {<br>\t\t\tSystem.out.println(d.user_id + &quot;:&quot; + d.friends + &quot;:&quot; + d.degrees);<br>\t\t}<br>\t\tSystem.out.println(&quot;-----------------&quot;);<br>\t\tint len = bi_bfs(user_nodes, 0, 1);<br>\t\tSystem.out.println(&quot;距离：&quot; + len);<br>\t}<br>运行结果：<br>0:[2, 3, 4]:{0=0}<br>1:[2, 4]:{1=0}<br>2:[0, 1]:{2=0}<br>3:[0]:{3=0}<br>4:[0, 1]:{4=0}<br>-----------------<br>距离：2<br><br>老师您帮忙看下程序逻辑有没有什么问题，从测试结果来看应该是对的。","like_count":11,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436733,"discussion_content":"逻辑上是对的👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547682550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60599,"user_name":"Being","can_delete":false,"product_type":"c1","uid":1152227,"ip_address":"","ucode":"80A8783927B650","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg","comment_is_top":false,"comment_ctime":1547517856,"is_pvip":false,"replies":[{"id":"21694","content":"是的，规模小不能体现双向优势。另外，如果两个出发点a和b，如果a出发的图平均连接度明显大于b出发的图，那么从b单向广度可能效率更高。","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1547574734,"ip_address":"","comment_id":60599,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44497190816","product_id":100021201,"comment_content":"老师，我理解的双向广度优先搜索，其实重点关注的是两个点之间的联系（最短距离），而不是中间所有的覆盖关系。单向的必然导致大规模的覆盖搜索，像地毯式的，而双向的，不会把面积铺得那么大，在一定范围内找到交集即达到目的。所以也从侧面印证了，当关系网的规模很大的时候，使用双向的搜索覆盖面积必然比单向的小很多，而规模小反而不能体现双向BFS的优势。","like_count":10,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436558,"discussion_content":"是的，规模小不能体现双向优势。另外，如果两个出发点a和b，如果a出发的图平均连接度明显大于b出发的图，那么从b单向广度可能效率更高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547574734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79510,"user_name":"Wing·三金","can_delete":false,"product_type":"c1","uid":1341402,"ip_address":"","ucode":"6B9F5822C3717F","user_header":"https://static001.geekbang.org/account/avatar/00/14/77/da/54c663f3.jpg","comment_is_top":false,"comment_ctime":1553502047,"is_pvip":false,"replies":[{"id":"29212","content":"思考题的思路很好。<br>degree_a和degree_b主要是控制总的度数（也就是max_degree），不要搜索太多。<br><br>至于HashMap，是考虑到了不同节点到出发点的最短距离。","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1553616019,"ip_address":"","comment_id":79510,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27323305823","product_id":100021201,"comment_content":"思考题：能想到的是当 a b 结点的好友数量极度不对称时，单向更快；优化思路是，每一次迭代时比较下一层结点的数量，若是两边的数量级有明显差距（设置个阈值），则优先选择数量级小的一边进行搜索。但这样的做的弊端也很明显——很可能这一边不断往下搜索，但事实上另一边只要往下一层就完事了。所以还需要限制单边【连续优先搜索】的次数。<br><br>提问：老师，您有开头提到需要对 Node 添加一个 degrees 的 HashMap 变量来纪录其他用户结点与 self 的距离，但是后边用到的外部变量 degree_a 事实上就代替了这个功能是吗？<br>另外在实际应用中 max_degree 是设置为树的高度吗，还是可以有其他优化方式？","like_count":6,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444522,"discussion_content":"思考题的思路很好。\ndegree_a和degree_b主要是控制总的度数（也就是max_degree），不要搜索太多。\n\n至于HashMap，是考虑到了不同节点到出发点的最短距离。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553616019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197190,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1585362641,"is_pvip":false,"replies":[{"id":"75060","content":"交替扩展是好思路","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1585630641,"ip_address":"","comment_id":197190,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23060199121","product_id":100021201,"comment_content":"两边平均节点度不均匀时，从节点度小的方向单向查找效率较高。此时如果优化，可以用两边发现的好友数控制，当a的好友数大于b的，把b的好友向外扩展一度，否则扩展a的。这样交替扩展，应该能提高效率","like_count":5,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489471,"discussion_content":"交替扩展是好思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585630641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64618,"user_name":"风轨","can_delete":false,"product_type":"c1","uid":1185844,"ip_address":"","ucode":"7B8A5233B61EB0","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/34/c082419c.jpg","comment_is_top":false,"comment_ctime":1548836379,"is_pvip":false,"replies":[{"id":"22892","content":"考虑到了网络的动态改变，这个思路很赞👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1548868092,"ip_address":"","comment_id":64618,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18728705563","product_id":100021201,"comment_content":"&quot;双向广度优先比单向广度优先更高效&quot;的前提条件是&quot;两个被搜索的节点必须是联通的&quot;如果不是联通的，两个节点都会将他们各自的N度好友都找出来，不如只搜索其中一个；<br>针对这种情况可以维护一个网络分块信息表，每当有连接加入这个网络时检查一下它是否将两个分割的块连接起来了，如果是将这两个块标记为同一个块。在查找的时候就方便了，如果两个节点本身就不在一个块里面，距离直接就是无穷远。但是如果这个网络里面的连接还能删除的话就比较麻烦了，每删除一条边还要检查是否将一个块分割成了两个块，计算量比较大。<br><br>","like_count":4,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438103,"discussion_content":"考虑到了网络的动态改变，这个思路很赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548868092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245596,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/9c/1a750bc7.jpg","nickname":"l c","note":"","ucode":"7D43CC471595EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288861,"discussion_content":"这也就是并查集的基本思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593913950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203263,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1586162716,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"10176097308","product_id":100021201,"comment_content":"茶艺师学编程<br><br>今天说到的双向广度优先搜索，其中的思想在信息论中也有应用，就是正交信息，其大体意思为<br><br>用不同纬度的信息能很好地消除不确定性，如果信息是正交的，效果最好。<br><br>这好比如，在医院看病，医生一般会请你做血项检验和医学影像扫描，这两组不同纬度的信息（检查结果）组合起来用，医生对你身体出了什么问题有整体的把握（虽然这被大家诟病为“乱检查”）。但如果一个医生开出了CT扫描+核磁共振，大家都是同一纬度的，前面的CT扫描就等于白做了。<br><br>而这样的思想，其实我们还在学生时代就已经实践过了，那就是考试前老师一再重复强调的，“检查题目的时候，要换个思路（方法）来。”<br><br>考试的题目肯定存在不同的解法。但是任意的集合A和集合B有没有交集，交集大不大，在一开始的时候是不清楚的，因此在这时候就使用双向广度优先搜索，我觉得这大神心里是有把握的，他对将要处理数据有大体的认识。","like_count":2},{"had_liked":false,"id":175555,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1580742795,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5875710091","product_id":100021201,"comment_content":"深度优先搜索占用空间少，但是速度比较慢；广度优先搜索占用空间多，但是运行速度快，属于空间换时间吧。进一步，双向广度优先搜索，似乎也是用了更多的空间，来换取搜索效率。<br><br>对于后来那个聚类的例子，我有点不理解，感觉更多的时采用了剪枝的思路，和双向广度优先搜索好像没什么关系，当然也可以说是把之前的深度优先搜索，改为了广度优先同时剪枝。<br><br>对于思考题，在需要列举全部好友关系的情况下，以及在树的分叉比较多的情况下，似乎单向广度优先搜索的效率更高，主要是因为减少了比对的复杂性。<br><br>看了一下回复里面的答案，说是在 a 和 b 好友分布不均匀的情况下，从好友少的一段开始单向广度搜索，效果更好。<br><br>学习了 @菩提 的 Java 代码 和 @qinggeouye 的 Python 代码","like_count":1},{"had_liked":false,"id":170035,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1578495360,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5873462656","product_id":100021201,"comment_content":"不好意思，把 12 课的留言贴到 14 课这里了，请老师忽略","like_count":1},{"had_liked":false,"id":169017,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1578238174,"is_pvip":false,"replies":[{"id":"65858","content":"这个想法很好，确实可行👍","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1578427207,"ip_address":"","comment_id":169017,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873205470","product_id":100021201,"comment_content":"思考题：个人理解，当待查的两个结点相距较远，且各自都有大量好友时，则每往前搜索一步，判断两者好友的交集效率会非常低，即hasOverlap函数的效率会非常低。改进的方法，是否可考虑共用一个visited表，可以采用hash表存贮，存贮好友结点时，连同源节点的标识符（即待查的两个结点）一起存入，当发现结点存贮有冲突，且冲突的两个结点的源结点标识符不一致，则说明发现了两个待查结点的共同好友。<br><br>以上是个人一点肤浅理解，请老师指正。","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480403,"discussion_content":"这个想法很好，确实可行👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578427207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70499,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1551107802,"is_pvip":false,"replies":[{"id":"25371","content":"思路是对的，使用set实现代码也很简洁","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1551202809,"ip_address":"","comment_id":70499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846075098","product_id":100021201,"comment_content":"https:&#47;&#47;github.com&#47;qinggeouye&#47;GeekTime&#47;blob&#47;master&#47;MathematicProgrammer&#47;14_breadthFirstSearch&#47;lesson14_1.py<br><br>两个预留方法的 python 实现：<br><br>get_next_degree_friend(user_nodes, que, visited) 去掉了 user_id_a 和 degree_a 两个参数。<br>如果把 user_id_a 看作圆心，它的一度好友看作第一层节点，二度好友看作第二层节点 .... ，que 队列只保留某一层的节点即可，visited 仍保存所有访问过的节点。<br><br>def get_next_degree_friend(user_nodes, que, visited):<br>    &quot;&quot;&quot;<br>    :param user_nodes: 用户节点网络<br>    :param que: 某一层用户节点 即第几度好友<br>    :param visited: 已访问的所有用户节点<br>    :return:<br>    &quot;&quot;&quot;<br>    que_return = queue.Queue()  # 只保存某个用户的第几度好友<br>    visited_return = set()  # 保存从某个用户开始到第几度好友<br>    while not que.empty():<br>        current_user_id = que.get()<br>        if user_nodes[current_user_id] is None:<br>            continue<br>        for friend_id in user_nodes[current_user_id].friends:<br>            if user_nodes[friend_id] is None:<br>                continue<br>            if friend_id in visited:<br>                continue<br>            que_return.put(friend_id)<br>            visited_return.add(friend_id)  # 记录已经访问过的节点<br>    return que_return, visited_return<br><br>def has_overlap(visited_a, visited_b):<br>    # 两个 set() 的交集<br>    return len(visited_a &amp; visited_b) &gt; 0<br><br>#测试结果：<br>if __name__ == &quot;__main__&quot;:<br>    user_nodes_list = set_user_relation(10, 20)<br>    for i in range(len(user_nodes_list)):<br>        print(&quot;用户 %s 的好友: %s&quot; % (user_nodes_list[i].user_id, user_nodes_list[i].friends))<br>    print(&quot;---------双向广度优先搜索---------&quot;)<br>    print(&quot;两个用户节点 1和2 之间的最短路径长度：&quot;, bi_bfs(user_nodes_list, 1, 2))<br><br>用户 0 的好友: {8, 2, 3, 6}<br>用户 1 的好友: {8, 3, 5}<br>用户 2 的好友: {0, 4}<br>用户 3 的好友: {0, 1, 4, 5, 8, 9}<br>用户 4 的好友: {2, 3}<br>用户 5 的好友: {9, 3, 6, 1}<br>用户 6 的好友: {0, 8, 5}<br>用户 7 的好友: {9}<br>用户 8 的好友: {0, 1, 3, 6, 9}<br>用户 9 的好友: {8, 3, 5, 7}<br>---------双向广度优先搜索---------<br>两个用户节点 1和2 之间的最短路径长度： 3","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440667,"discussion_content":"思路是对的，使用set实现代码也很简洁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551202809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62931,"user_name":"Joe","can_delete":false,"product_type":"c1","uid":1337998,"ip_address":"","ucode":"EC76699640B7BF","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/8e/7b6ea886.jpg","comment_is_top":false,"comment_ctime":1548209188,"is_pvip":false,"replies":[{"id":"22356","content":"计算“公司”那一层是，一开始还是需要100 * 5个计数器，之后才会取前1个，也就是100*1。对于“同事”那一层同理","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1548272536,"ip_address":"","comment_id":62931,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843176484","product_id":100021201,"comment_content":"最后一个图没有看明白，图和计算结果对不上吧。不应该是5000+100+100+300吧","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437408,"discussion_content":"计算“公司”那一层是，一开始还是需要100 * 5个计数器，之后才会取前1个，也就是100*1。对于“同事”那一层同理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548272536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62536,"user_name":"蒋宏伟","can_delete":false,"product_type":"c1","uid":1088541,"ip_address":"","ucode":"02226CABD5ECE7","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","comment_is_top":false,"comment_ctime":1548084809,"is_pvip":false,"replies":[{"id":"22152","content":"后面会整理代码的Github，供大家参考","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1548121881,"ip_address":"","comment_id":62536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843052105","product_id":100021201,"comment_content":"代码布局有些错乱","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437251,"discussion_content":"后面会整理代码的Github，供大家参考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548121881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60557,"user_name":"草原上的奔跑","can_delete":false,"product_type":"c1","uid":1120348,"ip_address":"","ucode":"D69C617F767736","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/5c/1a58e8f6.jpg","comment_is_top":false,"comment_ctime":1547512355,"is_pvip":false,"replies":[{"id":"21693","content":"对，前提要连通，否则就无解了。编码的时候可以加个判断，路径长度是否已经超出一个的阈值，或者是否有新的结点发现，可以防止代码在两者不连通的情况下，陷入死循环。","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1547574590,"ip_address":"","comment_id":60557,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5842479651","product_id":100021201,"comment_content":"双向广度优先搜索应该是两个点要联通吧，感觉这是一个前提条件。图论这块内容，已经触及到我的盲区了，但是建立在这之上的内容很重要，深度搜索和广度搜索都是向一个资深程序员迈进要走的路。虽然走的时候很痛苦，但依然坚持，我喜欢看到路尽头的彩虹。","like_count":1,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436538,"discussion_content":"对，前提要连通，否则就无解了。编码的时候可以加个判断，路径长度是否已经超出一个的阈值，或者是否有新的结点发现，可以防止代码在两者不连通的情况下，陷入死循环。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547574590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352847,"user_name":"013923","can_delete":false,"product_type":"c1","uid":3035193,"ip_address":"陕西","ucode":"1214DAADBCA848","user_header":"","comment_is_top":false,"comment_ctime":1658979698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658979698","product_id":100021201,"comment_content":"谢谢！","like_count":0},{"had_liked":false,"id":268625,"user_name":"凹凸鸿","can_delete":false,"product_type":"c1","uid":1915334,"ip_address":"","ucode":"A458BAEBF314B2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/c6/1e12f271.jpg","comment_is_top":false,"comment_ctime":1608277490,"is_pvip":false,"replies":[{"id":"97576","content":"个人觉得哈希、缓存、数据库索引等基本技术都是可以考虑的。另外，我们还需要考虑应用和数据的特性，看看哪种技术才或者哪些技术的结合，才是最适合的","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1608506186,"ip_address":"","comment_id":268625,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608277490","product_id":100021201,"comment_content":"老师，上亿级别数据的项目数据库要怎么设计？怎么做到查询最优，现在一个400万数据的表查询花了30秒","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511991,"discussion_content":"个人觉得哈希、缓存、数据库索引等基本技术都是可以考虑的。另外，我们还需要考虑应用和数据的特性，看看哪种技术才或者哪些技术的结合，才是最适合的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608506186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267372,"user_name":"凹凸鸿","can_delete":false,"product_type":"c1","uid":1915334,"ip_address":"","ucode":"A458BAEBF314B2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/c6/1e12f271.jpg","comment_is_top":false,"comment_ctime":1607697410,"is_pvip":false,"replies":[{"id":"97155","content":"这里只是举一个例子，并非和前图对应","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1607793842,"ip_address":"","comment_id":267372,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607697410","product_id":100021201,"comment_content":"比如说，当前结点是 4，从结点 1 到结点 4 是 3 度，结点 2 到结点 4 是 2 度，结点 3 到结点 4 是 4 度---节点3到节点4为什么是4度？","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511619,"discussion_content":"这里只是举一个例子，并非和前图对应","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607793842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267370,"user_name":"凹凸鸿","can_delete":false,"product_type":"c1","uid":1915334,"ip_address":"","ucode":"A458BAEBF314B2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/c6/1e12f271.jpg","comment_is_top":false,"comment_ctime":1607697301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607697301","product_id":100021201,"comment_content":"比如说，当前结点是 4，从结点 1 到结点 4 是 3 度，结点 2 到结点 4 是 2 度，结点 3 到结点 4 是 4 度","like_count":0},{"had_liked":false,"id":188756,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1584411982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584411982","product_id":100021201,"comment_content":"&lt;?php<br>&#47;&#47; 用户节点相关类<br>class Node {<br>\tpublic $user_id;&#47;&#47; 用户id<br>\tpublic $friends = []; &#47;&#47; 朋友节点id<br>\tpublic $degree_a;&#47;&#47; 与a好友度数<br>\tpublic $degree_b;&#47;&#47; 与b好友度数<br>\tpublic function __construct($user_id) {<br>\t\t$this-&gt;user_id = $user_id;<br>\t\t$this-&gt;degree_a = 0;<br>\t\t$this-&gt;degree_b = 0;<br>\t}<br>}<br>&#47;**<br> * 双向广度优先搜索<br> *&#47;<br>function bi_bfs($user_nodes,$user_id_a,$user_id_b) {<br>\tif(empty($user_nodes[$user_id_a]) || empty($user_nodes[$user_id_b])) { &#47;&#47; a b 中某一用户不存在<br>\t\treturn -1;<br>\t}<br>\tif ($user_id_a == $user_id_b) return 0;    &#47;&#47; 两个用户是同一人，直接返回0<br>\t$queueArr_a = [];<br>\t$queueArr_b = [];<br>\t$visited_a = [];&#47;&#47; 存放已经访问过的节点<br>\t$visited_b = [];&#47;&#47; 存放已经访问过的节点<br>\t$visited_a[] = $user_id_a; <br>\t$visited_b[] = $user_id_b;<br>\t$degree_a = 0;<br>\t$degree_b = 0;<br>\t$max_degree = 20;&#47;&#47; max_degree的设置，防止两者之间不存在通路的情况<br>\tarray_push($queueArr_a,$user_id_a);<br>\tarray_push($queueArr_b,$user_id_b);<br>\t<br>\twhile ($degree_a + $degree_b &lt; $max_degree) {<br>\t\t$degree_a++;<br>\t\t$queueArr_a_friends = [];<br>\t\t$queueArr_b_friends = [];<br>\t\t<br>\t\t&#47;&#47; 先从a方向广度优先搜索<br>\t\t$queueArr_a_friends = getNextDegreeFriend($user_id_a,$user_nodes,<br>\t\t\t$queueArr_a,$queueArr_a_friends,$visited_a,1);<br>\t\t<br>\t\t&#47;&#47; 处理完所有当前层好友 判断与b的搜索结果中有没有交集<br>\t\tif (hasOverlap($visited_a, $visited_b)){<br>\t\t\treturn ($degree_a + $degree_b);<br>\t\t} else {<br>\t\t\t$queueArr_a = $queueArr_a_friends;<br>\t\t}<br>\t\t$degree_b++;<br>\t\t&#47;&#47; 先从b方向广度优先搜索<br>\t\t$queueArr_b_friends = getNextDegreeFriend($user_id_b,$user_nodes,<br>\t\t\t$queueArr_b,$queueArr_b_friends,$visited_b,0);<br>\t\t<br>\t\t&#47;&#47; 处理完所有当前层好友 判断与b的搜索结果中有没有交集<br>\t\tif (hasOverlap($visited_a, $visited_b)){<br>\t\t\treturn ($degree_a + $degree_b);<br>\t\t} else {<br>\t\t\t$queueArr_b = $queueArr_b_friends;<br>\t\t}<br>\t\t<br>\t}<br>}","like_count":0},{"had_liked":false,"id":170033,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1578495235,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1578495235","product_id":100021201,"comment_content":"在数学课里面看到关于用数据结构表达树，还是感觉有点奇怪，不过作者给出的 TreeNode 应该算是比较经典的一种，学习了。我觉的前缀树里面 prefix 和 label 的设计，很有想法，可以很方便的做前缀树的搜索，以前可能是忽略了这一部分。<br><br>使用 TreeNode 和 Stack 实现深度优先搜索，还是比较巧妙的，虽然也许递归的写法看上去会更简单一些。<br><br>使用临时栈来保证子节点的访问顺序和递归遍历时的访问顺序一致，也是一个比较有意思的地方。<br><br>自己用代码实现比较困难，所以还是学习了留言中的代码，其中 @qinggeouye 的 Python 代码最为漂亮，感谢。<br><br>如果在图中进行深度优先搜索，一个是要记录走过的节点，另外一个就是可能没有办法保障第一次就走完最长的路线，因为所有的点都是平级的，没有父子关系。所以，对图来说，是不是没有深度优先和广度优先的说法，只有遍历而已。","like_count":0},{"had_liked":false,"id":167653,"user_name":"cwtxz","can_delete":false,"product_type":"c1","uid":1778151,"ip_address":"","ucode":"4F35AEDB8F5D5D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BAuQlia9Dc07m3icOkibIqu2lhbnLD6cjgCNE8FSzG5Aj4cd26eRgspicTsWvA7WK1ftlQBD34PYRucZRXML5FA27A/132","comment_is_top":false,"comment_ctime":1577887271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577887271","product_id":100021201,"comment_content":"说实话，从事编程这项工作有些年头了，由于业务需要，自己也时常会利用一些可与时间来学习研究基本的数据结构与算法。从最开始的数组、栈、队列到后面稍微复杂的链表、字典、散列表，这些线性的数据结构于我而言都还算可以快速理解、上手并加以实践，但是一旦开始进入树与图的学习，学习难度呈集合级数上升，学习起这些非线性的数据结构真是让我一个头两个大，学习起来特别吃力，很多算法实在是想不出来，只好囫囵吞枣地把它给记住，我知道这样不好，但是，没办法，我实在是无法理解。学习了老师的“树的优先搜索”这几章的内容，似乎有种豁然开朗的感觉，困扰我许久的问题现在也能想通了，说明老师讲得实在很棒!!!","like_count":0},{"had_liked":false,"id":159124,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1575542396,"is_pvip":false,"replies":[{"id":"60883","content":"是的","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1575573478,"ip_address":"","comment_id":159124,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575542396","product_id":100021201,"comment_content":"度数小的情况，单向广度优先更有效","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476958,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575573478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144384,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1571907999,"is_pvip":true,"replies":[{"id":"55792","content":"从数量级来看是相同的，但是实际差别还是很大","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1572023591,"ip_address":"","comment_id":144384,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571907999","product_id":100021201,"comment_content":"感觉单向可以看作O(n^2)指数级别的增长  双向的更趋近于O(2*n)的增长","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471914,"discussion_content":"从数量级来看是相同的，但是实际差别还是很大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572023591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62668,"user_name":"🌞🇨🇳👦","can_delete":false,"product_type":"c1","uid":1168085,"ip_address":"","ucode":"6BB08F05546D06","user_header":"https://static001.geekbang.org/account/avatar/00/11/d2/d5/ed93f2fa.jpg","comment_is_top":false,"comment_ctime":1548126949,"is_pvip":false,"replies":[{"id":"22219","content":"很好的观察👍 这样确实可以在实现的时候进行优化","user_name":"作者回复","user_name_real":"黄申","uid":"1275061","ctime":1548170888,"ip_address":"","comment_id":62668,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548126949","product_id":100021201,"comment_content":"文中描述交替看两边是否有交集的段落，b,b{1}是否出现在a,a{1},a{2}，是不是没有必要呢，因为前面已经判断了a,a{1}不在b,b{1}的并集中，是不是只需判断b,b{1}是否出现在a{2}即可","like_count":0,"discussions":[{"author":{"id":1275061,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/b5/b68e3740.jpg","nickname":"黄申","note":"","ucode":"EE9AC074A322FF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437297,"discussion_content":"很好的观察👍 这样确实可以在实现的时候进行优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548170888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}