{"id":100861,"title":"11 | 答疑课堂：深入了解NIO的优化实现原理","content":"<p>你好，我是刘超。专栏上线已经有20多天的时间了，首先要感谢各位同学的积极留言，交流的过程使我也收获良好。</p><p>综合查看完近期的留言以后，我的第一篇答疑课堂就顺势诞生了。我将继续讲解I/O优化，对大家在08讲中提到的内容做重点补充，并延伸一些有关I/O的知识点，更多结合实际场景进行分享。话不多说，我们马上切入正题。</p><p>Tomcat中经常被提到的一个调优就是修改线程的I/O模型。<span class=\"orange\">Tomcat 8.5版本之前，默认情况下使用的是BIO线程模型，如果在高负载、高并发的场景下，可以通过设置NIO线程模型，来提高系统的网络通信性能。</span></p><p>我们可以通过一个性能对比测试来看看在高负载或高并发的情况下，BIO和NIO通信性能（这里用页面请求模拟多I/O读写操作的请求）：</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/4a/3e66a63ce9f0d9722005f78fa960244a.png?wh=934*518\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/3e/74/3e1d942b7e5e09ad6e4757b8d5cbe274.png?wh=935*521\" alt=\"\"></p><p><strong>测试结果：Tomcat在I/O读写操作比较多的情况下，使用NIO线程模型有明显的优势。</strong></p><p>Tomcat中看似一个简单的配置，其中却包含了大量的优化升级知识点。下面我们就从底层的网络I/O模型优化出发，再到内存拷贝优化和线程模型优化，深入分析下Tomcat、Netty等通信框架是如何通过优化I/O来提高系统性能的。</p><h2>网络I/O模型优化</h2><p>网络通信中，最底层的就是内核中的网络I/O模型了。随着技术的发展，操作系统内核的网络模型衍生出了五种I/O模型，《UNIX网络编程》一书将这五种I/O模型分为阻塞式I/O、非阻塞式I/O、I/O复用、信号驱动式I/O和异步I/O。每一种I/O模型的出现，都是基于前一种I/O模型的优化升级。</p><!-- [[[read_end]]] --><p>最开始的阻塞式I/O，它在每一个连接创建时，都需要一个用户线程来处理，并且在I/O操作没有就绪或结束时，线程会被挂起，进入阻塞等待状态，阻塞式I/O就成为了导致性能瓶颈的根本原因。</p><p><strong>那阻塞到底发生在套接字（socket）通信的哪些环节呢？</strong></p><p>在《Unix网络编程》中，套接字通信可以分为流式套接字（TCP）和数据报套接字（UDP）。其中TCP连接是我们最常用的，一起来了解下TCP服务端的工作流程（由于TCP的数据传输比较复杂，存在拆包和装包的可能，这里我只假设一次最简单的TCP数据传输）：</p><p><img src=\"https://static001.geekbang.org/resource/image/33/41/3310cc063aaf19f2aeb9ea5bc3188e41.jpg?wh=1042*1292\" alt=\"\"></p><ul>\n<li>首先，应用程序通过系统调用socket创建一个套接字，它是系统分配给应用程序的一个文件描述符；</li>\n<li>其次，应用程序会通过系统调用bind，绑定地址和端口号，给套接字命名一个名称；</li>\n<li>然后，系统会调用listen创建一个队列用于存放客户端进来的连接；</li>\n<li>最后，应用服务会通过系统调用accept来监听客户端的连接请求。</li>\n</ul><p>当有一个客户端连接到服务端之后，服务端就会调用fork创建一个子进程，通过系统调用read监听客户端发来的消息，再通过write向客户端返回信息。</p><h3>1.阻塞式I/O</h3><p>在整个socket通信工作流程中，socket的默认状态是阻塞的。也就是说，当发出一个不能立即完成的套接字调用时，其进程将被阻塞，被系统挂起，进入睡眠状态，一直等待相应的操作响应。从上图中，我们可以发现，可能存在的阻塞主要包括以下三种。</p><p><strong>connect阻塞</strong>：当客户端发起TCP连接请求，通过系统调用connect函数，TCP连接的建立需要完成三次握手过程，客户端需要等待服务端发送回来的ACK以及SYN信号，同样服务端也需要阻塞等待客户端确认连接的ACK信号，这就意味着TCP的每个connect都会阻塞等待，直到确认连接。</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/c9/2a208cf7dddf18d2fe813b75ef2f4ac9.png?wh=1143*640\" alt=\"\"></p><p><strong>accept阻塞</strong>：一个阻塞的socket通信的服务端接收外来连接，会调用accept函数，如果没有新的连接到达，调用进程将被挂起，进入阻塞状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/96/3fc5ef2eb6e594fd7d5cbc358cd5dd96.png?wh=1142*640\" alt=\"\"></p><p><strong>read、write阻塞</strong>：当一个socket连接创建成功之后，服务端用fork函数创建一个子进程， 调用read函数等待客户端的数据写入，如果没有数据写入，调用子进程将被挂起，进入阻塞状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/e1/cf/e14386a357185acc39fdc708fb3692cf.png?wh=1142*640\" alt=\"\"></p><h3>2.非阻塞式I/O</h3><p><span class=\"orange\">使用fcntl可以把以上三种操作都设置为非阻塞操作。</span>如果没有数据返回，就会直接返回一个EWOULDBLOCK或EAGAIN错误，此时进程就不会一直被阻塞。</p><p>当我们把以上操作设置为了非阻塞状态，我们需要设置一个线程对该操作进行轮询检查，这也是最传统的非阻塞I/O模型。</p><p><img src=\"https://static001.geekbang.org/resource/image/ec/62/ec2ec7914b3b86a1965dc98a830a3a62.png?wh=1142*640\" alt=\"\"></p><h3>3. I/O复用</h3><p>如果使用用户线程轮询查看一个I/O操作的状态，在大量请求的情况下，这对于CPU的使用率无疑是种灾难。 那么除了这种方式，还有其它方式可以实现非阻塞I/O套接字吗？</p><p>Linux提供了I/O复用函数select/poll/epoll，进程将一个或多个读操作通过系统调用函数，阻塞在函数操作上。这样，系统内核就可以帮我们侦测多个读操作是否处于就绪状态。</p><p><strong>select()函数</strong>：它的用途是，在超时时间内，监听用户感兴趣的文件描述符上的可读可写和异常事件的发生。Linux 操作系统的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个文件描述符（fd）。</p><pre><code> int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)\n</code></pre><p>查看以上代码，select() 函数监视的文件描述符分3类，分别是writefds（写文件描述符）、readfds（读文件描述符）以及exceptfds（异常事件文件描述符）。</p><p>调用后select() 函数会阻塞，直到有描述符就绪或者超时，函数返回。当select函数返回后，可以通过函数FD_ISSET遍历fdset，来找到就绪的描述符。fd_set可以理解为一个集合，这个集合中存放的是文件描述符，可通过以下四个宏进行设置：</p><pre><code>\n          void FD_ZERO(fd_set *fdset);           //清空集合\n          void FD_SET(int fd, fd_set *fdset);   //将一个给定的文件描述符加入集合之中\n          void FD_CLR(int fd, fd_set *fdset);   //将一个给定的文件描述符从集合中删除\n          int FD_ISSET(int fd, fd_set *fdset);   // 检查集合中指定的文件描述符是否可以读写 \n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/d8/dd/d8f4a9cfb8d37d08487a68fc10e31fdd.png?wh=1142*640\" alt=\"\"></p><p><strong>poll()函数</strong>：在每次调用select()函数之前，系统需要把一个fd从用户态拷贝到内核态，这样就给系统带来了一定的性能开销。再有单个进程监视的fd数量默认是1024，我们可以通过修改宏定义甚至重新编译内核的方式打破这一限制。但由于fd_set是基于数组实现的，在新增和删除fd时，数量过大会导致效率降低。</p><p>poll() 的机制与 select() 类似，二者在本质上差别不大。poll() 管理多个描述符也是通过轮询，根据描述符的状态进行处理，但 poll() 没有最大文件描述符数量的限制。</p><p>poll() 和 select() 存在一个相同的缺点，那就是包含大量文件描述符的数组被整体复制到用户态和内核的地址空间之间，而无论这些文件描述符是否就绪，他们的开销都会随着文件描述符数量的增加而线性增大。</p><p><img src=\"https://static001.geekbang.org/resource/image/54/db/54d775cf7df756672b23a1853441d3db.png?wh=1142*640\" alt=\"\"></p><p><strong>epoll()函数</strong>：select/poll是顺序扫描fd是否就绪，而且支持的fd数量不宜过大，因此它的使用受到了一些制约。</p><p>Linux在2.6内核版本中提供了一个epoll调用，epoll使用事件驱动的方式代替轮询扫描fd。epoll事先通过epoll_ctl()来注册一个文件描述符，将文件描述符存放到内核的一个事件表中，这个事件表是基于红黑树实现的，所以在大量I/O请求的场景下，插入和删除的性能比select/poll的数组fd_set要好，因此epoll的性能更胜一筹，而且不会受到fd数量的限制。</p><pre><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event event)\n\n</code></pre><p><strong>通过以上代码，我们可以看到：</strong>epoll_ctl()函数中的epfd是由 epoll_create()函数生成的一个epoll专用文件描述符。op代表操作事件类型，fd表示关联文件描述符，event表示指定监听的事件类型。</p><p>一旦某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知，之后进程将完成相关I/O操作。</p><pre><code>int epoll_wait(int epfd, struct epoll_event events,int maxevents,int timeout)\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/36/7a/36ee4e180cb6bb4f1452c0bafbe6f37a.png?wh=1142*640\" alt=\"\"></p><h3>4.信号驱动式I/O</h3><p>信号驱动式I/O类似观察者模式，内核就是一个观察者，信号回调则是通知。用户进程发起一个I/O请求操作，会通过系统调用sigaction函数，给对应的套接字注册一个信号回调，此时不阻塞用户进程，进程会继续工作。当内核数据就绪时，内核就为该进程生成一个SIGIO信号，通过信号回调通知进程进行相关I/O操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/1f/4c897ce649d3deb609a4f0a9ba7aee1f.png?wh=749*411\" alt=\"\"></p><p><span class=\"orange\">信号驱动式I/O相比于前三种I/O模式，实现了在等待数据就绪时，进程不被阻塞，主循环可以继续工作，所以性能更佳。</span></p><p>而由于TCP来说，信号驱动式I/O几乎没有被使用，这是因为SIGIO信号是一种Unix信号，信号没有附加信息，如果一个信号源有多种产生信号的原因，信号接收者就无法确定究竟发生了什么。而 TCP socket生产的信号事件有七种之多，这样应用程序收到 SIGIO，根本无从区分处理。</p><p>但信号驱动式I/O现在被用在了UDP通信上，我们从10讲中的UDP通信流程图中可以发现，UDP只有一个数据请求事件，这也就意味着在正常情况下UDP进程只要捕获SIGIO信号，就调用recvfrom读取到达的数据报。如果出现异常，就返回一个异常错误。比如，NTP服务器就应用了这种模型。</p><h3>5.异步I/O</h3><p>信号驱动式I/O虽然在等待数据就绪时，没有阻塞进程，但在被通知后进行的I/O操作还是阻塞的，进程会等待数据从内核空间复制到用户空间中。而异步I/O则是实现了真正的非阻塞I/O。</p><p>当用户进程发起一个I/O请求操作，系统会告知内核启动某个操作，并让内核在整个操作完成后通知进程。这个操作包括等待数据就绪和数据从内核复制到用户空间。由于程序的代码复杂度高，调试难度大，且支持异步I/O的操作系统比较少见（目前Linux暂不支持，而Windows已经实现了异步I/O），所以在实际生产环境中很少用到异步I/O模型。</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/c0/dd4b03afb56a3b7660794ce11fc421c0.png?wh=1142*640\" alt=\"\"></p><p>在08讲中，我讲到了NIO使用I/O复用器Selector实现非阻塞I/O，<span class=\"orange\">Selector就是使用了这五种类型中的I/O复用模型。</span>Java中的Selector其实就是select/poll/epoll的外包类。</p><p>我们在上面的TCP通信流程中讲到，Socket通信中的conect、accept、read以及write为阻塞操作，在Selector中分别对应SelectionKey的四个监听事件OP_ACCEPT、OP_CONNECT、OP_READ以及OP_WRITE。</p><p><img src=\"https://static001.geekbang.org/resource/image/85/96/85bcacec92e74c5cb6d6a39669e0d896.png?wh=648*253\" alt=\"\"></p><p>在NIO服务端通信编程中，首先会创建一个Channel，用于监听客户端连接；接着，创建多路复用器Selector，并将Channel注册到Selector，程序会通过Selector来轮询注册在其上的Channel，当发现一个或多个Channel处于就绪状态时，返回就绪的监听事件，最后程序匹配到监听事件，进行相关的I/O操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/15/e27534c5a157d0908d51b806919b1515.jpg?wh=1095*676\" alt=\"\"></p><p>在创建Selector时，程序会根据操作系统版本选择使用哪种I/O复用函数。在JDK1.5版本中，如果程序运行在Linux操作系统，且内核版本在2.6以上，NIO中会选择epoll来替代传统的select/poll，这也极大地提升了NIO通信的性能。</p><p><span class=\"orange\">由于信号驱动式I/O对TCP通信的不支持，以及异步I/O在Linux操作系统内核中的应用还不大成熟，大部分框架都还是基于I/O复用模型实现的网络通信。</span></p><h2>零拷贝</h2><p>在I/O复用模型中，执行读写I/O操作依然是阻塞的，在执行读写I/O操作时，存在着多次内存拷贝和上下文切换，给系统增加了性能开销。</p><p>零拷贝是一种避免多次内存复制的技术，用来优化读写I/O操作。</p><p>在网络编程中，通常由read、write来完成一次I/O读写操作。每一次I/O读写操作都需要完成四次内存拷贝，路径是I/O设备-&gt;内核空间-&gt;用户空间-&gt;内核空间-&gt;其它I/O设备。</p><p><span class=\"orange\">Linux内核中的mmap函数可以代替read、write的I/O读写操作，实现用户空间和内核空间共享一个缓存数据。</span>mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理内存地址。这种方式避免了内核空间与用户空间的数据交换。I/O复用中的epoll函数中就是使用了mmap减少了内存拷贝。</p><p>在Java的NIO编程中，则是使用到了Direct Buffer来实现内存的零拷贝。Java直接在JVM内存空间之外开辟了一个物理内存空间，这样内核和用户进程都能共享一份缓存数据。这是在08讲中已经详细讲解过的内容，你可以再去回顾下。</p><h2>线程模型优化</h2><p>除了内核对网络I/O模型的优化，NIO在用户层也做了优化升级。NIO是基于事件驱动模型来实现的I/O操作。Reactor模型是同步I/O事件处理的一种常见模型，其核心思想是将I/O事件注册到多路复用器上，一旦有I/O事件触发，多路复用器就会将事件分发到事件处理器中，执行就绪的I/O事件操作。<strong>该模型有以下三个主要组件：</strong></p><ul>\n<li>事件接收器Acceptor：主要负责接收请求连接；</li>\n<li>事件分离器Reactor：接收请求后，会将建立的连接注册到分离器中，依赖于循环监听多路复用器Selector，一旦监听到事件，就会将事件dispatch到事件处理器；</li>\n<li>事件处理器Handlers：事件处理器主要是完成相关的事件处理，比如读写I/O操作。</li>\n</ul><h3>1.单线程Reactor线程模型</h3><p>最开始NIO是基于单线程实现的，所有的I/O操作都是在一个NIO线程上完成。由于NIO是非阻塞I/O，理论上一个线程可以完成所有的I/O操作。</p><p>但NIO其实还不算真正地实现了非阻塞I/O操作，因为读写I/O操作时用户进程还是处于阻塞状态，这种方式在高负载、高并发的场景下会存在性能瓶颈，一个NIO线程如果同时处理上万连接的I/O操作，系统是无法支撑这种量级的请求的。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/f8/29b117cb60bcc8edd6d1fa21981fb9f8.png?wh=1800*640\" alt=\"\"></p><h3>2.多线程Reactor线程模型</h3><p>为了解决这种单线程的NIO在高负载、高并发场景下的性能瓶颈，后来使用了线程池。</p><p>在Tomcat和Netty中都使用了一个Acceptor线程来监听连接请求事件，当连接成功之后，会将建立的连接注册到多路复用器中，一旦监听到事件，将交给Worker线程池来负责处理。大多数情况下，这种线程模型可以满足性能要求，但如果连接的客户端再上一个量级，一个Acceptor线程可能会存在性能瓶颈。</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/82/0de0c467036f2973143a620448068a82.png?wh=1767*640\" alt=\"\"></p><h3>3.主从Reactor线程模型</h3><p>现在主流通信框架中的NIO通信框架都是基于主从Reactor线程模型来实现的。在这个模型中，Acceptor不再是一个单独的NIO线程，而是一个线程池。Acceptor接收到客户端的TCP连接请求，建立连接之后，后续的I/O操作将交给Worker I/O线程。</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/0a/f9d03620ae5c7c82c83f522710a62a0a.png?wh=1800*640\" alt=\"\"></p><h3>基于线程模型的Tomcat参数调优</h3><p>Tomcat中，BIO、NIO是基于主从Reactor线程模型实现的。</p><p><strong>在BIO中，</strong>Tomcat中的Acceptor只负责监听新的连接，一旦连接建立监听到I/O操作，将会交给Worker线程中，Worker线程专门负责I/O读写操作。</p><p><strong>在NIO中，</strong>Tomcat新增了一个Poller线程池，Acceptor监听到连接后，不是直接使用Worker中的线程处理请求，而是先将请求发送给了Poller缓冲队列。在Poller中，维护了一个Selector对象，当Poller从队列中取出连接后，注册到该Selector中；然后通过遍历Selector，找出其中就绪的I/O操作，并使用Worker中的线程处理相应的请求。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/ba/136315be52782bd88056fb28f3ec60ba.png?wh=1028*229\" alt=\"\"></p><p><span class=\"orange\">你可以通过以下几个参数来设置Acceptor线程池和Worker线程池的配置项。</span></p><p><strong>acceptorThreadCount：</strong>该参数代表Acceptor的线程数量，在请求客户端的数据量非常巨大的情况下，可以适当地调大该线程数量来提高处理请求连接的能力，默认值为1。</p><p><strong>maxThreads：</strong>专门处理I/O操作的Worker线程数量，默认是200，可以根据实际的环境来调整该参数，但不一定越大越好。</p><p><strong>acceptCount：</strong>Tomcat的Acceptor线程是负责从accept队列中取出该connection，然后交给工作线程去执行相关操作，这里的acceptCount指的是accept队列的大小。</p><p>当Http关闭keep alive，在并发量比较大时，可以适当地调大这个值。而在Http开启keep alive时，因为Worker线程数量有限，Worker线程就可能因长时间被占用，而连接在accept队列中等待超时。如果accept队列过大，就容易浪费连接。</p><p><strong>maxConnections：</strong>表示有多少个socket连接到Tomcat上。在BIO模式中，一个线程只能处理一个连接，一般maxConnections与maxThreads的值大小相同；在NIO模式中，一个线程同时处理多个连接，maxConnections应该设置得比maxThreads要大的多，默认是10000。</p><p><span class=\"orange\">今天的内容比较多，看到这里不知道你消化得如何？如果还有疑问，请在留言区中提出，我们共同探讨。</span>最后欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他加入讨论。</p><p></p>","comments":[{"had_liked":false,"id":103250,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1560403707,"is_pvip":false,"replies":[{"id":"37493","content":"理解正确，赞一个","user_name":"作者回复","comment_id":103250,"uid":"1228576","ip_address":"","utype":1,"ctime":1560479210,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"100344651515","product_id":100028001,"comment_content":"老师好!万分感觉，写的非常非常好谢谢。不过开心的同时，好多没看懂:-(先讲下我的理解吧。<br>阻塞IO:调用read()线程阻塞了<br>非阻塞IO:调用read()马上拿到一个数据未就绪，或者就绪。<br>I&#47;O多路复用:selector线程阻塞，channel非阻塞，用阻塞一个selector线程换了多个channel了非阻塞。select()函数基于数组，fd个数限制1024，poll()函数也是基于数组但是fd数目无限制。都会负责所有的fd(未就绪的开销浪了)，<br>epll()基于红黑数实现，fd无大小限制，平衡二叉数插入删除效率高。<br>信号驱动模式IO:对IO多路复用进一步优化，selector也非阻塞了。但是sign信号无法区分多信号源。所以socket未使用这种，只有在单一信号模型上才能应用。<br>异步IO模型:真正的非阻塞IO，其实前面的四种IO都不是真正的非阻塞IO，他们的非阻塞只是，从网络或者内存磁盘到内核空间的非阻塞，调用read()后还需要从内核拷贝到用户空间。异步IO基于回调，这一步也非阻塞了，从内核拷贝到用户空间后才通知用户进程。<br>能我是这么理解的前半断，有理解错的请老师指正谢谢。后半断没看完。","like_count":23,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453806,"discussion_content":"理解正确，赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560479210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103112,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1560385845,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"91754699061","product_id":100028001,"comment_content":"老师这篇可以配合隔壁专栏tomcat的13，14章一起看，会更加有味道。😃","like_count":21,"discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12123,"discussion_content":"tomcat那门课也很强","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568470360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103567,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1560473837,"is_pvip":false,"replies":[{"id":"37661","content":"主从模式则是，Reactor主线程主要处理监听连接事件，而Reactor从线程主要监听I&#47;O事件。这里是多线程处理accept事件，而不是创建多个ServerSocketChannel。","user_name":"作者回复","comment_id":103567,"uid":"1228576","ip_address":"","utype":1,"ctime":1560650842,"user_name_real":"刘超"}],"discussion_count":3,"race_medal":0,"score":"65984983277","product_id":100028001,"comment_content":"老师好对Reacktor的三种模式还是理解不太好。帮忙看看哪里有问题<br>单线程模型:一个selector同时监听accept,事件和read事件。检测到就在一个线程处理。<br>多线程模型:一个线程监听accept事件，创建channel注册到selector上，检听到Read等事件从线程池中获取线程处理。<br>主从模式:没看懂:-(，一个端口只能被一个serverSocketChannel监听，第二个好像会报错?这边的主从怎么理解啊","like_count":15,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453924,"discussion_content":"主从模式则是，Reactor主线程主要处理监听连接事件，而Reactor从线程主要监听I/O事件。这里是多线程处理accept事件，而不是创建多个ServerSocketChannel。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560650842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2421369,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f2/79/b2012f53.jpg","nickname":"余生","note":"","ucode":"AEF6C96738F03B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383215,"discussion_content":"感觉主从模式应该是这样: 一个线程监听连接，一个网络线程池read，一个work线程池处理消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625993910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1343671,"avatar":"","nickname":"Geek_bd613f","note":"","ucode":"69740C1D0FC15B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40240,"discussion_content":"知识量好大，老师讲得好好，能否补充下BIO和NIO的代码实现，不理解为什么BIO就是阻塞的，NIO就是非阻塞的？BIO客户端的一个请求，就会启用一个用户线程，并被阻塞在worker线程池的处理上；那NIO怎么避免一个客户端连接就启用一个用户线程的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572135721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104038,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1560597965,"is_pvip":false,"replies":[{"id":"37653","content":"你好，Reactor是一个模型，每个框架或者每个开发人员在处理I&#47;O事件可能不一样，根据自己业务场景来处理。<br><br>Netty是基于Reactor主线程去监听连接， Reactor从线程池监听读写事件，同时如果监听到事件后直接在该从线程中操作读写I&#47;O，将业务交给单独的业务线程池，也可以不交给单独的线程池处理，直接在从线程池处理。不交给业务线程池的好处是，减少上下文切换，坏处是会造成线程阻塞。<br><br>所以根据自己的业务的特性，如果你的数据特别大，I&#47;O读写操作放到handler线程池，，Reactor从线程数量有限，如果开大了，由于开多个多路复用器也会带来性能消耗。所以这种处理也是一种提高系统吞吐量的优化。<br>","user_name":"作者回复","comment_id":104038,"uid":"1228576","ip_address":"","utype":1,"ctime":1560649450,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":1,"score":"61690140109","product_id":100028001,"comment_content":"老师您在介绍Reactor线程模型的时候，关于多线程Reactor线程模型和主从Reactor线程模型，我有不同的理解。您画的多线程模型，其中读写交给了线程池，我在看Doug Lea的 《Scalable in java》中画的图和代码示例，读写事件还是由Reactor线程处理，只把业务处理交给了线程池。主从模型也是同样的，Reactor主线程处理连接，Reactor从线程池处理读写事件，业务交给单独的线程池处理。<br>还望老师指点","like_count":14,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454098,"discussion_content":"你好，Reactor是一个模型，每个框架或者每个开发人员在处理I/O事件可能不一样，根据自己业务场景来处理。\n\nNetty是基于Reactor主线程去监听连接， Reactor从线程池监听读写事件，同时如果监听到事件后直接在该从线程中操作读写I/O，将业务交给单独的业务线程池，也可以不交给单独的线程池处理，直接在从线程池处理。不交给业务线程池的好处是，减少上下文切换，坏处是会造成线程阻塞。\n\n所以根据自己的业务的特性，如果你的数据特别大，I/O读写操作放到handler线程池，，Reactor从线程数量有限，如果开大了，由于开多个多路复用器也会带来性能消耗。所以这种处理也是一种提高系统吞吐量的优化。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560649450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104353,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1560735480,"is_pvip":false,"replies":[{"id":"37870","content":"理解正确。select监听到事件之后就用当前线程把数据从内核态拷贝到用户态。","user_name":"作者回复","comment_id":104353,"uid":"1228576","ip_address":"","utype":1,"ctime":1560822664,"user_name_real":"刘超"}],"discussion_count":2,"race_medal":0,"score":"35920473848","product_id":100028001,"comment_content":"I&#47;O多路复用其实就相当于用了一个专门的线程来监听多个注册的事件，而之前的IO模型中，每一个事件都需要一个线程来监听，不知道我这样理解的是否正确？老师我还有一个问题，就是当select监听到一个事件到来时，它是另起一个线程把数据从内核态拷贝到用户态，还是自己就把这个事儿给干了？","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454238,"discussion_content":"理解正确。select监听到事件之后就用当前线程把数据从内核态拷贝到用户态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560822664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0f/70/f59db672.jpg","nickname":"槑·先生","note":"","ucode":"897F0475592E3A","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359034,"discussion_content":"那如果同时有多个通道的数据都准备好了，select线程自己拷多个通道的数据是不是有些吃力啊。\n\n会不会存在多个通道同时准备好的情况啊。感觉这里还有点模糊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616085559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113565,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1563080424,"is_pvip":false,"replies":[{"id":"41370","content":"对的，redis本身是操作内存，所以读取数据的效率会高很多。","user_name":"作者回复","comment_id":113565,"uid":"1228576","ip_address":"","utype":1,"ctime":1563090117,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"27332884200","product_id":100028001,"comment_content":"感谢老师分享，联想到Redis的单线程模式，Redis使用同一个线程来做selector，以及处理handler，这样的优点是减少上下文切换，不需要考虑并发问题；但是缺点也很明显，在IO数据量大的情况下，会导致QPS下降；这是由Redis选择IO模型决定的。","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458281,"discussion_content":"对的，redis本身是操作内存，所以读取数据的效率会高很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563090117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104237,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1560695159,"is_pvip":false,"replies":[{"id":"37785","content":"这里的本地内存应该指的是物理内存，避免堆内存和物理内存的拷贝，其实就是避免内核空间和用户空间的拷贝。","user_name":"作者回复","comment_id":104237,"uid":"1228576","ip_address":"","utype":1,"ctime":1560736913,"user_name_real":"刘超"}],"discussion_count":5,"race_medal":0,"score":"27330498935","product_id":100028001,"comment_content":"老师，隔壁李号双老师的《深入拆解Tomcat &amp; Jetty》中关于DirectByteBuffer的解释和您不一样，他的文章中DirectByteBuffer的作用是：DirectByteBuffer 避免了 JVM 堆与本地内存直接的拷贝，而并没有避免内存从内核空间到用户空间的拷贝。而sendfile 特性才是避免了内核与应用之间的内存拷贝。请问哪种才是对的？","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454184,"discussion_content":"这里的本地内存应该指的是物理内存，避免堆内存和物理内存的拷贝，其实就是避免内核空间和用户空间的拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560736913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326409,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3d/49/adf90844.jpg","nickname":"林伟烽","note":"","ucode":"97CE4039FAC8B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1670,"discussion_content":"李号双老师说得对","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562806693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1759325,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","nickname":"杯莫停","note":"","ucode":"4FA1D5CBBEF702","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578219,"discussion_content":"没认真看吧 讲的就是DirectBuffer 避免了堆内存拷贝到直接内存，而是直接拷贝到物理内存。没说避免了用户态和内核态之间的拷贝。mmap才是避免了户态和内核态之间的拷贝。用户态地址空间和内核态地址空间映射到同一块物理内存的。这样就没必要走用户态了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656584753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2426501,"avatar":"","nickname":"Geek_b0c3f5","note":"","ucode":"0C834A0E64015E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346790,"discussion_content":"刘超老师说得对，mmap是把用户地址空间和内核地址空间映射到同一块物理内存，省去了数据在用户空间和内核空间的copy。也是零copy的一种。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612063783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","nickname":"梁中华","note":"","ucode":"52FE40242CBAD0","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330,"discussion_content":"地内存也是应用的内存，属于用户空间的虚拟内存吧?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561452613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104899,"user_name":"余冲","can_delete":false,"product_type":"c1","uid":1175598,"ip_address":"","ucode":"162AF434FA753B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f0/2e/b3c880b8.jpg","comment_is_top":false,"comment_ctime":1560866375,"is_pvip":false,"replies":[{"id":"38049","content":"好的，后面补上","user_name":"作者回复","comment_id":104899,"uid":"1228576","ip_address":"","utype":1,"ctime":1560907294,"user_name_real":"刘超"}],"discussion_count":2,"race_medal":0,"score":"18740735559","product_id":100028001,"comment_content":"老师能对reactor的几种模型，给一个简单版的代码例子看看吗。感觉通过代码应该能更好的理解理论。","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454475,"discussion_content":"好的，后面补上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560907294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1649057,"avatar":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","nickname":"hello","note":"","ucode":"4F42DAA5DB5C38","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394728,"discussion_content":"老哥，老师后面有上代码吗？我才看到这儿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632019987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181689,"user_name":"阿卧","can_delete":false,"product_type":"c1","uid":1229566,"ip_address":"","ucode":"68C0CC25E57707","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/fe/038a076e.jpg","comment_is_top":false,"comment_ctime":1582616643,"is_pvip":false,"replies":[{"id":"70514","content":"对的，redis在处理文件事件（例如GET SET命令）时是通过事件处理器循环顺序处理各个事件。","user_name":"作者回复","comment_id":181689,"uid":"1228576","ip_address":"","utype":1,"ctime":1582720546,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"14467518531","product_id":100028001,"comment_content":"老师，redis的io多路复用模型，用的是单线程reactor线程模型嘛？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485079,"discussion_content":"对的，redis在处理文件事件（例如GET SET命令）时是通过事件处理器循环顺序处理各个事件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582720546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208768,"user_name":"chp","can_delete":false,"product_type":"c1","uid":1112415,"ip_address":"","ucode":"F0A2442230CD45","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/5f/b0a125a9.jpg","comment_is_top":false,"comment_ctime":1587435137,"is_pvip":false,"replies":[{"id":"78617","content":"这里说的非阻塞，是伪非阻塞，操作系统层面的epoll还是阻塞的，正在实现操作系统层面的非阻塞是AIO","user_name":"作者回复","comment_id":208768,"uid":"1228576","ip_address":"","utype":1,"ctime":1587990009,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"10177369729","product_id":100028001,"comment_content":"老师，为什么说NIO是同步非阻塞呀？同步我知道原因，那个非阻塞搞不懂，select函数不是已经阻塞了吗，这块要怎么理解呢","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492612,"discussion_content":"这里说的非阻塞，是伪非阻塞，操作系统层面的epoll还是阻塞的，正在实现操作系统层面的非阻塞是AIO","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587990009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168650,"user_name":"insist","can_delete":false,"product_type":"c1","uid":1054536,"ip_address":"","ucode":"1EE2800A900BA7","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/48/3ab39c86.jpg","comment_is_top":false,"comment_ctime":1578131759,"is_pvip":false,"replies":[{"id":"65924","content":"大家都一样，有时间偶尔捡起来再看看，温故而知新，可以为师矣","user_name":"作者回复","comment_id":168650,"uid":"1228576","ip_address":"","utype":1,"ctime":1578483564,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"10168066351","product_id":100028001,"comment_content":"感谢老师的讲解，很细致，从底层原理解释了5中IO模型。在netty，或者其他课程中，都有接触到这类知识，但是一直没有总结，总是看了感觉自己知道了，但是过段时间遇到这类问题，又不知道是为什么。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480283,"discussion_content":"大家都一样，有时间偶尔捡起来再看看，温故而知新，可以为师矣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578483564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103071,"user_name":"陆离","can_delete":false,"product_type":"c1","uid":1483932,"ip_address":"","ucode":"2C8C206CE36A81","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg","comment_is_top":false,"comment_ctime":1560378793,"is_pvip":false,"replies":[{"id":"37491","content":"是的，在Tomcat9版本改成了默认NIO。 <br><br>在Linux系统上，AIO的底层实现仍使用EPOLL，没有很好实现AIO，因此在性能上没有明显的优势；<br><br>这个跟堆内存溢出是类似的道理，如果物理内存被分配完了就会出现溢出错误。NIO中的directbuffer是用来分配内存读取或写入数据操作，如果数据比较大，而directbuffer分配比较下，则会分多次去读写，如果数据比较大的情况下可以适当调大提高效率。","user_name":"作者回复","comment_id":103071,"uid":"1228576","ip_address":"","utype":1,"ctime":1560479017,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"10150313385","product_id":100028001,"comment_content":"我所使用的Tomcat版本是9，默认的就是NIO，是不是版本不同默认模型也不同？<br>directbuffer如果满了会阻塞还是会报错？这一块的大小设置是不是也可以优化？<br>因为Linux的aio这一块不成熟所以nio现在是主流？还是有其他原因？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453716,"discussion_content":"是的，在Tomcat9版本改成了默认NIO。 \n\n在Linux系统上，AIO的底层实现仍使用EPOLL，没有很好实现AIO，因此在性能上没有明显的优势；\n\n这个跟堆内存溢出是类似的道理，如果物理内存被分配完了就会出现溢出错误。NIO中的directbuffer是用来分配内存读取或写入数据操作，如果数据比较大，而directbuffer分配比较下，则会分多次去读写，如果数据比较大的情况下可以适当调大提高效率。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560479017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289242,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1618930293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5913897589","product_id":100028001,"comment_content":"第 8 课原文：<br>DirectBuffer 只优化了用户空间内部的拷贝，而之前我们是说优化用户空间和内核空间的拷贝，那 Java 的 NIO 中是否能做到减少用户空间和内核空间的拷贝优化呢？<br><br>第 11 课原文：<br>在 Java 的 NIO 编程中，则是使用到了 Direct Buffer 来实现内存的零拷贝。Java 直接在 JVM 内存空间之外开辟了一个物理内存空间，这样内核和用户进程都能共享一份缓存数据。<br><br>老师，您好！<br>第 8 课说：DirectBuffer 只优化了用户空间内部的拷贝，并非优化用户空间和内核空间的。第 8 课提到的是 MappedByteBuffer 调用 mmap 文件内存映射，直接从硬盘读取数据到用户空间，没有经过内核空间。<br><br>第 11 课对 DirectBuffer 描述为：内核和用户进程都能共享一份缓存数据。<br><br>问题：<br>第 8 课讲只能优化用户空间。第 11 课讲优化内核空间和用户空间。这 2 节课的描述是否有出入吖？<br><br>谢谢老师！","like_count":1},{"had_liked":false,"id":170071,"user_name":"AA","can_delete":false,"product_type":"c1","uid":1103583,"ip_address":"","ucode":"CADCB958D6DA1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/df/1e4ecd94.jpg","comment_is_top":false,"comment_ctime":1578501721,"is_pvip":false,"replies":[{"id":"67224","content":"是的","user_name":"作者回复","comment_id":170071,"uid":"1228576","ip_address":"","utype":1,"ctime":1579524470,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"5873469017","product_id":100028001,"comment_content":"acceptCount是Acceptor主线程数？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480828,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579524470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112776,"user_name":"kaixiao7","can_delete":false,"product_type":"c1","uid":1242577,"ip_address":"","ucode":"505EC4AFB5E656","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/d1/cc6f82eb.jpg","comment_is_top":false,"comment_ctime":1562824797,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5857792093","product_id":100028001,"comment_content":"老师，有两个疑惑还望您解答，谢谢<br>1. ulimit -n 显示单个进程的文件句柄数为1024，但是启动一个socket服务(bio实现)后, cat &#47;proc&#47;&lt;pid&gt;&#47;limits 中显示的open files为4096, 实际测试当socket连接数达到4000左右时就无法再连接了.   还请老师解答一下4096怎么来的, 为什么1024不生效呢?<br>2. 您在文中提到epoll不受fd的限制. 但是我用NIO实现的服务端也是在连接到4000左右时无法再接收新的连接, 环境为Centos7(虚拟机, 内核3.10, 除了系统之外, 没有跑其他程序), jdk1.8, ulimit -n 结果为1024, cat &#47;proc&#47;sys&#47;fs&#47;file-max 结果为382293. 按理说socket连接数最大可以达到38000左右, 代码如下：<br>public static void main(String[] args) throws IOException {<br>        ServerSocketChannel channel = ServerSocketChannel.open();<br>        Selector selector = Selector.open();<br>        <br>        channel.configureBlocking(false);<br>        channel.socket().bind(new InetSocketAddress(10301));<br>        channel.register(selector, SelectionKey.OP_ACCEPT);<br><br>        int size = 0;<br>        <br>        while (true) {<br>            if (selector.select() == 0) {<br>                continue;<br>            }<br><br>            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br>            while (iterator.hasNext()) {<br>                SelectionKey key = iterator.next();<br>                iterator.remove();<br>                <br>                if (key.isAcceptable()) {<br>                    size++;<br>                    ServerSocketChannel server = (ServerSocketChannel) key.channel();<br>                    SocketChannel client = server.accept();<br><br>                    System.out.println(&quot;当前客户端连接数: &quot; + size + &quot;, &quot; + client.getRemoteAddress());<br>                }<br>            }<br>        }<br>        <br>    }","like_count":1,"discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541847,"discussion_content":"我对这个问题也是不解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640583076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13215,"discussion_content":"ulimit 分为Sn和Hn，默认一个1024一个4096","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568646315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354944,"user_name":"accpan","can_delete":false,"product_type":"c1","uid":1654083,"ip_address":"上海","ucode":"2857ACB7106E02","user_header":"https://static001.geekbang.org/account/avatar/00/19/3d/43/72ace06e.jpg","comment_is_top":false,"comment_ctime":1660899182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660899182","product_id":100028001,"comment_content":"总结的很到位","like_count":0},{"had_liked":false,"id":300750,"user_name":"平民人之助","can_delete":false,"product_type":"c1","uid":2658705,"ip_address":"","ucode":"5CCEC0BAC08AEC","user_header":"https://static001.geekbang.org/account/avatar/00/28/91/91/428a27a3.jpg","comment_is_top":false,"comment_ctime":1625371352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625371352","product_id":100028001,"comment_content":"其实大部分的公司都用undertow了，这个是默认开启nio吗","like_count":0},{"had_liked":false,"id":300661,"user_name":"Mars","can_delete":false,"product_type":"c1","uid":1185131,"ip_address":"","ucode":"5CAA44E6076C27","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/6b/4e472ff9.jpg","comment_is_top":false,"comment_ctime":1625297225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625297225","product_id":100028001,"comment_content":"Tomcat 中，BIO、NIO 是基于主从 Reactor 线程模型实现的。这句话不是很清楚，Reactor 的核心思想是将 I&#47;O 事件注册到多路复用器上，一旦有 I&#47;O 事件触发，多路复用器就会将事件分发到事件处理器中，执行就绪的 I&#47;O 事件操作。那BIO没有所有的I&#47;O事件注册，那怎么套用Reator模型呢？","like_count":0},{"had_liked":false,"id":289752,"user_name":"Geek_f67f40","can_delete":false,"product_type":"c1","uid":2583447,"ip_address":"","ucode":"E819443C553523","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pM3u1b8RtXpsjH8wHzwKnmnsDiba2SfeRbj8ltNnbBNN59FD3ZOOvYDx42kFdBLvu3FuWDQnDba2sop1iaGqBq8A/132","comment_is_top":false,"comment_ctime":1619166003,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619166003","product_id":100028001,"comment_content":"不知道老师用的是哪个版本，似乎没有mmap的源码显示，或者说，epoll底层根本没使用mmap？","like_count":0,"discussions":[{"author":{"id":2421369,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f2/79/b2012f53.jpg","nickname":"余生","note":"","ucode":"AEF6C96738F03B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383216,"discussion_content":"epoll根本没mmap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625994348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282205,"user_name":"warriorSL","can_delete":false,"product_type":"c1","uid":1597200,"ip_address":"","ucode":"902DA345FD2623","user_header":"https://static001.geekbang.org/account/avatar/00/18/5f/10/ed332d5a.jpg","comment_is_top":false,"comment_ctime":1615131373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615131373","product_id":100028001,"comment_content":"这篇文章对于理解服务器处理网络请求线程模型真是太优秀了","like_count":0},{"had_liked":false,"id":282077,"user_name":"星期一","can_delete":false,"product_type":"c1","uid":1125327,"ip_address":"","ucode":"2957D71C555E43","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/cf/bfb4d21f.jpg","comment_is_top":false,"comment_ctime":1615045796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615045796","product_id":100028001,"comment_content":"sun.nio.ch.ServerSocketChannelImpl#accept()<br>public SocketChannel accept() throws IOException {<br>        Object var1 = this.lock;<br>        synchronized(this.lock) {<br>            ......<br>        }<br>}  和文中Acceptor 线程池有冲突吗？","like_count":0},{"had_liked":false,"id":270523,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609150064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609150064","product_id":100028001,"comment_content":"BIO通过fork一个子进程处理一个对应连接,NIO一个进程对应多个连接,再通过多个线程处理对应的连接上的io.","like_count":0},{"had_liked":false,"id":270514,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609148877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609148877","product_id":100028001,"comment_content":"程序会通过 Selector 来轮询注册在其上的 Channel，当发现一个或多个 Channel 处于就绪状态时.<br>老师的这句话不太明白,epoll实现了阻塞时的监听回调,为什么selector还是使用轮循呢?轮循不是非常消耗性能嘛?","like_count":0},{"had_liked":false,"id":270510,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609148166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609148166","product_id":100028001,"comment_content":"select 通过阻塞后被唤醒的遍历读取fd数组来操作io,poll在select之上去除了对管理的fd数组中fd元素数量的限制,epoll采用红黑树存放fd提高了删写查性能,采用事件监听回调来操作io.","like_count":0},{"had_liked":false,"id":269649,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1608726550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608726550","product_id":100028001,"comment_content":"&quot;连接在 accept 队列中等待超时。如果 accept 队列过大，就容易浪费连接。&quot;<br>-----------------------<br>这里感觉没很看得很清楚，说下我的理解：<br>浪费连接是因为从accept中取出来之后放入worker线程池，但worker线程池由于并发量太大已经达到最大的线程数，所以只能在队列排队，而如果线程池的队列也占满，那就只能拒绝了。所以accept队列就算设置的很大，worker线程池处理不过来导致线程无法释放，那还是无济于事。老师，我理解的对吗？","like_count":0},{"had_liked":false,"id":248929,"user_name":"Geek_89bbab","can_delete":false,"product_type":"c1","uid":1156607,"ip_address":"","ucode":"B3110D5B3C9500","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/ff/6201122c.jpg","comment_is_top":false,"comment_ctime":1600362534,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1600362534","product_id":100028001,"comment_content":"老师，问一下epoll中哪里使用了mmap,我看了linux源码没有看到epoll中使用mmap。<br>“I&#47;O 复用中的 epoll 函数中就是使用了 mmap 减少了内存拷贝。”这个结论的出处是哪里？","like_count":0,"discussions":[{"author":{"id":2421369,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f2/79/b2012f53.jpg","nickname":"余生","note":"","ucode":"AEF6C96738F03B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383127,"discussion_content":"epoll应该是没有用mmap的，有很大一拨文章都说用了mmap都是以讹传讹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625914409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244721,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1598631618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598631618","product_id":100028001,"comment_content":"老师 directbuffer的作用是堆能直接拷贝到内核空间是吗","like_count":0},{"had_liked":false,"id":199318,"user_name":"10年以后","can_delete":false,"product_type":"c1","uid":1297421,"ip_address":"","ucode":"FE58CA7E5C2AF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/0d/89435926.jpg","comment_is_top":false,"comment_ctime":1585486671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585486671","product_id":100028001,"comment_content":"nio","like_count":0},{"had_liked":false,"id":165965,"user_name":"阿杜","can_delete":false,"product_type":"c1","uid":1066705,"ip_address":"","ucode":"349D3572F5ABE7","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg","comment_is_top":false,"comment_ctime":1577352475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577352475","product_id":100028001,"comment_content":"零拷贝，每次io都要经历四次数据拷贝，零拷贝是Direct Buffer实现，java直接申请了一块物理内存，数据直接从内核给用户进程。","like_count":0},{"had_liked":false,"id":165665,"user_name":"张悦","can_delete":false,"product_type":"c1","uid":1182317,"ip_address":"","ucode":"1E403BEEFFBF2B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/6d/61ace552.jpg","comment_is_top":false,"comment_ctime":1577280558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577280558","product_id":100028001,"comment_content":"二刷，还是刘老师写的好，看的舒服","like_count":0},{"had_liked":false,"id":165300,"user_name":"村夫","can_delete":false,"product_type":"c1","uid":1434041,"ip_address":"","ucode":"B70D4E421A281B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erdesQy0moaicYTicoHRQXzbmJm15wohb77qD1OdbuSqPCSUerbcZHzxJJunfmEhTx4kBLxbGaxQ9iag/132","comment_is_top":false,"comment_ctime":1577195975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577195975","product_id":100028001,"comment_content":"学到很多","like_count":0},{"had_liked":false,"id":162490,"user_name":"阿杜","can_delete":false,"product_type":"c1","uid":1066705,"ip_address":"","ucode":"349D3572F5ABE7","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg","comment_is_top":false,"comment_ctime":1576545505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576545505","product_id":100028001,"comment_content":"在 NIO 服务端通信编程中，首先会创建一个 Channel，用于监听客户端连接；接着，创建多路复用器 Selector，并将 Channel 注册到 Selector，程序会通过 Selector 来轮询注册在其上的 Channel，当发现一个或多个 Channel 处于就绪状态时，返回就绪的监听事件，最后程序匹配到监听事件，进行相关的 I&#47;O 操作。<br>这段总结的很好。<br>还有了解到线程池的逻辑还是有很多地方实现的，像这里的reactor也是，而且参数基本和java线程池参数一致的。看来很多优秀的实现逻辑在不同的应用中是可以复制的。","like_count":0},{"had_liked":false,"id":158397,"user_name":"邱柏森","can_delete":false,"product_type":"c1","uid":1113827,"ip_address":"","ucode":"ED91FEEC083F3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/e3/7da333ae.jpg","comment_is_top":false,"comment_ctime":1575363984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575363984","product_id":100028001,"comment_content":"&gt; poll() 函数：在每次调用 select() 函数之前，系统需要把一个 fd 从用户态拷贝到内核态，这样就给系统带来了一定的性能开销<br>这里应该是拷贝三组fd_set","like_count":0},{"had_liked":false,"id":141284,"user_name":"Sdylan","can_delete":false,"product_type":"c1","uid":1008503,"ip_address":"","ucode":"4589D0D0FA9275","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/77/423345ab.jpg","comment_is_top":false,"comment_ctime":1571135732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571135732","product_id":100028001,"comment_content":"2019.10.15 需要细看  ","like_count":0},{"had_liked":false,"id":134674,"user_name":"烈冬冰夏","can_delete":false,"product_type":"c1","uid":1060113,"ip_address":"","ucode":"F2875FC596D4FA","user_header":"https://static001.geekbang.org/account/avatar/00/10/2d/11/0ecbe9ea.jpg","comment_is_top":false,"comment_ctime":1568890928,"is_pvip":false,"replies":[{"id":"51871","content":"两者区别在于BIO是阻塞IO，而NIO为非阻塞IO","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569054669,"ip_address":"","comment_id":134674,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568890928","product_id":100028001,"comment_content":"Tomcat 中，BIO、NIO 是基于主从 Reactor主从，那2则的区别是什么呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467858,"discussion_content":"两者区别在于BIO是阻塞IO，而NIO为非阻塞IO","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569054669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131927,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1567983920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567983920","product_id":100028001,"comment_content":"可能功力未到，这次关于各种IO的通信模型没完全GET到点，这一部分又是必须要弄明白的，今年双十一又要开始一波囤书，《UNIX 网络编程》已加入购物车。","like_count":0},{"had_liked":false,"id":106882,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1561421718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561421718","product_id":100028001,"comment_content":"老师，请教一个问题，maxthreads这个参数在tomcat中是指只是单独处理I&#47;o的读写线程数，还是读取完数据后，本身的业务层处理也是在这个线程池里处理","like_count":0},{"had_liked":false,"id":104861,"user_name":"吾爱有三","can_delete":false,"product_type":"c1","uid":1138007,"ip_address":"","ucode":"FC5B32E36CE249","user_header":"https://static001.geekbang.org/account/avatar/00/11/5d/57/82f1a3d4.jpg","comment_is_top":false,"comment_ctime":1560858563,"is_pvip":false,"replies":[{"id":"38052","content":"这里的挂起是一个动作，阻塞是一种状态。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560907819,"ip_address":"","comment_id":104861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560858563","product_id":100028001,"comment_content":"文章多次提到挂起会进入阻塞状态，然到挂起等价阻塞？不是吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454459,"discussion_content":"这里的挂起是一个动作，阻塞是一种状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560907819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103860,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1560553218,"is_pvip":false,"replies":[{"id":"37658","content":"epoll是使用了wait方法阻塞等待事件，所以是阻塞的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560650485,"ip_address":"","comment_id":103860,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560553218","product_id":100028001,"comment_content":"老师好!又看了一遍总结了下<br>epoll()方式的优点如下<br>1.无需用户空间到内核空间的fd拷贝过程。<br>2.通过事件表，只返回就绪事件无需轮训遍历<br>3.基于红黑树增删快。<br>4.事件发生后内核主动回调，用户进程wait状态(此时算阻塞还是非阻塞啊?)<br>内核也像观察者，(事件驱动的都像观察者)<br>还有别的优点么?","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454027,"discussion_content":"epoll是使用了wait方法阻塞等待事件，所以是阻塞的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560650485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103735,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1560499918,"is_pvip":false,"replies":[{"id":"37660","content":"不是的，这个acceptCount是Acceptor的线程数量，也就是Reactor主线程数量。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560650571,"ip_address":"","comment_id":103735,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1560499918","product_id":100028001,"comment_content":"刘老师，请问poller线程池 poller队列和文末提的acceptCount队列是不是一个队列？<br>","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453985,"discussion_content":"不是的，这个acceptCount是Acceptor的线程数量，也就是Reactor主线程数量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560650571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397434,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/ba/412b05c1.jpg","nickname":"放下","note":"","ucode":"1AD911B1E23BDB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271330,"discussion_content":"老师这个地方是不是说错了，acceptThreadCount才是Acceptor的线程数量，accpetCount是能accept队列大小，就是能接收多大的连接请求，请老师指正","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590118334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103449,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1560437504,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1560437504","product_id":100028001,"comment_content":"晕了，如果能结合点生活中的例子就更好了，我先去看看其他资料，再回来提问题。","like_count":0},{"had_liked":false,"id":103382,"user_name":"kim118000","can_delete":false,"product_type":"c1","uid":1487926,"ip_address":"","ucode":"6CE3E673C81EBE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/jDG4trQm3t6licZym9TayWRib15Z3auNv4ictblMvkHxzYqOwuD3HibGs8ktGBrPefDic5ZYH85lg9CroynSMlJxcpw/132","comment_is_top":false,"comment_ctime":1560425717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560425717","product_id":100028001,"comment_content":"acceptorThreadCount：该参数代表 Acceptor 的线程数量，在请求客户端的数据量非常巨大的情况下，可以适当地调大该线程数量来提高处理请求连接的能力，默认值为 1。<br><br>老师，我今天看了源码注释<br>doesn&#39;t seem to work that well with mutiple acceptor threads<br><br>我之前的理解是Java还做不到多个接受连接来提高请求连接的处理能力，目前普遍的做法是通过fork多个子进程来达到同时监听同一个socket fd，但这样有惊群，所以利用mutex多个监听者只有一个能处理本次连接操作<br><br>目前还是一主多从方案，但这已经够用，可以通过多台机器提高并发。","like_count":0}]}