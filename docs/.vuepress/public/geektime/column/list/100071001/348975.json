{"id":348975,"title":"11 ｜通过程序并行计算，避免CPU资源浪费","content":"<p>你好，我是尹会生。</p><p>在我为运营工作提供技术咨询的时候，遇到过这样一个场景：这场运营活动，需要在电脑和手机端的多个不同应用程序，同时推送产品宣传图片和视频。这些大量的图片需要有不同的格式和尺寸，视频也需要根据不同的App截取不同的时长。</p><p>如果这类需要大量计算的多个任务成为你的日常工作，会花费你不少的时间和精力。不过别担心，我们可以通过程序并行计算，来提升任务效率。</p><p>不过你可能会说，用Python自动化执行，也可以提高计算效率啊，那为什么还要学习并行计算呢？</p><p>要知道，Python默认的自动化只能利用CPU的一个逻辑核心，如果采用并行计算，那就能够最大化地利用CPU资源，从而成倍提升大量计算的任务效率。接下来我就详细分析一下并行计算的高效之处。</p><h2>为什么要进行并行计算</h2><p>还是我在开头提出的运营工作的场景。如果你从这类任务消耗计算机主要资源的角度去考虑，会发现这类需求有两个共同的特点。</p><p>第一，它们都需要进行大量的计算，而计算主要是通过CPU来实现的。CPU的硬件指标上有两个和计算效率最相关的概念，分别是主频和多核。</p><p>主频决定CPU处理任务的快慢，多核决定处理的时候是否可以并行运行。这和生活中超市的收银一样，收银员的工作效率和超市开放了多少个收银台的通道，都决定了你能否以最快的速度购买到你想要买的商品。</p><!-- [[[read_end]]] --><p>第二，这些任务往往都需要运行相同的程序，但是程序的参数却需要根据不同的需求进行调整。</p><p>虽然咱们可以使用Python自动化执行这些程序，从而减少手动操作时间，但是我们还可以利用CPU的多核特性，让程序尽可能并行执行，发挥CPU的全部计算能力，提高运行效率。</p><p>那么接下来，我就来教你怎样利用Python的多进程库，来实现程序的并行计算，以及怎么提高并行计算的效率。</p><h2>怎样实现并行计算</h2><p>要想实现程序的并行计算，需要使用到标准库中的multiprocessing多进程库。你可能会问，进程是什么呢？</p><p><strong>进程，是计算机用来描述程序运行状态的名词</strong>。一个进程在运行时需要消耗一定的资源，包括CPU的时间、内存、设备I/O等。如果两个进程互相独立，在同一个任务处理过程中，没有前后依赖关系，那你可以利用multiprocessing库同时运行多个进程，这样就能成倍地减少多个任务执行的总时间。</p><p>接下来，我就以计算1-100的平方为例，看看怎么使用multiprocessing实现并行计算。代码如下：</p><pre><code>from multiprocessing import Pool\n\n# 计算平方\ndef f(x):\n    return x*x\n\nwith Pool(8) as p:\n    # 并行计算\n    res = p.map(f, range(1, 101))\n    print(f'计算平方的结果是:{res}')\n</code></pre><p>在这段代码中，我通过Pool包的map()函数来求1到100平方计算，由于每次计算平方的过程和下一次计算没有直接关联，我就可以使用并行的方式进行计算，提高计算效率。</p><p>为了让map()函数能够实现并行计算，我们必须在使用它之前，通过Pool()包为它指定并行计算的进程数量，设置要执行的函数名称f，以及f()函数所需参数。那么接下来，我就带你学习一下我是怎样使用with语句来设置函数的参数，并正确执行map()函数的。</p><p><strong>首先来看最关键的map()函数</strong>，它是Pool包实现并行计算的函数之一。在代码中我为map()函数赋值了f和range()函数两个参数。</p><p>第一个参数是函数对象。</p><p>函数对象会作为map()函数创建进程以后，即将执行的主要任务。因此，由于这里的含义是指定f对象将要被创建的进程执行，而不是将f()函数执行的结果作为新的进程执行，所以第一个参数必须使用函数对象f，而不能使用f()函数。</p><p>第二个参数要求必须是可迭代的对象。</p><p>例如我在代码中需要为f函数传递参数为1-100的整数，就可以使用range()函数产生1到100的整数并直接返回，因为它的返回值就是可迭代对象。</p><p>如果参数不是数字，就可以采用列表、元组、字典等支持迭代的数据类型，代替range()函数，作为f()函数的参数。举个例子，如果你需要并行调整多个视频的时长，就可以采用字典存储路径和要调整的视频时长，并把这个字典作为map()函数的第二个参数，map()函数会为字典的每个键值对创建一个进程来并行处理它们。</p><p><strong>接下来</strong>是map()函数中的三个主要部分，我来分析一下它们各自在并行计算中的功能。</p><p>第一，with语句。这是我们在第七讲学习怎么使用Python打开文件之后，第二次用到with语句了。</p><p>和文件操作类似，进程打开后也需要妥善关闭，但是进程关闭属于较为底层的操作，如果你不进行操作系统层面的程序设计，是不需要对关闭进程的函数进行修改的，因为使用默认关闭进程的行为，就能满足编写并行计算的需求。</p><p>因此，multiprocessing库对Pool包，支持了比较友好的进程打开和关闭方式，即with语句。也就是说，multiprocessing库把对进程的操作写在with语句块中，而with语句就会自动处理进程的打开和关闭，这样在实现并行计算的代码中，你就不用学习进程的基本操作，也能减轻你学习并发程序的负担。</p><p>在了解了with语句可以操作进程的打开和关闭后，我们来看代码中我是怎么使用with语句的。</p><p>我在代码中使用了“ with Pool(8) as p ”这条语句，这里的Pool()类是多进程库支持的进程池功能，它的作用是指定一个多进程的程序，最多能够并行执行的进程数量。它的参数“8”，表示map()函数最多同时运行8个进程。</p><p>剩下两个部分是range()函数和f()函数。</p><p>range()函数的作用是产生1-100的整数，这些整数会在每次创建新的进程时，依次作为f()函数的参数并赋值。而f()函数得到参数后，会把计算结果返回给map()函数。当f()函数处理完所有的参数后，map()函数还会返回一个列表作为运行的结果，并进行输出。</p><p>以上就是实现并行计算的主要过程。</p><h2>如何提高并行计算的效率</h2><p>我们除了需要掌握并行计算的基本方法外，还可以继续提升并行计算的效率。所以在程序中还有两个地方需要优化。</p><p>一个是为并行程序自动指定并行度。在并行计算的基本方法中，我使用了手动指定并行度的方式，来指定进程最多能够运行多少个。不过手动指定的并行度并不能适合所有的电脑，因此就需要根据计算机的CPU核数设置合理的并行度。而且，每台计算机的CPU资源是固定不变的，那么设置合理的进程数量能让你的并行计算任务充分利用CPU资源。</p><p>另一个是统计程序运行的时间。当你对并行计算的数量做了修改后，那程序是否对计算效率起到了提升效果呢？就还需要更精确的测量，这样才能得到更准确的结果。所以我们还需要使用Python统计出程序执行过程一共消耗了多长的时间。</p><p>我们先来看怎么自动设置适合你的电脑的并行度。</p><h3>为并行程序自动指定并行度</h3><p>计算类的任务包括数字计算、数据统计、视频的编解码等，都属于计算密集型应用，它们最大的资源开销就是CPU时间的消耗，设置的并行度过大或过小都不能达到最好的运行效率。</p><ul>\n<li>如果并行度设置过小，比如运行的进程数量小于逻辑CPU的数量，就会造成部分逻辑CPU因为无法被充分利用而处于闲置状态。</li>\n<li>如果并行度设置过大，由于现代的操作系统为了保证每个进程都能公平得到CPU资源，所以会造成CPU把时间大量消耗在进程切换上。那么并行度设置过大，会导致CPU还未完成一个进程的处理时，就得切换至下一个进程进行处理，而多进程之间来回切换也会消耗CPU时间，造成CPU资源的浪费。</li>\n</ul><p>那并行度该怎么设置才合理呢？通常情况下，我们会把并行度设置为逻辑CPU数量的两倍。不过假如计算任务达到小时级别（这类任务需要长时间占用CPU资源），为了减少切换任务时的开销，我建议计算的并行度和逻辑CPU数量保持相等。</p><p>这就又有一个问题了，该怎么获得计算机的逻辑CPU个数呢？Windows可以通过任务管理器获得，MacOS可以通过活动监视器获得。如果你希望取得逻辑CPU的个数之后，可以根据它的数量自动设置创建进程的数量，那么可以通过安装第三方包psutils，利用其中的cpu_count()函数取得逻辑CPU个数。</p><p>我把并行度自动设置为当前逻辑CPU两倍的代码写在下面，供你参考。</p><pre><code>from multiprocessing import Pool,Queue\nimport os\nimport psutil\n\n# 逻辑cpu个数\ncount = psutil.cpu_count()\n\n# 定义一个队列用于存储进程id\nqueue = Queue()\n\n# 用于计算平方和将运行函数的进程id写入队列\ndef f(x):\n    queue.put(os.getpid())\n    return x*x\n\nwith Pool(count*2) as p:\n    # 并行计算\n    res = p.map(f, range(1, 101))\n    print(f'计算平方的结果是:{res}')\n\n# 并行计算用到的进程id\npids = set()\nwhile not queue.empty():\n    pids.add(queue.get())\n    \nprint(f'用到的进程id是: {pids}')\n</code></pre><p>在代码中，我使用了 psutil.cpu_count() 函数来获取逻辑CPU的个数，它把“count*2”作为参数传递给Pool()类，并以逻辑CPU两倍作为最大创建进程数量，从而计算1-100的平方。</p><p>这里有两点需要你注意。第一，<strong>psutils是process and system utilities</strong>的缩写，所以它除了获取逻辑CPU数量外，还可以获取内存、硬盘、网络连接等和操作系统相关的信息。如果你在工作中需要取得操作系统的运行状态，就可以采用psutils包。</p><p>第二，psutils是第三方库，因此，在Windows上你需要通过cmd命令行执行pip3 install psutil安装后，才能释放psutils包，否则会出现模块无法找到的错误。</p><p>由于map()函数的第二个参数可能会被传入不可迭代对象，这时有可能会导致只运行了一个进程，因此我就在多进程执行过程中，增加了记录进程ID的功能。而在这一功能中，我使用的是<strong>os库、队列库和集合数据类型</strong><strong>，</strong>按照下面三个步骤来实现对所有创建的进程ID的统计。</p><p><strong>首先，<strong>使用</strong>os库的getpid()函数获取进程ID。</strong></p><p>由于map()函数会根据Pool()类的参数，事先创建好指定数量的进程，而每次运行f()函数都在创建好的进程中执行，所以我就采用os库的getpid()函数取得运行f()函数进程的唯一标识，这就是使用os库的用途。</p><p><strong>接下来，<strong><strong>使用队列库存储每次运行进程的ID</strong></strong>。</strong></p><p>为了把每次运行的进程ID存到一个对象中，我使用了multiprocessing库的队列包。因为在多进程的程序中，不能采用标准数据类型来传递数据，所以multiprocessing库还提供了方便进程间通信的对象——Queue队列。</p><p>map()函数每执行一次f()函数，我就把进程ID作为队列的put()函数的参数，并把进程ID放入队Queue中，直到所有的f()函数执行完成，队列里就会记录每次执行的进程ID信息。</p><p><strong>最后，<strong><strong>使用集合数据类型存储本次f()函数运行的所有进程ID</strong></strong>。</strong></p><p>为了实现这一功能，我需要通过while循环结构，根据队列不为空的条件，把队列中的进程ID使用get()函数取出来，放入pids变量中。</p><p>pids变量是集合数据类型，集合是一个无序的不重复元素序列，需要使用set()创建。你可以把集合当作一个只有键没有值的字典来记忆，它的特点是集合里的元素不能重复。</p><p>由于f()函数会多次在一个进程中执行，因此在队列中会记录重复的进程ID，我把进程ID从队列中取出后，放入集合数据类型中，自己就不用编写程序，自动把重复的进程ID去掉了。而且通过对集合pids中的进程ID进行输出，可以看到进程ID的数量刚好和Pool()类指定的并行进程数量相等。</p><p>这种用法是我经常在进行多进程程序调试的一种简单用法，我还会把它们的结果写入文件保存，以便程序出现异常执行结果时，可以根据调试的信息进行问题的定位。</p><h3>统计程序运行的时间</h3><p>我们除了需要掌握判断程序的并行度外，还可以统计并行计算比顺序计算节省了多少时间。那么再遇到相同场景的时候，你可以选择并行方式来运行程序，提高工作效率。接下来我来教你怎样统计Python程序运行的时间。</p><p>在Python中我们可以利用time库的time()函数，来记录当前时间的功能。</p><ul>\n<li>首先，需要在统计时间代码的前后各增加一次time.time()函数，并把它们统计时间的结果存放在time1、time2两个不同的变量中。</li>\n<li>然后再把两个变量相减，这样就能取得程序的运行时间了。</li>\n</ul><p>我把核心实现代码写在下面供你参考。</p><pre><code># 并行计算时间统计 \nwith Pool(4) as p:\n    # 并行计算\n    time1 = time.time()\n    res = p.map(f, range(1, 10001))\n    time2 = time.time()\n    # print(f'计算平方的结果是:{res}')\n\nprint(str(time2-time1))\n\n\n# 串行计算时间统计\nlist1 = []\n\ntime1 = time.time()\nfor i in range(1, 10001):\n    list1.append(f(i))\ntime2 = time.time()\n\nprint(str(time2-time1))\n</code></pre><p>在这段代码中，通过time1和time2的时间差就可以得到程序运行的时间了，那么根据运行时间，我们可以把并行程序和串行程序执行时间的性能进行对比。</p><p>这里你需要注意，由于计算平方的CPU开销较小，比较难体现并行计算的优势，你就可以采用并行访问网页，或其他CPU开销较高的程序，这样会让两个程序的时间差别更加明显。</p><h2>总结</h2><p>在最后，我来为你总结一下实现并行计算的<strong>基本方法和三个注意事项。</strong></p><p>通过multiprocessing的Pool包可以实现基于进程的并行计算功能，Pool包的map()函数会根据Pool包指定的进程数量实现并行运行。这里还有三点需要你注意：</p><ol>\n<li>作为map()函数的第一个参数你需要传递函数对象f，不能传递函数的调用f()形式，这是初学者实现并行任务最容易出现的错误。</li>\n<li>为了让并行度更适合你的电脑，应该根据逻辑CPU的个数设置并行度，并根据运行时间来对并行数量进一步优化。</li>\n<li>实现并行计算任务的程序除了使用多进程模型外还可以使用多线程模型。多进程的并行计算更适用于计算密集型应用，即程序运行过程中主要为计算类CPU开销大的程序，多线程模型适合I/O密集型的应用，例如:通过互联网进行批量网页访问和下载。如果你想将多进程的并发模型改为多线程的并发模型只需在导入库的时候将“multiprocessing”改为“multiprocessing.dummy”就能实现多线程并行访问网页。我将多进程和多线程两种方式导入库的代码贴在下方供你参考。</li>\n</ol><pre><code># 多进程模型\nfrom multiprocessing import Pool\n\n# 多线程模型\nfrom multiprocessing.dummy import Pool\n\n# multiprocessing.dummy的Pool用法和multiprocessing库相同\n</code></pre><p>我把这节课的相关代码放在了<a href=\"https://github.com/wilsonyin123/python_productivity/blob/main/%E6%96%87%E7%AB%A011%E4%BB%A3%E7%A0%81.zip\">GitHub</a>上，你可以自行查找、学习。</p><h2>思考题</h2><p>我为你留一道思考题，有一个软件包requests，可以通过requests.get('<a href=\"http://www.baidu.com\">http://www.baidu.com</a>').text 方式访问一个网站，并能够得到网页的源代码。假设我为你提供了几十个需要访问的网站，你是如何实现这些网站的并行访问的，你又能否通过Python对比出逐个访问网页的时间是并行访问的几倍吗？</p>","neighbors":{"left":{"article_title":"10｜按指定顺序给词语排序，提高查找效率","id":348179},"right":{"article_title":"12｜文本处理函数：三招解决数据对齐问题","id":349981}},"comments":[{"had_liked":false,"id":287639,"user_name":"聂小倩","can_delete":false,"product_type":"c1","uid":1985713,"ip_address":"","ucode":"62125D45F281AD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4c/b1/c8fc2efa.jpg","comment_is_top":false,"comment_ctime":1618063190,"is_pvip":false,"replies":[{"id":"104766","content":"这里要涉及操作系统的一些知识，一个Python进程运行之后，会申请自己运行所需要的内存，内存又按照功能分成很多部分，其中的“栈”会存放基本数据类型。那么一个进程中进行变量赋值是需要“栈”这个功能来完成的。<br><br>那当你使用了多进程之后，就会产生另一个进程，也就是会申请另一组“栈”。那么两个进程用了两个不同的“栈”，所以无法使用赋值的方式传递变量，而两个进程又可能会有互相通信的需要，所以在设计进程的时候，会再设计进程之间的通信方式，其中管道就是最常用的通信方式之一了。","user_name":"作者回复","user_name_real":"尹会生","uid":"1056235","ctime":1618590911,"ip_address":"","comment_id":287639,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18797932374","product_id":100071001,"comment_content":"老师，请问为什么说“在多进程的程序中，不能采用标准数据类型来传递数据”呢？","like_count":4,"discussions":[{"author":{"id":1056235,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/eb/b2123759.jpg","nickname":"尹会生","note":"","ucode":"D1093DBD093617","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518375,"discussion_content":"这里要涉及操作系统的一些知识，一个Python进程运行之后，会申请自己运行所需要的内存，内存又按照功能分成很多部分，其中的“栈”会存放基本数据类型。那么一个进程中进行变量赋值是需要“栈”这个功能来完成的。\n\n那当你使用了多进程之后，就会产生另一个进程，也就是会申请另一组“栈”。那么两个进程用了两个不同的“栈”，所以无法使用赋值的方式传递变量，而两个进程又可能会有互相通信的需要，所以在设计进程的时候，会再设计进程之间的通信方式，其中管道就是最常用的通信方式之一了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618590911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282261,"user_name":"十一哈哈","can_delete":false,"product_type":"c1","uid":1283235,"ip_address":"","ucode":"C8E1F9185D16F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/a3/9cfea58e.jpg","comment_is_top":false,"comment_ctime":1615175634,"is_pvip":false,"replies":[{"id":"102527","content":"是的，感谢，忘记在文字下方提醒大家。","user_name":"作者回复","user_name_real":"尹会生","uid":"1056235","ctime":1615206687,"ip_address":"","comment_id":282261,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18795044818","product_id":100071001,"comment_content":"windows下使用multiprocessing，要将进程池相关代码应该放在if __name__ == &#39;__main__&#39;下面，要不然运行会报错....","like_count":4,"discussions":[{"author":{"id":1056235,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/eb/b2123759.jpg","nickname":"尹会生","note":"","ucode":"D1093DBD093617","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516681,"discussion_content":"是的，感谢，忘记在文字下方提醒大家。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615206687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331360,"user_name":"Geek_a345af","can_delete":false,"product_type":"c1","uid":2897058,"ip_address":"","ucode":"7324910A005040","user_header":"","comment_is_top":false,"comment_ctime":1642561999,"is_pvip":false,"replies":[{"id":"121229","content":"你好，第一个问题，和你怀疑的cpu压力大小和进程数量多少是有一定关系的，基于硬件配置高，没有创建多进程是有可能出现的<br>2 queue.put(os.getpid()) 之后如果没有报错或没有取出数据之前队列中的数据是不会消失的，建议你这样做：<br>执行了queue.put(os.getpid()) 之后，增加一个观察队列的代码 ，queue.qsize() 这行代码可以返回队列的大小（队列里元素的数量）<br>另外在执行过程中，观察一下运行的终端是否有错误产生。","user_name":"作者回复","user_name_real":"编辑","uid":"1056235","ctime":1642855435,"ip_address":"","comment_id":331360,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937529295","product_id":100071001,"comment_content":"把您的代码复制到我电脑上试了下，<br>1、发现100以内的求平方，我这边的结果并没有启用多进程，一个进程就做完了这些。改成求1000的内的平方，才创建了两个进程。(电脑cpu是8)<br>2、queue.put(os.getpid())向队列里添加进程的id，在后面向set里存这些id的时候，发现queue是空的，不太明白是为什么。<br>","like_count":1,"discussions":[{"author":{"id":1056235,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/eb/b2123759.jpg","nickname":"尹会生","note":"","ucode":"D1093DBD093617","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547757,"discussion_content":"你好，第一个问题，和你怀疑的cpu压力大小和进程数量多少是有一定关系的，基于硬件配置高，没有创建多进程是有可能出现的\n2 queue.put(os.getpid()) 之后如果没有报错或没有取出数据之前队列中的数据是不会消失的，建议你这样做：\n执行了queue.put(os.getpid()) 之后，增加一个观察队列的代码 ，queue.qsize() 这行代码可以返回队列的大小（队列里元素的数量）\n另外在执行过程中，观察一下运行的终端是否有错误产生。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642855435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325471,"user_name":"天国之影","can_delete":false,"product_type":"c1","uid":1252620,"ip_address":"","ucode":"FBCB451EF0BA23","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/0c/c438c5df.jpg","comment_is_top":false,"comment_ctime":1638968873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5933936169","product_id":100071001,"comment_content":"如果在Jupyter Notebook下，可使用以下方法：<br>通过临时文件方式，读取并使用并行计算<br><br>from multiprocessing import Pool<br>from functools import partial<br>import inspect<br> <br>def parallal_task(func, iterable, cpu_count = 4):<br> <br>    with open(f&#39;.&#47;tmp_func.py&#39;, &#39;w&#39;) as file:<br>        file.write(inspect.getsource(func).replace(func.__name__, &quot;task&quot;))<br> <br>    from tmp_func import task<br> <br>    if __name__ == &#39;__main__&#39;:<br>        func = partial(task)<br>        pool = Pool(cpu_count * 2)<br>        res = pool.map(func, iterable)<br>        pool.close()<br>        return res<br>    else:<br>        raise &quot;Not in Jupyter Notebook&quot;<br><br># 计算平方<br>def def_f(x):<br>    return x * x<br><br>for res in parallal_task(def_f, range(1, 101)):<br>    print(f&#39;计算平方的结果是:{res}&#39;)","like_count":1},{"had_liked":false,"id":339793,"user_name":"坚果","can_delete":false,"product_type":"c1","uid":2367914,"ip_address":"","ucode":"480E112DF49A6A","user_header":"https://static001.geekbang.org/account/avatar/00/24/21/aa/3b1dbca7.jpg","comment_is_top":false,"comment_ctime":1648387692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648387692","product_id":100071001,"comment_content":"这一章有没有windows并行计算参考资料，我一个程序都没有调试成功，一运行就堵塞","like_count":0},{"had_liked":false,"id":339791,"user_name":"坚果","can_delete":false,"product_type":"c1","uid":2367914,"ip_address":"","ucode":"480E112DF49A6A","user_header":"https://static001.geekbang.org/account/avatar/00/24/21/aa/3b1dbca7.jpg","comment_is_top":false,"comment_ctime":1648387491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648387491","product_id":100071001,"comment_content":"<br>通过临时文件方式，读取并使用并行计算，为什么要通过临时文件使用并行计算？","like_count":0},{"had_liked":false,"id":325470,"user_name":"天国之影","can_delete":false,"product_type":"c1","uid":1252620,"ip_address":"","ucode":"FBCB451EF0BA23","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/0c/c438c5df.jpg","comment_is_top":false,"comment_ctime":1638968753,"is_pvip":false,"replies":[{"id":"119182","content":"从执行结果来看，串行和并行不是一个数量级的速度。所以我猜测你的串行计算程序一定是执行了多次。为什么多次执行相同的程序会变“快”？相信你看到这里心里就有了对正确答案的猜测。没错，这里的串行程序并没有计算，而是由于Python解释器在内存中缓存了短时间多次执行程序的结果。<br><br>那么由此，你可能会衍生出另外一个问题：既然能缓存了，跑在生成环境中的代码也可以，那么是不是并行计算无法比串行计算更有优势？<br><br>这里一定要清楚，我们跑的测试代码，是两次执行过程的中间结果和最终结果都没有变化，且代码简单才能进行的缓存。一旦进行复杂的常见，中间过程和结果不同，计算过程也就无法缓存了，必然并行和串行都要当做第一次运行来对待。这也经常是我们听到很多编译型语言在吐槽python运行的慢的原因了。<br>关于python执行代码缓存相关问题，可以参考下面这个链接，得到更详细的解释：<br>https:&#47;&#47;www.jianshu.com&#47;p&#47;eb100c7bb4cf","user_name":"作者回复","user_name_real":"编辑","uid":"1056235","ctime":1640149515,"ip_address":"","comment_id":325470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638968753","product_id":100071001,"comment_content":"老师，我运行出来的时间统计结果如下：<br><br>并行计算时间统计: 0.1607363224029541<br>串行计算时间统计: 0.0009999275207519531<br><br>为什么并行计算比串行计算耗时还长？","like_count":0,"discussions":[{"author":{"id":1056235,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/eb/b2123759.jpg","nickname":"尹会生","note":"","ucode":"D1093DBD093617","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540749,"discussion_content":"从执行结果来看，串行和并行不是一个数量级的速度。所以我猜测你的串行计算程序一定是执行了多次。为什么多次执行相同的程序会变“快”？相信你看到这里心里就有了对正确答案的猜测。没错，这里的串行程序并没有计算，而是由于Python解释器在内存中缓存了短时间多次执行程序的结果。\n\n那么由此，你可能会衍生出另外一个问题：既然能缓存了，跑在生成环境中的代码也可以，那么是不是并行计算无法比串行计算更有优势？\n\n这里一定要清楚，我们跑的测试代码，是两次执行过程的中间结果和最终结果都没有变化，且代码简单才能进行的缓存。一旦进行复杂的常见，中间过程和结果不同，计算过程也就无法缓存了，必然并行和串行都要当做第一次运行来对待。这也经常是我们听到很多编译型语言在吐槽python运行的慢的原因了。\n关于python执行代码缓存相关问题，可以参考下面这个链接，得到更详细的解释：\nhttps://www.jianshu.com/p/eb100c7bb4cf","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640149515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317331,"user_name":"Bill","can_delete":false,"product_type":"c1","uid":2802110,"ip_address":"","ucode":"779E3C365AAB87","user_header":"https://static001.geekbang.org/account/avatar/00/2a/c1/be/dcce5f5a.jpg","comment_is_top":false,"comment_ctime":1634743684,"is_pvip":false,"replies":[{"id":"115015","content":"棒！","user_name":"编辑回复","user_name_real":"李辰洋","uid":"2189689","ctime":1634783000,"ip_address":"","comment_id":317331,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1634743684","product_id":100071001,"comment_content":"打卡","like_count":0,"discussions":[{"author":{"id":2189689,"avatar":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","nickname":"🐑","note":"","ucode":"DE34B3B14287D1","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528770,"discussion_content":"棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634783000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316479,"user_name":"聪少 Jeff","can_delete":false,"product_type":"c1","uid":1159983,"ip_address":"","ucode":"C791ACA9B47679","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/2f/d08a1363.jpg","comment_is_top":false,"comment_ctime":1634345583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634345583","product_id":100071001,"comment_content":"为了初步本次课程的小伙伴想我遇到相同的问题（即是：进程池相关代码应放在if__name__ == &#39;main&quot;的报错）解决方法参考，这个问题已经在十一哈哈学员的提醒下发现的，为了直观一些提供以下代码参考一下。<br><br>[示例代码]<br>from multiprocessing import Pool<br># 1-100平方模拟程序<br><br><br>def f(x):<br>    # 计算平方<br>    return x * x<br><br><br>def test():<br>    with Pool(8) as p:<br>        res = p.map(f, range(1, 101))<br>        print(f&#39;计算平方的结果是:{res}&#39;)<br><br><br>if __name__ == &#39;__main__&#39;:<br>    test()<br>","like_count":0},{"had_liked":false,"id":291538,"user_name":"栾~龟虽寿！","can_delete":false,"product_type":"c1","uid":1504671,"ip_address":"","ucode":"219B38C08979FE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","comment_is_top":false,"comment_ctime":1620354071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620354071","product_id":100071001,"comment_content":"打卡学习了","like_count":0},{"had_liked":false,"id":281983,"user_name":"Soul of the Dragon","can_delete":false,"product_type":"c1","uid":2438011,"ip_address":"","ucode":"21603099E51B8A","user_header":"https://static001.geekbang.org/account/avatar/00/25/33/7b/9e012181.jpg","comment_is_top":false,"comment_ctime":1615002130,"is_pvip":false,"replies":[{"id":"102525","content":"你的Python应该是python2.x版本，需要将它换成Python3版本，要从官方网站重新下载。","user_name":"作者回复","user_name_real":"尹会生","uid":"1056235","ctime":1615206561,"ip_address":"","comment_id":281983,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615002130","product_id":100071001,"comment_content":"老师，请问如果在代码运行过程中出现“UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode characters in position 18-19: ordinal not in range(128)” 这样的报错，应该如何解决呢？","like_count":0,"discussions":[{"author":{"id":1056235,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/eb/b2123759.jpg","nickname":"尹会生","note":"","ucode":"D1093DBD093617","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516571,"discussion_content":"你的Python应该是python2.x版本，需要将它换成Python3版本，要从官方网站重新下载。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615206561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}