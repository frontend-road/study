{"id":740850,"title":"第 11 章 面向对象设计原则（下）","content":"\n<p>在上一章中，我通过一个具体的爬虫案例介绍了 SOLID 设计原则的前两条：SRP 与 OCP。相信你可以感受到，它们都比较抽象，代表面向对象设计的某种理想状态，而不与具体的技术名词直接挂钩。这意味着，“开放–关闭”“单一职责”这些名词，既可以形容类，也可以形容函数。</p>\n<p>而余下的三条原则稍微不同，它们都和具体的面向对象技术有关。</p>\n<p>SOLID 原则剩下的 LID 如下。</p>\n<ul>\n<li>L：Liskov substitution principle（里式替换原则，LSP）。</li>\n<li>I：interface segregation principle（接口隔离原则，ISP）。</li>\n<li>D：dependency inversion principle（依赖倒置原则，DIP）。</li>\n</ul>\n<p>LSP 是一条用来约束继承的设计原则。我在第 9 章中说过，继承是一种既强大又危险的技术，要设计出合理的继承关系绝非易事。在这方面，LSP 为我们提供了很好的指导。遵循该原则，有助于我们设计出合理的继承关系。</p>\n<p>ISP 与 DIP 都与面向对象体系里的接口对象有关，前者可以驱动我们设计出更好的接口，后者则会指导我们如何利用接口让代码变得更易扩展。</p>\n<p>但如前所述，Python 语言不像 Java，并没有内置任何接口对象。因此，我的诠释可能会与这两条原则的原始定义略有出入。</p>\n<p>关于 LID 就先介绍到这里，接下来我会通过具体的代码案例逐条诠释它们的详细含义。</p>\n<h2 id=\"nav_point_172\">11.1　LSP：里式替换原则</h2>\n<p>在 SOLID 所代表的 5 条设计原则里，LSP 的名称最为特别。不像其他 4 条原则，名称就概括了具体内容，LSP 是以它的发明者——计算机科学家 Barbara Liskov——来命名的。</p><!-- [[[read_end]]] -->\n<p>LSP 的原文稍微有点儿晦涩，看起来像复杂的数学公式：</p>\n<blockquote>\n<p>Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.</p>\n<p>给定一个属于类型 <code>T</code> 的对象 <code>x</code>，假如 <code>q(x)</code> 成立，那么对于 <code>T</code> 的子类型 <code>S</code> 来说，<code>S</code> 类型的任意对象 <code>y</code> 也都能让 <code>q(y)</code> 成立。</p>\n</blockquote>\n<p>这里用一种更通俗的方式来描述 LSP：LSP 认为，所有子类（派生类）对象应该可以任意替代父类（基类）对象使用，且不会破坏程序原本的功能。</p>\n<p>单看这些文字描述，LSP 显得比较抽象难懂。下面我们通过具体的 Python 代码，来看看一些常见的违反 LSP 的例子。</p>\n<h3 id=\"nav_point_173\">11.1.1　子类随意抛出异常</h3>\n<p>假设我正在开发一个简单的网站，网站支持用户注册与登录功能，因此我在项目中定义了一个用户类 <code>User</code>：</p>\n<pre class=\"code-rows\"><code>class User(Model):\n    \"\"\"用户类，包含普通用户的相关操作\"\"\"\n\n    ...\n\n    def deactivate(self):\n        \"\"\"停用当前用户\"\"\"\n        self.is_active = False\n        self.save()</code></pre>\n<p><code>User</code> 类支持许多操作，其中包括停用当前用户的方法：<code>deactivate()</code>。</p>\n<p>网站上线一周后，我发现有几个恶意用户批量注册了许多违反运营规定的账号，我需要把这些账号全部停用。为了方便处理，我写了一个批量停用用户的函数：</p>\n<pre class=\"code-rows\"><code>def deactivate_users(users: Iterable[User]):\n    \"\"\"批量停用多个用户\n\n    :param users: 可迭代的用户对象 User\n    \"\"\"\n    for user in users:\n        user.deactivate()</code></pre>\n<p>停用这些违规账号后，站点风平浪静地运行了一段时间。</p>\n<ol>\n<li><p><strong>增加管理员用户</strong></p>\n<p>随着网站的功能变得越来越丰富，我需要给系统增加一种新的用户类型：站点管理员。这是一类特殊的用户，比普通用户多了一些额外的管理类属性。</p>\n<p>下面是站点管理员类 <code>Admin</code> 的代码：</p>\n<pre class=\"code-rows\"><code>class Admin(User):\n    \"\"\"管理员用户类\"\"\"\n\n    ...\n\n    def deactivate(self):\n        # 管理员用户不允许被停用\n        raise RuntimeError('admin can not be deactivated!')</code></pre>\n<p>因为普通用户的绝大多数操作在管理员上适用，所以我让 <code>Admin</code> 类直接继承了 <code>User</code> 类，避免了许多重复代码。</p>\n<p>但是，管理员和普通用户其实有一些差别。比如，出于安全考虑，管理员不允许被直接停用。因此我重写了 <code>Admin</code> 的 <code>deactivate()</code> 方法，让它直接抛出 <code>RuntimeError</code> 异常。</p>\n<p>子类重写父类的少量行为，看上去正是继承的典型用法。但可能会让你有些意外的是，上面的代码明显违反了 LSP。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>违反 LSP</strong></p>\n<p>还记得网站刚上线时，我写的那个批量停用用户的函数 <code>deactivate_users()</code> 吗？它的代码如下所示：</p>\n<pre class=\"code-rows\"><code>def deactivate_users(users: Iterable[User]):\n    for user in users:\n        user.deactivate()</code></pre>\n<p>当系统里只有一种普通用户类 <code>User</code> 时，上面的函数完全可以正常工作，但当我增加了管理员类 <code>Admin</code> 后，一个新问题就会浮出水面。</p>\n<p>在 LSP 看来，新增的管理员类 <code>Admin</code> 是 <code>User</code> 的子类，因此 <code>Admin</code> 对象理应可以随意替代 <code>User</code> 对象。</p>\n<p>但是，假如我真的把 <code>[User(\"foo\"), Admin(\"bar_admin\")]</code> 这样的用户列表传到 <code>deactivate_users()</code> 函数里，程序马上就会抛出 <code>RuntimeError</code> 异常。因为在编写 <code>Admin</code> 时，我重写了父类的 <code>deactivate()</code> 函数——管理员压根儿就不支持停用操作。</p>\n<p>所以，现在的代码并不满足 LSP，因为在 <code>deactivate_users</code> 函数看来，子类 <code>Admin</code> 对象根本无法替代父类 <code>User</code> 对象。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>一个常见但错误的解决办法</strong></p>\n<p>要修复上面的问题，最直接的做法是在函数内增加类型判断：</p>\n<pre class=\"code-rows\"><code>def deactivate_users(users: Iterable[User]):\n    \"\"\"批量停用多个用户\"\"\"\n    for user in users:\n        # 管理员用户不支持 deactivate 方法，跳过\n        if isinstance(user, Admin):\n            logger.info(f'skip deactivating admin user ')\n            continue\n\n        user.deactivate()</code></pre>\n<p>当 <code>deactivate_users()</code> 函数遍历用户时，如果发现用户对象恰好属于 <code>Admin</code> 类，就跳过该用户，不执行停用。这样函数就能正确处理那些包含管理员的用户列表了。</p>\n<p>但这种做法有个显而易见的问题。虽然到目前为止，只有 <code>Admin</code> 类型不支持停用操作，但是谁能保证未来不会出现更多这种用户类型呢？</p>\n<p>假如以后网站有了更多继承 <code>User</code> 类的新用户类型（比如 VIP 用户、员工用户等），而它们也都不支持停用操作，那在现在的代码结构下，我就得不断调整 <code>deactivate_users()</code> 函数，来适配这些新的用户类型：</p>\n<pre class=\"code-rows\"><code># 在类型判断语句中不断追加新用户类型\n# if isinstance(user, Admin):\n# if isinstance(user, (Admin, VIPUser)):\nif isinstance(user, (Admin, VIPUser, Staff)):</code></pre>\n<p>看到这些，你想起上一章的 OCP 了吗？该原则认为：好设计应该对扩展开放，对修改关闭。而上面的代码在每次新增用户类型时，都要被同步修改，与 OCP 的要求相去甚远。</p>\n<p>此外，LSP 说：“子类对象可以替换父类。”这里的“子类”指的并不是某个具体的子类（比如 <code>Admin</code>），而是未来可能出现的任意一个子类。因此，通过增加一些针对性的类型判断，试图让程序符合 LSP 的做法完全行不通。</p>\n<p>既然增加类型判断不可行，我们来试试别的办法。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　你可以发现，SOLID 的每条原则其实互有关联。比如在这个例子里，违反 LSP 的代码同样无法满足 OCP 的要求。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>按 LSP 协议要求改造代码</strong></p>\n<p>在日常编码时，子类重写父类方法，让其抛出异常的做法其实并不少见。但之前代码的主要问题在于，<code>Admin</code> 类的 <code>deactivate()</code> 方法所抛出的异常过于随意，并不属于父类 <code>User</code> 协议的一部分。</p>\n<p>要让子类符合 LSP，我们必须让用户类 <code>User</code> 的“不支持停用”特性变得更显式，最好将其设计到父类协议里去，而不是让子类随心所欲地抛出异常。</p>\n<p>虽然在 Python 里，根本没有“父类的异常协议”这种东西，但我们至少可以做两件事。</p>\n<p>第一件事是创建自定义异常类。我们可以为“用户不支持停用”这件事创建一个专用的异常类：</p>\n<pre class=\"code-rows\"><code>class DeactivationNotSupported(Exception):\n    \"\"\"当用户不支持停用时抛出\"\"\"</code></pre>\n<p>第二件事是在父类 <code>User</code> 和子类 <code>Admin</code> 的方法文档里，增加与抛出异常相关的说明：</p>\n<pre class=\"code-rows\"><code>class User(Model):\n    ...\n\n    def deactivate(self):\n        \"\"\"停用当前用户\n\n        :raises: 当用户不支持停用时，抛出 DeactivationNotSupported 异常 ➊\n        \"\"\"\n        ...\n\nclass Admin(User):\n    ...\n\n    def deactivate(self):\n        raise DeactivationNotSupported('admin can not be deactivated')</code></pre>\n<blockquote>\n<p>❶ 虽然 <code>User</code> 类的 <code>deactivate</code> 方法暂时不会真正抛出 <code>DeactivationNotSupported</code> 异常，但我仍然需要把它写入文档中，作为父类规范予以声明</p>\n</blockquote>\n<p>这样调整后，<code>DeactivationNotSupported</code> 异常便显式成为了 <code>User</code> 类的 <code>deactivate()</code> 方法协议的一部分。当其他人要编写任何使用 <code>User</code> 的代码时，都可以针对这个异常进行恰当的处理。</p>\n<p>比如，我可以调整 <code>deactivate_users()</code> 方法，让它在每次调用 <code>deactivate()</code> 时都显式地捕获异常：</p>\n<pre class=\"code-rows\"><code>def deactivate_users(users: Iterable[User]):\n    \"\"\"批量停用多个用户\"\"\"\n    for user in users:\n        try:\n            user.deactivate()\n        except DeactivationNotSupported:\n            logger.info(\n                f'user  does not allow deactivating, skip.'\n            )</code></pre>\n<p>只要遵循父类的异常规范，当前的子类 <code>Admin</code> 对象以及未来可能出现的其他子类对象，都可以替代 <code>User</code> 对象。通过对异常做了一些微调，我们最终让代码满足了 LSP 的要求。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_174\">11.1.2　子类随意调整方法参数与返回值</h3>\n<p>通过上一节内容我们了解到，当子类方法随意抛出父类不认识的异常时，代码就会违反 LSP。除此之外，还有两种常见的违反 LSP 的情况，分别和子类方法的返回值与参数有关。</p>\n<ol>\n<li><p><strong>方法返回值违反 LSP</strong></p>\n<p>同样是前面的 <code>User</code> 类与 <code>Admin</code> 类，这次，我在类上添加了一个新的操作：</p>\n<pre class=\"code-rows\"><code>class User(Model):\n    \"\"\"普通用户类\"\"\"\n\n    ...\n\n    def list_related_posts(self) -&gt; List[int]:\n        \"\"\"查询所有与之相关的帖子 ID\"\"\"\n        return [\n            post.id\n            for post in session.query(Post).filter(username=self.username)\n        ]\n　\n　\nclass Admin(User):\n    \"\"\"管理员用户类\"\"\"\n\n    ...\n\n    def list_related_posts(self) -&gt; Iterable[int]:\n        # 管理员与所有帖子都有关，为了节约内存，使用生成器返回结果\n        for post in session.query(Post).all():\n            yield post.id</code></pre>\n<p>在上面的代码里，我给两个用户类增加了一个新方法：<code>list_related_posts()</code>，该方法会返回所有与当前用户有关的帖子 ID。对普通用户来说，“有关的帖子”指自己发布过的所有帖子；而对于管理员来说，“有关的帖子”指网站上的所有帖子。</p>\n<p>作为 <code>User</code> 的子类，<code>Admin</code> 的 <code>list_related_posts()</code> 方法返回值和父类并不完全一样。前者返回的是可迭代对象 <code>Iterable[int]</code>（通过生成器函数实现），而后者的方法返回值是列表对象：<code>List[int]</code>。</p>\n<p>那这种类型不一致究竟会不会违反 LSP 呢？我们来试试看。</p>\n<p>我写了一个函数，专门用来查询与用户相关的所有帖子标题：</p>\n<pre class=\"code-rows\"><code>def list_user_post_titles(user: User) -&gt; Iterable[str]:\n    \"\"\"获取与用户有关的所有帖子标题\"\"\"\n    for post_id in user.list_related_posts():\n        yield session.query(Post).get(post_id).title</code></pre>\n<p>对于这个函数来说，不论传入的 <code>user</code> 是 <code>User</code> 还是 <code>Admin</code> 对象，它都能正常工作。这是因为，虽然 <code>User</code> 和 <code>Admin</code> 的方法返回值类型不同，但它们都是可迭代的，都可以满足函数里循环的需求。</p>\n<p>既然如此，那上面的代码符合 LSP 吗？答案是否定的。因为虽然子类 <code>Admin</code> 对象可以替代父类 <code>User</code>，但这只是特殊场景下的一个巧合，并没有通用性。</p>\n<p>接下来看看第二个场景。</p>\n<p>有一位新同事加入了项目，他需要实现一个函数，来统计与用户有关的所有帖子数量。当他读到 <code>User</code> 类的代码时，发现 <code>list_related_posts()</code> 方法会返回一个包含所有帖子 ID 的列表，于是他就借助此方法编写了统计帖子数量的函数：</p>\n<pre class=\"code-rows\"><code>def get_user_posts_count(user: User) -&gt; int:\n    \"\"\"获取与用户相关的帖子数量\"\"\"\n    return len(user.list_related_posts())</code></pre>\n<p>在绝大多数情况下，上面的函数可以正常工作。</p>\n<p>但有一天，我偶然用一个管理员用户（<code>Admin</code>）调了上面的函数，程序马上就抛出了异常：<code>TypeError: object of type 'generator' has no len()</code>。</p>\n<p>虽然 <code>Admin</code> 是 <code>User</code> 的子类，但 <code>Admin</code> 类的 <code>list_related_posts()</code> 方法返回的并不是列表，而是一个不支持 <code>len()</code> 操作的生成器对象，因此程序肯定会报错。</p>\n<p>因此我们可以认定，现在 <code>User</code> 类的设计并不符合 LSP。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>调整返回值以符合 LSP</strong></p>\n<p>在我的代码里，<code>User</code> 类和 <code>Admin</code> 类的 <code>list_related_posts()</code> 返回了不同的结果。</p>\n<ul>\n<li><code>User</code> 类：返回列表对象 <code>List[int]</code>。</li>\n<li><code>Admin</code> 类：返回可迭代对象 <code>Iterable[int]</code>。</li>\n</ul>\n<p>很明显，二者之间存在共通点：它们都是可迭代的 <code>int</code> 对象，这也是为什么在第一个获取标题的场景里，子类对象可以替代父类。</p>\n<p>但要符合 LSP，子类方法与父类方法所返回的结果不能只是碰巧有一些共性。LSP 要求子类方法的返回值类型与父类完全一致，或者返回父类结果类型的子类对象。</p>\n<p>听上去有点儿绕，我来举个例子。</p>\n<p>假如我把之前两个类的方法返回值调换一下，让父类 <code>User</code> 的 <code>list_related_posts()</code> 方法返回 <code>Iterable[int]</code> 对象，让子类 <code>Admin</code> 的方法返回 <code>List[int]</code> 对象，这样的设计就完全符合 LSP，因为 <code>List</code> 是 <code>Iterable</code> 类型的子类：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; from collections.abc import Iterable\n&gt;&gt;&gt; issubclass(list, Iterable) ➊\nTrue</code></pre>\n<blockquote>\n<p>❶ 列表（以及所有容器类型）都是 <code>Iterable</code>（可迭代类型抽象类）的子类</p>\n</blockquote>\n<p>在这种情况下，当我用 <code>Admin</code> 对象替换 <code>User</code> 对象时，虽然方法返回值类型变了，但新的返回值支持旧返回值的所有操作（<code>List</code> 支持 <code>Iterable</code> 类型的所有操作——可迭代）。因此，所有依赖旧返回值（<code>Iterable</code>）的代码，都能拿着新的子类返回值（<code>List</code>）继续正常执行。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>方法参数违反 LSP</strong></p>\n<p>前面提到，要让代码符合 LSP，子类方法的返回值类型必须满足特定要求。除此以外，LSP 对子类方法的参数设计同样有一些要求。</p>\n<p>简单来说，要让子类符合 LSP，子类方法的参数必须与父类完全保持一致，或者，子类方法所接收的参数应该比父类更为抽象，要求更为宽松。</p>\n<p>第一条很好理解。大多数情况下，我们的子类方法不应该随意改动父类方法签名，否则就会违背 LSP。</p>\n<p>以下是一个错误示例：</p>\n<pre class=\"code-rows\"><code>class User(Model):\n    def list_related_posts(self, type: int) -&gt; List[int]: ...\n　\n　\nclass Admin(User):\n    def list_related_posts(self, include_hidden: bool) -&gt; List[int]: ... ➊</code></pre>\n<blockquote>\n<p>❶ 子类同名方法完全修改了方法参数，违反了 LSP</p>\n</blockquote>\n<p>不过，当子类方法参数与父类不一致时，有些特殊情况其实仍然可以满足 LSP。</p>\n<p>第一类情况是，子类方法可以接收比父类更多的参数，只要保证这些新增参数是可选的即可，比如：</p>\n<pre class=\"code-rows\"><code>class User(Model):\n    def list_related_posts(self) -&gt; List[int]: ...\n　\n　\nclass Admin(User):\n    def list_related_posts(self, include_hidden: bool = False) -&gt; List[int]: ... ➊</code></pre>\n<blockquote>\n<p>❶ 子类新增了可选参数 <code>include_hidden</code>，保证了与父类兼容。当其他人把 <code>Admin</code> 对象当作 <code>User</code> 使用时，不会破坏程序原本的功能</p>\n</blockquote>\n<p>第二类情况是，子类与父类参数一致，但子类的参数类型比父类的更抽象：</p>\n<pre class=\"code-rows\"><code>class User(Model):\n    def list_related_posts(self, titles=List[str]) -&gt; List[int]: ...\n　\n　\nclass Admin(User):\n    def list_related_posts(self, titles=Iterable[str]) -&gt; List[int]: ... ➊</code></pre>\n<blockquote>\n<p>❶ 子类的同名参数 <code>titles</code> 比父类更抽象。当调用方把 <code>Admin</code> 对象当作 <code>User</code> 使用时，按 <code>User</code> 的要求，传入的列表类型的 <code>titles</code> 参数仍然满足子类对 <code>titles</code> 参数的要求（是 <code>Iterable</code> 就行）</p>\n</blockquote>\n<p>简单总结一下，前面我展示了违反 LSP 的几种常见方式：</p>\n<ul>\n<li>子类抛出了父类所不认识的异常类型；</li>\n<li>子类的方法返回值类型与父类不同，并且该类型不是父类返回值类型的子类；</li>\n<li>子类的方法参数与父类不同，并且参数要求没有变得更宽松（可选参数）、同名参数没有更抽象。</li>\n</ul>\n<p>总体来说，这些违反 LSP 的做法都比较显式，比较容易发现。下面我们来看一类更隐蔽的违反 LSP 的做法。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_175\">11.1.3　基于隐式合约违反 LSP</h3>\n<p>在设计一个类时，有许多因素会影响 LSP。除了那些摆在明面上的、可见的方法参数和方法返回值类型以外，还有一些藏在类设计里的、不可见的东西。</p>\n<p>举个例子，在下面这段代码里，我实现了一个表示长方形的类：</p>\n<pre class=\"code-rows\"><code>class Rectangle:\n    def __init__(self, width: int, height: int):\n        self._width = width\n        self._height = height\n\n    @property\n    def width(self):\n        return self._width\n\n    @width.setter\n    def width(self, value: int):\n        self._width = value\n\n    @property\n    def height(self):\n        return self._height\n\n    @height.setter\n    def height(self, value: int):\n        self._height = value\n\n    def get_area(self) -&gt; int:\n        \"\"\"返回当前长方形的面积\"\"\"\n        return self.width * self.height</code></pre>\n<p>类的使用效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; r = Rectangle(width=3, height=5)\n&gt;&gt;&gt; r.get_area()\n15\n&gt;&gt;&gt; r.width = 4 ➊\n&gt;&gt;&gt; r.get_area()\n20</code></pre>\n<blockquote>\n<p>❶ 修改长方形的宽度，并重新计算面积</p>\n</blockquote>\n<p>某天，我接到一个新需求——增加一个新形状：正方形。我心想：正方形不就是一种特殊的长方形吗？于是我写了一个继承 <code>Rectangle</code> 的新类 <code>Square</code>：</p>\n<pre class=\"code-rows\"><code>class Square(Rectangle):\n    \"\"\"正方形\n\n    :param length: 边长\n    \"\"\"\n\n    def __init__(self, length: int): ➊\n        self._width = length\n        self._height = length\n\n    @property\n    def width(self):\n        return super().width\n\n    @width.setter\n    def width(self, value: int): ➋\n        self._width = value\n        self._height = value\n\n    @property\n    def height(self):\n        return super().height\n\n    @height.setter\n    def height(self, value: int):\n        self._width = value\n        self._height = value</code></pre>\n<blockquote>\n<p>❶ 初始化正方形时，只需要一个边长参数</p>\n<p>❷ 为了保证正方形形状，子类重写了 <code>width</code> 和 <code>height</code> 属性的 <code>setter</code> 方法，保持对象的宽与高永远一致</p>\n</blockquote>\n<p>接下来，我试用一下 <code>Square</code> 类：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; s = Square(3)\n&gt;&gt;&gt; s.get_area()\n9\n&gt;&gt;&gt; s.height = 4 ❶\n&gt;&gt;&gt; s.get_area()\n16</code></pre>\n<blockquote>\n<p>❶ 修改正方形的高后，正方形的宽也会随之变化</p>\n</blockquote>\n<p>看上去还不错，对吧？通过继承 <code>Rectangle</code>，我实现了新的正方形类。不过，虽然代码表面看上去没什么问题，但其实违反了 LSP。</p>\n<p>下面是一段针对长方形 <code>Rectangle</code> 编写的测试代码：</p>\n<pre class=\"code-rows\"><code>def test_rectangle_get_area(r: Rectangle):\n    r.width = 3\n    r.height = 5\n    assert r.get_area() == 15</code></pre>\n<p>假如你传入一个正方形对象 <code>Square</code>，会发现它根本无法通过这个测试，因为 <code>r.height = 5</code> 会同时修改正方形的 <code>width</code>，让最后的面积变成 <code>25</code>，而不是 <code>15</code>。</p>\n<p>在 <code>Rectangle</code> 类的设计中，有一个隐式的合约：长方形的宽和高应该总是可以单独修改，不会互相影响。上面的测试代码正是这个合约的一种表现形式。</p>\n<p>在这个场景下，子类 <code>Square</code> 对象并不能替换 <code>Rectangle</code> 使用，因此代码违反了 LSP。在真实项目中，这种因子类打破隐式合约违反 LSP 的情况，相比其他原因来说更难察觉，尤其需要当心。</p>\n<h3 id=\"nav_point_176\">11.1.4　LSP 小结</h3>\n<p>前面我描述了 SOLID 原则的第三条：LSP。</p>\n<p>在面向对象领域，当我们针对某个类型编写代码时，其实并不知道这个类型未来会派生出多少千奇百怪的子类型。我们只能根据当前看到的基类，尝试编写适用于未来子类的代码。</p>\n<p>假如这些子类不符合 LSP，那么面向对象所提供给我们的最大好处之一——多态，就不再可靠，变成了一句空谈。LSP 能促使我们设计出更合理的继承关系，将多态的潜能更好地激发出来。</p>\n<p>在编写代码时，假如你发现自己的设计违反了 LSP，就需要竭尽所能解决这个问题。有时你得在父类中引入新的异常类型，有时你得尝试用组合替代继承，有时你需要调整子类的方法参数。总之，只要深入思考类与类之间的关系，总会找到正确的解法。</p>\n<p>接下来，我将介绍 SOLID 原则的最后两条：</p>\n<ul>\n<li>ISP（接口隔离原则）</li>\n<li>DIP（依赖倒置原则）</li>\n</ul>\n<p>考虑到解释 DIP 的过程中，可以自然地引入 ISP 里的“接口”概念，因此先介绍 DIP，后介绍 ISP。</p>\n<h2 id=\"nav_point_177\">11.2　DIP：依赖倒置原则</h2>\n<p>不论多复杂的程序，都是由一个个模块组合而成的。当你告诉别人：“我正在写一个很复杂的程序”时，你其实并不是直接在写那个程序，而是在逐个完成它的模块，最后用这些模块组成程序。</p>\n<p>在用模块组成程序的过程中，模块间自然产生了依赖关系。举个例子，你的个人博客站点可能依赖 Flask 模块，而 Flask 依赖 Werkzeug，Werkzeug 又由多个低层模块组成。</p>\n<p>在正常的软件架构中，模块间的依赖关系应该是单向的，一个高层模块往往会依赖多个低层模块。整个依赖图就像一条蜿蜒而下、不断分叉的河流。</p>\n<p>DIP 是一条与依赖关系相关的原则。它认为：<strong>高层模块不应该依赖低层模块，二者都应该依赖抽象</strong>。</p>\n<p>乍一看，这个原则有些违反我们的常识——高层模块不就是应该依赖低层模块吗？还记得第一堂编程课上，在我学会编写 Hello World 程序时，高层模块（<code>main()</code> 函数）分明依赖了低层模块（<code>printf()</code>）。</p>\n<p>高层依赖低层明明是常识，为何 DIP 却说不要这样做呢？DIP 里的“倒置”具体又是什么意思？</p>\n<p>我们先把这些问题放在一旁，进入下面的案例研究。假如一切顺利，也许我们能在这个案例里找到这些问题的答案。</p>\n<h3 id=\"nav_point_178\">11.2.1　案例：按来源统计 Hacker News 条目数量</h3>\n<p>还记得在第 10 章中，我们写了一个抓取 Hacker News 热门内容的程序吗？这次，我想继续针对 Hacker News 做一些统计工作。</p>\n<p>在 Hacker News 上，每个由用户提交的条目后面都跟着它的来源域名。为了统计哪些站点在 Hacker News 上最受欢迎，我想编写一个脚本，用它来分组统计每个来源站点的条目数量，如图 11-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00390.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-1　Hacker News 条目来源截图</strong></p>\n<p>这个需求并不复杂。利用 <code>requests</code> 和 <code>collections</code> 模块，我很轻松地就完成了任务，如代码清单 11-1 所示。</p>\n<blockquote>\n<p><strong>代码清单 11-1</strong>　统计 Hacker News 新闻来源分组脚本 hn_site_grouper.py</p>\n</blockquote>\n<pre class=\"code-rows\"><code>class SiteSourceGrouper:\n    \"\"\"对 Hacker News 新闻来源站点进行分组统计\n\n    :param url: Hacker News 首页地址\n    \"\"\"\n\n    def __init__(self, url: str):\n        self.url = url\n\n    def get_groups(self) -&gt; Dict[str, int]:\n        \"\"\"获取 (域名, 个数) 分组\"\"\"\n        resp = requests.get(self.url)\n        html = etree.HTML(resp.text)\n        # 通过 XPath 语法筛选新闻域名标签\n        elems = html.xpath(\n            '//table[@class=\"itemlist\"]//span[@class=\"sitestr\"]'\n        )\n\n        groups = Counter()\n        for elem in elems:\n            groups.update([elem.text])\n        return groups\n\n\ndef main():\n    groups = SiteSourceGrouper(\"https://news.ycombinator.com/\").get_groups()\n    # 打印最常见的 3 个域名\n    for key, value in groups.most_common(3):\n        print(f'Site:  | Count: ')</code></pre>\n<p>脚本执行结果如下：</p>\n<pre class=\"code-rows\"><code>$ python hn_site_grouper.py\nSite: github.com | Count: 2\nSite: howonlee.github.io | Count: 1\nSite: latimes.com | Count: 1</code></pre>\n<p>脚本很短，核心代码加起来不到 20 行，但里面仍然藏着一条依赖关系链。</p>\n<p><code>SiteSourceGrouper</code> 是我们的核心类。为了完成统计任务，它需要先用 <code>requests</code> 模块抓取网页，再用 <code>lxml</code> 模块解析网页。从层级上来说，<code>SiteSourceGrouper</code> 是高层模块，<code>requests</code> 和 <code>lxml</code> 是低层模块，依赖关系是正向的，如图 11-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00391.jpeg\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-2　<code>SiteSourceGrouper</code> 依赖 <code>requests</code>、<code>lxml</code></strong></p>\n<p>看到图 11-2，也许你会觉得特别合理——这不就是正常的依赖关系吗？别着急，接下来我们给脚本写一些单元测试。</p>\n<h3 id=\"nav_point_179\">11.2.2　为脚本编写单元测试</h3>\n<p>为了测试程序的正确性，我为脚本写了一些单元测试：</p>\n<pre class=\"code-rows\"><code>from hn_site_grouper import SiteSourceGrouper\nfrom collections import Counter\n\ndef test_grouper_returning_valid_type(): ➊\n    \"\"\"测试 get_groups 是否返回了正确类型\"\"\"\n    grouper = SiteSourceGrouper('https://news.ycombinator.com/')\n    result = grouper.get_groups()\n    assert isinstance(result, Counter), \"groups should be Counter instance\"</code></pre>\n<blockquote>\n<p>❶ 这个单元测试基于 <code>pytest</code> 风格编写，执行它需要使用 <code>pytest</code> 测试工具</p>\n</blockquote>\n<p>上面的测试逻辑非常简单，我首先调用了 <code>get_groups()</code> 方法，然后判断它的返回值类型是否正确。</p>\n<p>在本地开发时，这个测试用例可以正常执行，没有任何问题。但当我提交了测试代码，想在 CI<span class=\"comment-number\">1</span> 服务器上自动执行测试时，却发现根本无法完成测试。</p>\n\n<p>报错信息如下：</p>\n<pre class=\"code-rows\"><code>requests.exceptions.ConnectionError: HTTPSConnectionPool(host='news.ycombinator.com', port=443): ... ... [Errno 8] nodename nor servname provided, or not known'))</code></pre>\n<p>这时我才想起来，我的 CI 环境根本就不能访问外网！</p>\n<p>你可以发现，上面的单元测试暴露了 <code>SiteSourceGrouper</code> 类的一个问题：它的执行链路依赖 <code>requests</code> 模块和网络条件，这严格限制了单元测试的执行环境。</p>\n<p>既然如此，怎么才能解决这个问题呢？假如你去请教有经验的 Python 开发者，他很可能会直接甩给你一句话：用 <code>mock</code> 啊！</p>\n<h4>使用 <code>mock</code> 模块</h4>\n<p><code>mock</code> 是测试领域的一个专有名词，代表一类特殊的测试假对象。</p>\n<p>假如你的代码依赖了其他模块，但你在执行单元测试时不想真正调用这些依赖的模块，那么你可以选择用一些特殊对象替换真实模块，这些用于替换的特殊对象常被统称为 <code>mock</code>。</p>\n<p>在 Python 里，单元测试模块 <code>unittest</code> 为我们提供了一个强大的 <code>mock</code> 子模块，里面有许多和 <code>mock</code> 技术有关的工具，如下所示。</p>\n<ul>\n<li><code>Mock</code>：<code>mock</code> 主类型，<code>Mock()</code> 对象被调用后不执行任何逻辑，但是会记录被调用的情况——包括次数、参数等。</li>\n<li><code>MagicMock</code>：在 <code>Mock</code> 类的基础上追加了对魔法方法的支持，是 <code>patch()</code> 函数所使用的默认类型。</li>\n<li><code>patch()</code>：补丁函数，使用时需要指定待替换的对象，默认使用一个 <code>MagicMock()</code> 替换原始对象，可当作上下文管理器或装饰器使用。</li>\n</ul>\n<p>对于我的脚本来说，假如用 <code>unittest.mock</code> 模块来编写单元测试，我需要做以下几件事：</p>\n<p>(1) 把一份正确的 Hacker News 页面内容保存为本地文件 static_hn.html；</p>\n<p>(2) 用 <code>mock</code> 对象替换真实的网络请求行为；</p>\n<p>(3) 让 <code>mock</code> 对象返回文件 static_hn.html 的内容。</p>\n<p>使用 <code>mock</code> 的测试代码如下所示：</p>\n<pre class=\"code-rows\"><code>from unittest import mock\n\n\n@mock.patch('hn_site_grouper.requests.get') ➊\ndef test_grouper_returning_valid_type(mocked_get): ➋\n    \"\"\"测试 get_groups 是否返回了正确类型\"\"\"\n    with open('static_hn.html', 'r') as fp:\n        mocked_get.return_value.text = fp.read() ➌\n\n    grouper = SiteSourceGrouperO('https://news.ycombinator.com/')\n    result = grouper.get_groups()\n    assert isinstance(result, Counter), \"groups should be Counter instance\"</code></pre>\n<blockquote>\n<p>❶ 通过 <code>patch</code> 装饰器将 <code>requests.get</code> 函数替换为一个 <code>MagicMock</code> 对象</p>\n<p>❷ 该 <code>MagicMock</code> 对象将会作为函数参数被注入</p>\n<p>❸ 将 <code>get()</code> 函数的返回结果（自动生成的另一个 <code>MagicMock</code> 对象）的 <code>text</code> 属性替换为来自本地文件的内容</p>\n</blockquote>\n<p>通过 <code>mock</code> 技术，我们最终让单元测试不再依赖网络环境，可以成功地在 CI 环境中执行。</p>\n<p>平心而论，当你了解了 <code>mock</code> 模块的基本用法后，就不会觉得上面的代码有多么复杂。但问题是，即便代码不复杂，上面的处理方式仍非常糟糕，我们一起来看看这是为什么。</p>\n<p>当我们编写单元测试时，有一条非常重要的指导原则：<strong>测试程序的行为，而不是测试具体实现</strong>。它的意思是，好的单元测试应该只关心被测试对象功能是否正常，是否能做好它所宣称的事情，而不应该关心被测试对象内部的具体实现是什么样的。</p>\n<p>为什么单元测试不能关心内部实现？这是有原因的。</p>\n<p>在编写代码时，我们常会修改类的具体实现，但很少会调整类的行为。如果测试代码过分关心类的内部实现，就会变得很脆弱。举个例子，假如有一天我发现了一个速度更快的网络请求模块：<code>fast_requests</code>，我想用它替换程序里的 <code>requests</code> 模块。但当我完成替换后，即便 <code>SiteSourceGrouper</code> 的功能和替换前完全一致，我仍然需要修改上面的测试代码，替换里面的 <code>@mock.patch('hn_site_grouper.requests.get')</code> 部分，平添了许多工作量。</p>\n<p>正因为如此，<code>mock</code> 应该总是被当作一种应急的技术，而不是一种低成本、让单元测试能快速开展的手段。大多数情况下，假如你的单元测试代码里有太多 <code>mock</code>，往往代表你的程序设计得不够合理，需要改进。</p>\n<p>既然 <code>mock</code> 方案不够理想，下面我们试试从“依赖关系”入手，看看 DIP 能给我们提供什么帮助。</p>\n<h3 id=\"nav_point_180\">11.2.3　实现 DIP</h3>\n<p>首先，我们回顾一下 DIP 的内容：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。但在上面的代码里，高层模块 <code>SiteSourceGrouper</code> 就直接依赖了低层模块 <code>requests</code>。</p>\n<p>为了让代码符合 DIP，我们的首要任务是创造一个“抽象”。但话又说回来，DIP 里的“抽象”到底指什么？</p>\n<p>在 7.3.2 节中，我简单介绍过“抽象”的含义。当时我说：抽象是一种选择特征、简化认知的手段，而这是对抽象的一种广义解释。DIP 里的“抽象”是一种更具体的东西。</p>\n<p>DIP 里的“抽象”特指编程语言里的一类特殊对象，这类对象只声明一些公开的 API，并不提供任何具体实现。比如在 Java 中，接口就是一种抽象。下面是一个提供“画”动作的接口：</p>\n<pre class=\"code-rows\"><code>interface Drawable {\n  public void draw();\n}</code></pre>\n<p>而 Python 里并没有上面这种接口对象，但有一个和接口非常类似的东西——抽象类：</p>\n<pre class=\"code-rows\"><code>from abc import ABC, abstractmethod\n\nclass Drawable(ABC):\n    @abstractmethod\n    def draw(self):\n        ...</code></pre>\n<p>搞清楚“抽象”是什么后，接着就是 DIP 里最重要的一步：设计抽象，其主要任务是确定这个抽象的职责与边界。</p>\n<p>在上面的脚本里，高层模块主要依赖 <code>requests</code> 模块做了两件事：</p>\n<p>(1) 通过 <code>requests.get()</code> 获取响应 <code>response</code> 对象；</p>\n<p>(2) 利用 <code>response.text</code> 获取响应文本。</p>\n<p>可以看出，这个依赖关系的主要目的是获取 Hacker News 的页面文本。因此，我可以创建一个名为 <code>HNWebPage</code> 的抽象，让它承担“提供页面文本”的职责。</p>\n<p>下面的 <code>HNWebPage</code> 抽象类就是实现 DIP 的关键：</p>\n<pre class=\"code-rows\"><code>from abc import ABC, abstractmethod\n\nclass HNWebPage(ABC):\n    \"\"\"抽象类：Hacker News 站点页面\"\"\"\n\n    @abstractmethod\n    def get_text(self) -&gt; str:\n        raise NotImplementedError()</code></pre>\n<p>定义好抽象后，接下来分别让高层模块和低层模块与抽象产生依赖关系。我们从低层模块开始。</p>\n<p>低层模块与抽象间的依赖关系表现为它会提供抽象的具体实现。在下面的代码里，我实现了 <code>RemoteHNWebPage</code> 类，它的作用是通过 <code>requests</code> 模块请求 Hacker News 页面，返回页面内容：</p>\n<pre class=\"code-rows\"><code>class RemoteHNWebPage(HNWebPage): ➊\n    \"\"\"远程页面，通过请求 Hacker News 站点返回内容\"\"\"\n\n    def __init__(self, url: str):\n        self.url = url\n\n    def get_text(self) -&gt; str:\n        resp = requests.get(self.url)\n        return resp.text</code></pre>\n<blockquote>\n<p>❶ 此时的依赖关系表现为类与类的继承。除继承外，与抽象类的依赖关系还有许多其他表现形式，比如使用抽象类的 <code>.register()</code> 方法，或者定义子类化钩子方法，等等。详情可参考 9.1.4 节</p>\n</blockquote>\n<p>处理完低层模块的依赖关系后，接下来我们需要调整高层模块 <code>SiteSourceGrouper</code> 类的代码：</p>\n<pre class=\"code-rows\"><code>class SiteSourceGrouper:\n    \"\"\"对 Hacker News 页面的新闻来源站点进行分组统计\"\"\"\n\n    def __init__(self, page: HNWebPage): ➊\n        self.page = page\n\n    def get_groups(self) -&gt; Dict[str, int]:\n        \"\"\"获取 (域名, 个数) 分组\"\"\"\n        html = etree.HTML(self.page.get_text()) ➋\n        ...\n\n\ndef main():\n    page = RemoteHNWebPage(url=\"https://news.ycombinator.com/\") ➌\n    grouper = SiteSourceGrouper(page).get_groups()</code></pre>\n<blockquote>\n<p>❶ 在初始化方法里，我用类型注解表明了所依赖的是抽象的 <code>HNWebPage</code> 类型</p>\n<p>❷ 调用 <code>HNWebPage</code> 类型的 <code>get_text()</code> 方法，获取页面文本内容</p>\n<p>❸ 实例化一个符合抽象 <code>HNWebPage</code> 的具体实现：<code>RemoteHNWebPage</code> 对象</p>\n</blockquote>\n<p>做完这些修改后，我们再看看现在的模块依赖关系，如图 11-3 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00392.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-3　<code>SiteSourceGrouper</code> 和 <code>RemoteHNWebPage</code> 都依赖抽象 <code>HNWebPage</code></strong></p>\n<p>可以看到，图 11-3 里的高层模块不再直接依赖低层模块，而是依赖处于中间的抽象：<code>HNWebPage</code>。低层模块也不再是被依赖的一方，而是反过来依赖处于上方的抽象层，这便是 DIP 里 inversion（倒置）一词的由来。</p>\n<h3 id=\"nav_point_181\">11.2.4　倒置后的单元测试</h3>\n<p>通过创建抽象实现 DIP 后，我们回到之前的单元测试问题。为了满足单元测试的无网络需求，基于 <code>HNWebPage</code> 抽象类，我可以实现一个不依赖网络的新类型 <code>LocalHNWebPage</code>：</p>\n<pre class=\"code-rows\"><code>class LocalHNWebPage(HNWebPage):\n    \"\"\"本地页面，根据本地文件返回页面内容\n\n    :param path: 本地文件路径\n    \"\"\"\n\n    def __init__(self, path: str):\n        self.path = path\n\n    def get_text(self) -&gt; str:\n        with open(self.path, 'r') as fp:\n            return fp.read()</code></pre>\n<p>单元测试代码也可以进行相应的调整：</p>\n<pre class=\"code-rows\"><code>def test_grouper_from_local():\n    page = LocalHNWebPage(path=\"./static_hn.html\")\n    grouper = SiteSourceGrouper(page)\n    result = grouper.get_groups()\n    assert isinstance(result, Counter), \"groups should be Counter instance\"</code></pre>\n<p>有了额外的抽象后，我们解耦了 <code>SiteSourceGrouper</code> 里的外网访问行为。现在的测试代码不需要任何 <code>mock</code> 技术，在无法访问外网的 CI 服务器上也能正常执行。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00372.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　为了演示，我对单元测试逻辑进行了极大的简化，其实上面的代码远算不上是一个合格的测试用例。在真实项目里，你应该准备一个虚构的 Hacker News 页面，里面刚好包含 <em>N</em> 个 来源自 foo.com 的条目，然后判断 <code>assert result['foo.com'] == N</code>，这样才能真正验证 <code>SiteSourceGrouper</code> 的核心逻辑是否正常。</p>\n</blockquote>\n<h3 id=\"nav_point_182\">11.2.5　DIP 小结</h3>\n<p>通过前面的样例我们了解到，DIP 要求代码在互相依赖的模块间创建新的抽象概念。当高层模块依赖抽象而不是具体实现后，我们就能更方便地用其他实现替换底层模块，提高代码灵活性。</p>\n<p>以下是有关 DIP 的两点额外思考。</p>\n<ol>\n<li><p><strong>退后一步是“鸭子”，向前一步是“协议”</strong></p>\n<p>为了实现 DIP，我在上面的例子中定义了抽象类：<code>HNWebPage</code>。但正如我在第 10 章中所说，在这个例子里，同样可以去掉抽象类——并非只有抽象类才能让依赖关系倒过来。</p>\n<p>如果在抽象类方案下，往后退一步，从代码里删掉抽象类，同时删掉所有的类型注解，你会发现代码仍然可以正常执行。在这种情况下，依赖关系仍然是倒过来的，但是处在中间的“抽象”变成了一个隐式概念。</p>\n<p>没有抽象类后，代码变成了“鸭子类型”，依赖倒置也变成了一种符合“鸭子类型”的倒置。</p>\n<p>反过来，假如你对“抽象”的要求更为严格，往前走一步，马上就会发现 Python 里的抽象类其实并非完全抽象。比如在抽象类里，你不光可以定义抽象方法，甚至可以把它当成普通基类，提供许多有具体实现的工具方法。</p>\n<p>那么除了抽象类以外，还有没有其他更严格的抽象方案呢？答案是肯定的。</p>\n<p>在 Python 3.8 版本里，类型注解 <code>typing</code> 模块增加了一个名为“协议”（<code>Protocol</code>）的类型。从各种意义上来说，<code>Protocol</code> 都比抽象类更接近传统的“接口”。</p>\n<p>下面是用 <code>Protocol</code> 实现的 <code>HNWebPage</code>：</p>\n<pre class=\"code-rows\"><code>class HNWebPage(Protocol):\n    \"\"\"协议：Hacker News 站点页面\"\"\"\n\n    def get_text(self) -&gt; str:\n        ...</code></pre>\n<p>虽然 <code>Protocol</code> 提供了定义协议的能力，但像类型注解一样，它并不提供运行时的协议检查，它的真正实力仍然需要搭配 mypy 才能发挥出来。</p>\n<p>通过 <code>Protocol</code> 与 mypy 类型检查工具，你能实现真正的基于协议的抽象与结构化子类技术。也就是说，只要某个类实现了 <code>get_text()</code> 方法，并且返回了 <code>str</code> 类型，那么它便可以当作 <code>HNWebPage</code> 使用。</p>\n<p>不过，<code>Protocol</code> 与 mypy 的上手门槛较高，如果不是大型项目，实在没必要使用。在多数情况下，普通的抽象类或鸭子类型已经够用了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>抽象一定是好的吗</strong></p>\n<p>有关 DIP 的全部内容，基本都是在反复说同一件事：抽象是好东西，抽象让代码变得更灵活。但是，抽象多的代码真的就更好吗？缺少抽象的代码就一定不够灵活吗？</p>\n<p>和所有这类问题的标准回答一样，答案是：视情况而定。</p>\n<p>当你习惯了 DIP 以后，会发现抽象不仅仅是一种编程手法，更是一种思考问题的特殊方式。只要愿意动脑子，你可以在代码的任何角落里都硬挤出一层额外抽象。</p>\n<ul>\n<li>代码依赖了 lxml 模块的 XPath 具体实现，假如 lxml 模块未来要改怎么办？我是不是得定义一层 <code>HNTitleDigester</code> 把它抽象进去？</li>\n<li>代码里的字符串字面量也是具体实现，万一以后要用其他字符串类型怎么办？我是不是得定义一个 <code>StringLike</code> 类型把它抽象进去？</li>\n<li>……</li>\n</ul>\n<p>如果真像上面这样思考，代码里似乎不再有真正可靠的东西，我们的大脑很快就会不堪重负。</p>\n<p>事实是，抽象的好处显而易见：它解耦了模块间的依赖关系，让代码变得更灵活。但抽象同时也带来了额外的编码与理解成本。所以，了解何时不抽象与何时抽象同样重要。只有对代码中那些容易变化的东西进行抽象，才能获得最大的收益。</p>\n<p>下面我们学习最后一条原则：ISP。</p>\n</li>\n</ol>\n<h2 id=\"nav_point_183\">11.3　ISP：接口隔离原则</h2>\n<p>顾名思义，这是一条与“接口”有关的原则。</p>\n<p>在上一节中我描述过接口的定义。接口是编程语言里的一类特殊对象，它包含一些公开的抽象协议，可以用来构建模块间的依赖关系。在不同的编程语言里，接口有不同的表现形态。在 Python 中，接口可以是抽象类、<code>Protocol</code>，也可以是鸭子类型里的某个隐式概念。</p>\n<p>接口是一种非常有用的设计工具，为了更好地发挥它的能力，ISP 对如何使用接口提出了要求：<strong>客户</strong>（client）不应该依赖任何它不使用的方法。</p>\n<p>ISP 里的“客户”不是使用软件的客户，而是接口的使用方——客户模块，也就是依赖接口的高层模块。</p>\n<p>拿上一节统计 Hacker News 页面条目的例子来说：</p>\n<ul>\n<li>使用方（客户模块）——<code>SiteSourceGrouper</code>；</li>\n<li>接口（其实是抽象类）——<code>HNWebPage</code>；</li>\n<li>依赖关系——调用接口方法 <code>get_text()</code> 获取页面文本。</li>\n</ul>\n<p>按照 ISP，一个接口所提供的方法应该刚好满足使用方的需求，一个不多，一个不少。在例子里，我设计的接口 <code>HNWebPage</code> 就是符合 ISP 的，因为它没有提供任何使用方不需要的方法。</p>\n<p>看上去，ISP 似乎比较容易遵守。但违反 ISP 究竟会带来什么后果呢？我们接着上个例子，通过一个新需求来试试违反 ISP。</p>\n<h3 id=\"nav_point_184\">11.3.1　案例：处理页面归档需求</h3>\n<p>在上一节的例子中，我编写了一个代表 Hacker News 站点页面的抽象类 <code>HNWebPage</code>，它只提供一种行为——获取当前页面的文本内容：</p>\n<pre class=\"code-rows\"><code>class HNWebPage(ABC):\n    \"\"\"抽象类：Hacker News 站点页面\"\"\"\n\n    @abstractmethod\n    def get_text(self) -&gt; str:\n        raise NotImplementedError()</code></pre>\n<p>现在，我想开发一个新功能：定期对 Hacker News 首页内容进行归档，观察热点新闻在不同时间点的变化规律。因此，除了页面文本内容外，我还需要获取页面大小、生成时间等额外信息。</p>\n<p>为了实现这个功能，我们可以对 <code>HNWebPage</code> 抽象类做一些扩展：</p>\n<pre class=\"code-rows\"><code>class HNWebPage(metaclass=ABC):\n\n    @abstractmethod\n    def get_text(self) -&gt; str:\n        \"\"\"获取页面文本内容\"\"\"\n\n    # 新增 get_size 与 get_generated_at\n\n    @abstractmethod\n    def get_size(self) -&gt; int:\n        \"\"\"获取页面大小\"\"\"\n\n    @abstractmethod\n    def get_generated_at(self) -&gt; datetime.datetime:\n        \"\"\"获取页面生成时间\"\"\"</code></pre>\n<p>我们在抽象类上增加了两个新方法：<code>get_size()</code> 和 <code>get_generated_at()</code>。通过这两个方法，程序就能获取页面大小和生成时间了。</p>\n<p>修改完抽象类后，接下来的任务是调整抽象类的具体实现。</p>\n<h3 id=\"nav_point_185\">11.3.2　修改实体类</h3>\n<p>在调整接口前，我有两个实现了接口协议的实体类型：<code>RemoteHNWebPage</code> 和 <code>LocalHNWebPage</code>。如今 <code>HNWebPage</code> 接口增加了两个新方法，我自然需要修改这两个实体类，给它们加上这两个新方法。</p>\n<p>修改 <code>RemoteHNWebPage</code> 类很容易，只要让 <code>get_size()</code> 返回页面长度，<code>get_generated_at()</code> 返回当前时间即可：</p>\n<pre class=\"code-rows\"><code>class RemoteHNWebPage(HNWebPage):\n    \"\"\"远程页面，通过请求 Hacker News 站点返回内容\"\"\"\n\n    def __init__(self, url: str):\n        self.url = url\n        # 保存当前请求结果\n        self._resp = None\n        self._generated_at = None\n\n    def get_text(self) -&gt; str:\n        \"\"\"获取页面内容\"\"\"\n        self._request_on_demand()\n        return self._resp.text\n\n    def get_size(self) -&gt; int:\n        \"\"\"获取页面大小\"\"\"\n        return len(self.get_text())\n\n    def get_generated_at(self) -&gt; datetime.datetime:\n        \"\"\"获取页面生成时间\"\"\"\n        self._request_on_demand()\n        return self._generated_at\n\n    def _request_on_demand(self): ➊\n        \"\"\"请求远程地址并避免重复\"\"\"\n        if self._resp is None:\n            self._resp = requests.get(self.url)\n            self._generated_at = datetime.datetime.now()</code></pre>\n<blockquote>\n<p>❶ 因为使用方可能会反复调用 <code>get_generated_at()</code> 等方法，所以我给类添加了一个简单的结果缓存功能</p>\n</blockquote>\n<p>完成 <code>RemoteHNWebPage</code> 类的修改后，接下来修改 <code>LocalHNWebPage</code> 类。但是，在给它添加 <code>get_generated_at()</code> 的过程中，我遇到了一个小问题。</p>\n<p><code>LocalHNWebPage</code> 的页面数据完全来源于本地文件，但仅仅通过一个本地文件，我根本就无法知道它的内容是何时生成的。</p>\n<p>这时，有两个选择摆在我们面前：</p>\n<p>(1) 让 <code>get_generated_at()</code> 返回一个错误结果，比如本地文件的修改时间；</p>\n<p>(2) 让 <code>get_generated_at()</code> 方法直接抛出 <code>NotImplementedError</code> 异常。</p>\n<p>但不论哪种做法，都不符合接口方法的定义，都很糟糕。所以，对 <code>HNWebPage</code> 接口的盲目扩展暴露出一个问题：更丰富的接口协议，意味着更高的实现成本，也更容易给实现方带来麻烦。</p>\n<p>不过，我们暂且把这个问题放到一旁，先让 <code>LocalHNWebPage.get_generated_at()</code> 直接抛出异常，继续编写 <code>SiteAchiever</code> 类，补完页面归档功能链条：</p>\n<pre class=\"code-rows\"><code>class SiteAchiever:\n    \"\"\"将不同时间点的 Hacker News 页面归档\"\"\"\n\n    def save_page(self, page: HNWebPage):\n        \"\"\"将页面保存到后端数据库\"\"\"\n        data = {\n            \"content\": page.get_text(),\n            \"generated_at\": page.get_generated_at(),\n            \"size\": page.get_size(),\n        }\n        # 将 data 保存到数据库中\n        # ...</code></pre>\n<h3 id=\"nav_point_186\">11.3.3　违反 ISP</h3>\n<p>完成整个页面归档任务后，不知道你是否还记得上一节的“按 Hacker News 来源统计条目数量”程序。现在所有模块间的依赖关系如图 11-4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00393.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-4　页面归档功能类关系图</strong></p>\n<p>仔细看图 11-4，有没有发现什么问题？</p>\n<ul>\n<li>问题 1：<code>SiteSourceGrouper</code> 类依赖了 <code>HNWebPage</code>，但是并不使用后者的 <code>get_size()</code>、<code>get_generated_at()</code> 方法。</li>\n<li>问题 2：<code>LocalHNWebPage</code> 类为了实现 <code>HNWebPage</code> 抽象，需要“退化”<code>get_generated_at()</code> 方法。</li>\n</ul>\n<p>你会发现，在我扩展完 <code>HNWebPage</code> 抽象类后，虽然按来源分组类 <code>SiteSourceGrouper</code> 仍然依赖 <code>HNWebPage</code>，但它其实只用到了 <code>get_text()</code> 这一个方法而已。</p>\n<p>上面的设计明显违反了 ISP。为了修复这个问题，我需要把大接口拆分成多个小接口。</p>\n<h3 id=\"nav_point_187\">11.3.4　分拆接口</h3>\n<p>在设计接口时有一个简单的技巧：让客户（调用方）来驱动协议设计。在现在的程序里，<code>HNWebPage</code> 接口共有两个客户。</p>\n<ul>\n<li><code>SiteSourceGrouper</code>：按域名来源统计，依赖 <code>get_text()</code>。</li>\n<li><code>SiteAchiever</code>：页面归档程序，依赖 <code>get_text()</code>、<code>get_size()</code> 和 <code>get_generated_at()</code>。</li>\n</ul>\n<p>根据这两个客户的需求，我可以把 <code>HNWebPage</code> 分离成两个不同的抽象类：</p>\n<pre class=\"code-rows\"><code>class ContentOnlyHNWebPage(ABC):\n    \"\"\" 抽象类：Hacker News 站点页面（仅提供内容）\"\"\"\n\n    @abstractmethod\n    def get_text(self) -&gt; str:\n        raise NotImplementedError()\n\n\nclass HNWebPage(ABC):\n    \"\"\" 抽象类：Hacker New 站点页面（含元数据）\"\"\"\n\n    @abstractmethod\n    def get_text(self) -&gt; str:\n        raise NotImplementedError()\n\n    @abstractmethod\n    def get_size(self) -&gt; int:\n        \"\"\" 获取页面大小\"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def get_generated_at(self) -&gt; datetime.datetime:\n        \"\"\" 获取页面生成时间\"\"\"\n        raise NotImplementedError()</code></pre>\n<p>完成拆分后，<code>SiteSourceGrouper</code> 和 <code>SiteAchiever</code> 便能各自依赖不同的抽象类了。</p>\n<p>同时，对于 <code>LocalHNWebPage</code> 类来说，它也不需要再纠结如何实现 <code>get_generated_at()</code> 方法，而只要认准那个只返回文本的 <code>ContentOnlyHNWebPage</code> 接口，实现其中的 <code>get_text()</code> 方法就行，如图 11-5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00394.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-5　实施接口隔离后的结果</strong></p>\n<p>从图 11-5 中可以看出，相比之前，符合 ISP 的依赖关系看起来要清爽得多。</p>\n<h3 id=\"nav_point_188\">11.3.5　其他违反 ISP 的场景</h3>\n<p>虽然我花了很长的篇幅，用了好几个抽象类才把 ISP 讲明白，但其实在日常编码中，违反 ISP 的例子并不少见，它常常出现在一些容易被我们忽视的地方。</p>\n<p>举个例子，在开发 Web 站点时，我们常常需要判断用户请求的 Cookies 或请求头（HTTP request header）里，是否包含某个标记值。为此，我们经常直接写出许多依赖整个 <code>request</code> 对象的函数：</p>\n<pre class=\"code-rows\"><code>def is_new_visitor(request: HttpRequest) -&gt; bool:\n    \"\"\"从 Cookies 判断是否新访客\"\"\"\n    return request.COOKIES.get('is_new_visitor') == 'y'</code></pre>\n<p>但事实上，除了 <code>COOKIES</code> 以外，<code>is_new_visitor()</code> 根本不需要 <code>request</code> 对象里面的任何其他内容。</p>\n<p>因此，我们完全可以把函数改成只接收 <code>cookies</code> 字典：</p>\n<pre class=\"code-rows\"><code>def is_new_visitor(cookies: Dict) -&gt; bool:\n    \"\"\"从 Cookies 判断是否为新访客\"\"\"\n    return cookies.get('is_new_visitor') == 'y'</code></pre>\n<p>类似的情况还有许多，比如一个负责发短信的函数，本身只需要两个参数：电话号码（<code>phone_number</code>）和用户姓名（<code>username</code>），但是函数依赖了整个用户对象（<code>User</code>），里面包含了几十个它根本不关心的其他字段和方法。</p>\n<p>所有这些问题，既是抽象上的一种不合理，也可以视作 ISP 的一种反例。</p>\n<blockquote>\n<p><strong>现实世界里的接口隔离</strong></p>\n<p>当你认识到 ISP 带来的种种好处后，很自然地会养成写小类、小接口的习惯。在现实世界里，其实已经有很多小而精的接口设计可供参考，比如：</p>\n<ul>\n<li>Python 的 <code>collections.abc</code> 模块里面有非常多的小接口；</li>\n<li>Go 语言标准库里的 Reader 和 Writer 接口。</li>\n</ul>\n</blockquote>\n<h2 id=\"nav_point_189\">11.4　总结</h2>\n<p>在本章中，我们学习了 SOLID 原则的后三条：</p>\n<ul>\n<li>LSP（里式替换原则）；</li>\n<li>DIP（依赖倒置原则）；</li>\n<li>ISP（接口隔离原则）。</li>\n</ul>\n<p>LSP 与继承有关。在设计继承关系时，我们常常会让子类重写父类的某些行为，但一些不假思索的随意重写，会导致子类对象无法完全替代父类对象，最终让代码的灵活性大打折扣。</p>\n<p>DIP 要求我们在高层与底层模块之间创建出抽象概念，以此反转模块间的依赖关系，提高代码灵活性。但抽象并非没有代价，只有对最恰当的事物进行抽象，才能获得最大的收益。</p>\n<p>DIP 鼓励我们创建抽象，ISP 指导我们如何创建出好的抽象。好的抽象应该是精准的，没有任何多余内容。</p>\n<p>至此，SOLID 原则的所有内容就都介绍完毕了。</p>\n<p>以下是本章要点知识总结。</p>\n<p>(1) LSP</p>\n<ul>\n<li>LSP 认为子类应该可以任意替代父类使用</li>\n<li>子类不应该抛出父类不认识的异常</li>\n<li>子类方法应该返回与父类一致的类型，或者返回父类返回值的子类型对象</li>\n<li>子类的方法参数应该和父类方法完全一致，或者要求更为宽松</li>\n<li>某些类可能会存在隐式合约，违反这些合约也会导致违反 LSP</li>\n</ul>\n<p>(2) DIP</p>\n<ul>\n<li>DIP 认为高层模块和低层模块都应该依赖于抽象</li>\n<li>编写单元测试有一个原则：测试行为，而不是测试实现</li>\n<li>单元测试不宜使用太多 <code>mock</code>，否则需要调整设计</li>\n<li>依赖抽象的好处是，修改低层模块实现不会影响高层代码</li>\n<li>在 Python 中，你可以用 <code>abc</code> 模块来定义抽象类</li>\n<li>除 <code>abc</code> 以外，你也可以用 <code>Protocol</code> 等技术来完成依赖倒置</li>\n</ul>\n<p>(3) ISP</p>\n<ul>\n<li>ISP 认为客户依赖的接口不应该包含任何它不需要的方法</li>\n<li>设计接口就是设计抽象</li>\n<li>写更小的类、更小的接口在大多数情况下是个好主意</li>\n</ul>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 10 章 面向对象设计原则（上）","id":740849},"right":{"article_title":"第 12 章 数据模型与描述符","id":740851}},"comments":[{"had_liked":false,"id":391766,"user_name":"噜噜噜","can_delete":false,"product_type":"c1","uid":1984457,"ip_address":"上海","ucode":"B37C2CD3B836DB","user_header":"https://static001.geekbang.org/account/avatar/00/1e/47/c9/1bf79dfa.jpg","comment_is_top":false,"comment_ctime":1719049138,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636605,"comment_content":"好经典～","like_count":0}]}