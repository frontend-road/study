{"id":455412,"title":"39｜异步处理：async/await内部是怎么实现的？","content":"<p>你好，我是陈天。</p><p>学完上一讲，我们对 Future 和 async/await 的基本概念有一个比较扎实的理解了，知道在什么情况下该使用 Future、什么情况下该使用 Thread，以及 executor 和 reactor 是怎么联动最终让 Future 得到了一个结果。</p><p>然而，我们并不清楚为什么 async fn 或者 async block 就能够产生 Future，也并不明白 Future 是怎么被 executor 处理的。今天我们就继续深入下去，看看 async/await 这两个关键词究竟施了什么样的魔法，能够让一切如此简单又如此自然地运转起来。</p><p>提前说明一下，我们会继续围绕着 Future 这个简约却又并不简单的接口，来探讨一些原理性的东西，主要是 Context 和 Pin这两个结构：</p><pre><code class=\"language-rust\">pub trait Future {\n    type Output;\n    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;\n}\n</code></pre><p>这堂课的内容即便没有完全弄懂，也并不影响你使用 async/await。如果精力有限，你可以不用理解所有细节，只要抓住这些问题产生的原因，以及解决方案的思路即可。</p><h2>Waker 的调用机制</h2><!-- [[[read_end]]] --><p>先来看这个接口的 Context 是个什么东西。</p><p>上节课我们简单讲过 executor 通过调用 poll 方法来让 Future 继续往下执行，如果 poll 方法返回 Poll::Pending，就阻塞 Future，直到 reactor 收到了某个事件，然后调用 Waker.wake() 把 Future 唤醒。这个 Waker 是哪来的呢？</p><p>其实，它隐含在 Context 中：</p><pre><code class=\"language-rust\">pub struct Context&lt;'a&gt; {\n    waker: &amp;'a Waker,\n    _marker: PhantomData&lt;fn(&amp;'a ()) -&gt; &amp;'a ()&gt;,\n}\n</code></pre><p>所以，Context 就是 Waker 的一个封装。</p><p>如果你去看 Waker 的定义和相关的代码，会发现它非常抽象，内部使用了一个 vtable 来允许各种各样的 waker 的行为：</p><pre><code class=\"language-rust\">pub struct RawWakerVTable {\n    clone: unsafe fn(*const ()) -&gt; RawWaker,\n    wake: unsafe fn(*const ()),\n    wake_by_ref: unsafe fn(*const ()),\n    drop: unsafe fn(*const ()),\n}\n</code></pre><p>这种手工生成 vtable 的做法，我们<a href=\"https://time.geekbang.org/column/article/424017\">之前</a>阅读 bytes 的源码已经见识过了，它可以最大程度兼顾效率和灵活性。</p><p>Rust 自身并不提供异步运行时，它只在标准库里规定了一些基本的接口，至于怎么实现，可以由各个运行时（如 tokio）自行决定。<strong>所以在标准库中，你只会看到这些接口的定义，以及“高层”接口的实现</strong>，比如 Waker 下的 wake 方法，只是调用了 vtable 里的 wake() 而已：</p><pre><code class=\"language-rust\">impl Waker {\n    /// Wake up the task associated with this `Waker`.\n    #[inline]\n    pub fn wake(self) {\n        // The actual wakeup call is delegated through a virtual function call\n        // to the implementation which is defined by the executor.\n        let wake = self.waker.vtable.wake;\n        let data = self.waker.data;\n\n        // Don't call `drop` -- the waker will be consumed by `wake`.\n        crate::mem::forget(self);\n\n        // SAFETY: This is safe because `Waker::from_raw` is the only way\n        // to initialize `wake` and `data` requiring the user to acknowledge\n        // that the contract of `RawWaker` is upheld.\n        unsafe { (wake)(data) };\n    }\n    ...\n}\n</code></pre><p>如果你想顺藤摸瓜找到 vtable 是怎么设置的，却发现一切线索都悄无声息地中断了，那是因为，具体的实现并不在标准库中，而是在第三方的异步运行时里，比如 tokio。</p><p>不过，虽然我们开发时会使用 tokio，但阅读、理解代码时，我建议看 futures 库，比如 waker vtable 的<a href=\"https://github.com/rust-lang/futures-rs/blob/master/futures-task/src/waker.rs\">定义</a>。futures 库还有一个简单的 executor，也非常适合进一步通过代码理解 executor 的原理。</p><h2>async究竟生成了什么？</h2><p>我们接下来看 Pin。这是一个奇怪的数据结构，正常数据结构的方法都是直接使用 self / &amp;self / &amp;mut self，可是 poll() 却使用了 Pin&lt;&amp;mut self&gt;，为什么？</p><p>为了讲明白 Pin，我们得往前追踪一步，看看产生 Future的一个 async block/fn 内部究竟生成了什么样的代码？来看下面这个简单的 async 函数：</p><pre><code class=\"language-rust\">async fn write_hello_file_async(name: &amp;str) -&gt; anyhow::Result&lt;()&gt; {\n    let mut file = fs::File::create(name).await?;\n    file.write_all(b\"hello world!\").await?;\n\n    Ok(())\n}\n</code></pre><p>首先它创建一个文件，然后往这个文件里写入 “hello world!”。这个函数有两个 await，创建文件的时候会异步创建，写入文件的时候会异步写入。最终，整个函数对外返回一个 Future。</p><p>其它人可以这样调用：</p><pre><code class=\"language-rust\">write_hello_file_async(\"/tmp/hello\").await?;\n</code></pre><p>我们知道，executor 处理 Future 时，会不断地调用它的 poll() 方法，于是，上面那句实际上相当于：</p><pre><code class=\"language-rust\">match write_hello_file_async.poll(cx) {\n    Poll::Ready(result) =&gt; return result,\n    Poll::Pending =&gt; return Poll::Pending\n}\n</code></pre><p>这是单个 await 的处理方法，那更加复杂的，一个函数中有若干个 await，该怎么处理呢？以前面<code>write_hello_file_async</code> 函数的内部实现为例，显然，我们只有在处理完 create()，才能处理 write_all()，所以，应该是类似这样的代码：</p><pre><code class=\"language-rust\">let fut = fs::File::create(name);\nmatch fut.poll(cx) {\n    Poll::Ready(Ok(file)) =&gt; {\n        let fut = file.write_all(b\"hello world!\");\n        match fut.poll(cx) {\n            Poll::Ready(result) =&gt; return result,\n            Poll::Pending =&gt; return Poll::Pending,\n        }\n    }\n    Poll::Pending =&gt; return Poll::Pending,\n}\n</code></pre><p>但是，前面说过，async 函数返回的是一个 Future，所以，还需要把这样的代码封装在一个 Future 的实现里，对外提供出去。因此，我们需要实现一个数据结构，把内部的状态保存起来，并为这个数据结构实现 Future。比如：</p><pre><code class=\"language-rust\">enum WriteHelloFile {\n    // 初始阶段，用户提供文件名\n    Init(String),\n    // 等待文件创建，此时需要保存 Future 以便多次调用\n    // 这是伪代码，impl Future 不能用在这里\n    AwaitingCreate(impl Future&lt;Output = Result&lt;fs::File, std::io::Error&gt;&gt;),\n    // 等待文件写入，此时需要保存 Future 以便多次调用\n    AwaitingWrite(impl Future&lt;Output = Result&lt;(), std::io::Error&gt;&gt;),\n    // Future 处理完毕\n    Done,\n}\n\nimpl WriteHelloFile {\n    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {\n        Self::Init(name.into())\n    }\n}\n\nimpl Future for WriteHelloFile {\n    type Output = Result&lt;(), std::io::Error&gt;;\n\n    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {\n        todo!()\n    }\n}\n\nfn write_hello_file_async(name: &amp;str) -&gt; WriteHelloFile {\n    WriteHelloFile::new(name)\n}\n</code></pre><p>这样，我们就把刚才的 write_hello_file_async 异步函数，转化成了一个返回 WriteHelloFile Future 的函数。来看这个 Future 如何实现（详细注释了）：</p><pre><code class=\"language-rust\">impl Future for WriteHelloFile {\n    type Output = Result&lt;(), std::io::Error&gt;;\n\n    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {\n        let this = self.get_mut();\n        loop {\n            match this {\n                // 如果状态是 Init，那么就生成 create Future，把状态切换到 AwaitingCreate\n                WriteHelloFile::Init(name) =&gt; {\n                    let fut = fs::File::create(name);\n                    *self = WriteHelloFile::AwaitingCreate(fut);\n                }\n                // 如果状态是 AwaitingCreate，那么 poll create Future\n                // 如果返回 Poll::Ready(Ok(_))，那么创建 write Future\n                // 并把状态切换到 Awaiting\n                WriteHelloFile::AwaitingCreate(fut) =&gt; match fut.poll(cx) {\n                    Poll::Ready(Ok(file)) =&gt; {\n                        let fut = file.write_all(b\"hello world!\");\n                        *self = WriteHelloFile::AwaitingWrite(fut);\n                    }\n                    Poll::Ready(Err(e)) =&gt; return Poll::Ready(Err(e)),\n                    Poll::Pending =&gt; return Poll::Pending,\n                },\n                // 如果状态是 AwaitingWrite，那么 poll write Future\n                // 如果返回 Poll::Ready(_)，那么状态切换到 Done，整个 Future 执行成功\n                WriteHelloFile::AwaitingWrite(fut) =&gt; match fut.poll(cx) {\n                    Poll::Ready(result) =&gt; {\n                        *self = WriteHelloFile::Done;\n                        return Poll::Ready(result);\n                    }\n                    Poll::Pending =&gt; return Poll::Pending,\n                },\n                // 整个 Future 已经执行完毕\n                WriteHelloFile::Done =&gt; return Poll::Ready(Ok(())),\n            }\n        }\n    }\n}\n</code></pre><p>这个 Future 完整实现的内部结构 ，其实就是一个状态机的迁移。</p><p>这段（伪）代码和之前异步函数是等价的：</p><pre><code class=\"language-rust\">async fn write_hello_file_async(name: &amp;str) -&gt; anyhow::Result&lt;()&gt; {\n    let mut file = fs::File::create(name).await?;\n    file.write_all(b\"hello world!\").await?;\n\n    Ok(())\n}\n</code></pre><p><strong>Rust 在编译 async fn 或者 async block 时，就会生成类似的状态机的实现</strong>。你可以看到，看似简单的异步处理，内部隐藏了一套并不难理解、但是写起来很生硬很啰嗦的状态机管理代码。</p><p>好搞明白这个问题，回到pin 。刚才我们手写状态机代码的过程，能帮你理解为什么会需要 Pin 这个问题。</p><h3>为什么需要 Pin？</h3><p>在上面实现 Future 的状态机中，我们引用了 file 这样一个局部变量：</p><pre><code class=\"language-rust\">WriteHelloFile::AwaitingCreate(fut) =&gt; match fut.poll(cx) {\n    Poll::Ready(Ok(file)) =&gt; {\n        let fut = file.write_all(b\"hello world!\");\n        *self = WriteHelloFile::AwaitingWrite(fut);\n    }\n    Poll::Ready(Err(e)) =&gt; return Poll::Ready(Err(e)),\n    Poll::Pending =&gt; return Poll::Pending,\n}\n</code></pre><p>这个代码是有问题的，file 被 fut 引用，但 file 会在这个作用域被丢弃。所以，我们需要把它保存在数据结构中：</p><pre><code class=\"language-rust\">enum WriteHelloFile {\n    // 初始阶段，用户提供文件名\n    Init(String),\n    // 等待文件创建，此时需要保存 Future 以便多次调用\n    AwaitingCreate(impl Future&lt;Output = Result&lt;fs::File, std::io::Error&gt;&gt;),\n    // 等待文件写入，此时需要保存 Future 以便多次调用\n    AwaitingWrite(AwaitingWriteData),\n    // Future 处理完毕\n    Done,\n}\n\nstruct AwaitingWriteData {\n    fut: impl Future&lt;Output = Result&lt;(), std::io::Error&gt;&gt;,\n    file: fs::File,\n}\n</code></pre><p>可以生成一个 AwaitingWriteData 数据结构，把 file 和 fut 都放进去，然后在 WriteHelloFile 中引用它。此时，在同一个数据结构内部，fut 指向了对 file 的引用，这样的数据结构，叫<strong>自引用结构（Self-Referential Structure）</strong>。</p><p>自引用结构有一个很大的问题是：一旦它被移动，原本的指针就会指向旧的地址。<br>\n<img src=\"https://static001.geekbang.org/resource/image/d9/25/d98a5812510307d1274e066d4b663c25.jpg?wh=2067x1164\" alt=\"\"></p><p>所以需要有某种机制来保证这种情况不会发生。Pin 就是为这个目的而设计的一个数据结构，我们可以 Pin 住指向一个 Future 的指针，看文稿中 Pin 的声明：</p><pre><code class=\"language-rust\">pub struct Pin&lt;P&gt; {\n    pointer: P,\n}\n\nimpl&lt;P: Deref&gt; Deref for Pin&lt;P&gt; {\n    type Target = P::Target;\n    fn deref(&amp;self) -&gt; &amp;P::Target {\n        Pin::get_ref(Pin::as_ref(self))\n    }\n}\n\nimpl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {\n        Pin::get_mut(Pin::as_mut(self))\n    }\n}\n</code></pre><p>Pin 拿住的是<strong>一个可以解引用成 T 的指针类型 P</strong>，而不是直接拿原本的类型 T。所以，对于 Pin 而言，你看到的都是 Pin&lt;Box&lt;T&gt;&gt;、Pin&lt;&amp;mut T&gt;，但不会是 Pin&lt;T&gt;。因为 Pin 的目的是，把 T 的内存位置锁住，从而避免移动后自引用类型带来的引用失效问题。<br>\n<img src=\"https://static001.geekbang.org/resource/image/f2/72/f2ac4b8ebaa25718191f747edca71072.jpg?wh=2067x1164\" alt=\"\"></p><p>这样数据结构可以正常访问，但是你<strong>无法直接</strong>拿到原来的数据结构进而移动它。</p><h3>自引用数据结构</h3><p>当然，自引用数据结构并非只在异步代码里出现，只不过异步代码在内部生成用状态机表述的 Future 时，很容易产生自引用结构。我们看一个和 Future 无关的例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=84d31bad09e9cf0824e07b64fa7930fb\">代码</a>）：</p><pre><code class=\"language-rust\">#[derive(Debug)]\nstruct SelfReference {\n    name: String,\n    // 在初始化后指向 name\n    name_ptr: *const String,\n}\n\nimpl SelfReference {\n    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {\n        SelfReference {\n            name: name.into(),\n            name_ptr: std::ptr::null(),\n        }\n    }\n\n    pub fn init(&amp;mut self) {\n        self.name_ptr = &amp;self.name as *const String;\n    }\n\n    pub fn print_name(&amp;self) {\n        println!(\n            \"struct {:p}: (name: {:p} name_ptr: {:p}), name: {}, name_ref: {}\",\n            self,\n            &amp;self.name,\n            self.name_ptr,\n            self.name,\n            // 在使用 ptr 是需要 unsafe\n            // SAFETY: 这里 name_ptr 潜在不安全，会指向旧的位置\n            unsafe { &amp;*self.name_ptr },\n        );\n    }\n}\n\nfn main() {\n    let data = move_creates_issue();\n    println!(\"data: {:?}\", data);\n    // 如果把下面这句注释掉，程序运行会直接 segment error\n    // data.print_name();\n    print!(\"\\\\n\");\n    mem_swap_creates_issue();\n}\n\nfn move_creates_issue() -&gt; SelfReference {\n    let mut data = SelfReference::new(\"Tyr\");\n    data.init();\n\n    // 不 move，一切正常\n    data.print_name();\n\n    let data = move_it(data);\n\n    // move 之后，name_ref 指向的位置是已经失效的地址\n    // 只不过现在 move 前的地址还没被回收挪作它用\n    data.print_name();\n    data\n}\n\nfn mem_swap_creates_issue() {\n    let mut data1 = SelfReference::new(\"Tyr\");\n    data1.init();\n\n    let mut data2 = SelfReference::new(\"Lindsey\");\n    data2.init();\n\n    data1.print_name();\n    data2.print_name();\n\n    std::mem::swap(&amp;mut data1, &amp;mut data2);\n    data1.print_name();\n    data2.print_name();\n}\n\nfn move_it(data: SelfReference) -&gt; SelfReference {\n    data\n}\n</code></pre><p>我们创建了一个自引用结构 SelfReference，它里面的 name_ref 指向了 name。正常使用它时，没有任何问题，但一旦对这个结构做 move 操作，name_ref 指向的位置还会是 move 前 name 的地址，这就引发了问题。看下图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/31/07/31002299965d19c7bb014050987f4907.jpg?wh=2067x1164\" alt=\"\"></p><p>同样的，如果我们使用 std::mem:swap，也会出现类似的问题，一旦 swap，两个数据的内容交换，然而，由于 name_ref 指向的地址还是旧的，所以整个指针体系都混乱了：<br>\n<img src=\"https://static001.geekbang.org/resource/image/42/17/420d3e07c76f9948135857f1d1898d17.jpg?wh=2118x2026\" alt=\"\"></p><p>看代码的输出，辅助你理解：</p><pre><code class=\"language-rust\">struct 0x7ffeea91d6e8: (name: 0x7ffeea91d6e8 name_ptr: 0x7ffeea91d6e8), name: Tyr, name_ref: Tyr\nstruct 0x7ffeea91d760: (name: 0x7ffeea91d760 name_ptr: 0x7ffeea91d6e8), name: Tyr, name_ref: Tyr\ndata: SelfReference { name: \"Tyr\", name_ptr: 0x7ffeea91d6e8 }\n\nstruct 0x7ffeea91d6f0: (name: 0x7ffeea91d6f0 name_ptr: 0x7ffeea91d6f0), name: Tyr, name_ref: Tyr\nstruct 0x7ffeea91d710: (name: 0x7ffeea91d710 name_ptr: 0x7ffeea91d710), name: Lindsey, name_ref: Lindsey\nstruct 0x7ffeea91d6f0: (name: 0x7ffeea91d6f0 name_ptr: 0x7ffeea91d710), name: Lindsey, name_ref: Tyr\nstruct 0x7ffeea91d710: (name: 0x7ffeea91d710 name_ptr: 0x7ffeea91d6f0), name: Tyr, name_ref: Lindsey\n</code></pre><p>可以看到，swap 之后，name_ref 指向的内容确实和 name 不一样了。这就是自引用结构带来的问题。</p><p>你也许会奇怪，不是说 move 也会出问题么？为什么第二行打印 name_ref 还是指向了 “Tyr”？这是因为 move 后，之前的内存失效，但是内存地址还没有被挪作它用，所以还能正常显示 “Tyr”。<strong>但这样的内存访问是不安全的</strong>，如果你把 main 中这句代码注释掉，程序就会 crash：</p><pre><code class=\"language-rust\">fn main() {\n    let data = move_creates_issue();\n    println!(\"data: {:?}\", data);\n    // 如果把下面这句注释掉，程序运行会直接 segment error\n    // data.print_name();\n    print!(\"\\\\n\");\n    mem_swap_creates_issue();\n}\n</code></pre><p>现在你应该了解到在 Rust 下，自引用类型带来的潜在危害了吧。</p><p>所以，Pin 的出现，对解决这类问题很关键，如果你试图移动被 Pin 住的数据结构，要么，编译器会通过编译错误阻止你；要么，你强行使用 unsafe Rust，自己负责其安全性。我们来看使用 Pin 后如何避免移动带来的问题：</p><pre><code class=\"language-rust\">use std::{marker::PhantomPinned, pin::Pin};\n\n#[derive(Debug)]\nstruct SelfReference {\n    name: String,\n    // 在初始化后指向 name\n    name_ptr: *const String,\n    // PhantomPinned 占位符\n    _marker: PhantomPinned,\n}\n\nimpl SelfReference {\n    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {\n        SelfReference {\n            name: name.into(),\n            name_ptr: std::ptr::null(),\n            _marker: PhantomPinned,\n        }\n    }\n\n    pub fn init(self: Pin&lt;&amp;mut Self&gt;) {\n        let name_ptr = &amp;self.name as *const String;\n        // SAFETY: 这里并不会把任何数据从 &amp;mut SelfReference 中移走\n        let this = unsafe { self.get_unchecked_mut() };\n        this.name_ptr = name_ptr;\n    }\n\n    pub fn print_name(self: Pin&lt;&amp;Self&gt;) {\n        println!(\n            \"struct {:p}: (name: {:p} name_ptr: {:p}), name: {}, name_ref: {}\",\n            self,\n            &amp;self.name,\n            self.name_ptr,\n            self.name,\n            // 在使用 ptr 是需要 unsafe\n            // SAFETY: 因为数据不会移动，所以这里 name_ptr 是安全的\n            unsafe { &amp;*self.name_ptr },\n        );\n    }\n}\n\nfn main() {\n    move_creates_issue();\n}\n\nfn move_creates_issue() {\n    let mut data = SelfReference::new(\"Tyr\");\n    let mut data = unsafe { Pin::new_unchecked(&amp;mut data) };\n    SelfReference::init(data.as_mut());\n\n    // 不 move，一切正常\n    data.as_ref().print_name();\n\n    // 现在只能拿到 pinned 后的数据，所以 move 不了之前\n    move_pinned(data.as_mut());\n    println!(\"{:?} ({:p})\", data, &amp;data);\n\n    // 你无法拿回 Pin 之前的 SelfReference 结构，所以调用不了 move_it\n    // move_it(data);\n}\n\nfn move_pinned(data: Pin&lt;&amp;mut SelfReference&gt;) {\n    println!(\"{:?} ({:p})\", data, &amp;data);\n}\n\n#[allow(dead_code)]\nfn move_it(data: SelfReference) {\n    println!(\"{:?} ({:p})\", data, &amp;data);\n}\n</code></pre><p>由于数据结构被包裹在 Pin 内部，所以在函数间传递时，变化的只是指向 data 的 Pin：<br>\n<img src=\"https://static001.geekbang.org/resource/image/d8/80/d8b774c6c4970abc8dbce29cbb2fde80.jpg?wh=2067x1164\" alt=\"\"></p><p>学习了Pin，不知道你有没有想起 Unpin 。</p><h3>那么，Unpin 是做什么的？</h3><p>我们在介绍<a href=\"https://time.geekbang.org/column/article/421324\">主要的系统 trait</a> 时，曾经提及 Unpin 这个 marker trait：</p><pre><code class=\"language-rust\">pub auto trait Unpin {}\n</code></pre><p>Pin 是为了让某个数据结构无法合法地移动，而 Unpin 则相当于声明数据结构是可以移动的，它的作用类似于 Send / Sync，通过类型约束来告诉编译器哪些行为是合法的、哪些不是。</p><p>在 Rust 中，绝大多数数据结构都是可以移动的，所以它们都自动实现了 <a href=\"https://doc.rust-lang.org/std/marker/trait.Unpin.html\">Unpin</a>。即便这些结构被 Pin 包裹，它们依旧可以进行移动，比如：</p><pre><code class=\"language-rust\">use std::mem;\nuse std::pin::Pin;\n\nlet mut string = \"this\".to_string();\nlet mut pinned_string = Pin::new(&amp;mut string);\n\n// We need a mutable reference to call `mem::replace`.\n// We can obtain such a reference by (implicitly) invoking `Pin::deref_mut`,\n// but that is only possible because `String` implements `Unpin`.\nmem::replace(&amp;mut *pinned_string, \"other\".to_string());\n</code></pre><p>当我们不希望一个数据结构被移动，可以使用 !Unpin。在 Rust 里，实现了 !Unpin 的，除了内部结构（比如 Future），主要就是 PhantomPinned：</p><pre><code class=\"language-rust\">pub struct PhantomPinned;\nimpl !Unpin for PhantomPinned {}\n</code></pre><p>所以，如果你希望你的数据结构不能被移动，可以为其添加 PhantomPinned 字段来隐式声明 !Unpin。</p><p>当数据结构满足 Unpin 时，创建 Pin 以及使用 Pin（主要是 DerefMut）都可以使用安全接口，否则，需要使用 unsafe 接口：</p><pre><code class=\"language-rust\">// 如果实现了 Unpin，可以通过安全接口创建和进行 DerefMut\nimpl&lt;P: Deref&lt;Target: Unpin&gt;&gt; Pin&lt;P&gt; {\n    pub const fn new(pointer: P) -&gt; Pin&lt;P&gt; {\n        // SAFETY: the value pointed to is `Unpin`, and so has no requirements\n        // around pinning.\n        unsafe { Pin::new_unchecked(pointer) }\n    }\n    pub const fn into_inner(pin: Pin&lt;P&gt;) -&gt; P {\n        pin.pointer\n    }\n}\n\nimpl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {\n        Pin::get_mut(Pin::as_mut(self))\n    }\n}\n\n// 如果没有实现 Unpin，只能通过 unsafe 接口创建，不能使用 DerefMut\nimpl&lt;P: Deref&gt; Pin&lt;P&gt; {\n    pub const unsafe fn new_unchecked(pointer: P) -&gt; Pin&lt;P&gt; {\n        Pin { pointer }\n    }\n\n    pub const unsafe fn into_inner_unchecked(pin: Pin&lt;P&gt;) -&gt; P {\n        pin.pointer\n    }\n}\n</code></pre><h2>async 产生的 Future 究竟是什么类型？</h2><p>现在，我们对 Future 的接口有了一个完整的认识，也知道 async 关键字的背后都发生了什么事情：</p><pre><code class=\"language-rust\">pub trait Future {\n    type Output;\n    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;\n}\n</code></pre><p>那么，当你写一个 async fn 或者使用了一个 async block 时，究竟得到了一个什么类型的数据呢？比如：</p><pre><code class=\"language-rust\">let fut = async { 42 };\n</code></pre><p>你肯定能拍着胸脯说，这个我知道，不就是 impl Future&lt;Output = i32&gt; 么？</p><p>对，但是 impl Future 不是一个具体的类型啊，我们讲过，它相当于 T: Future，那么这个 T 究竟是什么呢？我们来写段代码探索一下（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=40efb64c5e424e00e6fa57655c5357a1\">代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let fut = async { 42 };\n\n    println!(\"type of fut is: {}\", get_type_name(&amp;fut));\n}\n\nfn get_type_name&lt;T&gt;(_: &amp;T) -&gt; &amp;'static str {\n    std::any::type_name::&lt;T&gt;()\n}\n</code></pre><p>它的输出如下：</p><pre><code class=\"language-rust\">type of fut is: core::future::from_generator::GenFuture&lt;xxx::main::{{closure}}&gt;\n</code></pre><p>哈，我们似乎发现了新大陆，实现 Future trait 的是一个叫 GenFuture 的结构，它内部有一个闭包。猜测这个闭包是 <code>async { 42 }</code> 产生的？</p><p>我们看 GenFuture 的定义（感兴趣可以在 Rust 源码中搜 from_generator），可以看到它是一个泛型结构，内部数据 T 要满足 Generator trait：</p><pre><code class=\"language-rust\">struct GenFuture&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T);\n\npub trait Generator&lt;R = ()&gt; {\n    type Yield;\n    type Return;\n    fn resume(\n        self: Pin&lt;&amp;mut Self&gt;, \n        arg: R\n    ) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;\n}\n</code></pre><p><a href=\"https://doc.rust-lang.org/std/ops/trait.Generator.html\">Generator</a> 是 Rust nightly 的一个 trait，还没有进入到标准库。大致看看官网展示的例子，它是怎么用的：</p><pre><code class=\"language-rust\">#![feature(generators, generator_trait)]\n\nuse std::ops::{Generator, GeneratorState};\nuse std::pin::Pin;\n\nfn main() {\n    let mut generator = || {\n        yield 1;\n        return \"foo\"\n    };\n\n    match Pin::new(&amp;mut generator).resume(()) {\n        GeneratorState::Yielded(1) =&gt; {}\n        _ =&gt; panic!(\"unexpected return from resume\"),\n    }\n    match Pin::new(&amp;mut generator).resume(()) {\n        GeneratorState::Complete(\"foo\") =&gt; {}\n        _ =&gt; panic!(\"unexpected return from resume\"),\n    }\n}\n</code></pre><p>可以看到，如果你创建一个闭包，里面有 yield 关键字，就会得到一个 Generator。如果你在 Python 中使用过 yield，二者其实非常类似。因为 Generator 是一个还没进入到稳定版的功能，大致了解一下就行，以后等它的 API 稳定后再仔细研究。</p><h2>小结</h2><p>这一讲我们深入地探讨了 Future 接口各个部分Context、Pin/Unpin的含义，以及 async/await 这样漂亮的接口之下会产生什么样子的代码。</p><p>对照下面这张图，我们回顾一下过去两讲的内容：<br>\n<img src=\"https://static001.geekbang.org/resource/image/e3/4c/e3934324381bc8f90c061bbca629234c.jpg?wh=3022x1724\" alt=\"\"></p><p>并发任务运行在 Future 这样的协程上时，async/await是产生和运行并发任务的手段，async 定义一个可以并发执行的Future任务，await 触发这个任务并发执行。具体来说：</p><p>当我们使用 async 关键字时，它会产生一个 impl Future 的结果。对于一个 async block 或者 async fn 来说，内部的每个 await 都会被编译器捕捉，并成为返回的 Future 的 poll() 方法的内部状态机的一个状态。</p><p>Rust 的 Future 需要异步运行时来运行 Future，以 tokio 为例，它的 executor 会从 run queue 中取出 Future 进行 poll()，当 poll() 返回 Pending 时，这个 Future 会被挂起，直到 reactor 得到了某个事件，唤醒这个 Future，将其添加回 run queue 等待下次执行。</p><p>tokio 一般会在每个物理线程（或者 CPU core）下运行一个线程，每个线程有自己的 run queue 来处理 Future。为了提供最大的吞吐量，tokio 实现了 work stealing scheduler，这样，当某个线程下没有可执行的 Future，它会从其它线程的 run queue 中“偷”一个执行。</p><h2>思考题</h2><p>如果一个数据结构 T: !Unpin，我们为其生成 Box&lt;T&gt;，那么 Box&lt;T&gt; 是 Unpin 还是 !Unpin 的？</p><p>欢迎在留言区分享你的学习感悟和思考。</p><h3>拓展阅读</h3><p>观看 Jon Gjengset 的 <a href=\"https://www.youtube.com/watch?v=DkMwYxfSYNQ&amp;ab_channel=JonGjengset\">The Why, What, and How of Pinning in Rust</a>，进一步了解 Pin 和 Unpin。</p><p>感谢你的收听，如果你觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。恭喜你完成了Rust学习的第39次打卡，我们下节课见。</p>","neighbors":{"left":{"article_title":"38｜异步处理：Future是什么？它和async/await是什么关系？","id":455413},"right":{"article_title":"40｜异步处理：如何处理异步IO？","id":461695}},"comments":[{"had_liked":false,"id":324039,"user_name":"GengTeng","can_delete":false,"product_type":"c1","uid":1224623,"ip_address":"","ucode":"3F926F5EF1D075","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/af/8b03ce2c.jpg","comment_is_top":false,"comment_ctime":1638269367,"is_pvip":false,"replies":[{"id":"118872","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639849374,"ip_address":"","comment_id":324039,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14523171255","product_id":100085301,"comment_content":"我之前记录并翻译过无船同志（withoutboats）的一个讲座，供大家参考：https:&#47;&#47;gteng.org&#47;2021&#47;01&#47;30&#47;zero-cost-async-io&#47;","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539833,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639849374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","nickname":"Marvichov","note":"","ucode":"7482099415C41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537047,"discussion_content":"视频链接: https://youtu.be/skos4B5x7qE","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638945707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323866,"user_name":"罗同学","can_delete":false,"product_type":"c1","uid":1649119,"ip_address":"","ucode":"909B9EC768B9AD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vHujib2CCrUYNBaia32eIwTyJoAcl27vASZ9KGjSdnH1dJhD7CrSUicBib19Tf8nDibWaHjzIsvIfdqcXX6vGrH8bicw/132","comment_is_top":false,"comment_ctime":1638189315,"is_pvip":false,"replies":[{"id":"118876","content":"所有者还是之前的变量，只不过一般会把它 shadow 掉，这样没有人可以拿到。当这个变量离开作用域时还是会被回收。<br><br>```rust<br>use std::pin::Pin;<br><br>fn main() {<br>    let s = &quot;hello&quot;.to_string();<br>    println!(&quot;addr of s(stack): {:p}&quot;, &amp;s);<br>    let s = Pin::new(s);<br>    println!(&quot;addr of pinned s: {:p}&quot;, &amp;s);<br>}<br>```","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639849850,"ip_address":"","comment_id":323866,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10228123907","product_id":100085301,"comment_content":"Pin了后的数据 所有者变成谁了?","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539837,"discussion_content":"所有者还是之前的变量，只不过一般会把它 shadow 掉，这样没有人可以拿到。当这个变量离开作用域时还是会被回收。\n\n```rust\nuse std::pin::Pin;\n\nfn main() {\n    let s = &#34;hello&#34;.to_string();\n    println!(&#34;addr of s(stack): {:p}&#34;, &amp;s);\n    let s = Pin::new(s);\n    println!(&#34;addr of pinned s: {:p}&#34;, &amp;s);\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639849850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336642,"user_name":"老荀","can_delete":false,"product_type":"c1","uid":1214893,"ip_address":"","ucode":"C32E743518DECD","user_header":"https://static001.geekbang.org/account/avatar/00/12/89/ad/4efd929a.jpg","comment_is_top":false,"comment_ctime":1646271648,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646271648","product_id":100085301,"comment_content":"二刷…老师的课太良心了…","like_count":0},{"had_liked":false,"id":335364,"user_name":"清风徐来","can_delete":false,"product_type":"c1","uid":1202697,"ip_address":"","ucode":"2AAA5B8DE30DF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/09/afa3e112.jpg","comment_is_top":false,"comment_ctime":1645489075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645489075","product_id":100085301,"comment_content":"有了Pin为啥还有!UnPin","like_count":0},{"had_liked":false,"id":331439,"user_name":"JK.Ryan","can_delete":false,"product_type":"c1","uid":1014467,"ip_address":"","ucode":"D1E533F3DEC481","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/c3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1642586000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642586000","product_id":100085301,"comment_content":"庖丁解牛，很赞~👍🏻","like_count":0},{"had_liked":false,"id":330441,"user_name":"wowotuo","can_delete":false,"product_type":"c1","uid":1141192,"ip_address":"","ucode":"D87BCBD3EA61A9","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/c8/d6f00a46.jpg","comment_is_top":false,"comment_ctime":1641978670,"is_pvip":false,"replies":[{"id":"120691","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642292939,"ip_address":"","comment_id":330441,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641978670","product_id":100085301,"comment_content":"讲得很牛逼，现在反反复复听了看了不下10次","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546300,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642292939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326934,"user_name":"dva","can_delete":false,"product_type":"c1","uid":2101988,"ip_address":"","ucode":"EE27DAFCBF198D","user_header":"https://static001.geekbang.org/account/avatar/00/20/12/e4/57ade29a.jpg","comment_is_top":false,"comment_ctime":1639763297,"is_pvip":false,"replies":[{"id":"120822","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642311514,"ip_address":"","comment_id":326934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639763297","product_id":100085301,"comment_content":"Box&lt;T&gt;是Unpin，因为Box&lt;T&gt;实现了Unpin trait","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546467,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642311514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323784,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1638160092,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1638160092","product_id":100085301,"comment_content":"从基础到原理好好研究 Future。","like_count":0},{"had_liked":false,"id":323746,"user_name":"良师益友","can_delete":false,"product_type":"c1","uid":1614999,"ip_address":"","ucode":"02B0B2FDDDAE6A","user_header":"https://static001.geekbang.org/account/avatar/00/18/a4/97/bc269801.jpg","comment_is_top":false,"comment_ctime":1638149620,"is_pvip":false,"replies":[{"id":"118877","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639849865,"ip_address":"","comment_id":323746,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638149620","product_id":100085301,"comment_content":"以前在这里卡住了，这次说明白了，感谢老师","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539838,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639849866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}