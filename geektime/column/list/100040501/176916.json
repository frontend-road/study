{"id":176916,"title":"09 | 易用性改进 II：字面量、静态断言和成员函数说明符","content":"<p>你好，我是吴咏炜。</p><p>本讲我们继续易用性的话题，看看现代 C++ 带来的其他易用性改进。</p><h2>自定义字面量</h2><p>字面量（literal）是指在源代码中写出的固定常量，它们在 C++98 里只能是原生类型，如：</p><ul>\n<li><code>\"hello\"</code>，字符串字面量，类型是 <code>const char[6]</code></li>\n<li><code>1</code>，整数字面量，类型是 <code>int</code></li>\n<li><code>0.0</code>，浮点数字面量，类型是 <code>double</code></li>\n<li><code>3.14f</code>，浮点数字面量，类型是 <code>float</code></li>\n<li><code>123456789ul</code>，无符号长整数字面量，类型是 <code>unsigned long</code></li>\n</ul><p>C++11 引入了自定义字面量，可以使用 <code>operator\"\" 后缀</code> 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中加入了不少标准字面量。下面这个程序展示了它们的用法：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;complex&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nint main()\n{\n  cout &lt;&lt; \"i * i = \" &lt;&lt; 1i * 1i\n       &lt;&lt; endl;\n  cout &lt;&lt; \"Waiting for 500ms\"\n       &lt;&lt; endl;\n  this_thread::sleep_for(500ms);\n  cout &lt;&lt; \"Hello world\"s.substr(0, 5)\n       &lt;&lt; endl;\n}\n</code></pre><!-- [[[read_end]]] --><p>输出是：</p><blockquote>\n<p><code>i * i = (-1,0)</code><br>\n<code>Waiting for 500ms</code><br>\n<code>Hello</code></p>\n</blockquote><p>上面这个例子展示了 C++ 标准里提供的帮助生成虚数、时间和 <code>basic_string</code> 字面量的后缀。一个需要注意的地方是，我在上面使用了 <code>using namespace std</code>，这会同时引入 <code>std</code> 名空间和里面的内联名空间（inline namespace），包括了上面的字面量运算符所在的三个名空间：</p><ul>\n<li><code>std::literals::complex_literals</code></li>\n<li><code>std::literals::chrono_literals</code></li>\n<li><code>std::literals::string_literals</code></li>\n</ul><p>在产品项目中，一般不会（也不应该）全局使用 <code>using namespace std</code>（不过，为节约篇幅起见，专栏里的很多例子，特别是不完整的例子，还是默认使用了 <code>using namespace std</code>）。这种情况下，应当在使用到这些字面量的作用域里导入需要的名空间，以免发生冲突。在类似上面的例子里，就是在函数体的开头写：</p><pre><code class=\"language-c++\">using namespace std::literals::\n  chrono_literals;\n</code></pre><p>等等。</p><p>要在自己的类里支持字面量也相当容易，唯一的限制是非标准的字面量后缀必须以下划线 <code>_</code> 打头。比如，假如我们有下面的长度类：</p><pre><code class=\"language-c++\">struct length {\n  double value;\n  enum unit {\n    metre,\n    kilometre,\n    millimetre,\n    centimetre,\n    inch,\n    foot,\n    yard,\n    mile,\n  };\n  static constexpr double factors[] =\n    {1.0,    1000.0,  1e-3,\n     1e-2,   0.0254,  0.3048,\n     0.9144, 1609.344};\n  explicit length(double v,\n                  unit u = metre)\n  {\n    value = v * factors[u];\n  }\n};\n\nlength operator+(length lhs,\n                 length rhs)\n{\n  return length(lhs.value +\n                rhs.value);\n}\n\n// 可能有其他运算符\n</code></pre><p>我们可以手写 <code>length(1.0, length::metre)</code> 这样的表达式，但估计大部分开发人员都不愿意这么做吧。反过来，如果我们让开发人员这么写，大家应该还是基本乐意的：</p><pre><code class=\"language-c++\">1.0_m + 10.0_cm\n</code></pre><p>要允许上面这个表达式，我们只需要提供下面的运算符即可：</p><pre><code class=\"language-c++\">length operator\"\" _m(long double v)\n{\n  return length(v, length::metre);\n}\n\nlength operator\"\" _cm(long double v)\n{\n  return length(v, length::centimetre);\n}\n</code></pre><p>如果美国国家航空航天局采用了类似的系统的话，火星气候探测者号的事故也许就不会发生了 <span class=\"orange\">[1]</span>。当然，历史无法重来，而且 C++ 引入这样的语法已经是在事故发生之后十多年了……</p><p>关于自定义字面量的进一步技术细节，请参阅参考资料 <span class=\"orange\">[2]</span>。</p><h2>二进制字面量</h2><p>你一定知道 C++ 里有 <code>0x</code> 前缀，可以让开发人员直接写出像 <code>0xFF</code> 这样的十六进制字面量。另外一个目前使用得稍少的前缀就是 <code>0</code> 后面直接跟 0–7 的数字，表示八进制的字面量，在跟文件系统打交道的时候还会经常用到：有经验的 Unix 程序员可能会觉得 <code>chmod(path, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)</code> 并不比 <code>chmod(path, 0644)</code> 更为直观。从 C++14 开始，我们对于二进制也有了直接的字面量：</p><pre><code class=\"language-c++\">unsigned mask = 0b111000000;\n</code></pre><p>这在需要比特级操作等场合还是非常有用的。</p><p>不过，遗憾的是， I/O streams 里只有 <code>dec</code>、<code>hex</code>、<code>oct</code> 三个操纵器（manipulator），而没有 <code>bin</code>，因而输出一个二进制数不能像十进制、十六进制、八进制那么直接。一个间接方式是使用 <code>bitset</code>，但调用者需要手工指定二进制位数：</p><pre><code class=\"language-c++\">#include &lt;bitset&gt;\ncout &lt;&lt; bitset&lt;9&gt;(mask) &lt;&lt; endl;\n</code></pre><blockquote>\n<p><code>111000000</code></p>\n</blockquote><h2>数字分隔符</h2><p>数字长了之后，看清位数就变得麻烦了。有了二进制字面量，这个问题变得分外明显。C++14 开始，允许在数字型字面量中任意添加 <code>'</code> 来使其更可读。具体怎么添加，完全由程序员根据实际情况进行约定。某些常见的情况可能会是：</p><ul>\n<li>十进制数字使用三位的分隔，对应英文习惯的 thousand、million 等单位。</li>\n<li>十进制数字使用四位的分隔，对应中文习惯的万、亿等单位。</li>\n<li>十六进制数字使用两位或四位的分隔，对应字节或双字节。</li>\n<li>二进制数字使用三位的分隔，对应文件系统的权限分组。</li>\n<li>等等。</li>\n</ul><p>一些实际例子如下：</p><pre><code class=\"language-c++\">unsigned mask = 0b111'000'000;\nlong r_earth_equatorial = 6'378'137;\ndouble pi = 3.14159'26535'89793;\nconst unsigned magic = 0x44'42'47'4E;\n</code></pre><h2>静态断言</h2><p>C++98 的 <code>assert</code> 允许在运行时检查一个函数的前置条件是否成立。没有一种方法允许开发人员在编译的时候检查假设是否成立。比如，如果模板有个参数 <code>alignment</code>，表示对齐，那我们最好在编译时就检查 <code>alignment</code> 是不是二的整数次幂。之前人们用了一些模板技巧来达到这个目的，但输出的信息并不那么友善。比如，我之前使用的方法，会产生类似下面这样的输出：</p><p><img src=\"https://static001.geekbang.org/resource/image/a8/25/a808b0cda0a9f128b1be88b5ebd58f25.jpg?wh=1300x370\" alt=\"\"></p><p>能起作用，但不够直观。C++11 直接从语言层面提供了静态断言机制，不仅能输出更好的信息，而且适用性也更好，可以直接放在类的定义中，而不像之前用的特殊技巧只能放在函数体里。对于类似上面的情况，现在的输出是：</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/8f/9f268d08e671b7ab26c85a8f12603b8f.jpg?wh=1300x234\" alt=\"\"></p><p>静态断言语法上非常简单，就是：</p><pre><code class=\"language-c++\">static_assert(编译期条件表达式,\n              可选输出信息);\n</code></pre><p>产生上面的示例错误信息的代码是：</p><pre><code class=\"language-c++\">static_assert((alignment &amp; (alignment - 1)) == 0,\n  \"Alignment must be power of two\");\n</code></pre><h2>default 和 delete 成员函数</h2><p>在类的定义时，C++ 有一些规则决定是否生成默认的特殊成员函数。这些特殊成员函数可能包括：</p><ul>\n<li>默认构造函数</li>\n<li>析构函数</li>\n<li>拷贝构造函数</li>\n<li>拷贝赋值函数</li>\n<li>移动构造函数</li>\n<li>移动赋值函数</li>\n</ul><p>生成这些特殊成员函数（或不生成）的规则比较复杂，感兴趣的话你可以查看参考资料 <span class=\"orange\">[3]</span>。每个特殊成员函数有几种不同的状态：</p><ul>\n<li>隐式声明还是用户声明</li>\n<li>默认提供还是用户提供</li>\n<li>正常状态还是删除状态</li>\n</ul><p>这三个状态是可组合的，虽然不是所有的组合都有效。隐式声明的必然是默认提供的；默认提供的才可能被删除；用户提供的也必然是用户声明的。</p><p>如果成员和父类没有特殊原因导致对象不可拷贝或移动，在用户不声明这些成员函数的情况下，编译器会自动产生这些成员函数，即隐式声明、默认提供、正常状态。有特殊成员、用户声明的话，情况就非常复杂了：</p><ul>\n<li>没有初始化的非静态 const 数据成员和引用类型数据成员会导致默认提供的默认构造函数被删除。</li>\n<li>非静态的 const 数据成员和引用类型数据成员会导致默认提供的拷贝构造函数、拷贝赋值函数、移动构造函数和移动赋值函数被删除。</li>\n<li>用户如果没有自己提供一个拷贝构造函数（必须形如 <code>Obj(Obj&amp;)</code> 或 <code>Obj(const Obj&amp;)</code>；不是模板），编译器会隐式声明一个。</li>\n<li>用户如果没有自己提供一个拷贝赋值函数（必须形如 <code>Obj&amp; operator=(Obj&amp;)</code> 或 <code>Obj&amp; operator=(const Obj&amp;)</code>；不是模板），编译器会隐式声明一个。</li>\n<li>用户如果自己声明了一个移动构造函数或移动赋值函数，则默认提供的拷贝构造函数和拷贝赋值函数被删除。</li>\n<li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。</li>\n<li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动构造函数和析构函数，编译器会隐式声明一个移动赋值函数。</li>\n<li>……</li>\n</ul><p>我不鼓励你去死记硬背这些规则，而是希望你在项目和测试中体会其缘由。我认为这些规则还相当合理，虽然有略偏保守之嫌。尤其是关于移动构造和赋值：只要用户声明了另外的特殊成员函数中的任何一个，编译器就不默认提供了。不过嘛，缺省慢点总比缺省不安全要好……</p><p>我们这儿主要要说的是，我们可以改变缺省行为，在编译器能默认提供特殊成员函数时将其删除，或在编译器不默认提供特殊成员函数时明确声明其需要默认提供（不过，要注意，即使用户要求默认提供，编译器也可能根据其他规则将特殊成员函数标为删除）。</p><p>还是举例子来说明一下。对于下面这样的类，编译器看到有用户提供的构造函数，就会不默认提供默认构造函数：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass my_array {\npublic:\n  my_array(size_t size);\n  …\nprivate:\n  T*     data_{nullptr};\n  size_t size_{0};\n};\n</code></pre><p>在没有默认初始化时，我们如果需要默认构造函数，就需要手工写一个，如：</p><pre><code class=\"language-c++\">  my_array()\n    : data_(nullptr)\n    , size_(0) {}\n</code></pre><p>可有了默认初始化之后，这个构造函数显然就不必要了，所以我们现在可以写：</p><pre><code class=\"language-c++\">  my_array() = default;\n</code></pre><p>再来一个反向的例子。我们<a href=\"https://time.geekbang.org/column/article/169225\">[第 1 讲]</a> 里的 <code>shape_wrapper</code>，它的复制行为是不安全的。我们可以像<a href=\"https://time.geekbang.org/column/article/169263\">[第 2 讲]</a> 里一样去改进它，但如果正常情况不需要复制行为、只是想防止其他开发人员误操作时，我们可以简单地在类的定义中加入：</p><pre><code class=\"language-c++\">class shape_wrapper {\n  …\n  shape_wrapper(\n    const shape_wrapper&amp;) = delete;\n  shape_wrapper&amp; operator=(\n    const shape_wrapper&amp;) = delete;\n  …\n};\n</code></pre><p>在 C++11 之前，我们可能会用在 <code>private</code> 段里声明这些成员函数的方法，来达到相似的目的。但目前这个语法效果更好，可以产生更明确的错误信息。另外，你可以注意一下，用户声明成删除也是一种声明，因此编译器不会提供默认版本的移动构造和移动赋值函数。</p><h2>override 和 final 说明符</h2><p><code>override</code> 和 <code>final</code> 是两个 C++11 引入的新说明符。它们不是关键词，仅在出现在函数声明尾部时起作用，不影响我们使用这两个词作变量名等其他用途。这两个说明符可以单个或组合使用，都是加在类成员函数声明的尾部。</p><p><code>override</code> 显式声明了成员函数是一个虚函数且覆盖了基类中的该函数。如果有 <code>override</code> 声明的函数不是虚函数，或基类中不存在这个虚函数，编译器会报告错误。这个说明符的主要作用有两个：</p><ul>\n<li>给开发人员更明确的提示，这个函数覆写了基类的成员函数；</li>\n<li>让编译器进行额外的检查，防止程序员由于拼写错误或代码改动没有让基类和派生类中的成员函数名称完全一致。</li>\n</ul><p><code>final</code> 则声明了成员函数是一个虚函数，且该虚函数不可在派生类中被覆盖。如果有一点没有得到满足的话，编译器就会报错。</p><p><code>final</code> 还有一个作用是标志某个类或结构不可被派生。同样，这时应将其放在被定义的类或结构名后面。</p><p>用法示意如下：</p><pre><code class=\"language-c++\">class A {\npublic:\n  virtual void foo();\n  virtual void bar();\n  void foobar();\n};\n\nclass B : public A {\npublic:\n  void foo() override; // OK\n  void bar() override final; // OK\n  //void foobar() override;\n  // 非虚函数不能 override\n};\n\nclass C final : public B {\npublic:\n  void foo() override; // OK\n  //void bar() override;\n  // final 函数不可 override\n};\n\nclass D : public C {\n  // 错误：final 类不可派生\n  …\n};\n</code></pre><h2>内容小结</h2><p>今天我们介绍了现代 C++ 引入的另外几个易用性改进：自定义字面量，二进制字面量，数字分隔符，静态断言，default 和 delete 成员函数，及 override 和 final。同上一讲介绍的易用性改进一样，这些新功能可以改进代码的可读性，同时也不会带来额外的开销。在任何有条件使用满足新 C++ 标准的编译器的项目中，都应该考虑使用这些新特性。</p><h2>课后思考</h2><p>你最喜欢的 C++ 易用性改进是什么？为什么？</p><p>欢迎留言和我分享你的看法！</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “<em>Mars Climate Orbiter</em>”. <a href=\"https://en.wikipedia.org/wiki/Mars_Climate_Orbiter\">https://en.wikipedia.org/wiki/Mars_Climate_Orbiter</a> </span></p><p><span class=\"reference\">[1a] 维基百科, “火星气候探测者号”. <a href=\"https://zh.wikipedia.org/zh-cn/%E7%81%AB%E6%98%9F%E6%B0%A3%E5%80%99%E6%8E%A2%E6%B8%AC%E8%80%85%E8%99%9F\">https://zh.wikipedia.org/zh-cn/火星氣候探測者號</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “User-defined literals”. <a href=\"https://en.cppreference.com/w/cpp/language/user_literal\">https://en.cppreference.com/w/cpp/language/user_literal</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “用户定义字面量”. <a href=\"https://zh.cppreference.com/w/cpp/language/user_literal\">https://zh.cppreference.com/w/cpp/language/user_literal</a> </span></p><p><span class=\"reference\">[3] cppreference.com, “Non-static member functions”, section “Special member functions”. <a href=\"https://en.cppreference.com/w/cpp/language/member_functions\">https://en.cppreference.com/w/cpp/language/member_functions</a> </span></p><p><span class=\"reference\">[3a] cppreference.com, “非静态成员函数”, “特殊成员函数”部分. <a href=\"https://zh.cppreference.com/w/cpp/language/member_functions\">https://zh.cppreference.com/w/cpp/language/member_functions</a> </span></p>","comments":[{"had_liked":false,"id":162767,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1576586550,"is_pvip":false,"replies":[{"id":61883,"content":"C++ 项目入门都不容易，要找自己有兴趣的领域是关键。除了第 6 讲评论里推荐的那些，可以考虑下面两个（我将来也会讲到）：\n\n- EasyLogging++\n- Catch2","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576625565,"ip_address":"","comment_id":162767,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"您好，您有没有感觉比较好的开源c++项目推荐？ \n希望从别人的项目中学到一些经验，谢谢！","like_count":14},{"had_liked":false,"id":347695,"user_name":"瓜农","can_delete":false,"product_type":"c1","uid":1732221,"ip_address":"","ucode":"CF6B8E5B74BCA9","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6e/7d/0485232b.jpg","comment_is_top":false,"comment_ctime":1654321747,"is_pvip":false,"replies":[{"id":126774,"content":"如果你不需要性能，那你可以有抽象和优雅。见 Python。\n\n如果你不需要抽象，那你可以有简单和性能（但程序员用起来会很费力）。见 C。\n\n如果你不需要向后兼容性，用几十年的经验设计一种全新的语言，那你也至少可以做到兼顾抽象、优雅和性能（简单是简单不了了）。见 Rust。\n\n如果你啥都想要：性能，抽象，向后兼容性。那你就忘掉优雅吧，你会得到一个类似于 C++ 的东西。除非有人在 1980 之前能开天眼，那也许能设计出一个更优雅的东西。\n\n但那也不会是 Rust——在 C++ 诞生的年代，Rust 的编译速度恐怕没有任何人能承担得起。\n\n也不会是 Java。虚函数是有性能代价的，甚至是巨大的性能代价。Java 的虚拟机都是要用到 C++ 的。\n\n另外，const 为什么要用 final 来修饰？我觉得 Java 的这个设计也很没道理。C++ 里 final 基本不需要，也是受了其他语言的影响才有的，并且是个说明符，不是关键字。我在项目里从来没写过 final（override 还是经常需要的）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1654425261,"ip_address":"","comment_id":347695,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"一直有种感觉，相对于java，c++的语法设计略显随意不够自洽。\n譬如const&#47;final在java里面就final搞定了，vitual这个关键字也感觉比较鸡肋。\n老师怎么看","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478143,"discussion_content":"C++ 项目入门都不容易，要找自己有兴趣的领域是关键。除了第 6 讲评论里推荐的那些，可以考虑下面两个（我将来也会讲到）：\n\n- EasyLogging++\n- Catch2","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576625565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512537,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","nickname":"木瓜777","note":"","ucode":"FC52A499AF6374","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87102,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576643487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248361,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1600133248,"is_pvip":false,"replies":[{"id":91287,"content":"你在 Man 类里有私有成员变量 Boy a，又没有去初始化，那不就默认构造了么。\n\n如果你想用参数 boy 去拷贝构造 a，你需要写：\n\n    Man(Boy boy) : a(boy)\n    {\n        cout &lt;&lt; &quot;man constructor with boy &quot; &lt;&lt; endl;\n    }\n\n这样会拷贝构造两次。我想你真正需要的可能是（我加上了拷贝构造函数的 const）：\n\nclass Boy {\npublic:\n    Boy() { cout &lt;&lt; &quot;boy constructor&quot; &lt;&lt; endl; }\n    Boy(const Boy&amp; m) { cout &lt;&lt; &quot;boy copy constructor&quot; &lt;&lt; endl; }\n    Boy(Boy&amp;&amp; m) { cout &lt;&lt; &quot;boy move constructor&quot; &lt;&lt; endl; }\n};\n\nclass Man {\npublic:\n    Man() { cout &lt;&lt; &quot;man constructor  &quot; &lt;&lt; endl; }\n    Man(const Boy&amp; boy) : a(boy)\n    {\n        cout &lt;&lt; &quot;man constructor with boy &quot; &lt;&lt; endl;\n    }\n    Man(Man&amp; m) { cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl; }\n    Man(Man&amp;&amp; m) { cout &lt;&lt; &quot;move constructor&quot; &lt;&lt; endl; }\n\nprivate:\n    Boy a;\n};","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1600256329,"ip_address":"","comment_id":248361,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"代码如下：\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\n\n class dummy{\n\n };\nclass Boy{\npublic:\n    Boy(){\n        cout&lt;&lt;&quot;boy  constructor&quot;&lt;&lt;endl;\n    }\n    Boy(Boy&amp; m){\n        cout&lt;&lt;&quot;boy copy constructor&quot;&lt;&lt;endl;\n    }\n    Boy(Boy&amp;&amp; m){\n        cout&lt;&lt;&quot;boy move constructor&quot;&lt;&lt;endl;\n    }\n};\n\n class Man{\n\n public:\n    Man(){\n        cout&lt;&lt;&quot;man constructor  &quot;&lt;&lt;endl;\n    }\n     Man(Boy boy){\n         cout&lt;&lt;&quot;man constructor with boy &quot;&lt;&lt;endl;\n     }\n     Man(Man &amp;m){\n         cout&lt;&lt;&quot;copy constructor&quot;&lt;&lt;endl;\n     }\n     Man(Man&amp;&amp; m){\n         cout&lt;&lt;&quot;move constructor&quot;&lt;&lt;endl;\n     }\n\n private:\n     Boy a;\n };\n int main(){\n     dummy d;\n     dummy d2;\n     d = d2;\n     dummy d3 = d2;\n     std::cout &lt;&lt; &quot;***************&quot; &lt;&lt;std::endl;\n\n     Boy&amp;&amp; boy = Boy();\n     Boy&amp; b = boy;\n     std::cout &lt;&lt; &quot;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&quot; &lt;&lt;std::endl;\n\n      make_shared&lt;Man&gt;(boy); \n\n     std::cout &lt;&lt; &quot;###############&quot; &lt;&lt;std::endl;\n\n     make_shared&lt;Man&gt;(move(boy));\n }\n \n 输出的结果：\n***************\nboy  constructor\n&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;\nboy copy constructor\nboy  constructor    疑惑：为什么会调用Boy的构造函数呢？\nman constructor with boy \n###############\nboy move constructor\nboy  constructor  \nman constructor with boy \n\nProcess finished with exit code 0\n\n老师，如上“疑惑”所述，为什么会调用Boy的构造函数呢？我觉得不应该调用Boy的构造函数，因为调用了boy 拷贝构造，然后再调用Man的拷贝构造，就可以了。想不通。","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505633,"discussion_content":"你在 Man 类里有私有成员变量 Boy a，又没有去初始化，那不就默认构造了么。\n\n如果你想用参数 boy 去拷贝构造 a，你需要写：\n\n    Man(Boy boy) : a(boy)\n    {\n        cout &amp;lt;&amp;lt; &amp;quot;man constructor with boy &amp;quot; &amp;lt;&amp;lt; endl;\n    }\n\n这样会拷贝构造两次。我想你真正需要的可能是（我加上了拷贝构造函数的 const）：\n\nclass Boy {\npublic:\n    Boy() { cout &amp;lt;&amp;lt; &amp;quot;boy constructor&amp;quot; &amp;lt;&amp;lt; endl; }\n    Boy(const Boy&amp;amp; m) { cout &amp;lt;&amp;lt; &amp;quot;boy copy constructor&amp;quot; &amp;lt;&amp;lt; endl; }\n    Boy(Boy&amp;amp;&amp;amp; m) { cout &amp;lt;&amp;lt; &amp;quot;boy move constructor&amp;quot; &amp;lt;&amp;lt; endl; }\n};\n\nclass Man {\npublic:\n    Man() { cout &amp;lt;&amp;lt; &amp;quot;man constructor  &amp;quot; &amp;lt;&amp;lt; endl; }\n    Man(const Boy&amp;amp; boy) : a(boy)\n    {\n        cout &amp;lt;&amp;lt; &amp;quot;man constructor with boy &amp;quot; &amp;lt;&amp;lt; endl;\n    }\n    Man(Man&amp;amp; m) { cout &amp;lt;&amp;lt; &amp;quot;copy constructor&amp;quot; &amp;lt;&amp;lt; endl; }\n    Man(Man&amp;amp;&amp;amp; m) { cout &amp;lt;&amp;lt; &amp;quot;move constructor&amp;quot; &amp;lt;&amp;lt; endl; }\n\nprivate:\n    Boy a;\n};","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600256329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231126,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1593589670,"is_pvip":false,"replies":[{"id":85392,"content":"0 也是 2 的整数次幂，没毛病。😁 这是很标准的算法，我很早就看到过。\n\n从实用的角度，这一个判断可能确实不够。我的实际代码里有：\n\n    STATIC_ASSERT(alignment::value &gt; 0 &amp;&amp; alignment::value &lt;= 8192,\n                  Bad_alignment);\n    STATIC_ASSERT((alignment::value &amp; (alignment::value - 1)) == 0,\n                  Alignment_must_be_power_of_two);\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1593651304,"ip_address":"","comment_id":231126,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，您好。\n请问您在static_assert中使用的例子，是不是应该判断alignment &amp;&amp; (alignment &amp; (alignment - 1) ==0)?\n另外，这个算法真是精巧👍。效率之高让我甚至一度怀疑命题的等价性。证明了一下确实是等价的。","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505633,"discussion_content":"你在 Man 类里有私有成员变量 Boy a，又没有去初始化，那不就默认构造了么。\n\n如果你想用参数 boy 去拷贝构造 a，你需要写：\n\n    Man(Boy boy) : a(boy)\n    {\n        cout &amp;lt;&amp;lt; &amp;quot;man constructor with boy &amp;quot; &amp;lt;&amp;lt; endl;\n    }\n\n这样会拷贝构造两次。我想你真正需要的可能是（我加上了拷贝构造函数的 const）：\n\nclass Boy {\npublic:\n    Boy() { cout &amp;lt;&amp;lt; &amp;quot;boy constructor&amp;quot; &amp;lt;&amp;lt; endl; }\n    Boy(const Boy&amp;amp; m) { cout &amp;lt;&amp;lt; &amp;quot;boy copy constructor&amp;quot; &amp;lt;&amp;lt; endl; }\n    Boy(Boy&amp;amp;&amp;amp; m) { cout &amp;lt;&amp;lt; &amp;quot;boy move constructor&amp;quot; &amp;lt;&amp;lt; endl; }\n};\n\nclass Man {\npublic:\n    Man() { cout &amp;lt;&amp;lt; &amp;quot;man constructor  &amp;quot; &amp;lt;&amp;lt; endl; }\n    Man(const Boy&amp;amp; boy) : a(boy)\n    {\n        cout &amp;lt;&amp;lt; &amp;quot;man constructor with boy &amp;quot; &amp;lt;&amp;lt; endl;\n    }\n    Man(Man&amp;amp; m) { cout &amp;lt;&amp;lt; &amp;quot;copy constructor&amp;quot; &amp;lt;&amp;lt; endl; }\n    Man(Man&amp;amp;&amp;amp; m) { cout &amp;lt;&amp;lt; &amp;quot;move constructor&amp;quot; &amp;lt;&amp;lt; endl; }\n\nprivate:\n    Boy a;\n};","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600256329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163839,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1576810205,"is_pvip":false,"replies":[{"id":62313,"content":"对，final override 合法但不必要。\n\n当然不是所有内容都是被那个游戏开发人士喷的。他抱怨的是会导致编译速度下降，以及非优化编译性能差的那部份功能。通常都是模板相关的。所以这一讲的内容不属于其中。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576819337,"ip_address":"","comment_id":163839,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"如果对一个函数声明了final, 我觉得没有必要在添加override了吧. \noverride就是明确声明这是一个继承来的函数, final同样也是这个意思, 只不过final更霸道, 后续的不要在继承了! \n如果从一开始就不想让别的函数去继承而写final, 那就根本没必要去virtual它. 何必要在虚函数表中添加一个没有继承作用的虚函数呢?\n\nPS: 数字分隔符和自定义字面量真是学到了. 在9102年的尾巴, 我才知道有这么邪道的用法...\nPPS: 前些日子看了一些国外游戏大牛各种喷C++的帖子. 本章的所有内容应该都是他们喷的范围吧... 那些人特别看中编译时间, 追求极致的运行效率... 有个人专门对比了int a=7; 和 int a{7}的性能差别...从编译到运行时间... 利用宏展开的方式, 对这两个例子分别做了百万次展开, 如果用vs测试都能爆IDE内存的级别... 我觉得对于中小型对性能不是特别敏感的程序, 这些还是很有用的. \nPPPS: 最近对Data-oriented design感兴趣, 不知道作者以后是否有开这类理论实战课程的计划捏? 我搜索上面喷神, 就是从这里开始搜索出来的...","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478549,"discussion_content":"对，final override 合法但不必要。\n\n当然不是所有内容都是被那个游戏开发人士喷的。他抱怨的是会导致编译速度下降，以及非优化编译性能差的那部份功能。通常都是模板相关的。所以这一讲的内容不属于其中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576819337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187968,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1584285276,"is_pvip":false,"replies":[{"id":72670,"content":"哦，这是因为 operator&quot;&quot; 的参数要求是 long double（不是 double)。而一般的类里，double 的精度就够用了。倒不算什么刻意为之吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584328992,"ip_address":"","comment_id":187968,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"length的例子里，字面量operator&quot;&quot;实现中参数是long double,但是length成员变量value使用的是double，这是有意为之吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487306,"discussion_content":"哦，这是因为 operator&amp;quot;&amp;quot; 的参数要求是 long double（不是 double)。而一般的类里，double 的精度就够用了。倒不算什么刻意为之吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584328992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314365,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1632987477,"is_pvip":false,"replies":[{"id":113884,"content":"这也只是你的一家之言。大部分人最喜欢的是 auto。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1633146311,"ip_address":"","comment_id":314365,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"唯一喜欢的易用性改造就是列表初始化，其它的反而增加了复杂度。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527661,"discussion_content":"这也只是你的一家之言。大部分人最喜欢的是 auto。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633146311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281930,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1614955535,"is_pvip":false,"replies":[{"id":102506,"content":"对。override 的函数的参数是一样的，子类覆盖父类。overload 的函数的参数是不一样的，根据参数来选择合适的函数。两者不能混淆。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615200512,"ip_address":"","comment_id":281930,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，关于子类中重新定义虚函数这个动作我之前认为是重写(overwrite)，但也碰到有人说是重载(overload)，另外我看文章中说的是覆写(就是override的翻译吧？)。\n我个人倾向于overwrite或者override，因为重新定义虚函数这个动作涉及了多个类，而重载是指同一个类中的一组同名但形参个数或者形参类型不同的方法。我认为override是包含overwrite的，overwrite只说子类重新实现基类虚函数这种情况，而override则是覆盖，只要子类有了和基类中同名的方法，都会隐藏父类中的同名方法，如果子类能创建对象，必须要实现虚函数，因而就会隐藏基类中的同名方法。\n老师看下我说的有问题吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527661,"discussion_content":"这也只是你的一家之言。大部分人最喜欢的是 auto。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633146311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181678,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1582614734,"is_pvip":false,"replies":[{"id":70373,"content":"小改进，适合的就用起来。但也不用强求为了用而用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582616771,"ip_address":"","comment_id":181678,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"之前用default delete override final较多\nstatic_assert 和 自定义字面量和二进制字面量用的少 争取以后可以使用在自己的项目中 提供便利 老师的硬货很多 受益匪浅 感谢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516552,"discussion_content":"对。override 的函数的参数是一样的，子类覆盖父类。overload 的函数的参数是不一样的，根据参数来选择合适的函数。两者不能混淆。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615200512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162157,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1576468085,"is_pvip":false,"replies":[{"id":61711,"content":"都用上了吗？很好啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576474443,"ip_address":"","comment_id":162157,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我最喜欢的C++易用性改进及理由：\nauto： 少打字\nscope for：少打字\n类成员默认补始化语法：少打字\ndefault 和 delete 成员函数：简化对类行为的控制难度\n自定义字面量：代码看起来舒服。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477972,"discussion_content":"都用上了吗？很好啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576474443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83980,"discussion_content":"都用上了啊，基本所有C++11的新特性我都在使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576477995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162767,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1576586550,"is_pvip":false,"replies":[{"id":61883,"content":"C++ 项目入门都不容易，要找自己有兴趣的领域是关键。除了第 6 讲评论里推荐的那些，可以考虑下面两个（我将来也会讲到）：\n\n- EasyLogging++\n- Catch2","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576625565,"ip_address":"","comment_id":162767,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"您好，您有没有感觉比较好的开源c++项目推荐？ \n希望从别人的项目中学到一些经验，谢谢！","like_count":14,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478143,"discussion_content":"C++ 项目入门都不容易，要找自己有兴趣的领域是关键。除了第 6 讲评论里推荐的那些，可以考虑下面两个（我将来也会讲到）：\n\n- EasyLogging++\n- Catch2","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576625565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512537,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","nickname":"木瓜777","note":"","ucode":"FC52A499AF6374","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87102,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576643487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347695,"user_name":"瓜农","can_delete":false,"product_type":"c1","uid":1732221,"ip_address":"","ucode":"CF6B8E5B74BCA9","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6e/7d/0485232b.jpg","comment_is_top":false,"comment_ctime":1654321747,"is_pvip":false,"replies":[{"id":126774,"content":"如果你不需要性能，那你可以有抽象和优雅。见 Python。\n\n如果你不需要抽象，那你可以有简单和性能（但程序员用起来会很费力）。见 C。\n\n如果你不需要向后兼容性，用几十年的经验设计一种全新的语言，那你也至少可以做到兼顾抽象、优雅和性能（简单是简单不了了）。见 Rust。\n\n如果你啥都想要：性能，抽象，向后兼容性。那你就忘掉优雅吧，你会得到一个类似于 C++ 的东西。除非有人在 1980 之前能开天眼，那也许能设计出一个更优雅的东西。\n\n但那也不会是 Rust——在 C++ 诞生的年代，Rust 的编译速度恐怕没有任何人能承担得起。\n\n也不会是 Java。虚函数是有性能代价的，甚至是巨大的性能代价。Java 的虚拟机都是要用到 C++ 的。\n\n另外，const 为什么要用 final 来修饰？我觉得 Java 的这个设计也很没道理。C++ 里 final 基本不需要，也是受了其他语言的影响才有的，并且是个说明符，不是关键字。我在项目里从来没写过 final（override 还是经常需要的）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1654425261,"ip_address":"","comment_id":347695,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"一直有种感觉，相对于java，c++的语法设计略显随意不够自洽。\n譬如const&#47;final在java里面就final搞定了，vitual这个关键字也感觉比较鸡肋。\n老师怎么看","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574895,"discussion_content":"如果你不需要性能，那你可以有抽象和优雅。见 Python。\n\n如果你不需要抽象，那你可以有简单和性能（但程序员用起来会很费力）。见 C。\n\n如果你不需要向后兼容性，用几十年的经验设计一种全新的语言，那你也至少可以做到兼顾抽象、优雅和性能（简单是简单不了了）。见 Rust。\n\n如果你啥都想要：性能，抽象，向后兼容性。那你就忘掉优雅吧，你会得到一个类似于 C++ 的东西。除非有人在 1980 之前能开天眼，那也许能设计出一个更优雅的东西。\n\n但那也不会是 Rust——在 C++ 诞生的年代，Rust 的编译速度恐怕没有任何人能承担得起。\n\n也不会是 Java。虚函数是有性能代价的，甚至是巨大的性能代价。Java 的虚拟机都是要用到 C++ 的。\n\n另外，const 为什么要用 final 来修饰？我觉得 Java 的这个设计也很没道理。C++ 里 final 基本不需要，也是受了其他语言的影响才有的，并且是个说明符，不是关键字。我在项目里从来没写过 final（override 还是经常需要的）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654425261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248361,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1600133248,"is_pvip":false,"replies":[{"id":91287,"content":"你在 Man 类里有私有成员变量 Boy a，又没有去初始化，那不就默认构造了么。\n\n如果你想用参数 boy 去拷贝构造 a，你需要写：\n\n    Man(Boy boy) : a(boy)\n    {\n        cout &lt;&lt; &quot;man constructor with boy &quot; &lt;&lt; endl;\n    }\n\n这样会拷贝构造两次。我想你真正需要的可能是（我加上了拷贝构造函数的 const）：\n\nclass Boy {\npublic:\n    Boy() { cout &lt;&lt; &quot;boy constructor&quot; &lt;&lt; endl; }\n    Boy(const Boy&amp; m) { cout &lt;&lt; &quot;boy copy constructor&quot; &lt;&lt; endl; }\n    Boy(Boy&amp;&amp; m) { cout &lt;&lt; &quot;boy move constructor&quot; &lt;&lt; endl; }\n};\n\nclass Man {\npublic:\n    Man() { cout &lt;&lt; &quot;man constructor  &quot; &lt;&lt; endl; }\n    Man(const Boy&amp; boy) : a(boy)\n    {\n        cout &lt;&lt; &quot;man constructor with boy &quot; &lt;&lt; endl;\n    }\n    Man(Man&amp; m) { cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl; }\n    Man(Man&amp;&amp; m) { cout &lt;&lt; &quot;move constructor&quot; &lt;&lt; endl; }\n\nprivate:\n    Boy a;\n};","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1600256329,"ip_address":"","comment_id":248361,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"代码如下：\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\n\n class dummy{\n\n };\nclass Boy{\npublic:\n    Boy(){\n        cout&lt;&lt;&quot;boy  constructor&quot;&lt;&lt;endl;\n    }\n    Boy(Boy&amp; m){\n        cout&lt;&lt;&quot;boy copy constructor&quot;&lt;&lt;endl;\n    }\n    Boy(Boy&amp;&amp; m){\n        cout&lt;&lt;&quot;boy move constructor&quot;&lt;&lt;endl;\n    }\n};\n\n class Man{\n\n public:\n    Man(){\n        cout&lt;&lt;&quot;man constructor  &quot;&lt;&lt;endl;\n    }\n     Man(Boy boy){\n         cout&lt;&lt;&quot;man constructor with boy &quot;&lt;&lt;endl;\n     }\n     Man(Man &amp;m){\n         cout&lt;&lt;&quot;copy constructor&quot;&lt;&lt;endl;\n     }\n     Man(Man&amp;&amp; m){\n         cout&lt;&lt;&quot;move constructor&quot;&lt;&lt;endl;\n     }\n\n private:\n     Boy a;\n };\n int main(){\n     dummy d;\n     dummy d2;\n     d = d2;\n     dummy d3 = d2;\n     std::cout &lt;&lt; &quot;***************&quot; &lt;&lt;std::endl;\n\n     Boy&amp;&amp; boy = Boy();\n     Boy&amp; b = boy;\n     std::cout &lt;&lt; &quot;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&quot; &lt;&lt;std::endl;\n\n      make_shared&lt;Man&gt;(boy); \n\n     std::cout &lt;&lt; &quot;###############&quot; &lt;&lt;std::endl;\n\n     make_shared&lt;Man&gt;(move(boy));\n }\n \n 输出的结果：\n***************\nboy  constructor\n&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;\nboy copy constructor\nboy  constructor    疑惑：为什么会调用Boy的构造函数呢？\nman constructor with boy \n###############\nboy move constructor\nboy  constructor  \nman constructor with boy \n\nProcess finished with exit code 0\n\n老师，如上“疑惑”所述，为什么会调用Boy的构造函数呢？我觉得不应该调用Boy的构造函数，因为调用了boy 拷贝构造，然后再调用Man的拷贝构造，就可以了。想不通。","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574895,"discussion_content":"如果你不需要性能，那你可以有抽象和优雅。见 Python。\n\n如果你不需要抽象，那你可以有简单和性能（但程序员用起来会很费力）。见 C。\n\n如果你不需要向后兼容性，用几十年的经验设计一种全新的语言，那你也至少可以做到兼顾抽象、优雅和性能（简单是简单不了了）。见 Rust。\n\n如果你啥都想要：性能，抽象，向后兼容性。那你就忘掉优雅吧，你会得到一个类似于 C++ 的东西。除非有人在 1980 之前能开天眼，那也许能设计出一个更优雅的东西。\n\n但那也不会是 Rust——在 C++ 诞生的年代，Rust 的编译速度恐怕没有任何人能承担得起。\n\n也不会是 Java。虚函数是有性能代价的，甚至是巨大的性能代价。Java 的虚拟机都是要用到 C++ 的。\n\n另外，const 为什么要用 final 来修饰？我觉得 Java 的这个设计也很没道理。C++ 里 final 基本不需要，也是受了其他语言的影响才有的，并且是个说明符，不是关键字。我在项目里从来没写过 final（override 还是经常需要的）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654425261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231126,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1593589670,"is_pvip":false,"replies":[{"id":85392,"content":"0 也是 2 的整数次幂，没毛病。😁 这是很标准的算法，我很早就看到过。\n\n从实用的角度，这一个判断可能确实不够。我的实际代码里有：\n\n    STATIC_ASSERT(alignment::value &gt; 0 &amp;&amp; alignment::value &lt;= 8192,\n                  Bad_alignment);\n    STATIC_ASSERT((alignment::value &amp; (alignment::value - 1)) == 0,\n                  Alignment_must_be_power_of_two);\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1593651304,"ip_address":"","comment_id":231126,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，您好。\n请问您在static_assert中使用的例子，是不是应该判断alignment &amp;&amp; (alignment &amp; (alignment - 1) ==0)?\n另外，这个算法真是精巧👍。效率之高让我甚至一度怀疑命题的等价性。证明了一下确实是等价的。","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500166,"discussion_content":"0 也是 2 的整数次幂，没毛病。😁 这是很标准的算法，我很早就看到过。\n\n从实用的角度，这一个判断可能确实不够。我的实际代码里有：\n\n    STATIC_ASSERT(alignment::value &amp;gt; 0 &amp;amp;&amp;amp; alignment::value &amp;lt;= 8192,\n                  Bad_alignment);\n    STATIC_ASSERT((alignment::value &amp;amp; (alignment::value - 1)) == 0,\n                  Alignment_must_be_power_of_two);\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593651304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288162,"discussion_content":"大概总结并证明了一下这个判断方法，https://blog.csdn.net/zheng_easyfan/article/details/107067077 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593664085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288161,"discussion_content":"额是的，0本身不是问题，我主要concern的是alignment-1可能带来的情况。不知道您有两个断言，不好意思哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593663947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163839,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1576810205,"is_pvip":false,"replies":[{"id":62313,"content":"对，final override 合法但不必要。\n\n当然不是所有内容都是被那个游戏开发人士喷的。他抱怨的是会导致编译速度下降，以及非优化编译性能差的那部份功能。通常都是模板相关的。所以这一讲的内容不属于其中。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576819337,"ip_address":"","comment_id":163839,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"如果对一个函数声明了final, 我觉得没有必要在添加override了吧. \noverride就是明确声明这是一个继承来的函数, final同样也是这个意思, 只不过final更霸道, 后续的不要在继承了! \n如果从一开始就不想让别的函数去继承而写final, 那就根本没必要去virtual它. 何必要在虚函数表中添加一个没有继承作用的虚函数呢?\n\nPS: 数字分隔符和自定义字面量真是学到了. 在9102年的尾巴, 我才知道有这么邪道的用法...\nPPS: 前些日子看了一些国外游戏大牛各种喷C++的帖子. 本章的所有内容应该都是他们喷的范围吧... 那些人特别看中编译时间, 追求极致的运行效率... 有个人专门对比了int a=7; 和 int a{7}的性能差别...从编译到运行时间... 利用宏展开的方式, 对这两个例子分别做了百万次展开, 如果用vs测试都能爆IDE内存的级别... 我觉得对于中小型对性能不是特别敏感的程序, 这些还是很有用的. \nPPPS: 最近对Data-oriented design感兴趣, 不知道作者以后是否有开这类理论实战课程的计划捏? 我搜索上面喷神, 就是从这里开始搜索出来的...","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500166,"discussion_content":"0 也是 2 的整数次幂，没毛病。😁 这是很标准的算法，我很早就看到过。\n\n从实用的角度，这一个判断可能确实不够。我的实际代码里有：\n\n    STATIC_ASSERT(alignment::value &amp;gt; 0 &amp;amp;&amp;amp; alignment::value &amp;lt;= 8192,\n                  Bad_alignment);\n    STATIC_ASSERT((alignment::value &amp;amp; (alignment::value - 1)) == 0,\n                  Alignment_must_be_power_of_two);\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593651304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288162,"discussion_content":"大概总结并证明了一下这个判断方法，https://blog.csdn.net/zheng_easyfan/article/details/107067077 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593664085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288161,"discussion_content":"额是的，0本身不是问题，我主要concern的是alignment-1可能带来的情况。不知道您有两个断言，不好意思哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593663947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187968,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1584285276,"is_pvip":false,"replies":[{"id":72670,"content":"哦，这是因为 operator&quot;&quot; 的参数要求是 long double（不是 double)。而一般的类里，double 的精度就够用了。倒不算什么刻意为之吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584328992,"ip_address":"","comment_id":187968,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"length的例子里，字面量operator&quot;&quot;实现中参数是long double,但是length成员变量value使用的是double，这是有意为之吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478549,"discussion_content":"对，final override 合法但不必要。\n\n当然不是所有内容都是被那个游戏开发人士喷的。他抱怨的是会导致编译速度下降，以及非优化编译性能差的那部份功能。通常都是模板相关的。所以这一讲的内容不属于其中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576819337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314365,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1632987477,"is_pvip":false,"replies":[{"id":113884,"content":"这也只是你的一家之言。大部分人最喜欢的是 auto。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1633146311,"ip_address":"","comment_id":314365,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"唯一喜欢的易用性改造就是列表初始化，其它的反而增加了复杂度。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487306,"discussion_content":"哦，这是因为 operator&amp;quot;&amp;quot; 的参数要求是 long double（不是 double)。而一般的类里，double 的精度就够用了。倒不算什么刻意为之吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584328992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281930,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1614955535,"is_pvip":false,"replies":[{"id":102506,"content":"对。override 的函数的参数是一样的，子类覆盖父类。overload 的函数的参数是不一样的，根据参数来选择合适的函数。两者不能混淆。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615200512,"ip_address":"","comment_id":281930,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，关于子类中重新定义虚函数这个动作我之前认为是重写(overwrite)，但也碰到有人说是重载(overload)，另外我看文章中说的是覆写(就是override的翻译吧？)。\n我个人倾向于overwrite或者override，因为重新定义虚函数这个动作涉及了多个类，而重载是指同一个类中的一组同名但形参个数或者形参类型不同的方法。我认为override是包含overwrite的，overwrite只说子类重新实现基类虚函数这种情况，而override则是覆盖，只要子类有了和基类中同名的方法，都会隐藏父类中的同名方法，如果子类能创建对象，必须要实现虚函数，因而就会隐藏基类中的同名方法。\n老师看下我说的有问题吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516552,"discussion_content":"对。override 的函数的参数是一样的，子类覆盖父类。overload 的函数的参数是不一样的，根据参数来选择合适的函数。两者不能混淆。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615200512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181678,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1582614734,"is_pvip":false,"replies":[{"id":70373,"content":"小改进，适合的就用起来。但也不用强求为了用而用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582616771,"ip_address":"","comment_id":181678,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"之前用default delete override final较多\nstatic_assert 和 自定义字面量和二进制字面量用的少 争取以后可以使用在自己的项目中 提供便利 老师的硬货很多 受益匪浅 感谢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485075,"discussion_content":"小改进，适合的就用起来。但也不用强求为了用而用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582616771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162157,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1576468085,"is_pvip":false,"replies":[{"id":61711,"content":"都用上了吗？很好啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576474443,"ip_address":"","comment_id":162157,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我最喜欢的C++易用性改进及理由：\nauto： 少打字\nscope for：少打字\n类成员默认补始化语法：少打字\ndefault 和 delete 成员函数：简化对类行为的控制难度\n自定义字面量：代码看起来舒服。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485075,"discussion_content":"小改进，适合的就用起来。但也不用强求为了用而用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582616771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388925,"user_name":"helloworldorz","can_delete":false,"product_type":"c1","uid":1158126,"ip_address":"江苏","ucode":"F1B318C1AFDA29","user_header":"https://static001.geekbang.org/account/avatar/00/11/ab/ee/25376a20.jpg","comment_is_top":false,"comment_ctime":1711182198,"is_pvip":false,"replies":[{"id":141561,"content":"嗯，作为默认行为这是好的做法。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1711416495,"ip_address":"上海","comment_id":388925,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"最喜欢类数据成员的默认初始化，变量定义的时候就应该显示得去初始化它","like_count":0},{"had_liked":false,"id":333922,"user_name":"铿","can_delete":false,"product_type":"c1","uid":1009996,"ip_address":"","ucode":"23112C33A80463","user_header":"https://static001.geekbang.org/account/avatar/00/0f/69/4c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1644585492,"is_pvip":false,"replies":[{"id":122066,"content":"严肃地讲，语法糖对于易用性非常重要。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1644794616,"ip_address":"","comment_id":333922,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"auto 和 for的语法糖","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550887,"discussion_content":"严肃地讲，语法糖对于易用性非常重要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644794616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246102,"user_name":"201200861","can_delete":false,"product_type":"c1","uid":1900763,"ip_address":"","ucode":"4133BCD32FE933","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4Wp0sNFxYLd9mceUOAOVulWVPdEGEiaC9SCx2ZhfD8W9XTMjJYezrXxmfuKYA0YtJ6iadeBZchsc9g/132","comment_is_top":false,"comment_ctime":1599179654,"is_pvip":false,"replies":[{"id":90442,"content":"你自己提供了，编译器自然就不会提供了。头文件里瞟一眼啰。如果是别人提供的类定义，从使用者的角度，不去看类定义，应该是无从分辨的。\n\n从使用者的角度，容易分辨的，只能是用户不提供这些特殊成员函数时，编译器有没有自动提供。使用一下，不报错，自然就是编译器自动提供了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599181800,"ip_address":"","comment_id":246102,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，你好，如何看移动构造函数和拷贝函数，是编译器提供的还是用户自己写的？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550887,"discussion_content":"严肃地讲，语法糖对于易用性非常重要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644794616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236501,"user_name":"赵国辉","can_delete":false,"product_type":"c1","uid":1166280,"ip_address":"","ucode":"390196BD3082B8","user_header":"https://static001.geekbang.org/account/avatar/00/11/cb/c8/ff9f3ffb.jpg","comment_is_top":false,"comment_ctime":1595429677,"is_pvip":false,"replies":[{"id":87426,"content":"直接搜索就好。我看结果很匹配的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1595480603,"ip_address":"","comment_id":236501,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，有没有对c++虚函数表实现原理讲解比较透彻的文章或者书籍推荐一下。对这方面比较感兴趣。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502097,"discussion_content":"直接搜索就好。我看结果很匹配的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595480603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183589,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1583072250,"is_pvip":false,"replies":[{"id":71121,"content":"嗯，这明显是代码后来改过了。初版的代码应该没有好好测过，问题还不止一个。\n\n顺着原先代码的思路也能实现的，但应该是下面这个样子（可参考第 15 讲）：\n\n#include &lt;stdexcept&gt;\n\nconstexpr int ipow(int x, int n)\n{\n    return n &gt; 0 ? x * ipow(x, n - 1) : 1;\n}\n\ntemplate &lt;typename C&gt;\nconstexpr int b3_helper(C c)\n{\n    if (c &lt; &#39;0&#39; || c &gt;= &#39;3&#39;) {\n        throw std::invalid_argument(&quot;not a ternary digit&quot;);\n    }\n    return c - &#39;0&#39;;\n}\n\ntemplate &lt;typename C, typename... Tail&gt;\nconstexpr int b3_helper(C c, Tail... tail)\n{\n    if (c &lt; &#39;0&#39; || c &gt;= &#39;3&#39;) {\n        throw std::invalid_argument(&quot;not a ternary digit&quot;);\n    }\n    return ipow(3, sizeof...(tail)) * (c - &#39;0&#39;) + b3_helper(tail...);\n}\n\ntemplate &lt;char... chars&gt;\nconstexpr int operator&quot;&quot; _b3()\n{\n    return b3_helper(chars...);\n}\n\n第一个 b3_helper 还可以进一步精简成：\n\nconstexpr int b3_helper()\n{\n    return 0;\n}","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583118398,"ip_address":"","comment_id":183589,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"第四版中文版中给出的代码是这样的：\nconstexpr int ipow(int x, int n) {\n    return (n &gt; 0) ? x * ipow(n - 1) : 1;\n}\ntemplate&lt;char c&gt;\nconstexpr int b3_helper() {\n    static_assert(c &lt; &#39;3&#39;, &quot;not a ternary digit&quot;);\n    return c;\n}\ntemplate&lt;char c,char ... tail&gt;\nconstexpr int b3_helper() {\n    static_assert(c &lt; &#39;3&#39;, &quot;not a ternary digit&quot;);\n    return ipow(3, sizeof...(tail)) * (c - &#39;0&#39;) + b3_helper(tail...);\n}\ntemplate&lt;char...chars&gt;\nconstexpr int operator&quot;&quot; _b3() {\n    return b3_helper(chars...);\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502097,"discussion_content":"直接搜索就好。我看结果很匹配的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595480603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183256,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1582983160,"is_pvip":false,"replies":[{"id":70916,"content":"我不知道你看到的是什么，我这边是编译通过了。完整代码如下：\n\n#include &lt;iostream&gt;\n\nconstexpr int ipow(int x, int n)\n{\n  return n &gt; 0 ? x * ipow(x, n - 1)\n               : 1;\n}\n\ntemplate &lt;char...&gt;\nstruct helper;\n\ntemplate &lt;char c&gt;\nstruct helper&lt;c&gt; {\n  static_assert(\n    &#39;0&#39; &lt;= c &amp;&amp; c &lt; &#39;3&#39;,\n    &quot;not a ternary digit&quot;);\n  static constexpr int value()\n  {\n    return c - &#39;0&#39;;\n  }\n};\n\ntemplate &lt;char c, char... tail&gt;\nstruct helper&lt;c, tail...&gt; {\n  static_assert(\n    &#39;0&#39; &lt;= c &amp;&amp; c &lt; &#39;3&#39;,\n    &quot;not a ternary digit&quot;);\n  static constexpr int value()\n  {\n    return (c - &#39;0&#39;) *\n             ipow(3,\n                  sizeof...(tail)) +\n           helper&lt;tail...&gt;::value();\n  }\n};\n\ntemplate &lt;char... chars&gt;\nconstexpr int operator&quot;&quot; _b3()\n{\n  return helper&lt;chars...&gt;::value();\n}\n\nint main()\n{\n  std::cout &lt;&lt; 201_b3 &lt;&lt; std::endl;\n}\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582993902,"ip_address":"","comment_id":183256,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"是19.2.6节三进制的那个例子，b3_helper的调用有问题，vs2019社区版报的是“应输入0个参数，却提供了3个”，但是把圆括号换成模板参数的尖括号又报告“未找到匹配的重载”。像这种怎么修改合适呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485620,"discussion_content":"我不知道你看到的是什么，我这边是编译通过了。完整代码如下：\n\n#include &amp;lt;iostream&amp;gt;\n\nconstexpr int ipow(int x, int n)\n{\n  return n &amp;gt; 0 ? x * ipow(x, n - 1)\n               : 1;\n}\n\ntemplate &amp;lt;char...&amp;gt;\nstruct helper;\n\ntemplate &amp;lt;char c&amp;gt;\nstruct helper&amp;lt;c&amp;gt; {\n  static_assert(\n    &amp;#39;0&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt; &amp;#39;3&amp;#39;,\n    &amp;quot;not a ternary digit&amp;quot;);\n  static constexpr int value()\n  {\n    return c - &amp;#39;0&amp;#39;;\n  }\n};\n\ntemplate &amp;lt;char c, char... tail&amp;gt;\nstruct helper&amp;lt;c, tail...&amp;gt; {\n  static_assert(\n    &amp;#39;0&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt; &amp;#39;3&amp;#39;,\n    &amp;quot;not a ternary digit&amp;quot;);\n  static constexpr int value()\n  {\n    return (c - &amp;#39;0&amp;#39;) *\n             ipow(3,\n                  sizeof...(tail)) +\n           helper&amp;lt;tail...&amp;gt;::value();\n  }\n};\n\ntemplate &amp;lt;char... chars&amp;gt;\nconstexpr int operator&amp;quot;&amp;quot; _b3()\n{\n  return helper&amp;lt;chars...&amp;gt;::value();\n}\n\nint main()\n{\n  std::cout &amp;lt;&amp;lt; 201_b3 &amp;lt;&amp;lt; std::endl;\n}\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582993902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1758903,"avatar":"","nickname":"tr","note":"","ucode":"020AB6A704CD43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191576,"discussion_content":"好的谢谢老师，我们看到的代码确实不一样…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583003905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1758903,"avatar":"","nickname":"tr","note":"","ucode":"020AB6A704CD43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191694,"discussion_content":"好奇了，是什么样的区别？印刷错误吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583028375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":191576,"ip_address":"","group_id":0},"score":191694,"extra":""}]}]},{"had_liked":false,"id":183003,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1582906409,"is_pvip":false,"replies":[{"id":70808,"content":"我没有中文版，我也不确定你说的是哪个版本。\n\n我看到第四版的19.2.6节似乎有类似你说的东西。请详细说一下你指的是哪一节的哪个例子，使用什么编译器，具体错误信息是什么。\n\n单独起一个新的评论，不要回复这一个。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582942085,"ip_address":"","comment_id":183003,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，本贾尼在他的《c++程序设计语言》中480页写了一种叫模板字面值常量的语法，不过他的代码编译不过。如果您有时间的话能不能帮忙看下是不是真的有这种写法还是说其他什么原因","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485620,"discussion_content":"我不知道你看到的是什么，我这边是编译通过了。完整代码如下：\n\n#include &amp;lt;iostream&amp;gt;\n\nconstexpr int ipow(int x, int n)\n{\n  return n &amp;gt; 0 ? x * ipow(x, n - 1)\n               : 1;\n}\n\ntemplate &amp;lt;char...&amp;gt;\nstruct helper;\n\ntemplate &amp;lt;char c&amp;gt;\nstruct helper&amp;lt;c&amp;gt; {\n  static_assert(\n    &amp;#39;0&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt; &amp;#39;3&amp;#39;,\n    &amp;quot;not a ternary digit&amp;quot;);\n  static constexpr int value()\n  {\n    return c - &amp;#39;0&amp;#39;;\n  }\n};\n\ntemplate &amp;lt;char c, char... tail&amp;gt;\nstruct helper&amp;lt;c, tail...&amp;gt; {\n  static_assert(\n    &amp;#39;0&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt; &amp;#39;3&amp;#39;,\n    &amp;quot;not a ternary digit&amp;quot;);\n  static constexpr int value()\n  {\n    return (c - &amp;#39;0&amp;#39;) *\n             ipow(3,\n                  sizeof...(tail)) +\n           helper&amp;lt;tail...&amp;gt;::value();\n  }\n};\n\ntemplate &amp;lt;char... chars&amp;gt;\nconstexpr int operator&amp;quot;&amp;quot; _b3()\n{\n  return helper&amp;lt;chars...&amp;gt;::value();\n}\n\nint main()\n{\n  std::cout &amp;lt;&amp;lt; 201_b3 &amp;lt;&amp;lt; std::endl;\n}\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582993902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1758903,"avatar":"","nickname":"tr","note":"","ucode":"020AB6A704CD43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191576,"discussion_content":"好的谢谢老师，我们看到的代码确实不一样…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583003905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1758903,"avatar":"","nickname":"tr","note":"","ucode":"020AB6A704CD43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191694,"discussion_content":"好奇了，是什么样的区别？印刷错误吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583028375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":191576,"ip_address":"","group_id":0},"score":191694,"extra":""}]}]},{"had_liked":false,"id":182121,"user_name":"皮皮侠","can_delete":false,"product_type":"c1","uid":1258402,"ip_address":"","ucode":"04205990C1DE1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","comment_is_top":false,"comment_ctime":1582712329,"is_pvip":false,"replies":[{"id":70521,"content":"最方便的确实是在循环里用 auto，尤其在基于范围的循环里。其他的也可以慢慢用起来。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582721995,"ip_address":"","comment_id":182121,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"用得最顺手的就是在for循环里auto，override在Qt里继承类重写虚函数时用到。其他的default和delete以前初学时写过几个，现在在项目里倒用得少了，以后尽量多用多试，毕竟不影响性能！谢谢老师解析了这么多C++新特性；）","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485526,"discussion_content":"我没有中文版，我也不确定你说的是哪个版本。\n\n我看到第四版的19.2.6节似乎有类似你说的东西。请详细说一下你指的是哪一节的哪个例子，使用什么编译器，具体错误信息是什么。\n\n单独起一个新的评论，不要回复这一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582942085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181557,"user_name":"zKerry","can_delete":false,"product_type":"c1","uid":1497740,"ip_address":"","ucode":"9FB006D1A38D3F","user_header":"","comment_is_top":false,"comment_ctime":1582559227,"is_pvip":false,"replies":[{"id":70359,"content":"首先，语言之间互相学习是正常的。\n\n其次，C# 里有数字分隔符和二进制字面量是在 C# 7.0。换句话说，晚于 C++14。\n\n另外，我不知道 C# 有静态断言和自定义字面量的支持。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582610872,"ip_address":"","comment_id":181557,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"呃，这些东西在c#里都有","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485225,"discussion_content":"最方便的确实是在循环里用 auto，尤其在基于范围的循环里。其他的也可以慢慢用起来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582721995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165143,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1577171220,"is_pvip":false,"replies":[{"id":62951,"content":"对的，一定要用起来！","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577182535,"ip_address":"","comment_id":165143,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"既然有了这些特性， 我觉的就得在平时开发中用起来，不用就没有用，完全浪费了大神的研究","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479046,"discussion_content":"对的，一定要用起来！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577182535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388925,"user_name":"helloworldorz","can_delete":false,"product_type":"c1","uid":1158126,"ip_address":"江苏","ucode":"F1B318C1AFDA29","user_header":"https://static001.geekbang.org/account/avatar/00/11/ab/ee/25376a20.jpg","comment_is_top":false,"comment_ctime":1711182198,"is_pvip":false,"replies":[{"id":141561,"content":"嗯，作为默认行为这是好的做法。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1711416495,"ip_address":"上海","comment_id":388925,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"最喜欢类数据成员的默认初始化，变量定义的时候就应该显示得去初始化它","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640322,"discussion_content":"嗯，作为默认行为这是好的做法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711416495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333922,"user_name":"铿","can_delete":false,"product_type":"c1","uid":1009996,"ip_address":"","ucode":"23112C33A80463","user_header":"https://static001.geekbang.org/account/avatar/00/0f/69/4c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1644585492,"is_pvip":false,"replies":[{"id":122066,"content":"严肃地讲，语法糖对于易用性非常重要。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1644794616,"ip_address":"","comment_id":333922,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"auto 和 for的语法糖","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640322,"discussion_content":"嗯，作为默认行为这是好的做法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711416495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246102,"user_name":"201200861","can_delete":false,"product_type":"c1","uid":1900763,"ip_address":"","ucode":"4133BCD32FE933","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4Wp0sNFxYLd9mceUOAOVulWVPdEGEiaC9SCx2ZhfD8W9XTMjJYezrXxmfuKYA0YtJ6iadeBZchsc9g/132","comment_is_top":false,"comment_ctime":1599179654,"is_pvip":false,"replies":[{"id":90442,"content":"你自己提供了，编译器自然就不会提供了。头文件里瞟一眼啰。如果是别人提供的类定义，从使用者的角度，不去看类定义，应该是无从分辨的。\n\n从使用者的角度，容易分辨的，只能是用户不提供这些特殊成员函数时，编译器有没有自动提供。使用一下，不报错，自然就是编译器自动提供了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599181800,"ip_address":"","comment_id":246102,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，你好，如何看移动构造函数和拷贝函数，是编译器提供的还是用户自己写的？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505065,"discussion_content":"你自己提供了，编译器自然就不会提供了。头文件里瞟一眼啰。如果是别人提供的类定义，从使用者的角度，不去看类定义，应该是无从分辨的。\n\n从使用者的角度，容易分辨的，只能是用户不提供这些特殊成员函数时，编译器有没有自动提供。使用一下，不报错，自然就是编译器自动提供了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599181800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236501,"user_name":"赵国辉","can_delete":false,"product_type":"c1","uid":1166280,"ip_address":"","ucode":"390196BD3082B8","user_header":"https://static001.geekbang.org/account/avatar/00/11/cb/c8/ff9f3ffb.jpg","comment_is_top":false,"comment_ctime":1595429677,"is_pvip":false,"replies":[{"id":87426,"content":"直接搜索就好。我看结果很匹配的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1595480603,"ip_address":"","comment_id":236501,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，有没有对c++虚函数表实现原理讲解比较透彻的文章或者书籍推荐一下。对这方面比较感兴趣。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505065,"discussion_content":"你自己提供了，编译器自然就不会提供了。头文件里瞟一眼啰。如果是别人提供的类定义，从使用者的角度，不去看类定义，应该是无从分辨的。\n\n从使用者的角度，容易分辨的，只能是用户不提供这些特殊成员函数时，编译器有没有自动提供。使用一下，不报错，自然就是编译器自动提供了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599181800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183589,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1583072250,"is_pvip":false,"replies":[{"id":71121,"content":"嗯，这明显是代码后来改过了。初版的代码应该没有好好测过，问题还不止一个。\n\n顺着原先代码的思路也能实现的，但应该是下面这个样子（可参考第 15 讲）：\n\n#include &lt;stdexcept&gt;\n\nconstexpr int ipow(int x, int n)\n{\n    return n &gt; 0 ? x * ipow(x, n - 1) : 1;\n}\n\ntemplate &lt;typename C&gt;\nconstexpr int b3_helper(C c)\n{\n    if (c &lt; &#39;0&#39; || c &gt;= &#39;3&#39;) {\n        throw std::invalid_argument(&quot;not a ternary digit&quot;);\n    }\n    return c - &#39;0&#39;;\n}\n\ntemplate &lt;typename C, typename... Tail&gt;\nconstexpr int b3_helper(C c, Tail... tail)\n{\n    if (c &lt; &#39;0&#39; || c &gt;= &#39;3&#39;) {\n        throw std::invalid_argument(&quot;not a ternary digit&quot;);\n    }\n    return ipow(3, sizeof...(tail)) * (c - &#39;0&#39;) + b3_helper(tail...);\n}\n\ntemplate &lt;char... chars&gt;\nconstexpr int operator&quot;&quot; _b3()\n{\n    return b3_helper(chars...);\n}\n\n第一个 b3_helper 还可以进一步精简成：\n\nconstexpr int b3_helper()\n{\n    return 0;\n}","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583118398,"ip_address":"","comment_id":183589,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"第四版中文版中给出的代码是这样的：\nconstexpr int ipow(int x, int n) {\n    return (n &gt; 0) ? x * ipow(n - 1) : 1;\n}\ntemplate&lt;char c&gt;\nconstexpr int b3_helper() {\n    static_assert(c &lt; &#39;3&#39;, &quot;not a ternary digit&quot;);\n    return c;\n}\ntemplate&lt;char c,char ... tail&gt;\nconstexpr int b3_helper() {\n    static_assert(c &lt; &#39;3&#39;, &quot;not a ternary digit&quot;);\n    return ipow(3, sizeof...(tail)) * (c - &#39;0&#39;) + b3_helper(tail...);\n}\ntemplate&lt;char...chars&gt;\nconstexpr int operator&quot;&quot; _b3() {\n    return b3_helper(chars...);\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485721,"discussion_content":"嗯，这明显是代码后来改过了。初版的代码应该没有好好测过，问题还不止一个。\n\n顺着原先代码的思路也能实现的，但应该是下面这个样子（可参考第 15 讲）：\n\n#include &amp;lt;stdexcept&amp;gt;\n\nconstexpr int ipow(int x, int n)\n{\n    return n &amp;gt; 0 ? x * ipow(x, n - 1) : 1;\n}\n\ntemplate &amp;lt;typename C&amp;gt;\nconstexpr int b3_helper(C c)\n{\n    if (c &amp;lt; &amp;#39;0&amp;#39; || c &amp;gt;= &amp;#39;3&amp;#39;) {\n        throw std::invalid_argument(&amp;quot;not a ternary digit&amp;quot;);\n    }\n    return c - &amp;#39;0&amp;#39;;\n}\n\ntemplate &amp;lt;typename C, typename... Tail&amp;gt;\nconstexpr int b3_helper(C c, Tail... tail)\n{\n    if (c &amp;lt; &amp;#39;0&amp;#39; || c &amp;gt;= &amp;#39;3&amp;#39;) {\n        throw std::invalid_argument(&amp;quot;not a ternary digit&amp;quot;);\n    }\n    return ipow(3, sizeof...(tail)) * (c - &amp;#39;0&amp;#39;) + b3_helper(tail...);\n}\n\ntemplate &amp;lt;char... chars&amp;gt;\nconstexpr int operator&amp;quot;&amp;quot; _b3()\n{\n    return b3_helper(chars...);\n}\n\n第一个 b3_helper 还可以进一步精简成：\n\nconstexpr int b3_helper()\n{\n    return 0;\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583118398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593251,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","nickname":"doge","note":"","ucode":"9E2D4C8F9B4CBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351127,"discussion_content":"评论里的宝藏好多啊，这个用法可真清爽。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614158382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1758903,"avatar":"","nickname":"tr","note":"","ucode":"020AB6A704CD43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193213,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583138743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183256,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1582983160,"is_pvip":false,"replies":[{"id":70916,"content":"我不知道你看到的是什么，我这边是编译通过了。完整代码如下：\n\n#include &lt;iostream&gt;\n\nconstexpr int ipow(int x, int n)\n{\n  return n &gt; 0 ? x * ipow(x, n - 1)\n               : 1;\n}\n\ntemplate &lt;char...&gt;\nstruct helper;\n\ntemplate &lt;char c&gt;\nstruct helper&lt;c&gt; {\n  static_assert(\n    &#39;0&#39; &lt;= c &amp;&amp; c &lt; &#39;3&#39;,\n    &quot;not a ternary digit&quot;);\n  static constexpr int value()\n  {\n    return c - &#39;0&#39;;\n  }\n};\n\ntemplate &lt;char c, char... tail&gt;\nstruct helper&lt;c, tail...&gt; {\n  static_assert(\n    &#39;0&#39; &lt;= c &amp;&amp; c &lt; &#39;3&#39;,\n    &quot;not a ternary digit&quot;);\n  static constexpr int value()\n  {\n    return (c - &#39;0&#39;) *\n             ipow(3,\n                  sizeof...(tail)) +\n           helper&lt;tail...&gt;::value();\n  }\n};\n\ntemplate &lt;char... chars&gt;\nconstexpr int operator&quot;&quot; _b3()\n{\n  return helper&lt;chars...&gt;::value();\n}\n\nint main()\n{\n  std::cout &lt;&lt; 201_b3 &lt;&lt; std::endl;\n}\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582993902,"ip_address":"","comment_id":183256,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"是19.2.6节三进制的那个例子，b3_helper的调用有问题，vs2019社区版报的是“应输入0个参数，却提供了3个”，但是把圆括号换成模板参数的尖括号又报告“未找到匹配的重载”。像这种怎么修改合适呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485721,"discussion_content":"嗯，这明显是代码后来改过了。初版的代码应该没有好好测过，问题还不止一个。\n\n顺着原先代码的思路也能实现的，但应该是下面这个样子（可参考第 15 讲）：\n\n#include &amp;lt;stdexcept&amp;gt;\n\nconstexpr int ipow(int x, int n)\n{\n    return n &amp;gt; 0 ? x * ipow(x, n - 1) : 1;\n}\n\ntemplate &amp;lt;typename C&amp;gt;\nconstexpr int b3_helper(C c)\n{\n    if (c &amp;lt; &amp;#39;0&amp;#39; || c &amp;gt;= &amp;#39;3&amp;#39;) {\n        throw std::invalid_argument(&amp;quot;not a ternary digit&amp;quot;);\n    }\n    return c - &amp;#39;0&amp;#39;;\n}\n\ntemplate &amp;lt;typename C, typename... Tail&amp;gt;\nconstexpr int b3_helper(C c, Tail... tail)\n{\n    if (c &amp;lt; &amp;#39;0&amp;#39; || c &amp;gt;= &amp;#39;3&amp;#39;) {\n        throw std::invalid_argument(&amp;quot;not a ternary digit&amp;quot;);\n    }\n    return ipow(3, sizeof...(tail)) * (c - &amp;#39;0&amp;#39;) + b3_helper(tail...);\n}\n\ntemplate &amp;lt;char... chars&amp;gt;\nconstexpr int operator&amp;quot;&amp;quot; _b3()\n{\n    return b3_helper(chars...);\n}\n\n第一个 b3_helper 还可以进一步精简成：\n\nconstexpr int b3_helper()\n{\n    return 0;\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583118398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593251,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","nickname":"doge","note":"","ucode":"9E2D4C8F9B4CBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351127,"discussion_content":"评论里的宝藏好多啊，这个用法可真清爽。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614158382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1758903,"avatar":"","nickname":"tr","note":"","ucode":"020AB6A704CD43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193213,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583138743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183003,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1582906409,"is_pvip":false,"replies":[{"id":70808,"content":"我没有中文版，我也不确定你说的是哪个版本。\n\n我看到第四版的19.2.6节似乎有类似你说的东西。请详细说一下你指的是哪一节的哪个例子，使用什么编译器，具体错误信息是什么。\n\n单独起一个新的评论，不要回复这一个。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582942085,"ip_address":"","comment_id":183003,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，本贾尼在他的《c++程序设计语言》中480页写了一种叫模板字面值常量的语法，不过他的代码编译不过。如果您有时间的话能不能帮忙看下是不是真的有这种写法还是说其他什么原因","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485526,"discussion_content":"我没有中文版，我也不确定你说的是哪个版本。\n\n我看到第四版的19.2.6节似乎有类似你说的东西。请详细说一下你指的是哪一节的哪个例子，使用什么编译器，具体错误信息是什么。\n\n单独起一个新的评论，不要回复这一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582942085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182121,"user_name":"皮皮侠","can_delete":false,"product_type":"c1","uid":1258402,"ip_address":"","ucode":"04205990C1DE1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","comment_is_top":false,"comment_ctime":1582712329,"is_pvip":false,"replies":[{"id":70521,"content":"最方便的确实是在循环里用 auto，尤其在基于范围的循环里。其他的也可以慢慢用起来。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582721995,"ip_address":"","comment_id":182121,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"用得最顺手的就是在for循环里auto，override在Qt里继承类重写虚函数时用到。其他的default和delete以前初学时写过几个，现在在项目里倒用得少了，以后尽量多用多试，毕竟不影响性能！谢谢老师解析了这么多C++新特性；）","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485225,"discussion_content":"最方便的确实是在循环里用 auto，尤其在基于范围的循环里。其他的也可以慢慢用起来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582721995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181557,"user_name":"zKerry","can_delete":false,"product_type":"c1","uid":1497740,"ip_address":"","ucode":"9FB006D1A38D3F","user_header":"","comment_is_top":false,"comment_ctime":1582559227,"is_pvip":false,"replies":[{"id":70359,"content":"首先，语言之间互相学习是正常的。\n\n其次，C# 里有数字分隔符和二进制字面量是在 C# 7.0。换句话说，晚于 C++14。\n\n另外，我不知道 C# 有静态断言和自定义字面量的支持。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582610872,"ip_address":"","comment_id":181557,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"呃，这些东西在c#里都有","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485032,"discussion_content":"首先，语言之间互相学习是正常的。\n\n其次，C# 里有数字分隔符和二进制字面量是在 C# 7.0。换句话说，晚于 C++14。\n\n另外，我不知道 C# 有静态断言和自定义字面量的支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582610872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165143,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1577171220,"is_pvip":false,"replies":[{"id":62951,"content":"对的，一定要用起来！","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577182535,"ip_address":"","comment_id":165143,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"既然有了这些特性， 我觉的就得在平时开发中用起来，不用就没有用，完全浪费了大神的研究","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485032,"discussion_content":"首先，语言之间互相学习是正常的。\n\n其次，C# 里有数字分隔符和二进制字面量是在 C# 7.0。换句话说，晚于 C++14。\n\n另外，我不知道 C# 有静态断言和自定义字面量的支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582610872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162284,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1576492022,"is_pvip":false,"replies":[{"id":61752,"content":"其他的也要考虑用起来啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576500607,"ip_address":"","comment_id":162284,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"平时自己主要用到的就是auto和default和delete override，方便且避免出错","like_count":0},{"had_liked":false,"id":162082,"user_name":"中山浪子","can_delete":false,"product_type":"c1","uid":1055296,"ip_address":"","ucode":"25D0F8462473D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","comment_is_top":false,"comment_ctime":1576459280,"is_pvip":false,"replies":[{"id":61709,"content":"嗯，这个搭配很爽的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576474081,"ip_address":"","comment_id":162082,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"auto 和 for loop range base的搭配","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477949,"discussion_content":"嗯，这个搭配很爽的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576474081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162043,"user_name":"西钾钾","can_delete":false,"product_type":"c1","uid":1097722,"ip_address":"","ucode":"0EE77083636ED9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV27QOK57cdpdh3E4hbArCOlccdtjCyWooF9fhjeSKAMo9SN1v9RODkrZUZD4RejjbdsqU2FIeMA/132","comment_is_top":false,"comment_ctime":1576455461,"is_pvip":false,"replies":[{"id":61670,"content":"没成本的改进，能用就用起来吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576458970,"ip_address":"","comment_id":162043,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"auto 与 新的 for 遍历方法，因为实在是方便而且用的最多。其他的特性 ... 工作中貌似还没怎么用过😭","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477949,"discussion_content":"嗯，这个搭配很爽的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576474081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318858,"user_name":"Geek3726","can_delete":false,"product_type":"c1","uid":2689436,"ip_address":"","ucode":"6A98C512C9156A","user_header":"","comment_is_top":false,"comment_ctime":1635469386,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"硬着头皮看了基础篇，才发现，自己是没有基础的；\n去补补C++的知识再来，虽然在公司开发C++的项目，但大部份的代码都是C语言写的，落后了。","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477943,"discussion_content":"没成本的改进，能用就用起来吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576458970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83710,"discussion_content":"关键要升级编译器才行，centos 7默认只有gcc-4.8.3，只支持c++11","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576459441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99493,"discussion_content":"所以我在“课前必读”还特意讲了如何升级CentOS上的编译器。CentOS还是很常见的情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577200369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83710,"ip_address":"","group_id":0},"score":99493,"extra":""}]}]},{"had_liked":false,"id":162284,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1576492022,"is_pvip":false,"replies":[{"id":61752,"content":"其他的也要考虑用起来啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576500607,"ip_address":"","comment_id":162284,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"平时自己主要用到的就是auto和default和delete override，方便且避免出错","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478002,"discussion_content":"其他的也要考虑用起来啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576500607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162082,"user_name":"中山浪子","can_delete":false,"product_type":"c1","uid":1055296,"ip_address":"","ucode":"25D0F8462473D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","comment_is_top":false,"comment_ctime":1576459280,"is_pvip":false,"replies":[{"id":61709,"content":"嗯，这个搭配很爽的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576474081,"ip_address":"","comment_id":162082,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"auto 和 for loop range base的搭配","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478002,"discussion_content":"其他的也要考虑用起来啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576500607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162043,"user_name":"西钾钾","can_delete":false,"product_type":"c1","uid":1097722,"ip_address":"","ucode":"0EE77083636ED9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV27QOK57cdpdh3E4hbArCOlccdtjCyWooF9fhjeSKAMo9SN1v9RODkrZUZD4RejjbdsqU2FIeMA/132","comment_is_top":false,"comment_ctime":1576455461,"is_pvip":false,"replies":[{"id":61670,"content":"没成本的改进，能用就用起来吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576458970,"ip_address":"","comment_id":162043,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"auto 与 新的 for 遍历方法，因为实在是方便而且用的最多。其他的特性 ... 工作中貌似还没怎么用过😭","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477943,"discussion_content":"没成本的改进，能用就用起来吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576458970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83710,"discussion_content":"关键要升级编译器才行，centos 7默认只有gcc-4.8.3，只支持c++11","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576459441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1762459,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","nickname":"李义盛","note":"","ucode":"2C79848BCF545D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99493,"discussion_content":"所以我在“课前必读”还特意讲了如何升级CentOS上的编译器。CentOS还是很常见的情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577200369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83710,"ip_address":"","group_id":0},"score":99493,"extra":""}]}]},{"had_liked":false,"id":318858,"user_name":"Geek3726","can_delete":false,"product_type":"c1","uid":2689436,"ip_address":"","ucode":"6A98C512C9156A","user_header":"","comment_is_top":false,"comment_ctime":1635469386,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"硬着头皮看了基础篇，才发现，自己是没有基础的；\n去补补C++的知识再来，虽然在公司开发C++的项目，但大部份的代码都是C语言写的，落后了。","like_count":3}]}