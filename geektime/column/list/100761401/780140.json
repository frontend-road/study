{"id":780140,"title":"14｜列表（下）：列表所支持的基本操作","content":"<p>你好，我是海纳。</p><p>上节课我们介绍了列表的基本实现，初步实现了往列表中增加新元素、修改列表中的元素等功能。这节课我们会继续实现列表支持的其他基本操作，主要包括删除元素、对元素进行排序，以及迭代访问列表元素等功能。</p><h2>删除元素</h2><p>从列表中删除元素，如果是删除最后一个元素，可以直接使用 list 的 pop 方法。pop 方法与 append 方法刚好是一对逆操作。append 用来在列表的末尾添加元素，而 pop 则是删除列表的最后一个元素。</p><p>而删除指定位置的元素有两种方法，一种是使用 del 关键字，另一种是使用列表的 remove 方法。接下来，我们逐个实现它们。先从 pop 方法开始。</p><h3>实现 pop 方法</h3><p>先使用 C++ 实现 list_pop 函数，用于将列表末尾的元素删除。list_pop 只需要简单地调用列表对象上的 pop 方法即可。而 pop 方法在<a href=\"https://time.geekbang.org/column/article/772694\">第 4 节课</a>中定义 list 的时候，我们就已经实现了。</p><pre><code class=\"language-c++\">HiObject* list_pop(ObjList args) {\n&nbsp; &nbsp; HiList* list = (HiList*)(args-&gt;get(0));\n&nbsp; &nbsp; assert(list &amp;&amp; list-&gt;klass() == ListKlass::get_instance());\n&nbsp; &nbsp; return list-&gt;pop();\n}\n</code></pre><!-- [[[read_end]]] --><p>第二步，在 ListKlass 的构造方法里，把字符串 <code>“pop”</code> 与这个 native 方法关联在一起。</p><pre><code class=\"language-c++\">ListKlass::ListKlass() {\n&nbsp; &nbsp; HiDict * klass_dict = new HiDict();\n&nbsp; &nbsp; klass_dict-&gt;put(new HiString(\"append\"),&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; new FunctionObject(list_append));\n&nbsp; &nbsp; klass_dict-&gt;put(new HiString(\"pop\"),&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; new FunctionObject(list_pop));\n&nbsp; &nbsp; set_klass_dict(klass_dict);\n}\n</code></pre><p>从代码里，我们可以看到，添加 pop 方法与添加 append 方法要做的事情几乎是一样的。</p><p>接下来，我们再看一下使用 del 关键字删除指定的列表元素。</p><h3>实现 del 关键字</h3><p>关键字 del 不同于方法，一般来说，遇到关键字都会引入新的字节码。所以我们还是创建一个简单的例子，然后观察它的字节码。</p><pre><code class=\"language-plain\">l = [4, 1, 2, 3]\ndel l[0]\n&nbsp;17&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 56 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (l)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;59 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 (0)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;62 DELETE_SUBSCR&nbsp; &nbsp; &nbsp; &nbsp;\n</code></pre><p>为了方便查看，我把 Python 源代码和字节码放在一起了。注意上述代码的最后一行，出现了新的字节码：<strong>DELETE_SUBSCR</strong> 。这个字节码是不带参数的，它的参数都在操作数栈上。</p><p>栈顶第一个元素是整数 0，也就是序号，栈顶第二个元素是列表对象。而且这个字节码没有返回值，所以也就不用再把任何值送回到栈上了。我们可以这么实现这个字节码：</p><pre><code class=\"language-c++\">void Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; _frame = new FrameObject(codes);\n\tHiObject *v, *w, *u;\n\t...\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::DELETE_SUBSCR:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;del_subscr(w);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>从代码里可以看到，v、w 都是指向 HiObject 的指针，这就要求我们要在 HiObject 里添加 del_subscr 方法。这个逻辑推演和上一节课中的 store_subscr 方法是完全一样的。下面我给出了 del_subscr 方法的具体代码实现，你可以参考。</p><pre><code class=\"language-c++\">// object/hiObject.cpp\nvoid HiObject::del_subscr(HiObject* x) {\n&nbsp; &nbsp; klass()-&gt;del_subscr(this, x);\n}\n\n// object/klass.hpp\nclass Klass {\nprivate:\n&nbsp; &nbsp; Klass*&nbsp; &nbsp; &nbsp; &nbsp; _super;\n&nbsp; &nbsp; HiString*&nbsp; &nbsp; &nbsp;_name;\n&nbsp; &nbsp; HiDict*&nbsp; &nbsp; &nbsp; &nbsp;_klass_dict;\n\npublic:\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; virtual void del_subscr&nbsp; &nbsp; (HiObject* x, HiObject* y) { return; }\n};\n</code></pre><p>然后，我们在 ListKlass 中实现这个虚函数。</p><pre><code class=\"language-c++\">// object/hiList.hpp\nclass ListKlass : public Klass {\npublic:\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; virtual void del_subscr (HiObject* x, HiObject* y);\n};\n\n// object/hiList.cpp\nvoid ListKlass::del_subscr(HiObject* x, HiObject* y) {\n&nbsp; &nbsp; assert(x &amp;&amp; x-&gt;klass() == (Klass*) this);\n&nbsp; &nbsp; assert(y &amp;&amp; y-&gt;klass() == IntegerKlass::get_instance());\n\n&nbsp; &nbsp; HiList * lx = (HiList*)x;\n&nbsp; &nbsp; HiInteger* iy = (HiInteger*)y;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; lx-&gt;inner_list()-&gt;delete_index(iy-&gt;value());\n}\n\n// util/arrayList.cpp\ntemplate &lt;typename T&gt;\nvoid ArrayList&lt;T&gt;::delete_index(int index) {\n&nbsp; &nbsp; for (int i = index; i + 1 &lt; _length; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; _array[i] = _array[i+1];\n&nbsp; &nbsp; }\n&nbsp; &nbsp; _length--;\n}\n</code></pre><p>delete_index 的作用是从 ArrayList 中删除指定位置的元素（第 20 至 26 行）。由于其内部的数据结构是一个数组，在删除的时候，我们必须把后面的元素向前移，覆盖掉被删除的那个元素。在完成这个操作以后，再把 _length 减 1。这样，del 关键字删除元素的功能就全部完成了。</p><p>最后，我们关注 remove 方法的实现。这个方法接受一个参数，把列表里和这个参数相等的值删除掉。例如：</p><pre><code class=\"language-python\">l = [\"hello\", \"world\", \"hello\"]\nl.remove(\"hello\")\nprint(l) # [\"world\"]\n</code></pre><p>在列表中添加一个 native 方法我们已经做过很多次了。对 ListKlass 构造函数的修改，这里就不再列出了，为了练手，你可以自己实现。</p><p>这里重点关注一下 list_remove 方法的实现。</p><pre><code class=\"language-bash\">HiObject* list_remove(ObjList args) {\n&nbsp; &nbsp; HiList* list = (HiList*)(args-&gt;get(0));\n&nbsp; &nbsp; HiObject* target = (HiObject*)(args-&gt;get(1));\n\n&nbsp; &nbsp; assert(list &amp;&amp; list-&gt;klass() == ListKlass::get_instance());\n\n&nbsp; &nbsp; for (int i = 0; i &lt; list-&gt;inner_list()-&gt;size(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (list-&gt;get(i)-&gt;equal(target) == (HiObject*)Universe::HiTrue) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list-&gt;inner_list()-&gt;delete_index(i);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; return Universe::HiNone;\n}\n</code></pre><p>上述代码使用 equal 比较列表中的元素与输入参数 target 是否相等（第 8 行）。如果相等，equal 方法的返回值就是 HiTrue，否则就是 HiFalse。当元素与参数相等时，我们可以通过直接调用 delete_index 方法将元素删除。</p><p>到这里，删除元素的所有方法我们就全部实现了。最后我们可以通过以下的测试用例进行综合测试：</p><pre><code class=\"language-python\">l = [4, 1, 2, 3]\nl.remove(2)\nprint(l)&nbsp; &nbsp; &nbsp; &nbsp;# [4, 1, 3]\nl[0] = 3\nprint(l)&nbsp; &nbsp; &nbsp; &nbsp;# [3, 1, 3]\ndel l[0]\nprint(l)&nbsp; &nbsp; &nbsp; &nbsp;# [1, 3]\nprint(l.pop()) # 3\nprint(l)&nbsp; &nbsp; &nbsp; &nbsp;# [1]\n</code></pre><p>你自己运行一下这个例子，看看自己的测试结果是否与预期相符。</p><h2>对列表元素进行排序</h2><p>列表中有两个方法与列表元素的序列有关，一个是 reverse，一个是 sort。reverse 方法用来把列表中的所有元素倒序。sort 用来把列表中的元素按从小到大的顺序排列，也就是升序。</p><p>reverse 是列表的一个方法，我们看一下添加 reverse 方法的过程。</p><pre><code class=\"language-c++\">ListKlass::ListKlass() {\n&nbsp; &nbsp; HiDict * klass_dict = new HiDict();\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; klass_dict-&gt;put(new HiString(\"reverse\"),&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; new FunctionObject(list_reverse));\n&nbsp; &nbsp; set_klass_dict(klass_dict);\n}\n\nHiObject* list_reverse(ObjList args) {\n&nbsp; &nbsp; HiList* list = (HiList*)(args-&gt;get(0));\n\n&nbsp; &nbsp; int i = 0;\n&nbsp; &nbsp; int j = list-&gt;size() - 1;\n&nbsp; &nbsp; while (i &lt; j) {\n&nbsp; &nbsp; &nbsp; &nbsp; HiObject* t = list-&gt;get(i);\n&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;set(i, list-&gt;get(j));\n&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;set(j, t);\n\n&nbsp; &nbsp; &nbsp; &nbsp; i++;\n&nbsp; &nbsp; &nbsp; &nbsp; j--;\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; return Universe::HiNone;\n}\n</code></pre><p>这段代码的逻辑是这样的，i 指向列表头，j 指向列表尾，不停地交换前半部分元素和后半部分元素，直到 i 不再指向前半部分（第 14 至第 21 行）。代码的其他部分比较简单，这里我就不过多解释了。</p><p>接下来是 sort 方法。绝大多数的排序算法都是基于比较的，就是说，如果要把所有元素按照从小到大升序排列，得先定义大和小。两个元素能比较大小了，它们的先后顺序也就决定了。所以，<strong>我们要解决的第一个问题是列表的元素可以比较大小</strong>。</p><p>在 HiObject 中，我们已经定义好了 less、greater 等方法用来比较对象大小。并且在 IntegerKlass 中实现了相应的方法。</p><p>Python 2.7 支持不同类型的对象相互比较大小。它的规则是，整数类型比其他所有类型都小。其他类型之间相互比较的时候按照类型名称的字符串比较规则进行比较。例如，列表的类型名称是list，字符串类的类型名称是str。这两个类名称的字符串进行比较时，list小于str，这就意味着所有的列表对象都比字符串对象小。</p><p>但在 Python 3.8 中，这个规则被优化了，不再支持不同类型的对象之间进行比较和排序。也就是说只有比较操作符两边的操作数类型是相同的，才可以相互比较，如果比较的对象是不同类型的，就会抛出异常。但我们现在还没有实现异常，所以就直接 assert 失败退出程序了。</p><p>在搞清楚这些规则以后，我们再来实现 sort 方法。</p><pre><code class=\"language-c++\">ListKlass::ListKlass() {\n&nbsp; &nbsp; HiDict * klass_dict = new HiDict();\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; klass_dict-&gt;put(new HiString(\"sort\"),&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; new FunctionObject(list_sort));\n&nbsp; &nbsp; set_klass_dict(klass_dict);\n\n&nbsp; &nbsp; set_name(new HiString(\"list\"));\n}\n\nHiObject* list_sort(ObjList args) {\n&nbsp; &nbsp; HiList* list = (HiList*)(args-&gt;get(0));\n&nbsp; &nbsp; assert(list &amp;&amp; list-&gt;klass() == ListKlass::get_instance());\n\n&nbsp; &nbsp; // bubble sort\n&nbsp; &nbsp; for (int i = 0; i &lt; list-&gt;size(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; for (int j = list-&gt;size() - 1; j &gt; i; j--) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (list-&gt;get(j)-&gt;less(list-&gt;get(j-1)) == Universe::HiTrue) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HiObject* t = list-&gt;get(j);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list-&gt;set(j, list-&gt;get(j-1));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list-&gt;set(j-1, t);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; return Universe::HiNone;\n}\n</code></pre><p>list_sort 是列表的 sort 方法的真正实现。在 list_sort 中，我们采用了<strong>冒泡排序算法</strong>，这是一种最简单的排序算法。它重复地访问要排序的元素序列，依次比较两个相邻的元素，如果他们的顺序错误，如从小到大排序时，更大的数在前边，就把它们交换过来。</p><p>访问元素的工作会重复进行，直到没有相邻元素需要交换。这个算法名字的由来是因为越小的元素会经过交换慢慢“浮”到数列的顶端，就如同水中的气泡最终会上浮到顶端一样，所以叫作“冒泡排序”。</p><p>这里你可以尝试着使用<strong>快排或者堆排序</strong>来替换冒泡排序算法，从而使 list 的排序效率更高。</p><p>为了让列表对象相互之间能够比较，我们还要为列表增加比较的方法。</p><pre><code class=\"language-c++\">HiObject* ListKlass::less(HiObject* x, HiObject* y) {\n&nbsp; &nbsp; HiList * lx = (HiList*)x;\n&nbsp; &nbsp; HiList * ly = (HiList*)y;\n\n&nbsp; &nbsp; assert(lx &amp;&amp; lx-&gt;klass() == (Klass*) this);\n&nbsp; &nbsp; assert(ly &amp;&amp; ly-&gt;klass() == (Klass*) this);\n\n&nbsp; &nbsp; int len = lx-&gt;size() &lt; ly-&gt;size() ?\n&nbsp; &nbsp; &nbsp; &nbsp; lx-&gt;size() : ly-&gt;size();\n\n&nbsp; &nbsp; for (int i = 0; i &lt; len; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (lx-&gt;get(i)-&gt;less(ly-&gt;get(i)) == Universe::HiTrue) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Universe::HiTrue;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; else if (lx-&gt;get(i)-&gt;equal(ly-&gt;get(i)) != Universe::HiTrue) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Universe::HiFalse;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; if (lx-&gt;size() &lt; ly-&gt;size())\n&nbsp; &nbsp; &nbsp; &nbsp; return Universe::HiTrue;\n\n&nbsp; &nbsp; return Universe::HiFalse;\n}\n</code></pre><p>列表比较的逻辑与字符串比较的逻辑十分相似。首先检查两个对象的类型是否相同，如果不相同，就先比较类型的大小。如果类型相同，就逐个元素进行比较。</p><p>比较的规则是，在 x 某位置上的元素如果小于 y 相同位置上的元素，就可以直接返回 True。x 某位置上的元素如果大于 y 相同位置上的元素，就返回 False。如果在相同位置上的元素相等，那就继续比较下一位。如果所有位置上的元素都相等，但是 x 和 y 的长度不同，那么更短的那个列表更小。</p><p>到这里，我们可以使用下面的测试用例来检查我们的实现是否正确。</p><pre><code class=\"language-python\">a = [1, 3, 2, 5, 4]\nc = [1, 3]\nb = [\"a\", \"z\", \"hello\", \"world\"]\n\na.sort()\nprint(a)\nb.sort()\nprint(b)\nprint(a &lt; c)\n</code></pre><h2>遍历列表元素</h2><p>列表还有一个重要的机制，在 Python 编程实践中使用频率非常高的<strong>遍历</strong>。在讲解控制流的时候，我们只讲解了 while 循环，没有使用 for 关键字，这是因为 for 关键字要依赖更多的数据结构。</p><p>我们用一个例子来查看 for 循环使用的字节码。</p><pre><code class=\"language-python\">l = [1, 2, 3]\nfor i in l:\n    print(i)\n</code></pre><p>我们将这个测试用例编译以后，再使用 show_file 工具查看它的字节码。</p><pre><code class=\"language-plain\">&nbsp; 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (1)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (2)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (3)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 BUILD_LIST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (l)\n\n&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (l)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 GET_ITER\n&nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt;&nbsp; &nbsp;14 FOR_ITER&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 12 (to 28)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (i)\n\n&nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 18 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;20 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (i)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;22 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24 POP_TOP\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;26 JUMP_ABSOLUTE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14\n&nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt;&nbsp; &nbsp;28 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30 RETURN_VALUE\n</code></pre><p>上述字节码的第一个功能是创建列表（第 1 行至第 5 行）。第二部分对应源码文件的第 2 行，也就是那条 for 语句（第 7 行至第 10 行）。这 4 条字节码中，有两个是我们还没有实现的，分别是 GET_ITER 和 FOR_ITER。第三部分就是打印，这部分不再赘述。</p><p>第二部分出现了一个全新的概念：<strong>迭代器（iterator）</strong>。迭代器在 C++ STL 中和 Java 容器里被广泛使用，是一种非常常见的软件设计模式。</p><p>迭代器是一种对象，它能够遍历容器中的所有元素。迭代器并不仅仅是列表专用的，它用在很多地方，例如字典、文件等，程序员甚至可以自己定义迭代器。<strong>它的作用就是屏蔽底层的数据结构，让程序可以使用统一的接口来对不同的数据结构进行遍历操作。</strong></p><p>GET_ITER 可以获得栈顶对象的迭代器，并把迭代器送到栈顶。FOR_ITER 可以将迭代器往前推进。比如，迭代器在刚被创建的时候，总是指向第一个元素，而执行一次 FOR_ITER 以后，就会把第一个元素送到栈顶，同时将迭代器推进一次，指向第二个元素。</p><p>知道了迭代器的作用以后，我们就来设计列表的迭代器。Python 提供了一个函数，名为 iter，可以获取对象上的迭代器，我们可以先探究一下。</p><pre><code class=\"language-plain\">&gt;&gt;&gt; l = []\n&gt;&gt;&gt; it = iter(l)\n&gt;&gt;&gt; print(it)\n&lt;list_iterator object at 0x7fee725ccb20&gt;\n&gt;&gt;&gt; dir(it)\n[..., '__next__', ...]\n</code></pre><p>在 Python 的 REPL 环境里（在命令行下手动输入 Python 并回车即可进入），通过调用 iter 函数，获得一个空列表对象的迭代器，并把它打印了出来。可以看到，迭代器对象本身也是一个普通的 Python 对象，并且它的类型是 <strong>list_iterator</strong>。</p><p>通过 dir 查看它的属性，可以看到，list_iterator 类型上定义了 <strong>next</strong> 方法。这就为我们实现迭代器指明了方向。首先，迭代器也是一个 HiObject 对象，它的 klass 名称是list_iterator。我们把这些分析转换成代码。</p><pre><code class=\"language-c++\">// object/hiList.hpp\nclass ListIteratorKlass : public Klass {\nprivate:\n&nbsp; &nbsp; static ListIteratorKlass* instance;\n&nbsp; &nbsp; ListIteratorKlass();\n\npublic:\n&nbsp; &nbsp; static ListIteratorKlass* get_instance();\n};\n\nclass ListIterator : public HiObject {\nprivate:\n&nbsp; &nbsp; HiList*&nbsp; &nbsp;_owner;\n&nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp;_iter_cnt;\npublic:\n&nbsp; &nbsp; ListIterator(HiList* owner);\n\n&nbsp; &nbsp; HiList* owner()&nbsp; &nbsp; &nbsp; &nbsp; { return _owner; }\n&nbsp; &nbsp; int iter_cnt()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return _iter_cnt; }&nbsp;&nbsp;\n&nbsp; &nbsp; void inc_cnt()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ _iter_cnt++; }\n};\n</code></pre><p>ListIteratorKlass 和之前实现的 ListKlass 等其他 Klass 相同，也是一个单例对象。ListIterator 才是真正的迭代器，它继承自 HiObject。为了遍历列表，迭代器上要记录目标列表（_owner），还要记录当前已经遍历到什么位置（_iter_cnt）。</p><p>接下来，就要在代表迭代器类型的 ListIteratorKlass 中添加 <strong>next</strong> 方法。这个工作可以在构造函数里完成。</p><pre><code class=\"language-c++\">// object/hiList.hpp\nHiObject* listiterator_next(ObjList args);\n\n// object/hiList.cpp\nListIteratorKlass::ListIteratorKlass() {\n&nbsp; &nbsp; HiDict* klass_dict = new HiDict();\n&nbsp; &nbsp; klass_dict-&gt;put(new HiString(\"next\"),&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new FunctionObject(listiterator_next));\n&nbsp; &nbsp; set_klass_dict(klass_dict);\n\n&nbsp; &nbsp; set_name(new HiString(\"listiterator\"));\n}\n\nListIterator::ListIterator(HiList* list) {\n&nbsp; &nbsp; _owner = list;\n&nbsp; &nbsp; _iter_cnt = 0;\n&nbsp; &nbsp; set_klass(ListIteratorKlass::get_instance());\n}\n\nHiObject* listiterator_next(ObjList args) {\n&nbsp; &nbsp; ListIterator* iter = (ListIterator*)(args-&gt;get(0));\n\n&nbsp; &nbsp; HiList* alist = iter-&gt;owner();\n&nbsp; &nbsp; int iter_cnt = iter-&gt;iter_cnt();\n&nbsp; &nbsp; if (iter_cnt &lt; alist-&gt;inner_list()-&gt;size()) {\n&nbsp; &nbsp; &nbsp; &nbsp; HiObject* obj = alist-&gt;get(iter_cnt);\n&nbsp; &nbsp; &nbsp; &nbsp; iter-&gt;inc_cnt();\n&nbsp; &nbsp; &nbsp; &nbsp; return obj;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; else // TODO : we need StopIteration here to mark iteration end\n&nbsp; &nbsp; &nbsp; &nbsp; return NULL;\n}\n</code></pre><p>listiterator_next 方法的逻辑是取出当前 iter_cnt 所对应的对象，把它作为返回值返回给调用者，并且把 iter_cnt 加 1。</p><p>如果遍历结束，iter_cnt 的值就会等于列表的长度，我们通过返回 NULL 来表示结束了（第 30 行）。实际上，按照 Python 标准的要求，这里应该抛出一个 StopIteration 异常。但由于我们现在还没有实现异常机制，所以这里就先使用 NULL 来代表迭代器遍历结束。</p><p>实现完列表的迭代器以后，就可以实现迭代器相关的两个字节码了。</p><pre><code class=\"language-c++\">void Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; _frame = new FrameObject(codes);\n\tHiObject *v, *w, *u;\n\t...\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::GET_ITER:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(v-&gt;iter());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::FOR_ITER:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = TOP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = v-&gt;getattr(new HiString(\"next\"));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; build_frame(w, NULL);\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (TOP() == NULL) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _frame-&gt;_pc += op_arg;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>GET_ITER 的实现中调用了 v 的 iter 方法（第 10 至 13 行），v 的类型虽然是指向 HiObject 的指针，但它本质上是一个列表对象。</p><p>iter 方法的作用是生成与 v 相联系的 ListIterator。在 HiObject 及 Klass 类里添加 iter 方法的原型的代码，它的逻辑比较简单，就不再列出了。这里我只列出 ListKlass 中 iter 的具体实现，供你参考。</p><pre><code class=\"language-c++\">HiObject* ListKlass::iter(HiObject* x) {\n&nbsp; &nbsp; assert(x &amp;&amp; x-&gt;klass() == this);\n&nbsp; &nbsp; return new ListIterator((HiList*)x);\n}\n</code></pre><p>执行完 GET_ITER 字节码以后，列表的迭代器对象就已经在操作数栈顶了。接下来解释器就会循环地执行 FOR_ITER。</p><p>如果迭代的过程正常，也就是返回值不为 NULL，那么就继续执行下一条字节码。如果迭代的过程结束了，就跳转到目标字节码继续执行。</p><p>这个目标字节码由 FOR_ITER 的参数描述， FOR_ITER 的参数代表了迭代结束的目标指令与当前指令的偏移量。所以我们在迭代结束以后，将 _frame 的 _pc 值加上这个参数，就得到了要跳转的目标指令地址。</p><p>从列表中迭代取出元素的过程，就是不断地通过 build_frame 调用 ListIterator 的 <strong>next</strong> 方法的过程。这个调用最终会执行到 listiterator_next 函数中去。在这个函数里，我们不断地从列表中取出它的元素。</p><p>到这里，迭代器就全部实现完了。编译运行，就可以执行这部分的测试用例了。</p><p>最后，再添加一点优化。我们注意到 FOR_ITER 的每一次执行都会生成一个新的字符串对象，这种做法不仅会使性能变差，在没有正确地实现自动内存管理之前，还会带来更多的内存泄漏。</p><p>这个新生成的字符串值为 next，是一个常量，没有必要每次都重新生成。所以我们就可以以静态变量的形式把它记录下来。为此，我们创建一个名为 StringTable 的类，把所有虚拟机的字符串常量都记录在这个类里。</p><pre><code class=\"language-c++\">class StringTable {\nprivate:\n&nbsp; &nbsp; static StringTable* instance;\n&nbsp; &nbsp; StringTable();\n\npublic:\n&nbsp; &nbsp; static StringTable* get_instance();\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; HiString* next_str;\n};\n</code></pre><p>因为 StringTable 在整个虚拟机里只需要一份即可，所以我们采用单例模式实现它。在构造函数里，我们初始化 next_str。这样，在 FOR_ITER 里就可以使用这个字符串常量了，避免每次执行都需要创建一个新的对象。</p><pre><code class=\"language-c++\">StringTable::StringTable() {\n&nbsp; &nbsp; next_str = new HiString(\"next\");\n}\n\nvoid Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::FOR_ITER:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = TOP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = v-&gt;getattr(StringTable::get_instance()-&gt;next_str);\n&nbsp; &nbsp; ...\n}\n</code></pre><p>好了，关于迭代器我们先介绍到这里，Python 的迭代器是一个很复杂的机制，这里只是开了个头，后面我会慢慢补充。</p><h2>列表的加法乘法操作</h2><p>列表上定义的各种操作，我们已经介绍得差不多了。最后还有三种简单的操作，值得再介绍一下。第一个就是<strong>加法</strong>，两个列表相加的结果是一个新的列表，它包含了两个列表的所有内容。例如：</p><pre><code class=\"language-python\">a = [1, 2]\nb = [\"hello\", \"world\"]\nc = a + b&nbsp;\n#&nbsp; &nbsp; &nbsp;24 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (a)\n#&nbsp; &nbsp; &nbsp;27 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (b)\n#&nbsp; &nbsp; &nbsp;30 BINARY_ADD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n#&nbsp; &nbsp; &nbsp;31 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (c)\nprint(a)&nbsp; # [1, 2]\nprint(b)&nbsp; # [\"hello\", \"world\"]\nprint(c)&nbsp; # [1, 2, \"hello\", \"world\"]\n</code></pre><p>使用 Python 运行这个测试，就会发现，a 和 b 所指向的列表并没有发生改变。而 c 是一个新的列表，它包含了 a 和 b 的内容。</p><p>为了方便你观察，我在测试用例中以注释的形式把字节码列出来了。可以看到，列表的加法操作并没有引入新的字节码，与整数一样，使用了 BINARY_ADD 来进行列表的相加操作。我们知道，BINARY_ADD 的实现依赖于对象的 add 方法。为了支持列表类型的加法操作，就需要在ListKlass 中增加加法操作的实现。这是比较容易的。</p><pre><code class=\"language-python\">HiObject* ListKlass::add(HiObject* x, HiObject* y) {\n&nbsp; &nbsp; HiList* lx = (HiList*)x;\n&nbsp; &nbsp; assert(lx &amp;&amp; lx-&gt;klass() == (Klass*) this);\n&nbsp; &nbsp; HiList* ly = (HiList*)y;\n&nbsp; &nbsp; assert(ly &amp;&amp; ly-&gt;klass() == (Klass*) this);\n\n&nbsp; &nbsp; HiList* z = new HiList();\n&nbsp; &nbsp; for (int i = 0; i &lt; lx-&gt;size(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; z-&gt;inner_list()-&gt;set(i, lx-&gt;inner_list()-&gt;get(i));\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; for (int i = 0; i &lt; ly-&gt;size(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; z-&gt;inner_list()-&gt;set(i + lx-&gt;size(),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ly-&gt;inner_list()-&gt;get(i));\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; return z;\n}\n</code></pre><p>在 add 方法中，我们先创建一个新的空列表 z，然后把 x 里的所有元素都拷贝到 z 中去，再把 y 中的所有元素都拷贝到 z 中去，最后把 z 返回给调用者就可以了。</p><p>和加法差不多，列表还支持<strong>乘法</strong>。列表只能与整数相乘，记整数为 n，那么列表 lst 乘以 n 的结果与 n 个 lst 相加的结果相同。</p><p>乘法对应的字节码是 BINARY_MULTIPLY，这个字节码的实现依赖于对象的 mul 方法。在 ListKlass 中增加 mul 的实现就可以了。</p><pre><code class=\"language-python\">HiObject* ListKlass::mul(HiObject* x, HiObject* y) {\n&nbsp; &nbsp; HiList * lx = (HiList*)x;\n&nbsp; &nbsp; assert(lx &amp;&amp; lx-&gt;klass() == (Klass*) this);\n&nbsp; &nbsp; HiInteger* iy = (HiInteger*)y;\n&nbsp; &nbsp; assert(iy &amp;&amp; iy-&gt;klass() == IntegerKlass::get_instance());\n\n&nbsp; &nbsp; HiList* z = new HiList();\n&nbsp; &nbsp; for (int i = 0; i &lt; iy-&gt;value(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; lx-&gt;size(); j++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; z-&gt;inner_list()-&gt;set(i * lx-&gt;size() + j,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lx-&gt;inner_list()-&gt;get(j));\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; return z;\n}\n</code></pre><p>乘法的逻辑也很直接，你可以与加法相互对照着研究。<br>\n到这里，列表的基本操作就全部完成了。</p><h2>总结</h2><p>这节课主要实现了几个内建方法，一是 list_pop，删除列表的最后一个元素；二是 list_remove，从列表中删除由参数指定的那个元素；三是 list_reverse，将列表元素倒序排列；四是 list_sort，对列表元素进行升序排列。</p><p>这节课我们也引入了几个新的字节码来实现列表的相关操作：DELETE_SUBSCR 用来删除列表中指定下标对应的元素；GET_ITER 用来构建列表迭代器；FOR_ITER 可以通过迭代器访问元素，如果遍历结束就跳转到目标代码执行。</p><p>最后，我们还介绍了列表的加法，乘法等操作。</p><p>通过第 13 节课和第 14 节课，我们实现了列表的几个最重要的基本操作，包括列表的构建，对列表元素的增、删、查、改、遍历列表元素、对列表元素进行排序等等。列表的功能已经基本完备，从下节课开始，我们将重点实现另外一个基本的数据结构：字典。</p><h2>思考题</h2><p>请你查看一下，Python 3.8中列表还有哪些内建方法我们尚未实现？欢迎你把你查找到的结果分享到评论区，我们一起讨论，如果你觉得这节课的内容对你有帮助的话，也欢迎你分享给身边的朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":395311,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1730181933,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":394456,"user_name":"Geek_66a783","can_delete":false,"product_type":"c1","uid":3882146,"ip_address":"浙江","ucode":"26C66C3EACAE16","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pkjW8zleOmmWAbAMPkshJSFnDcN6d06DrYDeSIibmic2SW05Flv3ic5kLhzcHukia1Y1Ktm4OXdzYsicCnINiaCOeqQQ/132","comment_is_top":false,"comment_ctime":1726838875,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"FOR_ITER中直接调build_frame函数，对于用户使用python代码实现的自定义迭代器，是不是会出问题呀","like_count":0},{"had_liked":false,"id":394455,"user_name":"Geek_66a783","can_delete":false,"product_type":"c1","uid":3882146,"ip_address":"浙江","ucode":"26C66C3EACAE16","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pkjW8zleOmmWAbAMPkshJSFnDcN6d06DrYDeSIibmic2SW05Flv3ic5kLhzcHukia1Y1Ktm4OXdzYsicCnINiaCOeqQQ/132","comment_is_top":false,"comment_ctime":1726837559,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"HiObject* list_remove(ObjList args)的实现似乎有点问题，其中删除那行的代码应该是list-&gt;inner_list()-&gt;delete_index(i--);才对，因为当次第i个元素已经被删掉了，下一次循环的时候这个位置已经被后面的元素替补上来了，所以还要再次检测一下第i个位置的元素是不是要被删除的目标","like_count":0},{"had_liked":false,"id":391181,"user_name":"Se7en","can_delete":false,"product_type":"c1","uid":1225368,"ip_address":"北京","ucode":"93EFAE37AFB12D","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/98/82b76c88.jpg","comment_is_top":false,"comment_ctime":1717568434,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"加油👏","like_count":0}]}