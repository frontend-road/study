{"id":824413,"title":"16｜数据模拟：产品级页面数据模拟及热力图生成","content":"<p>你好，我是柳博文，欢迎和我一起学习前端工程师的AI实战课。</p><p>在上节课中，我们初步了解了UI的千人千面。因为不同属性的人群会有不同的UI结构设计的倾向，我们就可以类比数据的千人千面，借助AI的推荐，在端侧重排出符合当前用户喜好的UI结构与设计，这就是UI的千人千面。</p><p>想要更好地分析UI千人千面，数据可视化是常用的辅助手段之一。具体到用户在页面中的行为数据的可视化，热力图是一个不错的选择。</p><p>这节课，我们就以电商H5营销页面为例，通过模拟用户行为的方式生成用户数据，并通过热力图的方式来将用户数据可视化，之后用数据可视化的方式进行人群精细化分析，以及算法模型的训练。</p><h2>关键数据指标</h2><p>在模拟用户行为生成用户数据之前，有一些专业的数据指标及相关意义需要我们提前知晓。通常这也是业务埋点时需要收集的各项数据。你可以参考后面的表格来了解。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/c4/c7bd6da8bd78d4aca3b5bb485ba5c1c4.jpg?wh=7123x3480\" alt=\"\"></p><p>在上面的表格中，我们需要重点关注 <strong>PV、UV、PV点击率、UV点击率以及停留时长</strong>这五个指标，稍后我们就会通过模拟用户行为来生成这几个指标的数据。</p><h2>模拟用户行为生成用户数据</h2><p>在电商领域的营销导购业务中，通常会用H5页面将商品以及其他营销活动以Feeds形式展示出来。用户通过浏览这个H5页面来找到想要购买的目标商品，然后下单完成订单交易。</p><!-- [[[read_end]]] --><p>在这样一个预定的用户行为路径下，势必会在H5页面对应位置以及对应Feeds卡片上留下用户的行为数据。本质上来说，这些数据是<strong>一组用户自身数据和用户行为数据结合映射。</strong>这个映射中显示了不同画像的人群在这样一个页面中的行为数据，以及这样的行为数据最后带来的商业行为结果。</p><p>其中，用户画像就是用户自己的属性标签，比如年龄、性别等基本信息。除此之外，如果取得用户同意以后，还会有职业、购买力（收入水平）、社交关系、价格敏感度、搜索记录、购买历史、收藏加入购物车行为等等维度的数据。</p><p>同时，用户的行为数据就是用户在H5 页面Feeds流中留下的行为数据。在Feeds流中所有信息都会以卡片的形式承载。那么，用户在什么时间、在某个卡片处停留了多久、在什么卡片处发生了点击行为等，都可以对应成为不同维度的数据。这些数据包括卡片的曝光时间、停留时长、用户的点击位置和点击次数等。</p><p>因为不同属性的用户会在页面中形成不同的行为数据，最后达到不同的业务效果。那么用户在页面中的行为数据就可以表达为这样一个因果结构：</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/e9/6fca9283dc9514388606e361b9f7ece9.jpg?wh=5652x1467\" alt=\"\"></p><p>基于这样的分析，我们就可以使用程序来生成模拟数据了。这里我们选择用户年龄和性别两个画像维度来模拟用户画像，以UV点击、UV点击率、曝光次数来模拟用户行为数据，并结合Feeds流卡片UI进行分析。</p><p>其中性别的分类是男、女两类，年龄则分为18-25、25-35、35-45、45-55这样四个年龄段。</p><p>性别的分类很容易理解，而对于年龄的分类是有一定考量的。</p><ul>\n<li>\n<p>18-25这个年龄段往往代表大学生或者刚入职场的年轻人，年龄小、对价格敏感、独立性逐渐增强、购买力有限，追求时尚潮流，偏爱个性化产品。</p>\n</li>\n<li>\n<p>25-35这个年龄段往往代表了已婚有家庭的工薪群体，有家庭及个人需求，有独立购买力。</p>\n</li>\n<li>\n<p>35-45这个年龄段往往代表了已婚有家庭且有稳定收入的群体，有较强的家庭需求，有较强的购买力，注重实用性和性价比。</p>\n</li>\n<li>\n<p>45-55这个年龄段往往代表了较高的经济稳定性，较高可支配收入，且家庭成员子女也已独立，注重健康，重视产品质量和品牌价值。</p>\n</li>\n</ul><p>由此其实可以看出，人群画像中的年龄这一指标，是一个足够用来描述用户的指标，能够反映出其他画像指标。</p><p>同样，对于一个电商营销导购页面中，根据业务属性在Feeds流中的卡片可以分为以下几类。</p><p>首先是<strong>商品卡片</strong>，这是整个Feeds流中最多的一类卡片。这类卡片用于承载商品信息，信息结构往往是商品图加上商品信息，以及一些商品特殊属性。所谓特殊属性，就是一些可能够让用户产生兴趣的信息，比如“次日达”。</p><p>UI结构则分为两种，以商品图和信息部分上下组合（如下图②左图），左右组合（如下图②右图）为主。</p><p>其次是<strong>功能卡片</strong>（如下图①），这一类卡片往往就是带有活动属性的卡片，比如秒杀模块。功能卡片会具有一个跳转功能，在模块上也会承接到所见所得的商品。</p><p>然后是<strong>活动卡片</strong>（如下图④），这类卡片一般是直接出一个具有具体含义的图，比如“37女神节女装合集”等，然后以banner的样式插入到商品卡片中。活动卡片同样具有跳转功能，点击后将会跳转到对应的活动页面中。</p><p>最后是一些具有特定功能的模块，如关注收藏栏等，如下图③。</p><p><img src=\"https://static001.geekbang.org/resource/image/58/cc/5894d285cb30072068a494230e171fcc.jpg?wh=2773x1398\" alt=\"\"></p><p>以这四类卡片来组成一个常规营销页面Feeds流，结构一般如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/03/0e/037b17e38736c4d04dbbf4f1dc91580e.jpg?wh=2517x3338\" alt=\"\"></p><p>理解了这些必要的数据维度后，接下来我们就来使用一段程序来帮我们随机生成这样的数据。</p><p>注意，这里我们尽量按照真实数据（来源于真实电商业务数据结果）来用程序随机生成数据，生成数据结果可能有好有坏。不过我们的重点是基于UI的可视化数据分析以及AI算法模型的端侧重排，所以不必太过关注模拟的随机数据结果。</p><p>后面这段代码就是生成模拟数据的程序，使用JavaScript实现。</p><pre><code class=\"language-javascript\">// 生成随机用户ID\nfunction generateUserIds(numUsers) {\n&nbsp; &nbsp; const userIds = [];\n&nbsp; &nbsp; for (let i = 0; i &lt; numUsers; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; userIds.push(`user_${i + 1}`);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return userIds;\n}\n\n// 生成随机性别\nfunction generateRandomGender() {\n&nbsp; &nbsp; const genders = ['male', 'female'];\n&nbsp; &nbsp; return genders[Math.floor(Math.random() * genders.length)];\n}\n\n// 生成随机年龄\nfunction generateRandomAge() {\n&nbsp; &nbsp; return Math.floor(Math.random() * (55 - 18 + 1)) + 18;\n}\n\n// 生成随机点击时间\nfunction generateRandomTime() {\n&nbsp; &nbsp; const date = new Date();\n&nbsp; &nbsp; date.setHours(Math.floor(Math.random() * 24));\n&nbsp; &nbsp; date.setMinutes(Math.floor(Math.random() * 60));\n&nbsp; &nbsp; date.setSeconds(Math.floor(Math.random() * 60));\n&nbsp; &nbsp; return date.toISOString();\n}\n\n// 生成随机点云\nfunction generateRandomPointCloud(numPoints, maxX, maxY) {\n&nbsp; &nbsp; const points = [];\n&nbsp; &nbsp; for (let i = 0; i &lt; numPoints; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; const x = Math.random() * maxX;\n&nbsp; &nbsp; &nbsp; &nbsp; const y = Math.random() * maxY;\n&nbsp; &nbsp; &nbsp; &nbsp; points.push({ x, y });\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return points;\n}\n\n// 在指定坐标附近生成热点区域\nfunction generateHotspotsNearCoordinate(centerX, centerY, numHotspots, maxOffset = 100) {\n&nbsp; &nbsp; const hotspots = [];\n&nbsp; &nbsp; for (let i = 0; i &lt; numHotspots; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; const pointCloud = generateRandomPointCloud(10, maxOffset * 2, maxOffset * 2).map(point =&gt; ({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x: centerX + point.x - maxOffset,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y: centerY + point.y - maxOffset\n&nbsp; &nbsp; &nbsp; &nbsp; }));\n&nbsp; &nbsp; &nbsp; &nbsp; hotspots.push(pointCloud);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return hotspots;\n}\n\n// 修改后的生成热点区域函数，热点区域在y = 0到800px范围内生成\nfunction generateHotspots(numHotspots, pageWidth) {\n&nbsp; &nbsp; const hotspots = [];\n&nbsp; &nbsp; for (let i = 0; i &lt; numHotspots; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; const maxY = 800; // 设置热点区域的最大Y坐标为800px\n&nbsp; &nbsp; &nbsp; &nbsp; const centerX = Math.floor(Math.random() * pageWidth);\n&nbsp; &nbsp; &nbsp; &nbsp; const centerY = Math.floor(Math.random() * maxY); // 限制中心Y坐标到前800px内\n&nbsp; &nbsp; &nbsp; &nbsp; const pointCloud = generateRandomPointCloud(10, 100, 100).map(point =&gt; ({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x: centerX + point.x - 50,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y: centerY + point.y - 50\n&nbsp; &nbsp; &nbsp; &nbsp; }));\n&nbsp; &nbsp; &nbsp; &nbsp; hotspots.push(pointCloud);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return hotspots;\n}\n\n// 检查点是否在多边形内\nfunction isPointInPolygon(point, polygon) {\n&nbsp; &nbsp; let x = point.x, y = point.y;\n&nbsp; &nbsp; let inside = false;\n&nbsp; &nbsp; for (let i = 0, j = polygon.length - 1; i &lt; polygon.length; j = i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; const xi = polygon[i].x, yi = polygon[i].y;\n&nbsp; &nbsp; &nbsp; &nbsp; const xj = polygon[j].x, yj = polygon[j].y;\n\n&nbsp; &nbsp; &nbsp; &nbsp; const intersect = ((yi &gt; y) !== (yj &gt; y)) &amp;&amp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (x &lt; (xj - xi) * (y - yi) / (yj - yi) + xi);\n&nbsp; &nbsp; &nbsp; &nbsp; if (intersect) inside = !inside;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return inside;\n}\n\n// 生成随机点击位置，模拟热点和冷点区域，并在x轴上点击数据逐渐减少\nfunction generateRandomClickPosition(hotspots, pageWidth) {\n&nbsp; &nbsp; let x, y;\n&nbsp; &nbsp; const decreaseRate = 0.5; // 调整这里的值来控制减少的速率，越小减少越慢\n&nbsp; &nbsp; if (Math.random() &lt; 0.7) { // 70%的概率生成在热点区域\n&nbsp; &nbsp; &nbsp; &nbsp; const hotspot = hotspots[Math.floor(Math.random() * hotspots.length)];\n&nbsp; &nbsp; &nbsp; &nbsp; do {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = Math.floor(Math.random() * pageWidth);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y = Math.floor(Math.random() * 5000);\n&nbsp; &nbsp; &nbsp; &nbsp; } while (!isPointInPolygon({ x, y }, hotspot) || Math.random() &gt; ((pageWidth - x) / pageWidth) ** decreaseRate);\n&nbsp; &nbsp; } else { // 30%的概率生成在其他区域\n&nbsp; &nbsp; &nbsp; &nbsp; do {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = Math.floor(Math.random() * pageWidth);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y = Math.floor(Math.random() * 5000);\n&nbsp; &nbsp; &nbsp; &nbsp; } while (Math.random() &gt; (5000 - y) / 5000 || Math.random() &gt; ((pageWidth - x) / pageWidth) ** decreaseRate);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return { x, y };\n}\n\n// 生成点击数据\nfunction generateClickData(userIds, clicksPerUser, hotspots, pageWidth) {\n&nbsp; &nbsp; const clickData = [];\n&nbsp; &nbsp; userIds.forEach(userId =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; const gender = generateRandomGender();\n&nbsp; &nbsp; &nbsp; &nbsp; const age = generateRandomAge();\n&nbsp; &nbsp; &nbsp; &nbsp; for (let i = 0; i &lt; clicksPerUser; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clickData.push({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userId: userId,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gender: gender,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; age: age,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clickTime: generateRandomTime(),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clickPosition: generateRandomClickPosition(hotspots, pageWidth)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n&nbsp; &nbsp; return clickData;\n}\nconst numUsers = 10000;\nconst clicksPerUser = 5; // 每个用户的点击次数\nconst numHotspots = 6; // 热点区域数量\nconst pageWidth = 390;\n\nconst userIds = generateUserIds(numUsers);\nconst hotspots = generateHotspots(numHotspots, pageWidth);\ngenerateClickData(userIds, clicksPerUser, hotspots, pageWidth)\n</code></pre><p>在这段代码中，生成了不同性别以及不同年龄段下的用户在一个H5页面中的点击行为数据。之后还通过热区的概念来模拟生成用户集中点击区域的数据，这模拟了用户的兴趣和注意力。</p><p>刚才的代码是模拟用户点击定位，并以点击的位置来生成数据。另外，我们也可以使用其他方式来模拟生成数据，比如借助被点击的卡片类型、被点击卡片的位置索引等等，并且可以通过计算生成UV点击率这样信息含量更高的数据结果。</p><p>这里我再说一些题外话，因为在真实业务环境中这些数据往往需要连表查询才能得到的，所以呢，对于前端工程师来说，SQL也是建议深入学习的。</p><h2>生成热力图</h2><p>有了模拟数据，我们就可以生成热力图了。这里使用heatmap.js这个热力图工具库，使用它绘制热力图很容易，只需引入heatmap的脚本即可实现自定义的热力图。代码如下：</p><pre><code class=\"language-xtml\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&nbsp; &nbsp; &lt;meta charset=\"UTF-8\"&gt;\n&nbsp; &nbsp; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n&nbsp; &nbsp; &lt;title&gt;Data Visualization with Real H5 Page&lt;/title&gt;\n&nbsp; &nbsp; &lt;style&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; * {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; padding: 0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; margin: 0;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; body {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; margin: 0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overflow: auto;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; position: relative;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; #heatmapContainer {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; position: absolute;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top: 0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left: 0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; width: 390px;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; height: 5000px;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pointer-events: none;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; z-index: 10;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; background: rgba(0, 0, 0, 0.3);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; #h5Page {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; position: absolute;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top: 0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left: 0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; width: 390px;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; height: 5000px;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; z-index: 1;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &lt;/style&gt;\n&nbsp; &nbsp; &lt;!-- 引入 heatmap.js --&gt;\n&nbsp; &nbsp; &lt;script src=\"https://cdn.jsdelivr.net/npm/heatmap.js@2.0.5/build/heatmap.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&nbsp; &nbsp; &lt;div id=\"h5Page\"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;!-- 真实的H5页面内容在这里 --&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;p&gt;Your real H5 page content goes here...&lt;/p&gt;\n&nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &lt;div id=\"heatmapContainer\"&gt;&lt;/div&gt;\n&nbsp; &nbsp; &lt;script&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; // 初始化 heatmap 实例\n&nbsp; &nbsp; &nbsp; &nbsp; const heatmapInstance = h337.create({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; container: document.getElementById('heatmapContainer'),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; radius: 20,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxOpacity: 0.8,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minOpacity: 0,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blur: 0.75,\n&nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; &nbsp; &nbsp; // 格式化数据为 heatmap.js 需要的格式\n&nbsp; &nbsp; &nbsp; &nbsp; const heatmapData = {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max: 10,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data: generateClickData(userIds, clicksPerUser, hotspots, pageWidth).map(click =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const { x, y } = click.clickPosition;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return { x, y, value: 1 };\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })\n&nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置热力图数据\n&nbsp; &nbsp; &nbsp; &nbsp; heatmapInstance.setData(heatmapData);\n&nbsp; &nbsp; &nbsp; &nbsp; // 同步滚动逻辑\n&nbsp; &nbsp; &nbsp; &nbsp; const syncScroll = () =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const scrollTop = window.scrollY;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heatmapContainer.style.transform = `translateY(${-scrollTop}px)`;\n&nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; &nbsp; &nbsp; window.addEventListener('scroll', syncScroll);\n&nbsp; &nbsp; &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>在这段代码中，使用heatmap的API新建了一个实例，再通过前面所讲的生成模拟数据的方法generateClickData 来生成模拟数据，并将这些数据格式化，输出为heatmap需要的数据格式，最后显示在网页上。</p><p>同时，HTML结构使用了position的布局，在热力图层下还有一层H5页面的内容，这样能够将数据和页面具体位置对应起来，便于观察分析。在网页中执行这个代码之后的效果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/60/4b/60f498ea412686ec4ef43e4bc001d74b.jpg?wh=712x851\" alt=\"\"></p><h2>总结</h2><p>让我们来总结一下今天的内容吧！</p><p>这节课我们使用程序生成了用户点击行为的模拟数据，并根据这些数据生成了热力图。这个过程里有几个细节点需要我们格外关注。</p><p>首先是关键数据指标，要模拟用户在页面中的行为数据，一些领域的关键指标及含义需要知晓。在Web应用中，重要的业务指标包括UV、PV、UV点击率、PV点击率以及曝光时长等。</p><p>在电商领域的营销导购业务中，我们可以通过H5页面的Feeds流来展示商品和活动，以获取用户的行为数据并对其进行分析。利用heatmap.js生成了用户点击的模拟数据，并与页面内容叠加，结合同步滚动逻辑，实现了用户点击行为的动态热力图展示。</p><p>通过对用户画像（如性别和年龄段）和用户行为数据（如UV点击率、曝光次数等）的模拟，我们就能结合JavaScript程序生成点击数据、热点区域和点击位置。这个模拟的意义在于帮助我们更好地理解不同人群的偏好和行为模式，从而更深入地分析用户在页面中的行为特征。这将为后续优化营销策略、构建推荐系统提供有力支持。</p><h2>思考题</h2><p>这节课里我们将用户年龄作为关键指标，分析了不同年龄段用户的特质。那么以职业（学生，公司职员，自由职业）来划分用户的话，你觉得会找到哪些特征呢？</p><p>欢迎你在留言区和我交流讨论，如果这节课对你有启发，也推荐你把它分享给更多朋友。</p>","comments":[]}