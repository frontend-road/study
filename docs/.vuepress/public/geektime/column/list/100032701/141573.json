{"id":141573,"title":"22 | 非阻塞I/O：提升性能的加速器","content":"<p>你好，我是盛延敏，这里是网络编程实战第22讲，欢迎回来。</p><p>在性能篇的前两讲中，我分别介绍了select和poll两种不同的I/O多路复用技术。在接下来的这一讲中，我将带大家进入非阻塞I/O模式的世界。事实上，非阻塞I/O配合I/O多路复用，是高性能网络编程中的常见技术。</p><h2>阻塞 VS 非阻塞</h2><p>当应用程序调用阻塞I/O完成某个操作时，应用程序会被挂起，等待内核完成操作，感觉上应用程序像是被“阻塞”了一样。实际上，内核所做的事情是将CPU时间切换给其他有需要的进程，网络应用程序在这种情况下就会得不到CPU时间做该做的事情。</p><p>非阻塞I/O则不然，当应用程序调用非阻塞I/O完成某个操作时，内核立即返回，不会把CPU时间切换给其他进程，应用程序在返回后，可以得到足够的CPU时间继续完成其他事情。</p><p>如果拿去书店买书举例子，阻塞I/O对应什么场景呢？ 你去了书店，告诉老板（内核）你想要某本书，然后你就一直在那里等着，直到书店老板翻箱倒柜找到你想要的书，有可能还要帮你联系全城其它分店。注意，这个过程中你一直滞留在书店等待老板的回复，好像在书店老板这里\"阻塞\"住了。</p><p>那么非阻塞I/O呢？你去了书店，问老板有没你心仪的那本书，老板查了下电脑，告诉你没有，你就悻悻离开了。一周以后，你又来这个书店，再问这个老板，老板一查，有了，于是你买了这本书。注意，这个过程中，你没有被阻塞，而是在不断轮询。</p><!-- [[[read_end]]] --><p>但轮询的效率太低了，于是你向老板提议：“老板，到货给我打电话吧，我再来付钱取书。”这就是前面讲到的I/O多路复用。</p><p>再进一步，你连去书店取书也想省了，得了，让老板代劳吧，你留下地址，付了书费，让老板到货时寄给你，你直接在家里拿到就可以看了。这就是我们将会在第30讲中讲到的异步I/O。</p><p>这几个I/O模型，再加上进程、线程模型，构成了整个网络编程的知识核心。</p><p>按照使用场景，非阻塞I/O可以被用到读操作、写操作、接收连接操作和发起连接操作上。接下来，我们对它们一一解读。</p><h2>非阻塞I/O</h2><h3>读操作</h3><p>如果套接字对应的接收缓冲区没有数据可读，在非阻塞情况下read调用会立即返回，一般返回EWOULDBLOCK或EAGAIN出错信息。在这种情况下，出错信息是需要小心处理，比如后面再次调用read操作，而不是直接作为错误直接返回。这就好像去书店买书没买到离开一样，需要不断进行又一次轮询处理。</p><h3>写操作</h3><p>不知道你有没有注意到，在阻塞I/O情况下，write函数返回的字节数，和输入的参数总是一样的。如果返回值总是和输入的数据大小一样，write等写入函数还需要定义返回值吗？我不知道你是不是和我一样，刚接触到这一部分知识的时候有这种困惑。</p><p>这里就要引出我们所说的非阻塞I/O。在非阻塞I/O的情况下，如果套接字的发送缓冲区已达到了极限，不能容纳更多的字节，那么操作系统内核会<strong>尽最大可能</strong>从应用程序拷贝数据到发送缓冲区中，并立即从write等函数调用中返回。可想而知，在拷贝动作发生的瞬间，有可能一个字符也没拷贝，有可能所有请求字符都被拷贝完成，那么这个时候就需要返回一个数值，告诉应用程序到底有多少数据被成功拷贝到了发送缓冲区中，应用程序需要再次调用write函数，以输出未完成拷贝的字节。</p><p>write等函数是可以同时作用到阻塞I/O和非阻塞I/O上的，为了复用一个函数，处理非阻塞和阻塞I/O多种情况，设计出了写入返回值，并用这个返回值表示实际写入的数据大小。</p><p>也就是说，非阻塞I/O和阻塞I/O处理的方式是不一样的。</p><p>非阻塞I/O需要这样：拷贝→返回→再拷贝→再返回。</p><p>而阻塞I/O需要这样：拷贝→直到所有数据拷贝至发送缓冲区完成→返回。</p><p>不过在实战中，你可以不用区别阻塞和非阻塞I/O，使用循环的方式来写入数据就好了。只不过在阻塞I/O的情况下，循环只执行一次就结束了。</p><p>我在前面的章节中已经介绍了类似的方案，你可以看到writen函数的实现。</p><pre><code>/* 向文件描述符fd写入n字节数 */\nssize_t writen(int fd, const void * data, size_t n)\n{\n    size_t      nleft;\n    ssize_t     nwritten;\n    const char  *ptr;\n\n    ptr = data;\n    nleft = n;\n    //如果还有数据没被拷贝完成，就一直循环\n    while (nleft &gt; 0) {\n        if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) {\n           /* 这里EAGAIN是非阻塞non-blocking情况下，通知我们再次调用write() */\n            if (nwritten &lt; 0 &amp;&amp; errno == EAGAIN)\n                nwritten = 0;      \n            else\n                return -1;         /* 出错退出 */\n        }\n\n        /* 指针增大，剩下字节数变小*/\n        nleft -= nwritten;\n        ptr   += nwritten;\n    }\n    return n;\n}\n</code></pre><p>下面我通过一张表来总结一下read和write在阻塞模式和非阻塞模式下的不同行为特性：</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/aa/6e7a467bc6f5985eebbd94ef7de14aaa.png?wh=1022*381\" alt=\"\"><br>\n关于read和write还有几个结论，你需要把握住：</p><ol>\n<li>read总是在接收缓冲区有数据时就立即返回，不是等到应用程序给定的数据充满才返回。当接收缓冲区为空时，阻塞模式会等待，非阻塞模式立即返回-1，并有EWOULDBLOCK或EAGAIN错误。</li>\n<li>和read不同，阻塞模式下，write只有在发送缓冲区足以容纳应用程序的输出字节时才返回；而非阻塞模式下，则是能写入多少就写入多少，并返回实际写入的字节数。</li>\n<li>阻塞模式下的write有个特例, 就是对方主动关闭了套接字，这个时候write调用会立即返回，并通过返回值告诉应用程序实际写入的字节数，如果再次对这样的套接字进行write操作，就会返回失败。失败是通过返回值-1来通知到应用程序的。</li>\n</ol><h3>accept</h3><p>当accept和I/O多路复用select、poll等一起配合使用时，如果在监听套接字上触发事件，说明有连接建立完成，此时调用accept肯定可以返回已连接套接字。这样看来，似乎把监听套接字设置为非阻塞，没有任何好处。</p><p>为了说明这个问题，我们构建一个客户端程序，其中最关键的是，一旦连接建立，设置SO_LINGER套接字选项，把l_onoff标志设置为1，把l_linger时间设置为0。这样，连接被关闭时，TCP套接字上将会发送一个RST。</p><pre><code>struct linger ling;\nling.l_onoff = 1; \nling.l_linger = 0;\nsetsockopt(socket_fd, SOL_SOCKET, SO_LINGER, &amp;ling, sizeof(ling));\nclose(socket_fd);\n</code></pre><p>服务器端使用select I/O多路复用，不过，监听套接字仍然是blocking的。如果监听套接字上有事件发生，休眠5秒，以便模拟高并发场景下的情形。</p><pre><code>if (FD_ISSET(listen_fd, &amp;readset)) {\n    printf(&quot;listening socket readable\\n&quot;);\n    sleep(5);\n    struct sockaddr_storage ss;\n    socklen_t slen = sizeof(ss);\n    int fd = accept(listen_fd, (struct sockaddr *) &amp;ss, &amp;slen);\n</code></pre><p>这里的休眠时间非常关键，这样，在监听套接字上有可读事件发生时，并没有马上调用accept。由于客户端发生了RST分节，该连接被接收端内核从自己的已完成队列中删除了，此时再调用accept，由于没有已完成连接（假设没有其他已完成连接），accept一直阻塞，更为严重的是，该线程再也没有机会对其他I/O事件进行分发，相当于该服务器无法对其他I/O进行服务。</p><p>如果我们将监听套接字设为非阻塞，上述的情形就不会再发生。只不过对于accept的返回值，需要正确地处理各种看似异常的错误，例如忽略EWOULDBLOCK、EAGAIN等。</p><p>这个例子给我们的启发是，一定要将监听套接字设置为非阻塞的，尽管这里休眠时间5秒有点夸张，但是在极端情况下处理不当的服务器程序是有可能碰到例子所阐述的情况，为了让服务器程序在极端情况下工作正常，这点工作还是非常值得的。</p><h3>connect</h3><p>在非阻塞TCP套接字上调用connect函数，会立即返回一个EINPROGRESS错误。TCP三次握手会正常进行，应用程序可以继续做其他初始化的事情。当该连接建立成功或者失败时，通过I/O多路复用select、poll等可以进行连接的状态检测。</p><h2>非阻塞I/O + select多路复用</h2><p>我在这里给出了一个非阻塞I/O搭配select多路复用的例子。</p><pre><code>#define MAX_LINE 1024\n#define FD_INIT_SIZE 128\n\nchar rot13_char(char c) {\n    if ((c &gt;= 'a' &amp;&amp; c &lt;= 'm') || (c &gt;= 'A' &amp;&amp; c &lt;= 'M'))\n        return c + 13;\n    else if ((c &gt;= 'n' &amp;&amp; c &lt;= 'z') || (c &gt;= 'N' &amp;&amp; c &lt;= 'Z'))\n        return c - 13;\n    else\n        return c;\n}\n\n//数据缓冲区\nstruct Buffer {\n    int connect_fd;  //连接字\n    char buffer[MAX_LINE];  //实际缓冲\n    size_t writeIndex;      //缓冲写入位置\n    size_t readIndex;       //缓冲读取位置\n    int readable;           //是否可以读\n};\n\nstruct Buffer *alloc_Buffer() {\n    struct Buffer *buffer = malloc(sizeof(struct Buffer));\n    if (!buffer)\n        return NULL;\n    buffer-&gt;connect_fd = 0;\n    buffer-&gt;writeIndex = buffer-&gt;readIndex = buffer-&gt;readable = 0;\n    return buffer;\n}\n\nvoid free_Buffer(struct Buffer *buffer) {\n    free(buffer);\n}\n\nint onSocketRead(int fd, struct Buffer *buffer) {\n    char buf[1024];\n    int i;\n    ssize_t result;\n    while (1) {\n        result = recv(fd, buf, sizeof(buf), 0);\n        if (result &lt;= 0)\n            break;\n\n        for (i = 0; i &lt; result; ++i) {\n            if (buffer-&gt;writeIndex &lt; sizeof(buffer-&gt;buffer))\n                buffer-&gt;buffer[buffer-&gt;writeIndex++] = rot13_char(buf[i]);\n            if (buf[i] == '\\n') {\n                buffer-&gt;readable = 1;  //缓冲区可以读\n            }\n        }\n    }\n\n    if (result == 0) {\n        return 1;\n    } else if (result &lt; 0) {\n        if (errno == EAGAIN)\n            return 0;\n        return -1;\n    }\n\n    return 0;\n}\n\nint onSocketWrite(int fd, struct Buffer *buffer) {\n    while (buffer-&gt;readIndex &lt; buffer-&gt;writeIndex) {\n        ssize_t result = send(fd, buffer-&gt;buffer + buffer-&gt;readIndex, buffer-&gt;writeIndex - buffer-&gt;readIndex, 0);\n        if (result &lt; 0) {\n            if (errno == EAGAIN)\n                return 0;\n            return -1;\n        }\n\n        buffer-&gt;readIndex += result;\n    }\n\n    if (buffer-&gt;readIndex == buffer-&gt;writeIndex)\n        buffer-&gt;readIndex = buffer-&gt;writeIndex = 0;\n\n    buffer-&gt;readable = 0;\n\n    return 0;\n}\n\nint main(int argc, char **argv) {\n    int listen_fd;\n    int i, maxfd;\n\n    struct Buffer *buffer[FD_INIT_SIZE];\n    for (i = 0; i &lt; FD_INIT_SIZE; ++i) {\n        buffer[i] = alloc_Buffer();\n    }\n\n    listen_fd = tcp_nonblocking_server_listen(SERV_PORT);\n\n    fd_set readset, writeset, exset;\n    FD_ZERO(&amp;readset);\n    FD_ZERO(&amp;writeset);\n    FD_ZERO(&amp;exset);\n\n    while (1) {\n        maxfd = listen_fd;\n\n        FD_ZERO(&amp;readset);\n        FD_ZERO(&amp;writeset);\n        FD_ZERO(&amp;exset);\n\n        // listener加入readset\n        FD_SET(listen_fd, &amp;readset);\n\n        for (i = 0; i &lt; FD_INIT_SIZE; ++i) {\n            if (buffer[i]-&gt;connect_fd &gt; 0) {\n                if (buffer[i]-&gt;connect_fd &gt; maxfd)\n                    maxfd = buffer[i]-&gt;connect_fd;\n                FD_SET(buffer[i]-&gt;connect_fd, &amp;readset);\n                if (buffer[i]-&gt;readable) {\n                    FD_SET(buffer[i]-&gt;connect_fd, &amp;writeset);\n                }\n            }\n        }\n\n        if (select(maxfd + 1, &amp;readset, &amp;writeset, &amp;exset, NULL) &lt; 0) {\n            error(1, errno, &quot;select error&quot;);\n        }\n\n        if (FD_ISSET(listen_fd, &amp;readset)) {\n            printf(&quot;listening socket readable\\n&quot;);\n            sleep(5);\n            struct sockaddr_storage ss;\n            socklen_t slen = sizeof(ss);\n           int fd = accept(listen_fd, (struct sockaddr *) &amp;ss, &amp;slen);\n            if (fd &lt; 0) {\n                error(1, errno, &quot;accept failed&quot;);\n            } else if (fd &gt; FD_INIT_SIZE) {\n                error(1, 0, &quot;too many connections&quot;);\n                close(fd);\n            } else {\n                make_nonblocking(fd);\n                if (buffer[fd]-&gt;connect_fd == 0) {\n                    buffer[fd]-&gt;connect_fd = fd;\n                } else {\n                    error(1, 0, &quot;too many connections&quot;);\n                }\n            }\n        }\n\n        for (i = 0; i &lt; maxfd + 1; ++i) {\n            int r = 0;\n            if (i == listen_fd)\n                continue;\n\n            if (FD_ISSET(i, &amp;readset)) {\n                r = onSocketRead(i, buffer[i]);\n            }\n            if (r == 0 &amp;&amp; FD_ISSET(i, &amp;writeset)) {\n                r = onSocketWrite(i, buffer[i]);\n            }\n            if (r) {\n                buffer[i]-&gt;connect_fd = 0;\n                close(i);\n            }\n        }\n    }\n}\n</code></pre><p>第93行，调用fcntl将监听套接字设置为非阻塞。</p><pre><code>fcntl(fd, F_SETFL, O_NONBLOCK);\n</code></pre><p>第121行调用select进行I/O事件分发处理。</p><p>131-142行在处理新的连接套接字，注意这里也把连接套接字设置为非阻塞的。</p><p>151-156行在处理连接套接字上的I/O读写事件，这里我们抽象了一个Buffer对象，Buffer对象使用了readIndex和writeIndex分别表示当前缓冲的读写位置。</p><h2>实验</h2><p>启动该服务器：</p><pre><code>$./nonblockingserver\n</code></pre><p>使用多个telnet客户端连接该服务器，可以验证交互正常。</p><pre><code>$telnet 127.0.0.1 43211\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nfasfasfasf\nsnfsnfsnfs\n</code></pre><h2>总结</h2><p>非阻塞I/O可以使用在read、write、accept、connect等多种不同的场景，在非阻塞I/O下，使用轮询的方式引起CPU占用率高，所以一般将非阻塞I/O和I/O多路复用技术select、poll等搭配使用，在非阻塞I/O事件发生时，再调用对应事件的处理函数。这种方式，极大地提高了程序的健壮性和稳定性，是Linux下高性能网络编程的首选。</p><h2>思考题</h2><p>给你布置两道思考题:</p><p>第一道，程序中第133行这个判断说明了什么？如果要改进的话，你有什么想法？</p><pre><code>else if (fd &gt; FD_INIT_SIZE) {\n    error(1, 0, &quot;too many connections&quot;);\n    close(fd);\n</code></pre><p>第二道，你可以仔细阅读一下数据读写部分Buffer的代码，你觉得用一个Buffer对象，而不是两个的目的是什么？</p><p>欢迎在评论区写下你的思考，我会和你一起交流，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","neighbors":{"left":{"article_title":"21 | poll：另一种I/O多路复用","id":140520},"right":{"article_title":"23 | Linux利器：epoll的前世今生","id":143245}},"comments":[{"had_liked":false,"id":171554,"user_name":"HerofH","can_delete":false,"product_type":"c1","uid":1480252,"ip_address":"","ucode":"84EB3243FAB432","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/86QEF74Mhc6ECbBBMr62hVz0ezOicI2Kbv8QBA7qR7KepeoDib9W6KLxxMPuQ24JGusvjC03NNr8uj8GyK0DxKiaw/132","comment_is_top":false,"comment_ctime":1578966150,"is_pvip":false,"replies":[{"id":"68052","content":"读缓冲的作用有很多，你提到了通过设置缓冲区，减少系统调用的次数是一个方面，另外，别忘了读取的数据是需要在应用层进行报文解析的，一个应用层缓冲区显然是比较方便的，否则，需要不断的进行数据的读取，直至解析到完整的报文。我认为，应用层缓冲是&quot;空间换时间&quot;的一个比较好的例子。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1580627688,"ip_address":"","comment_id":171554,"utype":1}],"discussion_count":1,"race_medal":0,"score":"134722952326","product_id":100032701,"comment_content":"老师您好！我看到您这在应用层设计了一个读写缓冲区，我之前看了muduo和libevent，也是设计了这样的缓冲区，并且muduo作者陈硕也提到非阻塞IO必须要设计一个应用层Buffer，我很疑惑的就是，这样的读写缓冲区的必要性是什么呢？<br>我大概只能理解到非阻塞IO下使用应用层写缓冲区可以让还未来得及发出的数据先保存在应用层Buffer中，然后等到可写的时候再将数据从应用层Buffer写到fd的发送缓冲区中；<br>那么如何理解应用层读缓冲区的必要性呢？有数据来，触发可读事件，这个时候直接调用read去读不就可以了吗，为什么一定要先读到读缓冲区呢？根据libevent中，每次读数据时都会尽量多的从fd的接收缓冲区中读取数据到应用层buffer，我的一种想法是，设置读缓冲区的作用，是否是为了减少read的调用次数呢？<br>还是有其它原因呢？想了解一下老师的看法，谢谢！<br>","like_count":31,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481411,"discussion_content":"读缓冲的作用有很多，你提到了通过设置缓冲区，减少系统调用的次数是一个方面，另外，别忘了读取的数据是需要在应用层进行报文解析的，一个应用层缓冲区显然是比较方便的，否则，需要不断的进行数据的读取，直至解析到完整的报文。我认为，应用层缓冲是&amp;quot;空间换时间&amp;quot;的一个比较好的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580627688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259668,"user_name":"TinyCalf","can_delete":false,"product_type":"c1","uid":2137418,"ip_address":"","ucode":"0A3EF213359388","user_header":"https://static001.geekbang.org/account/avatar/00/20/9d/4a/09a5041e.jpg","comment_is_top":false,"comment_ctime":1604806236,"is_pvip":false,"replies":[{"id":"95514","content":"我觉得是可以这样理解的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1606042277,"ip_address":"","comment_id":259668,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57439381084","product_id":100032701,"comment_content":"我在思考一个问题，select既然已经告诉我们接口可读了，为什么还要用非阻塞IO；我自己的想法是，select其实只通知了有没有内容可读，没有提供有多少数据可读，所以当我们使用阻塞IO循环read时，无法确认下一个read还是不是可读的，因此仍然可能阻塞，而非阻塞IO可以解决这个问题，不知道我想的对不对","like_count":13,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508997,"discussion_content":"我觉得是可以这样理解的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606042277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2765079,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/31/17/ab2c27a6.jpg","nickname":"菜鸡互啄","note":"","ucode":"59162B81398399","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":539069,"discussion_content":"老师 为什么不是告诉我们哪个接口可读了 顺便把多少数据可读一并完成呢？是操作就是这样设计的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639584631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":508997,"ip_address":""},"score":539069,"extra":""}]}]},{"had_liked":false,"id":137084,"user_name":"MoonGod","can_delete":false,"product_type":"c1","uid":1254337,"ip_address":"","ucode":"CB39976963F37A","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/c1/54ef6885.jpg","comment_is_top":false,"comment_ctime":1569593504,"is_pvip":false,"replies":[{"id":"52780","content":"我在代码里多加一些注释，可以看最新的代码<br><br>https:&#47;&#47;github.com&#47;froghui&#47;yolanda","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569723893,"ip_address":"","comment_id":137084,"utype":1}],"discussion_count":3,"race_medal":0,"score":"53109201056","product_id":100032701,"comment_content":"感觉这篇的解释和前面的比起来太不细致了…很多地方都没说明。老师能不能多一些说明啊","like_count":12,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468934,"discussion_content":"我在代码里多加一些注释，可以看最新的代码\n\nhttps://github.com/froghui/yolanda","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569723893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2153838,"avatar":"https://static001.geekbang.org/account/avatar/00/20/dd/6e/8f6f79d2.jpg","nickname":"YUAN","note":"","ucode":"98EF68EEE21893","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316070,"discussion_content":"不应该是大于等于就判断连接太多吗？buffer最大下标是fd_init_size-1","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603354667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2153838,"avatar":"https://static001.geekbang.org/account/avatar/00/20/dd/6e/8f6f79d2.jpg","nickname":"YUAN","note":"","ucode":"98EF68EEE21893","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316089,"discussion_content":"老师您好，我认为\n1.那个buffer缓冲区可以做成循环的数组\n2.我认为onSocketRead那个函数会造成数据丢失吧，如果recv的数据超过了buffer的可用内存，就会造成客户的数据丢失吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603357311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241390,"user_name":"fedwing","can_delete":false,"product_type":"c1","uid":1743661,"ip_address":"","ucode":"2DFF902FD190C7","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/2d/f7fca208.jpg","comment_is_top":false,"comment_ctime":1597283654,"is_pvip":false,"replies":[{"id":"89400","content":"select和poll是&quot;老板&quot;这个内核自己在轮询哦，不是买书人(应用程序)在轮询，&quot;老板&quot;可以有多个方式优化这个过程，比如他记录了一个事件，一旦书定成了，他就发现需要告诉和他有订阅关系的&quot;你&quot;了。想想看，作为应用程序的&quot;你&quot;在这个过程中，是不是可以放开手干点别的事，比如玩个吃鸡游戏的什么。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1597641080,"ip_address":"","comment_id":241390,"utype":1}],"discussion_count":3,"race_medal":0,"score":"40251989318","product_id":100032701,"comment_content":"那么非阻塞 I&#47;O 呢？你去了书店，问老板有没你心仪的那本书，老板查了下电脑，告诉你没有，你就悻悻离开了。一周以后，你又来这个书店，再问这个老板，老板一查，有了，于是你买了这本书。注意，这个过程中，你没有被阻塞，而是在不断轮询。但轮询的效率太低了，于是你向老板提议：“老板，到货给我打电话吧，我再来付钱取书。”这就是前面讲到的 I&#47;O 多路复用。 <br>    对于这个我有点疑问，select和poll本质上，不都是轮询吗，为什么这里说轮询效率太低，改成select，poll","like_count":9,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503732,"discussion_content":"select和poll是&amp;quot;老板&amp;quot;这个内核自己在轮询哦，不是买书人(应用程序)在轮询，&amp;quot;老板&amp;quot;可以有多个方式优化这个过程，比如他记录了一个事件，一旦书定成了，他就发现需要告诉和他有订阅关系的&amp;quot;你&amp;quot;了。想想看，作为应用程序的&amp;quot;你&amp;quot;在这个过程中，是不是可以放开手干点别的事，比如玩个吃鸡游戏的什么。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597641080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346285,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/ed/76500086.jpg","nickname":"feng","note":"","ucode":"254A0D72E07ABF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588489,"discussion_content":"老师，select不是阻塞等待了吗，应用程序怎么可以去做别的事？如果不阻塞，那不是直接返回了吗，应用程序下一次还要来轮询才能知道要拿书了。逻辑不通啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663803003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245504,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/40/a203a3b9.jpg","nickname":"爱学习不害怕","note":"","ucode":"BE325C02E4C92F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298437,"discussion_content":"我理解一个是用户态一个是内核态吧。poll和select是内核实现的轮询，比用户态实现的轮询效率高一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597299024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234024,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1594555538,"is_pvip":false,"replies":[{"id":"86811","content":"总结到位👍","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1594907593,"ip_address":"","comment_id":234024,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40249261202","product_id":100032701,"comment_content":"1.select，poll，epoll是io多路复用技术，是操作系统提供的检测io事件是否就绪的方法，当然我们可以不用操作系统提供的方法而自己去写一个轮训，但是轮训会加重cpu负载。<br>2.当我们调用fcntl将套接字配置为非阻塞后，在该套接字上后续的accept，read，write操作都将变为非阻塞<br>3.非阻塞io一般都需要配合io多路复用技术使用","like_count":9,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501244,"discussion_content":"总结到位👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594907593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2776006,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er5SNsSoiaZw4Qzd2ctH4vtibHQordcLrYsX43oFZFloRTId0op617mcGlrvGx33U8ic2LTgdicoEFPvQ/132","nickname":"Frankey","note":"","ucode":"2F09BC2500C9E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569272,"discussion_content":"我还正纳闷怎么实现非阻塞的，然后就看到了你评论，帮上忙了。谢谢。我看了下代码。fcntl(fd, F_SETFL, O_NONBLOCK);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651389804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224565,"user_name":"扩散性百万咸面包","can_delete":false,"product_type":"c1","uid":1905171,"ip_address":"","ucode":"6D703D51553B42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","comment_is_top":false,"comment_ctime":1591444420,"is_pvip":false,"replies":[{"id":"84264","content":"很认真的回答你，我觉得你说的 单线程 + 多路复用 + 非阻塞I&#47;O，是和redis的设计有关的，通过这么一个设计，减少了多个线程锁的消耗，我想是redis做了一些取舍的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1592740334,"ip_address":"","comment_id":224565,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40246150084","product_id":100032701,"comment_content":"老师，认真的问你一个问题。<br><br>Redis中，网上的介绍是说单线程 + 多路复用 + 非阻塞I&#47;O。为什么不采取C10k问题中的，主从Reactor结构，多个事件分发器来充分利用CPU的多核能力呢？理论上这样更好啊。","like_count":9,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497526,"discussion_content":"很认真的回答你，我觉得你说的 单线程 + 多路复用 + 非阻塞I/O，是和redis的设计有关的，通过这么一个设计，减少了多个线程锁的消耗，我想是redis做了一些取舍的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592740334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2549097,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoib6BjEV4KPEaIdlLEfoVFRCxCSlL2XaIVDiaakvjhWEibibym323ZeHXAY46JMO3nSHmjiaWtAY47eww/132","nickname":"dobby","note":"","ucode":"9C1992C4DD28F5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534003,"discussion_content":"很简单，redis设计团队肯定在多线程锁竞争和单线程中比较出来，单线程这种架构性能更好更适用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638068457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182955,"user_name":"绿箭侠","can_delete":false,"product_type":"c1","uid":1528536,"ip_address":"","ucode":"B994F558A98E29","user_header":"https://static001.geekbang.org/account/avatar/00/17/52/d8/123a4981.jpg","comment_is_top":false,"comment_ctime":1582897104,"is_pvip":false,"replies":[{"id":"71027","content":"非阻塞和阻塞是指I&#47;O，具体作用到的是套接字上，而select这里是I&#47;O多路复用的一种技术，注意到这一行 ：<br>make_nonblocking(fd);<br><br>实际上是把套接字都改为非阻塞I&#47;O，再通过I&#47;O多路复用来接收套接字上的I&#47;O事件。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1583051969,"ip_address":"","comment_id":182955,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23057733584","product_id":100032701,"comment_content":"老师，评论区中 程序水果宝 说select非阻塞，我的理解：select(maxfd + 1, &amp;readset, &amp;writeset, &amp;exset, NULL) 此处因为NULL当然阻塞，不明白为什么说select非阻塞？？","like_count":5,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485511,"discussion_content":"非阻塞和阻塞是指I/O，具体作用到的是套接字上，而select这里是I/O多路复用的一种技术，注意到这一行 ：\nmake_nonblocking(fd);\n\n实际上是把套接字都改为非阻塞I/O，再通过I/O多路复用来接收套接字上的I/O事件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583051969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026502,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a9/c6/30b29c22.jpg","nickname":"那风在极客","note":"","ucode":"132B9263006BB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591075,"discussion_content":"select 是阻塞的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666262208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2916751,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/U5vvFI4v3jibf6uHbOFtkm1sBaXeLZnJicCOia0KW5KNb2KK06we5gkzJE7RiawfDzMAicHIpINUrTYfjrdZweQsuUA/132","nickname":"Geek_1cd0c8","note":"","ucode":"1F0C3F5E03C420","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576596,"discussion_content":"select函数本身不就是阻塞函数？！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655693567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147943,"user_name":"javaYJL","can_delete":false,"product_type":"c1","uid":1188249,"ip_address":"","ucode":"E326EB9AFDCE32","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/99/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1572920678,"is_pvip":false,"replies":[{"id":"57483","content":"accept和阻塞套接字一起使用就是阻塞的，和非阻塞套集字一起使用就是非阻塞的。阻塞和非阻塞是作用到套集字上的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1573282485,"ip_address":"","comment_id":147943,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23047757158","product_id":100032701,"comment_content":"老师，accept（)这个函数不是阻塞的吗？","like_count":5,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473347,"discussion_content":"accept和阻塞套接字一起使用就是阻塞的，和非阻塞套集字一起使用就是非阻塞的。阻塞和非阻塞是作用到套集字上的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573282485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138522,"user_name":"一天到晚游泳的鱼","can_delete":false,"product_type":"c1","uid":1433982,"ip_address":"","ucode":"1F40AF478D85B9","user_header":"","comment_is_top":false,"comment_ctime":1570289648,"is_pvip":false,"replies":[{"id":"54309","content":"你的理解是对的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570971673,"ip_address":"","comment_id":138522,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23045126128","product_id":100032701,"comment_content":"老师，我想请教一个问题就是, 当把一个描述符设置为非阻塞的之后，在该描述符上面的操作就会变成非阻塞的吗? 比如说把连接套接字设置为非阻塞的，send和recv就会变成非阻塞的吗?","like_count":5,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469555,"discussion_content":"你的理解是对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570971673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202482,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ydFhHonicUQibGlAfsAYBibNOfSxpCG5cJNp9oRibTJm3TrxM7Hj4WPPCRE3vluZJb0TGQqpKCaBWLdmra5Su1KF5Q/132","nickname":"yudidi","note":"","ucode":"70283DE39D86F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225021,"discussion_content":"是不是可以这么理解：如果listen_fd是非阻塞IO的套接字，accept(listen_fd)就不会阻塞?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586344488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137387,"user_name":"yusuf","can_delete":false,"product_type":"c1","uid":1170784,"ip_address":"","ucode":"9F32149B2ADDA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/60/eae432c6.jpg","comment_is_top":false,"comment_ctime":1569727729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23044564209","product_id":100032701,"comment_content":"1、133行判断是否超过了文件描述符的最大值，如果超过了，就会报错。可以考虑使用动态分配的方式，但如果超过了1024的话，使用上一节中的poll来处理会更好些<br>2、认为是考虑到对同一个fd的同一缓冲区进行读写操作，只用一个Buffer对象足够了","like_count":5},{"had_liked":false,"id":251616,"user_name":"YUAN","can_delete":false,"product_type":"c1","uid":2153838,"ip_address":"","ucode":"98EF68EEE21893","user_header":"https://static001.geekbang.org/account/avatar/00/20/dd/6e/8f6f79d2.jpg","comment_is_top":false,"comment_ctime":1601726059,"is_pvip":false,"replies":[{"id":"92060","content":"我把它归为多路复用。轮询的意思是应用程序自己不断的从应用层发起检测。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1601871749,"ip_address":"","comment_id":251616,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18781595243","product_id":100032701,"comment_content":"select和poll也是轮训吧😄？","like_count":4,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506566,"discussion_content":"我把它归为多路复用。轮询的意思是应用程序自己不断的从应用层发起检测。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601871749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287486,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1617973539,"is_pvip":false,"replies":[{"id":"104490","content":"鼓掌👏","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1618140137,"ip_address":"","comment_id":287486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14502875427","product_id":100032701,"comment_content":"Buffer.readable 为 1 或 0：<br><br>1-可读，说明结构体 buffer 有数据可读，也就可以往 connect_fd 写数据，因此是监听 connect_fd 的写事件。<br><br>0-不可读，说明结构体 buffer 无数据，即结构体 buffer 有空间可以写数据，也就可以从 connect_fd 读数据，因此是监听 connect_fd 的读事件。<br><br>老师，是这样不，谢谢！","like_count":3,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518322,"discussion_content":"鼓掌👏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618140137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170376,"user_name":"skye","can_delete":false,"product_type":"c1","uid":1027840,"ip_address":"","ucode":"C55C9F52C78A00","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/00/9b49f42b.jpg","comment_is_top":false,"comment_ctime":1578582206,"is_pvip":false,"replies":[{"id":"68058","content":"这句话是说，在read调用时，虽然设定需要1k个字节，实际上总是在缓冲区有数据时就立即返回了，有可能只读到了20个字节。这种行为对阻塞和非阻塞是一样的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1580628460,"ip_address":"","comment_id":170376,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14463484094","product_id":100032701,"comment_content":"read 总是在接收缓冲区有数据时就立即返回，不是等到应用程序给定的数据充满才返回。===<br>老师，这个是指阻塞时吗？","like_count":3,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480961,"discussion_content":"这句话是说，在read调用时，虽然设定需要1k个字节，实际上总是在缓冲区有数据时就立即返回了，有可能只读到了20个字节。这种行为对阻塞和非阻塞是一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580628460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137557,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1569775291,"is_pvip":false,"replies":[{"id":"53867","content":"ROT13（回转13位，rotateby13places，有时中间加了个减号称作ROT-13）是一种简易的置换暗码。<br><br>ROT-13 编码是一种每一个字母被另一个字母代替的方法。这个代替字母是由原来的字母向前移动 13 个字母而得到的。数字和非字母字符保持不变。<br><br>它是一种在网路论坛用作隐藏八卦、妙句、谜题解答以及某些脏话的工具，目的是逃过版主或管理员的匆匆一瞥。ROT13激励了广泛的线上书信撰写与字母游戏，且它常于新闻群组对话中被提及。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570698137,"ip_address":"","comment_id":137557,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14454677179","product_id":100032701,"comment_content":"老师代码中进行rot13_char编码的目的是啥？","like_count":3,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469148,"discussion_content":"ROT13（回转13位，rotateby13places，有时中间加了个减号称作ROT-13）是一种简易的置换暗码。\n\nROT-13 编码是一种每一个字母被另一个字母代替的方法。这个代替字母是由原来的字母向前移动 13 个字母而得到的。数字和非字母字符保持不变。\n\n它是一种在网路论坛用作隐藏八卦、妙句、谜题解答以及某些脏话的工具，目的是逃过版主或管理员的匆匆一瞥。ROT13激励了广泛的线上书信撰写与字母游戏，且它常于新闻群组对话中被提及。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570698137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137152,"user_name":"石将从","can_delete":false,"product_type":"c1","uid":1375617,"ip_address":"","ucode":"12F43E643D1D58","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/81/1864f266.jpg","comment_is_top":false,"comment_ctime":1569636213,"is_pvip":false,"replies":[{"id":"52778","content":"其实还是蛮简单的，稍微解释一下：<br><br>onSocketRead是通过套接字读取数据，数据存放在Buffer对象里，Buffer对象通过了writeIndex记录当前数<br>据区可写的位置；<br><br>onSocketWrite通过套接字写数据，数据来源于Buffer缓冲对象，Buffer缓冲对象的readIndex记录了当前缓冲区读的位置。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569723806,"ip_address":"","comment_id":137152,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14454538101","product_id":100032701,"comment_content":"没有注释，看onSocketWrite和onSocketRead函数很费劲","like_count":3,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468959,"discussion_content":"其实还是蛮简单的，稍微解释一下：\n\nonSocketRead是通过套接字读取数据，数据存放在Buffer对象里，Buffer对象通过了writeIndex记录当前数\n据区可写的位置；\n\nonSocketWrite通过套接字写数据，数据来源于Buffer缓冲对象，Buffer缓冲对象的readIndex记录了当前缓冲区读的位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569723806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240117,"user_name":"keepgoing","can_delete":false,"product_type":"c1","uid":1471387,"ip_address":"","ucode":"A2FE0687FB17E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/73/9b/67a38926.jpg","comment_is_top":false,"comment_ctime":1596765529,"is_pvip":false,"replies":[{"id":"89396","content":"如果是recv == 0，则说明是EOF，正常关闭；<br>如果是recv &lt;0，说明出错了，不做任何处理，继续下个fd；<br>如不是recv &lt;0,但是为EAGAIN，则进入写判断；<br><br>-1的作用就是为了区别出&gt;0和==0的不同return值。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1597640709,"ip_address":"","comment_id":240117,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10186700121","product_id":100032701,"comment_content":"请问老师onSocketRead函数中，error != EAGAIN的情况不应该也返回1，表示读到了错误需要关闭吗。<br>我理解recv == 0 以及 &lt; 0的情况都需要关闭，这里为什么只判断 == 0的情况关闭呢，另外结果返回值r == -1一直没有处理，想问下这个-1是什么用呢。看完代码比较疑惑，想请老师解答一下","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503346,"discussion_content":"如果是recv == 0，则说明是EOF，正常关闭；\n如果是recv &amp;lt;0，说明出错了，不做任何处理，继续下个fd；\n如不是recv &amp;lt;0,但是为EAGAIN，则进入写判断；\n\n-1的作用就是为了区别出&amp;gt;0和==0的不同return值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597640709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2331572,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep1aHicNquR3ETTicbInlCpfawcDMB8ILYyzegVTubTgQ0w6icarsK7fglpZVr7VfiaJaQ0eokNAHVYLA/132","nickname":"一个戒","note":"","ucode":"2FD9289C547785","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332396,"discussion_content":"请问一下楼主，当onSocketRead返回值为0时，有可能是EAGAIN或者onSocketRead完成，为什么154行判断一下就直接写了，如果是EAGAIN好像没做任何处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607179624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1471387,"avatar":"https://static001.geekbang.org/account/avatar/00/16/73/9b/67a38926.jpg","nickname":"keepgoing","note":"","ucode":"A2FE0687FB17E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300717,"discussion_content":"好的明白，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598246174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138285,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1570154956,"is_pvip":false,"replies":[{"id":"54298","content":"不是一定需要select才可以 accept的。这里的例子主要是说明如果不给监听套集字设置为非阻塞，可能会引起的问题。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570970283,"ip_address":"","comment_id":138285,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10160089548","product_id":100032701,"comment_content":"老师，有一个地方不是很明白。在连接套接字设为阻塞时，当客户端发送RST后，服务端在已完成连接队列删除了连接，accept阻塞。这时候如果有新连接进来了，为什么accept还是会阻塞呀？难道新连接进来一定要先select之后，accept才能取到连接好的套接字？？","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469467,"discussion_content":"不是一定需要select才可以 accept的。这里的例子主要是说明如果不给监听套集字设置为非阻塞，可能会引起的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570970283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202482,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ydFhHonicUQibGlAfsAYBibNOfSxpCG5cJNp9oRibTJm3TrxM7Hj4WPPCRE3vluZJb0TGQqpKCaBWLdmra5Su1KF5Q/132","nickname":"yudidi","note":"","ucode":"70283DE39D86F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225015,"discussion_content":"我觉得，只要有新的连接建立，accept就能返回，继续执行吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586344057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123690,"avatar":"https://static001.geekbang.org/account/avatar/00/11/25/6a/fac4e9d5.jpg","nickname":"战","note":"","ucode":"B65666690D15AA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117052,"discussion_content":"accept 在这种情况应该是能获取新链接的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578084953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137556,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1569774749,"is_pvip":false,"replies":[{"id":"53866","content":"这里举的一个例子，有可能在新的协议栈下有所改变，但是不管怎样，理论上的分析有可能导致阻塞，所以我们还是应该在平时编码中将监听套接字也设置为非阻塞的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570697914,"ip_address":"","comment_id":137556,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10159709341","product_id":100032701,"comment_content":"老师那个accept阻塞的实验，在我电脑（linux-4.18.0，ubuntu18.10）上的行为有点不太一样，无论是把listen_fd设置为阻塞还是非阻塞，sleep 5s还是10s或者更长，行为总是：accept成功获取到客户端连接，然后读取到客户端的RST","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469147,"discussion_content":"这里举的一个例子，有可能在新的协议栈下有所改变，但是不管怎样，理论上的分析有可能导致阻塞，所以我们还是应该在平时编码中将监听套接字也设置为非阻塞的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570697914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1498137,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dc/19/c058bcbf.jpg","nickname":"流浪地球","note":"","ucode":"25210DCD353F97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33428,"discussion_content":"我对这个地方的理解也是，服务器端accept后，客户端才认为链接建立成功，才会走后面的设置及close操作，对老师的代码产生的现象不是很理解。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1571123108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1717235,"avatar":"","nickname":"ray","note":"","ucode":"10962C711CBC11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228883,"discussion_content":"我是在ubuntu 18.04 kernel 5.3.0-46-generic，用wireshark抓包的结果是client一建立完连结后，会马上断开。但是accept还是会正常取出fd然后工作，不管有没有加make_nonblocking都一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586586176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1433982,"avatar":"","nickname":"一天到晚游泳的鱼","note":"","ucode":"1F40AF478D85B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24921,"discussion_content":"我用的centos系统，实验的结果和你一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570332235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288575,"user_name":"Jaime","can_delete":false,"product_type":"c1","uid":1078333,"ip_address":"","ucode":"904192CC4E916F","user_header":"https://static001.geekbang.org/account/avatar/00/10/74/3d/54bbc1df.jpg","comment_is_top":false,"comment_ctime":1618543318,"is_pvip":true,"replies":[{"id":"104850","content":"👍","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1618751718,"ip_address":"","comment_id":288575,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5913510614","product_id":100032701,"comment_content":"第一道问题，说明了这个服务器只能服务固定的连接，LINUX上是1024，改进的化，可以使用poll或者epoll突破文件描述符数量限制<br>第二道问题，BUFF就是一个循环缓冲区，一个读指针，一个写指针，已经可以实现读写功能，目的是节省内存","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518667,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618751718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287359,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1617900813,"is_pvip":false,"replies":[{"id":"104488","content":"select和poll是让操作系统在有I&#47;O实际时再从调用中返回，而且本质上select和poll都是在等待多种I&#47;O事件，和前面每次轮询单个I&#47;O事件是否就绪，有天壤之别。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1618139962,"ip_address":"","comment_id":287359,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5912868109","product_id":100032701,"comment_content":"原文：<br>那么非阻塞 I&#47;O 呢？…，这个过程中，你没有被阻塞，而是在不断轮询。<br>但轮询的效率太低了，于是你向老板提议：“老板，到货给我打电话吧，我再来付钱取书。”这就是前面讲到的 I&#47;O 多路复用。<br><br>以下代码片段，摘自前面两节课，当 select&#47;poll 的 time 参数设置为 0，也是非阻塞立刻返回，然后不断轮询调用 select&#47;poll 函数。这不就和非阻塞 I&#47;O 描述的是一样：立刻返回+轮询。<br>是不是说 select&#47;poll 可以处理多条“链路”，而非阻塞 I&#47;O 只处理一条链路。还是说这两个概念不是一回事，水果和动物不能混为一谈。<br>请问老师，是我哪里理解错了么？谢谢！<br><br>select&#47;poll 多路复用代码段：<br>for (;;) {<br>    readmask = allreads;<br>    int rc = select(socket_fd + 1, &amp;readmask, NULL, NULL, NULL);<br>}<br><br>for (;;) {<br>    if ((ready_number = poll(event_set, INIT_SIZE, -1)) &lt; 0) {<br>        error(1, errno, &quot;poll failed &quot;);<br>    }<br>}","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518277,"discussion_content":"select和poll是让操作系统在有I/O实际时再从调用中返回，而且本质上select和poll都是在等待多种I/O事件，和前面每次轮询单个I/O事件是否就绪，有天壤之别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618139962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268904,"user_name":"Geek_8313015","can_delete":false,"product_type":"c1","uid":1482180,"ip_address":"","ucode":"19EE1CD90CA3EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIvcr7IX9NtayicPbkuRzW661kQwxiaFFV3zSRVzJV0siaHXFEryofa06W1gGL5gnVLVH8DhttHyMIxQ/132","comment_is_top":false,"comment_ctime":1608424974,"is_pvip":false,"replies":[{"id":"98870","content":"内核帮你做的轮询，和咱们在应用程序里面不断的通过系统调用拿到结果的轮询，不是一回事。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1610285713,"ip_address":"","comment_id":268904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903392270","product_id":100032701,"comment_content":"老师，IO多路复用不也是轮训么，并不是打电话通知来取书，还有IO多路复用不是解决多路复用问么，跟阻塞非阻塞没啥关系吧","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512075,"discussion_content":"内核帮你做的轮询，和咱们在应用程序里面不断的通过系统调用拿到结果的轮询，不是一回事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610285713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250885,"user_name":"kang","can_delete":false,"product_type":"c1","uid":1263025,"ip_address":"","ucode":"6796C8C5285E60","user_header":"https://static001.geekbang.org/account/avatar/00/13/45/b1/9f3b2b27.jpg","comment_is_top":false,"comment_ctime":1601271338,"is_pvip":false,"replies":[{"id":"92056","content":"好棒，加油~","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1601871315,"ip_address":"","comment_id":250885,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5896238634","product_id":100032701,"comment_content":"这两天正好卡在怎么获取完成对端数据这里，我自己实现了nread函数，保证在tcp协议下可以完整获取数据。但是，第一次读取可能无法全部读到，但是第二次再读取7是，会在nread中阻塞住。select失效，看了非阻塞+缓冲区的设计，豁然开朗","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506326,"discussion_content":"好棒，加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601871315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244443,"user_name":"fedwing","can_delete":false,"product_type":"c1","uid":1743661,"ip_address":"","ucode":"2DFF902FD190C7","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/2d/f7fca208.jpg","comment_is_top":false,"comment_ctime":1598519055,"is_pvip":false,"replies":[{"id":"90125","content":"如果有新的连接，accept是可以返回的；但是如果不是新的连接，而是有数据可读，是没有办法从accept返回的，这样就不可以对其他I&#47;O进行服务了。(原文表达的稍微有点问题，稍后修正 ）","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1598796155,"ip_address":"","comment_id":244443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5893486351","product_id":100032701,"comment_content":"由于客户端发生了 RST 分节，该连接被接收端内核从自己的已完成队列中删除了，此时再调用 accept，由于没有已完成连接（假设没有其他已完成连接），accept 一直阻塞，更为严重的是，该线程再也没有机会对其他 I&#47;O 事件进行分发，相当于该服务器无法对新连接和其他 I&#47;O 进行服务。<br>请问下，为什么该服务器无法对新的连接服务，如果这个套接字，来了新的连接，是不是accept函数就可以返回成功了","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504581,"discussion_content":"如果有新的连接，accept是可以返回的；但是如果不是新的连接，而是有数据可读，是没有办法从accept返回的，这样就不可以对其他I/O进行服务了。(原文表达的稍微有点问题，稍后修正 ）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598796155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237807,"user_name":"puladiao","can_delete":false,"product_type":"c1","uid":1103345,"ip_address":"","ucode":"5F67E8F4091880","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/f1/efd8769e.jpg","comment_is_top":false,"comment_ctime":1595979370,"is_pvip":false,"replies":[{"id":"89338","content":"这里说的是一个非常极端的场景，即在进入了监听套接字判断的代码分支下，同时客户端发生了 RST 分节，导致接下来的代码阻塞在&quot;accept&quot;调用下，注意这里是一个单线程程序，没有办法对其他I&#47;O事件进行服务。不过，是可以对&quot;其他的新连接&quot;进行服务的。这里还是需要描述得更为清晰一点。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1597585092,"ip_address":"","comment_id":237807,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5890946666","product_id":100032701,"comment_content":"accept 一直阻塞，更为严重的是，该线程再也没有机会对其他 I&#47;O 事件进行分发，相当于该服务器无法对新连接和其他 I&#47;O 进行服务。<br><br>这一段有点没明白。accept函数在阻塞模式下，应该是一直等待下一个可以accept的连接。为什么文中说“无法对新连接进行服务”呢？","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502549,"discussion_content":"这里说的是一个非常极端的场景，即在进入了监听套接字判断的代码分支下，同时客户端发生了 RST 分节，导致接下来的代码阻塞在&amp;quot;accept&amp;quot;调用下，注意这里是一个单线程程序，没有办法对其他I/O事件进行服务。不过，是可以对&amp;quot;其他的新连接&amp;quot;进行服务的。这里还是需要描述得更为清晰一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597585092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228021,"user_name":"云淡风轻","can_delete":false,"product_type":"c1","uid":1121817,"ip_address":"","ucode":"D6903A0FCEBC58","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/19/a235f31d.jpg","comment_is_top":false,"comment_ctime":1592537132,"is_pvip":false,"replies":[{"id":"84282","content":"是的，我抽空改下代码。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1592744553,"ip_address":"","comment_id":228021,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5887504428","product_id":100032701,"comment_content":"思考题一，133行的判断是个bug吧，如果fd = FD_INIT_SIZE ，走buffer 的分支，数组就越位了，所以判断应该是 fd &gt;= FD_INIT_SIZE。","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498892,"discussion_content":"是的，我抽空改下代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592744553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219209,"user_name":"rongyefeng","can_delete":false,"product_type":"c1","uid":1959482,"ip_address":"","ucode":"9A15D947E9D645","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e6/3a/382cf024.jpg","comment_is_top":false,"comment_ctime":1589966701,"is_pvip":false,"replies":[{"id":"80983","content":"这一段确实是很难跑到，仅仅做为一个异常条件吧。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1589977640,"ip_address":"","comment_id":219209,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884933997","product_id":100032701,"comment_content":"请问老师， <br>make_nonblocking(fd);   <br>if (buffer[fd]-&gt;connect_fd == 0)   <br> {   <br>      buffer[fd]-&gt;connect_fd = fd;   <br>}   else {     <br>     error(1, 0, &quot;too many connections&quot;);   <br>}<br>这里的&quot;too many connections&quot;会在什么情况下出现呢？","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495718,"discussion_content":"这一段确实是很难跑到，仅仅做为一个异常条件吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589977640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197721,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1585394903,"is_pvip":false,"replies":[{"id":"74758","content":"回复里有答的很好的，看回复也是学习哦。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1585484717,"ip_address":"","comment_id":197721,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5880362199","product_id":100032701,"comment_content":"第一个问题，判断最多放多少socker 的描述符，可以改为动态数组<br>第二个问题，不理解，是不是可以认为节省空间？","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489587,"discussion_content":"回复里有答的很好的，看回复也是学习哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585484717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1803259,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","nickname":"linker","note":"","ucode":"6C5799F2FC2C82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216771,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585484920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183245,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1582981613,"is_pvip":false,"replies":[{"id":"71023","content":"这个联想倒是非常的清奇。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1583051536,"ip_address":"","comment_id":183245,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877948909","product_id":100032701,"comment_content":"文中select+阻塞IO的模型造成的accept一直阻塞的现象，很像单例模式中需要判断两次instance == null的情景。","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485615,"discussion_content":"这个联想倒是非常的清奇。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583051536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141892,"user_name":"JasonZhi","can_delete":false,"product_type":"c1","uid":1282818,"ip_address":"","ucode":"6C23DCD592636D","user_header":"https://static001.geekbang.org/account/avatar/00/13/93/02/fcab58d1.jpg","comment_is_top":false,"comment_ctime":1571245940,"is_pvip":true,"replies":[{"id":"55114","content":"你是对的，我已经修正代码，等待编辑更新，感谢指正。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1571456259,"ip_address":"","comment_id":141892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866213236","product_id":100032701,"comment_content":"第一段代码的注释是否有误？EINTR应该属于中断导致的错误，如：信号中断，如果是非阻塞没有数据可读的情况下，应该返回错误EAGAIN","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470928,"discussion_content":"你是对的，我已经修正代码，等待编辑更新，感谢指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571456259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139881,"user_name":"Geek_d4f974","can_delete":false,"product_type":"c1","uid":1591783,"ip_address":"","ucode":"F91D0CD09CB13E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/NTSD503ibERiba4wcsoiaezDrjLMOVVlAlliagHc6ic3icWFfuzaFWaHwuULQDo22mPiabicImFTB7ial82OuBD96bl4RTQ/132","comment_is_top":false,"comment_ctime":1570759836,"is_pvip":false,"replies":[{"id":"55071","content":"还好吧，这里主要是说非阻塞I&#47;O的含义，以及对我们编写程序的帮助，多读一下，应该可以搞定的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1571451067,"ip_address":"","comment_id":139881,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865727132","product_id":100032701,"comment_content":"这章真的晦涩难懂啊","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470155,"discussion_content":"还好吧，这里主要是说非阻塞I/O的含义，以及对我们编写程序的帮助，多读一下，应该可以搞定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571451067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137473,"user_name":"刘立伟","can_delete":false,"product_type":"c1","uid":1337037,"ip_address":"","ucode":"620ED44DDFCC6F","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/cd/eb469d2e.jpg","comment_is_top":false,"comment_ctime":1569749213,"is_pvip":false,"replies":[{"id":"53859","content":"我是ubuntu 16.04 LTS版本，默认的pthread就可以支持了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570697343,"ip_address":"","comment_id":137473,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5864716509","product_id":100032701,"comment_content":"ubuntu18.04环境下编译整个工程失败．提示如下<br>CMakeFiles&#47;aio01.dir&#47;aio01.c.o: In function `main&#39;:<br>aio01.c:(.text+0x19b): undefined reference to `aio_write&#39;<br>aio01.c:(.text+0x1f4): undefined reference to `aio_error&#39;<br>aio01.c:(.text+0x208): undefined reference to `aio_error&#39;<br>aio01.c:(.text+0x21d): undefined reference to `aio_return&#39;<br>aio01.c:(.text+0x329): undefined reference to `aio_read&#39;<br>aio01.c:(.text+0x379): undefined reference to `aio_error&#39;<br>aio01.c:(.text+0x38d): undefined reference to `aio_return&#39;<br>collect2: error: ld returned 1 exit status<br>chap-30&#47;CMakeFiles&#47;aio01.dir&#47;build.make:95: recipe for target &#39;bin&#47;aio01&#39; failed<br><br>需要在在chapter-30 下的CMakeList.txt 中的target_link_libraries　增加 rt","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469114,"discussion_content":"我是ubuntu 16.04 LTS版本，默认的pthread就可以支持了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570697343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2889984,"avatar":"","nickname":"Geek_da4d45","note":"","ucode":"B6094DE0FBCD5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545189,"discussion_content":"怎么加的啊？我也遇到了这个问题，不知道怎么修改啊 : (","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641871329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137144,"user_name":"石将从","can_delete":false,"product_type":"c1","uid":1375617,"ip_address":"","ucode":"12F43E643D1D58","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/81/1864f266.jpg","comment_is_top":false,"comment_ctime":1569635336,"is_pvip":false,"replies":[{"id":"52779","content":"好的，我在github上的提交多加一些注释。<br><br>https:&#47;&#47;github.com&#47;froghui&#47;yolanda","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569723851,"ip_address":"","comment_id":137144,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5864602632","product_id":100032701,"comment_content":"老师代码能不能写多点注释呀？基础差的同学看得费劲","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468957,"discussion_content":"好的，我在github上的提交多加一些注释。\n\nhttps://github.com/froghui/yolanda","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569723851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1231713,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cb/61/b62d8a3b.jpg","nickname":"张立华","note":"","ucode":"173B938DD9478A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22847,"discussion_content":"https://github.com/froghui/yolanda/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569714524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360984,"user_name":"Geek_1696dd","can_delete":false,"product_type":"c1","uid":2948566,"ip_address":"江苏","ucode":"DEC1F02116F5F5","user_header":"","comment_is_top":false,"comment_ctime":1667056694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1667056694","product_id":100032701,"comment_content":"老师这个程序和UNP那个非阻塞IO+select多路复用思想类似的吧","like_count":0},{"had_liked":false,"id":360893,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"广东","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1666946447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666946447","product_id":100032701,"comment_content":"我比较疑惑，select本身就是阻塞的吧，那select返回结果说明可以read()，那为什么还需要用非阻塞的IO呢","like_count":0},{"had_liked":false,"id":339543,"user_name":"菜鸡互啄","can_delete":false,"product_type":"c1","uid":2765079,"ip_address":"","ucode":"59162B81398399","user_header":"https://static001.geekbang.org/account/avatar/00/2a/31/17/ab2c27a6.jpg","comment_is_top":false,"comment_ctime":1648178625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648178625","product_id":100032701,"comment_content":"打卡 温故知新 每次看都有收货。","like_count":0},{"had_liked":false,"id":339095,"user_name":"Info_E","can_delete":false,"product_type":"c1","uid":1755152,"ip_address":"","ucode":"97207B2CC4C776","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/VTPuhJb5xxuRwH1iblqrAe3De4PoETgNWibZRkLlhvszysdtpAvSPZFuYtsJfWJmoXOFFWnpR02W9NGIiammU8UPg/132","comment_is_top":false,"comment_ctime":1647915755,"is_pvip":false,"replies":[{"id":"124143","content":"本来select调用也一直是等待事件返回的。","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1648297763,"ip_address":"","comment_id":339095,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647915755","product_id":100032701,"comment_content":"select 函数代码里设置的是阻塞式的，没有fd事件就不会返回，121行是不是就一直阻塞了。<br>","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558434,"discussion_content":"本来select调用也一直是等待事件返回的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648297763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324363,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":2012725,"ip_address":"","ucode":"B68B6D2519D924","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b6/35/f6622b4f.jpg","comment_is_top":false,"comment_ctime":1638406449,"is_pvip":false,"replies":[{"id":"117836","content":"开一个byte数组，把read得到的数据装进去。后面该解析的解析。","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1638691666,"ip_address":"","comment_id":324363,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638406449","product_id":100032701,"comment_content":"老师我有个疑问。在非阻塞模式下，如果接受缓冲区有数据，调用read会立即返回，那么返回了应用程序怎么读数据呢？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536110,"discussion_content":"开一个byte数组，把read得到的数据装进去。后面该解析的解析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638691666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323716,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1638110641,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638110641","product_id":100032701,"comment_content":"第一个问题：说明程序的并发超过了之前的预估值，可以使用动态分配Buffer 的方式提高并发。<br>第二个问题：此处程序功能类似echo，把收到的数据逐字节的回给客户端。所以同一个客户端的读写用了一个Buffer。","like_count":0},{"had_liked":false,"id":322615,"user_name":"huadanian","can_delete":false,"product_type":"c1","uid":1014061,"ip_address":"","ucode":"A986E1DB777428","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/2d/dbb5570f.jpg","comment_is_top":false,"comment_ctime":1637501029,"is_pvip":false,"replies":[{"id":"117472","content":"onSocketRead正确返回，没有出错。","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1638089063,"ip_address":"","comment_id":322615,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637501029","product_id":100032701,"comment_content":"请问老师，第154行的r==0的判断条件的原因是什么？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534079,"discussion_content":"onSocketRead正确返回，没有出错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638089063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319400,"user_name":"Geek_70e534","can_delete":false,"product_type":"c1","uid":2826984,"ip_address":"","ucode":"10F17256E5E396","user_header":"","comment_is_top":false,"comment_ctime":1635777814,"is_pvip":false,"replies":[{"id":"116133","content":"朋友，你觉得怎么解释这件事情比较容易理解呢？<br>因为更多的是理解这两种编程模式的差异，举例子是一个比较好的方式。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1636272277,"ip_address":"","comment_id":319400,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635777814","product_id":100032701,"comment_content":"感觉这个例子挺迷的，主要是实验结果都没有对比，给个结果就完事了，完全看不出阻塞和非阻塞的区别。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529622,"discussion_content":"朋友，你觉得怎么解释这件事情比较容易理解呢？\n因为更多的是理解这两种编程模式的差异，举例子是一个比较好的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636272277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305871,"user_name":"熊猫","can_delete":false,"product_type":"c1","uid":1080238,"ip_address":"","ucode":"23C85117A16BEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/ae/66ae403d.jpg","comment_is_top":false,"comment_ctime":1628215226,"is_pvip":false,"replies":[{"id":"111679","content":"这里展示的是多路复用非阻塞情况，根据套接字的状况再决定后面的动作，原文里是监听套接字有事件发生，所以对此进行操作，即调用accept进行处理。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1629636871,"ip_address":"","comment_id":305871,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1628215226","product_id":100032701,"comment_content":"这里的休眠时间非常关键，这样，在监听套接字上有可读事件发生时，并没有马上调用 accept---盛老师，我们不是先accept，再读数据吗？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524544,"discussion_content":"这里展示的是多路复用非阻塞情况，根据套接字的状况再决定后面的动作，原文里是监听套接字有事件发生，所以对此进行操作，即调用accept进行处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629636871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1080238,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7b/ae/66ae403d.jpg","nickname":"熊猫","note":"","ucode":"23C85117A16BEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390071,"discussion_content":"谢谢盛老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629641471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289366,"user_name":"Geek5198","can_delete":false,"product_type":"c1","uid":2028945,"ip_address":"","ucode":"2BEBE6A39D9A0E","user_header":"","comment_is_top":false,"comment_ctime":1618989740,"is_pvip":false,"replies":[{"id":"105519","content":"不是完全一样，select设置成0的用法是比较少用的，不过从作用原理上确实是要应用程序自己轮询了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1620223564,"ip_address":"","comment_id":289366,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618989740","product_id":100032701,"comment_content":"老师，有个问题不明白，如果非阻塞IO不使用select的话，那就是应用程序自己轮询，使用select的话，应用程序等待select返回，如果说把select的参数timeout设置成0的话，是不是和应用程序自己轮询效果一样了？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518894,"discussion_content":"不是完全一样，select设置成0的用法是比较少用的，不过从作用原理上确实是要应用程序自己轮询了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620223564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287577,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1618036881,"is_pvip":false,"replies":[{"id":"104491","content":"不一定啊，如果我开了一个比较大的缓冲，一次性读取很多byte，这样就不会频频的系统调用了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1618140192,"ip_address":"","comment_id":287577,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618036881","product_id":100032701,"comment_content":"老师，请问一下，怎么理解您回复 HerofH 中的「减少系统调用的次数」。<br>这个系统底层调用次数能减少么？<br>假设本来需要调用 10 次 read，即使新增 buffer 之后，也还是需要调用 10 次 read 的吧？<br>但是可以减少 write 函数的调用次数。<br>谢谢","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518353,"discussion_content":"不一定啊，如果我开了一个比较大的缓冲，一次性读取很多byte，这样就不会频频的系统调用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618140192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283897,"user_name":"🐗Jinx","can_delete":false,"product_type":"c1","uid":1711790,"ip_address":"","ucode":"B5C084F54BF66A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/ae/a6d5e24a.jpg","comment_is_top":false,"comment_ctime":1615976356,"is_pvip":false,"replies":[{"id":"103191","content":"其实buffer里面有足够的空间放置数据，一般情况下通过往buffer里存读取的数据，之后马上消费掉这部分读取的数据，再往buffer里存放即将发送的数据，这样往返，实际上一个buffer对象就已经够用了。buffer对象里保存了指针告诉我们读、写的位置，所以不会混的。<br><br>后面的章节里会对buffer的设计展开讨论，你可以耐着性子往下读。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1616314670,"ip_address":"","comment_id":283897,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615976356","product_id":100032701,"comment_content":"老师，我始终不是很明白为什么每个链接，也就是每个 client_fd 只需要维护一个 buffer？服务端应该为每个链接维护两个 buffer啊，一个是 input buffer，也就是用于接收客户端数据；另一个是 output buffer，用于储存回复客户端的数据。<br><br>如果每个链接只有一个 buffer 的话，岂不是，接收的数据跟要发送的数据都混在一起了？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517174,"discussion_content":"其实buffer里面有足够的空间放置数据，一般情况下通过往buffer里存读取的数据，之后马上消费掉这部分读取的数据，再往buffer里存放即将发送的数据，这样往返，实际上一个buffer对象就已经够用了。buffer对象里保存了指针告诉我们读、写的位置，所以不会混的。\n\n后面的章节里会对buffer的设计展开讨论，你可以耐着性子往下读。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616314670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256877,"user_name":"doge","can_delete":false,"product_type":"c1","uid":1593251,"ip_address":"","ucode":"9E2D4C8F9B4CBC","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","comment_is_top":false,"comment_ctime":1603770886,"is_pvip":false,"replies":[{"id":"95503","content":"在主循环里每次应该需要对结果进行清零处理。FD_CLR是清除掉对应的文件描述符，感觉这里有点问题。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1606041542,"ip_address":"","comment_id":256877,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1603770886","product_id":100032701,"comment_content":"问一下老师，在主循环的部分，老师是通过检查fd数据重新set了一遍read fd set和write fd set，这个确实OK，但我用另一种方式备份设置好的fd set，然后当客户端异常的时候用FD_CLR清理掉set对应的fd，但是好像没有成功，我用错了FD_CLR吗？<br><br>fd_set readfd;<br>FD_SET(xx, &amp;readfd);<br>...<br>fd_set backup = readfd;<br><br>while (1) {<br>select(maxfd + 1, &amp;readfd, NULL, NULL, NULL);<br>&#47;&#47;处理accetpfd<br>连接成功FD_SET(成功, &amp;backup)<br>&#47;&#47;处理客户端<br>如果客户端异常FD_CLR(异常, &amp;backup)<br>我这里用hexdump打印了backup，发现异常的位并没有被置零，最后导致select不停报EBADF错误，请问老师是我理解错了吗？<br><br>&#47;&#47;客户端处理完毕<br>readfd = backup;<br>}","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508150,"discussion_content":"在主循环里每次应该需要对结果进行清零处理。FD_CLR是清除掉对应的文件描述符，感觉这里有点问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606041542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593251,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","nickname":"doge","note":"","ucode":"9E2D4C8F9B4CBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318624,"discussion_content":"问题解决了，是我调用FD_CLR的时机晚了。看样子还是按照老师的写法比较不容易出错些(´;︵;`)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603792549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231773,"user_name":"郑祖煌","can_delete":false,"product_type":"c1","uid":1469608,"ip_address":"","ucode":"49A0D2E3279826","user_header":"https://static001.geekbang.org/account/avatar/00/16/6c/a8/1922a0f5.jpg","comment_is_top":false,"comment_ctime":1593767515,"is_pvip":false,"replies":[{"id":"85733","content":"嗯，有利有弊吧。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1593954886,"ip_address":"","comment_id":231773,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593767515","product_id":100032701,"comment_content":"1. 那个是限制fd的个数，可以将Buffer由数组的存储方式修改为链表的方式，就是在Buffer后面加一个指针。但是这个做不方面的一点就是得逐个去遍历。 ","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500433,"discussion_content":"嗯，有利有弊吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593954886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231751,"user_name":"郑祖煌","can_delete":false,"product_type":"c1","uid":1469608,"ip_address":"","ucode":"49A0D2E3279826","user_header":"https://static001.geekbang.org/account/avatar/00/16/6c/a8/1922a0f5.jpg","comment_is_top":false,"comment_ctime":1593764851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593764851","product_id":100032701,"comment_content":"第一个是对同时在线连接的人数做了限制。如果超过了FD_INIT_SIZE就强制关闭该socket连接。可以通过动态数据去实现人数的动态分配。","like_count":0},{"had_liked":false,"id":225624,"user_name":"n3bul2","can_delete":false,"product_type":"c1","uid":1137426,"ip_address":"","ucode":"11EDFAB2EA2B5E","user_header":"https://static001.geekbang.org/account/avatar/00/11/5b/12/b9ec95e2.jpg","comment_is_top":false,"comment_ctime":1591801392,"is_pvip":false,"replies":[{"id":"84271","content":"结果是正确的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1592742243,"ip_address":"","comment_id":225624,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591801392","product_id":100032701,"comment_content":"老师，我先运行了服务器端，在运行客户端输入ip一回车就退出了，服务器端显示”listening socket readable“，这是正确的结果吗？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497917,"discussion_content":"结果是正确的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592742243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211545,"user_name":"Joy","can_delete":false,"product_type":"c1","uid":1589746,"ip_address":"","ucode":"54560FE6398945","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/f2/4843532d.jpg","comment_is_top":false,"comment_ctime":1587980997,"is_pvip":false,"replies":[{"id":"79178","content":"是的。这里onSocketRead&#47;onSocketWrite函数本身是在主线程里处理的，如果很慢确实会拖累其他事件的处理，这个时候我们可以使用线程来处理。后面讲到的reactor模式会把事件检测和数据处理分开用不同的线程处理，某种程度可以规避你说的问题。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1588497473,"ip_address":"","comment_id":211545,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587980997","product_id":100032701,"comment_content":"老师您好，请问如果onSocketRead&#47;onSocketWrite函数里的处理时间较长会影响select所在while的循环处理或者说会影响其他事件的处理吗？谢谢！","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493291,"discussion_content":"是的。这里onSocketRead/onSocketWrite函数本身是在主线程里处理的，如果很慢确实会拖累其他事件的处理，这个时候我们可以使用线程来处理。后面讲到的reactor模式会把事件检测和数据处理分开用不同的线程处理，某种程度可以规避你说的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588497473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208665,"user_name":"智强","can_delete":false,"product_type":"c1","uid":1275287,"ip_address":"","ucode":"C5D8813FCB46E7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5lDDMYy9zfQGQAGPL5icH82BuP8J9loZKSqRffr80eyV5AhGS9LyMeWDmSOXl2iaIoK7qONlwpD4A/132","comment_is_top":false,"comment_ctime":1587397002,"is_pvip":false,"replies":[{"id":"78414","content":"不是哦，这里的下标表示的是数组Buffer里的元素，每个Buffer对象里面的connct_fd才是socket fd。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1587804248,"ip_address":"","comment_id":208665,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587397002","product_id":100032701,"comment_content":"不知道现在还能看到不。<br>146行开始对 fd_set 循环处理时，是否从 i = 3 开始比较好？<br>我的理解是 0，1，2三个 fd 不会对应 socket。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492568,"discussion_content":"不是哦，这里的下标表示的是数组Buffer里的元素，每个Buffer对象里面的connct_fd才是socket fd。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587804248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207755,"user_name":"heyman","can_delete":false,"product_type":"c1","uid":1173894,"ip_address":"","ucode":"92EF9EF1B1B1B3","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/86/d34800a4.jpg","comment_is_top":false,"comment_ctime":1587174792,"is_pvip":false,"replies":[{"id":"77719","content":"connect有连接超时设置。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1587304382,"ip_address":"","comment_id":207755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587174792","product_id":100032701,"comment_content":"”这里的休眠时间非常关键，这样，在监听套接字上有可读事件发生时，并没有马上调用 accept。由于客户端发生了 RST 分节，该连接被接收端内核从自己的已完成队列中删除了，此时再调用 accept，由于没有已完成连接（假设没有其他已完成连接），accept 一直阻塞“。请教一下，为什么客户端会发生RST分节？服务端还没有accept的话，客户端的connect不是应该阻塞吗？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492232,"discussion_content":"connect有连接超时设置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587304382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205353,"user_name":"你好","can_delete":false,"product_type":"c1","uid":1252980,"ip_address":"","ucode":"0B5E024BA58560","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/74/636ea0f3.jpg","comment_is_top":false,"comment_ctime":1586597033,"is_pvip":false,"replies":[{"id":"76803","content":":)","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1586681203,"ip_address":"","comment_id":205353,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586597033","product_id":100032701,"comment_content":"emmm，我有点懵了","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491457,"discussion_content":":)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586681203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205163,"user_name":"Geek_wannaBgeek","can_delete":false,"product_type":"c1","uid":1643435,"ip_address":"","ucode":"6F42F4181981C3","user_header":"https://static001.geekbang.org/account/avatar/00/19/13/ab/d73e25de.jpg","comment_is_top":false,"comment_ctime":1586562426,"is_pvip":false,"replies":[{"id":"76802","content":"信号驱动I&#47;O这个太空，Linux也没有实际的API支持，我理解你是想说AIO，当实际上, AIO是要帮我们把书给搬回家的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1586681189,"ip_address":"","comment_id":205163,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1586562426","product_id":100032701,"comment_content":"老师我想请问一下，这段“但轮询的效率太低了，于是你向老板提议：“老板，到货给我打电话吧，我再来付钱取书。”这就是前面讲到的 I&#47;O 多路复用。”感觉和信号驱动io有点像呢？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491411,"discussion_content":"信号驱动I/O这个太空，Linux也没有实际的API支持，我理解你是想说AIO，当实际上, AIO是要帮我们把书给搬回家的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586681189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1643435,"avatar":"https://static001.geekbang.org/account/avatar/00/19/13/ab/d73e25de.jpg","nickname":"Geek_wannaBgeek","note":"","ucode":"6F42F4181981C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234363,"discussion_content":"aio这个是内核负责拷贝倒是知道，一开始没有get到书店老板是select之类的角色，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586963468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169411,"user_name":"javaYJL","can_delete":false,"product_type":"c1","uid":1188249,"ip_address":"","ucode":"E326EB9AFDCE32","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/99/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1578329536,"is_pvip":false,"replies":[{"id":"68077","content":"从系统调用角度来说是的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1580631338,"ip_address":"","comment_id":169411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578329536","product_id":100032701,"comment_content":"老师，客户端发起connect连接。是不是要服务端完成acceptor接入处理，这个tcp连接才算是成功的？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480545,"discussion_content":"从系统调用角度来说是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580631338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168611,"user_name":"不诉离殇","can_delete":false,"product_type":"c1","uid":1239350,"ip_address":"","ucode":"4F7BB1220ECED7","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/36/f62471c5.jpg","comment_is_top":false,"comment_ctime":1578122665,"is_pvip":false,"replies":[{"id":"65473","content":"非阻塞I&#47;O的好处你已经说到了，就是可以直接返回，不会像阻塞I&#47;O一样一直阻塞。确实，如果是I&#47;O多路复用，看上去阻塞I&#47;O也是可以的，但是它有一个问题，就是容易阻塞，导致线程没耗死。你可以这么简单的理解，本来我们使用非阻塞I&#47;O需要自己不断的轮询，现在操作系统帮我代劳了，可以通过事件来通知我们，这样非阻塞I&#47;O+多路复用就成为了网络编程的一个标准技术了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1578213084,"ip_address":"","comment_id":168611,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578122665","product_id":100032701,"comment_content":"老师好，我有一个疑问，在使用io复用的情况下，既然内核通知套接口可读，那么这个时候read应该不会阻塞，直接就能返回，那么在io复用情况下，将套接字设置为非阻塞的对read操作有什么意义？非阻塞情况下如果没有数据还需要轮询，消耗cpu，还不如阻塞io？对于readn操作，如果读取的字节数不(假设有一个恶意的客户端，发了一部分数据就不发了），那么阻塞io的read就会一直阻塞（可以加timeout）？非阻塞io会一直轮询？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480269,"discussion_content":"非阻塞I/O的好处你已经说到了，就是可以直接返回，不会像阻塞I/O一样一直阻塞。确实，如果是I/O多路复用，看上去阻塞I/O也是可以的，但是它有一个问题，就是容易阻塞，导致线程没耗死。你可以这么简单的理解，本来我们使用非阻塞I/O需要自己不断的轮询，现在操作系统帮我代劳了，可以通过事件来通知我们，这样非阻塞I/O+多路复用就成为了网络编程的一个标准技术了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578213084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168369,"user_name":"学怪","can_delete":false,"product_type":"c1","uid":1723983,"ip_address":"","ucode":"FE40B40460B0C7","user_header":"https://static001.geekbang.org/account/avatar/00/1a/4e/4f/b0b24789.jpg","comment_is_top":false,"comment_ctime":1578056620,"is_pvip":false,"replies":[{"id":"65475","content":"你的错误是什么，我确定所有的程序都是可以编译、链接，并最后以可执行程序的方式运行的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1578213129,"ip_address":"","comment_id":168369,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578056620","product_id":100032701,"comment_content":"老师，这个贴出来的代码确定没有问题吗？我自己敲的和GitHub上下载下来的代码都跑不通呢","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480203,"discussion_content":"你的错误是什么，我确定所有的程序都是可以编译、链接，并最后以可执行程序的方式运行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578213129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163090,"user_name":"zhang","can_delete":false,"product_type":"c1","uid":1256330,"ip_address":"","ucode":"BFA19BED5A5322","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIRm3kWsgiaEXjO0rr0Aiav7o89StFTFSXbLTkEmiaibmnw8EQTejibrtzKla0emibePT0R0KXjFRIpfXrQ/132","comment_is_top":false,"comment_ctime":1576655052,"is_pvip":false,"replies":[{"id":"63908","content":"不能这么干。应该是这样，建立一个管道(pipe)，然第一个线程同时select这个管道的可读事件，第二个线程往这个管道发送一个字符，这样第一个线程就自然可以苏醒过来了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1577604479,"ip_address":"","comment_id":163090,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576655052","product_id":100032701,"comment_content":"如果是多线程的，一个线程select(max_fd+1, &amp;read_fds, &amp;write_fds, NULL, NULL)，另一个线程想要唤醒第一个线程的select的write_fds，如何做？我试验第二个线程调用第一个线程对象的FD_ZERO(&amp;write_fds);FD_SET(client.sd, &amp;write_fds);，但并没有唤醒select？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478244,"discussion_content":"不能这么干。应该是这样，建立一个管道(pipe)，然第一个线程同时select这个管道的可读事件，第二个线程往这个管道发送一个字符，这样第一个线程就自然可以苏醒过来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577604479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256330,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIRm3kWsgiaEXjO0rr0Aiav7o89StFTFSXbLTkEmiaibmnw8EQTejibrtzKla0emibePT0R0KXjFRIpfXrQ/132","nickname":"zhang","note":"","ucode":"BFA19BED5A5322","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87496,"discussion_content":"是否可以用eventfd来做，创建的wake_fd添加到select的readfds中。第二个线程写入buffer后，write这个wake_fd，这样第一个线程select就会被readfds的wake_fd事件唤醒，之后接着检查有writefds事件就从buffer取出数据发送。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576670852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154842,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1574578415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574578415","product_id":100032701,"comment_content":"非阻塞 I&#47;O 可以被用到读操作、写操作、接收连接操作和发起连接操作上。<br>非阻塞是相对于阻塞而言的，阻塞简单讲就是应用程序让内核做某一件事，内核需要点时间做，应用程序在内核做事的这段时间里啥也不干就干等着，直到内核把这件事干完，然后告诉应用程序结果，应用程序才接着干别的事情。<br>非阻塞的关键点是，不干等着了，在内核做事的那个时间段内，继续干自己能的事，等内核干完了应用程序交给它干的事，把结果返给应用程序时，应用程序则再继续干拿到结果之后应干的事。","like_count":0},{"had_liked":false,"id":153976,"user_name":"herongwei","can_delete":false,"product_type":"c1","uid":1153928,"ip_address":"","ucode":"E4158BF7AD2E70","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/88/34c171f1.jpg","comment_is_top":false,"comment_ctime":1574339638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574339638","product_id":100032701,"comment_content":"这一章需要反复阅读和理解","like_count":0},{"had_liked":false,"id":152738,"user_name":"zmysang","can_delete":false,"product_type":"c1","uid":1642663,"ip_address":"","ucode":"8A98057E7819DD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/tjhOILHBAmlx6YiaTZJzqzxn1uyB6XpdvGDIZhBn127TYEcoLLzxRiaKvtVd3HllQqPx7cqf2YmibyBUgGGGJPDkw/132","comment_is_top":false,"comment_ctime":1574072315,"is_pvip":false,"replies":[{"id":"59326","content":"可以这么理解。当然，接收缓冲去可读的大小，和发送缓冲区可写的大小都是可以通过内核参数动态配置。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1574497982,"ip_address":"","comment_id":152738,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574072315","product_id":100032701,"comment_content":"请问老师，我理解select函数是，如果readset中的fd的接收缓冲区不为空，就是可读的，如果writeset中的fd的发送缓冲区没有满就是可写的是吗？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474921,"discussion_content":"可以这么理解。当然，接收缓冲去可读的大小，和发送缓冲区可写的大小都是可以通过内核参数动态配置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574497982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138882,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1570498331,"is_pvip":false,"replies":[{"id":"54313","content":"这个例子就是说明一下监听套接字需要设置为非阻塞的，结果不重要了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570972148,"ip_address":"","comment_id":138882,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570498331","product_id":100032701,"comment_content":"有连接上来的时候sleep5秒那个例子中 我这边没有永久阻塞 反而是 .&#47;server: accept failed: Invalid argument","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469684,"discussion_content":"这个例子就是说明一下监听套接字需要设置为非阻塞的，结果不重要了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570972148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137544,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1569771406,"is_pvip":false,"replies":[{"id":"53862","content":"对，是指close掉两个方向的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570697521,"ip_address":"","comment_id":137544,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569771406","product_id":100032701,"comment_content":"文中说“对方主动关闭套接字，阻塞write调用会立即返回实际字节数，如果再次write，则返回失败”，这是的“关闭”只指两个方向关闭吗？如果对方只是半关闭的话，理论上本机还是可以继续write的吧","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469144,"discussion_content":"对，是指close掉两个方向的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570697521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136915,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1569552882,"is_pvip":false,"replies":[{"id":"52782","content":"如果有多个\\n，这里也认为客户端结束了，只不过\\n会发送给客户端。<br><br>可以加一个处理，如果读到\\n，就不要再继续读下去了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569724590,"ip_address":"","comment_id":136915,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569552882","product_id":100032701,"comment_content":"感觉 readable 这个标记的处理有点小问题，没太考虑多个 \\n 的情况","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468861,"discussion_content":"如果有多个\\n，这里也认为客户端结束了，只不过\\n会发送给客户端。\n\n可以加一个处理，如果读到\\n，就不要再继续读下去了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569724590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136878,"user_name":"程序水果宝","can_delete":false,"product_type":"c1","uid":1371633,"ip_address":"","ucode":"1700DDFE073A56","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132","comment_is_top":false,"comment_ctime":1569546827,"is_pvip":false,"replies":[{"id":"52785","content":" 代码都在:https:&#47;&#47;github.com&#47;froghui&#47;yolanda<br><br>这里贴一段：<br>    int listenfd;<br>    listenfd = socket(AF_INET, SOCK_STREAM, 0);<br>    fcntl(listenfd, F_SETFL, O_NONBLOCK);","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569724826,"ip_address":"","comment_id":136878,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1569546827","product_id":100032701,"comment_content":"应该把函数tcp_nonblocking_server_listen(SERV_PORT)的实现代码也给出来的，不然新手可能不知道怎么select 就变成了非阻塞了","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468839,"discussion_content":" 代码都在:https://github.com/froghui/yolanda\n\n这里贴一段：\n    int listenfd;\n    listenfd = socket(AF_INET, SOCK_STREAM, 0);\n    fcntl(listenfd, F_SETFL, O_NONBLOCK);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569724826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182631,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","nickname":"Keep-Moving","note":"","ucode":"76F33C06E07A27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21937,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569554676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1528536,"avatar":"https://static001.geekbang.org/account/avatar/00/17/52/d8/123a4981.jpg","nickname":"绿箭侠","note":"","ucode":"B994F558A98E29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182631,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","nickname":"Keep-Moving","note":"","ucode":"76F33C06E07A27","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189670,"discussion_content":"select(maxfd + 1, &amp;readset, &amp;writeset, &amp;exset, NULL) 此处当然会阻塞，没明白怎么说select非阻塞？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582896976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21937,"ip_address":""},"score":189670,"extra":""},{"author":{"id":2776006,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er5SNsSoiaZw4Qzd2ctH4vtibHQordcLrYsX43oFZFloRTId0op617mcGlrvGx33U8ic2LTgdicoEFPvQ/132","nickname":"Frankey","note":"","ucode":"2F09BC2500C9E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1528536,"avatar":"https://static001.geekbang.org/account/avatar/00/17/52/d8/123a4981.jpg","nickname":"绿箭侠","note":"","ucode":"B994F558A98E29","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569280,"discussion_content":"因为程序fcntl(listenfd, F_SETFL, O_NONBLOCK);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651392854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":189670,"ip_address":""},"score":569280,"extra":""}]}]}]}