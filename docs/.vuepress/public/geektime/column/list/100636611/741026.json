{"id":741026,"title":"第 4 章 Linux文件和目录管理","content":"\n<p>从这一章开始，阿铭介绍的命令会越来越多，希望你能够反复练习每一个命令的每一个选项。在Windows下，新建、复制、删除文件或者文件夹都非常简单，但Linux需要我们使用命令行进行操作。这样便增加了学习Linux系统的难度，不过不用担心，一旦能够熟练使用它们，那你将永远也不会忘记。万事开头难，所以请大家努力吧！</p>\n<h2 id=\"nav_point_54\">4.1 绝对路径和相对路径</h2>\n<p>在Linux中，什么是一个文件的路径呢？简单地说，就是这个文件存放的地方，例如在上一章提到的 /root/.ssh/authorized_keys就是一个文件的路径。只要你告诉系统某个文件的路径，系统就可以找到这个文件。</p>\n<p>在Linux中，存在着绝对路径和相对路径。</p>\n<ul>\n<li><strong>绝对路径</strong>：路径的写法一定是由根目录/写起的，例如 /usr/local/mysql。</li>\n<li><p><strong>相对路径</strong>：路径的写法不是由根目录/写起的。例如，要使用户首先进入到 /home目录，然后再进入到test目录，需执行的命令为：</p>\n<pre class=\"code-rows\"><code># cd /home\n# cd test</code></pre>\n<p>此时用户所在的路径为 /home/test。第一个<code>cd</code>命令后紧跟/home，home前面有斜杠；而第二个<code>cd</code>命令后紧跟test，test前面没有斜杠。这个test是相对于/home目录来讲的，所以称为相对路径。</p>\n</li>\n</ul>\n<h3 id=\"nav_point_55\">4.1.1 命令<code>cd</code></h3>\n<p>命令<code>cd</code>（change directory的简写）是用来变更用户所在目录的，如果该命令后面什么都不跟，就会直接进入当前用户的根目录下。我们做实验用的是root账户，所以运行命令<code>cd</code>后，会进入root账户的根目录/root下。如果<code>cd</code>后面跟目录名，则会直接切换到指定目录下。示例命令如下：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code># cd /tmp/\n# pwd\n/tmp\n# cd\n# pwd\n/root</code></pre>\n<p>上例中，命令<code>pwd</code>用于显示当前所在目录。命令<code>cd</code>后面只能是目录名，如果跟了文件名，则会报错，例如：</p>\n<pre class=\"code-rows\"><code># cd /etc/passwd\n-bash: cd: /etc/passwd: 不是目录</code></pre>\n<p>因为/etc/passwd为一个文件名，所以就报错了。在Linux文件系统中，有两个特殊的符号也可以表示目录。“<code>.</code>”表示当前目录，“<code>..</code>”表示当前目录的上一级目录，示例命令如下：</p>\n<pre class=\"code-rows\"><code># cd /usr/local/lib/\n# pwd\n/usr/local/lib\n# cd .\n# pwd\n/usr/local/lib\n# cd ..\n# pwd\n/usr/local</code></pre>\n<p>上例中，首先进入 /usr/local/lib/ 目录，接着输入“<code>.</code>”，用命令<code>pwd</code>查看当前目录，还是在 /usr/local/lib/目录下，然后输入“<code>..</code>”，则进入 /usr/local/ 目录（即 /usr/local/lib目录的上一级目录）。</p>\n<h3 id=\"nav_point_56\">4.1.2 命令<code>mkdir</code></h3>\n<p>命令<code>mkdir</code>（make directory的简写）用于创建目录，这个命令在上一章中用过。该命令的格式为：<code>mkdir [-mp] [目录名称]</code>。其中，<code>-m</code>、<code>-p</code>为其选项。<code>-m</code>选项用于指定要创建目录的权限（这个选项不常用，阿铭不作重点解释）。<code>-p</code>选项很管用，我们做个试验，你就一目了然了。执行如下命令：</p>\n<pre class=\"code-rows\"><code># mkdir /tmp/test/123\nmkdir: 无法创建目录 '/tmp/test/123': 没有那个文件或目录\n# mkdir -p /tmp/test/123\n# ls /tmp/test\n123</code></pre>\n<p>当我们创建目录 /tmp/test/123时，会提示无法创建、/tmp/test目录不存在。在Linux中，如果它发现要创建的目录的上一级目录不存在，就会报错。为了解决这个问题，Linux设置了<code>-p</code>选项，这个选项可以帮我们创建一大串级联目录，并且当创建一个已经存在的目录时，不会报错。示例命令如下：</p>\n<pre class=\"code-rows\"><code># ls -ld /tmp/test/123\ndrwxr-xr-x 2 root root 6 12月 30 07:25 /tmp/test/123\n# mkdir /tmp/test/123\nmkdir: 无法创建目录 '/tmp/test/123': 文件已存在\n# mkdir -p /tmp/test/123\n# ls -ld /tmp/test/123\ndrwxr-xr-x 2 root root 6 12月 30 07:25 /tmp/test/123</code></pre>\n<p>在上一章中阿铭已经介绍过<code>ls</code>命令，但并没有介绍它的<code>-d</code>选项。这个选项是针对目录的，通常都是和<code>-l</code>并用，写成<code>-ld</code>。它可以查看指定目录的属性，比如在本例中，它可以查看 /tmp/test/123目录的创建时间，如果不加<code>-d</code>，则会显示该目录里面的文件和子目录的属性。</p>\n<h3 id=\"nav_point_57\">4.1.3 命令<code>rmdir</code></h3>\n<p>命令<code>rmdir</code>（remove directory的简写）用于删除空目录，后面可以是一个目录，也可以是多个目录（用空格分隔）。但该命令只能删除目录，不能删除文件，所以阿铭一般不用它，而改用命令<code>rm</code>（remove的简写），这个命令不仅可以删除目录，还可以删除文件，将在4.1.4节中介绍。<code>rmdir</code>和<code>mkdir</code>具有相同的选项<code>-p</code>，它同样可以级联删除一大串目录，但在级联的目录中，如果某一个目录里还有目录或者文件，那这个命令就不好用了。我们先来看看命令<code>rmdir</code>的用法，示例命令如下：</p>\n<pre class=\"code-rows\"><code># ls /tmp/test\n123\n# rmdir /tmp/test/\nrmdir: 删除 '/tmp/test/' 失败: 目录非空\n# rmdir /tmp/test/123\n# ls /tmp/test\n#</code></pre>\n<p>在上例中，命令<code>rmdir</code>只能删除空目录，即使加上<code>-p</code>选项也只能删除一串空目录。可见，这个命令有很大的局限性，偶尔用一下还可以。</p>\n<h3 id=\"nav_point_58\">4.1.4 命令<code>rm</code></h3>\n<p>命令<code>rm</code>是最常用的，它也有很多选项。你可以通过命令<code>man rm</code>来获得它的详细帮助信息。这里，阿铭只介绍最常用的两个选项。</p>\n<ul>\n<li><p><code>-r</code>：删除目录用的选项，类似于<code>rmdir</code>，但可以删除非空目录。下面阿铭先创建一连串的目录，然后尝试删除它们。示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir -p /tmp/test/123\n# rm -r /tmp/test/123\nrm:是否删除目录 '/tmp/test/123'? y</code></pre>\n<p>和<code>rmdir</code>不同的是，在使用<code>rm –r</code>命令删除目录时，会询问是否删除，如果输入<code>y</code>，则会删除，如果输入<code>n</code>，则不删除。</p>\n</li>\n<li><p><code>-f</code>：表示强制删除。它不会询问是否删除，而是直接删除。即使后面跟一个不存在的文件或者目录，也不会报错。下面阿铭尝试删除一个不存在的目录，示例命令如下：</p>\n<pre class=\"code-rows\"><code># rm /tmp/test/123/123\nrm: 无法删除 '/tmp/test/123/123': 没有那个文件或目录\n# rm -f /tmp/test/123/123</code></pre>\n<p>上例中，由于 /tmp/test/123/123这个目录是不存在的，因此直接运行<code>rm</code>命令后会报错，加上<code>-f</code>选项后，就不会了。但如果要删除一个存在的目录，即使加上<code>-f</code>选项也会报错。所以，使用命令<code>rm</code>删除目录时，一定要加<code>-r</code>选项。请对比下面的示例命令和上面的示例命令，发现两者的区别：</p>\n<pre class=\"code-rows\"><code># rm -f /tmp/test/123\nrm: 无法删除 '/tmp/test/123': 是一个目录\n# rm -rf /tmp/test/123</code></pre>\n</li>\n</ul>\n<p>关于<code>rm</code>命令，阿铭使用最多的是<code>-rf</code>选项，这样删除文件或目录比较方便。但请大家千万要注意，<code>rm -rf</code>命令后面不能加<code>/</code>，因为它会把你的系统文件全部删除，这是非常危险的！</p>\n<h2 id=\"nav_point_59\">4.2 环境变量<code>PATH</code></h2>\n<p>在讲环境变量之前，阿铭先介绍一下命令<code>which</code>，它用于查找某个命令的绝对路径。示例命令如下：</p>\n<pre class=\"code-rows\"><code># which rmdir\n/usr/bin/rmdir\n# which rm\nalias rm='rm -i'\n /usr/bin/rm\n# which ls\nalias ls='ls --color=auto'\n /usr/bin/ls</code></pre>\n<p>其中<code>rm</code>和<code>ls</code>是两个特殊的命令，因为使用<code>alias</code>命令做了别名，所以我们用的<code>rm</code>实际上是<code>rm -i</code>，加上<code>-i</code>选项后，删除文件或者命令时都会询问是否确定要删除，这样做比较安全。命令<code>alias</code>可以设置命令或文件的别名，阿铭会在10.1.3节中详细介绍该命令。阿铭并不常使用命令<code>which</code>，平时只用它来查询某个命令的绝对路径。</p>\n<p>在上面的示例中，用<code>which</code>命令查到<code>rm</code>命令的绝对路径为 /usr/bin/rm。那么你是否会问：“为什么我们使用命令时，只是直接打出了命令，而没有使用这些命令的绝对路径呢？”这是环境变量<code>PATH</code>在起作用。请输入如下命令：</p>\n<pre class=\"code-rows\"><code># echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre>\n<p>这里的<code>echo</code>命令用来打印<code>$PATH</code>的值。<code>PATH</code>前面的<code>$</code>是变量的前缀符号，这些知识点将会在第10章中详细介绍。</p>\n<p>因为 /bin目录存在于<code>PATH</code>的设定中，所以自然可以找到<code>ls</code>。但值得注意的是，由于<code>PATH</code>里并没有/root目录，因此如果你将<code>ls</code>移到 /root目录下，那么再执行<code>ls</code>命令时，系统自然就找不到可执行文件了，它会提示command not found!。示例命令如下：</p>\n<pre class=\"code-rows\"><code># mv /usr/bin/ls /root/\n# ls\n-bash: /usr/bin/ls: 没有那个文件或目录</code></pre>\n<p>命令<code>mv</code>（move的简写）用于移动目录或者文件，它还有重命名的作用（这个将在4.2.2节中介绍）。那么，该如何解决上面的这种问题呢？有两种方法，一种方法是直接将 /root这个路径加入到<code>$PATH</code>当中，命令如下：</p>\n<pre class=\"code-rows\"><code># PATH=$PATH:/root\n# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root\n# ls\nanaconda-ks.cfg ls</code></pre>\n<p>另一种方法是使用绝对路径，命令如下：</p>\n<pre class=\"code-rows\"><code># /root/ls\nanaconda-ks.cfg ls</code></pre>\n<p>为了不影响系统使用，建议将ls文件还原，命令如下：</p>\n<pre class=\"code-rows\"><code># mv /root/ls /usr/bin/</code></pre>\n<h3 id=\"nav_point_60\">4.2.1 命令<code>cp</code></h3>\n<p><code>cp</code>是copy（即复制）的简写，该命令的格式为：<code>cp [选项] [ 来源文件 ] [目的文件]</code>。例如，若想把test1文件复制成test2文件，则可以写为<code>cp test1 test2</code>。下面介绍命令<code>cp</code>的几个常用选项。</p>\n<ul>\n<li><p><code>-r</code>：如果要复制一个目录，必须加<code>-r</code>选项，否则不能复制，这类似于<code>rm</code>命令。示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir 123\n# cp 123 456\ncp: 略过目录\"123\"\n# cp -r 123 456\n# ls –ld 123 456\ndrwxr-xr-x 2 root root 6 12月 30 07:35 123\ndrwxr-xr-x 2 root root 6 12月 30 07:36 456</code></pre>\n</li>\n<li><p><code>-i</code>：这是安全选项，当遇到一个目的文件名已存在的文件时，会询问是否覆盖，这也与<code>rm</code>命令类似。在Red Hat/CentOS系统中，使用的<code>cp</code>命令其实是<code>cp –i</code>，我们可以通过<code>which</code>命令查看，具体如下：</p>\n<pre class=\"code-rows\"><code># which cp\nalias cp='cp -i'\n /bin/cp</code></pre>\n<p>为了更形象地说明<code>-i</code>选项的作用，我们来做一个简单的小试验，命令如下：</p>\n<pre class=\"code-rows\"><code># cd 123\n# ls\n# touch 111\n# touch 222\n# cp -i 111 222\ncp：是否覆盖 '222'？ n\n# echo 'abc' &gt; 111\n# echo 'def' &gt; 222\n# cat 111 222\nabc\ndef\n# /bin/cp 111 222\n# cat 111\nabc\n# cat 222\nabc</code></pre>\n<p>上例中的<code>touch</code>可以解释为：如果有这个文件，则改变该文件的访问时间；如果没有这个文件，就创建这个文件。<code>echo</code>命令用于打印，但这里打印的内容<code>abc</code>和<code>def</code>并没有显示在屏幕上，而是分别写入了文件“111”和“222”。其中起写入作用的就是符号“<code>&gt;</code>”，这在Linux中叫作重定向，即把前面产生的输出写入到后面的文件中。<code>cat</code>命令则用于读取一个文件，并把读出的内容打印到当前屏幕上。（重定向将在第10章中介绍，<code>cat</code>命令将在4.3.1节中详细介绍，这里你只要明白它们的含义即可。）</p>\n</li>\n</ul>\n<h3 id=\"nav_point_61\">4.2.2 命令<code>mv</code></h3>\n<p><code>mv</code>是move（移动）的简写，该命令的格式为：<code>mv [ 选项 ] [源文件或目录] [目标文件或目录]</code>。该命令有如下几种情况。</p>\n<ul>\n<li>目标文件是目录，但该目录不存在。</li>\n<li>目标文件是目录，且该目录存在。</li>\n<li>目标文件是文件，且该文件不存在。</li>\n<li>目标文件是文件，但该文件存在。</li>\n</ul>\n<p>当目标文件是目录时，在其存在与不存在的两种情况下，执行<code>mv</code>命令后的结果是不一样的。如果该目录存在，则会把源文件或目录移动到该目录中。如果该目录不存在，则会把源目录重命名为给定的目标文件名。</p>\n<p>当目标文件是文件时，在其存在与不存在的两种情况下，执行<code>mv</code>命令后的结果也是不一样的。如果该文件存在，则会询问是否覆盖。如果该文件不存在，则会把源文件重命名为给定的目标文件名。</p>\n<p>下面我们来做几个小试验，示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir /tmp/test_mv\n# cd /tmp/test_mv\n# mkdir dira dirb\n# ls\ndira dirb\n# mv dira dirc\n# ls\ndirb dirc</code></pre>\n<p>上例中，阿铭首先创建了一个实验用的目录/tmp/test_mv，然后进入到该目录下进行实验，这样做的目的是保持目录和文件的简洁，后面的实验以此类推。在这里，<code>mv</code>命令的目标文件是目录dirc，并且该目录不存在，因此就把目录dira重命名为dirc。</p>\n<p>下例中，目标文件是目录dirb，且dirb存在，因此会把目录dirc移动到目录dirb里：</p>\n<pre class=\"code-rows\"><code># mv dirc dirb\n# ls\ndirb\n# ls dirb\ndirc</code></pre>\n<p>下例中，<code>mv</code>命令的目标文件是文件filee且这个文件不存在，因此把文件filed重命名为filee。<code>mv filee dirb</code>命令则将更名后的文件filee移动到目录dirb里：</p>\n<pre class=\"code-rows\"><code># touch filed\n# ls\ndirb filed\n# mv filed filee\n# ls\ndirb filee\n# mv filee dirb\n# ls\ndirb\n# ls dirb\ndirc filee</code></pre>\n<h2 id=\"nav_point_62\">4.3 几个与文档相关的命令</h2>\n<p>上面介绍的几个命令几乎都是与目录相关的，下面阿铭继续介绍几个与文档相关的命令。</p>\n<h3 id=\"nav_point_63\">4.3.1 命令<code>cat</code></h3>\n<p>命令<code>cat</code>（这并不是某个单词的简写，大家可以通过<code>man cat</code>命令查看它的解释）是比较常用的一个命令，用于查看一个文件的内容并将其显示在屏幕上。<code>cat</code>后面可以不加任何选项，直接跟文件名。下面阿铭将介绍它的两个常用选项。</p>\n<ul>\n<li><p><strong><code>-n</code></strong>：查看文件时，把行号也显示到屏幕上。示例命令如下（当前目录依然在 /tmp/test_mv）：</p>\n<pre class=\"code-rows\"><code># echo '111111111' &gt; dirb/filee\n# echo '222222222' &gt;&gt; dirb/filee\n# cat dirb/filee\n111111111\n222222222\n# cat -n dirb/filee\n 1 111111111\n 2 222222222</code></pre>\n<p>上例中出现了符号<code>&gt;&gt;</code>，它跟前面介绍的符号<code>&gt;</code>类似，作用也是重定向，即把前面的内容输入到后面的文件中，但符号<code>&gt;&gt;</code>是“追加”的意思。当使用符号<code>&gt;</code>时，如果文件中有内容，则会删除文件中原有的内容，而使用符号<code>&gt;&gt;</code>则不会。</p>\n</li>\n<li><p><strong><code>-A</code></strong>：显示所有的内容，包括特殊字符。示例命令如下：</p>\n<pre class=\"code-rows\"><code># cat -A dirb/filee\n111111111$\n222222222$</code></pre>\n<p>上例中，若不加<code>-A</code>选项，那么每行后面的<code>$</code>符号是看不到的。</p>\n</li>\n</ul>\n<h3 id=\"nav_point_64\">4.3.2 命令<code>tac</code></h3>\n<p>和命令<code>cat</code>一样，命令<code>tac</code>（正好是命令<code>cat</code>的反序写法）也是把文件的内容显示在屏幕上，只不过是先显示最后一行，然后显示倒数第二行，最后才显示第一行。我们使用命令<code>tac</code>来查看刚才创建的文件dirb/filee，显示的结果和执行命令<code>cat</code>后的结果正好是反序，如下所示：</p>\n<pre class=\"code-rows\"><code># tac dirb/filee\n222222222\n111111111</code></pre>\n<h3 id=\"nav_point_65\">4.3.3 命令<code>more</code></h3>\n<p>命令<code>more</code>也用于查看一个文件的内容，后面直接跟文件名。当文件内容太多，一屏不能全部显示时，用命令<code>cat</code>肯定是看不了前面的文件内容，这时可以使用命令<code>more</code>。当看完一屏后，按空格键可以继续看下一屏，看完所有内容后就会退出，可以按Ctrl+B向上翻屏，按Ctrl+F向下翻屏（同空格）。如果想提前退出，按Q键即可。</p>\n<h3 id=\"nav_point_66\">4.3.4 命令<code>less</code></h3>\n<p>命令<code>less</code>的作用和命令<code>more</code>一样，后面直接跟文件名，但命令<code>less</code>比<code>more</code>要多一些功能。按空格键可以翻页，按J键可以向下移动（按一下就向下移动一行），按K键可以向上移动。在使用<code>more</code>和<code>less</code>命令查看某个文件时，你可以按一下 / 键，并输入一个字符串（如<code>root</code>），然后回车，这样就可以查找这个字符串了。如果想查找多个该字符串，可以按N键以显示下一个。另外，也可以用 ? 键替代/键来搜索字符串，唯一不同的是，/ 键是从当前行向下搜索，而 ? 键是从当前行向上搜索。</p>\n<h3 id=\"nav_point_67\">4.3.5 命令<code>head</code></h3>\n<p>命令<code>head</code>用于显示文件的前10行内容，后面直接跟文件名。如果加<code>-n</code>选项，则代表显示文件的前几行，示例命令如下：</p>\n<pre class=\"code-rows\"><code># head /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\nadm:x:3:4:adm:/var/adm:/sbin/nologin\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\nsync:x:5:0:sync:/sbin:/bin/sync\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\nhalt:x:7:0:halt:/sbin:/sbin/halt\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\noperator:x:11:0:operator:/root:/sbin/nologin\n# head -n 1 /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\n# head -n2 /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin</code></pre>\n<p>大家请注意，选项<code>-n</code>后有无空格均可。另外，也可以省略<code>n</code>，<code>-</code>后面直接跟数字，示例命令如下：</p>\n<pre class=\"code-rows\"><code># head -2 /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin</code></pre>\n<h3 id=\"nav_point_68\">4.3.6 命令<code>tail</code></h3>\n<p>和命令<code>head</code>类似，命令<code>tail</code>用于显示文件的最后10行内容，后面直接跟文件名。如果加<code>-n</code>选项，则代表显示文件的最后几行，示例命令如下：</p>\n<pre class=\"code-rows\"><code># tail /etc/passwd\nnobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin\ndbus:x:81:81:System message bus:/:/sbin/nologin\nsystemd-coredump:x:999:997:systemd Core Dumper:/:/sbin/nologin\nsystemd-resolve:x:193:193:systemd Resolver:/:/sbin/nologin\ntss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin\npolkitd:x:998:996:User for polkitd:/:/sbin/nologin\nunbound:x:997:995:Unbound DNS resolver:/etc/unbound:/sbin/nologin\nsssd:x:996:993:User for sssd:/:/sbin/nologin\nsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin\nchrony:x:995:992::/var/lib/chrony:/sbin/nologin\n# tail -n2 /etc/passwd\nsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin\nchrony:x:995:992::/var/lib/chrony:/sbin/nologin\n# tail -2 /etc/passwd\nsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin\nchrony:x:995:992::/var/lib/chrony:/sbin/nologin</code></pre>\n<p>同样，<code>-n</code>后面有无空格均可，且<code>n</code>也可以省略。</p>\n<p>另外，命令<code>tail</code>的<code>-f</code>选项也常用，它可以动态显示文件的最后10行。如果文件内容在不断增加，使用<code>-f</code>选项将非常方便和直观。比如<code>tail -f /var/log/messages</code>可以动态、实时地查看文件/var/log/messages中的内容。</p>\n<h2 id=\"nav_point_69\">4.4 文件的所有者和所属组</h2>\n<p>每一个Linux目录或者文件，都会有一个所有者（owner）和所属组（group）。所有者是指文件的拥有者，所属组是指这个文件属于哪一个用户组（关于用户、用户组的概念，会在第5章中详细介绍，这里你要明白一个用户组下面会有若干个用户）。Linux这样设置文件属性是为文件的安全着想。</p>\n<p>例如，test文件的所有者是owner0，而test1文件的所有者是owner1，那么owner1很有可能是不可以查看test文件的，相应地，owner0也很有可能不可以查看test1文件（之所以说可能，是因为owner0和owner1有可能属于同一个用户组，而恰好这个用户组对这两个文件都有查看权限）。</p>\n<p>有时我们也会有这样的需求：使一个文件能同时被owner0和owner1查看，这怎么实现呢？这时“所属组”就派上用场了。先创建一个组owners，让owner0和owner1同属于这个组，然后建立一个文件test2，且其所属组为owners，这样owner0和owner1就都可以访问test2文件。Linux文件属性不仅规定了所有者和所属组，还规定了所有者、所属组以及其他用户（others）对该文件的权限。我们可以通过<code>ls -l</code>命令来查看这些属性，代码如下：</p>\n<pre class=\"code-rows\"><code># ls -l /etc/passwd\n-rw-r--r--. 1 root root 1080 12月 26 08:08 /etc/passwd</code></pre>\n<p>其中，第3列（用空格划分列）和第4列的<code>root</code>就是所有者和所属组。</p>\n<h2 id=\"nav_point_70\">4.5 Linux文件属性</h2>\n<p>在上例中，用<code>ls –l</code>命令查看当前目录下的文件时，共显示了9列内容（用空格划分列），它们都代表什么含义呢？</p>\n<ul>\n<li><p><strong>第1列</strong>：包含所查看文件的类型、所有者、所属组以及其他用户对该文件的权限。第1列共11位，其中第1位用来描述该文件的类型。上例中我们看到的文件类型是<code>-</code>，其实除了这个，还有<code>d</code>、<code>l</code>、<code>b</code>、<code>c</code>、<code>s</code>等，具体描述如下所示。</p>\n<ul>\n<li><code>-</code>表示该文件为普通文件。</li>\n<li><code>d</code>表示该文件为目录。</li>\n<li><p><code>l</code>表示该文件为链接文件（link file），在4.9.3节中即将提到的软链接即为该类型，示例命令如下：</p>\n<pre class=\"code-rows\"><code># ls -l /etc/rc.local\nlrwxrwxrwx. 1 root root 13 7月 1 11:29 /etc/rc.local -&gt; rc.d/rc.local</code></pre>\n<p>上例中，第1列<code>lrwxrwxrwx.</code>的第1位是<code>l</code>，表示该文件为链接文件，后面阿铭还会介绍它。</p>\n</li>\n<li><p><code>b</code>表示该文件为块设备，比如/dev/sda就是这样的文件，磁盘分区文件就是这种类型。</p>\n</li>\n<li><code>c</code>表示该文件为串行端口设备文件（又称字符设备文件），比如键盘、鼠标、打印机、tty终端等都是这样的文件。</li>\n<li><code>s</code>表示该文件为套接字文件（socket），应用于进程之间的通信，后面讲到MySQL时会用到该类型的文件。</li>\n<li><p>在文件类型后面紧接着的9位，每3位为一组，上例中（<code>lrwxrwxrwx.</code>）的这9位均为<code>rwx</code>这3个参数的组合。其中，<code>r</code>代表可读，<code>w</code>代表可写，<code>x</code>代表可执行。前3位为所有者的权限，中间3位为所属组的权限，最后3位为其他非本用户组的用户的权限。下面阿铭举例来说明一下。</p>\n<p>假设一个文件的属性为<code>-rwxr-xr--.</code>，它代表的意思是，该文件为普通文件，文件所有者对其可读、可写且可执行，文件所属组对其可读、不可写但可执行，其他用户对其只可读。对于一个目录来讲，打开这个目录即为执行这个目录，所以任何一个用户必须要有<code>x</code>权限才能打开并查看该目录下的内容。例如，一个目录的属性为<code>drwxr--r--.</code>，其所有者为root，只有root有<code>x</code>权限，那么除root之外的所有用户都不能打开这个目录。</p>\n<p>关于前面提到的第1列最后1位的“<code>.</code>”，阿铭要特别说明一下。老版本CentOS 5是没有这个点的，这主要是因为新版本的<code>ls</code>命令添加了SELinux或者acl的属性。如果文件或者目录使用了SELinux context的属性，这里会是一个点“<code>.</code>”；如果使用了acl的属性，这里会是一个加号“<code>+</code>”。关于SELinux和acl，阿铭不在此详细介绍，你只要了解是怎么回事即可。</p>\n</li>\n</ul>\n</li>\n<li><strong>第2列</strong>：表示该文件占用的节点（<code>inode</code>），如果是目录，那么这个数值与该目录下的子目录数量有关。</li>\n<li><strong>第3列</strong>：表示该文件的所有者。</li>\n<li><strong>第4列</strong>：表示该文件的所属组。</li>\n<li><strong>第5列</strong>：表示该文件的大小。</li>\n<li><strong>第6列、第7列和第8列</strong>：表示该文件最后一次被修改的时间（<code>mtime</code>），依次为月、日以及具体时间。</li>\n<li><strong>第9列</strong>：表示文件名。</li>\n</ul>\n<h2 id=\"nav_point_71\">4.6 更改文件的权限</h2>\n<p>4.5节讲了那么多的文件属性，你虽然不能一下子明白每列信息所表示的具体含义，但随着后续章节的逐步深入，阿铭相信你一定能理解和掌握它们。</p>\n<h3 id=\"nav_point_72\">4.6.1 命令<code>chgrp</code></h3>\n<p><code>chgrp</code>（change group的简写）命令可以更改文件的所属组，其格式为<code>chgrp [组名] [文件名]</code>，示例命令如下：</p>\n<pre class=\"code-rows\"><code># groupadd testgroup\n# mkdir /tmp/4_6 // 创建实验用的目录\n# cd /tmp/4_6\n# touch test1\n# ls -l test1\n-rw-r--r-- 1 root root 0 12月 30 07:43 test1\n# chgrp testgroup test1\n# ls -l test1\n-rw-r--r-- 1 root testgroup 0 12月 30 07:43 test1</code></pre>\n<p>上例中用到了<code>groupadd</code>命令，其含义为增加一个用户组。</p>\n<p><code>chgrp</code>命令还可以更改目录的所属组，示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir dir2\n# touch dir2/test2\n# ls –ld dir2\ndrwxr-xr-x 2 root root 19 12月 30 07:44 dir2\n# chgrp testgroup dir2\n# ls -ld dir2\ndrwxr-xr-x 2 root testgroup 19 12月 30 07:44 dir2\n# ls –l dir2\n总用量 0\n-rw-r--r-- 1 root root 0 12月 30 07:44 test2</code></pre>\n<p>上例中，<code>chgrp</code>命令只更改了目录本身，而目录下的文件并没有更改。如果要想级联更改子目录以及子文件，加<code>-R</code>选项可以实现，示例命令如下：</p>\n<pre class=\"code-rows\"><code># chgrp -R testgroup dir2\n# ls -l dir2\n总用量 0\n-rw-r--r-- 1 root testgroup 0 12月 30 07:44 test2</code></pre>\n<p>阿铭不常用<code>chgrp</code>命令，因为还有一个命令可以替代它，那就是<code>chown</code>。</p>\n<h3 id=\"nav_point_73\">4.6.2 命令<code>chown</code></h3>\n<p><code>chown</code>（change owner的简写）命令可以更改文件的所有者，其格式为：<code>chown [ -R ] 账户名 文件名</code>或者<code>chown [ -R ] 账户名:组名 文件名</code>。这里的<code>-R</code>选项只适用于目录，作用是级联更改，即不仅可以更改当前目录，连其中的子目录或者子文件也可以全部更改。示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir dir3\n# useradd user1 // 创建用户user1，useradd命令会在5.2.3节中介绍\n# touch dir3/test3 // 在dir3目录下创建test3文件\n# chown user1 dir3\n# ls -ld dir3 // dir3目录的所有者已经由root改为user1\ndrwxr-xr-x 2 user1 root 19 12月 30 07:46 dir3\n# ls -l dir3 // 但是dir3目录下的test3文件的所有者依旧是root\n总用量 0\n-rw-r--r-- 1 root root 0 12月 30 07:46 test3\n# chown -R user1:testgroup dir3\n# ls -l dir3\n总用量 0\n-rw-r--r-- 1 user1 testgroup 0 12月 30 07:46 test3</code></pre>\n<p>上例中，<code>chown -R user1:testgroup</code>会把test目录以及该目录下的文件的所有者都修改成user1，所属组都修改成testgroup。</p>\n<h3 id=\"nav_point_74\">4.6.3 命令<code>chmod</code></h3>\n<p>为了方便更改文件的权限，Linux使用数字代替<code>rwx</code>，具体规则为：用4表示<code>r</code>，用2表示<code>w</code>，用1表示<code>x</code>，用0表示<code>-</code>。例如，<code>rwxrwx---</code>用数字表示就是770，其具体算法为：<code>rwx=4+2+1=7</code>，<code>rwx=4+2+1=7</code>，<code>---=0+0+0=0</code>。</p>\n<p>命令<code>chmod</code>（change mode的简写）用于改变用户对文件/目录的读、写和执行权限，其格式为：<code>chmod [-R] xyz 文件名</code>（这里的<code>xyz</code>表示数字）。其中，<code>-R</code>选项的作用等同于<code>chown</code>命令的<code>-R</code>选项，也表示级联更改。值得注意的是，在Linux系统中，一个目录的默认权限为755，而一个文件的默认权限为644。下面我们举例说明一下：</p>\n<pre class=\"code-rows\"><code># ls -ld dir3\ndrwxr-xr-x 2 user1 testgroup 19 12月 30 07:46 dir3\n# ls -l dir3\n总用量 0\n-rw-r--r-- 1 user1 testgroup 0 12月 30 07:46 test3\n# chmod 750 dir3\n# ls -ld dir3\ndrwxr-x--- 2 user1 testgroup 19 12月 30 07:46 dir3\n# ls -l dir3/test3\n-rw-r--r-- 1 user1 testgroup 0 12月 30 07:46 dir3/test3\n# chmod 700 dir3/test3\n# ls -l dir3/test3\n-rwx------ 1 user1 testgroup 0 12月 30 07:46 dir3/test3\n# chmod -R 700 dir3\n# ls -ld dir3\ndrwx------ 2 user1 testgroup 19 12月 30 07:46 dir3\n# ls -l dir3\n总用量 0\n-rwx------ 1 user1 testgroup 0 12月 30 07:46 test3</code></pre>\n<p>如果你创建了一个目录，但又不想让其他人看到该目录的内容，则只需将其权限设置成<code>rwxr-----</code>（即740）即可。</p>\n<p><code>chmod命令</code>还支持使用<code>rwx</code>的方式来设置权限。从之前的介绍中可以发现，基本上就9个属性。我们可以使用<code>u</code>、<code>g</code>和<code>o</code>来分别表示<code>所有者</code>、<code>所属组</code>和<code>其他用户</code>的属性，用<code>a</code>代表<code>all</code>（即全部）。下面阿铭举例介绍它们的用法，示例命令如下：</p>\n<pre class=\"code-rows\"><code># chmod u=rwx,og=rx dir3/test3\n# ls -l dir3/test3\n-rwxr-xr-x 1 user1 testgroup 0 12月 30 07:46 dir3/test3</code></pre>\n<p>这样可以把dir3/test3的文件权限修改为<code>rwxr-xr-x</code>。此外，我们还可以针对<code>u</code>、<code>g</code>、<code>o</code>和<code>a</code>，增加或者减少它们的某个权限（读、写或执行），示例命令如下：</p>\n<pre class=\"code-rows\"><code># chmod u-x dir3/test3\n# ls -l dir3\n总用量 0\n-rw-r-xr-x 1 user1 testgroup 0 12月 30 07:46 test3\n# chmod a-x dir3/test3\n# ls -l dir3/test3\n-rw-r--r-- 1 user1 testgroup 0 12月 30 07:46 dir3/test3\n# chmod u+x dir3/test3\n# ls -l dir3/test3\n-rwxr--r-- 1 user1 testgroup 0 12月 30 07:46 dir3/test3</code></pre>\n<h3 id=\"nav_point_75\">4.6.4 命令<code>umask</code></h3>\n<p>默认情况下，目录的权限值为755，普通文件的权限值为644，那么这两个权限值是由谁规定的呢？究其原因，便涉及<code>umask</code>。</p>\n<p>命令<code>umask</code>用于改变文件的默认权限，其格式为：<code>umask xxx</code>（这里的<code>xxx</code>代表3个数字）。如果要查看<code>umask</code>的值，只要在命令行输入<code>umask</code>，然后按回车即可，如下所示：</p>\n<pre class=\"code-rows\"><code># umask\n0022</code></pre>\n<p>这里<code>umask</code>的预设值是0022，这表示什么含义呢？咱们先来看以下两条规则。</p>\n<ul>\n<li>若用户建立普通文件，则预设没有可执行权限，只有<code>r</code>、<code>w</code>两个权限，最大值为666（<code>-rw-rw-rw-</code>）。</li>\n<li>若用户建立目录，则预设所有权限均开放，即777（<code>drwxrwxrwx</code>）。</li>\n</ul>\n<p><code>umask</code>数值代表的含义为以上两条规则中的默认值（文件为666，目录为777）需要减掉的权限，所以：</p>\n<pre class=\"code-rows\"><code>目录的权限为rwxrwxrwx - ----w--w- = rwxr-xr-x\n普通文件的权限为rw-rw-rw- - ----w--w- = rw-r--r--</code></pre>\n<p><code>umask</code>的值是可以自定义的，比如设置<code>umask</code>为002，之后当你再次创建目录或者文件时，默认权限分别为：</p>\n<pre class=\"code-rows\"><code>rwxrwxrwx - -------w- = rwxrwxr-x（目录的权限）\nrw-rw-rw- - -------w- = rw-rw-r--（文件的权限）</code></pre>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># umask 002\n# mkdir dir4\n# ls -ld dir4\ndrwxrwxr-x 2 root root 6 12月 30 07:53 dir4\n# touch test4\n# ls -l test4\n-rw-rw-r-- 1 root root 0 12月 30 07:54 test4</code></pre>\n<p>这里我们可以看到创建的目录的默认权限变为775，而文件的默认权限变为664。如果要把<code>umask</code>改回来，具体操作方法如下：</p>\n<pre class=\"code-rows\"><code># umask 022\n# touch test5\n# ls -l test5\n-rw-r--r-- 1 root root 0 12月 30 07:54 test5</code></pre>\n<p>关于<code>umask</code>的计算方法，有的朋友喜欢换算成数字去做减法，比如<code>rwxrwxrwx</code> − <code>----w--w-</code>= 777 － 022 = 755。乍一看这好像没有任何问题，但有时会出错，比如当<code>umask</code>值为033时，如果使用单纯的数字减法，则文件的默认权限为666－033=633，但实际权限应该为<code>rw-rw-rw-</code> − <code>----wx-wx</code> = <code>rw-r--r--</code> = 644。</p>\n<p>可以在 /etc/bashrc里面更改<code>umask</code>的值，默认情况下，root的<code>umask</code>为022，而一般使用者的则为002。由于可写的权限非常重要，因此预设会去掉写权限。可能大家一直有一个疑问，阿铭介绍的<code>umask</code>值一直都是3位数，但为什么系统里面是4位呢？为什么最前面还有一个0呢？其实这个0加与不加没有影响，它表示<code>umask</code>数值是八进制的。</p>\n<h3 id=\"nav_point_76\">4.6.5 修改文件的特殊属性</h3>\n<ol>\n<li><p><strong>命令<code>chattr</code></strong></p>\n<p>命令<code>chattr</code>（change attribute）的格式为：<code>chattr [+-=][Asaci] [文件或者目录名]</code>，其中，<code>+</code>、<code>-</code>和<code>=</code>分别表示增加、减少和设定。各个权限选项的含义如下。</p>\n<ul>\n<li><strong><code>A</code></strong>：增加该权限后，表示文件或目录的<code>atime</code>将不可修改。</li>\n<li><strong><code>s</code></strong>：增加该权限后，会将数据同步写入磁盘中。</li>\n<li><strong><code>a</code></strong>：增加该权限后，表示只能追加不能删除，非root用户不能设定该属性。</li>\n<li><strong><code>c</code></strong>：增加该权限后，表示自动压缩该文件，读取时会自动解压。</li>\n<li><strong><code>i</code></strong>：增加该权限后，表示文件不能删除、重命名、设定链接、写入以及新增数据。</li>\n</ul>\n<p>以上选项中，常用的为<code>a</code>和<code>i</code>这两个选项。下面阿铭举例说明其用法，示例命令如下：</p>\n<pre class=\"code-rows\"><code># chattr +i dir2\n# touch dir2/test5\ntouch: 无法创建\"dir2/test5\": 权限不够\n# chattr -i dir2\n# touch dir2/test5\n# chattr +i dir2\n# rm -f dir2/test5\nrm: 无法删除\"dir2/test5\": 权限不够</code></pre>\n<p>上例中，给dir2目录增加<code>i</code>权限后，即使是root账户，也不能在dir2目录中创建或删除test5文件。</p>\n<p>下面再来看看<code>a</code>权限的作用，示例命令如下：</p>\n<pre class=\"code-rows\"><code># chattr -i dir2\n# touch dir2/test6\n# ls dir2\ntest2 test5 test6\n# chattr +a dir2\n# rm -f dir2/test6\nrm: 无法删除\"dir2/test6\": 不允许的操作\n# touch dir2/test7\n# ls dir2\ntest2 test5 test6 test7</code></pre>\n<p>上例中，dir2目录增加<code>a</code>权限后，只可以在里面创建文件，而不能删除文件。</p>\n<p>文件同样适用以上权限，示例命令如下：</p>\n<pre class=\"code-rows\"><code>\n# chattr +a dir2/test7\n# echo '11111' &gt; dir2/test7\n-bash: dir2/test7: 不允许的操作\n# echo '11111' &gt;&gt; dir2/test7\n# cat dir2/test7\n11111\n# chattr +i dir2/test6\n# echo '11111' &gt;&gt; dir2/test6\n-bash: test2/test3: 权限不够\n# echo '11111' &gt; dir2/test6\n-bash: dir2/test6: 权限不够\n# rm -f dir2/test6\nrm: 无法删除\"dir2/test6\": 权限不够</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>命令<code>lsattr</code></strong></p>\n<p><code>lsattr</code>（list attribute）命令用于读取文件或者目录的特殊权限，其格式为：<code>lsattr [-aR] [文件/目录名]</code>。下面先来看看<code>-a</code>和<code>-R</code>这两个选项的含义。</p>\n<ul>\n<li><strong><code>-a</code></strong>：类似于<code>ls</code>命令的<code>-a</code>选项，即连同隐藏文件一同列出。</li>\n<li><strong><code>-R</code></strong>：连同子目录的数据一同列出。</li>\n</ul>\n<p>这个命令的用法和<code>ls</code>类似，示例命令如下：</p>\n<pre class=\"code-rows\"><code># lsattr dir2\n---------------- dir2/test2\n---------------- dir2/test5\n----i----------- dir2/test6\n-----a---------- dir2/test7\n# lsattr -aR dir2\n-----a---------- dir2/.\n---------------- dir2/..\n---------------- dir2/test2\n---------------- dir2/test5\n----i----------- dir2/test6\n-----a---------- dir2/test7</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong><code>set uid</code>、<code>set gid</code>和<code>sticky bit</code></strong></p>\n<p>前面介绍权限的时候，我们一直都是用3位数，其实最前面还有一位，那就是下面要讲的<code>set uid</code>、<code>set gid</code>和<code>sticky bit</code>。</p>\n<ul>\n<li><strong><code>set uid</code></strong>：该权限针对二进制可执行文件，使文件在执行阶段具有文件所有者的权限。比如，<code>passwd</code>这个命令就具有该权限。当普通用户执行<code>passwd</code>命令时，可以临时获得root权限，从而可以更改密码。</li>\n<li><strong><code>set gid</code></strong>：该权限既可以作用在文件上（二进制可执行文件），也可以作用在目录上。当作用在文件上时，其功能和<code>set uid</code>一样，会使文件在执行阶段具有文件所属组的权限。给目录设置这个权限后，任何用户在此目录下创建的文件都具有和该目录的所属组相同的组。</li>\n<li><strong><code>sticky bit</code></strong>：可以理解为防删除位。文件是否可以被某用户删除，主要取决于该文件所在的目录是否对该用户具有写权限。如果没有写权限，则这个目录下的所有文件都不能删除，同时也不能添加新的文件。如果希望用户能够添加文件但不能删除该目录下其他用户的文件，则可以对父目录增加该权限。设置该权限后，就算用户对目录具有写权限，也不能删除其他用户的文件。</li>\n</ul>\n<p>例如，<code>passwd</code>命令设置了<code>set uid</code>权限，而 /tmp/ 目录则设置了<code>sticky bit</code>权限。下面我们来看看它们的权限，示例命令如下：</p>\n<pre class=\"code-rows\"><code># ls -l /usr/bin/passwd\n-rwsr-xr-x. 1 root root 27832 5月 11 2019 /usr/bin/passwd\n# ls -ld /tmp/\ndrwxrwxrwt. 21 root root 4096 12月 30 07:43 /tmp/</code></pre>\n<p>可以发现，<code>passwd</code>显示的是<code>rws</code>而非传统的<code>rwx</code>，用数字表示为4755。/tmp/ 显示的是<code>rwt</code>而非<code>rwx</code>，用数字表示为1777。那么，这个4和1是如何计算出来的呢？当有特殊权限时，第一位数字可以是0、1（<code>--t</code>）、2（<code>-s-</code>）、3（<code>-st</code>）、4（<code>s--</code>）、5（<code>s-t</code>）、6（<code>ss-</code>）或7（<code>sst</code>）。再回过头来看<code>passwd</code>，它是<code>s--</code>，所以是4；而/tmp/是<code>--t</code>，所以是1。</p>\n<p>配置这些特殊权限的方法和之前一样。比如，我想给一个文件增加<code>set uid</code>权限，那么命令为<code>chmod u+s filename</code>，而去掉这个权限的命令则为<code>chmod u-s filename</code>。同理，设置<code>set gid</code>权限的命令为<code>chmod g+s dirname</code>，设置<code>sticky bit</code>权限的命令为<code>chmod o+t dirname</code>。</p>\n<p>有时候，你可能会发现<code>set_uid</code>上的权限为大写的<code>S</code>，而不是小写的<code>s</code>，比如<code>rwS</code>，这是因为该文件没有<code>x</code>权限，不管是大写的<code>S</code>还是小写的<code>s</code>，都表示它存在<code>set_uid</code>或者<code>set_gid</code>权限，同理<code>sticky bit</code>也一样。</p>\n</li>\n</ol>\n<h2 id=\"nav_point_77\">4.7 在Linux下搜索文件</h2>\n<p>在Windows下有一个搜索工具，可以让我们快速找到文件，这很有用。然而在Linux下，搜索功能更加强大。</p>\n<h3 id=\"nav_point_78\">4.7.1 用<code>which</code>命令查找可执行文件的绝对路径</h3>\n<p>前面已经用过<code>which</code>命令，但需要注意的是，<code>which</code>只能用来查找在<code>PATH</code>环境变量中出现的路径下的可执行文件。这个命令比较常用，有时我们不知道某个命令的绝对路径，用<code>which</code>查找就很容易知道了。例如，查找<code>vi</code>和<code>cat</code>的绝对路径，命令如下：</p>\n<pre class=\"code-rows\"><code># which vi\n/usr/bin/vi\n# which cat\n/usr/bin/cat</code></pre>\n<h3 id=\"nav_point_79\">4.7.2 用<code>whereis</code>命令查找文件</h3>\n<p><code>whereis</code>命令通过预先生成的一个文件列表库查找与给出的文件名相关的文件，其格式为<code>whereis [-bms] [文件名称]</code>，其中各选项的含义如下所示。</p>\n<ul>\n<li><strong><code>-b</code></strong>：只查找二进制文件。</li>\n<li><strong><code>-m</code></strong>：只查找帮助文件（在man目录下的文件）。</li>\n<li><strong><code>-s</code></strong>：只查找源代码文件。</li>\n</ul>\n<p>例如，用<code>whereis</code>查看<code>ls</code>的示例命令如下：</p>\n<pre class=\"code-rows\"><code># whereis ls\nls: /usr/bin/ls /usr/share/man/man1/ls.1.gz</code></pre>\n<p>可以看到，共找到了两个文件。这个命令类似于模糊查找，只要文件名包含<code>ls</code>字符，就会将此文件列出来。此外，阿铭很少用到<code>whereis</code>命令。</p>\n<h3 id=\"nav_point_80\">4.7.3 用<code>locate</code>命令查找文件</h3>\n<p><code>locate</code>命令类似于<code>whereis</code>，也是通过查找预先生成的文件列表库来告诉用户要查找的文件在哪里，后面直接跟文件名。如果你的Linux没有这个命令，请安装mlocate软件包，安装命令如下：</p>\n<pre class=\"code-rows\"><code># yum install -y mlocate\n# locate passwd\nlocate: 无法执行 stat () `/var/lib/mlocate/mlocate.db': 没有那个文件或目录</code></pre>\n<p>安装好mlocate软件包后，初次运行<code>locate</code>命令会报错，这是因为系统还没有生成那个查找所需的文件列表库。可以使用<code>updatedb</code>命令立即生成（或更新）这个库。如果你的服务器上正执行重要的业务，那么最好不要运行这个命令，因为一旦运行，服务器的压力就会增大。默认情况下，这个数据库每周更新一次。如果使用<code>locate</code>命令搜索一个文件，而该文件正好是在两次更新时间段内创建的，那么肯定得不到结果。我们可以到文件 /etc/updated.conf中配置生成（或更新）这个数据库的规则。</p>\n<p><code>Locate</code>命令搜索到的文件列表，不管是目录名还是文件名，只要包含我们要搜索的关键词，就会列出来，所以<code>locate</code>不适合精准搜索。这个命令阿铭也不常用。</p>\n<h3 id=\"nav_point_81\">4.7.4 使用<code>find</code>搜索文件</h3>\n<p><code>find</code>这个搜索工具是阿铭使用最多的一个，请务必熟记，其格式为：<code>find [路径] [参数]</code>。下面介绍阿铭常用的几个参数。</p>\n<ul>\n<li><strong><code>-atime +n/-n</code></strong>：表示访问或执行时间大于/小于<em>n</em>天的文件。</li>\n<li><strong><code>-ctime +n/-n</code></strong>：表示写入、更改<code>inode</code>属性（如更改所有者、权限或者链接）的时间大于/小于<em>n</em>天的文件。</li>\n<li><strong><code>-mtime +n/-n</code></strong>：表示写入时间大于/小于<em>n</em>天的文件，该参数用得最多。</li>\n</ul>\n<p>下面我们先来做个简单的试验，示例命令如下：</p>\n<pre class=\"code-rows\"><code># find /tmp/4_6/ -mtime -1\n/tmp/4_6/\n/tmp/4_6/test1\n/tmp/4_6/dir2\n/tmp/4_6/dir2/test2\n/tmp/4_6/dir2/test5\n/tmp/4_6/dir2/test6\n/tmp/4_6/dir2/test7\n/tmp/4_6/dir3\n/tmp/4_6/dir3/test3\n/tmp/4_6/dir4\n/tmp/4_6/test4\n/tmp/4_6/test5</code></pre>\n<p>上例中，<code>-mtime -1</code>表示<code>mtime</code>在1天之内的文件，单位是天。而<code>-mtime +10</code>表示<code>mtime</code>在10天以上的文件。还有一种用法<code>-mmin -10</code>表示<code>mtime</code>在10分钟内的文件。有时候，也可以不加<code>+</code>或者<code>-</code>，比如<code>-mtime 10</code>，这表示正好为10天，这种用法相对较少。</p>\n<p>看到这里，你可能不太理解这三个<code>time</code>属性，那么阿铭就先介绍一下它们。文件的access time（即<code>atime</code>）是在读取或者执行文件时更改的。文件的modified time（即<code>mtime</code>）是在写入文件时随文件内容的更改而更改的。文件的change time（即<code>ctime</code>）是在写入文件、更改所有者、权限或链接设置时随<code>inode</code>内容的更改而更改的。</p>\n<p>其中，<code>inode</code>（索引节点）用来存放档案以及目录的基本信息，包含时间信息、文档名、所有者以及所属组等。<code>inode</code>是Unix操作系统中的一种数据结构，其本质是结构体，在文件系统创建时生成，且个数有限。在Linux下，可以通过命令<code>df -i</code>来查看各个分区的<code>inode</code>总数以及使用情况。</p>\n<p>因此，更改文件的内容便会更改<code>mtime</code>和<code>ctime</code>，但是文件的<code>ctime</code>可能会在<code>mtime</code>未发生任何变化时更改。例如，更改了文件的权限，但是文件内容没有变化。那么如何获得一个文件的<code>atime</code>、<code>mtime</code>以及<code>ctime</code>呢？<code>stat</code>命令可用来列出文件的<code>atime</code>、<code>ctime</code>和<code>mtime</code>，示例命令如下：</p>\n<pre class=\"code-rows\"><code># stat dir2/test2\n 文件：\"dir2/test2\"\n 大小：0 块：0 IO 块：4096 普通空文件\n设备：803h/2051d Inode：25689396 硬链接：1\n权限：(0644/-rw-r--r--) Uid：( 0/ root) Gid：( 1000/testgroup)\n最近访问：2019-12-30 07:44:10.706789647 -0500\n最近更改：2019-12-30 07:44:10.706789647 -0500\n最近改动：2019-12-30 07:45:37.978885268 -0500\n创建时间：-</code></pre>\n<p><code>atime</code>不一定在访问文件之后被修改，因为在使用ext3文件系统时，如果<code>mount</code>使用了<code>noatime</code>参数，那么就不会更新<code>atime</code>的信息。总之，这三个<code>time</code>属性值都放在<code>inode</code>中。若<code>mtime</code>、<code>atime</code>被修改，那么<code>inode</code>就一定会改，当然<code>ctime</code>也跟着要改了。</p>\n<p>下面阿铭继续介绍<code>find</code>的常用选项。</p>\n<ul>\n<li><p><strong><code>-name filename</code></strong>：表示直接查找指定文件名的文件，这个选项比较常用，示例命令如下：</p>\n<pre class=\"code-rows\"><code># find . -name test2 // .表示当前目录，当前目录在 /tmp/4_6下面\n./dir2/test2\n# find . -name \"test*\" // 支持用 * 通配\n./test1\n./dir2/test2\n./dir2/test5\n./dir2/test6\n./dir2/test7\n./dir3/test3\n./test4\n./test5</code></pre>\n</li>\n<li><p><strong><code>-type filetype</code></strong>：表示通过文件类型查找文件。文件类型在前面已经简单介绍过，相信你已经基本了解了。<code>filetype</code>包含<code>f</code>、<code>b</code>、<code>c</code>、<code>d</code>、<code>l</code>、<code>s</code>等类型，示例命令如下：</p>\n<pre class=\"code-rows\"><code># find . -type d\n.\n./dir2\n./dir3\n./dir4</code></pre>\n</li>\n</ul>\n<h2 id=\"nav_point_82\">4.8 Linux文件系统简介</h2>\n<p>Windows系统格式化硬盘时，会指定格式FAT或者NTFS，而Linux的文件系统格式为ext3、ext4或者xfs。早期的Linux使用ext2格式，CentOS 5默认使用ext3格式，CentOS 6默认使用ext4格式，而CentOS 7和CentOS 8默认使用xfs格式。ext2文件系统虽然高效、稳定，但随着Linux系统在关键业务中的应用，Linux文件系统的弱点也逐渐显露出来。ext2文件系统不是日志文件系统，这在关键行业是一个致命的弱点。</p>\n<p>ext3文件系统是直接从ext2文件系统发展而来的，它带有日志功能，可以跟踪记录文件系统的变化，并将变化内容写入日志。写操作首先是对日志记录文件进行操作，若整个写操作由于某种原因（如系统掉电）而中断，则当系统重启时，会根据日志记录来恢复中断前的写操作，而且这个过程费时极短。目前，ext3文件系统已经非常稳定、可靠，它完全兼容ext2文件系统，因此用户可以平滑地过渡到一个日志功能健全的文件系统，这实际上也是ext3日志文件系统设计的初衷。</p>\n<p>而ext4文件系统较ext3文件系统又有很多好的特性，其中最明显的是ext4支持的最大文件系统容量和单个最大文件大小比ext3大许多，二者之间的详细区别阿铭不再介绍。虽然ext4支持的单个文件大小已经达到了16TB，最大文件支持到40多亿，但依然还是有瓶颈的，xfs支持的量级要比ext4大得多，所以CentOS 7默认采用xfs也是必然的，还有一个原因，xfs的开发者目前受雇于Red Hat公司，ext4的开发者受雇于Google公司。</p>\n<p>在Windows中是不能识别Linux文件系统的，但在Linux系统中可以挂载Windows文件系统。Linux目前支持MS-DOS、VFAT、FAT、BSD等格式，如果你使用的是Red Hat或者CentOS，那么请不要妄图挂载NTFS格式的分区到Linux下，因为它不支持NTFS。当有这方面的需求时，我们可以通过安装ntfs-3g软件包来解决。</p>\n<p>除了ext3/ext4文件系统外，有些Linux发行版（如SUSE）默认的文件系统为ReiserFS，它在处理小于1KB的文件时的速度是ext文件系统的10倍。另外，ReiserFS空间浪费较少，它不会为一些小文件分配<code>inode</code>，而是打包存放在同一个磁盘块中。而ext是把这些小文件单独存放在不同的块上。例如，块大小为4KB，那么两个100字节的文件会占用两个块，ReiserFS则只占用一个块。当然，ReiserFS也有缺点，就是每升级一个版本，都要将磁盘重新格式化一次。</p>\n<h2 id=\"nav_point_83\">4.9 Linux文件类型</h2>\n<p>前面我们简单介绍了普通文件<code>-</code>、目录<code>d</code>等文件类型，为了加深理解，阿铭将详细介绍Linux的文件类型。</p>\n<h3 id=\"nav_point_84\">4.9.1 常见文件类型</h3>\n<p>在Linux文件系统中，主要有以下几种类型的文件。</p>\n<ul>\n<li><strong>普通文件（regular file）</strong>：即一般类型的文件，当用命令<code>ls -l</code>查看某个目录时，第一个属性为“<code>-</code>”的文件就是普通文件。它又可分成纯文本文件（ASCII）和二进制文件（binary）。纯文本文件的内容可以通过<code>cat</code>、<code>more</code>、<code>less</code>等工具直接查看，而二进制文件则不能。例如，我们用的命令 /usr/bin/ls就是一个二进制文件。</li>\n<li><strong>目录（directory）</strong>：它与Windows下的文件夹类似，只不过在Linux中我们不将其称为“文件夹”，而称为“目录”。用命令<code>ls -l</code>查看的第一个属性值为<code>d</code>的文件就是目录。</li>\n<li><strong>链接文件（link file）</strong>：用命令<code>ls -l</code>查看的第一个属性为<code>l</code>的文件就是链接文件，它类似于Windows下的快捷方式。这种文件在Linux中很常见，阿铭在日常系统运维工作中也经常用到，所以你要特别留意一下这类文件。</li>\n<li><strong>设备（device）</strong>：与系统周边相关的一些文件，通常都集中在/dev目录下。这种文件一般分为两种，一种是块（block）设备，就是一些存储数据以提供系统存取的接口设备，简称硬盘。例如，第一块硬盘是/dev/sda1，用命令<code>ls</code>-<code>l</code>查看的第一个属性值为<code>b</code>的文件就是块设备。另一种是字符（character）设备，是一些串行端口的接口设备，例如键盘、鼠标等，用命令<code>ls</code>-<code>l</code>查看的第一个属性为<code>c</code>的文件就是字符设备。</li>\n</ul>\n<h3 id=\"nav_point_85\">4.9.2 Linux文件后缀名</h3>\n<p>对于“后缀名”这个概念，相信你并不陌生。在Linux系统中，文件的后缀名没有具体意义，加或者不加都无所谓。但是为了便于区分，我们习惯在定义文件名时加一个后缀名。这样当用户看到某个文件名时，就会很快知道它到底是一个什么文件，例如1.sh、2.tar.gz、my.cnf、test.zip等。</p>\n<p>如果你是首次接触这些文件，也许会很疑惑，但没关系，等深入学习之后，你就会逐渐了解这些文件。在阿铭所列举的几个文件名中，1.sh代表它是一个shell脚本，2.tar.gz代表它是一个压缩包，my.cnf代表它是一个配置文件，test.zip代表它是一个压缩文件。</p>\n<p>另外需要知道，早期的UNIX系统文件名最多允许14个字符，而在新的UNIX或者Linux系统中，文件名最长可达255个字符。</p>\n<h3 id=\"nav_point_86\">4.9.3 Linux的链接文件</h3>\n<p>前面阿铭多次提到了“链接文件”这个概念，它分为硬链接（hard link）和软链接（symbolic link）两种。两种链接的本质区别在于<code>inode</code>。下面阿铭就来介绍一下这两种链接文件。</p>\n<ul>\n<li><strong>硬链接</strong>：当系统要读取一个文件时，会先读<code>inode</code>信息，然后再根据<code>inode</code>中的信息到块区域将数据取出来。硬链接是直接再建立一个<code>inode</code>链接到文件放置的块区域，即进行硬链接时该文件内容没有任何变化，只是增加了一个指向该文件的<code>inode</code>，并不会占用额外的磁盘空间。硬链接有两个限制：(1)不能跨文件系统，因为不同的文件系统有不同的<code>inode table</code>；(2)不能链接目录。</li>\n<li><strong>软链接</strong>：与硬链接不同，软链接是建立一个独立的文件，当读取这个链接文件时，它会把读取的行为转发到该文件所链接的文件上。例如，现在有一个文件a，我们做了一个软链接文件b（只是一个链接文件，非常小），b指向a。之后当读取b时，b就会把读取的动作转发到a上，这样就读取了文件a。当我们删除文件a时，链接文件b并不会被删除，但如果再次读取b，就会提示无法打开文件。另外，如果我们删除了b，那么a是不会有任何影响的。</li>\n</ul>\n<p>由此看来，似乎硬链接比较安全，因为无论删除哪一个硬链接文件，都会有其他文件指向那个<code>inode</code>，只要<code>inode</code>存在，那么文件的数据块也就存在。但由于硬链接的限制太多了（包括无法做目录的链接），因此用途上比较受限，而软链接的使用方向则较广。那么，如何建立软链接和硬链接呢？这就用到了下面我们要介绍的<code>ln</code>（link）命令。</p>\n<p><code>ln</code>命令的格式为：<code>ln [-s] [来源文件] [目的文件]</code>，该命令常用的选项是<code>-s</code>。如果不加<code>-s</code>选项就是建立硬链接，加上<code>-s</code>选项就建立软链接。示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir /tmp/4_9\n# cd /tmp/4_9\n# cp /etc/passwd ./\n# ll\n总用量 4\n-rw-r--r-- 1 root root 1121 12月 30 08:03 passwd\n# du -sk // du命令用来计算文件或者目录的大小，-k表示以KB为单位，这里的4，就是4KB\n4 .\n# ln passwd passwd-hard\n# ll\n总用量 8\n-rw-r--r-- 2 root root 1121 12月 30 08:03 passwd\n-rw-r--r-- 2 root root 1121 12月 30 08:03 passwd-hard\n# du -sk\n4 .</code></pre>\n<p>这里的<code>ll</code>命令等同于<code>ls -l</code>，请使用<code>which</code>命令查看一下。一开始目录下面只有一个passwd文件，目录总大小为4KB，做了硬链接后，虽然两个文件的大小都为1121B，但目录的总大小并没有变化。我们不妨先删除源文件，然后再来比较一下，示例命令如下：</p>\n<pre class=\"code-rows\"><code># rm -f passwd\n# ll\n总用量 4\n-rw-r--r-- 1 root root 1121 12月 30 08:03 passwd-hard\n# du -sk\n4 .</code></pre>\n<p>上例中，删除源文件passwd后，文件大小依旧不变。这说明硬链接文件并不会复制数据块，额外占用磁盘空间。再来看硬链接的另外一个限制——不允许目录做硬链接，示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir 123\n# ln 123 456\nln: \"123\": 不允许将硬链接指向目录</code></pre>\n<p>下面我们再来看看软链接的一些特性。首先建立一个测试目录456，然后复制 /etc/passwd文件来做测试，再给它做一个软链接文件，示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir 456\n# cd 456\n# cp /etc/passwd ./\n# ln -s passwd passwd-soft\n# ll\n总用量 4\n-rw-r--r-- 1 root root 1121 12月 30 08:05 passwd\nlrwxrwxrwx 1 root root 6 12月 30 08:05 passwd-soft -&gt; passwd\n# head -n1 passwd-soft\nroot:x:0:0:root:/root:/bin/bash\n# head -n1 passwd\nroot:x:0:0:root:/root:/bin/bash\n# rm -f passwd\n# head -n1 passwd-soft\nhead:无法打开\"passwd-soft\"读取数据:没有那个文件或目录\n# ll\n总用量 0\nlrwxrwxrwx 1 root root 6 12月 30 08:05 passwd-soft -&gt; passwd</code></pre>\n<p>上例中，如果删除源文件，则不能读取软链接文件，而且使用命令<code>ll</code>查看后，会发现颜色也有所变化。另外，目录不可以做硬链接，但可以做软链接，示例命令如下：</p>\n<pre class=\"code-rows\"><code># cd ..\n# In 456 789\nIn: \"456\": 不允许将硬链接指向目录\n# ln -s 456 789\n# ls -ld 456 789\ndrwxrwxr-x 2 root root 25 12月 30 08:06 456\nlrwxrwxrwx 1 root root 3 12月 30 08:07 789 -&gt; 456</code></pre>\n<h2 id=\"nav_point_87\">4.10 课后习题</h2>\n<p>(1) 命令<code>rmdir -p</code>用来删除一串目录，比如<code>rmdir -p /tmp/test/1/2/3</code>。如果/tmp/1/2/目录下除了3目录外还有个4目录，4目录里还有5目录，那么是否可以成功删除？用命令<code>rmdir -p</code>删除一个不存在的目录时，是否会报错呢？</p>\n<p>(2) 删除一个目录或者文件时，在删除之前会先询问我们是否删除，如果直接回车，是否能删除呢？如果输入的不是y也不是n，会发生什么呢？</p>\n<p>(3) 如何创建一串目录（如 /home/1/2/3/4）？</p>\n<p>(4) 使用<code>mv</code>命令时，如果目标文件不是目录，但该文件存在，会怎么样？</p>\n<p>(5) 使用<code>less</code>命令查看文件 /etc/passwd，搜索一下共出现了几个root？按哪个键可以向上/向下逐行移动？</p>\n<p>(6) 为什么目录必须要有<code>x</code>权限才可以查看目录下面的文件呢？</p>\n<p>(7) 如果设置<code>umask</code>为001，那么用户默认创建的目录和文件的权限是什么样子的？</p>\n<p>(8) 用<code>find</code>找出/var/目录下最近一天内变更的文件，再用<code>find</code>找出/root/目录下一小时内变更的文件。</p>\n<p>(9) 用<code>find</code>找出/etc/目录下一年内从未变更过的文件。</p>\n<p>(10) 为什么硬链接不能链接目录？硬链接的文件是否占用空间大小？硬链接文件是否可以跨分区创建？</p>\n<p>(11) Linux系统里，分别用什么符号表示纯文本文件、二进制文件、目录、链接文件、块设备以及字符设备？</p>\n<p>(12) 如何把dira目录以及该目录下的所有文件和目录修改为所有者为user1、所属组为users？</p>\n<p>(13) Linux系统中默认目录的权限是什么？文档的权限是什么？分别用三个数字表示。我们可以通过修改<code>umask</code>的值更改目录和文档的默认权限值，那么如何通过<code>umask</code>的值得到默认权限值呢？</p>\n<p>(14) 修改dirb目录的权限，使其所有者可读、可写且可执行，所属组可读且可执行，其他用户不可读、不可写也不可执行，使用什么命令呢？</p>\n<p>(15) 如何使文件只能写且不能删除呢？如何使文件不能被删除、重命名、设定链接、写入且新增数据呢？</p>\n<p>(16) Linux下的一个点“.”和两个点“..”分别表示什么？</p>\n<p>(17) <code>cd -</code>表示什么含义？</p>\n<p>(18) 用<code>ls</code>命令查看目录或者文件时，第2列的数值表示什么意思？如果一个目录的第2列的值为3，那么这个3是如何得到的呢？</p>\n<p>(19) 如果系统中没有<code>locate</code>命令，我们需要安装哪个软件包？初次使用<code>locate</code>命令会报错can not open `/var/lib/mlocate/mlocate.db`: No such file or directory，我们需要如何做呢？</p>\n<p>(20) 当复制一个文件时，如果目标文件存在会询问我们是否覆盖，如何做就不再询问了呢？</p>\n<p>(21) 假如一个文件内容一直在增加，如何动态显示这个文件的内容呢？</p>\n<p>(22) 更改文件读写执行权限的命令是什么？如何把一个目录下的所有文件（不含目录）的权限改为644？</p>\n<p>(23) 如何查看当前用户的目录?</p>\n<p>(24) 假如一个目录可以让任何人可写，那么如何能做到该目录下的文件只允许文件的所有者更改？</p>\n<p>(25) 简述软链接和硬链接的区别。</p>\n<p>(26) <code>cat a.txt</code>会更改a.txt的什么时间？<code>chmod 644 a.txt</code>会更改a.txt的什么时间？vi呢？直接<code>touch</code>呢？</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 3 章 远程登录Linux系统","id":741025},"right":{"article_title":"第 5 章 Linux系统用户与用户组管理","id":741027}},"comments":[{"had_liked":false,"id":390558,"user_name":"Lucas Liu","can_delete":false,"product_type":"c1","uid":3203602,"ip_address":"北京","ucode":"4FDD3448E0943A","user_header":"","comment_is_top":false,"comment_ctime":1715657664,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636611,"comment_content":"以下答案使用 Ubuntu 20.04 系统验证\n\n(21) 假如一个文件内容一直在增加，如何动态显示这个文件的内容呢？\n答：tail -f [目标文件]\n\n(22) 更改文件读写执行权限的命令是什么？如何把一个目录下的所有文件（不含目录）的权限改为 644？\n答：chmod 命令\nfind . -type f -exec chmod 644 {} \\;\n* find . -type f：这部分使用 find 命令来查找当前目录下的所有文件。-type f 表示只匹配文件，不包括目录。\n* -exec chmod 644 {} \\;：这部分表示对于每个找到的文件，会执行 chmod 644 命令来修改其权限。{} 会被替换为实际的文件名，\\; 表示命令结束。\n\n\n(23) 如何查看当前用户的目录?\n执行 cd 或 cd ~ 进入当前用户更目录，然后执行 ls 查看当前目录\n\n(24) 假如一个目录可以让任何人可写，那么如何能做到该目录下的文件只允许文件的所有者更改？\n执行 find . -type f -exec chmod 600 {} \\; 将该目录下所有文件权限设为 rw———，只允许文件所有者读写\n\n(25) 简述软链接和硬链接的区别。\n摘自知乎——https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;67366919\n【硬连接】\n硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\n【软连接】\n另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。\n\n(26) cat a.txt会更改 a.txt 的什么时间？chmod 644 a.txt会更改 a.txt 的什么时间？vi 呢？直接touch呢？\ncat a.txt会更改 atime\nchmod 644 a.txt会更改 ctime\nvim 编辑文件后会更改 mtime 和 chime\n直接touch会全部更改 atime、mtime、ctime","like_count":0},{"had_liked":false,"id":390557,"user_name":"Lucas Liu","can_delete":false,"product_type":"c1","uid":3203602,"ip_address":"北京","ucode":"4FDD3448E0943A","user_header":"","comment_is_top":false,"comment_ctime":1715657634,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636611,"comment_content":"以下答案使用 Ubuntu 20.04 系统验证\n\n(11) Linux 系统里，分别用什么符号表示纯文本文件、二进制文件、目录、链接文件、块设备以及字符设备？\n答：-表示普通文件，又可以分为纯文本文件和二进制文件\nd表示目录\nl表示链接文件（link file）\nb表示块设备\nc表示串行端口设备文件（又称字符设备文件）\n\n(12) 如何把 dira 目录以及该目录下的所有文件和目录修改为所有者为 user1、所属组为 users？\n答：chown -R user1:users dira\n\n(13) Linux 系统中默认目录的权限是什么？文档的权限是什么？分别用三个数字表示。我们可以通过修改umask的值更改目录和文档的默认权限值，那么如何通过umask的值得到默认权限值呢？\n答：目录默认权限：rwxr-xr-x 755\n文件默认权限：rw-r—r— 644\n通过将umask 设为000，然后新建文件和目录得到默认权限值\n\n(14) 修改 dirb 目录的权限，使其所有者可读、可写且可执行，所属组可读且可执行，其他用户不可读、不可写也不可执行，使用什么命令呢？\n答：chmod -R 750 dirb 或者 chmod -R u=rwx,g=rx,o=- dirb\n\n(15) 如何使文件只能写且不能删除呢？如何使文件不能被删除、重命名、设定链接、写入且新增数据呢？\n答：只能写且不能删除：chattr +a filea\n不能删除、重命名、设定链接、写入且新增数据：chattr +i fileb\n\n(16) Linux 下的一个点“.”和两个点“..”分别表示什么？\n答：“.”表示当前目录，“..”表示当前目录的上一级目录\n\n(17) cd -表示什么含义？\n答：当前工作目录将被切换到环境变量OLDPWD所表示的目录，也就是前一个工作目录。\n\n(18) 用ls命令查看目录或者文件时，第 2 列的数值表示什么意思？如果一个目录的第 2 列的值为 3，那么这个 3 是如何得到的呢？\n答：第2列代表硬链接数，默认为1，通过 ln 命令创建2个硬链接后达到3\n\n(19) 如果系统中没有locate命令，我们需要安装哪个软件包？初次使用locate命令会报错 can not open `&#47;var&#47;lib&#47;mlocate&#47;mlocate.db`: No such file or directory，我们需要如何做呢？\n答：需要安装 mlocate 软件包；首次执行前需要运行 updatedb 命令立即生成文件列表库\n\n(20) 当复制一个文件时，如果目标文件存在会询问我们是否覆盖，如何做就不再询问了呢？\n答：我在Ubuntu系统上的cp命令默认没有询问，添加 -i 参数后才有询问；如果你的系统默认有询问，可能是添加了别名 “cp=‘cp -i’”，删除别名后就不再询问了","like_count":0},{"had_liked":false,"id":390556,"user_name":"Lucas Liu","can_delete":false,"product_type":"c1","uid":3203602,"ip_address":"北京","ucode":"4FDD3448E0943A","user_header":"","comment_is_top":false,"comment_ctime":1715657290,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636611,"comment_content":"以下答案使用 Ubuntu 20.04 系统验证\n\n(1) 命令rmdir -p用来删除一串目录，比如rmdir -p &#47;tmp&#47;test&#47;1&#47;2&#47;3。如果 &#47;tmp&#47;1&#47;2&#47; 目录下除了 3 目录外还有个 4 目录，4 目录里还有 5 目录，那么是否可以成功删除？用命令rmdir -p删除一个不存在的目录时，是否会报错呢？\n答：test&#47;1&#47;2&#47;3 被删除，同时会报错无法删除目录 test&#47;1&#47;2，因为 test&#47;1&#47;2 不是空目录；删除不存在的目录时会报错：No such file or directory\n\n(2) 删除一个目录或者文件时，在删除之前会先询问我们是否删除，如果直接回车，是否能删除呢？如果输入的不是 y 也不是 n，会发生什么呢？\n答：直接回车不会删除，而是和输入不是y或n的内容一样会退出操作\n\n(3) 如何创建一串目录（如 &#47;home&#47;1&#47;2&#47;3&#47;4）？\n答：mkdir -p &#47;home&#47;1&#47;2&#47;3&#47;4\n\n(4) 使用mv命令时，如果目标文件不是目录，但该文件存在，会怎么样？\n答：mv filea fileb，filea 被重命名为fileb并覆盖原fileb\n\n(5) 使用less命令查看文件 &#47;etc&#47;passwd，搜索一下共出现了几个 root？按哪个键可以向上 &#47; 向下逐行移动？\n答：搜索到了3个root，使用J和K上下移动\n\n(6) 为什么目录必须要有x权限才可以查看目录下面的文件呢？\n答：目录的执行权限（x）允许用户进入该目录。如果没有执行权限，用户将无法进入目录，也就无法查看目录中的内容。\n\n(7) 如果设置umask为 001，那么用户默认创建的目录和文件的权限是什么样子的？\n答：-rw-rw-rw-（文件权限）\ndrwxrwxrw-(目录权限)\n\n(8) 用find找出 &#47;var&#47; 目录下最近一天内变更的文件，再用find找出 &#47;root&#47; 目录下一小时内变更的文件。\n答：find &#47;var&#47; -mtime -1\nfind &#47;root&#47; -mmin -60\n\n(9) 用find找出 &#47;etc&#47; 目录下一年内从未变更过的文件。\n答：find &#47;etc&#47; -mtime +365\n\n(10) 为什么硬链接不能链接目录？硬链接的文件是否占用空间大小？硬链接文件是否可以跨分区创建？\n答：搜索了一下，大意是说可能会形成环，导致Linux粗粒不了；硬链接文件并不会复制数据块，额外占用磁盘空间；不能跨文件系统，因为不同的文件系统有不同的inode table","like_count":0}]}