{"id":474252,"title":"课堂答疑（一）｜前置篇、C 核心语法实现篇问题集锦","content":"<p>你好，我是于航。</p><p>看到这里的你，应该已经完成了本课程前两个模块的学习。随着课程的不断推进，我陆续收到了很多反馈。很高兴看到你在评论区积极留言，和大家一起讨论思考题。并且，还有很多同学提出了一些非常有意义的问题。那么，在继续学习后面更深入的内容之前，让我们先暂缓脚步，从问题出发，进行一次整体性的回顾。</p><p>在这一讲中，我会以加餐的形式，为你剖析一些值得讨论的思考题，以及你们提出的有代表性的问题。</p><p><strong>问题一：</strong>在 <a href=\"https://time.geekbang.org/column/article/464550\">01 讲</a> 的最后，我留给你的问题是：在这一讲第一部分的 C 代码实例中，我们为何要给函数 findAddr 添加 <code>static</code> 关键字？不添加这个关键字的话，程序是否可以编译运行？</p><p>这里，我将那段代码简化了一下，只提取出与问题相关的部分，放到了下面。因此，问题也变成了：对于下面这段代码来说，将函数 foo 定义中使用的 <code>static</code> 关键字去掉，是否会影响程序的正常编译和运行呢？</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\ninline static int foo(void) {&nbsp;\n&nbsp; return 0;\n}\nint main(void) {\n&nbsp; printf(\"%d\", foo());\n&nbsp; return 0;&nbsp;\n}\n</code></pre><p>实际上，如果你能够在 <a href=\"https://godbolt.org\">godbolt</a> 上快速实践一下，就会发现：在默认情况下（没有使用任何优化参数），编译器会报出类似 “error: ld returned 1 exit status” 的链接器错误；而在使用 “-O1” 及以上优化参数的情况下，编译器则可以正常编译。那么，为什么会这样呢？</p><!-- [[[read_end]]] --><p>实际上，虽然我们在课程中会使用 C17 标准对代码进行编译，但上述代码中使用的 <code>inline</code> 关键字却来源于 C99 标准。对于编译器来说，在这个标准下，标注了 <code>inline</code> 关键字的函数<strong>意味着函数的定义仅用于内联</strong>。而当编译器在低优化等级下不选择将函数进行内联处理时，便会尝试去寻找一个可以进行链接的函数实现。</p><p>关于这一点，我们也可以从 C 标准中得到印证。在<a href=\"https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf\">这个链接</a>中， C17 标准文档的 91 页，第 6.7.4.7 小节对 <code>inline</code> 关键字进行了总结，你可以参考。</p><p>到这里，解决这个问题的方法就变得十分清晰了。通常，我们可以使用以下几个办法：</p><ol>\n<li>去掉 <code>inline</code> 关键字。由于该关键字通常只作为编译器的 hint，因此在使用优化的情况下，基本不会影响编译结果；</li>\n<li>使用 <code>static inline</code>，为函数提供 internal linkage。编译器总是能够使用在当前编译单元内具有静态链接的函数；</li>\n<li>使用 <code>extern</code> 为函数提供对应的 external definition。但这种方式与定义一个普通函数没有区别，从标准上来看，不符合内联的规则，即 inline definition。</li>\n</ol><p>另外，你也可以考虑使用 GNU C89 标准进行编译（-std=gnu89），以采用旧式的内联处理机制。但这种方式会让我们无法使用 C 语言的新特性，所以我并不推荐。</p><p><strong>问题二</strong>：在问题一的例子中，为什么使用 <code>inline static</code> 而不是 <code>static inline</code> 呢？</p><p>这是一个非常棒的问题。实际上，对于编译器而言，这两种写法都可以正常工作。但不同点在于，对于 C17 以前的标准来说，“声明标识符（Declaration Specifier）”是可以按照任意顺序摆放的。而在 C17 及以后的标准中则规定，声明标识符中的 “Storage-class Specifier” 应该被放置在各定义的最开头处，这其中便包含有 <code>static</code> 关键字。而对于其他形式，则会被视为过时的写法。但实际上，考虑到向前兼容，现代编译器都还支持这种旧式写法。</p><p><strong>问题三</strong>：有同学问到，为什么我们在文章代码中使用的内联汇编，与通过 C 代码编译而来的汇编，两者在风格上有很大差异？比如，对于同一个机器指令来说，两种风格在源操作数与目的操作数的使用顺序上竟然是完全相反的。</p><p>没错，这是一个相当细心的同学。实际上，对于 x86 汇编语言来说，目前工业界主要有两种不同的代码编写风格，即 Intel 风格和 AT&amp;T 风格。其中，前者被广泛使用在 Windows 操作系统及相关工具链上，而后者则被广泛使用在 “Unix 世界”中（因为 Unix 是从 AT&amp;T 贝尔实验室创建的）。因此，不同的代码风格便也对应着不同的代码编写方式。</p><p>这里，我把它们之间的一些主要区别，通过具体的例子进行了描述，并整理在了下面的表格中供你参考：</p><p><img src=\"https://static001.geekbang.org/resource/image/92/e8/9207fcyyce02361252ac01c29f6e8ee8.jpg?wh=1920x833\" alt=\"图片\"></p><p><strong>问题四</strong>：有同学在实践时发现，我在 <a href=\"https://time.geekbang.org/column/article/465228\">02 讲</a> 中介绍的一段本无法被正常编译的代码，却可以在 Clang 编译器下被正常编译。这里，为了方便你观察，我将这段代码直接放到了下面：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\nint main(void) {\n&nbsp; const int vx = 10;\n&nbsp; const int vy = 10;\n&nbsp; int arr[vx] = {1, 2, 3};&nbsp; // [错误1] 使用非常量表达式定义定长数组；\n&nbsp; switch(vy) {\n&nbsp; &nbsp; case vx: {&nbsp; // [错误2] 非常量表达式应用于 case 语句；\n&nbsp; &nbsp; &nbsp; printf(\"Value matched!\");\n&nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; }\n&nbsp; }\n}\n</code></pre><p>正如代码中第 5 行和第 7 行注释所描述的那样，我们无法用非常量表达式（值）来作为定长数组的长度参数，或是直接用于 <code>case</code> 语句中。而这段代码之所以能在 Clang 中被正常编译，则是由于编译器通常会竭尽所能地去编译用户提供的代码。</p><p>因此，在这个例子中，Clang 会在默认情况下使用名为 “gnu-folding-constant” 的 GNU 扩展，来处理代码中不符合 C 标准的用法。该扩展可以在代码需要的地方，将非常量表达式转换为常量表达式使用。但实际上，这并非 C 标准的内容。</p><p>为此，我们可以通过在编译代码时指定 “-pedantic-errors” 选项，阻止编译器对扩展能力的使用。该选项会在编译器使用扩展时发出相应的错误警告。而 GCC 与 Clang 这两个编译器均支持该选项。</p><p><strong>问题五</strong>：学习 C 语言，真的有必要了解汇编吗？</p><p>相信这是一个困扰很多 C 语言初学者的问题，这里我来谈一谈自己的理解。</p><p>首先，这个问题是没有标准答案的。C 语言被创造出来的目的之一，就是抹平汇编语言在编码上的差异。通过这种方式，人们可以做到代码的一次编写，多次编译。所以，对于学习或编写 C 代码来说，实际上是不需要了解汇编语言的。编译器会以最好的方式，帮助你将 C 代码转换成对应的机器代码。</p><p>但如果是这些情况：在你的应用场景中，单纯使用 C 代码无法完成相关任务（比如需要使用“内联汇编”的场景），或者你对 C 程序的性能优化有着极致的追求，又或是你想对程序的运行细节有更多的理解……那么，适当学习汇编语言与计算机体系结构的相关知识便是必要的。</p><p>总而言之，是否需要学习汇编语言，还是要看学习者自身的目的。编程语言是一种工具，学习它首先是要做到能用起来，在此基础上，再根据每个人的不同需求，向不同方向深入。</p><p><strong>问题六</strong>：<code>leave</code> 指令在“清理栈”时会将相关内存清空（置零）吗？</p><p>这个问题非常好。一般来说，我们在编码过程中提及所谓“清空”或“清理”时，大部分人第一时间都会认为是将某个量重置为对应的初始值，这其中可能包含有将某个值置为 0 的过程。但实际上，对于 <code>leave</code> 指令来说，它仅会在执行时修改寄存器 rsp 和 rbp 的值，但并不会对“残留”在栈中的数据（比如前一个栈帧）做任何处理。你可以通过下面这段代码来验证这个结论：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\nvoid foo(void) {\n&nbsp; int x;\n&nbsp; printf(\"%d\\n\", x);\n&nbsp; x = 10;\n}\nint main(void) {\n&nbsp; foo();\n&nbsp; foo();\n&nbsp; return 0;\n}\n</code></pre><p>因此，对于一个程序来说，相关寄存器中的值便能够完全表示这一时刻该程序的实际运行状态。在接下来的 <a href=\"https://time.geekbang.org/column/article/475867\">12 讲</a> 中，你将会看到，setjmp 与 longjmp 函数是如何通过保存寄存器的值来恢复函数的执行状态的。</p><p><strong>问题七</strong>：有同学问到，对于某些简单的算数运算逻辑，编译器为什么会使用 <code>lea</code> 指令，而非 <code>mov</code> 指令来实现呢？</p><p>实际上，对于某些特定格式的简单计算，使用 <code>lea</code> 指令可以获得比 <code>mov</code> 指令更好的性能。比如，来看下面这段 C 代码：</p><pre><code class=\"language-c++\">int foo(int n) {\n&nbsp; return 4 * n + 10;\n}\n</code></pre><p>对于这里的 foo 函数来说，编译器可以选择使用 <code>mov</code> 指令按照下面的方式来实现：</p><pre><code class=\"language-c++\">mov eax, edi\nsal eax, 2\nadd eax, 10\n</code></pre><p>当然，也可以使用 <code>lea</code> 指令，以一种更加精简的方式来实现：</p><pre><code class=\"language-c++\">&nbsp;lea&nbsp;eax, [10+rdi*4]\n</code></pre><p>可以看到，使用 <code>lea</code> 指令实现这段代码，可以让程序少执行两条机器指令，从而进一步提升程序的运行时性能。</p><p>在 x86 体系中，指令参数可以使用的一种内存地址形式为 [base + scale x offset + displacement]。其中，displacement 必须为 32 位有符号格式的立即数，scale 的可选值为 1、2、4 或 8，base 和 offset 可以由寄存器或者立即数组成。因此，通过这种方式，<code>lea</code> 指令就能够被用于实现多种基本的算术运算，并优化程序性能。</p><p><strong>问题八</strong>：C 语言可以实现类似 C++ 的函数重载吗？</p><p>这个问题很好，但遗憾的是，C 语言并没有提供用于实现多态的相关特性。不过在 C11 之后，借助泛型宏 _Generic，我们也可以在一定程度上实现类似的功能。具体你可以参考下面这段示例代码。而关于这个宏的详细使用方式，可以参考<a href=\"https://www.geeksforgeeks.org/_generic-keyword-c\">这个</a>链接。</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n#define foo(N) _Generic((N), \\\n&nbsp; double: food, \\\n&nbsp; default: fooi, \\\n&nbsp; float: foof)(N)\nint fooi(int n) { return n; }\ndouble food(double n) { return n; }\nfloat foof(float n) { return n; }\nint main(void) {\n&nbsp; printf(\"%d\", foo(1));\n&nbsp; return 0;\n}\n</code></pre><p>好了，今天的答疑就到这里，感谢提出问题的各位同学。如果你还有其他问题，欢迎在评论区与我讨论。</p>","comments":[{"had_liked":false,"id":329126,"user_name":"sugar","can_delete":false,"product_type":"c1","uid":1167046,"ip_address":"","ucode":"454538FF253B5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg","comment_is_top":false,"comment_ctime":1641141197,"is_pvip":false,"replies":[{"id":"119996","content":"可以试试 Visual Studio Code？我之前的 C++ 项目在 VSC 里单步调试的时候就可以直接 inspect 对应变量的内容（包括各类 STL 容器）。","user_name":"作者回复","user_name_real":"编辑","uid":"1005890","ctime":1641384619,"ip_address":"","comment_id":329126,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10231075789","product_id":100100701,"comment_content":"请教于航老师一个问题，我的日常开发程序语言主要是JavaScript和C&#47;C++，这个技术栈与老师应该比较类似。在js中，我们在运行时console.log可以打出任何一个代码中可见的变量的具体值，无论它是一个number、string这样的简单类型，还是各种类嵌套定义出的超级复杂的数据结构，这个能力在阅读其他人写的代码时很有帮助：我不确定一段程序中的某个符号代表的对象究竟是什么结构的时候，我可以直接去运行时把它log出来，尤其是项目代码量庞大的时候这能省去大量人肉读代码的时间；但是在c&#47;c++当中，据我目前所知似乎只能cout 或者 printf出一个基本类型，比如int double char等，不能像js那样轻松的console.log出任何type的变量完整结构。请问于航老师在面对这种情况时是怎么处理？是否只能人肉一个一个class definition去翻代码？c的一些三方库只能翻到.h文件，翻不到具体实现.c或者.cpp文件。","like_count":2,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544045,"discussion_content":"可以试试 Visual Studio Code？我之前的 C++ 项目在 VSC 里单步调试的时候就可以直接 inspect 对应变量的内容（包括各类 STL 容器）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641384619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1167046,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg","nickname":"sugar","note":"","ucode":"454538FF253B5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":544124,"discussion_content":"v8这种gn ninja编译的大项目 貌似没发vscode单步吧….？官方doc上我似乎没找到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641399235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544045,"ip_address":""},"score":544124,"extra":""}]},{"author":{"id":1228313,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/vQiadbkZYR239J80hjekw7jzY9vy6otLKPNDSuz2lruDiaXlKGkcsX5wwiaFevicgqV8odlRG4UITiadDF3fgicrHPcw/132","nickname":"疯码","note":"","ucode":"7FF11EC80439EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544427,"discussion_content":"也可以visual studio下输出断点，自带format","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641520360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331437,"user_name":"火云邪神霸绝天下","can_delete":false,"product_type":"c1","uid":1013399,"ip_address":"","ucode":"98EDC85AE13F5A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/97/23446114.jpg","comment_is_top":false,"comment_ctime":1642585520,"is_pvip":false,"replies":[{"id":"122221","content":"试着在 “-O0” 下编译，再看看执行结果呢？","user_name":"作者回复","user_name_real":"编辑","uid":"1005890","ctime":1645025231,"ip_address":"","comment_id":331437,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5937552816","product_id":100100701,"comment_content":"#include &lt;stdio.h&gt;<br>void foo(void) {<br>  int x;<br>  printf(&quot;%d\\n&quot;, x);<br>  x = 10;<br>}<br>int main(void) {<br>  foo();<br>  foo();<br>  return 0;<br>}<br><br>这个代码两次输出都是0。不太明白它说清楚了什么。<br>本来不就该是  0   吗？<br><br>函数执行一次就栈内空间回收了吧。下次执行下次说。","like_count":1,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551491,"discussion_content":"试着在 “-O0” 下编译，再看看执行结果呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645025232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328999,"user_name":"ZR2021","can_delete":false,"product_type":"c1","uid":1707352,"ip_address":"","ucode":"4F685C7516F057","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","comment_is_top":false,"comment_ctime":1641009460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5935976756","product_id":100100701,"comment_content":"老师强大！！！","like_count":1},{"had_liked":false,"id":328788,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1640883039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5935850335","product_id":100100701,"comment_content":"Good ","like_count":1},{"had_liked":false,"id":354017,"user_name":"TableBear","can_delete":false,"product_type":"c1","uid":1673990,"ip_address":"广东","ucode":"A2C0562EEA2725","user_header":"https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg","comment_is_top":false,"comment_ctime":1660018284,"is_pvip":true,"discussion_count":0,"race_medal":3,"score":"1660018284","product_id":100100701,"comment_content":"专属的微信群是哪个？还能进去吗","like_count":0},{"had_liked":false,"id":330459,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1641984557,"is_pvip":true,"replies":[{"id":"120565","content":"好的，我帮你问问看哈哈哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1005890","ctime":1642067688,"ip_address":"","comment_id":330459,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641984557","product_id":100100701,"comment_content":"我觉得老师可以请大佬来讲讲c语言在redis应用哈哈，有了nginx，怎么能少了redis","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545865,"discussion_content":"好的，我帮你问问看哈哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642067688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}