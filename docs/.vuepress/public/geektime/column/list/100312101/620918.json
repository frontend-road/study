{"id":620918,"title":"15｜Wrapper机制：Wrapper是怎么降低调用开销的？","content":"<p>你好，我是何辉。今天是我们深入研究Dubbo源码的第四篇，Wrapper 机制。</p><p>Wrapper，很多人从单词层面来解读，很容易理解成是Java包装类，或者是装饰器设计模式，其实都不是，它是Dubbo中的一种动态生成的代理类。</p><p>一听到代理，你可能已经想到了 JDK 和 Cglib 两个常见的代理，JDK 代理是动态生成了一个继承 Proxy 的代理类，而 Cglib 代理是动态生成了一个继承被代理类的派生代理类，既然都有现成的动态生成代理类的解决方案了，为什么 Dubbo 还需要动态生成自己的代理类呢？</p><p>带着这个问题，我们开始今天的学习。</p><h2>不足与缺失</h2><p>首先得弄明白一件事情，现有的 JDK 和 Cglib 代理为什么不能满足 Dubbo 的诉求？</p><h3>1. JDK 代理</h3><p>在“<a href=\"https://time.geekbang.org/column/article/613308\">泛化调用</a>”讲中我们讲过，泛化调用三部曲中第一个关键环节，通过接口类名、接口方法名、接口方法参数类名、业务请求参数，这四个维度的字段发起远程调用。</p><p>结合具体的应用场景来思考，有三个请求，每个请求中的四个字段值都不一样，现在要发往提供方服务：</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/56/a1295407baaa44dce7ce695964c8ba56.jpg?wh=4440x1836\" alt=\"图片\"></p><p>而提供方服务，需要在统一的入口中接收请求，然后派发到不同的接口服务中去。简单点说，提供方服务要做的就是，构建通用的接收请求入口，然后进行分发调用不同接口服务而已。<strong>如果要针对这个统一的入口进行编码实现，你会怎么写呢？</strong></p><!-- [[[read_end]]] --><p>写过不少业务代码的你，一定有了思路：</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/08/a2e7ba0b018e1ac5c86a7f95b835a208.jpg?wh=4554x1779\" alt=\"图片\"></p><p>可以通过反射机制获取接口类名对应的类对象，通过类对象的简称获取到对应的接口服务，通过接口方法名和接口方法参数，来精准定位需要提供方接口服务中的哪个方法进行处理。</p><p>对应代码就很简单了。</p><pre><code class=\"language-java\">///////////////////////////////////////////////////\n// 提供方服务：统一入口接收请求的控制器，原始的 if...else 方式\n///////////////////////////////////////////////////\n@RestController\npublic class CommonController {\n    // 定义统一的URL地址\n    @PostMapping(\"gateway/{className}/{mtdName}/{parameterTypeName}/request\")\n    public String recvCommonRequest(@PathVariable String className,\n                                    @PathVariable String mtdName,\n                                    @PathVariable String parameterTypeName,\n                                    @RequestBody String reqBody) throws Exception {\n        // 统一的接收请求的入口\n        return commonInvoke(className, parameterTypeName, mtdName, reqBody);\n    }\n    \n    /**\n     * &lt;h2&gt;统一入口的核心逻辑。&lt;/h2&gt;\n     *\n     * @param className：接口归属方法的全类名。\n     * @param mtdName：接口的方法名。\n     * @param parameterTypeName：接口的方法入参的全类名。\n     * @param reqParamsStr：请求数据。\n     * @return 接口方法调用的返回信息。\n     * @throws Exception\n     */\n    public static String commonInvoke(String className,\n                                      String mtdName,\n                                      String parameterTypeName,\n                                      String reqParamsStr) throws Exception {\n        // 通过反射机制可以获取接口类名对应的类对象\n        Class&lt;?&gt; clz = Class.forName(className);\n        \n        // 接着通过类对象的简称获取到对应的接口服务\n        Object cacheObj = SpringCtxUtils.getBean(clz);\n        \n        // 然后通过接口方法名和接口方法参数\n        if (cacheObj.getClass().getName().equals(className)) {\n            // 来精准定位需要提供方接口服务中的哪个方法进行处理\n            if (\"sayHello\".equals(mtdName) &amp;&amp; String.class.getName().equals(parameterTypeName)) {\n                // 真正的发起对源对象（被代理对象）的方法调用\n                return ((DemoFacade) cacheObj).sayHello(reqParamsStr);\n            } else if(\"say\".equals(mtdName) &amp;&amp; Void.class.getName().equals(parameterTypeName)){\n                // 真正的发起对源对象（被代理对象）的方法调用\n                return ((DemoFacade) cacheObj).say();\n            }\n            \n            // 如果找不到的话，就抛出异常，提示方法不存在\n            throw new RuntimeException(String.join(\".\", className, mtdName) + \" 的方法不存在\");\n        }\n        \n        // 如果找不到的话，就抛出异常，提示类不存在\n        throw new RuntimeException(className + \" 类不存在\");\n    }\n}\n</code></pre><p>代码中的实现思路和图是一样的，只是在写的过程中，我们发现了一个比较不爽的地方，就是这段 if…else 的逻辑代码。</p><pre><code class=\"language-java\">// 来精准定位需要提供方接口服务中的哪个方法进行处理\nif (\"sayHello\".equals(mtdName) &amp;&amp; String.class.getName().equals(parameterTypeName)) {\n    // 真正的发起对源对象（被代理对象）的方法调用\n    return ((DemoFacade) cacheObj).sayHello(reqParamsStr);\n} else if(\"say\".equals(mtdName) &amp;&amp; Void.class.getName().equals(parameterTypeName)){\n    // 真正的发起对源对象（被代理对象）的方法调用\n    return ((DemoFacade) cacheObj).say();\n}\n</code></pre><p>不停地利用 if…else 逻辑找到不同方法名对应方法逻辑，让提供方服务的统一入口外表看起来光鲜靓丽，内部实现其实丑陋不堪，一旦将来接口新增了方法，这里的 if…else 逻辑又得继续扩充，没完没了，永无止境。</p><p>你肯定也想到了，能不能把这段 if…else 逻辑去掉呢，最好变成更通用的逻辑，不感知方法名和方法参数就能直接进行方法调用。于是，我们现在的问题是，<strong>一方面不想感知各种方法名，另一方面，方法调用必定是有方法名的，这该如何是好呢？</strong></p><p>这里分享架构中最经典的一句话：“没有什么是加一层解决不了的，如果加一层不行，就再加一层”。既然调用必定要有方法，那干脆在各种 if…else 的方法前面再加一层，先调用代理方法名，然后让代理方法名的实现逻辑，拥有根据入参调用各种接口服务方法的能力。就是这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/fa/b91da4e352be6f6246763e738f5356fa.jpg?wh=5052x1791\" alt=\"图片\"></p><p>乍一看，这新加的一层不就像找了个中间商，中间商拥有各种服务资源，每种资源内部能自动根据入参，再次通过反射调用具体的接口服务方法。</p><p>兴奋的你立马写出来这样的代码。</p><pre><code class=\"language-java\">///////////////////////////////////////////////////\n// 提供方服务：统一入口接收请求的控制器，反射改善后的方式\n///////////////////////////////////////////////////\n@RestController\npublic class CommonController {\n    // 定义URL地址\n    @PostMapping(\"gateway/{className}/{mtdName}/{parameterTypeName}/request\")\n    public String recvCommonRequest(@PathVariable String className,\n                                    @PathVariable String mtdName,\n                                    @PathVariable String parameterTypeName,\n                                    @RequestBody String reqBody) throws Exception {\n        // 统一的接收请求的入口\n        return commonInvoke(className, parameterTypeName, mtdName, reqBody);\n    }\n    \n    /**\n     * &lt;h2&gt;统一入口的核心逻辑。&lt;/h2&gt;\n     *\n     * @param className：接口归属方法的全类名。\n     * @param mtdName：接口的方法名。\n     * @param parameterTypeName：接口的方法入参的全类名。\n     * @param reqParamsStr：请求数据。\n     * @return 接口方法调用的返回信息。\n     * @throws Exception\n     */\n    public static String commonInvoke(String className,\n                                      String mtdName,\n                                      String parameterTypeName,\n                                      String reqParamsStr) throws Exception {\n        // 通过反射机制可以获取接口类名对应的类对象\n        Class&lt;?&gt; clz = Class.forName(className);\n        \n        // 接着通过类对象的简称获取到对应的接口服务的【代理对象】\n        // 相当于不同的 clz 就会获取不同的代理对象，各个代理对象代理的源对象都不一样的\n        ProxyInvoker proxyInvoker = SpringCtxUtils.getBean(clz);\n        \n        // 【代理对象】调用自身的统一方法，然后内部会去识别方法名、方法参数调用不同的方法\n        return proxyInvoker.invoke(clz, mtdName, parameterTypeName, reqParamsStr);\n    }\n    \n    ///////////////////////////////////////////////////\n    // 提供方服务：模拟的是其中一个代理类结构样子\n    ///////////////////////////////////////////////////\n    public class ProxyInvoker$1 extends ProxyInvoker {\n        // 暴露的统一被调用的方法\n        public Object invoke(Class&lt;?&gt; clz,\n                             String mtdName,\n                             String parameterTypeName,\n                             String reqParamsStr){\n            // 通过反射找到方法对应的 Method 对象\n            Method method = clz.getDeclaredMethod(mtdName, Class.forName(parameterTypeName));\n            method.setAccessible(true);\n            // 反射调用\n            return method.invoke(getSourceTarget(), reqParamsStr);\n        }\n    }\n}\n</code></pre><p>代码中的改善点也很简单，主要有 2 点。</p><ul>\n<li>之前通过接口类名找接口服务对象，变成了<strong>找服务资源</strong>，即接口服务代理对象。</li>\n<li>之前通过 if…else 逻辑进行的方法调用，变成了<strong>通过方法的反射调用</strong>。</li>\n</ul><p>现在简单改善后，你是不是发现好像也蛮通用的，这就是 JDK 的动态代理模式，会动态生成一个继承 Proxy 的代理类。</p><p>为什么 Dubbo 不用 JDK 的代理模式呢？难道刚刚的改善代码有什么性能隐患么？其实有没有性能隐患，我们循环验证一把就知道了，看代码。</p><pre><code class=\"language-java\">///////////////////////////////////////////////////\n// 反射性能耗时测试类\n///////////////////////////////////////////////////\npublic class ReflectBenchmarkTest {\n    public static void main(String[] args) {\n        // 定义一个 size 变量为：100万\n        int size = 1000000;\n        // 循环正常创建类调用某个方法，并打印耗时的时间\n        long start = System.currentTimeMillis();\n        for (int i = 0; i &lt; size; i++) {\n            normalInvoke();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"正常调用耗时为：\" + (end - start) + \" 毫秒\");\n        \n        // 循环反射创建类调用某个方法，并打印耗时的时间\n        start = System.currentTimeMillis();\n        for (int i = 0; i &lt; size; i++) {\n            reflectInvoke();\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"反射调用耗时为：\" + (end - start) + \" 毫秒\");\n    }\n    \n    // 正常创建对象，并调用对象的方法\n    public static void normalInvoke(){\n        // 普通的创建对象\n        CustomSpi customSpi = new CustomSpi();\n        // 普通的调用对象的方法\n        customSpi.getDefaultPort();\n    }\n    \n    // 反射创建对象，并反射调用对象的方法\n    public static void reflectInvoke(){\n        try {\n            // 反射拿到对象信息\n            Class&lt;?&gt; clz = Class.forName(\"com.hmilyylimh.cloud.wrapper.spi.CustomSpi\");\n            // 反射创建对象\n            Object o = clz.newInstance();\n            // 反射想办法从 clz 中拿到 getDefaultPort 方法对象\n            Method method = clz.getDeclaredMethod(\"getDefaultPort\");\n            // 反射调用方法\n            method.invoke(o);\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>代码也非常简单，一段是正常创建对象并调用对象的方法，一段是反射创建对象并反射调用对象的方法，然后各自循环调用一百万次看耗时，看运行结果。</p><pre><code class=\"language-plain\">正常调用耗时为：5 毫秒\n反射调用耗时为：745 毫秒\n</code></pre><p>从打印的日志上可以明显看到，反射确实比较耗时，而 Dubbo 本身是一款追求高性能的调用框架，反射层面的各种耗时开销是不能容忍的，因此这是 JDK 代理的一个不足。</p><h3>2. Cglib 代理</h3><p>既然 JDK 动态代理会有反射性能开销的话，那 Cglib 总不会了吧。毕竟 Cglib 的核心原理，就是通过执行拦截器的回调方法（methodProxy.invokeSuper），从代理类的众多方法引用中匹配正确方法，并执行被代理类的方法。</p><p>Cglib的这种方式，就像代理类的内部动态生成了一堆的 if…else 语句来调用被代理类的方法，避免了手工写各种 if…else 的硬编码逻辑，省去了不少硬编码的活。</p><p>但是这么一来，如何生成动态代理类的逻辑就至关重要了，而且万一我们以后有自主定制的诉求，想修改这段生成代理类的这段逻辑，反而受 Cglib 库的牵制。</p><p>因此为了长远考虑，我们还是自己实现一套有 Cglib 思想的方案更好，并且还可以在此思想上，利用最简单的代码，定制适合自己框架的代理类。这其实也是Dubbo的想法。</p><h3>3.自定义代理</h3><p>好，我们总结下使用 JDK 和 Cglib 代理的一些顾虑。</p><ul>\n<li>JDK 代理，核心实现是进行反射调用，性能损耗不小。</li>\n<li>Cglib 代理，核心实现是生成了各种 if…else 代码来调用被代理类的方法，但是这块生成代理的逻辑不够灵活，难以自主修改。</li>\n</ul><p>基于这两点，我们考虑综合一下，<strong>在 Cglib 的思想之上采用自主实现，并且不使用反射机制</strong>。直白点就是，自己打造一个简化版的迷你型 Cglib 代理工具，这样一来，就可以在自己的代理工具中做各种与框架密切相关的逻辑了。</p><p>既然要自己生成代理类，就得先按照一个代码模板来编码，我们来设计代码模板：</p><pre><code class=\"language-java\">///////////////////////////////////////////////////\n// 代码模板\n///////////////////////////////////////////////////\npublic class $DemoFacadeCustomInvoker extends CustomInvoker {\n    @Override\n    public Object invokeMethod(Object instance, String mtdName, Class&lt;?&gt;[] types, Object[] args) throws NoSuchMethodException {\n        // 这里就是进行简单的 if 代码判断\n        if (\"sayHello\".equals(mtdName)) {\n            return ((DemoFacade) instance).sayHello(String.valueOf(args[0]));\n        }\n        if (\"say\".equals(mtdName)) {\n            return ((DemoFacade) instance).say();\n        }\n        throw new NoSuchMethodException(\"Method [\" + mtdName + \"] not found.\");\n    }\n}\n</code></pre><p>有 3 个细节点需要注意。</p><ol>\n<li>类名是 $ 符号开头的，表示是定制的代理类名。</li>\n<li>定义了一个父类 CustomInvoker，父类只有一个 invokeMethod 方法，并且是空实现。</li>\n<li>代理类重写 invokeMethod 方法后，内部通过 if…else 判断走进不同的方法分支，然后把代理类强转为被代理类，使用强转后的对象进行方法调用，省去了反射调用。</li>\n</ol><p>有了代码模板，我们对照着代码模板用 Java 语言编写生成出来。</p><pre><code class=\"language-java\">///////////////////////////////////////////////////\n// 自定义代理生成工具类\n///////////////////////////////////////////////////\npublic class CustomInvokerProxyUtils {\n    private static final AtomicInteger INC = new AtomicInteger();\n       \n    // 创建源对象（被代理对象）的代理对象\n    public static Object newProxyInstance(Object sourceTarget) throws Exception{\n        String packageName = \"com.hmilyylimh.cloud.wrapper.custom\";\n        // filePath = /E:/工程所在的磁盘路径/dubbo-15-dubbo-wrapper/target/classes/com/hmilyylimh/cloud/wrapper/custom\n        String filePath = CustomInvokerProxyUtils.class.getResource(\"/\").getPath()\n                + CustomInvokerProxyUtils.class.getPackage().toString().substring(\"package \".length()).replaceAll(\"\\\\.\", \"/\");\n        Class&lt;?&gt; targetClazz = sourceTarget.getClass().getInterfaces()[0];\n        // proxyClassName = $DemoFacadeCustomInvoker_1\n        String proxyClassName = \"$\" + targetClazz.getSimpleName() + \"CustomInvoker_\" + INC.incrementAndGet();\n        // 获取代理的字节码内容\n        String proxyByteCode = getProxyByteCode(packageName, proxyClassName, targetClazz);\n        // 缓存至磁盘中\n        file2Disk(filePath, proxyClassName, proxyByteCode);\n        // 等刷盘稳定后\n        TimeUtils.sleep(2000);\n        // 再编译java加载class至内存中\n        Object compiledClazz = compileJava2Class(filePath, packageName, proxyClassName, sourceTarget, targetClazz);\n        // 返回实例化的对象\n        return compiledClazz;\n    }\n    // 生成代理的字节码内容，其实就是一段类代码的字符串\n    private static String getProxyByteCode(String packageName, String proxyClassName, Class&lt;?&gt; targetClazz) {\n        StringBuilder sb = new StringBuilder();\n        // pkgContent = package com.hmilyylimh.cloud.wrapper.custom;\n        String pkgContent = \"package \" + packageName + \";\";\n        // importTargetClazz = import com.hmilyylimh.cloud.facade.demo.DemoFacade;\n        String importTargetClazz = \"import \" + targetClazz.getName() + \";\";\n        // importNoSuchMethodException = import org.apache.dubbo.common.bytecode.NoSuchMethodException;\n        String importNoSuchMethodException = \"import \" + org.apache.dubbo.common.bytecode.NoSuchMethodException.class.getName() + \";\";\n        // classHeadContent = public class $DemoFacadeCustomInvoker extends CustomInvoker {\n        String classHeadContent = \"public class \" + proxyClassName + \" extends \" + CustomInvoker.class.getSimpleName() + \" {\" ;\n        // 添加内容\n        sb.append(pkgContent).append(importTargetClazz).append(importNoSuchMethodException).append(classHeadContent);\n        // invokeMethodHeadContent = public Object invokeMethod(Object instance, String mtdName, Class&lt;?&gt;[] types, Object[] args) throws NoSuchMethodException {\n        String invokeMethodHeadContent = \"public \" + Object.class.getName() + \" invokeMethod\" +\n                \"(\" + Object.class.getName() + \" instance, \"\n                + String.class.getName() + \" mtdName, \" + Class.class.getName() + \"&lt;?&gt;[] types, \"\n                + Object.class.getName() + \"[] args) throws \" + org.apache.dubbo.common.bytecode.NoSuchMethodException.class.getName() + \" {\\n\";\n        sb.append(invokeMethodHeadContent);\n        for (Method method : targetClazz.getDeclaredMethods()) {\n            String methodName = method.getName();\n            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();\n            // if (\"sayHello\".equals(mtdName)) {\n            String ifHead = \"if (\\\"\" + methodName + \"\\\".equals(mtdName)) {\\n\";\n            // return ((DemoFacade) instance).sayHello(String.valueOf(args[0]));\n            String ifContent = null;\n            // 这里有 bug ，姑且就入参就传一个入参对象吧\n            if(parameterTypes.length != 0){\n                ifContent = \"return ((\" + targetClazz.getName() + \") instance).\" + methodName + \"(\" + String.class.getName() + \".valueOf(args[0]));\\n\";\n            } else {\n                ifContent = \"return ((\" + targetClazz.getName() + \") instance).\" + methodName + \"();\\n\";\n            }\n            // }\n            String ifTail = \"}\\n\";\n            sb.append(ifHead).append(ifContent).append(ifTail);\n        }\n        // throw new NoSuchMethodException(\"Method [\" + mtdName + \"] not found.\");\n        String invokeMethodTailContent = \"throw new \" + org.apache.dubbo.common.bytecode.NoSuchMethodException.class.getName() + \"(\\\"Method [\\\" + mtdName + \\\"] not found.\\\");\\n}\\n\";\n        sb.append(invokeMethodTailContent);\n        // 类的尾巴大括号\n        String classTailContent = \" } \";\n        sb.append(classTailContent);\n        return sb.toString();\n    }\n    private static void file2Disk(String filePath, String proxyClassName, String proxyByteCode) throws IOException {\n        File file = new File(filePath + File.separator + proxyClassName + \".java\");\n        if (!file.exists()) {\n            file.createNewFile();\n        }\n        FileWriter fileWriter = new FileWriter(file);\n        fileWriter.write(proxyByteCode);\n        fileWriter.flush();\n        fileWriter.close();\n    }\n    private static Object compileJava2Class(String filePath, String packageName, String proxyClassName, Object argsTarget, Class&lt;?&gt; targetClazz) throws Exception {\n        // 编译 Java 文件\n        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);\n        Iterable&lt;? extends JavaFileObject&gt; compilationUnits =\n                fileManager.getJavaFileObjects(new File(filePath + File.separator + proxyClassName + \".java\"));\n        JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, null, null, null, compilationUnits);\n        task.call();\n        fileManager.close();\n        // 加载 class 文件\n        URL[] urls = new URL[]{new URL(\"file:\" + filePath)};\n        URLClassLoader urlClassLoader = new URLClassLoader(urls);\n        Class&lt;?&gt; clazz = urlClassLoader.loadClass(packageName + \".\" + proxyClassName);\n        // 反射创建对象，并且实例化对象\n        Constructor&lt;?&gt; constructor = clazz.getConstructor();\n        Object newInstance = constructor.newInstance();\n        return newInstance;\n    }\n}\n</code></pre><p>生成的代码主要有三个步骤。</p><ol>\n<li>按照代码模板的样子，使用 Java 代码动态生成出来一份代码字符串。</li>\n<li>将生成的代码字符串保存到磁盘中。</li>\n<li>根据磁盘文件路径将文件编译为 class 文件，然后利用 URLClassLoader 加载至内存变成 Class 对象，最后反射创建对象并且实例化对象。</li>\n</ol><p>你有没有发现，生成一个代理类没有想象中的那么难，只需要按部就班一步步实现就行了。</p><p>接下来我们就使用代理工具类，生成代理类并调用方法看看。</p><pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n    // 创建源对象（即被代理对象）\n    DemoFacadeImpl demoFacade = new DemoFacadeImpl();\n    // 生成自定义的代理类\n    CustomInvoker invoker = \n         (CustomInvoker)CustomInvokerProxyUtils.newProxyInstance(demoFacade);\n    // 调用代理类的方法\n    invoker.invokeMethod(demoFacade, \"sayHello\", new Class[]{String.class}, new Object[]{\"Geek\"});\n}\n</code></pre><p>使用起来也非常方便，就三步。</p><ul>\n<li>首先，自己创建一个源对象。</li>\n<li>然后，通过代理工具类将源对象变成一个代理对象。</li>\n<li>最后，调用代理对象的方法就可以了。</li>\n</ul><h2>Wrapper 机制的原理</h2><p>通过一番自定义实现后，想必你已经理解了 Dubbo 的用意了，我们来看看源码层面Dubbo是怎么生成代理类的，有哪些值得关注的细节。</p><pre><code class=\"language-java\">// org.apache.dubbo.rpc.proxy.javassist.JavassistProxyFactory#getInvoker\n// 创建一个 Invoker 的包装类\n@Override\npublic &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {\n    // 这里就是生成 Wrapper 代理对象的核心一行代码\n    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') &lt; 0 ? proxy.getClass() : type);\n    // 包装一个 Invoker 对象\n    return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {\n        @Override\n        protected Object doInvoke(T proxy, String methodName,\n                                  Class&lt;?&gt;[] parameterTypes,\n                                  Object[] arguments) throws Throwable {\n            // 使用 wrapper 代理对象调用自己的 invokeMethod 方法\n            // 以此来避免反射调用引起的性能开销\n            // 通过强转来实现统一方法调用\n            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n        }\n    };\n}\n</code></pre><p>代码外表看起来很简单，内部的调用情况还是很深的，这里我也总结了代码调用流程图：</p><p><img src=\"https://static001.geekbang.org/resource/image/99/c6/9939c9abb9879cd4c65c2yy7c11430c6.jpg?wh=1920x788\" alt=\"图片\"></p><p>生成代理类的流程总结起来有 3 点。</p><ol>\n<li>以源对象的类属性为维度，与生成的代理类建立缓存映射关系，避免频繁创建代理类影响性能。</li>\n<li>生成了一个继承 Wrapper 的动态类，并且暴露了一个公有 invokeMethod 方法来调用源对象的方法。</li>\n<li>在invokeMethod 方法中，通过生成的 if…else 逻辑代码来识别调用源对象的不同方法。</li>\n</ol><p>看源码可能比较枯燥，我们还是来使用一下 Wrapper 机制，方便你更直观地理解，使用方式如下：</p><pre><code class=\"language-java\">public class InvokeDemoFacade {\n    public static void main(String[] args) throws Exception {\n        // 创建一个源对象（即被代理类）\n        DemoFacadeImpl demoFacade = new DemoFacadeImpl();\n        // 使用 Wrapper 机制获取一个继承  Wrapper 的代理类\n        final Wrapper wrapper = Wrapper.getWrapper(demoFacade.getClass());\n        // 使用生成的 wrapper 代理类调用通用的 invokeMethod 方法获取结果\n        Object result = wrapper.invokeMethod(\n                demoFacade,\n                \"sayHello\",\n                new Class[]{String.class},\n                new Object[]{\"Geek\"}\n        );\n        // 然后打印调用的结果\n        System.out.println(\"wrapper调用结果为：\" + result);\n    }\n}\n</code></pre><p>然后把生成是 wrapper 代理类 class 文件反编译为 Java 代码，看看生成的内容到底长什么样的。</p><pre><code class=\"language-java\">///////////////////////////////////////////////////\n// Wrapper.getWrapper(demoFacade.getClass()) \n// 这句代码生成出来的 wrapper 代理对象，对应类的代码结构\n///////////////////////////////////////////////////\npackage com.hmilyylimh.cloud.wrapper.demo;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Map;\nimport org.apache.dubbo.common.bytecode.NoSuchMethodException;\nimport org.apache.dubbo.common.bytecode.NoSuchPropertyException;\nimport org.apache.dubbo.common.bytecode.Wrapper;\nimport org.apache.dubbo.common.bytecode.ClassGenerator.DC;\n// Dubbo 框架生成代理类的类名为 DemoFacadeImplDubboWrap0，\n// 然后也继承了一个 Wrapper 对象，需要一个 invokeMethod 方法来统一调用\npublic class DemoFacadeImplDubboWrap0 extends Wrapper implements DC {\n    public static String[] pns;\n    public static Map pts;\n    public static String[] mns;\n    public static String[] dmns;\n    public static Class[] mts0;\n    public static Class[] mts1;\n    public String[] getPropertyNames() { return pns; }\n    public boolean hasProperty(String var1) { return pts.containsKey(var1); }\n    public Class getPropertyType(String var1) { return (Class)pts.get(var1); }\n    public String[] getMethodNames() { return mns; }\n    public String[] getDeclaredMethodNames() { return dmns; }\n    public void setPropertyValue(Object var1, String var2, Object var3) {\n        try {\n            DemoFacadeImpl var4 = (DemoFacadeImpl)var1;\n        } catch (Throwable var6) {\n            throw new IllegalArgumentException(var6);\n        }\n        throw new NoSuchPropertyException(\"Not found property \\\"\" + var2 + \"\\\" field or setter method in class com.hmilyylimh.cloud.wrapper.demo.DemoFacadeImpl.\");\n    }\n    public Object getPropertyValue(Object var1, String var2) {\n        try {\n            DemoFacadeImpl var3 = (DemoFacadeImpl)var1;\n        } catch (Throwable var5) {\n            throw new IllegalArgumentException(var5);\n        }\n        throw new NoSuchPropertyException(\"Not found property \\\"\" + var2 + \"\\\" field or getter method in class com.hmilyylimh.cloud.wrapper.demo.DemoFacadeImpl.\");\n    }\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!\n    // 重点看这里，这才是调用的关键代码\n    // 这里也动态生成了 if...else 代码\n    // 然后通过强转调用源对象（被代理对象）的方法\n    public Object invokeMethod(Object var1, String var2, Class[] var3, Object[] var4) throws InvocationTargetException {\n        DemoFacadeImpl var5;\n        try {\n            var5 = (DemoFacadeImpl)var1;\n        } catch (Throwable var8) {\n            throw new IllegalArgumentException(var8);\n        }\n        try {\n            if (\"sayHello\".equals(var2) &amp;&amp; var3.length == 1) {\n                return var5.sayHello((String)var4[0]);\n            }\n            if (\"say\".equals(var2) &amp;&amp; var3.length == 0) {\n                return var5.say();\n            }\n        } catch (Throwable var9) {\n            throw new InvocationTargetException(var9);\n        }\n        throw new NoSuchMethodException(\"Not found method \\\"\" + var2 + \"\\\" in class com.hmilyylimh.cloud.wrapper.demo.DemoFacadeImpl.\");\n    }\n    public DemoFacadeImplDubboWrap0() {\n    }\n}\n</code></pre><p>从反编译的 java 代码中，看这个重要的 invokeMethod 方法，内部生成了一堆 if 代码来判断调用不同的被代理对象的方法，细心的你，可能已经发现了，其实就是将我们最初朴实无华的代码变成动态生成而已，不再需要人工手动硬编码了。</p><p>我们最后比较一下正常调用、反射调用、Wrapper调用的耗时情况，新增Wrapper调用的部分代码。</p><pre><code class=\"language-java\">// 循环进行Wrapper调用，并打印耗时的时间\nCustomSpi customSpi = new CustomSpi();\nfinal Wrapper wrapper = Wrapper.getWrapper(customSpi.getClass());\nstart = System.currentTimeMillis();\nfor (int i = 0; i &lt; size; i++) {\n    wrapperInvoke(wrapper, customSpi);\n}\nend = System.currentTimeMillis();\nSystem.out.println(\"Wrapper调用耗时为：\" + (end - start) + \" 毫秒\");\n\n// wrapper 调用的方法，还是调用 CustomSpi 的 getDefaultPort 方法\npublic static void wrapperInvoke(Wrapper wrapper, Object reqObj){\n    try {\n        // 使用生成的 wrapper 代理类调用通用的 invokeMethod 方法获取结果\n        wrapper.invokeMethod(\n                reqObj,\n                \"getDefaultPort\",\n                new Class[]{},\n                new Object[]{}\n        );\n    } catch (Throwable e) {\n        e.printStackTrace();\n    }\n}\n</code></pre><p>结果耗时为情况。</p><pre><code class=\"language-java\">正常调用耗时为：8 毫秒\n反射调用耗时为：2019 毫秒\nWrapper调用耗时为：12 毫秒\n</code></pre><p>改善后的效果还是很可观的，与直接拿着对象进行调用相差无几，这也是 Dubbo 高性能的魅力所在。</p><h2>Wrapper 机制的利弊</h2><p>Wrapper机制既然这么牛，难道我们可以摒弃已有的 JDK 和 Cglib 代理了么？其实不是的，使用时也有利弊之分的。</p><p>Wrapper机制，对于搭建高性能的底层调用框架还是非常高效的，而且开辟了一条直接通过Java代码生成代理类的简便途径，为框架的未来各种定制扩展，提供了非常灵活的自主控制权。但不适合大众化，因为Wrapper机制定制化程度高，对维护人员会有较高的开发门槛要求。</p><h2>总结</h2><p>今天，我们从在提供方服务设计统一入口来接收各种请求的案例开始，进行分析与改造。</p><ul>\n<li>最朴实无华的 if…else 逻辑进行各种 case 分支处理，但是硬编码逻辑不易维护。</li>\n<li>叠加一层代理类来进行反射调用，做到了比较灵活的动态扩展，这也是 JDK 动态代理的方式，但在耗时开销上有性能问题。</li>\n<li>而Cglib 的代理实现逻辑，符合改造诉求，但是对于定制生成代理类的灵活需求，还得受 Cglib 库的牵制。</li>\n</ul><p>综合两个代理的不足，我们打造了一个迷你型的 Cglib 代理工具，也与 Dubbo 的 Wrapper 机制的实现思想有着异曲同工之妙。</p><p>这里也总结下自定义生成代理类的三部曲。</p><ul>\n<li>首先，想办法设计出一套代码模板，这套代码模板具备指定业务场景的通用性，这样才方便进行统一代理。</li>\n<li>然后，通过手写Java代码或者通过市场上的字节码工具，最终按照代码模板的要求生成出一套动态的代码。</li>\n<li>最后，将动态的代码通过JDK编译或者通过字节码工具，最终想办法生成 Class 对象，就可以拿着 Class 对象进行方法调用了。</li>\n</ul><h3>思考题</h3><p>在分析过程中，我们针对反射进行了性能测试，发现反射确实是比较耗费性能的。留个作业给你，研究下 java.lang.Class#getDeclaredMethod 方法，总结出这个方法的调用流程，排查下存在哪些耗时和占用内存的地方？</p><p>期待看到你的思考，如果你对今天的内容还有什么困惑，欢迎在留言区提问，我会第一时间回复。我们下一讲见。</p><h3>14 思考题参考</h3><p>上一期留了两个作业。</p><ol>\n<li>研究 Dubbo SPI 的底层加载逻辑。</li>\n<li>总结 Spring SPI 的使用步骤。</li>\n</ol><h4>作业一</h4><p>要想弄懂 Dubbo SPI 的底层加载逻辑，其实也比较简单，我们还是按照惯例，从报错的日志来慢慢了解 Dubbo SPI 的底层逻辑是什么。</p><p>我们还是以刚刚 Dubbo SPI 的案例代码为基础，将“/META-INF/services/com.hmilyylimh.cloud.dubbo.spi.IDemoSpi”该文件删掉，然后运行 Dubbo14DubboSpiApplication 应用程序，结果报错如下。</p><pre><code class=\"language-java\">Exception in thread \"main\" java.lang.IllegalStateException: No such extension com.hmilyylimh.cloud.dubbo.spi.IDemoSpi by name customSpi, no related exception was found, please check whether related SPI module is missing.\n\tat org.apache.dubbo.common.extension.ExtensionLoader.findException(ExtensionLoader.java:747)\n\tat org.apache.dubbo.common.extension.ExtensionLoader.createExtension(ExtensionLoader.java:754)\n\tat org.apache.dubbo.common.extension.ExtensionLoader.getExtension(ExtensionLoader.java:548)\n\tat org.apache.dubbo.common.extension.ExtensionLoader.getExtension(ExtensionLoader.java:523)\n\tat com.hmilyylimh.cloud.dubbo.Dubbo14DubboSpiApplication.main(Dubbo14DubboSpiApplication.java:17)\n</code></pre><p>从报错信息中，你也看到了，提示没有一个叫做 customSpi 名字的扩展点，离报错信息最近的一行代码为“ExtensionLoader.findException(ExtensionLoader.java:747)”，我们进入 ExtensionLoader 的 747 行去看看。</p><pre><code class=\"language-java\">private T createExtension(String name, boolean wrap) {\n    // 从扩展点集合中获取叫 name 的指定扩展点\n    Class&lt;?&gt; clazz = getExtensionClasses().get(name);\n    // 如果获取不到的话，或者含有重复名字的实现类的话\n    // 都会进入 findException 方法进行抛异常处理\n    if (clazz == null || unacceptableExceptions.contains(name)) {\n        throw findException(name);\n    }\n    // 此处省略若干行代码...\n}    \n</code></pre><p>由此可见，到底有没有扩展点集合或者到底怎么加载的，完全在于“getExtensionClasses()”该方法是怎么处理的，于是进入该方法看看。</p><pre><code class=\"language-java\">// 获取该接口的所有扩展点集合\nprivate Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() {\n    // 先从缓存里面取，看看有没有该接口的扩展点集合\n    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();\n    // 如果没有任何缓存的话\n    if (classes == null) {\n        // 则采用双检索的形式保证线程安全粒度去读取磁盘文件加载扩展点\n        synchronized (cachedClasses) {\n            classes = cachedClasses.get();\n            if (classes == null) {\n                // 真正加载扩展点的逻辑\n                classes = loadExtensionClasses();\n                // 如果加载到的话，则放入到缓存中，下一次就可以直接从缓存中取了\n                cachedClasses.set(classes);\n            }\n        }\n    }\n    return classes;\n}\n                  ↓\n// 正在加载扩展点的逻辑\nprivate Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {\n    // 此处省略若干行代码...\n    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;&gt;();\n    for (LoadingStrategy strategy : strategies) {\n        // 按照每种磁盘路径的策略去加载磁盘文件\n        loadDirectory(extensionClasses, strategy, type.getName());\n        // compatible with old ExtensionFactory\n        if (this.type == ExtensionInjector.class) {\n            loadDirectory(extensionClasses, strategy, ExtensionFactory.class.getName());\n        }\n    }\n    return extensionClasses;\n}\n                  ↓\n// 查看加载磁盘的策略有哪些，发现是一个方法\nprivate static volatile LoadingStrategy[] strategies = loadLoadingStrategies();\n                  ↓\n// 继续查看该方法的逻辑，结果发现该方法加载了 LoadingStrategy 接口的所有实现类\nprivate static LoadingStrategy[] loadLoadingStrategies() {\n    return stream(load(LoadingStrategy.class).spliterator(), false)\n        .sorted()\n        .toArray(LoadingStrategy[]::new);\n}\n                  ↓\n// LoadingStrategy 实现类之一，重点关注 directory 方法\npublic class DubboInternalLoadingStrategy implements LoadingStrategy {\n    @Override\n    public String directory() {\n        return \"META-INF/dubbo/internal/\";\n    }\n    // 此处省略若干行代码...\n}\n                  ↓\n// LoadingStrategy 实现类之一，重点关注 directory 方法\npublic class DubboLoadingStrategy implements LoadingStrategy {\n    @Override\n    public String directory() {\n        return \"META-INF/dubbo/\";\n    }\n    // 此处省略若干行代码...\n}\n                  ↓\n// LoadingStrategy 实现类之一，重点关注 directory 方法\npublic class ServicesLoadingStrategy implements LoadingStrategy {\n    @Override\n    public String directory() {\n        return \"META-INF/services/\";\n    }\n    // 此处省略若干行代码...\n}\n</code></pre><p>简单跟踪代码后，发现原来我们可以在三个路径下添加SPI机制的文件，分别为。</p><ul>\n<li>META-INF/dubbo/internal/</li>\n<li>META-INF/dubbo/</li>\n<li>META-INF/services/</li>\n</ul><p>真相也清楚了，Dubbo 框架会从这 3 个资源目录下去加载 SPI 机制的文件，只不过从路径的名称上可以看出，META-INF/dubbo/internal/ 存放的是 Dubbo 内置的一些扩展点，META-INF/services/ 存放的是 Dubbo 自身的一些业务逻辑所需要的一些扩展点，而 META-INF/dubbo/ 存放的是上层业务系统自身的一些定制 Dubbo 的相关扩展点。</p><h4>作业二</h4><p>Spring 中的 SPI 相比于 JDK 原生的，功能也很强大，主是通过 org.springframework.core.io.support.SpringFactoriesLoader#loadFactories 方法读取所有 jar 包的“META-INF/spring.factories”资源文件，并从文件中读取一堆的类似 EnableAutoConfiguration 标识的类路径，将这些类创建对应的 Spring Bean 对象注入到容器中，就完成了 SpringBoot 的自动装配底层核心原理。</p><p>使用步骤也比较简单，只需要简单的两步。</p><ul>\n<li>首先，定义一个类，该类可加Spring的相关注解，也可以不加，完全看实际业务诉求。</li>\n<li>然后，然后将该类的类路径添加到“META-INF/spring.factories”文件中，举个样例如下：</li>\n</ul><pre><code class=\"language-java\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.hmilyylimh.cloud.HmilyRegistryAutoConfiguration\n</code></pre><p>spring.factories 除了可以 EnableAutoConfiguration 类型的类之外，还可以处理一些其他类型的类，我也总结了。</p><ol>\n<li>ApplicationContextInitializer</li>\n<li>ApplicationListener</li>\n<li>AutoConfigurationImportListener</li>\n<li>AutoConfigurationImportFilter</li>\n<li>EnableAutoConfiguration</li>\n<li>FailureAnalyzer</li>\n<li>TemplateAvailabilityProvider</li>\n</ol>","comments":[{"had_liked":false,"id":366822,"user_name":"斯瓦辛武Roy","can_delete":false,"product_type":"c1","uid":2087578,"ip_address":"浙江","ucode":"0A6AE232481B86","user_header":"https://static001.geekbang.org/account/avatar/00/1f/da/9a/ed524797.jpg","comment_is_top":false,"comment_ctime":1674348601,"is_pvip":false,"replies":[{"id":133690,"content":"你好，斯瓦辛武Roy：感谢感谢，对你有帮助我就已经非常开心啦。春节期间不会停更，一三五节奏不变哈～","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1674484461,"ip_address":"湖南","comment_id":366822,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"给老师点个赞，这样的底层代码真的有助于P6的进步，希望春节期间不停更哈","like_count":3,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600542,"discussion_content":"你好，斯瓦辛武Roy：感谢感谢，对你有帮助我就已经非常开心啦。春节期间不会停更，一三五节奏不变哈～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674484462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378659,"user_name":"王建新","can_delete":false,"product_type":"c1","uid":1934802,"ip_address":"北京","ucode":"E3151DDC0EEF0D","user_header":"https://static001.geekbang.org/account/avatar/00/1d/85/d2/045c63fb.jpg","comment_is_top":false,"comment_ctime":1690549821,"is_pvip":false,"replies":[{"id":138225,"content":"你好，王建新：别心急，认真仔细的深入看几遍，其中的原理相信你会体会到的。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1691889751,"ip_address":"广东","comment_id":378659,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"他到底是怎么代理生成那块if else的没看到原理呀","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625561,"discussion_content":"你好，王建新：别心急，认真仔细的深入看几遍，其中的原理相信你会体会到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691889751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1712567,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/bxaaILnBnJTuqJn7jwhI1H6cctcovDSkml3icvGdPRmWbPqGLjvrqk3X1DNibJcW1stqav2RmatcjABDTfjG3v8A/132","nickname":"Geek_d45d62","note":"","ucode":"E3D9986D233462","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625214,"discussion_content":"生成字节码那块","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691466053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368137,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"北京","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1675928681,"is_pvip":false,"replies":[{"id":134074,"content":"你好，张三丰：举个例子，假设 dubbo 是 A 开发的，Cglib 是 B 开发的，A 根本不认识 B，A 只是在 maven 仓库使用了 B 开发的 Cglib 来封装字节码，字节码的封装过程都是在 Cglib 完成。但是，如果哪天，A 认为封装字节码的核心逻辑想要调整下，那么 A 是不是得试图改 Cglib 源码，而 Cglib 是 B 开发的。A 为了实现自己的各种业务需要定制化修改 B 写的 Cglib，那么 B 凭什么会让别人各种修改自己的 Cglib 源码呢？\n\n大概就是这个意思，所以会受到一定的牵制。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1676020817,"ip_address":"广东","comment_id":368137,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"&quot;但是这么一来，如何生成动态代理类的逻辑就至关重要了，而且万一我们以后有自主定制的诉求，想修改这段生成代理类的这段逻辑，反而受 Cglib 库的牵制。&quot;\n\n老师，这个能举个例子么？  是怎么牵制的？","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603229,"discussion_content":"你好，张三丰：举个例子，假设 dubbo 是 A 开发的，Cglib 是 B 开发的，A 根本不认识 B，A 只是在 maven 仓库使用了 B 开发的 Cglib 来封装字节码，字节码的封装过程都是在 Cglib 完成。但是，如果哪天，A 认为封装字节码的核心逻辑想要调整下，那么 A 是不是得试图改 Cglib 源码，而 Cglib 是 B 开发的。A 为了实现自己的各种业务需要定制化修改 B 写的 Cglib，那么 B 凭什么会让别人各种修改自己的 Cglib 源码呢？\n\n大概就是这个意思，所以会受到一定的牵制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676020817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3785417,"avatar":"","nickname":"Geek_d6ec7e","note":"","ucode":"58935518631260","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632006,"discussion_content":"这个理由是不是有点牵强。 现实情况是会有人觉得cglib的源码需要调整吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700300283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}