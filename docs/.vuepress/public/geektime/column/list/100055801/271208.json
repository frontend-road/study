{"id":271208,"title":"08｜基本编程支持：规避、解决编程时的常见问题","content":"<p>你好，我是吴咏炜。</p><p>在前面的几讲里，我们已经学了很多使用 Vim 的基本知识。今天是编程专题，我来专门介绍一下 Vim 对编程的特别支持。学了这一讲之后，你会进一步了解 Vim 编辑程序时的重要特性，并能够规避、解决编程时的常见问题。</p><h2>文件类型和关联设定</h2><p>程序源代码通常由文件组成，每个文件都有一个关联的文件类型。这个文件类型决定了 Vim 对其进行处理的一些基本设定，可能包括：</p><ul>\n<li>如何对文件进行高亮</li>\n<li>制表符（tab）的宽度（空格数）</li>\n<li>是否在键入 <code>&lt;Tab&gt;</code> 时扩展为空格字符</li>\n<li>每次缩进的空格数（是的，可以和制表符宽度不同）</li>\n<li>采用何种自动缩进方法</li>\n<li>其他可适用的选项</li>\n</ul><p><strong>文件高亮</strong>通常需要一套相当复杂的规则，我们今天就只把它当成一个既成事实了，不讨论这些规则的细节。其他各项在 Vim 里一般以选项的形式出现。这些选项都是文件本地（local）选项，即可以在一个文件里修改其数值而不影响其他文件。对于这样的选项，可以用 <code>:setlocal</code> 和 <code>:setglobal</code> 命令分别访问本地值和全局值。一般的 <code>:set</code> 命令在读取数值时（如 <code>:set tabstop?</code>）返回本地值，在写入数值时（如 <code>:set tabstop=4</code>）同时设置本地值和全局值。</p><p><strong>制表符宽度</strong>对应的选项是 <code>tabstop</code>。这在不同的语言里可能有不同的惯例，自然不必多说。它的缺省值是 8，但在不同的文件里可以不一样。不同的文件类型也可能会自动设定不同的数值。</p><!-- [[[read_end]]] --><p>是否<strong>扩展 <code>&lt;Tab&gt;</code> 为空格</strong>由 <code>expandtab</code> 选项控制。我们前面看到过，但没有讲过，Vim 选项有些是用等号赋值的，也有些不用等号，而只用选项名称或选项名称前面加 <code>no</code>，表示否定。这些就是布尔类型选项，<code>expandtab</code> 也是其中之一。如果打开了 <code>expandtab</code> 选项，那输入中的 tab 会被转变成空格；如果关闭的话，则 tab 字符会被保留。</p><p>让事情变得更复杂的是，Vim 还有个 <code>softtabstop</code> 选项，<strong>软制表符宽度</strong>。一旦设置了这个选项为非零值，再键入 <code>&lt;Tab&gt;</code> 和 <code>&lt;BS&gt;</code>（退格键），你就感觉像设置了这个宽度的 <code>tabstop</code> 一样，有相应数量的缩进或取消缩进，但实际插入的字符仍然受 <code>expandtab</code> 和 <code>tabstop</code> 两个选项控制。在设置软制表符宽度时，一种最常用的用法是同时设置 <code>expandtab</code>，这样，编辑时你感觉像使用了这个宽度的制表符一样，但你输入的内容里实际被保存的仍然是空格字符。</p><p>这些还不是 Vim 真正使用的“缩进”值。以 C 语言为例，当 Vim 看到你输入“{”和回车键时，会自动产生一个缩进，而这个缩进值跟 <code>tabstop</code> 和 <code>softtabstop</code> 都无关，是一个独立的选项 <code>shiftwidth</code>。</p><p>最后，Vim 还有很多精细的选项来控制如何进行<strong>缩进</strong>。默认情况下，Vim 没有特殊缩进，回车键回到行首。一般而言，使用选项 <code>autoindent</code> 可以使 Vim 至少记住上一行的缩进位置；而对于特定语言，Vim 可以设置更合适的选项，达到更佳的缩进效果——如对类 C 语言 Vim 会设置 <code>cindent</code> 选项，达到最优的缩进效果。我们下面还会提到，Vim 支持对类 C 语言的缩进有一些精调选项，你也可以自己进一步进行调整。</p><hr><p>我之前提到过，Vim 会根据文件类型来设置选项。所以，相关问题就是，Vim 如何判断文件类型，如何根据文件类型来设置选项，以及我们该如何定制这些行为。我们下面就来一一作答。</p><h3>文件类型判断</h3><p>Vim 的文件类型判断是在 filetype.vim 中执行的。我们可以用下面的命令来打开这个文件：</p><pre><code class=\"language-vim\">:e $VIMRUNTIME/filetype.vim \n</code></pre><p>这个文件相当复杂，但有编程功底的你，应该可以看出大概的意思吧？其中最主要的逻辑仍然是通过后缀来进行判断，如：</p><pre><code class=\"language-vim\">\" C++\nau BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp\n</code></pre><p>其中 <code>au</code> 是 <code>autocmd</code> 的缩写，代表 Vim 在发生某事件时触发某一动作。上面说的就是在创建（<code>BufNewFile</code>）或读入（<code>BufRead</code>）跟指定文件名模式匹配的文件时，把文件类型设为 C++（<code>setf cpp</code>， <code>setf</code> 是 <code>setfiletype</code> 的缩写）。</p><p>但在后缀不足以唯一判断时，Vim 可以进一步执行代码，如：</p><pre><code class=\"language-vim\">au BufNewFile,BufRead *.h\t\t\tcall dist#ft#FTheader()\n</code></pre><p>上面函数的定义在文件 $VIMRUNTIME/autoload/dist/ft.vim 里：</p><pre><code class=\"language-vim\">func dist#ft#FTheader()\n  if match(getline(1, min([line(\"$\"), 200])), '^@\\(interface\\|end\\|class\\)') &gt; -1\n    if exists(\"g:c_syntax_for_h\")\n      setf objc\n    else\n      setf objcpp\n    endif\n  elseif exists(\"g:c_syntax_for_h\")\n    setf c\n  elseif exists(\"g:ch_syntax_for_h\")\n    setf ch\n  else\n    setf cpp\n  endif\nendfunc\n</code></pre><p>它的大概意思是，如果在头 200 行里找到某行以 <code>@interface</code> 等内容开始，那就认为这是 Objective-C/C++，否则认为是 C/C++。具体是 C 还是 C++，则由全局变量 <code>g:c_syntax_for_h</code> 控制（我们忽略 Ch 这种小众情况）。详细语法我们就不展开讲述了，留待讨论 Vim 脚本的时候再看。</p><p>上面讲的是 Vim 的缺省行为。我们当然也可以定制 Vim的行为。按照惯例，一般把定制放在用户 Vim 配置目录里的 filetype.vim 里。我的定制如下所示：</p><pre><code class=\"language-vim\">if exists(\"did_load_filetypes\")\n  finish\nendif\n\nfunction! s:CheckCPP()\n  if expand('%:t') !~ '\\.'\n    setfiletype cpp\n  endif\nendfunction\n\naugroup filetypedetect\n  au! BufRead,BufNewFile *.asm      setfiletype masm\n  au! BufRead proxy.pac             setfiletype javascript\n  au! BufRead */c++/*               call s:CheckCPP()\n  au! BufRead */include/*           call s:CheckCPP()\naugroup END\n</code></pre><p>我们可以跳过一些语法方面的细节，只讨论代码里的意图。上面这段代码主要做了以下事情：</p><ul>\n<li>当读入或创建后缀为“.asm”的文件时，设置文件类型为微软宏汇编（默认为 GNU 的汇编格式）。</li>\n<li>当读入名字为“proxy.pac”的文件时，把内容当成 JavaScript 解释。</li>\n<li>当读入路径含“c++”或“include”的文件时，调用脚本内部函数 <code>CheckCPP</code>，检查文件名（<code>%</code> 代表文件名，<code>:t</code> 代表尾部，即去掉路径部分）是否不含“.”，是的话当成 C++ 文件类型。这是为了处理像“memory”这样的无后缀 C++ 头文件。</li>\n<li>随后 Vim 会继续载入自带的 filetype.vim；如果文件类型还未确定的话，则继续使用 Vim 自带的规则进行判断。</li>\n</ul><h3>文件类型选项</h3><p>一旦确定了文件类型，Vim 会从运行支持文件目录下载入同名的文件。以 Python 为例：</p><ul>\n<li>syntax/python.vim 包含了如何对 Python 进行语法加亮的设置</li>\n<li>indent/python.vim 包含了如何对 Python 代码进行缩进的设置（如在用户输入 <code>if</code> 时进行缩进等）</li>\n<li>ftplugin/python.vim 是文件类型插件，包含了其他跟文件类型相关的设置</li>\n</ul><p>文件类型插件中包含我们上面提到的制表符宽度方面的设定，具体来说，是下面这几行：</p><pre><code class=\"language-vim\">if !exists(\"g:python_recommended_style\") || g:python_recommended_style != 0\n    \" As suggested by PEP8.\n    setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=8\nendif\n</code></pre><p>默认情况下，该文件使用 <a href=\"https://www.python.org/dev/peps/pep-0008/\">PEP 8</a> 推荐的设置：</p><ul>\n<li>把用户输入的制表符扩展成空格</li>\n<li>缩进和软制表符宽度设为 4</li>\n<li>如果文件中包含制表符的话，仍按宽度为 8 来解释</li>\n</ul><p>缩进和软制表符宽度设成 4 估计不需要解释，这应该是最常用的缩进值了。使用空格而不是制表符的最大好处是，在无论何种环境下，展示效果都可以完全一致，不会在 diff 时或制表符宽度不符合预期时代码就乱了。至于“硬”制表符宽度仍然是 8，则是为了确保显示文件的兼容性，尤其是在终端里 cat 文件时和在浏览器中浏览源代码时；这两种情况下，制表符宽度一般都是 8。</p><p>跟 Python 不同，很多其他文件类型没有推荐的风格设定，这时就应该用户自己进行设定了。我推荐在 vimrc 配置文件里进行设置，因为比较集中、容易管理。如：</p><pre><code class=\"language-vim\">au FileType c,cpp,objc  setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=4 cinoptions=:0,g0,(0,w1\nau FileType json        setlocal expandtab shiftwidth=2 softtabstop=2\nau FileType vim         setlocal expandtab shiftwidth=2 softtabstop=2\n</code></pre><p>上面设置了几种不同文件类型的编辑选项。大部分我们都已经知道了，下面这个则是新的：</p><ul>\n<li><code>cinoptions</code> 可以精调 C 风格缩进的方式；上面 <code>:0</code> 表示 <code>switch</code> 下面的 <code>case</code> 语句不进行额外缩进，<code>g0</code> 代表作用域声明（<code>public:</code>、<code>private:</code> 等）不额外缩进，<code>(0</code> 和 <code>w1</code> 配合代表没结束的圆括号里的内容折行时不额外缩进。</li>\n</ul><p>我们也可以根据文件类型以外的条件来进行设定，如下面设定是要把 /usr/include 目录下的文件按 <a href=\"https://www.gnu.org/prep/standards/\">GNU 编码风格</a>来解释：</p><pre><code class=\"language-vim\">function! GnuIndent()\n  setlocal cinoptions=&gt;4,n-2,{2,^-2,:2,=2,g0,h2,p5,t0,+2,(0,u0,w1,m1\n  setlocal shiftwidth=2\n  setlocal tabstop=8\nendfunction\n\nau BufRead /usr/include/*  call GnuIndent()\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/32/2e/327950d78fafccce8aab31db624aaf2e.png?wh=1396*1212\" alt=\"Fig8.1\" title=\"GNU 风格的 C++ 代码（注意大括号的缩进风格和高亮的 tab 宽度）\"></p><p>当然，除了设定选项，我们也可以做其他事情，比如下面的代码是在 Vim 帮助文件中，将 <code>q</code> 设定为关闭窗口的按键，映射中的 <code>&lt;buffer&gt;</code> 表示该映射只对这个缓冲区有效。</p><pre><code class=\"language-vim\">au FileType help  nnoremap &lt;buffer&gt; q &lt;C-W&gt;c\n</code></pre><h2>Tags 支持</h2><p>Vim 对一种叫 tags 的文本索引格式有特殊支持。事实上，Vim 自己的帮助文件都是用 tags 来索引的。我们用过了 Vim 帮助，也就用过了 tags 文件。下面展示了 $VIMRUNTIME/doc/tags 文件中的一部分：</p><pre><code class=\"language-tags\">?       pattern.txt     /*?*\n?&lt;CR&gt;   pattern.txt     /*?&lt;CR&gt;*\n@       repeat.txt      /*@*\n@/      change.txt      /*@\\/*\n@:      repeat.txt      /*@:*\n@=      change.txt      /*@=*\n@@      repeat.txt      /*@@*\n@r      eval.txt        /*@r*\nA       insert.txt      /*A*\nACL     editing.txt     /*ACL*\nANSI-C  develop.txt     /*ANSI-C*\n</code></pre><p>我们可以清楚地看到，其中内容分为三列：第一列是关键字，第二列是文件名，第三列是在目标文件中的匹配文本。当你在 Vim 的帮助文件中使用双击或 <code>&lt;C-]&gt;</code> 等命令跳转时，Vim 就会在 tags 文件中搜索，寻找到匹配项的时候就跳转到指定的文件，并利用匹配文本跳转到指定的位置。</p><p>注意我们有不止一个 tags 文件。单单从 Vim 帮助的角度，个人 Vim 配置目录下的 doc 目录里有一个 tags 文件；每当你装了一个新的带帮助文件的 Vim 插件时，你都需要到这个 doc 目录下运行 <code>helptags .</code> 来重新生成索引。每个 Vim 软件包的 doc 目录下也同样需要有 tags 文件，不过包管理器能够在安装、更新时自动帮我们在 doc 目录下生成 tags 文件。Vim 在你使用 <code>:help</code> 命令查帮助时，会自动在你的所有运行时目录（可以使用 <code>:set runtimepath?</code> 查看）下的 doc/tags 里查找第一个匹配项。</p><h3>生成 tags 文件的工具</h3><p>如果 tags 文件只支持 Vim 帮助文件的话，那我就没必要对其进行详细讨论了。之所以在这里讨论 tags，是因为它可以用在编程语言上。要生成 Vim 可以使用的支持常用编程语言的 tags 文件，我们需要使用下列两个工具之一：</p><ul>\n<li><a href=\"http://ctags.sourceforge.net/\">Exubertant Ctags</a></li>\n<li><a href=\"https://ctags.io/\">Universal Ctags</a></li>\n</ul><p>Exuberant Ctags 是已经存在了好多年的老牌工具。Windows 下可直接下载可执行程序，而 Linux 和 macOS 上的包管理器一般也直接支持。如：</p><ul>\n<li>Ubuntu 下可使用 <code>sudo apt install exuberant-ctags</code></li>\n<li>CentOS 下可使用 <code>sudo yum install ctags</code></li>\n<li>macOS Homebrew 可使用 <code>brew install ctags</code>（但需要注意 macOS 本身提供了一个功能较简单的 ctags 命令，你可能需要将 /usr/local/bin 在路径里移到 /usr/bin 前面，或自己设置 alias，确保优先使用 /usr/local/bin/ctags）</li>\n</ul><p>Universal Ctags 还比较新，目前各操作系统的包管理器里多半还没有它，所以安装会麻烦一点。你需要自己查看文档，找到在你的操作系统上的安装方式。（我是直接从源代码编译了一个版本。）</p><p>我之所以要推荐 Universal Ctags，是因为虽然 Exuberant Ctags 和 Universal Ctags 都支持超过 40 种的常见编程语言，但 Exuberant Ctags 的最后一个版本 5.8，发布于 2009 年，之后就一直没有更新了。Universal Ctags 是基于 Exuberant Ctags 代码的改进版本，并把开发移到了 GitHub 上，项目一直处于活跃状态。想偷懒的话，可以直接使用 Exuberant Ctags；如果愿意折腾一下，或者明确遇到 Exuberant Ctags 的问题，则可以试试 Universal Ctags。</p><p>对于现代 C++ 代码，使用 Universal Ctags 还是挺重要的。老的 Exuberant Ctags 不能处理 C++11 以来的新语法——这当然也是件显而易见的事。</p><h3>生成 tags 文件的命令</h3><p>要生成 tags 文件时，你可以简单地进入到一个目录下，然后执行下面的语句对该目录及子目录下的程序源文件生成一个 tags 文件：</p><pre><code class=\"language-bash\">ctags -R .\n</code></pre><p>但根据场景和语言不同，你可能需要使用更多的选项。比如，对于 C++，我一般使用：</p><pre><code class=\"language-bash\">ctags --fields=+iaS --extra=+q -R .\n</code></pre><p>如果是对系统的头文件生成 tags 文件——可以用来查找函数的原型信息——那我们一般还需要加上 <code>--c-kinds=+p</code> 选项。为了一次性地对系统头文件简单地生成 tags 文件，我还专门写了个脚本 <a href=\"https://github.com/adah1972/gen_systags\">gen_systags</a> 来自动化这项工作。你如果感兴趣的话，也可以点进去看一下。</p><p>鉴于我们主要讲 Vim 而不是 Ctags，这个话题我暂时就点到为止、不展开了。你可以通过我给出的链接，以及 <code>man ctags</code> 或 <code>ctags --help</code> 的输出，自己进一步学习一下。讲到 C 的工作环境时，我们会再回到 Ctags。</p><h3>使用 tags 文件</h3><p>如果当前目录下或当前文件所在目录下存在 tags 文件，Vim 会自动使用这个文件，不需要你做额外的设定。你所需要做的就是在待搜索的关键字上（也可以在可视模式下选中需要的关键字）使用正常模式命令 <code>&lt;C-]&gt;</code>，或者按 <code>g</code>（<code>g</code> 可理解成 go）键加鼠标单击。你愿意的话，也可以手工输入命令 <code>:tag</code> 后面跟空格和待搜索的符号加回车键。这样 Vim 即会跳转到该符号的定义或声明位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/5e/d205869f3312918f8e39a40c2592325e.gif?wh=924*576\" alt=\"Fig8.2\" title=\"标签跳转示例\"></p><p>如果待搜索的符号找不到，Vim 会报错“E426: tag not found”。如果存在一个或多个匹配项，Vim 会跳转到第一个匹配的位置。下面我列举一下其他相关的常用命令：</p><ul>\n<li><code>:tnext</code>（缩写 <code>:tn</code>）跳转到下一个标签匹配位置</li>\n<li><code>:tNext</code>（缩写 <code>:tN</code>）或 <code>:tprevious</code>（缩写 <code>:tp</code>）跳转到上一个标签匹配位置</li>\n<li><code>:tfirst</code> 或 <code>:trewind</code> 跳转到第一个标签匹配位置</li>\n<li><code>:tlast</code> 跳转到最后一个标签匹配位置</li>\n<li><code>:tselect 名称</code>（<code>:tselect</code> 可缩写为 <code>:ts</code>）跟 <code>:tag</code> 类似，但会列举可能的匹配项，让你自己选择（而非跳转到第一个匹配位置）</li>\n<li><code>g]</code> 跟 <code>&lt;C-]&gt;</code> 类似，但跟 <code>:tselect</code> 一样会给出一个列表而非直接跳转</li>\n<li><code>:tjump 名称</code>（<code>:tjump</code> 可缩写为 <code>:tj</code>）跟 <code>:tselect</code> 类似，但在只有一个匹配项的时候会直接跳转到匹配位置</li>\n<li><code>g&lt;C-]&gt;</code> 跟 <code>g]</code> 类似，但跟 <code>:tjump</code> 一样在只有一个匹配项时会直接跳转到匹配位置</li>\n<li><code>:stselect 名称</code>（<code>:stselect</code> 可缩写为 <code>:sts</code>）跟 <code>:tselect</code> 类似，但结果会打开到一个新分割的窗口中</li>\n<li><code>:stjump 名称</code>（<code>:stjump</code> 可缩写为 <code>:stj</code>）跟 <code>:tjump</code> 类似，但结果会打开到一个新分割的窗口中</li>\n</ul><p>我们的标签跳转分为 <code>:tag</code>、<code>:tselect</code> 和 <code>:tjump</code> 三种不同方法，正常模式和可视模式的命令 <code>&lt;C-]</code> 也同样有后两种方法的变体，对应的命令分别是 <code>g]</code> 和 <code>g&lt;C-]&gt;</code>。这三个命令前面也都可以额外加上 <code>&lt;C-W&gt;</code>，表示结果打开到新窗口中而非当前窗口。</p><p><img src=\"https://static001.geekbang.org/resource/image/10/ec/1017481027bdbca5862acc8b1356e9ec.gif?wh=924*576\" alt=\"Fig8.3\" title=\"展示在新窗口中选择并打开 printf 的声明\"></p><p>Vim 默认只在当前目录下和文件所在目录下寻找 tags 文件。对于含多层目录的项目，这个设定就不合适了。解决方法是使用 Vim 的选项 <code>tags</code>。一个小技巧是根据项目的可能深度，检查上层存在的 tags 文件：</p><pre><code class=\"language-vim\">\" 加入记录系统头文件的标签文件和上层的 tags 文件\nset tags=./tags,../tags,../../tags,tags,/usr/local/etc/systags\n</code></pre><p><code>tags</code> 选项的默认值是 <code>./tags,tags</code>，即检查文件所在目录下的 tags 文件和当前目录下的 tags 文件。上面这样的写法还会额外检查父目录下的 tags 文件，祖父目录下的 tags 文件，以及我们上面用 gen_systags 生成的 systags 文件。这对一个有不超过三层目录结构的项目来讲就足够了。如果你的项目目录层次更深，也只需要在 <code>tags</code> 选项里添加 <code>../../../tags</code> 这样的内容即可。</p><h3>Tagbar 插件</h3><p>根据上面的描述，我们可以看到 Ctags 是一个可以从源代码中提取符号的工具。事实上，这个工具在我们不生成 tags 文件也都是有用的。Vim 的插件 tagbar 就可以利用 Ctags 来提取符号，生成源代码的结构图。只要 Ctags 能支持这种语言，插件就能“识别” 这种语言，来生成结构图；识别的好坏程度也视 Ctags 对其的支持程度而定。下面是一个示例：</p><p><img src=\"https://static001.geekbang.org/resource/image/01/c8/01c7599a78c335d5279f4ec261bdc8c8.png?wh=1700*1359\" alt=\"Fig8.4\" title=\"Tagbar 示例\"></p><p>跟之前类似，假设使用 minpac 的话，我们需要在 vimrc 中“Other plugins”那行下面加入下面的语句，并运行 <code>:PackUpdate</code> 来安装一下：</p><pre><code class=\"language-vim\">call minpac#add('majutsushi/tagbar')\n</code></pre><p>我给它映射了快捷键 <code>&lt;F9&gt;</code>，可以快速打开和关闭 Tagbar 的窗口：</p><pre><code class=\"language-vim\">\" 开关 Tagbar 插件的键映射\nnnoremap &lt;F9&gt;      :TagbarToggle&lt;CR&gt;\ninoremap &lt;F9&gt; &lt;C-O&gt;:TagbarToggle&lt;CR&gt;\n</code></pre><h2>Quickfix 窗口</h2><p>Vim 里有一种特殊类型的窗口，被称作 quickfix（快速修复）。这个窗口中会展示外部命令的结果，并可以通过这个窗口中的内容直接跳转到特定文件的特定位置。这个设计最初是用来加速“编辑-编译-编辑”这个循环的，但它的实际用处并不只是用来编译程序。</p><p>我们先来看一下 Vim 的 <code>:make</code> 命令。如果你的代码可以简单执行 <code>make</code> 来编译的话（也就是说，你已经写了或者生成了合适的 Makefile），你可以尝试直接在 Vim 里执行 <code>:make</code>。你会看到正常的执行过程。唯一不一样的地方是，如果编译失败了，Vim 会自动跳转到第一个出错的位置！</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/d0/f515a16bcb32114edab186520b2a47d0.gif?wh=1174*988\" alt=\"Fig8.5\" title=\"演示 :make 失败时的行为\"></p><p>如果使用 <code>:copen</code> 命令，我们就可以打开 quickfix 窗口。在里面我们可以看到完整的出错信息，并能通过颜色看出 Vim 解析了文件名和行号。我们在带文件名的行上双击即可跳转到对应位置。另外，我们在 quickfix 窗口中也有跟之前类似的“next”类命令：</p><ul>\n<li><code>:cnext</code>（缩写 <code>:cn</code>）跳转到下一个出错位置</li>\n<li><code>:cNext</code>（缩写 <code>:cN</code>）或 <code>:cprevious</code>（缩写 <code>:cp</code>）跳转到上一个出错位置</li>\n<li><code>:cfirst</code> 或 <code>:crewind</code> 跳转到第一个出错位置</li>\n<li><code>:clast</code> 跳转到最后一个出错位置</li>\n</ul><p>事实上，在这些下一个、上一个的命令中，我用得最多的就是这个快速修复里的跳转了。为了方便记忆，我对它们都映射了相似的快捷键。</p><pre><code class=\"language-vim\">\" 用于 quickfix、标签和文件跳转的键映射\nnmap &lt;F11&gt;   :cn&lt;CR&gt;\nnmap &lt;F12&gt;   :cp&lt;CR&gt;\nnmap &lt;M-F11&gt; :copen&lt;CR&gt;\nnmap &lt;M-F12&gt; :cclose&lt;CR&gt;\nnmap &lt;C-F11&gt; :tn&lt;CR&gt;\nnmap &lt;C-F12&gt; :tp&lt;CR&gt;\nnmap &lt;S-F11&gt; :n&lt;CR&gt;\nnmap &lt;S-F12&gt; :prev&lt;CR&gt;\n</code></pre><p>这是我的映射，你可以根据自己的需要进行调整。另外要留意的一点是，取决于环境，不是所有的快捷键都能被 Vim 接收到，尤其在使用终端和远程连接的时候。比如，在 Mac 上有些快捷键已经被系统占用，并且终端基本不接受修饰键；在 Windows 的远程连接客户端里，PuTTY 不支持使用 Alt 的快捷键，但 mintty 就可以。</p><h3><code>:make</code> 命令的其他细节</h3><p>Vim 里的 <code>:make</code> 命令缺省会执行 make 命令，并且这是可以通过选项 <code>makeprg</code> 来进行配置的。比如，如果你希望启用四路并发编译，你就可以设置 <code>:set makeprg=make\\ -j4</code>。你也可以使用 GNU Make 之外的构建工具，但需要注意的是，如果发现 Vim 不能识别你使用的构建工具产生的错误信息，你可能需要利用 <code>errorformat</code>（<a href=\"https://yianwillis.github.io/vimcdoc/doc/quickfix.html#errorformat\"><code>:help errorformat</code></a>）选项来告诉 Vim 如何处理错误信息。</p><h3><code>:grep</code> 命令</h3><p>对我而言，跟构建使用频度至少一样高的命令是搜索，也就是根据关键字找到相关的源代码。这就可以使用 Vim 的 <code>:grep</code> 命令。跟 <code>:make</code> 命令相似，Vim 会调用一个合适的外部程序（可通过 <code>grepprg</code> 选项来进行配置）来进行搜索，并从结果中找到文件名、行号等信息。注意：在 Windows 上如果 Vim 没找到 grep 的话，它会调用 Windows 自带的 findstr 命令行工具；为了获得跟其他平台相同的体验和跟 Vim 本身相似的正则表达式，我强烈推荐你在 Windows 上也安装 grep 工具。我们上一讲讲到的搜索模式，大部分在 grep 里可以原封不动地使用，尤其是对 <code>\\?</code>、<code>\\+</code>、<code>\\&lt;</code> 和 <code>\\&gt;</code> 的解释。考虑到 vi 源自 Bill Joy，grep 源自 Ken Thompson，两者的老祖宗都是 ed，这自然也不是件令人意外的事。</p><p>如果使用 grep 命令的话，我们的命令大致如下所示：</p><pre><code class=\"language-vim\">:grep '要查找的符号' 文件名列表\n</code></pre><p>当然，grep 支持的复杂参数我们都可以用上。比如，下面的命令可以在所有的子目录里查找用到了 <code>printf</code> 的 .c 和 .h 文件：</p><pre><code class=\"language-vim\">:grep -R --include='*.c' --include='*.h' '\\&lt;printf\\&gt;' .\n</code></pre><p><strong>小提示：</strong>在查看搜索结果时，适时使用 <code>zz</code>（或 <code>zt</code>、<code>zb</code>）重定位当前行在屏幕上的位置，可能可以更清晰地查看前后的相关代码。</p><h3>异步支持</h3><p>上面这些命令，都有一个缺点：在执行过程中你干不了其他事情。对于执行过程可能较慢的 make，这个问题尤其严重。幸好，在 Vim 8 支持异步任务之后，这个问题也得到了解决。我们利用一个插件，就可以获得类似在一些集成开发环境中的体验，在构建过程中仍然可以继续做其他事情。</p><p>我们首先需要安装一个插件 asyncrun.vim。跟前面类似，假设我们使用 minpac 的话，我们需要在 vimrc 中的合适位置加入下面这行：</p><pre><code class=\"language-vim\">call minpac#add('skywind3000/asyncrun.vim')\n</code></pre><p>我们还需要一个跟 <code>:make</code> 相似的命令。我使用下面的命令定义（今天我们重点看使用，定义的细节就不讨论了）：</p><pre><code class=\"language-vim\">\" 和 asyncrun 一起用的异步 make 命令\ncommand! -bang -nargs=* -complete=file Make AsyncRun -program=make @ &lt;args&gt;\n</code></pre><p>这个命令同样会使用 <code>makeprg</code> 选项。不过，还有个问题是默认情况下屏幕上看不到执行过程的信息。我们可以让 asyncrun 在执行命令时立即打开 quickfix 窗口：</p><pre><code class=\"language-vim\">\" 异步运行命令时打开 quickfix 窗口，高度为 10 行\nlet g:asyncrun_open = 10\n</code></pre><p>对于 C/C++ 程序员来讲，启动和停止构建应该是一个很频繁的操作吧。所以，我也给它分配了一个快捷键：</p><pre><code class=\"language-vim\">\" 映射按键来快速启停构建\nnnoremap &lt;F5&gt;  :if g:asyncrun_status != 'running'&lt;bar&gt;\n                 \\if &amp;modifiable&lt;bar&gt;\n                   \\update&lt;bar&gt;\n                 \\endif&lt;bar&gt;\n                 \\exec 'Make'&lt;bar&gt;\n               \\else&lt;bar&gt;\n                 \\AsyncStop&lt;bar&gt;\n               \\endif&lt;CR&gt;\n</code></pre><p>上面的代码通过判断异步任务状态和窗口是否可修改，还会自动执行保存文件和终止构建等操作。建议你自己尝试一下。鉴于我们本讲内容已经很多了，我们暂时就不讲解了。</p><p><img src=\"https://static001.geekbang.org/resource/image/12/65/12a729849d86ef08263622929ed05a65.gif?wh=1174*990\" alt=\"Fig8.6\" title=\"演示异步启动构建和使用快捷键跳转\"></p><h2>查看文档</h2><p>Vim 里快捷键 <code>K</code> 可以用来查看光标下关键字的相关文档。它的行为是由选项 <code>keywordprg</code>（<a href=\"https://yianwillis.github.io/vimcdoc/doc/options.html#'keywordprg'\"><code>:help 'keywordprg'</code></a>）控制的。这个选项的缺省值是 <code>man</code>，表示查看 Unix 的 man 手册，很多文件类型插件会对当前缓冲区设置一个更合适的值，如 Vim 脚本就会直接把行为改成调用 <code>:help</code> 命令。</p><p>查看 man 手册的默认行为通常只在终端工作良好，而在图形界面 Vim 里会出现显示问题。我推荐使用 Vim 内置的 man 插件，并把全局的 <code>keywordprg</code> 设成 <code>:Man</code>：</p><pre><code class=\"language-vim\">\" 启用 man 插件\nsource $VIMRUNTIME/ftplugin/man.vim\n\nset keywordprg=:Man\n</code></pre><p>这样，我们在使用 <code>K</code> 命令时，将在 Vim 里直接打开 man 手册，效果如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/yy/08/yy9c761e5cbaa5ff91d5f2c0952f6208.png?wh=1316*1068\" alt=\"Fig8.8\" title=\"使用 K 在 Vim 里查看 man 手册\"></p><p>你看，是不是就方便多了？</p><h2>内容小结</h2><p>今天我们讨论了 Vim 中对编程的基本支持，包括：</p><ul>\n<li>Vim 使用编程规则来判断文件类型，逻辑放在文件 filetype.vim 里。</li>\n<li>Vim 里有很多设置文件格式的选项，自动设置一般在 ftplugin 和 indent 目录下；我们可以简单地在 vimrc 配置文件中进行定制。Vim 通过 <code>cindent</code> 和 <code>cinoptions</code> 选项，对类 C 的语言提供了相当细颗粒的缩进风格支持。</li>\n<li>Vim 对 tags 文件提供了完整的支持，Ctags 工具可以对超过 40 种主流编程语言生成 tags 文件，供 Vim 和 Tagbar 使用。</li>\n<li>Vim 里通过 quickfix 窗口，对构建和搜索提供了内置支持；从 Vim 8 开始，我们可以使用异步支持，在构建时继续进行编辑。</li>\n<li>Vim 里通过 <code>K</code> 命令，可以快速地查阅文档；通过 man 插件，我们可以直接在 Vim 里查阅 man 手册。</li>\n</ul><p>本讲我们的配置文件更改较多，请仔细检查一下其中内容。对应的标签是 <code>l8-unix</code> 和 <code>l8-windows</code>。</p><h2>课后练习</h2><p>今天的内容不难，但较多较杂。请你务必自己试验一下我上面总结的这些功能，来加深对这些功能的理解。要提高编辑的效率，熟悉基本功能一定是必要的。</p><ul>\n<li>不管你用什么语言编程，找出 Vim 是如何判断你的源代码文件类型的。</li>\n<li>看看你能不能找出 Vim 对你使用的编程语言有没有附加的设置（可选）。</li>\n<li>尝试一下 Ctags，并用 <code>&lt;C-]&gt;</code> 来跳转到某个符号的定义。</li>\n<li>如果你的语言有构建过程，尝试异步的构建过程。</li>\n<li>尝试使用 <code>:grep</code> 命令来在你的源代码中搜索某一符号。</li>\n<li>对于 C 系语言，尝试使用 <code>K</code> 命令来查阅文档。</li>\n</ul><p>我是吴咏炜，我们下一讲再见。</p>","neighbors":{"left":{"article_title":"07｜正则表达式：实现文件内容的搜索和替换","id":270380},"right":{"article_title":"09｜七大常用技巧：让编辑效率再上一个台阶","id":272121}},"comments":[{"had_liked":false,"id":240876,"user_name":"吴咏炜","can_delete":false,"product_type":"c1","uid":1645639,"ip_address":"","ucode":"8C24C10AEC779F","user_header":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","comment_is_top":true,"comment_ctime":1597109027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233720642217001e+18","product_id":100055801,"comment_content":"根据 YouCompleteMe 同学给出的提醒，我文中对 tags 的的写法不是最好。更好的写法是：<br><br>set tags=.&#47;tags;,tags,&#47;usr&#47;local&#47;etc&#47;systags<br><br>感谢 YouCompleteMe 同学。语法帮助详见 :help file-searching。","like_count":7},{"had_liked":false,"id":240655,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1597027645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48841667901","product_id":100055801,"comment_content":"# 题外话<br>老师的这些内容都很全面,完全可以当手册来用.<br>可惜目前的订阅人数不多,留言的人数就更少了.<br><br>这也跟vim这个工具有关系吧.<br>毕竟这玩意的学习曲线陡峭也是出了名的.<br>但愿以后有兴趣的小伙伴能来这里系统的学习,少走弯路吧.<br><br># 制表符配置<br>说实话,我是记不清那么多tab的配置项含义的.<br>好在这玩意配置后就不需要怎么改了.<br>即使有疑问,也可以很方便的用老师后面介绍的`K`命令,看具体的配置项含义.<br><br># 文件类型判断<br>我记得有两种判断方式<br>1. 根据文件后缀名判断<br>2. 根据文件内容的前多少行的内容来判断<br>看了老师的专栏,知道还可以借助路径来辅助判断.<br><br># Tags支持<br>Ctags这玩意在大几年前,绝对是文件跳转用的主力.<br>但也存在着一些弊端.<br>最明显的就是如果多个地方有同名的函数名,在跳转时是不准确的.<br>这样就会遇到老师文中`展示在新窗口中选择并打开 printf 的声明`展示的,<br>需要按一长串快捷键,后面还需要选择编号`2`.<br><br>现在不少vim插件都可以提供完整LSP(Language Server protocol) 功能支持,<br>现在主流的编程语言好像都有了对应lsp的服务端吧.<br>有了它,就可以实现很精准的函数跳转啦.<br><br>即使是接口类型的,它也可以很方便的去查找所有实现了的类.<br>还可以查看某个类都实现了哪些接口.<br>是不是很屌?<br>这次得感谢微软了.<br><br># Quickfix location-list<br>既然谈到了这些列表跳转的快捷键,那我就再带带货.<br>推荐一款插件[vim-unimpaired](https:&#47;&#47;github.com&#47;tpope&#47;vim-unimpaired&#47;blob&#47;master&#47;doc&#47;unimpaired.txt)<br>看它的快捷键,是不是很有规律? 都是`[``]`开头的,很好记.<br><br># make 及异步化支持<br>推荐一个跟老师提到的`skywind3000&#47;asyncrun.vim`类似的插件吧<br>[vim-dispatch](https:&#47;&#47;github.com&#47;tpope&#47;vim-dispatch&#47;blob&#47;master&#47;doc&#47;dispatch.txt)<br><br># grep 命令<br>推荐一款&lt;Modern Vim&gt;书中推荐的插件<br>[vim-grepper](https:&#47;&#47;github.com&#47;mhinz&#47;vim-grepper)<br>可以很方便的选择具体搜索的命令.<br>比如我最近就很喜欢用ripgrep来搜索.<br><br>另外可以很方便的配置搜索当前buffer, 当前所有打开的buffer, 当前路径下的所有文件.<br><br>(由于涉及大量代码,导致评论超出了2000字限制,故放到另外一个评论中.)<br><br># vim的indent缩进<br>提到了tab的缩进,我就顺便推荐一个我最近三周才接触的一个插件.<br>[vim-indent-guides](https:&#47;&#47;github.com&#47;nathanaelkane&#47;vim-indent-guides)<br><br>以前为了配置tab&#47;空格可见,进程会配置vim的`listchars`选项.<br>就像文中`GNU 风格的 C++ 代码`图片显示的那样,tab用`&gt;---`展示.<br>但是针对我这种经常需要用鼠标去复制内容的人很不友好.经常会把这东西给复制进去了.<br><br>但是这个插件就很巧妙,是用背景色来对齐缩进.<br>可以很直观的看到缩进是空格还是tab.<br>也不存在复制时多出莫名其妙的字符.<br><br>由于我配置的背景色非常非常淡,所以不太会干扰正常的视线.<br>","like_count":12},{"had_liked":false,"id":240783,"user_name":"YouCompleteMe","can_delete":false,"product_type":"c1","uid":1232859,"ip_address":"","ucode":"89B5A75DA85E0A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","comment_is_top":false,"comment_ctime":1597062740,"is_pvip":false,"replies":[{"id":"88943","content":"这个语法我在资料里没查到过。我也学习了……","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1597068605,"ip_address":"","comment_id":240783,"utype":1}],"discussion_count":4,"race_medal":0,"score":"14481964628","product_id":100055801,"comment_content":"我用的 set ctags=.&#47;.tags;,.tags 其中的;表示递归向上，这样就不用写..和..&#47;..表示多层级了","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503559,"discussion_content":"这个语法我在资料里没查到过。我也学习了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597068605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297908,"discussion_content":"学习了.\n\n文中提到的插件`vim-gutentags`,我也是一周内才安装的.\n昨天在写回复的时候,还在犹豫要不要带上这个.\n\n因为这个工具默认只对工程目录做索引,需要当前目录或父级目录下有特征目录.(比如`.git`,`.svn`)\n其实有些场景没有这些目录,我也想自动生成tag文件.\n但是这个文章中提到,可以在目录下创建`.root`目录.\n强制让插件认为是工作目录.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597109686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232859,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","nickname":"YouCompleteMe","note":"","ucode":"89B5A75DA85E0A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297828,"discussion_content":"https://www.zhihu.com/question/47691414/answer/373700711  我试了下，工作目录的第五级父目录运行ctags -R.然后在工作目录下的一个函数调用，可以C-]跳转到第五级父目录的头文件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597069165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1232859,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","nickname":"YouCompleteMe","note":"","ucode":"89B5A75DA85E0A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297903,"discussion_content":"现在我知道了，这个语法是在 :help file-searching 里。以前我都没留意到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597108492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297828,"ip_address":""},"score":297903,"extra":""}]}]},{"had_liked":false,"id":240657,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1597027971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14481929859","product_id":100055801,"comment_content":"针对vim中Alt映射键不生效的问题,可以参考这篇文章.<br>[Vim 中正确使用 Alt映射](http:&#47;&#47;www.skywind.me&#47;blog&#47;archives&#47;1846)<br><br>我最近参考这篇文章,成功的在Mac上把Option键映射为了Alt键.<br>该文章对`Xshell` `putty` `MinTTY` 都有所涉及.<br>","like_count":4},{"had_liked":false,"id":240656,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1597027689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10186962281","product_id":100055801,"comment_content":"接上文.<br><br>这就是我就针对`vim-grepper`插件,配置的两个快捷键:<br>```<br>&quot; 如果安装了`ripgrep`就优先选择它 否则使用默认的grep<br>if exists(&#39;:GrepperRg&#39;)<br>\t&quot; 这种方式没法直接使用rg的命令行参数 但可以实现<br>\t&quot; -dir          指定文件或目录 cwd | file | filecwd | repo `h:g:grepper.dir`<br>\t&quot; -buffer       只搜索当前文件<br>\t&quot; -buffers      所有打开的文件<br>\tvnoremap &lt;F3&gt; &lt;Esc&gt;:&lt;C-u&gt;Grepper -dir cwd -tool rg -noprompt -query &#39;\\b&lt;C-r&gt;=GetVisual(&#39;rg&#39;)&lt;CR&gt;\\b&#39;  &lt;C-h&gt;<br>\tvnoremap &lt;F4&gt; &lt;Esc&gt;:&lt;C-u&gt;Grepper-buffers -dir cwd -tool rg -noprompt -query &#39;\\b&lt;C-r&gt;=GetVisual(&#39;rg&#39;)&lt;CR&gt;\\b&#39;  &lt;C-h&gt;<br>\tnnoremap &lt;expr&gt; &lt;F3&gt; &quot;:&lt;C-u&gt;Grepper -dir cwd -tool rg -noprompt -query &#39;\\\\b&quot; . expand(&#39;&lt;cword&gt;&#39;) . &quot;\\\\b&#39; &quot;<br>\tnnoremap &lt;expr&gt; &lt;F4&gt; &quot;:&lt;C-u&gt;Grepper-buffers -dir cwd -tool rg -noprompt -query &#39;\\\\b&quot; . expand(&#39;&lt;cword&gt;&#39;) . &quot;\\\\b&#39; &quot;<br>elseif exists(&#39;:GrepperGrep&#39;)<br>\tvnoremap &lt;F3&gt; &lt;Esc&gt;:&lt;C-u&gt;Grepper -dir cwd -tool grep -noprompt -query &#39;\\&lt;&lt;C-r&gt;=GetVisual(&#39;grep&#39;)&lt;CR&gt;\\&gt;&#39;  &lt;C-h&gt;<br>\tvnoremap &lt;F4&gt; &lt;Esc&gt;:&lt;C-u&gt;Grepper-buffers -dir cwd -tool grep -noprompt -query &#39;\\&lt;&lt;C-r&gt;=GetVisual(&#39;grep&#39;)&lt;CR&gt;\\&gt;&#39;  &lt;C-h&gt;<br>\tnnoremap &lt;expr&gt; &lt;F3&gt; &quot;:&lt;C-u&gt;Grepper -dir cwd -tool grep -noprompt -query &#39;\\\\&lt;&quot; . expand(&#39;&lt;cword&gt;&#39;) . &quot;\\\\&gt;&#39; &quot;<br>\tnnoremap &lt;expr&gt; &lt;F4&gt; &quot;:&lt;C-u&gt;Grepper-buffers -dir cwd -tool grep -noprompt -query &#39;\\\\&lt;&quot; . expand(&#39;&lt;cword&gt;&#39;) . &quot;\\\\&gt;&#39; &quot;<br>endif<br><br># 可视模式下的函数`GetVisual`来自于下面这个连接. 方便转义当前选中区域的特殊字符!!!<br># https:&#47;&#47;stackoverflow.com&#47;questions&#47;676600&#47;vim-search-and-replace-selected-text&#47;6171215#6171215<br>```<br><br>这是我映射的为数不多的几个F开头的功能键.<br>希望对大家有帮助.","like_count":1},{"had_liked":false,"id":241505,"user_name":"唐龙","can_delete":false,"product_type":"c1","uid":1471657,"ip_address":"","ucode":"87A10AE04F2037","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","comment_is_top":false,"comment_ctime":1597313506,"is_pvip":false,"replies":[{"id":"89188","content":"对。这需要理解语言。Vim 本身做这些功能都是用正则表达式的。那就不行了。<br><br>理论上来说，写插件跟语言服务器交互，可能还是能做到的。确实很麻烦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1597333273,"ip_address":"","comment_id":241505,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5892280802","product_id":100055801,"comment_content":"vim能不能实现，C++类的成员变量一个颜色，函数的形参一个颜色，类似于这样的高亮。感觉就算支持的话也会很麻烦。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503754,"discussion_content":"对。这需要理解语言。Vim 本身做这些功能都是用正则表达式的。那就不行了。\n\n理论上来说，写插件跟语言服务器交互，可能还是能做到的。确实很麻烦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597333273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055088,"avatar":"https://static001.geekbang.org/account/avatar/00/10/19/70/7dbf25dc.jpg","nickname":"mobus","note":"","ucode":"966C72FC8AE50A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300591,"discussion_content":"可以试试 one dark 配色","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598185748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304975,"user_name":"黄骏","can_delete":false,"product_type":"c1","uid":1849733,"ip_address":"","ucode":"3C41D02F4F712C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/39/85/c6110f83.jpg","comment_is_top":false,"comment_ctime":1627726589,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1627726589","product_id":100055801,"comment_content":"感觉现在我用vim的效率有点低，日常的查找，编辑好像是最高频的操作，可以从这2个优化提高下。","like_count":0},{"had_liked":false,"id":255163,"user_name":"大狗爱吃鱼","can_delete":false,"product_type":"c1","uid":2062955,"ip_address":"","ucode":"5E8A002A993608","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7a/6b/1b021705.jpg","comment_is_top":false,"comment_ctime":1603275294,"is_pvip":false,"replies":[{"id":"93013","content":"如果 Unix 下全部用 UTF-8，那就自然支持了。<br><br>否则可以考虑用 vimgrep 命令，性能就会低点了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1603295325,"ip_address":"","comment_id":255163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603275294","product_id":100055801,"comment_content":"grep中文支持，怎么做啊？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507624,"discussion_content":"如果 Unix 下全部用 UTF-8，那就自然支持了。\n\n否则可以考虑用 vimgrep 命令，性能就会低点了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603295325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244149,"user_name":"瀚海星尘","can_delete":false,"product_type":"c1","uid":1024461,"ip_address":"","ucode":"90F418299EA3BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/cd/2c513481.jpg","comment_is_top":false,"comment_ctime":1598411379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598411379","product_id":100055801,"comment_content":"这一讲的内容真多，干货满满，看了好几天才看完，学习了很多东西，比如之前就听过 ctags 这次算是弄明白了。","like_count":0},{"had_liked":false,"id":242614,"user_name":"__@948CSheLL","can_delete":false,"product_type":"c1","uid":2091669,"ip_address":"","ucode":"3799653724B8FC","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ea/95/3f2539cc.jpg","comment_is_top":false,"comment_ctime":1597797807,"is_pvip":false,"replies":[{"id":"89502","content":"如果Windows，没有约定俗成位置，我一般用 C:\\bin。<br><br>Unix 下如果只给自己安装是 ~&#47;bin，给机器上所有人（一般需要 root 权限）是 &#47;usr&#47;local&#47;bin。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1597799429,"ip_address":"","comment_id":242614,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597797807","product_id":100055801,"comment_content":"老师您好，我想请问一下，下好的Universal Ctags应该放到那个目录下合适？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504050,"discussion_content":"如果Windows，没有约定俗成位置，我一般用 C:\\bin。\n\nUnix 下如果只给自己安装是 ~/bin，给机器上所有人（一般需要 root 权限）是 /usr/local/bin。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597799429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241364,"user_name":"shyghost","can_delete":false,"product_type":"c1","uid":1028739,"ip_address":"","ucode":"54BD97AAD4C035","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b2/83/24798607.jpg","comment_is_top":false,"comment_ctime":1597280245,"is_pvip":false,"replies":[{"id":"89158","content":"tags属于传统工具，了解一下就行。真正要语义查询，还是用真正理解语言的工具。后面会讨论。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1597284268,"ip_address":"","comment_id":241364,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1597280245","product_id":100055801,"comment_content":"tags建议增加gtags工具，gtags不仅支出跳转，还支持函数引用的查询，而且文件更新时可以针对单个文件更新","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503727,"discussion_content":"tags属于传统工具，了解一下就行。真正要语义查询，还是用真正理解语言的工具。后面会讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597284268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1028739,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b2/83/24798607.jpg","nickname":"shyghost","note":"","ucode":"54BD97AAD4C035","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298560,"discussion_content":"期待后续的更新，现在有些插件是比较好用，就是依赖太多了，公司服务器上搭建不起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597326741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241030,"user_name":"李公子胜治","can_delete":false,"product_type":"c1","uid":1455420,"ip_address":"","ucode":"7D48D78D289935","user_header":"https://static001.geekbang.org/account/avatar/00/16/35/3c/9800b0ba.jpg","comment_is_top":false,"comment_ctime":1597155943,"is_pvip":false,"replies":[{"id":"89121","content":"我的Vim配置的主体部分都会进入这个专栏的。<br><br>C++的东西，可以在我的C++专栏的相应部分留言。我们在那里讨论吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1597215134,"ip_address":"","comment_id":241030,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597155943","product_id":100055801,"comment_content":"老师，可以分享一下你的vim配置吗😅还有老师可以详细讲一讲cpp中的不定参模板函数和类吗，我看书感觉好晦涩","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503625,"discussion_content":"我的Vim配置的主体部分都会进入这个专栏的。\n\nC++的东西，可以在我的C++专栏的相应部分留言。我们在那里讨论吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597215134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240932,"user_name":"pyhhou","can_delete":false,"product_type":"c1","uid":1256496,"ip_address":"","ucode":"31EF8D50CF91A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","comment_is_top":false,"comment_ctime":1597124255,"is_pvip":false,"replies":[{"id":"89074","content":"我来也同学已经基本回答了你的问题。再补充一下关于 quickfix。<br><br>Quickfix 是 Vim 中的一种“机制”。不同的命令和插件都可以使用它，不只是 make。一般来讲，“全局”的错误或信息定位会使用 quickfix，单文件的错误定位（编辑时发现错误）会使用另一个叫 location-list 的东西。两者概念上非常接近，只是一个是全局的，一个跟随窗口的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1597149222,"ip_address":"","comment_id":240932,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1597124255","product_id":100055801,"comment_content":"感觉这一篇满满的干货，但很多都是我没有接触过的概念。<br><br>对于 tags 感觉有点类似于函数跳转，比如在一些其它的编辑器中，按下 CMD，鼠标点击函数名就可以跳转到函数的定义的位置（日常工作中用的比较多，比较在意的一个功能）。不知道 vim 中函数跳转的实现是不是也和 tags 的实现类似？<br><br>另外，quickfix 是不是只能用于 make 指令？其功能能否用于语言的编译或运行中的错误定位，比如 Java，Golang 等等的编译。<br><br>谢谢老师的分享，知道很多自己从未接触过的东西，看来想要真正学好 VIM 还得多多尝试自己没接触过的东西","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503596,"discussion_content":"我来也同学已经基本回答了你的问题。再补充一下关于 quickfix。\n\nQuickfix 是 Vim 中的一种“机制”。不同的命令和插件都可以使用它，不只是 make。一般来讲，“全局”的错误或信息定位会使用 quickfix，单文件的错误定位（编辑时发现错误）会使用另一个叫 location-list 的东西。两者概念上非常接近，只是一个是全局的，一个跟随窗口的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597149222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298003,"discussion_content":"做Golang开发,应该是离不开这个插件了.[vim-go](https://github.com/fatih/vim-go)\n\n直接转到变量的类型定义:\nhttps://github.com/fatih/vim-go/blob/ef23d90b84231759a992adf79b0dcd72844c1f84/doc/vim-go.txt#L278\n\n查看结构体实现的接口列表 / 查看哪些结构体实现了当前接口\nhttps://github.com/fatih/vim-go/blob/ef23d90b84231759a992adf79b0dcd72844c1f84/doc/vim-go.txt#L525\n\n查看函数/变量的所有引用\nhttps://github.com/fatih/vim-go/blob/ef23d90b84231759a992adf79b0dcd72844c1f84/doc/vim-go.txt#L623\n\n另外还有很多功能待你去发现.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597141086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1256496,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","nickname":"pyhhou","note":"","ucode":"31EF8D50CF91A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298075,"discussion_content":"感谢建议，最近也在用 golang 做开发。准备尝试用用看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597161516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298003,"ip_address":""},"score":298075,"extra":""}]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297999,"discussion_content":"tags只能实现基本的函数/变量跳转.\n如果是想实现VSCode上的函数跳转, 查看所有实现的接口,查看所有引用, 建议是使用支持LSP的vim插件,比如[coc.nvim](https://github.com/neoclide/coc.nvim)\n\n我最近两年的Golang开发,都是在vim中做的.\n一般的编译或运行测试用例时的错误信息,都是可以由 quickfix 展示,然后方便的跳转到出错的行和列.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597139555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}