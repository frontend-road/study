{"id":130422,"title":"09 | 面向对象：实现数据和方法的封装","content":"<p>在现代计算机语言中，面向对象是非常重要的特性，似乎常用的语言都支持面向对象特性，比如Swift、C++、Java……不支持的反倒是异类了。</p><p>而它重要的特点就是封装。也就是说，对象可以把数据和对数据的操作封装在一起，构成一个不可分割的整体，尽可能地隐藏内部的细节，只保留一些接口与外部发生联系。 在对象的外部只能通过这些接口与对象进行交互，无需知道对象内部的细节。这样能降低系统的耦合，实现内部机制的隐藏，不用担心对外界的影响。那么它们是怎样实现的呢？</p><p>本节课，我将从语义设计和运行时机制的角度剖析面向对象的特性，带你深入理解面向对象的实现机制，让你能在日常编程工作中更好地运用面向对象的特性。比如，在学完这讲之后，你会对对象的作用域和生存期、对象初始化过程等有更清晰的了解。而且你不会因为学习了Java或C++的面向对象机制，在学习JavaScript和Ruby的面向对象机制时觉得别扭，因为它们的本质是一样的。</p><p>接下来，我们先简单地聊一下什么是面向对象。</p><h2>面向对象的语义特征</h2><p>我的一个朋友，在10多年前做过培训师，为了吸引学员的注意力，他在讲“什么是面向对象”时说：“面向对象是世界观，是方法论。”</p><p>虽然有点儿语不惊人死不休的意思，但我必须承认，所有的计算机语言都是对世界进行建模的方式，只不过建模的视角不同罢了。面向对象的设计思想，在上世纪90年代被推崇，几乎被视为最好的编程模式。实际上，各种不同的编程思想，都会表现为这门语言的语义特征，所以，我就从语义角度，利用类型、作用域、生存期这样的概念带你深入剖析一下面向对象的封装特性，其他特性在后面的课程中再去讨论。</p><!-- [[[read_end]]] --><ul>\n<li><strong>从类型角度</strong></li>\n</ul><p>类型处理是语义分析时的重要工作。现代计算机语言可以用自定义的类来声明变量，这是一个巨大的进步。因为早期的计算机语言只支持一些基础的数据类型，比如各种长短不一的整型和浮点型，像字符串这种我们编程时离不开的类型，往往是在基础数据类型上封装和抽象出来的。所以，我们要扩展语言的类型机制，让程序员可以创建自己的类型。</p><ul>\n<li><strong>从作用域角度</strong></li>\n</ul><p>首先是类的可见性。作为一种类型，它通常在整个程序的范围内都是可见的，可以用它声明变量。当然，一些像Java的语言，也能限制某些类型的使用范围，比如只能在某个命名空间内，或者在某个类内部。</p><p>对象的成员的作用域是怎样的呢？我们知道，对象的属性（“属性”这里指的是类的成员变量）可以在整个对象内部访问，无论在哪个位置声明。也就是说，对象属性的作用域是整个对象的内部，方法也是一样。这跟函数和块中的本地变量不一样，它们对声明顺序有要求，像C和Java这样的语言，在使用变量之前必须声明它。</p><ul>\n<li><strong>从生存期的角度</strong></li>\n</ul><p>对象的成员变量的生存期，一般跟对象的生存期是一样的。在创建对象的时候，就对所有成员变量做初始化，在销毁对象的时候，所有成员变量也随着一起销毁。当然，如果某个成员引用了从堆中申请的内存，这些内存需要手动释放，或者由垃圾收集机制释放。</p><p>但还有一些成员，不是与对象绑定的，而是与类型绑定的，比如Java中的静态成员。静态成员跟普通成员的区别，就是作用域和生存期不同，它的作用域是类型的所有对象实例，被所有实例共享。生存期是在任何一个对象实例创建之前就存在，在最后一个对象销毁之前不会消失。</p><p>你看，我们用这三个语义概念，就把面向对象的封装特性解释清楚了，无论语言在顶层怎么设计，在底层都是这么实现的。</p><p>了解了面向对象在语义上的原理之后，我们来实际动手解析一下代码中的类，这样能更深刻地体会这些原理。</p><h2>设计类的语法，并解析它</h2><p>我们要在语言中支持类的定义，在PlayScript.g4中，可以这样定义类的语法规则：</p><pre><code>classDeclaration\n    : CLASS IDENTIFIER\n      (EXTENDS typeType)?\n      (IMPLEMENTS typeList)?\n      classBody\n    ;\n\nclassBody\n    : '{' classBodyDeclaration* '}'\n    ;\n\nclassBodyDeclaration\n    : ';'\n    | memberDeclaration\n    ;\n\nmemberDeclaration\n    : functionDeclaration\n    | fieldDeclaration\n    ;\n\nfunctionDeclaration\n    : typeTypeOrVoid IDENTIFIER formalParameters ('[' ']')*\n      (THROWS qualifiedNameList)?\n      functionBody\n    ;\n</code></pre><p>我来简单地讲一下这个语法规则：</p><ul>\n<li>类声明以class关键字开头，有一个标识符是类型名称，后面跟着类的主体。</li>\n<li>类的主体里要声明类的成员。在简化的情况下，可以只关注类的属性和方法两种成员。我们故意把类的方法也叫做function，而不是method，是想把对象方法和函数做一些统一的设计。</li>\n<li>函数声明现在的角色是类的方法。</li>\n<li>类的成员变量的声明和普通变量声明在语法上没什么区别。</li>\n</ul><p>你能看到，我们构造像class这样高级别的结构时，越来越得心应手了，之前形成的一些基础的语法模块都可以复用，比如变量声明、代码块（block）等。</p><p>用上面的语法写出来的playscript脚本的效果如下，在示例代码里也有，你可以运行它：</p><pre><code>/*\nClassTest.play 简单的面向对象特性。\n*/\nclass Mammal{\n  //类属性\n  string name = &quot;&quot;;\n\n  //构造方法\n  Mammal(string str){\n    name = str;\n  }\n\n  //方法\n  void speak(){\n    println(&quot;mammal &quot; + name +&quot; speaking...&quot;);\n  }\n}\n\nMammal mammal = Mammal(&quot;dog&quot;); //playscript特别的构造方法，不需要new关键字\nmammal.speak();                          //访问对象方法\nprintln(&quot;mammal.name = &quot; + mammal.name); //访问对象的属性\n\n//没有构造方法，创建的时候用缺省构造方法\nclass Bird{\n  int speed = 50;    //在缺省构造方法里初始化\n\n  void fly(){\n    println(&quot;bird flying...&quot;);\n  }\n}\n\nBird bird = Bird();              //采用缺省构造方法\nprintln(&quot;bird.speed : &quot; + bird.speed + &quot;km/h&quot;);\nbird.fly();\n</code></pre><p>接下来，我们让playscript解释器处理这些看上去非常现代化的代码，怎么处理呢？</p><p>做完词法分析和语法分析之后，playscript会在语义分析阶段扫描AST，识别出所有自定义的类型，以便在其他地方引用这些类型来声明变量。因为类型的声明可以在代码中的任何位置，所以最好用单独的一次遍历来识别和记录类型（类型扫描的代码在TypeAndScopeScanner.java里）。</p><p>接着，我们在声明变量时，就可以引用这个类型了。语义分析的另一个工作，就是做变量类型的消解。当我们声明“Bird bird = Bird(); ”时，需要知道Bird对象的定义在哪里，以便正确地访问它的成员（变量类型的消解在TypeResolver.java里）。</p><p>在做语义分析时，要把类型的定义保存在一个数据结构中，我们来实现一下：</p><pre><code>public class Class extends Scope implements Type{\n    ...\n}\n\npublic abstract class Scope extends Symbol{\n    // 该Scope中的成员，包括变量、方法、类等。\n    protected List&lt;Symbol&gt; symbols = new LinkedList&lt;Symbol&gt;(\n}\n\npublic interface Type {\n    public String getName();    //类型名称\n\n    public Scope getEnclosingScope();\n}\n</code></pre><p>在这个设计中，我们看到Class就是一个Scope，Scope里面原来就能保存各种成员，现在可以直接复用，用来保存类的属性和方法，画成类图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/86/b1/864926c69c3c85c7df771374f78942b1.jpg?wh=1142*487\" alt=\"\"></p><p>图里有几个类，比如Symbol、Variable、Scope、Function和BlockScope，它们是我们的符号体系的主要成员。在做词法分析时，我们会解析出很多标识符，这些标识符出现在不同的语法规则里，包括变量声明、表达式，以及作为类名、方法名等出现。</p><p>在语义分析阶段，我们要把这些标识符一一识别出来，这个是一个变量，指的是一个本地变量；那个是一个方法名等。</p><p>变量、类和函数的名称，我们都叫做符号，比如示例程序中的Mammal、Bird、mammal、bird、name、speed等。编译过程中的一项重要工作就是建立符号表，它帮助我们进一步地编译或执行程序，而符号表就用上面几个类来保存信息。</p><p>在符号表里，我们保存它的名称、类型、作用域等信息。对于类和函数，我们也有相应的地方来保存类变量、方法、参数、返回值等信息。你可以看一看示例代码里面是如何解析和记录这些符号的。</p><p>解析完这些语义信息以后，我们来看运行期如何执行具有面向对象特征的程序，比如如何实例化一个对象？如何在内存里管理对象的数据？以及如何访问对象的属性和方法？</p><h2>对象是怎么实例化的</h2><p>首先通过构造方法来创建对象。</p><p>在语法中，我们没有用new这个关键字来表示对象的创建，而是省略掉了new，直接调用一个跟类名称相同的函数，这是我们独特的设计，示例代码如下：</p><pre><code>Mammal mammal = Mammal(&quot;dog&quot;); //playscript特别的构造方法，不需要new关键字\nBird bird = Bird();            //采用缺省构造方法\n</code></pre><p>但在语义检查的时候，在当前作用域中是肯定找不到这样一个函数的，因为类的初始化方法是在类的内部定义的，我们只要检查一下，Mammal和Bird是不是一个类名就可以了。</p><p>再进一步，Mammal类中确实有个构造方法Mammal()，而Bird类中其实没有一个显式定义的构造方法，但这并不意味着变量成员不会被初始化。我们借鉴了Java的初始化机制，就是提供缺省初始化方法，在缺省初始化方法里，会执行对象成员声明时所做的初始化工作。所以，上面的代码里，我们调用Bird()，实际上就是调用了这个缺省的初始化方法。无论有没有显式声明的构造方法，声明对象的成员变量时的初始化部分，一定会执行。对于Bird类，实际上就会执行“int speed = 50;”这个语句。</p><p>在RefResolver.java中做语义分析的时候，下面的代码能够检测出某个函数调用其实是类的构造方法，或者是缺省构造方法：</p><pre><code>// 看看是不是类的构建函数，用相同的名称查找一个class\nClass theClass = at.lookupClass(scope, idName);\nif (theClass != null) {\n    function = theClass.findConstructor(paramTypes);\n    if (function != null) {\n        at.symbolOfNode.put(ctx, function);\n    }\n    //如果是与类名相同的方法，并且没有参数，那么就是缺省构造方法\n    else if (ctx.expressionList() == null){\n        at.symbolOfNode.put(ctx, theClass); // TODO 直接赋予class\n    }\n    else{\n        at.log(&quot;unknown class constructor: &quot; + ctx.getText(), ctx);\n    }\n\n    at.typeOfNode.put(ctx, theClass); // 这次函数调用是返回一个对象\n}\n</code></pre><p>当然，类的构造方法跟普通函数还是有所不同的，例如我们不允许构造方法定义返回值，因为它的返回值一定是这个类的一个实例对象。</p><p>对象做了缺省初始化以后，再去调用显式定义的构造方法，这样才能完善整个对象实例化的过程。不过问题来了，我们可以把普通的本地变量的数据保存在栈里，那么如何保存对象的数据呢？</p><h2>如何在内存里管理对象的数据</h2><p>其实，我们也可以把对象的数据像其他数据一样，保存在栈里。</p><p><img src=\"https://static001.geekbang.org/resource/image/57/1b/572da99aeee859f8b7cbcf6ebfe9ea1b.jpg?wh=1142*1036\" alt=\"\"></p><p>C语言的结构体struct和C++语言的对象，都可以保存在栈里。保存在栈里的对象是直接声明并实例化的，而不是用new关键字来创建的。如果用new关键字来创建，实际上是在堆里申请了一块内存，并赋值给一个指针变量，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/15/72/15313f8205fa80912e72718685755072.jpg?wh=1142*666\" alt=\"\"></p><p>当对象保存在堆里的时候，可以有多个变量都引用同一个对象，比如图中的变量a和变量b就可以引用同一个对象object1。类的成员变量也可以引用别的对象，比如object1中的类成员引用了object2对象。对象的生存期可以超越创建它的栈桢的生存期。</p><p>我们可以对比一下这两种方式的优缺点。如果对象保存在栈里，那么它的生存期与作用域是一样的，可以自动的创建和销毁，因此不需要额外的内存管理。缺点是对象没办法长期存在并共享。而在堆里创建的对象虽然可以被共享使用，却增加了内存管理的负担。</p><p>所以在C语言和C++语言中，要小心管理从堆中申请的内存，在合适的时候释放掉这些内存。在Java语言和其他一些语言中，采用的是垃圾收集机制，也就是说当一个对象不再被引用时，就把内存收集回来。</p><p>分析到这儿的时候，我们其实可以帮Java语言优化一下内存管理。比如我们在分析代码时，如果发现某个对象的创建和使用都局限在某个块作用域中，并没有跟其他作用域共享，那么这个对象的生存期与当前栈桢是一致的，可以在栈里申请内存，而不是在堆里。这样可以免除后期的垃圾收集工作。</p><p>分析完对象的内存管理方式之后，回到playscript的实现。在playscript的Java版本里，我们用一个ClassObject对象来保存对象数据，而ClassObject是PlayObject的子类。上一讲，我们已经讲过PlayObject，它被栈桢用来保存本地变量，可以通过传入Variable来访问对象的属性值：</p><pre><code>//类的实例\npublic class ClassObject extends PlayObject{\n     //类型\n    protected Class type = null;\n    ... \n}\n\n//保存对象数据\npublic class PlayObject {\n    //成员变量\n    protected Map&lt;Variable, Object&gt; fields = new HashMap&lt;Variable, Object&gt;();\n\n    public Object getValue(Variable variable){\n        Object rtn = fields.get(variable);\n        return rtn;\n    }\n\n    public void setValue(Variable variable, Object value){\n        fields.put(variable, value);\n    }\n}\n</code></pre><p>在运行期，当需要访问一个对象时，我们也会用ClassObject来做一个栈桢，这样就可以像访问本地变量一样访问对象的属性了。而不需要访问这个对象的时候，就把它从栈中移除，如果没有其他对象引用这个对象，那么它会被Java的垃圾收集机制回收。</p><h2>访问对象的属性和方法</h2><p>在示例代码中，我们用点操作符来访问对象的属性和方法，比如：</p><pre><code>mammal.speak();                          //访问对象方法\nprintln(&quot;mammal.name = &quot; + mammal.name); //访问对象的属性\n</code></pre><p>属性和方法的引用也是一种表达式，语法定义如下：</p><pre><code>expression\n    : ...\n    | expression bop='.'\n      ( IDENTIFIER       //对象属性\n      | functionCall     //对象方法\n      )\n     ...\n     ;\n</code></pre><p>注意，点符号的操作可以是级联的，比如：</p><pre><code>obj1.obj2.field1;\nobj1.getObject2().field1;\n</code></pre><p>所以，对表达式的求值，要能够获得正确的对象引用，你可以运行一下ClassTest.play脚本，或者去看看我的参考实现。</p><p>另外，对象成员还可以设置可见性。也就是说，有些成员只有对象内部才能用，有些可以由外部访问。这个怎么实现呢？这只是个语义问题，是在编译阶段做语义检查的时候，不允许私有的成员被外部访问，报编译错误就可以了，在其他方面，并没有什么不同。</p><h2>课程小结</h2><p>我们针对面向对象的封装特性，从类型、作用域和生存期的角度进行了重新解读，这样能够更好地把握面向对象的本质特征。我们还设计了与面向对象的相关的语法并做了解析，然后讨论了面向对象程序的运行期机制，例如如何实例化一个对象，如何在内存里管理对象的数据，以及如何访问对象的属性和方法。</p><p>通过对类的语法和语义的剖析和运行机制的落地，我相信你会对面向对象的机制有更加本质的认识，也能更好地使用语言的面向对象特性了。</p><h2>一课一思</h2><p>我们用比较熟悉的语法实现了面向对象的基础特性，像Ruby、Go这样的语言，还有另外的机制来实现面向对象。思考一下，你所熟悉的语言的面向对象机制，在底层是如何实现的？它们在类型、作用域和生存期三个方面的特点是什么？欢迎在留言区分享你的发现。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p>我将本节课相关代码的链接放在了文末，供你参考。</p><ul>\n<li>playscript-java（项目目录）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/tree/master/playscript-java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/tree/master/playscript-java\">GitHub</a></li>\n<li>PlayScript.java（入口程序）：   <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.java\">GitHub</a></li>\n<li>PlayScript.g4（语法规则）：     <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.g4\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.g4\">GitHub</a></li>\n<li>ASTEvaluator.java（解释器）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/ASTEvaluator.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/ASTEvaluator.java\">GitHub</a></li>\n<li>TypeAndScopeScanner.java（识别对象声明）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeAndScopeScanner.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeAndScopeScanner.java\">GitHub</a></li>\n<li>TypeResolver.java（消解变量声明中引用的类型）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeResolver.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeResolver.java\">GitHub</a></li>\n<li>RefResolver.java（消解变量引用和函数调用）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/RefResolver.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/RefResolver.java\">GitHub</a></li>\n<li>ClassTest.play（演示面向对象的基本特征）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/examples/ClassTest.play\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/examples/ClassTest.play\">GitHub</a></li>\n</ul><p></p>","neighbors":{"left":{"article_title":"08 | 作用域和生存期：实现块作用域和函数","id":128623},"right":{"article_title":"10 | 闭包： 理解了原理，它就不反直觉了","id":131317}},"comments":[{"had_liked":false,"id":131813,"user_name":"mcuking","can_delete":false,"product_type":"c1","uid":1561415,"ip_address":"","ucode":"03E608A7FB1F1D","user_header":"https://static001.geekbang.org/account/avatar/00/17/d3/47/6f6c05e0.jpg","comment_is_top":false,"comment_ctime":1567914509,"is_pvip":false,"replies":[{"id":"50746","content":"可以的。当然可以。<br>如果你用工具的话，antlr是支持javascript的。<br>如果不用工具，手写词法分析器和语法分析器的话，那就更没有问题了。<br>我后面可能会抽时间用TypeScript（或其他语言）写一个版本，用于写Visual Studio Code的插件。<br>再抽出时间，我其实会拿playscript写playscript的编译器，也就是实现自举:-)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568183093,"ip_address":"","comment_id":131813,"utype":1}],"discussion_count":2,"race_medal":0,"score":"53107522061","product_id":100034101,"comment_content":"这个脚本语言使用 Java 或 C++ 实现的，请问下我想用 javascript 实现一个这样的脚本语言可以吗？","like_count":12,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466629,"discussion_content":"可以的。当然可以。\n如果你用工具的话，antlr是支持javascript的。\n如果不用工具，手写词法分析器和语法分析器的话，那就更没有问题了。\n我后面可能会抽时间用TypeScript（或其他语言）写一个版本，用于写Visual Studio Code的插件。\n再抽出时间，我其实会拿playscript写playscript的编译器，也就是实现自举:-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568183093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1561415,"avatar":"https://static001.geekbang.org/account/avatar/00/17/d3/47/6f6c05e0.jpg","nickname":"mcuking","note":"","ucode":"03E608A7FB1F1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9654,"discussion_content":"貌似antlr还不支持typescript，所以我选了js，想着把老师的课内容都走一遍，后面的编译型语言也可以用js实现吗？因为我现在只熟悉js和ts","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568200612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130730,"user_name":"逸飞兮","can_delete":false,"product_type":"c1","uid":1628550,"ip_address":"","ucode":"997C945D329F79","user_header":"https://static001.geekbang.org/account/avatar/00/18/d9/86/3437829e.jpg","comment_is_top":false,"comment_ctime":1567520973,"is_pvip":false,"replies":[{"id":"49329","content":"多谢建议！<br>目前，我尽量保证已经拷贝到文稿里的代码，就不再有变化。<br>如果有变化，我就按照你说的版本管理办法，建多个目录！<br>我抽时间要把代码库优化一下。整理得更整齐一些。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567648536,"ip_address":"","comment_id":130730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35927259341","product_id":100034101,"comment_content":"老师，您好，提个小建议。代码可以按照每节课程建一个文件夹，如果后面课程的代码是基于之前的，可以复制一份到对应的文件夹再修改，这样通过目录可以直接看到整个过程。没有一直跟着老师的课程节奏走，看代码需要翻git记录，有些麻烦。","like_count":8,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466095,"discussion_content":"多谢建议！\n目前，我尽量保证已经拷贝到文稿里的代码，就不再有变化。\n如果有变化，我就按照你说的版本管理办法，建多个目录！\n我抽时间要把代码库优化一下。整理得更整齐一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567648536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130738,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1567522041,"is_pvip":false,"replies":[{"id":"49322","content":"计算顺序是语义分析中的一个重要问题。<br>如果本计算要依赖下级节点先计算完，那么就要在exit方法中。<br>如果如果只依赖自身，那么在哪个方法都可以。比如，判单&quot;&gt;&quot;表达式的返回值类型，那肯定是bool，不依赖其他节点。<br>","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567648251,"ip_address":"","comment_id":130738,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14452423929","product_id":100034101,"comment_content":"语义分析的时候，有的时候在listener的enter中实现，有的时候在exit中实现，listener的enter和exit方法的具体区别是什么呢？","like_count":4,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466100,"discussion_content":"计算顺序是语义分析中的一个重要问题。\n如果本计算要依赖下级节点先计算完，那么就要在exit方法中。\n如果如果只依赖自身，那么在哪个方法都可以。比如，判单&amp;quot;&amp;gt;&amp;quot;表达式的返回值类型，那肯定是bool，不依赖其他节点。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567648251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130030,"user_name":"李梁 | 东大","can_delete":false,"product_type":"c1","uid":1302566,"ip_address":"","ucode":"F85447ECAAD684","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/26/7d0cb215.jpg","comment_is_top":false,"comment_ctime":1567354711,"is_pvip":false,"replies":[{"id":"48581","content":"你很善于动脑。<br><br>类型推断是第11讲里会讲的内容。<br>我这里提前说一下：类型推断就是两个计算过程。一个是S属性（综合属性）计算，从下往上推导，比如：<br>auto a = 2;<br>你从叶子节点2能推导出这整个语句的类型是int。<br>再做I属性（继承属性）计算，就是从上到下的推导。a是这个表达式的叶子节点，a的类型是可以从整个表达式的类型继承下来。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567412970,"ip_address":"","comment_id":130030,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14452256599","product_id":100034101,"comment_content":"请问c++ auto变量能进行对象类型推导，这是怎么实现的呢","like_count":3,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465773,"discussion_content":"你很善于动脑。\n\n类型推断是第11讲里会讲的内容。\n我这里提前说一下：类型推断就是两个计算过程。一个是S属性（综合属性）计算，从下往上推导，比如：\nauto a = 2;\n你从叶子节点2能推导出这整个语句的类型是int。\n再做I属性（继承属性）计算，就是从上到下的推导。a是这个表达式的叶子节点，a的类型是可以从整个表达式的类型继承下来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567412970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130737,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1567521931,"is_pvip":false,"replies":[{"id":"49324","content":"对应英文Resolve，可能有些资料也翻译做“解决”？<br>本质就是建立其正确的引用关系。<br>","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567648358,"ip_address":"","comment_id":130737,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157456523","product_id":100034101,"comment_content":"文中多次提到的“消解”的具体含义是什么呢？","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466099,"discussion_content":"对应英文Resolve，可能有些资料也翻译做“解决”？\n本质就是建立其正确的引用关系。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567648358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130319,"user_name":"D","can_delete":false,"product_type":"c1","uid":1027596,"ip_address":"","ucode":"5BB4D16FE39BFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/0c/f39f847a.jpg","comment_is_top":false,"comment_ctime":1567425434,"is_pvip":false,"replies":[{"id":"49383","content":"同意你的看法。<br>面向对象首先是一种编程思想。哪怕语言层面没有提供直接的支持，也可以按照面向对象编程的思想来做。具体到C语言，它有结构体，有指针，特别是有能够做任何类型转换的void*指针，具有很大的灵活性，所以是能模拟出面向对象的特性的。<br>操作系统中的很多东西是用C写的，就有面向对象思想。比如，把很多设备都抽象成文件，按照统一的接口操作。<br>当然在语言层面上提供支持，会容易一些。<br>","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1567653970,"ip_address":"","comment_id":130319,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5862392730","product_id":100034101,"comment_content":"c语言也能写成面向对象风格，只要实现了面向对象的范式，就是面向对象模型编程，不知说的对不对，还请宫老师指正。","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465903,"discussion_content":"同意你的看法。\n面向对象首先是一种编程思想。哪怕语言层面没有提供直接的支持，也可以按照面向对象编程的思想来做。具体到C语言，它有结构体，有指针，特别是有能够做任何类型转换的void*指针，具有很大的灵活性，所以是能模拟出面向对象的特性的。\n操作系统中的很多东西是用C写的，就有面向对象思想。比如，把很多设备都抽象成文件，按照统一的接口操作。\n当然在语言层面上提供支持，会容易一些。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567653970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2718510,"avatar":"","nickname":"jack123","note":"","ucode":"873D0046EF39D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400303,"discussion_content":"可以用宏实现 在linux kernel里面可以很多 类似面向对象的实现方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633229091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345538,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1652366445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652366445","product_id":100034101,"comment_content":"这里有个疑惑，怎么知道class关键字就可以作为类或者对象呢？例如我要实现一个关键字为A，作用就和c语言的struct类似，那么这里应该还有一个过程？","like_count":0},{"had_liked":false,"id":327172,"user_name":"getouo","can_delete":false,"product_type":"c1","uid":2847288,"ip_address":"","ucode":"1B4CA48C1432B4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIKyOGT44viavqB48XoUhZibK46v6NvOkhKea0rdky3OicOum8OalMOgTfUibIbKL0ukJicaVkJWiaYA2bg/132","comment_is_top":false,"comment_ctime":1639967690,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1639967690","product_id":100034101,"comment_content":"请问宫老师，怎么支持数组呢","like_count":0,"discussions":[{"author":{"id":2847288,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIKyOGT44viavqB48XoUhZibK46v6NvOkhKea0rdky3OicOum8OalMOgTfUibIbKL0ukJicaVkJWiaYA2bg/132","nickname":"getouo","note":"","ucode":"1B4CA48C1432B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540204,"discussion_content":"@Override\n    public Object visitArrayInitializer(ArrayInitializerContext ctx) {\n        List&lt;Object&gt; elements = new ArrayList&lt;&gt;();\n        int size = ctx.variableInitializer().size();\n        for (int i = 0; i &lt; size; i++) {\n            elements.add(this.visitVariableInitializer(ctx.variableInitializer(i)));\n        }\n        return elements;\n    }\n\n这样实现了一个但是感觉有点不合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639987211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299184,"user_name":"潜龙勿用","can_delete":false,"product_type":"c1","uid":2159460,"ip_address":"","ucode":"EEB8A6F3E4A1B8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dsZ5CFV7mCIKEn7YcVFJXksO201eeqsJXoT4EYNvcibAKNSWSQVZPbbRgPKraWqg6YnaaRlVoywic9MEsflicRDibQ/132","comment_is_top":false,"comment_ctime":1624502436,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1624502436","product_id":100034101,"comment_content":"Rust的变量出了作用域就不允许被引用，为了防止悬垂引用<br>","like_count":0},{"had_liked":false,"id":299177,"user_name":"潜龙勿用","can_delete":false,"product_type":"c1","uid":2159460,"ip_address":"","ucode":"EEB8A6F3E4A1B8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dsZ5CFV7mCIKEn7YcVFJXksO201eeqsJXoT4EYNvcibAKNSWSQVZPbbRgPKraWqg6YnaaRlVoywic9MEsflicRDibQ/132","comment_is_top":false,"comment_ctime":1624500359,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1624500359","product_id":100034101,"comment_content":"静态成员跟普通成员的区别，就是作用域和生存期不同，它的作用域是类型的所有对象实例，被所有实例共享。生存期是在任何一个对象实例创建之前就存在，在最后一个对象销毁之前不会消失。<br>------------------------------------------<br>“它的作用域是类型的所有对象实例”，这个描述会不会不太准确呢，静态成员先于所有对象实例存在。当没有对象实例也是可以访问静态成员的。还是引入类对象这个概念比较准确吧？","like_count":1},{"had_liked":false,"id":261247,"user_name":"brianway","can_delete":false,"product_type":"c1","uid":1042507,"ip_address":"","ucode":"E05738C88829C2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/4b/57fa0e34.jpg","comment_is_top":false,"comment_ctime":1605250213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605250213","product_id":100034101,"comment_content":"运行ClassTest.play 脚本会报错 Exception in thread &quot;main&quot; java.lang.NullPointerException<br>","like_count":0},{"had_liked":false,"id":202173,"user_name":"宋健","can_delete":false,"product_type":"c1","uid":1283082,"ip_address":"","ucode":"7DD1CAB40440C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/0a/7f7c9b25.jpg","comment_is_top":false,"comment_ctime":1585917093,"is_pvip":false,"replies":[{"id":"76957","content":"对不起，没太看明白你的问题...<br>但我可以总结一下。在面向对象的语言中，变量的作用域有以下几种：<br>1.类作用域（Class Scope）<br>也就是成员变量。它们在整个类中可见。<br>2.方法作用域（Method Scope）<br>就是方法中的成员变量。<br>3.块作用域（Block Scope）和循环作用域<br>一个块中声明的变量，在块外面无效。循环变量也是如此。<br>此外，还要考虑变量遮蔽（Variable Shadowing），也就是相同名称的变量，会遮蔽外层的变量。在Java里，本地变量可以遮蔽类成员变量，但块作用域中的变量，不允许遮蔽外层的本地变量。在这方面不同的语言定义会有不同。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586783750,"ip_address":"","comment_id":202173,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585917093","product_id":100034101,"comment_content":"所以说，如果在主类中定义的对象A，A拥有全局作用域，而A里面的方法以及属性就要看A的类里面定义的作用域是吗？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490524,"discussion_content":"对不起，没太看明白你的问题...\n但我可以总结一下。在面向对象的语言中，变量的作用域有以下几种：\n1.类作用域（Class Scope）\n也就是成员变量。它们在整个类中可见。\n2.方法作用域（Method Scope）\n就是方法中的成员变量。\n3.块作用域（Block Scope）和循环作用域\n一个块中声明的变量，在块外面无效。循环变量也是如此。\n此外，还要考虑变量遮蔽（Variable Shadowing），也就是相同名称的变量，会遮蔽外层的变量。在Java里，本地变量可以遮蔽类成员变量，但块作用域中的变量，不允许遮蔽外层的本地变量。在这方面不同的语言定义会有不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586783750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}