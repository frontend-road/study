{"id":771335,"title":"08｜类与接口的相互操作","content":"","comments":[{"had_liked":false,"id":390657,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1715884562,"is_pvip":false,"replies":[{"id":142097,"content":"@Jack Q 有点不好意思，我不太确定你这里有几个问题，因为有些部分只像是叙述。\n\nQ1：为什么不建议使用class X implements ClassA ...\n-------------\n在cheatsheets 中，TS只是不建议使用形如“class X  implements ClassA ...”的方式。也就是说，不建议把ClassA当成接口来用。就cheatsheets 面向的用户群体而言，TS想表达的只是简单的概念问题：不要去“实现一个类（例如ClassA）”，因为“类”应该用派生（extends）的方式来显式地说明它的可继承性。\n\nQ2：对比 interface I 和 type J。\n--------\n这里你只有示例，没有问题。似乎看起来，interface I声明得没什么不妥。但在你的描述中出了两个问题，其一是既然是`interface I ...`，那么该接口声明中就没有“实现...”这样的说法；其二则比较关键，在于extends AbstractF 并不会使 I 获得 abstract 的能力。\n\nabstract作为类成员声明时的修饰行为，约定是“子类必须实现该成员（例如method）”。因为这个缘故，AbstractF作为接口时只是成员列表中“有method”而已，与其它行为无关。所以interface I extends AbstractF也只是限制了成员列表中必须有method。\n\n对于`abstract AbstractF ...`来说，AbstractF是抽象类没错，但直接使用AbstractF引用不到抽象类的类型啊？得用type AbstractFConstructor = typeof AbstractF; 才能拿得到。而AbstractFConstructor是一个抽象的构造方法，这个在TypeScript有对应的抽象构造签名，是`interface IAbstractFConstructor { abstract new ... }`。这个才对应地得到`abstract AbstractF ...`\n\nQ3：对象类型 指代的是 K 还是 type K = typeStructure  这里的 等号右侧的 typeStructure 呢？\n--------\n指的是等号右侧的typeStructure 。\n\n几乎所有的类型都有它的“匿名的、字面风格的语法”。对象类型就是用“{ ... }”作字面语法的。类似的，元组就是以“[ ... ]”为字面语法的。对象类型没有具名语法（所以概念上与形式上也就同于匿名接口），所以它只能以type的形式来定义一个别名，或者用typeof从一个具体的变量中取出对象类型。\n\nQ4：merging...\n-------------\n这里好象没问题。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1716008717,"ip_address":"江苏","comment_id":390657,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"class A {}\n\nconst bag = new A;\n&#47;&#47; typescriptlang 的 class 相关cheatsheets (https:&#47;&#47;www.typescriptlang.org&#47;cheatsheets&#47;) 中提到 \n&#47;&#47; class 既可以 被当作 值使用，也可以被当作 类型 使用\n&#47;&#47; 但是提到最好不要 使用下面的 方式, 这里是什么原因呢？\nclass B implements A {}\n\nabstract class AbstractF {\n  abstract method(): void;\n}\n\ninterface G {\n  g: boolean\n}\ninterface H {\n  h: string;\n}\n\n&#47;&#47; 通过 extends AbstractF 使 I 获得了 abstract 的能力\ninterface I extends G, H, AbstractF {\n  i: number;\n  (): void;\n  new (args: string[]): void;\n  readonly i2: number[];\n  &#47;&#47; 实现 async + method\n  fun(): Promise&lt;void&gt;;\n  &#47;&#47; 实现 * 迭代器\n  [Symbol.iterator](): IterableIterator&lt;any&gt;;\n  &#47;&#47; 实现 getter setter\n  get size(): number;\n  set size(v: number);\n}\n\nconst j = {\n  k: [1,2,3],\n  l: false\n}\n\n&#47;&#47; 因为 typeof j 是从具体的实现上 获取得到的 对象类型, 所以 一定不会得到 类似 optional 这种属性\ntype J = typeof j\n&#47;&#47;   ^?\n\ntype K = {\n  k: 1\n}\n\n&#47;&#47; 疑问: 对象类型 指代的是 K 还是 type K = typeStructure  这里的 等号右侧的 typeStructure 呢？\n&#47;&#47; 疑问来源：\n&#47;&#47; const l: { m:2; n:[true]  } = {\n&#47;&#47;   m:2,\n&#47;&#47;   n: [true]\n&#47;&#47; }\n&#47;&#47; const l: typeStructure = value 视频说这个 typeStructure 部分是 匿名接口 or 对象类型 \n\n&#47;&#47; merging\ninterface L {\n  l: Record&lt;string, unknown&gt;\n}\n\ninterface L {\n  l1: string[]\n}\n\nconst m: L = {\n  l: {},\n  l1: []\n}\n&#47;&#47; type 的全称为 type alias\n&#47;&#47; 它的设计目的是用来 支持比interface 更丰富的类型系统的\n&#47;&#47; 下述的 M 可以看作是两个 匿名接口 or 对象类型的 union\n&#47;&#47; 如果是从匿名这个方向考虑, 对 匿名接口的 merging 一定是有问题的\n&#47;&#47; 所以 type 不支持 merging\ntype M = {\n  l: Record&lt;string, unknown&gt;\n} | {\n  l: string[]\n}","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645343,"discussion_content":"再补充一点。\n\n需要要留意的是，TS从来没有官方文档明确地指出“class A ...”将会“隐式地”声明“interface A”，官方隐去了这一层概念，是为了避免复杂性，在cheatsheets不借用这一层概念，同样也是为了避免复杂性。\n\n如果想要试图实现cheatsheets中所示禁例的语义，那么建议应该是如下：\n```\ninterface IntfC extends Bag { ... }\nclass C implements IntfC { ... }\n```","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1716008761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645342,"discussion_content":"@Jack Q 有点不好意思，我不太确定你这里有几个问题，因为有些部分只像是叙述。\n\nQ1：为什么不建议使用class X implements ClassA ...\n-------------\n在cheatsheets 中，TS只是不建议使用形如“class X  implements ClassA ...”的方式。也就是说，不建议把ClassA当成接口来用。就cheatsheets 面向的用户群体而言，TS想表达的只是简单的概念问题：不要去“实现一个类（例如ClassA）”，因为“类”应该用派生（extends）的方式来显式地说明它的可继承性。\n\nQ2：对比 interface I 和 type J。\n--------\n这里你只有示例，没有问题。似乎看起来，interface I声明得没什么不妥。但在你的描述中出了两个问题，其一是既然是`interface I ...`，那么该接口声明中就没有“实现...”这样的说法；其二则比较关键，在于extends AbstractF 并不会使 I 获得 abstract 的能力。\n\nabstract作为类成员声明时的修饰行为，约定是“子类必须实现该成员（例如method）”。因为这个缘故，AbstractF作为接口时只是成员列表中“有method”而已，与其它行为无关。所以interface I extends AbstractF也只是限制了成员列表中必须有method。\n\n对于`abstract AbstractF ...`来说，AbstractF是抽象类没错，但直接使用AbstractF引用不到抽象类的类型啊？得用type AbstractFConstructor = typeof AbstractF; 才能拿得到。而AbstractFConstructor是一个抽象的构造方法，这个在TypeScript有对应的抽象构造签名，是`interface IAbstractFConstructor { abstract new ... }`。这个才对应地得到`abstract AbstractF ...`\n\nQ3：对象类型 指代的是 K 还是 type K = typeStructure  这里的 等号右侧的 typeStructure 呢？\n--------\n指的是等号右侧的typeStructure 。\n\n几乎所有的类型都有它的“匿名的、字面风格的语法”。对象类型就是用“{ ... }”作字面语法的。类似的，元组就是以“[ ... ]”为字面语法的。对象类型没有具名语法（所以概念上与形式上也就同于匿名接口），所以它只能以type的形式来定义一个别名，或者用typeof从一个具体的变量中取出对象类型。\n\nQ4：merging...\n-------------\n这里好象没问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1716008717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":2,"child_discussions":[{"author":{"id":1160078,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","nickname":"Jack Q","note":"","ucode":"A7DBC311884FFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":645344,"discussion_content":"谢谢老师的解答。\n同时解释下我的留言中的关于问题：\n\n// 实现 async + method和  // 实现 * 迭代器 这里的描述不准确\r我在看视频时，注意到interface和对象类型部分中关于async 和 * 有提到是无法通过关键字或者语法实现，只能通过其他方式得到类似效果。\n\n所以想当然的用&#34;实现&#34;的进行了描述。是不是这样描述会更恰当：// 得到async + method的效果  和  // 得到 * 迭代器的效果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716018541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645342,"ip_address":"广东","group_id":0},"score":645344,"extra":""},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1160078,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","nickname":"Jack Q","note":"","ucode":"A7DBC311884FFA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645351,"discussion_content":"Oh。：）\n\n这没问题。其实我所谓的“其它方法”就是你这里的方法，声明成特定类型的属性，而不能使用*、async这样的关键字。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716027851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645344,"ip_address":"江苏","group_id":0},"score":645351,"extra":""}]}]},{"had_liked":false,"id":390346,"user_name":"WGH丶","can_delete":false,"product_type":"c3","uid":1922568,"ip_address":"陕西","ucode":"02E43256770C62","user_header":"https://static001.geekbang.org/account/avatar/00/1d/56/08/bd75f114.jpg","comment_is_top":false,"comment_ctime":1715175203,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"一但深究起来，细节是真多 - -！","like_count":0}]}