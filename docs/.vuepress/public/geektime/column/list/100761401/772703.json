{"id":772703,"title":"05｜分支语句：控制流让程序具备基本的运算能力","content":"<p>你好，我是海纳。</p><p>上一节课，我们让虚拟机成功地加载并执行了标准Python3.8版本的字节码，我知道你已经迫不及待想继续实现对象系统，以支持整数和字符串等更多的数据类型了。但只实现完备的对象系统并不能让虚拟机看上去功能更加强大，而控制流却可以让我们做更多的测试，例如，支持了分支和循环语句以后，就可以实现一个计算 fibonacci 数列的程序。所以我们决定实现了控制流之后，再重新思考对象系统。</p><p>典型的两种控制流结构是分支选择和循环结构，这节课我们先研究分支语句是如何实现的。</p><h2>分支语句</h2><p>为了研究 Python 字节码是如何表达分支结构的，我们先创建一个包含分支语句的测试文件。</p><pre><code class=\"language-python\"># test_if.py\nif 2 &gt; 1:\n&nbsp; &nbsp; print(2)\nelse:\n&nbsp; &nbsp; print(1)\n\nprint(3)\n</code></pre><p>使用以下命令，把上述文件编译成 pyc 文件。</p><pre><code class=\"language-python\">python -m compileall test_if.py\n</code></pre><p>然后通过show_file.py 查看这个文件结构，得到如下结果：</p><pre><code class=\"language-python\">code\n&nbsp; &nbsp;argcount 0\n&nbsp; &nbsp;nlocals 0\n&nbsp; &nbsp;stacksize 2\n&nbsp; &nbsp;flags 0040\n&nbsp; &nbsp;code\n&nbsp; &nbsp; &nbsp; 640064016b04721265006400830101006e08650064018301010065006402\n&nbsp; &nbsp; &nbsp; 8301010064035300\n&nbsp; 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (2)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (1)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 COMPARE_OP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 (&gt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 POP_JUMP_IF_FALSE&nbsp; &nbsp; &nbsp; &nbsp;18\n\n&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (2)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 POP_TOP\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 JUMP_FORWARD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 (to 26)\n\n&nbsp; 4&nbsp; &nbsp; &nbsp;&gt;&gt;&nbsp; &nbsp;18 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;20 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (1)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;22 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24 POP_TOP\n\n&nbsp; 6&nbsp; &nbsp; &nbsp;&gt;&gt;&nbsp; &nbsp;26 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;28 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (3)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32 POP_TOP\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;34 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;36 RETURN_VALUE\n&nbsp; &nbsp;consts\n&nbsp; &nbsp; &nbsp; 2\n&nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; 3\n&nbsp; &nbsp; &nbsp; None\n&nbsp; &nbsp;names ('print',)\n&nbsp; &nbsp;varnames ()\n&nbsp; &nbsp;freevars ()\n&nbsp; &nbsp;cellvars ()\n&nbsp; &nbsp;filename 'test_if.py'\n</code></pre><!-- [[[read_end]]] --><p>我们看到代码中所使用的三个整数都已经放在了 consts 表中。反编译出来的字节码部分则出现了三个尚未支持的字节码，分别是 COMPARE_OP、POP_JUMP_IF_FALSE 和JUMP_FORWARD。从 Python 虚拟机的标准文档或者 CPython 的源代码里都可以查到这三个字节码的编号，在 bytecode.hpp 里添加它们。</p><pre><code class=\"language-c++\">    /* Comparison operator */\n    static const unsigned char COMPARE_OP = 107;\n    /* Number of bytes to skip */\n    static const unsigned char JUMP_FORWARD = 110;\n    static const unsigned char POP_JUMP_IF_FALSE = 114;\n</code></pre><p>接下来，我们重点看看这三个字节码分别是如何实现的。</p><h2>实现比较指令</h2><p>第一个要处理的字节码是 <strong>COMPARE_OP</strong>，<a href=\"https://time.geekbang.org/column/article/771985\">第 3 节课</a>我们曾经提到字节码操作数编号大于 90 的都是带参数的。COMPARE_OP 的编号是 107，所以它是带参数的。在这节课的例子里，它的参数是 4（反编译结果的第 11 行）。这个参数所代表的是比较操作符的类型，比如 4 就代表大于，0 代表小于，2 代表等于。你可以看一下完整的比较操作所对应的类型。</p><pre><code class=\"language-c++\">    enum COMPARE {\n        LESS = 0,\n        LESS_EQUAL,\n        EQUAL,\n        NOT_EQUAL,\n        GREATER,\n        GREATER_EQUAL\n    };\n</code></pre><p>接下来就可以在 Interpreter 里添加 COMPARE_OP 的实现了。在此之前，我需要引入一个小的代码重构。为了使代码更简洁，我在代码里定义了宏 PUSH 和 POP，这样可以避免大量的手动输入。</p><pre><code class=\"language-c++\">// runtime/interpreter.cpp\n#define PUSH(x)  _stack-&gt;add((x))\n#define POP()    _stack-&gt;pop()\n</code></pre><p>最后，我们就可以在 Interpreter 中实现我们这节课提到的三个字节码了。</p><pre><code class=\"language-c++\">            case ByteCode::COMPARE_OP:\n                w = POP();\n                v = POP();\n\n                switch(op_arg) {\n                case ByteCode::GREATER:\n                    PUSH(v-&gt;greater(w));\n                    break;\n\n                case ByteCode::LESS:\n                    PUSH(v-&gt;less(w));\n                    break;\n\n                case ByteCode::EQUAL:\n                    PUSH(v-&gt;equal(w));\n                    break;\n\n                case ByteCode::NOT_EQUAL:\n                    PUSH(v-&gt;not_equal(w));\n                    break;\n\n                case ByteCode::GREATER_EQUAL:\n                    PUSH(v-&gt;ge(w));\n                    break;\n               \n                case ByteCode::LESS_EQUAL: \n                    PUSH(v-&gt;le(w));\n                    break;\n\n                default:\n                    printf(\"Error: Unrecognized compare op %d\\n\", op_arg);\n\n                }\n                break;\n</code></pre><p>在这段代码中，我们为每一种比较操作都提供了一个方法，又因为各个对象的比较方式各不相同，所以每个对象都会有自己的实现。要完成这个功能，这些比较方法必须和print方法一样，是虚函数，也就是必须要使用 virtual 关键字进行修饰。</p><pre><code class=\"language-c++\">class HiObject {\npublic:\n    virtual void print() {}\n\n    virtual HiObject* add(HiObject* x){}\n    virtual HiObject* greater  (HiObject* x) {};\n    virtual HiObject* less     (HiObject* x) {};\n    virtual HiObject* equal    (HiObject* x) {};\n    virtual HiObject* not_equal(HiObject* x) {};\n    virtual HiObject* ge       (HiObject* x) {};\n    virtual HiObject* le       (HiObject* x) {};\n};\n</code></pre><p>在 HiInteger 类中，我们必须提供用于整数比较的方法，也就是在子类中覆写父类的方法。在这里，我只列出大于操作所对应的greater方法，而等于、不等于、小于等操作所对应的方法，你可以自己补充。</p><pre><code class=\"language-c++\">HiObject* HiInteger::greater(HiObject* x) {\n    if (_value &gt; ((HiInteger*)x)-&gt;_value)\n        return new HiInteger(1);\n    else\n        return new HiInteger(0);\n}\n</code></pre><p>注意这个方法的返回值，在 Python 中 True 和 False 都是对象，所以在这里，我们定义用于比较操作的几个方法的时候，它的返回值也是 HiObject 类型的指针。但现在我们的虚拟机对象类型还不完整，没有真正的 True 和 False 对象，就临时使用 0 代表 False，使用 1 代表 True。这样的替代虽然并不完全符合 Python 语义，但就目前而言已经足够了。</p><h2>实现跳转功能</h2><p>在刚开始实现执行器的时候，我就解释过 pc 变量的含义，它是一个程序计数器，代表虚拟机当前执行到哪条指令了。当控制流因为分支选择而发生跳转的时候，本质上就是改变这个程序计数器，让它不再顺序向下取指，而是跳转到另外一个目标地址，去把那里的指令取出来执行。所以，所有的跳转指令本质上就是对程序计数器的干预，使它指向我们期望的地址。</p><p>然后再考察 POP_JUMP_IF_FALSE 的参数，在这节课的例子里，它是 18。这个参数代表的是绝对地址，也就是字节码前面的编号。你看一下地址编号为 18 的那条指令，反编译工具已经很贴心地帮我们标记了 “&gt;&gt;” 符号，地址为 18 的那条 LOAD_NAME 指令就是我们要跳转的目标地址。经过分析，POP_JUMP_IF_FALSE 的实现就非常简单了。</p><pre><code class=\"language-c++\">            case ByteCode::POP_JUMP_IF_FALSE:\n                v = POP();\n                if (((HiInteger*)v)-&gt;value() == 0)\n                    pc = op_arg;\n                break;\n</code></pre><p>上述实现只做了一个动作：当栈顶值为 0 时，把 pc 的值修改成目标地址（第4行）。刚刚我们讲到，现阶段我们用值为 0 的整数代表 False，所以当栈顶值为 False 的时候，就跳转到参数所指定的目标地址，如果是 True，就什么也不做，继续执行下面的语句。</p><p>三个字节码，我们已经实现了两个，还剩下最后一个：<strong>JUMP_FORWARD</strong>。这个字节码其实是最简单的，它也是带参数的，它的参数是一个无符号正数，代表相对地址，也就是用当前的 pc 加上这个参数才是要跳转的目标地址。就像它的名称所指示的，这个字节码只能向前跳转，所以它的参数一定是一个正数。你可以看一下它的代码。</p><pre><code class=\"language-c++\">            case ByteCode::JUMP_FORWARD:\n                pc += op_arg;\n                break;\n</code></pre><p>到这里，我们就把分支结构所需要的字节码全都实现了。现在可以编译执行一下。</p><pre><code class=\"language-plain\">src/build# make all\n...\nsrc/build# ./vm/pvm test_if.pyc \nmagic number is 0xa0df303\nmoddate is 0x5b66d766\nflags is 0x40\nparse OK!\n2\n3\n</code></pre><p>我们看到，结果是打印出了 2 和 3，这个结果符合预期。你不妨尝试一下等于、小于、不等于等其他比较操作，看看结果是否正确。</p><h2>实现True、False和None</h2><p>在前面的实现中，我们要使用 True 和 False 时，都是使用整型的 1 和 0 代替的。而且每次使用的时候，都要重新创建一个整型对象。实际上，整个虚拟机中只需要一个唯一的 True 对象和唯一的 False 对象。要实现全局唯一，我们自然就会想到 <strong>static 变量</strong>。除了 True 和 False，还有一个是 None 对象，它也是全局唯一的。</p><p>类似 True 和 False 这种全局唯一变量，未来还会遇到很多，所以我们把所有的这些变量都集中起来放到一个类中。我们不妨把这个类叫作 Universe，你可以看一下它的定义。</p><pre><code class=\"language-c++\">// runtime/universe.hpp\nclass Universe {\npublic:\n    static HiInteger* HiTrue;\n    static HiInteger* HiFalse;\n\n    static HiObject* HiNone;\n\npublic:\n    static void genesis();\n    static void destroy();\n};\n</code></pre><p>在 Universe 类中定义了三个静态变量，分别代表 True、False 和 None，又定义了两个方法，一个名为Genesis，意思是创世纪，就像宇宙的诞生，在这个函数中创建虚拟机最原始的对象结构。虚拟机里的所有对象以后都会以这个方法为起点。另一个是 destroy，顾名思义，这个方法是在虚拟机退出的时候调用，用来销毁对象，释放资源，清理空间。下面我们看一下这个类的具体实现。</p><pre><code class=\"language-c++\">// runtime/universe.cpp\nHiInteger* Universe::HiTrue   = NULL;\nHiInteger* Universe::HiFalse  = NULL;\n\nHiObject*  Universe::HiNone   = NULL;\n\nvoid Universe::genesis() {\n    HiTrue       = new HiInteger(1);\n    HiFalse      = new HiInteger(0);\n\n    HiNone       = new HiObject();\n}\n\nvoid Universe::destroy() {\n}\n</code></pre><p>首先，是 True、False 和 None 对象的初始化。static 变量在源文件中定义初始化，而不是在头文件中，是为了避免多个目标文件的链接冲突。我们在 genesis 方法里做真正的初始化，这样做的好处是，我们对于对象初始化的时机有绝对的掌控权，而不是交给编译器去决定。也就是说，<strong>只有我们明确地调用 genesis 的时候，对象才会真正开始初始化</strong>，这样我们就有机会在对象初始化之前做一些额外的工作。</p><p>实际上，这里完全可以把 HiTrue 和 HiFalse 这两个变量初始化为任意对象。对于虚拟机来说，真正有意义的是它们的地址，而不是它们的值。也就是说，这里只要指定一个绝对地址，然后说它就是 True，或者说它就是 None 就可以。</p><p>经过这样的改进，BinaryFileParser 在解析常量表的时候，就可以把字母“N”解析成 HiNone，而不是 NULL 指针。以此类推，HiInteger 的 greater 方法，也不用每次执行都创建一个新的对象，只要返回一个全局唯一的 True 和 False就可以了。</p><pre><code class=\"language-c++\">// use HiTrue and HiFalse instead of creating a new \n// object everytime.\nHiObject* HiInteger::greater(HiObject* x) {\n    if (_value &gt; ((HiInteger*)x)-&gt;_value)\n        //return new HiInteger(1);\n        return Universe::HiTrue;\n    else\n        //return new HiInteger(0);\n        return Universe::HiFalse;\n}\n</code></pre><p>其他的方法，比如 less、equal 等都有相同的改动。</p><p>还有一处修改是要注意的，interpreter 中对 JUMP_IF_FALSE 的实现，在判断 False 时，我们也不用再使用强制类型转换了，而是换成更加简单的地址比较。</p><pre><code class=\"language-c++\">             case ByteCode::POP_JUMP_IF_FALSE:\n                v = POP();\n\t\t\t\t//if (((HiInteger*)v)-&gt;value() == 0)\n                if (v == Universe::HiFalse)\n                    pc = op_arg;\n                break;\n</code></pre><p>到这里，分支操作所需要的比较和跳转功能就全部实现了。</p><h2>总结</h2><p>控制流的作用是控制程序的执行顺序，主要包含分支和循环两种结构，这节课我们重点介绍了分支语句的实现原理。</p><p>比较指令和跳转指令是实现分支语句的基础。Python 字节码中用于比较判断的指令是 COMPARE_OP，这节课的第二部分我们实现了这个字节码。每个比较指令结果都是布尔值 True 或者 False。在第二部分，我们临时使用了整型变量 1 和 0 来代替。后面我们又使用全局变量补全了 True、False 和 None 的实现。</p><p>用于跳转的指令，这节课中出现两条，第一条是<strong>POP_JUMP_IF_FALSE</strong>，它的含义是取出栈顶元素并判断，如果栈顶元素是 True，就不发生跳转，如果栈顶元素是 False，就跳转到这条字节码的参数所指定的目标地址，所以这是一条绝对跳转指令。</p><p>这节课出现的第二条跳转指令是 <strong>JUMP_FORWARD</strong>。执行这条指令不需要进行条件判断，但是它的参数却有些不一样。这条字节码的参数是目标地址相对于当前指令地址的偏移量，计算目标地址的时候，需要用当前地址加上这个偏移量。</p><p>实现了这些功能，我们这节课开头的例子就能正确执行了。成功地实现分支语句后，下节课我们继续实现循环语句。</p><p><span class=\"reference\">注：点击链接查看<a href=\"https://gitee.com/hinus/pythonvm/tree/geektime/\">课程代码地址</a></span></p><h2>思考题</h2><p>None 也可以用于条件判断，Python语言是如何处理它的呢？</p><p>如果执行我给出的这段代码，它的结果会是什么？我们的虚拟机又该如何修改，来支持这个特性呢？</p><pre><code class=\"language-python\">if None:\n    print(0)\nelse:\n    print(1)\n</code></pre><p>欢迎你把你的答案分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":390622,"user_name":"细雨平湖","can_delete":false,"product_type":"c1","uid":1144394,"ip_address":"北京","ucode":"D7F571A24388F2","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/4a/014c6775.jpg","comment_is_top":false,"comment_ctime":1715781380,"is_pvip":false,"replies":[{"id":142078,"content":"👍👏🏻","user_name":"作者回复","user_name_real":"编辑","uid":1360512,"ctime":1715790821,"ip_address":"浙江","comment_id":390622,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"讲得很不错。","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645134,"discussion_content":"👍👏🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715790822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391275,"user_name":"细露仔","can_delete":false,"product_type":"c1","uid":2054967,"ip_address":"广东","ucode":"58A586052657A8","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5b/37/aedccd85.jpg","comment_is_top":false,"comment_ctime":1717788602,"is_pvip":false,"replies":[{"id":142358,"content":"哦，是代码仓里的一个小工具。位于tools目录下。你去代码仓里看。由于是个开源小工具，我就没详细介绍。","user_name":"作者回复","user_name_real":"编辑","uid":1360512,"ctime":1718338171,"ip_address":"浙江","comment_id":391275,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"哎，这个show_file.py是什么时候冒出来的啊？我全局搜索也没发现前面的哪个章节有实现过他啊？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646615,"discussion_content":"哦，是代码仓里的一个小工具。位于tools目录下。你去代码仓里看。由于是个开源小工具，我就没详细介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1718338171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390718,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"上海","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1716098219,"is_pvip":true,"replies":[{"id":142111,"content":"是的。所以我们指定了3.8来讲解。3.10的操作数除了2，所以分析的时候要把操作数先乘以2。","user_name":"作者回复","user_name_real":"编辑","uid":1360512,"ctime":1716176663,"ip_address":"上海","comment_id":390718,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"Python 3.10编译出的跳转指令参数有差别\n\n7212\n6 POP_JUMP_IF_FALSE 18\n\n7209\n6 POP_JUMP_IF_FALSE 9 (to 18)\n\n6e08\n16 JUMP_FORWARD 8 (to 26)\n\n6e04\n16 JUMP_FORWARD 4 (to 26)","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645446,"discussion_content":"是的。所以我们指定了3.8来讲解。3.10的操作数除了2，所以分析的时候要把操作数先乘以2。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716176663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1038574,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg","nickname":"Only now","note":"","ucode":"C617473A03AE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":645479,"discussion_content":"老师，这种改变的益处是什么呢?看手册说其操作数含义由原先的字节偏移改为了指令数的偏移,现在版本的解释器的实现数指令比数字节更高效了吗?还是为了标准更统一?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716217439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645446,"ip_address":"北京","group_id":0},"score":645479,"extra":""}]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645399,"discussion_content":"Changed in version 3.10: The argument of jump, exception handling and loop instructions is now the instruction offset rather than the byte offset. https://docs.python.org/3/library/dis.html","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1716098413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395089,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1729403211,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0}]}