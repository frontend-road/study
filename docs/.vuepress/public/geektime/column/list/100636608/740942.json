{"id":740942,"title":"3.2 二叉查找树","content":"\n<p>在本节中我们将学习一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的符号表实现。具体来说，就是使用每个结点含有<strong>两个</strong>链接（链表中每个结点只含有一个链接）的二叉查找树来高效地实现符号表，这也是计算机科学中最重要的算法之一。</p>\n<p>首先，我们需要定义一些术语。我们所使用的数据结构由<strong>结点</strong>组成，结点包含的<strong>链接</strong>可以为空（<code>null</code>）或者指向其他结点。在<strong>二叉树</strong>中，每个结点只能有一个父结点（只有一个例外，也就是<strong>根结点</strong>，它没有父结点），而且每个结点都只有<strong>左右</strong>两个链接，分别指向自己的<strong>左子结点</strong>和<strong>右子结点</strong>（如图 3.2.1 所示）。尽管链接指向的是结点，但我们可以将每个链接看做指向了另一棵二叉树，而这棵树的根结点就是被指向的结点。因此我们可以将二叉树定义为一个空链接，或者是一个有左右两个链接的结点，每个链接都指向一棵（独立的<strong>）子二叉树</strong>。在<strong>二叉查找树</strong>中，每个结点还包含了一个键和一个值，键之间也有顺序之分以支持高效的查找。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01308.gif\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.1　详解二叉树</strong></p>\n<blockquote>\n<p><strong>定义</strong>。一棵<strong>二叉查找树</strong>（BST）是一棵二叉树，其中每个结点都含有一个 <code>Comparable</code> 的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。</p>\n</blockquote>\n<p>我们在画出二叉查找树时会将键写在结点上。我们使用“A 是 E 的左子结点”的说法用键指代结点。我们用连接结点的线表示链接，并将键对应的值写在结点旁边（若值不确定则省略）。除了空结点只表示为向下的一条线段以外，每个结点的链接都指向它下方的结点。和以前一样，我们在例子中只会使用索引测试用例生成的单个字母作为键，如图 3.2.2 所示。</p><!-- [[[read_end]]] -->\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01309.gif\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.2　详解二叉查找树</strong></p>\n<h3 id=\"nav_point_130\">3.2.1　基本实现</h3>\n<p>算法 3.3 定义了二叉查找树（BST）的数据结构，我们会在本节中用它实现有序符号表的 API。首先我们要研究一下这个经典的数据类型，以及与它的特点紧密相关的 <code>get()</code>（查找）和 <code>put()</code>（插入）方法的实现。</p>\n<h4>3.2.1.1　数据表示</h4>\n<p>和链表一样，我们嵌套定义了一个私有类来表示二叉查找树上的一个结点。每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器（有需要时我们会在图中将结点计数器的值写在结点上方）。左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树。变量 <code>N</code> 给出了以该结点为根的子树的结点总数。你将会看到，它简化了许多有序符号表的操作的实现。算法 3.3 中实现的私有方法 <code>size()</code> 会将空链接的值当作 0，这样我们就能保证以下公式对于二叉树中的任意结点 <code>x</code> 总是成立。</p>\n<pre class=\"code-rows\"><code>size(x) = size(x.left) + size(x.right) + 1</code></pre>\n<p>一棵二叉查找树代表了一组键（及其相应的值）的<strong>集合</strong>，而同一个集合可以用多棵不同的二叉查找树表示（如图 3.2.3 所示）。如果我们将一棵二叉查找树的所有键投影到一条直线上，保证一个结点的左子树中的键出现在它的左边，右子树中的键出现在它的右边，那么我们一定可以得到一条有序的键列。我们会利用二叉查找树的这种天生的灵活性，用多棵二叉查找树表示同一组有序的键来实现构建和使用二叉查找树的高效算法。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01310.gif\" alt=\"\" width=\"40%\" style=\"width: 40%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.3　两棵能够表示同一组键的二叉查找树</strong></p>\n<h4>3.2.1.2　查找</h4>\n<p>一般来说，在符号表中查找一个键可能得到两种结果。如果含有该键的结点存在于表中，我们的查找就<strong>命中</strong>了，然后返回相应的值。否则查找<strong>未命中</strong>（并返回 <code>null</code>）。根据数据表示的递归结构我们马上就能得到，在二叉查找树中查找一个键的递归算法：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中，否则我们就（递归地）在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。算法 3.3（续 1）中递归的 <code>get()</code> 方法完全实现了这段算法。它的第一个参数是一个结点（子树的根结点），第二个参数是被查找的键。代码会保证只有该结点所表示的子树才会含有和被查找的键相等的结点。和二分查找中每次迭代之后查找的区间就会减半一样，在二叉查找树中，随着我们不断向下查找，当前结点所表示的子树的大小也在减小（理想情况下是减半，但至少会有一个结点）。当找到一个含有被查找的键的结点（命中）或者当前子树变为空（未命中）时这个过程才会结束。从根结点开始，在每个结点中查找的进程都会递归地在它的一个子结点上展开，因此一次查找也就定义了树的一条路径。对于命中的查找，路径在含有被查找的键的结点处结束。对于未命中的查找，路径的终点是一个空链接，如图 3.2.4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01311.gif\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.4　二叉查找树中的查找命中（左）和未命中（右）</strong></p>\n<blockquote>\n<p><strong>算法 3.3　基于二叉查找树的符号表</strong></p>\n<pre class=\"code-rows\"><code>public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt;\n{\n   private Node root;               // 二叉查找树的根结点\n\n   private class Node\n   {\n      private Key key;              // 键\n      private Value val;            // 值\n      private Node left, right;     // 指向子树的链接\n      private int N;                // 以该结点为根的子树中的结点总数\n\n      public Node(Key key, Value val, int N)\n      {  this.key = key; this.val = val; this.N = N; }\n   }\n\n   public int size()\n   {  return size(root);  }\n\n   private int size(Node x)\n   {\n      if (x == null) return 0;\n      else           return x.N;\n   }\n\n   public Value get(Key key)\n   // 请见算法3.3（续1）\n\n   public void put(Key key, Value val)\n   // 请见算法3.3（续1）\n\n   // max()、min()、floor()、ceiling()方法请见算法3.3（续2）\n   // select()、rank()方法请见算法3.3（续3）\n   // delete()、deleteMin()、deleteMax()方法请见算法3.3（续4）\n   // keys()方法请见算法3.3（续5）\n}</code></pre>\n<p>这段代码用二叉查找树实现了有序符号表的 API，树由 <code>Node</code> 对象组成，每个对象都含有一对键值、两条链接和一个结点计数器 <code>N</code>。每个 <code>Node</code> 对象都是一棵含有 <code>N</code> 个结点的子树的根结点，它的左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树。<code>root</code> 变量指向二叉查找树的根结点 <code>Node</code> 对象（这棵树包含了符号表中的所有键值对）。本节会陆续给出其他方法的实现。</p>\n</blockquote>\n<p>算法 3.3（续 1）的实现过程如下所示。</p>\n<blockquote>\n<p><strong>算法 3.3（续 1）二叉查找树的查找和排序方法的实现</strong></p>\n<pre class=\"code-rows\"><code>public Value get(Key key)\n{  return get(root, key);  }\nprivate Value get(Node x, Key key)\n{  // 在以x为根结点的子树中查找并返回key所对应的值；\n   // 如果找不到则返回null\n   if (x == null) return null;\n   int cmp = key.compareTo(x.key);\n   if      (cmp &lt; 0) return get(x.left, key);\n   else if (cmp &gt; 0) return get(x.right, key);\n   else return x.val;\n}\n\npublic void put(Key key, Value val)\n{  // 查找key，找到则更新它的值，否则为它创建一个新的结点\n   root = put(root, key, val);\n}\n\nprivate Node put(Node x, Key key, Value val)\n{\n   // 如果key存在于以x为根结点的子树中则更新它的值；\n   // 否则将以key和val为键值对的新结点插入到该子树中\n   if (x == null) return new Node(key, val, 1);\n   int cmp = key.compareTo(x.key);\n   if      (cmp &lt; 0) x.left  = put(x.left,  key, val);\n   else if (cmp &gt; 0) x.right = put(x.right, key, val);\n   else x.val = val;\n   x.N = size(x.left) + size(x.right) + 1;\n   return x;\n}</code></pre>\n<p>这段代码实现了有序符号表 <code>API</code> 中的 <code>put()</code> 和 <code>get()</code> 方法，它们的递归实现也是本章稍后将会讨论的其他几种实现的模板。每个方法的实现既可以看做是实用的代码，也可以看做是之前讨论的递推猜想的证明。</p>\n</blockquote>\n<h4>3.2.1.3　插入</h4>\n<p>算法 3.3（续 1）中的查找代码几乎和二分查找的一样简单，这种简洁性是二叉查找树的重要特性之一。而二叉查找树的另一个更重要的特性就是插入的实现难度和查找差不多。当查找一个不存在于树中的结点并结束于一条空链接时，我们需要做的就是将链接指向一个含有被查找的键的新结点（详见图 3.2.5）。算法 3.3（续 1）中递归的 <code>put()</code> 方法的实现逻辑和递归查找很相似：如果树是空的，就返回一个含有该键值对的新结点；如果被查找的键小于根结点的键，我们会继续在左子树中插入该键，否则在右子树中插入该键。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01312.gif\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.5　二叉查找树的插入操作</strong></p>\n<h4>3.2.1.4　递归</h4>\n<p>这些递归实现值得我们花点儿时间去理解其中的运行细节。可以将递归调用<strong>前</strong>的代码想象成<strong>沿着树向下走</strong>：它会将给定的键和每个结点的键相比较并根据结果向左或者向右移动到下一个结点。然后可以将递归调用<strong>后</strong>的代码想象成<strong>沿着树向上爬</strong>。对于 <code>get()</code> 方法，这对应着一系列的返回指令（<code>return</code>），但是对于 <code>put()</code> 方法，这意味着重置搜索路径上每个父结点指向子结点的链接，并增加路径上每个结点中的计数器的值。在一棵简单的二叉查找树中，唯一的新链接就是在最底层指向新结点的链接，重置更上层的链接可以通过比较语句来避免。同样，我们只需要将路径上每个结点中的计数器的值加 1，但我们使用了更加通用的代码，使之等于结点的所有子结点的计数器之和加 1。在本节和下一节中，我们会学习一些更加高级但原理相同的算法，但它们在搜索路径上需要改变的链接更多，也需要适应性更强的代码来更新结点计数器。基本的二叉查找树的实现常常是非递归的（请见练习 3.2.13）——我们在实现中使用了递归，一来是为了便于读者理解代码的工作方式，二来也是为学习更加复杂的算法做准备。</p>\n<p>图 3.2.6 是对我们的标准索引用例轨迹的一份详细的研究，它向你展示了二叉树是如何生长的。新结点会连接到树底层的空链接上，树的其他部分则不会改变。例如，第一个被插入的键就是根结点，第二个被插入的键是根结点的两个子结点之一，以此类推。因为每个结点都含有两个链接，树会逐渐长大而不是萎缩。不仅如此，因为只有查找或者插入路径上的结点才会被访问，所以随着树的增长，被访问的结点数量占树的总结点数的比例也会不断的降低。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01313.gif\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.6　使用二叉查找树的标准索引用例的轨迹</strong></p>\n<h3 id=\"nav_point_131\">3.2.2　分析</h3>\n<p>使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。在最好的情况下，一棵含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个结点的树是完全平衡的，每条空链接和根结点的距离都为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00914.gif\" alt=\"\\sim\\lg N\" inline-img=\"true\" />。在最坏的情况下，搜索路径上可能有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个结点。如图 3.2.7 所示。但在一般情况下树的形状和最好情况更接近。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01314.gif\" alt=\"\" width=\"35%\" style=\"width: 35%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.7　二叉查找树的可能形状</strong></p>\n<p>对于很多应用来说，图 3.2.8 所示的简单模型都是适用的：我们假设键的分布是（均匀）随机的，或者说它们的插入顺序是<strong>随机的</strong>。对这个模型的分析而言，二叉查找树和快速排序几乎就是“双胞胎”。树的根结点就是快速排序中的第一个切分元素（左侧的键都比它小，右侧的键都比它大），而这对于所有的子树同样适用，这和快速排序中对子数组的递归排序完全对应。这使我们能够分析得到二叉查找树的一些性质。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01315.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.8　一棵典型的二叉查找树，由 256 个随机键组成</strong></p>\n<blockquote>\n<p><strong>命题 C</strong>。在由 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个随机键构造的二叉查找树中，查找命中平均所需的比较次数为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01316.gif\" alt=\"\\sim2\\ln N\" inline-img=\"true\" />（约 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01317.gif\" alt=\"1.39\\lg N\" inline-img=\"true\" />）。</p>\n<p><strong>证明</strong>。一次结束于给定结点的命中查找所需的比较次数为查找路径的深度加 1。如果将树中的所有结点的深度加起来，我们就能够得到一棵树的<strong>内部路径长度</strong>。因此，在二叉查找树中的平均比较次数即为平均内部路径长度加 1。我们可以使用 2.3 节的命题 K 的证明得到它：令 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01174.gif\" alt=\"C_N\" inline-img=\"true\" /> 为由 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个随机排序的不同键构造得到的二叉查找树的内部路径长度，则查找命中的平均成本为（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01318.gif\" alt=\"1+C_N/N\" inline-img=\"true\" />）。我们有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01175.gif\" alt=\"C_0=C_1=0\" inline-img=\"true\" />，且对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01176.gif\" alt=\"N&gt;1\" inline-img=\"true\" /> 我们可以根据二叉查找树的递归结构直接得到一个归纳关系式：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01319.gif\" alt=\"C_N=N-1+(C_0+C_)/N+(C_1+C_)/N+\\cdots+(C_+C_0)/N\" /></p>\n<p>其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00799.gif\" alt=\"N-1\" inline-img=\"true\" /> 这一项表示根结点使得树中的所有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00799.gif\" alt=\"N-1\" inline-img=\"true\" /> 个非根结点的路径上都加了 1。表达式的其他项代表了所有子树，它们的计算方法和大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的二叉查找树的方法相同。整理表达式后我们会发现，这个归纳公式和我们在2.3节中为快速排序得到的公式几乎完全相同，因此我们同样可以得到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01183.gif\" alt=\"C_N\\sim2N\\ln N\" inline-img=\"true\" />。</p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>命题 D</strong>。在由 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为  <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01316.gif\" alt=\"\\sim2\\ln N\" inline-img=\"true\" />（约 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01317.gif\" alt=\"1.39\\lg N\" inline-img=\"true\" />）。</p>\n<p><strong>证明</strong>。插入操作和查找未命中平均比查找命中需要一次额外的比较。这一点由归纳法不难得到（请见练习 3.2.16）。</p>\n</blockquote>\n<p>命题 C 说明在二叉查找树中查找随机键的成本比二分查找高约 39%。命题 D 说明这些额外的成本是值得的，因为插入一个新键的成本是对数级别的——这是基于二分查找的有序数组所不具备的灵活性，因为它的插入操作所需访问数组的次数是线性级别的。和快速排序一样，比较次数的标准差很小，因此 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 越大这个公式越准确。</p>\n<p><strong>实验</strong></p>\n<p>我们的随机键模型和典型的符号表使用情况是否相符？按照惯例，这个问题的答案需要具体问题具体分析，因为在不同的应用场景中性能的差别可能很大。幸好，对于大多数用例，这个模型都能很好地适应。</p>\n<p>作为例子，我们研究用 <code>FrequencyCounter</code> 处理长度大于等于 8 的单词时 <code>put()</code> 操作的成本。从图 3.2.9 可以看到，每次操作的平均成本从 <code>BinarySearchST</code> 的 484 次数组访问降低到了二叉查找树的 13 次，这也再次验证了理论模型所预测的对数级别的性能。根据命题 C 和命题 D，这个数值的合理大小应该是符号表大小的自然对数的两倍左右，因为对于一个几乎充满的符号表，大多数操作都是查找。这个预测至少有以下不准确性：</p>\n<ul>\n<li>很多操作都是在较小的符号表中进行的；</li>\n<li>键不随机；</li>\n<li>符号表可能太小，近似值 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01320.gif\" alt=\"2\\ln N\" /> 不准确。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01321.gif\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.9　使用二叉查找树，运行 <code>java FrequencyCounter 8 &lt; tale.txt</code> 的成本</strong></p>\n<p>无论如何，通过表 3.2.1 你都能看到，对于 <code>FrequencyCounter</code> 这个预测的误差只有若干次比较。事实上，大多数误差都能通过对近似值的数学表达式的改进得到解释（请见练习 3.2.35）。</p>\n<p><strong>表 3.2.1　使用二叉查找树的 <code>FrequencyCounter</code> 的每次 <code>put()</code> 操作平均所需的比较次数</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><th rowspan=\"3\"></th><th colspan=\"4\">tale.txt</th><th colspan=\"4\">leipzig1M.txt</th></tr>\n<tr><th rowspan=\"2\">单词数</th><th rowspan=\"2\">不同单词数</th><th colspan=\"2\">比较次数</th><th rowspan=\"2\">单词数</th><th rowspan=\"2\">不同单词数</th><th colspan=\"2\">比较次数</th></tr>\n<tr><th>模型预测</th><th>实际次数</th><th>模型预测</th><th>实际次数</th></tr>\n<tr><td>所有单词</td><td>135 635</td><td>10 679</td><td>18.6</td><td>17.5</td><td>21 191 455</td><td>534 580</td><td>23.4</td><td>22.1</td></tr>\n<tr><td>长度大于等于 8 的单词</td><td>14 350</td><td>5 131</td><td>17.6</td><td>13.9</td><td>4 239 597</td><td>299 593</td><td>22.7</td><td>21.4</td></tr>\n<tr><td>长度大于等于 10 的单词</td><td>4 582</td><td>2 260</td><td>15.4</td><td>13.1</td><td>1 610 829</td><td>165 555</td><td>20.5</td><td>19.3</td></tr>\n</table>\n\n<h3 id=\"nav_point_132\">3.2.3　有序性相关的方法与删除操作</h3>\n<p>二叉查找树得以广泛应用的一个重要原因就是它能够<strong>保持键的有序性</strong>，因此它可以作为实现有序符号表 API（请见 3.1.2 节）中的众多方法的基础。这使得符号表的用例不仅能够通过键还能通过键的相对顺序来访问键值对。下面，我们要研究有序符号表 API 中各个方法的实现。</p>\n<h4>3.2.3.1　最大键和最小键</h4>\n<p>如果根结点的左链接为空，那么一棵二叉查找树中最小的键就是根结点；如果左链接非空，那么树中的最小键就是左子树中的最小键。这不仅描述了算法 3.3（续 2）中 <code>min()</code> 方法的递归实现，同时也递推地证明了它能够在二叉查找树中找到最小的键。简单的循环也能等价实现这段描述，但为了保持一致性我们使用了递归。我们可以让递归调用返回键 <code>Key</code> 而非结点对象 <code>Node</code>，但我们后面还会用到这方法来找出含有最小键的结点。找出最大键的方法也是类似的，只是变为查找右子树而已。</p>\n<h4>3.2.3.2　向上取整和向下取整</h4>\n<p>如果给定的键 <code>key</code> <strong>小于</strong>二叉查找树的根结点的键，那么小于等于 <code>key</code> 的最大键 <code>floor(key)</code> <strong>一定</strong>在根结点的左子树中；如果给定的键 key <strong>大于</strong>二叉查找树的根结点，那么只有当根结点右子树中存在小于等于 <code>key</code> 的结点时，小于等于 <code>key</code> 的最大键才会出现在右子树中，否则根结点就是小于等于 <code>key</code> 的最大键。这段描述说明了 <code>floor()</code> 方法的递归实现，同时也递推地证明了它能够计算出预期的结果。将“左”变为“右”（同时将<strong>小于</strong>变为<strong>大于</strong>）就能够得到 <code>ceiling()</code> 的算法。向下取整函数的计算如图 3.2.10 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01322.gif\" alt=\"\" width=\"45%\" style=\"width: 45%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.10　计算 <code>floor()</code> 函数</strong></p>\n<h4>3.2.3.3　选择操作</h4>\n<p>二叉查找树中的选择操作和 2.5 节中我们学习过的基于切分的数组选择操作类似。我们在二叉查找树的每个结点中维护的子树结点计数器变量 <code>N</code> 就是用来支持此操作的。</p>\n<blockquote>\n<p><strong>算法 3.3（续 2）二叉查找树中 <code>max()</code>、<code>min()</code>、<code>floor()</code>、<code>ceiling()</code> 方法的实现</strong></p>\n<pre class=\"code-rows\"><code>public Key min()\n{\n   return min(root).key;\n}\nprivate Node min(Node x)\n{\n   if (x.left == null) return x;\n   return min(x.left);\n}\npublic Key floor(Key key)\n{\n   Node x = floor(root, key);\n   if (x == null) return null;\n   return x.key;\n}\nprivate Node floor(Node x, Key key)\n{\n   if (x == null) return null;\n   int cmp = key.compareTo(x.key);\n   if (cmp == 0) return x;\n   if (cmp &lt; 0)  return floor(x.left, key);\n   Node t = floor(x.right, key);\n   if (t != null) return t;\n   else           return x;\n}</code></pre>\n<p>每个公有方法都对应着一个私有方法，它接受一个额外的链接作为参数指向某个结点，通过正文中描述的递归方法查找返回 <code>null</code> 或者含有指定 <code>Key</code> 的结点 <code>Node</code>。<code>max()</code> 和 <code>ceiling()</code> 的实现分别与 <code>min()</code> 和 <code>floor()</code> 方法基本相同，只是将代码中的 <code>left</code> 和 <code>right</code>（以及＞和＜）调换而已。</p>\n</blockquote>\n<p>假设我们想找到排名为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 的键（即树中正好有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 个小于它的键）。如果左子树中的结点数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01113.gif\" alt=\"t\" inline-img=\"true\" /> 大于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" />，那么我们就<strong>继续</strong>（递归地）在左子树中查找排名为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 的键；如果 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01113.gif\" alt=\"t\" inline-img=\"true\" /> 等于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" />，我们就返回根结点中的键；如果 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01113.gif\" alt=\"t\" inline-img=\"true\" /> 小于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" />，我们就（递归地）在右子树中查找排名为（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01323.gif\" alt=\"k-t-1\" inline-img=\"true\" />）的键。和刚才一样，这段描述既说明了 <code>select()</code> 方法的递归实现同时也证明了它的正确性，此过程如图 3.2.11 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01324.gif\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.11　二叉查找树中的 <code>select()</code> 操作</strong></p>\n<h4>3.2.3.4　排名</h4>\n<p><code>rank()</code> 是 <code>select()</code> 的逆方法，它会返回给定键的排名。它的实现和 <code>select()</code> 类似：如果给定的键和根结点的键相等，我们返回左子树中的结点总数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01113.gif\" alt=\"t\" inline-img=\"true\" />；如果给定的键小于根结点，我们会返回该键在左子树中的排名（递归计算）；如果给定的键大于根结点，我们会返回 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01325.gif\" alt=\"t+1\" inline-img=\"true\" />（根结点）加上它在右子树中的排名（递归计算）。</p>\n<p>二叉查找树中选择和排名操作的实现如算法 3.3（续 3）所示。</p>\n<blockquote>\n<p><strong>算法 3.3（续 3）二叉查找树中 <code>select()</code> 和 <code>rank()</code> 方法的实现</strong></p>\n<pre class=\"code-rows\"><code>public Key select(int k)\n{\n   return select(root, k).key;\n}\nprivate Node select(Node x, int k)\n{   // 返回排名为k的结点\n    if (x == null) return null;\n    int t = size(x.left);\n    if      (t &gt; k) return select(x.left,  k);\n    else if (t &lt; k) return select(x.right, k-t-1);\n    else            return x;\n}\npublic int rank(Key key)\n{  return rank(key, root);  }\nprivate int rank(Key key, Node x)\n{  // 返回以x为根结点的子树中小于x.key的键的数量\n   if (x == null) return 0;\n   int cmp = key.compareTo(x.key);\n   if      (cmp &lt; 0) return rank(key, x.left);\n   else if (cmp &gt; 0) return 1 + size(x.left) + rank(key, x.right);\n   else              return size(x.left);\n}</code></pre>\n<p>这段代码使用了和我们已经在本章中学习过的其他实现中一样的递归模式实现了 <code>select()</code> 和 <code>rank()</code> 方法。它依赖于本节开始处给出的 <code>size()</code> 方法来统计每个结点以下的子结点总数。</p>\n</blockquote>\n<h4>3.2.3.5　删除最大键和删除最小键</h4>\n<p>二叉查找树中最难实现的方法就是 <code>delete()</code> 方法，即从符号表中删除一个键值对。作为热身运动，我们先考虑 <code>deleteMin()</code> 方法（删除最小键所对应的键值对），如图 3.2.12 所示。和 <code>put()</code> 一样，我们的递归方法接受一个指向结点的链接，并返回一个指向结点的链接。这样我们就能够方便地改变树的结构，将返回的链接赋给作为参数的链接。对于 <code>deleteMin()</code>，我们要不断深入根结点的左子树中直至遇见一个空链接，然后将指向该结点的链接指向该结点的右子树（只需要在递归调用中返回它的右链接即可）。此时已经没有任何链接指向要被删除的结点，因此它会被垃圾收集器清理掉。我们给出的标准递归代码在删除结点后会正确地设置它的父结点的链接并更新它到根结点的路径上的所有结点的计数器的值。<code>deleteMax()</code> 方法的实现和 <code>deleteMin()</code> 完全类似。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01326.gif\" alt=\"\" width=\"45%\" style=\"width: 45%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.12　删除二叉查找树中的最小结点</strong></p>\n<h4>3.2.3.6　删除操作</h4>\n<p>我们可以用类似的方式删除任意只有一个子结点（或者没有子结点）的结点，但应该怎样删除一个拥有两个子结点的结点呢？删除之后我们要处理两棵子树，但被删除结点的父结点只有一条空出来的链接。T. Hibbard 在 1962 年提出了解决这个难题的第一个方法，在删除结点 <code>x</code> 后用它的<strong>后继结点</strong>填补它的位置。因为 <code>x</code> 有一个右子结点，因此它的后继结点就是其右子树中的最小结点。这样的替换仍然能够保证树的有序性，因为 <code>x.key</code> 和它的后继结点的键之间不存在其他的键。我们能够用 4 个简单的步骤完成将 <code>x</code> 替换为它的后继结点的任务（具体过程如图 3.2.13 所示）：</p>\n<ul>\n<li>将指向即将被删除的结点的链接保存为 <code>t</code>；</li>\n<li>将 <code>x</code> 指向它的后继结点 <code>min(t.right)</code>；</li>\n<li>将 <code>x</code> 的右链接（原本指向一棵所有结点都大于 <code>x.key</code> 的二叉查找树）指向 <code>deleteMin(t.right)</code>，也就是在删除后所有结点仍然都大于 <code>x.key</code> 的子二叉查找树；</li>\n<li>将 <code>x</code> 的左链接（本为空）设为 <code>t.left</code>（其下所有的键都小于被删除的结点和它的后继结点）。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01327.gif\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.13　二叉查找树中的删除操作</strong></p>\n<p>在递归调用后我们会修正被删除的结点的父结点的链接，并将由此结点到根结点的路径上的所有结点的计数器减 1（这里计数器的值仍然会被设为其所有子树中的结点总数加一）。尽管这种方法能够正确地删除一个结点，它的一个缺陷是可能会在某些实际应用中产生性能问题。这个问题在于选用后继结点是一个随意的决定，且没有考虑树的对称性。可以使用它的前趋结点吗？实际上，前趋结点和后继结点的选择应该是随机的。详细讨论请见练习 3.2.42。</p>\n<p>二叉查找树中删除操作的实现如算法 3.3（续 4）所示。</p>\n<blockquote>\n<p><strong>算法 3.3（续 4）二叉查找树的 <code>delete()</code> 方法的实现</strong></p>\n<pre class=\"code-rows\"><code>public void deleteMin()\n{\n   root = deleteMin(root);\n}\n\nprivate Node deleteMin(Node x)\n{\n   if (x.left == null) return x.right;\n   x.left = deleteMin(x.left);\n   x.N = size(x.left) + size(x.right) + 1;\n   return x;\n}\n\npublic void delete(Key key)\n{  root = delete(root, key);  }\n\nprivate Node delete(Node x, Key key)\n{\n   if (x == null) return null;\n   int cmp = key.compareTo(x.key);\n   if      (cmp &lt; 0) x.left  = delete(x.left,  key);\n   else if (cmp &gt; 0) x.right = delete(x.right, key);\n   else\n   {\n      if (x.right == null) return x.left;\n      if (x.left == null) return x.right;\n      Node t = x;\n      x = min(t.right);  // 请见算法3.3（续2）\n      x.right = deleteMin(t.right);\n      x.left = t.left;\n   }\n   x.N = size(x.left) + size(x.right) + 1;\n   return x;\n}</code></pre>\n<p>如前文所述，这段代码实现了 Hibbard 的二叉查找树中对结点的即时删除。<code>delete()</code> 方法的代码很简洁，但不简单。也许理解它的最好办法就是读懂正文中的讲解，试着自己实现它并对比自己的代码和这段代码。一般情况下这段代码的效率不错，但对于大规模的应用来说可能会有一点问题（请见练习 3.2.42）。<code>deleteMax()</code> 的实现和 <code>deleteMin()</code> 类似，只需左右互换即可。</p>\n</blockquote>\n<h4>3.2.3.7　范围查找</h4>\n<p>要实现能够返回给定范围内键的 <code>keys()</code> 方法，我们首先需要一个遍历二叉查找树的基本方法，叫做<strong>中序遍历</strong>。要说明这个方法，我们先看看如何能够将二叉查找树中的所有键按照顺序打印出来。要做到这一点，我们应该先打印出根结点的左子树中的所有键（根据二叉查找树的定义它们应该都小于根结点的键），然后打印出根结点的键，最后打印出根结点的右子树中的所有键（根据二叉查找树的定义它们应该都大于根结点的键），如右侧的代码所示。</p>\n<pre class=\"code-rows\"><code>private void print(Node x)\n{\n   if (x == null) return;\n   print(x.left);\n   StdOut.println(x.key);\n   print(x.right);\n}</code></pre>\n<p style=\"text-align: center\">按顺序打印二叉查找树中的所有键</p>\n<p>和以前一样，刚才的描述也递推地证明了这段代码能够顺序打印树中的所有键。为了实现接受两个参数并能够将给定范围内的键返回给用例的 <code>keys()</code> 方法，我们可以修改一下这段代码，将所有落在给定范围以内的键加入一个队列 <code>Queue</code> 并跳过那些不可能含有所查找键的子树。和 <code>BinarySearchST</code> 一样，用例不需要知道我们使用 <code>Queue</code> 来收集符合条件的键。我们使用什么数据结构来实现 <code>Iterable&lt;Key&gt;</code> 并不重要，用例只要能够使用 Java 的 <code>foreach</code> 语句遍历返回的所有键就可以了。</p>\n<p>二叉查找树的范围查找操作的实现如算法 3.3（续 5）所示。</p>\n<blockquote>\n<p><strong>算法 3.3（续 5）二叉查找树的范围查找操作</strong></p>\n<pre class=\"code-rows\"><code>public Iterable&lt;Key&gt; keys()\n{  return keys(min(), max());  }\n\npublic Iterable&lt;Key&gt; keys(Key lo, Key hi)\n{\n    Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;();\n    keys(root, queue, lo, hi);\n    return queue;\n}\n\nprivate void keys(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)\n{\n   if (x == null) return;\n   int cmplo = lo.compareTo(x.key);\n   int cmphi = hi.compareTo(x.key);\n   if (cmplo &lt; 0) keys(x.left, queue, lo, hi);\n   if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) queue.enqueue(x.key);\n   if (cmphi &gt; 0) keys(x.right, queue, lo, hi);\n}</code></pre>\n<p>为了确保以给定结点为根的子树中所有在指定范围之内的键加入队列，我们会（递归地）查找根结点的左子树，然后查找根结点，然后（递归地）查找根结点的右子树。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01328.gif\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p style=\"text-align: center\"><strong>二叉查找树的范围查找</strong></p>\n</blockquote>\n<h4>3.2.3.8　性能分析</h4>\n<p>二叉查找树中和有序性相关的操作的效率如何？要研究这个问题，我们首先要知道<strong>树的高度</strong>（即树中任意结点的最大深度）。给定一棵树，树的高度决定了所有操作在最坏情况下的性能（范围查找除外，因为它的额外成本和返回的键的数量成正比）。</p>\n<blockquote>\n<p><strong>命题 E</strong>。在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。</p>\n<p><strong>证明</strong>。树的所有操作都沿着树的一条或两条路径行进。根据定义，路径的长度不可能大于树的高度。</p>\n</blockquote>\n<p>我们估计树的高度（即最坏情况下的成本）将会大于我们在 3.2.2 节中定义的平均内部路径长度（这个平均值已经包含了所有较短的路径），但会高多少呢？也许在你看来这个问题和命题 C 和命题 D 解答的问题类似，但它的解答其实要困难得多，完全超出了本书的范畴。1979 年，J. Robson 证明了随机键构造的二叉查找树的平均高度为树中结点数的对数级别，随后 L. Devroye 证明了对于足够大的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />，这个值趋近于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01329.gif\" alt=\"2.99\\lg N\" inline-img=\"true\" />。因此，如果我们的应用中的插入操作能够适用于这个随机模型，我们距离实现一个支持对数级别的所有操作的符号表的目标就已经不远了。我们可以认为随机构造的树中的所有路径长度都小于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01330.gif\" alt=\"3\\lg N\" inline-img=\"true\" />，但如果构造树的键不是随机的怎么办？在下一节中你会看到在实际应用中这个问题其实没有意义，因为还有<strong>平衡二叉查找树</strong>，它能保证无论键的插入顺序如何，树的高度都将是总键数的对数。</p>\n<p>总的来说，二叉查找树的实现并不困难，且当树的构造和随机模型近似时在各种实际应用场景中它都能进行快速地查找和插入。对于我们的例子（以及其他许多实际应用场景）来说，二叉查找树将不可能完成的任务变为可能。另外，许多程序员都偏爱基于二叉查找树的符号表的原因是它还支持高效的 <code>rank()</code>、<code>select()</code>、<code>delete()</code> 以及范围查找等操作。但同时，正如我们所强调过的，在某些场景中二叉查找树在最坏情况下的恶劣性能仍然是不可接受的。二叉查找树的基本实现的良好性能依赖于其中的键的分布足够随机以消除长路径。对于快速排序，我们可以先将数组打乱；而对于符号表的 API，我们无能为力，因为符号表的用例控制着各种操作的先后顺序。但最坏情况在实际应用也有可能出现——用例将所有键按照顺序或者逆序插入符号表就会增加这种情况出现的概率，而在没有明确的警告来避免这种行为时有些用例肯定会尝试这么做。这就是我们寻找更好的算法和数据结构的主要原因，这些算法和数据结构我们会在下一节学习。</p>\n<p>本书中简单的符号表实现的成本列在表 3.2.2 中。</p>\n<p><strong>表 3.2.2　简单的符号表实现的成本总结</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><th rowspan=\"2\">算法（数据结构）</th><th colspan=\"2\">最坏情况下的运行时间的增长数量级（<i>N</i>次插入之后）</th><th colspan=\"2\">平均情况下的运行时间的增长数量级（<i>N</i>次插入随机键之后）</th><th rowspan=\"2\">是否支持有序性相关的操作</th></tr>\n<tr><th>查找</th><th>插入</th><th>查找命中</th><th>插入</th></tr>\n<tr><td>顺序查询（无序链表）</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00986.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td><td>否</td></tr>\n<tr><td>二分查找（有序数组）</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00915.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00915.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00986.gif\" /></td><td>是</td></tr>\n<tr><td>二叉树查找（二叉查找树）</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01317.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01317.gif\" /></td><td>是</td></tr>\n</table>\n\n<h3 id=\"nav_point_133\">答疑</h3>\n<p><strong>问</strong>　我见过二叉查找树，但它的实现没有使用递归。这两种方式各有哪些优缺点？</p>\n<p><strong>答</strong>　一般来说，递归的实现更容易验证其正确性，而非递归的实现效率更高。在练习 3.2.13 中你需要用另一种方法实现 <code>get()</code>，你可能会注意到性能上的改进。如果树不是平衡的，函数调用的栈的深度可能会成为递归实现的一个问题。我们使用递归的一个主要原因是使读者能够轻松过渡到下一节中的平衡二叉查找树，而且递归版本显然更易于实现和调试。</p>\n<p><strong>问</strong>　维护 <code>Node</code> 对象中的结点计数器似乎需要很多代码，这有必要吗？为什么不只用一个变量来保存整棵树中的结点总数来实现用例中的 <code>size()</code> 方法？</p>\n<p><strong>答</strong>　<code>rank()</code> 和 <code>select()</code> 方法需要知道每个结点所代表的子树中的结点总数。如果你不需要实现这些操作，可以去掉这个变量以简化代码（请见练习 3.2.12）。要保证所有结点中的计数器的正确性的确很容易出错，但这个值在调试中同样有用。你也可以用递归的方法实现用例中的 <code>size()</code> 函数，但这样统计所有结点的运行时间可能是<strong>线性</strong>的。这十分危险，因为如果不知道这么一个简单的操作会如此耗时，用例的性能可能会变得很差。</p>\n<h3 id=\"nav_point_134\">练习</h3>\n<p><strong>3.2.1</strong>　将 <code>E A S Y Q U E S T I O N</code> 作为键按顺序插入一棵初始为空的二叉查找树中（方便起见设第 <code>i</code> 个键对应的值为 <code>i</code>），画出生成的二叉查找树。构造这棵树需要多少次比较？</p>\n<p><strong>3.2.2</strong>　将 <code>A X C S E R H</code> 作为键按顺序插入将会构造出一棵最坏情况下的二叉查找树结构，最下方的结点的两个链接全部为空，其他结点都含有一个空链接。用这些键给出构造最坏情况下的树的其他 5 种排列。</p>\n<p><strong>3.2.3</strong>　给出 <code>A X C S E R H</code> 的 5 种能够构造出<strong>最优</strong>二叉查找树的排列。</p>\n<p><strong>3.2.4</strong>　假设某棵二叉查找树的所有键均为 1 至 10 的整数，而我们要查找 5。那么以下哪个<strong>不可能</strong>是键的检查序列？</p>\n<p>　a. 10, 9, 8, 7, 6, 5</p>\n<p>　b. 4, 10, 8, 7, 5, 3</p>\n<p>　c. 1, 10, 2, 9, 3, 8, 4, 7, 6, 5</p>\n<p>　d. 2, 7, 3, 8, 4, 5</p>\n<p>　e. 1, 2, 10, 4, 8, 5</p>\n<p><strong>3.2.5</strong>　假设已知某棵二叉查找树中的每个结点的查找频率，且我们可以以任意顺序用它们构造一棵树。我们是应该按照查找频率的顺序由高到低或是由低到高将它们插入，还是用其他某种顺序？证明你的结论。</p>\n<p><strong>3.2.6</strong>　为二叉查找树添加一个方法 <code>height()</code> 来计算树的高度。实现两种方案：一种使用递归（用时为线性级别，所需空间和树高成正比），一种模仿 <code>size()</code> 在每个结点中添加一个变量（所需空间为线性级别，查询耗时为常数）。</p>\n<p><strong>3.2.7</strong>　为二叉查找树添加一个方法 <code>avgCompares()</code> 来计算一棵给定的树中的一次随机命中查找平均所需的比较次数（即树的内部路径长度除以树的大小再加 1）。实现两种方案：一种使用递归（用时为线性级别，所需空间和树高成正比），一种模仿 <code>size()</code> 在每个结点中添加一个变量（所需空间为线性级别，查询耗时为常数）。</p>\n<p><strong>3.2.8</strong>　编写一个静态方法 <code>optCompares()</code>，接受一个整型参数 <code>N</code> 并计算一棵最优（完美平衡的）二叉查找树中的一次随机查找命中平均所需的比较次数，如果树中的链接数量为 2 的幂，那么所有的空链接都应该在同一层，否则则分布在最底部的两层中。</p>\n<p><strong>3.2.9</strong>　对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01331.gif\" alt=\"N=2\" inline-img=\"true\" />、3、4、5 和 6，画出用 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个键可能构造出的所有不同形状的二叉查找树。</p>\n<p><strong>3.2.10</strong>　编写一个测试用例 TestBST.java 来测试正文中 <code>min()</code>、<code>max()</code>、<code>floor()</code>、<code>ceiling()</code>、<code>select()</code>、<code>rank()</code>、<code>delete()</code>、<code>deleteMin()</code>、<code>deleteMax()</code> 和 <code>keys()</code> 方法的实现。可以参考 3.1.3.1 节的标准索引用例，使它接受其他合适的命令行参数。</p>\n<p><strong>3.2.11</strong>　高度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 且含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个结点的二叉树能有多少种形状？使用 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个不同的键能有多少种不同的方式构造一棵高度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的二叉查找树？（参考练习 3.2.2）</p>\n<p><strong>3.2.12</strong>　实现一种二叉查找树，舍弃 <code>rank()</code> 和 <code>select()</code> 方法并且不在 <code>Node</code> 对象中使用计数器。</p>\n<p><strong>3.2.13</strong>　为二叉查找树实现非递归的 <code>put()</code> 和 <code>get()</code> 方法。</p>\n<p>　<strong>部分解答</strong>，以下是 <code>get()</code> 方法的实现：</p>\n<pre class=\"code-rows\"><code>public Value get(Key key)\n{\n   Node x = root;\n   while (x != null)\n   {\n      int cmp = key.compareTo(x.key);\n      if (cmp == 0) return x.val;\n      else if (cmp &lt; 0) x = x.left;\n      else if (cmp &gt; 0) x = x.right;\n   }\n   return null;\n}</code></pre>\n<p>　<code>put()</code> 的实现更复杂一些，因为它需要保存一个指向底层结点的链接，以便使之成为新结点的父结点。你还需要额外遍历一遍查找路径来更新所有的结点计数器以保证结点插入的正确性。因为在性能优先的实现中查找的次数比插入多得多，有必要使用这段 <code>get()</code> 代码，而相应的 <code>put()</code> 实现则无关紧要。</p>\n<p><strong>3.2.14</strong>　实现非递归的 <code>min()</code>、<code>max()</code>、<code>floor()</code>、<code>ceiling()</code>、<code>rank()</code> 和 <code>select()</code> 方法。</p>\n<p><strong>3.2.15</strong>　对于右下方的二叉查找树，给出计算下列方法的过程中结点的访问序列。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01332.gif\" alt=\"{%}\" /></p>\n<p>　a. <code>floor(\"Q\")</code></p>\n<p>　b. <code>select(5)</code></p>\n<p>　c. <code>ceiling(\"Q\")</code></p>\n<p>　d. <code>rank(\"J\")</code></p>\n<p>　e. <code>size(\"D\", \"T\")</code></p>\n<p>　f. <code>keys(\"D\", \"T\")</code></p>\n<p><strong>3.2.16</strong>　设一棵树的<strong>外部路径长度</strong>为从根结点到空链接的所有路径上的结点总数。证明对于大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的任意二叉树，其外部路径长度和内部路径长度之差为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01046.gif\" alt=\"2N\" inline-img=\"true\" />（可以参考命题 C）</p>\n<p><strong>3.2.17</strong>　从练习 3.2.1 构造的二叉查找树中将所有键按照插入顺序逐个删除并画出每次删除所得到的树。</p>\n<p><strong>3.2.18</strong>　从练习 3.2.1 构造的二叉查找树中将所有键按照字母顺序逐个删除并画出每次删除所得到的树。</p>\n<p><strong>3.2.19</strong>　从练习 3.2.1 构造的二叉查找树中逐次删除树的根结点并画出每次删除所得到的树。</p>\n<p><strong>3.2.20</strong>　请证明：对于含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个结点的二叉查找树，接受两个参数的 <code>size()</code> 方法所需的运行时间最多为树高的倍数加上查找范围内的键的数量。</p>\n<p><strong>3.2.21</strong>　为二叉查找树添加一个 <code>randomKey()</code> 方法来在和树高成正比的时间内从符号表中随机返回一个键。</p>\n<p><strong>3.2.22</strong>　请证明：若一棵二叉查找树中的一个结点有两个子结点，那么它的后继结点不会有左子结点，前趋结点不会有右子结点。</p>\n<p><strong>3.2.23</strong>　<code>delete()</code> 方法符合交换律吗？（先删除 <code>x</code> 后删除 <code>y</code> 和先删除 <code>y</code> 后删除 <code>x</code> 能够得到相同的结果吗？）</p>\n<p><strong>3.2.24</strong>　请证明：使用基于比较的算法构造一棵二叉查找树所需的最小比较次数为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01148.gif\" alt=\"\\lg(N!)\\sim N\\lg N\" inline-img=\"true\" />。</p>\n<h3 id=\"nav_point_135\">提高题</h3>\n<p><strong>3.2.25</strong>　<strong>完美平衡</strong>。编写一段程序，用一组键构造一棵和二分查找等价的二叉查找树。也就是说，在这棵树中查找任意键所产生的比较序列和在这组键中使用二分查找所产生的比较序列完全相同。</p>\n<p><strong>3.2.26</strong>　<strong>准确的概率</strong>。计算用 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个随机的互不相同的键构造出练习 3.2.9 中的每一棵树的概率。</p>\n<p><strong>3.2.27</strong>　<strong>内存使用</strong>。基于 1.4 节的假设，对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 对键值比较二叉查找树和 <code>BinarySearchST</code> 以及 <code>SequentialSearchST</code> 的内存使用情况。不需要记录键值本身占用的内存，只统计它们的引用。用图精确描述一棵以 <code>String</code> 为键、<code>Integer</code> 为值的二叉查找树（比如 <code>FrequencyCounter</code> 构造的那种）的内存使用情况，然后估计 <code>FrequencyCounter</code> 在使用二叉查找树处理《双城记》时树的内存使用情况（精确到字节）。</p>\n<p><strong>3.2.28</strong>　<strong>缓存</strong>。修改二叉查找树的实现，将最近访问的结点 <code>Node</code> 保存在一个变量中，这样 <code>get()</code> 或 <code>put()</code> 再次访问同一个键时就只需要常数时间了（参考练习 3.1.25）。</p>\n<p><strong>3.2.29</strong>　<strong>二叉树检查</strong>。编写一个递归的方法 <code>isBinaryTree()</code>，接受一个结点 <code>Node</code> 为参数。如果以该结点为根的子树中的结点总数和计数器的值 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 相符则返回 <code>true</code>，否则返回 <code>false</code>。<strong>注意</strong>：这项检查也能保证数据结构中不存在环，因此这的确是一棵二叉树！</p>\n<p><strong>3.2.30</strong>　<strong>有序性检查</strong>。编写一个递归的方法 <code>isOrdered()</code>，接受一个结点 <code>Node</code> 和 <code>min</code>、<code>max</code> 两个键作为参数。如果以该结点为根的子树中的所有结点都在 <code>min</code> 和 <code>max</code> 之间，<code>min</code> 和 <code>max</code> 的确分别是树中的最小和最大的结点且二叉查找树的有序性对树中的所有键都成立，返回 <code>true</code>，否则返回 <code>false</code>。</p>\n<p><strong>3.2.31</strong>　<strong>等值键检查</strong>。编写一个方法 <code>hasNoDuplicates()</code>，接受一个结点 <code>Node</code> 为参数。如果以该结点为根的二叉查找树中不含有等值的键则返回 <code>true</code>，否则返回 <code>false</code>。假设树已经通过了前几道练习的检查。</p>\n<p><strong>3.2.32</strong>　<strong>验证</strong>。编写一个方法 <code>isBST()</code>，接受一个结点 <code>Node</code> 为参数。若该结点是一个二叉查找树的根结点则返回 <code>true</code>，否则返回 <code>false</code>。<strong>提示</strong>：这个任务比看起来要困难，它和你调用前三题中各个方法的顺序有关。</p>\n<p>　<strong>解答</strong>：</p>\n<pre class=\"code-rows\"><code>private boolean isBST()\n{\n   if (!isBinaryTree(root)) return false;\n   if (!isOrdered(root, min(), max())) return false;\n   if (!hasNoDuplicates(root)) return false;\n   return true;\n}</code></pre>\n<p><strong>3.2.33</strong>　<strong>选择 / 排名检查</strong>。编写一个方法，对于 0 到 <code>size()-1</code> 之间的所有 <code>i</code>，检查 <code>i</code> 和 <code>rank(select(i))</code> 是否相等，并检查二叉查找树中的的任意键 <code>key</code> 和 <code>select(rank(key))</code> 是否相等。</p>\n<p><strong>3.2.34</strong>　<strong>线性符号表</strong>。你的目标是实现一个扩展的符号表 <code>ThreadedST</code>，支持以下两个运行时间为常数的操作：</p>\n<pre class=\"code-rows\"><code>Key next(Key key)，key的下一个键（若key为最大键则返回空）\nKey prev(Key key)，key的上一个键（若key为最小键则返回空）</code></pre>\n<p>　要做到这一点需要在结点中增加 <code>pred</code> 和 <code>succ</code> 两个变量来保存结点的前趋和后继结点，并相应修改 <code>put()</code>、<code>deleteMin()</code>、<code>deleteMax()</code> 和 <code>delete()</code> 方法来维护这两个变量。</p>\n<p><strong>3.2.35</strong>　<strong>改进的分析</strong>。为了更好地解释正文表格中的试验结果请改进它的数学模型。证明随着 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的增大，在一棵随机构造的二叉查找树中，一次命中查找所需的平均比较次数会趋近于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01333.gif\" alt=\"2\\ln N+2\\gamma-3\\approx1.39\\lg N-1.85\" inline-img=\"true\" />，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01334.gif\" alt=\"\\gamma=0.57721\\cdots\" inline-img=\"true\" />，即<strong>欧拉常数</strong>。<strong>提示</strong>：参考 2.3 节中对快速排序的分析，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01335.gif\" alt=\"1/x\" inline-img=\"true\" /> 的积分趋近于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01336.gif\" alt=\"\\ln N+\\gamma\" inline-img=\"true\" />。</p>\n<p><strong>3.2.36</strong>　<strong>迭代器</strong>。能否实现一个非递归版本的 <code>keys()</code> 方法，其使用的额外空间和树的高度成正比（和查找范围内的键的多少无关）？</p>\n<p><strong>3.2.37</strong>　<strong>按层遍历</strong>。编写一个方法 <code>printLevel()</code>，接受一个结点 <code>Node</code> 作为参数，按照层级顺序打印以该结点为根的子树（即按每个结点到根结点的距离的顺序，同一层的结点应该按从左至右的顺序）。<strong>提示</strong>：使用队列 <code>Queue</code>。</p>\n<p><strong>3.2.38</strong>　<strong>绘图</strong>。为二叉查找树添加一个方法 <code>draw()</code>，按照正文中的样式将树绘制出来。<strong>提示</strong>：在结点中用变量保存坐标并用递归的方法设置这些变量。</p>\n<h3 id=\"nav_point_136\">实验题</h3>\n<p><strong>3.2.39</strong>　<strong>平均情况</strong>。用经验数据评估在一棵由 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个随机结点构造的二叉查找树中，一次命中的查找和未命中的查找平均所需的比较次数的平均差和标准差，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01337.gif\" alt=\"N=10^4\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00848.gif\" alt=\"10^5\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" />，重复实验 100 遍。将你的实验结果和练习 3.2.35 给出的计算平均比较次数的公式进行对比。</p>\n<p><strong>3.2.40</strong>　<strong>树的高度</strong>。用经验数据评估一棵由 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个随机结点构造的二叉查找树的平均高度，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01337.gif\" alt=\"N=10^4\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00848.gif\" alt=\"10^5\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" />，重复实验 100 遍。将你的试验结果和正文中给出的估计值 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01329.gif\" alt=\"2.99\\lg N\" inline-img=\"true\" /> 进行对比。</p>\n<p><strong>3.2.41</strong>　<strong>数组表示</strong>。开发一个二叉查找树的实现，用三个数组表示一棵树（预先分配为构造函数中所指定的最大长度）：一个数组用来保存键，一个数组用来保存左链接的索引，一个数组用来保存右链接的索引。比较你的程序和标准实现的性能。</p>\n<p><strong>3.2.42</strong>　<strong>Hibbard 删除方法的性能问题</strong>。编写一个程序，从命令行接受一个参数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 并构造一棵由 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个随机键生成的二叉查找树，然后进入一个循环。在循环中它先删除一个随机键（<code>delete(select(StdRandom.uniform(N)))</code>），然后再插入一个随机键，如此循环 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00912.gif\" alt=\"N^2\" inline-img=\"true\" /> 次。循环结束后，计算并打印树的内部平均路径长度（内部路径长度除以 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 再加 1）。对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01338.gif\" alt=\"N=10^2\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00979.gif\" alt=\"10^3\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00847.gif\" alt=\"10^4\" inline-img=\"true\" />，运行你的程序来验证一个有些违反直觉的假设：这个过程会增加树的平均路径长度，增加的长度和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的平方根成正比。使用能够随机选择前趋或后继结点的 <code>delete()</code> 方法重复这个实验。</p>\n<p><strong>3.2.43</strong>　<strong><code>put()</code>/<code>get()</code> 方法的比例</strong>。用经验数据评估当使用 <code>FrequencyCounter</code> 来统计 100 万个随机整数中每个数的出现频率时，二叉查找树中 <code>put()</code> 方法和 <code>get()</code> 方法所消耗的时间的比例。</p>\n<p><strong>3.2.44</strong>　<strong>绘制成本图</strong>。改造二叉查找树的实现来绘制本节所示的那种能够显示计算中每次 <code>put()</code> 操作成本的图。</p>\n<p><strong>3.2.45</strong>　<strong>实际耗时</strong>。改造 <code>FrequencyCounter</code>，使用 <code>Stopwatch</code> 和 <code>StdDraw</code> 绘图，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00818.gif\" alt=\"x\" inline-img=\"true\" /> 轴表示 <code>get()</code> 和 <code>put()</code> 调用的总数，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00820.gif\" alt=\"y\" inline-img=\"true\" /> 轴为总运行时间，每次调用之后即在当前运行时间处绘制一个点。使用 <code>SequentialSearchST</code> 和你的程序处理《双城记》，再用 <code>BinarySearchST</code> 处理一遍，最后用二叉查找树处理一遍，然后讨论运行的结果。<strong>注意</strong>：曲线中突然的跳跃可能是<strong>缓存</strong>导致的，这已经超出了这个问题的讨论范围（请见练习 3.1.39）。</p>\n<p><strong>3.2.46</strong>　<strong>二叉查找树的临界点</strong>。使用随机 <code>double</code> 值作为键，分别找出使得二叉查找树的符号表比二分查找要快 10、100 倍和 1000 倍的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 值。分析并预测 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的大小并通过实验验证它。</p>\n<p><strong>3.2.47</strong>　<strong>平均查找耗时</strong>。用实验研究和计算在一棵由 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个随机结点构造的二叉查找树中到达任意结点的平均路径长度（内部路径长度除以 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 再加 1）的平均差和标准差，对于 100 到 10 000 之间的每个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 重复实验 1000 遍。将结果绘制成和图 3.2.14 相似的一张 Tufte 图，并画上函数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01339.gif\" alt=\"1.39\\lg N-1.85\" inline-img=\"true\" /> 的曲线（请见练习 3.2.35 和练习 3.2.39）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01340.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.2.14　一棵随机构造的二叉查找树中由根到达任意结点的平均路径长度</strong></p>\n","neighbors":{"left":{"article_title":"3.1 符号表","id":740941},"right":{"article_title":"3.3 平衡查找树","id":740943}},"comments":[]}