{"id":635706,"title":"19｜其他重要标准库特性实战：利用日历应用熟悉新特性","content":"<p>你好，我是卢誉声。</p><p>我们想要提升C++的编程效率，就需要对重要标准库的变更保持关注。在第18讲已经涵盖了绝大多数C++20带来的重要库变更。不过，我当时有意忽略了其中一个，就是我们今天的主角——C++20 Calendar、Timzone。</p><p>它们是对现有chrono库的重要补充。Calendar提供了日历的表示与计算工具。而Timezone提供了标准的时区定义，可以构建包含时区信息的zoned_time。</p><p>今天，我会围绕C++20 Calendar、Timzone带你进行编程实战，并结合上一讲涵盖的特性：jthread、source location、sync stream和u8string，实现一个使用新标准实现的日历程序。</p><p>哦，对了，我们还会在这一讲中使用C++ 20 Formatting库，帮你进一步加深对这个特性的理解。好，话不多说，就让我们从模块设计开始今天的内容（课程配套代码可以从<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>获取）。</p><h2>模块设计</h2><p>我们准备构建的命令行日历应用，具备以下特性。</p><ul>\n<li>使用C++20 chrono：支持显示本月日历，显示日期和星期信息。</li>\n<li>使用u8string：支持导出本年的全年日历到文本文件，编码为UTF-8。</li>\n</ul><p>我们依然采用传统C++模块结构设计，整体模块设计如下图所示。<br>\n<img src=\"https://static001.geekbang.org/resource/image/78/25/78e7e0c75ed186253b7d5cbb3a60db25.jpg?wh=2900x1682\" alt=\"\"></p><!-- [[[read_end]]] --><p>该工程包含两个子项目，一个是可执行文件calendarpp，另一个是静态链接库logging。从图中可以看到，calendarpp的入口是main.cpp，其他实现都在calendarpp模块下，包括后面这几个模块。</p><ul>\n<li>menu：主菜单实现，包括菜单定义与菜单交互。</li>\n<li>actions：各个菜单项的具体实现，完成具体的功能。</li>\n<li>utils：具体的底层实现模块，包括日历计算模块calendar、文本渲染模块render和输入输出模块io。</li>\n</ul><p>我们沿用了<a href=\"https://time.geekbang.org/column/article/631248\">第15讲</a>中的实现，即日志框架来构建并包装成了logging库，并利用第18讲中讲过的部分特性进行了改造。沿着这条路线，我们先从改造日志框架开始看。</p><h2>改造日志框架</h2><p>日志框架的所有代码文件都在projects/logging下，你可以结合代码来理解如何集成日志框架，并用它来记录系统运行日志。我们来看看，使用C++20的特性，可以在原有的框架基础上做出哪些改造。</p><p>之前的Handler在多线程场景下使用时，因为没有采用线程同步方案，导致输出时可能会产生错乱的问题，因此我们改造了Handler。</p><p>比如DefaultHandler的实现改造是后面这样。</p><pre><code class=\"language-c++\">#pragma once\n&nbsp;\n#include \"logging/Handler.h\"\n#include &lt;syncstream&gt;\n&nbsp;\nnamespace logging::handlers {\n&nbsp;&nbsp;&nbsp; // 默认日志处理器\n&nbsp;&nbsp;&nbsp; template &lt;Level HandlerLevel = Level::Warning&gt;\n&nbsp;&nbsp;&nbsp; // 继承BaseHandler\n&nbsp;&nbsp;&nbsp; class DefaultHandler : public BaseHandler&lt;HandlerLevel&gt; {\n&nbsp;&nbsp;&nbsp; public:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 构造函数，需要指定格式化器，默认格式化器为defaultFormatter\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultHandler(Formatter formatter = defaultFormatter) : BaseHandler&lt;HandlerLevel&gt;(formatter) {}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 禁止拷贝构造函数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultHandler(const DefaultHandler&amp;) = delete;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 定义移动构造函数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultHandler(const DefaultHandler&amp;&amp; rhs) noexcept : BaseHandler&lt;HandlerLevel&gt;(rhs.getForamtter()) {}\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // emit用于提交日志记录\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // emitLevel &gt; HandlerLevel的日志会被丢弃\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;Level emitLevel&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (emitLevel &gt; HandlerLevel)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void emit(const Record&amp; record) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // emitLevel &lt;= HandlerLevel的日志会被输出到标准输出流中\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;Level emitLevel&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (emitLevel &lt;= HandlerLevel)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void emit(const Record&amp; record) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 调用format将日志记录对象格式化成文本字符串\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::osyncstream(std::cout) &lt;&lt; this-&gt;format(record) &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; };\n}\n</code></pre><p>代码中的改动在第31行，通过<strong> std::osyncstream</strong> 包装了std::cout，然后通过包装后的输出流进行输出，这样就能完成输出的线程同步控制（详细讲解，你可以回顾上一讲 “sync stream” 这部分）。</p><p>日志框架的第二个改动在于，它通过source location记录了输出日志的源代码位置信息。实现在Record.h下，后面展示的是重点代码。</p><pre><code class=\"language-c++\">class Record {\npublic:\n&nbsp;&nbsp;&nbsp; // Logger名称\n&nbsp;&nbsp;&nbsp; std::string name;\n&nbsp;&nbsp;&nbsp; // 日志等级\n&nbsp;&nbsp;&nbsp; Level level;\n&nbsp;&nbsp;&nbsp; // 日志时间\n&nbsp;&nbsp;&nbsp; TimePoint time;\n&nbsp;&nbsp;&nbsp; // 日志消息\n&nbsp;&nbsp;&nbsp; std::string message;\n&nbsp;&nbsp;&nbsp; std::source_location sourceLocation;\n\n&nbsp;&nbsp;&nbsp; // getLevelName：获取日志等级文本\n&nbsp;&nbsp;&nbsp; const std::string&amp; getLevelName() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 调用toLevelName获取日志等级文本\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return toLevelName(level);\n&nbsp;&nbsp;&nbsp; }\n};\n</code></pre><p>通过代码可以看到，Record定义增加了sourceLocation用于记录源代码位置。</p><p>接着，我们还要修改Logger定义，增加记录源代码位置信息的功能。具体实现在Logger.h下，我们将log的定义改为以下形式。</p><pre><code class=\"language-c++\">template &lt;Level level&gt;\n&nbsp;&nbsp;&nbsp; requires (level &gt; loggerLevel)\nLogger&amp; log(const std::string&amp; message, std::source_location sourceLocation = std::source_location::current()) {\n&nbsp;&nbsp;&nbsp; return *this;\n}\n\n// 通过requires约束提交等级为日志记录器设定等级及以上的日志\ntemplate &lt;Level level&gt;\n&nbsp;&nbsp;&nbsp; requires (level &lt;= loggerLevel)\nLogger &amp; log(const std::string&amp; message, std::source_location sourceLocation = std::source_location::current()) {\n&nbsp;&nbsp;&nbsp; // 构造Record对象\n&nbsp;&nbsp;&nbsp; Record record{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;.name = _name,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .level = level,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .time = std::chrono::system_clock::now(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .message = message,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 记录源代码位置\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .sourceLocation = sourceLocation\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; // 调用handleLog实际处理日志输出\n&nbsp;&nbsp;&nbsp; handleLog&lt;level, HandlerCount - 1&gt;(record);\n\n&nbsp;&nbsp;&nbsp; return *this;\n}\n</code></pre><p>可以看到，我增加了source_location定义，并通过默认参数自动记录调用者的所在位置，调用者也可以自己指定需要记录的source_location。</p><p>我们同时<strong>修改了几个级别的相关接口</strong>，比如debug成员函数改造。</p><pre><code class=\"language-c++\">// 提交调试信息（log的包装）\nLogger&amp; debug(const std::string&amp; message, std::source_location sourceLocation = std::source_location::current()) {\n&nbsp;&nbsp;&nbsp; return log&lt;Level::Debug&gt;(message, sourceLocation);\n}\n</code></pre><p>其他的几个成员函数都和debug一样，这里就不展示出来了。</p><p>最后，我还修改了format函数输出sourceLocation中的信息。具体实现，我们以ModernFormatter.cpp的修改为例来看看。</p><pre><code class=\"language-c++\">#include \"logging/formatters/ModernFormatter.h\"\n#include \"logging/Record.h\"\n&nbsp;\nnamespace logging::formatters::modern {\n&nbsp;&nbsp;&nbsp; // formatRecord：将Record对象格式化为字符串\n&nbsp;&nbsp;&nbsp; std::string formatRecord(const Record&amp; record) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; sourceLocation = record.sourceLocation;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::format(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"{0:&lt;16}| [{1}] {2:%Y-%m-%d}T{2:%H:%M:%OS}Z - &lt;{3}:{4} [{5}]&gt; - {6}\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record.name,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record.getLevelName(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record.time,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sourceLocation.file_name(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sourceLocation.line(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sourceLocation.function_name(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record.message\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (std::exception&amp; e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; \"Error in format: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return \"\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>代码中format的部分加入了sourceLocation信息，其他部分相较于之前则没有变化。</p><h2>主程序与菜单</h2><p>在了解了日志框架的改造后，我们继续看如何通过C++20 Formatting库实现主程序和菜单。</p><p>主程序定义非常简单，在main.cpp中，代码是后面这样。</p><pre><code class=\"language-c++\">#include \"menu/Menu.h\"\n#include &lt;iostream&gt;\n#include &lt;format&gt;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; while (true) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 展示菜单\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; calendarpp::menu::showMenu();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 读取并执行菜单项\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; calendarpp::menu::readAction();\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>代码整体是一个while循环，首先展示菜单，然后读取用户输入并执行菜单项。所以只有用户选择退出程序时，整个程序才会退出。</p><p>菜单实现在menu/Menu.cpp中，代码是后面这样。</p><pre><code class=\"language-c++\">#include \"menu/Menu.h\"\n#include \"actions/ShowAction.h\"\n#include \"actions/ExportAction.h\"\n#include \"actions/ExitAction.h\"\n#include \"utils/RenderUtils.h\"\n&nbsp;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;cstdint&gt;\n#include &lt;format&gt;\n#include &lt;algorithm&gt;\n&nbsp;\nnamespace calendarpp::menu {\n&nbsp;&nbsp;&nbsp; // 菜单项类型\n&nbsp;&nbsp;&nbsp; struct MenuItem {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string title;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Action action;\n&nbsp;&nbsp;&nbsp; };\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 所有菜单\n&nbsp;&nbsp;&nbsp; static const std::vector&lt;MenuItem&gt; MenuItems = {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;MenuItem&gt; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .title = \"展示本月日历\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .action = actions::showCurrentMonth\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .title = \"导出本年日历\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .action = actions::exportCurrentYear\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .title = \"退出程序\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .action = actions::exitApp\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; };\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 菜单选项范围\n&nbsp;&nbsp;&nbsp; static const int32_t MinActionNumber = 1;\n&nbsp;&nbsp;&nbsp; static const int32_t MaxActionNumber = MenuItems.size();\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 展示菜单\n&nbsp;&nbsp;&nbsp; void showMenu() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 输出系统标题\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::format(\"\\n{:=^80}\\n\", \" Calendar++ v1.0 \") &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 输出当前时间与本地时区信息\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; utils::renderNow() &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 输出所有菜单\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::format(\"{:*^80}\\n\", \" MENU \");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::format(\"*{: ^78}*\\n\", \"\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::int32_t menuIndex = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; menuItem : MenuItems) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; menuIndex += 1;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 输出菜单序号与菜单名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string menuLine = std::format(\"({}) {}\", menuIndex, menuItem.title);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::format(\"* {: &lt;76} *\", menuLine) &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::format(\"*{: ^78}*\\n\", \"\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::format(\"{:*^80}\\n\", \"\");\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提示用户输入菜单编号\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::format(\"\\n请输入菜单编号({}-{}):\", 1, menuIndex);\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 读取用户输入并执行动作\n&nbsp;&nbsp;&nbsp; void readAction() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string actionNumberString;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 读取用户输入\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::getline(std::cin, actionNumberString);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 解析用户输入\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t actionNumber = std::stoi(actionNumberString);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (actionNumber &lt; MinActionNumber || actionNumber &gt; MaxActionNumber) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; std::format(\"菜单编号超出范围({}-{})\\n\", MinActionNumber, MaxActionNumber);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 执行相应菜单项的action\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t actionIndex = std::max(actionNumber - 1, 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; action = MenuItems[actionIndex].action;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; action();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (const std::exception&amp; e) {\n&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cerr &lt;&lt; \"无法识别用户输入\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>这段代码中值得注意的部分是 <strong>showMenu函数</strong>，它用于展示菜单。该函数输出标题后，会遍历所有的MenuItems并输出菜单内容。发现了么？这段代码通过format完成了大量的文本格式化工作。</p><p>最后我们还定义了readAction函数，用于读取用户输入的菜单编号并执行对应的菜单动作。这里使用了C++11引入的std::stoi函数将字符串转换成对应的整型数字。</p><p>菜单的展示效果是后面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/89/56/894d127e48f9d7566b4a7f742ea61b56.jpg?wh=1406x375\" alt=\"\"></p><p>需要注意的是，本项目代码采用了UTF-8编码，因此如果你在Windows下执行，需要在支持UTF-8编码输出的控制台下使用（比如MinGW的bash）。</p><h2>展示日历</h2><p>接下来，我们看一下该如何展示本月日历。在actions中定义了菜单项的函数实现，代码实现在src/actions/ShowAction.cpp中。</p><pre><code class=\"language-c++\">#include \"actions/ShowAction.h\"\n#include \"utils/RenderUtils.h\"\n&nbsp;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;format&gt;\n&nbsp;\nnamespace chrono = std::chrono;\n&nbsp;\nnamespace calendarpp::actions {\n&nbsp;&nbsp;&nbsp; void showCurrentMonth() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取当前时间\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chrono::time_point now{ chrono::system_clock::now() };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将时间转换为year_month_day\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chrono::year_month_day ymd{ chrono::floor&lt;chrono::days&gt;(now) };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取当前年月（类型为year_month）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chrono::year_month currentYearMonth = ymd.year() / ymd.month();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 调用渲染模块渲染当月日历\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; utils::renderMonth(currentYearMonth);\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>代码中定义了showCurrentMonth函数，该函数首先调用了chrono的Calendar获取当日所在的日期和月份。</p><p>Calendar是C++20引入到chrono中新的库特性，提供了标准的格里高利历（Gregorian calendar）实现。</p><p>这里简单介绍一下year_month_day，用于描述一个完整日期（年月日），该类型支持多种构造方法，这里使用chrono::system_clock::now()获取系统本地时间，然后采用chrono::floor&lt;chrono::days&gt;将时间转换为以日为单位的时间，最后调用year_month_day得到当日的日期。</p><p>year_month_day支持通过year和month成员函数获取当日的年份与月份，代码17行就调用了year / month这种形式构造了一个year_month对象，表示某年的某个月，这里最后得到的就是本日所在的当月。/是Calendar的一个操作符重载，是创建日期类型对象的一个语法糖。</p><p>代码最后调用renderMonth渲染了当月日历并将其输出到控制台，该函数定义在src/utils/RenderUtils.cpp中，属于渲染模块，我们分析一下相关代码。</p><p>首先定义了Weekdays常量，包含了周一到周日的所有星期几的定义。</p><pre><code class=\"language-c++\">// 定义一周七天的weekday常量\nstatic std::vector&lt;chrono::weekday&gt; Weekdays = {\n&nbsp;&nbsp;&nbsp; chrono::Monday,\n&nbsp;&nbsp;&nbsp; chrono::Tuesday,\n&nbsp;&nbsp;&nbsp; chrono::Wednesday,\n&nbsp;&nbsp;&nbsp; chrono::Thursday,\n&nbsp;&nbsp;&nbsp; chrono::Friday,\n&nbsp;&nbsp;&nbsp; chrono::Saturday,\n&nbsp;&nbsp;&nbsp; chrono::Sunday,\n};\n</code></pre><p>该数组的元素类型为chrono::weekday，这是chrono的标准类型，用来表示周几，其中Monday到Sunday都是chrono定义的常量，表示周一到周日。</p><pre><code class=\"language-c++\">// 渲染某个月份的日历，返回string\nstd::string renderMonth(chrono::year_month yearMonth) {\n&nbsp;&nbsp;&nbsp; std::ostringstream os;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 获取当月的所有周\n&nbsp;&nbsp;&nbsp; auto monthWeeks = utils::buildMonthWeeks(yearMonth);\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 获取当月第一天\n&nbsp;&nbsp;&nbsp; const auto firstDay = yearMonth / 1d;\n&nbsp;&nbsp;&nbsp; // 获取当月最后一天\n&nbsp;&nbsp;&nbsp; const auto lastDay = chrono::year_month_day(yearMonth / chrono::last);\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 输出格式化的标题（年份与月份）\n&nbsp;&nbsp;&nbsp; std::string titleLine = std::format(\"** {:%Y-%m} **\", yearMonth);\n&nbsp;&nbsp;&nbsp; os &lt;&lt; std::format(\"{:^35}\", titleLine) &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; os &lt;&lt; std::format(\"{:-&gt;35}\", \"\") &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 输出日历表头（从周一到周日）\n&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; headerLineParts;\n&nbsp;&nbsp;&nbsp; for (const auto&amp; weekday : Weekdays) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; headerLineParts.push_back(std::format(ZhCNLocale, \"{:L%a}\", weekday));\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; // 利用renderWeekLine生成格式化的表头（控制7个元素的位置与宽度）\n&nbsp;&nbsp;&nbsp; std::string headerLine = renderWeekLine(headerLineParts);\n&nbsp;&nbsp;&nbsp; os &lt;&lt; headerLine &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; os &lt;&lt; std::format(\"{:-&gt;35}\", \"\") &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 遍历monthWeeks，调用renderWeek生成日历中的每一行\n&nbsp;&nbsp;&nbsp; for (const auto&amp; currentWeek : monthWeeks) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string weekLine = renderWeek(currentWeek, yearMonth);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os &lt;&lt; weekLine &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 返回渲染的字符串\n&nbsp;&nbsp;&nbsp; return os.str();\n}\n&nbsp;\n// 渲染日历中的某一周\nstd::string renderWeek(const std::vector&lt;chrono::year_month_day&gt; week, chrono::year_month yearMonth) {\n&nbsp;&nbsp;&nbsp; // 获取当月第一天\n&nbsp;&nbsp;&nbsp; const auto firstDay = yearMonth / 1d;\n&nbsp;&nbsp;&nbsp; // 获取当月最后一天\n&nbsp;&nbsp;&nbsp; const auto lastDay = chrono::year_month_day(yearMonth / chrono::last);\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 生成本周的所有日期\n&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; weekLine;\n&nbsp;&nbsp;&nbsp; for (const auto&amp; currentDay : week) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string inCurrentMonthFlag = currentDay &gt;= firstDay &amp;&amp; currentDay &lt;= lastDay ? \"*\" : \"\";\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekLine.push_back(std::format(\"{}{:&gt;2}\", inCurrentMonthFlag, currentDay.day()));\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 利用renderWeekLine生成格式化的本周日期\n&nbsp;&nbsp;&nbsp; return renderWeekLine(weekLine);\n}\n&nbsp;\n// 生成某一周的格式化输出\nstd::string renderWeekLine(const std::vector&lt;std::string&gt;&amp; weekLine) {\n&nbsp;&nbsp;&nbsp; std::string renderResult;\n&nbsp;&nbsp;&nbsp; for (const auto&amp; weekLineItem : weekLine) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 所有内容按照宽度为4右对齐\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; renderResult.append(std::format(\"{:&gt;4} \", weekLineItem));\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; return renderResult;\n}\n</code></pre><p>代码中的注释已经比较详细了，所以后面我们只讨论一些重点实现。</p><p>代码第5行，作用是获取当月的所有周的数组，utils::buildMonthWeeks属于日历计算模块，我们后面详细解释其实现。</p><p>在代码第8行，用yearMonth / 1d生成当月的第一天，返回的类型就是year_month_day。其中1d是一个自定义文字量，定义在名称空间std::literals::chrono_literals中，相当于chrono::days(1)的语法糖，表示某个月1号。yearMonth / 1d中的/是yearMonth的操作符重载，表示当月第一天。</p><p>在代码第10行，用yearMonth / chrono::last表示当月最后一天。其中，chrono::last是C++20中引入的，用来表示一个时间序列末尾的标记。最后，我们调用chrono::year_month_day转换成year_month_day。</p><p>代码第18到25行，调用了renderWeekLine帮助我们生成格式化的标题，因为输出的日历需要将一周七天按照一定的布局输出到控制台上，该函数可以帮助我们完成渲染布局。代码第20行利用了locale输出中文，有兴趣可以自己看RenderUtils.cpp中的定义以及locale相关内容。</p><p>在代码第28到31行，生成日历的内容。由于日历里每周输出到一行中，因此这里遍历当月所有周，调用renderWeek完成一周的布局输出。</p><p>renderWeekLine函数实现也会比较简单，输入参数是一个包含N个字符串的数组，数组元素就是在日历中的每一个格子中需要输出的内容（比如表头的周几或者日期），这里主要通过format将每一格内容的输出宽度限制在4，确保布局工整。</p><p>渲染出来的效果如下图所示。<br>\n<img src=\"https://static001.geekbang.org/resource/image/58/75/581e249fe9ff9eb69052ce33d496b275.jpg?wh=1990x1070\" alt=\"\"></p><p>最后，我们看一下utils::buildMonthWeeks的实现，代码实现在src/utils/CalendarUtils.cpp中。</p><pre><code class=\"language-c++\">#include \"utils/CalendarUtils.h\"\n#include &lt;format&gt;\n&nbsp;\nnamespace chrono = std::chrono;\nusing namespace std::literals::chrono_literals;\n&nbsp;\nstatic uint32_t MaxWeekdayIndex = 6;\n&nbsp;\nnamespace calendarpp::utils {\n&nbsp;&nbsp;&nbsp; std::vector&lt;std::vector&lt;std::chrono::year_month_day&gt;&gt; buildMonthWeeks(std::chrono::year_month yearMonth) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取当月第一天\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto firstDay = yearMonth / 1d;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取当月最后一天\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto lastDay = chrono::year_month_day(yearMonth / chrono::last);\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;std::vector&lt;chrono::year_month_day&gt;&gt; monthWeeks;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将当月第一天设定为当日\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentDay = firstDay;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 当每周当日超出当月最后一天时中止循环\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (currentDay &lt;= lastDay) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 每次循环都计算出当日所在周的7天（周一到周日）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;chrono::year_month_day&gt; currentMonthWeek;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 通过weekday获取某一天是周几\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentWeekday = chrono::weekday{ std::chrono::sys_days{ currentDay } };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 通过iso_encoding获取周几的编码（1-7）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentWeekdayIndex = currentWeekday.iso_encoding() - 1;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 计算本周第一天\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto firstDayOfWeek = chrono::year_month_day{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::chrono::sys_days{ currentDay } - chrono::days(currentWeekdayIndex)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentDay = firstDayOfWeek;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 计算出本周的所有日期并添加到currentMonthWeek中\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (uint32_t weekdayIndex = 0; weekdayIndex &lt;= MaxWeekdayIndex; ++weekdayIndex) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentMonthWeek.push_back(currentDay);\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentDay = chrono::year_month_day{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::chrono::sys_days{ currentDay } + chrono::days(1)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将计算好的当前周添加到monthWeeks中\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; monthWeeks.push_back(currentMonthWeek);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return monthWeeks;\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>在这段代码中，我们会生成当月的所有周，通过Calendar完成了大量的日期计算，相比自己实现格里高利历要方便不少。</p><h2>导出日历</h2><p>除了展示日历，我们继续讨论序列化日历的实现。在src/actions/ExportAction.cpp中定义了导出菜单项的代码实现。</p><pre><code class=\"language-c++\">#include \"actions/ExportAction.h\"\n#include \"utils/RenderUtils.h\"\n#include \"utils/IOUtils.h\"\n&nbsp;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n&nbsp;\nnamespace chrono = std::chrono;\n&nbsp;\nnamespace calendarpp::actions {\n&nbsp;&nbsp;&nbsp; void exportCurrentYear() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取当前时间\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chrono::time_point now{ chrono::system_clock::now() };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将时间转换为year_month_day\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chrono::year_month_day ymd{ chrono::floor&lt;chrono::days&gt;(now) };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取当前年份\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chrono::year currentYear = ymd.year();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提示并读取用户输入\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"请输入导出文件路径: \";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string filePath;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::getline(std::cin, filePath);\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 调用IO模块将renderYear的渲染结果输出到文件中\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utils::writeFile(filePath, utils::renderYear(currentYear));\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::format(\"已将日历导出到文件中: {}\", filePath) &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>这段代码非常简单，核心是通过renderYear渲染当年的日历，然后通过writeFile以UTF-8编码写入到文件中。</p><p>函数renderYear实现在src/utils/RenderUtils.cpp中，相关代码如下所示。</p><pre><code class=\"language-c++\">// 定义一年12个月的month常量\nstatic std::vector&lt;chrono::month&gt; Months = {\n&nbsp;&nbsp;&nbsp; chrono::January,\n&nbsp;&nbsp;&nbsp; chrono::February,\n&nbsp;&nbsp;&nbsp; chrono::March,\n&nbsp;&nbsp;&nbsp; chrono::April,\n&nbsp;&nbsp;&nbsp; chrono::May,\n&nbsp;&nbsp;&nbsp; chrono::June,\n&nbsp;&nbsp;&nbsp; chrono::July,\n&nbsp;&nbsp;&nbsp; chrono::August,\n&nbsp;&nbsp;&nbsp; chrono::September,\n&nbsp;&nbsp;&nbsp; chrono::October,\n&nbsp;&nbsp;&nbsp; chrono::November,\n&nbsp;&nbsp;&nbsp; chrono::December,\n};\n&nbsp;\nstd::string renderYear(std::chrono::year year) {\n&nbsp;&nbsp;&nbsp; std::ostringstream os;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 输出格式化的标题（年份）\n&nbsp;&nbsp;&nbsp; std::string titleLine = std::format(\"**** {:%Y}年 ****\", year);\n&nbsp;&nbsp;&nbsp; os &lt;&lt; std::format(\"{:^35}\", titleLine) &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; os &lt;&lt; std::format(\"{:=^35}\\n\", \"\") &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 调用renderYearMonths并行生成12个月的日历\n&nbsp;&nbsp;&nbsp; std::vector&lt;std::string&gt; renderedMonths(Months.size(), \"\");\n&nbsp;&nbsp;&nbsp; renderYearMonths(renderedMonths, year);\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 将12个月的日历输入到输出流中\n&nbsp;&nbsp;&nbsp; for (const std::string&amp; renderedMonth : renderedMonths) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os &lt;&lt; renderedMonth;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 返回渲染好的字符串\n&nbsp;&nbsp;&nbsp; return os.str();\n}\n&nbsp;\nstatic void renderYearMonths(std::vector&lt;std::string&gt;&amp; renderedMonths, chrono::year year) {\n&nbsp;&nbsp;&nbsp; std::vector&lt;std::jthread&gt; renderThreads;\n&nbsp;\n&nbsp;&nbsp;&nbsp; int32_t monthIndex = 0;\n&nbsp;&nbsp;&nbsp; for (const auto&amp; currentMonth : Months) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentYearMonth = year / currentMonth;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; renderedMonth = renderedMonths[monthIndex];\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 创建jthread对象，开启计算线程，每个线程负责生成一个月的日历\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; renderThreads.push_back(std::jthread([currentYearMonth, &amp;renderedMonth] {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; renderedMonth = renderMonth(currentYearMonth);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }));\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++monthIndex;\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 退出函数时，所有jthread对象会自动等待计算完成然后退出\n}\n</code></pre><p>我们重点看一下renderYearMonths函数的实现。</p><p>该函数定义了一个jthread数组，然后循环创建了12个线程，用于分别调用renderMonth渲染各自月份的日历。由于jthread会在析构时自动等待本线程完成。因此，我们并不需要去join这些线程，在退出renderYearMonths之前，所有的工作线程肯定能结束任务。</p><p>最后看一下writeFile的实现，代码在src/utils/IOUtils.cpp中。</p><pre><code class=\"language-c++\">#include \"utils/IOUtils.h\"\n#include \"Logger.h\"\n&nbsp;\n#include &lt;filesystem&gt;\n#include &lt;format&gt;\n#include &lt;iostream&gt;\n&nbsp;\nnamespace fs = std::filesystem;\n&nbsp;\nnamespace calendarpp::utils {\n&nbsp;&nbsp;&nbsp; void writeFile(const std::string&amp; filePath, const std::string&amp; fileContent) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; logger = getLogger();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 检测文件是否存在\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fs::exists(filePath)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.warning(std::format(\"Override existed file: {}\", filePath));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 由于源代码使用UTF-8，生成的字符串就是UTF-8，因此可以直接强制类型转换构建u8string\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::u8string utf8FileContent(reinterpret_cast&lt;const char8_t*&gt;(fileContent.c_str()), fileContent.size());\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将u8string以二进制形式写入到文件中\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::ofstream outputFile(filePath, std::ios::binary);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputFile.write(reinterpret_cast&lt;char*&gt;(utf8FileContent.data()), utf8FileContent.size());\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>在这段代码中，首先通过文件系统库中的std::filsystem::exists检测文件是否存在，如果存在则提示用户会覆盖原有文件。</p><p>接着，将字符串转换成u8string，由于源代码使用UTF-8，生成的字符串就是UTF-8。因此，我们可以直接强制类型转换构建u8string。</p><p>最后，将u8string的data强制类型转换为char*，并通过二进制形式写入到文件中。</p><h2>总结</h2><p>在这一讲中，我们通过一个工程，串讲了一系列C++20带来的重要库变更。我们在原有的日志框架基础上，追加了source_location，用于记录打印日志时代码的所在位置。除此之外，将传统的输出流替换成sync stream，就可以轻松实现输出的线程同步控制。</p><p>在实现的过程中，我们还使用了TimeZone获取带时区的本地时间，并通过使用Calendar完成日历计算。这些针对chrono的标准库补充，大大降低了时间处理的复杂度。</p><p>最后，我们利用u8string，轻松实现了UTF-8编码的文本导出。</p><p>通过这些案例，我们可以感受到，<strong>现代 C++的库变更建立在新的核心语言特性基础上，为我们日常编程工作提供了极大的便利。避免造轮子，提升编程效率</strong>——这些对于库的核心变更来说是核心议题，所以我们应该保持对标准库演进的持续关注。</p><h2>课后思考</h2><p>现在日历中显示的时间是包含时区信息的本地时间，如果我们希望日历中显示的当前时间是UTC时间（日历显示依然按照本地时间计算，不需要变化），我们要对代码做什么改动？</p><p>欢迎给出你的方案，与大家一起分享。我们一同交流。下一讲见！</p>","comments":[{"had_liked":false,"id":387093,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1706435884,"is_pvip":false,"replies":[{"id":141120,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1706699743,"ip_address":"上海","comment_id":387093,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"把本地时间的显示换成UTC时间，只需修改RenderUtils.cpp中的 renderNow() 函数：把chrono::system_clock::now() 替换为 auto utcNow = std::chrono::utc_clock::now(); 同时把时区信息去除。","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636675,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706699743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396201,"user_name":"三笑三引伏兵","can_delete":false,"product_type":"c1","uid":3784424,"ip_address":"中国台湾","ucode":"B96439B22B407E","user_header":"https://static001.geekbang.org/account/avatar/00/39/be/e8/878aa74f.jpg","comment_is_top":false,"comment_ctime":1733541721,"is_pvip":false,"replies":[{"id":143865,"content":"一般并不会导致缓冲区过长。因为正常到了缓冲区长度肯定就emit或者析构了。所以我们每次输出都会包装一个新的osyncstream对象，确保不会发生这个问题。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1733980234,"ip_address":"加拿大","comment_id":396201,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"osyncstream好像是在调用emit()和析构时才会将自身缓冲区的内容传输给被包装的缓冲  在日志模块中的话不会导致缓冲区一直增长吗\n一般怎么解决呢","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655007,"discussion_content":"一般并不会导致缓冲区过长。因为正常到了缓冲区长度肯定就emit或者析构了。所以我们每次输出都会包装一个新的osyncstream对象，确保不会发生这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733980234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3784424,"avatar":"https://static001.geekbang.org/account/avatar/00/39/be/e8/878aa74f.jpg","nickname":"三笑三引伏兵","note":"","ucode":"B96439B22B407E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655189,"discussion_content":"好的 了解 谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734353602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369941,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1678162180,"is_pvip":false,"replies":[{"id":134892,"content":"需要基于非常基础的C函数进行封装，没有标准化方案。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1678249670,"ip_address":"上海","comment_id":369941,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"C++20之前没有Calendar吗？\n文中“Calendar 是 C++20 引入到 chrono 中新的库特性”，之前没有Calendar吗？有点小怀疑。如果没有，以前是怎么处理日历问题的？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608074,"discussion_content":"需要基于非常基础的C函数进行封装，没有标准化方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678249671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}