{"id":177442,"title":"18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？","content":"<p>上几节课中，我们学习了SOLID原则中的单一职责原则、开闭原则和里式替换原则，今天我们学习第四个原则，接口隔离原则。它对应SOLID中的英文字母“I”。对于这个原则，最关键就是理解其中“接口”的含义。那针对“接口”，不同的理解方式，对应在原则上也有不同的解读方式。除此之外，接口隔离原则跟我们之前讲到的单一职责原则还有点儿类似，所以今天我也会具体讲一下它们之间的区别和联系。</p><p>话不多说，现在就让我们正式开始今天的学习吧！</p><h2>如何理解“接口隔离原则”？</h2><p>接口隔离原则的英文翻译是“ Interface Segregation Principle”，缩写为ISP。Robert Martin在SOLID原则中是这样定义它的：“Clients should not be forced to depend upon interfaces that they do not use。”直译成中文的话就是：客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。</p><p>实际上，“接口”这个名词可以用在很多场合中。生活中我们可以用它来指插座接口等。在软件开发中，我们既可以把它看作一组抽象的约定，也可以具体指系统与系统之间的API接口，还可以特指面向对象编程语言中的接口等。</p><!-- [[[read_end]]] --><p>前面我提到，理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解为下面三种东西：</p><ul>\n<li>一组API接口集合</li>\n<li>单个API接口或函数</li>\n<li>OOP中的接口概念</li>\n</ul><p>接下来，我就按照这三种理解方式来详细讲一下，在不同的场景下，这条原则具体是如何解读和应用的。</p><h2>把“接口”理解为一组API接口集合</h2><p>我们还是结合一个例子来讲解。微服务用户系统提供了一组跟用户相关的API给其他系统使用，比如：注册、登录、获取用户信息等。具体代码如下所示：</p><pre><code>public interface UserService {\n  boolean register(String cellphone, String password);\n  boolean login(String cellphone, String password);\n  UserInfo getUserInfoById(long id);\n  UserInfo getUserInfoByCellphone(String cellphone);\n}\n\npublic class UserServiceImpl implements UserService {\n  //...\n}\n</code></pre><p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候我们该如何来做呢？你可能会说，这不是很简单吗，我只需要在UserService中新添加一个deleteUserByCellphone()或deleteUserById()接口就可以了。这个方法可以解决问题，但是也隐藏了一些安全隐患。</p><p>删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到UserService中，那所有使用到UserService的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户。</p><p>当然，最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的调用。不过，如果暂时没有鉴权框架来支持，我们还可以从代码设计的层面，尽量避免接口被误用。我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口RestrictedUserService中，然后将RestrictedUserService只打包提供给后台管理系统来使用。具体的代码实现如下所示：</p><pre><code>public interface UserService {\n  boolean register(String cellphone, String password);\n  boolean login(String cellphone, String password);\n  UserInfo getUserInfoById(long id);\n  UserInfo getUserInfoByCellphone(String cellphone);\n}\n\npublic interface RestrictedUserService {\n  boolean deleteUserByCellphone(String cellphone);\n  boolean deleteUserById(long id);\n}\n\npublic class UserServiceImpl implements UserService, RestrictedUserService {\n  // ...省略实现代码...\n}\n</code></pre><p>在刚刚的这个例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p><h2>把“接口”理解为单个API接口或函数</h2><p>现在我们再换一种理解方式，把接口理解为单个接口或函数（以下为了方便讲解，我都简称为“函数”）。那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。接下来，我们还是通过一个例子来解释一下。</p><pre><code>public class Statistics {\n  private Long max;\n  private Long min;\n  private Long average;\n  private Long sum;\n  private Long percentile99;\n  private Long percentile999;\n  //...省略constructor/getter/setter等方法...\n}\n\npublic Statistics count(Collection&lt;Long&gt; dataSet) {\n  Statistics statistics = new Statistics();\n  //...省略计算逻辑...\n  return statistics;\n}\n</code></pre><p>在上面的代码中，count()函数的功能不够单一，包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。按照接口隔离原则，我们应该把count()函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。拆分之后的代码如下所示：</p><pre><code>public Long max(Collection&lt;Long&gt; dataSet) { //... }\npublic Long min(Collection&lt;Long&gt; dataSet) { //... } \npublic Long average(Colletion&lt;Long&gt; dataSet) { //... }\n// ...省略其他统计函数...\n</code></pre><p>不过，你可能会说，在某种意义上讲，count()函数也不能算是职责不够单一，毕竟它做的事情只跟统计相关。我们在讲单一职责原则的时候，也提到过类似的问题。实际上，判定功能是否单一，除了很强的主观性，还需要结合具体的场景。</p><p>如果在项目中，对每个统计需求，Statistics定义的那几个统计信息都有涉及，那count()函数的设计就是合理的。相反，如果每个统计需求只涉及Statistics罗列的统计信息中一部分，比如，有的只需要用到max、min、average这三类统计信息，有的只需要用到average、sum。而count()函数每次都会把所有的统计信息计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。所以，在这个应用场景下，count()函数的设计就有点不合理了，我们应该按照第二种设计思路，将其拆分成粒度更细的多个统计函数。</p><p>不过，你应该已经发现，接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h2>把“接口”理解为OOP中的接口概念</h2><p>除了刚讲过的两种理解方式，我们还可以把“接口”理解为OOP中的接口概念，比如Java中的interface。我还是通过一个例子来给你解释。</p><p>假设我们的项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，我们分别设计实现了三个Configuration类：RedisConfig、MysqlConfig、KafkaConfig。具体的代码实现如下所示。注意，这里我只给出了RedisConfig的代码实现，另外两个都是类似的，我这里就不贴了。</p><pre><code>public class RedisConfig {\n    private ConfigSource configSource; //配置中心（比如zookeeper）\n    private String address;\n    private int timeout;\n    private int maxTotal;\n    //省略其他配置: maxWaitMillis,maxIdle,minIdle...\n\n    public RedisConfig(ConfigSource configSource) {\n        this.configSource = configSource;\n    }\n\n    public String getAddress() {\n        return this.address;\n    }\n    //...省略其他get()、init()方法...\n\n    public void update() {\n      //从configSource加载配置到address/timeout/maxTotal...\n    }\n}\n\npublic class KafkaConfig { //...省略... }\npublic class MysqlConfig { //...省略... }\n</code></pre><p>现在，我们有一个新的功能需求，希望支持Redis和Kafka配置信息的热更新。所谓“热更新（hot update）”就是，如果在配置中心中更改了配置信息，我们希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是RedisConfig、KafkaConfig类中）。但是，因为某些原因，我们并不希望对MySQL的配置信息进行热更新。</p><p>为了实现这样一个功能需求，我们设计实现了一个ScheduledUpdater类，以固定时间频率（periodInSeconds）来调用RedisConfig、KafkaConfig的update()方法更新配置信息。具体的代码实现如下所示：</p><pre><code>public interface Updater {\n  void update();\n}\n\npublic class RedisConfig implemets Updater {\n  //...省略其他属性和方法...\n  @Override\n  public void update() { //... }\n}\n\npublic class KafkaConfig implements Updater {\n  //...省略其他属性和方法...\n  @Override\n  public void update() { //... }\n}\n\npublic class MysqlConfig { //...省略其他属性和方法... }\n\npublic class ScheduledUpdater {\n    private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();;\n    private long initialDelayInSeconds;\n    private long periodInSeconds;\n    private Updater updater;\n\n    public ScheduleUpdater(Updater updater, long initialDelayInSeconds, long periodInSeconds) {\n        this.updater = updater;\n        this.initialDelayInSeconds = initialDelayInSeconds;\n        this.periodInSeconds = periodInSeconds;\n    }\n\n    public void run() {\n        executor.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                updater.update();\n            }\n        }, this.initialDelayInSeconds, this.periodInSeconds, TimeUnit.SECONDS);\n    }\n}\n\npublic class Application {\n  ConfigSource configSource = new ZookeeperConfigSource(/*省略参数*/);\n  public static final RedisConfig redisConfig = new RedisConfig(configSource);\n  public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);\n  public static final MySqlConfig mysqlConfig = new MysqlConfig(configSource);\n\n  public static void main(String[] args) {\n    ScheduledUpdater redisConfigUpdater = new ScheduledUpdater(redisConfig, 300, 300);\n    redisConfigUpdater.run();\n    \n    ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60);\n    kafkaConfigUpdater.run();\n  }\n}\n</code></pre><p>刚刚的热更新的需求我们已经搞定了。现在，我们又有了一个新的监控功能需求。通过命令行来查看Zookeeper中的配置信息是比较麻烦的。所以，我们希望能有一种更加方便的配置信息查看方式。</p><p>我们可以在项目中开发一个内嵌的SimpleHttpServer，输出项目的配置信息到一个固定的HTTP地址，比如：<a href=\"http://127.0.0.1:2389/config\">http://127.0.0.1:2389/config</a> 。我们只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过，出于某些原因，我们只想暴露MySQL和Redis的配置信息，不想暴露Kafka的配置信息。</p><p>为了实现这样一个功能，我们还需要对上面的代码做进一步改造。改造之后的代码如下所示：</p><pre><code>public interface Updater {\n  void update();\n}\n\npublic interface Viewer {\n  String outputInPlainText();\n  Map&lt;String, String&gt; output();\n}\n\npublic class RedisConfig implemets Updater, Viewer {\n  //...省略其他属性和方法...\n  @Override\n  public void update() { //... }\n  @Override\n  public String outputInPlainText() { //... }\n  @Override\n  public Map&lt;String, String&gt; output() { //...}\n}\n\npublic class KafkaConfig implements Updater {\n  //...省略其他属性和方法...\n  @Override\n  public void update() { //... }\n}\n\npublic class MysqlConfig implements Viewer {\n  //...省略其他属性和方法...\n  @Override\n  public String outputInPlainText() { //... }\n  @Override\n  public Map&lt;String, String&gt; output() { //...}\n}\n\npublic class SimpleHttpServer {\n  private String host;\n  private int port;\n  private Map&lt;String, List&lt;Viewer&gt;&gt; viewers = new HashMap&lt;&gt;();\n  \n  public SimpleHttpServer(String host, int port) {//...}\n  \n  public void addViewers(String urlDirectory, Viewer viewer) {\n    if (!viewers.containsKey(urlDirectory)) {\n      viewers.put(urlDirectory, new ArrayList&lt;Viewer&gt;());\n    }\n    this.viewers.get(urlDirectory).add(viewer);\n  }\n  \n  public void run() { //... }\n}\n\npublic class Application {\n    ConfigSource configSource = new ZookeeperConfigSource();\n    public static final RedisConfig redisConfig = new RedisConfig(configSource);\n    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);\n    public static final MySqlConfig mysqlConfig = new MySqlConfig(configSource);\n    \n    public static void main(String[] args) {\n        ScheduledUpdater redisConfigUpdater =\n            new ScheduledUpdater(redisConfig, 300, 300);\n        redisConfigUpdater.run();\n        \n        ScheduledUpdater kafkaConfigUpdater =\n            new ScheduledUpdater(kafkaConfig, 60, 60);\n        redisConfigUpdater.run();\n        \n        SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);\n        simpleHttpServer.addViewer(&quot;/config&quot;, redisConfig);\n        simpleHttpServer.addViewer(&quot;/config&quot;, mysqlConfig);\n        simpleHttpServer.run();\n    }\n}\n</code></pre><p>至此，热更新和监控的需求我们就都实现了。我们来回顾一下这个例子的设计思想。</p><p>我们设计了两个功能非常单一的接口：Updater和Viewer。ScheduledUpdater只依赖Updater这个跟热更新相关的接口，不需要被强迫去依赖不需要的Viewer接口，满足接口隔离原则。同理，SimpleHttpServer只依赖跟查看信息相关的Viewer接口，不依赖不需要的Updater接口，也满足接口隔离原则。</p><p>你可能会说，如果我们不遵守接口隔离原则，不设计Updater和Viewer两个小接口，而是设计一个大而全的Config接口，让RedisConfig、KafkaConfig、MysqlConfig都实现这个Config接口，并且将原来传递给ScheduledUpdater的Updater和传递给SimpleHttpServer的Viewer，都替换为Config，那会有什么问题呢？我们先来看一下，按照这个思路来实现的代码是什么样的。</p><pre><code>public interface Config {\n  void update();\n  String outputInPlainText();\n  Map&lt;String, String&gt; output();\n}\n\npublic class RedisConfig implements Config {\n  //...需要实现Config的三个接口update/outputIn.../output\n}\n\npublic class KafkaConfig implements Config {\n  //...需要实现Config的三个接口update/outputIn.../output\n}\n\npublic class MysqlConfig implements Config {\n  //...需要实现Config的三个接口update/outputIn.../output\n}\n\npublic class ScheduledUpdater {\n  //...省略其他属性和方法..\n  private Config config;\n\n  public ScheduleUpdater(Config config, long initialDelayInSeconds, long periodInSeconds) {\n      this.config = config;\n      //...\n  }\n  //...\n}\n\npublic class SimpleHttpServer {\n  private String host;\n  private int port;\n  private Map&lt;String, List&lt;Config&gt;&gt; viewers = new HashMap&lt;&gt;();\n \n  public SimpleHttpServer(String host, int port) {//...}\n  \n  public void addViewer(String urlDirectory, Config config) {\n    if (!viewers.containsKey(urlDirectory)) {\n      viewers.put(urlDirectory, new ArrayList&lt;Config&gt;());\n    }\n    viewers.get(urlDirectory).add(config);\n  }\n  \n  public void run() { //... }\n}\n</code></pre><p>这样的设计思路也是能工作的，但是对比前后两个设计思路，在同样的代码量、实现复杂度、同等可读性的情况下，第一种设计思路显然要比第二种好很多。为什么这么说呢？主要有两点原因。</p><p><strong>首先，第一种设计思路更加灵活、易扩展、易复用。</strong>因为Updater、Viewer职责更加单一，单一就意味了通用、复用性好。比如，我们现在又有一个新的需求，开发一个Metrics性能统计模块，并且希望将Metrics也通过SimpleHttpServer显示在网页上，以方便查看。这个时候，尽管Metrics跟RedisConfig等没有任何关系，但我们仍然可以让Metrics类实现非常通用的Viewer接口，复用SimpleHttpServer的代码实现。具体的代码如下所示：</p><pre><code>public class ApiMetrics implements Viewer {//...}\npublic class DbMetrics implements Viewer {//...}\n\npublic class Application {\n    ConfigSource configSource = new ZookeeperConfigSource();\n    public static final RedisConfig redisConfig = new RedisConfig(configSource);\n    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);\n    public static final MySqlConfig mySqlConfig = new MySqlConfig(configSource);\n    public static final ApiMetrics apiMetrics = new ApiMetrics();\n    public static final DbMetrics dbMetrics = new DbMetrics();\n    \n    public static void main(String[] args) {\n        SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);\n        simpleHttpServer.addViewer(&quot;/config&quot;, redisConfig);\n        simpleHttpServer.addViewer(&quot;/config&quot;, mySqlConfig);\n        simpleHttpServer.addViewer(&quot;/metrics&quot;, apiMetrics);\n        simpleHttpServer.addViewer(&quot;/metrics&quot;, dbMetrics);\n        simpleHttpServer.run();\n    }\n}\n</code></pre><p><strong>其次，第二种设计思路在代码实现上做了一些无用功。</strong>因为Config接口中包含两类不相关的接口，一类是update()，一类是output()和outputInPlainText()。理论上，KafkaConfig只需要实现update()接口，并不需要实现output()相关的接口。同理，MysqlConfig只需要实现output()相关接口，并需要实现update()接口。但第二种设计思路要求RedisConfig、KafkaConfig、MySqlConfig必须同时实现Config的所有接口函数（update、output、outputInPlainText）。除此之外，如果我们要往Config中继续添加一个新的接口，那所有的实现类都要改动。相反，如果我们的接口粒度比较小，那涉及改动的类就比较少。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.如何理解“接口隔离原则”？</strong></p><p>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个API接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为OOP中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><p><strong>2.接口隔离原则与单一职责原则的区别</strong></p><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h2>课堂讨论</h2><p>今天课堂讨论的话题是这样的：</p><p>java.util.concurrent并发包提供了AtomicInteger这样一个原子类，其中有一个函数getAndIncrement()是这样定义的：给整数增加一，并且返回未増之前的值。我的问题是，这个函数的设计是否符合单一职责原则和接口隔离原则？为什么？</p><pre><code>/**\n * Atomically increments by one the current value.\n * @return the previous value\n */\npublic final int getAndIncrement() {//...}\n</code></pre><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？","id":177110},"right":{"article_title":"19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？","id":177444}},"comments":[{"had_liked":false,"id":161360,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1576198128,"is_pvip":true,"discussion_count":13,"race_medal":0,"score":"624346456048","product_id":100039001,"comment_content":"Java.util.concurrent.atomic包下提供了机器底层级别实现的多线程环境下原子操作，相比自己实现类似的功能更加高效。<br>AtomicInteger提供了<br>intValue() 获取当前值<br>incrementAndGet() 相当于++i<br>getAndIncrement相当于i++<br>从getAndIncrement实现“原子”操作的角度上来说，原子级别的给整数加一，返回未加一之前的值。它的职责是明确的，是符合单一职责的。<br><br>从接口隔离原则上看，也是符合的，因为AtomicInteger封装了原子级别的整数操作。<br><br>补充：<br>多线程环境下如果需要计数的话不需旧的值时，推荐使用LongAdder或者LongAccumulator（CoreJava上说更加高效，但我对比了AtomicLong和LongAdder，没感觉效率上有提高，可能是例子写的不够准确。测试代码见 https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;tree&#47;master&#47;designpattern&#47;u18 希望和小伙伴们一起讨论）","like_count":146,"discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84039,"discussion_content":"LongAdder是用了更多的空间换取时间的,会将所有加的操作记入自己的内存空间,当获取到操作时一次性写入.这种在多个线程频繁竞争时性能就显现出来了.","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1576482639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84051,"discussion_content":"谢谢回复！涨姿势！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576483682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":84039,"ip_address":""},"score":84051,"extra":""}]},{"author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283250,"discussion_content":"我对LongAddr里面的设计思想是这么理解的：举个例子，假如有一个记录余额的数字，在并发高的情况下对这个余额进行更新操作，为了保证线程安全，对这个数字操作一定是在一个时刻里只能一个线程操作，那这种情况下就意味着对多线程的竞争是非常激励的，从第一个线程执行到最后一个线程执行完时间相对比较久，那我们换成LongAddr这种思路就是我把这个余额用多个数字进行记录，这多个数字的总和当然是正确的余额数，这个时候多并发更新操作的时候，就可以将多个线程分散到对这多个数字进行操作从而减少了并发竞争程度从而提升性能。当然这种设计思路是要求对数据不是强一致性的场景，在一些极端的情况去查数据会存在脏数据的情况。其实这设计思想可以应用在很多的场景当中","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1592222967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81059,"discussion_content":"每次都想看你的评论，哈哈","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576216751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":81130,"discussion_content":"谢谢你的关注，我好开心啊，居然有人喜欢看我的评论！我会继续加油哒！","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576225512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":81059,"ip_address":""},"score":81130,"extra":""},{"author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":300280,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598009822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":81130,"ip_address":""},"score":300280,"extra":""}]},{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96687,"discussion_content":"上面的解释是错的，LongAdder的思想是拆分锁的粒度，可以去看源码","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577086281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":97262,"discussion_content":"我看不懂源码呀🤣，给我们讲讲吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577109407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96687,"ip_address":""},"score":97262,"extra":""}]},{"author":{"id":1184185,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/b9/abb7bfe3.jpg","nickname":"小桶","note":"","ucode":"7967FF96CDE753","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302117,"discussion_content":"哥们，审题了吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598794089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004758,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/d6/124e2e93.jpg","nickname":"Calios","note":"","ucode":"B1AA60164DC42A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187206,"discussion_content":"名字太有个性，想不注意到都难～🤣","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582727779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2034632,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0b/c8/15f055d3.jpg","nickname":"图灵机","note":"","ucode":"EB02DB653AD591","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298778,"discussion_content":"多线程并发累加，累加次数大的时候差距还是比较明显的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597397277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","nickname":"注定非凡","note":"","ucode":"80673056E131B7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289029,"discussion_content":"佩服","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593958893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93200,"discussion_content":"我也关注到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576914020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161423,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1576203512,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"426777965816","product_id":100039001,"comment_content":"设计模式_18<br>纯理论分析，这么设计是不符合“接口隔离”原则的，毕竟，get是一个操作，increment是另一个操作。<br><br>结合具体场景，Atomic类的设计目的是保证操作的原子性，专门看了一下AtomicInteger的源码，发现没有单独的 increment 方法，然后思考了一下线程同步时的问题，场景需要保证 get 与 increment 中间不插入其他操作，否则函数的正确性无法保证，从场景的角度，它又是符合原则的。","like_count":99,"discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81830,"discussion_content":"就是这个理儿","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576286330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377672,"discussion_content":"cas操作大哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622770963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2062402,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOnpl8fRB9r2vED2s8j7Arwbn2K6M6HUBWNjgoqV4uqe94fTGK4WGpOJLeRxXcBXk3dp23eQR0AQ/132","nickname":"吴钩","note":"","ucode":"0EB50E8144BCDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350959,"discussion_content":"我觉得不完全准确。get和increment之间可以被打断的，只是increment是CAS实现的，若检测到并发冲突就重新执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614082460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302563,"discussion_content":"『场景需要保证 get 与 increment 中间不插入其他操作，否则函数的正确性无法保证』也说不通，单独的get操作是有的，要按这个说法，也不应该有单独的get操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598956746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1112747,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","nickname":"李小四","note":"","ucode":"2A766BE16B276B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":308639,"discussion_content":"不明白你认为错误的点在哪里，get是只读的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601016367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302563,"ip_address":""},"score":308639,"extra":""}]},{"author":{"id":1501505,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e9/41/7cb2cf64.jpg","nickname":"Poppy","note":"","ucode":"AF656A00521037","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222938,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586180996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81168,"discussion_content":"说的很有道理呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576228859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286350,"user_name":"星溯","can_delete":false,"product_type":"c1","uid":2528121,"ip_address":"","ucode":"A185ACCDE20723","user_header":"https://static001.geekbang.org/account/avatar/00/26/93/79/9efa9c11.jpg","comment_is_top":false,"comment_ctime":1617264910,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"147646152974","product_id":100039001,"comment_content":"老师此题大有深意，我们可以从此思考题中方法的设计来深化对单一职责和接口隔离的理解：<br>接口隔离，强调的是调用方，是否只使用了接口中的部分功能？若是，则违反接口隔离，应当细粒度拆分接口，从这个例子看，调用方诉求与方法名完全一致，通过方法内部封装两个操作，实现原子性，达成了调用方的最终目的，不多不少。<br>单一职责，不强调是否为调用方，只要能某一角度观察出，一个模块&#47;类&#47;方法，负责了多于一件事情，就可判定其破坏了单一职责，基于此经典理论，不假以深层次思考的角度出发，从方法本身的命名（做两件事）就可断定，它一定是破坏了单一职责的，应该拆分为两个操作。<br>但我们可以结合老师说的，判定职责是否单一，要懂得结合业务场景，业务需求，此方法，其实就是要通过JDK提供的CAS乐观自选锁（方法最终依赖硬件指令集原语，Compare And Swap）从“原语”这一词的含义看，其实也是同时、原子性地做了一件“完整”的事情，因此，考虑这一点，是可以判定它符合单一职责的。<br>而这其实正是单一职责判定结果，往往见仁见智的原因：基于不同的角度，不同的立场，不同的业务理解，往往可以得到不同的判定结果，但不必纠结，判定过程中用到的思想才是精髓。","like_count":35,"discussions":[{"author":{"id":2862349,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL7iccMa4yaKJyLyibysdJBiaodgMickvdCxc58knqcHibDBdBK3WDhPHOAXia7E1BZ7gba4bph6FwaN7sw/132","nickname":"之一","note":"","ucode":"F58398575F85F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553069,"discussion_content":"赞，豁然开朗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645705088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1630504,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e1/28/0a26566d.jpg","nickname":"奕涛_steve","note":"","ucode":"07B39F3C746C3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542449,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640752362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028956,"avatar":"","nickname":"勿更改任何信息","note":"","ucode":"575185C69C05A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408714,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635306340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245040,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/70/4a6f9065.jpg","nickname":"happyfucheng","note":"","ucode":"458E67028A5368","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396207,"discussion_content":"为你点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632403554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161562,"user_name":"Geek_e9b8c4","can_delete":false,"product_type":"c1","uid":1716601,"ip_address":"","ucode":"C29F7344A6EE6B","user_header":"","comment_is_top":false,"comment_ctime":1576233087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"147605121151","product_id":100039001,"comment_content":"总结成思维导图了，链接 https:&#47;&#47;blog.csdn.net&#47;dingshuo168&#47;article&#47;details&#47;103531805","like_count":34},{"had_liked":false,"id":161344,"user_name":"码到成功","can_delete":false,"product_type":"c1","uid":1251915,"ip_address":"","ucode":"E9CD9832CD14BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/1a/4b/98c5a1e8.jpg","comment_is_top":false,"comment_ctime":1576196240,"is_pvip":false,"replies":[{"id":"61487","content":"集中答疑一下吧 课都提前录好了","user_name":"作者回复","comment_id":161344,"uid":"1190123","ip_address":"","utype":1,"ctime":1576198161,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"130425215120","product_id":100039001,"comment_content":"老师可以每次课对上一次课的思考题做下解答吗","like_count":30,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477693,"discussion_content":"集中答疑一下吧 课都提前录好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576198161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162242,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bc/02/3f7a7197.jpg","nickname":"跨江大桥","note":"","ucode":"4629B23F1BB9F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415246,"discussion_content":"没有答疑，有加餐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637037547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2277251,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/83/c83be5a3.jpg","nickname":"eHackyd","note":"","ucode":"E6E7994FBDF0A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379088,"discussion_content":"所以他有没集中答疑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623677168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161373,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1576199116,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"74590643148","product_id":100039001,"comment_content":"思考题：<br>先看是否符合单一职责原则，这个函数的功能是加1然后返回之前的值，做了两件事，是不符合单一职责原则的！<br>但是却符合接口隔离原则，从调用者的角度来看的话，因为这个类是Atomic类，需要的所有操作都是原子的，所以为了满足调用者需要原子性的完成加一返回的操作，提供一个这样的接口是必要的，满足接口隔离原则。","like_count":17,"discussions":[{"author":{"id":2028956,"avatar":"","nickname":"勿更改任何信息","note":"","ucode":"575185C69C05A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408711,"discussion_content":"所见略同\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635305772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161351,"user_name":"方小白","can_delete":false,"product_type":"c1","uid":1441572,"ip_address":"","ucode":"425F5167C15407","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/24/d8f97f2c.jpg","comment_is_top":false,"comment_ctime":1576196948,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70295673684","product_id":100039001,"comment_content":"符合SRP 也符合ISP 。<br><br>理由是这个方法完成的逻辑就是一个功能：新增和返回旧值。只不过是两步操作罢了。如果你想获取，就用get方法，自增就用increment 方法。都有提供哇。<br><br>SRP：老师在文中说，实际上，要从中做出选择，我们不能脱离具体的应用场景。所以我认为是符合的。<br><br>ISP: 可以参考老师说的这句话：而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。<br>我们调用这个方法肯定是要用它的整个功能，而不是其中的一个新增或自增功能。","like_count":16,"discussions":[{"author":{"id":1590960,"avatar":"https://static001.geekbang.org/account/avatar/00/18/46/b0/4f45e06e.jpg","nickname":"天雨流芳","note":"","ucode":"81657BA9C900FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213463,"discussion_content":"“通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一‘’ 有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585096925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161327,"user_name":"NoAsk","can_delete":false,"product_type":"c1","uid":1122412,"ip_address":"","ucode":"71CA29776B4F68","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/6c/e4966364.jpg","comment_is_top":false,"comment_ctime":1576194289,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70295671025","product_id":100039001,"comment_content":"单一职责原则针对的是模块、类、接口的设计。getAnd<br>Increase()虽然集合了获取和增加两个功能，但是它作为对atomicInteger的值的常用方法，提供对其值的常规操作，是满足单一原则的。<br><br>从单一原则的下面这个解释考虑，是不满足接口隔离原则的。“如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。”，用户可能调用获取或增加的其中一个方法，再或者先调用增加再调用获取increaseAndGet()方法。<br><br>这是我个人理解，还望大家指正。","like_count":16,"discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81829,"discussion_content":"如果高并发的话，接口隔离的话，分别调用两个函数，是否会产生并发不同步的问题。有涉及到了加锁，加锁就会影响性能。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1576286209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161665,"user_name":"小海","can_delete":false,"product_type":"c1","uid":1183874,"ip_address":"","ucode":"E566E4B9E9852C","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/82/f5a3ecf5.jpg","comment_is_top":false,"comment_ctime":1576290295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"66000799735","product_id":100039001,"comment_content":"回答课后讨论题得结合具体的场景和运行环境。AtomicInteger的getAndIncrement()函数的职责很单一，就是&quot;获取当前值并递增&quot;这一步原子操作，有人说这是两步操作，这个函数是运行在多线程并发环境下，在这种环境下把获取当前值和递增拆分成两个函数会获得错误的结果，而该函数内部封装了两步操作使其成为一个原子操作，从这个角度任意一方都是另一方的附属品，两者必须同时完成而不能拆分，如果仅仅是为了获取当前值或者递增那完全可以使用该类的其它函数。从调用方的角度，必然是同时用到了获取当前值和递增两个功能，而不是部分功能，明白该函数设计的&quot;单一职责&quot;，就知道它符合SRP和ISP，不要试图去拆分一个原子操作。","like_count":15},{"had_liked":false,"id":176761,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1581157133,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"61710699277","product_id":100039001,"comment_content":"接口隔离原则：我只要我想要的，不想要的别给我<br>","like_count":14,"discussions":[{"author":{"id":1465328,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5b/f0/630735be.jpg","nickname":"枫","note":"","ucode":"79E8B292617168","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334106,"discussion_content":"应该是：我只给你想要的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607744042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377675,"discussion_content":"秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622771043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161350,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1576196850,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18756066034","product_id":100039001,"comment_content":"思考题:<br>个人感觉，不符合单一职责，也不符合接口隔离，因为函数做了两件事，不应该把获取当前值和值加1放在一起，因为<br>1.用户可能需要-1 *1等其他运算操作再返回原始值，这样就要n个方法每个方法中都有返回原始值的操作。<br>2.用户可能只想运算操作，不想运算后暴露原始结果<br>3.如果用户以后还想获取操作后的值，这个函数就不能同时返回两个值了<br>希望大家指正","like_count":4,"discussions":[{"author":{"id":1282715,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","nickname":"Wh1","note":"","ucode":"6D28506B99A285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201824,"discussion_content":"关于你的1和2，AtomicInteger其实也给出了相应的get() 和 set() 方法，但AtomicInteger的乘和除我倒是真没看见...\n关于你的3，AtomicInteger是为了保证 &#34;自增 + 返回结果&#34; 这个操作的原子性，AtomicInteger才设立了getAndIncrement()，如果是增加一些其他操作，就无法保证原子性了 。\n至于为什么这个操作是原子的，因为内部通过Unsafe提供的CAS自旋修改内存偏移地址实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583842464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282920,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1615465610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14500367498","product_id":100039001,"comment_content":"按语法定义貌似是违背了单一职责和接口隔离原则的。<br>但是我们要考虑的是单一职责和接口隔离的意义是什么？是为了隔离开单元模块，方便使用者随机组合、灵活运用。<br><br>但该方法的目的是为了正确获得更新与获得上一个值的准确定义。该方法通过cas无锁算法，实现了乐观锁，同时保证返回了准确值。<br><br>假如系统不提供此方法，而是业务自行调用get方法获取自增前的值，然后加上一再设置新值。那这里从获取到设置的整段代码，就不是线程安全的了。违背了这段代码的初衷。<br><br>反过来讲，调用方自己可以实现锁来保证线程安全。但是这个线程安全的职责就从 atomicInteger转移到了调用类，显然不是设计的初衷。<br><br>所以结合业务场景，两段操作，实际是要求原子话的。也就复合单一职责和借口隔离原则了。","like_count":3},{"had_liked":false,"id":202109,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1585903960,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14470805848","product_id":100039001,"comment_content":"文中第一种和第三种理解不是同一种吗？都是为了减少依赖不需要的接口函数。","like_count":3},{"had_liked":false,"id":163402,"user_name":"陈拾柒","can_delete":false,"product_type":"c1","uid":1473069,"ip_address":"","ucode":"22213E2FA5143A","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/2d/e3a5c52e.jpg","comment_is_top":false,"comment_ctime":1576717455,"is_pvip":false,"replies":[{"id":"62264","content":"不一样呢你再看看","user_name":"作者回复","comment_id":163402,"uid":"1190123","ip_address":"","utype":1,"ctime":1576796900,"user_name_real":"王争"}],"discussion_count":9,"race_medal":0,"score":"14461619343","product_id":100039001,"comment_content":"为什么觉得老师说的，对于接口的三种理解，第一种理解和第三种理解说的是同一件事情~","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478382,"discussion_content":"不一样呢你再看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576796900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1632462,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e8/ce/b5576a7f.jpg","nickname":"hotdog5225","note":"","ucode":"3FC53FEDBEE34A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215190,"discussion_content":"我觉得，作者的意思应该是：第一个理解是从实现类的角度来说的，要求实现类实现的接口中不应该有实现类不能实现/或者不需要实现的API。第三个理解是从接口的调用者来说的，调用者不应当依赖自己不需要的接口。（当然在作者的代码中，第三个理解中的代码，也包含了描述第一个理解的代码）。个人理解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585298451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2286788,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e4/c4/065f8c0c.jpg","nickname":"Tom-TTC","note":"","ucode":"36AB0797D6FD3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325957,"discussion_content":"感觉，第一个说的是api接口，第三个是java的interface类，分别对应文章中举的用户管理和redis等配置的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605489974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2071327,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9b/1f/9f3379d3.jpg","nickname":"Geek_7f21d2","note":"","ucode":"12204FDAD951BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302330,"discussion_content":"第一种， 你对外输出的一种能力，客户端可能只使用部分的能力 ，这样不符合接口隔离； 第三种， 你内部开发， 有多种的能力，不同的接口定义各自的能力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598879864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448126,"avatar":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","nickname":"慕高迪","note":"","ucode":"EB1CB5EA4E3A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290533,"discussion_content":"第一种微服务调用都是远程接口调用，如果接口中包含了不需要的内容，那就是违反了接口隔离原则。而第三种OOP中的接口，属于系统内的调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594526303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287896,"discussion_content":"我也有同样的感觉 哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593582828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053853,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/9d/19dcdd42.jpg","nickname":"瓜瓜","note":"","ucode":"2E98377E48399E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277666,"discussion_content":"我想，现在我们就应该这么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591089573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1817921,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erBJ1vppuwhTibCia7P24TQMz7TiaMId5QQjZuQJGicn4HynQEFGhC0x0wRUO2JlPzVPWK0sGtMwlvBLQ/132","nickname":"Onlyhalo","note":"","ucode":"ABDE0C48BCDD78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163811,"discussion_content":"我怎么感觉也差不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581098486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1328354,"avatar":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","nickname":"程晓擘","note":"","ucode":"96986D5AE2B96C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114821,"discussion_content":"我和你有一样的感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577977694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161361,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1576198137,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14461100025","product_id":100039001,"comment_content":"单一职责是针对于模块、类在具体的需求业务场景下是否符合只做一件事情的原则。<br>而接口隔离原则就细化到了接口方面，我是这样理解的，如果接口中的某些方法对于需要继承实现它的类来说是多余的，那么这个接口的设计就不符合接口隔离原则，可以考虑再拆分细化。<br>对于课后思考题，他只对该数做了相关操作符合单一职责原则。但从接口、函数来看它实现了两个功能，获取整数及给该整数加一，是不符合接口隔离原则的。<br>不知道我这样考虑是否正确，望指正","like_count":3,"discussions":[{"author":{"id":1385377,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","nickname":"何妨","note":"","ucode":"EC3983BFF7992A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80837,"discussion_content":"补充一下重点:对于api接口，调用者不应该强迫依赖它不需要的接口，可以考虑拆分出来，例如文中用户删除接口。对于函数来说应该只实现单一功能，例如文中 count 函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576199318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161723,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1576308471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166243063","product_id":100039001,"comment_content":"感觉是属于比较难判断是否单一职责的内容，顺便回头翻了一下单一职责的章节:在理解一下，单一职责主要还是要结合业务，getAndIncrement的方法实现了: 原子的获取并且新增的这一职责，如果拆开成get和Increment的话，就需要外层加锁处理原子的获取并新增操作，对于业务不太合适。<br>从接口隔离的原则看，调用这个方法的类，本身就是依赖这个接口，所以并没有违反。<br>想到一个问题： <br>如果一个类中，有n个查询的业务接口，根据姓名查，根据年纪查，根据地址查(假设不是参数控制，而是拆成3个接口)。那么不同调用方依赖这个类的时候，有可能是根据姓名查，有可能根据年纪查，如果都拆开了。那么接口是不是粒度太细了","like_count":2},{"had_liked":false,"id":161330,"user_name":"Chen","can_delete":false,"product_type":"c1","uid":1503113,"ip_address":"","ucode":"C1128558AB5BC4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/89/8c73a24d.jpg","comment_is_top":false,"comment_ctime":1576194799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166129391","product_id":100039001,"comment_content":"getAndIncrement()符合接口隔离原则，这是不是一个大而全的函数，而是一个细粒度的函数，跟count++的功能类似。","like_count":2},{"had_liked":false,"id":328698,"user_name":"邵亮","can_delete":false,"product_type":"c1","uid":1810890,"ip_address":"","ucode":"8407C3FDD11C0E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a1/ca/aae116f5.jpg","comment_is_top":false,"comment_ctime":1640846495,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5935813791","product_id":100039001,"comment_content":"从接口名称上来说不符合，但是因为是要实现原子操作，结合场景是符合的","like_count":1},{"had_liked":false,"id":271630,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1609743725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5904711021","product_id":100039001,"comment_content":"接口隔离原则中的”接口“在这里指的是函数，AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减，getAndIncrement()相当于线程安全的i++操作，调用者需要的是函数的需要加的同时，返回旧值，换句话说：用的是函数的全部功能，符合接口隔离原则。<br><br>getAndIncrement（）执行的是i++这个单一操作，因此也符合单一职责原则。","like_count":1},{"had_liked":false,"id":245407,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1598939021,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5893906317","product_id":100039001,"comment_content":"如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。<br>getAndIncrement通过调用CAS实现原子自增，保证线程安全。自增本身必须包含两个操作，取值和加一，我觉得这里的返回的取值，只是一个附产品。<br>在了解getAndIncrement方法的过程中，了解到CAS操作的乐观锁和自旋，还要CAS操作带来的ABA问题，堪比小说，很有意思！","like_count":1,"discussions":[{"author":{"id":1045577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","nickname":"北极的大企鹅","note":"","ucode":"8935346D08E109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375127,"discussion_content":"你的名字也很有意思!\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621491021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230434,"user_name":"skying","can_delete":false,"product_type":"c1","uid":1041865,"ip_address":"","ucode":"E7CFF50AB64BB1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","comment_is_top":false,"comment_ctime":1593391174,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5888358470","product_id":100039001,"comment_content":"我理解是符合接口隔离原则。<br>因为需要提供 原子性的服务能力，即 更新数据且返回更新后的数据，要保证原子性，必须在一个方法调用中返回。","like_count":1},{"had_liked":false,"id":229361,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592974994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887942290","product_id":100039001,"comment_content":"单一职责原则是从业务场景设计角度来看模块，类，方法的职责。而接口隔离则是避免将多余的数据暴露给调用方。想着想着感觉两个差不多啊","like_count":1},{"had_liked":false,"id":225920,"user_name":"N。","can_delete":false,"product_type":"c1","uid":1647830,"ip_address":"","ucode":"8EE55D4A24004A","user_header":"https://static001.geekbang.org/account/avatar/00/19/24/d6/c65a71b3.jpg","comment_is_top":false,"comment_ctime":1591889597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886856893","product_id":100039001,"comment_content":"根据具体的使用场景来做分析 这个是符合的，因为get和increment 他们在一起是必要的原子操作，分开后无法保证原子性","like_count":1},{"had_liked":false,"id":223597,"user_name":"扶摇九万里","can_delete":false,"product_type":"c1","uid":1240371,"ip_address":"","ucode":"58F30697C9D62B","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/33/070f7537.jpg","comment_is_top":false,"comment_ctime":1591142047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886109343","product_id":100039001,"comment_content":"按照我的理解，不同服务接口分离也是最小暴露加接口组合，oop接口是同一个服务的最小暴露加组合，主要还是组合给予的灵活扩展能力与功能管理能力吧","like_count":1},{"had_liked":false,"id":193872,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1584975819,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5879943115","product_id":100039001,"comment_content":"【设计模式笔记19】20200323<br>在之前的理解中接口隔离原则，只是单纯接口维度的隔离，比如两个不同的接口实现得功能不应该一样，另外目前犯了一个错误多个类似功能的会放在一个接口。今天学到了如果这些相似的接口都是给特定的接口调用方使用的话需要单独开一个接口，这样才符合接口隔离原则。从范围上看，一组接口、一组方法、一组函数都符合这个原则，使用方使用场景要分开。目前在实际开发中会使用重构为内部类的方式让代码更易读，实际上在开发工具中也是默认支持的，但是我们可以重构更彻底一些，哪个调用方使用，使用场景，多思考一下代码就能有提高。最后关于Atomic类的问题，我们从类名也可以看出，这是针对源自操作封装的方法，所以都是原子维度的操作，并不冲突，是符合接口隔离原则的","like_count":1},{"had_liked":false,"id":181717,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1582623746,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877591042","product_id":100039001,"comment_content":"感觉单一职责和接口隔离是总分的关系。单一职责大而全，接口隔离专门指接口的单一职责。似乎这两个不应该是并列关系，而是递进互相解释的关系","like_count":1},{"had_liked":false,"id":168777,"user_name":"LYy","can_delete":false,"product_type":"c1","uid":1102062,"ip_address":"","ucode":"8D5C39B9531E71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ee/f5c5e191.jpg","comment_is_top":false,"comment_ctime":1578156214,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5873123510","product_id":100039001,"comment_content":"SIP: 如果调用方不完全需要接口提供的全部功能，那么就需要审视接口是否可以进一步拆分。","like_count":1},{"had_liked":false,"id":161927,"user_name":"Varus","can_delete":false,"product_type":"c1","uid":1715988,"ip_address":"","ucode":"B9CB88C248BD93","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/14/840d0925.jpg","comment_is_top":false,"comment_ctime":1576406672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871373968","product_id":100039001,"comment_content":"这个主要是看是不是会有高并发的考虑，如果有的话，这种设计就非常有必要了，可以避免拿到错误的数据，没有的话，就可以继续细分一点","like_count":1},{"had_liked":false,"id":161477,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1576214004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871181300","product_id":100039001,"comment_content":"1.我主观认为都符合。<br><br>1.从名命来看，这个方法要做两件事，事实上它也只做了这两件事。所以这个方法的实现满足这个方法抽象的功能范围，耦合单一职责原则。<br><br>2.从使用方来看，返回数值并递增是这类原子类的常规使用场景（longaddr没这方法，蛋疼）。所以对于使用方而言，这个方法包含的两个功能都是其所需要的，所以它也满足接口隔离原则。","like_count":1},{"had_liked":false,"id":161393,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1576201124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871168420","product_id":100039001,"comment_content":"老师提到三种接口的情况可以这样理解:<br>1. 接口定义前设计原则(理解成OOP中语法接口或未定义的函数):尽量单一，细粒度！<br><br>2.接口定义后设计原则(理解成粗粒度的一组集合或函数):已有接口按需(调用者或者新功能)拆分或单独定义接口！","like_count":1},{"had_liked":false,"id":360631,"user_name":"Null","can_delete":false,"product_type":"c1","uid":1382587,"ip_address":"北京","ucode":"A7D4DF2A43C7D8","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/bb/9299fab1.jpg","comment_is_top":false,"comment_ctime":1666700104,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666700104","product_id":100039001,"comment_content":"接口隔离原则跟单一职责原则有点类似，这块的解释感觉有点牵强了。其实接口隔离隔离原则要不放弃对于单个接口的约束，因为单一职责管的挺好，没必要插一杠子。如果接口隔离非要管单一接口或者函数的事儿，那也就是接口的设计上希望是“职责单一”，之余其他的我觉得可以等同，没必要为了区分概念非要区分。","like_count":0},{"had_liked":false,"id":360630,"user_name":"Null","can_delete":false,"product_type":"c1","uid":1382587,"ip_address":"北京","ucode":"A7D4DF2A43C7D8","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/bb/9299fab1.jpg","comment_is_top":false,"comment_ctime":1666699820,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666699820","product_id":100039001,"comment_content":"为啥我觉得第一和第三种情况，没啥区别。","like_count":0},{"had_liked":false,"id":359718,"user_name":"MinsonLee","can_delete":false,"product_type":"c1","uid":1427500,"ip_address":"广东","ucode":"49D6D346AB3448","user_header":"","comment_is_top":false,"comment_ctime":1665801632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665801632","product_id":100039001,"comment_content":"是否可以理解为：符合接口隔离原则的类“接口”，其一定是符合“单一职责原则”的呢？","like_count":0},{"had_liked":false,"id":353844,"user_name":"陈志男","can_delete":false,"product_type":"c1","uid":2695483,"ip_address":"广东","ucode":"4831554F6AC2C7","user_header":"https://static001.geekbang.org/account/avatar/00/29/21/3b/7f01e158.jpg","comment_is_top":false,"comment_ctime":1659859473,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659859473","product_id":100039001,"comment_content":"场景为多线程，所以有些东西需要绑定在一起，分开操作返回的值就不是原子性了，而是被高并发改得面目全非","like_count":0},{"had_liked":false,"id":352574,"user_name":"Geek_1","can_delete":false,"product_type":"c1","uid":2704407,"ip_address":"","ucode":"59300A73996D20","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/17/e4fdcaad.jpg","comment_is_top":false,"comment_ctime":1658767432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658767432","product_id":100039001,"comment_content":"可以一个实现对应多个接口，这样可以实现接口隔离","like_count":0},{"had_liked":false,"id":351338,"user_name":"英雄","can_delete":false,"product_type":"c1","uid":1546612,"ip_address":"","ucode":"D1033C83C6CDE9","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/74/0203bf17.jpg","comment_is_top":false,"comment_ctime":1657708138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657708138","product_id":100039001,"comment_content":"看来花钱的东西是不一样，每一节课都能很好的理解，解开我多年的困惑“设计模式没鸟用”","like_count":0},{"had_liked":false,"id":349859,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1656387749,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656387749","product_id":100039001,"comment_content":"应该是符合的，它这个是原子新增，获取和新增是一个原子事务","like_count":0},{"had_liked":false,"id":343366,"user_name":"恬毅","can_delete":false,"product_type":"c1","uid":1015240,"ip_address":"","ucode":"914ED16F3BE714","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg","comment_is_top":false,"comment_ctime":1650800726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650800726","product_id":100039001,"comment_content":"如果抛开原子性的问题，是不符合单一职责和接口隔离原则的。因为有get和increment两个操作。<br>但是因为要实现原子性，所以就符合这个单一职责和接口隔离原则了","like_count":0},{"had_liked":false,"id":341273,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1649492815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649492815","product_id":100039001,"comment_content":"1.隔离，就是针对业务调用方来做的。<br>2.单一职责为了以后更容易重构，类、接口、模块的设计。<br>3.其实简单一句话，好用。","like_count":0},{"had_liked":false,"id":338603,"user_name":"意","can_delete":false,"product_type":"c1","uid":1129311,"ip_address":"","ucode":"A4B0C03248EA77","user_header":"https://static001.geekbang.org/account/avatar/00/11/3b/5f/a2c78423.jpg","comment_is_top":false,"comment_ctime":1647591885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647591885","product_id":100039001,"comment_content":"如果我们自己通过CAS（compareAndSet）编写incrementAndGet()，它大概长这样：<br><br>public int incrementAndGet(AtomicInteger var) {<br>    int prev, next;<br>    do {<br>        prev = var.get();<br>        next = prev + 1;<br>    } while ( ! var.compareAndSet(prev, next));<br>    return next;<br>}<br><br>CAS是底层保证原子性的。<br>一个CAS操作的过程可以用以下c代码表示: <br>int cas(long *addr, long old, long new)<br>{<br>    &#47;* Executes atomically. *&#47;<br>    if(*addr != old)<br>        return 0;<br>    *addr = new;<br>    return 1;<br>}<br><br>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。<br>1、循环时间长开销很大。<br>2、只能保证一个共享变量的原子操作。<br>3、ABA问题","like_count":0},{"had_liked":false,"id":330986,"user_name":"cheng_yc","can_delete":false,"product_type":"c1","uid":2856263,"ip_address":"","ucode":"6DE872A6AEC42E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqFjqX19XHS5npsnSrrxibLQU9b0zMb3AzmdribYdEOFrXCyh7dJRF8g8MUibWfbMM8K7fA46AZib75SQ/132","comment_is_top":false,"comment_ctime":1642340993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642340993","product_id":100039001,"comment_content":"其实这个看以怎样的维度去解释这个东西。<br>1.如果按照ISP定义来说，getAndIncrement是包含了两个操作，获取之前的值和对之前的值+1，不符合接口隔离原则，应该拆分为更细粒度的两个接口。<br>2.如果按照这个接口当时设计的实用意义来书，就是为了将两部操作使用cas保证了原子性。那就是合理的。跟上面讲的计算那个接口道理是一样的。<br>当然这个接口都是操作Integer类，满足单一职责原则","like_count":0},{"had_liked":false,"id":323688,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1638095582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638095582","product_id":100039001,"comment_content":"思考题：<br>getAndIncrement这是一个原子操作，也就是说它所包含的功能是不可分割的，或者全部执行，或者全部不做，从原子的不可分割性看，是符合单一职责原则的，但如果从其返回的结果看，会产生两种不同的结果，因此又是违返了接口隔离原则。","like_count":0},{"had_liked":false,"id":322678,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637548220,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637548220","product_id":100039001,"comment_content":"从名称上看是两个操作。操作上看，是原子加1，需要把获得加一捏在一起来看。","like_count":0},{"had_liked":false,"id":317518,"user_name":"Bacchus","can_delete":false,"product_type":"c1","uid":1830814,"ip_address":"","ucode":"A8AA7E4909B201","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ef/9e/fd29bdd8.jpg","comment_is_top":false,"comment_ctime":1634821842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634821842","product_id":100039001,"comment_content":"简单的来说<br>不满足单一职责原则，因为的确做了两件事<br>满足接口隔离原则，因为底层功能的确是一个，也没有依赖其他功能","like_count":0},{"had_liked":false,"id":315993,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1634096781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634096781","product_id":100039001,"comment_content":"单一职责是一个类或模块只完成一个职责or功能。getAndIncrement提供了或者oldValue和oldValue+1两个功能，不符合单一职责；但是职责理解比较模糊，如果理解它的职责就是+1并返回oldValue也是可以的。<br>接口隔离原则强调的是使用方不需要依赖冗余的功能，因此，从使用方的角度来看，应该是符合接口隔离职责的。","like_count":0},{"had_liked":false,"id":313331,"user_name":"我是曾经那个少年","can_delete":false,"product_type":"c1","uid":1015189,"ip_address":"","ucode":"9F02F7FF147D14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","comment_is_top":false,"comment_ctime":1632380588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632380588","product_id":100039001,"comment_content":"getAndIncrement 符合接口隔离原则，设计要看场景。获取增加后的值，在正式场景他的确是需要和存在的。<br><br>包括文中的例子统计功能，在报表查询真实业务情况下，他可能是正确的，原因很简单就是统计要查DB，有IO操作，可能在底层一次就查询出来了。","like_count":0},{"had_liked":false,"id":312822,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1632039745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632039745","product_id":100039001,"comment_content":"单一职责原则指的是模块，类，接口设计的功能单一，接口隔离原则主要针对的是对于客户端来说的，调用的这个接口功能粒度单一，方便扩展和维护","like_count":0},{"had_liked":false,"id":308939,"user_name":"征","can_delete":false,"product_type":"c1","uid":1592863,"ip_address":"","ucode":"A1B11446D28836","user_header":"https://static001.geekbang.org/account/avatar/00/18/4e/1f/c6fd287e.jpg","comment_is_top":false,"comment_ctime":1629866527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629866527","product_id":100039001,"comment_content":"根据模块应有的能力来提供接口，面对不同的调用者，由调用者在提供的能力列表中挑选或接口组合来满足其需要，实际项目中也没有太多的排期，给调用者定制化接口。所以提供者按照能力职责，适度的提供接口与函数。","like_count":0},{"had_liked":false,"id":303607,"user_name":"米豆丸","can_delete":false,"product_type":"c1","uid":2042568,"ip_address":"","ucode":"CE99FE3A1EBCAF","user_header":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","comment_is_top":false,"comment_ctime":1626872240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626872240","product_id":100039001,"comment_content":"接口隔离--&gt;供给平衡 多给不想要，按需提供","like_count":0},{"had_liked":false,"id":300954,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1625466365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625466365","product_id":100039001,"comment_content":"从定义来看的话，对于普通类Integer来说get和increment是两个操作，但对于AtomicInteger来说get和increment的组合是一个原子操作，也就是说getAndIncrement是从”指责“上来说是单一的，从”接口隔离“的方法功能来说也是满足隔离原则的。","like_count":0},{"had_liked":false,"id":299534,"user_name":"HSC胡舒程","can_delete":false,"product_type":"c1","uid":1941115,"ip_address":"","ucode":"77D81890F5E66B","user_header":"","comment_is_top":false,"comment_ctime":1624696915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624696915","product_id":100039001,"comment_content":"接口隔离原则就是要从用户使用的角度去考虑，尽量少的提供用户不需要的接口。对于不同用户的需要，提供相应的接口。","like_count":0},{"had_liked":false,"id":299090,"user_name":"Geek_e8b99d","can_delete":false,"product_type":"c1","uid":2391812,"ip_address":"","ucode":"DFD4F7916552E3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLReSm1spFQpHLU6Gw4LWpewDSPAk6FnR8Qw2mb1WE68KsPXCMsgGDrNwIicib30hjf6GV9hwjibQHOQ/132","comment_is_top":false,"comment_ctime":1624454416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624454416","product_id":100039001,"comment_content":"public static void main(String[] args) { ScheduledUpdater redisConfigUpdater = new ScheduledUpdater(redisConfig, 300, 300); redisConfigUpdater.run(); ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60); redisConfigUpdater.run(); SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389); simpleHttpServer.addViewer(&quot;&#47;config&quot;, redisConfig); simpleHttpServer.addViewer(&quot;&#47;config&quot;, mysqlConfig); simpleHttpServer.run(); } <br><br><br>kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60); redisConfigUpdater.run();  <br>这是不写错了？","like_count":0},{"had_liked":false,"id":296965,"user_name":"zart","can_delete":false,"product_type":"c1","uid":1148637,"ip_address":"","ucode":"E32677C0FD4421","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eomCrCRrLAWib0gMI2L2NbicMummlxOY6nVmphsDO0J3xx7OygNd8wJicc88RbNoHrcuXBsKLtCMvgFQ/132","comment_is_top":false,"comment_ctime":1623242566,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623242566","product_id":100039001,"comment_content":"接口隔离原则：通过将函数、接口设计为应用场景的最小粒度，实现灵活、复用、向下兼容的目的","like_count":0},{"had_liked":false,"id":295465,"user_name":"GaGi","can_delete":false,"product_type":"c1","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1622440875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622440875","product_id":100039001,"comment_content":"首先对于单一职责原则来理解，本身getAndIncrement是类中的一个方法，不能作为单一职责原则来进行判断。<br>而接口隔离原则可以用来判断该方法，作为调用者来看，这个方法的职责是够单一的","like_count":0},{"had_liked":false,"id":291726,"user_name":"lobby","can_delete":false,"product_type":"c1","uid":1181960,"ip_address":"","ucode":"8D81722BE36AD4","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/08/f3547e77.jpg","comment_is_top":false,"comment_ctime":1620451264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620451264","product_id":100039001,"comment_content":"感觉与职责定义有关系，方法申明上就是取值并加1，个人认为是满足的。但是对于方法做什么事情上，还是要尽量划分比较细","like_count":0},{"had_liked":false,"id":290035,"user_name":"学员203","can_delete":false,"product_type":"c1","uid":2559640,"ip_address":"","ucode":"63E4B7E3A7E140","user_header":"","comment_is_top":false,"comment_ctime":1619332852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619332852","product_id":100039001,"comment_content":"有疑惑，第一种理解说接口可以理解成一组API集合，但分析时都是针对interface来说，而第三种理解也是说的interface，感觉很相近，区别不大的？","like_count":0},{"had_liked":false,"id":288148,"user_name":"EQLT","can_delete":false,"product_type":"c1","uid":1122933,"ip_address":"","ucode":"609C93F0DEF0BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/75/79693c63.jpg","comment_is_top":false,"comment_ctime":1618322388,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618322388","product_id":100039001,"comment_content":"不符合单一职责，但符合接口隔离原则，我理解是<br>不符合单一职责是其做了两件事情，而符合接口隔离原则，是因为函数已经声明了当前会做两件事情返回数以及递增值。","like_count":0},{"had_liked":false,"id":287757,"user_name":"沐风","can_delete":false,"product_type":"c1","uid":1463926,"ip_address":"","ucode":"6675574198ABCE","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/76/e8200041.jpg","comment_is_top":false,"comment_ctime":1618134772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618134772","product_id":100039001,"comment_content":"借口隔离应该是更加注重设计上的细粒度划分，隔离不相关的业务或者方法。","like_count":0},{"had_liked":false,"id":287167,"user_name":"_(:з」∠)_","can_delete":false,"product_type":"c1","uid":2418852,"ip_address":"","ucode":"EFEBB3F72C2EA5","user_header":"https://static001.geekbang.org/account/avatar/00/24/e8/a4/18b34a6f.jpg","comment_is_top":false,"comment_ctime":1617800978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617800978","product_id":100039001,"comment_content":"应该从类的使用场景来看, 这个类下的函数都是原子操作, i i++ ++i其中的操作含义是不同的<br>职责不同 接口也没有实现无用的部分","like_count":0},{"had_liked":false,"id":285550,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1616893554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616893554","product_id":100039001,"comment_content":"我认为是符合的，因为它本身就是对i++这个功能的封装","like_count":0},{"had_liked":false,"id":284770,"user_name":"前路漫漫","can_delete":false,"product_type":"c1","uid":1792623,"ip_address":"","ucode":"3D39485D761444","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5a/6f/62c03303.jpg","comment_is_top":false,"comment_ctime":1616465303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616465303","product_id":100039001,"comment_content":"大部分场景应该也不会隔离的特别彻底，比如对于一组接口来说 里面有函数 A、B、C  ，业务方甲依赖 AB，业务方乙依赖 BC ，难道要写三个接口？","like_count":0},{"had_liked":false,"id":283758,"user_name":"Graham","can_delete":false,"product_type":"c1","uid":1994570,"ip_address":"","ucode":"C2545DE16EC3DD","user_header":"","comment_is_top":false,"comment_ctime":1615907254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615907254","product_id":100039001,"comment_content":"getAndIncrement方法名本身包括 get 和increment，get对应其返回previous value，increment表示自增，<br>做的事情也符合自己的定义，挺好的的，个人感觉没有毛病","like_count":0},{"had_liked":false,"id":282834,"user_name":"小熊","can_delete":false,"product_type":"c1","uid":2373458,"ip_address":"","ucode":"7DDDC76895C1D1","user_header":"https://static001.geekbang.org/account/avatar/00/24/37/52/fdfe66a1.jpg","comment_is_top":false,"comment_ctime":1615432390,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1615432390","product_id":100039001,"comment_content":"ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60); redisConfigUpdater.run();<br>这段代码写错了 ， 应该是：<br>ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60);<br>kafkaConfigUpdater.run();","like_count":0,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366007,"discussion_content":"是的是的，马上修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617939702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280915,"user_name":"张小张","can_delete":false,"product_type":"c1","uid":1517195,"ip_address":"","ucode":"0DBEF42144BDC8","user_header":"https://static001.geekbang.org/account/avatar/00/17/26/8b/d5e27bd0.jpg","comment_is_top":false,"comment_ctime":1614481030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614481030","product_id":100039001,"comment_content":"我有个疑问，怎么感觉接口理解1和接口理解3是一模一样的呢，都是interface协议职责划分","like_count":0},{"had_liked":false,"id":276139,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1611808383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611808383","product_id":100039001,"comment_content":"单从代码含义上面看，此函数做了两个操作，自增和获取自增后的值，看起来是做了两件事情，但是从场景来看，是没有问题得，因为多线程的问题，可能存在并发的问题，导致失去了原子性，所以需要把操作封装起来成一个函数","like_count":0},{"had_liked":false,"id":272456,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1610093635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610093635","product_id":100039001,"comment_content":"接口，是一定定义好方法。","like_count":0},{"had_liked":false,"id":269521,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1608691041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608691041","product_id":100039001,"comment_content":"也就是说 interface 必须站在 client &#47; 调用者的角度来设计，不要设计那种大而全的 interface，大而全会导致里面有些member是调用者用不到的。<br><br>答题： 符合。","like_count":0},{"had_liked":false,"id":265248,"user_name":"Kingram","can_delete":false,"product_type":"c1","uid":2247700,"ip_address":"","ucode":"212E403E81F2FC","user_header":"https://static001.geekbang.org/account/avatar/00/22/4c/14/8fa39544.jpg","comment_is_top":false,"comment_ctime":1606826188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606826188","product_id":100039001,"comment_content":"思考题：<br>这个类不熟，我主要搞go语言。<br>如果这个工具包还有获取旧值和自增的函数，那这个设计就是符合单一职责和接口隔离原则的。因为对调用者来说，这个函数需要实现的就是自增且返回旧值。","like_count":0},{"had_liked":false,"id":256193,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603549009,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1603549009","product_id":100039001,"comment_content":"如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。","like_count":0},{"had_liked":false,"id":250775,"user_name":"lengrongfu","can_delete":false,"product_type":"c1","uid":1494681,"ip_address":"","ucode":"FD6F35CA561E0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/99/447c33d4.jpg","comment_is_top":false,"comment_ctime":1601216258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601216258","product_id":100039001,"comment_content":"课后问题：我认为是满足单一职责原则的，我记得里面应该还有一个incr的方法，是提供只进行增加不返回结果的，问题中的方法是为了给使用方提供一个返回自增之后的当前值方法。这是满足另一种使用场景的。","like_count":0},{"had_liked":false,"id":248923,"user_name":"邵俊达","can_delete":false,"product_type":"c1","uid":1281460,"ip_address":"","ucode":"4B7DACE6DBCF95","user_header":"https://static001.geekbang.org/account/avatar/00/13/8d/b4/ff82483d.jpg","comment_is_top":false,"comment_ctime":1600358806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600358806","product_id":100039001,"comment_content":"ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60); redisConfigUpdater.run();<br><br>kafkaConfigUpdater 的调用都写成了 redisConfigUpdater.run()","like_count":0},{"had_liked":false,"id":248161,"user_name":"LeoBing","can_delete":false,"product_type":"c1","uid":1068193,"ip_address":"","ucode":"3964DA5DBFBE46","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/a1/40b75a55.jpg","comment_is_top":false,"comment_ctime":1600046715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600046715","product_id":100039001,"comment_content":"先对「接口」进行不同的范围定义。<br><br>然后再解释说明「隔离原则」代表的意义。<br><br>三个例子相当于从抽象层---&gt;实现层---&gt;使用层不同角度说明隔离的意义。因为需要讲清楚「隔离」，所以每个例子都以「职能单一原则」作为基础，对比解释更清晰。","like_count":0},{"had_liked":false,"id":247918,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1599917271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599917271","product_id":100039001,"comment_content":"单一职责原则关注的是模块、类、接口的设计，而不是函数层面的设计；当然我们也可以这样说，让某个函数从实现功能上尽量单一，也算是符合单一职责原则。具体来看，getAndIncrement() 这个函数虽然实现了 get 与 increment 两个操作，但从用户使用角度看，是会有可能让这两个操作合并来保持原子性的需求的，所以算符合单一职责。<br><br>接口隔离原则表明，如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来。我们来看看 AtomicInteger 中有没有专门用于 get 与 increment 的操作。答案是有的，前者是 AtomicInteger#get()；后者，可以用 AtomicInteger#incrementAndGet() 实现。所以说，getAndIncrement() 并没有阻碍用户单独调用其中的部分接口，该函数也是符合接口隔离原则的。","like_count":0},{"had_liked":false,"id":247594,"user_name":"Harlan","can_delete":false,"product_type":"c1","uid":2134882,"ip_address":"","ucode":"F43595A0A00B19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erpYZalYvFGcBs7zZvYwaQAZwTLiaw0mycJ4PdYpP3VxAYkAtyIRHhjSOrOK0yESaPpgEbVQUwf6LA/132","comment_is_top":false,"comment_ctime":1599750631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599750631","product_id":100039001,"comment_content":"全文核心： 接口隔离原则提供了一种判断接口的职责是否单一的标准<br><br>getAndIncrement()是一个原子操作，职责单一，实际上不可拆分","like_count":0},{"had_liked":false,"id":247018,"user_name":"蜡笔小旧","can_delete":false,"product_type":"c1","uid":1858515,"ip_address":"","ucode":"F648476E70DCCB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUjcPst52CBsh2ibdzaUymrXibKY6Tl1ccYzBOlCicu7ZyuqPC82L1uWiblyVLB3XibwlAHTPZc44rxdA/132","comment_is_top":false,"comment_ctime":1599558451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599558451","product_id":100039001,"comment_content":"看使用场景吧，如果使用场景既需要给整数加一，又需要获取未增之前的值，就符合接口隔离原则；如果使用场景仅需要给整数加一，则不符合接口隔离远征。","like_count":0},{"had_liked":false,"id":246380,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599302434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599302434","product_id":100039001,"comment_content":"我认为符合接口隔离原则， 因为他很好的 区分了 increamentAndget使用区别，  但是我觉得对于单一职责这个点存在疑问，  我只关心原子的 increament 为啥还要多做一个get， 是不是功能上不太单一呢？","like_count":0},{"had_liked":false,"id":246208,"user_name":"北斗星","can_delete":false,"product_type":"c1","uid":1321503,"ip_address":"","ucode":"BF5D43D664F254","user_header":"https://static001.geekbang.org/account/avatar/00/14/2a/1f/0bb0fefb.jpg","comment_is_top":false,"comment_ctime":1599208620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599208620","product_id":100039001,"comment_content":"在把“接口”理解为一组 API 接口集合中，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只打包提供给后台管理系统来使用。<br>这样写后台管理系统又需要把用户的登录注册等功能重新实现一遍，造成代码的重复。这又该如何解决呢？","like_count":0},{"had_liked":false,"id":246030,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1599138548,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599138548","product_id":100039001,"comment_content":"有一个疑问，如果我作为服务提供方，我提供了10个接口，可能A只用了5个，B也用到了5个，这种从调用方来看接口隔离，是不是有问题呢？","like_count":0,"discussions":[{"author":{"id":1596532,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5c/74/3f9e7c14.jpg","nickname":"foreveryi","note":"","ucode":"C322C02C8D1CEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303853,"discussion_content":"暂时只用到了5个，并不代表剩下的将来不会被调用方用到。而老师举的“删除用户”的接口，是完全不对外调用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599396177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245966,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599122464,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599122464","product_id":100039001,"comment_content":"符合，从使用场景角度来看","like_count":0},{"had_liked":false,"id":245836,"user_name":"火影.海诺","can_delete":false,"product_type":"c1","uid":2091565,"ip_address":"","ucode":"34729AFEE93B6D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ea/2d/34cb8e0a.jpg","comment_is_top":false,"comment_ctime":1599091164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599091164","product_id":100039001,"comment_content":"功能单一原则和接口隔离原则的关系就像功与法的关系，法是可以指导功的运行的。","like_count":0},{"had_liked":false,"id":245792,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1599054875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599054875","product_id":100039001,"comment_content":"从单一职责上来看，这个接口本身是不符合单一职责的。它一共做了两件事情，一件事情是对当前值增加，第二件事情是返回增加之前的值。<br>从接口隔离原则上，这个符不符合要从调用者的视角来看，调用者是否需要返回未增加之前的值，如果不需要那么就不符合接口隔离，如果需要那么就符合。","like_count":0},{"had_liked":false,"id":244287,"user_name":"郑自明","can_delete":false,"product_type":"c1","uid":1903493,"ip_address":"","ucode":"D0FBED818FCCC8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0b/85/ac258512.jpg","comment_is_top":false,"comment_ctime":1598451276,"is_pvip":false,"replies":[{"id":"90135","content":"语法归语法，看你怎么用了，这个跟原则不冲突的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1598833991,"ip_address":"","comment_id":244287,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598451276","product_id":100039001,"comment_content":"Java8 Interface有default method 这样新加的method不需要所有相关类再实现了。但对这些类而言 不就违背了接口隔离原则么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504541,"discussion_content":"语法归语法，看你怎么用了，这个跟原则不冲突的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598833991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243075,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1597940146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597940146","product_id":100039001,"comment_content":"从单一职责的角度来考虑则符合，目的是为了得到并加1操作的原子性。<br>从接口隔离的角度来考虑则不符合，get和increment操作耦合到一起了。","like_count":0},{"had_liked":false,"id":242832,"user_name":"超越自我","can_delete":false,"product_type":"c1","uid":2130462,"ip_address":"","ucode":"8A55D972EEFADA","user_header":"https://static001.geekbang.org/account/avatar/00/20/82/1e/f3cb3d57.jpg","comment_is_top":false,"comment_ctime":1597850218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597850218","product_id":100039001,"comment_content":"单一职责（类，模块，接口等对象）上的拆分，接口隔离（接口对象）上的拆分。接口隔离可以说是具体的单一职责拆的表现形式，接口隔离是将（调用者使用场景，权限等因素）作为拆分依据。它们最终拆成更小粒度的单一职责对象。","like_count":0},{"had_liked":false,"id":240630,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1597021891,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597021891","product_id":100039001,"comment_content":"接口隔离原则 不应该对调用者暴露多余接口","like_count":0},{"had_liked":false,"id":233353,"user_name":"Geek_71cea9","can_delete":false,"product_type":"c1","uid":2058308,"ip_address":"","ucode":"DE88271BA527DD","user_header":"","comment_is_top":false,"comment_ctime":1594296179,"is_pvip":false,"replies":[{"id":"86247","content":"是的，我觉得应该不过过于大而全，但拆的过细也不好，你可以结合着门面模式看下","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594386128,"ip_address":"","comment_id":233353,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594296179","product_id":100039001,"comment_content":"接口隔离原则，如果是从API接口角度，我觉得应该是从实现方来看，比如我实现某个接口，我只想实现这个接口的部分功能，其他功能用不上，那么就要考虑这个接口是否符合隔离原则，能否进行粒度拆分，这样也更灵活，针对函数来讲，应该就是从调用者的角度来看，比如我只想统计商品总量，而其他的统计结果，你不要给我，其实我们现在做的项目，都是前后端分离的，让前端调用，很多时候，我们项目中，会有一个很大的用户接口，包括一大堆信息，但是实际上前端只想获取用户的姓名或则手机号。但是你却给我了一大堆，后端也是为了图方便，只写一个接口，反正所有用户的信息全部塞到里面，那从这个角度，是不是也不符合接口隔离原则呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500991,"discussion_content":"是的，我觉得应该不过过于大而全，但拆的过细也不好，你可以结合着门面模式看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594386128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232903,"user_name":"Java垒墙工程师","can_delete":false,"product_type":"c1","uid":1937062,"ip_address":"","ucode":"E76AE44A9C76AE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","comment_is_top":false,"comment_ctime":1594166174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594166174","product_id":100039001,"comment_content":"接口隔离原则的标准是调用者需求，如果存在调用者同时需要函数全部功能，那么这样的方法存在就是满足接口隔离原则的，至于职责单一就不满足了，显然不单一","like_count":0},{"had_liked":false,"id":226043,"user_name":"pythonista","can_delete":false,"product_type":"c1","uid":1493954,"ip_address":"","ucode":"CE117439281B93","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/c2/abd584db.jpg","comment_is_top":false,"comment_ctime":1591934421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591934421","product_id":100039001,"comment_content":"符合单一职责  给使用者提供单一有用的原子操作 ","like_count":0},{"had_liked":false,"id":224188,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591315174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591315174","product_id":100039001,"comment_content":"IDE中查找变量(对象、接口)的”定义”(唯一)、查找变量的引用(多个)、查找接口的实现(多个)。怎么找到组装点呢？就是查找有抽象入参的引用，扩展点要引用这个函数注入实现！用的最多的是查找定义和查找函数的引用，找到谁依赖了自己，也就找到了功能的入口点!","like_count":0},{"had_liked":false,"id":224094,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591274173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591274173","product_id":100039001,"comment_content":"分层后的三层职责要分明，<br>controller：要处理鉴权、反序列化、数据校验：VO对象转为BO对象、数据序列化、错误信息。<br>service：业务逻辑加工组装、组合使用多个repo完成业务逻辑，不要把业务逻辑传递到repo层，保证repo只负责对象数据的持久化和数据的查询返回对象数据，所有业务逻辑都在service层完成。<br>repository：接收entity对象数据持久化到数据库，接受查询条件返回entity对象。repo层要屏蔽数据库设计的不合理干扰，在本层消化，比如冗余字段的补充、数据库字段名称、表字段划分不合理，做为数据的防腐层。<br>本层消化本层的难题，不要向外传递，保证层次之间掉调用关系优雅和易用。<br>“不变业务代码“依赖“可变的抽象“，抽象有多个实现，通过component层实例化对象组装依赖，“不变业务代码”不能直接实例化抽象的的实现，要通过函数形参传入。<br>","like_count":0},{"had_liked":false,"id":218303,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589774655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589774655","product_id":100039001,"comment_content":"我觉得还是符合的，单一原则 不是说步骤单一，而是操作是一个原子。","like_count":0},{"had_liked":false,"id":216988,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1589381458,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1589381458","product_id":100039001,"comment_content":"通过调用者如何使用接口来间接地判定，既符合单一职责原则、也接口隔离原则。很明显这个方法是对get方法的一个扩展，调用者有这个需求","like_count":0},{"had_liked":false,"id":215598,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589028565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589028565","product_id":100039001,"comment_content":"通过接口隔离类的功能：一个class实现多个interface，调用者依赖的是接口，看不到与自己无关的函数。可以根据功能规划类，不破坏类的功能完整性，用接口隔离复杂性，使用者只能看自己用到的功能，不用的功能看不到，这也是隔离的含义。，","like_count":0},{"had_liked":false,"id":203027,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1586103731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586103731","product_id":100039001,"comment_content":"我觉得是符合单一设计原则和接口隔离原则的。因为这个操作就相当于i++操作，是一个基本的操作，而且从接口隔离的角度上讲，功能也是隔离的，不会做无用功，所以说职责单一，接口隔离。","like_count":0},{"had_liked":false,"id":202706,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586055605,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586055605","product_id":100039001,"comment_content":"接口隔离原则提高了代码的可拓展性与可维护性。在平时的开发过程中，虽然偶尔会遵从某些原则，但是都是在无意识的情况下使用的。学习了这个章节，有了一个感叹：写好代码是一件事，写好一份高质量代码是另外一件事。以前，我一直觉得自己写的是代码，现在看来，不知道以前写的都是啥，哈哈哈哈😂。","like_count":0},{"had_liked":false,"id":202117,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1585904609,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585904609","product_id":100039001,"comment_content":"我认为这个需要分场景。<br>如果调用者清楚的知道需要获取并增加的操作，getAndIncrement() 作为一个原子动作来说是符合单一职责的，他只做一件事，就是函数名字的描述。<br>也是符合接口隔离原则的。调用者需要使用函数中的所有功能，而不是部分功能。<br>如果调用者只需要增加或是只需要获取，那么对于这个函数来说就都不符合了。就不应该调用这个函数","like_count":0},{"had_liked":false,"id":197949,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585404791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585404791","product_id":100039001,"comment_content":"这个原则确实挺抽象的。","like_count":0},{"had_liked":false,"id":196438,"user_name":"晓双","can_delete":false,"product_type":"c1","uid":1476696,"ip_address":"","ucode":"59CA9DB77697D5","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/58/3e19586a.jpg","comment_is_top":false,"comment_ctime":1585281133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585281133","product_id":100039001,"comment_content":"我认为是符合单一职责的，方法描述Atomically increments by one the current value.已经说得很清楚，这个方法就是原子增加一个值。","like_count":0},{"had_liked":false,"id":196100,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1585235571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585235571","product_id":100039001,"comment_content":"课后习题，符合单一职责和接口隔离原则。<br>单一职责：i++操作<br>接口隔离原则：只提供多线程下的整数原子操作。","like_count":0},{"had_liked":false,"id":195541,"user_name":"灯盖","can_delete":false,"product_type":"c1","uid":1482839,"ip_address":"","ucode":"0F8455A593D60C","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","comment_is_top":false,"comment_ctime":1585194939,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585194939","product_id":100039001,"comment_content":"接口隔离原则的第一种理解和迪米特法则是不是也有点想通之处呢？<br>一组API接口集合，根据接口隔离原则，会分为Interface1和Interface2。接口隔离原则强调，实现类可以实现其中一个接口或者实现所有接口。<br>不同的实现类就可以只实现自己需要的接口，做到接口隔离。<br><br>迪米特，结合基于接口而不是实现的规则，假设实现类C实现了Interface1和Interface2<br>那么C使用的时候可以<br>Interface1 * iter = new C();<br>这样就不会访问到Interface2接口中的内容<br>Interface2 * iter = new C();<br>这样就不会访问到Interface1接口中的内容<br><br>这样就实现了迪米特。<br><br>不知道这样理解对不对，请老师指正~","like_count":0},{"had_liked":false,"id":194137,"user_name":"黑客时间","can_delete":false,"product_type":"c1","uid":1831324,"ip_address":"","ucode":"7E22D76EECAC4D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f1/9c/cd12361d.jpg","comment_is_top":false,"comment_ctime":1585029605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585029605","product_id":100039001,"comment_content":"个人认为，符合单一职责<br>1.单一职责不意味着同时只能支持get或者increment，而是要完成一个功能。我在实际应用场景中就是要取值并且自增，那么这个方法刚好符合我的要求，它可以完成一个功能，那么认为就是符合单一职责<br>2.但我不确定是否符合隔离原则","like_count":0},{"had_liked":false,"id":193712,"user_name":"成活","can_delete":false,"product_type":"c1","uid":1734795,"ip_address":"","ucode":"F8840EE4DC3969","user_header":"https://static001.geekbang.org/account/avatar/00/1a/78/8b/421cb2c4.jpg","comment_is_top":false,"comment_ctime":1584952416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584952416","product_id":100039001,"comment_content":"个人认为原则的中文是不是应该翻译成“客户端不应该被强迫依赖”更好些","like_count":0},{"had_liked":false,"id":189757,"user_name":"Sun","can_delete":false,"product_type":"c1","uid":1196339,"ip_address":"","ucode":"1BC2741DC07FC5","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/33/d1064f9a.jpg","comment_is_top":false,"comment_ctime":1584546370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584546370","product_id":100039001,"comment_content":"实属牛逼，争哥的讲课思路太厉害了","like_count":0},{"had_liked":false,"id":188876,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1122284,"ip_address":"","ucode":"92BD46245FB5B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/ec/d611ce6c.jpg","comment_is_top":false,"comment_ctime":1584429442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584429442","product_id":100039001,"comment_content":"总结<br>1.什么是接口隔离原则<br>接口隔离原则是客户端不应该强迫它依赖不需要的接口内容<br>例如<br>如果是一组接口集合，那么就不应该依赖完全不需要的接口，<br>一个接口，但是其中的一些函数只在部分功能中使用，那么也是不符合的，应该把这个接口拆分成不同的接口<br>一函数中，有些功能是不需要的，那么也应该拆分成不同的函数<br>","like_count":0},{"had_liked":false,"id":188868,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1122284,"ip_address":"","ucode":"92BD46245FB5B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/ec/d611ce6c.jpg","comment_is_top":false,"comment_ctime":1584428416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584428416","product_id":100039001,"comment_content":"从场景来说，是符合接口隔离原则，接口隔离原则的意思是客户端不应该强迫依赖它不需要的接口，getAndIncrement()实现的增加，返回旧值，所以是符合的","like_count":0},{"had_liked":false,"id":188091,"user_name":"三年过后","can_delete":false,"product_type":"c1","uid":1283157,"ip_address":"","ucode":"5E9106C5F11BED","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/55/afc64956.jpg","comment_is_top":false,"comment_ctime":1584321026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584321026","product_id":100039001,"comment_content":"答疑：从功能上来说，getAndIncrement 好像干了两件事，调用C库将主内存值+1，并返回旧的值。仔细想，我主要就做+1操作，顺道返回主内存旧值。提高函数接口的灵活性。也是符合接口隔离原则的。个人拙见。","like_count":0},{"had_liked":false,"id":186166,"user_name":"路人甲","can_delete":false,"product_type":"c1","uid":1480119,"ip_address":"","ucode":"B720984454AFAF","user_header":"https://static001.geekbang.org/account/avatar/00/16/95/b7/15e157ec.jpg","comment_is_top":false,"comment_ctime":1583768484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583768484","product_id":100039001,"comment_content":"设计的非常灵活，赞","like_count":0},{"had_liked":false,"id":184762,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1583397199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583397199","product_id":100039001,"comment_content":"接口不要做无用功，比如1.A接口是先根据id查到用户，然后再查钱包有多少钱  有一个需求只是查用户，没必要查钱包，这样就多查浪费资源。<br>同理，2.如果你接口强制要求传个钱包id，我还要在调用A接口之前先弄到钱包id，耦合性一下子就高了<br>单一职责原则就是类似上面的1，做了无用功<br><br>接口隔离就是类似上面的2，依赖大<br><br>java.util.concurrent 并发包提供了 AtomicInteger 这样一个原子类，其中有一个函数 getAndIncrement() 是这样定义的：给整数增加一，并且返回未増之前的值。我的问题是，这个函数的设计是否符合单一职责原则和接口隔离原则？<br>答案是显而易见的，因为这是java自己设计的。。。<br>从单1上说：这个接口只是单纯的给这个值加1，所以符合<br>从接口隔离上来说：调用这个接口只要传一个相关的参数，所以符合。<br>当然incrementandget 和 getandincrement 区别。一个是先返回再加入参的值+1，另一个是先加1再返回入参。<br><br>看了下源码。。。其实他是通过unsafe.getAndAddInt(this, valueOffset, 1)通过反射根据字段偏移去修改对象。。。因为是原子操作，，，，没有return 参数的值。。。而是知道了结果，，，，incrementandget直接把参数的值+1.。。。","like_count":0},{"had_liked":false,"id":182388,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1582778089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582778089","product_id":100039001,"comment_content":"个人认为符合接口隔离原则。因为接口隔离和方法功能的复杂度其实没有必然的联系，没有规定说接口隔离就只能实现一个功能，getAndIncrement 这个方法的功能就是自增和返回旧值两个功能，方法的命名也非常清晰。再比如 BeanFactory#getBean 方法查找时其实会先从缓存中查找，如果查找不到会先实例化这个 Bean，而实例化 Bean 过程其实非常复杂，你能说 getBean 方法违反了接口隔离原则吗？","like_count":0},{"had_liked":false,"id":181675,"user_name":"junmawang","can_delete":false,"product_type":"c1","uid":1763466,"ip_address":"","ucode":"977E9E25CE6C94","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/8a/803a42e0.jpg","comment_is_top":false,"comment_ctime":1582613338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582613338","product_id":100039001,"comment_content":"1.接口隔离的定义<br>一组 API 接口集合。可以是某个微服务的接口，也可以是某个类库的接口，如果接口只被部分调用者使用，则这部分接口应该隔离出来。<br>自理解：如果A接口中的6个方法，有4个方法被A1用户，另外2个方法被B1用户调用，则该接口需要拆分成两个，也就是所谓的隔离。<br>单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数。<br>自理解：如果A函数中有1，2，3，4个逻辑，A1用户只需要1，2相关逻辑，B1用户只需要3，4相关逻辑，则需要将函数拆分。<br>OOP 中的接口概念，接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。<br><br>2.接口隔离原则与单一职责原则的区别<br>单一职责原则针对的是模块、类、接口的设计。<br>接口隔离原则更侧重于接口的设计，它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。<br><br>课堂讨论：<br>AtomicInteger为原子类，方法中的所有操作应该都是原子操作，AtomicInteger中的getAndIncrement()类似于i++，incrementAndGet()类似于++i，<br>如果做拆分两个操作需要用同步方式才能保证线程安全，所以该方法也符合单一职责原则和接口隔离原则。","like_count":0},{"had_liked":false,"id":181207,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582517622,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582517622","product_id":100039001,"comment_content":"针对这个问题,我的理解是,对于单一职责原则和接口隔离原则,是看一个方法的功能是否单一,能不能再继续拆分为粒度更小的接口,而这个方法,其粒度已经足够小了,而且其内部是使用CAS指令来进行替换的,对于CPU来说,是一个没法再拆分的原子操作,而且AtomicInteger内部也提供了get()和set()方法,也针对不同场景提供了incrementAndGet()等方法,方法多而不杂,都是对CAS指令的封装,足够应对多种场景下的使用,我认为是可以的","like_count":0},{"had_liked":false,"id":180888,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582435920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582435920","product_id":100039001,"comment_content":"这篇文章的分析，真是精彩。","like_count":0},{"had_liked":false,"id":180886,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582435879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582435879","product_id":100039001,"comment_content":"从单一职责的原则上看，get、increment 是两个不一样的操作，微观上看是不符合 单一职责 的设计原则的；<br>之所以这么设计，是因为这个类是一个线程安全地类，业务上就非常需要这个功能，所以它在宏观上分析是符合 单一职责 原则的。<br><br>从接口隔离上看，这个函数仍然符合原子类在业务上的设计，不存在&quot;依赖不必要接口&quot;的问题，所以也是符合接口隔离的。","like_count":0},{"had_liked":false,"id":178569,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1581747636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581747636","product_id":100039001,"comment_content":"老师，我觉得接口隔离原则重在隔离二字，单一只是辅助功能","like_count":0},{"had_liked":false,"id":177523,"user_name":"巨龙的力量啊","can_delete":false,"product_type":"c1","uid":1684858,"ip_address":"","ucode":"8FC6978929E48F","user_header":"https://static001.geekbang.org/account/avatar/00/19/b5/7a/a126c48f.jpg","comment_is_top":false,"comment_ctime":1581410240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581410240","product_id":100039001,"comment_content":"接口小粒度划分的同时，也要结合实际情况；接口功能是否隔离，可以看使用方的调用情况，是否都用到该接口的所有功能，如果只用到部分，就说明，接口在当前情况下设计是不合理的，不便于拓展。","like_count":0},{"had_liked":false,"id":177164,"user_name":"空空","can_delete":false,"product_type":"c1","uid":1444122,"ip_address":"","ucode":"8F6EFE5A6F6F64","user_header":"https://static001.geekbang.org/account/avatar/00/16/09/1a/e0f95684.jpg","comment_is_top":false,"comment_ctime":1581307520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581307520","product_id":100039001,"comment_content":"单一职责原则，侧重于针对某个特定接口，要满足功能的独立性和唯一性；<br>接口隔离原则，则强调接口与接口(方法与方法)之间的关系，要满足功能上的相互隔离，<br>","like_count":0},{"had_liked":false,"id":176815,"user_name":"谷雨","can_delete":false,"product_type":"c1","uid":1225827,"ip_address":"","ucode":"E8566AD0E2A521","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkkZBpiaOo4dGUuOXnRusBwcYCcwPTU8Pn41zbKh9py4Nwcf1rtc8A6yH5AtVVbkv8iaoS6hFgKevg/132","comment_is_top":false,"comment_ctime":1581173265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581173265","product_id":100039001,"comment_content":"单一职责和接口隔离的区别，我的理解：<br><br>单一职责，是划分域，这部分属于 A，另一部分属于 B。而接口隔离，更侧重不要“给调用者冗余的”，而冗余的本质，其实还是同一域。<br><br>所以，单一职责，是域与域，而接口隔离，是域内。","like_count":0},{"had_liked":false,"id":176595,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1581095105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581095105","product_id":100039001,"comment_content":"我反复思考了很久，觉得第一种接口的例子没有违背接口隔离原则。同样的api组，对delete鉴权了，就不违背，不鉴权就违背了？请老师打醒我。","like_count":0},{"had_liked":false,"id":174799,"user_name":"流星","can_delete":false,"product_type":"c1","uid":1114926,"ip_address":"","ucode":"94BACF37AD4953","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/2e/3a7b0eda.jpg","comment_is_top":false,"comment_ctime":1580391529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580391529","product_id":100039001,"comment_content":"是否单一原则得看划分的力度，如果力度更细，其实可以划分为两个方法，接口隔离是隔离的，只提供了一个单一的功能","like_count":0},{"had_liked":false,"id":171754,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1579007033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579007033","product_id":100039001,"comment_content":"老师, 我想起之前你讲DDD的时候, 在reposity前面有一个Bo, 按照这个原则, 我是不是每个根据不同的service写不同的bo, 但是如果这样, bo那些属性必定相同, 还是这里有区别","like_count":0},{"had_liked":false,"id":171181,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1578878188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578878188","product_id":100039001,"comment_content":"从并发的角度：原子性的完成递增并返回原来的结果，满足并发场景的需求，是符合单一原则的。<br>从纯理论分析角度：get 和 incr绑定 负责两个逻辑操作不符合单一原则要求。<br><br>从争哥上述的观点【单一原则】和【隔离原则】判断相对主观且受到使用场景影响，而getAndIncrement满足的特殊场景的要求，且AtomicInteger中有其他的方法满足要求，所以设计方面也是合理的。<br>","like_count":0},{"had_liked":false,"id":170504,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1578622588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578622588","product_id":100039001,"comment_content":"1. 是不是可以简单地理解为两者所关注的范范围不一样：单一职责原则的范围比较大包括模块、类和接口；而接口隔离原则只涉及接口（虽然这个接口的概念包括微服务意义上的接口、函数等）<br>2. 课后习题：如果从这个方法的职责上来说的话，应该符合接口隔离原则","like_count":0},{"had_liked":false,"id":169801,"user_name":"京京beaver","can_delete":false,"product_type":"c1","uid":1179056,"ip_address":"","ucode":"C21838D7CA7D6B","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/b0/e30fd916.jpg","comment_is_top":false,"comment_ctime":1578448120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578448120","product_id":100039001,"comment_content":"getAndIncrement符合单一职责原则和接口隔离原则,这个接口要解决的问题是，在并发情况下原子的获取最新值并加一。这个操作强调原子性，是不可分割的操作，所以符合SRP。这个操作除了获取，加锁，写入，解锁外没有其他额外的操作，没有引入不相关功能，所以符合ISP。","like_count":0},{"had_liked":false,"id":168763,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1578152177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578152177","product_id":100039001,"comment_content":"查看了AtomicInteger类，发现有get、set、getAndIncrement、getAndDecrement 、addAndGet 等等，我猜想可能++,--,以及加一个数这种情况用的比较多吧，所以写在了AtomicInteger类里面。<br><br>我认为符合单一职责和接口隔离原则的。<br>","like_count":0},{"had_liked":false,"id":167345,"user_name":"blackpiglet","can_delete":false,"product_type":"c1","uid":1032928,"ip_address":"","ucode":"58AA8329C91767","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c2/e0/7188aa0a.jpg","comment_is_top":false,"comment_ctime":1577772635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577772635","product_id":100039001,"comment_content":"这个问题的答案比较依赖主观的视角，比较难统一，个人看法是两个都符合：<br>单一职责原则：查值并自增是 atmoicInteger 的常见操作，虽然是两种更细粒度的操作的集合，放在一起作为一个功能也说得过去。<br>接口隔离原则：是否符合的唯一标准就是有没有人调用，只要有人觉得调这个调用比先调用查询再调用自增更方便，那就有必要。","like_count":0},{"had_liked":false,"id":166800,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1577600757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577600757","product_id":100039001,"comment_content":"接口的三个理解处理起来是一致的，就是不要依赖于用不着的功能，用不着的部分可能是整个接口，或者是接口的一个函数，或者是接口函数的部分功能。","like_count":0},{"had_liked":false,"id":165453,"user_name":"Arthur.Li","can_delete":false,"product_type":"c1","uid":1005824,"ip_address":"","ucode":"EC2436A5136C13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/00/6d14972a.jpg","comment_is_top":false,"comment_ctime":1577239577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577239577","product_id":100039001,"comment_content":"感觉单一职责原则是对模块、类、方法等功能的设计，强调模块、类、方法等的功能上单一，不要做过多的事。接口隔离更偏向“接口”，从调用者角度看事情，调用者要A，你不能也带有B<br><br>函数 getAndIncrement() 给整数增加一，并且返回未増之前的值是否符合单一和接口隔离原则？<br><br>我认为是都符合的。<br>1.单一职责原则： 因为函数功能即使从小颗粒度看也是职责单一的，只做了给数加一的功能，且返回值也是单一的。<br>2. 接口隔离原则：对于调用者来说，函数功能对整数加一并没有带来不想要的功能接口","like_count":0},{"had_liked":false,"id":164736,"user_name":"半截木头","can_delete":false,"product_type":"c1","uid":1296712,"ip_address":"","ucode":"72456E8E1BD6F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/c9/48/5a2879e3.jpg","comment_is_top":false,"comment_ctime":1577084396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577084396","product_id":100039001,"comment_content":"<br>&#47;**<br> * Atomically increments by one the current value.<br> * @return the previous value<br> *&#47;<br>public final int getAndIncrement() {&#47;&#47;...}<br>通常意思上来讲，get是一个操作，increment是另一个操作，所有一般来说是不满足ISP和SRP的。<br>但是具体到并发的应用场景上来，我们需要get和increment是原子操作的，所以在这个场景下，它是<br>满足ISP和SRP的。","like_count":0},{"had_liked":false,"id":164732,"user_name":"半截木头","can_delete":false,"product_type":"c1","uid":1296712,"ip_address":"","ucode":"72456E8E1BD6F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/c9/48/5a2879e3.jpg","comment_is_top":false,"comment_ctime":1577083456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577083456","product_id":100039001,"comment_content":"通过设计合理的接口，隔离掉对用户来说不必要的依赖。","like_count":0},{"had_liked":false,"id":164505,"user_name":"番茄炒西红柿","can_delete":false,"product_type":"c1","uid":1690242,"ip_address":"","ucode":"13F47BABAB2110","user_header":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","comment_is_top":false,"comment_ctime":1577013412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577013412","product_id":100039001,"comment_content":"后台问题我认为都符合，srp将的是一类对应一功能，atomicInteger对应是integer的原子类，自增是integer的原子操作所以符合一类对应一功能。<br>isp我认为也符合，从第二条函数的设计要单一来看，该方法就是自增返回原来值的方法，只实现了单一的功能故符合","like_count":0},{"had_liked":false,"id":164245,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1576915145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576915145","product_id":100039001,"comment_content":"关于第三个案例，不同功能用不同接口来支持，以实现更好的通用性和复用性。第二种实现方式我认为很常见，甚至更常见。老师说的是两个功能，倘若是5个功能，比如再增加上接口stop. Delete. Add. 那岂不是需要再增加3个接口，然后再修改已有代码，来支持这些特性？要是再增加其他功能又要全部修改。对此我并不是说老师的说法不好，我想说的是，根据实际场景，适当引入抽象类，来区分不同的组合有时候更适合一点。","like_count":0},{"had_liked":false,"id":164104,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1672483,"ip_address":"","ucode":"6BB1F4A5976158","user_header":"https://static001.geekbang.org/account/avatar/00/19/85/23/1c40a86e.jpg","comment_is_top":false,"comment_ctime":1576872895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576872895","product_id":100039001,"comment_content":"个人理解：getAndIncrement<br>从接口隔离原则看，包括 get 和 加1两个操作，不满足接口隔离原则。<br>从功能上看，它保证了加1并返回之前的值的原子操作，是满足接口隔离原则。","like_count":0},{"had_liked":false,"id":163896,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1576821287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576821287","product_id":100039001,"comment_content":"接口隔离原则：根据业务需求将大的接口划分为多个小的接口，怎么分，分多小，则看业务情况，最好满足你心中的接口单一职责原则。","like_count":0},{"had_liked":false,"id":163217,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1576672087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576672087","product_id":100039001,"comment_content":"打卡<br>1、接口的三个理解：<br>1）一组接口的集合，一个微服务的接口或是一个类的接口<br>如果一个接口集合中，部分调用者只使用了接口集合中的部分接口，就需要对这部分接口隔离出来，不强迫其他调用者也依赖这部分不被调用的接口。<br>2）单个API接口或是函数<br>如果部分调用者只使用了接口中的部分功能，就需要把函数功能拆分为更小的颗粒的函数，让调用者只依赖与他所需要的粒度的那个函数<br>3）OOP中的接口<br>接口的功能设计要单一，不要让接口的实现类和调用者，依赖不需要的接口函数。<br>2、接口隔离原则和单一职责原则的区别<br>单一职责原则考虑的是功能模块、类和接口的设计功能要单一。接口隔离原则注重于接口的设计，也从另一个角度去考虑问题，从调用者如何使用接口来判断接口的职责是否单一。如果调用者只使用部分接口或是接口的部分功能，那接口的设计就不够单一，需要把接口拆分为更小的颗粒度。","like_count":0},{"had_liked":false,"id":163212,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1576671171,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576671171","product_id":100039001,"comment_content":"接口的隔离也有点类似领域的划分 从行为上进行隔离 让调用方不多看见不应该看见的行为","like_count":0},{"had_liked":false,"id":163014,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1576640139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576640139","product_id":100039001,"comment_content":" AtomicInteger中的getAndIncrement满足单一职责，理由：这个方法只负责完成一个职责。因为在多线程环境下，要确保变量线程安全，获取值与值增加1属于同一个职责。而对于接口隔离原则而言，不应该强迫客户端依赖它不需要的接口。其中根据第二个单个API的而言，函数功能应该单一，所以不满足接口隔离原则","like_count":0},{"had_liked":false,"id":162876,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1576627926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576627926","product_id":100039001,"comment_content":"接口隔离原则关注的对象更多是接口，而且角度不同，从调用者的角度看接口是否符合单一职责原则。问题里的方法我认为不是接口隔离的，他将返回和增加耦合到一起了，没法复用","like_count":0},{"had_liked":false,"id":162814,"user_name":"|･ω･｀)","can_delete":false,"product_type":"c1","uid":1636123,"ip_address":"","ucode":"34E1DF62058D80","user_header":"https://static001.geekbang.org/account/avatar/00/18/f7/1b/8036958c.jpg","comment_is_top":false,"comment_ctime":1576594079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576594079","product_id":100039001,"comment_content":"我认为不符合单一职责原则<br>符合接口隔离原则<br>因为对使用方来说，他没有改变原来的数值<br>而对类本身来说，他做了两件事","like_count":0},{"had_liked":false,"id":162217,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1004755,"ip_address":"","ucode":"9BB9A170023CD8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/d3/46fd4aa3.jpg","comment_is_top":false,"comment_ctime":1576479276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576479276","product_id":100039001,"comment_content":"Go推荐使用单一接口，同时Go支持接口组合语法:<br><br>```go<br>type Reader interface {<br>\tread()<br>}<br><br>type Writer interface {<br>\twrite()<br>}<br><br>type ReadWriter interface {<br>\tReader<br>\tWriter<br>}<br>```","like_count":0},{"had_liked":false,"id":162210,"user_name":"potato00fa","can_delete":false,"product_type":"c1","uid":1307080,"ip_address":"","ucode":"D179E68D87CC50","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/c8/8e6dc340.jpg","comment_is_top":false,"comment_ctime":1576477801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576477801","product_id":100039001,"comment_content":"这节课还是很有用的，我之前直到现在写的代码，在Java Service层面上，大多数都是一个Interface 对应一个Impl，然后在重新写一个Impl的时候，就遇到了问题，这个Impl并不需要Interface里的一些功能，但是一旦继承以后就必须去实现，着实让人恼火。关键是接口没有隔离单一，在上层的多态环境里被随意调用，引发了各种各样的bug，最后只能强制编码人员谨慎使用某些类。","like_count":0},{"had_liked":false,"id":162198,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1576475810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576475810","product_id":100039001,"comment_content":"打卡～<br>我觉得从单一职责是符合但，因为从命名来看，\u001b和它做的事情是符合的，它本质上只做了原子操作加一。<br>但从接口隔离上不符合，因为它强迫调用者必须在做原子操作的时候去获取它之前的值。","like_count":0},{"had_liked":false,"id":162146,"user_name":"十二差一点","can_delete":false,"product_type":"c1","uid":1212732,"ip_address":"","ucode":"76C07F9A641630","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/3c/a01a60f3.jpg","comment_is_top":false,"comment_ctime":1576466795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576466795","product_id":100039001,"comment_content":"oc的协议可以通过@optional，@required来决定要不要实现，swift的协议也可以通过extension实现部分协议使其变成可选。iOS在设计的时候，应该就没考虑这个接口隔离原则。那Java为什么不这样设计呢？让接口也能可选和必选？那上面的第二种设计也就方便维护了","like_count":0},{"had_liked":false,"id":162106,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1576462261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576462261","product_id":100039001,"comment_content":"作为一个中台，要对接非常多的上层服务。每个服务都独立开一个服务包，这样管理的包太多了。不单独开一个服务包又违背了接口隔离。怎么怎么办啊？","like_count":0},{"had_liked":false,"id":162034,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1576453959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576453959","product_id":100039001,"comment_content":"此原则为单一职责原则提供了一个参考标准，根据调用者必要的功能来划分职责的范围","like_count":0},{"had_liked":false,"id":162033,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1576453883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576453883","product_id":100039001,"comment_content":"只给你必要的，而不是你想要的(ノ๑`ȏ´๑)ノ︵⌨","like_count":0},{"had_liked":false,"id":161985,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1576425010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576425010","product_id":100039001,"comment_content":"突然想到 JAVA 中的集合类库中，某些子类的实现直接为抛出异常。回去查看了一眼父类果然是标记了对应的异常<br>","like_count":0},{"had_liked":false,"id":161942,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1576410334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576410334","product_id":100039001,"comment_content":"1 ： 满足单一职责原则：因为AtomicInteger的 getAndIncrement 设计初衷就是为了实现原子性的整形操作，参考Serialization 类<br>2 ：满足接口隔离原则： 如果只是为了获取值，调用方可以使用 AtomicInteger 的 get方法<br>","like_count":0},{"had_liked":false,"id":161896,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1576395363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576395363","product_id":100039001,"comment_content":"getAndIncrement() 方法是符合接口隔离原则的, 因为 Atomically increments by one the current value 它属于 ++i, 返回的是 the previous value.","like_count":0},{"had_liked":false,"id":161866,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1576384579,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576384579","product_id":100039001,"comment_content":"这个接口放在Java并发编程这个场景下，符合单一职责原则—就是为了实现某个数得自增，同时解决了并发情况下数据覆盖的问题。<br><br>这个接口从接口隔离的角度，不符合接口隔离原则，因为该接口实现了get和increment两个功能，但是有可能调用者只需要其中一个","like_count":0},{"had_liked":false,"id":161846,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1576377813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576377813","product_id":100039001,"comment_content":"从命名来看，它就是要实现get&amp;increment，功能明确，符合单一职责；从使用场景来看，如果你只是想get或increment，它就违背了接口分离，因为引入了不需要的功能；但是如果调用者本来就需要get&amp;increment，那么它是没有违背接口分离的；","like_count":0},{"had_liked":false,"id":161804,"user_name":"白彬","can_delete":false,"product_type":"c1","uid":1498026,"ip_address":"","ucode":"E661F39B5F5861","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI8cnlibjqkJaYe0PpicFpF1V3LtzXrfot0bGwK1aT2zQtmnhmdUDwMHwBU5YqFmU8ibh0zqfIicTHHcw/132","comment_is_top":false,"comment_ctime":1576334981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576334981","product_id":100039001,"comment_content":"从原子操作的功能需求上考虑需要一个原子的操作支持返回老值和对计数器加一的原子操作。这个api是符合单一职责和接口隔离原则的。<br>","like_count":0},{"had_liked":false,"id":161801,"user_name":"白彬","can_delete":false,"product_type":"c1","uid":1498026,"ip_address":"","ucode":"E661F39B5F5861","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI8cnlibjqkJaYe0PpicFpF1V3LtzXrfot0bGwK1aT2zQtmnhmdUDwMHwBU5YqFmU8ibh0zqfIicTHHcw/132","comment_is_top":false,"comment_ctime":1576334380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576334380","product_id":100039001,"comment_content":"我理解符合单一原则。符合接口隔离原则。<br>从功能上讲 返回老值对原有值加一就是一个原子变量的基本功能。<br>从接口隔离讲。本身一个函数不涉及多个接口组合，用户依赖其中一个不依赖另一个的问题。而且这个函数不涉及返回多个数据，用户依赖其中一个属性的问题，用户调用说明需要这个函数的全部功能。","like_count":0},{"had_liked":false,"id":161624,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1576252147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576252147","product_id":100039001,"comment_content":"我个人理解是两个都满足<br>理由如下（个人观点）：<br>1、除了文章中提到的getAndIncrement，它里面还有getAndDecrement、incrementAndGet、decrementAndGet等这这种方法，操作的核心目的肯定是在于对于变量的加减操作，返回的值就是加减前后的，单一职责的我感觉满足了，如果目的不是为了加减，那就直接调用个get方法就好<br>2、对于1中说到的4个方法，例如getAndIncrement，incrementAndGet同样是加1，一个返回加之前一个加后，对于使用者，假如我就是要加之前的，那么也是完全符合接口隔离原则的，如果就是increment了，肯定有人在调用的时候，需要要加之前或者加之后的，自己还要在get一次","like_count":0},{"had_liked":false,"id":161608,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1576247238,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576247238","product_id":100039001,"comment_content":"我觉得应该是并发包,直接操作内存,对于锁的机制比较严格,所以将读和写操作写在一起,方便锁的处理吧.猜测而已,主写前端,对并发和锁不太懂.","like_count":0},{"had_liked":false,"id":161603,"user_name":"　扬帆丶启航　","can_delete":false,"product_type":"c1","uid":1235282,"ip_address":"","ucode":"4079D0889CD86C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/52/73351eab.jpg","comment_is_top":false,"comment_ctime":1576244980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576244980","product_id":100039001,"comment_content":"个人认为是满足单一原则的，因为只做了整数加一的操作；但是不满足接口隔离原则，因为不仅实现了整数加一，还提供了返回加一前的整数，调用者可能只使用其中的一个功能。","like_count":0},{"had_liked":false,"id":161573,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1576236043,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576236043","product_id":100039001,"comment_content":"这种方法中既有逻辑（新增，修改和删除逻辑），又要返回不是操作结果的内容，的确有二意性，项目中为了减少宂余，确实有这样的场景。<br>个人认为把 方法的操作和返回值，在方法名称中清晰的体现出来，名称和实际实现一致。<br><br>回到老师的题目，getAndIncrement方法名称，体现了：<br>1.increment 自增<br>2.get 返回<br>同时有And说明是2个操作。","like_count":0,"discussions":[{"author":{"id":1113660,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","nickname":"Miaozhe","note":"","ucode":"62872E8C138B67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81261,"discussion_content":"从接口隔离原则的判别维度，调用者的角度，无多余的操作，因此是复合该原则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576236456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161506,"user_name":"小小代码","can_delete":false,"product_type":"c1","uid":1290642,"ip_address":"","ucode":"F3D4E2C23FC9BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/92/f3dabcb1.jpg","comment_is_top":false,"comment_ctime":1576218918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576218918","product_id":100039001,"comment_content":"我认为AtomicInteger的getAndIncrement()函数设计是符合单一职责原则和接口隔离原则的，从并发编程的角度讲，获取和加1是一个原子操作，这么设计应该是考虑到了多线程的问题，从粗粒度讲，它是单一职责的","like_count":0},{"had_liked":false,"id":161489,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1576217210,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576217210","product_id":100039001,"comment_content":"今天学习的晚了，反而有更好的发现。<br><br>看了一圈评论，发现老师问的这个问题，如果单纯从单个功能上看，还有不同的意见；但是如果结合类中的其他方法，大致就明白这个函数存在的意义了。<br><br>所以，原来结合上下文也是需要具备的能力之一。","like_count":0},{"had_liked":false,"id":161485,"user_name":"ismind","can_delete":false,"product_type":"c1","uid":1138710,"ip_address":"","ucode":"7AADD673ED3BC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/16/d1dd4972.jpg","comment_is_top":false,"comment_ctime":1576216142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576216142","product_id":100039001,"comment_content":"个人思考：<br>1，是否符合单一职责？答案：符合。单一职责是说一个类或者模块只负责完成一个职责，很明显，这个方法只做了一件事那就是自增，有人会说：还返回了之前的值呀，那我也可以不让它返回或者返回自增之后的值，返回值只是函数完成一件事之后顺带的。归根到底，只做了一件事，那就是自增。<br>2，是否符合接口隔离原则？一个个来分析<br>（1）理解为一组API接口，很显然，这里是一个函数。这个不用考虑，跳过。<br>（2）单个API接口或者函数，没错，出现了“函数”，那么展开分析。这里，又感觉和单一职责类似，这个函数的粒度已经很细了，很显然，调用者需要的是将值自增，那么这个函数自然是符合接口隔离原则。<br>（3）oop中的接口，函数不是oop的接口，跳过。<br>    可以发现，这个函数的功能比较单一，和单一职责原则类似，那么是不是可以认为函数符合了单一职责，自然符合接口隔离原则？<br>综上所述，二者都符合，可以发现的是，如果只符合单一不符合接口隔离，或者反之，这是说不过去的，单一是类似于接口隔离的。<br>以上是个人的拙见，如果有错误还请指正，因为看到众说纷纭，所以干脆自己也思考一下。<br>期待老师给出详细而清晰的解答。","like_count":0},{"had_liked":false,"id":161459,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1576209220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576209220","product_id":100039001,"comment_content":"还是要看具体情况。<br>只从单一原则上来讲，是不符合的，这里进行了一次get操作和一次累加操作，这是两个功能。<br>如果调用者就是需要这种功能，那么是符合接口隔离原则的，他们绑定在一起，不需要隔离。","like_count":0},{"had_liked":false,"id":161454,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1576208702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576208702","product_id":100039001,"comment_content":"1.接口从单个api的角度考虑等价于单一职责原则。<br>2.从oop的角度考虑，抽象出多而小的接口，从代码的简洁性，扩展性，可读性都变得更好。","like_count":0},{"had_liked":false,"id":161426,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1576203997,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576203997","product_id":100039001,"comment_content":"getAndIncrement可以知晓加1是基于那个基数，得知基数是要做其它判断使用的。<br>单纯的计数可以使用LongAdder或者LongAccumulator。","like_count":0},{"had_liked":false,"id":161425,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1576203903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576203903","product_id":100039001,"comment_content":"课堂讨论Question: AtomicInteger#getAndIncrement()是否违反ISP?<br><br>课堂讨论Answer:<br><br>首先说结论: 函数符合单一职责原则,但不符合接口隔离原则.<br><br>要回答这个问题,前提是了解AtomicInteger类是做什么的:<br>AtomicInteger是java.util.concurrent包下的类,主要应用在并发场景下:<br>一个可能原子性更新的int值.它的应用场景可以是计数器.<br><br>该函数的设计无疑是符合单一职责原则的, 它仅做一件事: 为值+1,返回未加一之前的值.由于在并发场景可能其他thread也在同时操作这个类,它的设计是make sense的.<br><br>但该函数未必符合接口隔离原则,因为一个计数器可能不需要这个函数,可能仅需要incrementAndGet().这也许会让调用者迷惑: 我到底要用哪一个接口,getAndIncrement(),还是incrementAndGet()?<br><br>","like_count":0},{"had_liked":false,"id":161392,"user_name":"WIZ","can_delete":false,"product_type":"c1","uid":1260348,"ip_address":"","ucode":"313AF84674475C","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/3c/2947127c.jpg","comment_is_top":false,"comment_ctime":1576201089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576201089","product_id":100039001,"comment_content":"有个疑问，对于第一种情况，一组api通过隔离之后可能就会产生一个第二种情况还可以继续再隔离，按照这种理解的话，那不是随便一组接口都得隔离成好多个接口了嘛？若这样操作，是否合理？","like_count":0},{"had_liked":false,"id":161391,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1576200986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576200986","product_id":100039001,"comment_content":"我觉得这个符合接口隔离原则，因为他可以想象成是一组api操作，虽然是两个方法，但是是高内聚的，不符合单一职责","like_count":0},{"had_liked":false,"id":161390,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1576200909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576200909","product_id":100039001,"comment_content":"不错的思想，还是挺实用的","like_count":0},{"had_liked":false,"id":161386,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1576200621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576200621","product_id":100039001,"comment_content":"单一原则针对模块、类、接口。接口隔离原则对接口设计更细致说明。","like_count":0},{"had_liked":false,"id":161372,"user_name":"Geek_e7834d","can_delete":false,"product_type":"c1","uid":1530493,"ip_address":"","ucode":"ABAF1B1B7E6490","user_header":"","comment_is_top":false,"comment_ctime":1576199107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576199107","product_id":100039001,"comment_content":"getAndIncrement() 从接口隔离的角度可能很多人不会用到， 只会用到自增的用法。 但是从单一职责来看，如果拆成两个函数， 就不是线程安全的， 需要额外的逻辑来调用。从这个角度来说， 放在AutoInteger里，也是合理的。","like_count":0},{"had_liked":false,"id":161371,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1576198864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576198864","product_id":100039001,"comment_content":"接口隔离原则是从调用者角度看的，调用者不需要依赖他不应该依赖的接口，单一职责原则是从设计的时候需要考虑的事情","like_count":0},{"had_liked":false,"id":161364,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1576198491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576198491","product_id":100039001,"comment_content":"我觉得符合接口隔离原则，和单一职业原则。并发包里面除了getAndIncrement还有一个incrementAndGet的方法。两个方法都是已原子方式将当前值加1。不同的是一个返回原值，一个返回的是加1后的值。说明设计者已经将接口拆分成了一个更加细粒度的接口。在实际并发操作中可以根据具体情况来调用不同的接口。不知道理解对不对。","like_count":0},{"had_liked":false,"id":161362,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1237655,"ip_address":"","ucode":"088A8DA0A16BDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","comment_is_top":false,"comment_ctime":1576198197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576198197","product_id":100039001,"comment_content":"打卡打卡","like_count":0},{"had_liked":false,"id":161353,"user_name":"yy","can_delete":false,"product_type":"c1","uid":1120074,"ip_address":"","ucode":"04D42CDE3F5BBA","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/4a/87a6f2dc.jpg","comment_is_top":false,"comment_ctime":1576197333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576197333","product_id":100039001,"comment_content":"有个疑问接口隔离原则跟功能内聚是否有矛盾，比如useService类的设计按内聚来讲应该是把删除用户也放同一个类中而不是分开。请老师指正","like_count":0},{"had_liked":false,"id":161352,"user_name":"yy","can_delete":false,"product_type":"c1","uid":1120074,"ip_address":"","ucode":"04D42CDE3F5BBA","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/4a/87a6f2dc.jpg","comment_is_top":false,"comment_ctime":1576197134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576197134","product_id":100039001,"comment_content":"单一职责原则应该是站在用户的角度去思考职责是否单一。getAndIcrement接口符合用户的单一需求。","like_count":0},{"had_liked":false,"id":161341,"user_name":"张飞online","can_delete":false,"product_type":"c1","uid":1249136,"ip_address":"","ucode":"C9787E4B35888C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","comment_is_top":false,"comment_ctime":1576196123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576196123","product_id":100039001,"comment_content":"不管那哪种接口，最终目的是为了提炼出需要实现的公共部分，但是现实是这个公共部分不一定真的公共，所以我们又要看公共部分的”公共覆盖度”来确定设计小借口还是大而全的接口。","like_count":0},{"had_liked":false,"id":161322,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1576193180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576193180","product_id":100039001,"comment_content":"接口隔离原则懂了，单一职责原则还是有点区分不好，是懂非懂，感觉接口隔离原则是判定职责是否单一，单独看职责可能是单一，必须对各种使用场景是否隔离才能判定这个接口职责是否单一。不知道理解的正确不？","like_count":0},{"had_liked":false,"id":161321,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1576193097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576193097","product_id":100039001,"comment_content":"思考题:<br>      我认为符合接口隔离职责不符合接口单一职责。因为这个函数包含两个功能（返回修改前的值、值加1），所以包含两个功能，不符合接口单一职责。而这两个功能是需要被同时使用到的，所以符合接口隔离原则！","like_count":0},{"had_liked":false,"id":161318,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576190661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576190661","product_id":100039001,"comment_content":"思考题<br>这个接口没问题，这里确实有两步，但是这两步在并发语境下是高内聚的。","like_count":0},{"had_liked":false,"id":161317,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576190515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576190515","product_id":100039001,"comment_content":"可以从三个角度看接口拆分：<br>接口集合的适当拆分,将一个接口集合按照功能拆分成不同接口集合。<br>单个复杂接口的拆分，将一个接口拆分成若干接口。<br>基于被实现者和被调用者的适当拆分，做到没有多余的dummy实现。","like_count":0},{"had_liked":false,"id":161312,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1576179522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576179522","product_id":100039001,"comment_content":"第一种理解和第三种理解的区别有点困惑，感觉第一种理解更侧重于使用者，第三种理解更侧重于代码开发？看起来都像是在说职责要单一","like_count":0},{"had_liked":false,"id":161360,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1576198128,"is_pvip":true,"discussion_count":13,"race_medal":0,"score":"624346456048","product_id":100039001,"comment_content":"Java.util.concurrent.atomic包下提供了机器底层级别实现的多线程环境下原子操作，相比自己实现类似的功能更加高效。<br>AtomicInteger提供了<br>intValue() 获取当前值<br>incrementAndGet() 相当于++i<br>getAndIncrement相当于i++<br>从getAndIncrement实现“原子”操作的角度上来说，原子级别的给整数加一，返回未加一之前的值。它的职责是明确的，是符合单一职责的。<br><br>从接口隔离原则上看，也是符合的，因为AtomicInteger封装了原子级别的整数操作。<br><br>补充：<br>多线程环境下如果需要计数的话不需旧的值时，推荐使用LongAdder或者LongAccumulator（CoreJava上说更加高效，但我对比了AtomicLong和LongAdder，没感觉效率上有提高，可能是例子写的不够准确。测试代码见 https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;tree&#47;master&#47;designpattern&#47;u18 希望和小伙伴们一起讨论）","like_count":146,"discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84039,"discussion_content":"LongAdder是用了更多的空间换取时间的,会将所有加的操作记入自己的内存空间,当获取到操作时一次性写入.这种在多个线程频繁竞争时性能就显现出来了.","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1576482639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84051,"discussion_content":"谢谢回复！涨姿势！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576483682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":84039,"ip_address":""},"score":84051,"extra":""}]},{"author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283250,"discussion_content":"我对LongAddr里面的设计思想是这么理解的：举个例子，假如有一个记录余额的数字，在并发高的情况下对这个余额进行更新操作，为了保证线程安全，对这个数字操作一定是在一个时刻里只能一个线程操作，那这种情况下就意味着对多线程的竞争是非常激励的，从第一个线程执行到最后一个线程执行完时间相对比较久，那我们换成LongAddr这种思路就是我把这个余额用多个数字进行记录，这多个数字的总和当然是正确的余额数，这个时候多并发更新操作的时候，就可以将多个线程分散到对这多个数字进行操作从而减少了并发竞争程度从而提升性能。当然这种设计思路是要求对数据不是强一致性的场景，在一些极端的情况去查数据会存在脏数据的情况。其实这设计思想可以应用在很多的场景当中","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1592222967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81059,"discussion_content":"每次都想看你的评论，哈哈","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576216751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":81130,"discussion_content":"谢谢你的关注，我好开心啊，居然有人喜欢看我的评论！我会继续加油哒！","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576225512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":81059,"ip_address":""},"score":81130,"extra":""},{"author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":300280,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598009822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":81130,"ip_address":""},"score":300280,"extra":""}]},{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96687,"discussion_content":"上面的解释是错的，LongAdder的思想是拆分锁的粒度，可以去看源码","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577086281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":97262,"discussion_content":"我看不懂源码呀🤣，给我们讲讲吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577109407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96687,"ip_address":""},"score":97262,"extra":""}]},{"author":{"id":1184185,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/b9/abb7bfe3.jpg","nickname":"小桶","note":"","ucode":"7967FF96CDE753","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302117,"discussion_content":"哥们，审题了吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598794089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004758,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/d6/124e2e93.jpg","nickname":"Calios","note":"","ucode":"B1AA60164DC42A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187206,"discussion_content":"名字太有个性，想不注意到都难～🤣","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582727779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2034632,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0b/c8/15f055d3.jpg","nickname":"图灵机","note":"","ucode":"EB02DB653AD591","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298778,"discussion_content":"多线程并发累加，累加次数大的时候差距还是比较明显的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597397277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","nickname":"注定非凡","note":"","ucode":"80673056E131B7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289029,"discussion_content":"佩服","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593958893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93200,"discussion_content":"我也关注到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576914020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161423,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1576203512,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"426777965816","product_id":100039001,"comment_content":"设计模式_18<br>纯理论分析，这么设计是不符合“接口隔离”原则的，毕竟，get是一个操作，increment是另一个操作。<br><br>结合具体场景，Atomic类的设计目的是保证操作的原子性，专门看了一下AtomicInteger的源码，发现没有单独的 increment 方法，然后思考了一下线程同步时的问题，场景需要保证 get 与 increment 中间不插入其他操作，否则函数的正确性无法保证，从场景的角度，它又是符合原则的。","like_count":99},{"had_liked":false,"id":286350,"user_name":"星溯","can_delete":false,"product_type":"c1","uid":2528121,"ip_address":"","ucode":"A185ACCDE20723","user_header":"https://static001.geekbang.org/account/avatar/00/26/93/79/9efa9c11.jpg","comment_is_top":false,"comment_ctime":1617264910,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"147646152974","product_id":100039001,"comment_content":"老师此题大有深意，我们可以从此思考题中方法的设计来深化对单一职责和接口隔离的理解：<br>接口隔离，强调的是调用方，是否只使用了接口中的部分功能？若是，则违反接口隔离，应当细粒度拆分接口，从这个例子看，调用方诉求与方法名完全一致，通过方法内部封装两个操作，实现原子性，达成了调用方的最终目的，不多不少。<br>单一职责，不强调是否为调用方，只要能某一角度观察出，一个模块&#47;类&#47;方法，负责了多于一件事情，就可判定其破坏了单一职责，基于此经典理论，不假以深层次思考的角度出发，从方法本身的命名（做两件事）就可断定，它一定是破坏了单一职责的，应该拆分为两个操作。<br>但我们可以结合老师说的，判定职责是否单一，要懂得结合业务场景，业务需求，此方法，其实就是要通过JDK提供的CAS乐观自选锁（方法最终依赖硬件指令集原语，Compare And Swap）从“原语”这一词的含义看，其实也是同时、原子性地做了一件“完整”的事情，因此，考虑这一点，是可以判定它符合单一职责的。<br>而这其实正是单一职责判定结果，往往见仁见智的原因：基于不同的角度，不同的立场，不同的业务理解，往往可以得到不同的判定结果，但不必纠结，判定过程中用到的思想才是精髓。","like_count":35,"discussions":[{"author":{"id":2862349,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL7iccMa4yaKJyLyibysdJBiaodgMickvdCxc58knqcHibDBdBK3WDhPHOAXia7E1BZ7gba4bph6FwaN7sw/132","nickname":"之一","note":"","ucode":"F58398575F85F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553069,"discussion_content":"赞，豁然开朗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645705088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1630504,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e1/28/0a26566d.jpg","nickname":"奕涛_steve","note":"","ucode":"07B39F3C746C3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542449,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640752362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028956,"avatar":"","nickname":"勿更改任何信息","note":"","ucode":"575185C69C05A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408714,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635306340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245040,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/70/4a6f9065.jpg","nickname":"happyfucheng","note":"","ucode":"458E67028A5368","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396207,"discussion_content":"为你点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632403554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161562,"user_name":"Geek_e9b8c4","can_delete":false,"product_type":"c1","uid":1716601,"ip_address":"","ucode":"C29F7344A6EE6B","user_header":"","comment_is_top":false,"comment_ctime":1576233087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"147605121151","product_id":100039001,"comment_content":"总结成思维导图了，链接 https:&#47;&#47;blog.csdn.net&#47;dingshuo168&#47;article&#47;details&#47;103531805","like_count":34},{"had_liked":false,"id":161344,"user_name":"码到成功","can_delete":false,"product_type":"c1","uid":1251915,"ip_address":"","ucode":"E9CD9832CD14BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/1a/4b/98c5a1e8.jpg","comment_is_top":false,"comment_ctime":1576196240,"is_pvip":false,"replies":[{"id":"61487","content":"集中答疑一下吧 课都提前录好了","user_name":"作者回复","comment_id":161344,"uid":"1190123","ip_address":"","utype":1,"ctime":1576198161,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"130425215120","product_id":100039001,"comment_content":"老师可以每次课对上一次课的思考题做下解答吗","like_count":30,"discussions":[{"author":{"id":1002095,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","nickname":"xzy","note":"","ucode":"1A44368083A19E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368066,"discussion_content":"说的很好，但是“迭代器迭代完成后将列表中对应时间点删除”这个操作，跟老师上节课中，对“遍历时改变集合导致的未决行为”的第一种解决方案一样，要求程序员在使用完迭代器之后要主动执行一个函数操作，也增加了开发成本，还很容易漏掉。\n\n个人觉得可以参照WeakHashMap的实现，来规避掉这个主动操作\n在容器内部，创建一个List<WeakReference> iterators对象，把创建的迭代器保存到这个对象里，当执行size()或者容器扩容时，遍历iterators，找到第一个WeakReference指向的iterator不为null的对象，在容器中删除这个iterator创建时间之前删除的对象\n\n\n","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1618556058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222650,"discussion_content":"应该是delTimestamp小于列表中最小时间戳","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1586166161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1199213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","nickname":"LJK","note":"","ucode":"12B2441099FF1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223477,"discussion_content":"对，是delTime…失误了…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586229220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":222650,"ip_address":""},"score":223477,"extra":""},{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306852,"discussion_content":"我也是这样认为的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600403466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":222650,"ip_address":""},"score":306852,"extra":""}]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222655,"discussion_content":"而且可以根据actualSize和totalSize的比值，设定一个合理的watermark，达到了这个watermark，再去统一清理标记删除的元素","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1586166465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225008,"discussion_content":"如果直接把元素从数组中删除, 那么是不是需要移动元素, 这样是不是会影响到全部迭代器呢? 如果只是单独把删除的位置设置成nil, 那么这个快照数组就会越来越长, 还需要设计一个机制用来把整个快照数组都删掉","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1586343656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015951,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/8f/d8c2a82a.jpg","nickname":"波风皆人","note":"","ucode":"BA2D163A88C4A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251077,"discussion_content":"有点那个意思，不过mvcc是多版本的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588063474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2242740,"avatar":"https://static001.geekbang.org/account/avatar/00/22/38/b4/1843033d.jpg","nickname":"lh","note":"","ucode":"F048C6C0C7E8EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346525,"discussion_content":"删除前需要确定当前没有进行中的迭代器，并且清理的过程中不允许新建迭代器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611981162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109528,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","nickname":"王大喵","note":"","ucode":"C14AAE3ED964DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316025,"discussion_content":"我怎么知道迭代器已经处理完成了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603350704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1053926,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/e6/ab69e495.jpg","nickname":"Aze","note":"","ucode":"F2F5E10E2432DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1109528,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","nickname":"王大喵","note":"","ucode":"C14AAE3ED964DE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331077,"discussion_content":"为迭代器创建虚引用，当迭代器被回收时，清空容器中相应元素。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1606783813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":316025,"ip_address":""},"score":331077,"extra":""}]},{"author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234525,"discussion_content":"那也得有个迭代器知道我的时间戳是最小的。但是每个迭代器之间又是独立的，所以还需要引入一个额外的拥有全部迭代器的开始时间戳的组件，这要搞起来就很麻烦了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586965873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161373,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1576199116,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"74590643148","product_id":100039001,"comment_content":"思考题：<br>先看是否符合单一职责原则，这个函数的功能是加1然后返回之前的值，做了两件事，是不符合单一职责原则的！<br>但是却符合接口隔离原则，从调用者的角度来看的话，因为这个类是Atomic类，需要的所有操作都是原子的，所以为了满足调用者需要原子性的完成加一返回的操作，提供一个这样的接口是必要的，满足接口隔离原则。","like_count":17,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510665,"discussion_content":"嗯嗯 ������\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1651664,"avatar":"https://static001.geekbang.org/account/avatar/00/19/33/d0/962ebe2e.jpg","nickname":"Buring","note":"","ucode":"0AAEA64C63C2F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384559,"discussion_content":"您好，这里的应该不是虚引用吧，而是应该采用弱引用，毕竟弱引用定义是只要gc，必定被回收的，而这里的数组里的元素刚好符合这一点","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1626664522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161351,"user_name":"方小白","can_delete":false,"product_type":"c1","uid":1441572,"ip_address":"","ucode":"425F5167C15407","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/24/d8f97f2c.jpg","comment_is_top":false,"comment_ctime":1576196948,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70295673684","product_id":100039001,"comment_content":"符合SRP 也符合ISP 。<br><br>理由是这个方法完成的逻辑就是一个功能：新增和返回旧值。只不过是两步操作罢了。如果你想获取，就用get方法，自增就用increment 方法。都有提供哇。<br><br>SRP：老师在文中说，实际上，要从中做出选择，我们不能脱离具体的应用场景。所以我认为是符合的。<br><br>ISP: 可以参考老师说的这句话：而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。<br>我们调用这个方法肯定是要用它的整个功能，而不是其中的一个新增或自增功能。","like_count":16,"discussions":[{"author":{"id":2264685,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/6d/f2354440.jpg","nickname":"瞌睡的李先生","note":"","ucode":"88480FAFB4F879","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332016,"discussion_content":"在cpp这样的语言中使用析构函数可能是一种方案，但是那必须将迭代器的生命周期限定在某个函数内。如果是java这种依赖gc的语言那就更加不可能了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607045875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243331,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f8/c3/1d557354.jpg","nickname":"o my love","note":"","ucode":"307601ACAC5DCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297367,"discussion_content":"可以通过在容器中维护迭代器的游标来做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596889287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296904,"discussion_content":"迭代器的析构","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596700510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212912,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/f0/695ca05f.jpg","nickname":"Ifdevil","note":"","ucode":"79DB0ADE9AD082","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263528,"discussion_content":"是不是可以加个状态标记一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589210185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1945605,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/b0/05/c9da834e.jpg","nickname":"小人物大希望","note":"","ucode":"8EF313AA26D4B8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263422,"discussion_content":"也可以覆盖finalize()方法吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589206519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178683,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/3b/c6b5b64f.jpg","nickname":"bboy孙晨杰","note":"","ucode":"D7389FB3368749","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252330,"discussion_content":"是不是可以在迭代器使用结束之后，调用一个release方法，来当做commit。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588155872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1178683,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/3b/c6b5b64f.jpg","nickname":"bboy孙晨杰","note":"","ucode":"D7389FB3368749","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275221,"discussion_content":"不可以，因为什么时候使用完迭代器不可知","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590677357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252330,"ip_address":""},"score":275221,"extra":""},{"author":{"id":1109528,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","nickname":"王大喵","note":"","ucode":"C14AAE3ED964DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1178683,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/3b/c6b5b64f.jpg","nickname":"bboy孙晨杰","note":"","ucode":"D7389FB3368749","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316027,"discussion_content":"上一节也说过这个问题，这样还有个缺点  开发可能会忘记调用release方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603350781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252330,"ip_address":""},"score":316027,"extra":""},{"author":{"id":1125806,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/nVVI6Fib5LHbhAhv8CJ9MYPau7Lcp840ST6BeqnlibUNmI4UYvGIzxtOHcKIzFa10ERANAZQUaiaKkQg4SowsUR2g/132","nickname":"瓶子霸哥","note":"","ucode":"A7EEB459AB5550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323247,"discussion_content":"当没有迭代器的强引用的时候就使用完迭代器了吧，是不是用幻象引用可以当一个判断啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604906532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275221,"ip_address":""},"score":323247,"extra":""}]}]},{"had_liked":false,"id":161327,"user_name":"NoAsk","can_delete":false,"product_type":"c1","uid":1122412,"ip_address":"","ucode":"71CA29776B4F68","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/6c/e4966364.jpg","comment_is_top":false,"comment_ctime":1576194289,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70295671025","product_id":100039001,"comment_content":"单一职责原则针对的是模块、类、接口的设计。getAnd<br>Increase()虽然集合了获取和增加两个功能，但是它作为对atomicInteger的值的常用方法，提供对其值的常规操作，是满足单一原则的。<br><br>从单一原则的下面这个解释考虑，是不满足接口隔离原则的。“如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。”，用户可能调用获取或增加的其中一个方法，再或者先调用增加再调用获取increaseAndGet()方法。<br><br>这是我个人理解，还望大家指正。","like_count":16,"discussions":[{"author":{"id":1182146,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","nickname":"老庄道人","note":"","ucode":"C102EA323A69B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345249,"discussion_content":"这个不行吧，当要缩容的时候还有迭代器怎么办，这里的终极目的不是节省容量，而是迭代器正常运行，节省容量只是附带","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611706628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1651664,"avatar":"https://static001.geekbang.org/account/avatar/00/19/33/d0/962ebe2e.jpg","nickname":"Buring","note":"","ucode":"0AAEA64C63C2F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182146,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","nickname":"老庄道人","note":"","ucode":"C102EA323A69B4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":384562,"discussion_content":"可以采用弱引用来解决，只要gc即可回收，或者软引用取代强饮用，在内存不足时，强制清除那些软引用的元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626664663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345249,"ip_address":""},"score":384562,"extra":""}]},{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223815,"discussion_content":" 那你的迭代怎么办？垃圾回收方式，有迭代器之后删除的不回收？可是怎么感知外部的迭代器呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586256994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161665,"user_name":"小海","can_delete":false,"product_type":"c1","uid":1183874,"ip_address":"","ucode":"E566E4B9E9852C","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/82/f5a3ecf5.jpg","comment_is_top":false,"comment_ctime":1576290295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"66000799735","product_id":100039001,"comment_content":"回答课后讨论题得结合具体的场景和运行环境。AtomicInteger的getAndIncrement()函数的职责很单一，就是&quot;获取当前值并递增&quot;这一步原子操作，有人说这是两步操作，这个函数是运行在多线程并发环境下，在这种环境下把获取当前值和递增拆分成两个函数会获得错误的结果，而该函数内部封装了两步操作使其成为一个原子操作，从这个角度任意一方都是另一方的附属品，两者必须同时完成而不能拆分，如果仅仅是为了获取当前值或者递增那完全可以使用该类的其它函数。从调用方的角度，必然是同时用到了获取当前值和递增两个功能，而不是部分功能，明白该函数设计的&quot;单一职责&quot;，就知道它符合SRP和ISP，不要试图去拆分一个原子操作。","like_count":15},{"had_liked":false,"id":176761,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1581157133,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"61710699277","product_id":100039001,"comment_content":"接口隔离原则：我只要我想要的，不想要的别给我<br>","like_count":14,"discussions":[{"author":{"id":1465328,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5b/f0/630735be.jpg","nickname":"枫","note":"","ucode":"79E8B292617168","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334106,"discussion_content":"应该是：我只给你想要的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607744042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377675,"discussion_content":"秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622771043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161350,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1576196850,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18756066034","product_id":100039001,"comment_content":"思考题:<br>个人感觉，不符合单一职责，也不符合接口隔离，因为函数做了两件事，不应该把获取当前值和值加1放在一起，因为<br>1.用户可能需要-1 *1等其他运算操作再返回原始值，这样就要n个方法每个方法中都有返回原始值的操作。<br>2.用户可能只想运算操作，不想运算后暴露原始结果<br>3.如果用户以后还想获取操作后的值，这个函数就不能同时返回两个值了<br>希望大家指正","like_count":4,"discussions":[{"author":{"id":1456964,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","nickname":"菜头","note":"","ucode":"C5E95519F9EA21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571489,"discussion_content":"this.leftCount &gt;= 0; // 注意是&gt;=, 而非&gt;\n这个是什么原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652240289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337191,"discussion_content":"cursorInAll一直指向下一个要遍历的元素（符合时间范围）。justNext()方法当元素不符合时间范围会cursorInAll++，遍历到下一个符合条件的元素时结束，此时执行next()会返回cursorInAll指向的元素，返回之前会执行justNext()，cursorInAll又指向下一个要遍历的元素。我觉得代码没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608820292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1372576,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/uEO3jibbiaWwYLQAIxV9icKGibe4B18D4j2fmCquLELeKnatj8UpW27x83KEmSESshC4rg4HqJpmNh0qBFiaZdqLUsw/132","nickname":"达生","note":"","ucode":"98474B2BB03579","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340465,"discussion_content":"如果第0个是未删除的，那永远都不会执行cursorInAll++","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610011139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337191,"ip_address":""},"score":340465,"extra":""},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1372576,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/uEO3jibbiaWwYLQAIxV9icKGibe4B18D4j2fmCquLELeKnatj8UpW27x83KEmSESshC4rg4HqJpmNh0qBFiaZdqLUsw/132","nickname":"达生","note":"","ucode":"98474B2BB03579","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342302,"discussion_content":"没太懂你的意思，如果第0个是未删除的那创建SnapshotArrayIterator对象执行justNext()方法的时候就不会执行cursorInAll++，所以cursorInAll指向的是第0个（符合时间范围），往后面遍历的时候每执行一次next()方法就会执行justNext()使cursorInAll执行符合时间范围的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610632049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340465,"ip_address":""},"score":342302,"extra":""},{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1372576,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/uEO3jibbiaWwYLQAIxV9icKGibe4B18D4j2fmCquLELeKnatj8UpW27x83KEmSESshC4rg4HqJpmNh0qBFiaZdqLUsw/132","nickname":"达生","note":"","ucode":"98474B2BB03579","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348832,"discussion_content":"同样的感觉，没地方做增一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612748262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340465,"ip_address":""},"score":348832,"extra":""}]},{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304197,"discussion_content":"可以的老哥 我想了半天才想明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599493019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304191,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599492717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282920,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1615465610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14500367498","product_id":100039001,"comment_content":"按语法定义貌似是违背了单一职责和接口隔离原则的。<br>但是我们要考虑的是单一职责和接口隔离的意义是什么？是为了隔离开单元模块，方便使用者随机组合、灵活运用。<br><br>但该方法的目的是为了正确获得更新与获得上一个值的准确定义。该方法通过cas无锁算法，实现了乐观锁，同时保证返回了准确值。<br><br>假如系统不提供此方法，而是业务自行调用get方法获取自增前的值，然后加上一再设置新值。那这里从获取到设置的整段代码，就不是线程安全的了。违背了这段代码的初衷。<br><br>反过来讲，调用方自己可以实现锁来保证线程安全。但是这个线程安全的职责就从 atomicInteger转移到了调用类，显然不是设计的初衷。<br><br>所以结合业务场景，两段操作，实际是要求原子话的。也就复合单一职责和借口隔离原则了。","like_count":3},{"had_liked":false,"id":202109,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1585903960,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14470805848","product_id":100039001,"comment_content":"文中第一种和第三种理解不是同一种吗？都是为了减少依赖不需要的接口函数。","like_count":3},{"had_liked":false,"id":163402,"user_name":"陈拾柒","can_delete":false,"product_type":"c1","uid":1473069,"ip_address":"","ucode":"22213E2FA5143A","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/2d/e3a5c52e.jpg","comment_is_top":false,"comment_ctime":1576717455,"is_pvip":false,"replies":[{"id":"62264","content":"不一样呢你再看看","user_name":"作者回复","comment_id":163402,"uid":"1190123","ip_address":"","utype":1,"ctime":1576796900,"user_name_real":"王争"}],"discussion_count":9,"race_medal":0,"score":"14461619343","product_id":100039001,"comment_content":"为什么觉得老师说的，对于接口的三种理解，第一种理解和第三种理解说的是同一件事情~","like_count":3,"discussions":[{"author":{"id":1332256,"avatar":"https://static001.geekbang.org/account/avatar/00/14/54/20/90ad5247.jpg","nickname":"NiceBen","note":"","ucode":"793679E3520E84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352765,"discussion_content":"这个不行，如果删除数组之前有了Iterator的快照了，你将这个指向了Object，那么之前行程快照的Iterator再迭代元素的时候，就出问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614845529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350816,"discussion_content":"如果多次删除元素呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614038617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1300285,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d7/3d/a076faf1.jpg","nickname":"蜗牛","note":"","ucode":"A99C9C890F95E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326842,"discussion_content":"可以详细解释下这个吗，有点不太懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605686905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/be/53/eda4b622.jpg","nickname":"Smile @ Life","note":"","ucode":"320EDAD5A8BE56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295322,"discussion_content":"享元模式吗，但是问题是数组元素依然需要保留一个指针的大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596164593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293927,"discussion_content":"奇思妙想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595730575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161361,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1576198137,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14461100025","product_id":100039001,"comment_content":"单一职责是针对于模块、类在具体的需求业务场景下是否符合只做一件事情的原则。<br>而接口隔离原则就细化到了接口方面，我是这样理解的，如果接口中的某些方法对于需要继承实现它的类来说是多余的，那么这个接口的设计就不符合接口隔离原则，可以考虑再拆分细化。<br>对于课后思考题，他只对该数做了相关操作符合单一职责原则。但从接口、函数来看它实现了两个功能，获取整数及给该整数加一，是不符合接口隔离原则的。<br>不知道我这样考虑是否正确，望指正","like_count":3,"discussions":[{"author":{"id":1300285,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d7/3d/a076faf1.jpg","nickname":"蜗牛","note":"","ucode":"A99C9C890F95E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326843,"discussion_content":"怎么才能知道迭代完了呢。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605686937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281395,"discussion_content":"上节课说的迭代完成的时刻怎么判断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591718537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161723,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1576308471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166243063","product_id":100039001,"comment_content":"感觉是属于比较难判断是否单一职责的内容，顺便回头翻了一下单一职责的章节:在理解一下，单一职责主要还是要结合业务，getAndIncrement的方法实现了: 原子的获取并且新增的这一职责，如果拆开成get和Increment的话，就需要外层加锁处理原子的获取并新增操作，对于业务不太合适。<br>从接口隔离的原则看，调用这个方法的类，本身就是依赖这个接口，所以并没有违反。<br>想到一个问题： <br>如果一个类中，有n个查询的业务接口，根据姓名查，根据年纪查，根据地址查(假设不是参数控制，而是拆成3个接口)。那么不同调用方依赖这个类的时候，有可能是根据姓名查，有可能根据年纪查，如果都拆开了。那么接口是不是粒度太细了","like_count":2},{"had_liked":false,"id":161330,"user_name":"Chen","can_delete":false,"product_type":"c1","uid":1503113,"ip_address":"","ucode":"C1128558AB5BC4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/89/8c73a24d.jpg","comment_is_top":false,"comment_ctime":1576194799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166129391","product_id":100039001,"comment_content":"getAndIncrement()符合接口隔离原则，这是不是一个大而全的函数，而是一个细粒度的函数，跟count++的功能类似。","like_count":2},{"had_liked":false,"id":328698,"user_name":"邵亮","can_delete":false,"product_type":"c1","uid":1810890,"ip_address":"","ucode":"8407C3FDD11C0E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a1/ca/aae116f5.jpg","comment_is_top":false,"comment_ctime":1640846495,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5935813791","product_id":100039001,"comment_content":"从接口名称上来说不符合，但是因为是要实现原子操作，结合场景是符合的","like_count":1},{"had_liked":false,"id":271630,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1609743725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5904711021","product_id":100039001,"comment_content":"接口隔离原则中的”接口“在这里指的是函数，AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减，getAndIncrement()相当于线程安全的i++操作，调用者需要的是函数的需要加的同时，返回旧值，换句话说：用的是函数的全部功能，符合接口隔离原则。<br><br>getAndIncrement（）执行的是i++这个单一操作，因此也符合单一职责原则。","like_count":1},{"had_liked":false,"id":245407,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1598939021,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5893906317","product_id":100039001,"comment_content":"如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。<br>getAndIncrement通过调用CAS实现原子自增，保证线程安全。自增本身必须包含两个操作，取值和加一，我觉得这里的返回的取值，只是一个附产品。<br>在了解getAndIncrement方法的过程中，了解到CAS操作的乐观锁和自旋，还要CAS操作带来的ABA问题，堪比小说，很有意思！","like_count":1,"discussions":[{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281393,"discussion_content":"如果有并发的情况，怎么知道在这个迭代器之前的迭代器已经迭代完成了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591718416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1514305,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","nickname":"xk_","note":"","ucode":"DFE1AC38EA78A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282202,"discussion_content":"并不需要知道它已经迭代完成了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591922084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281393,"ip_address":""},"score":282202,"extra":""}]}]},{"had_liked":false,"id":230434,"user_name":"skying","can_delete":false,"product_type":"c1","uid":1041865,"ip_address":"","ucode":"E7CFF50AB64BB1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","comment_is_top":false,"comment_ctime":1593391174,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5888358470","product_id":100039001,"comment_content":"我理解是符合接口隔离原则。<br>因为需要提供 原子性的服务能力，即 更新数据且返回更新后的数据，要保证原子性，必须在一个方法调用中返回。","like_count":1},{"had_liked":false,"id":229361,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592974994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887942290","product_id":100039001,"comment_content":"单一职责原则是从业务场景设计角度来看模块，类，方法的职责。而接口隔离则是避免将多余的数据暴露给调用方。想着想着感觉两个差不多啊","like_count":1},{"had_liked":false,"id":225920,"user_name":"N。","can_delete":false,"product_type":"c1","uid":1647830,"ip_address":"","ucode":"8EE55D4A24004A","user_header":"https://static001.geekbang.org/account/avatar/00/19/24/d6/c65a71b3.jpg","comment_is_top":false,"comment_ctime":1591889597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886856893","product_id":100039001,"comment_content":"根据具体的使用场景来做分析 这个是符合的，因为get和increment 他们在一起是必要的原子操作，分开后无法保证原子性","like_count":1},{"had_liked":false,"id":223597,"user_name":"扶摇九万里","can_delete":false,"product_type":"c1","uid":1240371,"ip_address":"","ucode":"58F30697C9D62B","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/33/070f7537.jpg","comment_is_top":false,"comment_ctime":1591142047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886109343","product_id":100039001,"comment_content":"按照我的理解，不同服务接口分离也是最小暴露加接口组合，oop接口是同一个服务的最小暴露加组合，主要还是组合给予的灵活扩展能力与功能管理能力吧","like_count":1},{"had_liked":false,"id":193872,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1584975819,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5879943115","product_id":100039001,"comment_content":"【设计模式笔记19】20200323<br>在之前的理解中接口隔离原则，只是单纯接口维度的隔离，比如两个不同的接口实现得功能不应该一样，另外目前犯了一个错误多个类似功能的会放在一个接口。今天学到了如果这些相似的接口都是给特定的接口调用方使用的话需要单独开一个接口，这样才符合接口隔离原则。从范围上看，一组接口、一组方法、一组函数都符合这个原则，使用方使用场景要分开。目前在实际开发中会使用重构为内部类的方式让代码更易读，实际上在开发工具中也是默认支持的，但是我们可以重构更彻底一些，哪个调用方使用，使用场景，多思考一下代码就能有提高。最后关于Atomic类的问题，我们从类名也可以看出，这是针对源自操作封装的方法，所以都是原子维度的操作，并不冲突，是符合接口隔离原则的","like_count":1},{"had_liked":false,"id":181717,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1582623746,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877591042","product_id":100039001,"comment_content":"感觉单一职责和接口隔离是总分的关系。单一职责大而全，接口隔离专门指接口的单一职责。似乎这两个不应该是并列关系，而是递进互相解释的关系","like_count":1},{"had_liked":false,"id":168777,"user_name":"LYy","can_delete":false,"product_type":"c1","uid":1102062,"ip_address":"","ucode":"8D5C39B9531E71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ee/f5c5e191.jpg","comment_is_top":false,"comment_ctime":1578156214,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5873123510","product_id":100039001,"comment_content":"SIP: 如果调用方不完全需要接口提供的全部功能，那么就需要审视接口是否可以进一步拆分。","like_count":1},{"had_liked":false,"id":161927,"user_name":"Varus","can_delete":false,"product_type":"c1","uid":1715988,"ip_address":"","ucode":"B9CB88C248BD93","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/14/840d0925.jpg","comment_is_top":false,"comment_ctime":1576406672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871373968","product_id":100039001,"comment_content":"这个主要是看是不是会有高并发的考虑，如果有的话，这种设计就非常有必要了，可以避免拿到错误的数据，没有的话，就可以继续细分一点","like_count":1},{"had_liked":false,"id":161477,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1576214004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871181300","product_id":100039001,"comment_content":"1.我主观认为都符合。<br><br>1.从名命来看，这个方法要做两件事，事实上它也只做了这两件事。所以这个方法的实现满足这个方法抽象的功能范围，耦合单一职责原则。<br><br>2.从使用方来看，返回数值并递增是这类原子类的常规使用场景（longaddr没这方法，蛋疼）。所以对于使用方而言，这个方法包含的两个功能都是其所需要的，所以它也满足接口隔离原则。","like_count":1},{"had_liked":false,"id":161393,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1576201124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871168420","product_id":100039001,"comment_content":"老师提到三种接口的情况可以这样理解:<br>1. 接口定义前设计原则(理解成OOP中语法接口或未定义的函数):尽量单一，细粒度！<br><br>2.接口定义后设计原则(理解成粗粒度的一组集合或函数):已有接口按需(调用者或者新功能)拆分或单独定义接口！","like_count":1},{"had_liked":false,"id":360631,"user_name":"Null","can_delete":false,"product_type":"c1","uid":1382587,"ip_address":"北京","ucode":"A7D4DF2A43C7D8","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/bb/9299fab1.jpg","comment_is_top":false,"comment_ctime":1666700104,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666700104","product_id":100039001,"comment_content":"接口隔离原则跟单一职责原则有点类似，这块的解释感觉有点牵强了。其实接口隔离隔离原则要不放弃对于单个接口的约束，因为单一职责管的挺好，没必要插一杠子。如果接口隔离非要管单一接口或者函数的事儿，那也就是接口的设计上希望是“职责单一”，之余其他的我觉得可以等同，没必要为了区分概念非要区分。","like_count":0},{"had_liked":false,"id":360630,"user_name":"Null","can_delete":false,"product_type":"c1","uid":1382587,"ip_address":"北京","ucode":"A7D4DF2A43C7D8","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/bb/9299fab1.jpg","comment_is_top":false,"comment_ctime":1666699820,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666699820","product_id":100039001,"comment_content":"为啥我觉得第一和第三种情况，没啥区别。","like_count":0},{"had_liked":false,"id":359718,"user_name":"MinsonLee","can_delete":false,"product_type":"c1","uid":1427500,"ip_address":"广东","ucode":"49D6D346AB3448","user_header":"","comment_is_top":false,"comment_ctime":1665801632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665801632","product_id":100039001,"comment_content":"是否可以理解为：符合接口隔离原则的类“接口”，其一定是符合“单一职责原则”的呢？","like_count":0},{"had_liked":false,"id":353844,"user_name":"陈志男","can_delete":false,"product_type":"c1","uid":2695483,"ip_address":"广东","ucode":"4831554F6AC2C7","user_header":"https://static001.geekbang.org/account/avatar/00/29/21/3b/7f01e158.jpg","comment_is_top":false,"comment_ctime":1659859473,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659859473","product_id":100039001,"comment_content":"场景为多线程，所以有些东西需要绑定在一起，分开操作返回的值就不是原子性了，而是被高并发改得面目全非","like_count":0},{"had_liked":false,"id":352574,"user_name":"Geek_1","can_delete":false,"product_type":"c1","uid":2704407,"ip_address":"","ucode":"59300A73996D20","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/17/e4fdcaad.jpg","comment_is_top":false,"comment_ctime":1658767432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658767432","product_id":100039001,"comment_content":"可以一个实现对应多个接口，这样可以实现接口隔离","like_count":0},{"had_liked":false,"id":351338,"user_name":"英雄","can_delete":false,"product_type":"c1","uid":1546612,"ip_address":"","ucode":"D1033C83C6CDE9","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/74/0203bf17.jpg","comment_is_top":false,"comment_ctime":1657708138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657708138","product_id":100039001,"comment_content":"看来花钱的东西是不一样，每一节课都能很好的理解，解开我多年的困惑“设计模式没鸟用”","like_count":0},{"had_liked":false,"id":349859,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1656387749,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656387749","product_id":100039001,"comment_content":"应该是符合的，它这个是原子新增，获取和新增是一个原子事务","like_count":0},{"had_liked":false,"id":343366,"user_name":"恬毅","can_delete":false,"product_type":"c1","uid":1015240,"ip_address":"","ucode":"914ED16F3BE714","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg","comment_is_top":false,"comment_ctime":1650800726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650800726","product_id":100039001,"comment_content":"如果抛开原子性的问题，是不符合单一职责和接口隔离原则的。因为有get和increment两个操作。<br>但是因为要实现原子性，所以就符合这个单一职责和接口隔离原则了","like_count":0},{"had_liked":false,"id":341273,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1649492815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649492815","product_id":100039001,"comment_content":"1.隔离，就是针对业务调用方来做的。<br>2.单一职责为了以后更容易重构，类、接口、模块的设计。<br>3.其实简单一句话，好用。","like_count":0},{"had_liked":false,"id":338603,"user_name":"意","can_delete":false,"product_type":"c1","uid":1129311,"ip_address":"","ucode":"A4B0C03248EA77","user_header":"https://static001.geekbang.org/account/avatar/00/11/3b/5f/a2c78423.jpg","comment_is_top":false,"comment_ctime":1647591885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647591885","product_id":100039001,"comment_content":"如果我们自己通过CAS（compareAndSet）编写incrementAndGet()，它大概长这样：<br><br>public int incrementAndGet(AtomicInteger var) {<br>    int prev, next;<br>    do {<br>        prev = var.get();<br>        next = prev + 1;<br>    } while ( ! var.compareAndSet(prev, next));<br>    return next;<br>}<br><br>CAS是底层保证原子性的。<br>一个CAS操作的过程可以用以下c代码表示: <br>int cas(long *addr, long old, long new)<br>{<br>    &#47;* Executes atomically. *&#47;<br>    if(*addr != old)<br>        return 0;<br>    *addr = new;<br>    return 1;<br>}<br><br>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。<br>1、循环时间长开销很大。<br>2、只能保证一个共享变量的原子操作。<br>3、ABA问题","like_count":0,"discussions":[{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393699,"discussion_content":"这样不行，假设有个迭代器在还在遍历，此时某个元素被删除了，这个元素对这个迭代器还是可见的，因为deltimestamp>snapshottimestamp","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631548998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330986,"user_name":"cheng_yc","can_delete":false,"product_type":"c1","uid":2856263,"ip_address":"","ucode":"6DE872A6AEC42E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqFjqX19XHS5npsnSrrxibLQU9b0zMb3AzmdribYdEOFrXCyh7dJRF8g8MUibWfbMM8K7fA46AZib75SQ/132","comment_is_top":false,"comment_ctime":1642340993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642340993","product_id":100039001,"comment_content":"其实这个看以怎样的维度去解释这个东西。<br>1.如果按照ISP定义来说，getAndIncrement是包含了两个操作，获取之前的值和对之前的值+1，不符合接口隔离原则，应该拆分为更细粒度的两个接口。<br>2.如果按照这个接口当时设计的实用意义来书，就是为了将两部操作使用cas保证了原子性。那就是合理的。跟上面讲的计算那个接口道理是一样的。<br>当然这个接口都是操作Integer类，满足单一职责原则","like_count":0},{"had_liked":false,"id":323688,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1638095582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638095582","product_id":100039001,"comment_content":"思考题：<br>getAndIncrement这是一个原子操作，也就是说它所包含的功能是不可分割的，或者全部执行，或者全部不做，从原子的不可分割性看，是符合单一职责原则的，但如果从其返回的结果看，会产生两种不同的结果，因此又是违返了接口隔离原则。","like_count":0},{"had_liked":false,"id":322678,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637548220,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637548220","product_id":100039001,"comment_content":"从名称上看是两个操作。操作上看，是原子加1，需要把获得加一捏在一起来看。","like_count":0},{"had_liked":false,"id":317518,"user_name":"Bacchus","can_delete":false,"product_type":"c1","uid":1830814,"ip_address":"","ucode":"A8AA7E4909B201","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ef/9e/fd29bdd8.jpg","comment_is_top":false,"comment_ctime":1634821842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634821842","product_id":100039001,"comment_content":"简单的来说<br>不满足单一职责原则，因为的确做了两件事<br>满足接口隔离原则，因为底层功能的确是一个，也没有依赖其他功能","like_count":0},{"had_liked":false,"id":315993,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1634096781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634096781","product_id":100039001,"comment_content":"单一职责是一个类或模块只完成一个职责or功能。getAndIncrement提供了或者oldValue和oldValue+1两个功能，不符合单一职责；但是职责理解比较模糊，如果理解它的职责就是+1并返回oldValue也是可以的。<br>接口隔离原则强调的是使用方不需要依赖冗余的功能，因此，从使用方的角度来看，应该是符合接口隔离职责的。","like_count":0},{"had_liked":false,"id":313331,"user_name":"我是曾经那个少年","can_delete":false,"product_type":"c1","uid":1015189,"ip_address":"","ucode":"9F02F7FF147D14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","comment_is_top":false,"comment_ctime":1632380588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632380588","product_id":100039001,"comment_content":"getAndIncrement 符合接口隔离原则，设计要看场景。获取增加后的值，在正式场景他的确是需要和存在的。<br><br>包括文中的例子统计功能，在报表查询真实业务情况下，他可能是正确的，原因很简单就是统计要查DB，有IO操作，可能在底层一次就查询出来了。","like_count":0},{"had_liked":false,"id":312822,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1632039745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632039745","product_id":100039001,"comment_content":"单一职责原则指的是模块，类，接口设计的功能单一，接口隔离原则主要针对的是对于客户端来说的，调用的这个接口功能粒度单一，方便扩展和维护","like_count":0},{"had_liked":false,"id":308939,"user_name":"征","can_delete":false,"product_type":"c1","uid":1592863,"ip_address":"","ucode":"A1B11446D28836","user_header":"https://static001.geekbang.org/account/avatar/00/18/4e/1f/c6fd287e.jpg","comment_is_top":false,"comment_ctime":1629866527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629866527","product_id":100039001,"comment_content":"根据模块应有的能力来提供接口，面对不同的调用者，由调用者在提供的能力列表中挑选或接口组合来满足其需要，实际项目中也没有太多的排期，给调用者定制化接口。所以提供者按照能力职责，适度的提供接口与函数。","like_count":0},{"had_liked":false,"id":303607,"user_name":"米豆丸","can_delete":false,"product_type":"c1","uid":2042568,"ip_address":"","ucode":"CE99FE3A1EBCAF","user_header":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","comment_is_top":false,"comment_ctime":1626872240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626872240","product_id":100039001,"comment_content":"接口隔离--&gt;供给平衡 多给不想要，按需提供","like_count":0},{"had_liked":false,"id":300954,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1625466365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625466365","product_id":100039001,"comment_content":"从定义来看的话，对于普通类Integer来说get和increment是两个操作，但对于AtomicInteger来说get和increment的组合是一个原子操作，也就是说getAndIncrement是从”指责“上来说是单一的，从”接口隔离“的方法功能来说也是满足隔离原则的。","like_count":0},{"had_liked":false,"id":299534,"user_name":"HSC胡舒程","can_delete":false,"product_type":"c1","uid":1941115,"ip_address":"","ucode":"77D81890F5E66B","user_header":"","comment_is_top":false,"comment_ctime":1624696915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624696915","product_id":100039001,"comment_content":"接口隔离原则就是要从用户使用的角度去考虑，尽量少的提供用户不需要的接口。对于不同用户的需要，提供相应的接口。","like_count":0},{"had_liked":false,"id":299090,"user_name":"Geek_e8b99d","can_delete":false,"product_type":"c1","uid":2391812,"ip_address":"","ucode":"DFD4F7916552E3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLReSm1spFQpHLU6Gw4LWpewDSPAk6FnR8Qw2mb1WE68KsPXCMsgGDrNwIicib30hjf6GV9hwjibQHOQ/132","comment_is_top":false,"comment_ctime":1624454416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624454416","product_id":100039001,"comment_content":"public static void main(String[] args) { ScheduledUpdater redisConfigUpdater = new ScheduledUpdater(redisConfig, 300, 300); redisConfigUpdater.run(); ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60); redisConfigUpdater.run(); SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389); simpleHttpServer.addViewer(&quot;&#47;config&quot;, redisConfig); simpleHttpServer.addViewer(&quot;&#47;config&quot;, mysqlConfig); simpleHttpServer.run(); } <br><br><br>kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60); redisConfigUpdater.run();  <br>这是不写错了？","like_count":0},{"had_liked":false,"id":296965,"user_name":"zart","can_delete":false,"product_type":"c1","uid":1148637,"ip_address":"","ucode":"E32677C0FD4421","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eomCrCRrLAWib0gMI2L2NbicMummlxOY6nVmphsDO0J3xx7OygNd8wJicc88RbNoHrcuXBsKLtCMvgFQ/132","comment_is_top":false,"comment_ctime":1623242566,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623242566","product_id":100039001,"comment_content":"接口隔离原则：通过将函数、接口设计为应用场景的最小粒度，实现灵活、复用、向下兼容的目的","like_count":0},{"had_liked":false,"id":295465,"user_name":"GaGi","can_delete":false,"product_type":"c1","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1622440875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622440875","product_id":100039001,"comment_content":"首先对于单一职责原则来理解，本身getAndIncrement是类中的一个方法，不能作为单一职责原则来进行判断。<br>而接口隔离原则可以用来判断该方法，作为调用者来看，这个方法的职责是够单一的","like_count":0},{"had_liked":false,"id":291726,"user_name":"lobby","can_delete":false,"product_type":"c1","uid":1181960,"ip_address":"","ucode":"8D81722BE36AD4","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/08/f3547e77.jpg","comment_is_top":false,"comment_ctime":1620451264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620451264","product_id":100039001,"comment_content":"感觉与职责定义有关系，方法申明上就是取值并加1，个人认为是满足的。但是对于方法做什么事情上，还是要尽量划分比较细","like_count":0},{"had_liked":false,"id":290035,"user_name":"学员203","can_delete":false,"product_type":"c1","uid":2559640,"ip_address":"","ucode":"63E4B7E3A7E140","user_header":"","comment_is_top":false,"comment_ctime":1619332852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619332852","product_id":100039001,"comment_content":"有疑惑，第一种理解说接口可以理解成一组API集合，但分析时都是针对interface来说，而第三种理解也是说的interface，感觉很相近，区别不大的？","like_count":0},{"had_liked":false,"id":288148,"user_name":"EQLT","can_delete":false,"product_type":"c1","uid":1122933,"ip_address":"","ucode":"609C93F0DEF0BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/75/79693c63.jpg","comment_is_top":false,"comment_ctime":1618322388,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618322388","product_id":100039001,"comment_content":"不符合单一职责，但符合接口隔离原则，我理解是<br>不符合单一职责是其做了两件事情，而符合接口隔离原则，是因为函数已经声明了当前会做两件事情返回数以及递增值。","like_count":0},{"had_liked":false,"id":287757,"user_name":"沐风","can_delete":false,"product_type":"c1","uid":1463926,"ip_address":"","ucode":"6675574198ABCE","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/76/e8200041.jpg","comment_is_top":false,"comment_ctime":1618134772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618134772","product_id":100039001,"comment_content":"借口隔离应该是更加注重设计上的细粒度划分，隔离不相关的业务或者方法。","like_count":0},{"had_liked":false,"id":287167,"user_name":"_(:з」∠)_","can_delete":false,"product_type":"c1","uid":2418852,"ip_address":"","ucode":"EFEBB3F72C2EA5","user_header":"https://static001.geekbang.org/account/avatar/00/24/e8/a4/18b34a6f.jpg","comment_is_top":false,"comment_ctime":1617800978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617800978","product_id":100039001,"comment_content":"应该从类的使用场景来看, 这个类下的函数都是原子操作, i i++ ++i其中的操作含义是不同的<br>职责不同 接口也没有实现无用的部分","like_count":0},{"had_liked":false,"id":285550,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1616893554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616893554","product_id":100039001,"comment_content":"我认为是符合的，因为它本身就是对i++这个功能的封装","like_count":0},{"had_liked":false,"id":284770,"user_name":"前路漫漫","can_delete":false,"product_type":"c1","uid":1792623,"ip_address":"","ucode":"3D39485D761444","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5a/6f/62c03303.jpg","comment_is_top":false,"comment_ctime":1616465303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616465303","product_id":100039001,"comment_content":"大部分场景应该也不会隔离的特别彻底，比如对于一组接口来说 里面有函数 A、B、C  ，业务方甲依赖 AB，业务方乙依赖 BC ，难道要写三个接口？","like_count":0},{"had_liked":false,"id":283758,"user_name":"Graham","can_delete":false,"product_type":"c1","uid":1994570,"ip_address":"","ucode":"C2545DE16EC3DD","user_header":"","comment_is_top":false,"comment_ctime":1615907254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615907254","product_id":100039001,"comment_content":"getAndIncrement方法名本身包括 get 和increment，get对应其返回previous value，increment表示自增，<br>做的事情也符合自己的定义，挺好的的，个人感觉没有毛病","like_count":0},{"had_liked":false,"id":282834,"user_name":"小熊","can_delete":false,"product_type":"c1","uid":2373458,"ip_address":"","ucode":"7DDDC76895C1D1","user_header":"https://static001.geekbang.org/account/avatar/00/24/37/52/fdfe66a1.jpg","comment_is_top":false,"comment_ctime":1615432390,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1615432390","product_id":100039001,"comment_content":"ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60); redisConfigUpdater.run();<br>这段代码写错了 ， 应该是：<br>ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60);<br>kafkaConfigUpdater.run();","like_count":0,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366007,"discussion_content":"是的是的，马上修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617939702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280915,"user_name":"张小张","can_delete":false,"product_type":"c1","uid":1517195,"ip_address":"","ucode":"0DBEF42144BDC8","user_header":"https://static001.geekbang.org/account/avatar/00/17/26/8b/d5e27bd0.jpg","comment_is_top":false,"comment_ctime":1614481030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614481030","product_id":100039001,"comment_content":"我有个疑问，怎么感觉接口理解1和接口理解3是一模一样的呢，都是interface协议职责划分","like_count":0},{"had_liked":false,"id":276139,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1611808383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611808383","product_id":100039001,"comment_content":"单从代码含义上面看，此函数做了两个操作，自增和获取自增后的值，看起来是做了两件事情，但是从场景来看，是没有问题得，因为多线程的问题，可能存在并发的问题，导致失去了原子性，所以需要把操作封装起来成一个函数","like_count":0},{"had_liked":false,"id":272456,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1610093635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610093635","product_id":100039001,"comment_content":"接口，是一定定义好方法。","like_count":0},{"had_liked":false,"id":269521,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1608691041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608691041","product_id":100039001,"comment_content":"也就是说 interface 必须站在 client &#47; 调用者的角度来设计，不要设计那种大而全的 interface，大而全会导致里面有些member是调用者用不到的。<br><br>答题： 符合。","like_count":0},{"had_liked":false,"id":265248,"user_name":"Kingram","can_delete":false,"product_type":"c1","uid":2247700,"ip_address":"","ucode":"212E403E81F2FC","user_header":"https://static001.geekbang.org/account/avatar/00/22/4c/14/8fa39544.jpg","comment_is_top":false,"comment_ctime":1606826188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606826188","product_id":100039001,"comment_content":"思考题：<br>这个类不熟，我主要搞go语言。<br>如果这个工具包还有获取旧值和自增的函数，那这个设计就是符合单一职责和接口隔离原则的。因为对调用者来说，这个函数需要实现的就是自增且返回旧值。","like_count":0},{"had_liked":false,"id":256193,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603549009,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1603549009","product_id":100039001,"comment_content":"如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。","like_count":0},{"had_liked":false,"id":250775,"user_name":"lengrongfu","can_delete":false,"product_type":"c1","uid":1494681,"ip_address":"","ucode":"FD6F35CA561E0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/99/447c33d4.jpg","comment_is_top":false,"comment_ctime":1601216258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601216258","product_id":100039001,"comment_content":"课后问题：我认为是满足单一职责原则的，我记得里面应该还有一个incr的方法，是提供只进行增加不返回结果的，问题中的方法是为了给使用方提供一个返回自增之后的当前值方法。这是满足另一种使用场景的。","like_count":0},{"had_liked":false,"id":248923,"user_name":"邵俊达","can_delete":false,"product_type":"c1","uid":1281460,"ip_address":"","ucode":"4B7DACE6DBCF95","user_header":"https://static001.geekbang.org/account/avatar/00/13/8d/b4/ff82483d.jpg","comment_is_top":false,"comment_ctime":1600358806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600358806","product_id":100039001,"comment_content":"ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60); redisConfigUpdater.run();<br><br>kafkaConfigUpdater 的调用都写成了 redisConfigUpdater.run()","like_count":0},{"had_liked":false,"id":248161,"user_name":"LeoBing","can_delete":false,"product_type":"c1","uid":1068193,"ip_address":"","ucode":"3964DA5DBFBE46","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/a1/40b75a55.jpg","comment_is_top":false,"comment_ctime":1600046715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600046715","product_id":100039001,"comment_content":"先对「接口」进行不同的范围定义。<br><br>然后再解释说明「隔离原则」代表的意义。<br><br>三个例子相当于从抽象层---&gt;实现层---&gt;使用层不同角度说明隔离的意义。因为需要讲清楚「隔离」，所以每个例子都以「职能单一原则」作为基础，对比解释更清晰。","like_count":0},{"had_liked":false,"id":247918,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1599917271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599917271","product_id":100039001,"comment_content":"单一职责原则关注的是模块、类、接口的设计，而不是函数层面的设计；当然我们也可以这样说，让某个函数从实现功能上尽量单一，也算是符合单一职责原则。具体来看，getAndIncrement() 这个函数虽然实现了 get 与 increment 两个操作，但从用户使用角度看，是会有可能让这两个操作合并来保持原子性的需求的，所以算符合单一职责。<br><br>接口隔离原则表明，如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来。我们来看看 AtomicInteger 中有没有专门用于 get 与 increment 的操作。答案是有的，前者是 AtomicInteger#get()；后者，可以用 AtomicInteger#incrementAndGet() 实现。所以说，getAndIncrement() 并没有阻碍用户单独调用其中的部分接口，该函数也是符合接口隔离原则的。","like_count":0},{"had_liked":false,"id":247594,"user_name":"Harlan","can_delete":false,"product_type":"c1","uid":2134882,"ip_address":"","ucode":"F43595A0A00B19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erpYZalYvFGcBs7zZvYwaQAZwTLiaw0mycJ4PdYpP3VxAYkAtyIRHhjSOrOK0yESaPpgEbVQUwf6LA/132","comment_is_top":false,"comment_ctime":1599750631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599750631","product_id":100039001,"comment_content":"全文核心： 接口隔离原则提供了一种判断接口的职责是否单一的标准<br><br>getAndIncrement()是一个原子操作，职责单一，实际上不可拆分","like_count":0},{"had_liked":false,"id":247018,"user_name":"蜡笔小旧","can_delete":false,"product_type":"c1","uid":1858515,"ip_address":"","ucode":"F648476E70DCCB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUjcPst52CBsh2ibdzaUymrXibKY6Tl1ccYzBOlCicu7ZyuqPC82L1uWiblyVLB3XibwlAHTPZc44rxdA/132","comment_is_top":false,"comment_ctime":1599558451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599558451","product_id":100039001,"comment_content":"看使用场景吧，如果使用场景既需要给整数加一，又需要获取未增之前的值，就符合接口隔离原则；如果使用场景仅需要给整数加一，则不符合接口隔离远征。","like_count":0},{"had_liked":false,"id":246380,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599302434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599302434","product_id":100039001,"comment_content":"我认为符合接口隔离原则， 因为他很好的 区分了 increamentAndget使用区别，  但是我觉得对于单一职责这个点存在疑问，  我只关心原子的 increament 为啥还要多做一个get， 是不是功能上不太单一呢？","like_count":0},{"had_liked":false,"id":246208,"user_name":"北斗星","can_delete":false,"product_type":"c1","uid":1321503,"ip_address":"","ucode":"BF5D43D664F254","user_header":"https://static001.geekbang.org/account/avatar/00/14/2a/1f/0bb0fefb.jpg","comment_is_top":false,"comment_ctime":1599208620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599208620","product_id":100039001,"comment_content":"在把“接口”理解为一组 API 接口集合中，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只打包提供给后台管理系统来使用。<br>这样写后台管理系统又需要把用户的登录注册等功能重新实现一遍，造成代码的重复。这又该如何解决呢？","like_count":0},{"had_liked":false,"id":246030,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1599138548,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599138548","product_id":100039001,"comment_content":"有一个疑问，如果我作为服务提供方，我提供了10个接口，可能A只用了5个，B也用到了5个，这种从调用方来看接口隔离，是不是有问题呢？","like_count":0,"discussions":[{"author":{"id":1596532,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5c/74/3f9e7c14.jpg","nickname":"foreveryi","note":"","ucode":"C322C02C8D1CEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303853,"discussion_content":"暂时只用到了5个，并不代表剩下的将来不会被调用方用到。而老师举的“删除用户”的接口，是完全不对外调用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599396177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245966,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599122464,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599122464","product_id":100039001,"comment_content":"符合，从使用场景角度来看","like_count":0},{"had_liked":false,"id":245836,"user_name":"火影.海诺","can_delete":false,"product_type":"c1","uid":2091565,"ip_address":"","ucode":"34729AFEE93B6D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ea/2d/34cb8e0a.jpg","comment_is_top":false,"comment_ctime":1599091164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599091164","product_id":100039001,"comment_content":"功能单一原则和接口隔离原则的关系就像功与法的关系，法是可以指导功的运行的。","like_count":0},{"had_liked":false,"id":245792,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1599054875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599054875","product_id":100039001,"comment_content":"从单一职责上来看，这个接口本身是不符合单一职责的。它一共做了两件事情，一件事情是对当前值增加，第二件事情是返回增加之前的值。<br>从接口隔离原则上，这个符不符合要从调用者的视角来看，调用者是否需要返回未增加之前的值，如果不需要那么就不符合接口隔离，如果需要那么就符合。","like_count":0},{"had_liked":false,"id":244287,"user_name":"郑自明","can_delete":false,"product_type":"c1","uid":1903493,"ip_address":"","ucode":"D0FBED818FCCC8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0b/85/ac258512.jpg","comment_is_top":false,"comment_ctime":1598451276,"is_pvip":false,"replies":[{"id":"90135","content":"语法归语法，看你怎么用了，这个跟原则不冲突的。","user_name":"作者回复","comment_id":244287,"uid":"1190123","ip_address":"","utype":1,"ctime":1598833991,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1598451276","product_id":100039001,"comment_content":"Java8 Interface有default method 这样新加的method不需要所有相关类再实现了。但对这些类而言 不就违背了接口隔离原则么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504541,"discussion_content":"语法归语法，看你怎么用了，这个跟原则不冲突的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598833991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243075,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1597940146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597940146","product_id":100039001,"comment_content":"从单一职责的角度来考虑则符合，目的是为了得到并加1操作的原子性。<br>从接口隔离的角度来考虑则不符合，get和increment操作耦合到一起了。","like_count":0},{"had_liked":false,"id":242832,"user_name":"超越自我","can_delete":false,"product_type":"c1","uid":2130462,"ip_address":"","ucode":"8A55D972EEFADA","user_header":"https://static001.geekbang.org/account/avatar/00/20/82/1e/f3cb3d57.jpg","comment_is_top":false,"comment_ctime":1597850218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597850218","product_id":100039001,"comment_content":"单一职责（类，模块，接口等对象）上的拆分，接口隔离（接口对象）上的拆分。接口隔离可以说是具体的单一职责拆的表现形式，接口隔离是将（调用者使用场景，权限等因素）作为拆分依据。它们最终拆成更小粒度的单一职责对象。","like_count":0},{"had_liked":false,"id":240630,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1597021891,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597021891","product_id":100039001,"comment_content":"接口隔离原则 不应该对调用者暴露多余接口","like_count":0},{"had_liked":false,"id":233353,"user_name":"Geek_71cea9","can_delete":false,"product_type":"c1","uid":2058308,"ip_address":"","ucode":"DE88271BA527DD","user_header":"","comment_is_top":false,"comment_ctime":1594296179,"is_pvip":false,"replies":[{"id":"86247","content":"是的，我觉得应该不过过于大而全，但拆的过细也不好，你可以结合着门面模式看下","user_name":"作者回复","comment_id":233353,"uid":"1190123","ip_address":"","utype":1,"ctime":1594386128,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1594296179","product_id":100039001,"comment_content":"接口隔离原则，如果是从API接口角度，我觉得应该是从实现方来看，比如我实现某个接口，我只想实现这个接口的部分功能，其他功能用不上，那么就要考虑这个接口是否符合隔离原则，能否进行粒度拆分，这样也更灵活，针对函数来讲，应该就是从调用者的角度来看，比如我只想统计商品总量，而其他的统计结果，你不要给我，其实我们现在做的项目，都是前后端分离的，让前端调用，很多时候，我们项目中，会有一个很大的用户接口，包括一大堆信息，但是实际上前端只想获取用户的姓名或则手机号。但是你却给我了一大堆，后端也是为了图方便，只写一个接口，反正所有用户的信息全部塞到里面，那从这个角度，是不是也不符合接口隔离原则呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500991,"discussion_content":"是的，我觉得应该不过过于大而全，但拆的过细也不好，你可以结合着门面模式看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594386128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232903,"user_name":"Java垒墙工程师","can_delete":false,"product_type":"c1","uid":1937062,"ip_address":"","ucode":"E76AE44A9C76AE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","comment_is_top":false,"comment_ctime":1594166174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594166174","product_id":100039001,"comment_content":"接口隔离原则的标准是调用者需求，如果存在调用者同时需要函数全部功能，那么这样的方法存在就是满足接口隔离原则的，至于职责单一就不满足了，显然不单一","like_count":0},{"had_liked":false,"id":226043,"user_name":"pythonista","can_delete":false,"product_type":"c1","uid":1493954,"ip_address":"","ucode":"CE117439281B93","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/c2/abd584db.jpg","comment_is_top":false,"comment_ctime":1591934421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591934421","product_id":100039001,"comment_content":"符合单一职责  给使用者提供单一有用的原子操作 ","like_count":0},{"had_liked":false,"id":224188,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591315174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591315174","product_id":100039001,"comment_content":"IDE中查找变量(对象、接口)的”定义”(唯一)、查找变量的引用(多个)、查找接口的实现(多个)。怎么找到组装点呢？就是查找有抽象入参的引用，扩展点要引用这个函数注入实现！用的最多的是查找定义和查找函数的引用，找到谁依赖了自己，也就找到了功能的入口点!","like_count":0},{"had_liked":false,"id":224094,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591274173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591274173","product_id":100039001,"comment_content":"分层后的三层职责要分明，<br>controller：要处理鉴权、反序列化、数据校验：VO对象转为BO对象、数据序列化、错误信息。<br>service：业务逻辑加工组装、组合使用多个repo完成业务逻辑，不要把业务逻辑传递到repo层，保证repo只负责对象数据的持久化和数据的查询返回对象数据，所有业务逻辑都在service层完成。<br>repository：接收entity对象数据持久化到数据库，接受查询条件返回entity对象。repo层要屏蔽数据库设计的不合理干扰，在本层消化，比如冗余字段的补充、数据库字段名称、表字段划分不合理，做为数据的防腐层。<br>本层消化本层的难题，不要向外传递，保证层次之间掉调用关系优雅和易用。<br>“不变业务代码“依赖“可变的抽象“，抽象有多个实现，通过component层实例化对象组装依赖，“不变业务代码”不能直接实例化抽象的的实现，要通过函数形参传入。<br>","like_count":0},{"had_liked":false,"id":218303,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589774655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589774655","product_id":100039001,"comment_content":"我觉得还是符合的，单一原则 不是说步骤单一，而是操作是一个原子。","like_count":0},{"had_liked":false,"id":216988,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1589381458,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1589381458","product_id":100039001,"comment_content":"通过调用者如何使用接口来间接地判定，既符合单一职责原则、也接口隔离原则。很明显这个方法是对get方法的一个扩展，调用者有这个需求","like_count":0},{"had_liked":false,"id":215598,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589028565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589028565","product_id":100039001,"comment_content":"通过接口隔离类的功能：一个class实现多个interface，调用者依赖的是接口，看不到与自己无关的函数。可以根据功能规划类，不破坏类的功能完整性，用接口隔离复杂性，使用者只能看自己用到的功能，不用的功能看不到，这也是隔离的含义。，","like_count":0},{"had_liked":false,"id":203027,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1586103731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586103731","product_id":100039001,"comment_content":"我觉得是符合单一设计原则和接口隔离原则的。因为这个操作就相当于i++操作，是一个基本的操作，而且从接口隔离的角度上讲，功能也是隔离的，不会做无用功，所以说职责单一，接口隔离。","like_count":0},{"had_liked":false,"id":202706,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586055605,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586055605","product_id":100039001,"comment_content":"接口隔离原则提高了代码的可拓展性与可维护性。在平时的开发过程中，虽然偶尔会遵从某些原则，但是都是在无意识的情况下使用的。学习了这个章节，有了一个感叹：写好代码是一件事，写好一份高质量代码是另外一件事。以前，我一直觉得自己写的是代码，现在看来，不知道以前写的都是啥，哈哈哈哈😂。","like_count":0},{"had_liked":false,"id":202117,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1585904609,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585904609","product_id":100039001,"comment_content":"我认为这个需要分场景。<br>如果调用者清楚的知道需要获取并增加的操作，getAndIncrement() 作为一个原子动作来说是符合单一职责的，他只做一件事，就是函数名字的描述。<br>也是符合接口隔离原则的。调用者需要使用函数中的所有功能，而不是部分功能。<br>如果调用者只需要增加或是只需要获取，那么对于这个函数来说就都不符合了。就不应该调用这个函数","like_count":0},{"had_liked":false,"id":197949,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585404791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585404791","product_id":100039001,"comment_content":"这个原则确实挺抽象的。","like_count":0},{"had_liked":false,"id":196438,"user_name":"晓双","can_delete":false,"product_type":"c1","uid":1476696,"ip_address":"","ucode":"59CA9DB77697D5","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/58/3e19586a.jpg","comment_is_top":false,"comment_ctime":1585281133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585281133","product_id":100039001,"comment_content":"我认为是符合单一职责的，方法描述Atomically increments by one the current value.已经说得很清楚，这个方法就是原子增加一个值。","like_count":0},{"had_liked":false,"id":196100,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1585235571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585235571","product_id":100039001,"comment_content":"课后习题，符合单一职责和接口隔离原则。<br>单一职责：i++操作<br>接口隔离原则：只提供多线程下的整数原子操作。","like_count":0},{"had_liked":false,"id":195541,"user_name":"灯盖","can_delete":false,"product_type":"c1","uid":1482839,"ip_address":"","ucode":"0F8455A593D60C","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","comment_is_top":false,"comment_ctime":1585194939,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585194939","product_id":100039001,"comment_content":"接口隔离原则的第一种理解和迪米特法则是不是也有点想通之处呢？<br>一组API接口集合，根据接口隔离原则，会分为Interface1和Interface2。接口隔离原则强调，实现类可以实现其中一个接口或者实现所有接口。<br>不同的实现类就可以只实现自己需要的接口，做到接口隔离。<br><br>迪米特，结合基于接口而不是实现的规则，假设实现类C实现了Interface1和Interface2<br>那么C使用的时候可以<br>Interface1 * iter = new C();<br>这样就不会访问到Interface2接口中的内容<br>Interface2 * iter = new C();<br>这样就不会访问到Interface1接口中的内容<br><br>这样就实现了迪米特。<br><br>不知道这样理解对不对，请老师指正~","like_count":0},{"had_liked":false,"id":194137,"user_name":"黑客时间","can_delete":false,"product_type":"c1","uid":1831324,"ip_address":"","ucode":"7E22D76EECAC4D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f1/9c/cd12361d.jpg","comment_is_top":false,"comment_ctime":1585029605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585029605","product_id":100039001,"comment_content":"个人认为，符合单一职责<br>1.单一职责不意味着同时只能支持get或者increment，而是要完成一个功能。我在实际应用场景中就是要取值并且自增，那么这个方法刚好符合我的要求，它可以完成一个功能，那么认为就是符合单一职责<br>2.但我不确定是否符合隔离原则","like_count":0},{"had_liked":false,"id":193712,"user_name":"成活","can_delete":false,"product_type":"c1","uid":1734795,"ip_address":"","ucode":"F8840EE4DC3969","user_header":"https://static001.geekbang.org/account/avatar/00/1a/78/8b/421cb2c4.jpg","comment_is_top":false,"comment_ctime":1584952416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584952416","product_id":100039001,"comment_content":"个人认为原则的中文是不是应该翻译成“客户端不应该被强迫依赖”更好些","like_count":0},{"had_liked":false,"id":189757,"user_name":"Sun","can_delete":false,"product_type":"c1","uid":1196339,"ip_address":"","ucode":"1BC2741DC07FC5","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/33/d1064f9a.jpg","comment_is_top":false,"comment_ctime":1584546370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584546370","product_id":100039001,"comment_content":"实属牛逼，争哥的讲课思路太厉害了","like_count":0},{"had_liked":false,"id":188876,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1122284,"ip_address":"","ucode":"92BD46245FB5B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/ec/d611ce6c.jpg","comment_is_top":false,"comment_ctime":1584429442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584429442","product_id":100039001,"comment_content":"总结<br>1.什么是接口隔离原则<br>接口隔离原则是客户端不应该强迫它依赖不需要的接口内容<br>例如<br>如果是一组接口集合，那么就不应该依赖完全不需要的接口，<br>一个接口，但是其中的一些函数只在部分功能中使用，那么也是不符合的，应该把这个接口拆分成不同的接口<br>一函数中，有些功能是不需要的，那么也应该拆分成不同的函数<br>","like_count":0},{"had_liked":false,"id":188868,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1122284,"ip_address":"","ucode":"92BD46245FB5B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/ec/d611ce6c.jpg","comment_is_top":false,"comment_ctime":1584428416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584428416","product_id":100039001,"comment_content":"从场景来说，是符合接口隔离原则，接口隔离原则的意思是客户端不应该强迫依赖它不需要的接口，getAndIncrement()实现的增加，返回旧值，所以是符合的","like_count":0},{"had_liked":false,"id":188091,"user_name":"三年过后","can_delete":false,"product_type":"c1","uid":1283157,"ip_address":"","ucode":"5E9106C5F11BED","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/55/afc64956.jpg","comment_is_top":false,"comment_ctime":1584321026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584321026","product_id":100039001,"comment_content":"答疑：从功能上来说，getAndIncrement 好像干了两件事，调用C库将主内存值+1，并返回旧的值。仔细想，我主要就做+1操作，顺道返回主内存旧值。提高函数接口的灵活性。也是符合接口隔离原则的。个人拙见。","like_count":0},{"had_liked":false,"id":186166,"user_name":"路人甲","can_delete":false,"product_type":"c1","uid":1480119,"ip_address":"","ucode":"B720984454AFAF","user_header":"https://static001.geekbang.org/account/avatar/00/16/95/b7/15e157ec.jpg","comment_is_top":false,"comment_ctime":1583768484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583768484","product_id":100039001,"comment_content":"设计的非常灵活，赞","like_count":0},{"had_liked":false,"id":184762,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1583397199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583397199","product_id":100039001,"comment_content":"接口不要做无用功，比如1.A接口是先根据id查到用户，然后再查钱包有多少钱  有一个需求只是查用户，没必要查钱包，这样就多查浪费资源。<br>同理，2.如果你接口强制要求传个钱包id，我还要在调用A接口之前先弄到钱包id，耦合性一下子就高了<br>单一职责原则就是类似上面的1，做了无用功<br><br>接口隔离就是类似上面的2，依赖大<br><br>java.util.concurrent 并发包提供了 AtomicInteger 这样一个原子类，其中有一个函数 getAndIncrement() 是这样定义的：给整数增加一，并且返回未増之前的值。我的问题是，这个函数的设计是否符合单一职责原则和接口隔离原则？<br>答案是显而易见的，因为这是java自己设计的。。。<br>从单1上说：这个接口只是单纯的给这个值加1，所以符合<br>从接口隔离上来说：调用这个接口只要传一个相关的参数，所以符合。<br>当然incrementandget 和 getandincrement 区别。一个是先返回再加入参的值+1，另一个是先加1再返回入参。<br><br>看了下源码。。。其实他是通过unsafe.getAndAddInt(this, valueOffset, 1)通过反射根据字段偏移去修改对象。。。因为是原子操作，，，，没有return 参数的值。。。而是知道了结果，，，，incrementandget直接把参数的值+1.。。。","like_count":0},{"had_liked":false,"id":182388,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1582778089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582778089","product_id":100039001,"comment_content":"个人认为符合接口隔离原则。因为接口隔离和方法功能的复杂度其实没有必然的联系，没有规定说接口隔离就只能实现一个功能，getAndIncrement 这个方法的功能就是自增和返回旧值两个功能，方法的命名也非常清晰。再比如 BeanFactory#getBean 方法查找时其实会先从缓存中查找，如果查找不到会先实例化这个 Bean，而实例化 Bean 过程其实非常复杂，你能说 getBean 方法违反了接口隔离原则吗？","like_count":0},{"had_liked":false,"id":181675,"user_name":"junmawang","can_delete":false,"product_type":"c1","uid":1763466,"ip_address":"","ucode":"977E9E25CE6C94","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/8a/803a42e0.jpg","comment_is_top":false,"comment_ctime":1582613338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582613338","product_id":100039001,"comment_content":"1.接口隔离的定义<br>一组 API 接口集合。可以是某个微服务的接口，也可以是某个类库的接口，如果接口只被部分调用者使用，则这部分接口应该隔离出来。<br>自理解：如果A接口中的6个方法，有4个方法被A1用户，另外2个方法被B1用户调用，则该接口需要拆分成两个，也就是所谓的隔离。<br>单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数。<br>自理解：如果A函数中有1，2，3，4个逻辑，A1用户只需要1，2相关逻辑，B1用户只需要3，4相关逻辑，则需要将函数拆分。<br>OOP 中的接口概念，接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。<br><br>2.接口隔离原则与单一职责原则的区别<br>单一职责原则针对的是模块、类、接口的设计。<br>接口隔离原则更侧重于接口的设计，它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。<br><br>课堂讨论：<br>AtomicInteger为原子类，方法中的所有操作应该都是原子操作，AtomicInteger中的getAndIncrement()类似于i++，incrementAndGet()类似于++i，<br>如果做拆分两个操作需要用同步方式才能保证线程安全，所以该方法也符合单一职责原则和接口隔离原则。","like_count":0},{"had_liked":false,"id":181207,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582517622,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582517622","product_id":100039001,"comment_content":"针对这个问题,我的理解是,对于单一职责原则和接口隔离原则,是看一个方法的功能是否单一,能不能再继续拆分为粒度更小的接口,而这个方法,其粒度已经足够小了,而且其内部是使用CAS指令来进行替换的,对于CPU来说,是一个没法再拆分的原子操作,而且AtomicInteger内部也提供了get()和set()方法,也针对不同场景提供了incrementAndGet()等方法,方法多而不杂,都是对CAS指令的封装,足够应对多种场景下的使用,我认为是可以的","like_count":0},{"had_liked":false,"id":180888,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582435920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582435920","product_id":100039001,"comment_content":"这篇文章的分析，真是精彩。","like_count":0},{"had_liked":false,"id":180886,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582435879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582435879","product_id":100039001,"comment_content":"从单一职责的原则上看，get、increment 是两个不一样的操作，微观上看是不符合 单一职责 的设计原则的；<br>之所以这么设计，是因为这个类是一个线程安全地类，业务上就非常需要这个功能，所以它在宏观上分析是符合 单一职责 原则的。<br><br>从接口隔离上看，这个函数仍然符合原子类在业务上的设计，不存在&quot;依赖不必要接口&quot;的问题，所以也是符合接口隔离的。","like_count":0},{"had_liked":false,"id":178569,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1581747636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581747636","product_id":100039001,"comment_content":"老师，我觉得接口隔离原则重在隔离二字，单一只是辅助功能","like_count":0},{"had_liked":false,"id":177523,"user_name":"巨龙的力量啊","can_delete":false,"product_type":"c1","uid":1684858,"ip_address":"","ucode":"8FC6978929E48F","user_header":"https://static001.geekbang.org/account/avatar/00/19/b5/7a/a126c48f.jpg","comment_is_top":false,"comment_ctime":1581410240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581410240","product_id":100039001,"comment_content":"接口小粒度划分的同时，也要结合实际情况；接口功能是否隔离，可以看使用方的调用情况，是否都用到该接口的所有功能，如果只用到部分，就说明，接口在当前情况下设计是不合理的，不便于拓展。","like_count":0},{"had_liked":false,"id":177164,"user_name":"空空","can_delete":false,"product_type":"c1","uid":1444122,"ip_address":"","ucode":"8F6EFE5A6F6F64","user_header":"https://static001.geekbang.org/account/avatar/00/16/09/1a/e0f95684.jpg","comment_is_top":false,"comment_ctime":1581307520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581307520","product_id":100039001,"comment_content":"单一职责原则，侧重于针对某个特定接口，要满足功能的独立性和唯一性；<br>接口隔离原则，则强调接口与接口(方法与方法)之间的关系，要满足功能上的相互隔离，<br>","like_count":0},{"had_liked":false,"id":176815,"user_name":"谷雨","can_delete":false,"product_type":"c1","uid":1225827,"ip_address":"","ucode":"E8566AD0E2A521","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkkZBpiaOo4dGUuOXnRusBwcYCcwPTU8Pn41zbKh9py4Nwcf1rtc8A6yH5AtVVbkv8iaoS6hFgKevg/132","comment_is_top":false,"comment_ctime":1581173265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581173265","product_id":100039001,"comment_content":"单一职责和接口隔离的区别，我的理解：<br><br>单一职责，是划分域，这部分属于 A，另一部分属于 B。而接口隔离，更侧重不要“给调用者冗余的”，而冗余的本质，其实还是同一域。<br><br>所以，单一职责，是域与域，而接口隔离，是域内。","like_count":0},{"had_liked":false,"id":176595,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1581095105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581095105","product_id":100039001,"comment_content":"我反复思考了很久，觉得第一种接口的例子没有违背接口隔离原则。同样的api组，对delete鉴权了，就不违背，不鉴权就违背了？请老师打醒我。","like_count":0},{"had_liked":false,"id":174799,"user_name":"流星","can_delete":false,"product_type":"c1","uid":1114926,"ip_address":"","ucode":"94BACF37AD4953","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/2e/3a7b0eda.jpg","comment_is_top":false,"comment_ctime":1580391529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580391529","product_id":100039001,"comment_content":"是否单一原则得看划分的力度，如果力度更细，其实可以划分为两个方法，接口隔离是隔离的，只提供了一个单一的功能","like_count":0},{"had_liked":false,"id":171754,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1579007033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579007033","product_id":100039001,"comment_content":"老师, 我想起之前你讲DDD的时候, 在reposity前面有一个Bo, 按照这个原则, 我是不是每个根据不同的service写不同的bo, 但是如果这样, bo那些属性必定相同, 还是这里有区别","like_count":0},{"had_liked":false,"id":171181,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1578878188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578878188","product_id":100039001,"comment_content":"从并发的角度：原子性的完成递增并返回原来的结果，满足并发场景的需求，是符合单一原则的。<br>从纯理论分析角度：get 和 incr绑定 负责两个逻辑操作不符合单一原则要求。<br><br>从争哥上述的观点【单一原则】和【隔离原则】判断相对主观且受到使用场景影响，而getAndIncrement满足的特殊场景的要求，且AtomicInteger中有其他的方法满足要求，所以设计方面也是合理的。<br>","like_count":0},{"had_liked":false,"id":170504,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1578622588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578622588","product_id":100039001,"comment_content":"1. 是不是可以简单地理解为两者所关注的范范围不一样：单一职责原则的范围比较大包括模块、类和接口；而接口隔离原则只涉及接口（虽然这个接口的概念包括微服务意义上的接口、函数等）<br>2. 课后习题：如果从这个方法的职责上来说的话，应该符合接口隔离原则","like_count":0},{"had_liked":false,"id":169801,"user_name":"京京beaver","can_delete":false,"product_type":"c1","uid":1179056,"ip_address":"","ucode":"C21838D7CA7D6B","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/b0/e30fd916.jpg","comment_is_top":false,"comment_ctime":1578448120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578448120","product_id":100039001,"comment_content":"getAndIncrement符合单一职责原则和接口隔离原则,这个接口要解决的问题是，在并发情况下原子的获取最新值并加一。这个操作强调原子性，是不可分割的操作，所以符合SRP。这个操作除了获取，加锁，写入，解锁外没有其他额外的操作，没有引入不相关功能，所以符合ISP。","like_count":0},{"had_liked":false,"id":168763,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1578152177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578152177","product_id":100039001,"comment_content":"查看了AtomicInteger类，发现有get、set、getAndIncrement、getAndDecrement 、addAndGet 等等，我猜想可能++,--,以及加一个数这种情况用的比较多吧，所以写在了AtomicInteger类里面。<br><br>我认为符合单一职责和接口隔离原则的。<br>","like_count":0},{"had_liked":false,"id":167345,"user_name":"blackpiglet","can_delete":false,"product_type":"c1","uid":1032928,"ip_address":"","ucode":"58AA8329C91767","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c2/e0/7188aa0a.jpg","comment_is_top":false,"comment_ctime":1577772635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577772635","product_id":100039001,"comment_content":"这个问题的答案比较依赖主观的视角，比较难统一，个人看法是两个都符合：<br>单一职责原则：查值并自增是 atmoicInteger 的常见操作，虽然是两种更细粒度的操作的集合，放在一起作为一个功能也说得过去。<br>接口隔离原则：是否符合的唯一标准就是有没有人调用，只要有人觉得调这个调用比先调用查询再调用自增更方便，那就有必要。","like_count":0},{"had_liked":false,"id":166800,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1577600757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577600757","product_id":100039001,"comment_content":"接口的三个理解处理起来是一致的，就是不要依赖于用不着的功能，用不着的部分可能是整个接口，或者是接口的一个函数，或者是接口函数的部分功能。","like_count":0},{"had_liked":false,"id":165453,"user_name":"Arthur.Li","can_delete":false,"product_type":"c1","uid":1005824,"ip_address":"","ucode":"EC2436A5136C13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/00/6d14972a.jpg","comment_is_top":false,"comment_ctime":1577239577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577239577","product_id":100039001,"comment_content":"感觉单一职责原则是对模块、类、方法等功能的设计，强调模块、类、方法等的功能上单一，不要做过多的事。接口隔离更偏向“接口”，从调用者角度看事情，调用者要A，你不能也带有B<br><br>函数 getAndIncrement() 给整数增加一，并且返回未増之前的值是否符合单一和接口隔离原则？<br><br>我认为是都符合的。<br>1.单一职责原则： 因为函数功能即使从小颗粒度看也是职责单一的，只做了给数加一的功能，且返回值也是单一的。<br>2. 接口隔离原则：对于调用者来说，函数功能对整数加一并没有带来不想要的功能接口","like_count":0},{"had_liked":false,"id":164736,"user_name":"半截木头","can_delete":false,"product_type":"c1","uid":1296712,"ip_address":"","ucode":"72456E8E1BD6F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/c9/48/5a2879e3.jpg","comment_is_top":false,"comment_ctime":1577084396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577084396","product_id":100039001,"comment_content":"<br>&#47;**<br> * Atomically increments by one the current value.<br> * @return the previous value<br> *&#47;<br>public final int getAndIncrement() {&#47;&#47;...}<br>通常意思上来讲，get是一个操作，increment是另一个操作，所有一般来说是不满足ISP和SRP的。<br>但是具体到并发的应用场景上来，我们需要get和increment是原子操作的，所以在这个场景下，它是<br>满足ISP和SRP的。","like_count":0},{"had_liked":false,"id":164732,"user_name":"半截木头","can_delete":false,"product_type":"c1","uid":1296712,"ip_address":"","ucode":"72456E8E1BD6F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/c9/48/5a2879e3.jpg","comment_is_top":false,"comment_ctime":1577083456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577083456","product_id":100039001,"comment_content":"通过设计合理的接口，隔离掉对用户来说不必要的依赖。","like_count":0},{"had_liked":false,"id":164505,"user_name":"番茄炒西红柿","can_delete":false,"product_type":"c1","uid":1690242,"ip_address":"","ucode":"13F47BABAB2110","user_header":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","comment_is_top":false,"comment_ctime":1577013412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577013412","product_id":100039001,"comment_content":"后台问题我认为都符合，srp将的是一类对应一功能，atomicInteger对应是integer的原子类，自增是integer的原子操作所以符合一类对应一功能。<br>isp我认为也符合，从第二条函数的设计要单一来看，该方法就是自增返回原来值的方法，只实现了单一的功能故符合","like_count":0},{"had_liked":false,"id":164245,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1576915145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576915145","product_id":100039001,"comment_content":"关于第三个案例，不同功能用不同接口来支持，以实现更好的通用性和复用性。第二种实现方式我认为很常见，甚至更常见。老师说的是两个功能，倘若是5个功能，比如再增加上接口stop. Delete. Add. 那岂不是需要再增加3个接口，然后再修改已有代码，来支持这些特性？要是再增加其他功能又要全部修改。对此我并不是说老师的说法不好，我想说的是，根据实际场景，适当引入抽象类，来区分不同的组合有时候更适合一点。","like_count":0},{"had_liked":false,"id":164104,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1672483,"ip_address":"","ucode":"6BB1F4A5976158","user_header":"https://static001.geekbang.org/account/avatar/00/19/85/23/1c40a86e.jpg","comment_is_top":false,"comment_ctime":1576872895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576872895","product_id":100039001,"comment_content":"个人理解：getAndIncrement<br>从接口隔离原则看，包括 get 和 加1两个操作，不满足接口隔离原则。<br>从功能上看，它保证了加1并返回之前的值的原子操作，是满足接口隔离原则。","like_count":0},{"had_liked":false,"id":163896,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1576821287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576821287","product_id":100039001,"comment_content":"接口隔离原则：根据业务需求将大的接口划分为多个小的接口，怎么分，分多小，则看业务情况，最好满足你心中的接口单一职责原则。","like_count":0},{"had_liked":false,"id":163217,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1576672087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576672087","product_id":100039001,"comment_content":"打卡<br>1、接口的三个理解：<br>1）一组接口的集合，一个微服务的接口或是一个类的接口<br>如果一个接口集合中，部分调用者只使用了接口集合中的部分接口，就需要对这部分接口隔离出来，不强迫其他调用者也依赖这部分不被调用的接口。<br>2）单个API接口或是函数<br>如果部分调用者只使用了接口中的部分功能，就需要把函数功能拆分为更小的颗粒的函数，让调用者只依赖与他所需要的粒度的那个函数<br>3）OOP中的接口<br>接口的功能设计要单一，不要让接口的实现类和调用者，依赖不需要的接口函数。<br>2、接口隔离原则和单一职责原则的区别<br>单一职责原则考虑的是功能模块、类和接口的设计功能要单一。接口隔离原则注重于接口的设计，也从另一个角度去考虑问题，从调用者如何使用接口来判断接口的职责是否单一。如果调用者只使用部分接口或是接口的部分功能，那接口的设计就不够单一，需要把接口拆分为更小的颗粒度。","like_count":0},{"had_liked":false,"id":163212,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1576671171,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576671171","product_id":100039001,"comment_content":"接口的隔离也有点类似领域的划分 从行为上进行隔离 让调用方不多看见不应该看见的行为","like_count":0},{"had_liked":false,"id":163014,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1576640139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576640139","product_id":100039001,"comment_content":" AtomicInteger中的getAndIncrement满足单一职责，理由：这个方法只负责完成一个职责。因为在多线程环境下，要确保变量线程安全，获取值与值增加1属于同一个职责。而对于接口隔离原则而言，不应该强迫客户端依赖它不需要的接口。其中根据第二个单个API的而言，函数功能应该单一，所以不满足接口隔离原则","like_count":0},{"had_liked":false,"id":162876,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1576627926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576627926","product_id":100039001,"comment_content":"接口隔离原则关注的对象更多是接口，而且角度不同，从调用者的角度看接口是否符合单一职责原则。问题里的方法我认为不是接口隔离的，他将返回和增加耦合到一起了，没法复用","like_count":0},{"had_liked":false,"id":162814,"user_name":"|･ω･｀)","can_delete":false,"product_type":"c1","uid":1636123,"ip_address":"","ucode":"34E1DF62058D80","user_header":"https://static001.geekbang.org/account/avatar/00/18/f7/1b/8036958c.jpg","comment_is_top":false,"comment_ctime":1576594079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576594079","product_id":100039001,"comment_content":"我认为不符合单一职责原则<br>符合接口隔离原则<br>因为对使用方来说，他没有改变原来的数值<br>而对类本身来说，他做了两件事","like_count":0},{"had_liked":false,"id":162217,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1004755,"ip_address":"","ucode":"9BB9A170023CD8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/d3/46fd4aa3.jpg","comment_is_top":false,"comment_ctime":1576479276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576479276","product_id":100039001,"comment_content":"Go推荐使用单一接口，同时Go支持接口组合语法:<br><br>```go<br>type Reader interface {<br>\tread()<br>}<br><br>type Writer interface {<br>\twrite()<br>}<br><br>type ReadWriter interface {<br>\tReader<br>\tWriter<br>}<br>```","like_count":0},{"had_liked":false,"id":162210,"user_name":"potato00fa","can_delete":false,"product_type":"c1","uid":1307080,"ip_address":"","ucode":"D179E68D87CC50","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/c8/8e6dc340.jpg","comment_is_top":false,"comment_ctime":1576477801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576477801","product_id":100039001,"comment_content":"这节课还是很有用的，我之前直到现在写的代码，在Java Service层面上，大多数都是一个Interface 对应一个Impl，然后在重新写一个Impl的时候，就遇到了问题，这个Impl并不需要Interface里的一些功能，但是一旦继承以后就必须去实现，着实让人恼火。关键是接口没有隔离单一，在上层的多态环境里被随意调用，引发了各种各样的bug，最后只能强制编码人员谨慎使用某些类。","like_count":0},{"had_liked":false,"id":162198,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1576475810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576475810","product_id":100039001,"comment_content":"打卡～<br>我觉得从单一职责是符合但，因为从命名来看，\u001b和它做的事情是符合的，它本质上只做了原子操作加一。<br>但从接口隔离上不符合，因为它强迫调用者必须在做原子操作的时候去获取它之前的值。","like_count":0},{"had_liked":false,"id":162146,"user_name":"十二差一点","can_delete":false,"product_type":"c1","uid":1212732,"ip_address":"","ucode":"76C07F9A641630","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/3c/a01a60f3.jpg","comment_is_top":false,"comment_ctime":1576466795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576466795","product_id":100039001,"comment_content":"oc的协议可以通过@optional，@required来决定要不要实现，swift的协议也可以通过extension实现部分协议使其变成可选。iOS在设计的时候，应该就没考虑这个接口隔离原则。那Java为什么不这样设计呢？让接口也能可选和必选？那上面的第二种设计也就方便维护了","like_count":0},{"had_liked":false,"id":162106,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1576462261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576462261","product_id":100039001,"comment_content":"作为一个中台，要对接非常多的上层服务。每个服务都独立开一个服务包，这样管理的包太多了。不单独开一个服务包又违背了接口隔离。怎么怎么办啊？","like_count":0},{"had_liked":false,"id":162034,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1576453959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576453959","product_id":100039001,"comment_content":"此原则为单一职责原则提供了一个参考标准，根据调用者必要的功能来划分职责的范围","like_count":0},{"had_liked":false,"id":162033,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1576453883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576453883","product_id":100039001,"comment_content":"只给你必要的，而不是你想要的(ノ๑`ȏ´๑)ノ︵⌨","like_count":0},{"had_liked":false,"id":161985,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1576425010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576425010","product_id":100039001,"comment_content":"突然想到 JAVA 中的集合类库中，某些子类的实现直接为抛出异常。回去查看了一眼父类果然是标记了对应的异常<br>","like_count":0},{"had_liked":false,"id":161942,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1576410334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576410334","product_id":100039001,"comment_content":"1 ： 满足单一职责原则：因为AtomicInteger的 getAndIncrement 设计初衷就是为了实现原子性的整形操作，参考Serialization 类<br>2 ：满足接口隔离原则： 如果只是为了获取值，调用方可以使用 AtomicInteger 的 get方法<br>","like_count":0},{"had_liked":false,"id":161896,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1576395363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576395363","product_id":100039001,"comment_content":"getAndIncrement() 方法是符合接口隔离原则的, 因为 Atomically increments by one the current value 它属于 ++i, 返回的是 the previous value.","like_count":0},{"had_liked":false,"id":161866,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1576384579,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576384579","product_id":100039001,"comment_content":"这个接口放在Java并发编程这个场景下，符合单一职责原则—就是为了实现某个数得自增，同时解决了并发情况下数据覆盖的问题。<br><br>这个接口从接口隔离的角度，不符合接口隔离原则，因为该接口实现了get和increment两个功能，但是有可能调用者只需要其中一个","like_count":0},{"had_liked":false,"id":161846,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1576377813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576377813","product_id":100039001,"comment_content":"从命名来看，它就是要实现get&amp;increment，功能明确，符合单一职责；从使用场景来看，如果你只是想get或increment，它就违背了接口分离，因为引入了不需要的功能；但是如果调用者本来就需要get&amp;increment，那么它是没有违背接口分离的；","like_count":0},{"had_liked":false,"id":161804,"user_name":"白彬","can_delete":false,"product_type":"c1","uid":1498026,"ip_address":"","ucode":"E661F39B5F5861","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI8cnlibjqkJaYe0PpicFpF1V3LtzXrfot0bGwK1aT2zQtmnhmdUDwMHwBU5YqFmU8ibh0zqfIicTHHcw/132","comment_is_top":false,"comment_ctime":1576334981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576334981","product_id":100039001,"comment_content":"从原子操作的功能需求上考虑需要一个原子的操作支持返回老值和对计数器加一的原子操作。这个api是符合单一职责和接口隔离原则的。<br>","like_count":0},{"had_liked":false,"id":161801,"user_name":"白彬","can_delete":false,"product_type":"c1","uid":1498026,"ip_address":"","ucode":"E661F39B5F5861","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI8cnlibjqkJaYe0PpicFpF1V3LtzXrfot0bGwK1aT2zQtmnhmdUDwMHwBU5YqFmU8ibh0zqfIicTHHcw/132","comment_is_top":false,"comment_ctime":1576334380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576334380","product_id":100039001,"comment_content":"我理解符合单一原则。符合接口隔离原则。<br>从功能上讲 返回老值对原有值加一就是一个原子变量的基本功能。<br>从接口隔离讲。本身一个函数不涉及多个接口组合，用户依赖其中一个不依赖另一个的问题。而且这个函数不涉及返回多个数据，用户依赖其中一个属性的问题，用户调用说明需要这个函数的全部功能。","like_count":0},{"had_liked":false,"id":161624,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1576252147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576252147","product_id":100039001,"comment_content":"我个人理解是两个都满足<br>理由如下（个人观点）：<br>1、除了文章中提到的getAndIncrement，它里面还有getAndDecrement、incrementAndGet、decrementAndGet等这这种方法，操作的核心目的肯定是在于对于变量的加减操作，返回的值就是加减前后的，单一职责的我感觉满足了，如果目的不是为了加减，那就直接调用个get方法就好<br>2、对于1中说到的4个方法，例如getAndIncrement，incrementAndGet同样是加1，一个返回加之前一个加后，对于使用者，假如我就是要加之前的，那么也是完全符合接口隔离原则的，如果就是increment了，肯定有人在调用的时候，需要要加之前或者加之后的，自己还要在get一次","like_count":0},{"had_liked":false,"id":161608,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1576247238,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576247238","product_id":100039001,"comment_content":"我觉得应该是并发包,直接操作内存,对于锁的机制比较严格,所以将读和写操作写在一起,方便锁的处理吧.猜测而已,主写前端,对并发和锁不太懂.","like_count":0},{"had_liked":false,"id":161603,"user_name":"　扬帆丶启航　","can_delete":false,"product_type":"c1","uid":1235282,"ip_address":"","ucode":"4079D0889CD86C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/52/73351eab.jpg","comment_is_top":false,"comment_ctime":1576244980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576244980","product_id":100039001,"comment_content":"个人认为是满足单一原则的，因为只做了整数加一的操作；但是不满足接口隔离原则，因为不仅实现了整数加一，还提供了返回加一前的整数，调用者可能只使用其中的一个功能。","like_count":0},{"had_liked":false,"id":161573,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1576236043,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576236043","product_id":100039001,"comment_content":"这种方法中既有逻辑（新增，修改和删除逻辑），又要返回不是操作结果的内容，的确有二意性，项目中为了减少宂余，确实有这样的场景。<br>个人认为把 方法的操作和返回值，在方法名称中清晰的体现出来，名称和实际实现一致。<br><br>回到老师的题目，getAndIncrement方法名称，体现了：<br>1.increment 自增<br>2.get 返回<br>同时有And说明是2个操作。","like_count":0,"discussions":[{"author":{"id":1113660,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","nickname":"Miaozhe","note":"","ucode":"62872E8C138B67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81261,"discussion_content":"从接口隔离原则的判别维度，调用者的角度，无多余的操作，因此是复合该原则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576236456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161506,"user_name":"小小代码","can_delete":false,"product_type":"c1","uid":1290642,"ip_address":"","ucode":"F3D4E2C23FC9BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/92/f3dabcb1.jpg","comment_is_top":false,"comment_ctime":1576218918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576218918","product_id":100039001,"comment_content":"我认为AtomicInteger的getAndIncrement()函数设计是符合单一职责原则和接口隔离原则的，从并发编程的角度讲，获取和加1是一个原子操作，这么设计应该是考虑到了多线程的问题，从粗粒度讲，它是单一职责的","like_count":0},{"had_liked":false,"id":161489,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1576217210,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576217210","product_id":100039001,"comment_content":"今天学习的晚了，反而有更好的发现。<br><br>看了一圈评论，发现老师问的这个问题，如果单纯从单个功能上看，还有不同的意见；但是如果结合类中的其他方法，大致就明白这个函数存在的意义了。<br><br>所以，原来结合上下文也是需要具备的能力之一。","like_count":0},{"had_liked":false,"id":161485,"user_name":"ismind","can_delete":false,"product_type":"c1","uid":1138710,"ip_address":"","ucode":"7AADD673ED3BC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/16/d1dd4972.jpg","comment_is_top":false,"comment_ctime":1576216142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576216142","product_id":100039001,"comment_content":"个人思考：<br>1，是否符合单一职责？答案：符合。单一职责是说一个类或者模块只负责完成一个职责，很明显，这个方法只做了一件事那就是自增，有人会说：还返回了之前的值呀，那我也可以不让它返回或者返回自增之后的值，返回值只是函数完成一件事之后顺带的。归根到底，只做了一件事，那就是自增。<br>2，是否符合接口隔离原则？一个个来分析<br>（1）理解为一组API接口，很显然，这里是一个函数。这个不用考虑，跳过。<br>（2）单个API接口或者函数，没错，出现了“函数”，那么展开分析。这里，又感觉和单一职责类似，这个函数的粒度已经很细了，很显然，调用者需要的是将值自增，那么这个函数自然是符合接口隔离原则。<br>（3）oop中的接口，函数不是oop的接口，跳过。<br>    可以发现，这个函数的功能比较单一，和单一职责原则类似，那么是不是可以认为函数符合了单一职责，自然符合接口隔离原则？<br>综上所述，二者都符合，可以发现的是，如果只符合单一不符合接口隔离，或者反之，这是说不过去的，单一是类似于接口隔离的。<br>以上是个人的拙见，如果有错误还请指正，因为看到众说纷纭，所以干脆自己也思考一下。<br>期待老师给出详细而清晰的解答。","like_count":0},{"had_liked":false,"id":161459,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1576209220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576209220","product_id":100039001,"comment_content":"还是要看具体情况。<br>只从单一原则上来讲，是不符合的，这里进行了一次get操作和一次累加操作，这是两个功能。<br>如果调用者就是需要这种功能，那么是符合接口隔离原则的，他们绑定在一起，不需要隔离。","like_count":0},{"had_liked":false,"id":161454,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1576208702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576208702","product_id":100039001,"comment_content":"1.接口从单个api的角度考虑等价于单一职责原则。<br>2.从oop的角度考虑，抽象出多而小的接口，从代码的简洁性，扩展性，可读性都变得更好。","like_count":0},{"had_liked":false,"id":161426,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1576203997,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576203997","product_id":100039001,"comment_content":"getAndIncrement可以知晓加1是基于那个基数，得知基数是要做其它判断使用的。<br>单纯的计数可以使用LongAdder或者LongAccumulator。","like_count":0},{"had_liked":false,"id":161425,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1576203903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576203903","product_id":100039001,"comment_content":"课堂讨论Question: AtomicInteger#getAndIncrement()是否违反ISP?<br><br>课堂讨论Answer:<br><br>首先说结论: 函数符合单一职责原则,但不符合接口隔离原则.<br><br>要回答这个问题,前提是了解AtomicInteger类是做什么的:<br>AtomicInteger是java.util.concurrent包下的类,主要应用在并发场景下:<br>一个可能原子性更新的int值.它的应用场景可以是计数器.<br><br>该函数的设计无疑是符合单一职责原则的, 它仅做一件事: 为值+1,返回未加一之前的值.由于在并发场景可能其他thread也在同时操作这个类,它的设计是make sense的.<br><br>但该函数未必符合接口隔离原则,因为一个计数器可能不需要这个函数,可能仅需要incrementAndGet().这也许会让调用者迷惑: 我到底要用哪一个接口,getAndIncrement(),还是incrementAndGet()?<br><br>","like_count":0},{"had_liked":false,"id":161392,"user_name":"WIZ","can_delete":false,"product_type":"c1","uid":1260348,"ip_address":"","ucode":"313AF84674475C","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/3c/2947127c.jpg","comment_is_top":false,"comment_ctime":1576201089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576201089","product_id":100039001,"comment_content":"有个疑问，对于第一种情况，一组api通过隔离之后可能就会产生一个第二种情况还可以继续再隔离，按照这种理解的话，那不是随便一组接口都得隔离成好多个接口了嘛？若这样操作，是否合理？","like_count":0},{"had_liked":false,"id":161391,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1576200986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576200986","product_id":100039001,"comment_content":"我觉得这个符合接口隔离原则，因为他可以想象成是一组api操作，虽然是两个方法，但是是高内聚的，不符合单一职责","like_count":0},{"had_liked":false,"id":161390,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1576200909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576200909","product_id":100039001,"comment_content":"不错的思想，还是挺实用的","like_count":0},{"had_liked":false,"id":161386,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1576200621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576200621","product_id":100039001,"comment_content":"单一原则针对模块、类、接口。接口隔离原则对接口设计更细致说明。","like_count":0},{"had_liked":false,"id":161372,"user_name":"Geek_e7834d","can_delete":false,"product_type":"c1","uid":1530493,"ip_address":"","ucode":"ABAF1B1B7E6490","user_header":"","comment_is_top":false,"comment_ctime":1576199107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576199107","product_id":100039001,"comment_content":"getAndIncrement() 从接口隔离的角度可能很多人不会用到， 只会用到自增的用法。 但是从单一职责来看，如果拆成两个函数， 就不是线程安全的， 需要额外的逻辑来调用。从这个角度来说， 放在AutoInteger里，也是合理的。","like_count":0},{"had_liked":false,"id":161371,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1576198864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576198864","product_id":100039001,"comment_content":"接口隔离原则是从调用者角度看的，调用者不需要依赖他不应该依赖的接口，单一职责原则是从设计的时候需要考虑的事情","like_count":0},{"had_liked":false,"id":161364,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1576198491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576198491","product_id":100039001,"comment_content":"我觉得符合接口隔离原则，和单一职业原则。并发包里面除了getAndIncrement还有一个incrementAndGet的方法。两个方法都是已原子方式将当前值加1。不同的是一个返回原值，一个返回的是加1后的值。说明设计者已经将接口拆分成了一个更加细粒度的接口。在实际并发操作中可以根据具体情况来调用不同的接口。不知道理解对不对。","like_count":0},{"had_liked":false,"id":161362,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1237655,"ip_address":"","ucode":"088A8DA0A16BDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","comment_is_top":false,"comment_ctime":1576198197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576198197","product_id":100039001,"comment_content":"打卡打卡","like_count":0},{"had_liked":false,"id":161353,"user_name":"yy","can_delete":false,"product_type":"c1","uid":1120074,"ip_address":"","ucode":"04D42CDE3F5BBA","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/4a/87a6f2dc.jpg","comment_is_top":false,"comment_ctime":1576197333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576197333","product_id":100039001,"comment_content":"有个疑问接口隔离原则跟功能内聚是否有矛盾，比如useService类的设计按内聚来讲应该是把删除用户也放同一个类中而不是分开。请老师指正","like_count":0},{"had_liked":false,"id":161352,"user_name":"yy","can_delete":false,"product_type":"c1","uid":1120074,"ip_address":"","ucode":"04D42CDE3F5BBA","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/4a/87a6f2dc.jpg","comment_is_top":false,"comment_ctime":1576197134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576197134","product_id":100039001,"comment_content":"单一职责原则应该是站在用户的角度去思考职责是否单一。getAndIcrement接口符合用户的单一需求。","like_count":0},{"had_liked":false,"id":161341,"user_name":"张飞online","can_delete":false,"product_type":"c1","uid":1249136,"ip_address":"","ucode":"C9787E4B35888C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","comment_is_top":false,"comment_ctime":1576196123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576196123","product_id":100039001,"comment_content":"不管那哪种接口，最终目的是为了提炼出需要实现的公共部分，但是现实是这个公共部分不一定真的公共，所以我们又要看公共部分的”公共覆盖度”来确定设计小借口还是大而全的接口。","like_count":0},{"had_liked":false,"id":161322,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1576193180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576193180","product_id":100039001,"comment_content":"接口隔离原则懂了，单一职责原则还是有点区分不好，是懂非懂，感觉接口隔离原则是判定职责是否单一，单独看职责可能是单一，必须对各种使用场景是否隔离才能判定这个接口职责是否单一。不知道理解的正确不？","like_count":0},{"had_liked":false,"id":161321,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1576193097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576193097","product_id":100039001,"comment_content":"思考题:<br>      我认为符合接口隔离职责不符合接口单一职责。因为这个函数包含两个功能（返回修改前的值、值加1），所以包含两个功能，不符合接口单一职责。而这两个功能是需要被同时使用到的，所以符合接口隔离原则！","like_count":0},{"had_liked":false,"id":161318,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576190661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576190661","product_id":100039001,"comment_content":"思考题<br>这个接口没问题，这里确实有两步，但是这两步在并发语境下是高内聚的。","like_count":0},{"had_liked":false,"id":161317,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576190515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576190515","product_id":100039001,"comment_content":"可以从三个角度看接口拆分：<br>接口集合的适当拆分,将一个接口集合按照功能拆分成不同接口集合。<br>单个复杂接口的拆分，将一个接口拆分成若干接口。<br>基于被实现者和被调用者的适当拆分，做到没有多余的dummy实现。","like_count":0},{"had_liked":false,"id":161312,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1576179522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576179522","product_id":100039001,"comment_content":"第一种理解和第三种理解的区别有点困惑，感觉第一种理解更侧重于使用者，第三种理解更侧重于代码开发？看起来都像是在说职责要单一","like_count":0}]}