{"id":212374,"title":"31 | 加餐1：带你吃透课程中Java 8的那些重要知识点（一）","content":"<p>你好，我是朱晔。</p><p>Java 8是目前最常用的JDK版本，在增强代码可读性、简化代码方面，相比Java 7增加了很多功能，比如Lambda、Stream流操作、并行流（ParallelStream）、Optional可空类型、新日期时间类型等。</p><p>这个课程中的所有案例，都充分使用了Java 8的各种特性来简化代码。这也就意味着，如果你不了解这些特性的话，理解课程内的Demo可能会有些困难。因此，我将这些特性，单独拎了出来组成了两篇加餐。由于后面有单独一节课去讲Java 8的日期时间类型，所以这里就不赘述了。</p><h2>如何在项目中用上Lambda表达式和Stream操作？</h2><p>Java 8的特性有很多，除了这两篇加餐外，我再给你推荐一本全面介绍Java 8的书，叫《Java实战（第二版）》。此外，有同学在留言区问，怎么把Lambda表达式和Stream操作运用到项目中。其实，业务代码中可以使用这些特性的地方有很多。</p><p>这里，为了帮助你学习，并把这些特性用到业务开发中，我有三个小建议。</p><p>第一，从List的操作开始，先尝试把遍历List来筛选数据和转换数据的操作，使用Stream的filter和map实现，这是Stream最常用、最基本的两个API。你可以重点看看接下来两节的内容来入门。</p><!-- [[[read_end]]] --><p>第二，使用高级的IDE来写代码，以此找到可以利用Java 8语言特性简化代码的地方。比如，对于IDEA，我们可以把匿名类型使用Lambda替换的检测规则，设置为Error级别严重程度：</p><p><img src=\"https://static001.geekbang.org/resource/image/67/77/6707ccf4415c2d8715ed2529cfdec877.png?wh=2098*1304\" alt=\"\"></p><p>这样运行IDEA的Inspect Code的功能，可以在Error级别的错误中看到这个问题，引起更多关注，帮助我们建立使用Lambda表达式的习惯：</p><p><img src=\"https://static001.geekbang.org/resource/image/50/e4/5062b3ef6ec57ccde0f3f4b182811be4.png?wh=3190*624\" alt=\"\"></p><p>第三，如果你不知道如何把匿名类转换为Lambda表达式，可以借助IDE来重构：</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/e7/5a55c4284e4b10f659b7bcf0129cbde7.png?wh=1536*396\" alt=\"\"></p><p>反过来，如果你在学习课程内案例时，如果感觉阅读Lambda表达式和Stream API比较吃力，同样可以借助IDE把Java 8的写法转换为使用循环的写法：</p><p><img src=\"https://static001.geekbang.org/resource/image/98/8a/98828a36d6bb7b7972a647b37a64f08a.png?wh=2330*602\" alt=\"\"></p><p>或者是把Lambda表达式替换为匿名类：</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/7c/ee9401683b19e57462cb2574c285d67c.png?wh=1996*340\" alt=\"\"></p><h2>Lambda表达式</h2><p>Lambda表达式的初衷是，进一步简化匿名类的语法（不过实现上，Lambda表达式并不是匿名类的语法糖），使Java走向函数式编程。对于匿名类，虽然没有类名，但还是要给出方法定义。这里有个例子，分别使用匿名类和Lambda表达式创建一个线程打印字符串：</p><pre><code>//匿名类\nnew Thread(new Runnable(){\n    @Override\n    public void run(){\n        System.out.println(&quot;hello1&quot;);\n    }\n}).start();\n//Lambda表达式\nnew Thread(() -&gt; System.out.println(&quot;hello2&quot;)).start();\n</code></pre><p>那么，Lambda表达式如何匹配Java的类型系统呢？</p><p>答案就是，函数式接口。</p><p>函数式接口是一种只有单一抽象方法的接口，使用@FunctionalInterface来描述，可以隐式地转换成 Lambda 表达式。使用Lambda表达式来实现函数式接口，不需要提供类名和方法定义，通过一行代码提供函数式接口的实例，就可以让函数成为程序中的头等公民，可以像普通数据一样作为参数传递，而不是作为一个固定的类中的固定方法。</p><p>那，函数式接口到底是什么样的呢？java.util.function包中定义了各种函数式接口。比如，用于提供数据的Supplier接口，就只有一个get抽象方法，没有任何入参、有一个返回值：</p><pre><code>@FunctionalInterface\npublic interface Supplier&lt;T&gt; {\n\n    /**\n     * Gets a result.\n     *\n     * @return a result\n     */\n    T get();\n}\n</code></pre><p>我们可以使用Lambda表达式或方法引用，来得到Supplier接口的实例：</p><pre><code>//使用Lambda表达式提供Supplier接口实现，返回OK字符串\nSupplier&lt;String&gt; stringSupplier = ()-&gt;&quot;OK&quot;;\n//使用方法引用提供Supplier接口实现，返回空字符串\nSupplier&lt;String&gt; supplier = String::new;\n</code></pre><p>这样，是不是很方便？为了帮你掌握函数式接口及其用法，我再举几个使用Lambda表达式或方法引用来构建函数的例子：</p><pre><code>//Predicate接口是输入一个参数，返回布尔值。我们通过and方法组合两个Predicate条件，判断是否值大于0并且是偶数\nPredicate&lt;Integer&gt; positiveNumber = i -&gt; i &gt; 0;\nPredicate&lt;Integer&gt; evenNumber = i -&gt; i % 2 == 0;\nassertTrue(positiveNumber.and(evenNumber).test(2));\n\n//Consumer接口是消费一个数据。我们通过andThen方法组合调用两个Consumer，输出两行abcdefg\nConsumer&lt;String&gt; println = System.out::println;\nprintln.andThen(println).accept(&quot;abcdefg&quot;);\n\n//Function接口是输入一个数据，计算后输出一个数据。我们先把字符串转换为大写，然后通过andThen组合另一个Function实现字符串拼接\nFunction&lt;String, String&gt; upperCase = String::toUpperCase;\nFunction&lt;String, String&gt; duplicate = s -&gt; s.concat(s);\nassertThat(upperCase.andThen(duplicate).apply(&quot;test&quot;), is(&quot;TESTTEST&quot;));\n\n//Supplier是提供一个数据的接口。这里我们实现获取一个随机数\nSupplier&lt;Integer&gt; random = ()-&gt;ThreadLocalRandom.current().nextInt();\nSystem.out.println(random.get());\n\n//BinaryOperator是输入两个同类型参数，输出一个同类型参数的接口。这里我们通过方法引用获得一个整数加法操作，通过Lambda表达式定义一个减法操作，然后依次调用\nBinaryOperator&lt;Integer&gt; add = Integer::sum;\nBinaryOperator&lt;Integer&gt; subtraction = (a, b) -&gt; a - b;\nassertThat(subtraction.apply(add.apply(1, 2), 3), is(0));\n</code></pre><p>Predicate、Function等函数式接口，还使用default关键字实现了几个默认方法。这样一来，它们既可以满足函数式接口只有一个抽象方法，又能为接口提供额外的功能：</p><pre><code>@FunctionalInterface\npublic interface Function&lt;T, R&gt; {\n    R apply(T t);\n    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {\n        Objects.requireNonNull(before);\n        return (V v) -&gt; apply(before.apply(v));\n    }\n    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {\n        Objects.requireNonNull(after);\n        return (T t) -&gt; after.apply(apply(t));\n    }\n}\n</code></pre><p>很明显，Lambda表达式给了我们复用代码的更多可能性：我们可以把一大段逻辑中变化的部分抽象出函数式接口，由外部方法提供函数实现，重用方法内的整体逻辑处理。</p><p>不过需要注意的是，在自定义函数式接口之前，可以先确认下<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html\">java.util.function包</a>中的43个标准函数式接口是否能满足需求，我们要尽可能重用这些接口，因为使用大家熟悉的标准接口可以提高代码的可读性。</p><h2>使用Java 8简化代码</h2><p>这一部分，我会通过几个具体的例子，带你感受一下使用Java 8简化代码的三个重要方面：</p><ul>\n<li>使用Stream简化集合操作；</li>\n<li>使用Optional简化判空逻辑；</li>\n<li>JDK8结合Lambda和Stream对各种类的增强。</li>\n</ul><h3>使用Stream简化集合操作</h3><p>Lambda表达式可以帮我们用简短的代码实现方法的定义，给了我们复用代码的更多可能性。利用这个特性，我们可以把集合的投影、转换、过滤等操作抽象成通用的接口，然后通过Lambda表达式传入其具体实现，这也就是Stream操作。</p><p>我们看一个具体的例子。这里有一段20行左右的代码，实现了如下的逻辑：</p><ul>\n<li>把整数列表转换为Point2D列表；</li>\n<li>遍历Point2D列表过滤出Y轴&gt;1的对象；</li>\n<li>计算Point2D点到原点的距离；</li>\n<li>累加所有计算出的距离，并计算距离的平均值。</li>\n</ul><pre><code>private static double calc(List&lt;Integer&gt; ints) {\n    //临时中间集合\n    List&lt;Point2D&gt; point2DList = new ArrayList&lt;&gt;();\n    for (Integer i : ints) {\n        point2DList.add(new Point2D.Double((double) i % 3, (double) i / 3));\n    }\n    //临时变量，纯粹是为了获得最后结果需要的中间变量\n    double total = 0;\n    int count = 0;\n\n    for (Point2D point2D : point2DList) {\n        //过滤\n        if (point2D.getY() &gt; 1) {\n            //算距离\n            double distance = point2D.distance(0, 0);\n            total += distance;\n            count++;\n        }\n    }\n    //注意count可能为0的可能\n    return count &gt;0 ? total / count : 0;\n}\n</code></pre><p>现在，我们可以使用Stream配合Lambda表达式来简化这段代码。简化后一行代码就可以实现这样的逻辑，更重要的是代码可读性更强了，通过方法名就可以知晓大概是在做什么事情。比如：</p><ul>\n<li>map方法传入的是一个Function，可以实现对象转换；</li>\n<li>filter方法传入一个Predicate，实现对象的布尔判断，只保留返回true的数据；</li>\n<li>mapToDouble用于把对象转换为double；</li>\n<li>通过average方法返回一个OptionalDouble，代表可能包含值也可能不包含值的可空double。</li>\n</ul><p>下面的第三行代码，就实现了上面方法的所有工作：</p><pre><code>List&lt;Integer&gt; ints = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);\ndouble average = calc(ints);\ndouble streamResult = ints.stream()\n        .map(i -&gt; new Point2D.Double((double) i % 3, (double) i / 3))\n        .filter(point -&gt; point.getY() &gt; 1)\n        .mapToDouble(point -&gt; point.distance(0, 0))\n        .average()\n        .orElse(0);\n//如何用一行代码来实现，比较一下可读性\nassertThat(average, is(streamResult));\n</code></pre><p>到这里，你可能会问了，OptionalDouble又是怎么回事儿？</p><h3>有关Optional可空类型</h3><p>其实，类似OptionalDouble、OptionalInt、OptionalLong等，是服务于基本类型的可空对象。此外，Java8还定义了用于引用类型的Optional类。使用Optional，不仅可以避免使用Stream进行级联调用的空指针问题；更重要的是，它提供了一些实用的方法帮我们避免判空逻辑。</p><p>如下是一些例子，演示了如何使用Optional来避免空指针，以及如何使用它的fluent API简化冗长的if-else判空逻辑：</p><pre><code>@Test(expected = IllegalArgumentException.class)\npublic void optional() {\n    //通过get方法获取Optional中的实际值\n    assertThat(Optional.of(1).get(), is(1));\n    //通过ofNullable来初始化一个null，通过orElse方法实现Optional中无数据的时候返回一个默认值\n    assertThat(Optional.ofNullable(null).orElse(&quot;A&quot;), is(&quot;A&quot;));\n    //OptionalDouble是基本类型double的Optional对象，isPresent判断有无数据\n    assertFalse(OptionalDouble.empty().isPresent());\n    //通过map方法可以对Optional对象进行级联转换，不会出现空指针，转换后还是一个Optional\n    assertThat(Optional.of(1).map(Math::incrementExact).get(), is(2));\n    //通过filter实现Optional中数据的过滤，得到一个Optional，然后级联使用orElse提供默认值\n    assertThat(Optional.of(1).filter(integer -&gt; integer % 2 == 0).orElse(null), is(nullValue()));\n    //通过orElseThrow实现无数据时抛出异常\n    Optional.empty().orElseThrow(IllegalArgumentException::new);\n}\n</code></pre><p>我把Optional类的常用方法整理成了一张图，你可以对照案例再复习一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/c8/52/c8a901bb16b9fca07ae0fc8bb222b252.jpg?wh=2772*2263\" alt=\"\"></p><h3>Java 8类对于函数式API的增强</h3><p>除了Stream之外，Java 8中有很多类也都实现了函数式的功能。</p><p>比如，要通过HashMap实现一个缓存的操作，在Java 8之前我们可能会写出这样的getProductAndCache方法：先判断缓存中是否有值；如果没有值，就从数据库搜索取值；最后，把数据加入缓存。</p><pre><code>private Map&lt;Long, Product&gt; cache = new ConcurrentHashMap&lt;&gt;();\n\nprivate Product getProductAndCache(Long id) {\n    Product product = null;\n    //Key存在，返回Value\n    if (cache.containsKey(id)) {\n        product = cache.get(id);\n    } else {\n        //不存在，则获取Value\n        //需要遍历数据源查询获得Product\n        for (Product p : Product.getData()) {\n            if (p.getId().equals(id)) {\n                product = p;\n                break;\n            }\n        }\n        //加入ConcurrentHashMap\n        if (product != null)\n            cache.put(id, product);\n    }\n    return product;\n}\n\n@Test\npublic void notcoolCache() {\n    getProductAndCache(1L);\n    getProductAndCache(100L);\n\n    System.out.println(cache);\n    assertThat(cache.size(), is(1));\n    assertTrue(cache.containsKey(1L));\n}\n</code></pre><p>而在Java 8中，我们利用ConcurrentHashMap的computeIfAbsent方法，用一行代码就可以实现这样的繁琐操作：</p><pre><code>private Product getProductAndCacheCool(Long id) {\n    return cache.computeIfAbsent(id, i -&gt; //当Key不存在的时候提供一个Function来代表根据Key获取Value的过程\n            Product.getData().stream()\n                    .filter(p -&gt; p.getId().equals(i)) //过滤\n                    .findFirst() //找第一个，得到Optional&lt;Product&gt;\n                    .orElse(null)); //如果找不到Product，则使用null\n}\n\n@Test\npublic void coolCache()\n{\n    getProductAndCacheCool(1L);\n    getProductAndCacheCool(100L);\n\n    System.out.println(cache);\n    assertThat(cache.size(), is(1));\n    assertTrue(cache.containsKey(1L));\n}\n</code></pre><p>computeIfAbsent方法在逻辑上相当于：</p><pre><code>if (map.get(key) == null) {\n\tV newValue = mappingFunction.apply(key);\n\tif (newValue != null)\n\t\tmap.put(key, newValue);\n}\n</code></pre><p>又比如，利用Files.walk返回一个Path的流，通过两行代码就能实现递归搜索+grep的操作。整个逻辑是：递归搜索文件夹，查找所有的.java文件；然后读取文件每一行内容，用正则表达式匹配public class关键字；最后输出文件名和这行内容。</p><pre><code>@Test\npublic void filesExample() throws IOException {\n    //无限深度，递归遍历文件夹\n    try (Stream&lt;Path&gt; pathStream = Files.walk(Paths.get(&quot;.&quot;))) {\n        pathStream.filter(Files::isRegularFile) //只查普通文件\n                .filter(FileSystems.getDefault().getPathMatcher(&quot;glob:**/*.java&quot;)::matches) //搜索java源码文件\n                .flatMap(ThrowingFunction.unchecked(path -&gt;\n                        Files.readAllLines(path).stream() //读取文件内容，转换为Stream&lt;List&gt;\n                        .filter(line -&gt; Pattern.compile(&quot;public class&quot;).matcher(line).find()) //使用正则过滤带有public class的行\n                        .map(line -&gt; path.getFileName() + &quot; &gt;&gt; &quot; + line))) //把这行文件内容转换为文件名+行\n                .forEach(System.out::println); //打印所有的行\n    }\n}\n</code></pre><p>输出结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/84/12/84349a90ef4aaf30032d0a8f64ab4512.png?wh=2238*748\" alt=\"\"></p><p>我再和你分享一个小技巧吧。因为Files.readAllLines方法会抛出一个受检异常（IOException），所以我使用了一个自定义的函数式接口，用ThrowingFunction包装这个方法，把受检异常转换为运行时异常，让代码更清晰：</p><pre><code>@FunctionalInterface\npublic interface ThrowingFunction&lt;T, R, E extends Throwable&gt; {\n    static &lt;T, R, E extends Throwable&gt; Function&lt;T, R&gt; unchecked(ThrowingFunction&lt;T, R, E&gt; f) {\n        return t -&gt; {\n            try {\n                return f.apply(t);\n            } catch (Throwable e) {\n                throw new RuntimeException(e);\n            }\n        };\n    }\n\n    R apply(T t) throws E;\n}\n</code></pre><p>如果用Java 7实现类似逻辑的话，大概需要几十行代码，你可以尝试下。</p><h2>并行流</h2><p>前面我们看到的Stream操作都是串行Stream，操作只是在一个线程中执行，此外Java 8还提供了并行流的功能：通过parallel方法，一键把Stream转换为并行操作提交到线程池处理。</p><p>比如，如下代码通过线程池来并行消费处理1到100：</p><pre><code>IntStream.rangeClosed(1,100).parallel().forEach(i-&gt;{\n    System.out.println(LocalDateTime.now() + &quot; : &quot; + i);\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) { }\n});\n</code></pre><p>并行流不确保执行顺序，并且因为每次处理耗时1秒，所以可以看到在8核机器上，数组是按照8个一组1秒输出一次：</p><p><img src=\"https://static001.geekbang.org/resource/image/f1/d6/f114d98aa2530c3f7e91b06aaa4ee1d6.png?wh=670*840\" alt=\"\"></p><p>在这个课程中，有很多类似使用threadCount个线程对某个方法总计执行taskCount次操作的案例，用于演示并发情况下的多线程问题或多线程处理性能。除了会用到并行流，我们有时也会使用线程池或直接使用线程进行类似操作。为了方便你对比各种实现，这里我一次性给出实现此类操作的五种方式。</p><p>为了测试这五种实现方式，我们设计一个场景：使用20个线程（threadCount）以并行方式总计执行10000次（taskCount）操作。因为单个任务单线程执行需要10毫秒（任务代码如下），也就是每秒吞吐量是100个操作，那20个线程QPS是2000，执行完10000次操作最少耗时5秒。</p><pre><code>private void increment(AtomicInteger atomicInteger) {\n    atomicInteger.incrementAndGet();\n    try {\n        TimeUnit.MILLISECONDS.sleep(10);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre><p>现在我们测试一下这五种方式，是否都可以利用更多的线程并行执行操作。</p><p>第一种方式是使用线程。直接把任务按照线程数均匀分割，分配到不同的线程执行，使用CountDownLatch来阻塞主线程，直到所有线程都完成操作。这种方式，需要我们自己分割任务：</p><pre><code>private int thread(int taskCount, int threadCount) throws InterruptedException {\n    //总操作次数计数器\n    AtomicInteger atomicInteger = new AtomicInteger();\n    //使用CountDownLatch来等待所有线程执行完成\n    CountDownLatch countDownLatch = new CountDownLatch(threadCount);\n    //使用IntStream把数字直接转为Thread\n    IntStream.rangeClosed(1, threadCount).mapToObj(i -&gt; new Thread(() -&gt; {\n        //手动把taskCount分成taskCount份，每一份有一个线程执行\n        IntStream.rangeClosed(1, taskCount / threadCount).forEach(j -&gt; increment(atomicInteger));\n        //每一个线程处理完成自己那部分数据之后，countDown一次\n        countDownLatch.countDown();\n    })).forEach(Thread::start);\n    //等到所有线程执行完成\n    countDownLatch.await();\n    //查询计数器当前值\n    return atomicInteger.get();\n}\n</code></pre><p>第二种方式是，使用Executors.newFixedThreadPool来获得固定线程数的线程池，使用execute提交所有任务到线程池执行，最后关闭线程池等待所有任务执行完成：</p><pre><code>private int threadpool(int taskCount, int threadCount) throws InterruptedException {\n    //总操作次数计数器\n    AtomicInteger atomicInteger = new AtomicInteger();\n    //初始化一个线程数量=threadCount的线程池\n    ExecutorService executorService = Executors.newFixedThreadPool(threadCount);\n    //所有任务直接提交到线程池处理\n    IntStream.rangeClosed(1, taskCount).forEach(i -&gt; executorService.execute(() -&gt; increment(atomicInteger)));\n    //提交关闭线程池申请，等待之前所有任务执行完成\n    executorService.shutdown();\n    executorService.awaitTermination(1, TimeUnit.HOURS);\n    //查询计数器当前值\n    return atomicInteger.get();\n}\n</code></pre><p>第三种方式是，使用ForkJoinPool而不是普通线程池执行任务。</p><p>ForkJoinPool和传统的ThreadPoolExecutor区别在于，前者对于n并行度有n个独立队列，后者是共享队列。如果有大量执行耗时比较短的任务，ThreadPoolExecutor的单队列就可能会成为瓶颈。这时，使用ForkJoinPool性能会更好。</p><p>因此，ForkJoinPool更适合大任务分割成许多小任务并行执行的场景，而ThreadPoolExecutor适合许多独立任务并发执行的场景。</p><p>在这里，我们先自定义一个具有指定并行数的ForkJoinPool，再通过这个ForkJoinPool并行执行操作：</p><pre><code>private int forkjoin(int taskCount, int threadCount) throws InterruptedException {\n    //总操作次数计数器\n    AtomicInteger atomicInteger = new AtomicInteger();\n    //自定义一个并行度=threadCount的ForkJoinPool\n    ForkJoinPool forkJoinPool = new ForkJoinPool(threadCount);\n    //所有任务直接提交到线程池处理\n    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, taskCount).parallel().forEach(i -&gt; increment(atomicInteger)));\n    //提交关闭线程池申请，等待之前所有任务执行完成\n    forkJoinPool.shutdown();\n    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n    //查询计数器当前值\n    return atomicInteger.get();\n}\n</code></pre><p>第四种方式是，直接使用并行流，并行流使用公共的ForkJoinPool，也就是ForkJoinPool.commonPool()。</p><p>公共的ForkJoinPool默认的并行度是CPU核心数-1，原因是对于CPU绑定的任务分配超过CPU个数的线程没有意义。由于并行流还会使用主线程执行任务，也会占用一个CPU核心，所以公共ForkJoinPool的并行度即使-1也能用满所有CPU核心。</p><p>这里，我们通过配置强制指定（增大）了并行数，但因为使用的是公共ForkJoinPool，所以可能会存在干扰，你可以回顾下<a href=\"https://time.geekbang.org/column/article/210337\">第3讲</a>有关线程池混用产生的问题：</p><pre><code>private int stream(int taskCount, int threadCount) {\n    //设置公共ForkJoinPool的并行度\nSystem.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, String.valueOf(threadCount));\n    //总操作次数计数器\n    AtomicInteger atomicInteger = new AtomicInteger();\n    //由于我们设置了公共ForkJoinPool的并行度，直接使用parallel提交任务即可\n    IntStream.rangeClosed(1, taskCount).parallel().forEach(i -&gt; increment(atomicInteger));\n    //查询计数器当前值\n    return atomicInteger.get();\n}\n</code></pre><p>第五种方式是，使用CompletableFuture来实现。CompletableFuture.runAsync方法可以指定一个线程池，一般会在使用CompletableFuture的时候用到：</p><pre><code>private int completableFuture(int taskCount, int threadCount) throws InterruptedException, ExecutionException {\n    //总操作次数计数器\n    AtomicInteger atomicInteger = new AtomicInteger();\n    //自定义一个并行度=threadCount的ForkJoinPool\n    ForkJoinPool forkJoinPool = new ForkJoinPool(threadCount);\n    //使用CompletableFuture.runAsync通过指定线程池异步执行任务\n    CompletableFuture.runAsync(() -&gt; IntStream.rangeClosed(1, taskCount).parallel().forEach(i -&gt; increment(atomicInteger)), forkJoinPool).get();\n    //查询计数器当前值\n    return atomicInteger.get();\n}\n</code></pre><p>上面这五种方法都可以实现类似的效果：</p><p><img src=\"https://static001.geekbang.org/resource/image/77/cc/77c42149013fd82c18d39b5e0d0292cc.png?wh=1048*402\" alt=\"\"></p><p>可以看到，这5种方式执行完10000个任务的耗时都在5.4秒到6秒之间。这里的结果只是证明并行度的设置是有效的，并不是性能比较。</p><p>如果你的程序对性能要求特别敏感，建议通过性能测试根据场景决定适合的模式。一般而言，使用线程池（第二种）和直接使用并行流（第四种）的方式在业务代码中比较常用。但需要注意的是，我们通常会重用线程池，而不会像Demo中那样在业务逻辑中直接声明新的线程池，等操作完成后再关闭。</p><p><strong>另外需要注意的是，在上面的例子中我们一定是先运行stream方法再运行forkjoin方法，对公共ForkJoinPool默认并行度的修改才能生效。</strong></p><p>这是因为ForkJoinPool类初始化公共线程池是在静态代码块里，加载类时就会进行的，如果forkjoin方法中先使用了ForkJoinPool，即便stream方法中设置了系统属性也不会起作用。因此我的建议是，设置ForkJoinPool公共线程池默认并行度的操作，应该放在应用启动时设置。</p><h2>重点回顾</h2><p>今天，我和你简单介绍了Java 8中最重要的几个功能，包括Lambda表达式、Stream流式操作、Optional可空对象、并行流操作。这些特性，可以帮助我们写出简单易懂、可读性更强的代码。特别是使用Stream的链式方法，可以用一行代码完成之前几十行代码的工作。</p><p>因为Stream的API非常多，使用方法也是千变万化，因此我会在下一讲和你详细介绍Stream API的一些使用细节。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>检查下代码中是否有使用匿名类，以及通过遍历List进行数据过滤、转换和聚合的代码，看看能否使用Lambda表达式和Stream来重新实现呢？</li>\n<li>对于并行流部分的并行消费处理1到100的例子，如果把forEach替换为forEachOrdered，你觉得会发生什么呢？</li>\n</ol><p>关于Java 8，你还有什么使用心得吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","comments":[{"had_liked":false,"id":188796,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":true,"comment_ctime":1584416607,"is_pvip":true,"replies":[{"id":"72822","content":"lambda与普通的匿名内部类的实现方式不一样，可以参考一些资料，比如https:&#47;&#47;colobu.com&#47;2014&#47;11&#47;06&#47;secrets-of-java-8-lambda&#47;<br>这篇总结的很好：<br><br>编译时：<br>- Lambda 表达式会生成一个方法， 方法实现了表达式的代码逻辑<br>- 生成invokedynamic指令， 调用bootstrap方法， 由java.lang.invoke.LambdaMetafactory.metafactory方法实现<br>运行时：<br>- invokedynamic指令调用metafactory方法。 它会返回一个CallSite, 此CallSite返回目标类型的一个匿名实现类， 此类关联编译时产生的方法<br>- lambda表达式调用时会调用匿名实现类关联的方法。<br><br>forEachOrdered会让整个遍历过程失去并行化的效能，可以参考代码中的ForEachOrderedTest","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584419542,"ip_address":"","comment_id":188796,"utype":1}],"discussion_count":3,"race_medal":0,"score":"9.2233721114535997e+18","product_id":100047701,"comment_content":"疑问：匿名内部类和Lambda到底有什么区别？为什么匿名内部类会生成$1这样的class文件而Lambda并没有？？？<br>回答下问题：<br>1.项目中现在基本都是在使用Lambda表达式，主要是因为使用的vert.x和RxJava2，响应式变成基本都是Lambda；<br>2.并行效果消失，和去掉parallel()的效果是一样的，因为forEachOrdered将按照其源指定的顺序处理流的元素，而不管流是连续的还是并行的。<br><br>JavaDoc：<br>forEach:The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism.<br>-------谷歌翻译------<br>此操作的行为明确地是不确定的。 对于并行流管道，此操作不能保证尊重流的遇到顺序，因为这样做会牺牲并行性的好处。 对于任何给定的元素，可以在库选择的任何时间和线程中执行操作。 如果操作访问共享状态，则它负责提供所需的同步。<br><br>forEachOrdered :Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order.<br>-------谷歌翻译-----<br>如果流具有定义的遇到顺序，则按流的遇到顺序对此流的每个元素执行操作。","like_count":18,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487531,"discussion_content":"lambda与普通的匿名内部类的实现方式不一样，可以参考一些资料，比如https://colobu.com/2014/11/06/secrets-of-java-8-lambda/\n这篇总结的很好：\n\n编译时：\n- Lambda 表达式会生成一个方法， 方法实现了表达式的代码逻辑\n- 生成invokedynamic指令， 调用bootstrap方法， 由java.lang.invoke.LambdaMetafactory.metafactory方法实现\n运行时：\n- invokedynamic指令调用metafactory方法。 它会返回一个CallSite, 此CallSite返回目标类型的一个匿名实现类， 此类关联编译时产生的方法\n- lambda表达式调用时会调用匿名实现类关联的方法。\n\nforEachOrdered会让整个遍历过程失去并行化的效能，可以参考代码中的ForEachOrderedTest","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584419542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206671,"discussion_content":"把老师的链接和看了一些东西，整理了下，感兴趣的童鞋可以看看，大家多多交流\nhttps://github.com/y645194203/geektime-java-100/blob/master/TestLambda.java","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584426273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103456,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","nickname":"jacy","note":"","ucode":"0022A8759DDCE6","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551014,"discussion_content":"匿名内部类会生成$1这样的class文件而Lambda并没有。是否可以这么理解，匿名内部类是在编译时生成class文件，而Lambda是在运行行生成。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644849416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189495,"user_name":"小阳","can_delete":false,"product_type":"c1","uid":1296135,"ip_address":"","ucode":"97A162992E6A81","user_header":"https://static001.geekbang.org/account/avatar/00/13/c7/07/5798c17e.jpg","comment_is_top":true,"comment_ctime":1584522299,"is_pvip":false,"replies":[{"id":"73022","content":"看一下ForkJoinTask.fork()方法你就明白为什么能使用到自定义的ForkJoinPool了：<br><br>public final ForkJoinTask&lt;V&gt; fork() {<br>        Thread t;<br>        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)<br>            ((ForkJoinWorkerThread)t).workQueue.push(this);<br>        else<br>            ForkJoinPool.common.externalPush(this);<br>        return this;<br>    }","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584523201,"ip_address":"","comment_id":189495,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720727990006e+18","product_id":100047701,"comment_content":"疑问： 代码3 的执行代码 ，forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, taskCount).parallel().forEach(i -&gt; increment(atomicInteger))); 我的理解是 通过自定义的forkJoinPool来将并行任务提交到公共的forkJoinPool去执行，因为 paraller().forEach()执行过程中并没提供像代码5那样设置用户的forkJoinPool，您说是在自定义的forkJoinPool执行increment（atomicInteger）的，这是为什么呢？ ","like_count":9,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487710,"discussion_content":"看一下ForkJoinTask.fork()方法你就明白为什么能使用到自定义的ForkJoinPool了：\n\npublic final ForkJoinTask&amp;lt;V&amp;gt; fork() {\n        Thread t;\n        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n            ((ForkJoinWorkerThread)t).workQueue.push(this);\n        else\n            ForkJoinPool.common.externalPush(this);\n        return this;\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584523201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188723,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":true,"comment_ctime":1584408694,"is_pvip":false,"replies":[{"id":"72804","content":"<br>forEachOrdered 会让parallelStream丧失部分的并行能力，主要是forEach的逻辑无法并行起来，比较：<br><br> private void stream() {<br>        IntStream.rangeClosed(1, 10).filter(ForEachOrderedTest::filter).forEach(ForEachOrderedTest::consume);<br>    }<br><br>    private void parallelStream() {<br>        IntStream.rangeClosed(1, 10).parallel()<br>                .filter(ForEachOrderedTest::filter)<br>                .forEach(ForEachOrderedTest::consume);<br>    }<br><br>    private void parallelStreamForEachOrdered() {<br>        IntStream.rangeClosed(1, 10).parallel()<br>                .filter(ForEachOrderedTest::filter)<br>                .forEachOrdered(ForEachOrderedTest::consume);<br>    }","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584412841,"ip_address":"","comment_id":188723,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720470291005e+18","product_id":100047701,"comment_content":"检查下代码中是否有使用匿名类，以及通过遍历 List 进行数据过滤、转换和聚合的代码，看看能否使用 Lambda 表达式和 Stream 来重新实现呢？<br>已经使用lambda，stream快一年了，匿名类，基本就通过idea的自动处理，自己使用的基本上就：forEach，filter，map，这些。<br><br><br>对于并行流部分的并行消费处理 1 到 100 的例子，如果把 forEach 替换为 forEachOrdered，你觉得会发生什么呢？<br>个人猜测是会被有序化地多线程执行，四核CPU，1234 等一秒5678 这样。<br>但是，实际上，并发能力被直接移除。1等一秒，2等一秒，3......这样。不严谨的猜测，forEachOrdered 将本来的打印加上了类似于synchronized的效果。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487498,"discussion_content":"\nforEachOrdered 会让parallelStream丧失部分的并行能力，主要是forEach的逻辑无法并行起来，比较：\n\n private void stream() {\n        IntStream.rangeClosed(1, 10).filter(ForEachOrderedTest::filter).forEach(ForEachOrderedTest::consume);\n    }\n\n    private void parallelStream() {\n        IntStream.rangeClosed(1, 10).parallel()\n                .filter(ForEachOrderedTest::filter)\n                .forEach(ForEachOrderedTest::consume);\n    }\n\n    private void parallelStreamForEachOrdered() {\n        IntStream.rangeClosed(1, 10).parallel()\n                .filter(ForEachOrderedTest::filter)\n                .forEachOrdered(ForEachOrderedTest::consume);\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584412841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189417,"user_name":"退而结网","can_delete":false,"product_type":"c1","uid":1126394,"ip_address":"","ucode":"48C99264CC3A5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/2f/fa/191049df.jpg","comment_is_top":false,"comment_ctime":1584513722,"is_pvip":false,"replies":[{"id":"73015","content":"后续加餐干货同样很多","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584514006,"ip_address":"","comment_id":189417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"66009023162","product_id":100047701,"comment_content":"这个课程未免也太划算了，这个加餐囊括了好多其他的内容，物超所值，为老师点赞！打call","like_count":16,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487692,"discussion_content":"后续加餐干货同样很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584514006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188991,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1584442819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57419017667","product_id":100047701,"comment_content":"感觉老师是不是可以考虑加餐下泛型，简单的没啥问题，一大堆的那种看着就头疼，尤其是有的还需要自己定义。","like_count":14},{"had_liked":false,"id":188658,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1584401019,"is_pvip":false,"replies":[{"id":"72757","content":"其实IDEA已经增加了非常方便的Stream调试功能，可以参考https:&#47;&#47;www.jetbrains.com&#47;help&#47;idea&#47;analyze-java-stream-operations.html","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584403953,"ip_address":"","comment_id":188658,"utype":1}],"discussion_count":6,"race_medal":0,"score":"40239106683","product_id":100047701,"comment_content":"想问下老师,既然Lambda 表达式这么简洁,方便,但是我们项目经理要我们在项目中不要使用他,说是不好调试.......这个是理由吗?","like_count":10,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487477,"discussion_content":"其实IDEA已经增加了非常方便的Stream调试功能，可以参考https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584403953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2378309,"avatar":"https://static001.geekbang.org/account/avatar/00/24/4a/45/e048531a.jpg","nickname":"迪米乌格斯","note":"","ucode":"1D4393746DCBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376239,"discussion_content":"我觉得后面接手的人如果连Stream都不会的话, 对于项目能力的把关也堪忧, 我个人建议还是去学一下, Java8已经算是很老的版本了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622032381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206723,"discussion_content":"刘老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584433970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1035081,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","nickname":"刘大明","note":"","ucode":"83C063FBD9BF2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":206796,"discussion_content":"???","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584444794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206723,"ip_address":""},"score":206796,"extra":""}]},{"author":{"id":1076652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6d/ac/6128225f.jpg","nickname":"jjn0703","note":"","ucode":"83AF403AC7DFB7","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206398,"discussion_content":"主要后面接手的人 要是不会这个 就麻烦 哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584403720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1035081,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","nickname":"刘大明","note":"","ucode":"83C063FBD9BF2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1076652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6d/ac/6128225f.jpg","nickname":"jjn0703","note":"","ucode":"83AF403AC7DFB7","race_medal":5,"user_type":1,"is_pvip":true},"discussion":{"id":206795,"discussion_content":"估计是的。如果别人不会这个就有点麻烦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584444780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206398,"ip_address":""},"score":206795,"extra":""}]}]},{"had_liked":false,"id":189014,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1584446580,"is_pvip":false,"replies":[{"id":"72910","content":"因为filter还是并行的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584448991,"ip_address":"","comment_id":189014,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14469348468","product_id":100047701,"comment_content":"forEachOrdered 保证元素按顺序执行，我测试了代码的例子，发现去掉parallel后执行时间跟forEach差不多，加上后执行时间快了一倍多，结论是forEachOrdered并没有使parallel并行化效果完全消失，是这样的吗，也尝试看了一下源码，有点蒙。。<br>以下是我的测试结果<br>246810421086246810StopWatch &#39;&#39;: running time = 23068739988 ns<br>---------------------------------------------<br>ns         %     Task name<br>---------------------------------------------<br>15051360863  065%  stream<br>2010090132  009%  parallelStream<br>6007288993  026%  parallelStreamForEachOrdered","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487588,"discussion_content":"因为filter还是并行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584448991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189414,"user_name":"大头","can_delete":false,"product_type":"c1","uid":1315367,"ip_address":"","ucode":"C1FB2C8A0FB0C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/27/32746bbf.jpg","comment_is_top":false,"comment_ctime":1584513592,"is_pvip":true,"replies":[{"id":"73014","content":"是，不仅仅是简化，函数式的概念其实从更本上可以改变设计的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584513993,"ip_address":"","comment_id":189414,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174448184","product_id":100047701,"comment_content":"从传递对象，到传递匿名内部类，再到lambda表达式的演化，去掉了重复的代码，仅保留有意义的代码，越来越简洁明了了","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487689,"discussion_content":"是，不仅仅是简化，函数式的概念其实从更本上可以改变设计的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584513993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189008,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1584445863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174380455","product_id":100047701,"comment_content":"forEach不保证循环的顺序，forEachOrdered保证循环的顺序","like_count":3},{"had_liked":false,"id":188814,"user_name":"陈天柱","can_delete":false,"product_type":"c1","uid":1696225,"ip_address":"","ucode":"917BFDC845760D","user_header":"https://static001.geekbang.org/account/avatar/00/19/e1/e1/441df85d.jpg","comment_is_top":false,"comment_ctime":1584420493,"is_pvip":false,"replies":[{"id":"72846","content":"可以比较一下源码中的ForEachOrderedTest","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584423644,"ip_address":"","comment_id":188814,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174355085","product_id":100047701,"comment_content":"我实际开发的时候，最喜欢用的lambda表达式就是将一个集合对象转换成由该对象的指定字段值组成的集合，以前只会用，看了老师的文章以后才意识到学东西还是需要系统！<br>关于第二个思考题，尝试去阅读了一下源码，发现完全懵逼了，所以直接用idea跑了一下代码发现并行流forEachOrderd的效果直接是串行化了，虽然使用了并行流，但需要让任务有序化，让我想起了RocketMq里的顺序消息。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487535,"discussion_content":"可以比较一下源码中的ForEachOrderedTest","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584423644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188728,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1584408937,"is_pvip":false,"replies":[{"id":"72803","content":"没错","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584411788,"ip_address":"","comment_id":188728,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174343529","product_id":100047701,"comment_content":"java8的Lambda，给程序员提供了极大的便利性，和大幅度简化代码的可能性。单纯使用的话，学习成本并不高。常用的主流的操作也就那么几个。<br>但是要自行定义，并灵活变通使用，还是需要花些功夫去学习练习的。","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487499,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584411788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188670,"user_name":"jjn0703","can_delete":false,"product_type":"c1","uid":1076652,"ip_address":"","ucode":"83AF403AC7DFB7","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/ac/6128225f.jpg","comment_is_top":false,"comment_ctime":1584403746,"is_pvip":true,"replies":[{"id":"72759","content":"是的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584404295,"ip_address":"","comment_id":188670,"utype":1}],"discussion_count":1,"race_medal":5,"score":"10174338338","product_id":100047701,"comment_content":"Java8实战是出第二版了吗？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487480,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584404295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188652,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1584399047,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10174333639","product_id":100047701,"comment_content":"加餐来的 太及时了","like_count":2,"discussions":[{"author":{"id":1865356,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL3UicUedUgydoiadXuOFaOpIhOicrMbGUBEGBRkbbQibgVgRTYEIP4QFCzeicaRO8Br8icnvzic1ic1tUR8Q/132","nickname":"吴备","note":"","ucode":"47808627279AB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297453,"discussion_content":"你学习了，现在薪资多少呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596942248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205345,"user_name":"里子的忧伤","can_delete":false,"product_type":"c1","uid":1587392,"ip_address":"","ucode":"CB4C529635D434","user_header":"https://static001.geekbang.org/account/avatar/00/18/38/c0/04decf07.jpg","comment_is_top":false,"comment_ctime":1586595658,"is_pvip":false,"replies":[{"id":"76709","content":"并不是Function变为了ThrowingFunction，往ThrowingFunction.unchecked方法传入的本身就是一个lambda表达式，符合ThrowingFunction签名而已，返回的是Function&lt;T, R&gt;，所以没问题","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586603994,"ip_address":"","comment_id":205345,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881562954","product_id":100047701,"comment_content":"小白问题，往flatMap(ThrowingFunction.unchecked里传的参数function怎么就当做ThrowingFunction了呢","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491453,"discussion_content":"并不是Function变为了ThrowingFunction，往ThrowingFunction.unchecked方法传入的本身就是一个lambda表达式，符合ThrowingFunction签名而已，返回的是Function&amp;lt;T, R&amp;gt;，所以没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586603994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197828,"user_name":"杰哥长得帅","can_delete":false,"product_type":"c1","uid":1241993,"ip_address":"","ucode":"5A7FD1794F62D7","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/89/fcfecb46.jpg","comment_is_top":false,"comment_ctime":1585399971,"is_pvip":false,"replies":[{"id":"74634","content":"因为Function的签名不抛出受检异常IOException的，我们只能在flatMap中进行try...catch...了，这样就很不优雅臃肿，所以我们转换为运行时异常，这样就可以用一行代码来写完整个逻辑了","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585401760,"ip_address":"","comment_id":197828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880367267","product_id":100047701,"comment_content":"想问一下大佬，把受检异常转换为运行时异常，有什么作用呢","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489604,"discussion_content":"因为Function的签名不抛出受检异常IOException的，我们只能在flatMap中进行try...catch...了，这样就很不优雅臃肿，所以我们转换为运行时异常，这样就可以用一行代码来写完整个逻辑了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585401760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190208,"user_name":"终结者999号","can_delete":false,"product_type":"c1","uid":1055854,"ip_address":"","ucode":"33ADE61580B6DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","comment_is_top":false,"comment_ctime":1584614786,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5879582082","product_id":100047701,"comment_content":"默认并行流的一个小问题就是默认所有流操作使用同一个CommonPoll，可能会在有的操作比较慢的时候影响其他的并行操作。。","like_count":1},{"had_liked":false,"id":189980,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1584588231,"is_pvip":false,"replies":[{"id":"73138","content":"如果觉得好，可以多分享转发","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584599871,"ip_address":"","comment_id":189980,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879555527","product_id":100047701,"comment_content":"满满干货","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487845,"discussion_content":"如果觉得好，可以多分享转发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584599871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188818,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1584421119,"is_pvip":false,"replies":[{"id":"72844","content":"其实还是不同的，3是完全自定义一个ForkJoinPool，4是使用公共的ForkJoinPool，只不过设置了更大的并行度，5是演示CompletableFuture可以使用自定义的ForkJoinPool。有关CompletableFuture，源码中我给出了一个比较复杂的例子，但是文章中没有说明。日常开发根据自己的需求来选择。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584423561,"ip_address":"","comment_id":188818,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879388415","product_id":100047701,"comment_content":"大佬厉害！<br>IntStream.rangeClosed(1, taskCount).parallel().forEach(i -&gt; increment(atomicInteger)); <br>上面的代码3、4、5三种方法中完全相同，只不过是自己调用和放进线程池调用的区别，既然4都能自己用了，还要3、5干啥呢？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487537,"discussion_content":"其实还是不同的，3是完全自定义一个ForkJoinPool，4是使用公共的ForkJoinPool，只不过设置了更大的并行度，5是演示CompletableFuture可以使用自定义的ForkJoinPool。有关CompletableFuture，源码中我给出了一个比较复杂的例子，但是文章中没有说明。日常开发根据自己的需求来选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584423561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302304,"user_name":"tiger54910","can_delete":false,"product_type":"c1","uid":1500686,"ip_address":"","ucode":"F4D5BE1864E097","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Qq9IlgLjo8CVKTc93AHsicwDMJq3sbN4UsubLJXUQxWKDkEblaUHYviaq8TuVWygqkubwFEAa4qLiaQF6PyrfEQDg/132","comment_is_top":false,"comment_ctime":1626161304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626161304","product_id":100047701,"comment_content":"getProductAndCacheCool中的实现<br>cache.computeIfAbsent(id, i -&gt; &#47;&#47;当Key不存在的时候提供一个Function来代表根据Key获取Value的过程            Product.getData().stream()                   <br>.filter(p -&gt; p.getId().equals(i)) &#47;&#47;过滤                    <br>.findFirst() &#47;&#47;找第一个，得到Optional&lt;Product&gt;                   <br>.orElse(null)); &#47;&#47;如果找不到Product，则使用null<br>这是线程安全的吗？","like_count":0},{"had_liked":false,"id":285612,"user_name":"bigzuo","can_delete":false,"product_type":"c1","uid":1224554,"ip_address":"","ucode":"448C258D31A8A6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/RQdib68D7dsoFlYXOweiaPqLrcyn2jD6DCGnz8nc2VFmhmX0bpGTeSrVM5M9Qs7ibIInAmt5MeLcpcNja5YjyZCIg/132","comment_is_top":false,"comment_ctime":1616920144,"is_pvip":false,"replies":[{"id":"103682","content":"👍","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1617012625,"ip_address":"","comment_id":285612,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616920144","product_id":100047701,"comment_content":"通过搜索无意间浏览到朱晔老师的这个课程，看了一下脑图，其中很多坑自己都踩过。作为一个工作了八年的 Java 工程师，对文章的内容有不一样的认同感。","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517730,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617012625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280163,"user_name":"阿川Arc","can_delete":false,"product_type":"c1","uid":1978838,"ip_address":"","ucode":"4D990D6E3152A6","user_header":"https://static001.geekbang.org/account/avatar/00/1e/31/d6/4bfaa08c.jpg","comment_is_top":false,"comment_ctime":1614100394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614100394","product_id":100047701,"comment_content":"老师我想问一下第五种方式CompletableFuture实现的时候，把forkjoinpool换成其他线程池时需要执行shutdown程序才结束，forkjoinpool却不需要呢","like_count":0},{"had_liked":false,"id":279565,"user_name":"夏目🐳","can_delete":false,"product_type":"c1","uid":1101227,"ip_address":"","ucode":"4ED932E1F66F76","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/ab/1c3dc64b.jpg","comment_is_top":false,"comment_ctime":1613824666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613824666","product_id":100047701,"comment_content":"如何将从websocket收到的300000长度的消息存储到String中？","like_count":0},{"had_liked":false,"id":261757,"user_name":"crossover  of   AI","can_delete":false,"product_type":"c1","uid":2107466,"ip_address":"","ucode":"8EE3289947808F","user_header":"https://static001.geekbang.org/account/avatar/00/20/28/4a/36d07533.jpg","comment_is_top":false,"comment_ctime":1605514678,"is_pvip":false,"replies":[{"id":"95006","content":"多分享给身边朋友们","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1605521621,"ip_address":"","comment_id":261757,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605514678","product_id":100047701,"comment_content":"真的是句句真言 老师威武","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509598,"discussion_content":"多分享给身边朋友们","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605521621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253440,"user_name":"依旧木瓜","can_delete":false,"product_type":"c1","uid":1364763,"ip_address":"","ucode":"A77CD9CE9F67EB","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/1b/94a0637b.jpg","comment_is_top":false,"comment_ctime":1602740505,"is_pvip":true,"replies":[{"id":"92584","content":"感谢认可","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1602759729,"ip_address":"","comment_id":253440,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1602740505","product_id":100047701,"comment_content":"这个课程收货很大，都是些实战，真真正正平时都用的到的地方。期待老师能再出一些课程普惠大众","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507072,"discussion_content":"感谢认可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602759729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1750549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","nickname":"ImYours°","note":"","ucode":"51F653129034C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385205,"discussion_content":"老师还有其他的课程吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626942641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250653,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1601187322,"is_pvip":false,"replies":[{"id":"91753","content":"自己写一个函数接口","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1601198288,"ip_address":"","comment_id":250653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601187322","product_id":100047701,"comment_content":"最近遇到一个问题，想利用三个参数的Function或者是Consumer，为什么jdk就默认实现了1个参数的或者是2个参数呢，多个参数要怎么实现呢？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506250,"discussion_content":"自己写一个函数接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601198288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224416,"user_name":"Asura","can_delete":false,"product_type":"c1","uid":2004166,"ip_address":"","ucode":"E865D7FAFCF9B1","user_header":"https://static001.geekbang.org/account/avatar/00/1e/94/c6/a7c9f304.jpg","comment_is_top":false,"comment_ctime":1591372407,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1591372407","product_id":100047701,"comment_content":"想问下老师 有时用mybatisplus这些对单表操作的语句需要new对象set值去查询  这样到处new对象很难看  有时直接用双括号初始化去代替new对象了 但是会生成匿名内部类 可能会有内存泄露风险 可以用lambda怎么去代替吗","like_count":0,"discussions":[{"author":{"id":2110938,"avatar":"https://static001.geekbang.org/account/avatar/00/20/35/da/8496da45.jpg","nickname":"金伟斌@","note":"","ucode":"AC12BF71F3EF63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300655,"discussion_content":"builder","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598226360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219969,"user_name":"sunshine","can_delete":false,"product_type":"c1","uid":1690477,"ip_address":"","ucode":"A95679AB21566B","user_header":"https://static001.geekbang.org/account/avatar/00/19/cb/6d/1b47c15e.jpg","comment_is_top":false,"comment_ctime":1590127330,"is_pvip":false,"replies":[{"id":"81212","content":"这个不是在右键，是停留一会，左侧出现操作","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590139846,"ip_address":"","comment_id":219969,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590127330","product_id":100047701,"comment_content":"把流式语言变成循环的没找到在哪里，右键没有show context action","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496009,"discussion_content":"这个不是在右键，是停留一会，左侧出现操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590139846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215051,"user_name":"玩帆船的东郭君","can_delete":false,"product_type":"c1","uid":1860772,"ip_address":"","ucode":"F2F0DE3428E105","user_header":"https://static001.geekbang.org/account/avatar/00/1c/64/a4/9523350e.jpg","comment_is_top":false,"comment_ctime":1588898084,"is_pvip":false,"replies":[{"id":"79601","content":"Java实战 第2版<br>[英] 拉乌尔–加布里埃尔·乌尔玛，[意] 马里奥·富斯科，[英] 艾伦·米克罗夫特 著，陆明刚，劳佳 译","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588901469,"ip_address":"","comment_id":215051,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588898084","product_id":100047701,"comment_content":"老师推荐的书的全名叫什么？Java实战第二版？出版社和作者是哪个？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494293,"discussion_content":"Java实战 第2版\n[英] 拉乌尔–加布里埃尔·乌尔玛，[意] 马里奥·富斯科，[英] 艾伦·米克罗夫特 著，陆明刚，劳佳 译","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588901469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214524,"user_name":"二狗","can_delete":false,"product_type":"c1","uid":1244288,"ip_address":"","ucode":"91C38887F4F07B","user_header":"https://static001.geekbang.org/account/avatar/00/12/fc/80/21d67b9b.jpg","comment_is_top":false,"comment_ctime":1588761519,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588761519","product_id":100047701,"comment_content":"Lambda 一直没啃下来","like_count":0},{"had_liked":false,"id":203172,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1049994,"ip_address":"","ucode":"C0859057592720","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/8a/e7c5a7e2.jpg","comment_is_top":false,"comment_ctime":1586148216,"is_pvip":false,"replies":[{"id":"75961","content":"Preferences | Editor | Inspections","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586174692,"ip_address":"","comment_id":203172,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586148216","product_id":100047701,"comment_content":"老师，idea设置没按lambda语法报错的地方在哪，没找到","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490787,"discussion_content":"Preferences | Editor | Inspections","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586174692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197955,"user_name":"杰哥长得帅","can_delete":false,"product_type":"c1","uid":1241993,"ip_address":"","ucode":"5A7FD1794F62D7","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/89/fcfecb46.jpg","comment_is_top":false,"comment_ctime":1585405182,"is_pvip":false,"replies":[{"id":"74672","content":"好处是无需在Stream链内部来处理异常，在外部肯定要处理的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585442966,"ip_address":"","comment_id":197955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585405182","product_id":100047701,"comment_content":"谢谢大神对我上个问题的解答，但我还是有疑问：<br>即使把受检异常转换为运行时异常了，也还是要try catch捕获处理的吧。不然即使改成抛出RuntimeException，程序运行还是会有问题啊","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489627,"discussion_content":"好处是无需在Stream链内部来处理异常，在外部肯定要处理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585442966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192339,"user_name":"tripcom","can_delete":false,"product_type":"c1","uid":1884804,"ip_address":"","ucode":"CE01E51FA1D2A3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLsBXIu6pibTYZLf2ic5GSZMTIibMOTKGmp1gGRTdWMWaibzIpQ6r3qQ0ath6oGRh289XQrkXj53iaib8fg/132","comment_is_top":false,"comment_ctime":1584847158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584847158","product_id":100047701,"comment_content":"学习了","like_count":0}]}