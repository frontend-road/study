{"id":625912,"title":"24｜生产稳定的秘密武器：如何实施蓝绿发布？","content":"<p>你好，我是王炜。今天是我们 GitOps 高级发布策略的第一课。</p><p>在之前的课程里，我们通过构建 GitOps 工作流实现了自动发布。不过，我们并没有专门去关注新老版本在做更新时是如何切换流量的，这是因为 Kubernetes 的 Service 和 Pod 滚动更新机制自动帮助我们完成了这部分的工作。</p><p>在实际的生产环境中，为了提高发布的可靠性，我们通常需要借助发布策略来更加精细地控制流量切换。在几种发布策略中，蓝绿发布是较为简单且容易理解的一种，所以，我将从它开始来介绍如何在 GitOps 工作流中实施蓝绿发布。</p><p>那么，什么是蓝绿发布呢？</p><p>蓝绿发布核心思想是：<strong>为应用提供两套环境，并且可以很方便地对它们进行流量切换。</strong></p><p>在一次实际发布过程中，新版本的应用将以“绿色”环境部署到生产环境中，但在流量切换之前它并不接收外部流量。当我们完成“绿色”环境的测试之后，可以通过流量切换的方式让“绿色”环境接收外部请求，而旧的“蓝色”环境并不会立即销毁，而是作为灾备来使用。一旦发布过程产生故障，我们就可以将流量立即切换到旧的“蓝色”环境下。</p><p>这种部署方式比较适合那些存在兼容问题，或者因为状态原因导致不能很好地使用 Kubernetes 滚动更新的应用。还有的项目希望在更新时部署一个新的版本，同时控制流量切换过程；或者是在发布出现问题时快速回滚。蓝绿发布也是不错的选择。</p><!-- [[[read_end]]] --><p>在这节课，首先我会通过一个例子来说明如何通过手动的方式来实施蓝绿发布。然后，我会结合 Argo Rollout 这款工具进一步向你介绍如何自动化蓝绿发布过程。</p><p>在开始之前，你需要具备以下前提条件。</p><ul>\n<li>按照第一章<a href=\"https://time.geekbang.org/column/article/612571\">第 2 讲</a>的内容在本地配置好 Kind 集群，安装 Ingress-Nginx，<strong>并暴露 80 和 443 端口。</strong></li>\n<li>配置好 Kubectl，使其能够访问 Kind 集群。</li>\n</ul><h2>蓝绿发布概述</h2><p>为了更好地帮助你理解蓝绿发布，在正式进入实战之前，我们先来了解它的整体架构，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/d3/c594541df106b974d7794a9be97607d3.jpg?wh=1920x1024\" alt=\"图片\"></p><p>在上面这张架构图中，我们对同一个应用部署了两个版本的环境，称之为蓝绿环境，流量通过 Ingress-Nginx 进入到 Service，然后再由它将流量转发至 Pod。在没有切换流量之前，“蓝色”环境负责接收外部请求流量。</p><p>需要进行流量切换时，只要调整 Ingress 策略就可以让“绿色”环境接收外部流量，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/86/6e/86f788ec96990e9cdb20184e10f4646e.jpg?wh=1920x1020\" alt=\"图片\"></p><h2>蓝绿发布实战</h2><p>接下来，我们进入蓝绿发布实战。我会通过一个例子来说明如何使用 Kubernetes 原生的 Deployment 和 Service 来进行蓝绿发布，实战过程主要包含下面几个步骤。</p><ol>\n<li>创建蓝色环境的 Deployment 和 Service。</li>\n<li>创建 Ingress 策略，并指向蓝色环境的 Service。</li>\n<li>访问蓝色环境。</li>\n<li>创建绿色环境的 Deployment 和 Service。</li>\n<li>更新 Ingress 策略，并指向绿色环境。</li>\n<li>访问绿色环境。</li>\n</ol><h3>创建蓝色环境</h3><p>首先，我们需要创建蓝色环境，将下面的内容保存为 blue_deployment.yaml。</p><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: blue\n  labels:\n    app: blue\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: blue\n  template:\n    metadata:\n      labels:\n        app: blue\n    spec:\n      containers:\n      - name: demo\n        image: argoproj/rollouts-demo:blue\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: blue-service\n  labels:\n    app: blue\nspec:\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n  selector:\n    app: blue\n  type: ClusterIP\n</code></pre><p>在上面这段 Manifest 中，我们使用了 argoproj/rollouts-demo:blue 镜像创建了蓝色环境的 Deployment 工作负载，并且创建了名为 blue-service 的 Service 对象，同时通过 Service 选择器将 Service 和 Pod 进行了关联。</p><p>然后，使用 kubectl apply 命令将示例应用部署到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f blue_deployment.yaml&nbsp;\ndeployment.apps/blue created\nservice/blue-service created\n</code></pre><p>部署完成后，等待工作负载 Ready。</p><pre><code class=\"language-yaml\">$ kubectl wait pods -l app=blue --for condition=Ready --timeout=90s\npod/blue-79c9fb755d-9b6xx condition met\n</code></pre><p>当看到上面的输出后，代表绿色环境已经准备好了。</p><p>接下来，我们再创建蓝色环境的 Ingress 策略。将下面的内容保存为 blue_ingress.yaml 文件。</p><pre><code class=\"language-yaml\">apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: demo-ingress\nspec:\n  rules:\n  - host: \"bluegreen.demo\"\n    http:\n      paths:\n      - pathType: Prefix\n        path: \"/\"\n        backend:\n          service:\n            name: blue-service\n            port:\n              number: 80\n</code></pre><p>然后，通过 kubectl apply 将其应用到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f blue_ingress.yaml&nbsp; &nbsp;\ningress.networking.k8s.io/demo-ingress created\n</code></pre><p>在上面创建的 Ingres 策略中，我们指定了 bluegreen.info 作为访问域名。所以，在访问蓝色环境之前，你需要先在本地配置 Hosts 才能访问。</p><pre><code class=\"language-yaml\">127.0.0.1 bluegreen.demo\n</code></pre><p>如果你用的是 Linux 或者 MacOS 系统，请将上面的内容添加到 /etc/hosts 文件。</p><p>如果你用的是 Windows 系统，需要将上面的内容添加到 C:\\Windows\\System32\\Drivers\\etc\\hosts 文件。</p><p>此外，你还可以使用 <a href=\"https://github.com/oldj/SwitchHosts\">SwitchHosts</a> 这款开源工具来管理 Hosts 配置。</p><h3>访问蓝色环境</h3><p>配置完 Hosts 之后，接下来我们就可以访问蓝色环境了。使用浏览器访问 <a href=\"http://bluegreen.demo\">http://bluegreen.demo</a>，你应该能看到如下所示的页面。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/fd/de5788dc52f6a0887738e30e662afefd.png?wh=1920x1038\" alt=\"图片\"></p><p>在这个页面里，浏览器每秒钟会向后端发出 50 个请求，蓝色的方块代表后端返回接口的内容为 blue，对应 blue 版本的镜像，代表蓝色环境。</p><h3>部署绿色环境</h3><p>现在，假设我们需要发布新版本，也就是部署绿色环境。你可以将下面的内容保存为 green_deployment.yaml。</p><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: green\n  labels:\n    app: green\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: green\n  template:\n    metadata:\n      labels:\n        app: green\n    spec:\n      containers:\n      - name: demo\n        image: argoproj/rollouts-demo:green\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: green-service\n  labels:\n    app: green\nspec:\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n  selector:\n    app: green\n  type: ClusterIP\n</code></pre><p>在这段 Manifest 中，我们用 argoproj/rollouts-demo:green 镜像创建绿色环境的 Deployment，并且创建了名为 green-service 的 Service 对象。</p><p>接下来，使用 kubectl apply 来将它应用到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f green_deployment.yaml&nbsp;\ndeployment.apps/green created\nservice/green-service created\n</code></pre><p>部署完成后，等待工作负载 Ready。</p><pre><code class=\"language-yaml\">$ kubectl wait pods -l app=green --for condition=Ready --timeout=90s\npod/green-79c9fb755d-9b6xx condition met\n</code></pre><p>当看到上面的输出后，代表绿色环境已经准备好了。</p><h3>切换到绿色环境</h3><p>现在，当绿色环境已经准备好接收外部流量时，我们就可以通过调整 Ingress 策略来切换流量了。将下面的内容保存为 green_ingress.yaml。</p><pre><code class=\"language-yaml\">apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: demo-ingress\nspec:\n  rules:\n  - host: \"bluegreen.demo\"\n    http:\n      paths:\n      - pathType: Prefix\n        path: \"/\"\n        backend:\n          service:\n            name: green-service\n            port:\n              number: 80\n</code></pre><p>在上面这段 Ingress Manifest 中，我们将 backend.service 字段由原来的 blue-service 修改为了 green-service，这表示将 Ingress 接收到的外部请求转发到绿色环境的 Service 中，以此达到流量切换的目的。</p><p>现在，将这段 Ingress 策略应用到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f green_ingress.yaml\ningress.networking.k8s.io/demo-ingress configured\n</code></pre><p>重新返回浏览器，你将会看到请求将逐渐从蓝色切换到绿色，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/b6/8fc6a7dd4ec82581ac8byyb6e44d73b6.png?wh=1920x1038\" alt=\"图片\"></p><p>过几秒钟后，请求已经完全变为绿色，这表示流量已经完全从蓝色环境切换到了绿色环境。</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/9f/e7b73657678ea74f44e37915950b079f.png?wh=1920x1038\" alt=\"图片\"></p><p>到这里，蓝绿发布就已经完成了。</p><h2>蓝绿发布自动化</h2><p>到这里，我们都是通过创建 Kubernetes 原生对象并修改 Ingress 策略的方式来完成蓝绿发布的。这存在一些缺点，首先，在更新过程中，我们一般只关注镜像版本的变化，而不会去操作 Ingress 策略；其次，这种方式不利于将蓝绿发布和 GitOps 流水线进行整合。</p><p>接下来，我们来看看如何通过 Argo Rollout 工具来自动化蓝绿发布的过程。</p><h3>安装 Argo Rollout</h3><p>Argo Rollout 是一款专门提供 Kubernetes 高级部署能力的自动化工具，它可以独立运行，同时也可以和 ArgoCD 协同在 GitOps 流水线中来使用。</p><p>在使用之前，我们需要先安装它，你可以通过下面的命令进行安装。</p><pre><code class=\"language-yaml\">$ kubectl create namespace argo-rollouts  # 创建命名空间\n$ kubectl apply -n argo-rollouts -f https://ghproxy.com/https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml\n</code></pre><p>安装完成后，等待 Argo Rollout 工作负载就绪。</p><pre><code class=\"language-yaml\">$ kubectl wait --for=condition=Ready pods --all -n argo-rollouts --timeout=300s\npod/argo-rollouts-7f75b9fb76-wh4l5 condition met\n</code></pre><p>当看到上面的这段输出后，说明 Argo Rollout 已经准备完成了。</p><h3>创建 Rollout 对象</h3><p>和手动实施蓝绿发布的过程不同的是，为了实现自动化，Argo Rollout 采用了自定义资源（CRD）的方式来管理工作负载。如果你暂时还不理解 CRD 也没关系，你只需要知道它是一种扩展 Kubernetes 对象的方式就可以了。</p><p>首先，我们需要先创建 Rollout 对象。将下面的内容保存为 blue-green-service.yaml 文件。</p><pre><code class=\"language-yaml\">apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: bluegreen-demo\n  labels:\n    app: bluegreen-demo\nspec:\n  replicas: 3\n  revisionHistoryLimit: 1\n  selector:\n    matchLabels:\n      app: bluegreen-demo\n  template:\n    metadata:\n      labels:\n        app: bluegreen-demo\n    spec:\n      containers:\n      - name: bluegreen-demo\n        image: argoproj/rollouts-demo:blue\n        imagePullPolicy: Always\n        ports:\n        - name: http\n          containerPort: 8080\n          protocol: TCP\n        resources:\n          requests:\n            memory: 32Mi\n            cpu: 5m\n  strategy:\n    blueGreen:\n      autoPromotionEnabled: true\n      activeService: bluegreen-demo\n</code></pre><p>如果你仔细观察，会发现在这个 Rollout 对象中，它大部分的字段定义和 Kubernetes 原生的 Deployment 工作负载并没有太大的区别，只是将 apiVersion 从 apps/v1 修改为了 argoproj.io/v1alpha1，同时将 kind 字段从 Deployment 修改为了 Rollout，并且增加了 strategy 字段。在容器配置方面，Rollout 对象同样也使用了 argoproj/rollouts-demo:blue 来创建蓝色环境。</p><p>需要留意的是，strategy 字段是用来定义部署策略的。其中，autoPromotionEnabled 字段表示自动实施蓝绿发布，activeService 用来关联蓝绿发布的 Service，也就是我们在后续要创建的 Service 名称。</p><p>总结来说，当我们将这段 Rollout 对象应用到集群内之后，Argo Rollout 首先会创建 Kubernetes 原生对象 ReplicaSet，然后，ReplicaSet 会创建对应的 Pod。为了帮助你理解，你可以将它与之前手动实施蓝绿发布过程中创建的 Deployment 工作负载进行对比，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/4a/e50bb350dd7dcd6f2c1283c1a952c84a.jpg?wh=1903x1413\" alt=\"图片\"></p><p>从上面这张图我们可以看出，它们的最核心的区别在于 ReplicaSet 是由谁管理的。很显然，在这个例子中，Rollout 对象管理 ReplicaSet 对象，进而达到了管理 Pod 的目的。</p><p>在理解了它们的关系之后，接下来我们创建 Rollout 对象。和普通资源一样，你可以通过 kubectl apply 来创建。</p><pre><code class=\"language-yaml\">$ kubectl apply -f blue-green-rollout.yaml&nbsp;\nrollout.argoproj.io/bluegreen-demo created\n</code></pre><h3>创建 Service 和 Ingress</h3><p>创建好 Rollout 对象之后，我们还需要创建 Service 和 Ingress 策略，这和之前手动实施蓝绿发布的过程是一致的。</p><p>首先，创建 Service。将下面的内容保存为 blue-green-service.yaml 文件。</p><pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: bluegreen-demo\n  labels:\n    app: bluegreen-demo\nspec:\n  ports:\n  - port: 80\n    targetPort: http\n    protocol: TCP\n    name: http\n  selector:\n    app: bluegreen-demo\n</code></pre><p>然后，将它应用到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f blue-green-service.yaml&nbsp;\nservice/bluegreen-demo created\n</code></pre><p>最后，创建 Ingress 对象。将下面的内容保存为 blue-green-ingress.yaml 文件。</p><pre><code class=\"language-yaml\">apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: bluegreen-demo\nspec:\n  rules:\n  - host: \"bluegreen.auto\"\n    http:\n      paths:\n      - pathType: Prefix\n        path: \"/\"\n        backend:\n          service:\n            name: bluegreen-demo\n            port:\n              number: 80\n</code></pre><p>和之前创建的 Ingress 对象不同的是，这里我们使用了 bluegreen.auto 域名，以便和之前创建的 Ingress 域名区分开。</p><p>然后，使用 kubectl apply 命令将它应用到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f blue-green-ingress.yaml&nbsp;\ningress.networking.k8s.io/bluegreen-demo created\n</code></pre><p>同样地，为了能够访问 bluegreen.auto 域名，你还需要添加 Hosts 策略。</p><pre><code class=\"language-yaml\">127.0.0.1 bluegreen.auto\n</code></pre><h3>访问蓝色环境</h3><p>配置完 Hosts 之后，接下来我们就可以访问由 Argo Rollout 创建的蓝色环境了。使用浏览器访问 <a href=\"http://bluegreen.auto\">http://bluegreen.auto</a>，你应该能看到和手动实施蓝绿发布一样的页面。</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/55/2fc72993c507575869fc8b9fa07cf955.png?wh=1920x1038\" alt=\"图片\"></p><h3>蓝绿发布自动化</h3><p>现在，假设我们需要更新到绿色环境，在 Argo Rollout 的帮助下，你只需要修改 Rollout 对象中的镜像版本就可以了，流量切换过程将由 Argo Rollout 自动控制。</p><p>要更新到绿色环境，你需要编辑 blue-green-rollout.yaml 文件的 image 字段，将 blue 修改为 green 版本。</p><pre><code class=\"language-yaml\">containers:\n- name: bluegreen-demo\n  image: argoproj/rollouts-demo:green\n</code></pre><p>然后，使用 kubectl apply 将这段 Rollout 对象重新应用到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f blue-green-rollout.yaml\nrollout.argoproj.io/bluegreen-demo configured\n</code></pre><p>现在，返回到浏览器，等待十几秒后，你应该就能看到请求里开始出现绿色环境了。</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/91/e6e6f39a9a52cb0e5a60f74096e3ab91.png?wh=1920x1038\" alt=\"图片\"></p><p>几秒钟后，所有请求都变成了绿色方格，这表示蓝绿发布的自动化过程已经完成。</p><p>相比较手动的方式，在使用 Argo Rollout 进行蓝绿发布的过程中，我们不再需要手动去切换流量，除了更新镜像版本以外，我们也无需关注其他的 Kubernetes 对象。</p><h3>访问 Argo Rollout Dashboard</h3><p>要访问 Argo Rollout Dashboard，首先你需要安装 Argo Rollout 的 kubectl 插件，以 MacOS 为例，你可以通过下面的命令来安装。</p><pre><code class=\"language-yaml\">$ brew install argoproj/tap/kubectl-argo-rollouts\n</code></pre><p>Linux 或 Windows 系统可以通过直接下载二进制可执行文件的方式来安装，你可以在<a href=\"https://github.com/argoproj/argo-rollouts/releases\">这个链接</a>下载，并将它加入到 PATH 环境变量中，详细的步骤你可以参考<a href=\"https://argoproj.github.io/argo-rollouts/installation/#manual\">这份文档</a>。</p><p>插件安装完成后，你可以通过下面的命令来检查安装是否成功。</p><pre><code class=\"language-yaml\">$ kubectl argo rollouts version\nkubectl-argo-rollouts: v1.3.0+93ed7a4\n&nbsp; BuildDate: 2022-09-19T02:51:42Z\n&nbsp; GitCommit: 93ed7a497b021051bf6845da90907d67c231e703\n&nbsp; GitTreeState: clean\n&nbsp; GoVersion: go1.18.6\n&nbsp; Compiler: gc\n&nbsp; Platform: darwin/amd64\n</code></pre><p>当看到上面的输出结果后，说明插件安装成功了。</p><p>接下来，我们可以使用 kubectl argo rollouts dashboard 来启用 Dashboard。</p><pre><code class=\"language-yaml\">$ kubectl argo rollouts dashboard\nINFO[0000] Argo Rollouts Dashboard is now available at http://localhost:3100/rollouts\n</code></pre><p>然后，使用浏览器访问 <a href=\"http://localhost:3100/rollouts\">http://localhost:3100/rollouts</a> 打开 Dashboard，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/79/cd/79f9d70eeed935843ab6a6985f0f1dcd.png?wh=1920x1038\" alt=\"图片\"></p><p>点击进入 Rollout 的详情界面，在这里，你能够以图形化的方式来查看 Rollout 的信息或进行回滚操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/36/8abcdf5e8c94749d3037050dec909636.png?wh=1920x1038\" alt=\"图片\"></p><h2>自动化原理</h2><p>那么，Argo Rollout 为什么能够帮助我们自动切换流量呢？接下来，我为你详细分析一下它的工作原理。</p><p>在刚开始创建蓝色环境时，Ingress、Service 和 Rollout 的关系是下图这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/29/0d7c20a2faf5fe6a361yy6c5c0a47529.jpg?wh=1920x492\" alt=\"图片\"></p><p>在这个例子中，当 Rollout 对象创建后，Argo Rollout 将会随之创建 ReplicaSet 对象，名称为 blue-green-fbc7b7f55，这个 ReplicaSet 会在创建 Pod 时额外为 Pod 打上 rollouts-pod-template-hash=fbc7b7f55 的标签，同时为 Service 添加 rollouts-pod-template-hash=fbc7b7f55 选择器，这样，就打通了从 Ingress 到 Pod 的请求链路。</p><p>当我们修改 Rollout 对象的镜像版本后，Argo Rollout 将会重新创建一个新的 ReplicaSet 对象，名称为 bluegreen-demo-7d6459646d，新的 ReplicaSet 也会在创建 Pod 时额外为 Pod 打上&nbsp;rollouts-pod-template-hash=7d6459646d 标签。这时候蓝绿环境的 ReplicaSet 同时存在。</p><p>当绿色环境的 Pod 全部就绪之后，Argo Rollout 会将 Service 原来的选择器删除，并添加 rollouts-pod-template-hash=7d6459646d 的选择器，这样就将 Service 指向了绿色环境的 Pod，从而达到了切换流量的目的。同时，Argo Rollout 还会将蓝色环境的 ReplicaSet 副本数缩容为 0，但并不删除它，而是把它作为灾备。如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/70/a9/70c5b94f26ee5ba580ef59af7e2f9fa9.jpg?wh=1920x804\" alt=\"图片\"></p><p>这样，当我们需要重新回滚到蓝色环境时，Argo Rollout 只需调整蓝色环境的 ReplicaSet 副本数并且修改 Service 的选择器，就可以达到快速回滚的目的。</p><h2>总结</h2><p>这节课，我首先通过手动的方式带你实践了蓝绿发布的过程。这个过程的核心是部署两套 Deployment 和 Service，同时通过修改 Ingress 策略来实现切换流量。</p><p>但手动的方式并不适合与 GitOps 流水线结合使用，所以我们又介绍了通过 Argo Rollout 将蓝绿发布自动化的方法。</p><p>要将手动过程切换到自动化过程其实也非常简单，我们只需要安装 Argo Rollout，并修改 Deployment 对象的 apiVersion 和 Kind 字段，然后增加 strategy 字段配置蓝绿发布策略就可以了。</p><p>然后，我还为你分析了 Argo Rollout 实现自动化蓝绿发布的原理。和手动修改 Ingress 策略来实现的蓝绿发布不同的是，它主要是通过自动修改 Service 的选择器来对流量进行切换的。这种方式将蓝绿发布的过程变成了更新镜像的操作，极大降低了蓝绿发布的门槛。</p><p>最后，你需要注意的是，如果你希望在微服务架构下实施蓝绿发布，那么情况会复杂得多，你需要关注整个微服务链路的蓝绿流量的切换过程，并且在数据库层面也需要考虑对蓝绿发布的支持和适配情况，使数据库在升级过程中能够同时支持蓝绿（新旧）应用。</p><p>在下一节课，我会向你介绍在生产环境下更常见的一种发布方式：金丝雀发布。</p><h2>思考题</h2><p>最后，给你留两道思考题吧。</p><ol>\n<li>在手动实施蓝绿发布的过程中，当流量切换到绿色环境时，如何将蓝色环境的副本数缩容至 0 ？</li>\n<li>在上面的例子中，一旦更新 Rollout 对象的镜像版本，蓝绿发布过程就会自动进行。请你动手试试，如何使用 Rollout 对象的 autoPromotionEnabled 参数和 Argo Rollout kubectl 插件，实现手动控制蓝绿发布呢？（小提示：你可以参考<a href=\"https://argoproj.github.io/argo-rollouts/features/bluegreen/#example\">这个链接</a>。）</li>\n</ol><p>欢迎你给我留言交流讨论，你也可以把这节课分享给更多的朋友一起阅读。我们下节课见。</p>","comments":[{"had_liked":false,"id":370341,"user_name":"争光 Alan","can_delete":false,"product_type":"c1","uid":1336328,"ip_address":"上海","ucode":"338534F909AF03","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/08/0287f41f.jpg","comment_is_top":false,"comment_ctime":1678725184,"is_pvip":false,"replies":[{"id":135052,"content":"这两个问题都非常好。\n首先文章演示的蓝绿发布实际上是南北流量的蓝绿，微服务内部的东西流量灰度需要借助 istio 服务网格来实现，当业务内部发起服务间调用时，透传灰度标识，这样才能够实现全链路的灰度。\n其次数据库的灰度更复杂一些，一般的实践是多实例或者扩展 istio 协议。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1678758780,"ip_address":"广东","comment_id":370341,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"我理解rollout就是给deployment做了增强，增加了一种新版本创建时老版本保留的能力\n\n我的几个疑惑\n1. 一般业务会有前段，后端，数据库，微服务更多组件，这样的应用如何进行蓝绿？rollout可以对多个deployment做蓝绿吗？\n2. 新老版本共存的情况下，数据库是同一个，数据库新老版本不兼容如何处理？","like_count":5,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608957,"discussion_content":"这两个问题都非常好。\n首先文章演示的蓝绿发布实际上是南北流量的蓝绿，微服务内部的东西流量灰度需要借助 istio 服务网格来实现，当业务内部发起服务间调用时，透传灰度标识，这样才能够实现全链路的灰度。\n其次数据库的灰度更复杂一些，一般的实践是多实例或者扩展 istio 协议。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678758780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367394,"user_name":"zangchao","can_delete":false,"product_type":"c1","uid":1391250,"ip_address":"天津","ucode":"ABF6DC270B127C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJat6pp5AbdicOVBUgPrJicTqkaYC0ZnicrdHb2qHAmvicOJKO3NFH2SczHj7fubVHUKSdRbY9jGCr7SQ/132","comment_is_top":false,"comment_ctime":1675212899,"is_pvip":false,"replies":[{"id":133897,"content":"Argo Rollout 是一个不错的选择，比较轻量。此外，Netflix 开源的 Spinnaker 也可以做灰度发布，不过比较重。\n如果你的业务有很多个微服务，在不侵入业务的情况下，东西流量（微服务和微服务之间的调用）的灰度还是需要借助 Service Mesh 的。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1675414745,"ip_address":"广东","comment_id":367394,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"收获很多，很感谢老师，正好最近在做服务迁移K8s，需要实现服务的灰度发布、蓝绿发布等。想问下老师当前在K8s实现灰度发布有哪些开源库选择，Argo Rollout是否为实现K8s环境下灰度发布的最优选择？之前我们用Istio做过，最近准备放弃Istio了","like_count":2,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601800,"discussion_content":"Argo Rollout 是一个不错的选择，比较轻量。此外，Netflix 开源的 Spinnaker 也可以做灰度发布，不过比较重。\n如果你的业务有很多个微服务，在不侵入业务的情况下，东西流量（微服务和微服务之间的调用）的灰度还是需要借助 Service Mesh 的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675414745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1038646,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d9/36/92d8eb91.jpg","nickname":"Promise","note":"","ucode":"3E07E270EED2E8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603043,"discussion_content":"老铁在天津做开发还是运维呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675920457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368167,"user_name":"BertGeek","can_delete":false,"product_type":"c1","uid":1452799,"ip_address":"上海","ucode":"8E1D72C9F9778C","user_header":"https://static001.geekbang.org/account/avatar/00/16/2a/ff/a9d72102.jpg","comment_is_top":false,"comment_ctime":1675950054,"is_pvip":false,"replies":[{"id":134049,"content":"1. 正常现象，你可以用 Lens 一类的 UI 工具来查看\n2. Rollout 似乎不能支持这种用法\n3. 查看这个文档：https:&#47;&#47;github.com&#47;argoproj&#47;argo-rollouts&#47;blob&#47;master&#47;docs&#47;features&#47;kustomize.md","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1675952470,"ip_address":"广东","comment_id":368167,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"请问老师，几个问题：\n阿里云ack 集群，Argo Rollout实现蓝绿发布\n1. 因为deployment 改为了 Rollout，导致ack 的无状态页面无法看到pod 容器，只能在控制台容器组中看到。\n2. Argo Rollout 是否可以监测镜像变化，自动发布新版本 \n3. Argocd + Rollout ，如何与 Kustomize 集成。","like_count":1,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603120,"discussion_content":"1. 正常现象，你可以用 Lens 一类的 UI 工具来查看\n2. Rollout 似乎不能支持这种用法\n3. 查看这个文档：https://github.com/argoproj/argo-rollouts/blob/master/docs/features/kustomize.md","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675952470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367395,"user_name":"林龍","can_delete":false,"product_type":"c1","uid":1766285,"ip_address":"广东","ucode":"61A98DC0DC1E8A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/f3/8d/402e0e0f.jpg","comment_is_top":false,"comment_ctime":1675213132,"is_pvip":false,"replies":[{"id":133898,"content":"蓝绿发布在升级过程会保留老的环境，核心思想冗余。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1675415045,"ip_address":"广东","comment_id":367395,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"有个疑问，蓝绿发布这里案例是通过修改ingress的Deployment中的sevice修改对应的应用。自动化构建的话是通过引入Argo Rollout，请问这个自动化构建时修改Deployment的images有什么区别，它也是会通过ReplicaSet创建新的pod，同时也是新的pod创建成功后才会慢慢销毁旧的pod","like_count":1,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601803,"discussion_content":"蓝绿发布在升级过程会保留老的环境，核心思想冗余。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675415045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374060,"user_name":"Da Vinci","can_delete":false,"product_type":"c1","uid":1061671,"ip_address":"广东","ucode":"DB3B7F6A6028C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/27/e5a74107.jpg","comment_is_top":false,"comment_ctime":1683540995,"is_pvip":true,"replies":[{"id":136643,"content":"我没有遇到过，不过你可以尝试看一下这个 issues：https:&#47;&#47;github.com&#47;argoproj&#47;argo-cd&#47;issues&#47;6048","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1683630567,"ip_address":"广东","comment_id":374060,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"启动了dashboard，但是获取不到rollout，看stdoutput，上面报x509: “Argo CD” certificate is not trusted，这是什么原因啊","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617522,"discussion_content":"我没有遇到过，不过你可以尝试看一下这个 issues：https://github.com/argoproj/argo-cd/issues/6048","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683630567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382709,"user_name":"托瓦斯克一🎋","can_delete":false,"product_type":"c1","uid":2904318,"ip_address":"广东","ucode":"3FB99A5F16A09C","user_header":"https://static001.geekbang.org/account/avatar/00/2c/50/fe/992f7354.jpg","comment_is_top":false,"comment_ctime":1697867720,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"要使用 Rollout 对象的 `autoPromotionEnabled` 参数和 Argo Rollout kubectl 插件来实现手动控制蓝绿发布，您可以按照以下步骤进行操作：\n\n1. 确保已安装 Argo Rollout kubectl 插件。您可以参考 Argo Rollout 文档中的安装指南来安装插件：https:&#47;&#47;argoproj.github.io&#47;argo-rollouts&#47;installation&#47;\n\n2. 创建一个 Rollout 对象，并设置 `autoPromotionEnabled` 参数为 `false`，以禁用自动推进（auto-promotion）功能。示例配置如下：\n\n```yaml\napiVersion: argoproj.io&#47;v1alpha1\nkind: Rollout\nmetadata:\n  name: my-rollout\nspec:\n  strategy:\n    blueGreen:\n      autoPromotionEnabled: false\n  # 其他配置项...\n```\n\n在上面的配置中，我们将 `autoPromotionEnabled` 设置为 `false`，以禁用自动推进功能。\n\n3. 使用 `kubectl` 命令创建或更新 Rollout 对象：\n\n```shell\nkubectl apply -f rollout.yaml\n```\n\n确保将 `rollout.yaml` 替换为您实际的配置文件路径。\n\n4. 使用 Argo Rollout kubectl 插件来手动控制蓝绿发布过程。您可以使用以下命令列出 Rollout 对象的可用操作：\n\n```shell\nkubectl argo rollouts list\n```\n\n此命令将显示可用的 Rollout 对象及其状态。\n\n5. 执行蓝绿发布的步骤。您可以使用以下命令来推进蓝绿发布的不同阶段：\n\n```shell\nkubectl argo rollouts promote my-rollout\n```\n\n这将推进 Rollout 对象到下一个可用的蓝绿发布阶段。\n\n```shell\nkubectl argo rollouts abort my-rollout\n```\n\n这将中止当前的蓝绿发布过程。\n\n```shell\nkubectl argo rollouts set image my-rollout my-container=my-image:tag\n```\n\n这将更新 Rollout 对象中的容器镜像版本。\n\n通过使用这些命令，您可以手动控制蓝绿发布的不同阶段和操作，而不依赖于 `autoPromotionEnabled` 参数的自动推进功能。\n","like_count":0},{"had_liked":false,"id":368903,"user_name":"ghostwritten","can_delete":false,"product_type":"c1","uid":1308196,"ip_address":"北京","ucode":"AE512F2E24A1A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/24/547439f1.jpg","comment_is_top":false,"comment_ctime":1676880230,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":2,"product_id":100312001,"comment_content":"1. 什么是蓝绿发布？\n蓝绿发布呢？蓝绿发布核心思想是：为应用提供两套环境，并且可以很方便地对它们进行流量切换。在一次实际发布过程中，新版本的应用将以“绿色”环境部署到生产环境中，但在流量切换之前它并不接收外部流量。当我们完成“绿色”环境的测试之后，可以通过流量切换的方式让“绿色”环境接收外部请求，而旧的“蓝色”环境并不会立即销毁，而是作为灾备来使用。一旦发布过程产生故障，我们就可以将流量立即切换到旧的“蓝色”环境下。\n\n2. 手动蓝绿发布\n部署两套环境，镜像tag 分别为blue、green，切换操作其实是修改ingress的\nservice: \n        name: blue-service  # 改为green-service\n这种操作 Ingress 策略不利于将蓝绿发布和 GitOps 流水线进行整合。\n\n3. 蓝绿发布自动化\n3.1 创建命名空间\nkubectl create namespace argo-rollouts  \n3.2 安装 argo-rollouts\nkubectl apply -n argo-rollouts -f https:&#47;&#47;ghproxy.com&#47;https:&#47;&#47;github.com&#47;argoproj&#47;argo-rollouts&#47;releases&#47;latest&#47;download&#47;install.yaml\n3.3 等待\nkubectl wait --for=condition=Ready pods --all -n argo-rollouts --timeout=300s\n3.4 创建 Rollout 对象——blue-green-rollout.yaml \n重点理解：strategy 字段是用来定义部署策略的。其中，autoPromotionEnabled 字段表示自动实施蓝绿发布，activeService 用来关联蓝绿发布的 Service，也就是我们在后续要创建的 Service 名称。\n\n3.5 创建 Service 和 Ingress\nkubectl apply -f blue-green-service.yaml\nkubectl apply -f blue-green-ingress.yaml\n\n3.6 切换操作对象是Rollouts，是编辑 blue-green-rollout.yaml 文件的 image 字段，将 blue 修改为 green 版本，然后kubectl apply -f blue-green-rollout.yaml\n流量切换过程将由 Argo Rollout 自动控制。\n\n3.7 访问 Argo Rollout Dashboard\n$ brew install argoproj&#47;tap&#47;kubectl-argo-rollouts\n检查版本\nkubectl argo rollouts version\n部署dashboard\nkubectl argo rollouts dashboard\n\n4. 当我们需要重新回滚到蓝色环境时，Argo Rollout 只需调整蓝色环境的 ReplicaSet 副本数并且修改 Service 的选择器，就可以回滚","like_count":0}]}