{"id":245259,"title":"14 | 十面埋伏的并发：多线程真的很难吗？","content":"<p>你好，我是Chrono。</p><p>今天，我们来聊聊“并发”（Concurrency）、“多线程”（multithreading）。</p><p>在20年前，大多数人（当然也包括我）对这两个词还是十分陌生的。那个时候，CPU的性能不高，要做的事情也比较少，没什么并发的需求，简单的单进程、单线程就能够解决大多数问题。</p><p>但到了现在，计算机硬件飞速发展，不仅主频上G，还有了多核心，运算能力大幅度提升，只使用单线程很难“喂饱”CPU。而且，随着互联网、大数据、音频视频处理等新需求的不断涌现，运算量也越来越大。这些软硬件上的变化迫使“并发”“多线程”成为了每个技术人都不得不面对的课题。</p><p>通俗地说，“并发”是指在一个时间段里有多个操作在同时进行，与“多线程”并不是一回事。</p><p>并发有很多种实现方式，而多线程只是其中最常用的一种手段。不过，因为多线程已经有了很多年的实际应用，也有很多研究成果、应用模式和成熟的软硬件支持，所以，对这两者的区分一般也不太严格，下面我主要来谈多线程。</p><h2>认识线程和多线程</h2><p>要掌握多线程，就要先了解线程（thread）。</p><p>线程的概念可以分成好几个层次，从CPU、操作系统等不同的角度看，它的定义也不同。今天，我们单从语言的角度来看线程。</p><!-- [[[read_end]]] --><p><strong>在C++语言里，线程就是一个能够独立运行的函数</strong>。比如你写一个lambda表达式，就可以让它在线程里跑起来：</p><pre><code>auto f = []()                // 定义一个lambda表达式\n{\n    cout &lt;&lt; &quot;tid=&quot; &lt;&lt;\n        this_thread::get_id() &lt;&lt; endl;\n};\n\nthread t(f);                // 启动一个线程，运行函数f\n</code></pre><p>任何程序一开始就有一个主线程，它从main()开始运行。主线程可以调用接口函数，创建出子线程。子线程会立即脱离主线程的控制流程，单独运行，但共享主线程的数据。程序创建出多个子线程，执行多个不同的函数，也就成了多线程。</p><p>多线程的好处你肯定能列出好几条，比如任务并行、避免I/O阻塞、充分利用CPU、提高用户界面响应速度，等等。</p><p>不过，多线程也对程序员的思维、能力提出了极大的挑战。不夸张地说，它带来的麻烦可能要比好处更多。</p><p>这个问题相信你也很清楚，随手就能数出几个来，比如同步、死锁、数据竞争、系统调度开销等……每个写过实际多线程应用的人，可能都有“一肚子的苦水”。</p><p>其实，多线程编程这件事“说难也不难，说不难也难”。这句话听上去好像有点自相矛盾，但却有一定的道理。为什么这么说呢？</p><p>说它不难，是因为线程本身的概念是很简单的，只要规划好要做的工作，不与外部有过多的竞争读写，很容易就能避开“坑”，充分利用多线程，“跑满”CPU。</p><p>说它难，则是因为现实的业务往往非常复杂，很难做到完美的解耦。一旦线程之间有共享数据的需求，麻烦就接踵而至，因为要考虑各种情况、用各种手段去同步数据。随着线程数量的增加，复杂程度会以几何量级攀升，一不小心就可能会导致灾难性的后果。</p><p>多线程涵盖的知识点太多，许多大师、高手都不敢自称精通，想用一节课把多线程开发说清楚是完全不可能的。</p><p>所以，今天我们只聚焦C++的标准库，了解下标准库为多线程编程提供了哪些工具，在语言层面怎么改善多线程应用。有了这个基础，你再去看那些专著时，就可以省很多力气，开发时也能少走些弯路。</p><p>首先，你要知道一个最基本但也最容易被忽视的常识：<strong>“读而不写”就不会有数据竞争</strong>。</p><p>所以，在C++多线程编程里读取const变量总是安全的，对类调用const成员函数、对容器调用只读算法也总是线程安全的。</p><p>知道了这一点，你就应该多实践<a href=\"https://time.geekbang.org/column/article/238486\">第7讲</a>里的做法，多用const关键字，尽可能让操作都是只读的，为多线程打造一个坚实的基础。</p><p>然后，我要说一个多线程开发的原则，也是一句“自相矛盾”的话：</p><blockquote>\n<p>最好的并发就是没有并发，最好的多线程就是没有线程。</p>\n</blockquote><p>这又是什么意思呢？</p><p>简单来说，就是在大的、宏观的层面上“看得到”并发和线程，而在小的、微观的层面上“看不到”线程，减少死锁、同步等恶性问题的出现几率。</p><h2>多线程开发实践</h2><p>下面，我就来讲讲具体该怎么实践这个原则。在C++里，有四个基本的工具：仅调用一次、线程局部存储、原子变量和线程对象。</p><h3>仅调用一次</h3><p>程序免不了要初始化数据，这在多线程里却是一个不大不小的麻烦。因为线程并发，如果没有某种同步手段来控制，会导致初始化函数多次运行。</p><p>为此，C++提供了“仅调用一次”的功能，可以很轻松地解决这个问题。</p><p>这个功能用起来很简单，你要先声明一个<strong>once_flag</strong>类型的变量，最好是静态、全局的（线程可见），作为初始化的标志：</p><pre><code>static std::once_flag flag;        // 全局的初始化标志\n</code></pre><p>然后调用专门的<strong>call_once()</strong>函数，以函数式编程的方式，传递这个标志和初始化函数。这样C++就会保证，即使多个线程重入call_once()，也只能有一个线程会成功运行初始化。</p><p>下面是一个简单的示例，使用了lambda表达式来模拟实际的线程函数。你可以把<a href=\"https://github.com/chronolaw/cpp_study/blob/master/section3/thread.cpp\">GitHub仓库</a>里的代码下到本地，实际编译运行看看效果：</p><pre><code>auto f = []()                // 在线程里运行的lambda表达式\n{   \n    std::call_once(flag,      // 仅一次调用，注意要传flag\n        [](){                // 匿名lambda，初始化函数，只会执行一次\n            cout &lt;&lt; &quot;only once&quot; &lt;&lt; endl;\n        }                  // 匿名lambda结束\n    );                     // 在线程里运行的lambda表达式结束\n};\n\nthread t1(f);            // 启动两个线程，运行函数f\nthread t2(f);\n</code></pre><p>call_once()完全消除了初始化时的并发冲突，在它的调用位置根本看不到并发和线程。所以，按照刚才说的基本原则，它是一个很好的多线程工具。</p><p>它也可以很轻松地解决多线程领域里令人头疼的“双重检查锁定”问题，你可以自己试一试，用它替代锁定来初始化。</p><h3>线程局部存储</h3><p>读写全局（或者局部静态）变量是另一个比较常见的数据竞争场景，因为共享数据，多线程操作时就有可能导致状态不一致。</p><p>但如果仔细分析的话，你会发现，有的时候，全局变量并不一定是必须共享的，可能仅仅是为了方便线程传入传出数据，或者是本地cache，而不是为了共享所有权。</p><p>换句话说，这应该是线程独占所有权，不应该在多线程之间共同拥有，术语叫“<strong>线程局部存储</strong>”（thread local storage）。</p><p>这个功能在C++里由关键字<strong>thread_local</strong>实现，它是一个和static、extern同级的变量存储说明，有thread_local标记的变量在每个线程里都会有一个独立的副本，是“线程独占”的，所以就不会有竞争读写的问题。</p><p>下面是示范thread_local的代码，先定义了一个线程独占变量，然后用lambda表达式捕获引用，再放进多个线程里运行：</p><pre><code>thread_local int n = 0;        // 线程局部存储变量\n\nauto f = [&amp;](int x)           // 在线程里运行的lambda表达式，捕获引用\n{   \n    n += x;                   // 使用线程局部变量，互不影响\n    cout &lt;&lt; n;                // 输出，验证结果\n};  \n\nthread t1(f, 10);           // 启动两个线程，运行函数f\nthread t2(f, 20);\n</code></pre><p>在程序执行后，我们可以看到，两个线程分别输出了10和20，互不干扰。</p><p>你可以试着把变量的声明改成static，再运行一下。这时，因为两个线程共享变量，所以n就被连加了两次，最后的结果就是30。</p><pre><code>static int n = 0;    // 静态全局变量\n...                   // 代码与刚才的相同\n</code></pre><p>和call_once()一样，thread_local也很容易使用。但它的应用场合不是那么显而易见的，这要求你对线程的共享数据有清楚的认识，区分出独占的那部分，消除多线程对变量的并发访问。</p><h3>原子变量</h3><p>那么，对于那些非独占、必须共享的数据，该怎么办呢？</p><p>要想保证多线程读写共享数据的一致性，关键是<strong>要解决同步问题</strong>，不能让两个线程同时写，也就是“互斥”。</p><p>这在多线程编程里早就有解决方案了，就是互斥量（Mutex）。但它的成本太高，所以，对于小数据，应该采用“<strong>原子化</strong>”这个更好的方案。</p><p>所谓原子（atomic），在多线程领域里的意思就是不可分的。操作要么完成，要么未完成，不能被任何外部操作打断，总是有一个确定的、完整的状态。所以也就不会存在竞争读写的问题，不需要使用互斥量来同步，成本也就更低。</p><p>但不是所有的操作都可以原子化的，否则多线程编程就太轻松了。目前，C++只能让一些最基本的类型原子化，比如atomic_int、atomic_long，等等：</p><pre><code>using atomic_bool = std::atomic&lt;bool&gt;;    // 原子化的bool\nusing atomic_int  = std::atomic&lt;int&gt;;      // 原子化的int\nusing atomic_long = std::atomic&lt;long&gt;;    // 原子化的long\n</code></pre><p>这些原子变量都是模板类atomic的特化形式，包装了原始的类型，具有相同的接口，用起来和bool、int几乎一模一样，但却是原子化的，多线程读写不会出错。</p><p>注意，我说了“几乎”这个词。它还是有些不同的，一个重要的区别是，<strong>原子变量禁用了拷贝构造函数，所以在初始化的时候不能用“=”的赋值形式，只能用圆括号或者花括号</strong>：</p><pre><code>atomic_int  x {0};          // 初始化，不能用=\natomic_long y {1000L};      // 初始化，只能用圆括号或者花括号\n\nassert(++x == 1);           // 自增运算\n\ny += 200;                   // 加法运算\nassert(y &lt; 2000);           // 比较运算 \n</code></pre><p>除了模拟整数运算，原子变量还有一些特殊的原子操作，比如store、load、fetch_add、fetch_sub、exchange、compare_exchange_weak/compare_exchange_strong，最后一组就是著名的CAS（Compare And Swap）操作。</p><p>而另一个同样著名的TAS（Test And Set）操作，则需要用到一个特殊的原子类型atomic_flag。</p><p>它不是简单的bool特化（atomic<bool>），没有store、load的操作，只用来实现TAS，保证绝对无锁。</bool></p><p>你能用这些原子变量做些什么呢？</p><p>最基本的用法是把原子变量当作线程安全的全局计数器或者标志位，这也算是“初心”吧。但它还有一个更重要的应用领域，就是实现高效的无锁数据结构（lock-free）。</p><p>但我<strong>强烈不建议</strong>你自己尝试去写无锁数据结构，因为无锁编程的难度比使用互斥量更高，可能会掉到各种难以察觉的“坑”（例如ABA）里，最好还是用现成的库。</p><p>遗憾的是，标准库在这方面帮不了你，虽然网上可以找到不少开源的无锁数据结构，但经过实际检验的不多，我个人觉得你可以考虑<strong>boost.lock_free</strong>。</p><h3>线程</h3><p>到现在我说了call_once、thread_local和atomic这三个C++里的工具，它们都不与线程直接相关，但却能够用于多线程编程，尽量消除显式地使用线程。</p><p>但是，必须要用线程的时候，我们也不能逃避。</p><p>C++标准库里有专门的线程类thread，使用它就可以简单地创建线程，在名字空间std::this_thread里，还有yield()、get_id()、sleep_for()、sleep_until()等几个方便的管理函数。因为它们的用法比较简单，资料也随处可见，我就不再重复了。</p><p>下面的代码同时示范了thread和atomic的用法：</p><pre><code>static atomic_flag flag {false};    // 原子化的标志量\nstatic atomic_int  n;               // 原子化的int\n\nauto f = [&amp;]()              // 在线程里运行的lambda表达式，捕获引用\n{\n    auto value = flag.test_and_set();  // TAS检查原子标志量\n\n    if (value) {\n        cout &lt;&lt; &quot;flag has been set.&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;set flag by &quot; &lt;&lt;\n            this_thread::get_id() &lt;&lt; endl;  // 输出线程id\n    }\n\n    n += 100;                    // 原子变量加法运算\n\n    this_thread::sleep_for(      // 线程睡眠\n        n.load() * 10ms);        // 使用时间字面量\n    cout &lt;&lt; n &lt;&lt; endl;\n};                        // 在线程里运行的lambda表达式结束\n\nthread t1(f);                // 启动两个线程，运行函数f\nthread t2(f);\n\nt1.join();                   // 等待线程结束    \nt2.join();\n</code></pre><p>但还是基于那个原则，我建议你不要直接使用thread这个“原始”的线程概念，最好把它隐藏到底层，因为“看不到的线程才是好线程”。</p><p>具体的做法是调用函数async()，它的含义是“<strong>异步运行</strong>”一个任务，隐含的动作是启动一个线程去执行，但不绝对保证立即启动（也可以在第一个参数传递std::launch::async，要求立即启动线程）。</p><p>大多数thread能做的事情也可以用async()来实现，但不会看到明显的线程：</p><pre><code>auto task = [](auto x)                  // 在线程里运行的lambda表达式\n{\n    this_thread::sleep_for( x * 1ms);  // 线程睡眠\n    cout &lt;&lt; &quot;sleep for &quot; &lt;&lt; x &lt;&lt; endl;\n    return x;\n};\n\nauto f = std::async(task, 10);         // 启动一个异步任务\nf.wait();                              // 等待任务完成\n\nassert(f.valid());                    // 确实已经完成了任务\ncout &lt;&lt; f.get() &lt;&lt; endl;              // 获取任务的执行结果\n</code></pre><p>其实，这还是函数式编程的思路，在更高的抽象级别上去看待问题，异步并发多个任务，让底层去自动管理线程，要比我们自己手动控制更好（比如内部使用线程池或者其他机制）。</p><p>async()会返回一个future变量，可以认为是代表了执行结果的“期货”，如果任务有返回值，就可以用成员函数get()获取。</p><p>不过要特别注意，get()只能调一次，再次获取结果会发生错误，抛出异常std::future_error。（至于为什么这么设计我也不太清楚，没找到官方的解释）</p><p>另外，这里还有一个很隐蔽的“坑”，如果你不显式获取async()的返回值（即future对象），它就会<strong>同步阻塞</strong>直至任务完成（由于临时对象的析构函数），于是“async”就变成了“sync”。</p><p>所以，即使我们不关心返回值，也总要用auto来配合async()，避免同步阻塞，就像下面的示例代码那样：</p><pre><code>std::async(task, ...);            // 没有显式获取future，被同步阻塞\nauto f = std::async(task, ...);   // 只有上一个任务完成后才能被执行\n</code></pre><p>标准库里还有mutex、lock_guard、condition_variable、promise等很多工具，不过它们大多数都是广为人知的概念在C++里的具体实现，用法上没太多新意，所以我就不再多介绍了。</p><h2>小结</h2><p>说了这么长时间，你可能会有些奇怪，这节课的标题里有线程，但我并没有讲太多线程相关的东西，更多的是在讲“不用线程”的思维方式。</p><p>所谓“当局者迷”，如果你一头扎进多线程的世界，全力去研究线程、互斥量、锁等细节，就很容易“钻进死胡同”“一条道走到黑”。</p><p>很多时候，我们应该跳出具体的编码，换个角度来看问题，也许就能够“柳暗花明又一村”，得到新的、优雅的解决办法。</p><p>好了，今天就到这里，做个小结：</p><ol>\n<li>多线程是并发最常用的实现方式，好处是任务并行、避免阻塞，坏处是开发难度高，有数据竞争、死锁等很多“坑”；</li>\n<li>call_once()实现了仅调用一次的功能，避免多线程初始化时的冲突；</li>\n<li>thread_local实现了线程局部存储，让每个线程都独立访问数据，互不干扰；</li>\n<li>atomic实现了原子化变量，可以用作线程安全的计数器，也可以实现无锁数据结构；</li>\n<li>async()启动一个异步任务，相当于开了一个线程，但内部通常会有优化，比直接使用线程更好。</li>\n</ol><p>我再告诉你一个好消息：C++20正式加入了协程（关键字co_wait/co_yield/co_return）。它是用户态的线程，没有系统级线程那么多的麻烦事，使用它就可以写出开销更低、性能更高的并发程序。让我们一起期待吧！</p><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>你在多线程编程的时候遇到过哪些“坑”，有什么经验教训？</li>\n<li>你觉得async()比直接用thread启动线程好在哪里？</li>\n</ol><p>欢迎在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/d2/3fee7b3958a1780a3441c49b89288dd2.jpg?wh=2000*3214\" alt=\"\"></p>","neighbors":{"left":{"article_title":"13 | 五花八门的算法：不要再手写for循环了","id":243357},"right":{"article_title":"15 | 序列化：简单通用的数据交换格式有哪些？","id":245880}},"comments":[{"had_liked":false,"id":232614,"user_name":"战斗机二虎🐯","can_delete":false,"product_type":"c1","uid":1157201,"ip_address":"","ucode":"8AB69AD2D76784","user_header":"https://static001.geekbang.org/account/avatar/00/11/a8/51/46a788b1.jpg","comment_is_top":false,"comment_ctime":1594050422,"is_pvip":false,"replies":[{"id":"85874","content":"对，Nginx的自旋锁代码非常精致，值得学习。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594082949,"ip_address":"","comment_id":232614,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74608494454","product_id":100051801,"comment_content":"nginx的自旋锁实现就是一个非常成功的工程级的自旋锁","like_count":18,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500708,"discussion_content":"对，Nginx的自旋锁代码非常精致，值得学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594082949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224799,"user_name":"泡泡龙","can_delete":false,"product_type":"c1","uid":1208655,"ip_address":"","ucode":"8D43010FA3DC2C","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/4f/bce0d5bc.jpg","comment_is_top":false,"comment_ctime":1591542549,"is_pvip":true,"replies":[{"id":"82756","content":"多线程调试从来都不是个简单的工作，一般都是打日志，里面列出线程号和使用的变量，然后再慢慢分析。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591577698,"ip_address":"","comment_id":224799,"utype":1}],"discussion_count":2,"race_medal":2,"score":"70311019285","product_id":100051801,"comment_content":"虽然没有C++的多线程经验，但是记得其他语言的多线程，用IDE打断点调试是一个极难的问题","like_count":17,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497609,"discussion_content":"多线程调试从来都不是个简单的工作，一般都是打日志，里面列出线程号和使用的变量，然后再慢慢分析。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591577698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2401841,"avatar":"https://static001.geekbang.org/account/avatar/00/24/a6/31/0242f7d6.jpg","nickname":"ywz","note":"","ucode":"A93F43B3506FA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379070,"discussion_content":"多线程调试打日志的话会不会有点太多了？有没有其他的调试手段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623660386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224653,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1591497550,"is_pvip":true,"replies":[{"id":"82700","content":"这种想法是非常危险的，一定要特别注意。<br><br>volatile只是表示变量易变，与线程没有任何关系。<br><br>不加锁应该用atomic变量。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591531543,"ip_address":"","comment_id":224653,"utype":1}],"discussion_count":9,"race_medal":0,"score":"44541170510","product_id":100051801,"comment_content":"老师你好，假如一个变量用volatile修饰，是不是就可以不用加锁？","like_count":10,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497556,"discussion_content":"这种想法是非常危险的，一定要特别注意。\n\nvolatile只是表示变量易变，与线程没有任何关系。\n\n不加锁应该用atomic变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591531543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1216924,"avatar":"https://static001.geekbang.org/account/avatar/00/12/91/9c/3d630e3a.jpg","nickname":"萌萌岛主","note":"","ucode":"B749FBB922E396","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303253,"discussion_content":"了解一下单例模式的double-check","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599201650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1126649,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/f9/c0d1af4f.jpg","nickname":"三好码农","note":"","ucode":"1C118F2234F345","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297910,"discussion_content":"cpp萌新，也来交流一波，我的理解，java中volatile可以保证可见性，cpp中应该是一样的语义，没法保证线程安全，但是配合cas可以做到无锁，","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597109982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1807943,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","nickname":"出卖灵魂的教练Kerry","note":"","ucode":"8C64517DA556FE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1126649,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/f9/c0d1af4f.jpg","nickname":"三好码农","note":"","ucode":"1C118F2234F345","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297930,"discussion_content":"是的，当时我也是看了java的保证，才有这个想法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597113061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297910,"ip_address":""},"score":297930,"extra":""},{"author":{"id":2311396,"avatar":"","nickname":"JY","note":"","ucode":"5DE1DC047946E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1126649,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/f9/c0d1af4f.jpg","nickname":"三好码农","note":"","ucode":"1C118F2234F345","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327418,"discussion_content":"可见性，是关键","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605834270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297910,"ip_address":""},"score":327418,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1126649,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/f9/c0d1af4f.jpg","nickname":"三好码农","note":"","ucode":"1C118F2234F345","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359797,"discussion_content":"C++ 中的 volatile 和 Java 语义完全不同，跟多线程可以说没有任何关系。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1616293076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297910,"ip_address":""},"score":359797,"extra":""}]},{"author":{"id":2763179,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/29/ab/59a6e437.jpg","nickname":"Kevin","note":"","ucode":"3588850B3370C8","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410613,"discussion_content":"老师成功地帮我解惑了atomic和volatile，感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635741061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367639,"discussion_content":"我看到一篇博客里讲到volatile表示这变量可能会被意想不到地改变，提示编译器不要优化该变量,作者建议用volatile修饰在多个线程中使用的原生类型变量.不知道里面说的对不对? https://www.cnblogs.com/Stephen-Qin/p/11388620.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618411142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259818,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1047043,"ip_address":"","ucode":"651F1390B64953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/619e3e48.jpg","comment_is_top":false,"comment_ctime":1604846102,"is_pvip":true,"replies":[{"id":"94406","content":"很好的例子，赞。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1604886679,"ip_address":"","comment_id":259818,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18784715286","product_id":100051801,"comment_content":"async那里隐含的坑可以结合如下代码验证：<br>```<br>auto task = [](auto x)<br>    {<br>        &#47;&#47;using namespace std::chrono_literals;<br><br>        this_thread::sleep_for( x * 1ms);<br><br>        cout &lt;&lt; &quot;sleep for &quot; &lt;&lt; x &lt;&lt; endl;<br><br>        return x;<br>    };<br>    &#47;&#47;先输出Hello,world<br>    auto f = std::async(task, 100);<br><br>    cout &lt;&lt; &quot;Hello,world&quot; &lt;&lt; endl;<br><br>#if 0<br>    &#47;&#47;先输出sleep for 100<br>    std::async(task, 100);<br><br>    cout &lt;&lt; &quot;Hello,world&quot; &lt;&lt; endl;<br>#endif<br>    return 0;<br>```","like_count":5,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509036,"discussion_content":"很好的例子，赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604886679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238554,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1596197551,"is_pvip":false,"replies":[{"id":"88275","content":"callback并不能实现异步，但异步多用callback来实现解耦回调，比如actor和proactor这两种异步模式。<br><br>我理解的阻塞有两种，一种是io阻塞，一种是cpu计算量阻塞，前者可以用异步回调来避免，而后者就只能用多线程了。<br><br>目前在C++里，异步编程主要还是用多线程，而callback难于使用和理解，把处理流程分割的支离破碎，以后可能会用协程更好。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1596416950,"ip_address":"","comment_id":238554,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18776066735","product_id":100051801,"comment_content":"C++内怎么做异步呢？<br>1. Callback<br>2.多线程+Callback<br><br>但是这两个都有个问题，callback也是会阻塞的。如果有A B C D四个流程，B C D分别依赖于前一个的输出，这种callback就会调用栈太深，容易爆栈。<br><br>最近对异步编程模式产生了些疑问，应该怎么解决？","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502786,"discussion_content":"callback并不能实现异步，但异步多用callback来实现解耦回调，比如actor和proactor这两种异步模式。\n\n我理解的阻塞有两种，一种是io阻塞，一种是cpu计算量阻塞，前者可以用异步回调来避免，而后者就只能用多线程了。\n\n目前在C++里，异步编程主要还是用多线程，而callback难于使用和理解，把处理流程分割的支离破碎，以后可能会用协程更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596416950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226663,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1592182467,"is_pvip":false,"replies":[{"id":"83439","content":"async内部可能有优化，注意，只是可能，要看编译器具体怎么做，也可能不会优化，而且我们也无法控制他。<br><br>想要用线程池，还是得自己写，不过其实也比较简单，创建多个线程用list容纳就可以了。<br><br>可以参考boost.thread_pool，它就是这么做的。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592183595,"ip_address":"","comment_id":226663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18772051651","product_id":100051801,"comment_content":"（比如内部使用线程池或者其他机制）。那么async怎么跟线程池结合呢？老师有没有一些好的参考资料提供哈","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498325,"discussion_content":"async内部可能有优化，注意，只是可能，要看编译器具体怎么做，也可能不会优化，而且我们也无法控制他。\n\n想要用线程池，还是得自己写，不过其实也比较简单，创建多个线程用list容纳就可以了。\n\n可以参考boost.thread_pool，它就是这么做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592183595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225826,"user_name":"二杠一","can_delete":false,"product_type":"c1","uid":1141324,"ip_address":"","ucode":"040C9A30E7ADF4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dDk3WicuUbhvcb4R8PD0YiaFteqQvC4UpXHw4chKLDKB0qaOGeCxBJ3nfiaNZAyVQmAgesyE2MvABydxg6gic29j5w/132","comment_is_top":false,"comment_ctime":1591867846,"is_pvip":true,"replies":[{"id":"83205","content":"在C++11&#47;14里好像只能这样，在C++20里好像多了一个新的cout对象，是线程安全的。<br><br>不过我不太建议在多线程里用cout，一是不安全，二是也没什么意义，改成写日志文件的方式可能会更好。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591879905,"ip_address":"","comment_id":225826,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18771737030","product_id":100051801,"comment_content":"老师，在多个线程里同时往输出流输出，怎么保证一个线程的单次输出操作是完整的 ? 比如&quot;std::cout &lt;&lt; x &lt;&lt; std::endl;&quot;怎么保证不会漏掉&quot;std::endl&quot;这个输出，只能加锁吗？","like_count":5,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498007,"discussion_content":"在C++11/14里好像只能这样，在C++20里好像多了一个新的cout对象，是线程安全的。\n\n不过我不太建议在多线程里用cout，一是不安全，二是也没什么意义，改成写日志文件的方式可能会更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591879905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323104,"discussion_content":"很多开源的日志库都支持多线程，可以上GitHub找一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604886834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2149899,"avatar":"https://static001.geekbang.org/account/avatar/00/20/ce/0b/b1e244e6.jpg","nickname":"IMBFD","note":"","ucode":"2E7B3D01C537A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308290,"discussion_content":"写日志是不是也要用支持多线程的日志库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600909284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224497,"user_name":"被讨厌的勇气","can_delete":false,"product_type":"c1","uid":1547913,"ip_address":"","ucode":"AE3B3CA27D91A2","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","comment_is_top":false,"comment_ctime":1591418990,"is_pvip":false,"replies":[{"id":"82633","content":"<br>1.基本正确，async()是一种相当简化的线程用法，目的就是获取future值，如果不是这个场景就不如thread灵活。<br><br>2.比如说线程里要保存一些cache数据，很显然这些cache不会是多线程共享的，用thread_local就比较好。可以把它理解成是专门给线程准备的static全局变量。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591430021,"ip_address":"","comment_id":224497,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14476320878","product_id":100051801,"comment_content":"当需要获取线程的结果时，使用async可以直接获取其结果；使用thread则需要通过共享数据来获取，需要使用锁、条件变量。<br><br>async的缺点是只能获取一次。若需要保证线程一直运行，多次获取其‘结果’时，只能使用thread + condition_variable,不知道这样理解对不对？<br><br>thread_local的应用场景问题。若不需要共享数据，直接在lambad表达式中的捕获列表中进行值捕获不就每个线程一个副本了，没想出来必须使用thread_local的应用场景。","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497495,"discussion_content":"\n1.基本正确，async()是一种相当简化的线程用法，目的就是获取future值，如果不是这个场景就不如thread灵活。\n\n2.比如说线程里要保存一些cache数据，很显然这些cache不会是多线程共享的，用thread_local就比较好。可以把它理解成是专门给线程准备的static全局变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591430021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1209939,"avatar":"https://static001.geekbang.org/account/avatar/00/12/76/53/21d62a23.jpg","nickname":"鲁·本","note":"","ucode":"F1DEB30C21B48E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301244,"discussion_content":"比如线程内部用到的cache变量，如果用局部变量就需要在各个函数间传递参数，如果用local_thread就可以在函数内部直接访问，不用担心线程间访问冲突，因为是每个线程一个版本. 想想errno就好理解了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598451123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224457,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1591407014,"is_pvip":false,"replies":[{"id":"82629","content":"也不一定，看传给子线程什么参数了，局部变量也可以给子线程共享。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591429653,"ip_address":"","comment_id":224457,"utype":1}],"discussion_count":5,"race_medal":0,"score":"14476308902","product_id":100051801,"comment_content":"子线程会立即脱离主线程的控制流程，单独运行，但共享主线程的数据。这里指的是全局变量吧，像局部变量应该不行吧？","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497482,"discussion_content":"也不一定，看传给子线程什么参数了，局部变量也可以给子线程共享。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591429653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279857,"discussion_content":"罗老师，栈上的局部变量也可以共享吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591435876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1547913,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","nickname":"被讨厌的勇气","note":"","ucode":"AE3B3CA27D91A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279883,"discussion_content":"你可以传局部变量的引用进去，std:: ref (para)，默认是拷贝或移动，使用上面这种形式传递的就是引用，或指向局部变量的指针也能共享，语法是这样，但一般不这么使。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591444078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":279857,"ip_address":""},"score":279883,"extra":""},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1547913,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","nickname":"被讨厌的勇气","note":"","ucode":"AE3B3CA27D91A2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280027,"discussion_content":"嗯嗯，膜拜大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591458784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":279883,"ip_address":""},"score":280027,"extra":""}]},{"author":{"id":1547913,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","nickname":"被讨厌的勇气","note":"","ucode":"AE3B3CA27D91A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279803,"discussion_content":"是的。局部变量是在栈空间存储的（不包含局部静态变量），并不共享。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591419119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289847,"user_name":"dog_brother","can_delete":false,"product_type":"c1","uid":1619597,"ip_address":"","ucode":"9F64D3C6D815FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","comment_is_top":false,"comment_ctime":1619229659,"is_pvip":true,"replies":[{"id":"105113","content":"这个还是看怎么用吧，仔细看它的api，真正有哪些坑只有自己实际使用了才能知道，也许不会遇到那些坑。<br><br>thread使用起来很方便，其实就是对操作系统线程接口的封装，可以先小范围使用，再逐步替换pthread。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1619237307,"ip_address":"","comment_id":289847,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10209164251","product_id":100051801,"comment_content":"老师，我们生产环境是c++ 11，但是我们几乎不使用std的thread，主要是pthread系列函数。听说是因为std thread的坑比较多。","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519032,"discussion_content":"这个还是看怎么用吧，仔细看它的api，真正有哪些坑只有自己实际使用了才能知道，也许不会遇到那些坑。\n\nthread使用起来很方便，其实就是对操作系统线程接口的封装，可以先小范围使用，再逐步替换pthread。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619237307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288140,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1618319562,"is_pvip":false,"replies":[{"id":"104609","content":"说的很对，多线程的坑很多，很容易掉进去，所以应当尽量以“不用线程”的方式使用线程。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1618361922,"ip_address":"","comment_id":288140,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10208254154","product_id":100051801,"comment_content":"1.遇到的坑:分不清当前变量是在主线程中还是在子线程中.  教训:子线程函数入口run中的内容才算是在子线程中.<br><br>2.async函数,是一种更高层的异步方式.它不必显式手写join函数来让主线程等待子线程.它可以用std::future类型的变量来接收线程函数运行的结果,并通过get()的方法来获得结果.这样就不必像thread那样提前定义一个全局变量,在线程函数中进行赋值操作. 此外async还可以指定线程创建策略--是立马执行还是延迟执行.","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518526,"discussion_content":"说的很对，多线程的坑很多，很容易掉进去，所以应当尽量以“不用线程”的方式使用线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618361922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287632,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1618059535,"is_pvip":false,"replies":[{"id":"104450","content":"在多线程的场景里，是不能简单判断指针空的，有那个著名的双重检查锁定的问题。<br><br>至于具体的场景还真是不太好找，call_once是C++为我们提供的一个方便的工具，具体怎么用、用不用还是在于我们自己。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1618062527,"ip_address":"","comment_id":287632,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5913026831","product_id":100051801,"comment_content":"老师,这里有一个问题,既然不想让子线程重复调用初始化函数,应该可以在子线程创建之前调用一次初始化函数,为何还要设计call_once()函数呢?我搜了下call_once的用法,网上大多给的是简单的打印,复杂一些的有单例模式的用法,但单例模式完全可以通过判断m_pSingleton是否为空的方法来做.所以就更加想要知道真实情况下使用的场景.所以想让老师给出一个场景,或者给一个链接.谢谢老师.","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518373,"discussion_content":"在多线程的场景里，是不能简单判断指针空的，有那个著名的双重检查锁定的问题。\n\n至于具体的场景还真是不太好找，call_once是C++为我们提供的一个方便的工具，具体怎么用、用不用还是在于我们自己。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618062527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1304195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtlEYuHnR8VdRkNPcmkIqTM9DKahpcpicDdBvcmBWMIAAhBrd0QNWvl09slqrzB5TibryVcIfPmb7Q/132","nickname":"raisecomer","note":"","ucode":"32EA488E46471F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379453,"discussion_content":"如果初始化函数是在子线程满足某种条件时才进行调用，若不需要可能就不会调用了。但是，如果在子线程创建之前调用一次初始化函数，那就是不管需不需要，都要无条件的调用了，万一子线程用不着呢，不浪费资源吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623913203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366444,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618063645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225986,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1591924701,"is_pvip":false,"replies":[{"id":"83257","content":"不是，这个是典型的reader-writer问题了，写操作可能会变动容器的大小、元素内容。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591928874,"ip_address":"","comment_id":225986,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5886891997","product_id":100051801,"comment_content":"老师，如果一个线程在写容器，另一个线程对容器调用只读算法也总是线程安全的吗？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498070,"discussion_content":"不是，这个是典型的reader-writer问题了，写操作可能会变动容器的大小、元素内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591928874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224519,"user_name":"lckfa李钊","can_delete":false,"product_type":"c1","uid":1356899,"ip_address":"","ucode":"AD13D205104AA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/63/84960032.jpg","comment_is_top":false,"comment_ctime":1591427822,"is_pvip":false,"replies":[{"id":"82664","content":"<br>1.thread的概念已经被大多数人熟知了，而async()用的比较少，所以我想让大家多了解它，让它在合适的地方去替代thread，简化多线程编程。<br><br>当然了，aysnc()也是不可能完全替代thread，各有优缺点吧。<br><br>2.node.js里面用的是epoll，跟线程没啥关系，等到C++20、23把networking和协程弄完善了，我们也可以用C++轻松写出高效的并发代码。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591446675,"ip_address":"","comment_id":224519,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5886395118","product_id":100051801,"comment_content":"线程 好开，不好关，Windows下有直接回收线程句柄强行关闭线程的api，但是很明显，这不是什么好的实践。线程最好的关闭方式 是让它自然消亡。<br>对于某些场景我们需要使用守护线程或者监控线程，里面跑着要一直循环执行的任务，那么这个任务怎么停止就是个大问题。假设我们有一个ui线程，里面有些指针，而这些指针被守护线程里的无限循环任务使用，当UI线程被关闭，这些指针被UI线程回收，而守护线程还在使用这些指针的话，程序就表现在用户关闭时崩溃了。<br>对于这种问题，第一层，我们会使用event之类的方式进行线程之间的通信（同步），在UI线程关闭前通知守护线程先关闭，所以循环的停止条件（之一）就是收到由UI线程关闭时发出的event。第二层，守护线程已经运行到循环体里了，此时并不会检查event，还是可能操作一个已经被UI线程回收的指针，我想到的解决思路就是要UI线程的关闭也不能任性，必须等守护线程自然消亡后才能回收指针资源。第三层，干脆不在守护线程里操作UI线程里的指针，把程序再设计下，肯定有更好的解决方案。<br><br>关于async 和thread，我个人还是使用thread居多，当然了，async是thread的上层封装，好处是，使用起来更自然，而且，线程的返回值接收起来也方便，如果使用thread，要想获得任务返回值，呃....。但是，缺点也是存在的，async并不是很好用，首先async是定义在future中的，使用者需要了解诸如future ，promise ，启动参数等概念，不然会有一些误用。另外，作为C++程序员，总还是想理解得更底层些的，线程你帮我用标准库thread封装了，那么现在异步操作这种小事，我得自己来😀。哈哈，偏题了，其实理性的讲，现代C++早就走出了道的掣肘，而追求更多术的内在了；标准库肯定会越来越庞大，更高层次的封装，更快的开发效率早就是大势所趋，不然，为啥单线程的nodejs能把异步回调玩的风生水起，让大伙趋之若鹜呢，嗯，说远了。<br>","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497507,"discussion_content":"\n1.thread的概念已经被大多数人熟知了，而async()用的比较少，所以我想让大家多了解它，让它在合适的地方去替代thread，简化多线程编程。\n\n当然了，aysnc()也是不可能完全替代thread，各有优缺点吧。\n\n2.node.js里面用的是epoll，跟线程没啥关系，等到C++20、23把networking和协程弄完善了，我们也可以用C++轻松写出高效的并发代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591446675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054598,"avatar":"https://static001.geekbang.org/account/avatar/00/10/17/86/416f772e.jpg","nickname":"shelldon","note":"","ucode":"BF8FE102D6DD1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282587,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592021835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340842,"user_name":"Geek_69a925","can_delete":false,"product_type":"c1","uid":1711449,"ip_address":"","ucode":"E433AEC0659C33","user_header":"","comment_is_top":false,"comment_ctime":1649173253,"is_pvip":false,"replies":[{"id":"124647","content":"thread_local就是与static一样的变量声明方式，所以没有限制。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1649235763,"ip_address":"","comment_id":340842,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649173253","product_id":100051801,"comment_content":"老师，请问一下c++中thread_local变量的存储空间有没有限制呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560236,"discussion_content":"thread_local就是与static一样的变量声明方式，所以没有限制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649235763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337145,"user_name":"波波","can_delete":false,"product_type":"c1","uid":1701941,"ip_address":"","ucode":"7DE2935E0E786B","user_header":"https://static001.geekbang.org/account/avatar/00/19/f8/35/b6dd4ab5.jpg","comment_is_top":false,"comment_ctime":1646646341,"is_pvip":false,"replies":[{"id":"123259","content":"自从有了std::async我就基本不用boost::async了，抱歉啊。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1646726592,"ip_address":"","comment_id":337145,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646646341","product_id":100051801,"comment_content":"之前使用过Boost的async, 今天按老师您照教程使用了一下std::async, 发现两者有区别, 比如连着写3行async调用, boost.async会新开3个线程, 而3个std.async是共用一个线程. 这导致用std.async测试thread_local时被坑了\\哭\\哭","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555051,"discussion_content":"自从有了std::async我就基本不用boost::async了，抱歉啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646726592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328511,"user_name":"Geek_Chyq","can_delete":false,"product_type":"c1","uid":2103390,"ip_address":"","ucode":"216E124170DB8F","user_header":"https://static001.geekbang.org/account/avatar/00/20/18/5e/139a8403.jpg","comment_is_top":false,"comment_ctime":1640759088,"is_pvip":false,"replies":[{"id":"119719","content":"笑，看来是老朋友了。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1640827343,"ip_address":"","comment_id":328511,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640759088","product_id":100051801,"comment_content":"今天又在拜读Boost书籍，猛然发觉作者的名字好熟悉。经过和书上扉页照片多次比对（大佬定律，头发变少了而已），又在这里又遇见了。果然不会骗人，认定的，到哪都可以认定。罗老师好。哈","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542676,"discussion_content":"笑，看来是老朋友了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640827343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285178,"user_name":"图个啥呢","can_delete":false,"product_type":"c1","uid":1134984,"ip_address":"","ucode":"BEE1F1477056A2","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/88/232fe847.jpg","comment_is_top":false,"comment_ctime":1616658223,"is_pvip":false,"replies":[{"id":"103525","content":"应该是没有链接pthread库吧，加上-pthread试试。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1616713049,"ip_address":"","comment_id":285178,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616658223","product_id":100051801,"comment_content":"老师，好，linux系统运行call_once的例子的时候，出现了undefined reference to `pthread_create&#39;。这个要怎么解决？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517608,"discussion_content":"应该是没有链接pthread库吧，加上-pthread试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616713049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281822,"user_name":"木瓜","can_delete":false,"product_type":"c1","uid":1201914,"ip_address":"","ucode":"B24A54DEC7DB15","user_header":"https://static001.geekbang.org/account/avatar/00/12/56/fa/8ba604a6.jpg","comment_is_top":false,"comment_ctime":1614914247,"is_pvip":false,"replies":[{"id":"102318","content":"好像有本c++ concurrent in action吧，有同学留言推荐过，网上也有资源。<br><br>系统学习就是多看书多实践。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1614933906,"ip_address":"","comment_id":281822,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1614914247","product_id":100051801,"comment_content":"老师，请问怎么系统学习多线程编程呢？有教程或者书籍推荐吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516529,"discussion_content":"好像有本c++ concurrent in action吧，有同学留言推荐过，网上也有资源。\n\n系统学习就是多看书多实践。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614933906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201914,"avatar":"https://static001.geekbang.org/account/avatar/00/12/56/fa/8ba604a6.jpg","nickname":"木瓜","note":"","ucode":"B24A54DEC7DB15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352979,"discussion_content":"好的老师，刚把VS装好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614934107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259474,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1604734679,"is_pvip":true,"replies":[{"id":"94320","content":"我感觉C++标准库在并发方面做的还是不太好，只有基本的线程支持，没有大家公认的上层组件、框架，所以并发基本上都是自己造轮子，不像其他语言，框架用的人多自然就会有书。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1604746726,"ip_address":"","comment_id":259474,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604734679","product_id":100051801,"comment_content":"老师你好，c++并发这一块有什么书推荐吗？市场上其他语言并发编程挺多的，唯独c++就一本。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508943,"discussion_content":"我感觉C++标准库在并发方面做的还是不太好，只有基本的线程支持，没有大家公认的上层组件、框架，所以并发基本上都是自己造轮子，不像其他语言，框架用的人多自然就会有书。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604746726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249331,"user_name":"揅笑晏晏","can_delete":false,"product_type":"c1","uid":1237618,"ip_address":"","ucode":"DB9847B1C393FF","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/72/9ae3e5c8.jpg","comment_is_top":false,"comment_ctime":1600595149,"is_pvip":false,"replies":[{"id":"91480","content":"可以看一下标准，里面删除了赋值构造函数，所以最好不要这么写。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1600662846,"ip_address":"","comment_id":249331,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600595149","product_id":100051801,"comment_content":"原子变量可以用=初始化，如，atomic_int x = {0};  &#47;&#47; 正确<br>不过这应该是直接调用了赋值构造函数吧。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505901,"discussion_content":"可以看一下标准，里面删除了赋值构造函数，所以最好不要这么写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600662846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245492,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1598959309,"is_pvip":true,"replies":[{"id":"90308","content":"async()需要配合future来使用，屏蔽了线程概念，用起来就更简单一些。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1599008661,"ip_address":"","comment_id":245492,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598959309","product_id":100051801,"comment_content":"你在多线程编程的时候遇到过哪些“坑”，有什么经验教训？<br>1.多线程共享数据脏了<br>2.通过并行线程读写数据改为并行线程，串行合并数据<br>你觉得 async() 比直接用 thread 启动线程好在哪里？<br>1.没怎么用过，","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504898,"discussion_content":"async()需要配合future来使用，屏蔽了线程概念，用起来就更简单一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599008661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239620,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1596598864,"is_pvip":true,"replies":[{"id":"88504","content":"我觉得可以参考一下Nginx的多线程用法，给线程投递一个exit task，这样线程就会通过条件变量得到task，然后安全结束。<br><br>具体的代码是ngx_thread_pool.c，ngx_thread_pool_destroy()","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1596604879,"ip_address":"","comment_id":239620,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596598864","product_id":100051801,"comment_content":"老师，你好，关于条件变量应该如何退出呢？<br>比如说:<br>void f()<br>{<br>    while(m_isRun)<br>    { <br>       std::unique_lock&lt;std::mutex&gt;       dataLock(m_mtx);<br>       while(m_list.empty())<br>       {<br>           m_cond. wait(dataLock);<br>        }<br>        ……<br>    }<br>}<br>线程函数如上面所写，如果析构中调用join()根本听不了，如果调用deach()我发现在vs12上是有一些问题？不知道如何退出。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503162,"discussion_content":"我觉得可以参考一下Nginx的多线程用法，给线程投递一个exit task，这样线程就会通过条件变量得到task，然后安全结束。\n\n具体的代码是ngx_thread_pool.c，ngx_thread_pool_destroy()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596604879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239061,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1596424618,"is_pvip":false,"replies":[{"id":"88298","content":"涉及到多个任务的协调、等待结果，这必然要阻塞，这个显然是与多线程无关的。<br><br>异步主要是为了避免不必要的阻塞，在等待的时候可以去做别的事情。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1596432060,"ip_address":"","comment_id":239061,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596424618","product_id":100051801,"comment_content":"多线程实现异步的话，依旧有问题。假设A B C D线程但是A的输出是B的输入，以此类推。这个时候所谓的异步处理，只不过是线程分别处理各自的流程，但是现在线程间的结果等待仍旧是同步阻塞的。async我理解就是实现的这个。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502961,"discussion_content":"涉及到多个任务的协调、等待结果，这必然要阻塞，这个显然是与多线程无关的。\n\n异步主要是为了避免不必要的阻塞，在等待的时候可以去做别的事情。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596432060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234679,"user_name":"拓","can_delete":false,"product_type":"c1","uid":1757894,"ip_address":"","ucode":"94B81A10FACDCC","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d2/c6/964432e4.jpg","comment_is_top":false,"comment_ctime":1594772732,"is_pvip":false,"replies":[{"id":"86567","content":"可以看GitHub，上面有一些资料链接。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594775754,"ip_address":"","comment_id":234679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594772732","product_id":100051801,"comment_content":"chrono，您好，很受教。<br>能共享一些资料参考下吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501464,"discussion_content":"可以看GitHub，上面有一些资料链接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594775754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233720,"user_name":"蛀牙","can_delete":false,"product_type":"c1","uid":1153349,"ip_address":"","ucode":"F765A67DFEADFD","user_header":"","comment_is_top":false,"comment_ctime":1594413530,"is_pvip":false,"replies":[{"id":"86283","content":"线程并发也有很多模式，有什么immutable什么的，不过我现在用的不是很多，帮不上你，抱歉了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594430616,"ip_address":"","comment_id":233720,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594413530","product_id":100051801,"comment_content":"罗老师好，我在工作中总是听同事使用thread model一词，请问是不是有几个常用的线程模式呢？ 比如说：一种模式是多个线程都access common resource, 另一种模式是尽量让各个thread独立，各自maintain自己的resource，等等。<br>另外可以稍微讲解一下strand和executor吗？<br>一般executor会利用线程池的线程吗？ 还是自己会initialize一个线程？<br>感谢回复","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501141,"discussion_content":"线程并发也有很多模式，有什么immutable什么的，不过我现在用的不是很多，帮不上你，抱歉了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594430616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231815,"user_name":"Geek_496123","can_delete":false,"product_type":"c1","uid":1993795,"ip_address":"","ucode":"CC4DC7B00A38DF","user_header":"","comment_is_top":false,"comment_ctime":1593776275,"is_pvip":false,"replies":[{"id":"85619","content":"<br>1.一个是语言标准，一个是具体实现，C++里的thread是一个规格描述，到具体编译器、操作系统会有不同的实现方式，在语言这层做了屏蔽。<br>在Linux里可以认为thread底层就是pthread_xxx，但不能完全保证。<br><br>2.使用C++标准里的thread就可以不用关心操作系统的具体细节，对于跨平台编程非常有利。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593831289,"ip_address":"","comment_id":231815,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593776275","product_id":100051801,"comment_content":"C++中的thread 和 C语言中的pthread_create有什么关系或者区别吗？还有windows中的多线程api，初学者，表示各种多线程，傻傻分不清楚。","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500445,"discussion_content":"\n1.一个是语言标准，一个是具体实现，C++里的thread是一个规格描述，到具体编译器、操作系统会有不同的实现方式，在语言这层做了屏蔽。\n在Linux里可以认为thread底层就是pthread_xxx，但不能完全保证。\n\n2.使用C++标准里的thread就可以不用关心操作系统的具体细节，对于跨平台编程非常有利。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593831289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226667,"user_name":"饭小团","can_delete":false,"product_type":"c1","uid":1019783,"ip_address":"","ucode":"46CAF2771EBDC5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/87/c290cbff.jpg","comment_is_top":false,"comment_ctime":1592183489,"is_pvip":false,"replies":[{"id":"83446","content":"有读写锁可以用，这个属于很传统的多线程共享问题了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592184335,"ip_address":"","comment_id":226667,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592183489","product_id":100051801,"comment_content":"多度单写怎么实现？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498326,"discussion_content":"有读写锁可以用，这个属于很传统的多线程共享问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592184335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226508,"user_name":"Simon","can_delete":false,"product_type":"c1","uid":1914504,"ip_address":"","ucode":"A8A2E3E57BD029","user_header":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","comment_is_top":false,"comment_ctime":1592125334,"is_pvip":true,"replies":[{"id":"83415","content":"官方标准文档是最权威的定义，不过确实阅读有难度。<br><br>可以看cppreference网站，或者去看gcc的C++支持页，看看编译器对各项新特性的描述，难度会低一点。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592144208,"ip_address":"","comment_id":226508,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592125334","product_id":100051801,"comment_content":"怎样获知C++的最新标准？是去看1000多页的标准文档吗？太长了吧！","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498269,"discussion_content":"官方标准文档是最权威的定义，不过确实阅读有难度。\n\n可以看cppreference网站，或者去看gcc的C++支持页，看看编译器对各项新特性的描述，难度会低一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592144208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224844,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1591573766,"is_pvip":false,"replies":[{"id":"82759","content":"<br>1.问题太高端，不太理解context switch是什么，抱歉。<br><br>2.原子变量往细了说也是很复杂的，有好几种内存访问顺序规定，如果是最严格的memory_order_seq_cst就是你说的那样了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591578731,"ip_address":"","comment_id":224844,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1591573766","product_id":100051801,"comment_content":"#1<br>请conditional_variable的<br>notify,wait这两个成员函数，在哪些情况下会引起context switch?<br><br>#2<br>请conditional_variable的成员函数在哪些情况下会引起context switch?<br><br>#3<br>两个线程同时在读取一个原子变量，当第一个线程正在读取过过程的时候，第二个线程在做什么？busy-waiting?","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497627,"discussion_content":"\n1.问题太高端，不太理解context switch是什么，抱歉。\n\n2.原子变量往细了说也是很复杂的，有好几种内存访问顺序规定，如果是最严格的memory_order_seq_cst就是你说的那样了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591578731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048441,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/79/f400c4d1.jpg","nickname":"douge","note":"","ucode":"A6EB1AA3D53516","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392387,"discussion_content":"Linux 下Wait和notify都会cs吧，最终都会调用futex系统调用。原子操作时一般只有 bus lock或者cache invalidate，然后搭配for循环不断尝试有busy waiting","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630989220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258402,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","nickname":"皮皮侠","note":"","ucode":"04205990C1DE1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280712,"discussion_content":"context switch上下文切换吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591604584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1258402,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","nickname":"皮皮侠","note":"","ucode":"04205990C1DE1F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280828,"discussion_content":"嗯，是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591617513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280712,"ip_address":""},"score":280828,"extra":""}]}]},{"had_liked":false,"id":224731,"user_name":"1coma","can_delete":false,"product_type":"c1","uid":1822536,"ip_address":"","ucode":"89C0B2B89D2FF2","user_header":"https://static001.geekbang.org/account/avatar/00/1b/cf/48/de3caacb.jpg","comment_is_top":false,"comment_ctime":1591523482,"is_pvip":false,"replies":[{"id":"82701","content":"<br>1.这个我也说不太好，我一般都用try-lock，感觉比较安全，不容易犯错。<br><br>2.可以用性能分析工具，比如perf、systemtap，后面会讲。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591531681,"ip_address":"","comment_id":224731,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591523482","product_id":100051801,"comment_content":"罗老师，请问：<br>1.针对ABBA锁的问题，try-lock的方式一定比消除ABBA锁差吗？<br>2.针对多线程服务卡顿（高并发下）的问题，除了通过日志排查，有没有什么技巧？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497587,"discussion_content":"\n1.这个我也说不太好，我一般都用try-lock，感觉比较安全，不容易犯错。\n\n2.可以用性能分析工具，比如perf、systemtap，后面会讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591531681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224542,"user_name":"有学识的兔子","can_delete":false,"product_type":"c1","uid":1628867,"ip_address":"","ucode":"D1D654B1562FC9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","comment_is_top":false,"comment_ctime":1591435650,"is_pvip":false,"replies":[{"id":"82667","content":"<br>1.互斥锁用起来真的是有很多要注意的地方，并发编程对程序员的思维是一大挑战。<br>这里我觉得可以用递归锁，就是可以重复加锁的锁，可以查一下标准文档。<br><br>2.我觉得async相当于是一个外观模式，屏蔽了底层细节，更容易使用，即使你不了解多线程，也能够利用线程开发出并发程序。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591446826,"ip_address":"","comment_id":224542,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591435650","product_id":100051801,"comment_content":"1. 我遇到一个接口内部使用了同步锁的同时，内部嵌套的接口再一次使用了该同步锁；会出现死锁；<br>2.除了隐藏细节外，方便实现和处理异步任务？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497516,"discussion_content":"\n1.互斥锁用起来真的是有很多要注意的地方，并发编程对程序员的思维是一大挑战。\n这里我觉得可以用递归锁，就是可以重复加锁的锁，可以查一下标准文档。\n\n2.我觉得async相当于是一个外观模式，屏蔽了底层细节，更容易使用，即使你不了解多线程，也能够利用线程开发出并发程序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591446826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224509,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1591425222,"is_pvip":true,"replies":[{"id":"82636","content":"没有本质区别，只是传入的参数不同。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591433822,"ip_address":"","comment_id":224509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591425222","product_id":100051801,"comment_content":"启动线程中的运行函数，普通函数，静态函数，成员函数有什么区别吗","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497501,"discussion_content":"没有本质区别，只是传入的参数不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591433822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224446,"user_name":"TC128","can_delete":false,"product_type":"c1","uid":1993621,"ip_address":"","ucode":"C5FF12BB7406FB","user_header":"","comment_is_top":false,"comment_ctime":1591403308,"is_pvip":false,"replies":[{"id":"82630","content":"看自己的业务逻辑吧，可以重试，或者报错、记日志。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591429722,"ip_address":"","comment_id":224446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591403308","product_id":100051801,"comment_content":"老师好，请问call_once里面的函数调用失败（出错）了咋办？只能重启软件吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497478,"discussion_content":"看自己的业务逻辑吧，可以重试，或者报错、记日志。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591429722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224442,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1591402176,"is_pvip":false,"replies":[{"id":"82631","content":"C++11&#47;14里还没有这个特性，最新的C++20好像也没有，抱歉没办法帮到你。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591429808,"ip_address":"","comment_id":224442,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1591402176","product_id":100051801,"comment_content":"能否介绍一下C++里的反射？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497476,"discussion_content":"C++11/14里还没有这个特性，最新的C++20好像也没有，抱歉没办法帮到你。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591429808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547913,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","nickname":"被讨厌的勇气","note":"","ucode":"AE3B3CA27D91A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279802,"discussion_content":"C++里的反射没有Java那么强大，一般没什么用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591419046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}