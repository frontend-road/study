{"id":240147,"title":"88 | 开源实战五（中）：如何利用职责链与代理模式实现MyBatis Plugin？","content":"<p>上节课，我们对MyBatis框架做了简单的背景介绍，并且通过对比各种ORM框架，学习了代码的易用性、性能、灵活性之间的关系。一般来讲，框架提供的高级功能越多，那性能损耗就会越大；框架用起来越简单，提供越简化的使用方式，那灵活性也就越低。</p><p>接下来的两节课，我们再学习一下MyBatis用到一些经典设计模式。其中，今天，我们主要讲解MyBatis Plugin。尽管名字叫Plugin（插件），但它实际上跟之前讲到的Servlet Filter（过滤器）、Spring Interceptor（拦截器）类似，设计的初衷都是为了框架的扩展性，用到的主要设计模式都是职责链模式。</p><p>不过，相对于Servlet Filter和Spring Interceptor，MyBatis Plugin中职责链模式的代码实现稍微有点复杂。它是借助动态代理模式来实现的职责链。今天我就带你看下，如何利用这两个模式实现MyBatis Plugin。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>MyBatis Plugin功能介绍</h2><p>实际上，MyBatis Plugin跟Servlet Filter、Spring Interceptor的功能是类似的，都是在不需要修改原有流程代码的情况下，拦截某些方法调用，在拦截的方法调用的前后，执行一些额外的代码逻辑。它们的唯一区别在于拦截的位置是不同的。Servlet Filter主要拦截Servlet请求，Spring Interceptor主要拦截Spring管理的Bean方法（比如Controller类的方法等），而MyBatis Plugin主要拦截的是MyBatis在执行SQL的过程中涉及的一些方法。</p><!-- [[[read_end]]] --><p>MyBatis Plugin使用起来比较简单，我们通过一个例子来快速看下。</p><p>假设我们需要统计应用中每个SQL的执行耗时，如果使用MyBatis Plugin来实现的话，我们只需要定义一个SqlCostTimeInterceptor类，让它实现MyBatis的Interceptor接口，并且，在MyBatis的全局配置文件中，简单声明一下这个插件就可以了。具体的代码和配置如下所示：</p><pre><code>@Intercepts({\n        @Signature(type = StatementHandler.class, method = &quot;query&quot;, args = {Statement.class, ResultHandler.class}),\n        @Signature(type = StatementHandler.class, method = &quot;update&quot;, args = {Statement.class}),\n        @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = {Statement.class})})\npublic class SqlCostTimeInterceptor implements Interceptor {\n  private static Logger logger = LoggerFactory.getLogger(SqlCostTimeInterceptor.class);\n\n  @Override\n  public Object intercept(Invocation invocation) throws Throwable {\n    Object target = invocation.getTarget();\n    long startTime = System.currentTimeMillis();\n    StatementHandler statementHandler = (StatementHandler) target;\n    try {\n      return invocation.proceed();\n    } finally {\n      long costTime = System.currentTimeMillis() - startTime;\n      BoundSql boundSql = statementHandler.getBoundSql();\n      String sql = boundSql.getSql();\n      logger.info(&quot;执行 SQL：[ {} ]执行耗时[ {} ms]&quot;, sql, costTime);\n    }\n  }\n\n  @Override\n  public Object plugin(Object target) {\n    return Plugin.wrap(target, this);\n  }\n\n  @Override\n  public void setProperties(Properties properties) {\n    System.out.println(&quot;插件配置的信息：&quot;+properties);\n  }\n}\n\n&lt;!-- MyBatis全局配置文件：mybatis-config.xml --&gt;\n&lt;plugins&gt;\n  &lt;plugin interceptor=&quot;com.xzg.cd.a88.SqlCostTimeInterceptor&quot;&gt;\n    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;\n  &lt;/plugin&gt;\n&lt;/plugins&gt;\n</code></pre><p>因为待会我会详细地介绍MyBatis Plugin的底层实现原理，所以，这里暂时不对上面的代码做详细地解释。现在，我们只重点看下@Intercepts注解这一部分。</p><p>我们知道，不管是拦截器、过滤器还是插件，都需要明确地标明拦截的目标方法。@Intercepts注解实际上就是起了这个作用。其中，@Intercepts注解又可以嵌套@Signature注解。一个@Signature注解标明一个要拦截的目标方法。如果要拦截多个方法，我们可以像例子中那样，编写多条@Signature注解。</p><p>@Signature注解包含三个元素：type、method、args。其中，type指明要拦截的类、method指明方法名、args指明方法的参数列表。通过指定这三个元素，我们就能完全确定一个要拦截的方法。</p><p>默认情况下，MyBatis Plugin允许拦截的方法有下面这样几个：</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/d1/cd0aae4a0758ac0913ad28988a6718d1.jpg?wh=1723*763\" alt=\"\"></p><p>为什么默认允许拦截的是这样几个类的方法呢？</p><p>MyBatis底层是通过Executor类来执行SQL的。Executor类会创建StatementHandler、ParameterHandler、ResultSetHandler三个对象，并且，首先使用ParameterHandler设置SQL中的占位符参数，然后使用StatementHandler执行SQL语句，最后使用ResultSetHandler封装执行结果。所以，我们只需要拦截Executor、ParameterHandler、ResultSetHandler、StatementHandler这几个类的方法，基本上就能满足我们对整个SQL执行流程的拦截了。</p><p>实际上，除了统计SQL的执行耗时，利用MyBatis Plugin，我们还可以做很多事情，比如分库分表、自动分页、数据脱敏、加密解密等等。如果感兴趣的话，你可以自己实现一下。</p><h2>MyBatis Plugin的设计与实现</h2><p>刚刚我们简单介绍了MyBatis Plugin是如何使用的。现在，我们再剖析一下源码，看看如此简洁的使用方式，底层是如何实现的，隐藏了哪些复杂的设计。</p><p>相对于Servlet Filter、Spring Interceptor中职责链模式的代码实现，MyBatis Plugin的代码实现还是蛮有技巧的，因为它是借助动态代理来实现职责链的。</p><p>在<a href=\"https://time.geekbang.org/column/article/216278\">第62节</a>和<a href=\"https://time.geekbang.org/column/article/217395\">第63节</a>中，我们讲到，职责链模式的实现一般包含处理器（Handler）和处理器链（HandlerChain）两部分。这两个部分对应到Servlet Filter的源码就是Filter和FilterChain，对应到Spring Interceptor的源码就是HandlerInterceptor和HandlerExecutionChain，对应到MyBatis Plugin的源码就是Interceptor和InterceptorChain。除此之外，MyBatis Plugin还包含另外一个非常重要的类：Plugin。它用来生成被拦截对象的动态代理。</p><p>集成了MyBatis的应用在启动的时候，MyBatis框架会读取全局配置文件（前面例子中的mybatis-config.xml文件），解析出Interceptor（也就是例子中的SqlCostTimeInterceptor），并且将它注入到Configuration类的InterceptorChain对象中。这部分逻辑对应到源码如下所示：</p><pre><code>public class XMLConfigBuilder extends BaseBuilder {\n  //解析配置\n  private void parseConfiguration(XNode root) {\n    try {\n     //省略部分代码...\n      pluginElement(root.evalNode(&quot;plugins&quot;)); //解析插件\n    } catch (Exception e) {\n      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);\n    }\n  }\n\n  //解析插件\n   private void pluginElement(XNode parent) throws Exception {\n    if (parent != null) {\n      for (XNode child : parent.getChildren()) {\n        String interceptor = child.getStringAttribute(&quot;interceptor&quot;);\n        Properties properties = child.getChildrenAsProperties();\n        //创建Interceptor类对象\n        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();\n        //调用Interceptor上的setProperties()方法设置properties\n        interceptorInstance.setProperties(properties);\n        //下面这行代码会调用InterceptorChain.addInterceptor()方法\n        configuration.addInterceptor(interceptorInstance);\n      }\n    }\n  }\n}\n\n// Configuration类的addInterceptor()方法的代码如下所示\npublic void addInterceptor(Interceptor interceptor) {\n  interceptorChain.addInterceptor(interceptor);\n}\n</code></pre><p>我们再来看Interceptor和InterceptorChain这两个类的代码，如下所示。Interceptor的setProperties()方法就是一个单纯的setter方法，主要是为了方便通过配置文件配置Interceptor的一些属性值，没有其他作用。Interceptor类中intecept()和plugin()函数，以及InterceptorChain类中的pluginAll()函数，是最核心的三个函数，我们待会再详细解释。</p><pre><code>public class Invocation {\n  private final Object target;\n  private final Method method;\n  private final Object[] args;\n  // 省略构造函数和getter方法...\n  public Object proceed() throws InvocationTargetException, IllegalAccessException {\n    return method.invoke(target, args);\n  }\n}\npublic interface Interceptor {\n  Object intercept(Invocation invocation) throws Throwable;\n  Object plugin(Object target);\n  void setProperties(Properties properties);\n}\n\npublic class InterceptorChain {\n  private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;();\n\n  public Object pluginAll(Object target) {\n    for (Interceptor interceptor : interceptors) {\n      target = interceptor.plugin(target);\n    }\n    return target;\n  }\n\n  public void addInterceptor(Interceptor interceptor) {\n    interceptors.add(interceptor);\n  }\n  \n  public List&lt;Interceptor&gt; getInterceptors() {\n    return Collections.unmodifiableList(interceptors);\n  }\n}\n</code></pre><p>解析完配置文件之后，所有的Interceptor都加载到了InterceptorChain中。接下来，我们再来看下，这些拦截器是在什么时候被触发执行的？又是如何被触发执行的呢？</p><p>前面我们提到，在执行SQL的过程中，MyBatis会创建Executor、StatementHandler、ParameterHandler、ResultSetHandler这几个类的对象，对应的创建代码在Configuration类中，如下所示：</p><pre><code>public Executor newExecutor(Transaction transaction, ExecutorType executorType) {\n  executorType = executorType == null ? defaultExecutorType : executorType;\n  executorType = executorType == null ? ExecutorType.SIMPLE : executorType;\n  Executor executor;\n  if (ExecutorType.BATCH == executorType) {\n    executor = new BatchExecutor(this, transaction);\n  } else if (ExecutorType.REUSE == executorType) {\n    executor = new ReuseExecutor(this, transaction);\n  } else {\n    executor = new SimpleExecutor(this, transaction);\n  }\n  if (cacheEnabled) {\n    executor = new CachingExecutor(executor);\n  }\n  executor = (Executor) interceptorChain.pluginAll(executor);\n  return executor;\n}\n\npublic ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {\n  ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);\n  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);\n  return parameterHandler;\n}\n\npublic ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,\n    ResultHandler resultHandler, BoundSql boundSql) {\n  ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);\n  resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);\n  return resultSetHandler;\n}\n\npublic StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {\n  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);\n  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);\n  return statementHandler;\n}\n</code></pre><p>从上面的代码中，我们可以发现，这几个类对象的创建过程都调用了InteceptorChain的pluginAll()方法。这个方法的代码前面已经给出了。你可以回过头去再看一眼。它的代码实现很简单，嵌套调用InterceptorChain上每个Interceptor的plugin()方法。plugin()是一个接口方法（不包含实现代码），需要由用户给出具体的实现代码。在之前的例子中，SQLTimeCostInterceptor的plugin()方法通过直接调用Plugin的wrap()方法来实现。wrap()方法的代码实现如下所示：</p><pre><code>// 借助Java InvocationHandler实现的动态代理模式\npublic class Plugin implements InvocationHandler {\n  private final Object target;\n  private final Interceptor interceptor;\n  private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;\n\n  private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) {\n    this.target = target;\n    this.interceptor = interceptor;\n    this.signatureMap = signatureMap;\n  }\n\n  // wrap()静态方法，用来生成target的动态代理，\n  // 动态代理对象=target对象+interceptor对象。\n  public static Object wrap(Object target, Interceptor interceptor) {\n    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);\n    Class&lt;?&gt; type = target.getClass();\n    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);\n    if (interfaces.length &gt; 0) {\n      return Proxy.newProxyInstance(\n          type.getClassLoader(),\n          interfaces,\n          new Plugin(target, interceptor, signatureMap));\n    }\n    return target;\n  }\n\n  // 调用target上的f()方法，会触发执行下面这个方法。\n  // 这个方法包含：执行interceptor的intecept()方法 + 执行target上f()方法。\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    try {\n      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());\n      if (methods != null &amp;&amp; methods.contains(method)) {\n        return interceptor.intercept(new Invocation(target, method, args));\n      }\n      return method.invoke(target, args);\n    } catch (Exception e) {\n      throw ExceptionUtil.unwrapThrowable(e);\n    }\n  }\n\n  private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) {\n    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);\n    // issue #251\n    if (interceptsAnnotation == null) {\n      throw new PluginException(&quot;No @Intercepts annotation was found in interceptor &quot; + interceptor.getClass().getName());      \n    }\n    Signature[] sigs = interceptsAnnotation.value();\n    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();\n    for (Signature sig : sigs) {\n      Set&lt;Method&gt; methods = signatureMap.get(sig.type());\n      if (methods == null) {\n        methods = new HashSet&lt;Method&gt;();\n        signatureMap.put(sig.type(), methods);\n      }\n      try {\n        Method method = sig.type().getMethod(sig.method(), sig.args());\n        methods.add(method);\n      } catch (NoSuchMethodException e) {\n        throw new PluginException(&quot;Could not find method on &quot; + sig.type() + &quot; named &quot; + sig.method() + &quot;. Cause: &quot; + e, e);\n      }\n    }\n    return signatureMap;\n  }\n\n  private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) {\n    Set&lt;Class&lt;?&gt;&gt; interfaces = new HashSet&lt;Class&lt;?&gt;&gt;();\n    while (type != null) {\n      for (Class&lt;?&gt; c : type.getInterfaces()) {\n        if (signatureMap.containsKey(c)) {\n          interfaces.add(c);\n        }\n      }\n      type = type.getSuperclass();\n    }\n    return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]);\n  }\n}\n</code></pre><p>实际上，Plugin是借助Java InvocationHandler实现的动态代理类。用来代理给target对象添加Interceptor功能。其中，要代理的target对象就是Executor、StatementHandler、ParameterHandler、ResultSetHandler这四个类的对象。wrap()静态方法是一个工具函数，用来生成target对象的动态代理对象。</p><p>当然，只有interceptor与target互相匹配的时候，wrap()方法才会返回代理对象，否则就返回target对象本身。怎么才算是匹配呢？那就是interceptor通过@Signature注解要拦截的类包含target对象，具体可以参看wrap()函数的代码实现（上面一段代码中的第16~19行）。</p><p>MyBatis中的职责链模式的实现方式比较特殊。它对同一个目标对象嵌套多次代理（也就是InteceptorChain中的pluginAll()函数要执行的任务）。每个代理对象（Plugin对象）代理一个拦截器（Interceptor对象）功能。为了方便你查看，我将pluginAll()函数的代码又拷贝到了下面。</p><pre><code>public Object pluginAll(Object target) {\n  // 嵌套代理\n  for (Interceptor interceptor : interceptors) {\n    target = interceptor.plugin(target);\n    // 上面这行代码等于下面这行代码，target(代理对象)=target(目标对象)+interceptor(拦截器功能)\n    // target = Plugin.wrap(target, interceptor);\n  }\n  return target;\n}\n\n// MyBatis像下面这样创建target(Executor、StatementHandler、ParameterHandler、ResultSetHandler），相当于多次嵌套代理\nObject target = interceptorChain.pluginAll(target);\n</code></pre><p>当执行Executor、StatementHandler、ParameterHandler、ResultSetHandler这四个类上的某个方法的时候，MyBatis会嵌套执行每层代理对象（Plugin对象）上的invoke()方法。而invoke()方法会先执行代理对象中的interceptor的intecept()函数，然后再执行被代理对象上的方法。就这样，一层一层地把代理对象上的intercept()函数执行完之后，MyBatis才最终执行那4个原始类对象上的方法。</p><h2>重点回顾</h2><p>好了，今天内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p>今天，我们带你剖析了如何利用职责链模式和动态代理模式来实现MyBatis Plugin。至此，我们就已经学习了三种职责链常用的应用场景：过滤器（Servlet Filter）、拦截器（Spring Interceptor）、插件（MyBatis Plugin）。</p><p>职责链模式的实现一般包含处理器和处理器链两部分。这两个部分对应到Servlet Filter的源码就是Filter和FilterChain，对应到Spring Interceptor的源码就是HandlerInterceptor和HandlerExecutionChain，对应到MyBatis Plugin的源码就是Interceptor和InterceptorChain。除此之外，MyBatis Plugin还包含另外一个非常重要的类：Plugin类。它用来生成被拦截对象的动态代理。</p><p>在这三种应用场景中，职责链模式的实现思路都不大一样。其中，Servlet Filter采用递归来实现拦截方法前后添加逻辑。Spring Interceptor的实现比较简单，把拦截方法前后要添加的逻辑放到两个方法中实现。MyBatis Plugin采用嵌套动态代理的方法来实现，实现思路很有技巧。</p><h2>课堂讨论</h2><p>Servlet Filter、Spring Interceptor可以用来拦截用户自己定义的类的方法，而MyBatis Plugin默认可以拦截的只有Executor、StatementHandler、ParameterHandler、ResultSetHandler这四个类的方法，而且这四个类是MyBatis实现的类，并非用户自己定义的类。那MyBatis Plugin为什么不像Servlet Filter、Spring Interceptor那样，提供拦截用户自定义类的方法的功能呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"87 | 开源实战五（上）：MyBatis如何权衡易用性、性能和灵活性？","id":239239},"right":{"article_title":"89 | 开源实战五（下）：总结MyBatis框架中用到的10种设计模式","id":240971}},"comments":[{"had_liked":false,"id":221022,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1590383036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"130439401916","product_id":100039001,"comment_content":"思考题：因为用mybatis就是为了使用数据库。","like_count":29},{"had_liked":false,"id":221199,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1590424660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104669639764","product_id":100039001,"comment_content":"精彩，看了源码，Mybatis分布工具PageHelper也通过Plugin方式实现的。<br>@Intercepts({@Signature(<br>    type = Executor.class,<br>    method = &quot;query&quot;,<br>    args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}<br>)})<br>public class PageHelper implements Interceptor {...}","like_count":25},{"had_liked":false,"id":221120,"user_name":"your problem？","can_delete":false,"product_type":"c1","uid":1457464,"ip_address":"","ucode":"6E096E7958CFD7","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/38/6f02a4b9.jpg","comment_is_top":false,"comment_ctime":1590409813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74604853845","product_id":100039001,"comment_content":"思考题：YAGNI，单一职责原则，MyBatis就是负责简化以及通用数据库的处理，没有必要支持过多无关的东西","like_count":18},{"had_liked":false,"id":220967,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1590368610,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"40245074274","product_id":100039001,"comment_content":"我感觉这要从mybatis的使用场景考虑，mybatis主要用于简化数据库操作，所以对于SQL语句的解析才是其本质，而不需要额外支持其他的东西，所以不需要拦截用户自定义类的方法","like_count":9},{"had_liked":false,"id":222622,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1590850197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23065686677","product_id":100039001,"comment_content":"Springaop中的前置通知，后置通知，异常通知也是基于动态代理的职责链模式。","like_count":6},{"had_liked":false,"id":221490,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1590508052,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18770377236","product_id":100039001,"comment_content":"看第一篇以为听懂了，再第二篇，发现根本没懂。如果换成是我要实现sql耗时的操作，走两步就行<br>1、写一个切面拦截StatementHander的某些方法，在执行sql前后加开始结束时间就行。<br>2、上一点中拦截哪些方法，还是需要一个类似Plugin中的getSignatureMap方法的解析，没感觉到Plugin类其他的价值。。","like_count":4,"discussions":[{"author":{"id":1463740,"avatar":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","nickname":"Yeyw","note":"","ucode":"C9D20DB91C3BE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369213,"discussion_content":"statement hander是Spring bean？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1618975351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221654,"user_name":"Lambor","can_delete":false,"product_type":"c1","uid":1275494,"ip_address":"","ucode":"0E3C3C39A22495","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/66/cbd6013c.jpg","comment_is_top":false,"comment_ctime":1590559599,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14475461487","product_id":100039001,"comment_content":"MyBatis 每次SQL执行都会创建 Executor 等对象，再通过 pluginAll 方法创建一个代理的职责链，然后递归调用每个代理对象，最后调用 Executor 对象的方法。个人认为这个代理职责链主要就是控制 Executor 的方法在最后一步执行，这种职责链+代理的实现方式虽然巧妙，但感觉得不偿失，每次SQL调用都会创建一个新的嵌套代理调用链，这本身就是有性能消耗的，而且是作为底层框架，这点性能还是要考虑的。感觉采用 ApplicationFilterChain 的那种方式会更好，固定的一个拦截器链路，不用每次创建代理。","like_count":4,"discussions":[{"author":{"id":1008517,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","nickname":"姑射仙人","note":"","ucode":"3EFC1F3E592165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352374,"discussion_content":"这种方式确实有点取巧了，毕竟比较早的框架，想法还是挺6的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614695467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"静静聆听","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283248,"discussion_content":"老哥真知灼见，说的有理啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592222892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221276,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1590460506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10180395098","product_id":100039001,"comment_content":"职责单一,我用Mybatis就是为了更快更好的处理数据库之间的关系,所以专注于这四类是必然的,之前咱自己也看过Mybatis源码,但是并没有看出来是利用代理和职责链实现的整体执行过程","like_count":2},{"had_liked":false,"id":325957,"user_name":"我是曾经那个少年","can_delete":false,"product_type":"c1","uid":1015189,"ip_address":"","ucode":"9F02F7FF147D14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","comment_is_top":false,"comment_ctime":1639279257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5934246553","product_id":100039001,"comment_content":"数据库的执行前我们一般能做的就是：<br>1. 对数据库参数字段的一些处理，。<br>2. 对数据库响应结果的一些处理。<br>3. 或者动态概要SQL语句。<br>数据库ORM组件也就是处理这些东西，没有其他的业务扩展的需要。","like_count":1},{"had_liked":false,"id":321837,"user_name":"高乐","can_delete":false,"product_type":"c1","uid":2614078,"ip_address":"","ucode":"0AF7C5860C851B","user_header":"https://static001.geekbang.org/account/avatar/00/27/e3/3e/f22c2bad.jpg","comment_is_top":false,"comment_ctime":1637058139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5932025435","product_id":100039001,"comment_content":"请问老师，动态代理后的代理类是final的吧，应该无法再次被动态代理吧？那这个嵌套代理是怎么实现的？","like_count":2},{"had_liked":false,"id":286930,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1617687057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912654353","product_id":100039001,"comment_content":"pluginAll()方法的设计，有点像观察者模式，所有的观察者注册到被观察者中，被观察者必须等到所有的观察者执行完之后才能够执行","like_count":1},{"had_liked":false,"id":261012,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1605172796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5900140092","product_id":100039001,"comment_content":"mybatis的拦截的范围粒度比较大，针对的是特定类型的sql查询及参数和返回结果处理。拦截用户自定义的方法可以通过spring aop进行更细粒度的方法拦截。","like_count":1},{"had_liked":false,"id":228271,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1592629124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887596420","product_id":100039001,"comment_content":"Mybatis 需要更专注于数据库操作方面的代理，而更具体的方法代理可以交由 Spring 这类 AOP 框架配置实现，Mybatis 就不必再重复造轮子了。<br><br>对于 Mybatis 以动态代理的方式实现拦截器感觉到新颖，看似使用动态代理会影响效率，实则是提升了执行效率。这是因为只有在系统启动的时候会慢一些，在实际执行的过程中就不需要额外的匹配及判断过滤规则了，当然，动态代理还需要额外的内存开销。","like_count":1},{"had_liked":false,"id":223979,"user_name":"皮特尔","can_delete":false,"product_type":"c1","uid":1017161,"ip_address":"","ucode":"313862C91DD325","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/49/585c69c4.jpg","comment_is_top":false,"comment_ctime":1591247860,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5886215156","product_id":100039001,"comment_content":"MyBatis的使用场景仅限于数据库，所以只需要拦截数据库操作相关的四个类就可以了，没有拦截用户自定义类的必要。这也符合设计原则里的“单一职责”","like_count":1},{"had_liked":false,"id":344181,"user_name":"Molyt","can_delete":false,"product_type":"c1","uid":2283490,"ip_address":"","ucode":"9CCF7A18B2C547","user_header":"https://static001.geekbang.org/account/avatar/00/22/d7/e2/5e5cc8f3.jpg","comment_is_top":false,"comment_ctime":1651327471,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651327471","product_id":100039001,"comment_content":"这一节课更看不懂了，难顶（捂脸哭.jpg）","like_count":0},{"had_liked":false,"id":337667,"user_name":"ljx","can_delete":false,"product_type":"c1","uid":2446982,"ip_address":"","ucode":"6133FC98C44498","user_header":"https://static001.geekbang.org/account/avatar/00/25/56/86/db4c0d1c.jpg","comment_is_top":false,"comment_ctime":1646963952,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646963952","product_id":100039001,"comment_content":"感觉自己变强了，一年前看这段源码觉得云里雾里，只能理解个大概，如今再看是如此清晰。。。","like_count":0},{"had_liked":false,"id":297137,"user_name":"Edison","can_delete":false,"product_type":"c1","uid":1500120,"ip_address":"","ucode":"ADB01AF2966736","user_header":"https://static001.geekbang.org/account/avatar/00/16/e3/d8/6462cfdb.jpg","comment_is_top":false,"comment_ctime":1623323566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623323566","product_id":100039001,"comment_content":"学习了，这部分得看好久","like_count":0},{"had_liked":false,"id":289312,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1618975430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618975430","product_id":100039001,"comment_content":"职责单一，每个框架都做自己领域的事","like_count":0},{"had_liked":false,"id":221888,"user_name":"Bern","can_delete":false,"product_type":"c1","uid":1765806,"ip_address":"","ucode":"5A979552D5800D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlxr0eX6ZPlpiaUkH8SXoNibmOK9MJz2ZDYq5y57UfFHBu6dDc5VxKic1rAPiawLBVdSMl8y1Mwtp9Yg/132","comment_is_top":false,"comment_ctime":1590628902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590628902","product_id":100039001,"comment_content":"是不是因为mybatis的版本问题，有些方法和入参是不一样的","like_count":0}]}