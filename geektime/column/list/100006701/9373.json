{"id":9373,"title":"第19讲 | Java并发包提供了哪些并发工具类？","content":"<p>通过前面的学习，我们一起回顾了线程、锁等各种并发编程的基本元素，也逐步涉及了Java并发包中的部分内容，相信经过前面的热身，我们能够更快地理解Java并发包。</p><p>今天我要问你的问题是，<span class=\"orange\">Java并发包提供了哪些并发工具类？</span></p><h2>典型回答</h2><p>我们通常所说的并发包也就是java.util.concurrent及其子包，集中了Java并发的各种基础工具类，具体主要包括几个方面：</p><ul>\n<li>\n<p>提供了比synchronized更加高级的各种同步结构，包括CountDownLatch、CyclicBarrier、Semaphore等，可以实现更加丰富的多线程操作，比如利用Semaphore作为资源控制器，限制同时进行工作的线程数量。</p>\n</li>\n<li>\n<p>各种线程安全的容器，比如最常见的ConcurrentHashMap、有序的ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList等。</p>\n</li>\n<li>\n<p>各种并发队列实现，如各种BlockingQueue实现，比较典型的ArrayBlockingQueue、 SynchronousQueue或针对特定场景的PriorityBlockingQueue等。</p>\n</li>\n<li>\n<p>强大的Executor框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</p>\n</li>\n</ul><!-- [[[read_end]]] --><h2>考点分析</h2><p>这个题目主要考察你对并发包了解程度，以及是否有实际使用经验。我们进行多线程编程，无非是达到几个目的：</p><ul>\n<li>\n<p>利用多线程提高程序的扩展能力，以达到业务对吞吐量的要求。</p>\n</li>\n<li>\n<p>协调线程间调度、交互，以完成业务逻辑。</p>\n</li>\n<li>\n<p>线程间传递数据和状态，这同样是实现业务逻辑的需要。</p>\n</li>\n</ul><p>所以，这道题目只能算作简单的开始，往往面试官还会进一步考察如何利用并发包实现某个特定的用例，分析实现的优缺点等。</p><p>如果你在这方面的基础比较薄弱，我的建议是：</p><ul>\n<li>\n<p>从总体上，把握住几个主要组成部分（前面回答中已经简要介绍）。</p>\n</li>\n<li>\n<p>理解具体设计、实现和能力。</p>\n</li>\n<li>\n<p>再深入掌握一些比较典型工具类的适用场景、用法甚至是原理，并熟练写出典型的代码用例。</p>\n</li>\n</ul><p>掌握这些通常就够用了，毕竟并发包提供了方方面面的工具，其实很少有机会能在应用中全面使用过，扎实地掌握核心功能就非常不错了。真正特别深入的经验，还是得靠在实际场景中踩坑来获得。</p><h2>知识扩展</h2><p>首先，我们来看看并发包提供的丰富同步结构。前面几讲已经分析过各种不同的显式锁，今天我将专注于</p><ul>\n<li>\n<p><a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CountDownLatch.html\">CountDownLatch</a>，允许一个或多个线程等待某些操作完成。</p>\n</li>\n<li>\n<p><a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CyclicBarrier.html\">CyclicBarrier</a>，一种辅助性的同步结构，允许多个线程等待到达某个屏障。</p>\n</li>\n<li>\n<p><a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Semaphore.html\">Semaphore</a>，Java版本的信号量实现。</p>\n</li>\n</ul><p>Java提供了经典信号量（<a href=\"https://en.wikipedia.org/wiki/Semaphore_(programming)\">Semaphore</a>）的实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。你可以想象一下这个场景，在车站、机场等出租车时，当很多空出租车就位时，为防止过度拥挤，调度员指挥排队等待坐车的队伍一次进来5个人上车，等这5个人坐车出发，再放进去下一批，这和Semaphore的工作原理有些类似。</p><p>你可以试试使用Semaphore来模拟实现这个调度过程：</p><pre><code>import java.util.concurrent.Semaphore;\npublic class UsualSemaphoreSample {\n\tpublic static void main(String[] args) throws InterruptedException {\n    \tSystem.out.println(&quot;Action...GO!&quot;);\n    \tSemaphore semaphore = new Semaphore(5);\n    \tfor (int i = 0; i &lt; 10; i++) {\n        \tThread t = new Thread(new SemaphoreWorker(semaphore));\n        \tt.start();\n    \t}\n\t}\n}\nclass SemaphoreWorker implements Runnable {\n\tprivate String name;\n\tprivate Semaphore semaphore;\n\tpublic SemaphoreWorker(Semaphore semaphore) {\n    \tthis.semaphore = semaphore;\n\t}\n\t@Override\n\tpublic void run() {\n    \ttry {\n        \tlog(&quot;is waiting for a permit!&quot;);\n       \tsemaphore.acquire();\n        \tlog(&quot;acquired a permit!&quot;);\n        \tlog(&quot;executed!&quot;);\n    \t} catch (InterruptedException e) {\n        \te.printStackTrace();\n    \t} finally {\n        \tlog(&quot;released a permit!&quot;);\n        \tsemaphore.release();\n    \t}\n\t}\n\tprivate void log(String msg){\n    \tif (name == null) {\n        \tname = Thread.currentThread().getName();\n    \t}\n    \tSystem.out.println(name + &quot; &quot; + msg);\n\t}\n}\n</code></pre><p>这段代码是比较典型的Semaphore示例，其逻辑是，线程试图获得工作允许，得到许可则进行任务，然后释放许可，这时等待许可的其他线程，就可获得许可进入工作状态，直到全部处理结束。编译运行，我们就能看到Semaphore的允许机制对工作线程的限制。</p><p>但是，从具体节奏来看，其实并不符合我们前面场景的需求，因为本例中Semaphore的用法实际是保证，一直有5个人可以试图乘车，如果有1个人出发了，立即就有排队的人获得许可，而这并不完全符合我们前面的要求。</p><p>那么，我再修改一下，演示个非典型的Semaphore用法。</p><pre><code>import java.util.concurrent.Semaphore;\npublic class AbnormalSemaphoreSample {\n\tpublic static void main(String[] args) throws InterruptedException {\n    \tSemaphore semaphore = new Semaphore(0);\n    \tfor (int i = 0; i &lt; 10; i++) {\n        \tThread t = new Thread(new MyWorker(semaphore));\n        \tt.start();\n    \t}\n    \tSystem.out.println(&quot;Action...GO!&quot;);\n    \tsemaphore.release(5);\n    \tSystem.out.println(&quot;Wait for permits off&quot;);\n    \twhile (semaphore.availablePermits()!=0) {\n        \tThread.sleep(100L);\n    \t}\n    \tSystem.out.println(&quot;Action...GO again!&quot;);\n    \tsemaphore.release(5);\n\t}\n}\nclass MyWorker implements Runnable {\n\tprivate Semaphore semaphore;\n\tpublic MyWorker(Semaphore semaphore) {\n    \tthis.semaphore = semaphore;\n\t}\n\t@Override\n\tpublic void run() {\n    \ttry {\n        \tsemaphore.acquire();\n        \tSystem.out.println(&quot;Executed!&quot;);\n    \t} catch (InterruptedException e) {\n        \te.printStackTrace();\n    \t}\n\t}\n}\n\n</code></pre><p>注意，上面的代码，更侧重的是演示Semaphore的功能以及局限性，其实有很多线程编程中的反实践，比如使用了sleep来协调任务执行，而且使用轮询调用availalePermits来检测信号量获取情况，这都是很低效并且脆弱的，通常只是用在测试或者诊断场景。</p><p>总的来说，我们可以看出Semaphore就是个<strong>计数器</strong>，<strong>其基本逻辑基于acquire/release</strong>，并没有太复杂的同步逻辑。</p><p>如果Semaphore的数值被初始化为1，那么一个线程就可以通过acquire进入互斥状态，本质上和互斥锁是非常相似的。但是区别也非常明显，比如互斥锁是有持有者的，而对于Semaphore这种计数器结构，虽然有类似功能，但其实不存在真正意义的持有者，除非我们进行扩展包装。</p><p>下面，来看看CountDownLatch和CyclicBarrier，它们的行为有一定的相似度，经常会被考察二者有什么区别，我来简单总结一下。</p><ul>\n<li>\n<p>CountDownLatch是不可以重置的，所以无法重用；而CyclicBarrier则没有这种限制，可以重用。</p>\n</li>\n<li>\n<p>CountDownLatch的基本操作组合是countDown/await。调用await的线程阻塞等待countDown足够的次数，不管你是在一个线程还是多个线程里countDown，只要次数足够即可。所以就像Brain Goetz说过的，CountDownLatch操作的是事件。</p>\n</li>\n<li>\n<p>CyclicBarrier的基本操作组合，则就是await，当所有的伙伴（parties）都调用了await，才会继续进行任务，并自动进行重置。<strong>注意</strong>，正常情况下，CyclicBarrier的重置都是自动发生的，如果我们调用reset方法，但还有线程在等待，就会导致等待线程被打扰，抛出BrokenBarrierException异常。CyclicBarrier侧重点是线程，而不是调用事件，它的典型应用场景是用来等待并发线程结束。</p>\n</li>\n</ul><p>如果用CountDownLatch去实现上面的排队场景，该怎么做呢？假设有10个人排队，我们将其分成5个人一批，通过CountDownLatch来协调批次，你可以试试下面的示例代码。</p><pre><code>import java.util.concurrent.CountDownLatch;\npublic class LatchSample {\n\tpublic static void main(String[] args) throws InterruptedException {\n    \tCountDownLatch latch = new CountDownLatch(6);\n           for (int i = 0; i &lt; 5; i++) {\n                Thread t = new Thread(new FirstBatchWorker(latch));\n                t.start();\n    \t}\n    \tfor (int i = 0; i &lt; 5; i++) {\n        \t    Thread t = new Thread(new SecondBatchWorker(latch));\n        \t    t.start();\n    \t}\n           // 注意这里也是演示目的的逻辑，并不是推荐的协调方式\n    \twhile ( latch.getCount() != 1 ){\n        \t    Thread.sleep(100L);\n    \t}\n    \tSystem.out.println(&quot;Wait for first batch finish&quot;);\n    \tlatch.countDown();\n\t}\n}\nclass FirstBatchWorker implements Runnable {\n\tprivate CountDownLatch latch;\n\tpublic FirstBatchWorker(CountDownLatch latch) {\n    \tthis.latch = latch;\n\t}\n\t@Override\n\tpublic void run() {\n        \tSystem.out.println(&quot;First batch executed!&quot;);\n        \tlatch.countDown();\n\t}\n}\nclass SecondBatchWorker implements Runnable {\n\tprivate CountDownLatch latch;\n\tpublic SecondBatchWorker(CountDownLatch latch) {\n    \tthis.latch = latch;\n\t}\n\t@Override\n\tpublic void run() {\n    \ttry {\n        \tlatch.await();\n        \tSystem.out.println(&quot;Second batch executed!&quot;);\n    \t} catch (InterruptedException e) {\n        \te.printStackTrace();\n    \t}\n\t}\n}\n\n</code></pre><p>CountDownLatch的调度方式相对简单，后一批次的线程进行await，等待前一批countDown足够多次。这个例子也从侧面体现出了它的局限性，虽然它也能够支持10个人排队的情况，但是因为不能重用，如果要支持更多人排队，就不能依赖一个CountDownLatch进行了。其编译运行输出如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/46/b9/46c88c7d8e0507465bddb677e4eac5b9.png?wh=327*200\" alt=\"\"></p><p>在实际应用中的条件依赖，往往没有这么别扭，CountDownLatch用于线程间等待操作结束是非常简单普遍的用法。通过countDown/await组合进行通信是很高效的，通常不建议使用例子里那个循环等待方式。</p><p>如果用CyclicBarrier来表达这个场景呢？我们知道CyclicBarrier其实反映的是线程并行运行时的协调，在下面的示例里，从逻辑上，5个工作线程其实更像是代表了5个可以就绪的空车，而不再是5个乘客，对比前面CountDownLatch的例子更有助于我们区别它们的抽象模型，请看下面的示例代码：</p><pre><code>import java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\npublic class CyclicBarrierSample {\n\tpublic static void main(String[] args) throws InterruptedException {\n    \tCyclicBarrier barrier = new CyclicBarrier(5, new Runnable() {\n        \t@Override\n        \tpublic void run() {\n            \tSystem.out.println(&quot;Action...GO again!&quot;);\n        \t}\n    \t});\n    \tfor (int i = 0; i &lt; 5; i++) {\n        \tThread t = new Thread(new CyclicWorker(barrier));\n        \tt.start();\n    \t}\n\t}\n\tstatic class CyclicWorker implements Runnable {\n    \tprivate CyclicBarrier barrier;\n    \tpublic CyclicWorker(CyclicBarrier barrier) {\n        \tthis.barrier = barrier;\n    \t}\n    \t@Override\n    \tpublic void run() {\n        \ttry {\n            \tfor (int i=0; i&lt;3 ; i++){\n                \tSystem.out.println(&quot;Executed!&quot;);\n                \tbarrier.await();\n            \t}\n        \t} catch (BrokenBarrierException e) {\n            \te.printStackTrace();\n        \t} catch (InterruptedException e) {\n            \te.printStackTrace();\n        \t}\n \t   }\n\t}\n}\n</code></pre><p>为了让输出更能表达运行时序，我使用了CyclicBarrier特有的barrierAction，当屏障被触发时，Java会自动调度该动作。因为CyclicBarrier会<strong>自动</strong>进行重置，所以这个逻辑其实可以非常自然的支持更多排队人数。其编译输出如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/9f/eff56d3219ce5493ecacc70a168b2b9f.png?wh=384*317\" alt=\"\"></p><p>Java并发类库还提供了<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Phaser.html\">Phaser</a>，功能与CountDownLatch很接近，但是它允许线程动态地注册到Phaser上面，而CountDownLatch显然是不能动态设置的。Phaser的设计初衷是，实现多个线程类似步骤、阶段场景的协调，线程注册等待屏障条件触发，进而协调彼此间行动，具体请参考这个<a href=\"http://www.baeldung.com/java-phaser\">例子</a>。</p><p>接下来，我来梳理下并发包里提供的线程安全Map、List和Set。首先，请参考下面的类图。</p><p><img src=\"https://static001.geekbang.org/resource/image/35/57/35390aa8a6e6f9c92fda086a1b95b457.png?wh=752*327\" alt=\"\"></p><p>你可以看到，总体上种类和结构还是比较简单的，如果我们的应用侧重于Map放入或者获取的速度，而不在乎顺序，大多推荐使用ConcurrentHashMap，反之则使用ConcurrentSkipListMap；如果我们需要对大量数据进行非常频繁地修改，ConcurrentSkipListMap也可能表现出优势。</p><p>我在前面的专栏，谈到了普通无顺序场景选择HashMap，有顺序场景则可以选择类似TreeMap等，但是为什么并发容器里面没有ConcurrentTreeMap呢？</p><p>这是因为TreeMap要实现高效的线程安全是非常困难的，它的实现基于复杂的红黑树。为保证访问效率，当我们插入或删除节点时，会移动节点进行平衡操作，这导致在并发场景中难以进行合理粒度的同步。而SkipList结构则要相对简单很多，通过层次结构提高访问速度，虽然不够紧凑，空间使用有一定提高（O(nlogn)），但是在增删元素时线程安全的开销要好很多。为了方便你理解SkipList的内部结构，我画了一个示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/63/7b/63b94b5b1d002bb191c75d2c48af767b.png?wh=906*310\" alt=\"\"></p><p>关于两个CopyOnWrite容器，其实CopyOnWriteArraySet是通过包装了CopyOnWriteArrayList来实现的，所以在学习时，我们可以专注于理解一种。</p><p>首先，CopyOnWrite到底是什么意思呢？它的原理是，任何修改操作，如add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全。请看下面的代码片段，我进行注释的地方，可以清晰地理解其逻辑。</p><pre><code>public boolean add(E e) {\n\tsynchronized (lock) {\n    \tObject[] elements = getArray();\n    \tint len = elements.length;\n           // 拷贝\n    \tObject[] newElements = Arrays.copyOf(elements, len + 1);\n    \tnewElements[len] = e;\n           // 替换\n    \tsetArray(newElements);\n    \treturn true;\n            }\n}\nfinal void setArray(Object[] a) {\n\tarray = a;\n}\n</code></pre><p>所以这种数据结构，相对比较适合读多写少的操作，不然修改的开销还是非常明显的。</p><p>今天我对Java并发包进行了总结，并且结合实例分析了各种同步结构和部分线程安全容器，希望对你有所帮助。</p><h2>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？留给你的思考题是，你使用过类似CountDownLatch的同步结构解决实际问题吗？谈谈你的使用场景和心得。</p><p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p><p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>","comments":[{"had_liked":false,"id":44783,"user_name":"013","can_delete":false,"product_type":"c1","uid":1275744,"ip_address":"","ucode":"CB3C6AD184D1B3","user_header":"https://static001.geekbang.org/account/avatar/00/13/77/60/a44c90c5.jpg","comment_is_top":false,"comment_ctime":1543492230,"is_pvip":false,"replies":[{"id":"16133","content":"不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1543626872,"ip_address":"","comment_id":44783,"utype":1}],"discussion_count":1,"race_medal":0,"score":"362320745094","product_id":100006701,"comment_content":"1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：<br>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；<br>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；<br>另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。<br>2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。","like_count":85,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430833,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543626872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13260,"user_name":"天秤座的选择","can_delete":false,"product_type":"c1","uid":1124929,"ip_address":"","ucode":"BC3EF928C0F8EE","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/41/bd6da351.jpg","comment_is_top":false,"comment_ctime":1529480203,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"211982877707","product_id":100006701,"comment_content":"做android的，一个页面有A,B,C三个网络请求，其中请求C需要请求A和请求B的返回数据作为参数，用过CountdownLatch解决。","like_count":50,"discussions":[{"author":{"id":1024043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a0/2b/efa6dc2e.jpg","nickname":"KingSwim","note":"","ucode":"84DE14B7EB2580","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333,"discussion_content":"RxJava现在可以很好地做到了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1561453798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1093258,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","nickname":"赤云","note":"","ucode":"67476D582D8B6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534357,"discussion_content":"join  不更简单吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638171160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2282742,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d4/f6/e183ab38.jpg","nickname":"风","note":"","ucode":"E7C2D899490951","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1093258,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","nickname":"赤云","note":"","ucode":"67476D582D8B6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545917,"discussion_content":"调用线程一般用线程池，线程一般不会结束的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642082517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":534357,"ip_address":""},"score":545917,"extra":""}]},{"author":{"id":2391701,"avatar":"","nickname":"Geek_a3890b","note":"","ucode":"BF67D080DAF96D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403518,"discussion_content":"异步编排\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634095069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351122,"discussion_content":"理解到位，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614157856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120971,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1a/cb/5a2f6ff9.jpg","nickname":"一路向北","note":"","ucode":"5D16E71116FDC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294587,"discussion_content":"协程可以更简单的处理这种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595934154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13425,"user_name":"Daydayup","can_delete":false,"product_type":"c1","uid":1114245,"ip_address":"","ucode":"A03996E942CDFD","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/85/21e1a720.jpg","comment_is_top":false,"comment_ctime":1529624181,"is_pvip":false,"replies":[{"id":"4502","content":"合适的场景","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529627524,"ip_address":"","comment_id":13425,"utype":1}],"discussion_count":5,"race_medal":0,"score":"160443414133","product_id":100006701,"comment_content":"CountDownLatch最近还真用上了。我的需求是每个对象一个线程，分别在每个线程里计算各自的数据，最终等到所有线程计算完毕，我还需要将每个有共通的对象进行合并，所以用它很合适。","like_count":38,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419644,"discussion_content":"合适的场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529627524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026832,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","nickname":"Hesher","note":"","ucode":"99AB8B1704CB7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3230,"discussion_content":"如果都是重复的任务，fork join pool 好像也可以","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564323698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1466335,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5f/df/3c4881f0.jpg","nickname":"Geek","note":"","ucode":"1B8EB2C26DE4EC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1026832,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","nickname":"Hesher","note":"","ucode":"99AB8B1704CB7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271529,"discussion_content":"是的，只是countdownlatch的粒度更细，不用执行到线程结尾即可返回。而join必须整个线程结束","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1590153379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3230,"ip_address":""},"score":271529,"extra":""}]},{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351123,"discussion_content":"学以致用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614157876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107535,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/4f/03d34a71.jpg","nickname":"路灯","note":"","ucode":"DF7CB97900DA26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288899,"discussion_content":"这种场景用cylicbarrier是不是也可以？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593927562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13182,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1529448937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"126083500521","product_id":100006701,"comment_content":"对于Java 并发包提供了哪些并发工具类，我是这么理解的：<br>1. 执行任务，需要对应的执行框架（Executors）；<br>2. 多个任务被同时执行时，需要协调，这就需要Lock、闭锁、栅栏、信号量、阻塞队列；<br>3. Java程序中充满了对象，在并发场景中当然避免不了遇到同种类型的N个对象，而对象需要被存储，这需要高效的线程安全的容器类","like_count":30},{"had_liked":false,"id":13239,"user_name":"夏天🔆","can_delete":false,"product_type":"c1","uid":1100196,"ip_address":"","ucode":"BFCC20BFFD70EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/a4/f5341299.jpg","comment_is_top":false,"comment_ctime":1529461989,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"65953971429","product_id":100006701,"comment_content":"以前使用coutdownlatch进行并发异常的模拟，来修改bug，具体是在发生异常的错误堆栈上进行await，在某些条件处或触发点进行coutdown，来尽可能模拟触发异常时的场景，很多可以必现，修改之后没有问题，才算解决一个并发异常","like_count":16},{"had_liked":false,"id":13076,"user_name":"扫地僧的功夫梦","can_delete":false,"product_type":"c1","uid":1081053,"ip_address":"","ucode":"3B775474594BC3","user_header":"https://static001.geekbang.org/account/avatar/00/10/7e/dd/e4e6718a.jpg","comment_is_top":false,"comment_ctime":1529367188,"is_pvip":false,"replies":[{"id":"4415","content":"是说调用notify的那个线程的状态吗？<br>不是的，这里有很多方面：<br>阻塞一般发生在进入同步块儿时；<br>notify并不会让出当前的monitor；<br>可以用wait释放锁，但是进入waiting状态。<br><br>不建议靠记忆去学习，类似问题我建议思考一下：能不能用一段程序验证，需不需要利用什么工具；别忘了从Javadoc得到初步信息<br><br>授人以渔比提供答案更重要，最好不要你怀疑我这里的每个结论，自己写代码去玩玩","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529423159,"ip_address":"","comment_id":13076,"utype":1}],"discussion_count":4,"race_medal":0,"score":"65953876628","product_id":100006701,"comment_content":"17讲的问题，留言有点晚，老师可能不会看，想得到老师的回复：调用notify()&#47;notifyAll()方法后线程是处于阻塞状态吧，因为线程还没获取到锁。","like_count":15,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419527,"discussion_content":"是说调用notify的那个线程的状态吗？\n不是的，这里有很多方面：\n阻塞一般发生在进入同步块儿时；\nnotify并不会让出当前的monitor；\n可以用wait释放锁，但是进入waiting状态。\n\n不建议靠记忆去学习，类似问题我建议思考一下：能不能用一段程序验证，需不需要利用什么工具；别忘了从Javadoc得到初步信息\n\n授人以渔比提供答案更重要，最好不要你怀疑我这里的每个结论，自己写代码去玩玩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529423159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303240,"discussion_content":"补充老师的一句：但一般都是在当前线程即将退出同步功能块的时候才调用notify同样释放了锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599199252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1158477,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ad/4d/e24fc9e4.jpg","nickname":"蔡光明","note":"","ucode":"7EACC0555B4F19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304201,"discussion_content":"notify和释放锁是两回事，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599494267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303240,"ip_address":""},"score":304201,"extra":""},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1158477,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ad/4d/e24fc9e4.jpg","nickname":"蔡光明","note":"","ucode":"7EACC0555B4F19","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304655,"discussion_content":"谁不知道是两回事，没看到”退出”??看好整句话别就挑个词断词取义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599635737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304201,"ip_address":""},"score":304655,"extra":""}]}]},{"had_liked":false,"id":29756,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1538531957,"is_pvip":true,"replies":[{"id":"12430","content":"是个应用频率高的同步工具","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1540312185,"ip_address":"","comment_id":29756,"utype":1}],"discussion_count":4,"race_medal":0,"score":"44488204917","product_id":100006701,"comment_content":"最近有用到countDownLatch，一个批量更新接口，采用多线程提高处理速度，全部处理完将结果封装返回给app端","like_count":10,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425704,"discussion_content":"是个应用频率高的同步工具","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540312185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1195049,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/29/29d923ce.jpg","nickname":"江南小帅","note":"","ucode":"3519F8EA938022","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298100,"discussion_content":"future应用更广泛吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597191332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1768852,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/94/8704d2b0.jpg","nickname":"spoofer","note":"","ucode":"6723F64ACC3F27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351569,"discussion_content":"future 和 cats里面的for就可以了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614328590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024304,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/30/770c64b2.jpg","nickname":"褐言","note":"","ucode":"43A891C33DBDB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245769,"discussion_content":"Fork/Join 啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587698402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13298,"user_name":"石头狮子","can_delete":false,"product_type":"c1","uid":1118031,"ip_address":"","ucode":"3BABB93E552022","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/4f/c75c4889.jpg","comment_is_top":false,"comment_ctime":1529506229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31594277301","product_id":100006701,"comment_content":"列举实践中两个应用并发工具的场景:<br>1. 请求熔断器，使用 Semaphore 熔断某些请求线程，待系统恢复以后再逐步释放信号量。<br>2. Worker 搜索停止标志。使用 countdownlatch 标记 Worker 找到的结果个数，达到结果后其他线程不再继续执行。","like_count":8},{"had_liked":false,"id":13215,"user_name":"如风","can_delete":false,"product_type":"c1","uid":1022124,"ip_address":"","ucode":"368918EC7DD548","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/ac/c2c4fd82.jpg","comment_is_top":false,"comment_ctime":1529456191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31594227263","product_id":100006701,"comment_content":"在写爬虫时，使用过 Semaphore ，来控制最多爬同一个域名下的 url 数量。","like_count":8},{"had_liked":false,"id":38127,"user_name":"Phoenix","can_delete":false,"product_type":"c1","uid":1005368,"ip_address":"","ucode":"C51BE4C948755B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/38/ba6a106f.jpg","comment_is_top":false,"comment_ctime":1541949202,"is_pvip":false,"replies":[{"id":"15443","content":"不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1543194598,"ip_address":"","comment_id":38127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27311752978","product_id":100006701,"comment_content":"经过老师的讲解，我对CountDownLatch的使用场景是这样理解的：<br>1：A线程的执行，依赖与B线程或C线程等等其他多个线程任务的执行结果来触发A线程任务执行事件","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428615,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543194598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13177,"user_name":"THROW","can_delete":false,"product_type":"c1","uid":1112141,"ip_address":"","ucode":"A3C089A8F5F941","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/4d/4b748ff1.jpg","comment_is_top":false,"comment_ctime":1529425183,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27299228959","product_id":100006701,"comment_content":"ArrayBlockingQueue使用了两个condition来分别控制put和take的阻塞与唤醒，但是我在想好像只用一个condition也可以，因为put和take只会有一个是处于阻塞等待状态。所以设计成两个condition 的原因是什么呢？只是为了提高可读性么？","like_count":6,"discussions":[{"author":{"id":1158477,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ad/4d/e24fc9e4.jpg","nickname":"蔡光明","note":"","ucode":"7EACC0555B4F19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304490,"discussion_content":"是要有两个的，除非你把signal换成signalAll，因为take线程要唤醒的必须是put线程，put线程唤醒的必须是take线程，当然，如果用signalAll的话，用一个condition也是可以的，但是每次都唤醒所有线程，没有必要的吧","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1599579081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18403,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1533293433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23008129913","product_id":100006701,"comment_content":"我的使用经验，在进行高并发的测试时，我会使用countdownlatch,将所有的工作线程在开始时等待，然后在统一的开始，这样就可以避免创建线程所需的时间开销，更好的模拟高并发","like_count":6},{"had_liked":false,"id":13172,"user_name":"三个石头","can_delete":false,"product_type":"c1","uid":1110384,"ip_address":"","ucode":"A863A416D65217","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/70/a64d9498.jpg","comment_is_top":false,"comment_ctime":1529421881,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23004258361","product_id":100006701,"comment_content":"你用的Semaphore第二个例子，构造函数中为啥为0,信号量不是非负整数吗？","like_count":6,"discussions":[{"author":{"id":1968967,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/0b/47/221706c2.jpg","nickname":"陆琦琦","note":"","ucode":"2EA0C8491BF9A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260926,"discussion_content":"0是初始信号量啊，意思是要先release才能acquire","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588913877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303243,"discussion_content":"当在主线程初始化信号量为new Semaphore(0)时，在主线程和子线程同时使用了.acquire()去请求信号量，相当于是信号量从0，减去1变成-1，此时如果没有执行release，结果，线程就会阻塞在这里。如果主，子线程都首先执行了acquire因为没有别的线程来执行release，于是整个程序阻塞了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599199851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13090,"user_name":"Leiy","can_delete":false,"product_type":"c1","uid":1009001,"ip_address":"","ucode":"BE812F95D6089E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/69/efb57b83.jpg","comment_is_top":false,"comment_ctime":1529369460,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"23004205940","product_id":100006701,"comment_content":"对于CopyOnWriteArrayList，适用于读多写少的场景，这个比较好理解，但是在实际使用时候，读写比占多少时候，可以使用？心里还是没数，这个怎么去衡量？","like_count":5,"discussions":[{"author":{"id":1033435,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c4/db/6ba349d6.jpg","nickname":"LT","note":"","ucode":"A673D8DC820F6E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549241,"discussion_content":"根据线上流量特征，对多个备选方案做一次基准测试，选择性能最高的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643771391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13243,"user_name":"扫地僧的功夫梦","can_delete":false,"product_type":"c1","uid":1081053,"ip_address":"","ucode":"3B775474594BC3","user_header":"https://static001.geekbang.org/account/avatar/00/10/7e/dd/e4e6718a.jpg","comment_is_top":false,"comment_ctime":1529465674,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14414367562","product_id":100006701,"comment_content":"谢谢老师的回复，还是notify()&#47;notifyAll()问题，我想说的是被唤醒的线程再重新获取锁之前应该是阻塞状态吧。","like_count":3,"discussions":[{"author":{"id":1320592,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/90/f68608f3.jpg","nickname":"gwl","note":"","ucode":"24F334E9AC0313","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281933,"discussion_content":"https://www.zhihu.com/question/27654579\n推荐你看下这里第一个的图","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591844115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267472,"user_name":"SugarZh","can_delete":false,"product_type":"c1","uid":1198302,"ip_address":"","ucode":"5312F3B5DB671A","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/de/bebd1bf6.jpg","comment_is_top":false,"comment_ctime":1607760365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10197694957","product_id":100006701,"comment_content":"CountDownLatch其实有点类似go语言中的WaitGroup，都是等待所有线程都执行完，才会执行后续动作","like_count":2},{"had_liked":false,"id":150286,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573506540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10163441132","product_id":100006701,"comment_content":"semaphore主要是集中处理acquire&#47;release，控制进入关键区域的访问者个数。<br>典型用法一，semaphore初始化为5,表示可以有 5位访问者可以进入关键区域，每位访问者调用acquire获得进入关键区域的资格，也就是进入或等待。进入关键区的访问者访问者调用release，释放一个准入资格，其他等待中的一个访问者会被唤醒获准进入关键区域。<br>典型用法二，semaphore初始化为0,表示获取访问资格的访问者一开始处于等待状态，然后通过release(5)批量释放访问者进入关键区域 ，然后检查关键区域是否为空，再确定是否放下一批访问者进入。<br>","like_count":3},{"had_liked":false,"id":13337,"user_name":"zjh","can_delete":false,"product_type":"c1","uid":1125747,"ip_address":"","ucode":"3AB3862247BEF9","user_header":"","comment_is_top":false,"comment_ctime":1529544150,"is_pvip":false,"replies":[{"id":"4504","content":"不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529627839,"ip_address":"","comment_id":13337,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10119478742","product_id":100006701,"comment_content":"感觉再分布式的情况下，单体应用中需要多个线程并行的情况可能会被分散在多个应用里面，可能很少会用到CountDownLatch和cyclicbarrier，semaphore倒是比较适合用在分布式的场景下，用来做一些限流。<br><br>","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419616,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529627839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168058,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1578009136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872976432","product_id":100006701,"comment_content":"19 java并发包提供了哪些工具类 1 Java.util.concurrent及其子包，包含了java的各种并发工具类 1.1 提供了比synchronized更高级的同步结构 ，包括CountDownLatch，CyclicBarrier，Semaphore，可以实现更加丰富的线程操作 1.2  各种线程安全的容器 ConcurrentHashMap，ConcurrentSkipListMap，线程安全的数组 CopyOnWriteArrayList 1.3 各种并发队列BlockingQueue实现 ，比如ArrayBlockingQueue，SynchronousQueue或针对特定场景的PriorityBlockingQueue，1.4 强大的executor框架，可以创建不同类型的线程池和调度任务，不用自己创建。2 并发类的实际应用 CountDownLatch 允许一个或者多个线程等待某些操作完成，CyclicBarrier，允许多个线程等待达到某个屏障 ，Semphore java版本的信号量实现，2.1 Semphore通过限制一定数量的多个permit的方式，来达到限制统一资源访问的目的，Semphore是通过acquire和release，如果初始值设置为1，则1个线程通过acquire进入互斥状态，2.2 CountDownLatch和CyclicBarrier区别 CountDownLatch是不可以被重置的，CuclicBarrier可以被重置，CountDownLatch的基本操作组合是countdown&#47;await，调用 await的线程阻塞等待countDown足够的次数，不管一个还是多个线程，足够的次数即可。CyclicBarrier的组合就是await，当所有的伙伴都调用完了await，才会继续进行任务，并进行重置。CyclicBarrier 侧重的是线程，典型应用场景是等待比并发线程结束。Cyclic反应的是线程并发运行时的协调","like_count":2},{"had_liked":false,"id":82130,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1554127915,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5849095211","product_id":100006701,"comment_content":"一般用CountDownLatch来提高接口访问速度，不知道这样符不符合规范😂😂😂","like_count":1,"discussions":[{"author":{"id":1043495,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/27/f708ba52.jpg","nickname":"冷夜飞雪","note":"","ucode":"CC01ADAA8DFDFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374852,"discussion_content":"怎么做的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621388557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66921,"user_name":"……","can_delete":false,"product_type":"c1","uid":1116443,"ip_address":"","ucode":"DA4B01EDFA3B1C","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/1b/8665aa89.jpg","comment_is_top":false,"comment_ctime":1550042545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5845009841","product_id":100006701,"comment_content":"CyclicBarrier结合FixedThreadPool使用，如果屏障点多与线程池线程数，将会出现问题。","like_count":1},{"had_liked":false,"id":18621,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1533514735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828482031","product_id":100006701,"comment_content":"我的应用场景是异步发送一定数量的http消息，主线程等待 所有发送完毕，获取所有的发送成功数","like_count":1},{"had_liked":false,"id":18519,"user_name":"杨逸林","can_delete":false,"product_type":"c1","uid":1167233,"ip_address":"","ucode":"4BF3CF3E2F1AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","comment_is_top":false,"comment_ctime":1533405794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828373090","product_id":100006701,"comment_content":"大佬，我在我的博客上可以引用一些你写的ConcurrentHashMap的内容吗","like_count":1},{"had_liked":false,"id":15148,"user_name":"xinxin💛","can_delete":false,"product_type":"c1","uid":1120786,"ip_address":"","ucode":"885E23E7ACC1EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/12/71cbb5ec.jpg","comment_is_top":false,"comment_ctime":1530931356,"is_pvip":false,"replies":[{"id":"5327","content":"你是什么版本jdk？","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1531326536,"ip_address":"","comment_id":15148,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5825898652","product_id":100006701,"comment_content":"老师为什么我用ConcurrentHashMap执行remove操作的时候cpu总是跳得很高，hashmap就还好没那么夸张。。现在为了线程安全还是用ConcurrentHashMap，但执行remove操作的线程一多经常就卡死了。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420256,"discussion_content":"你是什么版本jdk？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531326536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13690,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1529930109,"is_pvip":false,"replies":[{"id":"4590","content":"这个...经验谈不上，我也没这经验；或者你可以对比二者的区别，加深理解；<br>为什么转？希望达到什么目标？","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529945632,"ip_address":"","comment_id":13690,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5824897405","product_id":100006701,"comment_content":"感觉CountDownLatch有点像c++中的条件锁，想问一下老师，可否给点从c++转java的建议。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419726,"discussion_content":"这个...经验谈不上，我也没这经验；或者你可以对比二者的区别，加深理解；\n为什么转？希望达到什么目标？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529945632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13179,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1529446379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5824413675","product_id":100006701,"comment_content":"客户端开发中遇到的并发场景会不会有点少？如果对并发领域有浓厚的兴趣，可以尝试超哪个方向转型（又或许不需要转型，只需要找一个方向来进行实践）？<br><br>老师课后留的问题，我在工作中没有遇到过。我在JAVA并发编程实践中了解到的一种场景是：需要测试N个线程并发执行某个任务时需要的时间。","like_count":1},{"had_liked":false,"id":283604,"user_name":"CharlieWong","can_delete":false,"product_type":"c1","uid":1393234,"ip_address":"","ucode":"0299043A439112","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Ko9aHAWDeYicZqElnJEoepIHLTpL8AkeicwQNsIFuZYpKAAkqkYgWmTMyqfQMSXlc5crCQWkpf8CrserhaT9mwsg/132","comment_is_top":false,"comment_ctime":1615855009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615855009","product_id":100006701,"comment_content":"只用过CountDownLatch来模拟测试并发调用","like_count":0},{"had_liked":false,"id":229422,"user_name":"大成尊者","can_delete":false,"product_type":"c1","uid":1783367,"ip_address":"","ucode":"42473322052B11","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/47/8e80082c.jpg","comment_is_top":false,"comment_ctime":1592990189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592990189","product_id":100006701,"comment_content":"你使用过类似 CountDownLatch 的同步结构解决实际问题吗？谈谈你的使用场景和心得。<br>答：使用过 CountDownLatch 进行多线程查询数据库。主线程New N个线程去执行任务，然后N个线程的所有查询结果汇总到一个ConcurrentLinkedQueue里面，每个线程执行完毕后，都countDown()，主线程await()等待N个线程全部执行完毕后，再使用查询结果。","like_count":0},{"had_liked":false,"id":192701,"user_name":"护爽使者","can_delete":false,"product_type":"c1","uid":1275464,"ip_address":"","ucode":"12DC35DD74671C","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/48/5ab89daa.jpg","comment_is_top":false,"comment_ctime":1584868890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584868890","product_id":100006701,"comment_content":"循环栅栏","like_count":0},{"had_liked":false,"id":185483,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1583590947,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1583590947","product_id":100006701,"comment_content":"CountDownLatch结合线程池使用的时候一定要小心，特别是并发量大于线程池大小的时候...别问我为什么知道😭","like_count":0,"discussions":[{"author":{"id":1320592,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/90/f68608f3.jpg","nickname":"gwl","note":"","ucode":"24F334E9AC0313","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281934,"discussion_content":"大于线程池大小的时候就会进入线程池队列，线城市队列满了就会再开线程，直到线程池的maxSize。。。所以是系统崩了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591844260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1181192,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","nickname":"Seven.Lin澤耿","note":"","ucode":"4CAB732CD6F149","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1320592,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/90/f68608f3.jpg","nickname":"gwl","note":"","ucode":"24F334E9AC0313","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":283494,"discussion_content":"直接没响应了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592283295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281934,"ip_address":""},"score":283494,"extra":""},{"author":{"id":1239696,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/90/95b862bc.jpg","nickname":"这是极客时间","note":"","ucode":"95EF3B568CAB7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181192,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","nickname":"Seven.Lin澤耿","note":"","ucode":"4CAB732CD6F149","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577059,"discussion_content":"通过自定义线程池能避免这个情况吧\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655905415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283494,"ip_address":""},"score":577059,"extra":""}]}]},{"had_liked":false,"id":150038,"user_name":"zaab","can_delete":false,"product_type":"c1","uid":1683063,"ip_address":"","ucode":"EE846895FF0C85","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QYKSUV20DMgBHAPLfgngdw4N8FHRCSBLCJueVRu9Ya1Ba2x4icx70zoVVFOZtG1K6TkHj5CFbuztQhRFyCjWXHQ/132","comment_is_top":false,"comment_ctime":1573451714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573451714","product_id":100006701,"comment_content":"CopyOnWriteArrayList使用的时候需要注意， 如果使用普通的for循环， 多线程的情况下， 在for循环的时候很可能会被读到修改的数据， 使用迭代器则不会有这种问题。<br>迭代器部分源码：<br> public Iterator&lt;E&gt; iterator() {<br>        return new COWIterator&lt;E&gt;(getArray(), 0);<br>    }<br>","like_count":0},{"had_liked":false,"id":136762,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1569504196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569504196","product_id":100006701,"comment_content":"CountDownLatch是为了保证线程间的顺序执行吧，CyclicBarrier则是线程间互相等待结束","like_count":0},{"had_liked":false,"id":89996,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1556360478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556360478","product_id":100006701,"comment_content":" mark 1.8提供了CompletableFuture ExecutorCompletionService","like_count":0},{"had_liked":false,"id":89780,"user_name":"木头疙瘩","can_delete":false,"product_type":"c1","uid":1025529,"ip_address":"","ucode":"FAA5C23F0C4BC3","user_header":"","comment_is_top":false,"comment_ctime":1556263114,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1556263114","product_id":100006701,"comment_content":"Java初级选手有一个小白的问题请教老师，关于文中提到的CopyOnWriteArrayList的add方法，既然方法中已经通过synchronized加锁了（我看了下源码，使用的是ReentrankLock加的锁，可能跟老师版本不同），那为何不能直接操作原数组还要copy一份新数组出来呢，希望老师能看到，谢谢~","like_count":0,"discussions":[{"author":{"id":1482665,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NPfmxlo2j93hOjYoJV54WHYFkeibzibUbRGhGCyicty5NXPx9XKxicZotfmjqhcibUbjJYnW8rLFDatleT2zhyaTlqg/132","nickname":"小永","note":"","ucode":"40AB78B21615D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6206,"discussion_content":"其实你说的是对的，如果只有一个add方法会存在并发修改，倒是没必要copy；但是还有add,remove,clear,set,另外主要还有addAll, removeAll这样重的并发写操作，另外你发现读操作并没有lock；这样cow有用武之地了，它能保证并发情况下写操作的同时不影响读操作，所谓的读写分离，写操作是互斥的，读操作是无锁的；这个东西本身的定位就是读多写少，倾向保证读的性能","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566786470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541386,"avatar":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","nickname":"N_H","note":"","ucode":"109B67557AB3CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8339,"discussion_content":"还有在循环遍历的时候可以不抛出异常 https://yq.aliyun.com/articles/665359","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567930285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82227,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1554166406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554166406","product_id":100006701,"comment_content":"关于CyclicBarrier有个问题，cb只有一个await方法来阻塞工作线程，直到所有规定数量的工作线程都达到await。但cb是如何计算工作线程达到await的呢？举例，cb的parties设置成4，启动5个调用await方法的工作线程，应该其中4个到达await之后内存屏障就解除了，但实际上线程会一直阻塞下去，就像没有所有线程都到达await一样，实际线程数必须和parties一致才能work。这怎么理解？","like_count":0},{"had_liked":false,"id":71467,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1551347865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551347865","product_id":100006701,"comment_content":"当需要一次性把大批量的数据加载到内存时，就可以使用CountDownLatch加载多个线程（分页加载，页总页数就是需要的线程树），然后把每页的记录数合并在一起就是所有的数据。","like_count":0},{"had_liked":false,"id":48381,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1544432470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544432470","product_id":100006701,"comment_content":"使用CountDownLatch做过一个日终统计用户每日交易额的功能，将用户通过id(long类型)取模,分步到10个线程进行操作，所有线程操作完毕以后，将结果汇总并进行下一步操作。","like_count":0},{"had_liked":false,"id":29900,"user_name":"shen","can_delete":false,"product_type":"c1","uid":1215066,"ip_address":"","ucode":"AE5737B0C7DC4F","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/5a/b67a82e3.jpg","comment_is_top":false,"comment_ctime":1538584992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538584992","product_id":100006701,"comment_content":"CountDownLatch比较典型的场景就是异步变同步，zookeeper watch调用等待","like_count":0},{"had_liked":false,"id":25231,"user_name":"泊浮目","can_delete":false,"product_type":"c1","uid":1067981,"ip_address":"","ucode":"182A7CC2F6BDAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/cd/185e5378.jpg","comment_is_top":false,"comment_ctime":1537274178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537274178","product_id":100006701,"comment_content":"那个angroid的问题不能通过join线程来解决吗","like_count":0},{"had_liked":false,"id":22890,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1536023849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536023849","product_id":100006701,"comment_content":"CopyOnWrite在替换老数组中，读操作会不会受到影响，迭代遍历操作会不会受到影响？","like_count":0},{"had_liked":false,"id":18620,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1533514696,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1533514696","product_id":100006701,"comment_content":"需要深入多次数阅读理解","like_count":0},{"had_liked":false,"id":14844,"user_name":"FKQ","can_delete":false,"product_type":"c1","uid":1118750,"ip_address":"","ucode":"A3F9464D73DC02","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/1e/b5cdff5f.jpg","comment_is_top":false,"comment_ctime":1530697699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530697699","product_id":100006701,"comment_content":"Android中多线程上传多张图片到阿里云，将每个线程返回的图片url地址，组合成一个数组传给服务端","like_count":0},{"had_liked":false,"id":13460,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1529654107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1529654107","product_id":100006701,"comment_content":"问个问题，CyclicBarrier初始化的Parties值是5，最后Await的是6，这种情况会是什么样子？","like_count":0},{"had_liked":false,"id":13458,"user_name":"如风","can_delete":false,"product_type":"c1","uid":1022124,"ip_address":"","ucode":"368918EC7DD548","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/ac/c2c4fd82.jpg","comment_is_top":false,"comment_ctime":1529648944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1529648944","product_id":100006701,"comment_content":"&quot;提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Sempahore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。”，发现一处拼写错误，在这一段中，Sempahore 拼写错了，应该是 Semaphore。","like_count":0},{"had_liked":false,"id":13349,"user_name":"步＊亮","can_delete":false,"product_type":"c1","uid":1005922,"ip_address":"","ucode":"CC3ACC68959BDF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/62/954065d4.jpg","comment_is_top":false,"comment_ctime":1529548718,"is_pvip":false,"replies":[{"id":"4508","content":"哈哈，那不是inner class","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529631146,"ip_address":"","comment_id":13349,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529548718","product_id":100006701,"comment_content":"SemaphoreWorker类应该为static","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419619,"discussion_content":"哈哈，那不是inner class","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529631146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13248,"user_name":"虞飞","can_delete":false,"product_type":"c1","uid":1053075,"ip_address":"","ucode":"601B864214C4F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/93/8b41390b.jpg","comment_is_top":false,"comment_ctime":1529468189,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1529468189","product_id":100006701,"comment_content":"copyonwriteArrayList循环插入大量数据时（比如100万个） 效率很低，因为它形成了100万次快照，那从理论上来说，有没有可能形成一次快照插100万条数据呢？","like_count":0}]}