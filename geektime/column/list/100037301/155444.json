{"id":155444,"title":"06 | 领域事件：解耦微服务的关键","content":"<p>你好，我是欧创新。今天我们来聊一聊“领域事件（Domain Event）”。</p><p>在事件风暴（Event Storming）时，我们发现除了命令和操作等业务行为以外，还有一种非常重要的事件，<span class=\"orange\">这种事件发生后通常会导致进一步的业务操作，在DDD中这种事件被称为领域事件。</span></p><p>这只是最简单的定义，并不能让我们真正理解它。那到底什么是领域事件？领域事件的技术实现机制是怎样的？这一讲，我们就重点解决这两个大的问题。</p><h2>领域事件</h2><p>领域事件是领域模型中非常重要的一部分，用来表示领域中发生的事件。一个领域事件将导致进一步的业务操作，在实现业务解耦的同时，还有助于形成完整的业务闭环。</p><p>举例来说的话，领域事件可以是业务流程的一个步骤，比如投保业务缴费完成后，触发投保单转保单的动作；也可能是定时批处理过程中发生的事件，比如批处理生成季缴保费通知单，触发发送缴费邮件通知操作；或者一个事件发生后触发的后续动作，比如密码连续输错三次，触发锁定账户的动作。</p><p><strong>那如何识别领域事件呢？</strong></p><p>很简单，和刚才讲的定义是强关联的。在做用户旅程或者场景分析时，我们要捕捉业务、需求人员或领域专家口中的关键词：“如果发生……，则……”“当做完……的时候，请通知……”“发生……时，则……”等。在这些场景中，如果发生某种事件后，会触发进一步的操作，那么这个事件很可能就是领域事件。</p><!-- [[[read_end]]] --><p>那领域事件为什么要用最终一致性，而不是传统SOA的直接调用的方式呢？</p><p>我们一起回顾一下 <a href=\"https://time.geekbang.org/column/article/154547\">[第05讲]</a> 讲到的聚合的一个设计原则：<span class=\"orange\">在边界之外使用最终一致性。</span>一次事务最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的最终一致性。</p><p>领域事件驱动设计可以切断领域模型之间的强依赖关系，事件发布完成后，发布方不必关心后续订阅方事件处理是否成功，这样可以实现领域模型的解耦，维护领域模型的独立性和数据的一致性。在领域模型映射到微服务系统架构时，领域事件可以解耦微服务，微服务之间的数据不必要求强一致性，而是基于事件的最终一致性。</p><p>回到具体的业务场景，我们发现有的领域事件发生在微服务内的聚合之间，有的则发生在微服务之间，还有两者皆有的场景，一般来说跨微服务的领域事件处理居多。在微服务设计时不同领域事件的处理方式会不一样。</p><h3>1. 微服务内的领域事件</h3><p>当领域事件发生在微服务内的聚合之间，领域事件发生后完成事件实体构建和事件数据持久化，发布方聚合将事件发布到事件总线，订阅方接收事件数据完成后续业务操作。</p><p>微服务内大部分事件的集成，都发生在同一个进程内，进程自身可以很好地控制事务，因此不一定需要引入消息中间件。但一个事件如果同时更新多个聚合，按照DDD“一次事务只更新一个聚合”的原则，你就要考虑是否引入事件总线。但微服务内的事件总线，可能会增加开发的复杂度，因此你需要结合应用复杂度和收益进行综合考虑。</p><p>微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，这种方式通常应用于实时性和数据一致性要求高的场景。这个过程会用到分布式事务，以保证发布方和订阅方的数据同时更新成功。</p><h3>2. 微服务之间的领域事件</h3><p>跨微服务的领域事件会在不同的限界上下文或领域模型之间实现业务协作，其主要目的是实现微服务解耦，减轻微服务之间实时服务访问的压力。</p><p>领域事件发生在微服务之间的场景比较多，事件处理的机制也更加复杂。跨微服务的事件可以推动业务流程或者数据在不同的子域或微服务间直接流转。</p><p>跨微服务的事件机制要总体考虑事件构建、发布和订阅、事件数据持久化、消息中间件，甚至事件数据持久化时还可能需要考虑引入分布式事务机制等。</p><p>微服务之间的访问也可以采用应用服务直接调用的方式，实现数据和服务的实时访问，弊端就是跨微服务的数据同时变更需要引入分布式事务，以确保数据的一致性。分布式事务机制会影响系统性能，增加微服务之间的耦合，所以我们还是要尽量避免使用分布式事务。</p><h2>领域事件相关案例</h2><p>我来给你介绍一个保险承保业务过程中有关领域事件的案例。</p><p>一个保单的生成，经历了很多子域、业务状态变更和跨微服务业务数据的传递。这个过程会产生很多的领域事件，这些领域事件促成了保险业务数据、对象在不同的微服务和子域之间的流转和角色转换。</p><p>在下面这张图中，我列出了几个关键流程，用来说明如何用领域事件驱动设计来驱动承保业务流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/23/93/23e38df6e78c0a10ddf27f8a254c0093.jpg?wh=2260*1296\" alt=\"\"></p><p><strong>事件起点：客户购买保险-业务人员完成保单录入-生成投保单-启动缴费动作。</strong></p><p>1.投保微服务生成缴费通知单，发布第一个事件：缴费通知单已生成，将缴费通知单数据发布到消息中间件。收款微服务订阅缴费通知单事件，完成缴费操作。缴费通知单已生成，领域事件结束。</p><p>2.收款微服务缴费完成后，发布第二个领域事件：缴费已完成，将缴费数据发布到消息中间件。原来的订阅方收款微服务这时则变成了发布方。原来的事件发布方投保微服务转换为订阅方。投保微服务在收到缴费信息并确认缴费完成后，完成投保单转成保单的操作。缴费已完成，领域事件结束。</p><p>3.投保微服务在投保单转保单完成后，发布第三个领域事件：保单已生成，将保单数据发布到消息中间件。保单微服务接收到保单数据后，完成保单数据保存操作。保单已生成，领域事件结束。</p><p>4.保单微服务完成保单数据保存后，后面还会发生一系列的领域事件，以并发的方式将保单数据通过消息中间件发送到佣金、收付费和再保等微服务，一直到财务，完后保单后续所有业务流程。这里就不详细说了。</p><p>总之，通过领域事件驱动的异步化机制，可以推动业务流程和数据在各个不同微服务之间的流转，实现微服务的解耦，减轻微服务之间服务调用的压力，提升用户体验。</p><h2>领域事件总体架构</h2><p>领域事件的执行需要一系列的组件和技术来支撑。我们来看一下这个领域事件总体技术架构图，<span class=\"orange\">领域事件处理包括：事件构建和发布、事件数据持久化、事件总线、消息中间件、事件接收和处理等。</span>下面我们逐一讲一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/8f/b221ed4011c23720ebe9f48ba8eee38f.jpg?wh=1768*976\" alt=\"\"></p><h3>1. 事件构建和发布</h3><p>事件基本属性至少包括：事件唯一标识、发生时间、事件类型和事件源，其中事件唯一标识应该是全局唯一的，以便事件能够无歧义地在多个限界上下文中传递。事件基本属性主要记录事件自身以及事件发生背景的数据。</p><p>另外事件中还有一项更重要，那就是业务属性，用于记录事件发生那一刻的业务数据，这些数据会随事件传输到订阅方，以开展下一步的业务操作。</p><p>事件基本属性和业务属性一起构成事件实体，事件实体依赖聚合根。领域事件发生后，事件中的业务数据不再修改，因此业务数据可以以序列化值对象的形式保存，这种存储格式在消息中间件中也比较容易解析和获取。</p><p>为了保证事件结构的统一，我们还会创建事件基类 DomainEvent（参考下图），子类可以扩充属性和方法。由于事件没有太多的业务行为，实现方法一般比较简单。</p><p><img src=\"https://static001.geekbang.org/resource/image/33/ec/3331c2d87d4dc0e68ec99fc9e02b44ec.jpg?wh=698*502\" alt=\"\"></p><p>事件发布之前需要先构建事件实体并持久化。事件发布的方式有很多种，你可以通过应用服务或者领域服务发布到事件总线或者消息中间件，也可以从事件表中利用定时程序或数据库日志捕获技术获取增量事件数据，发布到消息中间件。</p><h3>2. 事件数据持久化</h3><p>事件数据持久化可用于系统之间的数据对账，或者实现发布方和订阅方事件数据的审计。当遇到消息中间件、订阅方系统宕机或者网络中断，在问题解决后仍可继续后续业务流转，保证数据的一致性。</p><p>事件数据持久化有两种方案，在实施过程中你可以根据自己的业务场景进行选择。</p><ul>\n<li>持久化到本地业务数据库的事件表中，利用本地事务保证业务和事件数据的一致性。</li>\n<li>持久化到共享的事件数据库中。这里需要注意的是：业务数据库和事件数据库不在一个数据库中，它们的数据持久化操作会跨数据库，因此需要分布式事务机制来保证业务和事件数据的强一致性，结果就是会对系统性能造成一定的影响。</li>\n</ul><h3>3. 事件总线(EventBus)</h3><p>事件总线是实现微服务内聚合之间领域事件的重要组件，它提供事件分发和接收等服务。事件总线是进程内模型，它会在微服务内聚合之间遍历订阅者列表，采取同步或异步的模式传递数据。事件分发流程大致如下：</p><ul>\n<li>如果是微服务内的订阅者（其它聚合），则直接分发到指定订阅者；</li>\n<li>如果是微服务外的订阅者，将事件数据保存到事件库（表）并异步发送到消息中间件；</li>\n<li>如果同时存在微服务内和外订阅者，则先分发到内部订阅者，将事件消息保存到事件库（表），再异步发送到消息中间件。</li>\n</ul><h3>4. 消息中间件</h3><p>跨微服务的领域事件大多会用到消息中间件，实现跨微服务的事件发布和订阅。消息中间件的产品非常成熟，市场上可选的技术也非常多，比如Kafka，RabbitMQ等。</p><h3>5. 事件接收和处理</h3><p>微服务订阅方在应用层采用监听机制，接收消息队列中的事件数据，完成事件数据的持久化后，就可以开始进一步的业务处理。领域事件处理可在领域服务中实现。</p><h2>领域事件运行机制相关案例</h2><p>这里我用承保业务流程的缴费通知单事件，来给你解释一下领域事件的运行机制。这个领域事件发生在投保和收款微服务之间。发生的领域事件是：缴费通知单已生成。下一步的业务操作是：缴费。</p><p><img src=\"https://static001.geekbang.org/resource/image/89/11/89321072afd996c6a90fa9774f769e11.jpg?wh=2073*1005\" alt=\"\"></p><p><strong>事件起点：出单员生成投保单，核保通过后，发起生成缴费通知单的操作。</strong></p><p>1.投保微服务应用服务，调用聚合中的领域服务createPaymentNotice和createPaymentNoticeEvent，分别创建缴费通知单、缴费通知单事件。其中缴费通知单事件类PaymentNoticeEvent继承基类DomainEvent。</p><p>2.利用仓储服务持久化缴费通知单相关的业务和事件数据。为了避免分布式事务，这些业务和事件数据都持久化到本地投保微服务数据库中。</p><p>3.通过数据库日志捕获技术或者定时程序，从数据库事件表中获取事件增量数据，发布到消息中间件。这里说明：事件发布也可以通过应用服务或者领域服务完成发布。</p><p>4.收款微服务在应用层从消息中间件订阅缴费通知单事件消息主题，监听并获取事件数据后，应用服务调用领域层的领域服务将事件数据持久化到本地数据库中。</p><p>5.收款微服务调用领域层的领域服务PayPremium，完成缴费。</p><p>6.事件结束。</p><p>提示：缴费完成后，后续流程的微服务还会产生很多新的领域事件，比如缴费已完成、保单已保存等等。这些后续的事件处理基本上跟 1～6 的处理机制类似。</p><h2>总结</h2><p>今天我们主要讲了领域事件以及领域事件的处理机制。领域事件驱动是很成熟的技术，在很多分布式架构中得到了大量的使用。领域事件是DDD的一个重要概念，在设计时我们要重点关注领域事件，用领域事件来驱动业务的流转，尽量采用基于事件的最终一致，降低微服务之间直接访问的压力，实现微服务之间的解耦，维护领域模型的独立性和数据一致性。</p><p>除此之外，领域事件驱动机制可以实现一个发布方N个订阅方的模式，这在传统的直接服务调用设计中基本是不可能做到的。</p><h2>思考题</h2><p>思考一下你公司有哪些业务场景可以采用领域事件驱动的设计方式？</p><p>欢迎留言和我分享你的思考，你也可以把今天所学分享给身边的朋友，邀请他加入探讨，共同进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/33/7b1a917aff0ec923b78a54e81ed90733.jpg?wh=1110*659\" alt=\"unpreview\"></p>","comments":[{"had_liked":false,"id":144502,"user_name":"阿神","can_delete":false,"product_type":"c1","uid":1014761,"ip_address":"","ucode":"E34BA27C101E9F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/e9/5955aa73.jpg","comment_is_top":false,"comment_ctime":1571961241,"is_pvip":false,"replies":[{"id":"55701","content":"我跟你的观点一样。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571965945,"ip_address":"","comment_id":144502,"utype":1}],"discussion_count":20,"race_medal":0,"score":"246385097113","product_id":100037301,"comment_content":"微服务内的领域事件我建议少用，增加复杂性了","like_count":58,"discussions":[{"author":{"id":1041879,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/d7/d48f6b04.jpg","nickname":"Albert🐎","note":"","ucode":"48CF4C1211A3E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45103,"discussion_content":"事件发布订阅会让调用关系变的不够清晰。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1573004116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1594444,"avatar":"https://static001.geekbang.org/account/avatar/00/18/54/4c/a10605c9.jpg","nickname":"虾米","note":"","ucode":"6217B2D9E1E4E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138491,"discussion_content":"如果微服务内，不使用领域事件的话，是不是领域边界的逻辑处理就会采用同步调用处理？如此以来会不会又回到原始的开发模型，且边界模糊，难以测试？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1579247957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3009726,"avatar":"","nickname":"凌晨写Bug","note":"","ucode":"7345C0A982B6BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1594444,"avatar":"https://static001.geekbang.org/account/avatar/00/18/54/4c/a10605c9.jpg","nickname":"虾米","note":"","ucode":"6217B2D9E1E4E3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573516,"discussion_content":"微服务内直接调用问题不大，本身微服务粒度就不大。而且调用传参可以使用领域事件数据作为参数，用起来直观可以清晰知道是哪个领域事件的调用，而且后续改成事件总线调用也方便。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1653471254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":138491,"ip_address":""},"score":573516,"extra":""}]},{"author":{"id":1795341,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/0d/eab13441.jpg","nickname":"迎波扬帆","note":"","ucode":"D015FBAE853ABC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264582,"discussion_content":"不用领域事件就很难把聚合分界，event sourcing 这种模式也不好落地了。用event，那整个系统就不再是接口请求调用servise，而是接口请求后发送command，comnand触发相应的服务，进而再发起event，触发相应服务。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589334887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1094726,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b4/46/686f5abe.jpg","nickname":"SnoWalker","note":"","ucode":"826A3DE7E3AEC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263271,"discussion_content":"可以通过使用SpringEvent来降低复杂度，同时也支持事务","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589194370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1434423,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","nickname":"WESTWALL","note":"","ucode":"295A030F9D3BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1094726,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b4/46/686f5abe.jpg","nickname":"SnoWalker","note":"","ucode":"826A3DE7E3AEC9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411606,"discussion_content":"竟然还才知道哎，谢谢老哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635952283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263271,"ip_address":""},"score":411606,"extra":""}]},{"author":{"id":1222578,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a7/b2/274a4192.jpg","nickname":"漂泊的小飘","note":"","ucode":"25C0CA4887D8AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164907,"discussion_content":"如果微服务拆分的话。微服务内事件扩展性好一点吧。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581234873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471975,"discussion_content":"我跟你的观点一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571965945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1486895,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b0/2f/e2096905.jpg","nickname":"马成","note":"","ucode":"664F2BAA2E0F0B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365364,"discussion_content":"微服务内使用事件，而且是基于消息中间件的事件，还有一个重要作用是解决集群之间的事件协同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617783507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1193337,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","nickname":"Keith","note":"","ucode":"B40774090714D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1486895,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b0/2f/e2096905.jpg","nickname":"马成","note":"","ucode":"664F2BAA2E0F0B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":368190,"discussion_content":"微服务内的事件传递跟集群有什么关系?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618589627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365364,"ip_address":""},"score":368190,"extra":""}]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235477,"discussion_content":"领域事件才是真的好用，并没有增加复杂性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587041662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306531,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ef/a3/e9218325.jpg","nickname":"猩猩福斯","note":"","ucode":"289CE3376AA5CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205600,"discussion_content":"微服务内可以使用发布订阅设计模式，例如spring event","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584325395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1520451,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLqrAA1j4Oyy6ibicNOicn8K0olrEjtLLanic8V0y9icia6cvCVRCiabOm5llC0WhzcSWvaI2fia75hYbvjrQ/132","nickname":"幽林萌逐","note":"","ucode":"E6D95EC891800F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1306531,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ef/a3/e9218325.jpg","nickname":"猩猩福斯","note":"","ucode":"289CE3376AA5CE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381100,"discussion_content":"咨询下spring event 和利用mq 发布订阅看上去没啥区别？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624891699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":205600,"ip_address":""},"score":381100,"extra":""},{"author":{"id":1434423,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","nickname":"WESTWALL","note":"","ucode":"295A030F9D3BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1520451,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLqrAA1j4Oyy6ibicNOicn8K0olrEjtLLanic8V0y9icia6cvCVRCiabOm5llC0WhzcSWvaI2fia75hYbvjrQ/132","nickname":"幽林萌逐","note":"","ucode":"E6D95EC891800F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558070,"discussion_content":"sping event是个观察者模式的实现，同步的，可以支持事务","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648083896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381100,"ip_address":""},"score":558070,"extra":""}]},{"author":{"id":1748516,"avatar":"","nickname":"Geek_fa4b49","note":"","ucode":"09559B605EB8D7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70188,"discussion_content":"深有体会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575335658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005589,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/15/56f4e62a.jpg","nickname":"antz","note":"","ucode":"BDFDED6D7F0BD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47931,"discussion_content":"那夸聚合操作，直接在同一个事务中执行吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573436172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005589,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/15/56f4e62a.jpg","nickname":"antz","note":"","ucode":"BDFDED6D7F0BD2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186553,"discussion_content":"反正在一个进程内，应该是在同一个事务中执行，也就是数据的强一致性了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582691474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47931,"ip_address":""},"score":186553,"extra":""},{"author":{"id":1042354,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e7/b2/334bc992.jpg","nickname":"AlfredLover","note":"","ucode":"A3A998F362CC37","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234893,"discussion_content":"一般就是在一个Service里面直接事务处理了，强一致性。性能也不会差，简单粗暴。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587004389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186553,"ip_address":""},"score":234893,"extra":""},{"author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005589,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/15/56f4e62a.jpg","nickname":"antz","note":"","ucode":"BDFDED6D7F0BD2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413566,"discussion_content":"跨聚合用应用层调用领域服务就可以呀，事务不是尽量少用么","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636513180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47931,"ip_address":""},"score":413566,"extra":""}]},{"author":{"id":1104835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","nickname":"张迪","note":"","ucode":"6A5D44999A0FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41818,"discussion_content":"微服务内不是用领域事件，合作做到 应用层多个聚合的调用 数据一致性？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572511730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174919,"user_name":"兆哲","can_delete":false,"product_type":"c1","uid":1269847,"ip_address":"","ucode":"1DAEA37570CB45","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/57/70930a43.jpg","comment_is_top":false,"comment_ctime":1580458325,"is_pvip":false,"replies":[{"id":"67998","content":"在微服务设计时，微服务之间尽量通过领域事件的方式来解耦，耦合度过高，在一个微服务出现问题时容易导致整体出现雪崩现象。这种异步方式不仅可以解耦微服务，还可以起到削峰填谷的作用。所以非实时的调用尽量采用领域事件的方式。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1580546537,"ip_address":"","comment_id":174919,"utype":1}],"discussion_count":10,"race_medal":0,"score":"113249608021","product_id":100037301,"comment_content":"在公司与同事沟通微服务之间的关系的时候，DDD提倡服务之间使用领域事件进行解耦，<br>但是某些同事觉得，rpc调用与通过总线发布事件，在执行的内容上没有本质上减少的东西（RPC<br>调用失败也可以加入重试机制），并且这种解耦方式可能会导致追踪调用链路更加困难。<br>如何看待这样的解读呢？","like_count":27,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482566,"discussion_content":"在微服务设计时，微服务之间尽量通过领域事件的方式来解耦，耦合度过高，在一个微服务出现问题时容易导致整体出现雪崩现象。这种异步方式不仅可以解耦微服务，还可以起到削峰填谷的作用。所以非实时的调用尽量采用领域事件的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580546537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1808666,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/99/1a/196ff5f8.jpg","nickname":"长空","note":"","ucode":"EFE7E08491849C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177390,"discussion_content":"RPC和HTTP api调用在这个地方本质上是一样的。  \n\nRPC\\HTTP api\\本地方法调用: 一对一的同步调用\n总线\\mq\\其它: 广播的方式\n\n所以说用事件总线会解耦，而RPC不是解耦\n\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582102989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1023729,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9e/f1/abb7bfe3.jpg","nickname":"szs","note":"","ucode":"1EA8129BC61EFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1808666,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/99/1a/196ff5f8.jpg","nickname":"长空","note":"","ucode":"EFE7E08491849C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401187,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633597458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177390,"ip_address":""},"score":401187,"extra":""}]},{"author":{"id":1069797,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83er77H7TocrQqc0NsfkNjY4QT9llye3XxbZkIcBuX32RWwf4nA46EFvWaUncxcYZmP8wXMicz2TnkIw/132","nickname":"sum","note":"","ucode":"5058D2F417AA82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384739,"discussion_content":"我们这边追踪调用链路是通过事件ID或业务流水号来解决的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626734565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2043302,"avatar":"","nickname":"0092","note":"","ucode":"A95EF45C914BC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345015,"discussion_content":"mq解耦在国内落地会遇到一些现实问题，不讲原则，扯皮，以及管理者的胆大包天。。。最终落地时可能会由于前面这些因素导致出问题不好排查。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611639734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580040,"discussion_content":"除了解耦，消峰，领域事件能让具体业务聚焦在本域当中。\n比如交易成功，如果要发优惠券，还有其它业务，如果同步api调，交易域耦合其它域信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657845266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1080050,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/f2/6770d0a9.jpg","nickname":"张驰","note":"","ucode":"0ED97C2FCE6599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381003,"discussion_content":"MQ终将有性能瓶颈，如果用RPC就可以无限扩容下去，比如我现在有一个18万TPS的交易系统，如果改成MQ，那么MQ将成为我的性能瓶颈。  而RPC可以通过硬件无限扩容（不考虑注册中心的瓶颈问题）提升性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624863807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1507024,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/d0/e80e4a7e.jpg","nickname":"zhangyi","note":"","ucode":"0C4CAE9DA878F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1080050,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/f2/6770d0a9.jpg","nickname":"张驰","note":"","ucode":"0ED97C2FCE6599","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387155,"discussion_content":"mq作为一种分布式产物，也是支持扩容的。所以mq不会成为你所说的瓶颈","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1628006982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381003,"ip_address":""},"score":387155,"extra":""},{"author":{"id":1270239,"avatar":"https://static001.geekbang.org/account/avatar/00/13/61/df/c9470e1f.jpg","nickname":"明同学","note":"","ucode":"4F0877EB8B942E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1080050,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/f2/6770d0a9.jpg","nickname":"张驰","note":"","ucode":"0ED97C2FCE6599","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539639,"discussion_content":"18万tps，夸张了吧，现在国内没有平台有这个要求","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639795865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381003,"ip_address":""},"score":539639,"extra":""},{"author":{"id":1933878,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/82/36/f821ee14.jpg","nickname":"lipop","note":"","ucode":"22D9A38BD7A298","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1270239,"avatar":"https://static001.geekbang.org/account/avatar/00/13/61/df/c9470e1f.jpg","nickname":"明同学","note":"","ucode":"4F0877EB8B942E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":576511,"discussion_content":"淘宝双十一不就是50多万tps","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655617703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":539639,"ip_address":""},"score":576511,"extra":""}]}]},{"had_liked":false,"id":145197,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1572228925,"is_pvip":false,"replies":[{"id":"55988","content":"第一个问题：虽然这些消息队列自身有持久化的功能，但是中间过程，或者在订阅到数据后，在处理之前出问题，需要进行数据对账，这样就没法找到发布时和处理后的数据版本。关键的业务数据我建议还是落库比较好。<br>第二个问题：事件实体的业务数据还是按需发布比较好，避免不必要的业务信息泄露。<br>第三个问题：CDC的设计方式比较简单，属于数据库底层的技术，不会对上层应用产生太多的影响。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572230787,"ip_address":"","comment_id":145197,"utype":1}],"discussion_count":10,"race_medal":0,"score":"96061509437","product_id":100037301,"comment_content":"关于领域事件有几个问题：<br>1、如果采用了主流的消息队列（如rabbitmq，kafka，rocketmq），是否领域事件还需要持久化？<br>2、对于领域事件的内容，是否需要把所有变化（或绝大多数）的内容都保存到事件里面（比如保单里面的所有内容）？这样的话这个这个领域事件会不会比较大？<br>3、关于领域事件还有一种方案就是基于数据库cdc的方式，在系统中有大量领域事件的场景下，是否cdc的形式更加灵活一点？","like_count":23,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472284,"discussion_content":"第一个问题：虽然这些消息队列自身有持久化的功能，但是中间过程，或者在订阅到数据后，在处理之前出问题，需要进行数据对账，这样就没法找到发布时和处理后的数据版本。关键的业务数据我建议还是落库比较好。\n第二个问题：事件实体的业务数据还是按需发布比较好，避免不必要的业务信息泄露。\n第三个问题：CDC的设计方式比较简单，属于数据库底层的技术，不会对上层应用产生太多的影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572230787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069797,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83er77H7TocrQqc0NsfkNjY4QT9llye3XxbZkIcBuX32RWwf4nA46EFvWaUncxcYZmP8wXMicz2TnkIw/132","nickname":"sum","note":"","ucode":"5058D2F417AA82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384740,"discussion_content":"我们这边事件数据就是放到一个大JSON字段中，优点：数据比较全，缺点：传递和解析时会比较麻烦，特别是在做日终对账时的解析。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626735189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351805,"discussion_content":"CDC这个名词学习了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614445152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":409723,"discussion_content":"change data capture  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635496585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351805,"ip_address":""},"score":409723,"extra":""}]},{"author":{"id":1364986,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/eOb0Z9PVwFnfZthnxvYzL3uIoXZXsDZHaZQS97beFNyqVskWEeumxputYTAUGLqsuWG1f9ApV8c1BaXHkMibIRg/132","nickname":"Cydeer","note":"","ucode":"5E6DC0909D5916","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589226,"discussion_content":"关于第二点，一个发布方，多个订阅方，多个订阅方需要的数据是有一些区别的，事件实体中用所有订阅方使用的最全的数据吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664533156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/3d/1189e48a.jpg","nickname":"微思","note":"","ucode":"853C48AA183A7B","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404452,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634308257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88712,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576726861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005589,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/15/56f4e62a.jpg","nickname":"antz","note":"","ucode":"BDFDED6D7F0BD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47926,"discussion_content":"第二点还是比较纠结的，所以我们根据业务场景，有的地方把通用数据尽可能满足订阅者需要，有的地方只提供id","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573435993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1211243,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/6b/c630d446.jpg","nickname":"huhuhu","note":"","ucode":"C57587C430E42B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005589,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/15/56f4e62a.jpg","nickname":"antz","note":"","ucode":"BDFDED6D7F0BD2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368887,"discussion_content":"同样纠结，如果传递id还要做跨聚合调用查询，但是传递又可能造成多个订阅方同时修改造成数据不一致的情况，求老师解答","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618861778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47926,"ip_address":""},"score":368887,"extra":""},{"author":{"id":1507024,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/d0/e80e4a7e.jpg","nickname":"zhangyi","note":"","ucode":"0C4CAE9DA878F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1211243,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/6b/c630d446.jpg","nickname":"huhuhu","note":"","ucode":"C57587C430E42B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387156,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628007090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368887,"ip_address":""},"score":387156,"extra":""}]}]},{"had_liked":false,"id":144521,"user_name":"游泳速度快内裤跟不上","can_delete":false,"product_type":"c1","uid":1305954,"ip_address":"","ucode":"3EAD2BCDC39A3E","user_header":"https://static001.geekbang.org/account/avatar/00/13/ed/62/864dbe69.jpg","comment_is_top":false,"comment_ctime":1571965049,"is_pvip":false,"replies":[{"id":"55741","content":"事件总线你可以理解为运行在同一个进程内的消息中间件，它是一个很小的技术组件，可以通过配置支持异步或同步的消息机制。具体实现你可以查阅一下Eventbus组件相关的资料。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571983858,"ip_address":"","comment_id":144521,"utype":1}],"discussion_count":3,"race_medal":0,"score":"61701507193","product_id":100037301,"comment_content":"跨微服务的聚合间的领域事件驱动用消息中间件来衔接，这个比较容易理解，同一微服务内的聚合间的在实现层面如何来衔接呢，不太清楚这里面说的事件总线是一个什么概念，这个落实到代码上的话具体如何实现呢","like_count":15,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471986,"discussion_content":"事件总线你可以理解为运行在同一个进程内的消息中间件，它是一个很小的技术组件，可以通过配置支持异步或同步的消息机制。具体实现你可以查阅一下Eventbus组件相关的资料。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571983858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369756,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIopdUJmtgpsr9GibAibcZgS7h23P4FrgBfed3WveI4b4f8Vl2JjibhCzib9Y8Vs2M1PGQr7cwoKADxZQ/132","nickname":"秦道","note":"","ucode":"BE195C09BD14A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299120,"discussion_content":"微服务内的聚合间调用使用领域时间落地：Guava的EventBus了解一下，进程内的，不存在分布式事务问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597569049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437715,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f0/13/e5d0355a.jpg","nickname":"杨志远","note":"","ucode":"24F0BF091EDCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294431,"discussion_content":"同一个聚合内，应用服务层直接调用，考虑不同的场景（是否跨数据库操作）采用事务或分布式事务，确保数据一致性。事件总线应该是指一类组件，可以理解成消息中间件，springcloud bus也是通过关联消息队列的总线","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595893218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256547,"user_name":"信了","can_delete":false,"product_type":"c1","uid":1368648,"ip_address":"","ucode":"EA188A1DD1D390","user_header":"https://static001.geekbang.org/account/avatar/00/14/e2/48/6c066714.jpg","comment_is_top":false,"comment_ctime":1603675776,"is_pvip":false,"replies":[{"id":"93392","content":"createPaymentNotice完成领域模型的业务逻辑：创建缴费通知单，createPaymentNoticeEvent是在领域逻辑完成后，执行领域事件发布逻辑：创建缴费通知单事件。在这个案例中，将业务逻辑处理和事件处理逻辑做了分离，然后在应用层来编排，这样的好处是可以实现事件发布逻辑的复用。如果不需要复用，你也可以直接在统一个领域服务中完成业务逻辑处理和领域事件发布逻辑，不需要上升到应用层来编排。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1603691092,"ip_address":"","comment_id":256547,"utype":1}],"discussion_count":3,"race_medal":0,"score":"48848316032","product_id":100037301,"comment_content":"在领域事件运行机制相关案例中，投保微服务有两个领域服务，createPaymentNotice 和 createPaymentNoticeEvent，createPaymentNoticeEvent是为了创建缴费通知单事件，而createPaymentNotice是做什么的？","like_count":11,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508049,"discussion_content":"createPaymentNotice完成领域模型的业务逻辑：创建缴费通知单，createPaymentNoticeEvent是在领域逻辑完成后，执行领域事件发布逻辑：创建缴费通知单事件。在这个案例中，将业务逻辑处理和事件处理逻辑做了分离，然后在应用层来编排，这样的好处是可以实现事件发布逻辑的复用。如果不需要复用，你也可以直接在统一个领域服务中完成业务逻辑处理和领域事件发布逻辑，不需要上升到应用层来编排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603691092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543360,"discussion_content":"老师 那不就相当于完成了业务逻辑之后再处理领域事件的发布 那不是同一个进程内调用应用服务调应用服务吗？这样可以调吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641105731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":508049,"ip_address":""},"score":543360,"extra":""}]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331725,"discussion_content":"老师好像在那篇提过：事件的发布可以在领域层，可以在应用层，但是为了复用建议发布和订阅都放在应用层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606962354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239502,"user_name":"昌南一枝花","can_delete":false,"product_type":"c1","uid":2089155,"ip_address":"","ucode":"66118BEFFDC9BF","user_header":"","comment_is_top":false,"comment_ctime":1596550849,"is_pvip":false,"replies":[{"id":"88554","content":"这是因为聚合是微服务内最小的业务功能单元。为了保证聚合内数据更新时，符合聚合内固定的业务规则，在一次事务提交时通常会将聚合内所有变更的对象数据作为整体，通过聚合领域服务或聚合根方法一次通过仓储完成数据持久化操作。如果在一次交易中需要同时更新多个聚合数据，那么每一个聚合就是一个独立的数据提交单元，我们需要确保多个聚合数据都能在这个交易中提交更新成功，以保证不同聚合数据的一致性。<br>   为什么要做聚合之间的解耦，这是因为微服务的架构演进基本是以聚合为单位来演进的，未来在业务演进时微服务可能会根据聚合功能来重新拆分和组合聚合，所以要提前做好聚合之间的解耦，如果聚合的解耦做的不好，微服务演进时重新拆分和组合的工作量会非常大。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1596672965,"ip_address":"","comment_id":239502,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31661321921","product_id":100037301,"comment_content":"       微服务内使用诸如SpringEvent同步方式保证在一个事务在修改多个聚合数据时，数据一致性得到了保证。但和前一讲提到的聚合设计原则跨聚合操作不应放在一个事务中，而应保证最终一致性略有矛盾。<br>       是不是可以理解为Martinflow原本是想按聚合拆分微服务，所以跨聚合的操作不应放在一个事务里，否则没法按聚合拆分了。但实际应用中很少按聚合拆分微服务，为了方便也就允许跨聚合修改放一个本地事务里，后面万一要按聚合拆分微服务再拆分本地事务。","like_count":8,"discussions":[{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331733,"discussion_content":"\n\n现在感觉明白了，总结一下：\n如果是同个一微服务内，跨聚合的数据更新，为了保证数据一致性，建议标准的做法是通过领域事件解耦。\n\n同个一微服务内，如果跨聚合的数据更新，聚合在同一个数据库\n\t1.可以通过事件总线（单进程）来解耦，但是可能会增加复杂度\n\t2.可以通过本地事务直接保证 不同聚合的数据更新一致性，这是权衡后的实践经验\n\t3.按照老师说的 “在DDD聚合设计里一次事务只能修改一个聚合的数据” 我理解这个只是为了确保一个聚合中，多个实体数据之间的数据一致性\n    单独一个聚合作为一个业务的最小单元，他更新的时候保证原子性，要么成功，要么失败，所以要用事务保证，这个和跨聚合的更新不是同个一东西\n\n\n同个一微服务内，如果跨聚合的数据更新，聚合在不同数据库\n    1.通过领域事件，将事件发布到消息中间件来解耦，通过最终一致性保证数据一致性\n    1.1.事件持久化的时候，如果事件和业务在同库可以直接本地事务保证同时成功\n    1.2.事件持久化的时候，如果事件和业务在不同库，这个又要分布式事务保证一致性了，这个和下面直接通过分布式事务更新多个聚合是不一样的\n\n    2.通过分布式事务，保证多个聚合数据更新的一致性\n\n我理解以下方法都可能用到事务\n\n聚合根的方法本地事务）\n实体的方法（本地事务）\n领域服务的方法（本地事务+分布式事务）\n应用服务的方法（本地事务+分布式事务）\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1606964013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503121,"discussion_content":"这是因为聚合是微服务内最小的业务功能单元。为了保证聚合内数据更新时，符合聚合内固定的业务规则，在一次事务提交时通常会将聚合内所有变更的对象数据作为整体，通过聚合领域服务或聚合根方法一次通过仓储完成数据持久化操作。如果在一次交易中需要同时更新多个聚合数据，那么每一个聚合就是一个独立的数据提交单元，我们需要确保多个聚合数据都能在这个交易中提交更新成功，以保证不同聚合数据的一致性。\n   为什么要做聚合之间的解耦，这是因为微服务的架构演进基本是以聚合为单位来演进的，未来在业务演进时微服务可能会根据聚合功能来重新拆分和组合聚合，所以要提前做好聚合之间的解耦，如果聚合的解耦做的不好，微服务演进时重新拆分和组合的工作量会非常大。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596672965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369756,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIopdUJmtgpsr9GibAibcZgS7h23P4FrgBfed3WveI4b4f8Vl2JjibhCzib9Y8Vs2M1PGQr7cwoKADxZQ/132","nickname":"秦道","note":"","ucode":"BE195C09BD14A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299124,"discussion_content":"最后一段话总结的好，微服务能拆能组，关键就是做没做好聚合的解耦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597569669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153914,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1574329706,"is_pvip":false,"replies":[{"id":"59183","content":"现在的技术路线很多，只要能保证在一个事务在修改多个聚合数据时，能保证数据一致性就可以使用。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574391931,"ip_address":"","comment_id":153914,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31639100778","product_id":100037301,"comment_content":"spring提供的事件机制我感觉也可以啊，可以用在微服务内","like_count":7,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475320,"discussion_content":"现在的技术路线很多，只要能保证在一个事务在修改多个聚合数据时，能保证数据一致性就可以使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574391931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395356,"discussion_content":"说这么多，微服务内用事物逐渐，也能保证数据一致性啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632292396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169246,"user_name":"cup","can_delete":false,"product_type":"c1","uid":1304336,"ip_address":"","ucode":"0DCBBEDFE342F6","user_header":"https://static001.geekbang.org/account/avatar/00/13/e7/10/15742112.jpg","comment_is_top":false,"comment_ctime":1578300708,"is_pvip":false,"replies":[{"id":"65765","content":"1、领域事件方式主要是采用异步方式，实现数据的最终一致性。<br>2、一个聚合一个仓储，是指一个聚合与数据库交互的仓储服务是一个，并不是指一个聚合一个数据库。因为在DDD中为了保证聚合内数据和业务规则的一致性，通过聚合根将所有的实体等数据作为一个整体持久化到数据库中，所以一次事务只能修改一个聚合的数据。而如果一个操作跨了多个聚合的话，就需要考虑事务的概念了，其中有两种实现方式：最终一致性的事件总线机制和Saga等分布式事务的方式。这样也是为了聚合之间的解耦。<br>3、在同一个微服务内采用消息中间件过重了，事件总线属于轻量级的可实现发布订阅基本功能。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578387655,"ip_address":"","comment_id":169246,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27348104484","product_id":100037301,"comment_content":"老师，您好，有几个问题想请教一下<br>1、领域事件和一般的微服务之间的rpc调用区别是什么，因为大部分通信还是同步的rpc或者http调用，那每次rpc调用做一次更新操作就是一次领域事件么<br><br>2、大家都比较疑惑的问题<br>“微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，这种方式通常应用于实时性和数据一致性要求高的场景。这个过程会用到分布式事务，以保证发布方和订阅方的数据同时更新成功。” <br>老师的答案是：微服务内主要是因为跨聚合了。一个聚合一个仓储，在一次修改多个聚合的时候，可能会存在数据不一致的情况，所以用事件总线或者分布式事务。<br><br>您这里说的一个聚合一个仓储是指的不同的聚合使用不同的数据库是么？普通数据库事务无法保证跨库操作的数据一致性，所以使用分布式事务？这样做是为了不同聚合之间解耦，方便以后的微服务拆分？<br>但如果简化一下，可不可以同一微服务中不同聚合的数据放在一个库里，在应用服务开启数据库事务，操作两个聚合的数据，然后结束事务<br><br>3、同一个微服务内为什么不能用消息中间件呢，比如一个聚合生产，扔到rabbitmq，同一微服务里面另一个聚合消费<br>消息保存到进程内部，如果消费能力较低，会不会内存溢出<br>","like_count":7,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480478,"discussion_content":"1、领域事件方式主要是采用异步方式，实现数据的最终一致性。\n2、一个聚合一个仓储，是指一个聚合与数据库交互的仓储服务是一个，并不是指一个聚合一个数据库。因为在DDD中为了保证聚合内数据和业务规则的一致性，通过聚合根将所有的实体等数据作为一个整体持久化到数据库中，所以一次事务只能修改一个聚合的数据。而如果一个操作跨了多个聚合的话，就需要考虑事务的概念了，其中有两种实现方式：最终一致性的事件总线机制和Saga等分布式事务的方式。这样也是为了聚合之间的解耦。\n3、在同一个微服务内采用消息中间件过重了，事件总线属于轻量级的可实现发布订阅基本功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578387655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3178420,"avatar":"https://static001.geekbang.org/account/avatar/00/30/7f/b4/183fbfe9.jpg","nickname":"Geek_aa4694","note":"","ucode":"F773443CBAF46A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":588115,"discussion_content":"老师您好，如果一个领域模型包含两个聚合，应用层用到了对两个聚合的编排组合，对这个应用服用进行事物，不能实现一次事物修改多个聚合吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663558943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":480478,"ip_address":"北京"},"score":588115,"extra":""}]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391468,"discussion_content":"一次事务只能修改一个聚合的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630477987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144546,"user_name":"朱振光","can_delete":false,"product_type":"c1","uid":1622591,"ip_address":"","ucode":"132631BA843436","user_header":"https://static001.geekbang.org/account/avatar/00/18/c2/3f/42fc8939.jpg","comment_is_top":false,"comment_ctime":1571967677,"is_pvip":false,"replies":[{"id":"55737","content":"第一个问题，失败的情况应该比例是很少的。失败的信息可以采用多次重发的方式，如果这个还解决不了，只能将有问题的数据放到一个问题数据区，人工解决。当然要确保一个前提，要保证数据的时序性，不能覆盖已经产生的数据。<br>第二个问题，一般来说发布方不会等待订阅方反馈结果。发布方有发布的事件表，订阅方有消费事件表，你可以采用每日对账的方式来发现问题数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571981686,"ip_address":"","comment_id":144546,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27341771453","product_id":100037301,"comment_content":"内容很充实，但还是有两个问题。<br>1. 在采取最终一致性的情况下，event消费端如果出现错误，消费失败，但是之前的业务都成功了，虽然记录了event dB，但是后续如何处理，是需要人工介入解决吗？如果人工介入再解决，前端用户会不会看到数据不一致，体验不好？<br>2. 因为event都是异步发送，当最后一个event消费成功后，如何有效的通知前端界面，是用Web Socket吗？还是需要前端轮询到后台看是否都成功","like_count":7,"discussions":[{"author":{"id":1808666,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/99/1a/196ff5f8.jpg","nickname":"长空","note":"","ucode":"EFE7E08491849C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177387,"discussion_content":"针对第二个问题，传统上如果UI上看到成功，就一定成功了，但在微服务内不是的，所以第一个事件发出后UI上就会认为是成功的。\n\n微服务内按领域件去流转时，会带上业务数据和事件数据，所以从逻辑上讲是一定成功的，那么重试的机制就能解决相当一部分失败了。\n\n按前面说的，这样的话，UI上去操作下一个的时候因为数据延迟的问题可能操作不了，解决方向有2个：1.提高系统内信息的处理速度(只要逻辑上正确即可认为完成)   2 通过一次设计回避这个问题。\n\n典型的就是转账，现在用支付宝转钱非常快，实际上钱的流转是非常慢的，我们感觉到快是因为大部分操作都 在支付宝的账户上“缓存”着钱。 不涉及实体卡时非常快，但转钱到实体卡时就会慢一点\n\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582102713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472001,"discussion_content":"第一个问题，失败的情况应该比例是很少的。失败的信息可以采用多次重发的方式，如果这个还解决不了，只能将有问题的数据放到一个问题数据区，人工解决。当然要确保一个前提，要保证数据的时序性，不能覆盖已经产生的数据。\n第二个问题，一般来说发布方不会等待订阅方反馈结果。发布方有发布的事件表，订阅方有消费事件表，你可以采用每日对账的方式来发现问题数据。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571981686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069797,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83er77H7TocrQqc0NsfkNjY4QT9llye3XxbZkIcBuX32RWwf4nA46EFvWaUncxcYZmP8wXMicz2TnkIw/132","nickname":"sum","note":"","ucode":"5058D2F417AA82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384744,"discussion_content":"我们这边处理失败数据采取的就是老师所说的方式，通过每日对账及链路分析发现异常数据，然后发起修复方案，审批通过后再根据已选的修复方案按顺序自动修复数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626736195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162225,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1576480089,"is_pvip":false,"replies":[{"id":"61735","content":"在微服务内，不是少用领域事件，是少用事件总线。在DDD中是以聚合为单位进行数据管理的，如果一次操作会修改同一个微服务内的多个聚合的数据，你就需要保证多个聚合的数据一致性，为了解耦不同聚合，你需要采用分布式事务或者用事件总线两种方式，用事件总线不太方便管理服务和数据的关系，你可以用类似saga之类的分布式事务技术。总之需要确保你的不同聚合的业务规则和数据一致性，尽量减少系统建设复杂度。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576485566,"ip_address":"","comment_id":162225,"utype":1}],"discussion_count":7,"race_medal":0,"score":"23051316569","product_id":100037301,"comment_content":"我看到第一条留言，微服务领域时间建议少用，增加了复杂性。我有这么一个场景，用户入住一个房间后，要修改房态。如果不用领域事件，那么就得将入住和改房态写在同一个事务里。这里面入住是主操作，改房态是副操作。副操所除了问题，导致事务回滚，主操作也将无效，用户入住不成功。","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477982,"discussion_content":"在微服务内，不是少用领域事件，是少用事件总线。在DDD中是以聚合为单位进行数据管理的，如果一次操作会修改同一个微服务内的多个聚合的数据，你就需要保证多个聚合的数据一致性，为了解耦不同聚合，你需要采用分布式事务或者用事件总线两种方式，用事件总线不太方便管理服务和数据的关系，你可以用类似saga之类的分布式事务技术。总之需要确保你的不同聚合的业务规则和数据一致性，尽量减少系统建设复杂度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576485566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88722,"discussion_content":"不明白为什么同一个微服务内不同的聚合之间需要使用分布式事务,不是用本地事务就可以 了吗?还是说这里不同的聚合已经是使用不同的数据库了?","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576727292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1061976,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/58/957ca791.jpg","nickname":"Alvin","note":"","ucode":"ECA64F2913024A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383910,"discussion_content":"本地事务可以用在方法的直接引用上，对事件总线的发布订阅模式不起作用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626280240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":88722,"ip_address":""},"score":383910,"extra":""},{"author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1061976,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/58/957ca791.jpg","nickname":"Alvin","note":"","ucode":"ECA64F2913024A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395361,"discussion_content":"他的问题是，一个微服务内，保证多个聚合的数据一致性，用本地事务就可以解决，为什么要引入事件和分布式事务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632292816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383910,"ip_address":""},"score":395361,"extra":""},{"author":{"id":1933878,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/82/36/f821ee14.jpg","nickname":"lipop","note":"","ucode":"22D9A38BD7A298","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":576514,"discussion_content":"解耦吧，后面聚合拆分了怎么办呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655619149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":395361,"ip_address":""},"score":576514,"extra":""}]},{"author":{"id":1112367,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/2f/01b32495.jpg","nickname":"小孩","note":"","ucode":"A7F587FC641E63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298344,"discussion_content":"什么叫事件总线，消息发送到消息中间件算吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597274756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1435845,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/c5/8bdb0bba.jpg","nickname":"DarKnight","note":"","ucode":"B04AFD03768827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112367,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/2f/01b32495.jpg","nickname":"小孩","note":"","ucode":"A7F587FC641E63","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329009,"discussion_content":"事件总线是进程内通过程序编码实现的事件发布与消费功能，并没有借助到消息中间件（第三方进程），类似实现参考 Spring Event 在 Spring 容器内进行事件管理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606296907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298344,"ip_address":""},"score":329009,"extra":""}]}]},{"had_liked":false,"id":160688,"user_name":"itrickzhang","can_delete":false,"product_type":"c1","uid":1516886,"ip_address":"","ucode":"D6A9B141C944DF","user_header":"https://wx.qlogo.cn/mmopen/vi_32/R4ALlUr7UoLJYXhxfNhWGwOSsF8cZYaOPT0zybxOXkCH8iaAo3iaUvQO7EcV0ay9nQv4gaTj7wl1qOD2HMQqExiag/132","comment_is_top":false,"comment_ctime":1576021878,"is_pvip":false,"replies":[{"id":"61310","content":"不是这样的。消息中间件主要用于微服务之间的异步处理，其实很多场景还是实时服务调用的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576024286,"ip_address":"","comment_id":160688,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18755891062","product_id":100037301,"comment_content":"欧老师我想问下，微服务之间用消息中间件通讯，那么注册中心是否是微服务设计的一个鸡肋","like_count":5,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477453,"discussion_content":"不是这样的。消息中间件主要用于微服务之间的异步处理，其实很多场景还是实时服务调用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576024286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88723,"discussion_content":"实时性要求高的场景用同步调用,实时要求低的场景,如果考虑解耦用消息中间件","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576727574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107266,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/42/fbe890c0.jpg","nickname":"vector","note":"","ucode":"F42E76E8966BBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88320,"discussion_content":"看到这个问题其实我也有同感，DDD的目标也包括高内聚，高内聚以及领域事件应该也会减少跨服务间的调用，这个地方还有些想不太清楚的地方。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576688697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146282,"user_name":"Geek_a91670","can_delete":false,"product_type":"c1","uid":1705156,"ip_address":"","ucode":"6CAA9FF890F8EA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/04/c4/ef4bd241.jpg","comment_is_top":false,"comment_ctime":1572489115,"is_pvip":false,"replies":[{"id":"56472","content":"如果一个领域事件会同时修改多个聚合之间的数据的话，可能会存在不同聚合内数据一致性的问题。事件总线的方式可以以同步或者异步的方式来保证聚合之间数据的一致性。多个聚合之上的应用服务也可以来协调这种数据一致性，但由于是跨聚合，需要保证多个聚合同时成功，这可以用事务的方式来实现。但是由于在同一个微服务内的进程内，出错的概率要比微服务之间小得多。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572492447,"ip_address":"","comment_id":146282,"utype":1}],"discussion_count":11,"race_medal":0,"score":"18752358299","product_id":100037301,"comment_content":"&quot;微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，这种方式通常应用于实时性和数据一致性要求高的场景。这个过程会用到分布式事务，以保证发布方和订阅方的数据同时更新成功。&quot;<br>-------服务类的领域事件怎么还牵扯到分布式事务了呢?","like_count":5,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472780,"discussion_content":"如果一个领域事件会同时修改多个聚合之间的数据的话，可能会存在不同聚合内数据一致性的问题。事件总线的方式可以以同步或者异步的方式来保证聚合之间数据的一致性。多个聚合之上的应用服务也可以来协调这种数据一致性，但由于是跨聚合，需要保证多个聚合同时成功，这可以用事务的方式来实现。但是由于在同一个微服务内的进程内，出错的概率要比微服务之间小得多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572492447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1017181,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","nickname":"程序袁帅","note":"","ucode":"C281CA64EC91A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160025,"discussion_content":"看了作者的回复，我挺奇怪的，很困惑，作者明显没有明白提问者在问什么，这是我第二次看到作者答非所问的回答了，难道不是作者本人回复的吗？\n\n我补充一下提问者的疑问，提问者是想问在一个微服务内部还需要用到分布式事务吗？还是说简单的事务方式就可以，希望作者能够答到点上","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580743111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1808666,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/99/1a/196ff5f8.jpg","nickname":"长空","note":"","ucode":"EFE7E08491849C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1017181,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","nickname":"程序袁帅","note":"","ucode":"C281CA64EC91A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177384,"discussion_content":"其实没问题的。理论上一个微服务对应一个本地数据库，所以微服务内的聚合不涉及分布式事务。但实际情况下不太可能，如果多个聚合间涉及到不同的数据库，是否就是分布式事务呢？\n\n单个聚合内一般在一个数据库内，但多个聚合间就不一定了。 \n\n这是我对提问者和作者的理解\n\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582102287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":160025,"ip_address":""},"score":177384,"extra":""},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1017181,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","nickname":"程序袁帅","note":"","ucode":"C281CA64EC91A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239796,"discussion_content":"在DDD聚合设计里一次事务只能修改一个聚合的数据。如果一次事务中会修改多个聚合的数据，如果不采用事件总线方式也是可以的，但是需要引入分布式事务或者简单的事务机制来确保同时保证多个聚合的数据一次提交成功。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587308400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":160025,"ip_address":""},"score":239796,"extra":""},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":331727,"discussion_content":"如果多个聚合本来就是一个数据库中的，这个时候直接用本地事务就可以保证一致性，老师说的简单的事务机制是不是就是一个数据库的本地事务。\n\n如果用本地事务来保证一个微服务内的多个聚合（同一个数据据）的数据更新一致性，这样就会突破“在DDD聚合设计里一次事务只能修改一个聚合的数据”的理论限制。感觉前后矛盾了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606962806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":239796,"ip_address":""},"score":331727,"extra":""}]},{"author":{"id":1127394,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/e2/4893dc25.jpg","nickname":"Hello.World.唐 ","note":"","ucode":"DA192A1B9D4BD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307937,"discussion_content":"用spring @Transactional事务注解举例说明，事件总线以异步的方式发布一个领域事件，该领域事件同时修改多个聚合的数据时，聚合里的使用了@Transactional注解的实例，不能保证都在同一个线程里面。如聚合A修改成功，聚合B修改失败，聚合B的事务回滚，并不能影响到聚合A，那么在当前服务内，不同的聚合就会产生不一致数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600788518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1059771,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","nickname":"嘉嘉☕","note":"","ucode":"632A5CC4B53BB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46836,"discussion_content":"上文中说的是微服务内，所以，只是用到了事务，并不是分布式事务。是这样么？老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573215209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1437715,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f0/13/e5d0355a.jpg","nickname":"杨志远","note":"","ucode":"24F0BF091EDCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1059771,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","nickname":"嘉嘉☕","note":"","ucode":"632A5CC4B53BB1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294429,"discussion_content":"我的理解是，如果跨聚合操作是在同一个库上，使用一般事务，跨多个库时，使用分布式事务","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595892849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46836,"ip_address":""},"score":294429,"extra":""}]}]},{"had_liked":false,"id":243002,"user_name":"风中舞者","can_delete":false,"product_type":"c1","uid":1070630,"ip_address":"","ucode":"BE0D480624CFC1","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/26/5f78314d.jpg","comment_is_top":false,"comment_ctime":1597915406,"is_pvip":false,"replies":[{"id":"89586","content":"事件发布在领域层和应用层都可以，根据代码情况自由选择。事件订阅建议放在应用层。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597929850,"ip_address":"","comment_id":243002,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14482817294","product_id":100037301,"comment_content":"老师，不同微服务之间领域事件的调用，基于消息队列的事件发布，在微服务代码模型上是放到应用层还是领域层比较合适。","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504150,"discussion_content":"事件发布在领域层和应用层都可以，根据代码情况自由选择。事件订阅建议放在应用层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597929850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224504,"user_name":"乖，摸摸头","can_delete":false,"product_type":"c1","uid":1611745,"ip_address":"","ucode":"BD92741A11D3CD","user_header":"https://static001.geekbang.org/account/avatar/00/18/97/e1/0f4d90ff.jpg","comment_is_top":false,"comment_ctime":1591423117,"is_pvip":true,"replies":[{"id":"84669","content":"建议你看一下第7章里面，里面有“三层架构如何演进到 DDD 分层架构”的内容，这里面有三层架构和DDD分层架构的对比分析。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1592987345,"ip_address":"","comment_id":224504,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14476325005","product_id":100037301,"comment_content":"好嘛，我摊牌了，我是写php 的，看了 第13章后又回来把这章看了一遍，基于 laravel框架做得开发，<br>框架里的 view   controller   model 层   对应  用户接口层    应用层   领域层  通用层  是怎么划分的？请教一下老师  ","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497498,"discussion_content":"建议你看一下第7章里面，里面有“三层架构如何演进到 DDD 分层架构”的内容，这里面有三层架构和DDD分层架构的对比分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592987345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202304,"user_name":"wallace","can_delete":false,"product_type":"c1","uid":1261589,"ip_address":"","ucode":"EA46BC0FAF196C","user_header":"","comment_is_top":false,"comment_ctime":1585965139,"is_pvip":false,"replies":[{"id":"75664","content":"在后台会有一些监听的机制，当核保通过后，接收端会监听到核保通过的消息，接收相关数据并修改投保单核保状态后。前端可以采用待办刷新或者用Ajax等前端技术刷新后端的最新数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586004536,"ip_address":"","comment_id":202304,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14470867027","product_id":100037301,"comment_content":"老师好，请问从投保到核保通过是通过领域事件完成的，这种异步操作前端客户如何实时感知处理结果，并进行进一步处理，如缴费？","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490552,"discussion_content":"在后台会有一些监听的机制，当核保通过后，接收端会监听到核保通过的消息，接收相关数据并修改投保单核保状态后。前端可以采用待办刷新或者用Ajax等前端技术刷新后端的最新数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586004536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175033,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1004462,"ip_address":"","ucode":"8F7DE6E7B3D74F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/ae/a08024b2.jpg","comment_is_top":false,"comment_ctime":1580533325,"is_pvip":false,"replies":[{"id":"67993","content":"事件发布应用层和领域层两个都是可以的，看具体情况。事件接收建议放应用层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1580543104,"ip_address":"","comment_id":175033,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14465435213","product_id":100037301,"comment_content":"将事件发布放在应用层是否合适呢，还是应该视具体业务来? 看到老师的「领域事件运行机制相关案例」中，「创建缴费通知单事件」是在应用层，独立发布的。我们开发的业务中，事件发布的调用直接放在领域层逻辑中了。","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482605,"discussion_content":"事件发布应用层和领域层两个都是可以的，看具体情况。事件接收建议放应用层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580543104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543363,"discussion_content":"那怎么调用呢 应用层调用应用层吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641106888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004462,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ae/a08024b2.jpg","nickname":"Luke","note":"","ucode":"8F7DE6E7B3D74F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163795,"discussion_content":"感谢老师的解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581093674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145307,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1572248117,"is_pvip":false,"replies":[{"id":"56050","content":"因为事件发布方有事件实体的原始的持久化数据，事件订阅方也有自己接收的持久化数据。一般可以通过定期对账的方式检查数据的一致性。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572257528,"ip_address":"","comment_id":145307,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14457150005","product_id":100037301,"comment_content":"欧老师你好：事件有没有被消费成功（消费端成功拿到消息或消费端业务处理成功），一般如何通知到消息生产端?谢谢。","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472329,"discussion_content":"因为事件发布方有事件实体的原始的持久化数据，事件订阅方也有自己接收的持久化数据。一般可以通过定期对账的方式检查数据的一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572257528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024486,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","nickname":"旭东(Frank)","note":"","ucode":"176FA629800062","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":150621,"discussion_content":"感觉对账思路还是稳妥些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579796291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133657,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/59/c75cb36d.jpg","nickname":"N","note":"","ucode":"3791619172D64F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78297,"discussion_content":"消费失败一般的主流消息中间件都有重发机制，对消息生产者无感。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575987121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274564,"user_name":"keys头","can_delete":false,"product_type":"c1","uid":1444919,"ip_address":"","ucode":"47C3E0648A8434","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/37/913de94f.jpg","comment_is_top":false,"comment_ctime":1611064638,"is_pvip":false,"replies":[{"id":"101049","content":"这类业务没有太多的业务逻辑，所以基本没有领域模型的概念，整个业务逻辑读多写少，其微服务主要是提供查询服务，所以按照传统方式设计也是可以的，不必先构建领域模型，然后设计微服务。<br>但是这类数据可能会与业务数据进行组合查询的可能，而他们分别在不同的微服务中。这时，你可以将这部分代码类数据以事件驱动的方式复制到业务数据库中。另外如果业务系统需要考虑多中心多活，这部分数据可能需要部署在不同的数据中心，这类数据属于全局数据，这时可以按照一写多读的设计方式，在一个地集中完成写入，而在多个数据中心提供读的数据副本，为多个数据中心提供数据查询服务。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612857575,"ip_address":"","comment_id":274564,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10200999230","product_id":100037301,"comment_content":"欧老师，共享的数据类微服务，也就是数据代码类的数据字典系统应该怎么设计？有什么要点和注意事项吗？某一类字典数据可能只有一张表，是不是有必要把其他类的数据也放到同一个微服务中？比方说品牌库和行业库，各自都只有增删改查的功能。另外，有没有什么好的资料可以提供参考？","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514052,"discussion_content":"这类业务没有太多的业务逻辑，所以基本没有领域模型的概念，整个业务逻辑读多写少，其微服务主要是提供查询服务，所以按照传统方式设计也是可以的，不必先构建领域模型，然后设计微服务。\n但是这类数据可能会与业务数据进行组合查询的可能，而他们分别在不同的微服务中。这时，你可以将这部分代码类数据以事件驱动的方式复制到业务数据库中。另外如果业务系统需要考虑多中心多活，这部分数据可能需要部署在不同的数据中心，这类数据属于全局数据，这时可以按照一写多读的设计方式，在一个地集中完成写入，而在多个数据中心提供读的数据副本，为多个数据中心提供数据查询服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612857575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/a2/721ae4c6.jpg","nickname":"Jervis","note":"","ucode":"86C02C483449CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385513,"discussion_content":"@欧创新 老师，如果不用数据中台，是否有好的方式提供跨微服务的数据查询功能，只能在API中调用各个服务然后组合数据吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627107168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/a2/721ae4c6.jpg","nickname":"Jervis","note":"","ucode":"86C02C483449CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385512,"discussion_content":"一写多读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627106834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268621,"user_name":"有爱有波哥","can_delete":false,"product_type":"c1","uid":1464493,"ip_address":"","ucode":"DD9A023563151F","user_header":"https://static001.geekbang.org/account/avatar/00/16/58/ad/6abb57c4.jpg","comment_is_top":false,"comment_ctime":1608275828,"is_pvip":false,"replies":[{"id":"97485","content":"聚合之间强一致可以在应用层的应用服务中用事务来实现。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608281126,"ip_address":"","comment_id":268621,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10198210420","product_id":100037301,"comment_content":"欧老师 怎么聚合之间怎么实现强一致性","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511990,"discussion_content":"聚合之间强一致可以在应用层的应用服务中用事务来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608281126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243208,"user_name":"JKing","can_delete":false,"product_type":"c1","uid":1436774,"ip_address":"","ucode":"E0394EC5AC9446","user_header":"https://static001.geekbang.org/account/avatar/00/15/ec/66/57d5a1de.jpg","comment_is_top":false,"comment_ctime":1597993336,"is_pvip":false,"replies":[{"id":"89662","content":"是的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1598000494,"ip_address":"","comment_id":243208,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10187927928","product_id":100037301,"comment_content":"老师我还有一个疑问，同一个微服务跨聚合的业务编排我理解可以在应用层application进行编排吧，跨服务的业务依赖是通过领域事件来进行解耦吧？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504222,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598000494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242798,"user_name":"黄复贵","can_delete":false,"product_type":"c1","uid":1297883,"ip_address":"","ucode":"78720C903DBC8E","user_header":"https://static001.geekbang.org/account/avatar/00/13/cd/db/9c7e01ff.jpg","comment_is_top":false,"comment_ctime":1597844827,"is_pvip":false,"replies":[{"id":"89552","content":"聚合中包含聚合根、实体、值对象和领域服务。领域服务主要是处理涉及多个实体对象的业务操作。<br>理论上，聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，只作为实体实现与聚合根自身行为相关的业务逻辑，而将跨多个实体的复杂领域逻辑统一放在领域服务中实现。当然，简单聚合的跨多个实体的领域逻辑，可以考虑在聚合根的方法中实现。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597887261,"ip_address":"","comment_id":242798,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10187779419","product_id":100037301,"comment_content":"为什么图中的示例中，聚合包含了领域服务？聚合不是包含了实例、值对象以及相应业务行为的整体吗？领域服务又是什么？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504098,"discussion_content":"聚合中包含聚合根、实体、值对象和领域服务。领域服务主要是处理涉及多个实体对象的业务操作。\n理论上，聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，只作为实体实现与聚合根自身行为相关的业务逻辑，而将跨多个实体的复杂领域逻辑统一放在领域服务中实现。当然，简单聚合的跨多个实体的领域逻辑，可以考虑在聚合根的方法中实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597887261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181020,"user_name":"🎩","can_delete":false,"product_type":"c1","uid":1451068,"ip_address":"","ucode":"2F1C469595CF51","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/3c/23456f0d.jpg","comment_is_top":false,"comment_ctime":1582460573,"is_pvip":false,"replies":[{"id":"70383","content":"JPA比较适合DDD的设计场景。在持久化工具选型的时候后需要综合考虑，有时候也需要看性能。没试过Mongodb来存储领域对象，我觉得应该问题不大，DDD对数据模型要求不高，它比较重视领域模型。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582621261,"ip_address":"","comment_id":181020,"utype":1}],"discussion_count":5,"race_medal":0,"score":"10172395165","product_id":100037301,"comment_content":"JPA是不是更加适合这种DDD设计的场景，或者使用 mongo数据存储领域对象。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484889,"discussion_content":"JPA比较适合DDD的设计场景。在持久化工具选型的时候后需要综合考虑，有时候也需要看性能。没试过Mongodb来存储领域对象，我觉得应该问题不大，DDD对数据模型要求不高，它比较重视领域模型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582621261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1451068,"avatar":"https://static001.geekbang.org/account/avatar/00/16/24/3c/23456f0d.jpg","nickname":"🎩","note":"","ucode":"2F1C469595CF51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186663,"discussion_content":"老师，我不太理解为什么一个事务只能包含一个聚合根的操作，如果操作多个聚合根为什么要通过事件驱动呢？ 难道是一次操作多个会造成数据库压力大吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582703861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1451068,"avatar":"https://static001.geekbang.org/account/avatar/00/16/24/3c/23456f0d.jpg","nickname":"🎩","note":"","ucode":"2F1C469595CF51","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201141,"discussion_content":"我的理解是，方便后面做服务拆分。前面提到聚合是可以划分成微服务的最小边界。实现上，是可以在应用服务上做事务控制的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583762701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186663,"ip_address":""},"score":201141,"extra":""},{"author":{"id":1451068,"avatar":"https://static001.geekbang.org/account/avatar/00/16/24/3c/23456f0d.jpg","nickname":"🎩","note":"","ucode":"2F1C469595CF51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291766,"discussion_content":"Soga.有道理👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594949092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":201141,"ip_address":""},"score":291766,"extra":""}]},{"author":{"id":1451068,"avatar":"https://static001.geekbang.org/account/avatar/00/16/24/3c/23456f0d.jpg","nickname":"🎩","note":"","ucode":"2F1C469595CF51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186661,"discussion_content":"谢谢老师回复！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582703686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180409,"user_name":"深山小书童","can_delete":false,"product_type":"c1","uid":1079593,"ip_address":"","ucode":"6B5DD3B3D84534","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/29/a90cf777.jpg","comment_is_top":false,"comment_ctime":1582275535,"is_pvip":true,"replies":[{"id":"70387","content":"也是可以的。同一个微服务内出现故障的概率应该要小的多，而且要不就都不能写成功，要不都失败。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582621758,"ip_address":"","comment_id":180409,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10172210127","product_id":100037301,"comment_content":"同一个微服务内涉及到多个聚合数据修改时，在应用服务开本地事务，调用多个领域服务这种做法老师认为如何呢","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484651,"discussion_content":"也是可以的。同一个微服务内出现故障的概率应该要小的多，而且要不就都不能写成功，要不都失败。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582621758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178199,"user_name":"发飙的蜗牛","can_delete":false,"product_type":"c1","uid":1800868,"ip_address":"","ucode":"B2D96A2D0B6BA4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/a4/79ffe77c.jpg","comment_is_top":false,"comment_ctime":1581605803,"is_pvip":false,"replies":[{"id":"69832","content":"领域事件表的目的就是怕异步传输过程中出现数据不一致的问题，可以定期进行数据对账，当出现源端和目的端数据不一致时，追平数据。事件溯源主要还是记录每一个历史版本的方式吧，两者差异还是挺大的。其实领域事件驱动在我们的日常开发中很常见，就是异步的消息队列模式。<br><br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582114630,"ip_address":"","comment_id":178199,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10171540395","product_id":100037301,"comment_content":"看完了，内容很充实，可能是我在DDD方面没有什么经验，理解到的不多，但还是想总结一下。通过场景分析，用户路程分析，我们可以找出大部分的领域事件，然后在事件风暴完成后就可以看到聚合，以及聚合所属的各个限界上下文！之后呢应该就是基于设计微服务了！那么这里应该更多讲的领域事件在微服务架构设计中的作用，也就是老师上面所说的领域事件驱动设计。由领域事件来推动业务数据的流动，然后结合多个领域事件协作完成系统业务功能，但是感觉难点还是在如何保证数据的一致性上面。<br>在案例中可以看到，有业务数据模型和领域事件数据模型，之所以需要设计这个领域事件模型，还要存到数据库，主要是为了实现跨聚合以及跨微服务之间的数据一致性吗？这个跟事件溯源(Event Soucing)有什么关系呢？有没有一个代码例子可以参考一下呢？老师😏😏","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483697,"discussion_content":"领域事件表的目的就是怕异步传输过程中出现数据不一致的问题，可以定期进行数据对账，当出现源端和目的端数据不一致时，追平数据。事件溯源主要还是记录每一个历史版本的方式吧，两者差异还是挺大的。其实领域事件驱动在我们的日常开发中很常见，就是异步的消息队列模式。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582114630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144853,"user_name":"你的美","can_delete":false,"product_type":"c1","uid":1529298,"ip_address":"","ucode":"71B97BDBA3CDC3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","comment_is_top":false,"comment_ctime":1572076151,"is_pvip":false,"replies":[{"id":"55870","content":"聚合之间的领域事件是为了保证同一个微服务内聚合之间的数据一致性，记住：是在同一个微服务内。<br>它会增加开发的复杂度，应尽量少用，通过应用层的应用服务也能实现。<br>微服务之间的领域事件，可以采用异步方式来实现，减轻微服务之间直接调用的压力。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572088015,"ip_address":"","comment_id":144853,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10162010743","product_id":100037301,"comment_content":"用聚合内的领域事件服务（事件总线），是为了减轻微服务之间调用，消息中间件的压力，不用也行；用的话就可以将聚合内的服务调用设置成同步做实时提醒，在限界上下文的微服务之间设置成异步，实现最终的数据一致性。<br>老师这样理解对吗？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472137,"discussion_content":"聚合之间的领域事件是为了保证同一个微服务内聚合之间的数据一致性，记住：是在同一个微服务内。\n它会增加开发的复杂度，应尽量少用，通过应用层的应用服务也能实现。\n微服务之间的领域事件，可以采用异步方式来实现，减轻微服务之间直接调用的压力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572088015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292916,"user_name":"Wei_强","can_delete":false,"product_type":"c1","uid":1152887,"ip_address":"","ucode":"B0E40FB6636F9D","user_header":"https://static001.geekbang.org/account/avatar/00/11/97/77/a01ebefc.jpg","comment_is_top":false,"comment_ctime":1621076672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5916043968","product_id":100037301,"comment_content":"文中领域事件的代码demo有么？<br>createPaymentNotice 和 createPaymentNoticeEvent","like_count":1},{"had_liked":false,"id":180674,"user_name":"hello zero","can_delete":false,"product_type":"c1","uid":1028052,"ip_address":"","ucode":"D1F4B2A7D4635B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/d4/59e2bfd4.jpg","comment_is_top":false,"comment_ctime":1582362117,"is_pvip":true,"replies":[{"id":"70386","content":"事件总线我看到的主要是eventbus，你可以网上搜相关的组件，它本质上还是发布和监听的模式，只不过它是在微服务内。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582621620,"ip_address":"","comment_id":180674,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877329413","product_id":100037301,"comment_content":"欧老师，事件总线的实现技术有没有现成成熟的，可以给推荐一下？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484753,"discussion_content":"事件总线我看到的主要是eventbus，你可以网上搜相关的组件，它本质上还是发布和监听的模式，只不过它是在微服务内。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582621620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163475,"user_name":"达文西","can_delete":false,"product_type":"c1","uid":1398824,"ip_address":"","ucode":"01C1063F23D634","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","comment_is_top":false,"comment_ctime":1576727305,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"5871694601","product_id":100037301,"comment_content":"不明白为什么同一个微服务内不同的聚合之间需要使用分布式事务,不是用本地事务就可以 了吗?还是说这里不同的聚合已经是使用不同的数据库了?","like_count":1,"discussions":[{"author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124370,"discussion_content":"我觉得这里说的是同一个微服务内的不同聚合需要保证最终一致性而不是强一致性 也就是说假设聚合A已经处理完了 这个时候聚合A的事务就提交了 接下来需要聚合B接收聚合A处理完发出的notification之后继续处理 虽然聚合A和聚合B是在一个微服务内 但是是在不同事务里进行处理 那么就可能出现更新完聚合A之后服务出了问题 聚合B没有更新或者更新出错 这个时候就需要聚合A也回滚自己的数据保证数据一致 所以需要用到分布式事务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578415474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":125527,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578489148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":124370,"ip_address":""},"score":125527,"extra":""},{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269574,"discussion_content":"如果放到同一个事务里就是本地事务了 就不需要引入分布式事务了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589925558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":124370,"ip_address":""},"score":269574,"extra":""},{"author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269995,"discussion_content":"聚合之间不应该使用强一致 应该是最终一致","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589972134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269574,"ip_address":""},"score":269995,"extra":""}]}]},{"had_liked":false,"id":159912,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1575824776,"is_pvip":false,"replies":[{"id":"61059","content":"只要能够保证源端和目的端对账的要求，可以不必两端都持久化。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575853846,"ip_address":"","comment_id":159912,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870792072","product_id":100037301,"comment_content":"为什么事件在发送方和订阅方都要持久化呢？这样会不会太繁琐了，能只在发送方持久化吗","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477206,"discussion_content":"只要能够保证源端和目的端对账的要求，可以不必两端都持久化。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575853846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148064,"user_name":"星一","can_delete":false,"product_type":"c1","uid":1103829,"ip_address":"","ucode":"EF550131FAE1BF","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/d5/6fbf1070.jpg","comment_is_top":false,"comment_ctime":1572935605,"is_pvip":false,"replies":[{"id":"57144","content":"微服务内主要是因为跨聚合了。一个聚合一个仓储，在一次修改多个聚合的时候，可能会存在数据不一致的情况，所以用事件总线或者分布式事务。<br>付款是在收到缴费通知单后，在收款微服务完成的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573009953,"ip_address":"","comment_id":148064,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867902901","product_id":100037301,"comment_content":"老师您好，我有两个问题<br>1. 第1部分 “微服务内的领域事件”最后一段说到：“微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，这种方式通常应用于实时性和数据一致性要求高的场景。这个过程会用到分布式事务，以保证发布方和订阅方的数据同时更新成功。” ，有点不明白，微服务内的领域事件怎么会用到分布式事务？保证发布方和订阅方的数据都更新成功只要让消息中间件保证提交成功的消息一定被消费就行了吧？<br>2. 第5部分 “事件接收和处理”的例子里用户付款是在哪个阶段完成的","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473384,"discussion_content":"微服务内主要是因为跨聚合了。一个聚合一个仓储，在一次修改多个聚合的时候，可能会存在数据不一致的情况，所以用事件总线或者分布式事务。\n付款是在收到缴费通知单后，在收款微服务完成的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573009953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147946,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1572921047,"is_pvip":false,"replies":[{"id":"57014","content":"他们在一个微服务的进程内，事务相对好控制。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572930745,"ip_address":"","comment_id":147946,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867888343","product_id":100037301,"comment_content":"如果是微服务内的订阅者（其它聚合），则直接分发到指定订阅者；<br><br>-----对于微服务内的聚合，直接分发到指定订阅者，如果发送过程中挂了怎么办呢，这里面事件没有做持久化，出了问题，无法做到数据一致性吧","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473348,"discussion_content":"他们在一个微服务的进程内，事务相对好控制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572930745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147370,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1572861169,"is_pvip":false,"replies":[{"id":"56905","content":"可以加的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572862202,"ip_address":"","comment_id":147370,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867828465","product_id":100037301,"comment_content":"事件的持久化对象DomainEvent是不是应该加个状态，表示是否成功发布？这样定时任务才知道哪些事件是异常的","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473234,"discussion_content":"可以加的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572862202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146389,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572511803,"is_pvip":false,"replies":[{"id":"56510","content":"跟消息队列类似，也有发布订阅，可以配置为同步或异步。管理微服务内聚合之间的领域事件。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572513930,"ip_address":"","comment_id":146389,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867479099","product_id":100037301,"comment_content":"事件总线 是什么意思？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472838,"discussion_content":"跟消息队列类似，也有发布订阅，可以配置为同步或异步。管理微服务内聚合之间的领域事件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572513930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146387,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572511453,"is_pvip":false,"replies":[{"id":"56511","content":"是的","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572513950,"ip_address":"","comment_id":146387,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867478749","product_id":100037301,"comment_content":"领域事件驱动 改变了我对编码认知观。和之前写的事务脚本方式完全不同的编码模式。感觉事件驱动就是 最终一致性的最好的阐述。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472836,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572513950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145824,"user_name":"乘风","can_delete":false,"product_type":"c1","uid":1310814,"ip_address":"","ucode":"51C1BCC1701BDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/5e/73dd7bf6.jpg","comment_is_top":false,"comment_ctime":1572392963,"is_pvip":false,"replies":[{"id":"56308","content":"在微服务内大部分的逻辑都在一个进程内，后端数据库也是一个数据库，比微服务之间相对好控制一些。而在处理微服务内的领域事件的时候，引入事件总线后会增加开发的复杂度。个人感觉如果不会出现导致数据不一致的情况，就可以不使用事件总线。应用服务也可以实现多聚合的服务和数据协调的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572398977,"ip_address":"","comment_id":145824,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5867360259","product_id":100037301,"comment_content":"我看老师总说微服务内领域事件不建议多用，那又要避免一次事务修改多个聚合，该怎么用?","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472589,"discussion_content":"在微服务内大部分的逻辑都在一个进程内，后端数据库也是一个数据库，比微服务之间相对好控制一些。而在处理微服务内的领域事件的时候，引入事件总线后会增加开发的复杂度。个人感觉如果不会出现导致数据不一致的情况，就可以不使用事件总线。应用服务也可以实现多聚合的服务和数据协调的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572398977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310814,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/5e/73dd7bf6.jpg","nickname":"乘风","note":"","ucode":"51C1BCC1701BDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41436,"discussion_content":"那您的意思是使用服务编排而非事件机制","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572426375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43091,"discussion_content":"个人感觉如果不会出现导致数据不一致的情况，就可以不使用事件总线。\n----这句话， 我想说的是，在同一个微服务进程内，后端又是同一个数据库的情况下，怎么会出现数据不一致呢，都是在同一个事务应该不会出现数据不一致的问题吧？毕竟同一个事务失败会回滚的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572853305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88734,"discussion_content":"在同一个微服务进程内，后端又是同一个数据库的情况下，怎么会出现数据不一致呢，都是在同一个事务应该不会出现数据不一致的问题吧？毕竟同一个事务失败会回滚的。-------------同样的问题纠结了好久,看了好多评论都没找到老师的回复啊.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576728369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43091,"ip_address":""},"score":88734,"extra":""}]}]},{"had_liked":false,"id":144899,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1572084546,"is_pvip":false,"replies":[{"id":"55880","content":"是的。这样的实现逻辑相对简单。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572093471,"ip_address":"","comment_id":144899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867051842","product_id":100037301,"comment_content":"赞同老师触发事件的用法。走canal增量同步数据库数据，通过监听特定表的数据变更来触发生成事件的调用。如此有利于主流业务的解耦，提高维护和可读性。（具体生成事件的操作当然还是放在对应领域的微服务中，canal监听消费端可以理解为一个任务调度平台）","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472160,"discussion_content":"是的。这样的实现逻辑相对简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572093471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144729,"user_name":"李赐麟","can_delete":false,"product_type":"c1","uid":1364181,"ip_address":"","ucode":"455FF0383114DC","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/d5/73da87c3.jpg","comment_is_top":false,"comment_ctime":1572014646,"is_pvip":false,"replies":[{"id":"55876","content":"领域事件跟CQRS有那么一点差异。<br>CQRS主要是想读写分离，将没有领域模型的查询功能，从命令中分离出来。领域事件主要目的还是为了微服务解耦，在连续的业务处理过程中，以异步化的方式完成下一步的业务处理，降低微服务之间的直连。<br>它们的共同点就是通过消息中间件实现从源端数据到目的端数据的交互和分离。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572089539,"ip_address":"","comment_id":144729,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866981942","product_id":100037301,"comment_content":"有点cqrs的味道了。希望能有新的出路","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472087,"discussion_content":"领域事件跟CQRS有那么一点差异。\nCQRS主要是想读写分离，将没有领域模型的查询功能，从命令中分离出来。领域事件主要目的还是为了微服务解耦，在连续的业务处理过程中，以异步化的方式完成下一步的业务处理，降低微服务之间的直连。\n它们的共同点就是通过消息中间件实现从源端数据到目的端数据的交互和分离。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572089539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144716,"user_name":"心浮天空","can_delete":false,"product_type":"c1","uid":1051609,"ip_address":"","ucode":"3B2D0E6CC51EE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/d9/3328dd12.jpg","comment_is_top":false,"comment_ctime":1572007546,"is_pvip":true,"replies":[{"id":"55779","content":"第一个问题，发送失败后是可以通过定时程序重新发送的，如果系统不能自动处理，还可以设计成转人工处理。<br>第二个问题，我们会定义一个领域事件的实体，这是一个事件对象，用于存储事件数据。它在代码目录结构里有一个专门的目录，你可以继承事件基类，定义事件实体。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572012143,"ip_address":"","comment_id":144716,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5866974842","product_id":100037301,"comment_content":"个人理解：<br>同一微服务中的多个聚合之间的协作可以在应用服务层处理, 如果多个聚合根共享同一数据库时, 可以直接利用本地事务达到数据的一致性, 但这样的协作方式不利于之后聚合之间的拆分和独立演化，不过这种协作方式实现成本最低，效率也高, 在前期是个很好的选择。<br>跨服务间领域事件, 需要持久化存储, 防止事件丢失，当领域事件通知下游服务失败时, 可以由定时任务重新发送那些失败的事件。<br><br>有以下几个疑问：<br>1. 在跨服务的领域事件时, 下游服务可能由于各种原因没有接收到领域事件,  如何有效处理这种情况？个人觉得, 可以在本地存储已接收到的事件(在事件处理失败时，可以直接通过本地存储的事件进行重试), 通过定时任务对比本地事件和全局事件(订阅的事件)， 然后拉取本地未接收到的事件再进行处理。<br>2. 领域事件在发送方和接收方都需要有相关定义, 那么这个领域事件对象的定义应该写在哪里？是各自在本地定义？还是定义在共享的lib中, 然后相关服务引入lib即可?","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472081,"discussion_content":"第一个问题，发送失败后是可以通过定时程序重新发送的，如果系统不能自动处理，还可以设计成转人工处理。\n第二个问题，我们会定义一个领域事件的实体，这是一个事件对象，用于存储事件数据。它在代码目录结构里有一个专门的目录，你可以继承事件基类，定义事件实体。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572012143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40590,"discussion_content":"用数据库落库的事件实体中的数据，进行发布和订阅之间数据的比对，就可以发现是否订阅方成功执行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572239331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1051609,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0b/d9/3328dd12.jpg","nickname":"心浮天空","note":"","ucode":"3B2D0E6CC51EE6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40003,"discussion_content":"领域事件采用消息队列解耦, 上游服务发送成功, 但是下游可能由于各种原因没收到, 上游服务无法感知下游服务是否接收到领域事件了，这种情况如何处理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572057933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144709,"user_name":"嘉嘉☕","can_delete":false,"product_type":"c1","uid":1059771,"ip_address":"","ucode":"632A5CC4B53BB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","comment_is_top":false,"comment_ctime":1572003479,"is_pvip":false,"replies":[{"id":"55769","content":"建议做，如果你的数据不重要，不需要对账或者丢了也没关系。那就不需要。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572004497,"ip_address":"","comment_id":144709,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866970775","product_id":100037301,"comment_content":"老师好，<br>请问，事件数据，发布方和订阅方都要做持久化吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472077,"discussion_content":"建议做，如果你的数据不重要，不需要对账或者丢了也没关系。那就不需要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572004497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144534,"user_name":"陈勇","can_delete":false,"product_type":"c1","uid":1079706,"ip_address":"","ucode":"B78F24A4C3754B","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/9a/5198fc0e.jpg","comment_is_top":false,"comment_ctime":1571966786,"is_pvip":true,"replies":[{"id":"55738","content":"大多数情况下领域模型中的DO和数据持久化对象PO是一一对应的，如果不一一对应就需要先做数据重组和转换。比如如果多个DO对象，持久化时对应到一个PO对象，你就需要先将这几个DO对象做数据合并，组成PO对象后，再持久化到数据库中。<br>感觉JAVA除了Mybatis似乎没有其他太好的工具，.net倒是有一些组件可以直接将领域对象数据结构直接映射到数据库结构。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571982296,"ip_address":"","comment_id":144534,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866934082","product_id":100037301,"comment_content":"老师您好，请教一个问题，请问在实践DDD的时候，领域模型和数据模型是共用的吗？如果是共用的，那领域对象和数据对象不匹配问题怎么解决？比如一个实体包含了一个值对象，具体来说像mybatis这种非面向对象的ORM框架实施起来会不会更麻烦？通过associate关联？目前团队都是先设计好db，然后根据工具自动生产crud和do对象。如果要改成领域对象会比较麻烦，增加一层账户转化成本也有点高，请问老师有什么建议？谢谢","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471994,"discussion_content":"大多数情况下领域模型中的DO和数据持久化对象PO是一一对应的，如果不一一对应就需要先做数据重组和转换。比如如果多个DO对象，持久化时对应到一个PO对象，你就需要先将这几个DO对象做数据合并，组成PO对象后，再持久化到数据库中。\n感觉JAVA除了Mybatis似乎没有其他太好的工具，.net倒是有一些组件可以直接将领域对象数据结构直接映射到数据库结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571982296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347383,"user_name":"111110000","can_delete":false,"product_type":"c1","uid":1239012,"ip_address":"","ucode":"737B9F33541B41","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/e4/3b27a371.jpg","comment_is_top":false,"comment_ctime":1653982432,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1653982432","product_id":100037301,"comment_content":"老师，能举个列子针对领域事件表的：1.字断设计（字段信息）、2.存储设计（存储哪些数据）3.后期的对数设计吗","like_count":0},{"had_liked":false,"id":345724,"user_name":"Geek_39654e","can_delete":false,"product_type":"c1","uid":1943367,"ip_address":"","ucode":"985020FC14970C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVaNK1CMOiaJSZpV2DfaIdYssyWent0G5DxLjVewAXYL8EpSTdyXQ7j9pJTiaSJsYyCSaSg1nRpjZw/132","comment_is_top":false,"comment_ctime":1652526164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652526164","product_id":100037301,"comment_content":"feign和消息中间件的的选择上可以帮忙解答下吗？","like_count":0},{"had_liked":false,"id":337725,"user_name":"Jimmy","can_delete":false,"product_type":"c1","uid":2337326,"ip_address":"","ucode":"16ECFBA5826284","user_header":"https://static001.geekbang.org/account/avatar/00/23/aa/2e/b4162c55.jpg","comment_is_top":false,"comment_ctime":1646992429,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646992429","product_id":100037301,"comment_content":"跨微服务之间的非实时调用可以使用领域事件，微服务内不建议使用。","like_count":0},{"had_liked":false,"id":330697,"user_name":"cristal","can_delete":false,"product_type":"c1","uid":1321289,"ip_address":"","ucode":"EDCAE82B064447","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/49/b6af4e31.jpg","comment_is_top":false,"comment_ctime":1642124154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642124154","product_id":100037301,"comment_content":"有代码没？<br>","like_count":0},{"had_liked":false,"id":328044,"user_name":"老荀","can_delete":false,"product_type":"c1","uid":1214893,"ip_address":"","ucode":"C32E743518DECD","user_header":"https://static001.geekbang.org/account/avatar/00/12/89/ad/4efd929a.jpg","comment_is_top":false,"comment_ctime":1640500959,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640500959","product_id":100037301,"comment_content":"如果微服务内用事件总线，发布事件的时候，事件携带的信息通常是一个id还是整个对象（dto）？使用id的话，订阅方都需要去查询一次，使用dto并且异步事件下是否会有一致性的问题","like_count":0},{"had_liked":false,"id":325614,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1639042814,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639042814","product_id":100037301,"comment_content":"这里的领域 和聚合，聚合根；实体，值对象；微服务；这三个维度又是不一样的维度。领域可以跨对象，也可以跨聚合，领域完全是跟着业务走，那就可能会跨微服务，是这个概念吗？","like_count":0},{"had_liked":false,"id":322722,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1637566873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637566873","product_id":100037301,"comment_content":"公司传统售卖业务企业转线上，会有很多场景做领域事件驱动，比如下单、退单、会驱动其他服务（会员-积分、成长值变动）、（营销-券得核销）等；","like_count":0},{"had_liked":false,"id":308223,"user_name":"huhuhu","can_delete":false,"product_type":"c1","uid":1211243,"ip_address":"","ucode":"C57587C430E42B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/6b/c630d446.jpg","comment_is_top":false,"comment_ctime":1629458179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629458179","product_id":100037301,"comment_content":"你好老师，问下相同域下的子域允许相互直接调用吗，还是说需要在上层的application层进行聚合","like_count":0},{"had_liked":false,"id":302176,"user_name":"西瓜Hans","can_delete":false,"product_type":"c1","uid":2690689,"ip_address":"","ucode":"0FD8B59A4188E2","user_header":"https://static001.geekbang.org/account/avatar/00/29/0e/81/ea804784.jpg","comment_is_top":false,"comment_ctime":1626106201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626106201","product_id":100037301,"comment_content":"上面收款服务中的，保存缴费通知事件数据，是否应该放在应用层单独调用事件持久化仓储进行存储，而不应该耦合在收款的领域服务中。这样可以让收款领域服务的业务更干净？","like_count":0},{"had_liked":false,"id":298370,"user_name":"乐锦","can_delete":false,"product_type":"c1","uid":1092400,"ip_address":"","ucode":"DBC2E710076F82","user_header":"","comment_is_top":false,"comment_ctime":1624066229,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1624066229","product_id":100037301,"comment_content":"老师您好，有2个问题请教您一下：<br>1. 以电商为例，订单，库存是两个聚合，如果设计成不同的微服务，用户下单需要扣减库存，涉及并发的情况下，有可能扣减库存不成功，这两者是强一致性，那么用领域事件怎么处理呢？按照传统处理方式，要么放在一个服务里，用本地事务保证一致性，要么使用分布式事务，用DDD的方式怎么处理呢？<br>2. 一个用DDD设计的微服务集群，如何跟外部系统进行对接？可不可以用领域事件来进行处理呢？如果外部系统强依赖内部系统的返回值（错误信息，或者成功信息），是不是只能通过同步rpc+分布式事务的方式来保证呢？<br>希望老师帮忙解答一下，感谢！","like_count":0,"discussions":[{"author":{"id":1050018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/a2/721ae4c6.jpg","nickname":"Jervis","note":"","ucode":"86C02C483449CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385515,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627107374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292099,"user_name":"Fun.","can_delete":false,"product_type":"c1","uid":1019020,"ip_address":"","ucode":"BE7510F01B0D3B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/8c/f5ec128c.jpg","comment_is_top":false,"comment_ctime":1620692554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620692554","product_id":100037301,"comment_content":"老师的分层图和领域事件流转图，分别是用什么软件画的？","like_count":0},{"had_liked":false,"id":291770,"user_name":"郑印","can_delete":false,"product_type":"c1","uid":1005282,"ip_address":"","ucode":"181B0FDE5E1532","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/e2/2dcab30d.jpg","comment_is_top":false,"comment_ctime":1620470453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620470453","product_id":100037301,"comment_content":"老师你好。<br>我有一个疑问，假如收款服务挂了以后，投保微服务如何感知呢？如果不进行感知，对于前端用户是直接告知用户投保成功吗（实际可能只完成一半）？","like_count":0},{"had_liked":false,"id":282812,"user_name":"fcb的鱼","can_delete":false,"product_type":"c1","uid":1243901,"ip_address":"","ucode":"88667EBF09CEC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","comment_is_top":false,"comment_ctime":1615426945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615426945","product_id":100037301,"comment_content":"问下，这块的事件总线和消息中间件两者的功能感觉一样啊？有什么区别吗？","like_count":0},{"had_liked":false,"id":280460,"user_name":"CHEN川","can_delete":false,"product_type":"c1","uid":1001694,"ip_address":"","ucode":"4B4D11141A68B9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/de/d9a88304.jpg","comment_is_top":false,"comment_ctime":1614222891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614222891","product_id":100037301,"comment_content":"看到特别多的同学关心领域事件的最终一致性，我说说自己的看法。<br><br>我特别认同一句话：「软件是虚拟世界的虚拟人代替真实的人完成工作，只是这些虚拟人没有意识和人格，需要由真实的人像操作提线木偶一样操作它们」。当理解这句话后，再来想想领域事件应当如何实现？最终一致性应该怎么实现？举个简单的例子，你给小明还钱，先去银行把钱转到小明银行卡上，然后再打电话通知小明，在这个过程中，如果银行没有把钱打到小明账上，或者忘记通知小明，你会怎么办？你可能会去找银行，也可能会重新给小明打个电话，那如何把这些操作映射到软件上呢？当然可以使用各种本地事务或分布式事务框架，但它们仅仅是工具而已，本身的业务或者说架构绝不能依赖它们，甚至破环整体业务架构设计。","like_count":0},{"had_liked":false,"id":278462,"user_name":"猿一代","can_delete":false,"product_type":"c1","uid":1262626,"ip_address":"","ucode":"B9DF912F5CD363","user_header":"https://static001.geekbang.org/account/avatar/00/13/44/22/90a6fdd6.jpg","comment_is_top":false,"comment_ctime":1612952657,"is_pvip":false,"replies":[{"id":"101195","content":"能否把事件处理过程和谁消费谁的事件等稍微梳理一下？不好意思哈，get不到问题点。一般来说，如果采用事件驱动方式，那么不同聚合或微服务之间就不会存在事务，事件提交后就不必关心事件接收方如何处理了，后面我们可以设计补偿机制或者重传机制。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1613034139,"ip_address":"","comment_id":278462,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1612952657","product_id":100037301,"comment_content":"老师好，问题描述…：先后a，b事件-》mqs，消费事件a更新状态为a，a事务未处理完，同时消费事件b更新为b，b事务提交。然后a事务成功，状态为a，而不是b，这是不对的应该是b，这种咋处理","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515390,"discussion_content":"能否把事件处理过程和谁消费谁的事件等稍微梳理一下？不好意思哈，get不到问题点。一般来说，如果采用事件驱动方式，那么不同聚合或微服务之间就不会存在事务，事件提交后就不必关心事件接收方如何处理了，后面我们可以设计补偿机制或者重传机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613034139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2585107,"avatar":"","nickname":"张伟华","note":"","ucode":"97DC66A80F766F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371002,"discussion_content":"这是消息顺序性的问题吧，MQ严格有序很难做到。降维成串行消费，或者通过状态机，后序状态不能回退为前序状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619605103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267096,"user_name":"香","can_delete":false,"product_type":"c1","uid":1220273,"ip_address":"","ucode":"121D6CECECEEC3","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","comment_is_top":false,"comment_ctime":1607594605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607594605","product_id":100037301,"comment_content":"最后这个案例经典，不仅仅把领域事件的运行机制讲清楚，同时也把前面几讲的知识点做了整合，放在这个案例来理解，形象非常多。","like_count":0},{"had_liked":false,"id":265184,"user_name":"茶壶","can_delete":false,"product_type":"c1","uid":1640246,"ip_address":"","ucode":"E6EB08753DF973","user_header":"https://static001.geekbang.org/account/avatar/00/19/07/36/10ecbb44.jpg","comment_is_top":false,"comment_ctime":1606808972,"is_pvip":false,"replies":[{"id":"96475","content":"这两个领域服务都会有数据库的写入操作，一个领域服务完成业务数据入库，另一个是在事件领域服务中完成事件实体数据的写入，所以是需要在应用层进行事务控制的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1606896212,"ip_address":"","comment_id":265184,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606808972","product_id":100037301,"comment_content":"createPaymentNotice 和createPaymentNoticeEvent 分别是两个领域服务，事物应该是加在这两个领域服务上的。应用层编排调用这两个服务，不需要控制事物么？<br>即便是在一个进程中，一个db里，应用层也要处理事物问题吧，比如notice失败，如何回滚createPaymentNotice内容。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510826,"discussion_content":"这两个领域服务都会有数据库的写入操作，一个领域服务完成业务数据入库，另一个是在事件领域服务中完成事件实体数据的写入，所以是需要在应用层进行事务控制的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606896212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264622,"user_name":"今天明天🚗","can_delete":false,"product_type":"c1","uid":2155648,"ip_address":"","ucode":"D087C216CFF5BA","user_header":"https://static001.geekbang.org/account/avatar/00/20/e4/80/bfc5e2d9.jpg","comment_is_top":false,"comment_ctime":1606550808,"is_pvip":false,"replies":[{"id":"96478","content":"消息中间件都会有这个问题，所以在采用事件驱动模型的时候需要基于特定消息中间件建立完备的容错、幂等性、重传以及防止重复消费的机制。<br>您说的消息堆积如果产生原因是目的端应用的处理能力产生的问题的话，这种情况在同步调用的时候也会遇到。反而，用消息中间件来削峰填谷可以更好的保护目的端应用。<br>如果准实时性要求高，则需要保证消息中间件和目的端应用的能力冗余，以保证不出现消息堆积的情况。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1606897012,"ip_address":"","comment_id":264622,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606550808","product_id":100037301,"comment_content":"事件发布基于消息中间件，消息会出现堆积的情况，如果出现堆积对于要求数据实时性的业务场景如何处理呢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510626,"discussion_content":"消息中间件都会有这个问题，所以在采用事件驱动模型的时候需要基于特定消息中间件建立完备的容错、幂等性、重传以及防止重复消费的机制。\n您说的消息堆积如果产生原因是目的端应用的处理能力产生的问题的话，这种情况在同步调用的时候也会遇到。反而，用消息中间件来削峰填谷可以更好的保护目的端应用。\n如果准实时性要求高，则需要保证消息中间件和目的端应用的能力冗余，以保证不出现消息堆积的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606897012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262456,"user_name":"马里奥的马里奥","can_delete":false,"product_type":"c1","uid":1048423,"ip_address":"","ucode":"6848D9E82B58E3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/67/6ffe3a52.jpg","comment_is_top":false,"comment_ctime":1605745411,"is_pvip":false,"replies":[{"id":"95240","content":"在同一个微服务内用普通的事务控制就可以了，如果组合其它微服务的应用服务需要采用分布式事务。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605753280,"ip_address":"","comment_id":262456,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605745411","product_id":100037301,"comment_content":"微服务内的领域事件一节中提到“微服务内应用服务，可以采用分布式事务来处理事件”，我的疑问是什么是“微服务内应用服务”，另外“既然是在同一个微服务内，也就是同一个进程内，有必要采用分布式事务吗”？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509841,"discussion_content":"在同一个微服务内用普通的事务控制就可以了，如果组合其它微服务的应用服务需要采用分布式事务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605753280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244629,"user_name":"舒欣","can_delete":false,"product_type":"c1","uid":1216112,"ip_address":"","ucode":"D369F3A14A5CFC","user_header":"https://static001.geekbang.org/account/avatar/00/12/8e/70/dc1fd92c.jpg","comment_is_top":false,"comment_ctime":1598600004,"is_pvip":false,"replies":[{"id":"90660","content":"很好啊。谢谢你的建议，后续有机会再补上。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1599465015,"ip_address":"","comment_id":244629,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598600004","product_id":100037301,"comment_content":"反反复复看了很多遍，意犹未尽。DDD实战课缺少有不少干货，总感觉还是少了一些东西，老师能不能再讲讲事件溯源、CQRS、防腐层的设计等等","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504646,"discussion_content":"很好啊。谢谢你的建议，后续有机会再补上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599465015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243204,"user_name":"JKing","can_delete":false,"product_type":"c1","uid":1436774,"ip_address":"","ucode":"E0394EC5AC9446","user_header":"https://static001.geekbang.org/account/avatar/00/15/ec/66/57d5a1de.jpg","comment_is_top":false,"comment_ctime":1597993062,"is_pvip":false,"replies":[{"id":"89663","content":"对于同一个微服务，在应用服务中用事务注解就可以了。跨微服务时要用到分布式事务。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1598000654,"ip_address":"","comment_id":243204,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1597993062","product_id":100037301,"comment_content":"&quot;微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，这种方式通常应用于实时性和数据一致性要求高的场景。这个过程会用到分布式事务，以保证发布方和订阅方的数据同时更新成功&quot;。老师，既然是微服务内应用服务可以通过跨聚合的服务编排和组合，我吉利这种聚合编排是可以放在application这个层次吧？如果在application这个层级，都是在同一个微服务下的，为什么会有分布式事务问题？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504219,"discussion_content":"对于同一个微服务，在应用服务中用事务注解就可以了。跨微服务时要用到分布式事务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598000654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670730,"avatar":"","nickname":"Geek_0a4616","note":"","ucode":"9C37ED61ECCAC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380059,"discussion_content":"每个聚合一个仓储 对应到不同表或者可以，在应用层，没有分布式事务怎么统一呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624323343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1436774,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ec/66/57d5a1de.jpg","nickname":"JKing","note":"","ucode":"E0394EC5AC9446","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1670730,"avatar":"","nickname":"Geek_0a4616","note":"","ucode":"9C37ED61ECCAC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394058,"discussion_content":"你这种跟分布式事务没有关系，同一个jvm没有分布式事务概念，除非依赖多个jvm ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631703250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380059,"ip_address":""},"score":394058,"extra":""}]}]},{"had_liked":false,"id":241732,"user_name":"唐江","can_delete":false,"product_type":"c1","uid":1878120,"ip_address":"","ucode":"867C9808CF7760","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJpJXWFP3dNle88WnTkRTsEQkPJmOhepibiaTfhEtMRrbdg5EAWm4EzurA61oKxvCK2ZjMmy1QvmChw/132","comment_is_top":false,"comment_ctime":1597404160,"is_pvip":false,"replies":[{"id":"89378","content":"领域事件驱动和注册中心是有差异的。有了领域事件驱动，可以解耦微服务，通过数据最终一致性减少微服务之间的同步调用，避免出现雪崩。但是微服务之间的同步调用依然是必不可少的，比如查询操作以及时效性要求高的服务同步调用等，还有包括前后端之间的服务调用。所以服务注册中心还是必不可少的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597632469,"ip_address":"","comment_id":241732,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597404160","product_id":100037301,"comment_content":"请问一下，微服务架构中用了领域事件驱动的方式，那是不是就不需要注册中心了？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503829,"discussion_content":"领域事件驱动和注册中心是有差异的。有了领域事件驱动，可以解耦微服务，通过数据最终一致性减少微服务之间的同步调用，避免出现雪崩。但是微服务之间的同步调用依然是必不可少的，比如查询操作以及时效性要求高的服务同步调用等，还有包括前后端之间的服务调用。所以服务注册中心还是必不可少的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597632469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235340,"user_name":"Geek_2655db","can_delete":false,"product_type":"c1","uid":1809331,"ip_address":"","ucode":"3BC81783F791BD","user_header":"","comment_is_top":false,"comment_ctime":1594978141,"is_pvip":false,"replies":[{"id":"87211","content":"在进行消息中间件设计时需要特别进行以下设计：<br>1、发布者微服务需要有消息补偿和重试机制，在目的端出现故障和消息不可达时，可以完成数据重传。<br>2、订阅者微服务需要进行幂等性设计，防止重复消费。<br>不同的消息中间件的设计方式可能会不一样。<br>幂等性可以有两种方式保证：<br>第一、发布者微服务不重复发送，为每条消息生成一个全局唯一的事件id，消息中间件收到消息时，先根据该id判断消息是否重复发送，再决定是否接收该消息。<br>第二、订阅者不重复消费，订阅者拿到了消息之后，要判断是否已经消费过，如果已经消费，直接丢弃。可以采用以下两种方式：<br>1、如果从消息队列拿到数据要先存到数据库，那么可以根据事件ID创建唯一约束，当插入数据库时，会报违反唯一约束错误，不会插入成功。或者可以先从数据库查询，如果能查到，就可以直接丢弃。<br>2、每次消费前将事件ID保存到redis里面。消费时先去redis里面查一下有没有，没有再消费，有的话直接抛弃。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1595317812,"ip_address":"","comment_id":235340,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1594978141","product_id":100037301,"comment_content":"为了实现最终一致性，应该如何保障消息的可靠性和一致性？<br>可靠性即消息不会因为异常情况丢失。<br>一致性即消息不会因为异常情况消费失败或重复消费。<br>还望欧老师帮助解惑。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501692,"discussion_content":"在进行消息中间件设计时需要特别进行以下设计：\n1、发布者微服务需要有消息补偿和重试机制，在目的端出现故障和消息不可达时，可以完成数据重传。\n2、订阅者微服务需要进行幂等性设计，防止重复消费。\n不同的消息中间件的设计方式可能会不一样。\n幂等性可以有两种方式保证：\n第一、发布者微服务不重复发送，为每条消息生成一个全局唯一的事件id，消息中间件收到消息时，先根据该id判断消息是否重复发送，再决定是否接收该消息。\n第二、订阅者不重复消费，订阅者拿到了消息之后，要判断是否已经消费过，如果已经消费，直接丢弃。可以采用以下两种方式：\n1、如果从消息队列拿到数据要先存到数据库，那么可以根据事件ID创建唯一约束，当插入数据库时，会报违反唯一约束错误，不会插入成功。或者可以先从数据库查询，如果能查到，就可以直接丢弃。\n2、每次消费前将事件ID保存到redis里面。消费时先去redis里面查一下有没有，没有再消费，有的话直接抛弃。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595317812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369756,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIopdUJmtgpsr9GibAibcZgS7h23P4FrgBfed3WveI4b4f8Vl2JjibhCzib9Y8Vs2M1PGQr7cwoKADxZQ/132","nickname":"秦道","note":"","ucode":"BE195C09BD14A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299125,"discussion_content":"感觉话题变成了：分布式事务的解决方案有哪些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597569842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224110,"user_name":"乖，摸摸头","can_delete":false,"product_type":"c1","uid":1611745,"ip_address":"","ucode":"BD92741A11D3CD","user_header":"https://static001.geekbang.org/account/avatar/00/18/97/e1/0f4d90ff.jpg","comment_is_top":false,"comment_ctime":1591277288,"is_pvip":true,"replies":[{"id":"82541","content":"第7章有介绍。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591318305,"ip_address":"","comment_id":224110,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591277288","product_id":100037301,"comment_content":"应用服务 和 领域服务是怎么进行划分的？什么叫应用服务，怎么又算是领域服务？<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497368,"discussion_content":"第7章有介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591318305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220412,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590237884,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590237884","product_id":100037301,"comment_content":"电商的交易事件，后面是物流等处理","like_count":0},{"had_liked":false,"id":219347,"user_name":"Geek_7b5e8d","can_delete":false,"product_type":"c1","uid":1190308,"ip_address":"","ucode":"AC4B2BA6E1A49E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJv5HunMDDhpYdtRc46RqSIWah6VnlnsDXGYQE5iboFLKg301E9RcyEa3VqjkpU8LVFoRFibdibuuXgg/132","comment_is_top":false,"comment_ctime":1589995392,"is_pvip":true,"replies":[{"id":"81087","content":"只要不带来太大的成本，这样设计是没有问题的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590050509,"ip_address":"","comment_id":219347,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589995392","product_id":100037301,"comment_content":"我们对微服务内的领域事件也做了持久化，参考了微服务中application event架构的做法，因为这样才能保证事件不会因各种原因而丢弃，并且具备失败重试的可能。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495776,"discussion_content":"只要不带来太大的成本，这样设计是没有问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590050509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218397,"user_name":"张超","can_delete":false,"product_type":"c1","uid":1131018,"ip_address":"","ucode":"5B9939D9477EFB","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/0a/031abaef.jpg","comment_is_top":false,"comment_ctime":1589796494,"is_pvip":false,"replies":[{"id":"81090","content":"如果是重要的数据建议先入库。一般来说在同一个微服务内停机导致出现数据不一致的情况要比微服务之间的概率要小得多。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590051188,"ip_address":"","comment_id":218397,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589796494","product_id":100037301,"comment_content":"欧老师好，事件总线“如果是微服务内的订阅者（其它聚合），则直接分发到指定订阅者”。这部分需要先将事件入库吗，如果是放在内存的话,临时停机会不会有数据不一致的问题。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495448,"discussion_content":"如果是重要的数据建议先入库。一般来说在同一个微服务内停机导致出现数据不一致的情况要比微服务之间的概率要小得多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590051188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218093,"user_name":"z","can_delete":false,"product_type":"c1","uid":1107666,"ip_address":"","ucode":"CDB0BE8562ECB6","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/d2/638ca831.jpg","comment_is_top":false,"comment_ctime":1589713013,"is_pvip":false,"replies":[{"id":"80660","content":"如果不用总线的话，其实也可以在跨多个聚合的应用服务中用内部事务来实现。毕竟如果未来聚合要拆分到不同的微服务，这两种方式都有一定的代码改造量。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589723905,"ip_address":"","comment_id":218093,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589713013","product_id":100037301,"comment_content":"微服务内操作多个聚合：使用总线开发复杂，异步的话服务挂掉怎么保证后续操作执行呢？不使用总线，后续难以演化并且微服务内逻辑也复杂。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495350,"discussion_content":"如果不用总线的话，其实也可以在跨多个聚合的应用服务中用内部事务来实现。毕竟如果未来聚合要拆分到不同的微服务，这两种方式都有一定的代码改造量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589723905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218088,"user_name":"z","can_delete":false,"product_type":"c1","uid":1107666,"ip_address":"","ucode":"CDB0BE8562ECB6","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/d2/638ca831.jpg","comment_is_top":false,"comment_ctime":1589712157,"is_pvip":false,"replies":[{"id":"80661","content":"同一个微服务内出现机器挂的情况，用事务或者总线的处理方式感觉差异不太懂哈。其实也可以用事务的方式来实现的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589724036,"ip_address":"","comment_id":218088,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589712157","product_id":100037301,"comment_content":"一个微服务内，多个聚合采用最终一致性，机器挂了，数据在么关系，后面的事务执行失败了怎么办？不应该是在一个事务里吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495348,"discussion_content":"同一个微服务内出现机器挂的情况，用事务或者总线的处理方式感觉差异不太懂哈。其实也可以用事务的方式来实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589724036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214417,"user_name":"dorisnzy","can_delete":false,"product_type":"c1","uid":1672692,"ip_address":"","ucode":"8306C869EBFB3F","user_header":"https://static001.geekbang.org/account/avatar/00/19/85/f4/894bd980.jpg","comment_is_top":false,"comment_ctime":1588744253,"is_pvip":true,"replies":[{"id":"79532","content":"1、采用领域事件后，实际上就没有了微服务之间的服务链路了。<br>2、是的。领域事件主要适用于数据最终一致性。其实大部分的环境都可以做到准实时性。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588835514,"ip_address":"","comment_id":214417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588744253","product_id":100037301,"comment_content":"老师，我有以下几个问题需要咨询一下：<br>1、服务之间采用领域事件通信时服务链路最终如何做？<br>2、领域事件驱动是不是只用于业务数据的弱实时性（异步）？而数据要求强实时性是不是一般采用服务调用服务的形式（同步）？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494047,"discussion_content":"1、采用领域事件后，实际上就没有了微服务之间的服务链路了。\n2、是的。领域事件主要适用于数据最终一致性。其实大部分的环境都可以做到准实时性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588835514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212926,"user_name":"hugeo","can_delete":false,"product_type":"c1","uid":1042824,"ip_address":"","ucode":"438F289EDD21CD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/88/941e488a.jpg","comment_is_top":false,"comment_ctime":1588238767,"is_pvip":false,"replies":[{"id":"79537","content":"首先你要确定好领域模型，然后根据领域事件确定事件发布方领域模型，再根据业务下一步操作，确定事件订阅方领域模型。然后再引入消息中间件，根据领域事件实现机制，完成事件发布、持久化、订阅以及业务处理等机制。具体实现，你可以看一下加餐里面的代码。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588836348,"ip_address":"","comment_id":212926,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588238767","product_id":100037301,"comment_content":"老师，我做风控业务的事件现在分布得很零散，有什么建议吗？<br>例如 <br>1. 用户支付成功事件<br>来源：上游系统<br>渠道：kafka<br>操作：新建风控单<br>2. 风控单超时未审核事件<br>来源：服务扫描风控单表<br>渠道：线程内，扫描线程直接调用Listener类处理，失败了不管等下次扫描<br>操作：改风控单状态为拦截<br>3. 风控状态通知到上游事件<br>来源：风控状态变更<br>渠道：落Mysql。与状态变更在同一事物，通过扫表重试确保通知到位<br>操作：调用上游callback接口完成通知<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493648,"discussion_content":"首先你要确定好领域模型，然后根据领域事件确定事件发布方领域模型，再根据业务下一步操作，确定事件订阅方领域模型。然后再引入消息中间件，根据领域事件实现机制，完成事件发布、持久化、订阅以及业务处理等机制。具体实现，你可以看一下加餐里面的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588836348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212155,"user_name":"奋斗心","can_delete":false,"product_type":"c1","uid":1247286,"ip_address":"","ucode":"06A195AB0B6570","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/36/98be3d69.jpg","comment_is_top":false,"comment_ctime":1588068126,"is_pvip":false,"replies":[{"id":"78867","content":"不需要的。如果有顺序的话，可能就不能用异步的方式了。因为一次交易多个订阅，你无法保证谁先做完。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588074101,"ip_address":"","comment_id":212155,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588068126","product_id":100037301,"comment_content":"微服务之间的领域事件，如果业务上没有要求，多个消费方 一定要按顺序消费吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493443,"discussion_content":"不需要的。如果有顺序的话，可能就不能用异步的方式了。因为一次交易多个订阅，你无法保证谁先做完。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588074101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206119,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1586789513,"is_pvip":false,"replies":[{"id":"77329","content":"用DTO也是可以的，其实他们的区别主要是消息发布方的区别。后面的处理逻辑是一样的。用日志的方式通过数据库的方式，主要利用的数据库的底层特性，不需要在应用层进行事件发布逻辑处理了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587003794,"ip_address":"","comment_id":206119,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586789513","product_id":100037301,"comment_content":"为什么要使用数据库binlog的方式增量订阅呢？如果发布事件的微服务把数据组装好成dto，直接发送到消息中间件可以吗？这样也能支持多者消费的情况","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491678,"discussion_content":"用DTO也是可以的，其实他们的区别主要是消息发布方的区别。后面的处理逻辑是一样的。用日志的方式通过数据库的方式，主要利用的数据库的底层特性，不需要在应用层进行事件发布逻辑处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587003794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201425,"user_name":"董","can_delete":false,"product_type":"c1","uid":1228312,"ip_address":"","ucode":"40800C9FB7FA69","user_header":"","comment_is_top":false,"comment_ctime":1585787382,"is_pvip":false,"replies":[{"id":"75406","content":"你说的这种情况很少见吧？感觉你说的这种情况不太适合领域事件机制。<br>在领域事件驱动中，发布方只管数据发布，它不关心订阅方逻辑处理是不是成功。即使不成功也没关系，会通过事后补偿机制来修正。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585832503,"ip_address":"","comment_id":201425,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1585787382","product_id":100037301,"comment_content":"老师好，现在对DDD的理解还不够，想请教一个问题，比如某个业务场景，在页面前端展示数据a，b，c，d，这些数据是多个微服务提供的，而且每个属性的调用链路较长，实时性要求不高。<br>问题：如果使用事件驱动，页面的展示信息怎么返回给发布方的，是需要订阅方处理完，在发出完成事件给发布方订阅并把相关属性放到消息体，供发布方持久化，统一提供前端展示？<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490328,"discussion_content":"你说的这种情况很少见吧？感觉你说的这种情况不太适合领域事件机制。\n在领域事件驱动中，发布方只管数据发布，它不关心订阅方逻辑处理是不是成功。即使不成功也没关系，会通过事后补偿机制来修正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585832503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1899314,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/LalJD9ruYQI5zVM1GOCe4PjunIbbeeMiacFHC4TAj0DBVeialKt3vRCLs9dxn1vYXvfp8pgcyaeEQkh1nde1JoBQ/132","nickname":"jun","note":"","ucode":"3A9633CA1FE72E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271401,"discussion_content":"这种业务场景应该属于业务聚合，前端通过业务聚合出来的接口来同步返回信息；调用链都在业务聚合接口中去实现；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590129276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199994,"user_name":"james.d","can_delete":false,"product_type":"c1","uid":1087225,"ip_address":"","ucode":"CEE241856AF3B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/f9/3f976c91.jpg","comment_is_top":false,"comment_ctime":1585530472,"is_pvip":false,"replies":[{"id":"74917","content":"一般的建议是采用事件总线这种异步机制。我个人感觉在同一个微服务采用分布式事务机制应该也是可以接受的。毕竟在同一个微服务进程和同一个数据库内，出现问题的可能性还是比较小，性能应该也差不多能接受的。有的事务还是可以避免的，在设计的时候应该在应用层尽量避免同时修改两个聚合的数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585549049,"ip_address":"","comment_id":199994,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585530472","product_id":100037301,"comment_content":"请教欧老师，一个微服务内部有聚合A， 聚合B。某业务场景两个聚合都需要写库且只能是同步的。那么如何实现事务比较好呢？如果一个事务只能操作一个聚合，需要采用最终一致性的保证，好处是隔离得比较彻底，可扩展性好，坏处是会带来复杂性。如果包裹在一个事务中，可通过数据库的强一致性保证，好处是实现很简单，不会出现数据一致性问题，坏处是两个聚合在事务上耦合了，并且可能会带来性能的问题，比如有大事务的风险。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489912,"discussion_content":"一般的建议是采用事件总线这种异步机制。我个人感觉在同一个微服务采用分布式事务机制应该也是可以接受的。毕竟在同一个微服务进程和同一个数据库内，出现问题的可能性还是比较小，性能应该也差不多能接受的。有的事务还是可以避免的，在设计的时候应该在应用层尽量避免同时修改两个聚合的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585549049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196502,"user_name":"deem","can_delete":false,"product_type":"c1","uid":1936901,"ip_address":"","ucode":"3DBAAB685E0014","user_header":"","comment_is_top":false,"comment_ctime":1585286661,"is_pvip":false,"replies":[{"id":"74431","content":"是的。DDD在设计业务模型的时候就有这种概念，微服务设计时，只需要映射落地就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585291260,"ip_address":"","comment_id":196502,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585286661","product_id":100037301,"comment_content":"其实我的理解 如果按照微服务的设计来讲，通过这种异步的方式来让微服务进行解耦","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489316,"discussion_content":"是的。DDD在设计业务模型的时候就有这种概念，微服务设计时，只需要映射落地就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585291260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193331,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1584889904,"is_pvip":true,"replies":[{"id":"73722","content":"后面改就不太容易了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584929456,"ip_address":"","comment_id":193331,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1584889904","product_id":100037301,"comment_content":"我们开发了一周，项目紧急，又成了贫血模型了","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488539,"discussion_content":"后面改就不太容易了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584929456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132630,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/56/99369df2.jpg","nickname":"猛男还是萌男","note":"","ucode":"BD334667FCCBFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373670,"discussion_content":"一般都很正常\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620821039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190153,"user_name":"Geek_d38f30","can_delete":false,"product_type":"c1","uid":1512147,"ip_address":"","ucode":"955D6480731336","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ib1aca6ibMC3bcTZeVdTFalyyhdvy4DLQ7s4WBTWaw95k8IJNTUkZ5VwfB9rYwxVz3PAz4chBJhWcyMHib9KdEEnQ/132","comment_is_top":false,"comment_ctime":1584607558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584607558","product_id":100037301,"comment_content":"那些业务可以定义为领域事件？事件发生后，会触发的业务。如购买商品后添加积分。<br>领域事件的实现如何实现<br>1.事件的构建与发布<br>事件是有特定的属性，事件类型，调用事件，数据源调用参数<br>2.事件的持久化<br>把事件属性存在数据库，方便查询调用<br>3.事件总线<br>把所有事件的调用，做一个总接入口。接收事件，分发到对应的事务处理<br>4.消息中间件<br>Kafka，RabbitMQ。<br>领域事件发布-&gt;领域事件持久化-&gt;消息中间件-&gt;事件总线-&gt;领域事件处理<br>如果这个领域事件，调用频繁，可以多实例多处理<br>通过领域事件可以降低业务复杂度，我调用领域事件时，领域事件发布和持久化成功就行。<br>如果是微服务内的领域事件同一个进程内，直接调用，不通过消息中间件","like_count":0},{"had_liked":false,"id":184953,"user_name":"淡蓝色","can_delete":false,"product_type":"c1","uid":1199960,"ip_address":"","ucode":"798A01BC9D9CBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/58/e85a80e6.jpg","comment_is_top":false,"comment_ctime":1583457809,"is_pvip":true,"replies":[{"id":"71468","content":"两种总线是不一样的。事件总线相对简单，可以配置为实时或者异步，主要用于微服务内聚合之间，常见的时eventbus。消息总线主要是异步方式，主要用于微服务之间的数据异步，常见的有MQ、Kafka。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583459130,"ip_address":"","comment_id":184953,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1583457809","product_id":100037301,"comment_content":"我觉得可以设计两种截然不同的总线。<br>事件总线：用于服务内部聚合直接进行通信。<br>消息总线：用于服务之间进行通信。<br>两种总线可以采取不同的发布订阅方式和事务方式，例如事件总线利用本地缓存来保存事件，消息总线利用数据库来保存事件，当然这样会增加系统复杂度。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486185,"discussion_content":"两种总线是不一样的。事件总线相对简单，可以配置为实时或者异步，主要用于微服务内聚合之间，常见的时eventbus。消息总线主要是异步方式，主要用于微服务之间的数据异步，常见的有MQ、Kafka。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583459130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199960,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4f/58/e85a80e6.jpg","nickname":"淡蓝色","note":"","ucode":"798A01BC9D9CBC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210583,"discussion_content":"是的，两种总线模式分别使用不同的分发技术和事务实现方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584754371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184139,"user_name":"克制的民工","can_delete":false,"product_type":"c1","uid":1886437,"ip_address":"","ucode":"48E0231F469DA5","user_header":"https://static001.geekbang.org/account/avatar/00/1c/c8/e5/c0e8c78d.jpg","comment_is_top":false,"comment_ctime":1583235380,"is_pvip":false,"replies":[{"id":"71280","content":"建议还是采用异步的方式，主要还是为了微服务的解耦，避免微服务之间直接调用，在出现问题后带来的雪崩效应。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583247323,"ip_address":"","comment_id":184139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583235380","product_id":100037301,"comment_content":"请教，如果A微服务发一个领域事件给B，那么能否可以B设计一个POST的Restful接口，将领域事件用Restful接口搞定呢（当然有很多问题，但是简单场景是否也是可行的？）","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485906,"discussion_content":"建议还是采用异步的方式，主要还是为了微服务的解耦，避免微服务之间直接调用，在出现问题后带来的雪崩效应。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583247323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175300,"user_name":"Jie","can_delete":false,"product_type":"c1","uid":1045078,"ip_address":"","ucode":"AB94041E548FEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","comment_is_top":false,"comment_ctime":1580648282,"is_pvip":false,"replies":[{"id":"68155","content":"是的，跟消息队列的使用基本类似。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1580700610,"ip_address":"","comment_id":175300,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580648282","product_id":100037301,"comment_content":"感觉通过领域事件解耦后，需要更多考虑发布方的重试机制，和订阅方的调用幂等。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482685,"discussion_content":"是的，跟消息队列的使用基本类似。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580700610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173527,"user_name":"小谢同学","can_delete":false,"product_type":"c1","uid":1032544,"ip_address":"","ucode":"E809E6BC470631","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/60/fc3689d0.jpg","comment_is_top":false,"comment_ctime":1579589595,"is_pvip":false,"replies":[{"id":"67269","content":"消息中间件就是最终一致性，肯定会有延迟，但是现在消息中间件的处理能力非常强，延迟应该不会太大。实时的你可以分布式事务方式。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579593558,"ip_address":"","comment_id":173527,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579589595","product_id":100037301,"comment_content":"请问老师，过多的服务间消息传递是否会带来延迟等性能问题？也就是对消息中间件的依赖太大了，另外对性能要求高的业务还是应优先使用rpc的方式直接访问吧？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482101,"discussion_content":"消息中间件就是最终一致性，肯定会有延迟，但是现在消息中间件的处理能力非常强，延迟应该不会太大。实时的你可以分布式事务方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579593558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173053,"user_name":"alex","can_delete":false,"product_type":"c1","uid":1707959,"ip_address":"","ucode":"990D1092DE3E86","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0f/b7/9f3edf9f.jpg","comment_is_top":false,"comment_ctime":1579418065,"is_pvip":false,"replies":[{"id":"67193","content":"分布式事务有saga之类的组件。<br>异步方式在出现异常时需要根据自己的场景采用不同的策略，如多次重传或者转人工处理等。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579503260,"ip_address":"","comment_id":173053,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1579418065","product_id":100037301,"comment_content":"欧老师，您好，这个领域事年章节，我反复看了多次，基本上能领会你这里用事件驱动+消息中间件形式解耦多个微服务之间的调用，但为了实现两个微服务之间调用时的事务一致性的问题 ，要考虑到A调用B，但B服务在执行时出现异常而终止，这时应该有机制使B服务的方法重试执行，确保事务或数据的最终一致，请问处理这种过程的，有没有现成的中间件框架可以直接使用，能实现事件信息落库，发布异步消息通知，服务执行时，能监控到并使之重试实现数据的最终一致。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481942,"discussion_content":"分布式事务有saga之类的组件。\n异步方式在出现异常时需要根据自己的场景采用不同的策略，如多次重传或者转人工处理等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579503260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326455,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3d/77/45e5e06d.jpg","nickname":"胡鹏","note":"","ucode":"52644EC57FA4DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141575,"discussion_content":"你说的这属于最终一致性里面的范畴:   A和B有两种交互方式  1. 同步方式, 就是A调用B,   失败了需要A重试,不可能是B重试, 因为B没有数据      2. 异步方式, A把数据放入对了,B来消费,  如果B消费失败就在消费一次咯, A只保证数据就如队列就完了    \n如果是要强一致性, 就是要加入分布式事务, 要借助中间件,比较影响性能, 失败了大家都会滚,  不过这样性能消耗较大,开发较复杂, 除非特殊场景, 我所了解的基本上都是用最终一致性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579431996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172066,"user_name":"C J J","can_delete":false,"product_type":"c1","uid":1002287,"ip_address":"","ucode":"603AA1417BD0DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/2f/186918b4.jpg","comment_is_top":false,"comment_ctime":1579081263,"is_pvip":false,"replies":[{"id":"66942","content":"在这一节的设计中，我只是将领域事件的数据放到了数据库的事件表中，然后通过CDC之类工具将领域事件的增量逻辑日志提取并发布到消息队列中。采用基于数据库日志的原因主要是剥离业务逻辑与领域事件数据传输逻辑。<br>领域事件和Binlog不是一个维度的东西。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579242729,"ip_address":"","comment_id":172066,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1579081263","product_id":100037301,"comment_content":"老师，领域事件是否可理解成MySQL的binlog?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481608,"discussion_content":"在这一节的设计中，我只是将领域事件的数据放到了数据库的事件表中，然后通过CDC之类工具将领域事件的增量逻辑日志提取并发布到消息队列中。采用基于数据库日志的原因主要是剥离业务逻辑与领域事件数据传输逻辑。\n领域事件和Binlog不是一个维度的东西。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579242729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182167,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","nickname":"Shen","note":"","ucode":"CFF7609A754392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159065,"discussion_content":"感觉有点类似~~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580651433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166636,"user_name":"shitao","can_delete":false,"product_type":"c1","uid":1067270,"ip_address":"","ucode":"9F4D71D4F34B61","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/06/b90049f4.jpg","comment_is_top":false,"comment_ctime":1577526255,"is_pvip":false,"replies":[{"id":"64813","content":"是的","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577662726,"ip_address":"","comment_id":166636,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577526255","product_id":100037301,"comment_content":"绩效文档打分完成就是领域事件，会触发后续的审批流程，通知流程等","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479564,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577662726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163849,"user_name":"james.d","can_delete":false,"product_type":"c1","uid":1087225,"ip_address":"","ucode":"CEE241856AF3B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/f9/3f976c91.jpg","comment_is_top":false,"comment_ctime":1576810978,"is_pvip":false,"replies":[{"id":"62300","content":"领域服务之间调用容易导致聚合之间耦合度过高，不利于微服务的架构演进，因此建议通过应用服务来编排。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576814701,"ip_address":"","comment_id":163849,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576810978","product_id":100037301,"comment_content":"微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，这种方式通常应用于实时性和数据一致性要求高的场景。这个过程会用到分布式事务，以保证发布方和订阅方的数据同时更新成功。<br>这个观点貌似大家的疑惑都比较多, 可以在领域服务内实现跨聚合的调用，然后由领域服务来保证事务，这样可以避免引入分布式事务。当然这也只是一种折中，因为DDD中最好是基于聚合的维度来保证强一致，跨聚合的应该保证最终一致性。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478552,"discussion_content":"领域服务之间调用容易导致聚合之间耦合度过高，不利于微服务的架构演进，因此建议通过应用服务来编排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576814701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163467,"user_name":"达文西","can_delete":false,"product_type":"c1","uid":1398824,"ip_address":"","ucode":"01C1063F23D634","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","comment_is_top":false,"comment_ctime":1576726671,"is_pvip":false,"replies":[{"id":"62123","content":"在DDD里面聚合是数据管理的基本单元，都通过聚合的仓储服务来实现持久化，一个聚合有一个仓储，跟传统的一次修改很多不同的数据库表不太一样。两个不同的聚合就是两个不同的数据单元，但在一个事务中，如果一次修改两个聚合数据的话，需保证两个聚合数据的最终一致性。其目的也是为了聚合解耦，方便以后微服务架构的演进。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576733653,"ip_address":"","comment_id":163467,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576726671","product_id":100037301,"comment_content":"不要在同一个事务中修改不同聚合的数据,是为了方便后续微服务拆分解耦吗?那如果很清楚不同的聚合日后不会分到不同的微服务里面,为了开发的方便,是不是就可以在同一个事务中修改这些聚合的数据了?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478403,"discussion_content":"在DDD里面聚合是数据管理的基本单元，都通过聚合的仓储服务来实现持久化，一个聚合有一个仓储，跟传统的一次修改很多不同的数据库表不太一样。两个不同的聚合就是两个不同的数据单元，但在一个事务中，如果一次修改两个聚合数据的话，需保证两个聚合数据的最终一致性。其目的也是为了聚合解耦，方便以后微服务架构的演进。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576733653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163463,"user_name":"达文西","can_delete":false,"product_type":"c1","uid":1398824,"ip_address":"","ucode":"01C1063F23D634","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","comment_is_top":false,"comment_ctime":1576726504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576726504","product_id":100037301,"comment_content":"不要在同一个事务中修改不同的聚合数据是为了以后拆分微服务的时候方便解耦吗?","like_count":0},{"had_liked":false,"id":161862,"user_name":"天亮了","can_delete":false,"product_type":"c1","uid":1402260,"ip_address":"","ucode":"F5CEFC4B8F06EA","user_header":"https://static001.geekbang.org/account/avatar/00/15/65/94/829f321f.jpg","comment_is_top":false,"comment_ctime":1576383022,"is_pvip":true,"replies":[{"id":"61648","content":"1、应用服务会调用和组合领域服务，它们是在同一个进程里。<br>2、本地是指的是它们共享一个业务库。事件数据如果太多是需要定期清理或归档的。你也可以单独建立一个独立的事件库，但是由于一笔业务需要将业务数据和事件数据同时写成功，这时需要考虑分布式事务，可能会有效率问题。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576398463,"ip_address":"","comment_id":161862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576383022","product_id":100037301,"comment_content":"老师，请教 2 个问题：<br>1. 案例中领域服务和应用服务是 2 个独立的进程吗？<br>2. “业务和事件数据都持久化到本地投保微服务数据库中。”这一句，“本地”是指什么？是说这 2 个部分存在相同的数据库实例吗？如果是的话，那么事件太多往往需要归档或清理删除，如果每个领域都怎么搞，工作量会不会很大。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477885,"discussion_content":"1、应用服务会调用和组合领域服务，它们是在同一个进程里。\n2、本地是指的是它们共享一个业务库。事件数据如果太多是需要定期清理或归档的。你也可以单独建立一个独立的事件库，但是由于一笔业务需要将业务数据和事件数据同时写成功，这时需要考虑分布式事务，可能会有效率问题。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576398463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161503,"user_name":"给心来块冰块","can_delete":false,"product_type":"c1","uid":1063689,"ip_address":"","ucode":"7AFB56581782A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","comment_is_top":false,"comment_ctime":1576218727,"is_pvip":true,"replies":[{"id":"61537","content":"如果出现故障导致目的端未收到源端数据或数据不一致的问题，就可以比对两端的持久化事件数据，找出有问题的数据。这种问题数据包括未传送的数据或者数据不一致的数据等等，根据问题数据类型采用不同处理方式，或重传，或进行数据补偿等等机制。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576222991,"ip_address":"","comment_id":161503,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576218727","product_id":100037301,"comment_content":"这个事件数据持久化老师讲可以用在消息中间件故障、订阅者宕机或者网络故障恢复时数据对账，那这个在实施的时候是怎么实行的，怎么对账，在网络恢复后怎么继续之前的业务流转啊，不太明白，之前没有做过","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477738,"discussion_content":"如果出现故障导致目的端未收到源端数据或数据不一致的问题，就可以比对两端的持久化事件数据，找出有问题的数据。这种问题数据包括未传送的数据或者数据不一致的数据等等，根据问题数据类型采用不同处理方式，或重传，或进行数据补偿等等机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576222991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160985,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1576073198,"is_pvip":false,"replies":[{"id":"61399","content":"你提到的事件总线是不是企业服务总线（ESB）。事件总线跟它有点不太一样的。思想是可以借鉴的哈，但是内容要考虑一下极客的版权。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576113119,"ip_address":"","comment_id":160985,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576073198","product_id":100037301,"comment_content":"老师，事件总线这种工具可能在国企用的多些，在互联网公司，服务间通讯，下行用dubbo，springcloud，上行rocketMQ，这是一般操作，我想写一篇文章借用您的DDD思想，使用互联网公司常用的一些rpc工具来处理领域事件，不知您是否同意？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477557,"discussion_content":"你提到的事件总线是不是企业服务总线（ESB）。事件总线跟它有点不太一样的。思想是可以借鉴的哈，但是内容要考虑一下极客的版权。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576113119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158230,"user_name":"冷たい風","can_delete":false,"product_type":"c1","uid":1218363,"ip_address":"","ucode":"4D73962B51DD2F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGKX8kPDkrL7oPeBAv4WpqOmEg3KtsLs1vmundm9huEXMuIP3Ql0DZ0c2ZXMr0tVSiaQ7gV2T5GXA/132","comment_is_top":false,"comment_ctime":1575354232,"is_pvip":false,"replies":[{"id":"60631","content":"1、都可以做，可以根据你的使用习惯。<br>2、你可以在应用服务里调用两个服务的，一个用于事件处理，事件处理完成后调用另一个用于事件发布。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575372617,"ip_address":"","comment_id":158230,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575354232","product_id":100037301,"comment_content":"老师你好，基于文档中缴费通知单的例子我请教下以下俩个问题：<br>1、发送缴费通知事件是在应用层发出还是应该在领域层发出呢，还是无论在哪里发送都可以，DDD没有这个强制的规范？<br>2、例子中处理缴费通知和发送事件的方法是二个独立分开的方法，那如果发送事件的上下文数据是需要处理缴费通知逻辑里面的数据，那这种方式就行不通，那是不是就只能在领域服务层处理缴费通知逻辑完成后也在领域服务层发送领域事件？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476683,"discussion_content":"1、都可以做，可以根据你的使用习惯。\n2、你可以在应用服务里调用两个服务的，一个用于事件处理，事件处理完成后调用另一个用于事件发布。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575372617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155687,"user_name":"vivi","can_delete":false,"product_type":"c1","uid":1357983,"ip_address":"","ucode":"360A81D2003C99","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/9f/c64f0896.jpg","comment_is_top":false,"comment_ctime":1574736426,"is_pvip":false,"replies":[{"id":"59776","content":"是差不多的东西","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574742768,"ip_address":"","comment_id":155687,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574736426","product_id":100037301,"comment_content":"老师，领域事件和CQRS里面的COMMAND，什么关系呢？<br>EVENT BUS和COMMAND BUS的联系是什么呢，感觉是一套东西。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475834,"discussion_content":"是差不多的东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574742768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150899,"user_name":"surpass2007","can_delete":false,"product_type":"c1","uid":1023440,"ip_address":"","ucode":"910E4CABFC1540","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/d0/302be4d4.jpg","comment_is_top":false,"comment_ctime":1573624237,"is_pvip":false,"replies":[{"id":"58032","content":"并不是不可以用哈，场景不复杂能接受的话，也是可以用的。主要是服务之间的关系不那么清晰，不像服务之间调用那么直接。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573625343,"ip_address":"","comment_id":150899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573624237","product_id":100037301,"comment_content":"请问为什么微服务内的领域事件要少用呢？如果单纯的使用内部事件的方式，不引入复杂的消息总线，是不是不会增加太大的复杂性呀","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474305,"discussion_content":"并不是不可以用哈，场景不复杂能接受的话，也是可以用的。主要是服务之间的关系不那么清晰，不像服务之间调用那么直接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573625343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150653,"user_name":"张  振","can_delete":false,"product_type":"c1","uid":1491641,"ip_address":"","ucode":"546B38BDF61480","user_header":"https://static001.geekbang.org/account/avatar/00/16/c2/b9/6b0b239f.jpg","comment_is_top":false,"comment_ctime":1573575087,"is_pvip":false,"replies":[{"id":"57950","content":"可以的啊。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573599520,"ip_address":"","comment_id":150653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573575087","product_id":100037301,"comment_content":"问个额外的问题：生成保单之后，佣金和收付事件，可不可以异步去完成？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474233,"discussion_content":"可以的啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573599520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150316,"user_name":"JRich","can_delete":false,"product_type":"c1","uid":1114901,"ip_address":"","ucode":"66AE9D61533960","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg","comment_is_top":false,"comment_ctime":1573518743,"is_pvip":false,"replies":[{"id":"57811","content":"不知道有什么疑惑哈。你可以去网上搜一下Eventbus，有不少的实现方式。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573520253,"ip_address":"","comment_id":150316,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573518743","product_id":100037301,"comment_content":"对这里的事件总线有一些疑惑，请问老师有具体的实现吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474124,"discussion_content":"不知道有什么疑惑哈。你可以去网上搜一下Eventbus，有不少的实现方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573520253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150251,"user_name":"y3","can_delete":false,"product_type":"c1","uid":1128084,"ip_address":"","ucode":"C93F8EC2AAACF6","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/94/5aecb0ef.jpg","comment_is_top":false,"comment_ctime":1573484733,"is_pvip":false,"replies":[{"id":"57815","content":"目前来看主要是分布式事务的方式。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573520903,"ip_address":"","comment_id":150251,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1573484733","product_id":100037301,"comment_content":"请问老师，在要求数据强一致性的分布式场景下，是不是建议使用分布式事务来实现，有其他的解决方案吗？😊😊","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474106,"discussion_content":"目前来看主要是分布式事务的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573520903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2043876,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/gmu7HicQS0bhTl4mdmF8OF6r9SGtiaBmdjV2mDPhlsfCjp3kVicucRuNnhJy3E2DTaNeHzYpVc583UibHrX3ukiaJfw/132","nickname":"Geek_73f7d7","note":"","ucode":"E72F9B428F10CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286066,"discussion_content":"guava有一个eventvus可以参考下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593046851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128084,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/94/5aecb0ef.jpg","nickname":"y3","note":"","ucode":"C93F8EC2AAACF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48760,"discussion_content":"好的，谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573524047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149682,"user_name":"ZIxuAN","can_delete":false,"product_type":"c1","uid":1256455,"ip_address":"","ucode":"C04260E5E384A7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2c/07/06460a88.jpg","comment_is_top":false,"comment_ctime":1573317114,"is_pvip":false,"replies":[{"id":"57588","content":"代码目录结构后面会有专门的一节来讲，这个结构是我们项目过程总结出来的。个人感觉DDD主要提供的是一种思想，在战术实施过程可以根据自己的理解采用最合适的方式来实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573346964,"ip_address":"","comment_id":149682,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573317114","product_id":100037301,"comment_content":"老师，有没有实际应用中的代码发到github上看下，主要想看下项目结构，聚合根是怎么维护生命周期的以及事件的最终一致性是怎么做的。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473939,"discussion_content":"代码目录结构后面会有专门的一节来讲，这个结构是我们项目过程总结出来的。个人感觉DDD主要提供的是一种思想，在战术实施过程可以根据自己的理解采用最合适的方式来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573346964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149425,"user_name":"嘉嘉☕","can_delete":false,"product_type":"c1","uid":1059771,"ip_address":"","ucode":"632A5CC4B53BB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","comment_is_top":false,"comment_ctime":1573215510,"is_pvip":false,"replies":[{"id":"57437","content":"这种情形很特殊，由于一个聚合一个仓储，在仓储内一次修改或者创建聚合内的所有数据。实际上在进行跨聚合数据提交的时候，是在同一进程的事务。但是它与微服务之间的事务不太一样，它是在同一个微服务内，而这种微服务内的数据因为解耦的关系，不同聚合之间的数据隔离性比较高，因此有别于一般的事务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573219440,"ip_address":"","comment_id":149425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573215510","product_id":100037301,"comment_content":"微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，这种方式通常应用于实时性和数据一致性要求高的场景。这个过程会用到分布式事务，以保证发布方和订阅方的数据同时更新成功。<br><br>老师好，这段第一句说“微服务内....”，所以下文中提到的分布式事务，是不是应该就是事务，不是分布式事务？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473858,"discussion_content":"这种情形很特殊，由于一个聚合一个仓储，在仓储内一次修改或者创建聚合内的所有数据。实际上在进行跨聚合数据提交的时候，是在同一进程的事务。但是它与微服务之间的事务不太一样，它是在同一个微服务内，而这种微服务内的数据因为解耦的关系，不同聚合之间的数据隔离性比较高，因此有别于一般的事务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573219440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148966,"user_name":"公众号-微观技术","can_delete":false,"product_type":"c1","uid":1043546,"ip_address":"","ucode":"BD0E46A9CF97E9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/5a/1c68c5a7.jpg","comment_is_top":false,"comment_ctime":1573119166,"is_pvip":false,"replies":[{"id":"57308","content":"visio😀","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573123258,"ip_address":"","comment_id":148966,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573119166","product_id":100037301,"comment_content":"里面的图是用的什么软件画的？谢谢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473689,"discussion_content":"visio😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573123258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148337,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1003571,"ip_address":"","ucode":"58D6AFA7C905AF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/33/43833f7c.jpg","comment_is_top":false,"comment_ctime":1572982681,"is_pvip":false,"replies":[{"id":"57098","content":"分散并且订阅方多的话，是有点麻烦。跟数据迁移一样，可以选择关键数据对账。<br>两种方案各有利弊。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572994637,"ip_address":"","comment_id":148337,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572982681","product_id":100037301,"comment_content":"看了一下关于事件数据持久化的方案二，意思是每个服务都要记录自己发布过的事件和收到过的事件通知么？ 这样事件就会分散到很多个服务中，如果要做整个系统的对账，岂不是很麻烦？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473462,"discussion_content":"分散并且订阅方多的话，是有点麻烦。跟数据迁移一样，可以选择关键数据对账。\n两种方案各有利弊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572994637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003571,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/33/43833f7c.jpg","nickname":"Nick","note":"","ucode":"58D6AFA7C905AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46037,"discussion_content":"所以你更倾向使用哪种方案?\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573113419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148233,"user_name":"Geek_1c00cb","can_delete":false,"product_type":"c1","uid":1424080,"ip_address":"","ucode":"5B98BA2BBAD0DD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvnkXZiaop0haMiarN6TJTUyRtAK3NUetGBJP6MrZBmaadibWPUW1bKib4U51DyVEQkEicUNukWFTzzbQ/132","comment_is_top":false,"comment_ctime":1572961223,"is_pvip":false,"replies":[{"id":"57145","content":"我没有用过四色模型哈。<br>建模的时候，你是不是可以把领域事件驱动 ，当成一种特殊的服务调用呢，只不过是异步化了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573010077,"ip_address":"","comment_id":148233,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1572961223","product_id":100037301,"comment_content":"老师，请教个问题。最近想做重构，先发动大家对各个模块做了梳理，然后想先用四色模型建模，初步分析，但是对于事件驱动的业务如何用四色模型建模，尤其角色这个，指场景吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473438,"discussion_content":"我没有用过四色模型哈。\n建模的时候，你是不是可以把领域事件驱动 ，当成一种特殊的服务调用呢，只不过是异步化了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573010077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562982,"discussion_content":"八叉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649921306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1088710,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","nickname":"苗","note":"","ucode":"5ECCC6C855E541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102274,"discussion_content":"说的是六边形架构吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577335606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147350,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1572860446,"is_pvip":false,"replies":[{"id":"56903","content":"都可以的。但是我建议统一一下。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572861224,"ip_address":"","comment_id":147350,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572860446","product_id":100037301,"comment_content":"同一个微服务内不同聚合之间领域事件，可以在应用层发布领域事件。我觉得有时候通过应用层发布事件方便，但是有些场景下，产生什么样的领域事件，可能在领域层里才好构建出来，通过领域层发布事件也可以吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473231,"discussion_content":"都可以的。但是我建议统一一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572861224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146913,"user_name":"肖大保健","can_delete":false,"product_type":"c1","uid":1306868,"ip_address":"","ucode":"E3209A00C1B954","user_header":"https://static001.geekbang.org/account/avatar/00/13/f0/f4/22dbe2d9.jpg","comment_is_top":false,"comment_ctime":1572697826,"is_pvip":false,"replies":[{"id":"56788","content":"事件总线是微服务聚合之间数据协调用的。微服务之间是通过消息中间件的方式。查询的操作就不要走事件了。除非你采用CQRS模式，在写完库后，再用事件驱动模式异步到读库。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572787229,"ip_address":"","comment_id":146913,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572697826","product_id":100037301,"comment_content":"关于事件总线，在微服务之间，有同步（http，fegin），异步（mq）调用，是不是可以理解事件总线是一个集中处理调用的地方（事件发布订阅来解决）关于事件处理的持久化，事件发布，事件订阅后，两者就要进行存入数据库嘛，异常策略（定时，人工）处理，其实这里是不是应该排除一些非事务的事件（查询操作），事务操作要保持数据一致性才需要","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473053,"discussion_content":"事件总线是微服务聚合之间数据协调用的。微服务之间是通过消息中间件的方式。查询的操作就不要走事件了。除非你采用CQRS模式，在写完库后，再用事件驱动模式异步到读库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572787229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146516,"user_name":"Mr.Strive.Z.H.L","can_delete":false,"product_type":"c1","uid":1030198,"ip_address":"","ucode":"6D97E159E2EECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/36/542c96bf.jpg","comment_is_top":false,"comment_ctime":1572567250,"is_pvip":false,"replies":[{"id":"56583","content":"事件总线也可以配置为同步的方式。<br>如果不想用事件总线 ，你也可以在协调多个聚合的应用服务中加分布式事务也可以。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572570186,"ip_address":"","comment_id":146516,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572567250","product_id":100037301,"comment_content":"老师你好：<br>领域事件在微服务之间通过mq异步驱动，比较好理解。但是在微服务内部（一个系统中），不同的聚合之间采用事件总线驱动，但是如果要保证两个聚合的数据强一致性，怎么办？因为单个系统内采用事务即可，但是有了事件总线，似乎没办法将业务逻辑包含在同一个事物中了？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472896,"discussion_content":"事件总线也可以配置为同步的方式。\n如果不想用事件总线 ，你也可以在协调多个聚合的应用服务中加分布式事务也可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572570186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146308,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572493576,"is_pvip":false,"replies":[{"id":"56484","content":"人员保存成功后，将人员的事件数据发布到消息中间件即可，目的端订阅到主题数据后，进行后续处理。<br>发布到消息中间件就算下发成功了。如果后续不成功，可以通过源端和目的端数据对账的方式处理。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572499393,"ip_address":"","comment_id":146308,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572493576","product_id":100037301,"comment_content":"业务场景：下发人员到考勤机<br>系统：业务系统A，考勤微服务B<br>当操作人员在 A系统点击下发考勤机操作，接口需要提示人员是否下发成功。系统内部A系统会调用B系统接口，需要B系统接口返回下发状态。这种业务场景如何使用领域事件？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472790,"discussion_content":"人员保存成功后，将人员的事件数据发布到消息中间件即可，目的端订阅到主题数据后，进行后续处理。\n发布到消息中间件就算下发成功了。如果后续不成功，可以通过源端和目的端数据对账的方式处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572499393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","nickname":"张迪","note":"","ucode":"6A5D44999A0FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41779,"discussion_content":"类似于银行转账这样获取结果 实时性比较高的场景，是不是不适合使用领域事件？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572502923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145845,"user_name":"乘风","can_delete":false,"product_type":"c1","uid":1310814,"ip_address":"","ucode":"51C1BCC1701BDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/5e/73dd7bf6.jpg","comment_is_top":false,"comment_ctime":1572394430,"is_pvip":false,"replies":[{"id":"56309","content":"他们都在同一个进程和数据库内，不需要用到分布式事务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572399080,"ip_address":"","comment_id":145845,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572394430","product_id":100037301,"comment_content":"createPaymentNotice 和createPaymentNoticeEvent需要用事务包裹吗?如果不用，创建事件不成功怎么办?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472596,"discussion_content":"他们都在同一个进程和数据库内，不需要用到分布式事务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572399080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145309,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1572248311,"is_pvip":false,"replies":[{"id":"56052","content":"事件溯源主要记录事件在不同阶段的状态变化，领域事件驱动主要是实现事件数据在不同微服务之间的传输，实现微服务解耦。两者出发点应该不一样。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572257790,"ip_address":"","comment_id":145309,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572248311","product_id":100037301,"comment_content":"欧老师对事件溯源怎么看？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472331,"discussion_content":"事件溯源主要记录事件在不同阶段的状态变化，领域事件驱动主要是实现事件数据在不同微服务之间的传输，实现微服务解耦。两者出发点应该不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572257790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145228,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1572233268,"is_pvip":false,"replies":[{"id":"56028","content":"我感觉，第一是要做好源端和目的端数据的对账处理，发现并识别处理过程中的异常数据。第二是，发现异常数据后的，要有相应的处理机制。第三是，选择适合自己场景的技术，保证数据正确传输。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572241075,"ip_address":"","comment_id":145228,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572233268","product_id":100037301,"comment_content":"关于领域事件还有一个问题请教：对于大型系统来说，领域事件肯定有很多，在整个领域事件的管理方面有没有什么经验可以分享的？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472301,"discussion_content":"我感觉，第一是要做好源端和目的端数据的对账处理，发现并识别处理过程中的异常数据。第二是，发现异常数据后的，要有相应的处理机制。第三是，选择适合自己场景的技术，保证数据正确传输。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572241075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145212,"user_name":"。","can_delete":false,"product_type":"c1","uid":1222200,"ip_address":"","ucode":"75B163F01F20F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/38/55483b8c.jpg","comment_is_top":false,"comment_ctime":1572230533,"is_pvip":false,"replies":[{"id":"56027","content":"微服务内的领域事件主要是避免一次事务同时修改多个聚合的数据，解耦聚合和保证数据的一致性。但聚合内采用事件总线会增加开发的复杂度，个人不建议多用。<br>2、这种异步的方式一般都有源端和目的端定期对账的机制。我见得最多的是采用类似财务冲正的方式。如果在发布和订阅之间事件表的数据发现异步数据有问题，需要回退，会有相应的代码进行数据处理，不过不同的场景，业务逻辑会不一样，处理的方式会不一样。有的甚至还需要转人工处理。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572240359,"ip_address":"","comment_id":145212,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572230533","product_id":100037301,"comment_content":"欧老师，你好。有两个问题请教一下<br>1.微服务内的领域事件。<br>  我看你介绍的，需要引入事件总线和分布式事务。同一个服务内，应该是同一个进程，数据库一般也 <br>  是同一个。采用直接调用是不是就可以？如：在a领域中 b.method();<br>2.微服务间的领域事件。<br>  不管是rpc调用还是消息中间件，分布式事务不可避免吧。业界是如何处理分布式事务的呢？就像上面的例子，收款异常了怎么回滚投保？发mq的时候，投保数据已经入库了吧。是通过每条数据有状态标识？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472292,"discussion_content":"微服务内的领域事件主要是避免一次事务同时修改多个聚合的数据，解耦聚合和保证数据的一致性。但聚合内采用事件总线会增加开发的复杂度，个人不建议多用。\n2、这种异步的方式一般都有源端和目的端定期对账的机制。我见得最多的是采用类似财务冲正的方式。如果在发布和订阅之间事件表的数据发现异步数据有问题，需要回退，会有相应的代码进行数据处理，不过不同的场景，业务逻辑会不一样，处理的方式会不一样。有的甚至还需要转人工处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572240359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145117,"user_name":"Geek_b5c4eb","can_delete":false,"product_type":"c1","uid":1388118,"ip_address":"","ucode":"E1D119C0F4618D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FvADgWRdOA1U1KciauXHLiaNIzHVrVrLRyS0NcCW357nAed3PYIc0zEYTggth7iaekoaYr49fic2pNYcqugomy7dMA/132","comment_is_top":false,"comment_ctime":1572219941,"is_pvip":false,"replies":[{"id":"55960","content":"这里碰巧是领域服务对应一个应用服务。应用服务主要是做组合和编排，不具有太多的逻辑，所以不会太重。作为事件服务的发布和订阅，在应用服务中也只是完成发布和接受，不做业务逻辑处理，事件处理是在领域层去做的，所有也不会太重。<br>应用层主要是做服务组合、转换和传递的作用。不会有太多的业务逻辑处理。这样设计也相当于是将部分与业务无关的逻辑剥离出领域层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572226333,"ip_address":"","comment_id":145117,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572219941","product_id":100037301,"comment_content":"老师好，最后一个缴费例子，每个领域服务都对应一个应用服务么，而且图上事件的触发和订阅都由相应的应用服务来做，那应用服务是不是很重，而且领域服务显得不内聚了。实践中应用服务我们是做成了面向某一类用户的应用服务，如面向c端一个应用服务，面向内部运营系统一个应用服务，请问老师这样理解应用服务是否正确，谢谢！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472251,"discussion_content":"这里碰巧是领域服务对应一个应用服务。应用服务主要是做组合和编排，不具有太多的逻辑，所以不会太重。作为事件服务的发布和订阅，在应用服务中也只是完成发布和接受，不做业务逻辑处理，事件处理是在领域层去做的，所有也不会太重。\n应用层主要是做服务组合、转换和传递的作用。不会有太多的业务逻辑处理。这样设计也相当于是将部分与业务无关的逻辑剥离出领域层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572226333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145032,"user_name":"陈勇","can_delete":false,"product_type":"c1","uid":1079706,"ip_address":"","ucode":"B78F24A4C3754B","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/9a/5198fc0e.jpg","comment_is_top":false,"comment_ctime":1572166437,"is_pvip":true,"replies":[{"id":"55962","content":"等后面有时间的时候我试试看哈。不过DDD主要还是在于设计思想，你先从这个课件里了解一下DDD是怎样进行战略设计和战术设计的。咱们可以多保持交流。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572226616,"ip_address":"","comment_id":145032,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572166437","product_id":100037301,"comment_content":"老师能否用springboot和mybatis技术栈开源一个实战项目呢？比如对电商的商品域和营销域进行建模？通过一个项目把DDD的各个设计元素串起来？不然大家还是会看起来懂了，实践起来还是不会。谢谢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472219,"discussion_content":"等后面有时间的时候我试试看哈。不过DDD主要还是在于设计思想，你先从这个课件里了解一下DDD是怎样进行战略设计和战术设计的。咱们可以多保持交流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572226616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364986,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/eOb0Z9PVwFnfZthnxvYzL3uIoXZXsDZHaZQS97beFNyqVskWEeumxputYTAUGLqsuWG1f9ApV8c1BaXHkMibIRg/132","nickname":"Cydeer","note":"","ucode":"5E6DC0909D5916","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589230,"discussion_content":"打算搞一个这样的项目来学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664547454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144995,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1572156046,"is_pvip":false,"replies":[{"id":"55902","content":"这些领域事件分成两大类，一个是微服务内跨聚合的领域事件，另一个是微服务之间的领域事件。一个聚合内一般都不用领域事件驱动的方式设计，它们在同一个进程内，不需要采用异步的方式。<br>微服务内和微服务之间都可以采用应用服务调用的方式来实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572165822,"ip_address":"","comment_id":144995,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572156046","product_id":100037301,"comment_content":"看了最后的例子我有很大的疑惑，似乎领域事件并不和触发其的服务等，在同一个聚合里？而是分开两个聚合，在应用层一起调用？<br>按照直观感受把事件本身和事件源放在一起不是更内聚？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472204,"discussion_content":"这些领域事件分成两大类，一个是微服务内跨聚合的领域事件，另一个是微服务之间的领域事件。一个聚合内一般都不用领域事件驱动的方式设计，它们在同一个进程内，不需要采用异步的方式。\n微服务内和微服务之间都可以采用应用服务调用的方式来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572165822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40400,"discussion_content":"好像说岔了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572183223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144993,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1572155066,"is_pvip":false,"replies":[{"id":"55903","content":"领域事件由外部命令触发。触发命令可以是领域服务，也可以是实体的某一个方法或者行为。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572165964,"ip_address":"","comment_id":144993,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572155066","product_id":100037301,"comment_content":"请问您，领域事件要由领域服务产生，而不是由相关的实体实现产生领域事件的方法？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472203,"discussion_content":"领域事件由外部命令触发。触发命令可以是领域服务，也可以是实体的某一个方法或者行为。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572165964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144800,"user_name":"夙梦流尘","can_delete":false,"product_type":"c1","uid":1477260,"ip_address":"","ucode":"D7E84D3B588BD6","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/8c/07dd8832.jpg","comment_is_top":false,"comment_ctime":1572060405,"is_pvip":false,"replies":[{"id":"55873","content":"因为在微服务内部在同一个进程，事件总线相对好配置，它可以配置为异步的也可以配置为同步的。如果是同步就不需要落库。我还是建议尽量少用微服务内聚合之间的领域事件，它会增加你的开发复杂度。<br>微服务之间的事件，在事件数据落库后，通过应用服务直接发布到消息中间件的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572088988,"ip_address":"","comment_id":144800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572060405","product_id":100037301,"comment_content":"有两个问题想问下<br>1 服务内的事件我觉得也是要落库吧。因为要保证最终一致性<br>2 外部服务关心的消息可以不走事件总线直接在应用服务里发消息吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472117,"discussion_content":"因为在微服务内部在同一个进程，事件总线相对好配置，它可以配置为异步的也可以配置为同步的。如果是同步就不需要落库。我还是建议尽量少用微服务内聚合之间的领域事件，它会增加你的开发复杂度。\n微服务之间的事件，在事件数据落库后，通过应用服务直接发布到消息中间件的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572088988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144643,"user_name":"蜗牛慢慢爬","can_delete":false,"product_type":"c1","uid":1666095,"ip_address":"","ucode":"6591A58A582BE0","user_header":"https://static001.geekbang.org/account/avatar/00/19/6c/2f/8086c22a.jpg","comment_is_top":false,"comment_ctime":1571988994,"is_pvip":false,"replies":[{"id":"55751","content":"不好意思哈，不太方便放出来。有疑问咱们可以多沟通。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571993715,"ip_address":"","comment_id":144643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571988994","product_id":100037301,"comment_content":"建议把源码发出来好理解些，光这些流程有些抽象。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472048,"discussion_content":"不好意思哈，不太方便放出来。有疑问咱们可以多沟通。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571993715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144592,"user_name":"王乾","can_delete":false,"product_type":"c1","uid":1510374,"ip_address":"","ucode":"CF06C0444953DA","user_header":"https://static001.geekbang.org/account/avatar/00/17/0b/e6/dcb30037.jpg","comment_is_top":false,"comment_ctime":1571974024,"is_pvip":false,"replies":[{"id":"55720","content":"可以把问题具体化向作者提问，希望能帮到你！","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1571974940,"ip_address":"","comment_id":144592,"utype":2}],"discussion_count":2,"race_medal":0,"score":"1571974024","product_id":100037301,"comment_content":"太抽象了看不懂！","like_count":0,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472021,"discussion_content":"可以把问题具体化向作者提问，希望能帮到你！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571974940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39777,"discussion_content":"给你举一个常见的例子吧。现在互联网应用很多都采用削峰填谷的机制。在面对双十一之类的海量用户访问时，可以将访问数据先放到队列里面，排队进行处理，避免系统由于访问量太多而导致系统宕机。这是一种基于消息机制的异步化的实现机制，领域事件的技术实现模式类似，有什么具体疑问你可以直接发给我哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571984342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144590,"user_name":"夙梦流尘","can_delete":false,"product_type":"c1","uid":1477260,"ip_address":"","ucode":"D7E84D3B588BD6","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/8c/07dd8832.jpg","comment_is_top":false,"comment_ctime":1571973840,"is_pvip":false,"replies":[{"id":"55733","content":"可以通过应用层来协调和交互。应用服务是所有聚合之上的服务，负责服务的组合和编排，以及聚合之间的协调。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571980604,"ip_address":"","comment_id":144590,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1571973840","product_id":100037301,"comment_content":"那如果少用领域事件，聚合之间应该怎么交互呢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472019,"discussion_content":"可以通过应用层来协调和交互。应用服务是所有聚合之上的服务，负责服务的组合和编排，以及聚合之间的协调。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571980604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053853,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/9d/19dcdd42.jpg","nickname":"瓜瓜","note":"","ucode":"2E98377E48399E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39856,"discussion_content":"有很多操作还是需要异步的啊。事件不就是在异步的时候用吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572002695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1053853,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/9d/19dcdd42.jpg","nickname":"瓜瓜","note":"","ucode":"2E98377E48399E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39896,"discussion_content":"这个异步说的是微服务内聚合之间的异步，不是微服务之间的异步，微服务之间该用异步方式就毫不犹豫用异步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572012840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":39856,"ip_address":""},"score":39896,"extra":""},{"author":{"id":1477260,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8a/8c/07dd8832.jpg","nickname":"夙梦流尘","note":"","ucode":"D7E84D3B588BD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1053853,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/9d/19dcdd42.jpg","nickname":"瓜瓜","note":"","ucode":"2E98377E48399E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40023,"discussion_content":"我觉得事件最大的意义还是解耦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572061313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":39856,"ip_address":""},"score":40023,"extra":""}]}]},{"had_liked":false,"id":144559,"user_name":"TH","can_delete":false,"product_type":"c1","uid":1053413,"ip_address":"","ucode":"C5EA20546DC09C","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/e5/592d9324.jpg","comment_is_top":false,"comment_ctime":1571968611,"is_pvip":true,"replies":[{"id":"55736","content":"我在分层架构和其它章节会详细讲解这两个服务的。同名的话一般会通过后缀名来区分，比如*appservice是应用服务，*domainservice是领域服务。<br>投保转保单是在投保微服务完成的，它是投保微服务的最后一个业务操作。保单数据发送到保单微服务后，就到了保单管理的限界上下文了。上下文与实现一般都是一致的。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571980984,"ip_address":"","comment_id":144559,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571968611","product_id":100037301,"comment_content":"课表中好像没有涉及到领域服务和应用服务，老师可以讲一讲吗？本文案例中领域服务与应用服务同名，那么他们的概念和区别是什么呢？<br><br>另外，投保单转保单这个功能的实现位于投保微服务还是保单微服务？对应到上下文设计，又应当属于投保上下文还是保单上下文呢？从上下文到具体的实现，会不会出现上下文划分和实现的划分不一致的情况？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472007,"discussion_content":"我在分层架构和其它章节会详细讲解这两个服务的。同名的话一般会通过后缀名来区分，比如*appservice是应用服务，*domainservice是领域服务。\n投保转保单是在投保微服务完成的，它是投保微服务的最后一个业务操作。保单数据发送到保单微服务后，就到了保单管理的限界上下文了。上下文与实现一般都是一致的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571980984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144528,"user_name":"m5jun","can_delete":false,"product_type":"c1","uid":1237302,"ip_address":"","ucode":"CA51419232644B","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/36/452106af.jpg","comment_is_top":false,"comment_ctime":1571965735,"is_pvip":false,"replies":[{"id":"55739","content":"微服务的边界是基于领域模型的，领域模型是在限界上下文内，限界上下文也是一种边界。<br>因为聚合本身业务内聚性很高，在某些要求极致性能的情况下，也可以将聚合部署为一个微服务，比如一个服务就是一个微服务。<br>但我不提倡过度拆分，过度拆分会导致集成和运维的成本增加。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571982470,"ip_address":"","comment_id":144528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571965735","product_id":100037301,"comment_content":"微服务粒度的划分应该事基于领域而非聚合吧？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471990,"discussion_content":"微服务的边界是基于领域模型的，领域模型是在限界上下文内，限界上下文也是一种边界。\n因为聚合本身业务内聚性很高，在某些要求极致性能的情况下，也可以将聚合部署为一个微服务，比如一个服务就是一个微服务。\n但我不提倡过度拆分，过度拆分会导致集成和运维的成本增加。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571982470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144519,"user_name":" 刘进科","can_delete":false,"product_type":"c1","uid":1583439,"ip_address":"","ucode":"A557C60932C2AD","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBIQKyibEibjwyDicHSNy9jR5EfQQsztnZluMzkJV7TNwL7hSuUT5tXSaMicGFzo6cibOAH9GLA77kFTA/132","comment_is_top":false,"comment_ctime":1571964667,"is_pvip":false,"replies":[{"id":"55700","content":"生成订单是命令。订单已生成是命令产生的事件。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571965916,"ip_address":"","comment_id":144519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571964667","product_id":100037301,"comment_content":"领域事件只是指业务发生后的通知，例如&quot;订单己生成&quot;?那&quot;生成订单&quot;呢? 与CQRS里的command有什么联系?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471984,"discussion_content":"生成订单是命令。订单已生成是命令产生的事件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571965916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}