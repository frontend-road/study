{"id":735114,"title":"05｜Server性能提升：设计多个Processor","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>学完前几节课的内容之后，现在我们已经做到接口满足Servlet规范，而且功能模块拆分成了Connector和Processor两部分，它们各司其职，一个负责网络连接，一个负责Servlet调用处理。</p><p>但现在这个Server的运行模式是，一个Connector服务于一个Processor，而且每次创建Processor的时候都是重新实例化一个新的对象，Processor还不支持多线程处理，所以我们在HttpServer性能方面还有提升的空间。</p><p>这节课，我们计划引入池的概念，增强Processor的复用性，同时将Processor异步化，支持一个Connector服务于多个Processor。</p><p><img src=\"https://static001.geekbang.org/resource/image/15/c6/1534805c6edf2fb2c2493d34792bbac6.png?wh=2212x944\" alt=\"\"></p><h2>项目结构</h2><p>这节课，我们只针对原有的HttpConnector和HttpProcessor类进行改造，所以项目结构和maven引入依赖保持不变，还是延续下面的结构和配置。</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ server\n│  │  │  │  ├─ HttpConnector.java\n│  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  ├─ HttpServer.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  ├─ StatisResourceProcessor.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><!-- [[[read_end]]] --><p>pom.xml参考如下：</p><pre><code class=\"language-xml\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;day3&lt;/groupId&gt;\n    &lt;artifactId&gt;day3&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n            &lt;version&gt;3.4&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;  \n</code></pre><h2>池化技术引入</h2><p>现在我们在HttpConnector里获取到Socket后，每次都是创建一个全新的HttpProcessor对象，如下所示：</p><pre><code class=\"language-java\">socket = serverSocket.accept();\nHttpProcessor processor = new HttpProcessor();\nprocessor.process(socket);\n</code></pre><p>在并发请求逐步增加后，构造新对象会对服务器的性能造成负担，所以我们打算引入池，把对象初始化好之后，需要用的时候再拿出来使用，不需要使用的时候就再放回池里，不用再构造新的对象。</p><p>因此，接下来我们先改造HttpConnector类，使用ArrayDeque存放构造完毕的HttpProcessor对象。改造如下：</p><pre><code class=\"language-java\">public class HttpConnector implements Runnable {\n    int minProcessors = 3;\n    int maxProcessors = 10;\n    int curProcessors = 0;\n    //存放多个processor的池子\n    Deque&lt;HttpProcessor&gt; processors = new ArrayDeque&lt;&gt;();\n    public void run() {\n        ServerSocket serverSocket = null;\n        int port = 8080;\n        try {\n            serverSocket = new ServerSocket(port, 1, InetAddress.getByName(\"127.0.0.1\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n        // initialize processors pool\n        for (int i = 0; i &lt; minProcessors; i++) {\n            HttpProcessor processor = new HttpProcessor();\n            processors.push(processor);\n        }\n        curProcessors = minProcessors;\n        while (true) {\n            Socket socket = null;\n            try {\n                socket = serverSocket.accept();\n                //得到一个新的processor，这个processor从池中获取(池中有可能新建)\n                HttpProcessor processor = createProcessor();\n                if (processor == null) {\n                    socket.close();\n                    continue;\n                }\n                processor.process(socket); //处理\n                processors.push(processor); //处理完毕后放回池子\n                // Close the socket\n                socket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public void start() {\n        Thread thread = new Thread(this);\n        thread.start();\n    }\n    //从池子中获取一个processor，如果池子为空且小于最大限制，则新建一个\n    private HttpProcessor createProcessor() {\n        synchronized (processors) {\n            if (processors.size() &gt; 0) {\n                //获取一个\n                return ((HttpProcessor) processors.pop());\n            }\n            if (curProcessors &lt; maxProcessors) {\n                //新建一个\n                return (newProcessor());\n            }\n            else {\n                return (null);\n            }\n        }\n    }\n    //新建一个processor\n    private HttpProcessor newProcessor() {\n        HttpProcessor initprocessor = new HttpProcessor();\n        processors.push(initprocessor);\n        curProcessors++;\n        return ((HttpProcessor) processors.pop());\n    }\n}\n</code></pre><p>从上述代码中，我们可以看到，run()方法中先进行了processors池的初始化，就是循环创建新的HttpProcessor对象后，push到processors这个ArrayDeque里，processors作为HttpProcessor对象的存储池使用。</p><p>之后，每次接收到一个socket，就用createProcessor()方法获取到一个processor。看一下createProcessor()方法的代码，可以发现当processors内元素不为空的时候，直接从ArrayDeque内获取HttpProcessor对象，每次从池里获取一个processor。如果池子里没有processor，就新创建一个。</p><p>无论池子里有没有，最后的结果都是拿到了一个processor，然后执行它，任务执行完之后再把它放回池里。完成了一次请求响应。</p><p>但是我们要注意，到现在为止，HttpProcessor并没有做到多线程，也没有实现NIO，只是在池中放置了多个对象，做到了多路复用。目前整体架构还是阻塞式运行的，Socket每次用之后也关闭丢弃了。</p><p>所以我们要继续改造，优化HttpProcessor的性能。</p><h2>多线程HttpProcessor</h2><p>接下来，我们计划设置多线程Processor，通过这个手段继续优化它的性能。这可以使一个Connector同时服务于多个Processor。</p><p>基本的思路是使用多个线程，让Connector和Processor分别由不同的线程来运行。工作的基本流程是由Connector接收某个Socket连接后交给某个Processor线程处理，而Processor线程等待某个Socket连接到来后进行处理，处理完毕之后要交回给Connector。因此，<strong>这里的核心是要设计一个线程之间的同步机制。</strong></p><p>首先我们让HttpProcessor实现Runnable接口，这样每一个HttpProcessor都可以在独立的线程中运行。改造如下：</p><pre><code class=\"language-java\">public class HttpProcessor implements Runnable{\n    @Override\n    public void run() {\n        while (true) {\n            // 等待socket分配过来\n            Socket socket = await();\n            if (socket == null) continue;\n            // 处理请求\n            process(socket);\n            // 回收processor\n            connector.recycle(this);\n        }\n    }\n}\n</code></pre><p>上述Processor的run()方法执行过程是，等待某个Socket，收到Connector交过来的Socket后，Process方法处理这个Socket，处理完毕之后交回给Connector回收，并重新把这个processor放入池里。</p><p>这是Processor接收者这一边，而另一边就是作为分配者的Connector。类似地，我们提供一个assign方法让Connector分配Socket给Processor。</p><p>接下来我们重点解决分配者和接收者如何同步的问题。因为这是两个线程，一定需要同步才能协同工作。基本的思路就是 <code>await()</code> 方法里等着Socket，而assign()方法里分配Socket，中间通过一个标志来表示分配和接收状态，以此进行同步。</p><p>这个同步的机制内部其实就是用的Java自身提供的notify和wait。</p><p>看程序代码，如下所示：</p><pre><code class=\"language-java\">synchronized void assign(Socket socket) {\n    // 等待connector提供一个新的socket\n    while (available) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n        }\n    }\n    // 获取到这个新的Socket\n    this.socket = socket;\n    // 把标志设置回去\n    available = true;\n    //通知另外的线程\n    notifyAll();\n}\nprivate synchronized Socket await() {\n    // 等待connector提供一个新的socket\n    while (!available) {\n        try {\n            wait();\n        }catch (InterruptedException e) {\n        }\n    }\n    // 获得这个新的Socket\n    Socket socket = this.socket;\n    //设置标志为false\n    available = false;\n    //通知另外的线程\n    notifyAll();\n    return (socket);\n}\n</code></pre><p>首先看 <code>assign(socket)</code> 方法，在这里，我们用一个标志available来标记，如果标志为true，Connetor线程就继续死等。到了某个时候，Processor线程把这个标志设置为false，Connector线程就跳出死等的循环，然后把接收到的Socket交给Processor。然后要立刻重新把available标志设置为true，再调用 <code>notifyAll()</code> 通知其他线程。</p><p>再看 <code>await()</code>，这是作为接收者Processor的线程使用的方法。反过来，如果avaliable标志为false，那么Processor线程继续死等。到了某个时候，Connector线把这个标志设置为true，那么Processor线程就跳出死等的循环，拿到Socket。然后要立刻重新把avaiable标志设置为false，再调用 <code>notifyAll()</code> 通知其他线程。</p><p>这个线程互锁机制保证了两个线程之间的同步协调。图示如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/45/2d11aedac65015d24a77116290f1b145.png?wh=2220x1376\" alt=\"\"></p><p>下面我列出HttpProcessor的完整代码，因为HttpProcessor构造函数调整，增加了HttpConnector的参数，所以我把HttpConnector类调整后的代码一并列出了，随后我们统一说明调整步骤还有调整的理由。</p><p>HttpProcessor代码：</p><pre><code class=\"language-java\">public class HttpProcessor implements Runnable{\n    Socket socket;\n    boolean available = false;\n    HttpConnector connector;\n    public HttpProcessor(HttpConnector connector) {\n        this.connector = connector;\n    }\n    @Override\n    public void run() {\n        while (true) {\n            // 等待分配下一个 socket\n            Socket socket = await();\n            if (socket == null) continue;\n            // 处理来自这个socket的请求\n            process(socket);\n            // 完成此请求\n            connector.recycle(this);\n        }\n    }\n    public void start() {\n        Thread thread = new Thread(this);\n        thread.start();\n    }\n    public void process(Socket socket) {\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e1) {\n            e1.printStackTrace();\n        }\n        InputStream input = null;\n        OutputStream output = null;\n        try {\n            input = socket.getInputStream();\n            output = socket.getOutputStream();\n            // 创建请求对象并解析\n            Request request = new Request(input);\n            request.parse();\n            // 创建响应对象\n            Response response = new Response(output);\n            response.setRequest(request);\n//               response.sendStaticResource();\n            // 检查这是对servlet还是静态资源的请求\n            // a request for a servlet begins with \"/servlet/\"\n            if (request.getUri().startsWith(\"/servlet/\")) {\n                ServletProcessor processor = new ServletProcessor();\n                processor.process(request, response);\n            }\n            else {\n                StaticResourceProcessor processor = new StaticResourceProcessor();\n                processor.process(request, response);\n            }\n            // 关闭 socket\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    synchronized void assign(Socket socket) {\n        // 等待 connector 提供新的 Socket\n        while (available) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n            }\n        }\n        // 存储新可用的 Socket 并通知我们的线程\n        this.socket = socket;\n        available = true;\n        notifyAll();\n    }\n    private synchronized Socket await() {\n        // 等待 connector 提供一个新的 Socket\n        while (!available) {\n            try {\n                wait();\n            }catch (InterruptedException e) {\n            }\n        }\n        // 通知Connector我们已经收到这个Socket了\n        Socket socket = this.socket;\n        available = false;\n        notifyAll();\n        return (socket);\n    }\n}\n</code></pre><p>要注意available标志和 <code>assign()</code> 方法都是写在Processor类里的。</p><pre><code class=\"language-java\">processor.assign(socket);\n</code></pre><p>但是这并不表示 <code>assign()</code> 是Processor线程来执行，因为这个方法的调用者是Connector。</p><p>HttpConnector代码：</p><pre><code class=\"language-java\">public class HttpConnector implements Runnable {\n    int minProcessors = 3;\n    int maxProcessors = 10;\n    int curProcessors = 0;\n    //存放Processor的池子\n    Deque&lt;HttpProcessor&gt; processors = new ArrayDeque&lt;&gt;();\n    public void run() {\n        ServerSocket serverSocket = null;\n        int port = 8080;\n        try {\n            serverSocket = new ServerSocket(port, 1, InetAddress.getByName(\"127.0.0.1\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n        // 初始化池子initialize processors pool\n        for (int i = 0; i &lt; minProcessors; i++) {\n            HttpProcessor initprocessor = new HttpProcessor(this);\n            initprocessor.start();\n            processors.push(initprocessor);\n        }\n        curProcessors = minProcessors;\n        while (true) {\n            Socket socket = null;\n            try {\n                socket = serverSocket.accept();\n                //对每一个socket，从池子中拿到一个processor\n                HttpProcessor processor = createProcessor();\n                if (processor == null) {\n                    socket.close();\n                    continue;\n                }\n                //分配给这个processor\n                processor.assign(socket);\n                // Close the socket\n//                socket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public void start() {\n        Thread thread = new Thread(this);\n        thread.start();\n    }\n    //从池子中获取一个processor，池子为空且数量小于最大限制则会新建一个processor\n    private HttpProcessor createProcessor() {\n        synchronized (processors) {\n            if (processors.size() &gt; 0) {\n                return ((HttpProcessor) processors.pop());\n            }\n            if (curProcessors &lt; maxProcessors) {\n                return (newProcessor());\n            }\n            else {\n                return (null);\n            }\n        }\n    }\n    private HttpProcessor newProcessor() {\n        HttpProcessor initprocessor = new HttpProcessor(this);\n        initprocessor.start();\n        processors.push(initprocessor);\n        curProcessors++;\n        return ((HttpProcessor) processors.pop());\n    }\n    void recycle(HttpProcessor processor) {\n        processors.push(processor);\n    }\n}\n\n</code></pre><p>我们再回顾一下HttpProcessor类中的assign方法与await方法。在HttpProcessor的线程启动之后，available的标识一直是false，这个时候这个线程会一直等待。在HttpConnector类里构造Processor，并且调用 <code>processor.assign(socket)</code> 给HttpProcessor分配Socket之后，标识符available改成true，并且调用notifyAll这个本地方法通知唤醒所有等待的线程。</p><p>而在await方法里，HttpProcessor拿到HttpConnector传来的Socket之后，首先会接收Socket，并且立即把available由true改为false，最后以拿到的这个Socket为基准继续进行Processor中的处理工作。</p><p>这也意味着，一旦Connector分配了一个Socket给到Processor，后者就能立即结束等待，拿到Socket后调用Process方法继续后面的工作。这时available的状态立刻修改，进而用notifyAll方法唤醒Connector的等待线程，Connector就可以全身而退，去处理下一个HttpProcessor了。</p><p>Tomcat中两个线程互锁的这种机制很经典，在后续版本的NIO和Servlet协调的设计中都用到了。</p><p>这样也就做到了HttpProcessor的异步化，也正因为做到了异步化，我们就不能再利用Connector去关闭Socket了，因为Connector是不知道Processor何时处理完毕的，Socket的关闭任务就交给Processor自己处理了。</p><p>因此在Connector类里，socket.close()这一行被注释掉了，而在Processor类里新增了那一行代码。</p><h2>测试</h2><p>在src/test/java/test目录下，修改HelloServlet。</p><pre><code class=\"language-java\">package test;\nimport java.io.IOException;\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\npublic class HelloServlet implements Servlet{\n    @Override\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n        res.setCharacterEncoding(\"UTF-8\");\n        String doc = \"&lt;!DOCTYPE html&gt; \\n\" +\n                \"&lt;html&gt;\\n\" +\n                \"&lt;head&gt;&lt;meta charset=\\\"utf-8\\\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;\\n\"+\n                \"&lt;body bgcolor=\\\"#f0f0f0\\\"&gt;\\n\" +\n                \"&lt;h1 align=\\\"center\\\"&gt;\" + \"Hello World 你好\" + \"&lt;/h1&gt;\\n\";\n        res.getWriter().println(doc);\n    }\n    @Override\n    public void destroy() {\n    }\n    @Override\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n    @Override\n    public String getServletInfo() {\n        return null;\n    }\n    @Override\n    public void init(ServletConfig arg0) throws ServletException {\n    }\n}\n</code></pre><p>这一次我们的测试类还是和之前差不多，但在Processor的process方法中，我们新增了Thread.sleep方法。</p><p>在准备工作进行完毕之后，我们运行HttpServer服务器，在浏览器中可以连续打开多个页面，键入 <code>http://localhost:8080/hello.txt</code> 后，等待一小段时间（这个时间由Thread.sleep传入参数timeout决定，timeout以毫秒为单位），随后我们可以发现hello.txt里的所有文本内容，都作为返回体展示在浏览器页面上了。</p><p>再以同样的方法测试HelloServlet，输入 <code>http://localhost:8080/servlet/test.HelloServlet</code> 后等待一小会儿还是可以看到浏览器显示：Hello World 你好。这也是我们在HelloServlet里定义的返回资源内容。</p><p>这些结果可以证明，我们整体的改造已经做到Processor异步化的改造，在客户端连续输入多次请求后，能做到并发执行，互不影响。</p><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/5d/75/5d5f42c1d99ba37d9b66821ed322ca75.jpg?wh=2308x1172\" alt=\"\"></p><p>这节课我们主要做了两件事：引入池化技术以及Processor多线程。前者我们从优化对象构造，持续复用的角度，做到了性能的优化提升，压缩了构造对象的性能开销；而后者则从并发的角度，使Connector能同时服务于多个Processor，减少了原来因等待Processor处理而产生的时间消耗，但是也需要仔细编写线程同步代码。</p><p>本节课完整代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter05\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter0</a><a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter05\">5</a></p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：Tomcat为什么用一个简单的queue来实现多线程而不是用JDK自带的线程池？</p><p>欢迎你把你思考后的结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"04｜各司其职的Server：拆分响应模块与处理模块","id":734381},"right":{"article_title":"06｜规范化：引入HttpRequest与HttpResponse","id":735122}},"comments":[{"had_liked":false,"id":386234,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"广东","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1704359989,"is_pvip":false,"replies":[{"id":140784,"content":"赞。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1704380996,"ip_address":"湖南","comment_id":386234,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"思考题：tomcat的线程池模型和JDK自带线程池模型在核心线程池用完后的实现方式上是不同的；JDK的线程池在达到核心线程池数量后，后续的请求会进入到等待队列（微观上看属于阻塞），因为tomcat作为servlet服务请求，本质上只能并发处理有限个（核心线程数）的并发数，这显然是不合理的；所以tomcat的线程池模型是达到核心线程池后会继续启动新线程处理请求，直到达到最大线程数；","like_count":5,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635086,"discussion_content":"赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704380996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1572356,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fe/04/bb427e47.jpg","nickname":"码哥字节","note":"","ucode":"362103AD52C8E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650680,"discussion_content":"那可以把核心线程数与最大线程数设置成一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725445535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1572356,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fe/04/bb427e47.jpg","nickname":"码哥字节","note":"","ucode":"362103AD52C8E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651673,"discussion_content":"还是有区别的，为了达到高吞吐量，你的核心线程数势必要设置一个大的数值，因为核心线程数在空闲时不能释放，所以会很耗资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1727240677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":650680,"ip_address":"广东","group_id":0},"score":651673,"extra":""},{"author":{"id":1572356,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fe/04/bb427e47.jpg","nickname":"码哥字节","note":"","ucode":"362103AD52C8E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654819,"discussion_content":"也可以设置回收空闲核心线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733537527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":651673,"ip_address":"广东","group_id":0},"score":654819,"extra":""}]}]},{"had_liked":false,"id":388526,"user_name":"Geek_ac5e30","can_delete":false,"product_type":"c1","uid":2704281,"ip_address":"中国香港","ucode":"D8349339D63A10","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/kgFgg4b6yribq8tSqAht0383fzoGSG9COPiaicLMzbdouGBrtJehiboqnJbbAiaNEtib1wYM9wAlAvCTZFUfYQDaElBA/132","comment_is_top":false,"comment_ctime":1710333248,"is_pvip":false,"replies":[{"id":141538,"content":"是","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1711286644,"ip_address":"福建","comment_id":388526,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"这里 available 变量是否使用 volatile 修饰会好一些呢？这里涉及到两个线程之间的可见性问题","like_count":4,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640198,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711286644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2683430,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","nickname":"听风有信","note":"","ucode":"2CCB467114FF5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654030,"discussion_content":"应该不用，同一把锁的解锁 happens  before 于加锁，所以 available 的修改是可见的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731722859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385554,"user_name":"so long","can_delete":false,"product_type":"c1","uid":1449679,"ip_address":"浙江","ucode":"2A6B47BB32FC18","user_header":"https://static001.geekbang.org/account/avatar/00/16/1e/cf/97cd8be1.jpg","comment_is_top":false,"comment_ctime":1702902658,"is_pvip":false,"replies":[{"id":140508,"content":"是的。jdk线程池用的普通队列，不适合io型多任务处理。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702969487,"ip_address":"北京","comment_id":385554,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"jdk线程池，在并发数超过核心线程数后，会先将请求任务添加到队列中，而不是创建新的线程处理请求任务，所以会存在一定的延迟","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634072,"discussion_content":"是的。jdk线程池用的普通队列，不适合io型多任务处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702969487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385810,"user_name":"像少年样飞驰","can_delete":false,"product_type":"c1","uid":1115033,"ip_address":"上海","ucode":"494E9FBA0648D4","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/99/d7737b19.jpg","comment_is_top":false,"comment_ctime":1703426047,"is_pvip":false,"replies":[{"id":140596,"content":"也是可以的，但是jdk线程池不是很适合，所以Tomcat采用了这个方式（有人也有类似问题，见别的解答）。对我个人来说，是忠于Tomcat的原始实现，以后学习者读到Tomcat这一段源代码的时候不会觉得难以理解。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703487671,"ip_address":"广东","comment_id":385810,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"这里面线程同步机制需要这样写么？ 直接参考线程池的设计，用一个阻塞队列是不是就可以了？ 本质上还是一个生产和消费的模型吧","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634421,"discussion_content":"也是可以的，但是jdk线程池不是很适合，所以Tomcat采用了这个方式（有人也有类似问题，见别的解答）。对我个人来说，是忠于Tomcat的原始实现，以后学习者读到Tomcat这一段源代码的时候不会觉得难以理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703487671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385551,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1702901504,"is_pvip":false,"replies":[{"id":140538,"content":"都是好问题。notifyall会唤醒全部，但是代码中一旦标志不符合就会继续等待，不会出现几个同时处理，你仔细跟代码。recycle我也认为会出现并发问题，你这个观察很好，这段代码取自Tomcat4源代码，应该是有问题。 线程池大小，很复杂，大师们有个公式，依赖于核还有计算时间等待时间，但是实际系统复杂，很不好估算计算时间等待时间，并且还有别的进程共用CPU，所以呢，不好回答，我一般拍脑袋就是讲线程池大小设置为核的数量。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703033885,"ip_address":"安徽","comment_id":385551,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：用notifyAll唤醒所有线程，不对吧。\n假如有5个线程，connector同时启动这5个线程，5个线程处于wait状态。假设此时来了一个连接请求，由其中的一个线程A处理，那么，connector应该只唤醒这线程A吧。用notifyall会唤醒全部5个线程，难道5个线程处理同一个请求吗？\n\nQ2：recycle方法有多线程问题吗？\n假设有5个线程在处理5个请求，这5个线程都会调用recycle方法，此时会存在并发问题吗？\nQ3：线程池的大小一般为多大？\n有经验公式吗？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634127,"discussion_content":"都是好问题。notifyall会唤醒全部，但是代码中一旦标志不符合就会继续等待，不会出现几个同时处理，你仔细跟代码。recycle我也认为会出现并发问题，你这个观察很好，这段代码取自Tomcat4源代码，应该是有问题。 线程池大小，很复杂，大师们有个公式，依赖于核还有计算时间等待时间，但是实际系统复杂，很不好估算计算时间等待时间，并且还有别的进程共用CPU，所以呢，不好回答，我一般拍脑袋就是讲线程池大小设置为核的数量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703033885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"安徽","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2704281,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kgFgg4b6yribq8tSqAht0383fzoGSG9COPiaicLMzbdouGBrtJehiboqnJbbAiaNEtib1wYM9wAlAvCTZFUfYQDaElBA/132","nickname":"Geek_ac5e30","note":"","ucode":"D8349339D63A10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639155,"discussion_content":"这里 notifyAll 和 notify 没区别的，因为锁住的只有两个线程，一个 processor 一个 connector ， 这就是 one to one 的场景","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1710333154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283181,"avatar":"https://static001.geekbang.org/account/avatar/00/13/94/6d/5cd6e8c7.jpg","nickname":"张贺","note":"","ucode":"0254E40FB3EB5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634087,"discussion_content":"回答一下 Q1: 这里每个 processor 对象是一个线程，wait 阻塞是在 synchronized 方法中，也就是 在这个对象锁的等待队列中，这个等待队列中只有这一个线程，所以 notifyall 也只会通知给一个线程。可以参考 java 并发编程实战第六课。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1702982785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1444698,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","nickname":"C.","note":"","ucode":"5AE269220EFD73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634043,"discussion_content":"回答一下Q3：\n线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）\n平均工作时间 = 执行任务时间-所有的等待时间\n- 线程的平均工作时间所占比例越高，就需要越少的线程；\n- 线程的平均等待时间所占比例越高，就需要越多的线程；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702954905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388350,"user_name":"无心","can_delete":false,"product_type":"c1","uid":1405943,"ip_address":"广东","ucode":"81CEB9F80C4675","user_header":"https://static001.geekbang.org/account/avatar/00/15/73/f7/d7581b65.jpg","comment_is_top":false,"comment_ctime":1709975568,"is_pvip":false,"replies":[{"id":141412,"content":"没反。就是一个闸门，控制两边。看你从哪面去看这个问题。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1710131643,"ip_address":"澳大利亚","comment_id":388350,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"avaliable的 ture 和 false 语意是不是反了","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":638934,"discussion_content":"没反。就是一个闸门，控制两边。看你从哪面去看这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710131643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2683430,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","nickname":"听风有信","note":"","ucode":"2CCB467114FF5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654031,"discussion_content":"表示是否有 socket 在用。不是 processor 是否可用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731723026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387188,"user_name":"Geek_b7bd01","can_delete":false,"product_type":"c1","uid":2438512,"ip_address":"广东","ucode":"5585AF0A3D1797","user_header":"","comment_is_top":false,"comment_ctime":1706682098,"is_pvip":false,"replies":[{"id":141130,"content":"直接丢给processor不行，生产者消费者之间要同步。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1706919320,"ip_address":"澳大利亚","comment_id":387188,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"为什么connector调用processor.assign()方法，这样不会导致connector线程进行等待吗？为何不直接将任务丢给processor。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636767,"discussion_content":"直接丢给processor不行，生产者消费者之间要同步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706919320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2292255,"avatar":"","nickname":"TKF","note":"","ucode":"167E911262E166","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636823,"discussion_content":"你能拿到processor只会有两种，一种是没处理过请求的，一种是处理过请求又还回queue里面的，不管是哪种，它本身都是阻塞在await方法上的，available变量肯定为false，调用它的assign方法并不会导致connnector等待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1707095990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387187,"user_name":"Geek_b7bd01","can_delete":false,"product_type":"c1","uid":2438512,"ip_address":"广东","ucode":"5585AF0A3D1797","user_header":"","comment_is_top":false,"comment_ctime":1706681978,"is_pvip":false,"replies":[{"id":141129,"content":"并不会等processor执行完，那就成了串行了。互锁机制解决生产者消费者同步问题。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1706919269,"ip_address":"澳大利亚","comment_id":387187,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"这样connector不是必须得等待processor执行完成之后才能继续往下走吗，不影响效率吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636766,"discussion_content":"并不会等processor执行完，那就成了串行了。互锁机制解决生产者消费者同步问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706919269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385806,"user_name":"ctt","can_delete":false,"product_type":"c1","uid":1126661,"ip_address":"广东","ucode":"FA87B9E86FD308","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/05/9028e9ac.jpg","comment_is_top":false,"comment_ctime":1703415283,"is_pvip":false,"replies":[{"id":140595,"content":"因为本质上是需要拿出一个processor.只是没有的时候会临时新建一个。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703487395,"ip_address":"广东","comment_id":385806,"utype":1}],"discussion_count":1,"race_medal":1,"score":2,"product_id":100636401,"comment_content":" HttpProcessor initprocessor = new HttpProcessor();       \n processors.push(initprocessor);        \ncurProcessors++;        \nreturn ((HttpProcessor) processors.pop());    请问这段代码为什么push完就立即pop了呢","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634420,"discussion_content":"因为本质上是需要拿出一个processor.只是没有的时候会临时新建一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703487395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385582,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1702951196,"is_pvip":false,"replies":[{"id":140509,"content":"你的理解原则上是正确的。具体一点，jdk线程池标准模式当核心线程数超过后直接进队列，不是新建线程，这个方式不适合io型多任务。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702969652,"ip_address":"北京","comment_id":385582,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"Tomcat 为什么用一个简单的 queue 来实现多线程而不是用 JDK 自带的线程池？\n1.自定义可以更好地控制，还有后期的优化\n2.历史原因，可能当时内置线程池功能没那么完善\n现在，应该也支持使用JDK自带的线程池\n\n交个作业：https:&#47;&#47;github.com&#47;caozhenyuan&#47;mini-tomcat","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634073,"discussion_content":"你的理解原则上是正确的。具体一点，jdk线程池标准模式当核心线程数超过后直接进队列，不是新建线程，这个方式不适合io型多任务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702969653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2737559,"avatar":"https://static001.geekbang.org/account/avatar/00/29/c5/97/f043fb42.jpg","nickname":"Michael","note":"","ucode":"B296AE51768236","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646909,"discussion_content":"如果在使用 JDK 线程池时，把 corePoolSize 设置成跟 maxPoolSize 相等，是不是就可以使用了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1718972310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385515,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1702871395,"is_pvip":false,"replies":[{"id":140507,"content":"简单来讲，jdk线程池使用普通队列，当并发任务数超过了核心大小后，直接进队列等待，这种方式比较适合CPU型多任务。但是servlet的应用场景是io型的，所以Tomcat要自己实现。我们也可以比较简单地重写jdk队列的offer方法，数量没有达到最大线程数就返回false，让线程池新建线程。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1702969218,"ip_address":"北京","comment_id":385515,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100636401,"comment_content":"🌝🌝自带JDK线程池初始化指定线程数， 共用这些线程， 可能这次在A线程执行， 下次在B线程执行，上下文切来切去造成性能不必要的开销，在网络中这点开销算是很大了。 只能想到这个点，不知道是否正确","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634071,"discussion_content":"简单来讲，jdk线程池使用普通队列，当并发任务数超过了核心大小后，直接进队列等待，这种方式比较适合CPU型多任务。但是servlet的应用场景是io型的，所以Tomcat要自己实现。我们也可以比较简单地重写jdk队列的offer方法，数量没有达到最大线程数就返回false，让线程池新建线程。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1702969218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391710,"user_name":"小树","can_delete":false,"product_type":"c1","uid":1293569,"ip_address":"福建","ucode":"EB7656849D8F6C","user_header":"https://static001.geekbang.org/account/avatar/00/13/bd/01/9c6482df.jpg","comment_is_top":false,"comment_ctime":1718876309,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100636401,"comment_content":"想请教一下老师，实际上是不是不会有 “如果available标志为 true，Connetor 线程就继续死等”这个情况呢。\n因为每个processor线程的available初始是false的，等connector接收了新连接、assign了socket、更新了available变量以后，processor才能执行；processor执行完了以后这个processor也就被回收了，又进入了新一轮的上述过程。\n所以我觉得，好像永远是各个processor等待connector来执行assign，而connector实际并没有机会进入到assign里的wait()的部分？","like_count":1,"discussions":[{"author":{"id":3790749,"avatar":"https://static001.geekbang.org/account/avatar/00/39/d7/9d/73390cc0.jpg","nickname":"wild wings.Luv","note":"","ucode":"D76D40B24B4998","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651047,"discussion_content":"同问，前面在创建processor时已经保证processor是空闲状态的了，我不是很理解同步机制的作用在哪里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726127321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394212,"user_name":"wild wings.Luv","can_delete":false,"product_type":"c1","uid":3790749,"ip_address":"广东","ucode":"D76D40B24B4998","user_header":"https://static001.geekbang.org/account/avatar/00/39/d7/9d/73390cc0.jpg","comment_is_top":false,"comment_ctime":1726127077,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100636401,"comment_content":"老师您好，看了您的文章收获满满。其中关于并发处理请求的架构我有一些问题。由于connector和processor是一对多的关系，所以每个processor要单独维护自己的信号，connector在分配socket时，调用processor的同步块assign。但是这个同步这里的代码我好像不是很理解。connector和processor之间实际上没有”同步的生产消费关系“：首先，createProcessor处有空余的processor时才会分配给connector，所以connector并不需要等待某个processor消费完了再给他socket，当没有空余的processor时直接放弃处理（这里也是我觉得设计的不足之处）。其次，processor中的同步块也并不是等待processor处理完请求释放socket之后，才把状态设置为false，而是拿到socket之后就马上更改状态。这样做的目的我不是很清楚，也就是这样的同步机制，我没有理解到它的用处。","like_count":0},{"had_liked":false,"id":394187,"user_name":"符方继","can_delete":false,"product_type":"c1","uid":3956001,"ip_address":"广东","ucode":"B098BE802D2117","user_header":"https://static001.geekbang.org/account/avatar/00/3c/5d/21/afbecbd3.jpg","comment_is_top":false,"comment_ctime":1726066866,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100636401,"comment_content":"@Override public void run() { \nwhile (true) { \n                &#47;&#47; 等待分配下一个 \n               socket Socket socket = await(); \n               if (socket == null) continue; \n               &#47;&#47; 处理来自这个socket的请求 process(socket);\n              &#47;&#47; 完成此请求 connector.recycle(this); \n} \n}\n在高并发的情况下，是否要对socket的outputStream互斥？如果一个socket发送多个请求，每个线程都返回数据是否会出现粘包、数据错误等问题？\n","like_count":0},{"had_liked":false,"id":392796,"user_name":"__Alucard","can_delete":false,"product_type":"c1","uid":2625245,"ip_address":"浙江","ucode":"8766ECCC8C7283","user_header":"https://static001.geekbang.org/account/avatar/00/28/0e/dd/4d468ad7.jpg","comment_is_top":false,"comment_ctime":1721805144,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100636401,"comment_content":"1.JDK线程池使用的阻塞队列BlockingQueue是单向队列，不支持双端操作，而Tomcat使用了Deque作为双端队列来优先使用旧的线程，平衡线程间的工作负载。\n2.JDK线程池的工作队列机制不适合作为WebServer容器来处理IO请求。\n3.事实上到这一节已经出现了经典的通信模型的设计： 单线程(多协程，IO操作上下文开销小)处理IO操作，多线程处理后续的业务逻辑，Netty也参考了这种设计。","like_count":0},{"had_liked":false,"id":391811,"user_name":"chang","can_delete":false,"product_type":"c1","uid":1158800,"ip_address":"浙江","ucode":"54CF3B7BC85297","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/90/83e0d28d.jpg","comment_is_top":false,"comment_ctime":1719146174,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100636401,"comment_content":"void recycle(HttpProcessor processor) {\n        processors.push(processor);\n    }\n这里应该加下synchronized，可能多个线程处理完同时归还","like_count":0}]}