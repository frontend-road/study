{"id":118322,"title":"11 | 如何实现高性能的异步网络传输？","content":"<p>你好，我是李玥。上一节课我们学习了异步的线程模型，异步与同步模型最大的区别是，同步模型会阻塞线程等待资源，而异步模型不会阻塞线程，它是等资源准备好后，再通知业务代码来完成后续的资源处理逻辑。这种异步设计的方法，可以很好地解决IO等待的问题。</p><p>我们开发的绝大多数业务系统，都是IO密集型系统。跟IO密集型系统相对的另一种系统叫计算密集型系统。通过这两种系统的名字，估计你也能大概猜出来IO密集型系统是什么意思。</p><p>IO密集型系统大部分时间都在执行IO操作，这个IO操作主要包括网络IO和磁盘IO，以及与计算机连接的一些外围设备的访问。与之相对的计算密集型系统，大部分时间都是在使用CPU执行计算操作。我们开发的业务系统，很少有非常耗时的计算，更多的是网络收发数据，读写磁盘和数据库这些IO操作。这样的系统基本上都是IO密集型系统，特别适合使用异步的设计来提升系统性能。</p><p>应用程序最常使用的IO资源，主要包括磁盘IO和网络IO。由于现在的SSD的速度越来越快，对于本地磁盘的读写，异步的意义越来越小。所以，使用异步设计的方法来提升IO性能，我们更加需要关注的问题是，如何来实现高性能的异步网络传输。</p><p>今天，咱们就来聊一聊这个话题。</p><!-- [[[read_end]]] --><h2>理想的异步网络框架应该是什么样的？</h2><p>在我们开发的程序中，如果要实现通过网络来传输数据，需要用到开发语言提供的网络通信类库。大部分语言提供的网络通信基础类库都是同步的。一个TCP连接建立后，用户代码会获得一个用于收发数据的通道，每个通道会在内存中开辟两片区域用于收发数据的缓存。</p><p>发送数据的过程比较简单，我们直接往这个通道里面来写入数据就可以了。用户代码在发送时写入的数据会暂存在缓存中，然后操作系统会通过网卡，把发送缓存中的数据传输到对端的服务器上。</p><p>只要这个缓存不满，或者说，我们发送数据的速度没有超过网卡传输速度的上限，那这个发送数据的操作耗时，只不过是一次内存写入的时间，这个时间是非常快的。所以，<strong>发送数据的时候同步发送就可以了，没有必要异步。</strong></p><p>比较麻烦的是接收数据。对于数据的接收方来说，它并不知道什么时候会收到数据。那我们能直接想到的方法就是，用一个线程阻塞在那儿等着数据，当有数据到来的时候，操作系统会先把数据写入接收缓存，然后给接收数据的线程发一个通知，线程收到通知后结束等待，开始读取数据。处理完这一批数据后，继续阻塞等待下一批数据到来，这样周而复始地处理收到的数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/b2/4c94c5e1e437ac087ef3b50acf8dceb2.jpg?wh=3888*1493\" alt=\"\"><br>\n这就是同步网络IO的模型。同步网络IO模型在处理少量连接的时候，是没有问题的。但是如果要同时处理非常多的连接，同步的网络IO模型就有点儿力不从心了。</p><p>因为，每个连接都需要阻塞一个线程来等待数据，大量的连接数就会需要相同数量的数据接收线程。当这些TCP连接都在进行数据收发的时候，会导致什么情况呢？对，会有大量的线程来抢占CPU时间，造成频繁的CPU上下文切换，导致CPU的负载升高，整个系统的性能就会比较慢。</p><p>所以，我们需要使用异步的模型来解决网络IO问题。怎么解决呢？</p><p><strong>你可以先抛开你知道的各种语言的异步类库和各种异步的网络IO框架，想一想，对于业务开发者来说，一个好的异步网络框架，它的API应该是什么样的呢？</strong></p><p>我们希望达到的效果，无非就是，只用少量的线程就能处理大量的连接，有数据到来的时候能第一时间处理就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/49/d6/49ca88d34fc5c4815d20189770cf76d6.jpg?wh=4363*2640\" alt=\"\"></p><p>对于开发者来说，最简单的方式就是，事先定义好收到数据后的处理逻辑，把这个处理逻辑作为一个回调方法，在连接建立前就通过框架提供的API设置好。当收到数据的时候，由框架自动来执行这个回调方法就好了。</p><p>实际上，有没有这么简单的框架呢？</p><h2>使用Netty来实现异步网络通信</h2><p>在Java中，大名鼎鼎的Netty框架的API设计就是这样的。接下来我们看一下如何使用Netty实现异步接收数据。</p><pre><code>// 创建一组线性\nEventLoopGroup group = new NioEventLoopGroup();\n\ntry{\n    // 初始化Server\n    ServerBootstrap serverBootstrap = new ServerBootstrap();\n    serverBootstrap.group(group);\n    serverBootstrap.channel(NioServerSocketChannel.class);\n    serverBootstrap.localAddress(new InetSocketAddress(&quot;localhost&quot;, 9999));\n\n    // 设置收到数据后的处理的Handler\n    serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {\n        protected void initChannel(SocketChannel socketChannel) throws Exception {\n            socketChannel.pipeline().addLast(new MyHandler());\n        }\n    });\n    // 绑定端口，开始提供服务\n    ChannelFuture channelFuture = serverBootstrap.bind().sync();\n    channelFuture.channel().closeFuture().sync();\n} catch(Exception e){\n    e.printStackTrace();\n} finally {\n    group.shutdownGracefully().sync();\n}\n</code></pre><p>这段代码它的功能非常简单，就是在本地9999端口，启动了一个Socket Server来接收数据。我带你一起来看一下这段代码：</p><ol>\n<li>首先我们创建了一个EventLoopGroup对象，命名为group，这个group对象你可以简单把它理解为一组线程。这组线程的作用就是来执行收发数据的业务逻辑。</li>\n<li>然后，使用Netty提供的ServerBootstrap来初始化一个Socket Server，绑定到本地9999端口上。</li>\n<li>在真正启动服务之前，我们给serverBootstrap传入了一个MyHandler对象，这个MyHandler是我们自己来实现的一个类，它需要继承Netty提供的一个抽象类：ChannelInboundHandlerAdapter，在这个MyHandler里面，我们可以定义收到数据后的处理逻辑。这个设置Handler的过程，就是我刚刚讲的，预先来定义回调方法的过程。</li>\n<li>最后就可以真正绑定本地端口，启动Socket服务了。</li>\n</ol><p>服务启动后，如果有客户端来请求连接，Netty会自动接受并创建一个Socket连接。你可以看到，我们的代码中，并没有像一些同步网络框架中那样，需要用户调用Accept()方法来接受创建连接的情况，在Netty中，这个过程是自动的。</p><p>当收到来自客户端的数据后，Netty就会在我们第一行提供的EventLoopGroup对象中，获取一个IO线程，在这个IO线程中调用接收数据的回调方法，来执行接收数据的业务逻辑，在这个例子中，就是我们传入的MyHandler中的方法。</p><p>Netty本身它是一个全异步的设计，我们上节课刚刚讲过，异步设计会带来额外的复杂度，所以这个例子的代码看起来会比较多，比较复杂。但是你看，其实它提供了一组非常友好API。</p><p>真正需要业务代码来实现的就两个部分：一个是把服务初始化并启动起来，还有就是，实现收发消息的业务逻辑MyHandler。而像线程控制、缓存管理、连接管理这些异步网络IO中通用的、比较复杂的问题，Netty已经自动帮你处理好了，有没有感觉很贴心？所以，非常多的开源项目使用Netty作为其底层的网络IO框架，并不是没有原因的。</p><p>在这种设计中，Netty自己维护一组线程来执行数据收发的业务逻辑。如果说，你的业务需要更灵活的实现，自己来维护收发数据的线程，可以选择更加底层的Java NIO。其实，Netty也是基于NIO来实现的。</p><h2>使用NIO来实现异步网络通信</h2><p>在Java的NIO中，它提供了一个Selector对象，来解决一个线程在多个网络连接上的多路复用问题。什么意思呢？在NIO中，每个已经建立好的连接用一个Channel对象来表示。我们希望能实现，在一个线程里，接收来自多个Channel的数据。也就是说，这些Channel中，任何一个Channel收到数据后，第一时间能在同一个线程里面来处理。</p><p>我们可以想一下，一个线程对应多个Channel，有可能会出现这两种情况：</p><ol>\n<li>线程在忙着处理收到的数据，这时候Channel中又收到了新数据；</li>\n<li>线程闲着没事儿干，所有的Channel中都没收到数据，也不能确定哪个Channel会在什么时候收到数据。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/a8/50/a8bb4e812db8601d54933771f3614350.jpg?wh=4428*2665\" alt=\"\"></p><p>Selecor通过一种类似于事件的机制来解决这个问题。首先你需要把你的连接，也就是Channel绑定到Selector上，然后你可以在接收数据的线程来调用Selector.select()方法来等待数据到来。这个select方法是一个阻塞方法，这个线程会一直卡在这儿，直到这些Channel中的任意一个有数据到来，就会结束等待返回数据。它的返回值是一个迭代器，你可以从这个迭代器里面获取所有Channel收到的数据，然后来执行你的数据接收的业务逻辑。</p><p>你可以选择直接在这个线程里面来执行接收数据的业务逻辑，也可以将任务分发给其他的线程来执行，如何选择完全可以由你的代码来控制。</p><h2>小结</h2><p>传统的同步网络IO，一般采用的都是一个线程对应一个Channel接收数据，很难支持高并发和高吞吐量。这个时候，我们需要使用异步的网络IO框架来解决问题。</p><p>然后我讲了Netty和NIO这两种异步网络框架的API和它们的使用方法。这里面，你需要体会一下这两种框架在API设计方面的差异。Netty自动地解决了线程控制、缓存管理、连接管理这些问题，用户只需要实现对应的Handler来处理收到的数据即可。而NIO是更加底层的API，它提供了Selector机制，用单个线程同时管理多个连接，解决了多路复用这个异步网络通信的核心问题。</p><h2>思考题</h2><p>刚刚我们提到过，Netty本身就是基于NIO的API来实现的。课后，你可以想一下，针对接收数据这个流程，Netty它是如何用NIO来实现的呢？欢迎在留言区与我分享讨论。</p><p>感谢阅读，如果你觉得这篇文章对你有一些启发，也欢迎把它分享给你的朋友。</p><p></p>","neighbors":{"left":{"article_title":"10 | 如何使用异步设计提升系统性能？","id":117272},"right":{"article_title":"12 | 序列化与反序列化：如何通过网络传输结构化的数据？","id":118848}},"comments":[{"had_liked":false,"id":124391,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1565875469,"is_pvip":false,"replies":[{"id":45726,"content":"这个比喻非常赞👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565918235,"ip_address":"","comment_id":124391,"utype":1}],"discussion_count":10,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"关于JAVA的网络，之前有个比喻形式的总结，分享给大家：\n例子：有一个养鸡的农场，里面养着来自各个农户（Thread）的鸡（Socket），每家农户都在农场中建立了自己的鸡舍（SocketChannel）\n1、BIO：Block IO，每个农户盯着自己的鸡舍，一旦有鸡下蛋，就去做捡蛋处理；\n2、NIO：No-Block IO-单Selector，农户们花钱请了一个饲养员（Selector），并告诉饲养员（register）如果哪家的鸡有任何情况（下蛋）均要向这家农户报告（select keys）；\n3、NIO：No-Block IO-多Selector，当农场中的鸡舍逐渐增多时，一个饲养员巡视（轮询）一次所需时间就会不断地加长，这样农户知道自己家的鸡有下蛋的情况就会发生较大的延迟。怎么解决呢？没错，多请几个饲养员（多Selector），每个饲养员分配管理鸡舍，这样就可以减轻一个饲养员的工作量，同时农户们可以更快的知晓自己家的鸡是否下蛋了；\n4、Epoll模式：如果采用Epoll方式，农场问题应该如何改进呢？其实就是饲养员不需要再巡视鸡舍，而是听到哪间鸡舍的鸡打鸣了（活跃连接），就知道哪家农户的鸡下蛋了；\n5、AIO：Asynchronous I&#47;O, 鸡下蛋后，以前的NIO方式要求饲养员通知农户去取蛋，AIO模式出现以后，事情变得更加简单了，取蛋工作由饲养员自己负责，然后取完后，直接通知农户来拿即可，而不需要农户自己到鸡舍去取蛋。","like_count":298},{"had_liked":false,"id":126880,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566515490,"is_pvip":false,"replies":[{"id":46940,"content":"感谢你的建议！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566523098,"ip_address":"","comment_id":126880,"utype":1}],"discussion_count":7,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"课后思考及建议\n没有对比就没有伤害，尤其对于学习，对比一下就知道那个课程优秀，那个更优秀。\n\n首先，我觉得如何实现高性能的网络通信，是必须要讲的，这个原理是脱离具体语言的，和什么实现框架也没什么关系。\n不过篇幅有限老师只能讲解一下她的精髓，如果想一点点弄明白，建议看看李林峰大哥的《netty权威指南(第二版)》她用了三章来讲解网络通信模型的演进。\n另外，我同时在学kafka的专栏，我发现一个现象，两位老师都没有先将一个消息的全生命历程先细致的讲一下，学习过丁奇老师的MySQL，他上来就讲解了一下一个SQL语句是怎么执行的。我觉得很有整体感，知道整个过程之后其实下面再细致的讲解都是性能优化的事情啦！\n我猜想其他各种系统，尤其是和数据打交道的都类似，只要一个完整的流程知道了，下面好多知识都是在为这个系统的性能、健壮性、高可用性、自身的其他特性在加强。\n所以，我提过这样的问题，也建议先讲一下一条消息从发送到接收都经历了那些关键环节或组件，对一条消息的全生命历程有个整体的认识。然后再讲每个关键环节为什么这么实现，其性能最佳吞吐量最高。然后再讲各个组件是怎么紧密配合的，如果我知道一个软件是什么？又清楚他由什么组成？每一部分为什么如此设计？那些设计是通用的那些设计比较独特？我觉得我就理解了这个软件\n老师的课程非常优秀，哈哈，我觉得听了我的建议还可以再优秀一点点\n","like_count":64,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464221,"discussion_content":"感谢你的建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566523098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073596,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/bc/88a905a5.jpg","nickname":"亮点","note":"","ucode":"1B8AE07484C69A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625020,"discussion_content":"感觉什么都说了，又什么都没说，停留在表层，不适合想进阶的人","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1691203784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5939,"discussion_content":"不妥之处还请见谅😀","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566543137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47748,"discussion_content":"netty权威指南感觉内容拖沓，对核心关键点又有点隔靴挠痒。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573400605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020492,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/4c/40783447.jpg","nickname":"何骧","note":"","ucode":"11DCC74CE2F300","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297145,"discussion_content":"有什么推荐吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596786809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47748,"ip_address":"","group_id":0},"score":297145,"extra":""},{"author":{"id":1879262,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ac/de/68f35320.jpg","nickname":"小来子","note":"","ucode":"4EDAF31E43B211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380933,"discussion_content":"这门课程也有点了。感觉不紧凑，可能是叙述方式的问题。   尤其是读到这节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624803422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47748,"ip_address":"","group_id":0},"score":380933,"extra":""}]},{"author":{"id":1499730,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erQ5LXNgaZ3ReArPrY4YeT5mNVtBpiazFEQzNuUXxzdLOWtMliaGicNCpjaOezRISARHXPibkA4ACgib1g/132","nickname":"JensonYao","note":"","ucode":"D4A9765F1112BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649851,"discussion_content":"这个全局性思路很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724056103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124126,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1565829407,"is_pvip":false,"replies":[{"id":45720,"content":"我们还是需要一个例子能让大家理解异步网络传输的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565917323,"ip_address":"","comment_id":124126,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"多回到队列上来吧。Netty几乎很多Java课都会讲到。。。","like_count":25,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463022,"discussion_content":"我们还是需要一个例子能让大家理解异步网络传输的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565917323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1879262,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ac/de/68f35320.jpg","nickname":"小来子","note":"","ucode":"4EDAF31E43B211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380934,"discussion_content":"赞同 这节课实属有点摸不着头脑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624803450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488038,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","nickname":"渠梁","note":"","ucode":"DC86BDEC63C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299311,"discussion_content":"netty不是异步吧\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597652674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2045627,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/36/bb/67d689c5.jpg","nickname":"一颗小橘子🍊","note":"","ucode":"584557A3E26B33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1488038,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","nickname":"渠梁","note":"","ucode":"DC86BDEC63C9BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377230,"discussion_content":"加1 netty应该是同步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622555420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299311,"ip_address":"","group_id":0},"score":377230,"extra":""},{"author":{"id":1053772,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/4c/c581813b.jpg","nickname":"中学生","note":"","ucode":"C9B9FB6DBFC628","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2045627,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/36/bb/67d689c5.jpg","nickname":"一颗小橘子🍊","note":"","ucode":"584557A3E26B33","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385391,"discussion_content":"Netty is an asynchronous event-driven network application framework...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627025645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377230,"ip_address":"","group_id":0},"score":385391,"extra":""}]}]},{"had_liked":false,"id":208460,"user_name":"喜欢地球的阿培同学","can_delete":false,"product_type":"c1","uid":1361746,"ip_address":"","ucode":"5F97037585F857","user_header":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","comment_is_top":false,"comment_ctime":1587364194,"is_pvip":false,"replies":[{"id":78331,"content":"方法在阻塞时，你要区分它的线程状态，如果是你说的等待锁，那线程的状态是waiting，是不会申请cpu时间片的，那就不会上下文切换。\n\n如果是这个方法呢：\n\nvoid blockMethod() {\n    while(....) {doSomeThing();}\n}\n\n对于这个调用者看来，也是阻塞在这个调用这个blockMethod方法上了，但是线程是RUNNING状态，这个时候肯定是要申请CPU时间片的。\n\nSelector.select()在阻塞时，它的内部实现根据操作系统和epoll的配置不同，实际上有好几种实现，不同的实现行为也不一样。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1587694603,"ip_address":"","comment_id":208460,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师您好，我上周问了你2个问题。 分别在第17讲和第11讲\n\n第一个问题: 一个是100个线程，1个线程在运行，99个线程在阻塞(等待锁释放)，会不会造成线程频繁上下文切换。你回答的是不会。\n\n第二个问题: 我又问了一个 Selector.select()方法是一个阻塞方法，这个线程会一直卡在这儿。你的回答我理解过后是会造成线程上下文切换\n\n那为什么第一个问题不会造成线程上下文频繁切换呢？ 是因为底层操作系统的原因吗？ 而普通的socket连接阻塞，是会造成线程上下文切换？","like_count":15,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463022,"discussion_content":"我们还是需要一个例子能让大家理解异步网络传输的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565917323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1879262,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ac/de/68f35320.jpg","nickname":"小来子","note":"","ucode":"4EDAF31E43B211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380934,"discussion_content":"赞同 这节课实属有点摸不着头脑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624803450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488038,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","nickname":"渠梁","note":"","ucode":"DC86BDEC63C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299311,"discussion_content":"netty不是异步吧\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597652674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2045627,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/36/bb/67d689c5.jpg","nickname":"一颗小橘子🍊","note":"","ucode":"584557A3E26B33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1488038,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","nickname":"渠梁","note":"","ucode":"DC86BDEC63C9BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377230,"discussion_content":"加1 netty应该是同步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622555420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299311,"ip_address":"","group_id":0},"score":377230,"extra":""},{"author":{"id":1053772,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/4c/c581813b.jpg","nickname":"中学生","note":"","ucode":"C9B9FB6DBFC628","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2045627,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/36/bb/67d689c5.jpg","nickname":"一颗小橘子🍊","note":"","ucode":"584557A3E26B33","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385391,"discussion_content":"Netty is an asynchronous event-driven network application framework...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627025645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377230,"ip_address":"","group_id":0},"score":385391,"extra":""}]}]},{"had_liked":false,"id":207199,"user_name":"喜欢地球的阿培同学","can_delete":false,"product_type":"c1","uid":1361746,"ip_address":"","ucode":"5F97037585F857","user_header":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","comment_is_top":false,"comment_ctime":1587022669,"is_pvip":false,"replies":[{"id":77853,"content":"Selector本身是阻塞的，但它只需要阻塞一个线程，就可以等待多个socket连接，任何一个连接有数据进来就会解除阻塞。这就是所谓的“多路复用”。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1587353197,"ip_address":"","comment_id":207199,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"最后文中有一段话: &quot;Selecor 通过一种类似于事件的机制来解决这个问题。首先你需要把你的连接，也就是 Channel 绑定到 Selector 上，然后你可以在接收数据的线程来调用 Selector.select() 方法来等待数据到来。这个 select 方法是一个阻塞方法，这个线程会一直卡在这儿，直到这些 Channel 中的任意一个有数据到来，就会结束等待返回数据。&quot;\n\n这个 select 方法是一个阻塞方法，这个线程会一直卡在这儿，岂不是和上篇文章的同步转账类似，该线程会处于等待状态，无法充分利用cpu资源。","like_count":9,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492464,"discussion_content":"方法在阻塞时，你要区分它的线程状态，如果是你说的等待锁，那线程的状态是waiting，是不会申请cpu时间片的，那就不会上下文切换。\n\n如果是这个方法呢：\n\nvoid blockMethod() {\n    while(....) {doSomeThing();}\n}\n\n对于这个调用者看来，也是阻塞在这个调用这个blockMethod方法上了，但是线程是RUNNING状态，这个时候肯定是要申请CPU时间片的。\n\nSelector.select()在阻塞时，它的内部实现根据操作系统和epoll的配置不同，实际上有好几种实现，不同的实现行为也不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587694603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216040,"user_name":"青禾qingh","can_delete":false,"product_type":"c1","uid":1651441,"ip_address":"","ucode":"453FC435B03790","user_header":"https://static001.geekbang.org/account/avatar/00/19/32/f1/fd24d52b.jpg","comment_is_top":false,"comment_ctime":1589173007,"is_pvip":false,"replies":[{"id":80342,"content":"严格来说，是这样的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589462991,"ip_address":"","comment_id":216040,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，nio不是异步的吧，我理解是同步非阻塞的，当然非阻塞也仅仅是指读写数据的时候，select也是阻塞的，我理解aio才是异步的","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492036,"discussion_content":"Selector本身是阻塞的，但它只需要阻塞一个线程，就可以等待多个socket连接，任何一个连接有数据进来就会解除阻塞。这就是所谓的“多路复用”。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587353197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330527,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8f/9f/0767e5a5.jpg","nickname":"流云","note":"","ucode":"4DA4CE36520724","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384894,"discussion_content":"老师，这种“多路复用”会不会出现在同一个时间点同时两个数据被送过来，这两个数据又是如何处理的呢，还是说selector内部实际上是一个类似时分复用的机制，就可以很好地解决这种场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626785071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124082,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1565816132,"is_pvip":false,"replies":[{"id":45717,"content":"放心，我们这门课使用的任何语言都不会特别深入，更多的是讲实现原理，语言只是讲解和举例的载体。\n\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565917162,"ip_address":"","comment_id":124082,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"Java基础太差：几乎不懂；故而其实本课程学习让我觉得越多Java相关的非常吃力，希望老师后面的课程里面纯Java的东西能浅一点或者告知Java的理解大概要什么水平。\n刘超老师的趣谈linux在跟着学、张磊的深入剖析Kubernetes目前学了一遍。我想从用这种方式去理解或解释不知道原理是否类似正确吧：希望老师提点或者下堂课时解答。\n其实Netty基于NIO就像Kubernetes其实是基于Cgroup和Namespace一样：其实Netty是使用了NIO的Selecor去处理线程的异步机制，Netty在它的基础上去优化了其线程控制和连接管理并追加了缓存管理，请老师指正；谢谢。\n努力跟着学习，努力跟着做题；希望完课的时候能从另外一个高度&#47;层次去理解和使用消息队列。","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494650,"discussion_content":"严格来说，是这样的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589462991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3021110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cjichzNjhghHD9DJEXCBrh1PqmmlfBwC84NKbn9obLYEGCBDiaqufEArL26Qy0YiaibVbhcnYON7oqh7v6HgCjmk3g/132","nickname":"Geek_eca226","note":"","ucode":"E738A5618F3218","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581109,"discussion_content":"那面试说netty异步会被面试官diss吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658499871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555560,"discussion_content":"你好，关于同步非阻塞能具体展开讲讲吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646973879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3585239,"avatar":"","nickname":"Geek_fc724d","note":"","ucode":"684ACFE9CBBD8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612595,"discussion_content":"同步就是发送一个请求，这个线程在那里等着占用cpu也不往下执行，同步非阻塞就是发一个请求不往下执行但是会让出cpu时间片。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680792961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":555560,"ip_address":"江苏","group_id":0},"score":612595,"extra":""}]}]},{"had_liked":false,"id":124220,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1565836792,"is_pvip":false,"replies":[{"id":45722,"content":"你说的这个问题是有可能出现的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565917566,"ip_address":"","comment_id":124220,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，以下是我的理解：异步网络框架中，通过线程池处理接收消息的情况，和同步相比，好处在于，同步框架下，一个连接必须有两个线程（等数据的线程、处理数据的线程），当连接过多时会有大量频繁的上下文切换；而异步框架利用线程池接管了（等数据的线程）的作用，减少了上下文切换、线程的创建销毁的开销；\n问题是：虽然线程池完成了数据接收的功能，但加入消息发送方发来了大量的消息，因为线程池的线程数量毕竟是有限的，此时是否就会出现消息不能及时转发给数据处理线程的情况呢？","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463000,"discussion_content":"放心，我们这门课使用的任何语言都不会特别深入，更多的是讲实现原理，语言只是讲解和举例的载体。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565917162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217997,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1589690280,"is_pvip":false,"replies":[{"id":80845,"content":"是的，SSD同样是，顺序读写远远比随机读写快。\n\n至于异步的方式并不适合用来读写磁盘，读数据的时候肯定要等待磁盘返回数据，写入的时候，虽然可以用异步写来大幅提升响应时间，但其实牺牲了数据可靠性。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589868395,"ip_address":"","comment_id":217997,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，就算是SSD，随机查询的速度也会非常慢吧，那为什么SSD就不用考虑异步呢？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463065,"discussion_content":"你说的这个问题是有可能出现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565917566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291430,"discussion_content":"netty不会一直被一条流独占，还是会处理其他流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594817517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211584,"user_name":"77","can_delete":false,"product_type":"c1","uid":1946562,"ip_address":"","ucode":"C57A8443814F7A","user_header":"","comment_is_top":false,"comment_ctime":1587986117,"is_pvip":false,"replies":[{"id":78790,"content":"是的，数据会暂存在socket缓冲区中，等待下一次读取。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1588049920,"ip_address":"","comment_id":211584,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，问个问题，线程在忙着处理收到的数据，这时候 Channel 中又收到了新数据；新数据是下一次遍历Channel时处理吗？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495318,"discussion_content":"是的，SSD同样是，顺序读写远远比随机读写快。\n\n至于异步的方式并不适合用来读写磁盘，读数据的时候肯定要等待磁盘返回数据，写入的时候，虽然可以用异步写来大幅提升响应时间，但其实牺牲了数据可靠性。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589868395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124391,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1565875469,"is_pvip":false,"replies":[{"id":45726,"content":"这个比喻非常赞👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565918235,"ip_address":"","comment_id":124391,"utype":1}],"discussion_count":10,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"关于JAVA的网络，之前有个比喻形式的总结，分享给大家：\n例子：有一个养鸡的农场，里面养着来自各个农户（Thread）的鸡（Socket），每家农户都在农场中建立了自己的鸡舍（SocketChannel）\n1、BIO：Block IO，每个农户盯着自己的鸡舍，一旦有鸡下蛋，就去做捡蛋处理；\n2、NIO：No-Block IO-单Selector，农户们花钱请了一个饲养员（Selector），并告诉饲养员（register）如果哪家的鸡有任何情况（下蛋）均要向这家农户报告（select keys）；\n3、NIO：No-Block IO-多Selector，当农场中的鸡舍逐渐增多时，一个饲养员巡视（轮询）一次所需时间就会不断地加长，这样农户知道自己家的鸡有下蛋的情况就会发生较大的延迟。怎么解决呢？没错，多请几个饲养员（多Selector），每个饲养员分配管理鸡舍，这样就可以减轻一个饲养员的工作量，同时农户们可以更快的知晓自己家的鸡是否下蛋了；\n4、Epoll模式：如果采用Epoll方式，农场问题应该如何改进呢？其实就是饲养员不需要再巡视鸡舍，而是听到哪间鸡舍的鸡打鸣了（活跃连接），就知道哪家农户的鸡下蛋了；\n5、AIO：Asynchronous I&#47;O, 鸡下蛋后，以前的NIO方式要求饲养员通知农户去取蛋，AIO模式出现以后，事情变得更加简单了，取蛋工作由饲养员自己负责，然后取完后，直接通知农户来拿即可，而不需要农户自己到鸡舍去取蛋。","like_count":298,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463152,"discussion_content":"这个比喻非常赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565918235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1655940,"avatar":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","nickname":"呆瓜","note":"","ucode":"C98C7B224D0640","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361318,"discussion_content":"其实我觉得这个例子举得并不是很好，发表下自己观点，有错误的地方也希望大家慷慨纠正😃\n1.例子中增加了“饲养员”的角色和职责不是很清晰\n2.总结维度不是很清晰\n a.Epoll是操作系统底层实现方式，不是上层的模型;\n b.单Selector与多Selector本质上没有区别\n3.例子中的“NIO:No-Block IO-*Selector”\n a.单Selector与多Selector本质上没有太大区别\n b.Unix 系统下 IO 模型 ： 同步阻塞 I/O、 同步非阻塞 I/O、 I/O 多路复用、 信号驱动 I/O 、 异步 I/O；而Java的NIO（new IO）技术，其实使用的是IO多路复用模型 ( MIO , I/O Multiplexing ) 不是同步非阻塞 I/O 模型( NIO , None Blocking IO )\n c.多路复用模型是一种“同步-阻塞”模型，例子中“如果哪家的鸡有任何情况（下蛋）均要向这家农户报告（select keys）”显然是异步的，而且并没有提现出Selector的轮询阻塞和read拷贝阻塞。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1616641211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5678,"discussion_content":"很棒，建议在文中找个位置加上这段","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566434933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100474,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ca/ba/fe5c8bf9.jpg","nickname":"IThinkIGottaGo","note":"","ucode":"A4F59631795876","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5565,"discussion_content":"那这是否可以认为 epoll 依然不是一种 aio 呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566355522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2181985,"avatar":"","nickname":"Geek_da8c85","note":"","ucode":"BAC8AE70A5C6BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650539,"discussion_content":"Selector本质上是一个reactor模式的应用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725199224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2181985,"avatar":"","nickname":"Geek_da8c85","note":"","ucode":"BAC8AE70A5C6BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650538,"discussion_content":"将selector与其比喻成一个伺养员，不如比喻成一个农场主更好，selector只是负责巡视和通知，真正干活的还是事件处理器， 所以就类似于一个农场主（管理者）只是在不停地巡视， 然后发现某个channel发生了事件，就通知转发给具体的某个work（农户）去处理。\n类似的比喻是餐厅，channel就是一个个餐桌，selector是餐厅经理，事件处理worker是服务员， 当selector不停地巡视整个餐厅的各个餐桌，当发现有事件触发了， 无论是买单、点单、餐桌清理等事件，就转发给服务员去处理。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725198702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066686,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/be/169f825e.jpg","nickname":"陈哆啦","note":"","ucode":"DC0D67B25D180E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559679,"discussion_content":"太棒了, mark一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648878101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1505492,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/exfIUlVdCpicQPc7fOI6XezUuXd7rayRia7sB2GGHGP7IEBibI6TJbQS2R0bMNejzR1odAIDFP05cWjujrmbIzzwg/132","nickname":"AlexWillBeGood","note":"","ucode":"6D7BB91781E38C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348936,"discussion_content":"那么想问一下，AIO情况下回调函数是在“饲养员”那里处理了还是“农户”那里处理了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612786581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065849,"avatar":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","nickname":"test","note":"","ucode":"9A4973E591DD12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290020,"discussion_content":"很形象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594303729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1499380,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6Xwdhayv9Jdnee7HfDYSAMTUtMAAVORMhiaN8bIM0QJibrQ5EDqB8o5pWE6FRuaqguwG86o5Gh90ruDw/132","nickname":"不会爬树的熊","note":"","ucode":"E417D8D9D5FED2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5054,"discussion_content":"复制粘贴啦，很形象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565917444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126880,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566515490,"is_pvip":false,"replies":[{"id":46940,"content":"感谢你的建议！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566523098,"ip_address":"","comment_id":126880,"utype":1}],"discussion_count":7,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"课后思考及建议\n没有对比就没有伤害，尤其对于学习，对比一下就知道那个课程优秀，那个更优秀。\n\n首先，我觉得如何实现高性能的网络通信，是必须要讲的，这个原理是脱离具体语言的，和什么实现框架也没什么关系。\n不过篇幅有限老师只能讲解一下她的精髓，如果想一点点弄明白，建议看看李林峰大哥的《netty权威指南(第二版)》她用了三章来讲解网络通信模型的演进。\n另外，我同时在学kafka的专栏，我发现一个现象，两位老师都没有先将一个消息的全生命历程先细致的讲一下，学习过丁奇老师的MySQL，他上来就讲解了一下一个SQL语句是怎么执行的。我觉得很有整体感，知道整个过程之后其实下面再细致的讲解都是性能优化的事情啦！\n我猜想其他各种系统，尤其是和数据打交道的都类似，只要一个完整的流程知道了，下面好多知识都是在为这个系统的性能、健壮性、高可用性、自身的其他特性在加强。\n所以，我提过这样的问题，也建议先讲一下一条消息从发送到接收都经历了那些关键环节或组件，对一条消息的全生命历程有个整体的认识。然后再讲每个关键环节为什么这么实现，其性能最佳吞吐量最高。然后再讲各个组件是怎么紧密配合的，如果我知道一个软件是什么？又清楚他由什么组成？每一部分为什么如此设计？那些设计是通用的那些设计比较独特？我觉得我就理解了这个软件\n老师的课程非常优秀，哈哈，我觉得听了我的建议还可以再优秀一点点\n","like_count":64,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463152,"discussion_content":"这个比喻非常赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565918235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1655940,"avatar":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","nickname":"呆瓜","note":"","ucode":"C98C7B224D0640","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361318,"discussion_content":"其实我觉得这个例子举得并不是很好，发表下自己观点，有错误的地方也希望大家慷慨纠正😃\n1.例子中增加了“饲养员”的角色和职责不是很清晰\n2.总结维度不是很清晰\n a.Epoll是操作系统底层实现方式，不是上层的模型;\n b.单Selector与多Selector本质上没有区别\n3.例子中的“NIO:No-Block IO-*Selector”\n a.单Selector与多Selector本质上没有太大区别\n b.Unix 系统下 IO 模型 ： 同步阻塞 I/O、 同步非阻塞 I/O、 I/O 多路复用、 信号驱动 I/O 、 异步 I/O；而Java的NIO（new IO）技术，其实使用的是IO多路复用模型 ( MIO , I/O Multiplexing ) 不是同步非阻塞 I/O 模型( NIO , None Blocking IO )\n c.多路复用模型是一种“同步-阻塞”模型，例子中“如果哪家的鸡有任何情况（下蛋）均要向这家农户报告（select keys）”显然是异步的，而且并没有提现出Selector的轮询阻塞和read拷贝阻塞。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1616641211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5678,"discussion_content":"很棒，建议在文中找个位置加上这段","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566434933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100474,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ca/ba/fe5c8bf9.jpg","nickname":"IThinkIGottaGo","note":"","ucode":"A4F59631795876","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5565,"discussion_content":"那这是否可以认为 epoll 依然不是一种 aio 呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566355522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2181985,"avatar":"","nickname":"Geek_da8c85","note":"","ucode":"BAC8AE70A5C6BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650539,"discussion_content":"Selector本质上是一个reactor模式的应用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725199224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2181985,"avatar":"","nickname":"Geek_da8c85","note":"","ucode":"BAC8AE70A5C6BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650538,"discussion_content":"将selector与其比喻成一个伺养员，不如比喻成一个农场主更好，selector只是负责巡视和通知，真正干活的还是事件处理器， 所以就类似于一个农场主（管理者）只是在不停地巡视， 然后发现某个channel发生了事件，就通知转发给具体的某个work（农户）去处理。\n类似的比喻是餐厅，channel就是一个个餐桌，selector是餐厅经理，事件处理worker是服务员， 当selector不停地巡视整个餐厅的各个餐桌，当发现有事件触发了， 无论是买单、点单、餐桌清理等事件，就转发给服务员去处理。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725198702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066686,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/be/169f825e.jpg","nickname":"陈哆啦","note":"","ucode":"DC0D67B25D180E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559679,"discussion_content":"太棒了, mark一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648878101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1505492,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/exfIUlVdCpicQPc7fOI6XezUuXd7rayRia7sB2GGHGP7IEBibI6TJbQS2R0bMNejzR1odAIDFP05cWjujrmbIzzwg/132","nickname":"AlexWillBeGood","note":"","ucode":"6D7BB91781E38C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348936,"discussion_content":"那么想问一下，AIO情况下回调函数是在“饲养员”那里处理了还是“农户”那里处理了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612786581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065849,"avatar":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","nickname":"test","note":"","ucode":"9A4973E591DD12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290020,"discussion_content":"很形象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594303729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1499380,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6Xwdhayv9Jdnee7HfDYSAMTUtMAAVORMhiaN8bIM0QJibrQ5EDqB8o5pWE6FRuaqguwG86o5Gh90ruDw/132","nickname":"不会爬树的熊","note":"","ucode":"E417D8D9D5FED2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5054,"discussion_content":"复制粘贴啦，很形象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565917444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124126,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1565829407,"is_pvip":false,"replies":[{"id":45720,"content":"我们还是需要一个例子能让大家理解异步网络传输的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565917323,"ip_address":"","comment_id":124126,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"多回到队列上来吧。Netty几乎很多Java课都会讲到。。。","like_count":25,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464221,"discussion_content":"感谢你的建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566523098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073596,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/bc/88a905a5.jpg","nickname":"亮点","note":"","ucode":"1B8AE07484C69A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625020,"discussion_content":"感觉什么都说了，又什么都没说，停留在表层，不适合想进阶的人","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1691203784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5939,"discussion_content":"不妥之处还请见谅😀","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566543137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47748,"discussion_content":"netty权威指南感觉内容拖沓，对核心关键点又有点隔靴挠痒。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573400605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020492,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/4c/40783447.jpg","nickname":"何骧","note":"","ucode":"11DCC74CE2F300","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297145,"discussion_content":"有什么推荐吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596786809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47748,"ip_address":"","group_id":0},"score":297145,"extra":""},{"author":{"id":1879262,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ac/de/68f35320.jpg","nickname":"小来子","note":"","ucode":"4EDAF31E43B211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380933,"discussion_content":"这门课程也有点了。感觉不紧凑，可能是叙述方式的问题。   尤其是读到这节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624803422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47748,"ip_address":"","group_id":0},"score":380933,"extra":""}]},{"author":{"id":1499730,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erQ5LXNgaZ3ReArPrY4YeT5mNVtBpiazFEQzNuUXxzdLOWtMliaGicNCpjaOezRISARHXPibkA4ACgib1g/132","nickname":"JensonYao","note":"","ucode":"D4A9765F1112BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649851,"discussion_content":"这个全局性思路很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724056103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208460,"user_name":"喜欢地球的阿培同学","can_delete":false,"product_type":"c1","uid":1361746,"ip_address":"","ucode":"5F97037585F857","user_header":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","comment_is_top":false,"comment_ctime":1587364194,"is_pvip":false,"replies":[{"id":78331,"content":"方法在阻塞时，你要区分它的线程状态，如果是你说的等待锁，那线程的状态是waiting，是不会申请cpu时间片的，那就不会上下文切换。\n\n如果是这个方法呢：\n\nvoid blockMethod() {\n    while(....) {doSomeThing();}\n}\n\n对于这个调用者看来，也是阻塞在这个调用这个blockMethod方法上了，但是线程是RUNNING状态，这个时候肯定是要申请CPU时间片的。\n\nSelector.select()在阻塞时，它的内部实现根据操作系统和epoll的配置不同，实际上有好几种实现，不同的实现行为也不一样。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1587694603,"ip_address":"","comment_id":208460,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师您好，我上周问了你2个问题。 分别在第17讲和第11讲\n\n第一个问题: 一个是100个线程，1个线程在运行，99个线程在阻塞(等待锁释放)，会不会造成线程频繁上下文切换。你回答的是不会。\n\n第二个问题: 我又问了一个 Selector.select()方法是一个阻塞方法，这个线程会一直卡在这儿。你的回答我理解过后是会造成线程上下文切换\n\n那为什么第一个问题不会造成线程上下文频繁切换呢？ 是因为底层操作系统的原因吗？ 而普通的socket连接阻塞，是会造成线程上下文切换？","like_count":15,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492464,"discussion_content":"方法在阻塞时，你要区分它的线程状态，如果是你说的等待锁，那线程的状态是waiting，是不会申请cpu时间片的，那就不会上下文切换。\n\n如果是这个方法呢：\n\nvoid blockMethod() {\n    while(....) {doSomeThing();}\n}\n\n对于这个调用者看来，也是阻塞在这个调用这个blockMethod方法上了，但是线程是RUNNING状态，这个时候肯定是要申请CPU时间片的。\n\nSelector.select()在阻塞时，它的内部实现根据操作系统和epoll的配置不同，实际上有好几种实现，不同的实现行为也不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587694603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207199,"user_name":"喜欢地球的阿培同学","can_delete":false,"product_type":"c1","uid":1361746,"ip_address":"","ucode":"5F97037585F857","user_header":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","comment_is_top":false,"comment_ctime":1587022669,"is_pvip":false,"replies":[{"id":77853,"content":"Selector本身是阻塞的，但它只需要阻塞一个线程，就可以等待多个socket连接，任何一个连接有数据进来就会解除阻塞。这就是所谓的“多路复用”。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1587353197,"ip_address":"","comment_id":207199,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"最后文中有一段话: &quot;Selecor 通过一种类似于事件的机制来解决这个问题。首先你需要把你的连接，也就是 Channel 绑定到 Selector 上，然后你可以在接收数据的线程来调用 Selector.select() 方法来等待数据到来。这个 select 方法是一个阻塞方法，这个线程会一直卡在这儿，直到这些 Channel 中的任意一个有数据到来，就会结束等待返回数据。&quot;\n\n这个 select 方法是一个阻塞方法，这个线程会一直卡在这儿，岂不是和上篇文章的同步转账类似，该线程会处于等待状态，无法充分利用cpu资源。","like_count":9,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492036,"discussion_content":"Selector本身是阻塞的，但它只需要阻塞一个线程，就可以等待多个socket连接，任何一个连接有数据进来就会解除阻塞。这就是所谓的“多路复用”。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587353197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330527,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8f/9f/0767e5a5.jpg","nickname":"流云","note":"","ucode":"4DA4CE36520724","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384894,"discussion_content":"老师，这种“多路复用”会不会出现在同一个时间点同时两个数据被送过来，这两个数据又是如何处理的呢，还是说selector内部实际上是一个类似时分复用的机制，就可以很好地解决这种场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626785071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216040,"user_name":"青禾qingh","can_delete":false,"product_type":"c1","uid":1651441,"ip_address":"","ucode":"453FC435B03790","user_header":"https://static001.geekbang.org/account/avatar/00/19/32/f1/fd24d52b.jpg","comment_is_top":false,"comment_ctime":1589173007,"is_pvip":false,"replies":[{"id":80342,"content":"严格来说，是这样的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589462991,"ip_address":"","comment_id":216040,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，nio不是异步的吧，我理解是同步非阻塞的，当然非阻塞也仅仅是指读写数据的时候，select也是阻塞的，我理解aio才是异步的","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494650,"discussion_content":"严格来说，是这样的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589462991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3021110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cjichzNjhghHD9DJEXCBrh1PqmmlfBwC84NKbn9obLYEGCBDiaqufEArL26Qy0YiaibVbhcnYON7oqh7v6HgCjmk3g/132","nickname":"Geek_eca226","note":"","ucode":"E738A5618F3218","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581109,"discussion_content":"那面试说netty异步会被面试官diss吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658499871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555560,"discussion_content":"你好，关于同步非阻塞能具体展开讲讲吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646973879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3585239,"avatar":"","nickname":"Geek_fc724d","note":"","ucode":"684ACFE9CBBD8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612595,"discussion_content":"同步就是发送一个请求，这个线程在那里等着占用cpu也不往下执行，同步非阻塞就是发一个请求不往下执行但是会让出cpu时间片。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680792961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":555560,"ip_address":"江苏","group_id":0},"score":612595,"extra":""}]}]},{"had_liked":false,"id":124082,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1565816132,"is_pvip":false,"replies":[{"id":45717,"content":"放心，我们这门课使用的任何语言都不会特别深入，更多的是讲实现原理，语言只是讲解和举例的载体。\n\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565917162,"ip_address":"","comment_id":124082,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"Java基础太差：几乎不懂；故而其实本课程学习让我觉得越多Java相关的非常吃力，希望老师后面的课程里面纯Java的东西能浅一点或者告知Java的理解大概要什么水平。\n刘超老师的趣谈linux在跟着学、张磊的深入剖析Kubernetes目前学了一遍。我想从用这种方式去理解或解释不知道原理是否类似正确吧：希望老师提点或者下堂课时解答。\n其实Netty基于NIO就像Kubernetes其实是基于Cgroup和Namespace一样：其实Netty是使用了NIO的Selecor去处理线程的异步机制，Netty在它的基础上去优化了其线程控制和连接管理并追加了缓存管理，请老师指正；谢谢。\n努力跟着学习，努力跟着做题；希望完课的时候能从另外一个高度&#47;层次去理解和使用消息队列。","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463000,"discussion_content":"放心，我们这门课使用的任何语言都不会特别深入，更多的是讲实现原理，语言只是讲解和举例的载体。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565917162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124220,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1565836792,"is_pvip":false,"replies":[{"id":45722,"content":"你说的这个问题是有可能出现的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565917566,"ip_address":"","comment_id":124220,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，以下是我的理解：异步网络框架中，通过线程池处理接收消息的情况，和同步相比，好处在于，同步框架下，一个连接必须有两个线程（等数据的线程、处理数据的线程），当连接过多时会有大量频繁的上下文切换；而异步框架利用线程池接管了（等数据的线程）的作用，减少了上下文切换、线程的创建销毁的开销；\n问题是：虽然线程池完成了数据接收的功能，但加入消息发送方发来了大量的消息，因为线程池的线程数量毕竟是有限的，此时是否就会出现消息不能及时转发给数据处理线程的情况呢？","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463065,"discussion_content":"你说的这个问题是有可能出现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565917566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291430,"discussion_content":"netty不会一直被一条流独占，还是会处理其他流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594817517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217997,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1589690280,"is_pvip":false,"replies":[{"id":80845,"content":"是的，SSD同样是，顺序读写远远比随机读写快。\n\n至于异步的方式并不适合用来读写磁盘，读数据的时候肯定要等待磁盘返回数据，写入的时候，虽然可以用异步写来大幅提升响应时间，但其实牺牲了数据可靠性。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589868395,"ip_address":"","comment_id":217997,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，就算是SSD，随机查询的速度也会非常慢吧，那为什么SSD就不用考虑异步呢？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495318,"discussion_content":"是的，SSD同样是，顺序读写远远比随机读写快。\n\n至于异步的方式并不适合用来读写磁盘，读数据的时候肯定要等待磁盘返回数据，写入的时候，虽然可以用异步写来大幅提升响应时间，但其实牺牲了数据可靠性。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589868395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211584,"user_name":"77","can_delete":false,"product_type":"c1","uid":1946562,"ip_address":"","ucode":"C57A8443814F7A","user_header":"","comment_is_top":false,"comment_ctime":1587986117,"is_pvip":false,"replies":[{"id":78790,"content":"是的，数据会暂存在socket缓冲区中，等待下一次读取。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1588049920,"ip_address":"","comment_id":211584,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，问个问题，线程在忙着处理收到的数据，这时候 Channel 中又收到了新数据；新数据是下一次遍历Channel时处理吗？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493308,"discussion_content":"是的，数据会暂存在socket缓冲区中，等待下一次读取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588049920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130388,"user_name":"杰哥长得帅","can_delete":false,"product_type":"c1","uid":1241993,"ip_address":"","ucode":"5A7FD1794F62D7","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/89/fcfecb46.jpg","comment_is_top":false,"comment_ctime":1567439111,"is_pvip":false,"replies":[{"id":48740,"content":"因为接收数据这些操作都需要cpu来执行。接收数据的这个操作，实际上就是把数据从socket 缓冲区复制到用户程序的内存空间，然后执行用户代码去解析数据等其他业务逻辑，这些操作都需要CPU来执行。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567493196,"ip_address":"","comment_id":130388,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"同步的时候，每个连接都需要阻塞一个线程来等待数据，大量的连接数就会需要相同数量的数据接收线程。当这些 TCP 连接都在进行数据收发的时候，会导致什么情况呢？对，会有大量的线程来抢占 CPU 时间，造成频繁的 CPU 上下文切换，导致 CPU 的负载升高，整个系统的性能就会比较慢。\n\n老师能详细解释下 “大量线程用于数据接收时，为什么又会有大量线程来抢占cpu时间” 吗","like_count":2},{"had_liked":false,"id":124373,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1565869720,"is_pvip":false,"replies":[{"id":45725,"content":"其实这些语言中，它们的很多基础类库实现的原理都是一样的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565918172,"ip_address":"","comment_id":124373,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"不小心发出去了，继续上一个回答。Netty使用了NIO的IO多路复用能力，采用线程池来增加对多核CPU的利用。在Linux编程里epoll加非阻塞IO，组成了传说中的reactor模式，那么Netty为每一个线程实现一个reactor，使得这个吞吐量非常强大，对应到C++的框架，就类似muduo网络库了。","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465934,"discussion_content":"因为接收数据这些操作都需要cpu来执行。接收数据的这个操作，实际上就是把数据从socket 缓冲区复制到用户程序的内存空间，然后执行用户代码去解析数据等其他业务逻辑，这些操作都需要CPU来执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567493196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187282,"user_name":"Spring coming","can_delete":false,"product_type":"c1","uid":1116196,"ip_address":"","ucode":"9E01F2D987D08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/24/1d3bafaf.jpg","comment_is_top":false,"comment_ctime":1584073734,"is_pvip":false,"replies":[{"id":72773,"content":"网络连接和线程是二回事儿，在异步网络IO中，网络连接可以不占用线程。\n\n异步回调的时候，执行回调方法这个过程，一定要有一个线程来执行，一般来说，如果回调方法没什么逻辑很快，可以直接在IO线程里面执行，否则需要再做一次异步调用，让单独的回调线程来执行。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1584408959,"ip_address":"","comment_id":187282,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"请问老师一个问题，异步回调发生的时候才会占用线程吗，收到回调之前网络连接是不是也需要占用线程来处理啊？从回调发生的时候到回调结束，这里涉及到线程的变化是怎么样的啊","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487055,"discussion_content":"网络连接和线程是二回事儿，在异步网络IO中，网络连接可以不占用线程。\n\n异步回调的时候，执行回调方法这个过程，一定要有一个线程来执行，一般来说，如果回调方法没什么逻辑很快，可以直接在IO线程里面执行，否则需要再做一次异步调用，让单独的回调线程来执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584408959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124205,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1565834450,"is_pvip":false,"replies":[{"id":45755,"content":"我们这节课和接下来的几节课讲的都是实现消息队列必须的一些技术，同学应该重点来理解我们讲解的原理，但是要真正掌握这些原理，还是需要依托与某一个语言或者框架来实际操作一下的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565924271,"ip_address":"","comment_id":124205,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"希望老师多讲讲MQ 相关的,不要深入某一个语言某一个类库或者框架进行讲解的，有的同学语言不熟悉，代码也看不懂的，某一个类库或者框架实现的细节也不知道的","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463059,"discussion_content":"我们这节课和接下来的几节课讲的都是实现消息队列必须的一些技术，同学应该重点来理解我们讲解的原理，但是要真正掌握这些原理，还是需要依托与某一个语言或者框架来实际操作一下的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565924271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1302746,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoWfXendN7czHpsyaWKLPK6Na9P5czquJ7Wdre4TibZQ5SQib88edyuib3LpCVFkp0gII2wyvvR8tEIA/132","nickname":"OM","note":"","ucode":"E33C66A70802A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386007,"discussion_content":"需要的，不然没办法表达技术的要点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627380991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125334,"user_name":"奎因","can_delete":false,"product_type":"c1","uid":1495355,"ip_address":"","ucode":"1A191B66ECF899","user_header":"https://static001.geekbang.org/account/avatar/00/16/d1/3b/03d21d78.jpg","comment_is_top":false,"comment_ctime":1566168297,"is_pvip":false,"replies":[{"id":46022,"content":"方便的话可以给大家分享一下代码哟","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566175526,"ip_address":"","comment_id":125334,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"我是 Python 开发者，基于 Python 内置的 low level api 中的异步 io 对象编写了一个异步的 websocket","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463532,"discussion_content":"方便的话可以给大家分享一下代码哟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566175526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124781,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1612614,"ip_address":"","ucode":"5A26761299F7AC","user_header":"https://static001.geekbang.org/account/avatar/00/18/9b/46/ad3194bd.jpg","comment_is_top":false,"comment_ctime":1565973097,"is_pvip":false,"replies":[{"id":45891,"content":"简单地说，异步的方法和类似CompletableFuture这样的异步框架，可以解决我们自己编写代码的异步化问题。\n\n而NIO等异步网络通信框架，解决的是异步收发网络数据的问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566121102,"ip_address":"","comment_id":124781,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，有点晕，前边讲的completablefuture和nio之间的区别和联系是什么呢？好像两者并没有直接关系？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463320,"discussion_content":"简单地说，异步的方法和类似CompletableFuture这样的异步框架，可以解决我们自己编写代码的异步化问题。\n\n而NIO等异步网络通信框架，解决的是异步收发网络数据的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566121102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37593,"discussion_content":"completablefuture 应该是代码逻辑 同步 异步的问题  nio是网络通信  阻塞非阻塞的问题  不知道这样描述对不对~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571643083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124369,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1565869252,"is_pvip":false,"replies":[{"id":45724,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565918128,"ip_address":"","comment_id":124369,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"不是很懂Java，强答一发，如有错误还望指正。我理解的异步框架应该是提供提供对客户端端连接，然后转发到业务服务器上，并通过回调的方式来响应这个异步的请求。实现整个完整的过程就是一个异步框架了。Java的NIO我不是很懂，但是我猜想NIO只是为Java实现了Linux下的IO多路复用能力，更准确的只是一种IO模型框架。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463140,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565918128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552373,"discussion_content":"也不懂，强发一说，编程语言提供的API，特性等，基础还是封装操作系统提供的底层API，操作系统提供的API，也是对硬件操作的封装，这就是一个层层封装的过程。\n业务上开发也是一样，什么中间件，工具，也是封装，我们都站在巨人的肩膀上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645433833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124671,"user_name":"史双龙","can_delete":false,"product_type":"c1","uid":1176417,"ip_address":"","ucode":"387D01880867AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/61/8f7fca5b.jpg","comment_is_top":false,"comment_ctime":1565940880,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"玥哥秋安：我今天看了这个课程我觉得就有同学要说，老师你是不是跑题了，首先我要说一下为什么要说今天这讲课，并且用netty来举栗子。\n第一：了解一下异步网络传输的原理\n第二：用Netty来举栗子是因为Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。\n第三：rocketMQ的底层就是用Netty实现的。\n第四：可以看一下第9节课如果学习开源代码，然后在看一下rocketMQ的源码。然后根据MQ的Producer，Consumer，Broker，NameSrv等的底层实现是不是理解了玥哥的良苦用心。\n个人见解勿喷！","like_count":28,"discussions":[{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"程序员俊达","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573325,"discussion_content":"是这么个流程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653357772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139619,"user_name":"达文西","can_delete":false,"product_type":"c1","uid":1398824,"ip_address":"","ucode":"01C1063F23D634","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","comment_is_top":false,"comment_ctime":1570693022,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"关于同步&#47;异步,阻塞&#47;非阻塞的定义,可以参考这篇博客https:&#47;&#47;www.cnblogs.com&#47;dolphin0520&#47;p&#47;3916526.html","like_count":8,"discussions":[{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"程序员俊达","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573325,"discussion_content":"是这么个流程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653357772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124216,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1565835865,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"学习完高性能网络传输，写下自己的理解和疑惑，老师有空帮忙看下哦\nNetty服务端会存在两个线程池NioEventLoopGroup，一个线程池主要用来处理客户端的连接，一般设置单线程NioEventLoop，在Linux中可能是EpollEventLoop，要是服务端监控多个端口可以设置多个线程，服务端接收到客户端的连接会创建Channel通道，Channel通道中会有收发缓存，服务端会定时监控Channel通道是否已经断开，在一定时间没有收到客户端的心跳包，把客户端的Channel从服务端移除，还可以设置服务端接收连接的队列，还有一个处理线程池NioEventLoopGroup，里面会有多个线程NioEventLoop，然后每个NioEventLoop都会有一个Selector，然后可以多个channel绑定到NioEventLoop的Selector中，即一个Channel只能被一个NioEventLoop处理，一个NioEventLoop可以处理多个Channel，即收到Channel数据，NioEventLoop执行Handler，包括解码、拆包等Handler，服务端返回响应消息对Channel进行编码等Handler。\n尝试回答下课后习题接收数据这个流程Netty是一个NioEventLoop会有一个Selector，原先的Nio是只有一个Selector进行处理所有的连接收发事件，这样的话比如NioEventLoopGroup中有10个NioEventLoop，这样的话就有10个Selector，比如有10000读写请求，每个Selector就可以维持1000","like_count":6,"discussions":[{"author":{"id":2405308,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b3/bc/4d00adce.jpg","nickname":"知行","note":"","ucode":"A514020B2ED437","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555659,"discussion_content":"netty 应该是同步非阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647009162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183227,"discussion_content":"你既然看过那篇文章，那是不是对于专栏中大量的使用&#34;异步&#34;这个词感到迷惑，毕竟多路复用不算是异步IO，😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582469868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130388,"user_name":"杰哥长得帅","can_delete":false,"product_type":"c1","uid":1241993,"ip_address":"","ucode":"5A7FD1794F62D7","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/89/fcfecb46.jpg","comment_is_top":false,"comment_ctime":1567439111,"is_pvip":false,"replies":[{"id":48740,"content":"因为接收数据这些操作都需要cpu来执行。接收数据的这个操作，实际上就是把数据从socket 缓冲区复制到用户程序的内存空间，然后执行用户代码去解析数据等其他业务逻辑，这些操作都需要CPU来执行。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567493196,"ip_address":"","comment_id":130388,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"同步的时候，每个连接都需要阻塞一个线程来等待数据，大量的连接数就会需要相同数量的数据接收线程。当这些 TCP 连接都在进行数据收发的时候，会导致什么情况呢？对，会有大量的线程来抢占 CPU 时间，造成频繁的 CPU 上下文切换，导致 CPU 的负载升高，整个系统的性能就会比较慢。\n\n老师能详细解释下 “大量线程用于数据接收时，为什么又会有大量线程来抢占cpu时间” 吗","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465934,"discussion_content":"因为接收数据这些操作都需要cpu来执行。接收数据的这个操作，实际上就是把数据从socket 缓冲区复制到用户程序的内存空间，然后执行用户代码去解析数据等其他业务逻辑，这些操作都需要CPU来执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567493196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124373,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1565869720,"is_pvip":false,"replies":[{"id":45725,"content":"其实这些语言中，它们的很多基础类库实现的原理都是一样的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565918172,"ip_address":"","comment_id":124373,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"不小心发出去了，继续上一个回答。Netty使用了NIO的IO多路复用能力，采用线程池来增加对多核CPU的利用。在Linux编程里epoll加非阻塞IO，组成了传说中的reactor模式，那么Netty为每一个线程实现一个reactor，使得这个吞吐量非常强大，对应到C++的框架，就类似muduo网络库了。","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463142,"discussion_content":"其实这些语言中，它们的很多基础类库实现的原理都是一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565918172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187282,"user_name":"Spring coming","can_delete":false,"product_type":"c1","uid":1116196,"ip_address":"","ucode":"9E01F2D987D08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/24/1d3bafaf.jpg","comment_is_top":false,"comment_ctime":1584073734,"is_pvip":false,"replies":[{"id":72773,"content":"网络连接和线程是二回事儿，在异步网络IO中，网络连接可以不占用线程。\n\n异步回调的时候，执行回调方法这个过程，一定要有一个线程来执行，一般来说，如果回调方法没什么逻辑很快，可以直接在IO线程里面执行，否则需要再做一次异步调用，让单独的回调线程来执行。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1584408959,"ip_address":"","comment_id":187282,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"请问老师一个问题，异步回调发生的时候才会占用线程吗，收到回调之前网络连接是不是也需要占用线程来处理啊？从回调发生的时候到回调结束，这里涉及到线程的变化是怎么样的啊","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463142,"discussion_content":"其实这些语言中，它们的很多基础类库实现的原理都是一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565918172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124205,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1565834450,"is_pvip":false,"replies":[{"id":45755,"content":"我们这节课和接下来的几节课讲的都是实现消息队列必须的一些技术，同学应该重点来理解我们讲解的原理，但是要真正掌握这些原理，还是需要依托与某一个语言或者框架来实际操作一下的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565924271,"ip_address":"","comment_id":124205,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"希望老师多讲讲MQ 相关的,不要深入某一个语言某一个类库或者框架进行讲解的，有的同学语言不熟悉，代码也看不懂的，某一个类库或者框架实现的细节也不知道的","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487055,"discussion_content":"网络连接和线程是二回事儿，在异步网络IO中，网络连接可以不占用线程。\n\n异步回调的时候，执行回调方法这个过程，一定要有一个线程来执行，一般来说，如果回调方法没什么逻辑很快，可以直接在IO线程里面执行，否则需要再做一次异步调用，让单独的回调线程来执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584408959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125334,"user_name":"奎因","can_delete":false,"product_type":"c1","uid":1495355,"ip_address":"","ucode":"1A191B66ECF899","user_header":"https://static001.geekbang.org/account/avatar/00/16/d1/3b/03d21d78.jpg","comment_is_top":false,"comment_ctime":1566168297,"is_pvip":false,"replies":[{"id":46022,"content":"方便的话可以给大家分享一下代码哟","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566175526,"ip_address":"","comment_id":125334,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"我是 Python 开发者，基于 Python 内置的 low level api 中的异步 io 对象编写了一个异步的 websocket","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463059,"discussion_content":"我们这节课和接下来的几节课讲的都是实现消息队列必须的一些技术，同学应该重点来理解我们讲解的原理，但是要真正掌握这些原理，还是需要依托与某一个语言或者框架来实际操作一下的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565924271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1302746,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoWfXendN7czHpsyaWKLPK6Na9P5czquJ7Wdre4TibZQ5SQib88edyuib3LpCVFkp0gII2wyvvR8tEIA/132","nickname":"OM","note":"","ucode":"E33C66A70802A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386007,"discussion_content":"需要的，不然没办法表达技术的要点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627380991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124781,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1612614,"ip_address":"","ucode":"5A26761299F7AC","user_header":"https://static001.geekbang.org/account/avatar/00/18/9b/46/ad3194bd.jpg","comment_is_top":false,"comment_ctime":1565973097,"is_pvip":false,"replies":[{"id":45891,"content":"简单地说，异步的方法和类似CompletableFuture这样的异步框架，可以解决我们自己编写代码的异步化问题。\n\n而NIO等异步网络通信框架，解决的是异步收发网络数据的问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566121102,"ip_address":"","comment_id":124781,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，有点晕，前边讲的completablefuture和nio之间的区别和联系是什么呢？好像两者并没有直接关系？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463532,"discussion_content":"方便的话可以给大家分享一下代码哟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566175526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124369,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1565869252,"is_pvip":false,"replies":[{"id":45724,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565918128,"ip_address":"","comment_id":124369,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"不是很懂Java，强答一发，如有错误还望指正。我理解的异步框架应该是提供提供对客户端端连接，然后转发到业务服务器上，并通过回调的方式来响应这个异步的请求。实现整个完整的过程就是一个异步框架了。Java的NIO我不是很懂，但是我猜想NIO只是为Java实现了Linux下的IO多路复用能力，更准确的只是一种IO模型框架。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463320,"discussion_content":"简单地说，异步的方法和类似CompletableFuture这样的异步框架，可以解决我们自己编写代码的异步化问题。\n\n而NIO等异步网络通信框架，解决的是异步收发网络数据的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566121102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37593,"discussion_content":"completablefuture 应该是代码逻辑 同步 异步的问题  nio是网络通信  阻塞非阻塞的问题  不知道这样描述对不对~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571643083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124671,"user_name":"史双龙","can_delete":false,"product_type":"c1","uid":1176417,"ip_address":"","ucode":"387D01880867AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/61/8f7fca5b.jpg","comment_is_top":false,"comment_ctime":1565940880,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"玥哥秋安：我今天看了这个课程我觉得就有同学要说，老师你是不是跑题了，首先我要说一下为什么要说今天这讲课，并且用netty来举栗子。\n第一：了解一下异步网络传输的原理\n第二：用Netty来举栗子是因为Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。\n第三：rocketMQ的底层就是用Netty实现的。\n第四：可以看一下第9节课如果学习开源代码，然后在看一下rocketMQ的源码。然后根据MQ的Producer，Consumer，Broker，NameSrv等的底层实现是不是理解了玥哥的良苦用心。\n个人见解勿喷！","like_count":28,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463140,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565918128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552373,"discussion_content":"也不懂，强发一说，编程语言提供的API，特性等，基础还是封装操作系统提供的底层API，操作系统提供的API，也是对硬件操作的封装，这就是一个层层封装的过程。\n业务上开发也是一样，什么中间件，工具，也是封装，我们都站在巨人的肩膀上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645433833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139619,"user_name":"达文西","can_delete":false,"product_type":"c1","uid":1398824,"ip_address":"","ucode":"01C1063F23D634","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","comment_is_top":false,"comment_ctime":1570693022,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"关于同步&#47;异步,阻塞&#47;非阻塞的定义,可以参考这篇博客https:&#47;&#47;www.cnblogs.com&#47;dolphin0520&#47;p&#47;3916526.html","like_count":8,"discussions":[{"author":{"id":2405308,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b3/bc/4d00adce.jpg","nickname":"知行","note":"","ucode":"A514020B2ED437","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555659,"discussion_content":"netty 应该是同步非阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647009162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183227,"discussion_content":"你既然看过那篇文章，那是不是对于专栏中大量的使用&#34;异步&#34;这个词感到迷惑，毕竟多路复用不算是异步IO，😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582469868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124216,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1565835865,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"学习完高性能网络传输，写下自己的理解和疑惑，老师有空帮忙看下哦\nNetty服务端会存在两个线程池NioEventLoopGroup，一个线程池主要用来处理客户端的连接，一般设置单线程NioEventLoop，在Linux中可能是EpollEventLoop，要是服务端监控多个端口可以设置多个线程，服务端接收到客户端的连接会创建Channel通道，Channel通道中会有收发缓存，服务端会定时监控Channel通道是否已经断开，在一定时间没有收到客户端的心跳包，把客户端的Channel从服务端移除，还可以设置服务端接收连接的队列，还有一个处理线程池NioEventLoopGroup，里面会有多个线程NioEventLoop，然后每个NioEventLoop都会有一个Selector，然后可以多个channel绑定到NioEventLoop的Selector中，即一个Channel只能被一个NioEventLoop处理，一个NioEventLoop可以处理多个Channel，即收到Channel数据，NioEventLoop执行Handler，包括解码、拆包等Handler，服务端返回响应消息对Channel进行编码等Handler。\n尝试回答下课后习题接收数据这个流程Netty是一个NioEventLoop会有一个Selector，原先的Nio是只有一个Selector进行处理所有的连接收发事件，这样的话比如NioEventLoopGroup中有10个NioEventLoop，这样的话就有10个Selector，比如有10000读写请求，每个Selector就可以维持1000","like_count":6,"discussions":[{"author":{"id":1476323,"avatar":"https://static001.geekbang.org/account/avatar/00/16/86/e3/a31f6869.jpg","nickname":" 尿布","note":"","ucode":"D1C8BDA7540962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279138,"discussion_content":"高性能网络传输是哪本书","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591285235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124120,"user_name":"王飞2023","can_delete":false,"product_type":"c1","uid":1111400,"ip_address":"","ucode":"C0F3139B836F39","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1565828315,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"1   本文按理说应该讲的是消息队列中网络的使用，但是实际作者讲的是java的网络基础编程和netty的入门介绍。\n\n2   实际的网络传输，比如rocketmq在发送端也是异步的，而不是同步。\n\n3  对于java的BIO,NIO，包括netty的入门demo，网上文章很多。如何在消息队列的中间件开发中，能高效使用netty，或者说NIO，也不是一件容易的事。","like_count":3},{"had_liked":false,"id":171349,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1024763,"ip_address":"","ucode":"F6B5C64BC99FB7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/fb/94af9cf1.jpg","comment_is_top":false,"comment_ctime":1578906368,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"读了本节，又在网上查了查NIO的内容。最后理解如下,NIO核心是增加了缓存层，这样就不用一个连接启用一个线程。缓存跟消息队列一样，做了前端连接和后端线程的分离。利用缓存的中转站借助少量线程实现后端业务处理。NIO减少的是后端线程不是前端的请求连接。这点容易迷惑。","like_count":1},{"had_liked":false,"id":126797,"user_name":"凌霄","can_delete":false,"product_type":"c1","uid":1107786,"ip_address":"","ucode":"19C4BFB0298276","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/4a/4dfb565a.jpg","comment_is_top":false,"comment_ctime":1566478963,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"jsf中netty使用一个线程组boss线程（一个端口一个boss线程）专门处理accept，使用一个线程组work专门处理io，work线程再调用业务线程。","like_count":1},{"had_liked":false,"id":396498,"user_name":"小黄哥","can_delete":false,"product_type":"c1","uid":1102129,"ip_address":"浙江","ucode":"805429DFA5EA93","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/31/d0866990.jpg","comment_is_top":false,"comment_ctime":1734685453,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"Redis也是基于IO多路复用实现了自己的事件驱动框架","like_count":0},{"had_liked":false,"id":369383,"user_name":"小红帽","can_delete":false,"product_type":"c1","uid":1135290,"ip_address":"广东","ucode":"876000FB67C980","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/ba/440c0157.jpg","comment_is_top":false,"comment_ctime":1677479712,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"针对接收数据这个流程，Netty 它是如何用 NIO 来实现的呢？\n没有看过java NIO的代码，从理论来说这里应该有两类线程\n1、等待io的线程，限定数量的seltor监控io流\n2、判断数据接收完成和唤起等待io的线程（事件回调机制）\n所以使用nio来实现的话，首先肯定要先启用一个nio服务监听接口调用，然后数据接收完成后会用一个新的线程来处理业务逻辑。","like_count":0},{"had_liked":false,"id":338702,"user_name":"i_chase","can_delete":false,"product_type":"c1","uid":1795511,"ip_address":"","ucode":"09C41C863F4EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","comment_is_top":false,"comment_ctime":1647674138,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"没有必要一直说java...","like_count":0},{"had_liked":false,"id":334350,"user_name":"邱邱邱","can_delete":false,"product_type":"c1","uid":2611827,"ip_address":"","ucode":"828318EB2316EB","user_header":"https://static001.geekbang.org/account/avatar/00/27/da/73/7e7593a7.jpg","comment_is_top":false,"comment_ctime":1644895671,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"阅读Netty之前理解如何基于NIO实现方法：Netty通过一组线程来替代NIO中的seletor线程，以应对连接数量较多时，NIO频繁阻塞，导致数据无法&quot;及时消费&quot;。然后应该还有一种分发数据的机制。大概认为的就这些，等待一会阅读Netty代码后补充。","like_count":0},{"had_liked":false,"id":322407,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2b938b4f.jpg","comment_is_top":false,"comment_ctime":1637374084,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"在图书馆来学习了","like_count":0},{"had_liked":false,"id":314635,"user_name":"Geek_e30e11","can_delete":false,"product_type":"c1","uid":2650394,"ip_address":"","ucode":"DAB14EEE0D960A","user_header":"","comment_is_top":false,"comment_ctime":1633268465,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"感觉只要学好linux中的 \n阻塞io\n非阻塞io\n信号驱动io\n多路复用\n异步io\n就可以理解了","like_count":0},{"had_liked":false,"id":296105,"user_name":"非洲黑猴子","can_delete":false,"product_type":"c1","uid":2639724,"ip_address":"","ucode":"F5FEAC07D562E0","user_header":"https://static001.geekbang.org/account/avatar/00/28/47/6c/78184d19.jpg","comment_is_top":false,"comment_ctime":1622766388,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":4,"product_id":100032301,"comment_content":"Linux下，使用了epoll_create, ctl, wait 三个系统调用，利用mmap以只读的形式跟内核共享内核空间内存，底层数据结构是红黑树和链表，比selector的好处是减少了用户&#47;内核态之间的socket文件描述符的拷贝以及内核态中对所有socket文件描述符的遍历。Redis单线程能这么快，也有赖于epoll和mmap，说到底还是托了Linux内核的福","like_count":0,"discussions":[{"author":{"id":1614410,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","nickname":"老杨在努力","note":"","ucode":"AA541B3BAD53A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4923,"discussion_content":"可以去天池上看一下中间性性能比赛的三届和四届，是一个很好的实践","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565833676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124120,"user_name":"王飞2023","can_delete":false,"product_type":"c1","uid":1111400,"ip_address":"","ucode":"C0F3139B836F39","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1565828315,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"1   本文按理说应该讲的是消息队列中网络的使用，但是实际作者讲的是java的网络基础编程和netty的入门介绍。\n\n2   实际的网络传输，比如rocketmq在发送端也是异步的，而不是同步。\n\n3  对于java的BIO,NIO，包括netty的入门demo，网上文章很多。如何在消息队列的中间件开发中，能高效使用netty，或者说NIO，也不是一件容易的事。","like_count":3,"discussions":[{"author":{"id":1614410,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","nickname":"老杨在努力","note":"","ucode":"AA541B3BAD53A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4923,"discussion_content":"可以去天池上看一下中间性性能比赛的三届和四届，是一个很好的实践","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565833676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171349,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1024763,"ip_address":"","ucode":"F6B5C64BC99FB7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/fb/94af9cf1.jpg","comment_is_top":false,"comment_ctime":1578906368,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"读了本节，又在网上查了查NIO的内容。最后理解如下,NIO核心是增加了缓存层，这样就不用一个连接启用一个线程。缓存跟消息队列一样，做了前端连接和后端线程的分离。利用缓存的中转站借助少量线程实现后端业务处理。NIO减少的是后端线程不是前端的请求连接。这点容易迷惑。","like_count":1},{"had_liked":false,"id":126797,"user_name":"凌霄","can_delete":false,"product_type":"c1","uid":1107786,"ip_address":"","ucode":"19C4BFB0298276","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/4a/4dfb565a.jpg","comment_is_top":false,"comment_ctime":1566478963,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"jsf中netty使用一个线程组boss线程（一个端口一个boss线程）专门处理accept，使用一个线程组work专门处理io，work线程再调用业务线程。","like_count":1},{"had_liked":false,"id":396498,"user_name":"小黄哥","can_delete":false,"product_type":"c1","uid":1102129,"ip_address":"浙江","ucode":"805429DFA5EA93","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/31/d0866990.jpg","comment_is_top":false,"comment_ctime":1734685453,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"Redis也是基于IO多路复用实现了自己的事件驱动框架","like_count":0},{"had_liked":false,"id":369383,"user_name":"小红帽","can_delete":false,"product_type":"c1","uid":1135290,"ip_address":"广东","ucode":"876000FB67C980","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/ba/440c0157.jpg","comment_is_top":false,"comment_ctime":1677479712,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"针对接收数据这个流程，Netty 它是如何用 NIO 来实现的呢？\n没有看过java NIO的代码，从理论来说这里应该有两类线程\n1、等待io的线程，限定数量的seltor监控io流\n2、判断数据接收完成和唤起等待io的线程（事件回调机制）\n所以使用nio来实现的话，首先肯定要先启用一个nio服务监听接口调用，然后数据接收完成后会用一个新的线程来处理业务逻辑。","like_count":0},{"had_liked":false,"id":338702,"user_name":"i_chase","can_delete":false,"product_type":"c1","uid":1795511,"ip_address":"","ucode":"09C41C863F4EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","comment_is_top":false,"comment_ctime":1647674138,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"没有必要一直说java...","like_count":0},{"had_liked":false,"id":334350,"user_name":"邱邱邱","can_delete":false,"product_type":"c1","uid":2611827,"ip_address":"","ucode":"828318EB2316EB","user_header":"https://static001.geekbang.org/account/avatar/00/27/da/73/7e7593a7.jpg","comment_is_top":false,"comment_ctime":1644895671,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"阅读Netty之前理解如何基于NIO实现方法：Netty通过一组线程来替代NIO中的seletor线程，以应对连接数量较多时，NIO频繁阻塞，导致数据无法&quot;及时消费&quot;。然后应该还有一种分发数据的机制。大概认为的就这些，等待一会阅读Netty代码后补充。","like_count":0},{"had_liked":false,"id":322407,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2b938b4f.jpg","comment_is_top":false,"comment_ctime":1637374084,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"在图书馆来学习了","like_count":0},{"had_liked":false,"id":314635,"user_name":"Geek_e30e11","can_delete":false,"product_type":"c1","uid":2650394,"ip_address":"","ucode":"DAB14EEE0D960A","user_header":"","comment_is_top":false,"comment_ctime":1633268465,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"感觉只要学好linux中的 \n阻塞io\n非阻塞io\n信号驱动io\n多路复用\n异步io\n就可以理解了","like_count":0},{"had_liked":false,"id":296105,"user_name":"非洲黑猴子","can_delete":false,"product_type":"c1","uid":2639724,"ip_address":"","ucode":"F5FEAC07D562E0","user_header":"https://static001.geekbang.org/account/avatar/00/28/47/6c/78184d19.jpg","comment_is_top":false,"comment_ctime":1622766388,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":4,"product_id":100032301,"comment_content":"Linux下，使用了epoll_create, ctl, wait 三个系统调用，利用mmap以只读的形式跟内核共享内核空间内存，底层数据结构是红黑树和链表，比selector的好处是减少了用户&#47;内核态之间的socket文件描述符的拷贝以及内核态中对所有socket文件描述符的遍历。Redis单线程能这么快，也有赖于epoll和mmap，说到底还是托了Linux内核的福","like_count":0},{"had_liked":false,"id":296021,"user_name":"LQS  KF","can_delete":false,"product_type":"c1","uid":1364737,"ip_address":"","ucode":"3C0A07A8220094","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/01/716d45b6.jpg","comment_is_top":false,"comment_ctime":1622707198,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"Netty是通过一个事件循环线程(EventLoop)来处理read事件。其中会调用Nio#Selector#select()方法进行多路复用事件监听，收到读请求(SelectionKey)判断，从Channel中读取消息到ByteBuf然后在ChannelPIpeline中传递。通过若干ChannelHandler处理。完成读请求","like_count":0},{"had_liked":false,"id":295713,"user_name":"一颗小橘子🍊","can_delete":false,"product_type":"c1","uid":2045627,"ip_address":"","ucode":"584557A3E26B33","user_header":"https://static001.geekbang.org/account/avatar/00/1f/36/bb/67d689c5.jpg","comment_is_top":false,"comment_ctime":1622555269,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"多路复用io实际上是同步io吧？","like_count":0},{"had_liked":false,"id":269599,"user_name":"老大不小","can_delete":false,"product_type":"c1","uid":1295609,"ip_address":"","ucode":"35BCDD3CB13467","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","comment_is_top":false,"comment_ctime":1608710949,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"netty是使用react模式设计的，采用boss和work分工的设计思想。boss负责接收数据，work负责处理数据。boss一般是单线程，work默认是cpu*2个线程。\n其本质也是使用了nio的selector的多路复用来监控注册在其上的channel,每个channel都有channelPipeline，里面包含inbound和outbound类型的channelHandler。","like_count":0},{"had_liked":false,"id":242260,"user_name":"渠梁","can_delete":false,"product_type":"c1","uid":1488038,"ip_address":"","ucode":"DC86BDEC63C9BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","comment_is_top":false,"comment_ctime":1597651545,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"我记得netty是同步非阻塞，不是异步","like_count":0},{"had_liked":false,"id":236550,"user_name":"子非鱼","can_delete":false,"product_type":"c1","uid":1621660,"ip_address":"","ucode":"020DA0784E728C","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","comment_is_top":false,"comment_ctime":1595465567,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"之前看nio讲的都是同步非阻塞模式，nio2是异步非阻塞。都懵逼了。","like_count":0},{"had_liked":false,"id":215715,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1589082269,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"rpc框架的实现到最后，都很像是实现了一个单机的消息队列。请求的打包解包，请求的队列化，消息按id就行分区。","like_count":0},{"had_liked":false,"id":215712,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1589081472,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"accpet4，sendtofile，gettimeofdate优化，gethostname优化，无锁队列，时间轮超时机制，work线程池，日志异步化。如果要提供协程环境，还可以把phtread的锁，信号量和通知机制hook掉，异步实现。提业务只需实现这样的函数的proc（ctx，req，rsp）","like_count":0},{"had_liked":false,"id":212020,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1588047508,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"这个模型也有个称不上问题的问题，就是如果有一个链接，后续处理时间比较长，那么会阻塞在这个线程上的其他链接。之前我们项目上就因为使用不当导致了所有链接全部瘫痪。用的时候一定要注意","like_count":0},{"had_liked":false,"id":186985,"user_name":"LiYanbin","can_delete":false,"product_type":"c1","uid":1129976,"ip_address":"","ucode":"2F50493F818909","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/f8/b13674e6.jpg","comment_is_top":false,"comment_ctime":1583983728,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"个人理解：\n这边的要讲的异步是应用层的收发异步，即读写异步，那么只要配合底层接口实现的多路IO复用机制（或者理解为事件通知机制），就能实现\n跟原来的阻塞等待的优点是，内核会把进程或者线程挂起，也就不会有频繁的线程切换。","like_count":0},{"had_liked":false,"id":184626,"user_name":"释然","can_delete":false,"product_type":"c1","uid":1264381,"ip_address":"","ucode":"23BE77AB5DCDF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/fd/047518b0.jpg","comment_is_top":false,"comment_ctime":1583373984,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"NIO 和 golang 的 goroutine 比较像","like_count":0},{"had_liked":false,"id":296021,"user_name":"LQS  KF","can_delete":false,"product_type":"c1","uid":1364737,"ip_address":"","ucode":"3C0A07A8220094","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/01/716d45b6.jpg","comment_is_top":false,"comment_ctime":1622707198,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"Netty是通过一个事件循环线程(EventLoop)来处理read事件。其中会调用Nio#Selector#select()方法进行多路复用事件监听，收到读请求(SelectionKey)判断，从Channel中读取消息到ByteBuf然后在ChannelPIpeline中传递。通过若干ChannelHandler处理。完成读请求","like_count":0},{"had_liked":false,"id":295713,"user_name":"一颗小橘子🍊","can_delete":false,"product_type":"c1","uid":2045627,"ip_address":"","ucode":"584557A3E26B33","user_header":"https://static001.geekbang.org/account/avatar/00/1f/36/bb/67d689c5.jpg","comment_is_top":false,"comment_ctime":1622555269,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"多路复用io实际上是同步io吧？","like_count":0},{"had_liked":false,"id":269599,"user_name":"老大不小","can_delete":false,"product_type":"c1","uid":1295609,"ip_address":"","ucode":"35BCDD3CB13467","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","comment_is_top":false,"comment_ctime":1608710949,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"netty是使用react模式设计的，采用boss和work分工的设计思想。boss负责接收数据，work负责处理数据。boss一般是单线程，work默认是cpu*2个线程。\n其本质也是使用了nio的selector的多路复用来监控注册在其上的channel,每个channel都有channelPipeline，里面包含inbound和outbound类型的channelHandler。","like_count":0},{"had_liked":false,"id":242260,"user_name":"渠梁","can_delete":false,"product_type":"c1","uid":1488038,"ip_address":"","ucode":"DC86BDEC63C9BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","comment_is_top":false,"comment_ctime":1597651545,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"我记得netty是同步非阻塞，不是异步","like_count":0},{"had_liked":false,"id":236550,"user_name":"子非鱼","can_delete":false,"product_type":"c1","uid":1621660,"ip_address":"","ucode":"020DA0784E728C","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","comment_is_top":false,"comment_ctime":1595465567,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"之前看nio讲的都是同步非阻塞模式，nio2是异步非阻塞。都懵逼了。","like_count":0},{"had_liked":false,"id":215715,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1589082269,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"rpc框架的实现到最后，都很像是实现了一个单机的消息队列。请求的打包解包，请求的队列化，消息按id就行分区。","like_count":0},{"had_liked":false,"id":215712,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1589081472,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"accpet4，sendtofile，gettimeofdate优化，gethostname优化，无锁队列，时间轮超时机制，work线程池，日志异步化。如果要提供协程环境，还可以把phtread的锁，信号量和通知机制hook掉，异步实现。提业务只需实现这样的函数的proc（ctx，req，rsp）","like_count":0},{"had_liked":false,"id":212020,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1588047508,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"这个模型也有个称不上问题的问题，就是如果有一个链接，后续处理时间比较长，那么会阻塞在这个线程上的其他链接。之前我们项目上就因为使用不当导致了所有链接全部瘫痪。用的时候一定要注意","like_count":0},{"had_liked":false,"id":186985,"user_name":"LiYanbin","can_delete":false,"product_type":"c1","uid":1129976,"ip_address":"","ucode":"2F50493F818909","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/f8/b13674e6.jpg","comment_is_top":false,"comment_ctime":1583983728,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"个人理解：\n这边的要讲的异步是应用层的收发异步，即读写异步，那么只要配合底层接口实现的多路IO复用机制（或者理解为事件通知机制），就能实现\n跟原来的阻塞等待的优点是，内核会把进程或者线程挂起，也就不会有频繁的线程切换。","like_count":0},{"had_liked":false,"id":184626,"user_name":"释然","can_delete":false,"product_type":"c1","uid":1264381,"ip_address":"","ucode":"23BE77AB5DCDF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/fd/047518b0.jpg","comment_is_top":false,"comment_ctime":1583373984,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"NIO 和 golang 的 goroutine 比较像","like_count":0},{"had_liked":false,"id":156226,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574839648,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"有点枯燥,有点难.","like_count":0},{"had_liked":false,"id":154358,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574414843,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"不行, 不太适合我有点高深了, 我先缓缓以后学","like_count":0},{"had_liked":false,"id":135758,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1569253842,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"讲的非常好，Nginx的能支撑高并发，也是多路复用，底层原理一样，因为都依赖OS的seIect，epoⅠⅠ","like_count":0},{"had_liked":false,"id":133195,"user_name":"go...go","can_delete":false,"product_type":"c1","uid":1102589,"ip_address":"","ucode":"1746CE5BD3B891","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/fd/3400f1b5.jpg","comment_is_top":false,"comment_ctime":1568440487,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"听过音频后，有所感悟整理如下:\n同步模式下： 多个连接对应多个线程。连接存活不活跃的情况下，线程始终处于等待资源的状态。 存在线程资源浪费&#47;占用内存的情况。当同时存在多个活跃连接时，连接越多线程越多，线程线上下文切换越频繁，从而产生其他开销。\n异步模式下：多个连接对应单个或少量线程。连接不活跃的时候，只有少部分线程处于等待资源的状态。资源浪费和内存占用较少。当同时存在多个活跃连接的时候，将写入动作以事件的方式发送给相应的处理组件。处理组件的线程数量可控，在满足业务需要的情况下，线程上下文切换相对减少。\n两种模式在少量连接请求的情况下，处理效果差不多。但随着请求的增多，同步模式会更早的达到性能瓶颈。\n","like_count":0},{"had_liked":false,"id":128672,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1566949162,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"IO阻塞线程导致load升高吧，不是cpu","like_count":0},{"had_liked":false,"id":125239,"user_name":"Colin","can_delete":false,"product_type":"c1","uid":1005481,"ip_address":"","ucode":"39234AE54BAE3D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/a9/fe93beac.jpg","comment_is_top":false,"comment_ctime":1566129551,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"我觉得这一章完全可以带过","like_count":0},{"had_liked":false,"id":124999,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1566038827,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"今天坐了8个小时火车，正好把课程看一遍。老师课程写的非常好，一口气读完毫无枯燥敢。回答一下今天的问题:同一个数据在不同操作系统中的表示形式不同，可能导致程序无法被读出;内存里面的数据还会包含很多对象引用，类应用，这些存的都是内存地址，当你再次加载到内存时，这些引用都是失效的。","like_count":0},{"had_liked":false,"id":124242,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1565840871,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"Netty 它是如何用 NIO 来实现的呢？\n不是写Java的，尝试来答一下，应该是类似Nginx，一个主线程，多个worker线程，用epoll管理多路复用套接字，主线程将连接通过负载均衡算法分配到worker线程。","like_count":0},{"had_liked":false,"id":124222,"user_name":"ly","can_delete":false,"product_type":"c1","uid":1221628,"ip_address":"","ucode":"5E2B85252DABF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/fc/379387a4.jpg","comment_is_top":false,"comment_ctime":1565837000,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"netty用得很少，其原理不太清楚，但是用java的nio写过简单的非生产程序。我的大致猜测：\n他的serverbootstrap的bind就是调用serversocketchannel的bind并且accept","like_count":0},{"had_liked":false,"id":156226,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574839648,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"有点枯燥,有点难.","like_count":0},{"had_liked":false,"id":154358,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574414843,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"不行, 不太适合我有点高深了, 我先缓缓以后学","like_count":0},{"had_liked":false,"id":135758,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1569253842,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"讲的非常好，Nginx的能支撑高并发，也是多路复用，底层原理一样，因为都依赖OS的seIect，epoⅠⅠ","like_count":0},{"had_liked":false,"id":133195,"user_name":"go...go","can_delete":false,"product_type":"c1","uid":1102589,"ip_address":"","ucode":"1746CE5BD3B891","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/fd/3400f1b5.jpg","comment_is_top":false,"comment_ctime":1568440487,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"听过音频后，有所感悟整理如下:\n同步模式下： 多个连接对应多个线程。连接存活不活跃的情况下，线程始终处于等待资源的状态。 存在线程资源浪费&#47;占用内存的情况。当同时存在多个活跃连接时，连接越多线程越多，线程线上下文切换越频繁，从而产生其他开销。\n异步模式下：多个连接对应单个或少量线程。连接不活跃的时候，只有少部分线程处于等待资源的状态。资源浪费和内存占用较少。当同时存在多个活跃连接的时候，将写入动作以事件的方式发送给相应的处理组件。处理组件的线程数量可控，在满足业务需要的情况下，线程上下文切换相对减少。\n两种模式在少量连接请求的情况下，处理效果差不多。但随着请求的增多，同步模式会更早的达到性能瓶颈。\n","like_count":0},{"had_liked":false,"id":128672,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1566949162,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"IO阻塞线程导致load升高吧，不是cpu","like_count":0},{"had_liked":false,"id":125239,"user_name":"Colin","can_delete":false,"product_type":"c1","uid":1005481,"ip_address":"","ucode":"39234AE54BAE3D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/a9/fe93beac.jpg","comment_is_top":false,"comment_ctime":1566129551,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"我觉得这一章完全可以带过","like_count":0},{"had_liked":false,"id":124999,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1566038827,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"今天坐了8个小时火车，正好把课程看一遍。老师课程写的非常好，一口气读完毫无枯燥敢。回答一下今天的问题:同一个数据在不同操作系统中的表示形式不同，可能导致程序无法被读出;内存里面的数据还会包含很多对象引用，类应用，这些存的都是内存地址，当你再次加载到内存时，这些引用都是失效的。","like_count":0},{"had_liked":false,"id":124242,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1565840871,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"Netty 它是如何用 NIO 来实现的呢？\n不是写Java的，尝试来答一下，应该是类似Nginx，一个主线程，多个worker线程，用epoll管理多路复用套接字，主线程将连接通过负载均衡算法分配到worker线程。","like_count":0},{"had_liked":false,"id":124222,"user_name":"ly","can_delete":false,"product_type":"c1","uid":1221628,"ip_address":"","ucode":"5E2B85252DABF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/fc/379387a4.jpg","comment_is_top":false,"comment_ctime":1565837000,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"netty用得很少，其原理不太清楚，但是用java的nio写过简单的非生产程序。我的大致猜测：\n他的serverbootstrap的bind就是调用serversocketchannel的bind并且accept","like_count":0}]}