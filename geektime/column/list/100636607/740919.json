{"id":740919,"title":"第 11 章 使用 JavaScript 实现浏览器的动态 HTTP 请求","content":"\n    \n    <p>本章将介绍 JavaScript 环境提供的一些 API。为了让大家理解浏览器的行为背后所进行的 HTTP 通信，前面的章节重点介绍了浏览器的动作，比如第一次加载页面时的 <code>GET</code> 请求、Cookie\n        和缓存等的相关内容。</p>\n    <p>除全局导航之外，其他的动态服务器访问都是使用 JavaScript 实现的。JavaScript 可以实现的操作越广泛，网站实现中能够使用的功能就越多。JavaScript 是拓宽 Web\n        可能性必不可少的一种手段。本章将介绍浏览器上的 JavaScript 所拥有的可以进行各种通信及 HTTP 相关处理的 API。</p>\n    <h2 id=\"nav_point_269\">11.1　浏览器的 HTTP 与生命周期</h2>\n    <p>浏览器执行 HTTP 访问的地方主要有两处，分别是加载网站和加载后使用 JavaScript 进行访问。</p>\n    <p>在地址栏中输入 URL，点击 <code>&lt;a&gt;</code> 标签的链接，执行表单发送等操作后，浏览器就会获取新的内容。该访问是通过 HTTP 执行的。</p>\n    <p>浏览器查看返回的内容的 <code>Content-Type</code>，如果能显示该内容，就清除整个画面，显示该内容。这种重置浏览器画面的请求称为全局导航。当内容是 HTML 时，其引用的样式表、图像、Web 字体和\n        JavaScript 等文件也是通过 HTTP 请求并下载的。</p><!-- [[[read_end]]] -->\n    <p>如果返回的内容中存在 <code>Content-Disposition</code> 首部，指示下载的内容不显示在浏览器中，那么将不清除画面，将内容下载到计算机的“下载”文件夹等中。</p>\n    <p>使用 JavaScript 的 API 也可以执行 HTTP 访问。在画面显示结束、执行 JavaScript 时，如果其中使用了进行通信的功能，就也会进行通信。在 XMLHttpRequest、Fetch 和 Server\n        Sent Events 的情况下进行的是 HTTP 通信，否则进行 WebSocket 或 WebRTC 通信。使用 JavaScript 实现的通信所获取的内容由 JavaScript 处理。</p>\n    <h2 id=\"nav_point_270\">11.2　XMLHttpRequest</h2>\n    <p>XMLHttpRequest 最早由 Microsoft 引入，后来实现了标准化。XMLHttpRequest 在技术上能够实现 Ajax，由此形成了新的 Web 表现形式，掀起了被称为 Web 2.0 的运动。第 4\n        章介绍了 XMLHttpRequest 的历史，本节将介绍它的用法。</p>\n    <pre class=\"code-rows\"><code>var xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"/json\", true);\nxhr.onload = function () {\n    // 返回响应时调用的方法\n    if (xhr.status === 200) {\n        // 解析 JSON 并显示\n        console.log(JSON.parse(xhr.responseText));\n    }\n};\nxhr.setRequestHeader(\"MyHeader\", \"HeaderValue\")\nxhr.send();</code></pre>\n    <p>URL 是相对地址，所以上面的代码不会实际运行，它与下面的模拟命令表示的含义相同。</p>\n    <pre class=\"code-rows\"><code>$ curl -H \"MyHeader=HeaderValue\" /json</code></pre>\n    <p><code>open()</code> 方法用于指定方法和发送目的地。如果将第 3 个参数设置为 <code>true</code>，则变为异步执行。在同步执行的情况下，<code>send()</code>\n        方法在响应返回之前不会结束。而且在发生阻塞后，用户的操作不会得到响应，这时大家会觉得网站的反应速度太慢。因此，相信不会有人使用 <code>true</code> 之外的值。</p>\n    <p>使用 <code>send()</code> 方法开始发送数据。将数据传递给该方法，该方法就会将数据发送给服务器。</p>\n    <pre class=\"code-rows\"><code>var xhr = new XMLHttpRequest();\nxhr.open(\"POST\", \"/json\", true);\nxhr.onload = function () {\n    // 返回响应时调用的方法\n}\nxhr.send(JSON.stringify({\"message\": \"hello world\"}));</code></pre>\n    <p>curl 中使用 <code>-d</code> 传递数据。要想从文件中读取要发送的 JSON，需要使用 <code>@</code> 指定文件名，或者使用 <code>-T</code>。</p>\n    <pre class=\"code-rows\"><code>$ curl -d @send.json /json\n\n$ curl -T send.json /json</code></pre>\n    <p>另外，XMLHttpRequest 存在两个版本，这里介绍的是名为 Level 2 的新版本。上网查一下 XMLHttpRequest\n        就可以找到许多关于旧版本的信息。虽然两个版本在后面介绍的安全问题上存在差别，但二者的设计框架和思想基本相同，因此本书只介绍 Level 2。</p>\n    <h3 id=\"nav_point_271\">处理各种数据格式</h3>\n    <p>XMLHttpRequest 支持许多数据格式。通过在 <code>responseType</code> 中设置字符串，可以指定在 <code>response</code>\n        中存储哪种对象的返回值。下面的代码用于接收持有文件种类和二进制数据的 <code>Blob</code> 对象，并使用 <code>img</code> 标签进行显示。</p>\n    <pre class=\"code-rows\"><code>xhr.responseType = 'blob';\nxhr.onload = function(e) {\n    if (this.status == 200) {\n        var blob = this.response;\n        var img = document.createElement('img');\n        img.onload = function(e) {\n            window.URL.revokeObjectURL(img.src);\n        };\n        img.src = window.URL.createObjectURL(blob);\n        document.body.appendChild(img);\n        ︙\n    }\n};\nxhr.send();</code></pre>\n    <p><code>responseType</code> 中可以设置的字符串如表 11-1 所示。</p>\n    <p><strong>表 11-1　responseType 中可以设置的字符串</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>设置值</p>\n                </th>\n                <th>\n                    <p>数据类型</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p><code>arraybuffer</code></p>\n                </td>\n                <td>\n                    <p>ArrayBuffer</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>blob</code></p>\n                </td>\n                <td>\n                    <p>Blob</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>document</code></p>\n                </td>\n                <td>\n                    <p>Document</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>json</code></p>\n                </td>\n                <td>\n                    <p>JSON</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>xml</code></p>\n                </td>\n                <td>\n                    <p>XML</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>text</code></p>\n                </td>\n                <td>\n                    <p>string（默认）</p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <p>在未设置 <code>responseType</code> 的情况下，如果数据是 XML 的 MIME\n        类型（<code>text/xml</code>、<code>application/xml</code>），就以字符串形式存储在 <code>responseXML</code> 中，否则存储在\n        <code>responseText</code> 中。如果服务器未设置 MIME 类型，则由客户端指定 MIME 类型。</p>\n    <h2 id=\"nav_point_272\">11.3　FetchAPI</h2>\n    <p>Fetch API 是实现了标准化的 API，比 XMLHttpRequest 更易使用，XMLHttpRequest 能做的事情也都可以由 Fetch API 实现。除此之外，Fetch API\n        还可以实现缓存控制等细致的内容。</p>\n    <p>本节将介绍 Fetch API 的使用方法。</p>\n    <h3 id=\"nav_point_273\">11.3.1　FetchAPI 的基础内容</h3>\n    <p>代码清单 11-1 是使用 Fetch API 的示例代码。</p>\n    <p><strong>代码清单 11-1　使用 Fetch API 的 JavaScript 示例代码</strong></p>\n    <pre class=\"code-rows\"><code>const response = await fetch(\"news.json\", { // ❶ ❸\n    method: 'GET',                          // ❷\n    mode: 'cors',\n    credentials: 'include',\n    cache: 'default',\n    headers: {\n        'Content-Type': 'application/json'\n    }\n});\nconsole.log(response.status);               // ❹\nif (response.ok) {                          // ❺\n    const json = await response.json();     // ❻\n    console.log(json);\n}</code></pre>\n    <blockquote>\n        <p>❶ 和 XMLHttpRequest 一样，不创建对象，而是调用 <code>fetch()</code> 函数。</p>\n        <p>❷ <code>fetch()</code> 函数的第二个参数是可选对象（可省略）。</p>\n        <p>❸ 由于 <code>fetch()</code> 是异步处理，所以加上 <code>await</code> 以等待服务器响应。</p>\n        <p>❹ 服务器响应中包含首部和状态码。<code>status</code> 属性中包含状态码。</p>\n        <p>❺ 当状态码是 <code>200</code> ~ <code>299</code> 的正常响应时，<code>ok</code> 属性为 <code>true</code>。</p>\n        <p>❻ 由于响应主体的读取和解析比较耗时，所以加上 <code>await</code> 进行等待。</p>\n    </blockquote>\n    <p>下面的示例代码中省略了所有的选项，仅使用 <code>GET</code> 读取 JSON，代码很短。</p>\n    <pre class=\"code-rows\"><code>const response = await fetch(\"news.json\");\nif (response.ok) {\n    const json = await response.json();\n    console.log(json);\n}</code></pre>\n    <p>JavaScript 中使用 <code>await</code> 来等待比较耗时的处理的结果。<code>fetch()</code> 等函数在执行繁重（需要等待）的处理时会返回 <code>Promise</code>\n        对象，<code>Promise</code> 对象根据结束时的返回值来判断处理是否正常结束。<code>Promise</code> 是表示“稍后通知处理结束的结果哦”的“约定”。将 <code>await</code>\n        添加到返回 <code>Promise</code> 的函数之前，以等待约定达成。</p>\n    <p><code>fetch()</code> 只处理一个来回的通信，所以看起来只有一处处理比较繁重，但其实有两处。</p>\n    <blockquote>\n        <ul>\n            <li>进行 HTTP 通信，等待服务器返回响应，完成最开始的首部部分的解析</li>\n            <li>然后读取整个主体</li>\n        </ul>\n    </blockquote>\n    <h3 id=\"nav_point_274\">11.3.2　Fetch 的选项</h3>\n    <p>前面的示例代码采用了 JSON 形式来读取数据，Fetch API 支持的数据类型如表 11-2 所示。</p>\n    <p><strong>表 11-2　Fetch API 支持的数据类型</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>方法</p>\n                </th>\n                <th>\n                    <p>类型</p>\n                </th>\n                <th>\n                    <p>说明</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p><code>arrayBuffer()</code></p>\n                </td>\n                <td>\n                    <p>ArrayBuffer</p>\n                </td>\n                <td>\n                    <p>固定长度的二进制数据。可以使用 <code>Typed Array</code> 进行读写</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>blob()</code></p>\n                </td>\n                <td>\n                    <p>Blob</p>\n                </td>\n                <td>\n                    <p>表示文件内容的 MIME 类型 + 二进制数据。可以通过 <code>FileReader</code> 转换为 <code>ArrayBuffer</code>\n                    </p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>formData()</code></p>\n                </td>\n                <td>\n                    <p>FormData</p>\n                </td>\n                <td>\n                    <p>与 HTML 表单互换的成对的名称与值</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>json()</code></p>\n                </td>\n                <td>\n                    <p>Object</p>\n                </td>\n                <td>\n                    <p>解析 JSON，由 JavaScript 的对象、数组等构成的对象</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>text()</code></p>\n                </td>\n                <td>\n                    <p>string</p>\n                </td>\n                <td>\n                    <p>字符串</p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <p>我们可以使用选项来自定义各种项目。如表 11-3 所示，有一部分方法无法使用。另外，<code>GET</code>、<code>HEAD</code>、<code>POST</code> 这 3 个方法会以 CORS\n        安全的方式处理。</p>\n    <p><strong>表 11-3　Fetch API 中可使用的方法</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>项目</p>\n                </th>\n                <th>\n                    <p>方法</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p>CORS 安全</p>\n                </td>\n                <td>\n                    <p><code>GET</code>、<code>HEAD</code>、<code>POST</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>禁止方法</p>\n                </td>\n                <td>\n                    <p><code>CONNECT</code>、<code>TRACE</code>、<code>TRACK</code></p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <p>作为安全对策，Fetch API 通过如表 11-4 所示的设置值来表示 CORS 模式。在 XMLHttpRequest 的情况下，模式无法修改。</p>\n    <p><strong>表 11-4　Fetch API 的 CORS 模式</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>设置值</p>\n                </th>\n                <th>\n                    <p>Fetch 默认</p>\n                </th>\n                <th>\n                    <p>XHR 默认</p>\n                </th>\n                <th>\n                    <p>说明</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p><code>cors</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>允许访问其他源服务器</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>same-origin</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>在访问其他源服务器时发生错误</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>no-cors</code></p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>无视 CORS 连接，返回空响应</p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <p>除此之外，可设置的值还有 <code>navigate</code>、<code>websocket</code>、<code>cors-with-forced-preflight</code> 等。</p>\n    <p>对 Cookie 的限制是在 <code>credentials</code> 中设置的，能够设置的值如表 11-5 所示。在 XMLHttpRequest 中，将 <code>withCredential</code>\n        属性设置为 <code>true</code> 与设置 <code>include</code> 的效果是一样的。</p>\n    <p><strong>表 11-5　Fetch API 的 credentials 中可以设置的值</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>设置值</p>\n                </th>\n                <th>\n                    <p>Fetch 默认</p>\n                </th>\n                <th>\n                    <p>XHR 默认</p>\n                </th>\n                <th>\n                    <p>说明</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p><code>omit</code></p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>不发送 Cookie</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>same-origin</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>仅在同源的情况下发送 Cookie</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>include</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>发送 Cookie</p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <p>Web 的发展是速度和安全性两方面提升的结果，Fetch API 属于后者。它的设计理念是，默认选择更严格的设置，然后根据需要显式解除该设置。</p>\n    <h3 id=\"nav_point_275\">11.3.3　创建和解析查询参数</h3>\n    <p>在使用 <code>GET</code> 方法发送数据时，可以使用 <code>URLSearchParams</code> 创建和解析参数。虽然现在仍有很多示例代码是使用历史悠久的\n        <code>encodeURIComponent()</code> 编写的，但大家尽量还是使用 <code>URLSearchParams</code> 比较好。这样一来，这些代码也可以用于 Internet\n        Explorer 之外的浏览器。</p>\n    <p><code>set()</code> 方法可以用来向查询参数中添加数据。除此之外，也可以使用 <code>append()</code> 方法。查询参数类似于编程语言中提供的映射、散列和字典等数据结构，一个键对应多个值。使用\n        <code>append()</code> 可以为一个键设置多个值（代码清单 11-2）。</p>\n    <p><strong>代码清单 11-2　查询参数的结构</strong></p>\n    <pre class=\"code-rows\"><code>const params = new URLSearchParams();\n// 使用 set 添加数据\nparams.set(\"name\", \" 惠比寿东公园\");\n// 也可以使用 append 添加数据\nparams.append(\"hasTako\", \"true\");\n// 使用 toString() 获取字符串格式的数据\nconsole.log(params.toString());\n// name=%E6%81%B5%E6%AF%94%E5%AF%BF%E6%9D%B1%E5%85%AC%E5%9C%92&amp;hasTako=true</code></pre>\n    <p>查询参数的解析使用同一个类。将查询参数的字符串设置到 <code>constructor</code> 属性中，可以创建一个已经设置好值的实例，然后就可以使用该实例的 <code>has()</code> 方法或\n        <code>get()</code> 方法来检查键是否存在，并获取值（代码清单 11-3）。</p>\n    <p><strong>代码清单 11-3　解析查询参数</strong></p>\n    <pre class=\"code-rows\"><code>const params = new URLSearchParams(location.search);\n// 使用 has 判断指定的键是否存在\nparams.has(\"name\");\n// 使用 get 获取指定键的值\nparams.get(\"hasTako\");</code></pre>\n    <p>当同一个键包含多个值时，可以使用 <code>getAll()</code> 方法获取一个包含所有值的数组。</p>\n    <p>JavaScript 自带的 <code>Map</code> 结构与方法名一样用起来很方便。我们也可以使用 <code>for</code> 循环来一并获取键和值（代码清单 11-4）。</p>\n    <p><strong>代码清单 11-4　使用循环获取键和值</strong></p>\n    <pre class=\"code-rows\"><code>for (const [key, vakue] of params.entries()) {\n    console.log(`$: $`);\n}</code></pre>\n    <h3 id=\"nav_point_276\">11.3.4　发送主体</h3>\n    <p>本章开头的示例代码中包含了 HTTP 的 4 个基本元素中的以下 3 个。另外，上一节还介绍了路径元素中查询参数的相关内容。</p>\n    <blockquote>\n        <ul>\n            <li>方法和路径</li>\n            <li>首部</li>\n            <li>状态码</li>\n        </ul>\n    </blockquote>\n    <p>而主体可以通过 Fetch API 的第 2 个参数来实现。</p>\n    <p><strong>application/x-www-form-urlencoded 形式的表单发送</strong></p>\n    <p>首先，我们按表单的默认发送方式（无法发送文件），使用 JavaScript 发送相同的内容。</p>\n    <p>我们试着从浏览器发送第 2 章的示例代码中的 curl 命令，如下所示。</p>\n    <pre class=\"code-rows\"><code>$ curl --http1.0 -d title=\"The Art of Community\" -d author=\"Jono Bacon\" http://\nlocalhost:18888</code></pre>\n    <p>严格来讲，<code>application/x-www-form-urlencoded</code> 的处理与其存在不同之处，但它们的 URL 都使用了百分号编码。因此，通过\n        <code>URLSearchParams</code>，我们就可以使用 JavaScript 来模拟表单的发送（代码清单 11-5）。</p>\n    <p><strong>代码清单 11-5　以 application/x-www-form-urlencoded 形式发送</strong></p>\n    <pre class=\"code-rows\"><code>const form = new URLSearchParams();\nform.set(\"title\", \"The Art of Community\");\nform.set(\"author\", \"Jono Bacon\");\n\nconst res = await fetch(\"/post\", {\n    method: \"POST\",\n    body: form\n});</code></pre>\n    <p><strong>multipart/form-data 形式的表单发送</strong></p>\n    <p>我们也可以使用 Fetch 来实现 <code>multipart/form-data</code> 形式的表单发送。</p>\n    <pre class=\"code-rows\"><code>$ curl --http1.0 -F title=\"The Art of Community\" -F author=\"Jono Bacon\" -F\nattachment-file=@test.txt http://localhost:18888</code></pre>\n    <p>将 <code>URLSearchParams</code> 替换为 <code>FormData</code> 基本上就可以了（代码清单 11-6）。</p>\n    <p><strong>代码清单 11-6　以 multipart/form-data 形式发送</strong></p>\n    <pre class=\"code-rows\"><code>const form = new FormData();\nform.set(\"title\", \"The Art of Community\");\nform.set(\"author\", \"Jono Bacon\");\n// 添加文件\nconst content = \"Hello World\";\nconst blob = new Blob([content], { type: \"text/plain\"});\nform.set(\"attachement-file\", blob, \"test.txt\");\n\nconst res = await fetch(\"/post\", {\n    method: \"POST\",\n    body: form\n});</code></pre>\n    <p>虽然这里使用 JavaScript 创建了相当于文件内容的内容，但我们也可以添加本地文件进行发送。不过，根据安全方面的要求，浏览器不可以自行查找本地文件。浏览器只可以访问经用户允许的文件。具体来讲，就是使用\n        <code>&lt;input&gt;</code> 标签创建文件选择器，访问用户选择的指定文件（代码清单 11-7）。</p>\n    <p><strong>代码清单 11-7　发送使用 input 标签的选择器选择的文件</strong></p>\n    <pre class=\"code-rows\"><code>const fileElement = document.querySelector(\"input[type=file]\");\nform.set(\"attachement-file\", fileElement.files[0]);</code></pre>\n    <p><strong>发送和接收 JSON</strong></p>\n    <p>近年来，作为 Web 应用程序的主角的 JSON 的发送操作也很简单。如果发送字符串，那么我们只要指定合适的 <code>Content-Type</code> 就可以了（代码清单 11-8）。</p>\n    <p><strong>代码清单 11-8　以 JSON 形式发送</strong></p>\n    <pre class=\"code-rows\"><code>const res = await fetch(\"/post\", {\n    method: \"POST\",\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n        \"title\": \"The Art of Community\",\n        \"author\": \"Jono Bacon\"\n    })\n});</code></pre>\n    <h3 id=\"nav_point_277\">11.3.5　只有 FetchAPI 可以执行的操作</h3>\n    <p><strong>缓存控制</strong></p>\n    <p>在介绍 Fetch API 的特征时，人们最常提到的就是缓存。Fetch API 可以对缓存进行控制，其中，可设置的值如表 11-6 所示。</p>\n    <p><strong>表 11-6　Fetch API 的缓存控制中可以设置的值</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>设置值</p>\n                </th>\n                <th>\n                    <p>默认</p>\n                </th>\n                <th>\n                    <p>说明</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p><code>default</code></p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>遵循标准的浏览器动作</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>no-store</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>请求时忽略缓存，也不缓存结果</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>reload</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>与浏览器的重新加载一样，请求时忽略缓存，不发送 <code>ETag</code> 等。如果可以缓存，则缓存结果</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>no-cache</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>即使缓存未过期，也发送 HTTP 请求，同时发送本地缓存的 <code>ETag</code> 等，如果服务器返回 <code>304</code>，则使用缓存的内容\n                    </p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>force-cache</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>即使缓存过期，也可以使用。如果没有缓存，则发送 HTTP 请求</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>only-if-cached</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>即使缓存过期，也可以使用。如果没有缓存，则报错</p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <p>在使用 <code>no-store</code>、<code>reload</code>、<code>no-cache</code> 的情况下，无论缓存状态如何，浏览器都会强行发起请求。在使用\n        <code>no-cache</code> 的情况下，由于会发送缓存相关的信息，所以在不发送主体的情况下，也可能会收到 <code>304 Not Modified</code>。</p>\n    <p>相反，主动使用缓存的是 <code>force-cache</code> 和 <code>only-if-cached</code>。即使超过了 <code>Max-Age</code>\n        首部指定的期限，也会使用缓存。<code>only-if-cached</code> 在没有缓存的情况下会报错，因此不会向外部发送请求。</p>\n    <p><strong>重定向控制</strong></p>\n    <p>在重定向控制方面，可设置的值如表 11-7 所示。</p>\n    <p><strong>表 11-7　Fetch API 的重定向控制中可以设置的值</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>设置值</p>\n                </th>\n                <th>\n                    <p>默认</p>\n                </th>\n                <th>\n                    <p>说明</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p><code>follow</code></p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>跟随重定向（最多 20 个重定向）</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>manual</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>不跟随重定向，仅表明存在重定向</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p><code>error</code></p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>抛出网络错误</p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <p>当值为 <code>manual</code> 时，如果存在重定向，那么返回的就不是响应本身，而是对响应进行包装、过滤后的内容。该响应的 <code>type</code> 属性中仅存储\n        <code>opaqueredirect</code> 字符串，其他信息都被过滤掉了，这是因为重定向的过程中包含了不可以泄露的 URL 和首部。由于主体为 <code>null</code>，状态码为\n        0，而且无法获取首部，所以我们只能知道“存在重定向”这件事。与 <code>error</code> 不同，该值不会报错。</p>\n    <p><strong>支持 Service Worker</strong></p>\n    <p>有一些功能能够通过 Fetch API 实现，但无法通过 XMLHttpRequest 实现，其中最典型的就是 Service Worker。当前的规范规定，当从 Service Worker 内部连接外部服务时，仅可以使用\n        Fetch API。</p>\n    <p>以 Google 为中心的组织提出了让 Web 拥有应用程序的功能特性的 PWA（Progressive Web App，渐进式网页应用）技术。Service Worker 作为 PWA\n        的核心，是以控制应用程序的生命周期和通信内容为目的开发的。支持 Service Worker 的 Web 服务可以离线运行，也可以处理通知。Service Worker 是在 Web 服务的前端 JavaScript\n        和服务器之间运行的中间层。</p>\n    <h3 id=\"nav_point_278\">11.3.6　使用 FetchAPI 时常见的错误</h3>\n    <p>Fetch API 提供了灵活易用的 API，所谓灵活，就是即使设置上有些许错误，也能得到正确的结果。</p>\n    <p>首部的 <code>Content-Type</code> 中忘记设置 <code>application/json</code> 是发送 JSON 时的常见错误之一。在这种情况下，虽然可以发送\n        JSON，但实现比较严格的服务器有时无法判断内容，从而发生错误。除此之外，由于 JSON 无法自动转换为文本，所以忘记设置 <code>JSON.stringify()</code> 也会引发错误。</p>\n    <p>另外，我们还要注意浏览器默认并不发送 Cookie。要想发送 Cookie，第 2 个参数必须设置为 <code>credentials: true</code>（代码清单 11-9）。</p>\n    <p><strong>代码清单 11-9　以 JSON 形式发送</strong></p>\n    <pre class=\"code-rows\"><code>const res = await fetch(\"/post\", {\n    method: \"POST\",\n    credentials: true,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n        \"title\": \"The Art of Community\",\n        \"author\": \"Jono Bacon\"\n    })\n});</code></pre>\n    <p>在 API 需要认证的情况下，如果不加上 <code>credentials</code>，服务器就会返回错误。而且，如果未使用 <code>Response</code> 的 <code>ok</code>\n        属性确认状态码，<code>json()</code> 方法就会抛出异常。该方法内部会直接调用 <code>JSON.parse()</code>。当状态码为 <code>403</code> 时，如果解析\n        <code>Forbidden</code> 字符串，就会发生“<code>Unexpected token F in JSON at position 0</code>”的错误（代码清单 11-10）。</p>\n    <p><strong>代码清单 11-10　以 JSON 形式发送</strong></p>\n    <pre class=\"code-rows\"><code>const json = await response.json();\n// SyntaxError: Unexpected token F in JSON at position 0</code></pre>\n    <h3 id=\"nav_point_279\">11.3.7　在浏览器之外的 JavaScript 环境中使用 FetchAPI</h3>\n    <p>Node.js 默认不支持 Fetch API，但可以通过 <code>npm</code> 中的 <code>node-fetch</code> 包使用 Fetch API。如果使用\n        <code>isomorphic-fetch</code>、<code>isomorphic-unfetch</code>、<code>cross-fetch</code> 等包，则浏览器和 Node.js\n        可以通过相同的代码来使用 Fetch API。除此之外，<code>cross-fetch</code> 使得 React Native 也可以使用 Fetch API。</p>\n    <p>浏览器会显示某个网站，Fetch API 也可以指定访问相对路径或无域名的绝对路径（以 <code>/</code> 开头）。在这种情况下，我们可以根据浏览器中显示的 URL 导出访问目的地。由于 Node.js\n        中没有当前路径的概念，所以 Fetch API 中只能指定包含域名的 URL。这一点请大家注意。</p>\n    <h2 id=\"nav_point_280\">11.4　使用 JavaScript 重新加载浏览器时的 HTTP 访问</h2>\n    <p>前面介绍了通过 XMLHttpRequest 或 Fetch API 可以使用 JavaScript 进行通信，并处理通信结果。这样一来，即使浏览器未进行全局导航，也能获取或发送数据，避免画面在切换时闪烁（页面一瞬间全白）。\n    </p>\n    <p>不过，有时我们也希望与用户在地址栏中输入 URL 或者点击链接等时一样，实现 HTTP 访问，清除浏览器当时的状态并加载内容。</p>\n    <p>最简单的方法是在 <code>location.href</code> 中设置要跳转到的 URL。</p>\n    <pre class=\"code-rows\"><code>location.href = \"https://tako.××××.com\";</code></pre>\n    <p>这时只可以使用 <code>GET</code> 方法发起请求。另一种方法是使用 JavaScript 动态创建表单，然后调用 <code>submit()</code> 方法。如果将 <code>method</code>\n        属性设置为 <code>\"post\"</code>，就可以使用 <code>POST</code> 方法发起请求。</p>\n    <pre class=\"code-rows\"><code>const form = document.createElement(\"form\");\nform.action = \"https://tako.××××.com\";\nform.method = \"post\";\ndocument.body.appendChild(form);\nform.submit();\ndocument.body.removeChild(form);</code></pre>\n    <h2 id=\"nav_point_281\">11.5　下载文件</h2>\n    <p>当存在 <code>Content-Type</code> 无法表示的内容，或使用 <code>Content-Disposition</code>\n        首部指示下载时，浏览器会进行下载，但不重置画面。当下载内容可以在浏览器中显示时，我们可以使用带有 <code>download</code> 属性的 <code>&lt;a&gt;</code> 标签来实现。我们还可以使用\n        JavaScript 来触发下载。</p>\n    <pre class=\"code-rows\"><code>const anchor = document.createElement(\"a\");\nanchor.href = \"https://tako.××××.com\";\nanchor.download = \"tako.json\";\ndocument.body.appendChild(anchor);\nanchor.click();\ndocument.body.removeChild(anchor);</code></pre>\n    <p>如果下载时需要设置特殊的首部，或者必须使用 <code>GET</code> 之外的发送方法，那么我们可以使用 Fetch 进行下载。</p>\n    <pre class=\"code-rows\"><code>const res = await fetch(\"https://tako.××××.com\", {\n    headers: {\n        Authorization: \"Basic XXXXX\"\n    }\n});\nif (res.ok) {\n    const anchor = document.createElement(\"a\");\n    anchor.href = URL.createObjectURL(await res.blob());\n    anchor.download = \"tako.json\";\n    document.body.appendChild(anchor);\n    anchor.click();\n    URL.revokeObjectURL(anchor.href);\n    document.body.removeChild(anchor);\n}</code></pre>\n    <h3 id=\"nav_point_282\">动态创建内容并下载</h3>\n    <p>借助第 4 章介绍的 Data URI 方案，我们可以使用 JavaScript 动态创建文件。虽然可以在 HTML 中直接插入内容（图像等）并使用，不过这里我们来尝试下载 Excel 文件。</p>\n    <p>代码清单 11-11 中使用 <code>SheetJS</code> 库来创建 Excel 文件。虽然也可以自行创建 Data URI 方案形式的字符串，不过这里使用了高级功能\n        <code>URL.createObjectURL()</code> 来生成。创建 <code>&lt;a&gt;</code> 标签并设置其属性，然后点击标签设置的链接，就可以下载文件了 <span&#10; class=\"comment-number\">1。</span&#10;></p>\n    \n    <p>这样一来，即使不进行 HTTP 通信，浏览器也可以远程下载文件。</p>\n    <p><strong>代码清单 11-11　使用 JavaScript 创建并下载文件</strong></p>\n    <pre class=\"code-rows\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;script src=\"https://unpkg.com/xlsx/dist/xlsx.full.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;button onclick=\"download()\"&gt;Download XLSX&lt;/button&gt;\n    &lt;script&gt;\n        function download() {\n            const contentType = \"application/vnd.openxmlformats-officedocument.\nspreadsheetml.sheet\";\n            const wb = XLSX.utils.book_new();\n            const ws = XLSX.utils.aoa_to_sheet([\n                [\" 瑞穗银行\", \"0001\"],\n                [\" 三菱 UFJ 银行\", \"0005\"],\n                [\" 三井住友银行\", \"0009\"],\n                [\" 理索纳银行\", \"0010\"],\n                [\" 埼玉理索纳银行\", \"0017\"],\n            ]);\n            XLSX.utils.book_append_sheet(wb, ws, \"Bank Codes\");\n            const xlsx = XLSX.write(wb, { type: \"array\" });\n            const dataUri = URL.createObjectURL(new Blob([xlsx], {\n                type: contentType\n            }));\n            const a = document.createElement(\"a\");\n            a.href = dataUri;\n            a.download = \"bankcode.xlsx\";\n            a.click();\n            URL.revokeObjectURL(url);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n    <h2 id=\"nav_point_283\">11.6　Server-SentEvents</h2>\n    <p>与 XMLHttpRequest 和 Fetch API 不同，Server-Sent Events 是实现从服务器端开始通信的协议和 JavaScript API。另外，基于 Server-Sent Events\n        的通信并不是进行一次就结束了，而是一直保持连接，服务器能够多次返回响应。Server-Sent Events 还拥有断开后重新连接、读取未接收完的内容等功能。</p>\n    <p>JavaScript 端使用 <code>EventSource</code> 类来访问 Server-Sent Events。该类负责传递事件流、在连接中断时重新连接等。代码清单 11-12 是 Mozilla 网站的\n        Server-Sent Events 的示例代码。</p>\n    <p><strong>代码清单 11-12　Server-Sent Events 的示例代码（摘自 Mozilla 网站）</strong></p>\n    <pre class=\"code-rows\"><code>const evtSource = new EventSource(\"ssedemo.php\");\n\n// 消息的事件处理器\nevtSource.onmessage = (e) =&gt; {\n    const newElement = document.createElement(\"li\");\n    newElement.innerHTML = \"message: \" + e.data;\n        eventList.appendChild(newElement);\n    }\n};\n\nevtSource.addEventListener(\"ping\", (e) =&gt; {\n    const newElement = document.createElement(\"li\");\n\n    const obj = JSON.parse(e.data);\n    newElement.innerHTML = \"ping at \" + obj.time;\n    eventList.appendChild(newElement);\n}, false);</code></pre>\n    <p>代码清单 11-12 中设置了两种事件处理器（event handler）。<code>onmessage</code> 是在接收到无事件标签的 <code>data</code>\n        标签的消息时调用的回调函数。<code>addEventListener()</code> 指定事件名称并注册回调函数，它仅处理特定的带有事件标签的消息。</p>\n    <p>重新连接和保持连接的处理在 JavaScript 无法查看的层中完成。客户端记录消息 ID，在重新连接时，将最后接收到的 ID 作为 <code>Last-Event-ID</code>\n        首部发送。服务器通过查看该首部，就能够知道客户端成功地接收到了前面的事件，从而只发送此后的事件。</p>\n    <h2 id=\"nav_point_284\">11.7　WebSocket</h2>\n    <p>WebSocket 是提供双向通信功能的 API，该功能与 HTTP 底层的 TCP 套接字相似。在 HTTP 通信中，首部的数据量比较大，在频繁处理比较小的数据时，开销会变大。WebSocket\n        会消除这种开销，在频繁处理比较小的数据时更高效地进行传输，并且既可以从客户端发送数据，也可以从服务器发送数据。</p>\n    <p>JavaScript 的 API 类似于 TCP 套接字的 API。在通信时，由客户端发起连接请求，服务器处于等待接收的状态。</p>\n    <blockquote>\n        <ol>\n            <li class=\"第2级有序列表\">使用指定的 IP 地址、端口号启动服务器（<code>Listen</code>）。</li>\n            <li class=\"第2级有序列表\">客户端（浏览器）声明开始与服务器进行通信（<code>Connect</code>）。</li>\n            <li class=\"第2级有序列表\">服务器接收来自客户端的连接请求（<code>Accept</code>）。</li>\n            <li class=\"第2级有序列表\">将套接字类的实例传递给服务器。</li>\n            <li class=\"第2级有序列表\">在服务器受理后，客户端套接字实例的发送功能和接收功能开始有效。</li>\n        </ol>\n    </blockquote>\n    <p>这里的 <code>Listen</code>、<code>Connect</code> 和 <code>Accept</code>\n        是为了方便读者理解而添加的，它们是笔者在介绍系统编程的套接字时使用的函数名称。JavaScript 的 WebSocket 的 API 名称与此不同，但基本思想是一样的。实际上，因为使用 HTTP\n        连接后客户端会请求进行协议升级，所以内部的步骤有点复杂，但从外部来看，顺序是一样的。</p>\n    <p>代码清单 11-13 是服务器和客户端进行连接和发送数据的代码。通过 <code>WebSocket</code> 类的构造函数指定连接目标的 URL，然后通过 <code>send()</code>\n        方法发送数据。在上面的步骤中，只有步骤 2 是需要客户端在连接时完成的。该构造函数和 <code>onopen</code> 事件监听器的后台仅执行该操作。</p>\n    <p><strong>代码清单 11-13　使用 WebSocket 进行连接和发送数据</strong></p>\n    <pre class=\"code-rows\"><code>var socket = new WebSocket('ws://××××.com');\nsocket.onopen = () =&gt; {\n    setInterval(() =&gt; {\n        if (socket.bufferedAmount === 0) {\n            socket.send(getUpdateData());\n        }\n    }, 50);\n};</code></pre>\n    <p>针对连接之后的套接字，客户端需要执行以下操作。</p>\n    <blockquote>\n        <p><code>send([ 数据 ])</code></p>\n        <p>将数据发送给服务器。</p>\n        <p><code>onmessage</code></p>\n        <p>使用事件处理器接收服务器发送来的数据。</p>\n        <p><code>close([ 状态码 [, 原因 ]])</code></p>\n        <p>关闭套接字。</p>\n    </blockquote>\n    <p>数据可以是字符串、Blob 和 ArrayBuffer 等。<code>onmessage</code> 方法用于接收数据。<code>onmessage</code> 事件的用法与 Server-Sent Events\n        相同。</p>\n    <h2 id=\"nav_point_285\">11.8　本章小结</h2>\n    <p>本章介绍了使用 JavaScript 进行通信的具体方法。</p>\n    <p>与 Go 语言不同，JavaScript 大多用于开发在浏览器上查看的网站，因此实现 HTTP 通信的 API 也有很大不同。另外，为了实现特殊的通信，有时还需要用到一些复杂的技术。Server-Sent\n        Events、WebSocket 等通信并非只进行一次，这也是与主要用于服务器端实现的 Go 语言的不同之处。</p>\n    <p>考虑到 Go 语言可能会在云原生时代迅猛发展，并且其本身也是一门简单易学的编程语言，所以本书使用 Go\n        语言进行了介绍，但一种编程语言并不能覆盖所有领域，我们需要根据不同的用途使用不同的语言。如果大家抱着多学一门编程语言也没坏处的想法，那么恐怕最后还是会选 JavaScript，因为 JavaScript\n        是浏览器唯一支持的编程语言。</p>\n    <p>浏览器还拥有使用 Service Worker 进行通信缓存、离线访问服务器等功能，本书并未对这些功能进行介绍。Web 还在发展，相信未来会出现更多高级功能。</p>\n\n    <br style=\"page-break-after:always\" />\n    ","comments":[]}