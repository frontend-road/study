{"id":241094,"title":"03 | 可测试性： 一个影响软件设计的重要因素","content":"<p>你好！我是郑晔。</p><p>上一讲，我们讲了软件设计的第一步：分离关注点。作为至关重要的第一步，分离关注点常常被人忽略，严重影响了设计的有效性。这一讲，我们再来看另一个经常被很多人忽视的因素：可测试性。</p><p>在讨论可测试性之前，我们不妨先来思考一个问题：你觉得软件开发中最浪费时间的环节是什么？答案肯定不是写代码，因为写代码是一个建设的过程，谈不上是在浪费时间。在我接触过的诸多项目里，集成测试可以说是一个浪费时间的大户。</p><p>那你的项目是怎么做集成测试的呢？一个常见的测试场景是这样的：你先花了一些时间打包部署一个服务端应用，然后开始测试。测着测着，你发现一个Bug，然后调查半天，最后发现是一个简单的错误。你就在心里暗恨，为啥写代码的时候没发现呢！</p><p>这还只是一个简单的场景，也有稍微复杂一点的。比如，有多个不同项目组的人一起联合测试。当你测出一个Bug，然后辛辛苦苦调查半天，发现是另外一个模块出了问题，你唯一能做的就是等着那个组的同事把Bug改好，测试才能进行下去。更可恨的是，他们查了半天，结果也是一个简单的错误。你会在心里嘀咕，为啥写代码的时候不仔细一点呢？</p><p>在实际工作中，我们经常遇到类似的场景。你觉得这种状态正常吗？可能很多人对此习以为常。虽然难受，却不得不忍受。</p><!-- [[[read_end]]] --><p>但我想说的是，这样的问题原本有机会得到优化。而出现这样的问题，主要原因就在于<strong>前期设计时<strong><strong>就埋下了隐患</strong></strong>，你<strong><strong>根本</strong></strong>没有考虑“可测试性”</strong>。</p><h2>软件设计要考虑“可测试性”</h2><p>我们知道，软件开发要解决的问题是从需求而来。需求包括两大类，第一类是功能性需求，也就是要完成怎样的业务功能；第二类是非功能性需求，是业务功能之外的一些需求。</p><p>非功能性需求也被分为两大类，一类称为执行质量（Execution  qualities），你所熟悉的吞吐、延迟、安全就属于这一类，它们都是可以在运行时通过运维手段被观察到的；而另一类称为演化质量（Evolution  qualities），它们内含于一个软件的结构之中，包括可测试性、可维护性、可扩展性等。</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/da/a126ab6ed0251c82b7d15c2e9c041cda.jpg?wh=2248*1265\" alt=\"\"></p><p>做设计的时候，功能性需求自不必说，你肯定会考虑到。在非功能性需求中，执行质量是很多程序员的心头爱，一般也不会被忽略。但演化质量的地位却很低，常常为人忽略，尤其是其中的“可测试性”。</p><p>我们在开发过程中欠下的很多技术债，本质上都是因为忽略了“可测试性”这个需求。</p><p>可测试性为什么如此重要？因为我们做设计，其实就是把一个软件拆分成一个一个的小模块。如果不尽可能地保证每个小模块的正确性，而只是从最外围的系统角度去验证系统的正确性，这将会是一个非常困难的过程。就和盖楼是一个道理，不保证钢筋、水泥、砖土质量合格，却想要盖出合格的大楼来，很荒唐吧！然而，很多团队的软件开发就是这么做的。</p><p>我们要保证每个小模块的正确性，就要保证每个模块在开发阶段能够测试，而想要每个模块能够测试，在设计过程中，就要保证每个模块是可以测试的，而这就是可测试性。</p><p>一旦我们在可测试性上考虑不足，就会引发一系列的后续问题。比如，复杂的系统不仅仅在测试上有难度，在集成、部署等各个环节，都有其复杂性，完成一次部署往往也需要很长时间。</p><p>这也就意味着，即便是一个简单的验证工作，部署的时间成本也非常昂贵。这还不包括在出问题时，我们在一个复杂系统中定位问题的成本。</p><p>我们只有把每个小模块尽可能做好，才能尽量降低对集成环境的依赖程度，从而节省后期的成本。这就相当于在前面多花了1块钱，却省下了后期的10块钱。</p><p>我们回过头思考一下这节课刚开始提到的那个问题，为什么我们在集成测试场景中，会浪费那么多时间呢？因为这个系统只能在集成测试环境中进行测试，所以，即使是一些非常简单的问题，也只能在这阶段暴露。这些问题原本可以在更前面的阶段解决，比如，单元测试。</p><p>可为什么这些问题会遗留到集成测试环境呢？很多程序员给你的回答都会是，不好测。而这不好测的背后，往往就是因为在设计中没有考虑“可测试性”这个因素。</p><p>那么如何在设计中考虑可测试性呢？其实就是要在设计时想一下，<strong>这个函数/模块/系统要怎么测。</strong></p><p>当你用这个标准衡量一些系统时，可能就会发现一种典型的错误，就是设计根本没有考虑过测试。这样的系统常常只有最外层的接口可以测试，也就是说，整个系统必须集成起来才能测试。前面提到的集成测试的问题犯下的就是这种错误。</p><p>在实际工作中，很多公司为了做集成测试，要把所有的子系统全部都搭建出来，也就是一套完整的环境。这种环境要占用大量的资源，一般来说，公司不会准备很多套。这样造成的结果就是各个团队对于环境的竞争，再叠加上各个系统配合的问题，测试的效率还会进一步降低。</p><p><strong>所以，我们在设计一个函数/模块/系统时，必须将可测试性纳入考量，以便于能够完成不同层次的测试，减少对集成环境的依赖。</strong></p><p>那么，具体该如何做呢？一方面，尽可能地给每个模块更多的测试，使构成系统的每个模块尽可能稳定，把集成测试环境更多地留作公共的验收资源。另一方面，尽可能搭建本地的集成测试环境，周边的系统可以采用模拟服务的方案。</p><p>在软件开发过程中考虑测试，实际上是思考软件的质量问题，而把质量的思考前移到开发，甚至是设计阶段，是软件开发从传统进入到现代的重要一步。</p><h2>当你有了可测试性的视角</h2><p>现在你已经对软件设计中的可测试性有了一个初步的认识。其实，在了解可测试性之后，我们还可以把它作为一个衡量标准来考察已有的设计。</p><p>比如，有一个设计模式叫Singleton，通常的做法是把构造函数做成私有的。如果这个Singleton的类与其他组件配合，由于这个私有函数的存在，这个类无法继承，也就不能用一个子类对象去模拟它。所以，从可测试性的角度来看，Singleton就不是一个好的设计模式。</p><p>再比如，TDD（Test-Driven Development，测试驱动开发）对于很多人来说都非常困难，主要有两方面原因。一方面，这些人不习惯先写测试的工作方式，但另外一方面，也是更重要的原因，是他们不知道怎么测试。</p><p>因为很多模块的设计根本没有考虑过如何做测试，要把它们单独拿出来测试，必然会遇到很多问题。</p><p>举个例子，在通常的架构中，服务会调用数据库访问的代码。如果是不考虑测试的做法，代码可能写成这样：</p><pre><code>class ProductService {\n  // 访问数据库的对象\n  private ProduceRepository repository = new ProductRepository();\n  \n  public Product find(final long id) {\n    return this.repository.find(id);\n  }\n}\n</code></pre><p>在这里，我们要直接创建数据库访问的对象，然而，要创建数据库访问对象，就要同时把数据库连接起来，你要准备一大堆相关的东西，所以，测试的复杂度就会非常大。</p><p>可是，测试这个服务目的是，关心这个服务的逻辑是不是写正确了，这与是不是用数据库没关系啊！所以，如果我考虑了可测试性，服务的依赖就变成了一个数据访问的接口：</p><pre><code>class ProductService {\n  // 访问数据库的对象\n  private ProduceRepository repository;\n  \n  public ProductService(final ProduceRepository repository) {\n    this.repository = repository;\n  }\n  \n  public Product find(final long id) {\n    return this.repository.find(id);\n  }\n}\n</code></pre><p>在这种代码里，我们只需要将数据访问的接口模拟出来，而用来模拟接口的Mock框架在各种程序语言里几乎都可以找到。我们唯一要保证的，就是模拟出来的对象要与接口定义的行为保持一致，不过，这可比准备数据库，难度系数要低多了。</p><p>真正懂得了可测试性，还可以帮助我们理解软件开发的趋势。有些Java工作经验的同学可能听说过EJB（Enterprise Java Beans），它是2000年左右的开发主流。当时一个Java系统如果没用到EJB，你都不好意思和人打招呼。但是，今天你很难听说有谁还在用EJB做新系统了。</p><p>在每次测试时，EJB都需要部署到专门的应用服务器上。站在可测试性的角度看，它的测试成本就是极其高昂的，相应的开发成本也就变得很高。</p><p>当年与EJB竞争的正是当今如日中天的Spring，Spring胜出的一个重要原因就是它简化了开发。它当年的口号正是without EJB。<strong>这是一种重要的开发趋势：轻量级开发</strong>。而这背后，重要的思维基础，<strong><strong>就是可测试性</strong></strong>。后面在第五讲中，我们会讲到SpringDI容器的设计，你会进一步看到可测试性在其中发挥的作用。</p><p>实际上，Spring在简化开发的道路上从未停下脚步。今天的Java程序员使用Spring Boot的时候，启动它就像启动一个普通的Java应用，在IDE里做各种调试，甚至都没有注意到它启动时，下面有一个Tomcat。</p><p>要知道，当年可是要打出一个WAR包，部署到Tomcat上。所以，曾几何时，能够连接远程的Web服务器是IDE一项重要的功能，而这项功能在今天来看，已经非常鸡肋了。</p><h2>总结时刻</h2><p>今天，我们学习了一个影响软件设计的重要因素：可测试性。</p><p>在软件设计中，可测试性常常被人忽视，结果造成了很多模块的不可测，由此引发了很多技术债。所以，在设计中就要充分考虑可测试性。</p><p>在设计中考虑可测试性，就是在设计时问一下，<strong>这个函数/模块/系统怎么测</strong>。在软件开发中，只有把一个一个的小模块做了足够的测试，我们才会有稳定的构造块，才可以在集成测试的时候，只关注最终的结果。</p><p>而有了可测试性的视角，我们可以把它当作一个衡量标准去看待其他的设计或实践，也可以用它帮助我们理解软件的发展趋势。</p><p>经过前几讲基础知识的铺垫，你对软件设计已经有了一个初步的了解。下一讲，我们将进入到实际的工作环节中，去了解一个软件的设计。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>做软件设计，请考虑可测试性。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/58/9e/587d5a0c7a5e6dbfea504e7bfee69e9e.jpg?wh=2248*724\" alt=\"\"></p><h2>思考题</h2><p>最后，我想请你回想一下，如果以可测试性衡量一下你开发过的系统，它的可测试性如何？有哪些问题是由于最初没有考虑可测试性造成的呢？欢迎在留言区分享你的经历。</p><p>感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"02 | 分离关注点：软件设计至关重要的第一步","id":240749},"right":{"article_title":"04 | 三步走：如何了解一个软件的设计？","id":241114}},"comments":[{"had_liked":false,"id":222130,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1590682546,"is_pvip":false,"replies":[{"id":"81931","content":"之所以我们要先讲分离关注点，就是因为很多人会把东西混在一起，测试当然就会很困难了。<br><br>以你的场景为例，做 PDF 生成，这里面要拆分开几个不同的环节：<br>* 从别的服务器拉取数据；<br>* 解析外部业务数据；<br>* 业务数据清洗成自己的数据；<br>* 采用模板引擎进行渲染生成 PDF；<br>* 将文件上传到 S3；<br>* 将文件地址返回给客户端。<br><br>接下来，就是一个一个分别构建这几个不同的模块，每个模块单独测试。<br>* 从别的服务器拉取数据：关注数据能否正确获取，获取出错该如何处理，这里需要将拉取协议进行隔离；<br>* 解析外部业务数据：关注数据能否正确解析，无法解析的数据该如何处理；<br>* 业务数据清洗成自己的数据：关注数据能否正确转化，业务含义不正确该如何处理；<br>* 采用模板引擎进行渲染生成PDF：关注渲染过程能否正常进行。需要将PDF作为一个生成目标进行隔离。这一过程需要人工检查生成的PDF格式是否正确。<br>* 将文件上传到S3：关注文件上传是否正确，需要将文件上传目标进行隔离，S3只是一个目标。<br>* 将文件地址返回给客户端：关注是否能够获取到文件地址，这里要结合上一项中的上传目标，将S3隔离开来。<br><br>各个都测试好之后，再进行集成测试，这里面的关注点就是这些模块联动起来是否能够正常运行，以及检查结果的正确性。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1590725353,"ip_address":"","comment_id":222130,"utype":1}],"discussion_count":8,"race_medal":0,"score":"461152183218","product_id":100052601,"comment_content":"最近有同事正好在做PDF的生成，也就是把业务数据从各个别的服务拉取回来 然后清洗加工成自己想要的数据 然后传递给模版引擎进行渲染 最终生成pdf文件上传s3 然后通过API把上传的文件地址返回给客户端 想请问老师 这部分逻辑应该怎么测试？因为同事在写完代码之后只做了简单的测试（也就是直接mock其他的service的服务然后mock数据返回 以及mock了s3上传 ）最后只是简单看了一下返回值是否为空就完事了。最后到环境上验证才发现好多字段的格式有问题。那像这类场景我们该怎么合理测试才能尽可能保证做到测试完整性呢？","like_count":108,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496677,"discussion_content":"之所以我们要先讲分离关注点，就是因为很多人会把东西混在一起，测试当然就会很困难了。\n\n以你的场景为例，做 PDF 生成，这里面要拆分开几个不同的环节：\n* 从别的服务器拉取数据；\n* 解析外部业务数据；\n* 业务数据清洗成自己的数据；\n* 采用模板引擎进行渲染生成 PDF；\n* 将文件上传到 S3；\n* 将文件地址返回给客户端。\n\n接下来，就是一个一个分别构建这几个不同的模块，每个模块单独测试。\n* 从别的服务器拉取数据：关注数据能否正确获取，获取出错该如何处理，这里需要将拉取协议进行隔离；\n* 解析外部业务数据：关注数据能否正确解析，无法解析的数据该如何处理；\n* 业务数据清洗成自己的数据：关注数据能否正确转化，业务含义不正确该如何处理；\n* 采用模板引擎进行渲染生成PDF：关注渲染过程能否正常进行。需要将PDF作为一个生成目标进行隔离。这一过程需要人工检查生成的PDF格式是否正确。\n* 将文件上传到S3：关注文件上传是否正确，需要将文件上传目标进行隔离，S3只是一个目标。\n* 将文件地址返回给客户端：关注是否能够获取到文件地址，这里要结合上一项中的上传目标，将S3隔离开来。\n\n各个都测试好之后，再进行集成测试，这里面的关注点就是这些模块联动起来是否能够正常运行，以及检查结果的正确性。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590725353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275515,"discussion_content":"感觉。。这是测试覆盖的问题吧（与可测试性关系不大）。仅做了功能性测试。漏掉了非功能性测试。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590722925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275706,"discussion_content":"嗯 我还是多解释一下吧 可测试性是测试覆盖的前提 所以肯定是有关系的 我这个问题延伸出来的问题就是：模块怎么定义？按照上边老师说的那每个步骤划分成一个模块还是如何？模块与模块之间如何隔离？一般来说按照我们的设计都会只暴露一个接口(interface(内部调用者)和API(外部调用者))给调用者而屏蔽了其他的细节比如数据清理，比如模版引擎渲染， 那里面的实现细节怎么测试？private方法怎么测试？如果这个接口的返回值是s3地址那怎么去测试里面的每一个步骤？如果划分的模块过多(每个步骤都暴露一个方法)，那内部逻辑怎么和外部逻辑隔离？这些点其实都是我review了同事代码之后发现的我无法解答的地方，所以我才会有上面的问题。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590756845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275515,"ip_address":""},"score":275706,"extra":""},{"author":{"id":1168504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d4/78/66b3f2a2.jpg","nickname":"斯盖丸","note":"","ucode":"B881D14B028F14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348528,"discussion_content":"你好，你们的项目现在怎么样了？还有我想请教一下你所说的多模块是不是IDEA一个project下的多module？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612614238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275706,"ip_address":""},"score":348528,"extra":""},{"author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1168504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d4/78/66b3f2a2.jpg","nickname":"斯盖丸","note":"","ucode":"B881D14B028F14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348932,"discussion_content":"你好 我们的项目还在 多模块在不同的环境下有不同的语义 我说的是一个功能由不同的组件配合完成 不确定你的问题是什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612783058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":348528,"ip_address":""},"score":348932,"extra":""}]},{"author":{"id":2363368,"avatar":"","nickname":"walnut","note":"","ucode":"AF379E153E7499","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349281,"discussion_content":"解析外部业务数据；\n* 业务数据清洗成自己的数据；\n* 采用模板引擎进行渲染生成 PDF；\n\n这3项算业务吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613036372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275803,"discussion_content":"1.可测试性是覆盖的前提。这话有点道理，get。\n2.栏主列的是流程步奏，跟模块划分应该没啥关系。\n3.模块划分是基于领域实体的。栏主划分的渲染成pdf和上传文件到文件系统，这些都可以划分为基础功能，属于业务无关每个模块都要单独定义的（基于接口而非实现）。\n4.私有方法单独测试，除了升级成子类可见的作用范围。没想到什么好办法。\n5.参数检验没测这种事，划分成非功能性测试不对。应该划分为功能性测试的。没测到实在有点说不过去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590763322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276235,"discussion_content":"流程步骤跟模块划分其实关系很大的，想这样一个问题：拉取别的服务的数据/清洗数据/模版文件的选择/上传到哪里的选择 这些都是业务相关的。\n如果我们把PDF的生成当作一个公共的模块 那么以上这些操作都不能归到这个公共模块，因为如果你归到公共模块的话那么别的业务模块依赖PDF这个公共模块也会把你的模块依赖进去 这样是不合理的 所以这几部分的实现属于业务模块 PDF模块的功能是把这整个流程串联起来 但是以上各部分的具体实现属于各个业务模块自己。我如果不仔细分析这些步骤一股脑全部放到PDF模块里面 那必然是不合理的。\n但是通过和你的讨论我突然发现：其实我们的模块划分是不对的，因为我们没有对不同的步骤做抽象而是把所有的东西都混在一起，所以导致测试也被揉在一起，其实正确的可能应该是：PDF模块自己的模版渲染是自己的测试需要覆盖的一部分，每个业务模块需要去测试自己的那部分，这样的话其实就完全能做到模块划分合理，测试也都各自分开了，互不影响。\n至于你最后说的功能性测试和非功能性测试 我觉得是对的，因为模块划分混乱，所以测试职责混乱。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1590844477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275803,"ip_address":""},"score":276235,"extra":""}]}]},{"had_liked":false,"id":222163,"user_name":"Moonus","can_delete":false,"product_type":"c1","uid":1813327,"ip_address":"","ucode":"F8261DA1E8DF2C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqia9gfbDeu8RqUlSozxmnzr6micGefNs5QGehBBl23xH6V82GxYwjgFgCKIA9n6iafFVKFoxVw5fHWw/132","comment_is_top":false,"comment_ctime":1590711208,"is_pvip":true,"replies":[{"id":"81974","content":"private 方法怎么测？其实是一个伪命题。要测 private 方法，更多的是因为这个类承担了过多的职责，才会出现层层嵌套的方法，才会不好测。<br><br>你的改进方法非常对，将这个方法移到另外一个类中，它成了 public 的，该怎么测，就怎么测。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1590745650,"ip_address":"","comment_id":222163,"utype":1}],"discussion_count":5,"race_medal":0,"score":"117554828200","product_id":100052601,"comment_content":"比如service层有个很长，包含复杂逻辑的private方法，但我又想测试他。只能通过最顶层的public方法作为入口，这导致需要保证大量的前提条件的正确，我们需要mock很多外部依赖。<br>当private方法复杂并包含逻辑，其正确应当重构代码，而不是在测试做妥协，可以将需要测试的private方法转移到另一个对象中，成为一个public的方法。同时让我体会到测试驱动设计的含义。","like_count":28,"discussions":[{"author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275709,"discussion_content":"嗯 这也是我目前纠结的点 把private方法变成public方法那是不是从某种程度上说我们把实现的细节暴露给了外部呢？因为本来是类A要做的工作 现在把其中的某一步或者几步分离到另外一个类B了 并且这些类还是一等公民 那不就把细节暴露到外面了 这样做合理么？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590757182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2016786,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c6/12/7c36aa3a.jpg","nickname":"Black船长","note":"","ucode":"B0B73E8DEB56C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279492,"discussion_content":"用protectd修饰或者friendly，同一个package下调用、或者子类继承去调用，可测的同时降低对外暴露。 还有个不成熟的想法，private也可以用反射来调用。是不是可以弄个啥插件，专门提供测试private方法的能力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591355461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275709,"ip_address":""},"score":279492,"extra":""},{"author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2016786,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c6/12/7c36aa3a.jpg","nickname":"Black船长","note":"","ucode":"B0B73E8DEB56C4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":279639,"discussion_content":"嗯 我是Java栈的 倒是确实有这么个框架能帮助测试private的方法 只是我在纠结这样做的收益","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591372136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":279492,"ip_address":""},"score":279639,"extra":""}]},{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496697,"discussion_content":"private 方法怎么测？其实是一个伪命题。要测 private 方法，更多的是因为这个类承担了过多的职责，才会出现层层嵌套的方法，才会不好测。\n\n你的改进方法非常对，将这个方法移到另外一个类中，它成了 public 的，该怎么测，就怎么测。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590745650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1615590,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a6/e6/248c69ff.jpg","nickname":"铁锅炖大鹅","note":"","ucode":"6D1D7218975920","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":592239,"discussion_content":"反射","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667222506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":496697,"ip_address":"福建"},"score":592239,"extra":""}]}]},{"had_liked":false,"id":222711,"user_name":"段启超","can_delete":false,"product_type":"c1","uid":1258209,"ip_address":"","ucode":"164CF3018071B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","comment_is_top":false,"comment_ctime":1590897222,"is_pvip":false,"replies":[{"id":"85081","content":"多谢分享如此惨痛的教训，相信你已经理解了循环依赖的问题所在。<br><br>从设计的角度看，循环依赖之所以产生，一个重要的原因就是没有分清接口和实现。如果都是实现，一不小心就循环依赖了，如果分清楚接口和实现，实现依赖于接口，产生循环依赖的可能性就会大幅度降低。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1593408786,"ip_address":"","comment_id":222711,"utype":1}],"discussion_count":2,"race_medal":0,"score":"83195275846","product_id":100052601,"comment_content":"    和大家分享一下我最近发现的一个问题：滥用@Autowired<br>    最近在给手上的代码上加测试的时候我进行了如下操作：<br>    1. 我在测试类中写了一个测试，因为类A中要执行的这个逻辑需要依赖另外一个对象B，于是我把这个需要依赖的对象B从全局变量中移动到构造中，作为参数放了进去，然后再构造方法上加了注解@Autowired。（注意： 原来的这个@Autowired 是在这个全局变量上的）<br>    2. 我在测试中mock 了这个依赖的B对象，然后给到了这个Service 的实例中去。<br>    3. 写业务代码实现，让测试通过。 <br>     <br>    本来以为测试已经通过，没什么问题了，结果在集成测试启动Spring 容器的时候，发现挂掉了，发生了循环依赖，查看代码，果然，在B中也@Autowired 注入了A ，他们两个就此开始循环～～～～<br>    结果用idea 的分析工具扫了一通，发现循环依赖不止于此，还有很多很多。。。。。<br>   <br>  从这件事儿上体现出来的问题： <br>  1:  滥用@Autowired 体现出来的首先就是没有分离关注点，让一个类中做了过多的事情。 现在想过来原来写过的很多代码里头都是一大堆的@Autowired 注入 ，很多XXXService 的代码大概率的会发生这种事情。 <br>  2:  其实IDEA 编译器里边早就提醒过你了，当你在字段上使用@Autowired 去注入的时候，会有黄线的提示，提醒你不要这么使用，推荐你使用构造器的方式去注入。而很多人的处理方式就是对这个黄线视而不见。 <br>  3：如果从代码的测试性的角度来出发，你一定不会这么做，因为这么做没有办法去mock 你的依赖。 代码会丑到你自己都不想看。 <br>  4:  以前没想过循环依赖是怎么发生的，现在明白了：一个罪魁祸首就是滥用@Autowired  。循环依赖本身也是一个设计上的坏味道。如果有人问我说如何解决循环依赖，我会回答他： 首先不要循环依赖。 <br> ","like_count":20,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496892,"discussion_content":"多谢分享如此惨痛的教训，相信你已经理解了循环依赖的问题所在。\n\n从设计的角度看，循环依赖之所以产生，一个重要的原因就是没有分清接口和实现。如果都是实现，一不小心就循环依赖了，如果分清楚接口和实现，实现依赖于接口，产生循环依赖的可能性就会大幅度降低。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593408786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074742,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/36/b4a4e6fb.jpg","nickname":"Edon du","note":"","ucode":"1648624751AAE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581799,"discussion_content":"可以考虑抽象一个应用编排层，就不存在循环依赖了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658998066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222133,"user_name":"西西弗与卡夫卡","can_delete":false,"product_type":"c1","uid":1001710,"ip_address":"","ucode":"B4C27B8335B76A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/ee/872ad07e.jpg","comment_is_top":false,"comment_ctime":1590683420,"is_pvip":true,"replies":[{"id":"81954","content":"很赞的做法！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1590741568,"ip_address":"","comment_id":222133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70310160156","product_id":100052601,"comment_content":"曾经开发过堆场应用，其中一个步骤是从远端服务器同步到本地服务器，然后再执行本地逻辑。如果每次测试本地逻辑都要从服务端拉取数据的话，就没法自动测了。当时采用的测试方法就是先抓取接口数据生成接口文件，测试就从文件中加载，再运行，最后销毁整个数据库。如果有接口相关的bug，也同样抓取数据保存，构建一个bug号命名的测试方法测试bug。<br><br>后来做过系统高可用软件，采用的方法是将代码自动部署到多个Docker里，测试代码里依据场景（为了方便，场景还用DSL写）比如杀某个Docker来测试高可用逻辑是否正常。","like_count":17,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496679,"discussion_content":"很赞的做法！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590741568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222168,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1590712073,"is_pvip":false,"replies":[{"id":"82534","content":"如何将一个已有系统改造成粒度小且可测试的程序？这到底是不是一个问题，其实要考虑的。很多系统的改造，是切分开来，逐步替换。我们在专栏最后，会讲到如何做一个现有系统的改造，敬请期待。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591314958,"ip_address":"","comment_id":222168,"utype":1}],"discussion_count":6,"race_medal":0,"score":"66015221513","product_id":100052601,"comment_content":"其实难度是，现在大多开发者接触的一个已有的系统，在这个系统进行维护，修改各种bug，以及添加一些新需求。那么问题来了，如何将一个已有系统改造成粒度小且可测试的程序？我觉得这个应该是大家关心的工程实践","like_count":15,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496700,"discussion_content":"如何将一个已有系统改造成粒度小且可测试的程序？这到底是不是一个问题，其实要考虑的。很多系统的改造，是切分开来，逐步替换。我们在专栏最后，会讲到如何做一个现有系统的改造，敬请期待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591314958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275473,"discussion_content":"1.改造已有功能，看个人重构经验和对项目的了解，不然重构很可能是把项目变得更糟。\n2.至于扩展时怎么保证可测试性。建议遵循开闭原则，对已有核心功能的调整，尽量保持在一行代码或没有代码变动的程度。这样新的功能就隔离在原有功能之外。如果把原有功能看做骨架，那么新功能就是细节，这个时候，面向这个细节做功能测试，就只是入参和逻辑的问题，无需从入口处开始造数据，满足层层业务到自己新加的功能上。而只要新功能所有逻辑的单元测试都ok，上层的集成测试就会比较顺利。毕竟你在上层的改动很小，小就比较不容易出错。（如此写功能，往往会有性能差的矛盾。但大部分潜意识性能差的认知其实都是无关紧要的，所以先写好，再调优）","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1590719243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276318,"discussion_content":"如果要重构的话，是不是得写一部分单元测试，或者是需要构建一个“安全网”。给自己的代码写测试都不一定写的好，给别人的代码写单元测试就更难了。\n\n然后老板可能只是希望你去修改一个 bug，重构这部分很可能不算业绩，怎么破？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590851111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275473,"ip_address":""},"score":276318,"extra":""},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":276556,"discussion_content":"1.重构很重要，但都停留在嘴上。 代码能力这块算不算业绩，在于上层领导选贤育人的能力。毕竟如果领导不懂或则不看，你就是把代码写出花来又有何用？总归不就是个人追求罢了。\n\n2.重构别人代码时，我先是提炼下自己要变更的那一块逻辑。然后针对提炼的方法写单元测试。这样成本小些。单元测试主要是无脑加自动化。如果功能很简单，可以不写。但如果功能复杂，想要靠意念保证不改错，既不靠谱，心智负担也重。写单元测试，验证时的心智负担会比较低（无脑）。而且以后都能用（自动化），值得花功夫。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590901113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":276318,"ip_address":""},"score":276556,"extra":""},{"author":{"id":1046920,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","nickname":"阳仔","note":"","ucode":"79F73D85EDF3E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":277428,"discussion_content":"这个是一个问题，我觉得，如果你老板懂技术那么他会理解重构的意义，如果他不懂，需要“教育”他","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591057737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":276318,"ip_address":""},"score":277428,"extra":""}]},{"author":{"id":1120997,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","nickname":"favorlm","note":"","ucode":"CFD52127AA6E1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279735,"discussion_content":"期待期待期待，我现在正在将一个原有系统进行期待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591407551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222237,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1590722787,"is_pvip":false,"replies":[{"id":"81973","content":"很好的思考，你发现的问题确实都是很严重的问题，会严重地影响开发的进展。不过，能发现这些问题，就是最好改进的起点。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1590745483,"ip_address":"","comment_id":222237,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31655493859","product_id":100052601,"comment_content":"1.对于自己重构大半代码的项目，我觉得应该是有偏见的（恶心太多次了）。但我还是认为我现在的项目可测试性很差。<br>a.项目启动太慢(服务包启动一次7-8分钟，war包启动一次20几分钟)。虽然单测时我们可以控制扫包范围，但总会扫到一些&quot;基础包&quot;莫名其妙的玩意，逼着你只能扩大扫包范围，而扩大扫包范围就会让单元测试的间隔无意义的变长。（项目本身分层没规范。部分基础公共包的分层不规范，且强依赖，无法按需加载）<br>b.工具包大量非纯函数的工具。静态方法不采用mock框架的高级功能是mock不了的，所以往往我们不会去测试工具类的逻辑。但这些工具包往往也存在文档不全或文档和功能脱节的情况。这个时候，一旦你使用不当或者工具类有bug那么就可能出现与预期不符的情况，而这个排查起来是比较难受的。因为这往往是你排查的最后一步，而你可能没有权限，只能看着反编译的源码，找到问题也改不了。只能改动自己的功能不用这个工具。（由此可见DI是多么美好的东西）<br>c.臃肿的大类+强依赖中间数据结构。近百个字段的核心类，让你找个字段都很晕。中间数据(map,键值的list)在功能间传递，缺少封装。每次要获取自己要用的数据结构都要对中间数据做转换。逻辑走完后，还要对中间数据做变动，以保证变更对外部生效。这一切的结果就是逻辑被变得复杂了，代码行数增多了。而代码行数和逻辑变多出问题的可能就变大，测试的工作量就变大。<br><br>2.其他的，诸如不要有未决行为,尽量少用全局变量，低耦合等等都是个人编码能力的事，怪不得老项目了。提高可测试性,其实我觉得就是要遵循最小依赖的原则。最好就只有入参和本地逻辑（逻辑中没有外部依赖，没有外部变量，没有外部静态方法），这样可测试性是最好的。而要做到这个也并非不可能，全在你的设计和拆分力度上。","like_count":8,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496723,"discussion_content":"很好的思考，你发现的问题确实都是很严重的问题，会严重地影响开发的进展。不过，能发现这些问题，就是最好改进的起点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590745483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222147,"user_name":"北天魔狼","can_delete":false,"product_type":"c1","uid":1188144,"ip_address":"","ucode":"C22623ECEB8DBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/30/8ecce1e1.jpg","comment_is_top":false,"comment_ctime":1590704927,"is_pvip":true,"replies":[{"id":"81957","content":"没有谁是可靠的，包括自己。有几个人能记住自己几个月前写的代码细节呢。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1590742092,"ip_address":"","comment_id":222147,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23065541407","product_id":100052601,"comment_content":"测试前置数据，测试API，测试完清理数据。<br>感觉测试主要是为了防止自己或者别人改了自己的代码","like_count":6,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496688,"discussion_content":"没有谁是可靠的，包括自己。有几个人能记住自己几个月前写的代码细节呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590742092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222142,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1590687468,"is_pvip":false,"replies":[{"id":"81930","content":"这个理解是对的。做好 TDD，前提是懂一点设计，否则，自己就把自己绕进去了。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1590724536,"ip_address":"","comment_id":222142,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23065523948","product_id":100052601,"comment_content":"由于集成测试环境复杂，排错复杂，所以我们要尽量在前期，开发甚至设计阶段就要考虑测试，尽量把bug消灭在集成测试之前。每个模块保证接口功能正常，模块交互又是按照规范的，一般集成都问题不大，当然只是概率非常低。<br><br>单元测试还有一个好处，那就是自动化。写一个功能，就运行一下单元测试。单元测试是代码功能的保障。经常对曾经一些低级的bug如手误少些个！之类的错误深恶痛绝，觉得怎么能犯这么低级的错误。我错怪自己了，人就是这样一种粗心的动物，应该让程序来检查代码的正确性，程序检查的又快又不会出错，何乐不为?当然前提是得有单元测试。<br><br>Tdd是一种好的实践。在测试上要多下点功夫。<br>","like_count":6,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496686,"discussion_content":"这个理解是对的。做好 TDD，前提是懂一点设计，否则，自己就把自己绕进去了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590724536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223300,"user_name":"PM2","can_delete":false,"product_type":"c1","uid":1276515,"ip_address":"","ucode":"BE80B76C1CA3F1","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/63/487f537e.jpg","comment_is_top":false,"comment_ctime":1591058834,"is_pvip":false,"replies":[{"id":"82425","content":"我的单元测试并不是靠资料学出来的，那就推荐一本很多人推荐的书，《测试驱动的面向对象软件开发》（Growing Object-Oriented Software, Guided by Tests）。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591194366,"ip_address":"","comment_id":223300,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14475960722","product_id":100052601,"comment_content":"有什么好的资源关于单元测试吗？网上内容虽然很多，但是鱼龙混杂","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497093,"discussion_content":"我的单元测试并不是靠资料学出来的，那就推荐一本很多人推荐的书，《测试驱动的面向对象软件开发》（Growing Object-Oriented Software, Guided by Tests）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591194366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404776,"discussion_content":"JUnit有相关的书籍，Go也有相关的资料","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634398185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222219,"user_name":"FelixFly","can_delete":false,"product_type":"c1","uid":1160461,"ip_address":"","ucode":"1D39A7C3D0E31F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg","comment_is_top":false,"comment_ctime":1590719183,"is_pvip":true,"replies":[{"id":"81972","content":"大多数公司对于质量的思考是远远不够的，只用最后的结果说话，却不关注过程，造成的结果就是结果也不好，过程乱糟糟。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1590744365,"ip_address":"","comment_id":222219,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14475621071","product_id":100052601,"comment_content":"可测试性现在是大家普遍关注的事情，公司能写单元测试的人是极少数，由于单元测试的缺失，很多问题都是暴露在集成测试，而在集成测试中发现问题会需要大量的时间来查找问题，是本身问题还是上下游服务问题导致，这就是后来引发出来的链路跟踪需求，不然就没办法定位问题","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496718,"discussion_content":"大多数公司对于质量的思考是远远不够的，只用最后的结果说话，却不关注过程，造成的结果就是结果也不好，过程乱糟糟。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590744365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222166,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1590711758,"is_pvip":false,"replies":[{"id":"82535","content":"没错，这是一脉相承的。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591314973,"ip_address":"","comment_id":222166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14475613646","product_id":100052601,"comment_content":"前面一节提到软件设计的首先是要分解，而分解的一个目的我觉得就是为了软件的可测试性。<br>当然这也是建立在分解粒度要小的基础上，","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496699,"discussion_content":"没错，这是一脉相承的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591314973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316575,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1634398337,"is_pvip":false,"replies":[{"id":"114697","content":"向前一步","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1634563688,"ip_address":"","comment_id":316575,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10224332929","product_id":100052601,"comment_content":"开始工作的时候，为了测试定时任务，要修改服务器时间！很多年后才学会传参数给定时任务要调用的方法就能测试","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528418,"discussion_content":"向前一步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634563688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223599,"user_name":"蓝士钦","can_delete":false,"product_type":"c1","uid":1229516,"ip_address":"","ucode":"726EB5C8EF1249","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/cc/ca22bb7c.jpg","comment_is_top":false,"comment_ctime":1591142378,"is_pvip":false,"replies":[{"id":"82407","content":"快去看看05！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591182047,"ip_address":"","comment_id":223599,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10181076970","product_id":100052601,"comment_content":"有些项目从controller一直到dao都是一个简单的方法调用，逻辑都在sql里，这样如何单元测试呢？难道只能通过集成测试验证相互关联的方法里sql正确性了嘛……","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497182,"discussion_content":"快去看看05！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591182047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1867796,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/80/14/0bcc4dd3.jpg","nickname":"Victor","note":"","ucode":"0AA9F68348A4D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278150,"discussion_content":"对sql进行单元测试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591154636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223298,"user_name":"PM2","can_delete":false,"product_type":"c1","uid":1276515,"ip_address":"","ucode":"BE80B76C1CA3F1","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/63/487f537e.jpg","comment_is_top":false,"comment_ctime":1591058746,"is_pvip":false,"replies":[{"id":"82426","content":"这个点是对的，这是要先学分离关注点的原因。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591194388,"ip_address":"","comment_id":223298,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10180993338","product_id":100052601,"comment_content":"单元测试的前提是测试单元划分的足够细。","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497091,"discussion_content":"这个点是对的，这是要先学分离关注点的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591194388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222679,"user_name":"大晨_Richard","can_delete":false,"product_type":"c1","uid":1080725,"ip_address":"","ucode":"E19F3DBD582D63","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/95/2ad3bb05.jpg","comment_is_top":false,"comment_ctime":1590891628,"is_pvip":false,"replies":[{"id":"82537","content":"然！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591315047,"ip_address":"","comment_id":222679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885858924","product_id":100052601,"comment_content":"没有设计，写到什么写什么，是最大的问题","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496880,"discussion_content":"然！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591315047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222505,"user_name":"Being","can_delete":false,"product_type":"c1","uid":1152227,"ip_address":"","ucode":"80A8783927B650","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg","comment_is_top":false,"comment_ctime":1590822363,"is_pvip":false,"replies":[{"id":"85078","content":"这个理解非常好！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1593408420,"ip_address":"","comment_id":222505,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885789659","product_id":100052601,"comment_content":"如果提成一个个的API后，如何测试就很好理解了，想像自己在命令窗口调用一个个command，就是一个个API后执行，来assert返回结果就简单了。反过来其实也是在提醒我们实现功能，提接口时考虑一种最简单的通过命令行调取方式，能否实现。<br>那么这样无论是后台执行，还是涉及界面的调用逻辑，都是可测的。","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496821,"discussion_content":"这个理解非常好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593408420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222340,"user_name":"jacky","can_delete":false,"product_type":"c1","uid":1049177,"ip_address":"","ucode":"A0BD06E2ABF520","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/59/989f65c8.jpg","comment_is_top":false,"comment_ctime":1590753448,"is_pvip":false,"replies":[{"id":"85018","content":"这个可以去查查概念定义。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1593350031,"ip_address":"","comment_id":222340,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885720744","product_id":100052601,"comment_content":"延迟，安全为什么叫执行质量？可测试性叫演化质量？有点绕","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496758,"discussion_content":"这个可以去查查概念定义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593350031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345068,"user_name":"小袁","can_delete":false,"product_type":"c1","uid":1811495,"ip_address":"","ucode":"3F5D8721F577D9","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","comment_is_top":false,"comment_ctime":1651998424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651998424","product_id":100052601,"comment_content":"赞成在集成测试前测试，但不赞成通过测试保证每个模块的正确性。","like_count":0},{"had_liked":false,"id":344998,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1651920174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651920174","product_id":100052601,"comment_content":"做软件设计，请考虑可测试性。--记下来","like_count":0},{"had_liked":false,"id":336526,"user_name":"砖用冰西瓜","can_delete":false,"product_type":"c1","uid":1057075,"ip_address":"","ucode":"9FB3FAFC958A10","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/33/acacb6ac.jpg","comment_is_top":false,"comment_ctime":1646203059,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646203059","product_id":100052601,"comment_content":"我是做前端的，web 页面在需求上变化非常快，写测试的话，压力实在过大，请问这种情况如何才能尽可能的保证质量？","like_count":0},{"had_liked":false,"id":313712,"user_name":"Bravery168","can_delete":false,"product_type":"c1","uid":1232973,"ip_address":"","ucode":"DB08AEFBD6DF2B","user_header":"https://static001.geekbang.org/account/avatar/00/12/d0/4d/2116c1a4.jpg","comment_is_top":false,"comment_ctime":1632627429,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1632627429","product_id":100052601,"comment_content":"可测试性确实是一个在设计开发过程中容易忽略，但也很重要的点。<br>增加这个维度的思考，确实有助于进一步提升软件设计和开发质量。","like_count":0},{"had_liked":false,"id":299751,"user_name":"远逝的栀子花","can_delete":false,"product_type":"c1","uid":1608615,"ip_address":"","ucode":"77DCF684BABEEF","user_header":"https://static001.geekbang.org/account/avatar/00/18/8b/a7/b6471f02.jpg","comment_is_top":false,"comment_ctime":1624845495,"is_pvip":true,"replies":[{"id":"108725","content":"能早发现的问题就比晚发现的问题强","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1624880470,"ip_address":"","comment_id":299751,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1624845495","product_id":100052601,"comment_content":"测试用例的开发设计，可以针对每一个函数进行测试，利用好各种现有的测试接口进行测试，一旦接口发生变化就能测试用例失败，立马进行修复，不用等到代码上了测试环境或者代码上网阶段才发现。","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522533,"discussion_content":"能早发现的问题就比晚发现的问题强","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624880470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241552,"user_name":"w0807m","can_delete":false,"product_type":"c1","uid":1003931,"ip_address":"","ucode":"A23769F77ED2C1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/9b/540c0aef.jpg","comment_is_top":false,"comment_ctime":1597333286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597333286","product_id":100052601,"comment_content":"可测试性确实很重要。不过要在开发的时候注意，哪些情况会影响可测试性，老师好像并没有说的很具体，而这就需要自己多去实践和总结。我个人经验是多使用mock生成框架。","like_count":0},{"had_liked":false,"id":235050,"user_name":"若飞","can_delete":false,"product_type":"c1","uid":1158942,"ip_address":"","ucode":"35F9E876931DA4","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/1e/d4935b21.jpg","comment_is_top":false,"comment_ctime":1594878626,"is_pvip":false,"replies":[{"id":"87014","content":"测试是问题暴露的地方。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595116553,"ip_address":"","comment_id":235050,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594878626","product_id":100052601,"comment_content":"最近是为项目可测试性头疼，由于前期没有做好测试设计，所以当前针对方法、类、接口、模块以及系统各个层次的测试都会一抓一头麻，多谢提供如此好的思路。","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501593,"discussion_content":"测试是问题暴露的地方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595116553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228873,"user_name":"刘超","can_delete":false,"product_type":"c1","uid":1356539,"ip_address":"","ucode":"00F953D30F0A62","user_header":"https://static001.geekbang.org/account/avatar/00/14/b2/fb/fa145af3.jpg","comment_is_top":false,"comment_ctime":1592831801,"is_pvip":true,"replies":[{"id":"84390","content":"严格地说，用了protected，singleton就不是singleton了，因为你制造了一个可以赋出其他值的对象。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1592837985,"ip_address":"","comment_id":228873,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592831801","product_id":100052601,"comment_content":"singletone模式构造函数可以是protected的，是可以有子类的。","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499227,"discussion_content":"严格地说，用了protected，singleton就不是singleton了，因为你制造了一个可以赋出其他值的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592837985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225486,"user_name":"giteebravo","can_delete":false,"product_type":"c1","uid":1005290,"ip_address":"","ucode":"C087E8D6B5A98B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg","comment_is_top":false,"comment_ctime":1591765121,"is_pvip":false,"replies":[{"id":"83050","content":"亲爱的，你慢慢飞！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591774105,"ip_address":"","comment_id":225486,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1591765121","product_id":100052601,"comment_content":"<br>项目伊始，写代码还会有可测试性的意识，但写着写着，就写飞了～<br>","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497864,"discussion_content":"亲爱的，你慢慢飞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591774105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224923,"user_name":"灰尘","can_delete":false,"product_type":"c1","uid":1155092,"ip_address":"","ucode":"362C407B8E1307","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/14/c3f6c745.jpg","comment_is_top":false,"comment_ctime":1591593832,"is_pvip":false,"replies":[{"id":"82948","content":"你的目标如果是测SQL，连数据库是可以的。但是，要把数据库和业务分开，参见后面讲DI容器的一节。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591706796,"ip_address":"","comment_id":224923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591593832","product_id":100052601,"comment_content":"如果要测试复杂查询条件的sql，还是要依赖数据库吧","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497656,"discussion_content":"你的目标如果是测SQL，连数据库是可以的。但是，要把数据库和业务分开，参见后面讲DI容器的一节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591706796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222811,"user_name":"jacky","can_delete":false,"product_type":"c1","uid":1049177,"ip_address":"","ucode":"A0BD06E2ABF520","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/59/989f65c8.jpg","comment_is_top":false,"comment_ctime":1590916804,"is_pvip":false,"replies":[{"id":"82254","content":"后面我们讲到封装的时候会提到，封装是基于行为的，而不是基于数据的，具体的数据表是底层实现。而测试，我们的目标应该是基于行为的。<br><br>每个模块都会有一些可观察的行为，无论是通过返回值，或是通过查看的接口，这些可观察的行为就是测试的立足点。<br><br>所以，你的这个问题其实更多的是思路的问题，而不是具体测试方法的问题。如果你有更具体的例子，我可以帮助你来分析一下。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591058296,"ip_address":"","comment_id":222811,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590916804","product_id":100052601,"comment_content":"为了可测试性，系统可能无形中多了很多的接口，比如数据库有200个表，可能会出现200个接口，而膨胀的接口让人看起来非常难受。这要怎么解决？","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496926,"discussion_content":"后面我们讲到封装的时候会提到，封装是基于行为的，而不是基于数据的，具体的数据表是底层实现。而测试，我们的目标应该是基于行为的。\n\n每个模块都会有一些可观察的行为，无论是通过返回值，或是通过查看的接口，这些可观察的行为就是测试的立足点。\n\n所以，你的这个问题其实更多的是思路的问题，而不是具体测试方法的问题。如果你有更具体的例子，我可以帮助你来分析一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591058296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222628,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1590851667,"is_pvip":true,"replies":[{"id":"85080","content":"可测试性和写测试，其实是两个独立的维度，首先要有可测试性，然后，再说要不要写测试。<br><br>TDD想要得到一个好的设计，前提条件是知道什么叫好的设计，所以，要先学点设计。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1593408564,"ip_address":"","comment_id":222628,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1590851667","product_id":100052601,"comment_content":"“保证每个模块在开发阶段能够测试”，是否一定要引入测试驱动开发或者单元测试？如果对每个模块进行手工测试，或者是自动化黑盒测试呢？<br><br>在瀑布开发模式，或者是普通的团队中，测试人员一般都是在整个软件基本完成之后才开始进行测试。外部测试很难在函数或者模块级别开始介入。<br><br>在设计的时候，想一下这个模块要怎么测，其实就是考虑清楚这个模块要怎么调用。<br><br>之前接触过测试驱动开发，使用 Mock 框架来模拟各种外部访问资源，应该算是其中的高级技术话题。另外一个难点，是在于任务分解，所以我准备同步去学习《10X程序员工作法》。<br><br>如果没有单元测试和测试驱动开发，我觉的重构和持续集成也很难做好，主要是每次调试 bug 都需要比预计更多的时间。<br><br>做软件设计的时候，考虑可测试性，其实也算是“以终为始”的一种思维方式。<br><br>看了一下留言，虽然不多，但是藏龙卧虎。<br><br>老师在留言里面提到做好 TDD，前提是懂一点设计。我的理解是先有 TDD，然后重构，最终得到好的设计。当然，如果有一定的经验，知道什么是好的设计，无疑可以少走一点弯路。","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496867,"discussion_content":"可测试性和写测试，其实是两个独立的维度，首先要有可测试性，然后，再说要不要写测试。\n\nTDD想要得到一个好的设计，前提条件是知道什么叫好的设计，所以，要先学点设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593408564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222614,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1590849075,"is_pvip":false,"replies":[{"id":"82113","content":"我在部落里发了一个长回答，回答这个有共性的问题，供参考。<br><br>http:&#47;&#47;gk.link&#47;a&#47;10iL3","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1590888911,"ip_address":"","comment_id":222614,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1590849075","product_id":100052601,"comment_content":"还有个问题，因为方法封装的 关系，有些业务逻辑是访问级别是私有的 ，如果想在单元测试里测试这样的代码，只有暂时性的把访问级别提高到公有了吗，这个问题困扰了很久，没想到什么好的办法。","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496862,"discussion_content":"我在部落里发了一个长回答，回答这个有共性的问题，供参考。\n\nhttp://gk.link/a/10iL3","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590888911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1867796,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/80/14/0bcc4dd3.jpg","nickname":"Victor","note":"","ucode":"0AA9F68348A4D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278152,"discussion_content":"按理说，对于一个类更关心的是公有方法的调用，应该不需要测试到私有方法，涉及到了私有方法说明类暴露的外部接口不合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591154953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021539,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","nickname":"捞鱼的搬砖奇","note":"","ucode":"2FD194C4DA26E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276514,"discussion_content":"我看到了，已经在部落做了回复，谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590893494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222610,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1590848943,"is_pvip":false,"replies":[{"id":"82111","content":"把Spring启动起来，这就是集成测试了，一定要把集成测试的规模缩小，多用单元测试，我在《10x 程序员工作法》里讲过了。<br><br>最好的办法当然是把业务逻辑测试分开测，在第5讲，我们会讲到Spring DI容器的来源，希望你从那个部分里能够借鉴一些思路。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1590886830,"ip_address":"","comment_id":222610,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590848943","product_id":100052601,"comment_content":"想请教老师，类似 Spring 这样的，举例子说我要测试一个业务逻辑，这个逻辑里包含了对表的操作。最好的方式是把逻辑和表操作分开测试吗，还要 在测试能运行之前 Spring 要创建一堆的 Bean，如果系统规模大启动的时间就要很久，这样有简化的办法吗","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496860,"discussion_content":"把Spring启动起来，这就是集成测试了，一定要把集成测试的规模缩小，多用单元测试，我在《10x 程序员工作法》里讲过了。\n\n最好的办法当然是把业务逻辑测试分开测，在第5讲，我们会讲到Spring DI容器的来源，希望你从那个部分里能够借鉴一些思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590886830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222371,"user_name":"Flynn","can_delete":false,"product_type":"c1","uid":1174517,"ip_address":"","ucode":"293321CC198C0C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aY5QA2COoiaGy7P3MJzUIam3GG94GpA0fTx8yJN3OyBiaP3eNL65ia99H4RbaqC4fypg7JhBOujlJs7bBTdJKdMUQ/132","comment_is_top":false,"comment_ctime":1590762875,"is_pvip":false,"replies":[{"id":"82067","content":"后面还会提到单例，这里不妨说两句。你真的需要一个在语法上的单例吗？实际上，对于大多数系统而言，在系统内保持唯一就可以了，如果使用 DI 容器的话，缺省的对象模式就是全局唯一，所以，只要想清楚，我们需要的是什么样的单例，问题就简单了。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1590843640,"ip_address":"","comment_id":222371,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590762875","product_id":100052601,"comment_content":"现在的测试都是人工测试，造成的问题主要是频繁回归，改了代码就担心破坏了以前的功能。因为没考虑可测试性，项目里存在很多的单例。不用单例可以用什么方式呢？","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496768,"discussion_content":"后面还会提到单例，这里不妨说两句。你真的需要一个在语法上的单例吗？实际上，对于大多数系统而言，在系统内保持唯一就可以了，如果使用 DI 容器的话，缺省的对象模式就是全局唯一，所以，只要想清楚，我们需要的是什么样的单例，问题就简单了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590843640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222352,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1590757439,"is_pvip":false,"replies":[{"id":"82533","content":"虽然我把模块进行了分解，但并代表把细节暴露出去。<br><br>你这里的 calller， 它面对的还是同样的一个接口，只不过，在内部被分成了多个可以组合的模块。Caller 并不知道里面是由哪些模块组成的，以及如何组成的，这怎么算暴露细节呢？<br><br>单独拆分出来的模块的方法确实要变成 public，但它们作为一个独立的模块，提供一个完成特定功能的方法，所以，有一个 public 的方法是很正常的。<br><br>这里的关键点在于，什么叫把细节暴露出去，这个暴露到底是针对谁而言的。这是需要回答的问题。在没有分离关注点的时候，它是一个方法内部的细节，在分离关注点之后，它就不再是一个方法内部了，每个模块都是一个独立的模块。你怎么判断它是不是暴露细节呢？这是一个需要想清楚的问题。<br><br>","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591314860,"ip_address":"","comment_id":222352,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590757439","product_id":100052601,"comment_content":"还想请教一下老师对于模块应该怎么理解？比如您给我回复的生成pdf的步骤里：是否把每一个步骤都作为一个模块？那是不是把内部的实现细节暴露出去了，因为对于caller来说 我给你数据 你帮我生成pdf至于你通过什么方式渲染caller不管也无权过问 但是如果把模块独立出去了那是否以为着某些方法会变成public的？那是否说明我们把实现细节暴露出去了？","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496763,"discussion_content":"虽然我把模块进行了分解，但并代表把细节暴露出去。\n\n你这里的 calller， 它面对的还是同样的一个接口，只不过，在内部被分成了多个可以组合的模块。Caller 并不知道里面是由哪些模块组成的，以及如何组成的，这怎么算暴露细节呢？\n\n单独拆分出来的模块的方法确实要变成 public，但它们作为一个独立的模块，提供一个完成特定功能的方法，所以，有一个 public 的方法是很正常的。\n\n这里的关键点在于，什么叫把细节暴露出去，这个暴露到底是针对谁而言的。这是需要回答的问题。在没有分离关注点的时候，它是一个方法内部的细节，在分离关注点之后，它就不再是一个方法内部了，每个模块都是一个独立的模块。你怎么判断它是不是暴露细节呢？这是一个需要想清楚的问题。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591314860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1606669,"avatar":"https://static001.geekbang.org/account/avatar/00/18/84/0d/4e289b94.jpg","nickname":"三生","note":"","ucode":"1DE1A2693A5E33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276358,"discussion_content":"我认为本身这个功能属于一个模块，如果功能较少应该不用暴露细节，最后只有一个execute即可，测试的时候应该考虑的是最后结果，不会注重这个生成的过程吧。\n若是中间有其他复杂数据变换等操作应当进行封装调用工具类进行生成，这样也是只有一个execute，测试的时候更加关注工具类的行为和结果是否正确，有点像老师的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590853482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}