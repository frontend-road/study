[{"article_id":169177,"article_title":"开篇词 | C++这么难，为什么我们还要用C++？","article_content":"<p>你好，我是吴咏炜。</p><p>C++ 可算是一种声名在外的编程语言了。这个名声有好有坏，从好的方面讲，C++ 性能非常好，哪个编程语言性能好的话，总忍不住要跟 C++ 来单挑一下；从坏的方面讲，它是臭名昭著的复杂、难学、难用。当然，这样一来，熟练的 C++ 程序员也就自然而然获得了“水平很高”的名声，所以这也不完全是件坏事。</p><p>不管说 C++ 是好还是坏，不可否认的是，C++ 仍然是一门非常流行且非常具有活力的语言。继沉寂了十多年，并终于发布语言标准的第二版——C++11——之后，C++ 以每三年一版的频度发布着新的语言标准，每一版都在基本保留向后兼容性的同时，提供着改进和新功能。<strong>本专栏主要就是讲这些新特性以及相关的编程实践。</strong></p><p>在讲所有这些细节之前，我想先讲一讲为什么要用 C++，什么时候该用 C++，及如何学习 C++。</p><h2>C++ 的意义</h2><p>C++ 程序员应该都听到过下面这种说法：</p><blockquote>\n<p>C++ 是一门多范式的通用编程语言。</p>\n</blockquote><p>多范式，是因为 C++ 支持面向过程编程，也支持面向对象编程，也支持泛型编程，新版本还可以说是支持了函数式编程。同时，上面这些不同的范式，都可以在同一项目中组合使用，这就大大增加了开发的灵活性。因此，C++ 适用的领域非常广泛，小到嵌入式，大到分布式服务器，到处可以见到 C++ 的身影。</p><!-- [[[read_end]]] --><p>下面是一些著名的用到 C++ 的场合：</p><ul>\n<li>大型桌面应用程序（如 Adobe Photoshop、Google Chrome 和 Microsoft Office）</li>\n<li>大型网站后台（如 Google 的搜索引擎）</li>\n<li>游戏（如 StarCraft）和游戏引擎（如 Unreal 和 Unity）</li>\n<li>编译器（如 LLVM/Clang 和 GCC）</li>\n<li>解释器（如 Java 虚拟机和 V8 JavaScript 引擎）</li>\n<li>实时控制（如战斗机的飞行控制和火星车的自动驾驶系统）</li>\n<li>视觉和智能引擎（如 OpenCV、TensorFlow）</li>\n<li>数据库（如 Microsoft SQL Server、MySQL 和 MongoDB）</li>\n</ul><p>有些同学可能会觉得，这些应用场景似乎和平时的开发场景有点远啊！你的感觉是对的。有些传统上使用 C++ 的场合现在已经不一定使用 C++，最典型的是个人电脑上的桌面应用。以前 Windows 下开发桌面应用常常用 MFC，微软的 C++ 框架，而现在我估计听说过 MFC 的程序员都不多吧。目前很流行的 Visual Studio Code 主要是用 TypeScript 写的，不是 C++。而我自己也用 C# 写过桌面应用，不过界面逻辑之外的计算和处理仍然是用一个 C++ 的 DLL 来完成。典型情况是，需要性能的组件用 C++ 来写，整个应用程序融合多种不同的语言。</p><p>前面我提到了， C++ 的传统领域有被侵蚀的风险，那是因为和它相竞争的语言远远不止一个，可以说是上下夹攻。</p><ul>\n<li>如果专注性能和最小内存占用的话，C 仍然是首选——嵌入式领域用 C 非常多，而 Linux 也是用纯 C 写的。</li>\n<li>如果专注抽象表达和可读性的话，那 Python 之类的脚本语言则要方便得多。</li>\n<li>图形界面（GUI）编程传统上是 C++ 的地盘，但近年来 C# 和 JavaScript 占领了很大一部分市场。</li>\n<li>游戏算是 C++ 的经典强项了，但有了 C++ 写的游戏引擎，游戏用 C# 写也没啥问题了——你可能不一定知道，Unity 游戏引擎上的首选开发语言是 C#，而王者荣耀是用什么游戏引擎呢？答案正是 Unity——所以王者荣耀可以认为是用 C# 开发的。</li>\n<li>还有，Go 和 Rust 也加入了战团，对 C++ 形成了一定的竞争……</li>\n</ul><p><strong>看起来，C++ 有点危险啊……</strong></p><p>不过，真是这样吗？我们需要回到 C++ 的核心竞争力上来看一下。</p><ul>\n<li>抽象能力：意味着较高的开发效率，同时，更重要的是，不会因抽象而降低性能。</li>\n<li>性能：这不用多说了，就是快并且占用资源少。</li>\n<li>功耗：这是近年来我们越来越关注的问题，跟性能直接相关，性能好了功耗自然就低。</li>\n</ul><p>计算机在发明的初期，价格奇高，而性能拿今天的标准来看却是极低的，自然不能不关注性能。慢慢地，计算机的性能“足够”了，性能似乎也就不那么重要了，脚本语言于是也有了用武之地。而随着移动设备的普遍使用，大量设备用电池供电而不接电源了，功耗就逐渐成了我们大家关注的大问题。因此，即使主流移动平台的开发语言不是 C++——而是 Java 和 Objective-C 或 Swift——但任何性能要求高的应用，都几乎必然会用到 C++ 开发的组件。</p><p>同时，移动设备要联网，也大大刺激了服务器的增加。在服务器端，虽然没有电池电量的问题，但有着服务器集群的供电问题、空调问题、需要的服务器数量问题等，因而  C++ 的使用也是非常广泛的。</p><p>前面说到了王者荣耀的客户端是用 Unity + C# 开发的，但我没有说王者荣耀的服务器端——那可还是用 C++ 开发的。另外，有一点我前面还藏着呢！虽然王者荣耀初期是纯用 Unity 开发的，没有用到 C++；但后来，腾讯又用 C++ 把游戏的逻辑部分独立成了一个 GameCore，进一步提高了性能  <span class=\"orange\">[1]</span>。</p><p>目前，跟 C++ 定位差不多、能有直接竞争关系的，也就是既支持高度抽象、又追求高性能的通用编程语言，其实只有 Rust 一种。而 Rust 远没有达到跟 C++ 一样的成熟和普及程度。这也可以从 TIOBE 的排名看出来：C++ 是第 4 位，而 Rust 是第 25 位  <span class=\"orange\">[2]</span>。</p><p>另外，和 C 的兼容性，也是 C++ 的一大优势。虽然现在很多大型程序都混杂了多种语言，但在小项目里，减少语言的数量可以简化开发和部署。前不久，我在 Python 里做了一些加解密运算，发现使用的第三方库性能仍不够高，虽然它已经用了 C 开发的加解密引擎。所以，我找了用 C 写的高性能加解密代码，然后使用 pybind11 库  <span class=\"orange\">[3]</span>，只手写了一百来行的 C++11 代码，就把性能又提高了几倍。</p><h2>什么时候该用 C++？</h2><p>如此说来，C++ 既然性能又好，又支持抽象，为什么没有更流行呢？</p><p>因为代价更高。C++ 是一种复杂的语言，难以上手和熟练掌握，因此也是一种比较容易出错、被误用的语言。C++ 一直与 C 基本保持了向后兼容性，这种兼容性，也一直是 C++ 的安全性和易用性方面的负担。C++ 比起 C 来，要更安全，更不容易出现缓冲区溢出这类漏洞，但跟没有指针概念的语言比起来，它仍然是一种“不安全”的语言。我的个人经验，完成同样的功能，C++ 需要的代码行数一般是 Python 的三倍左右，而性能则可以达到 Python 的十倍以上。</p><p><strong>问题来了：你在开发上额外付出的时间，能从性能上省回来吗？</strong></p><p>显然，这取决于你开发软件的用途和开发时间。举个例子，如果你用 Python 开发需要一天，运行需要十秒，并且不需要反复运行；那么，转用 C++ 开发就意味着开发费用也许要增加两倍，开发加运行的总时间增加两天，大亏。</p><p>反之，如果用Python开发还是需要一天，单次运行需要十秒，但是软件会作为服务长时间运行、每天被调用十万次。在这种情况下，明显你就需要多台服务器来支撑其使用了。这时，如果用 C++ 开发会需要额外的两天，但跟 Python 相比，部署上有望节约十分之九的硬件和电费——那就很值了。</p><p>简言之，当你的软件属于运算密集或者内存密集型，你需要性能、且愿意为性能付出额外代价的时候，应该考虑用 C++，特别在你的代码需要部署在多台服务器或者移动设备的场合。反之，如果性能不会成为你开发的软件的瓶颈，那 C++ 可能就不是一个最合适的工具。</p><p>此外，在嵌入式应用的场景，那就根本不是值不值、而是行不行的问题。如果程序完成一个功能不能在指定的若干毫秒、甚至微秒内完成，那产品根本是失败、不可用的。在这种场合，能和 C++ 竞争的只有 C，但 C 是一种开发效率更低、更需要堆人力的语言了。在嵌入式开发使用 C++ 的最大障碍可能不是技术，而是人力资源——搞嵌入式开发的程序员可能大多都习惯使用纯 C 了。</p><p>由于 C++ 是解决性能问题的利器，短时间里在市场上没有真正的竞争对手，对 C++ 的需求会在相当长的时间里一直存在，尤其在大公司和像金融机构一样对性能渴求的地方。顺便提一句，C++ 之父 Bjarne Stroustrup 目前就职的地方便是摩根斯坦利。</p><h2>如何学习 C++？</h2><p>作为很多聪明人使用过的语言，C++ 在某些场合也可能被用来炫技，写出除了本人之外谁都看不懂的高抽象代码。这恰恰是 Bjarne 想努力抵制的方向。他想让 C++ 对初学者变得更为友好，也明确提出过，他不希望 C++ 是一种让人们耍机灵的语言，而是一种让人们更易于使用的语言 <span class=\"orange\">[4]</span>。</p><p>这同样也是本专栏的一个目标：我希望你能把 C++ 当作一种实用的语言，能用它写出抽象但自然的代码，而非佶屈聱牙、难以卒读的那种。希望我 30 年的 C++ 经验能够给你一点帮助。</p><p>学习 C++ 语言就像学一门活跃使用中的外语，你不要期望能够掌握所有的单词和语法规则——那对于世界上 99.999999% 的人来说是不可能的。但语言是服务于人的，语法规则也是服务于人的，是为了让人们能够更好地沟通和表达。虽然 C++ 的每一个新标准都是让语言从定义和规则的角度变得更复杂，但从用法上来说，新标准允许人们能够更简单地表达自己的计算意图。跟学外语一样，我们需要的是多看多写，掌握合适的“语感”，而不是记住所有的规则。</p><p><strong>Bjarne 有一个洋葱理论：</strong>抽象层次就像一个洋葱，是层层嵌套的。如果想用较低的抽象层次表达较高的概念，就好比一次切过了很多层洋葱，你会把自己的眼泪熏出来的。与这个思路相反，教 C++ 往往有一种不好的倾向，从那些琐碎易错的底层教起，自底向上，使得学生常常在尚未领悟到抽象的真谛之前就已经被 C++ 的复杂性吓翻，从入门到放弃；或者，在学了基本的 C 语法和 class 之后就满足了，错过了高级抽象带来的全新境界。他主张学习应当自顶向下，先学习高层的抽象，再层层剥茧、丝丝入扣地一步步进入下层。如果一次走太深的话，挫折可能就难免了。</p><p>作为专栏而非具体的工具参考书，我会重点讲是什么和为什么，而不是语法细节。同样，我也不讲或少讲技巧，但在需要的地方，我会给出合适的参考资料。希望你在学习了本专栏之后，能够知道某个 C++ 的功能为什么存在和应该在什么情况下使用。那样的话，本专栏的目的就达到了。</p><p><strong>具体内容上，本专栏共分为四个部分，详情如下：</strong></p><ul>\n<li>第一部分——基础篇，讲解现代 C++ 中的最重要特性，帮助你理解基础概念。</li>\n<li>第二部分——提高篇，讲述几个独立的专题，帮助你掌握 C++ 中的一些高级技巧。</li>\n<li>第三部分——实战篇，讨论实际的工具和第三方库，帮助你打磨手头的兵器库。</li>\n<li>第四部分——未来篇，讨论 C++20 中即将引入的一些新特性，帮助你培养前瞻性。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/5b/53/5bdb83751b83699dd6f84239f1792053.jpg\" alt=\"\"></p><p>希望你在完整地学完这四个部分之后，能对现代 C++，这一熟悉而又陌生的语言，有着新的理解，并用它去更好地解决项目中的实际问题。</p><p>最后，感谢你的关注。关于 C++ 呢，不知道你有什么样的看法？你学习它的主要原因是什么？你平时使用 C++ 的场景有哪些？欢迎你在留言区和我交流。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] 游戏葡萄，“《王者荣耀》技术总监复盘回炉历程：没跨过这三座大山，就是另一款MOBA霸占市场了”。<a href=\"https://gameinstitute.qq.com/community/detail/115782\">https://gameinstitute.qq.com/community/detail/115782</a> </span></p><p><span class=\"reference\">[2] TIOBE Index for November 2019. <a href=\"https://www.tiobe.com/tiobe-index/\">https://www.tiobe.com/tiobe-index/</a> </span></p><p><span class=\"reference\">[3] Wenzel Jakob et al., pybind11. <a href=\"https://github.com/pybind/pybind11\">https://github.com/pybind/pybind11</a> </span></p><p><span class=\"reference\">[4] Interview, “What’s all the C Plus Fuss? Bjarne Stroustrup warns of dangerous future plans for his C++”. <a href=\"https://www.theregister.co.uk/2018/06/18/bjarne_stroustrup_c_plus_plus/\">https://www.theregister.co.uk/2018/06/18/bjarne_stroustrup_c_plus_plus/</a> </span></p>","neighbors":{"left":[],"right":{"article_title":"课前必读 | 有关术语发音及环境要求","id":169198}}},{"article_id":169198,"article_title":"课前必读 | 有关术语发音及环境要求","article_content":"<p>你好，我是吴咏炜。</p><p>这一讲是课前必读，主要说明术语发音和环境要求的问题，希望能帮助你更好地学习和实践本专栏的内容。</p><h2>术语发音列表</h2><p>C++ 里有些术语不是标准的英文单词。在本专栏中使用下面的发音表：</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/72/bc0ee5d92ae1d741c14b8fef6fb04d72.jpg\" alt=\"\"></p><p>注意这些发音并没有标准化，列出来只是为了避免发生误解。你不一定必须按照我的读法来。</p><h2>环境要求</h2><p>在专栏中，我大部分时间都会使用不超过 C++17 标准的语言特性。而要编译示例代码，需要以下所列的至少一种编译器：</p><ul>\n<li>GCC 7 或更新版本</li>\n<li>Clang 5 或更新版本</li>\n<li>Visual Studio 2017 15.9 (MSVC 19.16) 或更新版本</li>\n</ul><p>以上三种编译器应当都能够工作——但我无法保证。如果遇到问题的话，请升级到跟我的测试环境相同的版本：</p><ul>\n<li>GCC 8.3</li>\n<li>Clang 9.0</li>\n<li>Visual Studio 2019 16.3 (MSVC 19.23)</li>\n</ul><p>如果你对跨平台性不那么讲究的话，推荐使用你的操作系统里最常用的编译器。也就是：</p><ul>\n<li>用 Windows 的话，使用 MSVC</li>\n<li>用 Linux 的话，使用 GCC</li>\n<li>用 macOS 的话，使用 Clang（但如果操作系统比 Mojave 老的话，苹果提供的开发工具不能完整支持 C++17；你需要升级操作系统，或者使用非苹果的编译器——如 Homebrew 提供的 gcc 和 llvm <span class=\"orange\">[1]</span>）</li>\n</ul><!-- [[[read_end]]] --><p>对在 Windows 上使用 GCC 的开发者，我要特别提醒一句：要获得最全面的功能，你应当使用 MinGW-w64 的 POSIX 线程版本，这样才能完整使用 C++ 标准里的功能。当前版本可从参考资料 <span class=\"orange\">[2]</span> 的链接下载。</p><p>使用稳定发布版（如 CentOS）的 Linux 用户也需要检查一下，你的 GCC 版本有可能比较老。如果早于 GCC 7 的话，建议你安装一个新版本的 GCC（不需要覆盖系统的 GCC）。比如，对于 CentOS 7，系统安装的 GCC 版本是 4.8，太老，你可以通过安装 centos-release-scl 和 devtoolset-7-gcc-c++ 两个包来获得 GCC 7；随后，可以使用命令 <code>scl enable devtoolset-7 bash</code> 或 <code>. /opt/rh/devtoolset-7/enable</code> 来启用 GCC 7。</p><p>稍需注意的是，最后在讲到 C++20 新特性时，某些实验功能可能会要求某个特定的编译器。这种情况下，你可能就需要安装、使用非默认的编译器了。不过，只有少数几讲需要这么做，不用担心。</p><p>由于专栏涉及到的都是较短的代码，我不会提供工程文件。建议你熟悉编译器的命令行，来快速编译代码。使用 GCC 的话，推荐使用下面的命令行：</p><p><code>g++ -std=c++17 -W -Wall -Wfatal-errors 文件名</code></p><p>Clang 的话也比较类似：</p><p><code>clang++ -std=c++17 -W -Wall -Wfatal-errors 文件名</code></p><p>MSVC 的命令行风格有点不同，一般需要下面这样子：</p><p><code>cl /std:c++17 /EHsc /W3 文件名</code></p><p>另外，即使不用较新的 C++ 特性，你也一定要用比较新的编译器。单单是输出错误信息的友好程度，老版本和新版本就是没法比的。</p><p>以 GCC 为例，老版本输出错误信息是单色的，在碰到有模板的代码时，错误信息动辄几百行，以致那时有人专门开发了软件来让错误信息更可读 <span class=\"orange\">[3]</span>。幸运的是，我们今天不再需要这类软件了，编译器的输出比之前友好得多，GCC 和 Clang 还会使用颜色来展示问题的重点。下面这张图，就是 GCC 9.2 的输出。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/23/13fbdc8077a5a330e45c5ccdc94c2923.png\" alt=\"\"></p><p>明确好以上内容，我们就要正式开始了，你准备好了吗？</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Homebrew. <a href=\"https://brew.sh/\">https://brew.sh/</a></span></p><p><span class=\"reference\">[2] MinGW-w64 GCC-8.1.0. <a href=\"https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/8.1.0/threads-posix/dwarf/\">https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/8.1.0/threads-posix/dwarf/</a></span></p><p><span class=\"reference\">[3] Leor Zolman, “STLFilt: An STL error message decryptor for C++”. <a href=\"https://www.bdsoft.com/tools/stlfilt.html\">https://www.bdsoft.com/tools/stlfilt.html</a></span></p>","neighbors":{"left":{"article_title":"开篇词 | C++这么难，为什么我们还要用C++？","id":169177},"right":{"article_title":"01 | 堆、栈、RAII：C++里该如何管理资源？","id":169225}}},{"article_id":169225,"article_title":"01 | 堆、栈、RAII：C++里该如何管理资源？","article_content":"<p>你好，我是吴咏炜。</p><p>今天我们就正式开启了C++的学习之旅，作为第一讲，我想先带你把地基打牢。我们来学习一下内存管理的基本概念，大致的学习路径是：先讲堆和栈，然后讨论 C++ 的特色功能  RAII。掌握这些概念，是能够熟练运用 C++ 的基础。</p><h2>基本概念</h2><p><strong>堆</strong>，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。</p><p>C++ 标准里一个相关概念是自由存储区，英文是 free store，特指使用 <code>new</code> 和 <code>delete</code> 来分配和释放内存的区域。一般而言，这是堆的一个子集：</p><ul>\n<li><code>new</code> 和 <code>delete</code> 操作的区域是 free store</li>\n<li><code>malloc</code> 和 <code>free</code> 操作的区域是 heap</li>\n</ul><p>但 <code>new</code> 和 <code>delete</code> 通常底层使用 <code>malloc</code> 和 <code>free</code> 来实现，所以 free store 也是 heap。鉴于对其区分的实际意义并不大，在本专栏里，除非另有特殊说明，我会只使用堆这一术语。</p><p><strong>栈</strong>，英文是 stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或 LIFO）。</p><!-- [[[read_end]]] --><p><strong>RAII</strong>，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。</p><p>RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。</p><p>接下来，我将会对堆、栈和 RAII 进行深入的探讨。</p><h2>堆</h2><p>从现代编程的角度来看，使用堆，或者说使用动态内存分配，是一件再自然不过的事情了。下面这样的代码，都会导致在堆上分配内存（并构造对象）。</p><pre><code class=\"language-c++\">// C++\nauto ptr = new std::vector&lt;int&gt;();\n</code></pre><pre><code class=\"language-java\">// Java\nArrayList&lt;int&gt; list = new ArrayList&lt;int&gt;();\n</code></pre><pre><code class=\"language-python\"># Python\nlst = list()\n</code></pre><p>从历史的角度，动态内存分配实际上是较晚出现的。由于动态内存带来的不确定性——内存分配耗时需要多久？失败了怎么办？等等——至今仍有很多场合会禁用动态内存，尤其在实时性要求比较高的场合，如飞行控制器和电信设备。不过，由于大家多半对这种用法比较熟悉，特别是从 C 和 C++ 以外的其他语言开始学习编程的程序员，所以提到内存管理，我们还是先讨论一下使用堆的编程方式。</p><p>在堆上分配内存，有些语言可能使用 <code>new</code> 这样的关键字，有些语言则是在对象的构造时隐式分配，不需要特殊关键字。不管哪种情况，程序通常需要牵涉到三个可能的内存管理器的操作：</p><ol>\n<li>让内存管理器分配一个某个大小的内存块</li>\n<li>让内存管理器释放一个之前分配的内存块</li>\n<li>让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放</li>\n</ol><p>C++ 通常会做上面的操作 1 和 2。Java 会做上面的操作 1 和 3。而 Python 会做上面的操作 1、2、3。这是语言的特性和实现方式决定的。</p><p><strong>需要略加说明的是，上面的三个操作都不简单，并且彼此之间是相关的。</strong></p><p>第一，分配内存要考虑程序当前已经有多少未分配的内存。内存不足时要从操作系统申请新的内存。内存充足时，要从可用的内存里取出一块合适大小的内存，做簿记工作将其标记为已用，然后将其返回给要求内存的代码。</p><p>需要注意到，绝大部分情况下，可用内存都会比要求分配的内存大，所以代码只被允许使用其被分配的内存区域，而剩余的内存区域仍属于未分配状态，可以在后面的分配过程中使用。另外，如果内存管理器支持垃圾收集的话，分配内存的操作还可能会触发垃圾收集。</p><p>第二，释放内存不只是简单地把内存标记为未使用。对于连续未使用的内存块，通常内存管理器需要将其合并成一块，以便可以满足后续的较大内存分配要求。毕竟，目前的编程模式都要求申请的内存块是连续的。</p><p>第三，垃圾收集操作有很多不同的策略和实现方式，以实现性能、实时性、额外开销等各方面的平衡。由于 C++ 里通常都不使用垃圾收集，所以就不是我们专栏的重点，不再展开讲解。</p><p>下面这张图展示了一个简单的分配过程：</p><p><img src=\"https://static001.geekbang.org/resource/image/18/5a/1814fb6093744c64ac9d3861fb4d3a5a.png\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/a7/3b/a7b72d6062c5cd798a2de991bffd713b.png\" alt=\"\"></p><p>注意在图 1e 的状态下，内存管理器是满足不了长度大于 4 的内存分配要求的；而在图 1f 的状态，则长度小于等于 7 的单个内存要求都可以得到满足。</p><p>当然，这只是一个简单的示意，只是为了让你能够对这个过程有一个大概的感性认识。在不考虑垃圾收集的情况下，内存需要手工释放；在此过程中，内存可能有碎片化的情况。比如，在图 1d 的情况下，虽然总共剩余内存为 6，但却满足不了长度大于 4 的内存分配要求。</p><p>幸运的是，大部分软件开发人员都不需要担心这个问题。内存分配和释放的管理，是内存管理器的任务，一般情况下我们不需要介入。我们只需要正确地使用 <code>new</code> 和 <code>delete</code>。每个 <code>new</code> 出来的对象都应该用 <code>delete</code> 来释放，就是这么简单。</p><p>但真的很简单、可以高枕无忧了吗？</p><p>事实说明，漏掉 <code>delete</code> 是一种常见的情况，这叫“内存泄漏”——相信你一定听到过这个说法。为什么呢？</p><p>我们还是看一些代码例子。</p><pre><code class=\"language-c++\">void foo()\n{\n  bar* ptr = new bar();\n  …\n  delete ptr;\n}\n</code></pre><p>这个很简单吧，但是却存在两个问题：</p><ol>\n<li>中间省略的代码部分也许会抛出异常，导致最后的 <code>delete ptr</code> 得不到执行。</li>\n<li>更重要的，这个代码不符合 C++ 的惯用法。在 C++ 里，这种情况下有 99% 的可能性不应该使用堆内存分配，而应使用栈内存分配。这样写代码的，估计可能是从 Java 转过来的🤭——但我真见过这样的代码。</li>\n</ol><p>而更常见、也更合理的情况，是分配和释放不在一个函数里。比如下面这段示例代码：</p><pre><code class=\"language-c++\">bar* make_bar(…)\n{\n  bar* ptr = nullptr;\n  try {\n    ptr = new bar();\n    …\n  }\n  catch (...) {\n    delete ptr;\n    throw;\n  }\n  return ptr;\n}\n\nvoid foo()\n{\n  …\n  bar* ptr = make_bar(…)\n  …\n  delete ptr;\n}\n</code></pre><p>这样的话，会漏 <code>delete</code> 的可能性是不是大多了？有关这个问题的解决方法，我们在下一讲还会提到。</p><p>好，堆我们暂时就讨论到这儿。下面，我们看看更符合 C++ 特性的栈内存分配。</p><h2>栈</h2><p>我们先来看一段示例代码，来说明 C++ 里函数调用、本地变量是如何使用栈的。当然，这一过程取决于计算机的实际架构，具体细节可能有所不同，但原理上都是相通的，都会使用一个后进先出的结构。</p><pre><code class=\"language-c++\">void foo(int n)\n{\n  …\n}\n\nvoid bar(int n)\n{\n  int a = n + 1;\n  foo(a);\n}\n\nint main()\n{\n  …\n  bar(42);\n  …\n}\n</code></pre><p>这段代码执行过程中的栈变化，我画了下面这张图来表示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/3b/6ef3d653af7fa6c9728ea4bea348093b.png\" alt=\"\"></p><p>在我们的示例中，栈是向上增长的。在包括 x86 在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。任何一个函数，根据架构的约定，只能使用进入函数时栈指针向上部分的栈空间。当函数调用另外一个函数时，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，并跳转到新的函数。新的函数进入后，首先做一些必须的保存工作，然后会调整栈指针，<strong>分配出本地变量所需的空间</strong>，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。</p><p>注意到了没有，本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了。我们可以看到：</p><ul>\n<li>栈上的分配极为简单，移动一下栈指针而已。</li>\n<li>栈上的释放也极为简单，函数执行结束时移动一下栈指针即可。</li>\n<li>由于后进先出的执行过程，不可能出现内存碎片。</li>\n</ul><p>顺便说一句，图 2 中每种颜色都表示某个函数占用的栈空间。这部分空间有个特定的术语，叫做栈帧（stack frame）。GCC 和 Clang 的命令行参数中提到 frame 的，如 <code>-fomit-frame-pointer</code>，一般就是指栈帧。</p><p>前面例子的本地变量是简单类型，C++ 里称之为 POD 类型（Plain Old Data）。对于有构造和析构函数的非 POD 类型，栈上的内存分配也同样有效，只不过 C++ 编译器会在生成代码的合适位置，插入对构造和析构函数的调用。</p><p>这里尤其重要的是：编译器会自动调用析构函数，包括在函数执行发生异常的情况。在发生异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding）。事实上，如果你用 MSVC 编译含异常的 C++ 代码，但没有使用上一讲说过的 <code>/EHsc</code> 参数，编译器就会报告：</p><blockquote>\n<p>warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc</p>\n</blockquote><p>下面是一段简短的代码，可以演示栈展开：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n\nclass Obj {\npublic:\n  Obj() { puts(\"Obj()\"); }\n  ~Obj() { puts(\"~Obj()\"); }\n};\n\nvoid foo(int n)\n{\n  Obj obj;\n  if (n == 42)\n    throw \"life, the universe and everything\";\n}\n\nint main()\n{\n  try {\n    foo(41);\n    foo(42);\n  }\n  catch (const char* s) {\n    puts(s);\n  }\n}\n</code></pre><p>执行代码的结果是：</p><blockquote>\n<p><code>Obj()</code><br>\n<code>~Obj()</code><br>\n<code>Obj()</code><br>\n<code>~Obj()</code><br>\n<code>life, the universe and everything</code></p>\n</blockquote><p>也就是说，不管是否发生了异常，<code>obj</code> 的析构函数都会得到执行。</p><p>在 C++ 里，所有的变量缺省都是值语义——如果不使用 <code>*</code> 和 <code>&amp;</code> 的话，变量不会像 Java 或 Python 一样引用一个堆上的对象。对于像智能指针这样的类型，你写 <code>ptr-&gt;call()</code> 和 <code>ptr.get()</code>，语法上都是对的，并且 <code>-&gt;</code> 和 <code>.</code> 有着不同的语法作用。而在大部分其他语言里，访问成员只用 <code>.</code>，但在作用上实际等价于 C++ 的 <code>-&gt;</code>。这种值语义和引用语义的区别，是 C++ 的特点，也是它的复杂性的一个来源。要用好 C++，就需要理解它的值语义的特点。</p><p>对堆和栈有了基本了解之后，我们继续往下，聊一聊 C++ 的重要特性 RAII。</p><h2>RAII</h2><p>C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：</p><ul>\n<li>对象很大；</li>\n<li>对象的大小在编译时不能确定；</li>\n<li>对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。</li>\n</ul><p>常见情况之一是，在工厂方法或其他面向对象编程的情况下，返回值类型是基类（的指针或引用）。下面的例子，是对工厂方法的简单演示：</p><pre><code class=\"language-c++\">enum class shape_type {\n  circle,\n  triangle,\n  rectangle,\n  …\n};\n\nclass shape { … };\nclass circle : public shape { … };\nclass triangle : public shape { … };\nclass rectangle : public shape { … };\n\nshape* create_shape(shape_type type)\n{\n  …\n  switch (type) {\n  case shape_type::circle:\n    return new circle(…);\n  case shape_type::triangle:\n    return new triangle(…);\n  case shape_type::rectangle:\n    return new rectangle(…);\n  …\n  }\n}\n</code></pre><p>这个 <code>create_shape</code> 方法会返回一个 <code>shape</code> 对象，对象的实际类型是某个 <code>shape</code> 的子类，圆啊，三角形啊，矩形啊，等等。这种情况下，函数的返回值只能是指针或其变体形式。如果返回类型是 <code>shape</code>，实际却返回一个 <code>circle</code>，编译器不会报错，但结果多半是错的。这种现象叫对象切片（object slicing），是 C++ 特有的一种编码错误。这种错误不是语法错误，而是一个对象复制相关的语义错误，也算是 C++ 的一个陷阱了，大家需要小心这个问题。</p><p>那么，我们怎样才能确保，在使用 <code>create_shape</code> 的返回值时不会发生内存泄漏呢？</p><p>答案就在析构函数和它的栈展开行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。一个简单的实现如下所示：</p><pre><code class=\"language-c++\">class shape_wrapper {\npublic:\n  explicit shape_wrapper(\n    shape* ptr = nullptr)\n    : ptr_(ptr) {}\n  ~shape_wrapper()\n  {\n    delete ptr_;\n  }\n  shape* get() const { return ptr_; }\nprivate:\n  shape* ptr_;\n};\n\nvoid foo()\n{\n  …\n  shape_wrapper ptr_wrapper(\n    create_shape(…));\n  …\n}\n</code></pre><p>如果你好奇 <code>delete</code> 空指针会发生什么的话，那答案是，这是一个合法的空操作。在 <code>new</code> 一个对象和 <code>delete</code> 一个指针时编译器需要干不少活的，它们大致可以如下翻译：</p><pre><code class=\"language-c++\">// new circle(…)\n{\n  void* temp = operator new(sizeof(circle));\n  try {\n    circle* ptr =\n      static_cast&lt;circle*&gt;(temp);\n    ptr-&gt;circle(…);\n    return ptr;\n  }\n  catch (...) {\n    operator delete(ptr);\n    throw;\n  }\n}\n</code></pre><pre><code class=\"language-c++\">if (ptr != nullptr) {\n  ptr-&gt;~shape();\n  operator delete(ptr);\n}\n</code></pre><p>也就是说，<code>new</code> 的时候先分配内存（失败时整个操作失败并向外抛出异常，通常是 <code>bad_alloc</code>），然后在这个结果指针上构造对象（注意上面示意中的调用构造函数并不是合法的 C++ 代码）；构造成功则 <code>new</code> 操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。<code>delete</code> 时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存。</p><p>回到 <code>shape_wrapper</code> 和它的析构行为。在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：</p><ul>\n<li>关闭文件（<code>fstream</code> 的析构就会这么做）</li>\n<li>释放同步锁</li>\n<li>释放其他重要的系统资源</li>\n</ul><p>例如，我们应该使用：</p><pre><code class=\"language-c++\">std::mutex mtx;\n\nvoid some_func()\n{\n  std::lock_guard&lt;std::mutex&gt; guard(mtx);\n  // 做需要同步的工作\n}\n</code></pre><p>而不是：</p><pre><code class=\"language-c++\">std::mutex mtx;\n\nvoid some_func()\n{\n  mtx.lock();\n  // 做需要同步的工作……\n  // 如果发生异常或提前返回，\n  // 下面这句不会自动执行。\n  mtx.unlock();\n}\n</code></pre><p>顺便说一句，上面的 <code>shape_wrapper</code> 差不多就是个最简单的智能指针了。至于完整的智能指针，我们留到下一讲继续学习。</p><h2>内容小结</h2><p>本讲我们讨论了 C++ 里内存管理的一些基本概念，强调栈是 C++ 里最“自然”的内存使用方式，并且，使用基于栈和析构函数的 RAII，可以有效地对包括堆内存在内的系统资源进行统一管理。</p><h2>课后思考</h2><p>最后留给你一道思考题。<code>shape_wrapper</code> 和智能指针比起来，还缺了哪些功能？欢迎留言和我分享你的观点。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Memory management”. <a href=\"https://en.wikipedia.org/wiki/Memory_management\">https://en.wikipedia.org/wiki/Memory_management</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Stack-based memory allocation”. <a href=\"https://en.wikipedia.org/wiki/Stack-based_memory_allocation\">https://en.wikipedia.org/wiki/Stack-based_memory_allocation</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “Resource acquisition is initialization”. <a href=\"https://en.wikipedia.org/wiki/RAII\">https://en.wikipedia.org/wiki/RAII</a> </span></p><p><span class=\"reference\">[3a] 维基百科, “RAII”. <a href=\"https://zh.wikipedia.org/zh-cn/RAII\">https://zh.wikipedia.org/zh-cn/RAII</a> </span></p><p><span class=\"reference\">[4] Wikipedia, “Call stack”. <a href=\"https://en.wikipedia.org/wiki/Call_stack\">https://en.wikipedia.org/wiki/Call_stack</a> </span></p><p><span class=\"reference\">[5] Wikipedia, “Object slicing”. <a href=\"https://en.wikipedia.org/wiki/Object_slicing\">https://en.wikipedia.org/wiki/Object_slicing</a> </span></p><p><span class=\"reference\">[6] Stack Overflow, “Why does the stack address grow towards decreasing memory addresses?” <a href=\"https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses\">https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses</a> </span></p><p><span class=\"reference\">注意：有些条目虽然有中文版，但内容太少；此处单独标出中文版条目的，则是内容比较全面、能够补充本专栏内容的情况。 </span></p>","neighbors":{"left":{"article_title":"课前必读 | 有关术语发音及环境要求","id":169198},"right":{"article_title":"02 | 自己动手，实现C++的智能指针","id":169263}}},{"article_id":169263,"article_title":"02 | 自己动手，实现C++的智能指针","article_content":"<p>你好，我是吴咏炜。</p><p>上一讲，我们描述了一个某种程度上可以当成智能指针用的类 <code>shape_wrapper</code>。使用那个智能指针，可以简化资源的管理，从根本上消除资源（包括内存）泄漏的可能性。这一讲我们就来进一步讲解，如何将 <code>shape_wrapper</code> 改造成一个完整的智能指针。你会看到，智能指针本质上并不神秘，其实就是 RAII 资源管理功能的自然展现而已。</p><p>在学完这一讲之后，你应该会对 C++ 的 <code>unique_ptr</code> 和 <code>shared_ptr</code> 的功能非常熟悉了。同时，如果你今后要创建类似的资源管理类，也不会是一件难事。</p><h2>回顾</h2><p>我们上一讲给出了下面这个类：</p><pre><code class=\"language-c++\">class shape_wrapper {\npublic:\n  explicit shape_wrapper(\n    shape* ptr = nullptr)\n    : ptr_(ptr) {}\n  ~shape_wrapper()\n  {\n    delete ptr_;\n  }\n  shape* get() const { return ptr_; }\n\nprivate:\n  shape* ptr_;\n};\n</code></pre><p>这个类可以完成智能指针的最基本的功能：对超出作用域的对象进行释放。<strong>但它缺了点东西：</strong></p><ol>\n<li>这个类只适用于 <code>shape</code> 类</li>\n<li>该类对象的行为不够像指针</li>\n<li>拷贝该类对象会引发程序行为异常</li>\n</ol><!-- [[[read_end]]] --><p>下面我们来逐一看一下怎么弥补这些问题。</p><h2>模板化和易用性</h2><p>要让这个类能够包装任意类型的指针，我们需要把它变成一个类模板。这实际上相当容易：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\npublic:\n  explicit smart_ptr(T* ptr = nullptr)\n    : ptr_(ptr) {}\n  ~smart_ptr()\n  {\n    delete ptr_;\n  }\n  T* get() const { return ptr_; }\nprivate:\n  T* ptr_;\n};\n</code></pre><p>和 <code>shape_wrapper</code> 比较一下，我们就是在开头增加模板声明 <code>template &lt;typename T&gt;</code>，然后把代码中的 <code>shape</code> 替换成模板参数 <code>T</code> 而已。这些修改非常简单自然吧？模板本质上并不是一个很复杂的概念。这个模板使用也很简单，把原来的 <code>shape_wrapper</code> 改成 <code>smart_ptr&lt;shape&gt;</code> 就行。</p><p>目前这个 <code>smart_ptr</code> 的行为还是和指针有点差异的：</p><ul>\n<li>它不能用 <code>*</code> 运算符解引用</li>\n<li>它不能用 <code>-&gt;</code> 运算符指向对象成员</li>\n<li>它不能像指针一样用在布尔表达式里</li>\n</ul><p>不过，这些问题也相当容易解决，加几个成员函数就可以：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\npublic:\n  …\n  T&amp; operator*() const { return *ptr_; }\n  T* operator-&gt;() const { return ptr_; }\n  operator bool() const { return ptr_; }\n}\n</code></pre><h2>拷贝构造和赋值</h2><p>拷贝构造和赋值，我们暂且简称为拷贝，这是个比较复杂的问题了。关键还不是实现问题，而是我们该如何定义其行为。假设有下面的代码：</p><pre><code class=\"language-c++\">smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1};\n</code></pre><p>对于第二行，究竟应当让编译时发生错误，还是可以有一个更合理的行为？我们来逐一检查一下各种可能性。</p><p>最简单的情况显然是禁止拷贝。我们可以使用下面的代码：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\n  …\n  smart_ptr(const smart_ptr&amp;)\n    = delete;\n  smart_ptr&amp; operator=(const smart_ptr&amp;)\n    = delete;\n  …\n};\n</code></pre><p>禁用这两个函数非常简单，但却解决了一种可能出错的情况。否则，<code>smart_ptr&lt;shape&gt; ptr2{ptr1};</code> 在编译时不会出错，但在运行时却会有未定义行为——由于会对同一内存释放两次，通常情况下会导致程序崩溃。</p><p>我们是不是可以考虑在拷贝智能指针时把对象拷贝一份？不行，通常人们不会这么用，因为使用智能指针的目的就是要减少对象的拷贝啊。何况，虽然我们的指针类型是 <code>shape</code>，但实际指向的却应该是 <code>circle</code> 或 <code>triangle</code> 之类的对象。在 C++ 里没有像 Java 的 <code>clone</code> 方法这样的约定；一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。</p><p>我们要么试试在拷贝时转移指针的所有权？大致实现如下：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\n  …\n  smart_ptr(smart_ptr&amp; other)\n  {\n    ptr_ = other.release();\n  }\n  smart_ptr&amp; operator=(smart_ptr&amp; rhs)\n  {\n    smart_ptr(rhs).swap(*this);\n    return *this;\n  }\n  …\n  T* release()\n  {\n    T* ptr = ptr_;\n    ptr_ = nullptr;\n    return ptr;\n  }\n  void swap(smart_ptr&amp; rhs)\n  {\n    using std::swap;\n    swap(ptr_, rhs.ptr_);\n  }\n  …\n};\n</code></pre><p>在拷贝构造函数中，通过调用 <code>other</code> 的 <code>release</code> 方法来释放它对指针的所有权。在赋值函数中，则通过拷贝构造产生一个临时对象并调用 <code>swap</code> 来交换对指针的所有权。实现上是不复杂的。</p><p>如果你学到的赋值函数还有一个类似于 <code>if (this != &amp;rhs)</code> 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。</p><p><strong>上面代码里的这种惯用法（见参考资料 <span class=\"orange\">[1]</span>）则保证了强异常安全性：</strong>赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。</p><p>如果你觉得这个实现还不错的话，那恭喜你，你达到了 C++ 委员会在 1998 年时的水平：上面给出的语义本质上就是 C++98 的 <code>auto_ptr</code> 的定义。如果你觉得这个实现很别扭的话，也恭喜你，因为 C++ 委员会也是这么觉得的：<code>auto_ptr</code> 在 C++17 时已经被正式从 C++ 标准里删除了。</p><p>上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 <code>smart_ptr</code>，你就不再拥有这个对象了……</p><h2>“移动”指针？</h2><p>在下一讲我们将完整介绍一下移动语义。这一讲，我们先简单看一下 <code>smart_ptr</code> 可以如何使用“移动”来改善其行为。</p><p>我们需要对代码做两处小修改：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\n  …\n  smart_ptr(smart_ptr&amp;&amp; other)\n  {\n    ptr_ = other.release();\n  }\n  smart_ptr&amp; operator=(smart_ptr rhs)\n  {\n    rhs.swap(*this);\n    return *this;\n  }\n  …\n};\n</code></pre><p>看到修改的地方了吗？我改了两个地方：</p><ul>\n<li>把拷贝构造函数中的参数类型 <code>smart_ptr&amp;</code> 改成了 <code>smart_ptr&amp;&amp;</code>；现在它成了移动构造函数。</li>\n<li>把赋值函数中的参数类型 <code>smart_ptr&amp;</code> 改成了 <code>smart_ptr</code>，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。</li>\n</ul><p>根据 C++ 的规则，如果我提供了移动构造函数而没有手动提供拷贝构造函数，那后者自动被禁用（记住，C++ 里那些复杂的规则也是为方便编程而设立的）。于是，我们自然地得到了以下结果：</p><pre><code class=\"language-c++\">smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1};             // 编译出错\nsmart_ptr&lt;shape&gt; ptr3;\nptr3 = ptr1;                             // 编译出错\nptr3 = std::move(ptr1);                  // OK，可以\nsmart_ptr&lt;shape&gt; ptr4{std::move(ptr3)};  // OK，可以\n</code></pre><p>这个就自然多了。</p><p>这也是 C++11 的 <code>unique_ptr</code> 的基本行为。</p><h2>子类指针向基类指针的转换</h2><p>哦，我撒了一个小谎。不知道你注意到没有，一个 <code>circle*</code> 是可以隐式转换成 <code>shape*</code> 的，但上面的 <code>smart_ptr&lt;circle&gt;</code> 却无法自动转换成 <code>smart_ptr&lt;shape&gt;</code>。这个行为显然还是不够“自然”。</p><p>不过，只需要额外加一点模板代码，就能实现这一行为。在我们目前给出的实现里，只需要增加一个构造函数即可——这也算是我们让赋值函数利用构造函数的好处了。</p><pre><code class=\"language-c++\">  template &lt;typename U&gt;\n  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)\n  {\n    ptr_ = other.release();\n  }\n</code></pre><p>这样，我们自然而然利用了指针的转换特性：现在 <code>smart_ptr&lt;circle&gt;</code> 可以移动给 <code>smart_ptr&lt;shape&gt;</code>，但不能移动给 <code>smart_ptr&lt;triangle&gt;</code>。不正确的转换会在代码编译时直接报错。</p><p>需要注意，上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 <code>= delete</code> 了（见“拷贝构造和赋值”一节）。不过，更通用的方式仍然是同时定义标准的拷贝/移动构造函数和所需的模板构造函数。下面的引用计数智能指针里我们就需要这么做。</p><p>至于非隐式的转换，因为本来就是要写特殊的转换函数的，我们留到这一讲的最后再讨论。</p><h2>引用计数</h2><p><code>unique_ptr</code> 算是一种较为安全的智能指针了。但是，一个对象只能被单个 <code>unique_ptr</code> 所拥有，这显然不能满足所有使用场合的需求。一种常见的情况是，多个智能指针同时拥有一个对象；当它们全部都失效时，这个对象也同时会被删除。这也就是 <code>shared_ptr</code> 了。</p><p><code>unique_ptr</code> 和 <code>shared_ptr</code> 的主要区别如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/07/c8/072fc41e503d22c3ab2bf6a3801903c8.png\" alt=\"\"></p><p>多个不同的 <code>shared_ptr</code> 不仅可以共享一个对象，在共享同一对象时也需要同时共享同一个计数。当最后一个指向对象（和共享计数）的 <code>shared_ptr</code> 析构时，它需要删除对象和共享计数。我们下面就来实现一下。</p><p>我们先来写出共享计数的接口：</p><pre><code class=\"language-c++\">class shared_count {\npublic:\n  shared_count();\n  void add_count();\n  long reduce_count();\n  long get_count() const;\n};\n</code></pre><p>这个 <code>shared_count</code> 类除构造函数之外有三个方法：一个增加计数，一个减少计数，一个获取计数。注意上面的接口增加计数不需要返回计数值；但减少计数时需要返回计数值，以供调用者判断是否它已经是最后一个指向共享计数的 <code>shared_ptr</code> 了。由于真正多线程安全的版本需要用到我们目前还没学到的知识，我们目前先实现一个简单化的版本：</p><pre><code class=\"language-c++\">class shared_count {\npublic:\n  shared_count() : count_(1) {}\n  void add_count()\n  {\n    ++count_;\n  }\n  long reduce_count()\n  {\n    return --count_;\n  }\n  long get_count() const\n  {\n    return count_;\n  }\n\nprivate:\n  long count_;\n};\n</code></pre><p>现在我们可以实现我们的引用计数智能指针了。首先是构造函数、析构函数和私有成员变量：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\npublic:\n  explicit smart_ptr(T* ptr = nullptr)\n    : ptr_(ptr)\n  {\n    if (ptr) {\n      shared_count_ =\n        new shared_count();\n    }\n  }\n  ~smart_ptr()\n  {\n    if (ptr_ &amp;&amp;\n      !shared_count_\n         -&gt;reduce_count()) {\n      delete ptr_;\n      delete shared_count_;\n    }\n  }\n\nprivate:\n  T* ptr_;\n  shared_count* shared_count_;\n};\n</code></pre><p>构造函数跟之前的主要不同点是会构造一个 <code>shared_count</code> 出来。析构函数在看到 <code>ptr_</code> 非空时（此时根据代码逻辑，<code>shared_count</code> 也必然非空），需要对引用数减一，并在引用数降到零时彻底删除对象和共享计数。原理就是这样，不复杂。</p><p>当然，我们还有些细节要处理。为了方便实现赋值（及其他一些惯用法），我们需要一个新的 <code>swap</code> 成员函数：</p><pre><code class=\"language-c++\">  void swap(smart_ptr&amp; rhs)\n  {\n    using std::swap;\n    swap(ptr_, rhs.ptr_);\n    swap(shared_count_,\n         rhs.shared_count_);\n  }\n</code></pre><p>赋值函数可以跟前面一样，保持不变，但拷贝构造和移动构造函数是需要更新一下的：</p><pre><code class=\"language-c++\">  smart_ptr(const smart_ptr&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(const smart_ptr&lt;U&gt;&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      shared_count_ =\n        other.shared_count_;\n      other.ptr_ = nullptr;\n    }\n  }\n</code></pre><p>除复制指针之外，对于拷贝构造的情况，我们需要在指针非空时把引用数加一，并复制共享计数的指针。对于移动构造的情况，我们不需要调整引用数，直接把 <code>other.ptr_</code> 置为空，认为 <code>other</code> 不再指向该共享对象即可。</p><p>不过，上面的代码有个问题：它不能正确编译。编译器会报错，像：</p><blockquote>\n<p>fatal error: ‘ptr_’ is a private member of ‘smart_ptr&lt;circle&gt;’</p>\n</blockquote><p>错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 <code>ptr_</code> 和 <code>shared_count_</code>。我们需要在 <code>smart_ptr</code> 的定义中显式声明：</p><pre><code class=\"language-c++\">  template &lt;typename U&gt;\n  friend class smart_ptr;\n</code></pre><p>此外，我们之前的实现（类似于单一所有权的 <code>unique_ptr</code> ）中用 <code>release</code> 来手工释放所有权。在目前的引用计数实现中，它就不太合适了，应当删除。但我们要加一个对调试非常有用的函数，返回引用计数值。定义如下：</p><pre><code class=\"language-c++\">  long use_count() const\n  {\n    if (ptr_) {\n      return shared_count_\n        -&gt;get_count();\n    } else {\n      return 0;\n    }\n  }\n</code></pre><p>这就差不多是一个比较完整的引用计数智能指针的实现了。我们可以用下面的代码来验证一下它的功能正常：</p><pre><code class=\"language-c++\">class shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {\npublic:\n  ~circle() { puts(\"~circle()\"); }\n};\n\nint main()\n{\n  smart_ptr&lt;circle&gt; ptr1(new circle());\n  printf(\"use count of ptr1 is %ld\\n\",\n         ptr1.use_count());\n  smart_ptr&lt;shape&gt; ptr2;\n  printf(\"use count of ptr2 was %ld\\n\",\n         ptr2.use_count());\n  ptr2 = ptr1;\n  printf(\"use count of ptr2 is now %ld\\n\",\n         ptr2.use_count());\n  if (ptr1) {\n    puts(\"ptr1 is not empty\");\n  }\n}\n</code></pre><p>这段代码的运行结果是：</p><blockquote>\n<p><code>use count of ptr1 is 1</code><br>\n<code>use count of ptr2 was 0</code><br>\n<code>use count of ptr2 is now 2</code><br>\n<code>ptr1 is not empty</code><br>\n<code>~circle()</code></p>\n</blockquote><p>上面我们可以看到引用计数的变化，以及最后对象被成功删除。</p><h2>指针类型转换</h2><p>对应于 C++ 里的不同的类型强制转换：</p><ul>\n<li>static_cast</li>\n<li>reinterpret_cast</li>\n<li>const_cast</li>\n<li>dynamic_cast</li>\n</ul><p>智能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。如下所示：</p><pre><code class=\"language-c++\">  template &lt;typename U&gt;\n  smart_ptr(const smart_ptr&lt;U&gt;&amp; other,\n            T* ptr)\n  {\n    ptr_ = ptr;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n</code></pre><p>这样我们就可以实现转换所需的函数模板了。下面实现一个 <code>dynamic_pointer_cast</code> 来示例一下：</p><pre><code class=\"language-c++\">template &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; dynamic_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other)\n{\n  T* ptr =\n    dynamic_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n</code></pre><p>在前面的验证代码后面我们可以加上：</p><pre><code class=\"language-c++\">  smart_ptr&lt;circle&gt; ptr3 =\n    dynamic_pointer_cast&lt;circle&gt;(ptr2);\n  printf(\"use count of ptr3 is %ld\\n\",\n         ptr3.use_count());\n</code></pre><p>编译会正常通过，同时能在输出里看到下面的结果：</p><blockquote>\n<p>use count of ptr3 is 3</p>\n</blockquote><p>最后，对象仍然能够被正确删除。这说明我们的实现是正确的。</p><h2>代码列表</h2><p>为了方便你参考，下面我给出了一个完整的 <code>smart_ptr</code> 代码列表：</p><pre><code class=\"language-c++\">#include &lt;utility&gt;  // std::swap\n\nclass shared_count {\npublic:\n  shared_count() noexcept\n    : count_(1) {}\n  void add_count() noexcept\n  {\n    ++count_;\n  }\n  long reduce_count() noexcept\n  {\n    return --count_;\n  }\n  long get_count() const noexcept\n  {\n    return count_;\n  }\n\nprivate:\n  long count_;\n};\n\ntemplate &lt;typename T&gt;\nclass smart_ptr {\npublic:\n  template &lt;typename U&gt;\n  friend class smart_ptr;\n\n  explicit smart_ptr(T* ptr = nullptr)\n    : ptr_(ptr)\n  {\n    if (ptr) {\n      shared_count_ =\n        new shared_count();\n    }\n  }\n  ~smart_ptr()\n  {\n    if (ptr_ &amp;&amp;\n      !shared_count_\n         -&gt;reduce_count()) {\n      delete ptr_;\n      delete shared_count_;\n    }\n  }\n\n  smart_ptr(const smart_ptr&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      other.shared_count_-&gt;add_count();\n      shared_count_ = other.shared_count_;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      shared_count_ =\n        other.shared_count_;\n      other.ptr_ = nullptr;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(const smart_ptr&lt;U&gt;&amp; other,\n            T* ptr) noexcept\n  {\n    ptr_ = ptr;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n  smart_ptr&amp;\n  operator=(smart_ptr rhs) noexcept\n  {\n    rhs.swap(*this);\n    return *this;\n  }\n\n  T* get() const noexcept\n  {\n    return ptr_;\n  }\n  long use_count() const noexcept\n  {\n    if (ptr_) {\n      return shared_count_\n        -&gt;get_count();\n    } else {\n      return 0;\n    }\n  }\n  void swap(smart_ptr&amp; rhs) noexcept\n  {\n    using std::swap;\n    swap(ptr_, rhs.ptr_);\n    swap(shared_count_,\n         rhs.shared_count_);\n  }\n\n  T&amp; operator*() const noexcept\n  {\n    return *ptr_;\n  }\n  T* operator-&gt;() const noexcept\n  {\n    return ptr_;\n  }\n  operator bool() const noexcept\n  {\n    return ptr_;\n  }\n\nprivate:\n  T* ptr_;\n  shared_count* shared_count_;\n};\n\ntemplate &lt;typename T&gt;\nvoid swap(smart_ptr&lt;T&gt;&amp; lhs,\n          smart_ptr&lt;T&gt;&amp; rhs) noexcept\n{\n  lhs.swap(rhs);\n}\n\ntemplate &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; static_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  T* ptr = static_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n\ntemplate &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; reinterpret_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  T* ptr = reinterpret_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n\ntemplate &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; const_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  T* ptr = const_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n\ntemplate &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; dynamic_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  T* ptr = dynamic_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n</code></pre><p>如果你足够细心的话，你会发现我在代码里加了不少 <code>noexcept</code>。这对这个智能指针在它的目标场景能正确使用是十分必要的。我们会在下面的几讲里回到这个话题。</p><h2>内容小结</h2><p>这一讲我们从 <code>shape_wrapper</code> 出发，实现了一个基本完整的带引用计数的智能指针。这个智能指针跟标准的 <code>shared_ptr</code> 比，还缺了一些东西（见参考资料 <span class=\"orange\">[2]</span>），但日常用到的智能指针功能已经包含在内。现在，你应当已经对智能指针有一个较为深入的理解了。</p><h2>课后思考</h2><p>这里留几个问题，你可以思考一下：</p><ol>\n<li>不查阅 <code>shared_ptr</code> 的文档，你觉得目前 <code>smart_ptr</code> 应当添加什么功能吗？</li>\n<li>你想到的功能在标准的 <code>shared_ptr</code> 里吗？</li>\n<li>你觉得智能指针应该满足什么样的线程安全性？</li>\n</ol><p>欢迎留言和我交流你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Stack Overflow, GManNickG’s answer to “What is the copy-and-swap idiom?”. <a href=\"https://stackoverflow.com/a/3279550/816999\">https://stackoverflow.com/a/3279550/816999</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “std::shared_ptr”. <a href=\"https://en.cppreference.com/w/cpp/memory/shared_ptr\">https://en.cppreference.com/w/cpp/memory/shared_ptr</a> </span></p>","neighbors":{"left":{"article_title":"01 | 堆、栈、RAII：C++里该如何管理资源？","id":169225},"right":{"article_title":"03 | 右值和移动究竟解决了什么问题？","id":169268}}},{"article_id":169268,"article_title":"03 | 右值和移动究竟解决了什么问题？","article_content":"<p>你好，我是吴咏炜。</p><p>从上一讲智能指针开始，我们已经或多或少接触了移动语义。本讲我们就完整地讨论一下移动语义和相关的概念。移动语义是 C++11 里引入的一个重要概念；理解这个概念，是理解很多现代 C++ 里的优化的基础。</p><h2>值分左右</h2><p>我们常常会说，C++ 里有左值和右值。这话不完全对。标准里的定义实际更复杂，规定了下面这些值类别（value categories）：</p><p><img src=\"https://static001.geekbang.org/resource/image/18/3c/18b692072537d4ce179d3857a8a0133c.png?wh=720*576\" alt=\"\"></p><p>我们先理解一下这些名词的字面含义：</p><ul>\n<li>一个 lvalue 是通常可以放在等号左边的表达式，左值</li>\n<li>一个 rvalue 是通常只能放在等号右边的表达式，右值</li>\n<li>一个 glvalue 是 generalized lvalue，广义左值</li>\n<li>一个 xvalue 是 expiring value，将亡值</li>\n<li>一个 prvalue 是 pure rvalue，纯右值</li>\n</ul><p>还是有点晕，是吧？我们暂且抛开这些概念，只看其中两个：lvalue 和 prvalue。</p><p>左值 lvalue 是有标识符、可以取地址的表达式，最常见的情况有：</p><ul>\n<li>变量、函数或数据成员的名字</li>\n<li>返回左值引用的表达式，如 <code>++x</code>、<code>x = 1</code>、<code>cout &lt;&lt; ' '</code></li>\n<li>字符串字面量如 <code>\"hello world\"</code></li>\n</ul><p>在函数调用时，左值可以绑定到左值引用的参数，如 <code>T&amp;</code>。一个常量只能绑定到常左值引用，如 <code>const T&amp;</code>。</p><!-- [[[read_end]]] --><p>反之，纯右值 prvalue 是没有标识符、不可以取地址的表达式，一般也称之为“临时对象”。最常见的情况有：</p><ul>\n<li>返回非引用类型的表达式，如 <code>x++</code>、<code>x + 1</code>、<code>make_shared&lt;int&gt;(42)</code></li>\n<li>除字符串字面量之外的字面量，如 <code>42</code>、<code>true</code></li>\n</ul><p>在 C++11 之前，右值可以绑定到常左值引用（const lvalue reference）的参数，如 <code>const T&amp;</code>，但不可以绑定到非常左值引用（non-const lvalue reference），如 <code>T&amp;</code>。从 C++11 开始，C++ 语言里多了一种引用类型——右值引用。右值引用的形式是 <code>T&amp;&amp;</code>，比左值引用多一个 <code>&amp;</code> 符号。跟左值引用一样，我们可以使用 <code>const</code> 和 <code>volatile</code> 来进行修饰，但最常见的情况是，我们不会用 <code>const</code> 和 <code>volatile</code> 来修饰右值。本专栏就属于这种情况。</p><p>引入一种额外的引用类型当然增加了语言的复杂性，但也带来了很多优化的可能性。由于 C++ 有重载，我们就可以根据不同的引用类型，来选择不同的重载函数，来完成不同的行为。回想一下，在上一讲中，我们就利用了重载，让 <code>smart_ptr</code> 的构造函数可以有不同的行为：</p><pre><code class=\"language-c++\">template &lt;typename U&gt;\nsmart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  ptr_ = other.ptr_;\n  if (ptr_) {\n    other.shared_count_-&gt;add_count();\n    shared_count_ =\n      other.shared_count_;\n  }\n}\ntemplate &lt;typename U&gt;\nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\n{\n  ptr_ = other.ptr_;\n  if (ptr_) {\n    shared_count_ =\n      other.shared_count_;\n    other.ptr_ = nullptr;\n  }\n}\n</code></pre><p>你可能会好奇，使用右值引用的第二个重载函数中的变量 <code>other</code> 算是左值还是右值呢？根据定义，<code>other</code> 是个变量的名字，变量有标识符、有地址，所以它还是一个左值——虽然它的类型是右值引用。</p><p>尤其重要的是，拿这个 <code>other</code> 去调用函数时，它匹配的也会是左值引用。也就是说，<strong>类型是右值引用的变量是一个左值！</strong>这点可能有点反直觉，但跟 C++ 的其他方面是一致的。毕竟对于一个右值引用的变量，你是可以取地址的，这点上它和左值完全一致。稍后我们再回到这个话题上来。</p><p>再看一下下面的代码：</p><pre><code class=\"language-c++\">smart_ptr&lt;shape&gt; ptr1{new circle()};\nsmart_ptr&lt;shape&gt; ptr2 = std::move(ptr1);\n</code></pre><p>第一个表达式里的 <code>new circle()</code> 就是一个纯右值；但对于指针，我们通常使用值传递，并不关心它是左值还是右值。</p><p>第二个表达式里的 <code>std::move(ptr)</code> 就有趣点了。它的作用是把一个左值引用强制转换成一个右值引用，而并不改变其内容。从实用的角度，在我们这儿 <code>std::move(ptr1)</code> 等价于 <code>static_cast&lt;smart_ptr&lt;shape&gt;&amp;&amp;&gt;(ptr1)</code>。因此，<code>std::move(ptr1)</code> 的结果是指向 <code>ptr1</code> 的一个右值引用，这样构造 <code>ptr2</code> 时就会选择上面第二个重载。</p><p>我们可以把 <code>std::move(ptr1)</code> 看作是一个有名字的右值。为了跟无名的纯右值 prvalue 相区别，C++ 里目前就把这种表达式叫做 xvalue。跟左值 lvalue 不同，xvalue 仍然是不能取地址的——这点上，xvalue 和 prvalue 相同。所以，xvalue 和 prvalue 都被归为右值 rvalue。我们用下面的图来表示会更清楚一点：</p><p><img src=\"https://static001.geekbang.org/resource/image/03/5a/036cc6865a9623a48918b504e408945a.png?wh=768*830\" alt=\"\"></p><p>另外请注意，“值类别”（value category）和“值类型”（value type）是两个看似相似、却毫不相干的术语。前者指的是上面这些左值、右值相关的概念，后者则是与引用类型（reference type）相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。在 C++ 里，所有的原生类型、枚举、结构、联合、类都代表值类型，只有引用（<code>&amp;</code>）和指针（<code>*</code>）才是引用类型。在 Java 里，数字等原生类型是值类型，类则属于引用类型。在 Python 里，一切类型都是引用类型。</p><h2>生命周期和表达式类型</h2><p>一个变量的生命周期在超出作用域时结束。如果一个变量代表一个对象，当然这个对象的生命周期也在那时结束。那临时对象（prvalue）呢？在这儿，C++ 的规则是：一个临时对象会在包含这个临时对象的完整表达式估值完成后、按生成顺序的逆序被销毁，除非有生命周期延长发生。我们先看一个没有生命周期延长的基本情况：</p><pre><code class=\"language-c++\">process_shape(circle(), triangle());\n</code></pre><p>在这儿，我们生成了临时对象，一个圆和一个三角形，它们会在 <code>process_shape</code> 执行完成并生成结果对象后被销毁。</p><p>我们插入一些实际的代码，就可以演示这一行为：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n\nclass shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {\npublic:\n  circle() { puts(\"circle()\"); }\n  ~circle() { puts(\"~circle()\"); }\n};\n\nclass triangle : public shape {\npublic:\n  triangle() { puts(\"triangle()\"); }\n  ~triangle() { puts(\"~triangle()\"); }\n};\n\nclass result {\npublic:\n  result() { puts(\"result()\"); }\n  ~result() { puts(\"~result()\"); }\n};\n\nresult\nprocess_shape(const shape&amp; shape1,\n              const shape&amp; shape2)\n{\n  puts(\"process_shape()\");\n  return result();\n}\n\nint main()\n{\n  puts(\"main()\");\n  process_shape(circle(), triangle());\n  puts(\"something else\");\n}\n</code></pre><p>输出结果可能会是（<code>circle</code> 和 <code>triangle</code> 的顺序在标准中没有规定）：</p><blockquote>\n<p><code>main()</code><br>\n<code>circle()</code><br>\n<code>triangle()</code><br>\n<code>process_shape()</code><br>\n<code>result()</code><br>\n<code>~result()</code><br>\n<code>~triangle()</code><br>\n<code>~circle()</code><br>\n<code>something else</code></p>\n</blockquote><p>目前我让 <code>process_shape</code> 也返回了一个结果，这是为了下一步演示的需要。你可以看到结果的临时对象最后生成、最先析构。</p><p>为了方便对临时对象的使用，C++ 对临时对象有特殊的生命周期延长规则。这条规则是：</p><blockquote>\n<p>如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长。</p>\n</blockquote><p>我们对上面的代码只要改一行就能演示这个效果。把 <code>process_shape</code> 那行改成：</p><pre><code class=\"language-c++\">result&amp;&amp; r = process_shape(\n  circle(), triangle());\n</code></pre><p>我们就能看到不同的结果了：</p><blockquote>\n<p><code>main()</code><br>\n<code>circle()</code><br>\n<code>triangle()</code><br>\n<code>process_shape()</code><br>\n<code>result()</code><br>\n<code>~triangle()</code><br>\n<code>~circle()</code><br>\n<code>something else</code><br>\n<code>~result()</code></p>\n</blockquote><p>现在 <code>result</code> 的生成还在原来的位置，但析构被延到了 <code>main</code> 的最后。</p><p>需要万分注意的是，这条生命期延长规则只对 prvalue 有效，而对 xvalue 无效。如果由于某种原因，prvalue 在绑定到引用以前已经变成了 xvalue，那生命期就不会延长。不注意这点的话，代码就可能会产生隐秘的 bug。比如，我们如果这样改一下代码，结果就不对了：</p><pre><code class=\"language-c++\">#include &lt;utility&gt;  // std::move\n…\nresult&amp;&amp; r = std::move(process_shape(\n  circle(), triangle()));\n</code></pre><p>这时的代码输出就回到了前一种情况。虽然执行到 something else 那儿我们仍然有一个有效的变量 <code>r</code>，但它指向的对象已经不存在了，对 <code>r</code> 的解引用是一个未定义行为。由于 <code>r</code> 指向的是栈空间，通常不会立即导致程序崩溃，而会在某些复杂的组合条件下才会引致问题……</p><p>对 C++ 的这条生命期延长规则，在后面讲到视图（view）的时候会十分有用。那时我们会看到，有些 C++ 的用法实际上会隐式地利用这条规则。</p><p>此外，参考资料 <span class=\"orange\">[5]</span> 中提到了一个有趣的事实：你可以把一个没有虚析构函数的子类对象绑定到基类的引用变量上，这个子类对象的析构仍然是完全正常的——这是因为这条规则只是延后了临时对象的析构而已，不是利用引用计数等复杂的方法，因而只要引用绑定成功，其类型并没有什么影响。</p><h2>移动的意义</h2><p>上面我们谈了一些语法知识。就跟学外语的语法一样，这些内容是比较枯燥的。虽然这些知识有时有用，但往往要回过头来看的时候才觉得。初学之时，更重要的是理解为什么，和熟练掌握基本的用法。</p><p>对于 <code>smart_ptr</code>，我们使用右值引用的目的是实现移动，而实现移动的意义是减少运行的开销——在引用计数指针的场景下，这个开销并不大。移动构造和拷贝构造的差异仅在于：</p><ul>\n<li>少了一次 <code>other.shared_count_-&gt;add_count()</code> 的调用</li>\n<li>被移动的指针被清空，因而析构时也少了一次 <code>shared_count_-&gt;reduce_count()</code> 的调用</li>\n</ul><p>在使用容器类的情况下，移动更有意义。我们可以尝试分析一下下面这个假想的语句（假设 <code>name</code> 是 <code>string</code> 类型）：</p><pre><code class=\"language-c++\">string result =\n  string(\"Hello, \") + name + \".\";\n</code></pre><p>在 C++11 之前的年代里，这种写法是绝对不推荐的。因为它会引入很多额外开销，执行流程大致如下：</p><ol>\n<li>调用构造函数 <code>string(const char*)</code>，生成临时对象 1；<code>\"Hello, \"</code> 复制 1 次。</li>\n<li>调用 <code>operator+(const string&amp;, const string&amp;)</code>，生成临时对象 2；<code>\"Hello, \"</code> 复制 2 次，<code>name</code> 复制 1 次。</li>\n<li>调用 <code>operator+(const string&amp;, const char*)</code>，生成对象 3；<code>\"Hello, \"</code> 复制 3 次，<code>name</code> 复制 2 次，<code>\".\"</code> 复制 1 次。</li>\n<li>假设返回值优化能够生效（最佳情况），对象 3 可以直接在 <code>result</code> 里构造完成。</li>\n<li>临时对象 2 析构，释放指向 <code>string(\"Hello, \") + name</code> 的内存。</li>\n<li>临时对象 1 析构，释放指向 <code>string(\"Hello, \")</code> 的内存。</li>\n</ol><p>既然 C++ 是一门追求性能的语言，一个合格的 C++ 程序员会写：</p><pre><code class=\"language-c++\">string result = \"Hello, \";\nresult += name;\nresult += \".\";\n</code></pre><p>这样的话，只会调用构造函数一次和 <code>string::operator+=</code> 两次，没有任何临时对象需要生成和析构，所有的字符串都只复制了一次。但显然代码就啰嗦多了——尤其如果拼接的步骤比较多的话。从 C++11 开始，这不再是必须的。同样上面那个单行的语句，执行流程大致如下：</p><ol>\n<li>调用构造函数 <code>string(const char*)</code>，生成临时对象 1；<code>\"Hello, \"</code> 复制 1 次。</li>\n<li>调用 <code>operator+(string&amp;&amp;, const string&amp;)</code>，直接在临时对象 1 上面执行追加操作，并把结果移动到临时对象 2；<code>name</code> 复制 1 次。</li>\n<li>调用 <code>operator+(string&amp;&amp;, const char*)</code>，直接在临时对象 2 上面执行追加操作，并把结果移动到 <code>result</code>；<code>\".\"</code> 复制 1 次。</li>\n<li>临时对象 2 析构，内容已经为空，不需要释放任何内存。</li>\n<li>临时对象 1 析构，内容已经为空，不需要释放任何内存。</li>\n</ol><p>性能上，所有的字符串只复制了一次；虽然比啰嗦的写法仍然要增加临时对象的构造和析构，但由于这些操作不牵涉到额外的内存分配和释放，是相当廉价的。程序员只需要牺牲一点点性能，就可以大大增加代码的可读性。而且，所谓的性能牺牲，也只是相对于优化得很好的 C 或 C++ 代码而言——这样的 C++ 代码的性能仍然完全可以超越 Python 类的语言的相应代码。</p><p>此外很关键的一点是，C++ 里的对象缺省都是值语义。在下面这样的代码里：</p><pre><code class=\"language-c++\">class A {\n  B b_;\n  C c_;\n};\n</code></pre><p>从实际内存布局的角度，很多语言——如 Java 和 Python——会在 <code>A</code> 对象里放 <code>B</code> 和 <code>C</code> 的指针（虽然这些语言里本身没有指针的概念）。而 C++ 则会直接把 <code>B</code> 和 <code>C</code> 对象放在 <code>A</code> 的内存空间里。这种行为既是优点也是缺点。说它是优点，是因为它保证了内存访问的局域性，而局域性在现代处理器架构上是绝对具有性能优势的。说它是缺点，是因为复制对象的开销大大增加：在 Java 类语言里复制的是指针，在 C++ 里是完整的对象。这就是为什么 C++ 需要移动语义这一优化，而 Java 类语言里则根本不需要这个概念。</p><p>一句话总结，移动语义使得在 C++ 里返回大对象（如容器）的函数和运算符成为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率。</p><p>所有的现代 C++ 的标准容器都针对移动进行了优化。</p><h2>如何实现移动？</h2><p>要让你设计的对象支持移动的话，通常需要下面几步：</p><ul>\n<li>你的对象应该有分开的拷贝构造和移动构造函数（除非你只打算支持移动，不支持拷贝——如 <code>unique_ptr</code>）。</li>\n<li>你的对象应该有 <code>swap</code> 成员函数，支持和另外一个对象快速交换成员。</li>\n<li>在你的对象的名空间下，应当有一个全局的 <code>swap</code> 函数，调用成员函数 <code>swap</code> 来实现交换。支持这种用法会方便别人（包括你自己在将来）在其他对象里包含你的对象，并快速实现它们的 <code>swap</code> 函数。</li>\n<li>实现通用的 <code>operator=</code>。</li>\n<li>上面各个函数如果不抛异常的话，应当标为 <code>noexcept</code>。这对移动构造函数尤为重要。</li>\n</ul><p>具体写法可以参考我们当前已经实现的 <code>smart_ptr</code>：</p><ul>\n<li><code>smart_ptr</code> 有拷贝构造和移动构造函数（虽然此处我们的模板构造函数严格来说不算拷贝或移动构造函数）。移动构造函数应当从另一个对象获取资源，清空其资源，并将其置为一个可析构的状态。</li>\n</ul><pre><code class=\"language-c++\">smart_ptr(const smart_ptr&amp; other) noexcept\n{\n  ptr_ = other.ptr_;\n  if (ptr_) {\n    other.shared_count_\n      -&gt;add_count();\n    shared_count_ =\n      other.shared_count_;\n  }\n}\ntemplate &lt;typename U&gt;\nsmart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  ptr_ = other.ptr_;\n  if (ptr_) {\n    other.shared_count_\n      -&gt;add_count();\n    shared_count_ =\n      other.shared_count_;\n  }\n}\ntemplate &lt;typename U&gt;\nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\n{\n  ptr_ = other.ptr_;\n  if (ptr_) {\n    shared_count_ =\n      other.shared_count_;\n    other.ptr_ = nullptr;\n  }\n}\n</code></pre><ul>\n<li><code>smart_ptr</code> 有 <code>swap</code> 成员函数。</li>\n</ul><pre><code class=\"language-c++\">void swap(smart_ptr&amp; rhs) noexcept\n{\n  using std::swap;\n  swap(ptr_, rhs.ptr_);\n  swap(shared_count_,\n       rhs.shared_count_);\n}\n</code></pre><ul>\n<li>有支持 <code>smart_ptr</code> 的全局 <code>swap</code> 函数。</li>\n</ul><pre><code class=\"language-c++\">template &lt;typename T&gt;\nvoid swap(smart_ptr&lt;T&gt;&amp; lhs,\n          smart_ptr&lt;T&gt;&amp; rhs) noexcept\n{\n  lhs.swap(rhs);\n}\n</code></pre><ul>\n<li><code>smart_ptr</code> 有通用的 <code>operator=</code> 成员函数。注意为了避免让人吃惊，通常我们需要将其实现成对 <code>a = a;</code> 这样的写法安全。下面的写法算是个小技巧，对传递左值和右值都有效，而且规避了 <code>if (&amp;rhs != this)</code> 这样的判断。</li>\n</ul><pre><code class=\"language-c++\">  smart_ptr&amp;\n  operator=(smart_ptr rhs) noexcept\n  {\n    rhs.swap(*this);\n    return *this;\n  }\n</code></pre><h2>不要返回本地变量的引用</h2><p>有一种常见的 C++ 编程错误，是在函数里返回一个本地对象的引用。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。理论上来说，程序出任何奇怪的行为都是正常的。</p><p>在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用 <code>std::move</code> 进行干预——使用 <code>std::move</code> 对于移动行为没有帮助，反而会影响返回值优化。</p><p>下面是个例子：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;  // std::cout/endl\n#include &lt;utility&gt;   // std::move\n\nusing namespace std;\n\nclass Obj {\npublic:\n  Obj()\n  {\n    cout &lt;&lt; \"Obj()\" &lt;&lt; endl;\n  }\n  Obj(const Obj&amp;)\n  {\n    cout &lt;&lt; \"Obj(const Obj&amp;)\"\n       &lt;&lt; endl;\n  }\n  Obj(Obj&amp;&amp;)\n  {\n    cout &lt;&lt; \"Obj(Obj&amp;&amp;)\" &lt;&lt; endl;\n  }\n};\n\nObj simple()\n{\n  Obj obj;\n  // 简单返回对象；一般有 NRVO\n  return obj;\n}\n\nObj simple_with_move()\n{\n  Obj obj;\n  // move 会禁止 NRVO\n  return std::move(obj);\n}\n\nObj complicated(int n)\n{\n  Obj obj1;\n  Obj obj2;\n  // 有分支，一般无 NRVO\n  if (n % 2 == 0) {\n    return obj1;\n  } else {\n    return obj2;\n  }\n}\n\nint main()\n{\n  cout &lt;&lt; \"*** 1 ***\" &lt;&lt; endl;\n  auto obj1 = simple();\n  cout &lt;&lt; \"*** 2 ***\" &lt;&lt; endl;\n  auto obj2 = simple_with_move();\n  cout &lt;&lt; \"*** 3 ***\" &lt;&lt; endl;\n  auto obj3 = complicated(42);\n}\n</code></pre><p>输出通常为：</p><blockquote>\n<p><code>*** 1 ***</code><br>\n<code>Obj()</code><br>\n<code>*** 2 ***</code><br>\n<code>Obj()</code><br>\n<code>Obj(Obj&amp;&amp;)</code><br>\n<code>*** 3 ***</code><br>\n<code>Obj()</code><br>\n<code>Obj()</code><br>\n<code>Obj(Obj&amp;&amp;)</code></p>\n</blockquote><p>也就是，用了 <code>std::move</code> 反而妨碍了返回值优化。</p><h2>引用坍缩和完美转发</h2><p>最后讲一个略复杂、但又不得不讲的话题，引用坍缩（又称“引用折叠”）。这个概念在泛型编程中是一定会碰到的。我们今天既然讲了左值和右值引用，也需要一起讲一下。</p><p>我们已经讲了对于一个实际的类型 <code>T</code>，它的左值引用是 <code>T&amp;</code>，右值引用是 <code>T&amp;&amp;</code>。那么：</p><ol>\n<li>是不是看到 <code>T&amp;</code>，就一定是个左值引用？</li>\n<li>是不是看到 <code>T&amp;&amp;</code>，就一定是个右值引用？</li>\n</ol><p>对于前者的回答是“是”，对于后者的回答为“否”。</p><p>关键在于，在有模板的代码里，对于类型参数的推导结果可能是引用。我们可以略过一些繁复的语法规则，要点是：</p><ul>\n<li>对于 <code>template &lt;typename T&gt; foo(T&amp;&amp;)</code> 这样的代码，如果传递过去的参数是左值，<code>T</code> 的推导结果是左值引用；如果传递过去的参数是右值，<code>T</code> 的推导结果是参数的类型本身。</li>\n<li>如果 <code>T</code> 是左值引用，那 <code>T&amp;&amp;</code> 的结果仍然是左值引用——即 <code>type&amp; &amp;&amp;</code> 坍缩成了 <code>type&amp;</code>。</li>\n<li>如果 <code>T</code> 是一个实际类型，那 <code>T&amp;&amp;</code> 的结果自然就是一个右值引用。</li>\n</ul><p>我们之前提到过，右值引用变量仍然会匹配到左值引用上去。下面的代码会验证这一行为：</p><pre><code class=\"language-c++\">void foo(const shape&amp;)\n{\n  puts(\"foo(const shape&amp;)\");\n}\n\nvoid foo(shape&amp;&amp;)\n{\n  puts(\"foo(shape&amp;&amp;)\");\n}\n\nvoid bar(const shape&amp; s)\n{\n  puts(\"bar(const shape&amp;)\");\n  foo(s);\n}\n\nvoid bar(shape&amp;&amp; s)\n{\n  puts(\"bar(shape&amp;&amp;)\");\n  foo(s);\n}\n\nint main()\n{\n  bar(circle());\n}\n</code></pre><p>输出为：</p><blockquote>\n<p><code>bar(shape&amp;&amp;)</code><br>\n<code>foo(const shape&amp;)</code></p>\n</blockquote><p>如果我们要让 <code>bar</code> 调用右值引用的那个 foo 的重载，我们必须写成：</p><pre><code class=\"language-c++\">foo(std::move(s));\n</code></pre><p>或：</p><pre><code class=\"language-c++\">foo(static_cast&lt;shape&amp;&amp;&gt;(s));\n</code></pre><p>可如果两个 <code>bar</code> 的重载除了调用 <code>foo</code> 的方式不一样，其他都差不多的话，我们为什么要提供两个不同的 <code>bar</code> 呢？</p><p>事实上，很多标准库里的函数，连目标的参数类型都不知道，但我们仍然需要能够保持参数的值类别：左值的仍然是左值，右值的仍然是右值。这个功能在 C++ 标准库中已经提供了，叫 <code>std::forward</code>。它和 <code>std::move</code> 一样都是利用引用坍缩机制来实现。此处，我们不介绍其实现细节，而是重点展示其用法。我们可以把我们的两个 <code>bar</code> 函数简化成：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nvoid bar(T&amp;&amp; s)\n{\n  foo(std::forward&lt;T&gt;(s));\n}\n</code></pre><p>对于下面这样的代码：</p><pre><code class=\"language-c++\">circle temp;\nbar(temp);\nbar(circle());\n</code></pre><p>现在的输出是：</p><blockquote>\n<p><code>foo(const shape&amp;)</code><br>\n<code>foo(shape&amp;&amp;)</code></p>\n</blockquote><p>一切如预期一样。</p><p>因为在 <code>T</code> 是模板参数时，<code>T&amp;&amp;</code> 的作用主要是保持值类别进行转发，它有个名字就叫“转发引用”（forwarding reference）。因为既可以是左值引用，也可以是右值引用，它也曾经被叫做“万能引用”（universal reference）。</p><h2>内容小结</h2><p>本讲介绍了 C++ 里的值类别，重点介绍了临时变量、右值引用、移动语义和实际的编程用法。由于这是 C++11 里的重点功能，你对于其基本用法需要牢牢掌握。</p><h2>课后思考</h2><p>留给你两道思考题：</p><ol>\n<li>请查看一下标准函数模板 <code>make_shared</code> 的声明，然后想一想，这个函数应该是怎样实现的。</li>\n<li>为什么 <code>smart_ptr::operator=</code> 对左值和右值都有效，而且不需要对等号两边是否引用同一对象进行判断？</li>\n</ol><p>欢迎留言和我交流你的看法，尤其是对第二个问题。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Value categories”. <a href=\"https://en.cppreference.com/w/cpp/language/value_category\">https://en.cppreference.com/w/cpp/language/value_category</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “值类别”. <a href=\"https://zh.cppreference.com/w/cpp/language/value_category\">https://zh.cppreference.com/w/cpp/language/value_category</a> </span></p><p><span class=\"reference\">[2] Anders Schau Knatten, “lvalues, rvalues, glvalues, prvalues, xvalues, help!”. <a href=\"https://blog.knatten.org/2018/03/09/lvalues-rvalues-glvalues-prvalues-xvalues-help/\">https://blog.knatten.org/2018/03/09/lvalues-rvalues-glvalues-prvalues-xvalues-help/</a> </span></p><p><span class=\"reference\">[3] Jeaye, “Value category cheat-sheet”. <a href=\"https://blog.jeaye.com/2017/03/19/xvalues/\">https://blog.jeaye.com/2017/03/19/xvalues/</a> </span></p><p><span class=\"reference\">[4] Thomas Becker, “C++ rvalue references explained”. <a href=\"http://thbecker.net/articles/rvalue_references/section_01.html\">http://thbecker.net/articles/rvalue_references/section_01.html</a> </span></p><p><span class=\"reference\">[5] Herb Sutter, “GotW #88: A candidate for the ‘most important const’”. <a href=\"https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\">https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/</a> </span></p>","neighbors":{"left":{"article_title":"02 | 自己动手，实现C++的智能指针","id":169263},"right":{"article_title":"04 | 容器汇编 I：比较简单的若干容器","id":173167}}},{"article_id":173167,"article_title":"04 | 容器汇编 I：比较简单的若干容器","article_content":"<p>你好，我是吴咏炜。</p><p>上几讲我们学习了 C++ 的资源管理和值类别。今天我们换一个话题，来看一下 C++ 里的容器。</p><p>关于容器，已经存在不少的学习资料了。在 cppreference 上有很完备的参考资料（<span class=\"orange\">[1]</span>）。今天我们采取一种非正规的讲解方式，尽量不重复已有的参考资料，而是让你加深对于重要容器的理解。</p><p>对于容器，学习上的一个麻烦点是你无法直接输出容器的内容——如果你定义了一个 <code>vector&lt;int&gt; v</code>，你是没法简单输出 <code>v</code> 的内容的。有人也许会说用 <code>copy(v.begin(), v.end(), ostream_iterator(…))</code>，可那既啰嗦，又对像 <code>map</code> 或 <code>vector&lt;vector&lt;…&gt;&gt;</code> 这样的复杂类型无效。因此，我们需要一个更好用的工具。在此，我向你大力推荐 xeus-cling <span class=\"orange\">[2]</span>。它的便利性无与伦比——你可以直接在浏览器里以交互的方式运行代码，不需要本机安装任何编译器（点击“Trying it online”下面的 binder 链接）。下面是在线运行的一个截图：</p><p><img src=\"https://static001.geekbang.org/resource/image/71/ca/7199bb5b1394fe1aa9f91b850c309eca.png?wh=1064*771\" alt=\"\"></p><p>xeus-cling 也可以在本地安装。对于使用 Linux 的同学，安装应当是相当便捷的。有兴趣的话，使用其他平台的同学也可以尝试一下。</p><p>如果你既没有本地运行的条件，也不方便远程使用互联网来运行代码，我个人还为本专栏写了一个小小的工具 <span class=\"orange\">[3]</span>。在你的代码中包含这个头文件，也可以方便地得到类似于上面的输出。示例代码如下所示：</p><!-- [[[read_end]]] --><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include \"output_container.h\"\n\nusing namespace std;\n\nint main()\n{\n  map&lt;int, int&gt; mp{\n    {1, 1}, {2, 4}, {3, 9}};\n  cout &lt;&lt; mp &lt;&lt; endl;\n  vector&lt;vector&lt;int&gt;&gt; vv{\n    {1, 1}, {2, 4}, {3, 9}};\n  cout &lt;&lt; vv &lt;&lt; endl;\n}\n</code></pre><p>我们会得到下面的输出：</p><blockquote>\n<p><code>{ 1 =&gt; 1, 2 =&gt; 4, 3 =&gt; 9 }</code><br>\n<code>{ { 1, 1 }, { 2, 4 }, { 3, 9 } }</code></p>\n</blockquote><p>这个代码中用到了很多我们目前专栏还没有讲的知识，所以你暂且不用关心它的实现原理。如果你能看得懂这个代码，那就太棒了。如果你看不懂，唔，不急，慢慢来，你会明白的。</p><p>工具在手，天下我有。下面我们正式开讲容器篇。</p><h2>string</h2><p><code>string</code> 一般并不被认为是一个 C++ 的容器。但鉴于其和容器有很多共同点，我们先拿 <code>string</code> 类来开说。</p><p><code>string</code> 是模板 <code>basic_string</code> 对于 <code>char</code> 类型的特化，可以认为是一个只存放字符 <code>char</code> 类型数据的容器。“真正”的容器类与 <code>string</code> 的最大不同点是里面可以存放任意类型的对象。</p><p>跟其他大部分容器一样， <code>string</code> 具有下列成员函数：</p><ul>\n<li><code>begin</code> 可以得到对象起始点</li>\n<li><code>end</code> 可以得到对象的结束点</li>\n<li><code>empty</code> 可以得到容器是否为空</li>\n<li><code>size</code> 可以得到容器的大小</li>\n<li><code>swap</code> 可以和另外一个容器交换其内容</li>\n</ul><p>（对于不那么熟悉容器的人，需要知道 C++ 的 <code>begin</code> 和 <code>end</code> 是半开半闭区间：在容器非空时，<code>begin</code> 指向第一个元素，而 <code>end</code> 指向最后一个元素后面的位置；在容器为空时，<code>begin</code> 等于 <code>end</code>。在 <code>string</code> 的情况下，由于考虑到和 C 字符串的兼容，<code>end</code> 指向代表字符串结尾的 <code>\\0</code> 字符。）</p><p>上面就几乎是所有容器的共同点了。也就是说：</p><ul>\n<li>容器都有开始和结束点</li>\n<li>容器会记录其状态是否非空</li>\n<li>容器有大小</li>\n<li>容器支持交换</li>\n</ul><p>当然，这只是容器的“共同点”而已。每个容器都有其特殊的用途。</p><p><code>string</code> 的内存布局大致如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/62/eec393f933220a9998b7235c8acc1862.png?wh=1298*450\" alt=\"\"></p><p>下面你会看到，不管是内存布局，还是成员函数，<code>string</code> 和 <code>vector</code> 是非常相似的。</p><p><code>string</code> 当然是为了存放字符串。和简单的 C 字符串不同：</p><ul>\n<li><code>string</code> 负责自动维护字符串的生命周期</li>\n<li><code>string</code> 支持字符串的拼接操作（如之前说过的 <code>+</code> 和 <code>+=</code>）</li>\n<li><code>string</code> 支持字符串的查找操作（如 <code>find</code> 和 <code>rfind</code>）</li>\n<li><code>string</code> 支持从 <code>istream</code> 安全地读入字符串（使用 <code>getline</code>）</li>\n<li><code>string</code> 支持给期待 <code>const char*</code> 的接口传递字符串内容（使用 <code>c_str</code>）</li>\n<li><code>string</code> 支持到数字的互转（<code>stoi</code> 系列函数和 <code>to_string</code>）</li>\n<li>等等</li>\n</ul><p>推荐你在代码中尽量使用 <code>string</code> 来管理字符串。不过，对于对外暴露的接口，情况有一点复杂。我一般不建议在接口中使用 <code>const string&amp;</code>，除非确知调用者已经持有 <code>string</code>：如果函数里不对字符串做复杂处理的话，使用 <code>const char*</code> 可以避免在调用者只有 C 字符串时编译器自动构造 <code>string</code>，这种额外的构造和析构代价并不低。反过来，如果实现较为复杂、希望使用 <code>string</code> 的成员函数的话，那就应该考虑下面的策略：</p><ul>\n<li>如果不修改字符串的内容，使用 <code>const string&amp;</code> 或 C++17 的 <code>string_view</code> 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制。</li>\n<li>如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用 <code>string</code> 作为参数类型（自动拷贝）。</li>\n<li>如果需要改变调用者的字符串内容，使用 <code>string&amp;</code> 作为参数类型（通常不推荐）。</li>\n</ul><p>估计大部分同学对 <code>string</code> 已经很熟悉了。我们在此只给出一个非常简单的小例子：</p><pre><code class=\"language-c++\">string name;\ncout &lt;&lt; \"What's your name? \";\ngetline(cin, name);\ncout &lt;&lt; \"Nice to meet you, \" &lt;&lt; name\n     &lt;&lt; \"!\\n\";\n</code></pre><h2>vector</h2><p><code>vector</code> 应该是最常用的容器了。它的名字“向量”来源于数学术语，但在实际应用中，我们把它当成动态数组更为合适。它基本相当于 Java 的 <code>ArrayList</code> 和 Python 的 <code>list</code>。</p><p>和 <code>string</code> 相似，<code>vector</code> 的成员在内存里连续存放，同时 <code>begin</code>、<code>end</code>、<code>front</code>、<code>back</code> 成员函数指向的位置也和 <code>string</code> 一样，大致如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/24/10/247951f886561c30ced2eb7700f9d510.png?wh=1298*450\" alt=\"\"></p><p>除了容器类的共同点，<code>vector</code> 允许下面的操作（不完全列表）：</p><ul>\n<li>可以使用中括号的下标来访问其成员（同 <code>string</code>）</li>\n<li>可以使用 <code>data</code> 来获得指向其内容的裸指针（同 <code>string</code>）</li>\n<li>可以使用 <code>capacity</code> 来获得当前分配的存储空间的大小，以元素数量计（同 <code>string</code>）</li>\n<li>可以使用 <code>reserve</code> 来改变所需的存储空间的大小，成功后 <code>capacity()</code> 会改变（同 <code>string</code>）</li>\n<li>可以使用 <code>resize</code> 来改变其大小，成功后 <code>size()</code> 会改变（同 <code>string</code>）</li>\n<li>可以使用 <code>pop_back</code> 来删除最后一个元素（同 <code>string</code>）</li>\n<li>可以使用 <code>push_back</code> 在尾部插入一个元素（同 <code>string</code>）</li>\n<li>可以使用 <code>insert</code> 在指定位置前插入一个元素（同 <code>string</code>）</li>\n<li>可以使用 <code>erase</code> 在指定位置删除一个元素（同 <code>string</code>）</li>\n<li>可以使用 <code>emplace</code> 在指定位置构造一个元素</li>\n<li>可以使用 <code>emplace_back</code> 在尾部新构造一个元素</li>\n</ul><p>大家可以留意一下 <code>push_…</code> 和 <code>pop_…</code> 成员函数。它们存在时，说明容器对指定位置的删除和插入性能较高。<code>vector</code> 适合在尾部操作，这是它的内存布局决定的。只有在尾部插入和删除时，其他元素才会不需要移动，除非内存空间不足导致需要重新分配内存空间。</p><p>当 <code>push_back</code>、<code>insert</code>、<code>reserve</code>、<code>resize</code> 等函数导致内存重分配时，或当 <code>insert</code>、<code>erase</code> 导致元素位置移动时，<code>vector</code> 会试图把元素“移动”到新的内存区域。<code>vector</code> 通常保证强异常安全性，如果元素类型没有提供一个<strong>保证不抛异常的移动构造函数</strong>，<code>vector</code> 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 <code>noexcept</code>，或只在容器中放置对象的智能指针。这就是为什么我之前需要在 <code>smart_ptr</code> 的实现中标上 <code>noexcept</code> 的原因。</p><p>下面的代码可以演示这一行为：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Obj1 {\npublic:\n  Obj1()\n  {\n    cout &lt;&lt; \"Obj1()\\n\";\n  }\n  Obj1(const Obj1&amp;)\n  {\n    cout &lt;&lt; \"Obj1(const Obj1&amp;)\\n\";\n  }\n  Obj1(Obj1&amp;&amp;)\n  {\n    cout &lt;&lt; \"Obj1(Obj1&amp;&amp;)\\n\";\n  }\n};\n\nclass Obj2 {\npublic:\n  Obj2()\n  {\n    cout &lt;&lt; \"Obj2()\\n\";\n  }\n  Obj2(const Obj2&amp;)\n  {\n    cout &lt;&lt; \"Obj2(const Obj2&amp;)\\n\";\n  }\n  Obj2(Obj2&amp;&amp;) noexcept\n  {\n    cout &lt;&lt; \"Obj2(Obj2&amp;&amp;)\\n\";\n  }\n};\n\nint main()\n{\n  vector&lt;Obj1&gt; v1;\n  v1.reserve(2);\n  v1.emplace_back();\n  v1.emplace_back();\n  v1.emplace_back();\n\n  vector&lt;Obj2&gt; v2;\n  v2.reserve(2);\n  v2.emplace_back();\n  v2.emplace_back();\n  v2.emplace_back();\n}\n</code></pre><p>我们可以立即得到下面的输出：</p><blockquote>\n<p><code>Obj1()</code><br>\n<code>Obj1()</code><br>\n<code>Obj1()</code><br>\n<code>Obj1(const Obj1&amp;)</code><br>\n<code>Obj1(const Obj1&amp;)</code><br>\n<code>Obj2()</code><br>\n<code>Obj2()</code><br>\n<code>Obj2()</code><br>\n<code>Obj2(Obj2&amp;&amp;)</code><br>\n<code>Obj2(Obj2&amp;&amp;)</code></p>\n</blockquote><p><code>Obj1</code> 和 <code>Obj2</code> 的定义只差了一个 <code>noexcept</code>，但这个小小的差异就导致了 <code>vector</code> 是否会移动对象。这点非常重要。</p><p>C++11 开始提供的 <code>emplace…</code> 系列函数是为了提升容器的性能而设计的。你可以试试把 <code>v1.emplace_back()</code> 改成 <code>v1.push_back(Obj1())</code>。对于 <code>vector</code> 里的内容，结果是一样的；但使用 <code>push_back</code> 会额外生成临时对象，多一次（移动或拷贝）构造和析构。如果是移动的情况，那会有小幅性能损失；如果对象没有实现移动的话，那性能差异就可能比较大了。</p><p>现代处理器的体系架构使得对连续内存访问的速度比不连续的内存要快得多。因而，<code>vector</code> 的连续内存使用是它的一大优势所在。当你不知道该用什么容器时，缺省就使用 <code>vector</code> 吧。</p><p><code>vector</code> 的一个主要缺陷是大小增长时导致的元素移动。如果可能，尽早使用 <code>reserve</code> 函数为 <code>vector</code> 保留所需的内存，这在 <code>vector</code> 预期会增长很大时能带来很大的性能提升。</p><h2>deque</h2><p><code>deque</code> 的意思是 double-ended queue，双端队列。它主要是用来满足下面这个需求：</p><ul>\n<li>容器不仅可以从尾部自由地添加和删除元素，也可以从头部自由地添加和删除。</li>\n</ul><p><code>deque</code> 的接口和 <code>vector</code> 相比，有如下的区别：</p><ul>\n<li><code>deque</code> 提供 <code>push_front</code>、<code>emplace_front</code> 和 <code>pop_front</code> 成员函数。</li>\n<li><code>deque</code> 不提供 <code>data</code>、<code>capacity</code> 和 <code>reserve</code> 成员函数。</li>\n</ul><p><code>deque</code> 的内存布局一般是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/a1/aea92e7e005d65fa56d6332bb7706fa1.png?wh=1104*832\" alt=\"\"></p><p>可以看到：</p><ul>\n<li>如果只从头、尾两个位置对 <code>deque</code> 进行增删操作的话，容器里的对象永远不需要移动。</li>\n<li>容器里的元素只是部分连续的（因而没法提供 <code>data</code> 成员函数）。</li>\n<li>由于元素的存储大部分仍然连续，它的遍历性能是比较高的。</li>\n<li>由于每一段存储大小相等，<code>deque</code> 支持使用下标访问容器元素，大致相当于 <code>index[i / chunk_size][i % chunk_size]</code>，也保持高效。</li>\n</ul><p>如果你需要一个经常在头尾增删元素的容器，那 <code>deque</code> 会是个合适的选择。</p><h2>list</h2><p><code>list</code> 在 C++ 里代表双向链表。和 <code>vector</code> 相比，它优化了在容器中间的插入和删除：</p><ul>\n<li><code>list</code> 提供高效的、O(1) 复杂度的任意位置的插入和删除操作。</li>\n<li><code>list</code> 不提供使用下标访问其元素。</li>\n<li><code>list</code> 提供 <code>push_front</code>、<code>emplace_front</code> 和 <code>pop_front</code> 成员函数（和 <code>deque</code> 相同）。</li>\n<li><code>list</code> 不提供 <code>data</code>、<code>capacity</code> 和 <code>reserve</code> 成员函数（和 <code>deque</code> 相同）。</li>\n</ul><p>它的内存布局一般是下图这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/ad/14/addb521e20de1a302206f4286eac3914.png?wh=1388*788\" alt=\"\"></p><p>需要指出的是，虽然 <code>list</code> 提供了任意位置插入新元素的灵活性，但由于每个元素的内存空间都是单独分配、不连续，它的遍历性能比 <code>vector</code> 和 <code>deque</code> 都要低。这在很大程度上抵消了它在插入和删除操作时不需要移动元素的理论性能优势。如果你不太需要遍历容器、又需要在中间频繁插入或删除元素，可以考虑使用 <code>list</code>。</p><p>另外一个需要注意的地方是，因为某些标准算法在 <code>list</code> 上会导致问题，list 提供了成员函数作为替代，包括下面几个：</p><ul>\n<li><code>merge</code></li>\n<li><code>remove</code></li>\n<li><code>remove_if</code></li>\n<li><code>reverse</code></li>\n<li><code>sort</code></li>\n<li><code>unique</code></li>\n</ul><p>下面是一个示例（以 xeus-cling 的交互为例）：</p><pre><code class=\"language-c++\">#include &lt;algorithm&gt;\n#include &lt;list&gt;\n#include &lt;vector&gt;\nusing namespace std;\n</code></pre><pre><code class=\"language-c++\">list&lt;int&gt; lst{1, 7, 2, 8, 3};\nvector&lt;int&gt; vec{1, 7, 2, 8, 3};\n</code></pre><pre><code class=\"language-c++\">sort(vec.begin(), vec.end());     // 正常\n// sort(lst.begin(), lst.end());  // 会出错\nlst.sort();                       // 正常\n</code></pre><pre><code class=\"language-c++\">lst  // 输出 { 1, 2, 3, 7, 8 }\n</code></pre><pre><code class=\"language-c++\">vec  // 输出 { 1, 2, 3, 7, 8 }\n</code></pre><p>如果不用 xeus-cling 的话，我们需要做点转换：</p><ul>\n<li>把 <code>using namespace std;</code> 后面的部分放到 <code>main</code> 函数里。</li>\n<li>文件开头加上 <code>#include \"output_container.h\"</code> 和 <code>#include &lt;iostream&gt;</code>。</li>\n<li>把输出语句改写成 <code>cout &lt;&lt; … &lt;&lt; endl;</code>。</li>\n</ul><p>这次我会给一下改造的示例（下次就请你自行改写了😉）：</p><pre><code class=\"language-c++\">#include \"output_container.h\"\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;list&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main()\n{\n  list&lt;int&gt; lst{1, 7, 2, 8, 3};\n  vector&lt;int&gt; vec{1, 7, 2, 8, 3};\n\n  sort(vec.begin(), vec.end());    // 正常\n  // sort(lst.begin(), lst.end()); // 会出错\n  lst.sort();                      // 正常\n\n  cout &lt;&lt; lst &lt;&lt; endl;\n  // 输出 { 1, 2, 3, 7, 8 }\n\n  cout &lt;&lt; vec &lt;&lt; endl;\n  // 输出 { 1, 2, 3, 7, 8 }\n}\n</code></pre><h2>forward_list</h2><p>既然 <code>list</code> 是双向链表，那么 C++ 里有没有单向链表呢？答案是肯定的。从 C++11 开始，前向列表 <code>forward_list</code> 成了标准的一部分。</p><p>我们先看一下它的内存布局：</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/4e/ef23c4d60940c170629cf65771df084e.png?wh=1388*788\" alt=\"\"></p><p>大部分 C++ 容器都支持 <code>insert</code> 成员函数，语义是从指定的位置之前插入一个元素。对于 <code>forward_list</code>，这不是一件容易做到的事情（想一想，为什么？）。标准库提供了一个 <code>insert_after</code> 作为替代。此外，它跟 <code>list</code> 相比还缺了下面这些成员函数：</p><ul>\n<li><code>back</code></li>\n<li><code>size</code></li>\n<li><code>push_back</code></li>\n<li><code>emplace_back</code></li>\n<li><code>pop_back</code></li>\n</ul><p>为什么会需要这么一个阉割版的 list 呢？原因是，在元素大小较小的情况下，<code>forward_list</code> 能节约的内存是非常可观的；在列表不长的情况下，不能反向查找也不是个大问题。提高内存利用率，往往就能提高程序性能，更不用说在内存可能不足时的情况了。</p><p>目前你只需要知道这个东西的存在就可以了。如果你觉得不需要用到它的话，也许你真的不需要它。</p><h2>queue</h2><p>在结束本讲之前，我们再快速讲两个类容器。它们的特别点在于它们都不是完整的实现，而是依赖于某个现有的容器，因而被称为容器适配器（container adaptor）。</p><p>我们先看一下队列 <code>queue</code>，先进先出（FIFO）的数据结构。</p><p><code>queue</code> 缺省用 <code>deque</code> 来实现。它的接口跟 <code>deque</code> 比，有如下改变：</p><ul>\n<li>不能按下标访问元素</li>\n<li>没有 <code>begin</code>、<code>end</code> 成员函数</li>\n<li>用 <code>emplace</code> 替代了 <code>emplace_back</code>，用 <code>push</code> 替代了 <code>push_back</code>，用 <code>pop</code> 替代了 <code>pop_front</code>；没有其他的 <code>push_…</code>、<code>pop_…</code>、<code>emplace…</code>、<code>insert</code>、<code>erase</code> 函数</li>\n</ul><p>它的实际内存布局当然是随底层的容器而定的。从概念上讲，它的结构可如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/09/ff/090f23e3b4cdd8d297e4b970cbbf6cff.png?wh=1298*450\" alt=\"\"></p><p>鉴于 <code>queue</code> 不提供 <code>begin</code> 和 <code>end</code> 方法，无法无损遍历，我们只能用下面的代码约略展示一下其接口：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nint main()\n{\n  std::queue&lt;int&gt; q;\n  q.push(1);\n  q.push(2);\n  q.push(3);\n  while (!q.empty()) {\n    std::cout &lt;&lt; q.front()\n              &lt;&lt; std::endl;\n    q.pop();\n  }\n}\n</code></pre><p>这个代码的输出就不用解释了吧。哈哈。</p><h2>stack</h2><p>类似地，栈 <code>stack</code> 是后进先出（LIFO）的数据结构。</p><p><code>stack</code> 缺省也是用 <code>deque</code> 来实现，但它的概念和 <code>vector</code> 更相似。它的接口跟 <code>vector</code> 比，有如下改变：</p><ul>\n<li>不能按下标访问元素</li>\n<li>没有 <code>begin</code>、<code>end</code> 成员函数</li>\n<li><code>back</code> 成了 <code>top</code>，没有 <code>front</code></li>\n<li>用 <code>emplace</code> 替代了 <code>emplace_back</code>，用 <code>push</code> 替代了 <code>push_back</code>，用 <code>pop</code> 替代了 <code>pop_back</code>；没有其他的 <code>push_…</code>、<code>pop_…</code>、<code>emplace…</code>、<code>insert</code>、<code>erase</code> 函数</li>\n</ul><p>一般图形表示法会把 <code>stack</code> 表示成一个竖起的 <code>vector</code>：</p><p><img src=\"https://static001.geekbang.org/resource/image/68/47/68026091ff5eacac00c49d75151fff47.png?wh=1476*692\" alt=\"\"></p><p>这里有一个小细节需要注意。<code>stack</code> 跟我们前面讨论内存管理时的栈有一个区别：在这里下面是低地址，向上则地址增大；而我们讨论内存管理时，高地址在下面，向上则地址减小，方向正好相反。提这一点，是希望你在有需要检查栈结构时不会因此而发生混淆；在使用 <code>stack</code> 时，这个区别通常无关紧要。</p><p>示例代码和上面的 <code>queue</code> 相似，但输出正好相反：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nint main()\n{\n  std::stack&lt;int&gt; s;\n  s.push(1);\n  s.push(2);\n  s.push(3);\n  while (!s.empty()) {\n    std::cout &lt;&lt; s.top()\n              &lt;&lt; std::endl;\n    s.pop();\n  }\n}\n</code></pre><h2>内容小结</h2><p>本讲我们介绍了 C++ 里面的序列容器和两个容器适配器。通过本讲的介绍，你应该已经对容器有了一定的理解和认识。下一讲我们会讲完剩余的标准容器。</p><h2>课后思考</h2><p>留几个问题请你思考一下：</p><ol>\n<li>今天讲的容器有哪些共同的特点？</li>\n<li>为什么 C++ 有这么多不同的序列容器类型？</li>\n<li>为什么 <code>stack</code>（或 <code>queue</code>）的 <code>pop</code> 函数返回类型为 <code>void</code>，而不是直接返回容器的 <code>top</code>（或 <code>front</code>）成员？</li>\n</ol><p>欢迎留言和我交流你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Containers library”. <a href=\"https://en.cppreference.com/w/cpp/container\">https://en.cppreference.com/w/cpp/container</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “容器库”. <a href=\"https://zh.cppreference.com/w/cpp/container\">https://zh.cppreference.com/w/cpp/container</a> </span></p><p><span class=\"reference\">[2] QuantStack, xeus-cling. <a href=\"https://github.com/QuantStack/xeus-cling\">https://github.com/QuantStack/xeus-cling</a> </span></p><p><span class=\"reference\">[3] 吴咏炜, output_container. <a href=\"https://github.com/adah1972/output_container/blob/master/output_container.h\">https://github.com/adah1972/output_container/blob/master/output_container.h</a> </span></p>","neighbors":{"left":{"article_title":"03 | 右值和移动究竟解决了什么问题？","id":169268},"right":{"article_title":"05 | 容器汇编 II：需要函数对象的容器","id":174434}}},{"article_id":174434,"article_title":"05 | 容器汇编 II：需要函数对象的容器","article_content":"<p>你好，我是吴咏炜。</p><p>上一讲我们学习了 C++ 的序列容器和两个容器适配器，今天我们继续讲完剩下的标准容器（<span class=\"orange\">[1]</span>）。</p><h2>函数对象及其特化</h2><p>在讲容器之前，我们需要首先来讨论一下两个重要的函数对象，<code>less</code> 和 <code>hash</code>。</p><p>我们先看一下 <code>less</code>，小于关系。在标准库里，通用的 <code>less</code> 大致是这样定义的：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nstruct less\n  : binary_function&lt;T, T, bool&gt; {\n  bool operator()(const T&amp; x,\n                  const T&amp; y) const\n  {\n    return x &lt; y;\n  }\n};\n</code></pre><p>也就是说，<code>less</code> 是一个函数对象，并且是个二元函数，执行对任意类型的值的比较，返回布尔类型。作为函数对象，它定义了函数调用运算符（<code>operator()</code>），并且缺省行为是对指定类型的对象进行 <code>&lt;</code> 的比较操作。</p><p>有点平淡无奇，是吧？原因是因为这个缺省实现在大部分情况下已经够用，我们不太需要去碰它。在需要大小比较的场合，C++ 通常默认会使用 <code>less</code>，包括我们今天会讲到的若干容器和排序算法 <code>sort</code>。如果我们需要产生相反的顺序的话，则可以使用 <code>greater</code>，大于关系。</p><p>计算哈希值的函数对象 <code>hash</code> 就不一样了。它的目的是把一个某种类型的值转换成一个无符号整数哈希值，类型为 <code>size_t</code>。它没有一个可用的默认实现。对于常用的类型，系统提供了需要的特化 <span class=\"orange\">[2]</span>，类似于：</p><!-- [[[read_end]]] --><pre><code class=\"language-c++\">template &lt;class T&gt; struct hash;\n\ntemplate &lt;&gt;\nstruct hash&lt;int&gt;\n  : public unary_function&lt;int, size_t&gt; {\n  size_t operator()(int v) const\n    noexcept\n  {\n    return static_cast&lt;size_t&gt;(v);\n  }\n};\n</code></pre><p>这当然是一个极其简单的例子。更复杂的类型，如指针或者 <code>string</code> 的特化，都会更复杂。要点是，对于每个类，类的作者都可以提供 <code>hash</code> 的特化，使得对于不同的对象值，函数调用运算符都能得到尽可能均匀分布的不同数值。</p><p>我们用下面这个例子来加深一下理解：</p><pre><code class=\"language-c++\">#include &lt;algorithm&gt;   // std::sort\n#include &lt;functional&gt;  // std::less/greater/hash\n#include &lt;iostream&gt;    // std::cout/endl\n#include &lt;string&gt;      // std::string\n#include &lt;vector&gt;      // std::vector\n#include \"output_container.h\"\n\nusing namespace std;\n\nint main()\n{\n  // 初始数组\n  vector&lt;int&gt; v{13, 6, 4, 11, 29};\n  cout &lt;&lt; v &lt;&lt; endl;\n\n  // 从小到大排序\n  sort(v.begin(), v.end());\n  cout &lt;&lt; v &lt;&lt; endl;\n\n  // 从大到小排序\n  sort(v.begin(), v.end(),\n       greater&lt;int&gt;());\n  cout &lt;&lt; v &lt;&lt; endl;\n\n  cout &lt;&lt; hex;\n\n  auto hp = hash&lt;int*&gt;();\n  cout &lt;&lt; \"hash(nullptr)  = \"\n       &lt;&lt; hp(nullptr) &lt;&lt; endl;\n  cout &lt;&lt; \"hash(v.data()) = \"\n       &lt;&lt; hp(v.data()) &lt;&lt; endl;\n  cout &lt;&lt; \"v.data()       = \"\n       &lt;&lt; static_cast&lt;void*&gt;(v.data())\n       &lt;&lt; endl;\n\n  auto hs = hash&lt;string&gt;();\n  cout &lt;&lt; \"hash(\\\"hello\\\")  = \"\n       &lt;&lt; hs(string(\"hello\")) &lt;&lt; endl;\n  cout &lt;&lt; \"hash(\\\"hellp\\\")  = \"\n       &lt;&lt; hs(string(\"hellp\")) &lt;&lt; endl;\n}\n</code></pre><p>在 MSVC 下的某次运行结果如下所示：</p><blockquote>\n<p><code>{ 13, 6, 4, 11, 29 }</code><br>\n<code>{ 4, 6, 11, 13, 29 }</code><br>\n<code>{ 29, 13, 11, 6, 4 }</code><br>\n<code>hash(nullptr) = a8c7f832281a39c5</code><br>\n<code>hash(v.data()) = 7a0bdfd7df0923d2</code><br>\n<code>v.data() = 000001EFFB10EAE0</code><br>\n<code>hash(\"hello\") = a430d84680aabd0b</code><br>\n<code>hash(\"hellp\") = a430e54680aad322</code></p>\n</blockquote><p>可以看到，在这个实现里，空指针的哈希值是一个非零的数值，指针的哈希值也和指针的数值不一样。要注意不同的实现处理的方式会不一样。事实上，我的测试结果是 GCC、Clang 和 MSVC 对常见类型的哈希方式都各有不同。</p><p>在上面的例子里，我们同时可以看到，这两个函数对象的值不重要。我们甚至可以认为，每个 <code>less</code>（或 <code>greater</code> 或 <code>hash</code>）对象都是等价的。关键在于其类型。以 <code>sort</code> 为例，第三个参数的类型确定了其排序行为。</p><p>对于容器也是如此，函数对象的类型确定了容器的行为。</p><h2>priority_queue</h2><p><code>priority_queue</code> 也是一个容器适配器。上一讲没有和其他容器适配器一起讲的原因就在于它用到了比较函数对象（默认是 <code>less</code>）。它和 <code>stack</code> 相似，支持 <code>push</code>、<code>pop</code>、<code>top</code> 等有限的操作，但容器内的顺序既不是后进先出，也不是先进先出，而是（部分）排序的结果。在使用缺省的 <code>less</code> 作为其 <code>Compare</code> 模板参数时，最大的数值会出现在容器的“顶部”。如果需要最小的数值出现在容器顶部，则可以传递 <code>greater</code> 作为其 <code>Compare</code> 模板参数。</p><p>下面的代码可以演示其功能：</p><pre><code class=\"language-c++\">#include &lt;functional&gt;  // std::greater\n#include &lt;iostream&gt;    // std::cout/endl\n#include &lt;memory&gt;      // std::pair\n#include &lt;queue&gt;       // std::priority_queue\n#include &lt;vector&gt;      // std::vector\n#include \"output_container.h\"\n\nusing namespace std;\n\nint main()\n{\n  priority_queue&lt;\n    pair&lt;int, int&gt;,\n    vector&lt;pair&lt;int, int&gt;&gt;,\n    greater&lt;pair&lt;int, int&gt;&gt;&gt;\n    q;\n  q.push({1, 1});\n  q.push({2, 2});\n  q.push({0, 3});\n  q.push({9, 4});\n  while (!q.empty()) {\n    cout &lt;&lt; q.top() &lt;&lt; endl;\n    q.pop();\n  }\n}\n</code></pre><p>输出为：</p><blockquote>\n<p><code>(0, 3)</code><br>\n<code>(1, 1)</code><br>\n<code>(2, 2)</code><br>\n<code>(9, 4)</code></p>\n</blockquote><h2>关联容器</h2><p>关联容器有 <code>set</code>（集合）、<code>map</code>（映射）、<code>multiset</code>（多重集）和 <code>multimap</code>（多重映射）。跳出 C++ 的语境，<code>map</code>（映射）的更常见的名字是关联数组和字典 <span class=\"orange\">[3]</span>，而在 JSON 里直接被称为对象（object）。在 C++ 外这些容器常常是无序的；在 C++ 里关联容器则被认为是有序的。</p><p>我们可以通过以下的 xeus-cling 交互来体会一下。</p><pre><code class=\"language-c++\">#include &lt;functional&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\nusing namespace std;\n</code></pre><pre><code class=\"language-c++\">set&lt;int&gt; s{1, 1, 1, 2, 3, 4};\n</code></pre><pre><code class=\"language-c++\">s\n</code></pre><blockquote>\n<p><code>{ 1, 2, 3, 4 }</code></p>\n</blockquote><pre><code class=\"language-c++\">multiset&lt;int, greater&lt;int&gt;&gt; ms{1, 1, 1, 2, 3, 4};\n</code></pre><pre><code class=\"language-c++\">ms\n</code></pre><blockquote>\n<p><code>{ 4, 3, 2, 1, 1, 1 }</code></p>\n</blockquote><pre><code class=\"language-c++\">map&lt;string, int&gt; mp{\n  {\"one\", 1},\n  {\"two\", 2},\n  {\"three\", 3},\n  {\"four\", 4}\n};\n</code></pre><pre><code class=\"language-c++\">mp\n</code></pre><blockquote>\n<p><code>{ \"four\" =&gt; 4, \"one\" =&gt; 1, \"three\" =&gt; 3, \"two\" =&gt; 2 }</code></p>\n</blockquote><pre><code class=\"language-c++\">mp.insert({\"four\", 4});\n</code></pre><pre><code class=\"language-c++\">mp\n</code></pre><blockquote>\n<p><code>{ \"four\" =&gt; 4, \"one\" =&gt; 1, \"three\" =&gt; 3, \"two\" =&gt; 2 }</code></p>\n</blockquote><pre><code class=\"language-c++\">mp.find(\"four\") == mp.end()\n</code></pre><blockquote>\n<p><code>false</code></p>\n</blockquote><pre><code class=\"language-c++\">mp.find(\"five\") == mp.end()\n</code></pre><blockquote>\n<p><code>(bool) true</code></p>\n</blockquote><pre><code class=\"language-c++\">mp[\"five\"] = 5;\n</code></pre><pre><code class=\"language-c++\">mp\n</code></pre><blockquote>\n<p><code>{ \"five\" =&gt; 5, \"four\" =&gt; 4, \"one\" =&gt; 1, \"three\" =&gt; 3, \"two\" =&gt; 2 }</code></p>\n</blockquote><pre><code class=\"language-c++\">multimap&lt;string, int&gt; mmp{\n  {\"one\", 1},\n  {\"two\", 2},\n  {\"three\", 3},\n  {\"four\", 4}\n};\n</code></pre><pre><code class=\"language-c++\">mmp\n</code></pre><blockquote>\n<p><code>{ \"four\" =&gt; 4, \"one\" =&gt; 1, \"three\" =&gt; 3, \"two\" =&gt; 2 }</code></p>\n</blockquote><pre><code class=\"language-c++\">mmp.insert({\"four\", -4});\n</code></pre><pre><code class=\"language-c++\">mmp\n</code></pre><blockquote>\n<p><code>{ \"four\" =&gt; 4, \"four\" =&gt; -4, \"one\" =&gt; 1, \"three\" =&gt; 3, \"two\" =&gt; 2 }</code></p>\n</blockquote><p>可以看到，关联容器是一种有序的容器。名字带“multi”的允许键重复，不带的不允许键重复。<code>set</code> 和 <code>multiset</code> 只能用来存放键，而 <code>map</code> 和 <code>multimap</code> 则存放一个个键值对。</p><p>与序列容器相比，关联容器没有前、后的概念及相关的成员函数，但同样提供 <code>insert</code>、<code>emplace</code> 等成员函数。此外，关联容器都有 <code>find</code>、<code>lower_bound</code>、<code>upper_bound</code> 等查找函数，结果是一个迭代器：</p><ul>\n<li><code>find(k)</code> 可以找到任何一个等价于查找键 k 的元素（<code>!(x &lt; k || k &lt; x)</code>）</li>\n<li><code>lower_bound(k)</code> 找到第一个不小于查找键 k 的元素（<code>!(x &lt; k)</code>）</li>\n<li><code>upper_bound(k)</code> 找到第一个大于查找键 k 的元素（<code>k &lt; x</code>）</li>\n</ul><pre><code class=\"language-c++\">mp.find(\"four\")-&gt;second\n</code></pre><blockquote>\n<p><code>4</code></p>\n</blockquote><pre><code class=\"language-c++\">mp.lower_bound(\"four\")-&gt;second\n</code></pre><blockquote>\n<p><code>4</code></p>\n</blockquote><pre><code class=\"language-c++\">(--mp.upper_bound(\"four\"))-&gt;second\n</code></pre><blockquote>\n<p><code>4</code></p>\n</blockquote><pre><code class=\"language-c++\">mmp.lower_bound(\"four\")-&gt;second\n</code></pre><blockquote>\n<p><code>4</code></p>\n</blockquote><pre><code class=\"language-c++\">(--mmp.upper_bound(\"four\"))-&gt;second\n</code></pre><blockquote>\n<p><code>-4</code></p>\n</blockquote><p>如果你需要在 <code>multimap</code> 里精确查找满足某个键的区间的话，建议使用 <code>equal_range</code>，可以一次性取得上下界（半开半闭）。如下所示：</p><pre><code class=\"language-c++\">#include &lt;tuple&gt;\nmultimap&lt;string, int&gt;::iterator\n  lower, upper;\nstd::tie(lower, upper) =\n  mmp.equal_range(\"four\");\n</code></pre><pre><code class=\"language-c++\">(lower != upper)  // 检测区间非空\n</code></pre><blockquote>\n<p><code>true</code></p>\n</blockquote><pre><code class=\"language-c++\">lower-&gt;second\n</code></pre><blockquote>\n<p><code>4</code></p>\n</blockquote><pre><code class=\"language-c++\">(--upper)-&gt;second\n</code></pre><blockquote>\n<p><code>-4</code></p>\n</blockquote><p>如果在声明关联容器时没有提供比较类型的参数，缺省使用 <code>less</code> 来进行排序。如果键的类型提供了比较算符 <code>&lt;</code> 的重载，我们不需要做任何额外的工作。否则，我们就需要对键类型进行 <code>less</code> 的特化，或者提供一个其他的函数对象类型。</p><p>对于自定义类型，我推荐尽量使用标准的 <code>less</code> 实现，通过重载 <code>&lt;</code>（及其他标准比较运算符）对该类型的对象进行排序。存储在关联容器中的键一般应满足严格弱序关系（strict weak ordering；<span class=\"orange\">[4]</span>），即：</p><ul>\n<li>对于任何该类型的对象 x：<code>!(x &lt; x)</code>（非自反）</li>\n<li>对于任何该类型的对象 x 和 y：如果 <code>x &lt; y</code>，则 <code>!(y &lt; x)</code>（非对称）</li>\n<li>对于任何该类型的对象 x、y 和 z：如果 <code>x &lt; y</code> 并且 <code>y &lt; z</code>，则 <code>x &lt; z</code>（传递性）</li>\n<li>对于任何该类型的对象 x、y 和 z：如果 x 和 y 不可比（<code>!(x &lt; y)</code> 并且 <code>!(y &lt; x)</code>）并且 y 和 z 不可比，则 x 和 z 不可比（不可比的传递性）</li>\n</ul><p>大部分情况下，类型是可以满足这些条件的，不过：</p><ul>\n<li>如果类型没有一般意义上的大小关系（如复数），我们一定要别扭地定义一个大小关系吗？</li>\n<li>通过比较来进行查找、插入和删除，复杂度为对数 O(log(n))，有没有达到更好的性能的方法？</li>\n</ul><h2>无序关联容器</h2><p>从 C++11 开始，每一个关联容器都有一个对应的无序关联容器，它们是：</p><ul>\n<li><code>unordered_set</code></li>\n<li><code>unordered_map</code></li>\n<li><code>unordered_multiset</code></li>\n<li><code>unordered_multimap</code></li>\n</ul><p>这些容器和关联容器非常相似，主要的区别就在于它们是“无序”的。这些容器不要求提供一个排序的函数对象，而要求一个可以计算哈希值的函数对象。你当然可以在声明容器对象时手动提供这样一个函数对象类型，但更常见的情况是，我们使用标准的 <code>hash</code> 函数对象及其特化。</p><p>下面是一个示例（这次我们暂不使用 xeus-cling，因为它在输出复数时有限制，不能显示其数值）：</p><pre><code class=\"language-c++\">#include &lt;complex&gt;        // std::complex\n#include &lt;iostream&gt;       // std::cout/endl\n#include &lt;unordered_map&gt;  // std::unordered_map\n#include &lt;unordered_set&gt;  // std::unordered_set\n#include \"output_container.h\"\n\nusing namespace std;\n\nnamespace std {\n\ntemplate &lt;typename T&gt;\nstruct hash&lt;complex&lt;T&gt;&gt; {\n  size_t\n  operator()(const complex&lt;T&gt;&amp; v) const\n    noexcept\n  {\n    hash&lt;T&gt; h;\n    return h(v.real()) + h(v.imag());\n  }\n};\n\n}  // namespace std\n\nint main()\n{\n  unordered_set&lt;int&gt; s{\n    1, 1, 2, 3, 5, 8, 13, 21\n  };\n  cout &lt;&lt; s &lt;&lt; endl;\n\n  unordered_map&lt;complex&lt;double&gt;,\n                double&gt;\n    umc{{{1.0, 1.0}, 1.4142},\n        {{3.0, 4.0}, 5.0}};\n  cout &lt;&lt; umc &lt;&lt; endl;\n}\n</code></pre><p>输出可能是（顺序不能保证）：</p><blockquote>\n<p><code>{ 21, 5, 8, 3, 13, 2, 1 }</code><br>\n<code>{ (3,4) =&gt; 5, (1,1) =&gt; 1.4142 }</code></p>\n</blockquote><p>请注意我们在 <code>std</code> 名空间中添加了特化，这是少数用户可以向 <code>std</code> 名空间添加内容的情况之一。正常情况下，向 <code>std</code> 名空间添加声明或定义是禁止的，属于未定义行为。</p><p>从实际的工程角度，无序关联容器的主要优点在于其性能。关联容器和 <code>priority_queue</code> 的插入和删除操作，以及关联容器的查找操作，其复杂度都是 O(log(n))，而无序关联容器的实现使用哈希表 <span class=\"orange\">[5]</span>，可以达到平均 O(1)！但这取决于我们是否使用了一个好的哈希函数：在哈希函数选择不当的情况下，无序关联容器的插入、删除、查找性能可能成为最差情况的 O(n)，那就比关联容器糟糕得多了。</p><h2>array</h2><p>我们讲的最后一个容器是 C 数组的替代品。C 数组在 C++ 里继续存在，主要是为了保留和 C 的向后兼容性。C 数组本身和 C++ 的容器相差是非常大的：</p><ul>\n<li>C 数组没有 <code>begin</code> 和 <code>end</code> 成员函数（虽然可以使用全局的 <code>begin</code> 和 <code>end</code> 函数）</li>\n<li>C 数组没有 <code>size</code> 成员函数（得用一些模板技巧来获取其长度）</li>\n<li>C 数组作为参数有退化行为，传递给另外一个函数后那个函数不再能获得 C 数组的长度和结束位置</li>\n</ul><p>在 C 的年代，大家有时候会定义这样一个宏来获得数组的长度：</p><pre><code class=\"language-c++\">#define ARRAY_LEN(a) \\\n  (sizeof(a) / sizeof((a)[0]))\n</code></pre><p>如果在一个函数内部对数组参数使用这个宏，结果肯定是错的。现在 GCC 会友好地发出警告：</p><pre><code class=\"language-c++\">void test(int a[8])\n{\n  cout &lt;&lt; ARRAY_LEN(a) &lt;&lt; endl;\n}\n</code></pre><blockquote>\n<p>warning: sizeof on array function parameter will return size of ‘int *’ instead of ‘int [8]’ [-Wsizeof-array-argument]<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; ARRAY_LEN(a) &lt;&lt; endl;</p>\n</blockquote><p>C++17 直接提供了一个 <code>size</code> 方法，可以用于提供数组长度，并且在数组退化成指针的情况下会直接失败：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;  // std::cout/endl\n#include &lt;iterator&gt;  // std::size\n\nvoid test(int arr[])\n{\n  // 不能编译\n  // std::cout &lt;&lt; std::size(arr)\n  //           &lt;&lt; std::endl;\n}\n\nint main()\n{\n  int arr[] = {1, 2, 3, 4, 5};\n  std::cout &lt;&lt; \"The array length is \"\n            &lt;&lt; std::size(arr)\n            &lt;&lt; std::endl;\n  test(arr);\n}\n</code></pre><p>此外，C 数组也没有良好的复制行为。你无法用 C 数组作为 <code>map</code> 或 <code>unordered_map</code> 的键类型。下面的代码演示了失败行为：</p><pre><code class=\"language-c++\">#include &lt;map&gt;  // std::map\n\ntypedef char mykey_t[8];\n\nint main()\n{\n  std::map&lt;mykey_t, int&gt; mp;\n  mykey_t mykey{\"hello\"};\n  mp[mykey] = 5;\n  // 轰，大段的编译错误\n}\n</code></pre><p>如果不用 C 数组的话，我们该用什么来替代呢？</p><p>我们有三个可以考虑的选项：</p><ul>\n<li>如果数组较大的话，应该考虑 <code>vector</code>。<code>vector</code> 有最大的灵活性和不错的性能。</li>\n<li>对于字符串数组，当然应该考虑 <code>string</code>。</li>\n<li>如果数组大小固定（C 的数组在 C++ 里本来就是大小固定的）并且较小的话，应该考虑 <code>array</code>。<code>array</code> 保留了 C 数组在栈上分配的特点，同时，提供了 <code>begin</code>、<code>end</code>、<code>size</code> 等通用成员函数。</li>\n</ul><p><code>array</code> 可以避免 C 数组的种种怪异行径。上面的失败代码，如果使用 <code>array</code> 的话，稍作改动就可以通过编译：</p><pre><code class=\"language-c++\">#include &lt;array&gt;     // std::array\n#include &lt;iostream&gt;  // std::cout/endl\n#include &lt;map&gt;       // std::map\n#include \"output_container.h\"\n\ntypedef std::array&lt;char, 8&gt; mykey_t;\n\nint main()\n{\n  std::map&lt;mykey_t, int&gt; mp;\n  mykey_t mykey{\"hello\"};\n  mp[mykey] = 5;  // OK\n  std::cout &lt;&lt; mp &lt;&lt; std::endl;\n}\n</code></pre><p>输出则是意料之中的：</p><blockquote>\n<p><code>{ hello =&gt; 5 }</code></p>\n</blockquote><h2>内容小结</h2><p>本讲介绍了 C++ 的两个常用的函数对象，<code>less</code> 和 <code>hash</code>；然后介绍了用到这两个函数对象的容器适配器、关联容器和无序关联容器；最后，通过例子展示了为什么我们应当避免 C 数组而考虑使用 <code>array</code>。通过这两讲，我们已经完整地了解了 C++ 提供的标准容器。</p><h2>课后思考</h2><p>请思考一下：</p><ol>\n<li>为什么大部分容器都提供了 <code>begin</code>、<code>end</code> 等方法？</li>\n<li>为什么容器没有继承一个公用的基类？</li>\n</ol><p>欢迎留言和我交流你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Containers library”. <a href=\"https://en.cppreference.com/w/cpp/container\">https://en.cppreference.com/w/cpp/container</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “容器库”. <a href=\"https://zh.cppreference.com/w/cpp/container\">https://zh.cppreference.com/w/cpp/container</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “Explicit (full) template specialization”. <a href=\"https://en.cppreference.com/w/cpp/language/template_specialization\">https://en.cppreference.com/w/cpp/language/template_specialization</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “显式（全）模板特化”. <a href=\"https://zh.cppreference.com/w/cpp/language/template_specialization\">https://zh.cppreference.com/w/cpp/language/template_specialization</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “Associative array”. <a href=\"https://en.wikipedia.org/wiki/Associative_array\">https://en.wikipedia.org/wiki/Associative_array</a> </span></p><p><span class=\"reference\">[3a] 维基百科, “关联数组”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84\">https://zh.wikipedia.org/zh-cn/关联数组</a> </span></p><p><span class=\"reference\">[4] Wikipedia, “Weak ordering”. <a href=\"https://en.wikipedia.org/wiki/Weak_ordering\">https://en.wikipedia.org/wiki/Weak_ordering</a> </span></p><p><span class=\"reference\">[5] Wikipedia, “Hash table”. <a href=\"https://en.wikipedia.org/wiki/Hash_table\">https://en.wikipedia.org/wiki/Hash_table</a> </span></p><p><span class=\"reference\">[5a] 维基百科, “哈希表”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%93%88%E5%B8%8C%E8%A1%A8\">https://zh.wikipedia.org/zh-cn/哈希表</a> </span></p>","neighbors":{"left":{"article_title":"04 | 容器汇编 I：比较简单的若干容器","id":173167},"right":{"article_title":"06 | 异常：用还是不用，这是个问题","id":175579}}},{"article_id":175579,"article_title":"06 | 异常：用还是不用，这是个问题","article_content":"<p>你好，我是吴咏炜。</p><p>到现在为止，我们已经有好多次都提到异常了。今天，我们就来彻底地聊一聊异常。</p><p>首先，开宗明义，如果你不知道到底该不该用异常的话，那答案就是该用。如果你需要避免使用异常，原因必须是你有明确的需要避免使用异常的理由。</p><p>下面我们就开始说说异常。</p><h2>没有异常的世界</h2><p>我们先来看看没有异常的世界是什么样子的。最典型的情况就是 C 了。</p><p>假设我们要做一些矩阵的操作，定义了下面这个矩阵的数据结构：</p><pre><code class=\"language-c\">typedef struct {\n  float* data;\n  size_t nrows;\n  size_t ncols;\n} matrix;\n</code></pre><p>我们至少需要有初始化和清理的代码：</p><pre><code class=\"language-c\">enum matrix_err_code {\n  MATRIX_SUCCESS,\n  MATRIX_ERR_MEMORY_INSUFFICIENT,\n  …\n};\n\nint matrix_alloc(matrix* ptr,\n                 size_t nrows,\n                 size_t ncols)\n{\n  size_t size =\n    nrows * ncols * sizeof(float);\n  float* data = malloc(size);\n  if (data == NULL) {\n    return MATRIX_ERR_MEMORY_INSUFFICIENT;\n  }\n  ptr-&gt;data = data;\n  ptr-&gt;nrows = nrows;\n  ptr-&gt;ncols = ncols;\n}\n\nvoid matrix_dealloc(matrix* ptr)\n{\n  if (ptr-&gt;data == NULL) {\n    return;\n  }\n  free(ptr-&gt;data);\n  ptr-&gt;data = NULL;\n  ptr-&gt;nrows = 0;\n  ptr-&gt;ncols = 0;\n}\n</code></pre><!-- [[[read_end]]] --><p>然后，我们做一下矩阵乘法吧。函数定义大概会是这个样子：</p><pre><code class=\"language-c\">int matrix_multiply(matrix* result,\n                    const matrix* lhs,\n                    const matrix* rhs)\n{\n  int errcode;\n  if (lhs-&gt;ncols != rhs-&gt;nrows) {\n    return MATRIX_ERR_MISMATCHED_MATRIX_SIZE;\n    // 呃，得把这个错误码添到 enum matrix_err_code 里\n  }\n  errcode = matrix_alloc(\n    result, lhs-&gt;nrows, rhs-&gt;ncols);\n  if (errcode != MATRIX_SUCCESS) {\n    return errcode;\n  }\n  // 进行矩阵乘法运算\n  return MATRIX_SUCCESS;\n}\n</code></pre><p>调用代码则大概是这个样子：</p><pre><code class=\"language-c\">  matrix c;\n\n  // 不清零的话，错误处理和资源清理会更复杂\n  memset(&amp;c, 0, sizeof(matrix));\n\n  errcode = matrix_multiply(c, a, b);\n  if (errcode != MATRIX_SUCCESS) {\n    goto error_exit;\n  }\n  // 使用乘法的结果做其他处理\n\nerror_exit:\n  matrix_dealloc(&amp;c);\n  return errcode;\n</code></pre><p>可以看到，我们有大量需要判断错误的代码，零散分布在代码各处。</p><p>可这是 C 啊。我们用 C++、不用异常可以吗？</p><p>当然可以，但你会发现结果好不了多少。毕竟，C++ 的构造函数是不能返回错误码的，所以你根本不能用构造函数来做可能出错的事情。你不得不定义一个只能清零的构造函数，再使用一个 <code>init</code> 函数来做真正的构造操作。C++ 虽然支持运算符重载，可你也不能使用，因为你没法返回一个新矩阵……</p><p>我上面还只展示了单层的函数调用。事实上，如果出错位置离处理错误的位置相差很远的话，每一层的函数调用里都得有判断错误码的代码，这就既对写代码的人提出了严格要求，也对读代码的人造成了视觉上的干扰……</p><h2>使用异常</h2><p>如果使用异常的话，我们就可以在构造函数里做真正的初始化工作了。假设我们的矩阵类有下列的数据成员：</p><pre><code class=\"language-c++\">class matrix {\n  …\nprivate:\n  float* data_;\n  size_t nrows_;\n  size_t ncols_;\n};\n</code></pre><p>构造函数我们可以这样写：</p><pre><code class=\"language-c++\">matrix::matrix(size_t nrows,\n               size_t ncols)\n{\n  data_  = new float[nrows * ncols];\n  nrows_ = nrows;\n  ncols_ = ncols;\n}\n</code></pre><p>析构非常简单：</p><pre><code class=\"language-c++\">matrix::~matrix()\n{\n  delete[] data_;\n}\n</code></pre><p>乘法函数可以这样写：</p><pre><code class=\"language-c++\">class matrix {\n  …\n  friend matrix\n  operator*(const matrix&amp;,\n            const matrix&amp;);\n};\n\nmatrix operator*(const matrix&amp; lhs,\n                 const matrix&amp; rhs)\n{\n  if (lhs.ncols != rhs.nrows) {\n    throw std::runtime_error(\n      \"matrix sizes mismatch\");\n  }\n  matrix result(lhs.nrows, rhs.ncols);\n  // 进行矩阵乘法运算\n  return result;\n}\n</code></pre><p>使用乘法的代码则更是简单：</p><pre><code class=\"language-c++\">matrix c = a * b;\n</code></pre><p>你可能已经非常疑惑了：错误处理在哪儿呢？只有一个 <code>throw</code>，跟前面的 C 代码能等价吗？</p><p>异常处理并不意味着需要写显式的 <code>try</code> 和 <code>catch</code>。<strong>异常安全的代码，可以没有任何 <code>try</code> 和 <code>catch</code>。</strong></p><p>如果你不确定什么是“异常安全”，我们先来温习一下概念：异常安全是指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态。</p><p>我们看看可能会出现错误/异常的地方：</p><ul>\n<li>\n<p>首先是内存分配。如果 <code>new</code> 出错，按照 C++ 的规则，一般会得到异常 <code>bad_alloc</code>，对象的构造也就失败了。这种情况下，在 <code>catch</code> 捕捉到这个异常之前，所有的栈上对象会全部被析构，资源全部被自动清理。</p>\n</li>\n<li>\n<p>如果是矩阵的长宽不合适不能做乘法呢？我们同样会得到一个异常，这样，在使用乘法的地方，对象 <code>c</code> 根本不会被构造出来。</p>\n</li>\n<li>\n<p>如果在乘法函数里内存分配失败呢？一样，<code>result</code> 对象根本没有构造出来，也就没有 <code>c</code> 对象了。还是一切正常。</p>\n</li>\n<li>\n<p>如果 <code>a</code>、<code>b</code> 是本地变量，然后乘法失败了呢？析构函数会自动释放其空间，我们同样不会有任何资源泄漏。</p>\n</li>\n</ul><p>总而言之，只要我们适当地组织好代码、利用好 RAII，实现矩阵的代码和使用矩阵的代码都可以更短、更清晰。我们可以统一在外层某个地方处理异常——通常会记日志、或在界面上向用户报告错误了。</p><h2>避免异常的风格指南？</h2><p>但大名鼎鼎的 Google 的 C++ 风格指南不是说要避免异常吗 <span class=\"orange\">[1]</span>？这又是怎么回事呢？</p><p>答案实际已经在 Google 的文档里了：</p><blockquote>\n<p>Given that Google’s existing code is not exception-tolerant, the costs of using exceptions are somewhat greater than the costs in a new project. The conversion process would be slow and error-prone. We don’t believe that the available alternatives to exceptions, such as error codes and assertions, introduce a significant burden.</p>\n<p>Our advice against using exceptions is not predicated on philosophical or moral grounds, but practical ones. Because we’d like to use our open-source projects at Google and it’s difficult to do so if those projects use exceptions, we need to advise against exceptions in Google open-source projects as well. Things would probably be different if we had to do it all over again from scratch.</p>\n</blockquote><p>我来翻译一下（我的加重）：</p><blockquote>\n<p>鉴于 Google 的现有代码不能承受异常，<strong>使用异常的代价要比在全新的项目中使用异常大一些</strong>。转换[代码来使用异常的]过程会缓慢而容易出错。我们不认为可代替异常的方法，如错误码或断言，会带来明显的负担。</p>\n<p>我们反对异常的建议并非出于哲学或道德的立场，而是出于实际考虑。因为我们希望在 Google 使用我们的开源项目，而如果这些项目使用异常的话就会对我们的使用带来困难，我们也需要反对在 Google 的开源项目中使用异常。<strong>如果我们从头再来一次的话，事情可能就会不一样了。</strong></p>\n</blockquote><p>这个如果还比较官方、委婉的话，Reddit 上还能找到一个更个人化的表述 <span class=\"orange\">[2]</span>：</p><blockquote>\n<p>I use [<em>sic</em>] to work at Google, and Craig Silverstein, who wrote the first draft of the style guideline, said that he regretted the ban on exceptions, but he had no choice; when he wrote it, it wasn’t only that the compiler they had at the time did a very bad job on exceptions, but that they already had a huge volume of non-exception-safe code.</p>\n</blockquote><p>我的翻译（同样，我的加重）：</p><blockquote>\n<p>我过去在 Google 工作，写了风格指南初稿的 Craig Silverstein 说过<strong>他对禁用异常感到遗憾</strong>，但他当时别无选择。在他写风格指南的时候，不仅<strong>他们使用的编译器在异常上工作得很糟糕</strong>，而且<strong>他们已经有了一大堆异常不安全的代码了</strong>。</p>\n</blockquote><p>当然，除了历史原因以外，也有出于性能等其他原因禁用异常的。美国国防部的联合攻击战斗机（JSF）项目的 C++ 编码规范就禁用异常，因为工具链不能保证抛出异常时的实时性能。不过在那种项目里，被禁用的 C++ 特性就多了，比如动态内存分配都不能使用。</p><p>一些游戏项目为了追求高性能，也禁用异常。这个实际上也有一定的历史原因，因为今天的主流 C++ 编译器，在异常关闭和开启时应该已经能够产生性能差不多的代码（在异常未抛出时）。代价是产生的二进制文件大小的增加，因为异常产生的位置决定了需要如何做栈展开，这些数据需要存储在表里。典型情况，使用异常和不使用异常比，二进制文件大小会有约百分之十到二十的上升。LLVM 项目的编码规范里就明确指出这是不使用 RTTI 和异常的原因 <span class=\"orange\">[3]</span>：</p><blockquote>\n<p>In an effort to reduce code and executable size, LLVM does not use RTTI (e.g. <code>dynamic_cast&lt;&gt;;</code>) or exceptions.</p>\n</blockquote><p>我默默地瞅了眼我机器上 88MB 大小的单个 clang-9 可执行文件，对 Chris Lattner 的决定至少表示理解。但如果想跟这种项目比，你得想想是否值得这么去做。你的项目对二进制文件的大小和性能有这么渴求吗？需要这么去拼吗？</p><h2>异常的问题</h2><p>异常当然不是一个完美的特性，否则也不会招来这些批评和禁用了。对它的批评主要有两条：</p><ul>\n<li>异常违反了“你不用就不需要付出代价”的 C++ 原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀。</li>\n<li>异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常。</li>\n</ul><p>对于第一条，开发者没有什么可做的。事实上，这也算是 C++ 实现的一个折中了。目前的主流异常实现中，都倾向于牺牲可执行文件大小、提高主流程（happy path）的性能。只要程序不抛异常，C++ 代码的性能比起完全不做错误检查的代码，都只有几个百分点的性能损失 <span class=\"orange\">[4]</span>。除了非常有限的一些场景，可执行文件大小通常不会是个问题。</p><p>第二条可以算作是一个真正有效的批评。和 Java 不同，C++ 里不会对异常规约进行编译时的检查。从 C++17 开始，C++ 甚至完全禁止了以往的动态异常规约，你不再能在函数声明里写你可能会抛出某某异常。你唯一能声明的，就是某函数不会抛出异常——<code>noexcept</code>、<code>noexcept(true)</code> 或 <code>throw()</code>。这也是 C++ 的运行时唯一会检查的东西了。如果一个函数声明了不会抛出异常、结果却抛出了异常，C++ 运行时会调用 <code>std::terminate</code> 来终止应用程序。不管是程序员的声明，还是编译器的检查，都不会告诉你哪些函数会抛出哪些异常。</p><p>当然，不声明异常是有理由的。特别是在泛型编程的代码里，几乎不可能预知会发生些什么异常。我个人对避免异常带来的问题有几点建议：</p><ol>\n<li>写异常安全的代码，尤其在模板里。可能的话，提供强异常安全保证 <span class=\"orange\">[5]</span>，在任何第三方代码发生异常的情况下，不改变对象的内容，也不产生任何资源泄漏。</li>\n<li>如果你的代码可能抛出异常的话，在文档里明确声明可能发生的异常类型和发生条件。确保使用你的代码的人，能在不检查你的实现的情况下，了解需要准备处理哪些异常。</li>\n<li>对于肯定不会抛出异常的代码，将其标为 <code>noexcept</code>。尤其是，移动构造函数、移动赋值运算符和 <code>swap</code> 函数一般需要保证不抛异常并标为 <code>noexcept</code>（析构函数通常不抛异常且自动默认为 <code>noexcept</code>，不需要标）。</li>\n</ol><h2>使用异常的理由</h2><p>虽然后面我们会描述到一些不使用异常、也不使用错误返回码的错误处理方式，但异常是渗透在 C++ 中的标准错误处理方式。标准库的错误处理方式就是异常。其中不仅包括运行时错误，甚至包括一些逻辑错误。比如，在说容器的时候，有一个我没提的地方是，在能使用 <code>[]</code> 运算符的地方，C++ 的标准容器也提供了 <code>at</code> 成员函数，能够在下标不存在的时候抛出异常，作为一种额外的帮助调试的手段。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;   // std::cout/endl\n#include &lt;stdexcept&gt;  // std::out_of_range\n#include &lt;vector&gt;     // std::vector\nusing namespace std;\n</code></pre><pre><code class=\"language-c++\">vector&lt;int&gt; v{1, 2, 3};\n</code></pre><pre><code class=\"language-c++\">v[0]\n</code></pre><blockquote>\n<p><code>1</code></p>\n</blockquote><pre><code class=\"language-c++\">v.at(0)\n</code></pre><blockquote>\n<p><code>1</code></p>\n</blockquote><pre><code class=\"language-c++\">v[3]\n</code></pre><blockquote>\n<p><code>-1342175236</code></p>\n</blockquote><pre><code class=\"language-c++\">try {\n  v.at(3);\n}\ncatch (const out_of_range&amp; e) {\n  cerr &lt;&lt; e.what() &lt;&lt; endl;\n}\n</code></pre><blockquote>\n<p><code>_M_range_check: __n (which is 3) &gt;= this-&gt;size() (which is 3)</code></p>\n</blockquote><p>C++ 的标准容器在大部分情况下提供了强异常保证，即，一旦异常发生，现场会恢复到调用函数之前的状态，容器的内容不会发生改变，也没有任何资源泄漏。前面提到过，<code>vector</code> 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数。这是因为一旦某个操作发生了异常，被移动的元素已经被破坏，处于只能析构的状态，异常安全性就不能得到保证了。</p><p>只要你使用了标准容器，不管你自己用不用异常，你都得处理标准容器可能引发的异常——至少有 <code>bad_alloc</code>，除非你明确知道你的目标运行环境不会产生这个异常。这对普通配置的 Linux 环境而言，倒确实是对的……这也算是 Google 这么规定的一个底气吧。</p><p>虽然对于运行时错误，开发者并没有什么选择余地；但对于代码中的逻辑错误，开发者则是可以选择不同的处理方式的：你可以使用异常，也可以使用 <code>assert</code>，在调试环境中报告错误并中断程序运行。由于测试通常不能覆盖所有的代码和分支，<code>assert</code> 在发布模式下一般被禁用，两者并不是完全的替代关系。在允许异常的情况下，使用异常可以获得在调试和发布模式下都良好、一致的效果。</p><p>标准 C++ 可能会产生哪些异常，可以查看参考资料 <span class=\"orange\">[6]</span>。</p><h2>内容小结</h2><p>今天我们讨论了使用异常的理由和不使用异常的理由。希望通过本讲，你能够充分理解为什么异常是 C++ 委员会和很多大拿推荐的错误处理方式，并在可以使用异常的地方正确地使用异常这一方便的错误处理机制。</p><p>如果你还想进一步深入了解异常的话，可以仔细阅读一下参考资料 <span class=\"orange\">[4]</span>。</p><h2>课后思考</h2><p>你的 C++ 项目里使用异常吗？为什么？</p><p>欢迎留言和我交流你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Google, “Google C++ style guide”. <a href=\"https://google.github.io/styleguide/cppguide.html#Exceptions\">https://google.github.io/styleguide/cppguide.html#Exceptions</a> </span></p><p><span class=\"reference\">[2] Reddit, Discussion on “Examples of C++ projects which embrace exceptions?”. <a href=\"https://www.reddit.com/r/cpp/comments/4wkkge/examples_of_c_projects_which_embrace_exceptions/\">https://www.reddit.com/r/cpp/comments/4wkkge/examples_of_c_projects_which_embrace_exceptions/</a> </span></p><p><span class=\"reference\">[3] LLVM Project, “LLVM coding standards”. <a href=\"https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions\">https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions</a> </span></p><p><span class=\"reference\">[4] Standard C++ Foundation, “FAQ—exceptions and error handling”. <a href=\"https://isocpp.org/wiki/faq/exceptions\">https://isocpp.org/wiki/faq/exceptions</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “Exceptions”. <a href=\"https://en.cppreference.com/w/cpp/language/exceptions\">https://en.cppreference.com/w/cpp/language/exceptions</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “异常”. <a href=\"https://zh.cppreference.com/w/cpp/language/exceptions\">https://zh.cppreference.com/w/cpp/language/exceptions</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::exception”. <a href=\"https://en.cppreference.com/w/cpp/error/exception\">https://en.cppreference.com/w/cpp/error/exception</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::exception”. <a href=\"https://zh.cppreference.com/w/cpp/error/exception\">https://zh.cppreference.com/w/cpp/error/exception</a> </span></p>","neighbors":{"left":{"article_title":"05 | 容器汇编 II：需要函数对象的容器","id":174434},"right":{"article_title":"07 | 迭代器和好用的新for循环","id":176842}}},{"article_id":176842,"article_title":"07 | 迭代器和好用的新for循环","article_content":"<p>你好，我是吴咏炜。</p><p>我们已经讲过了容器。在使用容器的过程中，你也应该对迭代器（iterator）或多或少有了些了解。今天，我们就来系统地讲一下迭代器。</p><h2>什么是迭代器？</h2><p>迭代器是一个很通用的概念，并不是一个特定的类型。它实际上是一组对类型的要求（<span class=\"orange\">[1]</span>）。它的最基本要求就是从一个端点出发，下一步、下一步地到达另一个端点。按照一般的中文习惯，也许“遍历”是比“迭代”更好的用词。我们可以遍历一个字符串的字符，遍历一个文件的内容，遍历目录里的所有文件，等等。这些都可以用迭代器来表达。</p><p>我在用 output_container.h 输出容器内容的时候，实际上就对容器的 <code>begin</code> 和 <code>end</code> 成员函数返回的对象类型提出了要求。假设前者返回的类型是 I，后者返回的类型是 S，这些要求是：</p><ul>\n<li>I 对象支持 <code>*</code> 操作，解引用取得容器内的某个对象。</li>\n<li>I 对象支持 <code>++</code>，指向下一个对象。</li>\n<li>I 对象可以和 I 或 S 对象进行相等比较，判断是否遍历到了特定位置（在 S 的情况下是是否结束了遍历）。</li>\n</ul><p>注意在 C++17 之前，<code>begin</code> 和 <code>end</code> 返回的类型 I 和 S 必须是相同的。从 C++17 开始，I 和 S 可以是不同的类型。这带来了更大的灵活性和更多的优化可能性。</p><p>上面的类型 I，多多少少就是一个满足输入迭代器（input iterator）的类型了。不过，output_container.h 只使用了前置 <code>++</code>，但输入迭代器要求前置和后置 <code>++</code> 都得到支持。</p><!-- [[[read_end]]] --><p>输入迭代器不要求对同一迭代器可以多次使用 <code>*</code> 运算符，也不要求可以保存迭代器来重新遍历对象，换句话说，只要求可以单次访问。如果取消这些限制、允许多次访问的话，那迭代器同时满足了前向迭代器（forward iterator）。</p><p>一个前向迭代器的类型，如果同时支持 <code>--</code>（前置及后置），回到前一个对象，那它就是个双向迭代器（bidirectional iterator）。也就是说，可以正向遍历，也可以反向遍历。</p><p>一个双向迭代器，如果额外支持在整数类型上的 <code>+</code>、<code>-</code>、<code>+=</code>、<code>-=</code>，跳跃式地移动迭代器；支持 <code>[]</code>，数组式的下标访问；支持迭代器的大小比较（之前只要求相等比较）；那它就是个随机访问迭代器（random-access iterator）。</p><p>一个随机访问迭代器 <code>i</code> 和一个整数 <code>n</code>，在 <code>*i</code> 可解引用且 <code>i + n</code> 是合法迭代器的前提下，如果额外还满足 <code>*(addressdof(*i) + n)</code> 等价于 <code>*(i + n)</code>，即保证迭代器指向的对象在内存里是连续存放的，那它（在 C++20 里）就是个连续迭代器（contiguous iterator）。</p><p>以上这些迭代器只考虑了读取。如果一个类型像输入迭代器，但 <code>*i</code> 只能作为左值来写而不能读，那它就是个输出迭代器（output iterator）。</p><p>而比输入迭代器和输出迭代器更底层的概念，就是迭代器了。基本要求是：</p><ul>\n<li>对象可以被拷贝构造、拷贝赋值和析构。</li>\n<li>对象支持 <code>*</code> 运算符。</li>\n<li>对象支持前置 <code>++</code> 运算符。</li>\n</ul><p>迭代器类型的关系可从下图中全部看到：</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/5a/dd25c3f074fe0b792dddecfd15f74e5a.png\" alt=\"\"></p><p>迭代器通常是对象。但需要注意的是，指针可以满足上面所有的迭代器要求，因而也是迭代器。这应该并不让人惊讶，因为本来迭代器就是根据指针的特性，对其进行抽象的结果。事实上，<code>vector</code> 的迭代器，在很多实现里就直接是使用指针的。</p><h2>常用迭代器</h2><p>最常用的迭代器就是容器的 <code>iterator</code> 类型了。以我们学过的顺序容器为例，它们都定义了嵌套的 <code>iterator</code> 类型和 <code>const_iterator</code> 类型。一般而言，<code>iterator</code> 可写入，<code>const_iterator</code> 类型不可写入，但这些迭代器都被定义为输入迭代器或其派生类型：</p><ul>\n<li><code>vector::iterator</code> 和 <code>array::iterator</code> 可以满足到连续迭代器。</li>\n<li><code>deque::iterator</code> 可以满足到随机访问迭代器（记得它的内存只有部分连续）。</li>\n<li><code>list::iterator</code> 可以满足到双向迭代器（链表不能快速跳转）。</li>\n<li><code>forward_list::iterator</code> 可以满足到前向迭代器（单向链表不能反向遍历）。</li>\n</ul><p>很常见的一个输出迭代器是 <code>back_inserter</code> 返回的类型 <code>back_inserter_iterator</code> 了；用它我们可以很方便地在容器的尾部进行插入操作。另外一个常见的输出迭代器是 <code>ostream_iterator</code>，方便我们把容器内容“拷贝”到一个输出流。示例如下：</p><pre><code class=\"language-c++\">#include &lt;algorithm&gt;  // std::copy\n#include &lt;iterator&gt;   // std::back_inserter\n#include &lt;vector&gt;     // std::vector\nusing namespace std;\n</code></pre><pre><code class=\"language-c++\">vector&lt;int&gt; v1{1, 2, 3, 4, 5};\nvector&lt;int&gt; v2;\ncopy(v1.begin(), v1.end(),\n     back_inserter(v2));\n</code></pre><pre><code class=\"language-c++\">v2\n</code></pre><blockquote>\n<p><code>{ 1, 2, 3, 4, 5 }</code></p>\n</blockquote><pre><code class=\"language-c++\">#include &lt;iostream&gt;  // std::cout\ncopy(v2.begin(), v2.end(),\n     ostream_iterator&lt;int&gt;(cout, \" \"));\n</code></pre><blockquote>\n<p><code>1 2 3 4 5</code></p>\n</blockquote><h2>使用输入行迭代器</h2><p>下面我们来看一下一个我写的输入迭代器。它的功能本身很简单，就是把一个输入流（<code>istream</code>）的内容一行行读进来。配上 C++11 引入的基于范围的 for 循环的语法，我们可以把遍历输入流的代码以一种自然、非过程式的方式写出来，如下所示：</p><pre><code class=\"language-c++\">for (const string&amp; line :\n     istream_line_reader(is)) {\n  // 示例循环体中仅进行简单输出\n  cout &lt;&lt; line &lt;&lt; endl;\n}\n</code></pre><p>我们可以对比一下以传统的方式写的 C++ 代码，其中需要照顾不少细节：</p><pre><code class=\"language-c++\">string line;\nfor (;;) {\n  getline(is, line);\n  if (!is) {\n    break;\n  }\n  cout &lt;&lt; line &lt;&lt; endl;\n}\n</code></pre><p>从 <code>is</code> 读入输入行的逻辑，在前面的代码里一个语句就全部搞定了，在这儿用了 5 个语句……</p><p>我们后面会分析一下这个输入迭代器。在此之前，我先解说一下基于范围的 for 循环这个语法。虽然这可以说是个语法糖，但它对提高代码的可读性真的非常重要。如果不用这个语法糖的话，简洁性上的优势就小多了。我们直接把这个循环改写成等价的普通 for 循环的样子。</p><pre><code class=\"language-c++\">{\n  auto&amp;&amp; r = istream_line_reader(is);\n  auto it = r.begin();\n  auto end = r.end();\n  for (; it != end; ++it) {\n    const string&amp; line = *it;\n    cout &lt;&lt; line &lt;&lt; endl;\n  }\n}\n</code></pre><p>可以看到，它做的事情也不复杂，就是：</p><ul>\n<li>获取冒号后边的范围表达式的结果，并隐式产生一个引用，在整个循环期间都有效。注意根据生命期延长规则，表达式结果如果是临时对象的话，这个对象要在循环结束后才被销毁。</li>\n<li>自动生成遍历这个范围的迭代器。</li>\n<li>循环内自动生成根据冒号左边的声明和 <code>*it</code> 来进行初始化的语句。</li>\n<li>下面就是完全正常的循环体。</li>\n</ul><p>生成迭代器这一步有可能是——但不一定是——调用 <code>r</code> 的 <code>begin</code> 和 <code>end</code> 成员函数。具体规则是：</p><ul>\n<li>对于 C 数组（必须是没有退化为指针的情况），编译器会自动生成指向数组头尾的指针（相当于自动应用可用于数组的 <code>std::begin</code> 和 <code>std::end</code> 函数）。</li>\n<li>对于有 <code>begin</code> 和 <code>end</code> 成员的对象，编译器会调用其 <code>begin</code> 和 <code>end</code> 成员函数（我们目前的情况）。</li>\n<li>否则，编译器会尝试在 <code>r</code> 对象所在的名空间寻找可以用于 <code>r</code> 的 <code>begin</code> 和 <code>end</code> 函数，并调用 <code>begin(r)</code> 和 <code>end(r)</code>；找不到的话则失败报错。</li>\n</ul><h2>定义输入行迭代器</h2><p>下面我们看一下，要实现这个输入行迭代器，需要做些什么工作。</p><p>C++ 里有些固定的类型要求规范。对于一个迭代器，我们需要定义下面的类型：</p><pre><code class=\"language-c++\">class istream_line_reader {\npublic:\n  class iterator {  // 实现 InputIterator\n  public:\n    typedef ptrdiff_t difference_type;\n    typedef string value_type;\n    typedef const value_type* pointer;\n    typedef const value_type&amp; reference;\n    typedef input_iterator_tag\n      iterator_category;\n    …\n  };\n  …\n};\n</code></pre><p>仿照一般的容器，我们把迭代器定义为 <code>istream_line_reader</code> 的嵌套类。它里面的这五个类型是必须定义的（其他泛型 C++ 代码可能会用到这五个类型；之前标准库定义了一个可以继承的类模板 <code>std::iterator</code> 来产生这些类型定义，但这个类目前已经被废弃 <span class=\"orange\">[2]</span>）。其中：</p><ul>\n<li><code>difference_type</code> 是代表迭代器之间距离的类型，定义为 <code>ptrdiff_t</code> 只是种标准做法（指针间差值的类型），对这个类型没什么特别作用。</li>\n<li><code>value_type</code> 是迭代器指向的对象的值类型，我们使用 <code>string</code>，表示迭代器指向的是字符串。</li>\n<li><code>pointer</code> 是迭代器指向的对象的指针类型，这儿就平淡无奇地定义为 <code>value_type</code> 的常指针了（我们可不希望别人来更改指针指向的内容）。</li>\n<li>类似的，<code>reference</code> 是 <code>value_type</code> 的常引用。</li>\n<li><code>iterator_category</code> 被定义为 <code>input_iterator_tag</code>，标识这个迭代器的类型是 input iterator（输入迭代器）。</li>\n</ul><p>作为一个真的只能读一次的输入迭代器，有个特殊的麻烦（前向迭代器或其衍生类型没有）：到底应该让 <code>*</code> 负责读取还是 <code>++</code> 负责读取。我们这儿采用常见、也较为简单的做法，让 <code>++</code> 负责读取，<code>*</code> 负责返回读取的内容（这个做法会有些副作用，但按我们目前的用法则没有问题）。这样的话，这个 <code>iterator</code> 类需要有一个数据成员指向输入流，一个数据成员来存放读取的结果。根据这个思路，我们定义这个类的基本成员函数和数据成员：</p><pre><code class=\"language-c++\">class istream_line_reader {\npublic:\n  class iterator {\n    …\n    iterator() noexcept\n      : stream_(nullptr) {}\n    explicit iterator(istream&amp; is)\n      : stream_(&amp;is)\n    {\n      ++*this;\n    }\n\n    reference operator*() const noexcept\n    {\n      return line_;\n    }\n    pointer operator-&gt;() const noexcept\n    {\n      return &amp;line_;\n    }\n    iterator&amp; operator++()\n    {\n      getline(*stream_, line_);\n      if (!*stream_) {\n        stream_ = nullptr;\n      }\n      return *this;\n    }\n    iterator operator++(int)\n    {\n      iterator temp(*this);\n      ++*this;\n      return temp;\n    }\n\n  private:\n    istream* stream_;\n    string line_;\n  };\n  …\n};\n</code></pre><p>我们定义了默认构造函数，将 <code>stream_</code> 清空；相应的，在带参数的构造函数里，我们根据传入的输入流来设置 <code>stream_</code>。我们也定义了 <code>*</code> 和 <code>-&gt;</code> 运算符来取得迭代器指向的文本行的引用和指针，并用 <code>++</code> 来读取输入流的内容（后置 <code>++</code> 则以惯常方式使用前置 <code>++</code> 和拷贝构造来实现）。唯一“特别”点的地方，是我们在构造函数里调用了 <code>++</code>，确保在构造后调用 <code>*</code> 运算符时可以读取内容，符合日常先使用 <code>*</code>、再使用 <code>++</code> 的习惯。一旦文件读取到尾部（或出错），则 <code>stream_</code> 被清空，回到默认构造的情况。</p><p>对于迭代器之间的比较，我们则主要考虑文件有没有读到尾部的情况，简单定义为：</p><pre><code class=\"language-c++\">    bool operator==(const iterator&amp; rhs)\n      const noexcept\n    {\n      return stream_ == rhs.stream_;\n    }\n    bool operator!=(const iterator&amp; rhs)\n      const noexcept\n    {\n      return !operator==(rhs);\n    }\n</code></pre><p>有了这个 <code>iterator</code> 的定义后，<code>istream_line_reader</code> 的定义就简单得很了：</p><pre><code class=\"language-c++\">class istream_line_reader {\npublic:\n  class iterator {…};\n  istream_line_reader() noexcept\n    : stream_(nullptr) {}\n  explicit istream_line_reader(\n    istream&amp; is) noexcept\n    : stream_(&amp;is) {}\n  iterator begin()\n  {\n    return iterator(*stream_);\n  }\n  iterator end() const noexcept\n  {\n    return iterator();\n  }\n\nprivate:\n  istream* stream_;\n};\n</code></pre><p>也就是说，构造函数只是简单地把输入流的指针赋给 <code>stream_</code> 成员变量。<code>begin</code> 成员函数则负责构造一个真正有意义的迭代器；<code>end</code> 成员函数则只是返回一个默认构造的迭代器而已。</p><p>以上就是一个完整的基于输入流的行迭代器了。这个行输入模板的设计动机和性能测试结果可参见参考资料 <span class=\"orange\">[3]</span> 和 <span class=\"orange\">[4]</span>；完整的工程可用代码，请参见参考资料 <span class=\"orange\">[5]</span>。该项目中还提供了利用 C 文件接口的 file_line_reader 和基于内存映射文件的 mmap_line_reader。</p><h2>内容小结</h2><p>今天我们介绍了所有的迭代器类型，并介绍了基于范围的 for 循环。随后，我们介绍了一个实际的输入迭代器工具，并用它来简化从输入流中读入文本行这一常见操作。最后，我们展示了这个输入迭代器的定义。</p><h2>课后思考</h2><p>请思考一下：</p><ol>\n<li>目前这个输入行迭代器的行为，在什么情况下可能导致意料之外的后果？</li>\n<li>请尝试一下改进这个输入行迭代器，看看能不能消除这种意外。如果可以，该怎么做？如果不可以，为什么？</li>\n</ol><p>欢迎留言和我交流你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Iterator library”. <a href=\"https://en.cppreference.com/w/cpp/iterator\">https://en.cppreference.com/w/cpp/iterator</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “迭代器库”. <a href=\"https://zh.cppreference.com/w/cpp/iterator\">https://zh.cppreference.com/w/cpp/iterator</a> </span></p><p><span class=\"reference\">[2] Jonathan Boccara, “std::iterator is deprecated: why, what it was, and what to use instead”. <a href=\"https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/\">https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/</a> </span></p><p><span class=\"reference\">[3] 吴咏炜, “Python <code>yield</code> and C++ coroutines”. <a href=\"https://yongweiwu.wordpress.com/2016/08/16/python-yield-and-cplusplus-coroutines/\">https://yongweiwu.wordpress.com/2016/08/16/python-yield-and-cplusplus-coroutines/</a> </span></p><p><span class=\"reference\">[4] 吴咏炜, “Performance of my line readers”. <a href=\"https://yongweiwu.wordpress.com/2016/11/12/performance-of-my-line-readers/\">https://yongweiwu.wordpress.com/2016/11/12/performance-of-my-line-readers/</a> </span></p><p><span class=\"reference\">[5] 吴咏炜, nvwa. <a href=\"https://github.com/adah1972/nvwa/\">https://github.com/adah1972/nvwa/</a> </span></p>","neighbors":{"left":{"article_title":"06 | 异常：用还是不用，这是个问题","id":175579},"right":{"article_title":"08 | 易用性改进 I：自动类型推断和初始化","id":176850}}},{"article_id":176850,"article_title":"08 | 易用性改进 I：自动类型推断和初始化","article_content":"<p>你好，我是吴咏炜。</p><p>在之前的几讲里，我们已经多多少少接触到了一些 C++11 以来增加的新特性。下面的两讲，我会重点讲一下现代 C++（C++11/14/17）带来的易用性改进。</p><p>就像我们 <a href=\"https://time.geekbang.org/column/article/169177\">[开篇词]</a> 中说的，我们主要是介绍 C++ 里好用的特性，而非让你死记规则。因此，这里讲到的内容，有时是一种简化的说法。对于日常使用，本讲介绍的应该能满足大部分的需求。对于复杂用法和边角情况，你可能还是需要查阅参考资料里的明细规则。</p><h2>自动类型推断</h2><p>如果要挑选 C++11 带来的最重大改变的话，自动类型推断肯定排名前三。如果只看易用性或表达能力的改进的话，那它就是“舍我其谁”的第一了。</p><h3>auto</h3><p>自动类型推断，顾名思义，就是编译器能够根据表达式的类型，自动决定变量的类型（从 C++14 开始，还有函数的返回类型），不再需要程序员手工声明（<span class=\"orange\">[1]</span>）。但需要说明的是，<code>auto</code> 并没有改变 C++ 是静态类型语言这一事实——使用 <code>auto</code> 的变量（或函数返回值）的类型仍然是编译时就确定了，只不过编译器能自动帮你填充而已。</p><p>自动类型推断使得像下面这样累赘的表达式成为历史：</p><pre><code class=\"language-c++\">// vector&lt;int&gt; v;\nfor (vector&lt;int&gt;::iterator\n       it = v.begin(),\n       end = v.end();\n     it != end; ++it) {\n  // 循环体\n}\n</code></pre><!-- [[[read_end]]] --><p>现在我们可以直接写（当然，是不使用基于范围的 for 循环的情况）：</p><pre><code class=\"language-c++\">for (auto it = v.begin(), end = v.end();\n     it != end; ++it) {\n  // 循环体\n}\n</code></pre><p>不使用自动类型推断时，如果容器类型未知的话，我们还需要加上 <code>typename</code>（注意此处 const 引用还要求我们写 <code>const_iterator</code> 作为迭代器的类型）：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nvoid foo(const T&amp; container)\n{\n  for (typename T::const_iterator\n         it = v.begin(),\n    …\n}\n</code></pre><p>如果 <code>begin</code> 返回的类型不是该类型的 <code>const_iterator</code> 嵌套类型的话，那实际上不用自动类型推断就没法表达了。这还真不是假设。比如，如果我们的遍历函数要求支持 C 数组的话，不用自动类型推断的话，就只能使用两个不同的重载：</p><pre><code class=\"language-c++\">template &lt;typename T, std::size_t N&gt;\nvoid foo(const T (&amp;a)[N])\n{\n  typedef const T* ptr_t;\n  for (ptr_t it = a, end = a + N;\n       it != end; ++it) {\n    // 循环体\n  }\n}\n\ntemplate &lt;typename T&gt;\nvoid foo(const T&amp; c)\n{\n  for (typename T::const_iterator\n         it = c.begin(),\n         end = c.end();\n       it != end; ++it) {\n    // 循环体\n  }\n}\n</code></pre><p>如果使用自动类型推断的话，再加上 C++11 提供的全局 <code>begin</code> 和 <code>end</code> 函数，上面的代码可以统一成：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nvoid foo(const T&amp; c)\n{\n  using std::begin;\n  using std::end;\n  // 使用依赖参数查找（ADL）；见 <span class=\"orange\">[2]</span>\n  for (auto it = begin(c),\n       ite = end(c);\n       it != ite; ++it) {\n    // 循环体\n  }\n}\n</code></pre><p>从这个例子可见，自动类型推断不仅降低了代码的啰嗦程度，也提高了代码的抽象性，使我们可以用更少的代码写出通用的功能。</p><p><code>auto</code> 实际使用的规则类似于函数模板参数的推导规则（<span class=\"orange\">[3]</span>）。当你写了一个含 <code>auto</code> 的表达式时，相当于把 <code>auto</code> 替换为模板参数的结果。举具体的例子：</p><ul>\n<li><code>auto a = expr;</code> 意味着用 <code>expr</code> 去匹配一个假想的 <code>template &lt;typename T&gt; f(T)</code> 函数模板，结果为值类型。</li>\n<li><code>const auto&amp; a = expr;</code> 意味着用 <code>expr</code> 去匹配一个假想的 <code>template &lt;typename T&gt; f(const T&amp;)</code> 函数模板，结果为常左值引用类型。</li>\n<li><code>auto&amp;&amp; a = expr;</code> 意味着用 <code>expr</code> 去匹配一个假想的 <code>template &lt;typename T&gt; f(T&amp;&amp;)</code> 函数模板，根据<a href=\"https://time.geekbang.org/column/article/169268\">[第 3 讲]</a> 中我们讨论过的转发引用和引用坍缩规则，结果是一个跟 <code>expr</code> 值类别相同的引用类型。</li>\n</ul><h3>decltype</h3><p><code>decltype</code> 的用途是获得一个表达式的类型，结果可以跟类型一样使用。它有两个基本用法：</p><ul>\n<li><code>decltype(变量名)</code> 可以获得变量的精确类型。</li>\n<li><code>decltype(表达式)</code> （表达式不是变量名，但包括 <code>decltype((变量名))</code> 的情况）可以获得表达式的引用类型；除非表达式的结果是个纯右值（prvalue），此时结果仍然是值类型。</li>\n</ul><p>如果我们有 <code>int a;</code>，那么：</p><ul>\n<li><code>decltype(a)</code> 会获得 <code>int</code>（因为 <code>a</code> 是 <code>int</code>）。</li>\n<li><code>decltype((a))</code> 会获得 <code>int&amp;</code>（因为 <code>a</code> 是 lvalue）。</li>\n<li><code>decltype(a + a)</code> 会获得 <code>int</code>（因为 <code>a + a</code> 是 prvalue）。</li>\n</ul><h3>decltype(auto)</h3><p>通常情况下，能写 <code>auto</code> 来声明变量肯定是件比较轻松的事。但这儿有个限制，你需要在写下 <code>auto</code> 时就决定你写下的是个引用类型还是值类型。根据类型推导规则，<code>auto</code> 是值类型，<code>auto&amp;</code> 是左值引用类型，<code>auto&amp;&amp;</code> 是转发引用（可以是左值引用，也可以是右值引用）。使用 <code>auto</code> 不能通用地根据表达式类型来决定返回值的类型。不过，<code>decltype(expr)</code> 既可以是值类型，也可以是引用类型。因此，我们可以这么写：</p><pre><code class=\"language-c++\">decltype(expr) a = expr;\n</code></pre><p>这种写法明显不能让人满意，特别是表达式很长的情况（而且，任何代码重复都是潜在的问题）。为此，C++14 引入了 <code>decltype(auto)</code> 语法。对于上面的情况，我们只需要像下面这样写就行了。</p><pre><code class=\"language-c++\">decltype(auto) a = expr;\n</code></pre><p>这种代码主要用在通用的转发函数模板中：你可能根本不知道你调用的函数是不是会返回一个引用。这时使用这种语法就会方便很多。</p><h3>函数返回值类型推断</h3><p>从 C++14 开始，函数的返回值也可以用 <code>auto</code> 或 <code>decltype(auto)</code> 来声明了。同样的，用 <code>auto</code> 可以得到值类型，用 <code>auto&amp;</code> 或 <code>auto&amp;&amp;</code> 可以得到引用类型；而用 <code>decltype(auto)</code> 可以根据返回表达式通用地决定返回的是值类型还是引用类型。</p><p>和这个形式相关的有另外一个语法，后置返回值类型声明。严格来说，这不算“类型推断”，不过我们也放在一起讲吧。它的形式是这个样子：</p><pre><code class=\"language-c++\">auto foo(参数) -&gt; 返回值类型声明\n{\n  // 函数体\n}\n</code></pre><p>通常，在返回类型比较复杂、特别是返回类型跟参数类型有某种推导关系时会使用这种语法。以后我们会讲到一些实例。今天暂时不多讲了。</p><h3>类模板的模板参数推导</h3><p>如果你用过 <code>pair</code> 的话，一般都不会使用下面这种形式：</p><pre><code class=\"language-c++\">pair&lt;int, int&gt; pr{1, 42};\n</code></pre><p>使用 <code>make_pair</code> 显然更容易一些：</p><pre><code class=\"language-c++\">auto pr = make_pair(1, 42);\n</code></pre><p>这是因为函数模板有模板参数推导，使得调用者不必手工指定参数类型；但 C++17 之前的类模板却没有这个功能，也因而催生了像 <code>make_pair</code> 这样的工具函数。</p><p>在进入了 C++17 的世界后，这类函数变得不必要了。现在我们可以直接写：</p><pre><code class=\"language-c++\">pair pr{1, 42};\n</code></pre><p>生活一下子变得简单多了！</p><p>在初次见到 <code>array</code> 时，我觉得它的主要缺点就是不能像 C 数组一样自动从初始化列表来推断数组的大小了：</p><pre><code class=\"language-c++\">int a1[] = {1, 2, 3};\narray&lt;int, 3&gt; a2{1, 2, 3}; // 啰嗦\n// array&lt;int&gt; a3{1, 2, 3}; 不行\n</code></pre><p>这个问题在 C++17 里也是基本不存在的。虽然不能只提供一个模板参数，但你可以两个参数全都不写 🤣：</p><pre><code class=\"language-c++\">array a{1, 2, 3};\n// 得到 array&lt;int, 3&gt;\n</code></pre><p>这种自动推导机制，可以是编译器根据构造函数来自动生成：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nstruct MyObj {\n  MyObj(T value);\n  …\n};\n\nMyObj obj1{string(\"hello\")};\n// 得到 MyObj&lt;string&gt;\nMyObj obj2{\"hello\"};\n// 得到 MyObj&lt;const char*&gt;\n</code></pre><p>也可以是手工提供一个推导向导，达到自己需要的效果：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nstruct MyObj {\n  MyObj(T value);\n  …\n};\n\nMyObj(const char*) -&gt; MyObj&lt;string&gt;;\n\nMyObj obj{\"hello\"};\n// 得到 MyObj&lt;string&gt;\n</code></pre><p>更多的技术细节请参见参考资料 <span class=\"orange\">[4]</span>。</p><h3>结构化绑定</h3><p>在讲关联容器的时候我们有过这样一个例子：</p><pre><code class=\"language-c++\">multimap&lt;string, int&gt;::iterator\n  lower, upper;\nstd::tie(lower, upper) =\n  mmp.equal_range(\"four\");\n</code></pre><p>这个例子里，返回值是个 <code>pair</code>，我们希望用两个变量来接收数值，就不得不声明了两个变量，然后使用 <code>tie</code> 来接收结果。在 C++11/14 里，这里是没法使用 <code>auto</code> 的。好在 C++17 引入了一个新语法，解决了这个问题。目前，我们可以把上面的代码简化为：</p><pre><code class=\"language-c++\">auto [lower, upper] =\n  mmp.equal_range(\"four\");\n</code></pre><p>这个语法使得我们可以用 <code>auto</code> 声明变量来分别获取 <code>pair</code> 或 <code>tuple</code> 返回值里各个子项，可以让代码的可读性更好。</p><p>关于这个语法的更多技术说明，请参见参考资料 <span class=\"orange\">[5]</span>。</p><h2>列表初始化</h2><p>在 C++98 里，标准容器比起 C 风格数组至少有一个明显的劣势：不能在代码里方便地初始化容器的内容。比如，对于数组你可以写：</p><pre><code class=\"language-c++\">int a[] = {1, 2, 3, 4, 5};\n</code></pre><p>而对于 <code>vector</code> 你却得写：</p><pre><code class=\"language-c++\">vector&lt;int&gt; v;\nv.push(1);\nv.push(2);\nv.push(3);\nv.push(4);\nv.push(5);\n</code></pre><p>这样真是又啰嗦，性能又差，显然无法让人满意。于是，C++ 标准委员会引入了列表初始化，允许以更简单的方式来初始化对象。现在我们初始化容器也可以和初始化数组一样简单了：</p><pre><code class=\"language-c++\">vector&lt;int&gt; v{1, 2, 3, 4, 5};\n</code></pre><p>同样重要的是，这不是对标准库容器的特殊魔法，而是一个通用的、可以用于各种类的方法。从技术角度，编译器的魔法只是对 <code>{1, 2, 3}</code> 这样的表达式自动生成一个初始化列表，在这个例子里其类型是 <code>initializer_list&lt;int&gt;</code>。程序员只需要声明一个接受 <code>initializer_list</code> 的构造函数即可使用。从效率的角度，至少在动态对象的情况下，容器和数组也并无二致，都是通过拷贝（构造）进行初始化。</p><p>对于初始化列表在构造函数外的用法和更多的技术细节，请参见参考资料 <span class=\"orange\">[6]</span>。</p><h2>统一初始化</h2><p>你可能已经注意到了，我在代码里使用了大括号 <code>{}</code> 来进行对象的初始化。这当然也是 C++11 引入的新语法，能够代替很多小括号 <code>()</code> 在变量初始化时使用。这被称为统一初始化（uniform initialization）。</p><p>大括号对于构造一个对象而言，最大的好处是避免了 C++ 里“最令人恼火的语法分析”（the most vexing parse）。我也遇到过。假设你有一个类，原型如下：</p><pre><code class=\"language-c++\">class utf8_to_wstring {\npublic:\n  utf8_to_wstring(const char*);\n  operator wchar_t*();\n};\n</code></pre><p>然后你在 Windows 下想使用这个类来帮助转换文件名，打开文件：</p><pre><code class=\"language-c++\">ifstream ifs(\n  utf8_to_wstring(filename));\n</code></pre><p>你随后就会发现，<code>ifs</code> 的行为无论如何都不正常。最后，要么你自己查到，要么有人告诉你，上面这个写法会被编译器认为是和下面的写法等价的：</p><pre><code class=\"language-c++\">ifstream ifs(\n  utf8_to_wstring filename);\n</code></pre><p>换句话说，编译器认为你是声明了一个叫 <code>ifs</code> 的函数，而不是对象！</p><p>如果你把任何一对小括号替换成大括号（或者都替换，如下），则可以避免此类问题：</p><pre><code class=\"language-c++\">ifstream ifs{\n  utf8_to_wstring{filename}};\n</code></pre><p>推而广之，你几乎可以在所有初始化对象的地方使用大括号而不是小括号。它还有一个附带的特点：当一个构造函数没有标成 <code>explicit</code> 时，你可以使用大括号不写类名来进行构造，如果调用上下文要求那类对象的话。如：</p><pre><code class=\"language-c++\">Obj getObj()\n{\n  return {1.0};\n}\n</code></pre><p>如果 Obj 类可以使用浮点数进行构造的话，上面的写法就是合法的。如果有无参数、多参数的构造函数，也可以使用这个形式。除了形式上的区别，它跟 <code>Obj(1.0)</code> 的主要区别是，后者可以用来调用 <code>Obj(int)</code>，而使用大括号时编译器会拒绝“窄”转换，不接受以 <code>{1.0}</code> 或 <code>Obj{1.0}</code> 的形式调用构造函数 <code>Obj(int)</code>。</p><p>这个语法主要的限制是，如果一个类既有使用初始化列表的构造函数，又有不使用初始化列表的构造函数，那编译器会<strong>千方百计</strong>地试图调用使用初始化列表的构造函数，导致各种意外。所以，如果给一个推荐的话，那就是：</p><ul>\n<li>如果一个类没有使用初始化列表的构造函数时，初始化该类对象可全部使用统一初始化语法。</li>\n<li>如果一个类有使用初始化列表的构造函数时，则只应用在初始化列表构造的情况。</li>\n</ul><p>关于这个语法的更多详细用法讨论，请参见参考资料 <span class=\"orange\">[7]</span>。</p><h2>类数据成员的默认初始化</h2><p>按照 C++98 的语法，数据成员可以在构造函数里进行初始化。这本身不是问题，但实践中，如果数据成员比较多、构造函数又有多个的话，逐个去初始化是个累赘，并且很容易在增加数据成员时漏掉在某个构造函数中进行初始化。为此，C++11 增加了一个语法，允许在声明数据成员时直接给予一个初始化表达式。这样，当且仅当构造函数的初始化列表中不包含该数据成员时，这个数据成员就会自动使用初始化表达式进行初始化。</p><p>这个句子有点长。我们看个例子：</p><pre><code class=\"language-c++\">class Complex {\npublic:\n  Complex()\n    : re_(0) , im_(0) {}\n  Complex(float re)\n    : re_(re), im_(0) {}\n  Complex(float re, float im)\n    : re_(re) , im_(im) {}\n  …\n\nprivate:\n  float re_;\n  float im_;\n};\n</code></pre><p>假设由于某种原因，我们不能使用缺省参数来简化构造函数，我们可以用什么方式来优化上面这个代码呢？</p><p>使用数据成员的默认初始化的话，我们就可以这么写：</p><pre><code class=\"language-c++\">class Complex {\npublic:\n  Complex() {}\n  Complex(float re) : re_(re) {}\n  Complex(float re, float im)\n    : re_(re) , im_(im) {}\n\nprivate:\n  float re_{0};\n  float im_{0};\n};\n</code></pre><p>第一个构造函数没有任何初始化列表，所以类数据成员的初始化全部由默认初始化完成，<code>re_</code> 和 <code>im_</code> 都是 0。第二个构造函数提供了 <code>re_</code> 的初始化，<code>im_</code> 仍由默认初始化完成。第三个构造函数则完全不使用默认初始化。</p><h2>内容小结</h2><p>在本讲中，我们介绍了现代 C++ 引入的几个易用性改进：自动类型推断，初始化列表，及类数据成员的默认初始化。使用这些特性非常简单，可以立即简化你的 C++ 代码，而不会引入额外的开销。唯一的要求只是你不要再使用那些上古时代的老掉牙编译器了……</p><h2>课后思考</h2><p>你使用过现代 C++ 的这些特性了吗？如果还没有的话，哪些特性你打算在下一个项目里开始使用？</p><p>欢迎留言来分享你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Placeholder type specifiers”. <a href=\"https://en.cppreference.com/w/cpp/language/auto\">https://en.cppreference.com/w/cpp/language/auto</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “占位符类型说明符”. <a href=\"https://zh.cppreference.com/w/cpp/language/auto\">https://zh.cppreference.com/w/cpp/language/auto</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Argument-dependent name lookup”. <a href=\"https://en.wikipedia.org/wiki/Argument-dependent_name_lookup\">https://en.wikipedia.org/wiki/Argument-dependent_name_lookup</a> </span></p><p><span class=\"reference\">[2a] 维基百科, “依赖于实参的名字查找”. <a href=\"https://zh.wikipedia.org/zh-cn/%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%AE%9E%E5%8F%82%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE\">https://zh.wikipedia.org/zh-cn/依赖于实参的名字查找</a> </span></p><p><span class=\"reference\">[3] cppreference.com, “Template argument deduction”. <a href=\"https://en.cppreference.com/w/cpp/language/template_argument_deduction\">https://en.cppreference.com/w/cpp/language/template_argument_deduction</a> </span></p><p><span class=\"reference\">[3a] cppreference.com, “模板实参推导”. <a href=\"https://zh.cppreference.com/w/cpp/language/template_argument_deduction\">https://zh.cppreference.com/w/cpp/language/template_argument_deduction</a> </span></p><p><span class=\"reference\">[4] cppreference.com, “Class template argument deduction”. <a href=\"https://en.cppreference.com/w/cpp/language/class_template_argument_deduction\">https://en.cppreference.com/w/cpp/language/class_template_argument_deduction</a> </span></p><p><span class=\"reference\">[4a] cppreference.com, “类模板实参推导”. <a href=\"https://zh.cppreference.com/w/cpp/language/class_template_argument_deduction\">https://zh.cppreference.com/w/cpp/language/class_template_argument_deduction</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “Structured binding declaration”. <a href=\"https://en.cppreference.com/w/cpp/language/structured_binding\">https://en.cppreference.com/w/cpp/language/structured_binding</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “结构化绑定声明”. <a href=\"https://zh.cppreference.com/w/cpp/language/structured_binding\">https://zh.cppreference.com/w/cpp/language/structured_binding</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::initializer_list”. <a href=\"https://en.cppreference.com/w/cpp/utility/initializer_list\">https://en.cppreference.com/w/cpp/utility/initializer_list</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::initializer_list”. <a href=\"https://en.cppreference.com/w/cpp/utility/initializer_list\">https://en.cppreference.com/w/cpp/utility/initializer_list</a> </span></p><p><span class=\"reference\">[7] Scott Meyers, <em>Effective Modern C++</em>, item 7. O’Reilly Media, 2014. 有中文版（高博译，中国电力出版社，2018 年）</span></p>","neighbors":{"left":{"article_title":"07 | 迭代器和好用的新for循环","id":176842},"right":{"article_title":"09 | 易用性改进 II：字面量、静态断言和成员函数说明符","id":176916}}},{"article_id":176916,"article_title":"09 | 易用性改进 II：字面量、静态断言和成员函数说明符","article_content":"<p>你好，我是吴咏炜。</p><p>本讲我们继续易用性的话题，看看现代 C++ 带来的其他易用性改进。</p><h2>自定义字面量</h2><p>字面量（literal）是指在源代码中写出的固定常量，它们在 C++98 里只能是原生类型，如：</p><ul>\n<li><code>\"hello\"</code>，字符串字面量，类型是 <code>const char[6]</code></li>\n<li><code>1</code>，整数字面量，类型是 <code>int</code></li>\n<li><code>0.0</code>，浮点数字面量，类型是 <code>double</code></li>\n<li><code>3.14f</code>，浮点数字面量，类型是 <code>float</code></li>\n<li><code>123456789ul</code>，无符号长整数字面量，类型是 <code>unsigned long</code></li>\n</ul><p>C++11 引入了自定义字面量，可以使用 <code>operator\"\" 后缀</code> 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中加入了不少标准字面量。下面这个程序展示了它们的用法：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;complex&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nint main()\n{\n  cout &lt;&lt; \"i * i = \" &lt;&lt; 1i * 1i\n       &lt;&lt; endl;\n  cout &lt;&lt; \"Waiting for 500ms\"\n       &lt;&lt; endl;\n  this_thread::sleep_for(500ms);\n  cout &lt;&lt; \"Hello world\"s.substr(0, 5)\n       &lt;&lt; endl;\n}\n</code></pre><!-- [[[read_end]]] --><p>输出是：</p><blockquote>\n<p><code>i * i = (-1,0)</code><br>\n<code>Waiting for 500ms</code><br>\n<code>Hello</code></p>\n</blockquote><p>上面这个例子展示了 C++ 标准里提供的帮助生成虚数、时间和 <code>basic_string</code> 字面量的后缀。一个需要注意的地方是，我在上面使用了 <code>using namespace std</code>，这会同时引入 <code>std</code> 名空间和里面的内联名空间（inline namespace），包括了上面的字面量运算符所在的三个名空间：</p><ul>\n<li><code>std::literals::complex_literals</code></li>\n<li><code>std::literals::chrono_literals</code></li>\n<li><code>std::literals::string_literals</code></li>\n</ul><p>在产品项目中，一般不会（也不应该）全局使用 <code>using namespace std</code>（不过，为节约篇幅起见，专栏里的很多例子，特别是不完整的例子，还是默认使用了 <code>using namespace std</code>）。这种情况下，应当在使用到这些字面量的作用域里导入需要的名空间，以免发生冲突。在类似上面的例子里，就是在函数体的开头写：</p><pre><code class=\"language-c++\">using namespace std::literals::\n  chrono_literals;\n</code></pre><p>等等。</p><p>要在自己的类里支持字面量也相当容易，唯一的限制是非标准的字面量后缀必须以下划线 <code>_</code> 打头。比如，假如我们有下面的长度类：</p><pre><code class=\"language-c++\">struct length {\n  double value;\n  enum unit {\n    metre,\n    kilometre,\n    millimetre,\n    centimetre,\n    inch,\n    foot,\n    yard,\n    mile,\n  };\n  static constexpr double factors[] =\n    {1.0,    1000.0,  1e-3,\n     1e-2,   0.0254,  0.3048,\n     0.9144, 1609.344};\n  explicit length(double v,\n                  unit u = metre)\n  {\n    value = v * factors[u];\n  }\n};\n\nlength operator+(length lhs,\n                 length rhs)\n{\n  return length(lhs.value +\n                rhs.value);\n}\n\n// 可能有其他运算符\n</code></pre><p>我们可以手写 <code>length(1.0, length::metre)</code> 这样的表达式，但估计大部分开发人员都不愿意这么做吧。反过来，如果我们让开发人员这么写，大家应该还是基本乐意的：</p><pre><code class=\"language-c++\">1.0_m + 10.0_cm\n</code></pre><p>要允许上面这个表达式，我们只需要提供下面的运算符即可：</p><pre><code class=\"language-c++\">length operator\"\" _m(long double v)\n{\n  return length(v, length::metre);\n}\n\nlength operator\"\" _cm(long double v)\n{\n  return length(v, length::centimetre);\n}\n</code></pre><p>如果美国国家航空航天局采用了类似的系统的话，火星气候探测者号的事故也许就不会发生了 <span class=\"orange\">[1]</span>。当然，历史无法重来，而且 C++ 引入这样的语法已经是在事故发生之后十多年了……</p><p>关于自定义字面量的进一步技术细节，请参阅参考资料 <span class=\"orange\">[2]</span>。</p><h2>二进制字面量</h2><p>你一定知道 C++ 里有 <code>0x</code> 前缀，可以让开发人员直接写出像 <code>0xFF</code> 这样的十六进制字面量。另外一个目前使用得稍少的前缀就是 <code>0</code> 后面直接跟 0–7 的数字，表示八进制的字面量，在跟文件系统打交道的时候还会经常用到：有经验的 Unix 程序员可能会觉得 <code>chmod(path, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)</code> 并不比 <code>chmod(path, 0644)</code> 更为直观。从 C++14 开始，我们对于二进制也有了直接的字面量：</p><pre><code class=\"language-c++\">unsigned mask = 0b111000000;\n</code></pre><p>这在需要比特级操作等场合还是非常有用的。</p><p>不过，遗憾的是， I/O streams 里只有 <code>dec</code>、<code>hex</code>、<code>oct</code> 三个操纵器（manipulator），而没有 <code>bin</code>，因而输出一个二进制数不能像十进制、十六进制、八进制那么直接。一个间接方式是使用 <code>bitset</code>，但调用者需要手工指定二进制位数：</p><pre><code class=\"language-c++\">#include &lt;bitset&gt;\ncout &lt;&lt; bitset&lt;9&gt;(mask) &lt;&lt; endl;\n</code></pre><blockquote>\n<p><code>111000000</code></p>\n</blockquote><h2>数字分隔符</h2><p>数字长了之后，看清位数就变得麻烦了。有了二进制字面量，这个问题变得分外明显。C++14 开始，允许在数字型字面量中任意添加 <code>'</code> 来使其更可读。具体怎么添加，完全由程序员根据实际情况进行约定。某些常见的情况可能会是：</p><ul>\n<li>十进制数字使用三位的分隔，对应英文习惯的 thousand、million 等单位。</li>\n<li>十进制数字使用四位的分隔，对应中文习惯的万、亿等单位。</li>\n<li>十六进制数字使用两位或四位的分隔，对应字节或双字节。</li>\n<li>二进制数字使用三位的分隔，对应文件系统的权限分组。</li>\n<li>等等。</li>\n</ul><p>一些实际例子如下：</p><pre><code class=\"language-c++\">unsigned mask = 0b111'000'000;\nlong r_earth_equatorial = 6'378'137;\ndouble pi = 3.14159'26535'89793;\nconst unsigned magic = 0x44'42'47'4E;\n</code></pre><h2>静态断言</h2><p>C++98 的 <code>assert</code> 允许在运行时检查一个函数的前置条件是否成立。没有一种方法允许开发人员在编译的时候检查假设是否成立。比如，如果模板有个参数 <code>alignment</code>，表示对齐，那我们最好在编译时就检查 <code>alignment</code> 是不是二的整数次幂。之前人们用了一些模板技巧来达到这个目的，但输出的信息并不那么友善。比如，我之前使用的方法，会产生类似下面这样的输出：</p><p><img src=\"https://static001.geekbang.org/resource/image/59/a5/59fa97e766d6c363ae23546e211774a5.png\" alt=\"\"></p><p>能起作用，但不够直观。C++11 直接从语言层面提供了静态断言机制，不仅能输出更好的信息，而且适用性也更好，可以直接放在类的定义中，而不像之前用的特殊技巧只能放在函数体里。对于类似上面的情况，现在的输出是：</p><p><img src=\"https://static001.geekbang.org/resource/image/37/48/37c7f1703b6c2d09137ccf3a5065be48.png\" alt=\"\"></p><p>静态断言语法上非常简单，就是：</p><pre><code class=\"language-c++\">static_assert(编译期条件表达式,\n              可选输出信息);\n</code></pre><p>产生上面的示例错误信息的代码是：</p><pre><code class=\"language-c++\">static_assert((alignment &amp; (alignment - 1)) == 0,\n  \"Alignment must be power of two\");\n</code></pre><h2>default 和 delete 成员函数</h2><p>在类的定义时，C++ 有一些规则决定是否生成默认的特殊成员函数。这些特殊成员函数可能包括：</p><ul>\n<li>默认构造函数</li>\n<li>析构函数</li>\n<li>拷贝构造函数</li>\n<li>拷贝赋值函数</li>\n<li>移动构造函数</li>\n<li>移动赋值函数</li>\n</ul><p>生成这些特殊成员函数（或不生成）的规则比较复杂，感兴趣的话你可以查看参考资料 <span class=\"orange\">[3]</span>。每个特殊成员函数有几种不同的状态：</p><ul>\n<li>隐式声明还是用户声明</li>\n<li>默认提供还是用户提供</li>\n<li>正常状态还是删除状态</li>\n</ul><p>这三个状态是可组合的，虽然不是所有的组合都有效。隐式声明的必然是默认提供的；默认提供的才可能被删除；用户提供的也必然是用户声明的。</p><p>如果成员和父类没有特殊原因导致对象不可拷贝或移动，在用户不声明这些成员函数的情况下，编译器会自动产生这些成员函数，即隐式声明、默认提供、正常状态。有特殊成员、用户声明的话，情况就非常复杂了：</p><ul>\n<li>没有初始化的非静态 const 数据成员和引用类型数据成员会导致默认提供的默认构造函数被删除。</li>\n<li>非静态的 const 数据成员和引用类型数据成员会导致默认提供的拷贝构造函数、拷贝赋值函数、移动构造函数和移动赋值函数被删除。</li>\n<li>用户如果没有自己提供一个拷贝构造函数（必须形如 <code>Obj(Obj&amp;)</code> 或 <code>Obj(const Obj&amp;)</code>；不是模板），编译器会隐式声明一个。</li>\n<li>用户如果没有自己提供一个拷贝赋值函数（必须形如 <code>Obj&amp; operator=(Obj&amp;)</code> 或 <code>Obj&amp; operator=(const Obj&amp;)</code>；不是模板），编译器会隐式声明一个。</li>\n<li>用户如果自己声明了一个移动构造函数或移动赋值函数，则默认提供的拷贝构造函数和拷贝赋值函数被删除。</li>\n<li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。</li>\n<li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动构造函数和析构函数，编译器会隐式声明一个移动赋值函数。</li>\n<li>……</li>\n</ul><p>我不鼓励你去死记硬背这些规则，而是希望你在项目和测试中体会其缘由。我认为这些规则还相当合理，虽然有略偏保守之嫌。尤其是关于移动构造和赋值：只要用户声明了另外的特殊成员函数中的任何一个，编译器就不默认提供了。不过嘛，缺省慢点总比缺省不安全要好……</p><p>我们这儿主要要说的是，我们可以改变缺省行为，在编译器能默认提供特殊成员函数时将其删除，或在编译器不默认提供特殊成员函数时明确声明其需要默认提供（不过，要注意，即使用户要求默认提供，编译器也可能根据其他规则将特殊成员函数标为删除）。</p><p>还是举例子来说明一下。对于下面这样的类，编译器看到有用户提供的构造函数，就会不默认提供默认构造函数：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass my_array {\npublic:\n  my_array(size_t size);\n  …\nprivate:\n  T*     data_{nullptr};\n  size_t size_{0};\n};\n</code></pre><p>在没有默认初始化时，我们如果需要默认构造函数，就需要手工写一个，如：</p><pre><code class=\"language-c++\">  my_array()\n    : data_(nullptr)\n    , size_(0) {}\n</code></pre><p>可有了默认初始化之后，这个构造函数显然就不必要了，所以我们现在可以写：</p><pre><code class=\"language-c++\">  my_array() = default;\n</code></pre><p>再来一个反向的例子。我们<a href=\"https://time.geekbang.org/column/article/169225\">[第 1 讲]</a> 里的 <code>shape_wrapper</code>，它的复制行为是不安全的。我们可以像<a href=\"https://time.geekbang.org/column/article/169263\">[第 2 讲]</a> 里一样去改进它，但如果正常情况不需要复制行为、只是想防止其他开发人员误操作时，我们可以简单地在类的定义中加入：</p><pre><code class=\"language-c++\">class shape_wrapper {\n  …\n  shape_wrapper(\n    const shape_wrapper&amp;) = delete;\n  shape_wrapper&amp; operator=(\n    const shape_wrapper&amp;) = delete;\n  …\n};\n</code></pre><p>在 C++11 之前，我们可能会用在 <code>private</code> 段里声明这些成员函数的方法，来达到相似的目的。但目前这个语法效果更好，可以产生更明确的错误信息。另外，你可以注意一下，用户声明成删除也是一种声明，因此编译器不会提供默认版本的移动构造和移动赋值函数。</p><h2>override 和 final 说明符</h2><p><code>override</code> 和 <code>final</code> 是两个 C++11 引入的新说明符。它们不是关键词，仅在出现在函数声明尾部时起作用，不影响我们使用这两个词作变量名等其他用途。这两个说明符可以单个或组合使用，都是加在类成员函数声明的尾部。</p><p><code>override</code> 显式声明了成员函数是一个虚函数且覆盖了基类中的该函数。如果有 <code>override</code> 声明的函数不是虚函数，或基类中不存在这个虚函数，编译器会报告错误。这个说明符的主要作用有两个：</p><ul>\n<li>给开发人员更明确的提示，这个函数覆写了基类的成员函数；</li>\n<li>让编译器进行额外的检查，防止程序员由于拼写错误或代码改动没有让基类和派生类中的成员函数名称完全一致。</li>\n</ul><p><code>final</code> 则声明了成员函数是一个虚函数，且该虚函数不可在派生类中被覆盖。如果有一点没有得到满足的话，编译器就会报错。</p><p><code>final</code> 还有一个作用是标志某个类或结构不可被派生。同样，这时应将其放在被定义的类或结构名后面。</p><p>用法示意如下：</p><pre><code class=\"language-c++\">class A {\npublic:\n  virtual void foo();\n  virtual void bar();\n  void foobar();\n};\n\nclass B : public A {\npublic:\n  void foo() override; // OK\n  void bar() override final; // OK\n  //void foobar() override;\n  // 非虚函数不能 override\n};\n\nclass C final : public B {\npublic:\n  void foo() override; // OK\n  //void bar() override;\n  // final 函数不可 override\n};\n\nclass D : public C {\n  // 错误：final 类不可派生\n  …\n};\n</code></pre><h2>内容小结</h2><p>今天我们介绍了现代 C++ 引入的另外几个易用性改进：自定义字面量，二进制字面量，数字分隔符，静态断言，default 和 delete 成员函数，及 override 和 final。同上一讲介绍的易用性改进一样，这些新功能可以改进代码的可读性，同时也不会带来额外的开销。在任何有条件使用满足新 C++ 标准的编译器的项目中，都应该考虑使用这些新特性。</p><h2>课后思考</h2><p>你最喜欢的 C++ 易用性改进是什么？为什么？</p><p>欢迎留言和我分享你的看法！</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “<em>Mars Climate Orbiter</em>”. <a href=\"https://en.wikipedia.org/wiki/Mars_Climate_Orbiter\">https://en.wikipedia.org/wiki/Mars_Climate_Orbiter</a> </span></p><p><span class=\"reference\">[1a] 维基百科, “火星气候探测者号”. <a href=\"https://zh.wikipedia.org/zh-cn/%E7%81%AB%E6%98%9F%E6%B0%A3%E5%80%99%E6%8E%A2%E6%B8%AC%E8%80%85%E8%99%9F\">https://zh.wikipedia.org/zh-cn/火星氣候探測者號</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “User-defined literals”. <a href=\"https://en.cppreference.com/w/cpp/language/user_literal\">https://en.cppreference.com/w/cpp/language/user_literal</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “用户定义字面量”. <a href=\"https://zh.cppreference.com/w/cpp/language/user_literal\">https://zh.cppreference.com/w/cpp/language/user_literal</a> </span></p><p><span class=\"reference\">[3] cppreference.com, “Non-static member functions”, section “Special member functions”. <a href=\"https://en.cppreference.com/w/cpp/language/member_functions\">https://en.cppreference.com/w/cpp/language/member_functions</a> </span></p><p><span class=\"reference\">[3a] cppreference.com, “非静态成员函数”, “特殊成员函数”部分. <a href=\"https://zh.cppreference.com/w/cpp/language/member_functions\">https://zh.cppreference.com/w/cpp/language/member_functions</a> </span></p>","neighbors":{"left":{"article_title":"08 | 易用性改进 I：自动类型推断和初始化","id":176850},"right":{"article_title":"10 | 到底应不应该返回对象？","id":178940}}},{"article_id":178940,"article_title":"10 | 到底应不应该返回对象？","article_content":"<p>你好，我是吴咏炜。</p><p>前几讲里我们已经约略地提到了返回对象的问题，本讲里我们进一步展开这个话题，把返回对象这个问题讲深讲透。</p><h2>F.20</h2><p>《C++ 核心指南》的 F.20 这一条款是这么说的 <span class=\"orange\">[1]</span>：</p><blockquote>\n<p>F.20: For “out” output values, prefer return values to output parameters</p>\n</blockquote><p>翻译一下：</p><blockquote>\n<p>在函数输出数值时，尽量使用返回值而非输出参数</p>\n</blockquote><p>这条可能会让一些 C++ 老手感到惊讶——在 C++11 之前的实践里，我们完全是采用相反的做法的啊！</p><p>在解释 F.20 之前，我们先来看看我们之前的做法。</p><h3>调用者负责管理内存，接口负责生成</h3><p>一种常见的做法是，接口的调用者负责分配一个对象所需的内存并负责其生命周期，接口负责生成或修改该对象。这种做法意味着对象可以默认构造（甚至只是一个结构），代码一般使用错误码而非异常。</p><p>示例代码如下：</p><pre><code class=\"language-c++\">MyObj obj;\nec = initialize(&amp;obj);\n…\n</code></pre><p>这种做法和 C 是兼容的，很多程序员出于惯性也沿用了 C 的这种做法。一种略为 C++ 点的做法是使用引用代替指针，这样在上面的示例中就不需要使用 <code>&amp;</code> 运算符了；但这样只是语法略有区别，本质完全相同。如果对象有合理的析构函数的话，那这种做法的主要问题是啰嗦、难于组合。你需要写更多的代码行，使用更多的中间变量，也就更容易犯错误。</p><!-- [[[read_end]]] --><p>假如我们已有矩阵变量 $\\mathbf{A}$、$\\mathbf{B}$ 和 $\\mathbf{C}$，要执行一个操作</p><p>$$<br>\n\\mathbf{R} = \\mathbf{A} \\times \\mathbf{B} + \\mathbf{C}<br>\n$$</p><p>那在这种做法下代码大概会写成：</p><pre><code class=\"language-c++\">error_code_t add(\n  matrix* result,\n  const matrix&amp; lhs,\n  const matrix&amp; rhs);\nerror_code_t multiply(\n  matrix* result,\n  const matrix&amp; lhs,\n  const matrix&amp; rhs);\n…\n  error_code_t ec;\n  …\n  matrix temp;\n  ec = multiply(&amp;temp, a, b);\n  if (ec != SUCCESS) {\n    goto end;\n  }\n  matrix r;\n  ec = add(&amp;r, temp, c);\n  if (ec != SUCCESS) {\n    goto end;\n  }\n  …\nend:\n  // 返回 ec 或类似错误处理\n</code></pre><p>理论上该方法可以有一个变体，不使用返回值，而使用异常来表示错误。实践中，我从来没在实际系统中看到过这样的代码。</p><h3>接口负责对象的堆上生成和内存管理</h3><p>另外一种可能的做法是接口提供生成和销毁对象的函数，对象在堆上维护。<code>fopen</code> 和 <code>fclose</code> 就是这样的接口的实例。注意使用这种方法一般不推荐由接口生成对象，然后由调用者通过调用 <code>delete</code> 来释放。在某些环境里，比如 Windows 上使用不同的运行时库时，这样做会引发问题。</p><p>同样以上面的矩阵运算为例，代码大概就会写成这个样子：</p><pre><code class=\"language-c++\">matrix* add(\n  const matrix* lhs,\n  const matrix* rhs,\n  error_code_t* ec);\nmatrix* multiply(\n  const matrix* lhs,\n  const matrix* rhs,\n  error_code_t* ec);\nvoid deinitialize(matrix** mat);\n…\n  error_code_t ec;\n  …\n  matrix* temp = nullptr;\n  matrix* r = nullptr;\n  temp = multiply(a, b, &amp;ec);\n  if (!temp) {\n    goto end;\n  }\n  r = add(temp, c, &amp;ec);\n  if (!r) {\n    goto end;\n  }\n  …\nend:\n  if (temp) {\n    deinitialize(&amp;temp);\n  }\n  // 返回 ec 或类似错误处理\n</code></pre><p>可以注意到，虽然代码看似稍微自然了一点，但啰嗦程度却增加了，原因是正确的处理需要考虑到各种不同错误路径下的资源释放问题。这儿也没有使用异常，因为异常在这种表达下会产生内存泄漏，除非用上一堆 <code>try</code> 和 <code>catch</code>，但那样异常在表达简洁性上的优势就没有了，没有实际的好处。</p><p>不过，如果我们同时使用智能指针和异常的话，就可以得到一个还不错的变体。如果接口接受和返回的都是 <code>shared_ptr&lt;matrix&gt;</code>，那调用代码就简单了：</p><pre><code class=\"language-c++\">shared_ptr&lt;matrix&gt; add(\n  const shared_ptr&lt;matrix&gt;&amp; lhs,\n  const shared_ptr&lt;matrix&gt;&amp; rhs);\nshared_ptr&lt;matrix&gt; multiply(\n  const shared_ptr&lt;matrix&gt;&amp; lhs,\n  const shared_ptr&lt;matrix&gt;&amp; rhs);\n…\n  auto r = add(multiply(a, b), c);\n</code></pre><p>调用这些接口必须要使用 <code>shared_ptr</code>，这不能不说是一个限制。另外，对象永远是在堆上分配的，在很多场合，也会有一定的性能影响。</p><h3>接口直接返回对象</h3><p>最直接了当的代码，当然就是直接返回对象了。这回我们看实际可编译、运行的代码：</p><pre><code class=\"language-c++\">#include &lt;armadillo&gt;\n#include &lt;iostream&gt;\n\nusing arma::imat22;\nusing std::cout;\n\nint main()\n{\n  imat22 a{{1, 1}, {2, 2}};\n  imat22 b{{1, 0}, {0, 1}};\n  imat22 c{{2, 2}, {1, 1}};\n  imat22 r = a * b + c;\n  cout &lt;&lt; r;\n}\n</code></pre><p>这段代码使用了 Armadillo，一个利用现代 C++ 特性的开源线性代数库 <span class=\"orange\">[2]</span>。你可以看到代码非常简洁，完全表意（<code>imat22</code> 是元素类型为整数的大小固定为 2 x 2 的矩阵）。它有以下优点：</p><ul>\n<li>代码直观、容易理解。</li>\n<li>乘法和加法可以组合在一行里写出来，无需中间变量。</li>\n<li>性能也没有问题。实际执行中，没有复制发生，计算结果直接存放到了变量 <code>r</code> 上。更妙的是，因为矩阵大小是已知的，这儿不需要任何动态内存，所有对象及其数据全部存放在栈上。</li>\n</ul><p>Armadillo 是个比较复杂的库，我们就不以 Armadillo 的代码为例来进一步讲解了。我们可以用一个假想的 <code>matrix</code> 类来看看返回对象的代码是怎样编写的。</p><h2>如何返回一个对象？</h2><p>一个用来返回的对象，通常应当是可移动构造/赋值的，一般也同时是可拷贝构造/赋值的。如果这样一个对象同时又可以默认构造，我们就称其为一个半正则（semiregular）的对象。如果可能的话，我们应当尽量让我们的类满足半正则这个要求。</p><p>半正则意味着我们的 <code>matrix</code> 类提供下面的成员函数：</p><pre><code class=\"language-c++\">class matrix {\npublic:\n  // 普通构造\n  matrix(size_t rows, size_t cols);\n  // 半正则要求的构造\n  matrix();\n  matrix(const matrix&amp;);\n  matrix(matrix&amp;&amp;);\n  // 半正则要求的赋值\n  matrix&amp; operator=(const matrix&amp;);\n  matrix&amp; operator=(matrix&amp;&amp;);\n};\n</code></pre><p>我们先看一下在没有返回值优化的情况下 C++ 是怎样返回对象的。以矩阵乘法为例，代码应该像下面这样：</p><pre><code class=\"language-c++\">matrix operator*(const matrix&amp; lhs,\n                 const matrix&amp; rhs)\n{\n  if (lhs.cols() != rhs.rows()) {\n    throw runtime_error(\n      \"sizes mismatch\");\n  }\n  matrix result(lhs.rows(),\n                rhs.cols());\n  // 具体计算过程\n  return result;\n}\n</code></pre><p>注意对于一个本地变量，我们永远不应该返回其引用（或指针），不管是作为左值还是右值。从标准的角度，这会导致未定义行为（undefined behavior），从实际的角度，这样的对象一般放在栈上可以被调用者正常覆盖使用的部分，随便一个函数调用或变量定义就可能覆盖这个对象占据的内存。这还是这个对象的析构不做事情的情况：如果析构函数会释放内存或破坏数据的话，那你访问到的对象即使内存没有被覆盖，也早就不是有合法数据的对象了……</p><p>回到正题。我们需要回想起，在<a href=\"https://time.geekbang.org/column/article/169268\">[第 3 讲]</a> 里说过的，返回非引用类型的表达式结果是个纯右值（prvalue）。在执行 <code>auto r = …</code> 的时候，编译器会认为我们实际是在构造 <code>matrix r(…)</code>，而“…”部分是一个纯右值。因此编译器会首先试图匹配 <code>matrix(matrix&amp;&amp;)</code>，在没有时则试图匹配 <code>matrix(const matrix&amp;)</code>；也就是说，有移动支持时使用移动，没有移动支持时则拷贝。</p><h2>返回值优化（拷贝消除）</h2><p>我们再来看一个能显示生命期过程的对象的例子：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Can copy and move\nclass A {\npublic:\n  A() { cout &lt;&lt; \"Create A\\n\"; }\n  ~A() { cout &lt;&lt; \"Destroy A\\n\"; }\n  A(const A&amp;) { cout &lt;&lt; \"Copy A\\n\"; }\n  A(A&amp;&amp;) { cout &lt;&lt; \"Move A\\n\"; }\n};\n\nA getA_unnamed()\n{\n  return A();\n}\n\nint main()\n{\n  auto a = getA_unnamed();\n}\n</code></pre><p>如果你认为执行结果里应当有一行“Copy A”或“Move A”的话，你就忽视了返回值优化的威力了。即使完全关闭优化，三种主流编译器（GCC、Clang 和 MSVC）都只输出两行：</p><blockquote>\n<p><code>Create A</code><br>\n<code>Destroy A</code></p>\n</blockquote><p>我们把代码稍稍改一下：</p><pre><code class=\"language-c++\">A getA_named()\n{\n  A a;\n  return a;\n}\n\nint main()\n{\n  auto a = getA_named();\n}\n</code></pre><p>这回结果有了一点点小变化。虽然 GCC 和 Clang 的结果完全不变，但 MSVC 在非优化编译的情况下产生了不同的输出（优化编译——使用命令行参数 <code>/O1</code>、<code>/O2</code> 或 <code>/Ox</code>——则不变）：</p><blockquote>\n<p><code>Create A</code><br>\n<code>Move A</code><br>\n<code>Destroy A</code><br>\n<code>Destroy A</code></p>\n</blockquote><p>也就是说，返回内容被移动构造了。</p><p>我们继续变形一下：</p><pre><code class=\"language-c++\">#include &lt;stdlib.h&gt;\n\nA getA_duang()\n{\n  A a1;\n  A a2;\n  if (rand() &gt; 42) {\n    return a1;\n  } else {\n    return a2;\n  }\n}\n\nint main()\n{\n  auto a = getA_duang();\n}\n</code></pre><p>这回所有的编译器都被难倒了，输出是：</p><blockquote>\n<p><code>Create A</code><br>\n<code>Create A</code><br>\n<code>Move A</code><br>\n<code>Destroy A</code><br>\n<code>Destroy A</code><br>\n<code>Destroy A</code></p>\n</blockquote><p>关于返回值优化的实验我们就做到这里。下一步，我们试验一下把移动构造函数删除：</p><pre><code class=\"language-c++\">  // A(A&amp;&amp;) { cout &lt;&lt; \"Move A\\n\"; }\n</code></pre><p>我们可以立即看到“Copy A”出现在了结果输出中，说明目前结果变成拷贝构造了。</p><p>如果再进一步，把拷贝构造函数也删除呢（注：此时是标成 <code>= delete</code>，而不是简单注释掉——否则，就如我们在<a href=\"https://time.geekbang.org/column/article/176916\">[第 9 讲]</a> 讨论过的，编译器会默认提供拷贝构造和移动构造函数）？是不是上面的 <code>getA_unnamed</code>、<code>getA_named</code> 和 <code>getA_duang</code> 都不能工作了？</p><p>在 C++14 及之前确实是这样的。但从 C++17 开始，对于类似于 <code>getA_unnamed</code> 这样的情况，即使对象不可拷贝、不可移动，这个对象仍然是可以被返回的！C++17 要求对于这种情况，对象必须被直接构造在目标位置上，不经过任何拷贝或移动的步骤 <span class=\"orange\">[3]</span>。</p><h2>回到 F.20</h2><p>理解了 C++ 里的对返回值的处理和返回值优化之后，我们再回过头看一下 F.20 里陈述的理由的话，应该就显得很自然了：</p><blockquote>\n<p>A return value is self-documenting, whereas a <code>&amp;</code> could be either in-out or out-only and is liable to be misused.</p>\n<p>返回值是可以自我描述的；而 <code>&amp;</code> 参数既可能是输入输出，也可能是仅输出，且很容易被误用。</p>\n</blockquote><p>我想我对返回对象的可读性，已经给出了充足的例子。对于其是否有性能影响这一问题，也给出了充分的说明。</p><p>我们最后看一下 F.20 里描述的例外情况：</p><ul>\n<li>“对于非值类型，比如返回值可能是子对象的情况，使用 <code>unique_ptr</code> 或 <code>shared_ptr</code> 来返回对象。”也就是面向对象、工厂方法这样的情况，像<a href=\"https://time.geekbang.org/column/article/169225\">[第 1 讲]</a> 里给出的 <code>create_shape</code> 应该这样改造。</li>\n<li>“对于移动代价很高的对象，考虑将其分配在堆上，然后返回一个句柄（如 <code>unique_ptr</code>），或传递一个非 const 的目标对象的引用来填充（用作输出参数）。”也就是说不方便移动的，那就只能使用一个 RAII 对象来管理生命周期，或者老办法输出参数了。</li>\n<li>“要在一个内层循环里在多次函数调用中重用一个自带容量的对象：将其当作输入/输出参数并将其按引用传递。”这也是个需要继续使用老办法的情况。</li>\n</ul><h2>内容小结</h2><p>C++ 里已经对返回对象做了大量的优化，目前在函数里直接返回对象可以得到更可读、可组合的代码，同时在大部分情况下我们可以利用移动和返回值优化消除性能问题。</p><h2>课后思考</h2><p>请你考虑一下：</p><ol>\n<li>你的项目使用了返回对象了吗？如果没有的话，本讲内容有没有说服你？</li>\n<li>这讲里我们没有深入讨论赋值；请你思考一下，如果例子里改成赋值，会有什么样的变化？</li>\n</ol><p>欢迎留言和我交流你的想法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Bjarne Stroustrup and Herb Sutter (editors), “C++ core guidelines”, item F.20. <a href=\"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-out\">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-out</a> (非官方中文版可参见 <a href=\"https://github.com/lynnboy/CppCoreGuidelines-zh-CN\">https://github.com/lynnboy/CppCoreGuidelines-zh-CN</a>) </span></p><p><span class=\"reference\">[2] Conrad Sanderson and Ryan Curtin, Armadillo. <a href=\"http://arma.sourceforge.net/\">http://arma.sourceforge.net/</a> </span></p><p><span class=\"reference\">[3] cppreference.com, “Copy elision”. <a href=\"https://en.cppreference.com/w/cpp/language/copy_elision\">https://en.cppreference.com/w/cpp/language/copy_elision</a> </span></p><p><span class=\"reference\">[3a] cppreference.com, “复制消除”. <a href=\"https://zh.cppreference.com/w/cpp/language/copy_elision\">https://zh.cppreference.com/w/cpp/language/copy_elision</a> </span></p>","neighbors":{"left":{"article_title":"09 | 易用性改进 II：字面量、静态断言和成员函数说明符","id":176916},"right":{"article_title":"11 | Unicode：进入多文字支持的世界","id":179357}}},{"article_id":179357,"article_title":"11 | Unicode：进入多文字支持的世界","article_content":"<p>你好，我是吴咏炜。</p><p>这一讲我们来讲一个新话题，Unicode。我们会从编码的历史谈起，讨论编程中对中文和多语言的支持，然后重点看一下 C++ 中应该如何处理这些问题。</p><h2>一些历史</h2><p>ASCII <span class=\"orange\">[1]</span> 是一种创立于 1963 年的 7 位编码，用 0 到 127 之间的数值来代表最常用的字符，包含了控制字符（很多在今天已不再使用）、数字、大小写拉丁字母、空格和基本标点。它在编码上具有简单性，字母和数字的编码位置非常容易记忆（相比之下，设计 EBCDIC <span class=\"orange\">[2]</span> 的人感觉是脑子进了水，哦不，进了穿孔卡片了；难怪它和 IBM 的那些过时老古董一起已经几乎被人遗忘）。时至今日，ASCII 可以看作是字符编码的基础，主要的编码方式都保持着与 ASCII 的兼容性。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/35/cc7fb695569c7ea460c1b89fc7859735.gif\" alt=\"\"></p><p>ASCII 里只有基本的拉丁字母，它既没有带变音符的拉丁字母（如 é 和 ä ），也不支持像希腊字母（如 α、β、γ）、西里尔字母（如 Пушкин）这样的其他欧洲文字（也难怪，毕竟它是 American Standard Code for Information Interchange）。很多其他编码方式纷纷应运而生，包括 ISO 646 系列、ISO/IEC 8859 系列等等；大部分编码方式都是头 128 个字符与 ASCII 兼容，后 128 个字符是自己的扩展，总共最多是 256 个字符。每次只有一套方式可以生效，称之为一个代码页（code page）。这种做法，只能适用于文字相近、且字符数不多的国家。比如，下图表示了 ISO-8859-1（也称作 Latin-1）和后面的 Windows 扩展代码页 1252（下图中绿框部分为 Windows 的扩展），就只能适用于西欧国家。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/ab/95/ab06af7037bd09d229efbb693be42195.png\" alt=\"\"></p><p>最早的中文字符集标准是 1980 年的国标 GB2312 <span class=\"orange\">[3]</span>，其中收录了 6763 个常用汉字和 682 个其他符号。我们平时会用到编码 GB2312，其实更正确的名字是 EUC-CN <span class=\"orange\">[4]</span>，它是一种与 ASCII 兼容的编码方式。它用单字节表示 ASCII 字符而用双字节表示 GB2312 中的字符；由于 GB2312 中本身也含有 ASCII 中包含的字符，在使用中逐渐就形成了“半角”和“全角”的区别。</p><p>国标字符集后面又有扩展，这个扩展后的字符集就是 GBK <span class=\"orange\">[5]</span>，是中文版 Windows 使用的标准编码方式。GB2312 和 GBK 所占用的编码位置可以参看下面的图（由 John M. Długosz 为 Wikipedia 绘制）：</p><p><img src=\"https://static001.geekbang.org/resource/image/da/0f/da18e20f4a929399d63a467760657c0f.png\" alt=\"\"></p><p>图中 GBK/1 和 GBK/2 为 GB2312 中已经定义的区域，其他的则是后面添加的字符，总共定义了两万多个编码点，支持了绝大部分现代汉语中还在使用的字。</p><p>Unicode <span class=\"orange\">[6]</span> 作为一种统一编码的努力，诞生于八十年代末九十年代初，标准的第一版出版于 1991—1992 年。由于最初发明者的目标放得太低，只期望对活跃使用中的现代文字进行编码，他们认为 16 比特的“宽 ASCII”就够用了。这就导致了早期采纳 Unicode 的组织，特别是微软，在其操作系统和工具链中广泛采用了 16 比特的编码方式。在今天，微软的系统中宽字符类型 wchar_t 仍然是 16 位的，操作系统底层接口大量使用 16 位字符编码的 API，说到 Unicode 编码时仍然指的是 16 位的编码 UTF-16（这一不太正确的名字，跟中文 GBK 编码居然可以被叫做 ANSI 相比，实在是小巫见大巫了）。在微软以外的世界，Unicode 本身不作编码名称用，并且最主流的编码方式并不是 UTF-16，而是和 ASCII 全兼容的 UTF-8。</p><p>早期 Unicode 组织的另一个决定是不同语言里的同一个字符使用同一个编码点，来减少总编码点的数量。中日韩三国使用的汉字就这么被统一了：像“将”、“径”、“网”等字，每个字在 Unicode 中只占一个编码点。这对网页的字体选择也造成了不少麻烦，时至今日我们仍然可以看到这个问题 <span class=\"orange\">[7]</span>。不过这和我们的主题无关，就不再多费笔墨了。</p><h2>Unicode 简介</h2><p>Unicode 在今天已经大大超出了最初的目标。到 Unicode 12.1 为止，Unicode 已经包含了 137,994 个字符，囊括所有主要语言（使用中的和已经不再使用的），并包含了表情符号、数学符号等各种特殊字符。仍然要指出一下，Unicode 字符是根据含义来区分的，而非根据字形。除了前面提到过中日韩汉字没有分开，像斜体（italics）、小大写字母（small caps）等排版效果在 Unicode 里也没有独立的对应。不过，因为 Unicode 里包含了很多数学、物理等自然科学中使用的特殊符号，某些情况下你也可以找到对应的符号，可以用在聊天中耍酷，如 𝒷𝒶𝒹（但不适合严肃的排版）。</p><p>Unicode 的编码点是从 0x0 到 0x10FFFF，一共 1,114,112 个位置。一般用“U+”后面跟 16 进制的数值来表示一个 Unicode 字符，如 U+0020 表示空格，U+6C49 表示“汉”，U+1F600 表示“😀”，等等（不足四位的一般写四位）。</p><p>Unicode 字符的常见编码方式有：</p><ul>\n<li>UTF-32 <span class=\"orange\">[8]</span>：32 比特，是编码点的直接映射。</li>\n<li>UTF-16 <span class=\"orange\">[9]</span>：对于从 U+0000 到 U+FFFF 的字符，使用 16 比特的直接映射；对于大于 U+FFFF 的字符，使用 32 比特的特殊映射关系——在 Unicode 的 16 比特编码点中 0xD800–0xDFFF 是一段空隙，使得这种变长编码成为可能。在一个 UTF-16 的序列中，如果看到内容是 0xD800–0xDBFF，那这就是 32 比特编码的前 16 比特；如果看到内容是 0xDC00–0xDFFF，那这是 32 比特编码的后 16 比特；如果内容在 0xD800–0xDFFF 之外，那就是一个 16 比特的映射。</li>\n<li>UTF-8 <span class=\"orange\">[10]</span>：1 到 4 字节的变长编码。在一个合法的 UTF-8 的序列中，如果看到一个字节的最高位是 0，那就是一个单字节的 Unicode 字符；如果一个字节的最高两比特是 10，那这是一个 Unicode 字符在编码后的后续字节；否则，这就是一个 Unicode 字符在编码后的首字节，且最高位开始连续 1 的个数表示了这个字符按 UTF-8 的方式编码有几个字节。</li>\n</ul><p>在上面三种编码方式里，只有 UTF-8 完全保持了和 ASCII 的兼容性，目前得到了最广泛的使用。在我们下面讲具体编码方式之前，我们先看一下上面提到的三个字符在这三种方式下的编码结果：</p><ul>\n<li>UTF-32：U+0020 映射为 0x00000020，U+6C49 映射为 0x00006C49，U+1F600 映射为 0x0001F600。</li>\n<li>UTF-16：U+0020 映射为 0x0020，U+6C49 映射为 0x6C49，而 U+1F600 会映射为 0xD83D DE00。</li>\n<li>UTF-8：U+0020 映射为 0x20，U+6C49 映射为 0xE6 B1 89，而 U+1F600 会映射为 0xF0 9F 98 80。</li>\n</ul><p>Unicode 有好几种（上面还不是全部）不同的编码方式，上面的 16 比特和 32 比特编码方式还有小头党和大头党之争（“汉”按字节读取时是 6C 49 呢，还是 49 6C？）；同时，任何一种编码方式还需要跟传统的编码方式容易区分。因此，Unicode 文本文件通常有一个使用 BOM（byte order mark）字符的约定，即字符 U+FEFF <span class=\"orange\">[11]</span>。由于 Unicode 不使用 U+FFFE，在文件开头加一个 BOM 即可区分各种不同编码：</p><ul>\n<li>如果文件开头是 0x00 00 FE FF，那这是大头在前的 UTF-32 编码；</li>\n<li>否则如果文件开头是 0xFF FE 00 00，那这是小头在前的 UTF-32 编码；</li>\n<li>否则如果文件开头是 0xFE FF，那这是大头在前的 UTF-16 编码；</li>\n<li>否则如果文件开头是 0xFF FE，那这是小头在前的 UTF-16 编码（注意，这条规则和第二条的顺序不能相反）；</li>\n<li>否则如果文件开头是 0xEF BB BF，那这是 UTF-8 编码；</li>\n<li>否则，编码方式使用其他算法来确定。</li>\n</ul><p>编辑器可以（有些在配置之后）根据 BOM 字符来自动决定文本文件的编码。比如，我一般在 Vim 中配置 <code>set fileencodings=ucs-bom,utf-8,gbk,latin1</code>。这样，Vim 在读入文件时，会首先检查 BOM 字符，有 BOM 字符按 BOM 字符决定文件编码；否则，试图将文件按 UTF-8 来解码（由于 UTF-8 有格式要求，非 UTF-8 编码的文件通常会导致失败）；不行，则试图按 GBK 来解码（失败的概率就很低了）；还不行，就把文件当作 Latin1 来处理（永远不会失败）。</p><p>在 UTF-8 编码下使用 BOM 字符并非必需，尤其在 Unix 上。但 Windows 上通常会使用 BOM 字符，以方便区分 UTF-8 和传统编码。</p><h2>C++ 中的 Unicode 字符类型</h2><p>C++98 中有 <code>char</code> 和 <code>wchar_t</code> 两种不同的字符类型，其中 <code>char</code> 的长度是单字节，而 <code>wchar_t</code> 的长度不确定。在 Windows 上它是双字节，只能代表 UTF-16，而在 Unix 上一般是四字节，可以代表 UTF-32。为了解决这种混乱，目前我们有了下面的改进：</p><ul>\n<li>C++11 引入了 <code>char16_t</code> 和 <code>char32_t</code> 两个独立的字符类型（不是类型别名），分别代表 UTF-16 和 UTF-32。</li>\n<li>C++20 将引入 <code>char8_t</code> 类型，进一步区分了可能使用传统编码的窄字符类型和 UTF-8 字符类型。</li>\n<li>除了 <code>string</code> 和 <code>wstring</code>，我们也相应地有了 <code>u16string</code>、<code>u32string</code>（和将来的 <code>u8string</code>）。</li>\n<li>除了传统的窄字符/字符串字面量（如 <code>\"hi\"</code>）和宽字符/字符串字面量（如 <code>L\"hi\"</code>），引入了新的 UTF-8、UTF-16 和 UTF-32 字面量，分别形如 <code>u8\"hi\"</code>、<code>u\"hi\"</code> 和 <code>U\"hi\"</code>。</li>\n<li>为了确保非 ASCII 字符在源代码中可以简单地输入，引入了新的 Unicode 换码序列。比如，我们前面说到的三个字符可以这样表达成一个 UTF-32 字符串字面量：<code>U\" \\u6C49\\U0001F600\"</code>。要生成 UTF-16 或 UTF-8 字符串字面量只需要更改前缀即可。</li>\n</ul><p>使用这些新的字符（串）类型，我们可以用下面的代码表达出 UTF-32 和其他两种 UTF 编码间是如何转换的：</p><pre><code class=\"language-c++\">#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nconst char32_t unicode_max =\n  0x10FFFF;\n\nvoid to_utf_16(char32_t ch,\n               u16string&amp; result)\n{\n  if (ch &gt; unicode_max) {\n    throw runtime_error(\n      \"invalid code point\");\n  }\n  if (ch &lt; 0x10000) {\n    result += char16_t(ch);\n  } else {\n    char16_t first =\n      0xD800 |\n      ((ch - 0x10000) &gt;&gt; 10);\n    char16_t second =\n      0xDC00 | (ch &amp; 0x3FF);\n    result += first;\n    result += second;\n  }\n}\n\nvoid to_utf_8(char32_t ch,\n              string&amp; result)\n{\n  if (ch &gt; unicode_max) {\n    throw runtime_error(\n      \"invalid code point\");\n  }\n  if (ch &lt; 0x80) {\n    result += ch;\n  } else if (ch &lt; 0x800) {\n    result += 0xC0 | (ch &gt;&gt; 6);\n    result += 0x80 | (ch &amp; 0x3F);\n  } else if (ch &lt; 0x10000) {\n    result += 0xE0 | (ch &gt;&gt; 12);\n    result +=\n      0x80 | ((ch &gt;&gt; 6) &amp; 0x3F);\n    result += 0x80 | (ch &amp; 0x3F);\n  } else {\n    result += 0xF0 | (ch &gt;&gt; 18);\n    result +=\n      0x80 | ((ch &gt;&gt; 12) &amp; 0x3F);\n    result +=\n      0x80 | ((ch &gt;&gt; 6) &amp; 0x3F);\n    result += 0x80 | (ch &amp; 0x3F);\n  }\n}\n\nint main()\n{\n  char32_t str[] =\n    U\" \\u6C49\\U0001F600\";\n  u16string u16str;\n  string u8str;\n  for (auto ch : str) {\n    if (ch == 0) {\n      break;\n    }\n    to_utf_16(ch, u16str);\n    to_utf_8(ch, u8str);\n  }\n  cout &lt;&lt; hex &lt;&lt; setfill('0');\n  for (char16_t ch : u16str) {\n    cout &lt;&lt; setw(4) &lt;&lt; unsigned(ch)\n         &lt;&lt; ' ';\n  }\n  cout &lt;&lt; endl;\n  for (unsigned char ch : u8str) {\n    cout &lt;&lt; setw(2) &lt;&lt; unsigned(ch)\n         &lt;&lt; ' ';\n  }\n  cout &lt;&lt; endl;\n}\n</code></pre><p>输出结果是：</p><blockquote>\n<p><code>0020 6c49 d83d de00</code><br>\n<code>20 e6 b1 89 f0 9f 98 80</code></p>\n</blockquote><h2>平台区别</h2><p>下面我们看一下在两个主流的平台上一般是如何处理 Unicode 编码问题的。</p><h3>Unix</h3><p>现代 Unix 系统，包括 Linux 和 macOS 在内，已经全面转向了 UTF-8。这样的系统中一般直接使用 <code>char[]</code> 和 <code>string</code> 来代表 UTF-8 字符串，包括输入、输出和文件名，非常简单。不过，由于一个字符单位不能代表一个完整的 Unicode 字符，在需要真正进行文字处理的场合转换到 UTF-32 往往会更简单。在以前及需要和 C 兼容的场合，会使用 <code>wchar_t</code>、<code>uint32_t</code> 或某个等价的类型别名；在新的纯 C++ 代码里，就没有理由不使用 <code>char32_t</code> 和 <code>u32string</code> 了。</p><p>Unix 下输出宽字符串需要使用 <code>wcout</code>（这点和 Windows 相同），并且需要进行区域设置，如下所示：</p><pre><code class=\"language-c++\">std::locale::global(\n    std::locale(\"\"));\nstd::wcout.imbue(std::locale());\n</code></pre><p>由于没有什么额外好处，反而可能在某些环境因为区域设置失败而引发问题，Unix 平台下一般只用 <code>cout</code>，不用 <code>wcout</code>。</p><h3>Windows</h3><p>Windows 由于历史原因和保留向后兼容性的需要（Windows 为了向后兼容性已经到了大规模放弃优雅的程度了），一直用 <code>char</code> 表示传统编码（如，英文 Windows 上是 Windows-1252，简体中文 Windows 上是 GBK），用 <code>wchar_t</code> 表示 UTF-16。由于传统编码一次只有一种、且需要重启才能生效，要得到好的多语言支持，在和操作系统交互时必须使用 UTF-16。</p><p>对于纯 Windows 编程，全面使用宽字符（串）是最简单的处理方式。当然，源代码和文本很少用 UTF-16 存储，通常还是 UTF-8（除非是纯 ASCII，否则必须加入 BOM 字符来和传统编码相区分）。这时可能会有一个小小的令人惊讶的地方：微软的编译器会把源代码里窄字符串字面量中的非 ASCII 字符转换成传统编码。换句话说，同样的源代码在不同编码的 Windows 下编译可能会产生不同的结果！如果你希望保留 UTF-8 序列的话，就应该使用 UTF-8 字面量（并在将来使用 <code>char8_t</code> 字符类型）。</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n\ntemplate &lt;typename T&gt;\nvoid dump(const T&amp; str)\n{\n  for (char ch : str) {\n    printf(\n      \"%.2x \",\n      static_cast&lt;unsigned char&gt;(ch));\n  }\n  putchar('\\n');\n}\n\nint main()\n{\n  char str[] = \"你好\";\n  char u8str[] = u8\"你好\";\n  dump(str);\n  dump(u8str);\n}\n</code></pre><p>下面展示的是以上代码在 Windows 下系统传统编码设置为简体中文时的编译、运行结果：</p><blockquote>\n<p><code>c4 e3 ba c3 00</code><br>\n<code>e4 bd a0 e5 a5 bd 00</code></p>\n</blockquote><p>Windows 下的 <code>wcout</code> 主要用在配合宽字符的输出，此外没什么大用处。原因一样，只有进行了正确的区域设置，才能输出跟该区域相匹配的宽字符串（不匹配的字符将导致后续输出全部消失！）。如果要输出中文，得写 <code>setlocale(LC_ALL, \"Chinese_China.936\");</code>，这显然就让“统一码”输出失去意义了。</p><p>但是（还是有个“但是”），如果你<strong>只用</strong> <code>wcout</code>，不用 <code>cout</code> 或任何使用窄字符输出到 <code>stdout</code> 的函数（如 <code>puts</code>），这时倒有个还不错的解决方案，可以在终端输出多语言。我也是偶然才发现这一用法，并且没有在微软的网站上找到清晰的文档……代码如下所示：</p><pre><code class=\"language-c++\">#include &lt;fcntl.h&gt;\n#include &lt;io.h&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n  _setmode(_fileno(stdout),\n           _O_WTEXT);\n  std::wcout\n    &lt;&lt; L\"中文 Español Français\\n\";\n  std::wcout\n    &lt;&lt; \"Narrow characters are \"\n       \"also OK on wcout\\n\";\n  // but not on cout...\n}\n</code></pre><p>由于窄字符在大部分 Windows 系统上只支持传统编码，要打开一个当前编码不支持的文件名称，就必需使用宽字符的文件名。微软的 <code>fstream</code> 系列类及其 <code>open</code> 成员函数都支持 <code>const wchar_t*</code> 类型的文件名，这是 C++ 标准里所没有的。</p><h3>统一化处理</h3><p>要想写出跨平台的处理字符串的代码，我们一般考虑两种方式之一：</p><ul>\n<li>源代码级兼容，但内码不同</li>\n<li>源代码和内码都完全兼容</li>\n</ul><p>微软推荐的方式一般是前者。做 Windows 开发的人很多都知道 tchar.h 和 <code>_T</code> 宏，它们就起着类似的作用（虽然目的不同）。根据预定义宏的不同，系统会在同一套代码下选择不同的编码方式及对应的函数。拿一个最小的例子来说：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n\nint _tmain(int argc, TCHAR* argv[])\n{\n  _putts(_T(\"Hello world!\\n\"));\n}\n</code></pre><p>如果用缺省的命令行参数进行编译，上面的代码相当于：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n\nint main(int argc, char* argv[])\n{\n  puts(\"Hello world!\\n\");\n}\n</code></pre><p>而如果在命令行上加上了 <code>/D_UNICODE</code>，那代码则相当于：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n\nint wmain(int argc, wchar_t* argv[])\n{\n  _putws(L\"Hello world!\\n\");\n}\n</code></pre><p>当然，这个代码还是只能在 Windows 上用，并且仍然不漂亮（所有的字符和字符串字面量都得套上 <code>_T</code>）。后者无解，前者则可以找到替代方案（甚至自己写也不复杂）。C++ REST SDK 中就提供了类似的封装，可以跨平台地开发网络应用。但可以说，这种方式是一种主要照顾 Windows 的开发方式。</p><p>相应的，对 Unix 开发者而言更自然的方式是全面使用 UTF-8，仅在跟操作系统、文件系统打交道时把字符串转换成需要的编码。利用临时对象的生命周期，我们可以像下面这样写帮助函数和宏。</p><p>utf8_to_native.hpp：</p><pre><code class=\"language-c++\">#ifndef UTF8_TO_NATIVE_HPP\n#define UTF8_TO_NATIVE_HPP\n\n#include &lt;string&gt;\n\n#if defined(_WIN32) || \\\n    defined(_UNICODE)\n\nstd::wstring utf8_to_wstring(\n  const char* str);\nstd::wstring utf8_to_wstring(\n  const std::string&amp; str);\n\n#define NATIVE_STR(s) \\\n  utf8_to_wstring(s).c_str()\n\n#else\n\ninline const char*\nto_c_str(const char* str)\n{\n  return str;\n}\n\ninline const char*\nto_c_str(const std::string&amp; str)\n{\n  return str.c_str();\n}\n\n#define NATIVE_STR(s) \\\n  to_c_str(s)\n\n#endif\n\n#endif // UTF8_TO_NATIVE_HPP\n</code></pre><p>utf8_to_native.cpp：</p><pre><code class=\"language-c++\">#include \"utf8_to_native.hpp\"\n\n#if defined(_WIN32) || \\\n    defined(_UNICODE)\n#include &lt;windows.h&gt;\n#include &lt;system_error&gt;\n\nnamespace {\n\nvoid throw_system_error(\n  const char* reason)\n{\n  std::string msg(reason);\n  msg += \" failed\";\n  std::error_code ec(\n    GetLastError(),\n    std::system_category());\n  throw std::system_error(ec, msg);\n}\n\n} /* unnamed namespace */\n\nstd::wstring utf8_to_wstring(\n  const char* str)\n{\n  int len = MultiByteToWideChar(\n    CP_UTF8, 0, str, -1,\n    nullptr, 0);\n  if (len == 0) {\n    throw_system_error(\n      \"utf8_to_wstring\");\n  }\n  std::wstring result(len - 1,\n                      L'\\0');\n  if (MultiByteToWideChar(\n        CP_UTF8, 0, str, -1,\n        result.data(), len) == 0) {\n    throw_system_error(\n      \"utf8_to_wstring\");\n  }\n  return result;\n}\n\nstd::wstring utf8_to_wstring(\n  const std::string&amp; str)\n{\n  return utf8_to_wstring(\n    str.c_str());\n}\n\n#endif\n</code></pre><p>在头文件里，定义了在 Windows 下会做 UTF-8 到 UTF-16 的转换；在其他环境下则不真正做转换，而是不管提供的是字符指针还是 <code>string</code> 都会转换成字符指针。在 Windows 下每次调用 <code>NATIVE_STR</code> 会生成一个临时对象，当前语句执行结束后这个临时对象会自动销毁。</p><p>使用该功能的代码是这样的：</p><pre><code class=\"language-c++\">#include &lt;fstream&gt;\n#include \"utf8_to_native.hpp\"\n\nint main()\n{\n  using namespace std;\n  const char filename[] =\n    u8\"测试.txt\";\n  ifstream ifs(\n    NATIVE_STR(filename));\n  // 对 ifs 进行操作\n}\n</code></pre><p>上面这样的代码可以同时适用于现代 Unix 和现代 Windows（任何语言设置下），用来读取名为“测试.txt”的文件。</p><h2>编程支持</h2><p>结束之前，我们快速介绍一下其他的一些支持 Unicode 及其转换的 API。</p><h3>Windows API</h3><p>上一节的代码在 Windows 下用到了 <code>MultiByteToWideChar</code> <span class=\"orange\">[12]</span>，从某个编码转到 UTF-16。Windows 也提供了反向的 <code>WideCharToMultiByte</code> <span class=\"orange\">[13]</span>，从 UTF-16 转到某个编码。从上面可以看到，C 接口用起来并不方便，可以考虑自己封装一下。</p><h3>iconv</h3><p>Unix 下最常用的底层编码转换接口是 iconv <span class=\"orange\">[14]</span>，提供 <code>iconv_open</code>、<code>iconv_close</code> 和 <code>iconv</code> 三个函数。这同样是 C 接口，实践中应该封装一下。</p><h3>ICU4C</h3><p>ICU <span class=\"orange\">[15]</span> 是一个完整的 Unicode 支持库，提供大量的方法，ICU4C 是其 C/C++ 的版本。ICU 有专门的字符串类型，内码是 UTF-16，但可以直接用于 IO streams 的输出。下面的程序应该在所有平台上都有同样的输出（但在 Windows 上要求当前系统传统编码能支持待输出的字符）：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unicode/unistr.h&gt;\n#include &lt;unicode/ustream.h&gt;\n\nusing namespace std;\nusing icu::UnicodeString;\n\nint main()\n{\n  auto str = UnicodeString::fromUTF8(\n    u8\"你好\");\n  cout &lt;&lt; str &lt;&lt; endl;\n  string u8str;\n  str.toUTF8String(u8str);\n  cout &lt;&lt; \"In UTF-8 it is \"\n       &lt;&lt; u8str.size() &lt;&lt; \" bytes\"\n       &lt;&lt; endl;\n}\n</code></pre><h3>codecvt</h3><p>C++11 曾经引入了一个头文件 &lt;codecvt&gt; <span class=\"orange\">[16]</span> 用作 UTF 编码间的转换，但很遗憾，那个头文件目前已因为存在安全性和易用性问题被宣告放弃（deprecated）<span class=\"orange\">[17]</span>。&lt;locale&gt; 中有另外一个 <code>codecvt</code> 模板 <span class=\"orange\">[18]</span>，本身接口不那么好用，而且到 C++20 还会发生变化，这儿也不详细介绍了。有兴趣的话可以直接看参考资料。</p><h2>内容小结</h2><p>本讲我们讨论了 Unicode，以及 C++ 中对 Unicode 的支持。我们也讨论了在两大主流桌面平台上关于 Unicode 编码支持的一些惯用法。希望你在本讲之后，能清楚地知道 Unicode 和各种 UTF 编码是怎么回事。</p><h2>课后思考</h2><p>请思考一下：</p><ol>\n<li>为什么说 UTF-32 处理会比较简单？</li>\n<li>你知道什么情况下 UTF-32 也并不那么简单吗？</li>\n<li>哪种 UTF 编码方式空间存储效率比较高？</li>\n</ol><p>欢迎留言一起讨论一下。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “ASCII”. <a href=\"https://en.wikipedia.org/wiki/ASCII\">https://en.wikipedia.org/wiki/ASCII</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “EBCDIC”. <a href=\"https://en.wikipedia.org/wiki/EBCDIC\">https://en.wikipedia.org/wiki/EBCDIC</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “GB 2312”. <a href=\"https://en.wikipedia.org/wiki/GB_2312\">https://en.wikipedia.org/wiki/GB_2312</a> </span></p><p><span class=\"reference\">[3a] 维基百科, “GB 2312”. <a href=\"https://zh.wikipedia.org/zh-cn/GB_2312\">https://zh.wikipedia.org/zh-cn/GB_2312</a> </span></p><p><span class=\"reference\">[4] Wikipedia, “EUC-CN”. <a href=\"https://en.wikipedia.org/wiki/Extended_Unix_Code#EUC-CN\">https://en.wikipedia.org/wiki/Extended_Unix_Code#EUC-CN</a> </span></p><p><span class=\"reference\">[4a] 维基百科, “EUC-CN”. <a href=\"https://zh.wikipedia.org/zh-cn/EUC#EUC-CN\">https://zh.wikipedia.org/zh-cn/EUC#EUC-CN</a> </span></p><p><span class=\"reference\">[5] Wikipedia, “GBK”. <a href=\"https://en.wikipedia.org/wiki/GBK_(character_encoding)\">https://en.wikipedia.org/wiki/GBK_(character_encoding)</a> </span></p><p><span class=\"reference\">[5a] 维基百科, “汉字内码扩展规范”. <a href=\"https://zh.wikipedia.org/zh-cn/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%89%A9%E5%B1%95%E8%A7%84%E8%8C%83\">https://zh.wikipedia.org/zh-cn/汉字内码扩展规范</a> </span></p><p><span class=\"reference\">[6] Wikipedia, “Unicode”. <a href=\"https://en.wikipedia.org/wiki/Unicode\">https://en.wikipedia.org/wiki/Unicode</a> </span></p><p><span class=\"reference\">[6a] 维基百科, “Unicode”. <a href=\"https://zh.wikipedia.org/zh-cn/Unicode\">https://zh.wikipedia.org/zh-cn/Unicode</a> </span></p><p><span class=\"reference\">[7] 吴咏炜, “Specify LANG in a UTF-8 web page”. <a href=\"http://wyw.dcweb.cn/lang_utf8.htm\">http://wyw.dcweb.cn/lang_utf8.htm</a> </span></p><p><span class=\"reference\">[8] Wikipedia, “UTF-32”. <a href=\"https://en.wikipedia.org/wiki/UTF-32\">https://en.wikipedia.org/wiki/UTF-32</a> </span></p><p><span class=\"reference\">[9] Wikipedia, “UTF-16”. <a href=\"https://en.wikipedia.org/wiki/UTF-16\">https://en.wikipedia.org/wiki/UTF-16</a> </span></p><p><span class=\"reference\">[10] Wikipedia, “UTF-8”. <a href=\"https://en.wikipedia.org/wiki/UTF-8\">https://en.wikipedia.org/wiki/UTF-8</a> </span></p><p><span class=\"reference\">[11] Wikipedia, “Byte order mark”. <a href=\"https://en.wikipedia.org/wiki/Byte_order_mark\">https://en.wikipedia.org/wiki/Byte_order_mark</a> </span></p><p><span class=\"reference\">[11a] 维基百科, “字节顺序标记”. <a href=\"https://zh.wikipedia.org/zh-cn/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F\">https://zh.wikipedia.org/zh-cn/位元組順序記號</a> </span></p><p><span class=\"reference\">[12] Microsoft, “MultiByteToWideChar function”. <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar\">https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar</a> </span></p><p><span class=\"reference\">[13] Microsoft, “WideCharToMultiByte function”. <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte\">https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte</a> </span></p><p><span class=\"reference\">[14] Wikipedia, “iconv”. <a href=\"https://en.wikipedia.org/wiki/Iconv\">https://en.wikipedia.org/wiki/Iconv</a> </span></p><p><span class=\"reference\">[15] ICU Technical Committee, ICU—International Components for Unicode. <a href=\"http://site.icu-project.org/\">http://site.icu-project.org/</a> </span></p><p><span class=\"reference\">[16] cppreference.com, “Standard library header &lt;codecvt&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/codecvt\">https://en.cppreference.com/w/cpp/header/codecvt</a> </span></p><p><span class=\"reference\">[17] Alisdair Meredith, “Deprecating &lt;codecvt&gt;”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0618r0.html\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0618r0.html</a> </span></p><p><span class=\"reference\">[18] cppreference.com, “std::codecvt”. <a href=\"https://en.cppreference.com/w/cpp/locale/codecvt\">https://en.cppreference.com/w/cpp/locale/codecvt</a> </span></p>","neighbors":{"left":{"article_title":"10 | 到底应不应该返回对象？","id":178940},"right":{"article_title":"12 | 编译期多态：泛型编程和模板入门","id":179363}}},{"article_id":179363,"article_title":"12 | 编译期多态：泛型编程和模板入门","article_content":"<p>你好，我是吴咏炜。</p><p>相信你对多态这个面向对象的特性应该是很熟悉了。我们今天来讲一个非常 C++ 的话题，编译期多态及其相关的 C++ 概念。</p><h2>面向对象和多态</h2><p>在面向对象的开发里，最基本的一个特性就是“多态” <span class=\"orange\">[1]</span>——用相同的代码得到不同结果。以我们在<a href=\"https://time.geekbang.org/column/article/169225\">[第 1 讲]</a> 提到过的 <code>shape</code> 类为例，它可能会定义一些通用的功能，然后在子类里进行实现或覆盖：</p><pre><code class=\"language-c++\">class shape {\npublic:\n  …\n  virtual void draw(const position&amp;) = 0;\n};\n</code></pre><p>上面的类定义意味着所有的子类必须实现 <code>draw</code> 函数，所以可以认为 <code>shape</code> 是定义了一个接口（按 Java 的概念）。在面向对象的设计里，接口抽象了一些基本的行为，实现类里则去具体实现这些功能。当我们有着接口类的指针或引用时，我们实际可以唤起具体的实现类里的逻辑。比如，在一个绘图程序里，我们可以在用户选择一种形状时，把形状赋给一个 <code>shape</code> 的（智能）指针，在用户点击绘图区域时，执行 <code>draw</code> 操作。根据指针指向的形状不同，实际绘制出的可能是圆，可能是三角形，也可能是其他形状。</p><p>但这种面向对象的方式，并不是唯一一种实现多态的方式。在很多动态类型语言里，有所谓的“鸭子”类型 <span class=\"orange\">[2]</span>：</p><!-- [[[read_end]]] --><blockquote>\n<p>如果一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那么这只鸟就可以被当作鸭子。</p>\n</blockquote><p>在这样的语言里，你可以不需要继承来实现 <code>circle</code>、<code>triangle</code> 等类，然后可以直接在这个类型的变量上调用 <code>draw</code> 方法。如果这个类型的对象没有 <code>draw</code> 方法，你就会在执行到 <code>draw()</code> 语句的时候得到一个错误（或异常）。</p><p>鸭子类型使得开发者可以不使用继承体系来灵活地实现一些“约定”，尤其是使得混合不同来源、使用不同对象继承体系的代码成为可能。唯一的要求只是，这些不同的对象有“共通”的成员函数。这些成员函数应当有相同的名字和相同结构的参数（并不要求参数类型相同）。</p><p>听起来很抽象？我们来看一下 C++ 中的具体例子。</p><h2>容器类的共性</h2><p>容器类是有很多共性的。其中，一个最最普遍的共性就是，容器类都有 <code>begin</code> 和 <code>end</code> 成员函数——这使得通用地遍历一个容器成为可能。容器类不必继承一个共同的 Container 基类，而我们仍然可以写出通用的遍历容器的代码，如使用基于范围的循环。</p><p>大部分容器是有 <code>size</code> 成员函数的，在“泛型”编程中，我们同样可以取得一个容器的大小，而不要求容器继承一个叫 SizeableContainer 的基类。</p><p>很多容器具有 <code>push_back</code> 成员函数，可以在尾部插入数据。同样，我们不需要一个叫 BackPushableContainer 的基类。在这个例子里，<code>push_back</code> 函数的参数显然是都不一样的，但明显，所有的 <code>push_back</code> 函数都只接收一个参数。</p><p>我们可以清晰看到的是，虽然 C++ 的标准容器没有对象继承关系，但彼此之间有着很多的同构性。这些同构性很难用继承体系来表达，也完全不必要用继承来表达。C++ 的模板，已经足够表达这些鸭子类型。</p><p>当然，作为一种静态类型语言，C++ 是不会在运行时才报告“没找到 <code>draw</code> 方法”这类问题的。这类错误可以在编译时直接捕获，更精确地来说，是在模板实例化的过程中。</p><p>下面我们通过几个例子，来完整地看一下模板的定义、实例化和特化。</p><h2>C++ 模板</h2><h3>定义模板</h3><p>学过算法的同学应该都知道求最大公约数的辗转相除法，代码大致如下：</p><pre><code class=\"language-c++\">int my_gcd(int a, int b)\n{\n  while (b != 0) {\n    int r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\n</code></pre><p>这里只有一个小小的问题，C++ 的整数类型可不止 <code>int</code> 一种啊。为了让这个算法对像长整型这样的类型也生效，我们需要把它定义成一个模板：</p><pre><code class=\"language-c++\">template &lt;typename E&gt;\nE my_gcd(E a, E b)\n{\n  while (b != E(0)) {\n    E r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\n</code></pre><p>这个代码里，基本上就是把 <code>int</code> 替换成了模板参数 <code>E</code>，并在函数的开头添加了模板的声明。我们对于“整数”这只鸭子的要求实际上是：</p><ul>\n<li>可以通过常量 <code>0</code> 来构造</li>\n<li>可以拷贝（构造和赋值）</li>\n<li>可以作不等于的比较</li>\n<li>可以进行取余数的操作</li>\n</ul><p>对于标准的 <code>int</code>、<code>long</code>、<code>long long</code> 等类型及其对应的无符号类型，以上代码都能正常工作，并能得到正确的结果。</p><p>至于类模板的例子，我们可以直接参考<a href=\"https://time.geekbang.org/column/article/169263\">[第 2 讲]</a> 中的智能指针，这儿就不再重复了。</p><h3>实例化模板</h3><p>不管是类模板还是函数模板，编译器在看到其定义时只能做最基本的语法检查，真正的类型检查要在实例化（instantiation）的时候才能做。一般而言，这也是编译器会报错的时候。</p><p>对于我们上面 <code>my_gcd</code> 的情况，如果提供的是一般的整数类型，那是不会有问题的。但如果我们提供一些其他类型的时候，就有可能出问题了。以 CLN，一个高精度数字库为例（注：我并不是推荐大家使用这个库），如果我们使用它的 <code>cl_I</code> 高精度整数类型来调用 <code>my_gcd</code> 的话，出错信息大致如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/0a/fcc96fe6227cb35be460e73bbd6d1b0a.png\" alt=\"\"></p><p>其原因是，虽然它的整数类 <code>cl_I</code> 设计得很像普通的整数，但这个类的对象不支持 <code>%</code> 运算符。出错的第 20 行是我们调用 <code>my_gcd</code> 的位置，而第 9 行是函数模板定义中执行取余数操作的位置。</p><p>实例化失败的话，编译当然就出错退出了。如果成功的话，模板的实例就产生了。在整个的编译过程中，可能产生多个这样的（相同）实例，但最后链接时，会只剩下一个实例。这也是为什么 C++ 会有一个单一定义的规则：如果不同的编译单元看到不同的定义的话，那链接时使用哪个定义是不确定的，结果就可能会让人吃惊。</p><p>模板还可以显式实例化和外部实例化。如果我们在调用 <code>my_gcd</code> 之前进行显式实例化——即，使用 <code>template</code> 关键字并给出完整的类型来声明函数：</p><pre><code class=\"language-c++\">template cln::cl_I\n  my_gcd(cln::cl_I, cln::cl_I);\n</code></pre><p>那出错信息中的第二行就会显示要求实例化的位置。如果在显式实例化的形式之前加上 <code>extern</code> 的话，编译器就会认为这个模板已经在其他某个地方实例化，从而不再产生其定义（但代码用到的内联函数仍可能会导致实例化的发生，这个会随编译器和优化选项不同而变化）。在我们这个例子里，就意味着不会产生上面的编译错误信息了。当然，我们仍然会在链接时得到错误，因为我们并没有真正实例化这个模板。</p><p>类似的，当我们在使用 <code>vector&lt;int&gt;</code> 这样的表达式时，我们就在隐式地实例化 <code>vector&lt;int&gt;</code>。我们同样也可以选择用 <code>template class vector&lt;int&gt;;</code> 来显式实例化，或使用 <code>extern template class vector&lt;int&gt;;</code> 来告诉编译器不需要实例化。显式实例化和外部实例化通常在大型项目中可以用来集中模板的实例化，从而加速编译过程——不需要在每个用到模板的地方都进行实例化了——但这种方式有额外的管理开销，如果实例化了不必要实例化的模板的话，反而会导致可执行文件变大。因而，显式实例化和外部实例化应当谨慎使用。</p><h3>特化模板</h3><p>如果遇到像前面 CLN 那样的情况，我们需要使用的模板参数类型，不能完全满足模板的要求，应该怎么办？</p><p>我们实际上有好几个选择：</p><ul>\n<li>添加代码，让那个类型支持所需要的操作（对成员函数无效）。</li>\n<li>对于函数模板，可以直接针对那个类型进行重载。</li>\n<li>对于类模板和函数模板，可以针对那个类型进行特化。</li>\n</ul><p>对于 <code>cln::cl_I</code> 不支持 <code>%</code> 运算符这种情况，恰好上面的三种方法我们都可以用。</p><p>一、添加 <code>operator%</code> 的实现：</p><pre><code class=\"language-c++\">cln::cl_I\noperator%(const cln::cl_I&amp; lhs,\n          const cln::cl_I&amp; rhs)\n{\n  return mod(lhs, rhs);\n}\n</code></pre><p>在这个例子，这可能是最简单的解决方案了。但在很多情况下，尤其是对对象的成员函数有要求的情况下，这个方法不可行。</p><p>二、针对 <code>cl_I</code> 进行重载：</p><p>为通用起见，我不直接使用 <code>cl_I</code> 的 <code>mod</code> 函数，而用 <code>my_mod</code> 把 <code>my_gcd</code> 改造如下：</p><pre><code class=\"language-c++\">template &lt;typename E&gt;\nE my_gcd(E a, E b)\n{\n  while (b != E(0)) {\n    E r = my_mod(a, b);\n    a = b;\n    b = r;\n  }\n  return a;\n}\n</code></pre><p>然后，一般情况的 <code>my_mod</code> 显然就是：</p><pre><code class=\"language-c++\">template &lt;typename E&gt;\nE my_mod(const E&amp; lhs,\n         const E&amp; rhs)\n{\n  return lhs % rhs;\n}\n</code></pre><p>最后，针对 <code>cl_I</code> 类，我们可以重载（overload）：</p><pre><code class=\"language-c++\">cln::cl_I\nmy_mod(const cln::cl_I&amp; lhs,\n       const cln::cl_I&amp; rhs)\n{\n  return mod(lhs, rhs);\n}\n</code></pre><p>三、针对 <code>cl_I</code> 进行特化：</p><p>同二类似，但我们提供的不是一个重载，而是特化（specialization）：</p><pre><code class=\"language-c++\">template &lt;&gt;\ncln::cl_I my_mod&lt;cln::cl_I&gt;(\n  const cln::cl_I&amp; lhs,\n  const cln::cl_I&amp; rhs)\n{\n  return mod(lhs, rhs);\n}\n</code></pre><p>这个例子比较简单，特化和重载在行为上没有本质的区别。就一般而言，特化是一种更通用的技巧，最主要的原因是特化可以用在类模板和函数模板上，而重载只能用于函数。</p><p>不过，我只是展示了一种可能性而已。通用而言，Herb Sutter 给出了明确的建议：对函数使用重载，对类模板进行特化 <span class=\"orange\">[3]</span>。</p><p>展示特化的更好的例子是 C++11 之前的静态断言。使用特化技巧可以大致实现 <code>static_assert</code> 的功能：</p><pre><code class=\"language-c++\">template &lt;bool&gt;\nstruct compile_time_error;\ntemplate &lt;&gt;\nstruct compile_time_error&lt;true&gt; {};\n\n#define STATIC_ASSERT(Expr, Msg)   \\\n  {                                \\\n    compile_time_error&lt;bool(Expr)&gt; \\\n      ERROR_##_Msg;                \\\n    (void)ERROR_##_Msg;            \\\n  }\n</code></pre><p>上面首先声明了一个 struct 模板，然后仅对 <code>true</code> 的情况进行了特化，产生了一个 struct 的定义。这样。如果遇到 <code>compile_time_error&lt;false&gt;</code> 的情况——也就是下面静态断言里的 <code>Expr</code> 不为真的情况——编译就会失败报错，因为 <code>compile_time_error&lt;false&gt;</code> 从来就没有被定义过。</p><h2>“动态”多态和“静态”多态的对比</h2><p>我前面描述了面向对象的“动态”多态，也描述了 C++ 里基于泛型编程的“静态”多态。需要看到的是，两者解决的实际上是不太一样的问题。“动态”多态解决的是运行时的行为变化——就如我前面提到的，选择了一个形状之后，再选择在某个地方绘制这个形状——这个是无法在编译时确定的。“静态”多态或者“泛型”——解决的是很不同的问题，让适用于不同类型的“同构”算法可以用同一套代码来实现，实际上强调的是对代码的复用。C++ 里提供了很多标准算法，都一样只作出了基本的约定，然后对任何满足约定的类型都可以工作。以排序为例，C++ 里的标准 <code>sort</code> 算法（以两参数的重载为例）只要求：</p><ul>\n<li>参数满足随机访问迭代器的要求。</li>\n<li>迭代器指向的对象之间可以使用 <code>&lt;</code> 来比较大小，满足严格弱序关系。</li>\n<li>迭代器指向的对象可以被移动。</li>\n</ul><p>它的性能超出 C 的 <code>qsort</code>，因为编译器可以内联（inline）对象的比较操作；而在 C 里面比较只能通过一个额外的函数调用来实现。此外，C 的 <code>qsort</code> 函数要求数组指向的内容是可按比特复制的，C++ 的 <code>sort</code> 则要求迭代器指向的内容是可移动的，可适用于更广的情况。</p><p>C++ 里目前有大量这样的泛型算法。随便列举几个：</p><ul>\n<li><code>sort</code>：排序</li>\n<li><code>reverse</code>：反转</li>\n<li><code>count</code>：计数</li>\n<li><code>find</code>：查找</li>\n<li><code>max</code>：最大值</li>\n<li><code>min</code>：最小值</li>\n<li><code>minmax</code>：最小值和最大值</li>\n<li><code>next_permutation</code>：下一个排列</li>\n<li><code>gcd</code>：最大公约数</li>\n<li><code>lcm</code>：最小公倍数</li>\n<li>等等</li>\n</ul><h2>内容小结</h2><p>本讲我们对模板、泛型编程和静态多态做了最基本的描述，并和动态多态做了一定的比较。如果你不熟悉模板和泛型编程的话，应该在本讲之后已经对其有了初步的了解，我们可以在下面几讲中进行更深入的讨论。</p><h2>课后思考</h2><p>请你在课后读一下参考资料，了解一下各种不同的多态，然后想一想：</p><ul>\n<li>C++ 支持几种不同形式的多态？</li>\n<li>为什么并非所有的语言都支持这些不同的多态方式？</li>\n</ul><p>欢迎你留言与我分享你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Polymorphism”. <a href=\"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\">https://en.wikipedia.org/wiki/Polymorphism_(computer_science)</a> </span></p><p><span class=\"reference\">[1a] 维基百科, “多态”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\">https://zh.wikipedia.org/zh-cn/多型_(计算机科学)</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Duck typing”. <a href=\"https://en.wikipedia.org/wiki/Duck_typing\">https://en.wikipedia.org/wiki/Duck_typing</a> </span></p><p><span class=\"reference\">[2a] 维基百科, “鸭子类型”. <a href=\"https://zh.wikipedia.org/zh-cn/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\">https://zh.wikipedia.org/zh-cn/鸭子类型</a> </span></p><p><span class=\"reference\">[3] Herb Sutter, “Why not specialize function templates?”. <a href=\"http://www.gotw.ca/publications/mill17.htm\">http://www.gotw.ca/publications/mill17.htm</a> </span></p>","neighbors":{"left":{"article_title":"11 | Unicode：进入多文字支持的世界","id":179357},"right":{"article_title":"13 | 编译期能做些什么？一个完整的计算世界","id":181608}}},{"article_id":181608,"article_title":"13 | 编译期能做些什么？一个完整的计算世界","article_content":"<p>你好，我是吴咏炜。</p><p>上一讲我们简单介绍了模板的基本用法及其在泛型编程中的应用。这一讲我们来看一下模板的另外一种重要用途——编译期计算，也称作“模板元编程”。</p><h2>编译期计算</h2><p>首先，我们给出一个已经被证明的结论：C++ 模板是图灵完全的 <span class=\"orange\">[1]</span>。这句话的意思是，使用 C++ 模板，你可以在编译期间模拟一个完整的图灵机，也就是说，可以完成任何的计算任务。</p><p>当然，这只是理论上的结论。从实际的角度，我们并不<strong>想</strong>、也不可能在编译期完成所有的计算，更不用说编译期的编程是很容易让人看不懂的——因为这并不是语言设计的初衷。即便如此，我们也还是需要了解一下模板元编程的基本概念：它仍然有一些实用的场景，并且在实际的工程中你也可能会遇到这样的代码。虽然我们在开篇就说过不要炫技，但使用模板元编程写出的代码仍然是可理解的，尤其是如果你对递归不发怵的话。</p><p>好，闲话少叙，我们仍然拿代码说话：</p><pre><code class=\"language-c++\">template &lt;int n&gt;\nstruct factorial {\n  static const int value =\n    n * factorial&lt;n - 1&gt;::value;\n};\n\ntemplate &lt;&gt;\nstruct factorial&lt;0&gt; {\n  static const int value = 1;\n};\n</code></pre><!-- [[[read_end]]] --><p>上面定义了一个递归的阶乘函数。可以看出，它完全符合阶乘的递归定义：</p><p>$$<br>\n\\begin{aligned}<br>\n0! &amp;= 1 \\\\\\<br>\nn! &amp;= n \\times (n - 1)!<br>\n\\end{aligned}<br>\n$$</p><p>除了顺序有特定的要求——先定义，才能特化——再加语法有点特别，代码基本上就是这个数学定义的简单映射了。</p><p>那我们怎么知道这个计算是不是在编译时做的呢？我们可以直接看编译输出。下面直接贴出对上面这样的代码加输出（<code>printf(\"%d\\n\", factorial&lt;10&gt;::value);</code>）在 x86-64 下的编译结果：</p><pre><code class=\"language-assembly\">.LC0:\n        .string \"%d\\n\"\nmain:\n        push    rbp\n        mov     rbp, rsp\n        mov     esi, 3628800\n        mov     edi, OFFSET FLAT:.LC0\n        mov     eax, 0\n        call    printf\n        mov     eax, 0\n        pop     rbp\n        ret\n</code></pre><p>我们可以明确看到，编译结果里明明白白直接出现了常量 3628800。上面那些递归什么的，完全都没有了踪影。</p><p>如果我们传递一个负数给 <code>factorial</code> 呢？这时的结果就应该是编译期间的递归溢出。如 GCC 会报告：</p><blockquote>\n<p>fatal error: template instantiation depth exceeds maximum of 900 (use -ftemplate-depth= to increase the maximum)</p>\n</blockquote><p>如果把 <code>int</code> 改成 <code>unsigned</code>，不同的编译器和不同的标准选项会导致不同的结果。有些情况下错误信息完全不变，有些情况下则会报负数不能转换到 <code>unsigned</code>。通用的解决方案是使用 <code>static_assert</code>，确保参数永远不会是负数。</p><pre><code class=\"language-c++\">template &lt;int n&gt;\nstruct factorial {\n  static_assert(\n    n &gt;= 0,\n    \"Arg must be non-negative\");\n  static const int value =\n    n * factorial&lt;n - 1&gt;::value;\n};\n</code></pre><p>这样，当 <code>factorial</code> 接收到一个负数作为参数时，就会得到一个干脆的错误信息：</p><blockquote>\n<p>error: static assertion failed: Arg must be non-negative</p>\n</blockquote><p>下面我们看一些更复杂的例子。这些例子不是为了让你真的去写这样的代码，而是帮助你充分理解编译期编程的强大威力。如果这些例子你都完全掌握了，那以后碰到小的模板问题，你一定可以轻松解决，完全不在话下。</p><p>回想上面的例子，我们可以看到，要进行编译期编程，最主要的一点，是需要把计算转变成类型推导。比如，下面的模板可以代表条件语句：</p><pre><code class=\"language-c++\">template &lt;bool cond,\n          typename Then,\n          typename Else&gt;\nstruct If;\n\ntemplate &lt;typename Then,\n          typename Else&gt;\nstruct If&lt;true, Then, Else&gt; {\n  typedef Then type;\n};\n\ntemplate &lt;typename Then,\n          typename Else&gt;\nstruct If&lt;false, Then, Else&gt; {\n  typedef Else type;\n};\n</code></pre><p><code>If</code> 模板有三个参数，第一个是布尔值，后面两个则是代表不同分支计算的类型，这个类型可以是我们上面定义的任何一个模板实例，包括 <code>If</code> 和 <code>factorial</code>。第一个 struct 声明规定了模板的形式，然后我们不提供通用定义，而是提供了两个特化。第一个特化是真的情况，定义结果 <code>type</code> 为 <code>Then</code> 分支；第二个特化是假的情况，定义结果 <code>type</code> 为 <code>Else</code> 分支。</p><p>我们一般也需要循环：</p><pre><code class=\"language-c++\">template &lt;bool condition,\n          typename Body&gt;\nstruct WhileLoop;\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;true, Body&gt; {\n  typedef typename WhileLoop&lt;\n    Body::cond_value,\n    typename Body::next_type&gt;::type\n    type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;false, Body&gt; {\n  typedef\n    typename Body::res_type type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct While {\n  typedef typename WhileLoop&lt;\n    Body::cond_value, Body&gt;::type\n    type;\n};\n</code></pre><p>这个循环的模板定义稍复杂点。首先，我们对循环体类型有一个约定，它必须提供一个静态数据成员，<code>cond_value</code>，及两个子类型定义，<code>res_type</code> 和 <code>next_type</code>：</p><ul>\n<li><code>cond_value</code> 代表循环的条件（真或假）</li>\n<li><code>res_type</code> 代表退出循环时的状态</li>\n<li><code>next_type</code> 代表下面循环执行一次时的状态</li>\n</ul><p>这里面比较绕的地方是用类型来代表执行状态。如果之前你没有接触过函数式编程的话，这个在初学时有困难是正常的。把例子多看两遍，自己编译、修改、把玩一下，就会渐渐理解的。</p><p>排除这个抽象性，模板的定义和 <code>If</code> 是类似的，虽然我们为方便使用，定义了两个模板。<code>WhileLoop</code> 模板有两个模板参数，同样用特化来决定走递归分支还是退出循环分支。<code>While</code> 模板则只需要循环体一个参数，方便使用。</p><p>如果你之前模板用得不多的话，还有一个需要了解的细节，就是用 <code>::</code> 取一个成员类型、并且 <code>::</code> 左边有模板参数的话，得额外加上 <code>typename</code> 关键字来标明结果是一个类型。上面循环模板的定义里就出现了多次这样的语法。MSVC 在这方面往往比较宽松，不写 <code>typename</code> 也不会报错，但这是不符合 C++ 标准的用法。</p><p>为了进行计算，我们还需要通用的代表数值的类型。下面这个模板可以通用地代表一个整数常数：</p><pre><code class=\"language-c++\">template &lt;class T, T v&gt;\nstruct integral_constant {\n  static const T value = v;\n  typedef T value_type;\n  typedef integral_constant type;\n};\n</code></pre><p><code>integral_constant</code> 模板同时包含了整数的类型和数值，而通过这个类型的 <code>value</code> 成员我们又可以重新取回这个数值。有了这个模板的帮忙，我们就可以进行一些更通用的计算了。下面这个模板展示了如何使用循环模板来完成从 1 加到 n 的计算：</p><pre><code class=\"language-c++\">template &lt;int result, int n&gt;\nstruct SumLoop {\n  static const bool cond_value =\n    n != 0;\n  static const int res_value =\n    result;\n  typedef integral_constant&lt;\n    int, res_value&gt;\n    res_type;\n  typedef SumLoop&lt;result + n, n - 1&gt;\n    next_type;\n};\n\ntemplate &lt;int n&gt;\nstruct Sum {\n  typedef SumLoop&lt;0, n&gt; type;\n};\n</code></pre><p>然后你使用 <code>While&lt;Sum&lt;10&gt;::type&gt;::type::value</code> 就可以得到 1 加到 10 的结果。虽然有点绕，但代码实质就是在编译期间进行了以下的计算：</p><pre><code class=\"language-c++\">int result = 0;\nwhile (n != 0) {\n  result = result + n;\n  n = n - 1;\n}\n</code></pre><p>估计现在你的头已经很晕了。但我保证，这一讲最难的部分已经过去了。实际上，到现在为止，我们讲的东西还没有离开 C++98。而我们下面几讲里很快就会讲到，如何在现代 C++ 里不使用这种麻烦的方式也能达到同样的效果。</p><h2>编译期类型推导</h2><p>C++ 标准库在 &lt;type_traits&gt; 头文件里定义了很多工具类模板，用来提取某个类型（type）在某方面的特点（trait）<span class=\"orange\">[2]</span>。和上一节给出的例子相似，这些特点既是类型，又是常值。</p><p>为了方便地在值和类型之间转换，标准库定义了一些经常需要用到的工具类。上面描述的 <code>integral_constant</code> 就是其中一个（我的定义有所简化）。为了方便使用，针对布尔值有两个额外的类型定义：</p><pre><code class=\"language-c++\">typedef std::integral_constant&lt;\n  bool, true&gt; true_type;\ntypedef std::integral_constant&lt;\n  bool, false&gt; false_type;\n</code></pre><p>这两个标准类型 <code>true_type</code> 和 <code>false_type</code> 经常可以在函数重载中见到。有一个工具函数常常会写成下面这个样子：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass SomeContainer {\npublic:\n  …\n  static void destroy(T* ptr)\n  {\n    _destroy(ptr,\n      is_trivially_destructible&lt;\n        T&gt;());\n  }\n\nprivate:\n  static void _destroy(T* ptr,\n                       true_type)\n  {}\n  static void _destroy(T* ptr,\n                       false_type)\n  {\n    ptr-&gt;~T();\n  }\n};\n</code></pre><p>类似上面，很多容器类里会有一个 <code>destroy</code> 函数，通过指针来析构某个对象。为了确保最大程度的优化，常用的一个技巧就是用 <code>is_trivially_destructible</code> 模板来判断类是否是可平凡析构的——也就是说，不调用析构函数，不会造成任何资源泄漏问题。模板返回的结果还是一个类，要么是 <code>true_type</code>，要么是 <code>false_type</code>。如果要得到布尔值的话，当然使用 <code>is_trivially_destructible&lt;T&gt;::value</code> 就可以，但此处不需要。我们需要的是，使用 <code>()</code> 调用该类型的构造函数，让编译器根据数值类型来选择合适的重载。这样，在优化编译的情况下，编译器可以把不需要的析构操作彻底全部删除。</p><p>像 <code>is_trivially_destructible</code> 这样的 trait 类有很多，可以用来在模板里决定所需的特殊行为：</p><ul>\n<li><code>is_array</code></li>\n<li><code>is_enum</code></li>\n<li><code>is_function</code></li>\n<li><code>is_pointer</code></li>\n<li><code>is_reference</code></li>\n<li><code>is_const</code></li>\n<li><code>has_virtual_destructor</code></li>\n<li>…</li>\n</ul><p>这些特殊行为判断可以是像上面这样用于决定不同的重载，也可以是直接用在模板参数甚至代码里（记得我们是可以直接得到布尔值的）。</p><p>除了得到布尔值和相对应的类型的 trait 模板，我们还有另外一些模板，可以用来做一些类型的转换。以一个常见的模板 <code>remove_const</code> 为例（用来去除类型里的 const 修饰），它的定义大致如下：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nstruct remove_const {\n  typedef T type;\n};\ntemplate &lt;class T&gt;\nstruct remove_const&lt;const T&gt; {\n  typedef T type;\n};\n</code></pre><p>同样，它也是利用模板的特化，针对 const 类型去掉相应的修饰。比如，如果我们对 <code>const string</code> 应用 <code>remove_const</code>，就会得到 <code>string</code>，即，<code>remove_const&lt;const string&gt;::type</code> 等价于 <code>string</code>。</p><p>这里有一个细节你要注意一下，如果对 <code>const char*</code> 应用 <code>remove_const</code> 的话，结果还是 <code>const char*</code>。原因是，<code>const char*</code> 是指向 <code>const char</code> 的指针，而不是指向 <code>char</code> 的 const 指针。如果我们对 <code>char * const</code> 应用 <code>remove_const</code> 的话，还是可以得到 <code>char*</code> 的。</p><h3>简易写法</h3><p>如果你觉得写 <code>is_trivially_destructible&lt;T&gt;::value</code> 和 <code>remove_const&lt;T&gt;::type</code> 非常啰嗦的话，那你绝不是一个人。在当前的 C++ 标准里，前者有增加 <code>_v</code> 的编译时常量，后者有增加 <code>_t</code> 的类型别名：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\ninline constexpr bool\n  is_trivially_destructible_v =\n    is_trivially_destructible&lt;\n      T&gt;::value;\n</code></pre><pre><code class=\"language-c++\">template &lt;class T&gt;\nusing remove_const_t =\n  typename remove_const&lt;T&gt;::type;\n</code></pre><p>至于什么是 <code>constexpr</code>，我们会单独讲。<code>using</code> 是现代 C++ 的新语法，功能大致与 <code>typedef</code> 相似，但 <code>typedef</code> 只能针对某个特定的类型，而 <code>using</code> 可以生成别名模板。目前我们只需要知道，在你需要 trait 模板的结果数值和类型时，使用带 <code>_v</code> 和 <code>_t</code> 后缀的模板可能会更方便，尤其是带 <code>_t</code> 后缀的类型转换模板。</p><h2>通用的 fmap 函数模板</h2><p>你应当多多少少听到过 map-reduce。抛开其目前在大数据应用中的具体方式不谈，从概念本源来看，map <span class=\"orange\">[3]</span> 和 reduce <span class=\"orange\">[4]</span> 都来自函数式编程。下面我们演示一个 map 函数（当然，在 C++ 里它的名字就不能叫 <code>map</code> 了），其中用到了目前为止我们学到的多个知识点：</p><pre><code class=\"language-c++\">template &lt;\n  template &lt;typename, typename&gt;\n  class OutContainer = vector,\n  typename F, class R&gt;\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs)\n{\n  typedef decay_t&lt;decltype(\n    f(*inputs.begin()))&gt;\n    result_type;\n  OutContainer&lt;\n    result_type,\n    allocator&lt;result_type&gt;&gt;\n    result;\n  for (auto&amp;&amp; item : inputs) {\n    result.push_back(f(item));\n  }\n  return result;\n}\n</code></pre><p>我们：</p><ul>\n<li>用 <code>decltype</code> 来获得用 <code>f</code> 来调用 <code>inputs</code> 元素的类型（参考<a href=\"https://time.geekbang.org/column/article/176850\">[第 8 讲]</a>）；</li>\n<li>用 <code>decay_t</code> 来把获得的类型变成一个普通的值类型；</li>\n<li>缺省使用 <code>vector</code> 作为返回值的容器，但可以通过模板参数改为其他容器；</li>\n<li>使用基于范围的 for 循环来遍历 <code>inputs</code>，对其类型不作其他要求（参考<a href=\"https://time.geekbang.org/column/article/176842\">[第 7 讲]</a>）；</li>\n<li>存放结果的容器需要支持 <code>push_back</code> 成员函数（参考<a href=\"https://time.geekbang.org/column/article/173167\">[第 4 讲]</a>）。</li>\n</ul><p>下面的代码可以验证其功能：</p><pre><code class=\"language-c++\">vector&lt;int&gt; v{1, 2, 3, 4, 5};\nint add_1(int x)\n{\n    return x + 1;\n}\n\nauto result = fmap(add_1, v);\n</code></pre><p>在 <code>fmap</code> 执行之后，我们会在 <code>result</code> 里得到一个新容器，其内容是 2, 3, 4, 5, 6。</p><h2>内容小结</h2><p>本讲我们介绍了模板元编程的基本概念和例子，其本质是<strong>把计算过程用编译期的类型推导和类型匹配表达出来</strong>；然后介绍 type traits 及其基本用法；最后我们演示了一个简单的高阶函数 map，其实现中用到了我们目前已经讨论过的一些知识点。</p><h2>课后思考</h2><p>这一讲的内容可能有点烧脑，请你自行实验一下例子，并找一两个简单的算法用模板元编程的方法实现一下，看看能不能写出来。</p><p>如果有什么特别想法的话，欢迎留言和我分享交流。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Todd L. Veldhuizen, “C++ templates are Turing complete”. <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670\">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “Standard library header &lt;type_traits&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/type_traits\">https://en.cppreference.com/w/cpp/header/type_traits</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “标准库头文件 &lt;type_traits&gt;”. <a href=\"https://zh.cppreference.com/w/cpp/header/type_traits\">https://zh.cppreference.com/w/cpp/header/type_traits</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “Map (higher-order function)”. <a href=\"https://en.wikipedia.org/wiki/Map_(higher-order_function)\">https://en.wikipedia.org/wiki/Map_(higher-order_function)</a> </span></p><p><span class=\"reference\">[4] Wikipedia, “Fold (higher-order function)”. <a href=\"https://en.wikipedia.org/wiki/Fold_(higher-order_function)\">https://en.wikipedia.org/wiki/Fold_(higher-order_function)</a> </span></p>","neighbors":{"left":{"article_title":"12 | 编译期多态：泛型编程和模板入门","id":179363},"right":{"article_title":"14 | SFINAE：不是错误的替换失败是怎么回事?","id":181636}}},{"article_id":181636,"article_title":"14 | SFINAE：不是错误的替换失败是怎么回事?","article_content":"<p>你好，我是吴咏炜。</p><p>我们已经连续讲了两讲模板和编译期编程了。今天我们还是继续这个话题，讲的内容是模板里的一个特殊概念——替换失败非错（substitution failure is not an error），英文简称为 SFINAE。</p><h2>函数模板的重载决议</h2><p>我们之前已经讨论了不少模板特化。我们今天来着重看一个函数模板的情况。当一个函数名称和某个函数模板名称匹配时，重载决议过程大致如下：</p><ul>\n<li>根据名称找出所有适用的函数和函数模板</li>\n<li>对于适用的函数模板，要根据实际情况对模板形参进行替换；替换过程中如果发生错误，这个模板会被丢弃</li>\n<li>在上面两步生成的可行函数集合中，编译器会寻找一个最佳匹配，产生对该函数的调用</li>\n<li>如果没有找到最佳匹配，或者找到多个匹配程度相当的函数，则编译器需要报错</li>\n</ul><p>我们还是来看一个具体的例子（改编自参考资料 <span class=\"orange\">[1]</span>）。虽然这例子不那么实用，但还是比较简单，能够初步说明一下。</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n\nstruct Test {\n  typedef int foo;\n};\n\ntemplate &lt;typename T&gt;\nvoid f(typename T::foo)\n{\n  puts(\"1\");\n}\n\ntemplate &lt;typename T&gt;\nvoid f(T)\n{\n  puts(\"2\");\n}\n\nint main()\n{\n  f&lt;Test&gt;(10);\n  f&lt;int&gt;(10);\n}\n</code></pre><!-- [[[read_end]]] --><p>输出为：</p><blockquote>\n<p><code>1</code><br>\n<code>2</code></p>\n</blockquote><p>我们来分析一下。首先看 <code>f&lt;Test&gt;(10);</code> 的情况：</p><ul>\n<li>我们有两个模板符合名字 <code>f</code></li>\n<li>替换结果为 <code>f(Test::foo)</code> 和 <code>f(Test)</code></li>\n<li>使用参数 <code>10</code> 去匹配，只有前者参数可以匹配，因而第一个模板被选择</li>\n</ul><p>再看一下 <code>f&lt;int&gt;(10)</code> 的情况：</p><ul>\n<li>还是两个模板符合名字 <code>f</code></li>\n<li>替换结果为 <code>f(int::foo)</code> 和 <code>f(int)</code>；显然前者不是个合法的类型，被抛弃</li>\n<li>使用参数 <code>10</code> 去匹配 <code>f(int)</code>，没有问题，那就使用这个模板实例了</li>\n</ul><p>在这儿，体现的是 SFINAE 设计的最初用法：如果模板实例化中发生了失败，没有理由编译就此出错终止，因为还是可能有其他可用的函数重载的。</p><p>这儿的失败仅指函数模板的原型声明，即参数和返回值。函数体内的失败不考虑在内。如果重载决议选择了某个函数模板，而函数体在实例化的过程中出错，那我们仍然会得到一个编译错误。</p><h2>编译期成员检测</h2><p>不过，很快人们就发现 SFINAE 可以用于其他用途。比如，根据某个实例化的成功或失败来在编译期检测类的特性。下面这个模板，就可以检测一个类是否有一个名叫 <code>reserve</code>、参数类型为 <code>size_t</code> 的成员函数：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nstruct has_reserve {\n  struct good { char dummy; };\n  struct bad { char dummy[2]; };\n  template &lt;class U,\n            void (U::*)(size_t)&gt;\n  struct SFINAE {};\n  template &lt;class U&gt;\n  static good\n  reserve(SFINAE&lt;U, &amp;U::reserve&gt;*);\n  template &lt;class U&gt;\n  static bad reserve(...);\n  static const bool value =\n    sizeof(reserve&lt;T&gt;(nullptr))\n    == sizeof(good);\n};\n</code></pre><p>在这个模板里：</p><ul>\n<li>我们首先定义了两个结构 <code>good</code> 和 <code>bad</code>；它们的内容不重要，我们只关心它们的大小必须不一样。</li>\n<li>然后我们定义了一个 <code>SFINAE</code> 模板，内容也同样不重要，但模板的第二个参数需要是第一个参数的成员函数指针，并且参数类型是 <code>size_t</code>，返回值是 <code>void</code>。</li>\n<li>随后，我们定义了一个要求 <code>SFINAE*</code> 类型的 <code>reserve</code> 成员函数模板，返回值是 <code>good</code>；再定义了一个对参数类型无要求的 <code>reserve</code> 成员函数模板（不熟悉 <code>...</code> 语法的，可以看参考资料 <span class=\"orange\">[2]</span>），返回值是 <code>bad</code>。</li>\n<li>最后，我们定义常整型布尔值 <code>value</code>，结果是 <code>true</code> 还是 <code>false</code>，取决于 <code>nullptr</code> 能不能和 <code>SFINAE*</code> 匹配成功，而这又取决于模板参数 <code>T</code> 有没有返回类型是 <code>void</code>、接受一个参数并且类型为 <code>size_t</code> 的成员函数 <code>reserve</code>。</li>\n</ul><p>那这样的模板有什么用处呢？我们继续往下看。</p><h2>SFINAE 模板技巧</h2><h3>enable_if</h3><p>C++11 开始，标准库里有了一个叫 <code>enable_if</code> 的模板（定义在 &lt;type_traits&gt; 里），可以用它来选择性地启用某个函数的重载。</p><p>假设我们有一个函数，用来往一个容器尾部追加元素。我们希望原型是这个样子的：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr,\n            size_t size);\n</code></pre><p>显然，<code>container</code> 有没有 <code>reserve</code> 成员函数，是对性能有影响的——如果有的话，我们通常应该预留好内存空间，以免产生不必要的对象移动甚至拷贝操作。利用 <code>enable_if</code> 和上面的 <code>has_reserve</code> 模板，我们就可以这么写：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nenable_if_t&lt;has_reserve&lt;C&gt;::value,\n            void&gt;\nappend(C&amp; container, T* ptr,\n       size_t size)\n{\n  container.reserve(\n    container.size() + size);\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n\ntemplate &lt;typename C, typename T&gt;\nenable_if_t&lt;!has_reserve&lt;C&gt;::value,\n            void&gt;\nappend(C&amp; container, T* ptr,\n       size_t size)\n{\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n</code></pre><p>要记得之前我说过，对于某个 type trait，添加 <code>_t</code> 的后缀等价于其 <code>type</code> 成员类型。因而，我们可以用 <code>enable_if_t</code> 来取到结果的类型。<code>enable_if_t&lt;has_reserve&lt;C&gt;::value, void&gt;</code> 的意思可以理解成：如果类型 <code>C</code> 有 <code>reserve</code> 成员的话，那我们启用下面的成员函数，它的返回类型为 <code>void</code>。</p><p><code>enable_if</code> 的定义（其实非常简单）和它的进一步说明，请查看参考资料 <span class=\"orange\">[3]</span>。参考资料里同时展示了一个通用技巧，可以用在构造函数（无返回值）或不想手写返回值类型的情况下。但那个写法更绕一些，不是必需要用的话，就采用上面那个写出返回值类型的写法吧。</p><h3>decltype 返回值</h3><p>如果只需要在某个操作有效的情况下启用某个函数，而不需要考虑相反的情况的话，有另外一个技巧可以用。对于上面的 <code>append</code> 的情况，如果我们想限制只有具有 <code>reserve</code> 成员函数的类可以使用这个重载，我们可以把代码简化成：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nauto append(C&amp; container, T* ptr,\n            size_t size)\n  -&gt; decltype(\n    declval&lt;C&amp;&gt;().reserve(1U),\n    void())\n{\n  container.reserve(\n    container.size() + size);\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n</code></pre><p>这是我们第一次用到 <code>declval</code> <span class=\"orange\">[4]</span>，需要简单介绍一下。这个模板用来声明一个某个类型的参数，但这个参数只是用来参加模板的匹配，不允许实际使用。使用这个模板，我们可以在某类型没有默认构造函数的情况下，假想出一个该类的对象来进行类型推导。<code>declval&lt;C&amp;&gt;().reserve(1U)</code> 用来测试 <code>C&amp;</code> 类型的对象是不是可以拿 <code>1U</code> 作为参数来调用 <code>reserve</code> 成员函数。此外，我们需要记得，C++ 里的逗号表达式的意思是按顺序逐个估值，并返回最后一项。所以，上面这个函数的返回值类型是 <code>void</code>。</p><p>这个方式和 <code>enable_if</code> 不同，很难表示否定的条件。如果要提供一个专门给<strong>没有</strong> <code>reserve</code> 成员函数的 <code>C</code> 类型的 <code>append</code> 重载，这种方式就不太方便了。因而，这种方式的主要用途是避免错误的重载。</p><h3>void_t</h3><p><code>void_t</code> 是 C++17 新引入的一个模板 <span class=\"orange\">[5]</span>。它的定义简单得令人吃惊：</p><pre><code class=\"language-c++\">template &lt;typename...&gt;\nusing void_t = void;\n</code></pre><p>换句话说，这个类型模板会把任意类型映射到 <code>void</code>。它的特殊性在于，在这个看似无聊的过程中，编译器会检查那个“任意类型”的有效性。利用 <code>decltype</code>、<code>declval</code> 和模板特化，我们可以把 <code>has_reserve</code> 的定义大大简化：</p><pre><code class=\"language-c++\">template &lt;typename T,\n          typename = void_t&lt;&gt;&gt;\nstruct has_reserve : false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_reserve&lt;\n  T, void_t&lt;decltype(\n       declval&lt;T&amp;&gt;().reserve(1U))&gt;&gt;\n  : true_type {};\n</code></pre><p>这里第二个 <code>has_reserve</code> 模板的定义实际上是一个偏特化 <span class=\"orange\">[6]</span>。偏特化是类模板的特有功能，跟函数重载有些相似。编译器会找出所有的可用模板，然后选择其中最“特别”的一个。像上面的例子，所有类型都能满足第一个模板，但不是所有的类型都能满足第二个模板，所以第二个更特别。当第二个模板能被满足时，编译器就会选择第二个特化的模板；而只有第二个模板不能被满足时，才会回到第一个模板的通用情况。</p><p>有了这个 <code>has_reserve</code> 模板，我们就可以继续使用其他的技巧，如 <code>enable_if</code> 和下面的标签分发，来对重载进行限制。</p><h3>标签分发</h3><p>在上一讲，我们提到了用 <code>true_type</code> 和 <code>false_type</code> 来选择合适的重载。这种技巧有个专门的名字，叫标签分发（tag dispatch）。我们的 <code>append</code> 也可以用标签分发来实现：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nvoid _append(C&amp; container, T* ptr,\n             size_t size,\n             true_type)\n{\n  container.reserve(\n    container.size() + size);\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n\ntemplate &lt;typename C, typename T&gt;\nvoid _append(C&amp; container, T* ptr,\n             size_t size,\n             false_type)\n{\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n\ntemplate &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr,\n            size_t size)\n{\n  _append(\n    container, ptr, size,\n    integral_constant&lt;\n      bool,\n      has_reserve&lt;C&gt;::value&gt;{});\n}\n</code></pre><p>回想起上一讲里 <code>true_type</code> 和 <code>false_type</code> 的定义，你应该很容易看出这个代码跟使用 <code>enable_if</code> 是等价的。当然，在这个例子，标签分发并没有使用 <code>enable_if</code> 显得方便。作为一种可以替代 <code>enable_if</code> 的通用惯用法，你还是需要了解一下。</p><p>另外，如果我们用 <code>void_t</code> 那个版本的 <code>has_reserve</code> 模板的话，由于模板的实例会继承 <code>false_type</code> 或 <code>true_type</code> 之一，代码可以进一步简化为：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr,\n            size_t size)\n{\n  _append(\n    container, ptr, size,\n    has_reserve&lt;C&gt;{});\n}\n</code></pre><h3>静态多态的限制？</h3><p>看到这儿，你可能会怀疑，为什么我们不能像在 Python 之类的语言里一样，直接写下面这样的代码呢？</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr,\n            size_t size)\n{\n  if (has_reserve&lt;C&gt;::value) {\n    container.reserve(\n      container.size() + size);\n  }\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n</code></pre><p>如果你试验一下，就会发现，在 <code>C</code> 类型没有 <code>reserve</code> 成员函数的情况下，编译是不能通过的，会报错。这是因为 C++ 是静态类型的语言，所有的函数、名字必须在编译时被成功解析、确定。在动态类型的语言里，只要语法没问题，缺成员函数要执行到那一行上才会被发现。这赋予了动态类型语言相当大的灵活性；只不过，不能在编译时检查错误，同样也是很多人对动态类型语言的抱怨所在……</p><p>那在 C++ 里，我们有没有更好的办法呢？实际上是有的。具体方法，下回分解。</p><h2>内容小结</h2><p>今天我们介绍了 SFINAE 和它的一些主要惯用法。虽然随着 C++ 的演化，SFINAE 的重要性有降低的趋势，但我们仍需掌握其基本概念，才能理解使用了这一技巧的模板代码。</p><h2>课后思考</h2><p>这一讲的内容应该仍然是很烧脑的。请你务必试验一下文中的代码，加深对这些概念的理解。同样，有任何问题和想法，可以留言与我交流。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Substitution failure is not an error”. <a href=\"https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\">https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “Variadic functions”. <a href=\"https://en.cppreference.com/w/c/variadic\">https://en.cppreference.com/w/c/variadic</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “变参数函数”. <a href=\"https://zh.cppreference.com/w/c/variadic\">https://zh.cppreference.com/w/c/variadic</a> </span></p><p><span class=\"reference\">[3] cppreference.com, “std::enable_if”. <a href=\"https://en.cppreference.com/w/cpp/types/enable_if\">https://en.cppreference.com/w/cpp/types/enable_if</a> </span></p><p><span class=\"reference\">[3a] cppreference.com, “std::enable_if”. <a href=\"https://zh.cppreference.com/w/cpp/types/enable_if\">https://zh.cppreference.com/w/cpp/types/enable_if</a> </span></p><p><span class=\"reference\">[4] cppreference.com, “std::declval”. <a href=\"https://en.cppreference.com/w/cpp/utility/declval\">https://en.cppreference.com/w/cpp/utility/declval</a> </span></p><p><span class=\"reference\">[4a] cppreference.com, “std::declval”. <a href=\"https://zh.cppreference.com/w/cpp/utility/declval\">https://zh.cppreference.com/w/cpp/utility/declval</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “std::void_t”. <a href=\"https://en.cppreference.com/w/cpp/types/void_t\">https://en.cppreference.com/w/cpp/types/void_t</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “std::void_t”. <a href=\"https://zh.cppreference.com/w/cpp/types/void_t\">https://zh.cppreference.com/w/cpp/types/void_t</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “Partial template specialization”. <a href=\"https://en.cppreference.com/w/cpp/language/partial_specialization\">https://en.cppreference.com/w/cpp/language/partial_specialization</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “部分模板特化”. <a href=\"https://zh.cppreference.com/w/cpp/language/partial_specialization\">https://zh.cppreference.com/w/cpp/language/partial_specialization</a> </span></p>","neighbors":{"left":{"article_title":"13 | 编译期能做些什么？一个完整的计算世界","id":181608},"right":{"article_title":"15 | constexpr：一个常态的世界","id":182902}}},{"article_id":182902,"article_title":"15 | constexpr：一个常态的世界","article_content":"<p>你好，我是吴咏炜。</p><p>我们已经连续讲了几讲比较累人的编译期编程了。今天我们还是继续这个话题，但是，相信今天学完之后，你会感觉比之前几讲要轻松很多。C++ 语言里的很多改进，让我们做编译期编程也变得越来越简单了。</p><h2>初识 constexpr</h2><p>我们先来看一些例子：</p><pre><code class=\"language-c++\">int sqr(int n)\n{\n  return n * n;\n}\n\nint main()\n{\n  int a[sqr(3)];\n}\n</code></pre><p>想一想，这个代码合法吗？</p><p>看过之后，再想想这个代码如何？</p><pre><code class=\"language-c++\">int sqr(int n)\n{\n  return n * n;\n}\n\nint main()\n{\n  const int n = sqr(3);\n  int a[n];\n}\n</code></pre><p>还有这个？</p><pre><code class=\"language-c++\">#include &lt;array&gt;\n\nint sqr(int n)\n{\n  return n * n;\n}\n\nint main()\n{\n  std::array&lt;int, sqr(3)&gt; a;\n}\n</code></pre><p>此外，我们前面模板元编程里的那些类里的 <code>static const int</code> 什么的，你认为它们能用在上面的几种情况下吗？</p><p>如果以上问题你都知道正确的答案，那恭喜你，你对 C++ 的理解已经到了一个不错的层次了。但问题依然在那里：这些问题的答案不直观。并且，我们需要一个比模板元编程更方便的进行编译期计算的方法。</p><p>在 C++11 引入、在 C++14 得到大幅改进的 <code>constexpr</code> 关键字就是为了解决这些问题而诞生的。它的字面意思是 constant expression，常量表达式。存在两类 <code>constexpr</code> 对象：</p><!-- [[[read_end]]] --><ul>\n<li><code>constexpr</code> 变量（唉……😓）</li>\n<li><code>constexpr</code> 函数</li>\n</ul><p>一个 <code>constexpr</code> 变量是一个编译时完全确定的常数。一个 <code>constexpr</code> 函数至少对于某一组实参可以在编译期间产生一个编译期常数。</p><p>注意一个 <code>constexpr</code> 函数不保证在所有情况下都会产生一个编译期常数（因而也是可以作为普通函数来使用的）。编译器也没法通用地检查这点。编译器唯一强制的是：</p><ul>\n<li><code>constexpr</code> 变量必须立即初始化</li>\n<li>初始化只能使用字面量或常量表达式，后者不允许调用任何非 <code>constexpr</code> 函数</li>\n</ul><p><code>constexpr</code> 的实际规则当然稍微更复杂些，而且随着 C++ 标准的演进也有着一些变化，特别是对 <code>constexpr</code> 函数如何实现的要求在慢慢放宽。要了解具体情况包括其在不同 C++ 标准中的限制，可以查看参考资料 <span class=\"orange\">[1]</span>。下面我们也会回到这个问题略作展开。</p><p>拿 <code>constexpr</code> 来改造开头的例子，下面的代码就完全可以工作了：</p><pre><code class=\"language-c++\">#include &lt;array&gt;\n\nconstexpr int sqr(int n)\n{\n  return n * n;\n}\n\nint main()\n{\n  constexpr int n = sqr(3);\n  std::array&lt;int, n&gt; a;\n  int b[n];\n}\n</code></pre><p>要检验一个 <code>constexpr</code> 函数能不能产生一个真正的编译期常量，可以把结果赋给一个 <code>constexpr</code> 变量。成功的话，我们就确认了，至少在这种调用情况下，我们能真正得到一个编译期常量。</p><h2>constexpr 和编译期计算</h2><p>上面这些当然有点用。但如果只有这点用的话，就不值得我专门来写一讲了。更强大的地方在于，使用编译期常量，就跟我们之前的那些类模板里的 <code>static const int</code> 变量一样，是可以进行编译期计算的。</p><p>以<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 提到的阶乘函数为例，和那个版本基本等价的写法是：</p><pre><code class=\"language-c++\">constexpr int factorial(int n)\n{\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\n</code></pre><p>然后，我们用下面的代码可以验证我们确实得到了一个编译期常量：</p><pre><code class=\"language-c++\">int main()\n{\n  constexpr int n = factorial(10);\n  printf(\"%d\\n\", n);\n}\n</code></pre><p>编译可以通过，同时，如果我们看产生的汇编代码的话，一样可以直接看到常量 3628800。</p><p>这里有一个问题：在这个 <code>constexpr</code> 函数里，是不能写 <code>static_assert(n &gt;= 0)</code> 的。一个 <code>constexpr</code> 函数仍然可以作为普通函数使用——显然，传入一个普通 <code>int</code> 是不能使用静态断言的。替换方法是在 <code>factorial</code> 的实现开头加入：</p><pre><code class=\"language-c++\">  if (n &lt; 0) {\n    throw std::invalid_argument(\n      \"Arg must be non-negative\");\n  }\n</code></pre><p>如果你在 <code>main</code> 里写 <code>constexpr int n = factorial(-1);</code> 的话，就会看到编译器报告抛出异常导致无法得到一个常量表达式。建议你自己尝试一下。</p><h2>constexpr 和 const</h2><p>初学 <code>constexpr</code> 时，一个很可能有的困惑是，它跟 <code>const</code> 用法上的区别到底是什么。产生这种困惑是正常的，毕竟 <code>const</code> 是个重载了很多不同含义的关键字。</p><p><code>const</code> 的原本和基础的含义，自然是表示它修饰的内容不会变化，如：</p><pre><code class=\"language-c++\">const int n = 1:\nn = 2;  // 出错！\n</code></pre><p>注意 <code>const</code> 在类型声明的不同位置会产生不同的结果。对于常见的 <code>const char*</code> 这样的类型声明，意义和 <code>char const*</code> 相同，是指向常字符的指针，指针指向的内容不可更改；但和 <code>char * const</code> 不同，那代表指向字符的常指针，指针本身不可更改。本质上，<code>const</code> 用来表示一个<strong>运行时常量</strong>。</p><p>在 C++ 里，<code>const</code> 后面渐渐带上了现在的 <code>constexpr</code> 用法，也代表<strong>编译期常数</strong>。现在——在有了 <code>constexpr</code> 之后——我们应该使用 <code>constexpr</code> 在这些用法中替换 <code>const</code> 了。从编译器的角度，为了向后兼容性，<code>const</code> 和 <code>constexpr</code> 在很多情况下还是等价的。但有时候，它们也有些细微的区别，其中之一为是否内联的问题。</p><h3>内联变量</h3><p>C++17 引入了内联（inline）变量的概念，允许在头文件中定义内联变量，然后像内联函数一样，只要所有的定义都相同，那变量的定义出现多次也没有关系。对于类的静态数据成员，<code>const</code> 缺省是不内联的，而 <code>constexpr</code> 缺省就是内联的。这种区别在你用 <code>&amp;</code> 去取一个 <code>const int</code> 值的地址、或将其传到一个形参类型为 <code>const int&amp;</code> 的函数去的时候（这在 C++ 文档里的行话叫 ODR-use），就会体现出来。</p><p>下面是个合法的完整程序：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n\nstruct magic {\n  static const int number = 42;\n};\n\nint main()\n{\n  std::cout &lt;&lt; magic::number\n            &lt;&lt; std::endl;\n}\n</code></pre><p>我们稍微改一点：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct magic {\n  static const int number = 42;\n};\n\nint main()\n{\n  std::vector&lt;int&gt; v;\n  // 调用 push_back(const T&amp;)\n  v.push_back(magic::number);\n  std::cout &lt;&lt; v[0] &lt;&lt; std::endl;\n}\n</code></pre><p>程序在链接时就会报错了，说找不到 <code>magic::number</code>（注意：MSVC 缺省不报错，但使用标准模式——<code>/Za</code> 命令行选项——也会出现这个问题）。这是因为 ODR-use 的类静态常量也需要有一个定义，在没有内联变量之前需要在某一个源代码文件（非头文件）中这样写：</p><pre><code class=\"language-c++\">const int magic::number = 42;\n</code></pre><p>必须正正好好一个，多了少了都不行，所以叫 one definition rule。内联函数，现在又有了内联变量，以及模板，则不受这条规则限制。</p><p>修正这个问题的简单方法是把 <code>magic</code> 里的 <code>static const</code> 改成 <code>static constexpr</code> 或 <code>static inline const</code>。前者可行的原因是，类的静态 constexpr 成员变量默认就是内联的。const 常量和类外面的 constexpr 变量不默认内联，需要手工加 <code>inline</code> 关键字才会变成内联。</p><h3>constexpr 变量模板</h3><p>变量模板是 C++14 引入的新概念。之前我们需要用类静态数据成员来表达的东西，使用变量模板可以更简洁地表达。<code>constexpr</code> 很合适用在变量模板里，表达一个和某个类型相关的编译期常量。由此，type traits 都获得了一种更简单的表示方式。再看一下我们在<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 用过的例子：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\ninline constexpr bool\n  is_trivially_destructible_v =\n    is_trivially_destructible&lt;\n      T&gt;::value;\n</code></pre><p>了解了变量也可以是模板之后，上面这个代码就很容易看懂了吧？这只是一个小小的语法糖，允许我们把 <code>is_trivially_destructible&lt;T&gt;::value</code> 写成 <code>is_trivially_destructible_v&lt;T&gt;</code>。</p><h3>constexpr 变量仍是 const</h3><p>一个 <code>constexpr</code> 变量仍然是 const 常类型。需要注意的是，就像 <code>const char*</code> 类型是指向常量的指针、自身不是 const 常量一样，下面这个表达式里的 <code>const</code> 也是不能缺少的：</p><pre><code class=\"language-c++\">constexpr int a = 42;\nconstexpr const int&amp; b = a;\n</code></pre><p>第二行里，<code>constexpr</code> 表示 <code>b</code> 是一个编译期常量，<code>const</code> 表示这个引用是常量引用。去掉这个 <code>const</code> 的话，编译器就会认为你是试图将一个普通引用绑定到一个常数上，报一个类似下面的错误信息：</p><blockquote>\n<p><strong>error:</strong> binding reference of type ‘<strong>int&amp;</strong>’ to ‘<strong>const int</strong>’ discards qualifiers</p>\n</blockquote><p>如果按照 const 位置的规则，<code>constexpr const int&amp; b</code> 实际该写成 <code>const int&amp; constexpr b</code>。不过，<code>constexpr</code> 不需要像 <code>const</code> 一样有复杂的组合，因此永远是写在类型前面的。</p><h2>constexpr 构造函数和字面类型</h2><p>一个合理的 <code>constexpr</code> 函数，应当至少对于某一组编译期常量的输入，能得到编译期常量的结果。为此，对这个函数也是有些限制的：</p><ul>\n<li>最早，<code>constexpr</code> 函数里连循环都不能有，但在 C++14 放开了。</li>\n<li>目前，<code>constexpr</code> 函数仍不能有 <code>try … catch</code> 语句和 <code>asm</code> 声明，但到 C++20 会放开。</li>\n<li><code>constexpr</code> 函数里不能使用 <code>goto</code> 语句。</li>\n<li>等等。</li>\n</ul><p>一个有意思的情况是一个类的构造函数。如果一个类的构造函数里面只包含常量表达式、满足对 <code>constexpr</code> 函数的限制的话（这也意味着，里面不可以有任何动态内存分配），并且类的析构函数是平凡的，那这个类就可以被称为是一个字面类型。换一个角度想，对 <code>constexpr</code> 函数——包括字面类型构造函数——的要求是，得让编译器能在编译期进行计算，而不会产生任何“副作用”，比如内存分配、输入、输出等等。</p><p>为了全面支持编译期计算，C++14 开始，很多标准类的构造函数和成员函数已经被标为 <code>constexpr</code>，以便在编译期使用。当然，大部分的容器类，因为用到了动态内存分配，不能成为字面类型。下面这些不使用动态内存分配的字面类型则可以在常量表达式中使用：</p><ul>\n<li><code>array</code></li>\n<li><code>initializer_list</code></li>\n<li><code>pair</code></li>\n<li><code>tuple</code></li>\n<li><code>string_view</code></li>\n<li><code>optional</code></li>\n<li><code>variant</code></li>\n<li><code>bitset</code></li>\n<li><code>complex</code></li>\n<li><code>chrono::duration</code></li>\n<li><code>chrono::time_point</code></li>\n<li>…</li>\n</ul><p>下面这个玩具例子，可以展示上面的若干类及其成员函数的行为：</p><pre><code class=\"language-c++\">#include &lt;array&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string_view&gt;\n\nusing namespace std;\n\nint main()\n{\n  constexpr string_view sv{\"hi\"};\n  constexpr pair pr{sv[0], sv[1]};\n  constexpr array a{pr.first, pr.second};\n  constexpr int n1 = a[0];\n  constexpr int n2 = a[1];\n  cout &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; '\\n';\n}\n</code></pre><p>编译器可以在编译期即决定 <code>n1</code> 和 <code>n2</code> 的数值；从最后结果的角度，上面程序就是输出了两个整数而已。</p><h2>if constexpr</h2><p>上一讲的结尾，我们给出了一个在类型参数 <code>C</code> 没有 <code>reserve</code> 成员函数时不能编译的代码：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr,\n            size_t size)\n{\n  if (has_reserve&lt;C&gt;::value) {\n    container.reserve(\n      container.size() + size);\n  }\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n</code></pre><p>在 C++17 里，我们只要在 <code>if</code> 后面加上 <code>constexpr</code>，代码就能工作了 <span class=\"orange\">[2]</span>。当然，它要求括号里的条件是个编译期常量。满足这个条件后，标签分发、<code>enable_if</code> 那些技巧就不那么有用了。显然，使用 <code>if constexpr</code> 能比使用其他那些方式，写出更可读的代码……</p><h2>output_container.h 解读</h2><p>到了今天，我们终于把 output_container.h（<span class=\"orange\">[3]</span>）用到的 C++ 语法特性都讲过了，我们就拿里面的代码来讲解一下，让你加深对这些特性的理解。</p><pre><code class=\"language-c++\">// Type trait to detect std::pair\ntemplate &lt;typename T&gt;\nstruct is_pair : std::false_type {};\ntemplate &lt;typename T, typename U&gt;\nstruct is_pair&lt;std::pair&lt;T, U&gt;&gt;\n  : std::true_type {};\ntemplate &lt;typename T&gt;\ninline constexpr bool is_pair_v =\n  is_pair&lt;T&gt;::value;\n</code></pre><p>这段代码利用模板特化（<a href=\"https://time.geekbang.org/column/article/179363\">[第 12 讲]</a> 、<a href=\"https://time.geekbang.org/column/article/181636\">[第 14 讲]</a>）和 <code>false_type</code>、<code>true_type</code> 类型（<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a>），定义了 <code>is_pair</code>，用来检测一个类型是不是 <code>pair</code>。随后，我们定义了内联 <code>constexpr</code> 变量（本讲）<code>is_pair_v</code>，用来简化表达。</p><pre><code class=\"language-c++\">// Type trait to detect whether an\n// output function already exists\ntemplate &lt;typename T&gt;\nstruct has_output_function {\n  template &lt;class U&gt;\n  static auto output(U* ptr)\n    -&gt; decltype(\n      std::declval&lt;std::ostream&amp;&gt;()\n        &lt;&lt; *ptr,\n      std::true_type());\n  template &lt;class U&gt;\n  static std::false_type\n  output(...);\n  static constexpr bool value =\n    decltype(\n      output&lt;T&gt;(nullptr))::value;\n};\ntemplate &lt;typename T&gt;\ninline constexpr bool\n  has_output_function_v =\n    has_output_function&lt;T&gt;::value;\n</code></pre><p>这段代码使用 SFINAE 技巧（<a href=\"https://time.geekbang.org/column/article/181636\">[第 14 讲]</a>），来检测模板参数 <code>T</code> 的对象是否已经可以直接输出到 <code>ostream</code>。然后，一样用一个内联 <code>constexpr</code> 变量来简化表达。</p><pre><code class=\"language-c++\">// Output function for std::pair\ntemplate &lt;typename T, typename U&gt;\nstd::ostream&amp; operator&lt;&lt;(\n  std::ostream&amp; os,\n  const std::pair&lt;T, U&gt;&amp; pr);\n</code></pre><p>再然后我们声明了一个 <code>pair</code> 的输出函数（标准库没有提供这个功能）。我们这儿只是声明，是因为我们这儿有两个输出函数，且可能互相调用。所以，我们要先声明其中之一。</p><p>下面会看到，<code>pair</code> 的通用输出形式是“(x, y)”。</p><pre><code class=\"language-c++\">// Element output function for\n// containers that define a key_type\n// and have its value type as\n// std::pair\ntemplate &lt;typename T, typename Cont&gt;\nauto output_element(\n  std::ostream&amp; os,\n  const T&amp; element, const Cont&amp;,\n  const std::true_type)\n  -&gt; decltype(\n    std::declval&lt;\n      typename Cont::key_type&gt;(),\n    os);\n// Element output function for other\n// containers\ntemplate &lt;typename T, typename Cont&gt;\nauto output_element(\n  std::ostream&amp; os,\n  const T&amp; element, const Cont&amp;,\n  ...) -&gt; decltype(os);\n</code></pre><p>对于容器成员的输出，我们也声明了两个不同的重载。我们的意图是，如果元素的类型是 <code>pair</code> 并且容器定义了一个 <code>key_type</code> 类型，我们就认为遇到了关联容器，输出形式为“x =&gt; y”（而不是“(x, y)”）。</p><pre><code class=\"language-c++\">// Main output function, enabled\n// only if no output function\n// already exists\ntemplate &lt;\n  typename T,\n  typename = std::enable_if_t&lt;\n    !has_output_function_v&lt;T&gt;&gt;&gt;\nauto operator&lt;&lt;(std::ostream&amp; os,\n                const T&amp; container)\n  -&gt; decltype(container.begin(),\n              container.end(), os)\n…\n</code></pre><p>主输出函数的定义。注意这儿这个函数的启用有两个不同的 SFINAE 条件：</p><ul>\n<li>用 <code>decltype</code> 返回值的方式规定了被输出的类型必须有 <code>begin()</code> 和 <code>end()</code> 成员函数。</li>\n<li>用 <code>enable_if_t</code> 规定了只在被输出的类型没有输出函数时才启用这个输出函数。否则，对于 <code>string</code> 这样的类型，编译器发现有两个可用的输出函数，就会导致编译出错。</li>\n</ul><p>我们可以看到，用 <code>decltype</code> 返回值的方式比较简单，不需要定义额外的模板。但表达否定的条件还是要靠 <code>enable_if</code>。此外，因为此处是需要避免有二义性的重载，constexpr 条件语句帮不了什么忙。</p><pre><code class=\"language-c++\">  using element_type =\n    decay_t&lt;decltype(\n      *container.begin())&gt;;\n  constexpr bool is_char_v =\n    is_same_v&lt;element_type, char&gt;;\n  if constexpr (!is_char_v) {\n    os &lt;&lt; \"{ \";\n  }\n</code></pre><p>对非字符类型，我们在开始输出时，先输出“{ ”。这儿使用了 <code>decay_t</code>，是为了把类型里的引用和 const/volatile 修饰去掉，只剩下值类型。如果容器里的成员是 <code>char</code>，这儿会把 <code>char&amp;</code> 和 <code>const char&amp;</code> 还原成 <code>char</code>。</p><p>后面的代码就比较简单了。可能唯一需要留意的是下面这句：</p><pre><code class=\"language-c++\">  output_element(\n    os, *it, container,\n    is_pair&lt;element_type&gt;());\n</code></pre><p>这儿我们使用了标签分发技巧来输出容器里的元素。要记得，<code>output_element</code> 不纯粹使用标签分发，还会检查容器是否有 <code>key_type</code> 成员类型。</p><pre><code class=\"language-c++\">template &lt;typename T, typename Cont&gt;\nauto output_element(\n  std::ostream&amp; os,\n  const T&amp; element, const Cont&amp;,\n  const std::true_type)\n  -&gt; decltype(\n    std::declval&lt;\n      typename Cont::key_type&gt;(),\n    os)\n{\n  os &lt;&lt; element.first &lt;&lt; \" =&gt; \"\n     &lt;&lt; element.second;\n  return os;\n}\n\ntemplate &lt;typename T, typename Cont&gt;\nauto output_element(\n  std::ostream&amp; os,\n  const T&amp; element, const Cont&amp;,\n  ...) -&gt; decltype(os)\n{\n  os &lt;&lt; element;\n  return os;\n}\n</code></pre><p><code>output_element</code> 的两个重载的实现都非常简单，应该不需要解释了。</p><pre><code class=\"language-c++\">template &lt;typename T, typename U&gt;\nstd::ostream&amp; operator&lt;&lt;(\n  std::ostream&amp; os,\n  const std::pair&lt;T, U&gt;&amp; pr)\n{\n  os &lt;&lt; '(' &lt;&lt; pr.first &lt;&lt; \", \"\n     &lt;&lt; pr.second &lt;&lt; ')';\n  return os;\n}\n</code></pre><p>同样，<code>pair</code> 的输出的实现也非常简单。</p><p>唯一需要留意的，是上面三个函数的输出内容可能还是容器，因此我们要将其实现放在后面，确保它能看到我们的通用输出函数。</p><p>要看一下用到 output_container 的例子，可以回顾<a href=\"https://time.geekbang.org/column/article/173167\">[第 4 讲]</a> 和<a href=\"https://time.geekbang.org/column/article/174434\">[第 5 讲]</a>。</p><h2>内容小结</h2><p>本讲我们介绍了编译期常量表达式和编译期条件语句，可以看到，这两种新特性对编译期编程有了很大的改进，可以让代码变得更直观。最后我们讨论了我们之前用到的容器输出函数 output_container 的实现，里面用到了多种我们目前讨论过的编译期编程技巧。</p><h2>课后思考</h2><p>请你仔细想一想：</p><ol>\n<li>如果没有 constexpr 条件语句，这个容器输出函数需要怎样写？</li>\n<li>这种不使用 constexpr 的写法有什么样的缺点？推而广之，constexpr 条件语句的意义是什么？</li>\n</ol><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “constexpr specifier”. <a href=\"https://en.cppreference.com/w/cpp/language/constexpr\">https://en.cppreference.com/w/cpp/language/constexpr</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “constexpr 说明符”. <a href=\"https://zh.cppreference.com/w/cpp/language/constexpr\">https://zh.cppreference.com/w/cpp/language/constexpr</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “if statement”, section “constexpr if”. <a href=\"https://en.cppreference.com/w/cpp/language/if\">https://en.cppreference.com/w/cpp/language/if</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “if 语句”, “constexpr if” 部分. <a href=\"https://zh.cppreference.com/w/cpp/language/if\">https://zh.cppreference.com/w/cpp/language/if</a> </span></p><p><span class=\"reference\">[3] 吴咏炜, output_container. <a href=\"https://github.com/adah1972/output_container/blob/geektime/output_container.h\">https://github.com/adah1972/output_container/blob/geektime/output_container.h</a> </span></p>","neighbors":{"left":{"article_title":"14 | SFINAE：不是错误的替换失败是怎么回事?","id":181636},"right":{"article_title":"16 | 函数对象和lambda：进入函数式编程","id":184018}}},{"article_id":184018,"article_title":"16 | 函数对象和lambda：进入函数式编程","article_content":"<p>你好，我是吴咏炜。</p><p>本讲我们将介绍函数对象，尤其是匿名函数对象——lambda 表达式。今天的内容说难不难，但可能跟你的日常思维方式有较大的区别，建议你一定要试验一下文中的代码（使用 xeus-cling 的同学要注意：xeus-cling 似乎不太喜欢有 lambda 的代码😓；遇到有问题时，还是只能回到普通的编译执行方式了）。</p><h2>C++98 的函数对象</h2><p>函数对象（function object）<span class=\"orange\">[1]</span> 自 C++98 开始就已经被标准化了。从概念上来说，函数对象是一个可以被当作函数来用的对象。它有时也会被叫做 functor，但这个术语在范畴论里有着完全不同的含义，还是不用为妙——否则玩函数式编程的人可能会朝着你大皱眉头的。</p><p>下面的代码定义了一个简单的加 <em>n</em> 的函数对象类（根据一般的惯例，我们使用了 <code>struct</code> 关键字而不是 <code>class</code> 关键字）：</p><pre><code class=\"language-c++\">struct adder {\n  adder(int n) : n_(n) {}\n  int operator()(int x) const\n  {\n    return x + n_;\n  }\nprivate:\n  int n_;\n};\n</code></pre><p>它看起来相当普通，唯一有点特别的地方就是定义了一个 <code>operator()</code>，这个运算符允许我们像调用函数一样使用小括号的语法。随后，我们可以定义一个实际的函数对象，如 C++11 形式的：</p><!-- [[[read_end]]] --><pre><code class=\"language-c++\">auto add_2 = adder(2);\n</code></pre><p>或 C++98 形式的：</p><pre><code class=\"language-c++\">adder add_2(2);\n</code></pre><p>得到的结果 <code>add_2</code> 就可以当作一个函数来用了。你如果写下 <code>add_2(5)</code> 的话，就会得到结果 7。</p><p>C++98 里也定义了少数高阶函数：你可以传递一个函数对象过去，结果得到一个新的函数对象。最典型的也许是目前已经从 C++17 标准里移除的 <code>bind1st</code> 和 <code>bind2nd</code> 了（在 &lt;functional&gt; 头文件中提供）：</p><pre><code class=\"language-c++\">auto add_2 = bind2nd(plus&lt;int&gt;(), 2);\n</code></pre><p>这样产生的 <code>add_2</code> 功能和前面相同，是把参数 <code>2</code> 当作第二个参数绑定到函数对象 <code>plus&lt;int&gt;</code>（它的 <code>operator()</code> 需要两个参数）上的结果。当然，<code>auto</code> 在 C++98 里是没有的，结果要赋给一个变量就有点别扭了，得写成：</p><pre><code class=\"language-c++\">binder2nd&lt;plus&lt;int&gt; &gt; add_2(\n  plus&lt;int&gt;(), 2);\n</code></pre><p>因此，在 C++98 里我们通常会直接使用绑定的结果：</p><pre><code class=\"language-c++\">#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector v{1, 2, 3, 4, 5};\ntransform(v.begin(), v.end(),\n          v.begin(),\n          bind2nd(plus&lt;int&gt;(), 2));\n</code></pre><p>上面的代码会将容器里的每一项数值都加上 2（<code>transform</code> 函数模板在 &lt;algorithm&gt; 头文件中提供）。可以验证结果：</p><pre><code class=\"language-c++\">v\n</code></pre><blockquote>\n<p><code>{ 3, 4, 5, 6, 7 }</code></p>\n</blockquote><h3>函数的指针和引用</h3><p>除非你用一个引用模板参数来捕捉函数类型，传递给一个函数的函数实参会退化成为一个函数指针。不管是函数指针还是函数引用，你也都可以当成函数对象来用。</p><p>假设我们有下面的函数定义：</p><pre><code class=\"language-c++\">int add_2(int x)\n{\n  return x + 2;\n};\n</code></pre><p>如果我们有下面的模板声明：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nauto test1(T fn)\n{\n  return fn(2);\n}\n\ntemplate &lt;typename T&gt;\nauto test2(T&amp; fn)\n{\n  return fn(2);\n}\n\ntemplate &lt;typename T&gt;\nauto test3(T* fn)\n{\n  return (*fn)(2);\n}\n</code></pre><p>当我们拿 <code>add_2</code> 去调用这三个函数模板时，<code>fn</code> 的类型将分别被推导为 <code>int (*)(int)</code>、<code>int (&amp;)(int)</code> 和 <code>int (*)(int)</code>。不管我们得到的是指针还是引用，我们都可以直接拿它当普通的函数用。当然，在函数指针的情况下，我们直接写 <code>*value</code> 也可以。因而上面三个函数拿 <code>add_2</code> 作为实参调用的结果都是 <code>4</code>。</p><p>很多接收函数对象的地方，也可以接收函数的指针或引用。但在个别情况下，需要通过函数对象的类型来区分函数对象的时候，就不能使用函数指针或引用了——原型相同的函数，它们的类型也是相同的。</p><h2>Lambda 表达式</h2><p>Lambda 表达式 <span class=\"orange\">[2]</span> 是一个源自阿隆佐·邱奇（Alonzo Church）——艾伦·图灵（Alan Turing）的老师——的术语。邱奇创立了 λ 演算 <span class=\"orange\">[3]</span>，后来被证明和图灵机是等价的。</p><p>我们先不看数学上的 λ 表达式，看一下上一节给出的代码在使用 lambda 表达式时可以如何简化。</p><pre><code class=\"language-c++\">auto add_2 = [](int x) {\n  return x + 2;\n};\n</code></pre><p>显然，定义 <code>add_2</code> 不再需要定义一个额外的类型了，我们可以直接写出它的定义。理解它只需要注意下面几点：</p><ul>\n<li>Lambda 表达式以一对中括号开始（中括号中是可以有内容的；稍后我们再说）</li>\n<li>跟函数定义一样，我们有参数列表</li>\n<li>跟正常的函数定义一样，我们会有一个函数体，里面会有 <code>return</code> 语句</li>\n<li>Lambda 表达式一般不需要说明返回值（相当于 <code>auto</code>）；有特殊情况需要说明时，则应使用箭头语法的方式（参见<a href=\"https://time.geekbang.org/column/article/176850\">[第 8 讲]</a>）：<code>[]​(int x) -&gt; int { … }</code></li>\n<li>每个 lambda 表达式都有一个全局唯一的类型，要精确捕捉 lambda 表达式到一个变量中，只能通过 <code>auto</code> 声明的方式</li>\n</ul><p>当然，我们想要定义一个通用的 <code>adder</code> 也不难：</p><pre><code class=\"language-c++\">auto adder = [](int n) {\n  return [n](int x) {\n    return x + n;\n  };\n};\n</code></pre><p>这次我们直接返回了一个 lambda 表达式，并且中括号中写了 <code>n</code> 来捕获变量 <code>n</code> 的数值。这个函数的实际效果和前面的 <code>adder</code> 函数对象完全一致。也就是说，捕获 <code>n</code> 的效果相当于在一个函数对象中用成员变量存储其数值。</p><p>纯粹为了满足你可能有的好奇心，上面的 <code>adder</code> 相当于这样一个 λ 表达式：</p><p>$$<br>\n\\mathrm{adder} = \\lambda n.(\\lambda x.(+ \\ x \\ n))<br>\n$$</p><p>如果你去学 Lisp 或 Scheme 的话，你就会发现这些语言和 λ 表达式几乎是一一映射了。在 C++ 里，表达虽然稍微啰嗦一点，但也比较接近了。用我上面的 <code>adder</code> ，就可以得到类似于函数式编程语言里的 currying <span class=\"orange\">[4]</span> 的效果——把一个操作（此处是加法）分成几步来完成。没见过函数式编程的，可能对下面的表达式感到奇怪吧：</p><pre><code class=\"language-c++\">auto seven = adder(2)(5);\n</code></pre><p>不过，最常见的情况是，写匿名函数就是希望不需要起名字。以前面的把所有容器元素值加 2 的操作为例，使用匿名函数可以得到更简洁可读的代码：</p><pre><code class=\"language-c++\">transform(v.begin(), v.end(),\n          v.begin(),\n          [](int x) {\n            return x + 2;\n          });\n</code></pre><p>到了可以使用 ranges（已在 C++20 标准化）的时候，代码可以更短、更灵活。这个我们就留到后面再说了。</p><p>一个 lambda 表达式除了没有名字之外，还有一个特点是你可以立即进行求值。这就使得我们可以把一段独立的代码封装起来，达到更干净、表意的效果。</p><p>先看一个简单的例子：</p><pre><code class=\"language-c++\">[](int x) { return x * x; }(3)\n</code></pre><p>这个表达式的结果是 3 的平方 9。即使这个看似无聊的例子，都是有意义的，因为它免去了我们定义一个 constexpr 函数的必要。只要能满足 constexpr 函数的条件，一个 lambda 表达式默认就是 constexpr 函数。</p><p>另外一种用途是解决多重初始化路径的问题。假设你有这样的代码：</p><pre><code class=\"language-c++\">Obj obj;\nswitch (init_mode) {\ncase init_mode1:\n  obj = Obj(…);\n  break;\ncase init_mode2;\n  obj = Obj(…);\n  break;\n…\n}\n</code></pre><p>这样的代码，实际上是调用了默认构造函数、带参数的构造函数和（移动）赋值函数：既可能有性能损失，也对 <code>Obj</code> 提出了有默认构造函数的额外要求。对于这样的代码，有一种重构意见是把这样的代码分离成独立的函数。不过，有时候更直截了当的做法是用一个 lambda 表达式来进行改造，既可以提升性能（不需要默认函数或拷贝/移动），又让初始化部分显得更清晰：</p><pre><code class=\"language-c++\">auto obj = [init_mode]() {\n  switch (init_mode) {\n  case init_mode1:\n    return Obj(…);\n    break;\n  case init_mode2:\n    return Obj(…);\n    break;\n  …\n  }\n}();\n</code></pre><h3>变量捕获</h3><p>现在我们来细看一下 lambda 表达式中变量捕获的细节。</p><p>变量捕获的开头是可选的默认捕获符 <code>=</code> 或 <code>&amp;</code>，表示会自动按值或按引用捕获用到的本地变量，然后后面可以跟（逗号分隔）：</p><ul>\n<li>本地变量名标明对其按值捕获（不能在默认捕获符 <code>=</code> 后出现；因其已自动按值捕获所有本地变量）</li>\n<li><code>&amp;</code> 加本地变量名标明对其按引用捕获（不能在默认捕获符 <code>&amp;</code> 后出现；因其已自动按引用捕获所有本地变量）</li>\n<li><code>this</code> 标明按引用捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况）；注意默认捕获符 <code>=</code> 和 <code>&amp;</code> 号可以自动捕获 <code>this</code>（并且在 C++20 之前，在 <code>=</code> 后写 <code>this</code> 会导致出错）</li>\n<li><code>*this</code> 标明按值捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况；C++17 新增语法）</li>\n<li><code>变量名 = 表达式</code> 标明按值捕获表达式的结果（可理解为 <code>auto 变量名 = 表达式</code>）</li>\n<li><code>&amp;变量名 = 表达式</code> 标明按引用捕获表达式的结果（可理解为 <code>auto&amp; 变量名 = 表达式</code>）</li>\n</ul><p>从工程的角度，大部分情况不推荐使用默认捕获符。更一般化的一条工程原则是：<strong>显式的代码比隐式的代码更容易维护。</strong>当然，在这条原则上走多远是需要权衡的，你也不愿意写出非常啰嗦的代码吧？否则的话，大家就全部去写 C 了。</p><p>一般而言，按值捕获是比较安全的做法。按引用捕获时则需要更小心些，必须能够确保被捕获的变量和 lambda 表达式的生命期至少一样长，并在有下面需求之一时才使用：</p><ul>\n<li>需要在 lambda 表达式中修改这个变量并让外部观察到</li>\n<li>需要看到这个变量在外部被修改的结果</li>\n<li>这个变量的复制代价比较高</li>\n</ul><p>如果希望以移动的方式来捕获某个变量的话，则应考虑 <code>变量名 = 表达式</code> 的形式。表达式可以返回一个 prvalue 或 xvalue，比如可以是 <code>std::move(需移动捕获的变量)</code>。</p><p>上一节我们已经见过简单的按值捕获。下面是一些更多的演示变量捕获的例子。</p><p>按引用捕获：</p><pre><code class=\"language-c++\">vector&lt;int&gt; v1;\nvector&lt;int&gt; v2;\n…\nauto push_data = [&amp;](int n) {\n  // 或使用 [&amp;v1, &amp;v2] 捕捉\n  v1.push_back(n);\n  v2.push_back(n)\n};\n\npush_data(2);\npush_data(3);\n</code></pre><p>这个例子很简单。我们按引用捕获 <code>v1</code> 和 <code>v2</code>，因为我们需要修改它们的内容。</p><p>按值捕获外围对象：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nint get_count()\n{\n  static int count = 0;\n  return ++count;\n}\n\nclass task {\npublic:\n  task(int data) : data_(data) {}\n  auto lazy_launch()\n  {\n    return\n      [*this, count = get_count()]()\n      mutable {\n        ostringstream oss;\n        oss &lt;&lt; \"Done work \" &lt;&lt; data_\n            &lt;&lt; \" (No. \" &lt;&lt; count\n            &lt;&lt; \") in thread \"\n            &lt;&lt; this_thread::get_id()\n            &lt;&lt; '\\n';\n        msg_ = oss.str();\n        calculate();\n      };\n  }\n  void calculate()\n  {\n    this_thread::sleep_for(100ms);\n    cout &lt;&lt; msg_;\n  }\n\nprivate:\n  int data_;\n  string msg_;\n};\n\nint main()\n{\n  auto t = task{37};\n  thread t1{t.lazy_launch()};\n  thread t2{t.lazy_launch()};\n  t1.join();\n  t2.join();\n}\n</code></pre><p>这个例子稍复杂，演示了好几个 lambda 表达式的特性：</p><ul>\n<li><code>mutable</code> 标记使捕获的内容可更改（缺省不可更改捕获的值，相当于定义了 <code>operator()(…) const</code>）；</li>\n<li><code>[*this]</code> 按值捕获外围对象（<code>task</code>）；</li>\n<li><code>[count = get_count()]</code> 捕获表达式可以在生成 lambda 表达式时计算并存储等号后表达式的结果。</li>\n</ul><p>这样，多个线程复制了任务对象，可以独立地进行计算。请自行运行一下代码，并把 <code>*this</code> 改成 <code>this</code>，看看输出会有什么不同。</p><h2>泛型 lambda 表达式</h2><p>函数的返回值可以 auto，但参数还是要一一声明的。在 lambda 表达式里则更进一步，在参数声明时就可以使用 <code>auto</code>（包括 <code>auto&amp;&amp;</code> 等形式）。不过，它的功能也不那么神秘，就是给你自动声明了模板而已。毕竟，在 lambda 表达式的定义过程中是没法写 <code>template</code> 关键字的。</p><p>还是拿例子说话：</p><pre><code class=\"language-c++\">template &lt;typename T1,\n          typename T2&gt;\nauto sum(T1 x, T2 y)\n{\n  return x + y;\n}\n</code></pre><p>跟上面的函数等价的 lambda 表达式是：</p><pre><code class=\"language-c++\">auto sum = [](auto x, auto y)\n{\n  return x + y;\n}\n</code></pre><p>是不是反而更简单了？😂</p><p>你可能要问，这么写有什么用呢？问得好。简单来说，答案是可组合性。上面这个 <code>sum</code>，就跟标准库里的 <code>plus</code> 模板一样，是可以传递给其他接受函数对象的函数的，而 <code>+</code> 本身则不行。下面的例子虽然略有点无聊，也可以演示一下：</p><pre><code class=\"language-c++\">#include &lt;array&gt;    // std::array\n#include &lt;iostream&gt; // std::cout/endl\n#include &lt;numeric&gt;  // std::accumulate\n\nusing namespace std;\n\nint main()\n{\n  array a{1, 2, 3, 4, 5};\n  auto s = accumulate(\n    a.begin(), a.end(), 0,\n    [](auto x, auto y) {\n      return x + y;\n    });\n  cout &lt;&lt; s &lt;&lt; endl;\n}\n</code></pre><p>虽然函数名字叫 <code>accumulate</code>——累加——但它的行为是通过第四个参数可修改的。我们把上面的加号 <code>+</code> 改成星号 <code>*</code>，上面的计算就从从 1 加到 5 变成了算 5 的阶乘了。</p><h2>bind 模板</h2><p>我们上面提到了 <code>bind1st</code> 和 <code>bind2nd</code> 目前已经从 C++ 标准里移除。原因实际上有两个：</p><ul>\n<li>它的功能可以被 lambda 表达式替代</li>\n<li>有了一个更强大的 <code>bind</code> 模板 <span class=\"orange\">[5]</span></li>\n</ul><p>拿我们之前给出的例子：</p><pre><code class=\"language-c++\">transform(v.begin(), v.end(),\n          v.begin(),\n          bind2nd(plus&lt;int&gt;(), 2));\n</code></pre><p>现在我们可以写成：</p><pre><code class=\"language-c++\">using namespace std::\n  placeholders;  // for _1, _2...\ntransform(v.begin(), v.end(),\n          v.begin(),\n          bind(plus&lt;&gt;(), _1, 2));\n</code></pre><p>原先我们只能把一个给定的参数绑定到第一个参数或第二个参数上，现在则可以非常自由地适配各种更复杂的情况！当然，<code>bind</code> 的参数数量，必须是第一个参数（函数对象）所需的参数数量加一。而 <code>bind</code> 的结果的参数数量则没有限制——你可以无聊地写出 <code>bind(plus&lt;&gt;(), _1, _3)(1, 2, 3)</code>，而结果是 4（完全忽略第二个参数）。</p><p>你可能会问，它的功能是不是可以被 lambda 表达式替代呢。回答是“是”。对 <code>bind</code> 只需要稍微了解一下就好——在 C++14 之后的年代里，已经没有什么地方必须要使用 <code>bind</code> 了。</p><h2>function 模板</h2><p>每一个 lambda 表达式都是一个单独的类型，所以只能使用 <code>auto</code> 或模板参数来接收结果。在很多情况下，我们需要使用一个更方便的通用类型来接收，这时我们就可以使用 <code>function</code> 模板 <span class=\"orange\">[6]</span>。<code>function</code> 模板的参数就是函数的类型，一个函数对象放到 <code>function</code> 里之后，外界可以观察到的就只剩下它的参数、返回值类型和执行效果了。注意 <code>function</code> 对象的创建还是比较耗资源的，所以请你只在用 <code>auto</code> 等方法解决不了问题的时候使用这个模板。</p><p>下面是个简单的例子。</p><pre><code class=\"language-c++\">map&lt;string, function&lt;int(int, int)&gt;&gt;\n  op_dict{\n    {\"+\",\n     [](int x, int y) {\n       return x + y;\n     }},\n    {\"-\",\n     [](int x, int y) {\n       return x - y;\n     }},\n    {\"*\",\n     [](int x, int y) {\n       return x * y;\n     }},\n    {\"/\",\n     [](int x, int y) {\n       return x / y;\n     }},\n  };\n</code></pre><p>这儿，由于要把函数对象存到一个 <code>map</code> 里，我们必须使用 <code>function</code> 模板。随后，我们就可以用类似于 <code>op_dict.at(\"+\")(1, 6)</code> 这样的方式来使用 <code>function</code> 对象。这种方式对表达式的解析处理可能会比较有用。</p><h2>内容小结</h2><p>在这一讲中，我们了解了函数对象和 lambda 表达式的基本概念，并简单介绍了 <code>bind</code> 模板和 <code>function</code> 模板。它们在泛型编程和函数式编程中都是重要的基础组成部分，你应该熟练掌握。</p><h2>课后思考</h2><p>请：</p><ol>\n<li>尝试一下，把文章的 lambda 表达式改造成完全不使用 lambda。</li>\n<li>体会一下，lambda 表达式带来了哪些表达上的好处。</li>\n</ol><p>欢迎留言和我分享你的想法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Function object”. <a href=\"https://en.wikipedia.org/wiki/Function_object\">https://en.wikipedia.org/wiki/Function_object</a> </span></p><p><span class=\"reference\">[1a] 维基百科, “函数对象”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\">https://zh.wikipedia.org/zh-cn/函数对象</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Anonymous function”.<a href=\"https://en.wikipedia.org/wiki/Anonymous_function\">https://en.wikipedia.org/wiki/Anonymous_function</a> </span></p><p><span class=\"reference\">[2a] 维基百科, “匿名函数”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\">https://zh.wikipedia.org/zh-cn/匿名函数</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “Lambda calculus”. <a href=\"https://en.wikipedia.org/wiki/Lambda_calculus\">https://en.wikipedia.org/wiki/Lambda_calculus</a> </span></p><p><span class=\"reference\">[3a] 维基百科, “λ演算”. <a href=\"https://zh.wikipedia.org/zh-cn/%CE%9B%E6%BC%94%E7%AE%97\">https://zh.wikipedia.org/zh-cn/Λ演算</a> </span></p><p><span class=\"reference\">[4] Wikipedia, “Currying”. <a href=\"https://en.wikipedia.org/wiki/Currying\">https://en.wikipedia.org/wiki/Currying</a> </span></p><p><span class=\"reference\">[4a] 维基百科, “柯里化”. <a href=\"https://zh.wikipedia.org/zh-cn/%E6%9F%AF%E9%87%8C%E5%8C%96\">https://zh.wikipedia.org/zh-cn/柯里化</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “std::bind”. <a href=\"https://en.cppreference.com/w/cpp/utility/functional/bind\">https://en.cppreference.com/w/cpp/utility/functional/bind</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “std::bind”. <a href=\"https://zh.cppreference.com/w/cpp/utility/functional/bind\">https://zh.cppreference.com/w/cpp/utility/functional/bind</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::function”. <a href=\"https://en.cppreference.com/w/cpp/utility/functional/function\">https://en.cppreference.com/w/cpp/utility/functional/function</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::function”. <a href=\"https://zh.cppreference.com/w/cpp/utility/functional/function\">https://zh.cppreference.com/w/cpp/utility/functional/function</a> </span></p>","neighbors":{"left":{"article_title":"15 | constexpr：一个常态的世界","id":182902},"right":{"article_title":"17 | 函数式编程：一种越来越流行的编程范式","id":185189}}},{"article_id":185189,"article_title":"17 | 函数式编程：一种越来越流行的编程范式","article_content":"<p>你好，我是吴咏炜。</p><p>上一讲我们初步介绍了函数对象和 lambda 表达式，今天我们来讲讲它们的主要用途——函数式编程。</p><h2>一个小例子</h2><p>按惯例，我们还是从一个例子开始。想一下，如果给定一组文件名，要求数一下文件里的总文本行数，你会怎么做？</p><p>我们先规定一下函数的原型：</p><pre><code class=\"language-c++\">int count_lines(const char** begin,\n                const char** end);\n</code></pre><p>也就是说，我们期待接受两个 C 字符串的迭代器，用来遍历所有的文件名；返回值代表文件中的总行数。</p><p>要测试行为是否正常，我们需要一个很小的 <code>main</code> 函数：</p><pre><code class=\"language-c++\">int main(int argc,\n         const char** argv)\n{\n  int total_lines = count_lines(\n    argv + 1, argv + argc);\n  cout &lt;&lt; \"Total lines: \"\n       &lt;&lt; total_lines &lt;&lt; endl;\n}\n</code></pre><p>最传统的命令式编程大概会这样写代码：</p><pre><code class=\"language-c++\">int count_file(const char* name)\n{\n  int count = 0;\n  ifstream ifs(name);\n  string line;\n  for (;;) {\n    getline(ifs, line);\n    if (!ifs) {\n      break;\n    }\n    ++count;\n  }\n  return count;\n}\n\nint count_lines(const char** begin,\n                const char** end)\n{\n  int count = 0;\n  for (; begin != end; ++begin) {\n    count += count_file(*begin);\n  }\n  return count;\n}\n</code></pre><!-- [[[read_end]]] --><p>我们马上可以做一个简单的“说明式”改造。用 <code>istream_line_reader</code> 可以简化 <code>count_file</code> 成：</p><pre><code class=\"language-c++\">int count_file(const char* name)\n{\n  int count = 0;\n  ifstream ifs(name);\n  for (auto&amp;&amp; line :\n       istream_line_reader(ifs)) {\n    ++count;\n  }\n  return count;\n}\n</code></pre><p>在这儿，要请你停一下，想一想如何进一步优化这个代码。然后再继续进行往下看。</p><hr><p>如果我们使用之前已经出场过的两个函数，<code>transform</code> <span class=\"orange\">[1]</span> 和 <code>accumulate</code> <span class=\"orange\">[2]</span>，代码可以进一步简化为：</p><pre><code class=\"language-c++\">int count_file(const char* name)\n{\n  ifstream ifs(name);\n  istream_line_reader reader(ifs);\n  return distance(reader.begin(),\n                  reader.end());\n}\n\nint count_lines(const char** begin,\n                const char** end)\n{\n  vector&lt;int&gt; count(end - begin);\n  transform(begin, end,\n            count.begin(),\n            count_file);\n  return accumulate(\n    count.begin(), count.end(),\n    0);\n}\n</code></pre><p>这个就是一个非常函数式风格的结果了。上面这个处理方式恰恰就是 map-reduce。<code>transform</code> 对应 map，<code>accumulate</code> 对应 reduce。而检查有多少行文本，也成了代表文件头尾两个迭代器之间的“距离”（distance）。</p><h2>函数式编程的特点</h2><p>在我们的代码里不那么明显的一点是，函数式编程期望函数的行为像数学上的函数，而非一个计算机上的子程序。这样的函数一般被称为纯函数（pure function），要点在于：</p><ul>\n<li>会影响函数结果的只是函数的参数，没有对环境的依赖</li>\n<li>返回的结果就是函数执行的唯一后果，不产生对环境的其他影响</li>\n</ul><p>这样的代码的最大好处是易于理解和易于推理，在很多情况下也会使代码更简单。在我们上面的代码里，<code>count_file</code> 和 <code>accumulate</code> 基本上可以看做是纯函数（虽然前者实际上有着对文件系统的依赖），但 <code>transform</code> 不行，因为它改变了某个参数，而不是返回一个结果。下一讲我们会看到，这会影响代码的组合性。</p><p>我们的代码中也体现了其他一些函数式编程的特点：</p><ul>\n<li>函数就像普通的对象一样被传递、使用和返回。</li>\n<li>代码为说明式而非命令式。在熟悉函数式编程的基本范式后，你会发现说明式代码的可读性通常比命令式要高，代码还短。</li>\n<li>一般不鼓励（甚至完全不使用）可变量。上面代码里只有 <code>count</code> 的内容在执行过程中被修改了，而且这种修改实际是 <code>transform</code> 接口带来的。如果接口像<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 展示的 <code>fmap</code> 函数一样返回一个容器的话，就可以连这个问题都消除了。（C++ 毕竟不是一门函数式编程语言，对灵活性的追求压倒了其他考虑。）</li>\n</ul><h3>高阶函数</h3><p>既然函数（对象）可以被传递、使用和返回，自然就有函数会接受函数作为参数或者把函数作为返回值，这样的函数就被称为高阶函数。我们现在已经见过不少高阶函数了，如：</p><ul>\n<li><code>sort</code></li>\n<li><code>transform</code></li>\n<li><code>accumulate</code></li>\n<li><code>fmap</code></li>\n<li><code>adder</code></li>\n</ul><p>事实上，C++ 里以 algorithm（算法）<span class=\"orange\">[3]</span> 名义提供的很多函数都是高阶函数。</p><p>许多高阶函数在函数式编程中已成为基本的惯用法，在不同语言中都会出现，虽然可能是以不同的名字。我们在此介绍非常常见的三个，map（映射）、reduce（归并）和 filter（过滤）。</p><p>Map 在 C++ 中的直接映射是 <code>transform</code>（在 &lt;algorithm&gt; 头文件中提供）。它所做的事情也是数学上的映射，把一个范围里的对象转换成相同数量的另外一些对象。这个函数的基本实现非常简单，但这是一种强大的抽象，在很多场合都用得上。</p><p>Reduce 在 C++ 中的直接映射是 <code>accumulate</code>（在 &lt;numeric&gt; 头文件中提供）。它的功能是在指定的范围里，使用给定的初值和函数对象，从左到右对数值进行归并。在不提供函数对象作为第四个参数时，功能上相当于默认提供了加法函数对象，这时相当于做累加；提供了其他函数对象时，那当然就是使用该函数对象进行归并了。</p><p>Filter 的功能是进行过滤，筛选出符合条件的成员。它在当前 C++（C++20 之前）里的映射可以认为有两个：<code>copy_if</code> 和 <code>partition</code>。这是因为在 C++20 带来 ranges 之前，在 C++ 里实现惰性求值不太方便。上面说的两个函数里，<code>copy_if</code> 是把满足条件的元素拷贝到另外一个迭代器里；<code>partition</code> 则是根据过滤条件来对范围里的元素进行分组，把满足条件的放在返回值迭代器的前面。另外，<code>remove_if</code> 也有点相近，通常用于删除满足条件的元素。它确保把不满足条件的元素放在返回值迭代器的前面（但不保证满足条件的元素在函数返回后一定存在），然后你一般需要使用容器的 <code>erase</code> 成员函数来将待删除的元素真正删除。</p><h3>命令式编程和说明式编程</h3><p>传统上 C++ 属于命令式编程。命令式编程里，代码会描述程序的具体执行步骤。好处是代码显得比较直截了当；缺点就是容易让人只见树木、不见森林，只能看到代码啰嗦地怎么做（how），而不是做什么（what），更不用说为什么（why）了。</p><p>说明式编程则相反。以数据库查询语言 SQL 为例，SQL 描述的是类似于下面的操作：你想从什么地方（from）选择（select）满足什么条件（where）的什么数据，并可选指定排序（order by）或分组（group by）条件。你不需要告诉数据库引擎具体该如何去执行这个操作。事实上，在选择查询策略上，大部分数据库用户都不及数据库引擎“聪明”；正如大部分开发者在写出优化汇编代码上也不及编译器聪明一样。</p><p>这并不是说说明式编程一定就优于命令式编程。事实上，对于很多算法，命令式才是最自然的实现。以快速排序为例，很多地方在讲到函数式编程时会给出下面这个 Haskell（一种纯函数式的编程语言）的例子来说明函数式编程的简洁性：</p><pre><code class=\"language-haskell\">quicksort []     = []\nquicksort (p:xs) = (quicksort left)\n         ++ [p] ++ (quicksort right)\n  where\n    left  = filter (&lt; p) xs\n    right = filter (&gt;= p) xs\n</code></pre><p>这段代码简洁性确实没话说，但问题是，上面的代码的性能其实非常糟糕。真正接近 C++ 性能的快速排序，在 Haskell 里写出来一点不优雅，反而更丑陋 <span class=\"orange\">[4]</span>。</p><p>所以，我个人认为，说明式编程跟命令式编程可以结合起来产生既优雅又高效的代码。对于从命令式编程成长起来的大部分程序员，我的建议是：</p><ul>\n<li>写表意的代码，不要过于专注性能而让代码难以维护——记住高德纳的名言：“过早优化是万恶之源。”</li>\n<li>使用有意义的变量，但尽量不要去修改变量内容——变量的修改非常容易导致程序员的思维错误。</li>\n<li>类似地，尽量使用没有副作用的函数，并让你写的代码也尽量没有副作用，用返回值来代表状态的变化——没有副作用的代码更容易推理，更不容易出错。</li>\n<li>代码的隐式依赖越少越好，尤其是不要使用全局变量——隐式依赖会让代码里的错误难以排查，也会让代码更难以测试。</li>\n<li>使用知名的高级编程结构，如基于范围的 for 循环、映射、归并、过滤——这可以让你的代码更简洁，更易于推理，并减少类似下标越界这种低级错误的可能性。</li>\n</ul><p>这些跟函数式编程有什么关系呢？——这些差不多都是来自函数式编程的最佳实践。学习函数式编程，也是为了更好地体会如何从这些地方入手，写出易读而又高性能的代码。</p><h3>不可变性和并发</h3><p>在多核的时代里，函数式编程比以前更受青睐，一个重要的原因是函数式编程对并行并发天然友好。影响多核性能的一个重要因素是数据的竞争条件——由于共享内存数据需要加锁带来的延迟。函数式编程强调不可变性（immutability）、无副作用，天然就适合并发。更妙的是，如果你使用高层抽象的话，有时可以轻轻松松“免费”得到性能提升。</p><p>拿我们这一讲开头的例子来说，对代码做下面的改造，启用 C++17 的并行执行策略 <span class=\"orange\">[5]</span>，就能自动获得在多核环境下的性能提升：</p><pre><code class=\"language-c++\">int count_lines(const char** begin,\n                const char** end)\n{\n  vector&lt;int&gt; count(end - begin);\n  transform(execution::par,\n            begin, end,\n            count.begin(),\n            count_file);\n  return reduce(\n    execution::par,\n    count.begin(), count.end());\n}\n</code></pre><p>我们可以看到，两个高阶函数的调用中都加入了 <code>execution::par</code>，来启动自动并行计算。要注意的是，我把 <code>accumulate</code> 换成了 <code>reduce</code> <span class=\"orange\">[6]</span>，原因是前者已经定义成从左到右的归并，无法并行。<code>reduce</code> 则不同，初始值可以省略，操作上没有规定顺序，并反过来要求对元素的归并操作满足交换律和结合率（加法当然是满足的），即：</p><p>$$<br>\n\\begin{aligned}<br>\nA\\ \\otimes\\ B &amp;= B\\ \\otimes\\ A\\\\\\<br>\n(A\\ \\otimes\\ B)\\ \\otimes\\ C &amp;= A\\ \\otimes\\ (B\\ \\otimes\\ C)<br>\n\\end{aligned}<br>\n$$</p><p>当然，在这个例子里，一般我们不会有海量文件，即使有海量文件，并行读取性能一般也不会快于顺序读取，所以意义并不是很大。下面这个简单的例子展示了并行 <code>reduce</code> 的威力：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;execution&gt;\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n  vector&lt;double&gt; v(10000000, 0.0625);\n\n  {\n    auto t1 = chrono::\n      high_resolution_clock::now();\n    double result = accumulate(\n      v.begin(), v.end(), 0.0);\n    auto t2 = chrono::\n      high_resolution_clock::now();\n    chrono::duration&lt;double, milli&gt;\n      ms = t2 - t1;\n    cout &lt;&lt; \"accumulate: result \"\n         &lt;&lt; result &lt;&lt; \" took \"\n         &lt;&lt; ms.count() &lt;&lt; \" ms\\n\";\n  }\n\n  {\n    auto t1 = chrono::\n      high_resolution_clock::now();\n    double result =\n      reduce(execution::par,\n             v.begin(), v.end());\n    auto t2 = chrono::\n      high_resolution_clock::now();\n    chrono::duration&lt;double, milli&gt;\n      ms = t2 - t1;\n    cout &lt;&lt; \"reduce:     result \"\n         &lt;&lt; result &lt;&lt; \" took \"\n         &lt;&lt; ms.count() &lt;&lt; \" ms\\n\";\n  }\n}\n</code></pre><p>在我的电脑（Core i7 四核八线程）上的某次执行结果是：</p><blockquote>\n<p><code>accumulate: result 625000 took 26.122 ms</code><br>\n<code>reduce: result 625000 took 4.485 ms</code></p>\n</blockquote><p>执行策略还比较新，还没有被所有编译器支持。我目前测试下来，MSVC 没有问题，Clang 不行，GCC 需要外部库 TBB（Threading Building Blocks）<span class=\"orange\">[7]</span> 的帮助。我上面是用 GCC 编译的，命令行是：</p><blockquote>\n<p><code>g++-9 -std=c++17 -O3 test.cpp -ltbb</code></p>\n</blockquote><h2>Y 组合子</h2><p>限于篇幅，这一讲我们只是很初浅地探讨了函数式编程。对于 C++ 的函数式编程的深入探讨是有整本书的（见参考资料 <span class=\"orange\">[8]</span>），而今天讲的内容在书的最前面几章就覆盖完了。在后面，我们还会探讨部分的函数式编程话题；今天我们只再讨论一个有点有趣、也有点烧脑的话题，Y 组合子 <span class=\"orange\">[9]</span>。第一次阅读的时候，如果觉得困难，可以跳过这一部分。</p><p>不过，我并不打算讨论 Haskell Curry 使用的 Y 组合子定义——这个比较复杂，需要写一篇完整的文章来讨论（<span class=\"orange\">[10]</span>），而且在 C++ 中的实用性非常弱。我们只看它解决的问题：如何在 lambda 表达式中表现递归。</p><p>回想一下我们用过的阶乘的递归定义：</p><pre><code class=\"language-c++\">int factorial(int n)\n{\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\n</code></pre><p>注意里面用到了递归，所以你要把它写成 lambda 表达式是有点困难的：</p><pre><code class=\"language-c++\">auto factorial = [](int n) {\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * ???(n - 1);\n  }\n}\n</code></pre><p>下面我们讨论使用 Y 组合子的解决方案。</p><p>我们首先需要一个特殊的高阶函数，定义为：</p><p>$$<br>\ny(f) = f(y(f))<br>\n$$</p><p>显然，这个定义有点奇怪。事实上，它是会导致无限展开的——而它的威力也在于无限展开。我们也因此必须使用惰性求值的方式才能使用这个定义。</p><p>然后，我们定义阶乘为：</p><p>$$<br>\n\\mathrm{fact}(n) = \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times \\mathrm{fact}(n − 1)<br>\n$$</p><p>假设 $\\mathrm{fact}$ 可以表示成 $y(F)$，那我们可以做下面的变形：</p><p>$$<br>\n\\begin{aligned}<br>\ny(F)(n) &amp;= \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times y(F)(n − 1)\\\\\\<br>\nF(y(F))(n) &amp;= \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times y(F)(n − 1)<br>\n\\end{aligned}<br>\n$$</p><p>再把 $y(F)$ 替换成 $f$，我们从上面的第二个式子得到：</p><p>$$<br>\nF(f)(n) = \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times f(n − 1)<br>\n$$</p><p>我们得到了 $F$ 的定义，也就自然得到了 $\\mathrm{fact}$ 的定义。而且，这个定义是可以用 C++ 表达出来的。下面是完整的代码实现：</p><pre><code class=\"language-c++\">#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\n// Y combinator as presented by Yegor Derevenets in P0200R0\n// &lt;url:http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html&gt;\ntemplate &lt;class Fun&gt;\nclass y_combinator_result {\n  Fun fun_;\npublic:\n  template &lt;class T&gt;\n  explicit y_combinator_result(\n    T&amp;&amp; fun)\n    : fun_(std::forward&lt;T&gt;(fun))\n  {\n  }\n\n  template &lt;class... Args&gt;\n  decltype(auto)\n  operator()(Args&amp;&amp;... args)\n  {\n    // y(f) = f(y(f))\n    return fun_(\n      std::ref(*this),\n      std::forward&lt;Args&gt;(args)...);\n  }\n};\n\ntemplate &lt;class Fun&gt;\ndecltype(auto)\ny_combinator(Fun&amp;&amp; fun)\n{\n  return y_combinator_result&lt;\n    std::decay_t&lt;Fun&gt;&gt;(\n    std::forward&lt;Fun&gt;(fun));\n}\n\nint main()\n{\n  // 上面的那个 F\n  auto almost_fact =\n    [](auto f, int n) -&gt; int {\n    if (n == 0)\n      return 1;\n    else\n      return n * f(n - 1);\n  };\n  // fact = y(F)\n  auto fact =\n    y_combinator(almost_fact);\n  cout &lt;&lt; fact(10) &lt;&lt; endl;\n}\n</code></pre><p>这一节不影响后面的内容，看不懂的可以暂时略过。😝</p><h2>内容小结</h2><p>本讲我们对函数式编程进行了一个入门式的介绍，希望你对函数式编程的特点、优缺点有了一个初步的了解。然后，我快速讨论了一个会烧脑的话题，Y 组合子，让你对函数式编程的威力和难度也有所了解。</p><h2>课后思考</h2><p>想一想，你如何可以实现一个惰性的过滤器？一个惰性的过滤器应当让下面的代码通过编译，并且不会占用跟数据集大小相关的额外空间：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// filter_view 的定义\n\nint main()\n{\n  vector v{1, 2, 3, 4, 5};\n  auto&amp;&amp; fv = filter_view(\n    v.begin(), v.end(), [](int x) {\n      return x % 2 == 0;\n    });\n  cout &lt;&lt; accumulate(fv.begin(),\n                     fv.end(), 0)\n       &lt;&lt; endl;\n}\n</code></pre><p>结果输出应该是 <code>6</code>。</p><p><strong>提示：</strong>参考 <code>istream_line_reader</code> 的实现。</p><p>告诉我你是否成功了，或者你遇到了什么样的特别困难。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “std::transform”. <a href=\"https://en.cppreference.com/w/cpp/algorithm/transform\">https://en.cppreference.com/w/cpp/algorithm/transform</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “std::transform”. <a href=\"https://zh.cppreference.com/w/cpp/algorithm/transform\">https://zh.cppreference.com/w/cpp/algorithm/transform</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “std::accumulate”. <a href=\"https://en.cppreference.com/w/cpp/algorithm/accumulate\">https://en.cppreference.com/w/cpp/algorithm/accumulate</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “std::accumulate”. <a href=\"https://zh.cppreference.com/w/cpp/algorithm/accumulate\">https://zh.cppreference.com/w/cpp/algorithm/accumulate</a> </span></p><p><span class=\"reference\">[3] cppreference.com, “Standard library header &lt;algorithm&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/algorithm\">https://en.cppreference.com/w/cpp/header/algorithm</a> </span></p><p><span class=\"reference\">[3a] cppreference.com, “标准库头文件 &lt;algorithm&gt;”. <a href=\"https://zh.cppreference.com/w/cpp/header/algorithm\">https://zh.cppreference.com/w/cpp/header/algorithm</a> </span></p><p><span class=\"reference\">[4] 袁英杰, “Immutability: The Dark Side”. <a href=\"https://www.jianshu.com/p/13cd4c650125\">https://www.jianshu.com/p/13cd4c650125</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “Standard library header &lt;execution&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/execution\">https://en.cppreference.com/w/cpp/header/execution</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “标准库头文件 &lt;execution&gt;”. <a href=\"https://zh.cppreference.com/w/cpp/header/execution\">https://zh.cppreference.com/w/cpp/header/execution</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::reduce”. <a href=\"https://en.cppreference.com/w/cpp/algorithm/reduce\">https://en.cppreference.com/w/cpp/algorithm/reduce</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::reduce”. <a href=\"https://zh.cppreference.com/w/cpp/algorithm/reduce\">https://zh.cppreference.com/w/cpp/algorithm/reduce</a> </span></p><p><span class=\"reference\">[7] Intel, tbb. <a href=\"https://github.com/intel/tbb\">https://github.com/intel/tbb</a> </span></p><p><span class=\"reference\">[8] Ivan Čukić, <em>Functional Programming in C++</em>. Manning, 2019, <a href=\"https://www.manning.com/books/functional-programming-in-c-plus-plus\">https://www.manning.com/books/functional-programming-in-c-plus-plus</a> </span></p><p><span class=\"reference\">[9] Wikipedia, “Fixed-point combinator”. <a href=\"https://en.wikipedia.org/wiki/Fixed-point_combinator\">https://en.wikipedia.org/wiki/Fixed-point_combinator</a> </span></p><p><span class=\"reference\">[10] 吴咏炜, “<em>Y</em> Combinator and C++”. <a href=\"https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/\">https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/</a> </span></p>","neighbors":{"left":{"article_title":"16 | 函数对象和lambda：进入函数式编程","id":184018},"right":{"article_title":"18 | 应用可变模板和tuple的编译期技巧","id":185899}}},{"article_id":185899,"article_title":"18 | 应用可变模板和tuple的编译期技巧","article_content":"<p>你好，我是吴咏炜。</p><p>今天我们讲一个特殊的专题，如何使用可变模板和 tuple 来完成一些常见的功能，尤其是编译期计算。</p><h2>可变模板</h2><p>可变模板 <span class=\"orange\">[1]</span> 是 C++11 引入的一项新功能，使我们可以在模板参数里表达不定个数和类型的参数。从实际的角度，它有两个明显的用途：</p><ul>\n<li>用于在通用工具模板中转发参数到另外一个函数</li>\n<li>用于在递归的模板中表达通用的情况（另外会有至少一个模板特化来表达边界情况）</li>\n</ul><p>我们下面就来分开讨论一下。</p><h3>转发用法</h3><p>以标准库里的 <code>make_unique</code> 为例，它的定义差不多是下面这个样子：</p><pre><code class=\"language-c++\">template &lt;typename T,\n          typename... Args&gt;\ninline unique_ptr&lt;T&gt;\nmake_unique(Args&amp;&amp;... args)\n{\n  return unique_ptr&lt;T&gt;(\n    new T(forward&lt;Args&gt;(args)...));\n}\n</code></pre><p>这样，它就可以把传递给自己的全部参数转发到模板参数类的构造函数上去。注意，在这种情况下，我们通常会使用 <code>std::forward</code>，确保参数转发时仍然保持正确的左值或右值引用类型。</p><p>稍微解释一下上面三处出现的 <code>...</code>：</p><ul>\n<li><code>typename... Args</code> 声明了一系列的类型——<code>class...</code> 或 <code>typename...</code> 表示后面的标识符代表了一系列的类型。</li>\n<li><code>Args&amp;&amp;... args</code> 声明了一系列的形参 <code>args</code>，其类型是 <code>Args&amp;&amp;</code>。</li>\n<li><code>forward&lt;Args&gt;(args)...</code> 会在编译时实际逐项展开 <code>Args</code> 和 <code>args</code> ，参数有多少项，展开后就是多少项。</li>\n</ul><!-- [[[read_end]]] --><p>举一个例子，如果我们需要在堆上传递一个 <code>vector&lt;int&gt;</code>，假设我们希望初始构造的大小为 100，每个元素都是 <code>1</code>，那我们可以这样写：</p><pre><code class=\"language-c++\">make_unique&lt;vector&lt;int&gt;&gt;(100, 1)\n</code></pre><p>模板实例化之后，会得到相当于下面的代码：</p><pre><code class=\"language-c++\">template &lt;&gt;\ninline unique_ptr&lt;vector&lt;int&gt;&gt;\nmake_unique(int&amp;&amp; arg1, int&amp;&amp; arg2)\n{\n  return unique_ptr&lt;vector&lt;int&gt;&gt;(\n    new vector&lt;int&gt;(\n      forward&lt;int&gt;(arg1),\n      forward&lt;int&gt;(arg2)));\n}\n</code></pre><p>如前所述，<code>forward&lt;Args&gt;(args)...</code> 为每一项可变模板参数都以同样的形式展开。项数也允许为零，那样，我们在调用构造函数时也同样没有任何参数。</p><h3>递归用法</h3><p>我们也可以用可变模板来实现编译期递归。下面就是个小例子：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nconstexpr auto sum(T x)\n{\n  return x;\n}\n\ntemplate &lt;typename T1, typename T2,\n          typename... Targ&gt;\nconstexpr auto sum(T1 x, T2 y,\n                   Targ... args)\n{\n  return sum(x + y, args...);\n}\n</code></pre><p>在上面的定义里，如果 <code>sum</code> 得到的参数只有一个，会走到上面那个重载。如果有两个或更多参数，编译器就会选择下面那个重载，执行一次加法，随后你的参数数量就少了一个，因而递归总会终止到上面那个重载，结束计算。</p><p>要使用上面这个模板，我们就可以写出像下面这样的函数调用：</p><pre><code class=\"language-c++\">auto result = sum(1, 2, 3.5, x);\n</code></pre><p>模板会这样依次展开：</p><pre><code class=\"language-c++\">sum(1 + 2, 3.5, x)\nsum(3 + 3.5, x)\nsum(6.5 + x)\n6.5 + x\n</code></pre><p>注意我们都不必使用相同的数据类型：只要这些数据之间可以应用 <code>+</code>，它们的类型无关紧要……</p><p>再看另一个复杂些的例子，函数的组合 <span class=\"orange\">[2]</span>。如果我们有函数 $f$ 和 函数 $g$，要得到函数的联用 $g \\circ f$，其满足：</p><p>$$<br>\n(g \\circ f)(x) = g(f(x))<br>\n$$</p><p>我们能不能用一种非常简单的方式，写不包含变量 $x$ 的表达式来表示函数组合呢？答案是肯定的。</p><p>跟上面类似，我们需要写出递归的终结情况，单个函数的“组合”：</p><pre><code class=\"language-c++\">template &lt;typename F&gt;\nauto compose(F f)\n{\n  return [f](auto&amp;&amp;... x) {\n    return f(\n      forward&lt;decltype(x)&gt;(x)...);\n  };\n}\n</code></pre><p>上面我们仅返回一个泛型 lambda 表达式，保证参数可以转发到 <code>f</code>。记得我们在<a href=\"https://time.geekbang.org/column/article/184018\">[第 16 讲]</a> 讲过泛型 lambda 表达式，本质上就是一个模板，所以我们按转发用法的可变模板来理解上面的 <code>...</code> 部分就对了。</p><p>下面是正常有组合的情况：</p><pre><code class=\"language-c++\">template &lt;typename F,\n          typename... Args&gt;\nauto compose(F f, Args... other)\n{\n  return [f,\n          other...](auto&amp;&amp;... x) {\n    return f(compose(other...)(\n      forward&lt;decltype(x)&gt;(x)...));\n  };\n}\n</code></pre><p>在这个模板里，我们返回一个 lambda 表达式，然后用 <code>f</code> 捕捉第一个函数对象，用 <code>args...</code> 捕捉后面的函数对象。我们用 <code>args...</code> 继续组合后面的部分，然后把结果传到 <code>f</code> 里面。</p><p>上面的模板定义我实际上已经有所简化，没有保持值类别。完整的包含完美转发的版本，请看参考资料 <span class=\"orange\">[3]</span> 中的 functional.h 实现。</p><p>下面我们来试验一下使用这个 <code>compose</code> 函数。我们先写一个对输入范围中每一项都进行平方的函数对象：</p><pre><code class=\"language-c++\">auto square_list =\n  [](auto&amp;&amp; container) {\n    return fmap(\n      [](int x) { return x * x; },\n      container);\n  };\n</code></pre><p>我们使用了<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 中给出的 <code>fmap</code>，而不是标准库里的 <code>transform</code>，是因为后者接口非函数式，无法组合——它要求参数给出输出位置的迭代器，会修改迭代器指向的内容，返回结果也只是单个的迭代器；函数式的接口则期望不修改参数的内容，结果完全在返回值中。</p><p>我们这儿用了泛型 lambda 表达式，是因为组合的时候不能使用模板，只能是函数对象或函数（指针）——如果我们定义一个 <code>square_list</code> 模板的话，组合时还得显式实例化才行（写成 <code>square_list&lt;const vector&lt;int&gt;&amp;&gt;</code> 的样子），很不方便。</p><p>我们再写一个求和的函数对象：</p><pre><code class=\"language-c++\">auto sum_list =\n  [](auto&amp;&amp; container) {\n    return accumulate(\n      container.begin(),\n      container.end(), 0);\n  };\n</code></pre><p>那先平方再求和，就可以这样简单定义了：</p><pre><code class=\"language-c++\">auto squared_sum =\n  compose(sum_list, square_list);\n</code></pre><p>我们可以验证这个定义是可以工作的：</p><pre><code class=\"language-c++\">vector v{1, 2, 3, 4, 5};\ncout &lt;&lt; squared_sum(v) &lt;&lt; endl;\n</code></pre><p>我们会得到：</p><blockquote>\n<p><code>55</code></p>\n</blockquote><h2>tuple</h2><p>上面的写法虽然看起来还不错，但实际上有个缺陷：被 compose 的函数除了第一个（最右边的），其他的函数只能接收一个参数。要想进一步推进类似的技巧，我们得首先解决这个问题。</p><p>在 C++ 里，要通用地用一个变量来表达多个值，那就得看多元组——<code>tuple</code> 模板了 <span class=\"orange\">[4]</span>。<code>tuple</code> 算是 C++98 里的 <code>pair</code> 类型的一般化，可以表达任意多个固定数量、固定类型的值的组合。下面这段代码约略地展示了其基本用法：</p><pre><code class=\"language-c++\">#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// 整数、字符串、字符串的三元组\nusing num_tuple =\n  tuple&lt;int, string, string&gt;;\n\nostream&amp;\noperator&lt;&lt;(ostream&amp; os,\n           const num_tuple&amp; value)\n{\n  os &lt;&lt; get&lt;0&gt;(value) &lt;&lt; ','\n     &lt;&lt; get&lt;1&gt;(value) &lt;&lt; ','\n     &lt;&lt; get&lt;2&gt;(value);\n  return os;\n}\n\nint main()\n{\n  // 阿拉伯数字、英文、法文\n  vector&lt;num_tuple&gt; vn{\n    {1, \"one\",   \"un\"},\n    {2, \"two\",   \"deux\"},\n    {3, \"three\", \"trois\"},\n    {4, \"four\",  \"quatre\"}};\n  // 修改第 0 项的法文\n  get&lt;2&gt;(vn[0]) = \"une\";\n  // 按法文进行排序\n  sort(vn.begin(), vn.end(),\n       [](auto&amp;&amp; x, auto&amp;&amp; y) {\n         return get&lt;2&gt;(x) &lt;\n                get&lt;2&gt;(y);\n       });\n  // 输出内容\n  for (auto&amp;&amp; value : vn) {\n    cout &lt;&lt; value &lt;&lt; endl;\n  }\n  // 输出多元组项数\n  constexpr auto size = \\\n    tuple_size_v&lt;num_tuple&gt;;\n  cout &lt;&lt; \"Tuple size is \" &lt;&lt; size &lt;&lt; endl;\n}\n</code></pre><p>输出是：</p><blockquote>\n<p><code>2,two,deux</code><br>\n<code>4,four,quatre</code><br>\n<code>3,three,trois</code><br>\n<code>1,one,une</code><br>\n<code>Tuple size is 3</code></p>\n</blockquote><p>我们可以看到：</p><ul>\n<li><code>tuple</code> 的成员数量由尖括号里写的类型数量决定。</li>\n<li>可以使用 <code>get</code> 函数对 <code>tuple</code> 的内容进行读和写。（当一个类型在 <code>tuple</code> 中出现正好一次时，我们也可以传类型取内容，即，对我们上面的三元组，<code>get&lt;int&gt;</code> 是合法的，<code>get&lt;string&gt;</code> 则不是。）</li>\n<li>可以用 <code>tuple_size_v</code> （在编译期）取得多元组里面的项数。</li>\n</ul><p>如果我们要用一个三项的 <code>tuple</code> 去调用一个函数，我们可以写类似这样的代码：</p><pre><code class=\"language-c++\">template &lt;class F, class Tuple&gt;\nconstexpr decltype(auto) apply(\n  F&amp;&amp; f, Tuple&amp;&amp; t)\n{\n  return f(\n    get&lt;0&gt;(forward&lt;Tuple&gt;(t)),\n    get&lt;1&gt;(forward&lt;Tuple&gt;(t)),\n    get&lt;2&gt;(forward&lt;Tuple&gt;(t)));\n}\n</code></pre><p>这似乎已经挺接近我们需要的形式了，但实际调用函数的参数项数会变啊……</p><p>我们已经有了参数的项数（使用 <code>tuple_size_v</code>），所以我们下面要做的是生成从 0 到项数减一之间的整数序列。标准库里已经定义了相关的工具，我们需要的就是其中的 <code>make_index_sequence</code> <span class=\"orange\">[5]</span>，其简化实现如下所示：</p><pre><code class=\"language-c++\">template &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n\ntemplate &lt;size_t... Ints&gt;\nusing index_sequence =\n  integer_sequence&lt;size_t, Ints...&gt;;\n\ntemplate &lt;size_t N, size_t... Ints&gt;\nstruct index_sequence_helper {\n  typedef\n    typename index_sequence_helper&lt;\n      N - 1, N - 1, Ints...&gt;::type\n      type;\n};\n\ntemplate &lt;size_t... Ints&gt;\nstruct index_sequence_helper&lt;\n  0, Ints...&gt; {\n  typedef index_sequence&lt;Ints...&gt;\n    type;\n};\n\ntemplate &lt;size_t N&gt;\nusing make_index_sequence =\n  typename index_sequence_helper&lt;\n    N&gt;::type;\n</code></pre><p>正如一般的模板代码，它看起来还是有点绕的。其要点是，如果我们给出 <code>make_index_sequence&lt;N&gt;</code>，则结果是 <code>integer_sequence&lt;size_t, 0, 1, 2, …, N - 1&gt;</code>（一下子想不清楚的话，可以拿纸笔来模拟一下模板的展开过程）。而有了这样一个模板的帮助之后，我们就可以写出下面这样的函数（同样，这是标准库里的 <code>apply</code> 函数模板 <span class=\"orange\">[6]</span> 的简化版本）：</p><pre><code class=\"language-c++\">template &lt;class F, class Tuple,\n          size_t... I&gt;\nconstexpr decltype(auto)\napply_impl(F&amp;&amp; f, Tuple&amp;&amp; t,\n           index_sequence&lt;I...&gt;)\n{\n  return f(\n    get&lt;I&gt;(forward&lt;Tuple&gt;(t))...);\n}\n\ntemplate &lt;class F, class Tuple&gt;\nconstexpr decltype(auto)\napply(F&amp;&amp; f, Tuple&amp;&amp; t)\n{\n  return apply_impl(\n    forward&lt;F&gt;(f),\n    forward&lt;Tuple&gt;(t),\n    make_index_sequence&lt;\n      tuple_size_v&lt;\n        remove_reference_t&lt;\n          Tuple&gt;&gt;&gt;{});\n}\n</code></pre><p>我们如果有一个三元组 <code>t</code>，类型为 <code>tuple&lt;int, string, string&gt;</code>，去 <code>apply</code> 到一个函数 <code>f</code>，展开后我们得到 <code>apply_impl(f, t, index_sequence&lt;0, 1, 2&gt;{})</code>，再展开后我们就得到了上面那个有 <code>get&lt;0&gt;</code>、<code>get&lt;1&gt;</code>、<code>get&lt;2&gt;</code> 的函数调用形式。换句话说，我们利用一个计数序列的类型，可以在编译时展开 <code>tuple</code> 里的各个成员，并用来调用函数。</p><h2>数值预算</h2><p>上面的代码有点复杂，而且似乎并没有完成什么很重要的功能。我们下面看一个源自实际项目的例子。需求是，我们希望快速地计算一串二进制数中 1 比特的数量。举个例子，如果我们有十进制的 31 和 254，转换成二进制是 00011111 和 11111110，那我们应该得到 5 + 7 = 12。</p><p>显然，每个数字临时去数肯定会慢，我们应该预先把每个字节的 256 种情况记录下来。因而，如何得到这些计数值是个问题。在没有编译期编程时，我们似乎只能用另外一个程序先行计算，然后把结果填进去——这就很不方便很不灵活了。有了编译期编程，我们就不用写死，而让编译器在编译时帮我们计算数值。</p><p>利用 constexpr 函数，我们计算单个数值完全没有问题。快速定义如下：</p><pre><code class=\"language-c++\">constexpr int\ncount_bits(unsigned char value)\n{\n  if (value == 0) {\n    return 0;\n  } else {\n    return (value &amp; 1) +\n           count_bits(value &gt;&gt; 1);\n  }\n}\n</code></pre><p>可 256 个，总不见得把计算语句写上 256 遍吧？这就需要用到我们上面讲到的 <code>index_sequence</code> 了。我们定义一个模板，它的参数是一个序列，在初始化时这个模板会对参数里的每一项计算比特数，并放到数组成员里。</p><pre><code class=\"language-c++\">template &lt;size_t... V&gt;\nstruct bit_count_t {\n  unsigned char\n    count[sizeof...(V)] = {\n      static_cast&lt;unsigned char&gt;(\n        count_bits(V))...};\n};\n</code></pre><p>注意上面用 <code>sizeof...(V)</code> 可以获得参数的个数（在 <code>tuple_size_v</code> 的实现里实际也用到它了）。如果我们模板参数传 <code>0, 1, 2, 3</code>，结果里面就会有个含 4 项元素的数组，数值分别是对 0、1、2、3 的比特计数。</p><p>然后，我们当然就可以利用 <code>make_index_sequence</code> 来展开计算了，想产生几项就可以产生几项。不过，要注意到 <code>make_index_sequence</code> 的结果是个类型，不能直接用在 <code>bit_count_t</code> 的构造中。我们需要用模板匹配来中转一下：</p><pre><code class=\"language-c++\">template &lt;size_t... V&gt;\nconstexpr bit_count_t&lt;V...&gt;\nget_bit_count(index_sequence&lt;V...&gt;)\n{\n  return bit_count_t&lt;V...&gt;();\n}\n\nauto bit_count = get_bit_count(\n  make_index_sequence&lt;256&gt;());\n</code></pre><p>得到 <code>bit_count</code> 后，我们要计算一个序列里的比特数就只是轻松查表相加了，此处不再赘述。</p><h2>内容小结</h2><p>今天我们讨论了在编译期处理不确定数量的参数和类型的基本语言特性，可变模板，以及可以操控可变模板的重要工具——<code>tuple</code> 和 <code>index_sequence</code>。用好这些工具，可以让我们轻松地完成一些编译期计算的工作。</p><h2>课后思考</h2><p>请考虑一下：</p><ol>\n<li>我展示了 <code>compose</code> 带一个或更多参数的情况。你觉得 <code>compose</code> 不带任何参数该如何定义？它有意义吗？</li>\n<li>有没有可能不用 <code>index_sequence</code> 来初始化 <code>bit_count</code>？如果行，应该如何实现？</li>\n<li>作为一个挑战，你能自行实现出 <code>make_integer_sequence</code> 吗？</li>\n</ol><p>期待你的答案。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Parameter pack”. <a href=\"https://en.cppreference.com/w/cpp/language/parameter_pack\">https://en.cppreference.com/w/cpp/language/parameter_pack</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “形参包”. <a href=\"https://zh.cppreference.com/w/cpp/language/parameter_pack\">https://zh.cppreference.com/w/cpp/language/parameter_pack</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Function composition”. <a href=\"https://en.wikipedia.org/wiki/Function_composition\">https://en.wikipedia.org/wiki/Function_composition</a> </span></p><p><span class=\"reference\">[2a] 维基百科, “复合函数”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0\">https://zh.wikipedia.org/zh-cn/复合函数</a> </span></p><p><span class=\"reference\">[3] 吴咏炜, nvwa. <a href=\"https://github.com/adah1972/nvwa\">https://github.com/adah1972/nvwa</a> </span></p><p><span class=\"reference\">[4] cppreference.com, “std::tuple”. <a href=\"https://en.cppreference.com/w/cpp/utility/tuple\">https://en.cppreference.com/w/cpp/utility/tuple</a> </span></p><p><span class=\"reference\">[4a] cppreference.com, “std::tuple”. <a href=\"https://zh.cppreference.com/w/cpp/utility/tuple\">https://zh.cppreference.com/w/cpp/utility/tuple</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “std::integer_sequence”. <a href=\"https://en.cppreference.com/w/cpp/utility/integer_sequence\">https://en.cppreference.com/w/cpp/utility/integer_sequence</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “std::integer_sequence”. <a href=\"https://zh.cppreference.com/w/cpp/utility/integer_sequence\">https://zh.cppreference.com/w/cpp/utility/integer_sequence</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::apply”. <a href=\"https://en.cppreference.com/w/cpp/utility/apply\">https://en.cppreference.com/w/cpp/utility/apply</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::apply”. <a href=\"https://zh.cppreference.com/w/cpp/utility/apply\">https://zh.cppreference.com/w/cpp/utility/apply</a> </span></p>","neighbors":{"left":{"article_title":"17 | 函数式编程：一种越来越流行的编程范式","id":185189},"right":{"article_title":"19 | thread和future：领略异步中的未来","id":186689}}},{"article_id":186689,"article_title":"19 | thread和future：领略异步中的未来","article_content":"<p>你好，我是吴咏炜。</p><p>编译期的烧脑我们先告个段落，今天我们开始讲一个全新的话题——并发（concurrency）。</p><h2>为什么要使用并发编程？</h2><p>在本世纪初之前，大部分开发人员不常需要关心并发编程；用到的时候，也多半只是在单处理器上执行一些后台任务而已。只有少数为昂贵的工作站或服务器进行开发的程序员，才会需要为并发性能而烦恼。原因无他，程序员们享受着摩尔定律带来的免费性能提升，而高速的 Intel 单 CPU 是性价比最高的系统架构，可到了 2003 年左右，大家骤然发现，“免费午餐”已经结束了 <span class=\"orange\">[1]</span>。主频的提升停滞了：在 2001 年，Intel 已经有了主频 2.0 GHz 的 CPU，而 18 年后，我现在正在使用的电脑，主频也仍然只是 2.5 GHz，虽然从单核变成了四核。服务器、台式机、笔记本、移动设备的处理器都转向了多核，计算要求则从单线程变成了多线程甚至异构——不仅要使用 CPU，还得使用 GPU。</p><p>如果你不熟悉进程和线程的话，我们就先来简单介绍一下它们的关系。我们编译完执行的 C++ 程序，那在操作系统看来就是一个进程了。而每个进程里可以有一个或多个线程：</p><ul>\n<li>每个进程有自己的独立地址空间，不与其他进程分享；一个进程里可以有多个线程，彼此共享同一个地址空间。</li>\n<li>堆内存、文件、套接字等资源都归进程管理，同一个进程里的多个线程可以共享使用。每个进程占用的内存和其他资源，会在进程退出或被杀死时返回给操作系统。</li>\n<li>并发应用开发可以用多进程或多线程的方式。多线程由于可以共享资源，效率较高；反之，多进程（默认）不共享地址空间和资源，开发较为麻烦，在需要共享数据时效率也较低。但多进程安全性较好，在某一个进程出问题时，其他进程一般不受影响；而在多线程的情况下，一个线程执行了非法操作会导致整个进程退出。</li>\n</ul><!-- [[[read_end]]] --><p>我们讲 C++ 里的并发，主要讲的就是多线程。它对开发人员的挑战是全方位的。从纯逻辑的角度，并发的思维模式就比单线程更为困难。在其之上，我们还得加上：</p><ul>\n<li>编译器和处理器的重排问题</li>\n<li>原子操作和数据竞争</li>\n<li>互斥锁和死锁问题</li>\n<li>无锁算法</li>\n<li>条件变量</li>\n<li>信号量</li>\n<li>……</li>\n</ul><p>即使对于专家，并发编程都是困难的，上面列举的也只是部分难点而已。对于并发的基本挑战，Herb Sutter 在他的 Effective Concurrency 专栏给出了一个较为全面的概述 <span class=\"orange\">[2]</span>。要对 C++ 的并发编程有全面的了解，则可以阅读曼宁出版的 <em>C++ Concurrency in Action</em>（有中文版，但翻译口碑不好）<span class=\"orange\">[3]</span>。而我们今天主要要介绍的，则是并发编程的基本概念，包括传统的多线程开发，以及高层抽象 future（姑且译为未来量）的用法。</p><h2>基于 thread 的多线程开发</h2><p>我们先来看一个使用 <code>thread</code> 线程类 <span class=\"orange\">[4]</span> 的简单例子：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nmutex output_lock;\n\nvoid func(const char* name)\n{\n  this_thread::sleep_for(100ms);\n  lock_guard&lt;mutex&gt; guard{\n    output_lock};\n  cout &lt;&lt; \"I am thread \" &lt;&lt; name\n       &lt;&lt; '\\n';\n}\n\nint main()\n{\n  thread t1{func, \"A\"};\n  thread t2{func, \"B\"};\n  t1.join();\n  t2.join();\n}\n</code></pre><p>这是某次执行的结果：</p><blockquote>\n<p><code>I am thread B</code><br>\n<code>I am thread A</code></p>\n</blockquote><p><strong>一个平台细节：</strong>在 Linux 上编译线程相关的代码都需要加上 <code>-pthread</code> 命令行参数。Windows 和 macOS 上则不需要。</p><p>代码是相当直截了当的，执行了下列操作：</p><ol>\n<li>传递参数，起两个线程</li>\n<li>两个线程分别休眠 100 毫秒</li>\n<li>使用互斥量（mutex）锁定 <code>cout</code> ，然后输出一行信息</li>\n<li>主线程等待这两个线程退出后程序结束</li>\n</ol><p>以下几个地方可能需要稍加留意一下：</p><ul>\n<li><code>thread</code> 的构造函数的第一个参数是函数（对象），后面跟的是这个函数所需的参数。</li>\n<li><code>thread</code> 要求在析构之前要么 <code>join</code>（阻塞直到线程退出），要么 <code>detach</code>（放弃对线程的管理），否则程序会异常退出。</li>\n<li><code>sleep_for</code> 是 <code>this_thread</code> 名空间下的一个自由函数，表示当前线程休眠指定的时间。</li>\n<li>如果没有 <code>output_lock</code> 的同步，输出通常会交错到一起。</li>\n</ul><p>建议你自己运行一下，并尝试删除 <code>lock_guard</code> 和 <code>join</code> 的后果。</p><p><code>thread</code> 不能在析构时自动 <code>join</code> 有点不那么自然，这可以算是一个缺陷吧。在 C++20 的 <code>jthread</code> <span class=\"orange\">[5]</span> 到来之前，我们只能自己小小封装一下了。比如：</p><pre><code class=\"language-c++\">class scoped_thread {\npublic:\n  template &lt;typename... Arg&gt;\n  scoped_thread(Arg&amp;&amp;... arg)\n    : thread_(\n        std::forward&lt;Arg&gt;(arg)...)\n  {}\n  scoped_thread(\n    scoped_thread&amp;&amp; other)\n    : thread_(\n        std::move(other.thread_))\n  {}\n  scoped_thread(\n    const scoped_thread&amp;) = delete;\n  ~scoped_thread()\n  {\n    if (thread_.joinable()) {\n      thread_.join();\n    }\n  }\n\nprivate:\n  thread thread_;\n};\n</code></pre><p>这个实现里有下面几点需要注意：</p><ol>\n<li>我们使用了可变模板和完美转发来构造 <code>thread</code> 对象。</li>\n<li><code>thread</code> 不能拷贝，但可以移动；我们也类似地实现了移动构造函数。</li>\n<li>只有 joinable（已经 <code>join</code> 的、已经 <code>detach</code> 的或者空的线程对象都不满足 joinable）的 <code>thread</code> 才可以对其调用 <code>join</code> 成员函数，否则会引发异常。</li>\n</ol><p>使用这个 <code>scoped_thread</code> 类的话，我们就可以把我们的 <code>main</code> 函数改写成：</p><pre><code class=\"language-c++\">int main()\n{\n  scoped_thread t1{func, \"A\"};\n  scoped_thread t2{func, \"B\"};\n}\n</code></pre><p>这虽然是个微不足道的小例子，但我们已经可以发现：</p><ul>\n<li>执行顺序不可预期，或者说不具有决定性。</li>\n<li>如果没有互斥量的帮助，我们连完整地输出一整行信息都成问题。</li>\n</ul><p>我们下面就来讨论一下互斥量。</p><h3>mutex</h3><p>互斥量的基本语义是，一个互斥量只能被一个线程锁定，用来保护某个代码块在同一时间只能被一个线程执行。在前面那个多线程的例子里，我们就需要限制同时只有一个线程在使用 <code>cout</code>，否则输出就会错乱。</p><p>目前的 C++ 标准中，事实上提供了不止一个互斥量类。我们先看最简单、也最常用的 <code>mutex</code> 类 <span class=\"orange\">[6]</span>。<code>mutex</code> 只可默认构造，不可拷贝（或移动），不可赋值，主要提供的方法是：</p><ul>\n<li><code>lock</code>：锁定，锁已经被其他线程获得时则阻塞执行</li>\n<li><code>try_lock</code>：尝试锁定，获得锁返回 <code>true</code>，在锁被其他线程获得时返回 <code>false</code></li>\n<li><code>unlock</code>：解除锁定（只允许在已获得锁时调用）</li>\n</ul><p>你可能会想到，如果一个线程已经锁定了某个互斥量，再次锁定会发生什么？对于 <code>mutex</code>，回答是危险的未定义行为。你不应该这么做。如果有特殊需要可能在同一线程对同一个互斥量多次加锁，就需要用到递归锁 <code>recursive_mutex</code> 了 <span class=\"orange\">[7]</span>。除了允许同一线程可以无阻塞地多次加锁外（也必须有对应数量的解锁操作），<code>recursive_mutex</code> 的其他行为和 <code>mutex</code> 一致。</p><p>除了 <code>mutex</code> 和 <code>recursive_mutex</code>，C++ 标准库还提供了：</p><ul>\n<li><code>timed_mutex</code>：允许锁定超时的互斥量</li>\n<li><code>recursive_timed_mutex</code>：允许锁定超时的递归互斥量</li>\n<li><code>shared_mutex</code>：允许共享和独占两种获得方式的互斥量</li>\n<li><code>shared_timed_mutex</code>：允许共享和独占两种获得方式的、允许锁定超时的互斥量</li>\n</ul><p>这些我们就不做讲解了，需要的请自行查看参考资料 <span class=\"orange\">[8]</span>。另外，&lt;mutex&gt; 头文件中也定义了锁的 RAII 包装类，如我们上面用过的 <code>lock_guard</code>。为了避免手动加锁、解锁的麻烦，以及在有异常或出错返回时发生漏解锁，我们一般应当使用 <code>lock_guard</code>，而不是手工调用互斥量的 <code>lock</code> 和 <code>unlock</code> 方法。C++ 里另外还有 <code>unique_lock</code>（C++11）和 <code>scoped_lock</code>（C++17），提供了更多的功能，你在有更复杂的需求时应该检查一下它们是否合用。</p><h3>执行任务，返回数据</h3><p>如果我们要在某个线程执行一些后台任务，然后取回结果，我们该怎么做呢？</p><p>比较传统的做法是使用信号量或者条件变量。由于 C++17 还不支持信号量，我们要模拟传统的做法，只能用条件变量了。由于我的重点并不是传统的做法，条件变量 <span class=\"orange\">[9]</span> 我就不展开讲了，而只是展示一下示例的代码。</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;condition_variable&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\nclass scoped_thread {\n  … // 定义同上，略\n};\n\nvoid work(condition_variable&amp; cv,\n          int&amp; result)\n{\n  // 假装我们计算了很久\n  this_thread::sleep_for(2s);\n  result = 42;\n  cv.notify_one();\n}\n\nint main()\n{\n  condition_variable cv;\n  mutex cv_mut;\n  int result;\n\n  scoped_thread th{work, ref(cv),\n                   ref(result)};\n  // 干一些其他事\n  cout &lt;&lt; \"I am waiting now\\n\";\n  unique_lock lock{cv_mut};\n  cv.wait(lock);\n  cout &lt;&lt; \"Answer: \" &lt;&lt; result\n       &lt;&lt; '\\n';\n}\n</code></pre><p>可以看到，为了这个小小的“计算”，我们居然需要定义 5 个变量：线程、条件变量、互斥量、单一锁和结果变量。我们也需要用 <code>ref</code> 模板来告诉 <code>thread</code> 的构造函数，我们需要传递条件变量和结果变量的引用，因为 <code>thread</code> 默认复制或移动所有的参数作为线程函数的参数。这种复杂性并非逻辑上的复杂性，而只是实现导致的，不是我们希望的写代码的方式。</p><p>下面，我们就看看更高层的抽象，未来量 <code>future</code> <span class=\"orange\">[10]</span>，可以如何为我们简化代码。</p><h2>future</h2><p>我们先把上面的代码直接翻译成使用 <code>async</code> <span class=\"orange\">[11]</span>（它会返回一个 <code>future</code>）：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nint work()\n{\n  // 假装我们计算了很久\n  this_thread::sleep_for(2s);\n  return 42;\n}\n\nint main()\n{\n  auto fut = async(launch::async, work);\n  // 干一些其他事\n  cout &lt;&lt; \"I am waiting now\\n\";\n  cout &lt;&lt; \"Answer: \" &lt;&lt; fut.get()\n       &lt;&lt; '\\n';\n}\n</code></pre><p>完全同样的结果，代码大大简化，变量减到了只剩一个未来量，还不赖吧？</p><p>我们稍稍分析一下：</p><ul>\n<li><code>work</code> 函数现在不需要考虑条件变量之类的实现细节了，专心干好自己的计算活、老老实实返回结果就可以了。</li>\n<li>调用 <code>async</code> 可以获得一个未来量，<code>launch::async</code> 是运行策略，告诉函数模板 <code>async</code> 应当在新线程里异步调用目标函数。在一些老版本的 GCC 里，不指定运行策略，默认不会起新线程。</li>\n<li><code>async</code> 函数模板可以根据参数来推导出返回类型，在我们的例子里，返回类型是 <code>future&lt;int&gt;</code>。</li>\n<li>在未来量上调用 <code>get</code> 成员函数可以获得其结果。这个结果可以是返回值，也可以是异常，即，如果 <code>work</code> 抛出了异常，那 <code>main</code> 里在执行 <code>fut.get()</code> 时也会得到同样的异常，需要有相应的异常处理代码程序才能正常工作。</li>\n</ul><p>这里有两个要点，从代码里看不出来，我特别说明一下：</p><ol>\n<li>一个 <code>future</code> 上只能调用一次 <code>get</code> 函数，第二次调用为未定义行为，通常导致程序崩溃。</li>\n<li>这样一来，自然一个 <code>future</code> 是不能直接在多个线程里用的。</li>\n</ol><p>上面的第 1 点是 <code>future</code> 的设计，需要在使用时注意一下。第 2 点则是可以解决的。要么直接拿 <code>future</code> 来移动构造一个 <code>shared_future</code> <span class=\"orange\">[12]</span>，要么调用 <code>future</code> 的 <code>share</code> 方法来生成一个 <code>shared_future</code>，结果就可以在多个线程里用了——当然，每个 <code>shared_future</code> 上仍然还是只能调用一次 <code>get</code> 函数。</p><h3>promise</h3><p>我们上面用 <code>async</code> 函数生成了未来量，但这不是唯一的方式。另外有一种常用的方式是 <code>promise</code> <span class=\"orange\">[13]</span>，我称之为“承诺量”。我们同样看一眼上面的例子用 <code>promise</code> 该怎么写：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\nclass scoped_thread {\n  … // 定义同上，略\n};\n\nvoid work(promise&lt;int&gt; prom)\n{\n  // 假装我们计算了很久\n  this_thread::sleep_for(2s);\n  prom.set_value(42);\n}\n\nint main()\n{\n  promise&lt;int&gt; prom;\n  auto fut = prom.get_future();\n  scoped_thread th{work,\n                   move(prom)};\n  // 干一些其他事\n  cout &lt;&lt; \"I am waiting now\\n\";\n  cout &lt;&lt; \"Answer: \" &lt;&lt; fut.get()\n       &lt;&lt; '\\n';\n}\n</code></pre><p><code>promise</code> 和 <code>future</code> 在这里成对出现，可以看作是一个一次性管道：有人需要兑现承诺，往 <code>promise</code> 里放东西（<code>set_value</code>）；有人就像收期货一样，到时间去 <code>future</code>（写到这里想到，期货英文不就是 future 么，是不是该翻译成期货量呢？😝）里拿（<code>get</code>）就行了。我们把 <code>prom</code> 移动给新线程，这样老线程就完全不需要管理它的生命周期了。</p><p>就这个例子而言，使用 <code>promise</code> 没有 <code>async</code> 方便，但可以看到，这是一种非常灵活的方式，你不需要在一个函数结束的时候才去设置 <code>future</code> 的值。仍然需要注意的是，一组 <code>promise</code> 和 <code>future</code> 只能使用一次，既不能重复设，也不能重复取。</p><p><code>promise</code> 和 <code>future</code> 还有个有趣的用法是使用 <code>void</code> 类型模板参数。这种情况下，两个线程之间不是传递参数，而是进行同步：当一个线程在一个 <code>future&lt;void&gt;</code> 上等待时（使用 <code>get()</code> 或 <code>wait()</code>），另外一个线程可以通过调用 <code>promise&lt;void&gt;</code> 上的 <code>set_value()</code> 让其结束等待、继续往下执行。有兴趣的话，你可以自己试一下，我就不给例子了。</p><h3>packaged_task</h3><p>我们最后要讲的一种 <code>future</code> 的用法是打包任务 <code>packaged_task</code> <span class=\"orange\">[14]</span>，我们同样给出完成相同功能的示例，让你方便对比一下：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\nclass scoped_thread {\n  … // 定义同上，略\n};\n\nint work()\n{\n  // 假装我们计算了很久\n  this_thread::sleep_for(2s);\n  return 42;\n}\n\nint main()\n{\n  packaged_task&lt;int()&gt; task{work};\n  auto fut = task.get_future();\n  scoped_thread th{move(task)};\n  // 干一些其他事\n  this_thread::sleep_for(1s);\n  cout &lt;&lt; \"I am waiting now\\n\";\n  cout &lt;&lt; \"Answer: \" &lt;&lt; fut.get()\n       &lt;&lt; '\\n';\n}\n</code></pre><p>打包任务里打包的是一个函数，模板参数就是一个函数类型。跟 <code>thread</code>、<code>future</code>、<code>promise</code> 一样，<code>packaged_task</code> 只能移动，不能复制。它是个函数对象，可以像正常函数一样被执行，也可以传递给 <code>thread</code> 在新线程中执行。它的特别地方，自然也是你可以从它得到一个未来量了。通过这个未来量，你可以得到这个打包任务的返回值，或者，至少知道这个打包任务已经执行结束了。</p><h2>内容小结</h2><p>今天我们看了一下并发编程的原因、难点，以及 C++ 里的进行多线程计算的基本类，包括线程、互斥量、未来量等。这些对象的使用已经可以初步展现并发编程的困难，但更麻烦的事情还在后头呢……</p><h2>课后思考</h2><p>请试验一下文中的代码，并思考一下，并发编程中哪些情况下会发生死锁？</p><p>如果有任何问题或想法，欢迎留言与我分享。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Herb Sutter, “The free lunch is over”. <a href=\"http://www.gotw.ca/publications/concurrency-ddj.htm\">http://www.gotw.ca/publications/concurrency-ddj.htm</a> </span></p><p><span class=\"reference\">[2] Herb Sutter, “Effective concurrency”. <a href=\"https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-use-an-active-object-instead-of-a-mutex/\">https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-use-an-active-object-instead-of-a-mutex/</a> </span></p><p><span class=\"reference\">[3] Anthony Williams, <em>C++ Concurrency in Action</em> (2nd ed.). Manning, 2019, <a href=\"https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition\">https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition</a> </span></p><p><span class=\"reference\">[4] cppreference.com, “std::thread”. <a href=\"https://en.cppreference.com/w/cpp/thread/thread\">https://en.cppreference.com/w/cpp/thread/thread</a> </span></p><p><span class=\"reference\">[4a] cppreference.com, “std::thread”. <a href=\"https://zh.cppreference.com/w/cpp/thread/thread\">https://zh.cppreference.com/w/cpp/thread/thread</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “std::jthread”. <a href=\"https://en.cppreference.com/w/cpp/thread/jthread\">https://en.cppreference.com/w/cpp/thread/jthread</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::mutex”. <a href=\"https://en.cppreference.com/w/cpp/thread/mutex\">https://en.cppreference.com/w/cpp/thread/mutex</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::mutex”. <a href=\"https://zh.cppreference.com/w/cpp/thread/mutex\">https://zh.cppreference.com/w/cpp/thread/mutex</a> </span></p><p><span class=\"reference\">[7] cppreference.com, “std::recursive_mutex”. <a href=\"https://en.cppreference.com/w/cpp/thread/recursive_mutex\">https://en.cppreference.com/w/cpp/thread/recursive_mutex</a> </span></p><p><span class=\"reference\">[7a] cppreference.com, “std::recursive_mutex”. <a href=\"https://zh.cppreference.com/w/cpp/thread/recursive_mutex\">https://zh.cppreference.com/w/cpp/thread/recursive_mutex</a> </span></p><p><span class=\"reference\">[8] cppreference.com, “Standard library header &lt;mutex&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/mutex\">https://en.cppreference.com/w/cpp/header/mutex</a> </span></p><p><span class=\"reference\">[8a] cppreference.com, “标准库头文件 &lt;mutex&gt;”. <a href=\"https://zh.cppreference.com/w/cpp/header/mutex\">https://zh.cppreference.com/w/cpp/header/mutex</a> </span></p><p><span class=\"reference\">[9] cppreference.com, “std::recursive_mutex”. <a href=\"https://en.cppreference.com/w/cpp/thread/condition_variable\">https://en.cppreference.com/w/cpp/thread/condition_variable</a> </span></p><p><span class=\"reference\">[9a] cppreference.com, “std::recursive_mutex”. <a href=\"https://zh.cppreference.com/w/cpp/thread/condition_variable\">https://zh.cppreference.com/w/cpp/thread/condition_variable</a> </span></p><p><span class=\"reference\">[10] cppreference.com, “std::future”. <a href=\"https://en.cppreference.com/w/cpp/thread/future\">https://en.cppreference.com/w/cpp/thread/future</a> </span></p><p><span class=\"reference\">[10a] cppreference.com, “std::future”. <a href=\"https://zh.cppreference.com/w/cpp/thread/future\">https://zh.cppreference.com/w/cpp/thread/future</a> </span></p><p><span class=\"reference\">[11] cppreference.com, “std::async”. <a href=\"https://en.cppreference.com/w/cpp/thread/async\">https://en.cppreference.com/w/cpp/thread/async</a> </span></p><p><span class=\"reference\">[11a] cppreference.com, “std::async”. <a href=\"https://zh.cppreference.com/w/cpp/thread/async\">https://zh.cppreference.com/w/cpp/thread/async</a> </span></p><p><span class=\"reference\">[12] cppreference.com, “std::shared_future”. <a href=\"https://en.cppreference.com/w/cpp/thread/shared_future\">https://en.cppreference.com/w/cpp/thread/shared_future</a> </span></p><p><span class=\"reference\">[12a] cppreference.com, “std::shared_future”. <a href=\"https://en.cppreference.com/w/cpp/thread/shared_future\">https://en.cppreference.com/w/cpp/thread/shared_future</a> </span></p><p><span class=\"reference\">[13] cppreference.com, “std::promise”. <a href=\"https://en.cppreference.com/w/cpp/thread/promise\">https://en.cppreference.com/w/cpp/thread/promise</a> </span></p><p><span class=\"reference\">[13a] cppreference.com, “std::promise”. <a href=\"https://zh.cppreference.com/w/cpp/thread/promise\">https://zh.cppreference.com/w/cpp/thread/promise</a> </span></p><p><span class=\"reference\">[14] cppreference.com, “std::packaged_task”. <a href=\"https://en.cppreference.com/w/cpp/thread/packaged_task\">https://en.cppreference.com/w/cpp/thread/packaged_task</a> </span></p><p><span class=\"reference\">[14a] cppreference.com, “std::packaged_task”. <a href=\"https://zh.cppreference.com/w/cpp/thread/packaged_task\">https://zh.cppreference.com/w/cpp/thread/packaged_task</a> </span></p>","neighbors":{"left":{"article_title":"18 | 应用可变模板和tuple的编译期技巧","id":185899},"right":{"article_title":"20 | 内存模型和atomic：理解并发的复杂性","id":186708}}},{"article_id":186708,"article_title":"20 | 内存模型和atomic：理解并发的复杂性","article_content":"<p>你好，我是吴咏炜。</p><p>上一讲我们讨论了一些并发编程的基本概念，今天我们来讨论一个略有点绕的问题，C++ 里的内存模型和原子量。</p><h2>C++98 的执行顺序问题</h2><p>C++98 的年代里，开发者们已经了解了线程的概念，但 C++ 的标准里则完全没有提到线程。从实践上，估计大家觉得不提线程，C++ 也一样能实现多线程的应用程序吧。不过，很多聪明人都忽略了，下面的事实可能会产生不符合直觉预期的结果：</p><ul>\n<li>为了优化的必要，编译器是可以调整代码的执行顺序的。唯一的要求是，程序的“可观测”外部行为是一致的。</li>\n<li>处理器也会对代码的执行顺序进行调整（所谓的 CPU 乱序执行）。在单处理器的情况下，这种乱序无法被程序观察到；但在多处理器的情况下，在另外一个处理器上运行的另一个线程就可能会察觉到这种不同顺序的后果了。</li>\n</ul><p>对于上面的后一点，大部分开发者并没有意识到。原因有好几个方面：</p><ul>\n<li>多处理器的系统在那时还不常见</li>\n<li>主流的 x86 体系架构仍保持着较严格的内存访问顺序</li>\n<li>只有在数据竞争（data race）激烈的情况下才能看到“意外”的后果</li>\n</ul><p>举一个例子，假设我们有两个全局变量：</p><pre><code class=\"language-c++\">int x = 0;\nint y = 0;\n</code></pre><p>然后我们在一个线程里执行：</p><pre><code class=\"language-c++\">x = 1;\ny = 2;\n</code></pre><p>在另一个线程里执行：</p><pre><code class=\"language-c++\">if (y == 2) {\n  x = 3;\n  y = 4;\n}\n</code></pre><!-- [[[read_end]]] --><p>想一下，你认为上面的代码运行完之后，<code>x</code>、<code>y</code> 的数值有几种可能？</p><p>你如果认为有两种可能，1、2 和 3、4 的话，那说明你是按典型程序员的思维模式看问题的——没有像编译器和处理器一样处理问题。事实上，1、4 也是一种结果的可能。有两个基本的原因可以造成这一后果：</p><ul>\n<li>编译器没有义务一定按代码里给出的顺序产生代码。事实上，跟据上下文调整代码的执行顺序，使其最有利于处理器的架构，是优化中很重要的一步。就单个线程而言，先执行 <code>x = 1</code> 还是先执行 <code>y = 2</code> 完全是件无关紧要的事：它们没有外部“可观察”的区别。</li>\n<li>在多处理器架构中，各个处理器可能存在缓存不一致性问题。取决于具体的处理器类型、缓存策略和变量地址，对变量 <code>y</code> 的写入有可能先反映到主内存中去。之所以这个问题似乎并不常见，是因为常见的 x86 和 x86-64 处理器是在顺序执行方面做得最保守的——大部分其他处理器，如 ARM、DEC Alpha、PA-RISC、IBM Power、IBM z架构和 Intel Itanium 在内存序问题上都比较“松散”。x86 使用的内存模型基本提供了顺序一致性（sequential consistency）；相对的，ARM 使用的内存模型就只是松散一致性（relaxed consistency）。较为严格的描述，请查看参考资料 <span class=\"orange\">[1]</span> 和里面提供的进一步资料。</li>\n</ul><p>虽说 Intel 架构处理器的顺序一致性比较好，但在多处理器（包括多核）的情况下仍然能够出现写读序列变成读写序列的情况，产生意料之外的后果。参考资料 <span class=\"orange\">[2]</span> 中提供了完整的例子，包括示例代码。对于缓存不一致性问题的一般中文介绍，可以查看参考资料 <span class=\"orange\">[3]</span>。</p><h3>双重检查锁定</h3><p>在多线程可能对同一个单件进行初始化的情况下，有一个双重检查锁定的技巧，可基本示意如下：</p><pre><code class=\"language-c++\">// 头文件\nclass singleton {\npublic:\n  static singleton* instance();\n  …\nprivate:\n  static singleton* inst_ptr_;\n};\n\n// 实现文件\nsingleton* singleton::inst_ptr_ =\n  nullptr;\n\nsingleton* singleton::instance()\n{\n  if (inst_ptr_ == nullptr) {\n    lock_guard lock;  // 加锁\n    if (inst_ptr_ == nullptr) {\n      inst_ptr_ = new singleton();\n    }\n  }\n  return inst_ptr_;\n}\n</code></pre><p>这个代码的目的是消除大部分执行路径上的加锁开销。原本的意图是：如果 <code>inst_ptr_</code> 没有被初始化，执行才会进入加锁的路径，防止单件被构造多次；如果 <code>inst_ptr_</code> 已经被初始化，那它就会被直接返回，不会产生额外的开销。虽然看上去很美，但它一样有着上面提到的问题。Scott Meyers 和 Andrei Alexandrecu 详尽地分析了这个用法 <span class=\"orange\">[4]</span>，然后得出结论：即使花上再大的力气，这个用法仍然有着非常多的难以填补的漏洞。本质上还是上面说的，优化编译器会努力击败你试图想防止优化的努力，而多处理器会以令人意外的方式让代码走到错误的执行路径上去。他们分析得非常详细，建议你可以花时间学习一下。</p><h3>volatile</h3><p>在某些编译器里，使用 <code>volatile</code> 关键字可以达到内存同步的效果。但我们必须记住，这不是 <code>volatile</code> 的设计意图，也不能通用地达到内存同步的效果。<code>volatile</code> 的语义只是防止编译器“优化”掉对内存的读写而已。它的合适用法，目前主要是用来读写映射到内存地址上的 I/O 操作。</p><p>由于 <code>volatile</code> 不能在多处理器的环境下确保多个线程能看到同样顺序的数据变化，在今天的通用应用程序中，不应该再看到 <code>volatile</code> 的出现。</p><h2>C++11 的内存模型</h2><p>为了从根本上消除这些漏洞，C++11 里引入了适合多线程的内存模型。我们可以在参考资料 <span class=\"orange\">[5]</span> 里了解更多的细节。跟我们开发密切相关的是：现在我们有了原子对象（atomic）和使用原子对象的获得（acquire）、释放（release）语义，可以真正精确地控制内存访问的顺序性，保证我们需要的内存序。</p><h3>内存屏障和获得、释放语义</h3><p>拿刚才的那个例子来说，如果我们希望结果只能是 1、2 或 3、4，即满足程序员心中的完全存储序（total store ordering），我们需要在 <code>x = 1</code> 和 <code>y = 2</code> 两句语句之间加入内存屏障，禁止这两句语句交换顺序。我们在此种情况下最常用的两个概念是“获得”和“释放”：</p><ul>\n<li><strong>获得</strong>是一个对内存的<strong>读</strong>操作，当前线程的任何后面的读写操作都不允许重排到这个操作的<strong>前面</strong>去。</li>\n<li><strong>释放</strong>是一个对内存的<strong>写</strong>操作，当前线程的任何前面的读写操作都不允许重排到这个操作的<strong>后面</strong>去。</li>\n</ul><p>具体到我们上面的第一个例子，我们需要把 <code>y</code> 声明成 <code>atomic&lt;int&gt;</code>。然后，我们在线程 1 需要使用释放语义：</p><pre><code class=\"language-c++\">x = 1;\ny.store(2, memory_order_release);\n</code></pre><p>在线程 2 我们对 <code>y</code> 的读取应当使用获得语义，但存储只需要松散内存序即可：</p><pre><code class=\"language-c++\">if (y.load(memory_order_acquire) ==\n    2) {\n  x = 3;\n  y.store(4, memory_order_relaxed);\n}\n</code></pre><p>我们可以用下图示意一下，每一边的代码都不允许重排越过黄色区域，且如果 <code>y</code> 上的释放早于 <code>y</code> 上的获取的话，释放前对内存的修改都在另一个线程的获取操作后可见：</p><p><img src=\"https://static001.geekbang.org/resource/image/33/14/33484c6762bb98d91ce8d30a752e2614.png?wh=4758*1458\" alt=\"\"></p><p>事实上，在我们把 <code>y</code> 改成 <code>atomic&lt;int&gt;</code> 之后，两个线程的代码一行不改，执行结果都会是符合我们的期望的。因为 <code>atomic</code> 变量的写操作缺省就是释放语义，读操作缺省就是获得语义（不严格的说法，精确表述见下面的内存序部分）。即</p><ul>\n<li><code>y = 2</code> 相当于 <code>y.store(2, memory_order_release)</code></li>\n<li><code>y == 2</code> 相当于 <code>y.load(memory_order_acquire) == 2</code></li>\n</ul><p>但是，缺省行为可能是对性能不利的：我们并不需要在任何情况下都保证操作的顺序性。</p><p>另外，我们应当注意一下，acquire 和 release 通常都是配对出现的，目的是保证如果对同一个原子对象的 release 发生在 acquire 之前的话，release 之前发生的内存修改能够被 acquire 之后的内存读取全部看到。</p><h3>atomic</h3><p>刚才是对 atomic 用法的一个非正式介绍。下面我们对 atomic 做一个稍完整些的说明（更完整的见 <span class=\"orange\">[6]</span>）。</p><p>C++11 在 &lt;atomic&gt; 头文件中引入了 <code>atomic</code> 模板，对原子对象进行了封装。我们可以将其应用到任何类型上去。当然对于不同的类型效果还是有所不同的：对于整型量和指针等简单类型，通常结果是无锁的原子对象；而对于另外一些类型，比如 64 位机器上大小不是 1、2、4、8（有些平台/编译器也支持对更大的数据进行无锁原子操作）的类型，编译器会自动为这些原子对象的操作加上锁。编译器提供了一个原子对象的成员函数 <code>is_lock_free</code>，可以检查这个原子对象上的操作是否是无锁的。</p><p>原子操作有三类：</p><ul>\n<li>读：在读取的过程中，读取位置的内容不会发生任何变动。</li>\n<li>写：在写入的过程中，其他执行线程不会看到部分写入的结果。</li>\n<li>读‐修改‐写：读取内存、修改数值、然后写回内存，整个操作的过程中间不会有其他写入操作插入，其他执行线程不会看到部分写入的结果。</li>\n</ul><p>&lt;atomic&gt; 头文件中还定义了内存序，分别是：</p><ul>\n<li><code>memory_order_relaxed</code>：松散内存序，只用来保证对原子对象的操作是原子的</li>\n<li><code>memory_order_consume</code>：目前不鼓励使用，我就不说明了</li>\n<li><code>memory_order_acquire</code>：获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见</li>\n<li><code>memory_order_release</code>：释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</li>\n<li><code>memory_order_acq_rel</code>：获得释放操作，一个读‐修改‐写操作同时具有获得语义和释放语义，即它前后的任何读写操作都不允许重排，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见，当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</li>\n<li><code>memory_order_seq_cst</code>：顺序一致性语义，对于读操作相当于获取，对于写操作相当于释放，对于读‐修改‐写操作相当于获得释放，<strong>是所有原子操作的默认内存序</strong>（除此之外，顺序一致性还保证了多个原子量的修改在所有线程里观察到的修改顺序都相同；我们目前的讨论暂不涉及多个原子量的修改）</li>\n</ul><p><code>atomic</code> 有下面这些常用的成员函数：</p><ul>\n<li>默认构造函数（只支持零初始化）</li>\n<li>拷贝构造函数被删除</li>\n<li>使用内置对象类型的构造函数（不是原子操作）</li>\n<li>可以从内置对象类型赋值到原子对象（相当于 <code>store</code>）</li>\n<li>可以从原子对象隐式转换成内置对象（相当于 <code>load</code>）</li>\n<li><code>store</code>，写入对象到原子对象里，第二个可选参数是内存序类型</li>\n<li><code>load</code>，从原子对象读取内置对象，有个可选参数是内存序类型</li>\n<li><code>is_lock_free</code>，判断对原子对象的操作是否无锁（是否可以用处理器的指令直接完成原子操作）</li>\n<li><code>exchange</code>，交换操作，第二个可选参数是内存序类型（这是读‐修改‐写操作）</li>\n<li><code>compare_exchange_weak</code> 和 <code>compare_exchange_strong</code>，两个比较加交换（CAS）的版本，你可以分别指定成功和失败时的内存序，也可以只指定一个，或使用默认的最安全内存序（这是读‐修改‐写操作）</li>\n<li><code>fetch_add</code> 和 <code>fetch_sub</code>，仅对整数和指针内置对象有效，对目标原子对象执行加或减操作，返回其原始值，第二个可选参数是内存序类型（这是读‐修改‐写操作）</li>\n<li><code>++</code> 和 <code>--</code>（前置和后置），仅对整数和指针内置对象有效，对目标原子对象执行增一或减一，操作使用顺序一致性语义，并注意返回的不是原子对象的引用（这是读‐修改‐写操作）</li>\n<li><code>+=</code> 和 <code>-=</code>，仅对整数和指针内置对象有效，对目标原子对象执行加或减操作，返回操作之后的数值，操作使用顺序一致性语义，并注意返回的不是原子对象的引用（这是读‐修改‐写操作）</li>\n</ul><p>有了原子对象之后，我们可以轻而易举地把<a href=\"https://time.geekbang.org/column/article/169263\">[第 2 讲]</a> 中的 <code>shared_count</code> 变成线程安全。我们只需要包含 &lt;atomic&gt; 头文件，并把下面这行</p><pre><code class=\"language-c++\">  long count_;\n</code></pre><p>修改成</p><pre><code class=\"language-c++\">  std::atomic_long count_;\n</code></pre><p>即可（<code>atomic_long</code> 是 <code>atomic&lt;long&gt;</code> 的类型别名）。不过，由于我们并不需要 <code>++</code> 之后计数值影响其他行为，在 <code>add_count</code> 中执行简单的 <code>++</code>、使用顺序一致性语义略有浪费。更好的做法是将其实现成：</p><pre><code class=\"language-c++\">  void add_count() noexcept\n  {\n    count_.fetch_add(\n      1, std::memory_order_relaxed);\n  }\n</code></pre><h4>is_lock_free 的可能问题</h4><p>注意，macOS 上在使用 Clang 时似乎不支持对需要加锁的对象使用 <code>is_lock_free</code> 成员函数，此时链接会出错。而 GCC 在这种情况下，需要确保系统上装了 libatomic。以 CentOS 7 下的 GCC 7 为例，我们可以使用下面的语句来安装：</p><blockquote>\n<p><code>sudo yum install devtoolset-7-libatomic-devel</code></p>\n</blockquote><p>然后，用下面的语句编译可以通过：</p><blockquote>\n<p><code>g++ -pthread test.cpp -latomic</code></p>\n</blockquote><p>Windows 下使用 MSVC 则没有问题。</p><h3>mutex</h3><p>上一讲我们已经讨论了互斥量。今天，我们只需要补充两点：</p><ul>\n<li>互斥量的加锁操作（<code>lock</code>）具有获得语义</li>\n<li>互斥量的解锁操作（<code>unlock</code>）具有释放语义</li>\n</ul><p>有了目前讲过的这些知识，我们终于可以实现一个真正安全的双重检查锁定了：</p><pre><code class=\"language-c++\">// 头文件\nclass singleton {\npublic:\n  static singleton* instance();\n  …\nprivate:\n  static mutex lock_;\n  static atomic&lt;singleton*&gt;\n    inst_ptr_;\n};\n\n// 实现文件\nmutex singleton::lock_;\natomic&lt;singleton*&gt;\n  singleton::inst_ptr_;\n\nsingleton* singleton::instance()\n{\n  singleton* ptr = inst_ptr_.load(\n    memory_order_acquire);\n  if (ptr == nullptr) {\n    lock_guard&lt;mutex&gt; guard{lock_};\n    ptr = inst_ptr_.load(\n      memory_order_relaxed);\n    if (ptr == nullptr) {\n      ptr = new singleton();\n      inst_ptr_.store(\n        ptr, memory_order_release);\n    }\n  }\n  return inst_ptr_;\n}\n</code></pre><h2>并发队列的接口</h2><p>在结束这一讲之前，我们来检查一下并发对编程接口的冲击。回想我们之前讲到标准库里 <code>queue</code> 有下面这样的接口：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass queue {\npublic:\n  …\n  T&amp; front();\n  const T&amp; front() const;\n  void pop();\n  …\n}\n</code></pre><p>我们之前还问过为什么 <code>pop</code> 不直接返回第一个元素。可到了并发的年代，我们不禁要问，这样的接口设计到底明智吗？</p><p><strong>会不会在我们正在访问 <code>front()</code> 的时候，这个元素就被 <code>pop</code> 掉了？</strong></p><p>事实上，上面这样的接口是不可能做到并发安全的。并发安全的接口大概长下面这个样子：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass queue {\npublic:\n  …\n  void wait_and_pop(T&amp; dest)\n  bool try_pop(T&amp; dest);\n  …\n}\n</code></pre><p>换句话说，要准备好位置去接收；然后如果接收成功了，才安安静静地在自己的线程里处理已经被弹出队列的对象。接收方式还得分两种，阻塞式的和非阻塞式的……</p><p>那我为什么要在内存模型和原子量这一讲里讨论这个问题呢？因为并发队列的实现，经常是用原子量来达到无锁和高性能的。单生产者、单消费者的并发队列，用原子量和获得、释放语义就能简单实现。对于多生产者或多消费者的情况，那实现就比较复杂了，一般会使用 <code>compare_exchange_strong</code> 或 <code>compare_exchange_weak</code>。讨论这个话题的复杂性，就大大超出了本专栏的范围了。你如果感兴趣的话，可以查看下面几项内容：</p><ul>\n<li>nvwa::fc_queue <span class=\"orange\">[7]</span> 给出了一个单生产者、单消费者的无锁并发定长环形队列，代码长度是几百行的量级。</li>\n<li>moodycamel::ConcurrentQueue <span class=\"orange\">[8]</span> 给出了一个多生产者、多消费者的无锁通用并发队列，代码长度是几千行的量级。</li>\n<li>陈皓给出了一篇很棒的对无锁队列的中文描述 <span class=\"orange\">[9]</span>，推荐阅读。</li>\n</ul><h2>内容小结</h2><p>在这一讲里，我们讨论了 C++ 对并发的底层支持，特别是内存模型和原子量。这些底层概念，是在 C++ 里写出高性能并发代码的基础。</p><h2>课后思考</h2><p>在传统 PC 上开发的程序员，应当比较少接触具有松散或弱内存一致性的系统，但原子量和普通变量的区别还是很容易在代码中表现出来的。请你尝试一下多个线程对一个原子量和一个普通全局变量做多次增一操作，观察最后的结果。</p><p>在 Intel 处理器架构上，唯一可见的重排是多处理器下的写读操作。大力推荐你尝试一下参考资料 <span class=\"orange\">[2]</span> 中的例子（Windows 和 Linux 下可直接运行；macOS 下需要使用我的<a href=\"https://gist.github.com/adah1972/8ee7484647ea9a1795089219a3704574\">修改版本</a>或备用<a href=\"http://wyw.dcweb.cn/download.asp?path=&file=ordering.cpp\">下载链接</a>来覆盖下载代码中的 gcc/ordering.cpp），并修改预定义宏。另外一种改法就是把代码中的 <code>X</code>、<code>Y</code> 的类型改成 <code>atomic_int</code>，重排也就消失了。</p><p>如果遇到任何特别问题，欢迎留言与我交流。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Memory ordering”. <a href=\"https://en.wikipedia.org/wiki/Memory_ordering\">https://en.wikipedia.org/wiki/Memory_ordering</a> </span></p><p><span class=\"reference\">[1a] 维基百科, “内存排序”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F\">https://zh.wikipedia.org/zh-cn/内存排序</a> </span></p><p><span class=\"reference\">[2]  Jeff Preshing, “Memory reordering caught in the act”. <a href=\"https://preshing.com/20120515/memory-reordering-caught-in-the-act/\">https://preshing.com/20120515/memory-reordering-caught-in-the-act/</a> </span></p><p><span class=\"reference\">[3] 王欢明, 《多处理器编程：从缓存一致性到内存模型》. <a href=\"https://zhuanlan.zhihu.com/p/35386457\">https://zhuanlan.zhihu.com/p/35386457</a> </span></p><p><span class=\"reference\">[4] Scott Meyers and Andrei Alexandrescu, “C++ and the perils of double-checked locking”. <a href=\"https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf\">https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “Memory model”. <a href=\"https://en.cppreference.com/w/cpp/language/memory_model\">https://en.cppreference.com/w/cpp/language/memory_model</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “内存模型”. <a href=\"https://zh.cppreference.com/w/cpp/language/memory_model\">https://zh.cppreference.com/w/cpp/language/memory_model</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::atomic”. <a href=\"https://en.cppreference.com/w/cpp/atomic/atomic\">https://en.cppreference.com/w/cpp/atomic/atomic</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::atomic”. <a href=\"https://zh.cppreference.com/w/cpp/atomic/atomic\">https://zh.cppreference.com/w/cpp/atomic/atomic</a> </span></p><p><span class=\"reference\">[7] 吴咏炜, nvwa. <a href=\"https://github.com/adah1972/nvwa\">https://github.com/adah1972/nvwa</a> </span></p><p><span class=\"reference\">[8] Cameron Desrochers, moodycamel::ConcurrentQueue. <a href=\"https://github.com/cameron314/concurrentqueue\">https://github.com/cameron314/concurrentqueue</a> </span></p><p><span class=\"reference\">[9] 陈皓, 《无锁队列的实现》. <a href=\"https://coolshell.cn/articles/8239.html\">https://coolshell.cn/articles/8239.html</a> </span></p>","neighbors":{"left":{"article_title":"19 | thread和future：领略异步中的未来","id":186689},"right":{"article_title":"21 | 工具漫谈：编译、格式化、代码检查、排错各显身手","id":187980}}},{"article_id":187980,"article_title":"21 | 工具漫谈：编译、格式化、代码检查、排错各显身手","article_content":"<p>你好，我是吴咏炜。</p><p>现代 C++ 语言，我们讲到这里就告一段落了。今天我们正式开启了实战篇，先讲一个轻松些的话题——工具。</p><h2>编译器</h2><p>当然，轻松不等于不重要。毕竟，工欲善其事，必先利其器。我们做 C++ 开发，最基本的工具就是编译器，对其有些了解显然也是必要的。我们就先来看看我在专栏开头就提到的三种编译器，MSVC <span class=\"orange\">[1]</span>、GCC <span class=\"orange\">[2]</span> 和 Clang <span class=\"orange\">[3]</span>。</p><h3>MSVC</h3><p>三种编译器里最老资格的就是 MSVC 了。据微软员工在 2015 年的一篇博客，在 MSVC 的代码里还能找到 1982 年写下的注释 <span class=\"orange\">[4]</span>。这意味着 MSVC 是最历史悠久、最成熟，但也是最有历史包袱的编译器。</p><p>微软的编译器在传统代码的优化方面做得一直不错，但对模板的支持则是它的软肋，在 Visual Studio 2015 之前尤其不行——之前模板问题数量巨大，之后就好多了。而 2018 年 11 月 MSVC 宣布终于能够编译 range-v3 库，也成了一件值得庆贺的事 <span class=\"orange\">[5]</span>。当然，这件事情是值得高兴的，但考虑我在 2016 年的演讲里就已经用到了 range-v3，不能不觉得还是有点晚了。此外，我已经提过，微软对代码的“容忍度”一直有点太高（缺省情况下，不使用 <code>/Za</code> 选项），能接受 C++ 标准认为非法的代码，这至少对写跨平台的代码而言，绝不是一件好事。</p><!-- [[[read_end]]] --><p>MSVC 当然也有领先的地方。它对标准库的实现一直不算慢，较早就提供了比较健壮的线程（<a href=\"https://time.geekbang.org/column/article/186689\">[第 19 讲]</a>、<a href=\"https://time.geekbang.org/column/article/186708\">[第 20 讲]</a>）、正则表达式（<span class=\"orange\">[6]</span>）等标准库。在并发 <span class=\"orange\">[7]</span> 方面，微软也是比较领先的，并主导了协程的技术规格书 <span class=\"orange\">[8]</span>。微软一开始支持 C++ 标准的速度比较慢，但慢慢地，微软已经把全面支持 C++ 标准当作了目标，并在 2018 年宣布已全面支持 C++17 标准；虽然同时也承认仍有一些重大问题影响了其编译一些重要的开源 C++ 项目 <span class=\"orange\">[9]</span>。</p><p>MSVC 有一个地方我一直比较喜欢，就是代码里可以写出要求链接具体什么库，而链接什么库的命令，可以是使用的第三方代码里直接给出的。这就使得在命令行上编译使用到第三方库（如 Boost）的代码变得非常容易。在使用 GCC 和 Clang 时，用到什么库，就必须在命令行上写出来，这就迫使程序员使用更规范、也更麻烦的管理方式了。具体而言，对于下面的这个最小的单元测试程序：</p><pre><code class=\"language-c++\">#define BOOST_TEST_MAIN\n#include &lt;boost/test/unit_test.hpp&gt;\n\nBOOST_AUTO_TEST_CASE(minimal_test)\n{\n  BOOST_CHECK(1 + 1 == 2);\n}\n</code></pre><p>使用 GCC 或 Clang 时你需要输入类似下面这样的命令：</p><blockquote>\n<p><code>g++ -DBOOST_TEST_DYN_LINK test.cpp -lboost_unit_test_framework</code></p>\n</blockquote><p>而 Windows 下使用 MSVC 你只需要输入：</p><blockquote>\n<p><code>cl /DBOOST_TEST_DYN_LINK /EHsc /MD test.cpp</code></p>\n</blockquote><p>一下子就简单多了。</p><p>另外，在免费的 C++ 集成开发环境里，Visual Studio Community Edition 恐怕可以算是最好的了，至少在 Windows 上是这样。在自动完成功能和调试功能上 Visual Studio 做得特别好，为其他的免费工具所不及。如果你开发的 C++ 程序主要在 Windows 上运行，那 MSVC 就应该是首选了。</p><h3>Clang</h3><p>相反，在三个编译器里，最新的就是 Clang。作为 LLVM 项目的一部分，它的最早发布是在 2007 年，然后流行程度一路飙升，到现在成了一个通用的跨平台编译器。其中有不少苹果的支持——因为苹果对 GCC 的许可要求不满意，苹果把 LLVM 开发者 Chris Lattner 招致麾下（2005—2017），期间他除了为苹果设计开发了全新的语言 Swift，Clang 的 C++ 支持也得到了飞速的发展。</p><p>作为后来者，Clang 在错误信息易用性上做出了极大的改善。Clang 虽然一直在模拟 GCC 的功能和命令行，但错误信息的友好性是它的最大亮点。在语言层面，Clang 对 C++ 标准的支持也是飞速，正如下面这张图所展示的那样（<span class=\"orange\">[10]</span>）：</p><p><img src=\"https://static001.geekbang.org/resource/image/a6/71/a6432b0cbdc5ad6965402800f2057971.png\" alt=\"\"></p><p>可以看到，Clang 在 2011 异军突起，对 C++11 的支持程度在短时间甚至还超过了原先的领跑者 GCC。由于 Clang/LLVM 的模块化设计，在 Clang 上扩展新功能相当容易；而且动态库 libclang 直接向开发者暴露了分析 C++ 代码的接口，这也是 Clang 流行的一个主要原因。</p><p>即使在我主要使用 Windows 工作的时候，我在机器上也装了 Clang。我主要不是用它编译，而是利用它对 C++ 的理解，做代码的格式化（本讲下面会讲）和自动完成——对于文件数不多的项目，我还是喜欢使用 Vim <span class=\"orange\">[11]</span>，那机器上能不能用 clang_complete <span class=\"orange\">[12]</span> 区别就很大了。有了 clang_complete，那 Vim 里也就有个不算太笨的 C++ 自动完成引擎了。顾名思义，clang_complete 主要依赖的就是 Clang 了，更精确地说，是 libclang。</p><p>另外，当我写出在 MSVC 下编译不过的代码时，我也会看看代码能不能在 Clang 下通过。如果能过，那我就比较有信心，我写出的代码是正确的，只不过是 MSVC 处理不了而已😈。</p><p>Clang 目前在 macOS 下是默认的 C/C++ 编译器。在 Linux 和 Windows 下当然也都能安装：这种情况下，Clang 会使用平台上的主流 C++ 库，也就是在 Linux 上使用 libstdc++，在 Windows 上使用 MSVC 的 C++ 运行时。只有在 macOS 上，Clang 才会使用其原生 C++ 库，libc++ <span class=\"orange\">[13]</span>。顺便说一句，如果你想阅读一下现代 C++ 标准库的参考实现的话，libc++ 是可读性最好的——不过，任何一个软件产品的源代码都不是以可读性为第一考量，比起教科书、专栏里的代码例子，libc++ 肯定是要复杂多了。</p><p>最后一个关于版本号的说明：苹果开发工具里带的 Clang 的是苹果自己维护的一个分支，版本号和苹果的 Xcode 开发工具版本号一致，和开源项目 Clang 的版本号没有关系，显得比较乱。目前 Apple Clang 的最新版本是 11 了，但功能上落后于官方的 LLVM Clang 9.0 <span class=\"orange\">[14]</span>。要想使用最新版本的 Clang，最方便的方式是使用 Homebrew <span class=\"orange\">[15]</span> 安装 llvm：</p><blockquote>\n<p><code>brew install llvm</code></p>\n</blockquote><p>安装完之后，新的 clang 和 clang++ 工具在 /usr/local/opt/llvm/bin 目录下，和系统原有的命令不会发生冲突。你如果需要使用新的工具的话，需要改变路径的顺序，或者自己创建命令的别名（alias）。</p><h3>GCC</h3><p>GCC 的第一个版本发布于 1987 年，是由自由软件运动的发起人 Richard Stallman（常常被缩写为 RMS）亲自写的。因而，从诞生伊始，GCC 就带着很强的意识形态，承担着振兴自由软件的任务。在 GNU/Linux 平台上，GCC 自然是首选的编译器。自由软件的开发者，大部分也选择了 GCC。由于 GCC 是用 GPL 发布的，任何对 GCC 的修改都必须以 GPL 协议发布。这就迫使想修改 GCC 的人要为 GCC 做出贡献。这对自由软件当然是件好事，但对一家公司来讲就未必了。此外，你想拆出 GCC 的一部分来做其他事情，比如对代码进行分析，也绝不是件容易的事。这些问题，实际上就是迫使苹果公司在 LLVM/Clang 上投资的动机了。</p><p>作为应用最广的自由软件之一，GCC 无疑是非常成熟的软件。某些实验性的功能，比如对概念的支持，也是最早在 GCC 上面出现的。对 C++ 标准的支持，GCC 一直跟得非常紧，但是，由于自由软件依靠志愿者的工作，而非项目经理或产品经理的管理，对不同功能的优先级跟商业产品往往不同，也造就了 GCC 和 MSVC 上各有不同的着重点，优化编译结果哪个性能更高也会依赖于具体的程序。当然 GCC 是跨平台的，这点上肯定是 MSVC 不及的。根据 GCC 的方式写出的代码，跨平台性就会更好。目前我已知的最主要例外是终端上的多语言支持：由于 GCC 在 Windows 上使用了 MSVC 的一个过时的运行库 MSVCRT.DLL，到现在为止 GCC 要在终端上显示中文经常会出现问题 <span class=\"orange\">[16]</span>。</p><p>初期 GCC 在出错信息的友好程度上一直做得不太好。但 Clang 的出现刺激出了一种和 GCC 之间的良性竞争，到今天，GCC 的错误信息反而是最友好的了。我如果遇到程序编译出错在 Clang 里看不明白的话，我会试着用 GCC 再编译看看，在某些情况下，可能 GCC 的出错信息会更让人明白一些。</p><p>在可预见的将来，在自由/开源软件的开发上，GCC 一直会是编译器的标准。</p><h2>格式化工具</h2><h3>Clang-Format</h3><p>我上面提到了 Clang 有着非常模块化的设计，容易被其他工具复用其代码分析功能。LLVM 团队自己也提供一些工具，其中我个人最常用的就是 Clang-Format <span class=\"orange\">[17]</span>。</p><p>在使用 Clang-Format 之前，我也使用过一些其他的格式化工具。它们和 Clang-Format 的最大区别是，它们不理解 C++ 代码，在对付简单的 C 代码时还行，遇到复杂的 C++ 代码时就很容易出问题。此外，Clang-Format 还很智能，可以像人一样，根据具体情况和剩余空间来格式化，比如：</p><pre><code class=\"language-c++\">void func(int arg1, int arg2,\n          int arg3);\n\nvoid long_func_name(int arg1,\n                    int arg2,\n                    int arg3);\n\nvoid a_very_long_func_name(\n  int arg1, int arg2, int arg3);\n</code></pre><p>此外，它也提供了完善的配置项，你可以根据自己的需要来进行配置，如这是我的一个项目使用的格式化选项：</p><p><a href=\"https://github.com/adah1972/nvwa/blob/master/.clang-format\">https://github.com/adah1972/nvwa/blob/master/.clang-format</a></p><p>C++ 项目里放上这样一个文件，代码的格式化问题大家就不用瞎争了——大家确定这个文件的内容就行。</p><p>目前这个专栏的代码格式化选项也和上面的类似，最主要的区别就是行长限制（ColumnLimit）设成了 36，缩进宽度（IndentWidth）等选项基本减半，来适配手机的小显示屏。如果没有 Clang-Format，做代码的小屏适配就会累多了。</p><h2>代码检查工具</h2><h3>Clang-Tidy</h3><p>Clang 项目也提供了其他一些工具，包括代码的静态检查工具 Clang-Tidy <span class=\"orange\">[18]</span>。这是一个比较全面的工具，它除了会提示你危险的用法，也会告诉你如何去现代化你的代码。默认情况下，Clang-Tidy 只做基本的分析。你也可以告诉它你想现代化你的代码和提高代码的可读性：</p><blockquote>\n<p><code>clang-tidy --checks='clang-analyzer-*,modernize-*,readability-*' test.cpp</code></p>\n</blockquote><p>以下面简单程序为例：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;stddef.h&gt;\n\nusing namespace std;\n\nint sqr(int x) { return x * x; }\n\nint main()\n{\n  int a[5] = {1, 2, 3, 4, 5};\n  int b[5];\n  for (int i = 0; i &lt; 5; ++i) {\n    b[i] = sqr(a[i]);\n  }\n  for (int i : b) {\n    cout &lt;&lt; i &lt;&lt; endl;\n  }\n  char* ptr = NULL;\n  *ptr = '\\0';\n}\n</code></pre><p>Clang-Tidy 会报告下列问题：</p><ul>\n<li>&lt;stddef.h&gt; 应当替换成 &lt;cstddef&gt;</li>\n<li>函数形式 <code>int func(…)</code> 应当修改成 <code>auto func(…) -&gt; int</code></li>\n<li>不要使用 C 数组，应当改成 <code>std::array</code></li>\n<li><code>5</code> 是魔术数，应当改成具名常数</li>\n<li><code>NULL</code> 应当改成 <code>nullptr</code></li>\n</ul><p>前两条我不想听。这种情况下，使用配置文件来定制行为就必要了。配置文件叫 .clang-tidy，应当放在你的代码目录下或者代码的一个父目录下。Clang-Tidy 会使用最“近”的那个配置文件。下面的配置文件反映了我的偏好：</p><pre><code class=\"language-yaml\">Checks: 'clang-diagnostic-*,clang-analyzer-*,modernize-*,readability-*,-modernize-deprecated-headers,-modernize-use-trailing-return-type'\n</code></pre><p>世界清静多了：我不想听到的唐僧式的啰唣就消失了。</p><p>使用 Clang-Tidy 还需要注意的地方是，额外的命令行参数应当跟在命令行最后的 <code>--</code> 后面。比如，如果我们要扫描一个 C++ 头文件 foo.h，我们就需要明确告诉 Clang-Tidy 这是 C++ 文件（默认 .h 是 C 文件）。然后，如果我们需要包含父目录下的 common 目录，语言标准使用了 C++17，命令行就应该是下面这个样子：</p><blockquote>\n<p><code>clang-tidy foo.h -- -x c++ -std=c++17 -I../common</code></p>\n</blockquote><p>你有没有注意到，上面 Clang-Tidy 实际上漏报告了些问题：它报告了一些不重要的问题，却漏过了真正严重的问题。这似乎是个实现相关的特殊问题，因为如果把前面那些行删掉的话，后面两行有问题的代码也还是会产生告警的。</p><h3>Cppcheck</h3><p>Clang-Tidy 还是一个比较“重”的工具。它需要有一定的配置，需要能看到文件用到的头文件，运行的时间也会较长。而 Cppcheck <span class=\"orange\">[19]</span> 就是一个非常轻量的工具了。它运行速度飞快，看不到头文件、不需要配置就能使用。它跟 Clang-Tidy 的重点也不太一样：它强调的是发现代码可能出问题的地方，而不太着重代码风格问题，两者功能并不完全重叠。有条件的情况下，这两个工具可以一起使用。</p><p>以上面的例子来为例，Cppcheck 会干脆地报告代码中最严重的问题——空指针的解引用。它的开销很低，却能发现潜在的安全性问题，因而我觉得这是个性价比很高的工具。</p><h2>排错工具</h2><p>排错工具当然也有很多种，我们今天介绍其中两个，Valgrind 和 nvwa::debug_new。</p><h3>Valgrind</h3><p>Valgrind <span class=\"orange\">[20]</span> 算是一个老牌工具了。它是一个非侵入式的排错工具。根据 Valgrind 的文档，它会导致可执行文件的速度减慢 20 至 30 倍。但它可以在不改变可执行文件的情况下，只要求你在编译时增加产生调试信息的命令行参数（<code>-g</code>），即可查出内存相关的错误。</p><p>以下面的简单程序为例：</p><pre><code class=\"language-c++\">int main()\n{\n  char* ptr = new char[20];\n}\n</code></pre><p>在 Linux 上使用 <code>g++ -g test.cpp</code>  编译之后，然后使用 <code>valgrind --leak-check=full ./a.out</code> 检查运行结果，我们得到的输出会如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/50/5cb2060de012f04c4b30741c6e0deb50.png\" alt=\"\"></p><p>即其中包含了内存泄漏的信息，包括内存是从什么地方泄漏的。</p><p>Valgrind 的功能并不只是内存查错，也包含了多线程问题分析等其他功能。要进一步了解相关信息，请查阅其文档。</p><h3>nvwa::debug_new</h3><p>在 nvwa <span class=\"orange\">[21]</span> 项目里，我也包含了一个很小的内存泄漏检查工具。它的最大优点是小巧，并且对程序运行性能影响极小；缺点主要是不及 Valgrind 易用和强大，只能检查 <code>new</code> 导致的内存泄漏，并需要侵入式地对项目做修改。</p><p>需要检测内存泄漏时，你需要把 debug_new.cpp 加入到项目里。比如，可以简单地在命令行上加入这个文件：</p><blockquote>\n<p><code>c++ test.cpp \\</code><br>\n<code>../nvwa/nvwa/debug_new.cpp</code></p>\n</blockquote><p>下面是可能的运行时报错：</p><blockquote>\n<p><code>Leaked object at 0x100302760 (size 20, 0x1000018a4)</code><br>\n<code>*** 1 leaks found</code></p>\n</blockquote><p>在使用 GCC 和 Clang 时，可以让它自动帮你找出内存泄漏点的位置。在命令行上需要加入可执行文件的名称，并产生调试信息：</p><blockquote>\n<p><code>c++ -D_DEBUG_NEW_PROGNAME=\\\"a.out\\\" \\</code><br>\n<code>-g test.cpp \\</code><br>\n<code>../nvwa/nvwa/debug_new.cpp</code></p>\n</blockquote><p>这样，我们就可以在运行时看到一个更明确的错误：</p><blockquote>\n<p><code>Leaked object at 0x100302760 (size 20, main (in a.out) (test.cpp:3))</code><br>\n<code>*** 1 leaks found</code></p>\n</blockquote><p>这个工具的其他用法可以参见文档。</p><h2>网页工具</h2><h3>Compiler Explorer</h3><p>编译器都有输出汇编代码的功能：在 MSVC 上可使用 <code>/Fa</code>，在 GCC 和 Clang 上可使用 <code>-S</code>。不过，要把源代码和汇编对应起来，就需要一定的功力了。在这点上，godbolt.org <span class=\"orange\">[22]</span> 可以提供很大的帮助。它配置了多个不同的编译器，可以过滤掉编译器产生的汇编中开发者一般不关心的部分，并能够使用颜色和提示来帮助你关联源代码和产生的汇编。使用这个网站，你不仅可以快速查看你的代码在不同编译器里的优化结果，还能快速分享结果。比如，下面这个链接，就可以展示我们之前讲过的一个模板元编程代码的编译结果：</p><p><a href=\"https://godbolt.org/z/zPNEJ4\">https://godbolt.org/z/zPNEJ4</a></p><p>网页截图示意如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/e1/a2/e1f3f1f2125c6b0679fbf0752d30cda2.jpg\" alt=\"\"></p><p>当然，作为一个网站，godbolt.org 对代码的复杂度有一定的限制，也不能任意使用你在代码里用到的第三方库（不过，它已经装了不少主流的 C++ 库，如我们后面会讲到的 Boost、Catch2、range-v3 和 cppcoro）。要解决这个问题，你可以在你自己的机器上本地安装它背后的引擎，compiler-explorer <span class=\"orange\">[23]</span>。如果你的代码较复杂，或者有安全、隐私方面的顾虑的话，可以考虑这个方案。</p><h3>C++ Insights</h3><p>如果你在上面的链接里点击了“CppInsights”按钮的话，你就会跳转到 C++ Insights <span class=\"orange\">[24]</span> 网站，并且你贴在 godbolt.org 的代码也会一起被带过去。这个网站提供了另外一个编译器目前没有提供、但十分有用的功能：展示模板的展开过程。</p><p>回想我们在模板编程时的痛苦之一来自于我们需要在脑子中想象模板是如何展开的，而这个过程非常容易出错。当编译器出错时，我们得通过冗长的错误信息来寻找出错原因的蛛丝马迹；当编译器成功编译了一段我们不那么理解的模板代码时，我们在感到庆幸的同时，也往往会仍然很困惑——而使用这个网站，你就可以看到一个正确工作的模板是如何展开的。以<a href=\"https://time.geekbang.org/column/article/185899\">[第 18 讲]</a> 讨论的 <code>make_index_sequence</code> 为例，如果你把代码完整输入到网站上去、然后尝试展开 <code>make_index_sequence&lt;5&gt;</code>，你就会看到 <code>index_sequence_helper</code> 是这样展开的：</p><blockquote>\n<p><code>index_sequence_helper&lt;5&gt;</code><br>\n<code>index_sequence_helper&lt;4, 4&gt;</code><br>\n<code>index_sequence_helper&lt;3, 3, 4&gt;</code><br>\n<code>index_sequence_helper&lt;2, 2, 3, 4&gt;</code><br>\n<code>index_sequence_helper&lt;1, 1, 2, 3, 4&gt;</code><br>\n<code>index_sequence_helper&lt;0, 0, 1, 2, 3, 4&gt;</code></p>\n</blockquote><p>如果我更早一点知道这个工具的话，我就会在讲编译期编程的时候直接建议大家用了，应该会更有助于模板的理解……</p><h2>内容小结</h2><p>在今天这一讲中，我们对各个编译器和一些常用的工具作了简单的介绍。用好工具，可以大大提升你的开发效率。</p><h2>课后思考</h2><p>哪些工具你觉得比较有用？哪些工具你已经在用了（除了编译器）？你个人还会推荐哪些工具？</p><p>欢迎留言和我分享。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Visual Studio. <a href=\"https://visualstudio.microsoft.com/\">https://visualstudio.microsoft.com/</a> </span></p><p><span class=\"reference\">[2] GCC, the GNU Compiler Collection. <a href=\"https://gcc.gnu.org/\">https://gcc.gnu.org/</a> </span></p><p><span class=\"reference\">[3] Clang: a C language family frontend for LLVM. <a href=\"https://clang.llvm.org/\">https://clang.llvm.org/</a> </span></p><p><span class=\"reference\">[4] Jim Springfield,  “Rejuvenating the Microsoft C/C++ compiler”. <a href=\"https://devblogs.microsoft.com/cppblog/rejuvenating-the-microsoft-cc-compiler/\">https://devblogs.microsoft.com/cppblog/rejuvenating-the-microsoft-cc-compiler/</a> </span></p><p><span class=\"reference\">[5] Casey Carter, “Use the official range-v3 with MSVC 2017 version 15.9”. <a href=\"https://devblogs.microsoft.com/cppblog/use-the-official-range-v3-with-msvc-2017-version-15-9/\">https://devblogs.microsoft.com/cppblog/use-the-official-range-v3-with-msvc-2017-version-15-9/</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::regex”. <a href=\"https://en.cppreference.com/w/cpp/regex/basic_regex\">https://en.cppreference.com/w/cpp/regex/basic_regex</a> </span></p><p><span class=\"reference\">[7] Microsoft, “Concurrency Runtime”. <a href=\"https://docs.microsoft.com/en-us/cpp/parallel/concrt/concurrency-runtime\">https://docs.microsoft.com/en-us/cpp/parallel/concrt/concurrency-runtime</a> </span></p><p><span class=\"reference\">[8] ISO/IEC JTC1 SC22 WG21, “Programming languages—C++extensions for coroutines”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf</a> </span></p><p><span class=\"reference\">[9] Ulzii Luvsanbat, “Announcing: MSVC conforms to the C++ standard”. <a href=\"https://devblogs.microsoft.com/cppblog/announcing-msvc-conforms-to-the-c-standard/\">https://devblogs.microsoft.com/cppblog/announcing-msvc-conforms-to-the-c-standard/</a> </span></p><p><span class=\"reference\">[10] Jonathan Adamczewski, “The growth of modern C++ support”. <a href=\"http://brnz.org/hbr/?p=1404\">http://brnz.org/hbr/?p=1404</a> </span></p><p><span class=\"reference\">[11] Vim Online. <a href=\"https://www.vim.org/\">https://www.vim.org/</a> </span></p><p><span class=\"reference\">[12] Xavier Deguillard, clang_complete. <a href=\"https://github.com/xavierd/clang_complete\">https://github.com/xavierd/clang_complete</a> </span></p><p><span class=\"reference\">[13] “libc++” C++ Standard Library . <a href=\"https://libcxx.llvm.org/\">https://libcxx.llvm.org/</a> </span></p><p><span class=\"reference\">[14] cppreference.com, “C++ compiler support”. <a href=\"https://en.cppreference.com/w/cpp/compiler_support\">https://en.cppreference.com/w/cpp/compiler_support</a> </span></p><p><span class=\"reference\">[15] Homebrew. <a href=\"https://brew.sh/\">https://brew.sh/</a> </span></p><p><span class=\"reference\">[16] 吴咏炜, “MSVCRT.DLL console I/O bug”. <a href=\"https://yongweiwu.wordpress.com/2016/05/27/msvcrt-dll-console-io-bug/\">https://yongweiwu.wordpress.com/2016/05/27/msvcrt-dll-console-io-bug/</a> </span></p><p><span class=\"reference\">[17] ClangFormat. <a href=\"https://clang.llvm.org/docs/ClangFormat.html\">https://clang.llvm.org/docs/ClangFormat.html</a> </span></p><p><span class=\"reference\">[18] Clang-Tidy. <a href=\"https://clang.llvm.org/extra/clang-tidy/\">https://clang.llvm.org/extra/clang-tidy/</a> </span></p><p><span class=\"reference\">[19] Daniel Marjamäki, Cppcheck. <a href=\"https://github.com/danmar/cppcheck\">https://github.com/danmar/cppcheck</a> </span></p><p><span class=\"reference\">[20] Valgrind Home. <a href=\"https://valgrind.org/\">https://valgrind.org/</a> </span></p><p><span class=\"reference\">[21] 吴咏炜, nvwa. <a href=\"https://github.com/adah1972/nvwa/\">https://github.com/adah1972/nvwa/</a> </span></p><p><span class=\"reference\">[22] Matt Godbolt, “Compiler Explorer”. <a href=\"https://godbolt.org/\">https://godbolt.org/</a> </span></p><p><span class=\"reference\">[23] Matt Godbolt, compiler-explorer. <a href=\"https://github.com/mattgodbolt/compiler-explorer\">https://github.com/mattgodbolt/compiler-explorer</a> </span></p><p><span class=\"reference\">[24] Andreas Fertig, “C++ Insights”. <a href=\"https://cppinsights.io/\">https://cppinsights.io/</a> </span></p>","neighbors":{"left":{"article_title":"20 | 内存模型和atomic：理解并发的复杂性","id":186708},"right":{"article_title":"22 | 处理数据类型变化和错误：optional、variant、expected和Herbception","id":189022}}},{"article_id":189022,"article_title":"22 | 处理数据类型变化和错误：optional、variant、expected和Herbception","article_content":"<p>你好，我是吴咏炜。</p><p>我们之前已经讨论了异常是推荐的 C++ 错误处理方式。不过，C++ 里有另外一些结构也很适合进行错误处理，今天我们就来讨论一下。</p><h2>optional</h2><p>在面向对象（引用语义）的语言里，我们有时候会使用空值 null 表示没有找到需要的对象。也有人推荐使用一个特殊的空对象，来避免空值带来的一些问题 <span class=\"orange\">[1]</span>。可不管是空值，还是空对象，对于一个返回普通对象（值语义）的 C++ 函数都是不适用的——空值和空对象只能用在返回引用/指针的场合，一般情况下需要堆内存分配，在 C++ 里会引致额外的开销。</p><p>C++17 引入的 <code>optional</code> 模板 <span class=\"orange\">[2]</span> 可以（部分）解决这个问题。语义上来说，<code>optional</code> 代表一个“也许有效”“可选”的对象。语法上来说，一个 <code>optional</code> 对象有点像一个指针，但它所管理的对象是直接放在 <code>optional</code> 里的，没有额外的内存分配。</p><p>构造一个 <code>optional&lt;T&gt;</code> 对象有以下几种方法：</p><ol>\n<li>不传递任何参数，或者使用特殊参数 <code>std::nullopt</code>（可以和 <code>nullptr</code> 类比），可以构造一个“空”的 <code>optional</code> 对象，里面不包含有效值。</li>\n<li>第一个参数是 <code>std::in_place</code>，后面跟构造 <code>T</code> 所需的参数，可以在 <code>optional</code> 对象上直接构造出 <code>T</code> 的有效值。</li>\n<li>如果 <code>T</code> 类型支持拷贝构造或者移动构造的话，那在构造 <code>optional&lt;T&gt;</code> 时也可以传递一个 <code>T</code> 的左值或右值来将 <code>T</code> 对象拷贝或移动到 <code>optional</code> 中。</li>\n</ol><!-- [[[read_end]]] --><p>对于上面的第 1 种情况，<code>optional</code> 对象里是没有值的，在布尔值上下文里，会得到 <code>false</code>（类似于空指针的行为）。对于上面的第 2、3 两种情况，<code>optional</code> 对象里是有值的，在布尔值上下文里，会得到 <code>true</code>（类似于有效指针的行为）。类似的，在 <code>optional</code> 对象有值的情况下，你可以用 <code>*</code> 和 <code>-&gt;</code> 运算符去解引用（没值的情况下，结果是未定义行为）。</p><p>虽然 <code>optional</code> 是 C++17 才标准化的，但实际上这个用法更早就通行了。因为 <code>optional</code> 的实现不算复杂，有些库里就自己实现了一个版本。比如 cpptoml <span class=\"orange\">[3]</span> 就给出了下面这样的示例（进行了翻译和重排版），用法跟标准的 <code>optional</code> 完全吻合：</p><pre><code class=\"language-c++\">auto val = config-&gt;\n  get_as&lt;int64_t&gt;(\"my-int\");\n// val 是 cpptoml::option&lt;int64_t&gt;\n\nif (val) {\n  // *val 是 \"my-int\" 键下的整数值\n} else {\n  // \"my-int\" 不存在或不是整数\n}\n</code></pre><p>cpptoml 里只是个缩微版的 <code>optional</code>，实现只有几十行，也不支持我们上面说的所有构造方式。标准库的 <code>optional</code> 为了方便程序员使用，除了我目前描述的功能，还支持下面的操作：</p><ul>\n<li>安全的析构行为</li>\n<li>显式的 <code>has_value</code> 成员函数，判断 <code>optional</code> 是否有值</li>\n<li><code>value</code> 成员函数，行为类似于 <code>*</code>，但在 <code>optional</code> 对象无值时会抛出异常 <code>std::bad_optional_access</code></li>\n<li><code>value_or</code> 成员函数，在 <code>optional</code> 对象无值时返回传入的参数</li>\n<li><code>swap</code> 成员函数，和另外一个 <code>optional</code> 对象进行交换</li>\n<li><code>reset</code> 成员函数，清除 <code>optional</code> 对象包含的值</li>\n<li><code>emplace</code> 成员函数，在 <code>optional</code> 对象上构造一个新的值（不管成功与否，原值会被丢弃）</li>\n<li><code>make_optional</code> 全局函数，产生一个 <code>optional</code> 对象（类似 <code>make_pair</code>、<code>make_unique</code> 等）</li>\n<li>全局比较操作</li>\n<li>等等</li>\n</ul><p>如果我们认为无值就是数据无效，应当跳过剩下的处理，我们可以写出下面这样的高阶函数：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nconstexpr bool has_value(\n  const optional&lt;T&gt;&amp; x) noexcept\n{\n    return x.has_value();\n}\n\ntemplate &lt;typename T,\n          typename... Args&gt;\nconstexpr bool has_value(\n  const optional&lt;T&gt;&amp; first,\n  const optional&lt;\n    Args&gt;&amp;... other) noexcept\n{\n  return first.has_value() &amp;&amp;\n         has_value(other...);\n}\n\ntemplate &lt;typename F&gt;\nauto lift_optional(F&amp;&amp; f)\n{\n  return [f = forward&lt;F&gt;(f)](\n           auto&amp;&amp;... args) {\n    typedef decay_t&lt;decltype(f(\n      forward&lt;decltype(args)&gt;(args)\n        .value()...))&gt;\n      result_type;\n    if (has_value(args...)) {\n      return optional&lt;result_type&gt;(\n        f(forward&lt;decltype(args)&gt;(\n            args)\n            .value()...));\n    } else {\n      return optional&lt;\n        result_type&gt;();\n    }\n  };\n}\n</code></pre><p><code>has_value</code> 比较简单，它可以有一个或多个 <code>optional</code> 参数，并在所有参数都有值时返回真，否则返回假。<code>lift_optional</code> 稍复杂些，它接受一个函数，返回另外一个函数。在返回的函数里，参数是一个或多个 <code>optional</code> 类型，<code>result_type</code> 是用参数的值（<code>value()</code>）去调用原先函数时的返回值类型，最后返回的则是 <code>result_type</code> 的 <code>optional</code> 封装。函数内部会检查所有的参数是否都有值（通过调用 <code>has_value</code>）：有值时会去拿参数的值去调用原先的函数，否则返回一个空的 <code>optional</code> 对象。</p><p>这个函数能把一个原本要求参数全部有效的函数抬升（lift）成一个接受和返回 <code>optional</code> 参数的函数，并且，只在参数全部有效时去调用原来的函数。这是一种非常函数式的编程方式。使用上面函数的示例代码如下：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;optional&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\n// 需包含 lift_optional 的定义\n\nconstexpr int increase(int n)\n{\n    return n + 1;\n}\n\n// 标准库没有提供 optional 的输出\nostream&amp;\noperator&lt;&lt;(ostream&amp; os,\n           optional&lt;int&gt;(x))\n{\n  if (x) {\n    os &lt;&lt; '(' &lt;&lt; *x &lt;&lt; ')';\n  } else {\n    os &lt;&lt; \"(Nothing)\";\n  }\n  return os;\n}\n\nint main()\n{\n  auto inc_opt =\n    lift_optional(increase);\n  auto plus_opt =\n    lift_optional(plus&lt;int&gt;());\n  cout &lt;&lt; inc_opt(optional&lt;int&gt;())\n       &lt;&lt; endl;\n  cout &lt;&lt; inc_opt(make_optional(41))\n       &lt;&lt; endl;\n  cout &lt;&lt; plus_opt(\n            make_optional(41),\n            optional&lt;int&gt;())\n       &lt;&lt; endl;\n  cout &lt;&lt; plus_opt(\n            make_optional(41),\n            make_optional(1))\n       &lt;&lt; endl;\n}\n</code></pre><p>输出结果是：</p><blockquote>\n<p><code>(Nothing)</code><br>\n<code>(42)</code><br>\n<code>(Nothing)</code><br>\n<code>(42)</code></p>\n</blockquote><h2>variant</h2><p><code>optional</code> 是一个非常简单而又好用的模板，很多情况下，使用它就足够解决问题了。在某种意义上，可以把它看作是允许有两种数值的对象：要么是你想放进去的对象，要么是 <code>nullopt</code>（再次提醒，联想 <code>nullptr</code>）。如果我们希望除了我们想放进去的对象，还可以是 <code>nullopt</code> 之外的对象怎么办呢（比如，某种出错的状态）？又比如，如果我希望有三种或更多不同的类型呢？这种情况下，<code>variant</code> <span class=\"orange\">[4]</span> 可能就是一个合适的解决方案。</p><p>在没有 <code>variant</code> 类型之前，你要达到类似的目的，恐怕会使用一种叫做带标签的联合（tagged union）的数据结构。比如，下面就是一个可能的数据结构定义：</p><pre><code class=\"language-c++\">struct FloatIntChar {\n  enum {\n    Float,\n    Int,\n    Char\n  } type;\n  union {\n    float float_value;\n    int int_value;\n    char char_value;\n  };\n};\n</code></pre><p>这个数据结构的最大问题，就是它实际上有很多复杂情况需要特殊处理。对于我们上面例子里的 POD 类型，这么写就可以了（但我们仍需小心保证我们设置的 <code>type</code> 和实际使用的类型一致）。如果我们把其中一个类型换成非 POD 类型，就会有复杂问题出现。比如，下面的代码是不能工作的：</p><pre><code class=\"language-c++\">struct StringIntChar {\n  enum {\n    String,\n    Int,\n    Char\n  } type;\n  union {\n    string string_value;\n    int int_value;\n    char char_value;\n  };\n};\n</code></pre><p>编译器会很合理地看到在 union 里使用 <code>string</code> 类型会带来构造和析构上的问题，所以会拒绝工作。要让这个代码工作，我们得手工加上析构函数，并且，在析构函数里得小心地判断存储的是什么数值，来决定是否应该析构（否则，默认不调用任何 union 里的析构函数，从而可能导致资源泄漏）：</p><pre><code class=\"language-c++\">  ~StringIntChar()\n  {\n    if (type == String) {\n      string_value.~string();\n    }\n  }\n</code></pre><p>这样，我们才能安全地使用它（还是很麻烦）：</p><pre><code class=\"language-c++\">StringIntChar obj{\n  .type = StringIntChar::String,\n  .string_value = \"Hello world\"};\ncout &lt;&lt; obj.string_value &lt;&lt; endl;\n</code></pre><p>这里用到了按成员初始化的语法，把类型设置成了字符串，同时设置了字符串的值。不用说，这是件麻烦、容易出错的事情。同时，细查之后我发现，这个语法虽然在 C99 里有，但在 C++ 里要在 C++20 才会被标准化，因此实际是有兼容性问题的——老版本的 MSVC，或最新版本的 MSVC 在没有开启 C++20 支持时，就不支持这个语法。</p><p>所以，目前的主流建议是，应该避免使用“裸” union 了。替换方式，就是这一节要说的 <code>variant</code>。上面的例子，如果用 <code>variant</code> 的话，会非常的干净利落：</p><pre><code class=\"language-c++\">variant&lt;string, int, char&gt; obj{\n  \"Hello world\"};\ncout &lt;&lt; get&lt;string&gt;(obj) &lt;&lt; endl;\n</code></pre><p>可以注意到我上面构造时使用的是 <code>const char*</code>，但构造函数仍然能够正确地选择 <code>string</code> 类型，这是因为标准要求实现在没有一个完全匹配的类型的情况下，会选择成员类型中能够以传入的类型来构造的那个类型进行初始化（有且只有一个时）。<code>string</code> 类存在形式为 <code>string(const char*)</code> 的构造函数（不精确地说），所以上面的构造能够正确进行。</p><p>跟 <code>tuple</code> 相似，<code>variant</code> 上可以使用 <code>get</code> 函数模板，其模板参数可以是代表序号的数字，也可以是类型。如果编译时可以确定序号或类型不合法，我们在编译时就会出错。如果序号或类型合法，但运行时发现 <code>variant</code> 里存储的并不是该类对象，我们则会得到一个异常 <code>bad_variant_access</code>。</p><p><code>variant</code> 上还有一个重要的成员函数是 <code>index</code>，通过它我们能获得当前的数值的序号。就我们上面的例子而言，<code>obj.index()</code> 即为 <code>1</code>。正常情况下，<code>variant</code> 里总有一个有效的数值（缺省为第一个类型的默认构造结果），但如果 <code>emplace</code> 等修改操作中发生了异常，<code>variant</code> 里也可能没有任何有效数值，此时 <code>index()</code> 将会得到 <code>variant_npos</code>。</p><p>从基本概念来讲，<code>variant</code> 就是一个安全的 union，相当简单，我就不多做其他介绍了。你可以自己看文档来了解进一步的信息。其中比较有趣的一个非成员函数是 <code>visit</code> <span class=\"orange\">[5]</span>，文档里展示了一个非常简洁的、可根据当前包含的变量类型进行函数分发的方法。</p><p><strong>平台细节：</strong>在老于 Mojave 的 macOS 上编译含有 <code>optional</code> 或 <code>variant</code> 的代码，需要在文件开头加上：</p><pre><code class=\"language-c++\">#if defined(__clang__) &amp;&amp; defined(__APPLE__)\n#include &lt;__config&gt;\n#undef _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS\n#undef _LIBCPP_AVAILABILITY_BAD_VARIANT_ACCESS\n#define _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS\n#define _LIBCPP_AVAILABILITY_BAD_VARIANT_ACCESS\n#endif\n</code></pre><p>原因是苹果在头文件里把 <code>optional</code> 和 <code>variant</code> 在早期版本的 macOS 上禁掉了，而上面的代码去掉了这几个宏里对使用 <code>bad_optional_access</code> 和 <code>bad_variant_access</code> 的平台限制。我真看不出使用这两个头文件跟 macOS 的版本有啥关系。😞</p><h2>expected</h2><p>和前面介绍的两个模板不同，<code>expected</code> 不是 C++ 标准里的类型。但概念上这三者有相关性，因此我们也放在一起讲一下。</p><p>我前面已经提到，<code>optional</code> 可以作为一种代替异常的方式：在原本该抛异常的地方，我们可以改而返回一个空的 <code>optional</code> 对象。当然，此时我们就只知道没有返回一个合法的对象，而不知道为什么没有返回合法对象了。我们可以考虑改用一个 <code>variant</code>，但我们此时需要给错误类型一个独特的类型才行，因为这是 <code>variant</code> 模板的要求。比如：</p><pre><code class=\"language-c++\">enum class error_code {\n  success,\n  operation_failure,\n  object_not_found,\n  …\n};\n\nvariant&lt;Obj, error_code&gt;\n  get_object(…);\n</code></pre><p>这当然是一种可行的错误处理方式：我们可以判断返回值的 <code>index()</code>，来决定是否发生了错误。但这种方式不那么直截了当，也要求实现对允许的错误类型作出规定。Andrei Alexandrescu 在 2012 年首先提出的 Expected 模板 <span class=\"orange\">[6]</span>，提供了另外一种错误处理方式。他的方法的要点在于，把完整的异常信息放在返回值，并在必要的时候，可以“重放”出来，或者手工检查是不是某种类型的异常。</p><p>他的概念并没有被广泛推广，最主要的原因可能是性能。异常最被人诟病的地方是性能，而他的方式对性能完全没有帮助。不过，后面的类似模板都汲取了他的部分思想，至少会用一种显式的方式来明确说明当前是异常情况还是正常情况。在目前的 expected 的标准提案 <span class=\"orange\">[7]</span> 里，用法有点是 <code>optional</code> 和 <code>variant</code> 的某种混合：模板的声明形式像 <code>variant</code>，使用正常返回值像 <code>optional</code>。</p><p>下面的代码展示了一个 expected 实现 <span class=\"orange\">[8]</span> 的基本用法。</p><pre><code class=\"language-c++\">#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;tl/expected.hpp&gt;\n\nusing namespace std;\nusing tl::expected;\nusing tl::unexpected;\n\n// 返回 expected 的安全除法\nexpected&lt;int, string&gt;\nsafe_divide(int i, int j)\n{\n  if (j == 0)\n    return unexpected(\n      \"divide by zero\"s);\n  if (i == INT_MIN &amp;&amp; j == -1)\n    return unexpected(\n      \"integer divide overflows\"s);\n  if (i % j != 0)\n    return unexpected(\n      \"not integer division\"s);\n  else\n    return i / j;\n}\n\n// 一个测试函数\nexpected&lt;int, string&gt;\ncaller(int i, int j, int k)\n{\n  auto q = safe_divide(j, k);\n  if (q)\n    return i + *q;\n  else\n    return q;\n}\n\n// 支持 expected 的输出函数\ntemplate &lt;typename T, typename E&gt;\nostream&amp; operator&lt;&lt;(\n  ostream&amp; os,\n  const expected&lt;T, E&gt;&amp; exp)\n{\n  if (exp) {\n    os &lt;&lt; exp.value();\n  } else {\n    os &lt;&lt; \"unexpected: \"\n       &lt;&lt; exp.error();\n  }\n  return os;\n}\n\n// 调试使用的检查宏\n#define CHECK(expr)               \\\n  {                               \\\n    auto result = (expr);         \\\n    cout &lt;&lt; result;               \\\n    if (result ==                 \\\n        unexpected(               \\\n          \"divide by zero\"s)) {   \\\n      cout                        \\\n        &lt;&lt; \": Are you serious?\";  \\\n    } else if (result == 42) {    \\\n      cout &lt;&lt; \": Ha, I got you!\"; \\\n    }                             \\\n    cout &lt;&lt; endl;                 \\\n  }\n\nint main()\n{\n  CHECK(caller(2, 1, 0));\n  CHECK(caller(37, 20, 7));\n  CHECK(caller(39, 21, 7));\n}\n</code></pre><p>输出是：</p><blockquote>\n<p><code>unexpected: divide by zero: Are you serious?</code><br>\n<code>unexpected: not integer division</code><br>\n<code>42: Ha, I got you!</code></p>\n</blockquote><p>一个 <code>expected&lt;T, E&gt;</code> 差不多可以看作是 <code>T</code> 和 <code>unexpected&lt;E&gt;</code> 的 <code>variant</code>。在学过上面的 <code>variant</code> 之后，我们应该很容易看明白上面的程序了。下面是几个需要注意一下的地方：</p><ul>\n<li>如果一个函数要正常返回数据，代码无需任何特殊写法；如果它要表示出现了异常，则可以返回一个 <code>unexpected</code> 对象。</li>\n<li>这个返回值可以用来和一个正常值或 unexpected 对象比较，可以在布尔值上下文里检查是否有正常值，也可以用 <code>*</code> 运算符来取得其中的正常值——与 <code>optional</code> 类似，在没有正常值的情况下使用 <code>*</code> 是未定义行为。</li>\n<li>可以用 <code>value</code> 成员函数来取得其中的正常值，或使用 <code>error</code> 成员函数来取得其中的错误值——与 <code>variant</code> 类似，在 <code>expected</code> 中没有对应的值时产生异常 <code>bad_expected_access</code>。</li>\n<li>返回错误跟抛出异常比较相似，但检查是否发生错误的代码还是要比异常处理啰嗦。</li>\n</ul><h2>Herbception</h2><p>上面的用法初看还行，但真正用起来，你会发现仍然没有使用异常方便。这只是为了解决异常在错误处理性能问题上的无奈之举。大部分试图替换 C++ 异常的方法都是牺牲编程方便性，来换取性能。只有 Herb Sutter 提出了一个基本兼容当前 C++ 异常处理方式的错误处理方式 <span class=\"orange\">[9]</span>，被戏称为 Herbception。</p><p>上面使用 expected 的示例代码，如果改用 Herbception 的话，可以大致如下改造（示意，尚无法编译）：</p><pre><code class=\"language-c++\">int safe_divide(int i, int j) throws\n{\n  if (j == 0)\n    throw arithmetic_errc::\n      divide_by_zero;\n  if (i == INT_MIN &amp;&amp; j == -1)\n    throw arithmetic_errc::\n      integer_divide_overflows;\n  if (i % j != 0)\n    throw arithmetic_errc::\n      not_integer_division;\n  else\n    return i / j;\n}\n\nint caller(int i, int j,\n           int k) throws\n{\n  return i + safe_divide(j, k);\n}\n\n#define CHECK(expr)               \\\n  try {                           \\\n    int result = (expr);          \\\n    cout &lt;&lt; result;               \\\n    if (result == 42) {           \\\n      cout &lt;&lt; \": Ha, I got you!\"; \\\n    }                             \\\n  }                               \\\n  catch (error e) {               \\\n    if (e == arithmetic_errc::    \\\n               divide_by_zero) {  \\\n      cout                        \\\n        &lt;&lt; \"Are you serious? \";   \\\n    }                             \\\n    cout &lt;&lt; \"An error occurred\";  \\\n  }                               \\\n  cout &lt;&lt; endl\n\nint main()\n{\n  CHECK(caller(2, 1, 0));\n  CHECK(caller(37, 20, 7));\n  CHECK(caller(39, 21, 7));\n}\n</code></pre><p>我们可以看到，上面的代码和普通使用异常的代码非常相似，区别有以下几点：</p><ul>\n<li>函数需要使用 <code>throws</code>（注意不是 <code>throw</code>）进行声明。</li>\n<li>抛出异常的语法和一般异常语法相同，但抛出的是一个 <code>std::error</code> 值 <span class=\"orange\">[10]</span>。</li>\n<li>捕捉异常时不需要使用引用（因为 <code>std::error</code> 是个“小”对象），且使用一般的比较操作来检查异常“类型”，不再使用开销大的 RTTI。</li>\n</ul><p>虽然语法上基本是使用异常的样子，但 Herb 的方案却没有异常的不确定开销，性能和使用 expected 相仿。他牺牲了异常类型的丰富，但从实际编程经验来看，越是体现出异常优越性的地方——异常处理点和异常发生点距离较远的时候——越不需要异常有丰富的类型。因此，总体上看，这是一个非常吸引人的方案。不过，由于提案时间较晚，争议颇多，这个方案要进入标准至少要 C++23 了。我们目前稍稍了解一下就行。</p><p>更多技术细节，请查看参考资料。</p><h2>内容小结</h2><p>本讲我们讨论了两个 C++ 标准库的模板 <code>optional</code> 和 <code>variant</code>，然后讨论了两个标准提案 expected 和 Herbception。这些结构都可以使用在错误处理过程中——前三者当前可用，但和异常相比有不同的取舍；Herbception 当前还不可用，但有希望在错误处理上达到最佳的权衡点。</p><h2>课后思考</h2><p>错误处理是一个非常复杂的问题，在 C++ 诞生之后这么多年仍然没有该如何处理的定论。如何对易用性和性能进行取舍，一直是一个有矛盾的老大难问题。你的实际项目中是如何选择的？你觉得应该如何选择？</p><p>欢迎留言和我分享你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Null object pattern”. <a href=\"https://en.wikipedia.org/wiki/Null_object_pattern\">https://en.wikipedia.org/wiki/Null_object_pattern</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “std::optional”. <a href=\"https://en.cppreference.com/w/cpp/utility/optional\">https://en.cppreference.com/w/cpp/utility/optional</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “std::optional”. <a href=\"https://zh.cppreference.com/w/cpp/utility/optional\">https://zh.cppreference.com/w/cpp/utility/optional</a> </span></p><p><span class=\"reference\">[3] Chase Geigle, cpptoml. <a href=\"https://github.com/skystrife/cpptoml\">https://github.com/skystrife/cpptoml</a> </span></p><p><span class=\"reference\">[4] cppreference.com, “std::optional”. <a href=\"https://en.cppreference.com/w/cpp/utility/variant\">https://en.cppreference.com/w/cpp/utility/variant</a> </span></p><p><span class=\"reference\">[4a] cppreference.com, “std::optional”. <a href=\"https://zh.cppreference.com/w/cpp/utility/variant\">https://zh.cppreference.com/w/cpp/utility/variant</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “std::visit”. <a href=\"https://en.cppreference.com/w/cpp/utility/variant/visit\">https://en.cppreference.com/w/cpp/utility/variant/visit</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “std::visit”. <a href=\"https://zh.cppreference.com/w/cpp/utility/variant/visit\">https://zh.cppreference.com/w/cpp/utility/variant/visit</a> </span></p><p><span class=\"reference\">[6] Andrei Alexandrescu, “Systematic error handling in C++”. <a href=\"https://channel9.msdn.com/Shows/Going+Deep/C-and-Beyond-2012-Andrei-Alexandrescu-Systematic-Error-Handling-in-C\">https://channel9.msdn.com/Shows/Going+Deep/C-and-Beyond-2012-Andrei-Alexandrescu-Systematic-Error-Handling-in-C</a> </span></p><p><span class=\"reference\">[7] Vicente J. Botet Escribá and JF Bastien, “Utility class to represent expected object”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf</a> </span></p><p><span class=\"reference\">[8] Simon Brand, expected. <a href=\"https://github.com/TartanLlama/expected\">https://github.com/TartanLlama/expected</a> </span></p><p><span class=\"reference\">[9] Herb Sutter, “P0709R0: Zero-overhead deterministic exceptions: Throwing values”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf</a> </span></p><p><span class=\"reference\">[10] Niall Douglas, “P1028R0: SG14 <code>status_code</code> and standard <code>error object</code> for P0709 Zero-overhead deterministic exceptions”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1028r0.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1028r0.pdf</a> </span></p>","neighbors":{"left":{"article_title":"21 | 工具漫谈：编译、格式化、代码检查、排错各显身手","id":187980},"right":{"article_title":"23 | 数字计算：介绍线性代数和数值计算库","id":189042}}},{"article_id":189042,"article_title":"23 | 数字计算：介绍线性代数和数值计算库","article_content":"<p>你好，我是吴咏炜。</p><p>科学计算在今天已经完全可以使用 C++ 了。我不是从事科学计算这一领域的工作的，不过，在工作中也多多少少接触到了一些计算相关的库。今天，我就给你介绍几个有用的计算库。</p><h2>Armadillo</h2><p>说到计算，你可能首先会想到矩阵、矢量这些东西吧？这些计算，确实就是科学计算中的常见内容了。这些领域的标准，即是一些 Fortran 库定下的，如：</p><ul>\n<li>BLAS <span class=\"orange\">[1]</span></li>\n<li>LAPACK <span class=\"orange\">[2]</span></li>\n<li>ARPACK <span class=\"orange\">[3]</span></li>\n</ul><p>它们的实现倒不一定用 Fortran，尤其是 BLAS：</p><ul>\n<li>OpenBLAS <span class=\"orange\">[4]</span> 是用汇编和 C 语言写的</li>\n<li>Intel MKL <span class=\"orange\">[5]</span> 有针对 Intel 的特定 CPU 指令集进行优化的汇编代码</li>\n<li>Mir GLAS <span class=\"orange\">[6]</span> 是用 D 语言写的</li>\n</ul><p>不管实现的方法是哪一种，暴露出来的函数名字是这个样子的：</p><ul>\n<li><code>ddot</code></li>\n<li><code>dgemv</code></li>\n<li><code>dsyrk</code></li>\n<li><code>sgemm</code></li>\n<li>……</li>\n</ul><p>这个接口的唯一好处，应该就是，它是跨语言并且跨实现的😅。所以，使用这些函数时，你可以切换不同的实现，而不需要更改代码。唯一需要修改的，通常就是链接库的名字或位置而已。</p><p>假设我们需要做一个简单的矩阵运算，对一个矢量进行旋转：</p><p>$$<br>\n\\begin{aligned}<br>\n\\mathbf{P} &amp;= \\begin{bmatrix} 1 \\\\\\ 0 \\end{bmatrix}\\\\\\<br>\n\\mathbf{R} &amp;= \\begin{bmatrix}<br>\n\\cos(\\theta) &amp; -\\sin(\\theta) \\\\\\<br>\n\\sin(\\theta) &amp; \\cos(\\theta)\\end{bmatrix}\\\\\\<br>\n\\mathbf{P^\\prime} &amp;= \\mathbf{R} \\cdot \\mathbf{P}<br>\n\\end{aligned}<br>\n$$</p><!-- [[[read_end]]] --><p>这么一个简单的操作，用纯 C 接口的 BLAS 来表达，有点痛苦：你需要使用的大概是 <code>dgemv_</code> 函数，而这个函数需要 11 个参数！我查阅了一下资料之后，也就放弃了给你展示一下如何调用 <code>dgemv_</code> 的企图，我们还是老老实实地看一下在现代 C++ 里的写法吧：</p><pre><code class=\"language-c++\">#include &lt;armadillo&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n  // 代表位置的向量\n  arma::vec pos{1.0, 0.0};\n\n  // 旋转矩阵\n  auto&amp; pi = arma::datum::pi;\n  double angle = pi / 2;\n  arma::mat rot = {\n    {cos(angle), -sin(angle)},\n    {sin(angle), cos(angle)}};\n\n  cout &lt;&lt; \"Current position:\\n\"\n       &lt;&lt; pos;\n  cout &lt;&lt; \"Rotating \"\n       &lt;&lt; angle * 180 / pi\n       &lt;&lt; \" deg\\n\";\n\n  arma::vec new_pos = rot * pos;\n  cout &lt;&lt; \"New position:\\n\"\n       &lt;&lt; new_pos;\n}\n</code></pre><p>这就是使用 Armadillo <span class=\"orange\">[7]</span> 库来实现矢量旋转的代码。这个代码，基本就是上面的数学公式的一一对应了。代码相当直白，我只需要稍稍说明一下：</p><ul>\n<li>所有的 Armadillo 的类型和函数都定义在 <code>arma</code> 名空间下。</li>\n<li>Armadillo 在 <code>arma::datum</code> 下定义了包括 pi 和 e 在内的一些数学常量。</li>\n<li><code>vec</code> 是矢量类型，<code>mat</code> 是矩阵类型，这两个类型实际上是 <code>Col&lt;double&gt;</code> 和 <code>Mat&lt;double&gt;</code> 的缩写别名。</li>\n<li>Armadillo 支持使用 C++11 的列表初始化语法来初始化对象。</li>\n<li>Armadillo 支持使用流来输出对象。</li>\n</ul><p>上面代码的输出为：</p><blockquote>\n<p><code>Current position:</code><br>\n<code>1.0000</code><br>\n<code>0</code><br>\n<code>Rotating 90 deg</code><br>\n<code>New position:</code><br>\n<code>6.1232e-17</code><br>\n<code>1.0000e+00</code></p>\n</blockquote><p>输出里面的 <code>6.1232e-17</code> 是浮点数表示不精确的后果，把它理解成 0 就对了。</p><p>我们上面已经提到了 <code>vec</code> 实际上是 <code>Col&lt;double&gt;</code>，双精度浮点数类型的列矢量。自然，Armadillo 也有行矢量 <code>rowvec</code>（即 <code>Row&lt;double&gt;</code>），也可以使用其他的数字类型，如 <code>int</code>、 <code>float</code> 和 <code>complex&lt;float&gt;</code>。此外，除了大小不确定的线性代数对象之外，Armadillo 也提供了固定大小的子类型，如 <code>vec::fixed&lt;2&gt;</code> 和 <code>mat::fixed&lt;2, 2&gt;</code>；为方便使用，还提供了不少别名，如 <code>imat22</code> 代表 <code>Mat&lt;int&gt;::fixed&lt;2, 2&gt;</code> 等。固定大小的对象不需要动态内存分配，使用上有一定的性能优势。</p><p>Armadillo 是一个非常复杂的库，它的头文件数量超过了 500 个。我们今天不可能、也不必要描述它的所有功能，只能稍稍部分列举一下：</p><ul>\n<li>除了目前提到的列矢量、行矢量和矩阵外，Armadillo 也支持三维的数据立方体，<code>Cube</code> 模板。</li>\n<li>Armadillo 支持稀疏矩阵，<code>SpMat</code> 模板。</li>\n<li>除了数学上的加、减、乘运算，Armadillo 支持按元素的乘法、除法、相等、不等、小于比较等（使用 <code>%</code>、<code>/</code>、<code>==</code>、<code>!=</code>、<code>&lt;</code> 等）运算，结果的大小跟参数相同，每个元素是相应运算的结果。某些运算符可能不太直观，尤其是 <code>%</code>（不是取模）和 <code>==</code>（返回不是单个布尔值，而是矩阵）。</li>\n<li>Armadillo 支持对非固定大小的矢量、矩阵和立方体，改变其大小（<code>.reshape()</code> 和 <code>resize()</code>）。</li>\n<li>Armadillo 可以方便地按行（<code>.col()</code>）、列（<code>.row()</code>）、对角线（<code>.diag()</code>）读写矩阵的内容，包括用一个矢量去改写矩阵的对角线。</li>\n<li>Armadillo 可以方便地对矩阵进行转置（<code>.t()</code>）、求反（<code>.inv()</code>）。</li>\n<li>Armadillo 可以对矩阵进行特征分解（<code>eigen_sym()</code>、<code>eigen_gen()</code> 等）。</li>\n<li>Armadillo 支持傅立叶变换（<code>fft()</code>、<code>fft2()</code> 等）。</li>\n<li>Armadillo 支持常见的统计计算，如平均值、中位值、标准偏差等（<code>mean()</code>、<code>median()</code>、<code>stddev()</code> 等）。</li>\n<li>Armadillo 支持多项式方程求根（<code>roots</code>）。</li>\n<li>Armadillo 支持 k‐平均聚类（<em>k</em>-means clustering）算法（<code>kmeans</code>）。</li>\n<li>等等。</li>\n</ul><p>如果你需要用到这些功能，你可以自己去查看一下具体的细节，我们这儿只提几个与编程有关的细节。</p><h3>对象的输出</h3><p>我们上面已经展示了直接把对象输出到一个流。我们的写法是：</p><pre><code class=\"language-c++\">cout &lt;&lt; \"Current position:\\n\"\n     &lt;&lt; pos;\n</code></pre><p>实际上基本等价于调用 <code>print</code> 成员函数：</p><pre><code class=\"language-c++\">pos.print(\"Current position:\");\n</code></pre><p>这个写法可能会更简单些。此外，在这两种情况，输出的格式都是 Armadillo 自动控制的。如果你希望自己控制的话，可以使用 <code>raw_print</code> 成员函数。比如，对于上面代码里对 <code>new_pos</code> 的输出，我们可以写成（需要包含 &lt;iomanip&gt;）：</p><pre><code class=\"language-c++\">cout &lt;&lt; fixed &lt;&lt; setw(9)\n     &lt;&lt; setprecision(4);\nnew_pos.raw_print(\n  cout, \"New position:\");\n</code></pre><p>这种情况下，你可以有效地对格式、宽度和精度进行设置，能得到：</p><blockquote>\n<p><code>New position:</code><br>\n<code>0.0000</code><br>\n<code>1.0000</code></p>\n</blockquote><p>记得我们说过 <code>vec</code> 是 <code>Col&lt;double&gt;</code> 的别名，因此输出是多行的。我们要输出成单行的话，转置（transpose）一下就可以了：</p><pre><code class=\"language-c++\">cout &lt;&lt; fixed &lt;&lt; setw(9)\n     &lt;&lt; setprecision(4);\nnew_pos.t().raw_print(\n  cout, \"New position:\");\n</code></pre><p>输出为：</p><blockquote>\n<p><code>New position:</code><br>\n<code>0.0000 1.0000</code></p>\n</blockquote><h3>表达式模板</h3><p>如果你奇怪前面 <code>dgemv_</code> 为什么有 11 个参数，这里有个我没有提的细节是，它执行的实际上是个复合操作：</p><p>$$<br>\n\\mathbf{y} \\gets \\alpha\\mathbf{A}\\cdot\\mathbf{x} + \\beta\\mathbf{y}<br>\n$$</p><p>如果你只是简单地做乘法的话，就相当于 $\\alpha$ 为 1、$\\beta$ 为 0 的特殊情况。那么问题来了，如果你真的写了类似于上面这样的公式的话，编译器和线性代数库能不能转成合适的调用、而没有额外的开销呢？</p><p>答案是，至少在某些情况下是可以的。秘诀就是表达式模板（expression template）<span class=\"orange\">[8]</span>。</p><p>那什么是表达式模板呢？我们先回过去看我上面的例子。有没有注意到我写的是：</p><pre><code class=\"language-c++\">arma::vec new_pos = rot * pos;\n</code></pre><p>而没有使用 <code>auto</code> 来声明？</p><p>其中部分的原因是，<code>rot * pos</code> 的类型并不是 <code>vec</code>，而是：</p><pre><code class=\"language-c++\">const Glue&lt;Mat&lt;double&gt;, Col&lt;double&gt;, glue_times&gt;\n</code></pre><p>换句话说，结果是一个表达式，而并没有实际进行计算。如果我用 <code>auto</code> 的话，行为上似乎一切都正常，但我每次输出这个结果时，都会重新进行一次矩阵的乘法！而我用 <code>arma::vec</code> 接收的话，构造时就直接进行了计算，存储了表达式的结果。</p><p>上面的简单例子不能实际触发对 <code>dgemv_</code> 的调用，我用下面的代码实际验证出了表达式模板产生的优化（<code>fill::randu</code> 表示对矢量和矩阵的内容进行随机填充）：</p><pre><code class=\"language-c++\">#include &lt;armadillo&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nusing namespace arma;\n\nint main()\n{\n  vec x(8, fill::randu);\n  mat r(8, 8, fill::randu);\n  vec result = 2.5 * r * x;\n  cout &lt;&lt; result;\n}\n</code></pre><p>赋值语句右边的类型是：</p><pre><code class=\"language-c++\">const Glue&lt;eOp&lt;Mat&lt;double&gt;,\n               eop_scalar_times&gt;,\n           Col&lt;double&gt;, glue_times&gt;\n</code></pre><p>当使用这个表达式构造 <code>vec</code> 时，就会实际发生对 <code>dgemv_</code> 的调用。我也确实跟踪到了，在将要调用 <code>dgemv_</code> 时，标量值 2.5 确实在参数 <code>alpha</code> 指向的位置上（这个接口的参数都是指针）。</p><p>从上面的描述可以看到，表达式模板是把双刃剑：既可以提高代码的性能，又能增加代码被误用的可能性。在可能用到表达式模板的地方，你需要注意这些问题。</p><h3>平台细节</h3><p>Armadillo 的文档里说明了如何从源代码进行安装，但在 Linux 和 macOS 下通过包管理器安装可能是更快的方式。在 CentOS 下可使用 <code>sudo yum install armadillo-devel</code>，在 macOS 下可使用 <code>brew install armadillo</code>。使用包管理器一般也会同时安装常见的依赖软件，如 ARPACK 和 OpenBLAS。</p><p>在 Windows 上，Armadillo 的安装包里自带了一个基本版本的 64 位 BLAS 和 LAPACK 库。如果需要更高性能或 32 位版本的话，就需要自己另外去安装了。除非你只是做一些非常简单的线性代数计算（就像我今天的例子），那直接告诉 Armadillo 不要使用第三方库也行。</p><blockquote>\n<p><code>cl /EHsc /DARMA_DONT_USE_BLAS /DARMA_DONT_USE_LAPACK …</code></p>\n</blockquote><h2>Boost.Multiprecision</h2><p>众所周知，C 和 C++（甚至推而广之到大部分的常用编程语言）里的数值类型是有精度限制的。比如，上一讲的代码里我们就用到了 <code>INT_MIN</code>，最小的整数。很多情况下，使用目前这些类型是够用的（最高一般是 64 位整数和 80 位浮点数）。但也有很多情况，这些标准的类型远远不能满足需要。这时你就需要一个高精度的数值类型了。</p><p>有一次我需要找一个高精度整数类型和计算库，最后找到的就是 Boost.Multiprecision <span class=\"orange\">[9]</span>。它基本满足我的需求，以及一般意义上对库的期望：</p><ul>\n<li>正确实现我需要的功能</li>\n<li>接口符合直觉、易用</li>\n<li>有良好的性能</li>\n</ul><p>正确实现功能这点我就不多讲了。这是一个基本出发点，没有太多可讨论的地方。在我上次的需求里，对性能其实也没有很高的要求。让我对 Boost.Multiprecision 满意的主要原因，就是它的接口了。</p><h3>接口易用性</h3><p>我在<a href=\"https://time.geekbang.org/column/article/179363\">[第 12 讲]</a> 提到了 CLN。它对我来讲就是个反面教材。它的整数类型不仅不提供 <code>%</code> 运算符，居然还不提供 <code>/</code> 运算符！它强迫用户在下面两个方案中做出选择：</p><ul>\n<li>使用 <code>truncate2</code> 函数，得到一个商数和余数</li>\n<li>使用 <code>exquo</code> 函数，当且仅当可以整除的时候</li>\n</ul><p>不管作者的设计原则是什么，这简直就是易用性方面的灾难了——不仅这些函数要查文档才能知晓，而且有的地方我真的只需要简单的除法呀……</p><p>哦，对了，它在 Windows 编译还很不方便，而我那时用的正是 Windows。</p><p>Boost.Multiprecision 的情况则恰恰相反，让我当即大为满意：</p><ul>\n<li>使用基本的 <code>cpp_int</code> 对象不需要预先编译库，只需要 Boost 的头文件和一个好的编译器。</li>\n<li>常用运算符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 一个不缺，全部都有。</li>\n<li>可以自然地通过整数和字符串来进行构造。</li>\n<li>提供了用户自定义字面量来高效地进行初始化。</li>\n<li>在使用 IO 流时，输入输出既可以使用十进制，也可以通过 <code>hex</code> 来切换到十六进制。</li>\n</ul><p>下面的代码展示了它的基本功能：</p><pre><code class=\"language-c++\">#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;boost/multiprecision/cpp_int.hpp&gt;\n\nusing namespace std;\n\nint main()\n{\n  using namespace boost::\n    multiprecision::literals;\n  using boost::multiprecision::\n    cpp_int;\n\n  cpp_int a =\n    0x123456789abcdef0_cppi;\n  cpp_int b = 16;\n  cpp_int c{\"0400\"};\n  cpp_int result = a * b / c;\n  cout &lt;&lt; hex &lt;&lt; result &lt;&lt; endl;\n  cout &lt;&lt; dec &lt;&lt; result &lt;&lt; endl;\n}\n</code></pre><p>输出是：</p><blockquote>\n<p><code>123456789abcdef</code><br>\n<code>81985529216486895</code></p>\n</blockquote><p>我们可以看到，<code>cpp_int</code> 可以通过自定义字面量（后缀 <code>_cppi</code>；只能十六进制）来初始化，可以通过一个普通整数来初始化，也可以通过字符串来初始化（并可以使用 <code>0x</code> 和 <code>0</code> 前缀来选择十六进制和八进制）。拿它可以正常地进行加减乘除操作，也可以通过 IO 流来输入输出。</p><h3>性能</h3><p>Boost.Multiprecision 使用了表达式模板和 C++11 的移动来避免不必要的拷贝。后者当然是件好事，而前者曾经坑了我一下——我第一次使用 Boost.Multiprecision 时非常困惑为什么我使用 <code>half(n - 1)</code> 调用下面的简单函数居然会编译不过：</p><pre><code class=\"language-c++\">template &lt;typename N&gt;\ninline N half(N n)\n{\n  return n / 2;\n}\n</code></pre><p>我的意图当然是 <code>N</code> 应当被推导为 <code>cpp_int</code>，<code>half</code> 的结果也是 <code>cpp_int</code>。可实际上，<code>n - 1</code> 的结果跟上面的 Armadillo 展示的情况类似，是另外一个单独的类型。我需要把 <code>half(n - 1)</code> 改写成 <code>half(N(n - 1))</code> 才能得到期望的结果。</p><p>我做的计算挺简单，并不觉得表达式模板对我的计算有啥帮助，所以我最后是禁用了表达式模板：</p><pre><code class=\"language-c++\">typedef boost::multiprecision::\n  number&lt;\n    boost::multiprecision::\n      cpp_int_backend&lt;&gt;,\n    boost::multiprecision::et_off&gt;\n    int_type;\n</code></pre><p>类似于 Armadillo 可以换不同的 BLAS 和 LAPACK 实现，Boost.Multiprecision 也可以改换不同的后端。比如，如果我们打算使用 GMP <span class=\"orange\">[10]</span> 的话，我们需要包含利用 GMP 的头文件，并把上面的 <code>int_type</code> 的定义修正一下：</p><pre><code class=\"language-c++\">#include &lt;boost/multiprecision/gmp.hpp&gt;\n\ntypedef boost::multiprecision::\n  number&lt;\n    boost::multiprecision::gmp_int,\n    boost::multiprecision::et_off&gt;\n    int_type;\n</code></pre><p>注意，我并不是推荐你换用 GMP。如果你真的对性能非常渴求的话，应当进行测试来选择合适的后端。否则缺省的后端易用性最好——比如，使用 GMP 后端就不能使用自定义字面量了。</p><p>我当时寻找高精度算术库是为了做 RSA 加解密。计算本身不复杂，属于编程几小时、运行几毫秒的情况。如果你有兴趣的话，可以看一下我那时的挑选过程和最终代码 <span class=\"orange\">[11]</span>。</p><p>Boost 里好东西很多，远远不止这一样。下一讲我们就来专门聊聊 Boost。</p><h2>内容小结</h2><p>本讲我们讨论了两个进行计算的模板库，Armadillo 和 Boost.Multiprecision，并讨论了它们用到的表达式模板技巧和相关的计算库，如 BLAS、LAPACK 和 GMP。可以看到，使用 C++ 你可以站到巨人肩上，轻松写出高性能的计算代码。</p><h2>课后思考</h2><p>性能和易用性往往是有矛盾的。你对性能和易用性有什么样的偏好呢？欢迎留言与我分享。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Basic Linear Algebra Subprograms”. <a href=\"https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms\">https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “LAPACK”. <a href=\"https://en.wikipedia.org/wiki/LAPACK\">https://en.wikipedia.org/wiki/LAPACK</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “ARPACK”. <a href=\"https://en.wikipedia.org/wiki/ARPACK\">https://en.wikipedia.org/wiki/ARPACK</a> </span></p><p><span class=\"reference\">[4] Zhang Xianyi et al., OpenBLAS. <a href=\"https://github.com/xianyi/OpenBLAS\">https://github.com/xianyi/OpenBLAS</a> </span></p><p><span class=\"reference\">[5] Intel, Math Kernel Library. <a href=\"https://software.intel.com/mkl\">https://software.intel.com/mkl</a> </span></p><p><span class=\"reference\">[6] Ilya Yaroshenko, mir-glas. <a href=\"https://github.com/libmir/mir-glas\">https://github.com/libmir/mir-glas</a> </span></p><p><span class=\"reference\">[7] Conrad Sanderson and Ryan Curtin, “Armadillo: C++ library for linear algebra &amp; scientific computing”. <a href=\"http://arma.sourceforge.net/\">http://arma.sourceforge.net/</a> </span></p><p><span class=\"reference\">[8] Wikipedia, “Expression templates”. <a href=\"https://en.wikipedia.org/wiki/Expression_templates\">https://en.wikipedia.org/wiki/Expression_templates</a> </span></p><p><span class=\"reference\">[9] John Maddock, Boost.Multiprecision. <a href=\"https://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/index.html\">https://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/index.html</a> </span></p><p><span class=\"reference\">[10] The GNU MP bignum library. <a href=\"https://gmplib.org/\">https://gmplib.org/</a> </span></p><p><span class=\"reference\">[11] 吴咏炜, “Choosing a multi-precision library for C++—a critique”. <a href=\"https://yongweiwu.wordpress.com/2016/06/04/choosing-a-multi-precision-library-for-c-a-critique/\">https://yongweiwu.wordpress.com/2016/06/04/choosing-a-multi-precision-library-for-c-a-critique/</a> </span></p>","neighbors":{"left":{"article_title":"22 | 处理数据类型变化和错误：optional、variant、expected和Herbception","id":189022},"right":{"article_title":"24 | Boost：你需要的“瑞士军刀”","id":191136}}},{"article_id":191136,"article_title":"24 | Boost：你需要的“瑞士军刀”","article_content":"<p>你好，我是吴咏炜。</p><p>我们已经零零碎碎提到过几次 Boost 了。作为 C++ 世界里标准库之外最知名的开放源码程序库，我们值得专门用一讲来讨论一下 Boost。</p><h2>Boost 概览</h2><p>Boost 的网站把 Boost 描述成为经过同行评审的、可移植的 C++ 源码库（peer-reviewed portable C++ source libraries）<span class=\"orange\">[1]</span>。换句话说，它跟很多个人开源库不一样的地方在于，它的代码是经过评审的。事实上，Boost 项目的背后有很多 C++ 专家，比如发起人之一的 Dave Abarahams 是 C++ 标准委员会的成员，也是《C++ 模板元编程》一书 <span class=\"orange\">[2]</span> 的作者。这也就使得 Boost 有了很不一样的特殊地位：它既是 C++ 标准库的灵感来源之一，也是 C++ 标准库的试验田。下面这些 C++ 标准库就源自 Boost：</p><ul>\n<li>智能指针</li>\n<li>thread</li>\n<li>regex</li>\n<li>random</li>\n<li>array</li>\n<li>bind</li>\n<li>tuple</li>\n<li>optional</li>\n<li>variant</li>\n<li>any</li>\n<li>string_view</li>\n<li>filesystem</li>\n<li>等等</li>\n</ul><p>当然，将来还会有新的库从 Boost 进入 C++ 标准，如网络库的标准化就是基于 Boost.Asio 进行的。因此，即使相关的功能没有被标准化，我们也可能可以从 Boost 里看到某个功能可能会被标准化的样子——当然，最终标准化之后的样子还是经常有所变化的。</p><!-- [[[read_end]]] --><p>我们也可以在我们的编译器落后于标准、不能提供标准库的某个功能时使用 Boost 里的替代品。比如，我之前提到过老版本的 macOS 上苹果的编译器不支持 optional 和 variant。除了我描述的不正规做法，改用 Boost 也是方法之一。比如，对于 variant，所需的改动只是：</p><ul>\n<li>把包含 &lt;variant&gt; 改成包含 &lt;boost/variant.hpp&gt;</li>\n<li>把代码中的 <code>std::variant</code> 改成 <code>boost::variant</code></li>\n</ul><p>这样，就基本大功告成了。</p><p>作为一个准标准的库，很多环境里缺省会提供 Boost。这种情况下，在程序里使用 Boost 不会额外增加编译或运行时的依赖，减少了可能的麻烦。如果我需要某个功能，在标准库里没有，在 Boost 里有，我会很乐意直接使用 Boost 里的方案，而非另外去查找。如果我要使用非 Boost 的第三方库的话，那一般要么是 Boost 里没有，要么就是那个库比 Boost 里的要好用很多了。</p><p>鉴于 Boost 是一个库集合，当前版本（1.72）有 160 个独立库，即使写本书也不可能完整地讨论所有的库。这一讲里，我们也就管中窥豹式地浏览几个 Boost 库。具体你需要什么，还是得你自己回头去细细品味。</p><h3>Boost 的安装</h3><p>在主要的开发平台上，现在你都可以直接安装 Boost，而不需要自己从源代码编译了：</p><ul>\n<li>在 Windows 下使用 MSVC，我们可以使用 NuGet 安装（按需逐个安装）</li>\n<li>在 Linux 下，我们可以使用系统的包管理器（如 apt 和 yum）安装（按需逐个安装，或一次性安装所有的开发需要的包）</li>\n<li>在 macOS 下，我们可以使用 Homebrew 安装（一次性安装完整的 Boost）</li>\n</ul><p>如果你在某个平台上使用非缺省的编译器，如在 Windows 上或 macOS 上使用 GCC，一般就需要自己编译了，具体步骤请参见 Boost 的文档。不过，很多 Boost 库是完全不需要编译的，只需要把头文件加到编译器能找到的路径里就可以——如我们上一讲讨论的 Boost.Multiprecision 就是这样。我们讨论 Boost 库的时候，也会提一下使用这个库是否需要链接某个 Boost 库——需要的话，也就意味着需要编译和安装这个 Boost 库。</p><h2>Boost.TypeIndex</h2><p>TypeIndex 是一个很轻量级的库，它不需要链接，解决的也是使用模板时的一个常见问题，如何精确地知道一个表达式或变量的类型。我们还是看一个例子：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;boost/type_index.hpp&gt;\n\nusing namespace std;\nusing boost::typeindex::type_id;\nusing boost::typeindex::\n  type_id_with_cvr;\n\nint main()\n{\n  vector&lt;int&gt; v;\n  auto it = v.cbegin();\n\n  cout &lt;&lt; \"*** Using typeid\\n\";\n  cout &lt;&lt; typeid(const int).name()\n       &lt;&lt; endl;\n  cout &lt;&lt; typeid(v).name() &lt;&lt; endl;\n  cout &lt;&lt; typeid(it).name() &lt;&lt; endl;\n\n  cout &lt;&lt; \"*** Using type_id\\n\";\n  cout &lt;&lt; type_id&lt;const int&gt;() &lt;&lt; endl;\n  cout &lt;&lt; type_id&lt;decltype(v)&gt;()\n       &lt;&lt; endl;\n  cout &lt;&lt; type_id&lt;decltype(it)&gt;()\n       &lt;&lt; endl;\n\n  cout &lt;&lt; \"*** Using \"\n          \"type_id_with_cvr\\n\";\n  cout\n    &lt;&lt; type_id_with_cvr&lt;const int&gt;()\n    &lt;&lt; endl;\n  cout &lt;&lt; type_id_with_cvr&lt;decltype(\n            (v))&gt;()\n       &lt;&lt; endl;\n  cout &lt;&lt; type_id_with_cvr&lt;decltype(\n            move((v)))&gt;()\n       &lt;&lt; endl;\n  cout &lt;&lt; type_id_with_cvr&lt;decltype(\n            (it))&gt;()\n       &lt;&lt; endl;\n}\n</code></pre><p>上面的代码里，展示了标准的 <code>typeid</code> 和 Boost 的 <code>type_id</code> 和 <code>type_id_with_cvr</code> 的使用。它们的区别是：</p><ul>\n<li><code>typeid</code> 是标准 C++ 的关键字，可以应用到变量或类型上，返回一个 <code>std::type_info</code>。我们可以用它的 <code>name</code> 成员函数把结果转换成一个字符串，但标准不保证这个字符串的可读性和唯一性。</li>\n<li><code>type_id</code> 是 Boost 提供的函数模板，必须提供类型作为模板参数——所以对于表达式和变量我们需要使用 <code>decltype</code>。结果可以直接输出到 IO 流上。</li>\n<li><code>type_id_with_cvr</code> 和 <code>type_id</code> 相似，但它获得的结果会包含 const/volatile 状态及引用类型。</li>\n</ul><p>上面程序在 MSVC 下的输出为：</p><blockquote>\n<p><code>*** Using typeid</code><br>\n<code>int</code><br>\n<code>class std::vector&lt;int,class std::allocator&lt;int&gt; &gt;</code><br>\n<code>class std::_Vector_const_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt;</code><br>\n<code>*** Using type_id</code><br>\n<code>int</code><br>\n<code>class std::vector&lt;int,class std::allocator&lt;int&gt; &gt;</code><br>\n<code>class std::_Vector_const_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt;</code><br>\n<code>*** Using type_id_with_cvr</code><br>\n<code>int const</code><br>\n<code>class std::vector&lt;int,class std::allocator&lt;int&gt; &gt; &amp;</code><br>\n<code>class std::vector&lt;int,class std::allocator&lt;int&gt; &gt; &amp;&amp;</code><br>\n<code>class std::_Vector_const_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt; &amp;</code></p>\n</blockquote><p>在 GCC 下的输出为：</p><blockquote>\n<p><code>*** Using typeid</code><br>\n<code>i</code><br>\n<code>St6vectorIiSaIiEE</code><br>\n<code>N9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEE</code><br>\n<code>*** Using type_id</code><br>\n<code>int</code><br>\n<code>std::vector&lt;int, std::allocator&lt;int&gt; &gt;</code><br>\n<code>__gnu_cxx::__normal_iterator&lt;int const*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;</code><br>\n<code>*** Using type_id_with_cvr</code><br>\n<code>int const</code><br>\n<code>std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;</code><br>\n<code>std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;&amp;</code><br>\n<code>__gnu_cxx::__normal_iterator&lt;int const*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;&amp;</code></p>\n</blockquote><p>我们可以看到 MSVC 下 <code>typeid</code> 直接输出了比较友好的类型名称，但 GCC 下没有。此外，我们可以注意到：</p><ul>\n<li><code>typeid</code> 的输出忽略了 const 修饰，也不能输出变量的引用类型。</li>\n<li><code>type_id</code> 保证可以输出友好的类型名称，输出时也不需要调用成员函数，但例子里它忽略了 <code>int</code> 的 const 修饰，也和 <code>typeid</code> 一样不能输出表达式的引用类型。</li>\n<li><code>type_id_with_cvr</code> 可以输出 const/volatile 状态和引用类型，注意这种情况下模板参数必须包含引用类型，所以我用了 <code>decltype((v))</code> 这种写法，而不是 <code>decltype(v)</code>。如果你忘了这两者的区别，请复习一下<a href=\"https://time.geekbang.org/column/article/176850\">[第 8 讲]</a> 的 <code>decltype</code>。</li>\n</ul><p>显然，除非你正在使用 MSVC，否则调试期 <code>typeid</code> 的用法完全应该用 Boost 的 <code>type_id</code> 来替代。另外，如果你的开发环境要求禁用 RTTI（运行时类型识别），那 <code>typeid</code> 在 Clang 和 GCC 下根本不能使用，而使用 Boost.TypeIndex 库仍然没有问题。</p><p>当然，上面说的前提都是你在调试中试图获得变量的类型，而不是要获得一个多态对象的运行时类型。后者还是离不开 RTTI 的——虽然你也可以用一些其他方式来模拟 RTTI，但我个人觉得一般的项目不太有必要这样做。下面的代码展示了 <code>typeid</code> 和 <code>type_id</code> 在获取对象类型上的差异：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;boost/type_index.hpp&gt;\n\nusing namespace std;\nusing boost::typeindex::type_id;\n\nclass shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {};\n\n#define CHECK_TYPEID(object, type) \\\n  cout &lt;&lt; \"typeid(\" #object &lt;&lt; \")\" \\\n       &lt;&lt; (typeid(object) ==       \\\n               typeid(type)        \\\n             ? \" is \"              \\\n             : \" is NOT \")         \\\n       &lt;&lt; #type &lt;&lt; endl\n\n#define CHECK_TYPE_ID(object,      \\\n                      type)        \\\n  cout &lt;&lt; \"type_id(\" #object       \\\n       &lt;&lt; \")\"                      \\\n       &lt;&lt; (type_id&lt;decltype(       \\\n                 object)&gt;() ==     \\\n               type_id&lt;type&gt;()     \\\n             ? \" is \"              \\\n             : \" is NOT \")         \\\n       &lt;&lt; #type &lt;&lt; endl\n\nint main()\n{\n  shape* ptr = new circle();\n  CHECK_TYPEID(*ptr, shape);\n  CHECK_TYPEID(*ptr, circle);\n  CHECK_TYPE_ID(*ptr, shape);\n  CHECK_TYPE_ID(*ptr, circle);\n  delete ptr;\n}\n</code></pre><p>输出为：</p><blockquote>\n<p><code>typeid(*ptr) is NOT shape</code><br>\n<code>typeid(*ptr) is circle</code><br>\n<code>type_id(*ptr) is shape</code><br>\n<code>type_id(*ptr) is NOT circle</code></p>\n</blockquote><h2>Boost.Core</h2><p>Core 里面提供了一些通用的工具，这些工具常常被 Boost 的其他库用到，而我们也可以使用，不需要链接任何库。在这些工具里，有些已经（可能经过一些变化后）进入了 C++ 标准，如：</p><ul>\n<li><code>addressof</code>，在即使用户定义了 <code>operator&amp;</code> 时也能获得对象的地址</li>\n<li><code>enable_if</code>，这个我们已经深入讨论过了（<a href=\"https://time.geekbang.org/column/article/181636\">[第 14 讲]</a>）</li>\n<li><code>is_same</code>，判断两个类型是否相同，C++11 开始在 &lt;type_traits&gt; 中定义</li>\n<li><code>ref</code>，和标准库的相同，我们在<a href=\"https://time.geekbang.org/column/article/186689\">[第 19 讲]</a> 讨论线程时用过</li>\n</ul><p>我们在剩下的里面来挑几个讲讲。</p><h3>boost::core::demangle</h3><p><code>boost::core::demangle</code> 能够用来把 <code>typeid</code> 返回的内部名称“反粉碎”（demangle）成可读的形式，看代码和输出应该就非常清楚了：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;vector&gt;\n#include &lt;boost/core/demangle.hpp&gt;\n\nusing namespace std;\nusing boost::core::demangle;\n\nint main()\n{\n  vector&lt;int&gt; v;\n  auto it = v.cbegin();\n\n  cout &lt;&lt; \"*** Using typeid\\n\";\n  cout &lt;&lt; typeid(const int).name()\n       &lt;&lt; endl;\n  cout &lt;&lt; typeid(v).name() &lt;&lt; endl;\n  cout &lt;&lt; typeid(it).name() &lt;&lt; endl;\n\n  cout &lt;&lt; \"*** Demangled\\n\";\n  cout &lt;&lt; demangle(typeid(const int)\n                     .name())\n       &lt;&lt; endl;\n  cout &lt;&lt; demangle(typeid(v).name())\n       &lt;&lt; endl;\n  cout &lt;&lt; demangle(\n            typeid(it).name())\n       &lt;&lt; endl;\n}\n</code></pre><p>GCC 下的输出为：</p><blockquote>\n<p><code>*** Using typeid</code><br>\n<code>i</code><br>\n<code>St6vectorIiSaIiEE</code><br>\n<code>N9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEE</code><br>\n<code>*** Demangled</code><br>\n<code>int</code><br>\n<code>std::vector&lt;int, std::allocator&lt;int&gt; &gt;</code><br>\n<code>__gnu_cxx::__normal_iterator&lt;int const*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;</code></p>\n</blockquote><p>如果你不使用 RTTI 的话，那直接使用 TypeIndex 应该就可以。如果你需要使用 RTTI、又不是（只）使用 MSVC 的话，<code>demangle</code> 就会给你不少帮助。</p><h3>boost::noncopyable</h3><p><code>boost::noncopyable</code> 提供了一种非常简单也很直白的把类声明成不可拷贝的方式。比如，我们<a href=\"https://time.geekbang.org/column/article/169225\">[第 1 讲]</a> 里的 <code>shape_wrapper</code>，用下面的写法就明确表示了它不允许被拷贝：</p><pre><code class=\"language-c++\">#include &lt;boost/core/noncopyable.hpp&gt;\n\nclass shape_wrapper\n  : private boost::noncopyable {\n  …\n};\n</code></pre><p>你当然也可以自己把拷贝构造和拷贝赋值函数声明成 <code>= delete</code>，不过，上面的写法是不是可读性更佳？</p><h3>boost::swap</h3><p>你有没有印象在通用的代码如何对一个不知道类型的对象执行交换操作？不记得的话，标准做法是这样的：</p><pre><code class=\"language-c++\">{\n  using std::swap;\n  swap(lhs, rhs);\n}\n</code></pre><p>即，我们需要（在某个小作用域里）引入 <code>std::swap</code>，然后让编译器在“看得到” <code>std::swap</code> 的情况下去编译 <code>swap</code> 指令。根据 ADL，如果在被交换的对象所属类型的名空间下有 <code>swap</code> 函数，那个函数会被优先使用，否则，编译器会选择通用的 <code>std::swap</code>。</p><p>似乎有点小啰嗦。使用 Boost 的话，你可以一行搞定：</p><pre><code class=\"language-c++\">boost::swap(lhs, rhs);\n</code></pre><p>当然，你需要包含头文件 &lt;boost/core/swap.hpp&gt;。</p><h2>Boost.Conversion</h2><p>Conversion 同样是一个不需要链接的轻量级的库。它解决了标准 C++ 里的另一个问题，标准类型之间的转换不够方便。在 C++11 之前，这个问题尤为严重。在 C++11 里，标准引入了一系列的函数，已经可以满足常用类型之间的转换。但使用 Boost.Conversion 里的 <code>lexical_cast</code> 更不需要去查阅方法名称或动脑子去努力记忆。</p><p>下面是一个例子：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;boost/lexical_cast.hpp&gt;\n\nusing namespace std;\nusing boost::bad_lexical_cast;\nusing boost::lexical_cast;\n\nint main()\n{\n  // 整数到字符串的转换\n  int d = 42;\n  auto d_str =\n    lexical_cast&lt;string&gt;(d);\n  cout &lt;&lt; d_str &lt;&lt; endl;\n\n  // 字符串到浮点数的转换\n  auto f =\n    lexical_cast&lt;float&gt;(d_str) /\n    4.0;\n  cout &lt;&lt; f &lt;&lt; endl;\n\n  // 测试 lexical_cast 的转换异常\n  try {\n    int t = lexical_cast&lt;int&gt;(\"x\");\n    cout &lt;&lt; t &lt;&lt; endl;\n  }\n  catch (bad_lexical_cast&amp; e) {\n    cout &lt;&lt; e.what() &lt;&lt; endl;\n  }\n\n  // 测试标准库 stoi 的转换异常\n  try {\n    int t = std::stoi(\"x\");\n    cout &lt;&lt; t &lt;&lt; endl;\n  }\n  catch (invalid_argument&amp; e) {\n    cout &lt;&lt; e.what() &lt;&lt; endl;\n  }\n}\n</code></pre><p>GCC 下的输出为：</p><blockquote>\n<p><code>42</code><br>\n<code>10.5</code><br>\n<code>bad lexical cast: source type value could not be interpreted as target</code><br>\n<code>stoi</code></p>\n</blockquote><p>我觉得 GCC 里 <code>stoi</code> 的异常输出有点太言简意赅了……而 <code>lexical_cast</code> 的异常输出在不同的平台上有很好的一致性。</p><h2>Boost.ScopeExit</h2><p>我们说过 RAII 是推荐的 C++ 里管理资源的方式。不过，作为 C++ 程序员，跟 C 函数打交道也很正常。每次都写个新的 RAII 封装也有点浪费。Boost 里提供了一个简单的封装，你可以从下面的示例代码里看到它是如何使用的：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n#include &lt;boost/scope_exit.hpp&gt;\n\nvoid test()\n{\n  FILE* fp = fopen(\"test.cpp\", \"r\");\n  if (fp == NULL) {\n    perror(\"Cannot open file\");\n  }\n  BOOST_SCOPE_EXIT(&amp;fp) {\n    if (fp) {\n      fclose(fp);\n      puts(\"File is closed\");\n    }\n  } BOOST_SCOPE_EXIT_END\n  puts(\"Faking an exception\");\n  throw 42;\n}\n\nint main()\n{\n  try {\n    test();\n  }\n  catch (int) {\n    puts(\"Exception received\");\n  }\n}\n</code></pre><p>唯一需要说明的可能就是 <code>BOOST_SCOPE_EXIT</code> 里的那个 <code>&amp;</code> 符号了——把它理解成 lambda 表达式的按引用捕获就对了（虽然 <code>BOOST_SCOPE_EXIT</code> 可以支持 C++98 的代码）。如果不需要捕获任何变量，<code>BOOST_SCOPE_EXIT</code> 的参数必须填为 <code>void</code>。</p><p>输出为（假设 test.cpp 存在）：</p><blockquote>\n<p><code>Faking an exception</code><br>\n<code>File is closed</code><br>\n<code>Exception received</code></p>\n</blockquote><p>使用这个库也只需要头文件。注意实现类似的功能在 C++11 里相当容易，但由于 ScopeExit 可以支持 C++98 的代码，因而它的实现还是相当复杂的。</p><h2>Boost.Program_options</h2><p>传统上 C 代码里处理命令行参数会使用 <code>getopt</code>。我也用过，比如在下面的代码中：</p><p><a href=\"https://github.com/adah1972/breaktext/blob/master/breaktext.c\">https://github.com/adah1972/breaktext/blob/master/breaktext.c</a></p><p>这种方式有不少缺陷：</p><ul>\n<li>一个选项通常要在三个地方重复：说明文本里，<code>getopt</code> 的参数里，以及对 <code>getopt</code> 的返回结果进行处理时。不知道你觉得怎样，我反正发生过改了一处、漏改其他的错误。</li>\n<li>对选项的附加参数需要手工写代码处理，因而常常不够严格（C 的类型转换不够方便，尤其是检查错误）。</li>\n</ul><p>Program_options 正是解决这个问题的。这个代码有点老了，不过还挺实用；懒得去找特别的处理库时，至少这个伸手可用。使用这个库需要链接 boost_program_options 库。</p><p>下面的代码展示了代替上面的 <code>getopt</code> 用法的代码：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;boost/program_options.hpp&gt;\n\nnamespace po = boost::program_options;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\nstring locale;\nstring lang;\nint width = 72;\nbool keep_indent = false;\nbool verbose = false;\n\nint main(int argc, char* argv[])\n{\n  po::options_description desc(\n    \"Usage: breaktext [OPTION]... \"\n    \"&lt;Input File&gt; [Output File]\\n\"\n    \"\\n\"\n    \"Available options\");\n  desc.add_options()\n    (\"locale,L\",\n     po::value&lt;string&gt;(&amp;locale),\n     \"Locale of the console (system locale by default)\")\n    (\"lang,l\",\n     po::value&lt;string&gt;(&amp;lang),\n     \"Language of input (asssume no language by default)\")\n    (\"width,w\",\n     po::value&lt;int&gt;(&amp;width),\n     \"Width of output text (72 by default)\")\n    (\"help,h\", \"Show this help message and exit\")\n    (\",i\",\n     po::bool_switch(&amp;keep_indent),\n     \"Keep space indentation\")\n    (\",v\",\n     po::bool_switch(&amp;verbose),\n     \"Be verbose\");\n\n  po::variables_map vm;\n  try {\n    po::store(\n      po::parse_command_line(\n        argc, argv, desc),\n      vm);\n  }\n  catch (po::error&amp; e) {\n    cout &lt;&lt; e.what() &lt;&lt; endl;\n    exit(1);\n  }\n  vm.notify();\n\n  if (vm.count(\"help\")) {\n    cout &lt;&lt; desc &lt;&lt; \"\\n\";\n    exit(1);\n  }\n}\n</code></pre><p>略加说明一下：</p><ul>\n<li><code>options_description</code> 是基本的选项描述对象的类型，构造时我们给出对选项的基本描述。</li>\n<li><code>options_description</code> 对象的 <code>add_options</code> 成员函数会返回一个函数对象，然后我们直接用括号就可以添加一系列的选项。</li>\n<li>每个选项初始化时可以有两个或三个参数，第一项是选项的形式，使用长短选项用逗号隔开的字符串（可以只提供一种），最后一项是选项的文字描述，中间如果还有一项的话，就是选项的值描述。</li>\n<li>选项的值描述可以用 <code>value</code>、<code>bool_switch</code> 等方法，参数是输出变量的指针。</li>\n<li><code>variables_map</code>，变量映射表，用来存储对命令行的扫描结果；它继承了标准的 <code>std::map</code>。</li>\n<li><code>notify</code> 成员函数用来把变量映射表的内容实际传送到选项值描述里提供的那些变量里去。</li>\n<li><code>count</code> 成员函数继承自 <code>std::map</code>，只能得到 0 或 1 的结果。</li>\n</ul><p>这样，我们的程序就能处理上面的那些选项了。如果运行时在命令行加上 <code>-h</code> 或 <code>--help</code> 选项，程序就会输出跟原来类似的帮助输出——额外的好处是选项的描述信息较长时还能自动帮你折行，不需要手工排版了。建议你自己尝试一下，提供各种正确或错误的选项，来检查一下运行的结果。</p><p>当然现在有些更新的选项处理库，但它们应该都和 Program_options 更接近，而不是和 <code>getopt</code> 更接近。如果你感觉 Program_options 功能不足了，换一个其他库不会是件麻烦事。</p><h2>Boost.Hana</h2><p>Boost 里自然也有模板元编程相关的东西。但我不打算介绍 MPL、Fusion 和 Phoenix 那些，因为有些技巧，在 C++11 和 Lambda 表达式到来之后，已经略显得有点过时了。Hana 则不同，它是一个使用了 C++11/14 实现技巧和惯用法的新库，也和一般的模板库一样，只要有头文件就能使用。</p><p>Hana 里定义了一整套供<strong>编译期</strong>使用的数据类型和函数。我们现在看一下它提供的部分类型：</p><ul>\n<li><code>type</code>：把类型转化成对象（我们在<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 曾经示例过相反的动作，把数值转化成对象），来方便后续处理。</li>\n<li><code>integral_constant</code>：跟 <code>std::integral_constant</code> 相似，但定义了更多的运算符和语法糖。特别的，你可以用字面量来生成一个 <code>long long</code> 类型的 <code>integral_constant</code>，如 <code>1_c</code>。</li>\n<li><code>string</code>：一个编译期使用的字符串类型。</li>\n<li><code>tuple</code>：跟 <code>std::tuple</code> 类似，意图是当作编译期的 <code>vector</code> 来使用。</li>\n<li><code>map</code>：编译期使用的关联数组。</li>\n<li><code>set</code>：编译期使用的集合。</li>\n</ul><p>Hana 里的算法的名称跟标准库的类似，我就不一一列举了。下面的例子展示了一个基本用法：</p><pre><code class=\"language-c++\">#include &lt;boost/hana.hpp&gt;\nnamespace hana = boost::hana;\n\nclass shape {};\nclass circle {};\nclass triangle {};\n\nint main()\n{\n  using namespace hana::literals;\n\n  constexpr auto tup =\n    hana::make_tuple(\n      hana::type_c&lt;shape*&gt;,\n      hana::type_c&lt;circle&gt;,\n      hana::type_c&lt;triangle&gt;);\n\n  constexpr auto no_pointers =\n    hana::remove_if(\n      tup, [](auto a) {\n        return hana::traits::\n          is_pointer(a);\n      });\n\n  static_assert(\n    no_pointers ==\n    hana::make_tuple(\n      hana::type_c&lt;circle&gt;,\n      hana::type_c&lt;triangle&gt;));\n  static_assert(\n    hana::reverse(no_pointers) ==\n    hana::make_tuple(\n      hana::type_c&lt;triangle&gt;,\n      hana::type_c&lt;circle&gt;));\n  static_assert(\n    tup[1_c] == hana::type_c&lt;circle&gt;);\n}\n</code></pre><p>这个程序可以编译，但没有任何运行输出。在这个程序里，我们做了下面这几件事：</p><ul>\n<li>使用 <code>type_c</code> 把类型转化成 <code>type</code> 对象，并构造了类型对象的 <code>tuple</code></li>\n<li>使用 <code>remove_if</code> 算法移除了 <code>tup</code> 中的指针类型</li>\n<li>使用静态断言确认了结果是我们想要的</li>\n<li>使用静态断言确认了可以用 <code>reverse</code> 把 <code>tup</code> 反转一下</li>\n<li>使用静态断言确认了可以用方括号运算符来获取 <code>tup</code> 中的某一项</li>\n</ul><p>可以看到，Hana 本质上以类似普通的运行期编程的写法，来做编译期的计算。上面展示的只是一些最基本的用法，而 Hana 的文档里展示了很多有趣的用法。尤其值得一看的是，文档中展示了如何利用 Hana 提供的机制，来自己定义 <code>switch_</code>、<code>case_</code>、<code>default_</code>，使得下面的代码可以通过编译：</p><pre><code class=\"language-c++\">boost::any a = 'x';\nstd::string r =\n  switch_(a)(\n    case_&lt;int&gt;([](auto i) {\n      return \"int: \"s +\n             std::to_string(i);\n    }),\n    case_&lt;char&gt;([](auto c) {\n      return \"char: \"s +\n             std::string{c};\n    }),\n    default_(\n      [] { return \"unknown\"s; }));\nassert(r == \"char: x\"s);\n</code></pre><p>我个人认为很有意思。</p><h2>内容小结</h2><p>本讲我们对 Boost 的意义做了概要介绍，并蜻蜓点水地简单描述了若干 Boost 库的功能。如果你想进一步了解 Boost 的细节的话，就得自行查看文档了。</p><h2>课后思考</h2><p>请你考虑一下，我今天描述的 Boost 库里的功能是如何实现的。然后自己去看一下源代码（开源真是件大好事！），检查一下跟自己想象的是不是有出入。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Boost C++ Libraries. <a href=\"https://www.boost.org/\">https://www.boost.org/</a> </span></p><p><span class=\"reference\">[2] David Abarahams and Aleksey Gurtovoy, <em>C++ Template Metaprogramming</em>. Addison-Wesley, 2004. 有中文版（荣耀译，机械工业出版社，2010 年） </span></p>","neighbors":{"left":{"article_title":"23 | 数字计算：介绍线性代数和数值计算库","id":189042},"right":{"article_title":"25 | 两个单元测试库：C++里如何进行单元测试?","id":191714}}},{"article_id":191714,"article_title":"25 | 两个单元测试库：C++里如何进行单元测试?","article_content":"<p>你好，我是吴咏炜。</p><p>单元测试已经越来越成为程序员工作密不可分的一部分了。在 C++ 里，我们当然也是可以很方便地进行单元测试的。今天，我就来介绍两个单元测试库：一个是 Boost.Test <span class=\"orange\">[1]</span>，一个是 Catch2 <span class=\"orange\">[2]</span>。</p><h2>Boost.Test</h2><p>单元测试库有很多，我选择 Boost 的原因我在上一讲已经说过：“如果我需要某个功能，在标准库里没有，在 Boost 里有，我会很乐意直接使用 Boost 里的方案，而非另外去查找。”再说，Boost.Test 提供的功能还挺齐全的，我需要的都有了。作为开胃小菜，我们先看一个单元测试的小例子：</p><pre><code class=\"language-c++\">#define BOOST_TEST_MAIN\n#include &lt;boost/test/unit_test.hpp&gt;\n#include &lt;stdexcept&gt;\n\nvoid test(int n)\n{\n  if (n == 42) {\n    return;\n  }\n  throw std::runtime_error(\n    \"Not the answer\");\n}\n\nBOOST_AUTO_TEST_CASE(my_test)\n{\n  BOOST_TEST_MESSAGE(\"Testing\");\n  BOOST_TEST(1 + 1 == 2);\n  BOOST_CHECK_THROW(\n    test(41), std::runtime_error);\n  BOOST_CHECK_NO_THROW(test(42));\n\n  int expected = 5;\n  BOOST_TEST(2 + 2 == expected);\n  BOOST_CHECK(2 + 2 == expected);\n}\n\nBOOST_AUTO_TEST_CASE(null_test)\n{\n}\n</code></pre><!-- [[[read_end]]] --><p>我们从代码里可以看到：</p><ul>\n<li>我们在包含单元测试的头文件之前定义了 <code>BOOST_TEST_MAIN</code>。如果编译时用到了多个源文件，只有一个应该定义该宏。多文件测试的时候，我一般会考虑把这个定义这个宏加包含放在一个单独的文件里（只有两行）。</li>\n<li>我们用 <code>BOOST_AUTO_TEST_CASE</code> 来定义一个测试用例。一个测试用例里应当有多个测试语句（如 <code>BOOST_CHECK</code>）。</li>\n<li>我们用 <code>BOOST_CHECK</code> 或 <code>BOOST_TEST</code> 来检查一个应当成立的布尔表达式（区别下面会讲）。</li>\n<li>我们用 <code>BOOST_CHECK_THROW</code> 来检查一个应当抛出异常的语句。</li>\n<li>我们用 <code>BOOST_CHECK_NO_THROW</code> 来检查一个不应当抛出异常的语句。</li>\n</ul><p>如<a href=\"https://time.geekbang.org/column/article/187980\">[第 21 讲]</a> 所述，我们可以用下面的命令行来进行编译：</p><ul>\n<li>MSVC：<code>cl /DBOOST_TEST_DYN_LINK /EHsc /MD test.cpp</code></li>\n<li>GCC：<code>g++ -DBOOST_TEST_DYN_LINK test.cpp -lboost_unit_test_framework</code></li>\n<li>Clang：<code>clang++ -DBOOST_TEST_DYN_LINK test.cpp -lboost_unit_test_framework</code></li>\n</ul><p>运行结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/fc/2e71b25e154d6609bd5cd3f4bf4911fc.png\" alt=\"\"></p><p>我们现在能看到 <code>BOOST_CHECK</code> 和 <code>BOOST_TEST</code> 的区别了。后者是一个较新加入 Boost.Test 的宏，能利用模板技巧来输出表达式的具体内容。但在某些情况下，<code>BOOST_TEST</code> 试图输出表达式的内容会导致编译出错，这时可以改用更简单的 <code>BOOST_CHECK</code>。</p><p>不管是 <code>BOOST_CHECK</code> 还是 <code>BOOST_TEST</code>，在测试失败时，执行仍然会继续。在某些情况下，一个测试失败后继续执行后面的测试已经没有意义，这时，我们就可以考虑使用 <code>BOOST_REQUIRE</code> 或 <code>BOOST_TEST_REQUIRE</code>——表达式一旦失败，整个测试用例会停止执行（但其他测试用例仍会正常执行）。</p><p>缺省情况下单元测试的输出只包含错误信息和结果摘要，但输出的详细程度是可以通过命令行选项来进行控制的。如果我们在运行测试程序时加上命令行参数 <code>--log_level=all</code>（或 <code>-l all</code>），我们就可以得到下面这样更详尽的输出：</p><p><img src=\"https://static001.geekbang.org/resource/image/4e/73/4ead9a603e0f5c4703637c905a2faf73.png\" alt=\"\"></p><p>我们现在额外可以看到：</p><ul>\n<li>在进入、退出测试模块和用例时的提示</li>\n<li><code>BOOST_TEST_MESSAGE</code> 的输出</li>\n<li>正常通过的测试的输出</li>\n<li>用例里无测试断言的警告</li>\n</ul><p>使用 Windows 的同学如果运行了测试程序的话，多半会惊恐地发现终端上的文字颜色已经发生了变化。这似乎是 Boost.Test 在 Windows 上特有的一个问题：建议你把单元测试的色彩显示关掉。你可以在系统高级设置里添加下面这个环境变量，也可以直接在命令行上输入：</p><pre><code class=\"language-batch\">set BOOST_TEST_COLOR_OUTPUT=0\n</code></pre><hr><p>下面我们看一个更真实的例子。</p><p>假设我们有一个 <code>split</code> 函数，定义如下：</p><pre><code class=\"language-c++\">template &lt;typename String,\n          typename Delimiter&gt;\nclass split_view {\npublic:\n  typedef\n    typename String::value_type\n      char_type;\n  class iterator { … };\n\n  split_view(const String&amp; str,\n             Delimiter delimiter);\n  iterator begin() const;\n  iterator end() const;\n  vector&lt;basic_string&lt;char_type&gt;&gt;\n  to_vector() const;\n  vector&lt;basic_string_view&lt;char_type&gt;&gt;\n  to_vector_sv() const;\n};\n\ntemplate &lt;typename String,\n          typename Delimiter&gt;\nsplit_view&lt;String, Delimiter&gt;\nsplit(const String&amp; str,\n      Delimiter delimiter);\n</code></pre><p>这个函数的意图是把类似于字符串的类型（<code>string</code> 或 <code>string_view</code>）分割开，并允许对分割的结果进行遍历。为了方便使用，结果也可以直接转化成字符串的数组（<code>to_vector</code>）或字符串视图的数组（<code>to_vector_sv</code>）。我们不用关心这个函数是如何实现的，我们就需要测试一下，该如何写呢？</p><p>首先，当然是写出一个测试用例的框架，把试验的待分割字符串写进去：</p><pre><code class=\"language-c++\">BOOST_AUTO_TEST_CASE(split_test)\n{\n  string_view str{\n    \"&amp;grant_type=client_credential\"\n    \"&amp;appid=\"\n    \"&amp;secret=APPSECRET\"};\n}\n</code></pre><p>最简单直白的测试，显然就是用 <code>to_vector</code> 或 <code>to_vector_sv</code> 来查看结果是否匹配了。这个非常容易加进去：</p><pre><code class=\"language-c++\">  vector&lt;string&gt;\n    split_result_expected{\n      \"\",\n      \"grant_type=client_\"\n      \"credential\",\n      \"appid=\",\n      \"secret=APPSECRET\"};\n  auto result = split(str, '&amp;');\n  auto result_s =\n    result.to_vector();\n  BOOST_TEST(result_s ==\n             split_result_expected);\n</code></pre><p>如果 <code>to_vector</code> 实现正确的话，我们现在运行程序就能在终端输出上看到：</p><blockquote>\n<p><code>*** No errors detected</code></p>\n</blockquote><p>下面，我们进一步检查 <code>to_vector</code> 和 <code>to_vector_sv</code> 的结果是否一致：</p><pre><code class=\"language-c++\">  auto result_sv =\n    result.to_vector_sv();\n  BOOST_TEST_REQUIRE(\n    result_s.size() ==\n    result_sv.size());\n  {\n    auto it = result_sv.begin();\n    for (auto&amp; s : result_s) {\n      BOOST_TEST(s == *it);\n      ++it;\n    }\n  }\n</code></pre><p>最后我们再测试可以遍历 <code>result</code>，并且结果和之前的相同：</p><pre><code class=\"language-c++\">  size_t i = 0;\n  auto it = result.begin();\n  auto end = result.end();\n  for (; it != end &amp;&amp;\n         i &lt; result_s.size();\n       ++it) {\n    BOOST_TEST(*it == result_s[i]);\n    ++i;\n  }\n  BOOST_CHECK(it == end);\n</code></pre><p>而这，差不多就接近我实际的  <code>split</code> 测试代码了。完整代码可参见：</p><p><a href=\"https://github.com/adah1972/nvwa/blob/master/test/boosttest_split.cpp\">https://github.com/adah1972/nvwa/blob/master/test/boosttest_split.cpp</a></p><hr><p>Boost.Test 产生的可执行代码支持很多命令行参数，可以用 <code>--help</code> 命令行选项来查看。常用的有：</p><ul>\n<li><code>build_info</code> 可用来展示构建信息</li>\n<li><code>color_output</code> 可用来打开或关闭输出中的色彩</li>\n<li><code>log_format</code> 可用来指定日志输出的格式，包括纯文本、XML、JUnit 等</li>\n<li><code>log_level</code> 可指定日志输出的级别，有 all、test_suite、error、fatal_error、nothing 等一共 11 个级别</li>\n<li><code>run_test</code> 可选择只运行指定的测试用例</li>\n<li><code>show_progress</code> 可在测试时显示进度，在测试数量较大时比较有用（见下图）</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/c2/e5/c21168d96cd55836575a7e5b44e3a7e5.png\" alt=\"\"></p><p>我这儿只是个简单的介绍。完整的 Boost.Test 的功能介绍还是请你自行参看文档。</p><h2>Catch2</h2><p>说完了 Boost.Test，我们再来看一下另外一个单元测试库，Catch2。仍然是和上一讲里说的一样，我要选择 Boost 之外的库，一定有一个比较强的理由。Catch2 有着它自己独有的优点：</p><ul>\n<li>只需要单个头文件即可使用，不需要安装和链接，简单方便</li>\n<li>可选使用 BDD（Behavior-Driven Development）风格的分节形式</li>\n<li>测试失败可选直接进入调试器（Windows 和 macOS 上）</li>\n</ul><p>我们拿前面 Boost.Test 的示例直接改造一下：</p><pre><code class=\"language-c++\">#define CATCH_CONFIG_MAIN\n#include \"catch.hpp\"\n#include &lt;stdexcept&gt;\n\nvoid test(int n)\n{\n  if (n == 42) {\n    return;\n  }\n  throw std::runtime_error(\n    \"Not the answer\");\n}\n\nTEST_CASE(\"My first test\", \"[my]\")\n{\n  INFO(\"Testing\");\n  CHECK(1 + 1 == 2);\n  CHECK_THROWS_AS(\n    test(41), std::runtime_error);\n  CHECK_NOTHROW(test(42));\n\n  int expected = 5;\n  CHECK(2 + 2 == expected);\n}\n\nTEST_CASE(\"A null test\", \"[null]\")\n{\n}\n</code></pre><p>可以看到，两者之间的相似性非常多，基本只是宏的名称变了一下。唯一值得一提的，是测试用例的参数：第一项是名字，第二项是标签，可以一个或多个。你除了可以直接在命令行上写测试的名字（不需要选项）来选择运行哪个测试外，也可以写测试的标签来选择运行哪些测试。</p><p>这是它在 Windows 下用 MSVC 编译的输出：</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/c7/6faf4113a57d9c4b65d203de52c8bfc7.png\" alt=\"\"></p><p>终端的色彩不会被搞乱。缺省的输出清晰程度相当不错。至少在 Windows 下，它看起来可能是个比 Boost.Test 更好的选择。但反过来，在浅色的终端里，Catch2 的色彩不太友好。Boost.Test 在 Linux 和 macOS 下则不管终端的色彩设定，都有比较友好的输出。</p><p>和 Boost.Test 类似，Catch2 的测试结果输出格式也是可以修改的。默认格式是纯文本，但你可以通过使用 <code>-r junit</code> 来设成跟 JUnit 兼容的格式，或使用 <code>-r xml</code> 输出成 Catch2 自己的 XML 格式。这方面，它比 Boost.Test 明显易用的一个地方是格式参数大小写不敏感，而在 Boost.Test 里你必须用全大写的形式，如 <code>-f JUNIT</code>，麻烦！</p><hr><p>下面我们通过另外一个例子来展示一下所谓的 BDD <span class=\"orange\">[3]</span> 风格的测试。</p><p>BDD 风格的测试一般采用这样的结构：</p><ul>\n<li>Scenario：场景，我要做某某事</li>\n<li>Given：给定，已有的条件</li>\n<li>When：当，某个事件发生时</li>\n<li>Then：那样，就应该发生什么</li>\n</ul><p>如果我们要测试一个容器，那代码就应该是这个样子的：</p><pre><code class=\"language-c++\">SCENARIO(\"Int container can be accessed and modified\",\n         \"[container]\")\n{\n  GIVEN(\"A container with initialized items\")\n  {\n    IntContainer c{1, 2, 3, 4, 5};\n    REQUIRE(c.size() == 5);\n\n    WHEN(\"I access existing items\")\n    {\n      THEN(\"The items can be retrieved intact\")\n      {\n          CHECK(c[0] == 1);\n          CHECK(c[1] == 2);\n          CHECK(c[2] == 3);\n          CHECK(c[3] == 4);\n          CHECK(c[4] == 5);\n      }\n    }\n\n    WHEN(\"I modify items\")\n    {\n      c[1] = -2;\n      c[3] = -4;\n\n      THEN(\"Only modified items are changed\")\n      {\n        CHECK(c[0] == 1);\n        CHECK(c[1] == -2);\n        CHECK(c[2] == 3);\n        CHECK(c[3] == -4);\n        CHECK(c[4] == 5);\n      }\n    }\n  }\n}\n</code></pre><p>你可以在程序前面加上类型定义来测试你自己的容器类或标准容器（如 <code>vector&lt;int&gt;</code>）。这是一种非常直观的写测试的方式。正常情况下，你当然应该看到：</p><blockquote>\n<p><code>All tests passed (12 assertions in 1 test case)</code></p>\n</blockquote><p>如果你没有留意到的话，在 GIVEN 里 WHEN 之前的代码是在每次 WHEN 之前都会执行一遍的。这也是 BDD 方式的一个非常方便的地方。</p><p>如果测试失败，我们就能看到类似下面这样的信息输出了（我存心制造了一个错误）：</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/8b/fe7e7efbbc6e69418b378ea27701998b.png\" alt=\"\"></p><p>如果没有失败的情况下，想看到具体的测试内容，可以传递参数 <code>--success</code>（或 <code>-s</code>）。</p><hr><p>如果你发现 Catch2 的编译速度有点慢的话，那我得告诉你，那是非常正常的。在你沮丧之前，我还应该马上告诉你，这在实际项目中完全不是一个问题。因为慢的原因通常主要是构建 Catch2 的主程序部分，而这部份在项目中只需要做一次，以后不会再有变动。你需要的是分离下面这部分代码在主程序里：</p><pre><code class=\"language-c++\">#define CATCH_CONFIG_MAIN\n#include \"catch.hpp\"\n</code></pre><p>只要这两行，来单独编译 Catch2 的主程序部分。你的实际测试代码里，则不要再定义 <code>CATCH_CONFIG_MAIN</code> 了。你会发现，这样一分离后，编译速度会大大加快。事实上，如果 Catch2 的主程序部分不需要编译的话，Catch2 的测试用例的编译速度在我的机器上比 Boost.Test 的还要快。</p><p>我觉得 Catch2 是一个很现代、很好用的测试框架。它的宏更简单，一个 <code>CHECK</code> 可以替代 Boost.Test 中的 <code>BOOST_TEST</code> 和 <code>BOOST_CHECK</code>，也没有 <code>BOOST_TEST</code> 在某些情况下不能用、必须换用 <code>BOOST_CHECK</code> 的问题。对于一个新项目，使用 Catch2 应该是件更简单、更容易上手的事——尤其如果你在 Windows 上开发的话。</p><p>目前，在 GitHub 上，Catch2 的收藏数超过一万，复刻（fork）数达到一千七，也已经足以证明它的流行程度。</p><h2>内容小结</h2><p>今天我们介绍了两个单元测试库，Boost.Test 和 Catch2。整体上来看，这两个都是很优秀的单元测试框架，可以满足日常开发的需要。</p><h2>课后思考</h2><p>请你自己试验一下本讲中的例子，来制造一些成功和失败的情况。使用一下，才能更容易确定哪一个更适合你的需求。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Gennadiy Rozental and Raffi Enficiaud, Boost.Test. <a href=\"https://www.boost.org/doc/libs/release/libs/test/doc/html/index.html\">https://www.boost.org/doc/libs/release/libs/test/doc/html/index.html</a> </span></p><p><span class=\"reference\">[2] Two Blue Cubes Ltd., Catch2. <a href=\"https://github.com/catchorg/Catch2\">https://github.com/catchorg/Catch2</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “Behavior-driven development”. <a href=\"https://en.wikipedia.org/wiki/Behavior-driven_development\">https://en.wikipedia.org/wiki/Behavior-driven_development</a> </span></p>","neighbors":{"left":{"article_title":"24 | Boost：你需要的“瑞士军刀”","id":191136},"right":{"article_title":"26 | Easylogging++和spdlog：两个好用的日志库","id":193203}}},{"article_id":193203,"article_title":"26 | Easylogging++和spdlog：两个好用的日志库","article_content":"<p>你好，我是吴咏炜。</p><p>上一讲正文我介绍了两个可以在 C++ 中进行单元测试的库。今天，类似的，我介绍两个实用的日志库，分别是 Easylogging++ <span class=\"orange\">[1]</span> 和 spdlog <span class=\"orange\">[2]</span>。</p><h2>Easylogging++</h2><p>事实上，我本来想只介绍 Easylogging++ 的。但在检查其 GitHub 页面时，我发现了一个问题：它在 2019 年基本没有更新，且目前上报的问题也没有人处理。这是个潜在问题，除非你觉得这个库好到愿意自己动手修问题（话说回来，这个库还是不错的，我在这个项目贡献了 8 个被合并的 pull request）。不管怎样，原先说了要介绍这个库，所以我也还是介绍一下。</p><h3>概述</h3><p>Easylogging++ 一共只有两个文件，一个是头文件，一个是普通 C++ 源文件。事实上，它的一个较早版本只有一个文件。正如 Catch2 里一旦定义了 <code>CATCH_CONFIG_MAIN</code> 编译速度会大大减慢一样，把什么东西都放一起最终证明对编译速度还是相当不利的，因此，有人提交了一个补丁，把代码拆成了两个文件。使用 Easylogging++ 也只需要这两个文件——除此之外，就只有对标准和系统头文件的依赖了。</p><p>要使用 Easylogging++，推荐直接把这两个文件放到你的项目里。Easylogging++ 有很多的配置项会影响编译结果，我们先大致查看一下常用的可配置项：</p><!-- [[[read_end]]] --><ul>\n<li><code>ELPP_UNICODE</code>：启用 Unicode 支持，为在 Windows 上输出混合语言所必需</li>\n<li><code>ELPP_THREAD_SAFE</code>：启用多线程支持</li>\n<li><code>ELPP_DISABLE_LOGS</code>：全局禁用日志输出</li>\n<li><code>ELPP_DEFAULT_LOG_FILE</code>：定义缺省日志文件名称</li>\n<li><code>ELPP_NO_DEFAULT_LOG_FILE</code>：不使用缺省的日志输出文件</li>\n<li><code>ELPP_UTC_DATETIME</code>：在日志里使用协调世界时而非本地时间</li>\n<li><code>ELPP_FEATURE_PERFORMANCE_TRACKING</code>：开启性能跟踪功能</li>\n<li><code>ELPP_FEATURE_CRASH_LOG</code>：启用 GCC 专有的崩溃日志功能</li>\n<li><code>ELPP_SYSLOG</code>：允许使用系统日志（Unix 世界的 syslog）来记录日志</li>\n<li><code>ELPP_STL_LOGGING</code>：允许在日志里输出常用的标准容器对象（<code>std::vector</code> 等）</li>\n<li><code>ELPP_QT_LOGGING</code>：允许在日志里输出 Qt 的核心对象（<code>QVector</code> 等）</li>\n<li><code>ELPP_BOOST_LOGGING</code>：允许在日志里输出某些 Boost 的容器（<code>boost::container::vector</code> 等）</li>\n<li><code>ELPP_WXWIDGETS_LOGGING</code>：允许在日志里输出某些 wxWidgets 的模板对象（<code>wxVector</code> 等）</li>\n</ul><p>可以看到，Easylogging++ 的功能还是很丰富很全面的。</p><h3>开始使用 Easylogging++</h3><p>虽说 Easylogging++ 的功能非常多，但开始使用它毫不困难。我们从一个简单的例子开始看一下：</p><pre><code class=\"language-c++\">#include \"easylogging++.h\"\nINITIALIZE_EASYLOGGINGPP\n\nint main()\n{\n  LOG(INFO) &lt;&lt; \"My first info log\";\n}\n</code></pre><p>编译链接的时候要把 easylogging++.cc 放进去。比如，使用 GCC 的话，命令行会像：</p><blockquote>\n<p><code>g++ -std=c++17 test.cpp easylogging++.cc</code></p>\n</blockquote><p>运行生成的可执行程序，你就可以看到结果输出到终端和 myeasylog.log 文件里，包含了日期、时间、级别、日志名称和日志信息，形如：</p><blockquote>\n<p><code>2020-01-25 20:47:50,990 INFO [default] My first info log</code></p>\n</blockquote><p>如果你对上面用到的宏感到好奇的话， <code>INITIALIZE_EASYLOGGINGPP</code> 展开后（可以用编译器的 <code>-E</code> 参数查看宏展开后的结果）是定义了 Easylogging++ 使用到的全局对象，而 <code>LOG(INFO)</code> 则是 Info 级别的日志记录器，同时传递了文件名、行号、函数名等日志需要的信息。</p><h3>使用 Unicode</h3><p>如果你在 Windows 上，那有一个复杂性就是是否使用“Unicode”的问题（<a href=\"https://time.geekbang.org/column/article/179357\">[第 11 讲]</a> 中讨论了）。就我们日志输出而言，启用 Unicode 支持的好处是：</p><ul>\n<li>可以使用宽字符来输出</li>\n<li>日志文件的格式是 UTF-8，而不是传统的字符集，只能支持一种文字</li>\n</ul><p>要启用 Unicode 支持，你需要定义宏 <code>ELPP_UNICODE</code>，并确保程序中有对标准输出进行区域或格式设置（如<a href=\"https://time.geekbang.org/column/article/179357\">[第 11 讲]</a> 中所述，需要进行设置才能输出含非 ASCII 字符的宽字符串）。下面的程序给出了一个简单的示例：</p><pre><code class=\"language-c++\">#ifdef _WIN32\n#include &lt;fcntl.h&gt;\n#include &lt;io.h&gt;\n#else\n#include &lt;locale&gt;\n#endif\n#include \"easylogging++.h\"\nINITIALIZE_EASYLOGGINGPP\n\nint main()\n{\n#ifdef _WIN32\n  _setmode(_fileno(stdout),\n           _O_WTEXT);\n#else\n  using namespace std;\n  locale::global(locale(\"\"));\n  wcout.imbue(locale());\n#endif\n\n  LOG(INFO) &lt;&lt; L\"测试 test\";\n  LOG(INFO)\n    &lt;&lt; \"Narrow ASCII always OK\";\n}\n</code></pre><p>编译使用的命令行是：</p><blockquote>\n<p><code>cl /EHsc /DELPP_UNICODE test.cpp easylogging++.cc</code></p>\n</blockquote><h3>改变输出文件名</h3><p>Easylogging++ 的缺省输出日志名为 myeasylog.log，这在大部分情况下都是不适用的。我们可以直接在命令行上使用宏定义来修改（当然，稍大点的项目就应该放在项目的编译配置文件里了，如 Makefile）。比如，要把输出文件名改成 test.log，我们只需要在命令行上加入下面的选项就可以：</p><blockquote>\n<p><code>-DELPP_DEFAULT_LOG_FILE=\\\"test.log\\\"</code></p>\n</blockquote><h3>使用配置文件设置日志选项</h3><p>不过，对于日志文件名称这样的设置，使用配置文件是一个更好的办法。Easylogging++ 库自己支持配置文件，我也推荐使用一个专门的配置文件，并让 Easylogging++ 自己来加载配置文件。我自己使用的配置文件是这个样子的：</p><pre><code>* GLOBAL:\n   FORMAT               =  &quot;%datetime{%Y-%M-%d %H:%m:%s.%g} %levshort %msg&quot;\n   FILENAME             =  &quot;test.log&quot;\n   ENABLED              =  true\n   TO_FILE              =  true     ## 输出到文件\n   TO_STANDARD_OUTPUT   =  true     ## 输出到标准输出\n   SUBSECOND_PRECISION  =  6        ## 秒后面保留 6 位\n   MAX_LOG_FILE_SIZE    =  2097152  ## 最大日志文件大小设为 2MB\n   LOG_FLUSH_THRESHOLD  =  10       ## 写 10 条日志刷新一次缓存\n* DEBUG:\n   FORMAT               = &quot;%datetime{%Y-%M-%d %H:%m:%s.%g} %levshort [%fbase:%line] %msg&quot;\n   TO_FILE              =  true\n   TO_STANDARD_OUTPUT   =  false    ## 调试日志不输出到标准输出\n</code></pre><p>这个配置文件里有两节：第一节是全局（global）配置，配置了适用于所有级别的日志选项；第二节是专门用于调试（debug）级别的配置（你当然也可以自己配置 fatal、error、warning 等其他级别）。</p><p>假设这个配置文件的名字是 log.conf，我们在代码中可以这样使用：</p><pre><code class=\"language-c++\">#include \"easylogging++.h\"\nINITIALIZE_EASYLOGGINGPP\n\nint main()\n{\n  el::Configurations conf{\n    \"log.conf\"};\n  el::Loggers::\n    reconfigureAllLoggers(conf);\n  LOG(DEBUG) &lt;&lt; \"A debug message\";\n  LOG(INFO) &lt;&lt; \"An info message\";\n}\n</code></pre><p>注意编译命令行上应当加上 <code>-DELPP_NO_DEFAULT_LOG_FILE</code>，否则 Easylogging++ 仍然会生成缺省的日志文件。</p><p>运行生成的可执行程序，我们会在终端上看到一条信息，但在日志文件里则可以看到两条信息。如下所示：</p><blockquote>\n<p><code>2020-01-26 12:54:58.986739 D [test.cpp:11] A debug message</code><br>\n<code>2020-01-26 12:54:58.987444 I An info message</code></p>\n</blockquote><p>我们也可以明确看到我们在配置文件中定义的日志格式生效了，包括：</p><ul>\n<li>日期时间的格式使用“.”分隔秒的整数和小数部分，并且小数部分使用 6 位</li>\n<li>日志级别使用单个大写字母</li>\n<li>对于普通的日志，后面直接跟日志的信息；对于调试日志，则会输出文件名和行号</li>\n</ul><p>我们现在只需要修改配置文件，就能调整日志格式、决定输出和不输出哪些日志了。此外，我也推荐在编译时定义宏 <code>ELPP_DEBUG_ASSERT_FAILURE</code>，这样能在找不到配置文件时直接终止程序，而不是继续往下执行、在终端上以缺省的方式输出日志了。</p><h3>性能跟踪</h3><p>Easylogging++ 可以用来在日志中记录程序执行的性能数据。这个功能还是很方便的。下面的代码展示了用于性能跟踪的三个宏的用法：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include \"easylogging++.h\"\nINITIALIZE_EASYLOGGINGPP\n\nvoid foo()\n{\n  TIMED_FUNC(timer);\n  LOG(WARNING) &lt;&lt; \"A warning message\";\n}\n\nvoid bar()\n{\n  using namespace std::literals;\n  TIMED_SCOPE(timer1, \"void bar()\");\n  foo();\n  foo();\n  TIMED_BLOCK(timer2, \"a block\") {\n    foo();\n    std::this_thread::sleep_for(100us);\n  }\n}\n\nint main()\n{\n  el::Configurations conf{\n    \"log.conf\"};\n  el::Loggers::\n    reconfigureAllLoggers(conf);\n  bar();\n}\n</code></pre><p>简单说明一下：</p><ul>\n<li><code>TIMED_FUNC</code> 接受一个参数，是用于性能跟踪的对象的名字。它能自动产生函数的名称。示例中的 <code>TIMED_FUNC</code> 和 <code>TIMED_SCOPE</code> 的作用是完全相同的。</li>\n<li><code>TIMED_SCOPE</code> 接受两个参数，分别是用于性能跟踪的对象的名字，以及用于记录的名字。如果你不喜欢 <code>TIMED_FUNC</code> 生成的函数名字，可以用 <code>TIMED_SCOPE</code> 来代替。</li>\n<li><code>TIMED_BLOCK</code> 用于对下面的代码块进行性能跟踪，参数形式和 <code>TIMED_SCOPE</code> 相同。</li>\n</ul><p>在编译含有上面三个宏的代码时，需要定义宏 <code>ELPP_FEATURE_PERFORMANCE_TRACKING</code>。你一般也应该定义 <code>ELPP_PERFORMANCE_MICROSECONDS</code>，来获取微秒级的精度。下面是定义了上面两个宏编译的程序的某次执行的结果：</p><blockquote>\n<p><code>2020-01-26 15:00:11.99736 W A warning message</code><br>\n<code>2020-01-26 15:00:11.99748 I Executed [void foo()] in [110 us]</code><br>\n<code>2020-01-26 15:00:11.99749 W A warning message</code><br>\n<code>2020-01-26 15:00:11.99750 I Executed [void foo()] in [5 us]</code><br>\n<code>2020-01-26 15:00:11.99750 W A warning message</code><br>\n<code>2020-01-26 15:00:11.99751 I Executed [void foo()] in [4 us]</code><br>\n<code>2020-01-26 15:00:11.99774 I Executed [a block] in [232 us]</code><br>\n<code>2020-01-26 15:00:11.99776 I Executed [void bar()] in [398 us]</code></p>\n</blockquote><p>不过需要注意，由于 Easylogging++ 本身有一定开销，且开销有一定的不确定性，这种方式只适合颗粒度要求比较粗的性能跟踪。</p><p>性能跟踪产生的日志级别固定为 Info。性能跟踪本身可以在配置文件里的 GLOBAL 节下用 <code>PERFORMANCE_TRACKING = false</code> 来关闭。当然，关闭所有 Info 级别的输出也能达到关闭性能跟踪的效果。</p><h3>记录崩溃日志</h3><p>在 GCC 和 Clang 下，通过定义宏 <code>ELPP_FEATURE_CRASH_LOG</code> 我们可以启用崩溃日志。此时，当程序崩溃时，Easylogging++ 会自动在日志中记录程序的调用栈信息。通过记录下的信息，再利用 <code>addr2line</code> 这样的工具，我们就能知道是程序的哪一行引发了崩溃。下面的代码可以演示这一行为：</p><pre><code class=\"language-c++\">#include \"easylogging++.h\"\nINITIALIZE_EASYLOGGINGPP\n\nvoid boom()\n{\n  char* ptr = nullptr;\n  *ptr = '\\0';\n}\n\nint main()\n{\n  el::Configurations conf{\n    \"log.conf\"};\n  el::Loggers::\n    reconfigureAllLoggers(conf);\n  boom();\n}\n</code></pre><p>你可以自己尝试编译运行一下，就会在终端和日志文件中看到崩溃的信息了。</p><p>使用 macOS 的需要特别注意一下：由于缺省方式产生的可执行文件是位置独立的，系统每次加载程序会在不同的地址，导致无法通过地址定位到程序行。在编译命令行尾部加上 <code>-Wl,-no_pie</code> 可以解决这个问题。</p><h3>其他</h3><p>Easylogging++ 还有很多其他功能，我就不再一一讲解了。有些你简单试一下就可以用起来的。对于 <code>ELPP_STL_LOGGING</code>，你也可以在包含 easylogging++.h 之前包含我的 output_container.h，可以达到类似的效果。</p><p>此外，Easylogging++ 的 samples 目录下有不少例子，可以用作参考。比如常见的日志文件切换功能，在 Easylogging++ 里实现是需要稍微写一点代码的：Easylogging++ 会在文件满的时候调用你之前注册的回调函数，而你需要在回调函数里对老的日志文件进行重命名、备份之类的工作，samples/STL/roll-out.cpp 则提供了最简单的实现参考。</p><p>注意我使用的都是全局的日志记录器，但 Easylogging++ 允许你使用多个不同的日志记录器，用于（比如）不同的模块或功能。你如果需要这样的功能的话，也请你自行查阅文档了。</p><h2>spdlog</h2><p>跟 Easylogging++ 比起来，spdlog 要新得多了：前者是 2012 年开始的项目，而后者是 2014 年开始的。我在 2016 年末开始在项目中使用 Easylogging++ 时，Easylogging++ 的版本是 9.85 左右，而 spdlog 大概是 0.11，成熟度和热度都不那么高。</p><p>整体上，spdlog 也确实感觉要新很多。项目自己提到的功能点是：</p><ul>\n<li>非常快（性能是其主要目标）</li>\n<li>只需要头文件即可使用</li>\n<li>没有其他依赖</li>\n<li>跨平台</li>\n<li>有单线程和多线程的日志记录器</li>\n<li>日志文件旋转切换</li>\n<li>每日日志文件</li>\n<li>终端日志输出</li>\n<li>可选异步日志</li>\n<li>多个日志级别</li>\n<li>通过用户自定义式样来定制输出格式</li>\n</ul><h3>开始使用 spdlog</h3><p>跟 Easylogging++ 的例子相对应，我们以最简单的日志输出开头：</p><pre><code class=\"language-c++\">#include \"spdlog/spdlog.h\"\n\nint main()\n{\n  spdlog::info(\"My first info log\");\n}\n</code></pre><p>代码里看不到的是，输出结果中的“info”字样是彩色的，方便快速识别日志的级别。这个功能在 Windows、Linux 和 macOS 上都能正常工作，对用户还是相当友好的。不过，和 Easylogging++ 缺省就会输出到文件中不同，spdlog 缺省只是输出到终端而已。</p><p>你也许从代码中已经注意到，spdlog 不是使用 IO 流风格的输出了。它采用跟 Python 里的 <code>str.format</code> 一样的方式，使用大括号——可选使用序号和格式化要求——来对参数进行格式化。下面是一个很简单的例子：</p><pre><code class=\"language-c++\">  spdlog::warn(\n    \"Message with arg {}\", 42);\n  spdlog::error(\n    \"{0:d}, {0:x}, {0:o}, {0:b}\",\n    42);\n</code></pre><p>输出会像下面这样：</p><blockquote>\n<p><code>[2020-01-26 17:20:08.355] [warning] Message with arg 42</code><br>\n<code>[2020-01-26 17:20:08.355] [error] 42, 2a, 52, 101010</code></p>\n</blockquote><p>事实上，这就是 C++20 的 <code>format</code> 的风格了——spdlog 就是使用了一个 <code>format</code> 的库实现 fmt <span class=\"orange\">[3]</span>。</p><h3>设置输出文件</h3><p>在 spdlog 里，要输出文件得打开专门的文件日志记录器，下面的例子展示了最简单的用法：</p><pre><code class=\"language-c++\">#include \"spdlog/spdlog.h\"\n#include \"spdlog/sinks/basic_file_sink.h\"\n\nint main()\n{\n  auto file_logger =\n    spdlog::basic_logger_mt(\n      \"basic_logger\",\n      \"test.log\");\n  spdlog::set_default_logger(\n    file_logger);\n  spdlog::info(\"Into file: {1} {0}\",\n               \"world\", \"hello\");\n}\n</code></pre><p>执行之后，终端上没有任何输出，但 test.log 文件里就会增加如下的内容：</p><blockquote>\n<p><code>[2020-01-26 17:47:37.864] [basic_logger] [info] Into file: hello world</code></p>\n</blockquote><p>估计你立即会想问，那我想同时输出到终端和文件，该怎么办呢？</p><p>答案是你可以设立一个日志记录器，让它有两个（或更多个）日志槽（sink）即可。示例代码如下：</p><pre><code class=\"language-c++\">#include &lt;memory&gt;\n#include \"spdlog/spdlog.h\"\n#include \"spdlog/sinks/basic_file_sink.h\"\n#include \"spdlog/sinks/stdout_color_sinks.h\"\n\nusing namespace std;\nusing namespace spdlog::sinks;\n\nvoid set_multi_sink()\n{\n  auto console_sink = make_shared&lt;\n    stdout_color_sink_mt&gt;();\n  console_sink-&gt;set_level(\n    spdlog::level::warn);\n  console_sink-&gt;set_pattern(\n    \"%H:%M:%S.%e %^%L%$ %v\");\n\n  auto file_sink =\n    make_shared&lt;basic_file_sink_mt&gt;(\n      \"test.log\");\n  file_sink-&gt;set_level(\n    spdlog::level::trace);\n  file_sink-&gt;set_pattern(\n    \"%Y-%m-%d %H:%M:%S.%f %L %v\");\n\n  auto logger =\n    shared_ptr&lt;spdlog::logger&gt;(\n      new spdlog::logger(\n        \"multi_sink\",\n        {console_sink, file_sink}));\n  logger-&gt;set_level(\n    spdlog::level::debug);\n  spdlog::set_default_logger(\n    logger);\n}\n\nint main()\n{\n  set_multi_sink();\n  spdlog::warn(\n    \"this should appear in both \"\n    \"console and file\");\n  spdlog::info(\n    \"this message should not \"\n    \"appear in the console, only \"\n    \"in the file\");\n}\n</code></pre><p>大致说明一下：</p><ul>\n<li><code>console_sink</code> 是一个指向 <code>stdout_color_sink_mt</code> 的智能指针，我们设定让它只显示警告级别及以上的日志信息，并把输出式样调整成带毫秒的时间、有颜色的短级别以及信息本身。</li>\n<li><code>file_sink</code> 是一个指向 <code>basic_file_sink_mt</code> 的智能指针，我们设定让它显示跟踪级别及以上（也就是所有级别了）的日志信息，并把输出式样调整成带微秒的日期时间、短级别以及信息本身。</li>\n<li>然后我们创建了日志记录器，让它具有上面的两个日志槽。注意这儿的两个细节：1. 这儿的接口普遍使用 <code>shared_ptr</code>；2. 由于 <code>make_shared</code> 在处理 <code>initializer_list</code> 上的缺陷，对 <code>spdlog::logger</code> 的构造只能直接调用 <code>shared_ptr</code> 的构造函数，而不能使用 <code>make_shared</code>，否则编译会出错。</li>\n<li>最后我们调用了 <code>spdlog::set_default_logger</code> 把缺省的日志记录器设置成刚创建的对象。这样，之后的日志缺省就会记录到这个新的日志记录器了（我们当然也可以手工调用这个日志记录器的 <code>critical</code>、<code>error</code>、<code>warn</code> 等日志记录方法）。</li>\n</ul><p>在某次运行之后，我的终端上出现了：</p><blockquote>\n<p><code>20:44:45.086 W this should appear in both console and file</code></p>\n</blockquote><p>而 test.log 文件中则增加了：</p><blockquote>\n<p><code>2020-01-26 20:44:45.086524 W this should appear in both console and file</code><br>\n<code>2020-01-26 20:44:45.087174 I this message should not appear in the console, only in the file</code></p>\n</blockquote><p>跟 Easylogging++ 相比，我们现在看到了 spdlog 也有复杂的一面。两者在输出式样的灵活性上也有不同的选择：Easylogging++ 对不同级别的日志可采用不同的式样，而 spdlog 对不同的日志槽可采用不同的式样。</p><h3>日志文件切换</h3><p>在 Easylogging++ 里实现日志文件切换是需要写代码的，而且完善的多文件切换代码需要写上几十行代码才能实现。这项工作在 spdlog 则是超级简单的，因为 spdlog 直接提供了一个实现该功能的日志槽。把上面的例子改造成带日志文件切换我们只需要修改两处：</p><pre><code class=\"language-c++\">#include \"spdlog/sinks/rotating_file_sink.h\"\n// 替换 basic_file_sink.h\n…\n  auto file_sink = make_shared&lt;\n    rotating_file_sink_mt&gt;(\n    \"test.log\", 1048576 * 5, 3);\n  // 替换 basic_file_sink_mt，文件大\n  // 小为 5MB，一共保留 3 个日志文件\n</code></pre><p>这就非常简单好用了。</p><h3>适配用户定义的流输出</h3><p>虽然 spdlog 缺省不支持容器的输出，但是，它是可以和用户提供的流 <code>&lt;&lt;</code> 运算符协同工作的。如果我们要输出普通容器的话，我们只需要在代码开头加入：</p><pre><code class=\"language-c++\">#include \"output_container.h\"\n#include \"spdlog/fmt/ostr.h\"\n</code></pre><p>前一行包含了我们用于容器输出的代码，后一行包含了 spdlog 使用 ostream 来输出对象的能力。注意此处包含的顺序是重要的：spdlog 必须能看到用户的 <code>&lt;&lt;</code> 的定义。在有了这两行之后，我们就可以像下面这样写代码了：</p><pre><code class=\"language-c++\">vector&lt;int&gt; v;\n// …\nspdlog::info(\n  \"Content of vector: {}\", v);\n</code></pre><h3>只用头文件吗？</h3><p>使用 spdlog 可以使用只用头文件的方式，也可以使用预编译的方式。只用头文件的编译速度较慢：我的机器上使用预编译方式构建第一个例子需要一秒多，而只用头文件的方式需要五秒多（Clang 的情况；GCC 耗时要更长）。因此正式使用的话，我还是推荐你使用预编译、安装的方式。</p><p>在安装了库后，编译时需额外定义一个宏，在命令行上要添加库名。以 GCC 为例，命令行会像下面这个样子：</p><blockquote>\n<p><code>g++ -std=c++17 -DSPDLOG_COMPILED_LIB test.cpp -lspdlog</code></p>\n</blockquote><h3>其他</h3><p>刚才介绍的还只是 spdlog 的部分功能。你如果对使用这个库感兴趣的话，应该查阅文档来获得进一步的信息。我这儿觉得下面这些功能点值得提一下：</p><ul>\n<li>可以使用多个不同的日志记录器，用于不同的模块或功能。</li>\n<li>可以使用异步日志，减少记日志时阻塞的可能性。</li>\n<li>通过 <code>spdlog::to_hex</code> 可以方便地在日志里输出二进制信息。</li>\n<li>可用的日志槽还有 syslog、systemd、Android、Windows 调试输出等；扩展新的日志槽较为容易。</li>\n</ul><h2>内容小结</h2><p>今天我们介绍了两个不同的日志库，Easylogging++ 和 spdlog。它们在功能和实现方式上有很大的不同，建议你根据自己的实际需要来进行选择。</p><p>我目前对新项目的推荐是优先选择 spdlog：仅在你需要某个 Easylogging++ 提供、而 spdlog 不提供的功能时才选择 Easylogging++。</p><p>当然，C++ 的日志库远远不止这两个：我挑选的是我觉得比较好的和有实际使用经验的。其他可选择的日志库至少还有 Boost.Log <span class=\"orange\">[4]</span>、g3log <span class=\"orange\">[5]</span>、NanoLog <span class=\"orange\">[6]</span> 等（Log for C++ 接口有着 Java 式的啰嗦，且感觉有点“年久失修”，我明确不推荐）。在严肃的项目里，选择哪个日志库是值得认真比较和评估一下的。</p><h2>课后思考</h2><p>请对比一下 Easylogging++ 和 spdlog，考虑以下两个问题：</p><ol>\n<li>Easylogging++ 更多地使用了编译时的行为定制，而 spdlog 主要通过面向对象的方式在运行时修改日志的行为。你觉得哪种更好？为什么？</li>\n<li>Easylogging++ 使用了 IO 流的方式，而 spdlog 使用了 <code>std::format</code> 的方式。你更喜欢哪种？为什么？</li>\n</ol><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Amrayn Web Services, easyloggingpp. <a href=\"https://github.com/amrayn/easyloggingpp\">https://github.com/amrayn/easyloggingpp</a> </span></p><p><span class=\"reference\">[2] Gabi Melman, spdlog. <a href=\"https://github.com/gabime/spdlog\">https://github.com/gabime/spdlog</a> </span></p><p><span class=\"reference\">[3] Victor Zverovich, fmt. <a href=\"https://github.com/fmtlib/fmt\">https://github.com/fmtlib/fmt</a> </span></p><p><span class=\"reference\">[4] Andrey Semashev, Boost.Log v2. <a href=\"https://www.boost.org/doc/libs/release/libs/log/doc/html/index.html\">https://www.boost.org/doc/libs/release/libs/log/doc/html/index.html</a> </span></p><p><span class=\"reference\">[5] Kjell Hedström, g3log. <a href=\"https://github.com/KjellKod/g3log\">https://github.com/KjellKod/g3log</a> </span></p><p><span class=\"reference\">[6] Stanford University, NanoLog. <a href=\"https://github.com/PlatformLab/NanoLog\">https://github.com/PlatformLab/NanoLog</a> </span></p>","neighbors":{"left":{"article_title":"25 | 两个单元测试库：C++里如何进行单元测试?","id":191714},"right":{"article_title":"27 | C++ REST SDK：使用现代C++开发网络应用","id":193523}}},{"article_id":193523,"article_title":"27 | C++ REST SDK：使用现代C++开发网络应用","article_content":"<p>你好，我是吴咏炜。</p><p>在实战篇，我们最后要讲解的一个库是 C++ REST SDK（也写作 cpprestsdk）<span class=\"orange\">[1]</span>，一个支持 HTTP 协议 <span class=\"orange\">[2]</span>、主要用于 RESTful <span class=\"orange\">[3]</span> 接口开发的 C++ 库。</p><h2>初识 C++ REST SDK</h2><p>向你提一个问题，你认为用多少行代码可以写出一个类似于 curl <span class=\"orange\">[4]</span> 的 HTTP 客户端？</p><p>使用 C++ REST SDK 的话，答案是，只需要五十多行有效代码（即使是适配到我们目前的窄小的手机屏幕上）。请看：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#ifdef _WIN32\n#include &lt;fcntl.h&gt;\n#include &lt;io.h&gt;\n#endif\n#include &lt;cpprest/http_client.h&gt;\n\nusing namespace utility;\nusing namespace web::http;\nusing namespace web::http::client;\nusing std::cerr;\nusing std::endl;\n\n#ifdef _WIN32\n#define tcout std::wcout\n#else\n#define tcout std::cout\n#endif\n\nauto get_headers(http_response resp)\n{\n  auto headers = resp.to_string();\n  auto end =\n    headers.find(U(\"\\r\\n\\r\\n\"));\n  if (end != string_t::npos) {\n    headers.resize(end + 4);\n  };\n  return headers;\n}\n\nauto get_request(string_t uri)\n{\n  http_client client{uri};\n  // 用 GET 方式发起一个客户端请求\n  auto request =\n    client.request(methods::GET)\n      .then([](http_response resp) {\n        if (resp.status_code() !=\n            status_codes::OK) {\n          // 不 OK，显示当前响应信息\n          auto headers =\n            get_headers(resp);\n          tcout &lt;&lt; headers;\n        }\n        // 进一步取出完整响应\n        return resp\n          .extract_string();\n      })\n      .then([](string_t str) {\n        // 输出到终端\n        tcout &lt;&lt; str;\n      });\n  return request;\n}\n\n#ifdef _WIN32\nint wmain(int argc, wchar_t* argv[])\n#else\nint main(int argc, char* argv[])\n#endif\n{\n#ifdef _WIN32\n  _setmode(_fileno(stdout),\n           _O_WTEXT);\n#endif\n\n  if (argc != 2) {\n    cerr &lt;&lt; \"A URL is needed\\n\";\n    return 1;\n  }\n\n  // 等待请求及其关联处理全部完成\n  try {\n    auto request =\n      get_request(argv[1]);\n    request.wait();\n  }\n  // 处理请求过程中产生的异常\n  catch (const std::exception&amp; e) {\n    cerr &lt;&lt; \"Error exception: \"\n         &lt;&lt; e.what() &lt;&lt; endl;\n    return 1;\n  }\n}\n</code></pre><!-- [[[read_end]]] --><p>这个代码有点复杂，需要讲解一下：</p><ul>\n<li>第 14–18 行，我们根据平台来定义 <code>tcout</code>，确保多语言的文字能够正确输出。</li>\n<li>第 20–29 行，我们定义了 <code>get_headers</code>，来从 <code>http_response</code> 中取出头部的字符串表示。</li>\n<li>第 36 行，构造了一个客户端请求，并使用 <code>then</code> 方法串联了两个下一步的动作。<code>http_client::request</code> 的返回值是 <code>pplx::task&lt;http_response&gt;</code>。<code>then</code> 是 <code>pplx::task</code> 类模板的成员函数，参数是能接受其类型参数对象的函数对象。除了最后一个 <code>then</code> 块，其他每个 <code>then</code> 里都应该返回一个  <code>pplx::task</code>，而 <code>task</code> 的内部类型就是下一个 <code>then</code> 块里函数对象接受的参数的类型。</li>\n<li>第 37 行开始，是第一段异步处理代码。参数类型是 <code>http_response</code>——因为<code>http_client::request</code> 的返回值是 <code>pplx::task&lt;http_response&gt;</code>。代码中判断如果响应的 HTTP 状态码不是 200 OK，就会显示响应头来帮助调试。然后，进一步取出所有的响应内容（可能需要进一步的异步处理，等待后续的 HTTP 响应到达）。</li>\n<li>第 49 行开始，是第二段异步处理代码。参数类型是 <code>string_t</code>——因为上一段 <code>then</code> 块的返回值是 <code>pplx::task&lt;string_t&gt;</code>。代码中就是简单地把需要输出的内容输出到终端。</li>\n<li>第 56–60 行，我们根据平台来定义合适的程序入口，确保命令行参数的正确处理。</li>\n<li>第 62–65 行，在 Windows 上我们把标准输出设置成宽字符模式，来确保宽字符（串）能正确输出（参考<a href=\"https://time.geekbang.org/column/article/179357\">[第 11 讲]</a> ）。注意 <code>string_t</code> 在 Windows 上是 <code>wstring</code>，在其他平台上是 <code>string</code>。</li>\n<li>第 72–83 行，如注释所言，产生 HTTP 请求、等待 HTTP 请求完成，并处理相关的异常。</li>\n</ul><p>整体而言，这个代码还是很简单的，虽然这种代码风格，对于之前没有接触过这种函数式编程风格的人来讲会有点奇怪——这被称作持续传递风格（continuation-passing style），显式地把上一段处理的结果传递到下一个函数中。这个代码已经处理了 Windows 环境和 Unix 环境的差异，底下是相当复杂的。</p><p>另外提醒一下，在 Windows 上如果你把源代码存成 UTF-8 的话，需要确保文件以 BOM 字符打头。Windows 的编辑器通常缺省就会做到；在 Vim 里，可以通过 <code>set bomb</code> 命令做到这一点。</p><h2>安装和编译</h2><p>上面的代码本身虽然简单，但要把它编译成可执行文件比我们之前讲的代码都要复杂——C++ REST SDK 有外部依赖，在 Windows 上和 Unix 上还不太一样。它的编译和安装也略复杂，如果你没有这方面的经验的话，建议尽量使用平台推荐的二进制包的安装方式。</p><p>由于其依赖较多，使用它的编译命令行也较为复杂。正式项目中绝对是需要使用项目管理软件的（如 cmake）。此处，我给出手工编译的典型命令行，仅供你尝试编译上面的例子作参考。</p><p>Windows MSVC：</p><blockquote>\n<p><code>cl /EHsc /std:c++17 test.cpp cpprest.lib zlib.lib libeay32.lib ssleay32.lib winhttp.lib httpapi.lib bcrypt.lib crypt32.lib advapi32.lib gdi32.lib user32.lib</code></p>\n</blockquote><p>Linux GCC：</p><blockquote>\n<p><code>g++ -std=c++17 -pthread test.cpp -lcpprest -lcrypto -lssl -lboost_thread -lboost_chrono -lboost_system</code></p>\n</blockquote><p>macOS Clang：</p><blockquote>\n<p><code>clang++ -std=c++17 test.cpp -lcpprest -lcrypto -lssl -lboost_thread-mt -lboost_chrono-mt</code></p>\n</blockquote><h2>概述</h2><p>有了初步印象之后，现在我们可以回过头看看 C++ REST SDK 到底是什么了。它是一套用来开发 HTTP 客户端和服务器的现代异步 C++ 代码库，支持以下特性（随平台不同会有所区别）：</p><ul>\n<li>HTTP 客户端</li>\n<li>HTTP 服务器</li>\n<li>任务</li>\n<li>JSON</li>\n<li>URI</li>\n<li>异步流</li>\n<li>WebSocket 客户端</li>\n<li>OAuth 客户端</li>\n</ul><p>上面的例子里用到了 HTTP 客户端、任务和 URI（实际上是由 <code>string_t</code> 隐式构造了 <code>uri</code>），我们下面再介绍一下异步流、JSON 和 HTTP 服务器。</p><h2>异步流</h2><p>C++ REST SDK 里实现了一套异步流，能够实现对文件的异步读写。下面的例子展示了我们如何把网络请求的响应异步地存储到文件 results.html 中：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#ifdef _WIN32\n#include &lt;fcntl.h&gt;\n#include &lt;io.h&gt;\n#endif\n#include &lt;stddef.h&gt;\n#include &lt;cpprest/http_client.h&gt;\n#include &lt;cpprest/filestream.h&gt;\n\nusing namespace utility;\nusing namespace web::http;\nusing namespace web::http::client;\nusing namespace concurrency::streams;\nusing std::cerr;\nusing std::endl;\n\n#ifdef _WIN32\n#define tcout std::wcout\n#else\n#define tcout std::cout\n#endif\n\nauto get_headers(http_response resp)\n{\n  auto headers = resp.to_string();\n  auto end =\n    headers.find(U(\"\\r\\n\\r\\n\"));\n  if (end != string_t::npos) {\n    headers.resize(end + 4);\n  };\n  return headers;\n}\n\nauto get_request(string_t uri)\n{\n  http_client client{uri};\n  // 用 GET 方式发起一个客户端请求\n  auto request =\n    client.request(methods::GET)\n      .then([](http_response resp) {\n        if (resp.status_code() ==\n            status_codes::OK) {\n          // 正常的话\n          tcout &lt;&lt; U(\"Saving...\\n\");\n          ostream fs;\n          fstream::open_ostream(\n            U(\"results.html\"),\n            std::ios_base::out |\n              std::ios_base::trunc)\n            .then(\n              [&amp;fs,\n               resp](ostream os) {\n                fs = os;\n                // 读取网页内容到流\n                return resp.body()\n                  .read_to_end(\n                    fs.streambuf());\n              })\n            .then(\n              [&amp;fs](size_t size) {\n                // 然后关闭流\n                fs.close();\n                tcout\n                  &lt;&lt; size\n                  &lt;&lt; U(\" bytes \"\n                       \"saved\\n\");\n              })\n            .wait();\n        } else {\n          // 否则显示当前响应信息\n          auto headers =\n            get_headers(resp);\n          tcout &lt;&lt; headers;\n          tcout\n            &lt;&lt; resp.extract_string()\n                 .get();\n        }\n      });\n  return request;\n}\n\n#ifdef _WIN32\nint wmain(int argc, wchar_t* argv[])\n#else\nint main(int argc, char* argv[])\n#endif\n{\n#ifdef _WIN32\n  _setmode(_fileno(stdout),\n           _O_WTEXT);\n#endif\n\n  if (argc != 2) {\n    cerr &lt;&lt; \"A URL is needed\\n\";\n    return 1;\n  }\n\n  // 等待请求及其关联处理全部完成\n  try {\n    auto request =\n      get_request(argv[1]);\n    request.wait();\n  }\n  // 处理请求过程中产生的异常\n  catch (const std::exception&amp; e) {\n    cerr &lt;&lt; \"Error exception: \"\n         &lt;&lt; e.what() &lt;&lt; endl;\n  }\n}\n</code></pre><p>跟上一个例子比，我们去掉了原先的第二段处理统一输出的异步处理代码，但加入了一段嵌套的异步代码。有几个地方需要注意一下：</p><ul>\n<li>C++ REST SDK 的对象基本都是基于 <code>shared_ptr</code> 用引用计数实现的，因而可以轻松大胆地进行复制。</li>\n<li>虽然 <code>string_t</code> 在 Windows 上是 <code>wstring</code>，但文件流无论在哪个平台上都是以 UTF-8 的方式写入，符合目前的主流处理方式（<code>wofstream</code> 的行为跟平台和环境相关）。</li>\n<li><code>extract_string</code> 的结果这次没有传递到下一段，而是直接用 <code>get</code> 获得了最终结果（类似于<a href=\"https://time.geekbang.org/column/article/186689\">[第 19 讲]</a> 中的 <code>future</code>）。</li>\n</ul><p>这个例子的代码是基于 <a href=\"https://github.com/Microsoft/cpprestsdk/wiki/Getting-Started-Tutorial\">cpprestsdk 官方的例子</a>改编的。但我做的下面这些更动值得提一下：</p><ul>\n<li>去除了不必要的 <code>shared_ptr</code> 的使用。</li>\n<li><code>fstream::open_ostream</code> 缺省的文件打开方式是 <code>std::ios_base::out</code>，官方例子没有用 <code>std::ios_base::trunc</code>，导致不能清除文件中的原有内容。此处 C++ REST SDK 的 <code>file_stream</code> 行为跟标准 C++ 的 <code>ofstream</code> 是不一样的：后者缺省打开方式也是 <code>std::ios_base::out</code>，但此时文件内容<strong>会</strong>被自动清除。</li>\n<li>沿用我的前一个例子，先进行请求再打开文件流，而不是先打开文件流再发送网络请求，符合实际流程。</li>\n<li>这样做的一个结果就是 <code>then</code> 不完全是顺序的了，有嵌套，增加了复杂度，但展示了实际可能的情况。</li>\n</ul><h2>JSON 支持</h2><p>在基于网页的开发中，JSON <span class=\"orange\">[5]</span> 早已取代 XML 成了最主流的数据交换方式。REST 接口本身就是基于 JSON 的，自然，C++ REST SDK 需要对 JSON 有很好的支持。</p><p>JSON 本身可以在网上找到很多介绍的文章，我这儿就不多讲了。有几个 C++ 相关的关键点需要提一下：</p><ul>\n<li>JSON 的基本类型是空值类型、布尔类型、数字类型和字符串类型。其中空值类型和数字类型在 C++ 里是没有直接对应物的。数字类型在 C++ 里可能映射到 <code>double</code>，也可能是 <code>int32_t</code> 或 <code>int64_t</code>。</li>\n<li>JSON 的复合类型是数组（array）和对象（object）。JSON 数组像 C++ 的 <code>vector</code>，但每个成员的类型可以是任意 JSON 类型，而不像 <code>vector</code> 通常是同质的——所有成员属于同一类型。JSON 对象像 C++ 的 <code>map</code>，键类型为 JSON 字符串，值类型则为任意 JSON 类型。JSON 标准不要求对象的各项之间有顺序，不过，从实际项目的角度，我个人觉得保持顺序还是非常有用的。</li>\n</ul><p>如果你去搜索“c++ json”的话，还是可以找到一些不同的 JSON 实现的。功能最完整、名声最响的目前似乎是 nlohmann/json <span class=\"orange\">[6]</span>，而腾讯释出的 RapidJSON <span class=\"orange\">[7]</span> 则以性能闻名 <span class=\"orange\">[8]</span>。需要注意一下各个实现之间的区别：</p><ul>\n<li>nlohmann/json 不支持对 JSON 的对象（object）保持赋值顺序；RapidJSON 保持赋值顺序；C++ REST SDK 可选保持赋值顺序（通过 <code>web::json::keep_object_element_order</code> 和 <code>web::json::value::object</code> 的参数）。</li>\n<li>nlohmann/json 支持最友好的初始化语法，可以使用初始化列表和 JSON 字面量；C++ REST SDK 只能逐项初始化，并且一般应显式调用 <code>web::json::value</code> 的构造函数（接受布尔类型和字符串类型的构造函数有 <code>explicit</code> 标注）；RapidJSON 介于中间，不支持初始化列表和字面量，但赋值可以直接进行。</li>\n<li>nlohmann/json 和 C++ REST SDK 支持直接在用方括号 <code>[]</code> 访问不存在的 JSON 数组（array）成员时改变数组的大小；RapidJSON 的接口不支持这种用法，要向 JSON 数组里添加成员要麻烦得多。</li>\n<li>作为性能的代价，RapidJSON 里在初始化字符串值时，只会传递指针值；用户需要保证字符串在 JSON 值使用过程中的有效性。要复制字符串的话，接口要麻烦得多。</li>\n<li>RapidJSON 的 JSON 对象没有 <code>begin</code> 和 <code>end</code> 方法，因而无法使用标准的基于范围的 for 循环。总体而言，RapidJSON 的接口显得最特别、不通用。</li>\n</ul><p>如果你使用 C++ REST SDK 的其他功能，你当然也没有什么选择；否则，你可以考虑一下其他的 JSON 实现。下面，我们就只讨论 C++ REST SDK 里的 JSON 了。</p><p>在 C++ REST SDK 里，核心的类型是 <code>web::json::value</code>，这就对应到我前面说的“任意 JSON 类型”了。还是拿例子说话（改编自 RapidJSON 的例子）：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;assert.h&gt;\n#ifdef _WIN32\n#include &lt;fcntl.h&gt;\n#include &lt;io.h&gt;\n#endif\n#include &lt;cpprest/json.h&gt;\n\nusing namespace std;\nusing namespace utility;\nusing namespace web;\n\n#ifdef _WIN32\n#define tcout std::wcout\n#else\n#define tcout std::cout\n#endif\n\nint main()\n{\n#ifdef _WIN32\n  _setmode(_fileno(stdout),\n           _O_WTEXT);\n#endif\n\n  // 测试的 JSON 字符串\n  string_t json_str = U(R\"(\n    {\n      \"s\": \"你好，世界\",\n      \"t\": true,\n      \"f\": false,\n      \"n\": null,\n      \"i\": 123,\n      \"d\": 3.1416,\n      \"a\": [1, 2, 3]\n    })\");\n  tcout &lt;&lt; \"Original JSON:\"\n        &lt;&lt; json_str &lt;&lt; endl;\n\n  // 保持元素顺序并分析 JSON 字符串\n  json::keep_object_element_order(\n    true);\n  auto document =\n    json::value::parse(json_str);\n\n  // 遍历对象成员并输出类型\n  static const char* type_names[] =\n    {\n      \"Number\", \"Boolean\", \"String\",\n      \"Object\", \"Array\",   \"Null\",\n    };\n  for (auto&amp;&amp; value :\n       document.as_object()) {\n    tcout &lt;&lt; \"Type of member \"\n          &lt;&lt; value.first &lt;&lt; \" is \"\n          &lt;&lt; type_names[value.second\n                          .type()]\n          &lt;&lt; endl;\n  }\n\n  // 检查 document 是对象\n  assert(document.is_object());\n\n  // 检查 document[\"s\"] 是字符串\n  assert(document.has_field(U(\"s\")));\n  assert(\n    document[U(\"s\")].is_string());\n  tcout &lt;&lt; \"s = \"\n        &lt;&lt; document[U(\"s\")] &lt;&lt; endl;\n\n  // 检查 document[\"t\"] 是字符串\n  assert(\n    document[U(\"t\")].is_boolean());\n  tcout\n    &lt;&lt; \"t = \"\n    &lt;&lt; (document[U(\"t\")].as_bool()\n          ? \"true\"\n          : \"false\")\n    &lt;&lt; endl;\n\n  // 检查 document[\"f\"] 是字符串\n  assert(\n    document[U(\"f\")].is_boolean());\n  tcout\n    &lt;&lt; \"f = \"\n    &lt;&lt; (document[U(\"f\")].as_bool()\n          ? \"true\"\n          : \"false\")\n    &lt;&lt; endl;\n\n  // 检查 document[\"f\"] 是空值\n  tcout\n    &lt;&lt; \"n = \"\n    &lt;&lt; (document[U(\"n\")].is_null()\n          ? \"null\"\n          : \"?\")\n    &lt;&lt; endl;\n\n  // 检查 document[\"i\"] 是整数\n  assert(\n    document[U(\"i\")].is_number());\n  assert(\n    document[U(\"i\")].is_integer());\n  tcout &lt;&lt; \"i = \"\n        &lt;&lt; document[U(\"i\")] &lt;&lt; endl;\n\n  // 检查 document[\"d\"] 是浮点数\n  assert(\n    document[U(\"d\")].is_number());\n  assert(\n    document[U(\"d\")].is_double());\n  tcout &lt;&lt; \"d = \"\n        &lt;&lt; document[U(\"d\")] &lt;&lt; endl;\n\n  {\n    // 检查 document[\"a\"] 是数组\n    auto&amp; a = document[U(\"a\")];\n    assert(a.is_array());\n\n    // 测试读取数组元素并转换成整数\n    int y = a[0].as_integer();\n    (void)y;\n\n    // 遍历数组成员并输出\n    tcout &lt;&lt; \"a = \";\n    for (auto&amp;&amp; value :\n         a.as_array()) {\n      tcout &lt;&lt; value &lt;&lt; ' ';\n    }\n    tcout &lt;&lt; endl;\n  }\n\n  // 修改 document[\"i\"] 为长整数\n  {\n    uint64_t bignum = 65000;\n    bignum *= bignum;\n    bignum *= bignum;\n    document[U(\"i\")] = bignum;\n\n    assert(!document[U(\"i\")]\n              .as_number()\n              .is_int32());\n    assert(document[U(\"i\")]\n             .as_number()\n             .to_uint64() ==\n           bignum);\n    tcout &lt;&lt; \"i is changed to \"\n          &lt;&lt; document[U(\"i\")]\n          &lt;&lt; endl;\n  }\n\n  // 在数组里添加数值\n  {\n    auto&amp; a = document[U(\"a\")];\n    a[3] = 4;\n    a[4] = 5;\n    tcout &lt;&lt; \"a is changed to \"\n          &lt;&lt; document[U(\"a\")]\n          &lt;&lt; endl;\n  }\n\n  // 在 JSON 文档里添加布尔值：等号\n  // 右侧 json::value 不能省\n  document[U(\"b\")] =\n    json::value(true);\n\n  // 构造新对象，保持多个值的顺序\n  auto temp =\n    json::value::object(true);\n  // 在新对象里添加字符串：等号右侧\n  // json::value 不能省\n  temp[U(\"from\")] =\n    json::value(U(\"rapidjson\"));\n  temp[U(\"changed for\")] =\n    json::value(U(\"geekbang\"));\n\n  // 把对象赋到文档里；json::value\n  // 内部使用 unique_ptr，因而使用\n  // move 可以减少拷贝\n  document[U(\"adapted\")] =\n    std::move(temp);\n\n  // 完整输出目前的 JSON 对象\n  tcout &lt;&lt; document &lt;&lt; endl;\n}\n</code></pre><p>例子里我加了不少注释，应当可以帮助你看清 JSON 对象的基本用法了。唯一遗憾的是宏 <code>U</code>（类似于<a href=\"https://time.geekbang.org/column/article/179357\">[第 11 讲]</a> 里提到过的 <code>_T</code>）的使用有点碍眼：要确保代码在 Windows 下和 Unix 下都能工作，目前这还是必要的。</p><p>建议你测试一下这个例子。查看一下结果。</p><p>C++ REST SDK 里的 <code>http_request</code> 和 <code>http_response</code> 都对 JSON 有原生支持，如可以使用 <code>extract_json</code> 成员函数来异步提取 HTTP 请求或响应体中的 JSON 内容。</p><h2>HTTP 服务器</h2><p>前面我们提到了如何使用 C++ REST SDK 来快速搭建一个 HTTP 客户端。同样，我们也可以使用 C++ REST SDK 来快速搭建一个 HTTP 服务器。在三种主流的操作系统上，C++ REST SDK 的 <code>http_listener</code> 会通过调用 Boost.Asio <span class=\"orange\">[9]</span> 和操作系统的底层接口（IOCP、epoll 或 kqueue）来完成功能，向使用者隐藏这些细节、提供一个简单的编程接口。</p><p>我们将搭建一个最小的 REST 服务器，只能处理一个 sayHi 请求。客户端应当向服务器发送一个 HTTP 请求，URI 是：</p><blockquote>\n<p><code>/sayHi?name=…</code></p>\n</blockquote><p>“…”部分代表一个名字，而服务器应当返回一个 JSON 的回复，形如：</p><pre><code class=\"language-json\">{\"msg\": \"Hi, …!\"}\n</code></pre><p>这个服务器的有效代码行同样只有六十多行，如下所示：</p><pre><code class=\"language-c++\">#include &lt;exception&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#ifdef _WIN32\n#include &lt;fcntl.h&gt;\n#include &lt;io.h&gt;\n#endif\n#include &lt;cpprest/http_listener.h&gt;\n#include &lt;cpprest/json.h&gt;\n\nusing namespace std;\nusing namespace utility;\nusing namespace web;\nusing namespace web::http;\nusing namespace web::http::\n  experimental::listener;\n\n#ifdef _WIN32\n#define tcout std::wcout\n#else\n#define tcout std::cout\n#endif\n\nvoid handle_get(http_request req)\n{\n  auto&amp; uri = req.request_uri();\n\n  if (uri.path() != U(\"/sayHi\")) {\n    req.reply(\n      status_codes::NotFound);\n    return;\n  }\n\n  tcout &lt;&lt; uri::decode(uri.query())\n        &lt;&lt; endl;\n\n  auto query =\n    uri::split_query(uri.query());\n  auto it = query.find(U(\"name\"));\n  if (it == query.end()) {\n    req.reply(\n      status_codes::BadRequest,\n      U(\"Missing query info\"));\n    return;\n  }\n\n  auto answer =\n    json::value::object(true);\n  answer[U(\"msg\")] = json::value(\n    string_t(U(\"Hi, \")) +\n    uri::decode(it-&gt;second) +\n    U(\"!\"));\n\n  req.reply(status_codes::OK,\n            answer);\n}\n\nint main()\n{\n#ifdef _WIN32\n  _setmode(_fileno(stdout),\n           _O_WTEXT);\n#endif\n\n  http_listener listener(\n    U(\"http://127.0.0.1:8008/\"));\n  listener.support(methods::GET,\n                   handle_get);\n\n  try {\n    listener.open().wait();\n\n    tcout &lt;&lt; \"Listening. Press \"\n             \"ENTER to exit.\\n\";\n    string line;\n    getline(cin, line);\n\n    listener.close().wait();\n  }\n  catch (const exception&amp; e) {\n    cerr &lt;&lt; e.what() &lt;&lt; endl;\n    return 1;\n  }\n}\n</code></pre><p>如果你熟悉 HTTP 协议的话，上面的代码应当是相当直白的。只有少数几个细节我需要说明一下：</p><ul>\n<li>我们调用 <code>http_request::reply</code> 的第二个参数是 <code>json::value</code> 类型，这会让 HTTP 的内容类型（Content-Type）自动置成“application/json”。</li>\n<li><code>http_request::request_uri</code> 函数返回的是 <code>uri</code> 的引用，因此我用 <code>auto&amp;</code> 来接收。<code>uri::split_query</code> 函数返回的是一个普通的 <code>std::map</code>，因此我用 <code>auto</code> 来接收。</li>\n<li><code>http_listener::open</code> 和 <code>http_listener::close</code> 返回的是 <code>pplx::task&lt;void&gt;</code>；当这个任务完成时（<code>wait</code> 调用返回），表示 HTTP 监听器上的对应操作（打开或关闭）真正完成了。</li>\n</ul><p>运行程序，然后在另外一个终端里使用我们的第一个例子生成的可执行文件（或 curl）：</p><blockquote>\n<p><code>curl \"http://127.0.0.1:8008/sayHi?name=Peter\"</code></p>\n</blockquote><p>我们就应该会得到正确的结果：</p><blockquote>\n<p><code>{\"msg\":\"Hi, Peter!\"}</code></p>\n</blockquote><p>你也可以尝试把路径和参数写错，查看一下程序对出错的处理。</p><h2>关于线程的细节</h2><p>C++ REST SDK 使用异步的编程模式，使得写不阻塞的代码变得相当容易。不过，底层它是使用一个线程池来实现的——在 C++20 的协程能被使用之前，并没有什么更理想的跨平台方式可用。</p><p>C++ REST SDK 缺省会开启 40 个线程。在目前的实现里，如果这些线程全部被用完了，会导致系统整体阻塞。反过来，如果你只是用 C++ REST SDK 的 HTTP 客户端，你就不需要这么多线程。这个线程数量目前在代码里是可以控制的。比如，下面的代码会把线程池的大小设为 10：</p><pre><code class=\"language-c++\">#include &lt;pplx/threadpool.h&gt;\n…\ncrossplat::threadpool::\n  initialize_with_threads(10);\n</code></pre><p>如果你使用 C++ REST SDK 开发一个服务器，则不仅应当增加线程池的大小，还应当对并发数量进行统计，在并发数接近线程数时主动拒绝新的连接——一般可返回 <code>status_codes::ServiceUnavailable</code>——以免造成整个系统的阻塞。</p><h2>内容小结</h2><p>今天我们对 C++ REST SDK 的主要功能作了一下概要的讲解和演示，让你了解了它的主要功能和这种异步的编程方式。还有很多功能没有讲，但你应该可以通过查文档了解如何使用了。</p><p>这只能算是我们旅程中的一站——因为随着 C++20 的到来，我相信一定会有更多好用的网络开发库出现的。</p><h2>课后思考</h2><p>作为实战篇的最后一讲，内容还是略有点复杂的。如果你一下子消化不了，可以复习前面的相关内容。</p><p>如果对这讲的内容本身没有问题，则可以考虑一下，你觉得 C++ REST SDK 的接口好用吗？如果好用，原因是什么？如果不好用，你有什么样的改进意见？</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Microsoft, cpprestsdk. <a href=\"https://github.com/microsoft/cpprestsdk\">https://github.com/microsoft/cpprestsdk</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Hypertext Transfer Protocol”. <a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol\">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a> </span></p><p><span class=\"reference\">[2a] 维基百科, “超文本传输协议”. <a href=\"https://zh.m.wikipedia.org/zh-hans/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\">https://zh.m.wikipedia.org/zh-hans/超文本传输协议</a> </span></p><p><span class=\"reference\">[3] RESTful. <a href=\"https://restfulapi.net/\">https://restfulapi.net/</a> </span></p><p><span class=\"reference\">[4] curl. <a href=\"https://curl.haxx.se/\">https://curl.haxx.se/</a> </span></p><p><span class=\"reference\">[5] JSON. <a href=\"https://www.json.org/\">https://www.json.org/</a> </span></p><p><span class=\"reference\">[6] Niels Lohmann, json. <a href=\"https://github.com/nlohmann/json\">https://github.com/nlohmann/json</a> </span></p><p><span class=\"reference\">[7] Tencent, rapidjson. <a href=\"https://github.com/Tencent/rapidjson\">https://github.com/Tencent/rapidjson</a> </span></p><p><span class=\"reference\">[8] Milo Yip, nativejson-benchmark. <a href=\"https://github.com/miloyip/nativejson-benchmark\">https://github.com/miloyip/nativejson-benchmark</a> </span></p><p><span class=\"reference\">[9] Christopher Kohlhoff, Boost.Asio. <a href=\"https://www.boost.org/doc/libs/release/doc/html/boost_asio.html\">https://www.boost.org/doc/libs/release/doc/html/boost_asio.html</a> </span></p>","neighbors":{"left":{"article_title":"26 | Easylogging++和spdlog：两个好用的日志库","id":193203},"right":{"article_title":"新春寄语 | 35年码龄程序员：人生漫长，走点弯路在所难免","id":191725}}},{"article_id":191725,"article_title":"新春寄语 | 35年码龄程序员：人生漫长，走点弯路在所难免","article_content":"<p>你好，我是吴咏炜。</p><p>当你读到这一讲的时候，新年已经要来临了。今天，我们就轻松点，不讲硬核的话题了。我们就一起闲聊一下如何学习编程。</p><h2>我的编程生涯</h2><p>我学习编程在我的那一代人里算是比较早的。那时候已经有了“学电脑要从娃娃抓起”的说法，所以初一时老师就给我们介绍了什么是电脑：我第一次见到的是一台 Z80 芯片的 Laser 200，连接在一台单色显示器上，有着集成的键盘，ROM 里装载着 BASIC 语言解释器，有 4 KB 内存（你没有看错单位），没有磁盘、鼠标这些我们熟悉的外设，但可以连磁带机，还可以做比计算器更复杂的计算工作！</p><p>我还记得我尝试的头几个程序里有一个是出十道计算题，用随机数生成题目，让用户输入答案，并在最后计算得分。记得一开始我对 <code>For</code> … <code>Next</code> 循环的语义理解还不正确，找了计算机老师帮忙才得到正确的结果。但得到想要的结果后，真是有成就感啊！</p><p>于是，我就被这个按键会滴滴响的破烂玩意儿迷上了，还央求爸爸妈妈花了足足 500 元大洋（那时我爸妈的月收入才 60 几元，我妈因此放弃了一条金项链……）给我买了台更先进的 Laser 310（有 18 KB 内存哎！），连在家里的老式电视机上，这直接或间接导致了我的视力在初中急剧下降。不过，我的学习成绩完全没有受到负面影响，还各科全部稳定上升，直到考进了理想的高中和大学。</p><!-- [[[read_end]]] --><p>当然，没有磁盘的 Laser 310 实在是太弱了。还好，我参加了少科站的计算机班，逐渐接触到了 Apple II 计算机，后来又接触到最早的 IBM PC，并一路学习了：</p><ul>\n<li>\n<p>BASIC：当然，BASIC 还是少不了，在我们那个年代，它一直是很主流的，竞赛什么的还是常用 BASIC。Apple BASIC 和 DOS 3.3 就是我高中玩得最多的系统环境了。记得因为没有递归，在 BASIC 里写快速排序还是一件非常痛苦的事……<br>\n<img src=\"https://static001.geekbang.org/resource/image/4f/90/4f493489d877b49b6efc90979fe1cd90.png?wh=560*384\" alt=\"\" title=\"Apple DOS 3.3 的 HELLO 程序列表\"></p>\n</li>\n<li>\n<p>Logo：当时曾经热过一阵，但除了提高了我对编程的热情，似乎没记得它对我有多大的帮助。当时就只是玩玩作图而已，没有领会到它背后的编程理念。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ba/c2/bae4aeefadfdacb0edf4b99eddc574c2.png?wh=560*384\" alt=\"\" title=\"Apple Logo 的界面：有没有注意到圆不圆，方也不方？因为硬件像素点就不是正方的……\"></p>\n</li>\n<li>\n<p>Pascal：比起 BASIC，绝对是一阵新鲜空气啊。从 Pascal 里，我最早领会到了什么是结构化编程。记得最初需要理解指针就是在 Pascal 里。麻烦的地方是，在 Apple II 上跑 Pascal 没有 80 列卡是十分痛苦的，而少科站只有一台机器有 80 列卡……<br>\n<img src=\"https://static001.geekbang.org/resource/image/14/4b/146c7e73f4ee36ea8ff796dd11650a4b.png?wh=560*384\" alt=\"\" title=\"UCSD Pascal 的程序编辑界面：这里用上了 80 列卡\"></p>\n</li>\n<li>\n<p>Prolog：最初在纸面上学了点，但对我个人没有产生深远的影响。整个编程生涯里实际运行 Prolog 程序的机会都没有很多次。</p>\n</li>\n<li>\n<p>Lisp：学 Prolog 的时候也一起了解了。但当时只是了解了语法，而没有理解它的编程范式，也完全没有实践环境，因而没什么用。真正对 Lisp 有所领会要到多年之后捡起 Scheme 和 Racket 的时候。</p>\n</li>\n<li>\n<p>Forth：有段时间我很迷 Forth，但同样，因为没有实践的机会，实际上影响可以忽略不计。</p>\n</li>\n<li>\n<p>C：少科站计算机老师大力推荐的语言，但跟 Pascal 一样，跑起来不容易——在 Apple II 上需要插 Z80 卡跑 CP/M 操作系统才行。在 Turbo C/C++ 到来之前，没有太多机会使用。</p>\n</li>\n<li>\n<p>C++：接触到 Turbo C++ 之后，使用 C++ 就是件顺理成章的事了。具体哪一年开始用，我已经记不清了。印象比较深刻的，是 94—95 年写毕业论文时，一开始用的是没有数学协处理器的 386，作图的时候可以看到点是一个个出来的。后来换了有协处理器的 486 后，点就是一串串地流淌出来的。<br>\n<img src=\"https://static001.geekbang.org/resource/image/21/0d/21dc3488debd0706a2e9e427b1ea310d.jpg?wh=640*400\" alt=\"\" title=\"网上找来的 Turbo C++ 集成开发环境界面\"></p>\n</li>\n</ul><p>在我学习计算机的年代，一个高性能的编程语言属于实际应用的刚需，所以 C++ 成了后面非玩具项目的不二选择。大学期间肯定是花了不少时间把玩 C++ 的（依稀记得有个实验室老师希望我们有人接手他的一个 Fortran 计算代码，但没人肯上）。不过，那段时间对 C 和 C++ 的理解还是有缺陷的，再加上 DOS 下没有保护模式，也不那么容易发现错误，C++ 的路不太好走。记得曾经遇到个程序发生了空指针错误，我一直没找到原因……</p><p>大学之后，又陆续接触了一些其他的开发语言，如 VBScript 和 JavaScript。而我对 C++ 的理解有真正长足的进步，是在 2000—2005 那段时间。那时候，我在一家网络安全公司工作，对网络上的实时报文做高性能协议分析和内容检测，需要对网络协议、面向对象编程、系统架构都有比较好的把握。这又恰恰是互联网越来越成熟、走进大众生活的年代，网上的开发资源也愈见增多。我那时在 Windows 上开发 Linux 应用程序，为了方便起见，在本机也安装了 GCC，因而有段时间我在 MinGW GCC 的邮件列表还是相当活跃的。因为有切实的工作需要，也因为有好的交流场所，那是我真正在开发技能上突飞猛进的时间。</p><p>再后面，我加入了 Intel，并在那里工作了十年多。Intel 是一家了不起的公司，我在那里也学到了很多东西。不过，纯粹从软件开发技能上来说，那段时间进步不多。如果我坚持一直待下去的话，应该会有机会成为 PowerPoint Engineer 的。😂</p><p>离开 Intel 后，我的主要开发语言从 C++ 变成了 Python。这也算是一种全新的体验吧。不同的开发语言有着不同的功能取舍，而 Python 放弃了性能，来换取表达能力上的提高，对开发人员来说真是轻松之极。我在好几年的 C++ 大会上，讲 C++ 时都会拿 Python 代码来对标。一开始还有点不服气的意思（我也就比你多写了那么几行嘛），后来成了由衷的佩服和学习。我觉得 C++ 的发展目标就应该是达到 Python 的表达能力，同时还具有高出几个数量级的性能，那样就完美了……</p><h2>一万小时定律</h2><p>说了半天，你有没有觉得我学得非常的杂啊？我现在自己想想，都觉得似乎有点太杂了。不过，人生在世，不走点弯路是不可能的。我也没觉得我花在那些小众语言或不重要的特性上的时间完全是浪费，虽说也许有更好的学习方式。学习编程绝对是一场比马拉松更长的长跑，是需要长期的努力和付出的。</p><p>你很可能已经听说过“一万小时定律”了。这个说法的核心意思是，在大部分的领域里，从普通人变为专家需要投入至少约一万小时的时间。如果按每天工作八个小时、一周工作五天计算，那么成为一个领域的专家至少需要五年。如果投入时间不那么多，或者问题领域更复杂，“十年磨一剑”也是件很自然的事。</p><p>注意这是个约数，也只是必要条件，而非充分条件。时间少了，肯定完全没有希望；大于等于一万小时，也不能保证你一定成为专家。即使天才也需要勤学苦练。而如果天资真的不足，那估计投入再多也不会有啥效果。</p><p>如果你看得更仔细一点，你在了解一万小时定律时，应该会注意到不是随便练习一万小时就有用的。你需要的是刻意的练习。换句话说，练习是为了磨练你的思维（或肌肉，或其他需要训练的部分），而不能只是枯燥的练习而已。</p><p>打另外一个比方，如果你工作了五年，任务是数据库的查询和报表。那估计对绝大多数人，只有第一年可能是有能力提高的，后面四年则对能力提高没有什么大帮助。在求职市场上，这样的五年经验，多半不比两年工作经验的更有竞争力。考虑到五年经验的的薪水比两年的要高，很多公司会更偏好经验更少的呢。这就是为什么纯编程的职位（像 Java 开发工程师、Python 开发工程师之类）基本上见不到要求十年以上经验的。C++ 这方面相对还略好些，因为大家都知道 C++ 上手需要的时间比较长，所以经验很少的 C++ 程序员意义不大，除非公司里能分配比较有经验的程序员指导。但总体而言，经验要求多的，一般更会是架构、管理方面的职位，大家更认同这些方面的能力更需要长时间的积累。</p><p>你有没有注意我说的是“大家更认同”，而不是“我认为”？事实上，我个人的观点恰恰相反，纯粹的程序员能力，不论何种语言，也是可以积累的。只不过，这种积累的有效性因人而异，因而在求职市场上参考意义偏弱些。程序员如果希望积累个人能力的话，很重要的一点，是不要把重复的事情一直重复下去。如果你做一件事感觉以前做过了，你就得想想这里面是否有共性了；如果你做一件事已经是第三第四遍了，那绝对是某个地方出了点问题。你应当做的事情，是退一步，看看如何可以用更好的抽象来解决问题，而不是一遍遍地去重复——否则，就真成了码农，潜在可以被其他人，甚至机器，在某一天替代了。</p><p>这点上来说，C++ 是很适合爱好抽象的程序员的语言。C++ 允许高效的抽象，可以用来构造新的领域专用语言。我个人觉得 C++ 挺适合分层开发的——一部分有经验的老手开发系统的框架和底层抽象，并暴露出一个简单易用的接口给上层开发者；上层开发者可以相对经验较少，在老手的指导下完成整个系统的构建。</p><p>估计我说了这么多，你还是会想，那你学了这么多乱七八糟的语言，有用吗？</p><p>我的个人意见是，既没用，也有用。</p><p>如果我有一个好的老师具有针对性地来指导我，指出我哪方面有欠缺，哪方面需要加强训练，那当然会是件极好的事。可那样的事似乎只在音乐界和体育界发生了。在编程这样的开放领域，我还真不知道哪个大师是好老师教出来的。我不是说老师没有用（我遇到过好几个对我编程生涯有影响的好老师），但存在一个一对一的、同领域的好老师的概率真的太低了，尤其在你成长到一定程度之后。编程绝对是一个需要自学的领域。我在编程上“荒废”的时间，应该属于这一万小时中比较低效的部分，但不是无效的部分。说低效，是因为我并不是针对我的编程能力方面的缺陷，去刻意提高自己在某方面的能力。但是，因为我也不是无聊地重复编写同样的程序，而是根据自己的兴趣爱好钻研自己不理解、感兴趣的方面，这种“泛读”也应该部分起到了塑造我的思维的作用。</p><p>我还很喜欢 Larry Wall 认为程序员该有的三大美德：懒惰，急切，傲慢（laziness, impatience, hubris；初次阐释于 <em>Programming Perl</em> 第二版）。我翻译出完整的原文与你妙文共赏：</p><blockquote>\n<p><strong>懒惰</strong></p>\n<p>使得你花费极大努力来减少总体能量开销的品质。懒惰使你去写能让别人觉得有用、并减少繁杂工作的程序；你也会用文档描述你的程序，免得你不得不去回答别人的问题。因此，这是程序员的第一大美德。</p>\n<p><strong>急切</strong></p>\n<p>当计算机不能满足你的需求时你所感到的愤怒。这使得你写的程序不仅满足自己的需求，还能预期其他需求。至少努力去这么做。因此，这是程序员的第二大美德。</p>\n<p><strong>傲慢</strong></p>\n<p>老天都受不了你的极度骄傲。这种品质使得你写程序（和维护程序）时不允许别人有机会来说三道四。因此这是程序员的第三大美德。</p>\n</blockquote><p>搞软件开发的，我相信没有很笨的。智力上的差距通过努力、态度和技巧是完全可以填补的。希望你也能拥有这三个懒惰、急切、傲慢的美德。</p><h2>英语学习</h2><p>学编程应该学好英语。学编程应该学好英语。学编程应该学好英语。（重要的事情说三遍。）</p><p>不管出于什么原因，中文的编程资源没有英文的好，这是不争的事实。前些天，我在帮朋友出些 C++ 的考题，也在网上找了一下，结果看到了很多错误的题目和答案。有还在使用 <code>void main</code> 的（应该是 <code>int main</code>），有对结构的对齐规则理解不正确的（部分是因为 MSVC 和 GCC 规则有些细微的小区别），还有对 C++ 对象的生命周期规则理解有偏差的，等等。</p><p>事实上，我对 C++ 有疑惑时，解答大部分来自于 Stack Overflow——而国内完全没有同等级的编程问答网站。形式上有点相似的是百度问答，但内容的质量——不管是问题，还是回答——完全不可同日而语。百度问答上的很多问题，如果有人胆敢贴到 Stack Overflow 上去，问题立即会变成负分……</p><p>怎么学好英语，这个问题是被讨论过无数次了。对于我来讲，非常简单：我喜欢英语。喜欢永远是最好的学习动力。那如果你就是喜欢不起来呢？那我觉得，你需要告诉你自己：</p><ol>\n<li>学好英语是必要的</li>\n<li>学好英语比学好编程容易</li>\n<li>还有任何疑问，请参见第 1 条</li>\n</ol><p>你需要逼自己一下，定下小小的目标和计划，并每天<strong>坚持</strong>。比如：</p><ul>\n<li>每天阅读一篇英语的编程文章</li>\n<li>每天看一条英文的 C++ Core Guideline</li>\n<li>每天看 5 页 C++ 之父的 <em>The C++ Programming Language</em>（或其他的英文编程书籍）</li>\n<li>每天在 Stack Overflow 上看 3 个问答</li>\n<li>等等</li>\n</ul><p>你很快会发现，克服心理障碍之后，学习英语比起编程来是不费吹灰之力的事，不需要动什么脑筋。把自己沉浸到一个英文环境里，英语能力的提高是件自然而然的事。听说读写，其他方面缺乏训练还情有可原，读是应该最容易被解决的。为了能和世界各地的其他优秀程序员网上交流，写也需要多加练习——不要怕有错误，用简单的词把意思表达清楚，就是很好的第一步。多读多写，基本的网上阅读和交流就不会是一个难题了。</p><h2>新春快乐</h2><p>听我唠叨了这么多，希望你没有觉得厌烦。哈哈，就在此祝你新春快乐，在新的一年里学习顺利、工作成功。轻松的生活不是成长的人生所需要的，但希望你遇到的困难都能找到解决的方法，进而有所提高。</p><p>在这里顺便告个假，请容我和编辑稍稍歇上一天，1 月 27 日也就是大年初三我们停更一次。大家过年期间除了和亲朋好友团聚外，也可以抽时间把前面的内容再复习下。初五我会为大家提供一个加餐，C++ 编程推荐书目，希望能够为你在这个课程之外进一步提升自己的能力提供参考方向。1 月 31 日起我们恢复正文更新，再上征途，完成最后五讲的学习。</p>","neighbors":{"left":{"article_title":"27 | C++ REST SDK：使用现代C++开发网络应用","id":193523},"right":{"article_title":"新春福利 | C++好书荐读","id":193086}}},{"article_id":193086,"article_title":"新春福利 | C++好书荐读","article_content":"<h2>写在前面</h2><p>你好，我是吴咏炜。</p><p>今天我会介绍一些我觉得好并且值得推荐的书，但我不会提供任何购买或下载链接。前者没有必要，大家应该都知道怎么搜索；后者我个人认为违反道义。这些书没有哪本是程序员买不起的。如果书作者没有提供免费下载，而市面上又买不到某本书的话，那自己偷偷找个下载渠道也情有可原——但也请你不要分享出来、告诉我或者其他人。即使你认为以后别人复制你的作品是完全没有问题的（事实上我很怀疑这点，除非你是个硬核的自由软件贡献者），也不等于你有权利复制别人的作品。</p><h2>入门介绍</h2><p>Bjarne Stroustrup, <em>A Tour of C++</em>, 2nd ed. Addison-Wesley, 2018</p><p>中文版：王刚译，《C++ 语言导学》(第二版）。机械工业出版社，2019</p><p>推荐指数：★★★★★</p><p>（也有第一版的影印版，那就不推荐了。）</p><p>这是唯一一本较为浅显的全面介绍现代 C++ 的入门书。书虽然较薄，但 C++ 之父的功力在那里（这不是废话么😂），时有精妙之论。书的覆盖面很广，介绍了 C++ 的基本功能和惯用法。这本书的讲授方式，也体现了他的透过高层抽象来教授 C++ 的理念。</p><hr><p>Michael Wong 和 IBM XL 编译器中国开发团队，《深入理解 C++11：C++11 新特性解析与应用》。机械工业出版社，2013</p><!-- [[[read_end]]] --><p>推荐指数：★★★☆</p><p>这本书我犹豫了好久是否应该推荐。Michael Wong 是 C++ 标准委员会委员，内容的权威性没有问题。但这本书，从电子书版本（Kindle 和微信读书上都有此书）看，排印错误不少——校对工作没有做好。我觉得，如果你已经熟悉 C++98，想很系统地检视一下 C++11 的新特性，这本书可能还比较适合。（我只讲了一些重点的现代 C++ 特性，完整性相差很远。）</p><h2>最佳实践</h2><p>Scott Meyers, <em>Effective C++: 55 Specific Ways to Improve Your Programs and Designs</em>, 3rd ed. Addison-Wesley, 2005</p><p>中文版：侯捷译《Effective C++ 中文版》（第三版）。电子工业出版社，2011</p><p>推荐指数：★★★★</p><hr><p>Scott Meyers, <em>Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library</em>. Addison-Wesley, 2001</p><p>中文版：潘爱民、陈铭、邹开红译《Effective STL 中文版》。清华大学出版社，2006</p><p>推荐指数：★★★★</p><hr><p>Scott Meyers, <em>Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14</em>. O’Reilly, 2014</p><p>中文版：高博译《Effective Modern C++ 中文版》。中国电力出版社，2018</p><p>推荐指数：★★★★★</p><p>C++ 的大牛中有三人尤其让我觉得高山仰止，Scott Meyers 就是其中之一——Bjarne 让人感觉是睿智，而 Scott Meyers、Andrei Alexandrescu 和 Herb Sutter 则会让人感觉智商被碾压。Scott 对 C++ 语言的理解无疑是非常深入的，并以良好的文笔写出了好几代的 C++ 最佳实践。我读过他整个 Effective 系列四本书，每一本都是从头看到尾，收获巨大。（之所以不推荐第二本 <em>More Effective C++</em>，是因为那本没有出过新版，1996 年的内容有点太老了。）</p><p>这几本书讨论的都是最佳实践，因此，如果你没有实际做过 C++ 项目，感触可能不会那么深。做过实际项目的一定会看到，哦，原来我也犯了这个错误啊……如果你不想一下子看三本，至少最后一本属于必修课。</p><p>值得一提的是，这三本的译者在国内都是响当当的名家，翻译质量有保证。因此，这几本看看中文版就挺好。</p><h2>深入学习</h2><p>Herb Sutter, <em>Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Solutions</em>. Addison-Wesley, 1999</p><p>中文版：卓小涛译《Exceptional C++ 中文版》。中国电力出版社，2003</p><p>推荐指数：★★★★</p><p>我已经说过，我认为 Herb Sutter 是 C++ 界最聪明的三人之一。在这本书里，Herb 用提问、回答的形式讨论了很多 C++ 里的难点问题。虽然这本书有点老了，但我认为你一定可以从中学到很多东西。</p><hr><p>Herb Sutter and Andrei Alexandrescu, <em>C++ Coding Standards: 101 Rules, Guidelines, and Best Practices</em>. Addison-Wesley, 2004</p><p>中文版：刘基诚译《C++编程规范：101条规则准则与最佳实践》。人民邮电出版社，2006</p><p>推荐指数：★★★★</p><p>两个牛人制定的 C++ 编码规范。与其盲目追随网上的编码规范（比如，Google 的），不如仔细看看这两位大牛是怎么看待编码规范方面的问题的。</p><hr><p>侯捷，《STL 源码剖析》。华中科技大学出版社，2002</p><p>推荐指数：★★★★☆</p><p>这本是我推荐的唯二的直接以中文出版的 C++ 技术书。侯捷以庖丁解牛的方式，仔细剖析了早期 STL 的源码——对于不熟悉 STL 代码的人来说，绝对可以学到许多。我当年从这本书中学到了不少知识。虽说那里面的 STL 有点老了，但同时也更简单些，比今天主流的 STL 容易学习。</p><p>同时仍需注意，这本书有点老，也有些错误（比如，有人提到它对 <code>std::copy</code> 和 <code>memmove</code> 的说明是错的，但我已经不再有这本书了，没法确认），阅读时需要自己鉴别。但瑕不掩瑜，我还是认为这是本好书。</p><h2>高级专题</h2><p>Alexander A. Stepanov and Daniel E. Rose, <em>From Mathematics to Generic Programming</em>. Addison-Wesley, 2014</p><p>中文版：爱飞翔译《数学与泛型编程：高效编程的奥秘》。机械工业出版社，2017</p><p>推荐指数：★★★★★</p><p>Alexander Stepanov 是 STL 之父，这本书写的却不是具体的编程技巧或某个库，而是把泛型编程和抽象代数放在一起讨论了。说来惭愧，我是读了这本书之后才对群论稍稍有了点理解：之前看到的介绍材料都过于抽象，没能理解。事实上，Alexander 之前还写了一本同一题材、但使用公理推导风格的 <em>Elements of Programming</em>（裘宗燕译《编程原本》），那本就比较抽象艰深，从受欢迎程度上看远远不及这一本。我也只是买了放在书架上没看多少页😝。​</p><p>回到这本书本身。这本书用的编程语言是 C++，并引入了“概念”——虽然作者写这本书时并没有真正的 C++ 概念可用。书中讨论了数学、编程，还介绍了很多大数学家的生平。相对来说（尤其跟《编程原本》比），通过这本书是可以比较轻松地学习到泛型的威力的。哦，对了，我之前提到使用高精度整数算 RSA 就是拿这本书里描述的内容做练习。计算 RSA，从抽象的角度，只不过就是求幂和最大公约数而已……</p><p>除非抽象代数和模板编程你都已经了然于胸，否则这本书绝对会让你对编程的理解再上一个层次。相信我！</p><hr><p>Andrei Alexandrescu, <em>Modern C++ Design: Generic Programming and Design Patterns Applied</em>. Addison-Wesley, 2001</p><p>中文版：侯捷、於春景译《C++ 设计新思维》。华中科技大学出版社，2003</p><p>推荐指数：★★★★☆</p><p>这本书算是 Andrei 的成名作了，一出版就艳惊四座。书中讨论了大量模板相关的技巧，尤其是基于策略的设计。记得在这本书出版时，大量书中的代码是不能被编译器接受的。当然，错的基本上都是编译器，而不是 Andrei。</p><p>对了，注意到英文书名中的 Modern C++ 了吗？现代 C++ 这一提法就是从他开始的，虽然那是在 C++11 发布之前十年了。可以说他倡导了新的潮流。在今天，这本书的内容当然是略老了，但它仍然是不可替代的经典作品。书里的技巧有些已经过时了（我也不推荐大家今天去使用 Loki 库），但理念没有过时，对思维的训练也仍然有意义。</p><hr><p>Anthony Williams, <em>C++ Concurrency in Action</em>, 2nd ed.  Manning, 2019</p><p>中文译本只有第一版，且有人评论“机器翻译的都比这个好”。因而不推荐中文版。</p><p>推荐指数：★★★★☆</p><p>C++ 在并发上出名的书似乎只此一本。这也不算奇怪：作者是 Boost.Thread 的主要作者之一，并且也直接参与了 C++ 跟线程相关的很多标准化工作；同时，这本书也非常全面，内容覆盖并发编程相关的所有主要内容，甚至包括在 Concurrency TS 里讨论的，尚未进入 C++17 标准（但应当会进入 C++20）的若干重要特性：barrier、latch 和 continuation。</p><p>除非你为一些老式的嵌入式系统开发 C++ 程序，完全不需要接触并发，否则我推荐你阅读这本书。</p><hr><p>Ivan Čukić, <em>Functional Programming in C++</em>. Manning, 2019</p><p>中文版：程继洪、孙玉梅、娄山佑译《C++ 函数式编程》。机械工业出版社，2020</p><p>推荐指数：★★★★</p><p>推荐这本书我是有点私心的，毕竟我为这本书作了点小贡献，你也能在这本书里找到我的名字。因为这个，也因为这本书太新、评价太少，我也很犹豫该不该推荐。不过，鉴于在这个领域这是唯一的一本，如果你想用 C++ 语言做函数式编程的话，也没有更好的书可选了。</p><p>如果你对函数式编程有兴趣，可以读一读这本书。如果你对函数式编程不感冒，可以跳过这一本。</p><h2>参考书</h2><p>Bjarne Stroustrup, <em>The C++ Programming Language</em>, 4th ed. Addison-Wesley, 2013</p><p>中文版：王刚、杨巨峰译《C++ 程序设计语言》。机械工业出版社， 2016</p><p>推荐指数：★★★★☆</p><p>没什么可多说的，C++ 之父亲自执笔写的 C++ 语言。主要遗憾是没有覆盖 C++14/17 的内容。中文版分为两卷出版，内容实在是有点多了。不过，如果你没有看过之前的版本，并且对 C++ 已经有一定经验的话，这个新版还是会让你觉得，姜还是老的辣！</p><hr><p>Nicolai M. Josuttis, <em>The C++ Standard Library: A Tutorial and Reference</em>, 2nd ed. Addison-Wesley, 2012</p><p>中文版：侯捷译《C++ 标准库》。电子工业出版社，2015</p><p>推荐指数：★★★★☆</p><p>Nicolai 写的这本经典书被人称为既完备又通俗易懂，也是殊为不易。从 C++11 的角度，这本书堪称完美。当然，超过一千页的大部头，要看完也是颇为不容易了。如果你之前没有阅读过第一版，那我也会非常推荐这一本。</p><h2>C++ 的设计哲学</h2><p>Bjarne Stroustrup, <em>The Design and Evolution of C++</em>. Addison-Wesley, 1994</p><p>中文版：裘宗燕译《C++ 语言的设计与演化》。科学出版社， 2002</p><p>推荐指数：★★★☆</p><p>这本书不是给所有的 C++ 开发者准备的。它讨论的是为什么 C++ 会成为今天（1994 年）这个样子。如果你对 C++ 的设计思想感兴趣，那这本书会比较有用些。如果你对历史不感兴趣，那这本书不看也不会有很大问题。</p><hr><p>Bruce Eckel, <em>Thinking in C++, Vol. 1: Introduction to Standard C++</em>, 2nd ed.  Prentice-Hall, 2000</p><p>Bruce Eckel and Chuck Allison, <em>Thinking in C++, Vol. 2: Practical Programming</em>.  Pearson, 2003</p><p>中文版：刘宗田等译《C++ 编程思想》。机械工业出版社，2011</p><p>推荐指数：★★★</p><p>据说这套书翻译不怎么样，我没看过，不好评价。如果你英文没问题，还是看英文版吧——作者释出了英文的免费版本。这套书适合有一点编程经验的人，讲的是编程思想。推荐星级略低的原因是，书有点老，且据说存在一些错误。但 Bruce Eckel 对编程的理解非常深入，即使在 C++ 的细节上他有错误，通读此书肯定还是会对你大有益处的。</p><h2>非 C++ 的经典书目</h2><p>W. Richard Stevens, <em>TCP/IP Illustrated Volume 1: The Protocols</em>. Addison-Wesley, 1994</p><p>Gary R. Wright and W. Richard Stevens, <em>TCP/IP Illustrated Volume 2: The Implementation</em>. Addison-Wesley, 1995</p><p>W. Richard Stevens, <em>TCP/IP Illustrated Volume 3: TCP for Transactions, HTTP, NNTP and the Unix Domain Protocols</em>. Addison-Wesley 1996</p><p>中文版翻译不佳，不推荐。</p><p>推荐指数：★★★★☆</p><p>不是所有的书都是越新越好，《TCP/IP 详解》就是其中一例。W. Richard Stevens 写的卷一比后人补写的卷一第二版评价更高，就是其中一例。关于 TCP/IP 的编程，这恐怕是难以超越的经典了。不管你使用什么语言开发，如果你的工作牵涉到网络协议的话，这套书恐怕都值得一读——尤其是卷一。</p><hr><p>W. Richard Stevens and Stephen A. Rago, <em>Advanced Programming in the UNIX Environment</em>, 3rd ed. Addison-Wesley, 2013</p><p>中文版： 戚正伟、张亚英、尤晋元译《UNIX环境高级编程》。人民邮电出版社，2014</p><p>推荐指数：★★★★</p><p>从事 C/C++ 编程应当对操作系统有深入的了解，而这本书就是讨论 Unix 环境下的编程的。鉴于 Windows 下都有了 Unix 的编程环境，Unix 恐怕是开发人员必学的一课了。这本书是经典，而它的第三版至少没有损坏前两版的名声。</p><hr><p>Erich Gamma, Richard Helm, Ralph Johson, John Vlissides, and Grady Booch, <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. Addison-Wesley, 1994</p><p>中文版：李英军、马晓星、蔡敏、刘建中等译《设计模式》。机械工业出版社，2000</p><p>推荐指数：★★★★☆</p><p>经典就是经典，没什么可多说的。提示：如果你感觉这本书很枯燥、没用，那就等你有了更多的项目经验再回过头来看一下，也许就有了不同的体验。</p><hr><p>Eric S. Raymond, <em>The Art of UNIX Programming</em>. Addison-Wesley, 2003</p><p>中文版：姜宏、何源、蔡晓骏译《UNIX 编程艺术》。电子工业出版社，2006</p><p>推荐指数：★★★★</p><p>抱歉，这仍然是一本 Unix 相关的经典。如果你对 Unix 设计哲学有兴趣的话，那这本书仍然无可替代。如果你愿意看英文的话，这本书的英文一直是有在线免费版本的。</p><hr><p>Pete McBreen, <em>Software Craftsmanship: The New Imperative</em>. Addison-Wesley, 2001</p><p>中文版：熊节译《软件工艺》。人民邮电出版社，2004</p><p>推荐指数：★★★★</p><p>这本书讲的是软件开发的过程，强调的是软件开发中人的作用。相比其他的推荐书，这本要“软”不少。但不等于这本书不重要。如果你之前只关注纯技术问题的话，那现在是时间关注一下软件开发中人的问题了。</p><hr><p>Paul Graham, <em>Hackers &amp; Painters: Big Ideas From The Computer Age</em>. O’Reilly, 2008</p><p>中文版：阮一峰译《黑客与画家》。人民邮电出版社，2011</p><p>推荐指数：★★★★</p><p>这本讲的是一个更玄的问题：黑客是如何工作的。作者 Paul Graham 也是一名计算机界的大神了，用 Lisp 写出了被 Yahoo! 收购的网上商店，然后又从事风险投资，创办了著名的孵化器公司 Y Combinator。这本书是他的一本文集，讨论了黑客——即优秀程序员——的爱好、动机、工作方法等等。你可以从中学习一下，一个优秀的程序员是如何工作的，包括为什么脚本语言比静态类型语言受欢迎😁……</p><hr><p>Robert C. Martin, <em>Clean Code: A Handbook of Agile Software Craftsmanship</em>. Prentice Hall, 2008</p><p>中文版：韩磊译《代码整洁之道》。人民邮电出版社，2010</p><p>推荐指数：★★★★☆</p><p>Bob 大叔的书如果你之前没看过的话，这本是必看的。这本也是语言无关的，讲述的是如何写出干净的代码。有些建议初看也许有点出乎意料，但细想之下又符合常理。推荐。</p><h2>其他</h2><p>别忘了下面这两个重要的免费网站：</p><p>C++ Reference. <a href=\"https://en.cppreference.com\">https://en.cppreference.com</a></p><p>C++ Core Guidelines. <a href=\"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines</a></p><p>这两个网站绝对是优秀的免费资源。大力推荐！</p><p>希望今天的推荐能给你提供多一些的参考方向，从而进一步提升自己。</p>","neighbors":{"left":{"article_title":"新春寄语 | 35年码龄程序员：人生漫长，走点弯路在所难免","id":191725},"right":{"article_title":"28 | Concepts：如何对模板进行约束?","id":194005}}},{"article_id":194005,"article_title":"28 | Concepts：如何对模板进行约束?","article_content":"<p>你好，我是吴咏炜。</p><p>从这一讲开始，我们进入了未来篇，展望一下即将在 C++20 出现的新功能。我们第一个要讨论的，是 concepts（概念）——一个难产了很多年才终于进入 C++ 的新功能。</p><h2>一个小例子</h2><p>老规矩，要讲“概念”，我们先看例子。</p><p>我们知道 C++ 里有重载，可以根据参数的类型来选择合适的函数。比如，我们可以定义 <code>half</code> 对于 <code>int</code> 和 <code>string</code> 有不同的作用：</p><pre><code class=\"language-c++\">int half(int n)\n{\n  return n / 2;\n}\n\nstring half(string s)\n{\n  s.resize(s.size() / 2);\n  return s;\n}\n</code></pre><p>初看，似乎重载可以解决问题，但细想，不对啊：除了 <code>int</code>，我们还有差不多的 <code>short</code>、<code>long</code> 等类型，甚至还有 <code>boost::multiprecision::cpp_int</code>；除了 <code>string</code>，我们也还有 <code>wstring</code>、<code>u16string</code>、<code>u32string</code> 等等。上面的每个函数，实际上都适用于一族类型，而不是单个类型。重载在这方面并帮不了什么忙。</p><p>也许你现在已经反应过来了，我们有 SFINAE 啊！回答部分正确。可是，你告诉我你有没有想到一种很简单的方式能让 SFINAE 对整数类型可以工作？Type traits？嗯嗯，总是可以解决的是吧，但这会不会是一条把初学者劝退的道路呢？……</p><!-- [[[read_end]]] --><p>C++ 的概念就是用来解决这个问题的。对于上面的例子，我们只需要事先定义了 <code>Integer</code> 和 <code>String</code> 的概念（如何定义一个概念我们后面会说），我们就可以写出下面这样的代码：</p><pre><code class=\"language-c++\">template &lt;Integer N&gt;\nN half(N n)\n{\n  return n / 2;\n}\n\ntemplate &lt;String S&gt;\nS half(S s)\n{\n  s.resize(s.size() / 2);\n  return s;\n}\n</code></pre><p>我们应当了解一下，从概念上讲，上面这种形式的含义和下面的代码实质相同（以上面的第一个函数为例）：</p><pre><code class=\"language-c++\">template &lt;typename N&gt;\n  requires Integer&lt;N&gt;\nN half(N n)\n{\n  return n / 2;\n}\n</code></pre><p>即，这个 <code>half</code> 是一个函数模板，有一个模板参数，启用这个模板的前提条件是这个参数满足 <code>Integer</code> 这个约束。</p><h2>Concepts 简史</h2><p>2019 年 11 月，上海，当在 C++ 峰会上被问起他最喜欢的 C++ 特性有哪些时，Bjarne 的回答里就有 concepts。这丝毫不让我感到惊讶。虽然 C++ 的“概念”看起来是个挺简单的概念，但它的历史并不短——Bjarne 想把它加入 C++ 已经有好多年了 <span class=\"orange\">[1]</span>。</p><p>从基本概念上来讲，“概念”就是一组对模板参数的约束条件。我们讨论过模板就是 C++ 里的鸭子类型，但我们没有提过，Bjarne 对模板的接口实际上是相当不满意的：他自己的用词直接就是 lousy，并认为这一糟糕的接口设计是后面导致了恐怖的模板编译错误信息的根源。</p><p>从另一方面讲，Alex Stepanov 设计的 STL 一开始就包含了“概念”的概念，如我们在<a href=\"https://time.geekbang.org/column/article/176842\">[第 7 讲]</a> 中提到的各种不同类型的迭代器：</p><ul>\n<li>Output Iterator</li>\n<li>Input Iterator</li>\n<li>Forward Iterator</li>\n<li>Bidirectional Iterator</li>\n<li>Random Access Iterator</li>\n<li>…</li>\n</ul><p>这些概念出现在了 STL 的文档中，有详细的定义；但它们只是落在纸面上，而没有在 C++ 语言中有真正的体现。后来，他还进一步把很多概念的形式描述写进了他于 2009 年（和 Paul McJones 一起）出版的“神作” <em>Elements of Programming</em> <span class=\"orange\">[2]</span> 中，并给出了假想的实现代码——其中就有关键字 <code>requires</code>——即使那时没有任何编译器能够编译这样的代码。</p><p>在 C++ 第一次标准化（1998）之后，Bjarne 多次试图把“概念”引入 C++（根据我看到的文献，他在 03 到 09 年直接有至少九篇单独或合著的论文跟“概念”有关），但一直没有成功——魔鬼在细节，一旦进入细节，人们对一个看起来很美的点子的分歧就非常大了。一直到 C++11 标准化，“概念” 还是因为草案复杂、争议多、无成熟实现而没有进入 C++ 标准。</p><p>目前 C++20 里的“概念”的基础是 2009 年重新启动的 Concepts Lite，并在 2015 年出版成为技术规格书 Concepts TS（正式的 TS 文档需要花钱购买，我们需要进一步了解可以查看正式出版前的草案 <span class=\"orange\">[3]</span>）。很多人参与了相关工作，其中就包括了 Andrew Sutton、Bjarne Stroustrup 和 Alex Stepanov。这回，实现简化了，有了一个实现（GCC），争议也少多了。然而，“概念”还是没有进入 C++17，主要由于下面这些原因：</p><ul>\n<li>从 Concepts TS 出版到标准定稿只有不到四个⽉的时间（C++20 的内容也同样是在 2019 年就全部冻结了，到正式出版前的时间留个修正小问题和走批准流程）</li>\n<li>“概念”只有一个实现（GCC）</li>\n<li>Concepts TS 规格书的作者和 GCC 中的概念实现者是同⼀个⼈，没有⼈独⽴地从规格书出发实现概念</li>\n<li>Concepts TS ⾥没有实际定义概念，标准库也没有把概念用起来</li>\n</ul><p>当然，大家还是认可“概念”是个好功能，到了 2017 年 7 月，“概念”就正式并入 C++20 草案了。之后，小修订还是不少的（所以“概念”没有进入 C++20 也不完全是件坏事）。从用户的角度，最大的一个改变是“概念”的名字：目前，所有标准“概念”从全部由大写字母打头改成了“标准大小写”——即全部小写字母加下划线 <span class=\"orange\">[4]</span>。比如，允许相等比较这个概念，原先写作 <code>EqualityComparable</code>，现在要写成 <code>equality_comparable</code>。</p><h2>基本的 Concepts</h2><p>下图中给出了 C++ 里对象相关的部分标准概念（不完整）：</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/21/fc99fa3b010ab1e84741eea004933f21.png\" alt=\"\"></p><p>我们从下往上快速看一下：</p><ul>\n<li><code>move_constructible</code>：可移动构造</li>\n<li><code>swappable</code>：可交换</li>\n<li><code>movable</code>：可移动构造、可交换，合在一起就是可移动了</li>\n<li><code>copy_constructible</code>：可拷贝构造</li>\n<li><code>copyable</code>：可拷贝构造、可移动，合在一起就是可复制了（注：这儿“拷贝”和“复制”只是我在翻译中做的一点小区分，英文中没有区别）</li>\n<li><code>default_initializable</code>：可默认初始化（名字不叫 <code>default_constructible</code> 是因为目前的 type traits 中有 <code>is_default_constructible</code>，且意义和 <code>default_initializable</code> 有点微妙的区别；详见<a href=\"https://timsong-cpp.github.io/lwg-issues/3338\">问题报告 3338</a>）</li>\n<li><code>semiregular</code>：可复制、可默认初始化，合在一起就是半正则了</li>\n<li><code>equality_comparable</code>：可相等比较，即对象之间可以使用 <code>==</code> 运算符</li>\n<li><code>regular</code>：半正则、可相等比较，合在一起就是正则了</li>\n</ul><p>这些“概念”现在不只是文字描述，绝大部分是可以真正在代码中定义的。现在，准标准的定义已经可以在 cppreference.com 上找到 <span class=\"orange\">[5]</span>。从实际的角度，下面我们列举部分概念在 CMCSTL2 <span class=\"orange\">[6]</span>——一个 Ranges（我们下一讲讨论）的参考实现——中的定义。</p><p>从简单性的角度，我们自上往下看，首先是 <code>regular</code>：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nconcept regular =\n  semiregular&lt;T&gt; &amp;&amp;\n  equality_comparable&lt;T&gt;;\n</code></pre><p>很简单吧，定义一个 concept 此处只是一些针对类型的条件而已。可以看出，每个概念测试表达式（如 <code>semiregular&lt;T&gt;</code>）的结果是一个布尔值（编译期常量）。</p><p>然后是 <code>semiregular</code>：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nconcept semiregular =\n  copyable&lt;T&gt; &amp;&amp;\n  default_initializable&lt;T&gt;;\n</code></pre><p>再看一眼 <code>equality_comparable</code>：</p><pre><code class=\"language-c++\">template &lt;class T, class U&gt;\nconcept WeaklyEqualityComparable =\n  requires(\n      const remove_reference_t&lt;T&gt;&amp; t,\n      const remove_reference_t&lt;U&gt;&amp; u) {\n    { t == u } -&gt; boolean;\n    { t != u } -&gt; boolean;\n    { u == t } -&gt; boolean;\n    { u != t } -&gt; boolean;\n  };\n\ntemplate &lt;class T&gt;\nconcept equality_comparable =\n  WeaklyEqualityComparable&lt;T, T&gt;;\n</code></pre><p>这个稍复杂点，用到了 <code>requires</code> <span class=\"orange\">[7]</span>，但不需要我讲解，你也能看出来 <code>equality_comparable</code> 的要求就是类型的常左值引用之间允许进行 <code>==</code> 和 <code>!=</code> 的比较，且返回类型为布尔类型吧。</p><p>注意上面的定义里写的是 <code>boolean</code> 而不是 <code>bool</code>。这个概念定义不要求比较运算符的结果类型是 <code>bool</code>，而是可以用在需要布尔值的上下文中。自然，<code>boolean</code> 也是有定义的，但这个定义可能比你想象的复杂，我这儿就不写出来了😜。</p><p>我们之前已经讲过了各种迭代器，每个迭代器也自然地满足一个“概念”——概念名称基本上就是之前给的，只是大小写要变化一下而已。最底下的 <code>iterator</code> 是个例外：因为这个名字在标准里已经被占用啦。所以现在它的名字是 <code>input_or_output_iterator</code>。</p><p>迭代器本身需要满足哪些概念呢？我们看下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/0c/6ade3581f8f2da22c92987e81974210c.png\" alt=\"\"></p><p>注意这张跟上面那张图不一样，概念之间不是简单的“合取”关系，而是一种“继承”关系：上面的概念比它指向的下面的概念有更多的要求。具体到代码：</p><pre><code class=\"language-c++\">template &lt;class I&gt;\nconcept weakly_incrementable =\n  semiregular&lt;I&gt; &amp;&amp; requires(I i) {\n    typename iter_difference_t&lt;I&gt;;\n    requires signed_integral&lt;\n      iter_difference_t&lt;I&gt;&gt;;\n    { ++i } -&gt; same_as&lt;I&amp;&gt;;\n    i++;\n  };\n</code></pre><p>也就是说，<code>weakly_incrementable</code> 是 <code>semiregular</code> 再加一些额外的要求：</p><ul>\n<li><code>iter_difference_t&lt;I&gt;</code> 是一个类型</li>\n<li><code>iter_difference_t&lt;I&gt;</code> 是一个有符号的整数类型</li>\n<li><code>++i</code> 的结果跟 <code>I&amp;</code> 是完全相同的类型</li>\n<li>能够执行 <code>i++</code> 操作（不检查结果的类型）</li>\n</ul><p><code>input_or_output_iterator</code> 也很简单：</p><pre><code class=\"language-c++\">template &lt;class I&gt;\nconcept input_or_output_iterator =\n  __dereferenceable&lt;I&amp;&gt; &amp;&amp;\n  weakly_incrementable&lt;I&gt;;\n</code></pre><p>就是要求可以解引用、可以执行 <code>++</code>、可以使用 <code>iter_difference_t</code> 提取迭代器的 <code>difference_type</code> 而已。</p><p>剩下的概念的定义也不复杂，我这儿就不一一讲解了。感兴趣的话你可以自己去看 CMCSTL2 的源代码。</p><h3>简单的概念测试</h3><p>为了让你再简单感受一下标准的概念，我写了下面这个简单的测试程序，展示一些标准概念的测试结果：</p><pre><code class=\"language-c++\">#include &lt;armadillo&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;type_traits&gt;\n\nusing namespace std;\n\n#if defined(__cpp_concepts)\n\n#if __cpp_concepts &lt; 201811\n\n#include &lt;experimental/ranges/concepts&gt;\nusing namespace experimental::ranges;\n\n#else\n\n#include &lt;concepts&gt;\n\n#endif\n\n#else // defined(__cpp_concepts)\n\n#error \"No support for concepts!\"\n\n#endif\n\n#define TEST_CONCEPT(Concept,      \\\n                     Type)         \\\n  cout &lt;&lt; #Concept &lt;&lt; '&lt;' &lt;&lt; #Type \\\n       &lt;&lt; \"&gt;: \"                    \\\n       &lt;&lt; Concept&lt;Type&gt; &lt;&lt; endl\n\n#define TEST_CONCEPT2(             \\\n  Concept, Type1, Type2)           \\\n  cout &lt;&lt; #Concept &lt;&lt; '&lt;'          \\\n       &lt;&lt; #Type1 &lt;&lt; \", \" &lt;&lt; #Type2 \\\n       &lt;&lt; \"&gt;: \"                    \\\n       &lt;&lt; Concept&lt;Type1,           \\\n                  Type2&gt; &lt;&lt; endl\n\nint main()\n{\n  cout &lt;&lt; boolalpha;\n  cout &lt;&lt; \"__cpp_concepts is \"\n       &lt;&lt; __cpp_concepts &lt;&lt; endl;\n  TEST_CONCEPT(regular, int);\n  TEST_CONCEPT(regular, char);\n  TEST_CONCEPT(integral, int);\n  TEST_CONCEPT(integral, char);\n  TEST_CONCEPT(readable, int);\n  TEST_CONCEPT(readable,\n               unique_ptr&lt;int&gt;);\n  TEST_CONCEPT2(\n    writable, unique_ptr&lt;int&gt;, int);\n  TEST_CONCEPT2(writable,\n                unique_ptr&lt;int&gt;,\n                double);\n  TEST_CONCEPT2(writable,\n                unique_ptr&lt;int&gt;,\n                int*);\n  TEST_CONCEPT(semiregular,\n               unique_ptr&lt;int&gt;);\n  TEST_CONCEPT(semiregular,\n               shared_ptr&lt;int&gt;);\n  TEST_CONCEPT(equality_comparable,\n               unique_ptr&lt;int&gt;);\n  TEST_CONCEPT(semiregular,\n               arma::imat);\n  TEST_CONCEPT2(assignable_from,\n                arma::imat&amp;,\n                arma::imat&amp;);\n  TEST_CONCEPT(semiregular,\n               arma::imat22);\n  TEST_CONCEPT2(assignable_from,\n                arma::imat22&amp;,\n                arma::imat22&amp;);\n}\n</code></pre><p>代码照顾了两种可能的环境：</p><ul>\n<li>最新的 MSVC（需要使用 <code>/std:c++latest</code>；我用的是 Visual Studio 2019 16.4.4）</li>\n<li>GCC（需要使用 <code>-fconcepts</code>；我测试了 7、8、9 三个版本都可以）和 CMCSTL2（需要将其 include 目录用 <code>-I</code> 选项加到命令行上）</li>\n</ul><p>程序在 MSVC 下的结果如下所示：</p><blockquote>\n<p><code>__cpp_concepts is 201811</code><br>\n<code>regular&lt;int&gt;: true</code><br>\n<code>regular&lt;char&gt;: true</code><br>\n<code>integral&lt;int&gt;: true</code><br>\n<code>integral&lt;char&gt;: true</code><br>\n<code>readable&lt;int&gt;: false</code><br>\n<code>readable&lt;unique_ptr&lt;int&gt;&gt;: true</code><br>\n<code>writable&lt;unique_ptr&lt;int&gt;, int&gt;: true</code><br>\n<code>writable&lt;unique_ptr&lt;int&gt;, double&gt;: true</code><br>\n<code>writable&lt;unique_ptr&lt;int&gt;, int*&gt;: false</code><br>\n<code>semiregular&lt;unique_ptr&lt;int&gt;&gt;: false</code><br>\n<code>semiregular&lt;shared_ptr&lt;int&gt;&gt;: true</code><br>\n<code>equality_comparable&lt;unique_ptr&lt;int&gt;&gt;: true</code><br>\n<code>semiregular&lt;arma::imat&gt;: true</code><br>\n<code>assignable_from&lt;arma::imat&amp;, arma::imat&amp;&gt;: true</code><br>\n<code>semiregular&lt;arma::imat22&gt;: false</code><br>\n<code>assignable_from&lt;arma::imat22&amp;, arma::imat22&amp;&gt;: false</code></p>\n</blockquote><p>除了第一行 <code>__cpp_concepts</code> 的输出，GCC 的结果也是完全一致的。大部分的结果应当没有意外，但也需要注意，某些用起来没问题的类（如 <code>arma::imat22</code>），却因为一些实现上的特殊技术，不能满足 <code>semiregular</code>。——概念要比鸭子类型更为严格。</p><h2>概念、出错信息和 SFINAE</h2><p>显然，对于上面出现的这个例子：</p><pre><code class=\"language-c++\">template &lt;Integer N&gt;\nN half(N n)\n{\n  return n / 2;\n}\n</code></pre><p>我们用 <code>enable_if</code> 也是能写出来的：</p><pre><code class=\"language-c++\">template &lt;typename N&gt;\nenable_if_t&lt;Integer&lt;N&gt;, N&gt;\nhalf(N n)\n{\n  return n / 2;\n}\n</code></pre><p>不过，你不会觉得这种方式更好吧？而且，对于没有返回值的情况，要用对 <code>enable_if</code> 还是非常麻烦的（参见 <span class=\"orange\">[8]</span> 里的 Notes /注解部分）。</p><p>更重要的是，“概念”可以提供更为友好可读的代码，以及潜在更为友好的出错信息。拿 Andrew Sutton 的一个例子 <span class=\"orange\">[9]</span>（根据我们上节说的编译环境做了改编）：</p><pre><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n#if defined(__cpp_concepts)\n\n#if __cpp_concepts &lt; 201811\n\n#include &lt;experimental/ranges/concepts&gt;\nusing namespace experimental::ranges;\n\n#else\n\n#include &lt;concepts&gt;\n#include &lt;ranges&gt;\nusing namespace ranges;\n\n#endif\n\n#define REQUIRES(x) requires x\n\n#else // defined(__cpp_concepts)\n\n#define REQUIRES(x)\n\n#endif\n\ntemplate &lt;typename R, typename T&gt;\n  REQUIRES(\n    (range&lt;R&gt; &amp;&amp;\n     equality_comparable_with&lt;\n       T, typename R::value_type&gt;))\nbool in(R const&amp; r, T const&amp; value)\n{\n  for (auto const&amp; x : r)\n    if (x == value)\n      return true;\n  return false;\n}\n\nint main()\n{\n  vector&lt;string&gt; v{\"Hello\",\n                   \"World\"};\n  in(v, \"Hello\");\n  in(v, 0);\n}\n</code></pre><p>以 GCC 8 为例，如果不使用概念约束，<code>in(v, 0)</code> 这行会产生 166 行出错信息；而启用了概念约束后，出错信息缩减到了 8 行。MSVC 上对于这个例子不使用概念错误信息也较短，但启用了概念后仍然能产生更短、更明确的出错信息：</p><blockquote>\n<p><code>test.cpp(47): error C2672: 'in': no matching overloaded function found</code><br>\n<code>test.cpp(47): error C7602: 'in': the associated constraints are not satisfied</code><br>\n<code>test.cpp(34): note: see declaration of 'in'</code></p>\n</blockquote><p>随着编译器的改进，概念在出错信息上的优势在消减，但在代码表达上的优势仍然是实实在在的。记得<a href=\"https://time.geekbang.org/column/article/181636\">[第 14 讲]</a> 里我们费了好大的劲、用了几种不同的方法来定义 <code>has_reserve</code> 吗？在概念面前，那些就成了“回”字有几种写法了。我们可以飞快地定义下面的概念：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nconcept has_reserve =\n  requires(T&amp; dest) {\n    dest.reserve(1U);\n  };\n</code></pre><p>这个概念用在编译期条件语句里，效果和之前的完全相同……哦，错了，不用再写 <code>::value</code> 或 <code>{}</code> 了😂。</p><p>在<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 我给出过的 <code>fmap</code>，在实际代码中我也是用了 SFINAE 来进行约束的（略简化）：</p><pre><code class=\"language-c++\">template &lt;\n  template &lt;typename, typename&gt;\n  class OutContainer = vector,\n  typename F, class R&gt;\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs)\n  -&gt; decltype(\n    begin(inputs),\n    end(inputs),\n    OutContainer&lt;decay_t&lt;\n      decltype(f(*begin(\n        inputs)))&gt;&gt;());\n</code></pre><p>我费了老大的劲，要把返回值写出来，实际上就是为了利用 SFINAE 而已。如果使用“概念”，那代码可以简化成：</p><pre><code class=\"language-c++\">template &lt;\n  template &lt;typename, typename&gt;\n  class OutContainer = vector,\n  typename F, class R&gt;\n  requires requires(R&amp;&amp; r) {\n    begin(r);\n    end(r);\n  }\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs);\n</code></pre><p>上面的 <code>requires requires</code> 不是错误，正如 <code>noexcept(noexcept(…))</code> 不是错误一样。第一个 <code>requires</code> 开始一个 <strong>requires 子句</strong>，后面跟一个常量表达式，结果的真假表示是否满足了模板的约束条件。第二个 <code>requires</code> 则开始了一个 <strong>requires 表达式</strong>：如果类型 <code>R</code> 满足约束——可以使用 <code>begin</code> 和 <code>end</code> 对 <code>R&amp;&amp;</code> 类型的变量进行调用——则返回真，否则返回假。</p><p>不过，在 C++20 里，上面这个条件我是不需要这么写出来的。有一个现成的概念可用，这么写就行了：</p><pre><code class=\"language-c++\">template &lt;\n  template &lt;typename, typename&gt;\n  class OutContainer = vector,\n  typename F, class R&gt;\n  requires range&lt;R&gt;\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs);\n</code></pre><p>如你所见，我今天第二次用了 <code>range</code> 这个概念。究竟什么是 range？我们留到下一讲再说。</p><h2>内容小结</h2><p>今天我们讨论了 C++20 里可以说是最重要的新功能——概念。概念可以用来对模板参数进行约束，能取代 SFINAE，产生更好、更可读的代码。</p><p>注意本讲的内容并非一个形式化的描述，请你在阅读了本讲的内容之后，再对照参考资料 [6] 的内容看一下更严格的描述，然后再回过头来读一下例子，来加深你对本讲内容的理解。</p><h2>课后思考</h2><p>请结合自己的 C++ 项目，考虑一下，“概念”可以为开发具体带来哪些好处？反过来，负面的影响又可能会是什么？</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Bjarne Stroustrup, “Concepts: the future of generic programming, or how to design good concepts and use them well”. <a href=\"http://www.stroustrup.com/good_concepts.pdf\">http://www.stroustrup.com/good_concepts.pdf</a> </span></p><p><span class=\"reference\">[2] Alexander Stepanov and Paul McJones, <em>Elements of Programming</em>. Addison-Wesley, 2009. 有中文版（裘宗燕译《编程原本》，人民邮电出版社，2019 年） </span></p><p><span class=\"reference\">[3] ISO/IEC JTC1 SC22 WG21, N4549, “Programming languages — C++ extensions for concepts”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4549.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4549.pdf</a> </span></p><p><span class=\"reference\">[4] Herb Sutter et al., “Rename concepts to standard_case for C++20, while we still can”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “Standard library header &lt;concepts&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/concepts\">https://en.cppreference.com/w/cpp/header/concepts</a>. </span></p><p><span class=\"reference\">[5a] cppreference.com, “标准库头文件 &lt;concepts&gt;”. <a href=\"https://zh.cppreference.com/w/cpp/header/concepts\">https://zh.cppreference.com/w/cpp/header/concepts</a>. </span></p><p><span class=\"reference\">[6] Casey Carter et al., cmcstl2. <a href=\"https://github.com/CaseyCarter/cmcstl2\">https://github.com/CaseyCarter/cmcstl2</a> </span></p><p><span class=\"reference\">[7] cppreference.com, “Constraints and concepts”. <a href=\"https://en.cppreference.com/w/cpp/language/constraints\">https://en.cppreference.com/w/cpp/language/constraints</a> </span></p><p><span class=\"reference\">[7a] cppreference.com, “约束与概念”. <a href=\"https://zh.cppreference.com/w/cpp/language/constraints\">https://zh.cppreference.com/w/cpp/language/constraints</a> </span></p><p><span class=\"reference\">[8] cppreference.com, “std::enable_if”. <a href=\"https://en.cppreference.com/w/cpp/types/enable_if\">https://en.cppreference.com/w/cpp/types/enable_if</a> </span></p><p><span class=\"reference\">[8a] cppreference.com, “std::enable_if”. <a href=\"https://zh.cppreference.com/w/cpp/types/enable_if\">https://zh.cppreference.com/w/cpp/types/enable_if</a> </span></p><p><span class=\"reference\">[9] Andrew Sutton, “Introducing concepts”. <a href=\"https://accu.org/index.php/journals/2157\">https://accu.org/index.php/journals/2157</a> </span></p>","neighbors":{"left":{"article_title":"新春福利 | C++好书荐读","id":193086},"right":{"article_title":"29 | Ranges：无迭代器的迭代和更方便的组合","id":195553}}},{"article_id":195553,"article_title":"29 | Ranges：无迭代器的迭代和更方便的组合","article_content":"<p>你好，我是吴咏炜。</p><p>今天，我们继续上一讲开始的话题，讨论 ranges（范围）。</p><h2>Ranges 简介</h2><p>像下面这样的代码：</p><pre><code class=\"language-cpp\">#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nint main()\n{\n  using namespace std;\n  int a[] = {1, 7, 3, 6,\n             5, 2, 4, 8};\n  copy(begin(a), end(a),\n       ostream_iterator&lt;int&gt;(\n         std::cout, \" \"));\n  std::cout &lt;&lt; std::endl;\n  sort(begin(a), end(a));\n  copy(begin(a), end(a),\n       ostream_iterator&lt;int&gt;(\n         std::cout, \" \"));\n  std::cout &lt;&lt; std::endl;\n}\n</code></pre><p>你应该已经见到过好多次了。有没有觉得这个代码有点重复、有点无聊呢？尤其是里面的 <code>begin</code> 和 <code>end</code>？</p><p>很多人都留意到了迭代器虽然灵活，但不是一个足够高级的抽象——尤其是我们已经对 C 数组都可以进行基于“范围”的循环之后。如果我们把数组看作一个抽象的“范围”，我们就可以得到下面的代码：</p><pre><code class=\"language-cpp\">#include &lt;experimental/ranges/algorithm&gt;\n#include &lt;experimental/ranges/iterator&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n  using namespace std::\n    experimental::ranges;\n  int a[] = {1, 7, 3, 6,\n             5, 2, 4, 8};\n  copy(a, ostream_iterator&lt;int&gt;(\n            std::cout, \" \"));\n  std::cout &lt;&lt; std::endl;\n  sort(a);\n  copy(a, ostream_iterator&lt;int&gt;(\n            std::cout, \" \"));\n  std::cout &lt;&lt; std::endl;\n}\n</code></pre><!-- [[[read_end]]] --><p>这是真正可以编译的代码，用我们上一讲讲过的环境——最新版的 MSVC（编译命令行上需要额外加 <code>/permissive-</code> 选项）或 GCC 7+——都可以。不过，这一次即使最新版的 MSVC 也不能靠编译器本身支持 ranges 库的所有特性了：在两种环境下我们都必须使用 CMCSTL2 <span class=\"orange\">[1]</span>，也只能（在 C++20 之前临时）使用 <code>std::experimental::ranges</code> 而不是 <code>std::ranges</code>。注意我只引入了 <code>ranges</code> 名空间，而没有引入 <code>std</code> 名空间，这是因为 <code>copy</code>、<code>sort</code> 等名称同时出现在了这两个名空间里，同时引入两个名空间会在使用 <code>sort</code> 等名字时导致冲突。</p><p>这个程序的输出，当然是毫不意外的：</p><blockquote>\n<p><code>1 7 3 6 5 2 4 8</code><br>\n<code>1 2 3 4 5 6 7 8</code></p>\n</blockquote><p>下面我们看“视图”。比如下面的代码展示了一个反转的视图：</p><pre><code class=\"language-cpp\">#include &lt;experimental/ranges/algorithm&gt;\n#include &lt;experimental/ranges/iterator&gt;\n#include &lt;experimental/ranges/ranges&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n  using namespace std::\n    experimental::ranges;\n  int a[] = {1, 7, 3, 6,\n             5, 2, 4, 8};\n  copy(a, ostream_iterator&lt;int&gt;(\n            std::cout, \" \"));\n  std::cout &lt;&lt; std::endl;\n  auto r = reverse_view(a);\n  copy(r, ostream_iterator&lt;int&gt;(\n            std::cout, \" \"));\n  std::cout &lt;&lt; std::endl;\n}\n</code></pre><p>这个程序的输出是：</p><blockquote>\n<p><code>1 7 3 6 5 2 4 8</code><br>\n<code>8 4 2 5 6 3 7 1</code></p>\n</blockquote><p>为什么 <code>r</code> 是视图，而不是反向复制出的内容？我们可以在输出 <code>r</code> 之前（15行之后，16行之前）插入下面这行：</p><pre><code class=\"language-cpp\">  a[0] = 9;\n</code></pre><p>我们可以看到最后那行输出变成了：</p><blockquote>\n<p><code>8 4 2 5 6 3 7 9</code></p>\n</blockquote><p>这就证明了，<code>r</code> 没有复制 <code>a</code> 的内容。</p><p>视图的大小也不一定跟原先的“范围”一样。下面是我们在<a href=\"https://time.geekbang.org/column/article/185189\">[第 17 讲]</a> 讨论过的过滤视图在 ranges 里的实现的用法：</p><pre><code class=\"language-cpp\">  auto r =\n    filter_view(a, [](int i) {\n      return i % 2 == 0;\n    });\n</code></pre><p>拿这个来替换上面用到 <code>reverse_view</code> 的那行，我们就能得到：</p><blockquote>\n<p><code>6 2 4 8</code></p>\n</blockquote><p>这些视图还能进行组合：我们可以写 <code>reverse_view(filter_view(…))</code>。不过，在组合的情况下，下面这样的写法（使用 <code>|</code> 和视图适配器）可能更清晰些：</p><pre><code class=\"language-cpp\">  auto r = a |\n           views::filter([](int i) {\n             return i % 2 == 0;\n           }) |\n           views::reverse;\n</code></pre><p>这个程序的执行结果是：</p><blockquote>\n<p><code>8 4 2 6</code></p>\n</blockquote><p>如果你用过 Unix 的管道符，你一定会觉得这种写法非常自然、容易组合吧……</p><h2>范围相关的概念</h2><p>整个 ranges 库是基于概念来定义的。下面这张图展示了 range 相关的概念：</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/f9/e5a943a0f87d8c796fe3c78dabf524f9.png\" alt=\"\"></p><p>从图的右下角，我们可以看到上一讲讨论过的几个概念，包括 copyable 和 semiregular。再往上，我们看到了 view——视图——也看到了视图是一个 range。现在我们就先来看一下 range 和 view 的定义。</p><p>在 CMCSTL2 里，range 是这样定义的：</p><pre><code class=\"language-cpp\">template &lt;class T&gt;\nconcept _RangeImpl =\n  requires(T&amp;&amp; t) {\n    begin(static_cast&lt;T&amp;&amp;&gt;(t));\n    end(static_cast&lt;T&amp;&amp;&gt;(t));\n  };\n\ntemplate&lt;class T&gt;\nconcept range = _RangeImpl&lt;T&amp;&gt;;\n</code></pre><p>换句话说，一个 range 允许执行 <code>begin</code> 和 <code>end</code> 操作（注意这是在 <code>ranges</code> 名空间下的 <code>begin</code> 和 <code>end</code>，和 <code>std</code> 下的有些小区别）。所以，一个数组，一个容器，通常也能当作一个 range。</p><p>我们已经提到了视图，我们接下来就看一下 view 的定义：</p><pre><code class=\"language-cpp\">template &lt;class T&gt;\nconcept view =\n  range&lt;T&gt; &amp;&amp;\n  semiregular&lt;T&gt; &amp;&amp;\n  enable_view&lt;__uncvref&lt;T&gt;&gt;;\n</code></pre><p>可以看到，view 首先是一个 range，其次它是 semiregular，也就是，可以被移动和复制（对 range 没有这个要求）。然后 <code>enable_view</code> 是个实现提供的概念，它的实际要求就是，视图应该不是一个容器，可以在 O(1) 复杂度完成拷贝或移动操作。我们常用的 <code>string</code> 满足 range，不满足 view；而 <code>string_view</code> 则同时满足 range 和 view。</p><p>下面，我们看 common_range，它的意思是这是个普通的 range，对其应用 <code>begin()</code> 和 <code>end()</code>，结果是同一类型：</p><pre><code class=\"language-cpp\">template &lt;class T&gt;\nconcept common_range =\n  range&lt;T&gt; &amp;&amp;\n  same_as&lt;iterator_t&lt;T&gt;,\n          sentinel_t&lt;T&gt;&gt;;\n</code></pre><p>然后，sized_range 的意思就是这个 range 是有大小的，可以取出其大小（注意我们刚才的 <code>filter_view</code> 就是没有大小的）：</p><pre><code class=\"language-cpp\">template &lt;class T&gt;\nconcept sized_range =\n  range&lt;T&gt; &amp;&amp;\n  requires(T&amp; r) { size(r); };\n</code></pre><p>自然，output_range 的意思是这个 range 的迭代器满足输出迭代器的条件：</p><pre><code class=\"language-cpp\">template &lt;class R, class T&gt;\nconcept output_range =\n  range&lt;R&gt; &amp;&amp;\n  output_iterator&lt;iterator_t&lt;R&gt;, T&gt;;\n</code></pre><p>当然，input_range 的意思是这个 range 的迭代器满足输入迭代器的条件：</p><pre><code class=\"language-cpp\">template &lt;class T&gt;\nconcept input_range =\n  range&lt;T&gt; &amp;&amp;\n  input_iterator&lt;iterator_t&lt;T&gt;&gt;;\n</code></pre><p>再往上的这些概念，我想我就不用再啰嗦了……</p><h3>Sentinel</h3><p>我估计其他概念你理解起来应该问题不大，但 common_range 也许会让有些人迷糊：什么样的 range 会<strong>不</strong>是 common_range 呢？</p><p>答案是，有些 range 的结束点，不是固定的位置，而是某个条件：如遇到 0，或者某个谓词满足了 10 次之后……从 C++17 开始，基于范围的 for 循环也接受 <code>begin</code> 和 <code>end</code> 的结果不是同一类型了——我们把前者返回的结果类型叫 iterator（迭代器），而把后者返回的结果类型叫 sentinel（标记）。</p><p>下面展示了一个实际的例子：</p><pre><code class=\"language-cpp\">#include &lt;experimental/ranges/algorithm&gt;\n#include &lt;experimental/ranges/iterator&gt;\n#include &lt;iostream&gt;\n\nusing namespace std::experimental::\n  ranges;\n\nstruct null_sentinel {};\n\ntemplate &lt;input_iterator I&gt;\nbool operator==(I i, null_sentinel)\n{\n  return *i == 0;\n}\n\ntemplate &lt;input_iterator I&gt;\nbool operator==(null_sentinel, I i)\n{\n  return *i == 0;\n}\n\ntemplate &lt;input_iterator I&gt;\nbool operator!=(I i, null_sentinel)\n{\n  return *i != 0;\n}\n\ntemplate &lt;input_iterator I&gt;\nbool operator!=(null_sentinel, I i)\n{\n  return *i != 0;\n}\n\nint main(int argc, char* argv[])\n{\n  if (argc != 2) {\n    std::cout &lt;&lt; \"Please provide \"\n                 \"an argument!\"\n              &lt;&lt; std::endl;\n    return 1;\n  }\n  for_each(argv[1], null_sentinel(),\n           [](char ch) {\n             std::cout &lt;&lt; ch;\n           });\n  std::cout &lt;&lt; std::endl;\n}\n</code></pre><p>在这个程序里，<code>null_sentinel</code> 就是一个“空值标记”。这个类型存在的唯一意义，就是允许 <code>==</code> 和 <code>!=</code> 根据重载规则做一些特殊的事情：在这里，就是判断当前迭代器指向的位置是否为 0。上面程序的执行结果是把命令行上传入的第一个参数输出到终端上。</p><h2>概念测试</h2><p>我们现在对概念来做一下检查，看看常用的一些容器和视图满足哪些 ranges 里的概念。</p><p><img src=\"https://static001.geekbang.org/resource/image/36/5b/3628cbde0fa893b5d9df888db085c65b.png\" alt=\"\"></p><p>这张表里没有什么意外的东西。除了 view，<code>vector&lt;int&gt;</code> 满足所有的 range 概念。另外，<code>const vector&lt;int&gt;</code> 不能满足 output_range，不能往里写内容，也一切正常。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/a5/930d8b0e7d11be467eed5e12b98f0aa5.png\" alt=\"\"></p><p>这张表，同样表达了我们已知的事实：<code>list</code> 不满足 random_access_range 和 contiguous_range。</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/f4/1a575d6630dcbf2efdb5d41d229577f4.png\" alt=\"\"></p><p>这张表，说明了从 range 的角度，C 数组和 <code>vector</code> 是没啥区别的。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/e7/64c011b79225c8c4b37353ec374321e7.png\" alt=\"\"></p><p>这张就有点意思了，展示了反转视图的特点。我们可以看到它几乎和原始容器可满足的概念一样，就多了 view，少了 contiguous_range。应该没有让你感到意外的内容吧。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/71/8447ab67eefb08e389a8fabfcbeca371.png\" alt=\"\"></p><p>但过滤视图就不一样了：我们不能预知元素的数量，所以它不能满足 sized_range。</p><p><img src=\"https://static001.geekbang.org/resource/image/0f/94/0f7b3cededc2309d97e146e5cd566294.png\" alt=\"\"></p><p>我们前面说过，istream_line_reader 的迭代器是输入迭代器，所以它也只能是个 input_range。我们在设计上对 <code>begin()</code> 和 <code>end</code> 的返回值采用了相同的类型，因此它仍是个 common_range。用 take_view 可以取一个范围的前若干项，它就不是一个 commom_range 了。因为输入可能在到达预定项数之前结束，所以它也不是 sized_range。</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/08/9e77c25703ecfb51783ebbf604930708.png\" alt=\"\"></p><p>我们再来介绍一个新的视图，<code>iota_view</code>。它代表一个从某个数开始的递增序列。单参数的 <code>iota_view</code> 是无穷序列，双参数的是有限序列，从它们能满足的概念上就能看出来。这儿比较有趣的事实是，虽然 <code>iota_view(0, 5)</code> 和 <code>iota_view(0) | take(5)</code> 的结果相同，都是序列 {0, 1, 2, 3, 4}，但编译器看起来，前者比后者要多满足两个概念。这应该也不难理解。</p><h2>抽象和性能</h2><p>说了这么多，你可能还是有点好奇，那 ranges 的用途是什么呢？为了少写 <code>begin()</code> 和 <code>end()</code>？为了方便函数式编程？</p><p>当然，上面的说法都对，但最基本的目的，还是为了抽象和表达能力。我们可以看一眼下面的 Python 代码：</p><pre><code class=\"language-python\">reduce(lambda x, y: x + y,\n       map(lambda x: x * x, range(1, 101)))\n</code></pre><p>你应该不难看出，这个表达式做的是 $1^2+2^2+3^2+\\dots+100^2$。C++ 里我们该怎么做呢？</p><p>当然，手工循环是可以的：</p><pre><code class=\"language-cpp\">auto square = [](int x) {\n  return x * x;\n};\n\nint sum = 0;\nfor (int i = 1; i &lt; 101; ++i) {\n  sum += square(i);\n}\n</code></pre><p>比起 Python 的代码来，似乎上面这个写法有点啰嗦？我们试试使用 ranges：</p><pre><code class=\"language-cpp\">int sum = nvwa::reduce(\n  std::plus&lt;int&gt;(),\n  views::iota(1, 101) |\n    views::transform(\n      [](int x) { return x * x; }));\n</code></pre><p>我不知道你喜不喜欢上面这个表达方式，但它至少能在单个表达式里完成同样的功能。唯一遗憾的是，标准算法 <code>accumulate</code> 或 <code>reduce</code> 在上面不可用（没有针对 ranges 的改造），我只好拿我的非标 <code>reduce</code> <span class=\"orange\">[2]</span> 来凑凑数了。</p><p>同样重要的是，上面的代码性能很高……多高呢？看下面这行汇编输出的代码就知道了：</p><pre><code class=\"language-assembly\">movl\t$338350, -4(%rbp)\n</code></pre><h2>ranges 名空间</h2><p>我们现在再来看一下 ranges 名空间（我们目前代码里的 <code>std::experimental::ranges</code>，C++20 的 <code>std::ranges</code>）。这个名空间有 ranges 特有的内容：</p><ul>\n<li>视图（如 <code>reverse_view</code>）和视图适配器（如 <code>views::reverse</code>）</li>\n<li>ranges 相关的概念（如 <code>range</code>、<code>view</code> 等）</li>\n</ul><p>但也有些名称是从 <code>std</code> 名空间“复制”过来的，包括：</p><ul>\n<li>标准算法（如 <code>copy</code>、<code>transform</code>、<code>sort</code>、<code>all_of</code>、<code>for_each</code> 等；但是，如前面所说，没有 <code>accumulate</code> 或 <code>reduce</code>）</li>\n<li><code>begin</code> 和 <code>end</code></li>\n</ul><p><code>std::copy</code> 接受的是迭代器，而 <code>ranges::copy</code> 接受的是范围，似乎还有点道理。那 <code>begin</code> 和 <code>end</code> 呢？本来接受的参数就是一个范围啊……</p><p>Eric Niebler（Ranges TS 的作者）引入 <code>ranges::begin</code> 的目的是解决下面的代码可能产生的问题（他的例子 <span class=\"orange\">[3]</span>）：</p><pre><code class=\"language-cpp\">extern std::vector&lt;int&gt; get_data();\nauto it = std::begin(get_data());\nint i = *it; // BOOM\n</code></pre><p>注意在读取 <code>*it</code> 的时候，<code>get_data()</code> 返回的 <code>vector</code> 已经被销毁了——所以这个读取操作是未定义行为（undefined behavior）。</p><p>Eric Niebler 和 Casey Carter（CMCSTL2 的主要作者）使用了一个特殊的技巧，把 <code>begin</code> 和 <code>end</code> 实现成了有特殊约束的函数对象，使得下面这样的代码无法通过编译：</p><pre><code class=\"language-cpp\">extern std::vector&lt;int&gt; get_data();\nauto it = ranges::begin(get_data());\nint i = *it; // BOOM\n</code></pre><p>如果你对此有兴趣的话，可以看一下 CMCSTL2 里的 include/stl2/detail/range/access.hpp。</p><p>对一般的用户而言，记住 <code>ranges::begin</code> 和 <code>ranges::end</code> 是将来 <code>std::begin</code> 和 <code>std::end</code> 的更好的替代品就行了。</p><h2>一点历史</h2><p>对于标准算法里的迭代器的问题早就有人看到了，并且有不少人提出了改进的方案。最早在 2003 年，Boost.Range 就已经出现（但影响似乎不大）。Andrei Alexandresu 在 2009 年发了一篇很有影响力的文章，“Iterators must go” <span class=\"orange\">[4]</span>，讨论迭代器的问题，及他在 D 语言里实现 ranges 的经验，但在 C++ 界没有开花结果。Eric Niebler 在 2013 年开始了 range-v3 <span class=\"orange\">[5]</span> 的工作，这才是目前的 ranges 的基础。他把 ranges 写成了一个标准提案 <span class=\"orange\">[6]</span>，并在 2017 年被 ISO 出版成为正式的 Ranges TS。2018 年末，好消息传来，C++ 委员会通过了决议，Ranges 正式被并入了 C++20 的草案！</p><p><img src=\"https://static001.geekbang.org/resource/image/04/b4/04dfc0486f87f25871c5fc873d631eb4.png\" alt=\"\" title=\"图片背景来自网络\"></p><p>谁说程序员都是无趣的？这篇内容申请把 Ranges 并入 C++ 标准草案的纯技术文档 The One Ranges Proposal <span class=\"orange\">[7]</span>，开头绝对是激情四射啊。</p><h2>批评和未来</h2><p>如果我只说好的方面、问题一点不说，对于学习道路上的你，也不是件好事。最有名的对 C++ Ranges 的批评，就是 Unity 开发者 Aras Pranckevičius 发表的一篇文章 <span class=\"orange\">[8]</span>。我不完全认同文中的观点，但我觉得读一下反面的意见也很重要。</p><p>此外，C++20 里的 ranges 不是一个概念的终点。即便在 range-v3 库里，也有很多东西仍然没有进入 C++ 标准。比如，看一眼下面的代码：</p><pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;range/v3/all.hpp&gt;\n\nint main()\n{\n  std::vector&lt;int&gt; vd{1, 7, 3, 6,\n                      5, 2, 4, 8};\n  std::vector&lt;std::string&gt; vs{\n    \"one\",  \"seven\", \"three\",\n    \"six\",  \"five\",  \"two\",\n    \"four\", \"eight\"};\n  auto v =\n    ranges::views::zip(vd, vs);\n  ranges::sort(v);\n  for (auto i : vs) {\n    std::cout &lt;&lt; i &lt;&lt; std::endl;\n  }\n}\n</code></pre><p>上面的代码展示了标准 ranges 中还没有的 zip 视图，并且，zip 视图的结果还可以被排序，结果将使得原始的两个 <code>vector</code> 都重新排序。上述程序的运行结果是：</p><blockquote>\n<p><code>one</code><br>\n<code>two</code><br>\n<code>three</code><br>\n<code>four</code><br>\n<code>five</code><br>\n<code>six</code><br>\n<code>seven</code><br>\n<code>eight</code></p>\n</blockquote><p>这个非标的 range-v3 库的另外一个好处是，它不依赖于概念的支持，因而可以用在更多的环境中，包括目前还不支持概念的 Clang。</p><p>如果你希望自己尝试一下这个代码的话，需要在命令行上使用 <code>-I</code> 选项来包含 range-v3 的 include 目录，此外 MSVC 还需要几个特殊选项：</p><blockquote>\n<p><code>cl /EHsc /std:c++latest /permissive- /experimental:preprocessor …</code></p>\n</blockquote><h2>内容小结</h2><p>本讲讨论了 C++20 的又一重要特性 ranges。虽然这一特性比起 concepts 来争议要多，但无疑它展示了 C++ 语言的一些新的可能性，并可以产生非常紧凑的高性能代码。</p><h2>课后思考</h2><p>你怎么看待 ranges 和对它的批评？你会想用 ranges 吗？欢迎留言与我交流。</p><h2><span class=\"reference\">参考资料 </span></h2><p><span class=\"reference\">[1] Casey Carter et al., cmcstl2. <a href=\"https://github.com/CaseyCarter/cmcstl2\">https://github.com/CaseyCarter/cmcstl2</a> </span></p><p><span class=\"reference\">[2] 吴咏炜, nvwa/functional.h. <a href=\"https://github.com/adah1972/nvwa/blob/master/nvwa/functional.h\">https://github.com/adah1972/nvwa/blob/master/nvwa/functional.h</a> </span></p><p><span class=\"reference\">[3] Eric Niebler, “Standard ranges”. <a href=\"http://ericniebler.com/2018/12/05/standard-ranges/\">http://ericniebler.com/2018/12/05/standard-ranges/</a> </span></p><p><span class=\"reference\">[4] Andrei Alexandrescu, “Iterators must go”, <a href=\"http://accu.org/content/conf2009/AndreiAlexandrescu_iterators-must-go.pdf\">http://accu.org/content/conf2009/AndreiAlexandrescu_iterators-must-go.pdf</a> </span></p><p><span class=\"reference\">[5] Eric Niebler, range-v3. <a href=\"https://github.com/ericniebler/range-v3\">https://github.com/ericniebler/range-v3</a> </span></p><p><span class=\"reference\">[6] Eric Niebler and Casey Carter, “Working draft, C++ extensions for ranges”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf</a> </span></p><p><span class=\"reference\">[7] Eric Niebler, Casey Carter, and Christopher Di Bella, “The one ranges proposal”.  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf</a> </span></p><p><span class=\"reference\">[8] Aras Pranckevičius, “ ‘Modern’ C++ lamentations”. <a href=\"https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/\">https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/</a> ；CSDN 的翻译见 <a href=\"https://blog.csdn.net/csdnnews/article/details/86386281\">https://blog.csdn.net/csdnnews/article/details/86386281</a> </span></p>","neighbors":{"left":{"article_title":"28 | Concepts：如何对模板进行约束?","id":194005},"right":{"article_title":"30 | Coroutines：协作式的交叉调度执行","id":196785}}},{"article_id":196785,"article_title":"30 | Coroutines：协作式的交叉调度执行","article_content":"<p>你好，我是吴咏炜。</p><p>今天是我们未来篇的最后一讲，也是这个专栏正文内容的最后一篇了。我们讨论 C++20 里的又一个非常重要的新功能——协程 Coroutines。</p><h2>什么是协程？</h2><p>协程是一个很早就被提出的编程概念。根据高德纳的描述，协程的概念在 1958 年就被提出了。不过，它在主流编程语言中得到的支持不那么好，因而你很可能对它并不熟悉吧。</p><p>如果查阅维基百科，你可以看到下面这样的定义 <span class=\"orange\">[1]</span>：</p><blockquote>\n<p>协程是计算机程序的⼀类组件，推⼴了协作式多任务的⼦程序，允许执⾏被挂起与被恢复。相对⼦例程⽽⾔，协程更为⼀般和灵活……</p>\n</blockquote><p>等学完了这一讲，也许你可以明白这段话的意思。但对不了解协程的人来说，估计只能吐槽一句了，这是什么鬼？</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/f9/4d4fb4a1c16edb1087d934cd1bb7eef9.png\" alt=\"\" title=\"图片源自网络\"></p><p>很遗憾，在 C++ 里的标准协程有点小复杂。我们还是从……Python 开始。</p><pre><code class=\"language-python\">def fibonacci():\n    a = 0\n    b = 1\n    while True:\n        yield b\n        a, b = b, a + b\n</code></pre><p>即使你没学过 Python，上面这个生成斐波那契数列的代码应该也不难理解。唯一看起来让人会觉得有点奇怪的应该就是那个 <code>yield</code> 了。这种写法在 Python 里叫做“生成器”（generator），返回的是一个可迭代的对象，每次迭代就能得到一个 yield 出来的结果。这就是一种很常见的协程形式了。</p><!-- [[[read_end]]] --><p>如何使用这个生成器，请看下面的代码：</p><pre><code class=\"language-python\"># 打印头 20 项\nfor i in islice(fibonacci(), 20):\n    print(i)\n\n# 打印小于 10000 的数列项\nfor i in takewhile(\n        lambda x: x &lt; 10000,\n        fibonacci()):\n    print(i)\n</code></pre><p>这些代码很容易理解：<code>islice</code> 相当于<a href=\"https://time.geekbang.org/column/article/195553\">[第 29 讲]</a> 中的 <code>take</code>，取一个范围的头若干项；<code>takewhile</code> 则在范围中逐项取出内容，直到第一个参数的条件不能被满足。两个函数的结果都可以被看作是 C++ 中的视图。</p><p>我们唯一需要提的是，在代码的执行过程中，<code>fibonacci</code> 和它的调用代码是交叉执行的。下面我们用代码行加注释的方式标一下：</p><pre><code class=\"language-python\">a = 0  # fibonacci()\nb = 0  # fibonacci()\nyield b  # fibonacci()\nprint(i)  # 调用者\na, b = 1, 0 + 1  # fibonacci()\nyield b  # fibonacci()\nprint(i)  # 调用者\na, b = 1, 1 + 1  # fibonacci()\nyield b  # fibonacci()\nprint(i)  # 调用者\na, b = 2, 1 + 2  # fibonacci()\nyield b  # fibonacci()\nprint(i)  # 调用者\n…\n</code></pre><p>学到这儿的同学应该都知道我们在 C++ 里怎么完成类似的功能吧？我就不讲解了，直接给出可工作的代码。这是对应的 <code>fibonacci</code> 的定义：</p><pre><code class=\"language-c++\">#include &lt;iterator&gt;\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n\nclass fibonacci {\npublic:\n  class sentinel;\n  class iterator;\n  iterator begin() noexcept;\n  sentinel end() noexcept;\n};\n\nclass fibonacci::sentinel {};\n\nclass fibonacci::iterator {\npublic:\n  // Required to satisfy iterator\n  // concept\n  typedef ptrdiff_t difference_type;\n  typedef uint64_t value_type;\n  typedef const uint64_t* pointer;\n  typedef const uint64_t&amp; reference;\n  typedef std::input_iterator_tag\n    iterator_category;\n\n  value_type operator*() const\n  {\n    return b_;\n  }\n  pointer operator-&gt;() const\n  {\n    return &amp;b_;\n  }\n  iterator&amp; operator++()\n  {\n    auto tmp = a_;\n    a_ = b_;\n    b_ += tmp;\n    return *this;\n  }\n  iterator operator++(int)\n  {\n    auto tmp = *this;\n    ++*this;\n    return tmp;\n  }\n  bool\n  operator==(const sentinel&amp;) const\n  {\n    return false;\n  }\n  bool\n  operator!=(const sentinel&amp;) const\n  {\n    return true;\n  }\n\nprivate:\n  uint64_t a_{0};\n  uint64_t b_{1};\n};\n\n// sentinel needs to be\n// equality_comparable_with iterator\nbool operator==(\n  const fibonacci::sentinel&amp; lhs,\n  const fibonacci::iterator&amp; rhs)\n{\n  return rhs == lhs;\n}\nbool operator!=(\n  const fibonacci::sentinel&amp; lhs,\n  const fibonacci::iterator&amp; rhs)\n{\n  return rhs != lhs;\n}\n\ninline fibonacci::iterator\nfibonacci::begin() noexcept\n{\n  return iterator();\n}\n\ninline fibonacci::sentinel\nfibonacci::end() noexcept\n{\n  return sentinel();\n}\n</code></pre><p>调用代码跟 Python 的相似：</p><pre><code class=\"language-c++\">// 打印头 20 项\nfor (auto i :\n     fibonacci() | take(20)) {\n  cout &lt;&lt; i &lt;&lt; endl;\n}\n\n// 打印小于 10000 的数列项\nfor (auto i :\n     fibonacci() |\n       take_while([](uint64_t x) {\n         return x &lt; 10000;\n       })) {\n  cout &lt;&lt; i &lt;&lt; endl;\n}\n</code></pre><p>这似乎还行。但 <code>fibonacci</code> 的定义差异就大了：在 Python 里是 6 行有效代码，在 C++ 里是 53 行。C++ 的生产率似乎有点低啊……</p><h2>C++20 协程</h2><p>C++20 协程的基础是微软提出的 Coroutines TS（可查看工作草案 <span class=\"orange\">[2]</span>），它在 2019 年 7 月被批准加入到 C++20 草案中。目前，MSVC 和 Clang 已经支持协程。不过，需要提一下的是，目前被标准化的只是协程的底层语言支持，而不是上层的高级封装；稍后，我们会回到这个话题。</p><p>协程可以有很多不同的用途，下面列举了几种常见情况：</p><ul>\n<li>生成器</li>\n<li>异步 I/O</li>\n<li>惰性求值</li>\n<li>事件驱动应用</li>\n</ul><p>这一讲中，我们主要还是沿用生成器的例子，向你展示协程的基本用法。异步 I/O 应当在协程得到广泛采用之后，成为最能有明显收益的使用场景；但目前，就我看到的，只有 Windows 平台上有较好的支持——微软目前还是做了很多努力的。</p><p>回到 Coroutines。我们今天采用 Coroutines TS 中的写法，包括 <code>std::experimental</code> 名空间，以确保你可以在 MSVC 和 Clang 下编译代码。首先，我们看一下协程相关的新关键字，有下面三个：</p><ul>\n<li><code>co_await</code></li>\n<li><code>co_yield</code></li>\n<li><code>co_return</code></li>\n</ul><p>这三个关键字最初是没有 <code>co_</code> 前缀的，但考虑到 <code>await</code>、<code>yield</code> 已经在很多代码里出现，就改成了目前这个样子。同时，<code>return</code> 和 <code>co_return</code> 也作出了明确的区分：一个协程里只能使用 <code>co_return</code>，不能使用 <code>return</code>。这三个关键字只要有一个出现在函数中，这个函数就是一个协程了——从外部则看不出来，没有用其他语言常用的 <code>async</code> 关键字来标记（<code>async</code> 也已经有其他用途了，见<a href=\"https://time.geekbang.org/column/article/186689\">[第 19 讲]</a>）。C++ 认为一个函数是否是一个协程是一个实现细节，不是对外接口的一部分。</p><p>我们看一下用协程实现的 <code>fibonacci</code> 长什么样子：</p><pre><code class=\"language-c++\">uint64_resumable fibonacci()\n{\n  uint64_t a = 0;\n  uint64_t b = 1;\n  while (true) {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\n</code></pre><p>这个形式跟 Python 的非常相似了吧，也非常简洁。我们稍后再讨论 <code>uint64_resumable</code> 的定义，先看一下调用代码的样子：</p><pre><code class=\"language-c++\">auto res = fibonacci();\nwhile (res.resume()) {\n  auto i = res.get();\n  if (i &gt;= 10000) {\n    break;\n  }\n  cout &lt;&lt; i &lt;&lt; endl;\n}\n</code></pre><p>这个代码也非常简单，但我们需要留意 <code>resume</code> 和 <code>get</code> 两个函数调用——这就是我们的 <code>uint64_resumable</code> 类型需要提供的接口了。</p><h3>co_await、co_yield、co_return 和协程控制</h3><p>在讨论该如何定义 <code>uint64_resumable</code> 之前，我们需要先讨论一下协程的这三个新关键字。</p><p>首先是 <code>co_await</code>。对于下面这样一个表达式：</p><pre><code class=\"language-c++\">auto result = co_await 表达式;\n</code></pre><p>编译器会把它理解为：</p><pre><code class=\"language-c++\">auto&amp;&amp; __a = 表达式;\nif (!__a.await_ready()) {\n  __a.await_suspend(协程句柄);\n  // 挂起/恢复点\n}\nauto result = __a.await_resume();\n</code></pre><p>也就是说，“表达式”需要支持 <code>await_ready</code>、<code>await_suspend</code> 和 <code>await_resume</code> 三个接口。如果 <code>await_ready()</code> 返回真，就代表不需要真正挂起，直接返回后面的结果就可以；否则，执行 <code>await_suspend</code> 之后即挂起协程，等待协程被唤醒之后再返回 <code>await_resume()</code> 的结果。这样一个表达式被称作是个 awaitable。</p><p>标准里定义了两个 awaitable，如下所示：</p><pre><code class=\"language-c++\">struct suspend_always {\n  bool await_ready() const noexcept\n  {\n    return false;\n  }\n  void await_suspend(\n    coroutine_handle&lt;&gt;)\n    const noexcept {}\n  void await_resume()\n    const noexcept {}\n};\n\nstruct suspend_never {\n  bool await_ready() const noexcept\n  {\n    return true;\n  }\n  void await_suspend(\n    coroutine_handle&lt;&gt;)\n    const noexcept {}\n  void await_resume()\n    const noexcept {}\n};\n</code></pre><p>也就是说，<code>suspend_always</code> 永远告诉调用者需要挂起，而 <code>suspend_never</code> 则永远告诉调用者不需要挂起。两者的 <code>await_suspend</code> 和 <code>await_resume</code> 都是平凡实现，不做任何实际的事情。一个 awaitable 可以自行实现这些接口，以定制挂起之前和恢复之后需要执行的操作。</p><p>上面的 <code>coroutine_handle</code> 是 C++ 标准库提供的类模板。这个类是用户代码跟系统协程调度真正交互的地方，有下面这些成员函数我们等会就会用到：</p><ul>\n<li><code>destroy</code>：销毁协程</li>\n<li><code>done</code>：判断协程是否已经执行完成</li>\n<li><code>resume</code>：让协程恢复执行</li>\n<li><code>promise</code>：获得协程相关的 promise 对象（和<a href=\"https://time.geekbang.org/column/article/186689\">[第 19 讲]</a> 中的“承诺量”有点相似，是协程和调用者的主要交互对象；一般类型名称为 <code>promise_type</code>）</li>\n<li><code>from_promise</code>（静态）：通过 promise 对象的引用来生成一个协程句柄</li>\n</ul><p>协程的执行过程大致是这个样子的：</p><ol>\n<li>为协程调用分配一个协程帧，含协程调用的参数、变量、状态、promise 对象等所需的空间。</li>\n<li>调用 <code>promise.get_return_object()</code>，返回值会在协程第一次挂起时返回给协程的调用者。</li>\n<li>执行 <code>co_await promise.initial_suspsend()</code>；根据上面对 <code>co_await</code> 语义的描述，协程可能在此第一次挂起（但也可能此时不挂起，在后面的协程体执行过程中挂起）。</li>\n<li>执行协程体中的语句，中间可能有挂起和恢复；如果期间发生异常没有在协程体中处理，则调用 <code>promise.unhandled_exception()</code>。</li>\n<li>当协程执行到底，或者执行到 <code>co_return</code> 语句时，会根据是否有非 void 的返回值，调用 <code>promise.return_value(…)</code> 或 <code>promise.return_void()</code>，然后执行 <code>co_await promise.final_suspsend()</code>。</li>\n</ol><p>用代码可以大致表示如下：</p><pre><code class=\"language-c++\">  frame = operator new(…);\n  promise_type&amp; promise =\n    frame-&gt;promise;\n\n  // 在初次挂起时返回给调用者\n  auto return_value =\n    promise.get_return_object();\n\n  co_await promise\n    .initial_suspsend();\n  try {\n    执行协程体;\n    可能被 co_wait、co_yield 挂起;\n    恢复后继续执行，直到 co_return;\n  }\n  catch (...) {\n    promise.unhandled_exception();\n  }\n\nfinal_suspend:\n  co_await promise.final_suspsend();\n</code></pre><p>上面描述了 <code>co_await</code> 和 <code>co_return</code>，那 <code>co_yield</code> 呢？也很简单，<code>co_yield 表达式</code> 等价于：</p><pre><code class=\"language-c++\">co_await promise.yield_value(表达式);\n</code></pre><h3>定义 <code>uint64_resumable</code></h3><p>了解了上述知识之后，我们就可以展示一下 <code>uint64_resumable</code> 的定义了：</p><pre><code class=\"language-c++\">class uint64_resumable {\npublic:\n  struct promise_type {…};\n\n  using coro_handle =\n    coroutine_handle&lt;promise_type&gt;;\n  explicit uint64_resumable(\n    coro_handle handle)\n    : handle_(handle)\n  {\n  }\n  ~uint64_resumable()\n  {\n    handle_.destroy();\n  }\n  uint64_resumable(\n    const uint64_resumable&amp;) =\n    delete;\n  uint64_resumable(\n    uint64_resumable&amp;&amp;) = default;\n  bool resume();\n  uint64_t get();\n\nprivate:\n  coro_handle handle_;\n};\n</code></pre><p>这个代码相当简单，我们的结构内部有个 <code>promise_type</code>（下面会定义），而私有成员只有一个协程句柄。协程构造需要一个协程句柄，析构时将使用协程句柄来销毁协程；为简单起见，我们允许结构被移动，但不可复制（以免重复调用 <code>handle_.destroy()</code>）。除此之外，我们这个结构只提供了调用者需要的 <code>resume</code> 和 <code>get</code> 成员函数，分别定义如下：</p><pre><code class=\"language-c++\">bool uint64_resumable::resume()\n{\n  if (!handle_.done()) {\n    handle_.resume();\n  }\n  return !handle_.done();\n}\n\nuint64_t uint64_resumable::get()\n{\n  return handle_.promise().value_;\n}\n</code></pre><p>也就是说，<code>resume</code> 会判断协程是否已经结束，没结束就恢复协程的执行；当协程再次挂起时（调用者恢复执行），返回协程是否仍在执行中的状态。而 <code>get</code> 简单地返回存储在 promise 对象中的数值。</p><p>现在我们需要看一下 promise 类型了，它里面有很多协程的定制点，可以修改协程的行为：</p><pre><code class=\"language-c++\">struct promise_type {\n  uint64_t value_;\n  using coro_handle =\n    coroutine_handle&lt;promise_type&gt;;\n  auto get_return_object()\n  {\n    return uint64_resumable{\n      coro_handle::from_promise(\n        *this)};\n  }\n  constexpr auto initial_suspend()\n  {\n    return suspend_always();\n  }\n  constexpr auto final_suspend()\n  {\n    return suspend_always();\n  }\n  auto yield_value(uint64_t value)\n  {\n    value_ = value;\n    return suspend_always();\n  }\n  void return_void() {}\n  void unhandled_exception()\n  {\n    std::terminate();\n  }\n};\n</code></pre><p>简单解说一下：</p><ul>\n<li>结构里面只有一个数据成员 <code>value_</code>，存放供 <code>uint64_resumable::get</code> 取用的数值。</li>\n<li><code>get_return_object</code> 是第一个定制点。我们前面提到过，调用协程的返回值就是 <code>get_return_object()</code> 的结果。我们这儿就是使用 promise 对象来构造一个 <code>uint64_resumable</code>。</li>\n<li><code>initial_suspend</code> 是第二个定制点。我们此处返回 <code>suspend_always()</code>，即协程立即挂起，调用者马上得到 <code>get_return_object()</code> 的结果。</li>\n<li><code>final_suspend</code> 是第三个定制点。我们此处返回 <code>suspend_always()</code>，即使执行到了 <code>co_return</code> 语句，协程仍处于挂起状态。如果我们返回 <code>suspend_never()</code> 的话，那一旦执行了 <code>co_return</code> 或执行到协程结束，协程就会被销毁，连同已初始化的本地变量和 promise，并释放协程帧内存。</li>\n<li><code>yield_value</code> 是第四个定制点。我们这儿仅对 <code>value_</code> 进行赋值，然后让协程挂起（执行控制回到调用者）。</li>\n<li><code>return_void</code> 是第五个定制点。我们的代码永不返回，这儿无事可做。</li>\n<li><code>unhandled_exception</code> 是第六个定制点。我们这儿也不应该发生任何异常，所以我们简单地调用 <code>terminate</code> 来终结程序的执行。</li>\n</ul><p>好了，这样，我们就完成了协程相关的所有定义。有没有觉得轻松点？</p><hr><p>没有？那就对了。正如我在这一节开头说的，C++20 标准化的只是协程的底层语言支持（我上面还并不是一个非常完整的描述）。要用这些底层直接写应用代码，那是非常痛苦的事。这些接口的目标用户实际上也不是普通开发者，而是库的作者。</p><p>幸好，我们并不是没有任何高层抽象，虽然这些实现不“标准”。</p><h2>C++20 协程的高层抽象</h2><h3>cppcoro</h3><p>我们首先看一下跨平台的 cppcoro 库 <span class=\"orange\">[3]</span>，它提供的高层接口就包含了 <code>generator</code>。如果使用 cppcoro，我们的 <code>fibonacci</code> 协程可以这样实现：</p><pre><code class=\"language-c++\">#include &lt;cppcoro/generator.hpp&gt;\nusing cppcoro::generator;\n\ngenerator&lt;uint64_t&gt; fibonacci()\n{\n  uint64_t a = 0;\n  uint64_t b = 1;\n  while (true) {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\n</code></pre><p>使用 <code>fibonacci</code> 也比刚才的代码要方便：</p><pre><code class=\"language-c++\">for (auto i : fibonacci()) {\n  if (i &gt;= 10000) {\n    break;\n  }\n  cout &lt;&lt; i &lt;&lt; endl;\n}\n</code></pre><p>除了生成器，cppcoro 还支持异步任务和异步 I/O——遗憾的是，异步 I/O 目前只有 Windows 平台上有，还没人实现 Linux 或 macOS 上的支持。</p><h3>MSVC</h3><p>作为协程的先行者和 Coroutines TS 的提出者，微软在协程上做了很多工作。生成器当然也在其中：</p><pre><code class=\"language-c++\">#include &lt;experimental/generator&gt;\nusing std::experimental::generator;\n\ngenerator&lt;uint64_t&gt; fibonacci()\n{\n  uint64_t a = 0;\n  uint64_t b = 1;\n  while (true) {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\n</code></pre><p>微软还有一些有趣的私有扩展。比如，MSVC 把标准 C++ 的 <code>future</code> 改造成了 awaitable。下面的代码在 MSVC 下可以编译通过，简单地展示了基本用法：</p><pre><code class=\"language-c++\">future&lt;int&gt; compute_value()\n{\n  int result = co_await async([] {\n    this_thread::sleep_for(1s);\n    return 42;\n  });\n  co_return result;\n}\n\nint main()\n{\n  auto value = compute_value();\n  cout &lt;&lt; value.get() &lt;&lt; endl;\n}\n</code></pre><p>代码中有一个地方我需要提醒一下：虽然上面 <code>async</code> 返回的是 <code>future&lt;int&gt;</code>，但 <code>compute_value</code> 的调用者得到的并不是这个 <code>future</code>——它得到的是另外一个独立的 <code>future</code>，并最终由 <code>co_return</code> 把结果数值填充了进去。</p><h2>有栈协程和无栈协程</h2><p>我们最后需要说一下有栈（stackful）协程和无栈（stackless）协程的区别。C++ 里很早就有了有栈的协程，概念上来讲，有栈的协程跟纤程、goroutines 基本是一个概念，都是由用户自行调度的、操作系统之外的运行单元。每个这样的运行单元都有自己独立的栈空间，缺点当然就是栈的空间占用和切换栈的开销了。而无栈的协程自己没有独立的栈空间，每个协程只需要一个很小的栈帧，空间占用小，也没有栈的切换开销。</p><p>C++20 的协程是无栈的。部分原因是有栈的协程可以使用纯库方式实现，而无栈的协程需要一点编译器魔法帮忙。毕竟，协程里面的变量都是要放到堆上而不是栈上的。</p><p>一个简单的无栈协程调用的内存布局如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/66/e35d2b262c741acf40d69eedc6a5ad66.png\" alt=\"\"></p><p>可以看到，协程 C 本身的本地变量不占用栈，但当它调用其他函数时，它会使用线程原先的栈空间。在上面的函数 D 的执行过程中，协程是不可以挂起的——如果控制回到 B 继续，B 可能会使用目前已经被 D 使用的栈空间！</p><p>因此，无栈的协程牺牲了一定的灵活性，换来了空间的节省和性能。有栈的协程你可能起几千个就占用不少内存空间，而无栈的协程可以轻轻松松起到亿级——毕竟，维持基本状态的开销我实测下来只有一百字节左右。</p><p>反过来，如果无栈的协程不满足需要——比如，你的协程里需要有递归调用，并在深层挂起——你就不得不寻找一个有栈的协程的解决方案。目前已经有一些成熟的方案，比如 Boost.Coroutine2 <span class=\"orange\">[4]</span>。下面的代码展示如何在 Boost.Coroutine2 里实现 <code>fibonacci</code>，让你感受一点点小区别：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;stdint.h&gt;\n#include &lt;boost/coroutine2/all.hpp&gt;\n\ntypedef boost::coroutines2::\n  coroutine&lt;const uint64_t&gt;\n    coro_t;\n\nvoid fibonacci(\n  coro_t::push_type&amp; yield)\n{\n  uint64_t a = 0;\n  uint64_t b = 1;\n  while (true) {\n    yield(b);\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\n\nint main()\n{\n  for (auto i : coro_t::pull_type(\n         boost::coroutines2::\n           fixedsize_stack(),\n         fibonacci)) {\n    if (i &gt;= 10000) {\n      break;\n    }\n    std::cout &lt;&lt; i &lt;&lt; std::endl;\n  }\n}\n</code></pre><h2>编译器支持</h2><p>前面提到了，MSVC 和 Clang 目前支持协程。不过，它们都需要特殊的命令行选项来开启协程支持：</p><ul>\n<li>MSVC 需要 <code>/await</code> 命令行选项</li>\n<li>Clang 需要 <code>-fcoroutines-ts</code> 命令行选项</li>\n</ul><p>为了满足使用 CMake 的同学的要求，也为了方便大家编译，我把示例代码放到了 GitHub 上：<a href=\"https://github.com/adah1972/geek_time_cpp\">https://github.com/adah1972/geek_time_cpp</a></p><h2>内容小结</h2><p>本讲讨论了 C++20 里的第三个重要特性：协程。协程仍然很新，但它的重要性是毋庸置疑的——尤其在生成器和异步 I/O 上。</p><h2>课后思考</h2><p>请仔细比较第一个 <code>fibonacci</code> 的 C++ 实现和最后使用 <code>generator</code> 的 <code>fibonacci</code> 的实现，体会协程代码如果自行用状态机的方式来实现，是一件多麻烦的事情。</p><p>如果你对协程有兴趣，可以查看参考资料 <span class=\"orange\">[5]</span>，里面提供了一些较为深入的原理介绍。</p><h2><span class=\"reference\">参考资料 </span></h2><p><span class=\"reference\">[1] 维基百科, “协程”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%8D%8F%E7%A8%8B\">https://zh.wikipedia.org/zh-cn/协程</a> </span></p><p><span class=\"reference\">[2] Gor Nishanov, “Working draft, C++ extensions for coroutines”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf</a> </span></p><p><span class=\"reference\">[3] Lewis Baker, CppCoro. <a href=\"https://github.com/lewissbaker/cppcoro\">https://github.com/lewissbaker/cppcoro</a> </span></p><p><span class=\"reference\">[4] Oliver Kowalke, Boost.Coroutine2. <a href=\"https://www.boost.org/doc/libs/release/libs/coroutine2/doc/html/index.html\">https://www.boost.org/doc/libs/release/libs/coroutine2/doc/html/index.html</a> </span></p><p><span class=\"reference\">[5] Dawid Pilarski, “Coroutines introduction”. <a href=\"https://blog.panicsoftware.com/coroutines-introduction/\">https://blog.panicsoftware.com/coroutines-introduction/</a> </span></p>","neighbors":{"left":{"article_title":"29 | Ranges：无迭代器的迭代和更方便的组合","id":195553},"right":{"article_title":"加餐 | 部分课后思考题答案合集","id":197522}}},{"article_id":197522,"article_title":"加餐 | 部分课后思考题答案合集","article_content":"<p>你好，我是吴咏炜。这一讲我为你整理了本专栏部分课后思考题的答案，给你作为参考。</p><h2><a href=\"https://time.geekbang.org/column/article/169263\">第 2 讲</a></h2><p><strong>你觉得智能指针应该满足什么样的线程安全性？</strong></p><p>答：（不是真正的回答，只是描述一下标准中的智能指针的线程安全性。）</p><ol>\n<li>多个不同线程同时访问不同的智能指针（不管是否指向同一个对象）是安全的。</li>\n<li>多个不同线程同时读取同一个智能指针是安全的。</li>\n<li>多个不同线程在同一个智能指针上执行原子操作（<code>atomic_load</code> 等）是安全的。</li>\n<li>多个不同线程根据同一个智能指针创建新的智能指针（增加引用计数）是安全的。</li>\n<li>只会有一个线程最后会（在引用计数表示已经无引用时）调用删除函数去销毁存储的对象。</li>\n</ol><p>其他操作潜在是不安全的，特别是在不同的线程对同一个智能指针执行 <code>reset</code> 等修改操作。</p><h2><a href=\"https://time.geekbang.org/column/article/169268\">第 3 讲</a></h2><p><strong>为什么 <code>smart_ptr::operator=</code> 对左值和右值都有效，而且不需要对等号两边是否引用同一对象进行判断？</strong></p><p>答：我们使用值类型而非引用类型作为形参，这样实参永远会被移动（右值的情况）或复制（左值的情况），不可能和 <code>*this</code> 引用同一个对象。</p><h2><a href=\"https://time.geekbang.org/column/article/173167\">第 4 讲</a></h2><p><strong>为什么 <code>stack</code>（或 <code>queue</code>）的 <code>pop</code> 函数返回类型为 <code>void</code>，而不是直接返回容器的 <code>top</code>（或 <code>front</code>）成员？</strong></p><p>答：这是 C++98 里、还没有移动语义时的设计。如果 <code>pop</code> 返回元素，而元素拷贝时发生异常的话，那这个元素就丢失了。因而容器设计成有分离的 <code>top</code>（或 <code>front</code>）和 <code>pop</code> 成员函数，分别执行访问和弹出的操作。</p><!-- [[[read_end]]] --><p>有一种可能的设计是把接口改成 <code>void pop(T&)</code>，这增加了 <code>T</code> 必须支持默认构造和赋值的要求，在单线程为主的年代没有明显的好处，反而带来了对 <code>T</code> 的额外要求。</p><h2><a href=\"https://time.geekbang.org/column/article/174434\">第 5 讲</a></h2><p><strong>为什么大部分容器都提供了 <code>begin</code>、<code>end</code> 等方法？</strong></p><p>答：容器提供了 <code>begin</code> 和 <code>end</code> 方法，就意味着是可以迭代（遍历）的。大部分容器都可以从头到尾遍历，因而也就需要提供这两个方法。</p><p><strong>为什么容器没有继承一个公用的基类？</strong></p><p>答：C++ 不是面向对象的语言，尤其在标准容器的设计上主要使用值语义，使用公共基类完全没有用处。</p><h2><a href=\"https://time.geekbang.org/column/article/176842\">第 7 讲</a></h2><p><strong>目前这个输入行迭代器的行为，在什么情况下可能导致意料之外的后果？</strong></p><p>答：</p><pre><code class=\"language-c++\">#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include \"istream_line_reader.h\"\n\nusing namespace std;\n\nint main()\n{\n  ifstream ifs{\"test.cpp\"};\n  istream_line_reader reader{ifs};\n  auto begin = reader.begin();\n  for (auto it = reader.begin();\n    it != reader.end(); ++it) {\n    cout &lt;&lt; *it &lt;&lt; '\\n';\n  }\n}\n</code></pre><p>以上代码，因为 begin 多调用了一次，输出就少了一行……</p><p><strong>请尝试一下改进这个输入行迭代器，看看能不能消除这种意外。如果可以，该怎么做？如果不可以，为什么？</strong></p><p>答：很困难。比如，文件如果为空的话，从迭代器的行为角度，<code>begin()</code> 应该等于 <code>end()</code>——不预先读取一次的话，就无法获知这个结果。这样的改造总体看起来很不值，因此一般都不会选择这样做。</p><h2><a href=\"https://time.geekbang.org/column/article/178940\">第 10 讲</a></h2><p><strong>这讲里我们没有深入讨论赋值；请你思考一下，如果例子里改成赋值，会有什么样的变化？</strong></p><p>答：返回对象部分的讨论没有变化。对象的移动赋值操作应当实现成无异常，以确保数据不会丢失。</p><p>返回值优化在赋值情况下会失效。更一般的情况下，除非需要持续更新某个变量，比如在 <code>vector</code> 尾部追加数据，尽量对变量进行一次性赋值、不后续修改。这样的代码更容易推理，更不容易在后续修改中出错，也更能让编译器做（返回值）优化。</p><h2><a href=\"https://time.geekbang.org/column/article/179357\">第 11 讲</a></h2><p><strong>为什么说 UTF-32 处理会比较简单？</strong></p><p>答：UTF-32 下，一个字符就是一个基本的处理单位，一般不会出现一个字符跨多个处理单位的情况（UTF-8 和 UTF-16 下会发生）。</p><p><strong>你知道什么情况下 UTF-32 也并不那么简单吗？</strong></p><p>答：Unicode 下有所谓的修饰字符，用来修饰前一个字符。按 Unicode 的处理规则，这些字符应该和基本字符一起处理（如断行之类）。所以 UTF-32 下也不可以在任意单位处粗暴断开处理。</p><p><strong>哪种 UTF 编码方式空间存储效率比较高？</strong></p><p>答：视存储的内容而定。</p><p>比如，如果内容以 ASCII 为主（如源代码），那 UTF-8 效率最高。如果内容以一般的中文文本为主，那 UTF-16 效率最高。</p><h2><a href=\"https://time.geekbang.org/column/article/179363\">第 12 讲</a></h2><p><strong>为什么并非所有的语言都支持这些不同的多态方式？</strong></p><p>答：排除设计缺陷的情况，语言支持哪些多态方式，基本上取决于语言本身在类型方面的特性。</p><p>以 Python 为例，它是动态类型的语言。所以它不会有真正的静态多态。但和静态类型的面向对象语言（如 Java）不同，它的运行期多态不需要继承。没有参数化多态初看是个缺陷，但由于 Python 的动态参数系统允许默认参数和可变参数，并没有什么参数化多态能做得到而 Python 做不到的事。</p><h2><a href=\"https://time.geekbang.org/column/article/185189\">第 17 讲</a></h2><p><strong>想一想，你如何可以实现一个惰性的过滤器？</strong></p><p>答：</p><pre><code class=\"language-c++\">#include &lt;iterator&gt;\n\nusing namespace std;\n\ntemplate &lt;typename I, typename F&gt;\nclass filter_view {\npublic:\n  class iterator {\n  public:\n    typedef ptrdiff_t\n      difference_type;\n    typedef\n      typename iterator_traits&lt;\n        I&gt;::value_type value_type;\n    typedef\n      typename iterator_traits&lt;\n        I&gt;::pointer pointer;\n    typedef\n      typename iterator_traits&lt;\n        I&gt;::reference reference;\n    typedef forward_iterator_tag\n      iterator_category;\n\n    iterator(I current, I end, F cond)\n      : current_(current)\n      , end_(end)\n      , cond_(cond)\n    {\n      if (current_ != end_ &amp;&amp;\n          !cond_(*current_)) {\n        ++*this;\n      }\n    }\n    iterator&amp; operator++()\n    {\n      while (current_ != end_) {\n        ++current_;\n        if (cond_(*current_)) {\n          break;\n        }\n      }\n      return *this;\n    }\n    iterator operator++(int)\n    {\n      auto temp = *this;\n      ++*this;\n      return temp;\n    }\n    reference operator*() const\n    {\n      return *current_;\n    }\n    pointer operator-&gt;() const\n    {\n      return &amp;*current_;\n    }\n\n    bool operator==(const iterator&amp; rhs)\n    {\n      return current_ == rhs.current_;\n    }\n    bool operator!=(const iterator&amp; rhs)\n    {\n      return !operator==(rhs);\n    }\n\n  private:\n    I current_;\n    I end_;\n    F cond_;\n  };\n  filter_view(I begin, I end,\n              F cond)\n    : begin_(begin)\n    , end_(end)\n    , cond_(cond)\n  {}\n  iterator begin() const\n  {\n    return iterator(begin_, end_, cond_);\n  }\n  iterator end() const\n  {\n    return iterator(end_, end_, cond_);\n  }\n\nprivate:\n  I begin_;\n  I end_;\n  F cond_;\n};\n</code></pre><h2><a href=\"https://time.geekbang.org/column/article/185899\">第 18 讲</a></h2><p><strong>我展示了 <code>compose</code> 带一个或更多参数的情况。你觉得 <code>compose</code> 不带任何参数该如何定义？它有意义吗？</strong></p><p>答：</p><pre><code class=\"language-c++\">inline auto compose()\n{\n    return [](auto&amp;&amp; x) -&gt; decltype(auto)\n    {\n        return std::forward&lt;decltype(x)&gt;(x);\n    };\n}\n</code></pre><p>这个函数把参数原封不动地传回。它的意义相当于加法里的 0，乘法里的 1。</p><p>在普通的加法里，你可能不太需要 0；但在一个做加法的地方，如果别人想告诉你不要做任何操作，传给你一个 0 是最简单的做法。</p><p><strong>有没有可能不用 <code>index_sequence</code> 来初始化 <code>bit_count</code>？如果行，应该如何实现？</strong></p><p>答：可以，但这里有个小陷阱，目前 constexpr 要求在构造时直接初始化对象的内容。</p><pre><code class=\"language-c++\">template &lt;size_t N&gt;\nstruct bit_count_t {\n  constexpr bit_count_t()\n  {\n    for (auto i = 0U; i &lt; N; ++i) {\n      count[i] = count_bits(i);\n    }\n  }\n  unsigned char count[N]{};\n};\n\nconstexpr bit_count_t&lt;256&gt;\n  bit_count;\n</code></pre><p>也可以考虑改用 <code>std::array</code>：</p><pre><code class=\"language-c++\">std::array&lt;char, N&gt; count{};\n</code></pre><p>使用 <code>std::array</code> 的话，我们可以考虑不再需要 <code>bit_count_t</code> 结构，因为可以让 <code>get_bit_count</code> 直接返回一个 <code>std::array&lt;char, 256&gt;</code>（返回 <code>char [256]</code> 则不可行）。</p><p>到了 C++20，允许 constexpr 对象里存在平凡默认构造的成员之后，就可以去掉数组声明后的那个看似多余的初始化器 <code>{}</code> 了——但你仍需在后面初始化所有的成员。</p><p><strong>作为一个挑战，你能自行实现出 <code>make_integer_sequence</code> 吗？</strong></p><p>答 1：</p><pre><code class=\"language-c++\">template &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n\ntemplate &lt;class T&gt;\nstruct integer_sequence_ns {\n  template &lt;T N, T... Ints&gt;\n  struct integer_sequence_helper {\n    using type =\n      typename integer_sequence_helper&lt;\n        N - 1, N - 1,\n        Ints...&gt;::type;\n  };\n\n  template &lt;T... Ints&gt;\n  struct integer_sequence_helper&lt;\n    0, Ints...&gt; {\n    using type =\n      integer_sequence&lt;T, Ints...&gt;;\n  };\n};\n\ntemplate &lt;class T, T N&gt;\nusing make_integer_sequence =\n  typename integer_sequence_ns&lt;T&gt;::\n    template integer_sequence_helper&lt;\n      N&gt;::type;\n</code></pre><p>如果一开始写成 <code>template &lt;class T, T N, T... Ints&gt; struct integer_sequence_helper</code> 的话，就会遇到错误“non-type template argument specializes a template parameter with dependent type ‘T’”（非类型的模板实参特化了一个使用依赖类型的‘T’的模板形参）。这是目前的 C++ 标准所不允许的写法，改写成嵌套类形式可以绕过这个问题。</p><p>答 2：</p><pre><code class=\"language-c++\">template &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n\ntemplate &lt;class T, T N, T... Is&gt;\nauto make_integer_sequence_impl()\n{\n  if constexpr (N == 0) {\n    return integer_sequence&lt;\n      T, Is...&gt;();\n  } else {\n    return make_integer_sequence_impl&lt;\n      T, N - 1, N - 1, Is...&gt;();\n  }\n}\n\ntemplate &lt;class T, T N&gt;\nusing make_integer_sequence =\n  decltype(\n    make_integer_sequence_impl&lt;\n      T, N&gt;());\n</code></pre><p>这又是一个 <code>constexpr</code> 能简化表达的例子。</p><h2><a href=\"https://time.geekbang.org/column/article/186689\">第 19 讲</a></h2><p><strong>并发编程中哪些情况下会发生死锁？</strong></p><p>答：多个线程里，如果没有或不能事先约定访问顺序，同时进行可阻塞的资源访问，访问顺序可以形成一个环，就会引发死锁。</p><p>可阻塞的资源访问可能包括（但不限于）：</p><ul>\n<li>互斥量上的 <code>lock</code> 调用</li>\n<li>条件变量上的 <code>wait</code> 调用</li>\n<li>对线程的 <code>join</code> 调用</li>\n<li>对 <code>future</code> 的 <code>get</code> 调用</li>\n</ul><h2><a href=\"https://time.geekbang.org/column/article/193523\">第 27 讲</a></h2><p><strong>你觉得 C++ REST SDK 的接口好用吗？如果好用，原因是什么？如果不好用，你有什么样的改进意见？</strong></p><p>答：举几个可能的改进点。</p><p>C++ REST SDK 的 <code>uri::decode</code> 接口设计有不少问题：</p><ul>\n<li>最严重的，不能对 query string 的等号左边的部分进行 <code>decode</code>；只能先 <code>split_query</code> 再 <code>decode</code>，此时等号左边已经在 <code>map</code> 里，不能修改——要修改需要建一个新的 <code>map</code>。</li>\n<li>目前的实现对“+”不能重新还原成空格。</li>\n</ul><p>换个说法，目前的接口能正确处理“/search?q=query%20string”这样的请求，但不能正确处理“/search?%71=query+string”这样的请求。</p><p>应当有一个 <code>split_query_and_decode</code> 接口，同时执行分割和解码。</p><p>另外，<code>json</code> 的接口也还是不够好用，最主要是没有使用初始化列表的构造。构造复杂的 JSON 结构有点啰嗦了。</p><p><code>fstream::open_ostream</code> 缺省行为跟 <code>std::ofstream</code> 不一样应该是个 bug。应当要么修正接口（接口缺省参数里带上 <code>trunc</code>），要么修正实现（跟 <code>std::ofstream</code> 一样把 <code>out</code> 当成 <code>out|trunc</code>）。</p><h2><a href=\"https://time.geekbang.org/column/article/194005\">第 28 讲</a></h2><p><strong>“概念”可以为开发具体带来哪些好处？反过来，负面的影响又可能会是什么？</strong></p><p>答：对于代码严谨、具有形式化思维的人，“概念”是个福音，它不仅可以大量消除 SFINAE 的使用，还能以较为精确和形式化的形式在代码里写出对类型的要求，使得代码变得清晰、易读。</p><p>但反过来说，“概念”比鸭子类型更严格。在代码加上概念约束后，相关代码很可能需要修改才能满足概念的要求，即使之前在实际使用中可能已经完全没有问题。从迭代器的角度，实际使用中最小功能集是构造、可复制、<code>*</code>、前置 <code>++</code>、与 sentinel 类型对象的 <code>!=</code>（单一形式）。而为了满足迭代器概念，则要额外确保满足以下各点：</p><ul>\n<li>可默认初始化</li>\n<li>在 iterator 类型和 sentinel 类型之间，需要定义完整的四个 <code>==</code> 和 <code>!=</code> 运算符</li>\n<li>定义迭代器的标准内部类型，如 <code>difference_type</code> 等</li>\n</ul><p>以上就是今天的全部内容了，希望能对你有所帮助！如果你有更多问题，还是请你在留言区中提出，我会一一解答。</p>","neighbors":{"left":{"article_title":"30 | Coroutines：协作式的交叉调度执行","id":196785},"right":{"article_title":"结束语 | 终点已达，行程还要继续","id":198531}}},{"article_id":198531,"article_title":"结束语 | 终点已达，行程还要继续","article_content":"<p>你好，我是吴咏炜。</p><p>从去年八月底极客时间第一次找我到现在，一眨眼居然差不多半年了，时间过得也真是飞快。终于结束了这段旅程，感到轻松，感到欣然，也感到有丝丝遗憾。</p><p>轻松，是因为终于结束了被人“追债”的日子😝。记得最初我们的计划是一周拿出十几小时的时间来写专栏，但从实际结果来看，这更接近我写一篇文章所需要的时间。“后果”就是我的业余时间近乎全部搭进去了，即使我的家庭领导（你懂的），已经赦免了我的家务工作，但到了专栏更新后期，熬夜突击也在所难免。</p><p>欣然，是因为我发现写作这个过程不仅对他人有益，对我自己的知识体系也是一个极好的梳理。写作的原初目的当然是分享，看到有人能觉得我写的东西可以带来帮助，这就是一件很快乐的事。同时，写作也是写给自己，可以将知识形式化、系统化、具象化。在这个过程中，很容易发现自己的问题：我也修正了自己的一些错误的见解，部分靠自己的再学习，部分靠他人的反馈。你也应该试试这个方法，多输出、多分享，在交流中共同进步。</p><p>遗憾，是因为这个专栏我再努力，也只能覆盖 C++ 的部分重要特性。C++ 的功能要写全，恐怕得用上至少 100 讲；如果要做到对初学者友好，200 讲够不够都是个问题。但就目前的专栏定位来讲，也只能是这种以点带面的方式，引出一些最重要的 C++ 学习方向了……</p><!-- [[[read_end]]] --><p>综合来说，对于最后的成品，我还是满意的。它可以称得上我 2019-2020 的跨年心血之作——里面的内容，从文字到代码到插图，都凝结着我的辛勤和汗水。</p><p>虽然不能保证我讲述的内容完全没有错误，但我能担保内容中没有任何我已知的错误。虽然不能担保我提供的代码完全没有 bug，但我至少可以保证，我写代码和写正文是一样的正式和规范（甚至更认真），并且但凡略长的代码，我都已经仔仔细细地测试过。事实上，在查阅资料的过程中，我还看到了一些 C++ 之父的代码错误——显然，由于这种或那种的原因，他没有测试他的所有代码——而即使 C++ 之父，也做不到直接写下的代码没有 bug😈。</p><p>虽然之前已经说过，但在结束之前，我还是要再重复强调一下，如果学习专栏时遇到问题，该怎么办。</p><p>由于定位和篇幅，你不可能通过这个专栏从无到有地学会 C++，也不可能通过这个专栏从了解 C++ 变成精通 C++——后者恐怕也没有专栏能做得到。我能做到的，是给你一些指引，给你一些方向，给你分享我在这个方向上的心得和你可以进一步学习的资料。正如我在 <a href=\"https://time.geekbang.org/column/article/169177\">[开篇词]</a> 里说的，我会教你的，是让你知道某个 C++ 的功能为什么存在和应该在什么情况下使用——这是目前外面的参考资料中比较缺的。真正的熟练掌握，靠的还是你自己。“师父领进门，修行在自身。”前人不我欺也。</p><p>此外，如果你觉得有没完全看明白的地方，你应该反复看，或者过几天再重新看。根据目前的评论我发现，读漏我正文内容的同学还是有一些的——这应该是读第一遍没完全吃透的结果。这个问题不怨你，也不怨我，因为这是学习过程中的自然现象。如果一本教科书，有人读一遍之后可以全部掌握其中的内容，那要么是内容太简单了，要么他是个天才。对于大部分不是天才的我们，需要认识到这是个正常的学习过程，无需担忧和焦虑。我们需要的只是努力前行——旅程就是一个脚步一个脚步地走下来的。</p><p>最后的最后，感谢你们，我的读者！不管是你们的鼓励，还是你们的批评，都是我前进的动力，激励我把这个专栏写得更好。即便是你们提的问题，也让我明白了哪些地方我没有阐释得足够透彻。希望如果能有下次机会，我能写得更完美一点，来回报你们对我的信任和对 C++ 的热爱。</p><p>不知道为什么，写 C++ 的时候，我常常想起这首老歌：</p><blockquote>\n<p>我来唱一首歌古老的那首歌<br>\n我轻轻地唱你慢慢地和</p>\n</blockquote><p>C++ 虽然有点古老了，但在新世纪，它仍然给人历久弥新的感觉。为了理想，历经艰苦的日子是必须的，但希望我们不必哭泣，希望我们都可以欢笑着实现自己的梦想。</p><p>哦，对了，虽然 C++ 不是纯面向对象的语言，但在某些特殊的日子里，比如今天，我还是要赞美面向对象一下😂。纯代码的人生还是不完备的。所以，祝一句，情人节快乐。</p><p>我是吴咏炜，我们后会有期！</p><p><a href=\"https://jinshuju.net/f/RoxGGS\"><img src=\"https://static001.geekbang.org/resource/image/51/cd/51a6f73a5433b7347d68f924c9e3efcd.jpg\" alt=\"\"></a></p>","neighbors":{"left":{"article_title":"加餐 | 部分课后思考题答案合集","id":197522},"right":{"article_title":"结课问卷获奖用户名单","id":204716}}},{"article_id":204716,"article_title":"结课问卷获奖用户名单","article_content":"<p>你好！</p><p>截至今天，本专栏的结课问卷就回收完毕了，十分感谢你的参与。现在我们来公布一下获奖用户名单。</p><p>在这里，我首先要感谢各位同学给我们的反馈，你们的声音可以促使我们精益求精。在这些反馈中，我们看到了很多非常有价值的信息，也收获了很多的支持与肯定。在此，我们精选出了反馈最为具体、丰富，最有实际价值的 5 位用户，送出“极客时间超大鼠标垫”，或者“价值 99 元的极客时间课程阅码”。中奖名单如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/47/9f820af6e197f690454825c41d785847.jpg\" alt=\"\"></p><p>恭喜这 5 位同学，也再次感谢所有参与调研的同学。希望大家今后还能多多支持，给予宝贵意见。</p><p>最后，除了公布中奖名单以外，我还要和你同步一件事情。为了方便你编译，目前，本专栏可编译的完整示例代码已经放在 <a href=\"https://github.com/adah1972/geek_time_cpp\">GitHub</a> 上。如果你使用 CMake，还可以用它来生成你使用的平台所需要的工程文件。</p><p>专栏的结束是另一种开始，后续我们会和吴咏炜老师继续迭代、优化专栏内容，你可以持续关注。如果你有任何问题，欢迎在留言区中提出。</p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"结束语 | 终点已达，行程还要继续","id":198531},"right":{"article_title":"第二季回归｜拿下Vim，让编程效率神器为我所用","id":263667}}},{"article_id":263667,"article_title":"第二季回归｜拿下Vim，让编程效率神器为我所用","article_content":"<p>你好，我是吴咏炜。</p><p>今年 2 月，我们这门 C++ 课程结课。5个月后，我给你带来了一个全新的课程：Vim 实用技巧必知必会。</p><p>在咱 C++ 课程里，我分享过 Larry Wall（拉里 · 沃尔）所说的程序员的三大美德：懒惰，急切，傲慢（laziness, impatience, hubris）。正是这些美德，驱动我们不断地追求效率和极致，而 Vim 就恰恰是这样一个效率利器。我想通过这门新课，和你一起享受 Vim 带来的技术乐趣。</p><p>那么 Vim 真的这么厉害吗？它到底好在哪里呢？根据我自己的使用经验，除了高效之外，Vim 还有以下三大优势：</p><ul>\n<li>Vim 是一个完全跨平台的编辑器</li>\n<li>Vim 是一个高度可定制、可扩展的编辑器</li>\n<li>Vim 有着良好的生态环境</li>\n</ul><p>不过，比起很多“开箱即用”的编辑器，Vim 是有一定的学习曲线的。这一点你不用担心，我会尽量多讲原理，而不是枯燥地讲解命令。不得不讲命令的时候，我会使用图片和动画，让你能对相关内容有一个直观的理解。</p><p>对于很多 Vim 的命令，我们是需要形成“肌肉记忆”的；我们不需要死记硬背，但需要多看、多练，熟能生巧，在学习过程中自然而然就掌握了使用 Vim 的技巧。</p><p>在这个课程中，我会基于目前最新的 Vim 8.2 来讲解 Vim 的功能。学完后，你将获得：</p><!-- [[[read_end]]] --><ul>\n<li>即学即用的 Vim 高频命令</li>\n<li>定制自己专属的 Vim 环境</li>\n<li>利用 Vim 脚本和插件实现常用功能</li>\n<li>Vim 高阶用法和技巧</li>\n</ul><p>如果你正在使用Vim，期待和你在课程里探讨更多Vim的可能性。如果你还没有用过Vim，希望这门课能为你打开一个全新的效率世界。</p><p>现在，课程已经上线了。我为你申请了老用户福利，一张 15 元专属优惠券，可与限时优惠叠加使用，到手仅需 ¥64，建议尽早使用。</p><p>点击下方图片即可进入新课程试读，期待与你在Vim课程里继续切磋！</p><p><a href=\"https://time.geekbang.org/column/intro/324?utm_term=zeusE5AJR&amp;utm_source=app&amp;utm_medium=geektime&amp;utm_campaign=diyiji&amp;utm_content=0720\"><img src=\"https://static001.geekbang.org/resource/image/b9/d6/b90c9c03f317ec3f7e07fe82defbc9d6.jpg\" alt=\"\"></a></p>","neighbors":{"left":{"article_title":"结课问卷获奖用户名单","id":204716},"right":{"article_title":"期末测试 | 对于现代C++，你掌握了多少呢？","id":239062}}},{"article_id":239062,"article_title":"期末测试 | 对于现代C++，你掌握了多少呢？","article_content":"<p>你好，我是吴咏炜。</p><p>《现代C++实战30讲》这个专栏已经完结有段时间了，很庆幸啊，依然能收到很多留言，与我交流技术。为认真学习的你点赞，也很感谢你的支持！</p><p>为了让你更好地检测自己的学习成果，我特意做了一套期末测试题。题目共有20道，满分为100分，快来检测一下吧！</p><p><a href=\"http://time.geekbang.org/quiz/intro?act_id=136&exam_id=293\"><img src=\"https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png?wh=1142*201\" alt=\"\"></a></p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"第二季回归｜拿下Vim，让编程效率神器为我所用","id":263667},"right":{"article_title":"旅程再启｜那些关于C++的新认知","id":489407}}},{"article_id":489407,"article_title":"旅程再启｜那些关于C++的新认知","article_content":"<p>你好，我是吴咏炜。</p><p>在专栏结束了两年之后，我决定对专栏进行一些续写，重启这段旅程。</p><p>在这两年的时间里，通过项目、学习和教学，我对 C++ 也有了一些新的认识。一些之前觉得没必要讲的，现在觉得非常有用、值得讲一讲；也有些技巧，就是自己在这段时间里新学会的。不管哪种情况，我觉得跟我的专栏读者分享一下都很有意义。</p><p>由于目前计划的篇幅没有原先那么多，我不打算新起一个专栏。对于老读者，这就算是一个新年福利吧。同时，既然不是新专栏，我也给自己减轻一点更新的压力，就不做一周三次那种更新了。续写的部分会进行不定期更新，间隔大致会在两周左右。当然，在这种情况下，我希望我新写的内容能够更精益求精，能帮助你在 C++ 上再上一层楼，人人都成为 C++ 高手😉。</p><p>好，闲话就到这里。旅途再见。</p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"期末测试 | 对于现代C++，你掌握了多少呢？","id":239062},"right":{"article_title":"31｜new和delete背后：分配函数和释放函数","id":489409}}},{"article_id":489409,"article_title":"31｜new和delete背后：分配函数和释放函数","article_content":"<p>你好，我是吴咏炜。</p><p>有一个我之前没讲、但挺有意思的话题是 <code>new</code> 和 <code>delete</code> 行为的定制。这件事情我很久很久以前就做过 <span class=\"orange\">[1]</span>，没往专栏里写的最主要原因是，这实际是 C++98 就有的高级技巧，不属于现代 C++。不过，在目前续写的内容里，我就不再拘泥必须新了，既然这是 C++ 里现在仍然需要的技巧，那就还是介绍一下。何况，这部分在现代 C++ 里还是有点新内容的。</p><h2>最常用的分配和释放函数</h2><p>在<a href=\"https://time.geekbang.org/column/article/169225\">第 1 讲</a>，我提到过，当我们使用 <code>new</code> 和 <code>delete</code> 来创建和销毁对象时，实际发生的事情还是比较多的（如果忘了的话，可以去复习一下）。其中，分配内存和释放内存的操作是通过 <code>operator new</code> 和 <code>operator delete</code> 函数完成的。在最简单的 <code>new</code> 和 <code>delete</code> 形式里，我们使用的是以下两个函数：</p><pre><code class=\"language-cpp\">void* operator new(size_t size);\nvoid operator delete(void* ptr) noexcept;\n</code></pre><p><code>operator new</code> 和 <code>operator delete</code> 函数通常就被称为分配函数（allocation function）和释放函数（deallocation function）。</p><p>需要注意 <code>operator new</code> 是可能抛出异常的，而 <code>operator delete</code> 则不会抛出异常，被标为 noexcept。这和我们通常不允许在析构函数中抛出异常是完全一致的。</p><!-- [[[read_end]]] --><p>但这远不是这两个函数的所有形式。最典型情况，我们对于数组形式的分配（如 <code>pArray = new Obj[42]</code>）和释放（如 <code>delete[] pArray</code>），有专门的分配和释放函数：</p><pre><code class=\"language-cpp\">void* operator new[](size_t size);\nvoid operator delete[](void* ptr) noexcept;\n</code></pre><p>这些函数的默认实现都很简单，大致相当于：</p><pre><code class=\"language-cpp\">void* operator new(size_t size)\n{\n  void* ptr = malloc(size);\n  if (ptr == nullptr) {\n    throw bad_alloc();\n  }\n  return ptr;\n}\n\nvoid operator delete(void* ptr) noexcept\n{\n  free(ptr);\n}\n\nvoid* operator new[](size_t size)\n{\n  return operator new(size);\n}\n\nvoid operator delete[](void* ptr) noexcept\n{\n  operator delete(ptr);\n}\n</code></pre><p>即，这些函数最后会转到 C 标准库里的 <code>malloc</code> 和 <code>free</code> 上，但是，分配函数在内存分配失败时的默认行为是抛异常，而非返回空指针。</p><p>你可能会想，为什么要这么中转一次呢，直接调用 <code>malloc</code> 和 <code>free</code> 不行吗？原因也很简单，这样一个中间层就是一个定制点，我们可以通过提供自己的 <code>operator new</code> 和 <code>operator delete</code> 函数来修改内存的分配和释放行为，而非直接调用 <code>malloc</code> 和 <code>free</code>。当用户不提供 <code>operator new</code> 和 <code>operator delete</code> 函数时，<code>new</code> 和 <code>delete</code> 就会调用标准库提供的版本；否则，用户提供的 <code>operator new</code> 和 <code>operator delete</code> 函数就会被使用。</p><p>具体的实现机制根据平台不同而不同。比如，在 Linux 上标准库的分配和释放函数由 libstdc++.so 共享库提供，只要链接过程中在 <code>-lstdc++</code> 之前的目标文件或库文件里有分配和释放函数出现，它们就会比标准库的分配和释放函数有更高的优先权，会被所有用到分配和释放函数的地方调用，包括 libstdc++ 自身。</p><p>不过，需要留意的是，用户提供的分配和释放函数仍需跟标准的分配和释放函数有同样的接口，包括形式和语义。特别是：</p><ul>\n<li>分配函数不应返回空指针，而应使用 <code>std::bad_alloc</code> 异常表示内存分配失败</li>\n<li>释放函数不允许抛出异常</li>\n</ul><p>举一个具体的例子，<code>make_shared</code> 函数会调用 <code>operator new</code>，并期待内存分配失败时会抛出异常。如果你自己提供的 <code>operator new</code> 替换版本抛出了异常，那 <code>make_shared</code> 也会有正常的失败行为；而如果你提供的 <code>operator new</code> 替换版本返回了空指针，那程序一般就会因为访问空指针而崩溃了——虽然我不能担保所有标准库的行为都是这样，但这样的行为至少是完全符合 C++ 标准的。</p><h2>布置分配和释放函数</h2><p>为了应对一些更加灵活的内存分配和释放场景，特别是考虑到有些环境完全不允许使用异常，C++ 里有所谓的布置（placement）<code>new</code> 和对应的分配和释放函数。我们可以在 <code>new</code> 时传递额外的特殊参数，编译器则会把这些额外参数传给 <code>operator new</code>，并利用重载机制找到正确的分配函数 <span class=\"orange\">[2]</span>。</p><p>它的最常见形式在标准库的头文件 <new> 中已经定义了：</new></p><pre><code class=\"language-cpp\">struct nothrow_t {\n  explicit nothrow_t() = default;\n};\n\nextern const nothrow_t nothrow;\n\nvoid* operator new(\n  size_t size,\n  const nothrow_t&amp;) noexcept;\nvoid* operator new[](\n  size_t size,\n  const nothrow_t&amp;) noexcept;\n</code></pre><p>这样，当我们使用 <code>new(std::nothrow) Obj</code> 这样的形式时，编译器会产生对 <code>operator new(size_t, const nothrow_t&amp;)</code> 的调用，而这个函数就不会抛出异常了——它会跟 <code>malloc</code> 一样，在内存分配失败时返回空指针。</p><p>讲到这里，你可能会疑惑了：我说到了布置分配函数和释放函数，但似乎我们并不需要布置释放函数啊——确实 C++ 里也没有 <code>delete(nothrow) ptr</code> 这样的语法。单单对于无异常编程的场景，布置释放函数确实意义不大。但作为一种通用机制，C++ 的设计者需要考虑其他的应用场景；特别是，当布置分配函数成功而构造函数失败的情况。回想我们讲过的 <code>new Circle(…)</code> 的过程：</p><pre><code class=\"language-cpp\">{\n  void* temp = operator new(sizeof(circle));\n  try {\n    circle* ptr =\n      static_cast&lt;circle*&gt;(temp);\n    ptr-&gt;circle(…);\n    return ptr;\n  }\n  catch (...) {\n    operator delete(ptr);\n    throw;\n  }\n}\n</code></pre><p>对于普通的 <code>new Obj</code>，在构造函数发生异常时编译器会自动调用 <code>operator delete(void*)</code>。那对于 <code>new(placementTag) Obj</code> 呢？</p><p>我想你应该已经猜到了，编译器会产生一个对 <code>operator delete(ptr, placementTag)</code> 的调用。如果对应的 <code>operator delete</code> 重载不存在，那编译器则不会产生对 <code>operator delete</code> 的调用。此时，如果相应的 <code>operator new</code> 确实分配了内存的话，我们就有了内存泄漏。所以，通常我们提供布置分配函数时，都需要提供对应的布置释放函数，来应对这种情况。</p><p>事实上，标准库对布置分配函数都提供了对应的布置释放函数，即使在布置释放函数什么事都不需要做的时候。而编译器通常也会对用户只提供布置分配函数而没有提供布置释放函数的情况进行告警。</p><h3>不分配内存的布置分配和释放函数</h3><p>除了 <code>nothrow</code> 之外，另外一种常见的布置分配和释放函数的定义如下（简洁起见，我略去了数组版本）：</p><pre><code class=\"language-cpp\">inline void*\noperator new(size_t,\n             void* ptr) noexcept\n{ return ptr; }\n\ninline void\noperator delete(void*,\n                void*) noexcept\n{}\n</code></pre><p>根据这种形式，我们可以写出下面这样的代码，把对象构造在一个已经存在的缓冲区上：</p><pre><code class=\"language-cpp\">shape* create_shape(void* buffer,\n                    size_t size,\n                    shape_type type)\n{\n  …\n  switch (type) {\n  case shape_type::circle:\n    assert(size &gt;= sizeof(circle));\n    return new(buffer) circle();\n  case shape_type::triangle:\n    assert(size &gt;= sizeof(triangle));\n    return new(buffer) triangle();\n  case shape_type::rectangle:\n    assert(size &gt;= sizeof(rectangle));\n    return new(buffer) rectangle();\n  …\n  }\n}\n\nshape_type type = …;\nchar buffer[200];\nauto ptr = create_shape(\n  buffer, sizeof buffer, type);\n// 使用 ptr\nptr-&gt;~shape();\n</code></pre><p>在这个 <code>create_shape</code> 的实现里，我们不在堆上创建对象，而是在一个现有的缓冲区上创建对象。这时候 <code>operator new(size_t, void*)</code> 这个重载就能用得上了，虽然它只是简单地返回缓冲区的地址。显然，释放函数确实不需要做任何事情；但是，我们仍需用 <code>ptr-&gt;~shape()</code> 这样的形式显式地在缓冲区失效前对对象进行析构。</p><p>另外注意，跟大部分其他分配函数和释放函数不同，这些函数是不能被用户提供的版本替换的。</p><h2>内存对齐的分配和释放函数</h2><p>在 C++11 之前，C++ 要产生特殊的对象对齐，只能使用编译器厂商提供的特殊说明符。比如，要把一个结构体按 32 字节对齐，在 GCC 下我们需要这样写：</p><pre><code class=\"language-cpp\">struct S {\n  float v[8];\n} __attribute__((aligned(32)));\n</code></pre><p>到了 MSVC，我们就得写成：</p><pre><code class=\"language-cpp\">__declspec(align(32)) struct S {\n  float v[8];\n};\n</code></pre><p>这当然不那么令人满意。所幸，这个问题到了 C++11 就有了很大的缓解，我们可以使用 <code>alignas</code> 关键字来跨平台地处理这个问题了：</p><pre><code class=\"language-cpp\">struct alignas(32) S {\n  float v[8];\n};\n</code></pre><p>但在 C++17 之前，这样的结构体碰到 <code>new</code> 和 <code>delete</code> 依然会有问题，因为 <code>new</code> 和 <code>delete</code> 没有任何机制来处理内存对齐问题。如果你用了 <code>new S</code> 这样的表达式，结果的对齐仍然不会考虑结构体的对齐要求，而只是实现里的默认对齐值，通常是 8 或 16——你没有一种通用的办法来进行控制。</p><p>C++17 对此的解决方式是引入了一堆新的使用 <code>std::align_val_t</code> 的分配和释放函数。<code>align_val_t</code> 是一个枚举类，目的是给对齐值一个强类型。标准库提供的相关分配和释放函数有以下这些（<span class=\"orange\">[3] 和 [4]</span>）：</p><pre><code class=\"language-cpp\">void* operator new(\n  size_t size, align_val_t al);\nvoid* operator new[](\n  size_t size, align_val_t al);\nvoid* operator new(\n  size_t size, align_val_t al,\n  const nothrow_t&amp;) noexcept;\nvoid* operator new[](\n  size_t size, align_val_t al,\n  const nothrow_t&amp;) noexcept;\nvoid operator delete(\n  void* ptr,\n  align_val_t al) noexcept;\nvoid operator delete[](\n  void* ptr,\n  align_val_t al) noexcept;\nvoid operator delete(\n  void* ptr, align_val_t al,\n  const nothrow_t&amp;) noexcept;\nvoid operator delete[](\n  void* ptr, align_val_t al,\n  const nothrow_t&amp;) noexcept;\n</code></pre><p>如果我们写出 <code>new S</code> 这样的表达式，在 C++17 里就会自动产生一个 <code>operator new(sizeof(S), std::align_val_t{32})</code> 这样的调用。系统的默认实现，或者用户提供的替换实现，都必须提供相应的对齐保证，对于 <code>new S</code> 可以保证返回的指针的二进制表示的最低 5 位为 0。</p><p>参考资料 <span class=\"orange\">[6]</span> 里展示了一个可以直接被分配函数和释放函数调用的函数实现（C++17 提供的 <code>aligned_alloc</code> 目前在 MSVC 下没有实现，因为 Windows 下无法提供内存对齐的高效 <code>free</code> 实现 <span class=\"orange\">[5]</span>）。</p><h2>替换分配和释放函数</h2><p>我前面已经提过，用户可以替换标准库提供的大部分分配和释放函数。作为一种可以适用多种场景、可灵活扩展的语言，我们可能出于以下的理由来替换分配和释放函数：</p><ul>\n<li>用来适配特定平台或环境的内存管理器</li>\n<li>用来对内存进行跟踪和排错</li>\n<li>用来实现内存池</li>\n<li>……</li>\n</ul><p>第一种情况要根据特定的环境来考虑，这里没法展开。其他两种情况，我们后续会进行讨论。参考资料 <span class=\"orange\">[7]</span> 里提供了一个我从 2004 年开始写的内存泄漏检测器，只要把这个文件链接到你的项目中，程序即可在退出时检查是否发生了 <code>new</code>/<code>delete</code> 不匹配导致的内存泄漏。它的原理在 <span class=\"orange\">[1]</span> 中进行了讨论。我们后面也会讨论一个更新的内存泄漏检测器的实现。</p><p>在替换分配和释放函数时，有一个小细节需要注意一下。对于最普通的 <code>operator new(size_t)</code>，我们一般应考虑同时提供 <code>operator delete(void*)</code> 和 <code>operator delete(void*, size_t)</code>。如果不提供的话，至少 GCC 会对此进行报警（当使用了 <code>-Wextra</code> 告警选项时）。</p><p>C++ 标准里规定，如果同时提供了这两个释放函数的话，编译器会优先选择带 <code>size_t</code> 参数的重载——从理论上讲，利用 <code>size_t</code> 大小参数可以获得更高的性能。Andrei Alexandrescu 更是争辩只用指针的释放函数是一个设计错误。不过，业界的惯性是巨大的。由于 Unix 和 C 的内存管理基本上是基于 <code>malloc</code>/<code>free</code> 的模式，目前对 <code>operator delete(void*, size_t)</code> 的实现（包括标准库里的实现）也基本上只是转发到 <code>operator delete(void*)</code> 而已。</p><h3>类特定的分配和释放函数</h3><p>分配和释放函数并不一定只能进行全局的替换。我们完全可以只对某一个类（如 <code>Obj</code>）替换它的分配和释放函数，这样，只有 <code>new Obj</code> 和 <code>delete pObj</code> 这样的表达式才会使用对应的分配和释放函数。代码如下所示：</p><pre><code class=\"language-cpp\">class Obj {\npublic:\n  …\n  static void* operator new(size_t);\n  static void operator delete(\n    void* ptr) noexcept;\n};\n</code></pre><p>你可能想，是不是可以用类特定的分配和释放函数来实现一个内存池呢？毕竟，一个类的分配大小是固定的，应该会提供很多便利性。回答是：也对，也不对。</p><p>对的原因是，以上推理本身没有问题。事实上，我在十几年前就尝试过这样的实现 <span class=\"orange\">[8]</span>。</p><p>不对的原因是，目前大部分代码里已经不再直接使用 <code>new</code> 和 <code>delete</code> 来创建和销毁对象了。<code>make_shared</code> 函数会一次性分配对象和引用计数的空间，减少内存分配和释放的次数，因而类特定的 <code>operator new</code> 和 <code>operator delete</code> 不会被使用。<code>list</code> 和 <code>map</code> 这样的容器会把对象所需的空间和结点相关的其他信息一起分配，因而类特定的 <code>operator new</code> 和 <code>operator delete</code> 也不会被使用。而 <code>vector</code> 这样的容器会一次性分配多个对象所需的空间，同样不会使用类特定的 <code>operator new</code> 和 <code>operator delete</code>。</p><p>因此，总体来说，类特定的分配和释放函数在现代 C++ 里已经成了一个比较鸡肋的功能。我们也就不多展开讨论了。</p><p>当然，我们需要定制内存分配和释放行为的需求仍然在。对于容器，我们是有办法的，因为容器的分配器参数（<code>Allocator</code>）就是用来解决这个问题的。这个我们放在下一讲进行讨论。</p><h2>内容小结</h2><p>今天我们讨论了 <code>new</code> 和 <code>delete</code> 背后的一个细节，分配函数和释放函数。标准库里实现了这些函数，同时也允许用户对其进行替换，来定制程序的行为。</p><h2>课后思考</h2><p>考虑一下，用户通过 <code>new Obj</code> 得到的指针和 <code>operator new</code> 返回的指针相同吗？通过 <code>new Obj[n]</code> 得到的指针和 <code>operator new[]</code> 返回的指针呢？</p><p>欢迎留言和我分享你的观点。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] 吴咏炜, “A cross-platform memory leak detector”. <a href=\"http://wyw.dcweb.cn/leakage.htm\">http://wyw.dcweb.cn/leakage.htm</a></span></p><p><span class=\"reference\">[2] cppreference.com, “new expression”. <a href=\"https://en.cppreference.com/w/cpp/language/new\">https://en.cppreference.com/w/cpp/language/new</a></span></p><p><span class=\"reference\">[2a] cppreference.com, “new 表达式”. <a href=\"https://zh.cppreference.com/w/cpp/language/new\">https://zh.cppreference.com/w/cpp/language/new</a></span></p><p><span class=\"reference\">[3] cppreference.com, “operator new, operator new[]”. <a href=\"https://en.cppreference.com/w/cpp/memory/new/operator_new\">https://en.cppreference.com/w/cpp/memory/new/operator_new</a></span></p><p><span class=\"reference\">[3a] cppreference.com, “operator new, operator new[]”. <a href=\"https://zh.cppreference.com/w/cpp/memory/new/operator_new\">https://zh.cppreference.com/w/cpp/memory/new/operator_new</a></span></p><p><span class=\"reference\">[4] cppreference.com, “operator delete, operator delete[]”. <a href=\"https://en.cppreference.com/w/cpp/memory/new/operator_delete\">https://en.cppreference.com/w/cpp/memory/new/operator_delete</a></span></p><p><span class=\"reference\">[4a] cppreference.com, “operator delete, operator delete[]”. <a href=\"https://zh.cppreference.com/w/cpp/memory/new/operator_delete\">https://zh.cppreference.com/w/cpp/memory/new/operator_delete</a></span></p><p><span class=\"reference\">[5] Microsoft, “&lt;cstdlib&gt;”. <a href=\"https://docs.microsoft.com/en-us/cpp/standard-library/cstdlib\">https://docs.microsoft.com/en-us/cpp/standard-library/cstdlib</a></span></p><p><span class=\"reference\">[6] 吴咏炜, “aligned_memory.cpp”. <a href=\"https://github.com/adah1972/nvwa/blob/master/nvwa/aligned_memory.cpp\">https://github.com/adah1972/nvwa/blob/master/nvwa/aligned_memory.cpp</a></span></p><p><span class=\"reference\">[7] 吴咏炜, “debug_new.cpp”. <a href=\"https://github.com/adah1972/nvwa/blob/master/nvwa/debug_new.cpp\">https://github.com/adah1972/nvwa/blob/master/nvwa/debug_new.cpp</a></span></p><p><span class=\"reference\">[8] 吴咏炜, “Design and implementation of a static memory pool”. <a href=\"http://wyw.dcweb.cn/static_mem_pool.htm\">http://wyw.dcweb.cn/static_mem_pool.htm</a></span></p>","neighbors":{"left":{"article_title":"旅程再启｜那些关于C++的新认知","id":489407},"right":{"article_title":"32｜容器里的内存管理：分配器","id":491227}}},{"article_id":491227,"article_title":"32｜容器里的内存管理：分配器","article_content":"<p>你好，我是吴咏炜。</p><p>上一讲里我们讨论了 C++ 里内存管理的基本工具，分配和释放函数。今天，我们来讨论一下容器里管理内存的机制——分配器（allocator）。</p><h2>一点点历史</h2><p>从网上可以找到的 SGI STL 的文档 <span class=\"orange\">[1]</span> 中能够看到，在 C++ 标准化之前，STL 已经引入了分配器的概念，并且还引入了多种分配器，为不同的使用场景进行优化：</p><ul>\n<li><code>alloc</code>：线程安全的默认分配器；默认对小于 128 字节的分配要求使用内存池，超过则使用 <code>malloc_alloc</code></li>\n<li><code>pthread_alloc</code>：每线程使用独立内存池的分配器</li>\n<li><code>single_client_alloc</code>：线程不安全的快速分配器</li>\n<li><code>malloc_alloc</code>：调用 <code>malloc</code> 和 <code>free</code> 来分配和释放内存的分配器</li>\n</ul><p>分配器的目的是分离对象的构造和内存分配。显然，这种方式把内存分配的决策交给了容器（而非对象），带来了很大的灵活性，性能上也有好处，因此较早的 C++ 标准库的实现也都沿袭了 SGI STL 里的这些分配器。</p><p>不过，随着时间的发展，大家也慢慢放弃了 SGI STL 实现里的这些不同的分配器，而只使用 C++ 标准里定义的 <code>std::allocator</code> 了。除了标准里定义的分配器和 SGI STL 的接口不同外，一个很重要的原因恐怕是分配器是容器类型的一部分，因此使用不同分配器的容器是不同的类型：一个要求 <code>vector&lt;int&gt;&amp;</code> 作为形参类型的函数，是不能接受 <code>vector&lt;int, single_client_alloc&lt;int&gt; &gt;</code> 作为实参类型的。这个问题要到 C++17 引入多态分配器（<code>polymorphic_allocator</code>）才算部分得到解决。</p><!-- [[[read_end]]] --><p>在 SGI STL 的实现里，分配器需要提供两个静态成员函数：</p><ul>\n<li><code>static void* allocate(size_t n)</code></li>\n<li><code>static void deallocate(void* p, size_t n)</code></li>\n</ul><p>这跟我们上一讲讨论的分配和释放函数非常相似，只除了一点——这里的 <code>deallocate</code> 是可以看到释放的内存块的大小的。这当然对性能很有好处：有了它，我们可以很方便地根据内存块的大小来实现内存池。另外需要注意的一个细节是 <code>allocate</code> 和 <code>deallocate</code> 都是静态成员函数，因此 SGI STL 里的分配器只有全局状态，不能根据实例来区分状态。</p><p>C++98 的分配器里最重要的成员函数同样是 <code>allocate</code> 和 <code>deallocate</code>，但形式和语义都进行了修改，并且不再是静态成员函数，因而理论上它们可以拥有非全局的状态。可惜的是，“尽管不要求自定义分配器为无状态，标准库中是否及如何支持分配器是实现定义的。若实现不支持使用不相等的分配器值，则这种使用可能导致实现定义的运行时错误或未定义行为” <span class=\"orange\">[2]</span>。也就是说，在 C++98 的年代里，你最好使用跟 SGI STL 分配器一样不携带状态的分配器，否则可能有兼容性问题。</p><p>C++98 的分配器里另外一个问题是有点过度设计了。分配器不仅要负责对象的内存分配和释放，还要负责构造和析构——分配器需要有成员函数 <code>construct</code> 和 <code>destroy</code>。这个功能不能说一点用都没有（比如，你可以用它来跟踪某种对象在容器中被构造了多少次），但用处真的不大，跟分配器的关系也有点远。</p><p>从 C++11 开始，在 <code>allocator_traits</code> 的帮助下，我们终于可以进一步抛开一些不必要的细节，在保留向后兼容性的同时，简单而快速地实现出自己需要的分配器。分配器也明确规定了<strong>可以</strong>有自己的状态。下面，我们就以 C++17 里的分配器要求为基础来讨论一下分配器的实现。</p><h2>标准分配器</h2><p>标准分配器 <code>std::allocator</code> 是一个非常简单的分配器。下面，我们就一起看一个标准分配器的示例实现，来了解一下分配器里的必要成员：</p><pre><code class=\"language-cpp\">template &lt;class T&gt;\nclass allocator {\npublic:\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using value_type = T;\n\n  using is_always_equal = true_type;\n  using propagate_on_container_move_assignment =\n    true_type;\n\n  template &lt;class U&gt;\n  struct rebind {\n    using other = allocator&lt;U&gt;;\n  };\n\n  allocator() = default;\n\n  template &lt;class U&gt;\n  allocator(\n    const allocator&lt;U&gt;&amp;) noexcept\n  {}\n\n  T* allocate(size_t n)\n  {\n    return static_cast&lt;T*&gt;(\n      ::operator new(n *\n                     sizeof(T)));\n  }\n\n  void deallocate(T* p,\n                  size_t n) noexcept\n  {\n    ::operator delete(p);\n  }\n};\n</code></pre><p>头三个类型别名基本上永远这样写，不需要修改。把 <code>is_always_equal</code> 定义为 <code>true_type</code>，意味着这个分配器是没有内部状态的，所有的标准分配器都相等。类似地，我们把 <code>propagate_on_container_move_assignment</code> 定义为 <code>true_type</code>，意味着在容器移动的时候目标容器可以取得源内存的所有权，这样可以高效地进行移动（否则目标容器即使在移动赋值时仍然只能对所有元素逐个构造或赋值）。类似的特征成员还有 <code>propagate_on_container_copy_assignment</code> 和 <code>propagate_on_container_swap</code>，不过这两个我们取默认值 <code>false_type</code> 就行（这些特征的详细说明请参考 <span class=\"orange\">[2]</span>）。</p><p>上一讲我们提到类特定的分配和释放函数的一个大问题是，当对象放到容器里的时候，对象的内存空间一般是和所需的其他数据一起分配的。以 GCC 11 标准库的 <code>std::set</code> 为例：当你创建 <code>set&lt;Obj&gt;</code> 的时候，结点的真正类型是 <code>std::_Rb_tree_node&lt;Obj&gt;</code>，而用户对象则存储在这个结点对象的内存里。因此，类特定的分配和释放函数对此是无效的。</p><p>分配器解决这个问题的方式是 <code>rebind</code>（重新绑定）成员类模板。以 <code>set&lt;Obj&gt;</code> 为例，它的默认模板参数规定了默认分配器是 <code>allocator&lt;Obj&gt;</code>，在 <code>set</code> 的实现里实际使用的分配器类型最终会变成 <code>allocator&lt;Obj&gt;::rebind&lt;_Rb_tree_node&lt;Obj&gt;&gt;::other</code>，用这个分配器分配出来的内存大小就是红黑树的结点大小，而不是用户对象的大小了。</p><p>标准分配器没有数据成员，所以我们使用缺省的默认构造函数就可以了。我们需要显式声明缺省的默认构造函数，是因为我们还有另外一个构造函数，一个可以接受使用其他模板参数的 <code>std::allocator</code> 的构造函数。它也不需要实际做任何事情。</p><p>真正需要干活的，就是 <code>allocate</code> 和 <code>deallocate</code> 函数了。跟 SGI STL 的分配器不同，标准库里的分配器是知道自己要为什么类型分配内存的，所以 <code>allocate</code> 的参数不是要分配内存的对象的大小，而是要分配内存的对象的数量。在这个最简单的 <code>std::allocator</code> 里，那就是简单地计算出所需分配的内存的大小，然后调用全局的 <code>operator new</code> 来分配内存了。类似地，<code>deallocate</code> 会得到需要释放的指针和这个指针指向的对象的数量。由于目前我们的实现只是简单地调用 <code>operator delete</code> 来释放内存，数量这个参数也就不使用了。</p><h3>分配器特征</h3><p>我上面给出的 <code>allocator</code> 跟目前 C++17 里的标准分配器还是有点小区别，最主要就是在 C++17 里标准分配器仍然有 <code>construct</code> 和 <code>destroy</code> 等成员，虽然它们已经是不必要的了。以这两个成员函数为例，它们的定义非常简单：</p><pre><code class=\"language-cpp\">template &lt;class T&gt;\nclass allocator {\npublic:\n  …\n  template &lt;typename U,\n            typename... Args&gt;\n  void\n  construct(U* p, Args&amp;&amp;... args) noexcept(\n    std::is_nothrow_constructible&lt;\n      U, Args...&gt;::value)\n  {\n    ::new((void*)p) U(\n      std::forward&lt;Args&gt;(args)...);\n  }\n\n  template &lt;typename U&gt;\n  void destroy(U* p) noexcept(\n    std::is_nothrow_destructible&lt;\n      U&gt;::value)\n  {\n    p-&gt;~U();\n  }\n};\n</code></pre><p>相信你在学过了完美转发（<a href=\"https://time.geekbang.org/column/article/169268\">第 3 讲</a>）、type traits（<a href=\"https://time.geekbang.org/column/article/181608\">第 13 讲</a>）、可变模板（<a href=\"https://time.geekbang.org/column/article/185899\">第 18 讲</a>）和分配函数（<a href=\"https://time.geekbang.org/column/article/489409\">上一讲</a>）之后，理解上面的代码应该已经没什么问题了。唯一需要略加说明一下的是，<code>noexcept</code> 说明里的编译期布尔表达式是用来计算当前函数是否会抛出异常的。这样，如果能用 <code>Args...</code> 来无异常地构造 <code>U</code> 对象，那 <code>construct</code> 函数也能保证不抛异常；如果 <code>U</code> 的析构能够不抛异常，那 <code>destroy</code> 函数也能保证不抛异常。</p><p>这两个函数在 C++17 里被标为废弃，在 C++20 里被正式移除。我们的替代方案，就是在分配器没有提供某个成员的时候，可以通过分配器特征（<code>allocator_traits</code>）提供默认版本。基本技巧就是我们在<a href=\"https://time.geekbang.org/column/article/181636\">第 14 讲</a>讨论的 SFINAE。比如，在 GCC 的头文件 bits/alloc_traits.h 你可以找到别名模板 <code>__has_construct</code>，就是用来检测分配器是不是有参数形式匹配的 <code>construct</code> 成员函数。略去 <code>noexcept</code> 的处理，<code>allocator_traits</code> 里对 <code>construct</code> 的处理大致如下：</p><pre><code class=\"language-cpp\">template &lt;typename Alloc&gt;\nstruct allocator_traits {\n  …\n  template &lt;typename T,\n            typename... Args&gt;\n  using __has_construct = …;\n  template &lt;typename T,\n            typename... Args&gt;\n  static enable_if_t&lt;\n    __has_construct&lt;T,\n                    Args...&gt;::value&gt;\n  construct(Alloc&amp; a, T* p,\n            Args&amp;&amp;... args)\n  { // Alloc 里面有 construct 的情况\n    a.construct(\n      p, forward&lt;Args&gt;(args)...);\n  }\n  template &lt;typename T,\n            typename... Args&gt;\n  static enable_if_t&lt;\n    !__has_construct&lt;T,\n                     Args...&gt;::value&gt;\n  construct(Alloc&amp; a, T* p,\n            Args&amp;&amp;... args)\n  { // Alloc 里面没有 construct 的情况\n    new(p) T(forward&lt;Args&gt;(args)...);\n  }\n};\n</code></pre><p>这样，我们在拥有某个分配器 <code>Alloc</code>、它的实例 <code>a</code> 和某对象的目的地址 <code>p</code>，并需要构造一个该对象的时候，只要调用 <code>allocator_traits&lt;Alloc&gt;::construct(a, p, …)</code> 即可。<code>allocator_traits</code> 会根据分配器里是否有成员函数 <code>construct</code> 来决定是否要使用某种特殊的方式来构造对象。</p><p>对于其他可能缺失的成员的处理也大致如此。</p><h2>多态分配器</h2><p>我们前面已经提到，分配器是容器的类型的一部分，因而同种容器有不同的分配器也被视作不同的类型。如果我们在代码中使用了不同的分配器，又希望忽略分配器的不同，特别是在函数的形参之中，那多态分配器就有了用武之地。</p><p>在多态分配器里，把内存管理的功能放在一个抽象类 <code>memory_resource</code>（内存资源；<span class=\"orange\">[3]</span>）里面。它提供下面这三个主要接口：</p><ul>\n<li><code>void* allocate(size_t bytes, size_t alignment = alignof(max_align_t));</code></li>\n<li><code>void deallocate(void* p, size_t bytes, size_t alignment = alignof(max_align_t));</code></li>\n<li><code>bool is_equal(const memory_resource&amp; other) const noexcept;</code></li>\n</ul><p>可以看到，这个接口又回到了 SGI STL 那种纯粹的内存分配的样子。不过，里面加上了新的对齐参数，默认值是跟平台最大的标量类型一致。另外，专门有一个接口用来多态地检查两个 <code>memory_resource</code> 是否相等。</p><p>这三个接口都是需要子类来“实现”的。但这三个函数本身不是虚函数——它们会调用前面加上 <code>do_</code> 前缀的保护成员函数，这才是子类里需要覆盖的。一个简单能实际干活的子类可能长这个样子：</p><pre><code class=\"language-cpp\">class new_delete_alloc_resource\n  : public pmr::memory_resource {\nprotected:\n  void* do_allocate(\n    size_t bytes,\n    size_t alignment) override\n  {\n    return ::operator new(\n      bytes, align_val_t{alignment});\n  }\n\n  void do_deallocate(\n    void* p, size_t bytes,\n    size_t alignment) override\n  {\n    ::operator delete(\n      p, align_val_t{alignment});\n  }\n\n  bool do_is_equal(\n    const pmr::memory_resource&amp;\n      other) const noexcept override\n  {\n    return dynamic_cast&lt;\n      const new_delete_alloc_resource*&gt;(\n      &amp;other);\n  }\n};\n</code></pre><p>也就是说，我们调用全局的 <code>operator new</code> 和 <code>operator delete</code> 来分配和释放内存；而任何两个 <code>new_delete_alloc_resource</code> 都被视作相等，因此我们只需要使用 <code>dynamic_cast</code> 检查 <code>other</code> 也是个 <code>new_delete_alloc_resource</code> 就可以了。</p><p>另外，<code>pmr</code> 名空间里也提供了针对两个 <code>memory_resource</code> 的相等和不等运算符。相等定义为：</p><pre><code class=\"language-cpp\">inline bool operator==(\n  const memory_resource&amp; a,\n  const memory_resource&amp; b) noexcept\n{\n  return &amp;a == &amp;b || a.is_equal(b);\n}\n</code></pre><p>即，两个 <code>memory_resource</code> 是同一个，或者 <code>is_equal</code> 函数返回真。</p><p>不等运算符从 C++20 开始能根据相等运算符自动提供，在 C++20 之前总是定义成相等运算符的否操作（<code>!(a == b)</code>）。</p><p>我们定义的 <code>new_delete_alloc_resource</code> 是一个 <code>memory_resource</code>，我们需要把这个 <code>memory_resource</code> 注入到 <code>polymorphic_allocator</code>（多态分配器；<span class=\"orange\">[4]</span>）里才能真正使用。<code>polymorphic_allocator</code> 里面只保存一个 <code>memory_resource</code> 的指针，它的成员函数基本上也只是转发调用 <code>memory_resource</code> 的成员函数。向 <code>polymorphic_allocator</code> 注入的方式有两种：</p><ol>\n<li>\n<p>调用 <code>polymorphic_allocator</code> 的默认构造函数。这相当于调用 <code>pmr::get_default_resource</code> <span class=\"orange\">[5]</span> 函数来获得系统默认的内存资源的指针，并使用该指针来调用下面这个构造函数。</p>\n</li>\n<li>\n<p>调用使用 <code>memory_resource</code> 指针的单参数 <code>polymorphic_allocator</code> 构造函数。这个指针会被记录下来，供后面的成员函数使用。</p>\n</li>\n</ol><p>对于第一种情况，我们多半需要使用函数 <code>pmr::set_default_resource</code> <span class=\"orange\">[6]</span> 来修改默认的内存资源。默认值是 <code>new_delete_resource()</code> <span class=\"orange\">[7]</span> 返回的 <code>memory_resource</code> 指针，使用 <code>new</code> 和 <code>delete</code> 来进行内存分配和释放，功能上像我上面定义的 <code>new_delete_alloc_resource</code>。注意这一修改是全局的，会影响所有后面的 <code>polymorphic_allocator</code> 的默认构造，因而存在潜在的多线程冲突问题。</p><p>无论是上面哪种情况，程序员都需要确保内存资源对象在多态分配器的存续期间也一直存在，否则即会导致未定义行为。因此，内存资源对象常常会被实现为一个单件，如标准库中 <code>new_delete_resource</code> 和 <code>null_memory_resource</code> <span class=\"orange\">[8]</span> 函数返回的内存资源对象就是如此。</p><p>不过，我们如果小心管理内存的话，生命期更短的对象也是可以的。标准库提供的内存池内存资源 <span class=\"orange\">[9]</span>、<span class=\"orange\">[10]</span> 和单调缓冲区内存资源 <span class=\"orange\">[11]</span>，就展示了一些更大的灵活性。下面是使用单线程无保护内存池 <span class=\"orange\">[10]</span> 的一个例子：</p><pre><code class=\"language-cpp\">pmr::unsynchronized_pool_resource\n  res;\npmr::polymorphic_allocator&lt;int&gt;\n  a{&amp;res};\n\n{\n  set&lt;int, less&lt;int&gt;,\n      pmr::polymorphic_allocator&lt;int&gt;&gt;\n    s(a);\n  // 使用 s，会自动使用内存池\n} // s 的生命周期不可长于 res\n</code></pre><p>到这里，你应该已经看到多态内存池的强大功能了。不过，有一个使用多态内存池的后果不知道你留意到了没有：跟把 <code>propagate_on_container_move_assignment</code> 设为 <code>false_type</code> 一样，移动的行为可能会发生变化。使用默认分配器时，如果你把一个 <code>vector</code> 移动赋值到另外一个 <code>vector</code>，编译器不会产生元素对象移动的代码，因为只需要调整一下 <code>vector</code> 本身的指针就可以了。而现在只有在分配器相等的情况下才能这样做了；在不相等时，就只能两个 <code>vector</code> 各自使用分配器分配内存，然后把源 <code>vector</code> 里面的元素逐个移动过去……</p><p>此外，使用分配器的标准容器在 <code>pmr</code> 名空间下都存在别名模板：我们可以使用 <code>std::pmr::set&lt;int&gt;</code>，而不是又臭又长的 <code>std::set&lt;int, std::less&lt;int&gt;, std::pmr::polymorphic_allocator&lt;int&gt;&gt;</code>。这让我们在容器中使用多态分配器会方便很多。</p><p>最后再补充一句，使用多态分配器是一个系统工程，毕竟 <code>std::vector&lt;int&gt;</code> 和 <code>std::pmr::vector&lt;int&gt;</code> 仍然是两个不同的类型。这也是目前多态分配器仍没有被广泛使用的主要原因之一吧。</p><h2>内容小结</h2><p>本讲我们详细讲解了分配器这一概念，包括标准前的 SGI STL 分配器、标准的分配器、分配器特征和多态分配器。这些功能一起为内存管理提供了极大的灵活性。</p><h2>课后思考</h2><p>请阅读一下你使用的 C++ 标准库里的分配器相关源码，并考虑一下洋葱原则在相关设计里的体现。有任何问题或想吐槽的地方，欢迎留言和我分享。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] SGI, “Standard Template Library programmer’s guide”. <a href=\"https://web.archive.org/web/20140805212355/http://www.sgi.com/tech/stl/\">https://web.archive.org/web/20140805212355/http://www.sgi.com/tech/stl/</a> 原本属于 SGI 网站的一部分，后属于惠普分拆出来的 HPE；HPE 在 2018 年初宣布将其下线，目前只能通过 Internet Archive 访问——在国内直接访问可能有问题</span></p><p><span class=\"reference\">[2] cppreference.com, “C++ named requirements: Allocator”. <a href=\"https://en.cppreference.com/w/cpp/named_req/Allocator\">https://en.cppreference.com/w/cpp/named_req/Allocator</a></span></p><p><span class=\"reference\">[2a] cppreference.com, “C++ 具名要求：分配器 (Allocator)”. <a href=\"https://zh.cppreference.com/w/cpp/named_req/Allocator\">https://zh.cppreference.com/w/cpp/named_req/Allocator</a></span></p><p><span class=\"reference\">[3] cppreference.com, “std::pmr::memory_resource”. <a href=\"https://en.cppreference.com/w/cpp/memory/memory_resource\">https://en.cppreference.com/w/cpp/memory/memory_resource</a></span></p><p><span class=\"reference\">[3a] cppreference.com, “std::pmr::memory_resource”. <a href=\"https://zh.cppreference.com/w/cpp/memory/memory_resource\">https://zh.cppreference.com/w/cpp/memory/memory_resource</a></span></p><p><span class=\"reference\">[4] cppreference.com, “std::pmr::polymorphic_allocator”. <a href=\"https://en.cppreference.com/w/cpp/memory/polymorphic_allocator\">https://en.cppreference.com/w/cpp/memory/polymorphic_allocator</a></span></p><p><span class=\"reference\">[4a] cppreference.com, “std::pmr::polymorphic_allocator”. <a href=\"https://zh.cppreference.com/w/cpp/memory/polymorphic_allocator\">https://zh.cppreference.com/w/cpp/memory/polymorphic_allocator</a></span></p><p><span class=\"reference\">[5] cppreference.com, “std::pmr::get_default_resource”. <a href=\"https://en.cppreference.com/w/cpp/memory/get_default_resource\">https://en.cppreference.com/w/cpp/memory/get_default_resource</a></span></p><p><span class=\"reference\">[5a] cppreference.com, “std::pmr::set_default_resource”. <a href=\"https://zh.cppreference.com/w/cpp/memory/set_default_resource\">https://zh.cppreference.com/w/cpp/memory/set_default_resource</a></span></p><p><span class=\"reference\">[6] cppreference.com, “std::pmr::set_default_resource”. <a href=\"https://en.cppreference.com/w/cpp/memory/set_default_resource\">https://en.cppreference.com/w/cpp/memory/set_default_resource</a></span></p><p><span class=\"reference\">[6a] cppreference.com, “std::pmr::set_default_resource”. <a href=\"https://zh.cppreference.com/w/cpp/memory/set_default_resource\">https://zh.cppreference.com/w/cpp/memory/set_default_resource</a></span></p><p><span class=\"reference\">[7] cppreference.com, “std::pmr::new_delete_resource”. <a href=\"https://en.cppreference.com/w/cpp/memory/new_delete_resource\">https://en.cppreference.com/w/cpp/memory/new_delete_resource</a></span></p><p><span class=\"reference\">[7a] cppreference.com, “std::pmr::new_delete_resource”. <a href=\"https://zh.cppreference.com/w/cpp/memory/new_delete_resource\">https://zh.cppreference.com/w/cpp/memory/new_delete_resource</a></span></p><p><span class=\"reference\">[8] cppreference.com, “std::pmr::null_memory_resource”. <a href=\"https://en.cppreference.com/w/cpp/memory/null_memory_resource\">https://en.cppreference.com/w/cpp/memory/null_memory_resource</a></span></p><p><span class=\"reference\">[8a] cppreference.com, “std::pmr::null_memory_resource”. <a href=\"https://zh.cppreference.com/w/cpp/memory/null_memory_resource\">https://zh.cppreference.com/w/cpp/memory/null_memory_resource</a></span></p><p><span class=\"reference\">[9] cppreference.com, “std::pmr::synchronized_pool_resource”. <a href=\"https://en.cppreference.com/w/cpp/memory/synchronized_pool_resource\">https://en.cppreference.com/w/cpp/memory/synchronized_pool_resource</a></span></p><p><span class=\"reference\">[9a] cppreference.com, “std::pmr::synchronized_pool_resource”. <a href=\"https://zh.cppreference.com/w/cpp/memory/synchronized_pool_resource\">https://zh.cppreference.com/w/cpp/memory/synchronized_pool_resource</a></span></p><p><span class=\"reference\">[10] cppreference.com, “std::pmr::unsynchronized_pool_resource”. <a href=\"https://en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource\">https://en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource</a></span></p><p><span class=\"reference\">[10a] cppreference.com, “std::pmr::unsynchronized_pool_resource”. <a href=\"https://zh.cppreference.com/w/cpp/memory/unsynchronized_pool_resource\">https://zh.cppreference.com/w/cpp/memory/unsynchronized_pool_resource</a></span></p><p><span class=\"reference\">[11] cppreference.com, “std::pmr::monotonic_buffer_resource”. <a href=\"https://en.cppreference.com/w/cpp/memory/monotonic_buffer_resource\">https://en.cppreference.com/w/cpp/memory/monotonic_buffer_resource</a></span></p><p><span class=\"reference\">[11a] cppreference.com, “std::pmr::monotonic_buffer_resource”. <a href=\"https://zh.cppreference.com/w/cpp/memory/monotonic_buffer_resource\">https://zh.cppreference.com/w/cpp/memory/monotonic_buffer_resource</a></span></p>","neighbors":{"left":{"article_title":"31｜new和delete背后：分配函数和释放函数","id":489409},"right":{"article_title":"33｜性能测试的正确姿势：性能、时间和优化","id":496791}}},{"article_id":496791,"article_title":"33｜性能测试的正确姿势：性能、时间和优化","article_content":"<p>你好，我是吴咏炜。</p><p>在上一讲讲完后，原本计划是要聊一聊内存池的。不过，要说内存池的好坏，就得讨论性能，而之前并没有专门讲过性能测试这个话题。鉴于这个问题本身有一定的复杂性，我们还是先专门用一讲讨论一下性能测试的相关问题。</p><h2>意外的测试结果</h2><p>假设你想测试一下，<code>memset</code> 究竟有没有性能优势。于是，你写下了下面这样的测试代码：</p><pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n\nint main()\n{\n  constexpr int LOOPS = 10000000;\n  char buf[80];\n  clock_t t1;\n  clock_t t2;\n\n  t1 = clock();\n  for (int i = 0; i &lt; LOOPS; ++i) {\n    memset(buf, 0, sizeof buf);\n  }\n  t2 = clock();\n  printf(\"%g\\n\", (t2 - t1) * 1.0 /\n                   CLOCKS_PER_SEC);\n\n  t1 = clock();\n  for (int i = 0; i &lt; LOOPS; ++i) {\n    for (size_t j = 0;\n         j &lt; sizeof buf; ++j) {\n      buf[j] = 0;\n    }\n  }\n  t2 = clock();\n  printf(\"%g\\n\", (t2 - t1) * 1.0 /\n                   CLOCKS_PER_SEC);\n}\n</code></pre><!-- [[[read_end]]] --><p>然后你运行一下，啊哈，使用 <code>memset</code> 要快出 50 倍以上！</p><blockquote>\n<p><code>0.044433</code><br>\n<code>2.53513</code></p>\n</blockquote><p>好奇如你，也许就会想到，开启优化会不会有区别呢？于是，你加上了 <code>-O2</code> 命令行选项。在某些编译器上，你可能会对类似下面的结果目瞪口呆的：</p><blockquote>\n<p><code>2e-06</code><br>\n<code>1e-06</code></p>\n</blockquote><p><code>memset</code> 更慢？优化比不优化快了一百万倍？编译器这是疯掉了吗？😱</p><hr><p>到了这里，我们需要复习一下<a href=\"https://time.geekbang.org/column/article/186708\">第 20 讲</a>里关于内存模型和优化的这两句话：</p><blockquote>\n<p>为了优化的必要，编译器是可以调整代码的执行顺序的。唯一的要求是，程序的“可观测”外部行为是一致的。</p>\n</blockquote><p>当时我这么写是要说明，单线程下正确的行为可能到了多线程就有问题。但从性能测试的角度，即使单线程也一样会遇到鬼！编译器非常聪明，它看到了：你往内存里写数据了，又没有使用写到内存的数据；同时这是本地变量，你也没有把变量的引用或指针传到其他地方去。所以，外界不会观测到数据的改变。没人看到的东西，干吗需要存在？于是乎，编译器就把写内存的代码彻底优化没了，没了……</p><p>你模模糊糊想起来，<code>volatile</code> 关键字可以影响编译器优化。那加上这个关键字是不是有效呢？经过一番折腾，你把代码改成了下面这个样子：</p><pre><code class=\"language-cpp\">  volatile char buf[80];\n  …\n  for (int i = 0; i &lt; LOOPS; ++i) {\n    memset(const_cast&lt;char*&gt;(buf),\n           0, sizeof buf);\n  }\n  …\n</code></pre><p>运行之后，可能得到下面这样的结果：</p><blockquote>\n<p><code>0.104638</code><br>\n<code>0.467247</code></p>\n</blockquote><p>哈，这就合理多了！看起来，我们可以得出结论，<code>memset</code> 确实比手工填充数据要快不少啊。</p><hr><p>不过，这个结论真的正确吗？</p><p>答案为否。</p><p><code>volatile</code> 关键字确实阻止了编译器优化。但这回它反向影响了。<code>volatile</code> 在 C++ 里的语义是，严格按照代码的指示对内存进行读写：你写一次，编译器就产生相应写的代码；你读一次，编译器就产生相应读的代码——一个不多，一个不少。这就导致了对内存操作的性能劣化。通常，你只在进行内存映射的输入输出时才有这么用的必要。</p><p>如果不用 <code>volatile</code>，那编译器至少在理论上是可以对上面的代码做出更好的优化的。我们把 <code>buf</code> 改成一个普通的全局变量，就能测到一个更接近真实的效果了。我们可以看到，GCC 和 Clang 都做出了更好的优化，对 <code>memset</code> 和循环清零产生了完全相同的代码。GCC 在 Core i7 架构（<code>-march=corei7</code>）上产生的汇编代码如下（参见 <a href=\"https://godbolt.org/z/xeohT4v1P\">https://godbolt.org/z/xeohT4v1P</a>）：</p><pre><code class=\"language-assembly\">pxor    xmm0, xmm0\nmovaps  XMMWORD PTR buf[rip], xmm0\nmovaps  XMMWORD PTR buf[rip+16], xmm0\nmovaps  XMMWORD PTR buf[rip+32], xmm0\nmovaps  XMMWORD PTR buf[rip+48], xmm0\nmovaps  XMMWORD PTR buf[rip+64], xmm0\n</code></pre><p>也就是说，编译器洞察了你要做的事情是往 <code>buf</code> 里写入 80 个零，因而采取了最高效的方式，一次写 16 个零，连写五次，根本就没有循环了……</p><h2>如何进行性能测试</h2><p>我上面给出了答案，但我忽略了一些测试细节。很遗憾，这个问题真的有点复杂。我们现在再回过来讨论一下。</p><h3>内存屏障问题</h3><p>使用全局变量并不意味着我们一定就能测到真实数据。以上面的这个测试为例，虽然编译器看到我们往全局变量写入，就一定不可能把写入完全忽略掉，但它完全可能会做一些写入的合并。事实上，实测下来 Clang 就做了写入的合并，因此测试的结果数据看起来比 GCC 和 MSVC 要漂亮很多。从测试上面两种写法的区别上讲，问题还不算大，但如果我们想拿这个数据来计算代码的性能数据的话，那就要了命了。</p><p>一种可能的解法是加入内存屏障，告诉编译器到现在为止的内存修改都得给我完成了。全局锁就是一种通用的内存屏障，但在上面的代码里加入全局锁的话，加解锁的开销就会完全掩盖我们要测试部分的开销了。每种处理器架构都有自己的内存屏障指令，这比 C++ 或操作系统的锁要轻量一点，但对于我们上面的测试来讲，仍然是重了（约 10 倍的性能下降）。每一种编译器，基本上也都有非标准的轻量级内存屏障指令，只影响编译器优化，而不影响 CPU 的处理性能。</p><p>最后一种方式看起来最有希望，但遗憾的是，在我们上面的例子里，加入内存屏障本身会影响 GCC 产生的代码。仅针对目前的代码，我们可以写出下面这样一个内存屏障的函数：</p><pre><code class=\"language-cpp\">#ifdef _MSC_VER\n#include &lt;intrin.h&gt;\n#endif\n\ninline void memory_fence()\n{\n#ifdef _MSC_VER\n  _ReadWriteBarrier();\n#elif defined(__clang__)\n  __asm__ __volatile__(\"\" ::: \"memory\");\n#endif\n}\n</code></pre><p>然后我们在测试代码后调用这个函数，确保对内存的写入会生效。注意我们仍需使用全局变量作为写入目标才行。</p><p>这种解法的问题是，它实在太脆弱了。从原理上来讲，它能不能工作并没有任何人可以保证。对于一个新的编译器，代码很可能会无效；对于当前工作的编译器的一个新版本，代码也可能会变为无效……</p><p>目前最可靠也最跨平台的解决方案仍然是用锁。如果想使用锁，我们需要有一种比 <code>clock()</code> 精度高得多的测量时间的办法。</p><h3>时间测量问题</h3><p>不同的平台有不同的时间测量函数。具体的细节我就不讨论了，直接给出我的测试结果。</p><p>Linux：</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/db/b3e38cdc0aa80fc3595cd13b8f5b45db.jpg?wh=1596x816\" alt=\"\"></p><p>Windows：</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/b6/4d14382c890b228aec051e3f1f1865b6.jpg?wh=1598x1010\" alt=\"\"></p><p>精度的测量是取当函数返回的数值变化时的差值。当连续调用某一个计时函数时，它返回的结果是可能不变的。当它变化时，变化的数值就是它的测时精度。表中展示的就是这些精度测量结果的平均值（及方差，如果测试结果不完全一样的话）。</p><p>精度受 API 设计的影响，也受函数实现的影响。比如，Windows 上定义 <code>CLOCKS_PER_SEC</code> 为 1000，显然 <code>clock()</code> 也就不可能获得高于一毫秒的精度了。C++11 的三种时钟从目前实现的接口上来看都允许实现一纳秒的精度，但实际精度则要远远低于一纳秒。</p><p>测试结果当然跟具体的硬件也可能有关系，但至少这里可以看到一些基本的共性：</p><ul>\n<li>首先，<code>clock()</code> 函数不是个好选择，它的精度可能很差，本身耗时也可能会比较长。</li>\n<li>其次，C++11 带来的三种时钟不管是精度还是自身开销都还算不错。既然其他方面没有区别，我们就选择使用能提供稳定增长保证的 <code>steady_clock</code>（<code>system_clock</code> 是不稳定的，系统时间被调整时，时钟返回的数值也会变化；<code>high_resolution_clock</code> 的稳定性在标准中没有进行规定）<span class=\"orange\">[1]</span>。</li>\n<li>最后，如果时间戳计数器（Time Stamp Counter <span class=\"orange\">[2]</span>）可用的话，它能提供最高的精度和最短的耗时。它是处理器上的硬件计数器，精度高，速度快，在多核系统上也能提供正确的读数；但在多 CPU 插槽的系统上则不一定能提供相应的保证，因而在那种情况下可能需要把测试程序绑定到某个核上运行。</li>\n</ul><p><code>rdtsc</code> 返回的数值单位是时钟周期数（但频率可能跟处理器的实际运行频率不同）。上表中测量各个函数的耗时用的就是 <code>rdtsc</code>。</p><p>我目前在<a href=\"https://github.com/adah1972/geek_time_cpp\">代码库</a>里加入了 rdtsc.h 文件。它的实现就是优先使用 x86 和 x86-64 平台提供的 <code>rdtsc</code> 的实现，在找不到时转而使用 <code>stead_clock</code> 作为替代。有兴趣的可以自行查看。</p><p>额外提一句，我这边讲的性能测试是微观层面的测试，即所谓的 microbenchmarking，一般以函数为单位。这种测试是单线程的，需要干扰尽可能少。可能的干扰有：</p><ul>\n<li>其他的应用程序——应尽可能关闭其他应用，尤其是会耗 CPU的。</li>\n<li>处理器的自动频率变化——最好关闭这类功能，如 Intel 的 Turbo Boost。</li>\n<li>不同性能核之间的迁移——如果你的测试系统上有所谓的大小核，而你又没办法把程序绑定到某个核上面的话，那这样的系统不适合用来做微观层面的性能测试。</li>\n</ul><h3>通用测试方法</h3><p>下面我们讨论一种我个人经常使用的通用的性能测试方法。由于编译器的很多优化机制并不能由代码来控制，这也只能算是一种最佳实践而已。根据你的特定平台，也许你可以找出更好的测试方法。</p><p>我的基本方法是：</p><ul>\n<li>把待测的代码放到一个函数里，这样容易消除一些其他干扰。</li>\n<li>可选地，把这个函数用 <code>__attribute__((noinline))</code> <span class=\"orange\">[3]</span> 或 <code>__declspec(noinline)</code> <span class=\"orange\">[4]</span> 标注为不要内联。</li>\n<li>确保有一个依赖函数执行结果的数值会被写到某个全局变量里。根据代码的规模和组织，可以直接在这个函数里写入，或者通过外部传入的一个全局变量的指针或引用来写入。</li>\n<li>在函数的开头和结尾测量时间，并把测得的时长累加到某个地方。</li>\n<li>在循环里反复调用被测函数，并在每次调用函数前后进行加解锁，产生内存屏障。</li>\n</ul><p>比如，<code>memset</code> 的测试代码可能就会变成这个样子：</p><pre><code class=\"language-cpp\">char buf[80];\nuint64_t memset_duration;\nstd::mutex mutex;\n\nvoid test_memset()\n{\n  uint64_t t1 = rdtsc();\n  memset(buf, 0, sizeof buf);\n  uint64_t t2 = rdtsc();\n  memset_duration += (t2 - t1);\n}\n\nint main()\n{\n  constexpr int LOOPS = 10000000;\n  for (int i = 0; i &lt; LOOPS; ++i) {\n    std::lock_guard guard{mutex};\n    test_memset();\n  }\n  printf(\"%g\\n\", memset_duration * 1.0 / LOOPS);\n}\n</code></pre><p>使用这种方法，我们确实可以验证出在 GCC 和 Clang 下，两种清零方法在缓冲区大小已知的情况下可以获得相同的性能（如果大小要运行时才能决定，那就是另外一个需要单独测试的问题了）。</p><h3>一个小测试框架</h3><p>利用 RAII（<a href=\"https://time.geekbang.org/column/article/169225\">第 1 讲</a>），我们可以使用一个框架把代码再整理一下，使得测试更加简单和自动。这个框架比较简单，设计和实现我就不讲了。下面给你简单介绍一下它的使用。</p><p>对于当前的例子，首先我们需要声明两个待测函数的索引：</p><pre><code class=\"language-cpp\">enum profiled_functions {\n  PF_TEST_MEMSET,\n  PF_TEST_PLAIN_LOOP,\n};\n</code></pre><p>然后，我们需要声明函数索引和函数名的关系：</p><pre><code class=\"language-cpp\">name_mapper name_map[] = {\n  {PF_TEST_MEMSET, \"test_memset\"},\n  {PF_TEST_PLAIN_LOOP, \"test_plain_loop\"},\n  {-1, nullptr}};\n</code></pre><p>对于待测函数，我们需要在函数开头插入一行代码，表示要对这个函数进行性能测试（利用一个 RAII 对象）：</p><pre><code class=\"language-cpp\">void test_memset()\n{\n  PROFILE_CHECK(PF_TEST_MEMSET);\n  memset(buf, 0, sizeof buf);\n}\n</code></pre><p>这样就行了。下面输出的代码也不需要了，程序会在最后进程退出的时候自动打印汇总测试数据（利用另外一个 RAII 对象），如下所示：</p><blockquote>\n<p><code>0 test_memset:</code><br>\n<code>  Call count: 10000000</code><br>\n<code>  Call duration: 240756468</code><br>\n<code>  Average duration: 24.0756</code><br>\n<code>1 test_plain_loop:</code><br>\n<code>  Call count: 10000000</code><br>\n<code>  Call duration: 241429159</code><br>\n<code>  Average duration: 24.1429</code></p>\n</blockquote><p>完整代码请参考 GitHub 上的<a href=\"https://github.com/adah1972/geek_time_cpp\">代码库</a>。如果想检查不同架构下的性能差异的话，可以在 cmake 命令行上指定编译器和附加参数，如：</p><p><code>CXX='g++ -march=corei7' cmake …</code></p><p>此外，需要说明一下，跟 <code>assert</code> 类似，<code>PROFILE_CHECK</code> 宏在 <code>NDEBUG</code> 宏被定义时就不生效了。所以，上面的输出在使用了 <code>cmake -DCMAKE_BUILD_TYPE=Release …</code> 时就不会有了。</p><p>最后，注意我举这个例子，主要是为了说明测试的复杂性和测试的方法。对于这个例子本身，由于代码简单、运行时间非常短，测试带来的额外开销过大，因而检查汇编输出可能是最好的检查性能的方式。显然，对于更大更复杂的代码，从汇编代码推断性能就困难多了。在那时候，类似目前的测试框架这样的代码就会非常有用。</p><h2>浅谈优化的问题</h2><p>今天提到的测试困难，很大程度上都是 C++ 编译器的优化造成的。事实上，C++ 里很多未定义行为之所以成为未定义行为，也是跟性能有关的。为了追求性能，C++ 编译器是可谓无所不用其极。有些人觉得编译器忽略了人的意图，感到很不爽，但事实是，C++ 编译器在优化方面确实比大部分程序员做得更好。这也是现在基本上没人写汇编的原因——即使不考虑可移植性，在某一特定平台上要写出超过 C++ 编译器水平的汇编代码，也已经越来越困难了。</p><p>但这种优化，虽然常常对程序有好处，也常常是违背程序员的直觉的。我这里另外举两个简单的例子，来说明一下为什么 C++ 编译器<strong>需要</strong>违反程序员的直觉。</p><h3>优化和未定义行为</h3><p>假如我们有一个 <code>int</code> 类型的变量 <code>x</code>，那 <code>x * 2 / 2</code> 的结果是几？</p><p>如果 C++ 把有符号整数运算溢出的结果定义为补码的内存表示，也就是说，32 位正整数 <code>0x40'00'00'00</code>（$2^{30}$）乘以 2 的结果就是 <code>0x80'00'00'00</code>（$-2^{31}$），再除以 2 的话，我们就不能得回原先的数值，而是得到了 <code>0xC0'00'00'00</code>（$-2^{30}$）。这样的话，<code>x * 2 / 2</code> 就不能优化为 <code>x</code>！</p><p>那能不能使用异常呢？也不行。跟除零不一样，整数运算溢出不会产生硬件中断。而如果我们在每条加法、减法、乘法、除法（对，除法也可能溢出—— <code>INT_MIN / -1</code> 就会）上都加入指令来检查是否发生溢出、并在发生溢出时报告异常的话，性能的退步将是不可接受的 <span class=\"orange\">[5]</span>。</p><p>所以，C++ 的处理方式就是，规定有符号整数运算溢出为未定义行为 <span class=\"orange\">[6]</span>，即程序员需要保证这种情况不会发生，否则后果自负。这在允许编译器把 <code>x * 2 / 2</code> 优化成 <code>x</code> 的同时，也意味着，下面这样的代码返回的结果可能会跟程序员预想的不同（参见 <a href=\"https://godbolt.org/z/Ex5ad6vM9\">https://godbolt.org/z/Ex5ad6vM9</a>）：</p><pre><code class=\"language-cpp\">bool test(int n)\n{\n  return (n + 1) == INT_MIN;\n}\n</code></pre><p>你想的是，如果 <code>n + 1</code> 溢出了，应该会得到 <code>INT_MIN</code> 这个特殊的结果。但编译器可以认为溢出是永远不会发生的（因为正确的程序里不应该有未定义行为），因此可以直接返回 <code>false</code>。——这也是实际可以在 GCC 和 Clang 上测到的结果。</p><h3>优化和执行顺序</h3><p>假设我们有三个全局 <code>int</code> 变量 <code>x</code>、<code>y</code> 和 <code>a</code>，然后我们执行下面的代码：</p><pre><code class=\"language-cpp\">x = a;\ny = 2;\n</code></pre><p>那是不是编译器会产生先写入 <code>x</code>、再写入 <code>y</code> 的代码呢？</p><p>我想你猜到了，答案为“不一定”。下面是某些编译器实际产生的汇编代码（参见 <a href=\"https://godbolt.org/z/zsfvsf63E\">https://godbolt.org/z/zsfvsf63E</a>）：</p><pre><code class=\"language-assembly\">mov     eax, DWORD PTR a\nmov     DWORD PTR y, 2\nmov     DWORD PTR x, eax\n</code></pre><p>我们可以看到，编译器产生的代码是：先读入 <code>a</code>，再写入 <code>y</code>，最后写入 <code>x</code>。</p><p>为什么要这样？一样，是因为优化。读入 <code>a</code> 的数值到 eax 寄存器里，跟写入 2 到 <code>y</code> 里是两个不相关操作，可以同时执行。这样的代码，比起完全按程序员指定的执行顺序产生的代码，可望得到更高的性能。</p><h2>内容小结</h2><p>本讲我们通过一个小例子，讨论了优化跟性能测试的一些问题。希望你在学完这一讲之后，能够了解优化对代码和测试产生的影响，并能正确地测试代码的性能。</p><h2>课后思考</h2><p>请尝试修改代码，让编译器没法在编译期得到需要清零的数据块大小。测试这种情况下的性能。（提示：你这次需要上面讲到的要求不内联的标注了。）</p><p>如果对结果有疑惑，建议使用 Compiler Explorer 网站（<a href=\"https://time.geekbang.org/column/article/187980\">第 21 讲</a>有介绍）或编译器生成汇编代码（<code>-S</code> 或 <code>/Fa</code>）的选项来仔细检视一下。</p><p>如果有任何疑问，欢迎留言和我讨论。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Date and time utilities – Clocks”. <a href=\"https://en.cppreference.com/w/cpp/chrono#Clocks\">https://en.cppreference.com/w/cpp/chrono#Clocks</a></span></p><p><span class=\"reference\">[1a] cppreference.com, “日期和时间工具 – 时钟”. <a href=\"https://zh.cppreference.com/w/cpp/chrono#.E6.97.B6.E9.92.9F\">https://zh.cppreference.com/w/cpp/chrono#.E6.97.B6.E9.92.9F</a></span></p><p><span class=\"reference\">[2] Wikipedia, “Time Stamp Counter”. <a href=\"https://en.wikipedia.org/wiki/Time_Stamp_Counter\">https://en.wikipedia.org/wiki/Time_Stamp_Counter</a></span></p><p><span class=\"reference\">[3] GCC, “GCC 11.2 Manual – Common Function Attributes”. <a href=\"https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gcc/Common-Function-Attributes.html\">https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gcc/Common-Function-Attributes.html</a></span></p><p><span class=\"reference\">[4] Microsoft, “noinline”. <a href=\"https://docs.microsoft.com/en-us/cpp/cpp/noinline?view=msvc-170\">https://docs.microsoft.com/en-us/cpp/cpp/noinline?view=msvc-170</a></span></p><p><span class=\"reference\">[5] Will Dietz, Peng Li, John Regehr, and Vikram Adve, “Understanding Integer Overflow in C/C++”. <a href=\"https://www.cs.utah.edu/~regehr/papers/overflow12.pdf\">https://www.cs.utah.edu/~regehr/papers/overflow12.pdf</a></span></p><p><span class=\"reference\">[6] cppreference.com, “Undefined behavior”. <a href=\"https://en.cppreference.com/w/cpp/language/ub\">https://en.cppreference.com/w/cpp/language/ub</a></span></p><p><span class=\"reference\">[6a] cppreference.com, “未定义行为”. <a href=\"http://zh.cppreference.com/w/cpp/language/ub\">http://zh.cppreference.com/w/cpp/language/ub</a></span></p>","neighbors":{"left":{"article_title":"32｜容器里的内存管理：分配器","id":491227},"right":{"article_title":"34｜快速分配和释放内存：内存池","id":503029}}},{"article_id":503029,"article_title":"34｜快速分配和释放内存：内存池","article_content":"<p>你好，我是吴咏炜。</p><p>在上一讲讲过了性能测试之后，我们终于可以回到内存池这个话题，来深入讨论一下了。</p><h2>一个测试用例</h2><p>如果你想用内存池，那我的第一个问题就是，你到底是不是需要使用内存池？</p><p>下面是一些你可能想使用内存池的理由：</p><ul>\n<li>希望减少内存分配和释放的时间开销——更快的分配和释放</li>\n<li>希望减少内存分配和释放的空间开销——更少的总体内存使用</li>\n</ul><p>下面则是一些反对使用内存池的理由：</p><ul>\n<li>你的通用内存分配器可能已经足够快了</li>\n<li>使用内存池可能导致操作系统更难回收你已经不再需要的内存</li>\n<li>使用内存池可能使得你的对象较难跟其他对象进行交互（参考<a href=\"https://time.geekbang.org/column/article/491227\">第 32 讲</a>，在 PMR 之前分配器是容器类型的一部分）</li>\n</ul><p>当然，既然你看到这里了，你肯定是想要使用内存池的。不过，我们需要能够衡量使用内存池的效果，所以我们需要进行测试。</p><p>如果你想要进行某个操作的性能测试，你就需要某种“典型场景”。作为例子，我这儿拿一个掺入了随机操作的过程当作测试场景。具体来说，我做的事情是：</p><ol>\n<li>产生随机数</li>\n<li>把这些随机数插入到一个 <code>unordered_set</code> 中，测量所需的时间</li>\n<li>把这些随机数从这个 <code>unordered_set</code> 里逐个删除，测量所需的时间</li>\n<li>再把这些随机数重新插入到 <code>unordered_set</code> 中，测量所需的时间</li>\n</ol><!-- [[[read_end]]] --><p>这虽然不是一个完美的例子，但确实可以让我们观察到内存池的作用。如果你有真实的场景，也可以借鉴这种方式来进行测试。</p><p>我们的待测对象和类型非常简单：</p><pre><code class=\"language-cpp\">using TestType = unordered_set&lt;int&gt;;\nTestType s;\n</code></pre><p>产生随机数的代码略复杂一点点：</p><pre><code class=\"language-cpp\">mt19937 engine;\nuniform_int_distribution&lt;int&gt; dist;\narray&lt;int, LEN&gt; rand_nums{};\nfor (int&amp; num : rand_nums) {\n  num = dist(engine);\n}\n</code></pre><p>我们希望得到跨平台的稳定测试结果，因此指定了一个名声不错的伪随机数引擎 <code>mt19937</code>（否则默认的伪随机数引擎 <code>default_random_engine</code> 也没什么问题）。我们只需要一个简单的随机均匀分布，因而使用了默认构造的 <code>uniform_int_distribution</code>，不给出随机数的范围，来产生所有合法整数范围内的随机数。然后，我们在长度为 <code>LEN</code> 的数组中，每一项（注意此处必须使用引用的方式来范围遍历 <code>rand_nums</code>）都写入一个随机的整数。由于我们没有对随机数引擎使用真正随机的种子来初始化，这些随机数每次都是相同的，可以保证测试的稳定性。</p><p>初始插入操作就简单了，只是把数组 <code>rand_nums</code> 里的每一项插入到 <code>s</code> 里。由于 <code>s</code> 这个变量的操作实在有点复杂，不管它是全局变量还是本地变量，编译器都不太可能把这些操作优化掉了。我们这个测试可以简单地测量总体耗时：</p><pre><code class=\"language-cpp\">t1 = rdtsc();\nfor (int num : rand_nums) {\n  s.insert(num);\n}\nt2 = rdtsc();\n</code></pre><p>删除操作也差不多，我们仍然使用 <code>rand_nums</code> 来删除 <code>s</code> 中的每一项：</p><pre><code class=\"language-cpp\">t1 = rdtsc();\nfor (int num : rand_nums) {\n  s.erase(num);\n}\nt2 = rdtsc();\n</code></pre><p>最后，我们再重复一遍插入的过程，看看重新插入的性能有没有变化。完整的测试代码可以看一下<a href=\"https://github.com/adah1972/geek_time_cpp\">代码库</a>。</p><p>下面是某硬件环境下的初步测试结果。</p><p>Apple Clang 12.0，macOS Catalina 10.15：</p><blockquote>\n<p><code>It took 449 cycles by average to insert a number</code><br>\n<code>It took 492 cycles by average to erase  a number</code><br>\n<code>It took 305 cycles by average to insert a number again</code></p>\n</blockquote><p>MSVC 19.29，Windows 10：</p><blockquote>\n<p><code>It took 366 cycles by average to insert a number</code><br>\n<code>It took 185 cycles by average to erase  a number</code><br>\n<code>It took 300 cycles by average to insert a number again</code></p>\n</blockquote><p>GCC 10.3，Ubuntu Linux 20.04 LTS：</p><blockquote>\n<p><code>It took 307 cycles by average to insert a number</code><br>\n<code>It took 162 cycles by average to erase  a number</code><br>\n<code>It took 176 cycles by average to insert a number again</code></p>\n</blockquote><p>可以看到，使用不同的平台和编译器，结果差异比较大。但我们确实可以看到，再次插入的性能比第一次要高，在 Linux 上尤其明显。</p><p>事实上，这还只是使用默认的内存分配器的结果。使用不同的内存分配器也能获得不同的效果。比如，在 Linux 上使用 tcmalloc <span class=\"orange\">[1]</span> 来取代默认的分配器 <span class=\"orange\">[2]</span>，我们可以得到更好的测试结果：</p><blockquote>\n<p><code>It took 250 cycles by average to insert a number</code><br>\n<code>It took 116 cycles by average to erase  a number</code><br>\n<code>It took 117 cycles by average to insert a number again</code></p>\n</blockquote><p>取决于你使用的平台的内存分配器的性能，也取决于你是否需要跨平台地得到更好的内存分配性能，内存池也许对你很有用，也许对你用处不大。目前，我就假设内存池会对你有用吧（既然你已经读到这里了😁）。</p><h2>PMR 内存池</h2><p>有了测试用例之后，我们可以验证一下多态分配器（<a href=\"https://time.geekbang.org/column/article/491227\">第 32 讲</a>）里提供的内存池的作用了。我们只需要对测试用例做一下小修改，把 <code>TestType</code> 相关的两行改成下面这样子就行：</p><pre><code class=\"language-cpp\">using TestType = pmr::unordered_set&lt;int&gt;;\npmr::unsynchronized_pool_resource res;\npmr::polymorphic_allocator&lt;int&gt; a{&amp;res};\nTestType s(a);\n</code></pre><p>取决于平台，你可能会看到不同的性能结果。比如，在 Linux 上我得到了下面的测试结果：</p><blockquote>\n<p><code>It took 272 cycles by average to insert a number</code><br>\n<code>It took 210 cycles by average to erase  a number</code><br>\n<code>It took 169 cycles by average to insert a number again</code></p>\n</blockquote><p>性能数据有得有失。而在 macOS 和 Windows 上，我看到了更大的、全方位的性能提升。对于跨平台的应用，这样的内存池确实会有效果。</p><p>注意，我上面使用的是无多线程同步的 <code>unsynchronized_pool_resource</code>。有多线程同步的内存池就是另外一个故事了。在 Linux 上，性能反而会有下降；而在其他平台上，性能提升也很不明显。——一般而言，对于多线程的处理，通用内存分配器已经做了充足的优化，性能上可能反而会超出一般简单实现的内存池。内存池通常应该在<strong>单线程</strong>或<strong>线程本地</strong>（thread_local）的场景使用，至少从执行时间的角度来讲是如此。</p><h2>自定义内存池</h2><p>在<a href=\"https://time.geekbang.org/column/article/489409\">第 31 讲</a>我提到过，利用同一类型的对象的大小完全相同这一特性，可以实现一个高度优化的内存池。只是利用类特定的分配和释放函数，使用场景会比较受限。下面我会描述利用这个思路实现的一个内存池，既可以用在类特定的分配和释放函数里，也可以用在容器的分配器里。</p><h3>基本策略</h3><p>作为内存池，最基本的要求就是减少向系统的内存分配器请求内存的次数。因此，我们希望单次内存分配就获得大块的内存（chunk），然后分割开给各个对象使用。这样的内存块，通常是某个特定大小的整数倍。</p><p>下一步，我们有两种不同的做法：</p><ol>\n<li>任何要求某个大小（或某个大小范围）的内存分配请求都到某一个内存池里分配和释放</li>\n<li>任何要求某个特定类型的对象的内存分配请求都到某一个内存池里分配和释放</li>\n</ol><p>第一种做法跟 SGI STL 差不多，而第二种做法是 C++ 的内存分配机制给我们的额外优化机会。两种做法各有一些优缺点，而我目前是采取了第二种做法，主要考虑下面这些因素：</p><ul>\n<li>不同类型的对象使用不同的内存池，即使它们的大小相同。在很多场景下，把同一类型的对象放在一起，程序会有更好的局域性。</li>\n<li>通过对象类型可以得出对象大小，但反过来则不可以。换句话说，按我目前的方式，你可以把方案退化成为只使用对象大小，因而讲解目前这种方式更具有通用性。</li>\n</ul><p>我做的另外一个选择是在大部分时间里<strong>不</strong>返回内存给内存分配器。原因是：</p><ul>\n<li>返回内存给内存分配器反而更容易导致内存碎片，导致后续内存不足或消耗更大。</li>\n<li>返回内存给内存分配器，通常内存分配器也没法返回给操作系统（因为内存碎片的原因），因此并不能减少程序的运行期内存开销。</li>\n<li>不返回内存给内存分配器的话，实现简单，代码更小、更快。</li>\n</ul><p>我的一些实验表明，内存池也很难决定什么时候返回内存给内存分配器。如果某个内存块（chunk）全空就返回的话，程序向内存分配器请求内存的次数会明显增加。目前我能想到的唯一好处，是程序的对象数量会有明显的波动的时候：在某个时刻，程序会产生大量的 A 对象，然后释放掉；在另一时刻，又会产生大量的 B 对象，然后释放掉。仅在这种情况下，我的不返回选择会增加程序的最大内存开销。目前我就暂不考虑这种特殊场景了。</p><h3>对象内存池</h3><p>根据上面的讨论，我们需要有一个内存块的数据结构，也需要决定一个内存块里放多少个对象。我们采用一个可特化的参数来决定后者：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\ninline constexpr size_t\n  memory_chunk_size = 64;\n</code></pre><p>也就是说，<code>memory_chunk_size</code> 默认大小是 64，但你可以针对某一特定类型来进行特化，改变其大小。比如，你想针对你的某一特定 <code>Obj</code> 类型把大小改成 32，你可以写：</p><pre><code class=\"language-cpp\">template &lt;&gt;\ninline constexpr size_t\n  memory_chunk_size&lt;Obj&gt; = 32;\n</code></pre><p>当然，一般情况下你没必要这么做。在大部分需要内存池的场景，默认大小已经工作得挺好了。</p><p>然后，我们需要定义一个数据结构，可以存放某种对象，也可以把内存块串成一个链表。显然，我们可以使用一个 union：</p><pre><code class=\"language-cpp\">union node {\n  T data;\n  node* next;\n};\n</code></pre><p>直接使用 <code>T</code> 类型的好处是我们可以自然地使用 <code>T</code> 类型的对齐特征，而不需要使用 <code>alignas</code> 之类的麻烦方式。不过，我们也有一些小复杂性需要解决：当 <code>T</code> 是一个带有非平凡构造函数和析构函数的对象时，上面的代码编译会有问题，因为编译器不知道在构造和析构时到底该怎么办了。我们只用这个结点来管理内存，因此我们声明空的构造函数和析构函数就好（注意，此处不能使用 <code>= default</code>）。此外，这样的内存结点显然也不应该进行复制，因此，我们最好要禁用拷贝构造函数和拷贝赋值运算符。</p><pre><code class=\"language-cpp\">union node {\n  T data;\n  node* next;\n  node() {}\n  ~node() {}\n  node(const node&amp;) = delete;\n  node&amp;\n  operator=(const node&amp;) = delete;\n};\n</code></pre><p>然后，我们就可以定义出内存块了：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nclass memory_chunk {\npublic:\n  union node {\n    …\n  };\n  memory_chunk(\n    memory_chunk* next_chunk);\n  node* get_free_nodes()\n  {\n    return storage_.data();\n  }\n  memory_chunk* get_next() const\n  {\n    return next_chunk_;\n  }\n\nprivate:\n  memory_chunk* next_chunk_{};\n  array&lt;node, memory_chunk_size&lt;T&gt;&gt;\n    storage_;\n};\n</code></pre><p>内存块就是结点的数组，加上指向下一个内存块的指针，来把内存块串成一个链表。我们通过构造函数来初始化内存块：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nmemory_chunk&lt;T&gt;::memory_chunk(\n  memory_chunk* next_chunk)\n  : next_chunk_(next_chunk)\n{\n  for (size_t i = 0;\n       i &lt; storage_.size() - 1;\n       ++i) {\n    storage_[i].next =\n      &amp;storage_[i + 1];\n  }\n  storage_[storage_.size() - 1]\n    .next = nullptr;\n}\n</code></pre><p>“下一个”内存块的指针由外部传入。对于结点的数组，我们使每个结点的 <code>next</code> 指针指向下一项；除了最后一项，其 <code>next</code> 指针为空。也就是说，我们把内存块串成了一个链表，供后面内存池来使用。</p><p>有了这些原料，我们的内存池就可以很方便地写出来了。类的定义如下：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nclass memory_pool {\npublic:\n  using node =\n    typename memory_chunk&lt;T&gt;::node;\n  memory_pool() = default;\n  memory_pool(const memory_pool&amp;) =\n    delete;\n  memory_pool&amp; operator=(\n    const memory_pool&amp;) = delete;\n  ~memory_pool();\n  T* allocate();\n  void deallocate(T* ptr);\n\nprivate:\n  node* free_list_{};\n  memory_chunk&lt;T&gt;* chunk_list_{};\n};\n</code></pre><p>可以看到，内存池对象只有两个成员变量，<code>free_list_</code> 和 <code>chunk_list_</code>，及三个成员函数，析构函数、<code>allocate</code> 和 <code>deallocate</code>。<code>free_list_</code> 是空闲结点的链表，<code>chunk_list_</code> 是所有内存块的链表。而在三个成员函数里，析构函数的意义是负责释放所有的内存块：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nmemory_pool&lt;T&gt;::~memory_pool()\n{\n  while (chunk_list_) {\n    memory_chunk&lt;T&gt;* chunk =\n      chunk_list_;\n    chunk_list_ =\n      chunk_list_-&gt;get_next();\n    delete chunk;\n  }\n}\n</code></pre><p><code>allocate</code> 负责内存的分配：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nT* memory_pool&lt;T&gt;::allocate()\n{\n  if (free_list_ == nullptr) {\n    chunk_list_ =\n      new memory_chunk&lt;T&gt;(\n        chunk_list_);\n    free_list_ =\n      chunk_list_-&gt;get_free_nodes();\n  }\n  T* result = &amp;free_list_-&gt;data;\n  free_list_ = free_list_-&gt;next;\n  return result;\n}\n</code></pre><p>我们首先检查空闲列表 <code>free_list_</code> 是否为空，为空则说明内存池里已经没有内存供对象使用，因此我们需要新申请一个内存块，然后让 <code>chunk_list_</code> 指向这个新内存块，并让 <code>free_list</code> 指向其首项。随后，分配内存只是简单地从结点链表上摘下一项，并调整链表的首项指针。</p><p><code>deallocate</code> 当然就是负责内存的释放：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nvoid memory_pool&lt;T&gt;::deallocate(T* ptr)\n{\n  auto free_item =\n    reinterpret_cast&lt;node*&gt;(ptr);\n  free_item-&gt;next = free_list_;\n  free_list_ = free_item;\n}\n</code></pre><p>这就更简单了，就是把用户传进来的指针当成结点的指针，然后放回到空闲列表里而已。</p><p>顺便说一句，对于调整链表这样的操作，标准库提供的 <code>std::exchange</code> 工具可以让代码更加简洁。比如，<code>allocate</code> 的最后三条语句可以缩成一条：<code>return &amp;exchange(free_list_, free_list_-&gt;next)-&gt;data;</code>。</p><h3>内存池应用：类特定的分配和释放函数</h3><p>虽然类特定的分配和释放函数已经不那么经常使用，我们还是可以看一下如何把内存池用到这一最简单的应用场景中。这也可以让我们测一下这种极端情况下的内存池收益。</p><p>之前提过，对于某一个类 <code>Obj</code>，我们要使用类特定的分配和释放函数，只需在其中声明这样两个成员函数：</p><pre><code class=\"language-cpp\">class Obj {\npublic:\n  …\n  void* operator new(size_t size);\n  void operator delete(\n    void* ptr) noexcept;\n};\n</code></pre><p>这里我省去了声明前的 <code>static</code>，这是允许的，效果相同（不管写不写 <code>static</code>，这两个成员函数都是静态的）。我们可以在这个类的实现文件（非头文件）里加入下面的内容即可使用内存池：</p><pre><code class=\"language-cpp\">memory_pool&lt;Obj&gt; obj_pool;\n\nvoid* Obj::operator new(size_t size)\n{\n  assert(size == sizeof(Obj));\n  return obj_pool.allocate();\n}\n\nvoid Obj::operator delete(\n  void* ptr) noexcept\n{\n  obj_pool.deallocate(\n    static_cast&lt;Obj*&gt;(ptr));\n}\n</code></pre><p>对于这样的对象，及没有类特定的分配和释放函数的对象，分别做大量的 <code>new</code> 和 <code>delete</code> 操作，我在 Linux（默认分配和释放性能最好的主流平台）上得到：</p><blockquote>\n<p><code>107 cycles for each allocation and deallocations on normal Obj</code><br>\n<code>  8 cycles for each allocation and deallocations on pooled Obj</code>\\</p>\n</blockquote><p>不使用内存池时平均每次分配和释放耗时 107 个时钟周期，使用内存池则降为 8 个时钟周期。</p><p>如果使用 tcmalloc，区别就小一点了：</p><blockquote>\n<p><code> 27 cycles for each allocation and deallocations on normal Obj</code><br>\n<code>  8 cycles for each allocation and deallocations on pooled Obj</code>\\</p>\n</blockquote><p>不使用内存池也只要 27 个时钟周期。</p><h3>内存池应用：分配器</h3><p>上面的测试可以让我们看到内存池带来的收益会有多大，但手工使用 <code>new</code> 和 <code>delete</code> 早就已经不是推荐的做法了。最常见的情况，我们需要把对象放在容器里面。因此，我们需要让分配器支持内存池。</p><p>除了我们定义分配器需要的那些必要定义外，我们需要定义的核心成员函数是 <code>allocate</code> 和 <code>deallocate</code>。实现的示意如下：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nmemory_pool&lt;T&gt;&amp; get_memory_pool()\n{\n  thread_local memory_pool&lt;T&gt; pool;\n  return pool;\n}\n\ntemplate &lt;typename T,\n          typename Base =\n            allocator&lt;T&gt;&gt;\nstruct pooled_allocator\n  : private Base {\n  …\n\n  T* allocate(size_t n)\n  {\n    if (n == 1) {\n      return get_memory_pool&lt;T&gt;()\n        .allocate();\n    } else {\n      return Base::allocate(n);\n    }\n  }\n\n  void deallocate(T* p, size_t n)\n  {\n    if (n == 1) {\n      return get_memory_pool&lt;T&gt;()\n        .deallocate(p);\n    } else {\n      return Base::deallocate(p, n);\n    }\n  }\n};\n</code></pre><p>也就是说，对于每一种特定类型 <code>T</code>，我们都有一个专属的线程本地内存池。这个内存池会在首次使用被创建，在线程退出时被销毁。</p><p>在 <code>allocate</code> 和 <code>deallocate</code> 函数里，我们首先检查需要分配或释放的对象个数。当前的实现不能处理超过单个对象大小的分配和释放，因此这样的请求会直接转到基类的内存分配器进行处理， 默认情况下是系统的 <code>std::allocator</code>，它会使用 <code>operator new</code> 和 <code>operator delete</code> 来进行分配和释放。我们仅针对单个对象的内存分配和释放使用线程本地内存池，因此这个分配器适合 <code>list</code>、<code>map</code>、<code>set</code> 这样的对元素单独分配内存的容器，而不适合 <code>vector</code>、<code>deque</code> 这样的批量分配内存的容器。——后者实际上也基本没有使用内存池的必要了。</p><p>使用这个内存池很简单，把容器的 <code>Allocator</code> 模板参数设成目前实现的 <code>pooled_allocator</code> 即可。使用之前的测试，我们需要把 <code>TestType</code> 定义成下面的形式：</p><pre><code class=\"language-cpp\">using TestType = unordered_set&lt;\n  int, hash&lt;int&gt;, equal_to&lt;int&gt;,\n  pooled_allocator&lt;int&gt;&gt;;\n</code></pre><p>由于 <code>Allocator</code> 是最后一个参数，我们必须把之前类模板的默认模板参数也手工补上，也就是 <code>hash&lt;int&gt;</code> 和 <code>equal_to&lt;int&gt;</code> 这两个。这样做一下简单修改之后，我们就能看到测试的性能提升。在 Linux 上我得到了：</p><blockquote>\n<p><code>It took 199 cycles by average to insert a number</code><br>\n<code>It took 112 cycles by average to erase  a number</code><br>\n<code>It took 110 cycles by average to insert a number again</code></p>\n</blockquote><p>确实是迄今为止最好的性能测试结果！</p><h3>生命周期陷阱</h3><p>好吧，我撒了个小谎。如果你原封不动按我目前给出的代码来自己实现一遍的话，你很可能看到程序在退出时挂起或崩溃。问题是这样发生的：</p><ol>\n<li>我们有一个全局对象，在构造时会把它的析构函数调用挂到程序退出时需要执行的代码中。</li>\n<li>在这个全局对象首次需要内存时，我们会初始化内存池的实例。同时，它的析构函数会挂到线程退出需要执行的代码中。注意这比第 1 步要晚。</li>\n<li>内存池析构会发生在全局对象析构之前（即使它们都是全局对象或者都是线程本地对象，也一定是后构造的先析构），它会释放所有的内存。</li>\n<li>在全局对象析构时，如果有任何读写之前分配的堆上内存的操作，都是未定义行为！</li>\n</ol><p>那么问题如何解决呢？我们可以选择以下几种方式：</p><ul>\n<li>确保内存池的构造先于全局对象的构造。把全局对象改成 thread_local 是一件简单的事（或者如果我们只需要单线程操作的话，可以把 <code>get_memory_pool</code> 里的 <code>thread_local</code> 改成 <code>static</code>），但问题是，内存池实例的类型是实现定义的，很难预料。对于我们的 <code>unordered_set&lt;int, …&gt;</code>，真正需要实例化的内存池类型可能是 <code>pooled_allocator&lt;std::__detail::_Hash_node&lt;int, false&gt;&gt;</code>，并且会随编译器不同而不同！</li>\n<li>在线程退出时不释放内存。问题是，如果我们重复起停线程的话，就会有内存泄漏了。只有在我们起的线程数量固定的情况下，这种方法才可行。</li>\n<li>不使用全局对象或线程本地对象，而是只使用本地对象。这当然对程序是一种限制……</li>\n</ul><p>很遗憾，似乎真没有完美的解决方案！你只能根据你的实际使用场景，选择其中最合适的一种了。</p><p><a href=\"https://github.com/adah1972/geek_time_cpp\">代码库</a>本讲的最后一个测试用例展示了预声明内存池的做法，如果你真有这样的需要，可以参考一下。</p><h2>内容小结</h2><p>在本讲中我们完整讨论了内存池，包括它的测试和实现。你在学完这一讲之后，应该已经对内存池有了充分的了解，知道什么情况下、该如何去实现一个内存池。</p><h2>课后思考</h2><p>请练习一下本讲的代码，复现内存池生命周期的问题，并尝试使用不同的解决方案。然后：</p><ol>\n<li>尝试一下，在 <code>memory_pool</code> 中加入对象计数，并在析构时检查对象数是否为零，仅在为零时才释放内存。</li>\n<li>考虑一下，如何发现你的容器结点究竟是什么类型？</li>\n</ol><p>如果有任何问题，欢迎留言和我进行讨论。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Google, “gperftools”. <a href=\"https://github.com/gperftools/gperftools\">https://github.com/gperftools/gperftools</a></span></p><p><span class=\"reference\">[2] GNU, “The GNU allocator”. <a href=\"https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html\">https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html</a></span></p>","neighbors":{"left":{"article_title":"33｜性能测试的正确姿势：性能、时间和优化","id":496791},"right":{"article_title":"35 | 发现和识别内存问题：内存调试实践","id":508706}}},{"article_id":508706,"article_title":"35 | 发现和识别内存问题：内存调试实践","article_content":"<p>你好，我是吴咏炜。</p><p>作为内存相关话题的最后一讲，今天我们来聊一聊内存调试的问题。</p><h2>场景</h2><p>首先，目前已经存在一些工具，可以让你在自己不写任何代码的情况下，帮助你来进行内存调试。用好你所在平台的现有工具，已经可以帮你解决很多内存相关问题（在<a href=\"https://time.geekbang.org/column/article/187980\">第 21 讲</a>中我已经介绍了一些）。</p><p>不过，前面提到的工具，主要帮你解决的问题是内存泄漏，部分可以帮你解决内存踩踏问题。它们不能帮你解决内存相关的所有问题，比如：</p><ul>\n<li>内存检测工具可能需要使用自己的特殊内存分配器，因此不能和你的特殊内存分配器协作（不使用标准的 <code>malloc</code>/<code>free</code>）</li>\n<li>某些内存调试工具对性能影响太大，无法在实际场景中测试</li>\n<li>你需要检查程序各个模块的分别内存占用情况</li>\n<li>你需要检查程序各个线程的分别内存占用情况</li>\n<li>……</li>\n</ul><p>总的来说，现成的工具提供了一定的功能，如果它直接能满足你的需求，那当然最好。但如果你有超出它能力的需求，那自己写点代码来帮助调试，也不是一件非常困难的事情——尤其在我们了解了这么多关于内存的底层细节之后。</p><h2>内存调试原理</h2><p>内存调试的基本原理，就是在内存分配的时候记录跟分配相关的一些基本信息，然后，在后面的某个时间点，可以通过检查记录下来的信息来检查跟之前分配的匹配情况，如：</p><!-- [[[read_end]]] --><ul>\n<li>在（测试）程序退出时检查是否有未释放的内存，即有没有产生内存泄漏</li>\n<li>在释放内存时检查内存是不是确实是之前分配的</li>\n<li>根据记录的信息来对内存的使用进行分门别类的统计</li>\n</ul><p>根据不同的使用场景，我们需要在分配内存时记录不同的信息，比如：</p><ul>\n<li>需要检查有没有内存泄漏，我们可以只记录总的内存分配和释放次数</li>\n<li>需要检查内存泄漏的数量和位置，我们需要在每个内存块里额外记录分配内存的大小，及调用内存分配的代码的位置（文件、行号之类）；但这样记录下来的位置不一定是真正有问题的代码的位置</li>\n<li>需要检查实际造成内存泄漏的代码的位置，我们最好能够记录内存分配时的完整调用栈（而非分配内存的调用发生的位置）；注意这通常是一个平台相关的解决方案</li>\n<li>作为一种简单、跨平台的替换方案，我们可以在内存分配时记录一个“上下文”，这样在有内存泄漏时可以缩小错误范围，知道在什么上下文里发生了问题</li>\n<li>这个“上下文”里可以包含模块、线程之类的信息，随后我们就可以针对模块或线程来进行统计</li>\n<li>我们可以在分配内存时往里安插一个特殊的标识，并在释放时检查并清除这个标识，用来识别是不是释放了不该释放的内存，或者发生了重复释放</li>\n</ul><p>根据你的实际场景和需要，可能性也是无穷无尽的。</p><p>下面，我们就来根据“上下文”的思想，来实现一个小小的内存调试工具。基于同样的思想，你也可以对它进行扩充，来满足你的特殊需求。</p><h2>“上下文”内存调试工具</h2><h3>预备知识</h3><p>这个内存调试工具说难不难，但它用到了很多我们之前学过的知识。我在下面再列举一下，万一忘记了的话，建议你复习一下再往下看：</p><ul>\n<li>RAII（<a href=\"https://time.geekbang.org/column/article/169225\">第 1 讲</a>）：我们使用 RAII 来自动产生和销毁一个上下文</li>\n<li><code>deque</code> 和 <code>stack</code>（<a href=\"https://time.geekbang.org/column/article/173167\">第 4 讲</a>）：用来存放当前线程的所有上下文</li>\n<li><code>operator new</code> 和 <code>operator delete</code> 的不同形态及其替换（<a href=\"https://time.geekbang.org/column/article/489409\">第 31 讲</a>）：我们需要使用布置版本，指定对齐，并截获内存分配和释放操作</li>\n<li>分配器（<a href=\"https://time.geekbang.org/column/article/491227\">第 32 讲</a>）：我们最后会需要使用一个特殊的分配器来处理一个小细节</li>\n</ul><h3>上下文</h3><p>我已经说了好多遍上下文这个词。从代码的角度，它到底是什么呢？</p><p>它是什么，由你来决定。</p><p>从内存调试的角度，可能有用的上下文定义有：</p><ul>\n<li>文件名加行号</li>\n<li>文件名加函数名</li>\n<li>函数名加行号</li>\n<li>等等</li>\n</ul><p>每个人可能有不同的偏好。我目前使用了文件名加函数名这种方式，把上下文定义成：</p><pre><code class=\"language-cpp\">struct context {\n  const char* file;\n  const char* func;\n};\n</code></pre><p>要生成上下文，可以利用标准宏或编译器提供的特殊宏。下面的写法适用于任何编译器：</p><pre><code class=\"language-cpp\">context{__FILE__, __func__}\n</code></pre><p>如果你使用 GCC 的话，你应该会想用 <code>__PRETTY_FUNCTION__</code> 来代替 <code>__func__</code> <span class=\"orange\">[1]</span>。而如果你使用 MSVC 的话，<code>__FUNCSIG__</code> 可能会是个更好的选择 <span class=\"orange\">[2]</span>。</p><h3>上下文的产生和销毁</h3><p>我们使用一个类栈的数据结构来存放所有的上下文，并使用后进先出的方式来加入或抛弃上下文。代码非常直白，如下所示：</p><pre><code class=\"language-cpp\">thread_local stack&lt;context&gt;\n  context_stack;\n\nconst context default_ctx{\n  \"&lt;UNKNOWN&gt;\", \"&lt;UNKNOWN&gt;\"};\n\nconst context&amp;\nget_current_context()\n{\n  if (context_stack.empty()) {\n    return default_ctx;\n  }\n  return context_stack.top();\n}\n\nvoid restore_context()\n{\n  context_stack.pop();\n}\n\nvoid save_context(\n  const context&amp; ctx)\n{\n  context_stack.push(ctx);\n}\n</code></pre><p>但如果要求你次次小心地手工调用 <code>restore_context</code> 和 <code>save_context</code> 的话，那也太麻烦、太容易出错了。这时，我们可以写一个小小的 RAII 类，来自动化对这两个函数的调用：</p><pre><code class=\"language-cpp\">class checkpoint {\npublic:\n  explicit checkpoint(\n    const context&amp; ctx)\n  {\n    save_context(ctx);\n  }\n  ~checkpoint()\n  {\n    restore_context();\n  }\n};\n</code></pre><p>再加上一个宏会更方便一点：</p><pre><code class=\"language-cpp\">#define MEMORY_CHECKPOINT()        \\\n  checkpoint func_checkpoint{      \\\n    context{__FILE__, __func__}}\n</code></pre><p>然后，你就只需要在自己的函数里加上一行代码，就可以跟踪函数内部的内存使用了：</p><pre><code class=\"language-cpp\">void SomeFunc()\n{\n  MEMORY_CHECKPOINT();\n  // 函数里的其他操作\n}\n</code></pre><h3>记录上下文</h3><p>之前的代码只是让我们可以产生在某一特定场景下的上下文。我们要利用这些上下文进行内存调试，就需要把上下文记录下来。我们需要定义一堆额外的布置分配和释放函数。简单起见，我们在这些函数里，简单转发内存分配和释放请求到新的函数：</p><pre><code class=\"language-cpp\">void* operator new(\n  size_t size, const context&amp; ctx)\n{\n  void* ptr = alloc_mem(size, ctx);\n  if (ptr) {\n    return ptr;\n  } else {\n    throw bad_alloc();\n  }\n}\nvoid* operator new[](\n  size_t size, const context&amp; ctx)\n{\n  // 同上，略\n}\nvoid* operator new(\n  size_t size,\n  align_val_t align_val,\n  const context&amp; ctx)\n{\n  void* ptr = alloc_mem(\n    size, ctx, size_t(align_val));\n  if (ptr) {\n    return ptr;\n  } else {\n    throw bad_alloc();\n  }\n}\nvoid* operator new[](\n  size_t size,\n  align_val_t align_val,\n  const context&amp; ctx)\n{\n  // 同上，略\n}\n\nvoid operator delete(\n  void* ptr,\n  const context&amp;) noexcept\n{\n  free_mem(ptr);\n}\nvoid operator delete[](\n  void* ptr,\n  const context&amp;) noexcept\n{\n  free_mem(ptr);\n}\nvoid operator delete(\n  void* ptr, align_val_t align_val,\n  const context&amp;) noexcept\n{\n  free_mem(ptr, size_t(align_val));\n}\nvoid operator delete[](\n  void* ptr, align_val_t align_val,\n  const context&amp;) noexcept\n{\n  free_mem(ptr, size_t(align_val));\n}\n</code></pre><p>标准的分配和释放函数也类似地只是转发而已，但我们这时就会需要用上前面产生的上下文。代码重复比较多，我就只列举最典型的两个函数了：</p><pre><code class=\"language-cpp\">void* operator new(size_t size)\n{\n  return operator new(\n    size, get_current_context());\n}\n\nvoid operator delete(\n  void* ptr) noexcept\n{\n  free_mem(ptr);\n}\n</code></pre><p>下面，我们需要把重点放到 <code>alloc_mem</code> 和 <code>free_mem</code> 两个函数上。我们先写出这两个函数的原型：</p><pre><code class=\"language-cpp\">void* alloc_mem(\n  size_t size, const context&amp; ctx,\n  size_t alignment =\n    __STDCPP_DEFAULT_NEW_ALIGNMENT__);\n\nvoid free_mem(\n  void* usr_ptr,\n  size_t alignment =\n    __STDCPP_DEFAULT_NEW_ALIGNMENT__);\n</code></pre><p><code>alloc_mem</code> 接受大小、上下文和对齐值（默认为系统的默认对齐值 <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>），进行内存分配，并把上下文记录下来。显然，下面的问题就是：</p><ul>\n<li>我们需要记录多少额外信息？</li>\n<li>我们需要把信息记录到哪里？</li>\n</ul><p>鉴于在释放内存时，通用的接口<strong>只能</strong>拿到一个指针，我们需要通过这个指针找到我们原先记录的信息，因此，我们得出结论，只能把额外的信息记录到分配给用户的内存前面。也就是说，我们需要在分配内存时多分配一点空间，在开头存上我们需要的额外信息，然后把额外信息后的内容返回给用户。这样，在用户释放内存的时候，我们才能简单地找到我们记录的额外信息。</p><p>我们需要额外存储的信息也不能只是上下文。关键地：</p><ul>\n<li>我们需要记录用户申请的内存大小，并用指针把所有的内存块串起来，以便在需要时报告内存泄漏的数量和大小。</li>\n<li>我们需要记录额外信息的大小，因为在不同的对齐值下，额外信息的指针和返回给用户的指针之间的差值会不相同。</li>\n<li>我们需要魔术数来辅助校验内存的有效性，帮助检测释放非法内存和重复释放。</li>\n</ul><p>因此，我们把额外信息的结构体定义如下：</p><pre><code class=\"language-cpp\">struct alloc_list_base {\n  alloc_list_base* next;\n  alloc_list_base* prev;\n};\n\nstruct alloc_list_t\n  : alloc_list_base {\n  size_t size;\n  context ctx;\n  uint32_t head_size;\n  uint32_t magic;\n};\n\nalloc_list_base alloc_list = {\n  &amp;alloc_list, // head (next)\n  &amp;alloc_list, // tail (prev)\n};\n</code></pre><p>从 <code>alloc_list_t</code> 分出一个 <code>alloc_list_base</code> 子类的目的是方便我们统一对链表头尾的操作，不需要特殊处理。<code>alloc_list</code> 的 <code>next</code> 成员指向链表头，<code>prev</code> 成员指向链表尾；把 <code>alloc_list</code> 也算进去，整个链表构成一个环形。</p><p><code>alloc_list_t</code> 内容有效时我们会在 <code>magic</code> 中填入一个特殊数值，这里我们随便取一个：</p><pre><code class=\"language-cpp\">constexpr uint32_t CMT_MAGIC =\n  0x4D'58'54'43; // \"CTXM\";\n</code></pre><p>在实现 <code>alloc_mem</code> 之前，我们先把对齐函数的实现写出来：</p><pre><code class=\"language-cpp\">constexpr uint32_t\nalign(size_t alignment, size_t s)\n{\n  return static_cast&lt;uint32_t&gt;(\n    (s + alignment - 1) &amp;\n    ~(alignment - 1));\n}\n</code></pre><p>我们这里把一个大小 <code>s</code> 调整为 <code>alignment</code> 的整数倍。这里 <code>alignment</code> 必须是 2 的整数次幂，否则这个算法不对。一种可能更容易理解、但也更低效的计算方法是 <code>(s + alignment - 1) / alignment * alignment</code>。</p><p>这样，我们终于可以写出 <code>alloc_mem</code> 的定义了：</p><pre><code class=\"language-cpp\">size_t current_mem_alloc = 0;\n\nvoid* alloc_mem(\n  size_t size, const context&amp; ctx,\n  size_t alignment =\n    __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n{\n  uint32_t aligned_list_node_size =\n    align(alignment,\n          sizeof(alloc_list_t));\n  size_t s =\n    size + aligned_list_node_size;\n  auto ptr =\n    static_cast&lt;alloc_list_t*&gt;(\n      aligned_alloc(\n        alignment,\n        align(alignment, s)));\n  if (ptr == nullptr) {\n    return nullptr;\n  }\n  auto usr_ptr =\n    reinterpret_cast&lt;byte*&gt;(ptr) +\n    aligned_list_node_size;\n  ptr-&gt;ctx = ctx;\n  ptr-&gt;size = size;\n  ptr-&gt;head_size =\n    aligned_list_node_size;\n  ptr-&gt;magic = MAGIC;\n  ptr-&gt;prev = alloc_list.prev;\n  ptr-&gt;next = &amp;alloc_list;\n  alloc_list.prev-&gt;next = ptr;\n  alloc_list.prev = ptr;\n  current_mem_alloc += size;\n  return usr_ptr;\n}\n</code></pre><p>简单解释一下：</p><ul>\n<li>我们用一个全局变量 <code>current_mem_alloc</code> 跟踪当前已经分配的内存总量。</li>\n<li>把额外存储信息的大小和用户请求的内存大小都调为 <code>alignment</code> 的整数倍，并使用两者之和作为大小参数来调用 C++17 的 <code>aligned_alloc</code>，进行内存分配；注意 <code>aligned_alloc</code> 要求分配内存大小必须为对齐值的整数倍。</li>\n<li>如果分配内存失败，我们只能返回空指针。</li>\n<li>否则，我们在链表结点里填入内容，插入到链表尾部，增加  <code>current_mem_alloc</code> 值，并返回链表结点后的部分给用户。</li>\n</ul><h3>释放检查</h3><p>释放内存就是一个相反的操作，我们拿到一个用户提供的指针和对齐值，倒推出链表结点的地址，检查其中内容来验证地址的有效性，最后把链表结点从链表中摘除，并释放内存。</p><p>倒推链表结点地址的代码如下（简化版）：</p><pre><code class=\"language-cpp\">alloc_list_t*\nconvert_user_ptr(void* usr_ptr,\n                 size_t alignment)\n{\n  auto offset =\n    static_cast&lt;byte*&gt;(usr_ptr) -\n    static_cast&lt;byte*&gt;(nullptr);\n  auto byte_ptr =\n    static_cast&lt;byte*&gt;(usr_ptr);\n\n  if (offset % alignment != 0) {\n    return nullptr;\n  }\n  auto ptr =\n    reinterpret_cast&lt;alloc_list_t*&gt;(\n      byte_ptr -\n      align(alignment,\n            sizeof(alloc_list_t)));\n  if (ptr-&gt;magic != MAGIC) {\n    return nullptr;\n  }\n\n  return ptr;\n}\n</code></pre><p>我们首先把用户指针 <code>usr_ptr</code> 转换成整数值 <code>offset</code>，然后检查其是否对齐。不对齐的话，这个指针肯定是错误的，这个函数就直接返回空指针了。否则，我们就把用户指针减去链表结点的对齐大小，并转换为正确的类型。保险起见，我们还需要检查魔术数是否正确，不正确同样用空指针表示失败。魔术数正确的话，那我们才算得到了正确的结果。</p><p>检查逻辑基本就在上面了。<code>free_mem</code> 函数则相当简单：</p><pre><code class=\"language-cpp\">void free_mem(\n  void* usr_ptr,\n  size_t alignment =\n    __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n{\n  if (usr_ptr == nullptr) {\n    return;\n  }\n\n  auto ptr = convert_user_ptr(\n    usr_ptr, alignment);\n  if (ptr == nullptr) {\n    puts(\"Invalid pointer or \"\n         \"double-free\");\n    abort();\n  }\n  current_mem_alloc -= ptr-&gt;size;\n  ptr-&gt;magic = 0;\n  ptr-&gt;prev-&gt;next = ptr-&gt;next;\n  ptr-&gt;next-&gt;prev = ptr-&gt;prev;\n  free(ptr);\n}\n</code></pre><p>对于空指针，我们按 C++ 标准不需要做任何事情，立即返回即可。如果倒推链表结点地址失败的话，我们会输出一行错误信息，并终止程序执行——内存错误是一个很严重的问题，通常继续执行程序已经没有意义，还是早点失败上调试器检查比较好。一切成功的话，我们就在 <code>current_mem_alloc</code> 里减去释放内存的大小，清除魔术数（这样才能防止重复释放），从链表中摘除当前结点，最后释放内存。</p><h3>退出检查</h3><p>我们在链表结点里存储了上下文信息，这就让我们后续可以做很多调试工作了。一种典型的应用是在程序退出时进行内存泄漏检查。我们可以使用一个全局 RAII 对象来控制调用 <code>check_leaks</code>，这可以保证泄漏检查会发生在 <code>main</code> 全部执行完成之后（课后思考里有更复杂的方法）：</p><pre><code class=\"language-cpp\">class invoke_check_leak_t {\npublic:\n  ~invoke_check_leak_t()\n  {\n    check_leaks();\n  }\n} invoke_check_leak;\n</code></pre><p>而 <code>check_leaks</code> 所需要做的事情，也就只是遍历内存块的链表而已：</p><pre><code class=\"language-cpp\">int check_leaks()\n{\n  int leak_cnt = 0;\n  auto ptr =\n    static_cast&lt;alloc_list_t*&gt;(\n      alloc_list.next);\n\n  while (ptr != &amp;alloc_list) {\n    if (ptr-&gt;magic != MAGIC) {\n      printf(\"error: heap data \"\n             \"corrupt near %p\\n\",\n             &amp;ptr-&gt;magic);\n      abort();\n    }\n\n    auto usr_ptr =\n      reinterpret_cast&lt;const byte*&gt;(\n        ptr) +\n      ptr-&gt;head_size;\n    printf(\"Leaked object at %p \"\n           \"(size %zu, \",\n           usr_ptr, ptr-&gt;size);\n    print_context(ptr-&gt;ctx);\n    printf(\")\\n\");\n\n    ptr =\n      static_cast&lt;alloc_list_t*&gt;(\n        ptr-&gt;next);\n    ++leak_cnt;\n  }\n  if (leak_cnt) {\n    printf(\"*** %d leaks found\\n\",\n           leak_cnt);\n  }\n\n  return leak_cnt;\n}\n</code></pre><p>我们从链表头（<code>alloc_list.next</code>）开始遍历链表，对每个结点首先检查魔术数是否正确，然后根据 <code>head_size</code> 算出用户内存所在的位置，并和上下文一起打印出来，然后泄漏计数加一。待链表遍历完成之后（遍历指针重新指向 <code>alloc_list</code>），我们打印泄漏内存块的数量，并将其返回。</p><p>对于下面这样一个简单的 <code>main</code> 函数：</p><pre><code class=\"language-cpp\">int main()\n{\n  auto ptr1 = new char[10];\n  MEMORY_CHECKPOINT();\n  auto ptr2 = new char[20];\n}\n</code></pre><p>这是一种可能的运行结果：</p><blockquote>\n<p><code>Leaked object at 0x57930e30 (size 10, context: &lt;UNKNOWN&gt;/&lt;UNKNOWN&gt;)</code><br>\n<code>Leaked object at 0x57930e70 (size 20, context: test.cpp/main)</code><br>\n<code>*** 2 leaks found</code></p>\n</blockquote><h3>一个小细节</h3><p>有一个小细节我们这里讨论一下：<code>context_stack</code> 也需要使用内存，按目前的实现，它的内存占用会计入到“当前”上下文里去，这可能会是一个不必要、且半随机的干扰。为此，我们给它准备一个独立的分配器，使得它占用的内存不被上下文所记录。它的实现如下所示：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nstruct malloc_allocator {\n  typedef T value_type;\n  typedef std::true_type\n    is_always_equal;\n  typedef std::true_type\n    propagate_on_container_move_assignment;\n\n  malloc_allocator() = default;\n  template &lt;typename U&gt;\n  malloc_allocator(\n    const malloc_allocator&lt;U&gt;&amp;)\n  {}\n\n  template &lt;typename U&gt;\n  struct rebind {\n    typedef malloc_allocator&lt;U&gt;\n      other;\n  };\n\n  T* allocate(size_t n)\n  {\n    return static_cast&lt;T*&gt;(\n      malloc(n * sizeof(T)));\n  }\n  void deallocate(T* p, size_t)\n  {\n    free(p);\n  }\n};\n</code></pre><p>除了一些常规的固定代码，这个分配器的主要功能体现在它的 <code>allocate</code> 和 <code>deallocate</code> 的实现上，里面直接调用了 <code>malloc</code> 和 <code>free</code>，而不是 <code>operator new</code> 和 <code>operator delete</code>，也非常简单。</p><p>然后，我们只需要让我们的 <code>context_stack</code> 使用这个分配器即可。</p><pre><code class=\"language-cpp\">thread_local stack&lt;\n  context,\n  deque&lt;context,\n        malloc_allocator&lt;context&gt;&gt;&gt;\n  context_stack;\n</code></pre><p>注意 <code>stack</code> 只是一个容器适配器，分配器参数需要写到它的底层容器 <code>deque</code> 里去才行。</p><h2>内容小结</h2><p>本讲我们综合运用迄今为止学到的多种知识，描述了一个使用栈式上下文对内存使用进行调试的工具。目前这个工具只是简单地记录上下文信息，并在检查内存泄漏时输出未释放的内存块的上下文信息。你可以根据自己的需要对其进行扩展，来满足特定的调试目的。</p><h2>课后思考</h2><p>Nvwa 项目提供了一个根据本讲思路实现的完整的内存调试器，请参考其中的 memory_trace.* 和 aligned_memory.* 文件 <span class=\"orange\">[3]</span>。它比本讲的介绍更加复杂一些，对跨平台和实际使用场景考虑更多，如：</p><ul>\n<li>多线程加锁保护，并通过自定义的 <code>fast_mutex</code> 来规避 MSVC 中的 <code>std::mutex</code> 的重入问题</li>\n<li>不直接调用标准的 <code>aligned_alloc</code> 和 <code>free</code> 来分配和释放内存，解决对齐分配的跨平台性问题</li>\n<li>对 <code>new[]</code> 和 <code>delete</code> 的不匹配使用有较好的检测</li>\n<li>使用 RAII 计数对象来尽可能延迟对 <code>check_leaks</code> 的调用</li>\n<li>更多的错误检测和输出</li>\n<li>……</li>\n</ul><p>请自行分析这一实际实现中增加的复杂性。如有任何问题，欢迎留言和我进行讨论。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] GNU, GCC Manual, section “Function Names as Strings”. <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html\">https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html</a></span></p><p><span class=\"reference\">[2] Microsoft, “Predefined macros”. <a href=\"https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170\">https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170</a></span></p><p><span class=\"reference\">[3] 吴咏炜, nvwa. <a href=\"https://github.com/adah1972/nvwa/\">https://github.com/adah1972/nvwa/</a></span></p>","neighbors":{"left":{"article_title":"34｜快速分配和释放内存：内存池","id":503029},"right":{"article_title":"36｜访问对象的代理对象：视图类型","id":513719}}},{"article_id":513719,"article_title":"36｜访问对象的代理对象：视图类型","article_content":"<p>你好，我是吴咏炜。</p><p>前面我们用连续五讲讨论了内存相关的很多问题，这是因为在 C++ 里，开发人员需要认真考虑对象的生命周期，包括对其内存进行管理。我们需要保证对象使用的内存，不会在对象还在使用时就会被释放。在其他一些语言里，或者使用跟踪垃圾收集，或者使用引用计数，可以自动化这一过程。C++ 理论上来讲也可以这样做，如到处使用 <code>shared_ptr</code>，但这样的话，程序的执行性能就会受到影响。我们之所以有这么多灵活的机制来控制内存的使用，就是为了让程序员对内存的分配和释放有最大的控制权，在需要的场合下得到最高的效率。付出的代价当然就是语言的复杂性了。</p><p>但我们还有另外一类问题，我们在使用一个对象时，明确知道这个对象在使用过程中一直存在，它的生命周期一定会超出我们的使用时间。在这种情况下，如果我们要使用这个对象，或者这个对象的一部分，就没有必要进行内存分配和对象创建、复制、销毁了。按引用或指针来访问这类对象是一种可能性，但通过一个代理对象来访问底层数据往往更加灵活和方便，并可以提供接口上的一致性。这类代理对象我们通常以值的方式进行传参和返回，非常简单、也非常高效。<code>string_view</code> 就是这样的一种对象类型。</p><!-- [[[read_end]]] --><h2>string_view</h2><p><code>string_view</code> 是 C++17 引入的一种新类型，它提供了非常方便的传递字符串（或其中一部分）的方式 <span class=\"orange\">[1]</span>。我们先来看看它的基本用法。</p><h3>示例</h3><p>下面是一个非常简单的使用 <code>string_view</code> 的例子：</p><pre><code class=\"language-cpp\">string greet(string_view name)\n{\n  string result(\"Hi, \");\n  result += name;\n  result += '!';\n  return result;\n}\n</code></pre><p>这个 <code>greet</code> 函数接受一个 <code>string_view</code>，然后生成一个字符串返回。显然，我们可以传递一个 <code>string_view</code> 对象给这个函数，但更重要的是，我们可以传递其他更常用的字符串类对象，包括字符串字面量和 <code>string</code>。</p><p>这样是可以的：</p><pre><code class=\"language-cpp\">auto greeting = greet(\"C++\");\n</code></pre><p>这样也是可以的：</p><pre><code class=\"language-cpp\">string name;\ngetline(cin, name);\nauto greeting = greet(name);\n</code></pre><h3>原理</h3><p>我们可以这样做的原因，是因为 <code>string_view</code> 可以通过（常）字符指针来构造，而 <code>string</code> 也能自动转换成 <code>string_view</code>。究其本质，<code>string_view</code> 只保存两样东西：</p><ul>\n<li>一个 <code>const char*</code>，指向字符串的开头</li>\n<li>一个 <code>size_t</code>，表示字符串的长度</li>\n</ul><p>换句话说，<code>string_view</code> 是一个字符串的视图，不保存字符串，而只保存字符串的指针和长度。使用者需要确保在使用 <code>string_view</code> 的时候，底层的字符串一直存在。</p><p>想要构造一个 <code>string_view</code>，你可以提供一个指针加一个长度。不过，更常见的用法，仍然是通过字符串字面量来构造 <code>string_view</code>，及把 <code>string</code> 自动转换成 <code>string_view</code>。</p><p>这里顺便提一下<a href=\"https://time.geekbang.org/column/article/169268\">第 3 讲</a>里说过的字符串字面量是左值的原因。对于一个字符串字面量，编译器实际上是会默认生成一个静态的字符串对象的，即上面的前一种写法基本等效于：</p><pre><code class=\"language-cpp\">static const char _str1[] = \"C++\";\nauto greeting = greet(_str1);\n</code></pre><p>无论使用上面的前一种写法（使用字符串字面量作为实参）还是后一种写法（使用 <code>string</code> 作为实参），显然，在 <code>greet</code> 函数的运行期间，我们都完全不需要担心字符串的生命周期。</p><h3>生命周期问题</h3><p>反过来，当然我们也会有一些可能出问题的场合。比如，下面这种写法就是有问题的：</p><pre><code class=\"language-cpp\">string_view name = \"C++\"s;\n</code></pre><p>估计这种代码一般不会有人写，但这个代码在语法上是完全合法的。它的意思是从一个临时 <code>string</code> 对象来生成一个 <code>string_view</code>，而问题在于，在这行语句执行结束时，临时 <code>string</code> 对象就已经不存在。因此 <code>string_view</code> 对象会指向已经被销毁的字符串对象，导致未定义行为。你后面再去使用 <code>name</code> 的话，会发现它有时有你期望的内容，有时则是乱码，有时甚至可能导致程序崩溃。遗憾的是，目前（2022 年）的主流 C++ 编译器里，只有 Clang 会对这样的代码进行告警。</p><p>另外一种可能的出错场景是把 <code>string_view</code> 存下来或返回。在 <code>greet</code> 的执行期间，正常的代码没有任何理由会修改底层字符串或发生生命周期问题；即使我们用类似上面错误的方式写 <code>greet(\"C++\"s)</code>，代码仍然是完全合法的，因为临时字符串对象的析构动作会发生在 <code>greet</code> 函数返回之后。但如果这个函数把 <code>string_view</code> 存下来或返回，则又是另外一个故事——类似于上面的错误就又可能发生了。</p><h3>string_view 的好处</h3><p>你可能会想，既然有生命周期的陷阱，那我们为什么要使用 <code>string_view</code> 呢？</p><p>因为好处也是很大的。我们可以检查一下上面这个函数的替换接口形式：</p><ol>\n<li>我们可以使用 <code>greet(const string&amp;)</code> 这样的按引用传参方式。这样的参数形式对 <code>string</code> 实参当然很友好，但对于字符串字面量就不友好了。虽然使用字符串字面量看起完全自动很正常，但编译器产生的代码是相当无聊和低效的：它会生成一个临时 <code>string</code> 对象，把字符串字面量中的内容全部复制进去，然后拿这个临时对象去调用 <code>greet</code> 函数，并在函数返回之后销毁这个临时的 <code>string</code> 对象。</li>\n<li>我们可以使用 <code>greet(const char*)</code> 这样的传统接口。这样的参数形式对字符串字面量实参很友好，但对 <code>string</code> 对象来讲，就不方便了——我们会需要使用 <code>s.c_str()</code> 这样的形式来传参。还有，如果这个字符串很长，获取字符串的长度也会是一个低效的 O(n) 操作。此外，我们也没法直接使用 <code>string</code> 类提供的方便方法了，如 <code>find</code>、<code>substr</code> 等。</li>\n</ol><p>如果我们把形参替换成 <code>string_view</code> 的话：</p><ol>\n<li>当我们传递的实参为 <code>string</code> 时，<code>string</code> 会使用内部指针和长度高效地生成 <code>string_view</code> 对象。</li>\n<li>当我们传递的实参可退化为 <code>const char*</code> 时，那编译器会自动获取这个字符串的长度（通过调用 <code>char_traits&lt;char&gt;::length(s)</code>）。这里又可以细分为两种情况：字符串内容在编译时确定（即字符串字面量），及字符串内容在编译时不确定。当字符串内容在编译时可确定时，<code>string_view</code> 具有最大的优势：不仅我们没有任何额外的开销，而且目前的主流优化编译器都可以在编译时算出字符串的长度，因而可以产生最高效的代码。否则，<code>string_view</code> 会在代码执行时去动态获取字符串的长度，在你后续需要字符串长度时也非常合适，不算额外开销。</li>\n</ol><p>此外，虽然 <code>string_view</code> 不是 <code>string</code>，它的成员函数跟 <code>string</code> 还是非常相似的。我们同样有 <code>data</code>、<code>size</code>、<code>begin</code>、<code>end</code>、<code>find</code> 等方法。它跟 <code>string</code> 最为显著的不同点是：</p><ul>\n<li>你不能修改字符串的内容。<code>data</code> 成员函数返回的是 <code>const char*</code>，而不像 <code>string</code> 的 <code>data</code> 成员函数从 C++17 开始可以返回 <code>char*</code>，允许程序员直接通过指针修改底层的字符串（当然，不允许超过尾部）。</li>\n<li>没有 <code>c_str</code> 成员函数。从语义上说，<code>string</code> 的 <code>data</code> 成员函数只是返回指针，在 C++11 之前甚至不保证字符串会零结尾；而只有 <code>c_str</code> 是从 C++98 开始就一直保证返回的字符串是零结尾的。<code>string_view</code> 的 <code>data</code> 成员函数返回的字符串又不保证零结尾了，即使我们构造 <code>string_view</code> 使用的字符串是零结尾的——因为只有这样，我们才能高效地取出 <code>string_view</code> 的一部分，形成一个新的 <code>string_view</code> 对象。这也意味着，我们在需要把字符串指针传到期待零结尾字符串的 C 函数接口里去时，使用 <code>string_view</code> 是不合适的。</li>\n<li><code>substr</code> 成员函数返回的是一个新的 <code>string_view</code>，而非 <code>string</code>。产生新的指针和长度只是简单的加减运算，当然也就很高效，但别忘了，刚说过的，产生的结果可能不是零结尾，即使原始的 <code>string_view</code> 是零结尾。</li>\n<li>我们额外有成员函数 <code>remove_prefix</code> 和 <code>remove_suffix</code>，可以修改当前 <code>string_view</code> 对象（但不会动底下的字符串）。<code>remove_prefix</code> 去掉开头的若干字符，因而如果 <code>string_view</code> 原先是零结尾的话，现在仍然是零结尾；<code>remove_suffix</code> 去掉结尾的若干字符，显然，即使 <code>string_view</code> 原先是零结尾的，在这个操作之后就不再是零结尾的了。</li>\n</ul><p>最后，强调一点，我上面一直在讲 <code>string_view</code>，那主要是因为对于不开发 Windows 应用的人来说，<code>string_view</code> 一般就已经够用了。实际上，<code>string_view</code> 跟 <code>string</code> 一样，是一个类型别名：<code>std::string_view</code> 相当于 <code>std::basic_string_view&lt;char&gt;</code>。我们是可以使用其他字符类型去特化 <code>basic_string_view</code> 的，系统也已经帮我们定义了相应的别名，如 <code>wstring_view</code>、<code>u32string_view</code> 等等。你可以根据自己的需要进行选用。</p><h2>span</h2><p>C++20 引入的 <code>span</code> 是另外一个非常有用的视图类型 <span class=\"orange\">[2]</span>。如果你想在 C++14/17 的环境里使用 <code>span</code> 的话，则可以使用微软 GSL 库中定义的 <code>gsl::span</code> <span class=\"orange\">[3]</span>。除了名空间的不同（<code>std</code> 还是 <code>gsl</code>），它们目前行为基本一致，除了一点：<code>gsl::span</code> 会做越界检查，因而更安全，但也可能因此带来一些性能问题。我们后面会再来讨论这一点。</p><h3>示例</h3><p>同样，我们先通过一些例子来对 <code>span</code> 有一些直观的了解。</p><p>假设我们有一个通用的打印整数序列的函数：</p><pre><code class=\"language-cpp\">void print(span&lt;int&gt; sp)\n{\n  for (int n : sp) {\n    cout &lt;&lt; n &lt;&lt; ' ';\n  }\n  cout &lt;&lt; '\\n';\n}\n</code></pre><p>我们可以使用各种各样提供连续存储的整数“容器”作为实参传给 <code>print</code> 函数。比如，下面这些变量都是可以传递给 <code>print</code> 的：</p><pre><code class=\"language-cpp\">array a{1, 2, 3, 4, 5};\nint b[]{1, 2, 3, 4, 5};\nvector v{1, 2, 3, 4, 5};\n</code></pre><p>而不提供连续存储的容器则不能这么用，如：</p><pre><code class=\"language-cpp\">list lst{1, 2, 3, 4, 5};\n</code></pre><p>但是，如果你认为 <code>span&lt;char&gt;</code> 和 <code>string_view</code> 有对应关系的话，那就错了。最核心的区别在于，<code>span&lt;char&gt;</code> 会允许你更改底层的数据，而 <code>string_view</code> 不允许。刨除接口上的区别，<code>span&lt;const char&gt;</code> 跟 <code>string_view</code> 有相似之处。我上面给出的 <code>print</code> 实际是 const 不正确的，你如果有一个容器的 const 引用的话，将无法使用 <code>print</code> 函数来打印。</p><p>正确的 <code>print</code> 版本和另外一个修改容器内容的 <code>increase</code> 函数如下所示：</p><pre><code class=\"language-cpp\">void print(span&lt;const int&gt; sp)\n{\n  for (int n : sp) {\n    cout &lt;&lt; n &lt;&lt; ' ';\n  }\n  cout &lt;&lt; '\\n';\n}\n\nvoid increase(span&lt;int&gt; sp,\n              int value = 1)\n{\n  for (int&amp; n : sp) {\n    n += value;\n  }\n}\n</code></pre><p>如果我们调用 <code>increase(a)</code> 的话，<code>a</code> 的内容就会变为 <code>{2, 3, 4, 5, 6}</code>。</p><h3>一些技术细节</h3><p>我们可以直接使用指针加长度来构造 <code>span</code>，我们也可以用连续存储的序列范围作为参数来构造 <code>span</code>（GSL 和 C++20 使用了不同的方法来限制容器类型，但结果仍是基本一致的），一般有：</p><ul>\n<li>C 风格数组</li>\n<li><code>array</code></li>\n<li><code>vector</code></li>\n<li>其他 <code>span</code></li>\n</ul><p>跟连续存储的序列容器（如 <code>vector</code>）及 <code>string_view</code> 一样，<code>span</code> 具有一些标准的 STL 成员函数，如：</p><ul>\n<li><code>begin</code></li>\n<li><code>end</code></li>\n<li><code>front</code></li>\n<li><code>back</code></li>\n<li><code>size</code></li>\n<li><code>empty</code></li>\n<li><code>data</code></li>\n<li><code>operator[]</code></li>\n<li>……</li>\n</ul><p><code>span</code> 也有一些自己特有的成员函数：</p><ul>\n<li><code>size_bytes</code>：字节数来计算的序列大小（而非元素数）</li>\n<li><code>first</code>：开头若干项组成的新 <code>span</code>（注意这和 <code>string_view::remove_prefix</code> 和 <code>string_view::remove_suffix</code> 代码风格不同，不修改自身）</li>\n<li><code>last</code>：结尾若干项组成的新 <code>span</code>（注意这和 <code>string_view::remove_prefix</code> 和 <code>string_view::remove_suffix</code> 代码风格不同，不修改自身）</li>\n<li><code>subspan</code>：根据给定的偏移量和长度组成的新 <code>span</code>（这和 <code>string_view::substr</code> 就比较类似了）</li>\n</ul><p><code>span</code> 还有一个特点，它的长度可以是编译期确定的。它有第二个模板参数 <code>extent</code>，默认值是 <code>dynamic_extent</code>，代表动态的长度，这种方式较为常用和灵活。但如果你的 <code>span</code> 可以在编译期确定长度的话，你也完全可以利用这一特性来对代码进行进一步的优化。事实上，对于数组和 <code>array</code> 的情况，如果你不指定模板参数的话，默认推导就会得出一个编译期固定的长度。</p><p>比如，对于我们前面定义的变量 <code>a</code>，我们使用 <code>span sp{a};</code> 这样的声明会产生的实际类型不是 <code>span&lt;int, dynamic_extent&gt;</code>，而是 <code>span&lt;int, 5&gt;</code>。由于长度编码在类型里，长度不占用内存空间，因而它比 <code>span&lt;int&gt;</code> 一般要少占用一半内存（虽然这通常不重要）。同时，动态长度的 <code>span</code> 能通过静态长度的 <code>span</code> 构造出来，因此把这个静态长度的 <code>sp</code> 传给 <code>print</code> 函数也没有问题。</p><p>最后，再重复一遍，<code>span</code> 本质上就是指针加长度的一个语法糖，程序员必须保证在使用 <code>span</code> 时，底层的数据一直合法地存在，否则会导致未定义行为。我曾经见过一个很隐晦的 bug，本质上代码差不多是下面这个样子（<code>Data</code> 是某个结构体）：</p><pre><code class=\"language-cpp\">span&lt;Data&gt; sp;\n…\nif (…) {\n  vector&lt;Data&gt; v = …;\n  sp = v;\n}\nDoSomething(sp);\n</code></pre><p>这就是一个典型的释放后使用。麻烦的是，在单线程的情况下，代码运行通常不会出错，你很难发现里面的问题。问题通常在多线程环境才会暴露出来：有其他线程正好分配到了被释放的内存，并在 <code>DoSomething</code> 执行完之前往里写入了其他内容。这显然不是一个可以非常容易复现的问题，你可以想象一下测试人员在抓这个虫子的时候有多么的苦恼……</p><h3>gsl::span 的性能问题</h3><p>前面我提到过，<code>gsl::span</code> 会做越界检查，更安全，但也因此可能带来一些性能问题。最典型的情况就是把一个 <code>span</code> 的内容复制到另一个 <code>span</code> 里去，如：</p><pre><code class=\"language-cpp\">std::copy(sp1.begin(),\n          sp1.end(),\n          sp2.begin());\n</code></pre><p>目前测试下来，除了 MSVC 标准库的 <code>copy</code> 实现对 <code>span</code> 有特殊的处理逻辑，其他环境都会因为每拷贝一个元素都要执行越界检查而导致巨大的性能损失。当然，取决于具体的编译器，产生的影响也各不相同。在最坏的情况下，我看到过使用 <code>gsl::span</code> 要比使用 <code>std::span</code> 性能劣化几十倍！</p><p>所幸，这个问题有一个非常简单的解决方法，使用 <code>gsl::copy</code> 即可：</p><pre><code class=\"language-cpp\">gsl::copy(sp1, sp2);\n</code></pre><p>这个写法简单、有边界检查，也没有额外的开销，看一下 <code>gsl::copy</code> 的源代码，你就知道它是先检查边界，再使用指针和长度进行拷贝：</p><pre><code class=\"language-cpp\">Expects(dest.size() &gt;= src.size());\nstd::copy_n(src.data(), src.size(), dest.data());\n</code></pre><p>有兴趣的话，你可以拿我放在<a href=\"https://github.com/adah1972/geek_time_cpp\">代码库</a>的测试程序来自行测试一下。</p><h2>视图类型</h2><p>通过以上两个例子，我想你基本已经知道视图类型是怎么回事了。一般而言，视图类型：</p><ul>\n<li>是个小对象，可以在常数时间拷贝、移动或赋值</li>\n<li>一般以传值方式来使用（除非你想修改视图本身，如将其缩小）</li>\n<li>跟容器一样支持遍历操作</li>\n<li>不持有数据，使用者需要保证在视图存续期间其指向的数据一直存在（不过，像 <code>shared_ptr</code> 一样通过引用计数来持有底层对象在实现上也是允许的）</li>\n</ul><p>到 C++17 为止，<strong>视图</strong>还不是一个语言层面能真正表达的概念。而到了 C++20，我们就真正有了 <code>view</code> 这个概念，来支持对视图的表达 <span class=\"orange\">[4]</span>。</p><p>不过，从实用的角度，程序员更高兴的应该是 C++20 范围库里提供的各种有用的视图了 <span class=\"orange\">[5]</span>。我在<a href=\"https://time.geekbang.org/column/article/195553\">第 29 讲</a>里介绍过一些，今天我再讲一个 <code>elements_view</code> 作为例子 <span class=\"orange\">[6]</span>。</p><p>对于一个有类 <code>tuple</code> 元素类型的容器（包括 <code>map</code>、<code>unordered_map</code>、<code>vector&lt;tuple&lt;…&gt;&gt;</code> 等），<code>elements_view</code> 的作用是形成所有元素中的某一项的视图。特别地，取第 0 项的也被称为 <code>keys_view</code>（<code>keys_view&lt;R&gt;</code> 相当于 <code>elements_view&lt;R, 0&gt;</code>），取第 1 项的也被称为 <code>values_view</code>（<code>values_view&lt;R&gt;</code> 相当于 <code>elements_view&lt;R, 1&gt;</code>）。这就使得我们访问一个 <code>map</code> 中的所有“键”（keys）或所有“值”（values）变得非常方便。</p><p>比如，如果使用我之前介绍的 output_container 的“升级”版本 output_range <span class=\"orange\">[7]</span>，我们可以用下面的代码来输出 <code>map</code> 中的第二项：</p><pre><code class=\"language-cpp\">map&lt;int, string&gt; mp{{1, \"one\"},\n                    {2, \"two\"},\n                    {3, \"three\"}};\nauto vv = mp | views::values;\ncout &lt;&lt; vv &lt;&lt; endl;\n</code></pre><p><code>vv</code> 就是一个 <code>mp</code> 里所有“值”的视图，它的实际类型相当复杂，你不会想手工把它写出来的——这点上，范围库里的视图跟我们前面介绍的 <code>string_view</code> 和 <code>span</code> 不同。不过，你仍然可以用 <code>auto</code> 来对它进行接收和复制，这些都是非常轻量的操作。程序实际产生的输出为：</p><blockquote>\n<p><code>{ one, two, three }</code></p>\n</blockquote><h2>内容小结</h2><p>本讲我们介绍了几个有用的视图类型。使用它们，你可以简化代码、统一函数的接口，同时保持程序的高效执行。这些类型的对象可以高效返回和复制，你唯一需要考虑的，就是保证视图里面实际指向的对象在视图的使用期间仍然一直存在。</p><h2>课后思考</h2><p>在很多使用视图类型的场景下（如 <code>print</code> 和 <code>increase</code>），我们可以使用一个函数模板来代替，把参数从 <code>span&lt;int&gt;</code> 变成类型模板参数（<code>const T&amp;</code> 和 <code>T&amp;</code>）即可。请你想一想，两种方式各有什么优缺点？</p><p>你能不能利用迭代器（参考<a href=\"https://time.geekbang.org/column/article/176842\">第 7 讲</a>）和模板，在 C++17 下自行实现出一个 <code>elements_view</code>？这会是一个不错的小练习。</p><p>最后，别忘了<a href=\"https://github.com/adah1972/geek_time_cpp\">代码库</a>里有示例代码可供运行和参考。如有任何问题，欢迎留言和我讨论。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “std::basic_string_view”. <a href=\"https://en.cppreference.com/w/cpp/string/basic_string_view\">https://en.cppreference.com/w/cpp/string/basic_string_view</a></span></p><p><span class=\"reference\">[1a] cppreference.com, “std::basic_string_view”. <a href=\"https://zh.cppreference.com/w/cpp/string/basic_string_view\">https://zh.cppreference.com/w/cpp/string/basic_string_view</a></span></p><p><span class=\"reference\">[2] cppreference.com, “std::span”. <a href=\"https://en.cppreference.com/w/cpp/container/span\">https://en.cppreference.com/w/cpp/container/span</a></span></p><p><span class=\"reference\">[2a] cppreference.com, “std::span”. <a href=\"https://zh.cppreference.com/w/cpp/container/span\">https://zh.cppreference.com/w/cpp/container/span</a></span></p><p><span class=\"reference\">[3] Microsoft, “GSL”. <a href=\"https://github.com/microsoft/GSL\">https://github.com/microsoft/GSL</a></span></p><p><span class=\"reference\">[4] cppreference.com, “std::ranges::view”. <a href=\"https://en.cppreference.com/w/cpp/ranges/view\">https://en.cppreference.com/w/cpp/ranges/view</a></span></p><p><span class=\"reference\">[4a] cppreference.com, “std::ranges::view”. <a href=\"https://zh.cppreference.com/w/cpp/ranges/view\">https://zh.cppreference.com/w/cpp/ranges/view</a></span></p><p><span class=\"reference\">[5] cppreference.com, “Ranges library”. <a href=\"https://en.cppreference.com/w/cpp/ranges\">https://en.cppreference.com/w/cpp/ranges</a></span></p><p><span class=\"reference\">[5a] cppreference.com, “范围库”. <a href=\"https://zh.cppreference.com/w/cpp/ranges\">https://zh.cppreference.com/w/cpp/ranges</a></span></p><p><span class=\"reference\">[6] cppreference.com, “std::ranges::elements_view”. <a href=\"https://en.cppreference.com/w/cpp/ranges/elements_view\">https://en.cppreference.com/w/cpp/ranges/elements_view</a></span></p><p><span class=\"reference\">[6a] cppreference.com, “std::ranges::elements_view”. <a href=\"https://zh.cppreference.com/w/cpp/ranges/elements_view\">https://zh.cppreference.com/w/cpp/ranges/elements_view</a></span></p><p><span class=\"reference\">[7] 吴咏炜, output_range. <a href=\"https://github.com/adah1972/output_range\">https://github.com/adah1972/output_range</a></span></p>","neighbors":{"left":{"article_title":"35 | 发现和识别内存问题：内存调试实践","id":508706},"right":{"article_title":"37｜参数传递的正确方法和模板的二进制膨胀","id":517514}}},{"article_id":517514,"article_title":"37｜参数传递的正确方法和模板的二进制膨胀","article_content":"<p>你好，我是吴咏炜。</p><p>上一讲我们讨论的视图类型的对象，通常和内置类型的对象一样，是使用传值的方式来进行传参的。这种方式非常简单，也是比较推荐的 C++ 的做法，但这种方式存在对对象类型的限制。在对象比较大的时候，或者可能比较大的时候，按值传参就可能有性能问题。这包括了大部分的函数模板，除非你能预知用来实例化模板的参数。此外，还有很多对象可能是不可复制、甚至不可移动的，显然，这些对象你也不可能按值传参。此时，你就只能使用引用或指针来传参了。</p><h2>参数传递的方式</h2><p>函数的参数有入参、出参和出入参之分。入参是最常见的情况，意味着一个参数是让函数来使用的。出参表示一个参数是函数来写的，它必须是一个引用或指针，在现代 C++ 里已经较少推荐，因为返回对象（包括结构体、<code>pair</code>、<code>tuple</code> 等）往往可导致更加清晰、更加安全、同时性能也不下降的代码。出入参是一种中间情况，参数会被函数同时读和写。它也是引用或指针，常常是一个序列的对象（如 <code>vector</code> 和 <code>string</code>），里面本来就有内容，并在函数执行的过程中让函数继续往里添加内容。</p><p>对于现代 C++，非可选的出参和出入参通常使用引用方式，这样的代码写起来会更加方便。而可选的出参和出入参则一般使用指针方式，可以用空指针表示这个参数不被使用。而入参的情况就复杂多了：</p><!-- [[[read_end]]] --><ul>\n<li>如果一个入参是不可选，且它的类型为内置类型或小对象（可按两个指针的大小作初步估算），应当使用值传参的方式（<code>Obj obj</code>）：数字类型、指针类型、视图类型一般会使用这种方式。</li>\n<li>如果一个入参是不可选的，默认可使用 const 左值引用的方式（<code>const Obj&amp; obj</code>）：容器、大对象和堆上分配内存的对象一般会使用这种方式。</li>\n<li>如果一个入参是可选的，则可以使用指针传参，使用空指针表示这个参数不存在（<code>Obj* ptr</code> 或 <code>const Obj* ptr</code>）。</li>\n<li>如果一个入参是不可选、移动友好的，且在函数中需要产生一个拷贝，那可以使用值方式传参（<code>Obj obj</code>）。</li>\n</ul><p>前三种情况都比较直白，应该只有最后一种需要说明一下。使用值传参的典型情况是构造函数、赋值运算符和利用入参构造新对象的函数。我们在<a href=\"https://time.geekbang.org/column/article/169263\">第 2 讲</a>就给出过使用值传参的赋值运算符的例子。这里，我再举一个构造函数来说明一下。如果我们需要传递一个字符串给构造函数，让构造函数把它作为成员变量存下来以供后续使用和更改，那我们这个参数使用 <code>string</code> 就挺合适：</p><pre><code class=\"language-cpp\">class Obj {\npublic:\n  explicit Obj(string name)\n    : name_(move(name)) {}\n  …\n\nprivate:\n  string name_;\n};\n</code></pre><p>这样写的话，如果我们传递一个左值 <code>string</code> 给 <code>Obj</code> 构造函数的话，编译器会产生一次拷贝和一次移动，把名字写到 <code>name_</code> 里，比使用 <code>const string&amp;</code> 作为参数类型多一次移动。它的优点是当 <code>string</code> 是一个临时对象的时候（包括用户传递字符串字面量的情况），<code>Obj</code> 的构造函数会通过两次移动把名字写到 <code>name_</code> 里。这时候，如果我们使用的是 <code>const string&amp;</code> 的话，临时构造出来的 <code>string</code> 对象就不能被移动，而是白白地构造和析构了，浪费。</p><p>当然，入参也可以是右值引用，但这对于普通的函数（移动构造函数、移动赋值运算符之外）就很少见了，因为大部分情况下没有必要要求入参必须是个临时对象。同时提供左值引用和右值引用的重载是一种可能性，但除了在追求极致优化的基础库里，一般并不值得这么做。</p><p>上面说的情况都是参数类型（<code>Obj</code>）已知的情况。对于函数模板，参数类型本身可能是一个模板参数。这种情况下，我们又应该如何处理呢？</p><h3>转发引用</h3><p>实际上，基本原则跟上面仍然是类似的，除了我们需要把参数继续往下传到另外一个函数去、并且我们不知道这个参数会如何被使用的情况。这时，我们通常会使用转发引用。</p><p>转发引用的一个典型形式是在 <code>make_unique</code>、<code>make_shared</code>、<code>emplace</code> 等函数或方法里传递未知数量和类型的参数，如：</p><pre><code class=\"language-cpp\">template &lt;typename T,\n          typename... Args&gt;\nauto make_unique(Args&amp;&amp;... args)\n{\n  return unique_ptr&lt;T&gt;(\n    new T(forward&lt;Args&gt;(args)...));\n}\n</code></pre><p>刨除不常见的 const 右值的情况，我们来具体分析一下常见的三种场景（先限定单参数的情况）：</p><ul>\n<li>当给定的参数是 const 左值（如 <code>const Obj&amp;</code>）时，<code>Args</code> 被推导为 <code>const Obj&amp;</code>，这样，在引用坍缩后，<code>Args&amp;&amp;</code> 仍然是 <code>const Obj&amp;</code>。</li>\n<li>当给定的参数是非 const 左值（如 <code>Obj&amp;</code>）时，<code>Args</code> 被推导为 <code>Obj&amp;</code>，这样，在引用坍缩后，<code>Args&amp;&amp;</code> 仍然是 <code>Obj&amp;</code>。</li>\n<li>当给定的参数是右值（如 <code>Obj&amp;&amp;</code>）时，<code>Args</code> 被推导为 <code>Obj</code>，这样，<code>Args&amp;&amp;</code> 当然仍保持为 <code>Obj&amp;&amp;</code>。</li>\n</ul><p>回顾一下，我们这里要使用 <code>forward</code> 的原因是，所有的变量都是左值，因此，如果我们要保持“右值性”，就得使用强制类型转换。<code>forward</code> 所做的事情，本质上就是 <code>static_cast&lt;Args&amp;&amp;&gt;(args)</code>，右值被转换成右值引用（xvalue），左值仍保持为左值引用（由于引用坍缩）。</p><p>一般而言，转发引用之后总会跟着 <code>forward</code> 的使用。反过来，如果转发引用后面没有 <code>forward</code> 的话，则是非常可疑的（ranges 是一种常见的例外）<span class=\"orange\">[1]</span>。</p><h3>auto&amp;&amp;</h3><p>转发引用的另外一种常见用法是 <code>auto&amp;&amp;</code>。可能的场景有：</p><ul>\n<li>在变量声明中使用</li>\n<li>在泛型 lambda 表达式中使用</li>\n<li>在 C++20 的函数模板参数声明中使用</li>\n</ul><p>我们可以写：</p><pre><code class=\"language-cpp\">auto&amp;&amp; x = …;\n</code></pre><p>我们可以写：</p><pre><code class=\"language-cpp\">for (auto&amp;&amp; item : rng) {\n  …\n}\n</code></pre><p>我们也可以写：</p><pre><code class=\"language-cpp\">auto lambda = [](auto&amp;&amp; x,\n                 auto&amp;&amp; y) {\n  // 处理并返回\n};\n</code></pre><p>到了 C++20，我们还可以写：</p><pre><code class=\"language-cpp\">auto process(auto&amp;&amp; x, auto&amp;&amp; y)\n{\n  // 处理并返回\n}\n</code></pre><p>这么写着还真方便啊，也不用管参数是不是 const，及到底是左值还是右值了。爽。</p><h3>转发引用的问题</h3><p>如果你真这么觉得的话，那你显然忘了我刚写的这句话了：</p><blockquote>\n<p>一般而言，转发引用之后总会跟着 <code>forward</code> 的使用。反过来，如果转发引用后面没有 <code>forward</code> 的话，则是非常可疑的（ranges 是一种常见的例外）。</p>\n</blockquote><p>我们先抛开不谈语义问题（毕竟，如果没有副作用，语义不正确在某些时候也是可以接受的……），看看这么写有什么实际问题。</p><p>拿泛型 lambda 表达式那个例子来说，它本质上相当于下面的函数对象定义：</p><pre><code class=\"language-cpp\">struct Unnamed {\n  template &lt;typename T1,\n            typename T2&gt;\n  auto operator()(T1&amp;&amp; x,\n                  T2&amp;&amp; y) const\n  {\n    // 处理并返回\n  }\n} lambda;\n</code></pre><p>粗粗一看，似乎也没什么问题，是吧？</p><p>假设我们有下面的变量定义：</p><pre><code class=\"language-cpp\">int n;\nlong long lln;\nspan&lt;const int&gt; sp;\n</code></pre><p>问题来了：下面的表达式会产生多少个不同的特化（实例化结果）？</p><pre><code class=\"language-cpp\">lambda(n, lln);\nlambda(lln, n);\nlambda(n, 1);\nlambda(n, sp[0]);\nlambda(sp[0], lln);\n</code></pre><p>问题实际不难，我们只需要按照推导规则把参数类型一一填进去即可：</p><pre><code class=\"language-cpp\">Unnamed::operator()&lt;int&amp;, long long&amp;&gt;;\nUnnamed::operator()&lt;long long&amp;, int&amp;&gt;;\nUnnamed::operator()&lt;int&amp;, int&gt;;\nUnnamed::operator()&lt;int&amp;, const int&amp;&gt;;\nUnnamed::operator()&lt;const int&amp;, long long&amp;&gt;;\n</code></pre><p>所有的情况都是不同的，所以有五种不同的特化！这就意味着，至少从理论上来说，这五种不同的使用方式可能会产生五份不同的二进制代码。</p><h3>避免不必要的转发引用</h3><p>那这是不是真的会成为一个问题呢？这……取决于具体情况，尤其取决于代码是不是可以被良好地内联。作为一般的指导原则，消除不必要的特化是最简单的处理方式。</p><p>就我们目前这个具体例子来说，假设我们不修改入参 <code>x</code> 和 <code>y</code>，我们有两种不同的处理方式：</p><ul>\n<li>如果我们的参数只会是内置类型（如上面用到的 <code>int</code>、<code>long long</code> 等），我们可以按值传参</li>\n<li>如果我们对参数类型和大小无法确定，那使用 const 引用会是一个不错的选择</li>\n</ul><p>如果把这个例子的 <code>auto&amp;&amp;</code> 改一下：</p><pre><code class=\"language-cpp\">auto lambda = [](const auto&amp; x,\n                 const auto&amp; y) {\n  // 处理并返回\n};\n</code></pre><p>那我们至少可以把上面的五种特化缩减到三种了：</p><pre><code class=\"language-cpp\">Unnamed::operator()&lt;int, long long&gt;;\nUnnamed::operator()&lt;long long, int&gt;;\nUnnamed::operator()&lt;int, int&gt;;\n</code></pre><p>注意，我主要想说明的是我们应当避免不必要的转发引用，而不是避免所有的转发引用。特别是，如果你在 <code>auto&amp;&amp;</code> 后面需要使用 <code>forward</code> 来进行转发的话（类似于 <code>forward&lt;decltype(x)&gt;(x)</code>），那转发引用的使用通常是合适的。</p><h2>模板的二进制膨胀</h2><p>模板在带来方便和性能的同时，也可能使代码产生膨胀，这是一个需要权衡的问题。我们上一讲讲到的视图类型，实际上既可能消减二进制代码，也可能增加二进制代码。</p><p>对于像 <code>span</code> 这样的类型，它明显可以消减二进制代码。如果我们的 <code>print</code> 函数的定义改成：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nvoid print(const T&amp; rng)\n{\n  for (const auto&amp; n : rng) {\n    cout &lt;&lt; n &lt;&lt; ' ';\n  }\n  cout &lt;&lt; '\\n';\n}\n</code></pre><p>那它显然可以工作，而且还非常灵活。但是，现在当我们传递 <code>vector&lt;int&gt;</code>、<code>array&lt;int, 5&gt;</code>、<code>array&lt;int, 8&gt;</code>、<code>int[5]</code>、<code>int[8]</code> 时，那就是五种不同的特化了。如果由于任何原因 <code>print</code> 不能内联的话，我们就会生成约五倍数量的二进制代码。</p><p>而像 <code>elements_view</code> 这样的类型就反过来潜在可能会增加二进制代码。相信你目前已经能理解这个问题，我就不展开了。不过，相对其他一些不使用视图类型的方案，它在易用性和性能方面的提升，很可能大大超过了潜在的二进制膨胀的危害。</p><h3>通过退化消减二进制膨胀</h3><p>某些二进制膨胀问题不太好解决，有一些则是很容易解决的。在像传递 <code>char[8]</code>、<code>int[5]</code> 这样的参数的场景，使用指针或者 <code>span</code>（即指针加长度）往往是一种很好的替换方案。下面，我们再来看一个很具体的例子，如何高效地实现一个通用的日志函数的传参。</p><p>为了高效地传递大对象，日志函数的对外接口可能长下面这个样子：</p><pre><code class=\"language-cpp\">template &lt;typename... Args&gt;\nvoid log(log_level,\n         const Args&amp;... args);\n</code></pre><p>这里，我们用 const 左值引用传参，规避了前面说的不同引用类型的参数会带来的额外特化。但这里我们还会遇到一个常见问题：字面量 <code>\"hello\"</code> 和 <code>\"world\"</code> 被视作同一类型——<code>const char[6]</code>——但它们和 <code>\"hi\"</code>——<code>const char[3]</code>——就不是同一类型了。这时候，我们需要非引用方式传参时候的退化行为，把 <code>const char</code> 数组当作 <code>const char*</code> 处理。</p><p>我们可以简单地把目前的这个 <code>log</code> 函数模板重命名为 <code>log_impl</code>，而新增一个简单转发的 <code>log</code> 函数模板：</p><pre><code class=\"language-cpp\">template &lt;typename... Args&gt;\nvoid log(log_level level,\n         const Args&amp;... args)\n{\n  log_impl(level,\n           try_decay(args)...);\n}\n</code></pre><p>这个函数够简单，一般可以内联。即使不能内联，它会带来的额外膨胀也非常小。所以，我们只需要专心实现 <code>try_decay</code> 就行了。</p><p>这里，我们就有一定的自由度来选择到底该怎么做了。我目前的策略是这样的：</p><ul>\n<li>对于可以退化为 <code>const char*</code> 的类型，强制类型转换成 <code>const char*</code></li>\n<li>对于其他数组类型，将其转变为 <code>span</code></li>\n<li>其他情况直接完美转发</li>\n</ul><p>代码如下：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nconstexpr decltype(auto)\ntry_decay(T&amp;&amp; value)\n{\n  using decayed_type = decay_t&lt;T&gt;;\n  using remove_ref_type =\n    remove_reference_t&lt;T&gt;;\n  if constexpr (\n    is_same_v&lt;decayed_type,\n              const char*&gt;) {\n    return decayed_type(value);\n  } else if constexpr (\n    is_array_v&lt;remove_ref_type&gt;) {\n    return span&lt;remove_extent_t&lt;\n      remove_ref_type&gt;&gt;(value);\n  } else {\n    return forward&lt;T&gt;(value);\n  }\n}\n</code></pre><p>需要注意一下，使用转发引用的函数都潜在存在此类问题。所以，在 C++11 开始的新时代里，也并不是使用 <code>emplace_back</code> 一定比 <code>push_back</code> 更好，即使你正确使用、没有犯低级错误 <span class=\"orange\">[2]</span>。</p><h3>通过公共基类消减二进制膨胀</h3><p>除了参数类型，还有一种常见的优化类模板方法的办法，就是抽取公共基类。</p><p>类模板里通常有很多方法，一般总有些是跟模板参数相关的。但是，也常常可能存在一些方法，跟模板参数没有任何关系，或者很容易就能改造成没有关系。这类方法也是模板二进制膨胀的来源之一。</p><p>想象一下，类模板 <code>Obj&lt;T&gt;</code> 里有方法 <code>CommonMethod()</code>。当我们用不同的类型，如 <code>int</code> 和 <code>char</code>，去实例化的时候，我们就可能会编译产生方法 <code>Obj&lt;int&gt;::CommonMethod()</code> 和 <code>Obj&lt;char&gt;::CommonMethod()</code>。这是两个无关的成员函数，因此编译器一般不会为你进行优化。在你每次实例化时，编译器都会在需要用到 <code>CommonMethod</code> 时提供一份新的代码，而不会看到不同的 <code>CommonMethod</code> 实际是一样的。我们需要显式地告诉编译器，不同的 <code>CommonMethod</code> 实际上是同一份。一种通行的做法，就是把这样的方法放到一个公用的非模板基类里去。如下所示：</p><pre><code class=\"language-cpp\">class ObjBase {\npublic:\n  void CommonMethod();\n};\n\ntemplate &lt;typename T&gt;\nclass Obj : private ObjBase {\npublic:\n  // 如果 CommonMethod 是一个 Obj\n  // 需要暴露的方法\n  using ObjBase::CommonMethod;\n  …\n};\n</code></pre><p><code>Obj</code> 私有继承 <code>ObjBase</code>，这是一种实现继承关系。我们让 <code>Obj</code> 可以使用 <code>ObjBase</code> 的数据成员和方法，但不允许别人通过一个 <code>ObjBase</code> 的引用或指针来访问 <code>Obj</code>。如果 <code>CommonMethod</code> 原来是一个私有方法，那 <code>Obj</code> 现在直接使用就可以了；如果 <code>CommonMethod</code> 原来是一个公开或保护方法，那我们需要在合适的位置使用 <code>using</code> 来确保它能被调用者或子类使用。</p><p>某些标准库实现里的模板类就会使用这种方法来进行优化。</p><h2>内容小结</h2><p>本讲我讨论了两个相关问题：如何传递参数，如何减少模板的二进制膨胀。使用合适的引用方式，并合理使用退化，可以让我们产出既灵活又小巧的代码。</p><h2>课后思考</h2><p>如果一个函数的调用者应该持有一个 <code>unique_ptr</code>，函数的参数应该怎么写？</p><p>为什么目前的 <code>try_decay</code> 里面需要使用 <code>remove_reference_t</code>？两个用到的地方如果直接使用 <code>T</code> 会发生什么后果？</p><p>期待你的思考，如有任何疑问，我们留言区见！</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Arthur O’Dwyer, “‘Universal reference’ or ‘forward reference’?”. <a href=\"https://quuxplusone.github.io/blog/2022/02/02/look-what-they-need/\">https://quuxplusone.github.io/blog/2022/02/02/look-what-they-need/</a></span></p><p><span class=\"reference\">[2] Arthur O’Dwyer, “Don’t blindly prefer <code>emplace_back</code> to <code>push_back</code>”. <a href=\"https://quuxplusone.github.io/blog/2021/03/03/push-back-emplace-back/\">https://quuxplusone.github.io/blog/2021/03/03/push-back-emplace-back/</a></span></p>","neighbors":{"left":{"article_title":"36｜访问对象的代理对象：视图类型","id":513719},"right":{"article_title":"38 | 折叠表达式：高效的编译期展开","id":523170}}},{"article_id":523170,"article_title":"38 | 折叠表达式：高效的编译期展开","article_content":"<p>你好，我是吴咏炜。</p><p>当我在写<a href=\"https://time.geekbang.org/column/article/185899\">第 18 讲</a>“应用可变模板和 tuple 的编译期技巧”时，有朋友就建议可以讨论一下折叠表达式 <span class=\"orange\">[1]</span>。不过，在那时候我对折叠表达式并没有什么实际应用经验，觉得它用处不大，于是就略过了。幸好我只是没有写，而没有乱加评论，否则就图欧图森破（too old, too simple）了。很多功能，只有在你真正需要到它、又掌握如何使用的时候，你才会觉得真正有用。很多 C++ 里看似用处不大的特性，都是这种情况（当然也不是所有，否则就不会有对特性的废弃和删除了）。</p><p>跟之前一样，我们还是通过具体的例子来看一下折叠表达式的作用和表达能力。</p><h2>基本用法</h2><h3>一元折叠</h3><p>在<a href=\"https://time.geekbang.org/column/article/185899\">第 18 讲</a>我举过这样一个编译期递归的例子：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nconstexpr auto sum(T x)\n{\n  return x;\n}\n\ntemplate &lt;typename T1, typename T2,\n          typename... Targ&gt;\nconstexpr auto sum(T1 x, T2 y,\n                   Targ... args)\n{\n  return sum(x + y, args...);\n}\n</code></pre><p>而使用折叠表达式的话，我们可以把代码简化成下面这个样子：</p><pre><code class=\"language-cpp\">template &lt;typename... Args&gt;\nconstexpr auto sum(Args... args)\n{\n  return (... + args);\n}\n</code></pre><!-- [[[read_end]]] --><p>你应该可以看到，这个改进有多大了吧？</p><p>虽然猜这个代码是什么意思不难，但要精确理解这样的代码的语义，以及自己写出正确的折叠表达式，我们还是需要讲一点点语法。</p><p>首先，折叠表达式应用在可变模板的情况下，所以，我们需要有 <code>typename... Args</code> 这样的模板参数，及 <code>Args... args</code>、<code>const Args&amp;... args</code>、<code>Args&amp;&amp;... args</code> 之类的函数参数包 <span class=\"orange\">[2]</span>。</p><p>其次，我们在折叠表达式里使用参数包有一种特殊的形式。我们一定会用到圆括号（漏括号是初学时的常见错误）、参数包名称、运算符和 <code>...</code>。上面的代码用的是“一元左折叠”，形式是“<code>(... 运算符 参数包名称)</code>”。</p><p>最后，我们看一下折叠表达式是如何展开的。如果参数包只有一项（<code>args0</code>），那结果就是这个参数自身（<code>args0</code>）；如果参数包有两项（<code>args0, args1</code>），那结果就是这两项用运算符拼接起来（<code>args0 + args1</code>）；如果参数包有三项（<code>args0, args1, args2</code>），那结果就是这三项用运算符拼接起来（<code>args0 + args1 + args2</code>）；以此类推。</p><p>如果你初步理解了，那我得声明一下，我上面做了简化。对于超过两项的折叠表达式展开，我们有时候需要关注一下运算符的结合问题，即我们需要的是 <code>(args0 + args1) + args2</code>，还是 <code>args0 + (args1 + args2)</code>。显而易见，对于加法，以及其他满足结合律的运算符，这两者的区别并不重要。但是，即使对于加法，实际上这两种顺序都不是完全没有区别的（如浮点数），而对于减法、除法之类的运算，那就更不用说了。所以，我们需要区分一元左折叠和一元右折叠两种不同的方式，它们分别对应于 <code>(args0 + args1) + args2</code> 和 <code>args0 + (args1 + args2)</code>。写折叠表达式时的区别是，一元左折叠的 <code>...</code> 在左边，而一元右折叠的 <code>...</code> 在右边：<code>(... + args)</code> 和 <code>(args + ...)</code>。</p><p>下面用符号描述一下。令 $E$ 代表参数包，$N$ 代表参数包里的参数数量，则：</p><ul>\n<li>一元左折叠是 $(\\ldots\\ \\mathrm{op}\\ E)$，展开后成为 $(((E_1\\ \\mathrm{op}\\ E_2) \\ \\mathrm{op}\\ \\ldots)\\ \\mathrm{op}\\ E_N)$</li>\n<li>一元右折叠是 $(E \\ \\mathrm{op}\\ \\ldots)$，展开后成为$(E_1\\ \\mathrm{op}\\ (\\ldots\\ \\mathrm{op}\\ (E_{N-1}\\ \\mathrm{op}\\ E_N)))$</li>\n</ul><h3>与和或的折叠</h3><p>在大部分折叠表达式的展开过程中，参数包为空是一个错误。不过，为了方便实际使用的场景，C++ 对于使用 <code>&amp;&amp;</code> 和 <code>||</code> 的折叠表达式有特殊处理，允许参数包为空。这种情况下，<code>&amp;&amp;</code> 得到 <code>true</code>，<code>||</code> 得到 <code>false</code>——也就是说，相当于折叠表达式默认填充了一项不影响正常运算结果的数据：<code>true &amp;&amp; args0 &amp;&amp; ...</code> 和 <code>false || args0 || ...</code>。</p><p>C++ 里的“与”和“或”有短路求值行为 <span class=\"orange\">[3]</span>。当你写下 <code>a &amp;&amp; b</code> 时，如果 <code>a</code> 算出的结果是 <code>false</code>，编译器就不会对 <code>b</code> 进行求值，因为求值没有意义，不会影响结果。这是一个明确定义了的行为。类似地，如果 <code>a || b</code> 里 <code>a</code> 的结果是 <code>true</code>，编译器也不会对 <code>b</code> 进行求值。</p><p>如果我们看 <code>a &amp;&amp; b &amp;&amp; c</code> 这样的表达式的话，我们会发现情况也完全一样。按照运算符的结合规则，上面的表达式等同于 <code>(a &amp;&amp; b) &amp;&amp; c</code>；如果 <code>a</code> 结果为 <code>false</code>，无需对 <code>b</code> 求值就得到 <code>a &amp;&amp; b</code> 为 <code>false</code>，所以 <code>c</code> 也无需求值即得到最终结果 <code>false</code>。如果 <code>a</code> 为 <code>true</code>，编译器才会对 <code>b</code> 求值，并在结果为 <code>true</code> 时才对 <code>c</code> 求值……</p><p>再进一步，对于 <code>a &amp;&amp; (b &amp;&amp; c)</code> 进行分析，我们会发现，求值的顺序和结果仍将完全相同：</p><ul>\n<li>若 <code>a</code> 求值为 <code>false</code>，则 <code>b &amp;&amp; c</code> 不求值，结果为 <code>false</code></li>\n<li>若 <code>a</code> 求值为 <code>true</code>，然后 <code>b</code> 求值为 <code>false</code>，则 <code>c</code> 不求值，结果为 <code>false</code></li>\n<li>若 <code>a</code> 求值为 <code>true</code>，然后 <code>b</code> 求值为 <code>true</code>，则结果为 <code>c</code> 求值的结果</li>\n</ul><p>这样的分析对于 <code>||</code> 也同样适用。因此，一元左折叠和右折叠的等价性不仅对于普通满足结合律的运算符是成立的，而且对于有短路规则的运算符也同样是成立的。</p><h3>逗号的折叠</h3><p>很多人可能没注意到，逗号“<code>,</code>”也是一个运算符 <span class=\"orange\">[4]</span>，表达式 <code>a, b</code> 的意思是（当然，不是在能被当作函数参数的地方；如果可能被编译器误解，多加一重括号就行），对 <code>a</code> 和 <code>b</code> 依次进行求值，返回后一个表达式 <code>b</code> 的结果。在使用逗号的折叠表达式里，参数包也允许为空，此时表达式的结果相当于 <code>void()</code>，即没有数值。</p><p>我们后面会展示逗号折叠表达式的用法。</p><h3>二元折叠</h3><p>在参数包里提供了运算所需的所有参数时，一元折叠表达式就很好了。但还有很大的一类展开场景，我们没法用一元折叠表达式，因为我们需要在函数里提供某个参数。一种典型的情况就是，我们需要把一堆参数输出到某个流里：</p><pre><code class=\"language-cpp\">cout &lt;&lt; args0 &lt;&lt; args1 &lt;&lt; ... &lt;&lt; argsN;\n</code></pre><p>这里我们就需要用到所谓的“二元左折叠”了。如果待输出的参数组成了我们的参数包 <code>args</code>，我们用下面的代码就能输出：</p><pre><code class=\"language-cpp\">(cout &lt;&lt; ... &lt;&lt; args);\n</code></pre><p>类似地，我们有“二元右折叠”，道理相同，我就不展开了。</p><p>二元折叠相当于提供了一个“初值”，所以参数包允许为空。对于空参数包，<code>(... + args)</code> 是不合法代码，而 <code>(0 + ... + args)</code> 就是合法的了。</p><p>下面用符号描述一下。令 $E$ 代表参数包，$N$ 代表参数包里的参数数量，$I$ 代表“初值参数”，则：</p><ul>\n<li>二元左折叠是 $(I\\ \\mathrm{op}\\ \\ldots\\ \\mathrm{op}\\ E)$，展开后成为 $((((I\\ \\mathrm{op}\\ E_1)\\ \\mathrm{op}\\ E_2) \\ \\mathrm{op}\\ \\ldots)\\ \\mathrm{op}\\ E_N)$</li>\n<li>二元右折叠是 $(E \\ \\mathrm{op}\\ \\ldots\\ \\mathrm{op}\\ I)$，展开后成为$(E_1\\ \\mathrm{op}\\ (\\ldots\\ \\mathrm{op}\\ (E_{N-1}\\ \\mathrm{op}\\ (E_N\\ \\mathrm{op}\\ I))))$</li>\n</ul><h2>折叠表达式的应用场景</h2><p>在对折叠表达式有了一些初步的了解之后，我们来看一下实际应用折叠表达式的一些场景。</p><h3>空指针检查</h3><p>作为一种编译期展开的功能，折叠表达式能够达到跟手写展开完全相同的效果，但表达上要精炼得多。比如，我们有代码需要检查给定的指针（有可能有智能指针）是否有为空的情况，我们就可以写：</p><pre><code class=\"language-cpp\">if (ptr1 == nullptr ||\n    ptr2 == nullptr ||\n    …\n    ptrN == nullptr) {\n  // 记录日志，出错返回，等等\n}\n</code></pre><p>这当然不算糟糕，但下面这样的写法是不是好上一点点？</p><pre><code class=\"language-cpp\">if (is_any_null(ptr1, ptr2, …, ptrN)) {\n  // 记录日志，出错返回，等等\n}\n</code></pre><p>而 <code>is_any_null</code> 的实现非常简单：</p><pre><code class=\"language-cpp\">template &lt;typename... Args&gt;\nconstexpr bool\nis_any_null(const Args&amp;... args)\n{\n  return (... || (args == nullptr));\n}\n</code></pre><h3>返回值检查</h3><p>比上面这种更复杂一点的，是调用多个函数，检查返回值，并在返回值表示不成功时终止代码执行。示意代码如下：</p><pre><code class=\"language-cpp\">error_t result{};\nresult = check1(…);\nif (result != error_t::ok) {\n  return result;\n}\nresult = check2(…);\nif (result != error_t::ok) {\n  return result;\n}\nresult = check3(…);\nif (result != error_t::ok) {\n  return result;\n}\nresult = check4(…);\nif (result != error_t::ok) {\n  return result;\n}\nreturn error_t::ok;\n</code></pre><p>利用折叠表达式，我们也可以这样简化代码：</p><pre><code class=\"language-cpp\">return checked_exec(\n  error_t::ok,\n  [&amp;] { return check1(…); },\n  [&amp;] { return check2(…); },\n  [&amp;] { return check3(…); },\n  [&amp;] { return check4(…); });\n</code></pre><p>当然，我们需要提供 <code>checked_exec</code> 的定义：</p><pre><code class=\"language-cpp\">template &lt;typename R,\n          typename... Fn&gt;\nR checked_exec(const R&amp; expected,\n               Fn&amp;&amp;... fn)\n{\n  R result = expected;\n  (void)(((result = forward&lt;Fn&gt;(\n             fn)()) == expected) &amp;&amp;\n         ...);\n  return result;\n}\n</code></pre><p>在参数展开和内联后，我们上面对 <code>checked_exec</code> 的调用就大致相当于下面的代码：</p><pre><code class=\"language-cpp\">error_t result = error_t::ok;\n(void)(((result = check1(…)) == error_t::ok) &amp;&amp;\n       (((result = check2(…)) == error_t::ok) &amp;&amp;\n        (((result = check3(…)) == error_t::ok) &amp;&amp;\n         ((result = check4(…)) == error_t::ok))));\nreturn result;\n</code></pre><p>这里我严格按一元右折叠的形式进行了展开，但就如上面讨论过的，这里左折叠和右折叠是等价的。此时，去掉一些括号，代码会更加清晰：</p><pre><code class=\"language-cpp\">(void)((result = check1(…)) == error_t::ok &amp;&amp;\n       (result = check2(…)) == error_t::ok &amp;&amp;\n       (result = check3(…)) == error_t::ok &amp;&amp;\n       (result = check4(…)) == error_t::ok);\n</code></pre><p>所以，我们看到了，利用折叠表达式和短路规则，我们可以实现 <code>checked_exec</code> 或类似的函数，来简化一些重复的检查，让代码更加清晰，并避免低级错误。</p><h3>编译期遍历</h3><p>利用逗号折叠表达式，我们可以实现一些编译期的遍历操作。最基本的，当然就是直接遍历所有的参数了。利用这种方式，我们可以来实现带分隔符的打印操作：</p><pre><code class=\"language-cpp\">template &lt;typename T,\n          typename First,\n          typename... Rest&gt;\nvoid print_with_separator(\n  const T&amp; sep,\n  const First&amp; first,\n  const Rest&amp;... rest)\n{\n  cout &lt;&lt; first;\n  ((cout &lt;&lt; sep &lt;&lt; rest), ...);\n  cout &lt;&lt; endl;\n}\n</code></pre><p>这个代码很简单，可以内联，因此我也没有必要像<a href=\"https://time.geekbang.org/column/article/517514\">第 37 讲</a>里描述的那样进一步进行传参优化了。这里的编译期展开就利用了逗号折叠表达式。比如，当我们以 <code>print_with_separator(\", \", \"one\", \"two\", \"three\")</code> 来调用时，函数体展开成大致这个样子（去掉了不必要的括号）：</p><pre><code class=\"language-cpp\">cout &lt;&lt; \"one\";\n((cout &lt;&lt; \", \" &lt;&lt; \"two\"),\n (cout &lt;&lt; \", \" &lt;&lt; \"three\"));\ncout &lt;&lt; endl;\n</code></pre><p>逗号前的那个表达式就成了我们希望在参数包 <code>args</code> 上反复执行的内容。</p><p>使用类似的方式，我们可以打印一个 <code>tuple</code>。这时，代码就稍微复杂一些了：我们需要根据需要遍历的项数预先生成编译期的整数序列，也就是<a href=\"https://time.geekbang.org/column/article/185899\">第 18 讲</a>讨论过的 <code>make_index_sequence</code>，然后利用折叠表达式来逐项遍历。</p><p>不过呢，我们这次会使用标准库里的一个对 <code>make_index_sequence</code> 的小小封装 <span class=\"orange\">[5]</span>：</p><pre><code class=\"language-cpp\">template &lt;class... T&gt;\nusing index_sequence_for =\n  make_index_sequence&lt;sizeof...(T)&gt;;\n</code></pre><p>这个类模板会根据模板参数的项数来生成一个合适的序列。比如，如果传给 <code>index_sequence_for</code> 的模板参数有三项的话，那结果类型就会是 <code>index_sequence&lt;0, 1, 2&gt;</code>。</p><p>然后，<code>print_tuple</code> 就可以这样实现：</p><pre><code class=\"language-cpp\">template &lt;typename Tup,\n          size_t... Is&gt;\nvoid output_tuple_members(\n  ostream&amp; os,\n  const Tup&amp; tup,\n  index_sequence&lt;Is...&gt;)\n{\n  ((os &lt;&lt; (Is != 0 ? \", \" : \"\")\n       &lt;&lt; get&lt;Is&gt;(tup)),\n   ...);\n}\n\ntemplate &lt;typename... Args&gt;\nvoid print_tuple(const tuple&lt;Args...&gt;&amp; args)\n{\n  cout &lt;&lt; '(';\n  output_tuple_members(\n    cout, args,\n    index_sequence_for&lt;Args...&gt;{});\n  cout &lt;&lt; ')';\n}\n</code></pre><p>对于一个三项的 <code>tuple</code>，最后展开出来的代码就差不多是这个样子：</p><pre><code class=\"language-cpp\">cout &lt;&lt; '(';\n((cout &lt;&lt; (0 != 0 ? \", \" : \"\")\n       &lt;&lt; get&lt;0&gt;(args)),\n (cout &lt;&lt; (1 != 0 ? \", \" : \"\")\n       &lt;&lt; get&lt;1&gt;(args)),\n (cout &lt;&lt; (2 != 0 ? \", \" : \"\")\n       &lt;&lt; get&lt;2&gt;(args)));\ncout &lt;&lt; ')';\n</code></pre><p>显然，它确实能够完成我们需要的打印任务。如果我们传它一个 <code>make_tuple(1, \"two\", 3.14159)</code>，打印结果就会是：</p><blockquote>\n<p><code>(1, two, 3.14159)</code></p>\n</blockquote><h2>内容小结</h2><p>本讲我讨论了 C++17 提供的折叠表达式，并通过提供具体的例子，向你展示了如何使用这一特性来进行编译期展开，从而简化重复的代码。</p><h2>课后思考</h2><p>尝试一下不用折叠表达式去实现 <code>checked_exec</code>（或其他使用了折叠表达式的函数模板），体会一下折叠表达式带来的简化。</p><p>期待你的动手实践，有任何疑问我们留言区见！</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “fold expression”. <a href=\"https://en.cppreference.com/w/cpp/language/fold\">https://en.cppreference.com/w/cpp/language/fold</a></span></p><p><span class=\"reference\">[1a] cppreference.com, “折叠表达式”. <a href=\"https://zh.cppreference.com/w/cpp/language/fold\">https://zh.cppreference.com/w/cpp/language/fold</a></span></p><p><span class=\"reference\">[2] cppreference.com, “Parameter pack”. <a href=\"https://en.cppreference.com/w/cpp/language/parameter_pack\">https://en.cppreference.com/w/cpp/language/parameter_pack</a></span></p><p><span class=\"reference\">[2a] cppreference.com, “形参包”. <a href=\"https://zh.cppreference.com/w/cpp/language/parameter_pack\">https://zh.cppreference.com/w/cpp/language/parameter_pack</a></span></p><p><span class=\"reference\">[3] cppreference.com, “Logical operators”. <a href=\"https://en.cppreference.com/w/cpp/language/operator_logical\">https://en.cppreference.com/w/cpp/language/operator_logical</a></span></p><p><span class=\"reference\">[3a] cppreference.com, “逻辑运算符”. <a href=\"https://zh.cppreference.com/w/cpp/language/operator_logical\">https://zh.cppreference.com/w/cpp/language/operator_logical</a></span></p><p><span class=\"reference\">[4] cppreference.com, “Other operators”. <a href=\"https://en.cppreference.com/w/cpp/language/operator_other\">https://en.cppreference.com/w/cpp/language/operator_other</a></span></p><p><span class=\"reference\">[4a] cppreference.com, “其他运算符”. <a href=\"https://zh.cppreference.com/w/cpp/language/operator_other\">https://zh.cppreference.com/w/cpp/language/operator_other</a></span></p><p><span class=\"reference\">[5] cppreference.com, “std::integer_sequence”. <a href=\"https://en.cppreference.com/w/cpp/utility/integer_sequence\">https://en.cppreference.com/w/cpp/utility/integer_sequence</a></span></p><p><span class=\"reference\">[5a] cppreference.com, “std::integer_sequence”. <a href=\"https://zh.cppreference.com/w/cpp/utility/integer_sequence\">https://zh.cppreference.com/w/cpp/utility/integer_sequence</a></span></p>","neighbors":{"left":{"article_title":"37｜参数传递的正确方法和模板的二进制膨胀","id":517514},"right":{"article_title":"39 | 如何在编译期玩转字符串？","id":527423}}},{"article_id":527423,"article_title":"39 | 如何在编译期玩转字符串？","article_content":"<p>你好，我是吴咏炜。</p><p>在实际的项目里，我遇到过不少在编译期处理字符串的需求。今天，我们就来把这个问题好好讨论一下。</p><h2>对象的选择</h2><p>在编译期处理字符串，你是不能使用 <code>std::string</code> 的。原因有以下几个方面：</p><ul>\n<li>在 C++20 之前你完全无法在编译期使用 <code>string</code>。而且，对于编译期 <code>string</code> 的支持来得比较晚，只有 MSVC 较早支持，GCC 需要刚出炉不久的 GCC 12，Clang 需要当前（2022 年 6 月）尚未正式发布的 LLVM 15。</li>\n<li>到了 C++20，你虽然可以在编译期使用 <code>string</code>，但实际上仍有很多不方便的地方。最明显的，编译期生成的字符串不能在运行期使用。并且，<code>string</code> <strong>不可以</strong>声明为 constexpr。</li>\n<li><code>string</code> 不能用作模板参数。</li>\n</ul><p>因此我们只能放弃这个看起来最方便的方式，另外探索一条新路。我们的基本操作对象可以是下面这几样：</p><ul>\n<li>常字符指针，这是字符串字面量会自然退化成的东西</li>\n<li><code>string_view</code>，C++17 里新增的有力工具，方法和 <code>string</code> 类似，且基本都是 constexpr</li>\n<li><code>array</code>，使用它我们才可以返回全新的字符串</li>\n</ul><p>我们的编译期字符串处理，也因此会围绕着这几种类型来进行讨论。</p><h2>常见操作</h2><h3>获取字符串长度</h3><p>一个最最基本的操作，显然就是获取字符串的长度。这里，我们不能使用 C 的 <code>strlen</code> 函数，因为这个函数不是 constexpr。</p><!-- [[[read_end]]] --><p>对于这个操作，我们尝试一下几种不同的实现方式。</p><p>首先，我们可以自己实现 <code>strlen</code> 的功能，并把代码写成 constexpr 函数：</p><pre><code class=\"language-cpp\">namespace strtools {\n\nconstexpr size_t\nlength(const char* str)\n{\n  size_t count = 0;\n  while (*str != '\\0') {\n    ++str;\n    ++count;\n  }\n  return count;\n}\n\n} // namespace strtools\n</code></pre><p>不过，标准库里是不是有现成的编译期获取字符串长度的机制呢？答案是，有。不仅有，还能支持 <code>char</code>、<code>wchar_t</code> 等多种不同字符类型的情况。以 Unix 下最常用的 <code>char</code> 为例，使用跟上面相同的接口，我们可以写出：</p><pre><code class=\"language-cpp\">constexpr size_t\nlength(const char* str)\n{\n  return char_traits&lt;char&gt;::length(\n    str);\n}\n</code></pre><p>从 C++17 开始，这就是合法的可以在编译期计算字符串长度的代码了。（不过，一些较老的编译器上，使用 <code>char_traits</code> 会有一些问题，如 GCC 8 或更老的版本。）</p><p>既然用了 C++17，我们当然也可以试一下 <code>string_view</code> 了：</p><pre><code class=\"language-cpp\">constexpr size_t\nlength(string_view sv)\n{\n  return sv.size();\n}\n</code></pre><p>不管使用上面哪一种写法，现在你可以用下面的代码来验证我们确实可以在编译的时候验证字符串的长度：</p><pre><code class=\"language-cpp\">static_assert(strtools::length(\"Hi\") == 2);\n</code></pre><p>目前看起来，应该是 <code>string_view</code> 实现最方便了。</p><h3>查找字符</h3><p>查找指定的字符也是一个常用功能。我们不能使用 <code>strchr</code>，但一样，我们有几种不同的实现方式可供选择。使用 <code>char_traits</code> 或 <code>string_view</code> 的代码都非常简单。</p><p>这是使用 <code>char_traits</code> 的版本：</p><pre><code class=\"language-cpp\">constexpr const char*\nfind(const char* str, char ch)\n{\n  return char_traits&lt;char&gt;::find(\n    str, length(str), ch);\n}\n</code></pre><p>这是使用 <code>string_view</code> 的版本：</p><pre><code class=\"language-cpp\">constexpr string_view::size_type\nfind(string_view sv, char ch)\n{\n  return sv.find(ch);\n}\n</code></pre><p>这次我就不展示手工的查找代码了。（除非你非得用老的编译器，否则简单为好。）</p><h3>字符串比较</h3><p>下一个是字符串比较。这个 <code>string_view</code> 完全不需要动手就赢了：<code>string_view</code> 可以直接进行各种标准的比较，不需要写任何的代码。</p><h3>截取子串</h3><p>看起来使用 <code>string_view</code> 很方便，我们应当尽量使用 <code>string_view</code>，可以少写代码。不过，截取子串这个操作，<code>string_view::substr</code> 够不够用呢？</p><p>这个问题，没有实际的使用场景是比较难回答的。我在项目中遇到过的一个实际场景是，<code>__FILE__</code> 宏可能会携带编译时的完整路径，导致在不同路径下编译会产生不同的二进制输出。而比较理想的解决方式是，通过编译期编程来消除某个前缀或者截取路径的最后部分，让编译的绝对路径不会泄漏出来。</p><p>实测结果，<code>string_view::substr</code> 难当此任。对于下面的代码：</p><pre><code class=\"language-cpp\">puts(\"/usr/local\"sv.substr(5)\n       .data());\n</code></pre><p>我们在编译器的汇编输出里会看到这样的代码（参见 <a href=\"https://godbolt.org/z/1dssd96vz\">https://godbolt.org/z/1dssd96vz</a>）：</p><pre><code class=\"language-assembly\">.LC0:\n        .string \"/usr/local\"\n        …\n        mov     edi, OFFSET FLAT:.LC0+5\n        call    puts\n</code></pre><p>我们得另外想办法……</p><p>下面我们来试试 <code>array</code>。很容易会想到类似下面这样的代码：</p><pre><code class=\"language-cpp\">constexpr auto\nsubstr(string_view sv,\n       size_t offset, size_t count)\n{\n  array&lt;char, count + 1&gt; result{};\n  copy_n(&amp;sv[offset], count,\n         result.data());\n  return result;\n}\n</code></pre><p>代码的意图应该很容易读懂：根据要求的大小生成一个全新的字符数组并清零（C++20 之前不允许 constexpr 变量不立即初始化）；拷贝所需的内容；然后返回。可惜，这个代码没法通过编译……</p><p>它里面有好几个问题：</p><ul>\n<li>函数参数不是编译期常量，不能用在模板参数里</li>\n<li><code>copy_n</code> 在 C++20 之前不是 constexpr，不能用于编译期编程</li>\n</ul><p>第二个问题好解决，手写个循环就行。我们重点来看一下第一个问题。</p><p>一个 constexpr 函数可以在编译期求值，也可以在运行期求值，所以函数的参数全部不被视作编译期常量，不能用到模板参数等要求编译期常量的地方。</p><p>更进一步，这个问题到了 C++20 的 consteval 函数，仍然没有解决。其主要原因是，如果我们允许函数的参数当作编译期常量来用的话，那我们就能写出一个函数，它的入参的不同的<strong>值</strong>（相同类型），能够产生不同<strong>类型</strong>的返回值。例如（当前为不合法代码）：</p><pre><code class=\"language-cpp\">consteval auto make_constant(int n)\n{\n  return integral_constant&lt;int, n&gt;{};\n}\n</code></pre><p>这在目前的类型系统里是无法接受的，我们仍需确保函数的返回值有唯一类型。要想在函数里用作模板参数的值，就必须以模板参数的形式来传递给函数模板（而不是作为非模板函数的普通参数）——这种情况下，每一个不同的模板参数就意味着一个不同的模板特化，不是同一个函数，这样就没有上面这个函数返回值类型不唯一这个问题。</p><p>顺便说一句，有一个标准提案 P1045 试图解决这个问题 <span class=\"orange\">[1]</span>，但后来迟迟没有进展。由于存在一些绕过的方案（下面会讨论），目前我们仍能实现需要的效果。</p><p>回到 <code>substr</code> 函数，我们需要把长度变成模板参数。下面是修改的结果：</p><pre><code class=\"language-cpp\">template &lt;size_t Count&gt;\nconstexpr auto\nsubstr(string_view sv,\n       size_t offset = 0)\n{\n  array&lt;char, Count + 1&gt; result{};\n  for (size_t i = 0; i &lt; Count;\n       ++i) {\n    result[i] = sv[offset + i];\n  }\n  return result;\n}\n</code></pre><p>这回，代码确实可以工作了。对于 <code>puts(substr&lt;5&gt;(\"/usr/local\", 5).data());</code>，现在编译器生成的结果里不再有 <code>\"/usr/\"</code> 了。</p><hr><p>不过，很遗憾，这回我们见到了抽象对编译器的挑战：在当前 Godbolt 上最新版本的 GCC（12.1）和 MSVC（19.32）下，这个版本的 <code>substr</code> 没有生成最优的输出，我在老版本的编译器上也多多少少遇到了一些兼容性问题。因此，纯粹从实际的角度，我推荐下面这个不使用 <code>string_view</code> 的版本：</p><pre><code class=\"language-cpp\">template &lt;size_t Count&gt;\nconstexpr auto\nsubstr(const char* str,\n       size_t offset = 0)\n{\n  array&lt;char, Count + 1&gt; result{};\n  for (size_t i = 0; i &lt; Count;\n       ++i) {\n    result[i] = str[offset + i];\n  }\n  return result;\n}\n</code></pre><p>如果有兴趣的话，你可以自行比较一下这两个不同版本代码生成的汇编：</p><ul>\n<li><a href=\"https://godbolt.org/z/zT8s1aEYo\">https://godbolt.org/z/zT8s1aEYo</a></li>\n<li><a href=\"https://godbolt.org/z/qGPevxP98\">https://godbolt.org/z/qGPevxP98</a></li>\n</ul><p>只有 Clang 对于这两个版本生成了完全相同的高效汇编代码：</p><pre><code class=\"language-assembly\">        mov     word ptr [rsp + 4], 108\n        mov     dword ptr [rsp], 1633906540\n        mov     rdi, rsp\n        call    puts\n</code></pre><p>如果你不明白为什么有 108 和 1633906540 这两个数字的话，提醒你一下，这两个数字的十六进制表示分别是 0x6C 和 0x61636F6C。查一下 ASCII 表你就应该可以明白了。</p><hr><p>既然我们在接口里不用 <code>string_view</code>，参数里的 <code>offset</code> 就变得很鸡肋了。因此，下面我们不再使用 <code>offset</code> 这个参数，并把函数名更改为 <code>copy_str</code>：</p><pre><code class=\"language-cpp\">template &lt;size_t Count&gt;\nconstexpr auto\ncopy_str(const char* str)\n{\n  array&lt;char, Count + 1&gt; result{};\n  for (size_t i = 0; i &lt; Count;\n       ++i) {\n    result[i] = str[i];\n  }\n  return result;\n}\n</code></pre><h2>编译期传参问题</h2><p>不过，当你想把上面这些编译期函数组合起来的话，你会发现仍然缺了点什么。比如，如果你想把 <code>\"/usr/local\"</code> 这样的路径<strong>自动</strong>去掉第一段，得到 <code>\"local\"</code>，你可能会试图写出下面这样的代码：</p><pre><code class=\"language-cpp\">constexpr auto\nremove_head(const char* path)\n{\n  if (*path == '/') {\n    ++path;\n  }\n  auto start = find(path, '/');\n  if (start == nullptr) {\n    return copy_str&lt;length(path)&gt;(\n      path);\n  } else {\n    return copy_str&lt;length(\n      start + 1)&gt;(start + 1);\n  }\n}\n</code></pre><p>它的问题仍然是，没法通过编译。并且，你有没有注意到，这个代码恰恰违反了我上面提到过的，一个函数的返回类型需要一致这个约束。</p><p>对于这个问题，我目前一般采用 Michael Park 描述的一个解法，用 lambda 表达式来对“编译期参数”进行封装 <span class=\"orange\">[2]</span>。为了方便使用，我定义了三个宏：</p><pre><code class=\"language-cpp\">#define CARG typename\n#define CARG_WRAP(x) [] { return (x); }\n#define CARG_UNWRAP(x) (x)()\n</code></pre><p>“CARG”的意思是“constexpr argument”，代表编译期常量参数。对应于之前那个不能编译的 <code>make_constant</code> 函数，我们现在可以用下面的函数模板来代替：</p><pre><code class=\"language-cpp\">template &lt;CARG Int&gt;\nconstexpr auto\nmake_constant(Int cn)\n{\n  constexpr int n = CARG_UNWRAP(cn);\n  return integral_constant&lt;int,\n                           n&gt;{};\n}\n</code></pre><p>很容易验证它能够正常工作：</p><pre><code class=\"language-cpp\">auto result =\n  make_constant(CARG_WRAP(2));\nstatic_assert(\n  std::is_same_v&lt;\n    integral_constant&lt;int, 2&gt;,\n    decltype(result)&gt;);\n</code></pre><p>稍微解释一下。在模板参数里，我用 <code>CARG</code> 代替 <code>typename</code>，这只是为了代码的可读性，表示这个模板参数实质上是编译期常量的类型封装。<code>Int</code> 就是这个特殊类型的名称。这个类型我们在实例化函数模板的时候不提供，而是让编译器自己进行推导。调用的时候（<code>make_constant(CARG_WRAP(2))</code>）实际提供的是一个 lambda 表达式（<code>[] { return (2); }</code>），里面封装了我们需要的常量。在实际使用的时候，再使用 <code>CARG_UNWRAP</code> 来进行求值（<code>[] { return (2); }()</code>），重新得回常量值。</p><p>现在我们可以改写 <code>remove_head</code> 函数了：</p><pre><code class=\"language-cpp\">template &lt;CARG Str&gt;\nconstexpr auto\nremove_head(Str cpath)\n{\n  constexpr auto path =\n    CARG_UNWRAP(cpath);\n  constexpr int skip =\n    (*path == '/') ? 1 : 0;\n  constexpr auto pos = path + skip;\n  constexpr auto start =\n    find(pos, '/');\n  if constexpr (start == nullptr) {\n    return copy_str&lt;length(pos)&gt;(\n      pos);\n  } else {\n    return copy_str&lt;length(\n      start + 1)&gt;(start + 1);\n  }\n}\n</code></pre><p>这个函数跟之前的版本结构相似，但细节上有了很多改变。为了把结果作为模板参数传递给 <code>copy_str</code>，我们不得不一路使用 constexpr，为此还必须放弃可变性，写出非常具有函数式编程风格的代码。</p><p>最终效果如何呢？我们在 <code>main</code> 函数里只放下面这一条语句试试：</p><pre><code class=\"language-cpp\">puts(strtools::remove_head(\n       CARG_WRAP(\"/usr/local\"))\n       .data());\n</code></pre><p>下面是 GCC 在 x86-64 上优化编译输出的汇编（参见 <a href=\"https://godbolt.org/z/M1v1ba3PE\">https://godbolt.org/z/M1v1ba3PE</a>）：</p><pre><code class=\"language-assembly\">main:\n        sub     rsp, 24\n        mov     eax, DWORD PTR .LC0[rip]\n        lea     rdi, [rsp+8]\n        mov     DWORD PTR [rsp+8], eax\n        mov     eax, 108\n        mov     WORD PTR [rsp+12], ax\n        call    puts\n        xor     eax, eax\n        add     rsp, 24\n        ret\n.LC0:\n        .byte   108\n        .byte   111\n        .byte   99\n        .byte   97\n</code></pre><p>可以看到，编译器会把 <code>\"local\"</code> 对应的 ASCII 码填到栈上，把使用的栈空间的起始地址赋给 rdi 寄存器，然后调用 <code>puts</code> 函数。输出中完全看不到 <code>\"/usr/\"</code> 的影子了。事实上，上面那条 <code>puts</code> 语句跟 <code>puts(substr&lt;5&gt;(\"/usr/local\", 5).data());</code> 的输出结果没有区别。</p><p>Godbolt 上的版本是使用 <code>char_traits</code> 的简洁版本，适用于较新的编译器。特别地，GCC 8 就无法正常工作了。而 GitHub 上的<a href=\"https://github.com/adah1972/geek_time_cpp\">代码库</a>采用了手写的 <code>strtools::length</code> 和 <code>strtools::find</code>，在 GCC 7 下依然能够工作。</p><p>这里再提醒一句，编译期产生的字符 <code>array</code> 是可以安全地自由传递和存储的，但从 <code>array</code> 里用 <code>data()</code> 方法取得的指针不是。取得指针<strong>立即</strong>用来调用其他函数是可以的（像上面的 <code>puts</code>），因为 <code>array</code> 的生命周期会延续到这条语句执行结束；但直接把这个指针存下来，则会导致悬挂指针，是一种未定义行为。</p><h2>字符串模板参数</h2><p>上面我们已经在参数传递中把字符串变成了类型（lambda 表达式），但不像整数和 <code>integral_constant</code>，这两者之间没有一一对应关系。这在很多时候是不方便的：对于两个 <code>integral_constant</code>，我们可以直接使用 <code>is_same</code> 来判断它们是否相同；对于传递字符串的 lambda 表达式，我们可没法这么用——两个 lambda 表达式的类型永远不同。</p><p>C++ 里是不允许直接使用字符串字面量作为非类型模板参数的，因为字符串在不同的翻译单元可能会重复出现，而且字符串也没有合适的比较语义——比较两个字符串只是两个指针的比较而已，不能达到用户一般期望的效果。要使用字符串字面量作为模板参数，我们需要找到方法，把字符串当成一系列的字符传给模板进行处理。我们有两种可用的方法：</p><ul>\n<li>GCC 的非标准扩展，可以用在 GCC 和 Clang 编译器中（支持 C++17）</li>\n<li>C++20 的标准方法，可以用在任何支持 C++20 的编译器中（包含 GCC）</li>\n</ul><p>下面我们分别来看一下。</p><h3>GCC 扩展</h3><p>GCC 有一个根据标准提案实现的扩展 <span class=\"orange\">[3]</span>，使得我们可以把字符串当成模板参数来使用，编译器会把字符串展开成一系列的字符，结果就完全落入了标准 C++ 的范畴。这样的代码在 GCC 和 Clang 下都能够工作，但如果你打开 <code>-Wpedantic</code> 开关的话，编译器会对这种用法告警，告诉你这不是标准 C++。</p><p>下面是一个示例：</p><pre><code class=\"language-cpp\">template &lt;char... Cs&gt;\nstruct compile_time_string {\n  static constexpr char value[]{\n    Cs..., '\\0'};\n};\n\ntemplate &lt;typename T, T... Cs&gt;\nconstexpr compile_time_string&lt;Cs...&gt;\noperator\"\"_cts()\n{\n  return {};\n}\n</code></pre><p>类模板的定义是标准 C++，使我们可以声明出 <code>compile_time_string&lt;'H', 'i'&gt;</code> 这样的类型，同时，取这个类型的 <code>value</code> 成员我们即可得到 <code>\"Hi\"</code> 这样一个字符串。GCC 的扩展是在字面量运算符上——我们现在可以写出 <code>\"Hi\"_cts</code> 来得到一个 <code>compile_time_string&lt;'H', 'i'&gt;</code> 类型的对象。</p><p>使用上面的定义，下面的代码会合法通过编译：</p><pre><code class=\"language-cpp\">constexpr auto a = \"Hi\"_cts;\nconstexpr auto b = \"Hi\"_cts;\nstatic_assert(\n  is_same_v&lt;decltype(a),\n            decltype(b)&gt;);\n</code></pre><h3>C++20</h3><p>上面的方法虽然简单有效，但在 C++ 标准委员会没能获得共识从而进入标准。不过，到了 C++20，我们可以在模板参数中使用更多的非类型模板参数的类型了（这句话确实有点拗口）<span class=\"orange\">[4]</span>。特别是，用户定义的字面类型也在其中（可参考<a href=\"https://time.geekbang.org/column/article/182902\">第 15 讲</a>）。</p><p>下面是一个示例：</p><pre><code class=\"language-cpp\">template &lt;size_t N&gt;\nstruct compile_time_string {\n  constexpr compile_time_string(\n    const char (&amp;str)[N])\n  {\n    copy_n(str, N, value);\n  }\n  char value[N]{};\n};\n\ntemplate &lt;compile_time_string cts&gt;\nconstexpr auto operator\"\"_cts()\n{\n  return cts;\n}\n</code></pre><p>同样，前面的那个类模板没啥特别，但允许这个 <code>compile_time_string</code> 用作模板参数，以及<strong>字符串字面量运算符模板</strong> <span class=\"orange\">[5]</span>，就是 C++20 的改进了。我们现在同样可以写出 <code>\"Hi\"_cts</code> 来生成一个 <code>compile_time_string</code> 的对象。不过，需要注意的是，这个对象的类型是 <code>compile_time_string&lt;3&gt;</code>，因此 <code>\"Hi\"_cts</code> 和 <code>\"Ha\"_cts</code> 属于同一类型——这就和 GCC 扩展的结果很不同了。</p><p>不过，重点在于我们已经可以使用 <code>compile_time_string</code> 作为模板参数，所以，我们再小小地包一层就可以了：</p><pre><code class=\"language-cpp\">template &lt;compile_time_string cts&gt;\nstruct cts_wrapper {\n  static constexpr compile_time_string\n    str{cts};\n};\n</code></pre><p>对应于前面的编译期字符串类型比较，我们现在需要这样写：</p><pre><code class=\"language-cpp\">auto a = cts_wrapper&lt;\"Hi\"_cts&gt;{};\nauto b = cts_wrapper&lt;\"Hi\"_cts&gt;{};\nstatic_assert(\n  is_same_v&lt;decltype(a),\n            decltype(b)&gt;);\n</code></pre><p>甚至进一步简化成（通过非 explicit 的构造）：</p><pre><code class=\"language-cpp\">auto a = cts_wrapper&lt;\"Hi\"&gt;{};\nauto b = cts_wrapper&lt;\"Hi\"&gt;{};\nstatic_assert(\n  is_same_v&lt;decltype(a),\n            decltype(b)&gt;);\n</code></pre><h3>接口统一</h3><p>前面 GCC 和 C++20 的写法不一致，在实际项目里会带来一些困扰。因此，在实际项目里，我会使用宏，使得实际使用这些功能的代码是统一的。具体细节你可以参考 GitHub 上的<a href=\"https://github.com/adah1972/geek_time_cpp\">代码库</a>。在使用这些宏定义之后，现在我们可以这样写：</p><pre><code class=\"language-cpp\">using t1 = decltype(CTS_STRING(Hi));\nusing t2 = decltype(CTS_STRING(Hi));\nusing t3 = decltype(CTS_STRING(Ha));\nstatic_assert(is_same_v&lt;t1, t2&gt;);\nstatic_assert(!is_same_v&lt;t1, t3&gt;);\nputs(CTS_GET_VALUE(CTS_STRING(Hi)));\n</code></pre><p>有了这样的基础之后，我们就可以在编译期玩很多花样，得到一些之前无法完成的效果。</p><h2>内容小结</h2><p>本讲我们讨论了在编译期处理字符串的一些技巧。利用这些技巧，我们能够在编译而非执行代码时对字符串进行处理，从而把一些处理提前，消除运行期的开销。</p><h2>课后思考</h2><p>请尝试一下，你能不能实现我文中提到的需求，在编译期把一个文件名去掉前面的路径部分，只留下最后的名称？</p><p>期待你的分享，如有任何疑问，欢迎留言讨论！</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] David Stone, “<code>constexpr</code> function parameters”. <a href=\"https://wg21.link/p1045r1\">https://wg21.link/p1045r1</a></span></p><p><span class=\"reference\">[2] Michael Park, “<code>constexpr</code> function parameters”. <a href=\"https://mpark.github.io/programming/2017/05/26/constexpr-function-parameters/\">https://mpark.github.io/programming/2017/05/26/constexpr-function-parameters/</a></span></p><p><span class=\"reference\">[3] Richard Smith, “Literal operator templates for strings”. <a href=\"http://wg21.link/n3599\">http://wg21.link/n3599</a></span></p><p><span class=\"reference\">[4] cppreference.com, “Template parameters and template arguments”. <a href=\"https://en.cppreference.com/w/cpp/language/template_parameters\">https://en.cppreference.com/w/cpp/language/template_parameters</a></span></p><p><span class=\"reference\">[4a] cppreference.com, “模板形参与模板实参”. <a href=\"https://zh.cppreference.com/w/cpp/language/template_parameters\">https://zh.cppreference.com/w/cpp/language/template_parameters</a></span></p><p><span class=\"reference\">[5] cppreference.com, “User-defined literals”. <a href=\"https://en.cppreference.com/w/cpp/language/user_literal\">https://en.cppreference.com/w/cpp/language/user_literal</a></span></p><p><span class=\"reference\">[5a] cppreference.com, “用户定义字面量”. <a href=\"https://zh.cppreference.com/w/cpp/language/user_literal\">https://zh.cppreference.com/w/cpp/language/user_literal</a></span></p>","neighbors":{"left":{"article_title":"38 | 折叠表达式：高效的编译期展开","id":523170},"right":[]}}]