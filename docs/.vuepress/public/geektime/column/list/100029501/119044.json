{"id":119044,"title":"30丨锁：悲观锁和乐观锁是什么？","content":"<p>索引和锁是数据库中的两个核心知识点，不论在工作中，还是在面试中，我们都会经常跟它们打交道。之前我们已经从不同维度对索引进行了了解，比如B+树、Hash索引、页结构、缓冲池和索引原则等，了解它们的工作原理可以加深我们对索引的理解。同时在基础篇的部分中，我也讲解了事务的4大原则以及不同的隔离级别。这些隔离级别的实现都是通过锁来完成的，你可以思考下为什么我们需要给数据加锁呢？</p><p>实际上加锁是为了保证数据的一致性，这个思想在程序开发领域中同样很重要。在程序开发中也会存在多线程同步的问题。当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻最多只有一个线程在进行访问，保证数据的完整性和一致性。</p><p>今天的内容主要包括以下几个方面：</p><ol>\n<li>就分类而言，锁的划分有多种方式，这些划分方式都包括哪些？</li>\n<li>为什么共享锁会发生死锁？</li>\n<li>乐观锁和悲观锁的思想是什么？乐观锁有两种实现方式，这两种实现方式是什么？</li>\n<li>多个事务并发，发生死锁时该如何解决？怎样降低死锁发生的概率？</li>\n</ol><h2>按照锁粒度进行划分</h2><p>锁用来对数据进行锁定，我们可以从锁定对象的粒度大小来对锁进行划分，分别为行锁、页锁和表锁。</p><p>顾名思义，行锁就是按照行的粒度对数据进行锁定。锁定力度小，发生锁冲突概率低，可以实现的并发度高，但是对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。</p><!-- [[[read_end]]] --><p>页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</p><p>表锁就是对数据表进行锁定，锁定粒度很大，同时发生锁冲突的概率也会较高，数据访问的并发度低。不过好处在于对锁的使用开销小，加锁会很快。</p><p>行锁、页锁和表锁是相对常见的三种锁，除此以外我们还可以在区和数据库的粒度上锁定数据，对应区锁和数据库锁。不同的数据库和存储引擎支持的锁粒度不同，InnoDB和Oracle支持行锁和表锁。而MyISAM只支持表锁，MySQL中的BDB存储引擎支持页锁和表锁。SQL Server可以同时支持行锁、页锁和表锁，如下表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/b2/ca5598e46ab7ec59c3d3721e337a1ab2.png?wh=857*332\" alt=\"\"><br>\n这里需要说明下，每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><h2>从数据库管理的角度对锁进行划分</h2><p>除了按照锁粒度大小对锁进行划分外，我们还可以从数据库管理的角度对锁进行划分。共享锁和排它锁，是我们经常会接触到的两把锁。</p><p>共享锁也叫读锁或S锁，共享锁锁定的资源可以被其他用户读取，但不能修改。在进行<code>SELECT</code>的时候，会将对象进行共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改。</p><p>比如我们想给product_comment在表上加共享锁，可以使用下面这行命令：</p><pre><code>LOCK TABLE product_comment READ;\n</code></pre><p>当对数据表加上共享锁的时候，该数据表就变成了只读模式，此时我们想要更新product_comment表中的数据，比如下面这样：</p><pre><code>UPDATE product_comment SET product_id = 10002 WHERE user_id = 912178;\n</code></pre><p>系统会做出如下提示：</p><pre><code>ERROR 1099 (HY000): Table 'product_comment' was locked with a READ lock and can't be updated\n</code></pre><p>也就是当共享锁没有释放时，不能对锁住的数据进行修改。</p><p>如果我们想要对表上的共享锁进行解锁，可以使用下面这行命令：</p><pre><code>UNLOCK TABLE;\n</code></pre><p>如果我们想要给某一行加上共享锁呢，比如想对user_id=912178的数据行加上共享锁，可以像下面这样：</p><pre><code>SELECT comment_id, product_id, comment_text, user_id FROM product_comment WHERE user_id = 912178 LOCK IN SHARE MODE\n</code></pre><p>排它锁也叫独占锁、写锁或X锁。排它锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。</p><p>如果我们想给product_comment数据表添加排它锁，可以使用下面这行命令：</p><pre><code>LOCK TABLE product_comment WRITE;\n</code></pre><p>这时只有获得排它锁的事务可以对product_comment进行查询或修改，其他事务如果想要在product_comment表上查询数据，则需要等待。你可以自己开两个MySQL客户端来模拟下。</p><p>这时我们释放掉排它锁，使用这行命令即可。</p><pre><code>UNLOCK TABLE;\n</code></pre><p>同样的，如果我们想要在某个数据行上添加排它锁，比如针对user_id=912178的数据行，则写成如下这样：</p><pre><code>SELECT comment_id, product_id, comment_text, user_id FROM product_comment WHERE user_id = 912178 FOR UPDATE;\n</code></pre><p>另外当我们对数据进行更新的时候，也就是<code>INSERT</code>、<code>DELETE</code>或者<code>UPDATE</code>的时候，数据库也会自动使用排它锁，防止其他事务对该数据行进行操作。</p><p>当我们想要获取某个数据表的排它锁的时候，需要先看下这张数据表有没有上了排它锁。如果这个数据表中的某个数据行被上了行锁，我们就无法获取排它锁。这时需要对数据表中的行逐一排查，检查是否有行锁，如果没有，才可以获取这张数据表的排它锁。这个过程是不是有些麻烦？这里就需要用到意向锁。</p><p>意向锁（Intent Lock），简单来说就是给更大一级别的空间示意里面是否已经上过锁。举个例子，你可以给整个房子设置一个标识，告诉它里面有人，即使你只是获取了房子中某一个房间的锁。这样其他人如果想要获取整个房子的控制权，只需要看这个房子的标识即可，不需要再对房子中的每个房间进行查找。这样是不是很方便？</p><p>返回数据表的场景，如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p><p>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。同理，事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录，不能对整个表进行全表扫描。</p><h2>为什么共享锁会发生死锁的情况？</h2><p>当我们使用共享锁的时候会出现死锁的风险，下面我们用两个MySQL客户端来模拟一下事务查询。</p><p>首先客户端1开启事务，然后采用读锁的方式对<code>user_id=912178</code>的数据行进行查询，这时事务没有提交的时候，这两行数据行上了读锁。</p><p><img src=\"https://static001.geekbang.org/resource/image/94/48/94f4e7c282b6cbeae64f0bad5ac6cb48.png?wh=1730*483\" alt=\"\"><br>\n然后我们用客户端2开启事务，同样对<code>user_id=912178</code>获取读锁，理论上获取读锁后还可以对数据进行修改，比如执行下面这条语句：</p><pre><code>UPDATE product_comment SET product_i = 10002 WHERE user_id = 912178;\n</code></pre><p>当我们执行的时候客户端2会一直等待，因为客户端1也获取了该数据的读锁，不需要客户端2对该数据进行修改。这时客户端2会提示等待超时，重新执行事务。</p><p><img src=\"https://static001.geekbang.org/resource/image/10/16/10b9d284597012bcd237041d7c573a16.png?wh=1730*601\" alt=\"\"><br>\n你能看到当有多个事务对同一数据获得读锁的时候，可能会出现死锁的情况。</p><h2>从程序员的角度进行划分</h2><p>如果从程序员的视角来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待数据并发的思维方式。</p><p>乐观锁（Optimistic Locking）认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者时间戳机制实现。</p><h3>乐观锁的版本号机制</h3><p>在表中设计一个版本字段version，第一次读的时候，会获取version字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p>这种方式类似我们熟悉的SVN、CVS版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p><h3>乐观锁的时间戳机制</h3><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p><p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p><p>悲观锁（Pessimistic Locking）也是一种思想，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/e3/0dd602515faab3b6b0cd0d42adaa87e3.png?wh=1728*677\" alt=\"\"><br>\n从这两种锁的设计思想中，你能看出乐观锁和悲观锁的适用场景：</p><ol>\n<li>\n<p>乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p>\n</li>\n<li>\n<p>悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读-写和写-写的冲突。</p>\n</li>\n</ol><h2>总结</h2><p>今天我们讲解了数据库中锁的划分，你能看到从不同维度都可以对锁进行划分，需要注意的是，乐观锁和悲观锁并不是锁，而是锁的设计思想。</p><p>既然有锁的存在，就有可能发生死锁的情况。死锁就是多个事务（如果是在程序层面就是多个进程）在执行过程中，因为竞争某个相同的资源而造成阻塞的现象。发生死锁，往往是因为在事务中，锁的获取是逐步进行的。</p><p>我在文章中举了一个例子，在客户端1获取某数据行共享锁的同时，另一个客户端2也获取了该数据行的共享锁，这时任何一个客户端都没法对这个数据进行更新，因为共享锁会阻止其他事务对数据的更新，当某个客户端想要对锁定的数据进行更新的时候，就出现了死锁的情况。当死锁发生的时候，就需要一个事务进行回滚，另一个事务获取锁完成事务，然后将锁释放掉，很像交通堵塞时候的解决方案。</p><p><img src=\"https://static001.geekbang.org/resource/image/97/7f/9794e3a155edbf8d7b68a7ff8910fc7f.jpg?wh=3011*2313\" alt=\"\"><br>\n我们都不希望出现死锁的情况，可以采取一些方法避免死锁的发生：</p><ol>\n<li>如果事务涉及多个表，操作比较复杂，那么可以尽量一次锁定所有的资源，而不是逐步来获取，这样可以减少死锁发生的概率；</li>\n<li>如果事务需要更新数据表中的大部分数据，数据表又比较大，这时可以采用锁升级的方式，比如将行级锁升级为表级锁，从而减少死锁产生的概率；</li>\n<li>不同事务并发读写多张数据表，可以约定访问表的顺序，采用相同的顺序降低死锁发生的概率。</li>\n</ol><p>当然在数据库中，也有一些情况是不会发生死锁的，比如采用乐观锁的方式。另外在MySQL MyISAM存储引擎中也不会出现死锁，这是因为MyISAM总是一次性获得全部的锁，这样的话要么全部满足可以执行，要么就需要全部等待。</p><p>最后你有没有想过，使用MySQL InnoDB存储引擎时，为什么对某行数据添加排它锁之前，会在数据表上添加意向排他锁呢？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起来进步。</p>","neighbors":{"left":{"article_title":"29丨为什么没有理想的索引？","id":118746},"right":{"article_title":"31丨为什么大部分RDBMS都会支持MVCC？","id":120351}},"comments":[{"had_liked":false,"id":125535,"user_name":"DZ","can_delete":false,"product_type":"c1","uid":1132240,"ip_address":"","ucode":"452555FA0F9E0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/d0/6bafd7d4.jpg","comment_is_top":false,"comment_ctime":1566199927,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"263559204983","product_id":100029501,"comment_content":"意向锁是一种协作机制，用于表锁和行锁的共生场景。<br><br>意向锁表达的信息很明确：某事务打算获得某种行锁，或某事务已持有某种行锁。<br><br>这样一来，打算锁表的事务就能迅速获得足够的锁信息并决定下一步行动。<br><br>反之，如果没有意向锁机制，打算锁表的事务就必须遍历所有行的锁信息，才能获得足够的锁信息，这样实际上就形成了行锁对表锁的严重干扰。<br><br>如果表锁和行锁不共生，如MyISAM仅支持表锁，就不需要意向锁了。","like_count":61,"discussions":[{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377487,"discussion_content":"赞，补充一点官方文档的解释：\nIntention Locks\nInnoDB supports multiple granularity locking which permits coexistence of row locks and table locks. For example, a statement such as LOCK TABLES ... WRITE takes an exclusive lock (an X lock) on the specified table. To make locking at multiple granularity levels practical, InnoDB uses intention locks. Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table. There are two types of intention locks:\n\nAn intention shared lock (IS) indicates that a transaction intends to set a shared lock on individual rows in a table.\n\nAn intention exclusive lock (IX) indicates that a transaction intends to set an exclusive lock on individual rows in a table.\n\nFor example, SELECT ... FOR SHARE sets an IS lock, and SELECT ... FOR UPDATE sets an IX lock.\n\nThe intention locking protocol is as follows:\n\nBefore a transaction can acquire a shared lock on a row in a table, it must first acquire an IS lock or stronger on the table.\n\nBefore a transaction can acquire an exclusive lock on a row in a table, it must first acquire an IX lock on the table.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622684592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587830,"discussion_content":"通透！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663311596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129204,"user_name":"wonderq_gk","can_delete":false,"product_type":"c1","uid":1572636,"ip_address":"","ucode":"9A10DDC39DBB6B","user_header":"https://static001.geekbang.org/account/avatar/00/17/ff/1c/d049776e.jpg","comment_is_top":false,"comment_ctime":1567062429,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"199135558045","product_id":100029501,"comment_content":"死锁那个演示有问题啊，死锁是互相等待，而你演示的只是单方等待，很正常啊，根本就不是死锁","like_count":46,"discussions":[{"author":{"id":1013283,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","nickname":"空知","note":"","ucode":"C448E98238DD36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6994,"discussion_content":"(⊙v⊙)嗯...好像确实不能算作死锁 死锁需要彼此循环等待 样例只是占有等待，只能算作阻塞超时吧","likes_number":17,"is_delete":false,"is_hidden":false,"ctime":1567244088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1798260,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/70/74/06742258.jpg","nickname":"demnox","note":"","ucode":"C3D8A08ED74ED1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":125120,"discussion_content":"如果客户端1也update的话，就会阻塞，这样1和2都在等对方释放共享锁","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1578475445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264796,"discussion_content":"嗯 可能叫做事务锁等待超时更准确些","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1589348456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364440,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d1/d8/e63e3bab.jpg","nickname":"寒山","note":"","ucode":"4D363531F959F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323000,"discussion_content":"既然获取的是共享锁(读锁)，为什么还想着有更新操作？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604851274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127312,"user_name":"melon","can_delete":false,"product_type":"c1","uid":1327313,"ip_address":"","ucode":"AFBE9426C10AFA","user_header":"https://static001.geekbang.org/account/avatar/00/14/40/d1/fb6f402a.jpg","comment_is_top":false,"comment_ctime":1566647595,"is_pvip":false,"replies":[{"id":"47664","content":"感谢提问，在InnoDB中有三种行锁的方式：<br>1）记录锁：针对单个行记录添加锁。<br>2）间隙锁（Gap Locking）：可以帮我们锁住一个范围（索引之间的空隙），但不包括记录本身。采用间隙锁的方式可以防止幻读情况的产生。<br>3）Next-Key锁：帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁+记录锁，可以解决幻读的问题","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1566900990,"ip_address":"","comment_id":127312,"utype":1}],"discussion_count":4,"race_medal":0,"score":"87465993515","product_id":100029501,"comment_content":"老师 意向锁(intent lock)和间隙锁（gap lock） 还有next-key lock 能否说一下呢<br>","like_count":20,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464433,"discussion_content":"感谢提问，在InnoDB中有三种行锁的方式：\n1）记录锁：针对单个行记录添加锁。\n2）间隙锁（Gap Locking）：可以帮我们锁住一个范围（索引之间的空隙），但不包括记录本身。采用间隙锁的方式可以防止幻读情况的产生。\n3）Next-Key锁：帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁+记录锁，可以解决幻读的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566900990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377488,"discussion_content":"可以看下官方文档 https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.htmlhttps://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html 的介绍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622684726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239546,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKWiaZb7a2JAcIVlXYuZ3iaPfSF6vBbg3yUps6LKpsZarftyXufMHYKJmMKzH3bIpVkDAVNXE9q0oOw/132","nickname":"Mr_scx","note":"","ucode":"28B5CE68A5A339","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301713,"discussion_content":"这么说，MySQL中的默认事务隔离级别是可重复读，从定义上来说，可重复读机制是无法避免幻读的异常发生，但是MySQL innoDB中可以通过锁进行优化，也就是采用这里的next-key锁，就可以避免幻读？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598615339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1446375,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","nickname":"book尾汁","note":"","ucode":"AE2B8DFC643ACC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200909,"discussion_content":"也就是说记录锁可以避免不可重复读  但不能避免幻读，间隙锁可以避免幻读，但不能避免不可重复读，next-key锁两种都可以避免。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583738967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131815,"user_name":"小年","can_delete":false,"product_type":"c1","uid":1239992,"ip_address":"","ucode":"BDEF5315847236","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/b8/22065888.jpg","comment_is_top":false,"comment_ctime":1567915655,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"48812555911","product_id":100029501,"comment_content":"啊，读锁不是不能修改吗，为啥模拟的客户端2说理论上可以修改呀？","like_count":11,"discussions":[{"author":{"id":1572866,"avatar":"https://static001.geekbang.org/account/avatar/00/18/00/02/54ff9f67.jpg","nickname":"极客小码","note":"","ucode":"A19924AE51BE03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292188,"discussion_content":"set autocommit=0; 我试了一下，事务还没 commit 的话，另开一个窗口，相同的用户不能修改，行锁是有效的，commit之后，则行锁释放","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595132391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245735,"avatar":"https://static001.geekbang.org/account/avatar/00/13/02/27/226f3c4a.jpg","nickname":"周佳","note":"","ucode":"BBD2D15E37FF6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67008,"discussion_content":"是不能修改的，这里有问题。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575120041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1252173,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1b/4d/2cc44d9a.jpg","nickname":"刘忽悠","note":"","ucode":"095DE3A8D3F450","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1245735,"avatar":"https://static001.geekbang.org/account/avatar/00/13/02/27/226f3c4a.jpg","nickname":"周佳","note":"","ucode":"BBD2D15E37FF6E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156948,"discussion_content":"测了一下，本用户加的行锁，自己是可以修改的，并且其他用户对本行也能继续加行锁，但是其他用户不能修改；如果是表锁，那本用户自己也不能修改，其他用户一样，另外其他用户不能继续加锁，必须等待表锁被释放","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1580421003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":67008,"ip_address":""},"score":156948,"extra":""},{"author":{"id":1245504,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/40/a203a3b9.jpg","nickname":"爱学习不害怕","note":"","ucode":"BE325C02E4C92F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252173,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1b/4d/2cc44d9a.jpg","nickname":"刘忽悠","note":"","ucode":"095DE3A8D3F450","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":306048,"discussion_content":"谢谢分享。根据你的测试结果，我的理解是这样，客户端2给这个行加了个行锁，那么理论上来说客户端2还能接着对这一行进行修改。但是实际上还有一把行锁在客户端1那儿，那么客户端2只能等待这把锁释放，结果就是超时了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600155513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":156948,"ip_address":""},"score":306048,"extra":""},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252173,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1b/4d/2cc44d9a.jpg","nickname":"刘忽悠","note":"","ucode":"095DE3A8D3F450","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":377502,"discussion_content":"为什么本用户加的行锁，自己是可以修改的？之前不是说 “共享锁也叫读锁或 S 锁，共享锁锁定的资源可以被其他用户读取，但不能修改。”，我查官方文档的时候，看到人家说，老师说的行锁，其实是意向锁，文档里这么讲：For example, SELECT ... FOR SHARE sets an IS lock, and SELECT ... FOR UPDATE sets an IX lock. 【这个语句结构就是文中对行加读锁和写锁的语句】\n同时又说：\nIntention locks **do not** block anything except full table requests (for example, LOCK TABLES ... WRITE). The main purpose of intention locks is to show that someone is locking （注意这里的语态是现在将来时） a row【注意这里都是针对行】, or going to lock a row in the table. 【给我感觉好像就是并没有真的锁定某个行，而是说未来可能要进行 读 或者 写 的操作，起个示意的作用，就像评论区第条小DZ同学说的，“意向锁是一种协作机制，用于表锁和行锁的共生场景。\n意向锁表达的信息很明确：某事务打算获得某种行锁，或某事务已持有某种行锁。”】\n也正是因为行锁（意向锁）不是已经锁住，所以说是可以修改的？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1622688134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":156948,"ip_address":""},"score":377502,"extra":""}]},{"author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264751,"discussion_content":"我觉得他的意思是想说  理论上这里正常的操作应该是客户端1已经释放了共享锁  此时客户端2就可以进行修改  但是 实际上是没有发生的。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589346317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006214,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5a/86/abb7bfe3.jpg","nickname":"OrdinaryYZH","note":"","ucode":"244B9184B20DBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312721,"discussion_content":"DDIA里面有提到，这应该叫锁升级，一个事务中是可以先读，再写的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602779305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165599,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1577266644,"is_pvip":false,"replies":[{"id":"63474","content":"总结的不错","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1577503764,"ip_address":"","comment_id":165599,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35937005012","product_id":100029501,"comment_content":"悲观锁和乐观锁<br>从字面上来理解，那就是一个是悲观的，一个是乐观的，至于什么意思，作为中国人，这词语的意思你不会不懂！<br><br>悲观锁<br>比如说有一个人总是小心翼翼的，吃饭喝水要验毒，家里要装摄像头，走路都要左顾右盼，生怕别人害他，在数据库中也就是生怕别人操作它的数据，干什么之前都要先检查一遍（加锁操作），等我使用完了，我在开放。（这样的人生其实太累了，容易死锁）<br><br>乐观锁<br>有个人干什么都很放心自己，也放心别人，大大咧咧，，吃饭也不管有没有毒就吃，类似于这样的操作就叫做是乐观锁，总是认为别人不会操作他的数据，就去操作数据，在提交的时候，根据固定的信息去检查一下，一般就是version.这样的话，如果发现信息不对（别人谋害他），就不更新了（去医院治愈好了）","like_count":8,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479219,"discussion_content":"总结的不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577503764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377509,"discussion_content":"悲观锁好像也没那么悲观吧【笑哭】\n感觉就像是，饭前一定要洗手遵守一套流程化的东西，有点死板罢了（比如没有洗手的地方就不吃饭了）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622688835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125466,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1566187379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35925925747","product_id":100029501,"comment_content":"使用 MySQL InnoDB 存储引擎时，为什么对某行数据添加排它锁之前，会在数据表上添加意向排他锁呢？<br>这样就不需要逐行扫描，看每一行上是否有排它锁了，通过大粒度，来节省资源。","like_count":8},{"had_liked":false,"id":165602,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1577267018,"is_pvip":false,"replies":[{"id":"63473","content":"对的","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1577503756,"ip_address":"","comment_id":165602,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31642038090","product_id":100029501,"comment_content":"问题——<br>告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。而不需要进行全表的扫描，节省时间，提高效率！","like_count":7,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479221,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577503756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135751,"user_name":"峻铭","can_delete":false,"product_type":"c1","uid":1106202,"ip_address":"","ucode":"63AB23BADACA88","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/1a/20977779.jpg","comment_is_top":false,"comment_ctime":1569253029,"is_pvip":false,"replies":[{"id":"54097","content":"对 乐观锁的一种实现","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1570782027,"ip_address":"","comment_id":135751,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27339056805","product_id":100029501,"comment_content":"乐观锁让我想起了java里面的cas原理","like_count":6,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468324,"discussion_content":"对 乐观锁的一种实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570782027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21129,"discussion_content":"是的，一个原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569423071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152925,"user_name":"冲","can_delete":false,"product_type":"c1","uid":1149914,"ip_address":"","ucode":"4191C8A4DF3840","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIk46cor5XVFTPZbPOnb7pViabgy450pobo46hRHFQz5nR5ocYRKIzC8vShic36vwa553H4Vj50x5wA/132","comment_is_top":false,"comment_ctime":1574124860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18753994044","product_id":100029501,"comment_content":"老师有个问题，这个锁是一般在我进行select等语句是或自动加锁吗？而在这里只是讲了有这几种锁的机制。还是说正常情况下数据库不会主动加锁，我需要主动去加锁。","like_count":4},{"had_liked":false,"id":295961,"user_name":"完美坚持","can_delete":false,"product_type":"c1","uid":1919541,"ip_address":"","ucode":"AE0261D8DDEF64","user_header":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","comment_is_top":false,"comment_ctime":1622683869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14507585757","product_id":100029501,"comment_content":"我看官方文档那个例子还要更进一步，1 要读取 —— 加了 共享锁；2 要修改 —— 需要加 排它锁，但是受制于 1 的共享锁，没办法实现；1又要进一步修改 —— 需要 2 释放它的 排它锁；可是此时 1 的 共享锁还没有释放，于是不能成行，成了死扣了。<br>举个生活化的场景：<br>1. 老婆生气了（共享锁）；<br>2. 老公本来想让老婆帮自己一下忙——把冰箱的生鸡蛋拿过去，老公要炒鸡蛋，结果老婆生气，不给他拿；<br>   2.1 假设老公没有办法自己拿鸡蛋，只能等老婆拿过鸡蛋自己才能炒菜，于是老公就只能等老婆那边消气（当然他可以哄老婆，让老婆早点消气）；<br>3. 可是现在老婆非要老公把炒好的鸡蛋拿过来她要吃，老公也没有办法啊——你不拿来生鸡蛋我怎么炒鸡蛋，这不是巧妇难为无米之炊，难为我妈【笑哭】。<br>我觉得这个更像是一种思索的例子（必须要到第3步才真正是个死锁），而文中的那个例子，好像只到了第二步。","like_count":3},{"had_liked":false,"id":242944,"user_name":"官人","can_delete":false,"product_type":"c1","uid":1306315,"ip_address":"","ucode":"ECEF55B08E252B","user_header":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","comment_is_top":false,"comment_ctime":1597899671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14482801559","product_id":100029501,"comment_content":"老师你好:<br>         执行update的时候where带索引和不带索引会导致全表锁和行锁 这个行锁和表锁在不同隔离级别下是怎么定义的? <br>         我在读未提交,和读已提交隔离级别下发现update where不带索引也没有导致表锁,<br>         在 REPEATABLE READ 才出现表锁 <br>         请问老师在不同隔离级别update上锁的机制有什么不同么.","like_count":3},{"had_liked":false,"id":235822,"user_name":"程序员班吉","can_delete":false,"product_type":"c1","uid":1478098,"ip_address":"","ucode":"BD48CF7649609A","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/d2/8a6be8d8.jpg","comment_is_top":false,"comment_ctime":1595212831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14480114719","product_id":100029501,"comment_content":"乐观锁和悲观锁是一种锁的思想<br><br>一、乐观锁<br>乐观锁说的是程序员认为同一数据发生并发的情况属于小概率事件，从代码层面通过版本号、时间戳等手段来验证当前事务内数据的一致性<br><br>二、悲观锁<br>悲观锁说的是，程序员认为数据在同一时刻可能会存在大量并发的情况，需要借助数据库一些锁机制来实现数据的一致性，具体的手段包括：<br>1. 共享锁——多个事务可以同时查询数据，但在其它事务查询的时候不能进行更新操作<br>2. 排他锁——排他锁用于更新操作，保证在同一时刻只有一个事务可以对数据进行更新<br>3. 意向锁——由于获取共享锁和排他锁需要确保数据表中没有行锁，所以需要扫描每一行来判断是否有锁，效率不高。意向所其实就是在表的层面加了一标识，如果表中有行锁那在表的层面也会有一个对应的意向锁。","like_count":3},{"had_liked":false,"id":138737,"user_name":"edc","can_delete":false,"product_type":"c1","uid":1030994,"ip_address":"","ucode":"DD6CE24AEC115B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/52/50624a0f.jpg","comment_is_top":false,"comment_ctime":1570435736,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10160370328","product_id":100029501,"comment_content":"【在进行SELECT的时候，会将对象进行共享锁锁定】这句有点模糊，如果select自动就加上了共享锁，为什么还要在SQL中加上 lock in share mode","like_count":2,"discussions":[{"author":{"id":2618193,"avatar":"https://static001.geekbang.org/account/avatar/00/27/f3/51/c8eb2d0c.jpg","nickname":"Amon Tin","note":"","ucode":"25391BEEB6A719","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545808,"discussion_content":"select不会自动给行加共享锁，只有在指定share mode时才会加，select时innodb是采用的快照读redaview模式做了无锁化的设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642056177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005290,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg","nickname":"giteebravo","note":"","ucode":"C087E8D6B5A98B","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345029,"discussion_content":"怎么让 select 自动加共享锁？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611643406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129215,"user_name":"wonderq_gk","can_delete":false,"product_type":"c1","uid":1572636,"ip_address":"","ucode":"9A10DDC39DBB6B","user_header":"https://static001.geekbang.org/account/avatar/00/17/ff/1c/d049776e.jpg","comment_is_top":false,"comment_ctime":1567063504,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10156998096","product_id":100029501,"comment_content":"主要是共享锁会发生死锁，排他锁应该不会","like_count":2,"discussions":[{"author":{"id":1005290,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg","nickname":"giteebravo","note":"","ucode":"C087E8D6B5A98B","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345007,"discussion_content":"排他锁会独占资源，不会发生死锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611638117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127161,"user_name":"yhui","can_delete":false,"product_type":"c1","uid":1512714,"ip_address":"","ucode":"1AAAF47E41FFB8","user_header":"https://static001.geekbang.org/account/avatar/00/17/15/0a/c450e565.jpg","comment_is_top":false,"comment_ctime":1566571613,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"10156506205","product_id":100029501,"comment_content":"陈老师，我们同姓，麻烦帮忙看看这个问题：<br>SELECT id FROM user <br>WHERE 1=1 AND aid IN (1,2) <br>AND bid IN (4) <br>AND cid IN (-1,0,1,2,3,4,5,6,7,17,16,15,14,13,12,18,8) <br>ORDER BY id DESC  LIMIT 20<br>我创建了（aid,bid,cid,did）的联合索引<br>使用explain分析发现这条语句没用上联合索引，反而用的主键索引，然后我试着修改了下语句<br>AND cid IN (-1,0,1,2,3,4,5,6,7,17,16,15,14,13,12,18,8)  把这句改成<br>AND cid IN (-1,0,1,2)   改短了一些，发现索引选择对了！<br><br>这是为什么啊，in里有个数限制多少个会触发优化器重新选择索引导致选错吗？？ <br><br>","like_count":2,"discussions":[{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21128,"discussion_content":"你这个表中是不是数据比较少？选择索引的时候，发现使用索引还不如使用主键来得快呢，所以选择了主键索引。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1569423037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234682,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d6/fa/1f5bf642.jpg","nickname":"未来的胡先森","note":"","ucode":"AFF193AC0E2E6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6281,"discussion_content":"把 WHERE 1=1 去掉呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566821198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066644,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/94/ca15724a.jpg","nickname":"下一道彩虹","note":"","ucode":"6F286504A9BCD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235894,"discussion_content":"话说1=1是什么骚操作？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587050240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1005290,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg","nickname":"giteebravo","note":"","ucode":"C087E8D6B5A98B","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1066644,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/94/ca15724a.jpg","nickname":"下一道彩虹","note":"","ucode":"6F286504A9BCD8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345008,"discussion_content":"代码中的拼接条件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611638201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":235894,"ip_address":""},"score":345008,"extra":""}]}]},{"had_liked":false,"id":274531,"user_name":"zxjiao","can_delete":false,"product_type":"c1","uid":1242725,"ip_address":"","ucode":"01AD348ECAE76C","user_header":"https://static001.geekbang.org/account/avatar/00/12/f6/65/e4e04d15.jpg","comment_is_top":false,"comment_ctime":1611048371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5906015667","product_id":100029501,"comment_content":"老师，InnoDB存储引擎，查询的时候使用了索引列，会自动加共享锁么？","like_count":1},{"had_liked":false,"id":219365,"user_name":"真名不叫黄金","can_delete":false,"product_type":"c1","uid":1174066,"ip_address":"","ucode":"FB611FC98F5BA7","user_header":"https://static001.geekbang.org/account/avatar/00/11/ea/32/1fd102ec.jpg","comment_is_top":false,"comment_ctime":1590019125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884986421","product_id":100029501,"comment_content":"老师，能否请教一个问题。文中说到“意向锁可以避免一行行去检查是否加锁”，为什么需要“一行行”呢？难道锁不是在内存中的一个数据结构保存所有锁吗？为什么会需要去扫表呢？","like_count":1},{"had_liked":false,"id":192279,"user_name":"YqY","can_delete":false,"product_type":"c1","uid":1524154,"ip_address":"","ucode":"73FB936045DCB9","user_header":"https://static001.geekbang.org/account/avatar/00/17/41/ba/ae028565.jpg","comment_is_top":false,"comment_ctime":1584844959,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879812255","product_id":100029501,"comment_content":"<br>UPDATE product_comment SET product_i = 10002 WHERE user_id = 912178;  这句代码的有问题， product_i = 10002 应该是 product_id= 10002 ","like_count":1,"discussions":[{"author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264764,"discussion_content":"是的 应该是手误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589346629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163580,"user_name":"刘育飞","can_delete":false,"product_type":"c1","uid":1363642,"ip_address":"","ucode":"06600614E898CC","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/ba/f73555c7.jpg","comment_is_top":false,"comment_ctime":1576748871,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5871716167","product_id":100029501,"comment_content":"我的mysql 用 innodb 设置自动 提交事务，我没手动开启和提交事务，我执行更新语句时，会自动加行锁吗","like_count":1,"discussions":[{"author":{"id":1033425,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c4/d1/209abdd6.jpg","nickname":"小狼","note":"","ucode":"FEAC7864FC1D20","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298140,"discussion_content":"要看你的 sql 语句怎么写，如果是 update <table_name> set xxx = xxx for update; 形式就会加行锁，否则不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597202474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152946,"user_name":"冲","can_delete":false,"product_type":"c1","uid":1149914,"ip_address":"","ucode":"4191C8A4DF3840","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIk46cor5XVFTPZbPOnb7pViabgy450pobo46hRHFQz5nR5ocYRKIzC8vShic36vwa553H4Vj50x5wA/132","comment_is_top":false,"comment_ctime":1574128196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869095492","product_id":100029501,"comment_content":"老师还有个问题问下，表级锁在一个库中只能对一个表添加吗？<br>我先对第一个表player添加了表级锁，这时使用UODATE 返回Table &#39;player&#39; was locked with a READ lock and can&#39;t be updated，这时正常的<br>我再对player_score添加表级锁 ，这次再对表player UPDATE返回 Table &#39;player&#39; was not locked with LOCK TABLES，这时player也不能进行SELECT查询，同样返回Table &#39;player&#39; was not locked with LOCK TABLES<br>","like_count":1},{"had_liked":false,"id":152909,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1574122835,"is_pvip":false,"replies":[{"id":"59727","content":"加油ABC同学，可以先粗略浏览一遍，然后找文章中感兴趣的内容，有代码的地方 自己复现一遍","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1574738217,"ip_address":"","comment_id":152909,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869090131","product_id":100029501,"comment_content":"回来补课，8月学了一段时间，然后去忙其他的了，希望年内能学完这门课😀😀","like_count":1,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474986,"discussion_content":"加油ABC同学，可以先粗略浏览一遍，然后找文章中感兴趣的内容，有代码的地方 自己复现一遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574738217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054958,"avatar":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","nickname":"ABC","note":"","ucode":"7501AD9C0C4A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60629,"discussion_content":"谢谢老师。正在挨个学习，目前已经学了85%。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574742491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125436,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1566184853,"is_pvip":false,"replies":[{"id":"47670","content":"可以的，地址：https:&#47;&#47;github.com&#47;cystanford&#47;SQL-XMind","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1566901359,"ip_address":"","comment_id":125436,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861152149","product_id":100029501,"comment_content":"请问xmind可以提供下吗","like_count":1,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463574,"discussion_content":"可以的，地址：https://github.com/cystanford/SQL-XMind","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566901359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125382,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1566176886,"is_pvip":false,"replies":[{"id":"47671","content":"棒棒哒！","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1566901405,"ip_address":"","comment_id":125382,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861144182","product_id":100029501,"comment_content":"我又回来了老师<br>","like_count":1,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463553,"discussion_content":"棒棒哒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566901405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357495,"user_name":"年少挽滑稽世无双","can_delete":false,"product_type":"c1","uid":2962599,"ip_address":"四川","ucode":"793DCBDE25A07B","user_header":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","comment_is_top":false,"comment_ctime":1663313465,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663313465","product_id":100029501,"comment_content":"意向锁（Intention Lock），又称I锁，针对表锁。<br>意向锁的含义是如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的上层结点加意向锁。<br>当有事务给表的数据行加了共享锁或排它锁，同时会给表设置一个标识，代表已经有行锁了，其他事务要想对表加表锁时，就不必逐行判断有没有行锁可能跟表锁冲突了，直接读这个标识就可以确定自己该不该加表锁。特别是表中的记录很多时，逐行判断加表锁的方式效率很低。而这个标识就是意向锁。<br>1.意向共享锁（Intent Share Lock，简称IS锁），对整个表加共享锁之前，需要先获取到意向共享锁。<br>2.意向排它锁（Intent Exclusive Lock，简称IX锁），对整个表加排它锁之前，需要先获取到意向排它锁。<br>","like_count":0},{"had_liked":false,"id":314462,"user_name":"Sruby","can_delete":false,"product_type":"c1","uid":1016232,"ip_address":"","ucode":"A7D1B93F41DA0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/a8/559afe8b.jpg","comment_is_top":false,"comment_ctime":1633085442,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1633085442","product_id":100029501,"comment_content":"排它锁也叫独占锁、写锁或 X 锁。排它锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。<br>-----------------------<br>应该跟排它锁的范围有关，如果是表级排它锁会阻塞DML和DQL，但是行级排它锁只会影响DML，DQL不会阻塞。<br>","like_count":0},{"had_liked":false,"id":314461,"user_name":"Sruby","can_delete":false,"product_type":"c1","uid":1016232,"ip_address":"","ucode":"A7D1B93F41DA0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/a8/559afe8b.jpg","comment_is_top":false,"comment_ctime":1633084547,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1633084547","product_id":100029501,"comment_content":"行级排它锁不影响DQL操作，只会影响DML操作。","like_count":0},{"had_liked":false,"id":290030,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1619331701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619331701","product_id":100029501,"comment_content":"从多个角度来区分不同的锁的概念，学到了","like_count":0},{"had_liked":false,"id":219766,"user_name":"王锐浩","can_delete":false,"product_type":"c1","uid":1988541,"ip_address":"","ucode":"00FCBEACF7906D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoeoiahO3vO8xnQbuLkriapWV5J6b08tUiaxhhA7oyRHoBQV7OQQ3TxmSASXs4J39rgibAD9hgptc5jhA/132","comment_is_top":false,"comment_ctime":1590076058,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1590076058","product_id":100029501,"comment_content":"有个问题获得共享锁的事务应该是不能执行修改操作吧，所以上述的共享锁导致死锁的情况应该不成立啊，因为事务需要先释放共享锁再执行修改操作","like_count":0,"discussions":[{"author":{"id":1690807,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cc/b7/af6ef83d.jpg","nickname":"抢小孩子糖吃","note":"","ucode":"09F302FC76582A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311415,"discussion_content":"我理解是获得共享锁的事务可以修改操作 。 是让其他事务不能修改操作自能读","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602332280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208599,"user_name":"ballgod","can_delete":false,"product_type":"c1","uid":1584098,"ip_address":"","ucode":"C20E95E98EAC43","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIR9QrAn9TZOrJMSYMyN96PAuAjETVrN5SPp3hMbfUAGIWtHceWPEoQtPdXeuBn7VB7dagtxynAIA/132","comment_is_top":false,"comment_ctime":1587388486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587388486","product_id":100029501,"comment_content":"用两个客户端试了一下排他锁，但是另一个客户端却能进行读操作，这是什么原因？","like_count":0},{"had_liked":false,"id":207170,"user_name":"Jone_乔泓恺","can_delete":false,"product_type":"c1","uid":1407941,"ip_address":"","ucode":"158154301D5E40","user_header":"https://static001.geekbang.org/account/avatar/00/15/7b/c5/35f92dad.jpg","comment_is_top":false,"comment_ctime":1587020005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587020005","product_id":100029501,"comment_content":"文中的“获取xxx锁” 是不是就是给数据记录上锁、加锁的意思啊？","like_count":0},{"had_liked":false,"id":195014,"user_name":"博弈","can_delete":false,"product_type":"c1","uid":1433344,"ip_address":"","ucode":"B1A69837E41972","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/EcYNib1bnDf5dz6JcrE8AoyZYMdqic2VNmbBtCcVZTO9EoDZZxqlQDEqQKo6klCCmklOtN9m0dTd2AOXqSneJYLw/132","comment_is_top":false,"comment_ctime":1585127974,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585127974","product_id":100029501,"comment_content":"获取读锁，理论上获取读锁后还可以对数据进行修改，这句话不是很理解，为啥从理论上来说还可以修改呢？","like_count":0,"discussions":[{"author":{"id":1005290,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg","nickname":"giteebravo","note":"","ucode":"C087E8D6B5A98B","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345010,"discussion_content":"应该是一种假设吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611638369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177725,"user_name":"Geek_ade3cb","can_delete":false,"product_type":"c1","uid":1815632,"ip_address":"","ucode":"5DD2BAF1E1DDF3","user_header":"","comment_is_top":false,"comment_ctime":1581481259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581481259","product_id":100029501,"comment_content":"老师您好，请问为什么只在页锁终会出现死锁？行锁和表锁不会吗？","like_count":0},{"had_liked":false,"id":172380,"user_name":"酸葡萄","can_delete":false,"product_type":"c1","uid":1154146,"ip_address":"","ucode":"9D059C4FB327C0","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","comment_is_top":false,"comment_ctime":1579164388,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1579164388","product_id":100029501,"comment_content":"但是共享锁不是所谓的读锁吗？读锁不是不允许修改吗？读锁在行级别允许对行进行修改？","like_count":0,"discussions":[{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206974,"discussion_content":"上面的示例是在一个事务中，第一条语句获取读锁，第二条语句再去修改数据。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584455753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172375,"user_name":"酸葡萄","can_delete":false,"product_type":"c1","uid":1154146,"ip_address":"","ucode":"9D059C4FB327C0","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","comment_is_top":false,"comment_ctime":1579163248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579163248","product_id":100029501,"comment_content":"读锁是可以多个客户端同时度的，读锁之所以在事务中会死锁，本质上应该是数据库的读锁是不可重入的吧，即不能重复对一把锁加锁？","like_count":0},{"had_liked":false,"id":164259,"user_name":"爬行的蜗牛","can_delete":false,"product_type":"c1","uid":1033956,"ip_address":"","ucode":"6623B62DE63CE9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QD6bf8hkS5dHrabdW7M7Oo9An1Oo3QSxqoySJMDh7GTraxFRX77VZ2HZ13x3R4EVYddIGXicRRDAc7V9z5cLDlA/132","comment_is_top":false,"comment_ctime":1576917646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576917646","product_id":100029501,"comment_content":"因为意向排它锁目的就是告诉其他事务，目前那些行已经有排它锁，避免其他事物对已经有排它锁的行操作， 更好的避免死锁。","like_count":0},{"had_liked":false,"id":144624,"user_name":"Coool","can_delete":false,"product_type":"c1","uid":1701702,"ip_address":"","ucode":"1D1AB3270B02B9","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/46/209ca424.jpg","comment_is_top":false,"comment_ctime":1571984558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571984558","product_id":100029501,"comment_content":"读锁的模拟实验里，为什么可以修改上了锁的数据？","like_count":0},{"had_liked":false,"id":139648,"user_name":"Beson","can_delete":false,"product_type":"c1","uid":1576655,"ip_address":"","ucode":"F4F1EBE64EBC06","user_header":"https://static001.geekbang.org/account/avatar/00/18/0e/cf/a97a9cd4.jpg","comment_is_top":false,"comment_ctime":1570697992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570697992","product_id":100029501,"comment_content":"老师你好，可以再详细解释一下，为什么共享锁会发生死锁吗？举的例子不太明白","like_count":0},{"had_liked":false,"id":129948,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1567334483,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1567334483","product_id":100029501,"comment_content":"老师，乐观锁应该还是会加锁的对不，基于行锁来修改?","like_count":0,"discussions":[{"author":{"id":1005290,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg","nickname":"giteebravo","note":"","ucode":"C087E8D6B5A98B","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345032,"discussion_content":"不会加锁，在代码层面为 SQL 语句添加了 where 条件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611643607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1573288,"avatar":"https://static001.geekbang.org/account/avatar/00/18/01/a8/2662a8d1.jpg","nickname":"小白鼠丶","note":"","ucode":"76EFABC5DF8AEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8930,"discussion_content":"不加锁 使用程序来实现  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568105047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129691,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1567221419,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1567221419","product_id":100029501,"comment_content":"老师问下 共享锁死锁那里，为啥开了 LOCK IN SHARE MODE 共享锁之后 理论上还可以执行UPDATE 更新操作？更新不是写操作吗？","like_count":0,"discussions":[{"author":{"id":1005290,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg","nickname":"giteebravo","note":"","ucode":"C087E8D6B5A98B","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345033,"discussion_content":"此处应该是一种假设","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611643679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128022,"user_name":"未来的胡先森","can_delete":false,"product_type":"c1","uid":1234682,"ip_address":"","ucode":"AFF193AC0E2E6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/fa/1f5bf642.jpg","comment_is_top":false,"comment_ctime":1566821944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566821944","product_id":100029501,"comment_content":"避免死锁实际上就是破坏「死锁」产生的四个必要条件<br><br>乐观锁解决的就是「资源互斥」问题，让资源由「锁」到相对共享","like_count":0},{"had_liked":false,"id":126752,"user_name":"马哲富","can_delete":false,"product_type":"c1","uid":1107917,"ip_address":"","ucode":"D6BDDFE3CC07ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg","comment_is_top":false,"comment_ctime":1566464230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566464230","product_id":100029501,"comment_content":"如果没有显示的添加锁，是不是有一个默认锁？","like_count":0},{"had_liked":false,"id":125431,"user_name":"lmtoo","can_delete":false,"product_type":"c1","uid":1133918,"ip_address":"","ucode":"FCD5B9C941D448","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/5e/c5c62933.jpg","comment_is_top":false,"comment_ctime":1566184127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566184127","product_id":100029501,"comment_content":"添加意向排它锁是为了防止在锁升级时需要全表扫描；两个读锁，其中一个读锁升级为写锁，这不算是死锁吧","like_count":0},{"had_liked":false,"id":125372,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1566175563,"is_pvip":false,"replies":[{"id":"62757","content":"myisam不是事务安全的","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1577089534,"ip_address":"","comment_id":125372,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1566175563","product_id":100029501,"comment_content":"有一点不明白，为什么MyISAM不存在死锁的情况？MyISAM一个事务一次获取全部的共享锁，另一个事务也获取全部的共享锁，然后再更新数据，这个时候不还是会发生死锁吗？","like_count":0,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463548,"discussion_content":"myisam不是事务安全的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577089534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5320,"discussion_content":"myisam没有事务\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1566177213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1196475,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","nickname":"安静的boy","note":"","ucode":"F5F44B75228A85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5417,"discussion_content":"哦哦 明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566258554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5320,"ip_address":""},"score":5417,"extra":""}]}]}]}