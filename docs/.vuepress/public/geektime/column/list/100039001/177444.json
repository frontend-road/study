{"id":177444,"title":"19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？","content":"<p>关于SOLID原则，我们已经学过单一职责、开闭、里式替换、接口隔离这四个原则。今天，我们再来学习最后一个原则：依赖反转原则。在前面几节课中，我们讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。而今天我们要讲到的依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：</p><ul>\n<li>“依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？</li>\n<li>我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？</li>\n<li>如果你熟悉Java语言，那Spring框架中的IOC跟这些概念又有什么关系呢？</li>\n</ul><p>看了刚刚这些问题，你是不是有点懵？别担心，今天我会带你将这些问题彻底搞个清楚。之后再有人问你，你就能轻松应对。话不多说，现在就让我们带着这些问题，正式开始今天的学习吧！</p><h2>控制反转（IOC）</h2><p>在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是Inversion Of Control，缩写为IOC。此处我要强调一下，如果你是Java工程师的话，暂时别把这个“IOC”跟Spring框架的IOC联系在一起。关于Spring的IOC，我们待会儿还会讲到。</p><!-- [[[read_end]]] --><p>我们先通过一个例子来看一下，什么是控制反转。</p><pre><code>public class UserServiceTest {\n  public static boolean doTest() {\n    // ... \n  }\n  \n  public static void main(String[] args) {//这部分逻辑可以放到框架中\n    if (doTest()) {\n      System.out.println(&quot;Test succeed.&quot;);\n    } else {\n      System.out.println(&quot;Test failed.&quot;);\n    }\n  }\n}\n</code></pre><p>在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：</p><pre><code>public abstract class TestCase {\n  public void run() {\n    if (doTest()) {\n      System.out.println(&quot;Test succeed.&quot;);\n    } else {\n      System.out.println(&quot;Test failed.&quot;);\n    }\n  }\n  \n  public abstract boolean doTest();\n}\n\npublic class JunitApplication {\n  private static final List&lt;TestCase&gt; testCases = new ArrayList&lt;&gt;();\n  \n  public static void register(TestCase testCase) {\n    testCases.add(testCase);\n  }\n  \n  public static final void main(String[] args) {\n    for (TestCase case: testCases) {\n      case.run();\n    }\n  }\n</code></pre><p>把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是TestCase类中的doTest()抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的main()函数了。 具体的代码如下所示：</p><pre><code>public class UserServiceTest extends TestCase {\n  @Override\n  public boolean doTest() {\n    // ... \n  }\n}\n\n// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()\nJunitApplication.register(new UserServiceTest();\n</code></pre><p>刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p><p>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</p><p>实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</p><h2>依赖注入（DI）</h2><p>接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。依赖注入的英文翻译是Dependency Injection，缩写为DI。对于这个概念，有一个非常形象的说法，那就是：依赖注入是一个标价25美元，实际上只值5美分的概念。也就是说，这个概念听起来很“高大上”，实际上，理解、应用起来非常简单。</p><p>那到底什么是依赖注入呢？我们用一句话来概括就是：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p><p>我们还是通过一个例子来解释一下。在这个例子中，Notification类负责消息推送，依赖MessageSender类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：</p><pre><code>// 非依赖注入实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  public Notification() {\n    this.messageSender = new MessageSender(); //此处有点像hardcode\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic class MessageSender {\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n// 使用Notification\nNotification notification = new Notification();\n\n// 依赖注入的实现方式\npublic class Notification {\n  private MessageSender messageSender;\n  \n  // 通过构造函数将messageSender传递进来\n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    //...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  }\n}\n//使用Notification\nMessageSender messageSender = new MessageSender();\nNotification notification = new Notification(messageSender);\n</code></pre><p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把MessageSender定义成接口，基于接口而非实现编程。改造后的代码如下所示：</p><pre><code>public class Notification {\n  private MessageSender messageSender;\n  \n  public Notification(MessageSender messageSender) {\n    this.messageSender = messageSender;\n  }\n  \n  public void sendMessage(String cellphone, String message) {\n    this.messageSender.send(cellphone, message);\n  }\n}\n\npublic interface MessageSender {\n  void send(String cellphone, String message);\n}\n\n// 短信发送类\npublic class SmsSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n// 站内信发送类\npublic class InboxSender implements MessageSender {\n  @Override\n  public void send(String cellphone, String message) {\n    //....\n  }\n}\n\n//使用Notification\nMessageSender messageSender = new SmsSender();\nNotification notification = new Notification(messageSender);\n</code></pre><p>实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，在后面的章节中，我们会讲到，它是编写可测试性代码最有效的手段。</p><h2>依赖注入框架（DI Framework）</h2><p>弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。</p><p>在采用依赖注入实现的Notification类中，虽然我们不需要用类似hard code的方式，在类内部通过new来创建MessageSender对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：</p><pre><code>public class Demo {\n  public static final void main(String args[]) {\n    MessageSender sender = new SmsSender(); //创建对象\n    Notification notification = new Notification(sender);//依赖注入\n    notification.sendMessage(&quot;13918942177&quot;, &quot;短信验证码：2346&quot;);\n  }\n}\n</code></pre><p>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。</p><p>你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p>实际上，现成的依赖注入框架有很多，比如Google Guice、Java Spring、Pico Container、Butterfly Container等。不过，如果你熟悉Java Spring框架，你可能会说，Spring框架自己声称是<strong>控制反转容器</strong>（Inversion Of Control Container）。</p><p>实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而Spring框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。</p><h2>依赖反转原则（DIP）</h2><p>前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是Dependency Inversion Principle，缩写为DIP。中文翻译有时候也叫依赖倒置原则。</p><p>为了追本溯源，我先给出这条原则最原汁原味的英文描述：</p><blockquote>\n<p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p>\n</blockquote><p>我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿Tomcat这个Servlet容器作为例子来解释一下。</p><p>Tomcat是运行Java Web应用程序的容器。我们编写的Web应用程序代码只需要部署在Tomcat容器下，便可以被Tomcat容器调用执行。按照之前的划分原则，Tomcat就是高层模块，我们编写的Web应用程序代码就是低层模块。Tomcat和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是Servlet规范。Servlet规范不依赖具体的Tomcat容器和应用程序的实现细节，而Tomcat容器和应用程序依赖Servlet规范。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.控制反转</strong></p><p>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p><p><strong>2.依赖注入</strong></p><p>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过new的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</p><p><strong>3.依赖注入框架</strong></p><p>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p><strong>4.依赖反转原则</strong></p><p>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。</p><h2>课堂讨论</h2><p>从Notification这个例子来看，“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":162059,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1576457216,"is_pvip":false,"discussion_count":8,"race_medal":1,"score":"1564944552960","product_id":100039001,"comment_content":"课后思考：<br>“基于接口而非实现编程”与“依赖注入”的联系是二者都是从外部传入依赖对象而不是在内部去new一个出来。<br>区别是“基于接口而非实现编程”强调的是“接口”，强调依赖的对象是接口，而不是具体的实现类；而“依赖注入”不强调这个，类或接口都可以，只要是从外部传入不是在内部new出来都可以称为依赖注入。","like_count":365,"discussions":[{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93245,"discussion_content":"Your comment makes perfect sense! 依赖注入与基于接口编程的联系，我理解还有一点，值得提一下。赞成您说的依赖注入本身不强调接口或是实现，但是通常情况下依赖注入加上基于接口威力更大，接口把依赖抽象化，传入不同对接口的实现可以很好实现对扩展开放的原则。个人理解😺","likes_number":37,"is_delete":false,"is_hidden":false,"ctime":1576916690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1838042,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/0b/da/34be57e8.jpg","nickname":"趣稚鬼👻","note":"","ucode":"8AE6776DCA8541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201308,"discussion_content":"到位","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583769354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":93245,"ip_address":""},"score":201308,"extra":""},{"author":{"id":1033096,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","nickname":"如来神掌","note":"","ucode":"45E20FF935BD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283393,"discussion_content":"优秀👏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592266799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":93245,"ip_address":""},"score":283393,"extra":""}]},{"author":{"id":1237327,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","nickname":"Remember九离","note":"","ucode":"97EE6E6344689F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270800,"discussion_content":"一语中的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590056609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334583,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5d/37/061e7fac.jpg","nickname":"小苗晓雪","note":"","ucode":"B15FDF455853D2","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549680,"discussion_content":"说的非常有道理~学习了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644204279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209027,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584601753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1017181,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","nickname":"程序袁帅","note":"","ucode":"C281CA64EC91A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160777,"discussion_content":"「而“依赖注入”不强调这个，类或接口都可以」这个我有点疑问请教，依赖注入可以注入接口吗？如果可以，接口如何实例化？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580827204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1560281,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ce/d9/e3fc735c.jpg","nickname":"leo","note":"","ucode":"AAF0F90D8A2481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1017181,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","nickname":"程序袁帅","note":"","ucode":"C281CA64EC91A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222794,"discussion_content":"”注入的是接口“，这句话指的只是注入了实现了这个接口（行为）的对象。在程序运行过程中，无论是原先定义的是接口还是类，实际上在这一层都应该是对象，所以不存在实例化的问题（可以认为执行到注入这一层，一定是在某个地方实例化了），运行过程中，Class对象才是描述类或接口信息的。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1586175251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":160777,"ip_address":""},"score":222794,"extra":""}]}]},{"had_liked":false,"id":162035,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1576454046,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"602871875486","product_id":100039001,"comment_content":"区别:<br>1.依赖注入是一种具体编程技巧，关注的是对象创建和类之间关系，目的提高了代码的扩展性，我们可以灵活地替换依赖的类。<br>2.基于接口而非实现编程是一种设计原则，关注抽象和实现，上下游调用稳定性，目的是降低耦合性，提高扩展性。<br><br>联系:<br>都是基于开闭原则思路，提高代码扩展性！","like_count":141,"discussions":[{"author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375735,"discussion_content":"其实依赖注入也是一种基于接口而非实现编程的一种实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621836827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162097,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1576461078,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"452548027158","product_id":100039001,"comment_content":"依赖倒置原则概念是高层次模块不依赖于低层次模块。看似在要求高层次模块，实际上是在规范低层次模块的设计。<br><br>低层次模块提供的接口要足够的抽象、通用，在设计时需要考虑高层次模块的使用种类和场景。<br><br>明明是高层次模块要使用低层次模块，对低层次模块有依赖性。现在反而低层次模块需要根据高层次模块来设计，出现了「倒置」的显现。<br><br>这样设计好处有两点：<br><br>1. 低层次模块更加通用，适用性更广<br>2. 高层次模块没有依赖低层次模块的具体实现，方便低层次模块的替换<br><br>思考题：<br><br>基于接口而非实现编程，是一种指导编码的思想。依赖注入是它的一种具体应用。<br><br>个人理解，仅供参考~","like_count":106,"discussions":[{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289623,"discussion_content":"依赖反转，高层不依赖低层，但也不是说低层就要依赖高层；低层和高层依赖的抽象接口是一种解耦","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1594167788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2528121,"avatar":"https://static001.geekbang.org/account/avatar/00/26/93/79/9efa9c11.jpg","nickname":"星溯","note":"","ucode":"A185ACCDE20723","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363720,"discussion_content":"低层次模块不需要为高层次模块考虑而设计接口，接口（协议）所有权属高层模块，低层只负责实现，才是真正的依赖倒置/反转","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1617269570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286802,"discussion_content":"是的，高层提需求给低层，高层与低层通过接口抽象来调用\n以往是高层依赖于低层(低层具体实现)，缺点：低层变动会影响高层\n从根本上来讲，低层是服务提供方，应该依赖于高层的最终诉求，而这个诉求就是接口抽象","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1593302000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1681459,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a8/33/b71635c1.jpg","nickname":"锋子","note":"","ucode":"89FFA85BDB1C99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321624,"discussion_content":"一样的想法，看到高层不依赖低层次，还有点懵逼，感觉倒过来更像是现实。 但其实这个没啥意义，就是一个说法，知道意思就行了。 感觉是调用方依赖被调用的，被调用的尽量更通用，让上层可以不那么依赖自己。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604598128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062444,"avatar":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","nickname":"小喵喵","note":"","ucode":"FDBBB2A59DB8B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85739,"discussion_content":"在数据结构与算法之美专栏每次总结的都很好，现在又在这里遇见你。也期待每次的总结。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576570750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062444,"avatar":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","nickname":"小喵喵","note":"","ucode":"FDBBB2A59DB8B6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101789,"discussion_content":"争取多总结，一起加油。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577290262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85739,"ip_address":""},"score":101789,"extra":""}]},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269907,"discussion_content":"原文: https://www.cnblogs.com/wod-Y/p/12746794.html\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589960904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1191955,"avatar":"https://static001.geekbang.org/account/avatar/00/12/30/13/d5fe9d3f.jpg","nickname":"memorylose","note":"","ucode":"2C2F61F960B0A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253360,"discussion_content":"精彩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588229853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220617,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","nickname":"Six","note":"","ucode":"E297BB638B2BD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216517,"discussion_content":"兄弟总结的很到位。给你个赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585459504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","nickname":"沐夜星光","note":"","ucode":"22F699E237B179","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114321,"discussion_content":"看文章，还不太明白，什么依赖，怎么反转了，你这一说懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577968510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236569,"avatar":"https://static001.geekbang.org/account/avatar/00/12/de/59/ceea56a9.jpg","nickname":"Nan","note":"","ucode":"A3DEC678BF814D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101217,"discussion_content":"给你点赞，看你评论让我顿悟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577285542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1236569,"avatar":"https://static001.geekbang.org/account/avatar/00/12/de/59/ceea56a9.jpg","nickname":"Nan","note":"","ucode":"A3DEC678BF814D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101790,"discussion_content":"对大家有帮助也是我留言的动力…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577290323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":101217,"ip_address":""},"score":101790,"extra":""}]}]},{"had_liked":false,"id":162052,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1576456677,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"186260050405","product_id":100039001,"comment_content":"1⃣️控制反转是一种编程思想，把控制权交给第三方。依赖注入是实现控制反转最典型的方法。<br>2⃣️依赖注入（对象）的方式要采用“基于接口而非实现编程”的原则，说白了就是依赖倒转。<br>3⃣️低层的实现要符合里氏替换原则。子类的可替换性，使得父类模块或依赖于抽象的高层模块无需修改，实现程序的可扩展性。","like_count":44,"discussions":[{"author":{"id":1838042,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/0b/da/34be57e8.jpg","nickname":"趣稚鬼👻","note":"","ucode":"8AE6776DCA8541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201316,"discussion_content":"第三点还是很✔","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583769481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88646,"discussion_content":"控制反转是上层不依赖下层吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576722611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88663,"discussion_content":"额额，这是是依赖反转(倒转)？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576723469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":88646,"ip_address":""},"score":88663,"extra":""}]}]},{"had_liked":false,"id":171313,"user_name":"Maurice","can_delete":false,"product_type":"c1","uid":1729796,"ip_address":"","ucode":"A35112AA415C67","user_header":"","comment_is_top":false,"comment_ctime":1578900817,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"130427919697","product_id":100039001,"comment_content":"“相对于细节的多变性,抽象的东西要稳定的多”，个人认为吃透这句话就够了。","like_count":31,"discussions":[{"author":{"id":1608383,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","nickname":"X_L～","note":"","ucode":"6BD8C24750F86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368929,"discussion_content":"精辟","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618884117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220713,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a0/69/e42348a8.jpg","nickname":"李奇锋","note":"","ucode":"1A0A359D0530C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363771,"discussion_content":"前提是有一个正确/合理的抽象模型","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617280183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162036,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1576454055,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"117540571047","product_id":100039001,"comment_content":"原来的模式是一个spring开发的项目放在Tomcat中，控制权在Tomcat手中。现在微服务兴起，大家都用springboot开发。此时是Tomcat在springboot项目当中。控制权在springboot手中，虽然只是表面上。这便是控制反转。<br><br>这是一场控制权争夺之战。","like_count":26,"discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83909,"discussion_content":"并非表面，事实就是如此。原本的spring容器需要在web容器初始化好后才装配，现在变成web容器在spring容器初始化时装配。这给予了spring容器初始化更多的权限。脱离寄人篱下的窘境。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1576473410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2336076,"avatar":"https://static001.geekbang.org/account/avatar/00/23/a5/4c/8c225320.jpg","nickname":"Miss陈","note":"","ucode":"C4635B9479963A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330175,"discussion_content":"springboot只是一个自动装配的脚手架，你所说的控制权，依然是在spring框架手上啊，spring通过依赖注入实现对象的管理，springboot只是这些框架的一个零配置工具而已，tomcat服务器也是面向servlet规范开发，你所写的类会被编译成servlet类，你这个表述有点混乱，springboot只是一个jar包而已，里面对框架进行&#34;自动装配&#34;，实现0配置方便使用，对于你开发的应用，控制权一直在spring手中","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606539808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192968,"discussion_content":"纳尼。。。。。？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583113092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252593,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/f1/840ef7f9.jpg","nickname":"KKKKK","note":"","ucode":"E9DAF0FCCE898C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98356,"discussion_content":"一个是运行容器 一个是开发框架 这两个有必然联系吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577156902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1482915,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","nickname":"业余爱好者","note":"","ucode":"A890935A982988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252593,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/f1/840ef7f9.jpg","nickname":"KKKKK","note":"","ucode":"E9DAF0FCCE898C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98379,"discussion_content":"都是容器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577159032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":98356,"ip_address":""},"score":98379,"extra":""}]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88344,"discussion_content":"Springboot.  Web项目不还是离不开web容器吗，只是内嵌了而已,它还是活在web容器的“阴影”里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576704713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83720,"discussion_content":"真的是这样么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576459754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1482915,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","nickname":"业余爱好者","note":"","ucode":"A890935A982988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":83836,"discussion_content":"表面上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576468571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83720,"ip_address":""},"score":83836,"extra":""}]}]},{"had_liked":false,"id":162829,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1576597544,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"96065878056","product_id":100039001,"comment_content":"课堂讨论：这两个概念没什么关系，讲的不是一个事。依赖注入讲的是一个对象如何获得它运行所依赖的对象，所谓依赖注入就是不需要自己去new，让框架注入进来；基于接口而不是实现编程讲的是抽象思维的应用，利用编程，可以屏蔽掉底层具体实现改变导致上层改变的问题。<br><br>文中的那个例子，只是恰好同时使用了依赖注入这个编程技巧，同时也实践了基于接口而非实现编程这个原则。","like_count":23,"discussions":[{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337681,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609040737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162371,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1341964,"ip_address":"","ucode":"88440A9C773832","user_header":"https://static001.geekbang.org/account/avatar/00/14/7a/0c/5abd1cf9.jpg","comment_is_top":false,"comment_ctime":1576505495,"is_pvip":false,"replies":[{"id":"62282","content":"tomcat的例子不算啊","user_name":"作者回复","comment_id":162371,"uid":"1190123","ip_address":"","utype":1,"ctime":1576804038,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"87475851415","product_id":100039001,"comment_content":"DIP原则有点嘎然而止的感觉，缺少了一个具体的例子。","like_count":20,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478031,"discussion_content":"tomcat的例子不算啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576804038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385841,"discussion_content":"你细品，前面旁敲侧击，最后一个类比概括，还不够精彩吗？跟作文倒叙一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627296019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2254854,"avatar":"https://static001.geekbang.org/account/avatar/00/22/68/06/e74b5675.jpg","nickname":"存在","note":"","ucode":"F3217DC5B799BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587509,"discussion_content":"JDBC其实也是一种DIP原则，各个数据库厂商自行实现驱动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663120546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162010,"user_name":"KIM","can_delete":false,"product_type":"c1","uid":1113766,"ip_address":"","ucode":"189216730D37F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/a6/bb3d76e6.jpg","comment_is_top":false,"comment_ctime":1576429066,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"70295905802","product_id":100039001,"comment_content":"感觉比head first设计模式讲的清晰","like_count":16,"discussions":[{"author":{"id":1476665,"avatar":"https://static001.geekbang.org/account/avatar/00/16/88/39/d420a588.jpg","nickname":"小马过河","note":"","ucode":"89451C0545EA11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284460,"discussion_content":"head first博大精深，需要反复食用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592537321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190170,"avatar":"https://static001.geekbang.org/account/avatar/00/12/29/1a/87f11f3d.jpg","nickname":"JackPn","note":"","ucode":"0A207AF8D39F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115376,"discussion_content":"head First讲的是实战，这个专栏截至目前基本都是理论，没法比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578013071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1590154,"avatar":"","nickname":"Geek_ed366d","note":"","ucode":"EADF432AE2DA79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190170,"avatar":"https://static001.geekbang.org/account/avatar/00/12/29/1a/87f11f3d.jpg","nickname":"JackPn","note":"","ucode":"0A207AF8D39F76","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287703,"discussion_content":"这里实战更多啊\n比如这一个个例子，都是业务开发的真实场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593513614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":115376,"ip_address":""},"score":287703,"extra":""}]},{"author":{"id":1464006,"avatar":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","nickname":"斐波那契","note":"","ucode":"85E2EBC01392B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98477,"discussion_content":"我也看head first这本书 head first主要是用轻松的方式循序渐进地介绍设计模式 而这里就是更细节地讲解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577165945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93246,"discussion_content":"啊是吗？😹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576916734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252160,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1602151134,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"57436725982","product_id":100039001,"comment_content":"从 Notification 这个例子来看，“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？<br>A：依赖注入是一种具体编码技巧，其主要目的有两点：<br>1.\t将依赖关系建立的位置，从类的内部向上移动到类的入口（构造函数，或非构造函数的其他方法的参数），或者放到框架层面来支持（框架支持依赖关系的配置，对象创建，管理对象声明周期——根据对象被引用的记数实现）。<br>2.\t通过改变依赖关系建立的位置，将创建被依赖对象的任务移动到类的外部，从而简化了类的作者的负担：一方面是创建对象的负担，另一方面是管理依赖的负担<br>“基于接口而非实现编程“是一种编程原则，通过接口引入中间层，实现依赖关系的解耦。这是一个非常宽泛的原则，可以细化为多项原则，比如接口隔离原则（强调接口的功能单一特性，即通过分解支持功能的灵活细粒度扩展），里氏替换原则（强调接口的行为一致性，保证接口上层代码逻辑的简单性），开闭原则（强调接口的抽象特性，即通过多态特性实现功能的扩展）。<br>用一句话来概括：“基于接口而非实现编程”是让依赖变弱，而“依赖注入”是让依赖转移，两者相互补充，可以方便的结合起来使用。","like_count":13,"discussions":[{"author":{"id":2323679,"avatar":"https://static001.geekbang.org/account/avatar/00/23/74/df/6c4c970c.jpg","nickname":"刘胜","note":"","ucode":"2ED796A94E1C8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328110,"discussion_content":"你这个才是解释最清楚的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606057141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162058,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1576457195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35936195563","product_id":100039001,"comment_content":"区别:<br>基于接口而非实现编程:是面向对象编程的一种方式.减少对外部的依赖,还可以提升代码的灵活性,扩展及修改时可以控制风险的传播,符合开闭原则.<br>依赖注入:是一种具体的编码技巧,属于编程规范的范畴.不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。<br>联系:<br>两者结合在一起可以实现代码的灵活性,减少对外部的依赖,提升代码的可维护性&#47;可扩展性.<br>课外感想:<br>非常喜欢王争老师这样有深度内涵的课程,概念理解深入透彻,宏观方向把握准确,跟着老师的课程更有信心去挑战阿里这样一流企业的工作.报告老师,我归队了.","like_count":8},{"had_liked":false,"id":162162,"user_name":"帆大肚子","can_delete":false,"product_type":"c1","uid":1529040,"ip_address":"","ucode":"3DB11DB2FA1802","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/d0/4e1fc664.jpg","comment_is_top":false,"comment_ctime":1576468665,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31641239737","product_id":100039001,"comment_content":"在我看来，“依赖注入”是“基于接口而非实现编程”的一个实践。<br>“基于接口而非实现编程”是一条设计原则，可以帮助我们诞生更多类似于“依赖注入”的实践","like_count":7,"discussions":[{"author":{"id":2162521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MaX06SRk19zM2lAaymYylpXD6LMtIPFlDyxZKgRhmZCjhNE4nIdDGBmh08razhebVCgAv54xialYBBIIwmleBew/132","nickname":"Geek_6d1382","note":"","ucode":"B61E65CFEB684F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312457,"discussion_content":"同感哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602689756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175774,"user_name":"程序袁帅","can_delete":false,"product_type":"c1","uid":1017181,"ip_address":"","ucode":"C281CA64EC91A7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","comment_is_top":false,"comment_ctime":1580826473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27350630249","product_id":100039001,"comment_content":"基于接口中的接口不是特指是编程语言中的接口，代表的是抽象。<br><br>1. 面向抽象编程，它强调的核心是抽象思维，解决的核心问题是程序的可扩展性。<br>2. 依赖注入，它强调的核心对象的管理，解决的核心问题释放程序员生产力，程序员不用花太多经历管理琐碎的对象创建和生命周期管理，将精力花在具有价值的业务上。","like_count":6},{"had_liked":false,"id":162142,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1576466354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27346270130","product_id":100039001,"comment_content":"控制反转：控制指的是程序流程的控制，反转是指程序的流程的控制权由程序员转移到框架<br>依赖注入：上层类依赖底层类执行业务，以前往往将底层类作为上层类的成员变量，在上层类的内部声明底层类。注入就是底层类在外边声明，通过接口的方式注入到上层类中<br>依赖反转原则：我的理解是模块的解耦。上层模块依赖于低等模块，通过抽象出一套规则或者接口，使得上层业务依赖于抽象规则，低层业务实现规则。<br><br>我觉得基于接口编程与依赖反转原则比较类似，区别的话，依赖反转原则，依赖的不一定非得是接口，也许是一套规则，比如老师举的tomcat与java服务的例子","like_count":5},{"had_liked":false,"id":162032,"user_name":"progyoung","can_delete":false,"product_type":"c1","uid":1014692,"ip_address":"","ucode":"0B4898AE78F9F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/a4/24955994.jpg","comment_is_top":false,"comment_ctime":1576453389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27346257165","product_id":100039001,"comment_content":"依赖注入标价 25 美元，实际上只值 5 美分。形象啊，不能被貌似高大上的概念给唬住了，产生畏难心理。","like_count":6},{"had_liked":false,"id":178302,"user_name":"木子00","can_delete":false,"product_type":"c1","uid":1314724,"ip_address":"","ucode":"8F78CA722EB29B","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","comment_is_top":false,"comment_ctime":1581655277,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"23056491757","product_id":100039001,"comment_content":"还是没有彻底搞懂!!!<br>只是懂了文字上.","like_count":5,"discussions":[{"author":{"id":1015189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","nickname":"我是曾经那个少年","note":"","ucode":"9F02F7FF147D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396022,"discussion_content":"想想JDBC规范和Servlet规范EJB规范这些就明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632382212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020529,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/71/9fd7cd7a.jpg","nickname":"Daniel","note":"","ucode":"282E09B3146501","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365050,"discussion_content":"随着工程项目多了，就好理解了，我都是通过之前工程经验去理解今天的课，就很好理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617694673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2234620,"avatar":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","nickname":"江南一笑","note":"","ucode":"E38938A1178827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336858,"discussion_content":"课程确实抽象了，只能在项目中慢慢理解了。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608717497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162000,"user_name":"MindController","can_delete":false,"product_type":"c1","uid":1159113,"ip_address":"","ucode":"3B9CECCD12CF6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/c9/d9c72c60.jpg","comment_is_top":false,"comment_ctime":1576427247,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23051263727","product_id":100039001,"comment_content":"深夜打卡","like_count":5,"discussions":[{"author":{"id":1466447,"avatar":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","nickname":"Daiver","note":"","ucode":"9B1A03AFBC79BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83570,"discussion_content":"共同点：二者的存在都是为了解耦。二者的区别：基于接口编程是最重要的就是可扩展性；而依赖注入托管了对象的生命周期，依赖注入有运行时 注入和编译时注入；从spring的依赖注入来说，它不仅有着了依赖注入作用，同时也包含了面向接口编程。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576430120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162060,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1576457260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18756326444","product_id":100039001,"comment_content":"这个专栏确实讲解的非常细致！争哥确实是用心做专栏！以前对很多类似的概念都没理解透彻，通过这个专栏完全明白了！","like_count":4},{"had_liked":false,"id":162020,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576443783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18756312967","product_id":100039001,"comment_content":"控制反转的本质是分拆控制代码和具体执行代码，控制代码放在较高的层次上，也可能交给第三方类库，实现代码放在较低的层次上，通常是一个接口的实现。<br><br>依赖反转本质是分拆类中的new语句，因为new语句引入了对实现类构造函数的依赖，属于很强的依赖。分拆之后构造和实现放在另外一个类里（通常交给第三方类库），使用的地方引用接口。依赖反转可以拆分类的依赖关系，可以减少实现类的引用，用接口取代，实现接口和实现的分离。依赖反转和基于接口而非实现的原则类似，两者都倾向于依赖接口而非具体类。不同点在于，前者更关注类层次中的依赖关系以及对构造函数的依赖，尽量避免高层次的类依赖底层的实现，尽量避免对构造函数的依赖。后者，更强调类的使用的地方，尽量使用更抽象更宽泛的接口，而非更具体更细节的实现，使得信息隐藏和抽象。<br><br>控制反转和依赖反转都是有成本的，会破坏代码的内聚性和简洁性，需要权衡使用。<br>","like_count":4},{"had_liked":false,"id":219031,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1589935458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14474837346","product_id":100039001,"comment_content":"这句话没理解，这句话强调的是对”流程”控制的反转(比如使用模板方法设计模式)，但是依赖注入是怎么实现流程控制的反转的？从老师的例子上没有看出来，依赖注入只是把对象创建的权利交给了框架，而不是流程控制权利。<br><br>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。<br><br>","like_count":3},{"had_liked":false,"id":286368,"user_name":"星溯","can_delete":false,"product_type":"c1","uid":2528121,"ip_address":"","ucode":"A185ACCDE20723","user_header":"https://static001.geekbang.org/account/avatar/00/26/93/79/9efa9c11.jpg","comment_is_top":false,"comment_ctime":1617269468,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10207204060","product_id":100039001,"comment_content":"感觉还是依赖倒置这个翻译更为合适<br>还有最关键的一点感觉老师可以展开讲解的是：依赖倒置的精髓，在于接口&#47;抽象所有权的倒置，高层不依赖低层，其实需要把低层的能力&#47;协议抽象成接口，并且接口所有权属于高层，这样就能真正做到对高层的复用，而不依赖低层的实现细节，如果只是高层依赖低层的抽象&#47;接口，那不是真正的依赖倒置。<br>可以结合好莱坞原则“Dont call me, I will call you”来理解，应用程序不需要调用Tomcat&#47;Spring这样的框架来实现什么交互，而是由Tomcat&#47;Spring拥有协议，应用程序实现此协议（比如实现Servlet接口），来完成交互","like_count":3,"discussions":[{"author":{"id":2415980,"avatar":"","nickname":"Geek_9bd83c","note":"","ucode":"0CACC79030FCBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590717,"discussion_content":"接口由高层定义。\n如果由底层定义，那底层可以修改约定接口……但是这个改动权限就是应该高层来决定的，底层只负责实现细节。\n解决了我一直以来的疑惑！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666035346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224060,"user_name":"奥利奥，晴天。","can_delete":false,"product_type":"c1","uid":1478996,"ip_address":"","ucode":"9CA5E2C3C2D054","user_header":"https://static001.geekbang.org/account/avatar/00/16/91/54/007a667e.jpg","comment_is_top":false,"comment_ctime":1591264005,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10181198597","product_id":100039001,"comment_content":"依赖注入的方式 特别好，结合开闭原则，很容易写出可测试的代码，以前写go语言，写个单元测试，引入数据库配置，引入配置文件，非常难测试，后来学了依赖注入这个东西，感觉代码测试，清爽干净简单了。。。","like_count":3},{"had_liked":false,"id":174299,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1580127663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10170062255","product_id":100039001,"comment_content":"基于接口而非实现编程偏向于类的实现方式，表示某个类要服从特定的契约<br>依赖注入偏向于类的管理方式，通过配置来管理类的加载","like_count":2},{"had_liked":false,"id":162011,"user_name":"iLeGeND","can_delete":false,"product_type":"c1","uid":1055475,"ip_address":"","ucode":"4055A628A6E97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","comment_is_top":false,"comment_ctime":1576429352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166363944","product_id":100039001,"comment_content":"有收获","like_count":2},{"had_liked":false,"id":283900,"user_name":"佐镜兄","can_delete":false,"product_type":"c1","uid":1062804,"ip_address":"","ucode":"18DB653A028632","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/94/723ec0e9.jpg","comment_is_top":false,"comment_ctime":1615977250,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5910944546","product_id":100039001,"comment_content":"依赖反转原则感觉还是很迷惑，上层代码不依赖底层？那上层如何调用底层？","like_count":1,"discussions":[{"author":{"id":1813614,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/ac/6e/c13d131c.jpg","nickname":"她微笑的脸y","note":"","ucode":"E3B559B10B4A70","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530713,"discussion_content":"依赖同一个抽象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637132730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415980,"avatar":"","nickname":"Geek_9bd83c","note":"","ucode":"0CACC79030FCBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590716,"discussion_content":"上层定义约定接口，只调用接口。\n底层实现接口具体逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666035120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010796,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6c/6c/abb7bfe3.jpg","nickname":"我是谁","note":"","ucode":"2362EABBFFF7C2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542992,"discussion_content":"感觉较真起来还是要依赖于底层，只不过这个上层代码只使用了这个抽象/接口，而不是直接使用底层类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640925074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193563,"user_name":"PCMD","can_delete":false,"product_type":"c1","uid":1842844,"ip_address":"","ucode":"76A1106F42AEAC","user_header":"https://static001.geekbang.org/account/avatar/00/1c/1e/9c/39f5ff2a.jpg","comment_is_top":false,"comment_ctime":1584927703,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5879894999","product_id":100039001,"comment_content":"基于接口而非实现编程,和依赖注入，其实都可以算是依赖注入。<br>可以看文中的定义 &quot;我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。&quot;  其实都是一样，只不过在 基于接口而非实现编程 更多的体现了可扩展性，体现了开放原则。并且，最终注入的也是 该接口的实现，而非单一的接口 <br>自我认为","like_count":1},{"had_liked":false,"id":181256,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582527972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877495268","product_id":100039001,"comment_content":"文中同样提到了依赖注入是一种编程技巧,是指的是对于其他类的依赖不要在类中进行new来生成,而是通过构造方法,函数参数注入进来,但没有直接说明构造函数或者参数注入进来的是一个抽象的类或者接口,其也可以注入一个实现类.但是为了保证使用抽象的思想,一般会注入接口或者抽象类,提高代码可维护性,而基于接口而非实现编程,其本质也是为了使用抽象的思想,提高代码的可维护性","like_count":1},{"had_liked":false,"id":167117,"user_name":"至今未来","can_delete":false,"product_type":"c1","uid":1632716,"ip_address":"","ucode":"ED6F557FDB0B5B","user_header":"https://static001.geekbang.org/account/avatar/00/18/e9/cc/1eb3120e.jpg","comment_is_top":false,"comment_ctime":1577694168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872661464","product_id":100039001,"comment_content":"依赖注入是种编码技巧 来提高扩展性（巧妙的构建数据流）<br>基于接口而非实现编程 是利用编程语言提供的多态属性来提高扩展性（利用编程语言自身的结构属性-多态）","like_count":1},{"had_liked":false,"id":163284,"user_name":"|･ω･｀)","can_delete":false,"product_type":"c1","uid":1636123,"ip_address":"","ucode":"34E1DF62058D80","user_header":"https://static001.geekbang.org/account/avatar/00/18/f7/1b/8036958c.jpg","comment_is_top":false,"comment_ctime":1576679815,"is_pvip":false,"replies":[{"id":"62268","content":"你网上搜下 开关的例子 那个更简单","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1576797213,"ip_address":"","comment_id":163284,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871647111","product_id":100039001,"comment_content":"关于最后一个依赖反转能再举个简单的代码例子吗？Tomcat的案例没懂˙Ⱉ˙ฅ","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478329,"discussion_content":"你网上搜下 开关的例子 那个更简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576797213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162705,"user_name":"阿顺","can_delete":false,"product_type":"c1","uid":1698258,"ip_address":"","ucode":"36F2AD6F980B11","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","comment_is_top":false,"comment_ctime":1576579334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871546630","product_id":100039001,"comment_content":"区别：依赖注入是不是使用的是多态的特性，基于接口而非实现编程使用了抽象的性，对吗","like_count":1},{"had_liked":false,"id":162610,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1576565000,"is_pvip":false,"replies":[{"id":"62281","content":"周一三五更新的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1576803528,"ip_address":"","comment_id":162610,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871532296","product_id":100039001,"comment_content":"老师，今天怎么没更新，我已经迫不及待了。隔壁那本DDD好多词汇难理解，我受了打击，过来找安慰。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478103,"discussion_content":"周一三五更新的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576803528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162390,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1576508157,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5871475453","product_id":100039001,"comment_content":"基于接口而非实现编程（依赖倒置原则）: 高层和低层组件都使用了一样的接口，然后让接口去控制整个逻辑，这样高层组件就不会依赖于具体的低层组件实现。简单来讲，就是大家都用接口，彼此不认识。<br>依赖注入：依赖注入就是一个组件内部依赖一个对象，但是他不自己造，等别人送上来。<br>他们俩的关系就是，在依赖倒置原则指导下的设计里，组件都没有内部创造依赖的对象，全是通过外部传入的，但是也不一定是注入，有可能只是个过客（传进去用完就扔），而且注入的时候，都是以接口的形式注入的，而依赖注入并不一定是接口。","like_count":1},{"had_liked":false,"id":162316,"user_name":"再见孙悟空","can_delete":false,"product_type":"c1","uid":1025518,"ip_address":"","ucode":"57E12A2F9CD915","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/ee/6bbac848.jpg","comment_is_top":false,"comment_ctime":1576499295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871466591","product_id":100039001,"comment_content":"“基于接口而非实现编程” 和 “依赖注入” <br><br>联系 ：<br>都能实现注入功能，程序依赖的对象都能在外部事先创建而无需程序内部显示 new 。<br><br>区别：<br>“基于接口而非实现编程” 可以看作是 “依赖注入” 的一种实现方式。除了构造方法注入外，依赖注入还包括 setter 方法注入。","like_count":1},{"had_liked":false,"id":162212,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1576477893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871445189","product_id":100039001,"comment_content":"Ioc样例代码那里,抽象类TestCase 的doTest方法 应该返回布鲁尔值,而不是void","like_count":1},{"had_liked":false,"id":162147,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1576466848,"is_pvip":false,"replies":[{"id":"62285","content":"d是dip 不是lod的 lod后面有讲到","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1576804341,"ip_address":"","comment_id":162147,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871434144","product_id":100039001,"comment_content":"SOLID 的最后一个原则D，我看好多书上说是 迪米特法则 啊，为什么文章里没有提呢？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477967,"discussion_content":"d是dip 不是lod的 lod后面有讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576804341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162119,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1576463476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871430772","product_id":100039001,"comment_content":"设计模式_19<br># 作业<br>“基于接口而非实现编程”: 是一种设计原则。<br>“依赖注入”: 一种对上面原则的应用。<br><br># 感想：<br>今天的内容，一定程度上是对前面基础原则的组合式实践。<br>在依赖反转原则里，<br>“具体实现依赖抽象”，是对“基于接口而非实现编程”的实践。<br>比如“高层模块不要依赖低层模块”，是“开闭原则”的实践。<br><br>像“单一职责”、“开闭原则”等的底层原则，我们都能理解它的“字面含义”，但真正掌握它要更多的实践和更丰富的信息量，这是我理解的，为什么还要继续讲基于基础原则的实践。","like_count":1},{"had_liked":false,"id":162067,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1576457875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871425171","product_id":100039001,"comment_content":"感觉依赖反转原则是不是可以叫“依赖抽象原则”？😂，从字面意思来看我觉得可以翻译成:高层模块和低层模块及实现细节都应依赖于抽象。","like_count":1},{"had_liked":false,"id":162031,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1576452790,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5871420086","product_id":100039001,"comment_content":"区别就是依赖注入属于框架层面，接口编程属于实现层面","like_count":1},{"had_liked":false,"id":162018,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1576438625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871405921","product_id":100039001,"comment_content":"课后讨论问题正是我的疑惑😦","like_count":1},{"had_liked":false,"id":357717,"user_name":"徐志超-Klaus","can_delete":false,"product_type":"c1","uid":2343086,"ip_address":"北京","ucode":"CF26B39965F2A2","user_header":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","comment_is_top":false,"comment_ctime":1663578509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663578509","product_id":100039001,"comment_content":"可惜了，依赖反转没有小例子","like_count":0},{"had_liked":false,"id":357040,"user_name":"Geek_0d2e85","can_delete":false,"product_type":"c1","uid":2882738,"ip_address":"浙江","ucode":"D0E64BB92C6223","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKwRibg8Y6J3BQsFfyboA5Px6ibx3iaerK3ia53XiavSJQ3quO7MxdFI9pwEACurR13MkuDTNnMurBqydA/132","comment_is_top":false,"comment_ctime":1662882163,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1662882163","product_id":100039001,"comment_content":"一句话总结：控制反转要通过依赖注入来实现，而依赖注入过程中又要展现了依赖反转","like_count":0},{"had_liked":false,"id":356053,"user_name":"Geek_1","can_delete":false,"product_type":"c1","uid":2704407,"ip_address":"北京","ucode":"59300A73996D20","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/17/e4fdcaad.jpg","comment_is_top":false,"comment_ctime":1661937197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661937197","product_id":100039001,"comment_content":"高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象","like_count":0},{"had_liked":false,"id":354409,"user_name":"泽韦德","can_delete":false,"product_type":"c1","uid":1103888,"ip_address":"浙江","ucode":"948E7B067A3786","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/10/5173922c.jpg","comment_is_top":false,"comment_ctime":1660373249,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1660373249","product_id":100039001,"comment_content":"基于接口编程和依赖注入都是控制反转的表现形式，依赖注入不一定要基于接口注入，也可以基于实现类注入。基于接口编程应用范围比依赖注入范围广。","like_count":0},{"had_liked":false,"id":351594,"user_name":"zhaoxb","can_delete":false,"product_type":"c1","uid":1686527,"ip_address":"","ucode":"A392B6A3DE98B7","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/ff/86ac9581.jpg","comment_is_top":false,"comment_ctime":1657971369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657971369","product_id":100039001,"comment_content":"依赖注入在更高的层面将对象和对象的使用者解耦，使得调用者可以根据场景灵活的替换对象，而无需修改自身的代码；<br>基于接口编程，是实现依赖注入的一种手段，例如我们完全可以通过继承也能实现依赖注入需要的解耦；<br>但基于接口编程更好，因为它更纯粹，强调了调用者需要什么行为，只提供实现了这种行为的具体类给调用者即可，不需要关心更其他细节。","like_count":0},{"had_liked":false,"id":347517,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1654101379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654101379","product_id":100039001,"comment_content":"1.依赖注入是管理成员变量对象使用外部导入，不要硬编码，比如创建数据库连接<br>2.接口而非实现是面相接口编程，接口更加稳定，更加灵活，代码可以测试，","like_count":0},{"had_liked":false,"id":343352,"user_name":"Geek_天涯tobe","can_delete":false,"product_type":"c1","uid":2354145,"ip_address":"","ucode":"8C95EE164CAB70","user_header":"https://static001.geekbang.org/account/avatar/00/23/eb/e1/71bb3704.jpg","comment_is_top":false,"comment_ctime":1650795804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650795804","product_id":100039001,"comment_content":"Tomcat 这个例子在第几章","like_count":0},{"had_liked":false,"id":343206,"user_name":"Morty","can_delete":false,"product_type":"c1","uid":1026658,"ip_address":"","ucode":"C2E532741F99E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/62/78b45741.jpg","comment_is_top":false,"comment_ctime":1650706937,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650706937","product_id":100039001,"comment_content":"补充个具体的例子：<br>https:&#47;&#47;www.digitalocean.com&#47;community&#47;conceptual_articles&#47;s-o-l-i-d-the-first-five-principles-of-object-oriented-design#dependency-inversion-principle","like_count":0},{"had_liked":false,"id":342029,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1649984725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649984725","product_id":100039001,"comment_content":"“依赖注入” 更多描述的是一种编程技巧不在乎注入的是接口还是具体的实现类，<br>基于&quot;接口而非实现编程&quot;更多描述的是一种规范。这种规范关注的对象就是接口，编程的时候基于接口，可以提高代码的拓展性。符合开闭原则，对于不同的需求使用不同的接口的实现类；同时我们的编程只依赖了必要的接口 符合迪米特法则（LOD）","like_count":0},{"had_liked":false,"id":341961,"user_name":"Scorpion 刘波","can_delete":false,"product_type":"c1","uid":1609667,"ip_address":"","ucode":"DF60BC39EA8B56","user_header":"https://static001.geekbang.org/account/avatar/00/18/8f/c3/02801527.jpg","comment_is_top":false,"comment_ctime":1649932510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649932510","product_id":100039001,"comment_content":"看了三遍不知道说的啥，直到我百度了一下看到这篇，我悟了 https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;33492169","like_count":0},{"had_liked":false,"id":332454,"user_name":"Lingo","can_delete":false,"product_type":"c1","uid":1075334,"ip_address":"","ucode":"82ECA2E0533B78","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/86/348be7f8.jpg","comment_is_top":false,"comment_ctime":1643261999,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1643261999","product_id":100039001,"comment_content":"现实生活中的控制反转：<br><br>1⃣️智能家居都接入天猫精灵，给天猫精灵输入控制流程，这样给天猫精灵一个指令，它帮你完成多个任务。<br><br>2⃣️苹果手机中的【快捷指令】应用","like_count":0},{"had_liked":false,"id":332453,"user_name":"Lingo","can_delete":false,"product_type":"c1","uid":1075334,"ip_address":"","ucode":"82ECA2E0533B78","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/86/348be7f8.jpg","comment_is_top":false,"comment_ctime":1643261435,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1643261435","product_id":100039001,"comment_content":"🌟什么是控制反转？<br><br>😢控制反转之前：<br><br>今天张三去肯德基吃了个汉堡<br>明天李四去必胜客吃了个披萨<br>……<br><br>😄控制反转之后：<br><br>框架代码：【某时】【某人】去【某处】吃了【谋食物】<br><br>客服端代码：<br>某时=今天<br>某人=张三<br>某处=肯德基<br>某食物=汉堡<br><br>💡流程控制本来在程序员，现在反转给了框架代码。<br><br>🌹好处：<br>降低了程序员出错的概率。<br>降低了当程序员的门槛。<br>规范化了流程控制逻辑。<br><br>Spring框架声称自己是一个控制反转容器。","like_count":0},{"had_liked":false,"id":330576,"user_name":"小吉他","can_delete":false,"product_type":"c1","uid":2691377,"ip_address":"","ucode":"8B69721EA847BA","user_header":"https://static001.geekbang.org/account/avatar/00/29/11/31/278e7fe1.jpg","comment_is_top":false,"comment_ctime":1642054428,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1642054428","product_id":100039001,"comment_content":"控制反转：原先由程序员控制，现在反转给框架<br>依赖注入：不直接New，而是采用构成函数、函数参数获取对象<br>依赖反转：高层不依赖底层，而应该依赖一个共同的抽象；抽象不依赖实现细节，细节依赖抽象","like_count":0},{"had_liked":false,"id":329148,"user_name":"Geek_08733c","can_delete":false,"product_type":"c1","uid":2411555,"ip_address":"","ucode":"9EE5A78C35DBB1","user_header":"","comment_is_top":false,"comment_ctime":1641181228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641181228","product_id":100039001,"comment_content":"这一篇讲的太好了，老师有货","like_count":0},{"had_liked":false,"id":325913,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1639228666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639228666","product_id":100039001,"comment_content":"思考题：“基于接口编程而非实现编程”与“依赖注入”的区别与联系<br>1.两者的区别：基于接口编程而非实现编程，是一种设计思想，强调的是程序中应尽量引用接口对象，而非具体实现接口的对象，强调实现对象对程序透明；依赖注入则是一种编程技巧，强调程序依赖的对象通过外部传入，但并没有强制规定必须传递接口对象还是实现对象，依赖注入强调的是尽量使被引用的对象可被灵活的替换；<br>2.两者的共同点都是为了增加程序的可扩展性，都是通过替换依赖对象来实现，基于接口编程而非实现编程可以看成是依赖注入的一种特殊形式。","like_count":0},{"had_liked":false,"id":324181,"user_name":"🤔","can_delete":false,"product_type":"c1","uid":2712441,"ip_address":"","ucode":"600A071D843A17","user_header":"https://static001.geekbang.org/account/avatar/00/29/63/79/0e88b04f.jpg","comment_is_top":false,"comment_ctime":1638327917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638327917","product_id":100039001,"comment_content":"我觉得这里的依赖反转要是能讲讲反转一词如何理解就好了","like_count":0},{"had_liked":false,"id":322790,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637588853,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637588853","product_id":100039001,"comment_content":"依赖注入更侧重于规范上下游的行为。一个完整的逻辑过程中，需要请求方和被调用方，存在业务上游和业务下游。上下游都需要遵循的规范行为就是依赖注入编程。","like_count":0},{"had_liked":false,"id":322789,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637588760,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637588760","product_id":100039001,"comment_content":"最明显的区别面向接口只是约束一方的行为，","like_count":0},{"had_liked":false,"id":322280,"user_name":"二小","can_delete":false,"product_type":"c1","uid":1593919,"ip_address":"","ucode":"5377CB552237B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/3f/c8b40efe.jpg","comment_is_top":false,"comment_ctime":1637287654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637287654","product_id":100039001,"comment_content":"若是依据上面对控制反转的定义，那么，依赖注入其实并不是控制反转吧，依赖注入框架才是控制反转","like_count":0},{"had_liked":false,"id":320572,"user_name":"黄钰宸","can_delete":false,"product_type":"c1","uid":2719989,"ip_address":"","ucode":"A79A37F1DC6040","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJFPECFrx6sL90QB3SVeKjMOZibic4Wp09qcH4G8hK9uuGomGU8ElTrOprs7KuMVUUYRcP4fjze8o2w/132","comment_is_top":false,"comment_ctime":1636383116,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636383116","product_id":100039001,"comment_content":"对于课后习题的解答：在我看来，基于接口而非实现编程主要是：将易变的逻辑封装起来，暴露稳定的抽象方法，供稳定的主流程调用，所以这个易变的逻辑需要作为参数传递进主逻辑只能利用多态特性，将参数设置为接口或抽象类；而依赖注入就是解决了这个参数的创建流程；依赖注入是【给】，而基于接口而非实现是【用】。","like_count":0},{"had_liked":false,"id":317766,"user_name":"jk001","can_delete":false,"product_type":"c1","uid":2812934,"ip_address":"","ucode":"FF1E3A2883E8D9","user_header":"https://static001.geekbang.org/account/avatar/00/2a/ec/06/4494ecde.jpg","comment_is_top":false,"comment_ctime":1634954600,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1634954600","product_id":100039001,"comment_content":"面向接口编程是依赖倒置的一种手段。","like_count":0},{"had_liked":false,"id":314713,"user_name":"振振","can_delete":false,"product_type":"c1","uid":1313365,"ip_address":"","ucode":"ECE08186230140","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/55/5e440425.jpg","comment_is_top":false,"comment_ctime":1633343209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633343209","product_id":100039001,"comment_content":"依赖倒置 dip 个人理解：简单了说就是少用基类多用接口；往高了说就是框架设计时面向接口或者协议设计。希望作者给点回复，因为这一点讲的太抽象了","like_count":0},{"had_liked":false,"id":314712,"user_name":"振振","can_delete":false,"product_type":"c1","uid":1313365,"ip_address":"","ucode":"ECE08186230140","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/55/5e440425.jpg","comment_is_top":false,"comment_ctime":1633342951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633342951","product_id":100039001,"comment_content":"依赖反转太难理解了，太烦泛化了","like_count":0},{"had_liked":false,"id":313336,"user_name":"我是曾经那个少年","can_delete":false,"product_type":"c1","uid":1015189,"ip_address":"","ucode":"9F02F7FF147D14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","comment_is_top":false,"comment_ctime":1632382180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632382180","product_id":100039001,"comment_content":"这个不能用我们一般的业务代码去套依赖反转的例子。 我们的业务代码高模块肯定是依赖低模块，去调用。<br><br>跟应该考虑中间件去考虑。<br>例如JDBC规范，Java操作数据库不需要关注具体的数据库的连接查询细节。<br>Servlet规范，Web应用不需要关注具体的应用服务器等规范都是这种思想。","like_count":0},{"had_liked":false,"id":312908,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1632114375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632114375","product_id":100039001,"comment_content":"控制反转，依赖注入，依赖反转。<br>前两个好理解，程序流程的控制权交给框架非程序员，在外面生成好对象后通过构造方法传入另一个对象使用。<br>依赖反转，正常的都是高层依赖底层，现在改为都依赖一个抽象来实现链接","like_count":0},{"had_liked":false,"id":312134,"user_name":"王也","can_delete":false,"product_type":"c1","uid":1133206,"ip_address":"","ucode":"9EA69B51ECC99F","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/96/8756eaa2.jpg","comment_is_top":false,"comment_ctime":1631634293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631634293","product_id":100039001,"comment_content":"理解的是真牛逼啊。","like_count":0},{"had_liked":false,"id":309077,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1629936198,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1629936198","product_id":100039001,"comment_content":"依赖的是接口，注入的是实现","like_count":0},{"had_liked":false,"id":308758,"user_name":"小周","can_delete":false,"product_type":"c1","uid":2453498,"ip_address":"","ucode":"7ED7BC27A46C4C","user_header":"https://static001.geekbang.org/account/avatar/00/25/6f/fa/615a0df3.jpg","comment_is_top":false,"comment_ctime":1629788161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629788161","product_id":100039001,"comment_content":"基于接口而非实现编程是一种设计思想，封装具体实现，暴露稳定的接口。依赖注入是一种具体的编码技巧，它并不是在类中new类依赖的对象，而是在外面new完之后，通过构造函数或者方法传参等方式将其设置到类中。它们都能够提高代码的扩展性和灵活性","like_count":0},{"had_liked":false,"id":307138,"user_name":"易飞","can_delete":false,"product_type":"c1","uid":2630424,"ip_address":"","ucode":"32AC28754237F7","user_header":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","comment_is_top":false,"comment_ctime":1628905678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628905678","product_id":100039001,"comment_content":"感觉看懂了，又好像没看懂","like_count":0},{"had_liked":false,"id":301498,"user_name":"乔帆 Kayla","can_delete":false,"product_type":"c1","uid":1883514,"ip_address":"","ucode":"81944832230BC4","user_header":"https://static001.geekbang.org/account/avatar/00/1c/bd/7a/37df606b.jpg","comment_is_top":false,"comment_ctime":1625719335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625719335","product_id":100039001,"comment_content":"“基于接口而非实现编程”跟“依赖注入”<br>区别：“基于接口而非实现编程”是设计思想，“依赖注入”是编码技巧；<br>关联：可以通过依赖注入的方式实现“基于接口而非实现编程”的设计思想。","like_count":0},{"had_liked":false,"id":301389,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1625657285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625657285","product_id":100039001,"comment_content":"“基于接口而非实现编程” 是指导原则和编程思想。<br>“依赖注入”是具体的编程技巧。<br>“基于接口而非实现编程”的原则可以实现“依赖注入”的编程，反之来讲，“依赖注入”的实现依赖于“基于接口而非实现编程”的原则指导。","like_count":0},{"had_liked":false,"id":297268,"user_name":"wsh","can_delete":false,"product_type":"c1","uid":1006628,"ip_address":"","ucode":"C0FE187C6EECED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","comment_is_top":false,"comment_ctime":1623399313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623399313","product_id":100039001,"comment_content":"依赖注入主要是对数据的抽象，我们可以方便替换掉所以依赖的数据对象，而不影响使用者的代码，使用类和注入类之间常常是组合的关系。而基于接口而非实现编程，是对操作的抽象，使用类和借口类一般是继承关系。","like_count":0},{"had_liked":false,"id":296366,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1622942234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622942234","product_id":100039001,"comment_content":"区别是：“基于接口而非实现编程”是一种编程的思想，强调以接口为顶级设计，方便以后的扩展。而“依赖注入”是一种编程技巧，指的是创建的依赖对象不是通过new的方式创建的，而是通过函数传递过来的。<br>联系是：“基于接口而非实现编程”是设计的是接口，方便扩展，符合开闭原则。“依赖注入”在定义输入参数时，可以定义为接口，这样的话其接口的实现类也可以传递过来，也是方便以后的扩展。","like_count":0},{"had_liked":false,"id":296127,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1622772654,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1622772654","product_id":100039001,"comment_content":"依赖注入依赖于&quot;基于接口而非实现编程&quot;","like_count":0},{"had_liked":false,"id":293887,"user_name":"Geek_d60492","can_delete":false,"product_type":"c1","uid":2599089,"ip_address":"","ucode":"9A79B12F0D3D63","user_header":"https://static001.geekbang.org/account/avatar/00/27/a8/b1/092b658f.jpg","comment_is_top":false,"comment_ctime":1621587449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621587449","product_id":100039001,"comment_content":"依赖注入是实现控制反转的一种手段，属于“技”的层面；基于接口而非实现编程是面向对象设计原则，属于“术”这个层面。我们在使用依赖注入时，考虑到扩展性，需要遵循基于接口而非实现编程这个原则。","like_count":0},{"had_liked":false,"id":293866,"user_name":"苏杭天下","can_delete":false,"product_type":"c1","uid":2626287,"ip_address":"","ucode":"C6080021BA450F","user_header":"https://static001.geekbang.org/account/avatar/00/28/12/ef/cb0b57ec.jpg","comment_is_top":false,"comment_ctime":1621583041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621583041","product_id":100039001,"comment_content":"突然有个很粗糙的理解：就比如租房子，先不考虑代理只考虑这个依赖反转。原先租房子是找房东租，租客和房东是依赖关系，租客调用房东的房子。现在来了个中介，既然是非代理就不收中介费，比作共同依赖的一个抽象。房东把房子交给中介，租客不再找房东而是直接找中介，两者不再彼此依赖，而是共同依赖一个中介！这样的好处是，下次不想租这个房东的房子了，可以直接再次调用这个中介，让中介换个其他房东房子。或者房东不想租给你这个人，房东可以直接找依赖的中介换个租客。代码层面上不需要改动很多，因为两者都是依赖的这个中介。","like_count":0},{"had_liked":false,"id":291805,"user_name":"唐杨海","can_delete":false,"product_type":"c1","uid":1073096,"ip_address":"","ucode":"095619849CB268","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/c8/67e59742.jpg","comment_is_top":false,"comment_ctime":1620524346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620524346","product_id":100039001,"comment_content":"1.高层模块和低层模块都依赖于协议<br>2.协议不能由低层模块所有，可以由第三方所有，或者高层模块所有，这才是反转","like_count":0},{"had_liked":false,"id":290117,"user_name":"学员203","can_delete":false,"product_type":"c1","uid":2559640,"ip_address":"","ucode":"63E4B7E3A7E140","user_header":"","comment_is_top":false,"comment_ctime":1619393362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619393362","product_id":100039001,"comment_content":"我理解的依赖反转就是调用者依赖于被调用者的抽象，不依赖具体实现类，而作为被调用者是实现抽象接口的，感觉思想就是实现不被调用者时要面向接口编程而不是面向实现编程，可以联想Head first说的披萨店和具体披萨的代码实现。","like_count":0},{"had_liked":false,"id":289660,"user_name":"Gandalf","can_delete":false,"product_type":"c1","uid":1267039,"ip_address":"","ucode":"3881987167B713","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/5f/5dc667c3.jpg","comment_is_top":false,"comment_ctime":1619136290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619136290","product_id":100039001,"comment_content":"基于接口而非实现编程是抽象的一种实现方式，而依赖注入是对所要使用的外部对象的获取方式","like_count":0},{"had_liked":false,"id":288195,"user_name":"EQLT","can_delete":false,"product_type":"c1","uid":1122933,"ip_address":"","ucode":"609C93F0DEF0BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/75/79693c63.jpg","comment_is_top":false,"comment_ctime":1618360405,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618360405","product_id":100039001,"comment_content":"基于接口而非实现编程，更多的在于解耦代码，带来更大的扩展性。而依赖注入可以说更注重解决逻辑之间的依赖关系，利用基于接口而非实现编程的方式去实现依赖的反转，让高层不因底层的实际逻辑实现的更改而发生变更，更好地保护高层逻辑的正确性<br>","like_count":0},{"had_liked":false,"id":286406,"user_name":"李奇锋","can_delete":false,"product_type":"c1","uid":1220713,"ip_address":"","ucode":"1A0A359D0530C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/69/e42348a8.jpg","comment_is_top":false,"comment_ctime":1617283334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617283334","product_id":100039001,"comment_content":"explanation:: 在运行期间，上层的模块依赖下层模块把事情做出来。但是，在设计阶段，下层模块的实现逻辑依赖上层模块抽象出来的逻辑 ((或者说是上层建立的抽象模型&#47;接口))","like_count":0},{"had_liked":false,"id":286400,"user_name":"李奇锋","can_delete":false,"product_type":"c1","uid":1220713,"ip_address":"","ucode":"1A0A359D0530C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/69/e42348a8.jpg","comment_is_top":false,"comment_ctime":1617280932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617280932","product_id":100039001,"comment_content":"我感觉用 事件驱动模型（event loop）这个广泛了解的模型去讲解控制反转会有更好的效果。<br><br>只要是符合 事件驱动框架的的所有内容，都会被event loop进行调度，写代码的时候不一定需要知道自己的代码具体在什么时间点上背调用，但是它抽象出来的模型能确保执行逻辑的正确性。","like_count":0},{"had_liked":false,"id":285553,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1616894399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616894399","product_id":100039001,"comment_content":"两者的表象有点类似，但是侧重点不同。  面向接口编程强调的是设计，类和模块之间通过这种方式解耦。  而依赖注入强调的是有外部依赖时，从外部注入。","like_count":0},{"had_liked":false,"id":282953,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1615473628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615473628","product_id":100039001,"comment_content":"关于高层不依赖于低层的思考：<br>比如做手游开发，我们有非常多的发行渠道。比如要上架应用宝、小米商城、华为市场。。。<br>然后要做支付接口的时候，业务逻辑就绝不能依赖于某一个渠道的逻辑。<br>假如我们设计流程的时候，应用宝有个专门的获取签证流程，我们的流程接口里，针对这个签证流程设计了个方法。那么后续所有的渠道接入都得实现这个方法。显然是不合理的。<br>所以这个接口的设计应该去抽象出各个流程来。比如统一的认证、统一的发起支付、统一的回调即可。每个渠道都把各自的步骤，划分进接口的各个实现里面。<br>这样子，就标准化，方便了后续扩展。<br><br>所以这里说的高层不依赖于低层，应该叫高层设计不依赖于低层实现。","like_count":0},{"had_liked":false,"id":282948,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1615472712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615472712","product_id":100039001,"comment_content":"关于控制反转与依赖反转两个概念的思考：<br><br>控制反转：控制是个动作，就是表示流程某个动作控制权的转移。<br>以文章里测试代码为例，本来应该低层执行的流程，触发的权利和时机交给了高层。也就是低层多个的模块的同一个流程，统一商量个协议，交给高层一并触发执行。这里应该是通过高层对低层的控制反转，高聚合了触发时机。<br><br>那有没有高层反转给底层呢？我暂且认为没有吧。<br><br>依赖反转：<br>依赖是个关系，就是谁依赖谁的问题。<br>比如李四写了个接口(获取用户的订单列表)，给前端赵六调用。刚开始产品，并没有要求订单的排列顺序。这时看到的顺序，就是依赖于服务端怎么写，客户端怎么显示。<br>后来产品加入排序功能，客户端指定了排序方式。服务端就根据客户端的参数排序了。这时候显示顺序就依赖于前端开发赵六了。<br><br>感觉不是很准确。。。先这样吧。","like_count":0},{"had_liked":false,"id":280299,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1614154829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614154829","product_id":100039001,"comment_content":"单一职责原则，开闭原则，里氏替换原则，接口隔离原则，依赖反转原则。","like_count":0},{"had_liked":false,"id":279687,"user_name":"大风","can_delete":false,"product_type":"c1","uid":1606600,"ip_address":"","ucode":"95C2B6B98247FB","user_header":"https://static001.geekbang.org/account/avatar/00/18/83/c8/c08fc40f.jpg","comment_is_top":false,"comment_ctime":1613907509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613907509","product_id":100039001,"comment_content":"“基于接口而非实现编程”强调应用程序的设计阶段，尽可能的找出业务骨架即稳定的部分，它的另一面表述也可以说是把不稳定的部分封装起来形成稳定的部分；扩展性正是基于稳定的抽象部分而进行具体实现体现出来的。这正是开闭原则的一种非常好的实现手段。<br>“依赖注入”则侧重于对大量对象创建及其生命周期管理功能的封装，它与应用程序业务场景无关，并且工具在应用程序运行阶段。<br>它们都符合控制反转的设计思想，都充分梳理了应用程序中高低层模块之间的调用关系。另外，前者是设计思想会贯穿于我们在任何软件设计时，需要对业务实现时时操心用心提炼设计；后者显得要具像一点是应用程序的基础设施的一部分，在任何应用程序场景中都几乎是固化的。","like_count":0},{"had_liked":false,"id":279452,"user_name":"Geek_78eadb","can_delete":false,"product_type":"c1","uid":1712955,"ip_address":"","ucode":"843C6C380D28FA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/OYQh8KlUgMx0sZ35felqqRlboXkcOFib0qGgRHuvFCNIMzxRzxN8SjZpwtDuS0PGV0L0Pneiak7yzcd043f2efbg/132","comment_is_top":false,"comment_ctime":1613789849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613789849","product_id":100039001,"comment_content":"从 Notification 这个例子来看，“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？<br><br>两者强调不同的内容：<br>- 依赖注入：强调类在外面初始化成对象后传进来。<br>- 基于接口而非实现编程：强调调用者可操作接口类，实现类与接口类拥有相同的结构，调用者无需了解实现类细节。<br><br>因此两者无关系：<br><br>- 不使用”依赖注入“，也可实现”基于接口而非实现编程“：比如从外面传入的是类，在内部进行初始化。<br>- 不使用”基于接口而非实现编程“，也可实现”依赖注入“：比如不使用接口，直接将类的实例传进来。<br><br>但两者也可结合使用，比如本课的例子。","like_count":0},{"had_liked":false,"id":269620,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1608717413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608717413","product_id":100039001,"comment_content":"为什么都翻译成“依赖”，明明是“取决于”。 高层模块不取决于底层模块。所有模块都取决于抽象。抽象不由细节（过程）决定，细节取决于抽象。这就好理解多了，不是吗？","like_count":0},{"had_liked":false,"id":267043,"user_name":"崔光伟","can_delete":false,"product_type":"c1","uid":1875245,"ip_address":"","ucode":"603FCACC5CFC1C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJZMLfqpOHFbYF6Q31xgbKJ0FaO2ibFSqzyjV9gRlIYsnvGUcxYaG1eABJ5UupxVeda0yV0B3sBqDA/132","comment_is_top":false,"comment_ctime":1607580660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607580660","product_id":100039001,"comment_content":"依赖注入是一种代码风格，关注类之间的关系或者创建对形象的方式；基于接口而非实现编程是一种设计原则，关注抽象和实现。","like_count":0},{"had_liked":false,"id":266665,"user_name":"•••","can_delete":false,"product_type":"c1","uid":1122277,"ip_address":"","ucode":"D7F185FC4BFE14","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/e5/053ebfc9.jpg","comment_is_top":false,"comment_ctime":1607431851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607431851","product_id":100039001,"comment_content":"依赖注入重于方式，注入的可以是类也可以是接口。<br>基于接口重于抽象，降低耦合度。","like_count":0},{"had_liked":false,"id":266179,"user_name":"落尘","can_delete":false,"product_type":"c1","uid":1802622,"ip_address":"","ucode":"7B76B94CA301D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/7e/fb688b5c.jpg","comment_is_top":false,"comment_ctime":1607226932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607226932","product_id":100039001,"comment_content":"控制反转是一种原则，表示将程序执行的流程的控制从程序员反转到了框架。<br>依赖注入，表示将依赖类对象的创建，由类内部反转到了类外部？<br>依赖注入框架，表示将创建依赖对象，管理对象的生命周期，依赖注入等由程序员反转到了框架。<br><br>关于依赖注入我理解的没错吗？","like_count":0},{"had_liked":false,"id":266176,"user_name":"落尘","can_delete":false,"product_type":"c1","uid":1802622,"ip_address":"","ucode":"7B76B94CA301D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/7e/fb688b5c.jpg","comment_is_top":false,"comment_ctime":1607226467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607226467","product_id":100039001,"comment_content":"“基于接口而非实现编程”是一种原则，“依赖注入”是该原则的一种实践方式。我感觉“依赖注入”就是策略模式","like_count":0},{"had_liked":false,"id":265266,"user_name":"Kingram","can_delete":false,"product_type":"c1","uid":2247700,"ip_address":"","ucode":"212E403E81F2FC","user_header":"https://static001.geekbang.org/account/avatar/00/22/4c/14/8fa39544.jpg","comment_is_top":false,"comment_ctime":1606834776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606834776","product_id":100039001,"comment_content":"区别：<br>从Notification这个例子来看，依赖注入和基于接口而非实现编程不是一个东西，Notification依赖的MessageSender是一个接口还是一个类都没关系，只要不是本类中new出来的就算是依赖注入，而基于接口而非实现编程强调的是接口，上层模块不依赖下层的不稳定的实现，而是依赖更稳定的接口，在Notification 这个例子中，MessageSender就必须是一个接口。<br>联系：<br>两者都是为了降低程序的耦合性、提高代码的可读性、可扩展性、可维护性。结合使用效果更佳～","like_count":0},{"had_liked":false,"id":263211,"user_name":"JRich","can_delete":false,"product_type":"c1","uid":1114901,"ip_address":"","ucode":"66AE9D61533960","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg","comment_is_top":false,"comment_ctime":1606048031,"is_pvip":false,"replies":[{"id":"96105","content":"������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700815,"ip_address":"","comment_id":263211,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606048031","product_id":100039001,"comment_content":"控制反转定义里是程序执行流程的控制权反转，而依赖注入讲的是对象的创建由外部创建好通过构造方法或setter方法注入进来，感觉两个讲的不是一个意思，虽然依赖注入也有控制反转的意思，但是对象的创建和获取的权利被反转，更确切的理解应该是2个场景吧。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510122,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262892,"user_name":"JRich","can_delete":false,"product_type":"c1","uid":1114901,"ip_address":"","ucode":"66AE9D61533960","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg","comment_is_top":false,"comment_ctime":1605871400,"is_pvip":false,"replies":[{"id":"96136","content":"������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701352,"ip_address":"","comment_id":262892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605871400","product_id":100039001,"comment_content":"基于接口而非实现编程使用了依赖注入编程技巧。因为基于接口而非实现编程使用了面向对象的多态特性来提高代码扩展性，必然不可能在类内部创建对象，只能从外部注入。区别就是依赖注入不仅可以使用接口，还可以使用类。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510019,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260887,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1605148078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605148078","product_id":100039001,"comment_content":"IOC，个人理解主要是“控制权由内部转移到了外部”。这个控制权不仅指流程的控制权由内部转向外部，也包含内部对象生命周期管理的反转。<br>DI，依赖注入是实现IOC的一种常见方法，简单易用。<br>DIP，依赖反转原则是解藕的一种方法。原来是调用者依赖被调用者；现在在二者中间加了一层抽象，这层抽象原则成为了二者的依赖，有点面向接口编程的味道。","like_count":0},{"had_liked":false,"id":256415,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603619270,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1603619270","product_id":100039001,"comment_content":"“基于接口而非实现编程”，是一种基于抽象进行编程，把功能和实现分开，“依赖注入”是依赖的对象外注入，而不是内部创建，这增加代码可扩展性，可以让下层依赖上层让设计者更加灵活。二者都是编程技巧，增加代码扩展性。","like_count":0},{"had_liked":false,"id":247939,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1599922240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599922240","product_id":100039001,"comment_content":"依赖注入强调的是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式注入类来使用；它可以基于接口编程，也可以基于实现编程；当注入至类中的对象是接口对象的时候，那就是基于接口编程。","like_count":0},{"had_liked":false,"id":247761,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1533352,"ip_address":"","ucode":"6FD3642D6455AE","user_header":"https://static001.geekbang.org/account/avatar/00/17/65/a8/6431f8b0.jpg","comment_is_top":false,"comment_ctime":1599821677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599821677","product_id":100039001,"comment_content":"dip的原则用起来着实简单，理解起来需要一些基础，一定需要理解为什么不能都去new对象去做，这样才能感受到他的好处","like_count":0},{"had_liked":false,"id":247641,"user_name":"火影.海诺","can_delete":false,"product_type":"c1","uid":2091565,"ip_address":"","ucode":"34729AFEE93B6D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ea/2d/34cb8e0a.jpg","comment_is_top":false,"comment_ctime":1599785098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599785098","product_id":100039001,"comment_content":"控制反转说的是一种原则，一种理念，而依赖注入算这种原则的一个实现方式……为的是减低模块之间的耦合性……最终是为了代码的可扩展服务的。","like_count":0},{"had_liked":false,"id":246388,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599305059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599305059","product_id":100039001,"comment_content":"基于接口而非实现和依赖注入一样是一种原则，一种规范，都是帮助代码易扩展，易维护的有效手段<br>不同点在于基于接口而非实现 主要关注的是接口本身， 也包含了需要抽象的方法，一种约定和协议<br>依赖注入更多的是关注流程和具体类的管理， 解决hardcode对一个类的过度侵入","like_count":0},{"had_liked":false,"id":246010,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599131795,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599131795","product_id":100039001,"comment_content":"1、联系：相似地方，基于接口编程，<br>2、区别：依赖注入，可以很方便扩展为不同的接口类；<br>","like_count":0},{"had_liked":false,"id":245685,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1599026679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599026679","product_id":100039001,"comment_content":"依赖注入是编写可测试性代码最有效的手段。<br>最近尝试写单元测试，发现在需要mock数据的时候无从下手，现在发现是代码本身的可测试性差。<br>控制反转，指的是程序的执行流程从程序员反转到框架。<br>依赖反转，指的是上层模块对下层模块的依赖反转到对抽象接口的依赖。<br>依赖注入，指的是依赖外部传入对象，而不是内部创建对象。","like_count":0},{"had_liked":false,"id":244466,"user_name":"好名字","can_delete":false,"product_type":"c1","uid":1951501,"ip_address":"","ucode":"E2BFD96F912A67","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c7/0d/0dab398b.jpg","comment_is_top":false,"comment_ctime":1598526716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598526716","product_id":100039001,"comment_content":"我理解的依赖反转是，高层模块A依赖低层模块B，可以抽象出一个C，让B依赖C，A依赖C。","like_count":0},{"had_liked":false,"id":244241,"user_name":"辉","can_delete":false,"product_type":"c1","uid":2118347,"ip_address":"","ucode":"A1252F2209190F","user_header":"","comment_is_top":false,"comment_ctime":1598439522,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598439522","product_id":100039001,"comment_content":"需求决定实现挺正常的啊，一直困惑为何要说成依赖反转。","like_count":0},{"had_liked":false,"id":241399,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1597284464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597284464","product_id":100039001,"comment_content":"依赖注入实际上可以注入任何实例，但是想起到增强扩展性的目的，注入类型就必须是抽象的接口类。简单说依赖注入是基于接口编程的一种具体应用场景","like_count":0},{"had_liked":false,"id":241103,"user_name":"Geek_31594d","can_delete":false,"product_type":"c1","uid":2030240,"ip_address":"","ucode":"9058787881CE82","user_header":"","comment_is_top":false,"comment_ctime":1597193085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597193085","product_id":100039001,"comment_content":"控制反转- 本因开发自己控制的流程交给框架处理，开发只需要实现具体功能<br>依赖注入-需要某个对象或者资源的时候，本来是自己创建，现在依然于调用时外部传递<br>依赖注入框架-调用对象的创建 生命周期 依赖注入等于框架去处理<br>依赖反转原则-暂时不是很明确  高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象（需要加深印象）","like_count":0},{"had_liked":false,"id":232911,"user_name":"Java垒墙工程师","can_delete":false,"product_type":"c1","uid":1937062,"ip_address":"","ucode":"E76AE44A9C76AE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","comment_is_top":false,"comment_ctime":1594167607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594167607","product_id":100039001,"comment_content":"区别：<br>     基于接口编程：实现类获得解耦，方便后续替换和修改，调用方不感知<br>     依赖注入：强调的是依赖对象外部输入，而非硬编码到内部<br>二者联系：<br>     都对代码扩展非常友好","like_count":0},{"had_liked":false,"id":230405,"user_name":"大强","can_delete":false,"product_type":"c1","uid":1737397,"ip_address":"","ucode":"D5C64C5A01B25D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/82/b5/a6049a26.jpg","comment_is_top":false,"comment_ctime":1593363307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593363307","product_id":100039001,"comment_content":"基于接口而非实战编程，主要指导我们编程要有抽象思维，用抽象类或者接口实现多态特性。依赖注入主要解决的是对象之间的依赖关系，所有依赖对象通过构造函数或者set方法传递依赖对象。二者的联系就是他们都可以实现拓展性，满足ocp原则","like_count":0},{"had_liked":false,"id":229989,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1593235460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593235460","product_id":100039001,"comment_content":"关于课后题 我的理解是都是用到了接口但是侧重理念不一样，基于接口编程是类之间解耦理念，有些依赖反转原则，即调用底层不基于实现。而依赖注入也是是利用接口但是分离代码职责 避免直接内部创建依赖对象 更有单一指责性在里面，更方便测试","like_count":0},{"had_liked":false,"id":229986,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1593235092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593235092","product_id":100039001,"comment_content":"控制反转 依赖注入 和依赖反转，这三个概念的区别是我目前看到的所有文章教程里说的最清晰明了的，谢谢老师。","like_count":0},{"had_liked":false,"id":229370,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592978221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592978221","product_id":100039001,"comment_content":"依赖注入和面象接口而非实现编程，如A调用B的方法，依赖注入值得是B，而面象接口指的是A。针对的对象不同。<br>依赖倒置原则指的是高层不依赖底层，抽象不依赖具体。其实是面向接口的具体实现了。要求底层足够的抽象扩展，本来是底层给高层提供服务，却要求底层。所以是依赖倒置了","like_count":0},{"had_liked":false,"id":229227,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592926763,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592926763","product_id":100039001,"comment_content":"依赖注入是一种具体的编程技巧，通过外部创建好类对象然后通过构造函数或属性等方式传入给调用者，这样可随时进行替换。","like_count":0},{"had_liked":false,"id":229225,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592926581,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592926581","product_id":100039001,"comment_content":"基于接口而非实现编程是设计原则，指导类的设计，依赖接口而不直接依赖实现类，具备更高的扩展性。而依赖注入是一种具体的编程技巧，通过外部创建好对象（）","like_count":0},{"had_liked":false,"id":226382,"user_name":"港岛妹夫","can_delete":false,"product_type":"c1","uid":1097416,"ip_address":"","ucode":"9F6AAA29B60D8F","user_header":"https://static001.geekbang.org/account/avatar/00/10/be/c8/7c5f324f.jpg","comment_is_top":false,"comment_ctime":1592057289,"is_pvip":false,"replies":[{"id":"83996","content":"都是实践中来的，自己动脑子思考的比较多，书的话也就是看看而已，你可以看我写的这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;uKkQMIWTtAmvsEYZCxvZeg","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1592526369,"ip_address":"","comment_id":226382,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592057289","product_id":100039001,"comment_content":"想知道争哥的英文原文都是从哪里读来的. 如果是书的话, 可以推荐一些嘛~","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498221,"discussion_content":"都是实践中来的，自己动脑子思考的比较多，书的话也就是看看而已，你可以看我写的这篇文章：\nhttps://mp.weixin.qq.com/s/uKkQMIWTtAmvsEYZCxvZeg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592526369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223793,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1591182061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591182061","product_id":100039001,"comment_content":"区别：<br>1、依赖注入是一种具体的编程技巧，通过参数传递类而不是在内部new创建对象，降低代码的耦合性，提高可扩展性<br>2、面向接口编程可以说是一种编程思想或者设计原则，关注抽象和实现，上下游调用稳定性<br><br>联系：<br>二者都可以提高代码的可扩展性，基于开闭的原则","like_count":0},{"had_liked":false,"id":219399,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1590022440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590022440","product_id":100039001,"comment_content":"模板设计模式，依赖注入都可以实现控制反转。两者有个共同点，就是均为开发者保留扩展点，前者的扩展点是动作，后者的扩展点是整个对象(每个对象拥有各自个性化的动作)。","like_count":0},{"had_liked":false,"id":218538,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1589815084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589815084","product_id":100039001,"comment_content":"“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？<br>-----<br><br>- 首先基于接口而非实现编程，相同点：因为两者都依赖接口来实现被调用者的抽象，减少类之间的耦合，提供低成本的替换。<br>- 不同：基于接口而非实现编程，也可以理解为最基础的一种编码实践之一，设计模式有相当一部分是基于这种实践总结的。依赖注入，甚至说是依赖反转，是前者的扩展。<br>- 可以这么理解，前者是基石之一，后面是对前者的补充和发展","like_count":0},{"had_liked":false,"id":217290,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589455260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589455260","product_id":100039001,"comment_content":"依赖倒置、控制反转、依赖注入是三个不同的概念。<br>依赖倒置：把service层的接口挪到controller层，controller层不再依赖service的任何代码，service层实现controller中定义的接口，这样就实现了高层代码不知道低层代码，低层实现高层定义的接口，是依赖倒置。跟是否使用注入框架没有关系，重点是层之间的依赖关系。<br>控制反转：是框架的设计思路，框架是完成一整套业务流程逻辑的，高层调用低层时只需要实现框架预留的扩展点，然后传入框架，改变框架的行为，看起来是框架在调用高层的代码，we call you，you do not call me！<br><br>业务组装：扩展点要是预留的接口，可以编写多个实现；扩展点要是基类，可以编写多个泛化；然后业务组装层挑选实现和泛化，然后实例化对象，传入高层代码。<br>整个程序分高层业务逻辑,高层扩展规范(基类、接口)，高层扩展规范的实现，业务组装。注入就是业务组装层的工作，实例化泛化或实现，然后在实例化高层代码时传入，是UML说的一种依赖构造关系，用了依赖注入框架，也不一定就是依赖倒置，也不一定控制反转，现在常规写法接口和实现在同一层，controller层依赖了service层的接口，依赖没有倒置。这种写法违反了依赖倒置的规范，不知为啥大部分代码都是这种写法。spring的IOC框架声称是依赖注入控制反转容器，IOC只是把实现代码装配，是否控制反转了？是否依赖倒置了？IOC没有能力控制。<br>","like_count":0},{"had_liked":false,"id":217011,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589385097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589385097","product_id":100039001,"comment_content":"依赖注入没有实现控制反转！！！ <br>依赖注入只是实现了可以替换依赖。控制流程没有由高层挪到低层！service相对controller是低层，xxxController依赖xxxService的抽象接口，控制没有反转，控制还是在高层，只是可以方便的替换依赖类xxxService。<br><br>xxxService接口看作预留扩展点，xxxController作为低层，依赖注入框架看作高层可以，但是依赖注入框架作为高层不合适，因为程序员不关心依赖框架具体实现细节。","like_count":0},{"had_liked":false,"id":216922,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589369554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589369554","product_id":100039001,"comment_content":"控制反转是编程思想，用于框架设计，本来应该高层调用低层并控制程序流程，反转为低层调用高层的实现，并控制程序流程。<br><br>依赖反转也是编程思想，控制反转的构造入参可以是class、interface、abstract，依赖反转是高层和低层都依赖interface或abstract，不要依赖class，也是低层调用高层的一种思想。高层写代码依赖的是调用的是低层的interface或abstract，不依赖class。<br><br>实现控制反转的方法有模板模式、依赖注入、里式替换。","like_count":0},{"had_liked":false,"id":214894,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1588843801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588843801","product_id":100039001,"comment_content":"1、依赖翻转：<br>一般来说，先有提供者提供功能，调用者如果想使用，那么就要适配提供者的api。<br><br>上层会调用下层，似乎也是上层需要适配被下层的api。<br><br>但是依赖倒置原则是让下层来主动适配上层，否者这个下层实现就是不合格的！上层并不依赖下层。<br><br>那么下层如何来适配上层呢？<br><br>上层模块定义一个抽象标准，并直接依赖这个抽象标准，下层主动实现这个标准。<br><br>上层并不关心是不是有下层实现，也不关心下层实现的对不对，即上层不依赖下层实现。<br><br>下层需要实现上层定义的抽象标准，所以这时下层模块依赖了上层模块。<br><br>文中tomcat的例子十分形象，tomcat作为上层的容器，规定下层实现必须实现servlet规范，tomcat版本不依赖任何下层实现，一样跑的转，但是下层实现如果不遵守规范，那上层模块就不鸟你了。","like_count":0},{"had_liked":false,"id":214387,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1588736786,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588736786","product_id":100039001,"comment_content":"基于接口而非实现编程 类似于设计原则，依赖注入类似于具体实现。<br>基于接口而非实现编程 类似于接口，依赖注入类似于继承了该接口。<br>","like_count":0},{"had_liked":false,"id":212354,"user_name":"KID","can_delete":false,"product_type":"c1","uid":1867938,"ip_address":"","ucode":"EE80B7CA7CC2A2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/80/a2/96dcd1fa.jpg","comment_is_top":false,"comment_ctime":1588088847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588088847","product_id":100039001,"comment_content":"依赖注入是一种代码编写技巧，基于接口编程而非实现编程是一种设计原则，前者关注类和对象的关系，后者关注抽象和实现；目的都是为了提高可扩展性，降低耦合","like_count":0},{"had_liked":false,"id":207412,"user_name":"林子er","can_delete":false,"product_type":"c1","uid":1629256,"ip_address":"","ucode":"85637288F22CF0","user_header":"https://static001.geekbang.org/account/avatar/00/18/dc/48/9796286e.jpg","comment_is_top":false,"comment_ctime":1587084722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587084722","product_id":100039001,"comment_content":"基于接口而非实现编程是设计原则，依赖注入更多的是说实现方式，一般用后者实现前者","like_count":0},{"had_liked":false,"id":203032,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1586104988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586104988","product_id":100039001,"comment_content":"基于接口而非实现的编程，其中的接口就是依赖反转原则中所谓的&quot;抽象&quot;。接口不依赖具体的实现类和实现类的调用，但实现类和实现类的调用依赖接口。因此基于接口而非实现的编程，就是依赖反转原则的一个具体应用。","like_count":0},{"had_liked":false,"id":202737,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586059605,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586059605","product_id":100039001,"comment_content":"个人感觉依赖反转这个名字起得不好，为什么呢？因为这个通过看这个名字，和具体的描述似乎很难联系起来，或者名字或者描述之间没有联系。","like_count":0},{"had_liked":false,"id":201391,"user_name":"Geek_49de4e","can_delete":false,"product_type":"c1","uid":1586108,"ip_address":"","ucode":"8A01075936CC81","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/guAazdraayUib2pmGYuxFGUEHZUoibsj2xNTdjOT0McXJKQUPKwH4EHRfV72oaiatfiaWoT0fm5zib1dNqnFNbcFRQw/132","comment_is_top":false,"comment_ctime":1585760291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585760291","product_id":100039001,"comment_content":"1.依赖注入改变了对象初始化的位置，但并未改变对象之间的依赖关系。<br>2.面向抽象编程改变对象之间对具体实现的依赖。<br><br>结合上面两点，在模版和IOC框架中通过面向抽象编程来定义扩展点，并通过依赖注入来生产注对象，是遵循了依赖倒置原则的良好实践。","like_count":0},{"had_liked":false,"id":200737,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585644658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585644658","product_id":100039001,"comment_content":"控制反转：控制是指对流程的控制，反转是指原本是程序员控制流程，反转成框架控制流程。<br><br>依赖反转：高层代码不依赖于低层代码，他们共同依赖于一个抽象。<br><br>依赖注入：不通过 new 的方式在类内部创建类的对象。而是在外面创建好类的对象，然后通过函数参数，构造函数方式传入","like_count":0},{"had_liked":false,"id":200659,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585630390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585630390","product_id":100039001,"comment_content":"依赖注入只是将需要的对象传递进去就可以了，专注于注入，而基于接口而非实现编程基于多tai,基于扩展性，专注于面对未来的变化，所以开发人员不仅要面对功能实现，更应该面对未来的变化","like_count":0},{"had_liked":false,"id":199562,"user_name":"ryan007","can_delete":false,"product_type":"c1","uid":1046357,"ip_address":"","ucode":"7D28C589800CAE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/55/769bf4fb.jpg","comment_is_top":false,"comment_ctime":1585491489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585491489","product_id":100039001,"comment_content":"有理论有实践，还是很不错的","like_count":0},{"had_liked":false,"id":198626,"user_name":"Six","can_delete":false,"product_type":"c1","uid":1220617,"ip_address":"","ucode":"E297BB638B2BD9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","comment_is_top":false,"comment_ctime":1585460753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585460753","product_id":100039001,"comment_content":"控制反转是 这里的控制是对程序的控制，而反转是由程序员控制的逻辑交给框架来抽象控制，讲的是一种设计思想。<br>依赖注入是一个类依赖一个类，而将这个类通过外部传入。一般被依赖的设计成接口或者抽象类比较容易扩展，讲的是一种编程技巧<br>依赖倒置原则 则说的是调用方依赖实现方，通常通过接口来规范。调用方不知道具体的实现，而实现不知道具体的调用方。对于实现方在设计的时候，需要考虑调用方的使用场景，多个调用方的通用性。","like_count":0},{"had_liked":false,"id":197962,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585405381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585405381","product_id":100039001,"comment_content":"这个是真的抽象，好像也没讲和Spring IOC得差别吧。","like_count":0},{"had_liked":false,"id":197713,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1585394171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585394171","product_id":100039001,"comment_content":"记录今天学习的内容，控制反转，依赖注入，依赖反正。","like_count":0},{"had_liked":false,"id":196243,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585266493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585266493","product_id":100039001,"comment_content":"基于接口编程强调的是将公共功能抽出来。<br>而依赖注入更强调不要在内部new对象，这样绑定死了调用对象。","like_count":0},{"had_liked":false,"id":195255,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1585150442,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585150442","product_id":100039001,"comment_content":"【设计模式笔记20】20200325<br>控制反转：将程序的流程放在框架层实现，反转的是程序的流程控制，一句话：流程控制从自己控制变成框架控制。好处是专注实现逻辑即可，流程由框架管理<br>依赖注入：依赖的对象通过构造函数和serrer方法传递进来，而不是通过new的方式创建。好处是可以减少对象的创建，从而提高程序运行的性能，虚拟机会对不再使用得对象进行垃圾回收，导致应用频繁gc。<br>依赖注入框架：具备创建对象、对象的生命周期管理、依赖注入的功能框架。<br>为什么要使用控制反转框架：不需要关心对象的依赖关系，对象之间的关系可以交给容器完成，减少代码的耦合度<br>最后再回答下问题：首先“基于接口而不是实现编程”讲的是程序的交互问题，即如何实现写代码，依赖注入是一种关系程序内部对象的技巧，两个维度的问题","like_count":0},{"had_liked":false,"id":194958,"user_name":"黑客时间","can_delete":false,"product_type":"c1","uid":1831324,"ip_address":"","ucode":"7E22D76EECAC4D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f1/9c/cd12361d.jpg","comment_is_top":false,"comment_ctime":1585123825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585123825","product_id":100039001,"comment_content":"基于接口编程能够使依赖注入的兼容性更强，在实际操作中，我只需要确定所依赖的类的类型，但是具体是哪个实现类，我不关心，根据实际情况进行注入就可以了","like_count":0},{"had_liked":false,"id":194739,"user_name":"然","can_delete":false,"product_type":"c1","uid":1347648,"ip_address":"","ucode":"43B7D3896D706B","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/40/dfa19744.jpg","comment_is_top":false,"comment_ctime":1585100977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585100977","product_id":100039001,"comment_content":"依赖反转：高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。","like_count":0},{"had_liked":false,"id":194438,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585059700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585059700","product_id":100039001,"comment_content":"控制反转这个定义挺反人类的，今天终于听老师讲明白了，不是由编程人员控制逻辑走向，而是由这样一种设计出的框架来控制走向","like_count":0},{"had_liked":false,"id":192690,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584868322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584868322","product_id":100039001,"comment_content":"“控制翻转”是心法是指导原则，“依赖注入”是剑谱是手段，“依赖注入框架”则是倚天剑是工具。","like_count":0},{"had_liked":false,"id":192686,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584868136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584868136","product_id":100039001,"comment_content":"讲的是俩个层面的事情。“基于接口而非实现编程”讲的是编码原则，如何从逻辑上组织代码；“依赖注入”讲的是实现方式，怎么样把相关代码组合起来。","like_count":0},{"had_liked":false,"id":189822,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1584572064,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584572064","product_id":100039001,"comment_content":"tomcat那个例子很好","like_count":0,"discussions":[{"author":{"id":2559640,"avatar":"","nickname":"学员203","note":"","ucode":"63E4B7E3A7E140","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370334,"discussion_content":"懂的人说好，没接触过的不理解，比如前端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619364927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179714,"user_name":"huangzhimim","can_delete":false,"product_type":"c1","uid":1018596,"ip_address":"","ucode":"ACAB00327DD95D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/e4/e5e1fd9b.jpg","comment_is_top":false,"comment_ctime":1582082889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582082889","product_id":100039001,"comment_content":"&#47;&#47; 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()JunitApplication.register(new UserServiceTest();<br><br>真心求教这里可以用什么配置来实现呢","like_count":0},{"had_liked":false,"id":178963,"user_name":"杨松","can_delete":false,"product_type":"c1","uid":1512517,"ip_address":"","ucode":"FB3C73BC44C94D","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/45/adf079ae.jpg","comment_is_top":false,"comment_ctime":1581864205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581864205","product_id":100039001,"comment_content":"老师你好，请教下开篇的第一个问题““依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？”能给个总结性的答案吗？这个问题总感觉有点晕晕的，还是不能理解的特别透彻。","like_count":0},{"had_liked":false,"id":177845,"user_name":"嘿泥鳅","can_delete":false,"product_type":"c1","uid":1285186,"ip_address":"","ucode":"A22BDA7A6DA23E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/F5Srwp8IibOU9PDCDgmpdIZF9UXQZzfPKzNseHW5GR0WmusGfrkmzQ6wq32omW3uTtl8aXjkudYSA0NEmibxAcnw/132","comment_is_top":false,"comment_ctime":1581514012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581514012","product_id":100039001,"comment_content":"区别：<br>1.基于接口而非实现编程强调的是隔离变化应对未来需求，并且作为一种面向对象的基本原则<br>2.依赖注入则是实现IOC的基本手段<br>联系：两者都以提高代码扩展性作为目标和意义，并且DI可以借助基于接口而非实现编程来增强扩展性和灵活性，例如Spring中的接口注入。","like_count":0},{"had_liked":false,"id":177489,"user_name":"涉蓝","can_delete":false,"product_type":"c1","uid":1134619,"ip_address":"","ucode":"C1321E29E01625","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLh8ubWQtDRa6exJtloSwibLliaejpF7434ficyggzukmXE63UlSPvbykoiaVDZo4CbDIIOQsCkicibyn9A/132","comment_is_top":false,"comment_ctime":1581403846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581403846","product_id":100039001,"comment_content":"依赖注入是为了实现控制反转的一种编程方法，而要实现依赖注入的前提就是可能变化的依赖是根据接口抽象出来的，所以 基于接口而非实现编程 是实现 依赖注入 的 基础","like_count":0},{"had_liked":false,"id":175755,"user_name":"刘明丰","can_delete":false,"product_type":"c1","uid":1591790,"ip_address":"","ucode":"64C1D6CC769F75","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eocPWoTKicQG9ic42hLQBOqEziaNYxBekyGXljWrYfhk8gjLGZWfUX0JlObCvOIUSA8tRXicfxeSDJMMw/132","comment_is_top":false,"comment_ctime":1580819837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580819837","product_id":100039001,"comment_content":"控制反转和依赖注入其实是描述事物的角度不一样，依赖注入是上帝视角来看的，程序本身看成一个黑盒，所有的依赖都通过外部填充进去；控制反转是程序本身作为第一视角的，本来程序需要依赖关系都是靠自己new出来的，都是自己控制的，反转之后就不一样了，依赖关系不再靠自己维护了，而是交给了外部或者说是第三方来维护，控制权发生了变化。","like_count":0},{"had_liked":false,"id":174798,"user_name":"流星","can_delete":false,"product_type":"c1","uid":1114926,"ip_address":"","ucode":"94BACF37AD4953","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/2e/3a7b0eda.jpg","comment_is_top":false,"comment_ctime":1580391395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580391395","product_id":100039001,"comment_content":"基于接口而非实现是指通过接口的方式而不用考虑内部实现，依赖注入更强调的是依赖","like_count":0},{"had_liked":false,"id":174688,"user_name":"h1z3y3","can_delete":false,"product_type":"c1","uid":1284984,"ip_address":"","ucode":"AD0B626CF56A9A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVqBf4Tkj2OtdziaIKlJJf6RVpZ8LmbPibg47Ba4wiaW5zXecpYYn5oKTrzhOJ6L5H2Yv7cqLSODiazA/132","comment_is_top":false,"comment_ctime":1580351627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580351627","product_id":100039001,"comment_content":"可以看一下 Uncle Bob 的 Clean Architecture， <br>真正的实现，整个架构完全分层，层与层之间使用都是DI","like_count":0},{"had_liked":false,"id":174079,"user_name":"移动一下","can_delete":false,"product_type":"c1","uid":1034115,"ip_address":"","ucode":"9314E79C72A71E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/83/ca76b4f3.jpg","comment_is_top":false,"comment_ctime":1579954959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579954959","product_id":100039001,"comment_content":"联系是两者都用了抽象，都是为了扩展，区别是依赖注入强调了对象生成的地方来源于外部","like_count":0},{"had_liked":false,"id":172371,"user_name":"www","can_delete":false,"product_type":"c1","uid":1275203,"ip_address":"","ucode":"951B364F2CB211","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg","comment_is_top":false,"comment_ctime":1579162501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579162501","product_id":100039001,"comment_content":"基于接口而非实现编程是一种编程思想，强调的是接口可以应对需求的变更，有更高的扩展性<br>依赖注入是一种编程技巧，可以实现控制反转的编程思想，解放程序员对复杂的类成员的初始化，让程序员专心于业务代码上","like_count":0},{"had_liked":false,"id":171208,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1578881793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578881793","product_id":100039001,"comment_content":"首先 ”基于接口而非实现编程”便于“依赖注入”中动态替换，灵活的进行拓展。类似在spring框架中有接口和实现类，而只需要依赖接口即可，可以动态调整实现。<br>其次 ”基于接口而非实现编程” 侧重类的设计，是实现代码灵活性、提升可拓展的方式。而“依赖注入”是一种具体的编码技巧，可将具体的业务逻辑 和 通用重复的代码切分出来，简化代码开发的难度等。","like_count":0},{"had_liked":false,"id":170917,"user_name":"东流","can_delete":false,"product_type":"c1","uid":1738147,"ip_address":"","ucode":"2715BC6E87BD83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/a3/7e078442.jpg","comment_is_top":false,"comment_ctime":1578757194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578757194","product_id":100039001,"comment_content":"依赖反转强调类中对象在外部初始化，传给类时最好基于接口而非实现，但不强求；而基于接口而非实现指的是类给类通信时的一种设计原则","like_count":0},{"had_liked":false,"id":170198,"user_name":"CHS","can_delete":false,"product_type":"c1","uid":1240227,"ip_address":"","ucode":"3D8B2DABC0A1D6","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/a3/28763399.jpg","comment_is_top":false,"comment_ctime":1578548328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578548328","product_id":100039001,"comment_content":"Notification 基于接口而非实现编程更加灵活，调用方只需要调用接口的相关方法就可以了，不用管实现方式怎么实现的。","like_count":0},{"had_liked":false,"id":169777,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1578445418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578445418","product_id":100039001,"comment_content":"基于接口而非实现和控制反转挺相似，前者强调依赖的对象，尽量依赖接口，后者强调依赖的方向，高层模块有时候需要另外一个低层模块的功能，直接引用会让稳定的高层模块依赖不稳定的低层模块，这时候有必要在高层模块中衍生出一个接口，这个接口是和高层一样稳定的，然后让低层的模块实现这个接口，运行时期注入低层的模块，来让高层的模块调用低层的功能，这样就通过了两者都依赖接口来避免了高层模块直接依赖低层的模块。","like_count":0},{"had_liked":false,"id":168783,"user_name":"开心小毛","can_delete":false,"product_type":"c1","uid":1023762,"ip_address":"","ucode":"9D57A2773759F3","user_header":"","comment_is_top":false,"comment_ctime":1578159155,"is_pvip":false,"replies":[{"id":"65750","content":"上层模块的抽象你是指什么呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1578380725,"ip_address":"","comment_id":168783,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1578159155","product_id":100039001,"comment_content":"底层模块依赖上层模块的抽象是否提倡？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480335,"discussion_content":"上层模块的抽象你是指什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578380725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123422,"discussion_content":"上层模块的抽象指的是调用者的接口。例如，被调用者的实现类和接口分别定义在两个不同的DLL中，被调用者的实现类和接口也分别定义在各自的DLL中，此时被调用者实现类的DLL引用调用者接口的DLL, 这样是否提倡。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578402683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123400,"discussion_content":"上层模块的抽象指的是调用者的接口。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578402293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168778,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1578156850,"is_pvip":false,"replies":[{"id":"65751","content":"倒置就是反转，我在文章中不是解释了为啥叫反转吗😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1578380767,"ip_address":"","comment_id":168778,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578156850","product_id":100039001,"comment_content":"高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。  不太明白，为什么叫依赖倒置呀？倒置啥呢？ 我可能会取名，依赖抽象原则，哈哈。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480332,"discussion_content":"倒置就是反转，我在文章中不是解释了为啥叫反转吗😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578380767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168707,"user_name":"Yangjing","can_delete":false,"product_type":"c1","uid":1018061,"ip_address":"","ucode":"D88DFD4958D07C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/cd/2c3808ce.jpg","comment_is_top":false,"comment_ctime":1578145312,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578145312","product_id":100039001,"comment_content":"联系在这两者都是通过多态特性来实现的；区别在于依赖接口编程侧重点在类应该依赖接口（或抽象类），依赖注入侧重于通过注入的方式实例化类依赖的对象。","like_count":0},{"had_liked":false,"id":168647,"user_name":"青子","can_delete":false,"product_type":"c1","uid":1518034,"ip_address":"","ucode":"C159B8C644E7DA","user_header":"https://static001.geekbang.org/account/avatar/00/17/29/d2/475ee8e7.jpg","comment_is_top":false,"comment_ctime":1578131165,"is_pvip":false,"replies":[{"id":"65956","content":"代码稍微有点问题，我改下，抱歉！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1578490058,"ip_address":"","comment_id":168647,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1578131165","product_id":100039001,"comment_content":"JunitApplication.register(new UserServiceTest();<br>在控制反转中执行这句话会执行该类中的final修饰的main方法吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480281,"discussion_content":"代码稍微有点问题，我改下，抱歉！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578490058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177602,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","nickname":"Treasure","note":"","ucode":"4211ECEB347C3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138465,"discussion_content":"文章这段有问题的代码没有更新呢，小争哥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579244922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167376,"user_name":"七月有风","can_delete":false,"product_type":"c1","uid":1439990,"ip_address":"","ucode":"B3F82397347C5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/f6/3e2db176.jpg","comment_is_top":false,"comment_ctime":1577780041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577780041","product_id":100039001,"comment_content":"第一次接触依赖注入是在Angular.Js 1.X版本中","like_count":0},{"had_liked":false,"id":166765,"user_name":"无所从来","can_delete":false,"product_type":"c1","uid":1325996,"ip_address":"","ucode":"E7AD394BC16A73","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ac/40807e85.jpg","comment_is_top":false,"comment_ctime":1577589841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577589841","product_id":100039001,"comment_content":"高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。","like_count":0},{"had_liked":false,"id":166381,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1577439911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577439911","product_id":100039001,"comment_content":"“基于接口而非实现编程”跟“依赖注入”。<br>强调点不同：“基于接口而非实现编程”强调的是接口（抽象概念的接口）更加着重于在思想层面，“依赖注入”强调的是一种具体的方式方法。","like_count":0},{"had_liked":false,"id":166019,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1587803,"ip_address":"","ucode":"867405CA5A9FB7","user_header":"https://static001.geekbang.org/account/avatar/00/18/3a/5b/ce1724ca.jpg","comment_is_top":false,"comment_ctime":1577363672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577363672","product_id":100039001,"comment_content":"课后思考题：<br>依赖注入拆开来：“依赖” 要基于接口约定，而“注入” 是指模块间的关联方式，而后者是“基于接口而非实现编程” 所没有定义的。","like_count":0},{"had_liked":false,"id":165838,"user_name":"奔跑的小孩","can_delete":false,"product_type":"c1","uid":1304259,"ip_address":"","ucode":"0053193F7A9870","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/21uTMWr7bx5qMibp2hwmGvLbYuj5Aic2dqD3futlNo25eDGDt4t7zzN9cdnj7cVGwTot1U4AyADfWUpqjq1SicgWQ/132","comment_is_top":false,"comment_ctime":1577329896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577329896","product_id":100039001,"comment_content":"依赖倒置原则  说的有些不理解，这里讲的感觉好像是一种思路，高层次到低层次，具体到抽象","like_count":0},{"had_liked":false,"id":165703,"user_name":"Nan","can_delete":false,"product_type":"c1","uid":1236569,"ip_address":"","ucode":"A3DEC678BF814D","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/59/ceea56a9.jpg","comment_is_top":false,"comment_ctime":1577285482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577285482","product_id":100039001,"comment_content":"抽象不依赖具体实现细节： 工厂方法，框架。<br>具体实现细节依赖抽象（所谓反转的地方）：根据高层次需要的进行设计<br><br>感谢 Smallfly 朋友的留言，让我有种顿悟的感觉","like_count":0},{"had_liked":false,"id":165023,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1577149072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577149072","product_id":100039001,"comment_content":"尝试解读一下控制翻转，依赖注入和依赖注入框架之间的关系。<br><br>如果控制翻转我们定义为一件事情的结果，比如：我要有知识.<br>依赖注入：是通向这件事情的一个手段，比如：听老师讲课<br>依赖注入框架：运用如上手段，系统化，完整化的实现这个结果。比如：学校教育体系的存在，我们学知识，上学即可","like_count":0},{"had_liked":false,"id":164957,"user_name":"番茄炒西红柿","can_delete":false,"product_type":"c1","uid":1690242,"ip_address":"","ucode":"13F47BABAB2110","user_header":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","comment_is_top":false,"comment_ctime":1577116276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577116276","product_id":100039001,"comment_content":"基于接口编程强调的是一种设计原则，强调抽象化。而依赖注入则是实现，强调类与类（接口）间的依赖关系，用聚合而非组合关系","like_count":0},{"had_liked":false,"id":164268,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1576919847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576919847","product_id":100039001,"comment_content":"代码里好像有两个小问题：<br>1. 控制反转的代码中，doTest()的返回值误写成了void，应该是Boolean吧？<br>2. 还是控制反转的代码中，for循环中的变量命名case是Java中的关键字，编译不通过的","like_count":0},{"had_liked":false,"id":164107,"user_name":"jason","can_delete":false,"product_type":"c1","uid":1167872,"ip_address":"","ucode":"3329F08BAF307E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d2/00/9a247b1e.jpg","comment_is_top":false,"comment_ctime":1576880355,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576880355","product_id":100039001,"comment_content":"“依赖注入”指依赖时要依赖一个抽象的接口，但注入时要注入一个具体实现。所以实现依赖注入要求我们要基于接口而非实现编程。","like_count":0,"discussions":[{"author":{"id":2559640,"avatar":"","nickname":"学员203","note":"","ucode":"63E4B7E3A7E140","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370335,"discussion_content":"感觉是不是理解偏了，文章重点说的是依赖反转原则，和依赖注入不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619365073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163799,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1576804605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576804605","product_id":100039001,"comment_content":"Spring 的IoC 容器除了主要通过依赖注入实现控制反转外，应该还有其它功能","like_count":0},{"had_liked":false,"id":163665,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1258380,"ip_address":"","ucode":"BFA3BE8D8773A7","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/8c/23eef8d7.jpg","comment_is_top":false,"comment_ctime":1576763729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576763729","product_id":100039001,"comment_content":"这一章我怎么就听不太懂了呢😂😂","like_count":0},{"had_liked":false,"id":163528,"user_name":"皮卡皮卡","can_delete":false,"product_type":"c1","uid":1216284,"ip_address":"","ucode":"D440EEC7301C76","user_header":"https://static001.geekbang.org/account/avatar/00/12/8f/1c/1c728388.jpg","comment_is_top":false,"comment_ctime":1576736963,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576736963","product_id":100039001,"comment_content":"控制反转中的第二段改造代码public abstract void doTest();应该是public abstract boolean doTest();<br>同时第三段中的不需要程序员显示调用register()，应该是显式调用doTest()吧","like_count":0},{"had_liked":false,"id":163497,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1576731741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576731741","product_id":100039001,"comment_content":"这一篇文章确实是我读过的把这四个概念讲的最清楚明白的。","like_count":0},{"had_liked":false,"id":163422,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1576719727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576719727","product_id":100039001,"comment_content":"打卡<br>1、控制反转（Inversion Of Control）：“控制”指对程序流程的控制，“反转”指没有使用框架之前，程序员控制整个程序的执行，使用框架之后，整个程序的执行由框架来控制。程序执行的流程的控制权从程序员“反转”到了框架<br><br>2、依赖注入（ Dependency Injection）：不通过new的方式在类内部创建依赖对象，而是通过构造函数或是函数参数等方式传递对象给类使用。这样提供高了扩展性，可以方便的替换依赖的类，符合“开闭原则”。根据基于接口而非实现编程原则，注入的可以是接口的实现类，更为方便灵活和易扩展<br><br>3、依赖注入框架（DI Framework）：通过框架提供的扩展点，简单配置所需创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的声明周期、依赖注入等操作；<br><br>4、依赖反转原则（Dependency Inversion Principle）：高层模块不依赖于底层模块，高层模块和底层模块都依赖与抽象，抽象不依赖于具体的实现细节，具体的实现细节依赖与抽象。（在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计）","like_count":0},{"had_liked":false,"id":163376,"user_name":"曾志伟","can_delete":false,"product_type":"c1","uid":1152405,"ip_address":"","ucode":"ED6E1073E0B247","user_header":"https://static001.geekbang.org/account/avatar/00/11/95/95/8078a8f8.jpg","comment_is_top":false,"comment_ctime":1576715371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576715371","product_id":100039001,"comment_content":"基于接口而非实现编程，其中接口指的是协议或者约定，调用者只需根据协议进行编程即可，无需依赖接口的具体实现。依赖注入是指类的成员不通过自己内部生成，而是通过类的调用者在类外部生成，再传入类中。前者是为了接口实现类的变动不影响接口调用类，后者可以解耦成员拥有类和成员实现逻辑。前者是后者的一种实现方式。","like_count":0},{"had_liked":false,"id":163219,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1576672377,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576672377","product_id":100039001,"comment_content":"依赖注入描述的是一种编码技巧 而编程框架在抽象的层面让大家可以方便的使用这种技巧 这种技巧的好处是依赖的组织管理更简单 因为都交给框架做了 而大家只要写自己的业务就好 而面向接口编程是设计原则 为了更好的解耦和扩展和插拔 用依赖注入的技巧配合面向接口编程 能协调实现更好的代码架构","like_count":0},{"had_liked":false,"id":163206,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1576669955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576669955","product_id":100039001,"comment_content":"区别：依赖注入是一种编程技巧，即使注入的类未采用面向接口编程，也可以。<br>联系：可以结合面向接口编程的原则，来进行依赖注入，这样的代码的就更加易于扩展。","like_count":0},{"had_liked":false,"id":163154,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1576664115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576664115","product_id":100039001,"comment_content":"控制反转: 上层不依赖下层<br>依赖注入:通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。","like_count":0},{"had_liked":false,"id":163053,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1576648971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576648971","product_id":100039001,"comment_content":"“基于接口而非实现编程”是基础，在此基础上将依赖获取方式抽象，进而演进出各种控制反转和框架。“依赖注入”仅是获取依赖的一种具体方式。这两个一个是战略层面的，一个是战术层面的。落地到代码时，都是依靠Java接口+里式替换来实现的，故看上去一样。","like_count":0},{"had_liked":false,"id":163038,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1576644553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576644553","product_id":100039001,"comment_content":"区别是依赖注入是指生成所依赖对象的方式，是自己生成还是别人注入，基于接口而非实现编程关注的不是对象的生成，而是使用对象的地方，是用接口还是具体的实现来编程，以以后扩展比较方便，复合开闭原则。","like_count":0},{"had_liked":false,"id":162658,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1576574498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576574498","product_id":100039001,"comment_content":"JunitApplication.register(new UserServiceTest();这段代码少了个括号吧？","like_count":0},{"had_liked":false,"id":162651,"user_name":"草原上的奔跑","can_delete":false,"product_type":"c1","uid":1120348,"ip_address":"","ucode":"D69C617F767736","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/5c/1a58e8f6.jpg","comment_is_top":false,"comment_ctime":1576573441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576573441","product_id":100039001,"comment_content":"基于接口而非实现编程，那我基于接口了，我的实现怎么办呢，这个时候，依赖注入来了，给你注入一个你需要的实现。依赖注入可以灵活配置，极大的增强了程序的灵活性，可扩展性。只要接口设计好，通过依赖注入，实现随便换！","like_count":0},{"had_liked":false,"id":162595,"user_name":"нáпの゛","can_delete":false,"product_type":"c1","uid":1130666,"ip_address":"","ucode":"834FA877EFBAF7","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/aa/49bbb007.jpg","comment_is_top":false,"comment_ctime":1576562502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576562502","product_id":100039001,"comment_content":"课后题理解“基于接口而非实现编程”是一种指导思想，依赖注入是在这个思想指导下的具体实现，注入相当于基于接口，在类里new相当于实现编程。<br>还需要老师不定期加餐来个同一解答。","like_count":0},{"had_liked":false,"id":162521,"user_name":"饭","can_delete":false,"product_type":"c1","uid":1610573,"ip_address":"","ucode":"B3F1702D4DE604","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","comment_is_top":false,"comment_ctime":1576548382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576548382","product_id":100039001,"comment_content":"“基于接口而非实现编程”：是一种编程指导思想<br>“依赖注入”：是具体的编程技巧，它在实现过程中，往往又会结合“基于接口而非实现编程”，实现创建类与具体被依赖类的解藕","like_count":0},{"had_liked":false,"id":162351,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1576502989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576502989","product_id":100039001,"comment_content":"基于接口而非编程  强调 接口 概念<br>依赖注入  类接口都可以","like_count":0},{"had_liked":false,"id":162278,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1576491344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576491344","product_id":100039001,"comment_content":"依赖注入可以基于接口而非实现编程，也可以基于实现编程，讲得是类或模块之间的依赖如何实现。<br><br>而基于接口编程主要是从类或模块自身的扩展性出发的。","like_count":0},{"had_liked":false,"id":162251,"user_name":"歌顿","can_delete":false,"product_type":"c1","uid":1154982,"ip_address":"","ucode":"EA84E55C61F61A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIVA6yj0YzARUJV3uqD5Qu0OUNbypl5QvCEwx0rTXubaXlU9TPoorQaZT8SMMvXZMnHLjIpBvIsnA/132","comment_is_top":false,"comment_ctime":1576487178,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1576487178","product_id":100039001,"comment_content":"前端er 表示 Tomcat，Sevlet 规范 是什么鬼。。<br><br>作者能不能尽量写代码例子而不是举这些框架，如果是希望我们还去学习框架那肯定是不可能了","like_count":0,"discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84467,"discussion_content":"你的重点该是要弄清楚规范这个词的理解,至于哪种规范不需要具体懂得","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576497965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162244,"user_name":"马哲富","can_delete":false,"product_type":"c1","uid":1107917,"ip_address":"","ucode":"D6BDDFE3CC07ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg","comment_is_top":false,"comment_ctime":1576486016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576486016","product_id":100039001,"comment_content":"控制指的是程序的执行逻辑；反转指的是不由程序员来控制程序执行，而是由框架来控制；依赖注入指的是不在一个类内部直接new一个对象，而是在外部创建好了直接传进来使用（有点类似于组合关系）","like_count":0},{"had_liked":false,"id":162224,"user_name":"ismind","can_delete":false,"product_type":"c1","uid":1138710,"ip_address":"","ucode":"7AADD673ED3BC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/16/d1dd4972.jpg","comment_is_top":false,"comment_ctime":1576480031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576480031","product_id":100039001,"comment_content":"个人的理解：<br><br>一，首先，来简单梳理着两个语句的含义：<br>1）基于接口而非实现编程，可以看到，在一个类ClazzA的方法中，<br>如果需要将某一个类ClazzB作为参数，那么建议将类ClazzB替换为接口。<br>2）依赖注入，在一个类ClazzA中，需要用到某一个类ClazzB，<br>不需要在ClazzA里直接new ClazzB，而是在ClazzA外创建好，通过构造函数或者函数参数传递给ClazzA。<br><br>二，比较区别与联系<br>1，区别<br>1）基于接口而非实现编程是一种原则，而依赖注入是一种具体的编码技巧。<br>2）依赖注入可以有依赖注入框架，而基于接口而非实现编程则没有基于接口而非实现编程框架。<br><br>2，联系<br>1）二者都可以通过接口来实现类的传递，二者有些类似。<br>2）二者都是将某一个类或者接口作为参数传递到另一个类中。<br>3）可以看到，二者都有效提高了代码的扩展性，无论是基于接口而非实现编程，还是依赖注入<br>最终的目的都是提高代码的扩展性、灵活性，越能应对未来的需求变化，殊途同归！<br><br>以上是个人的见解，还请多指教。","like_count":0},{"had_liked":false,"id":162206,"user_name":"potato00fa","can_delete":false,"product_type":"c1","uid":1307080,"ip_address":"","ucode":"D179E68D87CC50","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/c8/8e6dc340.jpg","comment_is_top":false,"comment_ctime":1576477295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576477295","product_id":100039001,"comment_content":"控制反转不仅可以用在代码设计上，也可以用在架构设计上。比如分布式环境中，要做一个限频功能，如果每个系统每个接口都自己实现限流算法和频次，就会难以管理和控制，但是如果把限频的功能都反转到一个独立的系统，接口每次被调用之前都去问询该系统，情况就会好得多。","like_count":0},{"had_liked":false,"id":162173,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1576471066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576471066","product_id":100039001,"comment_content":"个人认为：<br>1.基于接口编程而非实现编程是一种设计思想，用以提高程序的扩展性。依赖注入是控制反转的一种实现方式，主要用于简化我们项目的开发。<br>2.依赖注入在遵守基于接口编程而非实现编程原则的基础上去实现，会提高程序的扩展性。","like_count":0},{"had_liked":false,"id":162172,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1576470960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576470960","product_id":100039001,"comment_content":"基于接口而非实现编程:主要是为了应对变化，提升扩展性。<br>依赖注入: 主要是为了减少依赖，把互相之间的依赖关系，通过配置或少量代码描述出来。比如spring直接注入一个实现类A。某一天换成B的时候，违反了基于接口编程，但是还符合依赖注入。<br>共同目的:都是为了增加扩展性","like_count":0},{"had_liked":false,"id":162166,"user_name":"quietwater","can_delete":false,"product_type":"c1","uid":1055029,"ip_address":"","ucode":"C25E2CD356D3F9","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/35/be8372be.jpg","comment_is_top":false,"comment_ctime":1576469419,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576469419","product_id":100039001,"comment_content":"从 Notification 这个例子来看，“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？依赖注入主要解决创建对象的问题，对象的依赖关系具体实现，是对象的生命周期管理。基于接口编程是我们要依赖抽象不要依赖具体实现，是面向抽象编程，是解决依赖关系的策略。","like_count":0},{"had_liked":false,"id":162164,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1576468776,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576468776","product_id":100039001,"comment_content":"接口是一种契约形式的编程约定，给依赖注入落地的提供手段，方便编译器进行检查。<br>依赖契约优先。","like_count":0},{"had_liked":false,"id":162149,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1576466998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576466998","product_id":100039001,"comment_content":"课堂讨论Answer：<br><br><br><br>基于接口而非实现编程 是 里氏替换原则（Liskov Substitution Principle）理论下的具体实践，“依赖注入”是 依赖倒置原则（Dependency Injection Principle）理论下的具体实践。<br><br><br><br>关于两者的联系：<br><br>“基于接口而非实现编程”和”依赖注入“都是抽象理论指导下的编码实践，而且关注核心问题都是：依赖抽象。<br><br><br><br>关于两者的区别：<br><br>”基于接口而非实现编程“在具体实践上更强调接口与实现类的契约关系，即接口指导并约束实现类的职责，实现类负责在接口的指导下完成符合规范的功能。<br><br>而”依赖注入“在编码上更关注类与类之间的依赖关系，应该依赖抽象，而不是依赖具体。","like_count":0},{"had_liked":false,"id":162141,"user_name":"kyle","can_delete":false,"product_type":"c1","uid":1631655,"ip_address":"","ucode":"53F0E544933798","user_header":"https://static001.geekbang.org/account/avatar/00/18/e5/a7/bf2ca8fc.jpg","comment_is_top":false,"comment_ctime":1576466346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576466346","product_id":100039001,"comment_content":"依赖注入指的是编程的思想，有很多种方法实现DI, 对于c# 文中的例子是构造函数输入，也可以是通过属性输入，等等。","like_count":0},{"had_liked":false,"id":162126,"user_name":"SMTCode","can_delete":false,"product_type":"c1","uid":1109038,"ip_address":"","ucode":"0D837A753E4FAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/2e/49d13bd2.jpg","comment_is_top":false,"comment_ctime":1576464273,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576464273","product_id":100039001,"comment_content":"控制反转 (IOC: Inversion Of Control):<br><br>控制反转框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员在利用框架进行开发时，只需要往框架的预留点上，添加跟自己业务相关的代码，就可以利用这个框架来驱动整个程序流程的执行。<br><br>即：在框架中实现业务逻辑的控制流程，程序员只需要添加具体的业务逻辑即可，减少业务逻辑与控制逻辑的耦合。<br>依赖注入 (DI: Dependency )<br><br>不通过new的方式在类内部创建对象，而是将依赖的对象在外部创建好后，通过构造函数、函数参数等方式，将对象传递给类使用。<br><br>这样可以提高代码的扩展性，可以灵活替换依赖的类。<br>依赖注入框架(DI Framework):<br><br>通过依赖注入框架的扩展点，简单配置一下所有需要的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。<br>依赖翻转原则(DIP: Dependency Inversion Principle):<br><br>High-level modules shouldn&#39;t depend on low-level modules.<br>Both modules should depend on abstractions. <br>In addition, abstractions shouldn&#39;t depend details.<br>Details should depend abstractions.<br><br>高层模块不应当依赖低层模块。<br>高层模块和低层模块都应依赖于抽象。<br>此外，抽象不能依赖于细节。<br>细节应当依赖于抽象。<br><br>这条原则主要是针对框架而言的，在日常的业务逻辑中，高层模块还是要依赖低层模块的。","like_count":0},{"had_liked":false,"id":162114,"user_name":"潜默闻雨","can_delete":false,"product_type":"c1","uid":1323147,"ip_address":"","ucode":"E597ECBC0A1BB5","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/8b/3334f23e.jpg","comment_is_top":false,"comment_ctime":1576463062,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1576463062","product_id":100039001,"comment_content":"现实工程中的依赖反转：银行网贷项目。银行定义为高层（资金方），各大网贷平台定义为底层（资产方，各种网贷app）。银行想放贷款赚钱，这个时候就去找各大网贷app去商议，你们帮我提供客户，我给你们钱。然后银行便一个一个的对接网贷app，每联系一个就谈一次需求，网贷app千万多，奈何我银行没几个。然后，资金方发现自己依赖于每一个资产方，一旦资产方有什么业务变动，资金方自己必须也做响应调整，实属麻烦。这个时候突然跳出个中间商（可以理解为抽象），说资金方资产方，你们的业务我来帮你解决吧，我提供一个平台，定义一套标准，资金方你只管给钱，资产方你只管提供客户借钱，保证让每个客户都贷到款。这下整个生产线便十分通畅了，资金方也不会因为资产方的业务调整而做调整了，所有的变动都由这个中间商来解决了，资金方就是放放放，资产方就是借借借，其他不再关注。这个是自己在做的项目，我们就是那个中间商。突然联想到，感觉这样比喻应该没问题😁。顺便提醒下，网贷app利率都高的很，银行贷款利率要低很多（没事别乱用网贷，跟高利贷没啥区别，就算是大平台，依然高的很）","like_count":0,"discussions":[{"author":{"id":1631655,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e5/a7/bf2ca8fc.jpg","nickname":"kyle","note":"","ucode":"53F0E544933798","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85305,"discussion_content":"具体实现是不是，你们作为中间方，针对资金方和资产方各提供一套接口，他们各自实现就可以了？ 新的app只要按照接口实现即可。资金划拨是实时的还是通过中间的保证金？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576538585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1323147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/8b/3334f23e.jpg","nickname":"潜默闻雨","note":"","ucode":"E597ECBC0A1BB5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1631655,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e5/a7/bf2ca8fc.jpg","nickname":"kyle","note":"","ucode":"53F0E544933798","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85485,"discussion_content":"接口由中间商各自跟资金方资产方对接设计。资金划拨一部分是实时风控实时放款，一部分是保证金那种，资产方批量推送资金方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576549020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85305,"ip_address":""},"score":85485,"extra":""}]}]},{"had_liked":false,"id":162112,"user_name":"your problem？","can_delete":false,"product_type":"c1","uid":1457464,"ip_address":"","ucode":"6E096E7958CFD7","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/38/6f02a4b9.jpg","comment_is_top":false,"comment_ctime":1576462905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576462905","product_id":100039001,"comment_content":"思考题：<br>区别：基于接口而非实现编程是一种指导原则，描述的是从细节上的一个函数，到宏观上的系统对接不应该依赖于具体实现而是依赖于抽象的接口对接，而依赖注入则是指不从内部建立具体的类依赖而将依赖通过注入或者传参等方式导入，是一种通过抽象降低依赖的具体编码实现<br>联系：可以通过基于接口编程思想来实现依赖注入（依赖注入框架就是这么做的）<br>不知道理解的有问题没有，请老师和大家来指点一下","like_count":0},{"had_liked":false,"id":162109,"user_name":"划时代","can_delete":false,"product_type":"c1","uid":1061454,"ip_address":"","ucode":"9554CE2F83B77F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2o1Izf2YyJSnnI0ErZ51pYRlnrmibqUTaia3tCU1PjMxuwyXSKOLUYiac2TQ5pd5gNGvS81fVqKWGvDsZLTM8zhWg/132","comment_is_top":false,"comment_ctime":1576462595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576462595","product_id":100039001,"comment_content":"控制反转、依赖注入、依赖反转原则，已经在我设计开发的开发框架中熟练运用了，线上产品运行稳定，但我却不知道它们的名字。先知道框架代码的设计实现方式，后知道设计模式概念。后知后觉。","like_count":0},{"had_liked":false,"id":162108,"user_name":"Askerlve","can_delete":false,"product_type":"c1","uid":1178535,"ip_address":"","ucode":"BF29F9A8674507","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/a7/12c90699.jpg","comment_is_top":false,"comment_ctime":1576462360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576462360","product_id":100039001,"comment_content":"打开，讲得好～","like_count":0},{"had_liked":false,"id":162104,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1576461915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576461915","product_id":100039001,"comment_content":"以前也学过几次，每次都是了解的一知半解，回头就忘记，这回听完还是这种感觉，可能要多看这些名字，然后对应的代码，反复思考，循环记忆啊，这回一定要加深理解，行程条件反射。","like_count":0},{"had_liked":false,"id":162098,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1576461083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576461083","product_id":100039001,"comment_content":"我觉得依赖注入是基于面相接口编程这种思想的吧。<br>在举个与题解无关的例子，就是spring怎么做到不去new的，他将抽象指向具体实现这一步放到了配置文件里，然后利用工厂模式完美解耦合。","like_count":0},{"had_liked":false,"id":162095,"user_name":"liu_liu","can_delete":false,"product_type":"c1","uid":1019138,"ip_address":"","ucode":"24283806A07759","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","comment_is_top":false,"comment_ctime":1576461030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576461030","product_id":100039001,"comment_content":"依赖注入可以采用“基于接口编程”原则来实现","like_count":0},{"had_liked":false,"id":162094,"user_name":"逆风星痕","can_delete":false,"product_type":"c1","uid":1420482,"ip_address":"","ucode":"1E18E46E8DA58E","user_header":"https://static001.geekbang.org/account/avatar/00/15/ac/c2/aec60ae2.jpg","comment_is_top":false,"comment_ctime":1576460897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576460897","product_id":100039001,"comment_content":"两者都是为了提高代码的可扩展性，依赖注入是一个更全的指导原则，基于接口而非实现编程可以看着是其的一种实现，同时也进行了扩展。","like_count":0},{"had_liked":false,"id":162088,"user_name":"峰峰","can_delete":false,"product_type":"c1","uid":1262507,"ip_address":"","ucode":"E2207B6E68F255","user_header":"https://static001.geekbang.org/account/avatar/00/13/43/ab/ec100d05.jpg","comment_is_top":false,"comment_ctime":1576460064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576460064","product_id":100039001,"comment_content":"基于接口而非实现编程是对类设计的一种思想原则，依赖注入是具体的编码实现。<br>其中，依赖注入通过参数化的方式解决了在类中直接new对象的过程，也是解决了类与类的耦合。<br>不过，基于依赖注入在方法定义上使用具体的实现类的话，那么扩展性的问题没有解决。我们往往使用多态这一特性使得父类对象引用子类对象的方式达到好的扩展性。<br>因此，依赖注入的实现是在基于接口而非实现编程的设计原则之上的一种具体编程实现。","like_count":0},{"had_liked":false,"id":162079,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1576458937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576458937","product_id":100039001,"comment_content":"基于接口而非实现编程是一种编程思想，依赖注入是一种编程技巧，前者依赖后者。如果不用依赖注入，那就必须在调用类内部创建被调用类的对象，这样一来，被调用类就只能是一个具体的类而不能是一个接口，基于接口而非实现编程就无从谈起了","like_count":0},{"had_liked":false,"id":162076,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1576458713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576458713","product_id":100039001,"comment_content":"共同点：它们都需要一起维护和遵守一份规则。<br>区别点：基于接口非实现，重在说定义一份规则；而后者，侧重说，你要如何遵守依赖注入的规则。","like_count":0},{"had_liked":false,"id":162074,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1576458697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576458697","product_id":100039001,"comment_content":"依赖注入是一种具体方式，而基于接口而非实现编程是一种思想，两者搭配可以更灵活使用依赖注入，让代码的拓展性变得更好","like_count":0},{"had_liked":false,"id":162069,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1576458349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576458349","product_id":100039001,"comment_content":"一直用spring，从未如此清晰理解ioc和di。学习了","like_count":0},{"had_liked":false,"id":162045,"user_name":"Xs.Ten","can_delete":false,"product_type":"c1","uid":1128376,"ip_address":"","ucode":"2368B9BDDDEE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/b8/c887a5ea.jpg","comment_is_top":false,"comment_ctime":1576455963,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576455963","product_id":100039001,"comment_content":"“基于接口而非实现编程”是一种编程思想，而依赖注入是“基于接口而非实现编程”的具体实现。","like_count":0},{"had_liked":false,"id":162042,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1576455237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576455237","product_id":100039001,"comment_content":"依赖注入是被动的，框架提程序员做了管理bean的事，基于接口而实现限编程是主动的，是程序员自己控制的","like_count":0},{"had_liked":false,"id":162040,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1576455103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576455103","product_id":100039001,"comment_content":"一个是设计思想，一个是编码技巧。目的都是为了解耦合，不要直接依赖，而是通过上层抽象关联，这样服务方的改动，并不会影响调用方的使用。最终还是一个开闭原则。","like_count":0},{"had_liked":false,"id":162038,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1576454757,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576454757","product_id":100039001,"comment_content":"控制反转和基于接口编程都不依赖具体的实现细节","like_count":0},{"had_liked":false,"id":162030,"user_name":"Aaron Cheung","can_delete":false,"product_type":"c1","uid":1079816,"ip_address":"","ucode":"03972759C53667","user_header":"https://static001.geekbang.org/account/avatar/00/10/7a/08/4d3e47dd.jpg","comment_is_top":false,"comment_ctime":1576452595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576452595","product_id":100039001,"comment_content":"起床打个卡","like_count":0},{"had_liked":false,"id":162059,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1576457216,"is_pvip":false,"discussion_count":8,"race_medal":1,"score":"1564944552960","product_id":100039001,"comment_content":"课后思考：<br>“基于接口而非实现编程”与“依赖注入”的联系是二者都是从外部传入依赖对象而不是在内部去new一个出来。<br>区别是“基于接口而非实现编程”强调的是“接口”，强调依赖的对象是接口，而不是具体的实现类；而“依赖注入”不强调这个，类或接口都可以，只要是从外部传入不是在内部new出来都可以称为依赖注入。","like_count":365,"discussions":[{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93245,"discussion_content":"Your comment makes perfect sense! 依赖注入与基于接口编程的联系，我理解还有一点，值得提一下。赞成您说的依赖注入本身不强调接口或是实现，但是通常情况下依赖注入加上基于接口威力更大，接口把依赖抽象化，传入不同对接口的实现可以很好实现对扩展开放的原则。个人理解😺","likes_number":37,"is_delete":false,"is_hidden":false,"ctime":1576916690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1838042,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/0b/da/34be57e8.jpg","nickname":"趣稚鬼👻","note":"","ucode":"8AE6776DCA8541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201308,"discussion_content":"到位","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583769354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":93245,"ip_address":""},"score":201308,"extra":""},{"author":{"id":1033096,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","nickname":"如来神掌","note":"","ucode":"45E20FF935BD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283393,"discussion_content":"优秀👏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592266799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":93245,"ip_address":""},"score":283393,"extra":""}]},{"author":{"id":1237327,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","nickname":"Remember九离","note":"","ucode":"97EE6E6344689F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270800,"discussion_content":"一语中的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590056609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334583,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5d/37/061e7fac.jpg","nickname":"小苗晓雪","note":"","ucode":"B15FDF455853D2","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549680,"discussion_content":"说的非常有道理~学习了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644204279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209027,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584601753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1017181,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","nickname":"程序袁帅","note":"","ucode":"C281CA64EC91A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160777,"discussion_content":"「而“依赖注入”不强调这个，类或接口都可以」这个我有点疑问请教，依赖注入可以注入接口吗？如果可以，接口如何实例化？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580827204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1560281,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ce/d9/e3fc735c.jpg","nickname":"leo","note":"","ucode":"AAF0F90D8A2481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1017181,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","nickname":"程序袁帅","note":"","ucode":"C281CA64EC91A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222794,"discussion_content":"”注入的是接口“，这句话指的只是注入了实现了这个接口（行为）的对象。在程序运行过程中，无论是原先定义的是接口还是类，实际上在这一层都应该是对象，所以不存在实例化的问题（可以认为执行到注入这一层，一定是在某个地方实例化了），运行过程中，Class对象才是描述类或接口信息的。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1586175251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":160777,"ip_address":""},"score":222794,"extra":""}]}]},{"had_liked":false,"id":162035,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1576454046,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"602871875486","product_id":100039001,"comment_content":"区别:<br>1.依赖注入是一种具体编程技巧，关注的是对象创建和类之间关系，目的提高了代码的扩展性，我们可以灵活地替换依赖的类。<br>2.基于接口而非实现编程是一种设计原则，关注抽象和实现，上下游调用稳定性，目的是降低耦合性，提高扩展性。<br><br>联系:<br>都是基于开闭原则思路，提高代码扩展性！","like_count":141,"discussions":[{"author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375735,"discussion_content":"其实依赖注入也是一种基于接口而非实现编程的一种实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621836827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162097,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1576461078,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"452548027158","product_id":100039001,"comment_content":"依赖倒置原则概念是高层次模块不依赖于低层次模块。看似在要求高层次模块，实际上是在规范低层次模块的设计。<br><br>低层次模块提供的接口要足够的抽象、通用，在设计时需要考虑高层次模块的使用种类和场景。<br><br>明明是高层次模块要使用低层次模块，对低层次模块有依赖性。现在反而低层次模块需要根据高层次模块来设计，出现了「倒置」的显现。<br><br>这样设计好处有两点：<br><br>1. 低层次模块更加通用，适用性更广<br>2. 高层次模块没有依赖低层次模块的具体实现，方便低层次模块的替换<br><br>思考题：<br><br>基于接口而非实现编程，是一种指导编码的思想。依赖注入是它的一种具体应用。<br><br>个人理解，仅供参考~","like_count":106,"discussions":[{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289623,"discussion_content":"依赖反转，高层不依赖低层，但也不是说低层就要依赖高层；低层和高层依赖的抽象接口是一种解耦","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1594167788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2528121,"avatar":"https://static001.geekbang.org/account/avatar/00/26/93/79/9efa9c11.jpg","nickname":"星溯","note":"","ucode":"A185ACCDE20723","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363720,"discussion_content":"低层次模块不需要为高层次模块考虑而设计接口，接口（协议）所有权属高层模块，低层只负责实现，才是真正的依赖倒置/反转","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1617269570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286802,"discussion_content":"是的，高层提需求给低层，高层与低层通过接口抽象来调用\n以往是高层依赖于低层(低层具体实现)，缺点：低层变动会影响高层\n从根本上来讲，低层是服务提供方，应该依赖于高层的最终诉求，而这个诉求就是接口抽象","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1593302000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1681459,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a8/33/b71635c1.jpg","nickname":"锋子","note":"","ucode":"89FFA85BDB1C99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321624,"discussion_content":"一样的想法，看到高层不依赖低层次，还有点懵逼，感觉倒过来更像是现实。 但其实这个没啥意义，就是一个说法，知道意思就行了。 感觉是调用方依赖被调用的，被调用的尽量更通用，让上层可以不那么依赖自己。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604598128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062444,"avatar":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","nickname":"小喵喵","note":"","ucode":"FDBBB2A59DB8B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85739,"discussion_content":"在数据结构与算法之美专栏每次总结的都很好，现在又在这里遇见你。也期待每次的总结。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576570750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062444,"avatar":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","nickname":"小喵喵","note":"","ucode":"FDBBB2A59DB8B6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101789,"discussion_content":"争取多总结，一起加油。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577290262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85739,"ip_address":""},"score":101789,"extra":""}]},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269907,"discussion_content":"原文: https://www.cnblogs.com/wod-Y/p/12746794.html\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589960904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1191955,"avatar":"https://static001.geekbang.org/account/avatar/00/12/30/13/d5fe9d3f.jpg","nickname":"memorylose","note":"","ucode":"2C2F61F960B0A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253360,"discussion_content":"精彩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588229853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220617,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","nickname":"Six","note":"","ucode":"E297BB638B2BD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216517,"discussion_content":"兄弟总结的很到位。给你个赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585459504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","nickname":"沐夜星光","note":"","ucode":"22F699E237B179","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114321,"discussion_content":"看文章，还不太明白，什么依赖，怎么反转了，你这一说懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577968510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236569,"avatar":"https://static001.geekbang.org/account/avatar/00/12/de/59/ceea56a9.jpg","nickname":"Nan","note":"","ucode":"A3DEC678BF814D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101217,"discussion_content":"给你点赞，看你评论让我顿悟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577285542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1236569,"avatar":"https://static001.geekbang.org/account/avatar/00/12/de/59/ceea56a9.jpg","nickname":"Nan","note":"","ucode":"A3DEC678BF814D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101790,"discussion_content":"对大家有帮助也是我留言的动力…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577290323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":101217,"ip_address":""},"score":101790,"extra":""}]}]},{"had_liked":false,"id":162052,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1576456677,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"186260050405","product_id":100039001,"comment_content":"1⃣️控制反转是一种编程思想，把控制权交给第三方。依赖注入是实现控制反转最典型的方法。<br>2⃣️依赖注入（对象）的方式要采用“基于接口而非实现编程”的原则，说白了就是依赖倒转。<br>3⃣️低层的实现要符合里氏替换原则。子类的可替换性，使得父类模块或依赖于抽象的高层模块无需修改，实现程序的可扩展性。","like_count":44,"discussions":[{"author":{"id":1838042,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/0b/da/34be57e8.jpg","nickname":"趣稚鬼👻","note":"","ucode":"8AE6776DCA8541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201316,"discussion_content":"第三点还是很✔","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583769481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88646,"discussion_content":"控制反转是上层不依赖下层吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576722611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88663,"discussion_content":"额额，这是是依赖反转(倒转)？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576723469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":88646,"ip_address":""},"score":88663,"extra":""}]}]},{"had_liked":false,"id":171313,"user_name":"Maurice","can_delete":false,"product_type":"c1","uid":1729796,"ip_address":"","ucode":"A35112AA415C67","user_header":"","comment_is_top":false,"comment_ctime":1578900817,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"130427919697","product_id":100039001,"comment_content":"“相对于细节的多变性,抽象的东西要稳定的多”，个人认为吃透这句话就够了。","like_count":31},{"had_liked":false,"id":162036,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1576454055,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"117540571047","product_id":100039001,"comment_content":"原来的模式是一个spring开发的项目放在Tomcat中，控制权在Tomcat手中。现在微服务兴起，大家都用springboot开发。此时是Tomcat在springboot项目当中。控制权在springboot手中，虽然只是表面上。这便是控制反转。<br><br>这是一场控制权争夺之战。","like_count":26,"discussions":[{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312530,"discussion_content":"可以采用 Visitor中进行default方法的visit()\n每个实现类（操作类）自由选择是否实现 visit() ，来避免你的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602729017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162829,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1576597544,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"96065878056","product_id":100039001,"comment_content":"课堂讨论：这两个概念没什么关系，讲的不是一个事。依赖注入讲的是一个对象如何获得它运行所依赖的对象，所谓依赖注入就是不需要自己去new，让框架注入进来；基于接口而不是实现编程讲的是抽象思维的应用，利用编程，可以屏蔽掉底层具体实现改变导致上层改变的问题。<br><br>文中的那个例子，只是恰好同时使用了依赖注入这个编程技巧，同时也实践了基于接口而非实现编程这个原则。","like_count":23,"discussions":[{"author":{"id":1007330,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/e2/1fad3052.jpg","nickname":"Jemmy","note":"","ucode":"A979F4A5210225","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224958,"discussion_content":"ResourceFile 是抽象类，如果一个ResourceFile对象指向PdfFile，如何根据ResourceFile 对象获取PDF类型，并调用PdfExtractStartegy呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586339697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1007330,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/e2/1fad3052.jpg","nickname":"Jemmy","note":"","ucode":"A979F4A5210225","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":227144,"discussion_content":"判断具体子类型再执行相应逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586470240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224958,"ip_address":""},"score":227144,"extra":""},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312529,"discussion_content":"那如何进行foreach遍历执行呢，有100个文件，我想一次就for循环结束掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602729002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227144,"ip_address":""},"score":312529,"extra":""}]}]},{"had_liked":false,"id":162371,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1341964,"ip_address":"","ucode":"88440A9C773832","user_header":"https://static001.geekbang.org/account/avatar/00/14/7a/0c/5abd1cf9.jpg","comment_is_top":false,"comment_ctime":1576505495,"is_pvip":false,"replies":[{"id":"62282","content":"tomcat的例子不算啊","user_name":"作者回复","comment_id":162371,"uid":"1190123","ip_address":"","utype":1,"ctime":1576804038,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"87475851415","product_id":100039001,"comment_content":"DIP原则有点嘎然而止的感觉，缺少了一个具体的例子。","like_count":20,"discussions":[{"author":{"id":1294908,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","nickname":"杜威","note":"","ucode":"CF49380E27467F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573735,"discussion_content":"我也想到了桥接模式。桥接模式也是分离实现和继承关系。不过访问者更侧重于如何扩展实现。这么看，又会有点像装饰器模式。但是装饰器模式不侧重对一组类进行功能扩展。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653619597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162010,"user_name":"KIM","can_delete":false,"product_type":"c1","uid":1113766,"ip_address":"","ucode":"189216730D37F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/a6/bb3d76e6.jpg","comment_is_top":false,"comment_ctime":1576429066,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"70295905802","product_id":100039001,"comment_content":"感觉比head first设计模式讲的清晰","like_count":16,"discussions":[{"author":{"id":1476665,"avatar":"https://static001.geekbang.org/account/avatar/00/16/88/39/d420a588.jpg","nickname":"小马过河","note":"","ucode":"89451C0545EA11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284460,"discussion_content":"head first博大精深，需要反复食用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592537321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190170,"avatar":"https://static001.geekbang.org/account/avatar/00/12/29/1a/87f11f3d.jpg","nickname":"JackPn","note":"","ucode":"0A207AF8D39F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115376,"discussion_content":"head First讲的是实战，这个专栏截至目前基本都是理论，没法比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578013071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1590154,"avatar":"","nickname":"Geek_ed366d","note":"","ucode":"EADF432AE2DA79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190170,"avatar":"https://static001.geekbang.org/account/avatar/00/12/29/1a/87f11f3d.jpg","nickname":"JackPn","note":"","ucode":"0A207AF8D39F76","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287703,"discussion_content":"这里实战更多啊\n比如这一个个例子，都是业务开发的真实场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593513614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":115376,"ip_address":""},"score":287703,"extra":""}]},{"author":{"id":1464006,"avatar":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","nickname":"斐波那契","note":"","ucode":"85E2EBC01392B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98477,"discussion_content":"我也看head first这本书 head first主要是用轻松的方式循序渐进地介绍设计模式 而这里就是更细节地讲解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577165945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93246,"discussion_content":"啊是吗？😹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576916734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252160,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1602151134,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"57436725982","product_id":100039001,"comment_content":"从 Notification 这个例子来看，“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？<br>A：依赖注入是一种具体编码技巧，其主要目的有两点：<br>1.\t将依赖关系建立的位置，从类的内部向上移动到类的入口（构造函数，或非构造函数的其他方法的参数），或者放到框架层面来支持（框架支持依赖关系的配置，对象创建，管理对象声明周期——根据对象被引用的记数实现）。<br>2.\t通过改变依赖关系建立的位置，将创建被依赖对象的任务移动到类的外部，从而简化了类的作者的负担：一方面是创建对象的负担，另一方面是管理依赖的负担<br>“基于接口而非实现编程“是一种编程原则，通过接口引入中间层，实现依赖关系的解耦。这是一个非常宽泛的原则，可以细化为多项原则，比如接口隔离原则（强调接口的功能单一特性，即通过分解支持功能的灵活细粒度扩展），里氏替换原则（强调接口的行为一致性，保证接口上层代码逻辑的简单性），开闭原则（强调接口的抽象特性，即通过多态特性实现功能的扩展）。<br>用一句话来概括：“基于接口而非实现编程”是让依赖变弱，而“依赖注入”是让依赖转移，两者相互补充，可以方便的结合起来使用。","like_count":13,"discussions":[{"author":{"id":2323679,"avatar":"https://static001.geekbang.org/account/avatar/00/23/74/df/6c4c970c.jpg","nickname":"刘胜","note":"","ucode":"2ED796A94E1C8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328110,"discussion_content":"你这个才是解释最清楚的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606057141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162058,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1576457195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35936195563","product_id":100039001,"comment_content":"区别:<br>基于接口而非实现编程:是面向对象编程的一种方式.减少对外部的依赖,还可以提升代码的灵活性,扩展及修改时可以控制风险的传播,符合开闭原则.<br>依赖注入:是一种具体的编码技巧,属于编程规范的范畴.不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。<br>联系:<br>两者结合在一起可以实现代码的灵活性,减少对外部的依赖,提升代码的可维护性&#47;可扩展性.<br>课外感想:<br>非常喜欢王争老师这样有深度内涵的课程,概念理解深入透彻,宏观方向把握准确,跟着老师的课程更有信心去挑战阿里这样一流企业的工作.报告老师,我归队了.","like_count":8},{"had_liked":false,"id":162162,"user_name":"帆大肚子","can_delete":false,"product_type":"c1","uid":1529040,"ip_address":"","ucode":"3DB11DB2FA1802","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/d0/4e1fc664.jpg","comment_is_top":false,"comment_ctime":1576468665,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31641239737","product_id":100039001,"comment_content":"在我看来，“依赖注入”是“基于接口而非实现编程”的一个实践。<br>“基于接口而非实现编程”是一条设计原则，可以帮助我们诞生更多类似于“依赖注入”的实践","like_count":7,"discussions":[{"author":{"id":2162521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MaX06SRk19zM2lAaymYylpXD6LMtIPFlDyxZKgRhmZCjhNE4nIdDGBmh08razhebVCgAv54xialYBBIIwmleBew/132","nickname":"Geek_6d1382","note":"","ucode":"B61E65CFEB684F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312457,"discussion_content":"同感哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602689756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175774,"user_name":"程序袁帅","can_delete":false,"product_type":"c1","uid":1017181,"ip_address":"","ucode":"C281CA64EC91A7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","comment_is_top":false,"comment_ctime":1580826473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27350630249","product_id":100039001,"comment_content":"基于接口中的接口不是特指是编程语言中的接口，代表的是抽象。<br><br>1. 面向抽象编程，它强调的核心是抽象思维，解决的核心问题是程序的可扩展性。<br>2. 依赖注入，它强调的核心对象的管理，解决的核心问题释放程序员生产力，程序员不用花太多经历管理琐碎的对象创建和生命周期管理，将精力花在具有价值的业务上。","like_count":6},{"had_liked":false,"id":162142,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1576466354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27346270130","product_id":100039001,"comment_content":"控制反转：控制指的是程序流程的控制，反转是指程序的流程的控制权由程序员转移到框架<br>依赖注入：上层类依赖底层类执行业务，以前往往将底层类作为上层类的成员变量，在上层类的内部声明底层类。注入就是底层类在外边声明，通过接口的方式注入到上层类中<br>依赖反转原则：我的理解是模块的解耦。上层模块依赖于低等模块，通过抽象出一套规则或者接口，使得上层业务依赖于抽象规则，低层业务实现规则。<br><br>我觉得基于接口编程与依赖反转原则比较类似，区别的话，依赖反转原则，依赖的不一定非得是接口，也许是一套规则，比如老师举的tomcat与java服务的例子","like_count":5},{"had_liked":false,"id":162032,"user_name":"progyoung","can_delete":false,"product_type":"c1","uid":1014692,"ip_address":"","ucode":"0B4898AE78F9F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/a4/24955994.jpg","comment_is_top":false,"comment_ctime":1576453389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27346257165","product_id":100039001,"comment_content":"依赖注入标价 25 美元，实际上只值 5 美分。形象啊，不能被貌似高大上的概念给唬住了，产生畏难心理。","like_count":6},{"had_liked":false,"id":178302,"user_name":"木子00","can_delete":false,"product_type":"c1","uid":1314724,"ip_address":"","ucode":"8F78CA722EB29B","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","comment_is_top":false,"comment_ctime":1581655277,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"23056491757","product_id":100039001,"comment_content":"还是没有彻底搞懂!!!<br>只是懂了文字上.","like_count":5,"discussions":[{"author":{"id":1015189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","nickname":"我是曾经那个少年","note":"","ucode":"9F02F7FF147D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396022,"discussion_content":"想想JDBC规范和Servlet规范EJB规范这些就明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632382212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020529,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/71/9fd7cd7a.jpg","nickname":"Daniel","note":"","ucode":"282E09B3146501","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365050,"discussion_content":"随着工程项目多了，就好理解了，我都是通过之前工程经验去理解今天的课，就很好理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617694673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2234620,"avatar":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","nickname":"江南一笑","note":"","ucode":"E38938A1178827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336858,"discussion_content":"课程确实抽象了，只能在项目中慢慢理解了。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608717497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162000,"user_name":"MindController","can_delete":false,"product_type":"c1","uid":1159113,"ip_address":"","ucode":"3B9CECCD12CF6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/c9/d9c72c60.jpg","comment_is_top":false,"comment_ctime":1576427247,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23051263727","product_id":100039001,"comment_content":"深夜打卡","like_count":5},{"had_liked":false,"id":162060,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1576457260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18756326444","product_id":100039001,"comment_content":"这个专栏确实讲解的非常细致！争哥确实是用心做专栏！以前对很多类似的概念都没理解透彻，通过这个专栏完全明白了！","like_count":4},{"had_liked":false,"id":162020,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576443783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18756312967","product_id":100039001,"comment_content":"控制反转的本质是分拆控制代码和具体执行代码，控制代码放在较高的层次上，也可能交给第三方类库，实现代码放在较低的层次上，通常是一个接口的实现。<br><br>依赖反转本质是分拆类中的new语句，因为new语句引入了对实现类构造函数的依赖，属于很强的依赖。分拆之后构造和实现放在另外一个类里（通常交给第三方类库），使用的地方引用接口。依赖反转可以拆分类的依赖关系，可以减少实现类的引用，用接口取代，实现接口和实现的分离。依赖反转和基于接口而非实现的原则类似，两者都倾向于依赖接口而非具体类。不同点在于，前者更关注类层次中的依赖关系以及对构造函数的依赖，尽量避免高层次的类依赖底层的实现，尽量避免对构造函数的依赖。后者，更强调类的使用的地方，尽量使用更抽象更宽泛的接口，而非更具体更细节的实现，使得信息隐藏和抽象。<br><br>控制反转和依赖反转都是有成本的，会破坏代码的内聚性和简洁性，需要权衡使用。<br>","like_count":4},{"had_liked":false,"id":219031,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1589935458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14474837346","product_id":100039001,"comment_content":"这句话没理解，这句话强调的是对”流程”控制的反转(比如使用模板方法设计模式)，但是依赖注入是怎么实现流程控制的反转的？从老师的例子上没有看出来，依赖注入只是把对象创建的权利交给了框架，而不是流程控制权利。<br><br>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。<br><br>","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510694,"discussion_content":"嗯嗯 加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286368,"user_name":"星溯","can_delete":false,"product_type":"c1","uid":2528121,"ip_address":"","ucode":"A185ACCDE20723","user_header":"https://static001.geekbang.org/account/avatar/00/26/93/79/9efa9c11.jpg","comment_is_top":false,"comment_ctime":1617269468,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10207204060","product_id":100039001,"comment_content":"感觉还是依赖倒置这个翻译更为合适<br>还有最关键的一点感觉老师可以展开讲解的是：依赖倒置的精髓，在于接口&#47;抽象所有权的倒置，高层不依赖低层，其实需要把低层的能力&#47;协议抽象成接口，并且接口所有权属于高层，这样就能真正做到对高层的复用，而不依赖低层的实现细节，如果只是高层依赖低层的抽象&#47;接口，那不是真正的依赖倒置。<br>可以结合好莱坞原则“Dont call me, I will call you”来理解，应用程序不需要调用Tomcat&#47;Spring这样的框架来实现什么交互，而是由Tomcat&#47;Spring拥有协议，应用程序实现此协议（比如实现Servlet接口），来完成交互","like_count":3,"discussions":[{"author":{"id":2415980,"avatar":"","nickname":"Geek_9bd83c","note":"","ucode":"0CACC79030FCBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590717,"discussion_content":"接口由高层定义。\n如果由底层定义，那底层可以修改约定接口……但是这个改动权限就是应该高层来决定的，底层只负责实现细节。\n解决了我一直以来的疑惑！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666035346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224060,"user_name":"奥利奥，晴天。","can_delete":false,"product_type":"c1","uid":1478996,"ip_address":"","ucode":"9CA5E2C3C2D054","user_header":"https://static001.geekbang.org/account/avatar/00/16/91/54/007a667e.jpg","comment_is_top":false,"comment_ctime":1591264005,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10181198597","product_id":100039001,"comment_content":"依赖注入的方式 特别好，结合开闭原则，很容易写出可测试的代码，以前写go语言，写个单元测试，引入数据库配置，引入配置文件，非常难测试，后来学了依赖注入这个东西，感觉代码测试，清爽干净简单了。。。","like_count":3},{"had_liked":false,"id":174299,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1580127663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10170062255","product_id":100039001,"comment_content":"基于接口而非实现编程偏向于类的实现方式，表示某个类要服从特定的契约<br>依赖注入偏向于类的管理方式，通过配置来管理类的加载","like_count":2},{"had_liked":false,"id":162011,"user_name":"iLeGeND","can_delete":false,"product_type":"c1","uid":1055475,"ip_address":"","ucode":"4055A628A6E97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","comment_is_top":false,"comment_ctime":1576429352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166363944","product_id":100039001,"comment_content":"有收获","like_count":2},{"had_liked":false,"id":283900,"user_name":"佐镜兄","can_delete":false,"product_type":"c1","uid":1062804,"ip_address":"","ucode":"18DB653A028632","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/94/723ec0e9.jpg","comment_is_top":false,"comment_ctime":1615977250,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5910944546","product_id":100039001,"comment_content":"依赖反转原则感觉还是很迷惑，上层代码不依赖底层？那上层如何调用底层？","like_count":1},{"had_liked":false,"id":193563,"user_name":"PCMD","can_delete":false,"product_type":"c1","uid":1842844,"ip_address":"","ucode":"76A1106F42AEAC","user_header":"https://static001.geekbang.org/account/avatar/00/1c/1e/9c/39f5ff2a.jpg","comment_is_top":false,"comment_ctime":1584927703,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5879894999","product_id":100039001,"comment_content":"基于接口而非实现编程,和依赖注入，其实都可以算是依赖注入。<br>可以看文中的定义 &quot;我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。&quot;  其实都是一样，只不过在 基于接口而非实现编程 更多的体现了可扩展性，体现了开放原则。并且，最终注入的也是 该接口的实现，而非单一的接口 <br>自我认为","like_count":1},{"had_liked":false,"id":181256,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582527972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877495268","product_id":100039001,"comment_content":"文中同样提到了依赖注入是一种编程技巧,是指的是对于其他类的依赖不要在类中进行new来生成,而是通过构造方法,函数参数注入进来,但没有直接说明构造函数或者参数注入进来的是一个抽象的类或者接口,其也可以注入一个实现类.但是为了保证使用抽象的思想,一般会注入接口或者抽象类,提高代码可维护性,而基于接口而非实现编程,其本质也是为了使用抽象的思想,提高代码的可维护性","like_count":1},{"had_liked":false,"id":167117,"user_name":"至今未来","can_delete":false,"product_type":"c1","uid":1632716,"ip_address":"","ucode":"ED6F557FDB0B5B","user_header":"https://static001.geekbang.org/account/avatar/00/18/e9/cc/1eb3120e.jpg","comment_is_top":false,"comment_ctime":1577694168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872661464","product_id":100039001,"comment_content":"依赖注入是种编码技巧 来提高扩展性（巧妙的构建数据流）<br>基于接口而非实现编程 是利用编程语言提供的多态属性来提高扩展性（利用编程语言自身的结构属性-多态）","like_count":1},{"had_liked":false,"id":163284,"user_name":"|･ω･｀)","can_delete":false,"product_type":"c1","uid":1636123,"ip_address":"","ucode":"34E1DF62058D80","user_header":"https://static001.geekbang.org/account/avatar/00/18/f7/1b/8036958c.jpg","comment_is_top":false,"comment_ctime":1576679815,"is_pvip":false,"replies":[{"id":"62268","content":"你网上搜下 开关的例子 那个更简单","user_name":"作者回复","comment_id":163284,"uid":"1190123","ip_address":"","utype":1,"ctime":1576797213,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5871647111","product_id":100039001,"comment_content":"关于最后一个依赖反转能再举个简单的代码例子吗？Tomcat的案例没懂˙Ⱉ˙ฅ","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478329,"discussion_content":"你网上搜下 开关的例子 那个更简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576797213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162705,"user_name":"阿顺","can_delete":false,"product_type":"c1","uid":1698258,"ip_address":"","ucode":"36F2AD6F980B11","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","comment_is_top":false,"comment_ctime":1576579334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871546630","product_id":100039001,"comment_content":"区别：依赖注入是不是使用的是多态的特性，基于接口而非实现编程使用了抽象的性，对吗","like_count":1},{"had_liked":false,"id":162610,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1576565000,"is_pvip":false,"replies":[{"id":"62281","content":"周一三五更新的","user_name":"作者回复","comment_id":162610,"uid":"1190123","ip_address":"","utype":1,"ctime":1576803528,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5871532296","product_id":100039001,"comment_content":"老师，今天怎么没更新，我已经迫不及待了。隔壁那本DDD好多词汇难理解，我受了打击，过来找安慰。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478103,"discussion_content":"周一三五更新的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576803528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162390,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1576508157,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5871475453","product_id":100039001,"comment_content":"基于接口而非实现编程（依赖倒置原则）: 高层和低层组件都使用了一样的接口，然后让接口去控制整个逻辑，这样高层组件就不会依赖于具体的低层组件实现。简单来讲，就是大家都用接口，彼此不认识。<br>依赖注入：依赖注入就是一个组件内部依赖一个对象，但是他不自己造，等别人送上来。<br>他们俩的关系就是，在依赖倒置原则指导下的设计里，组件都没有内部创造依赖的对象，全是通过外部传入的，但是也不一定是注入，有可能只是个过客（传进去用完就扔），而且注入的时候，都是以接口的形式注入的，而依赖注入并不一定是接口。","like_count":1},{"had_liked":false,"id":162316,"user_name":"再见孙悟空","can_delete":false,"product_type":"c1","uid":1025518,"ip_address":"","ucode":"57E12A2F9CD915","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/ee/6bbac848.jpg","comment_is_top":false,"comment_ctime":1576499295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871466591","product_id":100039001,"comment_content":"“基于接口而非实现编程” 和 “依赖注入” <br><br>联系 ：<br>都能实现注入功能，程序依赖的对象都能在外部事先创建而无需程序内部显示 new 。<br><br>区别：<br>“基于接口而非实现编程” 可以看作是 “依赖注入” 的一种实现方式。除了构造方法注入外，依赖注入还包括 setter 方法注入。","like_count":1},{"had_liked":false,"id":162212,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1576477893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871445189","product_id":100039001,"comment_content":"Ioc样例代码那里,抽象类TestCase 的doTest方法 应该返回布鲁尔值,而不是void","like_count":1},{"had_liked":false,"id":162147,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1576466848,"is_pvip":false,"replies":[{"id":"62285","content":"d是dip 不是lod的 lod后面有讲到","user_name":"作者回复","comment_id":162147,"uid":"1190123","ip_address":"","utype":1,"ctime":1576804341,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5871434144","product_id":100039001,"comment_content":"SOLID 的最后一个原则D，我看好多书上说是 迪米特法则 啊，为什么文章里没有提呢？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477967,"discussion_content":"d是dip 不是lod的 lod后面有讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576804341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162119,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1576463476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871430772","product_id":100039001,"comment_content":"设计模式_19<br># 作业<br>“基于接口而非实现编程”: 是一种设计原则。<br>“依赖注入”: 一种对上面原则的应用。<br><br># 感想：<br>今天的内容，一定程度上是对前面基础原则的组合式实践。<br>在依赖反转原则里，<br>“具体实现依赖抽象”，是对“基于接口而非实现编程”的实践。<br>比如“高层模块不要依赖低层模块”，是“开闭原则”的实践。<br><br>像“单一职责”、“开闭原则”等的底层原则，我们都能理解它的“字面含义”，但真正掌握它要更多的实践和更丰富的信息量，这是我理解的，为什么还要继续讲基于基础原则的实践。","like_count":1},{"had_liked":false,"id":162067,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1576457875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871425171","product_id":100039001,"comment_content":"感觉依赖反转原则是不是可以叫“依赖抽象原则”？😂，从字面意思来看我觉得可以翻译成:高层模块和低层模块及实现细节都应依赖于抽象。","like_count":1},{"had_liked":false,"id":162031,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1576452790,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5871420086","product_id":100039001,"comment_content":"区别就是依赖注入属于框架层面，接口编程属于实现层面","like_count":1},{"had_liked":false,"id":162018,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1576438625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871405921","product_id":100039001,"comment_content":"课后讨论问题正是我的疑惑😦","like_count":1},{"had_liked":false,"id":357717,"user_name":"徐志超-Klaus","can_delete":false,"product_type":"c1","uid":2343086,"ip_address":"北京","ucode":"CF26B39965F2A2","user_header":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","comment_is_top":false,"comment_ctime":1663578509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663578509","product_id":100039001,"comment_content":"可惜了，依赖反转没有小例子","like_count":0},{"had_liked":false,"id":357040,"user_name":"Geek_0d2e85","can_delete":false,"product_type":"c1","uid":2882738,"ip_address":"浙江","ucode":"D0E64BB92C6223","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKwRibg8Y6J3BQsFfyboA5Px6ibx3iaerK3ia53XiavSJQ3quO7MxdFI9pwEACurR13MkuDTNnMurBqydA/132","comment_is_top":false,"comment_ctime":1662882163,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1662882163","product_id":100039001,"comment_content":"一句话总结：控制反转要通过依赖注入来实现，而依赖注入过程中又要展现了依赖反转","like_count":0},{"had_liked":false,"id":356053,"user_name":"Geek_1","can_delete":false,"product_type":"c1","uid":2704407,"ip_address":"北京","ucode":"59300A73996D20","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/17/e4fdcaad.jpg","comment_is_top":false,"comment_ctime":1661937197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661937197","product_id":100039001,"comment_content":"高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象","like_count":0},{"had_liked":false,"id":354409,"user_name":"泽韦德","can_delete":false,"product_type":"c1","uid":1103888,"ip_address":"浙江","ucode":"948E7B067A3786","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/10/5173922c.jpg","comment_is_top":false,"comment_ctime":1660373249,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1660373249","product_id":100039001,"comment_content":"基于接口编程和依赖注入都是控制反转的表现形式，依赖注入不一定要基于接口注入，也可以基于实现类注入。基于接口编程应用范围比依赖注入范围广。","like_count":0},{"had_liked":false,"id":351594,"user_name":"zhaoxb","can_delete":false,"product_type":"c1","uid":1686527,"ip_address":"","ucode":"A392B6A3DE98B7","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/ff/86ac9581.jpg","comment_is_top":false,"comment_ctime":1657971369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657971369","product_id":100039001,"comment_content":"依赖注入在更高的层面将对象和对象的使用者解耦，使得调用者可以根据场景灵活的替换对象，而无需修改自身的代码；<br>基于接口编程，是实现依赖注入的一种手段，例如我们完全可以通过继承也能实现依赖注入需要的解耦；<br>但基于接口编程更好，因为它更纯粹，强调了调用者需要什么行为，只提供实现了这种行为的具体类给调用者即可，不需要关心更其他细节。","like_count":0},{"had_liked":false,"id":347517,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1654101379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654101379","product_id":100039001,"comment_content":"1.依赖注入是管理成员变量对象使用外部导入，不要硬编码，比如创建数据库连接<br>2.接口而非实现是面相接口编程，接口更加稳定，更加灵活，代码可以测试，","like_count":0},{"had_liked":false,"id":343352,"user_name":"Geek_天涯tobe","can_delete":false,"product_type":"c1","uid":2354145,"ip_address":"","ucode":"8C95EE164CAB70","user_header":"https://static001.geekbang.org/account/avatar/00/23/eb/e1/71bb3704.jpg","comment_is_top":false,"comment_ctime":1650795804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650795804","product_id":100039001,"comment_content":"Tomcat 这个例子在第几章","like_count":0},{"had_liked":false,"id":343206,"user_name":"Morty","can_delete":false,"product_type":"c1","uid":1026658,"ip_address":"","ucode":"C2E532741F99E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/62/78b45741.jpg","comment_is_top":false,"comment_ctime":1650706937,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650706937","product_id":100039001,"comment_content":"补充个具体的例子：<br>https:&#47;&#47;www.digitalocean.com&#47;community&#47;conceptual_articles&#47;s-o-l-i-d-the-first-five-principles-of-object-oriented-design#dependency-inversion-principle","like_count":0},{"had_liked":false,"id":342029,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1649984725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649984725","product_id":100039001,"comment_content":"“依赖注入” 更多描述的是一种编程技巧不在乎注入的是接口还是具体的实现类，<br>基于&quot;接口而非实现编程&quot;更多描述的是一种规范。这种规范关注的对象就是接口，编程的时候基于接口，可以提高代码的拓展性。符合开闭原则，对于不同的需求使用不同的接口的实现类；同时我们的编程只依赖了必要的接口 符合迪米特法则（LOD）","like_count":0},{"had_liked":false,"id":341961,"user_name":"Scorpion 刘波","can_delete":false,"product_type":"c1","uid":1609667,"ip_address":"","ucode":"DF60BC39EA8B56","user_header":"https://static001.geekbang.org/account/avatar/00/18/8f/c3/02801527.jpg","comment_is_top":false,"comment_ctime":1649932510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649932510","product_id":100039001,"comment_content":"看了三遍不知道说的啥，直到我百度了一下看到这篇，我悟了 https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;33492169","like_count":0},{"had_liked":false,"id":332454,"user_name":"Lingo","can_delete":false,"product_type":"c1","uid":1075334,"ip_address":"","ucode":"82ECA2E0533B78","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/86/348be7f8.jpg","comment_is_top":false,"comment_ctime":1643261999,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1643261999","product_id":100039001,"comment_content":"现实生活中的控制反转：<br><br>1⃣️智能家居都接入天猫精灵，给天猫精灵输入控制流程，这样给天猫精灵一个指令，它帮你完成多个任务。<br><br>2⃣️苹果手机中的【快捷指令】应用","like_count":0},{"had_liked":false,"id":332453,"user_name":"Lingo","can_delete":false,"product_type":"c1","uid":1075334,"ip_address":"","ucode":"82ECA2E0533B78","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/86/348be7f8.jpg","comment_is_top":false,"comment_ctime":1643261435,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1643261435","product_id":100039001,"comment_content":"🌟什么是控制反转？<br><br>😢控制反转之前：<br><br>今天张三去肯德基吃了个汉堡<br>明天李四去必胜客吃了个披萨<br>……<br><br>😄控制反转之后：<br><br>框架代码：【某时】【某人】去【某处】吃了【谋食物】<br><br>客服端代码：<br>某时=今天<br>某人=张三<br>某处=肯德基<br>某食物=汉堡<br><br>💡流程控制本来在程序员，现在反转给了框架代码。<br><br>🌹好处：<br>降低了程序员出错的概率。<br>降低了当程序员的门槛。<br>规范化了流程控制逻辑。<br><br>Spring框架声称自己是一个控制反转容器。","like_count":0},{"had_liked":false,"id":330576,"user_name":"小吉他","can_delete":false,"product_type":"c1","uid":2691377,"ip_address":"","ucode":"8B69721EA847BA","user_header":"https://static001.geekbang.org/account/avatar/00/29/11/31/278e7fe1.jpg","comment_is_top":false,"comment_ctime":1642054428,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1642054428","product_id":100039001,"comment_content":"控制反转：原先由程序员控制，现在反转给框架<br>依赖注入：不直接New，而是采用构成函数、函数参数获取对象<br>依赖反转：高层不依赖底层，而应该依赖一个共同的抽象；抽象不依赖实现细节，细节依赖抽象","like_count":0},{"had_liked":false,"id":329148,"user_name":"Geek_08733c","can_delete":false,"product_type":"c1","uid":2411555,"ip_address":"","ucode":"9EE5A78C35DBB1","user_header":"","comment_is_top":false,"comment_ctime":1641181228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641181228","product_id":100039001,"comment_content":"这一篇讲的太好了，老师有货","like_count":0},{"had_liked":false,"id":325913,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1639228666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639228666","product_id":100039001,"comment_content":"思考题：“基于接口编程而非实现编程”与“依赖注入”的区别与联系<br>1.两者的区别：基于接口编程而非实现编程，是一种设计思想，强调的是程序中应尽量引用接口对象，而非具体实现接口的对象，强调实现对象对程序透明；依赖注入则是一种编程技巧，强调程序依赖的对象通过外部传入，但并没有强制规定必须传递接口对象还是实现对象，依赖注入强调的是尽量使被引用的对象可被灵活的替换；<br>2.两者的共同点都是为了增加程序的可扩展性，都是通过替换依赖对象来实现，基于接口编程而非实现编程可以看成是依赖注入的一种特殊形式。","like_count":0},{"had_liked":false,"id":324181,"user_name":"🤔","can_delete":false,"product_type":"c1","uid":2712441,"ip_address":"","ucode":"600A071D843A17","user_header":"https://static001.geekbang.org/account/avatar/00/29/63/79/0e88b04f.jpg","comment_is_top":false,"comment_ctime":1638327917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638327917","product_id":100039001,"comment_content":"我觉得这里的依赖反转要是能讲讲反转一词如何理解就好了","like_count":0},{"had_liked":false,"id":322790,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637588853,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637588853","product_id":100039001,"comment_content":"依赖注入更侧重于规范上下游的行为。一个完整的逻辑过程中，需要请求方和被调用方，存在业务上游和业务下游。上下游都需要遵循的规范行为就是依赖注入编程。","like_count":0},{"had_liked":false,"id":322789,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637588760,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637588760","product_id":100039001,"comment_content":"最明显的区别面向接口只是约束一方的行为，","like_count":0},{"had_liked":false,"id":322280,"user_name":"二小","can_delete":false,"product_type":"c1","uid":1593919,"ip_address":"","ucode":"5377CB552237B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/3f/c8b40efe.jpg","comment_is_top":false,"comment_ctime":1637287654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637287654","product_id":100039001,"comment_content":"若是依据上面对控制反转的定义，那么，依赖注入其实并不是控制反转吧，依赖注入框架才是控制反转","like_count":0},{"had_liked":false,"id":320572,"user_name":"黄钰宸","can_delete":false,"product_type":"c1","uid":2719989,"ip_address":"","ucode":"A79A37F1DC6040","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJFPECFrx6sL90QB3SVeKjMOZibic4Wp09qcH4G8hK9uuGomGU8ElTrOprs7KuMVUUYRcP4fjze8o2w/132","comment_is_top":false,"comment_ctime":1636383116,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636383116","product_id":100039001,"comment_content":"对于课后习题的解答：在我看来，基于接口而非实现编程主要是：将易变的逻辑封装起来，暴露稳定的抽象方法，供稳定的主流程调用，所以这个易变的逻辑需要作为参数传递进主逻辑只能利用多态特性，将参数设置为接口或抽象类；而依赖注入就是解决了这个参数的创建流程；依赖注入是【给】，而基于接口而非实现是【用】。","like_count":0},{"had_liked":false,"id":317766,"user_name":"jk001","can_delete":false,"product_type":"c1","uid":2812934,"ip_address":"","ucode":"FF1E3A2883E8D9","user_header":"https://static001.geekbang.org/account/avatar/00/2a/ec/06/4494ecde.jpg","comment_is_top":false,"comment_ctime":1634954600,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1634954600","product_id":100039001,"comment_content":"面向接口编程是依赖倒置的一种手段。","like_count":0},{"had_liked":false,"id":314713,"user_name":"振振","can_delete":false,"product_type":"c1","uid":1313365,"ip_address":"","ucode":"ECE08186230140","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/55/5e440425.jpg","comment_is_top":false,"comment_ctime":1633343209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633343209","product_id":100039001,"comment_content":"依赖倒置 dip 个人理解：简单了说就是少用基类多用接口；往高了说就是框架设计时面向接口或者协议设计。希望作者给点回复，因为这一点讲的太抽象了","like_count":0},{"had_liked":false,"id":314712,"user_name":"振振","can_delete":false,"product_type":"c1","uid":1313365,"ip_address":"","ucode":"ECE08186230140","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/55/5e440425.jpg","comment_is_top":false,"comment_ctime":1633342951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633342951","product_id":100039001,"comment_content":"依赖反转太难理解了，太烦泛化了","like_count":0},{"had_liked":false,"id":313336,"user_name":"我是曾经那个少年","can_delete":false,"product_type":"c1","uid":1015189,"ip_address":"","ucode":"9F02F7FF147D14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","comment_is_top":false,"comment_ctime":1632382180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632382180","product_id":100039001,"comment_content":"这个不能用我们一般的业务代码去套依赖反转的例子。 我们的业务代码高模块肯定是依赖低模块，去调用。<br><br>跟应该考虑中间件去考虑。<br>例如JDBC规范，Java操作数据库不需要关注具体的数据库的连接查询细节。<br>Servlet规范，Web应用不需要关注具体的应用服务器等规范都是这种思想。","like_count":0},{"had_liked":false,"id":312908,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1632114375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632114375","product_id":100039001,"comment_content":"控制反转，依赖注入，依赖反转。<br>前两个好理解，程序流程的控制权交给框架非程序员，在外面生成好对象后通过构造方法传入另一个对象使用。<br>依赖反转，正常的都是高层依赖底层，现在改为都依赖一个抽象来实现链接","like_count":0},{"had_liked":false,"id":312134,"user_name":"王也","can_delete":false,"product_type":"c1","uid":1133206,"ip_address":"","ucode":"9EA69B51ECC99F","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/96/8756eaa2.jpg","comment_is_top":false,"comment_ctime":1631634293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631634293","product_id":100039001,"comment_content":"理解的是真牛逼啊。","like_count":0},{"had_liked":false,"id":309077,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1629936198,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1629936198","product_id":100039001,"comment_content":"依赖的是接口，注入的是实现","like_count":0},{"had_liked":false,"id":308758,"user_name":"小周","can_delete":false,"product_type":"c1","uid":2453498,"ip_address":"","ucode":"7ED7BC27A46C4C","user_header":"https://static001.geekbang.org/account/avatar/00/25/6f/fa/615a0df3.jpg","comment_is_top":false,"comment_ctime":1629788161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629788161","product_id":100039001,"comment_content":"基于接口而非实现编程是一种设计思想，封装具体实现，暴露稳定的接口。依赖注入是一种具体的编码技巧，它并不是在类中new类依赖的对象，而是在外面new完之后，通过构造函数或者方法传参等方式将其设置到类中。它们都能够提高代码的扩展性和灵活性","like_count":0},{"had_liked":false,"id":307138,"user_name":"易飞","can_delete":false,"product_type":"c1","uid":2630424,"ip_address":"","ucode":"32AC28754237F7","user_header":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","comment_is_top":false,"comment_ctime":1628905678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628905678","product_id":100039001,"comment_content":"感觉看懂了，又好像没看懂","like_count":0},{"had_liked":false,"id":301498,"user_name":"乔帆 Kayla","can_delete":false,"product_type":"c1","uid":1883514,"ip_address":"","ucode":"81944832230BC4","user_header":"https://static001.geekbang.org/account/avatar/00/1c/bd/7a/37df606b.jpg","comment_is_top":false,"comment_ctime":1625719335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625719335","product_id":100039001,"comment_content":"“基于接口而非实现编程”跟“依赖注入”<br>区别：“基于接口而非实现编程”是设计思想，“依赖注入”是编码技巧；<br>关联：可以通过依赖注入的方式实现“基于接口而非实现编程”的设计思想。","like_count":0},{"had_liked":false,"id":301389,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1625657285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625657285","product_id":100039001,"comment_content":"“基于接口而非实现编程” 是指导原则和编程思想。<br>“依赖注入”是具体的编程技巧。<br>“基于接口而非实现编程”的原则可以实现“依赖注入”的编程，反之来讲，“依赖注入”的实现依赖于“基于接口而非实现编程”的原则指导。","like_count":0},{"had_liked":false,"id":297268,"user_name":"wsh","can_delete":false,"product_type":"c1","uid":1006628,"ip_address":"","ucode":"C0FE187C6EECED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","comment_is_top":false,"comment_ctime":1623399313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623399313","product_id":100039001,"comment_content":"依赖注入主要是对数据的抽象，我们可以方便替换掉所以依赖的数据对象，而不影响使用者的代码，使用类和注入类之间常常是组合的关系。而基于接口而非实现编程，是对操作的抽象，使用类和借口类一般是继承关系。","like_count":0},{"had_liked":false,"id":296366,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1622942234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622942234","product_id":100039001,"comment_content":"区别是：“基于接口而非实现编程”是一种编程的思想，强调以接口为顶级设计，方便以后的扩展。而“依赖注入”是一种编程技巧，指的是创建的依赖对象不是通过new的方式创建的，而是通过函数传递过来的。<br>联系是：“基于接口而非实现编程”是设计的是接口，方便扩展，符合开闭原则。“依赖注入”在定义输入参数时，可以定义为接口，这样的话其接口的实现类也可以传递过来，也是方便以后的扩展。","like_count":0},{"had_liked":false,"id":296127,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1622772654,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1622772654","product_id":100039001,"comment_content":"依赖注入依赖于&quot;基于接口而非实现编程&quot;","like_count":0},{"had_liked":false,"id":293887,"user_name":"Geek_d60492","can_delete":false,"product_type":"c1","uid":2599089,"ip_address":"","ucode":"9A79B12F0D3D63","user_header":"https://static001.geekbang.org/account/avatar/00/27/a8/b1/092b658f.jpg","comment_is_top":false,"comment_ctime":1621587449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621587449","product_id":100039001,"comment_content":"依赖注入是实现控制反转的一种手段，属于“技”的层面；基于接口而非实现编程是面向对象设计原则，属于“术”这个层面。我们在使用依赖注入时，考虑到扩展性，需要遵循基于接口而非实现编程这个原则。","like_count":0},{"had_liked":false,"id":293866,"user_name":"苏杭天下","can_delete":false,"product_type":"c1","uid":2626287,"ip_address":"","ucode":"C6080021BA450F","user_header":"https://static001.geekbang.org/account/avatar/00/28/12/ef/cb0b57ec.jpg","comment_is_top":false,"comment_ctime":1621583041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621583041","product_id":100039001,"comment_content":"突然有个很粗糙的理解：就比如租房子，先不考虑代理只考虑这个依赖反转。原先租房子是找房东租，租客和房东是依赖关系，租客调用房东的房子。现在来了个中介，既然是非代理就不收中介费，比作共同依赖的一个抽象。房东把房子交给中介，租客不再找房东而是直接找中介，两者不再彼此依赖，而是共同依赖一个中介！这样的好处是，下次不想租这个房东的房子了，可以直接再次调用这个中介，让中介换个其他房东房子。或者房东不想租给你这个人，房东可以直接找依赖的中介换个租客。代码层面上不需要改动很多，因为两者都是依赖的这个中介。","like_count":0},{"had_liked":false,"id":291805,"user_name":"唐杨海","can_delete":false,"product_type":"c1","uid":1073096,"ip_address":"","ucode":"095619849CB268","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/c8/67e59742.jpg","comment_is_top":false,"comment_ctime":1620524346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620524346","product_id":100039001,"comment_content":"1.高层模块和低层模块都依赖于协议<br>2.协议不能由低层模块所有，可以由第三方所有，或者高层模块所有，这才是反转","like_count":0},{"had_liked":false,"id":290117,"user_name":"学员203","can_delete":false,"product_type":"c1","uid":2559640,"ip_address":"","ucode":"63E4B7E3A7E140","user_header":"","comment_is_top":false,"comment_ctime":1619393362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619393362","product_id":100039001,"comment_content":"我理解的依赖反转就是调用者依赖于被调用者的抽象，不依赖具体实现类，而作为被调用者是实现抽象接口的，感觉思想就是实现不被调用者时要面向接口编程而不是面向实现编程，可以联想Head first说的披萨店和具体披萨的代码实现。","like_count":0},{"had_liked":false,"id":289660,"user_name":"Gandalf","can_delete":false,"product_type":"c1","uid":1267039,"ip_address":"","ucode":"3881987167B713","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/5f/5dc667c3.jpg","comment_is_top":false,"comment_ctime":1619136290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619136290","product_id":100039001,"comment_content":"基于接口而非实现编程是抽象的一种实现方式，而依赖注入是对所要使用的外部对象的获取方式","like_count":0},{"had_liked":false,"id":288195,"user_name":"EQLT","can_delete":false,"product_type":"c1","uid":1122933,"ip_address":"","ucode":"609C93F0DEF0BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/75/79693c63.jpg","comment_is_top":false,"comment_ctime":1618360405,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618360405","product_id":100039001,"comment_content":"基于接口而非实现编程，更多的在于解耦代码，带来更大的扩展性。而依赖注入可以说更注重解决逻辑之间的依赖关系，利用基于接口而非实现编程的方式去实现依赖的反转，让高层不因底层的实际逻辑实现的更改而发生变更，更好地保护高层逻辑的正确性<br>","like_count":0},{"had_liked":false,"id":286406,"user_name":"李奇锋","can_delete":false,"product_type":"c1","uid":1220713,"ip_address":"","ucode":"1A0A359D0530C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/69/e42348a8.jpg","comment_is_top":false,"comment_ctime":1617283334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617283334","product_id":100039001,"comment_content":"explanation:: 在运行期间，上层的模块依赖下层模块把事情做出来。但是，在设计阶段，下层模块的实现逻辑依赖上层模块抽象出来的逻辑 ((或者说是上层建立的抽象模型&#47;接口))","like_count":0},{"had_liked":false,"id":286400,"user_name":"李奇锋","can_delete":false,"product_type":"c1","uid":1220713,"ip_address":"","ucode":"1A0A359D0530C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/69/e42348a8.jpg","comment_is_top":false,"comment_ctime":1617280932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617280932","product_id":100039001,"comment_content":"我感觉用 事件驱动模型（event loop）这个广泛了解的模型去讲解控制反转会有更好的效果。<br><br>只要是符合 事件驱动框架的的所有内容，都会被event loop进行调度，写代码的时候不一定需要知道自己的代码具体在什么时间点上背调用，但是它抽象出来的模型能确保执行逻辑的正确性。","like_count":0},{"had_liked":false,"id":285553,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1616894399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616894399","product_id":100039001,"comment_content":"两者的表象有点类似，但是侧重点不同。  面向接口编程强调的是设计，类和模块之间通过这种方式解耦。  而依赖注入强调的是有外部依赖时，从外部注入。","like_count":0},{"had_liked":false,"id":282953,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1615473628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615473628","product_id":100039001,"comment_content":"关于高层不依赖于低层的思考：<br>比如做手游开发，我们有非常多的发行渠道。比如要上架应用宝、小米商城、华为市场。。。<br>然后要做支付接口的时候，业务逻辑就绝不能依赖于某一个渠道的逻辑。<br>假如我们设计流程的时候，应用宝有个专门的获取签证流程，我们的流程接口里，针对这个签证流程设计了个方法。那么后续所有的渠道接入都得实现这个方法。显然是不合理的。<br>所以这个接口的设计应该去抽象出各个流程来。比如统一的认证、统一的发起支付、统一的回调即可。每个渠道都把各自的步骤，划分进接口的各个实现里面。<br>这样子，就标准化，方便了后续扩展。<br><br>所以这里说的高层不依赖于低层，应该叫高层设计不依赖于低层实现。","like_count":0},{"had_liked":false,"id":282948,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1615472712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615472712","product_id":100039001,"comment_content":"关于控制反转与依赖反转两个概念的思考：<br><br>控制反转：控制是个动作，就是表示流程某个动作控制权的转移。<br>以文章里测试代码为例，本来应该低层执行的流程，触发的权利和时机交给了高层。也就是低层多个的模块的同一个流程，统一商量个协议，交给高层一并触发执行。这里应该是通过高层对低层的控制反转，高聚合了触发时机。<br><br>那有没有高层反转给底层呢？我暂且认为没有吧。<br><br>依赖反转：<br>依赖是个关系，就是谁依赖谁的问题。<br>比如李四写了个接口(获取用户的订单列表)，给前端赵六调用。刚开始产品，并没有要求订单的排列顺序。这时看到的顺序，就是依赖于服务端怎么写，客户端怎么显示。<br>后来产品加入排序功能，客户端指定了排序方式。服务端就根据客户端的参数排序了。这时候显示顺序就依赖于前端开发赵六了。<br><br>感觉不是很准确。。。先这样吧。","like_count":0},{"had_liked":false,"id":280299,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1614154829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614154829","product_id":100039001,"comment_content":"单一职责原则，开闭原则，里氏替换原则，接口隔离原则，依赖反转原则。","like_count":0},{"had_liked":false,"id":279687,"user_name":"大风","can_delete":false,"product_type":"c1","uid":1606600,"ip_address":"","ucode":"95C2B6B98247FB","user_header":"https://static001.geekbang.org/account/avatar/00/18/83/c8/c08fc40f.jpg","comment_is_top":false,"comment_ctime":1613907509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613907509","product_id":100039001,"comment_content":"“基于接口而非实现编程”强调应用程序的设计阶段，尽可能的找出业务骨架即稳定的部分，它的另一面表述也可以说是把不稳定的部分封装起来形成稳定的部分；扩展性正是基于稳定的抽象部分而进行具体实现体现出来的。这正是开闭原则的一种非常好的实现手段。<br>“依赖注入”则侧重于对大量对象创建及其生命周期管理功能的封装，它与应用程序业务场景无关，并且工具在应用程序运行阶段。<br>它们都符合控制反转的设计思想，都充分梳理了应用程序中高低层模块之间的调用关系。另外，前者是设计思想会贯穿于我们在任何软件设计时，需要对业务实现时时操心用心提炼设计；后者显得要具像一点是应用程序的基础设施的一部分，在任何应用程序场景中都几乎是固化的。","like_count":0},{"had_liked":false,"id":279452,"user_name":"Geek_78eadb","can_delete":false,"product_type":"c1","uid":1712955,"ip_address":"","ucode":"843C6C380D28FA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/OYQh8KlUgMx0sZ35felqqRlboXkcOFib0qGgRHuvFCNIMzxRzxN8SjZpwtDuS0PGV0L0Pneiak7yzcd043f2efbg/132","comment_is_top":false,"comment_ctime":1613789849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613789849","product_id":100039001,"comment_content":"从 Notification 这个例子来看，“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？<br><br>两者强调不同的内容：<br>- 依赖注入：强调类在外面初始化成对象后传进来。<br>- 基于接口而非实现编程：强调调用者可操作接口类，实现类与接口类拥有相同的结构，调用者无需了解实现类细节。<br><br>因此两者无关系：<br><br>- 不使用”依赖注入“，也可实现”基于接口而非实现编程“：比如从外面传入的是类，在内部进行初始化。<br>- 不使用”基于接口而非实现编程“，也可实现”依赖注入“：比如不使用接口，直接将类的实例传进来。<br><br>但两者也可结合使用，比如本课的例子。","like_count":0},{"had_liked":false,"id":269620,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1608717413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608717413","product_id":100039001,"comment_content":"为什么都翻译成“依赖”，明明是“取决于”。 高层模块不取决于底层模块。所有模块都取决于抽象。抽象不由细节（过程）决定，细节取决于抽象。这就好理解多了，不是吗？","like_count":0},{"had_liked":false,"id":267043,"user_name":"崔光伟","can_delete":false,"product_type":"c1","uid":1875245,"ip_address":"","ucode":"603FCACC5CFC1C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJZMLfqpOHFbYF6Q31xgbKJ0FaO2ibFSqzyjV9gRlIYsnvGUcxYaG1eABJ5UupxVeda0yV0B3sBqDA/132","comment_is_top":false,"comment_ctime":1607580660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607580660","product_id":100039001,"comment_content":"依赖注入是一种代码风格，关注类之间的关系或者创建对形象的方式；基于接口而非实现编程是一种设计原则，关注抽象和实现。","like_count":0},{"had_liked":false,"id":266665,"user_name":"•••","can_delete":false,"product_type":"c1","uid":1122277,"ip_address":"","ucode":"D7F185FC4BFE14","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/e5/053ebfc9.jpg","comment_is_top":false,"comment_ctime":1607431851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607431851","product_id":100039001,"comment_content":"依赖注入重于方式，注入的可以是类也可以是接口。<br>基于接口重于抽象，降低耦合度。","like_count":0},{"had_liked":false,"id":266179,"user_name":"落尘","can_delete":false,"product_type":"c1","uid":1802622,"ip_address":"","ucode":"7B76B94CA301D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/7e/fb688b5c.jpg","comment_is_top":false,"comment_ctime":1607226932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607226932","product_id":100039001,"comment_content":"控制反转是一种原则，表示将程序执行的流程的控制从程序员反转到了框架。<br>依赖注入，表示将依赖类对象的创建，由类内部反转到了类外部？<br>依赖注入框架，表示将创建依赖对象，管理对象的生命周期，依赖注入等由程序员反转到了框架。<br><br>关于依赖注入我理解的没错吗？","like_count":0},{"had_liked":false,"id":266176,"user_name":"落尘","can_delete":false,"product_type":"c1","uid":1802622,"ip_address":"","ucode":"7B76B94CA301D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/7e/fb688b5c.jpg","comment_is_top":false,"comment_ctime":1607226467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607226467","product_id":100039001,"comment_content":"“基于接口而非实现编程”是一种原则，“依赖注入”是该原则的一种实践方式。我感觉“依赖注入”就是策略模式","like_count":0},{"had_liked":false,"id":265266,"user_name":"Kingram","can_delete":false,"product_type":"c1","uid":2247700,"ip_address":"","ucode":"212E403E81F2FC","user_header":"https://static001.geekbang.org/account/avatar/00/22/4c/14/8fa39544.jpg","comment_is_top":false,"comment_ctime":1606834776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606834776","product_id":100039001,"comment_content":"区别：<br>从Notification这个例子来看，依赖注入和基于接口而非实现编程不是一个东西，Notification依赖的MessageSender是一个接口还是一个类都没关系，只要不是本类中new出来的就算是依赖注入，而基于接口而非实现编程强调的是接口，上层模块不依赖下层的不稳定的实现，而是依赖更稳定的接口，在Notification 这个例子中，MessageSender就必须是一个接口。<br>联系：<br>两者都是为了降低程序的耦合性、提高代码的可读性、可扩展性、可维护性。结合使用效果更佳～","like_count":0},{"had_liked":false,"id":263211,"user_name":"JRich","can_delete":false,"product_type":"c1","uid":1114901,"ip_address":"","ucode":"66AE9D61533960","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg","comment_is_top":false,"comment_ctime":1606048031,"is_pvip":false,"replies":[{"id":"96105","content":"������","user_name":"作者回复","comment_id":263211,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700815,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1606048031","product_id":100039001,"comment_content":"控制反转定义里是程序执行流程的控制权反转，而依赖注入讲的是对象的创建由外部创建好通过构造方法或setter方法注入进来，感觉两个讲的不是一个意思，虽然依赖注入也有控制反转的意思，但是对象的创建和获取的权利被反转，更确切的理解应该是2个场景吧。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510122,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262892,"user_name":"JRich","can_delete":false,"product_type":"c1","uid":1114901,"ip_address":"","ucode":"66AE9D61533960","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg","comment_is_top":false,"comment_ctime":1605871400,"is_pvip":false,"replies":[{"id":"96136","content":"������","user_name":"作者回复","comment_id":262892,"uid":"1190123","ip_address":"","utype":1,"ctime":1606701352,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1605871400","product_id":100039001,"comment_content":"基于接口而非实现编程使用了依赖注入编程技巧。因为基于接口而非实现编程使用了面向对象的多态特性来提高代码扩展性，必然不可能在类内部创建对象，只能从外部注入。区别就是依赖注入不仅可以使用接口，还可以使用类。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510019,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260887,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1605148078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605148078","product_id":100039001,"comment_content":"IOC，个人理解主要是“控制权由内部转移到了外部”。这个控制权不仅指流程的控制权由内部转向外部，也包含内部对象生命周期管理的反转。<br>DI，依赖注入是实现IOC的一种常见方法，简单易用。<br>DIP，依赖反转原则是解藕的一种方法。原来是调用者依赖被调用者；现在在二者中间加了一层抽象，这层抽象原则成为了二者的依赖，有点面向接口编程的味道。","like_count":0},{"had_liked":false,"id":256415,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603619270,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1603619270","product_id":100039001,"comment_content":"“基于接口而非实现编程”，是一种基于抽象进行编程，把功能和实现分开，“依赖注入”是依赖的对象外注入，而不是内部创建，这增加代码可扩展性，可以让下层依赖上层让设计者更加灵活。二者都是编程技巧，增加代码扩展性。","like_count":0},{"had_liked":false,"id":247939,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1599922240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599922240","product_id":100039001,"comment_content":"依赖注入强调的是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式注入类来使用；它可以基于接口编程，也可以基于实现编程；当注入至类中的对象是接口对象的时候，那就是基于接口编程。","like_count":0},{"had_liked":false,"id":247761,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1533352,"ip_address":"","ucode":"6FD3642D6455AE","user_header":"https://static001.geekbang.org/account/avatar/00/17/65/a8/6431f8b0.jpg","comment_is_top":false,"comment_ctime":1599821677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599821677","product_id":100039001,"comment_content":"dip的原则用起来着实简单，理解起来需要一些基础，一定需要理解为什么不能都去new对象去做，这样才能感受到他的好处","like_count":0},{"had_liked":false,"id":247641,"user_name":"火影.海诺","can_delete":false,"product_type":"c1","uid":2091565,"ip_address":"","ucode":"34729AFEE93B6D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ea/2d/34cb8e0a.jpg","comment_is_top":false,"comment_ctime":1599785098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599785098","product_id":100039001,"comment_content":"控制反转说的是一种原则，一种理念，而依赖注入算这种原则的一个实现方式……为的是减低模块之间的耦合性……最终是为了代码的可扩展服务的。","like_count":0},{"had_liked":false,"id":246388,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599305059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599305059","product_id":100039001,"comment_content":"基于接口而非实现和依赖注入一样是一种原则，一种规范，都是帮助代码易扩展，易维护的有效手段<br>不同点在于基于接口而非实现 主要关注的是接口本身， 也包含了需要抽象的方法，一种约定和协议<br>依赖注入更多的是关注流程和具体类的管理， 解决hardcode对一个类的过度侵入","like_count":0},{"had_liked":false,"id":246010,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599131795,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599131795","product_id":100039001,"comment_content":"1、联系：相似地方，基于接口编程，<br>2、区别：依赖注入，可以很方便扩展为不同的接口类；<br>","like_count":0},{"had_liked":false,"id":245685,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1599026679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599026679","product_id":100039001,"comment_content":"依赖注入是编写可测试性代码最有效的手段。<br>最近尝试写单元测试，发现在需要mock数据的时候无从下手，现在发现是代码本身的可测试性差。<br>控制反转，指的是程序的执行流程从程序员反转到框架。<br>依赖反转，指的是上层模块对下层模块的依赖反转到对抽象接口的依赖。<br>依赖注入，指的是依赖外部传入对象，而不是内部创建对象。","like_count":0},{"had_liked":false,"id":244466,"user_name":"好名字","can_delete":false,"product_type":"c1","uid":1951501,"ip_address":"","ucode":"E2BFD96F912A67","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c7/0d/0dab398b.jpg","comment_is_top":false,"comment_ctime":1598526716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598526716","product_id":100039001,"comment_content":"我理解的依赖反转是，高层模块A依赖低层模块B，可以抽象出一个C，让B依赖C，A依赖C。","like_count":0},{"had_liked":false,"id":244241,"user_name":"辉","can_delete":false,"product_type":"c1","uid":2118347,"ip_address":"","ucode":"A1252F2209190F","user_header":"","comment_is_top":false,"comment_ctime":1598439522,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598439522","product_id":100039001,"comment_content":"需求决定实现挺正常的啊，一直困惑为何要说成依赖反转。","like_count":0},{"had_liked":false,"id":241399,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1597284464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597284464","product_id":100039001,"comment_content":"依赖注入实际上可以注入任何实例，但是想起到增强扩展性的目的，注入类型就必须是抽象的接口类。简单说依赖注入是基于接口编程的一种具体应用场景","like_count":0},{"had_liked":false,"id":241103,"user_name":"Geek_31594d","can_delete":false,"product_type":"c1","uid":2030240,"ip_address":"","ucode":"9058787881CE82","user_header":"","comment_is_top":false,"comment_ctime":1597193085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597193085","product_id":100039001,"comment_content":"控制反转- 本因开发自己控制的流程交给框架处理，开发只需要实现具体功能<br>依赖注入-需要某个对象或者资源的时候，本来是自己创建，现在依然于调用时外部传递<br>依赖注入框架-调用对象的创建 生命周期 依赖注入等于框架去处理<br>依赖反转原则-暂时不是很明确  高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象（需要加深印象）","like_count":0},{"had_liked":false,"id":232911,"user_name":"Java垒墙工程师","can_delete":false,"product_type":"c1","uid":1937062,"ip_address":"","ucode":"E76AE44A9C76AE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","comment_is_top":false,"comment_ctime":1594167607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594167607","product_id":100039001,"comment_content":"区别：<br>     基于接口编程：实现类获得解耦，方便后续替换和修改，调用方不感知<br>     依赖注入：强调的是依赖对象外部输入，而非硬编码到内部<br>二者联系：<br>     都对代码扩展非常友好","like_count":0},{"had_liked":false,"id":230405,"user_name":"大强","can_delete":false,"product_type":"c1","uid":1737397,"ip_address":"","ucode":"D5C64C5A01B25D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/82/b5/a6049a26.jpg","comment_is_top":false,"comment_ctime":1593363307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593363307","product_id":100039001,"comment_content":"基于接口而非实战编程，主要指导我们编程要有抽象思维，用抽象类或者接口实现多态特性。依赖注入主要解决的是对象之间的依赖关系，所有依赖对象通过构造函数或者set方法传递依赖对象。二者的联系就是他们都可以实现拓展性，满足ocp原则","like_count":0},{"had_liked":false,"id":229989,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1593235460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593235460","product_id":100039001,"comment_content":"关于课后题 我的理解是都是用到了接口但是侧重理念不一样，基于接口编程是类之间解耦理念，有些依赖反转原则，即调用底层不基于实现。而依赖注入也是是利用接口但是分离代码职责 避免直接内部创建依赖对象 更有单一指责性在里面，更方便测试","like_count":0},{"had_liked":false,"id":229986,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1593235092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593235092","product_id":100039001,"comment_content":"控制反转 依赖注入 和依赖反转，这三个概念的区别是我目前看到的所有文章教程里说的最清晰明了的，谢谢老师。","like_count":0},{"had_liked":false,"id":229370,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592978221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592978221","product_id":100039001,"comment_content":"依赖注入和面象接口而非实现编程，如A调用B的方法，依赖注入值得是B，而面象接口指的是A。针对的对象不同。<br>依赖倒置原则指的是高层不依赖底层，抽象不依赖具体。其实是面向接口的具体实现了。要求底层足够的抽象扩展，本来是底层给高层提供服务，却要求底层。所以是依赖倒置了","like_count":0},{"had_liked":false,"id":229227,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592926763,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592926763","product_id":100039001,"comment_content":"依赖注入是一种具体的编程技巧，通过外部创建好类对象然后通过构造函数或属性等方式传入给调用者，这样可随时进行替换。","like_count":0},{"had_liked":false,"id":229225,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592926581,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592926581","product_id":100039001,"comment_content":"基于接口而非实现编程是设计原则，指导类的设计，依赖接口而不直接依赖实现类，具备更高的扩展性。而依赖注入是一种具体的编程技巧，通过外部创建好对象（）","like_count":0},{"had_liked":false,"id":226382,"user_name":"港岛妹夫","can_delete":false,"product_type":"c1","uid":1097416,"ip_address":"","ucode":"9F6AAA29B60D8F","user_header":"https://static001.geekbang.org/account/avatar/00/10/be/c8/7c5f324f.jpg","comment_is_top":false,"comment_ctime":1592057289,"is_pvip":false,"replies":[{"id":"83996","content":"都是实践中来的，自己动脑子思考的比较多，书的话也就是看看而已，你可以看我写的这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;uKkQMIWTtAmvsEYZCxvZeg","user_name":"作者回复","comment_id":226382,"uid":"1190123","ip_address":"","utype":1,"ctime":1592526369,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1592057289","product_id":100039001,"comment_content":"想知道争哥的英文原文都是从哪里读来的. 如果是书的话, 可以推荐一些嘛~","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498221,"discussion_content":"都是实践中来的，自己动脑子思考的比较多，书的话也就是看看而已，你可以看我写的这篇文章：\nhttps://mp.weixin.qq.com/s/uKkQMIWTtAmvsEYZCxvZeg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592526369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223793,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1591182061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591182061","product_id":100039001,"comment_content":"区别：<br>1、依赖注入是一种具体的编程技巧，通过参数传递类而不是在内部new创建对象，降低代码的耦合性，提高可扩展性<br>2、面向接口编程可以说是一种编程思想或者设计原则，关注抽象和实现，上下游调用稳定性<br><br>联系：<br>二者都可以提高代码的可扩展性，基于开闭的原则","like_count":0},{"had_liked":false,"id":219399,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1590022440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590022440","product_id":100039001,"comment_content":"模板设计模式，依赖注入都可以实现控制反转。两者有个共同点，就是均为开发者保留扩展点，前者的扩展点是动作，后者的扩展点是整个对象(每个对象拥有各自个性化的动作)。","like_count":0},{"had_liked":false,"id":218538,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1589815084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589815084","product_id":100039001,"comment_content":"“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？<br>-----<br><br>- 首先基于接口而非实现编程，相同点：因为两者都依赖接口来实现被调用者的抽象，减少类之间的耦合，提供低成本的替换。<br>- 不同：基于接口而非实现编程，也可以理解为最基础的一种编码实践之一，设计模式有相当一部分是基于这种实践总结的。依赖注入，甚至说是依赖反转，是前者的扩展。<br>- 可以这么理解，前者是基石之一，后面是对前者的补充和发展","like_count":0},{"had_liked":false,"id":217290,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589455260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589455260","product_id":100039001,"comment_content":"依赖倒置、控制反转、依赖注入是三个不同的概念。<br>依赖倒置：把service层的接口挪到controller层，controller层不再依赖service的任何代码，service层实现controller中定义的接口，这样就实现了高层代码不知道低层代码，低层实现高层定义的接口，是依赖倒置。跟是否使用注入框架没有关系，重点是层之间的依赖关系。<br>控制反转：是框架的设计思路，框架是完成一整套业务流程逻辑的，高层调用低层时只需要实现框架预留的扩展点，然后传入框架，改变框架的行为，看起来是框架在调用高层的代码，we call you，you do not call me！<br><br>业务组装：扩展点要是预留的接口，可以编写多个实现；扩展点要是基类，可以编写多个泛化；然后业务组装层挑选实现和泛化，然后实例化对象，传入高层代码。<br>整个程序分高层业务逻辑,高层扩展规范(基类、接口)，高层扩展规范的实现，业务组装。注入就是业务组装层的工作，实例化泛化或实现，然后在实例化高层代码时传入，是UML说的一种依赖构造关系，用了依赖注入框架，也不一定就是依赖倒置，也不一定控制反转，现在常规写法接口和实现在同一层，controller层依赖了service层的接口，依赖没有倒置。这种写法违反了依赖倒置的规范，不知为啥大部分代码都是这种写法。spring的IOC框架声称是依赖注入控制反转容器，IOC只是把实现代码装配，是否控制反转了？是否依赖倒置了？IOC没有能力控制。<br>","like_count":0},{"had_liked":false,"id":217011,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589385097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589385097","product_id":100039001,"comment_content":"依赖注入没有实现控制反转！！！ <br>依赖注入只是实现了可以替换依赖。控制流程没有由高层挪到低层！service相对controller是低层，xxxController依赖xxxService的抽象接口，控制没有反转，控制还是在高层，只是可以方便的替换依赖类xxxService。<br><br>xxxService接口看作预留扩展点，xxxController作为低层，依赖注入框架看作高层可以，但是依赖注入框架作为高层不合适，因为程序员不关心依赖框架具体实现细节。","like_count":0},{"had_liked":false,"id":216922,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1589369554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589369554","product_id":100039001,"comment_content":"控制反转是编程思想，用于框架设计，本来应该高层调用低层并控制程序流程，反转为低层调用高层的实现，并控制程序流程。<br><br>依赖反转也是编程思想，控制反转的构造入参可以是class、interface、abstract，依赖反转是高层和低层都依赖interface或abstract，不要依赖class，也是低层调用高层的一种思想。高层写代码依赖的是调用的是低层的interface或abstract，不依赖class。<br><br>实现控制反转的方法有模板模式、依赖注入、里式替换。","like_count":0},{"had_liked":false,"id":214894,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1588843801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588843801","product_id":100039001,"comment_content":"1、依赖翻转：<br>一般来说，先有提供者提供功能，调用者如果想使用，那么就要适配提供者的api。<br><br>上层会调用下层，似乎也是上层需要适配被下层的api。<br><br>但是依赖倒置原则是让下层来主动适配上层，否者这个下层实现就是不合格的！上层并不依赖下层。<br><br>那么下层如何来适配上层呢？<br><br>上层模块定义一个抽象标准，并直接依赖这个抽象标准，下层主动实现这个标准。<br><br>上层并不关心是不是有下层实现，也不关心下层实现的对不对，即上层不依赖下层实现。<br><br>下层需要实现上层定义的抽象标准，所以这时下层模块依赖了上层模块。<br><br>文中tomcat的例子十分形象，tomcat作为上层的容器，规定下层实现必须实现servlet规范，tomcat版本不依赖任何下层实现，一样跑的转，但是下层实现如果不遵守规范，那上层模块就不鸟你了。","like_count":0},{"had_liked":false,"id":214387,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1588736786,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588736786","product_id":100039001,"comment_content":"基于接口而非实现编程 类似于设计原则，依赖注入类似于具体实现。<br>基于接口而非实现编程 类似于接口，依赖注入类似于继承了该接口。<br>","like_count":0},{"had_liked":false,"id":212354,"user_name":"KID","can_delete":false,"product_type":"c1","uid":1867938,"ip_address":"","ucode":"EE80B7CA7CC2A2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/80/a2/96dcd1fa.jpg","comment_is_top":false,"comment_ctime":1588088847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588088847","product_id":100039001,"comment_content":"依赖注入是一种代码编写技巧，基于接口编程而非实现编程是一种设计原则，前者关注类和对象的关系，后者关注抽象和实现；目的都是为了提高可扩展性，降低耦合","like_count":0},{"had_liked":false,"id":207412,"user_name":"林子er","can_delete":false,"product_type":"c1","uid":1629256,"ip_address":"","ucode":"85637288F22CF0","user_header":"https://static001.geekbang.org/account/avatar/00/18/dc/48/9796286e.jpg","comment_is_top":false,"comment_ctime":1587084722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587084722","product_id":100039001,"comment_content":"基于接口而非实现编程是设计原则，依赖注入更多的是说实现方式，一般用后者实现前者","like_count":0},{"had_liked":false,"id":203032,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1586104988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586104988","product_id":100039001,"comment_content":"基于接口而非实现的编程，其中的接口就是依赖反转原则中所谓的&quot;抽象&quot;。接口不依赖具体的实现类和实现类的调用，但实现类和实现类的调用依赖接口。因此基于接口而非实现的编程，就是依赖反转原则的一个具体应用。","like_count":0},{"had_liked":false,"id":202737,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586059605,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586059605","product_id":100039001,"comment_content":"个人感觉依赖反转这个名字起得不好，为什么呢？因为这个通过看这个名字，和具体的描述似乎很难联系起来，或者名字或者描述之间没有联系。","like_count":0},{"had_liked":false,"id":201391,"user_name":"Geek_49de4e","can_delete":false,"product_type":"c1","uid":1586108,"ip_address":"","ucode":"8A01075936CC81","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/guAazdraayUib2pmGYuxFGUEHZUoibsj2xNTdjOT0McXJKQUPKwH4EHRfV72oaiatfiaWoT0fm5zib1dNqnFNbcFRQw/132","comment_is_top":false,"comment_ctime":1585760291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585760291","product_id":100039001,"comment_content":"1.依赖注入改变了对象初始化的位置，但并未改变对象之间的依赖关系。<br>2.面向抽象编程改变对象之间对具体实现的依赖。<br><br>结合上面两点，在模版和IOC框架中通过面向抽象编程来定义扩展点，并通过依赖注入来生产注对象，是遵循了依赖倒置原则的良好实践。","like_count":0},{"had_liked":false,"id":200737,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585644658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585644658","product_id":100039001,"comment_content":"控制反转：控制是指对流程的控制，反转是指原本是程序员控制流程，反转成框架控制流程。<br><br>依赖反转：高层代码不依赖于低层代码，他们共同依赖于一个抽象。<br><br>依赖注入：不通过 new 的方式在类内部创建类的对象。而是在外面创建好类的对象，然后通过函数参数，构造函数方式传入","like_count":0},{"had_liked":false,"id":200659,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585630390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585630390","product_id":100039001,"comment_content":"依赖注入只是将需要的对象传递进去就可以了，专注于注入，而基于接口而非实现编程基于多tai,基于扩展性，专注于面对未来的变化，所以开发人员不仅要面对功能实现，更应该面对未来的变化","like_count":0},{"had_liked":false,"id":199562,"user_name":"ryan007","can_delete":false,"product_type":"c1","uid":1046357,"ip_address":"","ucode":"7D28C589800CAE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/55/769bf4fb.jpg","comment_is_top":false,"comment_ctime":1585491489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585491489","product_id":100039001,"comment_content":"有理论有实践，还是很不错的","like_count":0},{"had_liked":false,"id":198626,"user_name":"Six","can_delete":false,"product_type":"c1","uid":1220617,"ip_address":"","ucode":"E297BB638B2BD9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","comment_is_top":false,"comment_ctime":1585460753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585460753","product_id":100039001,"comment_content":"控制反转是 这里的控制是对程序的控制，而反转是由程序员控制的逻辑交给框架来抽象控制，讲的是一种设计思想。<br>依赖注入是一个类依赖一个类，而将这个类通过外部传入。一般被依赖的设计成接口或者抽象类比较容易扩展，讲的是一种编程技巧<br>依赖倒置原则 则说的是调用方依赖实现方，通常通过接口来规范。调用方不知道具体的实现，而实现不知道具体的调用方。对于实现方在设计的时候，需要考虑调用方的使用场景，多个调用方的通用性。","like_count":0},{"had_liked":false,"id":197962,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585405381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585405381","product_id":100039001,"comment_content":"这个是真的抽象，好像也没讲和Spring IOC得差别吧。","like_count":0},{"had_liked":false,"id":197713,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1585394171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585394171","product_id":100039001,"comment_content":"记录今天学习的内容，控制反转，依赖注入，依赖反正。","like_count":0},{"had_liked":false,"id":196243,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585266493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585266493","product_id":100039001,"comment_content":"基于接口编程强调的是将公共功能抽出来。<br>而依赖注入更强调不要在内部new对象，这样绑定死了调用对象。","like_count":0},{"had_liked":false,"id":195255,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1585150442,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585150442","product_id":100039001,"comment_content":"【设计模式笔记20】20200325<br>控制反转：将程序的流程放在框架层实现，反转的是程序的流程控制，一句话：流程控制从自己控制变成框架控制。好处是专注实现逻辑即可，流程由框架管理<br>依赖注入：依赖的对象通过构造函数和serrer方法传递进来，而不是通过new的方式创建。好处是可以减少对象的创建，从而提高程序运行的性能，虚拟机会对不再使用得对象进行垃圾回收，导致应用频繁gc。<br>依赖注入框架：具备创建对象、对象的生命周期管理、依赖注入的功能框架。<br>为什么要使用控制反转框架：不需要关心对象的依赖关系，对象之间的关系可以交给容器完成，减少代码的耦合度<br>最后再回答下问题：首先“基于接口而不是实现编程”讲的是程序的交互问题，即如何实现写代码，依赖注入是一种关系程序内部对象的技巧，两个维度的问题","like_count":0},{"had_liked":false,"id":194958,"user_name":"黑客时间","can_delete":false,"product_type":"c1","uid":1831324,"ip_address":"","ucode":"7E22D76EECAC4D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f1/9c/cd12361d.jpg","comment_is_top":false,"comment_ctime":1585123825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585123825","product_id":100039001,"comment_content":"基于接口编程能够使依赖注入的兼容性更强，在实际操作中，我只需要确定所依赖的类的类型，但是具体是哪个实现类，我不关心，根据实际情况进行注入就可以了","like_count":0},{"had_liked":false,"id":194739,"user_name":"然","can_delete":false,"product_type":"c1","uid":1347648,"ip_address":"","ucode":"43B7D3896D706B","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/40/dfa19744.jpg","comment_is_top":false,"comment_ctime":1585100977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585100977","product_id":100039001,"comment_content":"依赖反转：高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。","like_count":0},{"had_liked":false,"id":194438,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585059700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585059700","product_id":100039001,"comment_content":"控制反转这个定义挺反人类的，今天终于听老师讲明白了，不是由编程人员控制逻辑走向，而是由这样一种设计出的框架来控制走向","like_count":0},{"had_liked":false,"id":192690,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584868322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584868322","product_id":100039001,"comment_content":"“控制翻转”是心法是指导原则，“依赖注入”是剑谱是手段，“依赖注入框架”则是倚天剑是工具。","like_count":0},{"had_liked":false,"id":192686,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584868136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584868136","product_id":100039001,"comment_content":"讲的是俩个层面的事情。“基于接口而非实现编程”讲的是编码原则，如何从逻辑上组织代码；“依赖注入”讲的是实现方式，怎么样把相关代码组合起来。","like_count":0},{"had_liked":false,"id":189822,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1584572064,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584572064","product_id":100039001,"comment_content":"tomcat那个例子很好","like_count":0,"discussions":[{"author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299451,"discussion_content":"我想到一个java不支持Double Dispatch的可能的原因，方法调用，需要分配『栈』给方法来保存本地变量的引用（基本类型的话，引用字面量；对象类型则引用『堆』中的对象），而『栈』是在编译时就分配好了的，于是对于方法的参数（形参），也需要在编译时就确定好引用类型，所以调用对象的『哪个方法』，只能根据编译时的方法参数类型决定；而作为实参的对象是运行时才在『堆』中创建（编译时不需要知道对象具体是哪一个，只需要知道它的类型），再传入方法，这时会做运行时类型校验，只要类型是兼容（assignable）的, 就能通过，此时调用实参对象的方法，自然是调用『这个』具体对象的方法喽，所以调用『哪个对象』的方法，由对象运行时的类型决定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597703033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1511556,"avatar":"","nickname":"某小浩","note":"","ucode":"F0A65F516B17BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288112,"discussion_content":"我是觉得如果java支持double dispatch的话，就不存在方法重载了，也许从运行前的编译检查上来说就变得不那么可靠了，比如我觉得根据定义js好像double dispatch，不知道对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593653797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1511556,"avatar":"","nickname":"某小浩","note":"","ucode":"F0A65F516B17BB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299448,"discussion_content":"支持double dispatch的话, 也依然存在方法重载啊（方法重载依然有意义啊），上节课中第二段代码（本节课也摘抄过来了）就是例子，而且此时编译不报错，能work了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597698300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288112,"ip_address":""},"score":299448,"extra":""},{"author":{"id":1488312,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/b8/1178ae00.jpg","nickname":"莫邪","note":"","ucode":"F3B35D2844F520","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1511556,"avatar":"","nickname":"某小浩","note":"","ucode":"F0A65F516B17BB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326270,"discussion_content":"我觉得double dispatch就是因为有重载才有意义，没有重载的话就不需要确定调用对象的哪一个方法，因为没有重载就一个方法，不需要区分是对象的哪一个方法，那单分派和双分派就没区别了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605574039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288112,"ip_address":""},"score":326270,"extra":""}]}]},{"had_liked":false,"id":179714,"user_name":"huangzhimim","can_delete":false,"product_type":"c1","uid":1018596,"ip_address":"","ucode":"ACAB00327DD95D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/e4/e5e1fd9b.jpg","comment_is_top":false,"comment_ctime":1582082889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582082889","product_id":100039001,"comment_content":"&#47;&#47; 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()JunitApplication.register(new UserServiceTest();<br><br>真心求教这里可以用什么配置来实现呢","like_count":0},{"had_liked":false,"id":178963,"user_name":"杨松","can_delete":false,"product_type":"c1","uid":1512517,"ip_address":"","ucode":"FB3C73BC44C94D","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/45/adf079ae.jpg","comment_is_top":false,"comment_ctime":1581864205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581864205","product_id":100039001,"comment_content":"老师你好，请教下开篇的第一个问题““依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？”能给个总结性的答案吗？这个问题总感觉有点晕晕的，还是不能理解的特别透彻。","like_count":0},{"had_liked":false,"id":177845,"user_name":"嘿泥鳅","can_delete":false,"product_type":"c1","uid":1285186,"ip_address":"","ucode":"A22BDA7A6DA23E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/F5Srwp8IibOU9PDCDgmpdIZF9UXQZzfPKzNseHW5GR0WmusGfrkmzQ6wq32omW3uTtl8aXjkudYSA0NEmibxAcnw/132","comment_is_top":false,"comment_ctime":1581514012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581514012","product_id":100039001,"comment_content":"区别：<br>1.基于接口而非实现编程强调的是隔离变化应对未来需求，并且作为一种面向对象的基本原则<br>2.依赖注入则是实现IOC的基本手段<br>联系：两者都以提高代码扩展性作为目标和意义，并且DI可以借助基于接口而非实现编程来增强扩展性和灵活性，例如Spring中的接口注入。","like_count":0},{"had_liked":false,"id":177489,"user_name":"涉蓝","can_delete":false,"product_type":"c1","uid":1134619,"ip_address":"","ucode":"C1321E29E01625","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLh8ubWQtDRa6exJtloSwibLliaejpF7434ficyggzukmXE63UlSPvbykoiaVDZo4CbDIIOQsCkicibyn9A/132","comment_is_top":false,"comment_ctime":1581403846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581403846","product_id":100039001,"comment_content":"依赖注入是为了实现控制反转的一种编程方法，而要实现依赖注入的前提就是可能变化的依赖是根据接口抽象出来的，所以 基于接口而非实现编程 是实现 依赖注入 的 基础","like_count":0},{"had_liked":false,"id":175755,"user_name":"刘明丰","can_delete":false,"product_type":"c1","uid":1591790,"ip_address":"","ucode":"64C1D6CC769F75","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eocPWoTKicQG9ic42hLQBOqEziaNYxBekyGXljWrYfhk8gjLGZWfUX0JlObCvOIUSA8tRXicfxeSDJMMw/132","comment_is_top":false,"comment_ctime":1580819837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580819837","product_id":100039001,"comment_content":"控制反转和依赖注入其实是描述事物的角度不一样，依赖注入是上帝视角来看的，程序本身看成一个黑盒，所有的依赖都通过外部填充进去；控制反转是程序本身作为第一视角的，本来程序需要依赖关系都是靠自己new出来的，都是自己控制的，反转之后就不一样了，依赖关系不再靠自己维护了，而是交给了外部或者说是第三方来维护，控制权发生了变化。","like_count":0},{"had_liked":false,"id":174798,"user_name":"流星","can_delete":false,"product_type":"c1","uid":1114926,"ip_address":"","ucode":"94BACF37AD4953","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/2e/3a7b0eda.jpg","comment_is_top":false,"comment_ctime":1580391395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580391395","product_id":100039001,"comment_content":"基于接口而非实现是指通过接口的方式而不用考虑内部实现，依赖注入更强调的是依赖","like_count":0},{"had_liked":false,"id":174688,"user_name":"h1z3y3","can_delete":false,"product_type":"c1","uid":1284984,"ip_address":"","ucode":"AD0B626CF56A9A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVqBf4Tkj2OtdziaIKlJJf6RVpZ8LmbPibg47Ba4wiaW5zXecpYYn5oKTrzhOJ6L5H2Yv7cqLSODiazA/132","comment_is_top":false,"comment_ctime":1580351627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580351627","product_id":100039001,"comment_content":"可以看一下 Uncle Bob 的 Clean Architecture， <br>真正的实现，整个架构完全分层，层与层之间使用都是DI","like_count":0},{"had_liked":false,"id":174079,"user_name":"移动一下","can_delete":false,"product_type":"c1","uid":1034115,"ip_address":"","ucode":"9314E79C72A71E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/83/ca76b4f3.jpg","comment_is_top":false,"comment_ctime":1579954959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579954959","product_id":100039001,"comment_content":"联系是两者都用了抽象，都是为了扩展，区别是依赖注入强调了对象生成的地方来源于外部","like_count":0},{"had_liked":false,"id":172371,"user_name":"www","can_delete":false,"product_type":"c1","uid":1275203,"ip_address":"","ucode":"951B364F2CB211","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg","comment_is_top":false,"comment_ctime":1579162501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579162501","product_id":100039001,"comment_content":"基于接口而非实现编程是一种编程思想，强调的是接口可以应对需求的变更，有更高的扩展性<br>依赖注入是一种编程技巧，可以实现控制反转的编程思想，解放程序员对复杂的类成员的初始化，让程序员专心于业务代码上","like_count":0},{"had_liked":false,"id":171208,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1578881793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578881793","product_id":100039001,"comment_content":"首先 ”基于接口而非实现编程”便于“依赖注入”中动态替换，灵活的进行拓展。类似在spring框架中有接口和实现类，而只需要依赖接口即可，可以动态调整实现。<br>其次 ”基于接口而非实现编程” 侧重类的设计，是实现代码灵活性、提升可拓展的方式。而“依赖注入”是一种具体的编码技巧，可将具体的业务逻辑 和 通用重复的代码切分出来，简化代码开发的难度等。","like_count":0},{"had_liked":false,"id":170917,"user_name":"东流","can_delete":false,"product_type":"c1","uid":1738147,"ip_address":"","ucode":"2715BC6E87BD83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/a3/7e078442.jpg","comment_is_top":false,"comment_ctime":1578757194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578757194","product_id":100039001,"comment_content":"依赖反转强调类中对象在外部初始化，传给类时最好基于接口而非实现，但不强求；而基于接口而非实现指的是类给类通信时的一种设计原则","like_count":0},{"had_liked":false,"id":170198,"user_name":"CHS","can_delete":false,"product_type":"c1","uid":1240227,"ip_address":"","ucode":"3D8B2DABC0A1D6","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/a3/28763399.jpg","comment_is_top":false,"comment_ctime":1578548328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578548328","product_id":100039001,"comment_content":"Notification 基于接口而非实现编程更加灵活，调用方只需要调用接口的相关方法就可以了，不用管实现方式怎么实现的。","like_count":0},{"had_liked":false,"id":169777,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1578445418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578445418","product_id":100039001,"comment_content":"基于接口而非实现和控制反转挺相似，前者强调依赖的对象，尽量依赖接口，后者强调依赖的方向，高层模块有时候需要另外一个低层模块的功能，直接引用会让稳定的高层模块依赖不稳定的低层模块，这时候有必要在高层模块中衍生出一个接口，这个接口是和高层一样稳定的，然后让低层的模块实现这个接口，运行时期注入低层的模块，来让高层的模块调用低层的功能，这样就通过了两者都依赖接口来避免了高层模块直接依赖低层的模块。","like_count":0},{"had_liked":false,"id":168783,"user_name":"开心小毛","can_delete":false,"product_type":"c1","uid":1023762,"ip_address":"","ucode":"9D57A2773759F3","user_header":"","comment_is_top":false,"comment_ctime":1578159155,"is_pvip":false,"replies":[{"id":"65750","content":"上层模块的抽象你是指什么呢？","user_name":"作者回复","comment_id":168783,"uid":"1190123","ip_address":"","utype":1,"ctime":1578380725,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"1578159155","product_id":100039001,"comment_content":"底层模块依赖上层模块的抽象是否提倡？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510465,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168778,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1578156850,"is_pvip":false,"replies":[{"id":"65751","content":"倒置就是反转，我在文章中不是解释了为啥叫反转吗😂","user_name":"作者回复","comment_id":168778,"uid":"1190123","ip_address":"","utype":1,"ctime":1578380767,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1578156850","product_id":100039001,"comment_content":"高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。  不太明白，为什么叫依赖倒置呀？倒置啥呢？ 我可能会取名，依赖抽象原则，哈哈。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480332,"discussion_content":"倒置就是反转，我在文章中不是解释了为啥叫反转吗😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578380767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168707,"user_name":"Yangjing","can_delete":false,"product_type":"c1","uid":1018061,"ip_address":"","ucode":"D88DFD4958D07C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/cd/2c3808ce.jpg","comment_is_top":false,"comment_ctime":1578145312,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578145312","product_id":100039001,"comment_content":"联系在这两者都是通过多态特性来实现的；区别在于依赖接口编程侧重点在类应该依赖接口（或抽象类），依赖注入侧重于通过注入的方式实例化类依赖的对象。","like_count":0},{"had_liked":false,"id":168647,"user_name":"青子","can_delete":false,"product_type":"c1","uid":1518034,"ip_address":"","ucode":"C159B8C644E7DA","user_header":"https://static001.geekbang.org/account/avatar/00/17/29/d2/475ee8e7.jpg","comment_is_top":false,"comment_ctime":1578131165,"is_pvip":false,"replies":[{"id":"65956","content":"代码稍微有点问题，我改下，抱歉！","user_name":"作者回复","comment_id":168647,"uid":"1190123","ip_address":"","utype":1,"ctime":1578490058,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1578131165","product_id":100039001,"comment_content":"JunitApplication.register(new UserServiceTest();<br>在控制反转中执行这句话会执行该类中的final修饰的main方法吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480281,"discussion_content":"代码稍微有点问题，我改下，抱歉！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578490058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177602,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","nickname":"Treasure","note":"","ucode":"4211ECEB347C3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138465,"discussion_content":"文章这段有问题的代码没有更新呢，小争哥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579244922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167376,"user_name":"七月有风","can_delete":false,"product_type":"c1","uid":1439990,"ip_address":"","ucode":"B3F82397347C5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/f6/3e2db176.jpg","comment_is_top":false,"comment_ctime":1577780041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577780041","product_id":100039001,"comment_content":"第一次接触依赖注入是在Angular.Js 1.X版本中","like_count":0},{"had_liked":false,"id":166765,"user_name":"无所从来","can_delete":false,"product_type":"c1","uid":1325996,"ip_address":"","ucode":"E7AD394BC16A73","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ac/40807e85.jpg","comment_is_top":false,"comment_ctime":1577589841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577589841","product_id":100039001,"comment_content":"高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。","like_count":0},{"had_liked":false,"id":166381,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1577439911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577439911","product_id":100039001,"comment_content":"“基于接口而非实现编程”跟“依赖注入”。<br>强调点不同：“基于接口而非实现编程”强调的是接口（抽象概念的接口）更加着重于在思想层面，“依赖注入”强调的是一种具体的方式方法。","like_count":0},{"had_liked":false,"id":166019,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1587803,"ip_address":"","ucode":"867405CA5A9FB7","user_header":"https://static001.geekbang.org/account/avatar/00/18/3a/5b/ce1724ca.jpg","comment_is_top":false,"comment_ctime":1577363672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577363672","product_id":100039001,"comment_content":"课后思考题：<br>依赖注入拆开来：“依赖” 要基于接口约定，而“注入” 是指模块间的关联方式，而后者是“基于接口而非实现编程” 所没有定义的。","like_count":0},{"had_liked":false,"id":165838,"user_name":"奔跑的小孩","can_delete":false,"product_type":"c1","uid":1304259,"ip_address":"","ucode":"0053193F7A9870","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/21uTMWr7bx5qMibp2hwmGvLbYuj5Aic2dqD3futlNo25eDGDt4t7zzN9cdnj7cVGwTot1U4AyADfWUpqjq1SicgWQ/132","comment_is_top":false,"comment_ctime":1577329896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577329896","product_id":100039001,"comment_content":"依赖倒置原则  说的有些不理解，这里讲的感觉好像是一种思路，高层次到低层次，具体到抽象","like_count":0},{"had_liked":false,"id":165703,"user_name":"Nan","can_delete":false,"product_type":"c1","uid":1236569,"ip_address":"","ucode":"A3DEC678BF814D","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/59/ceea56a9.jpg","comment_is_top":false,"comment_ctime":1577285482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577285482","product_id":100039001,"comment_content":"抽象不依赖具体实现细节： 工厂方法，框架。<br>具体实现细节依赖抽象（所谓反转的地方）：根据高层次需要的进行设计<br><br>感谢 Smallfly 朋友的留言，让我有种顿悟的感觉","like_count":0},{"had_liked":false,"id":165023,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1577149072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577149072","product_id":100039001,"comment_content":"尝试解读一下控制翻转，依赖注入和依赖注入框架之间的关系。<br><br>如果控制翻转我们定义为一件事情的结果，比如：我要有知识.<br>依赖注入：是通向这件事情的一个手段，比如：听老师讲课<br>依赖注入框架：运用如上手段，系统化，完整化的实现这个结果。比如：学校教育体系的存在，我们学知识，上学即可","like_count":0},{"had_liked":false,"id":164957,"user_name":"番茄炒西红柿","can_delete":false,"product_type":"c1","uid":1690242,"ip_address":"","ucode":"13F47BABAB2110","user_header":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","comment_is_top":false,"comment_ctime":1577116276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577116276","product_id":100039001,"comment_content":"基于接口编程强调的是一种设计原则，强调抽象化。而依赖注入则是实现，强调类与类（接口）间的依赖关系，用聚合而非组合关系","like_count":0},{"had_liked":false,"id":164268,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1576919847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576919847","product_id":100039001,"comment_content":"代码里好像有两个小问题：<br>1. 控制反转的代码中，doTest()的返回值误写成了void，应该是Boolean吧？<br>2. 还是控制反转的代码中，for循环中的变量命名case是Java中的关键字，编译不通过的","like_count":0},{"had_liked":false,"id":164107,"user_name":"jason","can_delete":false,"product_type":"c1","uid":1167872,"ip_address":"","ucode":"3329F08BAF307E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d2/00/9a247b1e.jpg","comment_is_top":false,"comment_ctime":1576880355,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576880355","product_id":100039001,"comment_content":"“依赖注入”指依赖时要依赖一个抽象的接口，但注入时要注入一个具体实现。所以实现依赖注入要求我们要基于接口而非实现编程。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510112,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163799,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1576804605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576804605","product_id":100039001,"comment_content":"Spring 的IoC 容器除了主要通过依赖注入实现控制反转外，应该还有其它功能","like_count":0},{"had_liked":false,"id":163665,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1258380,"ip_address":"","ucode":"BFA3BE8D8773A7","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/8c/23eef8d7.jpg","comment_is_top":false,"comment_ctime":1576763729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576763729","product_id":100039001,"comment_content":"这一章我怎么就听不太懂了呢😂😂","like_count":0},{"had_liked":false,"id":163528,"user_name":"皮卡皮卡","can_delete":false,"product_type":"c1","uid":1216284,"ip_address":"","ucode":"D440EEC7301C76","user_header":"https://static001.geekbang.org/account/avatar/00/12/8f/1c/1c728388.jpg","comment_is_top":false,"comment_ctime":1576736963,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576736963","product_id":100039001,"comment_content":"控制反转中的第二段改造代码public abstract void doTest();应该是public abstract boolean doTest();<br>同时第三段中的不需要程序员显示调用register()，应该是显式调用doTest()吧","like_count":0},{"had_liked":false,"id":163497,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1576731741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576731741","product_id":100039001,"comment_content":"这一篇文章确实是我读过的把这四个概念讲的最清楚明白的。","like_count":0},{"had_liked":false,"id":163422,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1576719727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576719727","product_id":100039001,"comment_content":"打卡<br>1、控制反转（Inversion Of Control）：“控制”指对程序流程的控制，“反转”指没有使用框架之前，程序员控制整个程序的执行，使用框架之后，整个程序的执行由框架来控制。程序执行的流程的控制权从程序员“反转”到了框架<br><br>2、依赖注入（ Dependency Injection）：不通过new的方式在类内部创建依赖对象，而是通过构造函数或是函数参数等方式传递对象给类使用。这样提供高了扩展性，可以方便的替换依赖的类，符合“开闭原则”。根据基于接口而非实现编程原则，注入的可以是接口的实现类，更为方便灵活和易扩展<br><br>3、依赖注入框架（DI Framework）：通过框架提供的扩展点，简单配置所需创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的声明周期、依赖注入等操作；<br><br>4、依赖反转原则（Dependency Inversion Principle）：高层模块不依赖于底层模块，高层模块和底层模块都依赖与抽象，抽象不依赖于具体的实现细节，具体的实现细节依赖与抽象。（在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计）","like_count":0},{"had_liked":false,"id":163376,"user_name":"曾志伟","can_delete":false,"product_type":"c1","uid":1152405,"ip_address":"","ucode":"ED6E1073E0B247","user_header":"https://static001.geekbang.org/account/avatar/00/11/95/95/8078a8f8.jpg","comment_is_top":false,"comment_ctime":1576715371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576715371","product_id":100039001,"comment_content":"基于接口而非实现编程，其中接口指的是协议或者约定，调用者只需根据协议进行编程即可，无需依赖接口的具体实现。依赖注入是指类的成员不通过自己内部生成，而是通过类的调用者在类外部生成，再传入类中。前者是为了接口实现类的变动不影响接口调用类，后者可以解耦成员拥有类和成员实现逻辑。前者是后者的一种实现方式。","like_count":0},{"had_liked":false,"id":163219,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1576672377,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576672377","product_id":100039001,"comment_content":"依赖注入描述的是一种编码技巧 而编程框架在抽象的层面让大家可以方便的使用这种技巧 这种技巧的好处是依赖的组织管理更简单 因为都交给框架做了 而大家只要写自己的业务就好 而面向接口编程是设计原则 为了更好的解耦和扩展和插拔 用依赖注入的技巧配合面向接口编程 能协调实现更好的代码架构","like_count":0},{"had_liked":false,"id":163206,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1576669955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576669955","product_id":100039001,"comment_content":"区别：依赖注入是一种编程技巧，即使注入的类未采用面向接口编程，也可以。<br>联系：可以结合面向接口编程的原则，来进行依赖注入，这样的代码的就更加易于扩展。","like_count":0},{"had_liked":false,"id":163154,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1576664115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576664115","product_id":100039001,"comment_content":"控制反转: 上层不依赖下层<br>依赖注入:通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。","like_count":0},{"had_liked":false,"id":163053,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1576648971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576648971","product_id":100039001,"comment_content":"“基于接口而非实现编程”是基础，在此基础上将依赖获取方式抽象，进而演进出各种控制反转和框架。“依赖注入”仅是获取依赖的一种具体方式。这两个一个是战略层面的，一个是战术层面的。落地到代码时，都是依靠Java接口+里式替换来实现的，故看上去一样。","like_count":0},{"had_liked":false,"id":163038,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1576644553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576644553","product_id":100039001,"comment_content":"区别是依赖注入是指生成所依赖对象的方式，是自己生成还是别人注入，基于接口而非实现编程关注的不是对象的生成，而是使用对象的地方，是用接口还是具体的实现来编程，以以后扩展比较方便，复合开闭原则。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504775,"discussion_content":"所有的行为模式都是将行为分离，这点不是访问者模式独有的。如果支持double dispatch，完全没必要有访问者模式。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598833605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162658,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1576574498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576574498","product_id":100039001,"comment_content":"JunitApplication.register(new UserServiceTest();这段代码少了个括号吧？","like_count":0},{"had_liked":false,"id":162651,"user_name":"草原上的奔跑","can_delete":false,"product_type":"c1","uid":1120348,"ip_address":"","ucode":"D69C617F767736","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/5c/1a58e8f6.jpg","comment_is_top":false,"comment_ctime":1576573441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576573441","product_id":100039001,"comment_content":"基于接口而非实现编程，那我基于接口了，我的实现怎么办呢，这个时候，依赖注入来了，给你注入一个你需要的实现。依赖注入可以灵活配置，极大的增强了程序的灵活性，可扩展性。只要接口设计好，通过依赖注入，实现随便换！","like_count":0},{"had_liked":false,"id":162595,"user_name":"нáпの゛","can_delete":false,"product_type":"c1","uid":1130666,"ip_address":"","ucode":"834FA877EFBAF7","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/aa/49bbb007.jpg","comment_is_top":false,"comment_ctime":1576562502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576562502","product_id":100039001,"comment_content":"课后题理解“基于接口而非实现编程”是一种指导思想，依赖注入是在这个思想指导下的具体实现，注入相当于基于接口，在类里new相当于实现编程。<br>还需要老师不定期加餐来个同一解答。","like_count":0},{"had_liked":false,"id":162521,"user_name":"饭","can_delete":false,"product_type":"c1","uid":1610573,"ip_address":"","ucode":"B3F1702D4DE604","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","comment_is_top":false,"comment_ctime":1576548382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576548382","product_id":100039001,"comment_content":"“基于接口而非实现编程”：是一种编程指导思想<br>“依赖注入”：是具体的编程技巧，它在实现过程中，往往又会结合“基于接口而非实现编程”，实现创建类与具体被依赖类的解藕","like_count":0},{"had_liked":false,"id":162351,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1576502989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576502989","product_id":100039001,"comment_content":"基于接口而非编程  强调 接口 概念<br>依赖注入  类接口都可以","like_count":0},{"had_liked":false,"id":162278,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1576491344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576491344","product_id":100039001,"comment_content":"依赖注入可以基于接口而非实现编程，也可以基于实现编程，讲得是类或模块之间的依赖如何实现。<br><br>而基于接口编程主要是从类或模块自身的扩展性出发的。","like_count":0},{"had_liked":false,"id":162251,"user_name":"歌顿","can_delete":false,"product_type":"c1","uid":1154982,"ip_address":"","ucode":"EA84E55C61F61A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIVA6yj0YzARUJV3uqD5Qu0OUNbypl5QvCEwx0rTXubaXlU9TPoorQaZT8SMMvXZMnHLjIpBvIsnA/132","comment_is_top":false,"comment_ctime":1576487178,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1576487178","product_id":100039001,"comment_content":"前端er 表示 Tomcat，Sevlet 规范 是什么鬼。。<br><br>作者能不能尽量写代码例子而不是举这些框架，如果是希望我们还去学习框架那肯定是不可能了","like_count":0},{"had_liked":false,"id":162244,"user_name":"马哲富","can_delete":false,"product_type":"c1","uid":1107917,"ip_address":"","ucode":"D6BDDFE3CC07ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg","comment_is_top":false,"comment_ctime":1576486016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576486016","product_id":100039001,"comment_content":"控制指的是程序的执行逻辑；反转指的是不由程序员来控制程序执行，而是由框架来控制；依赖注入指的是不在一个类内部直接new一个对象，而是在外部创建好了直接传进来使用（有点类似于组合关系）","like_count":0},{"had_liked":false,"id":162224,"user_name":"ismind","can_delete":false,"product_type":"c1","uid":1138710,"ip_address":"","ucode":"7AADD673ED3BC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/16/d1dd4972.jpg","comment_is_top":false,"comment_ctime":1576480031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576480031","product_id":100039001,"comment_content":"个人的理解：<br><br>一，首先，来简单梳理着两个语句的含义：<br>1）基于接口而非实现编程，可以看到，在一个类ClazzA的方法中，<br>如果需要将某一个类ClazzB作为参数，那么建议将类ClazzB替换为接口。<br>2）依赖注入，在一个类ClazzA中，需要用到某一个类ClazzB，<br>不需要在ClazzA里直接new ClazzB，而是在ClazzA外创建好，通过构造函数或者函数参数传递给ClazzA。<br><br>二，比较区别与联系<br>1，区别<br>1）基于接口而非实现编程是一种原则，而依赖注入是一种具体的编码技巧。<br>2）依赖注入可以有依赖注入框架，而基于接口而非实现编程则没有基于接口而非实现编程框架。<br><br>2，联系<br>1）二者都可以通过接口来实现类的传递，二者有些类似。<br>2）二者都是将某一个类或者接口作为参数传递到另一个类中。<br>3）可以看到，二者都有效提高了代码的扩展性，无论是基于接口而非实现编程，还是依赖注入<br>最终的目的都是提高代码的扩展性、灵活性，越能应对未来的需求变化，殊途同归！<br><br>以上是个人的见解，还请多指教。","like_count":0},{"had_liked":false,"id":162206,"user_name":"potato00fa","can_delete":false,"product_type":"c1","uid":1307080,"ip_address":"","ucode":"D179E68D87CC50","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/c8/8e6dc340.jpg","comment_is_top":false,"comment_ctime":1576477295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576477295","product_id":100039001,"comment_content":"控制反转不仅可以用在代码设计上，也可以用在架构设计上。比如分布式环境中，要做一个限频功能，如果每个系统每个接口都自己实现限流算法和频次，就会难以管理和控制，但是如果把限频的功能都反转到一个独立的系统，接口每次被调用之前都去问询该系统，情况就会好得多。","like_count":0},{"had_liked":false,"id":162173,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1576471066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576471066","product_id":100039001,"comment_content":"个人认为：<br>1.基于接口编程而非实现编程是一种设计思想，用以提高程序的扩展性。依赖注入是控制反转的一种实现方式，主要用于简化我们项目的开发。<br>2.依赖注入在遵守基于接口编程而非实现编程原则的基础上去实现，会提高程序的扩展性。","like_count":0},{"had_liked":false,"id":162172,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1576470960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576470960","product_id":100039001,"comment_content":"基于接口而非实现编程:主要是为了应对变化，提升扩展性。<br>依赖注入: 主要是为了减少依赖，把互相之间的依赖关系，通过配置或少量代码描述出来。比如spring直接注入一个实现类A。某一天换成B的时候，违反了基于接口编程，但是还符合依赖注入。<br>共同目的:都是为了增加扩展性","like_count":0},{"had_liked":false,"id":162166,"user_name":"quietwater","can_delete":false,"product_type":"c1","uid":1055029,"ip_address":"","ucode":"C25E2CD356D3F9","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/35/be8372be.jpg","comment_is_top":false,"comment_ctime":1576469419,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576469419","product_id":100039001,"comment_content":"从 Notification 这个例子来看，“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？依赖注入主要解决创建对象的问题，对象的依赖关系具体实现，是对象的生命周期管理。基于接口编程是我们要依赖抽象不要依赖具体实现，是面向抽象编程，是解决依赖关系的策略。","like_count":0},{"had_liked":false,"id":162164,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1576468776,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576468776","product_id":100039001,"comment_content":"接口是一种契约形式的编程约定，给依赖注入落地的提供手段，方便编译器进行检查。<br>依赖契约优先。","like_count":0},{"had_liked":false,"id":162149,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1576466998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576466998","product_id":100039001,"comment_content":"课堂讨论Answer：<br><br><br><br>基于接口而非实现编程 是 里氏替换原则（Liskov Substitution Principle）理论下的具体实践，“依赖注入”是 依赖倒置原则（Dependency Injection Principle）理论下的具体实践。<br><br><br><br>关于两者的联系：<br><br>“基于接口而非实现编程”和”依赖注入“都是抽象理论指导下的编码实践，而且关注核心问题都是：依赖抽象。<br><br><br><br>关于两者的区别：<br><br>”基于接口而非实现编程“在具体实践上更强调接口与实现类的契约关系，即接口指导并约束实现类的职责，实现类负责在接口的指导下完成符合规范的功能。<br><br>而”依赖注入“在编码上更关注类与类之间的依赖关系，应该依赖抽象，而不是依赖具体。","like_count":0},{"had_liked":false,"id":162141,"user_name":"kyle","can_delete":false,"product_type":"c1","uid":1631655,"ip_address":"","ucode":"53F0E544933798","user_header":"https://static001.geekbang.org/account/avatar/00/18/e5/a7/bf2ca8fc.jpg","comment_is_top":false,"comment_ctime":1576466346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576466346","product_id":100039001,"comment_content":"依赖注入指的是编程的思想，有很多种方法实现DI, 对于c# 文中的例子是构造函数输入，也可以是通过属性输入，等等。","like_count":0},{"had_liked":false,"id":162126,"user_name":"SMTCode","can_delete":false,"product_type":"c1","uid":1109038,"ip_address":"","ucode":"0D837A753E4FAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/2e/49d13bd2.jpg","comment_is_top":false,"comment_ctime":1576464273,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576464273","product_id":100039001,"comment_content":"控制反转 (IOC: Inversion Of Control):<br><br>控制反转框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员在利用框架进行开发时，只需要往框架的预留点上，添加跟自己业务相关的代码，就可以利用这个框架来驱动整个程序流程的执行。<br><br>即：在框架中实现业务逻辑的控制流程，程序员只需要添加具体的业务逻辑即可，减少业务逻辑与控制逻辑的耦合。<br>依赖注入 (DI: Dependency )<br><br>不通过new的方式在类内部创建对象，而是将依赖的对象在外部创建好后，通过构造函数、函数参数等方式，将对象传递给类使用。<br><br>这样可以提高代码的扩展性，可以灵活替换依赖的类。<br>依赖注入框架(DI Framework):<br><br>通过依赖注入框架的扩展点，简单配置一下所有需要的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。<br>依赖翻转原则(DIP: Dependency Inversion Principle):<br><br>High-level modules shouldn&#39;t depend on low-level modules.<br>Both modules should depend on abstractions. <br>In addition, abstractions shouldn&#39;t depend details.<br>Details should depend abstractions.<br><br>高层模块不应当依赖低层模块。<br>高层模块和低层模块都应依赖于抽象。<br>此外，抽象不能依赖于细节。<br>细节应当依赖于抽象。<br><br>这条原则主要是针对框架而言的，在日常的业务逻辑中，高层模块还是要依赖低层模块的。","like_count":0},{"had_liked":false,"id":162114,"user_name":"潜默闻雨","can_delete":false,"product_type":"c1","uid":1323147,"ip_address":"","ucode":"E597ECBC0A1BB5","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/8b/3334f23e.jpg","comment_is_top":false,"comment_ctime":1576463062,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1576463062","product_id":100039001,"comment_content":"现实工程中的依赖反转：银行网贷项目。银行定义为高层（资金方），各大网贷平台定义为底层（资产方，各种网贷app）。银行想放贷款赚钱，这个时候就去找各大网贷app去商议，你们帮我提供客户，我给你们钱。然后银行便一个一个的对接网贷app，每联系一个就谈一次需求，网贷app千万多，奈何我银行没几个。然后，资金方发现自己依赖于每一个资产方，一旦资产方有什么业务变动，资金方自己必须也做响应调整，实属麻烦。这个时候突然跳出个中间商（可以理解为抽象），说资金方资产方，你们的业务我来帮你解决吧，我提供一个平台，定义一套标准，资金方你只管给钱，资产方你只管提供客户借钱，保证让每个客户都贷到款。这下整个生产线便十分通畅了，资金方也不会因为资产方的业务调整而做调整了，所有的变动都由这个中间商来解决了，资金方就是放放放，资产方就是借借借，其他不再关注。这个是自己在做的项目，我们就是那个中间商。突然联想到，感觉这样比喻应该没问题😁。顺便提醒下，网贷app利率都高的很，银行贷款利率要低很多（没事别乱用网贷，跟高利贷没啥区别，就算是大平台，依然高的很）","like_count":0,"discussions":[{"author":{"id":1631655,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e5/a7/bf2ca8fc.jpg","nickname":"kyle","note":"","ucode":"53F0E544933798","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85305,"discussion_content":"具体实现是不是，你们作为中间方，针对资金方和资产方各提供一套接口，他们各自实现就可以了？ 新的app只要按照接口实现即可。资金划拨是实时的还是通过中间的保证金？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576538585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1323147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/8b/3334f23e.jpg","nickname":"潜默闻雨","note":"","ucode":"E597ECBC0A1BB5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1631655,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e5/a7/bf2ca8fc.jpg","nickname":"kyle","note":"","ucode":"53F0E544933798","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85485,"discussion_content":"接口由中间商各自跟资金方资产方对接设计。资金划拨一部分是实时风控实时放款，一部分是保证金那种，资产方批量推送资金方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576549020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85305,"ip_address":""},"score":85485,"extra":""}]}]},{"had_liked":false,"id":162112,"user_name":"your problem？","can_delete":false,"product_type":"c1","uid":1457464,"ip_address":"","ucode":"6E096E7958CFD7","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/38/6f02a4b9.jpg","comment_is_top":false,"comment_ctime":1576462905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576462905","product_id":100039001,"comment_content":"思考题：<br>区别：基于接口而非实现编程是一种指导原则，描述的是从细节上的一个函数，到宏观上的系统对接不应该依赖于具体实现而是依赖于抽象的接口对接，而依赖注入则是指不从内部建立具体的类依赖而将依赖通过注入或者传参等方式导入，是一种通过抽象降低依赖的具体编码实现<br>联系：可以通过基于接口编程思想来实现依赖注入（依赖注入框架就是这么做的）<br>不知道理解的有问题没有，请老师和大家来指点一下","like_count":0},{"had_liked":false,"id":162109,"user_name":"划时代","can_delete":false,"product_type":"c1","uid":1061454,"ip_address":"","ucode":"9554CE2F83B77F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2o1Izf2YyJSnnI0ErZ51pYRlnrmibqUTaia3tCU1PjMxuwyXSKOLUYiac2TQ5pd5gNGvS81fVqKWGvDsZLTM8zhWg/132","comment_is_top":false,"comment_ctime":1576462595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576462595","product_id":100039001,"comment_content":"控制反转、依赖注入、依赖反转原则，已经在我设计开发的开发框架中熟练运用了，线上产品运行稳定，但我却不知道它们的名字。先知道框架代码的设计实现方式，后知道设计模式概念。后知后觉。","like_count":0},{"had_liked":false,"id":162108,"user_name":"Askerlve","can_delete":false,"product_type":"c1","uid":1178535,"ip_address":"","ucode":"BF29F9A8674507","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/a7/12c90699.jpg","comment_is_top":false,"comment_ctime":1576462360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576462360","product_id":100039001,"comment_content":"打开，讲得好～","like_count":0},{"had_liked":false,"id":162104,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1576461915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576461915","product_id":100039001,"comment_content":"以前也学过几次，每次都是了解的一知半解，回头就忘记，这回听完还是这种感觉，可能要多看这些名字，然后对应的代码，反复思考，循环记忆啊，这回一定要加深理解，行程条件反射。","like_count":0},{"had_liked":false,"id":162098,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1576461083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576461083","product_id":100039001,"comment_content":"我觉得依赖注入是基于面相接口编程这种思想的吧。<br>在举个与题解无关的例子，就是spring怎么做到不去new的，他将抽象指向具体实现这一步放到了配置文件里，然后利用工厂模式完美解耦合。","like_count":0},{"had_liked":false,"id":162095,"user_name":"liu_liu","can_delete":false,"product_type":"c1","uid":1019138,"ip_address":"","ucode":"24283806A07759","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","comment_is_top":false,"comment_ctime":1576461030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576461030","product_id":100039001,"comment_content":"依赖注入可以采用“基于接口编程”原则来实现","like_count":0},{"had_liked":false,"id":162094,"user_name":"逆风星痕","can_delete":false,"product_type":"c1","uid":1420482,"ip_address":"","ucode":"1E18E46E8DA58E","user_header":"https://static001.geekbang.org/account/avatar/00/15/ac/c2/aec60ae2.jpg","comment_is_top":false,"comment_ctime":1576460897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576460897","product_id":100039001,"comment_content":"两者都是为了提高代码的可扩展性，依赖注入是一个更全的指导原则，基于接口而非实现编程可以看着是其的一种实现，同时也进行了扩展。","like_count":0},{"had_liked":false,"id":162088,"user_name":"峰峰","can_delete":false,"product_type":"c1","uid":1262507,"ip_address":"","ucode":"E2207B6E68F255","user_header":"https://static001.geekbang.org/account/avatar/00/13/43/ab/ec100d05.jpg","comment_is_top":false,"comment_ctime":1576460064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576460064","product_id":100039001,"comment_content":"基于接口而非实现编程是对类设计的一种思想原则，依赖注入是具体的编码实现。<br>其中，依赖注入通过参数化的方式解决了在类中直接new对象的过程，也是解决了类与类的耦合。<br>不过，基于依赖注入在方法定义上使用具体的实现类的话，那么扩展性的问题没有解决。我们往往使用多态这一特性使得父类对象引用子类对象的方式达到好的扩展性。<br>因此，依赖注入的实现是在基于接口而非实现编程的设计原则之上的一种具体编程实现。","like_count":0},{"had_liked":false,"id":162079,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1576458937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576458937","product_id":100039001,"comment_content":"基于接口而非实现编程是一种编程思想，依赖注入是一种编程技巧，前者依赖后者。如果不用依赖注入，那就必须在调用类内部创建被调用类的对象，这样一来，被调用类就只能是一个具体的类而不能是一个接口，基于接口而非实现编程就无从谈起了","like_count":0},{"had_liked":false,"id":162076,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1576458713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576458713","product_id":100039001,"comment_content":"共同点：它们都需要一起维护和遵守一份规则。<br>区别点：基于接口非实现，重在说定义一份规则；而后者，侧重说，你要如何遵守依赖注入的规则。","like_count":0},{"had_liked":false,"id":162074,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1576458697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576458697","product_id":100039001,"comment_content":"依赖注入是一种具体方式，而基于接口而非实现编程是一种思想，两者搭配可以更灵活使用依赖注入，让代码的拓展性变得更好","like_count":0},{"had_liked":false,"id":162069,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1576458349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576458349","product_id":100039001,"comment_content":"一直用spring，从未如此清晰理解ioc和di。学习了","like_count":0},{"had_liked":false,"id":162045,"user_name":"Xs.Ten","can_delete":false,"product_type":"c1","uid":1128376,"ip_address":"","ucode":"2368B9BDDDEE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/b8/c887a5ea.jpg","comment_is_top":false,"comment_ctime":1576455963,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576455963","product_id":100039001,"comment_content":"“基于接口而非实现编程”是一种编程思想，而依赖注入是“基于接口而非实现编程”的具体实现。","like_count":0},{"had_liked":false,"id":162042,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1576455237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576455237","product_id":100039001,"comment_content":"依赖注入是被动的，框架提程序员做了管理bean的事，基于接口而实现限编程是主动的，是程序员自己控制的","like_count":0},{"had_liked":false,"id":162040,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1576455103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576455103","product_id":100039001,"comment_content":"一个是设计思想，一个是编码技巧。目的都是为了解耦合，不要直接依赖，而是通过上层抽象关联，这样服务方的改动，并不会影响调用方的使用。最终还是一个开闭原则。","like_count":0},{"had_liked":false,"id":162038,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1576454757,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576454757","product_id":100039001,"comment_content":"控制反转和基于接口编程都不依赖具体的实现细节","like_count":0},{"had_liked":false,"id":162030,"user_name":"Aaron Cheung","can_delete":false,"product_type":"c1","uid":1079816,"ip_address":"","ucode":"03972759C53667","user_header":"https://static001.geekbang.org/account/avatar/00/10/7a/08/4d3e47dd.jpg","comment_is_top":false,"comment_ctime":1576452595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576452595","product_id":100039001,"comment_content":"起床打个卡","like_count":0}]}