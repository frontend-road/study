{"id":502584,"title":"14｜DI Container（2）：如何通过Sad Path为容器增加功能？","content":"<p>你好，我是徐昊。今天我们将继续使用TDD的方式来实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code>package geektime.tdd.di;\n  \nimport jakarta.inject.Provider;\nimport java.util.HashMap;\nimport java.util.Map;\n    \npublic class Context {\n    private Map&lt;Class&lt;?&gt;, Provider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n    \n    public &lt;ComponentType&gt; void bind(Class&lt;ComponentType&gt; type, ComponentType instance) {\n        providers.put(type, (Provider&lt;ComponentType&gt;) () -&gt; instance);\n    }\n    \n    public &lt;ComponentType, ComponentImplementation extends ComponentType&gt;\n    void bind(Class&lt;ComponentType&gt; type, Class&lt;ComponentImplementation&gt; implementation) {\n        providers.put(type, (Provider&lt;ComponentType&gt;) () -&gt; {\n            try {\n                return (ComponentType) implementation.getConstructor().newInstance();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n    \n    public &lt;ComponentType&gt; ComponentType get(Class&lt;ComponentType&gt; type) {\n        return (ComponentType) providers.get(type).get();\n    }\n}\n</code></pre><p>任务列表状态为：</p><ul>\n<li>\n<p><s>无需构造的组件——组件实例</s></p>\n</li>\n<li>\n<p>如果注册的组件不可实例化，则抛出异常</p>\n<ul>\n<li>抽象类</li>\n<li>接口</li>\n</ul>\n</li>\n<li>\n<p>构造函数注入</p>\n<ul>\n<li><s>无依赖的组件应该通过默认构造函数生成组件实例</s></li>\n<li>有依赖的组件，通过Inject标注的构造函数生成组件实例</li>\n<li>如果所依赖的组件也存在依赖，那么需要对所依赖的组件也完成依赖注入</li>\n<li>如果组件有多于一个Inject标注的构造函数，则抛出异常</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>字段注入</p>\n<ul>\n<li>通过Inject标注将字段声明为依赖组件</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果字段为final则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>方法注入</p>\n<ul>\n<li>通过Inject标注的方法，其参数为依赖组件</li>\n<li>通过Inject标注的无参数方法，会被调用</li>\n<li>按照子类中的规则，覆盖父类中的Inject方法</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果方法定义类型参数，则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>对Provider类型的依赖</p>\n<ul>\n<li>注入构造函数中可以声明对于Provider的依赖</li>\n<li>注入字段中可以声明对于Provider的依赖</li>\n<li>注入方法中可声明对于Provider的依赖</li>\n</ul>\n</li>\n<li>\n<p>自定义Qualifier的依赖</p>\n<ul>\n<li>注册组件时，可额外指定Qualifier</li>\n<li>注册组件时，可从类对象上提取Qualifier</li>\n<li>寻找依赖时，需同时满足类型与自定义Qualifier标注</li>\n<li>支持默认Qualifier——Named</li>\n</ul>\n</li>\n<li>\n<p>Singleton生命周期</p>\n<ul>\n<li>注册组件时，可额外指定是否为Singleton</li>\n<li>注册组件时，可从类对象上提取Singleton标注</li>\n<li>对于包含Singleton标注的组件，在容器范围内提供唯一实例</li>\n<li>容器组件默认不是Single生命周期</li>\n</ul>\n</li>\n<li>\n<p>自定义Scope标注</p>\n<ul>\n<li>可向容器注册自定义Scope标注的回调</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><h2>视频演示</h2><p>让我们进入今天的部分：</p><p><video poster=\"https://media001.geekbang.org/109133d4dd584bdc8af0b1038b7e1865/snapshots/0955bbd5127f415c8fb1ae9937e13536-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/db5fb95-1801774e640-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/6099dd2413b24ec8868482d15db22e8f/76b3297f891b4de38f849698653bacab-bfd744b531ceb7d88ec7ff4210887c26-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p><video poster=\"https://media001.geekbang.org/bc0fb541fdfd4934b7f729b328167784/snapshots/578c764214f64a0f802b097ed570c5a0-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/ab9bdbf-1801774d7e3-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/561278c9fc4b4696abf0bb9f8f354a81/aaa2e332f5084b78a4d5679a6f08dd35-a4cc29fbebebdbfca81fe81c38338693-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2><strong>思考题</strong></h2><p>下一步将要如何重构已有代码？</p><p>欢迎把你的思考和想法分享在留言区，也欢迎你扫描详情页的二维码加入读者交流群。我们下节课再见！</p>","comments":[{"had_liked":false,"id":344259,"user_name":"JC","can_delete":false,"product_type":"c1","uid":1097553,"ip_address":"","ucode":"A95FACC6EE9851","user_header":"https://static001.geekbang.org/account/avatar/00/10/bf/51/1791ae60.jpg","comment_is_top":false,"comment_ctime":1651403146,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"第二段视频最后，是不是用 Stream.noneMatch 语义上更好些","like_count":5},{"had_liked":false,"id":368303,"user_name":"肖韬","can_delete":false,"product_type":"c1","uid":1059962,"ip_address":"江苏","ucode":"BBCDBFD08C8B8E","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/7a/f2e63f58.jpg","comment_is_top":false,"comment_ctime":1676166116,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"老师，第一段视频中，按照您的 test case，我觉得应该报错。我自己写了相同的代码，确实报错了，但是您的测试用例却没报错，对此百思不得其解。\n\n在 should_bind_type_to_a_class_with_inject_constructor 中，测试用例是这样的：\n\n      Dependency dependency = new Dependency() {};\n      context.bind(Component.class, ComponentWithInjectConstructor.class);\n      context.bind(Dependency.class, dependency);\n\n在 Context#bind(Component.class, ComponentWithInjectConstructor.class) 的实现代码中，会根据依赖类型 Dependency.class，要求context中返回它的一个实例。\n\n\n但是很明显，在测试用例调用 context.bind(Component.class, ComponentWithInjectConstructor.class) 时，dependency 实例此时还不在容器中。所以这里应该报错，但是视频中却没有报错。请老师解答。","like_count":0,"discussions":[{"author":{"id":1258251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/0b/fd18c8ab.jpg","nickname":"大胖子呀、","note":"","ucode":"4BADF8096254BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613694,"discussion_content":"如果你的报错了，说明你存储对象的方式和老师的不一样，老师用的是Provider，是一种“异步”的方式，只有在调用get的时候才会去创建对象。你如果在bind的时候就报错了，说明你是在bind的时候就创建对象了，但是用Provider的话就不一样了，它是在get的时候才会创建对象。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1681462761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}