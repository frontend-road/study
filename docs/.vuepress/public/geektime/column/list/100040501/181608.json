{"id":181608,"title":"13 | 编译期能做些什么？一个完整的计算世界","content":"<p>你好，我是吴咏炜。</p><p>上一讲我们简单介绍了模板的基本用法及其在泛型编程中的应用。这一讲我们来看一下模板的另外一种重要用途——编译期计算，也称作“模板元编程”。</p><h2>编译期计算</h2><p>首先，我们给出一个已经被证明的结论：C++ 模板是图灵完全的 <span class=\"orange\">[1]</span>。这句话的意思是，使用 C++ 模板，你可以在编译期间模拟一个完整的图灵机，也就是说，可以完成任何的计算任务。</p><p>当然，这只是理论上的结论。从实际的角度，我们并不<strong>想</strong>、也不可能在编译期完成所有的计算，更不用说编译期的编程是很容易让人看不懂的——因为这并不是语言设计的初衷。即便如此，我们也还是需要了解一下模板元编程的基本概念：它仍然有一些实用的场景，并且在实际的工程中你也可能会遇到这样的代码。虽然我们在开篇就说过不要炫技，但使用模板元编程写出的代码仍然是可理解的，尤其是如果你对递归不发怵的话。</p><p>好，闲话少叙，我们仍然拿代码说话：</p><pre><code class=\"language-c++\">template &lt;int n&gt;\nstruct factorial {\n  static const int value =\n    n * factorial&lt;n - 1&gt;::value;\n};\n\ntemplate &lt;&gt;\nstruct factorial&lt;0&gt; {\n  static const int value = 1;\n};\n</code></pre><!-- [[[read_end]]] --><p>上面定义了一个递归的阶乘函数。可以看出，它完全符合阶乘的递归定义：</p><p>$$<br>\n\\begin{aligned}<br>\n0! &amp;= 1 \\\\\\<br>\nn! &amp;= n \\times (n - 1)!<br>\n\\end{aligned}<br>\n$$</p><p>除了顺序有特定的要求——先定义，才能特化——再加语法有点特别，代码基本上就是这个数学定义的简单映射了。</p><p>那我们怎么知道这个计算是不是在编译时做的呢？我们可以直接看编译输出。下面直接贴出对上面这样的代码加输出（<code>printf(\"%d\\n\", factorial&lt;10&gt;::value);</code>）在 x86-64 下的编译结果：</p><pre><code class=\"language-assembly\">.LC0:\n        .string \"%d\\n\"\nmain:\n        push    rbp\n        mov     rbp, rsp\n        mov     esi, 3628800\n        mov     edi, OFFSET FLAT:.LC0\n        mov     eax, 0\n        call    printf\n        mov     eax, 0\n        pop     rbp\n        ret\n</code></pre><p>我们可以明确看到，编译结果里明明白白直接出现了常量 3628800。上面那些递归什么的，完全都没有了踪影。</p><p>如果我们传递一个负数给 <code>factorial</code> 呢？这时的结果就应该是编译期间的递归溢出。如 GCC 会报告：</p><blockquote>\n<p>fatal error: template instantiation depth exceeds maximum of 900 (use -ftemplate-depth= to increase the maximum)</p>\n</blockquote><p>如果把 <code>int</code> 改成 <code>unsigned</code>，不同的编译器和不同的标准选项会导致不同的结果。有些情况下错误信息完全不变，有些情况下则会报负数不能转换到 <code>unsigned</code>。通用的解决方案是使用 <code>static_assert</code>，确保参数永远不会是负数。</p><pre><code class=\"language-c++\">template &lt;int n&gt;\nstruct factorial {\n  static_assert(\n    n &gt;= 0,\n    \"Arg must be non-negative\");\n  static const int value =\n    n * factorial&lt;n - 1&gt;::value;\n};\n</code></pre><p>这样，当 <code>factorial</code> 接收到一个负数作为参数时，就会得到一个干脆的错误信息：</p><blockquote>\n<p>error: static assertion failed: Arg must be non-negative</p>\n</blockquote><p>下面我们看一些更复杂的例子。这些例子不是为了让你真的去写这样的代码，而是帮助你充分理解编译期编程的强大威力。如果这些例子你都完全掌握了，那以后碰到小的模板问题，你一定可以轻松解决，完全不在话下。</p><p>回想上面的例子，我们可以看到，要进行编译期编程，最主要的一点，是需要把计算转变成类型推导。比如，下面的模板可以代表条件语句：</p><pre><code class=\"language-c++\">template &lt;bool cond,\n          typename Then,\n          typename Else&gt;\nstruct If;\n\ntemplate &lt;typename Then,\n          typename Else&gt;\nstruct If&lt;true, Then, Else&gt; {\n  typedef Then type;\n};\n\ntemplate &lt;typename Then,\n          typename Else&gt;\nstruct If&lt;false, Then, Else&gt; {\n  typedef Else type;\n};\n</code></pre><p><code>If</code> 模板有三个参数，第一个是布尔值，后面两个则是代表不同分支计算的类型，这个类型可以是我们上面定义的任何一个模板实例，包括 <code>If</code> 和 <code>factorial</code>。第一个 struct 声明规定了模板的形式，然后我们不提供通用定义，而是提供了两个特化。第一个特化是真的情况，定义结果 <code>type</code> 为 <code>Then</code> 分支；第二个特化是假的情况，定义结果 <code>type</code> 为 <code>Else</code> 分支。</p><p>我们一般也需要循环：</p><pre><code class=\"language-c++\">template &lt;bool condition,\n          typename Body&gt;\nstruct WhileLoop;\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;true, Body&gt; {\n  typedef typename WhileLoop&lt;\n    Body::cond_value,\n    typename Body::next_type&gt;::type\n    type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;false, Body&gt; {\n  typedef\n    typename Body::res_type type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct While {\n  typedef typename WhileLoop&lt;\n    Body::cond_value, Body&gt;::type\n    type;\n};\n</code></pre><p>这个循环的模板定义稍复杂点。首先，我们对循环体类型有一个约定，它必须提供一个静态数据成员，<code>cond_value</code>，及两个子类型定义，<code>res_type</code> 和 <code>next_type</code>：</p><ul>\n<li><code>cond_value</code> 代表循环的条件（真或假）</li>\n<li><code>res_type</code> 代表退出循环时的状态</li>\n<li><code>next_type</code> 代表下面循环执行一次时的状态</li>\n</ul><p>这里面比较绕的地方是用类型来代表执行状态。如果之前你没有接触过函数式编程的话，这个在初学时有困难是正常的。把例子多看两遍，自己编译、修改、把玩一下，就会渐渐理解的。</p><p>排除这个抽象性，模板的定义和 <code>If</code> 是类似的，虽然我们为方便使用，定义了两个模板。<code>WhileLoop</code> 模板有两个模板参数，同样用特化来决定走递归分支还是退出循环分支。<code>While</code> 模板则只需要循环体一个参数，方便使用。</p><p>如果你之前模板用得不多的话，还有一个需要了解的细节，就是用 <code>::</code> 取一个成员类型、并且 <code>::</code> 左边有模板参数的话，得额外加上 <code>typename</code> 关键字来标明结果是一个类型。上面循环模板的定义里就出现了多次这样的语法。MSVC 在这方面往往比较宽松，不写 <code>typename</code> 也不会报错，但这是不符合 C++ 标准的用法。</p><p>为了进行计算，我们还需要通用的代表数值的类型。下面这个模板可以通用地代表一个整数常数：</p><pre><code class=\"language-c++\">template &lt;class T, T v&gt;\nstruct integral_constant {\n  static const T value = v;\n  typedef T value_type;\n  typedef integral_constant type;\n};\n</code></pre><p><code>integral_constant</code> 模板同时包含了整数的类型和数值，而通过这个类型的 <code>value</code> 成员我们又可以重新取回这个数值。有了这个模板的帮忙，我们就可以进行一些更通用的计算了。下面这个模板展示了如何使用循环模板来完成从 1 加到 n 的计算：</p><pre><code class=\"language-c++\">template &lt;int result, int n&gt;\nstruct SumLoop {\n  static const bool cond_value =\n    n != 0;\n  static const int res_value =\n    result;\n  typedef integral_constant&lt;\n    int, res_value&gt;\n    res_type;\n  typedef SumLoop&lt;result + n, n - 1&gt;\n    next_type;\n};\n\ntemplate &lt;int n&gt;\nstruct Sum {\n  typedef SumLoop&lt;0, n&gt; type;\n};\n</code></pre><p>然后你使用 <code>While&lt;Sum&lt;10&gt;::type&gt;::type::value</code> 就可以得到 1 加到 10 的结果。虽然有点绕，但代码实质就是在编译期间进行了以下的计算：</p><pre><code class=\"language-c++\">int result = 0;\nwhile (n != 0) {\n  result = result + n;\n  n = n - 1;\n}\n</code></pre><p>估计现在你的头已经很晕了。但我保证，这一讲最难的部分已经过去了。实际上，到现在为止，我们讲的东西还没有离开 C++98。而我们下面几讲里很快就会讲到，如何在现代 C++ 里不使用这种麻烦的方式也能达到同样的效果。</p><h2>编译期类型推导</h2><p>C++ 标准库在 &lt;type_traits&gt; 头文件里定义了很多工具类模板，用来提取某个类型（type）在某方面的特点（trait）<span class=\"orange\">[2]</span>。和上一节给出的例子相似，这些特点既是类型，又是常值。</p><p>为了方便地在值和类型之间转换，标准库定义了一些经常需要用到的工具类。上面描述的 <code>integral_constant</code> 就是其中一个（我的定义有所简化）。为了方便使用，针对布尔值有两个额外的类型定义：</p><pre><code class=\"language-c++\">typedef std::integral_constant&lt;\n  bool, true&gt; true_type;\ntypedef std::integral_constant&lt;\n  bool, false&gt; false_type;\n</code></pre><p>这两个标准类型 <code>true_type</code> 和 <code>false_type</code> 经常可以在函数重载中见到。有一个工具函数常常会写成下面这个样子：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass SomeContainer {\npublic:\n  …\n  static void destroy(T* ptr)\n  {\n    _destroy(ptr,\n      is_trivially_destructible&lt;\n        T&gt;());\n  }\n\nprivate:\n  static void _destroy(T* ptr,\n                       true_type)\n  {}\n  static void _destroy(T* ptr,\n                       false_type)\n  {\n    ptr-&gt;~T();\n  }\n};\n</code></pre><p>类似上面，很多容器类里会有一个 <code>destroy</code> 函数，通过指针来析构某个对象。为了确保最大程度的优化，常用的一个技巧就是用 <code>is_trivially_destructible</code> 模板来判断类是否是可平凡析构的——也就是说，不调用析构函数，不会造成任何资源泄漏问题。模板返回的结果还是一个类，要么是 <code>true_type</code>，要么是 <code>false_type</code>。如果要得到布尔值的话，当然使用 <code>is_trivially_destructible&lt;T&gt;::value</code> 就可以，但此处不需要。我们需要的是，使用 <code>()</code> 调用该类型的构造函数，让编译器根据数值类型来选择合适的重载。这样，在优化编译的情况下，编译器可以把不需要的析构操作彻底全部删除。</p><p>像 <code>is_trivially_destructible</code> 这样的 trait 类有很多，可以用来在模板里决定所需的特殊行为：</p><ul>\n<li><code>is_array</code></li>\n<li><code>is_enum</code></li>\n<li><code>is_function</code></li>\n<li><code>is_pointer</code></li>\n<li><code>is_reference</code></li>\n<li><code>is_const</code></li>\n<li><code>has_virtual_destructor</code></li>\n<li>…</li>\n</ul><p>这些特殊行为判断可以是像上面这样用于决定不同的重载，也可以是直接用在模板参数甚至代码里（记得我们是可以直接得到布尔值的）。</p><p>除了得到布尔值和相对应的类型的 trait 模板，我们还有另外一些模板，可以用来做一些类型的转换。以一个常见的模板 <code>remove_const</code> 为例（用来去除类型里的 const 修饰），它的定义大致如下：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nstruct remove_const {\n  typedef T type;\n};\ntemplate &lt;class T&gt;\nstruct remove_const&lt;const T&gt; {\n  typedef T type;\n};\n</code></pre><p>同样，它也是利用模板的特化，针对 const 类型去掉相应的修饰。比如，如果我们对 <code>const string</code> 应用 <code>remove_const</code>，就会得到 <code>string</code>，即，<code>remove_const&lt;const string&gt;::type</code> 等价于 <code>string</code>。</p><p>这里有一个细节你要注意一下，如果对 <code>const char*</code> 应用 <code>remove_const</code> 的话，结果还是 <code>const char*</code>。原因是，<code>const char*</code> 是指向 <code>const char</code> 的指针，而不是指向 <code>char</code> 的 const 指针。如果我们对 <code>char * const</code> 应用 <code>remove_const</code> 的话，还是可以得到 <code>char*</code> 的。</p><h3>简易写法</h3><p>如果你觉得写 <code>is_trivially_destructible&lt;T&gt;::value</code> 和 <code>remove_const&lt;T&gt;::type</code> 非常啰嗦的话，那你绝不是一个人。在当前的 C++ 标准里，前者有增加 <code>_v</code> 的编译时常量，后者有增加 <code>_t</code> 的类型别名：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\ninline constexpr bool\n  is_trivially_destructible_v =\n    is_trivially_destructible&lt;\n      T&gt;::value;\n</code></pre><pre><code class=\"language-c++\">template &lt;class T&gt;\nusing remove_const_t =\n  typename remove_const&lt;T&gt;::type;\n</code></pre><p>至于什么是 <code>constexpr</code>，我们会单独讲。<code>using</code> 是现代 C++ 的新语法，功能大致与 <code>typedef</code> 相似，但 <code>typedef</code> 只能针对某个特定的类型，而 <code>using</code> 可以生成别名模板。目前我们只需要知道，在你需要 trait 模板的结果数值和类型时，使用带 <code>_v</code> 和 <code>_t</code> 后缀的模板可能会更方便，尤其是带 <code>_t</code> 后缀的类型转换模板。</p><h2>通用的 fmap 函数模板</h2><p>你应当多多少少听到过 map-reduce。抛开其目前在大数据应用中的具体方式不谈，从概念本源来看，map <span class=\"orange\">[3]</span> 和 reduce <span class=\"orange\">[4]</span> 都来自函数式编程。下面我们演示一个 map 函数（当然，在 C++ 里它的名字就不能叫 <code>map</code> 了），其中用到了目前为止我们学到的多个知识点：</p><pre><code class=\"language-c++\">template &lt;\n  template &lt;typename, typename&gt;\n  class OutContainer = vector,\n  typename F, class R&gt;\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs)\n{\n  typedef decay_t&lt;decltype(\n    f(*inputs.begin()))&gt;\n    result_type;\n  OutContainer&lt;\n    result_type,\n    allocator&lt;result_type&gt;&gt;\n    result;\n  for (auto&amp;&amp; item : inputs) {\n    result.push_back(f(item));\n  }\n  return result;\n}\n</code></pre><p>我们：</p><ul>\n<li>用 <code>decltype</code> 来获得用 <code>f</code> 来调用 <code>inputs</code> 元素的类型（参考<a href=\"https://time.geekbang.org/column/article/176850\">[第 8 讲]</a>）；</li>\n<li>用 <code>decay_t</code> 来把获得的类型变成一个普通的值类型；</li>\n<li>缺省使用 <code>vector</code> 作为返回值的容器，但可以通过模板参数改为其他容器；</li>\n<li>使用基于范围的 for 循环来遍历 <code>inputs</code>，对其类型不作其他要求（参考<a href=\"https://time.geekbang.org/column/article/176842\">[第 7 讲]</a>）；</li>\n<li>存放结果的容器需要支持 <code>push_back</code> 成员函数（参考<a href=\"https://time.geekbang.org/column/article/173167\">[第 4 讲]</a>）。</li>\n</ul><p>下面的代码可以验证其功能：</p><pre><code class=\"language-c++\">vector&lt;int&gt; v{1, 2, 3, 4, 5};\nint add_1(int x)\n{\n    return x + 1;\n}\n\nauto result = fmap(add_1, v);\n</code></pre><p>在 <code>fmap</code> 执行之后，我们会在 <code>result</code> 里得到一个新容器，其内容是 2, 3, 4, 5, 6。</p><h2>内容小结</h2><p>本讲我们介绍了模板元编程的基本概念和例子，其本质是<strong>把计算过程用编译期的类型推导和类型匹配表达出来</strong>；然后介绍 type traits 及其基本用法；最后我们演示了一个简单的高阶函数 map，其实现中用到了我们目前已经讨论过的一些知识点。</p><h2>课后思考</h2><p>这一讲的内容可能有点烧脑，请你自行实验一下例子，并找一两个简单的算法用模板元编程的方法实现一下，看看能不能写出来。</p><p>如果有什么特别想法的话，欢迎留言和我分享交流。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Todd L. Veldhuizen, “C++ templates are Turing complete”. <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670\">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “Standard library header &lt;type_traits&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/type_traits\">https://en.cppreference.com/w/cpp/header/type_traits</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “标准库头文件 &lt;type_traits&gt;”. <a href=\"https://zh.cppreference.com/w/cpp/header/type_traits\">https://zh.cppreference.com/w/cpp/header/type_traits</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “Map (higher-order function)”. <a href=\"https://en.wikipedia.org/wiki/Map_(higher-order_function)\">https://en.wikipedia.org/wiki/Map_(higher-order_function)</a> </span></p><p><span class=\"reference\">[4] Wikipedia, “Fold (higher-order function)”. <a href=\"https://en.wikipedia.org/wiki/Fold_(higher-order_function)\">https://en.wikipedia.org/wiki/Fold_(higher-order_function)</a> </span></p>","comments":[{"had_liked":false,"id":165563,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1577260644,"is_pvip":false,"replies":[{"id":63150,"content":"对，对于模板，就是要在脑子里或纸上、电脑上把它展开……☺️","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577275419,"ip_address":"","comment_id":165563,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"脑壳儿疼的兄弟姐妹们，我这有个小偏方， 哈哈\n\nWhile&lt; Sum&lt;2&gt;::type &gt;::type::value 实例化(instantiation)过程\n--&gt; While&lt; SumLoop&lt;0, 2&gt; &gt;::type::value\n--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;&gt;::type::value\n--&gt; WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type::value\n\n--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type&gt;::type::value\n--&gt; WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type::value\n\n--&gt; WhileLoop&lt;SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type&gt;::type::value\n--&gt; WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type::value\n\n--&gt; WhileLoop&lt;SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type&gt;::type::value\n--&gt; WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type::value\n\n--&gt; SumLoop&lt;3, -1&gt;::res_type::value\n\n--&gt;integral_constant&lt;int, 3&gt;::value\n--&gt;3","like_count":22},{"had_liked":false,"id":165604,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577267357,"is_pvip":false,"replies":[{"id":63164,"content":"下面的函数和模板是基本等价的：\n\nint foo(int n)\n{\n  if (n == 2 || n == 3 || n == 5) {\n    return 1;\n  } else {\n    return 2;\n  }\n}\n\ntemplate &lt;int n&gt;\nstruct Foo {\n  typedef typename If&lt;\n    (n == 2 || n == 3 || n == 5),\n    integral_constant&lt;int, 1&gt;,\n    integral_constant&lt;int, 2&gt;&gt;::type\n    type;\n};\n\n你可以输出 foo(3)，也可以输出 Foo&lt;3&gt;::type::value。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577283642,"ip_address":"","comment_id":165604,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"记得吴老师之前预告过，这一节可能会比较难，确实被难住了。在第一个 If 模板这里就被卡住了，老师能给个简单的例子来说明这个 If 模板该如何使用么？","like_count":10,"discussions":[{"author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630886,"discussion_content":"加上注释帮助大家理解，整个过程就是不断的先推导模板参数和推导::type 类型，过程中不断的做 substitution\nWhile&lt; Sum&lt;2&gt;::type &gt;::type::value 实例化(instantiation)过程\n\n--&gt; While&lt; Sum&lt;2&gt;::type &gt;::type::value                                           // 推导 Sum&lt;2&gt;::type\n--&gt; While&lt; SumLoop&lt;0, 2&gt; &gt;::type::value                                          // 推导 While&lt; SumLoop&lt;0, 2&gt;::type\n--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;&gt;::type::value             // 推导 SumLoop&lt;0, 2&gt;::cond_value\n--&gt; WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type::value                                  // 推导 WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type\n\n--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type&gt;::type::value  // 推导 SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type\n--&gt; WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type::value                                  // 推导 WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type\n\n--&gt; WhileLoop&lt;SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type&gt;::type::value  // 推导 SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type\n--&gt; WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type::value                                  // 推导 WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type\n\n--&gt; WhileLoop&lt;SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type&gt;::type::value  // 推导 SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type\n--&gt; WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type::value                                // 推导 WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type\n\n--&gt; SumLoop&lt;3, -1&gt;::res_type::value                                              // 推导 SumLoop&lt;3, -1&gt;::res_type, 生成integral_constant&lt;int, 3&gt;\n\n--&gt;integral_constant&lt;int, 3&gt;::value                                              // 获取 静态变量 value\n--&gt;3","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1699003481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479206,"discussion_content":"对，对于模板，就是要在脑子里或纸上、电脑上把它展开……☺️","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577275419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2006194,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/9c/b2/1a9beeb1.jpg","nickname":"转遍世界","note":"","ucode":"0783BFDDE87029","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634718,"discussion_content":"从上面的展开我有两个疑问，一是SumLoop&lt;0, 2&gt;::cond_value初始条件第一次用没进入下次循环体即SumLoop&lt;0, 2&gt;::next_type，第二次用了才进入？二是n==0时条件为false时还计算了next_type，即把0加到了结果，这样很可能导致错误，\n怎么解决？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703835603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":479206,"ip_address":"江苏","group_id":0},"score":634718,"extra":""}]}]},{"had_liked":false,"id":296048,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1622715836,"is_pvip":false,"replies":[{"id":107512,"content":"谢谢抓虫🙏。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1622869253,"ip_address":"","comment_id":296048,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"比如，如果我们对 const string&amp; 应用 remove_const，就会得到 string&amp;，即，remove_const::type 等价于 string&amp;。\n\nremove_const只能去顶层const。const string&amp;应用remove_const后还是const string&amp;，const string应用remove_const后是string。","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479222,"discussion_content":"下面的函数和模板是基本等价的：\n\nint foo(int n)\n{\n  if (n == 2 || n == 3 || n == 5) {\n    return 1;\n  } else {\n    return 2;\n  }\n}\n\ntemplate &amp;lt;int n&amp;gt;\nstruct Foo {\n  typedef typename If&amp;lt;\n    (n == 2 || n == 3 || n == 5),\n    integral_constant&amp;lt;int, 1&amp;gt;,\n    integral_constant&amp;lt;int, 2&amp;gt;&amp;gt;::type\n    type;\n};\n\n你可以输出 foo(3)，也可以输出 Foo&amp;lt;3&amp;gt;::type::value。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577283642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172312,"user_name":"YouCompleteMe","can_delete":false,"product_type":"c1","uid":1232859,"ip_address":"","ucode":"89B5A75DA85E0A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","comment_is_top":false,"comment_ctime":1579147719,"is_pvip":false,"replies":[{"id":66876,"content":"嗯，是的，你的写法能少展开一次。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579185272,"ip_address":"","comment_id":172312,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"template &lt;typename Body&gt;\nstruct whileLoop&lt;true, Body&gt;\n部分似乎改成下面这样，更直观，\n编译时计算更少呢\n\ntemplate &lt;typename Body&gt;\nstruct whileLoop&lt;true, Body&gt; {\n    typedef typename whileLoop&lt;\n      Body::next_type::cond_value, \n      typename Body::next_type&gt;::type \n      type;\n};","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521305,"discussion_content":"谢谢抓虫🙏。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622869253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328248,"user_name":"莫言","can_delete":false,"product_type":"c1","uid":2174219,"ip_address":"","ucode":"7B4A0D0FF49806","user_header":"https://static001.geekbang.org/account/avatar/00/21/2d/0b/e6836053.jpg","comment_is_top":false,"comment_ctime":1640620214,"is_pvip":false,"replies":[{"id":119580,"content":"模板的参数可以是类型（如 int），可以是值（如长度 8），也可以是其他（类或别名）模板。这个语法代表 OutContainer 是一个带两个类型模板参数的（类或别名）模板。（vector 有两个类型模板参数，第二个有默认值，一般不需要自己提供。）","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1640675172,"ip_address":"","comment_id":328248,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"template &lt;  template &lt;typename, typename&gt;  class OutContainer = vector,  typename F, class R&gt;\n请问老师，这个OutConContainer前面的template&lt;typename,typename&gt;应该怎么理解","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481695,"discussion_content":"嗯，是的，你的写法能少展开一次。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579185272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382426,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1697293170,"is_pvip":false,"replies":[{"id":139381,"content":"我测试了一下，似乎不行？\n\n我就前面加了 &lt;iostream&gt; 的包含和 using。然后就报错了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1697812894,"ip_address":"广东","comment_id":382426,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"分享一下我的代码：实现求最大公约数的辗转相除法\ntemplate &lt;bool Cond, typename Body&gt;\nstruct WhileLoop;\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;true, Body&gt;\n{\n    typedef typename WhileLoop&lt;Body::Cond, typename Body::NextType&gt;::type type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;false, Body&gt;\n{\n    typedef typename Body::ResType type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct While\n{\n    typedef typename WhileLoop&lt;Body::Cond, Body&gt;::type type;\n};\n\ntemplate &lt;typename T, T val&gt;\nstruct integer\n{\n    typedef T ValueType;\n    static const T Value = val;\n    typedef integer type;\n};\n\ntemplate &lt;int lhs, int rhs&gt;\nstruct GCD\n{\n    static const bool Cond = lhs % rhs != 0;\n    static const int result = lhs;\n    typedef integer&lt;int, result&gt; ResType;\n    typedef GCD&lt;rhs, lhs % rhs&gt; NextType;\n};\n\nint main()\n{\n    cout &lt;&lt; While&lt;GCD&lt;100, 56&gt;&gt;::type::Value &lt;&lt; endl;\n    return 0;\n}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542180,"discussion_content":"模板的参数可以是类型（如 int），可以是值（如长度 8），也可以是其他（类或别名）模板。这个语法代表 OutContainer 是一个带两个类型模板参数的（类或别名）模板。（vector 有两个类型模板参数，第二个有默认值，一般不需要自己提供。）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640675172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290495,"user_name":"Geek_15f2c9","can_delete":false,"product_type":"c1","uid":2557701,"ip_address":"","ucode":"3AA686B1D31AB1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Wjsc175urqxxBcCsxSDG5iaWcEq4hIg4SCCVJCIC108Ul5l7US4iaE3iaaMWodSJeybGemicEnfetHFCj9P6QI17xw/132","comment_is_top":false,"comment_ctime":1619590071,"is_pvip":false,"replies":[{"id":105294,"content":"很好的问题。但是，实际必要性不高。\n\n原因是，f(…) 极少会有合法的、返回右值引用的场景。唯一我能想到的可能性是返回值是根据输入的右值生成的情况。这样的话，得保证在输入是个右值容器时传递元素的右值给 f，所以真要考虑这种情况的话，代码比你写的还要再复杂不少……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1619617088,"ip_address":"","comment_id":290495,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，对万能引用使用完美转发是否好点，result.push_back(std::forward&lt;decltype(f(item))&gt;(f(item)))或result.emplace_back(std::forward&lt;decltype(f(item))&gt;(f(item)));;","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629926,"discussion_content":"我测试了一下，似乎不行？\n\n我就前面加了 &lt;iostream&gt; 的包含和 using。然后就报错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697812894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":3201926,"avatar":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","nickname":"李云龙","note":"","ucode":"785924B16BE788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":630236,"discussion_content":"老师您好，我是在Windows上，IDE是visual studio2022, 加上&lt;iostream&gt; 和 using 是可以正常工作的。我没有在gcc上测试，等下我用gcc试一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698200933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":629926,"ip_address":"北京","group_id":0},"score":630236,"extra":""},{"author":{"id":3201926,"avatar":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","nickname":"李云龙","note":"","ucode":"785924B16BE788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":630255,"discussion_content":"在Linux上用gcc编译确实报错，经过抢修，可通过代码如下，多谢老师提醒：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;bool Cond, typename Body&gt;\nstruct WhileLoop;\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;true, Body&gt;\n{\n    typedef typename WhileLoop&lt;Body::Cond, typename Body::NextType&gt;::type type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;false, Body&gt;\n{\n    typedef typename Body::ResType type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct While\n{\n    typedef typename WhileLoop&lt;Body::Cond, Body&gt;::type type;\n};\n\ntemplate &lt;typename T, T val&gt;\nstruct integer\n{\n    typedef T ValueType;\n    static const T Value = val;\n    typedef integer type;\n};\n\ntemplate &lt;int lhs, int rhs&gt;\nstruct GCD\n{\n    static const bool Cond = rhs != 0 &amp;&amp; rhs % (lhs % rhs) != 0;\n    static const int result = rhs;\n    typedef integer&lt;int, result&gt; ResType;\n    typedef GCD&lt;rhs, lhs% rhs&gt; NextType;\n};\n\nint main()\n{\n    cout &lt;&lt; While&lt;GCD&lt;100, 56&gt;&gt;::type::Value &lt;&lt; endl;\n    return 0;\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698219333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":629926,"ip_address":"北京","group_id":0},"score":630255,"extra":""}]}]},{"had_liked":false,"id":264808,"user_name":"Gazelle","can_delete":false,"product_type":"c1","uid":2049810,"ip_address":"","ucode":"5839E1510A53FE","user_header":"https://static001.geekbang.org/account/avatar/00/1f/47/12/0186b64e.jpg","comment_is_top":false,"comment_ctime":1606658144,"is_pvip":false,"replies":[{"id":96256,"content":"这里有个小细节：const T&amp; 等同于 T const&amp;，但和 T&amp; const 不同。前者是一个指向常量的引用，后者是一个常引用。只有后者才被看作是一个“常量”。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1606788794,"ip_address":"","comment_id":264808,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我实践写了下remove_const，好像没有把const去掉。这里是不是有点问题呢？\nhttps:&#47;&#47;stackoverflow.com&#47;questions&#47;15887144&#47;stdremove-const-with-const-references\n我看这里说是如果同时有const和引用的话，还需要去掉引用？\nstd::remove_const&lt;std::remove_reference&lt;const string&amp;&gt;::type&gt;::type","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519216,"discussion_content":"很好的问题。但是，实际必要性不高。\n\n原因是，f(…) 极少会有合法的、返回右值引用的场景。唯一我能想到的可能性是返回值是根据输入的右值生成的情况。这样的话，得保证在输入是个右值容器时传递元素的右值给 f，所以真要考虑这种情况的话，代码比你写的还要再复杂不少……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619617088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252660,"user_name":"鲁·本","can_delete":false,"product_type":"c1","uid":1209939,"ip_address":"","ucode":"F1DEB30C21B48E","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/53/21d62a23.jpg","comment_is_top":false,"comment_ctime":1602426833,"is_pvip":false,"replies":[{"id":92303,"content":"哈哈，我写的时候头也很大。只是为了说明能写出来，而不是真想&#47;需要这么写。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1602477198,"ip_address":"","comment_id":252660,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"对While&lt;Sum&lt;10&gt;::type&gt;::type::value进行手动推导，最终是能推导出实际语句是 integral_constant&lt;int，10+9+...1&gt;::value的，但让我独立写出 完整的代码是万万不能的😄","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510690,"discussion_content":"这里有个小细节：const T&amp;amp; 等同于 T const&amp;amp;，但和 T&amp;amp; const 不同。前者是一个指向常量的引用，后者是一个常引用。只有后者才被看作是一个“常量”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606788794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223332,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":2005742,"ip_address":"","ucode":"CB7AC741E0E4B7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","comment_is_top":false,"comment_ctime":1591064079,"is_pvip":false,"replies":[{"id":82274,"content":"指的就是这句：\n\n_destroy(ptr, is_trivially_destructible&lt;T&gt;())\n\n这儿构造了一个 true_type 或 false_type 的对象，然后编译器会根据第二个参数的类型，决定调用 _destroy 的哪个重载。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591066358,"ip_address":"","comment_id":223332,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"“如果要得到布尔值的话，当然使用 `is_trivially_destructible::value` 就可以，但此处不需要。需要的是，使用 `()` 调用该类型的构造函数，让编译器根据数值类型来选择合适的重载。这样，在优化编译的情况下，编译器可以把不需要的析构操作彻底全部删除。”\n老师，这里没太懂，使用 `()` 调用该类型的构造，这里的调用是在哪里调用，为什么 destroy 要调用构造函数","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506828,"discussion_content":"哈哈，我写的时候头也很大。只是为了说明能写出来，而不是真想/需要这么写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602477198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165563,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1577260644,"is_pvip":false,"replies":[{"id":63150,"content":"对，对于模板，就是要在脑子里或纸上、电脑上把它展开……☺️","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577275419,"ip_address":"","comment_id":165563,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"脑壳儿疼的兄弟姐妹们，我这有个小偏方， 哈哈\n\nWhile&lt; Sum&lt;2&gt;::type &gt;::type::value 实例化(instantiation)过程\n--&gt; While&lt; SumLoop&lt;0, 2&gt; &gt;::type::value\n--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;&gt;::type::value\n--&gt; WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type::value\n\n--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type&gt;::type::value\n--&gt; WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type::value\n\n--&gt; WhileLoop&lt;SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type&gt;::type::value\n--&gt; WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type::value\n\n--&gt; WhileLoop&lt;SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type&gt;::type::value\n--&gt; WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type::value\n\n--&gt; SumLoop&lt;3, -1&gt;::res_type::value\n\n--&gt;integral_constant&lt;int, 3&gt;::value\n--&gt;3","like_count":22,"discussions":[{"author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630886,"discussion_content":"加上注释帮助大家理解，整个过程就是不断的先推导模板参数和推导::type 类型，过程中不断的做 substitution\nWhile&lt; Sum&lt;2&gt;::type &gt;::type::value 实例化(instantiation)过程\n\n--&gt; While&lt; Sum&lt;2&gt;::type &gt;::type::value                                           // 推导 Sum&lt;2&gt;::type\n--&gt; While&lt; SumLoop&lt;0, 2&gt; &gt;::type::value                                          // 推导 While&lt; SumLoop&lt;0, 2&gt;::type\n--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;&gt;::type::value             // 推导 SumLoop&lt;0, 2&gt;::cond_value\n--&gt; WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type::value                                  // 推导 WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type\n\n--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type&gt;::type::value  // 推导 SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type\n--&gt; WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type::value                                  // 推导 WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type\n\n--&gt; WhileLoop&lt;SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type&gt;::type::value  // 推导 SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type\n--&gt; WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type::value                                  // 推导 WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type\n\n--&gt; WhileLoop&lt;SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type&gt;::type::value  // 推导 SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type\n--&gt; WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type::value                                // 推导 WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type\n\n--&gt; SumLoop&lt;3, -1&gt;::res_type::value                                              // 推导 SumLoop&lt;3, -1&gt;::res_type, 生成integral_constant&lt;int, 3&gt;\n\n--&gt;integral_constant&lt;int, 3&gt;::value                                              // 获取 静态变量 value\n--&gt;3","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1699003481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479206,"discussion_content":"对，对于模板，就是要在脑子里或纸上、电脑上把它展开……☺️","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577275419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2006194,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/9c/b2/1a9beeb1.jpg","nickname":"转遍世界","note":"","ucode":"0783BFDDE87029","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634718,"discussion_content":"从上面的展开我有两个疑问，一是SumLoop&lt;0, 2&gt;::cond_value初始条件第一次用没进入下次循环体即SumLoop&lt;0, 2&gt;::next_type，第二次用了才进入？二是n==0时条件为false时还计算了next_type，即把0加到了结果，这样很可能导致错误，\n怎么解决？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703835603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":479206,"ip_address":"江苏","group_id":0},"score":634718,"extra":""}]}]},{"had_liked":false,"id":165604,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577267357,"is_pvip":false,"replies":[{"id":63164,"content":"下面的函数和模板是基本等价的：\n\nint foo(int n)\n{\n  if (n == 2 || n == 3 || n == 5) {\n    return 1;\n  } else {\n    return 2;\n  }\n}\n\ntemplate &lt;int n&gt;\nstruct Foo {\n  typedef typename If&lt;\n    (n == 2 || n == 3 || n == 5),\n    integral_constant&lt;int, 1&gt;,\n    integral_constant&lt;int, 2&gt;&gt;::type\n    type;\n};\n\n你可以输出 foo(3)，也可以输出 Foo&lt;3&gt;::type::value。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577283642,"ip_address":"","comment_id":165604,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"记得吴老师之前预告过，这一节可能会比较难，确实被难住了。在第一个 If 模板这里就被卡住了，老师能给个简单的例子来说明这个 If 模板该如何使用么？","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479222,"discussion_content":"下面的函数和模板是基本等价的：\n\nint foo(int n)\n{\n  if (n == 2 || n == 3 || n == 5) {\n    return 1;\n  } else {\n    return 2;\n  }\n}\n\ntemplate &amp;lt;int n&amp;gt;\nstruct Foo {\n  typedef typename If&amp;lt;\n    (n == 2 || n == 3 || n == 5),\n    integral_constant&amp;lt;int, 1&amp;gt;,\n    integral_constant&amp;lt;int, 2&amp;gt;&amp;gt;::type\n    type;\n};\n\n你可以输出 foo(3)，也可以输出 Foo&amp;lt;3&amp;gt;::type::value。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577283642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296048,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1622715836,"is_pvip":false,"replies":[{"id":107512,"content":"谢谢抓虫🙏。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1622869253,"ip_address":"","comment_id":296048,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"比如，如果我们对 const string&amp; 应用 remove_const，就会得到 string&amp;，即，remove_const::type 等价于 string&amp;。\n\nremove_const只能去顶层const。const string&amp;应用remove_const后还是const string&amp;，const string应用remove_const后是string。","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521305,"discussion_content":"谢谢抓虫🙏。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622869253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172312,"user_name":"YouCompleteMe","can_delete":false,"product_type":"c1","uid":1232859,"ip_address":"","ucode":"89B5A75DA85E0A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","comment_is_top":false,"comment_ctime":1579147719,"is_pvip":false,"replies":[{"id":66876,"content":"嗯，是的，你的写法能少展开一次。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579185272,"ip_address":"","comment_id":172312,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"template &lt;typename Body&gt;\nstruct whileLoop&lt;true, Body&gt;\n部分似乎改成下面这样，更直观，\n编译时计算更少呢\n\ntemplate &lt;typename Body&gt;\nstruct whileLoop&lt;true, Body&gt; {\n    typedef typename whileLoop&lt;\n      Body::next_type::cond_value, \n      typename Body::next_type&gt;::type \n      type;\n};","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481695,"discussion_content":"嗯，是的，你的写法能少展开一次。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579185272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328248,"user_name":"莫言","can_delete":false,"product_type":"c1","uid":2174219,"ip_address":"","ucode":"7B4A0D0FF49806","user_header":"https://static001.geekbang.org/account/avatar/00/21/2d/0b/e6836053.jpg","comment_is_top":false,"comment_ctime":1640620214,"is_pvip":false,"replies":[{"id":119580,"content":"模板的参数可以是类型（如 int），可以是值（如长度 8），也可以是其他（类或别名）模板。这个语法代表 OutContainer 是一个带两个类型模板参数的（类或别名）模板。（vector 有两个类型模板参数，第二个有默认值，一般不需要自己提供。）","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1640675172,"ip_address":"","comment_id":328248,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"template &lt;  template &lt;typename, typename&gt;  class OutContainer = vector,  typename F, class R&gt;\n请问老师，这个OutConContainer前面的template&lt;typename,typename&gt;应该怎么理解","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542180,"discussion_content":"模板的参数可以是类型（如 int），可以是值（如长度 8），也可以是其他（类或别名）模板。这个语法代表 OutContainer 是一个带两个类型模板参数的（类或别名）模板。（vector 有两个类型模板参数，第二个有默认值，一般不需要自己提供。）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640675172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382426,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1697293170,"is_pvip":false,"replies":[{"id":139381,"content":"我测试了一下，似乎不行？\n\n我就前面加了 &lt;iostream&gt; 的包含和 using。然后就报错了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1697812894,"ip_address":"广东","comment_id":382426,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"分享一下我的代码：实现求最大公约数的辗转相除法\ntemplate &lt;bool Cond, typename Body&gt;\nstruct WhileLoop;\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;true, Body&gt;\n{\n    typedef typename WhileLoop&lt;Body::Cond, typename Body::NextType&gt;::type type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;false, Body&gt;\n{\n    typedef typename Body::ResType type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct While\n{\n    typedef typename WhileLoop&lt;Body::Cond, Body&gt;::type type;\n};\n\ntemplate &lt;typename T, T val&gt;\nstruct integer\n{\n    typedef T ValueType;\n    static const T Value = val;\n    typedef integer type;\n};\n\ntemplate &lt;int lhs, int rhs&gt;\nstruct GCD\n{\n    static const bool Cond = lhs % rhs != 0;\n    static const int result = lhs;\n    typedef integer&lt;int, result&gt; ResType;\n    typedef GCD&lt;rhs, lhs % rhs&gt; NextType;\n};\n\nint main()\n{\n    cout &lt;&lt; While&lt;GCD&lt;100, 56&gt;&gt;::type::Value &lt;&lt; endl;\n    return 0;\n}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629926,"discussion_content":"我测试了一下，似乎不行？\n\n我就前面加了 &lt;iostream&gt; 的包含和 using。然后就报错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697812894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":3201926,"avatar":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","nickname":"李云龙","note":"","ucode":"785924B16BE788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":630236,"discussion_content":"老师您好，我是在Windows上，IDE是visual studio2022, 加上&lt;iostream&gt; 和 using 是可以正常工作的。我没有在gcc上测试，等下我用gcc试一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698200933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":629926,"ip_address":"北京","group_id":0},"score":630236,"extra":""},{"author":{"id":3201926,"avatar":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","nickname":"李云龙","note":"","ucode":"785924B16BE788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":630255,"discussion_content":"在Linux上用gcc编译确实报错，经过抢修，可通过代码如下，多谢老师提醒：\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;bool Cond, typename Body&gt;\nstruct WhileLoop;\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;true, Body&gt;\n{\n    typedef typename WhileLoop&lt;Body::Cond, typename Body::NextType&gt;::type type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct WhileLoop&lt;false, Body&gt;\n{\n    typedef typename Body::ResType type;\n};\n\ntemplate &lt;typename Body&gt;\nstruct While\n{\n    typedef typename WhileLoop&lt;Body::Cond, Body&gt;::type type;\n};\n\ntemplate &lt;typename T, T val&gt;\nstruct integer\n{\n    typedef T ValueType;\n    static const T Value = val;\n    typedef integer type;\n};\n\ntemplate &lt;int lhs, int rhs&gt;\nstruct GCD\n{\n    static const bool Cond = rhs != 0 &amp;&amp; rhs % (lhs % rhs) != 0;\n    static const int result = rhs;\n    typedef integer&lt;int, result&gt; ResType;\n    typedef GCD&lt;rhs, lhs% rhs&gt; NextType;\n};\n\nint main()\n{\n    cout &lt;&lt; While&lt;GCD&lt;100, 56&gt;&gt;::type::Value &lt;&lt; endl;\n    return 0;\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698219333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":629926,"ip_address":"北京","group_id":0},"score":630255,"extra":""}]}]},{"had_liked":false,"id":290495,"user_name":"Geek_15f2c9","can_delete":false,"product_type":"c1","uid":2557701,"ip_address":"","ucode":"3AA686B1D31AB1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Wjsc175urqxxBcCsxSDG5iaWcEq4hIg4SCCVJCIC108Ul5l7US4iaE3iaaMWodSJeybGemicEnfetHFCj9P6QI17xw/132","comment_is_top":false,"comment_ctime":1619590071,"is_pvip":false,"replies":[{"id":105294,"content":"很好的问题。但是，实际必要性不高。\n\n原因是，f(…) 极少会有合法的、返回右值引用的场景。唯一我能想到的可能性是返回值是根据输入的右值生成的情况。这样的话，得保证在输入是个右值容器时传递元素的右值给 f，所以真要考虑这种情况的话，代码比你写的还要再复杂不少……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1619617088,"ip_address":"","comment_id":290495,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，对万能引用使用完美转发是否好点，result.push_back(std::forward&lt;decltype(f(item))&gt;(f(item)))或result.emplace_back(std::forward&lt;decltype(f(item))&gt;(f(item)));;","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519216,"discussion_content":"很好的问题。但是，实际必要性不高。\n\n原因是，f(…) 极少会有合法的、返回右值引用的场景。唯一我能想到的可能性是返回值是根据输入的右值生成的情况。这样的话，得保证在输入是个右值容器时传递元素的右值给 f，所以真要考虑这种情况的话，代码比你写的还要再复杂不少……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619617088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264808,"user_name":"Gazelle","can_delete":false,"product_type":"c1","uid":2049810,"ip_address":"","ucode":"5839E1510A53FE","user_header":"https://static001.geekbang.org/account/avatar/00/1f/47/12/0186b64e.jpg","comment_is_top":false,"comment_ctime":1606658144,"is_pvip":false,"replies":[{"id":96256,"content":"这里有个小细节：const T&amp; 等同于 T const&amp;，但和 T&amp; const 不同。前者是一个指向常量的引用，后者是一个常引用。只有后者才被看作是一个“常量”。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1606788794,"ip_address":"","comment_id":264808,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我实践写了下remove_const，好像没有把const去掉。这里是不是有点问题呢？\nhttps:&#47;&#47;stackoverflow.com&#47;questions&#47;15887144&#47;stdremove-const-with-const-references\n我看这里说是如果同时有const和引用的话，还需要去掉引用？\nstd::remove_const&lt;std::remove_reference&lt;const string&amp;&gt;::type&gt;::type","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510690,"discussion_content":"这里有个小细节：const T&amp;amp; 等同于 T const&amp;amp;，但和 T&amp;amp; const 不同。前者是一个指向常量的引用，后者是一个常引用。只有后者才被看作是一个“常量”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606788794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252660,"user_name":"鲁·本","can_delete":false,"product_type":"c1","uid":1209939,"ip_address":"","ucode":"F1DEB30C21B48E","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/53/21d62a23.jpg","comment_is_top":false,"comment_ctime":1602426833,"is_pvip":false,"replies":[{"id":92303,"content":"哈哈，我写的时候头也很大。只是为了说明能写出来，而不是真想&#47;需要这么写。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1602477198,"ip_address":"","comment_id":252660,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"对While&lt;Sum&lt;10&gt;::type&gt;::type::value进行手动推导，最终是能推导出实际语句是 integral_constant&lt;int，10+9+...1&gt;::value的，但让我独立写出 完整的代码是万万不能的😄","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506828,"discussion_content":"哈哈，我写的时候头也很大。只是为了说明能写出来，而不是真想/需要这么写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602477198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223332,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":2005742,"ip_address":"","ucode":"CB7AC741E0E4B7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","comment_is_top":false,"comment_ctime":1591064079,"is_pvip":false,"replies":[{"id":82274,"content":"指的就是这句：\n\n_destroy(ptr, is_trivially_destructible&lt;T&gt;())\n\n这儿构造了一个 true_type 或 false_type 的对象，然后编译器会根据第二个参数的类型，决定调用 _destroy 的哪个重载。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591066358,"ip_address":"","comment_id":223332,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"“如果要得到布尔值的话，当然使用 `is_trivially_destructible::value` 就可以，但此处不需要。需要的是，使用 `()` 调用该类型的构造函数，让编译器根据数值类型来选择合适的重载。这样，在优化编译的情况下，编译器可以把不需要的析构操作彻底全部删除。”\n老师，这里没太懂，使用 `()` 调用该类型的构造，这里的调用是在哪里调用，为什么 destroy 要调用构造函数","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497102,"discussion_content":"指的就是这句：\n\n_destroy(ptr, is_trivially_destructible&amp;lt;T&amp;gt;())\n\n这儿构造了一个 true_type 或 false_type 的对象，然后编译器会根据第二个参数的类型，决定调用 _destroy 的哪个重载。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591066358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2005742,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","nickname":"吃鱼","note":"","ucode":"CB7AC741E0E4B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277526,"discussion_content":"老师我看了下C++reference，is_trivially_destructible::value 继承自 integral_constant，而 integral_constant 有对 () 的操作符重载：\n\ntemplate <class T, T v>\nstruct integral_constant {\n  static constexpr T value = v;\n  typedef T value_type;\n  typedef integral_constant<T,v> type;\n  constexpr operator T() const noexcept { return v; }\n  constexpr T operator()() const noexcept { return v; }\n};\n\n那课程中使用 is_trivially_destructible<T>() 是否是使用了这个操作符重载呢？如果是的话其返回应该是一个 bool 类型的值，为什么可以用 true_type 和 false_type 来接收参数呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591065960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2005742,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","nickname":"吃鱼","note":"","ucode":"CB7AC741E0E4B7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278521,"discussion_content":"当然没有使用 operator T()。调用 operator T() 是要在明确要求 T 类型的场合，我们先现在则恰恰相反，只有 true_type 和 false_type 的重载。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591195124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277526,"ip_address":"","group_id":0},"score":278521,"extra":""}]}]},{"had_liked":false,"id":167868,"user_name":"吃一个芒果","can_delete":false,"product_type":"c1","uid":1762540,"ip_address":"","ucode":"313816A05796BD","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e4/ec/88ccd50b.jpg","comment_is_top":false,"comment_ctime":1577954581,"is_pvip":false,"replies":[{"id":65234,"content":"你希望的写法我觉得是写不出来的，而且意义似乎也不大？下面这样写似乎表达能力是一样的，并且可以过：\n\ntemplate &lt;bool Condition, int num1, int num2&gt;\nusing If = typename If_&lt;Condition&gt;::\n  template type&lt;num1, num2&gt;;\n\ntemplate &lt;int num1, int num2&gt;\nusing True = If&lt;true, num1, num2&gt;;\n\ntemplate &lt;int num1, int num2&gt;\nusing False = If&lt;false, num1, num2&gt;;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577975890,"ip_address":"","comment_id":167868,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"template &lt;int num1, int num2&gt;\nstruct Add_\n{\n    const static int res = num1 + num2;\n};\n\ntemplate &lt;int num1, int num2&gt;\nstruct Sub_\n{\n    const static int res = num1 - num2;\n};\n\ntemplate &lt;bool Condition&gt;\nstruct If_;\n\ntemplate &lt;&gt;\nstruct If_ &lt;true&gt;\n{\n    template&lt;int num1, int num2&gt;\n    using type = Add_&lt;num1, num2&gt;;\n};\n\ntemplate &lt;&gt;\nstruct If_ &lt;false&gt;\n{\n    template&lt;int num1, int num2&gt;\n    using type = Sub_&lt;num1, num2&gt;;\n};\n\ntemplate&lt;int num1, int num2&gt;\ntemplate&lt;bool Condition&gt;\nusing If = typename If_&lt;Condition&gt;::template type&lt;num1, num2&gt;;\n\ntemplate&lt;int num1, int num2&gt;\nusing True = If&lt;true&gt;;\n\ntemplate&lt;int num1, int num2&gt;\nusing False = If&lt;false&gt;;\n\n老师你好，我想问一个语法方面可能比较钻牛角尖的问题\n我定义了If_,用来在true和false的时候返回不同的模板。又定义了True和False，这样就可以通过True&lt;a, b&gt;::res或者False&lt;a, b&gt;::res来获取不同模板的计算结果。但是如果我想用类似If&lt;condition&gt;&lt;a, b&gt;::res这样的调用（不知道我表达清楚没有）来获取不同的结果（在不改If_定义的情况下），应该怎么写呢？谢谢！","like_count":1},{"had_liked":false,"id":166499,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577459544,"is_pvip":false,"replies":[{"id":63478,"content":"1. 因为模板的定义就是这个样子，虽然我们平时第二个参数用的都是默认模板参数。\n\n2. 不是右值引用，是转发引用。复习一下第 3 讲结尾部分吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577508280,"ip_address":"","comment_id":166499,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，关于最后这个例子，有两个小问题：\n1，我们平时定义一个 vector 的时候，一般并不会写成 vector&lt;int, allocator&lt;int&gt;&gt; vec 这种形式，为什么模板函数里面定义返回值 result 时，需要多一个 allocator？\n2，fmap函数的入参和for循环，全都用的右值引用，有什么特殊考量么？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479518,"discussion_content":"1. 因为模板的定义就是这个样子，虽然我们平时第二个参数用的都是默认模板参数。\n\n2. 不是右值引用，是转发引用。复习一下第 3 讲结尾部分吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577508280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344032,"user_name":"陈狄","can_delete":false,"product_type":"c1","uid":2011954,"ip_address":"","ucode":"456F00EB2EB43D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b3/32/0ee78a1a.jpg","comment_is_top":false,"comment_ctime":1651202312,"is_pvip":false,"replies":[{"id":125681,"content":"我自己写完都不想看这代码了……只是想练习一下确实可以写出循环。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651411887,"ip_address":"","comment_id":344032,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"编译期编程确实6，模版写循环确实绕，展开如下：\nWhile&lt;Sum&lt;10&gt;::type&gt;::type::value\nWhile&lt;SumLoop&lt;0, 10&gt;&gt;::type::value\nWhileLoop&lt;SumLoop&lt;0, 10&gt;::cond_value, SumLoop&lt;0, 10&gt;&gt;::type::value\nWhileLoop&lt;true, SumLoop&lt;0, 10&gt;&gt;::type::value\nWhileLoop&lt;SumLoop&lt;0, 10&gt;::cond_value, SumLoop&lt;0, 10&gt;::next_type&gt;::type::value\nWhileLoop&lt;true, SumLoop&lt;10, 9&gt;&gt;::type::value\nWhileLoop&lt;SumLoop&lt;10, 9&gt;&gt;::cond_value,SumLoop&lt;10, 9&gt;&gt;::next_type&gt;::type::value\n...\nWhileLoop&lt;SumLoop&lt;55, 0&gt;&gt;::cond_value,SumLoop&lt;55, 0&gt;&gt;::next_type&gt;::type::value\nWhileLoop&lt;false,SumLoop&lt;55, -1&gt;&gt;::type::value\nSumLoop&lt;55, -1&gt;::res_type::value\nintegral_constant&lt;int, 55&gt;::value","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569348,"discussion_content":"我自己写完都不想看这代码了……只是想练习一下确实可以写出循环。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651411887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278996,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1613531578,"is_pvip":false,"replies":[{"id":101425,"content":"我给出的定义只是给大家直观地看一下。生产代码应该使用标准库。\n\n不过，生产代码一般也不建议使用 using namespace std; 哦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1613630265,"ip_address":"","comment_id":278996,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"While&lt;Sum&lt;10&gt;::type&gt;::type::value的例子中会使用到了自己integral_constant模板，但是stl中也有一份integral_constant，所以运行本示例代码时如果一开始直接 using namespace std会编译报错","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515590,"discussion_content":"我给出的定义只是给大家直观地看一下。生产代码应该使用标准库。\n\n不过，生产代码一般也不建议使用 using namespace std; 哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613630265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240122,"user_name":"talor","can_delete":false,"product_type":"c1","uid":1350638,"ip_address":"","ucode":"245EE908DA39EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/ee/211e86cd.jpg","comment_is_top":false,"comment_ctime":1596766711,"is_pvip":false,"replies":[{"id":88666,"content":"是有点烧。搞明白了就是个新世界。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596785135,"ip_address":"","comment_id":240122,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"脑子烧坏了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503349,"discussion_content":"是有点烧。搞明白了就是个新世界。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596785135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239390,"user_name":"Geek_68d3d2","can_delete":false,"product_type":"c1","uid":1674369,"ip_address":"","ucode":"EBD6D881AA7A74","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqf54z1ZmqQY1kmJ6t1HAnrqMM3j6WKf0oDeVLhtnA2ZUKY6AX9MK6RjvcO8SiczXy3uU0IzBQ3tpw/132","comment_is_top":false,"comment_ctime":1596521308,"is_pvip":false,"replies":[{"id":88457,"content":"还是类型。但在模板元编程里，玩的就是利用类型推导来做计算。所以类型是当成变量来用的。\n\n哈哈，有点绕，慢慢看。😄","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596540192,"ip_address":"","comment_id":239390,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"typedef SumLoop&lt;0, n&gt; type;这个语法不是给类型定义别名吗 怎么代码里变成了变量定义???","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503091,"discussion_content":"还是类型。但在模板元编程里，玩的就是利用类型推导来做计算。所以类型是当成变量来用的。\n\n哈哈，有点绕，慢慢看。😄","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596540192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441214,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fd/be/232ffedf.jpg","nickname":"大李","note":"","ucode":"45538A3E6DF9A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316635,"discussion_content":"“利用类型推导做计算”，老师的这句话很关键。目前的理解就通过 typedef 定义了一堆类型，然后每个类型都需要推导，而推导的过程就是会展开计算，通过偏特化带入了各种变量进去。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603433369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232795,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594119228,"is_pvip":false,"replies":[{"id":85988,"content":"对我来讲，res_type 和 res_value 是同一个值的两种不同表现方式。目前这种写法，于我更为自然些。你的写法也没有问题。\n\n浮点数由于精度问题，目前在 C++ 里不允许用作模板参数。可以参考这个讨论 https:&#47;&#47;stackoverflow.com&#47;questions&#47;2183087&#47;why-cant-i-use-float-value-as-a-template-parameter","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594213838,"ip_address":"","comment_id":232795,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"这一课看的脑浆都沸腾了……\n吴老师，您好。有如下几个问题请教一下：\n在SumLoop中定义的res_value的目的是什么？为什么不直接使用\ntypedef integral_constant&lt;int, result&gt; res_type 而是\ntypedef integral_constant&lt;int, res_value&gt; res_type呢？前者编译执行都没有问题的。\n在integral_constant定义typedef integral_constant type目的是什么？\n另外我尝试稍微改动了一下文中例子如下：\ntemplate &lt;class T, T v&gt;\nstruct type_constant {\n  static const T value = v;\n  typedef T value_type;\n  typedef type_constant type;\n};\n\ntemplate &lt;typename T, T result, T n&gt;\nstruct SumLoop {\n  static const bool cond_value = (n &gt; (T)0);\n  &#47;&#47; static const int res_value = result;\n  typedef type_constant&lt;T, result&gt; res_type;\n  typedef SumLoop&lt;T, result + n, n - (T)1&gt; next_type;\n};\n\ntemplate &lt;typename T, T n&gt;\nstruct Sum {\n  typedef SumLoop&lt;T, (T)0, n&gt; type;\n};\n结果发现只能够支持范整型类型如int,size_t,ulong等等：\nWhile&lt;Sum&lt;size_t, 10&gt;::type&gt;::type::value编译执行工作正常；但对于浮点型如：\nWhile&lt;Sum&lt;float, 10.0)&gt;::type&gt;::type::value编译报错：\nerror: ‘float’ is not a valid type for a template non-type parameter\n请问这是什么原因？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500769,"discussion_content":"对我来讲，res_type 和 res_value 是同一个值的两种不同表现方式。目前这种写法，于我更为自然些。你的写法也没有问题。\n\n浮点数由于精度问题，目前在 C++ 里不允许用作模板参数。可以参考这个讨论 https://stackoverflow.com/questions/2183087/why-cant-i-use-float-value-as-a-template-parameter","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594213838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200665,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1585632499,"is_pvip":false,"replies":[{"id":75162,"content":"1. 确实是为了灵活，但这个设计不能算很成功，因为真的用的人非常少。但从理论上来讲，你用 allocator 可以实现非常特别的内存管理策略，如预分配之类。\n\n2. 迭代器实际上是比容器更抽象的概念，第 7 讲介绍的 istream_line_reader 就不能说是个容器。第 29 讲有比容器更抽象的“范围”。type_traits 翻译成中文是“类型特点”，是各种对共性的描述，是一组非常散的概念，跟迭代器、容器之类相提并论我觉得不妥。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585663530,"ip_address":"","comment_id":200665,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"最近在看STl源码分析。\n1.一直再想allocator类为什么要存在？\n   为不同的容器类型提供了内存资源管理类，同时也支持用户自定义，更方便和灵活。实际上对于容器而言内部的资源都是分布在对上的，栈上的只不过是个符号。\n2.为什么要有type_traits？\n   iterator是对容器类的一种底层抽象.type_traits实际上也是这样的抽象，只不过更抽象。\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490094,"discussion_content":"1. 确实是为了灵活，但这个设计不能算很成功，因为真的用的人非常少。但从理论上来讲，你用 allocator 可以实现非常特别的内存管理策略，如预分配之类。\n\n2. 迭代器实际上是比容器更抽象的概念，第 7 讲介绍的 istream_line_reader 就不能说是个容器。第 29 讲有比容器更抽象的“范围”。type_traits 翻译成中文是“类型特点”，是各种对共性的描述，是一组非常散的概念，跟迭代器、容器之类相提并论我觉得不妥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585663530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175425,"user_name":"oozero","can_delete":false,"product_type":"c1","uid":1265651,"ip_address":"","ucode":"9D14BCB54E8529","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/f3/05f5c779.jpg","comment_is_top":false,"comment_ctime":1580716204,"is_pvip":false,"replies":[{"id":68183,"content":"那要花时间整理了……后半部分的代码我比较全点，前半部分一开始没有保留所有的测试代码……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580727955,"ip_address":"","comment_id":175425,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师可以将文中示例代码片段整理成文件，分享到GitHub，让c++基础不扎实的同学可以更直观的学习吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482727,"discussion_content":"那要花时间整理了……后半部分的代码我比较全点，前半部分一开始没有保留所有的测试代码……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580727955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168968,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1578227965,"is_pvip":false,"replies":[{"id":65548,"content":"没区别。\n\n要点是你不需要使用这些模板，也同样能达到编译期编程的效果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578272578,"ip_address":"","comment_id":168968,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"在文中提到这么一句话：“实际上，到现在为止，我们讲的东西还没有离开 C++98。而我们下面几讲里很快就会讲到，如何在现代 C++ 里不使用这种麻烦的方式也能达到同样的效果。”\n想问一下如果用现代C++实现上述的IF或者WhileLoop，究竟跟上述的有什么区别。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480389,"discussion_content":"没区别。\n\n要点是你不需要使用这些模板，也同样能达到编译期编程的效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578272578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167868,"user_name":"吃一个芒果","can_delete":false,"product_type":"c1","uid":1762540,"ip_address":"","ucode":"313816A05796BD","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e4/ec/88ccd50b.jpg","comment_is_top":false,"comment_ctime":1577954581,"is_pvip":false,"replies":[{"id":65234,"content":"你希望的写法我觉得是写不出来的，而且意义似乎也不大？下面这样写似乎表达能力是一样的，并且可以过：\n\ntemplate &lt;bool Condition, int num1, int num2&gt;\nusing If = typename If_&lt;Condition&gt;::\n  template type&lt;num1, num2&gt;;\n\ntemplate &lt;int num1, int num2&gt;\nusing True = If&lt;true, num1, num2&gt;;\n\ntemplate &lt;int num1, int num2&gt;\nusing False = If&lt;false, num1, num2&gt;;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577975890,"ip_address":"","comment_id":167868,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"template &lt;int num1, int num2&gt;\nstruct Add_\n{\n    const static int res = num1 + num2;\n};\n\ntemplate &lt;int num1, int num2&gt;\nstruct Sub_\n{\n    const static int res = num1 - num2;\n};\n\ntemplate &lt;bool Condition&gt;\nstruct If_;\n\ntemplate &lt;&gt;\nstruct If_ &lt;true&gt;\n{\n    template&lt;int num1, int num2&gt;\n    using type = Add_&lt;num1, num2&gt;;\n};\n\ntemplate &lt;&gt;\nstruct If_ &lt;false&gt;\n{\n    template&lt;int num1, int num2&gt;\n    using type = Sub_&lt;num1, num2&gt;;\n};\n\ntemplate&lt;int num1, int num2&gt;\ntemplate&lt;bool Condition&gt;\nusing If = typename If_&lt;Condition&gt;::template type&lt;num1, num2&gt;;\n\ntemplate&lt;int num1, int num2&gt;\nusing True = If&lt;true&gt;;\n\ntemplate&lt;int num1, int num2&gt;\nusing False = If&lt;false&gt;;\n\n老师你好，我想问一个语法方面可能比较钻牛角尖的问题\n我定义了If_,用来在true和false的时候返回不同的模板。又定义了True和False，这样就可以通过True&lt;a, b&gt;::res或者False&lt;a, b&gt;::res来获取不同模板的计算结果。但是如果我想用类似If&lt;condition&gt;&lt;a, b&gt;::res这样的调用（不知道我表达清楚没有）来获取不同的结果（在不改If_定义的情况下），应该怎么写呢？谢谢！","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480032,"discussion_content":"你希望的写法我觉得是写不出来的，而且意义似乎也不大？下面这样写似乎表达能力是一样的，并且可以过：\n\ntemplate &amp;lt;bool Condition, int num1, int num2&amp;gt;\nusing If = typename If_&amp;lt;Condition&amp;gt;::\n  template type&amp;lt;num1, num2&amp;gt;;\n\ntemplate &amp;lt;int num1, int num2&amp;gt;\nusing True = If&amp;lt;true, num1, num2&amp;gt;;\n\ntemplate &amp;lt;int num1, int num2&amp;gt;\nusing False = If&amp;lt;false, num1, num2&amp;gt;;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577975890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166499,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577459544,"is_pvip":false,"replies":[{"id":63478,"content":"1. 因为模板的定义就是这个样子，虽然我们平时第二个参数用的都是默认模板参数。\n\n2. 不是右值引用，是转发引用。复习一下第 3 讲结尾部分吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577508280,"ip_address":"","comment_id":166499,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，关于最后这个例子，有两个小问题：\n1，我们平时定义一个 vector 的时候，一般并不会写成 vector&lt;int, allocator&lt;int&gt;&gt; vec 这种形式，为什么模板函数里面定义返回值 result 时，需要多一个 allocator？\n2，fmap函数的入参和for循环，全都用的右值引用，有什么特殊考量么？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480032,"discussion_content":"你希望的写法我觉得是写不出来的，而且意义似乎也不大？下面这样写似乎表达能力是一样的，并且可以过：\n\ntemplate &amp;lt;bool Condition, int num1, int num2&amp;gt;\nusing If = typename If_&amp;lt;Condition&amp;gt;::\n  template type&amp;lt;num1, num2&amp;gt;;\n\ntemplate &amp;lt;int num1, int num2&amp;gt;\nusing True = If&amp;lt;true, num1, num2&amp;gt;;\n\ntemplate &amp;lt;int num1, int num2&amp;gt;\nusing False = If&amp;lt;false, num1, num2&amp;gt;;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577975890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344032,"user_name":"陈狄","can_delete":false,"product_type":"c1","uid":2011954,"ip_address":"","ucode":"456F00EB2EB43D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b3/32/0ee78a1a.jpg","comment_is_top":false,"comment_ctime":1651202312,"is_pvip":false,"replies":[{"id":125681,"content":"我自己写完都不想看这代码了……只是想练习一下确实可以写出循环。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651411887,"ip_address":"","comment_id":344032,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"编译期编程确实6，模版写循环确实绕，展开如下：\nWhile&lt;Sum&lt;10&gt;::type&gt;::type::value\nWhile&lt;SumLoop&lt;0, 10&gt;&gt;::type::value\nWhileLoop&lt;SumLoop&lt;0, 10&gt;::cond_value, SumLoop&lt;0, 10&gt;&gt;::type::value\nWhileLoop&lt;true, SumLoop&lt;0, 10&gt;&gt;::type::value\nWhileLoop&lt;SumLoop&lt;0, 10&gt;::cond_value, SumLoop&lt;0, 10&gt;::next_type&gt;::type::value\nWhileLoop&lt;true, SumLoop&lt;10, 9&gt;&gt;::type::value\nWhileLoop&lt;SumLoop&lt;10, 9&gt;&gt;::cond_value,SumLoop&lt;10, 9&gt;&gt;::next_type&gt;::type::value\n...\nWhileLoop&lt;SumLoop&lt;55, 0&gt;&gt;::cond_value,SumLoop&lt;55, 0&gt;&gt;::next_type&gt;::type::value\nWhileLoop&lt;false,SumLoop&lt;55, -1&gt;&gt;::type::value\nSumLoop&lt;55, -1&gt;::res_type::value\nintegral_constant&lt;int, 55&gt;::value","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479518,"discussion_content":"1. 因为模板的定义就是这个样子，虽然我们平时第二个参数用的都是默认模板参数。\n\n2. 不是右值引用，是转发引用。复习一下第 3 讲结尾部分吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577508280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278996,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1613531578,"is_pvip":false,"replies":[{"id":101425,"content":"我给出的定义只是给大家直观地看一下。生产代码应该使用标准库。\n\n不过，生产代码一般也不建议使用 using namespace std; 哦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1613630265,"ip_address":"","comment_id":278996,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"While&lt;Sum&lt;10&gt;::type&gt;::type::value的例子中会使用到了自己integral_constant模板，但是stl中也有一份integral_constant，所以运行本示例代码时如果一开始直接 using namespace std会编译报错","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569348,"discussion_content":"我自己写完都不想看这代码了……只是想练习一下确实可以写出循环。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651411887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240122,"user_name":"talor","can_delete":false,"product_type":"c1","uid":1350638,"ip_address":"","ucode":"245EE908DA39EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/ee/211e86cd.jpg","comment_is_top":false,"comment_ctime":1596766711,"is_pvip":false,"replies":[{"id":88666,"content":"是有点烧。搞明白了就是个新世界。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596785135,"ip_address":"","comment_id":240122,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"脑子烧坏了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515590,"discussion_content":"我给出的定义只是给大家直观地看一下。生产代码应该使用标准库。\n\n不过，生产代码一般也不建议使用 using namespace std; 哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613630265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239390,"user_name":"Geek_68d3d2","can_delete":false,"product_type":"c1","uid":1674369,"ip_address":"","ucode":"EBD6D881AA7A74","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqf54z1ZmqQY1kmJ6t1HAnrqMM3j6WKf0oDeVLhtnA2ZUKY6AX9MK6RjvcO8SiczXy3uU0IzBQ3tpw/132","comment_is_top":false,"comment_ctime":1596521308,"is_pvip":false,"replies":[{"id":88457,"content":"还是类型。但在模板元编程里，玩的就是利用类型推导来做计算。所以类型是当成变量来用的。\n\n哈哈，有点绕，慢慢看。😄","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596540192,"ip_address":"","comment_id":239390,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"typedef SumLoop&lt;0, n&gt; type;这个语法不是给类型定义别名吗 怎么代码里变成了变量定义???","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503349,"discussion_content":"是有点烧。搞明白了就是个新世界。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596785135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232795,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594119228,"is_pvip":false,"replies":[{"id":85988,"content":"对我来讲，res_type 和 res_value 是同一个值的两种不同表现方式。目前这种写法，于我更为自然些。你的写法也没有问题。\n\n浮点数由于精度问题，目前在 C++ 里不允许用作模板参数。可以参考这个讨论 https:&#47;&#47;stackoverflow.com&#47;questions&#47;2183087&#47;why-cant-i-use-float-value-as-a-template-parameter","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594213838,"ip_address":"","comment_id":232795,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"这一课看的脑浆都沸腾了……\n吴老师，您好。有如下几个问题请教一下：\n在SumLoop中定义的res_value的目的是什么？为什么不直接使用\ntypedef integral_constant&lt;int, result&gt; res_type 而是\ntypedef integral_constant&lt;int, res_value&gt; res_type呢？前者编译执行都没有问题的。\n在integral_constant定义typedef integral_constant type目的是什么？\n另外我尝试稍微改动了一下文中例子如下：\ntemplate &lt;class T, T v&gt;\nstruct type_constant {\n  static const T value = v;\n  typedef T value_type;\n  typedef type_constant type;\n};\n\ntemplate &lt;typename T, T result, T n&gt;\nstruct SumLoop {\n  static const bool cond_value = (n &gt; (T)0);\n  &#47;&#47; static const int res_value = result;\n  typedef type_constant&lt;T, result&gt; res_type;\n  typedef SumLoop&lt;T, result + n, n - (T)1&gt; next_type;\n};\n\ntemplate &lt;typename T, T n&gt;\nstruct Sum {\n  typedef SumLoop&lt;T, (T)0, n&gt; type;\n};\n结果发现只能够支持范整型类型如int,size_t,ulong等等：\nWhile&lt;Sum&lt;size_t, 10&gt;::type&gt;::type::value编译执行工作正常；但对于浮点型如：\nWhile&lt;Sum&lt;float, 10.0)&gt;::type&gt;::type::value编译报错：\nerror: ‘float’ is not a valid type for a template non-type parameter\n请问这是什么原因？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503091,"discussion_content":"还是类型。但在模板元编程里，玩的就是利用类型推导来做计算。所以类型是当成变量来用的。\n\n哈哈，有点绕，慢慢看。😄","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596540192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441214,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fd/be/232ffedf.jpg","nickname":"大李","note":"","ucode":"45538A3E6DF9A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316635,"discussion_content":"“利用类型推导做计算”，老师的这句话很关键。目前的理解就通过 typedef 定义了一堆类型，然后每个类型都需要推导，而推导的过程就是会展开计算，通过偏特化带入了各种变量进去。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603433369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200665,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1585632499,"is_pvip":false,"replies":[{"id":75162,"content":"1. 确实是为了灵活，但这个设计不能算很成功，因为真的用的人非常少。但从理论上来讲，你用 allocator 可以实现非常特别的内存管理策略，如预分配之类。\n\n2. 迭代器实际上是比容器更抽象的概念，第 7 讲介绍的 istream_line_reader 就不能说是个容器。第 29 讲有比容器更抽象的“范围”。type_traits 翻译成中文是“类型特点”，是各种对共性的描述，是一组非常散的概念，跟迭代器、容器之类相提并论我觉得不妥。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585663530,"ip_address":"","comment_id":200665,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"最近在看STl源码分析。\n1.一直再想allocator类为什么要存在？\n   为不同的容器类型提供了内存资源管理类，同时也支持用户自定义，更方便和灵活。实际上对于容器而言内部的资源都是分布在对上的，栈上的只不过是个符号。\n2.为什么要有type_traits？\n   iterator是对容器类的一种底层抽象.type_traits实际上也是这样的抽象，只不过更抽象。\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500769,"discussion_content":"对我来讲，res_type 和 res_value 是同一个值的两种不同表现方式。目前这种写法，于我更为自然些。你的写法也没有问题。\n\n浮点数由于精度问题，目前在 C++ 里不允许用作模板参数。可以参考这个讨论 https://stackoverflow.com/questions/2183087/why-cant-i-use-float-value-as-a-template-parameter","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594213838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175425,"user_name":"oozero","can_delete":false,"product_type":"c1","uid":1265651,"ip_address":"","ucode":"9D14BCB54E8529","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/f3/05f5c779.jpg","comment_is_top":false,"comment_ctime":1580716204,"is_pvip":false,"replies":[{"id":68183,"content":"那要花时间整理了……后半部分的代码我比较全点，前半部分一开始没有保留所有的测试代码……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580727955,"ip_address":"","comment_id":175425,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师可以将文中示例代码片段整理成文件，分享到GitHub，让c++基础不扎实的同学可以更直观的学习吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490094,"discussion_content":"1. 确实是为了灵活，但这个设计不能算很成功，因为真的用的人非常少。但从理论上来讲，你用 allocator 可以实现非常特别的内存管理策略，如预分配之类。\n\n2. 迭代器实际上是比容器更抽象的概念，第 7 讲介绍的 istream_line_reader 就不能说是个容器。第 29 讲有比容器更抽象的“范围”。type_traits 翻译成中文是“类型特点”，是各种对共性的描述，是一组非常散的概念，跟迭代器、容器之类相提并论我觉得不妥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585663530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168968,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1578227965,"is_pvip":false,"replies":[{"id":65548,"content":"没区别。\n\n要点是你不需要使用这些模板，也同样能达到编译期编程的效果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578272578,"ip_address":"","comment_id":168968,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"在文中提到这么一句话：“实际上，到现在为止，我们讲的东西还没有离开 C++98。而我们下面几讲里很快就会讲到，如何在现代 C++ 里不使用这种麻烦的方式也能达到同样的效果。”\n想问一下如果用现代C++实现上述的IF或者WhileLoop，究竟跟上述的有什么区别。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482727,"discussion_content":"那要花时间整理了……后半部分的代码我比较全点，前半部分一开始没有保留所有的测试代码……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580727955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167092,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1577690056,"is_pvip":false,"replies":[{"id":64982,"content":"很好！第 18 讲你会学得很轻松。😉","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577791705,"ip_address":"","comment_id":167092,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"这个课后思考题真不是盖得。。。还看到了5分钟编译期堆排序的段子。。。看得我心惊胆战。。。\n不过还是一堆百度写出了一个，针对int型，写出从[0, N)的编译期生成数组的例子。。。兼容其他类型还要再额外写好多代码。。偷懒直接写了int型。。。\n我在msvc下测试了，应该没问题。。。用到了模板不定参数，其他不知道什么技巧的方法。。。\n想要让int N转换成从0，1，2，3，4，5 。。。卡在了如何把这堆参数展开。。写得可能复杂一些。。不知道怎么更简单。。 下面代码吧：\n\ntemplate&lt;int... values&gt;\nstruct IntegerSequence {};\n\ntemplate&lt;typename T, T v, typename INTEGER_SEQUENCE&gt;\nstruct PushBack;\n\ntemplate&lt;int v, int... values&gt;\nstruct PushBack&lt;int, v, IntegerSequence&lt;values...&gt;&gt; {\n\tusing type = IntegerSequence&lt;values..., v&gt;;\n};\n\ntemplate&lt;int N&gt;\nstruct IntegerRange {\n\tusing type = typename PushBack&lt;int, N-1, typename IntegerRange&lt;N-1&gt;::type&gt;::type;\n};\n\ntemplate&lt;&gt;\nstruct IntegerRange&lt;1&gt; {\n\tusing type = IntegerSequence&lt;0&gt;;\n};\n\ntemplate&lt;int N, typename INTEGER_SEQUENCE&gt;\nstruct RangeArray;\n\ntemplate&lt;int N, int... values&gt;\nstruct RangeArray&lt;N, IntegerSequence&lt;values...&gt;&gt; {\n\tstatic constexpr std::array&lt;int, N&gt; value = {values...};\n};\n\ntemplate&lt;int N&gt; using Range = RangeArray&lt;N, typename IntegerRange&lt;N&gt;::type&gt;;\n\n测试：\nauto A = Range&lt;5&gt;::value; \n不出意外，会生成std::array&lt;int, 5&gt;{0,1,2,3,4};","like_count":0},{"had_liked":false,"id":166234,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577420565,"is_pvip":false,"replies":[{"id":63346,"content":"我真是自作自受，得看这样的代码。😜\n\n1. 我给的这些模板只是说明能力的，肯定不是让你真的这么写代码的。比如你这种累加，可以考虑这样写（只考虑了正向）：\n\ntemplate &lt;int from, int to, int sum, bool ending&gt;\nstruct sum_two_op;\n\ntemplate &lt;int from, int to, int sum&gt;\nstruct sum_two_op&lt;from, to, sum, false&gt; {\n    static const int value = sum;\n};\n\ntemplate &lt;int from, int to, int sum&gt;\nstruct sum_two_op&lt;from, to, sum, true&gt; {\n    static const int value =\n        sum_two_op&lt;from + 1, to, sum + from, (from &lt; to)&gt;::value;\n};\n\ntemplate &lt;int from, int to&gt;\nstruct sum_two {\n    static const int value = sum_two_op&lt;from, to, 0, (from &lt;= to)&gt;::value;\n};\n\n2. 你已经很靠近了，只犯了一个小错误，SumTwo 里的方向。应该是：\n\ntemplate &lt;int from, int to&gt;\nstruct SumTwo {\n    typedef SumAnyTwo&lt;(from &lt; to), from, to&gt; type;\n};\n\n另外，你目前的处理对于 from==to 的情况有点问题。可参考我上面的写法，那是可以正确处理的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577424052,"ip_address":"","comment_id":166234,"utype":1}],"discussion_count":5,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"吴老师，看了你的While模板，试着想把这个计算累加的功能扩展一下，输入任意两个数，可以求他们之间的数的累加和，代码如下：\ntemplate &lt;int from, int to, int sum&gt;\nstruct SumAnyTwo_A\n{\n    static const bool cond_value = from != to;\n    static const int res_value = sum;\n    typedef integral_constant&lt;int, res_value&gt; res_type;\n    typedef SumAnyTwo_A&lt;from + 1, to, sum + from&gt; next_type;\n};\n\ntemplate &lt;int from, int to, int sum&gt;\nstruct SumAnyTwo_B\n{\n    static const bool cond_value = from != to;\n    static const int res_value = sum;\n    typedef integral_constant&lt;int, res_value&gt; res_type;\n    typedef SumAnyTwo_B&lt;from - 1, to, sum + from&gt; next_type;\n};\n\ntemplate &lt;bool valueCompare, int from, int to&gt;\nstruct SumAnyTwo;\n\ntemplate &lt;int from, int to&gt;\nstruct SumAnyTwo&lt;true, from, to&gt;\n{\n    typedef SumAnyTwo_A&lt;from, to, 0&gt; addType;\n};\n\ntemplate &lt;int from, int to&gt;\nstruct SumAnyTwo&lt;false, from, to&gt;\n{\n    typedef SumAnyTwo_B&lt;from, to, 0&gt; addType;\n};\n\ntemplate &lt;int from, int to&gt;\nstruct SumTwo\n{\n    typedef SumAnyTwo&lt;(from &gt; to), from, to&gt; type;\n};\n\n遇到了两个问题：\n1，这段代码看起来不够优雅，在C++ 98 的范畴内，有更好的模板元编程实现方式么？\n2，当我试图调用这个While模板时，出现如下状况，不明白为什么第一个会报错\n        While&lt;SumTwo&lt;8, 3&gt;::type::addType&gt;::type::value &#47;&#47; 报错，template  instantiation depth exceeds maximum of 900\n        While&lt;SumAnyTwo_B&lt;8, 3, 0&gt;&gt;::type::value &#47;&#47; OK\n       While&lt;SumAnyTwo&lt;(8 - 3 &lt; 0), 8, 3&gt;::addType&gt;::type::value &#47;&#47;OK\n\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479741,"discussion_content":"很好！第 18 讲你会学得很轻松。😉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577791705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166015,"user_name":"zhang","can_delete":false,"product_type":"c1","uid":1256330,"ip_address":"","ucode":"BFA19BED5A5322","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIRm3kWsgiaEXjO0rr0Aiav7o89StFTFSXbLTkEmiaibmnw8EQTejibrtzKla0emibePT0R0KXjFRIpfXrQ/132","comment_is_top":false,"comment_ctime":1577362337,"is_pvip":false,"replies":[{"id":63327,"content":"对你的业务场景不熟悉，随便评论几句。\n\n・C++11 里有现成的 mutex、condition_variable 和 unique_lock。\n・Client::Lock 和 Client::Unlock 似乎没有用处。\n・变量 pending 的命名让人困惑：收到数据了，“挂起”标志被设为真，然后发送数据就能继续往下执行了？连续两次 sendData 中间必须有一次 recvData 才行，而且 sendData 里的等待是在发送之后？这块感觉有问题。\n・inter_mutex 和 inter_protect 本身目前没有看出问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577411094,"ip_address":"","comment_id":166015,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"您好，我想问一个mutex相关的问题，虽然这部分内容以后会讲，但我现在工作中有一个疑问，麻烦您看一下，谢谢。\n代码简写如下：\nclass Mutex {\npublic:\n    pthread_mutex_t mutex;\n    Mutex():mutex(PTHREAD_MUTEX_INITIALIZER) {}\n    void lock() {\n        pthread_mutex_lock(&amp;mutex);\n    }\n    void unlock() {\n        pthread_mutex_unlock(&amp;mutex);\n    }\n};\nclass Cond {\npublic:\n    pthread_cond_t cond;\n    Cond():cond(PTHREAD_COND_INITIALIZER) {}\n    void signal() {\n        pthread_cond_signal(&amp;cond);\n    }\n    void broadcast() {\n        pthread_cond_broadcast(&amp;cond);\n    }\n    void wait(Mutex &amp;mutex) {\n        pthread_cond_wait(&amp;cond, &amp;mutex.mutex);\n    }\n};\nclass ScopeLock {\n    Mutex &amp;mutex;\npublic:\n    ScopeLock(CanMutex &amp;_mutex):mutex(_mutex) {\n        mutex.lock();\n    };\n    ~ScopeLock() {\n        mutex.unlock();\n    };\n};\n\nclass Client\n{\npublic:\n    Mutex inter_mutex;\n    Mutex mutex;\n    Cond cond;\n    bool pending;\n    Client():pending(false){}\n    ~Client(){}\n    void Lock() {\n        mutex.lock();\n    }\n    void Unlock() {\n        mutex.unlock();\n    }\n    void sendData() {\n        const ScopeLock inter_protect(inter_mutex);\n        const ScopeLock protect(mutex);\n\n        &#47;&#47;send_to_server();\n\n        while (!pending) {\n            cond.wait(mutex);\n        }\n        pending = false;\n    }\n    void recvData() {\n        const ScopeLock protect(mutex);\n        pending = true;\n        cond.signal();\n    }\n};\n我有几个线程会执行同一个Client对象的sendData函数，有一个线程执行Client对象的recvData函数。我主要想问我几个sendData线程需要同步执行，执行完一个sendData发送后，再执行另一个sendData。那么我在sendData函数最开始加整个函数范围的锁const ScopeLock inter_protect(inter_mutex);，是否可以这样做？谢谢！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479351,"discussion_content":"对你的业务场景不熟悉，随便评论几句。\n\n・C++11 里有现成的 mutex、condition_variable 和 unique_lock。\n・Client::Lock 和 Client::Unlock 似乎没有用处。\n・变量 pending 的命名让人困惑：收到数据了，“挂起”标志被设为真，然后发送数据就能继续往下执行了？连续两次 sendData 中间必须有一次 recvData 才行，而且 sendData 里的等待是在发送之后？这块感觉有问题。\n・inter_mutex 和 inter_protect 本身目前没有看出问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577411094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256330,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIRm3kWsgiaEXjO0rr0Aiav7o89StFTFSXbLTkEmiaibmnw8EQTejibrtzKla0emibePT0R0KXjFRIpfXrQ/132","nickname":"zhang","note":"","ucode":"BFA19BED5A5322","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104807,"discussion_content":"谢谢回复。我的业务场景就是发送线程执行sendData之后，必须等待接收线程recvData之后才会执行完sendData。我的问题就是有多个发送线程要执行sendData，所以还需要再加一个inter_mutex锁，来保证多个发送线程是顺序执行的。不知道在sendData函数第一行就const ScopeLock inter_protect(inter_mutex);来保证多个线程顺序执行，是否正确？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577451704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1256330,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIRm3kWsgiaEXjO0rr0Aiav7o89StFTFSXbLTkEmiaibmnw8EQTejibrtzKla0emibePT0R0KXjFRIpfXrQ/132","nickname":"zhang","note":"","ucode":"BFA19BED5A5322","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106050,"discussion_content":"按这么说，目前没发现有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577508672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104807,"ip_address":"","group_id":0},"score":106050,"extra":""}]}]},{"had_liked":false,"id":165651,"user_name":"安静的雨","can_delete":false,"product_type":"c1","uid":1004841,"ip_address":"","ucode":"6371DE858C4D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/29/4fa6e9fb.jpg","comment_is_top":false,"comment_ctime":1577278553,"is_pvip":false,"replies":[{"id":63240,"content":"觉得有趣就好，这个我们要讲上好几讲的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577336029,"ip_address":"","comment_id":165651,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"模版编程很有趣，期待老师的更新。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479351,"discussion_content":"对你的业务场景不熟悉，随便评论几句。\n\n・C++11 里有现成的 mutex、condition_variable 和 unique_lock。\n・Client::Lock 和 Client::Unlock 似乎没有用处。\n・变量 pending 的命名让人困惑：收到数据了，“挂起”标志被设为真，然后发送数据就能继续往下执行了？连续两次 sendData 中间必须有一次 recvData 才行，而且 sendData 里的等待是在发送之后？这块感觉有问题。\n・inter_mutex 和 inter_protect 本身目前没有看出问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577411094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256330,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIRm3kWsgiaEXjO0rr0Aiav7o89StFTFSXbLTkEmiaibmnw8EQTejibrtzKla0emibePT0R0KXjFRIpfXrQ/132","nickname":"zhang","note":"","ucode":"BFA19BED5A5322","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104807,"discussion_content":"谢谢回复。我的业务场景就是发送线程执行sendData之后，必须等待接收线程recvData之后才会执行完sendData。我的问题就是有多个发送线程要执行sendData，所以还需要再加一个inter_mutex锁，来保证多个发送线程是顺序执行的。不知道在sendData函数第一行就const ScopeLock inter_protect(inter_mutex);来保证多个线程顺序执行，是否正确？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577451704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1256330,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIRm3kWsgiaEXjO0rr0Aiav7o89StFTFSXbLTkEmiaibmnw8EQTejibrtzKla0emibePT0R0KXjFRIpfXrQ/132","nickname":"zhang","note":"","ucode":"BFA19BED5A5322","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106050,"discussion_content":"按这么说，目前没发现有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577508672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104807,"ip_address":"","group_id":0},"score":106050,"extra":""}]}]},{"had_liked":false,"id":165495,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1577245543,"is_pvip":false,"replies":[{"id":63149,"content":"试试 c++1y、c++14 等标准选项了。这个 GCC 太老了……我要求 C++17、GCC 7 的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577275341,"ip_address":"","comment_id":165495,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;type_traits&gt;\n\nusing namespace std;\n\ntemplate&lt; class T &gt;\nusing decay_t = typename decay&lt;T&gt;::type;\n\ntemplate &lt; template &lt;typename, typename&gt; class OutContainer = vector,\n           typename F, class R&gt;\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs)\n{\n    typedef decay_t&lt;decltype( f(*inputs.begin()))&gt; result_type;\n    OutContainer&lt; result_type, allocator&lt;result_type&gt;&gt; result;\n    for (auto&amp;&amp; item : inputs) {\n        result.push_back(f(item));\n    }\n    return result;\n}\n\nint add_1(int x)\n{\n    return x + 1;\n}\n\nint main()\n{\n    vector&lt;int&gt; v{1, 2, 3, 4, 5};\n\n    auto result = fmap(add_1, v);\n\n    for (auto &amp;&amp;v : result) {\n        cout &lt;&lt; v &lt;&lt; endl;\n    }\n}\n\n用g++ 4.8.5 带std=c++11参数编译能通过并正确运行，但是有warning:\n13_5.cc:12:28: warning: ‘fmap’ function uses ‘auto’ type specifier without trailing return type [enabled by default] auto fmap(F&amp;&amp; f, R&amp;&amp; inputs)\n\n请问老师如何加尾置返回类型消除warning?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479246,"discussion_content":"觉得有趣就好，这个我们要讲上好几讲的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577336029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165438,"user_name":"李义盛","can_delete":false,"product_type":"c1","uid":1762459,"ip_address":"","ucode":"2C79848BCF545D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","comment_is_top":false,"comment_ctime":1577238026,"is_pvip":false,"replies":[{"id":63148,"content":"拿纸笔来展开试试？实际上就是一种展开而已。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577275219,"ip_address":"","comment_id":165438,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"一到模板就处于看不懂状态了。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479183,"discussion_content":"试试 c++1y、c++14 等标准选项了。这个 GCC 太老了……我要求 C++17、GCC 7 的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577275341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100384,"discussion_content":"上面的代码在https://www.onlinegdb.com/上可以在C++14和C++17下无报警编译通过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577256416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101108,"discussion_content":"那应该的啊，你的警告实质上说的是你的编译器没有打开 C++14 支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577283957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100384,"ip_address":"","group_id":0},"score":101108,"extra":""}]}]},{"had_liked":false,"id":165389,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1577232803,"is_pvip":false,"replies":[{"id":63038,"content":"1 是有点编译器魔法的。如果你有析构函数，或者你没有析构函数但有个非 POD 数据成员，is_trivially_destructible 就不成立了。\n\n2 trivial 是很常见的数学术语，没什么特别的。见：\n\nhttps:&#47;&#47;baike.baidu.com&#47;item&#47;%E5%B9%B3%E5%87%A1&#47;16739977\nhttps:&#47;&#47;zh.wikipedia.org&#47;wiki&#47;%E5%B9%B3%E5%87%A1_(%E6%95%B8%E5%AD%B8)\nhttps:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Triviality_(mathematics)","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577237045,"ip_address":"","comment_id":165389,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"“常用的一个技巧就是用 is_trivially_destructible 模板来判断类是否是可平凡析构的——也就是说，不调用析构函数，不会造成任何资源泄漏问题。”\n\n麻烦解释一下，\n#1 这个类模版是如何识别“，不调用析构函数，不会造成任何资源泄漏问题”？ 这的资源包括new的堆内存吗？\n#2 trivially这个词总是觉得很难理解，C++里，使用这个词的目的，到底是什么？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479141,"discussion_content":"1 是有点编译器魔法的。如果你有析构函数，或者你没有析构函数但有个非 POD 数据成员，is_trivially_destructible 就不成立了。\n\n2 trivial 是很常见的数学术语，没什么特别的。见：\n\nhttps://baike.baidu.com/item/%E5%B9%B3%E5%87%A1/16739977\nhttps://zh.wikipedia.org/wiki/%E5%B9%B3%E5%87%A1_(%E6%95%B8%E5%AD%B8)\nhttps://en.wikipedia.org/wiki/Triviality_(mathematics)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577237045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165386,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1577232703,"is_pvip":false,"replies":[{"id":63040,"content":"编译期要连续讲到第 18 讲，甚至之后还会有提到的机会。你喜欢那是最好了。我是怕很多人会被编译期编程吓退呢。😅\n\npolicy 这个概念不单独讲，但我觉得在讨论了使用常数来对模板进行特化之后，这个概念应该没有特别之处。我们的例子倒是会有标准库提供的 policy。😁","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577237777,"ip_address":"","comment_id":165386,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"一直对模板元编程感兴趣，但总是搞不明白，今天学习很有收获，特别是最后的fmap，感谢老师，记得模板编程还有policy之类的东西，老师之后在编译期这方面还会更详细讲解吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479139,"discussion_content":"编译期要连续讲到第 18 讲，甚至之后还会有提到的机会。你喜欢那是最好了。我是怕很多人会被编译期编程吓退呢。😅\n\npolicy 这个概念不单独讲，但我觉得在讨论了使用常数来对模板进行特化之后，这个概念应该没有特别之处。我们的例子倒是会有标准库提供的 policy。😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577237777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175497,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1580734083,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"类比刚学函数时的感觉。模板类型推导=函数嵌套，用于提供逻辑过程；计算过程由参数传递的过程中进行。逻辑+计算，这样就完成了模板计算。","like_count":0},{"had_liked":false,"id":167092,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1577690056,"is_pvip":false,"replies":[{"id":64982,"content":"很好！第 18 讲你会学得很轻松。😉","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577791705,"ip_address":"","comment_id":167092,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"这个课后思考题真不是盖得。。。还看到了5分钟编译期堆排序的段子。。。看得我心惊胆战。。。\n不过还是一堆百度写出了一个，针对int型，写出从[0, N)的编译期生成数组的例子。。。兼容其他类型还要再额外写好多代码。。偷懒直接写了int型。。。\n我在msvc下测试了，应该没问题。。。用到了模板不定参数，其他不知道什么技巧的方法。。。\n想要让int N转换成从0，1，2，3，4，5 。。。卡在了如何把这堆参数展开。。写得可能复杂一些。。不知道怎么更简单。。 下面代码吧：\n\ntemplate&lt;int... values&gt;\nstruct IntegerSequence {};\n\ntemplate&lt;typename T, T v, typename INTEGER_SEQUENCE&gt;\nstruct PushBack;\n\ntemplate&lt;int v, int... values&gt;\nstruct PushBack&lt;int, v, IntegerSequence&lt;values...&gt;&gt; {\n\tusing type = IntegerSequence&lt;values..., v&gt;;\n};\n\ntemplate&lt;int N&gt;\nstruct IntegerRange {\n\tusing type = typename PushBack&lt;int, N-1, typename IntegerRange&lt;N-1&gt;::type&gt;::type;\n};\n\ntemplate&lt;&gt;\nstruct IntegerRange&lt;1&gt; {\n\tusing type = IntegerSequence&lt;0&gt;;\n};\n\ntemplate&lt;int N, typename INTEGER_SEQUENCE&gt;\nstruct RangeArray;\n\ntemplate&lt;int N, int... values&gt;\nstruct RangeArray&lt;N, IntegerSequence&lt;values...&gt;&gt; {\n\tstatic constexpr std::array&lt;int, N&gt; value = {values...};\n};\n\ntemplate&lt;int N&gt; using Range = RangeArray&lt;N, typename IntegerRange&lt;N&gt;::type&gt;;\n\n测试：\nauto A = Range&lt;5&gt;::value; \n不出意外，会生成std::array&lt;int, 5&gt;{0,1,2,3,4};","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479741,"discussion_content":"很好！第 18 讲你会学得很轻松。😉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577791705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166234,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577420565,"is_pvip":false,"replies":[{"id":63346,"content":"我真是自作自受，得看这样的代码。😜\n\n1. 我给的这些模板只是说明能力的，肯定不是让你真的这么写代码的。比如你这种累加，可以考虑这样写（只考虑了正向）：\n\ntemplate &lt;int from, int to, int sum, bool ending&gt;\nstruct sum_two_op;\n\ntemplate &lt;int from, int to, int sum&gt;\nstruct sum_two_op&lt;from, to, sum, false&gt; {\n    static const int value = sum;\n};\n\ntemplate &lt;int from, int to, int sum&gt;\nstruct sum_two_op&lt;from, to, sum, true&gt; {\n    static const int value =\n        sum_two_op&lt;from + 1, to, sum + from, (from &lt; to)&gt;::value;\n};\n\ntemplate &lt;int from, int to&gt;\nstruct sum_two {\n    static const int value = sum_two_op&lt;from, to, 0, (from &lt;= to)&gt;::value;\n};\n\n2. 你已经很靠近了，只犯了一个小错误，SumTwo 里的方向。应该是：\n\ntemplate &lt;int from, int to&gt;\nstruct SumTwo {\n    typedef SumAnyTwo&lt;(from &lt; to), from, to&gt; type;\n};\n\n另外，你目前的处理对于 from==to 的情况有点问题。可参考我上面的写法，那是可以正确处理的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577424052,"ip_address":"","comment_id":166234,"utype":1}],"discussion_count":5,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"吴老师，看了你的While模板，试着想把这个计算累加的功能扩展一下，输入任意两个数，可以求他们之间的数的累加和，代码如下：\ntemplate &lt;int from, int to, int sum&gt;\nstruct SumAnyTwo_A\n{\n    static const bool cond_value = from != to;\n    static const int res_value = sum;\n    typedef integral_constant&lt;int, res_value&gt; res_type;\n    typedef SumAnyTwo_A&lt;from + 1, to, sum + from&gt; next_type;\n};\n\ntemplate &lt;int from, int to, int sum&gt;\nstruct SumAnyTwo_B\n{\n    static const bool cond_value = from != to;\n    static const int res_value = sum;\n    typedef integral_constant&lt;int, res_value&gt; res_type;\n    typedef SumAnyTwo_B&lt;from - 1, to, sum + from&gt; next_type;\n};\n\ntemplate &lt;bool valueCompare, int from, int to&gt;\nstruct SumAnyTwo;\n\ntemplate &lt;int from, int to&gt;\nstruct SumAnyTwo&lt;true, from, to&gt;\n{\n    typedef SumAnyTwo_A&lt;from, to, 0&gt; addType;\n};\n\ntemplate &lt;int from, int to&gt;\nstruct SumAnyTwo&lt;false, from, to&gt;\n{\n    typedef SumAnyTwo_B&lt;from, to, 0&gt; addType;\n};\n\ntemplate &lt;int from, int to&gt;\nstruct SumTwo\n{\n    typedef SumAnyTwo&lt;(from &gt; to), from, to&gt; type;\n};\n\n遇到了两个问题：\n1，这段代码看起来不够优雅，在C++ 98 的范畴内，有更好的模板元编程实现方式么？\n2，当我试图调用这个While模板时，出现如下状况，不明白为什么第一个会报错\n        While&lt;SumTwo&lt;8, 3&gt;::type::addType&gt;::type::value &#47;&#47; 报错，template  instantiation depth exceeds maximum of 900\n        While&lt;SumAnyTwo_B&lt;8, 3, 0&gt;&gt;::type::value &#47;&#47; OK\n       While&lt;SumAnyTwo&lt;(8 - 3 &lt; 0), 8, 3&gt;::addType&gt;::type::value &#47;&#47;OK\n\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479451,"discussion_content":"我真是自作自受，得看这样的代码。😜\n\n1. 我给的这些模板只是说明能力的，肯定不是让你真的这么写代码的。比如你这种累加，可以考虑这样写（只考虑了正向）：\n\ntemplate &amp;lt;int from, int to, int sum, bool ending&amp;gt;\nstruct sum_two_op;\n\ntemplate &amp;lt;int from, int to, int sum&amp;gt;\nstruct sum_two_op&amp;lt;from, to, sum, false&amp;gt; {\n    static const int value = sum;\n};\n\ntemplate &amp;lt;int from, int to, int sum&amp;gt;\nstruct sum_two_op&amp;lt;from, to, sum, true&amp;gt; {\n    static const int value =\n        sum_two_op&amp;lt;from + 1, to, sum + from, (from &amp;lt; to)&amp;gt;::value;\n};\n\ntemplate &amp;lt;int from, int to&amp;gt;\nstruct sum_two {\n    static const int value = sum_two_op&amp;lt;from, to, 0, (from &amp;lt;= to)&amp;gt;::value;\n};\n\n2. 你已经很靠近了，只犯了一个小错误，SumTwo 里的方向。应该是：\n\ntemplate &amp;lt;int from, int to&amp;gt;\nstruct SumTwo {\n    typedef SumAnyTwo&amp;lt;(from &amp;lt; to), from, to&amp;gt; type;\n};\n\n另外，你目前的处理对于 from==to 的情况有点问题。可参考我上面的写法，那是可以正确处理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577424052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1452167,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcwXucibksEYRSYg6icjibzGa7efcMrCsGec2UwibjTd57icqDz0zzkEEOM2pXVju60dibzcnQKPfRkN9g/132","nickname":"Geek_93970d","note":"","ucode":"52AC308BEC7737","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347724,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612317248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1490070,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","nickname":"总统老唐","note":"","ucode":"F2CC66E5BB4871","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104368,"discussion_content":"感谢吴老师及时答疑。不过还有点小疑问，你说方向错了，确实把大于符号改成小于符号就可以了，但是为什么会有这样的问题，是因为大于符号会干扰模板类型的推断么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577427638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1490070,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","nickname":"总统老唐","note":"","ucode":"F2CC66E5BB4871","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104385,"discussion_content":"不是啊，你符号错了，模板展开就到达不了终结条件了。本来展开5次就结束，现在变成无穷展开了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577429507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104368,"ip_address":"","group_id":0},"score":104385,"extra":""},{"author":{"id":1490070,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","nickname":"总统老唐","note":"","ucode":"F2CC66E5BB4871","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":104522,"discussion_content":"确实是我没看仔细，多谢吴老师耐心","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577439320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104385,"ip_address":"","group_id":0},"score":104522,"extra":""}]}]},{"had_liked":false,"id":166015,"user_name":"zhang","can_delete":false,"product_type":"c1","uid":1256330,"ip_address":"","ucode":"BFA19BED5A5322","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIRm3kWsgiaEXjO0rr0Aiav7o89StFTFSXbLTkEmiaibmnw8EQTejibrtzKla0emibePT0R0KXjFRIpfXrQ/132","comment_is_top":false,"comment_ctime":1577362337,"is_pvip":false,"replies":[{"id":63327,"content":"对你的业务场景不熟悉，随便评论几句。\n\n・C++11 里有现成的 mutex、condition_variable 和 unique_lock。\n・Client::Lock 和 Client::Unlock 似乎没有用处。\n・变量 pending 的命名让人困惑：收到数据了，“挂起”标志被设为真，然后发送数据就能继续往下执行了？连续两次 sendData 中间必须有一次 recvData 才行，而且 sendData 里的等待是在发送之后？这块感觉有问题。\n・inter_mutex 和 inter_protect 本身目前没有看出问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577411094,"ip_address":"","comment_id":166015,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"您好，我想问一个mutex相关的问题，虽然这部分内容以后会讲，但我现在工作中有一个疑问，麻烦您看一下，谢谢。\n代码简写如下：\nclass Mutex {\npublic:\n    pthread_mutex_t mutex;\n    Mutex():mutex(PTHREAD_MUTEX_INITIALIZER) {}\n    void lock() {\n        pthread_mutex_lock(&amp;mutex);\n    }\n    void unlock() {\n        pthread_mutex_unlock(&amp;mutex);\n    }\n};\nclass Cond {\npublic:\n    pthread_cond_t cond;\n    Cond():cond(PTHREAD_COND_INITIALIZER) {}\n    void signal() {\n        pthread_cond_signal(&amp;cond);\n    }\n    void broadcast() {\n        pthread_cond_broadcast(&amp;cond);\n    }\n    void wait(Mutex &amp;mutex) {\n        pthread_cond_wait(&amp;cond, &amp;mutex.mutex);\n    }\n};\nclass ScopeLock {\n    Mutex &amp;mutex;\npublic:\n    ScopeLock(CanMutex &amp;_mutex):mutex(_mutex) {\n        mutex.lock();\n    };\n    ~ScopeLock() {\n        mutex.unlock();\n    };\n};\n\nclass Client\n{\npublic:\n    Mutex inter_mutex;\n    Mutex mutex;\n    Cond cond;\n    bool pending;\n    Client():pending(false){}\n    ~Client(){}\n    void Lock() {\n        mutex.lock();\n    }\n    void Unlock() {\n        mutex.unlock();\n    }\n    void sendData() {\n        const ScopeLock inter_protect(inter_mutex);\n        const ScopeLock protect(mutex);\n\n        &#47;&#47;send_to_server();\n\n        while (!pending) {\n            cond.wait(mutex);\n        }\n        pending = false;\n    }\n    void recvData() {\n        const ScopeLock protect(mutex);\n        pending = true;\n        cond.signal();\n    }\n};\n我有几个线程会执行同一个Client对象的sendData函数，有一个线程执行Client对象的recvData函数。我主要想问我几个sendData线程需要同步执行，执行完一个sendData发送后，再执行另一个sendData。那么我在sendData函数最开始加整个函数范围的锁const ScopeLock inter_protect(inter_mutex);，是否可以这样做？谢谢！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479451,"discussion_content":"我真是自作自受，得看这样的代码。😜\n\n1. 我给的这些模板只是说明能力的，肯定不是让你真的这么写代码的。比如你这种累加，可以考虑这样写（只考虑了正向）：\n\ntemplate &amp;lt;int from, int to, int sum, bool ending&amp;gt;\nstruct sum_two_op;\n\ntemplate &amp;lt;int from, int to, int sum&amp;gt;\nstruct sum_two_op&amp;lt;from, to, sum, false&amp;gt; {\n    static const int value = sum;\n};\n\ntemplate &amp;lt;int from, int to, int sum&amp;gt;\nstruct sum_two_op&amp;lt;from, to, sum, true&amp;gt; {\n    static const int value =\n        sum_two_op&amp;lt;from + 1, to, sum + from, (from &amp;lt; to)&amp;gt;::value;\n};\n\ntemplate &amp;lt;int from, int to&amp;gt;\nstruct sum_two {\n    static const int value = sum_two_op&amp;lt;from, to, 0, (from &amp;lt;= to)&amp;gt;::value;\n};\n\n2. 你已经很靠近了，只犯了一个小错误，SumTwo 里的方向。应该是：\n\ntemplate &amp;lt;int from, int to&amp;gt;\nstruct SumTwo {\n    typedef SumAnyTwo&amp;lt;(from &amp;lt; to), from, to&amp;gt; type;\n};\n\n另外，你目前的处理对于 from==to 的情况有点问题。可参考我上面的写法，那是可以正确处理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577424052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1452167,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcwXucibksEYRSYg6icjibzGa7efcMrCsGec2UwibjTd57icqDz0zzkEEOM2pXVju60dibzcnQKPfRkN9g/132","nickname":"Geek_93970d","note":"","ucode":"52AC308BEC7737","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347724,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612317248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1490070,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","nickname":"总统老唐","note":"","ucode":"F2CC66E5BB4871","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104368,"discussion_content":"感谢吴老师及时答疑。不过还有点小疑问，你说方向错了，确实把大于符号改成小于符号就可以了，但是为什么会有这样的问题，是因为大于符号会干扰模板类型的推断么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577427638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1490070,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","nickname":"总统老唐","note":"","ucode":"F2CC66E5BB4871","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104385,"discussion_content":"不是啊，你符号错了，模板展开就到达不了终结条件了。本来展开5次就结束，现在变成无穷展开了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577429507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104368,"ip_address":"","group_id":0},"score":104385,"extra":""},{"author":{"id":1490070,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","nickname":"总统老唐","note":"","ucode":"F2CC66E5BB4871","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":104522,"discussion_content":"确实是我没看仔细，多谢吴老师耐心","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577439320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104385,"ip_address":"","group_id":0},"score":104522,"extra":""}]}]},{"had_liked":false,"id":165651,"user_name":"安静的雨","can_delete":false,"product_type":"c1","uid":1004841,"ip_address":"","ucode":"6371DE858C4D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/29/4fa6e9fb.jpg","comment_is_top":false,"comment_ctime":1577278553,"is_pvip":false,"replies":[{"id":63240,"content":"觉得有趣就好，这个我们要讲上好几讲的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577336029,"ip_address":"","comment_id":165651,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"模版编程很有趣，期待老师的更新。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479246,"discussion_content":"觉得有趣就好，这个我们要讲上好几讲的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577336029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165495,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1577245543,"is_pvip":false,"replies":[{"id":63149,"content":"试试 c++1y、c++14 等标准选项了。这个 GCC 太老了……我要求 C++17、GCC 7 的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577275341,"ip_address":"","comment_id":165495,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;type_traits&gt;\n\nusing namespace std;\n\ntemplate&lt; class T &gt;\nusing decay_t = typename decay&lt;T&gt;::type;\n\ntemplate &lt; template &lt;typename, typename&gt; class OutContainer = vector,\n           typename F, class R&gt;\nauto fmap(F&amp;&amp; f, R&amp;&amp; inputs)\n{\n    typedef decay_t&lt;decltype( f(*inputs.begin()))&gt; result_type;\n    OutContainer&lt; result_type, allocator&lt;result_type&gt;&gt; result;\n    for (auto&amp;&amp; item : inputs) {\n        result.push_back(f(item));\n    }\n    return result;\n}\n\nint add_1(int x)\n{\n    return x + 1;\n}\n\nint main()\n{\n    vector&lt;int&gt; v{1, 2, 3, 4, 5};\n\n    auto result = fmap(add_1, v);\n\n    for (auto &amp;&amp;v : result) {\n        cout &lt;&lt; v &lt;&lt; endl;\n    }\n}\n\n用g++ 4.8.5 带std=c++11参数编译能通过并正确运行，但是有warning:\n13_5.cc:12:28: warning: ‘fmap’ function uses ‘auto’ type specifier without trailing return type [enabled by default] auto fmap(F&amp;&amp; f, R&amp;&amp; inputs)\n\n请问老师如何加尾置返回类型消除warning?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479183,"discussion_content":"试试 c++1y、c++14 等标准选项了。这个 GCC 太老了……我要求 C++17、GCC 7 的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577275341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100384,"discussion_content":"上面的代码在https://www.onlinegdb.com/上可以在C++14和C++17下无报警编译通过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577256416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101108,"discussion_content":"那应该的啊，你的警告实质上说的是你的编译器没有打开 C++14 支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577283957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100384,"ip_address":"","group_id":0},"score":101108,"extra":""}]}]},{"had_liked":false,"id":165438,"user_name":"李义盛","can_delete":false,"product_type":"c1","uid":1762459,"ip_address":"","ucode":"2C79848BCF545D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","comment_is_top":false,"comment_ctime":1577238026,"is_pvip":false,"replies":[{"id":63148,"content":"拿纸笔来展开试试？实际上就是一种展开而已。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577275219,"ip_address":"","comment_id":165438,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"一到模板就处于看不懂状态了。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479158,"discussion_content":"拿纸笔来展开试试？实际上就是一种展开而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577275219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165389,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1577232803,"is_pvip":false,"replies":[{"id":63038,"content":"1 是有点编译器魔法的。如果你有析构函数，或者你没有析构函数但有个非 POD 数据成员，is_trivially_destructible 就不成立了。\n\n2 trivial 是很常见的数学术语，没什么特别的。见：\n\nhttps:&#47;&#47;baike.baidu.com&#47;item&#47;%E5%B9%B3%E5%87%A1&#47;16739977\nhttps:&#47;&#47;zh.wikipedia.org&#47;wiki&#47;%E5%B9%B3%E5%87%A1_(%E6%95%B8%E5%AD%B8)\nhttps:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Triviality_(mathematics)","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577237045,"ip_address":"","comment_id":165389,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"“常用的一个技巧就是用 is_trivially_destructible 模板来判断类是否是可平凡析构的——也就是说，不调用析构函数，不会造成任何资源泄漏问题。”\n\n麻烦解释一下，\n#1 这个类模版是如何识别“，不调用析构函数，不会造成任何资源泄漏问题”？ 这的资源包括new的堆内存吗？\n#2 trivially这个词总是觉得很难理解，C++里，使用这个词的目的，到底是什么？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479158,"discussion_content":"拿纸笔来展开试试？实际上就是一种展开而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577275219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165386,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1577232703,"is_pvip":false,"replies":[{"id":63040,"content":"编译期要连续讲到第 18 讲，甚至之后还会有提到的机会。你喜欢那是最好了。我是怕很多人会被编译期编程吓退呢。😅\n\npolicy 这个概念不单独讲，但我觉得在讨论了使用常数来对模板进行特化之后，这个概念应该没有特别之处。我们的例子倒是会有标准库提供的 policy。😁","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577237777,"ip_address":"","comment_id":165386,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"一直对模板元编程感兴趣，但总是搞不明白，今天学习很有收获，特别是最后的fmap，感谢老师，记得模板编程还有policy之类的东西，老师之后在编译期这方面还会更详细讲解吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479141,"discussion_content":"1 是有点编译器魔法的。如果你有析构函数，或者你没有析构函数但有个非 POD 数据成员，is_trivially_destructible 就不成立了。\n\n2 trivial 是很常见的数学术语，没什么特别的。见：\n\nhttps://baike.baidu.com/item/%E5%B9%B3%E5%87%A1/16739977\nhttps://zh.wikipedia.org/wiki/%E5%B9%B3%E5%87%A1_(%E6%95%B8%E5%AD%B8)\nhttps://en.wikipedia.org/wiki/Triviality_(mathematics)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577237045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175497,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1580734083,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"类比刚学函数时的感觉。模板类型推导=函数嵌套，用于提供逻辑过程；计算过程由参数传递的过程中进行。逻辑+计算，这样就完成了模板计算。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479139,"discussion_content":"编译期要连续讲到第 18 讲，甚至之后还会有提到的机会。你喜欢那是最好了。我是怕很多人会被编译期编程吓退呢。😅\n\npolicy 这个概念不单独讲，但我觉得在讨论了使用常数来对模板进行特化之后，这个概念应该没有特别之处。我们的例子倒是会有标准库提供的 policy。😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577237777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}