{"id":220230,"title":"12 | 异常处理：别让自己在出问题的时候变为瞎子","content":"<p>你好，我是朱晔。今天，我来和你聊聊异常处理容易踩的坑。</p><p>应用程序避免不了出异常，捕获和处理异常是考验编程功力的一个精细活。一些业务项目中，我曾看到开发同学在开发业务逻辑时不考虑任何异常处理，项目接近完成时再采用“流水线”的方式进行异常处理，也就是统一为所有方法打上try…catch…捕获所有异常记录日志，有些技巧的同学可能会使用AOP来进行类似的“统一异常处理”。</p><p>其实，这种处理异常的方式非常不可取。那么今天，我就和你分享下不可取的原因、与异常处理相关的坑和最佳实践。</p><h2>捕获和处理异常容易犯的错</h2><p>“统一异常处理”方式正是我要说的第一个错：<strong>不在业务代码层面考虑异常处理，仅在框架层面粗犷捕获和处理异常</strong>。</p><p>为了理解错在何处，我们先来看看大多数业务应用都采用的三层架构：</p><ul>\n<li>Controller层负责信息收集、参数校验、转换服务层处理的数据适配前端，轻业务逻辑；</li>\n<li>Service层负责核心业务逻辑，包括各种外部服务调用、访问数据库、缓存处理、消息处理等；</li>\n<li>Repository层负责数据访问实现，一般没有业务逻辑。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/2f/61/2f2cfbd86efd3bc140400bcaf2985361.png?wh=1304*1284\" alt=\"\"></p><p>每层架构的工作性质不同，且从业务性质上异常可能分为业务异常和系统异常两大类，这就决定了很难进行统一的异常处理。我们从底向上看一下三层架构：</p><!-- [[[read_end]]] --><ul>\n<li>Repository层出现异常或许可以忽略，或许可以降级，或许需要转化为一个友好的异常。如果一律捕获异常仅记录日志，很可能业务逻辑已经出错，而用户和程序本身完全感知不到。</li>\n<li>Service层往往涉及数据库事务，出现异常同样不适合捕获，否则事务无法自动回滚。此外Service层涉及业务逻辑，有些业务逻辑执行中遇到业务异常，可能需要在异常后转入分支业务流程。如果业务异常都被框架捕获了，业务功能就会不正常。</li>\n<li>如果下层异常上升到Controller层还是无法处理的话，Controller层往往会给予用户友好提示，或是根据每一个API的异常表返回指定的异常类型，同样无法对所有异常一视同仁。</li>\n</ul><p>因此，我不建议在框架层面进行异常的自动、统一处理，尤其不要随意捕获异常。但，框架可以做兜底工作。如果异常上升到最上层逻辑还是无法处理的话，可以以统一的方式进行异常转换，比如通过@RestControllerAdvice + @ExceptionHandler，来捕获这些“未处理”异常：</p><ul>\n<li>对于自定义的业务异常，以Warn级别的日志记录异常以及当前URL、执行方法等信息后，提取异常中的错误码和消息等信息，转换为合适的API包装体返回给API调用方；</li>\n<li>对于无法处理的系统异常，以Error级别的日志记录异常和上下文信息（比如URL、参数、用户ID）后，转换为普适的“服务器忙，请稍后再试”异常信息，同样以API包装体返回给调用方。</li>\n</ul><p>比如，下面这段代码的做法：</p><pre><code>@RestControllerAdvice\n@Slf4j\npublic class RestControllerExceptionHandler {\n    private static int GENERIC_SERVER_ERROR_CODE = 2000;\n    private static String GENERIC_SERVER_ERROR_MESSAGE = &quot;服务器忙，请稍后再试&quot;;\n\n    @ExceptionHandler\n    public APIResponse handle(HttpServletRequest req, HandlerMethod method, Exception ex) {\n        if (ex instanceof BusinessException) {\n            BusinessException exception = (BusinessException) ex;\n            log.warn(String.format(&quot;访问 %s -&gt; %s 出现业务异常！&quot;, req.getRequestURI(), method.toString()), ex);\n            return new APIResponse(false, null, exception.getCode(), exception.getMessage());\n        } else {\n            log.error(String.format(&quot;访问 %s -&gt; %s 出现系统异常！&quot;, req.getRequestURI(), method.toString()), ex);\n            return new APIResponse(false, null, GENERIC_SERVER_ERROR_CODE, GENERIC_SERVER_ERROR_MESSAGE);\n        }\n    }\n}\n</code></pre><p>出现运行时系统异常后，异常处理程序会直接把异常转换为JSON返回给调用方：</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/84/c215e78f1b23583393649fa89efe9f84.png?wh=774*308\" alt=\"\"></p><p>要做得更好，你可以把相关出入参、用户信息在脱敏后记录到日志中，方便出现问题时根据上下文进一步排查。</p><p>第二个错，<strong>捕获了异常后直接生吞</strong>。在任何时候，我们捕获了异常都不应该生吞，也就是直接丢弃异常不记录、不抛出。这样的处理方式还不如不捕获异常，因为被生吞掉的异常一旦导致Bug，就很难在程序中找到蛛丝马迹，使得Bug排查工作难上加难。</p><p>通常情况下，生吞异常的原因，可能是不希望自己的方法抛出受检异常，只是为了把异常“处理掉”而捕获并生吞异常，也可能是想当然地认为异常并不重要或不可能产生。但不管是什么原因，不管是你认为多么不重要的异常，都不应该生吞，哪怕是一个日志也好。</p><p>第三个错，<strong>丢弃异常的原始信息</strong>。我们来看两个不太合适的异常处理方式，虽然没有完全生吞异常，但也丢失了宝贵的异常信息。</p><p>比如有这么一个会抛出受检异常的方法readFile：</p><pre><code>private void readFile() throws IOException {\n\tFiles.readAllLines(Paths.get(&quot;a_file&quot;));\n}\n</code></pre><p>像这样调用readFile方法，捕获异常后，完全不记录原始异常，直接抛出一个转换后异常，导致出了问题不知道IOException具体是哪里引起的：</p><pre><code>@GetMapping(&quot;wrong1&quot;)\npublic void wrong1(){\n    try {\n        readFile();\n    } catch (IOException e) {\n        //原始异常信息丢失  \n        throw new RuntimeException(&quot;系统忙请稍后再试&quot;);\n    }\n}\n</code></pre><p>或者是这样，只记录了异常消息，却丢失了异常的类型、栈等重要信息：</p><pre><code>catch (IOException e) {\n    //只保留了异常消息，栈没有记录\n    log.error(&quot;文件读取错误, {}&quot;, e.getMessage());\n    throw new RuntimeException(&quot;系统忙请稍后再试&quot;);\n}\n</code></pre><p>留下的日志是这样的，看完一脸茫然，只知道文件读取错误的文件名，至于为什么读取错误、是不存在还是没权限，完全不知道。</p><pre><code>[12:57:19.746] [http-nio-45678-exec-1] [ERROR] [.g.t.c.e.d.HandleExceptionController:35  ] - 文件读取错误, a_file\n</code></pre><p>这两种处理方式都不太合理，可以改为如下方式：</p><pre><code>catch (IOException e) {\n    log.error(&quot;文件读取错误&quot;, e);\n    throw new RuntimeException(&quot;系统忙请稍后再试&quot;);\n}\n</code></pre><p>或者，把原始异常作为转换后新异常的cause，原始异常信息同样不会丢：</p><pre><code>catch (IOException e) {\n    throw new RuntimeException(&quot;系统忙请稍后再试&quot;, e);\n}\n</code></pre><p>其实，JDK内部也会犯类似的错。之前我遇到一个使用JDK10的应用偶发启动失败的案例，日志中可以看到出现类似的错误信息：</p><pre><code>Caused by: java.lang.SecurityException: Couldn't parse jurisdiction policy files in: unlimited\n\tat java.base/javax.crypto.JceSecurity.setupJurisdictionPolicies(JceSecurity.java:355)\n\tat java.base/javax.crypto.JceSecurity.access$000(JceSecurity.java:73)\n\tat java.base/javax.crypto.JceSecurity$1.run(JceSecurity.java:109)\n\tat java.base/javax.crypto.JceSecurity$1.run(JceSecurity.java:106)\n\tat java.base/java.security.AccessController.doPrivileged(Native Method)\n\tat java.base/javax.crypto.JceSecurity.&lt;clinit&gt;(JceSecurity.java:105)\n\t... 20 more\n</code></pre><p>查看JDK JceSecurity类setupJurisdictionPolicies方法源码，发现异常e没有记录，也没有作为新抛出异常的cause，当时读取文件具体出现什么异常（权限问题又或是IO问题）可能永远都无法知道了，对问题定位造成了很大困扰：</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/65/b8b581f6130211a19ed66490dbcd0465.png?wh=1926*1124\" alt=\"\"></p><p>第四个错，<strong>抛出异常时不指定任何消息</strong>。我见过一些代码中的偷懒做法，直接抛出没有message的异常：</p><pre><code>throw new RuntimeException();\n</code></pre><p>这么写的同学可能觉得永远不会走到这个逻辑，永远不会出现这样的异常。但，这样的异常却出现了，被ExceptionHandler拦截到后输出了下面的日志信息：</p><pre><code>[13:25:18.031] [http-nio-45678-exec-3] [ERROR] [c.e.d.RestControllerExceptionHandler:24  ] - 访问 /handleexception/wrong3 -&gt; org.geekbang.time.commonmistakes.exception.demo1.HandleExceptionController#wrong3(String) 出现系统异常！\njava.lang.RuntimeException: null\n...\n</code></pre><p>这里的null非常容易引起误解。按照空指针问题排查半天才发现，其实是异常的message为空。</p><p>总之，如果你捕获了异常打算处理的话，<strong>除了通过日志正确记录异常原始信息外，通常还有三种处理模式</strong>：</p><ul>\n<li>转换，即转换新的异常抛出。对于新抛出的异常，最好具有特定的分类和明确的异常消息，而不是随便抛一个无关或没有任何信息的异常，并最好通过cause关联老异常。</li>\n<li>重试，即重试之前的操作。比如远程调用服务端过载超时的情况，盲目重试会让问题更严重，需要考虑当前情况是否适合重试。</li>\n<li>恢复，即尝试进行降级处理，或使用默认值来替代原始数据。</li>\n</ul><p>以上，就是通过catch捕获处理异常的一些最佳实践。</p><h2>小心finally中的异常</h2><p>有些时候，我们希望不管是否遇到异常，逻辑完成后都要释放资源，这时可以使用finally代码块而跳过使用catch代码块。</p><p>但要千万小心finally代码块中的异常，因为资源释放处理等收尾操作同样也可能出现异常。比如下面这段代码，我们在finally中抛出一个异常：</p><pre><code>@GetMapping(&quot;wrong&quot;)\npublic void wrong() {\n    try {\n        log.info(&quot;try&quot;);\n        //异常丢失\n        throw new RuntimeException(&quot;try&quot;);\n    } finally {\n        log.info(&quot;finally&quot;);\n        throw new RuntimeException(&quot;finally&quot;);\n    }\n}\n</code></pre><p>最后在日志中只能看到finally中的异常，<strong>虽然try中的逻辑出现了异常，但却被finally中的异常覆盖了</strong>。这是非常危险的，特别是finally中出现的异常是偶发的，就会在部分时候覆盖try中的异常，让问题更不明显：</p><pre><code>[13:34:42.247] [http-nio-45678-exec-1] [ERROR] [.a.c.c.C.[.[.[/].[dispatcherServlet]:175 ] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: finally] with root cause\njava.lang.RuntimeException: finally\n</code></pre><p>至于异常为什么被覆盖，原因也很简单，因为一个方法无法出现两个异常。修复方式是，finally代码块自己负责异常捕获和处理：</p><pre><code>@GetMapping(&quot;right&quot;)\npublic void right() {\n    try {\n        log.info(&quot;try&quot;);\n        throw new RuntimeException(&quot;try&quot;);\n    } finally {\n        log.info(&quot;finally&quot;);\n        try {\n            throw new RuntimeException(&quot;finally&quot;);\n        } catch (Exception ex) {\n            log.error(&quot;finally&quot;, ex);\n        }\n    }\n}\n</code></pre><p>或者可以把try中的异常作为主异常抛出，使用addSuppressed方法把finally中的异常附加到主异常上：</p><pre><code>@GetMapping(&quot;right2&quot;)\npublic void right2() throws Exception {\n    Exception e = null;\n    try {\n        log.info(&quot;try&quot;);\n        throw new RuntimeException(&quot;try&quot;);\n    } catch (Exception ex) {\n        e = ex;\n    } finally {\n        log.info(&quot;finally&quot;);\n        try {\n            throw new RuntimeException(&quot;finally&quot;);\n        } catch (Exception ex) {\n            if (e!= null) {\n                e.addSuppressed(ex);\n            } else {\n                e = ex;\n            }\n        }\n    }\n    throw e;\n}\n</code></pre><p>运行方法可以得到如下异常信息，其中同时包含了主异常和被屏蔽的异常：</p><pre><code>java.lang.RuntimeException: try\n\tat org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.right2(FinallyIssueController.java:69)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\t...\n\tSuppressed: java.lang.RuntimeException: finally\n\t\tat org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.right2(FinallyIssueController.java:75)\n\t\t... 54 common frames omitted\n</code></pre><p>其实这正是try-with-resources语句的做法，对于实现了AutoCloseable接口的资源，建议使用try-with-resources来释放资源，否则也可能会产生刚才提到的，释放资源时出现的异常覆盖主异常的问题。比如如下我们定义一个测试资源，其read和close方法都会抛出异常：</p><pre><code>public class TestResource implements AutoCloseable {\n    public void read() throws Exception{\n        throw new Exception(&quot;read error&quot;);\n    }\n    @Override\n    public void close() throws Exception {\n        throw new Exception(&quot;close error&quot;);\n    }\n}\n</code></pre><p>使用传统的try-finally语句，在try中调用read方法，在finally中调用close方法：</p><pre><code>@GetMapping(&quot;useresourcewrong&quot;)\npublic void useresourcewrong() throws Exception {\n    TestResource testResource = new TestResource();\n    try {\n        testResource.read();\n    } finally {\n        testResource.close();\n    }\n}\n</code></pre><p>可以看到，同样出现了finally中的异常覆盖了try中异常的问题：</p><pre><code>java.lang.Exception: close error\n\tat org.geekbang.time.commonmistakes.exception.finallyissue.TestResource.close(TestResource.java:10)\n\tat org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.useresourcewrong(FinallyIssueController.java:27)\n</code></pre><p>而改为try-with-resources模式之后：</p><pre><code>@GetMapping(&quot;useresourceright&quot;)\npublic void useresourceright() throws Exception {\n    try (TestResource testResource = new TestResource()){\n        testResource.read();\n    }\n}\n</code></pre><p>try和finally中的异常信息都可以得到保留：</p><pre><code>java.lang.Exception: read error\n\tat org.geekbang.time.commonmistakes.exception.finallyissue.TestResource.read(TestResource.java:6)\n\t...\n\tSuppressed: java.lang.Exception: close error\n\t\tat org.geekbang.time.commonmistakes.exception.finallyissue.TestResource.close(TestResource.java:10)\n\t\tat org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.useresourceright(FinallyIssueController.java:35)\n\t\t... 54 common frames omitted\n</code></pre><h2>千万别把异常定义为静态变量</h2><p>既然我们通常会自定义一个业务异常类型，来包含更多的异常信息，比如异常错误码、友好的错误提示等，那就需要在业务逻辑各处，手动抛出各种业务异常来返回指定的错误码描述（比如对于下单操作，用户不存在返回2001，商品缺货返回2002等）。</p><p>对于这些异常的错误代码和消息，我们期望能够统一管理，而不是散落在程序各处定义。这个想法很好，但稍有不慎就可能会出现把异常定义为静态变量的坑。</p><p>我在救火排查某项目生产问题时，遇到了一件非常诡异的事情：我发现异常堆信息显示的方法调用路径，在当前入参的情况下根本不可能产生，项目的业务逻辑又很复杂，就始终没往异常信息是错的这方面想，总觉得是因为某个分支流程导致业务没有按照期望的流程进行。</p><p><strong>经过艰难的排查，最终定位到原因是把异常定义为了静态变量，导致异常栈信息错乱</strong>，类似于定义一个Exceptions类来汇总所有的异常，把异常存放在静态字段中：</p><pre><code>public class Exceptions {\n    public static BusinessException ORDEREXISTS = new BusinessException(&quot;订单已经存在&quot;, 3001);\n...\n}\n</code></pre><p>把异常定义为静态变量会导致异常信息固化，这就和异常的栈一定是需要根据当前调用来动态获取相矛盾。</p><p>我们写段代码来模拟下这个问题：定义两个方法createOrderWrong和cancelOrderWrong方法，它们内部都会通过Exceptions类来获得一个订单不存在的异常；先后调用两个方法，然后抛出。</p><pre><code>@GetMapping(&quot;wrong&quot;)\npublic void wrong() {\n    try {\n        createOrderWrong();\n    } catch (Exception ex) {\n        log.error(&quot;createOrder got error&quot;, ex);\n    }\n    try {\n        cancelOrderWrong();\n    } catch (Exception ex) {\n        log.error(&quot;cancelOrder got error&quot;, ex);\n    }\n}\n\nprivate void createOrderWrong() {\n    //这里有问题\n    throw Exceptions.ORDEREXISTS;\n}\n\nprivate void cancelOrderWrong() {\n    //这里有问题\n    throw Exceptions.ORDEREXISTS;\n}\n</code></pre><p>运行程序后看到如下日志，cancelOrder got error的提示对应了createOrderWrong方法。显然，cancelOrderWrong方法在出错后抛出的异常，其实是createOrderWrong方法出错的异常：</p><pre><code>[14:05:25.782] [http-nio-45678-exec-1] [ERROR] [.c.e.d.PredefinedExceptionController:25  ] - cancelOrder got error\norg.geekbang.time.commonmistakes.exception.demo2.BusinessException: 订单已经存在\n\tat org.geekbang.time.commonmistakes.exception.demo2.Exceptions.&lt;clinit&gt;(Exceptions.java:5)\n\tat org.geekbang.time.commonmistakes.exception.demo2.PredefinedExceptionController.createOrderWrong(PredefinedExceptionController.java:50)\n\tat org.geekbang.time.commonmistakes.exception.demo2.PredefinedExceptionController.wrong(PredefinedExceptionController.java:18)\n</code></pre><p>修复方式很简单，改一下Exceptions类的实现，通过不同的方法把每一种异常都new出来抛出即可：</p><pre><code>public class Exceptions {\n    public static BusinessException orderExists(){\n        return new BusinessException(&quot;订单已经存在&quot;, 3001);\n    }\n}\n</code></pre><h2>提交线程池的任务出了异常会怎么样？</h2><p>在<a href=\"https://time.geekbang.org/column/article/210337\">第3讲</a>介绍线程池时我提到，线程池常用作异步处理或并行处理。那么，把任务提交到线程池处理，任务本身出现异常时会怎样呢？</p><p>我们来看一个例子：提交10个任务到线程池异步处理，第5个任务抛出一个RuntimeException，每个任务完成后都会输出一行日志：</p><pre><code>@GetMapping(&quot;execute&quot;)\npublic void execute() throws InterruptedException {\n\n    String prefix = &quot;test&quot;;\n    ExecutorService threadPool = Executors.newFixedThreadPool(1, new ThreadFactoryBuilder().setNameFormat(prefix+&quot;%d&quot;).get());\n    //提交10个任务到线程池处理，第5个任务会抛出运行时异常\n    IntStream.rangeClosed(1, 10).forEach(i -&gt; threadPool.execute(() -&gt; {\n        if (i == 5) throw new RuntimeException(&quot;error&quot;);\n        log.info(&quot;I'm done : {}&quot;, i);\n    }));\n\n    threadPool.shutdown();\n    threadPool.awaitTermination(1, TimeUnit.HOURS);\n}\n</code></pre><p>观察日志可以发现两点：</p><pre><code>...\n[14:33:55.990] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:26  ] - I'm done : 4\nException in thread &quot;test0&quot; java.lang.RuntimeException: error\n\tat org.geekbang.time.commonmistakes.exception.demo3.ThreadPoolAndExceptionController.lambda$null$0(ThreadPoolAndExceptionController.java:25)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\n[14:33:55.990] [test1] [INFO ] [e.d.ThreadPoolAndExceptionController:26  ] - I'm done : 6\n...\n</code></pre><ul>\n<li>任务1到4所在的线程是test0，任务6开始运行在线程test1。由于我的线程池通过线程工厂为线程使用统一的前缀test加上计数器进行命名，因此<strong>从线程名的改变可以知道因为异常的抛出老线程退出了，线程池只能重新创建一个线程</strong>。如果每个异步任务都以异常结束，那么线程池可能完全起不到线程重用的作用。</li>\n<li>因为没有手动捕获异常进行处理，ThreadGroup帮我们进行了未捕获异常的默认处理，向标准错误输出打印了出现异常的线程名称和异常信息。<strong>显然，这种没有以统一的错误日志格式记录错误信息打印出来的形式，对生产级代码是不合适的</strong>，ThreadGroup的相关源码如下所示：</li>\n</ul><pre><code>public void uncaughtException(Thread t, Throwable e) {\n        if (parent != null) {\n            parent.uncaughtException(t, e);\n        } else {\n            Thread.UncaughtExceptionHandler ueh =\n                Thread.getDefaultUncaughtExceptionHandler();\n            if (ueh != null) {\n                ueh.uncaughtException(t, e);\n            } else if (!(e instanceof ThreadDeath)) {\n                System.err.print(&quot;Exception in thread \\&quot;&quot;\n                                 + t.getName() + &quot;\\&quot; &quot;);\n                e.printStackTrace(System.err);\n            }\n        }\n    }\n</code></pre><p>修复方式有2步：</p><ol>\n<li>以execute方法提交到线程池的异步任务，最好在任务内部做好异常处理；</li>\n<li>设置自定义的异常处理程序作为保底，比如在声明线程池时自定义线程池的未捕获异常处理程序：</li>\n</ol><pre><code>new ThreadFactoryBuilder()\n\t.setNameFormat(prefix+&quot;%d&quot;)\n\t.setUncaughtExceptionHandler((thread, throwable)-&gt; log.error(&quot;ThreadPool {} got exception&quot;, thread, throwable))\n\t.get()\n</code></pre><p>或者设置全局的默认未捕获异常处理程序：</p><pre><code>static {\n    Thread.setDefaultUncaughtExceptionHandler((thread, throwable)-&gt; log.error(&quot;Thread {} got exception&quot;, thread, throwable));\n}\n</code></pre><p>通过线程池ExecutorService的execute方法提交任务到线程池处理，如果出现异常会导致线程退出，控制台输出中可以看到异常信息。那么，把execute方法改为submit，线程还会退出吗，异常还能被处理程序捕获到吗？</p><p><strong>修改代码后重新执行程序可以看到如下日志，说明线程没退出，异常也没记录被生吞了：</strong></p><pre><code>[15:44:33.769] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I'm done : 1\n[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I'm done : 2\n[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I'm done : 3\n[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I'm done : 4\n[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I'm done : 6\n[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I'm done : 7\n[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I'm done : 8\n[15:44:33.771] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I'm done : 9\n[15:44:33.771] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I'm done : 10\n</code></pre><p>为什么会这样呢？</p><p>查看FutureTask源码可以发现，在执行任务出现异常之后，异常存到了一个outcome字段中，只有在调用get方法获取FutureTask结果的时候，才会以ExecutionException的形式重新抛出异常：</p><pre><code>public void run() {\n...\n    try {\n        Callable&lt;V&gt; c = callable;\n        if (c != null &amp;&amp; state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                result = c.call();\n                ran = true;\n            } catch (Throwable ex) {\n                result = null;\n                ran = false;\n                setException(ex);\n            }\n...\n}\n\nprotected void setException(Throwable t) {\n    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n        outcome = t;\n        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n        finishCompletion();\n    }\n}\n\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s &lt;= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n}\n\nprivate V report(int s) throws ExecutionException {\n    Object x = outcome;\n    if (s == NORMAL)\n        return (V)x;\n    if (s &gt;= CANCELLED)\n        throw new CancellationException();\n    throw new ExecutionException((Throwable)x);\n}\n</code></pre><p>修改后的代码如下所示，我们把submit返回的Future放到了List中，随后遍历List来捕获所有任务的异常。这么做确实合乎情理。既然是以submit方式来提交任务，那么我们应该关心任务的执行结果，否则应该以execute来提交任务：</p><pre><code>List&lt;Future&gt; tasks = IntStream.rangeClosed(1, 10).mapToObj(i -&gt; threadPool.submit(() -&gt; {\n    if (i == 5) throw new RuntimeException(&quot;error&quot;);\n    log.info(&quot;I'm done : {}&quot;, i);\n})).collect(Collectors.toList());\n\ntasks.forEach(task-&gt; {\n    try {\n        task.get();\n    } catch (Exception e) {\n        log.error(&quot;Got exception&quot;, e);\n    }\n});\n</code></pre><p>执行这段程序可以看到如下的日志输出：</p><pre><code>[15:44:13.543] [http-nio-45678-exec-1] [ERROR] [e.d.ThreadPoolAndExceptionController:69  ] - Got exception\njava.util.concurrent.ExecutionException: java.lang.RuntimeException: error\n</code></pre><h2>重点回顾</h2><p>在今天的文章中，我介绍了处理异常容易犯的几个错和最佳实践。</p><p>第一，注意捕获和处理异常的最佳实践。首先，不应该用AOP对所有方法进行统一异常处理，异常要么不捕获不处理，要么根据不同的业务逻辑、不同的异常类型进行精细化、针对性处理；其次，处理异常应该杜绝生吞，并确保异常栈信息得到保留；最后，如果需要重新抛出异常的话，请使用具有意义的异常类型和异常消息。</p><p>第二，务必小心finally代码块中资源回收逻辑，确保finally代码块不出现异常，内部把异常处理完毕，避免finally中的异常覆盖try中的异常；或者考虑使用addSuppressed方法把finally中的异常附加到try中的异常上，确保主异常信息不丢失。此外，使用实现了AutoCloseable接口的资源，务必使用try-with-resources模式来使用资源，确保资源可以正确释放，也同时确保异常可以正确处理。</p><p>第三，虽然在统一的地方定义收口所有的业务异常是一个不错的实践，但务必确保异常是每次new出来的，而不能使用一个预先定义的static字段存放异常，否则可能会引起栈信息的错乱。</p><p>第四，确保正确处理了线程池中任务的异常，如果任务通过execute提交，那么出现异常会导致线程退出，大量的异常会导致线程重复创建引起性能问题，我们应该尽可能确保任务不出异常，同时设置默认的未捕获异常处理程序来兜底；如果任务通过submit提交意味着我们关心任务的执行结果，应该通过拿到的Future调用其get方法来获得任务运行结果和可能出现的异常，否则异常可能就被生吞了。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>关于在finally代码块中抛出异常的坑，如果在finally代码块中返回值，你觉得程序会以try或catch中返回值为准，还是以finally中的返回值为准呢？</li>\n<li>对于手动抛出的异常，不建议直接使用Exception或RuntimeException，通常建议复用JDK中的一些标准异常，比如<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html\">IllegalArgumentException</a>、<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html\">IllegalStateException</a>、<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html\">UnsupportedOperationException</a>，你能说说它们的适用场景，并列出更多常用异常吗？</li>\n</ol><p>不知道针对异常处理，你还遇到过什么坑，还有什么最佳实践的心得吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","comments":[{"had_liked":false,"id":202995,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1586099401,"is_pvip":true,"replies":[{"id":"75895","content":"👍🏻，你总结了比较重要的两点，JVM采用异常表控制try-catch的跳转逻辑；对于finally中的代码块其实是复制到try和catch中的return和throw之前的方式来处理的。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586136360,"ip_address":"","comment_id":202995,"utype":1}],"discussion_count":16,"race_medal":0,"score":"388133156041","product_id":100047701,"comment_content":"这篇文章收获很大，因为我们现在的系统就是用的统一异常处理，使用的就是老师提到的兜底异常，就是简单的分为业务异常和非业务异常，提示语不同而已。<br>试着回答下问题：<br>第一个问题：<br>肯定是以finally语句块为准。<br>原因：首先需要明白的是在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。其中，from 指针和 to 指针标示了该异常处理器所监控的范围，例如 try 代码块所覆盖的范围。target 指针则指向异常处理器的起始位置，例如 catch 代码块的起始位置；<br>当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。所以异常操作是一个非常耗费性能的操作；<br>finally 代码块的原理是复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中。所以不管是是正常还是异常执行，finally都是最后执行的，所以肯定是finally语句块中为准。<br><br>第二个问题：<br>IllegalArgumentException：不合法的参数异常，比如说限制不能为空或者有指定的发小范围，调用方没有按照规定传递参数，就可以抛出这个异常；<br>IllegalStateException：如果有状态流转的概念在里面（比如状态机），状态只能从A-&gt;B-&gt;C,若状态直接从A-&gt;C,就可以抛出该异常；<br>UnsupportedOperationException：不支持该操作异常，比如非抽象父类中有个方法，子类必须实现，父类中的方法就可以抛出次异常。老师在集合坑中提到的Arrays.asList 返回的 List 并不是我们期望的 java.util.ArrayList，而是 Arrays 的内部类 ArrayList。ArrayList 内部类继承自 AbstractList 类，并没有覆写父类的 add 方法，而父类中 add 方法的实现，就是抛出 UnsupportedOperationException。<br>","like_count":91,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490725,"discussion_content":"👍🏻，你总结了比较重要的两点，JVM采用异常表控制try-catch的跳转逻辑；对于finally中的代码块其实是复制到try和catch中的return和throw之前的方式来处理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586136360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188891,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/1b/7aa4d93d.jpg","nickname":"盒子","note":"","ucode":"2A95F1121109B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245690,"discussion_content":"对于finally中的代码块其实是复制到try和catch中的return和throw之前的方式来处理的。对于这句话可能还不够准确；下面看两个示例：\n\npublic static int t1 () {\n        int i = 1;\n        try {\n            return i;\n        }finally {\n            ++i;\n        }\n    }\n\npublic static int t2 () {\n        int i = 1;\n        try {\n            return i;\n        }finally {\n            return ++i;\n        }\n    }\n\nt1 方法返回的是 1， t2 方法返回的是 2； 原因是在进入 finally 代码块前，会记录返回结果，finally 对返回结果的操作不影响此前记录的值；但是如果 在 finally 中return 就会覆盖此前保存的返回值；","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1587691945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1188891,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/1b/7aa4d93d.jpg","nickname":"盒子","note":"","ucode":"2A95F1121109B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249823,"discussion_content":"public static void main(String[] args) {\n\n        System.out.println(t1());\n\n    }\n    public static User t1 () {\n        User user = new User();\n        user.setAge(12);\n        try {\n            return user;\n        }finally {\n            user.setName(&#34;zhangsan&#34;);\n        }\n    }\n\n\n输出：User{age=12, name=&#39;zhangsan&#39;}\n\n明白了吗？  int是基本数据类型，是值传递，你的t1中，i最后是2，但是1已经被返回回去了，并且是值返回并不是引用，因此你的t1方法测试本身是有问题的。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1587965381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":245690,"ip_address":""},"score":249823,"extra":""},{"author":{"id":1188891,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/1b/7aa4d93d.jpg","nickname":"盒子","note":"","ucode":"2A95F1121109B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":250168,"discussion_content":"感谢解答，我理解你的意思；其实我想指出，进入 finally 之前的return 的对象是缓存好的； 例如下面例子返回的还是\n\nUser{name=&#39;z3&#39;, age=12}\n\npublic static User t1 () {\n        User user = new User(&#34;z3&#34;,12);\n        try {\n            return user;\n        } finally {\n            user = new User(&#34;l4&#34;, 13);\n        }\n    }","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587995478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":249823,"ip_address":""},"score":250168,"extra":""},{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1188891,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/1b/7aa4d93d.jpg","nickname":"盒子","note":"","ucode":"2A95F1121109B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250422,"discussion_content":"是的，你这种写法，开发工具会提醒无效语句的，我说下我的理解，为啥这块会不生效，user变量本身其实是一个地址，也就是c语音的指针，本质上就是内存地址，也就是一个数字，在return的时候，user的地址被返回，被调用者接受，调用者此时就是这个指针，在finally中，你在给user赋值，此时user指向的地址也返回的那个已经完全不一样了，没有关系了，这就是finally语句看起来应该生效但没生效的原因。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1588001830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":250168,"ip_address":""},"score":250422,"extra":""}]},{"author":{"id":2002306,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erx6pib1rW5tReUYQzQmNJjjmecb7iasr9gf34IB45tXc5f2qksoqVhUkQHr08icTyBduiaVjy1sI7wKQ/132","nickname":"菜刀","note":"","ucode":"AABE26A96C2729","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291817,"discussion_content":"这不是深入理解Java虚拟机中的内容吗😄","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594962029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055054,"avatar":"https://static001.geekbang.org/account/avatar/00/10/19/4e/d411cfab.jpg","nickname":"一会","note":"","ucode":"4B1F0508ABFBCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223955,"discussion_content":"卧槽 牛逼  原谅本人没文化 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586263931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1055054,"avatar":"https://static001.geekbang.org/account/avatar/00/10/19/4e/d411cfab.jpg","nickname":"一会","note":"","ucode":"4B1F0508ABFBCB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224536,"discussion_content":"多在极客时间呆一呆，就有文化了😂","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586313936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223955,"ip_address":""},"score":224536,"extra":""}]},{"author":{"id":1194238,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/fe/988bf0d9.jpg","nickname":"空空如也","note":"","ucode":"342F3A2C8A3C11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222623,"discussion_content":"恐怖如斯 强","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586164117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1194238,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/fe/988bf0d9.jpg","nickname":"空空如也","note":"","ucode":"342F3A2C8A3C11","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222653,"discussion_content":"是斗破苍穹萧炎吗😂😂😂","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586166389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":222623,"ip_address":""},"score":222653,"extra":""}]},{"author":{"id":1528941,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/BCIyymNXUd0gicELBmOnzJptrXZM9Fo95w8nhzvyuibC8icCsrmSBAZBicfrRgLL71ZiaCWnxxaDtJ2hp3b3nWEsRUA/132","nickname":"Geek_6e3c24","note":"","ucode":"076F5E2C271BF2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392610,"discussion_content":"百度了一堆话  贴出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631070354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270612,"discussion_content":"高手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590029687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227883,"discussion_content":"👍👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586517360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226018,"discussion_content":"牛皮，牛皮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586415705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233750,"user_name":"扎紧绷带","can_delete":false,"product_type":"c1","uid":1316667,"ip_address":"","ucode":"4EDB38E21C12BB","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/3b/37bcd31e.jpg","comment_is_top":false,"comment_ctime":1594436423,"is_pvip":false,"replies":[{"id":"86321","content":"这是一个很常见的需求，使用HttpServletRequestWrapper即可，参考 https:&#47;&#47;github.com&#47;JosephZhu1983&#47;appinfocenter&#47;blob&#47;master&#47;client&#47;src&#47;main&#47;java&#47;me&#47;josephzhu&#47;appinfocenter&#47;client&#47;DumpFilter.java","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1594520884,"ip_address":"","comment_id":233750,"utype":1}],"discussion_count":1,"race_medal":0,"score":"87493782343","product_id":100047701,"comment_content":"老师，为了便于定位异常请求bug，我希望url请求后端出现异常后，框架拦截打印出请求的参数信息，因为body里的参数在流中，只能消费一次，想要在出错后打印，必须要提前复制出一份保存。老师有什么好的实践吗？","like_count":21,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501153,"discussion_content":"这是一个很常见的需求，使用HttpServletRequestWrapper即可，参考 https://github.com/JosephZhu1983/appinfocenter/blob/master/client/src/main/java/me/josephzhu/appinfocenter/client/DumpFilter.java","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594520884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203298,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1586168045,"is_pvip":false,"replies":[{"id":"75963","content":"嗯，原因是：<br>1、id是数字型，传入的1,2,3,4,5,6,7,8,9的并不能转换为数字，所以截断为1（第一个逗号之前的数字）<br>2、zhangsan,lisi,wangwu整个当做一个字符串来查询了，所以数据库中根本查不到name=&#39;zhangsan,lisi,wangwu&#39;这样的记录","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586179088,"ip_address":"","comment_id":203298,"utype":1}],"discussion_count":3,"race_medal":0,"score":"70305644781","product_id":100047701,"comment_content":"遇到一个坑(也可以说不理解)，和该篇文章没关系，反馈一下<br><br>mysql 占位符问题<br>prepare sqltpl from &#39;select id,name from table1 where id in (?)&#39;;<br>set @a=&#39;1,2,3,4,5,6,7,8,9&#39;;<br>execute  sqltpl using @a;<br><br>结果：只输出第一条符合条件的记录<br><br>prepare sqltpl from &#39;select name from table1 where name in (?)&#39;;<br>set @a=&#39;zhangsan,lisi,wangwu&#39;;<br>execute  sqltpl using @a;<br>结果没有记录","like_count":17,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490822,"discussion_content":"嗯，原因是：\n1、id是数字型，传入的1,2,3,4,5,6,7,8,9的并不能转换为数字，所以截断为1（第一个逗号之前的数字）\n2、zhangsan,lisi,wangwu整个当做一个字符串来查询了，所以数据库中根本查不到name=&amp;#39;zhangsan,lisi,wangwu&amp;#39;这样的记录","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586179088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":582789,"discussion_content":"这几天看下来老师真的很有耐心","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659676115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":490822,"ip_address":"广东"},"score":582789,"extra":""}]},{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222879,"discussion_content":"soga,多谢老师","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586179171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202434,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1585988097,"is_pvip":false,"replies":[{"id":"75613","content":"创建异常的时候一次性fillInStackTrace了，除非这样：<br><br>BusinessException ex =  Exceptions.ORDEREXISTS;<br>ex.fillInStackTrace();<br>throw ex;<br><br><br>（这样同样不是线程安全的）","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585995225,"ip_address":"","comment_id":202434,"utype":1}],"discussion_count":5,"race_medal":0,"score":"61715530241","product_id":100047701,"comment_content":"老师，关于 千万别把异常定义为静态变量，麻烦分析下为什么cancelOrderRight抛出的异常信息指向createOrderWrong所在的行~","like_count":14,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490583,"discussion_content":"创建异常的时候一次性fillInStackTrace了，除非这样：\n\nBusinessException ex =  Exceptions.ORDEREXISTS;\nex.fillInStackTrace();\nthrow ex;\n\n\n（这样同样不是线程安全的）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585995225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5d/78/f011d586.jpg","nickname":"遇见阳光","note":"","ucode":"378E5D37B3CD0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221412,"discussion_content":"感觉没看懂啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586007808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1203576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5d/78/f011d586.jpg","nickname":"遇见阳光","note":"","ucode":"378E5D37B3CD0E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227543,"discussion_content":"就是Exceptions.ORDEREXISTS异常初始化的时候已经定死了堆栈异常是指向at org.geekbang.time.commonmistakes.exception.predefinedexception.PredefinedExceptionController.createOrderWrong(PredefinedExceptionController.java:56)这一行的，以后无论是哪里（cancelOrder方法）抛出这个异常，在日志中输出的堆栈异常都与第一次一样。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1586499313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":221412,"ip_address":""},"score":227543,"extra":""}]},{"author":{"id":1876823,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/X4ib36ADEvj76XaKD4OUY9k15KqWCAVCwibPicBxz6BBUfDrVolpYInn8zFOw3JBPtVw3L4Lkibaf2eLPemwGKzAXA/132","nickname":"Geek_427d0c","note":"","ucode":"D7A04138C4B8CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399134,"discussion_content":"我把这个代码放在了一个Java文件里执行，并没有出现交替的情况。就是很正常的栈信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632910236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079495,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","nickname":"新世界","note":"","ucode":"4473DC1505F158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379347,"discussion_content":"static 在类加载器的时候已经初始化了固定的异常，并且在使用中不会改变，所以无论如何抛出，最后就只是第一次初始化时候的异常，如果大家不明白，我举个最简单的例子\n在 PredefinedExceptionController中 添加一个静态块\nstatic  {\n        Exceptions exceptions = new Exceptions();\n    }\n\n\n这时候会在加载类的时候初始化： \n    public static BusinessException ORDER_EXISTS = new BusinessException(&#34;订单已存在&#34;,3001); 这句话，这个异常就会报创建对象异常，如下\n\n2021-06-16 18:10:58 [com.xs.micro.study.exception.ExceptionTestController] :36-[ERROR] [service:study-base,TraceId:] cancelOrder got error\ncom.xs.micro.study.exception.BusinessException: 订单已存在\n\tat com.xs.micro.study.exception.Exceptions.<clinit>(Exceptions.java:13)\n\tat com.xs.micro.study.exception.ExceptionTestController.<clinit>(ExceptionTestController.java:22)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:200)\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:87)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1312)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1214)\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623838340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202448,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1585990082,"is_pvip":false,"replies":[{"id":"75608","content":"不错","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585993670,"ip_address":"","comment_id":202448,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53125597634","product_id":100047701,"comment_content":"IllegalArgumentException: 入参错误，比如参数类型int输入string。<br>IllegalStateException: 状态错误，比如订单已经支付完成，二次请求支付接口。<br>UnsupportedOperationException: 不支持操作错误，比如对一笔不能退款的订单退款。<br>其他异常<br>SecurityException: 权限错误，比如未登陆用户调用修改用户信息接口。","like_count":13,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490586,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585993670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202809,"user_name":"终结者999号","can_delete":false,"product_type":"c1","uid":1055854,"ip_address":"","ucode":"33ADE61580B6DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","comment_is_top":false,"comment_ctime":1586072540,"is_pvip":true,"replies":[{"id":"75794","content":"就是Throwable的stacktrace只是在其new出来的时候才初始化（调用fillInStackTrace方法）是一次性的（除非你手动调用那个方法），而非getStackTrace的时候去获得stacktrace，毕竟我们关心的是异常抛出时的栈。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586077045,"ip_address":"","comment_id":202809,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31650843612","product_id":100047701,"comment_content":"关于行者的问题，请老师再解释一下可以吗？貌似没有看懂那个回复，什么叫一次性fillstacktrace？","like_count":8,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490692,"discussion_content":"就是Throwable的stacktrace只是在其new出来的时候才初始化（调用fillInStackTrace方法）是一次性的（除非你手动调用那个方法），而非getStackTrace的时候去获得stacktrace，毕竟我们关心的是异常抛出时的栈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586077045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079495,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","nickname":"新世界","note":"","ucode":"4473DC1505F158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379349,"discussion_content":"static 在类加载器的时候已经初始化了固定的异常，并且在使用中不会改变，所以无论如何抛出，最后就只是第一次初始化时候的异常，如果大家不明白，我举个最简单的例子\n在 PredefinedExceptionController中 添加一个静态块\nstatic {\n        Exceptions exceptions = new Exceptions();\n    }\n\n\n这时候会在加载类的时候初始化：\n    public static BusinessException ORDER_EXISTS = new BusinessException(&#34;订单已存在&#34;,3001); 这句话，这个异常就会报创建对象异常，如下\n\n2021-06-16 18:10:58 [com.xs.micro.study.exception.ExceptionTestController] :36-[ERROR] [service:study-base,TraceId:] cancelOrder got error\ncom.xs.micro.study.exception.BusinessException: 订单已存在\nat com.xs.micro.study.exception.Exceptions.<clinit>(Exceptions.java:13)\nat com.xs.micro.study.exception.ExceptionTestController.<clinit>(ExceptionTestController.java:22)\nat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\nat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\nat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\nat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\nat org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:200)\nat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:87)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1312)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1214)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623838693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202437,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1585988796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23060825276","product_id":100047701,"comment_content":"现在出问题就是瞎子，一点一点的日志的打，上线，哎，这哪是个合格的RD呀","like_count":6},{"had_liked":false,"id":202965,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":1166969,"ip_address":"","ucode":"09E29168D53178","user_header":"https://static001.geekbang.org/account/avatar/00/11/ce/79/673f4268.jpg","comment_is_top":false,"comment_ctime":1586094529,"is_pvip":true,"replies":[{"id":"75890","content":"仔细观察一下栈，数据串了，取消订单的异常栈显示了下单的方法","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586133746,"ip_address":"","comment_id":202965,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14470996417","product_id":100047701,"comment_content":"老师，看不懂那个异常定义为静态变量的例子，异常打印的是堆栈信息，堆栈信息必须是对象是这个意思吗？","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490718,"discussion_content":"仔细观察一下栈，数据串了，取消订单的异常栈显示了下单的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586133746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202319,"user_name":"努力奋斗的Pisces","can_delete":false,"product_type":"c1","uid":1336441,"ip_address":"","ucode":"AD4F8909CF190A","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/79/f1e1ca76.jpg","comment_is_top":false,"comment_ctime":1585967638,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14470869526","product_id":100047701,"comment_content":"1.得看finally里面是怎么处理的了，除非finally没有执行到，或者是finally里面报错了，不然都是按照finally里面的返回值做最终的返回吧","like_count":3},{"had_liked":false,"id":202268,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1585952273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14470854161","product_id":100047701,"comment_content":"订单存在异常，这个例子实际开发中真需要区分吗？个人觉得无效参数的例子更好些","like_count":3},{"had_liked":false,"id":301013,"user_name":"walle斌","can_delete":false,"product_type":"c1","uid":1062848,"ip_address":"","ucode":"0DB3243004951F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","comment_is_top":false,"comment_ctime":1625485184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920452480","product_id":100047701,"comment_content":"没有回答老师的问题，而是对异常处理有一些其他看法<br>1、log.error保留现场，log.error(&quot;xxx error:&quot; + reqString,e)<br>2、以标准返回，返回错误，供上层处理，按照标准返回的正确与与否返回<br>3、标准返回，除了一般的是否正确，错误码，错误信息，增加如下2点，方便快速排查问题<br>1）、详细错误，附带错误的前200【可配置】信息，且对外网关可以考虑过滤此字段<br>2）、全链路跟踪字段<br>直接把全链路跟踪字段暴露出来，对于异常排场加速排查。而且有了详细错误字段，其实一眼就能看出咋回事了，一般的错误。","like_count":1},{"had_liked":false,"id":207682,"user_name":"yan_12345","can_delete":false,"product_type":"c1","uid":1904542,"ip_address":"","ucode":"7F2D3230C1621A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/t1IeXCJODYdTt2RPGqx2zDjVX4N1FrxCWqQFfico2wVfetel8vcQYax1ASJHagACzdGCiaUbzlbjjfwtZa5G5TSQ/132","comment_is_top":false,"comment_ctime":1587136278,"is_pvip":false,"replies":[{"id":"77568","content":"有意义，把偏向于底层的异常转换为高层异常。换句话说把偏向于内部处理自己才能理解的异常转换为一个外部可以理解的异常抛出。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587167755,"ip_address":"","comment_id":207682,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882103574","product_id":100047701,"comment_content":"老师，在业务代码当中，在catch之后，在什么情况下需要重新抛出新的异常，这样做有什么意义和作用？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492208,"discussion_content":"有意义，把偏向于底层的异常转换为高层异常。换句话说把偏向于内部处理自己才能理解的异常转换为一个外部可以理解的异常抛出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587167755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205346,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1586595703,"is_pvip":false,"replies":[{"id":"76708","content":"有收货就好。statis-&gt;static。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586603083,"ip_address":"","comment_id":205346,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881562999","product_id":100047701,"comment_content":"好文，目前生产环境就存在出现异常只向上返回e.getMessage()，导致出现预期外的问题时一脸懵逼，这块日后一定要注意。statis Exception这块学习到了，对日后闭坑有很大帮助。通过这篇文章还学到了try-with-resources语法，收货颇丰。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491454,"discussion_content":"有收货就好。statis-&amp;gt;static。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586603083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204755,"user_name":"skying","can_delete":false,"product_type":"c1","uid":1041865,"ip_address":"","ucode":"E7CFF50AB64BB1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","comment_is_top":false,"comment_ctime":1586450012,"is_pvip":true,"replies":[{"id":"76521","content":"异常处理程序只是作为保底出了异常可以自己来处理，不能防止异常产生。<br><br>文中修复方式有 2 步，第一步是比较重要的：以 execute 方法提交到线程池的异步任务，最好在任务内部做好异常处理；设置自定义的异常处理程序作为保底，比如在声明线程池时自定义线程池的未捕获异常处理程序：","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586479519,"ip_address":"","comment_id":204755,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5881417308","product_id":100047701,"comment_content":"你好，关于 提交到线程池的线程发生异常的场景。<br>我本地环境 添加了UncaughtExceptionHandler，但后续的5次循环中，打印的线程还是test1.<br><br>本地环境:spring boot2.2.5+undertow","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491275,"discussion_content":"异常处理程序只是作为保底出了异常可以自己来处理，不能防止异常产生。\n\n文中修复方式有 2 步，第一步是比较重要的：以 execute 方法提交到线程池的异步任务，最好在任务内部做好异常处理；设置自定义的异常处理程序作为保底，比如在声明线程池时自定义线程池的未捕获异常处理程序：","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586479519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228591,"discussion_content":"可以完整帖一下你的代码和输出，输出test1是对的，老的线程是test0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586565407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228145,"discussion_content":"是execute还是submit?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586526480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","nickname":"skying","note":"","ucode":"E7CFF50AB64BB1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227362,"discussion_content":"@作者，你好，在设置自定义的异常处理程序作为保底后，后面的线程是从线程池中取 还是 创建新的 线程呢\n就这一点 我不太理解，本地demo出的结果和你的专栏上的 不一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586485684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350733,"user_name":"Geek_d3928c","can_delete":false,"product_type":"c1","uid":2450893,"ip_address":"","ucode":"7CB09FD1F7CB23","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/L8EpqHoAnmvkzCIsdOkv5QvhIzu5tMaF2FDusXShqukv5ZBkS8DbicWaErjnYydibiaqBrs70wQ8P6axvC2FbWpbQ/132","comment_is_top":false,"comment_ctime":1657123987,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657123987","product_id":100047701,"comment_content":"try-with-resources语句能够帮你自动调用资源的close()函数关闭资源不用到finally块.,在try关键字后面的( )里new一些需要自动关闭的资源。","like_count":1},{"had_liked":false,"id":332415,"user_name":"花下眠","can_delete":false,"product_type":"c1","uid":1183854,"ip_address":"","ucode":"F14C138BF7AEA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/6e/a21968a9.jpg","comment_is_top":false,"comment_ctime":1643242051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643242051","product_id":100047701,"comment_content":"异常以为自己理解了，看完这节课，收获满满，瑞思拜<br>1、切记生吞异常，并且记录堆栈信息<br>2、异常消息有意义<br>3、异常覆盖<br>4、线程池异常，为线程起名字好定位问题，注意异常后线程是否退出等","like_count":0},{"had_liked":false,"id":319120,"user_name":"刘志鹏","can_delete":false,"product_type":"c1","uid":2546103,"ip_address":"","ucode":"FBA7FA3A392D22","user_header":"","comment_is_top":false,"comment_ctime":1635595999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635595999","product_id":100047701,"comment_content":"我的异常处理通常这么做：1： 自定义异常，包括中英文message, code。2： service手动抛出业务异常， controller 不捕获； 3：框架统一处理。<br><br>这样返回的message，其实也是service抛出的异常消息。  ","like_count":0},{"had_liked":false,"id":315263,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1633773929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633773929","product_id":100047701,"comment_content":"为什么我测试时，execute 方式即使加了异常捕获处理，线程还是会退出重建？","like_count":0},{"had_liked":false,"id":314239,"user_name":"Geek_427d0c","can_delete":false,"product_type":"c1","uid":1876823,"ip_address":"","ucode":"D7A04138C4B8CB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/X4ib36ADEvj76XaKD4OUY9k15KqWCAVCwibPicBxz6BBUfDrVolpYInn8zFOw3JBPtVw3L4Lkibaf2eLPemwGKzAXA/132","comment_is_top":false,"comment_ctime":1632908552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632908552","product_id":100047701,"comment_content":"不知道是什么原因，下述代码，没有出现老师的静态Exception的现象。打印的error堆栈信息看到还是很正常的。<br>package com.example.demo;<br><br>import lombok.extern.slf4j.Slf4j;<br><br>&#47;**<br> * Created by wensi on 2021-09-09<br> *&#47;<br>@Slf4j<br>public class Test {<br>    public static BusinessException ORDEREXISTS = new BusinessException(&quot;订单已经存在&quot;);<br><br>    public static void main(String[] args) throws InterruptedException {<br>        new Test().wrong();<br>    }<br><br>    public void wrong() {<br>        try {<br>            createOrderWrong();<br>        } catch (Exception ex) {<br>            log.error(&quot;createOrder got error&quot;, ex);<br>        }<br>        try {<br>            cancelOrderWrong();<br>        } catch (Exception ex) {<br>            log.error(&quot;cancelOrder got error&quot;, ex);<br>        }<br>    }<br><br>    private void createOrderWrong() { &#47;&#47;这里有问题<br>        throw Test.ORDEREXISTS;<br>    }<br><br>    private void cancelOrderWrong() { &#47;&#47;这里有问题<br>        throw Test.ORDEREXISTS;<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":309118,"user_name":"Vince","can_delete":false,"product_type":"c1","uid":2689860,"ip_address":"","ucode":"53CB603F3034EC","user_header":"https://static001.geekbang.org/account/avatar/00/29/0b/44/c6487b93.jpg","comment_is_top":false,"comment_ctime":1629948953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629948953","product_id":100047701,"comment_content":"真好，受益匪浅，直接就读了2遍，我还得和小伙伴分享一下收获","like_count":0},{"had_liked":false,"id":264970,"user_name":"六石","can_delete":false,"product_type":"c1","uid":2302562,"ip_address":"","ucode":"D0891B58CA5EB1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoqJGUoKZDx52g82wux57lgo1qH64wGRIumic6Twzb94hEmzmvdeNdw5ibiaMbicOGzlsLt9pXFQJbI7w/132","comment_is_top":false,"comment_ctime":1606724339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606724339","product_id":100047701,"comment_content":"直接把异常完全抛出很多时候会有安全问题吧，攻击者可以根据异常类型和描述进行攻击，有时候这种方式并不好。所以有些公司内部的规范中明确要求针对几种特殊的异常不允许直接抛出，最好的方式是记录日志，日志中进行说明。","like_count":0},{"had_liked":false,"id":248390,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1600144817,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1600144817","product_id":100047701,"comment_content":"总结：<br>1、业务异常建议自行捕获，全局异常最好是用于兜底。<br>2、不要生吞异常。<br>3、小心finally异常覆盖，可能会导致你对问题的误判，可以使用try-with-resources破解，try-with-resources会suppressedfinally中的异常。<br>4、异常栈是跟据当前上下文生成，不可用static定义异常，否则会导致异常栈固化，从而影响问题定位（认为是走到其他分支了）。<br>5、线程池execute抛异常如果不处理，会导致线程退出，然后线程池按core线程数据重建缺失的线程。如果一直抛异常导致重建，那线程池跟本就起不到线池重用的作用。submit抛异常如果不处理，会被生吞，get时可以捕获到异常。<br><br>问题：<br>1、finally return会覆盖return结果，因为会重写一次栈返回地址的值。<br>2、精确的异常能方便定位问题。","like_count":0},{"had_liked":false,"id":245441,"user_name":"Geek_fe5e8a","can_delete":false,"product_type":"c1","uid":2103563,"ip_address":"","ucode":"B4CC300397BD6A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dgox0m94vr6w2Vxk0N6651pyL5wKWicqgwIxU9iahlIn5LKeFfQJDjzUoQKM8WNibS7Yuxyulmic1Xxfia5ibFc6ia0Hw/132","comment_is_top":false,"comment_ctime":1598945861,"is_pvip":false,"replies":[{"id":"90346","content":"可以看下官网的介绍，专栏是说坑点的，并不是介绍各种知识点","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1599019456,"ip_address":"","comment_id":245441,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598945861","product_id":100047701,"comment_content":"老师能不能讲讲lombok的注解@SneakyThrows ","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504880,"discussion_content":"可以看下官网的介绍，专栏是说坑点的，并不是介绍各种知识点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599019456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241446,"user_name":"李和桃","can_delete":false,"product_type":"c1","uid":1015877,"ip_address":"","ucode":"97E66953070EE0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/45/d719f7df.jpg","comment_is_top":false,"comment_ctime":1597298190,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597298190","product_id":100047701,"comment_content":"1、以finally的返回值为准。此处引出另一个异常点，在try里面返回的值在finally中被修改，返回的是try中的结果还是finally的？答案是try。<br>2、异常使用如IllegalArgumentException、IllegalStateException、UnsupportedOperationException是为了更精细化异常的类型。如IllegalArgumentException是非法参数异常，可以在校验参数时使用。IllegalStateException可以在当前非正常状态下抛出。UnsupportedOperationException是在不支持某个操作时抛出，如Arrays.asList()的add\\remove等方法","like_count":0,"discussions":[{"author":{"id":1750549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","nickname":"ImYours°","note":"","ucode":"51F653129034C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376036,"discussion_content":"你说的第一个没有get到，有例子说明吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621935359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235706,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1595156196,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595156196","product_id":100047701,"comment_content":"提交线程池的任务代码中使用到redission代码  new ThreadFactoryBuilder();<br>可以使用自定义工厂类替换<br>    class MySelfThreadFactory implements ThreadFactory {<br>        String namePrefix;<br>        AtomicInteger threadNumber = new AtomicInteger(1);<br><br>        public MySelfThreadFactory(String namePrefix){<br>            this.namePrefix = namePrefix;<br>        }<br>        @Override<br>        public Thread newThread(Runnable r) {<br>            Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement());<br>            return t;<br>        }<br>    }<br>","like_count":0,"discussions":[{"author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305193,"discussion_content":"Guava包里面也有这个builder的，看api与文章中用的一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599813803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235700,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1595153935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595153935","product_id":100047701,"comment_content":"为啥提交线程池的任务那部分代码需要用到redis jar包的东西.<br>还得安装个redis = =","like_count":0},{"had_liked":false,"id":235339,"user_name":"青山","can_delete":false,"product_type":"c1","uid":1131070,"ip_address":"","ucode":"749BAD1834AC0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/3e/1d9c257f.jpg","comment_is_top":false,"comment_ctime":1594978090,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1594978090","product_id":100047701,"comment_content":"其实使用全局捕获异常，转换为自定义异常 不需要JDK 中的一些标准异常去操作。","like_count":0},{"had_liked":false,"id":232666,"user_name":"Geek_96815d","can_delete":false,"product_type":"c1","uid":2011773,"ip_address":"","ucode":"8D3CAF4AE9831A","user_header":"","comment_is_top":false,"comment_ctime":1594083589,"is_pvip":false,"replies":[{"id":"85903","content":"程序中断是指？","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1594100203,"ip_address":"","comment_id":232666,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594083589","product_id":100047701,"comment_content":"execute 使用执行出现异常，程序依然没有中断","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500730,"discussion_content":"程序中断是指？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594100203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223796,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1591182568,"is_pvip":false,"replies":[{"id":"82417","content":"1 抛出异常需要设置消息 2 不建议捕获范围这么大的异常","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1591188014,"ip_address":"","comment_id":223796,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591182568","product_id":100047701,"comment_content":"   @GetMapping(&quot;wrong3&quot;)<br>    public void wrong3(@RequestParam(&quot;orderId&quot;) String orderId) {<br>        try {<br>            readFile();<br>        } catch (Exception e) {<br>            log.error(&quot;文件读取错误&quot;, e);<br>            throw new RuntimeException();<br>        }<br>    }<br><br>---<br>老师我在项目中发现这个也是错的，是因为用 `Exception` 代替了IOException吗？<br>还是因为抛出异常 throw new RuntimeException() 这里没有任何提示消息，所以是错误的用法？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497242,"discussion_content":"1 抛出异常需要设置消息 2 不建议捕获范围这么大的异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591188014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218053,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1589704790,"is_pvip":false,"replies":[{"id":"80654","content":"是","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1589716717,"ip_address":"","comment_id":218053,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589704790","product_id":100047701,"comment_content":"老师，把异常定义为静态变量后，cancelOrderWrong的异常堆栈却是createOrderWrong的，是因为createOrderWrong的异常信息是先调用的，由于异常是staic的，导致之后所有该异常堆栈都是createOrderWrong的吗？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495336,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589716717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215555,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1589015681,"is_pvip":false,"replies":[{"id":"79794","content":"偏向底层的服务使用CE还是有好处的，这个这是一个语法，还是看用的人怎么去用好。任何技术，强管控有强管控的好处，弱管控有弱管控的好处，没有绝对对错。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1589017523,"ip_address":"","comment_id":215555,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1589015681","product_id":100047701,"comment_content":"老师，我想请假下你对Java中的Checked Exception和UnChecked Exception的看法？我个人编程习惯上不喜欢使用Checked Exception，我认为对编程不友好，而且无论出现什么异常都是对正常的逻辑造成影响，好像Checked Exception相对于UnChecked Exception没啥优点，有的话也就是告诉调用者有异常而已，但是异常还是得处理==、","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494475,"discussion_content":"偏向底层的服务使用CE还是有好处的，这个这是一个语法，还是看用的人怎么去用好。任何技术，强管控有强管控的好处，弱管控有弱管控的好处，没有绝对对错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589017523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181192,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","nickname":"Seven.Lin澤耿","note":"","ucode":"4CAB732CD6F149","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261878,"discussion_content":"多谢老师，确实是，存在即是合理的。各个框架也有自己的风格，Spring就比较对编程友好，使用的比较多的UE","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589017900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209570,"user_name":"yan_12345","can_delete":false,"product_type":"c1","uid":1904542,"ip_address":"","ucode":"7F2D3230C1621A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/t1IeXCJODYdTt2RPGqx2zDjVX4N1FrxCWqQFfico2wVfetel8vcQYax1ASJHagACzdGCiaUbzlbjjfwtZa5G5TSQ/132","comment_is_top":false,"comment_ctime":1587567335,"is_pvip":false,"replies":[{"id":"78216","content":"把偏向于底层的异常转换为高层异常。换句话说把偏向于内部处理自己才能理解的异常转换为一个外部可以理解的异常抛出。<br><br>异常是否有用和是否是受检异常没关系，现在看来受检异常的设定不一定是一个正确的设计。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587599987,"ip_address":"","comment_id":209570,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587567335","product_id":100047701,"comment_content":"老师，请教一个问题，在平常的业务代码当中，看到在catch异常之后，会抛出运行时异常RuntimeException，这种异常不是检查异常，不需要强制捕获，那重新抛出这种异常有什么作用，","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492834,"discussion_content":"把偏向于底层的异常转换为高层异常。换句话说把偏向于内部处理自己才能理解的异常转换为一个外部可以理解的异常抛出。\n\n异常是否有用和是否是受检异常没关系，现在看来受检异常的设定不一定是一个正确的设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587599987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208591,"user_name":"梁铁山","can_delete":false,"product_type":"c1","uid":1233214,"ip_address":"","ucode":"36249D99DD8D5D","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/3e/77c6ba5e.jpg","comment_is_top":false,"comment_ctime":1587387638,"is_pvip":false,"replies":[{"id":"77933","content":"不太明白你的问题，“如果 MbeUserproduct 这个实体中的属性有@NotNull 等注解，那么通过添加@Valid可以在全局异常中捕获到属性异常信息（400）” 这种处理方式有什么问题吗？","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587388929,"ip_address":"","comment_id":208591,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1587387638","product_id":100047701,"comment_content":"老师好，我们项目是用SpringMVC的，也是使用统一异常处理，在实际项目中遇到了个比较棘手的问题。RespEntity&lt;Map&lt;String, String&gt;&gt; create(@RequestBody @Valid Useproduct useproduct, HttpServletRequest request) throws Exception { 。。。}  如果 MbeUserproduct 这个实体中的属性有@NotNull 等注解，那么通过添加@Valid可以在全局异常中捕获到属性异常信息（400）；如果属性中没有添加此类的注解，那么就不会进入全局的异常处理类中，前端虽然会收到400的响应状态，但是没有具体的错误信息。<br><br>老师，对于这类问题该怎么处理！","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492528,"discussion_content":"不太明白你的问题，“如果 MbeUserproduct 这个实体中的属性有@NotNull 等注解，那么通过添加@Valid可以在全局异常中捕获到属性异常信息（400）” 这种处理方式有什么问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587388929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241229,"discussion_content":"最好贴一下完整代码，直接在底层就抛出的异常，是什么异常呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587396618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1233214,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d1/3e/77c6ba5e.jpg","nickname":"梁铁山","note":"","ucode":"36249D99DD8D5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240881,"discussion_content":"就是实体里面的属性如果没有添加@NotNull等注解的话，那么异常无法在全局异常类里面捕获，直接在底层就抛出了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587390615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204953,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1586499333,"is_pvip":false,"replies":[{"id":"76596","content":"就像你方案一说的，理论上如果异常、DTO和API都定义在一个jar包里面，客户端服务端共享，那么客户端完全是可以抛出这样的自定义异常的，dubbo我不是很熟悉，你可以研究一下，我觉得dubbo应该可以自动实现，而不是需要你在ExceptionFilter里面自己去这么实现（看 https:&#47;&#47;github.com&#47;apache&#47;dubbo&#47;blob&#47;47ee52d122fb6f0462ed99530cfe462c591feac8&#47;dubbo-rpc&#47;dubbo-rpc-api&#47;src&#47;main&#47;java&#47;org&#47;apache&#47;dubbo&#47;rpc&#47;filter&#47;ExceptionFilter.java 中的确也是这样实现的）。<br><br>我比较建议不要细化定义这么多服务端自己的异常，对于RPC区分业务异常和系统异常足够了，定义两个大类即可","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586504268,"ip_address":"","comment_id":204953,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1586499333","product_id":100047701,"comment_content":"老师，关于java微服务之间通过rpc调用的异常处理问题，请教下，先说声谢谢。<br>我们使用了dubbo作为rpc调用的框架，但是微服务A调用微服务B时抛出了业务异常（比如xxxBusinessException），<br>这些异常都是微服务B自定义的（xxxBusinessException extends ApplicationException，而ApplicationException是extends RuntimeException），<br>但是返回到微服务A时，都被转成了RuntimeException。经查，是因为dubbo框架中通过ExceptionFilter把异常进行了处理，防止客户端无法识别而报错。<br>但是我其实想要的是这些异常里面的errorCode和errorMsg，现在都没有了。我现在有两种优化思路：<br>1. 微服务A和B都依赖这个ApplicationException，然后重写dubbo框架中的ExceptionFilter，抛出ApplicationException，<br>这样微服务A就可以通过这个异常获取到errorCode和errorMsg等信息；<br>2. 把RPC的返回结果由返回业务DTO，改成返回一个标准的APIResponse（即{&quot;success&quot;: false, &quot;data&quot;: 原来的业务DTO， &quot;errorCode&quot;：1111, &quot;errorMsg&quot;: &quot;xxxx&quot;}）;<br><br>老师觉得如何，有什么更好的行业实践么<br>","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491336,"discussion_content":"就像你方案一说的，理论上如果异常、DTO和API都定义在一个jar包里面，客户端服务端共享，那么客户端完全是可以抛出这样的自定义异常的，dubbo我不是很熟悉，你可以研究一下，我觉得dubbo应该可以自动实现，而不是需要你在ExceptionFilter里面自己去这么实现（看 https://github.com/apache/dubbo/blob/47ee52d122fb6f0462ed99530cfe462c591feac8/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/ExceptionFilter.java 中的确也是这样实现的）。\n\n我比较建议不要细化定义这么多服务端自己的异常，对于RPC区分业务异常和系统异常足够了，定义两个大类即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586504268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242455,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","nickname":"天天向上","note":"","ucode":"0CCCA6F4DCC480","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267995,"discussion_content":"dubbo的对外暴露的接口上如果声明了xxxBusinessException异常，那么在调用方式可以拿到这个真实的异常信息的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589721487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204952,"user_name":"大大大熊myeh","can_delete":false,"product_type":"c1","uid":1139413,"ip_address":"","ucode":"4832C2E7CEB151","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","comment_is_top":false,"comment_ctime":1586499181,"is_pvip":false,"replies":[{"id":"76587","content":"你的理解没错，不过，文中贴出的代码部分已经足以说明问题<br><br>cancelOrder got error 这个提示对应栈中的 PredefinedExceptionController.createOrderWrong方法，可以看到错乱<br><br>[14:05:25.782] [http-nio-45678-exec-1] [ERROR] [.c.e.d.PredefinedExceptionController:25  ] - cancelOrder got error<br>org.geekbang.time.commonmistakes.exception.demo2.BusinessException: 订单已经存在<br>  at org.geekbang.time.commonmistakes.exception.demo2.Exceptions.&lt;clinit&gt;(Exceptions.java:5)<br>  at org.geekbang.time.commonmistakes.exception.demo2.PredefinedExceptionController.createOrderWrong(PredefinedExceptionController.java:50)<br>  at org.geekbang.time.commonmistakes.exception.demo2.PredefinedExceptionController.wrong(PredefinedExceptionController.java:18)<br><br>留言区貌似不支持md","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586503101,"ip_address":"","comment_id":204952,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586499181","product_id":100047701,"comment_content":"关于“把异常定义为静态变量”的错误示例，建议把堆栈贴全，不要仅贴下半部分，可能是水平原因，我是运行了一下您的代码才理解后面的那段解释。<br><br>其实您想说的是，如果把异常定义为静态变量，那么以后每次调用这个静态变量的异常，它的堆栈信息都是第一次调用该异常时的堆栈信息，会引起排查时的很大困难。<br><br>（顺便测试一下留言的markdown）<br><br>````java<br>14:06:35.916 [main] ERROR org.geekbang.time.commonmistakes.exception.predefinedexception.PredefinedExceptionController - createOrder got error<br>org.geekbang.time.commonmistakes.exception.predefinedexception.BusinessException: 订单已经存在<br>\tat org.geekbang.time.commonmistakes.exception.predefinedexception.Exceptions.&lt;clinit&gt;(Exceptions.java:5)<br>\tat org.geekbang.time.commonmistakes.exception.predefinedexception.PredefinedExceptionController.createOrderWrong(PredefinedExceptionController.java:56)<br>\tat org.geekbang.time.commonmistakes.exception.predefinedexception.PredefinedExceptionController.main(PredefinedExceptionController.java:29)<br>14:06:35.919 [main] ERROR org.geekbang.time.commonmistakes.exception.predefinedexception.PredefinedExceptionController - cancelOrder got error<br>org.geekbang.time.commonmistakes.exception.predefinedexception.BusinessException: 订单已经存在<br>\tat org.geekbang.time.commonmistakes.exception.predefinedexception.Exceptions.&lt;clinit&gt;(Exceptions.java:5)<br>\tat org.geekbang.time.commonmistakes.exception.predefinedexception.PredefinedExceptionController.createOrderWrong(PredefinedExceptionController.java:56)<br>\tat org.geekbang.time.commonmistakes.exception.predefinedexception.PredefinedExceptionController.main(PredefinedExceptionController.java:29)<br>````<br>","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491335,"discussion_content":"你的理解没错，不过，文中贴出的代码部分已经足以说明问题\n\ncancelOrder got error 这个提示对应栈中的 PredefinedExceptionController.createOrderWrong方法，可以看到错乱\n\n[14:05:25.782] [http-nio-45678-exec-1] [ERROR] [.c.e.d.PredefinedExceptionController:25  ] - cancelOrder got error\norg.geekbang.time.commonmistakes.exception.demo2.BusinessException: 订单已经存在\n  at org.geekbang.time.commonmistakes.exception.demo2.Exceptions.&amp;lt;clinit&amp;gt;(Exceptions.java:5)\n  at org.geekbang.time.commonmistakes.exception.demo2.PredefinedExceptionController.createOrderWrong(PredefinedExceptionController.java:50)\n  at org.geekbang.time.commonmistakes.exception.demo2.PredefinedExceptionController.wrong(PredefinedExceptionController.java:18)\n\n留言区貌似不支持md","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586503101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}