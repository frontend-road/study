{"id":107767,"title":"78 | 常用组件化URL Scheme方案","content":"<p><strong>PDF 课件和源代码下载地址：</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/geektime-ios-course\">https://gitee.com/geektime-geekbang/geektime-ios-course</a></p>","comments":[{"had_liked":false,"id":146072,"user_name":"Mason","can_delete":false,"product_type":"c3","uid":1453662,"ip_address":"","ucode":"AA2E37FDF9D313","user_header":"https://static001.geekbang.org/account/avatar/00/16/2e/5e/d42c79bb.jpg","comment_is_top":false,"comment_ctime":1572428358,"is_pvip":false,"replies":[{"id":56675,"content":"‘路由’这个概念，在客户端或者Web开发中，我认为可以简单理解为‘根据URL或者规则（参数）的解析，分配或跳转到不同的页面（或方法）’，当然这个概念和网络中路由的概念不同。而‘scheme’，通常是指URL中固定位置的字段，一般是‘:&#47;&#47;’之前，比如http&#47;https等，这些在对应的课程中都有讲解。本身两者是不同维度的描述，但是他们之间有一定的联系：就是路由的实现可以通过URL Scheme的方法实现。系统级的我们可以通过加载url，不同的Scheme拉起不同的App，在App内部也可以判断url中的Scheme来处理自定义的业务逻辑。总的来说，路由感觉是一个偏向于功能&#47;能力的描述，Scheme作为Url的一部分，路由这个功能的实现一般需要使用它。","user_name":"作者回复","user_name_real":"zzz","uid":1041455,"ctime":1572579449,"ip_address":"","comment_id":146072,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"老师,路由和url scheme是同一个东西吗","like_count":2,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472699,"discussion_content":"‘路由’这个概念，在客户端或者Web开发中，我认为可以简单理解为‘根据URL或者规则（参数）的解析，分配或跳转到不同的页面（或方法）’，当然这个概念和网络中路由的概念不同。而‘scheme’，通常是指URL中固定位置的字段，一般是‘://’之前，比如http/https等，这些在对应的课程中都有讲解。本身两者是不同维度的描述，但是他们之间有一定的联系：就是路由的实现可以通过URL Scheme的方法实现。系统级的我们可以通过加载url，不同的Scheme拉起不同的App，在App内部也可以判断url中的Scheme来处理自定义的业务逻辑。总的来说，路由感觉是一个偏向于功能/能力的描述，Scheme作为Url的一部分，路由这个功能的实现一般需要使用它。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572579449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114771,"user_name":"Realtime","can_delete":false,"product_type":"c3","uid":1107989,"ip_address":"","ucode":"CCE761CF2CD804","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/15/c60311ab.jpg","comment_is_top":false,"comment_ctime":1563386322,"is_pvip":false,"replies":[{"id":42644,"content":"对于Swift的组件化，可以通过@objc 或者Extension的方式。具体的Demo可以参考https:&#47;&#47;github.com&#47;ModulizationDemo&#47;SwfitDemo","user_name":"作者回复","user_name_real":"dequanzhu","uid":1041455,"ctime":1563890714,"ip_address":"","comment_id":114771,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"老师，NSStringFromClass利用的是objective-C的run time. 这种方式也适合Swift 语言么？ 还说swift 使用别的解耦方式？多谢。","like_count":1,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458809,"discussion_content":"对于Swift的组件化，可以通过@objc 或者Extension的方式。具体的Demo可以参考https://github.com/ModulizationDemo/SwfitDemo","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563890714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529929,"avatar":"","nickname":"起风了001","note":"","ucode":"8DCDBA40B8CC9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2293,"discussion_content":"swift有一样的API \nlet vc = NSClassFromString(&#34;UIViewController&#34;) as! UIViewController.Type\nprint(&#34;\\(vc.init())&#34;);\n另外swift有专门的反射API也许可以实现这个.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563440256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307583,"user_name":"高亮","can_delete":false,"product_type":"c3","uid":2731035,"ip_address":"","ucode":"414D1CFDE112ED","user_header":"","comment_is_top":false,"comment_ctime":1629166026,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"《78 | 常用组件化URL Scheme方案》提到的“GTMediator扩展”是什么样的？","like_count":0},{"had_liked":false,"id":284221,"user_name":"Geek_b06087","can_delete":false,"product_type":"c3","uid":2403434,"ip_address":"","ucode":"6177875679AD32","user_header":"","comment_is_top":false,"comment_ctime":1616124780,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"你好 使用scheme这种方式 必须在+load方法里面注册么，这样的话，引入过多的+load方法就会导致启动时间（preMain）的延长吧","like_count":0}]}