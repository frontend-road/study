{"id":740839,"title":"第 3 章 容器类型(1)","content":"<h1 id=\"nav_point_48\">第 3 章　容器类型</h1>\n<p>在我们的日常生活中，有一类物品比较特别，它们自身并不提供“具体”的功能，最大的用处就是存放其他东西——小学生用的文具盒、图书馆的书架，都可归入此类物品，我们可以统称它们为“容器”。</p>\n<p>而在代码世界里，同样也有“容器”这个概念。代码里的<strong>容器</strong>泛指那些专门用来装其他对象的特殊数据类型。在 Python 中，最常见的内置容器类型有四种：列表、元组、字典、集合。</p>\n<p><strong>列表</strong>（list）是一种非常经典的容器类型，通常用来存放多个同类对象，比如从 1 到 10 的所有整数：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></pre>\n<p><strong>元组</strong>（tuple）和列表非常类似，但跟列表不同，它不能被修改。这意味着元组完成初始化后就没法再改动了：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; names = ('foo', 'bar')\n&gt;&gt;&gt; names[1] = 'x'\n...\nTypeError: 'tuple' object does not support item assignment</code></pre>\n<p><strong>字典</strong>（dict）类型存放的是一个个键值对（<code>key: value</code>）。它功能强大，应用广泛，就连 Python 内部也大量使用，比如每个类实例的所有属性，就都存放在一个名为 <code>dict</code> 的字典里：</p>\n<pre class=\"code-rows\"><code>class Foo:\n    def __init__(self, value):\n        self.value = value\n\nfoo = Foo('bar')\nprint(foo.__dict__, type(foo.__dict__))</code></pre>\n<p>执行后输出：</p>\n<pre class=\"code-rows\"><code>{'value': 'bar'} &lt;class 'dict'&gt;</code></pre>\n<p><strong>集合</strong>（set）也是一种常用的容器类型。它最大的特点是成员不能重复，所以经常用来去重（剔除重复元素）：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; numbers = [1, 2, 2, 1]\n&gt;&gt;&gt; set(numbers)\n</code></pre>\n<p>这四种容器类型各有优缺点，适用场景也各不相同。本章将简单介绍每种容器类型的特点，深入分析它们的应用场景，帮你厘清一些常见的概念。更好地掌握容器能帮助你写出更高效的 Python 代码。</p>\n<h2 id=\"nav_point_49\">3.1　基础知识</h2>\n<p>在基础知识部分，我将按照列表、元组、字典、集合的顺序介绍每种容器的基本操作，并在其中穿插一些重要的概念解释。</p><!-- [[[read_end]]] -->\n<h3 id=\"nav_point_50\">3.1.1　列表常用操作</h3>\n<p>列表是一种有序的可变容器类型，是日常编程中最常用的类型之一。常用的列表创建方式有两种：字面量语法与 <code>list()</code> 内置函数。</p>\n<p>使用 <code>[]</code> 符号来创建一个列表字面量：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; numbers = [1, 2, 3, 4]</code></pre>\n<p>内置函数 <code>list(iterable)</code> 则可以把任何一个可迭代对象转换为列表，比如字符串：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; list('foo')\n['f', 'o', 'o']</code></pre>\n<p>对于已有列表，我们可以通过索引访问它的成员。要删除列表中的某些内容，可以直接使用 <code>del</code> 语句：</p>\n<pre class=\"code-rows\"><code># 通过索引获取内容，如果索引越界，会抛出 IndexError 异常\n&gt;&gt;&gt; numbers[2]\n3\n\n# 使用切片获取一段内容\n&gt;&gt;&gt; numbers[1:]\n[2, 3, 4]\n\n#  删除列表中的一段内容\n&gt;&gt;&gt; del numbers[1:]\n&gt;&gt;&gt; numbers\n[1]</code></pre>\n<ol>\n<li><p><strong>在遍历列表时获取下标</strong></p>\n<p>当你使用 <code>for</code> 循环遍历列表时，默认会逐个拿到列表的所有成员。假如你想在遍历的同时，获取当前循环下标，可以选择用内置函数 <code>enumerate()</code> 包裹列表对象 <span class=\"comment-number\">1</span>：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; names = ['foo', 'bar']\n&gt;&gt;&gt; for index, s in enumerate(names):\n...     print(index, s)\n...\n0 foo\n1 bar</code></pre>\n<p><code>enumerate()</code> 接收一个可选的 <code>start</code> 参数，用于指定循环下标的初始值（默认为 0）：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; for index, s in enumerate(names, start=10):\n...     print(index, s)\n...\n10 foo\n11 bar</code></pre>\n<p><code>enumerate()</code> 适用于任何“可迭代对象”，因此它不光可以用于列表，还可以用于元组、字典、字符串等其他对象。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　你可以在 6.1.1 节找到关于“可迭代对象”的更多介绍。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>列表推导式</strong></p>\n<p>当我们需要处理某个列表时，一般有两个目的：修改已有成员的值；根据规则剔除某些成员。</p>\n<p>举个例子，有个列表里存放了许多正整数，我想要剔除里面的奇数，并将所有数字乘以 100。假如用传统写法，代码如下所示：</p>\n<pre class=\"code-rows\"><code>def remove_odd_mul_100(numbers):\n    \"\"\"剔除奇数并乘以 100\"\"\"\n    results = []\n    for number in numbers:\n        if number % 2 == 1:\n            continue\n        results.append(number * 100)\n    return results</code></pre>\n<p>一共 6 行代码，看上去并不算太多。但其实针对这类需求，Python 为我们提供了更精简的写法：<strong>列表推导式</strong>（list comprehension）。使用列表推导式，上面函数里的 6 行代码可以压缩成一行：</p>\n<pre class=\"code-rows\"><code># 用一个表达式完成 4 件事情\n#\n# 1. 遍历旧列表：for n in numbers\n# 2. 对成员进行条件过滤：if n % 2 == 0\n# 3. 修改成员： n * 100\n# 4. 组装新的结果列表\n#\nresults = [n * 100 for n in numbers if n % 2 == 0]</code></pre>\n<p>相比传统风格的旧代码，列表推导式把几类操作压缩在了一起，结果就是：代码量更少，并且维持了很高的可读性。因此，列表推导式可以算得上处理列表数据的一把“利器”。</p>\n<p>但在使用列表推导式时，也需要注意不要陷入一些常见误区。在 3.3.6 节中，我会谈谈使用列表推导式的两个“不要”。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_51\">3.1.2　理解列表的可变性</h3>\n<p>Python 里的内置数据类型，大致上可分为可变与不可变两种。</p>\n<ul>\n<li><strong>可变</strong>（mutable）：列表、字典、集合。</li>\n<li><strong>不可变</strong>（immutable）：整数、浮点数、字符串、字节串、元组。</li>\n</ul>\n<p>前面提到，列表是可变的。当我们初始化一个列表后，仍然可以调用 <code>.append()</code>、<code>.extend()</code> 等方法来修改它的内容。而字符串和整数等都是不可变的——我们没法修改一个已经存在的字符串对象。</p>\n<p>在学习 Python 时，理解类型的可变性是非常重要的一课。如果不能掌握它，你在写代码时就会遇到很多与之相关的“惊喜”。</p>\n<p>拿一个最常见的场景“函数调用”来说，许多新手在刚接触 Python 时，很难理解下面这两个例子。</p>\n<h4>示例一：为字符串追加内容</h4>\n<p>在这个示例里，我们定义一个往字符串追加内容的函数 <code>add_str()</code>，并在外层用一个字符串参数调用该函数：</p>\n<pre class=\"code-rows\"><code>def add_str(in_func_obj):\n    print(f'In add [before]: in_func_obj=\"\"')\n    in_func_obj += ' suffix'\n    print(f'In add [after]: in_func_obj=\"\"')\n\n\norig_obj = 'foo'\nprint(f'Outside [before]: orig_obj=\"\"')\nadd_str(orig_obj)\nprint(f'Outside [after]: orig_obj=\"\"')</code></pre>\n<p>运行上面的代码会输出这样的结果：</p>\n<pre class=\"code-rows\"><code>Outside [before]: orig_obj=\"foo\"\nIn add [before]: in_func_obj=\"foo\"\nIn add [after]: in_func_obj=\"foo suffix\"\n\n# 重要：这里的 orig_obj 变量还是原来的值\nOutside [after]: orig_obj=\"foo\"</code></pre>\n<p>在这段代码里，原始字符串对象 <code>orig_obj</code> 被作为参数传给了 <code>add_str()</code> 函数的 <code>in_func_obj</code> 变量。随后函数内部通过 <code>+=</code> 操作修改了 <code>in_func_obj</code> 的值，为其增加了后缀字符串。但重点是：函数外的 <code>orig_obj</code> 变量所指向的值没有受到任何影响。</p>\n<h4>示例二：为列表追加内容</h4>\n<p>在这个例子中，我们保留一模一样的代码逻辑，但是把 <code>orig_obj</code> 换成了列表对象：</p>\n<pre class=\"code-rows\"><code>def add_list(in_func_obj):\n    print(f'In add [before]: in_func_obj=\"\"')\n    in_func_obj += ['baz']\n    print(f'In add [after]: in_func_obj=\"\"')\n\n\norig_obj = ['foo', 'bar']\nprint(f'Outside [before]: orig_obj=\"\"')\nadd_list(orig_obj)\nprint(f'Outside [after]: orig_obj=\"\"')</code></pre>\n<p>执行后会发现结果大不一样：</p>\n<pre class=\"code-rows\"><code>Outside [before]: orig_obj=\"['foo', 'bar']\"\nIn add [before]: in_func_obj=\"['foo', 'bar']\"\nIn add [after]: in_func_obj=\"['foo', 'bar', 'baz']\"\n\n# 注意：函数外的 orig_obj 变量的值已经被修改了！\nOutside [after]: orig_obj=\"['foo', 'bar', 'baz']\"</code></pre>\n<p>当操作对象变成列表后，函数内的 <code>+=</code> 操作居然可以修改原始变量的值 !</p>\n<h4>示例解释</h4>\n<p>如果要用其他编程语言的术语来解释这两个例子，上面的函数调用<strong>似乎</strong>分别可以对应两种函数参数传递机制。</p>\n<p>(1) <strong>值传递</strong>（pass-by-value）：调用函数时，传过去的是变量所指向对象（值）的拷贝，因此对函数内变量的任何修改，都不会影响原始变量——对应 <code>orig_obj</code> 是字符串时的行为。</p>\n<p>(2) <strong>引用传递</strong>（pass-by-reference）：调用函数时，传过去的是变量自身的引用（内存地址），因此，修改函数内的变量会直接影响原始变量——对应 <code>orig_obj</code> 是列表时的行为。</p>\n<p>看了上面的解释，你也许会发出灵魂拷问：为什么 Python 的函数调用要同时使用两套不同的机制，把事情搞得这么复杂呢？</p>\n<p>答案其实没有你想得那么“复杂”——Python 在进行函数调用传参时，采用的既不是值传递，也不是引用传递，而是传递了“变量所指对象的引用”（pass-by-object-reference）。</p>\n<p>换个角度说，当你调用 <code>func(orig_obj)</code> 后，Python 只是新建了一个函数内部变量 <code>in_func_obj</code>，然后让它和外部变量 <code>orig_obj</code> 指向同一个对象，相当于做了一次变量赋值：</p>\n<pre class=\"code-rows\"><code>def func(in_func_obj): ...\n\norig_obj = ...\nfunc(orig_obj)</code></pre>\n<p>这个过程如图 3-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00375.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3-1　进行函数调用后，变量与值对象间的关系示意图</strong></p>\n<p>一次函数调用基本等于执行了 <code>in_func_obj = orig_obj</code>。</p>\n<p>所以，当我们在函数内部执行 <code>in_func_obj += ...</code> 等修改操作时，是否会影响外部变量，只取决于 <code>in_func_obj</code> 所指向的对象本身是否可变。</p>\n<p>如图 3-2 所示，浅色标签代表变量，白色方块代表值。在左侧的图里，<code>in_func_obj</code> 和 <code>orig_obj</code> 都指向同一个字符串值 <code>'foo'</code>。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00376.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3-2　对字符串对象执行 <code>+=</code> 操作</strong></p>\n<p>在对字符串进行 <code>+=</code> 操作时，因为字符串是不可变类型，所以程序会生成一个新对象（值）：<code>'foo suffix'</code>，并让 <code>in_func_obj</code> 变量指向这个新对象；旧值（原始变量 <code>orig_obj</code> 指向的对象）则不受任何影响，如图 3-2 右侧所示。</p>\n<p>但如果对象是可变的（比如列表），<code>+=</code> 操作就会直接原地修改 <code>in_func_obj</code> 变量所指向的值，而它同时也是原始变量 <code>orig_obj</code> 所指向的内容；待修改完成后，两个变量所指向的值（同一个）肯定就都受到了影响。如图 3-3 所示，右边的列表在操作后直接多了一个成员：<code>'bar'</code>。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00377.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3-3　对列表对象执行 <code>+=</code> 操作</strong></p>\n<p>由此可见，Python 的函数调用不能简单归类为“值传递”或者“引用传递”，一切行为取决于对象的可变性。</p>\n<h3 id=\"nav_point_52\">3.1.3　常用元组操作</h3>\n<p>元组是一种有序的不可变容器类型。它看起来和列表非常像，只是标识符从中括号 <code>[]</code> 变成了圆括号 <code>()</code>。由于元组不可变，所以它也没有列表那一堆内置方法，比如 <code>.append()</code>、<code>.extend()</code> 等。</p>\n<p>和列表一样，元组也有两种常用的定义方式——字面量表达式和 <code>tuple()</code> 内置函数：</p>\n<pre class=\"code-rows\"><code># 使用字面量语法定义元组\n&gt;&gt;&gt; t = (0, 1, 2)\n\n# 真相：“括号”其实不是定义元组的关键标志——直接删掉两侧括号\n# 同样也能完成定义，“逗号”才是让解释器判定为元组的关键\n&gt;&gt;&gt; t = 0, 1, 2\n&gt;&gt;&gt; t\n(0, 1, 2)\n\n# 使用 tuple(iterable) 内置函数\n&gt;&gt;&gt; t = tuple('foo')\n&gt;&gt;&gt; t\n('f', 'o', 'o')</code></pre>\n<p>因为元组是一种不可变类型，所以下面这些操作都不会成功：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; del user_info[1]\n# 报错：元组成员不允许被删除\n#   TypeError: 'tuple' object doesn't support item deletion\n&gt;&gt;&gt; user_info.append(0)\n# 报错：元组压根儿就没有 append 方法\n#   AttributeError: 'tuple' object has no attribute 'append'</code></pre>\n<ol>\n<li><p><strong>返回多个结果，其实就是返回元组</strong></p>\n<p>在 Python 中，函数可以一次返回多个结果，这其实是通过返回一个元组来实现的：</p>\n<pre class=\"code-rows\"><code>def get_rectangle():\n    \"\"\"返回长方形的宽和高\"\"\"\n    width = 100\n    height = 20\n    return width, height\n　\n　\n# 获取函数的多个返回值\nresult = get_rectangle()\nprint(result, type(result))\n# 输出：\n# (100, 20) &lt;class 'tuple'&gt;</code></pre>\n<p>将函数返回值一次赋值给多个变量时，其实就是对元组做了一次解包操作：</p>\n<pre class=\"code-rows\"><code>width, height = get_rectangle()\n# 可以理解为：width, height = (width, height)</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>没有“元组推导式”</strong></p>\n<p>前提到，列表有自己的列表推导式。而元组和列表那么像，是不是也有自己的推导式呢？瞎猜不如尝试，我们把 <code>[]</code> 改成 <code>()</code> 符号来试试看：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; results = (n * 100 for n in range(10) if n % 2 == 0)\n&gt;&gt;&gt; results\n&lt;generator object &lt;genexpr&gt; at 0x10e94e2e0&gt;</code></pre>\n<p>很遗憾，上面的表达式并没有生成元组，而是返回了一个<strong>生成器</strong>（generator）对象。因此它是生成器推导式，而非元组推导式。</p>\n<p>不过幸运的是，虽然无法通过推导式直接拿到元组，但生成器仍然是一种可迭代类型，所以我们还是可以对它调用 <code>tuple()</code> 函数，获得元组：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; results = tuple((n * 100 for n in range(10) if n % 2 == 0))\n&gt;&gt;&gt; results\n(0, 200, 400, 600, 800)</code></pre>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00372.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　有关生成器和迭代器的更多内容，可查看 6.1.1 节。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>存放结构化数据</strong></p>\n<p>和列表不同，在同一个元组里出现不同类型的值是很常见的事情,因此元组经常用来存放结构化数据。比如，下面的 <code>user_info</code> 就是一份包含名称、年龄等信息的用户数据：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; user_info = ('piglei', 'MALE', 30, True)\n&gt;&gt;&gt; user_info[2]\n30</code></pre>\n<p>正因为元组有这个特点，所以 Python 为我们提供了一个特殊的元组类型：具名元组。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_53\">3.1.4　具名元组</h3>\n<p>和列表一样，当我们想访问元组成员时，需要用数字索引来定位：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; rectangle = (100, 20)\n&gt;&gt;&gt; rectangle[0] ➊\n100\n&gt;&gt;&gt; rectangle[-1] ➋\n20</code></pre>\n<blockquote>\n<p>❶ 访问第一个成员</p>\n<p>❷ 访问最后一个成员</p>\n</blockquote>\n<p>前面提到，元组经常用来存放结构化数据，但只能通过数字来访问元组成员其实特别不方便——比如我就完全记不住上面的 <code>rectangle[0]</code> 到底代表长方形的宽度还是高度。</p>\n<p>为了解决这个问题，我们可以使用一种特殊的元组：<strong>具名元组</strong>（namedtuple）。具名元组在保留普通元组功能的基础上，允许为元组的每个成员命名，这样你便能通过名称而不止是数字索引访问成员。</p>\n<p>创建具名元组需要用到 <code>namedtuple()</code> 函数，它位于标准库的 <code>collections</code> 模块里，使用前需要先导入：</p>\n<pre class=\"code-rows\"><code>from collections import namedtuple\n\nRectangle = namedtuple('Rectangle', 'width,height') ➊</code></pre>\n<blockquote>\n<p>❶ 除了用逗号来分隔具名元组的字段名称以外，还可以用空格分隔：<code>'width height'</code>，或是直接使用一个字符串列表：<code>['width', 'height']</code></p>\n</blockquote>\n<p>使用效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; rect = Rectangle(100, 20) ➊\n&gt;&gt;&gt; rect = Rectangle(width=100, height=20) ➋\n&gt;&gt;&gt; print(rect[0]) ➌\n100\n&gt;&gt;&gt; print(rect.width) ➍\n100\n&gt;&gt;&gt; rect.width += 1 ➎\n...\nAttributeError: can't set attribute</code></pre>\n<blockquote>\n<p>❶ 初始化具名元组</p>\n<p>❷ 也可以指定字段名称来初始化</p>\n<p>❸ 可以像普通元组一样，通过数字索引访问成员</p>\n<p>❹ 具名元组也支持通过名称来访问成员</p>\n<p>❺ 和普通元组一样，具名元组是不可变的</p>\n</blockquote>\n<p>在 Python 3.6 版本以后，除了使用 <code>namedtuple()</code> 函数以外，你还可以用 <code>typing.NamedTuple</code> 和类型注解语法来定义具名元组类型。这种方式在可读性上更胜一筹：</p>\n<pre class=\"code-rows\"><code>class Rectangle(NamedTuple):\n    width: int\n    height: int\n\nrect = Rectangle(100, 20)</code></pre>\n<p>但需要注意的是，上面的写法虽然给 <code>width</code> 和 <code>height</code> 加了类型注解，但 Python 在执行时并不会做真正的类型校验。也就是说，下面这段代码也能正常执行：</p>\n<pre class=\"code-rows\"><code># 提供错误的类型来初始化\nrect_wrong_type = Rectangle('string', 'not_a_number')</code></pre>\n<p>想要严格校验字段类型，可以使用 mypy 等工具对代码进行静态检查（我们会在 13.1.5 节详细讲解）。</p>\n<p>和普通元组比起来，使用具名元组的好处很多。其中最直观的一点就是：用名字访问成员（<code>rect.width</code>）比用普通数字（<code>rect[0]</code>）更易读、更好记。除此之外，具名元组还有其他妙用，在 3.3.7 节中，我会展示把它用作函数返回值的好处。</p>\n<h3 id=\"nav_point_54\">3.1.5　字典常用操作</h3>\n<p>跟列表和元组比起来，字典是一种更为复杂的容器结构。它所存储的内容不再是单一维度的线性序列，而是多维度的 <code>key: value</code> 键值对。以下是字典的一些基本操作：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; movie = {'name': 'Burning', 'type': 'movie', 'year': 2018}\n\n# 通过 key 来获取某个 value\n&gt;&gt;&gt; movie['year']\n2018\n\n# 字典是一种可变类型，所以可以给它增加新的 key\n&gt;&gt;&gt; movie['rating'] = 10\n\n# 字典的 key 不可重复，对同一个 key 赋值会覆盖旧值\n&gt;&gt;&gt; movie['rating'] = 9\n&gt;&gt;&gt; movie\n{'name': 'Burning', 'type': 'movie', 'year': 2018, 'rating': 9}</code></pre>\n<ol>\n<li><p><strong>遍历字典</strong></p>\n<p>当我们直接遍历一个字典对象时，会逐个拿到字典所有的 <code>key</code>。如果你想在遍历字典时同时获取 <code>key</code> 和 <code>value</code>，需要使用字典的 <code>.items()</code> 方法：</p>\n<pre class=\"code-rows\"><code># 遍历获取字典所有的 key\n&gt;&gt;&gt; for key in movie:\n...     print(key, movie[key])\n\n# 一次获取字典的所有 key: value 键值对\n&gt;&gt;&gt; for key, value in movie.items():\n...     print(key, value)</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>访问不存在的字典键</strong></p>\n<p>当用不存在的键访问字典内容时，程序会抛出 <code>KeyError</code> 异常，我们通常称之为程序里的<strong>边界情况</strong>（edge case）。针对这种边界情况，比较常见的处理方式有两种：</p>\n<p>(1) 读取内容前先做一次条件判断，只有判断通过的情况下才继续执行其他操作；</p>\n<p>(2) 直接操作，但是捕获 <code>KeyError</code> 异常。</p>\n<p>第一种写法：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; if 'rating' in movie:\n...     rating = movie['rating']\n... else:\n...     rating = 0\n...</code></pre>\n<p>第二种写法：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; try:\n...     rating = movie['rating']\n... except KeyError:\n...     rating = 0\n...</code></pre>\n<p>在 Python 中，人们比较推崇第二种写法，因为它看起来更简洁，执行效率也更高。不过，如果只是“提供默认值的读取操作”，其实可以直接使用字典的 <code>.get()</code> 方法。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00372.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　在 5.1.1 节中，我们会详细探讨为何应该使用捕获异常来处理边界情况。</p>\n</blockquote>\n<p><code>dict.get(key, default)</code> 方法接收一个 <code>default</code> 参数，当访问的键不存在时，方法会返回 <code>default</code> 作为默认值：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; movie.get('rating', 0) ➊\n\n0</code></pre>\n<blockquote>\n<p>❶ 此时 <code>movie</code> 里没有 <code>rating</code> 字段</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 <code>setdefault</code> 取值并修改</strong></p>\n<p>有时，我们需要修改字典中某个可能不存在的键，比如在下面的代码里，我需要往字典 <code>d</code> 的 <code>items</code> 键里追加新值，但 <code>d['items']</code> 可能根本就不存在。因此我写了一段异常捕获逻辑——假如 <code>d['items']</code> 不存在，就以列表来初始化它：</p>\n<pre class=\"code-rows\"><code>try:\n    d['items'].append(value)\nexcept KeyError:\n    d['items'] = [value]</code></pre>\n<p>针对上面这种情况，其实有一个更适合的工具：<code>d.setdefault(key, default=None)</code> 方法。使用它，可以直接删掉上面的异常捕获，代码逻辑会变得更简单。</p>\n<p>视条件的不同，调用 <code>dict.setdefault(key, default)</code> 会产生两种结果：当 <code>key</code> 不存在时，该方法会把 <code>default</code> 值写入字典的 <code>key</code> 位置，并返回该值；假如 <code>key</code> 已经存在，该方法就会直接返回它在字典中的对应值。代码如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d = {'title': 'foobar'}\n&gt;&gt;&gt; d.setdefault('items', []).append('foo') ➊\n&gt;&gt;&gt; d\n{'title': 'foobar', 'items': ['foo']}\n&gt;&gt;&gt; d.setdefault('items', []).append('bar') ➋\n&gt;&gt;&gt; d\n{'title': 'foobar', 'items': ['foo', 'bar']}</code></pre>\n<blockquote>\n<p>❶ 若 <code>key</code> 不存在，以空列表 <code>[]</code> 初始化并返回</p>\n<p>❷ 若 <code>key</code> 存在，直接返回旧值</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 <code>pop</code> 方法删除不存在的键</strong></p>\n<p>如果我们想删除字典里的某个键，一般会使用 <code>del d[key]</code> 语句；但如果要删除的键不存在，该操作就会抛出 <code>KeyError</code> 异常。</p>\n<p>因此，要想安全地删除某个键，需要加上一段异常捕获逻辑：</p>\n<pre class=\"code-rows\"><code>try:\n    del d[key]\nexcept KeyError:\n    # 忽略 key 不存在的情况\n    pass</code></pre>\n<p>但假设你只是单纯地想去掉某个键，并不关心它存在与否、删除有没有成功，那么使用 <code>dict.pop(key, default)</code> 方法就够了。</p>\n<p>只要在调用 <code>pop</code> 方法时传入默认值 <code>None</code>，在键不存在的情况下也不会产生任何异常：</p>\n<pre class=\"code-rows\"><code>d.pop(key, None)</code></pre>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　严格说来，<code>pop</code> 方法的主要用途并不是删除某个键，而是取出这个键对应的值。但我个人觉得，偶尔用它来执行删除操作也无伤大雅。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>字典推导式</strong></p>\n<p>和列表类似，字典同样有自己的字典推导式。（比元组待遇好多啦！）你可以用它来方便地过滤和处理字典成员：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d1 = {'foo': 3, 'bar': 4}\n&gt;&gt;&gt; \n{'foo': 30}</code></pre>\n</li>\n</ol>\n<h3 id=\"nav_point_55\">3.1.6　认识字典的有序性与无序性</h3>\n<p>在 Python 3.6 版本以前，几乎所有开发者都遵从一条常识：“Python 的字典是无序的。”这里的无序指的是：当你按照某种顺序把内容存进字典后，就永远没法按照原顺序把它取出来了。</p>\n<p>以下面这段代码为例：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d = {}\n&gt;&gt;&gt; d['FIRST_KEY'] = 1\n&gt;&gt;&gt; d['SECOND_KEY'] = 2\n\n&gt;&gt;&gt; for key in d:\n...     print(key)</code></pre>\n<p>如果用 Python 2.7 版本运行这段代码，你会发现输出顺序和插入顺序反过来了。第二个插入的 <code>SECOND_KEY</code> 反而第一个被打印了出来：</p>\n<pre class=\"code-rows\"><code>SECOND_KEY\nFIRST_KEY</code></pre>\n<p>上面这种无序现象，是由字典的底层实现所决定的。</p>\n<p>Python 里的字典在底层使用了<strong>哈希表</strong>（hash table）数据结构。当你往字典里存放一对 <code>key: value</code> 时，Python 会先通过哈希算法计算出 <code>key</code> 的哈希值——一个整型数字；然后根据这个哈希值，决定数据在表里的具体位置。</p>\n<p>因此，最初的内容插入顺序，在这个哈希过程中被自然丢掉了，字典里的内容顺序变得仅与哈希值相关，与写入顺序无关。在很长一段时间里，字典的这种无序性一直被当成一个常识为大家所接受。</p>\n<p>但 Python 语言在不断进化。Python 3.6 为字典类型引入了一个改进：优化了底层实现，同样的字典相比 3.5 版本可节约多达 25% 的内存。而这个改进同时带来了一个有趣的副作用：字典变得有序了。因此，只要用 Python 3.6 之后的版本执行前面的代码，结果永远都会是 <code>FIRST_KEY</code> 在前，<code>SECOND_KEY</code> 在后。</p>\n<p>一开始，字典变为有序只是作为 3.6 版本的“隐藏特性”存在。但到了 3.7 版本，它已经彻底成了语言规范的一部分。<span class=\"comment-number\">2</span></p>\n\n<p>如今当你使用字典时，假如程序的目标运行环境是 Python 3.7 或更高版本，那你完全可以依赖字典类型的这种有序特性。</p>\n<p>但如果你使用的 Python 版本没有那么新，也可以从 <code>collections</code> 模块里方便地拿到另一个有序字典对象 <code>OrderedDict</code>，它可以在 Python 3.7 以前的版本里保证字典有序：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; d = OrderedDict()\n&gt;&gt;&gt; d['FIRST_KEY'] = 1\n&gt;&gt;&gt; d['SECOND_KEY'] = 2\n\n&gt;&gt;&gt; for key in d:\n...     print(key)\nFIRST_KEY\nSECOND_KEY</code></pre>\n<p><code>OrderedDict</code> 最初出现于 2009 年发布的 Python 3.1 版本，距今已有十多年历史。因为新版本的 Python 的字典已然变得有序，所以人们常常讨论 <code>collections.OrderedDict</code> 是否有必要继续存在。</p>\n<p>但在我看来，<code>OrderedDict</code> 比起普通字典仍然有一些优势。最直接的一点是，<code>OrderedDict</code> 把“有序”放在了自己的名字里，因此当你在代码中使用它时，其实比普通字典更清晰地表达了“此处会依赖字典的有序特性”这一点。</p>\n<p>另外从功能上来说，<code>OrderedDict</code> 与新版本的字典其实也有着一些细微区别。比如，在对比两个内容相同而顺序不同的字典对象时，解释器会返回 <code>True</code> 结果；但如果是 <code>OrderedDict</code> 对象，则会返回 <code>False</code>：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d1 = {'name': 'piglei', 'fruit': 'apple'}\n&gt;&gt;&gt; d2 = {'fruit': 'apple', 'name': 'piglei'}\n&gt;&gt;&gt; d1 == d2 ➊\nTrue\n\n&gt;&gt;&gt; d1 = OrderedDict(name='piglei', fruit='apple')\n&gt;&gt;&gt; d2 = OrderedDict(fruit='apple', name='piglei')\n&gt;&gt;&gt; d1 == d2 ➋\nFalse</code></pre>\n<blockquote>\n<p>❶ 内容一致而顺序不同的字典被视作相等，因为解释器只对比字典的键和值是否一致</p>\n<p>❷ 同样的 <code>OrderedDict</code> 则被视作不相等，因为“键的顺序”也会作为对比条件</p>\n</blockquote>\n<p>除此之外，<code>OrderedDict</code> 还有 <code>.move_to_end()</code> 等普通字典没有的一些方法。所以，即便 Python 3.7 及之后的版本已经提供了内置的“有序字典”，但 <code>OrderedDict</code> 仍然有着自己的一席之地。</p>\n<h3 id=\"nav_point_56\">3.1.7　集合常用操作</h3>\n<p>集合是一种无序的可变容器类型，它最大的特点就是成员不能重复。集合字面量的语法和字典很像，都是使用大括号包裹，但集合里装的是一维的值 <code></code>，而不是键值对 <code></code>。</p>\n<p>初始化一个集合：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; fruits = {'apple', 'orange', 'apple', 'pineapple'}</code></pre>\n<p>重新查看上面 <code>fruits</code> 变量的值，你会马上体会到集合最重要的两个特征——去重与无序——重复的 <code>'apple'</code> 消失了，成员顺序也被打乱了：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; fruits\n{'pineapple', 'orange', 'apple'}</code></pre>\n<p>要初始化一个空集合，只能调用 <code>set()</code> 方法，因为 <code>{}</code> 表示的是一个空字典，而不是一个空集合。</p>\n<pre class=\"code-rows\"><code># 正确初始化一个空集合\n&gt;&gt;&gt; empty_set = set()</code></pre>\n<p>集合也有自己的推导式语法：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; nums = [1, 2, 2, 4, 1]\n&gt;&gt;&gt; \n</code></pre>\n<ol>\n<li><p><strong>不可变的集合 <code>frozenset</code></strong></p>\n<p>集合是一种可变类型，使用 <code>.add()</code> 方法可以向集合追加新成员：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; new_set = set(['foo', 'foo', 'bar'])\n&gt;&gt;&gt; new_set.add('apple')\n&gt;&gt;&gt; new_set\n{'apple', 'bar', 'foo'}</code></pre>\n<p>假如你想要一个不可变的集合，可使用内置类型 <code>frozenset</code>，它和普通 <code>set</code> 非常像，只是少了所有的修改类方法：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; f_set = frozenset(['foo', 'bar'])\n&gt;&gt;&gt; f_set.add('apple')\n# 报错：没有 add/remove 那些修改集合的方法\nAttributeError: 'frozenset' object has no attribute 'add'</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>集合运算</strong></p>\n<p>除了天生不重复以外，集合的最大独特之处在于：你可以对其进行真正的集合运算，比如求交集、并集、差集，等等。所有操作都可以用两种方式来进行：方法和运算符。</p>\n<p>假如我有两个保存了水果名称的集合：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; fruits_1 = {'apple', 'orange', 'pineapple'}\n&gt;&gt;&gt; fruits_2 = {'tomato', 'orange', 'grapes', 'mango'}</code></pre>\n<p>对两个集合求交集，也就是获取两个集合中同时存在的东西：</p>\n<pre class=\"code-rows\"><code># 使用 &amp; 运算符\n&gt;&gt;&gt; fruits_1 &amp; fruits_2\n{'orange'}\n# 使用 intersection 方法完成同样的功能\n&gt;&gt;&gt; fruits_1.intersection(fruits_2)\n...</code></pre>\n<p>对集合求并集，把两个集合里的东西合起来：</p>\n<pre class=\"code-rows\"><code># 使用 | 运算符\n&gt;&gt;&gt; fruits_1 | fruits_2\n{'mango', 'orange', 'grapes', 'pineapple', 'apple', 'tomato'}\n# 使用 union 方法完成同样的功能\n&gt;&gt;&gt; fruits_1.union(fruits_2)\n...</code></pre>\n<p>对集合求差集，获得前一个集合有、后一个集合没有的东西：</p>\n<pre class=\"code-rows\"><code># 使用 - 运算符\n&gt;&gt;&gt; fruits_1 - fruits_2\n{'apple', 'pineapple'}\n# 使用 difference 方法完成同样的功能\n&gt;&gt;&gt; fruits_1.difference(fruits_2)\n...</code></pre>\n<p>除了上面这三种运算，集合还有 <code>symmetric_difference</code>、<code>issubset</code> 等其他许多有用的操作，你可以在官方文档里找到详细的说明。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　这些集合运算在特定场景下非常有用，能帮你高效完成任务，达到事半功倍的效果。第 12 章的案例故事板块就有一个使用集合解决真实问题的有趣案例。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>集合只能存放可哈希对象</strong></p>\n<p>在使用集合时，除了上面这些常见操作，你还需要了解另一件重要的事情，那就是集合到底可以存放哪些类型的数据。</p>\n<p>比如下面的集合可以被成功初始化：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; valid_set = {'apple', 30, 1.3, ('foo',)}</code></pre>\n<p>但这个集合就不行：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; invalid_set = {'foo', [1, 2, 3]}\n...\nTypeError: unhashable type: 'list'</code></pre>\n<p>正如上面的报错信息所示，集合里只能存放“可哈希”（hashable）的对象。假如把不可哈希的对象（比如上面的列表）放入集合，程序就会抛出 <code>TypeError</code> 异常。</p>\n<p>在使用集合时，可哈希性是个非常重要的概念，下面我们来看看什么决定了对象的可哈希性。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_57\">3.1.8　了解对象的可哈希性</h3>\n<p>在介绍字典类型时，我们说过字典底层使用了哈希表数据结构，其实集合也一样。当我们把某个对象放进集合或者作为字典的键使用时，解释器都需要对该对象进行一次哈希运算，得到哈希值，然后再进行后面的操作。</p>\n<p>这个计算哈希值的过程，是通过调用内置函数 <code>hash(obj)</code> 完成的。如果对象是可哈希的，<code>hash</code> 函数会返回一个整型结果，否则将会报 <code>TypeError</code> 错误。</p>\n<p>因此，要把某个对象放进集合，那它就必须是“可哈希”的。话说到这里，到底哪些类型是可哈希的？哪些又是不可哈希的呢？我们来试试看。</p>\n<p>首先，那些不可变的内置类型都是可哈希的：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; hash('string')\n-3407286361374970639\n&gt;&gt;&gt; hash(100)\n# 有趣的事情，整型的 hash 值就是它自身的值\n100\n&gt;&gt;&gt; hash((1, 2, 3))\n529344067295497451</code></pre>\n<p>而可变的内置类型都无法正常计算哈希值：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; hash({'key': 'value'})\nTypeError: unhashable type: 'dict'\n&gt;&gt;&gt; hash([1, 2, 3])\nTypeError: unhashable type: 'list'</code></pre>\n<p>可变类型的不可哈希特点有一定的“传染性”。比如在一个原本可哈希的元组里放入可变的列表对象后，它也会马上变得不可哈希：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; hash((1, 2, 3, ['foo', 'bar']))\nTypeError: unhashable type: 'list'</code></pre>\n<p>由用户定义的所有对象默认都是可哈希的：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; class Foo:\n...     pass\n...\n&gt;&gt;&gt; foo = Foo()\n&gt;&gt;&gt; hash(foo)\n273594269</code></pre>\n<p>总结一下，某种类型是否可哈希遵循下面的规则：</p>\n<p>(1) 所有的不可变内置类型，都是可哈希的，比如 <code>str</code>、<code>int</code>、<code>tuple</code>、<code>frozenset</code> 等；</p>\n<p>(2) 所有的可变内置类型，都是不可哈希的，比如 <code>dict</code>、<code>list</code> 等；</p>\n<p>(3) 对于不可变容器类型 <code>(tuple, frozenset)</code>，仅当它的所有成员都不可变时，它自身才是可哈希的；</p>\n<p>(4) 用户定义的类型默认都是可哈希的。</p>\n<p>谨记，只有可哈希的对象，才能放进集合或作为字典的键使用。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00372.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　在 12.2 节中，你可以读到一个深度使用可哈希概念的案例故事。</p>\n</blockquote>\n<h3 id=\"nav_point_58\">3.1.9　深拷贝与浅拷贝</h3>\n<p>在 3.1.2 节中，我们学习了对象的可变性概念，并看到了可变性如何影响代码的行为。在操作这些可变对象时，如果不拷贝原始对象就修改，可能会产生我们并不期待的结果。</p>\n<p>比如在下面的代码里，<code>nums</code> 和 <code>nums_copy</code> 两个变量就指向了同一个列表，修改 <code>nums</code> 的同时会影响 <code>nums_copy</code>：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; nums = [1, 2, 3, 4]\n&gt;&gt;&gt; nums_copy = nums\n&gt;&gt;&gt; nums[2] = 30\n&gt;&gt;&gt; nums_copy ➊\n[1, 2, 30, 4]</code></pre>\n<blockquote>\n<p>❶ <code>nums_copy</code> 的内容也发生了变化</p>\n</blockquote>\n<p>假如我们想让两个变量的修改操作互不影响，就需要拷贝变量所指向的可变对象，做到让不同变量指向不同对象。按拷贝的深度，常用的拷贝操作可分为两种：浅拷贝与深拷贝。</p>\n<ol>\n<li><p><strong>浅拷贝</strong></p>\n<p>要进行浅拷贝，最通用的办法是使用 <code>copy</code> 模块下的 <code>copy()</code> 方法：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; import copy\n&gt;&gt;&gt; nums_copy = copy.copy(nums)\n&gt;&gt;&gt; nums[2] = 30\n\n# 修改不再相互影响\n&gt;&gt;&gt; nums, nums_copy\n([1, 2, 30, 4], [1, 2, 3, 4])</code></pre>\n<p>除了使用 <code>copy()</code> 函数外，对于那些支持推导式的类型，用推导式也可以产生一个浅拷贝对象：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d = {'foo': 1}\n&gt;&gt;&gt; d2 = \n&gt;&gt;&gt; d['foo'] = 2\n&gt;&gt;&gt; d, d2\n({'foo': 2}, {'foo': 1})</code></pre>\n<p>使用各容器类型的内置构造函数，同样能实现浅拷贝效果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d2 = dict(d.items()) ➊\n&gt;&gt;&gt; nums_copy = list(nums) ➋</code></pre>\n<blockquote>\n<p>❶ 以字典 <code>d</code> 的内容构建一个新字典</p>\n<p>❷ 以列表 <code>nums</code> 的成员构建一个新列表</p>\n</blockquote>\n<p>对于支持切片操作的容器类型——比如列表、元组，对其进行全切片也可以实现浅拷贝效果：</p>\n<pre class=\"code-rows\"><code># nums_copy 会变成 nums 的浅拷贝\n&gt;&gt;&gt; nums_copy = nums[:]</code></pre>\n<p>除了上面这些办法，有些类型自身就提供了浅拷贝方法，可以直接使用：</p>\n<pre class=\"code-rows\"><code># 列表有 copy 方法\n&gt;&gt;&gt; num = [1, 2, 3, 4]\n&gt;&gt;&gt; nums.copy()\n[1, 2, 3, 4]\n\n# 字典也有 copy 方法\n&gt;&gt;&gt; d = {'foo': 'bar'}\n&gt;&gt;&gt; d.copy()\n{'foo': 'bar'}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>深拷贝</strong></p>\n<p>大部分情况下，上面的浅拷贝操作足以满足我们对可变类型的复制需求。但对于一些层层嵌套的复杂数据来说，浅拷贝仍然无法解决嵌套对象被修改的问题。</p>\n<p>比如，下面的 <code>items</code> 是一个嵌套了子列表的多级列表：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; items = [1, ['foo', 'bar'], 2, 3]</code></pre>\n<p>如果只是使用 <code>copy.copy()</code> 对 <code>items</code> 进行浅拷贝，你会发现它并不能做到完全隔离两个变量：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; import copy\n&gt;&gt;&gt; items_copy = copy.copy(items)\n&gt;&gt;&gt; items[0] = 100 ➊\n&gt;&gt;&gt; items[1].append('xxx') ➋\n&gt;&gt;&gt; items\n[100, ['foo', 'bar', 'xxx'], 2, 3]\n&gt;&gt;&gt; items_copy ➌\n[1, ['foo', 'bar', 'xxx'], 2, 3]</code></pre>\n<blockquote>\n<p>❶ 修改 <code>items</code> 的第一层成员</p>\n<p>❷ 修改 <code>items</code> 的第二层成员，往子列表内追加元素</p>\n<p>❸ 对 <code>items[1]</code> 的第一层修改没有影响浅拷贝对象，<code>items_copy[0]</code> 仍然是 <code>1</code>，但对嵌套子列表 <code>items[1]</code> 的修改已经影响了 <code>items_copy[1]</code> 的值，列表内多出了 <code>'xxx'</code></p>\n</blockquote>\n<p>之所以会出现这样的结果，是因为即便对 <code>items</code> 做了浅拷贝，<code>items[1]</code> 和 <code>items_copy[1]</code> 指向的仍旧是同一个列表。如果使用 <code>id()</code> 函数查看它们的对象 ID，会发现它们其实是同一个对象：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; id(items[1]), id(items_copy[1])\n(4467751104, 4467751104)</code></pre>\n<p>要解决这个问题，可以用 <code>copy.deepcopy()</code> 函数来进行深拷贝操作：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; items_deep = copy.deepcopy(items)</code></pre>\n<p>深拷贝会遍历并拷贝 <code>items</code> 里的所有内容——包括它所嵌套的子列表。做完深拷贝后，<code>items</code> 和 <code>items_deep</code> 的子列表不再是同一个对象，它们的修改操作自然也不会再相互影响：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; id(items[1]), id(items_deep[1]) ➊\n(4467751104, 4467286400)</code></pre>\n<blockquote>\n<p>❶ 子列表的对象 ID 不再一致</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"nav_point_59\">3.2　案例故事</h2>\n<p>虽然 Python 已经内置了不少强大的容器类型，但在这些内置容器的基础上，我们还能方便地创造新的容器类型，设计更好用的自定义数据结构。</p>\n<p>在下面这个案例故事里，“我”就来设计一个自定义字典类型，利用它重构一段数据分析脚本。</p>\n<h3 id=\"nav_point_60\">分析网站访问日志</h3>\n<p>几个月前，我开始利用业余时间开发一个 Python 资讯类网站 PyNews，上面汇集了许多 Python 相关的精品技术文章，用户可以免费浏览这些文章，学习最新的 Python 技术。</p>\n<p>上周六，我把 PyNews 部署到了线上。令我没想到的是，这个小网站居然特别受欢迎，在没怎么宣传的情况下，日访问量节节攀升，一周以后，每日浏览人数居然已经突破了 1000。</p>\n<p>但随着用户访问量的增加，越来越多的用户开始向我抱怨：“网站访问速度太慢了！”我心想：“这不行啊，访问速度这么慢，用户不就全跑了嘛！”于是，我决定马上开始优化 PyNews 的访问速度。</p>\n<p>要优化性能，第一步永远是找到性能瓶颈。刚好，我把网站所有页面的访问耗时都记录在了一个访问日志里。因此，我准备先分析访问日志，看看究竟是哪些页面在“拖后腿”。</p>\n<p>访问日志文件格式如下：</p>\n<pre class=\"code-rows\"><code># 格式：请求路径 请求耗时（毫秒）\n/articles/three-tips-on-writing-file-related-codes/ 120\n/articles/15-thinking-in-edge-cases/ 400\n/admin/ 3275\n...</code></pre>\n<p>日志里记录了每次请求的路径与耗时。基于这些日志，我决定先写一个访问分析脚本，把请求数据按路径分组，然后再依据耗时将其划为不同的性能等级，从而找到迫切需要优化的页面。</p>\n<p>基于我的设计，响应时间被分为四个性能等级。</p>\n<p>(1) 非常快：小于 100 毫秒。</p>\n<p>(2) 较快：100 到 300 毫秒之间。</p>\n<p>(3) 较慢：300 毫秒到 1 秒之间。</p>\n<p>(4) 慢：大于 1 秒。</p>\n<p>理想的解析结果如下所示：</p>\n<pre class=\"code-rows\"><code>---\n== Path: /articles/three-tips-on-writing-file-related-codes/\n   Total requests: 828\n   Performance:\n     - Less than 100 ms: 16\n     - Between 100 and 300 ms: 35\n     - Between 300 ms and 1 s: 119\n     - Greater than 1 s: 696\n== Path: /\n...\n---</code></pre>\n<p>脚本会按分组输出请求路径、总请求数以及各性能等级请求数。</p>\n<p>因为原始日志格式很简单，非常容易解析，所以我很快就写完了整个脚本，如代码清单 3-1 所示。</p>\n<blockquote>\n<p><strong>代码清单 3-1</strong>　日志分析脚本 analyzer_v1.py</p>\n</blockquote>\n<pre class=\"code-rows\"><code>from enum import Enum\n\n\nclass PagePerfLevel(str, Enum):\n    LT_100 = 'Less than 100 ms'\n    LT_300 = 'Between 100 and 300 ms'\n    LT_1000 = 'Between 300 ms and 1 s'\n    GT_1000 = 'Greater than 1 s'\n\n\ndef analyze_v1():\n    path_groups = {}\n    with open(\"logs.txt\", \"r\") as fp:\n        for line in fp:\n            path, time_cost_str = line.strip().split()\n\n            # 根据页面耗时计算性能等级\n            time_cost = int(time_cost_str)\n            if time_cost &lt; 100:\n                level = PagePerfLevel.LT_100\n            elif time_cost &lt; 300:\n                level = PagePerfLevel.LT_300\n            elif time_cost &lt; 1000:\n                level = PagePerfLevel.LT_1000\n            else:\n                level = PagePerfLevel.GT_1000\n\n            # 如果路径第一次出现，存入初始值\n            if path not in path_groups:\n                path_groups[path] = {}\n\n            # 如果性能 level 第一次出现，存入初始值 1\n            try:\n                path_groups[path][level] += 1\n            except KeyError:\n                path_groups[path][level] = 1\n\n    for path, result in path_groups.items():\n        print(f'== Path: ')\n        total = sum(result.values())\n        print(f'   Total requests: ')\n        print(f'   Performance:')\n\n        # 在输出结果前，按照“性能等级”在 PagePerfLevel 里面的顺序排列，小于 100 毫秒\n        # 的在最前面\n        sorted_items = sorted(\n            result.items(), key=lambda pair: list(PagePerfLevel).index(pair[0])\n        )\n        for level_name, count in sorted_items:\n            print(f'     - : ')\n\n\nif __name__ == \"__main__\":\n    analyze_v1()</code></pre>\n<p>在上面的代码里，我首先在最外层定义了枚举类型 <code>PagePerfLevel</code>，用于表示不同的请求性能等级，随后在 <code>analyze_v1()</code> 内实现了所有的主逻辑。其中的关键步骤有：</p>\n<p>(1) 遍历整个日志文件，逐行解析请求路径（<code>path</code>）与耗时（<code>time_cost</code>）；</p>\n<p>(2) 根据耗时计算请求属于哪个性能等级；</p>\n<p>(3) 判断请求路径是否初次出现，如果是，以<strong>子字典</strong>初始化 <code>path_groups</code> 里的对应值；</p>\n<p>(4) 对<strong>子字典</strong>的对应性能等级 <code>key</code>，执行请求数加 1 操作。</p>\n<p>经以上步骤完成数据统计后，在输出每组路径的结果时，函数不能直接遍历 <code>result.items()</code>，而是要先参照 <code>PagePerfLevel</code> 枚举类按性能等级排好序，然后再输出。</p>\n<p>在线上测试试用这个脚本后，我发现它可以正常分析请求、输出性能分组信息，达到了我的预期。</p>\n<p>不过，虽然脚本功能正常，但我总觉得它的代码写得不太好。一个最直观的感受是：<code>analyze_v1()</code> 函数里的逻辑特别复杂，耗时转级别、请求数累加的逻辑，全都被糅在了一块，整个函数读起来很困难。</p>\n<p>另一个问题是，代码里分布着太多零碎的字典操作，比如 <code>if path not in path_groups</code>、<code>try: ... except KeyError:</code>，等等，看上去非常不利落。</p>\n<p>于是我决定花点儿时间重构一下这份脚本，解决上述两个问题。</p>\n<ol>\n<li><p><strong>使用 <code>defaultdict</code> 类型</strong></p>\n<p>在上面的代码里，有两种字典操作看上去有点儿像：</p>\n<pre class=\"code-rows\"><code># 1\n# 如果路径第一次出现，存入初始值\nif path not in path_groups:\n    path_groups[path] = {}\n\n# 2\n# 如果性能 level 第一次出现，存入初始值 1\ntry:\n    path_groups[path][level] += 1\nexcept KeyError:\n    path_groups[path][level] = 1</code></pre>\n<p>当 <code>path</code> 和 <code>level</code> 变量作为字典的 <code>key</code> 第一次出现时，为了正常处理它们，代码同时用了两种操作：先判断后初始化；直接操作并捕获 <code>KeyError</code> 异常。我们在 3.1.5 节学过，除了这么操作，其实还可以使用字典的 <code>.get()</code> 和 <code>.setdefault()</code> 方法来简化代码。</p>\n<p>但在这个场景下，内置模块 <code>collections</code> 里的 <code>defaultdict</code> 类型才是最好的选择。</p>\n<p><code>defaultdict(default_factory, ...)</code> 是一种特殊的字典类型。它在被初始化时，接收一个可调用对象 <code>default_factory</code> 作为参数。之后每次进行 <code>d[key]</code> 操作时，如果访问的 <code>key</code> 不存在，<code>defaultdict</code> 对象会自动调用 <code>default_factory()</code> 并将结果作为值保存在对应的 <code>key</code> 里。</p>\n<p>为了更好地理解 <code>defaultdict</code> 的特点，我们来做个小实验。首先初始化一个空 <code>defaultdict</code> 对象：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; from collections import defaultdict\n&gt;&gt;&gt; int_dict = defaultdict(int)</code></pre>\n<p>然后直接对一个不存在的 <code>key</code> 执行累加操作。普通字典在执行这个操作时，会抛出 <code>KeyError</code> 异常，但 <code>defaultdict</code> 不会：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; int_dict['foo'] += 1</code></pre>\n<p>当 <code>int_dict</code> 发现键 <code>'foo'</code> 不存在时，它会调用 <code>default_factory</code>——也就是 <code>int()</code>——拿到结果 <code>0</code>，将其保存到字典后再执行累加操作：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; int_dict\ndefaultdict(&lt;class 'int'&gt;, {'foo': 1})\n&gt;&gt;&gt; dict(int_dict)\n{'foo': 1}</code></pre>\n<p>通过引入 <code>defaultdict</code> 类型，代码的两处初始化逻辑都变得更简单了。</p>\n<p>接下来，我们需要解决 <code>analyze_v1()</code> 函数内部逻辑过于杂乱的问题。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 <code>MutableMapping</code> 创建自定义字典类型</strong></p>\n<p>在前面的函数里，有一段核心的字典操作代码：先通过 <code>time_cost</code> 计算出 <code>level</code>，然后以 <code>level</code> 为键将请求数保存到字典中。这段代码的逻辑比较独立，假如把它从函数中抽离出来，代码会变得更好理解。</p>\n<p>此时就该自定义字典类型闪亮登场了。自定义字典和普通字典很像，但它可以给字典的默认行为加上一些变化。比如在这个场景下，我们会让字典在操作“响应耗时”键时，直接将其翻译成对应的性能等级。</p>\n<p>在 Python 中定义一个字典类型，可通过继承 <code>MutableMapping</code> 抽象类来实现，如代码清单 3-2 所示。</p>\n<blockquote>\n<p><strong>代码清单 3-2</strong>　用于存储响应时间的自定义字典</p>\n</blockquote>\n<pre class=\"code-rows\"><code>from collections.abc import MutableMapping\n　\n　\nclass PerfLevelDict(MutableMapping):\n    \"\"\"存储响应时间性能等级的字典\"\"\"\n\n    def __init__(self):\n        self.data = defaultdict(int)\n\n    def __getitem__(self, key):\n        \"\"\"当某个级别不存在时，默认返回 0\"\"\"\n        return self.data[self.compute_level(key)]\n\n    def __setitem__(self, key, value):\n        \"\"\"将 key 转换为对应的性能等级，然后设置值\"\"\"\n        self.data[self.compute_level(key)] = value\n\n    def __delitem__(self, key):\n        del self.data[key]\n\n    def __iter__(self):\n        return iter(self.data)\n\n    def __len__(self):\n        return len(self.data)\n\n    @staticmethod\n    def compute_level(time_cost_str):\n        \"\"\"根据响应时间计算性能等级\"\"\"\n        # 假如已经是性能等级，不做转换直接返回\n        if time_cost_str in list(PagePerfLevel):\n            return time_cost_str\n\n        time_cost = int(time_cost_str)\n        if time_cost &lt; 100:\n            return PagePerfLevel.LT_100\n        elif time_cost &lt; 300:\n            return PagePerfLevel.LT_300\n        elif time_cost &lt; 1000:\n            return PagePerfLevel.LT_1000\n        return PagePerfLevel.GT_1000</code></pre>\n<p>在上面的代码中，我编写了一个继承了 <code>MutableMapping</code> 的字典类 <code>PerfLevelDict</code>。但光继承还不够，要让这个类变得像字典一样，还需要重写包括 <code>__getitem__</code>、<code>__setitem__</code> 在内的 6 个魔法方法。</p>\n<p>其中最重要的几点简单说明如下：</p>\n<ul>\n<li>在 <code>__init__</code> 初始化方法里，使用 <code>defaultdict(int)</code> 对象来简化字典的空值初始化操作；</li>\n<li><code>__getitem__</code> 方法定义了 <code>d[key]</code> 取值操作时的行为；</li>\n<li><code>__setitem__</code> 方法定义了 <code>d[key] = value</code> 赋值操作时的行为；</li>\n<li><code>PerfLevelDict</code> 的 <code>__getitem__/__setitem__</code> 方法和普通字典的最大不同，在于操作前调用了 <code>compute_level()</code>，将字典键转成了性能等级。</li>\n</ul>\n<p>我们来试用一下 <code>PerfLevelDict</code> 类：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d = PerfLevelDict()\n&gt;&gt;&gt; d[50] += 1\n&gt;&gt;&gt; d[403] += 12\n&gt;&gt;&gt; d[30] += 2\n&gt;&gt;&gt; dict(d)\n{&lt;PagePerfLevel.LT_100: 'Less than 100 ms'&gt;: 3, &lt;PagePerfLevel.LT_1000: 'Between 300 ms and 1 s'&gt;: 12}</code></pre>\n<p>有了 <code>PerfLevelDict</code> 类以后，我们不需要再去手动做“耗时→级别”转换了，一切都可以由自定义字典的内部逻辑处理好。</p>\n<p>创建自定义字典类还带来了一个额外的好处。在之前的代码里，有许多有关字典的零碎操作，比如求和、对 <code>.items()</code> 排序等，现在它们全都可以封装到 <code>PerfLevelDict</code> 类里，代码逻辑不再是东一块、西一块，而是全部由一个数据类搞定。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>代码重构</strong></p>\n<p>使用 <code>defaultdict</code> 和自定义字典类以后，代码最终优化成了代码清单 3-3 所示的样子。</p>\n<blockquote>\n<p><strong>代码清单 3-3</strong>　重构后的日志分析脚本 analyzer_v2.py</p>\n</blockquote>\n<pre class=\"code-rows\"><code>from enum import Enum\nfrom collections import defaultdict\nfrom collections.abc import MutableMapping\n　\n　\nclass PagePerfLevel(str, Enum):\n    LT_100 = 'Less than 100 ms'\n    LT_300 = 'Between 100 and 300 ms'\n    LT_1000 = 'Between 300 ms and 1 s'\n    GT_1000 = 'Greater than 1 s'\n　\n　\nclass PerfLevelDict(MutableMapping):\n    \"\"\"存储响应时间性能等级的字典\"\"\"\n\n    def __init__(self):\n        self.data = defaultdict(int)\n\n    def __getitem__(self, key):\n        \"\"\"当某个性能等级不存在时，默认返回 0\"\"\"\n        return self.data[self.compute_level(key)]\n\n    def __setitem__(self, key, value):\n        \"\"\"将 key 转换为对应的性能等级，然后设置值\"\"\"\n        self.data[self.compute_level(key)] = value\n\n    def __delitem__(self, key):\n        del self.data[key]\n\n    def __iter__(self):\n        return iter(self.data)\n\n    def __len__(self):\n        return len(self.data)\n\n    def items(self):\n        \"\"\"按照顺序返回性能等级数据\"\"\"\n        return sorted(\n            self.data.items(),\n            key=lambda pair: list(PagePerfLevel).index(pair[0]),\n        )\n\n    def total_requests(self):\n        \"\"\"返回总请求数\"\"\"\n        return sum(self.values())\n\n    @staticmethod\n    def compute_level(time_cost_str):\n        \"\"\"根据响应时间计算性能等级\"\"\"\n        if time_cost_str in list(PagePerfLevel):\n            return time_cost_str\n\n        time_cost = int(time_cost_str)\n        if time_cost &lt; 100:\n            return PagePerfLevel.LT_100\n        elif time_cost &lt; 300:\n            return PagePerfLevel.LT_300\n        elif time_cost &lt; 1000:\n            return PagePerfLevel.LT_1000\n        return PagePerfLevel.GT_1000\n\ndef analyze_v2():\n    path_groups = defaultdict(PerfLevelDict)\n    with open(\"logs.txt\", \"r\") as fp:\n        for line in fp:\n            path, time_cost = line.strip().split()\n            path_groups[path][time_cost] += 1\n\n    for path, result in path_groups.items():\n        print(f'== Path: ')\n        print(f'   Total requests: ')\n        print(f'   Performance:')\n        for level_name, count in result.items():\n            print(f'     - : ')\n　\n　\nif __name__ == '__main__':\n    analyze_v2()</code></pre>\n<p>阅读这段新代码，你可以明显感受到 <code>analyze_v2()</code> 函数相比之前的变化非常大。有了自定义字典 <code>PerfLevelDict</code> 的帮助，<code>analyze_v2()</code> 函数的整个逻辑变得非常清晰、非常容易理解——它只负责解析日志与打印结果，其他统计逻辑都交由 <code>PerfLevelDict</code> 负责。</p>\n<blockquote>\n<p><strong>为何不直接继承 <code>dict</code>？</strong></p>\n<p>在实现自定义字典时，我让 <code>PerfLevelDict</code> 继承了 <code>collections.abc</code> 下的 <code>MutableMapping</code> 抽象类，而不是内置字典 <code>dict</code>。这看起来有点儿奇怪，因为从直觉上说，假如你想实现某个自定义类型，最方便的选择就是继承原类型。</p>\n<p>但是，如果真的继承 <code>dict</code> 来创建自定义字典类型，你会碰到很多问题。</p>\n<p>拿一个最常见的场景来说，假如你继承了 <code>dict</code>，通过 <code>__setitem__</code> 方法重写了它的键赋值操作。此时，虽然常规的 <code>d[key] = value</code> 行为会被重写；但假如调用方使用 <code>d.update(...)</code> 来更新字典内容，就根本不会触发重写后的键赋值逻辑。这最终会导致自定义类型的行为不一致。</p>\n<p>举个简单的例子，下面的 <code>UpperDict</code> 是继承了 <code>dict</code> 的自定义字典类型：</p>\n<pre class=\"code-rows\"><code>class UpperDict(dict):\n    \"\"\"总是把 key 转为大写\"\"\"\n\n    def __setitem__(self, key, value):\n        super().__setitem__(key.upper(), value)</code></pre>\n<p>试着使用 <code>UpperDict</code>：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d = UpperDict()\n&gt;&gt;&gt; d['foo'] = 1  ➊\n&gt;&gt;&gt; d\n{'FOO': 1}\n&gt;&gt;&gt; d.update({'bar': 2})  ➋\n&gt;&gt;&gt; d\n{'FOO': 1, 'bar': 2}</code></pre>\n<blockquote>\n<p>➊ 直接对字典键赋值，触发了大写转换逻辑</p>\n<p>➋ 调用 <code>.update(...)</code> 方法并不会触发任何自定义逻辑</p>\n</blockquote>\n<p>正因如此，如果你想创建一个自定义字典，继承 <code>collections.abc</code> 下的 <code>MutableMapping</code> 抽象类是个更好的选择，因为它没有上面的问题。而对于列表等其他容器类型来说，这条规则也同样适用。</p>\n<p>有关这个话题，你可以阅读 Trey Hunner 的文章“The problem with inheriting from dict and list in Python”了解详情。</p>\n</blockquote>\n</li>\n</ol>\n","comments":[{"had_liked":false,"id":389034,"user_name":"rs勿忘初心","can_delete":false,"product_type":"c1","uid":1519200,"ip_address":"北京","ucode":"557D1ECD757195","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/60/4fa1f3bd.jpg","comment_is_top":false,"comment_ctime":1711423515,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636605,"comment_content":"好多代码看着都不完整？麻烦编辑和作者可以帮忙校对下，避免误导读者或者增加阅读成本。\n\nfor path, result in path_groups.items(): print(f&#39;== Path: &#39;) print(f&#39; Total requests: &#39;) print(f&#39; Performance:&#39;) for level_name, count in result.items(): print(f&#39; - : &#39;)","like_count":0},{"had_liked":false,"id":388837,"user_name":"rs勿忘初心","can_delete":false,"product_type":"c1","uid":1519200,"ip_address":"北京","ucode":"557D1ECD757195","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/60/4fa1f3bd.jpg","comment_is_top":false,"comment_ctime":1710985260,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636605,"comment_content":"3.15这段代码看着不完整？\n\n&gt;&gt;&gt; d1 = {&#39;foo&#39;: 3, &#39;bar&#39;: 4}\n&gt;&gt;&gt; \n{&#39;foo&#39;: 30}","like_count":0}]}