{"id":128038,"title":"16 | 缓存策略：如何使用缓存来减少磁盘IO？","content":"<p>你好，我是李玥。这节课，我们一起来聊一聊缓存策略。</p><p>现代的消息队列，都使用磁盘文件来存储消息。因为磁盘是一个持久化的存储，即使服务器掉电也不会丢失数据。绝大多数用于生产系统的服务器，都会使用多块儿磁盘组成磁盘阵列，这样不仅服务器掉电不会丢失数据，即使其中的一块儿磁盘发生故障，也可以把数据从其他磁盘中恢复出来。</p><p>使用磁盘的另外一个原因是，磁盘很便宜，这样我们就可以用比较低的成本，来存储海量的消息。所以，不仅仅是消息队列，几乎所有的存储系统的数据，都需要保存到磁盘上。</p><p>但是，磁盘它有一个致命的问题，就是读写速度很慢。它有多慢呢？一般来说SSD（固态硬盘）每秒钟可以读写几千次，如果说我们的程序在处理业务请求的时候直接来读写磁盘，假设处理每次请求需要读写3～5次，即使每次请求的数据量不大，你的程序最多每秒也就能处理1000次左右的请求。</p><p>而内存的随机读写速度是磁盘的10万倍！所以，<strong>使用内存作为缓存来加速应用程序的访问速度，是几乎所有高性能系统都会采用的方法。</strong></p><p>缓存的思想很简单，就是把低速存储的数据，复制一份副本放到高速的存储中，用来加速数据的访问。缓存使用起来也非常简单，很多同学在做一些业务系统的时候，在一些执行比较慢的方法上加上一个@Cacheable的注解，就可以使用缓存来提升它的访问性能了。</p><!-- [[[read_end]]] --><p>但是，你是否考虑过，采用@Cacheable注解的方式缓存的命中率如何？或者说怎样才能提高缓存的命中率？缓存是否总能返回最新的数据？如果缓存返回了过期的数据该怎么办？接下来，我们一起来通过学习设计、使用缓存的最佳实践，找到这些问题的答案。</p><h2>选择只读缓存还是读写缓存？</h2><p>使用缓存，首先你就会面临选择读缓存还是读写缓存的问题。他们唯一的区别就是，在更新数据的时候，是否经过缓存。</p><p>我们之前的课中讲到Kafka使用的PageCache，它就是一个非常典型的读写缓存。操作系统会利用系统空闲的物理内存来给文件读写做缓存，这个缓存叫做PageCache。应用程序在写文件的时候，操作系统会先把数据写入到PageCache中，数据在成功写到PageCache之后，对于用户代码来说，写入就结束了。</p><p>然后，操作系统再异步地把数据更新到磁盘的文件中。应用程序在读文件的时候，操作系统也是先尝试从PageCache中寻找数据，如果找到就直接返回数据，找不到会触发一个缺页中断，然后操作系统把数据从文件读取到PageCache中，再返回给应用程序。</p><p>我们可以看到，在数据写到PageCache中后，它并不是同时就写到磁盘上了，这中间是有一个延迟的。操作系统可以保证，即使是应用程序意外退出了，操作系统也会把这部分数据同步到磁盘上。但是，如果服务器突然掉电了，这部分数据就丢失了。</p><p>你需要知道，<strong>读写缓存的这种设计，它天然就是不可靠的，是一种牺牲数据一致性换取性能的设计。</strong>当然，应用程序可以调用sync等系统调用，强制操作系统立即把缓存数据同步到磁盘文件中去，但是这个同步的过程是很慢的，也就失去了缓存的意义。</p><p>另外，写缓存的实现是非常复杂的。应用程序不停地更新PageCache中的数据，操作系统需要记录哪些数据有变化，同时还要在另外一个线程中，把缓存中变化的数据更新到磁盘文件中。在提供并发读写的同时来异步更新数据，这个过程中要保证数据的一致性，并且有非常好的性能，实现这些真不是一件容易的事儿。</p><p>所以说，一般情况下，不推荐你来使用读写缓存。</p><p>那为什么Kafka可以使用PageCache来提升它的性能呢？这是由消息队列的一些特点决定的。</p><p>首先，消息队列它的读写比例大致是1：1，因为，大部分我们用消息队列都是一收一发这样使用。这种读写比例，只读缓存既无法给写加速，读的加速效果也有限，并不能提升多少性能。</p><p>另外，Kafka它并不是只靠磁盘来保证数据的可靠性，它更依赖的是，在不同节点上的多副本来解决数据可靠性问题，这样即使某个服务器掉电丢失一部分文件内容，它也可以从其他节点上找到正确的数据，不会丢消息。</p><p>而且，PageCache这个读写缓存是操作系统实现的，Kafka只要按照正确的姿势来使用就好了，不涉及到实现复杂度的问题。所以，Kafka其实在设计上，充分利用了PageCache这种读写缓存的优势，并且规避了PageCache的一些劣势，达到了一个非常好的效果。</p><p>和Kafka一样，大部分其他的消息队列，同样也会采用读写缓存来加速消息写入的过程，只是实现的方式都不一样。</p><p>不同于消息队列，我们开发的大部分业务类应用程序，读写比都是严重不均衡的，一般读的数据的频次会都会远高于写数据的频次。从经验值来看，读次数一般都是写次数的几倍到几十倍。这种情况下，使用只读缓存来加速系统才是非常明智的选择。</p><p>接下来，我们一起来看一下，在构建一个只读缓存时，应该侧重考虑哪些问题。</p><h2>保持缓存数据新鲜</h2><p>对于只读缓存来说，缓存中的数据来源只有一个途径，就是从磁盘上来。当数据需要更新的时候，磁盘中的数据和缓存中的副本都需要进行更新。我们知道，在分布式系统中，除非是使用事务或者一些分布式一致性算法来保证数据一致性，否则，由于节点宕机、网络传输故障等情况的存在，我们是无法保证缓存中的数据和磁盘中的数据是完全一致的。</p><p>如果出现数据不一致的情况，数据一定是以磁盘上的那份拷贝为准。我们需要解决的问题就是，尽量让缓存中的数据与磁盘上的数据保持同步。</p><p>那选择什么时候来更新缓存中的数据呢？比较自然的想法是，我在更新磁盘中数据的同时，更新一下缓存中的数据不就可以了？这个想法是没有任何问题的，缓存中的数据会一直保持最新。但是，在并发的环境中，实现起来还是不太容易的。</p><p>你是选择同步还是异步来更新缓存呢？如果是同步更新，更新磁盘成功了，但是更新缓存失败了，你是不是要反复重试来保证更新成功？如果多次重试都失败，那这次更新是算成功还是失败呢？如果是异步更新缓存，怎么保证更新的时序？</p><p>比如，我先把一个文件中的某个数据设置成0，然后又设为1，这个时候文件中的数据肯定是1，但是缓存中的数据可不一定就是1了。因为把缓存中的数据更新为0，和更新为1是两个并发的异步操作，不一定谁会先执行。</p><p>这些问题都会导致缓存的数据和磁盘中的数据不一致，而且，在下次更新这条数据之前，这个不一致的问题它是一直存在的。当然，这些问题也不是不能解决的，比如，你可以使用分布式事务来解决，只是付出的性能、实现复杂度等代价比较大。</p><p>另外一种比较简单的方法就是，定时将磁盘上的数据同步到缓存中。一般的情况下，每次同步时直接全量更新就可以了，因为是在异步的线程中更新数据，同步的速度即使慢一些也不是什么大问题。如果缓存的数据太大，更新速度慢到无法接受，也可以选择增量更新，每次只更新从上次缓存同步至今这段时间内变化的数据，代价是实现起来会稍微有些复杂。</p><p>如果说，某次同步过程中发生了错误，等到下一个同步周期也会自动把数据纠正过来。这种定时同步缓存的方法，缺点是缓存更新不那么及时，优点是实现起来非常简单，鲁棒性非常好。</p><p>还有一种更简单的方法，我们从来不去更新缓存中的数据，而是给缓存中的每条数据设置一个比较短的过期时间，数据过期以后即使它还存在缓存中，我们也认为它不再有效，需要从磁盘上再次加载这条数据，这样就变相地实现了数据更新。</p><p>很多情况下，缓存的数据更新不那么及时，我们的系统也是能够接受的。比如说，你刚刚发了一封邮件，收件人过了一会儿才收到。或者说，你改了自己的微信头像，在一段时间内，你的好友看到的你还是旧的头像，这些都是可以接受的。这种对数据一致性没有那么敏感的场景下，你一定要选择后面两种方法。</p><p>而像交易类的系统，它对数据的一致性非常敏感。比如，你给别人转了一笔钱，别人查询自己余额却没有变化，这种情况肯定是无法接受的。对于这样的系统，一般来说，都不使用缓存或者使用我们提到的第一种方法，在更新数据的时候同时来更新缓存。</p><h2>缓存置换策略</h2><p>在使用缓存的过程中，除了要考虑数据一致性的问题，你还需要关注的另一个重要的问题是，在内存有限的情况下，要优先缓存哪些数据，让缓存的命中率最高。</p><p>当应用程序要访问某些数据的时候，如果这些数据在缓存中，那直接访问缓存中的数据就可以了，这次访问的速度是很快的，这种情况我们称为一次缓存命中；如果这些数据不在缓存中，那只能去磁盘中访问数据，就会比较慢。这种情况我们称为“缓存穿透”。显然，缓存的命中率越高，应用程序的总体性能就越好。</p><p>那用什么样的策略来选择缓存的数据，能使得缓存的命中率尽量高一些呢？</p><p>如果你的系统是那种可以预测未来访问哪些数据的系统，比如说，有的系统它会定期做数据同步，每次同步的数据范围都是一样的，像这样的系统，缓存策略很简单，就是你要访问什么数据，就缓存什么数据，甚至可以做到百分之百的命中。</p><p>但是，大部分系统，它并没有办法准确地预测未来会有哪些数据会被访问到，所以只能使用一些策略来尽可能地提高缓存命中率。</p><p>一般来说，我们都会在数据首次被访问的时候，顺便把这条数据放到缓存中。随着访问的数据越来越多，总有把缓存占满的时刻，这个时候就需要把缓存中的一些数据删除掉，以便存放新的数据，这个过程称为缓存置换。</p><p>到这里，问题就变成了：当缓存满了的时候，删除哪些数据，才能会使缓存的命中率更高一些，也就是采用什么置换策略的问题。</p><p><strong>命中率最高的置换策略，一定是根据你的业务逻辑，定制化的策略。</strong>比如，你如果知道某些数据已经删除了，永远不会再被访问到，那优先置换这些数据肯定是没问题的。再比如，你的系统是一个有会话的系统，你知道现在哪些用户是在线的，哪些用户已经离线，那优先置换那些已经离线用户的数据，尽量保留在线用户的数据也是一个非常好的策略。</p><p>另外一个选择，就是使用通用的置换算法。一个最经典也是最实用的算法就是LRU算法，也叫最近最少使用算法。这个算法它的思想是，最近刚刚被访问的数据，它在将来被访问的可能性也很大，而很久都没被访问过的数据，未来再被访问的几率也不大。</p><p>基于这个思想，<strong>LRU的算法原理非常简单，它总是把最长时间未被访问的数据置换出去。</strong>你别看这个LRU算法这么简单，它的效果是非常非常好的。</p><p>Kafka使用的PageCache，是由Linux内核实现的，它的置换算法的就是一种LRU的变种算法<br>\n：LRU 2Q。我在设计JMQ的缓存策略时，也是采用一种改进的LRU算法。LRU淘汰最近最少使用的页，JMQ根据消息这种流数据存储的特点，在淘汰时增加了一个考量维度：页面位置与尾部的距离。因为越是靠近尾部的数据，被访问的概率越大。</p><p>这样综合考虑下的淘汰算法，不仅命中率更高，还能有效地避免“挖坟”问题：例如某个客户端正在从很旧的位置开始向后读取一批历史数据，内存中的缓存很快都会被替换成这些历史数据，相当于大部分缓存资源都被消耗掉了，这样会导致其他客户端的访问命中率下降。加入位置权重后，比较旧的页面会很快被淘汰掉，减少“挖坟”对系统的影响。</p><h2>小结</h2><p>这节课我们主要聊了一下，如何使用缓存来加速你的系统，减少磁盘IO。按照读写性质，可以分为读写缓存和只读缓存，读写缓存实现起来非常复杂，并且只在消息队列等少数情况下适用。只读缓存适用的范围更广，实现起来也更简单。</p><p>在实现只读缓存的时候，你需要考虑的第一个问题是如何来更新缓存。这里面有三种方法，第一种是在更新数据的同时去更新缓存，第二种是定期来更新全部缓存，第三种是给缓存中的每个数据设置一个有效期，让它自然过期以达到更新的目的。这三种方法在更新的及时性上和实现的复杂度这两方面，都是依次递减的，你可以按需选择。</p><p>对于缓存的置换策略，最优的策略一定是你根据业务来设计的定制化的置换策略，当然你也可以考虑LRU这样通用的缓存置换算法。</p><h2>思考题</h2><p>课后来写点儿代码吧，实现一个采用LRU置换算法的缓存。</p><pre><code>/**\n * KV存储抽象\n */\npublic interface Storage&lt;K,V&gt; {\n    /**\n     * 根据提供的key来访问数据\n     * @param key 数据Key\n     * @return 数据值\n     */\n    V get(K key);\n}\n\n/**\n * LRU缓存。你需要继承这个抽象类来实现LRU缓存。\n * @param &lt;K&gt; 数据Key\n * @param &lt;V&gt; 数据值\n */\npublic abstract class LruCache&lt;K, V&gt; implements Storage&lt;K,V&gt;{\n    // 缓存容量\n    protected final int capacity;\n    // 低速存储，所有的数据都可以从这里读到\n    protected final Storage&lt;K,V&gt; lowSpeedStorage;\n\n    public LruCache(int capacity, Storage&lt;K,V&gt; lowSpeedStorage) {\n        this.capacity = capacity;\n        this.lowSpeedStorage = lowSpeedStorage;\n    }\n}\n</code></pre><p>你需要继承LruCache这个抽象类，实现你自己的LRU缓存。lowSpeedStorage是提供给你可用的低速存储，你不需要实现它。</p><p>欢迎你把代码上传到GitHub上，然后在评论区给出访问链接。大家来比一下，谁的算法性能更好。如果你有任何问题，也可以在评论区留言与我交流。</p><p>感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给你的朋友。</p><p></p>","comments":[{"had_liked":false,"id":129282,"user_name":"大白给小白讲故事","can_delete":false,"product_type":"c1","uid":1258557,"ip_address":"","ucode":"4538C24B67B513","user_header":"https://static001.geekbang.org/account/avatar/00/13/34/3d/51762e76.jpg","comment_is_top":false,"comment_ctime":1567078018,"is_pvip":false,"replies":[{"id":48235,"content":"与尾部的距离=最后一个一条消息的尾部位置 - 页面的位置\n\n这个值越小，说明请求的数据与尾部越近，置换的时候被留下的概率也就越大。\n\n对于历史数据，由于距离远，这个值会很大，那这些页面在置换的时候被留下的概率就很小，所以很快就会被从内从中置换出去。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567139422,"ip_address":"","comment_id":129282,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"”⻚⾯位置与尾部的距离。因为越是靠近尾部的数据，被访问的概率越⼤“\n不大理解这句话，尾部指的是啥？当某个客户端正在从很旧的位置开始向后读取⼀批历史数据，是怎么判断与尾部的距离，从而减少这部分的缓存。","like_count":19},{"had_liked":false,"id":148864,"user_name":"Yasir","can_delete":false,"product_type":"c1","uid":1300809,"ip_address":"","ucode":"072D6DBB64C39E","user_header":"https://static001.geekbang.org/account/avatar/00/13/d9/49/cca41e79.jpg","comment_is_top":false,"comment_ctime":1573095883,"is_pvip":false,"replies":[{"id":57586,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573346910,"ip_address":"","comment_id":148864,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"交作业，双向链表实现\nhttps:&#47;&#47;github.com&#47;tuhao&#47;leetcode&#47;blob&#47;master&#47;src&#47;mqexercise&#47;LRUTest.java","like_count":9,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465381,"discussion_content":"与尾部的距离=最后一个一条消息的尾部位置 - 页面的位置\n\n这个值越小，说明请求的数据与尾部越近，置换的时候被留下的概率也就越大。\n\n对于历史数据，由于距离远，这个值会很大，那这些页面在置换的时候被留下的概率就很小，所以很快就会被从内从中置换出去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567139422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129084,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1567040466,"is_pvip":false,"replies":[{"id":48180,"content":"这个是理论上的数据，实际上取决于随机顺序读写还是顺序读写，读写数据大小，差别还是非常大的。像CPU和内存，他们标称的速度都是多少多少Hz，这个赫兹Hz的意思就是每秒钟多少次，其实就是它的极限tps。\n\n但实际我们执行一次数据读写或者一行代码，编译成CPU指令可能是几条指令，这样你就大概能推断出这条指令的执行速度应该是个什么量级的了。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567128656,"ip_address":"","comment_id":129084,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"文中说SSD硬盘的访问速度每秒几千次，内存是硬盘的10万倍，那就是亿这个数量级了，运行那么快呢？CPU的缓存假如说是内存的千倍那就到了千亿的数据级了，会有那么快吗？","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465267,"discussion_content":"这个是理论上的数据，实际上取决于随机顺序读写还是顺序读写，读写数据大小，差别还是非常大的。像CPU和内存，他们标称的速度都是多少多少Hz，这个赫兹Hz的意思就是每秒钟多少次，其实就是它的极限tps。\n\n但实际我们执行一次数据读写或者一行代码，编译成CPU指令可能是几条指令，这样你就大概能推断出这条指令的执行速度应该是个什么量级的了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567128656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156567,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1574913178,"is_pvip":false,"replies":[{"id":60578,"content":"你这个实现中，命中缓存后“移动元素到尾部”这个操作，同时会移动其它无关的元素的位置（从队头移到队尾），这样就不满足LRU的原则了，可以试试将队列换成链表这种可以支持随机写的数据结构。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1575334334,"ip_address":"","comment_id":156567,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，我在github上写了一个lru的实现。https:&#47;&#47;github.com&#47;fomeiherz&#47;code-snippet&#47;tree&#47;master&#47;lru\n\n使用了HashMap和Queue一起实现的。使用HashMap保存键值对可以实现O(1)复杂查询，使用队列保存key，头部出队，尾部入队。更新比较复杂，需要删除对应的元素后，才可以再入队，这里是O(n) 复杂度。\n\n老师，更新队列顺序时是否会有更快办法？或者有更快的实现办法呢？求指导","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476154,"discussion_content":"你这个实现中，命中缓存后“移动元素到尾部”这个操作，同时会移动其它无关的元素的位置（从队头移到队尾），这样就不满足LRU的原则了，可以试试将队列换成链表这种可以支持随机写的数据结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575334334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135270,"user_name":"13761642169","can_delete":false,"product_type":"c1","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1569115345,"is_pvip":false,"replies":[{"id":51963,"content":"对应的几个写文件的系统调用都会经过PageCache，比如write pwrite还有mmap","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569202429,"ip_address":"","comment_id":135270,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"PageCache是OS提供的能力，用户程序调用什么API才能使用到PageCache，为什么说kafka大量使用到PageCache，因为mmap？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468119,"discussion_content":"对应的几个写文件的系统调用都会经过PageCache，比如write pwrite还有mmap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569202429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145010,"user_name":"A9","can_delete":false,"product_type":"c1","uid":1053211,"ip_address":"","ucode":"76D07F8EBE8DD0","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/1b/f62722ca.jpg","comment_is_top":false,"comment_ctime":1572159587,"is_pvip":false,"replies":[{"id":56034,"content":"DirectBuffer确实也需要经过PageCache，但是它有更好的批量大小，写入时的系统调用次数也会更少，所以性能更好一些。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572242727,"ip_address":"","comment_id":145010,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"JMQ是如何使用自定义的LRU算法的？即使使用DirectBuffer不是也要经过PageCache吗？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472211,"discussion_content":"DirectBuffer确实也需要经过PageCache，但是它有更好的批量大小，写入时的系统调用次数也会更少，所以性能更好一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572242727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129889,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1567315872,"is_pvip":false,"replies":[{"id":48723,"content":"A1：是的。\nA2：是的。\n对于问题3和4，你可以看一下关于JMQ的这篇文章：\nhttps:&#47;&#47;www.jiqizhixin.com&#47;articles&#47;2019-01-21-19\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567491866,"ip_address":"","comment_id":129889,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"来晚了，根据jms和kafka这两节，我试着猜想一下jms的机制，顺便提个问题：\n1. 老师这节提到的jms实现的缓存机制，都是基于direct buffer自己实现的一个内存池，并实现了变种的LRU对么？这个缓存就是前面提到的journal cache，被writeThread&#47;RelicationThread&#47;FlushThread使用？\n2. 这个内存池看起来并没有借助于netty的direict buffer pool是吧？\n3. 那原谅我对比一下jms和rocket，jms没有基于mmap去做而选择direct buffer，看起来是为了：\na. 减少GC的压力\nb. 比mmap更容易控制，就更容增加缓存的命中率\n这样？\n4. 另外，有个概念我很模糊，有资料说direct buffer在写磁盘&#47;socket时并不能真的节省一次cpu copy？那这样的话jms可以说并没有利用zero copy？\n\n望解惑","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465698,"discussion_content":"A1：是的。\nA2：是的。\n对于问题3和4，你可以看一下关于JMQ的这篇文章：\nhttps://www.jiqizhixin.com/articles/2019-01-21-19\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567491866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212590,"user_name":"77","can_delete":false,"product_type":"c1","uid":1946562,"ip_address":"","ucode":"C57A8443814F7A","user_header":"","comment_is_top":false,"comment_ctime":1588158198,"is_pvip":false,"replies":[{"id":79191,"content":"读写缓存和只读缓存的区别是，数据在更新的时候，是否去更新缓存。\n\n至于是先更新缓存，还是先更新磁盘文件，这个取决于不同的缓存策略。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1588513476,"ip_address":"","comment_id":212590,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师问个问题，关于读写缓存和只读缓存第一种的区别是不是 读写缓存是更新缓存然后异步去更新磁盘文件，只读缓存是先更新磁盘在更新缓存呢？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493553,"discussion_content":"读写缓存和只读缓存的区别是，数据在更新的时候，是否去更新缓存。\n\n至于是先更新缓存，还是先更新磁盘文件，这个取决于不同的缓存策略。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588513476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130664,"user_name":"明日","can_delete":false,"product_type":"c1","uid":1003917,"ip_address":"","ucode":"348899EC65AE8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/8d/09f28606.jpg","comment_is_top":false,"comment_ctime":1567504162,"is_pvip":false,"replies":[{"id":48983,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567565331,"ip_address":"","comment_id":130664,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"Java实现: https:&#47;&#47;gist.github.com&#47;imgaoxin&#47;ed59397c895b5a8a9572408b98542015","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466056,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567565331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/a7df049a.jpg","nickname":"Standly","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7785,"discussion_content":"老哥你这个get()不是O(1), 链表remove还是要遍历，可以参考下LinkedHashMap的实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567674063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1003917,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/51/8d/09f28606.jpg","nickname":"明日","note":"","ucode":"348899EC65AE8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/a7df049a.jpg","nickname":"Standly","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7816,"discussion_content":"是的，只是实现了功能，效率还需优化😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567680653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7785,"ip_address":"","group_id":0},"score":7816,"extra":""}]}]},{"had_liked":false,"id":129514,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1567145901,"is_pvip":false,"replies":[{"id":48359,"content":"还有就是，读写缓存可以为写入加速，但牺牲了数据可靠性。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567213601,"ip_address":"","comment_id":129514,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"我感觉读写缓存和只读缓存的第一种更新策略(更新数据的同时更新缓存)是一样的吧？因为它们都需要同时更新数据和缓存，区别可能是读写缓存以更新缓存为主，只读缓存的第一种更新策略是以更新数据为主吗","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465516,"discussion_content":"还有就是，读写缓存可以为写入加速，但牺牲了数据可靠性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567213601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129282,"user_name":"大白给小白讲故事","can_delete":false,"product_type":"c1","uid":1258557,"ip_address":"","ucode":"4538C24B67B513","user_header":"https://static001.geekbang.org/account/avatar/00/13/34/3d/51762e76.jpg","comment_is_top":false,"comment_ctime":1567078018,"is_pvip":false,"replies":[{"id":48235,"content":"与尾部的距离=最后一个一条消息的尾部位置 - 页面的位置\n\n这个值越小，说明请求的数据与尾部越近，置换的时候被留下的概率也就越大。\n\n对于历史数据，由于距离远，这个值会很大，那这些页面在置换的时候被留下的概率就很小，所以很快就会被从内从中置换出去。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567139422,"ip_address":"","comment_id":129282,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"”⻚⾯位置与尾部的距离。因为越是靠近尾部的数据，被访问的概率越⼤“\n不大理解这句话，尾部指的是啥？当某个客户端正在从很旧的位置开始向后读取⼀批历史数据，是怎么判断与尾部的距离，从而减少这部分的缓存。","like_count":19,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465381,"discussion_content":"与尾部的距离=最后一个一条消息的尾部位置 - 页面的位置\n\n这个值越小，说明请求的数据与尾部越近，置换的时候被留下的概率也就越大。\n\n对于历史数据，由于距离远，这个值会很大，那这些页面在置换的时候被留下的概率就很小，所以很快就会被从内从中置换出去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567139422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148864,"user_name":"Yasir","can_delete":false,"product_type":"c1","uid":1300809,"ip_address":"","ucode":"072D6DBB64C39E","user_header":"https://static001.geekbang.org/account/avatar/00/13/d9/49/cca41e79.jpg","comment_is_top":false,"comment_ctime":1573095883,"is_pvip":false,"replies":[{"id":57586,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573346910,"ip_address":"","comment_id":148864,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"交作业，双向链表实现\nhttps:&#47;&#47;github.com&#47;tuhao&#47;leetcode&#47;blob&#47;master&#47;src&#47;mqexercise&#47;LRUTest.java","like_count":9,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473642,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573346910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116106,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/ca/abb7bfe3.jpg","nickname":"Geek_ejy2ar","note":"","ucode":"DB6C45FD67CDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227560,"discussion_content":"学到了, 感谢大神.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586501109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129084,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1567040466,"is_pvip":false,"replies":[{"id":48180,"content":"这个是理论上的数据，实际上取决于随机顺序读写还是顺序读写，读写数据大小，差别还是非常大的。像CPU和内存，他们标称的速度都是多少多少Hz，这个赫兹Hz的意思就是每秒钟多少次，其实就是它的极限tps。\n\n但实际我们执行一次数据读写或者一行代码，编译成CPU指令可能是几条指令，这样你就大概能推断出这条指令的执行速度应该是个什么量级的了。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567128656,"ip_address":"","comment_id":129084,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"文中说SSD硬盘的访问速度每秒几千次，内存是硬盘的10万倍，那就是亿这个数量级了，运行那么快呢？CPU的缓存假如说是内存的千倍那就到了千亿的数据级了，会有那么快吗？","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473642,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573346910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116106,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/ca/abb7bfe3.jpg","nickname":"Geek_ejy2ar","note":"","ucode":"DB6C45FD67CDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227560,"discussion_content":"学到了, 感谢大神.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586501109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156567,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1574913178,"is_pvip":false,"replies":[{"id":60578,"content":"你这个实现中，命中缓存后“移动元素到尾部”这个操作，同时会移动其它无关的元素的位置（从队头移到队尾），这样就不满足LRU的原则了，可以试试将队列换成链表这种可以支持随机写的数据结构。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1575334334,"ip_address":"","comment_id":156567,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，我在github上写了一个lru的实现。https:&#47;&#47;github.com&#47;fomeiherz&#47;code-snippet&#47;tree&#47;master&#47;lru\n\n使用了HashMap和Queue一起实现的。使用HashMap保存键值对可以实现O(1)复杂查询，使用队列保存key，头部出队，尾部入队。更新比较复杂，需要删除对应的元素后，才可以再入队，这里是O(n) 复杂度。\n\n老师，更新队列顺序时是否会有更快办法？或者有更快的实现办法呢？求指导","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465267,"discussion_content":"这个是理论上的数据，实际上取决于随机顺序读写还是顺序读写，读写数据大小，差别还是非常大的。像CPU和内存，他们标称的速度都是多少多少Hz，这个赫兹Hz的意思就是每秒钟多少次，其实就是它的极限tps。\n\n但实际我们执行一次数据读写或者一行代码，编译成CPU指令可能是几条指令，这样你就大概能推断出这条指令的执行速度应该是个什么量级的了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567128656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135270,"user_name":"13761642169","can_delete":false,"product_type":"c1","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1569115345,"is_pvip":false,"replies":[{"id":51963,"content":"对应的几个写文件的系统调用都会经过PageCache，比如write pwrite还有mmap","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569202429,"ip_address":"","comment_id":135270,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"PageCache是OS提供的能力，用户程序调用什么API才能使用到PageCache，为什么说kafka大量使用到PageCache，因为mmap？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476154,"discussion_content":"你这个实现中，命中缓存后“移动元素到尾部”这个操作，同时会移动其它无关的元素的位置（从队头移到队尾），这样就不满足LRU的原则了，可以试试将队列换成链表这种可以支持随机写的数据结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575334334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145010,"user_name":"A9","can_delete":false,"product_type":"c1","uid":1053211,"ip_address":"","ucode":"76D07F8EBE8DD0","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/1b/f62722ca.jpg","comment_is_top":false,"comment_ctime":1572159587,"is_pvip":false,"replies":[{"id":56034,"content":"DirectBuffer确实也需要经过PageCache，但是它有更好的批量大小，写入时的系统调用次数也会更少，所以性能更好一些。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572242727,"ip_address":"","comment_id":145010,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"JMQ是如何使用自定义的LRU算法的？即使使用DirectBuffer不是也要经过PageCache吗？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468119,"discussion_content":"对应的几个写文件的系统调用都会经过PageCache，比如write pwrite还有mmap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569202429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129889,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1567315872,"is_pvip":false,"replies":[{"id":48723,"content":"A1：是的。\nA2：是的。\n对于问题3和4，你可以看一下关于JMQ的这篇文章：\nhttps:&#47;&#47;www.jiqizhixin.com&#47;articles&#47;2019-01-21-19\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567491866,"ip_address":"","comment_id":129889,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"来晚了，根据jms和kafka这两节，我试着猜想一下jms的机制，顺便提个问题：\n1. 老师这节提到的jms实现的缓存机制，都是基于direct buffer自己实现的一个内存池，并实现了变种的LRU对么？这个缓存就是前面提到的journal cache，被writeThread&#47;RelicationThread&#47;FlushThread使用？\n2. 这个内存池看起来并没有借助于netty的direict buffer pool是吧？\n3. 那原谅我对比一下jms和rocket，jms没有基于mmap去做而选择direct buffer，看起来是为了：\na. 减少GC的压力\nb. 比mmap更容易控制，就更容增加缓存的命中率\n这样？\n4. 另外，有个概念我很模糊，有资料说direct buffer在写磁盘&#47;socket时并不能真的节省一次cpu copy？那这样的话jms可以说并没有利用zero copy？\n\n望解惑","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472211,"discussion_content":"DirectBuffer确实也需要经过PageCache，但是它有更好的批量大小，写入时的系统调用次数也会更少，所以性能更好一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572242727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212590,"user_name":"77","can_delete":false,"product_type":"c1","uid":1946562,"ip_address":"","ucode":"C57A8443814F7A","user_header":"","comment_is_top":false,"comment_ctime":1588158198,"is_pvip":false,"replies":[{"id":79191,"content":"读写缓存和只读缓存的区别是，数据在更新的时候，是否去更新缓存。\n\n至于是先更新缓存，还是先更新磁盘文件，这个取决于不同的缓存策略。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1588513476,"ip_address":"","comment_id":212590,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师问个问题，关于读写缓存和只读缓存第一种的区别是不是 读写缓存是更新缓存然后异步去更新磁盘文件，只读缓存是先更新磁盘在更新缓存呢？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465698,"discussion_content":"A1：是的。\nA2：是的。\n对于问题3和4，你可以看一下关于JMQ的这篇文章：\nhttps://www.jiqizhixin.com/articles/2019-01-21-19\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567491866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130664,"user_name":"明日","can_delete":false,"product_type":"c1","uid":1003917,"ip_address":"","ucode":"348899EC65AE8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/8d/09f28606.jpg","comment_is_top":false,"comment_ctime":1567504162,"is_pvip":false,"replies":[{"id":48983,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567565331,"ip_address":"","comment_id":130664,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"Java实现: https:&#47;&#47;gist.github.com&#47;imgaoxin&#47;ed59397c895b5a8a9572408b98542015","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493553,"discussion_content":"读写缓存和只读缓存的区别是，数据在更新的时候，是否去更新缓存。\n\n至于是先更新缓存，还是先更新磁盘文件，这个取决于不同的缓存策略。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588513476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129514,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1567145901,"is_pvip":false,"replies":[{"id":48359,"content":"还有就是，读写缓存可以为写入加速，但牺牲了数据可靠性。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567213601,"ip_address":"","comment_id":129514,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"我感觉读写缓存和只读缓存的第一种更新策略(更新数据的同时更新缓存)是一样的吧？因为它们都需要同时更新数据和缓存，区别可能是读写缓存以更新缓存为主，只读缓存的第一种更新策略是以更新数据为主吗","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466056,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567565331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/a7df049a.jpg","nickname":"Standly","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7785,"discussion_content":"老哥你这个get()不是O(1), 链表remove还是要遍历，可以参考下LinkedHashMap的实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567674063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1003917,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/51/8d/09f28606.jpg","nickname":"明日","note":"","ucode":"348899EC65AE8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/a7df049a.jpg","nickname":"Standly","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7816,"discussion_content":"是的，只是实现了功能，效率还需优化😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567680653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7785,"ip_address":"","group_id":0},"score":7816,"extra":""}]}]},{"had_liked":false,"id":129286,"user_name":"微微一笑","can_delete":false,"product_type":"c1","uid":1250327,"ip_address":"","ucode":"CFA7ABE81D0B99","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","comment_is_top":false,"comment_ctime":1567079201,"is_pvip":false,"replies":[{"id":48182,"content":"我已经回复了，你可以去上一节看一下，如果还有问题可以继续留言提问。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567128803,"ip_address":"","comment_id":129286,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，希望您有时间能回答下我上一章节遗留的问题，感谢@老杨同志@冰激凌的眼泪@linqw\n小伙伴的留言解答~~~\n问题是：\n①rocketMq有consumeQueue，存储着offset，然后通过offset去commitlog找到对应的Message。通过看rocketmq的开发文档，通过offset去查询消息属于【随机读】，offset不是存储着消息在磁盘中的位置吗？为什么属于随机读呢？\n②rocketMq的某个topic下指定的消息队列数，指的是consumeQueue的数量吗？\n③性能上，顺序读优于随机读。rocketMq的实现上，在消费者与commitlog之间设计了consumeQueue的数据结构，导致不能顺序读，只能随机读。我的疑惑是，rocketMq为什么不像kafka那样设计，通过顺序读取消息，然后再根据topic、tag平均分配给不同的消费者实例,，这样消息积压的时候，直接增加消费者实例就可以了，不需要增加consumeQueue，这样也可以去除consumeQueue的存在呀？我在想consumeQueue存在的意义是什么呢？\n哈哈，我的理解可能有些问题，希望老师指点迷津~","like_count":0},{"had_liked":false,"id":129079,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1567040002,"is_pvip":false,"replies":[{"id":48181,"content":"我会在答疑中详细说一下这个问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567128677,"ip_address":"","comment_id":129079,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，能详细讲下pagecache的实现吗？内存和磁盘的映射是怎么搞的呢？什么时候对磁盘的读写可以用到这个，平时我们手动读写个文件会不会用到ps呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465383,"discussion_content":"我已经回复了，你可以去上一节看一下，如果还有问题可以继续留言提问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567128803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130343,"user_name":"不能扮演天使","can_delete":false,"product_type":"c1","uid":1046172,"ip_address":"","ucode":"9922330BFF7FFB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/9c/b457a937.jpg","comment_is_top":false,"comment_ctime":1567429223,"is_pvip":false,"replies":null,"discussion_count":9,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"LRU算法最经典的我觉得还是MySQL的bufferpool的设计，里面按比例分为young和old区，能很好的解决预读问题和老师讲的“挖坟”问题；","like_count":68,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465265,"discussion_content":"我会在答疑中详细说一下这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567128677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129495,"user_name":"姜戈","can_delete":false,"product_type":"c1","uid":1058972,"ip_address":"","ucode":"45C4BE93C8E4CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/9c/73e76b19.jpg","comment_is_top":false,"comment_ctime":1567140162,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"利用双向链表+哈希表, 支持所有操作时间复杂度都为O(1). https:&#47;&#47;github.com&#47;djangogao&#47;mqexercise.git\n实现了最基础LRU算法， 关于LRU的改进算法：LRU-K和 LRU 2Q，可参考此文章https:&#47;&#47;www.jianshu.com&#47;p&#47;c4e4d55706ff","like_count":31,"discussions":[{"author":{"id":1590610,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","nickname":"帝江","note":"","ucode":"93CBA4E4D05DA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379121,"discussion_content":"隔壁老王。隔壁老丁。他俩值的入手。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623715467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1225224,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132","nickname":"尔东橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1590610,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","nickname":"帝江","note":"","ucode":"93CBA4E4D05DA5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576296,"discussion_content":"什么意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655398602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379121,"ip_address":"","group_id":0},"score":576296,"extra":""}]},{"author":{"id":2402138,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/9kibYiacH30JKkb3VzCm0lC6WL1hQ2Nz72ZbPrEYHts8XO6o3nO55BAjardNV8uL5dXCF2E1MTjdPFB8PkLxyiaSA/132","nickname":"Geek_2080a3","note":"","ucode":"D617A4CCE63406","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343939,"discussion_content":"没记错的话redis也是这样设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611214317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2402138,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/9kibYiacH30JKkb3VzCm0lC6WL1hQ2Nz72ZbPrEYHts8XO6o3nO55BAjardNV8uL5dXCF2E1MTjdPFB8PkLxyiaSA/132","nickname":"Geek_2080a3","note":"","ucode":"D617A4CCE63406","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371456,"discussion_content":"redis可不是这样设计的哦。redis没法维护一个访问先后顺序，因为redis访问非常频繁，如果还要更新指针记录访问顺序，那么在每一步操作无疑更加耗时了。redis是如何做的呢？我没记错的话大概有10中以上策略。\n两个大方向来分：\n1、有过期时间key中淘汰\n     1）随机淘汰\n     2）随机取一批数据，找快到过期时间的key，记录下过期时间，在取一批数据与这个过期时间对比进行淘汰，具体可以看下redis这个课程，我一个星期不到就看完了，后面的课后题基本全部答对。\n    3）。。\n2、所有key中淘汰\n    清除策略同1\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619774323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343939,"ip_address":"","group_id":0},"score":371456,"extra":""},{"author":{"id":1593681,"avatar":"https://static001.geekbang.org/account/avatar/00/18/51/51/60d729d0.jpg","nickname":"文康","note":"","ucode":"E1952B9DFB5DF4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541672,"discussion_content":"8种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640513910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371456,"ip_address":"","group_id":0},"score":541672,"extra":""}]},{"author":{"id":1148845,"avatar":"https://static001.geekbang.org/account/avatar/00/11/87/ad/50a85a04.jpg","nickname":"hao","note":"","ucode":"997F2B57E2F556","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323253,"discussion_content":"red is也行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604907862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1076836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6e/64/9b000b4f.jpg","nickname":"喜欢你的笑","note":"","ucode":"DC9867EA2D4D97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283733,"discussion_content":"mysql过来的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592354788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2252648,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5f/68/8e4407c7.jpg","nickname":"💡","note":"","ucode":"8AB762A8CDFEF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1076836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6e/64/9b000b4f.jpg","nickname":"喜欢你的笑","note":"","ucode":"DC9867EA2D4D97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543069,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640944230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283733,"ip_address":"","group_id":0},"score":543069,"extra":""}]},{"author":{"id":1253634,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/02/a691a1d2.jpg","nickname":"mangoliu","note":"","ucode":"B065A045A806C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94925,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577000346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129161,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1567052268,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"    一路跟着三位老师在同时学习相关知识：我想我大致明白了消息队列的特性以及真正适用的场景，周二许老师的课程中刚好提到了相关东西特意为了许老师。\n    关系型数据库、非关系型数据库、消息队列其实都属于存储中间件，老师今天的话题如何利用缓存来减少磁盘IO其实就是涉及了三种存储中间件；其实老师今天的三种方法我的理解其实就是对应了三种存储中间件：三种存储中间件都和内存有关，如何合理使用缓存、内存、磁盘去做合适的事情才是关键；\n老师课程的算法：几门相关的课程同时在学时间还是偏紧，不过刘老师的操作系统、许老师的架构、以及老师的消息队列同时学习，倒是了解什么场景下用以及用哪种消息队列；至少跟着老师的消息队列我应当知道业务中的什么事情让它去承担并且使用什么策略，先用现成的吧；改进只能等第二遍学习时再去做了。\n  一直跟着学习学到现在发现学好消息队列的前提：1)对业务的数据情况清楚2)对于当下使用的存储中间件情况非常清楚3)对于消息队列所在的系统熟悉：其中就涉及需要非常了解操作系统和当前系统的架构最后就是充分利用当下的消息队列追加一些适合自己业务场景的算法：调整优化当下所用的消息队列。","like_count":12,"discussions":[{"author":{"id":1174704,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","nickname":"syz","note":"","ucode":"54AF17ACD72645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579938,"discussion_content":"插个眼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657781612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130575,"user_name":"付永强","can_delete":false,"product_type":"c1","uid":1419544,"ip_address":"","ucode":"898998296EBD56","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/18/393a841d.jpg","comment_is_top":false,"comment_ctime":1567486308,"is_pvip":false,"replies":null,"discussion_count":4,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"可以通过在进行更新数据库操作时，删除缓存，读取数据库时如果有缓存就直接读，没有缓存则从数据库读取并更新缓存，这样的设计可以确保缓存幂等。","like_count":5,"discussions":[{"author":{"id":2296514,"avatar":"https://static001.geekbang.org/account/avatar/00/23/0a/c2/463939e6.jpg","nickname":"Elmer","note":"","ucode":"5088F08D54B6EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594622,"discussion_content":"延迟双删","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669215093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207622,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","nickname":"丁小明","note":"","ucode":"CC23857B8D75D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256253,"discussion_content":"cache aside也还是有一点点问题，需要加个版本号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588465071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eowbK2ficLhO1yHjlpJiarGpCeJHIX5WJYdk8hpVicOT8cpKue4DB6lVRdLDFeUcjUGm9pWPgY5U3Qqg/132","nickname":"Idiot","note":"","ucode":"D575024E081472","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21162,"discussion_content":"缓存穿透，在高并发情况下，db不一定能抗住","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569426705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1341940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eowbK2ficLhO1yHjlpJiarGpCeJHIX5WJYdk8hpVicOT8cpKue4DB6lVRdLDFeUcjUGm9pWPgY5U3Qqg/132","nickname":"Idiot","note":"","ucode":"D575024E081472","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33782,"discussion_content":"你说的应该是雪崩，只有在多进程共享一个数据库时会出现，可以通过给待缓存数据加锁，或用一后台线程从队列中异步处理缓存加载请求，（且此后台线程只在缓不存在时读数据库）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571142245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21162,"ip_address":"","group_id":0},"score":33782,"extra":""}]}]},{"had_liked":false,"id":129186,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1567058574,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"Leetcode上面有一道LRU算法的题目，大家可以去做一做。","like_count":3},{"had_liked":false,"id":233804,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1594458996,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，有个问题，PageCache是需要在程序里面显式调用的？我一直以为是操作系统默认就开启的。","like_count":1,"discussions":[{"author":{"id":1010914,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIgYQgM25OaLGNWPUg5NSrQuCrPNicHqNgB9lsJGMalNU18sibF4cdYxKPuwgVsIc1m5ha5voHrY9Lg/132","nickname":"jacoffee","note":"","ucode":"B3BFD39138400B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555109,"discussion_content":"不需要的，Java IO中的很多API默认都会写入到page cache中的，比如说FileChannel.write(ByteBuffer src)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646749379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187633,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1584177749,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"关于读缓存还是读写缓存，老师说他们唯一的区别就是：在更新数据的时候，是否经过缓存。\n那我的理解像 redis 和 memcached 这种都是读缓存，因为更新数据与缓存算是独立的；而 pagecache 是读写缓存。\n读缓存的难点是在更新数据时，如何保持与当前最新数据的一致性。","like_count":1},{"had_liked":false,"id":144410,"user_name":"Switch","can_delete":false,"product_type":"c1","uid":1049360,"ip_address":"","ucode":"D8A7F7F6A0BEA9","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/10/26f9f762.jpg","comment_is_top":false,"comment_ctime":1571914776,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"参考@A9 的写了一版链表的，然后又写了一版基于 优先队列的。\nhttps:&#47;&#47;github.com&#47;Switch-vov&#47;mq-learing&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;switchvov&#47;cache","like_count":1,"discussions":[{"author":{"id":2296514,"avatar":"https://static001.geekbang.org/account/avatar/00/23/0a/c2/463939e6.jpg","nickname":"Elmer","note":"","ucode":"5088F08D54B6EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594622,"discussion_content":"延迟双删","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669215093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207622,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","nickname":"丁小明","note":"","ucode":"CC23857B8D75D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256253,"discussion_content":"cache aside也还是有一点点问题，需要加个版本号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588465071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eowbK2ficLhO1yHjlpJiarGpCeJHIX5WJYdk8hpVicOT8cpKue4DB6lVRdLDFeUcjUGm9pWPgY5U3Qqg/132","nickname":"Idiot","note":"","ucode":"D575024E081472","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21162,"discussion_content":"缓存穿透，在高并发情况下，db不一定能抗住","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569426705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1341940,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eowbK2ficLhO1yHjlpJiarGpCeJHIX5WJYdk8hpVicOT8cpKue4DB6lVRdLDFeUcjUGm9pWPgY5U3Qqg/132","nickname":"Idiot","note":"","ucode":"D575024E081472","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33782,"discussion_content":"你说的应该是雪崩，只有在多进程共享一个数据库时会出现，可以通过给待缓存数据加锁，或用一后台线程从队列中异步处理缓存加载请求，（且此后台线程只在缓不存在时读数据库）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571142245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21162,"ip_address":"","group_id":0},"score":33782,"extra":""}]}]},{"had_liked":false,"id":129286,"user_name":"微微一笑","can_delete":false,"product_type":"c1","uid":1250327,"ip_address":"","ucode":"CFA7ABE81D0B99","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","comment_is_top":false,"comment_ctime":1567079201,"is_pvip":false,"replies":[{"id":48182,"content":"我已经回复了，你可以去上一节看一下，如果还有问题可以继续留言提问。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567128803,"ip_address":"","comment_id":129286,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，希望您有时间能回答下我上一章节遗留的问题，感谢@老杨同志@冰激凌的眼泪@linqw\n小伙伴的留言解答~~~\n问题是：\n①rocketMq有consumeQueue，存储着offset，然后通过offset去commitlog找到对应的Message。通过看rocketmq的开发文档，通过offset去查询消息属于【随机读】，offset不是存储着消息在磁盘中的位置吗？为什么属于随机读呢？\n②rocketMq的某个topic下指定的消息队列数，指的是consumeQueue的数量吗？\n③性能上，顺序读优于随机读。rocketMq的实现上，在消费者与commitlog之间设计了consumeQueue的数据结构，导致不能顺序读，只能随机读。我的疑惑是，rocketMq为什么不像kafka那样设计，通过顺序读取消息，然后再根据topic、tag平均分配给不同的消费者实例,，这样消息积压的时候，直接增加消费者实例就可以了，不需要增加consumeQueue，这样也可以去除consumeQueue的存在呀？我在想consumeQueue存在的意义是什么呢？\n哈哈，我的理解可能有些问题，希望老师指点迷津~","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465383,"discussion_content":"我已经回复了，你可以去上一节看一下，如果还有问题可以继续留言提问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567128803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129079,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1567040002,"is_pvip":false,"replies":[{"id":48181,"content":"我会在答疑中详细说一下这个问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567128677,"ip_address":"","comment_id":129079,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，能详细讲下pagecache的实现吗？内存和磁盘的映射是怎么搞的呢？什么时候对磁盘的读写可以用到这个，平时我们手动读写个文件会不会用到ps呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465265,"discussion_content":"我会在答疑中详细说一下这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567128677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130343,"user_name":"不能扮演天使","can_delete":false,"product_type":"c1","uid":1046172,"ip_address":"","ucode":"9922330BFF7FFB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/9c/b457a937.jpg","comment_is_top":false,"comment_ctime":1567429223,"is_pvip":false,"replies":null,"discussion_count":9,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"LRU算法最经典的我觉得还是MySQL的bufferpool的设计，里面按比例分为young和old区，能很好的解决预读问题和老师讲的“挖坟”问题；","like_count":68,"discussions":[{"author":{"id":1590610,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","nickname":"帝江","note":"","ucode":"93CBA4E4D05DA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379121,"discussion_content":"隔壁老王。隔壁老丁。他俩值的入手。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623715467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1225224,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132","nickname":"尔东橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1590610,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","nickname":"帝江","note":"","ucode":"93CBA4E4D05DA5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576296,"discussion_content":"什么意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655398602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379121,"ip_address":"","group_id":0},"score":576296,"extra":""}]},{"author":{"id":2402138,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/9kibYiacH30JKkb3VzCm0lC6WL1hQ2Nz72ZbPrEYHts8XO6o3nO55BAjardNV8uL5dXCF2E1MTjdPFB8PkLxyiaSA/132","nickname":"Geek_2080a3","note":"","ucode":"D617A4CCE63406","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343939,"discussion_content":"没记错的话redis也是这样设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611214317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2402138,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/9kibYiacH30JKkb3VzCm0lC6WL1hQ2Nz72ZbPrEYHts8XO6o3nO55BAjardNV8uL5dXCF2E1MTjdPFB8PkLxyiaSA/132","nickname":"Geek_2080a3","note":"","ucode":"D617A4CCE63406","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371456,"discussion_content":"redis可不是这样设计的哦。redis没法维护一个访问先后顺序，因为redis访问非常频繁，如果还要更新指针记录访问顺序，那么在每一步操作无疑更加耗时了。redis是如何做的呢？我没记错的话大概有10中以上策略。\n两个大方向来分：\n1、有过期时间key中淘汰\n     1）随机淘汰\n     2）随机取一批数据，找快到过期时间的key，记录下过期时间，在取一批数据与这个过期时间对比进行淘汰，具体可以看下redis这个课程，我一个星期不到就看完了，后面的课后题基本全部答对。\n    3）。。\n2、所有key中淘汰\n    清除策略同1\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619774323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343939,"ip_address":"","group_id":0},"score":371456,"extra":""},{"author":{"id":1593681,"avatar":"https://static001.geekbang.org/account/avatar/00/18/51/51/60d729d0.jpg","nickname":"文康","note":"","ucode":"E1952B9DFB5DF4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541672,"discussion_content":"8种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640513910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371456,"ip_address":"","group_id":0},"score":541672,"extra":""}]},{"author":{"id":1148845,"avatar":"https://static001.geekbang.org/account/avatar/00/11/87/ad/50a85a04.jpg","nickname":"hao","note":"","ucode":"997F2B57E2F556","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323253,"discussion_content":"red is也行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604907862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1076836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6e/64/9b000b4f.jpg","nickname":"喜欢你的笑","note":"","ucode":"DC9867EA2D4D97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283733,"discussion_content":"mysql过来的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592354788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2252648,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5f/68/8e4407c7.jpg","nickname":"💡","note":"","ucode":"8AB762A8CDFEF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1076836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6e/64/9b000b4f.jpg","nickname":"喜欢你的笑","note":"","ucode":"DC9867EA2D4D97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543069,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640944230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283733,"ip_address":"","group_id":0},"score":543069,"extra":""}]},{"author":{"id":1253634,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/02/a691a1d2.jpg","nickname":"mangoliu","note":"","ucode":"B065A045A806C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94925,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577000346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129495,"user_name":"姜戈","can_delete":false,"product_type":"c1","uid":1058972,"ip_address":"","ucode":"45C4BE93C8E4CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/9c/73e76b19.jpg","comment_is_top":false,"comment_ctime":1567140162,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"利用双向链表+哈希表, 支持所有操作时间复杂度都为O(1). https:&#47;&#47;github.com&#47;djangogao&#47;mqexercise.git\n实现了最基础LRU算法， 关于LRU的改进算法：LRU-K和 LRU 2Q，可参考此文章https:&#47;&#47;www.jianshu.com&#47;p&#47;c4e4d55706ff","like_count":31,"discussions":[{"author":{"id":1969849,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIYdf5Z0Iicn5nTotREgicJibeRKHsSkgmBaH3ghpL5Oug6FNA4zo08X672ePXYbiaCWCr57wXwUPAiazg/132","nickname":"不倒霉熊","note":"","ucode":"2AAF4E62F502FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574509,"discussion_content":"LRU算法写的很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654093556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129161,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1567052268,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"    一路跟着三位老师在同时学习相关知识：我想我大致明白了消息队列的特性以及真正适用的场景，周二许老师的课程中刚好提到了相关东西特意为了许老师。\n    关系型数据库、非关系型数据库、消息队列其实都属于存储中间件，老师今天的话题如何利用缓存来减少磁盘IO其实就是涉及了三种存储中间件；其实老师今天的三种方法我的理解其实就是对应了三种存储中间件：三种存储中间件都和内存有关，如何合理使用缓存、内存、磁盘去做合适的事情才是关键；\n老师课程的算法：几门相关的课程同时在学时间还是偏紧，不过刘老师的操作系统、许老师的架构、以及老师的消息队列同时学习，倒是了解什么场景下用以及用哪种消息队列；至少跟着老师的消息队列我应当知道业务中的什么事情让它去承担并且使用什么策略，先用现成的吧；改进只能等第二遍学习时再去做了。\n  一直跟着学习学到现在发现学好消息队列的前提：1)对业务的数据情况清楚2)对于当下使用的存储中间件情况非常清楚3)对于消息队列所在的系统熟悉：其中就涉及需要非常了解操作系统和当前系统的架构最后就是充分利用当下的消息队列追加一些适合自己业务场景的算法：调整优化当下所用的消息队列。","like_count":12,"discussions":[{"author":{"id":1969849,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIYdf5Z0Iicn5nTotREgicJibeRKHsSkgmBaH3ghpL5Oug6FNA4zo08X672ePXYbiaCWCr57wXwUPAiazg/132","nickname":"不倒霉熊","note":"","ucode":"2AAF4E62F502FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574509,"discussion_content":"LRU算法写的很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654093556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130575,"user_name":"付永强","can_delete":false,"product_type":"c1","uid":1419544,"ip_address":"","ucode":"898998296EBD56","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/18/393a841d.jpg","comment_is_top":false,"comment_ctime":1567486308,"is_pvip":false,"replies":null,"discussion_count":4,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"可以通过在进行更新数据库操作时，删除缓存，读取数据库时如果有缓存就直接读，没有缓存则从数据库读取并更新缓存，这样的设计可以确保缓存幂等。","like_count":5,"discussions":[{"author":{"id":1174704,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","nickname":"syz","note":"","ucode":"54AF17ACD72645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579938,"discussion_content":"插个眼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657781612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129186,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1567058574,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"Leetcode上面有一道LRU算法的题目，大家可以去做一做。","like_count":3},{"had_liked":false,"id":233804,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1594458996,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，有个问题，PageCache是需要在程序里面显式调用的？我一直以为是操作系统默认就开启的。","like_count":1,"discussions":[{"author":{"id":1010914,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIgYQgM25OaLGNWPUg5NSrQuCrPNicHqNgB9lsJGMalNU18sibF4cdYxKPuwgVsIc1m5ha5voHrY9Lg/132","nickname":"jacoffee","note":"","ucode":"B3BFD39138400B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555109,"discussion_content":"不需要的，Java IO中的很多API默认都会写入到page cache中的，比如说FileChannel.write(ByteBuffer src)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646749379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187633,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1584177749,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"关于读缓存还是读写缓存，老师说他们唯一的区别就是：在更新数据的时候，是否经过缓存。\n那我的理解像 redis 和 memcached 这种都是读缓存，因为更新数据与缓存算是独立的；而 pagecache 是读写缓存。\n读缓存的难点是在更新数据时，如何保持与当前最新数据的一致性。","like_count":1},{"had_liked":false,"id":144410,"user_name":"Switch","can_delete":false,"product_type":"c1","uid":1049360,"ip_address":"","ucode":"D8A7F7F6A0BEA9","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/10/26f9f762.jpg","comment_is_top":false,"comment_ctime":1571914776,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"参考@A9 的写了一版链表的，然后又写了一版基于 优先队列的。\nhttps:&#47;&#47;github.com&#47;Switch-vov&#47;mq-learing&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;switchvov&#47;cache","like_count":1},{"had_liked":false,"id":129349,"user_name":"ponymm","can_delete":false,"product_type":"c1","uid":1087867,"ip_address":"","ucode":"E247AAA72AAAE2","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/7b/0a056674.jpg","comment_is_top":false,"comment_ctime":1567092954,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"“找不到会触发一个缺页中断，然后操作系统把数据从文件读取到 PageCache 中，再返回给应用程序”  这里pagecache中没有数据并不会产生缺页中断，而是alloc page,然后放入lru链表中，接着调用a_ops-&gt;readpage()读取数据到page，可以参考kernel的 do_generic_mapping_read 函数","like_count":1,"discussions":[{"author":{"id":1317999,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1c/6f/3ea2a599.jpg","nickname":"嘉木","note":"","ucode":"AF4877693782C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6859,"discussion_content":"趣谈操作系统过来的吗😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567145593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387534,"user_name":"颜如玉","can_delete":false,"product_type":"c1","uid":2856239,"ip_address":"四川","ucode":"C55FDAE3559054","user_header":"https://static001.geekbang.org/account/avatar/00/2b/95/2f/d88950a1.jpg","comment_is_top":false,"comment_ctime":1707827396,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"LinkedHashMap简单实现就是","like_count":0},{"had_liked":false,"id":351427,"user_name":"syz","can_delete":false,"product_type":"c1","uid":1174704,"ip_address":"","ucode":"54AF17ACD72645","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","comment_is_top":false,"comment_ctime":1657782621,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"写缓存：牺牲数据一致性\n读缓存：缓存命中问题（清理算法，挖坟）\n通用的LRU,或者根据业务来设计的定制化的置换策略\nKafka使用PageCache：\nPageCache 这个读写缓存是操作系统实现的，\n消息队列它的读写比例大致是 1：1，\n不同节点上的多副本来解决数据可靠性问题","like_count":0},{"had_liked":false,"id":346598,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1653273568,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"读？读写缓存？\n\t读写缓存天然不可靠 因为一旦断电 写了一半就丢失了 或者写完断电 但还没有同步到磁盘 也会丢失\n\tkakfa为啥可以这么用呢？\n\t\t一是用来多副本来保存  某个副本断电了 其他地方也有备份\n\t\t二是直接使用了os的pc 不存在什么复杂实现\n保持缓存数据新鲜\n\t1.更新数据的同时去更新缓存\n\t\t同步更新缓存 可能存在更新失败 就需要引入重试机制\n\t\t异步更新缓存 不好掌控不同异步操作的更新时序问题\n\t\t当然 可以引入分布式事务之类 保证数据的一致性\n\t2.定期更新全部缓存\n\t\t缓存更新不那么及时 还是得看情况使用\n\t3.给缓存一个短暂过期时间 让其自动过期\n\t\t容易引发缓存穿透问题\n\t总结\n\t\t对于金融业务等数据时效很严格的 得采用第一种方案 因为这是业务强制要求的\n\t\t其他情况 数据更新不那么及时 也没关系 还是要看场景选择\n缓存置换\n\t最好的方案一定是：根据自己的业务定制化的淘汰掉某些不用的缓存 使最常用的数据命中率最高\n\t常用方案就使用lru算法即可 淘汰掉最长时间未访问的数据","like_count":0},{"had_liked":false,"id":339710,"user_name":"郎思明","can_delete":false,"product_type":"c1","uid":2353023,"ip_address":"","ucode":"16A6DA0FBEA0E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPK6DZqNE1YZmght5wicmXS9wrB2YSPdCgs8XZhvAHCCVInGt2CcF3t5owevHomzliamkrIRrLugnw/132","comment_is_top":false,"comment_ctime":1648304553,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"按文中的说法，kafka并不能保证数据不丢失，因为它只将数据写到了pagecache中，就向客户端回复ack了","like_count":0},{"had_liked":false,"id":338883,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1647771372,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"为什么kafka适合用读写缓存?\n1.消息队列的读写比例一般是1:1（一收一发），使用只读缓存不能给写加速，对读性能也提升不大。\n2.读写缓存虽然天生就是不可靠，牺牲可靠性来提升性能。但是kafka并不是使用磁盘来保证数据可靠性的，而是通过多副本来保证数据可靠性的。\n\n缓存更新策略\n1.更新磁盘数据时同步更新缓存。\n2.更新磁盘数据之后，定时异步更新缓存。\n3.更新磁盘数据，不更新缓存，而是设置缓存有效期，超过有效期后，缓存数据失效，再去磁盘读取，写入缓存。\n\n缓存置换策略\n1.针对业务的置换策略最好。\n2.使用通用的缓存置换策略，例如最近最少使用策略(LRU)等变种算法。\n\n缓存穿透\n缓存没有数据，磁盘有数据。\n\n缓存击穿\n缓存没有数据，磁盘也没有数据。","like_count":0},{"had_liked":false,"id":298082,"user_name":"死磕郎一世","can_delete":false,"product_type":"c1","uid":1272996,"ip_address":"","ucode":"86C1197C3FB2A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/6c/a4/7f7c1955.jpg","comment_is_top":false,"comment_ctime":1623904990,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"redis是不是读写缓存？","like_count":0},{"had_liked":false,"id":245436,"user_name":"岳某","can_delete":false,"product_type":"c1","uid":1541667,"ip_address":"","ucode":"83F7352D07D8EC","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/23/b941f818.jpg","comment_is_top":false,"comment_ctime":1598944780,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"请问一下：JMQ的LRU内存置换有阀值设置么？是内存满了之后在开始置换还是达到一个阀值之后就开始置换？每次置换的比例是多少了？","like_count":0},{"had_liked":false,"id":213530,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1588465223,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"redis中的lfu也是来解决最近只是用一次的老数据，覆盖使用多次的新数据问题。","like_count":0},{"had_liked":false,"id":204904,"user_name":"zmysang","can_delete":false,"product_type":"c1","uid":1642663,"ip_address":"","ucode":"8A98057E7819DD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/tjhOILHBAmlx6YiaTZJzqzxn1uyB6XpdvGDIZhBn127TYEcoLLzxRiaKvtVd3HllQqPx7cqf2YmibyBUgGGGJPDkw/132","comment_is_top":false,"comment_ctime":1586488911,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"读缓存如果实现了始终如何保持与当前最新数据一致，这样是不是相当于实现读写缓存了？因为每次更新的数据也都会走缓存了，实现的复杂程序应该是跟读写缓存差不多吧。\n读写缓存是所有数据更新都会走缓存，读缓存一致是只有在缓存里面的数据更新才会走缓存？","like_count":0},{"had_liked":false,"id":129349,"user_name":"ponymm","can_delete":false,"product_type":"c1","uid":1087867,"ip_address":"","ucode":"E247AAA72AAAE2","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/7b/0a056674.jpg","comment_is_top":false,"comment_ctime":1567092954,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"“找不到会触发一个缺页中断，然后操作系统把数据从文件读取到 PageCache 中，再返回给应用程序”  这里pagecache中没有数据并不会产生缺页中断，而是alloc page,然后放入lru链表中，接着调用a_ops-&gt;readpage()读取数据到page，可以参考kernel的 do_generic_mapping_read 函数","like_count":1,"discussions":[{"author":{"id":1317999,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1c/6f/3ea2a599.jpg","nickname":"嘉木","note":"","ucode":"AF4877693782C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6859,"discussion_content":"趣谈操作系统过来的吗😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567145593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387534,"user_name":"颜如玉","can_delete":false,"product_type":"c1","uid":2856239,"ip_address":"四川","ucode":"C55FDAE3559054","user_header":"https://static001.geekbang.org/account/avatar/00/2b/95/2f/d88950a1.jpg","comment_is_top":false,"comment_ctime":1707827396,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"LinkedHashMap简单实现就是","like_count":0},{"had_liked":false,"id":351427,"user_name":"syz","can_delete":false,"product_type":"c1","uid":1174704,"ip_address":"","ucode":"54AF17ACD72645","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","comment_is_top":false,"comment_ctime":1657782621,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"写缓存：牺牲数据一致性\n读缓存：缓存命中问题（清理算法，挖坟）\n通用的LRU,或者根据业务来设计的定制化的置换策略\nKafka使用PageCache：\nPageCache 这个读写缓存是操作系统实现的，\n消息队列它的读写比例大致是 1：1，\n不同节点上的多副本来解决数据可靠性问题","like_count":0},{"had_liked":false,"id":346598,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1653273568,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"读？读写缓存？\n\t读写缓存天然不可靠 因为一旦断电 写了一半就丢失了 或者写完断电 但还没有同步到磁盘 也会丢失\n\tkakfa为啥可以这么用呢？\n\t\t一是用来多副本来保存  某个副本断电了 其他地方也有备份\n\t\t二是直接使用了os的pc 不存在什么复杂实现\n保持缓存数据新鲜\n\t1.更新数据的同时去更新缓存\n\t\t同步更新缓存 可能存在更新失败 就需要引入重试机制\n\t\t异步更新缓存 不好掌控不同异步操作的更新时序问题\n\t\t当然 可以引入分布式事务之类 保证数据的一致性\n\t2.定期更新全部缓存\n\t\t缓存更新不那么及时 还是得看情况使用\n\t3.给缓存一个短暂过期时间 让其自动过期\n\t\t容易引发缓存穿透问题\n\t总结\n\t\t对于金融业务等数据时效很严格的 得采用第一种方案 因为这是业务强制要求的\n\t\t其他情况 数据更新不那么及时 也没关系 还是要看场景选择\n缓存置换\n\t最好的方案一定是：根据自己的业务定制化的淘汰掉某些不用的缓存 使最常用的数据命中率最高\n\t常用方案就使用lru算法即可 淘汰掉最长时间未访问的数据","like_count":0},{"had_liked":false,"id":339710,"user_name":"郎思明","can_delete":false,"product_type":"c1","uid":2353023,"ip_address":"","ucode":"16A6DA0FBEA0E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPK6DZqNE1YZmght5wicmXS9wrB2YSPdCgs8XZhvAHCCVInGt2CcF3t5owevHomzliamkrIRrLugnw/132","comment_is_top":false,"comment_ctime":1648304553,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"按文中的说法，kafka并不能保证数据不丢失，因为它只将数据写到了pagecache中，就向客户端回复ack了","like_count":0},{"had_liked":false,"id":338883,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1647771372,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"为什么kafka适合用读写缓存?\n1.消息队列的读写比例一般是1:1（一收一发），使用只读缓存不能给写加速，对读性能也提升不大。\n2.读写缓存虽然天生就是不可靠，牺牲可靠性来提升性能。但是kafka并不是使用磁盘来保证数据可靠性的，而是通过多副本来保证数据可靠性的。\n\n缓存更新策略\n1.更新磁盘数据时同步更新缓存。\n2.更新磁盘数据之后，定时异步更新缓存。\n3.更新磁盘数据，不更新缓存，而是设置缓存有效期，超过有效期后，缓存数据失效，再去磁盘读取，写入缓存。\n\n缓存置换策略\n1.针对业务的置换策略最好。\n2.使用通用的缓存置换策略，例如最近最少使用策略(LRU)等变种算法。\n\n缓存穿透\n缓存没有数据，磁盘有数据。\n\n缓存击穿\n缓存没有数据，磁盘也没有数据。","like_count":0},{"had_liked":false,"id":298082,"user_name":"死磕郎一世","can_delete":false,"product_type":"c1","uid":1272996,"ip_address":"","ucode":"86C1197C3FB2A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/6c/a4/7f7c1955.jpg","comment_is_top":false,"comment_ctime":1623904990,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"redis是不是读写缓存？","like_count":0},{"had_liked":false,"id":245436,"user_name":"岳某","can_delete":false,"product_type":"c1","uid":1541667,"ip_address":"","ucode":"83F7352D07D8EC","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/23/b941f818.jpg","comment_is_top":false,"comment_ctime":1598944780,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"请问一下：JMQ的LRU内存置换有阀值设置么？是内存满了之后在开始置换还是达到一个阀值之后就开始置换？每次置换的比例是多少了？","like_count":0},{"had_liked":false,"id":213530,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1588465223,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"redis中的lfu也是来解决最近只是用一次的老数据，覆盖使用多次的新数据问题。","like_count":0},{"had_liked":false,"id":204904,"user_name":"zmysang","can_delete":false,"product_type":"c1","uid":1642663,"ip_address":"","ucode":"8A98057E7819DD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/tjhOILHBAmlx6YiaTZJzqzxn1uyB6XpdvGDIZhBn127TYEcoLLzxRiaKvtVd3HllQqPx7cqf2YmibyBUgGGGJPDkw/132","comment_is_top":false,"comment_ctime":1586488911,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"读缓存如果实现了始终如何保持与当前最新数据一致，这样是不是相当于实现读写缓存了？因为每次更新的数据也都会走缓存了，实现的复杂程序应该是跟读写缓存差不多吧。\n读写缓存是所有数据更新都会走缓存，读缓存一致是只有在缓存里面的数据更新才会走缓存？","like_count":0},{"had_liked":false,"id":197537,"user_name":"Geek_8c5f9c","can_delete":false,"product_type":"c1","uid":1596047,"ip_address":"","ucode":"70CD441EAF490F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","comment_is_top":false,"comment_ctime":1585384116,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"只读缓存更新缓存最简单的方法就是在数据更新时直接在缓存中的数据删除。下一个READ操作将更新后的数据再次放入缓存。","like_count":0},{"had_liked":false,"id":188041,"user_name":"slark","can_delete":false,"product_type":"c1","uid":1143574,"ip_address":"","ucode":"7E8DE962AA23A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/73/16/595b0342.jpg","comment_is_top":false,"comment_ctime":1584317814,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"读写缓存，只读缓存。\n如何数据更新\n缓存置换策略","like_count":0},{"had_liked":false,"id":173716,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1579667967,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"\n作业：https:&#47;&#47;github.com&#47;ToddSAP&#47;Geektime&#47;tree&#47;master&#47;src&#47;mqmaster&#47;course16&#47;lru\n参考HashMap用array+doubly linked list实现了一个数据结构，提供了LRU的功能。","like_count":0},{"had_liked":false,"id":150203,"user_name":"付锐涛","can_delete":false,"product_type":"c1","uid":1450711,"ip_address":"","ucode":"F5BF0571596C4B","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/d7/d166f764.jpg","comment_is_top":false,"comment_ctime":1573478116,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"置换时机：实时，定期，事件","like_count":0},{"had_liked":false,"id":136970,"user_name":"米乐m6app苹果官网下载","can_delete":false,"product_type":"c1","uid":1199058,"ip_address":"","ucode":"F4CDCFF71DDDB6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4b/d2/7baca523.jpg","comment_is_top":false,"comment_ctime":1569568743,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"https:&#47;&#47;gist.github.com&#47;mrpanc&#47;2cf2e668eab099114e0a1f99eb44f573 交作业，用go写了一版基础的lru策略","like_count":0},{"had_liked":false,"id":135978,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1569319438,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"缓存的速度理论上比磁盘快十万倍，那对性能的提升是多么的立竿见影——性能提升的神器。\n而且一级不行可以再来一级，我正好也在压测，用不用本地缓存，性能可以说会差上几十倍之多。\n具体缓存怎么用，还需根据自己的实际业务场景而定。我们redis缓存是每晚定时跑的，也可以人工触发，分为全量和增量，本地缓存是读redis缓存时添加的，为了防止不存在的key加重redis缓存的负载，会将一个特殊值写入本地缓存，以做标识。","like_count":0},{"had_liked":false,"id":132141,"user_name":"泛岁月的涟漪","can_delete":false,"product_type":"c1","uid":1104605,"ip_address":"","ucode":"1C27878EFBD3CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/dd/c9735ee8.jpg","comment_is_top":false,"comment_ctime":1568031047,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"public class DefaultLruCache&lt;K, V&gt; extends LruCache&lt;K, V&gt; {\n\n    private LruCacheImpl&lt;K, V&gt; cache;\n\n    public DefaultLruCache(int capacity, Storage&lt;K, V&gt; lowSpeedStorage) {\n        super(capacity, lowSpeedStorage);\n        cache = new LruCacheImpl&lt;&gt;(capacity, true);\n    }\n\n    @Override\n    public V get(K key) {\n        V value = cache.get(key);\n        if (value == null) {\n            value = lowSpeedStorage.get(key);\n            cache.put(key, value);\n        }\n        return value;\n    }\n\n    class LruCacheImpl&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {\n\n        public LruCacheImpl(int capacity, boolean accessOrder) {\n            super(capacity, 0.75F, accessOrder);\n        }\n\n        @Override\n        protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {\n            return size() &gt; capacity;\n        }\n    }\n}","like_count":0},{"had_liked":false,"id":130487,"user_name":"木木木","can_delete":false,"product_type":"c1","uid":1240679,"ip_address":"","ucode":"5EBC11AB704EF2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/67/d6d9499e.jpg","comment_is_top":false,"comment_ctime":1567473060,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"缓存和db的一致性有很多工作做的。文中三种方法，定时更新全部缓存估计只适合量小的，更新不频繁的配置性数据。定时的时间也有问题，太短影响性能，太长一致性问题。设置缓存时间也是类似的问题。我们业务中实际使用同步更新的方式，当然异步也可以。关键是在业务代码落库时落缓存补偿的记录，里面带序号，用来解决异步问题。更新后还可以进行一致性检查","like_count":0},{"had_liked":false,"id":130117,"user_name":"0xDDE58","can_delete":false,"product_type":"c1","uid":1181921,"ip_address":"","ucode":"A8D3B11DAE48B0","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/e1/2a9ef5c2.jpg","comment_is_top":false,"comment_ctime":1567387569,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"期待JMQ开源","like_count":0},{"had_liked":false,"id":129625,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1567175848,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"有一个问题：java 内部实现缓存很容易导致fullgc频繁发生","like_count":0},{"had_liked":false,"id":197537,"user_name":"Geek_8c5f9c","can_delete":false,"product_type":"c1","uid":1596047,"ip_address":"","ucode":"70CD441EAF490F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","comment_is_top":false,"comment_ctime":1585384116,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"只读缓存更新缓存最简单的方法就是在数据更新时直接在缓存中的数据删除。下一个READ操作将更新后的数据再次放入缓存。","like_count":0},{"had_liked":false,"id":188041,"user_name":"slark","can_delete":false,"product_type":"c1","uid":1143574,"ip_address":"","ucode":"7E8DE962AA23A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/73/16/595b0342.jpg","comment_is_top":false,"comment_ctime":1584317814,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"读写缓存，只读缓存。\n如何数据更新\n缓存置换策略","like_count":0},{"had_liked":false,"id":173716,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1579667967,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"\n作业：https:&#47;&#47;github.com&#47;ToddSAP&#47;Geektime&#47;tree&#47;master&#47;src&#47;mqmaster&#47;course16&#47;lru\n参考HashMap用array+doubly linked list实现了一个数据结构，提供了LRU的功能。","like_count":0},{"had_liked":false,"id":150203,"user_name":"付锐涛","can_delete":false,"product_type":"c1","uid":1450711,"ip_address":"","ucode":"F5BF0571596C4B","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/d7/d166f764.jpg","comment_is_top":false,"comment_ctime":1573478116,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"置换时机：实时，定期，事件","like_count":0},{"had_liked":false,"id":136970,"user_name":"米乐m6app苹果官网下载","can_delete":false,"product_type":"c1","uid":1199058,"ip_address":"","ucode":"F4CDCFF71DDDB6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4b/d2/7baca523.jpg","comment_is_top":false,"comment_ctime":1569568743,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"https:&#47;&#47;gist.github.com&#47;mrpanc&#47;2cf2e668eab099114e0a1f99eb44f573 交作业，用go写了一版基础的lru策略","like_count":0},{"had_liked":false,"id":135978,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1569319438,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"缓存的速度理论上比磁盘快十万倍，那对性能的提升是多么的立竿见影——性能提升的神器。\n而且一级不行可以再来一级，我正好也在压测，用不用本地缓存，性能可以说会差上几十倍之多。\n具体缓存怎么用，还需根据自己的实际业务场景而定。我们redis缓存是每晚定时跑的，也可以人工触发，分为全量和增量，本地缓存是读redis缓存时添加的，为了防止不存在的key加重redis缓存的负载，会将一个特殊值写入本地缓存，以做标识。","like_count":0},{"had_liked":false,"id":132141,"user_name":"泛岁月的涟漪","can_delete":false,"product_type":"c1","uid":1104605,"ip_address":"","ucode":"1C27878EFBD3CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/dd/c9735ee8.jpg","comment_is_top":false,"comment_ctime":1568031047,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"public class DefaultLruCache&lt;K, V&gt; extends LruCache&lt;K, V&gt; {\n\n    private LruCacheImpl&lt;K, V&gt; cache;\n\n    public DefaultLruCache(int capacity, Storage&lt;K, V&gt; lowSpeedStorage) {\n        super(capacity, lowSpeedStorage);\n        cache = new LruCacheImpl&lt;&gt;(capacity, true);\n    }\n\n    @Override\n    public V get(K key) {\n        V value = cache.get(key);\n        if (value == null) {\n            value = lowSpeedStorage.get(key);\n            cache.put(key, value);\n        }\n        return value;\n    }\n\n    class LruCacheImpl&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {\n\n        public LruCacheImpl(int capacity, boolean accessOrder) {\n            super(capacity, 0.75F, accessOrder);\n        }\n\n        @Override\n        protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {\n            return size() &gt; capacity;\n        }\n    }\n}","like_count":0},{"had_liked":false,"id":130487,"user_name":"木木木","can_delete":false,"product_type":"c1","uid":1240679,"ip_address":"","ucode":"5EBC11AB704EF2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/67/d6d9499e.jpg","comment_is_top":false,"comment_ctime":1567473060,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"缓存和db的一致性有很多工作做的。文中三种方法，定时更新全部缓存估计只适合量小的，更新不频繁的配置性数据。定时的时间也有问题，太短影响性能，太长一致性问题。设置缓存时间也是类似的问题。我们业务中实际使用同步更新的方式，当然异步也可以。关键是在业务代码落库时落缓存补偿的记录，里面带序号，用来解决异步问题。更新后还可以进行一致性检查","like_count":0},{"had_liked":false,"id":130117,"user_name":"0xDDE58","can_delete":false,"product_type":"c1","uid":1181921,"ip_address":"","ucode":"A8D3B11DAE48B0","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/e1/2a9ef5c2.jpg","comment_is_top":false,"comment_ctime":1567387569,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"期待JMQ开源","like_count":0},{"had_liked":false,"id":129625,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1567175848,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"有一个问题：java 内部实现缓存很容易导致fullgc频繁发生","like_count":0},{"had_liked":false,"id":129576,"user_name":"大男孩","can_delete":false,"product_type":"c1","uid":1026327,"ip_address":"","ucode":"F02ED59E849741","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/17/ed791bea.jpg","comment_is_top":false,"comment_ctime":1567156977,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"献丑了☺，实现了一个 LruCache，核心思路是用 Map 来做本地高速缓存，用 LinkedList 存储最近被访问的 Key 列表，代码如下：https:&#47;&#47;github.com&#47;jeffreylyp&#47;geektime-cache.git，核心优化点是对 Key 列表的更新操作全部异步化了，由单独的线程负责处理。","like_count":0},{"had_liked":false,"id":129546,"user_name":"A9","can_delete":false,"product_type":"c1","uid":1053211,"ip_address":"","ucode":"76D07F8EBE8DD0","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/1b/f62722ca.jpg","comment_is_top":false,"comment_ctime":1567152597,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"将key-value维护成一个双向链表，head为新鲜的数据，tail处为老一些的数据\n高速缓存使用HashMap或其他查询实现\n在容量满时，一次删除 size&#47;10+1个元素，避免重复触发删除操作\nhttps:&#47;&#47;gist.github.com&#47;WangYangA9&#47;90b3b05140bfef526eb7cb595b62c71a","like_count":0},{"had_liked":false,"id":129523,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1567148239,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"&#47;**\n * 不知道这样实现可不可以，肯定有问题哈哈\n * @param &lt;K&gt;\n * @param &lt;V&gt;\n *&#47;\npublic class LruCacheImpl&lt;K,V&gt; extends LruCache&lt;K,V&gt; {\n    &#47;**\n     * 高速缓存\n     *&#47;\n    private Map&lt;K,V&gt; highSpeedStorage = new HashMap&lt;&gt;(capacity);\n    &#47;**\n     * lru链表\n     *&#47;\n    private LinkedList&lt;K&gt; lruList = new LinkedList&lt;&gt;();\n\n    public LruCacheImpl(int capacity, Storage lowSpeedStorage) {\n        super(capacity, lowSpeedStorage);\n    }\n\n    @Override\n    public V get(K key) {\n        &#47;&#47;先从高速缓存中获取\n        V value = highSpeedStorage.get(key);\n        if (value != null) {\n            &#47;&#47;调整元素位置\n            K lastKey = lruList.peekLast();\n            if (!key.equals(lastKey)) {\n                lruList.remove(key);\n                lruList.addLast(key);\n            }\n            return value;\n        }\n        &#47;&#47;加锁访问低速缓存\n        synchronized (this) {\n            value = highSpeedStorage.get(key);\n            if (value != null) {\n                return value;\n            }\n            &#47;&#47;再从低速缓存中获取\n            value = lowSpeedStorage.get(key);\n            if (value == null) {\n                return null;\n            }\n            &#47;&#47;写入高速缓存\n            if (highSpeedStorage.size()&gt;=capacity) {\n                K removeKey = lruList.removeFirst();\n                highSpeedStorage.remove(removeKey);\n            }\n            highSpeedStorage.put(key, value);\n            lruList.addLast(key);\n        }\n        return value;\n    }\n}\n","like_count":0},{"had_liked":false,"id":129184,"user_name":"coffee","can_delete":false,"product_type":"c1","uid":1391640,"ip_address":"","ucode":"DF831C481B7949","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vK7WwQG23CI29w0iamcgetTicMdQ8NsJsQWSXIia3aSUbVE6dqfTiaVtqTdibJu31f7k2BkOSkQianxOUaqojEYP6ic3w/132","comment_is_top":false,"comment_ctime":1567058288,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"依mybatis的lrucache画了个瓢。采用linkedhashmap来实现的lru。插入应该是近似o(1).查找最好是o(1) ,最坏是o(n) .代码见https:&#47;&#47;github.com&#47;swgithub1006&#47;mqlearning","like_count":0},{"had_liked":false,"id":129138,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1567047670,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"课后习题做了一下，大概的实现思路是用链表存储数据，如果数据查询的数据不存在，从低速存储中拿到数据存到链表头部（要判断数据是否已满），如果数据存在，则从链表中取出数据，然后再放到链表头部。github地址：https:&#47;&#47;github.com&#47;wutianqi&#47;geek-pratice.git","like_count":0},{"had_liked":false,"id":129124,"user_name":"青舟","can_delete":false,"product_type":"c1","uid":1192732,"ip_address":"","ucode":"2651482AC0DEC6","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/1c/59a4e803.jpg","comment_is_top":false,"comment_ctime":1567045681,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"我们怎么进行性能测试呀？","like_count":0},{"had_liked":false,"id":129098,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1567042395,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"对于读写缓存，有条件的业务可以上保电内存（BBU），或者数据量有限场景可以用大电容的RAID卡来保障文件系统的读写性能以及可靠性。","like_count":0},{"had_liked":false,"id":129576,"user_name":"大男孩","can_delete":false,"product_type":"c1","uid":1026327,"ip_address":"","ucode":"F02ED59E849741","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/17/ed791bea.jpg","comment_is_top":false,"comment_ctime":1567156977,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"献丑了☺，实现了一个 LruCache，核心思路是用 Map 来做本地高速缓存，用 LinkedList 存储最近被访问的 Key 列表，代码如下：https:&#47;&#47;github.com&#47;jeffreylyp&#47;geektime-cache.git，核心优化点是对 Key 列表的更新操作全部异步化了，由单独的线程负责处理。","like_count":0},{"had_liked":false,"id":129546,"user_name":"A9","can_delete":false,"product_type":"c1","uid":1053211,"ip_address":"","ucode":"76D07F8EBE8DD0","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/1b/f62722ca.jpg","comment_is_top":false,"comment_ctime":1567152597,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"将key-value维护成一个双向链表，head为新鲜的数据，tail处为老一些的数据\n高速缓存使用HashMap或其他查询实现\n在容量满时，一次删除 size&#47;10+1个元素，避免重复触发删除操作\nhttps:&#47;&#47;gist.github.com&#47;WangYangA9&#47;90b3b05140bfef526eb7cb595b62c71a","like_count":0},{"had_liked":false,"id":129523,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1567148239,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"&#47;**\n * 不知道这样实现可不可以，肯定有问题哈哈\n * @param &lt;K&gt;\n * @param &lt;V&gt;\n *&#47;\npublic class LruCacheImpl&lt;K,V&gt; extends LruCache&lt;K,V&gt; {\n    &#47;**\n     * 高速缓存\n     *&#47;\n    private Map&lt;K,V&gt; highSpeedStorage = new HashMap&lt;&gt;(capacity);\n    &#47;**\n     * lru链表\n     *&#47;\n    private LinkedList&lt;K&gt; lruList = new LinkedList&lt;&gt;();\n\n    public LruCacheImpl(int capacity, Storage lowSpeedStorage) {\n        super(capacity, lowSpeedStorage);\n    }\n\n    @Override\n    public V get(K key) {\n        &#47;&#47;先从高速缓存中获取\n        V value = highSpeedStorage.get(key);\n        if (value != null) {\n            &#47;&#47;调整元素位置\n            K lastKey = lruList.peekLast();\n            if (!key.equals(lastKey)) {\n                lruList.remove(key);\n                lruList.addLast(key);\n            }\n            return value;\n        }\n        &#47;&#47;加锁访问低速缓存\n        synchronized (this) {\n            value = highSpeedStorage.get(key);\n            if (value != null) {\n                return value;\n            }\n            &#47;&#47;再从低速缓存中获取\n            value = lowSpeedStorage.get(key);\n            if (value == null) {\n                return null;\n            }\n            &#47;&#47;写入高速缓存\n            if (highSpeedStorage.size()&gt;=capacity) {\n                K removeKey = lruList.removeFirst();\n                highSpeedStorage.remove(removeKey);\n            }\n            highSpeedStorage.put(key, value);\n            lruList.addLast(key);\n        }\n        return value;\n    }\n}\n","like_count":0},{"had_liked":false,"id":129184,"user_name":"coffee","can_delete":false,"product_type":"c1","uid":1391640,"ip_address":"","ucode":"DF831C481B7949","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vK7WwQG23CI29w0iamcgetTicMdQ8NsJsQWSXIia3aSUbVE6dqfTiaVtqTdibJu31f7k2BkOSkQianxOUaqojEYP6ic3w/132","comment_is_top":false,"comment_ctime":1567058288,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"依mybatis的lrucache画了个瓢。采用linkedhashmap来实现的lru。插入应该是近似o(1).查找最好是o(1) ,最坏是o(n) .代码见https:&#47;&#47;github.com&#47;swgithub1006&#47;mqlearning","like_count":0},{"had_liked":false,"id":129138,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1567047670,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"课后习题做了一下，大概的实现思路是用链表存储数据，如果数据查询的数据不存在，从低速存储中拿到数据存到链表头部（要判断数据是否已满），如果数据存在，则从链表中取出数据，然后再放到链表头部。github地址：https:&#47;&#47;github.com&#47;wutianqi&#47;geek-pratice.git","like_count":0},{"had_liked":false,"id":129124,"user_name":"青舟","can_delete":false,"product_type":"c1","uid":1192732,"ip_address":"","ucode":"2651482AC0DEC6","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/1c/59a4e803.jpg","comment_is_top":false,"comment_ctime":1567045681,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"我们怎么进行性能测试呀？","like_count":0},{"had_liked":false,"id":129098,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1567042395,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"对于读写缓存，有条件的业务可以上保电内存（BBU），或者数据量有限场景可以用大电容的RAID卡来保障文件系统的读写性能以及可靠性。","like_count":0}]}