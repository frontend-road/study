{"id":643539,"title":"08｜整合IoC和MVC：如何在Web环境中启动IoC容器？","content":"<p>你好，我是郭屹。</p><p>通过上节课的工作，我们就初步实现了一个原始的MVC框架，并引入了@RequestMapping注解，还通过对指定的包进行全局扫描来简化XML文件配置。但是这个MVC框架是独立运行的，它跟我们之前实现的IoC容器还没有什么关系。</p><p>那么这节课，我们就把前面实现的IoC容器与MVC结合在一起，使MVC的Controller可以引用容器中的Bean，这样整合成一个大的容器。</p><h2>Servlet服务器启动过程</h2><p>IoC容器是一个自我实现的服务器，MVC是要符合Web规范的，不能自己想怎么来就怎么来。为了融合二者，我们有必要了解一下Web规范的内容。在Servlet规范中，服务器启动的时候，会根据web.xml文件来配置。下面我们花点时间详细介绍一下这个配置文件。</p><p>这个web.xml文件是Java的Servlet规范中规定的，它里面声明了一个Web应用全部的配置信息。按照规定，每个Java Web应用都必须包含一个web.xml文件，且必须放在WEB-INF路径下。它的顶层根是web-app，指定命名空间和schema规定。通常，我们会在web.xml中配置context-param、Listener、Filter和Servlet等元素。</p><!-- [[[read_end]]] --><p>下面是常见元素的说明。</p><pre><code class=\"language-plain\">&lt;display-name&gt;&lt;/display-name&gt;&nbsp;&nbsp;\n声明WEB应用的名字&nbsp; &nbsp;&nbsp;\n&lt;description&gt;&lt;/description&gt;&nbsp; &nbsp;\n&nbsp;声明WEB应用的描述信息&nbsp; &nbsp;&nbsp;\n&lt;context-param&gt;&lt;/context-param&gt;&nbsp;\n声明应用全局的初始化参数。&nbsp;&nbsp;\n&lt;listener&gt;&lt;/listener&gt;\n声明监听器，它在建立、修改和删除会话或servlet环境时得到事件通知。\n&lt;filter&gt;&lt;/filter&gt;&nbsp;\n声明一个实现javax.servlet.Filter接口的类。&nbsp; &nbsp;&nbsp;\n&lt;filter-mapping&gt;&lt;/filter-mapping&gt;\n声明过滤器的拦截路径。&nbsp;\n&lt;servlet&gt;&lt;/servlet&gt;&nbsp;\n声明servlet类。&nbsp;&nbsp; &nbsp;\n&lt;servlet-mapping&gt;&lt;/servlet-mapping&gt;&nbsp;\n声明servlet的访问路径，试一个方便访问的URL。&nbsp; &nbsp;&nbsp;\n&lt;session-config&gt;&lt;/session-config&gt;&nbsp;\nsession有关的配置，超时值。\n&lt;error-page&gt;&lt;/error-page&gt;&nbsp;\n在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面。&nbsp; &nbsp;\n</code></pre><p>当Servlet服务器如Tomcat启动的时候，要遵守下面的时序。</p><ol>\n<li>在启动Web项目时，Tomcat会读取web.xml中的comtext-param节点，获取这个Web应用的全局参数。</li>\n<li>Tomcat创建一个ServletContext实例，是全局有效的。</li>\n<li>将context-param的参数转换为键值对，存储在ServletContext里。</li>\n<li>创建listener中定义的监听类的实例，按照规定Listener要继承自ServletContextListener。监听器初始化方法是contextInitialized(ServletContextEvent event)。初始化方法中可以通过event.getServletContext().getInitParameter(“name”)方法获得上下文环境中的键值对。</li>\n<li>当Tomcat完成启动，也就是contextInitialized方法完成后，再对Filter过滤器进行初始化。</li>\n<li>servlet初始化：有一个参数load-on-startup，它为正数的值越小优先级越高，会自动启动，如果为负数或未指定这个参数，会在servlet被调用时再进行初始化。init-param 是一个servlet整个范围之内有效的参数，在servlet类的init()方法中通过 this.getInitParameter(″param1″)方法获得。</li>\n</ol><p>规范中规定的这个时序，就是我们整合两者的关键所在。</p><h2>Listener初始化启动IoC容器</h2><p>由上述服务器启动过程我们知道，我们把web.xml文件里定义的元素加载过程简单归总一下：先获取全局的参数context-param来创建上下文，之后如果配置文件里定义了Listener，那服务器会先启动它们，之后是Filter，最后是Servlet。因此我们可以利用这个时序，把容器的启动放到Web应用的Listener中。</p><p>Spring MVC就是这么设计的，它按照这个规范，用ContextLoaderListener来启动容器。我们也模仿它同样来实现这样一个Listener。</p><pre><code class=\"language-java\">package com.minis.web;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\n\npublic class ContextLoaderListener implements ServletContextListener {\n\tpublic static final String CONFIG_LOCATION_PARAM = \"contextConfigLocation\";\n\tprivate WebApplicationContext context;\n\t\n\tpublic ContextLoaderListener() {\n\t}\n\tpublic ContextLoaderListener(WebApplicationContext context) {\n\t\tthis.context = context;\n\t}\n\t@Override\n\tpublic void contextDestroyed(ServletContextEvent event) {\n\t}\n\t@Override\n\tpublic void contextInitialized(ServletContextEvent event) {\n\t\tinitWebApplicationContext(event.getServletContext());\n\t}\n\tprivate void initWebApplicationContext(ServletContext servletContext) {\n\t\tString sContextLocation = servletContext.getInitParameter(CONFIG_LOCATION_PARAM);\n\t\tWebApplicationContext wac = new AnnotationConfigWebApplicationContext(sContextLocation);\n\t\twac.setServletContext(servletContext);\n\t\tthis.context = wac;\n\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n\t}\n}\n</code></pre><p>ContextLoaderListener这个类里，先声明了一个常量CONFIG_LOCATION_PARAM，它的默认值是contextConfigLocation，这是代表配置文件路径的一个变量，也就是IoC容器的配置文件。这也就意味着，Listener期望web.xml里有一个参数用来配置文件路径。我们可以看一下web.xml文件。</p><pre><code class=\"language-plain\">&nbsp; &lt;context-param&gt;\n&nbsp; &nbsp; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n&nbsp; &nbsp; &lt;param-value&gt;applicationContext.xml&lt;/param-value&gt;\n&nbsp; &lt;/context-param&gt;\n&nbsp; &lt;listener&gt;\n&nbsp; &nbsp; &lt;listener-class&gt;\n\t&nbsp; &nbsp; &nbsp; &nbsp; com.minis.web.ContextLoaderListener\n\t&nbsp; &nbsp; &lt;/listener-class&gt;\n&nbsp; &lt;/listener&gt;\n</code></pre><p>上面这个文件，定义了这个Listener，还定义了全局参数指定配置文件路径。</p><p>ContextLoaderListener这个类里还定义了WebApplicationContext对象，目前还不存在这个类。但通过名字可以知道，WebApplicationContext 是一个上下文接口，应用在Web项目里。我们看看如何定义WebApplicationContext。</p><pre><code class=\"language-java\">package com.minis.web;\n\nimport javax.servlet.ServletContext;\nimport com.minis.context.ApplicationContext;\n\npublic interface WebApplicationContext extends ApplicationContext {\n\tString ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + \".ROOT\";\n\n\tServletContext getServletContext();\n\tvoid setServletContext(ServletContext servletContext);\n}\n</code></pre><p>可以看出，这个上下文接口指向了Servlet容器本身的上下文ServletContext。</p><p>接下来我们继续完善&nbsp;ContextLoaderListener 这个类，&nbsp;在初始化的过程中初始化WebApplicationContext， 并把这个上下文放到&nbsp;servletContext 的&nbsp;Attribute 某个属性里面。</p><pre><code class=\"language-java\">public void contextInitialized(ServletContextEvent event) {\n &nbsp; &nbsp;initWebApplicationContext(event.getServletContext());&nbsp; &nbsp; &nbsp;\n}\nprivate void initWebApplicationContext(ServletContext servletContext) {\n&nbsp; &nbsp; String sContextLocation =&nbsp;\nservletContext.getInitParameter(CONFIG_LOCATION_PARAM);\n    WebApplicationContext wac = new&nbsp;\nAnnotationConfigWebApplicationContext(sContextLocation);\n&nbsp; &nbsp; wac.setServletContext(servletContext);\n&nbsp; &nbsp; this.context = wac;\n&nbsp; &nbsp; servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ ATTRIBUTE, this.context);\n</code></pre><p>在这段代码中，通过配置文件参数从web.xml中得到配置文件路径，如applicationContext.xml，然后用这个配置文件创建了AnnotationConfigWebApplicationContext这一对象，我们叫WAC，这就成了新的上下文。然后调用servletContext.setAttribute()方法，按照默认的属性值将WAC设置到servletContext里。这样，AnnotationConfigWebApplicationContext 和&nbsp;servletContext 就能够互相引用了，很方便。</p><p>而这个AnnotationConfigWebApplicationContext又是什么呢？我们看下它的定义。</p><pre><code class=\"language-java\">package com.minis.web;\n\nimport javax.servlet.ServletContext;\nimport com.minis.context.ClassPathXmlApplicationContext;\n\npublic class AnnotationConfigWebApplicationContext&nbsp;\n\t\t\t\t\textends ClassPathXmlApplicationContext implements WebApplicationContext{\n\tprivate ServletContext servletContext;\n\t\n\tpublic AnnotationConfigWebApplicationContext(String fileName) {\n\t\tsuper(fileName);\n\t}\n\t@Override\n\tpublic ServletContext getServletContext() {\n\t\treturn this.servletContext;\n\t}\n\t@Override\n\tpublic void setServletContext(ServletContext servletContext) {\n\t\tthis.servletContext = servletContext;\n\t}\n}\n</code></pre><p>由&nbsp;AnnotationConfigWebApplicationContext 的继承关系可看出，该类其实质就是我们IoC容器中的ClassPathXmlApplicationContext，只是在此基础上增加了&nbsp;servletContext 的属性，这样就成了一个适用于Web场景的上下文。</p><p>我们在这个过程中用到了一个配置文件applicationContext.xml，它是由定义在web.xml里的一个参数指明的。</p><pre><code class=\"language-plain\">&nbsp; &lt;context-param&gt;\n&nbsp; &nbsp; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n&nbsp; &nbsp; &lt;param-value&gt;applicationContext.xml&lt;/param-value&gt;\n&nbsp; &lt;/context-param&gt;\n</code></pre><p>这个配置文件就是我们现在的IoC容器的配置文件，主要作用是声明Bean，如：</p><pre><code class=\"language-plain\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans&gt;\n\t&lt;bean id=\"bbs\" class=\"com.test.service.BaseBaseService\"&gt;&nbsp;\n\t&nbsp; &nbsp; &lt;property type=\"com.test.service.AServiceImpl\" name=\"as\" ref=\"aservice\"/&gt;\n\t&lt;/bean&gt;\n\t&lt;bean id=\"aservice\" class=\"com.test.service.AServiceImpl\"&gt;&nbsp;\n\t\t&lt;constructor-arg type=\"String\" name=\"name\" value=\"abc\"/&gt;\n\t\t&lt;constructor-arg type=\"int\" name=\"level\" value=\"3\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"String\" name=\"property1\" value=\"Someone says\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"String\" name=\"property2\" value=\"Hello World!\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"com.test.service.BaseService\" name=\"ref1\" ref=\"baseservice\"/&gt;\n\t&lt;/bean&gt;\n\t&lt;bean id=\"baseservice\" class=\"com.test.service.BaseService\"&gt;&nbsp;\n\t&lt;/bean&gt;\t\n&lt;/beans&gt;\n</code></pre><p>回顾一下，现在完整的过程是：当Sevlet服务器启动时，Listener会优先启动，读配置文件路径，启动过程中初始化上下文，然后启动IoC容器，这个容器通过refresh()方法加载所管理的Bean对象。这样就实现了Tomcat启动的时候同时启动IoC容器。</p><h2>改造DispatcherServlet，关联WAC</h2><p>好了，到了这一步，IoC容器启动了，我们回来再讨论MVC这边的事情。我们已经知道，在服务器启动的过程中，会注册&nbsp;Web应用上下文，也就是WAC。 这样方便我们通过属性拿到启动时的&nbsp;WebApplicationContext 。</p><pre><code class=\"language-java\">this.webApplicationContext = (WebApplicationContext)&nbsp;this.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION _CONTEXT_ATTRIBUTE);\n</code></pre><p>因此我们改造一下DispatcherServlet这个核心类里的init()方法。</p><pre><code class=\"language-java\">public void init(ServletConfig config) throws ServletException {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; super.init(config);\n&nbsp; &nbsp; this.webApplicationContext = (WebApplicationContext)&nbsp;\nthis.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION _CONTEXT_ATTRIBUTE);\n&nbsp; &nbsp; sContextConfigLocation =&nbsp;config.getInitParameter(\"contextConfigLocation\");\n&nbsp; &nbsp; URL xmlPath = null;\n\ttry {\n\t\txmlPath = this.getServletContext().getResource(sContextConfigLocation);\n\t} catch (MalformedURLException e) {\n\t\te.printStackTrace();\n\t}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; this.packageNames = XmlScanComponentHelper.getNodeValue(xmlPath);&nbsp;   &nbsp; &nbsp; Refresh();\n}\n</code></pre><p>首先在Servlet初始化的时候，从sevletContext里获取属性，拿到Listener启动的时候注册好的WebApplicationContext，然后拿到Servlet配置参数contextConfigLocation，这个参数代表的是配置文件路径，这个时候是我们的MVC用到的配置文件，如minisMVC-servlet.xml，之后再扫描路径下的包，调用refresh()方法加载Bean。这样，DispatcherServlet也就初始化完毕了。</p><p>然后是改造initMapping()方法，按照新的办法构建URL和后端程序之间的映射关系：查找使用了注解&nbsp;@RequestMapping 的方法，将 URL 存放到&nbsp;urlMappingNames 里，再把映射的对象存放到&nbsp;mappingObjs 里，映射的方法存放到&nbsp;mappingMethods 里。用这个方法取代过去解析&nbsp;Bean 得到的映射，省去了XML文件里的手工配置。你可以看一下相关代码。</p><pre><code class=\"language-java\">protected void initMapping() {\n&nbsp; &nbsp; for (String controllerName : this.controllerNames) {\n&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; clazz = this.controllerClasses.get(controllerName);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Object obj = this.controllerObjs.get(controllerName);\n&nbsp; &nbsp; &nbsp; &nbsp; Method[] methods = clazz.getDeclaredMethods();\n&nbsp; &nbsp; &nbsp; &nbsp; if (methods != null) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Method method : methods) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean isRequestMapping =&nbsp;\nmethod.isAnnotationPresent(RequestMapping.class);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (isRequestMapping) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String methodName = method.getName();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String urlMapping =&nbsp;\nmethod.getAnnotation(RequestMapping.class).value();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.urlMappingNames.add(urlMapping);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.mappingObjs.put(urlMapping, obj);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.mappingMethods.put(urlMapping, method);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>最后稍微调整一下&nbsp;doGet() 方法内的代码，去除不再使用的结构。</p><pre><code class=\"language-java\">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n&nbsp; &nbsp; String sPath = request.getServletPath();\n\tif (!this.urlMappingNames.contains(sPath)) {\n\t\treturn;\n\t}\n\n&nbsp; &nbsp; Object obj = null;\n&nbsp; &nbsp; Object objResult = null;\n&nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; Method method = this.mappingMethods.get(sPath);\n&nbsp; &nbsp; &nbsp; &nbsp; obj = this.mappingObjs.get(sPath);\n&nbsp; &nbsp; &nbsp; &nbsp; objResult = method.invoke(obj);\n&nbsp;   }&nbsp;catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n&nbsp; &nbsp; response.getWriter().append(objResult.toString());&nbsp; &nbsp; &nbsp;\n}\n</code></pre><p>代码里的这个doGet()方法从请求中获取访问路径，按照路径和后端程序的映射关系，获取到需要调用的对象和方法，调用方法后直接把结果返回给response。</p><p>到这里，整合了IoC容器的MVC就完成了。</p><h2>验证</h2><p>下面进行测试，我们先看一下Tomcat使用的web.xml文件配置。</p><pre><code class=\"language-plain\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:web=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\"&gt;\n&nbsp; &lt;context-param&gt;\n&nbsp; &nbsp; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n&nbsp; &nbsp; &lt;param-value&gt;applicationContext.xml&lt;/param-value&gt;\n&nbsp; &lt;/context-param&gt;\n&nbsp; &lt;listener&gt;\n&nbsp; &nbsp; &lt;listener-class&gt;\n\t&nbsp; &nbsp; &nbsp; &nbsp; com.minis.web.ContextLoaderListener\n\t&nbsp; &nbsp; &lt;/listener-class&gt;\n&nbsp; &lt;/listener&gt;\n&nbsp; &lt;servlet&gt;\n&nbsp; &nbsp; &lt;servlet-name&gt;minisMVC&lt;/servlet-name&gt;\n&nbsp; &nbsp; &lt;servlet-class&gt;com.minis.web.DispatcherServlet&lt;/servlet-class&gt;\n&nbsp; &nbsp; &lt;init-param&gt;\n&nbsp; &nbsp; &nbsp; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n&nbsp; &nbsp; &nbsp; &lt;param-value&gt; /WEB-INF/minisMVC-servlet.xml &lt;/param-value&gt;\n&nbsp; &nbsp; &lt;/init-param&gt;\n&nbsp; &nbsp; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&nbsp; &lt;/servlet&gt;\n&nbsp; &lt;servlet-mapping&gt;\n&nbsp; &nbsp; &lt;servlet-name&gt;minisMVC&lt;/servlet-name&gt;\n&nbsp; &nbsp; &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n&nbsp; &lt;/servlet-mapping&gt;\n&lt;/web-app&gt;\n</code></pre><p>然后是IoC容器使用的配置文件applicationContext.xml。</p><pre><code class=\"language-plain\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans&gt;\n\t&lt;bean id=\"bbs\" class=\"com.test.service.BaseBaseService\"&gt;&nbsp;\n\t&nbsp; &nbsp; &lt;property type=\"com.test.service.AServiceImpl\" name=\"as\" ref=\"aservice\"/&gt;\n\t&lt;/bean&gt;\n\t&lt;bean id=\"aservice\" class=\"com.test.service.AServiceImpl\"&gt;&nbsp;\n\t\t&lt;constructor-arg type=\"String\" name=\"name\" value=\"abc\"/&gt;\n\t\t&lt;constructor-arg type=\"int\" name=\"level\" value=\"3\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"String\" name=\"property1\" value=\"Someone says\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"String\" name=\"property2\" value=\"Hello World!\"/&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;property type=\"com.test.service.BaseService\" name=\"ref1\" ref=\"baseservice\"/&gt;\n\t&lt;/bean&gt;\n\t&lt;bean id=\"baseservice\" class=\"com.test.service.BaseService\"&gt;&nbsp;\n\t&lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre><p>MVC扫描的配置文件minisMVC-servlet.xml。</p><pre><code class=\"language-plain\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;components&gt;\n&lt;component-scan base-package=\"com.test\"/&gt;\n&lt;/components&gt;\n</code></pre><p>最后，在com.minis.test.HelloworldBean内的测试方法上，增加@RequestMapping注解。</p><pre><code class=\"language-java\">package com.test;\n\nimport com.minis.web.RequestMapping;\n\npublic class HelloWorldBean {\n&nbsp; &nbsp; @RequestMapping(\"/test\")\n&nbsp; &nbsp; public String doTest() {\n&nbsp; &nbsp; &nbsp; &nbsp; return \"hello world for doGet!\";&nbsp; &nbsp; &nbsp;\n    }\n}\n</code></pre><p>启动Tomcat进行测试，在浏览器输入框内键入：localhost:8080/test。<br>\n<span class=\"reference\">注：这个端口号可以自定义，也可依据实际情况在请求路径前增加上下文。</span><br>\n运行成功，学到这里，看到这个结果，你应该很开心吧。</p><h2>小结</h2><p>这节课，我们把MVC与IoC整合在了一起。具体过程是这样的：在Tomcat启动的过程中先拿context-param，初始化Listener，在初始化过程中，创建IoC容器构建WAC（WebApplicationContext），加载所管理的Bean对象，并把WAC关联到servlet context里。</p><p>然后在DispatcherServlet初始化的时候，从sevletContext里获取属性拿到WAC，放到servlet的属性中，然后拿到Servlet的配置路径参数，之后再扫描路径下的包，调用refresh()方法加载Bean，最后配置url mapping。</p><p>我们之所以有办法整合这二者，核心的原因是<strong>Servlet规范中规定的时序</strong>，从listerner到filter再到servlet，每一个环节都预留了接口让我们有机会干预，写入我们需要的代码。我们在学习过程中，更重要的是要学习如何构建可扩展体系的思路，在我们自己的软件开发过程中，记住<strong>不要将程序流程固定死</strong>，那样没有任何扩展的余地，而应该想着预留出一些接口理清时序，让别人在关节处也可以插入自己的逻辑。</p><p>容器是一个框架，之所以叫做框架而不是应用程序，关键就在于这套可扩展的体系，留给其他程序员极大的空间。读Rodd Johnson这些大师的源代码，就像欣赏一本优美的世界名著，每每都会发出“春风大雅能容物，秋水文章不染尘”的赞叹。希望你可以学到其中的精髓。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课，我也给你留一道思考题。我们看到从Dispatcher 内可访问WebApplicationContext里面管理的Bean，那通过WebApplicationContext 可以访问Dispatcher内管理的Bean吗？欢迎你在留言区和我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","comments":[{"had_liked":false,"id":371951,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1680536930,"is_pvip":false,"replies":[{"id":135769,"content":"很对。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680587625,"ip_address":"澳大利亚","comment_id":371951,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"思考题：Spring中有父子容器的概念。子容器：MVC容器，父容器：Spring容器。子可以访问父，反过来不行，这是由Spring的体系结构决定的，子容器继承父容器，所以子容器是知道父容器的，所以也就能得到父容器的引用，进而得到父容器中的bean。但是父容器是无法知道子容器的，所以也就无法直接获取子容器中的bean，但是可以通过getBeanFactory来得到子容器，从而获取到子容器中的bean，但java的三层模型，controller---&gt;service---&gt;dao，controller注入service对象是正常的，service注入controller有点奇怪，一般不这么干。不知道以上理解的对不对","like_count":9,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612277,"discussion_content":"很对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680587625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371581,"user_name":"睿智的仓鼠","can_delete":false,"product_type":"c1","uid":2781305,"ip_address":"湖北","ucode":"914D56E47B01F2","user_header":"https://static001.geekbang.org/account/avatar/00/2a/70/79/bb591140.jpg","comment_is_top":false,"comment_ctime":1680078090,"is_pvip":false,"replies":[{"id":135576,"content":"感谢感谢。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680087128,"ip_address":"澳大利亚","comment_id":371581,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"文中代码实现了webApplicationContext的注入，但排版缺少了很重要的 populateBean()方法，没有使用到初始化好的ioc容器，github中相关的完整的代码是：\n```java\nDispatcherServlet：\n\nprotected void initController() {\n        this.controllerNames = scanPackages(this.packageNames);\n        for (String controllerName : this.controllerNames) {\n            Object obj = null;\n            Class&lt;?&gt; clz = null;\n            try {\n                clz = Class.forName(controllerName);\n                obj = clz.newInstance();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            this.controllerClasses.put(controllerName, clz);\n\n            populateBean(obj);\n            this.controllerObjs.put(controllerName, obj);\n        }\n    }\n\n    &#47;&#47; 处理controller中的@Autowired注解\n    private void populateBean(Object bean) {\n        Class&lt;?&gt; clz = bean.getClass();\n        Field[] fields = clz.getDeclaredFields();\n        for (Field field : fields) {\n            boolean isAutowired = field.isAnnotationPresent(Autowired.class);\n            if (isAutowired) {\n                String fieldName = field.getName();\n                Object autowiredBean = this.webApplicationContext.getBean(fieldName);\n                field.setAccessible(true);\n                try {\n                    field.set(bean, autowiredBean);\n                } catch (IllegalAccessException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n    }\n```","like_count":7,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611436,"discussion_content":"感谢感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680087128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372036,"user_name":"不是早晨，就是黄昏","can_delete":false,"product_type":"c1","uid":2645005,"ip_address":"河南","ucode":"B7132BA7740AFE","user_header":"https://static001.geekbang.org/account/avatar/00/28/5c/0d/9ec703ab.jpg","comment_is_top":false,"comment_ctime":1680619657,"is_pvip":false,"replies":[{"id":135793,"content":"多谢指正。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680675703,"ip_address":"澳大利亚","comment_id":372036,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"最后，在 com.minis.test.HelloworldBean 内的测试方法上\n但是你项目代码里有新建了一个test目录，且是和minis同级，而minisMVC-servlet.xml里配置的也是com.test，文章给的代码也是com.test里的，感觉写的有点过于随意了。。。。","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612424,"discussion_content":"多谢指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680675704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376535,"user_name":"Cooler","can_delete":false,"product_type":"c1","uid":1639184,"ip_address":"上海","ucode":"3D5192BE887A33","user_header":"https://static001.geekbang.org/account/avatar/00/19/03/10/82c56b87.jpg","comment_is_top":false,"comment_ctime":1686901469,"is_pvip":false,"replies":[{"id":137285,"content":"用到了","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1687141981,"ip_address":"澳大利亚","comment_id":376535,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，目前wac.setServletContext(servletContext); 这一块相关代码是不是没有用在这一章讲的内容","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621316,"discussion_content":"用到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687141981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374779,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"广东","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1684410607,"is_pvip":false,"replies":[{"id":136773,"content":"你往后面看再回首的时候，有这一部分的解释。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684545223,"ip_address":"澳大利亚","comment_id":374779,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"课后题，通过WebApplicationContext 可以访问到DispatcherServlet里面的bean吗？\n我觉得是分成两种情况来讲的？\n根据Servlet的时序来讲的话，那么当初始化好WebApplicationContext的时候，DispatcherServlet还没有进行初始化，所以是空的无法访问的；\n但是Servlet初始化完成后呢那应该是可以的？但是怎么访问？用一个方法？\n这个方法怎么表明他是IOC的bean的？有点乱了","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618781,"discussion_content":"你往后面看再回首的时候，有这一部分的解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684545223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374778,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"广东","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1684409382,"is_pvip":false,"replies":[{"id":136771,"content":"好的","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684538214,"ip_address":"澳大利亚","comment_id":374778,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"黑夜模式，代码里面的标签全没了，作者可以跟后台反馈一下吗 改一下颜色啥的","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618773,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684538214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373945,"user_name":"Geek_b71d2c","can_delete":false,"product_type":"c1","uid":2731263,"ip_address":"北京","ucode":"3E44D6B22E4451","user_header":"https://static001.geekbang.org/account/avatar/00/29/ac/ff/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1683367302,"is_pvip":false,"replies":[{"id":136609,"content":"web.xml文件中的初始化参数没给吧？参考Github上的","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1683373326,"ip_address":"澳大利亚","comment_id":373945,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，请问一下servletContext.getInitParameter(CONFIG_LOCATION_PARAM)一直获取到的是空，这是什么原因呀","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617200,"discussion_content":"web.xml文件中的初始化参数没给吧？参考Github上的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683373326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372906,"user_name":"杨松","can_delete":false,"product_type":"c1","uid":1512517,"ip_address":"辽宁","ucode":"FB3C73BC44C94D","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/45/adf079ae.jpg","comment_is_top":false,"comment_ctime":1681786121,"is_pvip":false,"replies":[{"id":136274,"content":"分开的, mvc容器的配置文件和ioc的不同，从mvc容器中可以访问到ioc容器。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681818199,"ip_address":"澳大利亚","comment_id":372906,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，在代码分支geek_mvc2中，ContextLoaderListener加载了资源文件applicationContext.xml中的bean对象，然后DispatcherServlet会加载&#47;WEB-INF&#47;minisMVC-servlet.xml并扫描包com.test，那么这个包下的对象即被ioc容器加载了，又被DispatcherServlet(mvc容器)加载了，是不是后续的分支会解决这个问题","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614537,"discussion_content":"分开的, mvc容器的配置文件和ioc的不同，从mvc容器中可以访问到ioc容器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681818199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371706,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1680217787,"is_pvip":false,"replies":[{"id":135622,"content":"你从Github上看目录结构吧。或者你手工建web项目，然后把github上的代码copy过来。 狭义的Spring是不需要依赖Tomcat的，可以独立的。但是如果要web功能，就的要一个servlet服务器，Tomcat只是一种。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680263401,"ip_address":"澳大利亚","comment_id":371706,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"请教老师几个问题：\nQ1：我用idea2019创建的后端项目并没有web.xml，为什么？\n我创建的是springboot项目，maven项目，src目录下面是main和test，main下面是java和resource，并没有WebContent目录，也没有WEB_INF目录，更没有web.xml文件。这个现象怎么解释？另外，不同的项目有不同的目录结构，目录结构的定义在哪里有官方说明？\nQ2：用idea创建的项目缺省是基于tomcat吗？\nQ3：spring必须基于tomcat，不能独立工作吗？\n按文中的说法，servlet必须要用tomcat这个容器，这样的话，spring并不能独立使用，必须依赖于tomcat。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611711,"discussion_content":"你从Github上看目录结构吧。或者你手工建web项目，然后把github上的代码copy过来。 狭义的Spring是不需要依赖Tomcat的，可以独立的。但是如果要web功能，就的要一个servlet服务器，Tomcat只是一种。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680263401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318633,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","nickname":"Geek_7jwpfc","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620265,"discussion_content":"Q1，maven项目是项目，不包含webapp，webapp是遵循servlet规范，让servlet容器加载用的，你需要手动添加webapp目录，不会可以通过搜索引擎查看；\nQ2, 如果不想安装tomcat，可以通过maven安装tomcat插件，artifactId坐标是“tomcat7-maven-plugin”，它会自动加载webapp下面的目录；\nQ3，Spring和SpringMVC不是同一个概念，Spring是容器的概念，SpringMVC是提供http服务的概念；Spring不单独提供web服务的能力，如果你问的是“Spring web服务功能不能单独运行”，那当然离不开servlet容器；\n所有的课程都是围绕spring容器的概念走的，我们要把springMVC放入spring容器中，但是spring容器由谁启动呢，这节的目的就是教我们如何通过servlet容器引导spring容器；\n实在不明白的话，可以看下我的github，maven目录结构，内置tomcat无需安装git@github.com:wanbing0610/mini-spring.git","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685987451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1463987,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cQVffRuscdhnF5vnQjgAZnbLwHDALl3TsAQsgEYCYPVfuFMSkyaTUXHs2aA0ORpx7AjI3LTR2ibKw2Q0VepymqA/132","nickname":"Geek_66158e","note":"","ucode":"8C3A579A715726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612622,"discussion_content":"而且自从servlet3.0规范开始，已经可以去除使用wem. xml转而使用java spi机制通过实现指定接口来替代web. xml。还有一个是这里讲得是war包部署方式，当前主流的是jar包部署了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680804004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1463987,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cQVffRuscdhnF5vnQjgAZnbLwHDALl3TsAQsgEYCYPVfuFMSkyaTUXHs2aA0ORpx7AjI3LTR2ibKw2Q0VepymqA/132","nickname":"Geek_66158e","note":"","ucode":"8C3A579A715726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612620,"discussion_content":"因为你创建的是spring boot项目，它默认使用的嵌入式的tomcat，和spring mvc项目差别比较大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680803854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371624,"user_name":"马儿","can_delete":false,"product_type":"c1","uid":2247080,"ip_address":"四川","ucode":"542E23D7B6AB01","user_header":"","comment_is_top":false,"comment_ctime":1680110901,"is_pvip":false,"replies":[{"id":135602,"content":"往后看。Spring里面是用了两层application context.","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680172609,"ip_address":"澳大利亚","comment_id":371624,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"课后习题：目前Dispatcher可以 访问到WebApplicationContext中的bean，Dispatcher中的bean目前也存在对象的属性中了，但是Dispatcher没有被WebApplicationContext引用所以不能被访问。请问老师spring在管理controller产生的bean的时候是将这些bean统一注册到WebApplicationContext吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611566,"discussion_content":"往后看。Spring里面是用了两层application context.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680172609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371599,"user_name":"Shark","can_delete":false,"product_type":"c1","uid":3567201,"ip_address":"浙江","ucode":"DDF4B1A407C669","user_header":"https://static001.geekbang.org/account/avatar/00/36/6e/61/b1273106.jpg","comment_is_top":false,"comment_ctime":1680085723,"is_pvip":false,"replies":[{"id":135575,"content":"慢慢看，后面会抽出两个application context来。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680086996,"ip_address":"澳大利亚","comment_id":371599,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"在tomcat启动的过程中，是先初始化IoC容器，再初始化DispatcherServlet，在初始化DispatcherServlet的过程中记录URI与负责执行的方法和方法的对象关系映射，所以这些URI对应的对象此时是由DispatcherServlet管理的，而非IoC容器，而DispatcherServlet也不是IoC容器管理的，后续是不是会统一到IoC容器中？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611435,"discussion_content":"慢慢看，后面会抽出两个application context来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680086996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383993,"user_name":"7up","can_delete":false,"product_type":"c1","uid":2923215,"ip_address":"江苏","ucode":"DBA81DBB0EA8D9","user_header":"https://static001.geekbang.org/account/avatar/00/2c/9a/cf/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1700052888,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"看代码这里将controller放到Dispatcher容器中，其他bean放到webApplicationContext容器中，在Dispatcher初始化时将两者关联起来，第7节课则是没有区分。统一放到了MVC容器中，没有关联IOC容器。","like_count":1}]}