{"id":134752,"title":"01 | 网络互联的昨天、今天和明天：HTTP 协议的演化","content":"<p>你好，我是四火。</p><p>HTTP 协议是互联网基础中的基础，和很多技术谈具体应用场景不同的是，几乎所有的互联网服务都是它的应用，没有它，互联网的“互联”将无从谈起，因此我们把它作为正式学习的开篇。</p><p>说到其原理和协议本身，我相信大多数人都能说出个大概来，比如，有哪些常见的方法，常见 HTTP 头，返回码的含义等等。但你是否想过，这个古老而富有生命力的互联网“基石”是怎样发展演化过来的呢？从它身上，我们能否管中窥豹，一叶知秋，找到互联网成长和演进的影子？</p><p>今天，我想带你从实践的角度，亲身感受下这个过程，相信除了 HTTP 本身，你还可以发现网络协议发展过程中的一些通用和具有共性的东西。</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/2a/ac90bdd14bced3d81e314a7eddf6972a.png?wh=665*75\" alt=\"\"></p><h2>HTTP/0.9</h2><p>和很多其它协议一样，1991年，HTTP 在最开始的 0.9 版就定义了协议最核心的内容，虽说从功能上看只是具备了如今内容的一个小小的子集。比如，确定了客户端、服务端的这种基本结构，使用域名/IP 加端口号来确定目标地址的方式，还有换行回车作为基本的分隔符。</p><p>它非常简单，不支持请求正文，不支持除了  GET  以外的其它方法，不支持头部，甚至没有版本号的显式指定，而且整个请求只有一行，因而也被称为“The One-line Protocol”。比如：</p><!-- [[[read_end]]] --><pre><code>GET /target.html\n</code></pre><p>虽说 0.9 版本如今已经极少见到了，但幸运的是 Google 还依然支持（Bing 和 Baidu 不支持）。我们不妨自己动手，实践一下！虽然不能使用浏览器，但别忘了，我们还有一个更古老的工具 telnet。在命令行下建立连接：</p><pre><code>telnet www.google.com 80\n</code></pre><p>你会看到类似这样的提示：</p><pre><code>Trying 2607:f8b0:400a:803::2004...\nConnected to www.google.com.\nEscape character is '^]'.\n</code></pre><p>好，现在输入以下请求：</p><pre><code>GET /\n</code></pre><p>（请注意这里没有版本号，并不代表 HTTP 协议没有版本号，而是 0.9 版本的协议定义的请求中就是不带有版本号，这其实是该版本的一个缺陷）</p><p>接着，你会看到 Google 把首页 HTML 返回了：</p><pre><code>HTTP/1.0 200 OK\n...（此处省略多行HTTP 头）\n\n...（此处省略正文）\n</code></pre><h2>HTTP/1.0</h2><p>到了1996年，HTTP 1.0 版本就稳定而成熟了，也是如今浏览器广泛支持的最低版本 HTTP 协议。引入了返回码，引入了 header，引入了多字符集，也终于支持多行请求了。</p><p>当然，它的问题也还有很多，支持的特性也远没有后来的 1.1 版本多样。比如，方法只支持 GET、HEAD、POST 这几个。但是，麻雀虽小五脏俱全，这是第一个具备广泛实际应用价值的协议版本。</p><p>你一样可以用和前面类似的方法来亲自动手实践一下，不过，HTTP 1.0 因为支持多行文本的请求，单纯使用 telnet 已经无法很好地一次发送它们了，其中一个解决办法就是使用 <a href=\"http://netcat.sourceforge.net/\">netcat</a>。</p><p>好，我们先手写一份 HTTP/1.0 的多行请求，并保存到一个文件 request.txt 中：</p><pre><code>GET / HTTP/1.0\nUser-Agent: Mozilla/1.22 (compatible; MSIE 2.0; Windows 3.1)\nAccept: text/html\n\n</code></pre><p>（根据协议，无论请求还是响应，在 HTTP 的头部结束后，必须增加一个额外的换行回车，因此上述代码最后这个空行是必须的，如果是 POST 请求，那么通常在这个空行之后会有正文）</p><p>你看上面的 User-Agent，我写入了一个<a href=\"https://developers.whatismybrowser.com/useragents/parse/2868-internet-explorer-windows-trident\">假的浏览器和操作系统版本</a>，假装我穿越来自 Window 3.1 的年代，并且用的是 IE 2.0，这样一来，我想不会有人比我更“老”了吧。</p><p>好，接着用类似的方法，使用 netcat 来发送这个请求：</p><pre><code>netcat www.google.com 80 &lt; ~/Downloads/request.txt\n</code></pre><p>一样从 Google 收到了成功的报文。</p><p>不知这样的几次动手是否能给你一个启示：懂一点特定的协议，使用简单的命令行和文本编辑工具，我们就已经可以做很多事情了。比如上面这样改变 UA 头的办法，可以模拟不同的浏览器，就是用来分析浏览器适配（指根据不同浏览器的兼容性返回不同的页面数据）的常用方法。</p><h2>HTTP/1.1</h2><p>1999 年，著名的 RFC2616，在 1.0 的基础上，大量帮助传输效率提升的特性被加入。</p><p>你可能知道，从网络协议分层上看， TCP 协议在 HTTP 协议的下方（TCP 是在 OSI 7 层协议的第 4 层，而 HTTP 则是在最高的第 7 层应用层，因此，前者更加“底层”一点）。</p><p>在 HTTP 1.0 版本时，每一组请求和响应的交互，都要完成一次 TCP 的连接和关闭操作，这在曾经的互联网资源比较贫瘠的时候并没有暴露出多大的问题，但随着互联网的迅速发展，这种通讯模式显然过于低效了。</p><p>于是这个问题的解决方案——HTTP 的长连接，就自然而然地出现了，它指的是打开一次 TCP 连接，可以被连续几次报文传输重用，这样一来，我们就不需要给每次请求和响应都创建专门的连接了：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/f9/2e5a9e7cdc1560967168e96c642517f9.jpg?wh=1801*1406\" alt=\"\">（上图来自 <a href=\"https://medium.com/platform-engineer/evolution-of-http-69cfe6531ba0\">Evolution of HTTP — HTTP/0.9, HTTP/1.0, HTTP/1.1, Keep-Alive, Upgrade, and HTTPS</a>）</p><p>可以看到，<strong>通过建立长连接，中间的几次 TCP 连接开始和结束的握手都省掉了。</strong></p><p>那好，我们还是使用 netcat，这次把版本号改成 1.1，同时打开长连接：</p><pre><code>GET / HTTP/1.1\nHost: www.google.com\nUser-Agent: Mozilla/1.22 (compatible; MSIE 2.0; Windows 3.1)\nConnection: keep-alive\nAccept: text/html\n\n</code></pre><p>（别忘了上面那个空行）</p><p>相信你也注意到了上面客户端要求开启长连接的 HTTP 头：</p><pre><code>Connection: keep-alive\n</code></pre><p>再按老办法运行：</p><pre><code>netcat www.google.com 80 &lt; ~/Downloads/request.txt\n</code></pre><p>我们果然得到了 Google 的响应：</p><pre><code>HTTP/1.1 200 OK\nDate: ...\nExpires: -1\nCache-Control: private, max-age=0\nContent-Type: text/html; charset=ISO-8859-1\nTransfer-Encoding: chunked\n...（此处省略多行HTTP 头）\n\n127a\n...（此处省略 HTML）\n0\n\n</code></pre><p>但是在响应中，值得注意的有两点：</p><ol>\n<li>在 HTTP 头部，有这样一行：</li>\n</ol><pre><code>Transfer-Encoding: chunked\n</code></pre><ol>\n<li>正文的内容是这样的：</li>\n</ol><pre><code>127a\n...\n0\n\n</code></pre><p>同时，之前我们见到过头部的 Content-Length 不见了。这是怎么回事呢？</p><p>事实上，如果协议头中存在上述的 chunked 头，表示将采用分块传输编码，响应的消息将由若干个块分次传输，而不是一次传回。刚才的 127a，指的是接下去这一块的大小，在这些有意义的块传输完毕后，会紧跟上一个长度为 0 的块和一个空行，表示传输结束了，这也是最后的那个 0 的含义。</p><p>值得注意的是，实际上在这个 0 之后，协议还允许放一些额外的信息，这部分会被称作“<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer\">Trailer</a>”，这个额外的信息可以是用来校验正确性的 checksum，可以是数字签名，或者传输完成的状态等等。</p><p>在长连接开启的情况下，使用 Content-Length 还是 chunked 头，必须具备其中一种。<strong>分块传输编码大大地提高了HTTP 交互的灵活性</strong>，服务端可以在还不知道最终将传递多少数据的时候，就可以一块一块将数据传回来。在 [第  03  讲] 中，你还会看到藉由分块传输，可以实现一些模拟服务端推送的技术，比如 <a href=\"https://en.wikipedia.org/wiki/Comet_(programming)\">Comet</a>。</p><p>事实上 HTTP/1.1 还增加了很多其它的特性，比如更全面的方法，以及更全面的返回码，对指定客户端缓存策略的支持，对 content negotiation 的支持（即通过客户端请求的以 Accept 开头的头部来告知服务端它能接受的内容类型），等等。</p><h2>HTTP/2</h2><p>现在最广泛使用的 HTTP 协议还是 1.1 ，但是 HTTP/2  已经提出，在保持兼容性的基础上，包含了这样几个重要改进：</p><ul>\n<li>设计了一种机制，允许客户端来选择使用的 HTTP 版本，这个机制被命名为 ALPN；</li>\n<li>HTTP 头的压缩，在 HTTP/2  以前，HTTP 正文支持多种方式的压缩，但是 HTTP 头部却不能；</li>\n<li>多路复用，允许客户端同时在一个连接中同时传输多组请求响应的方法；</li>\n<li>服务端的 push 机制，比方说客户端去获取一个网页的时候，下载网页，分析网页内容，得知还需要一个 js 文件和一个 css 文件，于是再分别下载，而服务端的 push 机制可以提前就把这些资源推送到客户端，而不需要客户端来索取，从而节约网页加载总时间。</li>\n</ul><p>在 HTTP/2 之后，我们展望未来，HTTP/3 已经箭在弦上。如同前面的版本更新一样，依旧围绕传输效率这个协议核心来做进一步改进，其承载协议将从 TCP 转移到基于 UDP 的 <a href=\"https://en.wikipedia.org/wiki/QUIC\">QUIC</a> 上面来。</p><p>最后，我想说的是，<strong>HTTP 协议的进化史，恰恰是互联网进化史的一个绝佳缩影</strong>，从中你可以看到互联网发展的数个特质。比方说，长连接和分块传输很大程度上增强了 HTTP 交互模型上的灵活性，使得 B/S 架构下的消息即时推送成为可能。</p><h2>总结思考</h2><p>今天我们了解了 HTTP 协议的进化史，并且用了动手操作的方法来帮助你理解内容，还分析了其中两个重要的特性，长连接和分块传输。希望经过今天的实践，除了知识本身的学习，你还能够<strong>在快速的动手验证中，强化自己的主观认识，并将这种学习知识的方式培养成一种习惯，这是学习全栈技能的一大法宝</strong>。</p><p>现在，让我们来进一步思考这样两个问题：</p><ul>\n<li>文中介绍了分块传输的 HTTP 特性，你觉得它可以应用到哪些具体场景？</li>\n<li>如果让你去设计一个新的网络协议，你能否举例设计的过程中需要遵循哪些原则？</li>\n</ul><p>好，今天的分享就到这里，欢迎提出你的疑问，也期待你留言与我交流！</p><h2>选修课堂：抓一段 HTTP 的包</h2><p>如果你对于使用 tcpdump 进行网络抓包这个技能已经了解了，就可以跳过下面的内容。反之，推荐你动动手。因为在学习任何网络协议的时候，网络抓包是一个非常基本的实践前置技能；而在实际定位问题的时候，也时不时需要抓包分析。这也是我在第一讲就放上这堂选修课的原因。</p><p>俗话说，耳听为虚，眼见为实，下面让我们继续动手实践。你当然可以尝试抓访问某个网站的包，但也可以在本机自己启动一个 web 服务，抓一段 HTTP GET 请求的报文。</p><p>利用 Python，在任意目录，一行命令就可以在端口 8080 上启动一个完备的 HTTP  服务（这大概是世界上最简单的启动一个 HTTP 服务的方式了）：</p><pre><code>python -m SimpleHTTPServer 8080\n</code></pre><p>启动成功后，你应该能看到：</p><pre><code>Serving HTTP on 0.0.0.0 port 8080 ...\n</code></pre><p>接着使用 tcpdump  来抓包，注意抓的是 loopback  的包（本地发送到本地），因此执行：</p><pre><code>sudo tcpdump -i lo0 -v 'port 8080' -w http.cap\n</code></pre><p>这里的 -i 参数表示指定 interface，而因为客户端和服务端都在本地，因此使用  lo0（我使用的是 Mac，在某些Linux操作系统下可能是  lo，具体可以通过  ifconfig  查看）指定  loopback  的接口，这里我们只想捕获发往  8080  端口的数据包，结果汇总成  http.cap  文件。</p><p>打开浏览器敲入 <a href=\"http://localhost:8080\">http://localhost:8080</a>  并回车，应该能看到启动  HTTP  服务路径下的文件（夹）列表。这时候你也应该能看到类似下面这样的文字，标志着多少包被捕获，多少包被过滤掉了：</p><pre><code>24 packets captured\n232 packets received by filter\n</code></pre><p>好，现在我们使用 CTRL + C 结束这个抓包过程。</p><p>抓包后使用 <a href=\"https://www.wireshark.org/\">Wireshark</a>  打开该  http.cap  文件，在  filter  里面输入  http  以过滤掉别的我们不关心的数据包，我们应该能看到请求和响应至少两条数据。于是接下去的内容就是我们非常关心的了。</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/d8/2bdc949865ae703a08ffd528d44e3ad8.jpeg?wh=572*108\" alt=\"\"></p><p>如果你看到这里，我想请你再思考下，在不设置上面的 http filter 的时候，我们会看到比这多得多的报文，它们不是 HTTP 的请求响应所以才被过滤掉了，那么，它们都有什么呢？</p><h2>扩展阅读</h2><ul>\n<li>【基础】如果你对 HTTP 还不熟悉的话，推荐你阅读一篇系统性介绍 HTTP 的教程，比如 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP\">MDN 的这篇教程</a>。</li>\n<li>【基础】<a href=\"https://www.networkworld.com/article/3239677/the-osi-model-explained-how-to-understand-and-remember-the-7-layer-network-model.html\">The OSI model explained: How to understand (and remember) the 7 layer network model</a>：如果你对网络的 OSI 7 层模型还不清楚的话，建议阅读。如果你想知道那些鼎鼎大名的网络协议在这个模型中的哪个位置，那么请从 <a href=\"https://en.wikipedia.org/wiki/List_of_network_protocols_(OSI_model)\">List of network protocols (OSI model)</a> 里面找。基于聚焦主题的关系，我们在这个专栏中不会详细介绍呈现层（Presentation Layer）之下的网络协议。</li>\n<li>HTTP <a href=\"https://tools.ietf.org/html/rfc1945\">1.0</a>、<a href=\"https://tools.ietf.org/html/rfc2616\">1.1</a> 和 <a href=\"https://tools.ietf.org/html/rfc7540\">2.0</a>：它们是 RFC 文档，看起来似乎枯燥乏味，通常我们不需要去仔细阅读它们，但是当我们想知道对协议的理解是否正确，它们是我们最终的参考依据。</li>\n<li><a href=\"http://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf\">Key differences between HTTP 1.0 and HTTP 1.1</a>：文中总结了从 HTTP 1.0 到 1.1 的 9 大改进；而 <a href=\"http://qnimate.com/post-series/http2-complete-tutorial/\">HTTP/2 Complete Tutorial</a> 是一篇比较系统的 HTTP/2 的介绍。</li>\n</ul><p></p>","comments":[{"had_liked":false,"id":132489,"user_name":"William","can_delete":false,"product_type":"c1","uid":1241365,"ip_address":"","ucode":"4499F99B180102","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/15/8fcf8038.jpg","comment_is_top":true,"comment_ctime":1568137435,"is_pvip":true,"replies":[{"id":"50720","content":"笔记部分：<br>优秀，说得太棒了。做一点小小的说明：文中说的客户端和服务端的概念完全是从网络和协议的角度来进行的，和我们平时提到的选择 C&#47;S 还是 B&#47;S 的“应用模式”有所区别。HTTP 本身和选用 C&#47;S（Client&#47;Server）还是 B&#47;S（Browser&#47;Server）并没有必然关系。也就是说，无论你使用客户端还是浏览器，都可以使用 HTTP 方式和服务端交流。<br><br>思考题部分：<br>1. 分块传输和 Ajax 并没有直接联系，也就是说，分块传输可以使用、也可以不使用 Ajax 来完成。Ajax 的要点是使用异步 JavaScript 的方式来请求和处理网页上的数据。因此，这个问题，你可以再想想。:) （顺便预告一下，我们在 03 篇就会介绍其中的一个使用场景）<br>2. 正确。当然，还有其他的原则，比如数据传输的效率，可靠性，协议本身的向后兼容性，等等等等。<br>抓包的问题：正确，其它的基本都是 TCP 层的报文（当然，不只有连接建立握手的报文）。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568175361,"ip_address":"","comment_id":132489,"utype":1}],"discussion_count":3,"race_medal":0,"score":"9.2233721286171996e+18","product_id":100035501,"comment_content":"【📒笔记-HTTP发展史】<br>+ HTTP&#47;0.9 确立了C&#47;S架构，域名、IP、端口。换行回车作为基本分隔符。<br>+ HTTP&#47;1.0 返回码、header、多字符集、多行请求支持<br>+ HTTP&#47;1.1 长连接keep-alive。分块传输chunked。方法、返回码更全面，缓存控制策略，content negotiation。<br>+ HTTP&#47;2.0 头部压缩。多路复用(仍然存在线头阻塞)。二进制传输支持。服务端推送。ALPN。<br>+ HTTP&#47;3.0 0RTT建连(UDP)、多路复用(无线头阻塞)。<br>【思考题】<br>1.分块传输的应用场景：分部加载请求，缩短用户首屏等待时间，提高用户体验。是一种比ajax更好的方案，能少量的请求数。<br>2.语义明确无歧义。<br>【抓包思考题】<br>HTTP请求和响应报文之外，很多是TCP握手报文，用于建立和断开端到端的TCP可靠连接。TCP是HTTP和HTTPS的低层协议，保证数据可靠性、完整性、有序性等。","like_count":22,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466968,"discussion_content":"笔记部分：\n优秀，说得太棒了。做一点小小的说明：文中说的客户端和服务端的概念完全是从网络和协议的角度来进行的，和我们平时提到的选择 C/S 还是 B/S 的“应用模式”有所区别。HTTP 本身和选用 C/S（Client/Server）还是 B/S（Browser/Server）并没有必然关系。也就是说，无论你使用客户端还是浏览器，都可以使用 HTTP 方式和服务端交流。\n\n思考题部分：\n1. 分块传输和 Ajax 并没有直接联系，也就是说，分块传输可以使用、也可以不使用 Ajax 来完成。Ajax 的要点是使用异步 JavaScript 的方式来请求和处理网页上的数据。因此，这个问题，你可以再想想。:) （顺便预告一下，我们在 03 篇就会介绍其中的一个使用场景）\n2. 正确。当然，还有其他的原则，比如数据传输的效率，可靠性，协议本身的向后兼容性，等等等等。\n抓包的问题：正确，其它的基本都是 TCP 层的报文（当然，不只有连接建立握手的报文）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568175361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042793,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e9/69/779b48c2.jpg","nickname":"苏忆","note":"","ucode":"B8BE78280CCB99","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555422,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646898224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032000,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bf/40/94eaca1b.jpg","nickname":"wei","note":"","ucode":"8B14D27AE7C54E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403605,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634116566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133184,"user_name":"四喜","can_delete":false,"product_type":"c1","uid":1071389,"ip_address":"","ucode":"C5EBED19C0F332","user_header":"https://static001.geekbang.org/account/avatar/00/10/59/1d/c89abcd8.jpg","comment_is_top":false,"comment_ctime":1568436535,"is_pvip":false,"replies":[{"id":"51081","content":"嗯，了解。很好的建议。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568500854,"ip_address":"","comment_id":133184,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48813076791","product_id":100035501,"comment_content":"因为有墙的原因，所以需要海外节点才能telnet到google的80端口。<br><br>建议使用https:&#47;&#47;labs.play-with-docker.com ，可以一份中之内拉起一个海外linux实例。","like_count":12,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467285,"discussion_content":"嗯，了解。很好的建议。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568500854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010996,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6d/34/1912bdf2.jpg","nickname":"TechCheng","note":"","ucode":"D85039641DA73C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34372,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571196159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135149,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1569043899,"is_pvip":false,"replies":[{"id":"51924","content":"好问题。<br><br>这两个是不一样的，keep-alive 是不关闭 TCP 连接，也就是长连接，但是在不使用管道机制的情况下，交互是单工的，即客户端必须要等前一个请求的响应返回之后，新的请求才能发过去。而在使用管道机制的情况下，请求发送可以非阻塞，但是响应返回必须依然严格按照请求的顺序。<br><br>而多路复用则是基于流的，那么在传输的时候，无论请求还是响应，只要逻辑上允许就可以传输，如果两个请求没有依赖关系可以不必等待前一个返回而直接发送，虽说用的是同一条连接。<br><br>长连接需要客户端和服务端都要支持，同时 HTTP&#47;1.1 的 keep-alive 要打开，对于这个 TCP 连接的维护，大多数 web 服务器都支持。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569174270,"ip_address":"","comment_id":135149,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35928782267","product_id":100035501,"comment_content":"1.1长连接keep-alive和2.0的多路复用有什么区别？<br>通过请求自己的后端服务，抓包发现是每次交互都要使用一个tcp连接，如果要使用http1.1的长连接功能，是后端的实现吧，请问具体应该如何实现，让后端支持长连接？","like_count":9,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468067,"discussion_content":"好问题。\n\n这两个是不一样的，keep-alive 是不关闭 TCP 连接，也就是长连接，但是在不使用管道机制的情况下，交互是单工的，即客户端必须要等前一个请求的响应返回之后，新的请求才能发过去。而在使用管道机制的情况下，请求发送可以非阻塞，但是响应返回必须依然严格按照请求的顺序。\n\n而多路复用则是基于流的，那么在传输的时候，无论请求还是响应，只要逻辑上允许就可以传输，如果两个请求没有依赖关系可以不必等待前一个返回而直接发送，虽说用的是同一条连接。\n\n长连接需要客户端和服务端都要支持，同时 HTTP/1.1 的 keep-alive 要打开，对于这个 TCP 连接的维护，大多数 web 服务器都支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569174270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133832,"user_name":"CC","can_delete":false,"product_type":"c1","uid":1021014,"ip_address":"","ucode":"2B732860C4231B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/56/4b8395f6.jpg","comment_is_top":false,"comment_ctime":1568681510,"is_pvip":true,"replies":[{"id":"51367","content":"感谢你的回答，同时也感谢指出 Python3 下的方法。<br>关于你的问题，开始的部分是 TCP 的 handshake，后面还有数据传输，以及 teardown。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568694646,"ip_address":"","comment_id":133832,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27338485286","product_id":100035501,"comment_content":"思考题1：<br><br>分块传输两个特性：<br>1. 分块传输可以保持 HTTP 的持续链接（即 Keep-Alive）。<br>2. 分块传输可以让客户端在 body 信息发送完后，继续发送额外的 header 信息。<br><br>基于这两个特性，暂时想到下面两个类似的应用场景：<br>- 优先传输网页上最重要的内容（比如首屏内容，首屏 CSS），其他延后传输。<br>- 页面上内容的长度未知的场景，比如瀑布流布局。<br>- 可以在内容传输后，加上 Expires header，来告知内容是否已经过期。<br><br><br><br>思考题2：<br><br>暂时想到下面这些设计原则：<br>- 向前兼容<br>- 简单易用<br>- 可扩展<br><br><br><br>抓包：<br><br>第一次使用 Wireshark 分析抓包，感觉很有趣。<br><br>filter 的都是 TCP，而且发现大部分 TCP 都是成对出现，dest 和 src 相互交换。不知道这是不是就是文中提到的「握手」？<br><br>使用 python3 的朋友，如果发现文中的代码不好用，是因为 SimpleHTTPServer 在 3 中合并入了 http library，可以使用 http.server 替代，代码如下：<br><br>python -m http.server 8080<br><br><br>谢谢扩展阅读，学到之前很多不知道的知识。","like_count":6,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467521,"discussion_content":"感谢你的回答，同时也感谢指出 Python3 下的方法。\n关于你的问题，开始的部分是 TCP 的 handshake，后面还有数据传输，以及 teardown。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568694646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132943,"user_name":"seamoontime","can_delete":false,"product_type":"c1","uid":1235304,"ip_address":"","ucode":"09E36EAE215355","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/68/38703855.jpg","comment_is_top":false,"comment_ctime":1568280185,"is_pvip":false,"replies":[{"id":"50948","content":"专栏几乎所有的例子都可以使用别的 HTTPS 网站来完成。这一篇里面除了 HTTP&#47;0.9 那个小部分不能以外，其它全部都可以使用百度或者 Bing 完成。:)","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568301186,"ip_address":"","comment_id":132943,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23043116665","product_id":100035501,"comment_content":"老师例子能不能用百度，bing之类的，谷歌国内不可用啊","like_count":5,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467186,"discussion_content":"专栏几乎所有的例子都可以使用别的 HTTPS 网站来完成。这一篇里面除了 HTTP/0.9 那个小部分不能以外，其它全部都可以使用百度或者 Bing 完成。:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568301186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132518,"user_name":"pyhhou","can_delete":false,"product_type":"c1","uid":1256496,"ip_address":"","ucode":"31EF8D50CF91A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","comment_is_top":false,"comment_ctime":1568160442,"is_pvip":false,"replies":[{"id":"50722","content":"1. 对，“一次传不完”是其中一个应用场景。它和 TCP 或 UDP 的 packet 的概念有些像，但是他们是在不同的层次，一个是在应用层，一个是在传输层。<br>2. 嗯，这些都是很好的方面。<br>选修课堂问题：正确","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568178238,"ip_address":"","comment_id":132518,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18748029626","product_id":100035501,"comment_content":"思考题：<br>1. 当需要传输一个大文件，不能一次传完，可以使用分块传输，这里的分块传输和 UDP 中的分块传输类似吗？<br>2. 罗列了下，大概有几点：<br>    1）不存在歧义，计算机最难做的事就是做选择<br>    2）尽可能地简单<br>    3）保证以后容易扩展<br>    4）尽可能模块化<br>    5）对于发送操作一定要严格，对于接收操作要有一定的容忍度<br><br>选修课堂思考题：<br>除了 HTTP 报文外，剩下的都是 TCP 报文，因为 TCP 是 HTTP 的下一层，其需要建立连接，并接收或者发送数据到 HTTP，有了 TCP 报文才能够更为详细地反应网络中数据的传递","like_count":4,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466986,"discussion_content":"1. 对，“一次传不完”是其中一个应用场景。它和 TCP 或 UDP 的 packet 的概念有些像，但是他们是在不同的层次，一个是在应用层，一个是在传输层。\n2. 嗯，这些都是很好的方面。\n选修课堂问题：正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568178238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133017,"user_name":"infrared628","can_delete":false,"product_type":"c1","uid":1139985,"ip_address":"","ucode":"33D1181918FACD","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/11/04d6a42c.jpg","comment_is_top":false,"comment_ctime":1568313547,"is_pvip":false,"replies":[{"id":"50958","content":"关于 Google 那个，不清楚你的网络环境是否有特别的限制，否则应该是能够使用 telnet 的。你可以试试别的服务，看看telnet是否能访问。另外，telnet 只是建立了 tcp 连接，你需要发送消息才能得到响应。比如，在我的Mac上如下：telnet www.google.com 80<br>Trying 2607:f8b0:400a:809::2004...<br>Connected to www.google.com.<br>Escape character is &amp;#39;^]&amp;#39;.<br>GET &#47;<br>...<br><br>netcat 的话，那个例子不是使用交互模式，而是直接运行：netcat www.google.com 80 &lt; 文件路径","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568346348,"ip_address":"","comment_id":133017,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10158248139","product_id":100035501,"comment_content":"我可以access google，但是使用telnet www.google.com 80后cmd中啥也没有，按ctrl+c退出后cmd中看到出现以下错误：<br><br>HTTP&#47;1.0 400 Bad Request<br>Content-Length: 54<br>Content-Type: text&#47;html; charset=UTF-8<br>Date: Thu, 12 Sep 2019 18:28:18 GMT<br><br>&lt;html&gt;&lt;title&gt;Error 400 (Bad Request)!!1&lt;&#47;title&gt;&lt;&#47;html&gt;<br><br>这是google不支持telnet了吗？然后我试了下telnet www.example.com 80，同样cmd中啥也没有，按ctrl+c退出后出现以下信息说unimplemented：<br><br>HTTP&#47;1.0 501 Not Implemented<br>Content-Type: text&#47;html<br>Content-Length: 357<br>Connection: close<br>Date: Thu, 12 Sep 2019 18:30:31 GMT<br>Server: ECSF (bsa&#47;EB24)<br><br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;<br>                                           &lt;!DOCTYPE html PUBLIC &quot;-&#47;&#47;W3C&#47;&#47;DTD XHTML 1.0 Transitional&#47;&#47;EN&quot;<br>                                                                                                                  &quot;http:&#47;&#47;www.w3.org&#47;TR&#47;xhtml1&#47;DTD&#47;xhtml1-transitional.dtd&quot;&gt;<br>                                                    &lt;html xmlns=&quot;http:&#47;&#47;www.w3.org&#47;1999&#47;xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>                &lt;title&gt;501 - Not Implemented&lt;&#47;title&gt;<br>                                                        &lt;&#47;head&gt;<br>                                                                &lt;body&gt;<br>                                                                                &lt;h1&gt;501 - Not Implemented&lt;&#47;h1&gt;<br>                                                                                                                &lt;&#47;body&gt;<br>                                                                                                                       &lt;&#47;html&gt;<br><br><br>Connection to host lost.<br><br><br>然后装了netcat，在安装目录下写好课件里面的request.txt，然后运行nc后在Cmd line后面输入 www.google.com 80 &lt; ~request.txt或者www.example.com 80 &lt; ~request.txt，运行后说 invalid port &lt; ~request.txt，请问老师为什么port会是invalid？<br><br>上面这些错误是我运行有误还是windows的问题？<br>","like_count":2,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467219,"discussion_content":"关于 Google 那个，不清楚你的网络环境是否有特别的限制，否则应该是能够使用 telnet 的。你可以试试别的服务，看看telnet是否能访问。另外，telnet 只是建立了 tcp 连接，你需要发送消息才能得到响应。比如，在我的Mac上如下：telnet www.google.com 80\nTrying 2607:f8b0:400a:809::2004...\nConnected to www.google.com.\nEscape character is &amp;amp;#39;^]&amp;amp;#39;.\nGET /\n...\n\nnetcat 的话，那个例子不是使用交互模式，而是直接运行：netcat www.google.com 80 &amp;lt; 文件路径","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568346348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257990,"user_name":"唯心主义蠢货🍁","can_delete":false,"product_type":"c1","uid":1941034,"ip_address":"","ucode":"836B09E0459953","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9e/2a/f1d8913f.jpg","comment_is_top":false,"comment_ctime":1604237006,"is_pvip":false,"replies":[{"id":"93920","content":"协议设计的需要考虑的角度有很多，你说的都正确，也可以看看别人的补充。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1604277809,"ip_address":"","comment_id":257990,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5899204302","product_id":100035501,"comment_content":"1. 分块传输针对大文件传输过程，比如下载某个视频或者音频的过程<br>2. 设计一个协议的话，如果像http基于tcp，tcp保证了数据可以完整到达接收端，http只需要约定内容，分为请求和响应过程。<br>为了传输速度快，需要协议尽可能简洁<br>为了保证信息无误差，需要强制性规定<br>为了保证消息传输内容不同，需要满足可拓展性","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508520,"discussion_content":"协议设计的需要考虑的角度有很多，你说的都正确，也可以看看别人的补充。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604277809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220258,"user_name":"啊啦啦啦啦啦","can_delete":false,"product_type":"c1","uid":2003364,"ip_address":"","ucode":"0DC4DD56A36C7C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/91/a4/5606a292.jpg","comment_is_top":false,"comment_ctime":1590216679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885183975","product_id":100035501,"comment_content":"抓包这个操作如果想在win上执行，可以尝试一下 WinDump","like_count":2},{"had_liked":false,"id":137051,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1569584935,"is_pvip":false,"replies":[{"id":"52758","content":"你可以使用其它的 HTTPS 网站，原理是一样的。你也可以看其它的回复，有朋友给出了其它办法。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569690228,"ip_address":"","comment_id":137051,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864552231","product_id":100035501,"comment_content":"第一个坎 telnet google 时被gfw  如何破解","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468918,"discussion_content":"你可以使用其它的 HTTPS 网站，原理是一样的。你也可以看其它的回复，有朋友给出了其它办法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569690228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135015,"user_name":"Jasonfan","can_delete":false,"product_type":"c1","uid":1288175,"ip_address":"","ucode":"8152F929B24865","user_header":"https://static001.geekbang.org/account/avatar/00/13/a7/ef/3469bd6c.jpg","comment_is_top":false,"comment_ctime":1568978801,"is_pvip":false,"replies":[{"id":"51830","content":"这个协议里面并未规定具体时间：在没有数据传输的时候，保持一定的时间，之后服务端和客户端都可以主动结束长连接。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568998662,"ip_address":"","comment_id":135015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863946097","product_id":100035501,"comment_content":"四火老师，有个小疑问，长连接保持多久，什么时候结束长链接，进行下一次三次握手<br>","like_count":2,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468001,"discussion_content":"这个协议里面并未规定具体时间：在没有数据传输的时候，保持一定的时间，之后服务端和客户端都可以主动结束长连接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568998662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132874,"user_name":"谷径","can_delete":false,"product_type":"c1","uid":1019965,"ip_address":"","ucode":"D3462BF93E7A1B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/3d/7f5c1b37.jpg","comment_is_top":false,"comment_ctime":1568257081,"is_pvip":false,"replies":[{"id":"50899","content":"你要是能贴出问题来大家可能能一起看一下。另外，你看看是不是这个原因：由于某些原因我的文章中没有使用 python 3，如果你用的是 python3，命令是 python3 -m http.server 8080 （当然，如果你默认的 python 版本就是 3.xx 的，那么使用 python 替换 python3）<br><br>当然，你也完全可以抓访问其他网站的包，tcpdump 的命令需要稍微改一改（不是抓本机的 loopback 的包了）。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568264636,"ip_address":"","comment_id":132874,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863224377","product_id":100035501,"comment_content":"在mac终端bash中，直接用python -m SimpleHTTPServer 8080 提示语法有错，不知道什么原因<br>","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467155,"discussion_content":"你要是能贴出问题来大家可能能一起看一下。另外，你看看是不是这个原因：由于某些原因我的文章中没有使用 python 3，如果你用的是 python3，命令是 python3 -m http.server 8080 （当然，如果你默认的 python 版本就是 3.xx 的，那么使用 python 替换 python3）\n\n当然，你也完全可以抓访问其他网站的包，tcpdump 的命令需要稍微改一改（不是抓本机的 loopback 的包了）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568264636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132826,"user_name":"Franklin.du","can_delete":false,"product_type":"c1","uid":1005891,"ip_address":"","ucode":"A249024B44A164","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/43/66e5643a.jpg","comment_is_top":false,"comment_ctime":1568248512,"is_pvip":false,"replies":[{"id":"50897","content":"感谢你的认可！","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568264251,"ip_address":"","comment_id":132826,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863215808","product_id":100035501,"comment_content":"刚看到标题以为是一篇枯燥的介绍http协议历史的文章，看了以后发现这种和实践相结合的内容很有意思，这个专栏应该会有很多收获。感谢四火老师。另外其它学员的留言也很有启发，希望自己以后也能有高质量都留言。","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467138,"discussion_content":"感谢你的认可！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568264251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132807,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1568244397,"is_pvip":false,"replies":[{"id":"50896","content":"其实流媒体有使用 HTTP 也有不使用 HTTP 的，其它方面理解正确。对于协议的问题，理解挺不错的，当然，这两个都 是开放的问题，你也可以看看其他人的回答 :)","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568264212,"ip_address":"","comment_id":132807,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863211693","product_id":100035501,"comment_content":"问题一：在线视频播放，先传输完整视频的部分包，让视频缓冲播放，提升用户体验。当然，流媒体是不走http协议的，走http的类似场景都是比较适合的。<br>问题二：如果是应用层协议，那报文的格式化和解析、请求应答的规则是重点。通用简明的报文格式易于格式化和解析，适合粒度的应答码便于标示请求状态。","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467129,"discussion_content":"其实流媒体有使用 HTTP 也有不使用 HTTP 的，其它方面理解正确。对于协议的问题，理解挺不错的，当然，这两个都 是开放的问题，你也可以看看其他人的回答 :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568264212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132735,"user_name":"joker","can_delete":false,"product_type":"c1","uid":1501088,"ip_address":"","ucode":"4305206A1FE5EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/e7/a0/9a962a74.jpg","comment_is_top":false,"comment_ctime":1568208168,"is_pvip":true,"replies":[{"id":"50872","content":"在和网络、Web 接口、性能等问题打交道的时候，很常用。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568223315,"ip_address":"","comment_id":132735,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863175464","product_id":100035501,"comment_content":"抓包的应用场景都有哪些呀，老师","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467097,"discussion_content":"在和网络、Web 接口、性能等问题打交道的时候，很常用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568223315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132687,"user_name":"xcoder","can_delete":false,"product_type":"c1","uid":1207135,"ip_address":"","ucode":"2C70ED36B4AC8E","user_header":"https://static001.geekbang.org/account/avatar/00/12/6b/5f/cec1e980.jpg","comment_is_top":false,"comment_ctime":1568192816,"is_pvip":false,"replies":[{"id":"50870","content":"你好 xcoder，别害怕，每个人不同领域的知识储备都不同。你要是能具体谈谈那些不懂，我可以想想办法帮你","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568216501,"ip_address":"","comment_id":132687,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863160112","product_id":100035501,"comment_content":"完了，这课不好学啊，好多不懂，看着一头雾水，缺少必要的知识去联系起来，工具还得自己去查查学起来，还要阅读英文文章。。。。。","like_count":2,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467070,"discussion_content":"你好 xcoder，别害怕，每个人不同领域的知识储备都不同。你要是能具体谈谈那些不懂，我可以想想办法帮你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568216501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132685,"user_name":"Geek_63377c","can_delete":false,"product_type":"c1","uid":1622220,"ip_address":"","ucode":"9C3745537EFF48","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7xB3OdNLiaPgZQibVAD52Jx7fmKYFXibDBHLrPMnAHVknAzNRO2AskCqc80pwNFbicPJrUQExNgLQrN9iaVy8G5KTSQ/132","comment_is_top":false,"comment_ctime":1568191879,"is_pvip":false,"replies":[{"id":"50869","content":"你可以安装 Homebrew https:&#47;&#47;brew.sh&#47; 这个包管理工具，这样以后这些工具大多可以用它来安装，包括 netcat：<br>brew install netcat","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568216449,"ip_address":"","comment_id":132685,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863159175","product_id":100035501,"comment_content":"老师，请问netcat在mac电脑上怎么安装呢？","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467069,"discussion_content":"你可以安装 Homebrew https://brew.sh/ 这个包管理工具，这样以后这些工具大多可以用它来安装，包括 netcat：\nbrew install netcat","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568216449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132606,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1568172217,"is_pvip":false,"replies":[{"id":"50868","content":"既然你特别说到第二个问题，你的回答中“内外网的隔离”其实是它下层的协议，例如第三层的网络层中的 IP 协议关心的，而不是第七层应用层的 HTTP 所关心的。建议你阅读以下扩展阅读 OSI 相关的内容。<br>设计方面，本专栏中不会详细解读协议设计，但会有很多应用层协议的使用，以及特别强化 Web 接口的设计的介绍。:)","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568216279,"ip_address":"","comment_id":132606,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863139513","product_id":100035501,"comment_content":"      可能因为职业的特性吧：网络协议的设计基本都是由专业的网络工程师去做的；老师今天的第二个问题其实同样希望老师能够再后续课程做个思路的讲解吧。<br>       今天课程中的tcpdump和wireshark之前都有使用过和强化过：课程中就略过了。<br>       课后习题做个简单解答吧：第二个问题还是希望老师后面用个篇幅或者在某节课中讲解一下核心思路吧，麻烦老师了，给老师添加工作量了。<br>        1.Http特性的使用场景：简单的说其实主要是解决了人与机器通过使用万维网的通信，实现人机交互吧，解决 WWW 信息交互必须面对的需求。<br>        （1）http1.1<br>        1）可扩展性：巨大的用户群体，超长的寿命<br>        2）分布式系统下的 Hypermedia：大粒度数据的网络传输<br>        3）Internet 规模<br>        （2）http 2.0在此基础上解决了：多路复用和服务器消息推送.<br>      2.设计过程中的遵循原则：这块算是通过工作中的交互简述吧；<br>         1）内外网的隔离：根据功能划分网段<br>         2）根据需求选择合适的网络设计模型吧：星形或者、、、<br>        网络的工具可能工作中使用偏多点：设计实在是偏弱，希望后面课程能够得到老师的提点和教导；谢谢老师今天的分享。     <br>","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467034,"discussion_content":"既然你特别说到第二个问题，你的回答中“内外网的隔离”其实是它下层的协议，例如第三层的网络层中的 IP 协议关心的，而不是第七层应用层的 HTTP 所关心的。建议你阅读以下扩展阅读 OSI 相关的内容。\n设计方面，本专栏中不会详细解读协议设计，但会有很多应用层协议的使用，以及特别强化 Web 接口的设计的介绍。:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568216279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132586,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1568169248,"is_pvip":false,"replies":[{"id":"50723","content":"感谢。后面的文章也会尽量保持层次，每篇都有扩展阅读，争取让不同的人都有收获。当然，这篇是第一篇相对来说比较简单。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568179645,"ip_address":"","comment_id":132586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863136544","product_id":100035501,"comment_content":"赞，这是我订阅的课程里最“网络协议”式的课程了。<br><br>为什么呢？<br>定义网络协议就要像老师今天的课一样：<br>1、层次分明。适应于不同水平的人阅读，就像网络协议一样适应多种应用场景。<br><br>2、扩展性强。文后给出扩展阅读，可以根据自己的需要进行不同程度的延展。","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467023,"discussion_content":"感谢。后面的文章也会尽量保持层次，每篇都有扩展阅读，争取让不同的人都有收获。当然，这篇是第一篇相对来说比较简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568179645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277742,"user_name":"jkdong","can_delete":false,"product_type":"c1","uid":1438699,"ip_address":"","ucode":"4323FB6F80F2A2","user_header":"https://static001.geekbang.org/account/avatar/00/15/f3/eb/4bff2158.jpg","comment_is_top":false,"comment_ctime":1612535888,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1612535888","product_id":100035501,"comment_content":"python3 httpserver已经改为<br>python -m http.server 8082","like_count":0},{"had_liked":false,"id":142035,"user_name":"零维","can_delete":false,"product_type":"c1","uid":1235055,"ip_address":"","ucode":"D783CB1D59D1BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/6f/22e5ec55.jpg","comment_is_top":false,"comment_ctime":1571281399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571281399","product_id":100035501,"comment_content":"老师您好，我在使用 netcat 的过程中遇到了一个问题：<br>我可以通过 proxychain curl www.google.com 的方式来访问，但是下面这条命令就不行了：<br>proxychain nc -x 31211  www.google.com 80 &lt; request.txt （31211 是我 socks5 的端口号）<br>报错是：nc: read failed (0&#47;3): Broken pipe<br>网上没有查到这个怎么解决的方法，最后还是来请教一下老师。。","like_count":0},{"had_liked":false,"id":132485,"user_name":"TossKing","can_delete":false,"product_type":"c1","uid":1659743,"ip_address":"","ucode":"24CE772F4002E4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBrgkl6YD1R2YR3UF7biahp4nnXK8xPHBnxZniazytApWUia2YTEKPf2iceGYq0F31Eicx4D7yKIxHXIA/132","comment_is_top":false,"comment_ctime":1568133339,"is_pvip":false,"replies":[{"id":"50719","content":"加油。特别是抓包这项技能，还是很实用的。当然，我只是给了个最简单例子。专栏后面我们还会使用抓包来分析问题。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568174458,"ip_address":"","comment_id":132485,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568133339","product_id":100035501,"comment_content":"最近正好要做一个简单的私有协议实现从server下载包列表和具体的包文件，打算用http get，对http协议知之甚少，也没抓过包，这课来的太及时了。","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466965,"discussion_content":"加油。特别是抓包这项技能，还是很实用的。当然，我只是给了个最简单例子。专栏后面我们还会使用抓包来分析问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568174458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}