{"id":301716,"title":"10 | Pool：性能提升大杀器","content":"<p>你好，我是鸟窝。</p><p>Go是一个自动垃圾回收的编程语言，采用<a href=\"https://go.dev/blog/ismmkeynote\">三色并发标记算法</a>标记对象并回收。和其它没有自动垃圾回收的编程语言不同，使用Go语言创建对象的时候，我们没有回收/释放的心理负担，想用就用，想创建就创建。</p><p>但是，<strong>如果你想使用Go开发一个高性能的应用程序的话，就必须考虑垃圾回收给性能带来的影响</strong>，毕竟，Go的自动垃圾回收机制还是有一个STW（stop-the-world，程序暂停）的时间，而且，大量地创建在堆上的对象，也会影响垃圾回收标记的时间。</p><p>所以，一般我们做性能优化的时候，会采用对象池的方式，把不用的对象回收起来，避免被垃圾回收掉，这样使用的时候就不必在堆上重新创建了。</p><p>不止如此，像数据库连接、TCP的长连接，这些连接在创建的时候是一个非常耗时的操作。如果每次都创建一个新的连接对象，耗时较长，很可能整个业务的大部分耗时都花在了创建连接上。</p><p>所以，如果我们能把这些连接保存下来，避免每次使用的时候都重新创建，不仅可以大大减少业务的耗时，还能提高应用程序的整体性能。</p><p>Go标准库中提供了一个通用的Pool数据结构，也就是sync.Pool，我们使用它可以创建池化的对象。这节课我会详细给你介绍一下sync.Pool的使用方法、实现原理以及常见的坑，帮助你全方位地掌握标准库的Pool。</p><!-- [[[read_end]]] --><p>不过，这个类型也有一些使用起来不太方便的地方，就是<strong>它池化的对象可能会被垃圾回收掉</strong>，这对于数据库长连接等场景是不合适的。所以在这一讲中，我会专门介绍其它的一些Pool，包括TCP连接池、数据库连接池等等。</p><p>除此之外，我还会专门介绍一个池的应用场景： Worker Pool，或者叫做goroutine pool，这也是常用的一种并发模式，可以使用有限的goroutine资源去处理大量的业务数据。</p><h1>sync.Pool</h1><p>首先，我们来学习下标准库提供的sync.Pool数据类型。</p><p>sync.Pool数据类型用来保存一组可独立访问的<strong>临时</strong>对象。请注意这里加粗的“临时”这两个字，它说明了sync.Pool这个数据类型的特点，也就是说，它池化的对象会在未来的某个时候被毫无预兆地移除掉。而且，如果没有别的对象引用这个被移除的对象的话，这个被移除的对象就会被垃圾回收掉。</p><p>因为Pool可以有效地减少新对象的申请，从而提高程序性能，所以Go内部库也用到了sync.Pool，比如fmt包，它会使用一个动态大小的buffer池做输出缓存，当大量的goroutine并发输出的时候，就会创建比较多的buffer，并且在不需要的时候回收掉。</p><p>有两个知识点你需要记住：</p><ol>\n<li>sync.Pool本身就是线程安全的，多个goroutine可以并发地调用它的方法存取对象；</li>\n<li>sync.Pool不可在使用之后再复制使用。</li>\n</ol><h2>sync.Pool的使用方法</h2><p>知道了sync.Pool这个数据类型的特点，接下来，我们来学习下它的使用方法。其实，这个数据类型不难，它只提供了三个对外的方法：New、Get和Put。</p><p><strong>1.New</strong></p><p>Pool struct包含一个New字段，这个字段的类型是函数 func() interface{}。当调用Pool的Get方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个New方法来创建新的元素。如果你没有设置New字段，没有更多的空闲元素可返回时，Get方法将返回nil，表明当前没有可用的元素。</p><p>有趣的是，New是可变的字段。这就意味着，你可以在程序运行的时候改变创建元素的方法。当然，很少有人会这么做，因为一般我们创建元素的逻辑都是一致的，要创建的也是同一类的元素，所以你在使用Pool的时候也没必要玩一些“花活”，在程序运行时更改New的值。</p><p><strong>2.Get</strong></p><p>如果调用这个方法，就会从Pool<strong>取走</strong>一个元素，这也就意味着，这个元素会从Pool中移除，返回给调用者。不过，除了返回值是正常实例化的元素，Get方法的返回值还可能会是一个nil（Pool.New字段没有设置，又没有空闲元素可以返回），所以你在使用的时候，可能需要判断。</p><p><strong>3.Put</strong></p><p>这个方法用于将一个元素返还给Pool，Pool会把这个元素保存到池中，并且可以复用。但如果Put一个nil值，Pool就会忽略这个值。</p><p>好了，了解了这几个方法，下面我们看看sync.Pool最常用的一个场景：buffer池（缓冲池）。</p><p>因为byte slice是经常被创建销毁的一类对象，使用buffer池可以缓存已经创建的byte slice，比如，著名的静态网站生成工具Hugo中，就包含这样的实现<a href=\"https://github.com/gohugoio/hugo/blob/master/bufferpool/bufpool.go\">bufpool</a>，你可以看一下下面这段代码：</p><pre><code>var buffers = sync.Pool{\n\tNew: func() interface{} { \n\t\treturn new(bytes.Buffer)\n\t},\n}\n\nfunc GetBuffer() *bytes.Buffer {\n\treturn buffers.Get().(*bytes.Buffer)\n}\n\nfunc PutBuffer(buf *bytes.Buffer) {\n\tbuf.Reset()\n\tbuffers.Put(buf)\n}\n</code></pre><p>除了Hugo，这段buffer池的代码非常常用。很可能你在阅读其它项目的代码的时候就碰到过，或者是你自己实现buffer池的时候也会这么去实现，但是请你注意了，这段代码是有问题的，你一定不要将上面的代码应用到实际的产品中。它可能会有内存泄漏的问题，下面我会重点讲这个问题。</p><h2>实现原理</h2><p>了解了sync.Pool的基本使用方法，下面我们就来重点学习下它的实现。</p><p>Go 1.13之前的sync.Pool的实现有2大问题：</p><p><strong>1.每次GC都会回收创建的对象。</strong></p><p>如果缓存元素数量太多，就会导致STW耗时变长；缓存元素都被回收后，会导致Get命中率下降，Get方法不得不新创建很多对象。</p><p><strong>2.底层实现使用了Mutex，对这个锁并发请求竞争激烈的时候，会导致性能的下降。</strong></p><p>在Go 1.13中，sync.Pool做了大量的优化。前几讲中我提到过，提高并发程序性能的优化点是尽量不要使用锁，如果不得已使用了锁，就把锁Go的粒度降到最低。<strong>Go对Pool的优化就是避免使用锁，同时将加锁的queue改成lock-free的queue的实现，给即将移除的元素再多一次“复活”的机会。</strong></p><p>当前，sync.Pool的数据结构如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/96/f4003704663ea081230760098f8af696.jpg?wh=3659*2186\" alt=\"\"></p><p>Pool最重要的两个字段是 local和victim，因为它们两个主要用来存储空闲的元素。弄清楚这两个字段的处理逻辑，你就能完全掌握sync.Pool的实现了。下面我们来看看这两个字段的关系。</p><p>每次垃圾回收的时候，Pool会把victim中的对象移除，然后把local的数据给victim，这样的话，local就会被清空，而victim就像一个垃圾分拣站，里面的东西可能会被当做垃圾丢弃了，但是里面有用的东西也可能被捡回来重新使用。</p><p>victim中的元素如果被Get取走，那么这个元素就很幸运，因为它又“活”过来了。但是，如果这个时候Get的并发不是很大，元素没有被Get取走，那么就会被移除掉，因为没有别人引用它的话，就会被垃圾回收掉。</p><p>下面的代码是垃圾回收时sync.Pool的处理逻辑：</p><pre><code>func poolCleanup() {\n    // 丢弃当前victim, STW所以不用加锁\n    for _, p := range oldPools {\n        p.victim = nil\n        p.victimSize = 0\n    }\n\n    // 将local复制给victim, 并将原local置为nil\n    for _, p := range allPools {\n        p.victim = p.local\n        p.victimSize = p.localSize\n        p.local = nil\n        p.localSize = 0\n    }\n\n    oldPools, allPools = allPools, nil\n}\n</code></pre><p>在这段代码中，你需要关注一下local字段，因为所有当前主要的空闲可用的元素都存放在local字段中，请求元素时也是优先从local字段中查找可用的元素。local字段包含一个poolLocalInternal字段，并提供CPU缓存对齐，从而避免false sharing。</p><p>而poolLocalInternal也包含两个字段：private和shared。</p><ul>\n<li>private，代表一个缓存的元素，而且只能由相应的一个P存取。因为一个P同时只能执行一个goroutine，所以不会有并发的问题。</li>\n<li>shared，可以由任意的P访问，但是只有本地的P才能pushHead/popHead，其它P可以popTail，相当于只有一个本地的P作为生产者（Producer），多个P作为消费者（Consumer），它是使用一个local-free的queue列表实现的。</li>\n</ul><h3>Get方法</h3><p>我们来看看Get方法的具体实现原理。</p><pre><code>func (p *Pool) Get() interface{} {\n    // 把当前goroutine固定在当前的P上\n    l, pid := p.pin()\n    x := l.private // 优先从local的private字段取，快速\n    l.private = nil\n    if x == nil {\n        // 从当前的local.shared弹出一个，注意是从head读取并移除\n        x, _ = l.shared.popHead()\n        if x == nil { // 如果没有，则去偷一个\n            x = p.getSlow(pid) \n        }\n    }\n    runtime_procUnpin()\n    // 如果没有获取到，尝试使用New函数生成一个新的\n    if x == nil &amp;&amp; p.New != nil {\n        x = p.New()\n    }\n    return x\n}\n</code></pre><p>我来给你解释下这段代码。首先，从本地的private字段中获取可用元素，因为没有锁，获取元素的过程会非常快，如果没有获取到，就尝试从本地的shared获取一个，如果还没有，会使用getSlow方法去其它的shared中“偷”一个。最后，如果没有获取到，就尝试使用New函数创建一个新的。</p><p>这里的重点是getSlow方法，我们来分析下。看名字也就知道了，它的耗时可能比较长。它首先要遍历所有的local，尝试从它们的shared弹出一个元素。如果还没找到一个，那么，就开始对victim下手了。</p><p>在vintim中查询可用元素的逻辑还是一样的，先从对应的victim的private查找，如果查不到，就再从其它victim的shared中查找。</p><p>下面的代码是getSlow方法的主要逻辑：</p><pre><code>func (p *Pool) getSlow(pid int) interface{} {\n\n    size := atomic.LoadUintptr(&amp;p.localSize)\n    locals := p.local                       \n    // 从其它proc中尝试偷取一个元素\n    for i := 0; i &lt; int(size); i++ {\n        l := indexLocal(locals, (pid+i+1)%int(size))\n        if x, _ := l.shared.popTail(); x != nil {\n            return x\n        }\n    }\n\n    // 如果其它proc也没有可用元素，那么尝试从vintim中获取\n    size = atomic.LoadUintptr(&amp;p.victimSize)\n    if uintptr(pid) &gt;= size {\n        return nil\n    }\n    locals = p.victim\n    l := indexLocal(locals, pid)\n    if x := l.private; x != nil { // 同样的逻辑，先从vintim中的local private获取\n        l.private = nil\n        return x\n    }\n    for i := 0; i &lt; int(size); i++ { // 从vintim其它proc尝试偷取\n        l := indexLocal(locals, (pid+i)%int(size))\n        if x, _ := l.shared.popTail(); x != nil {\n            return x\n        }\n    }\n\n    // 如果victim中都没有，则把这个victim标记为空，以后的查找可以快速跳过了\n    atomic.StoreUintptr(&amp;p.victimSize, 0)\n\n    return nil\n}\n</code></pre><p>这里我没列出pin代码的实现，你只需要知道，pin方法会将此goroutine固定在当前的P上，避免查找元素期间被其它的P执行。固定的好处就是查找元素期间直接得到跟这个P相关的local。有一点需要注意的是，pin方法在执行的时候，如果跟这个P相关的local还没有创建，或者运行时P的数量被修改了的话，就会新创建local。</p><h3>Put方法</h3><p>我们来看看Put方法的具体实现原理。</p><pre><code>func (p *Pool) Put(x interface{}) {\n    if x == nil { // nil值直接丢弃\n        return\n    }\n    l, _ := p.pin()\n    if l.private == nil { // 如果本地private没有值，直接设置这个值即可\n        l.private = x\n        x = nil\n    }\n    if x != nil { // 否则加入到本地队列中\n        l.shared.pushHead(x)\n    }\n    runtime_procUnpin()\n}\n</code></pre><p>Put的逻辑相对简单，优先设置本地private，如果private字段已经有值了，那么就把此元素push到本地队列中。</p><h2>sync.Pool的坑</h2><p>到这里，我们就掌握了sync.Pool的使用方法和实现原理，接下来，我要再和你聊聊容易踩的两个坑，分别是内存泄漏和内存浪费。</p><h3>内存泄漏</h3><p>这节课刚开始的时候，我讲到，可以使用sync.Pool做buffer池，但是，如果用刚刚的那种方式做buffer池的话，可能会有内存泄漏的风险。为啥这么说呢？我们来分析一下。</p><p>取出来的bytes.Buffer在使用的时候，我们可以往这个元素中增加大量的byte数据，这会导致底层的byte slice的容量可能会变得很大。这个时候，即使Reset再放回到池子中，这些byte slice的容量不会改变，所占的空间依然很大。而且，因为Pool回收的机制，这些大的Buffer可能不被回收，而是会一直占用很大的空间，这属于内存泄漏的问题。</p><p>即使是Go的标准库，在内存泄漏这个问题上也栽了几次坑，比如 <a href=\"https://github.com/golang/go/issues/23199\">issue 23199</a>、<a href=\"https://github.com/dsnet\">@dsnet</a>提供了一个简单的可重现的例子，演示了内存泄漏的问题。再比如encoding、json中类似的问题：将容量已经变得很大的Buffer再放回Pool中，导致内存泄漏。后来在元素放回时，增加了检查逻辑，改成放回的超过一定大小的buffer，就直接丢弃掉，不再放到池子中，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/9f/e3e23d2f2ab55b64741e14856a58389f.png?wh=1098*319\" alt=\"\"></p><p>package fmt中也有这个问题，修改方法是一样的，超过一定大小的buffer，就直接丢弃了：</p><p><img src=\"https://static001.geekbang.org/resource/image/06/62/06c68476cac13a860c470b006718c462.png?wh=1012*392\" alt=\"\"></p><p>在使用sync.Pool回收buffer的时候，<strong>一定要检查回收的对象的大小。</strong>如果buffer太大，就不要回收了，否则就太浪费了。</p><h3>内存浪费</h3><p>除了内存泄漏以外，还有一种浪费的情况，就是池子中的buffer都比较大，但在实际使用的时候，很多时候只需要一个小的buffer，这也是一种浪费现象。接下来，我就讲解一下这种情况的处理方法。</p><p>要做到物尽其用，尽可能不浪费的话，我们可以将buffer池分成几层。首先，小于512 byte的元素的buffer占一个池子；其次，小于1K byte大小的元素占一个池子；再次，小于4K byte大小的元素占一个池子。这样分成几个池子以后，就可以根据需要，到所需大小的池子中获取buffer了。</p><p>在标准库 <a href=\"https://github.com/golang/go/blob/617f2c3e35cdc8483b950aa3ef18d92965d63197/src/net/http/server.go\">net/http/server.go</a>中的代码中，就提供了2K和4K两个writer的池子。你可以看看下面这段代码：</p><p><img src=\"https://static001.geekbang.org/resource/image/55/35/55086ccba91975a0f65bd35d1192e335.png?wh=628*611\" alt=\"\"></p><p>YouTube开源的知名项目vitess中提供了<a href=\"https://github.com/vitessio/vitess/blob/master/go/bucketpool/bucketpool.go\">bucketpool</a>的实现，它提供了更加通用的多层buffer池。你在使用的时候，只需要指定池子的最大和最小尺寸，vitess就会自动计算出合适的池子数。而且，当你调用Get方法的时候，只需要传入你要获取的buffer的大小，就可以了。下面这段代码就描述了这个过程，你可以看看：</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/08/c5cd474aa53fe57e0722d840a6c7f308.png?wh=591*146\" alt=\"\"></p><h1>第三方库</h1><p>除了这种分层的为了节省空间的buffer设计外，还有其它的一些第三方的库也会提供buffer池的功能。接下来我带你熟悉几个常用的第三方的库。</p><p>1.<a href=\"https://github.com/valyala/bytebufferpool\">bytebufferpool</a></p><p>这是fasthttp作者valyala提供的一个buffer池，基本功能和sync.Pool相同。它的底层也是使用sync.Pool实现的，包括会检测最大的buffer，超过最大尺寸的buffer，就会被丢弃。</p><p>valyala一向很擅长挖掘系统的性能，这个库也不例外。它提供了校准（calibrate，用来动态调整创建元素的权重）的机制，可以“智能”地调整Pool的defaultSize和maxSize。一般来说，我们使用buffer size的场景比较固定，所用buffer的大小会集中在某个范围里。有了校准的特性，bytebufferpool就能够偏重于创建这个范围大小的buffer，从而节省空间。</p><p>2.<a href=\"https://github.com/oxtoacart/bpool\">oxtoacart/bpool</a></p><p>这也是比较常用的buffer池，它提供了以下几种类型的buffer。</p><ul>\n<li>bpool.BufferPool： 提供一个固定元素数量的buffer 池，元素类型是bytes.Buffer，如果超过这个数量，Put的时候就丢弃，如果池中的元素都被取光了，会新建一个返回。Put回去的时候，不会检测buffer的大小。</li>\n<li>bpool.BytesPool：提供一个固定元素数量的byte slice池，元素类型是byte slice。Put回去的时候不检测slice的大小。</li>\n<li>bpool.SizedBufferPool： 提供一个固定元素数量的buffer池，如果超过这个数量，Put的时候就丢弃，如果池中的元素都被取光了，会新建一个返回。Put回去的时候，会检测buffer的大小，超过指定的大小的话，就会创建一个新的满足条件的buffer放回去。</li>\n</ul><p>bpool最大的特色就是能够保持池子中元素的数量，一旦Put的数量多于它的阈值，就会自动丢弃，而sync.Pool是一个没有限制的池子，只要Put就会收进去。</p><p>bpool是基于Channel实现的，不像sync.Pool为了提高性能而做了很多优化，所以，在性能上比不过sync.Pool。不过，它提供了限制Pool容量的功能，所以，如果你想控制Pool的容量的话，可以考虑这个库。</p><h1>连接池</h1><p>Pool的另一个很常用的一个场景就是保持TCP的连接。一个TCP的连接创建，需要三次握手等过程，如果是TLS的，还会需要更多的步骤，如果加上身份认证等逻辑的话，耗时会更长。所以，为了避免每次通讯的时候都新创建连接，我们一般会建立一个连接的池子，预先把连接创建好，或者是逐步把连接放在池子中，减少连接创建的耗时，从而提高系统的性能。</p><p>事实上，我们很少会使用sync.Pool去池化连接对象，原因就在于，sync.Pool会无通知地在某个时候就把连接移除垃圾回收掉了，而我们的场景是需要长久保持这个连接，所以，我们一般会使用其它方法来池化连接，比如接下来我要讲到的几种需要保持长连接的Pool。</p><h2>标准库中的http client池</h2><p>标准库的http.Client是一个http client的库，可以用它来访问web服务器。为了提高性能，这个Client的实现也是通过池的方法来缓存一定数量的连接，以便后续重用这些连接。</p><p>http.Client实现连接池的代码是在Transport类型中，它使用idleConn保存持久化的可重用的长连接：</p><p><img src=\"https://static001.geekbang.org/resource/image/14/ec/141ced98a81466b793b0f90b9652afec.png?wh=1192*430\" alt=\"\"></p><h2>TCP连接池</h2><p>最常用的一个TCP连接池是fatih开发的<a href=\"https://github.com/fatih/pool\">fatih/pool</a>，虽然这个项目已经被fatih归档（Archived），不再维护了，但是因为它相当稳定了，我们可以开箱即用。即使你有一些特殊的需求，也可以fork它，然后自己再做修改。</p><p>它的使用套路如下：</p><pre><code>// 工厂模式，提供创建连接的工厂方法\nfactory    := func() (net.Conn, error) { return net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:4000&quot;) }\n\n// 创建一个tcp池，提供初始容量和最大容量以及工厂方法\np, err := pool.NewChannelPool(5, 30, factory)\n\n// 获取一个连接\nconn, err := p.Get()\n\n// Close并不会真正关闭这个连接，而是把它放回池子，所以你不必显式地Put这个对象到池子中\nconn.Close()\n\n// 通过调用MarkUnusable, Close的时候就会真正关闭底层的tcp的连接了\nif pc, ok := conn.(*pool.PoolConn); ok {\n  pc.MarkUnusable()\n  pc.Close()\n}\n\n// 关闭池子就会关闭=池子中的所有的tcp连接\np.Close()\n\n// 当前池子中的连接的数量\ncurrent := p.Len()\n</code></pre><p>虽然我一直在说TCP，但是它管理的是更通用的net.Conn，不局限于TCP连接。</p><p>它通过把net.Conn包装成PoolConn，实现了拦截net.Conn的Close方法，避免了真正地关闭底层连接，而是把这个连接放回到池中：</p><pre><code>    type PoolConn struct {\n\t\tnet.Conn\n\t\tmu       sync.RWMutex\n\t\tc        *channelPool\n\t\tunusable bool\n\t}\n\t\n    //拦截Close\n\tfunc (p *PoolConn) Close() error {\n\t\tp.mu.RLock()\n\t\tdefer p.mu.RUnlock()\n\t\n\t\tif p.unusable {\n\t\t\tif p.Conn != nil {\n\t\t\t\treturn p.Conn.Close()\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treturn p.c.put(p.Conn)\n\t}\n</code></pre><p>它的Pool是通过Channel实现的，空闲的连接放入到Channel中，这也是Channel的一个应用场景：</p><pre><code>    type channelPool struct {\n\t\t// 存储连接池的channel\n\t\tmu    sync.RWMutex\n\t\tconns chan net.Conn\n\t\n\n\t\t// net.Conn 的产生器\n\t\tfactory Factory\n\t}\n</code></pre><h2>数据库连接池</h2><p>标准库sql.DB还提供了一个通用的数据库的连接池，通过MaxOpenConns和MaxIdleConns控制最大的连接数和最大的idle的连接数。默认的MaxIdleConns是2，这个数对于数据库相关的应用来说太小了，我们一般都会调整它。</p><p><img src=\"https://static001.geekbang.org/resource/image/49/15/49c14b5bccb6d6ac7a159eece17a2215.png?wh=552*106\" alt=\"\"></p><p>DB的freeConn保存了idle的连接，这样，当我们获取数据库连接的时候，它就会优先尝试从freeConn获取已有的连接（<a href=\"https://github.com/golang/go/blob/4fc3896e7933e31822caa50e024d4e139befc75f/src/database/sql/sql.go#L1196\">conn</a>）。</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/b5/d043yyd649a216fe37885yy4e03af3b5.png?wh=789*345\" alt=\"\"></p><h2>Memcached Client连接池</h2><p>Brad Fitzpatrick是知名缓存库Memcached的原作者，前Go团队成员。<a href=\"https://github.com/bradfitz/gomemcache\">gomemcache</a>是他使用Go开发的Memchaced的客户端，其中也用了连接池的方式池化Memcached的连接。接下来让我们看看它的连接池的实现。</p><p>gomemcache Client有一个freeconn的字段，用来保存空闲的连接。当一个请求使用完之后，它会调用putFreeConn放回到池子中，请求的时候，调用getFreeConn优先查询freeConn中是否有可用的连接。它采用Mutex+Slice实现Pool：</p><pre><code>   // 放回一个待重用的连接\n   func (c *Client) putFreeConn(addr net.Addr, cn *conn) {\n\t\tc.lk.Lock()\n\t\tdefer c.lk.Unlock()\n\t\tif c.freeconn == nil { // 如果对象为空，创建一个map对象\n\t\t\tc.freeconn = make(map[string][]*conn)\n\t\t}\n\t\tfreelist := c.freeconn[addr.String()] //得到此地址的连接列表\n\t\tif len(freelist) &gt;= c.maxIdleConns() {//如果连接已满,关闭，不再放入\n\t\t\tcn.nc.Close()\n\t\t\treturn\n\t\t}\n\t\tc.freeconn[addr.String()] = append(freelist, cn) // 加入到空闲列表中\n\t}\n\t\n    // 得到一个空闲连接\n\tfunc (c *Client) getFreeConn(addr net.Addr) (cn *conn, ok bool) {\n\t\tc.lk.Lock()\n\t\tdefer c.lk.Unlock()\n\t\tif c.freeconn == nil { \n\t\t\treturn nil, false\n\t\t}\n\t\tfreelist, ok := c.freeconn[addr.String()]\n\t\tif !ok || len(freelist) == 0 { // 没有此地址的空闲列表，或者列表为空\n\t\t\treturn nil, false\n\t\t}\n\t\tcn = freelist[len(freelist)-1] // 取出尾部的空闲连接\n\t\tc.freeconn[addr.String()] = freelist[:len(freelist)-1]\n\t\treturn cn, true\n\t}\n\n</code></pre><h1>Worker Pool</h1><p>最后，我再讲一个Pool应用得非常广泛的场景。</p><p>你已经知道，goroutine是一个很轻量级的“纤程”，在一个服务器上可以创建十几万甚至几十万的goroutine。但是“可以”和“合适”之间还是有区别的，你会在应用中让几十万的goroutine一直跑吗？基本上是不会的。</p><p>一个goroutine初始的栈大小是2048个字节，并且在需要的时候可以扩展到1GB（具体的内容你可以课下看看代码中的配置：<a href=\"https://github.com/golang/go/blob/f296b7a6f045325a230f77e9bda1470b1270f817/src/runtime/proc.go#L120\">不同的架构最大数会不同</a>），所以，大量的goroutine还是很耗资源的。同时，大量的goroutine对于调度和垃圾回收的耗时还是会有影响的，因此，goroutine并不是越多越好。</p><p>有的时候，我们就会创建一个Worker Pool来减少goroutine的使用。比如，我们实现一个TCP服务器，如果每一个连接都要由一个独立的goroutine去处理的话，在大量连接的情况下，就会创建大量的goroutine，这个时候，我们就可以创建一个固定数量的goroutine（Worker），由这一组Worker去处理连接，比如fasthttp中的<a href=\"https://github.com/valyala/fasthttp/blob/9f11af296864153ee45341d3f2fe0f5178fd6210/workerpool.go#L16\">Worker Pool</a>。</p><p>Worker的实现也是五花八门的：</p><ul>\n<li>有些是在后台默默执行的，不需要等待返回结果；</li>\n<li>有些需要等待一批任务执行完；</li>\n<li>有些Worker Pool的生命周期和程序一样长；</li>\n<li>有些只是临时使用，执行完毕后，Pool就销毁了。</li>\n</ul><p>大部分的Worker Pool都是通过Channel来缓存任务的，因为Channel能够比较方便地实现并发的保护，有的是多个Worker共享同一个任务Channel，有些是每个Worker都有一个独立的Channel。</p><p>综合下来，精挑细选，我给你推荐三款易用的Worker Pool，这三个Worker Pool 的API设计简单，也比较相似，易于和项目集成，而且提供的功能也是我们常用的功能。</p><ul>\n<li><a href=\"https://godoc.org/github.com/gammazero/workerpool\">gammazero/workerpool</a>：gammazero/workerpool可以无限制地提交任务，提供了更便利的Submit和SubmitWait方法提交任务，还可以提供当前的worker数和任务数以及关闭Pool的功能。</li>\n<li><a href=\"https://godoc.org/github.com/ivpusic/grpool\">ivpusic/grpool</a>：grpool创建Pool的时候需要提供Worker的数量和等待执行的任务的最大数量，任务的提交是直接往Channel放入任务。</li>\n<li><a href=\"https://godoc.org/github.com/dpaks/goworkers\">dpaks/goworkers</a>：dpaks/goworkers提供了更便利的Submit方法提交任务以及Worker数、任务数等查询方法、关闭Pool的方法。它的任务的执行结果需要在ResultChan和ErrChan中去获取，没有提供阻塞的方法，但是它可以在初始化的时候设置Worker的数量和任务数。</li>\n</ul><p>类似的Worker Pool的实现非常多，比如还有<a href=\"https://github.com/panjf2000/ants\">panjf2000/ants</a>、<a href=\"https://github.com/Jeffail/tunny\">Jeffail/tunny</a> 、<a href=\"https://github.com/benmanns/goworker\">benmanns/goworker</a>、<a href=\"https://github.com/go-playground/pool\">go-playground/pool</a>、<a href=\"https://github.com/Sherifabdlnaby/gpool\">Sherifabdlnaby/gpool</a>等第三方库。<a href=\"https://github.com/alitto/pond\">pond</a>也是一个非常不错的Worker Pool，关注度目前不是很高，但是功能非常齐全。</p><p>其实，你也可以自己去开发自己的Worker Pool，但是，对于我这种“懒惰”的人来说，只要满足我的实际需求，我还是倾向于从这个几个常用的库中选择一个来使用。所以，我建议你也从常用的库中进行选择。</p><h1>总结</h1><p>Pool是一个通用的概念，也是解决对象重用和预先分配的一个常用的优化手段。即使你自己没在项目中直接使用过，但肯定在使用其它库的时候，就享受到应用Pool的好处了，比如数据库的访问、http API的请求等等。</p><p>我们一般不会在程序一开始的时候就开始考虑优化，而是等项目开发到一个阶段，或者快结束的时候，才全面地考虑程序中的优化点，而Pool就是常用的一个优化手段。如果你发现程序中有一种GC耗时特别高，有大量的相同类型的临时对象，不断地被创建销毁，这时，你就可以考虑看看，是不是可以通过池化的手段重用这些对象。</p><p>另外，在分布式系统或者微服务框架中，可能会有大量的并发Client请求，如果Client的耗时占比很大，你也可以考虑池化Client，以便重用。</p><p>如果你发现系统中的goroutine数量非常多，程序的内存资源占用比较大，而且整体系统的耗时和GC也比较高，我建议你看看，是否能够通过Worker Pool解决大量goroutine的问题，从而降低这些指标。</p><p><img src=\"https://static001.geekbang.org/resource/image/58/aa/58358f16bcee0281b55299f0386e17aa.jpg?wh=2250*2404\" alt=\"\"></p><h1>思考题</h1><p>在标准库net/rpc包中，Server端需要解析大量客户端的请求（<a href=\"https://github.com/golang/go/blob/master/src/net/rpc/server.go#L171\">Request</a>），这些短暂使用的Request是可以重用的。请你检查相关的代码，看看Go开发者都使用了什么样的方式来重用这些对象。</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","neighbors":{"left":{"article_title":"09 | map：如何实现线程安全的map类型？","id":301174},"right":{"article_title":"11 | Context：信息穿透上下文","id":304086}},"comments":[{"had_liked":false,"id":258072,"user_name":"末班车","can_delete":false,"product_type":"c1","uid":2250914,"ip_address":"","ucode":"18C93971413431","user_header":"https://static001.geekbang.org/account/avatar/00/22/58/a2/24612c85.jpg","comment_is_top":false,"comment_ctime":1604286352,"is_pvip":false,"replies":[{"id":"94059","content":"好问题。<br>重新赋零值相当于reset,避免先前的垃圾数据影响这个request。<br>new会在堆上新创建一个对象。","user_name":"作者回复","comment_id":258072,"uid":"1066613","ip_address":"","utype":1,"ctime":1604370078,"user_name_real":"鸟窝"}],"discussion_count":3,"race_medal":0,"score":"108978468752","product_id":100061801,"comment_content":"之前用到去看过，好像是通过一个链表的形式，把request存起来，最新的在链表的头，最旧的在链表的尾部，可是不懂的是，为什么每次取出了req，还要重新赋零值呢，这和我每次new一个有什么区别么？求大佬指点。","like_count":26,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508548,"discussion_content":"好问题。\n重新赋零值相当于reset,避免先前的垃圾数据影响这个request。\nnew会在堆上新创建一个对象。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604370078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323116,"discussion_content":"是不是应该理解成：复用已有的对象，减少内存分配和垃圾回收的操作","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604887907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1155646,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132","nickname":"ppd0705","note":"","ucode":"EB63D4E3FD1E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365090,"discussion_content":"哇 还有这样的技巧，赋零值不会新建对象，而只是将原对象清空","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617706368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":323116,"ip_address":""},"score":365090,"extra":""}]}]},{"had_liked":false,"id":258093,"user_name":"Junes","can_delete":false,"product_type":"c1","uid":1354665,"ip_address":"","ucode":"CD2E829C868970","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/a9/590d6f02.jpg","comment_is_top":false,"comment_ctime":1604294912,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"53143902464","product_id":100061801,"comment_content":"分享一下我的理解，主要分为回收和获取两个函数：<br><br>func (server *Server) freeRequest(req *Request) {<br>\tserver.reqLock.Lock()<br>\t&#47;&#47; 将req放在freeReq的头部，指向原先的链表头<br>\t&#47;&#47; 至于为什么放在头部、而不是尾部，我觉得是放在尾部需要遍历完这个链表(增加时间复杂度)、或者要额外维护一个尾部Request的指针(增加空间复杂度)，权衡下放在头部更方便<br>\treq.next = server.freeReq<br>\tserver.freeReq = req<br>\tserver.reqLock.Unlock()<br>}<br><br>func (server *Server) getRequest() *Request {<br>\tserver.reqLock.Lock()<br>\t&#47;&#47; freeReq是一个链表，保存空闲的Request<br>\treq := server.freeReq<br>\tif req == nil {<br>\t\t&#47;&#47; 初始状态：freeReq为空时，在heap上重新分配一个对象<br>\t\treq = new(Request)<br>\t} else {<br>\t\tserver.freeReq = req.next<br>\t\t&#47;&#47; 复用的关键在这里，这里并不是新建一个对象 new(Request)<br>\t\t&#47;&#47; 这里的思想类似于Reset，将原先有数据的Request设置为空<br>\t\t*req = Request{}<br>\t}<br>\tserver.reqLock.Unlock()<br>\treturn req<br>}","like_count":13,"discussions":[{"author":{"id":1795511,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","nickname":"i_chase","note":"","ucode":"09C41C863F4EA3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581171,"discussion_content":"*req = Request{}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658568606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258382,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1604404615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31669175687","product_id":100061801,"comment_content":"谢谢老师，喜欢老师这篇文章中通过外链的方式列出一些老师常用的三方库，很有用！","like_count":8},{"had_liked":false,"id":258278,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1604367021,"is_pvip":false,"replies":[{"id":"94108","content":"对","user_name":"作者回复","comment_id":258278,"uid":"1066613","ip_address":"","utype":1,"ctime":1604445144,"user_name_real":"鸟窝"}],"discussion_count":5,"race_medal":1,"score":"10194301613","product_id":100061801,"comment_content":"请问老师, sync.Pool会有内存泄漏，怎么理解因为 Pool 回收的机制，这些大的 Buffer 可能不被回收？","like_count":3,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508603,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604445144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1513652,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erNHic2JXVlk9TOuNxcklCOwl0JMbq0ibibX1jSDxROUTv6ElZbxXotoDOvib3KI58MyMfUcLajQVMPzA/132","nickname":"耿耿","note":"","ucode":"587EABCE26E9F6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575162,"discussion_content":"这个老师的回答，简洁精辟，让我五体投地，一看就是大牛，虽然“对”这个回答我不能理解，但是一看就是大牛，只可意会不可言传！！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654628310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069510,"avatar":"https://static001.geekbang.org/account/avatar/00/10/51/c6/5929b321.jpg","nickname":"1","note":"","ucode":"47999DCE76E566","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386556,"discussion_content":"你们都知道原因啊、知道了分享下呗，我也是想不明白 “为什么大的Buffer可能会因为pool回收的机制不被回收”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627635383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354382,"discussion_content":"老师的意思应该不是不能回收，而是”可能不会回收“。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615284199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2391171,"avatar":"","nickname":"Geek_344b09","note":"","ucode":"56C5DAA39B26BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343549,"discussion_content":"请问下你现在理解了为什么大的Buffer不能回收的问题原因了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611071588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308282,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1629516622,"is_pvip":false,"replies":[{"id":"118826","content":"第一个已修正，go官方网站域名改了。<br>第二个看文章的贴图","user_name":"作者回复","comment_id":308282,"uid":"1066613","ip_address":"","utype":1,"ctime":1639807162,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5924483918","product_id":100061801,"comment_content":"老师的文章讲解的非常细致。 请问一下：<br><br>1. 三色并发标记算法 这个 链接地址 Not found 了。<br>2. 举例大的buffer 不被回收的 第一个 源码 函数：putEncodeState ，我没找到。请问一下在哪个文件里面呀。<br>","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539702,"discussion_content":"第一个已修正，go官方网站域名改了。\n第二个看文章的贴图","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639807162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258057,"user_name":"虫子樱桃","can_delete":false,"product_type":"c1","uid":1226331,"ip_address":"","ucode":"F8244A9E9BC5A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/b6/5b/4486e4f9.jpg","comment_is_top":false,"comment_ctime":1604281720,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5899249016","product_id":100061801,"comment_content":"思考题的奥秘感觉在这两个函数 <br>```<br>&#47;&#47; ServeRequest is like ServeCodec but synchronously serves a single request.<br>&#47;&#47; It does not close the codec upon completion.<br>func (server *Server) ServeRequest(codec ServerCodec) error {<br>\tsending := new(sync.Mutex)<br>\tservice, mtype, req, argv, replyv, keepReading, err := server.readRequest(codec)<br>\tif err != nil {<br>\t\tif !keepReading {<br>\t\t\treturn err<br>\t\t}<br>\t\t&#47;&#47; send a response if we actually managed to read a header.<br>\t\tif req != nil {<br>\t\t\tserver.sendResponse(sending, req, invalidRequest, codec, err.Error())<br>\t\t\tserver.freeRequest(req)<br>\t\t}<br>\t\treturn err<br>\t}<br>\tservice.call(server, sending, nil, mtype, req, argv, replyv, codec)<br>\treturn nil<br>} <br><br>func (server *Server) freeRequest(req *Request) {<br>\tserver.reqLock.Lock()<br>\treq.next = server.freeReq<br>\tserver.freeReq = req<br>\tserver.reqLock.Unlock()<br>}<br>```<br>","like_count":1,"discussions":[{"author":{"id":1102058,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/ea/8269574b.jpg","nickname":"缘","note":"","ucode":"F310AB5BE2A3BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333549,"discussion_content":"大的buffer为什么无法被回收呢？pool的回收机制是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607562380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1674466,"avatar":"https://static001.geekbang.org/account/avatar/00/19/8c/e2/48f4e4fa.jpg","nickname":"mkii","note":"","ucode":"534914EC7EA304","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1102058,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/ea/8269574b.jpg","nickname":"缘","note":"","ucode":"F310AB5BE2A3BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366854,"discussion_content":"我的理解是，并不是大的buffer不被回收。而是如果这个pool里面的这个buffer被频繁引用到，那么是有可能不被回收的。所以回收应该和大小没关系和引用有关系。只是因为这个buffer的容量只会增不会减，如果我只需要一个1K就完全够用的buffer，但是从pool中取出来的是2K的，这样利用率就很低了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618207038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":333549,"ip_address":""},"score":366854,"extra":""}]}]},{"had_liked":false,"id":339639,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1648264790,"is_pvip":false,"replies":[{"id":"124156","content":"谢谢点击[http:&#47;&#47;img01.sogoucdn.com&#47;app&#47;a&#47;200678&#47;64d6120c9ab37cb8ce7f52cea0ec9f75.gif]查看表情","user_name":"作者回复","comment_id":339639,"uid":"1066613","ip_address":"","utype":1,"ctime":1648341161,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1648264790","product_id":100061801,"comment_content":"讲的太好了！ 真的是开启了新世界的大门。 感谢大佬","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558477,"discussion_content":"谢谢点击[http://img01.sogoucdn.com/app/a/200678/64d6120c9ab37cb8ce7f52cea0ec9f75.gif]查看表情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648341161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338847,"user_name":"大布丁","can_delete":false,"product_type":"c1","uid":1389744,"ip_address":"","ucode":"3C655AA79A538C","user_header":"https://static001.geekbang.org/account/avatar/00/15/34/b0/8d14a2a1.jpg","comment_is_top":false,"comment_ctime":1647762137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647762137","product_id":100061801,"comment_content":"一文解决之前组长问我的一个问题：除了使用更多的goroutine来干更多的活之外，还有什么设计与优化的思想？当时没往线程池跟sync.Pool去思考，现在感触很深了！身为年轻人，代码功底不足的情况，我还是喜欢阅读源码后，动手实现里面的几个方法，以便于自己能够更深刻的去理解第三方库！","like_count":0},{"had_liked":false,"id":332108,"user_name":"tingting","can_delete":false,"product_type":"c1","uid":2035702,"ip_address":"","ucode":"61E6B0C4EC59C5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0f/f6/609ded9f.jpg","comment_is_top":false,"comment_ctime":1643019951,"is_pvip":false,"replies":[{"id":"121359","content":"链表更简单;map获取删除相对复杂;sync.pool会自动回收，不受控","user_name":"作者回复","comment_id":332108,"uid":"1066613","ip_address":"","utype":1,"ctime":1643072126,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1643019951","product_id":100061801,"comment_content":"请问老师，RPC request 池化的实现为什么不用sync.Map，而是选择使用链表实现呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548172,"discussion_content":"链表更简单;map获取删除相对复杂;sync.pool会自动回收，不受控","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643072126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319888,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1635999348,"is_pvip":true,"replies":[{"id":"116824","content":"因为每次是部分回收","user_name":"作者回复","comment_id":319888,"uid":"1066613","ip_address":"","utype":1,"ctime":1637034339,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"1635999348","product_id":100061801,"comment_content":"「因为 Pool 回收的机制，这些大的 Buffer 可能不被回收」是什么原因？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529802,"discussion_content":"因为每次是部分回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637034339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297000,"user_name":"Geek_b8670e","can_delete":false,"product_type":"c1","uid":1294216,"ip_address":"","ucode":"00DAA6C36150A0","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaIJ0sYgK8E7nICWsUNFwRurMEZZEzNV7FRzgTja8icH3WBMibgu73SQClLiaxeHias8B2xK6mianbibnA/132","comment_is_top":false,"comment_ctime":1623254458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623254458","product_id":100061801,"comment_content":"数据库连接池上有没有必要再做多路复用？","like_count":0},{"had_liked":false,"id":275996,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1611739964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611739964","product_id":100061801,"comment_content":"减少跟 OS 的 IO 次数  用池化手段来优化系统 ","like_count":0},{"had_liked":false,"id":258245,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1604357137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604357137","product_id":100061801,"comment_content":"可以用池化技术做任务队列么?尤其是worker pool这几个库","like_count":0},{"had_liked":false,"id":258243,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1604356243,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604356243","product_id":100061801,"comment_content":"那像websocke这种长连接，每个ws用一个goroutine来维护，是不是就没必要用池化技术了。","like_count":0,"discussions":[{"author":{"id":1024237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a0/ed/ea88b3b4.jpg","nickname":"tienchiu","note":"","ucode":"4BE250C88AA38B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320844,"discussion_content":"同问。分析下来是不用。\n但是可以考虑下链接复用的方式来减小goroutine数量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604488450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258137,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1604309533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604309533","product_id":100061801,"comment_content":"打卡。","like_count":0}]}