{"id":271754,"title":"04 | AOF日志：宕机了，Redis如何避免数据丢失？","content":"<p>你好，我是蒋德钧。</p><p>如果有人问你：“你会把Redis用在什么业务场景下？”我想你大概率会说：“我会把它当作缓存使用，因为它把后端数据库中的数据存储在内存中，然后直接从内存中读取数据，响应速度会非常快。”没错，这确实是Redis的一个普遍使用场景，但是，这里也有一个绝对不能忽略的问题：<strong>一旦服务器宕机，内存中的数据将全部丢失。</strong></p><p>我们很容易想到的一个解决方案是，从后端数据库恢复这些数据，但这种方式存在两个问题：一是，需要频繁访问数据库，会给数据库带来巨大的压力；二是，这些数据是从慢速数据库中读取出来的，性能肯定比不上从Redis中读取，导致使用这些数据的应用程序响应变慢。所以，对Redis来说，实现数据的持久化，避免从后端数据库中进行恢复，是至关重要的。</p><p>目前，Redis的持久化主要有两大机制，即AOF（Append Only File）日志和RDB快照。在接下来的两节课里，我们就分别学习一下吧。这节课，我们先重点学习下AOF日志。</p><h2>AOF日志是如何实现的？</h2><p>说到日志，我们比较熟悉的是数据库的写前日志（Write Ahead Log, WAL），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过，AOF日志正好相反，它是写后日志，“写后”的意思是Redis是先执行命令，把数据写入内存，然后才记录日志，如下图所示：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/40/1f/407f2686083afc37351cfd9107319a1f.jpg?wh=3218*1789\" alt=\"\" title=\"Redis AOF操作过程\"></p><p>那AOF为什么要先执行命令再记日志呢？要回答这个问题，我们要先知道AOF里记录了什么内容。</p><p>传统数据库的日志，例如redo log（重做日志），记录的是修改后的数据，而AOF里记录的是Redis收到的每一条命令，这些命令是以文本形式保存的。</p><p>我们以Redis收到“set testkey testvalue”命令后记录的日志为例，看看AOF日志的内容。其中，“<code>*3</code>”表示当前命令有三个部分，每部分都是由“<code>$+数字</code>”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“<code>$3 set</code>”表示这部分有3个字节，也就是“set”命令。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/9f/4d120bee623642e75fdf1c0700623a9f.jpg?wh=3094*2250\" alt=\"\" title=\"Redis AOF日志内容\"></p><p>但是，为了避免额外的检查开销，Redis在向AOF里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis在使用日志恢复数据时，就可能会出错。</p><p>而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。</p><p>除此之外，AOF还有一个好处：它是在命令执行后才记录日志，所以<strong>不会阻塞当前的写操作</strong>。</p><p>不过，AOF也有两个潜在的风险。</p><p>首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时Redis是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果Redis是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</p><p>其次，AOF虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</p><p>仔细分析的话，你就会发现，这两个风险都是和AOF写回磁盘的时机相关的。这也就意味着，如果我们能够控制一个写命令执行完后AOF日志写回磁盘的时机，这两个风险就解除了。</p><h2>三种写回策略</h2><p>其实，对于这个问题，AOF机制给我们提供了三个选择，也就是AOF配置项appendfsync的三个可选值。</p><ul>\n<li><strong>Always</strong>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li>\n<li><strong>Everysec</strong>，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>\n<li><strong>No</strong>，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>\n</ul><p>针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。我们来分析下其中的原因。</p><ul>\n<li>“同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；</li>\n<li>虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在Redis手中了，只要AOF记录没有写回磁盘，一旦宕机对应的数据就丢失了；</li>\n<li>“每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。</li>\n</ul><p>我把这三种策略的写回时机，以及优缺点汇总在了一张表格里，以方便你随时查看。</p><p><img src=\"https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg?wh=2284*682\" alt=\"\"></p><p>到这里，我们就可以根据系统对高性能和高可靠性的要求，来选择使用哪种写回策略了。总结一下就是：想要获得高性能，就选择No策略；如果想要得到高可靠性保证，就选择Always策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择Everysec策略。</p><p>但是，按照系统的性能需求选定了写回策略，并不是“高枕无忧”了。毕竟，AOF是以文件的形式在记录接收到的所有写命令。随着接收的写命令越来越多，AOF文件会越来越大。这也就意味着，我们一定要小心AOF文件过大带来的性能问题。</p><p>这里的“性能问题”，主要在于以下三个方面：一是，文件系统本身对文件大小有限制，无法保存过大的文件；二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；三是，如果发生宕机，AOF中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到Redis的正常使用。</p><p>所以，我们就要采取一定的控制手段，这个时候，<strong>AOF重写机制</strong>就登场了。</p><h2>日志文件太大了怎么办？</h2><p>简单来说，AOF重写机制就是在重写时，Redis根据数据库的现状创建一个新的AOF文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。比如说，当读取了键值对“testkey”: “testvalue”之后，重写机制会记录set testkey testvalue这条命令。这样，当需要恢复时，可以重新执行该命令，实现“testkey”: “testvalue”的写入。</p><p>为什么重写机制可以把日志文件变小呢? 实际上，重写机制具有“多变一”功能。所谓的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。</p><p>我们知道，AOF文件是以追加的方式，逐一记录接收到的写命令的。当一个键值对被多条写命令反复修改时，AOF文件会记录相应的多条命令。但是，在重写的时候，是根据这个键值对当前的最新状态，为它生成对应的写入命令。这样一来，一个键值对在重写日志中只用一条命令就行了，而且，在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。</p><p>下面这张图就是一个例子：</p><p><img src=\"https://static001.geekbang.org/resource/image/65/08/6528c699fdcf40b404af57040bb8d208.jpg?wh=4000*1088\" alt=\"\" title=\"AOF重写减少日志大小\"></p><p>当我们对一个列表先后做了6次修改操作后，列表的最后状态是[“D”, “C”, “N”]，此时，只用LPUSH u:list “N”, “C”, \"D\"这一条命令就能实现该数据的恢复，这就节省了五条命令的空间。对于被修改过成百上千次的键值对来说，重写能节省的空间当然就更大了。</p><p>不过，虽然AOF重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。这时，我们就要继续关注另一个问题了：重写会不会阻塞主线程？</p><h2>AOF重写会阻塞吗?</h2><p>和AOF日志由主线程写回不同，重写过程是由后台子进程bgrewriteaof来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。</p><p>我把重写的过程总结为“<strong>一个拷贝，两处日志</strong>”。</p><p>“一个拷贝”就是指，每次执行重写时，主线程fork出后台的bgrewriteaof子进程。此时，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>“两处日志”又是什么呢？</p><p>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的AOF日志，Redis会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个AOF日志的操作仍然是齐全的，可以用于恢复。</p><p>而第二处日志，就是指新的AOF重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的AOF文件，以保证数据库最新状态的记录。此时，我们就可以用新的AOF文件替代旧文件了。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg?wh=3688*1920\" alt=\"\" title=\"AOF非阻塞的重写过程\"></p><p>总结来说，每次AOF重写时，Redis会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为Redis采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</p><h2>小结</h2><p>这节课，我向你介绍了Redis用于避免数据丢失的AOF方法。这个方法通过逐一记录操作命令，在恢复时再逐一执行命令的方式，保证了数据的可靠性。</p><p>这个方法看似“简单”，但也是充分考虑了对Redis性能的影响。总结来说，它提供了AOF日志的三种写回策略，分别是Always、Everysec和No，这三种策略在可靠性上是从高到低，而在性能上则是从低到高。</p><p>此外，为了避免日志文件过大，Redis还提供了AOF重写机制，直接根据数据库里数据的最新状态，生成这些数据的插入命令，作为新日志。这个过程通过后台线程完成，避免了对主线程的阻塞。</p><p>其中，三种写回策略体现了系统设计中的一个重要原则 ，即trade-off，或者称为“取舍”，指的就是在性能和可靠性保证之间做取舍。我认为，这是做系统设计和开发的一个关键哲学，我也非常希望，你能充分地理解这个原则，并在日常开发中加以应用。</p><p>不过，你可能也注意到了，落盘时机和重写机制都是在“记日志”这一过程中发挥作用的。例如，落盘时机的选择可以避免记日志时阻塞主线程，重写可以避免日志文件过大。但是，在“用日志”的过程中，也就是使用AOF进行故障恢复时，我们仍然需要把所有的操作记录都运行一遍。再加上Redis的单线程设计，这些命令操作只能一条一条按顺序执行，这个“重放”的过程就会很慢了。</p><p>那么，有没有既能避免数据丢失，又能更快地恢复的方法呢？当然有，那就是RDB快照了。下节课，我们就一起学习一下，敬请期待。</p><h2>每课一问</h2><p>这节课，我给你提两个小问题：</p><ol>\n<li>AOF日志重写的时候，是由bgrewriteaof子进程来完成的，不用主线程参与，我们今天说的非阻塞也是指子进程的执行不阻塞主线程。但是，你觉得，这个重写过程有没有其他潜在的阻塞风险呢？如果有的话，会在哪里阻塞？</li>\n<li>AOF重写也有一个重写日志，为什么它不共享使用AOF本身的日志呢？</li>\n</ol><p>希望你能好好思考一下这两个问题，欢迎在留言区分享你的答案。另外，也欢迎你把这节课的内容转发出去，和更多的人一起交流讨论。</p>","neighbors":{"left":{"article_title":"03 | 高性能IO模型：为什么单线程Redis能那么快？","id":270474},"right":{"article_title":"05 | 内存快照：宕机后，Redis如何实现快速恢复？","id":271839}},"comments":[{"had_liked":false,"id":241152,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":true,"comment_ctime":1597203496,"is_pvip":true,"replies":[{"id":"89327","content":"非常赞！这个回答一定要置顶！<br><br>而且Kaito同学的不少问题回答都非常仔细和精彩，非常值得一读！<br><br>这里要谢谢Kaito同学指出的文章中的歧义：fork子进程时，子进程是会拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据了，此时，类似于有了父进程的所有内存数据。我的描述不太严谨了，非常感谢指出！<br><br>Kaito同学还提到了Huge page。这个特性大家在使用Redis也要注意。Huge page对提升TLB命中率比较友好，因为在相同的内存容量下，使用huge page可以减少页表项，TLB就可以缓存更多的页表项，能减少TLB miss的开销。<br><br>但是，这个机制对于Redis这种喜欢用fork的系统来说，的确不太友好，尤其是在Redis的写入请求比较多的情况下。因为fork后，父进程修改数据采用写时复制，复制的粒度为一个内存页。如果只是修改一个256B的数据，父进程需要读原来的内存页，然后再映射到新的物理地址写入。一读一写会造成读写放大。如果内存页越大（例如2MB的大页），那么读写放大也就越严重，对Redis性能造成影响。<br><br>Huge page在实际使用Redis时是建议关掉的。","user_name":"作者回复","comment_id":241152,"uid":"1609687","ip_address":"","utype":1,"ctime":1597575046,"user_name_real":"蒋德钧"}],"discussion_count":152,"race_medal":0,"score":"9.2233770249090007e+18","product_id":100056701,"comment_content":"问题1，Redis采用fork子进程重写AOF文件时，潜在的阻塞风险包括：fork子进程 和 AOF重写过程中父进程产生写入的场景，下面依次介绍。<br><br>\ta、fork子进程，fork这个瞬间一定是会阻塞主线程的（注意，fork时并不会一次性拷贝所有内存数据给子进程，老师文章写的是拷贝所有内存数据给子进程，我个人认为是有歧义的），fork采用操作系统提供的写实复制(Copy On Write)机制，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题，但fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。<br><br>\tb、fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。<br><br>问题2，AOF重写不复用AOF本身的日志，一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。","like_count":1162,"discussions":[{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339057,"discussion_content":"这哪是课代表，这是助教啊","likes_number":38,"is_delete":false,"is_hidden":false,"ctime":1609486715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2124243,"avatar":"https://static001.geekbang.org/account/avatar/00/20/69/d3/97510c5b.jpg","nickname":"荐哥 | 周优军","note":"","ucode":"5DDD9CC85A2E6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578435,"discussion_content":"每个课程都能发现你的身影，你也是好学生呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656743174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339057,"ip_address":""},"score":578435,"extra":""}]},{"author":{"id":1890006,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/d6/d6/5fbb6e00.jpg","nickname":"再忙也要充充电","note":"","ucode":"098F2D9D280D60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373713,"discussion_content":"大佬不但技术好素质还很好，我看上面的笔记中有的和自己理解有偏差的时候就开始说老师水平不行了，哈哈哈","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1620832356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2419770,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ec/3a/75bc138d.jpg","nickname":"Saitama","note":"","ucode":"94735DA32C22B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343791,"discussion_content":"大佬操作系统功底真强","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1611161343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2049478,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/45/c6/ba5176a6.jpg","nickname":"从不卖萌","note":"","ucode":"E9B7B1C8FAFE0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2419770,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ec/3a/75bc138d.jpg","nickname":"Saitama","note":"","ucode":"94735DA32C22B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346893,"discussion_content":"是的..这篇文章真学到太多东西","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1612093233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343791,"ip_address":""},"score":346893,"extra":""}]},{"author":{"id":2308831,"avatar":"https://static001.geekbang.org/account/avatar/00/23/3a/df/ea0fc831.jpg","nickname":"周天航","note":"","ucode":"B28D84594679A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324746,"discussion_content":"本来对文章内容还有一些疑问的（子进程直接拷贝一份内存，如果此时redis内存使用超过50%那岂不是没办法拷贝了吗？），看了您的解释就搞清楚了为啥了。内存中的数据实际只有一份，也只占一份内存然后两个进程之间共享，如果主进程收到修改命令，就让主进程重新申请内存，重新写。可以这么理解吗？","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1605164893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2308831,"avatar":"https://static001.geekbang.org/account/avatar/00/23/3a/df/ea0fc831.jpg","nickname":"周天航","note":"","ucode":"B28D84594679A6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324772,"discussion_content":"对。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605168509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324746,"ip_address":""},"score":324772,"extra":""},{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":589124,"discussion_content":"为什么是父进程重新申请内存写，而不是子进程呢？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664433860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324772,"ip_address":"北京"},"score":589124,"extra":""},{"author":{"id":1604468,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7b/74/9b88e040.jpg","nickname":"柏油","note":"","ucode":"92BFEEEE8BBFA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":590109,"discussion_content":"父、子进程都可以申请，谁需要写操作，谁就申请新内存并指向它，原内存页引用减1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1665540626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":589124,"ip_address":"广东"},"score":590109,"extra":""}]},{"author":{"id":1186807,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1b/f7/45e8b64a.jpg","nickname":"Fire","note":"","ucode":"4A2C50B77EDB2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340041,"discussion_content":"硬着头皮看完了趣谈linux操作系统建立了一定的概念体系后，再回头来看您和老师的回复，都通了，这感觉真好，感谢分享！","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1609889422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1186807,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1b/f7/45e8b64a.jpg","nickname":"Fire","note":"","ucode":"4A2C50B77EDB2C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353159,"discussion_content":"我也去看，还有一个计算机组成原理，应该可以加深理解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615038890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340041,"ip_address":""},"score":353159,"extra":""}]},{"author":{"id":1464835,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5a/03/b27f72b6.jpg","nickname":"秋梵","note":"","ucode":"129DA4E9886D2E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298580,"discussion_content":"课代表，看了这段话，有关内容我的理解是这样的你看看对不对，然后想问个问题：\nAOF重写的时候，子线程会首先拷贝必要的数据结构包括内存页表，完成了这个操作就可以进行重写，只不过父子进程这个时候指向的是同一个内存，在子进程重写过程中若父进程操作了已有的key，则会重新申请新的内存，这样父子进程就逐渐的拥有独自的内存空间。\n\n其中我有些不太明白的是，为什么父子进程要进行内存分离？子进程只有读操作并没有写操作啊，，不进行内存分离会有什么影响吗？而且子进程在重写完毕之后，拷贝的旧数据冗余内存Redis是如何处理的？\n\n求课代表大大解惑_(:3)∠*)_","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1597331489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":12,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1464835,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5a/03/b27f72b6.jpg","nickname":"秋梵","note":"","ucode":"129DA4E9886D2E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298593,"discussion_content":"你理解的是对的。\n\nfork意味着创建子进程，进程就是为了做资源隔离的，也就意味着各自需要拥有自己的内存空间，这是操作系统层面的机制。\n\nRedis想要生成RDB或重写AOF，必须先产生一份数据快照，然后把这个快照数据写到磁盘，想要做到这样，最经济的办法就是利用fork子进程的方式，操作系统帮已经帮你做好了这些工作，而且写时复制也可以避免fork长时间阻塞，这些都是操作系统层面的优化。\n\n子进程重写AOF结束后，子进程退出，冗余内存会被释放，还给操作系统，也就是说AOF重写期间，系统内存先减少，之后又回收回来。","likes_number":30,"is_delete":false,"is_hidden":false,"ctime":1597335202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298580,"ip_address":""},"score":298593,"extra":""},{"author":{"id":1464835,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5a/03/b27f72b6.jpg","nickname":"秋梵","note":"","ucode":"129DA4E9886D2E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":298614,"discussion_content":"啊 明白了 谢谢 | ᐕ)⁾⁾","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597362630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298593,"ip_address":""},"score":298614,"extra":""},{"author":{"id":1193052,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/5c/6b4757a0.jpg","nickname":"倪大人","note":"","ucode":"4798D69F3E86FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1464835,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5a/03/b27f72b6.jpg","nickname":"秋梵","note":"","ucode":"129DA4E9886D2E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298670,"discussion_content":"子进程只有读操作并没有写操作啊，不进行内存分离会有什么影响吗？\n\n会有问题呀，要是子进程已经读完，父进程再修改，不分离就会丢失这一次的操作数据了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597374672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298580,"ip_address":""},"score":298670,"extra":""}]},{"author":{"id":1186089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/19/29/4a8214b7.jpg","nickname":"Bug Killer","note":"","ucode":"2741A206F504E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301676,"discussion_content":"看了老师的讲解，再看 课代表的补充，简直绝了！","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1598605693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2185166,"avatar":"https://static001.geekbang.org/account/avatar/00/21/57/ce/ad3c3954.jpg","nickname":"鹅鹅鹅","note":"","ucode":"6AFA3FCC7B5AEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352261,"discussion_content":"真牛逼，这都怎么想出来的？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？我咋想不出来，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1614666668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1851970,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/42/42/2a04ada9.jpg","nickname":"毛小树","note":"","ucode":"E47DC07CE4959E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2185166,"avatar":"https://static001.geekbang.org/account/avatar/00/21/57/ce/ad3c3954.jpg","nickname":"鹅鹅鹅","note":"","ucode":"6AFA3FCC7B5AEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575173,"discussion_content":"这哪能想出来，只是知识储备多了才能写出来的，咱只会：\n牛逼。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1654647890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352261,"ip_address":""},"score":575173,"extra":""}]},{"author":{"id":2222937,"avatar":"","nickname":"ronaldo","note":"","ucode":"824AE89F4C58BB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320697,"discussion_content":"@Kaito  若原有的内存数据是A，  那重写AOF时，fork后父子进程都会指向A地址，当新的写入进来时，父进程会拷贝数据（新的key直接写？），而子进程访问A逐渐写入到重写AOF中，写完通知父进程，父进程会把写到缓冲的新key，再追加到重写AOF中，再rename。 希指正","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604455256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1400806,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/e6/19778e70.jpg","nickname":"Mr.埃克斯","note":"","ucode":"855BE5DFD2BB0B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2222937,"avatar":"","nickname":"ronaldo","note":"","ucode":"824AE89F4C58BB","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":350958,"discussion_content":"新的key直接申请内存就写了。其余理解正确。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614082458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320697,"ip_address":""},"score":350958,"extra":""},{"author":{"id":1355831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/37/d654fbac.jpg","nickname":"几近虚年","note":"","ucode":"28CD6486EED8E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1400806,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/e6/19778e70.jpg","nickname":"Mr.埃克斯","note":"","ucode":"855BE5DFD2BB0B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":360054,"discussion_content":"你好，我有个疑惑：\n写入新数据，申请内存后，直接就写到了新旧两个 AOF 日志文件。\n修改操作，父进程申请内存，写入旧 AOF 缓冲区。写完新 AOF 日志，再把旧 AOF 缓冲区的记录追加到新 AOF 日志文件。\n那老师说写新的数据，会存在新旧两个 AOF 日志的缓冲区呢？\n谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616341482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350958,"ip_address":""},"score":360054,"extra":""},{"author":{"id":2041396,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","nickname":"宙斯","note":"","ucode":"80DF36BAD298AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1355831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/37/d654fbac.jpg","nickname":"几近虚年","note":"","ucode":"28CD6486EED8E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388213,"discussion_content":"这里只有AOF缓冲区，AOF重写缓冲区（这是两个不同缓冲区），写入新数据会写入两个缓冲区。之所以写入AOF缓冲区（后续写入AOF文件）是为了防止宕机而冗余的数据，而AOF重写缓冲区是在重写日志文件生成后，再追加到重写日志文件中，最后再将重写日志文件命名为AOF日志文件。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628656514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360054,"ip_address":""},"score":388213,"extra":""}]},{"author":{"id":1594292,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epCnHKhYLefpkm02lnr4SpV5T4ibDQ2e4SlibkcaGu8ZxVDlEmVib6j0TiaDTicMmjrEdiaia8Aeen3nR7dg/132","nickname":"Geek_4a677e","note":"","ucode":"ACE5BD07A232D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539221,"discussion_content":"时刻提醒我自己，我是个废物 😭","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1639644275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503658,"discussion_content":"非常赞！这个回答一定要置顶！\n\n而且Kaito同学的不少问题回答都非常仔细和精彩，非常值得一读！\n\n这里要谢谢Kaito同学指出的文章中的歧义：fork子进程时，子进程是会拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据了，此时，类似于有了父进程的所有内存数据。我的描述不太严谨了，非常感谢指出！\n\nKaito同学还提到了Huge page。这个特性大家在使用Redis也要注意。Huge page对提升TLB命中率比较友好，因为在相同的内存容量下，使用huge page可以减少页表项，TLB就可以缓存更多的页表项，能减少TLB miss的开销。\n\n但是，这个机制对于Redis这种喜欢用fork的系统来说，的确不太友好，尤其是在Redis的写入请求比较多的情况下。因为fork后，父进程修改数据采用写时复制，复制的粒度为一个内存页。如果只是修改一个256B的数据，父进程需要读原来的内存页，然后再映射到新的物理地址写入。一读一写会造成读写放大。如果内存页越大（例如2MB的大页），那么读写放大也就越严重，对Redis性能造成影响。\n\nHuge page在实际使用Redis时是建议关掉的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597575046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2532285,"avatar":"","nickname":"Geek_926921","note":"","ucode":"51C3B0178D77E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360361,"discussion_content":"大佬，你是作者小号吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1616422669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340355,"discussion_content":"kaito大佬，请教一下，子进程fork之页，复制了页表和其他必要数据。这时页表是存在两份么，父进程一份，子进程一份。\n父进程 cow 写数据，新申请的内存，也只是更新页表。所以对子进程没影响。\n子进程重写完之后，释放自己的内存，所以对父进和没影响。\n不太明白key 和虚拟地址怎么映射，从而通过页表找到物理地址。\n\n谢谢大佬！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609985296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340361,"discussion_content":"key申请内存，内存申请是如何映射通过虚拟内存映射到物理内存的？你可以看看这方面资料。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609985799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340355,"ip_address":""},"score":340361,"extra":""}]},{"author":{"id":1179560,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/a8/73cd4a30.jpg","nickname":"千万海","note":"","ucode":"941C431A163B83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329304,"discussion_content":"大佬开课吧，我第一个买","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606363351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2212143,"avatar":"https://static001.geekbang.org/account/avatar/00/21/c1/2f/5c8167aa.jpg","nickname":"油纸伞","note":"","ucode":"C2655B9F8874E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309839,"discussion_content":"有个疑惑，如果写入内存成功了，在写入aof日志的时候失败了，宕机数据会不会丢失，有什么处理机制吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601458395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2354474,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/UNC7eWZWvRyAPWUpIJicgZBWLNpkljMbgeaFVWU3QNmWgaibchc8aGFfAG7gWh7eghHSrtSuSqMDp2ibVnvE2eLJg/132","nickname":"Geek_a88948","note":"","ucode":"C7FF3099A180D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2212143,"avatar":"https://static001.geekbang.org/account/avatar/00/21/c1/2f/5c8167aa.jpg","nickname":"油纸伞","note":"","ucode":"C2655B9F8874E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350651,"discussion_content":"redis-check-aof --fix xx.aof","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613966040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309839,"ip_address":""},"score":350651,"extra":""}]},{"author":{"id":1727355,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/5b/7b/1ee6ec86.jpg","nickname":"Lionheart","note":"","ucode":"CA2E83FE4EAD18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299113,"discussion_content":"子进程进行AOF重写期间，主进程的AOF重写缓冲区会持久化吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597567156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1727355,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/5b/7b/1ee6ec86.jpg","nickname":"Lionheart","note":"","ucode":"CA2E83FE4EAD18","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299123,"discussion_content":"会的，父子进程不影响。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597569582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299113,"ip_address":""},"score":299123,"extra":""},{"author":{"id":1335155,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","nickname":"拒绝","note":"","ucode":"CB0264C4D3FE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":314003,"discussion_content":"课代表请问一下:\n父子进程不影响的话,那新写入的命令,都会分别写入父子AOF日志,会不会出现父子进程AOF数据不一致; 不一致的话怎么做到子进程替换父进程的AOF日志?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603111941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299123,"ip_address":""},"score":314003,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1335155,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","nickname":"拒绝","note":"","ucode":"CB0264C4D3FE17","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338269,"discussion_content":"不会不一致 , redis执行命令是单线程意味着本次请求读取到的数据一定是最新的这个跟数据库不一样 . 一份内存数据两份日志就是为了保证一致性.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609227792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":314003,"ip_address":""},"score":338269,"extra":""}]},{"author":{"id":2120920,"avatar":"","nickname":"Geek_ec6af6","note":"","ucode":"43E270FCB07A17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298404,"discussion_content":"课代表同志，厉害啦 我看了很多都不懂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597290984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2331842,"avatar":"","nickname":"Geek_4f06ca","note":"","ucode":"69B37349DE3EC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372643,"discussion_content":"既然父线程和子线程共享内存，为什么发生重写时还需要把新数据写入重写缓冲里，这个新操作不是会放入父线程的内存里吗？子线程重写时会全部写入重写AOF文件吧，不懂，求指导","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620398436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2331842,"avatar":"","nickname":"Geek_4f06ca","note":"","ucode":"69B37349DE3EC5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373195,"discussion_content":"因为需要使用日志的方式记录先后顺序做回放 而不是直接将内存数据盖掉。注意此时父子进程两两互补干涉 父进程仍然负责外部读写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620649157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372643,"ip_address":""},"score":373195,"extra":""},{"author":{"id":2273076,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo1QZQ0eoOqvOyMyAzcsyEK8bQaZTd9aJHTTCYicicUm9gmhUFaxQe6IBc3caLVD8PhqtmhhicrNHe0w/132","nickname":"Severus4","note":"","ucode":"79BC6487B595EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373944,"discussion_content":"aof重写的过程中，新的操作是在主线程和子线程都存了一份，然后重写结束以后用子线程的缓冲来进行重放吗？这里可不可以直接用父线程的缓冲来重放？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620921435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373195,"ip_address":""},"score":373944,"extra":""},{"author":{"id":2556920,"avatar":"https://static001.geekbang.org/account/avatar/00/27/03/f8/1aa9a263.jpg","nickname":"👀","note":"","ucode":"6DB6C1BA41E787","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2331842,"avatar":"","nickname":"Geek_4f06ca","note":"","ucode":"69B37349DE3EC5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380483,"discussion_content":"在主进程fork子进程的时候，采用了了操作系统的写时复制（cpoy-on-write）,此时主进程中的所有内存页都被标识为read-only,子进程的内存地址也是指向父进程的内存。如果有进程发生写入操作的时候，操作系统检测到内存页是read-only的，就会把对应的内存页复制一份，此时主进程与子进程就分别持有独立的一份。所以在主进程中的写入操作并不会影响子进程的内存数据。也就是说，子进程的内存空间不包含新写入的数据。  可以看下大佬的博客：https://juejin.cn/post/6844903702373859335","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1624524207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372643,"ip_address":""},"score":380483,"extra":""}]},{"author":{"id":1266098,"avatar":"https://static001.geekbang.org/account/avatar/00/13/51/b2/e4281116.jpg","nickname":"敲键盘的猿","note":"","ucode":"23BEC050CF7CD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339998,"discussion_content":"太强了助教同学","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609857916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","nickname":"注定非凡","note":"","ucode":"80673056E131B7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298550,"discussion_content":"看完，只想大叫:牛皮","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597323708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2818816,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJR8XicKtnzHnOUDd7jkEpMnf7gME0uVNjUTJb0SUga6DuuEMszpHgDKScWoibdBL32O8dRrkxGibJjg/132","nickname":"Geek_43b98b","note":"","ucode":"3D1CB8CF4F259F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591174,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666339523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2725596,"avatar":"https://static001.geekbang.org/account/avatar/00/29/96/dc/8adf8971.jpg","nickname":"幼稚园的小朋友","note":"","ucode":"EF63C355BD58A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587471,"discussion_content":"大佬 能麻烦问下 在写时复制的时候 被复制的那部分页 不就在内存中存在两份了 在aof重写完成之后 是如何释放的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663077925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"日本"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3065276,"avatar":"","nickname":"Geek_b3b8da","note":"","ucode":"5461CD95B1D764","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585953,"discussion_content":"大佬对于操作系统理解太深入了，就好像内存里面有他的眼睛一样，清除的看见到底如何发生的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661917623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042801,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e9/71/40b04914.jpg","nickname":"Zer0","note":"","ucode":"CC754786CFEB4C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582258,"discussion_content":"基础知识也太扎实了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659339357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037669,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/65/1c9f1530.jpg","nickname":"NorthWind","note":"","ucode":"459ADF3B0945E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576757,"discussion_content":"写实复制-&gt; 写时复制吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655778891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2249400,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/b8/587a0c2d.jpg","nickname":"bwby","note":"","ucode":"9CDFB6FD9FE03F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569833,"discussion_content":"66","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651568655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1665437,"avatar":"https://static001.geekbang.org/account/avatar/00/19/69/9d/3dc6ea44.jpg","nickname":"baci","note":"","ucode":"173AB22308B07C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565054,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650378560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553317,"discussion_content":"后面忘记了，只需要看每一章的课后问题，然后再找下kaito大神的评论就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645847318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549445,"discussion_content":"结合这么多评论和一些博文，我说一下自己对fork和cow的理解，也不知道对不对。fork出子进程后，父子进程共享内存空间，假设此时有三个内存页abc。在子进程重写期间，假设父进程要对内存页b进行修改，则会先将b拷贝一份，暂且叫做b_copy，拷贝完后，父进程再对b_copy进行修改。此时，父子进程的内存空间已经局部隔离了，父进程是a、b_copy、c三个内存页，而子进程则还是abc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643987057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2263754,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8a/ca/1afcc75b.jpg","nickname":"健康的小牛犊","note":"","ucode":"A63C30B602F0A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549142,"discussion_content":"太强了太强了，这感觉直接加强了这个专栏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643618622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272662,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/56/37a4cea7.jpg","nickname":"单朋荣","note":"","ucode":"8AD121BEDD9675","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540390,"discussion_content":"在数据写成操作的时候（相当于之前讲的将AOF里多条相关语句合并），而新的写操作会写入新AOF缓存。在复制数据的时候，bgrewriteaof子进程复制的是虚拟页表，【在“写实复制”的时（父进程）会申请物理的内存空间】将数据重写为新的AOF记录；新写入的数据，会分别写入AOF缓冲和AOF重写缓冲。 这里的疑问是，AOF重写缓冲和新的AOF是什么关系，Reids数据拷贝应该是静态数据（就是父进程新的写操作发生之前，父子内存空间未分离的时候），在AOF日志重写完成的时候，追加AOF重写缓冲的新操作数据，如果不是这样，会不会造成记录“乱序”的问题？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640052309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2760501,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/1f/35/569e02f8.jpg","nickname":"张大局","note":"","ucode":"9F83EB9606EAEB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534265,"discussion_content":"疑问：“父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间”。这里的申请新的内存空间指的是文中的AOF缓冲区吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638152397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1693927,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIg8jibDUq1QVY6Kjabg6kc66QfjibibNCKwbEPCBq6ejQzg5WDhIv9Nyv9icfJ5W98CFMDYaoITibD7kQ/132","nickname":"Geek_018298","note":"","ucode":"02FE1726627515","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534232,"discussion_content":"真大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638147616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533917,"discussion_content":"同学们，我想请问一下Redis是什么时候判断AOF重写日志写完，并去替换旧的AOF文件的。\n\n还有当Redis使用新的AOF重写文件替换旧的AOF文件时，此时AOF缓冲区应该是不能写新的内容了吧？是需要加锁么。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638021794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107879,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e7/a7/9825371e.jpg","nickname":"Penn","note":"","ucode":"2D73D9C2AED26F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533350,"discussion_content":"大佬，咱们什么时候开课？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637843562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272315,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/nSvVtStiaQzslFM7YRnlhPyTgSHGoXvOqlSQS8rMEmfnFCtasNxRiaVfrRcMlkuOSq1iaReQD0CiaGHMVibsVMNkAxQ/132","nickname":"justin","note":"","ucode":"09AE502D6A28D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412149,"discussion_content":"这只能分析源码才能清楚的细节啊， 应该是分析过源码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636087010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2833297,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKIQ5ytSb60gchNca3lOc0yUQts2CLstRfSffhTQYxC9kl6QOHb1EvJM3rfJ0B5ziavkiapQB9Dnadw/132","nickname":"Geek_1a4ed3","note":"","ucode":"A1141788AE8056","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411182,"discussion_content":"高手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635861973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550249,"avatar":"","nickname":"Geek_621caf","note":"","ucode":"0312ABFDE154CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390885,"discussion_content":"强","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630118588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1992480,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/67/20/93b2e38e.jpg","nickname":"flying myself","note":"","ucode":"69F26BE9B94B58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388638,"discussion_content":"No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。 操作系统怎么控制的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628862905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2028585,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f4/29/20880430.jpg","nickname":"fire","note":"","ucode":"2B5F571516CD11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1992480,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/67/20/93b2e38e.jpg","nickname":"flying myself","note":"","ucode":"69F26BE9B94B58","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388723,"discussion_content":"操作系统有机制将页缓存写回到磁盘，具体怎么实现我也不知道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628927207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":388638,"ip_address":""},"score":388723,"extra":""}]},{"author":{"id":2644373,"avatar":"","nickname":"追风","note":"","ucode":"46A2EC5C07AC4F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388499,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628786758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2306058,"avatar":"https://static001.geekbang.org/account/avatar/00/23/30/0a/2cd6afa1.jpg","nickname":"浅池卧龙","note":"","ucode":"37F55BFD124EB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387689,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628348342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/cd/bb4e5d24.jpg","nickname":"谭晨","note":"","ucode":"B1355E14B03718","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384463,"discussion_content":"问题2中的“AOF重写不复用AOF本身的日志”的另一个原因，也是因为AOF重写不是根据原有的AOF去做，而是根据当前内存数据库的数据，去生成一条条命令进行保存。这个理解对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626603231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203051,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5b/6b/1b2f9b81.jpg","nickname":"Joey(小东)","note":"","ucode":"7C30FC82EECF74","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383925,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626309519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2164123,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oOSgaSW8MFRDx6da1bicY40IVg7hoDNjYlSuTeIg93aB3nuKedhbTa2HQhXpBJmN2w0xU9icvkTDZWMzL5NVicrYw/132","nickname":"伪钞","note":"","ucode":"7087364945A6B0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382765,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625715592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2653123,"avatar":"https://static001.geekbang.org/account/avatar/00/28/7b/c3/2888c579.jpg","nickname":"Geek_8115f3","note":"","ucode":"6C8E645D08063E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382507,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625621654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373224,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620654684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2344071,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c4/87/174fa848.jpg","nickname":"Lzh","note":"","ucode":"49E1E7028972DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371436,"discussion_content":"给大佬跪了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619768537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1259280,"avatar":"https://static001.geekbang.org/account/avatar/00/13/37/10/a8aa9acb.jpg","nickname":"jzdayz","note":"","ucode":"E84C0DFC53BE8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368997,"discussion_content":"父进程写入新的aof和旧的aof，那子进程对新的aof进行重写，这样不会产生竞争问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618899238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1249788,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/fc/9242ae5c.jpg","nickname":"冯浩","note":"","ucode":"D00E0133A6E4CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1259280,"avatar":"https://static001.geekbang.org/account/avatar/00/13/37/10/a8aa9acb.jpg","nickname":"jzdayz","note":"","ucode":"E84C0DFC53BE8A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370012,"discussion_content":"父进程不会直接去写新的aof文件，父进程是把新的写入放到缓存中，等新aof文件重写完了，再把缓存追加到新的aof文件中","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1619250561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368997,"ip_address":""},"score":370012,"extra":""},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1259280,"avatar":"https://static001.geekbang.org/account/avatar/00/13/37/10/a8aa9acb.jpg","nickname":"jzdayz","note":"","ucode":"E84C0DFC53BE8A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386188,"discussion_content":"仔细看老师的图，在重写期间，如果有新的写(子进程还在写第一次拷贝回来的数据)，会同时写到aof缓冲区和aof重写缓冲区，aof重写完拷贝完的数据后，会去把aof重写缓冲区的数据写到新的aof里面","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627459081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368997,"ip_address":""},"score":386188,"extra":""}]},{"author":{"id":1716574,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/31/5e/2aeb4f31.jpg","nickname":"xyuu","note":"","ucode":"CF0C9EF5F7D4E1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368079,"discussion_content":"大佬，是不是可以这么理解，重写AOF文件的时候，如果正好没有请求进来，那就是用原来的内存数据进行重写，同时如果主线程数据修改在子线程已经重写完这个页的数据之后那也不会复制内存，如果内存不足，那重写AOF是不是就会失败？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618560046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1182383,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/af/6f244997.jpg","nickname":"lee","note":"","ucode":"CD672BDB1B58F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1716574,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/31/5e/2aeb4f31.jpg","nickname":"xyuu","note":"","ucode":"CF0C9EF5F7D4E1","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":377560,"discussion_content":"个人理解为, 即使子线程已经重写完成这个页的数据, 但是主线程要修改这个页的数据的时候, 还是会复制一份去做新的写操作, 所以不会因为内存不足就AOF失败的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622710030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368079,"ip_address":""},"score":377560,"extra":""},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1716574,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/31/5e/2aeb4f31.jpg","nickname":"xyuu","note":"","ucode":"CF0C9EF5F7D4E1","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":549447,"discussion_content":"父进程修改子进程已经重写过的内存页，父进程还是会拷贝这个内存页再进行修改，这个是操作系统的cow机制，redis也控制不了。不过重写缓存也会记录这次修改，应该是没问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643987637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368079,"ip_address":""},"score":549447,"extra":""}]},{"author":{"id":2324871,"avatar":"https://static001.geekbang.org/account/avatar/00/23/79/87/255c9d42.jpg","nickname":"DropTower","note":"","ucode":"AE3215CB91C763","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366142,"discussion_content":"真大佬，赞赞赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617969727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1355831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/37/d654fbac.jpg","nickname":"几近虚年","note":"","ucode":"28CD6486EED8E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360237,"discussion_content":"你好，看了老师的第五讲，有个疑问：\n修改操作时，父进程分配了内存空间，此时拷贝数据到内存空间。那拷贝到新内存空间的数据是旧数据还是修改后的新数据？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616397578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1355831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/37/d654fbac.jpg","nickname":"几近虚年","note":"","ucode":"28CD6486EED8E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360284,"discussion_content":"拷贝原来的数据到新的内存空间，再修改它。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616409769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360237,"ip_address":""},"score":360284,"extra":""},{"author":{"id":1355831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/37/d654fbac.jpg","nickname":"几近虚年","note":"","ucode":"28CD6486EED8E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":360637,"discussion_content":"好的，昨天也在群里已经问清楚了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616495784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360284,"ip_address":""},"score":360637,"extra":""},{"author":{"id":1275424,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aiaO77mTsCalcia49ElevPn988pgwcL3rD5ic1DTD6E8rbAwfmguiaPsibHicsYGQID7VbmD21GUAV9bbuNMfDhDGGyg/132","nickname":"穿针土豆丝","note":"","ucode":"5DA3BDDE5162E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":365602,"discussion_content":"新增和修改分配内存能理解，那删除数据时，是不是就不用分配内存？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617848822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360284,"ip_address":""},"score":365602,"extra":""}]},{"author":{"id":1015986,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/b2/2e9f442d.jpg","nickname":"文武木子","note":"","ucode":"348752BDECD65F","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358244,"discussion_content":"牛啊，牛啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615951770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2416395,"avatar":"https://static001.geekbang.org/account/avatar/00/24/df/0b/7f14e6fd.jpg","nickname":"rtl.","note":"","ucode":"7E4E58548BA853","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356916,"discussion_content":"插眼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615707085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400806,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/e6/19778e70.jpg","nickname":"Mr.埃克斯","note":"","ucode":"855BE5DFD2BB0B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350988,"discussion_content":"“使用huge page可以减少页表项，TLB就可以缓存更多的页表项”，请问为什么huge page减少页表项，TLB就可以缓存更多的页表项，据我理解，TLB中的能够存储的页表项数量是固定的吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614091545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1803932,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/86/9c/f1c43834.jpg","nickname":"Walk beside you","note":"","ucode":"C3FDED0004C763","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1400806,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/e6/19778e70.jpg","nickname":"Mr.埃克斯","note":"","ucode":"855BE5DFD2BB0B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":353700,"discussion_content":"TLB全部存储的是地址谢谢，TLB中个数大小是由页的数目决定的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615192668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350988,"ip_address":""},"score":353700,"extra":""}]},{"author":{"id":2032032,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/01/a0/07ca2bd2.jpg","nickname":"一路顺风","note":"","ucode":"D46B7F92D65189","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350141,"discussion_content":"想请问下大佬，aof重写缓冲区是一块内存缓冲吗?重写缓冲区是在父进程中写的吧，如果重写aof慢的话会内存溢出吗？子进程重写完成之后通知父进程将aof缓冲区内容添加到新写的aof文件吗？这个添加过程是会阻塞父进程是吗？重写的aof文件在父进程中会在fork之前打开吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613724795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022411,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/cb/8964faab.jpg","nickname":"-只是小小配角_","note":"","ucode":"EFC1CD54A23F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348220,"discussion_content":"请问大佬，如果Redis内存占用比较大，AOF重写时，内存修改又比较频繁，有没有必要修改 Linux 系统参数 vm.overcommit_memory 为 1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612486548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1148422,"avatar":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","nickname":"美美","note":"","ucode":"44CC95C45AF345","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343599,"discussion_content":"为什么aof刷盘不直接采用异步呢？这样只要网络速率小于磁盘写入速率，就可以保证数据不丢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611108265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145779,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7b/b3/194f7f90.jpg","nickname":"没伞的孩子得使劲奔跑","note":"","ucode":"D015B4EF12E536","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338011,"discussion_content":"多强的基础，才能分针这么牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609153258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2194764,"avatar":"","nickname":"K菌无惨","note":"","ucode":"97A532D588FD49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336525,"discussion_content":"按我的理解是由于AOF重写缓冲区与AOF缓冲区的flush时机不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608616310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134774,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/b6/a60efa42.jpg","nickname":"孟凡浩","note":"","ucode":"77522A196C31D5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327956,"discussion_content":"mk","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606026262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":7,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1247310,"avatar":"https://static001.geekbang.org/account/avatar/00/13/08/4e/79c3d903.jpg","nickname":"结冰的海","note":"","ucode":"B6ED66252803ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326858,"discussion_content":"大佬，我有个疑问，当子进程重写AOF进行到一半时，主进程修改了已经重写过的数据，会触发写时复制，拷贝一份数据并申请内存给子进程，但子进程已经重写过这条数据了，虽然这条数据的操作可以通过AOF重写缓冲区后续刷入新的AOF日志，那么这个写时复制是不是就没有意义了？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605689841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1107305,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/69/719ec5d0.jpg","nickname":"Jian","note":"","ucode":"17ED4919F22DEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1247310,"avatar":"https://static001.geekbang.org/account/avatar/00/13/08/4e/79c3d903.jpg","nickname":"结冰的海","note":"","ucode":"B6ED66252803ED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333157,"discussion_content":"我理解已经写过了的就不会再写时复制了，这个时候只会添加到AOF重写缓冲区中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607445758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326858,"ip_address":""},"score":333157,"extra":""},{"author":{"id":2354474,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/UNC7eWZWvRyAPWUpIJicgZBWLNpkljMbgeaFVWU3QNmWgaibchc8aGFfAG7gWh7eghHSrtSuSqMDp2ibVnvE2eLJg/132","nickname":"Geek_a88948","note":"","ucode":"C7FF3099A180D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1247310,"avatar":"https://static001.geekbang.org/account/avatar/00/13/08/4e/79c3d903.jpg","nickname":"结冰的海","note":"","ucode":"B6ED66252803ED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350540,"discussion_content":"我的理解，写时复制是操作系统层面的实现，由系统实现。在redis源码中是看不到直接操作页表、映射的（可以理解为更底层的实现），最多看到fork。而AOF重写缓冲区的刷入是redis重写机制的代码，这部分是应该在源码中包含的。\n大佬提出fork写时复制的原理的出发点，是因为在申请内存时有可能会产生 阻塞 。这个阻塞和重写缓冲区刷入到aof日志，是没有关系的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613909659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326858,"ip_address":""},"score":350540,"extra":""},{"author":{"id":2354474,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/UNC7eWZWvRyAPWUpIJicgZBWLNpkljMbgeaFVWU3QNmWgaibchc8aGFfAG7gWh7eghHSrtSuSqMDp2ibVnvE2eLJg/132","nickname":"Geek_a88948","note":"","ucode":"C7FF3099A180D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1247310,"avatar":"https://static001.geekbang.org/account/avatar/00/13/08/4e/79c3d903.jpg","nickname":"结冰的海","note":"","ucode":"B6ED66252803ED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350542,"discussion_content":"写时复制肯定有意义啊，首先它是os实现的，只要fork就会触发，代码是控制不了的，除非不fork。\n它的意义在于标记了主进程的修改内容。如果重写未完成，还是可以通过原先的aof日志恢复数据的。\n有个地方表述不准确，写时复制是谁写谁复制，申请内存是父进程申请的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613910084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326858,"ip_address":""},"score":350542,"extra":""}]},{"author":{"id":1682027,"avatar":"https://static001.geekbang.org/account/avatar/00/19/aa/6b/ab9a072a.jpg","nickname":"对与错","note":"","ucode":"EF55733E3BD78B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326613,"discussion_content":"请问，bgwriteaof子进程只是用来把键值数据库中的数据重写为操作指令，然后放到AOF重写日志中吗，这个子进程应该不会往AOF重写缓冲区里面加数据吧，等到重写完成之后，再把重写日志与重写缓冲区内的数据合并作为新的AOF日志，我这样理解是对的吗？还有子进程在重写期间不会因为父进程有新的写入操作，而拷贝出新的内存空间？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605626917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306695,"discussion_content":"大佬  问个问题，在看到 “就是指新的 AOF 重写日志。这个操作也会被写到  重写日志的缓冲区”，这块，这个缓冲区的大小有限制吗？如果没有限制，这块是不是不安全？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600350521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1436839,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ec/a7/7d44c655.jpg","nickname":"snailshen","note":"","ucode":"C4875C476649B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306497,"discussion_content":"还有一点可能导致阻塞，就是在rewrite完成时，主进程同步重写缓冲区数据到aof文件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600304326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1905996,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epeiaBa4BwckMyrWKLmIjx60xZWa9VIj4aXVsc3781TqG5psItqx0pDFovMyCjficwu8IcpqY30S4Kw/132","nickname":"zgsdr0620","note":"","ucode":"51B701AAEAFE77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306090,"discussion_content":"您好，看了您的回答收获很多，但是对1.b有一个疑问：\n在COW的时候，不是子进程真正的拷贝数据吗，父进程应该不会受到影响吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600166968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1905996,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epeiaBa4BwckMyrWKLmIjx60xZWa9VIj4aXVsc3781TqG5psItqx0pDFovMyCjficwu8IcpqY30S4Kw/132","nickname":"zgsdr0620","note":"","ucode":"51B701AAEAFE77","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306093,"discussion_content":"谁修改数据谁拷贝，所以才叫“写时复制”。","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1600167711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306090,"ip_address":""},"score":306093,"extra":""}]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305816,"discussion_content":"膜拜大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600090787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1588637,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/9d/877deaff.jpg","nickname":"zlyj","note":"","ucode":"5F9F2BD2475E11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302318,"discussion_content":"请问大佬，为什么要设置一个重写缓冲区，原来的缓冲区和重写缓冲区数据不是一致的吗，直接将原缓冲区的数据和并入新的aof文件不行吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598877879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1682027,"avatar":"https://static001.geekbang.org/account/avatar/00/19/aa/6b/ab9a072a.jpg","nickname":"对与错","note":"","ucode":"EF55733E3BD78B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1588637,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/9d/877deaff.jpg","nickname":"zlyj","note":"","ucode":"5F9F2BD2475E11","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325869,"discussion_content":"我觉得更多的可能是避免污染数据和锁竞争把","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605448745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302318,"ip_address":""},"score":325869,"extra":""},{"author":{"id":2370506,"avatar":"","nickname":"Geek_774ef4","note":"","ucode":"9838717F36D085","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1588637,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/9d/877deaff.jpg","nickname":"zlyj","note":"","ucode":"5F9F2BD2475E11","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334952,"discussion_content":"数据可能已经不一样了，原来的缓冲区在1秒之后写入到aof文件，清空了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608034534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302318,"ip_address":""},"score":334952,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1588637,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/9d/877deaff.jpg","nickname":"zlyj","note":"","ucode":"5F9F2BD2475E11","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338266,"discussion_content":"缓冲区的数据在内存中 , 刷盘一次就没了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609227580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302318,"ip_address":""},"score":338266,"extra":""}]},{"author":{"id":1059944,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2c/68/c299bc71.jpg","nickname":"天敌","note":"","ucode":"CD29A622197197","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301629,"discussion_content":"看完！mark!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598591040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207009,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/e1/e2cbb49b.jpg","nickname":"coding","note":"","ucode":"A4F2E63C601993","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300272,"discussion_content":"大佬能加个微信吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598007764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1207009,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/e1/e2cbb49b.jpg","nickname":"coding","note":"","ucode":"A4F2E63C601993","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300277,"discussion_content":"个人主页有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598009500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300272,"ip_address":""},"score":300277,"extra":""}]},{"author":{"id":1231549,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","nickname":"吃饭饭","note":"","ucode":"95CFA07CDA2957","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300246,"discussion_content":"我申请加大佬微信：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597998480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":8,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1231549,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","nickname":"吃饭饭","note":"","ucode":"95CFA07CDA2957","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300278,"discussion_content":"个人主页有。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598009513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300246,"ip_address":""},"score":300278,"extra":""}]},{"author":{"id":1446171,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/1b/5f38f9c1.jpg","nickname":"花落忆流年","note":"","ucode":"363E0547EA80E5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299926,"discussion_content":"你好，我对第二个回答有点疑问，如果共用一个日志那只要主线程写就够了，不存在竞争吧；而且所谓重写就是要使用一个新的重写日志先记录当前内容同时记录后续操作，好像也无法在一个日志里去完成吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597878214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1446171,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/1b/5f38f9c1.jpg","nickname":"花落忆流年","note":"","ucode":"363E0547EA80E5","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":299947,"discussion_content":"重写是在子进程做的，没办法在主进程做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597886767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299926,"ip_address":""},"score":299947,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1446171,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/1b/5f38f9c1.jpg","nickname":"花落忆流年","note":"","ucode":"363E0547EA80E5","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":338267,"discussion_content":"为了不阻塞, aof重写的实现原理是直接去遍历redis数据库全量数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609227638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299926,"ip_address":""},"score":338267,"extra":""}]},{"author":{"id":1218205,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/dlIBXlicZrol7KX8l8QQu7nUpYhpBP5YIIdXe8RliatHdPU4licxiboqjMjJbJSaUpmib1iaIarMlgrtxpRjgOd2WYLw/132","nickname":"小黑","note":"","ucode":"DCED6B71BE7687","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299446,"discussion_content":"aof重写的时候会额外占用内存吗，如果重写期间客户端没有任何写操作的话","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597683287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1218205,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/dlIBXlicZrol7KX8l8QQu7nUpYhpBP5YIIdXe8RliatHdPU4licxiboqjMjJbJSaUpmib1iaIarMlgrtxpRjgOd2WYLw/132","nickname":"小黑","note":"","ucode":"DCED6B71BE7687","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338268,"discussion_content":"会 , 重写时会遍历redis数据库全量数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609227669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299446,"ip_address":""},"score":338268,"extra":""}]},{"author":{"id":2058455,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/68/d7/29025f1f.jpg","nickname":"前方的灯有点弱","note":"","ucode":"5CEDBCF3DDC991","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299351,"discussion_content":"😭我太菜了，学习学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597665958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1411281,"avatar":"https://static001.geekbang.org/account/avatar/00/15/88/d1/43ebb68c.jpg","nickname":"一条有梦想的咸鱼","note":"","ucode":"15BA7CA2C08EFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299149,"discussion_content":"“但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间”\n这句话不是很明白，如果添加一个新的键值对，就不会分离吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597578262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1411281,"avatar":"https://static001.geekbang.org/account/avatar/00/15/88/d1/43ebb68c.jpg","nickname":"一条有梦想的咸鱼","note":"","ucode":"15BA7CA2C08EFF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299162,"discussion_content":"只会针对修改的数据重新分配内存。添加新的key，只有父进程分配新的内存空间，子进程无任何影响，也看不到这个key。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597582732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299149,"ip_address":""},"score":299162,"extra":""},{"author":{"id":1062070,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","nickname":"我的黄金时代","note":"","ucode":"D7825B45B372F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":299615,"discussion_content":"这个机制是os本身去控制的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597751746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299162,"ip_address":""},"score":299615,"extra":""},{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1062070,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","nickname":"我的黄金时代","note":"","ucode":"D7825B45B372F4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299620,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597753397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299615,"ip_address":""},"score":299620,"extra":""}]},{"author":{"id":1106238,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e1/3e/a617ae38.jpg","nickname":"每天一点点","note":"","ucode":"B4DFDA3200B452","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299011,"discussion_content":"你好，问个问题哈\n父线程数据修改时会触发cow机制，此时父子线程的数据会分离，分离的应该只是修改的数据吧，不应该是全部数据吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597508259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1106238,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e1/3e/a617ae38.jpg","nickname":"每天一点点","note":"","ucode":"B4DFDA3200B452","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299024,"discussion_content":"是，只有修改的才会分离。另外注意是父子进程，不是父子线程。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597535532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299011,"ip_address":""},"score":299024,"extra":""},{"author":{"id":1194177,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/c1/237a2113.jpg","nickname":"wakeeee","note":"","ucode":"F1A1D051AC6509","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":310800,"discussion_content":"多谢你的评论。我看了老师的这篇文章，心想子进程怎么可能完完整整的拷贝一份物理内存，那也太浪费硬件资源了，在评论区找到答案了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602050396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299024,"ip_address":""},"score":310800,"extra":""}]},{"author":{"id":1193052,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/5c/6b4757a0.jpg","nickname":"倪大人","note":"","ucode":"4798D69F3E86FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298400,"discussion_content":"课代表，求问一下“一个拷贝，两处日志”的问题。\n\n第二处日志，新的写操作会被写到重写日志的缓冲区，这儿的缓冲区指的是什么？按我猜想应该是某一处内存？缓冲区记录的是操作还是k，v数据呢？假设新写了多次，这个缓冲区只存数据最终状态还是记录每次操作？\n\n假设重写开始时内存中keyA值为valueA，然后新的写操作set keyA valueB，重写完成后新的aof日志里keyA的操作记录是两条还是一条？\n\n*^O^* 求解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597289552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1193052,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/5c/6b4757a0.jpg","nickname":"倪大人","note":"","ucode":"4798D69F3E86FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298405,"discussion_content":"两条，AOF记录的是每一次操作记录。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597291073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298400,"ip_address":""},"score":298405,"extra":""}]},{"author":{"id":2107689,"avatar":"https://static001.geekbang.org/account/avatar/00/20/29/29/7664ee1e.jpg","nickname":"Geek_988cd0","note":"","ucode":"1D74CBF3E8DD64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298221,"discussion_content":"b点,如果说每次都会申请复制内存,那不就变成了 &#34;多次拷贝&#34;,这样一来 重写缓冲的意义不就没了吗,相当于重开了一个redis,可以这样理解吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597221372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2107689,"avatar":"https://static001.geekbang.org/account/avatar/00/20/29/29/7664ee1e.jpg","nickname":"Geek_988cd0","note":"","ucode":"1D74CBF3E8DD64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298251,"discussion_content":"你再读一下理解理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597227907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298221,"ip_address":""},"score":298251,"extra":""}]},{"author":{"id":2107689,"avatar":"https://static001.geekbang.org/account/avatar/00/20/29/29/7664ee1e.jpg","nickname":"Geek_988cd0","note":"","ucode":"1D74CBF3E8DD64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298218,"discussion_content":"进程和线程更乱了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597220848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":9,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2107689,"avatar":"https://static001.geekbang.org/account/avatar/00/20/29/29/7664ee1e.jpg","nickname":"Geek_988cd0","note":"","ucode":"1D74CBF3E8DD64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298252,"discussion_content":"理一理，没那么难。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597227918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298218,"ip_address":""},"score":298252,"extra":""},{"author":{"id":2105175,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","nickname":"Geek_72b9a7","note":"","ucode":"4C26B79F9F15A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2107689,"avatar":"https://static001.geekbang.org/account/avatar/00/20/29/29/7664ee1e.jpg","nickname":"Geek_988cd0","note":"","ucode":"1D74CBF3E8DD64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298304,"discussion_content":"老师说rewriteaof是子进城，然后又说主线程。我也有点疑惑？？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597241991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298218,"ip_address":""},"score":298304,"extra":""},{"author":{"id":1016575,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/ff/00e7614e.jpg","nickname":"robyy","note":"","ucode":"773337C9942A7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2105175,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","nickname":"Geek_72b9a7","note":"","ucode":"4C26B79F9F15A9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345168,"discussion_content":"应该是子进程，提到了cow，资源/内存分离了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611675234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298304,"ip_address":""},"score":345168,"extra":""}]}]},{"had_liked":false,"id":241597,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1597367179,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"426799129483","product_id":100056701,"comment_content":"1，作者讲了什么？<br>本章讲了Redis两种持久化机制之一：AOF机制原理<br>aof日志记录了redis所有增删改的操作，保存在磁盘上，当redis宕机，需要恢复内存中的数据时，可以通过读取aop日志恢复数据，从而避免因redis异常导致的数据丢失<br><br>2，作者是怎么把这事给讲明白的？<br>（1）作者先讲述redis宕机会导致内存数据丢失，需要有一种机制在redis重启后恢复数据。<br>（2）介绍了AOF通过记录每一个对redis数据进行增删改的操作日志，可以实现这种功能<br>（2）介绍了AOF的运行机制，数据保存机制，以及由此带来的优点和缺点<br>3，为了讲明白，作者讲了哪些要点，有哪些亮点？<br>（1）亮点：记录操作的时机分为：“写前日志和写后日志”，这个是我之前所不知道的<br>（2）要点1：AOF是写后日志，这样带来的好处是，记录的所有操作命令都是正确的，不需要额外的语法检查，确保redis重启时能够正确的读取回复数据<br>（3）要点2：AOF日志写入磁盘是比较影响性能的，为了平衡性能与数据安全，开发了三种机制：①：立即写入②：按秒写入③：系统写入<br>（4）要点3：AOF日志会变得巨大，所以Redis提供了日志重整的机制，通过读取内存中的数据重新产生一份数据写入日志<br>4，对于作者所讲，我有哪些发散性的思考？<br>作者说系统设计“取舍”二字非常重要，这是我之前未曾意识到的。作者讲了fork子进程机制，是Linux系统的一个能力，在刘超的课中讲过，这鼓舞了我继续学习的信心<br>5，将来有哪些场景，我可以应用上它？<br>目前还没有机会直接操作生产的redis配置，但现在要学习，争取将来可以直接操作<br>","like_count":100,"discussions":[{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368111,"discussion_content":"课代表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1618569056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2739957,"avatar":"","nickname":"Geek_39299b","note":"","ucode":"908C2FC4DECD33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389805,"discussion_content":"非凡哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629435993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253310,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1f/be/551454e0.jpg","nickname":"zxy","note":"","ucode":"FFAA3F6667305D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359326,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616162585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244717,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1598630448,"is_pvip":false,"replies":[{"id":"90092","content":"有两个配置项在控制AOF重写的触发时机：<br>1. auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB<br>2. auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。<br><br>AOF文件大小同时超出上面这两个配置项时，会触发AOF重写。<br><br>也可以看下@GEEKBANG_3036760的留言","user_name":"作者回复","comment_id":244717,"uid":"1609687","ip_address":"","utype":1,"ctime":1598708018,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"383850719792","product_id":100056701,"comment_content":"什么时候会触发AOF 重写呢？","like_count":89,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504677,"discussion_content":"有两个配置项在控制AOF重写的触发时机：\n1. auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB\n2. auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。\n\nAOF文件大小同时超出上面这两个配置项时，会触发AOF重写。\n\n也可以看下@GEEKBANG_3036760的留言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598708018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244774,"user_name":"GEEKBANG_3036760","can_delete":false,"product_type":"c1","uid":1603105,"ip_address":"","ucode":"5E322DD05C7F12","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZ09TltdQiboR0kc1Kzp4X7ul2t01sWMG3cA7kT4X1Uvibes5bAEXx72veJ6uEMmUFq8FtEQvwl6FQ/132","comment_is_top":false,"comment_ctime":1598673120,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"285066514656","product_id":100056701,"comment_content":"为了减小aof文件的体量，可以手动发送“bgrewriteaof”指令，通过子进程生成更小体积的aof，然后替换掉旧的、大体量的aof文件。<br><br>也可以配置自动触发<br><br>　　1）auto-aof-rewrite-percentage 100<br><br>　　2）auto-aof-rewrite-min-size 64mb<br><br>　　这两个配置项的意思是，在aof文件体量超过64mb，且比上次重写后的体量增加了100%时自动触发重写。我们可以修改这些参数达到自己的实际要求","like_count":66},{"had_liked":false,"id":241111,"user_name":"徐鹏","can_delete":false,"product_type":"c1","uid":1221936,"ip_address":"","ucode":"B19B6EB7002231","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/30/4be78ce7.jpg","comment_is_top":false,"comment_ctime":1597194081,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"190575755105","product_id":100056701,"comment_content":"有几个问题想请教一下：<br>1、文中多处提到bgrewriteaof 子进程，这个有点迷糊，主线程fork出来的bgrewriteaof是子线程还是子进程？<br>2、AOF重写会拷贝一份完整的内存数据，这个会导致内存占用直接翻倍吗？<br>3、如果一个key设置了过期时间，在利用AOF文件恢复数据时，key已经过期了这个是如何处理的呢？","like_count":44,"discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298159,"discussion_content":"\n1、子进程\n2、不会一次性拷贝所有内存数据，而且采用写实复制机制来做\n3、AOF文件中key的过期时间会保存为绝对时间，在恢复时会以绝对的过期时间写入，如果key已经过期，redis不会分配内存空间","likes_number":61,"is_delete":false,"is_hidden":false,"ctime":1597206777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":2061660,"avatar":"","nickname":"Geek_121747","note":"","ucode":"8A7AD79B6F53F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":298176,"discussion_content":"写时复制机制（Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。","likes_number":46,"is_delete":false,"is_hidden":false,"ctime":1597210913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298159,"ip_address":""},"score":298176,"extra":""},{"author":{"id":2945981,"avatar":"","nickname":"Geek_37dde4","note":"","ucode":"E631E98D354A06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2061660,"avatar":"","nickname":"Geek_121747","note":"","ucode":"8A7AD79B6F53F5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557455,"discussion_content":"写时复制是利用了虚拟内存的页表, 最初内核做了一些设置, 让页表项指向和父进程相同的物理内存页, 然后将这些页面自身标记为只读. fork()之后, 内核捕获父进程或子进程对这些页面的修改意图, 并为将发生修改的页面创建物理拷贝, 然后将新的页面拷贝分配给内核捕获的进程, 对页表项做相应的调整. ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1647827545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298176,"ip_address":""},"score":557455,"extra":""},{"author":{"id":1122953,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/89/5757eb43.jpg","nickname":"XiaoYeGe","note":"","ucode":"F07027153B6971","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":570074,"discussion_content":"这位老哥有没有自己的博客?  可以关注一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651654172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298159,"ip_address":""},"score":570074,"extra":""}]},{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298130,"discussion_content":"1. 老师应该想表达是：主线程fork出来一个bgrewriteaof子进程，而该子进程只有一个线程","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1597201167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073236,"avatar":"https://static001.geekbang.org/account/avatar/00/10/60/54/b3eb605b.jpg","nickname":"阿牛","note":"","ucode":"DC8C189FCF3289","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358519,"discussion_content":"一定是进程，为了实现内存分离。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1615991040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","nickname":"Leon📷","note":"","ucode":"B9BBD1EFAAE5A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336458,"discussion_content":"内核中线程和进程没有太多本质区别，数据结构都差不多","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608600934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373196,"discussion_content":"是进程 建议查下linux 的man","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620649315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","nickname":"Leon📷","note":"","ucode":"B9BBD1EFAAE5A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336459,"discussion_content":"一个进程的main进程在内核都是表现为main线程的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608600969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241137,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1597200074,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"164805957322","product_id":100056701,"comment_content":"AOF工作原理：<br>1、Redis 执行 fork() ，现在同时拥有父进程和子进程。<br>2、子进程开始将新 AOF 文件的内容写入到临时文件。<br>3、对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。<br>4、当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。<br>5、搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。<br><br>试着讨论下留言童鞋的几个问题<br><br>一、其中老师在文中提到：“因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。”<br>这里面说到 “Redis 会把这个操作写到它的缓冲区，这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的”，其实对于有些人有理解起来可能不是那么好理解，因为写入缓冲区为什么还不都是数据；<br><br>我的理解其实这个就是写入缓冲区，只不过是由appendfsync策略决定的，所以说的不丢失数据指的是不会因为子进程额外丢失数据。<br><br>二、AOF重新只是回拷贝引用(指针)，不会拷贝数据本身，因此量其实不大，那写入的时候怎么办呢，写时复制，即新开辟空间保存修改的值，因此需要额外的内存，但绝对不是redis现在占有的2倍。<br><br>三、AOF对于过期key不会特殊处理，因为Redis keys过期有两种方式：被动和主动方式。<br>\t当一些客户端尝试访问它时，key会被发现并主动的过期。<br>\t<br>\t当然，这样是不够的，因为有些过期的keys，永远不会访问他们。 无论如何，这些keys应该过期，所以定时随机测试设置keys的过期时间。所有这些过期的keys将会从删除。<br>\t具体就是Redis每秒10次做的事情：<br>\t\t测试随机的20个keys进行相关过期检测。<br>\t\t删除所有已经过期的keys。<br>\t\t如果有多于25%的keys过期，重复步奏1.<br><br>至于课后问题，看了 @与路同飞 童鞋的答案，没有更好的答案，就不回答了","like_count":38,"discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298161,"discussion_content":"AOF中保存的过期时间是绝对时间，key在恢复时，如果发现已经过期，不会分配内存空间，不需要走一遍过期删除策略。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597207038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":298170,"discussion_content":"是的，Keys的过期时间使用Unix时间戳存储(从Redis 2.6开始以毫秒为单位)。这意味着即使Redis实例不可用，时间也是一直在流逝的。\n\n要想过期的工作处理好，计算机必须采用稳定的时间。 如果你将RDB文件在两台时钟不同步的电脑间同步，有趣的事会发生（可能所有的 keys装载时就会过期）。\n\n即使正在运行的实例也会检查计算机的时钟，例如如果你设置了一个key的有效期是1000秒，然后设置你的计算机时间为未来2000秒，这时key会立即失效，而不是等1000秒之后。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1597208886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298161,"ip_address":""},"score":298170,"extra":""}]},{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298172,"discussion_content":"Kaito关于课后问题的解答更棒������������������������","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597209128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":298256,"discussion_content":"感谢，一块进步。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597228146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298172,"ip_address":""},"score":298256,"extra":""}]},{"author":{"id":1121738,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/ca/6dd795d9.jpg","nickname":"小菜","note":"","ucode":"BC0A84C7055824","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396105,"discussion_content":"重写缓存写入新的AOF时会阻塞主线程的操作吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632393094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1389314,"avatar":"https://static001.geekbang.org/account/avatar/00/15/33/02/83f47bf9.jpg","nickname":"流沙","note":"","ucode":"6153686D1C34B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379255,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623773246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241169,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1597207299,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"78906618627","product_id":100056701,"comment_content":"问题一:在AOF重写期间，Redis运行的命令会被积累在缓冲区，待AOF重写结束后会进行回放，在高并发情况下缓冲区积累可能会很大，这样就会导致阻塞，Redis后来通过Linux管道技术让aof期间就能同时进行回放，这样aof重写结束后只需要回放少量剩余的数据即可<br><br>问题二：对于任何文件系统都是不推荐并发修改文件的，例如hadoop的租约机制，Redis也是这样，避免重写发生故障，导致文件格式错乱最后aof文件损坏无法使用，所以Redis的做法是同时写两份文件，最后通过修改文件名的方式，保证文件切换的原子性<br><br>这里需要纠正一下老师前面的口误，就是Redis是通过使用操作系统的fork()方式创建进程，不是线程，也由于这个原因，主进程和fork出来的子进程的资源是不共享的，所以也出现Redis使用pipe管道技术来同步主子进程的aof增量数据","like_count":18,"discussions":[{"author":{"id":2273076,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo1QZQ0eoOqvOyMyAzcsyEK8bQaZTd9aJHTTCYicicUm9gmhUFaxQe6IBc3caLVD8PhqtmhhicrNHe0w/132","nickname":"Severus4","note":"","ucode":"79BC6487B595EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373943,"discussion_content":"有个地方没理解，老师给的图，aof重写时主线程运行的命令被积累在缓冲区，同时又在aof重写的缓冲区也记录了一份，那么在aof重写结束后应该是用重写缓冲区进行回放的吗？可不可以直接用主线程的缓冲区进行回放？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620921061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1451391,"avatar":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","nickname":"曾轼麟","note":"","ucode":"D418371AC11270","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2273076,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo1QZQ0eoOqvOyMyAzcsyEK8bQaZTd9aJHTTCYicicUm9gmhUFaxQe6IBc3caLVD8PhqtmhhicrNHe0w/132","nickname":"Severus4","note":"","ucode":"79BC6487B595EE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385955,"discussion_content":"并不是不可以，但是同步是自上而下的，如果回到主现线程可能会导致，暂停写入，影响到主线程从而引起整个db的阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627360886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373943,"ip_address":""},"score":385955,"extra":""},{"author":{"id":1451391,"avatar":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","nickname":"曾轼麟","note":"","ucode":"D418371AC11270","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2273076,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo1QZQ0eoOqvOyMyAzcsyEK8bQaZTd9aJHTTCYicicUm9gmhUFaxQe6IBc3caLVD8PhqtmhhicrNHe0w/132","nickname":"Severus4","note":"","ucode":"79BC6487B595EE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385956,"discussion_content":"因为主从同步，本身也是有缓冲区的，在子线程能避免写入阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627360952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373943,"ip_address":""},"score":385956,"extra":""}]},{"author":{"id":1113597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","nickname":"注定非凡","note":"","ucode":"80673056E131B7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298552,"discussion_content":"条理清晰，厉害👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597323892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241265,"user_name":"D","can_delete":false,"product_type":"c1","uid":1027596,"ip_address":"","ucode":"5BB4D16FE39BFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/0c/f39f847a.jpg","comment_is_top":false,"comment_ctime":1597231583,"is_pvip":false,"replies":[{"id":"89348","content":"AOF的全称是Append Only File，表示文件只能追加写。 Redis记日志时，就是用追加写文件的方式记录写命令操作的。","user_name":"作者回复","comment_id":241265,"uid":"1609687","ip_address":"","utype":1,"ctime":1597595718,"user_name_real":"蒋德钧"}],"discussion_count":4,"race_medal":0,"score":"66021741023","product_id":100056701,"comment_content":"AOF 是什么的缩写， 还是说就是这个名字？","like_count":15,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503688,"discussion_content":"AOF的全称是Append Only File，表示文件只能追加写。 Redis记日志时，就是用追加写文件的方式记录写命令操作的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597595718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298818,"discussion_content":"Append Only File","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597410358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027596,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/0c/f39f847a.jpg","nickname":"D","note":"","ucode":"5BB4D16FE39BFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298792,"discussion_content":"最好能有一个缩略词表吧，专业一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597399973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1313894,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0c/66/7a2313ba.jpg","nickname":"ruier","note":"","ucode":"5AE3CA17CAE369","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298289,"discussion_content":"AOF 文件是一个只进行追加操作的日志文件（append only log）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597237087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241194,"user_name":"脱缰的野马__","can_delete":false,"product_type":"c1","uid":1447569,"ip_address":"","ucode":"D5F993E7232C61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","comment_is_top":false,"comment_ctime":1597212765,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"57431787613","product_id":100056701,"comment_content":"文章前面说到redo log日志记录的是修改后的数据，但是在丁奇老师的MySQL实战中讲解的是redo log记录是对数据的操作记录，修改后的数据是保存在内存的change buffer中的","like_count":13,"discussions":[{"author":{"id":2017580,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c9/2c/9ed40921.jpg","nickname":"BOB","note":"","ucode":"E86596709EAB1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346070,"discussion_content":"专门看了下，redolog记录的是“在某个数据页上做了什么修改”","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1611849331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1940831,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqFHleTqYES6pD8NVUaH6PHRY5fRYLfyC5t7RxicRnTjR4ge5W4fibawZ8Av5I5t4ib7kKFejicLuqJ0g/132","nickname":"温安适","note":"","ucode":"715F45EE02AC46","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337549,"discussion_content":"redo log是记录的对数据的操作记录，是物理日志，至于change buffer只有非唯一索引才可以使用","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1608971299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383412,"discussion_content":"或者是是想提 binlog 的 row 格式？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626084182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241241,"user_name":"Archer30","can_delete":false,"product_type":"c1","uid":2108687,"ip_address":"","ucode":"B4D74EFA7D3107","user_header":"https://static001.geekbang.org/account/avatar/00/20/2d/0f/a00f2a32.jpg","comment_is_top":false,"comment_ctime":1597222195,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"40251927859","product_id":100056701,"comment_content":"问题1回答：如果子进程写入事件过长，并且这段事件，会导致AOF重写日志，积累过多，当新的AOF文件完成后，还是需要写入大量AOF重写日志里的内容，可能会导致阻塞。<br><br>问题2回答：我觉得评论区里的大部分回答 防止锁竞争 ，应该是把问题理解错了，父子两个进程本来就没有需要竞争的数据，老师所指的两个日志应该是“AOF缓冲区”和&quot;AOF重写缓冲区&quot;，而不是磁盘上的AOF文件，之所有另外有一个&quot;AOF重写缓冲区&quot;，是因为重写期间，主进程AOF还在继续工作，还是会同步到旧的AOF文件中，同步成功后，“AOF缓冲区”会被清除，会被清除，会被清除！","like_count":9,"discussions":[{"author":{"id":1905996,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epeiaBa4BwckMyrWKLmIjx60xZWa9VIj4aXVsc3781TqG5psItqx0pDFovMyCjficwu8IcpqY30S4Kw/132","nickname":"zgsdr0620","note":"","ucode":"51B701AAEAFE77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306092,"discussion_content":"同意您的第二点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600167361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2131606,"avatar":"","nickname":"Geek_da4cfb","note":"","ucode":"DB59B24A249713","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376643,"discussion_content":"人家问的是 AOF日志为啥 不和重写AOF日志公用一个文件，非的另外创建一个文件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622251659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/61/8ad99e09.jpg","nickname":"刘百万","note":"","ucode":"692E23D070641A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372052,"discussion_content":"另外，重写开始时，aof 缓冲区如果有数据没有写入日志，子进程写完后，使用的缓冲区不对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620142213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1977474,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","nickname":"Reborn 2.0","note":"","ucode":"BA506E7455D91C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314693,"discussion_content":"所以是因为&#34;AOF缓冲区&#34;不够大, 不能保证重写时候的AOF日志都能放在缓冲里?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603186361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241134,"user_name":"扩散性百万咸面包","can_delete":false,"product_type":"c1","uid":1905171,"ip_address":"","ucode":"6D703D51553B42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","comment_is_top":false,"comment_ctime":1597199634,"is_pvip":false,"replies":[{"id":"89106","content":"主线程收到写命令后，会把这个写命令写入AOF重写缓冲区，这是由主线程来写的，所以连线在一起了：）<br><br>bgrewriteaof主要是写新日志的。","user_name":"作者回复","comment_id":241134,"uid":"1609687","ip_address":"","utype":1,"ctime":1597207380,"user_name_real":"蒋德钧"}],"discussion_count":3,"race_medal":0,"score":"40251905298","product_id":100056701,"comment_content":"图是不是画错了。为什么主线程和AOF重写缓冲连起来了呢？不是应该bgrewriteaof来写吗？","like_count":9,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503654,"discussion_content":"主线程收到写命令后，会把这个写命令写入AOF重写缓冲区，这是由主线程来写的，所以连线在一起了：）\n\nbgrewriteaof主要是写新日志的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597207380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2278542,"avatar":"https://static001.geekbang.org/account/avatar/00/22/c4/8e/89f8d85e.jpg","nickname":"笑 容","note":"","ucode":"9E72450E9719ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320792,"discussion_content":"“bgrewriteaof主要是写新日志的”，新的重写日志就是从AOF重写缓存中出来的啊，不就是由bgrewiteaof进程来做的吗，主线程不是不参与重写的工作嘛。懵了我。。。。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604478890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1682027,"avatar":"https://static001.geekbang.org/account/avatar/00/19/aa/6b/ab9a072a.jpg","nickname":"对与错","note":"","ucode":"EF55733E3BD78B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2278542,"avatar":"https://static001.geekbang.org/account/avatar/00/22/c4/8e/89f8d85e.jpg","nickname":"笑 容","note":"","ucode":"9E72450E9719ED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325880,"discussion_content":"重写日志在重写没有完成之前是不会被&#34;发现&#34;的，所以子进程只需要把重写的命令写到重写日志上面，重写缓冲区是用来记录主进程变更操作的命令","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1605451685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320792,"ip_address":""},"score":325880,"extra":""}]}]},{"had_liked":false,"id":289685,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1619143732,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"35978882100","product_id":100056701,"comment_content":"Always，everysec，No，这三种模式就是 CAP 理论的体现。","like_count":8,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388266,"discussion_content":"大佬，ca还好理解，这个p咋理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628674325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373233,"discussion_content":"大佬，又看见你了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620656304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1123163,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","nickname":"悟空聊架构","note":"","ucode":"C2F482A0CF8AF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373293,"discussion_content":"后面还有哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620692340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373233,"ip_address":""},"score":373293,"extra":""}]}]},{"had_liked":false,"id":241282,"user_name":"ruier","can_delete":false,"product_type":"c1","uid":1313894,"ip_address":"","ucode":"5AE3CA17CAE369","user_header":"https://static001.geekbang.org/account/avatar/00/14/0c/66/7a2313ba.jpg","comment_is_top":false,"comment_ctime":1597237155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31662008227","product_id":100056701,"comment_content":"有个Django写的Redis管理小系统，有兴趣的朋友可以看一看，名字叫repoll<br>https:&#47;&#47;github.com&#47;NaNShaner&#47;repoll","like_count":7},{"had_liked":false,"id":252500,"user_name":"Daiver","can_delete":false,"product_type":"c1","uid":1466447,"ip_address":"","ucode":"9B1A03AFBC79BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","comment_is_top":false,"comment_ctime":1602320399,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27372124175","product_id":100056701,"comment_content":"AOF重写过程，主线程接收到了新的请求，并将日志写入缓冲区，如果宕机了，缓冲区的内容还是会丢失的。子进程在写日志时，重写缓冲区也是可能会丢失的，为啥说AOF日志还是齐全的，怎么可以用于恢复呢？","like_count":6,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388263,"discussion_content":"我觉得老师的意思是aof日志是相对齐全的，比如用了always策略，即使常用的everysec策略丢失的也是最多2s的数据，既然选择说明是可以容忍的。至于aof重写，即使失败了，删掉文件，再来一次又有何妨","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628673721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245968,"user_name":"Java垒墙工程师","can_delete":false,"product_type":"c1","uid":1937062,"ip_address":"","ucode":"E76AE44A9C76AE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","comment_is_top":false,"comment_ctime":1599122835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27368926611","product_id":100056701,"comment_content":"试听完了，彻底入坑","like_count":6},{"had_liked":false,"id":241095,"user_name":"与路同飞","can_delete":false,"product_type":"c1","uid":1138821,"ip_address":"","ucode":"2985F1440A1962","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","comment_is_top":false,"comment_ctime":1597190784,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"23072027264","product_id":100056701,"comment_content":"1.子线程重新AOF日志完成时会向主线程发送信号处理函数，会完成 （1）将AOF重写缓冲区的内容写入到新的AOF文件中。（2）将新的AOF文件改名，原子地替换现有的AOF文件。完成以后才会重新处理客户端请求。<br>2.不共享AOF本身的日志是防止锁竞争，类似于redis rehash。","like_count":5,"discussions":[{"author":{"id":1138821,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","nickname":"与路同飞","note":"","ucode":"2985F1440A1962","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298321,"discussion_content":"写错了，子进程，主进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597244666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2105175,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","nickname":"Geek_72b9a7","note":"","ucode":"4C26B79F9F15A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298309,"discussion_content":"重写会发生rehash吗 ？老师第二节课也讲了这个rehash.  没说具体发生于何时？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597243428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2105175,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","nickname":"Geek_72b9a7","note":"","ucode":"4C26B79F9F15A9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393084,"discussion_content":"触发条件有俩，评论区提了 第一个是key的个数大于桶数，且不在bgsave和rewrite的时候会触发。第二是key个数大于5倍桶数了，立马触发了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631242217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298309,"ip_address":""},"score":393084,"extra":""}]},{"author":{"id":2113159,"avatar":"","nickname":"Geek_beaeab","note":"","ucode":"651B07865D3208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298147,"discussion_content":"个人觉得不共享还有一个原因是防止重复写入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597203861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2113159,"avatar":"","nickname":"Geek_beaeab","note":"","ucode":"651B07865D3208","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393085,"discussion_content":"如果共享的话，个人觉得没必要两份了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631242266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298147,"ip_address":""},"score":393085,"extra":""}]},{"author":{"id":1905171,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","nickname":"扩散性百万咸面包","note":"","ucode":"6D703D51553B42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298128,"discussion_content":"AOF重写不是由后台线程完成的吗？怎么又是主线程写入了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597199108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249905,"user_name":"杨小羊快跑","can_delete":false,"product_type":"c1","uid":1489392,"ip_address":"","ucode":"FBD7BDDA499B0F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIL1K9WKIkvsdWBwthxz7M08hvqrbeibtzq9rKreZ8wEtHJa2F6x8C1f0dicibMOH6FUW2ayrBYlsEqQ/132","comment_is_top":false,"comment_ctime":1600847699,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18780716883","product_id":100056701,"comment_content":"开启AOF，有可能导致Redis hang住。日志里也有体现：Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis <br>主要原因：Linux规定执行write(2)时，如果对同一个文件正在执行fdatasync(2)将kernel buffer写入物理磁盘，或者有system wide sync在执行，write(2)会被Block住，整个Redis被Block住。（注：Redis处理完每个事件后都会调用write(2)将变化写入kernel的buffer）","like_count":4,"discussions":[{"author":{"id":2172420,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/r2nR7Zkl5RP7LobsNKJ6wmmtyXrh4alNSAOldx1y1PSeFB1J2I14HE4I0BCgicPhubIOibPZAENzEpHEWTFjMNqg/132","nickname":"董董","note":"","ucode":"C222E275545158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334556,"discussion_content":"赞，解决了我的为什么aof会阻塞主线程，刚开始我以为主线程不是将操作后的语句写入aof缓存就可以了么，为什么还会进行阻塞，原来要和操作系统内核有关了「简单来说就是fsync的时候write操作会被阻塞」","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607881274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388270,"discussion_content":"感觉这是针对文件的防止文件并发写问题，应该不包含缓存区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628675380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241112,"user_name":"Anony","can_delete":false,"product_type":"c1","uid":1174733,"ip_address":"","ucode":"4B7D06B8C7BFD3","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/cd/52753b9e.jpg","comment_is_top":false,"comment_ctime":1597194247,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18777063431","product_id":100056701,"comment_content":"上节说redis单线程处理网络IO和键值对的读写，持久化是由额外线程处理的。那AOF由额外线程处理的话，为什么会影响主线程呢？和主线程之间是什么关系？","like_count":4,"discussions":[{"author":{"id":1118627,"avatar":"https://static001.geekbang.org/account/avatar/00/11/11/a3/7a2405ca.jpg","nickname":"rfyiamcool","note":"","ucode":"65FCBF05B13893","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374650,"discussion_content":"Aof的每次机制是同步写的的，也就是fsyncdata。每秒机制的话利用了操作系统的buffer io来写数据，看起来是异步，然后由bio线程来fsync，但如果磁盘繁忙，你的写请求多的话，你的主线程write会被操作系统阻塞触发fsync同步操作。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621302384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388265,"discussion_content":"aof的缓存是由主线程写的，表面上除了always策略都和主线程无关了，实际上正是因为有了缓存的关联，如果同步线程处理不及时，缓存区堆积大量数据，为了保证缓存数据的完整性主线程会被阻塞写入，导致影响到主线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628674191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298166,"discussion_content":"抛开这个不说，两个进程也是可以相互影响的，比如竞争机器资源。锁等待什么的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597208031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313316,"user_name":"随机漫步的傻瓜","can_delete":false,"product_type":"c1","uid":2762186,"ip_address":"","ucode":"FBEFB27BF45ED4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/25/ca/96734ade.jpg","comment_is_top":false,"comment_ctime":1632374015,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14517275903","product_id":100056701,"comment_content":"感觉老师没有刻意把进程和线程分的特别清楚","like_count":3},{"had_liked":false,"id":288625,"user_name":"连长","can_delete":false,"product_type":"c1","uid":2047980,"ip_address":"","ucode":"555BD3DE57887F","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3f/ec/00904faa.jpg","comment_is_top":false,"comment_ctime":1618565683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10208500275","product_id":100056701,"comment_content":"AOF持久化机制<br>1、不进行数据校验，直接操作内存，成功后记录日志；<br>2、主线程把日志记录到AOF缓存区中，不进行持久化磁盘。<br><br>刷盘策略，都由子线程执行<br>1、Always，每执行一条写入操作，刷新缓存区到磁盘；<br>2、Everysec，每秒刷新缓存区到磁盘；<br>3、No，由操作系统决定何时将缓存区内存写回磁盘。<br>三种写回策略都有可能导致数据丢失<br><br>AOF重写<br>1、一个拷贝，两处日志；<br>2、bgrewriteaof子进程，复制内存数据，把内存数据写入重写日志；<br>3、AOF重写缓存，保证数据一致；<br>4、替换AOF日志，完成重写。","like_count":2},{"had_liked":false,"id":283831,"user_name":"pippin","can_delete":false,"product_type":"c1","uid":1784022,"ip_address":"","ucode":"F7619FCE24D481","user_header":"","comment_is_top":false,"comment_ctime":1615949770,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10205884362","product_id":100056701,"comment_content":"想知道，停电会导致aof日志损坏，需要使用redis-check-aof修复，在哪个环节会导致aof日志损坏","like_count":2,"discussions":[{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366103,"discussion_content":"在写命令的时候，可能只写了一半，然后断电了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617960169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273131,"user_name":"CityAnimal","can_delete":false,"product_type":"c1","uid":1139902,"ip_address":"","ucode":"206491F70572AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/64/be/12c37d15.jpg","comment_is_top":false,"comment_ctime":1610450388,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10200384980","product_id":100056701,"comment_content":"笔记打卡<br><br>    * [ ] 原理<br>        * [ ] 写后日志<br>            * [ ] 好处：<br>                * [ ] 避免出现记录错误命令的情况<br>                * [ ] 不会阻塞当前的写操作<br>            * [ ] 风险<br>                * [ ] 执行完命令后宕机 =&amp;gt; 数据丢失<br>                * [ ] 给下一个操作带来阻塞风险<br>                    * [ ] AOF 日志也是在主线程中执行的<br>        * [ ] 内容：收到的每一条命令，以文本形式保存<br>            * [ ] 命令：set testkey testvalue<br>            * [ ] aof: *3\\n$3\\nset\\n$7\\ntestkey\\n$9\\ntestvalue<br>                * [ ] *3 : 当前命令有三个部分<br>                * [ ] 每部分都是由“$+数字”开头，后面紧跟着具体的命令、键或值<br>    * [ ] 写回策略 &amp;lt;= 配置项 appendfsync<br>        * [ ] Always(同步写回)<br>            * [ ] 基本不丢数据<br>            * [ ] 影响主线程性能<br>        * [ ] Everysec(每秒写回)<br>            * [ ] 性能适中<br>            * [ ] 如果发生宕机，上一秒内未落盘的命令操作仍然会丢失<br>        * [ ] No(操作系统控制的写回)<br>            * [ ] 性能好<br>            * [ ] 一旦宕机前AOF 记录没有落盘，对应的数据就丢失了<br>    * [ ] AOF 文件过大<br>        * [ ] 性能问题<br>            * [ ] 文件系统对文件大小有限制<br>            * [ ] 追加命令记录效率低<br>            * [ ] 故障恢复非常缓慢<br>        * [ ] 方案：AOF 重写机制<br>            * [ ] 原理：根据redis的现状创建一个新的 AOF 文件<br>            * [ ] !!! 非常耗时 (不阻塞主线程)<br>                * [ ] 由后台子进程 bgrewriteaof 来完成的<br>                * [ ] 一个拷贝<br>                    * [ ] 主线程 fork 出 bgrewriteaof 子进程，并将内存拷贝给 bgrewriteaof<br>                * [ ] 两处日志<br>                    * [ ] 正在使用的 AOF 日志<br>                    * [ ] 新的 AOF 重写日志","like_count":2},{"had_liked":false,"id":263403,"user_name":"永远的草莓地","can_delete":false,"product_type":"c1","uid":1034001,"ip_address":"","ucode":"D4BD8DD42350CC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/11/89ba9915.jpg","comment_is_top":false,"comment_ctime":1606125629,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"10196060221","product_id":100056701,"comment_content":"redis AOF  appendfsync 选择 always 模式时，是等 fsync 完成之后，才返回成功，还是说先返回成功，之后 再 fsync ？","like_count":2,"discussions":[{"author":{"id":2933797,"avatar":"","nickname":"Geek_8b0800","note":"","ucode":"09D9692B62A691","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586915,"discussion_content":"根据《Redis设计与实现》里的伪代码是：先返回，再执行 write、fsync","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662607757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387074,"discussion_content":"老师这块讲错了。\n简单说一下：命令执行后只是写入 aof_buff。Redis 在主事件循环里，会先执行一个函数。这个函数检查 aof_buff，如果有数据且为 Always 策略，则写入磁盘。这个函数执行完成后，才会执行其它函数，包括命令请求。\n所以，当 AOF 回写策略为 Always 时，服务器宕机，会丢失一个事件周期的命令数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627975069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388274,"discussion_content":"按原子性来理解，这种不算成功操作，数据丢失是应该的。侧面也可以回答上面那个同学问题等 fsync 完成之后，才返回成功","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628675864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":387074,"ip_address":""},"score":388274,"extra":""}]},{"author":{"id":2104255,"avatar":"https://static001.geekbang.org/account/avatar/00/20/1b/bf/48de2ca3.jpg","nickname":"脚踏实地，砥砺前行","note":"","ucode":"273EAD9741748D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348415,"discussion_content":"我也很好奇，有没有哪位大神可以恢复下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612538765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241827,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1597460015,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10187394607","product_id":100056701,"comment_content":"老师好，本文循序渐进，线路清晰，实属深度好文，但如“AOF非阻塞的重写过程”图，有几个问题，望回复，谢谢。<br>1、如果写回策略是Always，是没有AOF缓冲的。是怎么做AOF重写呢？<br>2、图右边部分有四个日志：两个日志，两个重写日志，请问“一个拷贝，两个日志”中的“日志”是指四个中的哪两个？<br>3、aof缓冲没有线连到最下面的磁盘吗？","like_count":2,"discussions":[{"author":{"id":2903968,"avatar":"","nickname":"Geek_9e1c1a","note":"","ucode":"A79B61F7118DF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576622,"discussion_content":"1、如果是Always写回策略，是没有AOF缓冲的，需要马上写回到磁盘中，这个时候如果需要写入的数据过多，会阻塞主进程的执行。如果是EverySecond和NO策略都是有缓冲的，这个时候有可能宕机，丢失数据了。\n2、Redis的重写根本就是为了减少AOF日志文件的大小，同时不能对主进程有过多的阻塞，这个时候fork一个子进程，子进程就会将重写后的数据写入新的AOF日志文件中，那在重写的过程中，Redis会把新命令存储到AOF重写缓冲区，当子进程中重写完成之后，就会读取AOF重写缓冲区的内存追加到新的AOF文件中，此时AOF重写完成之后，旧的AOF就会被替换。\n注意在AOF重写的过程中，新的写请求过来，还是会往原来的AOF日志中写入的，主要是防止AOF重写失败(防止宕机后重写缓冲区的数据丢失），而不会影响AOF日志数据的丢失。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655707264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388275,"discussion_content":"第一个问题 应该是有缓存的，不过是被主线程立刻执行了。两个日志应该是aof日志和aof重新日志","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628676035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241587,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1597366173,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"10187300765","product_id":100056701,"comment_content":"appendfsync: no 是系统控制进行写磁盘，这里是利用文件系统的机制吗？ 如果是利用的文件系统的哪个功能， 一般多久进行持久化写磁盘呢？","like_count":2},{"had_liked":false,"id":316324,"user_name":"明人不做暗事","can_delete":false,"product_type":"c1","uid":2805682,"ip_address":"","ucode":"10D845C54312C8","user_header":"https://static001.geekbang.org/account/avatar/00/2a/cf/b2/2a124ccc.jpg","comment_is_top":false,"comment_ctime":1634269983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5929237279","product_id":100056701,"comment_content":"在AOF重写的时候，父进程仍然在进行写入命令，且更新第一个AOF日志。<br>当子进程AOF重写，已经将testkey1写入到新的AOF文件中了，此时父进程又开始执行 变更 testkey1 对应的 value。那么最终 旧的AOF文件 会有此记录，但新的AOF日志文件又是如何将这些记录整合在一起呢？","like_count":1},{"had_liked":false,"id":289160,"user_name":"jzdayz","can_delete":false,"product_type":"c1","uid":1259280,"ip_address":"","ucode":"E84C0DFC53BE8A","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/10/a8aa9acb.jpg","comment_is_top":false,"comment_ctime":1618898919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5913866215","product_id":100056701,"comment_content":"fork子进程。新增一个aof日志<br>父进程继续处理redis的相关事务，然后写入原来的aof(aof-source)和新的aof(aof-new)<br>子进程对aof-new进行重写压缩，最后替换原本的aof-source<br><br>问题:<br>aof-source和aof-new都是文件吗？<br><br>子进程和父进程都会对aof-new进行处理，这样不会出错吗？<br><br>最后在父进程一直进行写入aof-new的情况下，子进程的压缩是会残缺一部分的是吧？例入aof-source记录了10条记录，此时进行重写，aof-new也有10条记录，子进程对这十条记录进行压缩，此时redis受到命令，此时写入aof-new和aof-source，此时子进程压缩的还是原本的10条？还是说重新对11条命令进行压缩？","like_count":1},{"had_liked":false,"id":289136,"user_name":"Geek_77a14f","can_delete":false,"product_type":"c1","uid":2116919,"ip_address":"","ucode":"EB71258E219A6D","user_header":"","comment_is_top":false,"comment_ctime":1618886223,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5913853519","product_id":100056701,"comment_content":"如果文件太大，之后再往里面追加命令记录的话，效率也会变低？<br>这个是什么原因？磁盘寻道时间拉长？","like_count":1,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388272,"discussion_content":"应该是，毕竟打开一个超大文件也是很卡的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628675493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283946,"user_name":"阿牛","can_delete":false,"product_type":"c1","uid":1073236,"ip_address":"","ucode":"DC8C189FCF3289","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/54/b3eb605b.jpg","comment_is_top":false,"comment_ctime":1615992231,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5910959527","product_id":100056701,"comment_content":"【每日打卡】<br>今天主要讲的是Redis持久化AOF机制。<br>Redis持久化两大机制：AOF（Append Only File）日志和 RDB 快照。<br>AOF是先redis先执行操作，在将日志保存到磁盘中。<br>AOF两大好处：<br>1、避免出现记录错误命令的情况；<br>2、它是在命令执行后才记录日志，所以不会阻塞当前的写操作。；<br>AOF两大风险：<br>1、还没有来得及记日志就宕机，命令和相应数据就丢失了；<br>2、日志写入磁盘，影响后续AOF落盘操作；<br>[重点]AOF的工作原理：<br>1、Redis 执行 fork() ，现在同时拥有父进程和子进程。<br>2、子进程开始将新 AOF 文件的内容写入到临时文件。<br>3、对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。<br>4、当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将AOF重写缓存中的内容全部写入到新的AOF文件中。<br>5、对新的AOF文件进行改名，原子的覆盖原有的AOF文件；完成新旧两个AOF文件的替换。<br>额外收获：<br>写时复制机制（Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。","like_count":1},{"had_liked":false,"id":282480,"user_name":"Fly^O^Tian","can_delete":false,"product_type":"c1","uid":2029875,"ip_address":"","ucode":"FC15E524AC9159","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f9/33/1c8df42c.jpg","comment_is_top":false,"comment_ctime":1615272989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5910240285","product_id":100056701,"comment_content":"AOF日志总结<br>1.写后日志，写将数据写入到内存，然后在记录日志。日志记录的是操作命令。因为redis执行过的命令是已经检查过的正确命令，所以避免了错误命令的情况<br>2.三种写回策略。<br>always 总是同步写回日志，可靠性高，性能影响大<br>everysec 每秒写回，会丢失部分数据 ，性能适中<br>no 由操作系统控制写回，性能高，丢失数据多<br>3.AOF重写<br>由于操作系统文件大小限制，并且文件过大影响写入性能，会在这时重写日志，重写日志由子进程完成<br>会将redis数据拷贝一份到子进程，主线程的操作会同时写aof日志和aof重写日志，拷贝完成后新日志替代旧的日志","like_count":1},{"had_liked":false,"id":268764,"user_name":"陈大头","can_delete":false,"product_type":"c1","uid":1335400,"ip_address":"","ucode":"F1CA8837BF1E5C","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/68/626cb455.jpg","comment_is_top":false,"comment_ctime":1608343373,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5903310669","product_id":100056701,"comment_content":"我想问一下那个Everysec也是主线程去处理的吗？那一秒写入多个命令，如果遇到bigkey，是不是一样有可能有阻塞风险","like_count":1,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388273,"discussion_content":"只有always是主线程处理的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628675599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373200,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620649974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267033,"user_name":"main","can_delete":false,"product_type":"c1","uid":1293581,"ip_address":"","ucode":"9E0B806245F11E","user_header":"https://static001.geekbang.org/account/avatar/00/13/bd/0d/f4799191.jpg","comment_is_top":false,"comment_ctime":1607577213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5902544509","product_id":100056701,"comment_content":"老师没有提到在重写时候，父进程其实是通过pipe管道将重写时候的差异数据写到子进程的，子进程会受到pipe管道的差异数据，然后再追加到新的aof中，在子进程完成重写后，父进程的差异数据会非常小的，这样父进程再次将差异数据追加进aof中就不会导致长时间阻塞了","like_count":1},{"had_liked":false,"id":266848,"user_name":"周星平","can_delete":false,"product_type":"c1","uid":1494880,"ip_address":"","ucode":"1FDCB487392B03","user_header":"https://static001.geekbang.org/account/avatar/00/16/cf/60/9100ad4f.jpg","comment_is_top":false,"comment_ctime":1607505469,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5902472765","product_id":100056701,"comment_content":"https:&#47;&#47;www.pianshen.com&#47;article&#47;1391301224&#47;这个讲重写aof很清楚","like_count":1,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338255,"discussion_content":"博文是<<Redis设计与实现>>书里面的内容,一模一样推荐直接看书吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609224619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249641,"user_name":"萧","can_delete":false,"product_type":"c1","uid":1229143,"ip_address":"","ucode":"0C2239867AFF5F","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/57/27de274f.jpg","comment_is_top":false,"comment_ctime":1600738448,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"5895705744","product_id":100056701,"comment_content":"### Redis持久化之AOF日志<br>AOF日志是写后日志：先执行命令，数据写入内存，在写日志，记录的是操作命令<br>为了避免额外的命令检查开销，确认名字正确且成功执行后写AOF日志，避免记录错误命令；也不会阻塞当前写操作<br><br>AOF日志三种写回策略：<br>- Always 同步写回：一操作一写，慢落盘操作，影响性能<br>- Everysec 每秒写回：一秒一写，中和上下两种写回，性能适中，可能丢失一秒数据<br>- No 操作系统控制写回：写入内存缓冲区，由操作系统控制写磁盘，性能好，有数据丢失的可能性<br><br>AOF大文件的AOF重写：将多条命令合并为一条命令；使用另外的后台进行操作；重写时拷贝旧AOF文件，进行操作，新的操作同时写入新旧文件，完成后新旧交替","like_count":1},{"had_liked":false,"id":241753,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1597410478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892377774","product_id":100056701,"comment_content":"aof重写，我理解按如下操作也行：<br><br>bgrewriteaof线程直接操作磁盘的aof文件，主线程还是写原来的缓存。","like_count":1},{"had_liked":false,"id":241178,"user_name":"秋梵","can_delete":false,"product_type":"c1","uid":1464835,"ip_address":"","ucode":"129DA4E9886D2E","user_header":"https://static001.geekbang.org/account/avatar/00/16/5a/03/b27f72b6.jpg","comment_is_top":false,"comment_ctime":1597209031,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"5892176327","product_id":100056701,"comment_content":"老师我有个问题想问。文章里说，在子进程进行重写期间，如果有新的写操作，Redis 会把这个操作写到它的缓冲区。但是缓冲区也是存在内存中的，如果宕机，内存的数据会丢失，新的写操作同样会丢失，这样的话要怎么保证AOF的日志操作是齐全的？","like_count":1,"discussions":[{"author":{"id":1182802,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","nickname":"长脖子树","note":"","ucode":"D9090EF67EEB1B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309776,"discussion_content":"这篇文章中的图有问题\nfork 出子进程之后, 新增加的数据并不只放在 AOF 重写缓存 中,  AOF 原文件日志也会同时写入, 这样做的好就是 尽可能减少在宕机时的数据丢失\n而且进程间是内存隔离的, 子进程是拿不到AOF重写缓存, 那怎么保证数据一致呢?\n当子进程完成 AOF 重写之后, 它会向父进程发送一个完成信号，父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作：\n1. 将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。\n2. 对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。\nhttps://redisbook.readthedocs.io/en/latest/internal/aof.html","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1601435040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307441,"discussion_content":"\n不知道我这样说的对不对。 appendfsync设置的是always，就是同步写回，在bgrewriteaof子进程重写日志时，如果有日志数据写入，主进程还是直接同步将操作写回原来的日志文件，而在bgrewriteaof子进程中是没有这份数据的，主进程是开了一片缓存区保存这份数据的，在bgrewriteaof子进程重写日志完成，再将这份缓存写入新的日志文件中，最后替换掉原来的日志文件。如果在重写日志时宕机，日志文件还是原来那个。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1600651542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1145779,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7b/b3/194f7f90.jpg","nickname":"没伞的孩子得使劲奔跑","note":"","ucode":"D015B4EF12E536","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338015,"discussion_content":"应该是这个道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609153682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307441,"ip_address":""},"score":338015,"extra":""},{"author":{"id":1344535,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOn7k48KXia5rf0eXpzv2EGtqGibz3eNb8QnL8X72uia0g1rBwzXef4dV2JEdz3r4bu9GC1FLIeic4UA/132","nickname":"Lee","note":"","ucode":"6B8D59A0B1A1A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393230,"discussion_content":"不是简单的替换吧，子进程中的日志是全量的，缓存中是增量的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631321817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307441,"ip_address":""},"score":393230,"extra":""}]},{"author":{"id":1797149,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6c/1d/3e834742.jpg","nickname":"Mr.Cool","note":"","ucode":"1347C0F297F0B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302259,"discussion_content":"追问+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598861700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241173,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1597208042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892175338","product_id":100056701,"comment_content":"1.fork时候的开销<br>2.如果使用同一个文件会需要有文件锁的竞争","like_count":1},{"had_liked":false,"id":241159,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1597204855,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5892172151","product_id":100056701,"comment_content":"提问：<br>1. 一个拷贝：拷贝是当前redis实例中所有的键值对吗？<br>2. &quot;第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。&quot;<br>这里描述得不准确吧？操作记录写到缓存中，宕机也是会丢失的，正在使用的AOF日志也无法保证记录不丢失<br><br>3.1 拷贝数据的操作记录重写完成后，发生在拷贝数据后的那些最新操作 才会被写入新AOF文件中，这两个动作是串行的？<br>3.2 如果拷贝数据的操作记录尚未完成，redis重启了，应该同样会发生记录丢失吧<br>3.3 当两处日志 都存在时，redis从哪份AOF日志恢复？<br>3.4 AOF日志重写 只在AOF足够大时才触发？还是一旦开启AOF持久化功能，就会同时进行重写？<br><br>4. 如果AOF日志损坏了，redis实例重启恢复会怎样呢？<br>5. 不管采用怎样的持久化方案，想保证缓存中 数据不丢失是不可能，毕竟存在各种各样的异常，感觉如果redis作为数据库使用，只适用于 允许部分数据丢失 的应用场景。是这样吗？","like_count":1,"discussions":[{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298306,"discussion_content":"1. 暂未想出来\n\n自我解答：\n2. 答：这里写的缓冲区，是要追加至重写日志的写入命令，因此正在使用的日志是最新最全的\n\n3.1 答：查阅Redis官方文档：子进程完成重写后，向父进程发送重写完成信号，由父进程将最新操作追加至新AOF文件\n3.2 答：此时只会造成重写失败，Redis会从现有的AOF日志恢复数据\n3.3 答：Redis的文件替换是原子操作，用于恢复的文件只有一份\n3.4 答：重写机制的引入，就是为了解决AOF文件过大导致的性能问题，猜测应该是文件过大时，触发重写\n\n4.答：Redis提供工具用于恢复的\n5.答：这得看Redis的应用场景：\n用作缓存，缓存丢失，可以从关系型数据库恢复，因此系统设计需要考虑缓存数据丢失，如何从数据库恢复。\n用作数据库，把Redis当做数据库，必须得使用磁盘持久化机制才行，从以上的学习中了解到AOF存在一定的数据丢失风险","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597242559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074742,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/36/b4a4e6fb.jpg","nickname":"Edon du","note":"","ucode":"1648624751AAE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360632,"discussion_content":"一个拷贝：指的是fork子进程，copy的是当前redis实例内存中存储的最新的值，但不是真正的开辟一份内存copy内存的数据，而是copy主线程内存值地址的映射表，可以理解为多了一个内存指针。\n这个copy的过程中主线程是不能操作的，当copy完成后，主线程仍然会有数据更新操作流入，这时候，主线程需要开辟额外的内存空间来维护这个key，子进程用来重写AOF就行了，我是这么理解的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616494326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241143,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1597200948,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5892168244","product_id":100056701,"comment_content":"解答：<br>1. 存在阻塞风险，fork进程相对而言是一个比较慢的操作，而且存在大片的内存拷贝，这会影响到主线程的请求处理性能<br>2. 共享的话，两个进程会读写同一个文件。如果不增加进程锁的话，多个进程写日志的时序无法保证；而加锁，又会影响到各自的写日志效率，且会影响主线程的请求处理性能","like_count":1,"discussions":[{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301924,"discussion_content":"几节课的问题看下来，深感自己对于操作系统的知识理解不够透彻，因此在分析问题时只停留在表面，不够深入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598709613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241105,"user_name":"1900","can_delete":false,"product_type":"c1","uid":1105774,"ip_address":"","ucode":"320D65D14817D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/df/6e/267bd6ee.jpg","comment_is_top":false,"comment_ctime":1597193253,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"5892160549","product_id":100056701,"comment_content":"“而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。”<br><br>缓冲区本质上也是内存，宕机后内存中的数据都会丢失吧？为啥写入缓冲区就不会丢了？","like_count":1,"discussions":[{"author":{"id":1444698,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","nickname":"C.","note":"","ucode":"5AE269220EFD73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592017,"discussion_content":"我是这样理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667031810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1444698,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","nickname":"C.","note":"","ucode":"5AE269220EFD73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592015,"discussion_content":"发生重写后，老AOF会把新操作记录下来，重写缓冲区把新的写操作也记录下了，然后子进程重写完，会把这个重写缓冲区的写的操作追加到新AOF的后面，当宕机后，新的AOF就重写失败，但老AOF还是有最新的记录的。当然AOF那三个策略也不是完美的，还是需要补偿的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667031753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359437,"user_name":"Geek_62d5df","can_delete":false,"product_type":"c1","uid":3197360,"ip_address":"北京","ucode":"BCACE763B4789A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYmUib5xavd98HzH0mFnicrwWqJlyuu1pe1CdQ6tehpJPIFbNeKPtZVnZ1160WuibZQUGSI9KCpmVOg/132","comment_is_top":false,"comment_ctime":1665543167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665543167","product_id":100056701,"comment_content":"大佬们想问一下，如果重写AOF文件的时候的时候如果发生断电，会发生脏数据吗？","like_count":0},{"had_liked":false,"id":359382,"user_name":"Tim","can_delete":false,"product_type":"c1","uid":1480717,"ip_address":"浙江","ucode":"3AAA9FD3D8DDDB","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/0d/fb77a32c.jpg","comment_is_top":false,"comment_ctime":1665489337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665489337","product_id":100056701,"comment_content":"求问，每秒写回的策略，是不会阻塞主线程的吧？那这个每秒刷盘的动作是启的子任务执行的么？<br>","like_count":0},{"had_liked":false,"id":358308,"user_name":"Geek_bd4376","can_delete":false,"product_type":"c1","uid":2910297,"ip_address":"广东","ucode":"7C30E7538E281D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIxEuD0ytJhQUFGXxtric0OxtpFx95GYmkB9RMJXFsgH0eWKiayzTg91v3GpCHyRTc5outbwe5WBtng/132","comment_is_top":false,"comment_ctime":1664183848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664183848","product_id":100056701,"comment_content":"AOF文件中存储的是redis的命令，同步命令到 AOF 文件的整个过程可以分为三个阶段：<br>命令传播<br>当一个 Redis 客户端需要执行命令时， 它通过网络连接， 将协议文本发送给 Redis 服务器。服务器在<br>接到客户端的请求之后， 它会根据协议文本的内容， 选择适当的命令函数， 并将各个参数从字符串文<br>本转换为 Redis 字符串对象（ StringObject ）。每当命令函数成功执行之后， 命令参数都会被传播到<br>AOF 程序。<br>缓存追加<br>当命令被传播到 AOF 程序之后， 程序会根据命令以及命令的参数， 将命令从字符串对象转换回原来的<br>协议文本。协议文本生成之后， 它会被追加到 redis.h&#47;redisServer 结构的 aof_buf 末尾。<br>redisServer 结构维持着 Redis 服务器的状态， aof_buf 域则保存着所有等待写入到 AOF 文件的协<br>议文本（RESP）。<br>文件写入和保存<br>每当服务器常规任务函数被执行、 或者事件处理器被执行时， aof.c&#47;flushAppendOnlyFile 函数都会被<br>调用， 这个函数执行以下两个工作：<br>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件。<br>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。","like_count":0},{"had_liked":false,"id":356749,"user_name":"Geek_b3b8da","can_delete":false,"product_type":"c1","uid":3065276,"ip_address":"浙江","ucode":"5461CD95B1D764","user_header":"","comment_is_top":false,"comment_ctime":1662552392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662552392","product_id":100056701,"comment_content":"我看到作者说 “因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复” 这里面的缓冲区是指的buff吗？如果是buff的话根据倪朋飞老师的内存篇第16篇讲Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中，如果是经过文件系统那么数据肯定是缓存在cache里面除非是直接io跳过文件系统数据会缓存在buff当中","like_count":0},{"had_liked":false,"id":356461,"user_name":"may_huang","can_delete":false,"product_type":"c1","uid":1451623,"ip_address":"北京","ucode":"EAF989F18FC109","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/67/c3d90f46.jpg","comment_is_top":false,"comment_ctime":1662343172,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662343172","product_id":100056701,"comment_content":"“如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复”<br><br>不太明白这句话，如果Redis用作缓存，怎么从后端数据库重新读入数据进行恢复？这个后端数据库是指什么数据库？","like_count":0},{"had_liked":false,"id":355439,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1356094,"ip_address":"北京","ucode":"D0DA0D860B2746","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVMCWZkjAquAbQsBJLgtGgWAwh5BkX4tHgyysRDGbxomeH0AvsnCaVakEiauPPiaFHnTehgIOLkWEA/132","comment_is_top":false,"comment_ctime":1661390566,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661390566","product_id":100056701,"comment_content":"老师好  no写回策略与everysec写回策略,是不是在某种情况下丢失数据不一定是every丢失数据较多?","like_count":0},{"had_liked":false,"id":355062,"user_name":"蔡欧","can_delete":false,"product_type":"c1","uid":1317604,"ip_address":"广东","ucode":"39470A1DCAA7A9","user_header":"https://static001.geekbang.org/account/avatar/00/14/1a/e4/5e2a8190.jpg","comment_is_top":false,"comment_ctime":1661049455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661049455","product_id":100056701,"comment_content":"Redis如何避免数据丢失：AOF日志<br>AOF日志的缺点：可能会阻塞后续Redis操作<br>如何降低对后续Redis后续操作影响：使用写入缓冲区，系统刷盘，缺点：可能有数据丢失<br>如何避免AOF日志多大，超过文件系统文件限制或者过大日志文件导致写入缓存：使用AOF重写，替换原AOF文件<br>AOF重写文件为什么小：AOF重写只是将Redis数据导出，相比AOF文件记录每一次操作，会小很多<br>AOF重写原理：fork一个bgwritelog进程，将数据写入AOF重写文件中<br>AOF重写文件会丢失数据吗：不会，主线程的操作会同时写入AOF文件和AOF重写文件，一拷贝两写入<br>执行AOF重写会不会导致主线程操作变慢，甚至阻塞：会的，因为fork子进程采用写时拷贝，如果写入数据过大或者开启Huge Page，导致拷贝子进程数据过大，会导致主进程操作变慢<br>AOF恢复需要执行AOF日志所有命令，过程很慢，有其他的恢复手段吗：RDB","like_count":0},{"had_liked":false,"id":355000,"user_name":"tong96","can_delete":false,"product_type":"c1","uid":3070561,"ip_address":"浙江","ucode":"04CA9D1BEC3569","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mno5Csic4tevfH5icPib8MOR4DyYpujr3Gls6gibNHZChyDF4rTykdHxBDBssWHGNgwpAhvS90WLCOBbCNSQSgs9pw/132","comment_is_top":false,"comment_ctime":1660965057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660965057","product_id":100056701,"comment_content":"bgrewriteaof是子进程还是子线程啊","like_count":0},{"had_liked":false,"id":354788,"user_name":"Geek_045c20","can_delete":false,"product_type":"c1","uid":2914350,"ip_address":"北京","ucode":"3C446088613422","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/apXvlhZqT7NLxOYz63qZzHebzCMszx3jI56gvRVeq62fX1b3zHy6fao1UknvuqfUkHkbYG0YkOBfvqXmJBxffg/132","comment_is_top":false,"comment_ctime":1660787840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660787840","product_id":100056701,"comment_content":"重写是什么条件下触发的呢","like_count":0},{"had_liked":false,"id":348785,"user_name":"解忧","can_delete":false,"product_type":"c1","uid":2720795,"ip_address":"","ucode":"B9D5E46448A0D4","user_header":"https://static001.geekbang.org/account/avatar/00/29/84/1b/ad327fff.jpg","comment_is_top":false,"comment_ctime":1655391167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655391167","product_id":100056701,"comment_content":"问题1：重写过程中，AOF缓冲区以及AOF重写缓冲区的日志是否会写入磁盘的日志？如果是，AOF重写日志会怎么处理？<br>问题2：两处日志都有缓冲区，这个缓冲区默认大小是多少？调整参数是什么？","like_count":0},{"had_liked":false,"id":348696,"user_name":"。。","can_delete":false,"product_type":"c1","uid":2853618,"ip_address":"","ucode":"A52A6043D27D87","user_header":"https://static001.geekbang.org/account/avatar/00/2b/8a/f2/6c6f7886.jpg","comment_is_top":false,"comment_ctime":1655305516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655305516","product_id":100056701,"comment_content":"redis 有 rdb、aof，宕机后能恢复数据，但是可能会导致部分数据丢失。假设原本有一个数据（key=a，value=xxx），之后我把这个数据修改成了（key=a，value=yyy），但是没有被 rdb 记录，宕机重启后数据被恢复成了（key=a，value=xxx）。假设我用 redis 做缓存，这个数据在 mysql 中也有，这样就会导致数据库和缓存数据不一致，有什么解决办法吗？","like_count":0},{"had_liked":false,"id":347638,"user_name":"樱桃汁。","can_delete":false,"product_type":"c1","uid":2907715,"ip_address":"","ucode":"36EE9D8B9C5122","user_header":"https://static001.geekbang.org/account/avatar/00/2c/5e/43/004a52fa.jpg","comment_is_top":false,"comment_ctime":1654243464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654243464","product_id":100056701,"comment_content":"抱歉刚没写完，接着写，fork一个新进程把拷贝的那份REDIS数据写入磁盘AOF重写文件，同时主线程的操作会记录在AOF缓冲和AOF重写缓冲区。拷贝的数据重写完成后，AOF重写缓冲区的数据可以写入到磁盘AOF重写文件。之前的AOF缓冲区和磁盘AOF文件可以丢弃了","like_count":0},{"had_liked":false,"id":347636,"user_name":"樱桃汁。","can_delete":false,"product_type":"c1","uid":2907715,"ip_address":"","ucode":"36EE9D8B9C5122","user_header":"https://static001.geekbang.org/account/avatar/00/2c/5e/43/004a52fa.jpg","comment_is_top":false,"comment_ctime":1654243068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654243068","product_id":100056701,"comment_content":"1.第一个问题想不到2.重写日志要和重写保持一致，以及AOF本身日志过大，所以不共享使用3.简单总结了一下日志记录过程，首先是命令完成后，该命令存到内存的AOF缓冲区，然后再写入磁盘AOF文件，如果宕机了，AOF缓冲区的数据会丢失。重写时拷贝一份REDIS数据在内存，并开辟一块重写缓冲区，同时FORK一个进程把拷贝的REDIS数据录入磁盘重写AOF文件","like_count":0},{"had_liked":false,"id":346563,"user_name":"EUC Online Training","can_delete":false,"product_type":"c1","uid":2974598,"ip_address":"","ucode":"57129739EE55EB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mYjoUy09Rbv8Pibic7ia60ib3upcdCUOgP97EQwApMdqL0Q9adnDcNd2kKMtfr1Uh62ia0YLUvp8eAXtFybNlK1yibUQ/132","comment_is_top":false,"comment_ctime":1653231288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653231288","product_id":100056701,"comment_content":"请问重写子进程在进行AOF重写时会先把日志写到缓冲区吗？还是直接写入磁盘文件","like_count":0},{"had_liked":false,"id":344742,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1651744795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651744795","product_id":100056701,"comment_content":"想要获得高性能，就选择 No 策略；如果想要得到高可靠性保证，就选择 Always 策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略","like_count":0},{"had_liked":false,"id":344483,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1651581128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651581128","product_id":100056701,"comment_content":"结合课代表回答谈一下我的答案：<br>1.fork页表阻塞的问题 <br>这里课代表已经给出了较为详述的论证 不作过多补充<br>2.子线程频繁fsync flush<br>子线程在落盘temp文件时，会调用flush fysnc。flush实际上是清空用户态 buffer，fsync是强制落盘。<br>这里会有个问题 虽然对于主线程是无感知的，但是写盘是需要cpu time的，所以频繁高并发的写盘 cpu load会被拉高。<br>反之 主线程的cpu time就会减少<br>3.主线回调事件里rename是加锁的，如果aof文件很大 ，那么主线程以及cpu load又会被拉长。","like_count":0},{"had_liked":false,"id":344152,"user_name":"ayi7664_","can_delete":false,"product_type":"c1","uid":2967743,"ip_address":"","ucode":"C80A21E7187BEE","user_header":"https://static001.geekbang.org/account/avatar/00/2d/48/bf/5c1018a2.jpg","comment_is_top":false,"comment_ctime":1651306543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651306543","product_id":100056701,"comment_content":"老师，我有一个地方不明白，想请教您一下。aof缓冲区，和aof日志，是一个是内存级别的，一个是硬盘级别的吗？命令是会先进入oaf缓冲区，再根据写回机制，写到aof日志吗","like_count":0},{"had_liked":false,"id":343190,"user_name":"L.N","can_delete":false,"product_type":"c1","uid":2162414,"ip_address":"","ucode":"051D63CAFF42B2","user_header":"https://static001.geekbang.org/account/avatar/00/20/fe/ee/251ea1eb.jpg","comment_is_top":false,"comment_ctime":1650699386,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1650699386","product_id":100056701,"comment_content":"我想问一下，AOF重写缓冲区，是不是也要进行“旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。”，那么会不会阻塞主线程","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568505,"discussion_content":"不进行，直接追加即可；\nAOF重写步骤分三大步：根据内存生成AOF，应用上一步期间产生的增量数据，再应用上一步期间产生的增量数据；其中前两步在子进程进行，最后一步在主线程进行，所以会阻塞，但是第三步时间很短，几乎不影响，相对来说更值得关注的是fork子进程时候的阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651153218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341480,"user_name":"李伟","can_delete":false,"product_type":"c1","uid":1239462,"ip_address":"","ucode":"F0EF60EB250B20","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/a6/69907ec1.jpg","comment_is_top":false,"comment_ctime":1649653841,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649653841","product_id":100056701,"comment_content":"作者提到的写前日志会出现命令不正确的问题，我之前是没有想到的。一连串的悬念让我很有兴趣读下去。<br>redis是如何避免机器宕机而数据丢失的呢？<br>通过AOF日志，如果宕机了，可以通过AOF恢复。那AOF是在操作redis数据之前写入的还是之后写入的呢？<br>之后写入的，那么会不会存在数据丢失的风险？因为如果数据操作完了，但是还没有写入AOF的话，那么宕机不就会丢失数据吗？<br>Redis在性能和安全性方面做了三种策略，可以让使用者根据情况选择（1）同步写入，（2）每秒写入，（3）通过操作系统控制写入<br>那么如果AOF的文件过大会不会存在写入的时候发生长时间的阻塞呢？<br>Redis通过异步重写AOF日志来解决文件过大问题。","like_count":0},{"had_liked":false,"id":340836,"user_name":"target_fly 2 years later","can_delete":false,"product_type":"c1","uid":2926236,"ip_address":"","ucode":"B30877606ED30E","user_header":"https://static001.geekbang.org/account/avatar/00/2c/a6/9c/6a0a36b0.jpg","comment_is_top":false,"comment_ctime":1649171736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649171736","product_id":100056701,"comment_content":"老师您好，文章写的很好，读完收获很大，但还有2个疑问：<br>1. AOF是在内存还是在磁盘中的？ <br>2. AOF缓存区 和 AOF文件有什么关联？","like_count":0},{"had_liked":false,"id":340644,"user_name":"Geek_df320b","can_delete":false,"product_type":"c1","uid":2960133,"ip_address":"","ucode":"AD27DE6F11EA6B","user_header":"","comment_is_top":false,"comment_ctime":1648989648,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1648989648","product_id":100056701,"comment_content":"AOF重写时， fork子进程，拷贝内存，若内存不足会怎样？ 断电之后重新重写会再次拷贝内存？","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568513,"discussion_content":"fork子进程时并不会拷贝内存，而是用了copy on write技术，如果copy on write期间因内存不足申请失败，那么子进程会因为OOM被kill掉，重启后还是会进入这个“重写-被kill-重写”的死循环；所以一定要给Redis预留足够的空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651154084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333406,"user_name":"数学汤家凤","can_delete":false,"product_type":"c1","uid":2029485,"ip_address":"","ucode":"DE84E777C384AD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","comment_is_top":false,"comment_ctime":1644328859,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1644328859","product_id":100056701,"comment_content":"有几个问题想请教一下：<br>1. 重写 aof 时，接受到命令是同时 append 到 aof buf 和 aof 重写 buf 吗？<br>2. 若问题 1，是同时写到两个 buf 中，那么为什么还需要 aof 重写 buf？直接在 aof buf 中拿到重写时接受到命令不就行了吗？","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568508,"discussion_content":"1、是\n2、aof buf只是一个缓冲，没多久他就落盘清空了，不可能去硬盘读出来吧？即使去硬盘读，也没办法知道要从哪开始读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651153787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329520,"user_name":"J 杰~","can_delete":false,"product_type":"c1","uid":2883490,"ip_address":"","ucode":"7202987553A19D","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ff/a2/56e24200.jpg","comment_is_top":false,"comment_ctime":1641385043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641385043","product_id":100056701,"comment_content":"请问AOF写磁盘的时机是什么时候？客户端有写请求写完内存就直接返回，还是写完内存+日志才返回呢？","like_count":0},{"had_liked":false,"id":328685,"user_name":"冷山","can_delete":false,"product_type":"c1","uid":2839720,"ip_address":"","ucode":"67163D24B7FA0E","user_header":"https://static001.geekbang.org/account/avatar/00/2b/54/a8/3b334406.jpg","comment_is_top":false,"comment_ctime":1640841588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640841588","product_id":100056701,"comment_content":"AOF的重写过程：**一处拷贝，两处日志**。<br><br>**一处拷贝：**重写时、主线程fork()出一个 bgrewriteaof 子进程，并将自己的内存（fork瞬间数据库中的最新数据）继承给子进程使用。<br><br>由子进程把这些从主线程继承得来的最新数据写成Redis命令，记录到重写日志中。（拷贝则是指主线程的写时复制）<br><br>**两处日志：**在重写过程中、**主线程执行的新命令会同时由主线程写到旧日志以及新日志的文件缓冲区中**。<br><br>当子进程重写完成后：重写过程中所执行的新命令，会从AOF的重写缓冲区落盘到新的AOF日志里、以保证AOF日志和数据库数据的一致性。<br><br>然后、重写后的新日志会替代旧的日志。","like_count":0},{"had_liked":false,"id":327246,"user_name":"ฅSlekฅ","can_delete":false,"product_type":"c1","uid":2436755,"ip_address":"","ucode":"B732C672B3D301","user_header":"https://static001.geekbang.org/account/avatar/00/25/2e/93/81e3e4ca.jpg","comment_is_top":false,"comment_ctime":1640005180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640005180","product_id":100056701,"comment_content":"CopyOnWrite机制和CopyOnWriteList的实现原理很类似","like_count":0},{"had_liked":false,"id":326433,"user_name":"senda","can_delete":false,"product_type":"c1","uid":2729003,"ip_address":"","ucode":"74541011088AFB","user_header":"https://static001.geekbang.org/account/avatar/00/29/a4/2b/0e1bab59.jpg","comment_is_top":false,"comment_ctime":1639530067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639530067","product_id":100056701,"comment_content":"老师，请问一下，您说的这段如何理解呢？<br>      “因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。 ”    <br>       请问， 这一块不太理解，新的操作写入缓冲区，缓冲区也是在内存中的，如果宕机了，内存数据丢失了，就没法恢复数据了吧。","like_count":0},{"had_liked":false,"id":325842,"user_name":"Geek_f223ca","can_delete":false,"product_type":"c1","uid":2524434,"ip_address":"","ucode":"CC18B0F7C24898","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJm5SIHaDYWUDMQ1kJ5YMYSibTTiat2ZVRk8qiaoKS1WQuSVe14LrM29nWmyuZUtGhjOXbqockk1c4Vw/132","comment_is_top":false,"comment_ctime":1639189055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639189055","product_id":100056701,"comment_content":"老师，持久化过程时如何保证不会出现新的写覆盖数据","like_count":0},{"had_liked":false,"id":324985,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1638771757,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1638771757","product_id":100056701,"comment_content":"读过不止一遍的文章，这次读比以前读理解了更多，和最近学的os知识串起来了，基础还是王道。还有很多需要补的，继续加油。","like_count":0},{"had_liked":false,"id":323188,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1313963,"ip_address":"","ucode":"E0E655D048824A","user_header":"https://static001.geekbang.org/account/avatar/00/14/0c/ab/cfbf16e4.jpg","comment_is_top":false,"comment_ctime":1637757036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637757036","product_id":100056701,"comment_content":"请教下aof每秒回写下，对服务阻塞或对并发的影响有一些量化的经验或数据么","like_count":0},{"had_liked":false,"id":319847,"user_name":"fei","can_delete":false,"product_type":"c1","uid":2126331,"ip_address":"","ucode":"36D802EB42FEF3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOUjOGRlYNY1TDZpso7LQEhMyqmgUqEW3sm5xWTHqhU5rUol8NeEOxLMQA5ib09Y8Yg97ziaqsKduA/132","comment_is_top":false,"comment_ctime":1635987675,"is_pvip":true,"discussion_count":0,"race_medal":3,"score":"1635987675","product_id":100056701,"comment_content":"AOF重写时，等到拷贝数据的所有操作记录重写完成后，AOF重写日志缓冲中的记录的也会写入新的 AOF 文件，以保证数据库最新状态的记录。<br>我问题是：在将AOF重写日志缓冲的记录写入新AOF文件的过程也需要时间，在这个时间里如果又有新的写入，那又如何处理？这时是不能切换到新日志文件的。","like_count":0},{"had_liked":false,"id":313948,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1632750642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632750642","product_id":100056701,"comment_content":"Redis通过AOF日志的方式保证数据的可靠性，AOF日志是后写日志，即先执行命令，成功后再写AOF日志，这样做的风险是：<br><br>  1、断电的话不可避免会造成数据缺失；<br><br>  2、写日志的操作是在主线程上进行的，当日志写回磁盘时，如果硬盘写压力大，就会阻塞主线程。<br><br><br><br>有三种日志写回策略：<br>  Always，同步写回；<br>  Everysec，每秒写回；<br>  No，操作系统控制的写回。<br><br>每秒写回和操作系统控制写回都需要先将日志写到AOF内容缓冲区，然后按周期进行日志歇会，不能避免数据丢失。同步写回可以最大限度的避免数据丢失，但是每个写命令都进行写回操作，会影响主线程的性能。三种歇会策略中，每秒写回是一种在避免影响主线程性能和避免数据丢失之间的折中方案。<br><br>随着AOF日志文件的不断变大，AOF日志本身会成为性能瓶颈的主因。此时，需要进行AOF重写以降低AOF日志文件的大小。<br><br>具体过程是“一个拷贝，两处日志”：执行重写时，主线程先 fork 出后台的 bgrewriteaof 子进程，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。<br><br>为了保证AOF日志和重写日志都是最新的日志，所以每次执行写命令时，会同时把命令记录在AOF日志缓冲区和重写日志缓冲区。<br><br>等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，然后就可以用新的 AOF 文件替代旧文件了。<br><br>重写日志的过程不在主线程上，所以不会阻塞主线程。","like_count":0},{"had_liked":false,"id":312930,"user_name":"Geek_664206","can_delete":false,"product_type":"c1","uid":1480524,"ip_address":"","ucode":"585B39AA780B26","user_header":"","comment_is_top":false,"comment_ctime":1632126571,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1632126571","product_id":100056701,"comment_content":"Everysec模式，刷盘会阻塞主线程吗？还是由另一个子进程执行的？","like_count":0,"discussions":[{"author":{"id":1887603,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/cd/73/f6889c2f.jpg","nickname":"Wind","note":"","ucode":"AD108636DE44C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402330,"discussion_content":"会阻塞，是主线程做的，这部分笔记分享给你，老师没说，网上找到补充的\n\n落盘策略\n  a. Always 同步会写，主线程每次写操作都会（flushAppendOnlyFile）同步调用fsync强制落盘，数据不会丢失（写入数据后马上宕机，也是会丢数据的，但是这时候客户端也是没返回执行正常的结果，所以可以理解成不会丢），但是性能最差\n  b. Everysec 每秒(异步)回写，主线程只是作为生产者产生fsync任务，由bio线程消费并执行；另外Everysec 还需要注意每秒落盘量不能超过磁盘IO能力，否则会造成bio任务积压（Redis发现bio仍在执行任务时会直接堵塞任务提交，来应对磁盘IO能力不足的情况，也就是说磁盘IO能力不足导致落盘性能不足时，异步刷盘也会影响整体性能），系统宕机会有一秒数据丢失，性能适中\n  c. No 不显式调用fsync；让操作系统控制落盘时机，Redis无法决定增量数据的落盘时间，因此容错能力不可控；丢数据较多，性能最好","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633865311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312133,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1631633838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631633838","product_id":100056701,"comment_content":"redis为什么执行redis命令成功后再写日志就不会阻塞写操作。这两步操作难道是异步的吗。我理解如果不是异步的话执行后写和执行前写都会阻塞写操作","like_count":0},{"had_liked":false,"id":311582,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1344535,"ip_address":"","ucode":"6B8D59A0B1A1A9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOn7k48KXia5rf0eXpzv2EGtqGibz3eNb8QnL8X72uia0g1rBwzXef4dV2JEdz3r4bu9GC1FLIeic4UA/132","comment_is_top":false,"comment_ctime":1631321542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631321542","product_id":100056701,"comment_content":"“因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。”    <br>请问，缓冲区的数据也在内存，如果发生断电，是不是意味着也丢了……一直想不通","like_count":0},{"had_liked":false,"id":310504,"user_name":"刀斧手何在","can_delete":false,"product_type":"c1","uid":1202572,"ip_address":"","ucode":"B99D7ECC3EE954","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/8c/ba81a832.jpg","comment_is_top":false,"comment_ctime":1630685161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630685161","product_id":100056701,"comment_content":"问题： 为什么AOF写回不能fork子线程操作。或者独立一个子线程，专门用来刷AOF缓冲？","like_count":0},{"had_liked":false,"id":309254,"user_name":"louis","can_delete":false,"product_type":"c1","uid":2416570,"ip_address":"","ucode":"4923669B2F0748","user_header":"https://static001.geekbang.org/account/avatar/00/24/df/ba/4b9d2569.jpg","comment_is_top":false,"comment_ctime":1630023633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630023633","product_id":100056701,"comment_content":"重写是一个子进程，什么时候创建的呢？","like_count":0},{"had_liked":false,"id":309175,"user_name":"dandy","can_delete":false,"product_type":"c1","uid":1583740,"ip_address":"","ucode":"5EE976FCBD9215","user_header":"https://static001.geekbang.org/account/avatar/00/18/2a/7c/0d6a87c4.jpg","comment_is_top":false,"comment_ctime":1629968707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629968707","product_id":100056701,"comment_content":"总结一下aof的流程：<br>rewriteAppendOnlyFileBackground启动流程：<br>1 检查是否创建了子进程。有则退出<br>2 创建管道，目的是子进程aof备份的时候，还会有数据请求父进程，父进程需要把数据存到aof_rewrite_buf_blocks中(list数据)。<br>3 创建父子进程<br>    父进程：<br>\t记录子进程信息（pid）、时间戳等；<br>\t继续响应其他客户端请求；<br>\t收集AOF重写期间的命令，追加至aof_rewrite_buf_blocks；<br>\t子进程：<br>\t修改当前进程名称，创建重写所需的临时文件，调用rewriteAppendOnlyFile函数；<br>\t根据aof-use-rdb-preamble配置，以RDB或AOF方式写入前半部分，并同步至硬盘；<br>\taof写入，rioFileWrite并用fwrite命令，写到用户缓冲区，fflush用户缓冲区到内核缓冲区，fsync写到磁盘<br>\t获取创建的管道信息，父进程接收在aof期间，写入到缓存(使用list结构存储)的数据。以AOF方式写入后半部分，之后按照上述同样操作写入磁盘<br>\trename原子性AOF文件，子进程退出。<br><br>不清楚就去看源码喽！","like_count":0},{"had_liked":false,"id":307383,"user_name":"Alery","can_delete":false,"product_type":"c1","uid":1156557,"ip_address":"","ucode":"08F3F49181E67B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/cd/3aff5d57.jpg","comment_is_top":false,"comment_ctime":1629076054,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629076054","product_id":100056701,"comment_content":"请教一个问题，刷盘策略没有事物提交，即使采用always是不是还是一种不可靠的持久化？","like_count":0,"discussions":[{"author":{"id":1887603,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/cd/73/f6889c2f.jpg","nickname":"Wind","note":"","ucode":"AD108636DE44C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402334,"discussion_content":"网上找到的说 always 是主线程同步刷盘，也就是说在刷盘成功之前是没返回给客户端的，也就是说写数据了 但是刷盘时候宕机了，客户端没收到成功的应答，是可以理解成事务没完成的，当然严谨点说肯定是不及数据库的二阶段提交，所以老师也说了，是基本上不丢数据，没说绝对，要看业务对这个时候的宕机是怎么理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633865757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307108,"user_name":"flying myself","can_delete":false,"product_type":"c1","uid":1992480,"ip_address":"","ucode":"69F26BE9B94B58","user_header":"https://static001.geekbang.org/account/avatar/00/1e/67/20/93b2e38e.jpg","comment_is_top":false,"comment_ctime":1628862748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628862748","product_id":100056701,"comment_content":"No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。 操作系统控制写回是怎么实现的呢","like_count":0},{"had_liked":false,"id":305195,"user_name":"Geek_9036f8","can_delete":false,"product_type":"c1","uid":2181955,"ip_address":"","ucode":"1B5DE713CAE020","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ibEDauu4c6nN6UCsNApNAoABustxiadXvMXTuBHzhFjY1eW8ohkwxMqr2RnMeBDdibvxdWLXe7zrQialeQSkydfAsw/132","comment_is_top":false,"comment_ctime":1627873640,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1627873640","product_id":100056701,"comment_content":"老师，我有个问题，AOF重写的时候会重写所有数据的操作吗，如果是的话，那这跟RDB是不是就没有区别了，难道不是原AOF文件记录了哪些数据的操作才进行这些数据操作的合并吗，而现在是RDB和AOF共用的情况下，AOF就更没有必要进行所有数据的操作记录，那么这个时候这个重写机制会有改变吗，还是说这块的重写机制没有写太细？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388369,"discussion_content":"rdb和aof本身是独立的，个人觉得理论上可以用，但是如果强行耦合aof也公用rdb的快照文件性价比不是很高，因为aof重写子线程完成后还需要立即同步重写期间新增的缓冲区数据的，衔接处理不好很容易漏数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628734841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305079,"user_name":"xiong","can_delete":false,"product_type":"c1","uid":1099375,"ip_address":"","ucode":"C1BFD9EF96372F","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/6f/ac3003fa.jpg","comment_is_top":false,"comment_ctime":1627805469,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1627805469","product_id":100056701,"comment_content":"老师，有个疑惑点的地方：aof 在重写过程中的一个拷贝中说会把主线程的内存数据拷贝一份到子进程，如果数据量在很大的情况下，这个动作会有压力吗？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388268,"discussion_content":"不是拷贝的数据，是内存地址页都是存的内存物理地址的映射关系，这个是线性规律的，数据越多，关系也越多，但是肯定比数据占得空间小的多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628675208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303675,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1626923983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626923983","product_id":100056701,"comment_content":"回答这个问题,我们得看下Unix中的父子进程的拷贝<br>在父进程调用fork之后,<br>Unix会进行以父进程为模板创建子进程<br>然后拷贝虚拟内存中的地址(虚拟内存和物理内存有一个映射关系,这是因为Unix维护了一个大一统的内存系统,将上层对内存的操作和实际的内存解耦)<br>然后fork分别返回,父进程获取到子进程的pid<br>上述流程,之所以只拷贝虚拟内存,是因为Unix采用了写时复制(早期Unix是深拷贝)<br>而AOF不涉及操作内存,故不会拷贝物理内存<br>但是由于Unix中,可能出现进程数不足,以及虚拟内存表拷贝失败等问题,到来的AOF重写失败的风险<br>还有就是在学习课程之前,我曾经猜测过AOF的重写机制,早期我给出的答案是模仿MQ的日志文件,只是操作日志,即依次读取日志,根据key来判断key最终是否需要写入到日志中,到了重写流程完成之后,才进行一个强制写盘的操作,现在看来,我还是对Unix系统玩的浅啊","like_count":0},{"had_liked":false,"id":299824,"user_name":"斜杠青年","can_delete":false,"product_type":"c1","uid":1177739,"ip_address":"","ucode":"D7AF02B8588549","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/8b/74d2ab6b.jpg","comment_is_top":false,"comment_ctime":1624872610,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1624872610","product_id":100056701,"comment_content":"请问老师 写AOF文件是否要加入队列 控制先后顺序","like_count":0},{"had_liked":false,"id":298004,"user_name":"DDD","can_delete":false,"product_type":"c1","uid":1500472,"ip_address":"","ucode":"26411E3487BBB5","user_header":"https://static001.geekbang.org/account/avatar/00/16/e5/38/d271950c.jpg","comment_is_top":false,"comment_ctime":1623884138,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623884138","product_id":100056701,"comment_content":"‘第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区’ 这句话没听懂","like_count":0},{"had_liked":false,"id":297033,"user_name":"张新亮","can_delete":false,"product_type":"c1","uid":2406845,"ip_address":"","ucode":"B68A71CDEA551A","user_header":"https://static001.geekbang.org/account/avatar/00/24/b9/bd/7fef12c8.jpg","comment_is_top":false,"comment_ctime":1623288606,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1623288606","product_id":100056701,"comment_content":"问一下蒋老师，everysec模式下，每秒调一次fsync的，是主线程调的还是后台线程调的？","like_count":0,"discussions":[{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387059,"discussion_content":"everysec 下，是后台子线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627965876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296883,"user_name":"Jerry","can_delete":false,"product_type":"c1","uid":2120883,"ip_address":"","ucode":"790ADE0791C744","user_header":"https://static001.geekbang.org/account/avatar/00/20/5c/b3/05612134.jpg","comment_is_top":false,"comment_ctime":1623209764,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1623209764","product_id":100056701,"comment_content":"老师，Everysec写回策略：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘。这个每一秒把缓冲区的内容写入磁盘，这个操作还是不是主线程操作的，主线程操作的话应该会阻塞才对呀","like_count":0,"discussions":[{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387060,"discussion_content":"后台子线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627965931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296746,"user_name":"洋仔","can_delete":false,"product_type":"c1","uid":1907293,"ip_address":"","ucode":"60065172A83B23","user_header":"https://static001.geekbang.org/account/avatar/00/1d/1a/5d/963c9764.jpg","comment_is_top":false,"comment_ctime":1623143049,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623143049","product_id":100056701,"comment_content":"WAL也是先执行命令的啊，不过是先写日志，再写磁盘，这个角度AOF应该也是用的WAL的技术，也是先写日志，再写磁盘","like_count":0},{"had_liked":false,"id":296207,"user_name":"Geek2808","can_delete":false,"product_type":"c1","uid":2028948,"ip_address":"","ucode":"835C9691723163","user_header":"","comment_is_top":false,"comment_ctime":1622806219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622806219","product_id":100056701,"comment_content":"1、写日志是进行文件的IO，存在阻塞的风险。<br>2、无法有效区分从哪一段文件开始是AOF重写需要的日志。","like_count":0},{"had_liked":false,"id":295673,"user_name":"没头脑和不高兴","can_delete":false,"product_type":"c1","uid":2029287,"ip_address":"","ucode":"E1E90A415AF695","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f6/e7/eabea1ec.jpg","comment_is_top":false,"comment_ctime":1622539973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622539973","product_id":100056701,"comment_content":"问题1：在触发重写操作时，需要占用多大的内存，服务器空闲内存保持在多少比较合适。例如现在redis服务器，内存已使用10G。<br>问题2：重写过程会导致服务不可用有哪些原因。","like_count":0},{"had_liked":false,"id":295055,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1622197099,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622197099","product_id":100056701,"comment_content":"一是，文件系统本身对文件大小有限制，无法保存过大的文件；二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。<br>--------------------------------------------------》<br>第二点没明白， AOF追加，不是会记录文件当前写入的索引位置吗，和文件大小有什么关系","like_count":0},{"had_liked":false,"id":293504,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1621412609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621412609","product_id":100056701,"comment_content":"提两点不同看法：<br>1. 很多同学说bgrewriteaof子进程结束后，是使用信号通知redis主进程，但从最新的redis6.2.3看，redis实现了一个serverCron函数，其本质上是一个timer interrupt，支持所有需要asynchronously执行的工作，比如AOF rewrite, and handling of terminated children。<br>2. 关于“AOF非阻塞的重写过程”，更细节的实现是，AOF缓冲和AOF重写缓冲都隶属于Redis主进程（参见struct redisServer）：fork得到bgrewriteaof子进程，会继承父进程的所有内存结构，但它实际只用了redis数据库的“拷贝”并将其写到tempfile中，而没有使用AOF重写缓冲。追加AOF rewrite buffer到tempfile的工作是由redis主进程完成的。所以如果重写AOF期间修改的数据量较大，追加过程也是可能的一个性能风险点。也许redis已经考虑到了这一点，所以aof重写缓冲才采用链表block的形式。<br>请大家指教。","like_count":0},{"had_liked":false,"id":292143,"user_name":"JAVA初级开发工程师","can_delete":false,"product_type":"c1","uid":1876716,"ip_address":"","ucode":"F78E2F30751AC2","user_header":"http://thirdwx.qlogo.cn/mmopen/KFgDEHIEpnTUibfcckj33D1LVj9VapfrK3Yq2Gj00wnLt4nkWS7HvYy5NxvmnQcQpaysuBHVrB9MILWZ9hibUNasicPNtueYoNM/132","comment_is_top":false,"comment_ctime":1620702228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620702228","product_id":100056701,"comment_content":"请教个问题，AOF重写时写入请求特别导致AOF重写缓冲区满了会怎么处理","like_count":0},{"had_liked":false,"id":291662,"user_name":"二二江湖","can_delete":false,"product_type":"c1","uid":2065539,"ip_address":"","ucode":"F935DB9B620ADF","user_header":"https://static001.geekbang.org/account/avatar/00/1f/84/83/78d142c5.jpg","comment_is_top":false,"comment_ctime":1620402691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620402691","product_id":100056701,"comment_content":"请问下写时复制和写入重写缓冲区的数据不是重复了么？","like_count":0},{"had_liked":false,"id":290279,"user_name":"Geek_d8e6a2","can_delete":false,"product_type":"c1","uid":1618090,"ip_address":"","ucode":"ECD84E50DBAF30","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKqPgfj68lFBJ1YptiaIKv6Jib4m7RcpkpXzvG1PEW9YstRzvDvTNJ2uNiaNyZAI0lYiaGcj407q8beRA/132","comment_is_top":false,"comment_ctime":1619484376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619484376","product_id":100056701,"comment_content":"老师，我有个问题，如果写回策略设置的是No，那么在redis实例关闭的时候，会不会关闭前调用fsync同步到磁盘","like_count":0},{"had_liked":false,"id":288844,"user_name":"第四单元","can_delete":false,"product_type":"c1","uid":1747184,"ip_address":"","ucode":"3ED9D553E1DE17","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","comment_is_top":false,"comment_ctime":1618726381,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1618726381","product_id":100056701,"comment_content":"“除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以不会阻塞当前的写操作。“<br>这里为什么强调是写操作，读操作呢？会阻塞么","like_count":0,"discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373201,"discussion_content":"读操作就直接返回了 等待下一个op","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620650047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288448,"user_name":"小睡睡","can_delete":false,"product_type":"c1","uid":1102838,"ip_address":"","ucode":"049091D752DE29","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/f6/d9ecf4ea.jpg","comment_is_top":false,"comment_ctime":1618473492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618473492","product_id":100056701,"comment_content":"第三课时 持久化不是说 是额外的线程执行的吗？  ","like_count":0},{"had_liked":false,"id":287670,"user_name":"杨领well","can_delete":false,"product_type":"c1","uid":1145650,"ip_address":"","ucode":"3974A03855168C","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/32/60089a62.jpg","comment_is_top":false,"comment_ctime":1618100262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618100262","product_id":100056701,"comment_content":"Redis AOF Rewrite 流程：https:&#47;&#47;1drv.ms&#47;u&#47;s!AhmQllsCO9DomTTRmu4LRYhHHurN?e=bbp45d","like_count":0},{"had_liked":false,"id":287530,"user_name":"烟徒","can_delete":false,"product_type":"c1","uid":2551609,"ip_address":"","ucode":"72925C1EDD73D6","user_header":"","comment_is_top":false,"comment_ctime":1618016690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618016690","product_id":100056701,"comment_content":"如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。<br><br><br><br>缓冲区里的数据还没有写到磁盘的时候，就宕机了，AOF 日志最新操作岂不是没了？","like_count":0},{"had_liked":false,"id":287346,"user_name":"强哥","can_delete":false,"product_type":"c1","uid":1623715,"ip_address":"","ucode":"F062E874C5AFEB","user_header":"https://static001.geekbang.org/account/avatar/00/18/c6/a3/2a780bc6.jpg","comment_is_top":false,"comment_ctime":1617894406,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1617894406","product_id":100056701,"comment_content":"第2个问题： 1.本来AOF重写就是为了解决日志过大问题，共用原来的岂不是更大？共享完了，原来的内容怎么删? 2.共用原来的势必考虑如果某个key新发生了写，那么老的日志就不要拷贝过来了。那么做日志重写时是不是还要检查每个key最近发生了新写？","like_count":0},{"had_liked":false,"id":285989,"user_name":"Geek_f5daa4","can_delete":false,"product_type":"c1","uid":2368063,"ip_address":"","ucode":"18B39BFAC73E2E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIk0cGUy1nvQ6n4k77faGe0bXns4Me1sZznP4aUTUXRApcicKmesc7tpsF2wBqC1Ckicw1bd5T7XvsQ/132","comment_is_top":false,"comment_ctime":1617095537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617095537","product_id":100056701,"comment_content":"如果不小心触发了flushdb操作，该怎么恢复呢？<br>（在key很少的实验环境下在aof文件中删掉flushdb相关行再执行redis-check-aof --fix appendonly.aof，然后重启redis服务，是可以恢复内存的；但当模拟生产环境下复杂的情况下，redis-check-aof --fix appendonly.aof命令会直接把aof文件删减到几乎为空）","like_count":0},{"had_liked":false,"id":285363,"user_name":"蓝萧","can_delete":false,"product_type":"c1","uid":1227606,"ip_address":"","ucode":"DE125B56BF7818","user_header":"https://static001.geekbang.org/account/avatar/00/12/bb/56/a506a165.jpg","comment_is_top":false,"comment_ctime":1616753722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616753722","product_id":100056701,"comment_content":"AOF重写时，如果磁盘满了会怎么样？会报错还是静默不工作了","like_count":0},{"had_liked":false,"id":285028,"user_name":"匆匆那年","can_delete":false,"product_type":"c1","uid":1792255,"ip_address":"","ucode":"6CF758D19815FA","user_header":"https://static001.geekbang.org/account/avatar/00/1b/58/ff/d1add6f2.jpg","comment_is_top":false,"comment_ctime":1616583168,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616583168","product_id":100056701,"comment_content":"&quot;AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了&quot;，这个是在主线程吗，不是 AOF 把内容写到内存缓存中，内核异步把内容刷回磁盘吗","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388370,"discussion_content":"这个仅限于always策略吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628735605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285022,"user_name":"蓝萧","can_delete":false,"product_type":"c1","uid":1227606,"ip_address":"","ucode":"DE125B56BF7818","user_header":"https://static001.geekbang.org/account/avatar/00/12/bb/56/a506a165.jpg","comment_is_top":false,"comment_ctime":1616581496,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616581496","product_id":100056701,"comment_content":"AOF配置everysec时，每秒触发的AOF日志写入是主线程完成的吗？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388371,"discussion_content":"子线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628735624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284564,"user_name":"几近虚年","can_delete":false,"product_type":"c1","uid":1355831,"ip_address":"","ucode":"28CD6486EED8E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/b0/37/d654fbac.jpg","comment_is_top":false,"comment_ctime":1616340907,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616340907","product_id":100056701,"comment_content":"看了很多评论，我理解的重写 AOF 日志是这样的：<br>如果是没有修改的数据，旧 AOF 日志文件和新 AOF 日志文件，都是指向同一个物理内存地址。（写实复制机制）<br>写入新数据时重新分配内存，同时将内存地址写入旧、新 AOF 日志中。<br>修改数据，父线程分配内存（此时对新 AOF 日志不可见），写入旧 AOF 日志缓冲区，最后写入到新 AOF 日志。<br>不知道对不对...","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388373,"discussion_content":"应该是fork子进程时主进程和fork的子进程共享了主线程的内存地址，跟日志文件没关系。子线程纯粹的读不会涉及修改，所有的新增删除修改数据都会给主进程重新分配内存，操作同时计入重新aof缓存中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628735929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284006,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1616035313,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1616035313","product_id":100056701,"comment_content":"在服务器宕机的情况下，Redis 自己实现持久化与通过后端数据库恢复数据哪一个性能更好？毫无疑问是 Redis，那么问题来了，Redis 是如何做到的？<br><br>AOF 里面记录了 Redis 的每一条命令，其实在 MySQL 里面也有 binlog，如果设置成 statement，也能记录每一条 SQL。<br><br>Redis 使用写后日志，减少了额外的命令语法检查开销，可以避免出现记录错误日志。另外一个好处是，不会阻塞当前的写操作。<br><br>AOF 的重写其实适合应用场景密切相关的，因为 Redis 主要应用于缓存场景，所以不太在意某一个 key 的操作历史，只在乎这个 key 的当前值。<br><br>AOF 重写机制虽然巧妙，但是普通数据库估计没法使用。<br><br>AOF 重写由后台子进程 bgrewriteaof 来完成，采用“一个拷贝，两处日志”的方式。<br><br>对于课后思考题，第一题，在 bgrewriteaof 子进程进行重写的过程，我觉的在拷贝的时候有可能会发生阻塞，如果文件比较大，那么拷贝可能会比较慢（在内存里，几乎可以忽略），另一方面，就是有可能把内存占满，StackOverflow ?<br><br>第二个题目，AOF 重写的重写日志应该是在发生重新的时候（假设此时的时间为 t1）开始记录的，比原有的 AOF 重写日志要小很多，这样在完成了 t1 之前的日志重写之后，原有的 AOF 本身的日志就可以删除了。AOF 重写的重写日志相对来说要小一些，读写性能更好，最终删除的时候也更快。<br><br>看了 @Kaito 的答案，只能膜拜。<br><br>留言里面还提到 AOF 是 Append Only File 的缩写，也算是解了我的一个疑惑。","like_count":0},{"had_liked":false,"id":283237,"user_name":"小吴大人","can_delete":false,"product_type":"c1","uid":1795769,"ip_address":"","ucode":"4187A1E3AFCE84","user_header":"https://static001.geekbang.org/account/avatar/00/1b/66/b9/52e303cf.jpg","comment_is_top":false,"comment_ctime":1615634342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615634342","product_id":100056701,"comment_content":"aof重写过程中，aof缓存或者重写缓存不止记录写操作吧？删除修改是不是也应该记录一下？","like_count":0},{"had_liked":false,"id":283203,"user_name":"xiaoyu","can_delete":false,"product_type":"c1","uid":1245915,"ip_address":"","ucode":"477617C15FB5CC","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/db/5d227be5.jpg","comment_is_top":false,"comment_ctime":1615619327,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1615619327","product_id":100056701,"comment_content":"问题一<br>子进程完成AOF重写之后，会通知父进程（发送信号），父进程收到信号后会调用信号处理函数，会执行以下操作<br>1. 将AOF重写缓冲区的内容写入到新的AOF文件中<br>2. 对新的AOF文件改名并替换原有的AOF文件<br><br>上述操作也会造成主线程阻塞","like_count":0},{"had_liked":false,"id":281793,"user_name":"HUNTER","can_delete":false,"product_type":"c1","uid":1114579,"ip_address":"","ucode":"184725E9ED0E2C","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/d3/5cbaeb95.jpg","comment_is_top":false,"comment_ctime":1614905617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614905617","product_id":100056701,"comment_content":"老师你好，AOF缓冲区里的数据同步到磁盘的操作，是由主进程完成的吗","like_count":0},{"had_liked":false,"id":280503,"user_name":"Spoon","can_delete":false,"product_type":"c1","uid":1959822,"ip_address":"","ucode":"2FF9193AD482C2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","comment_is_top":false,"comment_ctime":1614237103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614237103","product_id":100056701,"comment_content":"aof fork之后，主进程和子进程之间是通过管道来通信的吧？","like_count":0},{"had_liked":false,"id":280342,"user_name":"团圆丁","can_delete":false,"product_type":"c1","uid":2161554,"ip_address":"","ucode":"23DD0146F43C7D","user_header":"https://static001.geekbang.org/account/avatar/00/20/fb/92/17923e19.jpg","comment_is_top":false,"comment_ctime":1614162194,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1614162194","product_id":100056701,"comment_content":"请问蒋老师一个问题：fork出一份数据，那是不是意味着内存使用量一下子就翻倍了？比如服务器内存100G，redis当前用了60G，那这时fork会成功吗？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388375,"discussion_content":"只是拷贝了内存地址页不是数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628736037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275790,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1611667841,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1611667841","product_id":100056701,"comment_content":"老师，请问将bgrewriteaof缓存写入文件时，redis主进程会被阻塞吗？","like_count":0},{"had_liked":false,"id":275260,"user_name":"David","can_delete":false,"product_type":"c1","uid":1168519,"ip_address":"","ucode":"B022C57C0FDC0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/87/aa475f0a.jpg","comment_is_top":false,"comment_ctime":1611413497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611413497","product_id":100056701,"comment_content":"redis 用AOF 恢复数据，避免大量请求数据库造成数据库压力和服务响应变慢我。为了平衡可靠性和性能，redis提供了三种回写策略。用重写解决AOF 文件过大的问题，重写在fork的子进程中进行，避免阻塞主线程。","like_count":0},{"had_liked":false,"id":274637,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1611108215,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1611108215","product_id":100056701,"comment_content":"为什么aof刷盘不直接采用异步呢？这样只要网络速率小于磁盘写入速率，就可以保证数据不丢了","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392849,"discussion_content":"猜测刷盘，也是对共享资源的处理，异步就要考虑锁的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631153000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271870,"user_name":"僊峯","can_delete":false,"product_type":"c1","uid":2039980,"ip_address":"","ucode":"FA140E7653C26D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/20/ac/c609855b.jpg","comment_is_top":false,"comment_ctime":1609846993,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609846993","product_id":100056701,"comment_content":"因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。<br>这一段里面只是把操作写入缓存区，宕机了怎么可能日子操作是齐全的？又没有落盘","like_count":0},{"had_liked":false,"id":270818,"user_name":"Just Do IT","can_delete":false,"product_type":"c1","uid":1192724,"ip_address":"","ucode":"1EAD92510FA7BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/14/78104f1f.jpg","comment_is_top":false,"comment_ctime":1609289948,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1609289948","product_id":100056701,"comment_content":"感觉后边说的有点乱<br>1.一个拷贝   主线程所拥有的数据被子线程全部拷贝过去，主线程的内存仍然有新数据写入，这个新数据是怎么到子线程那里去的？<br><br>2.主线程在更新AOF文件   子线程在更新重写AOF文件，新文件替换旧文件，难道是直接用重写日志文件替换原AOF日志文件？ 这两个文件格式完全不一样，直接替换肯定会出问题。<br><br><br>3.如果不是直接替换，那就是子线程也有自己的AOF文件，意味着子线程要同时写两个日志文件？用自己的AOF替换主线程的AOF文件？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388376,"discussion_content":"1.主进程的数据变更都会记录到重写aof缓存的 2文件格式一样的，重写日志不过是把中间过程日志滤掉了，保留最终结果日志 3.直接文件改名替换了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628736289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267140,"user_name":"五角场撸个串","can_delete":false,"product_type":"c1","uid":2281148,"ip_address":"","ucode":"543A7015D1E0CD","user_header":"https://static001.geekbang.org/account/avatar/00/22/ce/bc/8177eef4.jpg","comment_is_top":false,"comment_ctime":1607606786,"is_pvip":false,"replies":[{"id":"97906","content":"谢谢，一起努力！","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608975172,"ip_address":"","comment_id":267140,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607606786","product_id":100056701,"comment_content":"一口气看了好多节课，感谢老师的用心准备。老师的课从问题出发，从表面到原理，循序渐进，通俗易懂。对比其他有些课程，要么浮于表面，要么晦涩难懂。希望老师能够再出更多课程，谢谢。","like_count":0,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511521,"discussion_content":"谢谢，一起努力！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608975172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264762,"user_name":"许峰","can_delete":false,"product_type":"c1","uid":2346462,"ip_address":"","ucode":"C12E7B53D7E658","user_header":"https://static001.geekbang.org/account/avatar/00/23/cd/de/0334fd13.jpg","comment_is_top":false,"comment_ctime":1606635954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606635954","product_id":100056701,"comment_content":"还是没太明白<br>1. 子进程bgrewriteaof在主进程接受数据, 也有权获得同样一份数据, 并且将它们按照日志记录的格式写载哪里? 缓冲区? 还是文件? 它会形成一个具体的文件吗?<br>2. 子进程bgrewriteaof记录完日志, 和主进程执行命令是同步的吗? 只有同步, 才会宕机不丢失日志<br>3. 基于2, 宕机时, AOF重写日志可用, AOF日志丢失, AOF重写日志是怎么替换AOF日志的?","like_count":0},{"had_liked":false,"id":264632,"user_name":"圆圆满满","can_delete":false,"product_type":"c1","uid":1484192,"ip_address":"","ucode":"396E7A822014D1","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","comment_is_top":false,"comment_ctime":1606553829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606553829","product_id":100056701,"comment_content":"咨询老师一个问题，Redis是否能够保证数据100%不丢失？如果能，该怎么做才能保证不丢失？","like_count":0},{"had_liked":false,"id":263675,"user_name":"BertGeek","can_delete":false,"product_type":"c1","uid":1452799,"ip_address":"","ucode":"8E1D72C9F9778C","user_header":"https://static001.geekbang.org/account/avatar/00/16/2a/ff/a9d72102.jpg","comment_is_top":false,"comment_ctime":1606215578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606215578","product_id":100056701,"comment_content":"对redis有了新的认识，有几个疑问，请老师解答，非常感谢！<br><br>1. bgwriteaof子进程重写日志，对于新写入的数据，如果处理？何时达到数据一致？<br>   1) 如果有新数据写入，主进程继续回原来的日志文件，<br>   2) 在bgrewriteaof子进程中是没有这份数据的，主进程是开了一片缓存区保存这份数据的，<br>   3) 在bgrewriteaof子进程重写日志完成，才会将这缓存新热数据写入新的日志文件中<br>   4）原子重命名替换掉原来的日志文件。   <br><br>2. 重写AOF日志的时候如果Redis挂了重启，那重写AOF日志会接着之前的进度重写AOF日志还是重新从头开始写啊？<br><br>3. 使用redis aof 备份和恢复、迁移，对版本有强一致性要求么？<br><br><br><br><br><br><br>","like_count":0},{"had_liked":false,"id":262170,"user_name":"Cloud_July","can_delete":false,"product_type":"c1","uid":1003699,"ip_address":"","ucode":"98646F7142CBFF","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL8L7Am3u37GO6CWKqBbI02DZ2ss3IZb0F9OLewAS446vh3aicndQ255HjEDzIldBUhRpUbL04rnDA/132","comment_is_top":false,"comment_ctime":1605635576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605635576","product_id":100056701,"comment_content":"重写其实是在某个时刻对当前的内存库数据记录了一份set日志吧，没有使用aof日志做合并，这样的话重写跟aof类似，也会存在重写频率的问题吧，同时又类似RDB，只不过RDB是快照，直接记录的record，而重写是记录的set 操作，类似mysql的redo log 跟binlog row模式，不知道理解的对不对","like_count":0},{"had_liked":false,"id":261694,"user_name":"对与错","can_delete":false,"product_type":"c1","uid":1682027,"ip_address":"","ucode":"EF55733E3BD78B","user_header":"https://static001.geekbang.org/account/avatar/00/19/aa/6b/ab9a072a.jpg","comment_is_top":false,"comment_ctime":1605491549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605491549","product_id":100056701,"comment_content":"请问，bgwriteaof子进程只是用来把键值数据库中的数据重写为操作指令，然后放到AOF重写日志中吗，这个子进程应该不会往AOF重写缓冲区里面加数据吧，等到重写完成之后，再把重写日志与重写缓冲区内的数据合并作为新的AOF日志，我这样理解是对的吗？还有子进程在重写期间不会因为父进程有新的写入操作，而拷贝出新的内存空间？","like_count":0},{"had_liked":false,"id":259266,"user_name":"Geek_52fe14","can_delete":false,"product_type":"c1","uid":2213840,"ip_address":"","ucode":"2948724BF5815E","user_header":"","comment_is_top":false,"comment_ctime":1604665696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604665696","product_id":100056701,"comment_content":"aof缓冲区是不是宕机数据不会丢失","like_count":0},{"had_liked":false,"id":258766,"user_name":"明月几时","can_delete":false,"product_type":"c1","uid":1675716,"ip_address":"","ucode":"E46C844EAB2CD0","user_header":"https://static001.geekbang.org/account/avatar/00/19/91/c4/bcdcda65.jpg","comment_is_top":false,"comment_ctime":1604551653,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604551653","product_id":100056701,"comment_content":"为了避免日志文件过大，Redis 提供了 AOF 重写机制，直接根据数据库里数据的最新状态，生成这些数据的插入命令，作为新日志。这个过程通过后台线程完成，避免了对主线程的阻塞！","like_count":0},{"had_liked":false,"id":257661,"user_name":"漂泊者及其影子","can_delete":false,"product_type":"c1","uid":1119979,"ip_address":"","ucode":"13FE760FE8B111","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/eb/30864e40.jpg","comment_is_top":false,"comment_ctime":1604050335,"is_pvip":false,"replies":[{"id":"98034","content":"同时开启RDB和AOF时，会优先使用AOF文件进行恢复，因为相比RDB，AOF文件保存的命令操作通常更全些。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609111318,"ip_address":"","comment_id":257661,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604050335","product_id":100056701,"comment_content":"问个问题：redis同时开启RDB和AOF，redis重启基于哪个文件进行数据恢复","like_count":0,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508407,"discussion_content":"同时开启RDB和AOF时，会优先使用AOF文件进行恢复，因为相比RDB，AOF文件保存的命令操作通常更全些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609111318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256324,"user_name":"明月几时","can_delete":false,"product_type":"c1","uid":1675716,"ip_address":"","ucode":"E46C844EAB2CD0","user_header":"https://static001.geekbang.org/account/avatar/00/19/91/c4/bcdcda65.jpg","comment_is_top":false,"comment_ctime":1603599433,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603599433","product_id":100056701,"comment_content":"父子两个进程本来就没有需要竞争的数据，老师所指的两个日志应该是“AOF缓冲区”和&quot;AOF重写缓冲区&quot;，而不是磁盘上的AOF文件，之所有另外有一个&quot;AOF重写缓冲区&quot;，是因为重写期间，主进程AOF还在继续工作，还是会同步到旧的AOF文件中，同步成功后，“AOF缓冲区”会被清除，会被清除，会被清除！","like_count":0},{"had_liked":false,"id":254783,"user_name":"Reborn 2.0","can_delete":false,"product_type":"c1","uid":1977474,"ip_address":"","ucode":"BA506E7455D91C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","comment_is_top":false,"comment_ctime":1603186243,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603186243","product_id":100056701,"comment_content":"老师你好, 我想问一个问题: 在&#39;AOF非阻塞的重写过程&#39;配图里, 在AOF重写时候, 主进程维护了两个AOF缓冲: 一个是原来的AOF缓冲, 另一个是AOF重写缓冲. <br>我想问: 为什么需要维护AOF重写缓冲? 它的内容是包含在AOF缓冲里面的, 记录一个AOF缓冲里面的offset, 然后等数据重写好了, 再从offset开始把新的AOF写出去不好么?","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392861,"discussion_content":"aof缓冲是会按既定规则刷盘的，刷完就没了。所以要俩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631157544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253433,"user_name":"Just Do IT","can_delete":false,"product_type":"c1","uid":1192724,"ip_address":"","ucode":"1EAD92510FA7BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/14/78104f1f.jpg","comment_is_top":false,"comment_ctime":1602737037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602737037","product_id":100056701,"comment_content":"这句话不太理解，为何数据不丢失呢？缓存区在内存啊  宕机的话   数据还没有持久化完成 一样可以丢失的啊<br><br>Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。","like_count":0},{"had_liked":false,"id":253130,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1602605981,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602605981","product_id":100056701,"comment_content":"文中说的，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。<br>  问个问题，  缓存区不是也没写盘么，宕机了，为啥可以恢复？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392865,"discussion_content":"意思是aof日志缓冲区刷盘很快，丢数据最低可以控制到1s，业务能容忍。第二处那个重写aof日志缓存应该没这个刷盘的，只做回放","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631157936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252816,"user_name":"Hinimix","can_delete":false,"product_type":"c1","uid":1316937,"ip_address":"","ucode":"7994136C93BD89","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/49/b1d864e5.jpg","comment_is_top":false,"comment_ctime":1602493077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602493077","product_id":100056701,"comment_content":"Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。<br>这句话不太理解：为什么宕机了缓冲区里的属于还是齐全的呢，这个缓冲区是不是磁盘的buffer，即使宕机也会有磁盘保护存储，不会丢失数据","like_count":0},{"had_liked":false,"id":252505,"user_name":"Hinimix","can_delete":false,"product_type":"c1","uid":1316937,"ip_address":"","ucode":"7994136C93BD89","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/49/b1d864e5.jpg","comment_is_top":false,"comment_ctime":1602322394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602322394","product_id":100056701,"comment_content":"为什么宕机后能从缓冲区恢复呢，进程buffer应该释放了啊","like_count":0},{"had_liked":false,"id":252335,"user_name":"张小帅","can_delete":false,"product_type":"c1","uid":1682461,"ip_address":"","ucode":"0011E6BF1A4C02","user_header":"https://static001.geekbang.org/account/avatar/00/19/ac/1d/c8f41fce.jpg","comment_is_top":false,"comment_ctime":1602242925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602242925","product_id":100056701,"comment_content":"aof重写的时候会把主线程执行的命令也同步一份放到重写缓冲区，重写缓冲区应该有大小限制吧，如果放满了但是重写还未结束，会怎么处理呢","like_count":0},{"had_liked":false,"id":252225,"user_name":"Li Yao","can_delete":false,"product_type":"c1","uid":1129838,"ip_address":"","ucode":"703E1E5505F70D","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/6e/60680aa4.jpg","comment_is_top":false,"comment_ctime":1602203373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602203373","product_id":100056701,"comment_content":"AOF日志写入方式是尾部追加写入，文件比较大时，这种方式写入也会有效率问题吗？","like_count":0},{"had_liked":false,"id":252195,"user_name":"youngitachi","can_delete":false,"product_type":"c1","uid":1214582,"ip_address":"","ucode":"88717CA8B8ED64","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/76/c69b7fe5.jpg","comment_is_top":false,"comment_ctime":1602169929,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602169929","product_id":100056701,"comment_content":"老师，有个问题想请教下。<br>重写AOF日志的时候如果Redis挂了重启，那重写AOF日志会接着之前的进度重写AOF日志还是重新从头开始写啊？","like_count":0},{"had_liked":false,"id":251953,"user_name":"while (1)等;","can_delete":false,"product_type":"c1","uid":1061991,"ip_address":"","ucode":"BAEC7258D65B69","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/67/06a7f9be.jpg","comment_is_top":false,"comment_ctime":1601999605,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601999605","product_id":100056701,"comment_content":"老师好，AOF重写是如何设置的？频率是怎么定的？","like_count":0},{"had_liked":false,"id":251857,"user_name":"xmebcc","can_delete":false,"product_type":"c1","uid":1370407,"ip_address":"","ucode":"B6114A7FC56B37","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKV03icibEjdnG9Bo9uy31KAHHRIQMtdC7UjadibOiaDMcsH8tcV5acpmMvTk7WJTXgK8ovZ5ibrGib9cRA/132","comment_is_top":false,"comment_ctime":1601909864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601909864","product_id":100056701,"comment_content":"有点类似MySQL copy_inplace","like_count":0},{"had_liked":false,"id":251309,"user_name":"油纸伞","can_delete":false,"product_type":"c1","uid":2212143,"ip_address":"","ucode":"C2655B9F8874E2","user_header":"https://static001.geekbang.org/account/avatar/00/21/c1/2f/5c8167aa.jpg","comment_is_top":false,"comment_ctime":1601458033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601458033","product_id":100056701,"comment_content":"有个疑问，如果写入内存成功了，在写入aof日志的时候失败了有处理机制吗？","like_count":0},{"had_liked":false,"id":251246,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1601435330,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601435330","product_id":100056701,"comment_content":"关于 AOF 重写阻塞问题总结下<br>1. fork 的瞬间一定会阻塞主线程<br>2. 还是 fork 之后主子进程申请内容时, Huge Page 导致大量的读写内存, 可能导致阻塞, 降低性能  <br>3. 在最后主进程向AOF新文件写入AOF重写缓存和改名操作会造成主进程阻塞","like_count":0},{"had_liked":false,"id":250530,"user_name":"绝尘而去","can_delete":false,"product_type":"c1","uid":1252567,"ip_address":"","ucode":"690E4E6B3E39DD","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","comment_is_top":false,"comment_ctime":1601118025,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601118025","product_id":100056701,"comment_content":"“”此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。”<br>老师，文中的这段描述没太看懂，应该是父进程会把重写期间的写操作写入到旧日志文件中，所以即使重写期间宕机，也可以恢复吧。","like_count":0},{"had_liked":false,"id":250084,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1600929528,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1600929528","product_id":100056701,"comment_content":"incr操作怎么办，不幂等啊？","like_count":0,"discussions":[{"author":{"id":1400806,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/e6/19778e70.jpg","nickname":"Mr.埃克斯","note":"","ucode":"855BE5DFD2BB0B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351016,"discussion_content":"感觉会像binlog一样转成设置具体值的命令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614122038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249926,"user_name":"Guess","can_delete":false,"product_type":"c1","uid":1113416,"ip_address":"","ucode":"E436F153183E25","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/48/241e16a8.jpg","comment_is_top":false,"comment_ctime":1600855459,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1600855459","product_id":100056701,"comment_content":"问题描述：<br>1. redis在开启aof日志有三种写入模式Always、Everysec、No这三种模式。<br>2. aof重写是为了缩小aof日志<br>问题：<br>1.  如果aof的写入是always策略，是不是也有aof重写？<br>2. aof重写是不是都是需要重新读取aof日志，重写完成后替代原来的aof日志吗？<br>3. 如果在always策略下，且可以进行aof日志重写的话。那在aof重写的时候新来的操作日志会不会落到aof日志。如果是的话，还是原来的aof日志吗？","like_count":0,"discussions":[{"author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308936,"discussion_content":"你的三个问题都如你所想。建议去看官方文档，都有答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601126414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249687,"user_name":"差不多先生","can_delete":false,"product_type":"c1","uid":1636228,"ip_address":"","ucode":"AB2D3EB98DC765","user_header":"https://static001.geekbang.org/account/avatar/00/18/f7/84/85983bab.jpg","comment_is_top":false,"comment_ctime":1600761436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600761436","product_id":100056701,"comment_content":"为什么AOF后台重写要用子进程而不是用子线程","like_count":0},{"had_liked":false,"id":249644,"user_name":"小西几","can_delete":false,"product_type":"c1","uid":1286375,"ip_address":"","ucode":"ED1DDE17534508","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjzTQ6HPGw2LWLiaiciaibfdMMlmxEwBkBjxOPxeYynZlBKCf6U1b0ezM9IZYibB6yKR7HpRuAOdtj29Q/132","comment_is_top":false,"comment_ctime":1600739071,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1600739071","product_id":100056701,"comment_content":"老师你好，碰到一个问题：最近想做redis 数据迁移从单例迁移到集群。单例是配置文件关闭持久化的。<br>当使用bgsave 命令手动持久化时，持久化数据并没有保存在config get dir的目录里，并且lastsave 查看也是很久之前保存的时间，直接使用save，则直接报错。<br>以下是命令执行的结果：<br><br>127.0.0.1:6379&gt; CONFIG GET dir<br>1) &quot;dir&quot;<br>2) &quot;&#47;usr&#47;local&#47;redis&#47;bin&quot;<br>127.0.0.1:6379&gt; BGSAVE<br>Background saving started<br>127.0.0.1:6379&gt; LASTSAVE<br>(integer) 1568101339<br>127.0.0.1:6379&gt;<br><br># ls &#47;usr&#47;local&#47;redis&#47;bin<br>nohup.out  redis-benchmark  redis-check-aof  redis-check-rdb  redis-cli  redis.conf  redis-sentinel  redis-server<br><br>127.0.0.1:6379&gt; save<br>(error) ERR<br><br>请问老师，我该如何解决这个持久化的问题？<br><br>","like_count":0,"discussions":[{"author":{"id":1286375,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjzTQ6HPGw2LWLiaiciaibfdMMlmxEwBkBjxOPxeYynZlBKCf6U1b0ezM9IZYibB6yKR7HpRuAOdtj29Q/132","nickname":"小西几","note":"","ucode":"ED1DDE17534508","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309185,"discussion_content":"已解决权限问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601209296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249384,"user_name":"pippin","can_delete":false,"product_type":"c1","uid":1784022,"ip_address":"","ucode":"F7619FCE24D481","user_header":"","comment_is_top":false,"comment_ctime":1600617434,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1600617434","product_id":100056701,"comment_content":"不知道我这样说的对不对。 appendfsync设置的是always，就是同步写回，在bgrewriteaof子进程重写日志时，如果有日志数据写入，主进程还是直接同步将操作写回原来的日志文件，而在bgrewriteaof子进程中是没有这份数据的，主进程是开了一片缓存区保存这份数据的，在bgrewriteaof子进程重写日志完成，再将这份缓存写入新的日志文件中，最后替换掉原来的日志文件。而在主进程有个bigkey操作时，这时候造成的阻塞和是否在重写日志是没有关系的，这个操作无论何时操作都是会造成主进程的阻塞的。所以huge page这个也不是只有在重写日志才会出现的。而老师的第一问，问的是重写过程时，有没有其它阻塞风险。那这么问的话，我会想到阻塞是由重写过程造成的。但@kaito回答的重写过程中父进程产生写入的场景操作bigkey会造成阻塞是不仅仅在重写过程中才会出现。不知道我这样理解的对不对，搞的我有点混乱。","like_count":0,"discussions":[{"author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307396,"discussion_content":"还有在bgrewriteaof子进程重写日志完成后，主进程中缓存的那部分操作写入新的日志文件中会不会阻塞主进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600618124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248851,"user_name":"yinzhiping","can_delete":false,"product_type":"c1","uid":2114235,"ip_address":"","ucode":"71C74CE6F62FF8","user_header":"","comment_is_top":false,"comment_ctime":1600334515,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1600334515","product_id":100056701,"comment_content":"我们啥时候会使用新的AOF文件替代久的AOF文件呢？","like_count":0,"discussions":[{"author":{"id":1073443,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/23/30d134cf.jpg","nickname":"Young","note":"","ucode":"075C0BBE20FD8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371084,"discussion_content":"子进程完成AOF重写后，它向父进程发送一个信号，父进程收到信号后会调用一个信号处理函数，该函数把AOF重写缓冲区的命令追加到新AOF文件中然后替换掉现有AOF文件。父进程处理完毕后可以继续接受客户端命令调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619625569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308937,"discussion_content":"子进程重写完，父进程把增量的aof日志追加到新的aof文件，就会进行替换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601126618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247960,"user_name":"深蓝","can_delete":false,"product_type":"c1","uid":1035807,"ip_address":"","ucode":"85C7094E3A5289","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/1f/220c6d83.jpg","comment_is_top":false,"comment_ctime":1599955652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599955652","product_id":100056701,"comment_content":"问题1、主线程写入AOF重写日志缓存时会阻塞AOF重写子进程<br>问题2、共用会出现脏数据和阻塞的情况","like_count":0},{"had_liked":false,"id":247739,"user_name":"xanxus","can_delete":false,"product_type":"c1","uid":1654600,"ip_address":"","ucode":"FFF1EFD2ABCBAA","user_header":"","comment_is_top":false,"comment_ctime":1599813054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599813054","product_id":100056701,"comment_content":"原文中这样描述“我们以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。” 看上下文的描述，难道$+数字，的数字存的不应该是字符数量，而不是字节数量吗？？","like_count":0},{"had_liked":false,"id":246932,"user_name":"Onyanga","can_delete":false,"product_type":"c1","uid":1272825,"ip_address":"","ucode":"DF4D22F0D51881","user_header":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","comment_is_top":false,"comment_ctime":1599533913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599533913","product_id":100056701,"comment_content":"AOF的写回策略：Everysec和No是同步的还是异步的。","like_count":0},{"had_liked":false,"id":246826,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1599487373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599487373","product_id":100056701,"comment_content":"aof aways是否存在丢失一个命令的风险？","like_count":0},{"had_liked":false,"id":245850,"user_name":"Geek_27a248","can_delete":false,"product_type":"c1","uid":1542778,"ip_address":"","ucode":"6AC3AC42E6EEC9","user_header":"https://static001.geekbang.org/account/avatar/00/17/8a/7a/54003392.jpg","comment_is_top":false,"comment_ctime":1599094498,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599094498","product_id":100056701,"comment_content":"老师，我有个地方不解，可能是基础不好的原因，如果aof还原时此时主线程对aof文件中记录的key进行修改操作，此时的aof还原流程就变成什么样子的呢，是覆盖掉新值，然后主线程新的值继续追加日志到aof文件中吗","like_count":0,"discussions":[{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308218,"discussion_content":"Aof还原时系统是不可用的，还原完成后才可以写入","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600870763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245291,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1598885725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598885725","product_id":100056701,"comment_content":"老师好，请问 在说明“两处日志”的时候说的缓冲区是内存还是磁盘，如果是内存，为什么又说宕机了 AOF 的日志还是全的，如果是磁盘，和下面的示意图似乎对不上号。","like_count":0},{"had_liked":false,"id":245037,"user_name":"大帅哥","can_delete":false,"product_type":"c1","uid":1439523,"ip_address":"","ucode":"E6AE4804D9F337","user_header":"","comment_is_top":false,"comment_ctime":1598791902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598791902","product_id":100056701,"comment_content":"即使使用aof重新机制，日志文件依然可能很大，如果文件还是过大，redis是怎么处理的呢","like_count":0},{"had_liked":false,"id":244662,"user_name":"Bug Killer","can_delete":false,"product_type":"c1","uid":1186089,"ip_address":"","ucode":"2741A206F504E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/19/29/4a8214b7.jpg","comment_is_top":false,"comment_ctime":1598606284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598606284","product_id":100056701,"comment_content":"问个奇怪的问题：频繁的对文件进行Io会不会有性能问题呀。对appendonly.aof进行每秒追加写，追加写应该每秒都会持久化到硬盘吧。","like_count":0},{"had_liked":false,"id":243877,"user_name":"Aaron","can_delete":false,"product_type":"c1","uid":1066251,"ip_address":"","ucode":"B0C504A76297C7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/0Qp9pxHBvgdZAveKzsvUFFUicCJfe7ONzhC7jSNFQDNFvg0jRMXuqqZOdxG1qKosylUYrpIHUR2Q76w5m4HtVkg/132","comment_is_top":false,"comment_ctime":1598318273,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1598318273","product_id":100056701,"comment_content":"Redis存在两份日志，一份是原有的aof日志，一个是重写日志，重写日志的目的是减少占用磁盘的空间，那么原有的aof日志是不是会找个合适的时机清楚呢？","like_count":0,"discussions":[{"author":{"id":1073443,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/23/30d134cf.jpg","nickname":"Young","note":"","ucode":"075C0BBE20FD8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371085,"discussion_content":"子进程完成AOF重写后，它向父进程发送一个信号，父进程收到信号后会调用一个信号处理函数，该函数把AOF重写缓冲区的命令追加到新AOF文件中然后替换掉现有AOF文件。父进程处理完毕后可以继续接受客户端命令调用，","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619625716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073236,"avatar":"https://static001.geekbang.org/account/avatar/00/10/60/54/b3eb605b.jpg","nickname":"阿牛","note":"","ucode":"DC8C189FCF3289","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358530,"discussion_content":"当子进程完成对AOF文件重写之后，AOF重写缓存中的内容全部写入到新的AOF文件中；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615991759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242457,"user_name":"Jerry You","can_delete":false,"product_type":"c1","uid":2107375,"ip_address":"","ucode":"679A44B505482F","user_header":"https://static001.geekbang.org/account/avatar/00/20/27/ef/a7f94eda.jpg","comment_is_top":false,"comment_ctime":1597733721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597733721","product_id":100056701,"comment_content":"aof的缓冲和aof重写缓冲都是应对记录fork之后的写请求命令的，相当于fork之后的aof功能，最后fork结束之前，需要把对应的aof缓冲文件拿过来更新到最新的文件中吧？是这样理解的么？还有aof重写机制是什么时候触发的？","like_count":0},{"had_liked":false,"id":242367,"user_name":"小黑","can_delete":false,"product_type":"c1","uid":1218205,"ip_address":"","ucode":"DCED6B71BE7687","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dlIBXlicZrol7KX8l8QQu7nUpYhpBP5YIIdXe8RliatHdPU4licxiboqjMjJbJSaUpmib1iaIarMlgrtxpRjgOd2WYLw/132","comment_is_top":false,"comment_ctime":1597681776,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597681776","product_id":100056701,"comment_content":"请问老师，比如一个极端的情况，在配置文件中auto-aof-rewrite-min-size设置了64m，如果aof重写后还是超过64m，会发生什么呢？","like_count":0,"discussions":[{"author":{"id":1339620,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epN7EVEDiaCBHwbQdZpqgMQRbq0lCWYt2ITaY4a7CEJ0iaGg7zN0m5sLZPviaMFluVfNsFGCL8EChYHw/132","nickname":"晓翔","note":"","ucode":"53D92FCC111DA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299742,"discussion_content":"auto-aof-rewrite-min-size 是设置允许重写的最小aof文件大小,避免了达到约定百分比(即auto-aof-rewrite-percentage配置)但文件仍然很小的情况还要重写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597804149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242031,"user_name":"Geek_Lin","can_delete":false,"product_type":"c1","uid":2120990,"ip_address":"","ucode":"3C887B8E6FF3B9","user_header":"","comment_is_top":false,"comment_ctime":1597566542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597566542","product_id":100056701,"comment_content":"1.操作系统控制的写回：由操作系统决定何时将缓冲区内容写回磁盘，操作系统怎么决定的呢？<br>2.Redis是不是只有一个AOF文件，读文章感觉是，那么如果只有一个文章的话，追加写入操作，那么恢复的时候，如何知道从那一条操作开始呢？<br>","like_count":0},{"had_liked":false,"id":242030,"user_name":"Geek_Lin","can_delete":false,"product_type":"c1","uid":2120990,"ip_address":"","ucode":"3C887B8E6FF3B9","user_header":"","comment_is_top":false,"comment_ctime":1597566063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597566063","product_id":100056701,"comment_content":"每次都要把评论区看一遍，收获很大！！","like_count":0},{"had_liked":false,"id":241844,"user_name":"tiny🌾","can_delete":false,"product_type":"c1","uid":1119851,"ip_address":"","ucode":"7A4DE00381D1F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/6b/af7c7745.jpg","comment_is_top":false,"comment_ctime":1597464237,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597464237","product_id":100056701,"comment_content":"有一个问题<br>Bgaof在用拷贝的内存重写aof，在这期间主进程内存数据更新了，不就和bgaof写的内存不一样，最后用bgaof的重写日志哪不是久数据？","like_count":0},{"had_liked":false,"id":241751,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1597410378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597410378","product_id":100056701,"comment_content":"先记日志再执行命令，一般会对记录操作的语法有效性做检查，这个阶段需要解析操作命令，避免日志redo失败，但是这个方法会影响一定写性能。","like_count":0},{"had_liked":false,"id":241404,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1597285226,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597285226","product_id":100056701,"comment_content":"两个日志的合并，是分离后，主进程写的日志，往子进程的重写日志里合并吧？感觉文中这点没写清楚？","like_count":0,"discussions":[{"author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308794,"discussion_content":"我也觉得是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601085406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241342,"user_name":"Leslie_Lamport","can_delete":false,"product_type":"c1","uid":1315517,"ip_address":"","ucode":"62997381D754A9","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/bd/19d31e64.jpg","comment_is_top":false,"comment_ctime":1597258850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597258850","product_id":100056701,"comment_content":"“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。<br><br><br>— 拷贝数据的cost多大？","like_count":0},{"had_liked":false,"id":241335,"user_name":"AstonPutting","can_delete":false,"product_type":"c1","uid":1303239,"ip_address":"","ucode":"1DB579A7922964","user_header":"https://static001.geekbang.org/account/avatar/00/13/e2/c7/d6a0927a.jpg","comment_is_top":false,"comment_ctime":1597249731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597249731","product_id":100056701,"comment_content":"既然aof是以文本的形式记录redis的操作，是不是也可以用于不同Redis版本之间的备份与恢复，比如说redis4的aof日志恢复到redis3上","like_count":0},{"had_liked":false,"id":241263,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1597231092,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1597231092","product_id":100056701,"comment_content":"redis重写机制只针对还没有写入磁盘的信息吗？","like_count":0,"discussions":[{"author":{"id":1539926,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUBia0Aevb2CyMNPvuzTkVvlcoDpdFELFav5Bcic90wxehZibo0VglM7aRZLMo93Ful7v5TFlKfEYyg/132","nickname":"啊不多","note":"","ucode":"A38DE3C564B748","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298526,"discussion_content":"应该针对整个aof文件中的所有记录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597317545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241248,"user_name":"梨还羽","can_delete":false,"product_type":"c1","uid":1243267,"ip_address":"","ucode":"F6C89EF10DFC89","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/83/008b7b58.jpg","comment_is_top":false,"comment_ctime":1597223086,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597223086","product_id":100056701,"comment_content":"aof重写的触发条件：<br>1. 手动执行bgrewriteaof触发aof重写<br>2. 配置redis.conf文件的aof重写条件，如auto-aof-rewrite-min-size和auto-aof-rewrite-min-percenrage","like_count":0,"discussions":[{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298307,"discussion_content":"第一个是文件的大小，第二个是超过基准值的百分比，默认是100 ，也就两倍的基准值大小触发 aof","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597243063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241207,"user_name":"Mr.蜜","can_delete":false,"product_type":"c1","uid":1035257,"ip_address":"","ucode":"C911B81198B3F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","comment_is_top":false,"comment_ctime":1597216232,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"1597216232","product_id":100056701,"comment_content":"一开始说主线程fork一个子进程处理AOF，后面又说是子线程，到底是进程还是线程？AOF 会复制一份内存给子进程保存数据？如果内存不够怎么办？麻烦作者解释清楚，谢谢。","like_count":0,"discussions":[{"author":{"id":1370132,"avatar":"","nickname":"Geek_LV","note":"","ucode":"612BF99F9843F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298243,"discussion_content":"理论上需要两倍的内存。但Linux有copy-on-write 机制，父子进程会共享相同的物理内存页。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597226718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1035257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","nickname":"Mr.蜜","note":"","ucode":"C911B81198B3F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1370132,"avatar":"","nickname":"Geek_LV","note":"","ucode":"612BF99F9843F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":298355,"discussion_content":"是的，但这个知识点很重要，老师没有提，这实属不应该，因为目前大多数redis不可能因为要备份，而预留一半内存，何况就算纯复制，几十g内存也不是这么快能复制出来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597278839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298243,"ip_address":""},"score":298355,"extra":""},{"author":{"id":1035257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","nickname":"Mr.蜜","note":"","ucode":"C911B81198B3F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1370132,"avatar":"","nickname":"Geek_LV","note":"","ucode":"612BF99F9843F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":298359,"discussion_content":"而且他一会儿子线程，一会儿又子进程，完全不清楚他有没有搞清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597279482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298243,"ip_address":""},"score":298359,"extra":""},{"author":{"id":2108046,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLoAicus6PVAO7SJzBmPMsQ4AISV0IZTvFkQ5fzicA3VJ8GZbAFhtqZZkOCrnSiaPkYgTianK5gvmLsuQ/132","nickname":"Geek_dac7ff","note":"","ucode":"CA90CDD5AA0077","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1035257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","nickname":"Mr.蜜","note":"","ucode":"C911B81198B3F5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301512,"discussion_content":"首先，linux对进程和线程不做区分，统一由task_struct来管理所有进程和线程。 所谓的线程进程的区别，不过是是否和主进程共享内存空间。linux中，一个进程可以理解为这个进程的主线程，所以叫主线程没问题。进程可以通过 fork 创建子进程，也可以pthread_create 创建线程。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598542361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298359,"ip_address":""},"score":301512,"extra":""}]}]},{"had_liked":false,"id":241187,"user_name":"ikel","can_delete":false,"product_type":"c1","uid":1009002,"ip_address":"","ucode":"1D5CE7803C1C2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/6a/be36c108.jpg","comment_is_top":false,"comment_ctime":1597210914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597210914","product_id":100056701,"comment_content":"1、主线程的新数据同步到子进程时候可能会有socket阻塞<br>2、可能是考虑到加锁会有效率降低吧","like_count":0},{"had_liked":false,"id":241182,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1597209359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597209359","product_id":100056701,"comment_content":"写原来的AOF文件有可能会造成污染吧，万一写失败了，很难决定是回滚原来的写操作还是下次从指定位置开始写。而且也会存在资源竞争的问题。所以不如写完直接替换更加方便","like_count":0},{"had_liked":false,"id":241176,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1597208195,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1597208195","product_id":100056701,"comment_content":"老师我想问的是，什么时候会触发 aof 的重写机制，是定时触发还是被动条件的触发","like_count":0,"discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298198,"discussion_content":"你想，AOP重写是为了避免文件太大导致恢复的时候很慢，所以，应该是文件占用到一定比例的时候就会触发重写，可能有相关策略可以选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597218719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241156,"user_name":"林佳钦","can_delete":false,"product_type":"c1","uid":1453295,"ip_address":"","ucode":"A21E83E64933DE","user_header":"https://static001.geekbang.org/account/avatar/00/16/2c/ef/b04a2da2.jpg","comment_is_top":false,"comment_ctime":1597204360,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597204360","product_id":100056701,"comment_content":"第一个小问题. 这个也是我想问的问题，AOF fork的时候，fork也是一个阻塞的操作，这个过程不会造成主进程无法处理吗？<br>第二个小问题：是因为两个进程共享内存的访问效率问题？","like_count":0,"discussions":[{"author":{"id":1453295,"avatar":"https://static001.geekbang.org/account/avatar/00/16/2c/ef/b04a2da2.jpg","nickname":"林佳钦","note":"","ucode":"A21E83E64933DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298164,"discussion_content":"做梦梦到了，第二个问题是不是因为aof重写日志会替换原来的aof日志？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597207728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241136,"user_name":"al-byte","can_delete":false,"product_type":"c1","uid":1466744,"ip_address":"","ucode":"D0298A02E9259D","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/78/e7aa4e04.jpg","comment_is_top":false,"comment_ctime":1597200017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597200017","product_id":100056701,"comment_content":"AOF重写日志完成以后会覆盖旧的AOF日志，这个过程主线程应该会被阻塞吧如果日志文件过大还是会有阻塞风险的<br>","like_count":0},{"had_liked":false,"id":241131,"user_name":"OAuth","can_delete":false,"product_type":"c1","uid":1234664,"ip_address":"","ucode":"691F528EB533B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/e8/50b58ed8.jpg","comment_is_top":false,"comment_ctime":1597198425,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597198425","product_id":100056701,"comment_content":"为什么在使用AOF日志和AOF重写日志时，把操作写入各自的缓冲区，宕机了，日志也是完整的？缓冲区里的数据不会因为宕机丢失吗？没看明白","like_count":0},{"had_liked":false,"id":241104,"user_name":"小氘","can_delete":false,"product_type":"c1","uid":1622109,"ip_address":"","ucode":"DA55B9A02D9EE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","comment_is_top":false,"comment_ctime":1597193134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597193134","product_id":100056701,"comment_content":"课后思考题：我觉得&quot;一个拷贝&quot;过程中会阻塞主线程，开启拷贝时主线程无法对外服务，等数据拷贝完成后才行。","like_count":0},{"had_liked":false,"id":241102,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1597192848,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597192848","product_id":100056701,"comment_content":"子线程在重写的过程中，突然宕机了，重新只完成部分，其他部分丢失的风险；<br>如果共享就会出现重写日志刚写完，原日志正好更新，造成了重写日志数据不一致","like_count":0,"discussions":[{"author":{"id":1073236,"avatar":"https://static001.geekbang.org/account/avatar/00/10/60/54/b3eb605b.jpg","nickname":"阿牛","note":"","ucode":"DC8C189FCF3289","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358528,"discussion_content":"当子进程完成对AOF文件重写之后，它会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：\n1、将AOF重写缓存中的内容全部写入到新的AOF文件中；这个时候新的AOF文件所保存的数据库状态和服务器当前的数据库状态一致；\n2、对新的AOF文件进行改名，原子的覆盖原有的AOF文件；完成新旧两个AOF文件的替换。\n所以不会出现上述问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615991595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241099,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1597192541,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597192541","product_id":100056701,"comment_content":"我也有一个问题。<br><br>bgrewriteaof 子进程完成日志重写后的文件会和主线程产生的AOF文件合并么？<br><br>子进程的内存是拷贝自主线程的内存，操作系统在拷贝的时候不会真正的分配内存页，只有当主线程对某一个内存数据进行修改时，才会为子进程真正地分配内存页。我觉得重新分配的内存页太多时可能会发生阻塞。<br><br>那么，问题又来了。此时两个AOF文件对应的内存中同一个键的值已经不一致了，所以我觉得AOF重写日志是一个“基线”，在恢复数据时，应该先重放子进程的日志，然后再叠加主线程的AOF日志，这样才能恢复完整的数据。<br><br>不知道这么理解对么？","like_count":0,"discussions":[{"author":{"id":1073443,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/23/30d134cf.jpg","nickname":"Young","note":"","ucode":"075C0BBE20FD8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371088,"discussion_content":"子进程完成AOF重写后，它向父进程发送一个信号，父进程收到信号后会调用一个信号处理函数，该函数把AOF重写缓冲区的命令追加到新AOF文件中然后替换掉现有AOF文件。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619627114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241086,"user_name":"25ma","can_delete":false,"product_type":"c1","uid":1303713,"ip_address":"","ucode":"AB5435B9DB52C9","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/a1/178387da.jpg","comment_is_top":false,"comment_ctime":1597188914,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1597188914","product_id":100056701,"comment_content":"老师，我有一个疑问，之前说过Redis是单进程的，那现在这节怎么一直在强调Redis主线程这个概念，文中提及的主线程是主进程的主线程吗？还请老师解惑，谢谢","like_count":0,"discussions":[{"author":{"id":1157674,"avatar":"https://static001.geekbang.org/account/avatar/00/11/aa/2a/ce7c487d.jpg","nickname":"Terence孫","note":"","ucode":"8C3A89C18A2182","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298953,"discussion_content":"Redis处理内存那些主要的数据是用的一个线程，一个进程可以创建多个线程，这几个线程的资源是不共享，效能也是根据CPU每个核的线程有关，Redis处理一些日志或者集群等非核心功能的时候，会启动多个线程进行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597489640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298167,"discussion_content":"一个进程至少拥有一个线程。Redis 的单线程主要说明的是处理请求的线程只有一个，但是还是会有很多附属的线程在处理其他的事项。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597208121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130791,"avatar":"https://static001.geekbang.org/account/avatar/00/11/41/27/528144cc.jpg","nickname":"共和国长子","note":"","ucode":"C2F8F66FB23D3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298107,"discussion_content":"是单线程吧，不是但进程，那个单线程就是这个主线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597193805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}