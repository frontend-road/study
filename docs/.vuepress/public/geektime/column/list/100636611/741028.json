{"id":741028,"title":"第 6 章 Linux磁盘管理","content":"\n<p>在Windows下，我们可以非常直观地看到系统有多少个分区，每个分区使用多少、还剩多少。那么在Linux命令行下，如何进行这些操作呢？在Linux下的磁盘里面写数据也是有讲究的。如何分区？如何格式化？如何挂载？如何卸载？下面阿铭一一为大家解答这些问题。</p>\n<h2 id=\"nav_point_106\">6.1 查看磁盘或者目录的容量</h2>\n<p>监控磁盘的使用率在日常监控工作中是必须要做的，磁盘被写满是很要命的，严重时会导致磁盘损坏。那么，如何查看磁盘使用率呢？</p>\n<h3 id=\"nav_point_107\">6.1.1 命令<code>df</code></h3>\n<p>命令<code>df</code>（disk filesystem的简写）用于查看已挂载磁盘的总容量、使用容量、剩余容量等，其后可以不加任何参数，显示数据默认以KB为单位。示例命令如下：</p>\n<pre class=\"code-rows\"><code># df\n文件系统 1K-块 已用 可用 已用% 挂载点\ndevtmpfs 910288 0 910288 0% /dev\ntmpfs 924728 0 924728 0% /dev/shm\ntmpfs 924728 8868 915860 1% /run\ntmpfs 924728 0 924728 0% /sys/fs/cgroup\n/dev/sda3 16561152 1472276 15088876 9% /\n/dev/sda1 194235 121419 58480 68% /boot\ntmpfs 184944 0 184944 0% /run/user/0\ntmpfs 184944 0 184944 0% /run/user/1006</code></pre>\n<p>在上例的结果中，/、/boot是我们在安装系统时划分出来的。/dev、/dev/shm为内存分区，其大小默认是内存大小的1/2，如果我们把文件存到此分区下，就相当于存到了内存中，这样的好处是读写非常快，坏处是当系统重启时文件会丢失。后面的 /run、/sys/fs/cgroup等分区都是<code>tmpfs</code>，跟 /dev/shm类似，是临时文件系统，我们不要碰它们。<code>df</code>命令的常用选项有<code>-i</code>、<code>-h</code>、<code>-k</code>和<code>-m</code>，下面介绍这4个选项的用法。为了能更加简洁明了地让大家看到磁盘分区，在下面的示例中阿铭直接把与<code>tmpfs</code>相关的分区全部过滤掉了。</p><!-- [[[read_end]]] -->\n<ul>\n<li><p><strong><code>-i</code></strong>：表示查看<code>inode</code>的使用状况，如果已使用100%，那么即使磁盘空间有剩余，也会提示磁盘空间已满。示例命令如下：</p>\n<pre class=\"code-rows\"><code># df -i |grep -v tmpfs // grep -v的作用是过滤掉包含tmpfs字符串的行\n文件系统 Inode 已用(I) 可用(I) 已用(I)% 挂载点\n/dev/sda3 8285696 32458 8253238 1% /\n/dev/sda1 51200 309 50891 1% /boot</code></pre>\n</li>\n<li><p><strong><code>-h</code></strong>：表示使用合适的单位显示数据，例如GB。示例命令如下：</p>\n<pre class=\"code-rows\"><code># df -h |grep -v tmpfs\n文件系统 容量 已用 可用 已用% 挂载点\n/dev/sda3 16G 1.5G 15G 9% /\n/dev/sda1 190M 119M 58M 68% /boot</code></pre>\n</li>\n<li><p><strong><code>-k</code>、<code>-m</code></strong>：分别表示以KB和MB为单位显示数据。示例命令如下：</p>\n<pre class=\"code-rows\"><code># df -k |grep -v tmpfs\n文件系统 1K-块 已用 可用 已用% 挂载点\n/dev/sda3 16561152 1472276 15088876 9% /\n/dev/sda1 194235 121419 58480 68% /boot\n# df -m |grep -v tmpfs\n文件系统 1M-块 已用 可用 已用% 挂载点\n/dev/sda3 16173 1438 14736 9% /\n/dev/sda1 190 119 58 68% /boot</code></pre>\n</li>\n</ul>\n<p>简单介绍一下上述信息中各列所表示的含义。如果你的Linux和阿铭的虚拟机一样，也是中文显示，那么看字面意思就可以明白了。第1列为分区的名字，第2列为该分区的总容量，第3列为已使用的容量，第4列为剩余容量，第5列为使用容量的百分比（如果这个数值达到90%以上，那么就应该引起关注了。因为磁盘分区满了会引起系统崩溃），最后一列为挂载点，阿铭在安装系统时提到过这个词。</p>\n<h3 id=\"nav_point_108\">6.1.2 命令<code>du</code></h3>\n<p>命令<code>du</code>（disk useage）用来查看某个目录或文件所占空间的大小，其格式为<code>du [-abckmsh] [文件或者目录名]</code>。该命令常用的参数有如下几个。</p>\n<ul>\n<li><p><strong><code>-a</code></strong>：表示把全部文件和目录的大小都列出来。如果命令<code>du</code>后面不加任何选项和参数，则只会列出目录（包含子目录）的大小。如果<code>du</code>命令不指定单位，则默认显示单位为KB。示例命令如下：</p>\n<pre class=\"code-rows\"><code># du /root/\n8 /root/.ssh\n0 /root/123\n0 /root/456\n36 /root/\n# du -a /root/\n4 /root/.bash_logout\n4 /root/.bash_profile\n4 /root/.bashrc\n4 /root/.cshrc\n4 /root/.tcshrc\n4 /root/anaconda-ks.cfg\n4 /root/.bash_history\n4 /root/.ssh/authorized_keys\n4 /root/.ssh/known_hosts\n8 /root/.ssh\n0 /root/123\n0 /root/456\n36 /root/</code></pre>\n</li>\n<li><p><strong><code>-b</code></strong>：表示列出的值以B为单位输出。</p>\n</li>\n<li><strong><code>-k</code></strong>：表示以KB为单位输出，这和默认不加任何选项的输出值是一样的。</li>\n<li><strong><code>-m</code></strong>：表示以MB为单位输出。</li>\n<li><p><strong><code>-h</code></strong>：表示由系统自动调节输出单位。例如，如果文件太小，可能就几千字节，那么就以KB为单位显示；如果文件大到兆字节，就以GB为单位显示。若一个文件小于4KB，那么当使用<code>-k</code>选项时，也会显示4KB（后面阿铭再给大家解释原因）。同理，使用<code>-m</code>选项时，也会有类似问题。示例命令如下：</p>\n<pre class=\"code-rows\"><code># du -b /etc/passwd\n1209 /etc/passwd\n# du -k /etc/passwd\n4 /etc/passwd\n# du -m /etc/passwd\n1 /etc/passwd\n# du -h /etc/passwd\n4.0K /etc/passwd</code></pre>\n</li>\n<li><p><strong><code>-c</code></strong>：表示最后加总。这个选项阿铭不常用，示例命令如下：</p>\n<pre class=\"code-rows\"><code># du -c /root/\n8 /root/.ssh\n0 /root/123\n0 /root/456\n36 /root/\n36 总用量</code></pre>\n</li>\n<li><p><strong><code>-s</code></strong>：表示只列出总和。这个选项阿铭用得最多，示例命令如下：</p>\n<pre class=\"code-rows\"><code># du -s /root/\n36 /root/</code></pre>\n</li>\n</ul>\n<p>此外，阿铭习惯用<code>du -sh filename</code>这样的形式。</p>\n<h2 id=\"nav_point_109\">6.2 磁盘的分区和格式化</h2>\n<p>阿铭经常做的一件事就是拿一个全新的磁盘来分区并格式化。作为一个Linux系统管理员，对磁盘的操作必须熟练，所以请认真学习该部分内容。</p>\n<h3 id=\"nav_point_110\">6.2.1 增加虚拟磁盘</h3>\n<p>在正式介绍Linux分区工具之前，阿铭需要先给虚拟机添加一块磁盘，以便我们做后续的试验。给虚拟机添加虚拟磁盘的具体操作步骤如下（软件版本为VMware Workstation 14）。</p>\n<p>(1) 在当前的虚拟机选项卡上单击鼠标右键，选择“设置”，如图6-1所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100013/image00421.jpeg\" alt=\"{%}\" /></p>\n<p><strong>图6-1 打开设置</strong></p>\n<p>(2) 此时会弹出“虚拟机设置”对话框。单击下方的“添加”按钮，选择“硬盘”，再单击“下一步”，此时会弹出“添加硬件向导”对话框。</p>\n<p>(3)“选择磁盘类型”这里保持默认设置，不用更改任何指标，直接单击“下一步”按钮。</p>\n<p>(4)“选择磁盘”对话框里也保持默认设置，直接单击“下一步”按钮。</p>\n<p>(5)“指定磁盘容量”这里需要修改一下，设定“最大磁盘大小”为5GB，然后选择“将虚拟磁盘存储为单个文件”单选按钮，如图6-2所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100013/image00422.jpeg\" alt=\"{%}\" /></p>\n<p><strong>图6-2 指定磁盘容量</strong></p>\n<p>(6) 继续单击“下一步”按钮，然后单击“完成”按钮，最终成功添加新的虚拟磁盘。虽然磁盘已经添加，但暂时还不能被系统识别，需要重启系统才可以。</p>\n<h3 id=\"nav_point_111\">6.2.2 命令<code>fdisk</code></h3>\n<p><code>fdisk</code>是Linux下硬盘的分区工具，是一个非常实用的命令，但是此命令只能划分小于2TB的分区。该命令的格式为<code>fdisk [-l ] [设备名称]</code>，其选项只有<code>-l</code>。选项<code>-l</code>后面如果不加设备名称，就会直接列出系统中所有的磁盘设备以及分区表；如果加上设备名称，则会列出该设备的分区表。示例命令如下：</p>\n<pre class=\"code-rows\"><code># fdisk -l\nDisk /dev/sda：20 GiB，21474836480 字节，41943040 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0x1d6231bc\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sda1 * 2048 411647 409600 200M 83 Linux\n/dev/sda2 411648 8800255 8388608 4G 82 Linux swap / Solaris\n/dev/sda3 8800256 41943039 33142784 15.8G 83 Linux\n\n\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n\n# fdisk -l /dev/sdb\n\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节</code></pre>\n<p>从上例中可以看到阿铭新增的磁盘 /dev/sdb的信息。</p>\n<p><code>fdisk</code>命令如果不加<code>-l</code>选项，则会进入另一个模式，在该模式下，可以对磁盘进行分区操作。示例命令如下：</p>\n<pre class=\"code-rows\"><code># fdisk /dev/sdb\n欢迎使用 fdisk (util-linux 2.32.1)。\n更改将停留在内存中，直到您决定将更改写入磁盘。\n使用写入命令前请三思。\n\n设备不包含可识别的分区表。\n创建了一个磁盘标识符为 0xea205440 的新 DOS 磁盘标签。\n\n命令(输入 m 获取帮助)：</code></pre>\n<p>此时如果输入<code>m</code>，就会列出常用的命令，如下所示：</p>\n<pre class=\"code-rows\"><code>命令(输入 m 获取帮助)：m\n帮助：\n\n DOS (MBR)\n a 开关可启动标志\n b 编辑嵌套的 BSD 磁盘标签\n c 开关 dos 兼容性标志\n\n 常规\n d 删除分区\n F 列出未分区的空闲区\n l 列出已知分区类型\n n 添加新分区\n p 打印分区表\n t 更改分区类型\n v 检查分区表\n i 打印某个分区的相关信息\n\n 杂项\n m 打印此菜单\n u 更改 显示/记录 单位\n x 更多功能(仅限专业人员)\n\n 脚本\n I 从 sfdisk 脚本文件加载磁盘布局\n O 将磁盘布局转储为 sfdisk 脚本文件\n\n 保存并退出\n w 将分区表写入磁盘并退出\n q 退出而不保存更改\n\n 新建空磁盘标签\n g 新建一份 GPT 分区表\n G 新建一份空 GPT (IRIX) 分区表\n o 新建一份空 DOS 分区表\n s 新建一份空 Sun 分区表</code></pre>\n<p>下面介绍其中几个阿铭常用的命令。</p>\n<ul>\n<li><p><code>p</code>：表示打印当前磁盘的分区情况。示例命令如下：</p>\n<pre class=\"code-rows\"><code>命令(输入 m 获取帮助)：p\n\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xea205440\n\n// 说明：由于还未对/dev/sdb进行分区，所以并没有显示任何分区信息，你也可以针对/dev/sda进行演示，// 不过千万不要真去划分分区，那样你的操作系统就被破坏了</code></pre>\n</li>\n<li><p><code>n</code>：表示新建一个分区。</p>\n</li>\n<li><code>w</code>：表示保存。</li>\n<li><code>q</code>：表示退出。</li>\n<li><code>d</code>：表示删除一个分区。</li>\n</ul>\n<p>下面阿铭将对新增的磁盘 /dev/sdb进行分区操作。阿铭先给它建立第1个分区，命令如下所示：</p>\n<pre class=\"code-rows\"><code>命令(输入 m 获取帮助)：n\n分区类型\n p 主分区 (0个主分区，0个扩展分区，4空闲)\n e 扩展分区 (逻辑分区容器)\n选择 (默认 p)：</code></pre>\n<p>使用<code>n</code>命令新建分区，它会提示我们是要新建e（扩展分区）还是p（主分区）。阿铭的选择是p，于是输入p，然后回车，命令如下所示：</p>\n<pre class=\"code-rows\"><code>Select (default p): p\n分区号 (1-4, 默认 1): 1\n第一个扇区 (2048-10485759, 默认 2048): 2048\n上个扇区，+sectors 或 +size (2048-10485759, 默认 10485759): +1000M\n\n创建了一个新分区 1，类型为“Linux”，大小为 1000 MiB。</code></pre>\n<p>输入p后，会提示输入分区数，这里阿铭写1，因为是第1个分区（当然，你也可以写2或3，最多为4），此时如果你直接回车，那么会继续提示你必须输入一个数字。输入分区数后紧接着又提示你起始扇区从哪里开始，默认是2048，可以写2048或者直接回车（这里你也可以写大于2048的其他数字，不过这样就会造成空间浪费）。然后提示你输入最后一个扇区的数值，即需要给这个分区划分多大空间。关于扇区是多大，不必再细究，你只需要掌握阿铭教给你的方法即可，即写<code>+1000M</code>，这样既方便又不容易出错。用<code>p</code>命令查看，得知已经多出了一个分区，命令如下所示：</p>\n<pre class=\"code-rows\"><code>命令(输入 m 获取帮助)：p\n\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xea205440\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sdb1 2048 2050047 2048000 1000M 83 Linux</code></pre>\n<p>按照上面的步骤继续操作，一直创建到主分区4。如下所示：</p>\n<pre class=\"code-rows\"><code>命令(输入 m 获取帮助)：n\n分区类型\n p 主分区 (1个主分区，0个扩展分区，3空闲)\n e 扩展分区 (逻辑分区容器)\n选择 (默认 p)：p\n分区号 (2-4, 默认 2): 2\n第一个扇区 (2050048-10485759, 默认 2050048):\n上个扇区，+sectors 或 +size (2050048-10485759, 默认 10485759): +1000M\n\n创建了一个新分区 2，类型为“Linux”，大小为 1000 MiB。\n\n命令(输入 m 获取帮助)：n\n分区类型\n p 主分区 (2个主分区，0个扩展分区，2空闲)\n e 扩展分区 (逻辑分区容器)\n选择 (默认 p)：p\n分区号 (3,4, 默认 3):\n第一个扇区 (4098048-10485759, 默认 4098048):\n上个扇区，+sectors 或 +size (4098048-10485759, 默认 10485759): +1000M\n\n创建了一个新分区 3，类型为“Linux”，大小为 1000 MiB。\n\n命令(输入 m 获取帮助)：n\n分区类型\n p 主分区 (3个主分区，0个扩展分区，1空闲)\n e 扩展分区 (逻辑分区容器)\n选择 (默认 e)：p\n\n已选择分区 4\n第一个扇区 (6146048-10485759, 默认 6146048):\n上个扇区，+sectors 或 +size (6146048-10485759, 默认 10485759): +1000M\n\n创建了一个新分区 4，类型为“Linux”，大小为 1000 MiB。\n\n命令(输入 m 获取帮助)：n\n要创建更多分区，请先将一个主分区替换为扩展分区。</code></pre>\n<p>当创建完4个主分区后，如果再想创建新分区，就会出问题，这是因为在Linux系统中最多只能创建4个主分区。那么如果你想多创建几个分区，该怎么做呢？方法很简单，就是在创建完第3个主分区后、创建第4个分区时选择扩展分区。我们首先删除掉第4个分区，然后再新建分区，命令如下所示：</p>\n<pre class=\"code-rows\"><code>命令(输入 m 获取帮助)：d\n分区号 (1-4, 默认 4): 4\n\n分区 4 已删除。\n\n命令(输入 m 获取帮助)：n\n分区类型\n p 主分区 (3个主分区，0个扩展分区，1空闲)\n e 扩展分区 (逻辑分区容器)\n选择 (默认 e)：e\n\n已选择分区 4\n第一个扇区 (6146048-10485759, 默认 6146048):\n上个扇区，+sectors 或 +size (6146048-10485759, 默认 10485759): +2000M\n\n创建了一个新分区 4，类型为“Extended”，大小为 2 GiB。\n\n命令(输入 m 获取帮助)：p\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xea205440\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sdb1 2048 2050047 2048000 1000M 83 Linux\n/dev/sdb2 2050048 4098047 2048000 1000M 83 Linux\n/dev/sdb3 4098048 6146047 2048000 1000M 83 Linux\n/dev/sdb4 6146048 10242047 4096000 2G 5 扩展</code></pre>\n<p>扩展分区在最后一列显示为<code>Extended</code>，接下来继续创建分区，如下所示：</p>\n<pre class=\"code-rows\"><code>命令(输入 m 获取帮助)：n\n所有主分区都在使用中。\n添加逻辑分区 5\n第一个扇区 (6148096-10242047, 默认 6148096):\n上个扇区，+sectors 或 +size (6148096-10242047, 默认 10242047): +500M\n\n创建了一个新分区 5，类型为“Linux”，大小为 500 MiB。\n\n命令(输入 m 获取帮助)：p\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xea205440\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sdb1 2048 2050047 2048000 1000M 83 Linux\n/dev/sdb2 2050048 4098047 2048000 1000M 83 Linux\n/dev/sdb3 4098048 6146047 2048000 1000M 83 Linux\n/dev/sdb4 6146048 10242047 4096000 2G 5 扩展\n/dev/sdb5 6148096 7172095 1024000 500M 83 Linux</code></pre>\n<p>会发现此时再分区就和之前不一样了，你不再需要选择是新建主分区还是扩展分区，而是直接定义分区大小。值得注意的是，当创建完前3个主分区后，理应把剩余的磁盘空间全部划分给第4个扩展分区，不然剩余的空间就会浪费（在上面的示例中，阿铭其实并没有把剩余的磁盘空间完全划分给扩展分区）。因为创建完扩展分区后，再划分新的分区时，是在已经划分的扩展分区里来分的。</p>\n<p>上例中，/dev/sdb4为扩展分区，这个分区是不可以格式化的。你可以把它看成一个空壳子，能使用的分区为 /dev/sdb5，这是 /dev/sdb4的子分区，这个子分区称为逻辑分区。如果你发现分区不合理，想删除某个分区，那该怎么办呢？这就用到了<code>d</code>命令，刚刚阿铭已经用到过。下面阿铭再继续演示一下：</p>\n<pre class=\"code-rows\"><code>命令(输入 m 获取帮助)：d\n分区号 (1-5, 默认 5): 1\n\n分区 1 已删除。\n\n命令(输入 m 获取帮助)：p\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xea205440\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sdb2 2050048 4098047 2048000 1000M 83 Linux\n/dev/sdb3 4098048 6146047 2048000 1000M 83 Linux\n/dev/sdb4 6146048 10242047 4096000 2G 5 扩展\n/dev/sdb5 6148096 7172095 1024000 500M 83 Linux\n\n命令(输入 m 获取帮助)：d\n分区号 (2-5, 默认 5): 5\n\n分区 5 已删除。\n\n命令(输入 m 获取帮助)：p\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xea205440\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sdb2 2050048 4098047 2048000 1000M 83 Linux\n/dev/sdb3 4098048 6146047 2048000 1000M 83 Linux\n/dev/sdb4 6146048 10242047 4096000 2G 5 扩展\n\n命令(输入 m 获取帮助)：n\n分区类型\n p 主分区 (2个主分区，1个扩展分区，1空闲)\n l 逻辑分区 (从 5 开始编号)\n选择 (默认 p)：l\n\n添加逻辑分区 5\n第一个扇区 (6148096-10242047, 默认 6148096):\n上个扇区，+sectors 或 +size (6148096-10242047, 默认 10242047): +500M\n\n创建了一个新分区 5，类型为“Linux”，大小为 500 MiB。\n\n命令(输入 m 获取帮助)：p\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xea205440\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sdb2 2050048 4098047 2048000 1000M 83 Linux\n/dev/sdb3 4098048 6146047 2048000 1000M 83 Linux\n/dev/sdb4 6146048 10242047 4096000 2G 5 扩展\n/dev/sdb5 6148096 7172095 1024000 500M 83 Linux\n\n命令(输入 m 获取帮助)：d\n分区号 (2-5, 默认 5): 4\n\n分区 4 已删除。\n\n命令(输入 m 获取帮助)：p\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xea205440\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sdb2 2050048 4098047 2048000 1000M 83 Linux\n/dev/sdb3 4098048 6146047 2048000 1000M 83 Linux</code></pre>\n<p>输入d，会提示要删除哪个分区，你可以选择1到5之间的任意一个分区。其中，1-3是主分区（sdb1、sdb2和sdb3），4是扩展分区（sdb4），5是逻辑分区（sdb5）。如果输入5，则直接删除逻辑分区sdb5；但如果输入4，则会删除整个扩展分区sdb4，当然也包含sdb4里面的逻辑分区sdb5。在刚才的分区界面中，直接按Ctrl＋C键退出，这样刚划分的分区便全部取消了，咱们来重新做分区，命令如下所示：</p>\n<pre class=\"code-rows\"><code>命令(输入 m 获取帮助)：^C\n您确实要退出吗？Y\n\nfdisk /dev/sdb\n欢迎使用 fdisk (util-linux 2.32.1)。\n更改将停留在内存中，直到您决定将更改写入磁盘。\n使用写入命令前请三思。\n\n设备不包含可识别的分区表。\n创建了一个磁盘标识符为 0xf6cc0d7a 的新 DOS 磁盘标签。\n\n命令(输入 m 获取帮助)：p\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xf6cc0d7a\n\n\n命令(输入 m 获取帮助)：n\n分区类型\n p 主分区 (0个主分区，0个扩展分区，4空闲)\n e 扩展分区 (逻辑分区容器)\n选择 (默认 p)：e\n分区号 (1-4, 默认 1): 1\n第一个扇区 (2048-10485759, 默认 2048):\n上个扇区，+sectors 或 +size (2048-10485759, 默认 10485759):\n\n创建了一个新分区 1，类型为“Extended”，大小为 5 GiB。\n\n命令(输入 m 获取帮助)：p\n\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xf6cc0d7a\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sdb1 2048 10485759 10483712 5G 5 扩展\n\n命令(输入 m 获取帮助)：n\nPartition type:\n p primary (0 primary, 1 extended, 3 free)\n l logical (numbered from 5)</code></pre>\n<p>由上例可知，如果把第1个分区定为扩展分区，并且把全部空间都划分给该分区，那么再继续分区时，就会默认为添加逻辑分区，如下所示：</p>\n<pre class=\"code-rows\"><code>命令(输入 m 获取帮助)：n\n所有主分区的空间都在使用中。\n添加逻辑分区 5\n第一个扇区 (4096-10485759, 默认 4096):</code></pre>\n<p>我们来连续添加两个1000MB的分区，命令如下所示：</p>\n<pre class=\"code-rows\"><code>第一个扇区 (4096-10485759, 默认 4096):\n上个扇区，+sectors 或 +size (4096-10485759, 默认 10485759): +1000M\n\n创建了一个新分区 5，类型为“Linux”，大小为 1000 MiB。\n\n命令(输入 m 获取帮助)：n\n所有主分区的空间都在使用中。\n添加逻辑分区 6\n第一个扇区 (2054144-10485759, 默认 2054144):\n上个扇区，+sectors 或 +size (2054144-10485759, 默认 10485759): +1000M\n\n创建了一个新分区 6，类型为“Linux”，大小为 1000 MiB。\n\n命令(输入 m 获取帮助)：p\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xf6cc0d7a\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sdb1 2048 10485759 10483712 5G 5 扩展\n/dev/sdb5 4096 2052095 2048000 1000M 83 Linux\n/dev/sdb6 2054144 4102143 2048000 1000M 83 Linux</code></pre>\n<p>分区完成后，需要输入<code>w</code>命令来保存我们的配置，命令如下所示：</p>\n<pre class=\"code-rows\"><code>分区表已调整。\n将调用 ioctl() 来重新读分区表。\n正在同步磁盘。</code></pre>\n<p>然后使用命令<code>fdisk -l /dev/sdb</code>查看分区情况，命令如下所示：</p>\n<pre class=\"code-rows\"><code># fdisk -l /dev/sdb\n\nDisk /dev/sdb：5 GiB，5368709120 字节，10485760 个扇区\n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：dos\n磁盘标识符：0xf6cc0d7a\n\n设备 启动 起点 末尾 扇区 大小 Id 类型\n/dev/sdb1 2048 10485759 10483712 5G 5 扩展\n/dev/sdb5 4096 2052095 2048000 1000M 83 Linux\n/dev/sdb6 2054144 4102143 2048000 1000M 83 Linux</code></pre>\n<p>通过以上操作，相信你已经学会如何分区了。但阿铭要提醒你，一定不要随意分区，因为这非常危险，一不留神就把服务器上的数据全部给分没了。所以，在执行分区操作的时候，请保持百分之二百的细心！</p>\n<h2 id=\"nav_point_112\">6.3 格式化磁盘分区</h2>\n<p>虽然分好区了，但磁盘分区暂时还不能用，我们还须对每一个分区进行格式化。所谓格式化，其实就是安装文件系统，Windows下的文件系统有FAT32和NTFS。前面章节中，阿铭介绍过CentOS 8以XFS作为默认的文件系统，但我们依然可以给它指定ext3或者ext4格式。</p>\n<h3 id=\"nav_point_113\">6.3.1 命令<code>mke2fs</code>、<code>mkfs.ext2</code>、<code>mkfs.ext3</code>、<code>mkfs.ext4</code>和<code>mkfs.xfs</code></h3>\n<p>当用<code>man</code>命令查询前4个命令的帮助文档时，你会发现看到的是同一个帮助文档，这说明这4个命令是一样的。下面我们以<code>mke2fs</code>命令为例进行介绍。</p>\n<p><code>mke2fs</code>命令常用的选项如下所示。</p>\n<ul>\n<li><code>-b</code>：表示分区时为每个数据区块设定所占用的空间大小。目前，每个数据区块的大小支持1024B、2048B以及4096B。</li>\n<li><code>-i</code>：表示设定<code>inode</code>的大小。</li>\n<li><code>-N</code>：表示设定<code>inode</code>的数量。有时默认的<code>inode</code>数量不够用，所以要自定义<code>inode</code>的数量。</li>\n<li><code>-c</code>：表示在格式化前先检测一下磁盘是否有问题。加上这个选项后，运行速度会非常慢。</li>\n<li><code>-L</code>：表示预设该分区的标签（label）。</li>\n<li><code>-j</code>：表示建立ext3格式的分区。如果使用<code>mkfs.ext3</code>格式，就不用加这个选项了。</li>\n<li><p><code>-t</code>：用来指定文件系统的类型，可以是ext2、ext3，也可以是ext4。示例命令如下：</p>\n<pre class=\"code-rows\"><code># mke2fs -t ext4 /dev/sdb5\nmke2fs 1.44.3 (10-July-2018)\n创建含有 256000 个块（每块 4k）和 64000 个inode的文件系统\n文件系统UUID：ee707477-3db3-4368-8b86-252acbc18a81\n超级块的备份存储于下列块：\n 32768, 98304, 163840, 229376\n\n正在分配组表： 完成\n正在写入inode表： 完成\n创建日志（4096 个块）完成\n写入超级块和文件系统用户统计信息： 已完成</code></pre>\n</li>\n</ul>\n<p>指定文件系统格式为ext4时，命令mke2fs -t ext4 /dev/sdb5等同于mkfs.ext4 /dev/sdb5。然而，mke2fs并不支持把分区格式化成XFS类型，而只能使用mkfs.xfs，示例命令如下：</p>\n<pre class=\"code-rows\"><code># mke2fs -t xfs /dev/sdb6\nmke2fs 1.44.3 (10-July-2018)\n\n你的mke2fs.conf文件中没有定义类型为 xfs 的文件系统。\n正在终止……\n# mkfs.xfs /dev/sdb6\nmeta-data=/dev/sdb6 isize=512 agcount=4, agsize=64000 blks\n = sectsz=512 attr=2, projid32bit=1\n = crc=1 finobt=1, sparse=1, rmapbt=0\n = reflink=1\ndata = bsize=4096 blocks=256000, imaxpct=25\n = sunit=0 swidth=0 blks\nnaming =version 2 bsize=4096 ascii-ci=0, ftype=1\nlog =internal log bsize=4096 blocks=1566, version=2\n = sectsz=512 sunit=0 blks, lazy-count=1\nrealtime =none extsz=4096 blocks=0, rtextents=0</code></pre>\n<p>在上例中，你是否注意到“<code>块大小=4096</code>”或者<code>bsize=4096</code>这项指标呢？这里涉及“块”的概念。磁盘在格式化的时候，会预先规定好每一个块的大小，然后再把所有的空间分割成一个一个的小块。存数据的时候，也是一个块一个块地写入。如果你的磁盘里存储的都是特别小的文件，比如说1KB或者2KB，阿铭建议你在格式化磁盘时把块数值指定得小一点。ext4文件系统的默认块大小为4096B（即4KB）。在格式化时，可以指定块大小为1024B、2048B或者4096B（它们是成倍增加的）。虽然格式化时可以指定块大小超过4096B，但一旦超过4096B，就不能正常挂载了。那么，如何指定块大小呢？下面阿铭演示一下具体的操作方法，命令如下所示：</p>\n<pre class=\"code-rows\"><code># mke2fs -t ext4 -b 8192 /dev/sdb5\n警告：块大小 8192 在很多系统中不可用。\nmke2fs 1.44.3 (10-July-2018)\n /dev/sdb5 有一个 ext4 文件系统\n 创建于 Sat Jan 11 00:47:05 2020\nProceed anyway? (y,N) y\nmke2fs: 8192字节的块对于系统来说太大（最大为 4096）\nProceed anyway? (y,N) y\n警告：8192字节的块对于系统来说太大（最大为 4096），但仍然强制进行操作\n创建含有 128000 个块（每块 8k）和 64000 个inode的文件系统\n文件系统UUID：48a24828-56d2-45fc-b3bf-1cb09f00c896\n超级块的备份存储于下列块：\n 65528\n\n正在分配组表： 完成\n正在写入inode表： 完成\n创建日志（4096 个块）完成\n写入超级块和文件系统用户统计信息： 已完成\n\n# mkfs.xfs -b size=8192 /dev/sdb6 // 重新格式化sdb6时，会提示这个分区已经格式化过\nmkfs.xfs: /dev/sdb6 appears to contain an existing filesystem (xfs).\nmkfs.xfs: Use the -f option to force overwrite.\n# mkfs.xfs -f -b size=8192 /dev/sdb6 // 加-f选项就可以了\nmeta-data=/dev/sdb6 isize=512 agcount=4, agsize=32000 blks\n = sectsz=512 attr=2, projid32bit=1\n = crc=1 finobt=1, sparse=1, rmapbt=0\n = reflink=1\ndata = bsize=8192 blocks=128000, imaxpct=25\n = sunit=0 swidth=0 blks\nnaming =version 2 bsize=8192 ascii-ci=0, ftype=1\nlog =internal log bsize=8192 blocks=1128, version=2\n = sectsz=512 sunit=0 blks, lazy-count=1\nrealtime =none extsz=8192 blocks=0, rtextents=0</code></pre>\n<p>通过上面的小试验可以发现，如果指定块大小为8192B，就会提示设置的块大小值太大了，我们可以直接输入y强制格式化。你还可以尝试指定其他数字，但需要是1024的整数倍（1024、2048、4096或者8192）。其中，<code>mkfs.xfs</code>用法有点特殊，你需要注意区分它和<code>mke2fs</code>。另外，还可以给分区指定标签，命令如下所示：</p>\n<pre class=\"code-rows\"><code># mke2fs -L TEST -t ext4 /dev/sdb5\nmke2fs 1.44.3 (10-July-2018)\n /dev/sdb5 有一个 ext4 文件系统\n 创建于 Sat Jan 11 00:48:58 2020\nProceed anyway? (y,N) y\n创建含有 256000 个块（每块 4k）和 64000 个inode的文件系统\n文件系统UUID：e584a0dc-46b9-4d16-ad4d-78bc69786781\n超级块的备份存储于下列块：\n 32768, 98304, 163840, 229376\n\n正在分配组表： 完成\n正在写入inode表： 完成\n创建日志（4096 个块）完成\n写入超级块和文件系统用户统计信息： 已完成</code></pre>\n<p>这里我们可以使用<code>-L</code>选项来指定标签，标签会在挂载磁盘时使用，也可以把标签写入配置文件，这个阿铭稍后介绍。</p>\n<p>关于格式化的这部分内容，阿铭建议你，除非有需求，否则不需要指定块大小。也就是说，你只需要记住<code>-t</code>和<code>-L</code>这两个选项即可。</p>\n<h3 id=\"nav_point_114\">6.3.2 命令<code>e2label</code></h3>\n<p>该命令用于查看或修改分区的标签，它只支持ext格式的文件系统，而不支持XFS文件系统。这个命令阿铭很少使用，你只要了解一下即可。示例命令如下：</p>\n<pre class=\"code-rows\"><code># e2label /dev/sdb5\nTEST\n# e2label /dev/sdb5 TEST123\n# e2label /dev/sdb5\nTEST123</code></pre>\n<h2 id=\"nav_point_115\">6.4 挂载/卸载磁盘</h2>\n<p>前面我们讲到了磁盘的分区和格式化，那么格式化完成后，如何使用这些磁盘呢？这就涉及挂载磁盘了。格式化后的磁盘其实是一个块设备文件，类型为b。也许你会想，既然这个块文件就是那个分区，那么直接在那个文件中写数据不就相当于写入那个分区了吗？这当然不是。</p>\n<p>在挂载某个分区前，需要先建立一个挂载点，这个挂载点是以目录的形式出现的。一旦把某个分区挂载到这个挂载点（目录）下，之后再往这个目录写数据，就都会写到该分区中。所以，在挂载该分区前，挂载点（目录）下必须是个空目录。其实目录不为空并不影响所挂载分区的使用，但一旦挂载上了，该目录下以前的数据就看不到了（数据并没有丢失），除非卸载该分区。</p>\n<h3 id=\"nav_point_116\">6.4.1 命令<code>mount</code></h3>\n<p>如果不加任何选项，直接运行<code>mount</code>命令，会显示如下信息：</p>\n<pre class=\"code-rows\"><code># mount\nsysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)\nproc on /proc type proc (rw,nosuid,nodev,noexec,relatime)\ndevtmpfs on /dev type devtmpfs (rw,nosuid,size=910288k,nr_inodes=227572,mode=755)\nsecurityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)\ntmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)\ndevpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)\ntmpfs on /run type tmpfs (rw,nosuid,nodev,mode=755)\ntmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)\ncgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/\n usr/lib/systemd/systemd-cgroups-agent,name=systemd)\npstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)\nbpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)\ncgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)\ncgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)\ncgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)\ncgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)\ncgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)\ncgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)\ncgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)\ncgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)\ncgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)\ncgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)\ncgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)\nconfigfs on /sys/kernel/config type configfs (rw,relatime)\n/dev/sda3 on / type xfs (rw,relatime,attr2,inode64,noquota)\nsystemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=30,pgrp=1,timeout=0,minproto=5,\n maxproto=5,direct,pipe_ino=21502)\nmqueue on /dev/mqueue type mqueue (rw,relatime)\nhugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)\ndebugfs on /sys/kernel/debug type debugfs (rw,relatime)\n/dev/sda1 on /boot type ext4 (rw,relatime)\ntmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,size=184944k,mode=700)</code></pre>\n<p>上述输出的信息量有点大，大家先不用关心这些内容的含义。使用这个命令，可以查看当前系统已经挂载的所有分区、分区文件系统的类型、挂载点及一些选项等信息。如果想知道某个已挂载分区的文件系统类型，直接用<code>mount</code>命令查看即可。那么未挂载的分区，该怎么看呢，大家可以使用<code>blkid</code>命令查看，6.4.3节会讲到它。下面我们先建立一个空目录，然后在此目录里新建一个空白文档。示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir /newdir\n# touch /newdir/newfile.txt\n# ls /newdir/\nnewfile.txt</code></pre>\n<p>然后把刚才格式化的/dev/sdb5挂载到新建的目录/newdir上，命令如下所示：</p>\n<pre class=\"code-rows\"><code># mount /dev/sdb5 /newdir/\n# ls /newdir/\nlost+found\n# df -h |grep -v tmpfs\n文件系统 1K-块 已用 可用 已用% 挂载点\n/dev/sda3 16G 1.4G 15G 9% /\n/dev/sda1 190M 119M 58M 68% /boot\n/dev/sdb5 969M 2.5M 900M 1% /newdir</code></pre>\n<p>把 /dev/sdb5挂载到 /newdir后，原来在 /newdir下的newfile.txt文档就看不到了，通过命令<code>df -h</code>命令可以查看刚刚挂载的分区。</p>\n<p>我们也可以使用LABEL的方式挂载分区，命令如下所示：</p>\n<pre class=\"code-rows\"><code># umount /newdir/\n# df -h |grep -v tmpfs\n文件系统 1K-块 已用 可用 已用% 挂载点\n/dev/sda3 16G 1.4G 15G 9% /\n/dev/sda1 190M 119M 58M 68% /boot\n# mount LABEL=TEST123 /newdir\n# df -h |grep -v tmpfs\n文件系统 1K-块 已用 可用 已用% 挂载点\n/dev/sda3 16G 1.4G 15G 9% /\n/dev/sda1 190M 119M 58M 68% /boot\n/dev/sdb5 969M 2.5M 900M 1% /newdir</code></pre>\n<p>本例中用到了<code>umount</code>命令，这个命令是用来卸载磁盘分区的，阿铭稍后介绍。</p>\n<p><code>mount</code>命令常用的选项有<code>-a</code>、<code>-t</code>和<code>-o</code>。在介绍<code>-a</code>选项前，我们需要先了解一下 /etc/fstab这个配置文件。</p>\n<h3 id=\"nav_point_117\">6.4.2 /etc/fstab配置文件</h3>\n<p>我们先来查看一下 /etc/fstab文件的内容，命令如下所示：</p>\n<pre class=\"code-rows\"><code># cat /etc/fstab\n\n#\n# /etc/fstab\n# Created by anaconda on Thu Dec 26 08:06:21 2019\n#\n# Accessible filesystems, by reference, are maintained under '/dev/disk/'.\n# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.\n#\n# After editing this file, run 'systemctl daemon-reload' to update systemd\n# units generated from this file.\n#\nUUID=a1b68ae0-4783-45d2-991a-cfc60a95f91b / xfs defaults 0 0\nUUID=35b3ebc3-77aa-431c-a0ed-83c4994e95e0 /boot ext4 defaults 1 2\nUUID=648fc79f-7455-46b8-8c74-5de9682785df swap swap defaults 0 0</code></pre>\n<p>这个文件中显示了系统启动时需要挂载的各个分区，下面阿铭简单描述一下其中各列的含义。</p>\n<ul>\n<li>第1列是分区的标识，可以是分区的<code>LABEL</code>、分区的<code>UUID</code>（在6.4.3节中阿铭会着重讲一下这个概念），也可以是分区名（/dev/sda1）。</li>\n<li>第2列是挂载点。</li>\n<li>第3列是分区的格式。</li>\n<li>第4列是<code>mount命令</code>的一些挂载参数。一般情况下，直接写<code>defaults</code>即可。</li>\n<li>第5列的数字表示是否被dump备份。1表示备份，0表示不备份。</li>\n<li>第6列的数字表示开机时是否自检磁盘。1和2都表示检测，0表示不检测。自检时，1比2优先级高，所以先检测1，再检测2。如果有多个分区需要开机检测，就都设置成2，1检测完后会同时检测2。在CentOS 7/CentOS 8系统里，所有分区中该列的值都是0。</li>\n</ul>\n<p>下面阿铭着重介绍第4列的常用选项。</p>\n<ul>\n<li><strong><code>async</code>/<code>sync</code></strong>：<code>async</code>表示磁盘和内存不同步，系统会每隔一段时间把内存数据写入磁盘中，而<code>sync</code>则会时时同步内存和磁盘中的数据。</li>\n<li><strong><code>auto/noauto</code></strong>：表示开机自动挂载/不自动挂载。</li>\n<li><strong><code>defaults</code></strong>：表示按照大多数永久文件系统的默认值设置挂载定义，它包含了<code>rw</code>、<code>suid</code>、<code>dev</code>、<code>exec</code>、<code>auto</code>、<code>nouser</code>和<code>async</code>。</li>\n<li><strong><code>ro</code></strong>：表示按只读权限挂载。</li>\n<li><strong><code>rw</code></strong>：表示按可读可写权限挂载。</li>\n<li><strong><code>exec</code>/<code>noexec</code></strong>：表示允许/不允许可执行文件执行，但千万不要把根分区挂载为<code>noexec</code>，否则将无法使用系统，甚至连<code>mount</code>命令都无法使用。</li>\n<li><strong><code>user</code>/<code>nouser</code></strong>：表示允许/不允许root以外的其他用户挂载分区。为了安全，请用<code>nouser</code>。</li>\n<li><strong><code>suid</code>/<code>nosuid</code></strong>：表示允许/不允许分区有<code>suid</code>属性，一般设置<code>nosuid</code>。</li>\n<li><strong><code>usrquota</code></strong>：表示启动用户的磁盘配额模式。磁盘配额会针对用户限定他们使用的磁盘额度。</li>\n<li><strong><code>grquota</code></strong>：表示启动群组的磁盘配额模式。</li>\n</ul>\n<p>学完了/etc/fstab的内容，我们就可以自己修改这个文件，增加一行内容来挂载新增分区。例如，阿铭增加了这样一行：</p>\n<pre class=\"code-rows\"><code>LABEL=TEST123 /newdir ext4 defaults 0 0</code></pre>\n<p>然后卸载之前已经挂载的 /dev/sdb5，如下所示：</p>\n<pre class=\"code-rows\"><code># umount /dev/sdb5\n# df -h |grep -v tmpfs\n文件系统 1K-块 已用 可用 已用% 挂载点\n/dev/sda3 16G 1.4G 15G 9% /\n/dev/sda1 190M 119M 58M 68% /boot</code></pre>\n<p>使用命令<code>df -h</code>查看，会发现已经成功卸载/dev/sdb5。下面执行命令<code>mount –a</code>：</p>\n<pre class=\"code-rows\"><code># mount -a\n# df -h |grep -v tmpfs\n文件系统 1K-块 已用 可用 已用% 挂载点\n/dev/sda3 16G 1.4G 15G 9% /\n/dev/sda1 190M 119M 58M 68% /boot\n/dev/sdb5 969M 2.5M 900M 1% /newdir</code></pre>\n<p>使用命令<code>df -h</code>查看，会发现多出一个文件 /dev/sdb5挂载到了 /newdir下，这就是<code>mount -a</code>命令执行的结果。这个<code>-a</code>选项会把 /etc/fstab中出现的所有磁盘分区挂载上。除了<code>-a</code>选项外，还有两个常用的选项。</p>\n<ul>\n<li><strong><code>-t</code>选项</strong>：用来指定挂载的分区类型，默认不指定，会自动识别。</li>\n<li><p><strong><code>-o</code>选项</strong>：用来指定挂载的分区有哪些特性，即上面/etc/fstab配置文件中第4列的那些。这个选项阿铭经常使用，示例命令如下：</p>\n<pre class=\"code-rows\"><code># mkdir /newdir/dir1\n# mount -o remount,ro,sync /dev/sdb5 /newdir\n# mkdir /newdir/dir2\nmkdir: 无法创建目录\"/newdir/dir2\": 只读文件系统</code></pre>\n<p>由于<code>-o</code>选项指定了<code>ro</code>参数，所以该分区是只读的。通过<code>mount</code>命令可以看到，/dev/sdb5也有<code>ro</code>参数，示例命令如下：</p>\n<pre class=\"code-rows\"><code># mount |grep sdb5\n/dev/sdb5 on /newdir type ext4 (ro,relatime,sync)</code></pre>\n<p>下面阿铭重新挂载，让它恢复读写，如下所示：</p>\n<pre class=\"code-rows\"><code># mount -o remount /newdir // 这里可以省略掉磁盘分区，只写挂载点\n# mkdir /newdir/dir2\n# ls /newdir/\ndir1 dir2 lost+found</code></pre>\n</li>\n</ul>\n<h3 id=\"nav_point_118\">6.4.3 命令<code>blkid</code></h3>\n<p>阿铭在日常的运维工作中遇到过这样的情况，一台服务器上新装了两块磁盘：磁盘a（在服务器上显示为sdc）和磁盘b（在服务器上显示为sdd）。有一次阿铭把这两块磁盘都拔掉了，之后再重新插上，重启机器，结果两块磁盘的编号被调换了，即磁盘a显示为sdd，磁盘b显示为sdc（这是因为阿铭把磁盘插错了插槽）。</p>\n<p>我们知道挂载磁盘是通过/dev/sdb1这样的分区名字来挂载的，如果某分区先前已加入到/etc/fstab中，那么系统启动后就会挂载错分区。那么，怎样避免这样的情况发生呢？这就用到了<code>UUID</code>。我们可以通过<code>blkid</code>命令获取各分区的<code>UUID</code>，如下所示：</p>\n<pre class=\"code-rows\"><code># blkid\n/dev/sdb5: LABEL=\"TEST123\" UUID=\"e584a0dc-46b9-4d16-ad4d-78bc69786781\" TYPE=\"ext4\" PARTUUID=\n \"f6cc0d7a-05\"\n/dev/sda1: UUID=\"35b3ebc3-77aa-431c-a0ed-83c4994e95e0\" TYPE=\"ext4\" PARTUUID=\"1d6231bc-01\"\n/dev/sda2: UUID=\"648fc79f-7455-46b8-8c74-5de9682785df\" TYPE=\"swap\" PARTUUID=\"1d6231bc-02\"\n/dev/sda3: UUID=\"a1b68ae0-4783-45d2-991a-cfc60a95f91b\" TYPE=\"xfs\" PARTUUID=\"1d6231bc-03\"\n/dev/sdb6: UUID=\"2c55aa65-813f-458a-b68c-df0d74127de4\" TYPE=\"xfs\" PARTUUID=\"f6cc0d7a-06\"</code></pre>\n<p>这样可以获得全部磁盘分区的<code>UUID</code>。如果格式化时指定了<code>LABEL</code>，则该命令会显示<code>LABEL</code>值，文件系统的类型也会显示。当然，这个命令后面可以指定查询哪个分区，示例命令如下：</p>\n<pre class=\"code-rows\"><code># blkid /dev/sdb5\n/dev/sdb5: LABEL=\"TEST123\" UUID=\"e584a0dc-46b9-4d16-ad4d-78bc69786781\" TYPE=\"ext4\" PARTUUID=\"f6cc0d7a-05\"</code></pre>\n<p>获得<code>UUID</code>后，我们如何使用它呢？用法如下所示：</p>\n<pre class=\"code-rows\"><code># umount /newdir\n# mount UUID=\"e584a0dc-46b9-4d16-ad4d-78bc69786781\" /newdir/</code></pre>\n<p><code>UUID</code>也是支持写入到/etc/fstab中的，示例命令如下：</p>\n<pre class=\"code-rows\"><code># tail -1 /etc/fstab\nUUID=\"e584a0dc-46b9-4d16-ad4d-78bc69786781\" /newdir ext4 defaults 0 0</code></pre>\n<p>如果想让某个分区在开机后自动挂载，有两个办法可以实现：一是在 /etc/fstab中添加一行，如上例中那行；二是把挂载命令写到 /etc/rc.d/rc.local文件中，系统启动后会执行这个文件中的命令。只要你把想要开机启动的命令统统放到这个文件的最后即可。阿铭经常把挂载的命令放到该文件的最后一行，示例命令如下：</p>\n<pre class=\"code-rows\"><code># cat /etc/rc.d/rc.local\n#!/bin/bash\n# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES\n#\n# It is highly advisable to create own systemd services or udev rules\n# to run scripts during boot instead of using this file.\n#\n# In contrast to previous versions due to parallel execution during boot\n# this script will NOT be run after all other services.\n#\n# Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure\n# that this script will be executed during boot.\n\ntouch /var/lock/subsys/local\n/usr/bin/mount UUID=\"e584a0dc-46b9-4d16-ad4d-78bc69786781\" /newdir</code></pre>\n<p>有的朋友可能会遇到这样的情况，把命令写入/etc/rc.d/rc.local文件里，并没有开机执行，这很有可能是因为系统并没有找到那个命令。所以，为了避免出现此类问题，阿铭建议，对于以后要写入到该文件的命令，应使用绝对路径，比如本例中的<code>mount</code>应该写成<code>/usr/bin/mount</code>。更改完 /etc/rc.d/rc.local文件后，还需要一步操作：</p>\n<pre class=\"code-rows\"><code># chmod a+x /etc/rc.d/rc.local</code></pre>\n<p>这是因为，在CentOS 8系统，该文件默认没有执行权限。以上两种方法任选其一，阿铭介绍第2种方法其实也是告诉你：如何让一些操作行为随系统启动而自动执行。另外，阿铭建议你在挂载磁盘分区时，尽量使用<code>UUID</code>或者<code>LABEL</code>这两种方法。</p>\n<h3 id=\"nav_point_119\">6.4.4 命令<code>umount</code></h3>\n<p>在上面的小试验中，阿铭多次用到<code>umount</code>命令。这个命令后面可以跟挂载点，也可以跟分区名（如/dev/sdb1），但是不可以跟<code>LABEL</code>和<code>UUID</code>。示例命令如下：</p>\n<pre class=\"code-rows\"><code># umount /dev/sdb5\n# mount UUID=\"e584a0dc-46b9-4d16-ad4d-78bc69786781\" /newdir\n# umount /newdir\n# mount UUID=\"e584a0dc-46b9-4d16-ad4d-78bc69786781\" /newdir</code></pre>\n<p><code>umount</code>命令的<code>-l</code>选项非常有用。因为有时候你会遇到不能卸载的情况，如下所示：</p>\n<pre class=\"code-rows\"><code># umount /newdir\numount: /newdir：目标忙。\n (有些情况下通过 lsof(8) 或 fuser(1) 可以\n 找到有关使用该设备的进程的有用信息)</code></pre>\n<p>不能卸载是因为当前目录还在卸载的分区上。解决这个问题的办法有两种：一是进入到其他目录；二是使用<code>umount</code>命令的<code>-l</code>选项，示例命令如下：</p>\n<pre class=\"code-rows\"><code># umount -l /newdir\n# df -h |grep -v tmpfs\n文件系统 1K-块 已用 可用 已用% 挂载点\n/dev/sda3 16561152 1436184 15124968 9% /\n/dev/sda1 194235 121419 58480 68% /boot</code></pre>\n<h2 id=\"nav_point_120\">6.5 建立一个swap文件增加虚拟内存</h2>\n<p>在安装系统时我们就接触了<code>swap</code>命令，它类似于Windows的虚拟内存，分区时一般指定虚拟内存的大小为实际内存的2倍。如果你的实际内存超过4GB，那么划分8GB给虚拟内存就足够日常交换了。如果真遇到了虚拟内存不够用的情况，就必须增加一个虚拟磁盘，因为我们不可能重新给磁盘分区。增加虚拟磁盘的基本思路是：建立swapfile→格式化为swap格式→启用该虚拟磁盘。</p>\n<p>首先，建立swapfile，如下所示：</p>\n<pre class=\"code-rows\"><code># dd if=/dev/zero of=/tmp/newdisk bs=1M count=1024\n记录了1024+0 的读入\n记录了1024+0 的写出\n1073741824字节(1.1 GB)已复制，6.36177 秒，169 MB/秒</code></pre>\n<p>阿铭经常用到<code>dd</code>命令，所以也要请你掌握它的使用方法：用<code>if</code>指定源文件（一般是写 /dev/zero，它是UNIX系统特有的一个文件，它可以源源不断地提供0），<code>of</code>指定目标文件，<code>bs</code>定义块的大小，<code>count</code>定义块的数量。<code>bs</code>和<code>count</code>这两个参数决定了目标文件的大小，即目标文件大小为这两个参数的乘积。在上面的示例中，阿铭用<code>dd</code>命令建立了一个大小为1.1GB的文件，下面将此文件格式化为swap格式，命令如下：</p>\n<pre class=\"code-rows\"><code># mkswap -f /tmp/newdisk\nmkswap: /tmp/newdisk：不安全的权限 0644，建议使用 0600。\n正在设置交换空间版本 1，大小 = 1024 MiB (1073737728 个字节)\n无标签，UUID=df739399-cb11-4a92-b8db-9e94e257b815</code></pre>\n<p>文件格式化后，就可以挂载使用了，如下所示：</p>\n<pre class=\"code-rows\"><code># free -m\n total used free shared buff/cache available\nMem: 1806 235 293 8 1276 1413\nSwap: 4095 0 4095\n# swapon /tmp/newdisk\nswapon: /tmp/newdisk：不安全的权限 0644，建议使用 0600。 // 虽然提示不安全，但实际已经挂载上\n# free -m\n total used free shared buff/cache available\nMem: 1806 236 293 8 1276 1412\nSwap: 5119 0 5119</code></pre>\n<p>对比一下前后的swap分区，我们发现多了1024MB的空间。其中，<code>free</code>命令用来查看内存的使用情况，<code>-m</code>选项表示以MB为单位显示，阿铭会在第13章中详细介绍该命令。</p>\n<h2 id=\"nav_point_121\">6.6 课后习题</h2>\n<p>(1) 请查资料了解这些术语并说出它们之间的区别：/dev/hda、/dev/hdb、/dev/sda和/dev/sdb。</p>\n<p>(2) 为什么命令<code>du -b /etc/passwd</code>和命令<code>du -k /etc/passwd</code>执行后的结果不一致呢？（提示：通常情况下，1024B=1KB，阿铭的/etc/passwd文件的大小为1181B，以KB为单位表示时竟然是4KB。）</p>\n<p>(3) 请查资料了解磁盘的这些概念：heads、sectors和cylinders。</p>\n<p>(4) 磁盘分区时每一个扇区空间是多大？</p>\n<p>(5) 请查资料了解：ide和scsi接口的磁盘有什么区别，scsi磁盘（sda、sdb）最多可以分多少个逻辑分区。</p>\n<p>(6) 把磁盘格式化为ext4文件系统时，如果指定块大小不是1024B、2048B或4096B，会发生什么？指定块大小最小是多少，最大又是多少？</p>\n<p>(7) 如何查看当前系统里各个分区的文件系统类型？</p>\n<p>(8) /dev/zero和/dev/null在Linux系统中是什么文件？它们有什么作用？</p>\n<p>(9) 在Linux系统下，命令<code>df</code>和命令<code>du</code>主要用来做什么？</p>\n<p>(10) 在Linux系统下，用什么命令为一个新磁盘分区呢？又用什么命令格式化磁盘？</p>\n<p>(11) 如果不能使用<code>mount命令</code>挂载磁盘，我们需要使用什么命令获取相关错误信息？</p>\n<p>(12) 当卸载某个磁盘或者分区，报错umount: /newdir: device is busy时，我们该如何做？</p>\n<p>(13) 如何获取某个分区的<code>UUID</code>？</p>\n<p>(14) 如何使用<code>dd</code>命令生成一个大小为500MB的文件？</p>\n<p>(15) 查看内存大小的命令是什么？如何以MB为单位显示？</p>\n<p>(16) 如何查看各文件系统<code>inode</code>的使用情况？</p>\n<p>(17) 请使用VMware虚拟机分配一块1GB的虚拟磁盘，并用fdisk分区工具给新增磁盘分3个200MB的主分区，然后再分3个100MB的逻辑分区。</p>\n<p>(18) 给磁盘分区时，最多可以分几个主分区？最多可以分几个扩展分区？扩展分区和逻辑分区是什么关系？</p>\n<p>(19) 阿铭使用命令<code>fdisk -l /dev/sdb</code>查看磁盘分区状况时发现有这么几个分区：sdb1、sdb3、sdb5、sdb6和sdb7。请你推算一下这个磁盘共有几个主分区和几个逻辑分区？</p>\n<p>(20) 如何查看某个分区格式化时指定的块大小（1024B、2048B或4096B）？</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}