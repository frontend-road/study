{"id":464550,"title":"01｜快速回顾：一个 C 程序的完整生命周期","content":"<p>你好，我是于航。</p><p>在深入了解 C 语言、做到“知其所以然”之前，我们需要先做到“知其然”，也就是知道 C 语言是如何使用的。所以这一讲，我会从语法细节和语言特性、微观和宏观相结合的角度，带你快速、直观地回顾 C 语言的一些基础内容。而通过本讲的学习，你也会更容易理解这门课接下来的内容。</p><p>首先，我会带你回顾一个 C 程序从源代码编写到编译，再到最后运行的完整过程。除此之外，我还会用一段相对复杂的示例代码，来带你快速回顾 C 语言中最常见的那些语法及使用方式。最后，我们还会从语言本身的角度，来探讨 C 语言与其他编程语言在编程范式上的不同之处。</p><h2>学习这门课，需要怎样的实践开发环境？</h2><p>在开始回顾这些内容之前，我要先向你推荐一些学习这门课时会用到的开发工具。你可以利用这些工具，自行编译和运行课程中给出的示例代码，以加深你对课程内容的理解。</p><p>对于编译工具，这门课会穿插使用运行于 x86-64 平台的 GCC 11.2 或 Clang 13.0.0 版本编译器。市面上有很多成熟的 C 编译器可以选择，但不同的编译器可能存在着所支持平台（类 Unix、Windows）以及 C 标准（C89、C99、C11、C17）上的差异，因此在选择时需要特别注意这些问题。这门课里使用的 GCC 和 Clang 都支持 C 语言的最新标准 C17，并且都可以运行在类 Unix 与 Windows 系统上。</p><!-- [[[read_end]]] --><p>当然，如果你在本地环境中没有安装上面这些编译器，那么也可以直接使用云编译器，比如 <a href=\"https://godbolt.org\">Godbolt</a>。相较于本地编译器，云编译器即开即用，而且可以随时灵活切换不同的编译器版本。</p><p>至于 IDE，那些常用的都可以，不过推荐你选择 Visual Studio Code，因为它较为轻量，且目前提供的插件能力也足够进行 C 语言开发。最后，这门课里出现的所有代码，我都会统一放在<a href=\"https://github.com/Becavalier/geektime-c\">这个代码库</a>中，你可以根据需要自行获取。</p><h2>用一个程序快速回顾 C 核心语法</h2><p>为了让你比较完整地回顾 C 语言的核心语法，我设计了一个相对复杂的 C 语言程序作为例子。在这里，你可以先试着阅读这段代码，思考下 C 语言的使用方式。代码如下所示：</p><pre><code>#include &lt;stdlib.h&gt; \n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;stdbool.h&gt;\n\n#define BOOL_TRUE 1  // 定义用到的宏常量与宏函数；\n#define BOOL_FALSE 0\n#define typename(x) _Generic((x), \\\n  unsigned short: &quot;unsigned short int&quot;, \\\n  unsigned long: &quot;unsigned long int&quot;, \\\n  default: &quot;unknown&quot;)\n\ntypedef enum { Host, IP } IP_ADDR_TYPE;  // 定义枚举类型 IP_ADDR_TYPE，用于表示联合中生效的字段；\ntypedef struct {  // 定义结构 CONN；\n  size_t id;\n  uint16_t port;\n  bool closed;\n  IP_ADDR_TYPE addr_type;\n  union {\n    char host_name[256];\n    char ip[24];\n  };\n} CONN;\n\ninline static const char* findAddr(const CONN* pip) {  // 定义函数 findAddr，用于打印 CONN 对象的信息；\n  assert(pip != NULL);  // 运行时断言，判断传入的 CONN 指针是否有效；\n  return pip-&gt;addr_type == Host ? pip-&gt;host_name : pip-&gt;ip;\n}\n\nint main(int argc, char* argv[]) {  // 入口函数；\n  static_assert(sizeof(CONN) &lt;= 0x400, &quot;the size of CONN object exceeds limit.&quot;);  // 静态断言，判断 CONN 对象的大小是否符合要求；\n  const CONN conns[] = {  // 构造一个数组，包含三个 CONN 对象；\n    [2] = { 1, 80, BOOL_TRUE, IP, { .ip = &quot;127.0.0.1&quot; } },\n    [0] = { 2, 8080, BOOL_FALSE, IP, { .ip = &quot;192.168.1.1&quot; } },\n    { 3, 8088, BOOL_FALSE, Host, { .host_name = &quot;http://localhost/&quot; } }\n  };\n\n  for (size_t i = 0; i &lt; (sizeof(conns) / sizeof(CONN)); ++i) {  // 遍历上述 CONN 数组，并打印其中的内容；\n    printf(\n      &quot;Port: %d\\n&quot;\n      &quot;Host/Addr: %s\\n&quot;\n      &quot;Internal type of `id` is: %s\\n\\n&quot;,\n      conns[i].port,\n      findAddr(&amp;conns[i]),\n      typename(conns[i].id)\n    );\n  }\n  return EXIT_SUCCESS; \n}\n</code></pre><p>这段代码用到了横跨 K&amp;R C 到 C17 标准的许多语言特性，创建了多个基于自定义类型构建的对象，并在程序的最后将这些对象的相关信息打印了出来。</p><p>下面，就来跟着我一起梳理这段代码中用到的 C 语法特性吧。我会按照程序代码的执行顺序，来分别介绍每一个执行步骤中涉及到的关键语言知识点。其中，相关的语言结构和语法特性可以被分为下面这些类别。</p><h3>入口函数</h3><p>现在，让我们来仔细观察这个程序。首先，我们的目光来到第 31 行上名为 main 的函数。</p><p>所有的 C 程序都会使用 main 函数作为入口函数。入口函数，就是指程序开始运行时，代码中会被首先调用的那个函数。在 main 函数中，我们可以通过它接收到的实际参数，来选择性地访问程序在开始运行时，由用户传递给程序的外部参数。</p><p>main 函数在执行结束时会返回一个整数，用于表示程序执行完毕时的状态，通常返回数字 0 表示程序正常退出，返回其他数字则代表异常退出。为了保持代码的可读性，这里我们使用标准库中定义的宏常量 EXIT_SUCCESS ，作为程序退出的返回值。顾名思义，这个宏常量对应的实际值就是数字 0。</p><h3>数组</h3><p>接下来，我们来到第 33 行。可以看到，在 main 函数内部，我们使用了“括号列表（brace-enclosed lists）”的方式，完成了对数组 conns 的初始化过程。</p><p>而在初始化列表中，我们还使用了指派初始化（为初始化列表中的项设定“指派符”）的方式，来明确指定这些项在数组中的具体位置。比如这里第一项对应的 “[2]” ，就表示将该项设置为数组 conns 中的第 3 个元素（索引从 0 开始）。</p><p>数组定义完毕后，第 44 到第 46 行的代码访问了其内部存放的元素。这里我们直接使用方括号加索引值的语法形式做到了这一点。</p><h3>结构与联合</h3><p>数组 conns 内部，存放有若干个类型为 CONN 的结构对象。在 C 语言中，结构和联合（有时也被称为结构体与联合体）通常用来组织复杂类型的自定义数据。在结构中，所有定义字段的对应数据按照内存连续的方向排列；而在联合中，定义的字段同一时间只会有一个“生效”。</p><p>观察第 15 行到 24 行，可以看到：在我们对结构 CONN 的定义过程中，使用了来自 C99 标准的 <code>_Bool</code> 类型（这里的宏 bool 会展开为该类型），以及来自 C11 标准的匿名联合体。</p><p>第 34 到第 36 行，在我们对结构 CONN 对象的初始化过程中，也同样使用了类似数组的括号列表初始化，以及指派初始化。但和前面数组初始化不同的是，这里的指派是针对结构与联合类型内部的成员字段的，因此需要使用 “.” 符号来引用某个具体成员，而非数组所使用的形式。</p><h3>控制结构</h3><p>在这段代码的第 39 行，我们使用了 for 语句以循环的形式遍历了数组 conns 中的内容。除此之外，C 语言中常用的控制结构还有 switch 语句、while 语句、以及 goto 语句等等。这些语句分别以选择、迭代，及跳转这三种不同方式控制着程序的实际执行逻辑。而程序本身也可以在这些控制语句的灵活组合下变得更加复杂。</p><h3>指针</h3><p>指针是 C 语言中最危险但也最强大的“武器”之一。借助指针，我们能够灵活地操控程序享有的内存资源。</p><p>在上面代码的第 45 行，我们将数组 conns 中各个元素的地址传递给了函数 findAddr，而该函数则接收一个指向 CONN 类型对象的常量指针。所以，通过该指针，我们无法在函数内部修改指针所指向对象的值。而这在一定程度上保证了函数仅能够拥有足够完成其任务的最小权限。</p><h3>宏</h3><p>编译器对 C 源代码的处理过程分为几个阶段，其中，宏是最先被处理的一个部分。在这段代码的开头处，我们通过宏指令 “#include” 引入了程序正常运行需要的一些外部依赖项，这些引入的内容会在程序编译时得到替换。随后，我们又通过 “#define” 指令定义了相应的宏常量与宏函数，而其中的宏函数 typename 则使用到了 C11 标准新引入的 <code>_Generic</code> 关键字，以用来实现基于宏的泛型。</p><h3>断言</h3><p>在这段代码的第 32 行，我们使用了 C11 标准中提供的静态断言能力，来保证结构类型 CONN 的大小不会超过一定的阈值。而在代码的第 27 行，我们还使用了运行时断言来保证传递给函数 findAddr 的 CONN 对象指针不为空。</p><p>在 C 代码中，我们通常会使用断言，来对某种需要支持程序正常运行的假设性条件进行检查。而当条件不满足时，则在程序编译或运行时终止，并向用户抛出相应的错误信息。C 语言提供静态与动态两种类型的断言，其中静态断言会在代码编译时进行检查；而动态断言则会在程序运行过程中，执行到该断言语句时再进行检查。</p><h3>函数内联</h3><p>在函数 findAddr 的定义代码中，我们为其添加了名为 <code>inline</code> 的关键字。通过使用该关键字，我们可以“建议”编译器将该函数的内部逻辑直接替换到函数的调用位置处，以减少函数调用时产生的开销。这种方式通常使用在那些函数体较小，且会被多次调用的函数上，以产生较为显著的性能提升。</p><h3>其他特性</h3><p>除了上面提到的内容，这段代码中还涉及到了一些基本的 C 语言特性：</p><ul>\n<li>使用 <code>const</code> 定义只读变量；</li>\n<li>使用 <code>typedef</code> 定义新类型；</li>\n<li>使用 <code>static</code> 声明静态函数；</li>\n<li>使用各类运算符；</li>\n<li>调用标准库函数；</li>\n<li>使用 <code>enum</code> 定义枚举类型；</li>\n<li>……</li>\n</ul><p>这些语法特性本身比较常用，且概念较为简单，这里我就不再单独介绍了。如果你对其中的一些特性感到陌生，可以选择在 <a href=\"https://www.geeksforgeeks.org/c-programming-language/?ref=ghm\">GeeksforGeeks</a>网站上直接查找特定主题并学习，或者查阅《C Primer Plus》这些入门书籍。</p><p>到这里，我们就把 C 语言的核心语法大致捋了一遍。你可以看到，C 语言的语法并不复杂。C 语言在设计上就十分精简，截止到 C17 标准，语言本身也仅有 44 个关键字。C 语言的强大并不是源于复杂的语法设计，相反，简单的语法给了 C 开发者更高的自由度，让我们可以更加灵活地设计程序的运行逻辑。</p><h2>C 语言的编程范式是怎样的？</h2><p>抛开语法细节，从总体上来看，C 语言是一种“命令式”编程语言，和它类似的还有 Java、C#、Go 等语言。</p><p>命令式编程（Imperative Programming）是这样一种编程范式：使用可以改变程序状态的代码语句，描述程序应该如何运行。这种方式更关注计算机完成任务所需要执行的具体步骤。</p><p>下面我们来看一个例子。对于“从一个包含有指定数字的集合中，筛选出大于 7 的所有数字”这个需求，按照命令式编程的思路，我们需要通过编程语言来告诉计算机具体的执行步骤。</p><p>以 C 语言为例，解决这个需求的步骤可能会是这样：</p><ol>\n<li>使用数组，构造一块可以存放这些数字的内存空间；</li>\n<li>使用循环控制语句，依次检查内存中的这些数字是否满足要求（即大于 7）；</li>\n<li>对于满足要求的数字，将它们拷贝到新的内存空间中，暂存为结果。<br>\n对应的代码可能如下所示：</li>\n</ol><pre><code class=\"language-c++\">#define ARR_LEN 5\nint main(void) {&nbsp;\n&nbsp; int arr[ARR_LEN] = { 1, 5, 10, 9, 0 };\n&nbsp; for (int i = 0; i &lt; ARR_LEN; ++i) {\n&nbsp; &nbsp; if (arr[i] &gt; 7) {\n&nbsp; &nbsp; &nbsp; // save this element somewhere else.\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp; return 0;\n}\n</code></pre><p>相对于命令式编程语言，其他语言一般会被归类为“声明式”编程语言。声明式编程（Declarative Programming）也是一种常见的编程范式。<strong>不同的是，这种范式更倾向于表达计算的逻辑，而非解决问题时计算机需要执行的具体步骤。</strong></p><p>比如说，还是刚才那个需求，在使用声明式编程语言时，对应的解决步骤可能是：</p><ol>\n<li>构建一个容器来存放数据；</li>\n<li>按照条件对容器数据进行筛选，并将符合条件的数据作为结果返回。<br>\n如果以 JavaScript 为例，对应的代码可能如下所示：</li>\n</ol><pre><code class=\"language-javascript\">let arr = [1, 5, 10, 9, 0]\nlet result = arr.filter(n =&gt; n &gt; 7)\n</code></pre><p>可以看到的是，相较于命令式编程，声明式编程更倾向于表达在解决问题时应该做什么（构建容器、筛选），而不是具体怎么做（分配内存、遍历、拷贝）。</p><p>通常来说，命令式编程语言和声明式编程语言的差异，主要体现在两者的语言特性相较于计算机指令集的抽象程度。其中，命令式编程语言的抽象程度更低，这意味着该类语言的语法结构可以直接由相应的机器指令来实现。而声明式编程语言的抽象程度更高，这类语言更倾向于以叙事的方式来描述程序逻辑，开发者无需关心语言背后在机器指令层面的实现细节。两种语言在使用上各有其适用场景，并无孰好孰坏之分。</p><p>那么，C 语言作为一种低抽象层次的命令式编程语言，它的各类语法结构是如何对应到不同机器指令的？我会在下一个模块“语法核心实现篇”里为你详细介绍。</p><h2>C 程序的编译和运行</h2><p>编写完一段 C 代码，接下来的步骤就是对这段代码进行编译了。在执行编译命令时，为了保证程序的健壮性，我们一般会同时附带参数 “-Wall”，让编译器明确指出程序代码中存在的所有语法使用不恰当的地方。</p><p>如果将那段用来回顾核心语法的 C 代码存放在名为 “demo.c” 的文件中，那我们可以使用下面这行命令来编译并运行这个程序：</p><pre><code class=\"language-bash\">gcc demo.c&nbsp;-o demo -Wall &amp;&amp; ./demo\n</code></pre><p>一般来说，C 代码的完整编译过程可以分为如下四个阶段：</p><p><img src=\"https://static001.geekbang.org/resource/image/95/c2/957691f0ac44315ebf5619d553df4ac2.jpg?wh=1920x571\" alt=\"图片\"></p><ol>\n<li><strong>代码预处理</strong>：编译器会首先移除源代码中的所有注释信息，并处理所有宏指令。其中包括进行宏展开、宏替换，以及条件编译等。</li>\n<li><strong>编译优化</strong>：编译器会分析和优化源代码，并将其编译成对应的汇编格式代码，这部分代码中含有使用汇编指令描述的原始 C 程序逻辑。</li>\n<li><strong>汇编</strong>：编译器会将这些汇编代码编译成具有一定格式，可以被操作系统使用的某种对象文件格式。</li>\n<li><strong>链接</strong>：通过链接处理，编译器会将所有程序目前需要的对象文件进行整合、设置好程序中所有调用函数的正确地址，并生成对应的二进制可执行文件。<br>\n编译结束后，我们就得到了可以直接运行的二进制文件。在不同的操作系统上，你可以通过不同的方式来运行这个程序，比如双击或通过命令行。</li>\n</ol><h2>总结</h2><p>讲到这里，今天的内容也就基本结束了，最后我来给你总结一下。</p><p>这一讲，我们通过一个实例，带你快速回顾了 C 语言的一些重要语法特性。为了方便你复习，我把这些涉及到的核心语法特性总结成了一张表格：</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/16/a3797cfb319938f359812da1baf3b316.jpg?wh=1920x1783\" alt=\"图片\"></p><p>我还带你回顾了一个 C 程序的完整生命周期：代码编写、编译、运行。其中，C 代码的完整编译过程可以分为代码预处理、编译优化、汇编、链接四个阶段。程序的汇编、链接与运行，都会涉及与所在操作系统相关的一系列精细处理过程。我会在这门课的第四个模块中带你深入了解这些内容。</p><p>除此之外，我们还从语言本身的角度，探讨了 C 语言与其他编程语言的不同之处。C 语言作为一种命令式编程语言，抽象程度更低，语法结构可以直接由相应的机器指令经过简单的组合来实现。</p><h2>思考题</h2><p>最后，我们一起来做一个思考题吧。</p><p>在这一讲第一部分的 C 代码实例中，我们为何要给函数 findAddr 添加 <code>static</code> 关键字？不添加这个关键字的话，程序是否可以编译运行？欢迎在评论区分享你的思考和见解。</p><p>希望这一讲可以让你对 C 语言的基本情况有一个整体的感知。下一讲，我们会从一个 C 程序的基石，数据和量值出发，正式开始我们的 “C 语言核心语法实现”之旅，一起来看编译器是如何在背后实现这些基本语法的。我们下一讲见！</p>","comments":[{"had_liked":false,"id":325525,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":true,"comment_ctime":1639016229,"is_pvip":false,"replies":[{"id":"118135","content":"哈哈哈，实践出真知！<br><br>我直接在这里解答一下这个问题。正确情况下是如果在非优化的情况下，inline 需要配合 static 或者 extern 才能够编译。而在优化情况下，inline 可以单独使用。为什么会这样呢？<br><br>实际上，在 C17 标准中我们使用的 inline 关键字来源于 C99 标准。而在这个标准中，仅带有 inline 的函数具有 inline definition，表明该函数定义仅用于内联。而在非优化情况下，编译器通常会去寻找对应符号的 external definition（可以通过添加 extern 而获得），因此这种情况下会出现 linker error。而通过添加 static 关键字，可以使得对应函数定义具有 internal linkage，从而被编译器使用。在优化情况下，编译器会直接使用 inline definition 进行内联。<br><br>具体可以参考标准：http:&#47;&#47;www.open-std.org&#47;jtc1&#47;sc22&#47;WG14&#47;www&#47;docs&#47;n1256.pdf（112页，6.7.4.6）","user_name":"作者回复","comment_id":325525,"uid":"1005890","ip_address":"","utype":1,"ctime":1639058369,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"9.2233721759327007e+18","product_id":100100701,"comment_content":"我尝试去掉了 findAddr 函数中的 static 关键字，如下：<br>inline &#47;*static*&#47; const char* findAddr(const CONN* pip)<br>再次尝试编译，发现完全编译不过：<br>gcc -o demo -Wall .&#47;example.c <br>&#47;tmp&#47;ccPazvp1.o: In function `main&#39;:<br>example.c:(.text+0x14f): undefined reference to `findAddr&#39;<br>collect2: error: ld returned 1 exit status<br><br>评论区几乎无人去动手，差点误导了我，我猜测是与 const 这个关键词有关，请老师详解一下","like_count":33,"discussions":[{"author":{"id":2440338,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3c/92/81fa306d.jpg","nickname":"张Dave","note":"","ucode":"0E8B6FDEB7505B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557222,"discussion_content":"在优化的情况下，是指添加类似O2选项吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647701861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537428,"discussion_content":"哈哈哈，实践出真知！\n\n我直接在这里解答一下这个问题。正确情况下是如果在非优化的情况下，inline 需要配合 static 或者 extern 才能够编译。而在优化情况下，inline 可以单独使用。为什么会这样呢？\n\n实际上，在 C17 标准中我们使用的 inline 关键字来源于 C99 标准。而在这个标准中，仅带有 inline 的函数具有 inline definition，表明该函数定义仅用于内联。而在非优化情况下，编译器通常会去寻找对应符号的 external definition（可以通过添加 extern 而获得），因此这种情况下会出现 linker error。而通过添加 static 关键字，可以使得对应函数定义具有 internal linkage，从而被编译器使用。在优化情况下，编译器会直接使用 inline definition 进行内联。\n\n具体可以参考标准：http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf（112页，6.7.4.6）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639058369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325164,"user_name":"ZR2021","can_delete":false,"product_type":"c1","uid":1707352,"ip_address":"","ucode":"4F685C7516F057","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","comment_is_top":true,"comment_ctime":1638846697,"is_pvip":false,"replies":[{"id":"118005","content":"这是一个好问题。首先，这两种写法都是可以正常工作的。在 C17 标准之前，declaration specifier 可以按照任意的顺序摆放。而自 C17 标准之后，便规定 storage-class specifier（包含 static）应该被放置在各类定义的最开始，其他形式则为过时的写法。<br><br>6.11.5 Storage-class specifier<br>The placement of a storage-class speciﬁer other than at the beginning of the declaration speciﬁers in a declaration is an obsolescent feature.","user_name":"作者回复","comment_id":325164,"uid":"1005890","ip_address":"","utype":1,"ctime":1638858516,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"9.2233721286879007e+18","product_id":100100701,"comment_content":"老师，为啥是inline static而不是static inline的？这里有点奇怪","like_count":22,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536731,"discussion_content":"这是一个好问题。首先，这两种写法都是可以正常工作的。在 C17 标准之前，declaration specifier 可以按照任意的顺序摆放。而自 C17 标准之后，便规定 storage-class specifier（包含 static）应该被放置在各类定义的最开始，其他形式则为过时的写法。\n\n6.11.5 Storage-class specifier\nThe placement of a storage-class speciﬁer other than at the beginning of the declaration speciﬁers in a declaration is an obsolescent feature.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638858516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325596,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1639035523,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"70358512259","product_id":100100701,"comment_content":"C99里inline函数需要两套声明，一个inline的，一个非inline的。例子里的程序如果去掉static的话，如果编译时没有优化就不会用到inline的声明，而如果找不到非inline的声明的话就会报链接错误。<br><br>如果不想写两套声明的话，要么加上static（这样就内部链接了），要么加优化参数-O2以上。","like_count":17},{"had_liked":false,"id":325098,"user_name":"ZR2021","can_delete":false,"product_type":"c1","uid":1707352,"ip_address":"","ucode":"4F685C7516F057","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","comment_is_top":false,"comment_ctime":1638807273,"is_pvip":false,"replies":[{"id":"118000","content":"哈哈哈，欢迎支持，一起学习！","user_name":"作者回复","comment_id":325098,"uid":"1005890","ip_address":"","utype":1,"ctime":1638852035,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"23113643753","product_id":100100701,"comment_content":"工作5年了，都是纯c开发，看了很多开源代码，内核代码，就是没时间好好总结深入，正好这次趁这门课跟着于老师好好总结学习下，万分期待！！！","like_count":6,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536709,"discussion_content":"哈哈哈，欢迎支持，一起学习！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638852035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2613059,"avatar":"https://static001.geekbang.org/account/avatar/00/27/df/43/0773c064.jpg","nickname":"不会MATLAB","note":"","ucode":"725795EDB38F5A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538901,"discussion_content":"老哥嵌入式吗，俺也一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639553438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1707352,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","nickname":"ZR2021","note":"","ucode":"4F685C7516F057","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2613059,"avatar":"https://static001.geekbang.org/account/avatar/00/27/df/43/0773c064.jpg","nickname":"不会MATLAB","note":"","ucode":"725795EDB38F5A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":540628,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640098475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":538901,"ip_address":""},"score":540628,"extra":""}]}]},{"had_liked":false,"id":325094,"user_name":"送过快递的码农","can_delete":false,"product_type":"c1","uid":1587666,"ip_address":"","ucode":"66EA81B3BADC73","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","comment_is_top":false,"comment_ctime":1638805814,"is_pvip":false,"replies":[{"id":"118019","content":"C 中的宏你可以简单理解为根据一定规则对源代码进行的字符替换，并且这个过程是在编译器开始处理 C 语法代码之前就会进行的。这部分内容我们会在第 09 讲介绍哈。","user_name":"作者回复","comment_id":325094,"uid":"1005890","ip_address":"","utype":1,"ctime":1638868292,"user_name_real":"编辑"}],"discussion_count":5,"race_medal":0,"score":"10228740406","product_id":100100701,"comment_content":"老师，宏和函数的区别是啥？我之前听说他比函数访问更加快？执行上面是否一致呢，函数要进行call，压栈，完事儿出栈，还得ret返回调用前地址 ，但是宏相对简单一点？函数编译需要链接，宏相当于常量，操作系统全局，所以不需要么？函数处理内容更加多，宏比较固定？主要Java程序员没接触过宏，所以感觉是个很陌生的领域","like_count":2,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536787,"discussion_content":"C 中的宏你可以简单理解为根据一定规则对源代码进行的字符替换，并且这个过程是在编译器开始处理 C 语法代码之前就会进行的。这部分内容我们会在第 09 讲介绍哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638868292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539227,"discussion_content":"其实我之前做lab的时候也是在思考 宏到底有什么用 期待第九章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639645058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1707352,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","nickname":"ZR2021","note":"","ucode":"4F685C7516F057","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536556,"discussion_content":"宏的话在预处理阶段就直接展开了，没有入栈出栈等操作，自然快了很多，只是对参数类型没法做检查，但是内敛函数可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638806529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1587666,"avatar":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","nickname":"送过快递的码农","note":"","ucode":"66EA81B3BADC73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1707352,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","nickname":"ZR2021","note":"","ucode":"4F685C7516F057","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536739,"discussion_content":"那么问题来了，内敛函数是啥？又多了一个不懂的概念😭","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638860327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536556,"ip_address":""},"score":536739,"extra":""},{"author":{"id":1707352,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","nickname":"ZR2021","note":"","ucode":"4F685C7516F057","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1587666,"avatar":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","nickname":"送过快递的码农","note":"","ucode":"66EA81B3BADC73","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536767,"discussion_content":"不好意思，写错了，是内联，一种介于函数和宏之间的玩意，加快运行速度而且能检查参数类型的玩意，应该还是在预处理阶段就展开到各个调用函数中了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638865008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536739,"ip_address":""},"score":536767,"extra":""}]}]},{"had_liked":false,"id":325296,"user_name":"勇闯天涯","can_delete":false,"product_type":"c1","uid":1496539,"ip_address":"","ucode":"3C0F9F7DA2CA9A","user_header":"https://static001.geekbang.org/account/avatar/00/16/d5/db/3f9499d1.jpg","comment_is_top":false,"comment_ctime":1638894174,"is_pvip":false,"replies":[{"id":"118051","content":"可以看看《Modren C》？","user_name":"作者回复","comment_id":325296,"uid":"1005890","ip_address":"","utype":1,"ctime":1638924655,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"5933861470","product_id":100100701,"comment_content":"老师你好，有什么推荐的C语言书籍吗？偏进阶和高级篇的那种","like_count":1,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536968,"discussion_content":"可以看看《Modren C》？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638924655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2592779,"avatar":"https://static001.geekbang.org/account/avatar/00/27/90/0b/95b2d9ea.jpg","nickname":"好名字","note":"","ucode":"BF933A563EC57F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":537611,"discussion_content":"老师我搜索modern c搜不到相关书籍😟 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639118564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536968,"ip_address":""},"score":537611,"extra":""},{"author":{"id":1494781,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ce/fd/96e19d75.jpg","nickname":"Wittgenstein","note":"","ucode":"E15993F5DDBB9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2592779,"avatar":"https://static001.geekbang.org/account/avatar/00/27/90/0b/95b2d9ea.jpg","nickname":"好名字","note":"","ucode":"BF933A563EC57F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539498,"discussion_content":"ISBN:9787111681960\n去淘宝搜就有。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639730005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537611,"ip_address":""},"score":539498,"extra":""}]}]},{"had_liked":false,"id":325254,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1638880788,"is_pvip":false,"replies":[{"id":"118049","content":"不一定哈，可以在函数调用前先写函数原型，然后函数体就可以放在任意位置了。","user_name":"作者回复","comment_id":325254,"uid":"1005890","ip_address":"","utype":1,"ctime":1638922689,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5933848084","product_id":100100701,"comment_content":"findAddr函数一定要写在main函数的前面吗？","like_count":1,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536958,"discussion_content":"不一定哈，可以在函数调用前先写函数原型，然后函数体就可以放在任意位置了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638922690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344527,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1651631680,"is_pvip":false,"replies":[{"id":"125878","content":"这里的指针是一个 const 指针，所以我们无法通过该指针来修改指向变量的值。","user_name":"作者回复","comment_id":344527,"uid":"1005890","ip_address":"","utype":1,"ctime":1651844966,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1651631680","product_id":100100701,"comment_content":"通过该指针，我们无法在函数内部修改指针所指向对象的值。<br><br>？？ <br><br>这个说法有问题吧？？拿到地址了，可以改地址对应的内存吧","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570652,"discussion_content":"这里的指针是一个 const 指针，所以我们无法通过该指针来修改指向变量的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651844966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593681,"avatar":"https://static001.geekbang.org/account/avatar/00/18/51/51/381876ab.jpg","nickname":"文康","note":"","ucode":"E1952B9DFB5DF4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582961,"discussion_content":"产量指针类型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659843856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341185,"user_name":"纳兰容若","can_delete":false,"product_type":"c1","uid":1605876,"ip_address":"","ucode":"2E1EA2CDFDA1A9","user_header":"https://static001.geekbang.org/account/avatar/00/18/80/f4/564209ea.jpg","comment_is_top":false,"comment_ctime":1649407599,"is_pvip":true,"replies":[{"id":"124769","content":"可以在这边看哈，不过需要科学上网：https:&#47;&#47;en.cppreference.com&#47;w&#47;c<br>","user_name":"作者回复","comment_id":341185,"uid":"1005890","ip_address":"","utype":1,"ctime":1649590045,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1649407599","product_id":100100701,"comment_content":"老师您好 有个问题请教一下<br>咱们的示例程序中_Generic使用了c11的语法<br>类似的c11、c17中新用法在哪里查询呢<br>有类似MSDN的文档么","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561265,"discussion_content":"可以在这边看哈，不过需要科学上网：https://en.cppreference.com/w/c\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649590045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1605876,"avatar":"https://static001.geekbang.org/account/avatar/00/18/80/f4/564209ea.jpg","nickname":"纳兰容若","note":"","ucode":"2E1EA2CDFDA1A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":561494,"discussion_content":"多谢老师回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649648143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":561265,"ip_address":""},"score":561494,"extra":""}]}]},{"had_liked":false,"id":339039,"user_name":"JulyRemember","can_delete":false,"product_type":"c1","uid":1312184,"ip_address":"","ucode":"9E3D5D60D82999","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","comment_is_top":false,"comment_ctime":1647869894,"is_pvip":false,"replies":[{"id":"123914","content":"可以看一下是不是编译时使用了 -O0 以上的优化等级。","user_name":"作者回复","comment_id":339039,"uid":"1005890","ip_address":"","utype":1,"ctime":1647877895,"user_name_real":"作者"}],"discussion_count":1,"race_medal":0,"score":"1647869894","product_id":100100701,"comment_content":"为啥我用VScode去掉static可以编译通过并且运行结果是和不加值一样的，因为对C语言不太了解，所以也不知道为啥。","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557609,"discussion_content":"可以看一下是不是编译时使用了 -O0 以上的优化等级。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647877895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337521,"user_name":"Geek_e95a91","can_delete":false,"product_type":"c1","uid":2828685,"ip_address":"","ucode":"3AA6A16346D29F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK4SzX9OsN0YTrWeOsibk34iaJDYRKkvia1o5h6U5hbE37nB6ptQU4ibznvfFN3mjsibSWqBEZXyyBdXog/132","comment_is_top":false,"comment_ctime":1646879224,"is_pvip":false,"replies":[{"id":"123467","content":"你是说 C++ 中的 template 吗？","user_name":"作者回复","comment_id":337521,"uid":"1005890","ip_address":"","utype":1,"ctime":1647056867,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1646879224","product_id":100100701,"comment_content":"typename(),c标准支持嘛？","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555748,"discussion_content":"你是说 C++ 中的 template 吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647056867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326977,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1216016,"ip_address":"","ucode":"C34D4C44DBCE03","user_header":"https://static001.geekbang.org/account/avatar/00/12/8e/10/10092bb1.jpg","comment_is_top":false,"comment_ctime":1639810420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639810420","product_id":100100701,"comment_content":"针对本程序，去掉static是不可以编译运行的。一开始没注意有个inline<br><br>之所以添加static修饰，是为了限定该接口只能被本编译单元使用。<br>c的接口默认是extern的，外部只要添加接口声明即可引用该接口，因此需要显式地添加static来限定可能的引用以及同名符号冲突。","like_count":0},{"had_liked":false,"id":325621,"user_name":"Jerry_Yuan","can_delete":false,"product_type":"c1","uid":1387096,"ip_address":"","ucode":"525A52D7369DBC","user_header":"https://static001.geekbang.org/account/avatar/00/15/2a/58/fabdfe69.jpg","comment_is_top":false,"comment_ctime":1639047155,"is_pvip":false,"replies":[{"id":"118136","content":"可以参考我在另一个问题下的回答哈。","user_name":"作者回复","comment_id":325621,"uid":"1005890","ip_address":"","utype":1,"ctime":1639058476,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1639047155","product_id":100100701,"comment_content":"const char* findAddr(const CONN* pip)可以过编译，但是同时去掉static和inline变成inline const char* findAddr(const CONN* pip)则不能过编译，但是都可以gcc -S生成汇编代码。后者发生ld error，是不是编译器觉得这个findAddr是从别的地方来的，不是特别安全呢？","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537429,"discussion_content":"可以参考我在另一个问题下的回答哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639058476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325507,"user_name":"=","can_delete":false,"product_type":"c1","uid":2600127,"ip_address":"","ucode":"104232A8292220","user_header":"https://static001.geekbang.org/account/avatar/00/27/ac/bf/f549183e.jpg","comment_is_top":false,"comment_ctime":1639011026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639011026","product_id":100100701,"comment_content":"加static是为了让findAddr()函数只在本文件中使用，不能够被其他文件外部调用。<br>在本例中，可以去掉static。","like_count":0},{"had_liked":false,"id":325160,"user_name":"dog_brother","can_delete":false,"product_type":"c1","uid":1619597,"ip_address":"","ucode":"9F64D3C6D815FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","comment_is_top":false,"comment_ctime":1638845446,"is_pvip":true,"replies":[{"id":"118013","content":"正解！","user_name":"作者回复","comment_id":325160,"uid":"1005890","ip_address":"","utype":1,"ctime":1638866220,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1638845446","product_id":100100701,"comment_content":"我们用的还是gcc 4.8.5，用老师介绍的https:&#47;&#47;godbolt.org&#47;这个工具，很牛啊，原来老师开篇里的c和汇编的对比图是这么来的呀~","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536777,"discussion_content":"正解！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638866220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325118,"user_name":"jack123","can_delete":false,"product_type":"c1","uid":2718510,"ip_address":"","ucode":"873D0046EF39D6","user_header":"","comment_is_top":false,"comment_ctime":1638835333,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1638835333","product_id":100100701,"comment_content":"应该可以吧，函数加上static，表示仅本文件内访问，不加static默认是extern的，其他文件include的时候，可以被调用到","like_count":0,"discussions":[{"author":{"id":1188710,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","nickname":"LDxy","note":"","ucode":"956432CE7B7761","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536835,"discussion_content":"既然不加static就默认是extern，那extern关键字又有什么用呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638880575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2718510,"avatar":"","nickname":"jack123","note":"","ucode":"873D0046EF39D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1188710,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","nickname":"LDxy","note":"","ucode":"956432CE7B7761","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536959,"discussion_content":"在C++中有用，C++里面要引用C语言写的函数或者变量时，用extern “C”表示编译器用C语言的方式编译这段代码","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638922836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536835,"ip_address":""},"score":536959,"extra":""}]}]},{"had_liked":false,"id":325110,"user_name":"dog_brother","can_delete":false,"product_type":"c1","uid":1619597,"ip_address":"","ucode":"9F64D3C6D815FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","comment_is_top":false,"comment_ctime":1638832368,"is_pvip":true,"replies":[{"id":"118018","content":"函数式编程是声明式编程的一种，但面向对象属于哪一种类型本身是有争论的。","user_name":"作者回复","comment_id":325110,"uid":"1005890","ip_address":"","utype":1,"ctime":1638868088,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1638832368","product_id":100100701,"comment_content":"老师，命令式编程和声明式编程，是不是可以理解为面向对象和函数式编程啊？","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536785,"discussion_content":"函数式编程是声明式编程的一种，但面向对象属于哪一种类型本身是有争论的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638868088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1370125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e8/0d/6d303d18.jpg","nickname":"无双BaOY_WHA","note":"","ucode":"41F282C31D256C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537093,"discussion_content":"“左耳听风”专栏里面有一个“编程范式游记”系列，讲过各种编程范式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638955265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325109,"user_name":"dog_brother","can_delete":false,"product_type":"c1","uid":1619597,"ip_address":"","ucode":"9F64D3C6D815FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","comment_is_top":false,"comment_ctime":1638832262,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638832262","product_id":100100701,"comment_content":"static修饰函数，表示该函数只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用。在本文的事例里，去掉也是可以的。","like_count":0}]}