{"id":141817,"title":"09 | MVC架构解析：视图（View）篇","content":"<p>你好，我是四火。</p><p>今天我们继续学习 MVC 架构，主要内容就是 MVC 架构的第二部分——视图（View）。</p><h2>概念</h2><p>首先，我想问一问，什么是视图？有程序员说是界面，有程序员说是 UI（User Interface），这些都对，但是都不完整。</p><p>我认为<strong>MVC 架构中的视图是指将数据有目的、按规则呈现出来的组件</strong>。因此，如果返回和呈现给用户的不是图形界面，而是 XML 或 JSON 等特定格式组织呈现的数据，它依然是视图，而用 MVC 来解决的问题，也绝不只是具备图形界面的网站或者 App 上的问题。</p><h2>页面聚合技术</h2><p>虽然视图的定义实际更宽泛，但是我们平时讲到的视图，多半都是指“页面”。这里，就不得不提花样繁多的页面聚合技术了。</p><p>回想一下，之前我们在讲 Model 层的时候，是怎样解耦的？我们的办法就是继续分层，或是模块化；而对于 View 层来说，我们的办法则是拆分页面，分别处理，最终聚合起来。具体来说，这里提到的页面聚合，是指将展示的信息通过某种技术手段聚合起来，并形成最终的视图呈现给用户。页面聚合有这样两种典型类型。</p><ul>\n<li><strong>结构聚合：指的是将一个页面中不同的区域聚合起来，这体现的是分治的思想。</strong>例如一个页面，具备页眉、导航栏、目录、正文、页脚，这些区域可能是分别生成的，但是最后需要把它们聚合在一起，再呈现给用户。</li>\n<li><strong>数据-模板聚合：指的是聚合静态的模板和动态的数据，这体现的是解耦的思想。</strong>例如有的新闻网站首页整个页面的 HTML 是静态的，用户每天看到的样子都是差不多的，但每时每刻的新闻列表却是动态的，是不断更新的。</li>\n</ul><!-- [[[read_end]]] --><p>请注意这两者并不矛盾，很多网站的页面都兼具这两种聚合方式。</p><h3>服务端和客户端聚合方式的比较</h3><p>客户端聚合技术的出现远比服务端晚，因为和服务端聚合不同，这种聚合方式对于客户端的运算能力，客户端的 JavaScript 技术，以及浏览器的规范性都有着明确的要求。但是，客户端聚合技术却是如今更为流行的技术，其原因包括：</p><p><strong>架构上，客户端聚合达成了客户端-服务端分离和模板-数据聚合这二者的统一，这往往可以简化架构，保持灵活性。</strong></p><p>比如说，对于模板和静态资源（如脚本、样式、图片等），可以利用 CDN（Content Delivery Network，内容分发网络）技术，从网络中距离最近的节点获取，以达到快速展示页面的目的；而动态的数据则可以从中心节点异步获取，速度会慢一点，但保证了数据的一致性。数据抵达浏览器以后，再完成聚合，静态和动态的资源可以根据实际情况分别做服务端和客户端的优化，比如浏览器适配、缓存等等。如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/7b/c9877f90430f892d1b5e3d8fbb94a47b.png?wh=906*946\" alt=\"\"></p><p>你看上面这个例子，浏览器在上海，模板和静态资源从本地的上海节点获取，而数据异步从北京的中心节点获取。这种方式下，静态资源的访问是比较快的，而为了保证一致性，数据是从北京的中心节点获取的，这个速度会慢一些。在模板抵达浏览器以后，先展示一个等待的效果，并等待数据返回。在数据也抵达浏览器以后，则立即通过 JavaScript 进行客户端的聚合，展示聚合后的页面。</p><p>如果我们使用服务端聚合，就必须在服务端同时准备好模板和数据，聚合形成最终的页面，再返回给浏览器。整个过程涉及到的处理环节更多，架构更为复杂，而且同样为了保证一致性，数据必须放在北京节点，那么模板也就被迫从北京节点取得，聚合完成之后再返回，这样用户的等待时间会更长，用户也会看到浏览器的进度条迟迟完不成。见下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/62/6ccf2cb3605d0dbfa32e790157ca5a62.png?wh=1034*1258\" alt=\"\"></p><p><strong>资源上，客户端聚合将服务器端聚合造成的计算压力，分散到了客户端。</strong>可是实际上，这不只是计算的资源，还有网络传输的资源等等。比如说，使用服务端聚合，考虑到数据是会变化的，因而聚合之后的报文无法被缓存；而客户端聚合则不然，通常只有数据是无法被缓存，模板是可以被缓存起来的。</p><p>但是，<strong>客户端聚合也有它天然的弊端。其中最重要的一条，就是客户端聚合要求客户端具备一定的规范性和运算能力</strong>。这在现在多数的浏览器中都不是问题，但是如果是手机浏览器，这样的问题还是很常见的，由于操作系统和浏览器版本的不同，考虑聚合逻辑的兼容性，客户端聚合通常对终端适配有更高的要求，需要更多的测试。</p><p>在实际项目中，我们往往能见到客户端聚合和服务端聚合混合使用。具体来说，Web 页面通常主要使用客户端聚合，而某些低端设备页面，甚至 Wap 页面（常用于较为低端的手机上）则主要使用服务端聚合。下面我们就来学习一些具体的聚合技术。</p><h3>常见的聚合技术</h3><p><strong>1. iFrame 聚合</strong></p><p>iFrame 是一种最为原始和简单的聚合方式，也是 CSI（Client Side Includes，客户端包含）的一种典型方式，现在很多门户网站的广告投放，依然在使用。具体实现，只需要在 HTML 页面中嵌入这样的标签即可：</p><pre><code>&lt;iframe src=&quot;https://...&quot;&gt;&lt;/iframe&gt;\n</code></pre><p>这种方式本质上是给当前页面嵌入了一个子页面，对于浏览器来说，它们是完全独立的两个页面。其优势在于，不需要考虑跨域问题，而且如果这个子页面出了问题，往往也不会影响到父页面的展示。</p><p>不过，这种方式的缺点也非常明显，也是因为它们是两个独立的页面。比如子页面和父页面之间的交互和数据传递往往比较困难，再比如预留 iFrame 的位置也是静态的，不方便根据 iFrame 实际的内容和浏览器的窗口情况自适应并动态调整占用位置和大小，再比如对搜索引擎的优化不友好等等。</p><p><strong>2. 模板引擎</strong></p><p>模板引擎是最完备、最强大的解决方案，无论客户端还是服务端，都有许许多多优秀的模板引擎可供选择。比如 <a href=\"http://mustache.github.io/\">Mustache</a>，它不但可以用作客户端，也可以用作服务端的聚合，这是因为它既有 JavaScript 的库，也有后端语言，比如 Java 的库，再比如非常常用的 <a href=\"https://underscorejs.org/\">Underscore.js</a>，性能非常出色。</p><p>某些前端框架，为了达到功能或性能上的最优，也会自带一套自己的模板引擎，比如 AngularJS，我在下一章讲前端的时候会介绍。</p><p><strong>在使用模板引擎的时候，需要注意保持 View 层代码职责的清晰和纯粹</strong>，这在全栈项目开发的过程中尤为重要。负责视图，就只做展示的工作，不要放本该属于 Model 层的业务逻辑，也不要干请求转发和流程控制等 Controller 的活。回想上一讲我们学的 JSP 模板，就像 JSP Model 1 一样，功能多未必代表着模板引擎的优秀，有时候反而是留下了一个代码耦合的后门。</p><p><strong>3. Portlet</strong></p><p>Portlet 在早几年的门户应用（Portal）中很常见，它本身是一种 Web 的组件，每个 Portlet 会生成一个标记段，多个 Portlets 生成的标记段可以最终聚集并嵌入到同一个页面上，从而形成一个完整的最终页面。</p><p>技术上，Portlet 可以做到远程聚合（服务端），也可以做到本地聚合（客户端），数据来源的业务节点可以部署得非常灵活，因此在企业级应用中也非常常见。</p><p>Java 的 Portlet 规范经历了<a href=\"https://en.wikipedia.org/wiki/Java_Portlet_Specification\">三个版本</a>，详细定义了 Portlet 的生命周期、原理机制、容器等等方方面面。从最终的呈现来看，网站应用 Portlet 给用户的体验就像是在操作本地计算机一样，多个窗口层叠或平铺在桌面，每个窗口都是独立的，自包含的，并且可以任意调整位置，改变布局和大小。</p><p>如今 Portlet 因为其实现的复杂性、自身的限制，和较陡峭的学习曲线，往往显得比较笨重，因此应用面并不是很广泛。</p><p><img src=\"https://static001.geekbang.org/resource/image/03/01/036c657fa6fff4d4f3ba4ce91364bc01.jpg?wh=1844*1374\" alt=\"\">（上图来自 JBoss 的官方文档：<a href=\"https://docs.jboss.org/gatein/portal/3.4.0.Final/reference-guide/en-US/html/chap-Reference_Guide-Portlet_development.html\">Portlet development</a>，上图代表了一个页面，上面的每一个窗口都分别由一个 Portlet 实现）</p><p><strong>4. SSI</strong></p><p>还记得前面讲过的 CSI，客户端包含吗？与之相对的，自然也有服务端包含——SSI（ Server Side Includes）。它同样是一种非常简单的服务端聚合方式，大多数流行的 Web 服务器都支持 SSI 的语法。</p><p>比如下面这样的一条“注释”，从 HTML 的角度来讲，它确实是一条普通的注释，但是对于支持 SSL 的服务器来说，它就是一条特殊的服务器端包含的指令：</p><pre><code>&lt;!--#include file=&quot;extend.html&quot; --&gt;\n</code></pre><h2>模板引擎的工作机制</h2><p>前面已经提及了一些常见的页面聚合技术，但是模板引擎始终是最常用的，也自然是其中的重点。下面我们就结合一个小例子来一窥模板引擎的工作机制。</p><p>还记得  <a href=\"https://time.geekbang.org/column/article/140196\">[第 07 讲]</a>  介绍的 JSP 工作原理吗？类似的，模板引擎把渲染的工作分为编译和执行两个环节，并且只需要编译一次，每当数据改变的时候，模板并没有变，因而反复执行就可以了。</p><p>只不过这次，<strong>我们在编译后生成的目标代码，不再是 class 文件了，而是一个 JavaScript 的函数</strong>。因此我们可以尽量把工作放到预编译阶段去，生成函数以后，原始的模板就不再使用了，后面每次需要执行和渲染的时候直接调用这个函数传入参数就可以了。</p><p>比如这样的 <a href=\"https://handlebarsjs.com/\">Handlebars</a> 模板，使用一个循环，要在一个表格中列出图书馆所有图书的名字和描述：</p><pre><code>&lt;table&gt;\n  {{#each books}}\n  &lt;tr&gt;\n    &lt;td&gt;\n      {{this.name}}\n    &lt;/td&gt;\n    &lt;td&gt;\n      {{this.desc}}\n    &lt;/td&gt;\n  &lt;/tr&gt;\n  {{/each}}\n&lt;/table&gt;\n</code></pre><p>接着，模板被加载到变量 templateContent 里面，传递给 Handlebars 来进行编译，编译的结果是一个可执行的函数 func。编译过程完成后，就可以进行执行的过程了，func 接受一个图书列表的入参，输出模板执行后的结果。这两个过程如下：</p><pre><code>var func = Handlebars.compile(templateContent);\nvar result = func({\n    books : [\n        { name : &quot;A&quot;, desc : &quot;...&quot; },\n        { name : &quot;B&quot;, desc : &quot;...&quot; }\n    ]\n});\n</code></pre><p>如果我们想对这个 func 一窥究竟，我们将看到类似这样的代码：</p><pre><code>var buffer = &quot;&quot;, stack1, functionType=&quot;function&quot;, escapeExpression=this.escapeExpression, self=this;\n\nfunction program1(depth0,data) {\n  var buffer = &quot;&quot;, stack1;\n  buffer += &quot;\\n  &lt;tr&gt;\\n    &lt;td&gt;&quot;\n    + escapeExpression(((stack1 = depth0.name),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))\n    + &quot;&lt;/td&gt;\\n    &lt;td&gt;&quot;\n    + escapeExpression(((stack1 = depth0.desc),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))\n    + &quot;&lt;/td&gt;\\n  &lt;/tr&gt;\\n  &quot;;\n  return buffer;\n}\n \nbuffer += &quot;\\n&lt;table&gt;\\n  &quot;;\nstack1 = helpers.each.call(depth0, depth0.books, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});\nif(stack1 || stack1 === 0) { buffer += stack1; }\nbuffer += &quot;\\n&lt;/table&gt;\\n&quot;;\nreturn buffer;\n</code></pre><p>我们不需要对上面代码的每一处都了解清楚，但是可以看到一个大概的执行步骤，模板被编译后生成了一个字符串拼接的方法，即模板本身的字符串，去拼接实际传出的数据：</p><ul>\n<li>由于模板中定义了一个循环，因此方法 program1 在循环中被调用若干次；</li>\n<li>对于 td 标签中间的数据，会判断是直接拼接，还是作为方法递归调用，拼接其返回值。</li>\n</ul><h2>总结思考</h2><p>今天我们学习了 MVC 架构中的视图层（View），对于五花八门的页面聚合技术，我们需要抓住其本质，和前面学习 Model 层的解耦一样，应对软件复杂性的问题，绝招别无二致，就是“拆分”。</p><p><strong>无论是分层、分模块，还是分离静态模板和动态数据，当我们定义了不同的拆分方法，我们就把一个复杂的东西分解成组成单一、职责清晰的几个部分，分别处理以后，再聚合起来，不同的聚合方法正是由这些不同的拆分方法所决定的</strong>。</p><p>往后我们还会学习别的解耦技术，到那时请你回想我们本章到目前为止学过的这些有关“拆分”的方法，再放到一起比较，我相信你会有更多感悟。</p><p>在今天的选修课堂和扩展阅读之前，我先来提两个问题：</p><ul>\n<li>你在工作中是否使用过什么模板引擎，能说说当初在做技术选型时为什么选择了它吗？</li>\n<li>有朋友说，服务端聚合已经过时了，现在的网站都应该在客户端完成聚合的，你同意这个观点吗？</li>\n</ul><p>好，对于上面的问题，以及今天的内容，你有什么想法？欢迎在留言区和我讨论。</p><h2>选修课堂：动手使用 HTML 5 的模板标签</h2><p>文中我介绍了一些模板技术，还有一点你要知道，HTML 5 引入了模板标签，自此之后，我们终于可以不依赖于任何第三方库，在原生 HTML 中直接使用模板了。下面就让我们来动手实践一下吧。</p><p>打开 Chrome 的开发者工具，选择 Console 标签：</p><p><img src=\"https://static001.geekbang.org/resource/image/98/0c/986ead9ff6440fd6e36075f9b5dc310c.png?wh=1424*230\" alt=\"\"></p><p>然后，让我们先来检验一下你的浏览器是否支持 HTML 5 模板，即 template 标签。请执行：</p><pre><code>'content' in document.createElement('template')\n</code></pre><p>你应该能看到“true”，这就意味着你的浏览器是支持的。这是因为，content 是 HTML 5 的 template 标签特有的属性，用于放置原模板本身的内容。</p><p>接着，请在硬盘上创建一个 HTML 文件 template.html，写入如下内容：</p><pre><code>&lt;!doctype html&gt;\n\n&lt;html&gt;\n  &lt;div&gt;1&lt;/div&gt;\n  &lt;div&gt;3&lt;/div&gt;\n  &lt;template id=&quot;t&quot;&gt;\n  \t&lt;div&gt;2&lt;/div&gt;\n  &lt;/template&gt;\n&lt;/html&gt;\n</code></pre><p>使用 Chrome 打开它，你应该只能看到分别显示为“1”和“3”的两行，而 template 标签内的内容，由于是模板的关系，被浏览器自动忽略了。</p><p>我们再打开 Chrome 的开发者工具，选择 Console 标签，这次敲入这样两行命令：</p><pre><code>rendered = document.importNode(document.getElementById(&quot;t&quot;).content, true);\ndocument.getElementsByTagName(&quot;div&quot;)[0].append(rendered);\n</code></pre><p>这表示找到 id 为“t”的模板节点，根据其中的内容来创建一个节点，接着把这个节点安插到第一个 div 的标签后面。</p><p>这时，你应该看能看到三行，分别为“1”、“2”和“3”。</p><h2>扩展阅读</h2><ul>\n<li>【基础】今天的内容我们正式和几个 HTML 的标签见面了，如果你对 HTML 也不太熟悉的话，请一定学习一下，作为前端基础的三驾马车之一（另两驾是 CSS 和 JavaScript），我们以后会经常和它们见面的。首推 MDN 的教程，有一篇比较短的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/HTML_basics\">HTML 基础</a>，也有更为<a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/HTML\">详尽的展开</a>。</li>\n<li>【基础】文中也涉及到了一点点 JavaScript 的基础知识，如果你对于 JavaScript 还不了解，那么我推荐你阅读 MDN 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\">JavaScript 教程</a>中的快速入门部分。</li>\n<li>对于文中模板引擎以外的三种聚合方式，我也给你找了可选的阅读材料，你可以跟随自己的兴趣选择：对于 iFrame 聚合，<a href=\"https://krasimirtsonev.com/blog/article/iframe-or-not-that-is-the-question\">iframe, or not, that is the question</a> 这篇文章介绍了和使用 script 标签来写入页面内容比起来，使用 iFrame 的优劣；对于 Portlet 聚合，请参阅 <a href=\"https://en.wikipedia.org/wiki/Java_Portlet_Specification\">Java Portlet Specification</a> 词条，你将看到 Portlet 规范从 1.0 到 3.0 的改进；对于 SSI，请参阅维基百科的<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%86%85%E5%B5%8C\">服务器端内嵌</a>词条，上面介绍了一些它常用的指令。</li>\n</ul><p></p>","neighbors":{"left":{"article_title":"08 | MVC架构解析：模型（Model）篇","id":141679},"right":{"article_title":"10 | MVC架构解析：控制器（Controller）篇","id":143834}},"comments":[{"had_liked":false,"id":137831,"user_name":"CC","can_delete":false,"product_type":"c1","uid":1021014,"ip_address":"","ucode":"2B732860C4231B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/56/4b8395f6.jpg","comment_is_top":false,"comment_ctime":1569886738,"is_pvip":true,"replies":[{"id":"53137","content":"👍","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1570076887,"ip_address":"","comment_id":137831,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159821330","product_id":100035501,"comment_content":"1. 用过 SSI 和 Nunjucks。<br><br>当时选择 SSI 是因为自己对前端技术了解不足，SSI 容易掌握。当对复杂模板有需求后，找到了 Nunjucks。<br><br>现在回头看，其实自己对模板引擎的 trade-off 了解并不多，拿到一个就用，缺少深入理解。<br><br><br>2. 我不同意这个观点。<br><br>客户端聚合有代价。<br><br>第一次进入 web 或 web app 要等待一段时间。如果手机+不流畅的网络访问，一开始的体验不太好。如果是复杂的 web app，那么客户端需要下载的文件量和计算量就较大，等待时间就更长。<br><br>如文中提到，服务端聚合，可以通过分层和解耦，把一部分信息优先发送到客户端，这样会有更好的体验。<br><br>还有一种选择是 static site generator，把聚合的步骤在本地完成。但它不适合需要动态更新的网站，以及如果网站数据很大，本地编辑和执行的时间就会很长。<br><br>根据具体需求，选择适合的方案。","like_count":2,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469280,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570076887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213552,"user_name":"开心噶花苞","can_delete":false,"product_type":"c1","uid":1959550,"ip_address":"","ucode":"848A07A46FF17D","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e6/7e/1651f825.jpg","comment_is_top":false,"comment_ctime":1588473289,"is_pvip":false,"replies":[{"id":"79326","content":"了解，那具体他们翻译成什么比较好呢？","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1588689017,"ip_address":"","comment_id":213552,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5883440585","product_id":100035501,"comment_content":"解耦 和 耦合是翻译得很差的计算机专业名词的典范，就是，会中文的人乍一看，也不知道这两个是什么词，当然会有人会觉得这个内涵丰富，词义精准，但是这个就是中文翻译的一个弊端，本来很简单的词，偏偏要用很陌生的词来翻译。","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493813,"discussion_content":"了解，那具体他们翻译成什么比较好呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588689017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1409700,"avatar":"https://static001.geekbang.org/account/avatar/00/15/82/a4/a92c6eca.jpg","nickname":"墨灵","note":"","ucode":"185D70CA20BEEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327705,"discussion_content":"正因为是术语，才会采用陌生的词，这样你一看就明白是术语了。用通俗的词汇极容易混淆，在某个地方看到这词，你能马上判断是指普通词义还是术语词义？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605922252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1959550,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e6/7e/1651f825.jpg","nickname":"开心噶花苞","note":"","ucode":"848A07A46FF17D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259546,"discussion_content":"他的耦其实是想谐音couple的偶，也有藕断丝连的感觉, 然后这时你会觉得翻译得真好。可是其实你是因为看到couple这个词。然后你发现各行业都有这个词，可是具体意思都不一样的。这个耦合实在太省事了……来个转折，在计算机专业直接叫“连接”就好了嘛。还有一个词也是很经典的：熵！！这是什么鬼⊙▽⊙","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588780468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297211,"discussion_content":"在软件领域，中文名词如此，英文名词也好不去哪。经常让人读的浑身不舒服。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596809838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155564,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1574699089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869666385","product_id":100035501,"comment_content":"原来公司项目用的template是这个原因啊，我说为啥不直接用jsp el取值呢，哈哈。。","like_count":1},{"had_liked":false,"id":138844,"user_name":"pyhhou","can_delete":false,"product_type":"c1","uid":1256496,"ip_address":"","ucode":"31EF8D50CF91A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","comment_is_top":false,"comment_ctime":1570481002,"is_pvip":false,"replies":[{"id":"53654","content":"👍","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1570591075,"ip_address":"","comment_id":138844,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865448298","product_id":100035501,"comment_content":"1. 之前在用 React 的时候使用过一个叫 JSX 的东西，其功能就是将 HTML 样式的代码转化成 JavaScript 中的函数调用，对于一些复杂的结构，JSX 可以让代码变得更加简洁清晰，使得 React 中的代码风格能够被大多数人所适应，一开始认为 JSX 就是模版引擎，毕竟直观看，它和模版引擎的功能极其相似，但是 JSX 并不是模版引擎，只是用来代替模版引擎的一个语法糖，解释就是 JSX 表达的是 Virtual DOM 并不是实际的 HTML；之前之所以选用这个技术也是看 React 官网上说 JSX 和 React 比较搭<br><br>2. 不是特别同意这个观点，老师在文章中已经提到了客户端聚合的一些缺陷，就是这种方式需要客户端有一定的规范性和运算处理能力，如果是仅仅使用客户端聚合而不考虑服务器端聚合，这等同于将鸡蛋放在同一个篮子里，当项目的规模上来了，页面的模块增多了，聚合的复杂性将大大提升，客户端聚合将不能很好的进行；个人认为正确的考虑方式是结合实际情况考虑，将复杂的任务拆分并解耦，综合考虑服务器端聚合和客户端聚合<br>","like_count":2,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469669,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570591075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318013,"user_name":"garyhimself","can_delete":false,"product_type":"c1","uid":2708528,"ip_address":"","ucode":"4EDF54651242EC","user_header":"https://static001.geekbang.org/account/avatar/00/29/54/30/5f146e1b.jpg","comment_is_top":false,"comment_ctime":1635124374,"is_pvip":false,"replies":[{"id":"120972","content":"这里的区别是聚合的位置，是在客户端还是服务端。而不是模糊的“前后端分离”","user_name":"作者回复","user_name_real":"编辑","uid":"1580075","ctime":1642449688,"ip_address":"","comment_id":318013,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635124374","product_id":100035501,"comment_content":"客户端聚合是前后端分离，服务端聚合就是前后端放在一起通过后端渲染页面，不知道我的理解是否到位","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546889,"discussion_content":"这里的区别是聚合的位置，是在客户端还是服务端。而不是模糊的“前后端分离”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642449688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223489,"user_name":"paperen","can_delete":false,"product_type":"c1","uid":2016116,"ip_address":"","ucode":"5F882EAD0559DC","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c3/74/d21bddf4.jpg","comment_is_top":false,"comment_ctime":1591101191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591101191","product_id":100035501,"comment_content":"1. 自己写php的，用过smarty（用的人多），其实大部分框架都会包含模板引擎，后来发现公司就这么几个php开发，这模板也不可能让前端去写去学，也就没怎么用了，也逐步改变为页面与服务（页面+接口）分离的模式开发项目<br>2. 还是得看场景，一个项目来说前端部分在客户端渲染是普遍做法，但管理后台这些内部性质的平台开发还是大多数会选用服务端聚合","like_count":0},{"had_liked":false,"id":140100,"user_name":"鹏😎","can_delete":false,"product_type":"c1","uid":1255264,"ip_address":"","ucode":"B691572430BB9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/60/7510c6c5.jpg","comment_is_top":false,"comment_ctime":1570807236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570807236","product_id":100035501,"comment_content":"小白，努力学习中...","like_count":0},{"had_liked":false,"id":139251,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1570592397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570592397","product_id":100035501,"comment_content":"打卡吧:欠账了、、、开发的东西确实学习中结合面向模块编程在啃理解-发现确实还是理解起来很辛苦，放慢学习速度慢慢循环去看才能大致明白；后面加紧吧，坚持在课程完成的时能把每篇文章基本学完。<br>","like_count":0},{"had_liked":false,"id":138856,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1570493912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570493912","product_id":100035501,"comment_content":"都没用过：补课去😂😂😂怪不得感觉现在开发DEV+CSS的结构基本消失甚至很多UI和前端开发都不会这种架构。","like_count":0},{"had_liked":false,"id":138705,"user_name":"易儿易","can_delete":false,"product_type":"c1","uid":1242864,"ip_address":"","ucode":"B15D1031CA841E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLcWH3mSPmhjrs1aGL4b3TqI7xDqWWibM4nYFrRlp0z7FNSWaJz0mqovrgIA7ibmrPt8zRScSfRaqQ/132","comment_is_top":false,"comment_ctime":1570427462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570427462","product_id":100035501,"comment_content":"那jsp就属于服务端聚合了呗，毕竟编译后的servlet控制生成html并且运行在服务器上，现在一直在开发维护老项目使用陈旧的flex，应该是客户端聚合，客户端下载编译好的swf，请求完数据后聚合在页面内","like_count":0},{"had_liked":false,"id":137783,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1569847801,"is_pvip":false,"replies":[{"id":"53135","content":"😝","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1570076740,"ip_address":"","comment_id":137783,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569847801","product_id":100035501,"comment_content":"我的天，硬是听出玄幻小说等更新的感觉。。。","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469259,"discussion_content":"😝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570076740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137782,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1569847109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569847109","product_id":100035501,"comment_content":"模板引擎好像没有怎么大规模用过，小程序，bootstrap，easyUI用的比较多，拿easyUI举例子感觉更像是iframe的聚合，里面会嵌套两个页面。像微信小程序这种算是模板引擎吗，感觉这种声明式的一般来说模板引擎的面比较大？<br>服务端聚合还是要用的，你不要说浏览器的页面，要考虑兼容性。即使现在所谓大前端一把梭的情况，你什么都指望客户端聚合，不要说各种客户端，各种大小适配的问题，感觉做不到啊","like_count":0},{"had_liked":false,"id":137655,"user_name":"张理查","can_delete":false,"product_type":"c1","uid":1003152,"ip_address":"","ucode":"1F93E631CD4B35","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/90/a8d19e7b.jpg","comment_is_top":false,"comment_ctime":1569813364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569813364","product_id":100035501,"comment_content":"喜欢这种带扩展阅读的方式，节省了很多查找优质信息的时间。","like_count":0},{"had_liked":false,"id":137587,"user_name":"四喜","can_delete":false,"product_type":"c1","uid":1071389,"ip_address":"","ucode":"C5EBED19C0F332","user_header":"https://static001.geekbang.org/account/avatar/00/10/59/1d/c89abcd8.jpg","comment_is_top":false,"comment_ctime":1569802613,"is_pvip":false,"replies":[{"id":"52988","content":"想法不错！但是如果只是为了反爬虫，还有其它更好的方法来做到这一点（比如使用随页面生成的一次性 token），而不是说为了反爬虫就必须把 Web API 隐藏起来。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569905747,"ip_address":"","comment_id":137587,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1569802613","product_id":100035501,"comment_content":"从反爬虫的角度，<br><br>放在客户端聚合，势必要分多个请求。不想暴露的数据api就得引入加解密。<br><br>对于服务端聚合的页面，比较好控制呈现的数据维度和量，爬虫也只能老实的解析dom树。","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469164,"discussion_content":"想法不错！但是如果只是为了反爬虫，还有其它更好的方法来做到这一点（比如使用随页面生成的一次性 token），而不是说为了反爬虫就必须把 Web API 隐藏起来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569905747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297213,"discussion_content":"为什么要反爬虫？\n为什么不想暴露web api? 难道web api不就是为了拿给前端用的吗？有什么隐患吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596810705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071389,"avatar":"https://static001.geekbang.org/account/avatar/00/10/59/1d/c89abcd8.jpg","nickname":"四喜","note":"","ucode":"C5EBED19C0F332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23835,"discussion_content":"嗯，这个想法是因为抓别人网站的时候，发现这种服务端渲染的页面不方便而来的，哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569911019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}