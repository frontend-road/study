{"id":626599,"title":"10｜Coroutines实战（二）：异步文件操作库","content":"<p>你好，我是卢誉声。</p><p>今天，我们继续上一讲的工作，实现基于协程调度的异步文件系统操作库。同时，在这一讲中，我们还要探讨一个重要话题，即实现所有调度线程全异步化的理想异步模型。</p><p>上一讲的最后，我们已经实现了任务调度模块，这意味着我们搭建好了基于协程的任务调度框架。但是，目前task模块是运行在主线程上的。因此，只有当主线程没有其他任务执行时，task模块才会从消息循环中获取任务执行，并唤醒协程。</p><p>这不是一个理想的异步框架模型，<strong>我们更希望实现的是主线程和I/O调度全异步化。那么，这要如何实现呢？</strong></p><p>项目的完整代码，你可以<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>获取。</p><h2>I/O调度模块</h2><p>其实，task模块中预留的AsyncTaskSuspender函数，就是为了实现自定义任务的处理与唤醒机制。为此，我们继续讨论异步I/O的实现——基于task模块的任务调度框架，实现基于协程的异步I/O调度。</p><p>我们的基本思路是下图这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/11/13718c7eyy43faaaa2f6871f34623111.jpg?wh=3717x2458\" alt=\"\"></p><p>首先，我们要为I/O任务创建独立的任务队列。然后，AsyncTaskSuspender中的主线程，负责将任务与协程的唤醒函数分发到I/O任务队列中。</p><p>接下来还要创建一个有独立任务循环的新线程，读取I/O任务队列，用于处理I/O任务。最后，处理完I/O任务后，将任务的返回值和协程唤醒函数分发到主线程的任务队列中。根据主线程的任务循环机制，当主线程空闲时，唤醒协程。</p><!-- [[[read_end]]] --><p>接下来，看一下这个思路的具体实现，我们从task分区的实现开始。</p><h3>task分区</h3><p>第一步，我们来看看io模块的task分区task/AsyncIoTask.cpp。该分区实现了I/O任务队列，后面是具体代码。</p><pre><code class=\"language-c++\">export module asyncpp.io:task;\n&nbsp;\nimport asyncpp.core;\nimport asyncpp.task;\nimport &lt;functional&gt;;\nimport &lt;vector&gt;;\nimport &lt;mutex&gt;;\n&nbsp;\nnamespace asyncpp::io {\n&nbsp;\nexport struct AsyncIoTask {\n&nbsp;&nbsp;&nbsp; using ResumeHandler = std::function&lt;void()&gt;;\n&nbsp;&nbsp;&nbsp; using TaskHandler = std::function&lt;void()&gt;;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 协程唤醒函数\n&nbsp;&nbsp;&nbsp; ResumeHandler resumeHandler;\n&nbsp;&nbsp;&nbsp; // I/O任务函数\n&nbsp;&nbsp;&nbsp; TaskHandler taskHandler;\n};\n&nbsp;\nexport class AsyncIoTaskQueue {\npublic:\n&nbsp;&nbsp;&nbsp; static AsyncIoTaskQueue&amp; getInstance();\n&nbsp;\n&nbsp;&nbsp;&nbsp; void enqueue(const AsyncIoTask&amp; item) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; guard(_queueMutex);\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _queue.push_back(item);\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; bool dequeue(AsyncIoTask* item) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::lock_guard&lt;std::mutex&gt; guard(_queueMutex);\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_queue.size() == 0) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *item = _queue.back();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _queue.pop_back();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; size_t getSize() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _queue.size();\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\nprivate:\n&nbsp;&nbsp;&nbsp; // I/O任务队列\n&nbsp;&nbsp;&nbsp; std::vector&lt;AsyncIoTask&gt; _queue;\n&nbsp;&nbsp;&nbsp; // I/O任务队列互斥锁，用于实现线程同步，确保队列操作的线程安全\n&nbsp;&nbsp;&nbsp; std::mutex _queueMutex;\n};\n&nbsp;\nAsyncIoTaskQueue&amp; AsyncIoTaskQueue::getInstance() {\n&nbsp;&nbsp;&nbsp; static AsyncIoTaskQueue queue;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return queue;\n}\n&nbsp;\n}\n</code></pre><p>在这段代码中，AsyncIoTaskQueue的实现和AsyncTaskQueue类非常类似，不同之处就是AsyncIoTask的定义除了任务处理函数，还包含一个用于唤醒协程的处理函数resumeHandler。</p><h3>loop分区</h3><p>接下来，我们看一下io模块的loop分区task/AsyncIoLoop.cpp。该分区定义了异步I/O循环的实现，代码如下。</p><pre><code class=\"language-c++\">export module asyncpp.io:loop;\n\nimport :task;\nimport asyncpp.task;\n\nimport &lt;thread&gt;;\nimport &lt;chrono&gt;;\nimport &lt;thread&gt;;\nimport &lt;functional&gt;;\n\nnamespace asyncpp::io {\n&nbsp;&nbsp;&nbsp; export class AsyncIoLoop {\n&nbsp;&nbsp;&nbsp; public:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static AsyncIoLoop&amp; start();\n\n&nbsp;&nbsp;&nbsp; private:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncIoLoop() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _thread = std::jthread(std::bind(&amp;AsyncIoLoop::loopMain, this));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void loopExecution() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncIoTask opItem;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!AsyncIoTaskQueue::getInstance().dequeue(&amp;opItem)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; opItem.taskHandler();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; asyncEventQueue = asyncpp::task::AsyncTaskQueue::getInstance();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asyncEventQueue.enqueue({\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .handler = opItem.resumeHandler\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void loopMain() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (true) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopExecution();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::jthread _thread;\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; AsyncIoLoop&amp; AsyncIoLoop::start() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static AsyncIoLoop ioLoop;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ioLoop;\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>在这段代码中，AsyncIoLoop的主体实现和之前的AsyncTaskLoop非常类似，所以这里我们只讨论两个特别之处。</p><p>从代码里可以看到AsyncTaskLoop是直接在调用线程里执行的，而AsyncIoLoop类包含一个std::jthread对象（我们会在第十五讲中详细介绍jthread）。构造函数中会创建线程对象，并将loopMain作为线程的入口函数，用于启动一个线程来处理消息循环。</p><p>另一个特别的地方是，在任务循环的处理中，taskHandler执行结束之后，会将任务的resumeHandler添加到主线程AsyncTaskQueue中。根据主线程的任务循环机制，在主线程空闲之后，就会立刻执行resumeHandler唤醒协程。</p><h3>asyncify分区</h3><p>接下来，看一下io模块的asyncify分区task/AsyncIoAsyncify.cpp。代码实现如下。</p><pre><code class=\"language-c++\">export module asyncpp.io:asyncify;\n\nimport &lt;coroutine&gt;;\nimport &lt;type_traits&gt;;\nimport asyncpp.core;\nimport asyncpp.task;\nimport :task;\n\nnamespace asyncpp::io {\n&nbsp;&nbsp;&nbsp; using asyncpp::core::Invocable;\n&nbsp;&nbsp;&nbsp; using asyncpp::task::Awaitable;\n&nbsp;&nbsp;&nbsp; using asyncpp::task::AsyncTaskResumer;\n&nbsp;&nbsp;&nbsp; using asyncpp::task::variantAsyncify;\n&nbsp;&nbsp;&nbsp; using asyncpp::task::AsyncTaskSuspender;\n&nbsp;&nbsp;&nbsp; using asyncpp::task::CoroutineHandle;\n\n&nbsp;&nbsp;&nbsp; template &lt;typename ResultType&gt;\n&nbsp;&nbsp;&nbsp; void ioAsyncAwaitableSuspend(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Awaitable&lt;ResultType&gt;* awaitable,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncTaskResumer resumer,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CoroutineHandle&amp; h\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asyncpp::io::AsyncIoTask operationItem{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resumeHandler = [h] {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h.resume();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .taskHandler = [awaitable]() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; awaitable-&gt;_taskResult = awaitable-&gt;_taskHandler();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asyncpp::io::AsyncIoTaskQueue::getInstance().enqueue(operationItem);\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; template &lt;&gt;\n&nbsp;&nbsp;&nbsp; void ioAsyncAwaitableSuspend&lt;void&gt;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Awaitable&lt;void&gt;* awaitable,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncTaskResumer resumer,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CoroutineHandle&amp; h\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asyncpp::io::AsyncIoTask operationItem{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resumeHandler = [h] {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h.resume();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .taskHandler = [awaitable]() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; awaitable-&gt;_taskHandler();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asyncpp::io::AsyncIoTaskQueue::getInstance().enqueue(operationItem);\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; export template &lt;Invocable T&gt;\n&nbsp;&nbsp;&nbsp; auto ioAsyncify(T taskHandler) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using ResultType = std::invoke_result_t&lt;T&gt;;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AsyncTaskSuspender&lt;ResultType&gt; suspender = ioAsyncAwaitableSuspend&lt;ResultType&gt;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return variantAsyncify(taskHandler, suspender);\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>在这段代码中，我们调用asyncpp.task中的asyncify，将用户传递的taskHandler作为任务处理函数，将ioAsyncAwaitableSuspend作为suspend处理函数，这样我们就可以实现后面这样的异步I/O处理流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/78/86/781a2822cc4f37a1d348a74f65b5ed86.jpg?wh=3964x2741\" alt=\"\"></p><ol>\n<li>在co_await时将当前协程休眠，并在异步I/O任务队列中添加一个任务。</li>\n<li>异步I/O任务循环获取任务，处理任务后将任务的返回值记录到Awaiter对象中，并将协程唤醒作为任务函数，添加到主线程的任务队列中。</li>\n<li>主线程的任务循环在空闲时获取异步I/O任务的协程唤醒任务，执行后唤醒休眠的协程。</li>\n<li>休眠的协程被唤醒后，通过co_await和Awaiter对象获取到任务处理的返回结果，协程继续执行。</li>\n</ol><p>这样，我们就可以在协程中实现I/O任务处理的异步化，同时也屏蔽了所有的实现细节。用户可以简单地将普通函数变为支持在协程中异步执行的函数。</p><p>多么美妙啊！我们在几乎不增加任何运行时开销的前提下，通过协程实现了异步I/O的异步处理与任务调度。</p><h2>文件系统模块</h2><p>在完成任务调度模块和I/O调度模块后，我们来简单看一下文件系统操作模块fs/FileSystem.cpp。代码是后面这样。</p><pre><code class=\"language-c++\">export module asyncpp.fs;\n&nbsp;\nimport asyncpp.io;\nimport &lt;string&gt;;\nimport &lt;filesystem&gt;;\nimport &lt;functional&gt;;\nimport &lt;iostream&gt;;\n&nbsp;\nnamespace asyncpp::fs {\n&nbsp;&nbsp;&nbsp; using asyncpp::io::ioAsyncify;\n&nbsp;&nbsp;&nbsp; namespace fs = std::filesystem;\n&nbsp;\n&nbsp;&nbsp;&nbsp; export auto createDirectories(const std::string&amp; directoryPath) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ioAsyncify([directoryPath]() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fs::create_directories(directoryPath);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; export auto exists(const std::string&amp; directoryPath) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ioAsyncify([directoryPath]() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fs::exists(directoryPath);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; export auto removeAll(const std::string&amp; directoryPath) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ioAsyncify([directoryPath]() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fs::remove_all(directoryPath);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>这段代码的封装方法非常简单，调用ioAsyncify将一个普通函数转换成“可以通过co_await调用”的异步任务函数，这跟ES6中的promisify一样简单！</p><h2>调用示例</h2><p>现在我们终于实现了所有关键模块。最后，我们来看看如何定义协程，并在协程中使用我们封装的函数。</p><p>我们还是对照代码来理解。</p><pre><code class=\"language-c++\">import asyncpp.core;\nimport asyncpp.task;\nimport asyncpp.io;\nimport asyncpp.fs;\n \n#include &lt;iostream&gt;\n \nusing asyncpp::task::asyncify;\nusing asyncpp::task::AsyncTaskLoop;\nusing asyncpp::task::Coroutine;\n \nusing asyncpp::fs::createDirectories;\nusing asyncpp::fs::exists;\nusing asyncpp::fs::removeAll;\nusing asyncpp::fs::voidFsFunction;\n \nusing asyncpp::io::AsyncIoLoop;\n\n/*\n * 用于演示如何在协程中通过co_await调用异步化的文件系统操作函数\n *  - co_await会自动控制协程的休眠和唤醒，调用者无需关心其实现细节\n*/\nCoroutine asyncF() {\n    std::string dirPath = \"dir1/a/b/c\";\n \n    // 创建目录\n    std::string cmd = \"createDirectories\";\n    std::cout &lt;&lt; \"[AWAIT] Before: \" &lt;&lt; cmd &lt;&lt; std::endl;\n    auto createResult = co_await createDirectories(dirPath);\n    std::cout &lt;&lt; \"[AWAIT] After: \" &lt;&lt; cmd &lt;&lt; \": \" &lt;&lt; std::boolalpha &lt;&lt; createResult &lt;&lt; std::endl;\n \n    // 判断路径是否存在\n    cmd = \"exists1\";\n    std::cout &lt;&lt; \"[AWAIT] Before: \" &lt;&lt; cmd &lt;&lt; std::endl;\n    auto existsResult1 = co_await exists(dirPath);\n    std::cout &lt;&lt; \"[AWAIT] After: \" &lt;&lt; cmd &lt;&lt; \": \" &lt;&lt; std::boolalpha &lt;&lt; existsResult1 &lt;&lt; std::endl;\n \n    // 删除目录\n    cmd = \"removeAll\";\n    std::cout &lt;&lt; \"[AWAIT] Before: \" &lt;&lt; cmd &lt;&lt; std::endl;\n    auto removeResult = co_await removeAll(dirPath);\n    std::cout &lt;&lt; \"[AWAIT] After: \" &lt;&lt; cmd &lt;&lt; \": \" &lt;&lt; std::boolalpha &lt;&lt; removeResult &lt;&lt; std::endl;\n \n    // 判断路径是否存在\n    cmd = \"exists2\";\n    std::cout &lt;&lt; \"[AWAIT] Before: \" &lt;&lt; cmd &lt;&lt; std::endl;\n    auto existsResult2 = co_await exists(dirPath);\n    std::cout &lt;&lt; \"[AWAIT] After: \" &lt;&lt; cmd &lt;&lt; \": \" &lt;&lt; std::boolalpha &lt;&lt; existsResult2 &lt;&lt; std::endl;\n}\n \nvoid hello() {\n    std::cout &lt;&lt; \"&lt;HELLO&gt;\" &lt;&lt; std::endl;\n}\n \nauto asyncHello() {\n    return asyncify(hello);\n}\n\n/*\n * 用于演示如何调用asyncify来将一个普通的void函数异步化\n *  - asyncHello的返回值推荐使用auto让编译器诊断其类型，\n *。  如果不使用auto，这里需要写明其返回类型为asyncpp::task::Awaitable&lt;void&gt;\n *  - 在协程中就可以直接通过co_await调用asyncHello即可\n */\nasyncpp::task::Coroutine testVoid() {\n    // void函数封装示例\n    co_await asyncHello();\n}\n \nint main() {\n    // 启动异步I/O任务线程\n    AsyncIoLoop::start();\n \n    // 调用协程（协程会并发执行）\n    asyncF();\n    testVoid();\n \n    // 启动主线程任务循环（一定要最后调用，这里会阻塞）\n    AsyncTaskLoop::start();\n \n    return 0;\n}\n</code></pre><p>我们在main函数中，首先调用AsyncIoLoop::start启动异步I/O任务线程，接着调用asyncF和testVoid。</p><p>在调用asyncF时遇到co_await createDirectories时会先休眠，此时控制权会交还给main函数，然后main函数就会马上调用testVoid这个协程，testVoid遇到co_await asyncHello后会休眠再回到main函数，然后启动主线程循环。</p><p>因此，程序会先输出[AWAIT] Before…，然后输出<hello>。因为是异步的，我们其实无法准确得知运行时的具体顺序，所以，程序的控制台输出可能是后面截图里展示的这样。</hello></p><p><img src=\"https://static001.geekbang.org/resource/image/c6/ce/c6457322a75827671fd65cc6c66825ce.jpg?wh=1940x308\" alt=\"\"></p><h2>深入理解Coroutines</h2><p>看完编程实战后，你是不是对异步的概念和基于协程的异步实现有了新的体会。现在，我们回到C++ Coroutines的概念上，并做一些更深入的讨论，把协程调度的细节再梳理一下。</p><p>首先，协程是一个与线程独立的概念，协程的核心是让调用者和被调用的协程具备一种协同调度的能力：协程可以通过co_await暂时休眠并将控制权交还给调用者，调用者可以通过协程句柄的resume重新唤醒协程。</p><p>其次，协程通过较为复杂的约定为开发者提供了更细粒度控制协程调度的能力。我们一定要实现的类型是Coroutine、Promise，如果想要自定义co_await的行为，还需要实现Awaitable和Awaiter类型。</p><ul>\n<li>Coroutine类型可以将协程的句柄作为自己的成员变量，并以协程句柄为基础为协程调用者提供调度协程的接口。</li>\n<li>Promise类型可以在协程帧中存储更多的自定义数据，实现协程的各种元数据以及自定义状态的存储与传递。</li>\n<li>Awaitable和Awaiter可以控制co_await的各种行为，包括co_await后协程是否休眠，休眠后何时重新唤醒协程等。</li>\n</ul><p>在细粒度实现协程调度时还可以细分成两种情况，让我们分别看一下。</p><p>针对调用者的协程调度，我们需要关注Coroutine和Promise的实现细节。Promise中可以通过get_return_object控制调用协程的返回值类型，一般返回类型就是Coroutine。而在Coroutine类型中，我们需要定义为调用者提供的各种调度控制函数，根据实际业务需求实现相关的接口。</p><p>针对协程的内部调度，C++是通过co_await实现的，我们需要关注Awaitable和Awaiter的实现细节。</p><p>为了真正实现协程的异步执行，我们可以在Awaiter的await_suspend中将协程的相关信息，包括Awaiter对象、协程句柄传递给其他的线程，在其他线程中执行任务函数并恢复协程执行。为了确保线程安全，我们甚至可以在一些应用中，当任务函数执行完后，将协程的相关数据传回主线程，让主线程自己唤醒协程。</p><p>因此，只要符合与C++协程接口的约定，我们就可以根据实际需求，定义整个协程的执行与调度过程。只要了解整个协程的执行机制和线程的切换机制，就可以通过协程实现各式各样的异步任务执行与调度。</p><h2>总结</h2><p>虽然就目前来说，C++20提供的协程看起来很粗糙——它仅提供了语言层面的支持，缺乏标准库的支持。因此，就目前来说入门门槛还相对比较高，但是我们已经能够实现足够灵活的异步调度、实现我们自己的协程框架，并满足各式各样的任务调度需求。</p><p>C++ Coroutines可以在几乎零开销的情况下，大幅降低C++中实现异步调度的复杂度。实现基于C++20中的协程，就是去实现标准中针对协程的一整套约定，包含定义promise_type类型和Awaitable类型。其中，Awaitable的实现决定了协程休眠的具体行为。</p><p>同时，我们在代码中设计了asyncify和ioAsyncify函数，使用这两个函数可以在不修改原有接口的情况下简单包装，<strong>以非侵入式的方式生成为协程提供的异步函数</strong>。与调用原函数相比，在协程中调用生成的包装函数只需要加上co_await即可，其他地方没有任何区别。</p><p>我们也需要关注，协程只是一种调度框架或者说是调度机制，协程和线程分别是独立的概念，甚至在实现具体协程机制的时候，往往也离不开线程技术，就像我们的实现一样。但是一旦实现了协程框架，就能降低调用者的异步编程门槛，这正是协程的价值所在。</p><p>我们期待更加成熟的支持会在C++26或后续演进标准中到来。可以预见，在未来C++标准支持协程是光明的。</p><h2>课后思考</h2><p>在目前的设计中，异步I/O运行在一个独立线程上。由于所有的I/O任务都需要顺序执行，所以效率较低。请你尝试使用std::thread和std::mutex，基于线程池来实现更好性能的并发。</p><p>不妨在这里分享你的答案，我们一同交流。下一讲见！</p>","neighbors":{"left":{"article_title":"09｜Coroutines实战（一）：异步文件操作库","id":626593},"right":{"article_title":"期中周｜扩展现有协程框架，实现高级任务调度","id":629373}},"comments":[{"had_liked":false,"id":371625,"user_name":"猪小擎","can_delete":false,"product_type":"c1","uid":1370959,"ip_address":"北京","ucode":"D9552746AE3327","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","comment_is_top":false,"comment_ctime":1680111099,"is_pvip":false,"replies":[{"id":135795,"content":"感谢反馈，源代码正在做更新。\n\n这里我们协程是一个简单的“示例性”封装，实际要通过协程处理I&#47;O肯定要以IOCP、epoll和kqueue等技术为基础，并利用协程作为接口封装，在避免多线程与锁的情况下实现任务上下文切换，而不是直接使用filesystem这种简单的同步I&#47;O接口，但是如果这样就会偏离我们想要讲解的重点，所以就使用filesystem做了简单的示例。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1680698105,"ip_address":"上海","comment_id":371625,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"老师的github代码有好多GBK文件，建议修改下。\n携程的本质优点减少上下文切换，（中断），中断操作系统会把寄存器存在栈顶，然后内核栈和用户栈互换，这些大概会消耗1-10微秒。携程就要节约这无数的1-10微秒。可以操作系统的IO操作是默认会中断的，要把中断改成yield出让执行权需要做什么呢？底层调用的filesystem的操作本身就是中断操作吧？上层改成携程，对于进程来说，这中断的消耗并没有节省。","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612451,"discussion_content":"感谢反馈，源代码正在做更新。\n\n这里我们协程是一个简单的“示例性”封装，实际要通过协程处理I/O肯定要以IOCP、epoll和kqueue等技术为基础，并利用协程作为接口封装，在避免多线程与锁的情况下实现任务上下文切换，而不是直接使用filesystem这种简单的同步I/O接口，但是如果这样就会偏离我们想要讲解的重点，所以就使用filesystem做了简单的示例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680698106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614053,"discussion_content":"@猪小擎\n代码已更新，使用utf8编码。相应的 CMakeLists.txt 也做了更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681650268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367960,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1675768062,"is_pvip":false,"replies":[{"id":134081,"content":"Q1: 代码前面已经using asyncpp::task::Coroutine，所以这里asyncpp::task::Coroutine和Coroutine是一样的，这里只是演示引用该类型的不同用法，没有其他不同。\n\nQ2：C++的协程提供了：\n（1）关键字：协程只提供了co_await、co_yield这两个关键字。\n（2）基础类型支持：coroutine_handle是C++协程标准库内提供的类型\n（3）协程协议框架：其他部分只定义了一个协议框架，包括Coroutine、Promise、Awaitable和Awaiter都是标准提出的概念，并且定义了相关的标准协议，但是并没有提供标准实现或者工具，需要开发者熟悉这些协议然后自己实现。\n\n所以说，就目前来说（在C++26或后续标准到来以前）实现一个C++20的协程框架确实并不容易，但是基于框架再做业务开发就会简单很多。\n","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1676030562,"ip_address":"上海","comment_id":367960,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"请教老师两个问题：\nQ1：asyncF与testVoid定义为什么不同？\nasyncF与testVoid都是协程，但testVoid的定义是：asyncpp::task::Coroutine testVoid()；而testVoid的定义是Coroutine asyncF()。函数前面部分不同，为什么？\nQ2：协程在C++语法层面的支持就是几个关键字吗？\n这两篇读下来，有点模模糊糊，总体上感觉在C++语法层面，对于协程，似乎就是Coroutine、co_await这两个关键字，是吗？（Awaitable 和 Awaiter需要自己实现，不算关键字吧）","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603252,"discussion_content":"Q1: 代码前面已经using asyncpp::task::Coroutine，所以这里asyncpp::task::Coroutine和Coroutine是一样的，这里只是演示引用该类型的不同用法，没有其他不同。\n\nQ2：C++的协程提供了：\n（1）关键字：协程只提供了co_await、co_yield这两个关键字。\n（2）基础类型支持：coroutine_handle是C++协程标准库内提供的类型\n（3）协程协议框架：其他部分只定义了一个协议框架，包括Coroutine、Promise、Awaitable和Awaiter都是标准提出的概念，并且定义了相关的标准协议，但是并没有提供标准实现或者工具，需要开发者熟悉这些协议然后自己实现。\n\n所以说，就目前来说（在C++26或后续标准到来以前）实现一个C++20的协程框架确实并不容易，但是基于框架再做业务开发就会简单很多。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676030562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}