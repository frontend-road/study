{"id":202479,"title":"17 | 数据结构（下）：大整数实战，提升 Shift-And 算法能力","content":"<p>你好，我是胡光，咱们又见面了。</p><p>上节课呢，我们讲了大整数表示法的相关知识，并且给你演示了大整数加法及乘法处理过程。其实，你是否掌握了大整数表示法是次要的，主要是你可以在这个过程中，认识到数据结构的作用，也就是我强调的<strong>数据结构就是负责表示数据</strong>。</p><p>原先，我们之所以无法做较大整数的运算，那是因为我们所掌握的数据类型，无法表示很大的数字，有了大整数表示法以后，我们就可以做特别特别大的整数表示了。</p><p>我之前也一直在说，算法是做数据计算的，它和数据结构是程序设计中非常重要的两部分。既然是两部分，说明<strong>算法和数据结构可以独立分开设计</strong>。</p><p>关于这点呢，你可以想想上节课我们学的大整数加法，它其实就是算法。为什么这么说呢？你想想，这个加法过程难道是有了大整数以后，才出现的么？显然不是，即使没有大整数表示法，我们还是了解加法过程的，只不过这一次我们用大整数表示法，模拟了加法过程。因此，加法过程是一个独立的算法过程。</p><p>总而言之，就是在之前的课程中，我们确定了这样一个结论：<strong>如果是计算流程不合理，我们需要改进算法；如果是数据表示受限，我们需要求助于数据结构。</strong></p><p>为了让你更清晰地认识到，算法和数据结构是两个可以独立设计的部分，今天我们通过一个具体的算法，来感受一下这个独立设计的过程。</p><!-- [[[read_end]]] --><h2>字符串匹配问题</h2><p>首先让我们来了解一个概念，那就是“字符串匹配问题”。什么意思呢？简单来说，就是在一个大的字符串里面，查找是否包含另外一个较小的字符串。<br>\n<img src=\"https://static001.geekbang.org/resource/image/90/23/905e0c01811e78d0bb009e49b3be7e23.jpg?wh=1551*917\" alt=\"\" title=\"图1： 字符串匹配问题\"><br>\n如图所示，我们做的就是在字符串cjakjoek中，查找是否包含字符串kjo，其中，我们把这个cjakjoek字符串叫做文本串，kjo字符串叫做模式串。再举个例子，你手中有一篇英文文档，你想在这个文档中查找所有的 hello 单词。那么，英文文档就是我们所说的文本串，hello 就是模式串。</p><p>如果模式串是单独的一个，我们就称这种问题为“单模匹配问题”，如果模式串是多个，那就是“多模匹配问题”。我们今天重点讨论的是“单模匹配问题”。</p><p>如果给你一个文本串和模式串，让你查找文本串中是否包含模式串，你用程序怎么完成？最直观的做法，就是用模式串的首字母依次和文本串中的每一位对齐，每次对齐以后，看看所对应区域是否匹配，如果匹配就说明文本串包含模式串。</p><p>下面我给出这个方法的程序代码：</p><pre><code>// 暴力匹配算法程序\nint bruce_force(const char *text, const char *p) {\n    // 遍历文本串每一位\n    for (int i = 0; text[i]; i++) {\n        int flag = 1;\n        // 从文本串的第 i 位开始与模式串进行匹配\n        for (int j = 0; p[j]; j++) {\n            if (text[i + j] == p[j]) continue;\n            // 当代码到了这里，说明某一位不匹配\n            flag = 0;\n            break;\n        }\n        if (flag) return 1;\n    }\n    return 0;\n}\n</code></pre><p>正如你所看到的，这是最简单粗暴的方法。代码中的 bruce_force 程序，就是暴力匹配算法的过程，其中参数 text 就是文本串，p 就是模式串，如果包含模式串，函数返回值是 1，如果不包含，返回值就是 0。</p><p>这个程序的效率，可以说是单模匹配的所有算法中最差的了，它的时间复杂度是 O(nm)，其中，n 是文本串的长度，m 是模式串的长度。怎么理解呢？就是如果文本串长度是10，模式串长度是 3，那么这个程序差不多要计算30次，外层循环10次，内层循环每次循环 3 次。</p><p>按照这个理解，可以设想，当文本串长度是 10000，模式串长度是 1000 的时候，程序的运行次数是接近1000万次这个量级的！所以这种程序的效率最差。</p><h2>初识 Shift-And 算法</h2><p>其实，可以高效解决“单模匹配问题” 的算法有很多。今天，我们来学习一种叫做 Shift-And 的算法。</p><p>看到 Shift 你会想到什么？是不是电脑键盘上的 Shift 键？我们知道，这个键的作用是做转换，例如当你按住 Shift + 8 的时候，输入的就不是数字 8，而是一个 *。</p><p>而 Shift-And 中的另一个单词 And ，其实指代的是位运算中的按位与操作。这两个单词，差不多清晰展示了这个算法的基本流程：首先做信息的转换，然后利用位运算，完成单模匹配问题。下面，我们就来具体对这两步做下讲解。</p><h4>1. Shift-And 中的信息转换</h4><p>在 Shift-And 算法中，是将模式串的信息，转换成另外一个种信息格式，如何转换呢？如下图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/43/c0/4362d2e4ffbfc68f596184290caceac0.jpg?wh=2487*1373\" alt=\"\" title=\"图2： Shift-And 编码方法示意图\"></p><p>在 Shift-And 中，我们可以把模式串中的每一个字符，转换成一个数字，这个数字一般是由二进制表示。关于转换字符的编码有这么一个规则，就是如果某个字符在模式串的第 i 位中出现过，那么在相关字符编码的二进制数字表示中的第 i 位就为 1。</p><p>例如，图中字符 a，在模式串的第 0 位，第 5 位和第 6 位出现过，那么就将 a 字符编码的第 0、5、6 位设置为 1。在这里你需要注意的是，字符数组是从左向右看，也就是说最左边是最低位；而数字是从右向左看的，最右边才是最低位，这里是最容易犯糊涂的地方。</p><p>字符 c 呢，由于在第1位和第4位出现过，所以对应到二进制数字中，第1位和第 4 位都是 1，其余位置都是 0。按照这种规则呢，你会发现，没有在模式串中出现的字符，编码值就是 0 值，也就是它的所有二进制位上都是 0。</p><p>所以，在 Shift-And 算法中，通过看一个字符的编码，就能知道这个字符，在原模式串的第几位出现过。同时，通过模式串可以生成的编码信息，也可以还原模式串信息。</p><p>在之前的课程中，我们讲过类似的概念，一般来说，这种可以相互转换的信息，叫做等价信息表示。说白了就是信息一点儿也没少，只是换了一种表示形式。要想理解 Shift-And 算法，首先就要理解这种等价的信息表示方法。</p><h4>2.利用位运算做匹配</h4><p>讲完了信息转换步骤后，我们明确了一个事情，就是 Shift-And 算法中，只是对模式串做了信息转换，但对文本串本质内容没有做任何改动。接下来，我们就来讲解 Shift-And 算法中的 And 部分，也就是来回答 Shift-And 算法，究竟是怎么用位运算来做字符串匹配的。先看下图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/12/b4/1293af0c4e3ce6a29bfe681603f19cb4.jpg?wh=2531*1450\" alt=\"\" title=\"图3： Shift-And匹配流程的关键因素\"></p><p>在图中，有一个最关键的，就是 <strong>p 变量，它是整个匹配过程的核心变量</strong>。我们假设模式串的长度是 m ，code(str[i]) 代表了文本串第 i 位字符的编码，编码方式前面已经介绍过了。整个匹配过程，从前往后，依次处理文本串的每一位，处理到第 i 位的时候，就是用第 i 位字符的编码（code（str[i])），与 p 左移 1 位并或上 1 以后的值（p&lt;&lt; 1 | 1），做“按位与”运算，把得到的值赋给 p 变量。最终，当 p 的二进制表示的第 m 位为 1 时，说明匹配成功了。</p><p>为了帮助你理解，我给你准备了一个具体示例，下图是模拟了当模式串为 cdd，文本串为 acdd 时候的匹配流程：<br>\n<img src=\"https://static001.geekbang.org/resource/image/4f/e4/4fbf1d8708304abf3359fa933f90cfe4.jpg?wh=2505*1534\" alt=\"\" title=\"图4： Shift-And匹配流程示意图\"></p><p>要想理解这个匹配过程，首先就是需要注意到 ，变量 p 在第四步的时候，二进制表示的第 3 位为 1 了，说明此时截止到文本串 acdd 的第 4 位为止，匹配到了原模式串 cdd。这个过程，你需要仔细琢磨琢磨，然后再往下看。</p><p>接下来我们来讨论一般情况下的 p 值，如果模式串长度为 m，那么在什么情况下，p 值的第 m 位为 1 呢？</p><p>由算法中的 p 值计算公式可知，<strong>p 是由“按位与”操作得到的值</strong>，也就是说，其中一部分 code(str[i]) 的二进制的第 m 位必须为 1，这就意味着 str[i] 是模式串第 m 位的字符。并且为了p 值的第m位为1，按位与的另一边 (p &lt;&lt; 1 | 1) 这个值的第 m 位也必须是 1。</p><p>关于 (p &lt;&lt; 1 | 1) 这一部分中，或 1 操作，只能影响二进制的最低位，我们可以暂时忽略它。关键就是理解 p &lt;&lt; 1 这个操作，左移以后的第 m 位为1，说明左移之前，p 的二进制表示的 m - 1 位也是 1。</p><p>通过分析上一轮 p 的二进制表示的 m - 1 位为什么是 1 时，你会推理得到 str[i - 1] 必须是模式串 m - 1 位的字符。依次类推，你就会得到一个结论：文本串 str 的第 i - m 位，到第 i 位之间的字符串，其实就等于原模式串的内容。下面给你准备了一个示意图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/b3/09/b376fbe3c81bd4631dab4da7d0c8fb09.jpg?wh=2291*1372\" alt=\"\" title=\"图5： p 公式的理解与推导\"></p><p>其中 $p_m$ 代表  p 的二进制表示的第 m 位为 1，$p_{m-1}$ 表示  p 的二进制表示的第 m-1 位为 1。因为只有第 m-1 位为 1，才可能左移 1 位以后的结果第 m 位为 1。</p><p>最后我们来解释一下，为什么 p 左移 1 位以后，还需要或上一个 1 。其实也很好理解，如果 str[i] 是模式串的第 0 位字符，那么 p 在什么情况下，第 0 位是 1 ？你会发现，根据之前推理，只有在上一个状态 p 的 -1 位为 1 的时候，左移以后第 0 位才可能是 1。</p><p>但我们知道，根本没有 -1 位这个位置，也就是说，如果不看或 1 操作的话，一个初值为 0 的 p 变量，想通过单纯的左移操作，第 0 位永远不可能是 1。所以这个或 1 操作，其实就是为了使得 p 左移以后的第 0 位永远置为 1，而最终计算结果中的第 0 位是否为 1，这个要看 str[i] 这个字符是否在模式串的第 0 位出现过。</p><p>关于 Shift-And 算法这个知识点呢，我大致解释完了。你在学习这块知识的时候，可能感觉有点难，没准读完第一遍的时候，脑子都是懵的。但请相信我，也相信你自己，把这几段内容多看几遍，遇到不理解的句子，停下来多思考思考，看的次数多了，你就明白是什么意思了。</p><p>至此呢，我们就学习完了 Shift-And 算法的两个重要的过程。代码实现呢，如下所示：</p><pre><code>int shift_and(const char *str, const char *p_str) {\n    int code[256] = {0}, m = 0;\n    // 初始化每一个字符的编码\n    for (int i = 0; p_str[i]; i++, m++) {\n        code[p_str[i]] |= (1 &lt;&lt; i);\n    }\n    int p = 0;\n    for (int i = 0; str[i]; i++) {\n        p = (p &lt;&lt; 1 | 1) &amp; code[str[i]];\n        // 如果 p 所对应的模式串最高位为1，代表匹配成功\n        if (p &amp; (1 &lt;&lt; (m - 1))) return 1;\n    }\n    return 0;\n}\n</code></pre><p>在这份代码中，你会发现我们只用了两次循环，注意！是两次循环，而不是两层循环。一次循环是遍历模式串，生成编码 code 信息，第二次循环是遍历文本串 str，循环迭代得到 p 变量的值，直到 p 变量的第 m 位为 1 时，就代表匹配成功。</p><p>可以看到，这种算法的时间复杂度，和暴力匹配算法比起来，提升的不是一星半点。暴力算法是 O(nm) 的，而 Shift-And 算法的时间复杂度就是 O(n + m) 的。也就意味着，同样是文本串 10000 的长度，模式串 1000 长度，Shift-And 算法，是暴力匹配算法效率的 1000 倍！</p><h2>改进 Shift-And 算法</h2><p>说是 1000 倍，细心的你可能会发现一个问题，上述算法中的 p 变量，是一个整型变量，也就是说，p 变量最多支持，模式串长度不超过 32 位的单模匹配问题。</p><p>请你想想，这个问题究竟是出在算法上，还是出在数据结构上？答案很显然，是出在数据结构上。要是有一种数据结构，支持很大的二进制整数表示，同时在这种结构的数据上，还可以操作左移、或运算以及按位与运算的话，这种结构就可以取代原有整型 p 变量的作用。这样，我们就可以支持长度更长的模式串的匹配问题了！</p><p>所以今天给你留的作业呢，就是请你在尽量不修改算法流程的情况下，增加一个类型结构，实现可以处理 1000 位模式串的 Shift-And 算法。欢迎你把自己的答案写在留言区，我们一起来讨论实现方法。</p><h2>课程小结</h2><p>通过今天这堂课呢，我希望你彻底体会到，算法和数据结构是程序设计的两个部分，并且它们可以单独来进行学习、设计和实现。</p><p>如果说，今天想让你记住点儿什么的话，那就是：<strong>等价信息表示对于解决问题很重要</strong>。这个事情不只是对于程序设计而言，很多事情都是这样。同等的信息，不同的表示形式，其实就是不同的观察角度，最终的效果也会截然不同。就像今天的 Shift-And 算法，对于模式串的信息，做了一个等价转换以后，整个算法的时间复杂度就被优化了一个数量级，这个过程值得你花时间去仔细体会。</p><p>本节课，也是我们整个“编码能力训练篇”的最后一节了，我希望你通过这部分知识的学习，掌握计算思维，以及程序设计的核心法门。下一章节，我不再赘述算法和数据结构的重要性，而是请你带着在“编码能力训练篇”掌握的技巧，随我进入“算法与数据结构篇”的学习吧！</p><p>好了，今天就到这里了，我是胡光，我们下章见。</p>","neighbors":{"left":{"article_title":"16 | 数据结构（上）：突破基本类型的限制，存储更大的整数","id":201304},"right":{"article_title":"做好闭环（三）：编码能力训练篇的思考题答案都在这里啦！","id":203976}},"comments":[{"had_liked":false,"id":180576,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1582340258,"is_pvip":true,"replies":[{"id":"70093","content":"没错！说的完全正确！<br>还有一种解决方法，其实可以尝试开长度为 n 的整型数组，每一个整型对应于 30 位 2 进制位。","user_name":"作者回复","comment_id":180576,"uid":"1374625","ip_address":"","utype":1,"ctime":1582370658,"user_name_real":"胡炜燚"}],"discussion_count":3,"race_medal":0,"score":"18762209442","product_id":100043901,"comment_content":"改进Shift-And算法的思考:<br>数据结构的底层有两种想法，<br>1. 用数组，每个数组用0和1表示<br>2. 用字符串，用长度位N的01的字符串表示<br><br>但是C语言是不支持运算重载的，也就是位运算的符号是不能套用在新的数据结构，因此得要创建新的函数对应原来的位操作。<br><br>算法思想不变，但是代码形式会发生改变。<br>","like_count":4,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484720,"discussion_content":"没错！说的完全正确！\n还有一种解决方法，其实可以尝试开长度为 n 的整型数组，每一个整型对应于 30 位 2 进制位。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582370658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593251,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","nickname":"doge","note":"","ucode":"9E2D4C8F9B4CBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309566,"discussion_content":"用纯C来写真的有点难度啊，不过用C++来重载运算符倒是能清晰不少，o(╥﹏╥)o","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601348924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504671,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","nickname":"栾~龟虽寿！","note":"","ucode":"219B38C08979FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185023,"discussion_content":"整形不是4个字节，32bits,老师说30什么意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582592686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206125,"user_name":"1043","can_delete":false,"product_type":"c1","uid":1485365,"ip_address":"","ucode":"AAA69CC175AEE3","user_header":"https://static001.geekbang.org/account/avatar/00/16/aa/35/1a4884f9.jpg","comment_is_top":false,"comment_ctime":1586790225,"is_pvip":false,"replies":[{"id":"77174","content":"d(^_^o)","user_name":"作者回复","comment_id":206125,"uid":"1374625","ip_address":"","utype":1,"ctime":1586879617,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":1,"score":"10176724817","product_id":100043901,"comment_content":"胡老师这门课不仅仅就是编程入门的能力，可以说学懂了这个编程入门课就是进入了编程高手所要必须要掌握的终极技能的大门槛，再华丽、精深的编程技巧都是由优美的算法思维和结构协调的数据结构所组成。思维清晰、逻辑严谨、结构有序一直是编程进阶基础的基本功，唯有练好基本功，才能筑起更高、更稳的“大厦”。胡老师用入门这个简洁的语言告诉你：万丈高楼平地起，再牛的编程高手也得从这里、这个方向开始努力进阶的，这个入门接口是进入编程世界唯一不变的“高速公路的收费门岗”。","like_count":2,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491682,"discussion_content":"d(^_^o)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586879617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240215,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1596790465,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"5891757761","product_id":100043901,"comment_content":"茶艺师学编程<br><br>1、文中的bruce_force例子和shift_and算法例子，我自己跑，都是内存溢出结果······<br><br>2、思考题，我硬着头皮做，心里知道这肯定是错的······<br>代码如下：<br><br>#include &lt;stdio.h&gt;<br><br>typedef struct BIGP{<br>\tint p[1000];\t<br>} ;<br><br>int shift_and(const char *str, const char *p_str){<br>\tint code[256] = {0}, m = 0;<br>\tfor (int i = 0; p_str[i]; i++, m++){<br>\t\tcode[p_str[i]] |= (1 &lt;&lt; i);<br>\t}<br>\tstruct BIGP PP;<br>\tint pp.p = {0};<br>\tfor (int i = 0; str[i]; i++){<br>\t\tpp.p = (pp.p &lt;&lt; 1| 1) &amp; code[str[i]];<br>\t\tif (pp.p &amp; (1 &lt;&lt; (m - 1)))return 1;<br>\t}<br>\treturn 0;<br>}<br><br>int main(){<br>\tstruct BIG PP;<br>\tconst char *str, *p_str;<br>\tscanf(&quot;%s %s&quot;, str, p_str);<br>\tprintf(&quot;%s&quot;, shift_and(str, p_str));<br>\treturn 0;<br>}","like_count":1},{"had_liked":false,"id":193534,"user_name":"Modern","can_delete":false,"product_type":"c1","uid":1239720,"ip_address":"","ucode":"23B741F694F7D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/a8/72e43f12.jpg","comment_is_top":false,"comment_ctime":1584924558,"is_pvip":false,"replies":[{"id":"73767","content":"Yes！理解的非常到位！d(^_^o)","user_name":"作者回复","comment_id":193534,"uid":"1374625","ip_address":"","utype":1,"ctime":1584952976,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"5879891854","product_id":100043901,"comment_content":"哇，非常精彩，对于这个算法我的语义化理解是，p中的1从低位到高位移动的过程，每一次能够前进，就说明了当前位置的字符与模式串同一位置的字符相同，到达了m位置后就说明了每个位置都检查了一遍，都相同，于是就是完全匹配上了","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488579,"discussion_content":"Yes！理解的非常到位！d(^_^o)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584952976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180692,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1582365821,"is_pvip":true,"replies":[{"id":"70099","content":"嗯，这需要很多看似无关的基础算法思维，才有可能做到创造这种算法，其中还包括了编译原理相关算法思维。d(^_^o)","user_name":"作者回复","comment_id":180692,"uid":"1374625","ip_address":"","utype":1,"ctime":1582372232,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"5877333117","product_id":100043901,"comment_content":"虽然Shift-And算法搞懂了，但是一般是想不到的","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484763,"discussion_content":"嗯，这需要很多看似无关的基础算法思维，才有可能做到创造这种算法，其中还包括了编译原理相关算法思维。d(^_^o)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582372232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180616,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1582351861,"is_pvip":false,"replies":[{"id":"70095","content":"(｡ì _ í｡)","user_name":"作者回复","comment_id":180616,"uid":"1374625","ip_address":"","utype":1,"ctime":1582371041,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"5877319157","product_id":100043901,"comment_content":"Shift-And算法 很不错哦。","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484735,"discussion_content":"(｡ì _ í｡)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582371041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360795,"user_name":"look for","can_delete":false,"product_type":"c1","uid":1459157,"ip_address":"山东","ucode":"B19F0DED81B2BD","user_header":"https://static001.geekbang.org/account/avatar/00/16/43/d5/a7eaf722.jpg","comment_is_top":false,"comment_ctime":1666858186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666858186","product_id":100043901,"comment_content":"作业：<br><br>#include &lt;stdio.h&gt;<br>#define SIZE 100<br><br>int arr[SIZE]; &#47;&#47; 定义一个表示二进制大整数的数组<br><br>&#47;&#47; 转化为二进制大整数表示<br>int *convert_to_big_int(int num)<br>{<br>  &#47;&#47; 每次都重新初始化二进制大整数数组<br>  for (int i = 0; i &lt; SIZE; i++)<br>  {<br>    arr[i] = 0;<br>  }<br><br>  int count = 0;<br>  if (num == 0)<br>  {<br>    arr[0] = 0;<br>    return arr;<br>  }<br>  do<br>  {<br>    arr[++count] = num % 2;<br>    num = num &#47; 2;<br>  } while (num != 0);<br>  arr[0] = count;<br><br>  return arr;<br>}<br><br>&#47;&#47; 二进制大整数左移一位<br>void big_int_left_move_one(int *arr)<br>{<br>  if (arr[0] == 0)<br>  {<br>    arr[0] = 1;<br>    arr[1] = 1;<br>    return;<br>  }<br><br>  arr[0] += 1;<br>  for (int i = arr[0]; i &gt; 1; i--)<br>  {<br>    arr[i] = arr[i - 1];<br>  }<br>  arr[1] = 0;<br>}<br><br>&#47;&#47; 二进制大整数或1操作<br>void big_int_or_one(int *arr)<br>{<br>  arr[1] = 1;<br>  if (arr[0] == 0)<br>  {<br>    arr[0] = 1;<br>  }<br>}<br><br>&#47;&#47; 二进制大整数进行与操作<br>void big_int_and(int *a, int *b)<br>{<br>  int flag = 0;<br>  for (int i = a[0]; i &gt; 0; i--)<br>  {<br>    if (a[i] &amp;&amp; b[i])<br>    {<br>      a[i] = 1;<br>      &#47;&#47; 判断是否是第一次进入，第一次进入则设置a[0]的长度<br>      if (!flag)<br>      {<br>        a[0] = i;<br>        flag = 1;<br>      }<br>    }<br>    else<br>    {<br>      a[i] = 0;<br>    }<br>  }<br>  &#47;&#47; 判断之前是否与成功过，若没与成功过，则设置a[0]=0<br>  if (!flag)<br>  {<br>    a[0] = 0;<br>  }<br>}<br><br>&#47;&#47; 进行shift_and算法匹配<br>int shift_and(const char *str, const char *p_str)<br>{<br>  int code[256] = {0};<br>  int m = 0;<br>  &#47;&#47; 初始化每一个字符的编码<br>  for (int i = 0; p_str[i]; i++, m++)<br>  {<br>    code[p_str[i]] |= (1 &lt;&lt; i);<br>  }<br><br>  int p[SIZE] = {0};<br>  for (int i = 0; str[i]; i++)<br>  {<br>    &#47;&#47; p = (p &lt;&lt; 1 | 1) &amp; code[str[i]];<br>    int *stri = convert_to_big_int(code[str[i]]); &#47;&#47; 把code[str[i]]进行二进制大整数表示<br>    big_int_left_move_one(p);                     &#47;&#47; p左移一位<br>    big_int_or_one(p);                            &#47;&#47; p或上1<br>    big_int_and(p, stri);                         &#47;&#47; p进行与运算<br><br>    &#47;&#47; 如果p所对应的模式串的最高位为1，代表匹配成功<br>    if (p[m])<br>    {<br>      return 1;<br>    }<br>  }<br>  return 0;<br>}","like_count":0},{"had_liked":false,"id":285413,"user_name":"马建华","can_delete":false,"product_type":"c1","uid":1185974,"ip_address":"","ucode":"928189590259AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","comment_is_top":false,"comment_ctime":1616786808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616786808","product_id":100043901,"comment_content":"遍历字符串为何可以把循环写为“for (int i = 0; text[i]; i++)”？ 这里text[i]表示的是数字还是字符？","like_count":0},{"had_liked":false,"id":251095,"user_name":"doge","can_delete":false,"product_type":"c1","uid":1593251,"ip_address":"","ucode":"9E2D4C8F9B4CBC","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","comment_is_top":false,"comment_ctime":1601363365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601363365","product_id":100043901,"comment_content":"typedef struct BigInt {<br>    char *Int;<br>    int high;<br>    int size;<br>} BigInt;<br><br>BigInt* BigIntLeftShiftN(BigInt* pbi, int n) {<br>    if (!pbi) return pbi;<br>    if (!pbi-&gt;high &amp;&amp; !pbi-&gt;Int[0]) return pbi;<br>    if (n + pbi-&gt;high &gt; pbi-&gt;size) {<br>        DBG(&quot;Error happens, number bit exceed&quot;);<br>        return NULL;<br>    }<br>    int moveN = pbi-&gt;high + 1;<br>    pbi-&gt;high += n;<br>    for (int i = pbi-&gt;high; moveN &gt; 0; i--, moveN--) {<br>        pbi-&gt;Int[i] = pbi-&gt;Int[i - 1];<br>    }<br>    for (--n; n &gt;= 0; n--) {<br>        pbi-&gt;Int[n] = 0;<br>    }<br>    return pbi;<br>}<br><br>BigInt* BigIntAnd(BigInt *target, const BigInt* src) {<br>    if (!target || !src) {<br>        return target;<br>    }<br>    if (!src-&gt;high &amp;&amp; !src-&gt;Int[0]) {<br>        target-&gt;high = 0;<br>        target-&gt;Int[0] = 0;<br>        return target;<br>    }<br>    int flag = 1;<br>    for (int i = target-&gt;high; i &gt;= 0; i--) {<br>        target-&gt;Int[i] = target-&gt;Int[i] &amp; src-&gt;Int[i];<br>        if (flag) {<br>            if (!target-&gt;Int[i]) {<br>                target-&gt;high--;<br>            } else {<br>                flag = 0;<br>            }<br>        }<br>    }<br>    return target;<br>}<br><br>int BigIntShiftAnd(const char* text, const char* pat) {<br>    if (!text || !pat || !strlen(text) || !strlen(pat) || strlen(text) &lt; strlen(pat)) return -1;<br>    int len = (int)strlen(pat);<br>    BigInt** code = CodeInit(len);<br>    if (!code) return -1;<br>    for (int i = 0; pat[i]; i++) {<br>        code[(int)pat[i]]-&gt;high = i;<br>        code[(int)pat[i]]-&gt;Int[i] = 1;<br>    }<br>    BigInt* ret = BigIntGet(len);<br>    if (!ret) {<br>        CodeFree(code, len);<br>        return -1;<br>    }<br>    int pos = -1;<br>    for (int i = 0; text[i]; i++) {<br>        ret = BigIntLeftShiftN(ret, 1);<br>        ret-&gt;Int[0] = 1;<br>        ret = BigIntAnd(ret, code[(int)text[i]]);<br>        if (ret-&gt;high == len - 1 &amp;&amp; ret-&gt;Int[ret-&gt;high] &gt; 0) {<br>            pos = i - len + 1;<br>            break;<br>        }<br>    }<br>    CodeFree(code, len);<br>    return pos;<br>}<br>程序尝试这写出来了，验证好像没问题，就是感觉空间开销有点大。希望老师指点。评论空间有限，省略了初始化函数和销毁函数。","like_count":0}]}