{"id":69388,"title":"27 | 递归树：如何借助树来求解递归算法的时间复杂度？","content":"<p>今天，我们来讲这种数据结构的一种特殊应用，递归树。</p><p>我们都知道，递归代码的时间复杂度分析起来很麻烦。我们在<a href=\"https://time.geekbang.org/column/article/41913\">第12节《排序（下）》</a>那里讲过，如何利用递推公式，求解归并排序、快速排序的时间复杂度，但是，有些情况，比如快排的平均时间复杂度的分析，用递推公式的话，会涉及非常复杂的数学推导。</p><p>除了用递推公式这种比较复杂的分析方法，有没有更简单的方法呢？今天，我们就来学习另外一种方法，<strong>借助递归树来分析递归算法的时间复杂度</strong>。</p><h2>递归树与时间复杂度分析</h2><p>我们前面讲过，递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。</p><p>如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作<strong>递归树</strong>。我这里画了一棵斐波那契数列的递归树，你可以看看。节点里的数字表示数据的规模，一个节点的求解可以分解为左右子节点两个问题的求解。</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/a3/1d9648b7f43e430473d76d24803159a3.jpg?wh=1142*513\" alt=\"\"></p><p>通过这个例子，你对递归树的样子应该有个感性的认识了，看起来并不复杂。现在，我们就来看，<strong>如何用递归树来求解时间复杂度</strong>。</p><p>归并排序算法你还记得吧？它的递归实现代码非常简洁。现在我们就借助归并排序来看看，如何用递归树，来分析递归代码的时间复杂度。</p><!-- [[[read_end]]] --><p>归并排序的原理我就不详细介绍了，如果你忘记了，可以回看一下第12节的内容。归并排序每次会将数据规模一分为二。我们把归并排序画成递归树，就是下面这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/c6/d0/c66bfc3d02d3b7b8f64c208bf4c948d0.jpg?wh=1142*730\" alt=\"\"></p><p>因为每次分解都是一分为二，所以代价很低，我们把时间上的消耗记作常量$1$。归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中我们可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。我们把每一层归并操作消耗的时间记作$n$。</p><p>现在，我们只需要知道这棵树的高度$h$，用高度$h$乘以每一层的时间消耗$n$，就可以得到总的时间复杂度$O(n*h)$。</p><p>从归并排序的原理和递归树，可以看出来，归并排序递归树是一棵满二叉树。我们前两节中讲到，满二叉树的高度大约是$\\log_{2}n$，所以，归并排序递归实现的时间复杂度就是$O(n\\log n)$。我这里的时间复杂度都是估算的，对树的高度的计算也没有那么精确，但是这并不影响复杂度的计算结果。</p><p>利用递归树的时间复杂度分析方法并不难理解，关键还是在实战，所以，接下来我会通过三个实际的递归算法，带你实战一下递归的复杂度分析。学完这节课之后，你应该能真正掌握递归代码的复杂度分析。</p><h2>实战一：分析快速排序的时间复杂度</h2><p>在用递归树推导之前，我们先来回忆一下用递推公式的分析方法。你可以回想一下，当时，我们为什么说用递推公式来求解平均时间复杂度非常复杂？</p><p>快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式$T(n)=2T(\\frac{n}{2})+n$，很容易就能推导出时间复杂度是$O(n\\log n)$。但是，我们并不可能每次分区都这么幸运，正好一分为二。</p><p>我们假设平均情况下，每次分区之后，两个分区的大小比例为$1:k$。当$k=9$时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成$T(n)=T(\\frac{n}{10})+T(\\frac{9n}{10})+n$。</p><p>这个公式可以推导出时间复杂度，但是推导过程非常复杂。那我们来看看，<strong>用递归树来分析快速排序的平均情况时间复杂度，是不是比较简单呢？</strong></p><p>我们还是取$k$等于$9$，也就是说，每次分区都很不平均，一个分区是另一个分区的$9$倍。如果我们把递归分解的过程画成递归树，就是下面这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/44/43/44972a3531dae0b7a0ccc935bc13f243.jpg?wh=1142*811\" alt=\"\"></p><p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是$n$。我们现在只要求出递归树的高度$h$，这个快排过程遍历的数据个数就是 $h * n$ ，也就是说，时间复杂度就是$O(h * n)$。</p><p>因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。这样一个递归树的高度是多少呢？</p><p>我们知道，快速排序结束的条件就是待排序的小区间，大小为$1$，也就是说叶子节点里的数据规模是$1$。从根节点$n$到叶子节点$1$，递归树中最短的一个路径每次都乘以$\\frac{1}{10}$，最长的一个路径每次都乘以$\\frac{9}{10}$。通过计算，我们可以得到，从根节点到叶子节点的最短路径是$\\log_{10}n$，最长的路径是$\\log_{\\frac{10}{9}}n$。</p><p><img src=\"https://static001.geekbang.org/resource/image/7c/ed/7cea8607f0d92a901f3152341830d6ed.jpg?wh=1142*446\" alt=\"\"></p><p>所以，遍历数据的个数总和就介于$n\\log_{10}n$和$n\\log_{\\frac{10}{9}}n$之间。根据复杂度的大O表示法，对数复杂度的底数不管是多少，我们统一写成$\\log n$，所以，当分区大小比例是$1:9$时，快速排序的时间复杂度仍然是$O(n\\log n)$。</p><p>刚刚我们假设$k=9$，那如果$k=99$，也就是说，每次分区极其不平均，两个区间大小是$1:99$，这个时候的时间复杂度是多少呢？</p><p>我们可以类比上面$k=9$的分析过程。当$k=99$的时候，树的最短路径就是$\\log_{100}n$，最长路径是$\\log_{\\frac{100}{99}}n$，所以总遍历数据个数介于$n\\log_{100}n$和$n\\log_{\\frac{100}{99}}n$之间。尽管底数变了，但是时间复杂度也仍然是$O(n\\log n)$。</p><p>也就是说，对于$k$等于$9$，$99$，甚至是$999$，$9999$……，只要$k$的值不随$n$变化，是一个事先确定的常量，那快排的时间复杂度就是$O(n\\log n)$。所以，从概率论的角度来说，快排的平均时间复杂度就是$O(n\\log n)$。</p><h2>实战二：分析斐波那契数列的时间复杂度</h2><p>在递归那一节中，我们举了一个跨台阶的例子，你还记得吗？那个例子实际上就是一个斐波那契数列。为了方便你回忆，我把它的代码实现贴在这里。</p><pre><code>int f(int n) {\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  return f(n-1) + f(n-2);\n}\n</code></pre><p>这样一段代码的时间复杂度是多少呢？你可以先试着分析一下，然后再来看，我是怎么利用递归树来分析的。</p><p>我们先把上面的递归代码画成递归树，就是下面这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/ce/9ccbce1a70c7e2def52701dcf176a4ce.jpg?wh=1142*649\" alt=\"\"></p><p>这棵递归树的高度是多少呢？</p><p>$f(n)$分解为$f(n-1)$和$f(n-2)$，每次数据规模都是$-1$或者$-2$，叶子节点的数据规模是$1$或者$2$。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是$-1$，那最长路径大约就是$n$；如果每次都是$-2$，那最短路径大约就是$\\frac{n}{2}$。</p><p>每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作$1$。所以，从上往下，第一层的总时间消耗是$1$，第二层的总时间消耗是$2$，第三层的总时间消耗就是$2^{2}$。依次类推，第$k$层的时间消耗就是$2^{k-1}$，那整个算法的总的时间消耗就是每一层时间消耗之和。</p><p>如果路径长度都为$n$，那这个总和就是$2^{n}-1$。</p><p><img src=\"https://static001.geekbang.org/resource/image/86/1f/86d301fc5fa3088383fa5b45f01e4d1f.jpg?wh=1142*158\" alt=\"\"></p><p>如果路径长度都是$\\frac{n}{2}$ ，那整个算法的总的时间消耗就是$2^{\\frac{n}{2}}-1$。</p><p><img src=\"https://static001.geekbang.org/resource/image/55/d4/55fcb1570dfa09e457cdb93ba58777d4.jpg?wh=1142*158\" alt=\"\"></p><p>所以，这个算法的时间复杂度就介于$O(2^{n})$和$O(2^{\\frac{n}{2}})$之间。虽然这样得到的结果还不够精确，只是一个范围，但是我们也基本上知道了上面算法的时间复杂度是指数级的，非常高。</p><h2>实战三：分析全排列的时间复杂度</h2><p>前面两个复杂度分析都比较简单，我们再来看个稍微复杂的。</p><p>我们在高中的时候都学过排列组合。“如何把$n$个数据的所有排列都找出来”，这就是全排列的问题。</p><p>我来举个例子。比如，$1， 2，3$这样$3$个数据，有下面这几种不同的排列：</p><pre><code>1, 2, 3\n1, 3, 2\n2, 1, 3\n2, 3, 1\n3, 1, 2\n3, 2, 1\n</code></pre><p>如何编程打印一组数据的所有排列呢？这里就可以用递归来实现。</p><p>如果我们确定了最后一位数据，那就变成了求解剩下$n-1$个数据的排列问题。而最后一位数据可以是$n$个数据中的任意一个，因此它的取值就有$n$种情况。所以，“$n$个数据的排列”问题，就可以分解成$n$个“$n-1$个数据的排列”的子问题。</p><p>如果我们把它写成递推公式，就是下面这个样子：</p><pre><code>假设数组中存储的是1，2， 3...n。\n        \nf(1,2,...n) = {最后一位是1, f(n-1)} + {最后一位是2, f(n-1)} +...+{最后一位是n, f(n-1)}。\n</code></pre><p>如果我们把递推公式改写成代码，就是下面这个样子：</p><pre><code>// 调用方式：\n// int[]a = a={1, 2, 3, 4}; printPermutations(a, 4, 4);\n// k表示要处理的子数组的数据个数\npublic void printPermutations(int[] data, int n, int k) {\n  if (k == 1) {\n    for (int i = 0; i &lt; n; ++i) {\n      System.out.print(data[i] + &quot; &quot;);\n    }\n    System.out.println();\n  }\n\n  for (int i = 0; i &lt; k; ++i) {\n    int tmp = data[i];\n    data[i] = data[k-1];\n    data[k-1] = tmp;\n\n    printPermutations(data, n, k - 1);\n\n    tmp = data[i];\n    data[i] = data[k-1];\n    data[k-1] = tmp;\n  }\n}\n</code></pre><p>如果不用我前面讲的递归树分析方法，这个递归代码的时间复杂度会比较难分析。现在，我们来看下，如何借助递归树，轻松分析出这个代码的时间复杂度。</p><p>首先，我们还是画出递归树。不过，现在的递归树已经不是标准的二叉树了。</p><p><img src=\"https://static001.geekbang.org/resource/image/82/9b/82f40bed489cf29b14192b44decf059b.jpg?wh=1142*936\" alt=\"\"></p><p>第一层分解有$n$次交换操作，第二层有$n$个节点，每个节点分解需要$n-1$次交换，所以第二层总的交换次数是$n*(n-1)$。第三层有$n*(n-1)$个节点，每个节点分解需要$n-2$次交换，所以第三层总的交换次数是$n*(n-1)*(n-2)$。</p><p>以此类推，第$k$层总的交换次数就是$n * (n-1) * (n-2) * ... * (n-k+1)$。最后一层的交换次数就是$n * (n-1) * (n-2) * ... * 2 * 1$。每一层的交换次数之和就是总的交换次数。</p><pre><code>n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1\n</code></pre><p>这个公式的求和比较复杂，我们看最后一个数，$n * (n-1) * (n-2) * ... * 2 * 1$等于$n!$，而前面的$n-1$个数都小于最后一个数，所以，总和肯定小于$n * n!$，也就是说，全排列的递归算法的时间复杂度大于$O(n!)$，小于$O(n * n!)$，虽然我们没法知道非常精确的时间复杂度，但是这样一个范围已经让我们知道，全排列的时间复杂度是非常高的。</p><p>这里我稍微说下，掌握分析的方法很重要，思路是重点，不要纠结于精确的时间复杂度到底是多少。</p><h2>内容小结</h2><p>今天，我们用递归树分析了递归代码的时间复杂度。加上我们在排序那一节讲到的递推公式的时间复杂度分析方法，我们现在已经学习了两种递归代码的时间复杂度分析方法了。</p><p>有些代码比较适合用递推公式来分析，比如归并排序的时间复杂度、快速排序的最好情况时间复杂度；有些比较适合采用递归树来分析，比如快速排序的平均时间复杂度。而有些可能两个都不怎么适合使用，比如二叉树的递归前中后序遍历。</p><p>时间复杂度分析的理论知识并不多，也不复杂，掌握起来也不难，但是，在我们平时的工作、学习中，面对的代码千差万别，能够灵活应用学到的复杂度分析方法，来分析现有的代码，并不是件简单的事情，所以，你平时要多实战、多分析，只有这样，面对任何代码的时间复杂度分析，你才能做到游刃有余、毫不畏惧。</p><h2>课后思考</h2><p>$1$个细胞的生命周期是$3$小时，$1$小时分裂一次。求$n$小时后，容器内有多少细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p>","comments":[{"had_liked":false,"id":41178,"user_name":"farFlight","can_delete":false,"product_type":"c1","uid":1245211,"ip_address":"","ucode":"B0872D3ECBEC38","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbRibsic15KXfGEN3SSjnLhXGyhK2Uyrj5ibBJsKAjicNqtafDaQOLH4xpSJRZD1vmibFPJER1ySmwP9A/132","comment_is_top":false,"comment_ctime":1542756345,"is_pvip":false,"discussion_count":28,"race_medal":0,"score":"2033062287353","product_id":100017301,"comment_content":"假设细胞到了第三个小时是先分裂完再死亡，那么递推公式就应该是：<br>f(n) = f(n-1)*2 - f(n-3)<br>一次乘法和一次减法一起看作一次基本操作消耗，那么情况和斐波那契数列很像。<br>最高的树应该有n层， 最短的是n&#47;3层，每层操作数都是指数增长。<br>那么时间复杂度应该是在O(2^n)量级的。","like_count":473,"discussions":[{"author":{"id":1288019,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/53/d09af082.jpg","nickname":"TWENTYFOUR","note":"","ucode":"BFD3D7D6070664","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164105,"discussion_content":"递推公式不对。因为第n小时死亡的细胞应该是第(n-3)h刚分裂出来的细胞，而第(n-3)h刚分裂出来的细胞刚好等于第(n-4)h的细胞。所以递推公式应该是f(n)=2*f(n-1)-f(n-4)。","likes_number":24,"is_delete":false,"is_hidden":false,"ctime":1581151689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1739011,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/89/03/8498c7d5.jpg","nickname":"小K","note":"","ucode":"DA39D5CC847BEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91339,"discussion_content":"复杂度量级是指数级，但递推公式有误，死掉的细胞数应该是n-3时刻新生的细胞数，而n-3时刻新生的细胞数正是前一时刻分裂而来的即f(n-4)。\n参考：https://xiaozhuanlan.com/topic/6091358742","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1576828098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1180307,"avatar":"https://static001.geekbang.org/account/avatar/00/12/02/93/44672231.jpg","nickname":"seven","note":"","ucode":"55CE5F60051F89","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1739011,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/89/03/8498c7d5.jpg","nickname":"小K","note":"","ucode":"DA39D5CC847BEE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94737,"discussion_content":"有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576984365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":91339,"ip_address":""},"score":94737,"extra":""}]},{"author":{"id":1811010,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a2/42/4948f2b9.jpg","nickname":"划船一哥","note":"","ucode":"61539E491E86F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351490,"discussion_content":"第三小时：先分裂再死是f(n)=2f(n-1)-f(n-4)\n先死不分裂是f(n)=2[f(n-1)-f(n-4)]","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1614305035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335397,"discussion_content":"细胞分裂，一个变两个，原来的那个被分裂的细胞被分分裂后就已经不存在了，何来生命周期一说，题目本身有歧义","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1608182686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1014401,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7a/81/69874318.jpg","nickname":"ding","note":"","ucode":"54AF950B3CA740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":374437,"discussion_content":"不是的。 一个细胞分裂成两个，其中一个是原来那个也叫母细胞，另外一个是子细胞。\n一开始是女孩，女孩长大了，开始分裂，分裂之后就是妈妈跟女儿。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621175671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335397,"ip_address":""},"score":374437,"extra":""},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1014401,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7a/81/69874318.jpg","nickname":"ding","note":"","ucode":"54AF950B3CA740","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374571,"discussion_content":"好吧，你这解释，非要纠结其实也不准确，生物学上的细胞分裂，我专门查看下，意思是说，细胞分裂前的那个被分裂的细胞是母细胞，分裂后存在的两个细胞是子细胞。并不是说，分裂后，其中一个细胞是母细胞。只有一点是对的，就是细胞分裂后，分裂前如果是一个细胞，分裂后，总数为两个细胞。其实和习题想要表达的意思并不很相符，只要发生分裂，被分裂的那个细胞就不存在了，融入了分裂之后的那两个细胞。不存在母细胞是分裂之前死亡还是分裂之后死亡这种说法。因为在分裂的那一刻，它就已经变成两个子细胞的一部分了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621252954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":374437,"ip_address":""},"score":374571,"extra":""},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1014401,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7a/81/69874318.jpg","nickname":"ding","note":"","ucode":"54AF950B3CA740","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374572,"discussion_content":"更准确的习题例子是用兔子来做例子，比如一只兔子，一个月后生了两只兔子，三个月后，死了，这样才符合作者想表述的意思。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1621253350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":374437,"ip_address":""},"score":374572,"extra":""}]},{"author":{"id":1607864,"avatar":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","nickname":"陈琦","note":"","ucode":"48F974137EF0BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297132,"discussion_content":"答案应该是f(n)=2*f(n-1)-f(n-4)","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1596784549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1106109,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/bd/3abd26fd.jpg","nickname":"豪曹","note":"","ucode":"93C1CE47B74899","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282062,"discussion_content":"f(n) = f(n-1)*2 - f(n-4)","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591876048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69058,"discussion_content":"通过查阅相关算法其他的资料，认为该评论不对。具体参考Bryce同学的讲解，或https://xiaozhuanlan.com/topic/6091358742","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575255771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129782,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3d/36/a20eb4c4.jpg","nickname":"xfly.me","note":"","ucode":"40B8F900A094FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5609,"discussion_content":"递推公式不对","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1566375630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344632,"avatar":"https://static001.geekbang.org/account/avatar/00/14/84/78/c246f6d5.jpg","nickname":"Jeff","note":"","ucode":"3E22C18FF4986F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308428,"discussion_content":"k>=4 时， f(k) = 2f(k-1) - [f(k-3) - f(k-4)]","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600949820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/1f/ef171ece.jpg","nickname":"阿洛飛","note":"","ucode":"46038E357CF970","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304049,"discussion_content":"确切的来说是减去f(n-3)所有细胞中的是新生的细胞，那么f(n-3)中有代数为0，1，2，3的细胞的，那么0代的是从哪里呢，是从f(n-3)的上一代中来，所以是f(n-4)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599458950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296881,"discussion_content":"答案应该是f(n)=2*f(n-1)-f(n-4)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596694313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242338,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/e2/dbc4a5f2.jpg","nickname":"朱东旭","note":"","ucode":"C48DD620A63868","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220863,"discussion_content":"这个人认为正确答案是f(n-4),可是f(n-3)却得到了多数票，看样子真理确实掌握在少数人手中在这里得到了验证。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585927218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128420,"avatar":"https://static001.geekbang.org/account/avatar/00/11/37/e4/5d7a32c6.jpg","nickname":"creasylai19","note":"","ucode":"F9B04060FCFD3F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587321,"discussion_content":"这个递推公式不对。\n另外给一个简单的计算公式sum=(2^n)+(2^(n-1))+(2^(n-2))\n\n画图如下：\n第0小时        1            &gt;这一层(2^0)个节点，合计(2^0)个节点\n第1小时     1       1       &gt;这一层(2^1)个节点，合计(2^1)+(2^0)个节点\n第2小时  1   1   1   1     &gt;这一层(2^2)个节点，合计(2^2)+(2^1)+(2^0)个节点\n第3小时 1 1 1 1 1 1 1 1   &gt;这一层(2^3)个节点，合计(2^3)+(2^2)+(2^1)个节点\n...\n第n小时                     &gt;这一层(2^n)个节点，合计(2^n)+(2^(n-1))+(2^(n-2))个节点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662975576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2252211,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5d/b3/aa2c17f0.jpg","nickname":"🔥 如初之光","note":"","ucode":"0FB2BA12D4B15A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323043,"discussion_content":"第一反应就是类似斐波那契","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604877898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400168,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5d/68/98cf8ef8.jpg","nickname":"曾经蜡笔没有小新","note":"","ucode":"2D50C3A6DF8C15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294388,"discussion_content":"f(-∝)=0;f(0)=1;f(n)=2*f(n-1)-(f(n-3)-f(n-4));   完全三叉树，高度为n，每层操作次数为3^(n-1)，复杂度O(3^n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595863818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1903641,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0c/19/01f075fe.jpg","nickname":"Typing...","note":"","ucode":"5F8E60E5D55E3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244775,"discussion_content":"踩下去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587629467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583792,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2a/b0/0494447e.jpg","nickname":"墙东扶西","note":"","ucode":"8D6803FCDBF8AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225951,"discussion_content":"反驳的结论好像有点道理，n-3的所有存活细胞中，有些在n-2和n-1时刻已经死亡，所以减去f(n-3)是不对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586408839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69060,"discussion_content":"如果有一个这样的机制就好了---将正确的答案置顶或给予特殊标记。另外，如果评论内容错误，怎么会被选为精选留言呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575255868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1638587,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/bb/25a29311.jpg","nickname":"森鱼","note":"","ucode":"6AF86EB05088F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7564,"discussion_content":"最后剩下的细胞个数，并不只有最新的这一层，还有前两层的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567565932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014615,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/57/18b61282.jpg","nickname":"dullduck","note":"","ucode":"25293558309704","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1638587,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/bb/25a29311.jpg","nickname":"森鱼","note":"","ucode":"6AF86EB05088F4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115816,"discussion_content":"是细胞分裂，不是兔子下崽","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578037189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7564,"ip_address":""},"score":115816,"extra":""}]}]},{"had_liked":false,"id":51778,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1545237044,"is_pvip":false,"discussion_count":24,"race_medal":0,"score":"1835496272436","product_id":100017301,"comment_content":"有些同学不明白点赞第一的意思，在此试着解释一下。<br><br>假设细胞先分裂再死亡，即，每个细胞分裂三次后死亡（存活三个小时）。<br><br>n 从第 0 个小时开始，<br><br>n = 0，f(0) = 1<br><br>n = 1，f(1) = 2*f(1)<br><br>n = 2，f(2) = 2*f(1)<br><br>n = 3，f(3) = 2*f(2) - f(0) ，减去存活了三个小时的细胞个数。<br><br>n = 4，f(4) = 2*f(3) - f(1)，减去存活了三个小时的细胞个数。<br><br>以此类推：<br><br>f(n) = 2*f(n-1) - f(n-3)，减去存活了三个小时的细胞个数。<br>","like_count":428,"discussions":[{"author":{"id":1254012,"avatar":"https://static001.geekbang.org/account/avatar/00/13/22/7c/7169323f.jpg","nickname":"飘逸的翔云","note":"","ucode":"0E756D3AC3D889","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41616,"discussion_content":"n=1时是等于2*f(0)吧","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1572480483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698679,"avatar":"https://static001.geekbang.org/account/avatar/00/19/eb/77/ffd16123.jpg","nickname":"重洋","note":"","ucode":"B896A81B579BEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359292,"discussion_content":"确实是n-4：减去的不是n-3时的所有细胞，而是n-3时新生的细胞，即n-4，因为非新生的细胞在更早的时候已经死过了。\n换个说法：n时刻，应该减去n-3时刻仍存活的细胞（新生细胞），n-3之前出生的细胞已经死了还怎么减呢？","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1616158790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204386,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK1iadgQFxhYdu7wIUf7n5XYZlchNicdGBsafY9GPX3hNq0313DfE7ia6CeRm7VZAmwGPsLI8icTJUqXg/132","nickname":"jians","note":"","ucode":"2600DC7CE1E5E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79052,"discussion_content":"wo以为细胞只是一分为二，继续倒计时，三小时后都死完了","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1576050789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1602652,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzSRrK59sydlOmgvqIFm1pjHA55RcM5ttWvHdOZyibZhFCr7picy4Xf5Bf9dLOW8d2DGUwA1zormzw/132","nickname":"钱勇","note":"","ucode":"BA2796F17E54E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21261,"discussion_content":"注意：细胞分裂（cell division）是指活细胞增殖其数量由一个细胞分裂为两个细胞的过程。分裂前的细胞称母细胞，分裂后形成的新细胞称子细胞。通常包括细胞核分裂和细胞质分裂两步。在核分裂过程中母细胞把遗传物质传给子细胞。\n\n所以分裂一次得到2个细胞，而不是3个！","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1569460091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242338,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/e2/dbc4a5f2.jpg","nickname":"朱东旭","note":"","ucode":"C48DD620A63868","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220616,"discussion_content":"这推理不对，因为f(0)中的细胞有部分已经死亡了，不能整个减去f(0),准确来说是减去f(0)所在时点出生的所有细胞。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1585907075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607864,"avatar":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","nickname":"陈琦","note":"","ucode":"48F974137EF0BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297134,"discussion_content":"https://xiaozhuanlan.com/topic/6091358742","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1596784563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607864,"avatar":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","nickname":"陈琦","note":"","ucode":"48F974137EF0BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297133,"discussion_content":"答案应该是f(n)=2*f(n-1)-f(n-4)","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1596784556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131070,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/3e/c1f76202.jpg","nickname":"青山","note":"","ucode":"749BAD1834AC0F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":125056,"discussion_content":"最后的推到公式有错误:f(n-3),举个例子1,2,4,7,后面按照你的公式推导下一个结果为:14-2=12,问题来了你减的这个2他其中的一个已经在第三小时死了(结果为7的时候已经减1),这个时候就知道第四个小时死去的细胞为1而不为2(因为其中一个在第三小时死翘翘了),所以结果为14-1.","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578470936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1476862,"avatar":"https://static001.geekbang.org/account/avatar/00/16/88/fe/c18a85fe.jpg","nickname":"随风","note":"","ucode":"037CE3554D8AB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1131070,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/3e/c1f76202.jpg","nickname":"青山","note":"","ucode":"749BAD1834AC0F","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":308685,"discussion_content":"没问题，f(3)的时候死的是f(0)所以f(3) = 7, f(4)的时候死的是f(1)，也是死的是f(0)分裂出的两个，所以f(4)还是12不是13，并没有多减去1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601030052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":125056,"ip_address":""},"score":308685,"extra":""},{"author":{"id":2259843,"avatar":"https://static001.geekbang.org/account/avatar/00/22/7b/83/cbfeddae.jpg","nickname":"庆庆","note":"","ucode":"77BE2DCEF15450","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1476862,"avatar":"https://static001.geekbang.org/account/avatar/00/16/88/fe/c18a85fe.jpg","nickname":"随风","note":"","ucode":"037CE3554D8AB9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385818,"discussion_content":"f(0)分裂出的f(1)的两个，一个是老的（即f0细胞本身），一个是新的，老的在f(3)时死了，所以f(4)时只死了f(1)中这个新的，所以f(4)是13。这里理解有歧义的一点是，细胞分裂是老细胞吐一个新细胞出来，而不是老细胞变成2个新细胞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627287024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":308685,"ip_address":""},"score":385818,"extra":""}]},{"author":{"id":1225395,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","nickname":"帽子丨影","note":"","ucode":"2B34892A2DE83E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77014,"discussion_content":"我觉得正确的公式应该是减去3小时前新增的那些 f(n)=f(n-1) - (f(n-3) - f(n-4))","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575879436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1298380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","nickname":"徐改","note":"","ucode":"82276A584AC602","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1225395,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","nickname":"帽子丨影","note":"","ucode":"2B34892A2DE83E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362272,"discussion_content":"不过准确的是不是f(n) = 2*f(n-1) - [f(n-3) - f(n-4)]？，确实是只需要减去三小时前新生的那些细胞就可以了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616904451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77014,"ip_address":""},"score":362272,"extra":""}]},{"author":{"id":1174794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","nickname":"Juniper","note":"","ucode":"1BC24554034BD3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389944,"discussion_content":"3小时和4小时及之后的是不一样的，3小时是 f(3) = 2 * f(3-1) - f(3-3)，这里的f(3-3)是指的初始的细胞数。4小时公式是 f(4) = 2 * f(4-1) - f(4-4),这里的f(4-4)表示的是第（4-3）个小时新分裂的细胞数，他们恰好是第4小时死亡，由于细胞是1：1的比例分裂的，所以第（4-4）小时的总细胞数就是第（4-3）小时的新分裂细胞数。然后公式抽象一下，就是f(n) = 2 * f(n-1) - f(n-4),适用第4小时及之后的结果","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629531555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1174794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","nickname":"Juniper","note":"","ucode":"1BC24554034BD3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409812,"discussion_content":"感谢！ 懂了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635517326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389944,"ip_address":""},"score":409812,"extra":""}]},{"author":{"id":1547322,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","nickname":"junjun","note":"","ucode":"1F7EE146B9BE04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19838,"discussion_content":"那分裂后原来的细胞是不存在了吗？如果存在，这个推理是不是就不对了啊？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569230254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246531,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/43/baac3bbb.jpg","nickname":"EyesOnMe","note":"","ucode":"981482EA89DC02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573641,"discussion_content":"给你这么分析，确实应该是f(n-4)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653559858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296882,"discussion_content":"答案应该是f(n)=2*f(n-1)-f(n-4)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596694339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225395,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","nickname":"帽子丨影","note":"","ucode":"2B34892A2DE83E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77011,"discussion_content":"不是吧，f4的时候减去的f1是两个，但这两个中第一个在f3的时候已经死了啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575879167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238238,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/de/deaa9da1.jpg","nickname":"光脚造轮子","note":"","ucode":"7B1485B7045D15","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62603,"discussion_content":"n从3开始算吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574854396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23515,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569829401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001970,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/f2/25cfa472.jpg","nickname":"寒溪","note":"","ucode":"67B9F1A1C15A20","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6884,"discussion_content":"这个推理很赞，受教了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567153755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001970,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/f2/25cfa472.jpg","nickname":"寒溪","note":"","ucode":"67B9F1A1C15A20","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":165959,"discussion_content":"他的推导根本不对","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581343118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6884,"ip_address":""},"score":165959,"extra":""}]},{"author":{"id":1610333,"avatar":"","nickname":"Geek_86533a","note":"","ucode":"6961C429E8953A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4069,"discussion_content":"感谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565091672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2207,"discussion_content":"解释很清楚，给个赞。发现递归就是一步步写出来，比较好理解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563353901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66847,"user_name":"Bryce","can_delete":false,"product_type":"c1","uid":1286669,"ip_address":"","ucode":"E504AB8F2CA1A1","user_header":"https://static001.geekbang.org/account/avatar/00/13/a2/0d/e72f5e75.jpg","comment_is_top":false,"comment_ctime":1550028993,"is_pvip":false,"discussion_count":18,"race_medal":0,"score":"735989436609","product_id":100017301,"comment_content":"点赞第一的递推可能有些问题，这里假设经过三个小时的细胞分裂后再死亡。<br>通过留言可以看出有些同学可能没搞明白细胞分裂的方式，根据题意，细胞的生命周期是三个小时，一个小时后，第一个细胞分裂，此时细胞总数变成 2，但是这两个细胞的生存时间是不一样的，如果都当成新生细胞即存活时间为 0，那么给定的 3小时生命周期也就没意义了，所以这个时候其中一个细胞的生存时间变成了 1，另外一个刚分裂出来的是 0，下面简单表示一下分裂进程（-1 表示死亡）<br>时间          细胞状态 (生存时间)                                      细胞总数<br>  0              0                                                                        1<br>  1               1  0                                                                    2<br>  2              2  1  0  0                                                             4<br>  3             -1  2  1  1  0  0  0  0                                              7<br>  4             -1  2  2  1  1  1  1  0  0  0  0  0  0  0                        13<br>  5             -1  -1  2  2  2  2  1  1  1  1  1  1  1 <br>                   0  0  0  0  0  0  0  0  0  0  0  0  0                        24<br>  ....               .............................................                                   ....<br>f0 = 1<br>f1 = 2<br>f2 = 4<br>f3 = 7<br>可以发现到第四个小时的时候，规律出来了，在第四个小时死亡的细胞是三小时前也就是第一个小时的时候同时出生的细胞，而在第一个小时同时出生的细胞数等于第一个小时前一个小时的细胞总数<br>所以有递推式：f(n) = 2 * f(n - 1) - f(n - 4)","like_count":171,"discussions":[{"author":{"id":1128491,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","nickname":"星夜","note":"","ucode":"3B46C09D994CEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314171,"discussion_content":"应该是f(n-4)，因为3小时前的细胞并不都是刚出生的，而3小时前刚出生的细胞数就等于4小时前的细胞数������","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603121255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237849,"discussion_content":"减3还是减4归根结底的一个问题是细胞生下来是几岁？三个小时的生命周期，如果是减三，那生下来就是一岁，实际它没经历一个小时","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587191783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218937,"avatar":"https://static001.geekbang.org/account/avatar/00/12/99/79/74d4f24f.jpg","nickname":"anker","note":"","ucode":"6EDF1FB9D45238","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47186,"discussion_content":"你这不对啊老铁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573290048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1439568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","nickname":",","note":"","ucode":"191431A878D7B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5229,"discussion_content":"递推公式还是：f(n) = 2 * f(n - 1) - f(n - 3)，从第4个小时那里作者就写错了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566096868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1244817,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/91/0ee2741a.jpg","nickname":"吉页","note":"","ucode":"8E25056FB25012","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1439568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","nickname":",","note":"","ucode":"191431A878D7B6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187865,"discussion_content":"我认为作者第4个小时的时候只有一个-1是因为把第三个小时里的-1去掉了，这时候第4个小时里的-1代表的是第三个小时里的2。\n这样理解的话作者的文字图没有画错","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582774339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5229,"ip_address":""},"score":187865,"extra":""},{"author":{"id":1521486,"avatar":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","nickname":"知行合一","note":"","ucode":"2B8E634FC4CFB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1244817,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/91/0ee2741a.jpg","nickname":"吉页","note":"","ucode":"8E25056FB25012","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374844,"discussion_content":"你解释的对，要不然我也以为漏了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621387419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":187865,"ip_address":""},"score":374844,"extra":""}]},{"author":{"id":1016276,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/81/d4/e92abeb4.jpg","nickname":"Jecy-8","note":"","ucode":"2AE1575B9E63A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365066,"discussion_content":"跟我想的一样哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617700092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302340,"discussion_content":"点赞第一个 没错啊。。 f(3) = 2*f(2) - f(0)  第三个小时的时候  原始细胞就死掉了  所以有啥问题呢。。 这里 n = 3  带到公式就是 f(n) = 2*f(n-1) - f(n-3)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598882036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1192991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/1f/ef171ece.jpg","nickname":"阿洛飛","note":"","ucode":"46038E357CF970","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304048,"discussion_content":"确切的来说是减去f(n-3)所有细胞中的是新生的细胞，那么f(n-3)中有代数为0，1，2，3的细胞的，那么0代的是从哪里呢，是从f(n-3)的上一代中来，所以是f(n-4)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599458929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302340,"ip_address":""},"score":304048,"extra":""},{"author":{"id":2672167,"avatar":"https://static001.geekbang.org/account/avatar/00/28/c6/27/d553250e.jpg","nickname":"清风，佳音，真诚，理想","note":"","ucode":"7E3A0023B79C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383865,"discussion_content":"建议手工模拟一下，你就明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626257429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302340,"ip_address":""},"score":383865,"extra":""}]},{"author":{"id":1607864,"avatar":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","nickname":"陈琦","note":"","ucode":"48F974137EF0BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297137,"discussion_content":"时间复杂度呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596784726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547322,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","nickname":"junjun","note":"","ucode":"1F7EE146B9BE04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19843,"discussion_content":"我觉得当细胞生命周期到0的时候，可以算上，不用减去，这是就是f(n) = 2*f(n-1) - f(n-3)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569230625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205627,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","nickname":"Hwan","note":"","ucode":"A728C6790511BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19774,"discussion_content":"使用了两种方法，根据结构这个是正确的感觉，是n-4","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569223701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246563,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/63/9899e23c.jpg","nickname":"JimmyZ","note":"","ucode":"83CE33C8E032A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7790,"discussion_content":"其实复杂度计算的结果是一样的，但是到底是n-3还是n-4，取决于每个人怎么理解题目，生命周期3小时，到底什么时候死去：是2小时59分？还是3小时1分？不同的理解，就会造成n-3和n-4的区别。但是大多数人的理解应该是2小时59分死掉，活不过3小时，那么递推公式就是 n-3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567675730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1246563,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/63/9899e23c.jpg","nickname":"JimmyZ","note":"","ucode":"83CE33C8E032A4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69056,"discussion_content":"没明白你的意思，能具体阐述一下2小时59分和3小时1分的区别吗？\n\n我觉得这跟两个时间点没关系，通过查阅相关算法题目发现，理解该题目的关键是一次细胞分裂出来的多个细胞，生命周期不都是0。该条评论中的讲解是正确的。\nhttps://xiaozhuanlan.com/topic/6091358742","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575255701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7790,"ip_address":""},"score":69056,"extra":""}]},{"author":{"id":1514247,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/07/0c1c76c2.jpg","nickname":"Frederick","note":"","ucode":"1481E9A581F7C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3892,"discussion_content":"最后应该是f(n-3) 不是f(n-4)，可以直接代入n=3验证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564931042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1389469,"avatar":"https://static001.geekbang.org/account/avatar/00/15/33/9d/db4c40ce.jpg","nickname":"赵小骞","note":"","ucode":"243759EF92382E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1514247,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/07/0c1c76c2.jpg","nickname":"Frederick","note":"","ucode":"1481E9A581F7C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4279,"discussion_content":"可是我也觉得是n-4，而且这个公式不能带n-3验证","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1565268972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3892,"ip_address":""},"score":4279,"extra":""},{"author":{"id":1258401,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a1/f3835f01.jpg","nickname":"社会猪","note":"","ucode":"CFF5EA7F247373","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1389469,"avatar":"https://static001.geekbang.org/account/avatar/00/15/33/9d/db4c40ce.jpg","nickname":"赵小骞","note":"","ucode":"243759EF92382E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14394,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568736688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4279,"ip_address":""},"score":14394,"extra":""}]}]},{"had_liked":false,"id":43939,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1543330318,"is_pvip":false,"discussion_count":27,"race_medal":0,"score":"675853195790","product_id":100017301,"comment_content":"说个有意思的现象，我平时除了看专栏本身的内容，我也会看留言。我发现从专栏开始时，精品留言点赞数达到500多，随着专栏的前行，点赞的人越来越少了😄<br><br>从中，也能发现端倪。<br><br>这挺有意思的","like_count":158,"discussions":[{"author":{"id":1445123,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0d/03/e59341b4.jpg","nickname":"亚","note":"","ucode":"CDF4DFC3F3619A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228947,"discussion_content":"其实这是个很正常的现象，自己能坚持到最后固然最好，但是也没必要把自己的坚持强加到别人身上。如果不是这样，健身房早就可以倒闭了。。","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1586593993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1850499,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/3c/83/93e7af9e.jpg","nickname":"兰柯","note":"","ucode":"6D7230B3CE8722","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174721,"discussion_content":"是啊，老师的回复也越来越少了【手动狗头】","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1581938481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2437971,"avatar":"https://static001.geekbang.org/account/avatar/00/25/33/53/b27347b2.jpg","nickname":"博古拉","note":"","ucode":"9ED1EE3BF31D40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1850499,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/3c/83/93e7af9e.jpg","nickname":"兰柯","note":"","ucode":"6D7230B3CE8722","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352290,"discussion_content":"乐死我了，能不能顶你上去/狗头","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1614673682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":174721,"ip_address":""},"score":352290,"extra":""}]},{"author":{"id":1522962,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIshxMaBXdg4piacnPVaic3kGMS3lWIibcib1icAFCXcv3kEPwib7t7srmL1I2MEdWo0RXkBlAW4MtiahGAw/132","nickname":"愚者","note":"","ucode":"67F5A01DE0A84A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":775,"discussion_content":"越来越看不懂了，当人们不理解的时候会本能的烦躁，厌恶，即使正确也是讨厌的","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1562053836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2289712,"avatar":"https://static001.geekbang.org/account/avatar/00/22/f0/30/3128fd4f.jpg","nickname":"蓝瓶子 🌻","note":"","ucode":"0E432300A9FEB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538051,"discussion_content":"因为很多人不用看到这里 就已经找到工作了，就不看后边的了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639314773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2377965,"avatar":"","nickname":"Geek_8ac51c","note":"","ucode":"AE8E646F67B62E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338418,"discussion_content":"这个课能保留多久，我留言讨论最早一期的人能看见吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609273446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1239774,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epVZiaZL3Wicq92boVHYcrzCEl7XN1pCeh1nFibt254Kf38P6p4AqbAqnwe1b3cIQpDWCib16A9aF709g/132","nickname":"极明","note":"","ucode":"924F8FEE5D5737","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2377965,"avatar":"","nickname":"Geek_8ac51c","note":"","ucode":"AE8E646F67B62E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380884,"discussion_content":"能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624775536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338418,"ip_address":""},"score":380884,"extra":""}]},{"author":{"id":1716801,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/32/41/c1a7840b.jpg","nickname":"着迷","note":"","ucode":"429F1D4015A195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283847,"discussion_content":"看到这里，有一些看不懂了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592382803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1910465,"avatar":"","nickname":"iu1993914","note":"","ucode":"BAC6CE9AA4B992","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248765,"discussion_content":"你有主观臆断，只不过没说出来罢了，大家都懂。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587894002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178751,"discussion_content":"我只是称述了一个事实，没有任何个人的主观臆断。所以，要是让大家觉得我故意说话说了一半，故弄玄虚，抱歉了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582194476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742968,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/98/78/6459e29e.jpg","nickname":"麦芽科技学堂","note":"","ucode":"A90DDE4B6696BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":134121,"discussion_content":"意思是刚开始的时候队伍很拥挤，慢慢的有人开始掉队了，只要能坚持到最后就超过了80％的人","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579011140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582543,"discussion_content":"想不到有这么多人点赞，他们到底怎么想的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659500510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897788,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f5/3c/0a0247d9.jpg","nickname":"ShawnZ","note":"","ucode":"1A37744CCE0DD6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558109,"discussion_content":"这很正常，大家都留到最后才不正常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648095507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2702381,"avatar":"","nickname":"Geek_9e6efc","note":"","ucode":"A2991D304D1F31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394563,"discussion_content":"冲冲冲！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631940222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061991,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/67/06a7f9be.jpg","nickname":"while (1)等;","note":"","ucode":"BAEC7258D65B69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393086,"discussion_content":"其实看到这里，前面忘得也差不多了，能坚持下去也需要很大的毅力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631242467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1174794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","nickname":"Juniper","note":"","ucode":"1BC24554034BD3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389946,"discussion_content":"给你来个言，证明我还在","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629532326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2702193,"avatar":"https://static001.geekbang.org/account/avatar/00/29/3b/71/a690b71f.jpg","nickname":"zhengby","note":"","ucode":"5984647C8C8776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387174,"discussion_content":"就你是个聪明人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628038425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2675209,"avatar":"","nickname":"Geek_a90b9d","note":"","ucode":"4984DF7C016F3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383729,"discussion_content":"坚持到最后呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626225596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116397,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/ed/fe5242fe.jpg","nickname":"上善若水","note":"","ucode":"F4EC3FA1F27594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366929,"discussion_content":"快被劝退了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618219317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2440496,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3d/30/9e5e5d4d.jpg","nickname":"巴菲特不非","note":"","ucode":"9E2B911ED5BF08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353142,"discussion_content":"复制粘贴的公开笔记越来越少了，挺好的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615024448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2047825,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/3f/51/e4ac90a3.jpg","nickname":"nature calls","note":"","ucode":"2184AD76B6D61C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303772,"discussion_content":"有些东西没必要说出来。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599378204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109640,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/88/a890b41e.jpg","nickname":"chris","note":"","ucode":"6663E3E09457E3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209561,"discussion_content":"说明坚持就是胜利！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584636208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1650299,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ercJMgge7xt90pZCqtJZ0Qcxo81FVz662VfAN5k9JWSM4kEFA1y6Xia7e5l6XZdiaEBYYf2aYiaPNibdw/132","nickname":"Geek_st","note":"","ucode":"00C463FA081295","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169648,"discussion_content":"有什么意思？意思是什么？有Tm什么意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581639080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1189638,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","nickname":"色即是空","note":"","ucode":"46B8975ED087B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12229,"discussion_content":"说半截，有啥意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568506148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1097440,"avatar":"https://static001.geekbang.org/account/avatar/00/10/be/e0/8d299689.jpg","nickname":"wangKing","note":"","ucode":"9A0629528AB668","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1189638,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","nickname":"色即是空","note":"","ucode":"46B8975ED087B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77867,"discussion_content":"对啊 感觉阴阳怪气的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575949827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":12229,"ip_address":""},"score":77867,"extra":""},{"author":{"id":1721718,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/45/76/2b1354f6.jpg","nickname":"张亚运","note":"","ucode":"2D0C667E0D7B07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1097440,"avatar":"https://static001.geekbang.org/account/avatar/00/10/be/e0/8d299689.jpg","nickname":"wangKing","note":"","ucode":"9A0629528AB668","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79087,"discussion_content":"意思是越往后看的人越少了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576054521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77867,"ip_address":""},"score":79087,"extra":""},{"author":{"id":1721718,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/45/76/2b1354f6.jpg","nickname":"张亚运","note":"","ucode":"2D0C667E0D7B07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1097440,"avatar":"https://static001.geekbang.org/account/avatar/00/10/be/e0/8d299689.jpg","nickname":"wangKing","note":"","ucode":"9A0629528AB668","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79088,"discussion_content":"也说明大家都是几天热度，没人看到最后一节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576054541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77867,"ip_address":""},"score":79088,"extra":""}]}]},{"had_liked":false,"id":69051,"user_name":"朱凯","can_delete":false,"product_type":"c1","uid":1253253,"ip_address":"","ucode":"D18B53E4B92A96","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/85/639f3653.jpg","comment_is_top":false,"comment_ctime":1550651844,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"400982610372","product_id":100017301,"comment_content":"思路：f(n) = 2 * f(n-1) - 【n时刻点死掉的细胞数量】<br>而在【n时刻点死掉的细胞数量】就是【n-3时刻点新分裂的细胞数量】;【n-3时刻点新分裂的细胞数量】就是【n-4时刻点的细胞数总数】，即f(n-4)<br><br>故递推公式：f(n) = 2 * f(n-1) - f(n-4)<br>","like_count":93,"discussions":[{"author":{"id":1110494,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","nickname":"DullBird","note":"","ucode":"80E2FD5F9687CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5128,"discussion_content":"看了一圈，老铁分析的给力。\n补充一个如果是3h死了不分裂\nf(n) = 2 * [f(n-1) - f(n-4)]\nf(0)=1\nf(1)=2\nf(2)=4\nf(3)=6","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565970260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1197685,"avatar":"https://static001.geekbang.org/account/avatar/00/12/46/75/9f80409f.jpg","nickname":"追梦","note":"","ucode":"634A19055525B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318486,"discussion_content":"你这个比较清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603764105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1815185,"avatar":"","nickname":"松鼠鱼","note":"","ucode":"C0E87CCF71DB44","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268247,"discussion_content":"简明扼要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589737710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1528610,"avatar":"https://static001.geekbang.org/account/avatar/00/17/53/22/cce9a2e5.jpg","nickname":"naku","note":"","ucode":"B49EF5B5B38400","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219253,"discussion_content":"3小时死的时候分部分列这个我没从题目中看出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585747920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50623,"discussion_content":"其实这个也是错的，因为n时刻死掉的，并不是f(n-4)因为f(n-4)中部分早在fn之前死了，所以应该减去2^(n-3)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573740108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1504652,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/8c/82fb5890.jpg","nickname":"抱小星","note":"","ucode":"BA7B0DAFDA4AF5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":149157,"discussion_content":"你错了，因为之前死掉的已经在之前的n-5里面算过了，每一次都是对的。可以这么想，新生细胞是fnew（n），那么总细胞f（n）=fnew（n+1）\n然后 fnew（n）=fnew（n-1）+fnew（n-2）+fnew（n-3），因为只有前三个小时的细胞活着，会分裂。\n\n递推化简消去fnew可得，f（n）=2*f（n-1）-f（n-4），就是楼主的答案，是对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579738456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50623,"ip_address":""},"score":149157,"extra":""}]},{"author":{"id":1298190,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0G3cibDykvgGt6XrDzlXEqctkWFbvHg1V0WFicb7BjvnyOJlQKzOskKhE6qib0L0PK9iabrSwNotvEg/132","nickname":"六芸子轩","note":"","ucode":"DF56C53CCEDC55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29770,"discussion_content":"老铁nb，恍然大悟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570782900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233093,"user_name":"ɴɪᴋᴇʀ","can_delete":false,"product_type":"c1","uid":1616622,"ip_address":"","ucode":"DB7D92CBB5FD15","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","comment_is_top":false,"comment_ctime":1594215982,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"375256370734","product_id":100017301,"comment_content":"*****************************************************************************************<br>我看了一些评论，感觉都不太对，也看到了正确的答案，但是并没有讲清楚。所以来总结一下，让大家一起明白。<br><br>最开始为0的时刻，放入了1个细胞，然后1小时的时候，分裂变为了2个细胞，然后2小时的时候，分裂成了4个细胞，然后3小时的时候，分裂成了8个细胞，但是最早的那1个细胞死掉了，所以最终剩下7个细胞。列举时刻与个数的关系:<br><br>时刻: 0 1 2 3<br>个数: 1 2 4 7<br><br>将细胞分裂分为两个步骤，先分裂，后死亡。比如第四个小时的时候，从3小时的7个细胞分裂成14个，然后计算要死亡细胞的个数，直观上我们会认为，第1小时的时候2个细胞现在应该会死亡了，所以4小时的时候，细胞个数应该是7*2 - 2 = 12个，得到4小时之后的公式f(n) = f(n-1) * 2 - f(n-3)。<br><br>但这是错误的，因为第1小时的2个细胞，其中一个已经在第3小时的时候死掉了，因此第4小时的时候只会死掉1个细胞，正确的个数应该是 14 - 1 = 13.<br><br>经过这样分析，死掉的细胞数并不是前3小时的细胞总数f(n-3)，因为这里面包含n-3时刻新生的细胞和老细胞，很显然老细胞在n时刻之前就已经死完了。此时死掉的细胞数应该是n-3时刻新生的细胞数，而n-3时刻新生的细胞数正是前一时刻老细胞分裂而来的即f(n-4)，因此正确的计算公式是 f(n) = f(n-1) * 2 - f(n-4)。<br><br>用递归代码写出来就是<br>int F(int n){<br>    If(n&lt;0) return 0;<br>    If(n==0) return 1;<br>    If(n==1) return 2;<br>    If(n==2) return 4;<br>    If(n==3) return 7;<br>    return F(n-1) * 2 - F(n-4); <br>}<br><br>不知道你们看懂了没有，不过我是看懂了，这确实是正确答案。<br>***************************************************************************************","like_count":87,"discussions":[{"author":{"id":2713285,"avatar":"https://static001.geekbang.org/account/avatar/00/29/66/c5/755f50b3.jpg","nickname":"小小小孩","note":"","ucode":"389BAD9F8406D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389753,"discussion_content":"通俗易懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629422967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2137066,"avatar":"","nickname":"泡泡罗","note":"","ucode":"4FF91C51FD7364","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381351,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625020828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1985779,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/4c/f3/6d6def2a.jpg","nickname":"张斌辉","note":"","ucode":"D8D2E278F86F15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380996,"discussion_content":"把这条顶上去，这条才是正确答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624861442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2542913,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cd/41/c324a7de.jpg","nickname":"Martine","note":"","ucode":"A5D403AA8EC8E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374929,"discussion_content":"描述通俗易懂啊，这就是正确答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621413951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2439431,"avatar":"https://static001.geekbang.org/account/avatar/00/25/39/07/8fcac77a.jpg","nickname":"YouSec","note":"","ucode":"830D494EC91B77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372272,"discussion_content":"我自己直接用数学归纳推出来的也是减4，最开始我还以为自己推错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620263854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41197,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1542759314,"is_pvip":true,"discussion_count":7,"race_medal":0,"score":"177636418450","product_id":100017301,"comment_content":"思考题：<br>f0=1<br>f1=1+1=2<br>f2=1+1+2=4<br>f3=1+1+2+3-1=6 = f1 + f2<br>f4=1+1+2+3-1+5-1=10 = f2+f3<br>f5=1+1+2+4-1+5-1+8-2=16 = f3+f4<br>f（n）= f（n-1） + f（n-2）<br><br>与斐波那契数列的递归复杂度相同。","like_count":41,"discussions":[{"author":{"id":1909732,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLY0FFoux40Negib6LrE7EwT3T2BUbpYzOzUeiaiaXBmNGDGVgIZr5NeWBTEeCuALOg3ODtWa21bHMgg/132","nickname":"Geek_99ae14","note":"","ucode":"268852986A6B69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303624,"discussion_content":"如果是先分裂再死亡 f(3) = 7","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599316559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1174794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","nickname":"Juniper","note":"","ucode":"1BC24554034BD3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1909732,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLY0FFoux40Negib6LrE7EwT3T2BUbpYzOzUeiaiaXBmNGDGVgIZr5NeWBTEeCuALOg3ODtWa21bHMgg/132","nickname":"Geek_99ae14","note":"","ucode":"268852986A6B69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389948,"discussion_content":"所以说题目还不太严谨，没有说明先死亡还是先分裂。如果改成每小时分裂一次，分裂三次之后细胞死亡，那就是f(n) = 2 * f(n-1) - f(n-4)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629533334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303624,"ip_address":""},"score":389948,"extra":""}]},{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292601,"discussion_content":"通过一点一点画图，才发现这个才是正解。前面的乘 2 的方式都不严谨。但是，这种方式我推导出来的前提是 3 小时之后不分裂，直接嗝屁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595263158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1936370,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8b/f2/a7253cb0.jpg","nickname":"hpp","note":"","ucode":"3536E2B370ACBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275784,"discussion_content":"f5=1+1+2+4-1+5-1+8-2=16 = f3+f4 应该是f5=1+1+2+3-1+5-1+8-2=16 = f3+f4吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590762126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002945,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4d/c1/d1337337.jpg","nickname":"林墨染","note":"","ucode":"C90D508ABB9962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259798,"discussion_content":"这个太强了，感觉其他答案是看错题目了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588818496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269801,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/29/4564caba.jpg","nickname":"黄昏鹿场","note":"","ucode":"BC331B34E878CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225680,"discussion_content":"感觉评论去里只有这一个正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586392069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65350,"discussion_content":"计算，归纳，找规律，总结公式，强！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574997331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54548,"user_name":"菜鸡程序员","can_delete":false,"product_type":"c1","uid":1308074,"ip_address":"","ucode":"F1DFEC2343FE25","user_header":"https://static001.geekbang.org/account/avatar/00/13/f5/aa/5d520017.jpg","comment_is_top":false,"comment_ctime":1545897527,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"147574785591","product_id":100017301,"comment_content":"如果先分裂，经过画图发现 是1，2，4，7，13，24，44  发现应该是f(n)=2*f(n-1)-f(n-4) 置顶是错的","like_count":34,"discussions":[{"author":{"id":1000004,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/44/d3d67640.jpg","nickname":"Hills录","note":"","ucode":"779020947ACABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34295,"discussion_content":"1， 2，4，7（4*2-1），12（7*2-2），20（12*2-4），33（20*2-7）这样才对吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1571190806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238238,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/de/deaa9da1.jpg","nickname":"光脚造轮子","note":"","ucode":"7B1485B7045D15","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62598,"discussion_content":"f(n)=2*f(n-1)-f(n-3),n从3开始","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574854157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75999,"user_name":"张正龙","can_delete":false,"product_type":"c1","uid":1085069,"ip_address":"","ucode":"1A2C5CAB7D3231","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/8d/bc364ef4.jpg","comment_is_top":false,"comment_ctime":1552522744,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"138991476216","product_id":100017301,"comment_content":"我是来重温算法的，所以看起来还是通俗易懂的，回想当年大学学算法一个算法最少要在poj上做几十道题才能比较好理解，算法和数据结构真不是看俩便书或者文章就能理解的，一定要是要多练习的！而且还要明白一个事实，就算练习了，过段时间你也会忘记！所以我又来重温了！","like_count":32,"discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573804,"discussion_content":"坚持才能走得更远！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653647624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319540,"discussion_content":"那到底有啥用？都容易忘记了。仅仅是因为面试需要？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604046133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339008,"discussion_content":"同问，之前学习第一遍到动态规划时看到一些你的评论，现在回头再温习几遍，也能看到你的评论。。不过我也觉得很多内容只是让人了解。但我只需要的是能通过面试。。难道还是去刷题才是正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609473866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319540,"ip_address":""},"score":339008,"extra":""},{"author":{"id":2132421,"avatar":"https://static001.geekbang.org/account/avatar/00/20/89/c5/40a94ba6.jpg","nickname":"Jeff","note":"","ucode":"0D61F97C95E415","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580476,"discussion_content":"练脑子，拓宽解题思路行不行，思路可以从短视功利上移开，按你的思路归谬那还真是什么都没用。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658201739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319540,"ip_address":""},"score":580476,"extra":""}]}]},{"had_liked":false,"id":60716,"user_name":"咬尖月牙儿","can_delete":false,"product_type":"c1","uid":1325661,"ip_address":"","ucode":"A6223A6B713109","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/5d/c5dc789a.jpg","comment_is_top":false,"comment_ctime":1547536031,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"134691522207","product_id":100017301,"comment_content":"细胞分裂问题有个地方不解，1个细胞分裂之后不就变成2个新的细胞了，那么原来的细胞不就不存在了吗？那3小时后死亡怎么计算？","like_count":31,"discussions":[{"author":{"id":1539608,"avatar":"https://static001.geekbang.org/account/avatar/00/17/7e/18/c3ed4650.jpg","nickname":"Bayes","note":"","ucode":"2F83B2EFCE6B5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3875,"discussion_content":"你可能理解错题意了，1个细胞分裂出另一个细胞，而不是变成两个新的细胞。你那样理解不符合达尔文进化论，哈哈哈。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1564910408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1539608,"avatar":"https://static001.geekbang.org/account/avatar/00/17/7e/18/c3ed4650.jpg","nickname":"Bayes","note":"","ucode":"2F83B2EFCE6B5D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207993,"discussion_content":"那照你这样说，受精卵分裂后发育出来生成的双胞胎，一个是父亲或母亲一个是儿子或女儿咯","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584530608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3875,"ip_address":""},"score":207993,"extra":""}]},{"author":{"id":1402779,"avatar":"https://static001.geekbang.org/account/avatar/00/15/67/9b/8943ce41.jpg","nickname":"月夜星痕","note":"","ucode":"A33000D57FCD6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293444,"discussion_content":"我感觉 要是换成兔子产仔 可能更方便理解一点儿","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595549520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582546,"discussion_content":"我也是这么认为的，原细胞分裂后成为两个新的细胞，其生命周期为0。只是这种思考方式不符合出题人的意图。不是我们错了，是世界错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659501250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2193156,"avatar":"","nickname":"Geek_1b8580","note":"","ucode":"649033274EB0D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352905,"discussion_content":"分裂后一个是儿子，一个是自己，儿子的生命周期从零开始计时，而自己的生命周期计时继续，没有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614907611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1758307,"avatar":"","nickname":"韩方兴","note":"","ucode":"3C02DC65F3BB83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234920,"discussion_content":"说的是分裂啊  大哥，一分为二，跟指数爆炸一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587005814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010957,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6d/0d/e3fa096f.jpg","nickname":"拓","note":"","ucode":"AC1940ECC25436","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93441,"discussion_content":"同有此问题，怎么定义新细胞和老细胞。难道分裂后，总是有有一个的年龄是1，另一个是母细胞的年龄基础上+1？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576927389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215506,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8c/12/ccf8d2ca.jpg","nickname":"☆星月夜","note":"","ucode":"22BCA9807D0BD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1989,"discussion_content":"我也有这个问题，争哥麻烦解答下呗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563164456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1002401,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4b/a1/c2719a5a.jpg","nickname":"Panda🐟","note":"","ucode":"C6007A3192516A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1215506,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8c/12/ccf8d2ca.jpg","nickname":"☆星月夜","note":"","ucode":"22BCA9807D0BD4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83786,"discussion_content":"细胞分裂和动物产仔一样的，分裂后产生一个细胞宝宝，细胞妈妈老一岁","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1576463810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1989,"ip_address":""},"score":83786,"extra":""}]}]},{"had_liked":false,"id":42485,"user_name":"分清云淡","can_delete":false,"product_type":"c1","uid":1269873,"ip_address":"","ucode":"7045AE6BF72D31","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","comment_is_top":false,"comment_ctime":1542960947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"91737274163","product_id":100017301,"comment_content":"打卡，立flag的同学少了一个数量级都不止啊","like_count":22},{"had_liked":false,"id":47051,"user_name":"Laughing_Lz","can_delete":false,"product_type":"c1","uid":1251342,"ip_address":"","ucode":"7A7445E96F2978","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg","comment_is_top":false,"comment_ctime":1544026210,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"87443372130","product_id":100017301,"comment_content":"假设细胞到了第三个小时是先分裂完再死亡，递推公式为f(n) = 2f(n-1)-f(n-3)<br>假设细胞到了第三个小时是先死亡再其余的分裂，递推公式为f(n) = [f(n-1)-f(n-3)]*2","like_count":20,"discussions":[{"author":{"id":1298190,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0G3cibDykvgGt6XrDzlXEqctkWFbvHg1V0WFicb7BjvnyOJlQKzOskKhE6qib0L0PK9iabrSwNotvEg/132","nickname":"六芸子轩","note":"","ucode":"DF56C53CCEDC55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29767,"discussion_content":"可是这样不就是假设第(n-3)小时的细胞全部都是刚诞生的细胞且全部活到了第(n-1)小时么？从直觉上来讲这就是错的啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570782795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041584,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUmskEvtO5IBPmfuVVwmMTdG9iavOk4LuxXibiaEick4VoSE2Siav5ibL8lGgtKd0jmyd8ENkjxoLN7LnA/132","nickname":"shishao","note":"","ucode":"E6219D33CDBF58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2547,"discussion_content":"这个才是比较全面正确的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563767362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41682,"user_name":"komo0104","can_delete":false,"product_type":"c1","uid":1084059,"ip_address":"","ucode":"90C40C69F7CC93","user_header":"https://static001.geekbang.org/account/avatar/00/10/8a/9b/feb182d3.jpg","comment_is_top":false,"comment_ctime":1542822559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65967331999","product_id":100017301,"comment_content":"如果到了第三小时先分裂再死亡应该是f(n) = 2*f(n-1) - f(n-4)<br><br>—————————-<br> <br> public static int func(int hour){<br>   if(hour == 0) return 1;<br>   if(hour == 1) return 2;<br>   if(hour == 2) return 4;<br>   if(hour == 3) return 7; <br>   return 2*func(hour -1) - func(hour - 4);<br> }<br><br>————-<br>带入hour=4 <br>结果： 2 * func(3)-func(0)= 13","like_count":15},{"had_liked":false,"id":49429,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544685870,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"61674228014","product_id":100017301,"comment_content":"递归树分析递归算法的时间复杂度<br><br>把递归树画出来，计算每一层和每一层的一个耗时情况，求和<br>思考题：拒绝思考","like_count":14,"discussions":[{"author":{"id":1189638,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","nickname":"色即是空","note":"","ucode":"46B8975ED087B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12234,"discussion_content":"再来一遍，动动脑，好像也没有那么难！\n评论里好像有不同的声音，\n就这个递推公式f(n)=2f(n-1)-f(n-3)，时间复杂度3^n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568506788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1235504,"avatar":"https://static001.geekbang.org/account/avatar/00/12/da/30/f636914e.jpg","nickname":"广进","note":"","ucode":"A9A3FA76024577","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1189638,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","nickname":"色即是空","note":"","ucode":"46B8975ED087B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46728,"discussion_content":"大半年过去了,这是二刷了嘛,哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573198814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":12234,"ip_address":""},"score":46728,"extra":""},{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1189638,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","nickname":"色即是空","note":"","ucode":"46B8975ED087B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165973,"discussion_content":"再来一遍你还是做错了。。。应该是f(n) = 2f(n - 1) - f(n - 4)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581343749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":12234,"ip_address":""},"score":165973,"extra":""},{"author":{"id":1607864,"avatar":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","nickname":"陈琦","note":"","ucode":"48F974137EF0BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1189638,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","nickname":"色即是空","note":"","ucode":"46B8975ED087B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297136,"discussion_content":"为什么时间复杂度是这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596784647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":12234,"ip_address":""},"score":297136,"extra":""}]}]},{"had_liked":false,"id":48133,"user_name":"小罗是坏蛋","can_delete":false,"product_type":"c1","uid":1246573,"ip_address":"","ucode":"3D64B4F2F00FD8","user_header":"https://static001.geekbang.org/account/avatar/00/13/05/6d/ddc2abd0.jpg","comment_is_top":false,"comment_ctime":1544365216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48789005472","product_id":100017301,"comment_content":"如果第三个小时不分裂，死亡：<br>f(n)=f(n-1)+f(n-2)<br>第三个小时分裂之后再死亡：<br>有两个公式表达<br>f(n)=f(n-1)+f(n-2)+f(n-3)<br><br>之后再用斐波那契数列中老师的树的分析方式分析，得到结果<br>第三个小时不分裂，就死亡，与斐波那契数列结果相同<br>第三个小时先分裂再死亡，时间复杂度在<br>O(3^n&#47;3）至O(3^n)之间","like_count":11},{"had_liked":false,"id":104756,"user_name":"其","can_delete":false,"product_type":"c1","uid":1380391,"ip_address":"","ucode":"3918C2950430E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/10/27/3abd8f36.jpg","comment_is_top":false,"comment_ctime":1560828049,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40215533713","product_id":100017301,"comment_content":"说下递推公式吧，2*f(n-1)是肯定的，问题只出在后面的减数上，个人理解减数应该是第n-3次新生的细胞数，也就是第n-3次相比于第n-4次的增量，也就是f(n-3)-f(n-4)。<br>总结一下，递推公式应该为：<br>f(n) = f(n-1)*2 - (f(n-3)-f(n-4))<br>f(n) = f(n-1)*2 - f(n-3) + f(n-4)<br>初始条件为f(-1) = 0，f(0) = 1","like_count":9,"discussions":[{"author":{"id":2413294,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqfEZles2ojt0PC6Spic4zRRjWvS90KKqjmMib9kNOd6uOPicD6sbQudgs3DSkWQ2lKSickCvUSAsibHpg/132","nickname":"Geek_9ae5e2","note":"","ucode":"AA3FB86E372F6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344700,"discussion_content":"f(n-3)-f(n-4)应该是 n-3这天新增的,减去死去的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611562460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250140,"user_name":"Jeff","can_delete":false,"product_type":"c1","uid":1344632,"ip_address":"","ucode":"3E22C18FF4986F","user_header":"https://static001.geekbang.org/account/avatar/00/14/84/78/c246f6d5.jpg","comment_is_top":false,"comment_ctime":1600949705,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31665720777","product_id":100017301,"comment_content":"这个问题如果改一下，争议就会小了。假设有一种动物，只能存活 3 个小时，开始时只有 1 只，每隔 1 小时可以生产一只新的。求 n 小时后，共有多少只该动物存活。<br><br>假设先生完，再死。<br><br>开始， 第 0 小时， f(0) = 1;<br>第 1 小时， 仅 1 只，可生产 1 只，在原基础上 + 1，没有死亡，f(1) = 2;<br>第 2 小时，有两只，可再生产 2 只，没有死亡，f(2) = 4;<br>第 3 小时，有 4 只，可在生产 4 只，死亡 1 只（第 0 小时那只死了），f(3)=7;<br>第 4 小时，有7只，可在生产 7 只，死亡 1 只（第 1 小时新增的那只死了）， f(4) = 13;<br>第 5 小时，有 13 只，可再生产 13 只，死亡个数为第 2 小时时新增的个数（即 f（k-3）- f(k-4)), f(5) = 24.<br>第 k 层的个数，在第 k-1 层个数基础上，新增 k-1，死亡 k-3 层新增的个数（即 f(k-3) - f(k-4))。 <br>f(k) = 2 f(k-1) - [f(k-3) - f(k-4)] (k&gt;=4). <br><br>时间复杂度是和斐波那契数列一样， O(2^n) 级别。","like_count":7,"discussions":[{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335401,"discussion_content":"细胞分裂没有存活的问题，分裂后就不存在了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608183588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335400,"discussion_content":"我觉得你用动物更贴切一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608183568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41337,"user_name":"沉睡的木木夕","can_delete":false,"product_type":"c1","uid":1036362,"ip_address":"","ucode":"2C6B23B34C44E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/4a/7e3d158d.jpg","comment_is_top":false,"comment_ctime":1542766569,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"31607537641","product_id":100017301,"comment_content":"有几点问题不懂<br>1.实战二：分析斐波那契数列的时间复杂度 一节提到 <br>“f(n) 分解为 f(n-1) 和 f(n-2)，每次数据规模都是 -1 或者 -2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 -1，那最长路径大约就是 n；如果每次都是 -2，那最短路径大约就是 n&#47;2。”数据规模都是-1，-2 这怎么理解？每次都是-1，最长路径大约就是n  这又是怎么理解的？ <br>2.实战3中提到<br>“第一层分解有 n 次交换操作，第二层有 n 个节点，每个节点分解需要 n-1 次交换，所以第二层总的交换次数是 n*(n-1)。第三层有 n*(n-1) 个节点，每个节点分解需要 n-2 次交换，所以第三层总的交换次数是 n*(n-1)*(n-2)。”<br>交换操作的次数是怎么的出来的？<br>这对于我来讲就好比，数学老师讲了一堆看似简单的东西（有同学基础不好），最后老师最后落笔：所以1+1=2，但我还是一脸懵逼","like_count":7,"discussions":[{"author":{"id":1174510,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJmcPTvjtSbhBNic4wb61Pj77nIHcLG64MnAXicsHBrMWvjCQPoiaHTtYmbnlVSkSWZEnN2QlicekqLhg/132","nickname":"zzh","note":"","ucode":"0FC6BD729E5801","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":90939,"discussion_content":"我也觉得 应该是 n-1， k-1 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576803732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1174510,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJmcPTvjtSbhBNic4wb61Pj77nIHcLG64MnAXicsHBrMWvjCQPoiaHTtYmbnlVSkSWZEnN2QlicekqLhg/132","nickname":"zzh","note":"","ucode":"0FC6BD729E5801","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267097,"discussion_content":"这里需要明确求全排列有多少种可能和求全排列时间复杂度的区别。\n全排列问题是从第一个数字起，每个数分别与它后面的数字交换。\n我们可以认为每一个交换的时间复杂度是 O(1)，那么从 n 分解到 n 个 f(n-1) 需要进行 n 次交换，时间复杂度是 n。\nf(n-1) 分解为 (n-1)*f(n-2) 需要进行 n-1次交换，我们有 n 个 f(n-1) 问题，因此时间复杂度为 n*(n-1)。\n以此类推。\n最后的总时间复杂度是各层分解次数相加。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589600830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":90939,"ip_address":""},"score":267097,"extra":""}]},{"author":{"id":1615539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6LXcIqb5K48nia8d4zmdsD1M9AZeyXoGrLzX5xvqfN0fqXOsYKUWLbZvZ8TtJCXWmYbCkCXg93dQ/132","nickname":"漏脚脖","note":"","ucode":"214AE52EC201E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4196,"discussion_content":"我也没懂，感觉第二层是n-1次，为什么乘以个n呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565223756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1615539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6LXcIqb5K48nia8d4zmdsD1M9AZeyXoGrLzX5xvqfN0fqXOsYKUWLbZvZ8TtJCXWmYbCkCXg93dQ/132","nickname":"漏脚脖","note":"","ucode":"214AE52EC201E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267098,"discussion_content":"这里需要明确求全排列有多少种可能和求全排列时间复杂度的区别。\n全排列问题是从第一个数字起，每个数分别与它后面的数字交换。\n我们可以认为每一个交换的时间复杂度是 O(1)，那么从 n 分解到 n 个 f(n-1) 需要进行 n 次交换，时间复杂度是 n。\nf(n-1) 分解为 (n-1)*f(n-2) 需要进行 n-1次交换，我们有 n 个 f(n-1) 问题，因此时间复杂度为 n*(n-1)。\n以此类推。\n最后的总时间复杂度是各层分解次数相加。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589600837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4196,"ip_address":""},"score":267098,"extra":""}]}]},{"had_liked":false,"id":146659,"user_name":"If_","can_delete":false,"product_type":"c1","uid":1270862,"ip_address":"","ucode":"EBE721D0A120A4","user_header":"https://static001.geekbang.org/account/avatar/00/13/64/4e/0b9afa5e.jpg","comment_is_top":false,"comment_ctime":1572596333,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27342400109","product_id":100017301,"comment_content":"我就是那种原来都不甚清楚，很大部分都不了解，前边专栏看了四五六七遍的，刚刚来这的那种同学。走那么快干嘛，走稳点不好吗？","like_count":6},{"had_liked":false,"id":46999,"user_name":"不成熟的萌","can_delete":false,"product_type":"c1","uid":1244537,"ip_address":"","ucode":"4F5059446D062D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/79/d42c4c68.jpg","comment_is_top":false,"comment_ctime":1544016746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27313820522","product_id":100017301,"comment_content":"假设细胞3小时候先分裂再死亡。<br>life3 表示还能活3个小时， life2表示还能活2个小时，life1表示还能活1个小时<br>假设在第x时刻，存活细胞数为life1 = x, life2= y, life3 = z个，总细胞sum(x)<br>在第x + 1时刻，此时刻的life1细胞均来自上一时刻的life2细胞。此时刻life2细胞均来自上一时刻的life3细胞。上一时刻life1细胞死亡后，会分列均等数量life3细胞，因此上一时刻所有细胞均会分裂，所以此时刻life3细胞等于上一时刻所有细胞数。<br>所以x + 1时刻，life1 = y, life2 = z, life3 = sum(x), sum(x+1) = y + z  + sum(x)<br>x + 2, life1 = z, life2 = sum(x), life3 = sum(x + 1), sum(x+2) = z + sum(x) + sum(x + 1)<br>x + 3, life1 = sum(x), life2 = sum(x + 1), life3 = sum(x + 2) , sum(x + 3) = sum(x) + sum(x + 1) + sum(x + 2)<br>因此递推式为<br>sum(x) = sum(x - 1) + sum(x - 2) + sum(x - 3)<br>1 sum函数<br>3 sum函数<br>9 sum函数<br>所以是3的0次方+3的1次方+3的二次方，为几何级数，算法复杂度为O(3的n次方)","like_count":6},{"had_liked":false,"id":41350,"user_name":"ppingfann","can_delete":false,"product_type":"c1","uid":1242999,"ip_address":"","ucode":"38DE7D2F6D22E4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo435IStLENgI45dWOow9gPDh8RcqvuCOLp30XqLJK3wqmwO7QKRLx8sMg9eucMKnJdjwickrAQMBw/132","comment_is_top":false,"comment_ctime":1542767577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27312571353","product_id":100017301,"comment_content":"老师，有几个问题不明白：<br>1. 求归并排序的时间复杂度中<br>满二叉树的高度计算公式中的n指的是树中的节点的总个数，而归并排序中的n指的却是叶子节点的个数。所以归并排序中树的高度，我计算出来的是h=log2^2n-1。<br>2. 实战二中<br>“f(n) 分解为 f(n-1) 和 f(n-2)，每次数据规模都是 -1 或者 -2，叶子节点的数据规模是 1 或者 2。“<br>叶子节点为1或者2都不能再往下分叉了，所以，我计算出来的最长路径是n-2。举个具体的例子：n=5时，最长路径为3。<br>我计算出来的最短路径依据n的不同还会不同，<br>具体的例子：n=5时，最短路径为2，n=6时，最短路径依然为2。<br><br>是我理解的有偏差吗？请老师指点。","like_count":6},{"had_liked":false,"id":121583,"user_name":"月迷津渡","can_delete":false,"product_type":"c1","uid":1264111,"ip_address":"","ucode":"2B18B2FE3DAC3B","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/ef/02401473.jpg","comment_is_top":false,"comment_ctime":1565162180,"is_pvip":false,"replies":[{"id":"44724","content":"那就先放一放，抽空再看吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565218613,"ip_address":"","comment_id":121583,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23039998660","product_id":100017301,"comment_content":"第三个例子的排列组合代码相当晦涩啊，我跟了好几遍还是没能完全理解。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461862,"discussion_content":"那就先放一放，抽空再看吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565218613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583499,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/8b/3629c0f8.jpg","nickname":"游山行人","note":"","ucode":"E559BD0A3C6484","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221733,"discussion_content":"其实作者写的简洁了点，你可以把每一层都详细写出来就理解了，我原来也不理解，把每一层都写出来就理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586052839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233091,"user_name":"ɴɪᴋᴇʀ","can_delete":false,"product_type":"c1","uid":1616622,"ip_address":"","ucode":"DB7D92CBB5FD15","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","comment_is_top":false,"comment_ctime":1594215792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18774084976","product_id":100017301,"comment_content":"我看了一些评论，感觉都不太对，也看到了正确的答案，但是并没有讲清楚。所以来总结一下，让大家一起明白。<br><br>最开始为0的时刻，放入了1个细胞，然后1小时的时候，分裂变为了2个细胞，然后2小时的时候，分裂成了4个细胞，然后3小时的时候，分裂成了8个细胞，但是最早的那1个细胞死掉了，所以最终剩下7个细胞。列举时刻与个数的关系:<br><br>时刻: 0 1 2 3<br>个数: 1 2 4 7<br><br>将细胞分裂分为两个步骤，先分裂，后死亡。比如第四个小时的时候，从3小时的7个细胞分裂成14个，然后计算要死亡细胞的个数，直观上我们会认为，第1小时的时候两个细胞现在应该会死亡了，所以4小时的时候，细胞个数应该是7*2 - 2 = 14个，得到4小时之后的公式f(n) = f(n-1) * - f(n-3)。<br><br>但这是错误的，因为第1小时的2个细胞，其中一个已经在第3小时的时候死掉了，因此第4小时的时候只会死掉1个细胞，正确的个数应该是 14 - 1 = 13.<br><br>经过这样分析，死掉的细胞数并不是前3小时的细胞总数f(n-3)，因为这里面包含n-3时刻新生的细胞和老细胞，很显然老细胞在n时刻之前就已经死完了。此时死掉的细胞数应该是n-3时刻新生的细胞数，而n-3时刻新生的细胞数正是前一时刻老细胞分裂而来的即f(n-4)，因此正确的计算公式是 f(n) = f(n-1) * 2 - f(n-4)。<br><br>用递归代码写出来就是：<br>int F(int n){<br>    If(n&lt;0) return 0;<br>    If(n==0) return 1;<br>    If(n==1) return 2;<br>    If(n==2) return 4;<br>    If(n==3) return 7;<br>    return F(n-1) * 2 - F(n-4); <br>}<br><br>不知道你们看懂了没有，不过我是看懂了，这确实是正确答案。","like_count":4},{"had_liked":false,"id":201411,"user_name":"naku","can_delete":false,"product_type":"c1","uid":1528610,"ip_address":"","ucode":"B49EF5B5B38400","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/22/cce9a2e5.jpg","comment_is_top":false,"comment_ctime":1585782778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18765651962","product_id":100017301,"comment_content":"本来抱着看答案的想法看评论，结果发现有好几个答案，我是也没说谁的对，我看了评论的一些解答后我得出了另一个答案。。。<br>特来分享一下，让后面的人多个参考<br>要说明的是<br>1、1小时分裂1次，那么3小时分裂3次，因此说第3小时死了没分裂的我是不赞同的，我觉得是先分裂然后再死。因此3小时处该细胞分裂数目+1， 死了数目减一不会造成数目变化<br><br>核心思路：<br>f(n)是由f(n-1)分裂得到的 2*f(n-1),这个并不是直接的结果，因为还有死亡的，这里是评论中的分歧的地方，又说是f(n-3)的，也有说是f(n-4)的，我觉得是(f(n-3)-(fn-4))什么意思呢，<br>f(n)处要死的应该是刚刚好在统计f(n)时活了3个小时的,f(n-3)是包含了活了4,5个小时的细胞的，活了3个小时的细胞应该是3小时前新生成的细胞,也就是f(n-3)-f(n-4)<br><br>小时数  个数<br>0    1<br>1    2<br>2    4<br>3    f(2)*2-f(0)=7<br>4    f(3)*2-(f(1)-f(0))=13<br>5    f(4)*2-(f(2)-f(1))=25<br>因此我觉得递推公式就是 f(n)=f(n-1)*2 - (f(n-3)-f(n-4))<br>时间复杂度的分析：<br>如果不考虑用动态规划的话，求解f(n)会同时画出树状图会发现第1层是1个节点，第二层是3个，第3层是9个，刚好是3的等比数列，所以时间复杂度是3^n","like_count":4},{"had_liked":false,"id":54543,"user_name":"小新村小学扛霸子","can_delete":false,"product_type":"c1","uid":1250309,"ip_address":"","ucode":"BECFAB70A68C9F","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/05/5f46ffa6.jpg","comment_is_top":false,"comment_ctime":1545896521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18725765705","product_id":100017301,"comment_content":"感觉有点难，实战分析那都没怎么看懂。","like_count":4},{"had_liked":false,"id":51422,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1545181734,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18725050918","product_id":100017301,"comment_content":"课后题目得时间复杂度为 2^(N+1)<br>树得最后三层减去树得前边的层数。即为时间复杂度。。","like_count":4},{"had_liked":false,"id":41332,"user_name":"小林子","can_delete":false,"product_type":"c1","uid":1145383,"ip_address":"","ucode":"058C95ECBFE422","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/27/77ca2bc2.jpg","comment_is_top":false,"comment_ctime":1542766127,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18722635311","product_id":100017301,"comment_content":"f(0) =  1<br>f(1) = 2<br>f(2) = 4<br>f(3) = 8<br>f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)","like_count":4},{"had_liked":false,"id":204415,"user_name":"流水人家","can_delete":false,"product_type":"c1","uid":1479082,"ip_address":"","ucode":"9BB4367CAAF781","user_header":"https://static001.geekbang.org/account/avatar/00/16/91/aa/374cc963.jpg","comment_is_top":false,"comment_ctime":1586397718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14471299606","product_id":100017301,"comment_content":"假设细胞不会死亡，那第n个小时的细胞总数满足 f(n)=2f(n-1) ,现在细胞的存活周期是3个小时，也就是说每过一个小时要死亡得细胞个数是3个小时前新增的细胞个数，也就是f(n-3)-f(n-4)，又因为f(n-3)=2f(n-4),所以每过1小时死亡的细胞个数就是f(n-4),所以 第n个小时的细胞总数满足 f(n)=2f(n-1) -f(n-4),处理好边界就可以实现代码了，时间复杂度，上班不好摸鱼，后续补上","like_count":3},{"had_liked":false,"id":76983,"user_name":"嗯嗯","can_delete":false,"product_type":"c1","uid":1400407,"ip_address":"","ucode":"6A96950ABFA8CA","user_header":"https://static001.geekbang.org/account/avatar/00/15/5e/57/fb18c46a.jpg","comment_is_top":false,"comment_ctime":1552793722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14437695610","product_id":100017301,"comment_content":"看完这章以后我感觉我要重头再来一遍😅，忘了挺多的","like_count":3},{"had_liked":false,"id":166288,"user_name":"寒溪","can_delete":false,"product_type":"c1","uid":1001970,"ip_address":"","ucode":"67B9F1A1C15A20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/f2/25cfa472.jpg","comment_is_top":false,"comment_ctime":1577432864,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"10167367456","product_id":100017301,"comment_content":"按照我的理解细胞分裂分裂后分为母子个体，母细胞3个小时后死亡，子细胞3+1小时后死亡。<br>所以按照单一职责原则来拆分，可以拆分成分裂(division)和死亡(die)两个函数.<br>f(n)=division(n)-die(n);<br>division(n)=2divsion(n-1) n==1 =&gt; 1<br>die(n) = division(n-3) n&lt;3 =&gt; 0<br><br>java实现<br><br>divsion等于n这个时间段有多少细胞存活。<br>翻译成代码<br>public class CellDivision {<br><br><br>    public int count(int n){<br><br>        return division(n) - die(n);<br><br>    }<br><br><br>    &#47;**<br>     * n = 第几个小时<br>     *<br>     * @param n<br>     * @return 多少细胞<br>     *&#47;<br>    public int division(int n){<br>        if(n==0){<br>            return 1;<br>        }<br>        return 2*division(n-1);<br>    }<br><br>    public int die(int n){<br>        if(n &lt; 3){<br>            return 0;<br>        }<br><br>        return division(n-3);<br>    }<br><br><br>    @Test<br>    public void test(){<br>        System.out.println(count(3));<br>    }<br><br>}<br>","like_count":2},{"had_liked":false,"id":159646,"user_name":"Swing","can_delete":false,"product_type":"c1","uid":1330065,"ip_address":"","ucode":"55FCA9ECEFBBEB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","comment_is_top":false,"comment_ctime":1575713227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10165647819","product_id":100017301,"comment_content":"第n小时后 分裂+死亡后的 细胞总数 ：<br>f(n) = 原有个数 + 新生个数 - 应死亡个数( --》即 n-3 那次 新生的个数 ，即 f(n-4) ) <br>故 公式应该是下面这样：<br>f(n) = f(n-1) + f(n-1) - f(n-4) = 2f(n-1)-f(n-4)     (区间 n &gt;= 4)<br>可以，枚举验证：<br>f(0) = 1 ; <br>f(1) = 1+1-0 = 2;<br>f(2) = 2+2-0 = 4;<br>f(3) = 4+4-1 = 7;<br>f(4) = 7+7-1 = 13;<br>f(5) = 26 - 2 = 24;<br>f(6) = 48 - 4 = 44;<br>如下：<br>1  2  4  7  13  24  44 ","like_count":2},{"had_liked":false,"id":112845,"user_name":"小鸟淫太","can_delete":false,"product_type":"c1","uid":1247186,"ip_address":"","ucode":"AC44F552DDF93E","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/d2/d7a200d5.jpg","comment_is_top":false,"comment_ctime":1562831115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10152765707","product_id":100017301,"comment_content":"f(n) = 2f(n - 1) - f(n - 4)","like_count":2},{"had_liked":false,"id":106183,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1561197388,"is_pvip":false,"replies":[{"id":"38652","content":"每次分解操作（比如：f(n)分解为n个f(n-1)来计算的时候）都有成本的，要把每次分解操作的成本都累加起来。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561420293,"ip_address":"","comment_id":106183,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10151131980","product_id":100017301,"comment_content":"实战三中 为什么最后的复杂度是所有层加起来？第一层推导为第二层,逐渐推导为最后一层,所以复杂度应该是最后一层啊？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454993,"discussion_content":"每次分解操作（比如：f(n)分解为n个f(n-1)来计算的时候）都有成本的，要把每次分解操作的成本都累加起来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561420293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103269,"user_name":"Geek_cf29f0","can_delete":false,"product_type":"c1","uid":1337800,"ip_address":"","ucode":"F635968AE2656C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bWpFdAQwTzBg70ib6QTQomfQV3Ak1CFQPXun20w2Kz3PCLtsV75nNrqBuDEvehtlCoTkyT3icNWnvO7nPMc1RFfg/132","comment_is_top":false,"comment_ctime":1560407049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150341641","product_id":100017301,"comment_content":"递推公式：<br>f(0)=1<br>f(1)=2<br>f(2)=4<br>f(3)=8<br>f(4)=(f(3)-1)*2=14<br>...<br>f(n)=[f(n-1)-(f(n-4)-f(n-5))]*2，即上一个小时的总数-（n-4）小时新增的数，(n-4)小时新增个数=f(n-4)-f(n-5)<br>根据上述递推，构建递归树得到时间复杂度为o(n~3)，n的三次方","like_count":2},{"had_liked":false,"id":88528,"user_name":"E.L","can_delete":false,"product_type":"c1","uid":1127780,"ip_address":"","ucode":"A49725D222257A","user_header":"https://static001.geekbang.org/account/avatar/00/11/35/64/af491f09.jpg","comment_is_top":false,"comment_ctime":1555936302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10145870894","product_id":100017301,"comment_content":"点赞第一的留言感觉不太对，老师能不能确认一下标准答案？<br>我把前5次的情况列了一下，感觉应该是f(n) = f(n-1)*2 - f(n-4)。","like_count":2},{"had_liked":false,"id":53245,"user_name":"摸爬滚打三十年","can_delete":false,"product_type":"c1","uid":1240241,"ip_address":"","ucode":"764A7F920EC304","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/b1/d790b927.jpg","comment_is_top":false,"comment_ctime":1545618986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10135553578","product_id":100017301,"comment_content":"对于细胞问题，假设开始时有1个细胞：对应于时刻有 f(0) = 1， f(1) = 3 * f(0), f(2) = 3 * f(1), f(3) = 3 * f(2) - f(0)  依次类推 我们可以得出递推公式 f(n) = 3 * f(n-1) - f(n-3); 所以对于求解f(n)的问题转化为求解f(n-1) 和f(n-3)的子问题 ，我们得知 f(n）的递归书 对于 每层的计算次数 1 ，2 ，4   最高是 n层  最低层数 是 n-3 所以 递推实现 的 复杂度 为  2的n次方","like_count":2},{"had_liked":false,"id":46319,"user_name":"最摇摆的鱼","can_delete":false,"product_type":"c1","uid":1255574,"ip_address":"","ucode":"DA19F4C4224719","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqgVXa8DyW0YsrdYtPNMOdGH6hfdwfjwyBPRyoc9yuS4Ml18l0kApOoOKwYkF6NlDPYpX1bVEWomw/132","comment_is_top":false,"comment_ctime":1543899767,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10133834359","product_id":100017301,"comment_content":"细胞分裂后算是新细胞吗？这个生命周期为3小时有什么用？难道第一次分裂完成后的两个细胞，一个年龄为1小时，一个年龄为0小时？","like_count":2},{"had_liked":false,"id":41427,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1542779351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10132713943","product_id":100017301,"comment_content":"一脸的懵逼，越来越看不懂了。估计后面的图看不下去了。","like_count":2},{"had_liked":false,"id":316248,"user_name":"兔嘟嘟","can_delete":false,"product_type":"c1","uid":2028811,"ip_address":"","ucode":"5A9042B4C7670C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","comment_is_top":false,"comment_ctime":1634220601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5929187897","product_id":100017301,"comment_content":"评论区有点只有理论，没有实践的味道，绕来绕去大家都晕了<br>1. 题面：有一个细胞，它每个小时分裂一个细胞，每个细胞从下个小时开始，也分裂细胞。一个细胞在分裂3次后，立刻死亡。如果是第1个小时出生的细胞，那么就是第4个小时中死亡，问第n个小时后的细胞总数。<br>2. 样例：n=1, answer=2; n=4, answer=13<br>3. 思路：求第n个小时的细胞总数，就等价于求第n+1个小时出生的细胞数。第i个小时出生的细胞数，等于第i-1、i-2、i-3个小时出生的细胞数之和，是它们分裂产生了第i个小时的细胞，再往前的都死了。<br>4. 代码：<br>func dfs(n int) int {<br>\tif n &lt;= 1 {<br>\t\treturn 1<br>\t}<br>\tif n == 2 {<br>\t\treturn 2<br>\t}<br>\treturn dfs(n-1) + dfs(n-2) + dfs(n-3)<br>}<br>dfs(n+1)","like_count":1},{"had_liked":false,"id":218189,"user_name":"松鼠鱼","can_delete":false,"product_type":"c1","uid":1815185,"ip_address":"","ucode":"C0E87CCF71DB44","user_header":"","comment_is_top":false,"comment_ctime":1589732427,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5884699723","product_id":100017301,"comment_content":"斐波那契数列的时间复杂度分析并不严谨，因为随着层数的增加，每层节点个数是个先增多后减少的过程，不能简单地用2^n来表示。","like_count":1},{"had_liked":false,"id":102602,"user_name":"阿信","can_delete":false,"product_type":"c1","uid":1389604,"ip_address":"","ucode":"50616ED68A5B40","user_header":"https://static001.geekbang.org/account/avatar/00/15/34/24/34ca1d23.jpg","comment_is_top":false,"comment_ctime":1560261830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855229126","product_id":100017301,"comment_content":"n小时后的细胞数=n-1小时后的细胞数+n-1小时后的细胞总分裂数-当前死亡的细胞数，得出：<br>f(n)=2*f(n-1)-f(n-3)<br>","like_count":1},{"had_liked":false,"id":91025,"user_name":"小邓","can_delete":false,"product_type":"c1","uid":1474505,"ip_address":"","ucode":"1E903D5622D39F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/c9/40c609ee.jpg","comment_is_top":false,"comment_ctime":1556804499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851771795","product_id":100017301,"comment_content":"朱凯同学的留言写得好精炼！","like_count":1},{"had_liked":false,"id":90204,"user_name":"GL","can_delete":false,"product_type":"c1","uid":1125950,"ip_address":"","ucode":"EB14AF83184E85","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/3e/5ae876fd.jpg","comment_is_top":false,"comment_ctime":1556447156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851414452","product_id":100017301,"comment_content":"&#47;**<br>     * 每个细胞的状态分为4个状态，a刚诞生，b诞生1小时(a存在1小时后)，c诞生2小时（b存在1小时后）,d死亡（诞生3小时，c存在一小时后）;<br>     * 活着的细胞总数就是a、b、c三个状态的细胞总和。<br>     *&#47;<br>    public static int active(int n) {<br>        return a(n) + b(n) + c(n);<br>    }<br><br>    &#47;**<br>     * 刚诞生<br>     *&#47;<br>    static int a(int n) {<br>        if (n == 0) {<br>            return 1;<br>        }<br>        return a(n - 1) + b(n - 1) + c(n - 1);<br>    }<br><br>    &#47;**<br>     * 诞生1小时<br>     *&#47;<br>    static int b(int n) {<br>        if (n == 0) {<br>            return 0;<br>        }<br>        return a(n - 1);<br>    }<br><br>    &#47;**<br>     * 诞生2小时<br>     *&#47;<br>    static int c(int n) {<br>        if (n == 0 || n == 1) {<br>            return 0;<br>        } &#47;&#47;前两小时还没生成<br>        return b(n - 1);<br>    }","like_count":1},{"had_liked":false,"id":82389,"user_name":"LukeLiu","can_delete":false,"product_type":"c1","uid":1299549,"ip_address":"","ucode":"F8E90013B56840","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/5d/1bc54e2f.jpg","comment_is_top":false,"comment_ctime":1554199860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849167156","product_id":100017301,"comment_content":"假设数组中存储的是 1，2， 3...n。<br>        <br>f(1,2,...n) = {最后一位是 1, f(n-1)}+…+{最后一位是n,f(n-1)}<br>请问老师，在这个递归表达式中，只需要最后一位依次出现数组所有元素就行了，为什么在代码中是从第一个元素开始依次将该元素与第k-1个元素交换？","like_count":1},{"had_liked":false,"id":81595,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1553957517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848924813","product_id":100017301,"comment_content":"指数级","like_count":1},{"had_liked":false,"id":81508,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1553930426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848897722","product_id":100017301,"comment_content":"第n个小时的存活细胞数=一小时前的存活细胞数*2(因为分裂)-三小时前的存活细胞数(因为寿命到了)<br>所以f(n)=f(n-1)*2-f(n-3)<br>想了一个小时想出来的，感觉很爽","like_count":1},{"had_liked":false,"id":72683,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551692105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846659401","product_id":100017301,"comment_content":"打卡，有点难度了","like_count":1},{"had_liked":false,"id":41599,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1542810687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5837777983","product_id":100017301,"comment_content":"每一小时其实就是等比数列的第n项，死亡的话，正好是斐波拉契数列，不死亡就是公比是2，首项是1的等比数列。f(n)＝s(n)-s(n-2)","like_count":1},{"had_liked":false,"id":359059,"user_name":"Wilson","can_delete":false,"product_type":"c1","uid":1007140,"ip_address":"江苏","ucode":"3ADBE962C67B8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/24/040855d3.jpg","comment_is_top":false,"comment_ctime":1665211899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665211899","product_id":100017301,"comment_content":"老师，【归并排序画成递归树】的图，只是分解图。应该换成第12章中分解和合并的图，并标注是合并过程耗时的图。本章放的只是分解图，有点误导：是分解过程耗时，统计的时间为分解时间复杂度。","like_count":0},{"had_liked":false,"id":358966,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1665105830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665105830","product_id":100017301,"comment_content":"总结：<br>1. 分析时间复杂度的方法<br><br>1. 是指数级的时间复杂度","like_count":0},{"had_liked":false,"id":357124,"user_name":"creasylai19","can_delete":false,"product_type":"c1","uid":1128420,"ip_address":"广东","ucode":"F9B04060FCFD3F","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/e4/5d7a32c6.jpg","comment_is_top":false,"comment_ctime":1662976364,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1662976364","product_id":100017301,"comment_content":"我把这一节内容概括为把递归过程画出来，然后根据图形来分析复杂度，这样的分析简单很多，哈","like_count":0},{"had_liked":false,"id":354657,"user_name":"項霸霸","can_delete":false,"product_type":"c1","uid":1322122,"ip_address":"湖北","ucode":"34F3D2CEA4EE6C","user_header":"https://static001.geekbang.org/account/avatar/00/14/2c/8a/257c130b.jpg","comment_is_top":false,"comment_ctime":1660643222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660643222","product_id":100017301,"comment_content":"                      x                         y                         z                 num<br>            3年生命的细胞     2年生命的细胞      1年生命的细胞   细胞总数<br>初始0             1                       0                             0                  1<br>年1                1                       1                             0                   2<br>年2                2                       1                             1                   4<br>3                   4                       2                             1                    7<br>4                   7                       4                             2                    13<br>5                   13                     7                             4                    24<br>6                   24                     13                           7                    44 <br><br>初始值x=1，y=0，z=0，num=1 <br>循环   z=y，y=x，x=num，num=x+y+z   <br>循环次数n，等于过n小时。<br>f（n）=f（n-1）+f（n-2）+f（n-3）（仅n&gt;=3时成立）","like_count":0},{"had_liked":false,"id":352835,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1149402,"ip_address":"","ucode":"AD6933D125C930","user_header":"https://static001.geekbang.org/account/avatar/00/11/89/da/136cdca6.jpg","comment_is_top":false,"comment_ctime":1658976453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658976453","product_id":100017301,"comment_content":"f(n-1)+f(n-2)+f(n-3)","like_count":0},{"had_liked":false,"id":350373,"user_name":"Jay","can_delete":false,"product_type":"c1","uid":1070670,"ip_address":"","ucode":"ED9970F7E66080","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/4e/9291fac0.jpg","comment_is_top":false,"comment_ctime":1656857174,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1656857174","product_id":100017301,"comment_content":"果然，题目做不对的第一原因是，题目没读懂... 细胞分裂的过程这种常识，不查我还真没那么清楚，最难的居然是看不懂题目，类目....","like_count":0},{"had_liked":false,"id":341385,"user_name":"氢气","can_delete":false,"product_type":"c1","uid":1241800,"ip_address":"","ucode":"4EBAB1731F5F9A","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/c8/565f2fa0.jpg","comment_is_top":false,"comment_ctime":1649574883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649574883","product_id":100017301,"comment_content":"对于思考题，最开始我也以为是f(n)=2f(n-1)-f(n-4)，但后面画图思考后觉得不能这么简单的处理。 假设细胞是先分裂再死亡(即第三个小时的时候该细胞还存在并且可以正常分裂)。那么，f0=1,f1=2,f2=4,f3=8，第四个小时，死亡1个细胞剩余7个细胞，分裂得14个细胞，第五个小时，死亡f1&#47;2=1个细胞剩余13个细胞，分裂得到26个细胞，第六个小时，死亡f2&#47;2=2个细胞，剩余24个细胞，分裂后得48个细胞，即f(n)=2(f(n-1)-f(n-4)&#47;2) (可以理解为每次死掉的都是三个小时前新分裂得到的细胞)，时间复杂度按照递归树来进行推算是2^n量级，希望老师可以点评一下，我感觉这个思路应该没有问题了吧…","like_count":0},{"had_liked":false,"id":338534,"user_name":"GkTian","can_delete":false,"product_type":"c1","uid":1415305,"ip_address":"","ucode":"05B11A512A8892","user_header":"https://static001.geekbang.org/account/avatar/00/15/98/89/ca8fa978.jpg","comment_is_top":false,"comment_ctime":1647562427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647562427","product_id":100017301,"comment_content":"每个时刻数量的一半是分裂新生的<br>f(n)=2*(f(n-1) - f(n-3)&#47;2) = 2*f(n-1) - f(n-3)","like_count":0},{"had_liked":false,"id":337749,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1647007599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647007599","product_id":100017301,"comment_content":"本节学习到了使用递归树来分析递归程序的时间复杂度，画出递归树图，分析每一层的时间复杂度，找出最长路径和最短路径，数学计算时间复杂度；<br>思考题： 没有算出，看了下评论，如此简单~","like_count":0},{"had_liked":false,"id":337190,"user_name":"Geek_156572","can_delete":false,"product_type":"c1","uid":2920502,"ip_address":"","ucode":"8886A6989F31ED","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK7vYz9A0rM2Ny3yQib2IvI70xAoOGtFicicJZmToGcUTiac6QcJaRKfeibCrXUrb6DV7vwuKgxh6jfYiaw/132","comment_is_top":false,"comment_ctime":1646667732,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646667732","product_id":100017301,"comment_content":"思考题：直接列时序图，两个情况，第一个情况细胞三个小时直接死亡不分裂，第二个情况三个小时分裂后再死亡。<br>图中 * 表示存活， - 表示死亡<br><br>情况一：三小时后直接死亡<br>0 * 1<br>1 * * 2<br>2 * * * * 4<br>3 - * * * * * * 6<br>4 - - * * * * * * * * * * 10<br>5 - - - - * * * * * * * * * * * * * * * * 16<br><br>f(n)=2*(f(n-1)-f(n-3))<br><br>情况二 三小时后分裂再死亡<br>0 * 1<br>1 * * 2<br>2 * * * * 4<br>3 - * * * * * * * 7<br>4 - - * * * * * * * * * * * * * * 14<br>5 - - - - * * * * * * * * * * * * * * * * * * * * * * * * * * 26<br><br>f(n)=2*f(n-1)-f(n-4)","like_count":0},{"had_liked":false,"id":336318,"user_name":"ProcessIsTheKey","can_delete":false,"product_type":"c1","uid":1299347,"ip_address":"","ucode":"BE02EFD75F7D98","user_header":"https://static001.geekbang.org/account/avatar/00/13/d3/93/c3fb8566.jpg","comment_is_top":false,"comment_ctime":1646070509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646070509","product_id":100017301,"comment_content":"看了50%了，欧耶！","like_count":0},{"had_liked":false,"id":329908,"user_name":"陆一鸣猜不动","can_delete":false,"product_type":"c1","uid":2831163,"ip_address":"","ucode":"68E89A037F9A0C","user_header":"https://static001.geekbang.org/account/avatar/00/2b/33/3b/0b25b622.jpg","comment_is_top":false,"comment_ctime":1641636420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641636420","product_id":100017301,"comment_content":"先死亡后分裂也是一样的","like_count":0},{"had_liked":false,"id":327435,"user_name":"诸葛子房","can_delete":false,"product_type":"c1","uid":1205063,"ip_address":"","ucode":"4F8322C7C7B740","user_header":"https://static001.geekbang.org/account/avatar/00/12/63/47/8a49986f.jpg","comment_is_top":false,"comment_ctime":1640135274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640135274","product_id":100017301,"comment_content":"数据全排列挺复杂的呀，理解起来","like_count":0},{"had_liked":false,"id":326264,"user_name":"Wilson","can_delete":false,"product_type":"c1","uid":1007140,"ip_address":"","ucode":"3ADBE962C67B8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/24/040855d3.jpg","comment_is_top":false,"comment_ctime":1639452568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639452568","product_id":100017301,"comment_content":"n小时候剩余细胞2^n个细胞，时间复杂度2^n, <br>分析过程：<br>0小时1个细胞<br>1个小时后，原来1个裂变为2个细胞，总共2个细胞<br>2个小时后，原来2个裂变为4个细胞，总共4个细胞<br>3个小时后，原来4个裂变为8个细胞，总共8个细胞（我理解每次裂变原细胞就变成2个细胞，原细胞就死掉了）<br>4个小时后，原来8个裂变为16个细胞，总共16个细胞<br>......<br>N个小时后，原来2^(n-1)变成2^n个稀薄，总共就2^n个细胞。<br><br><br>时间复杂度跟本文文章说的第二个例子台阶计算方式时间复杂度为2^n-1，去除常量，时间复杂度为：O(2^n)","like_count":0},{"had_liked":false,"id":324959,"user_name":"bookheart","can_delete":false,"product_type":"c1","uid":1061842,"ip_address":"","ucode":"96514218509202","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLX8ole5k6gIZ1j5V0CUUGxBJoxGp9x6CxbkTHuTB9s2QKdyKT4PYYV3vTraLAxBqjwmJEXlRvXIQ/132","comment_is_top":false,"comment_ctime":1638755347,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638755347","product_id":100017301,"comment_content":"全排列的Go实现:<br>func printPermutations(data []int, n, k int) {<br>\tif k == 1 {<br>\t\tfor i := 0; i &lt; n; i++ {<br>\t\t\tfmt.Printf(&quot; %v&quot;, data[i])<br>\t\t}<br>\t\tfmt.Println()<br>\t}<br><br>\tfor i := 0; i &lt; k; i++ {<br>\t\tdata[i], data[k-1] = data[k-1], data[i]<br>\t\tprintPermutations(data, n, k-1)<br>\t\tdata[i], data[k-1] = data[k-1], data[i]<br>\t}<br>}","like_count":0},{"had_liked":false,"id":323396,"user_name":"monchickey","can_delete":false,"product_type":"c1","uid":1513948,"ip_address":"","ucode":"D7B670444F62B3","user_header":"https://static001.geekbang.org/account/avatar/00/17/19/dc/9d3ed421.jpg","comment_is_top":false,"comment_ctime":1637888863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637888863","product_id":100017301,"comment_content":"这么考虑3小时是有4个时刻，即0,1,2,3这4个时刻，而每个时刻对应一层（也就是分裂的瞬间），每一层达到寿命的细胞都是0时刻新生的细胞，4层恰好存在3个路径，可能是这里比较纠结，所以有：f(n)  = 2*f(n - 1) - f(n - 4)，n满足n ≥ 4。","like_count":0},{"had_liked":false,"id":321065,"user_name":"买了就等于学了","can_delete":false,"product_type":"c1","uid":1832194,"ip_address":"","ucode":"1FA56272783A53","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f5/02/d1a1f878.jpg","comment_is_top":false,"comment_ctime":1636643154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636643154","product_id":100017301,"comment_content":"其实一个细胞存活三个小时，意味着是到第四个小时才死。得出的数据就是<br>f(0) = 1, f(1) = 2, f(2)=4, f(3)=8, f(4)=15【死了初代细胞】, f(5)=29【死了f(1)产生的一个子细胞】，到这里就能够通过数据发现，f(n) =f(n-4) + f(n-3) + f(n-2) + f(n-1), n&gt;=4，其实从这条递归公式也能明白其中意义。","like_count":0},{"had_liked":false,"id":321063,"user_name":"买了就等于学了","can_delete":false,"product_type":"c1","uid":1832194,"ip_address":"","ucode":"1FA56272783A53","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f5/02/d1a1f878.jpg","comment_is_top":false,"comment_ctime":1636642607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636642607","product_id":100017301,"comment_content":"这一题用数据反推，得出递归公式：f(n) = f(n - 4) + f(n-3) + f(n-2) + f(n -1) n&gt;=4","like_count":0},{"had_liked":false,"id":306918,"user_name":"迪迦","can_delete":false,"product_type":"c1","uid":2620423,"ip_address":"","ucode":"949D47FE9CC819","user_header":"https://static001.geekbang.org/account/avatar/00/27/fc/07/ad2851ea.jpg","comment_is_top":false,"comment_ctime":1628775982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628775982","product_id":100017301,"comment_content":"和斐波那契数一样呀，\r<br>f0=1\r<br>f1=2\r<br>f2=4\r<br>fn=f(n-1)+(n-2)+(n-3)\r<br>结果是3的n次方  到3的三分之n次方","like_count":0},{"had_liked":false,"id":305172,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1627868329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627868329","product_id":100017301,"comment_content":"先不考虑最后死亡的情况，则通过数学归纳法发现包括死亡的共产生的细胞总数为2^(n) - 1，在减去倒数第4层往上死亡的细胞数为2^(n-4) - 1, 所以剩余的细胞数量为15*2^(n-4)","like_count":0},{"had_liked":false,"id":304479,"user_name":"Neuject","can_delete":false,"product_type":"c1","uid":1346309,"ip_address":"","ucode":"4DCFF6CDC4186E","user_header":"https://static001.geekbang.org/account/avatar/00/14/8b/05/3315b855.jpg","comment_is_top":false,"comment_ctime":1627446319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627446319","product_id":100017301,"comment_content":"时间复杂度分析：<br>1、f(n)时刻的细胞来源于 f(n-3)、f(n-2)、f(n-1)时刻新分裂的细胞，且当前时刻新分裂的细胞近似等于当前时刻细胞总数的一半，所以树可以近似分成三叉树；<br>2、分析每层耗时：分层是一个常量记作1；由于三叉树所以每层耗时1、3、9、27...3^(k-1)，n层1+3+9+...+2^(n-1)=2^n-1;<br>3、分析树高：最长路径是每次-1的时候，从f(n)到f(0)，需要n次所以树高最高是n；最短路径是每次-3的时候，从f(n)到f(0)，需要n&#47;3次，所以树高最低是n&#47;3；<br>4、所以总耗时介于O(3^n)到O(2^(n&#47;3))之间。","like_count":0},{"had_liked":false,"id":302550,"user_name":"清风，佳音，真诚，理想","can_delete":false,"product_type":"c1","uid":2672167,"ip_address":"","ucode":"7E3A0023B79C1B","user_header":"https://static001.geekbang.org/account/avatar/00/28/c6/27/d553250e.jpg","comment_is_top":false,"comment_ctime":1626258793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626258793","product_id":100017301,"comment_content":"先说结论：f(n)=2*f(n-1)+f(n-4).<br>这个结论建议手工模拟找一下规律，下面是推导方法：<br>首先，细胞的生命周期是3，因此假设新生的细胞为0代，那么第0代细胞会分裂出第1代和第0代细胞，第1代细胞会分裂出第2代和第1代细胞，第2代细胞会分裂出第3代和第0代细胞（❗❗❗其中第3代细胞随即死亡，不再分裂）<br><br>任意时刻，容器内细胞数目=前一时刻细胞数目*2-第3代细胞数目<br>                                        =前一时刻细胞数目*2-前一小时第2代细胞数目<br>                                        =前一时刻细胞数目*2-前前一小时第1代细胞数目<br>                                        =前一时刻细胞数目*2-前前前一小时第0代细胞数目<br>                                        =前一时刻细胞数目*2-前前前前一小时第0、1、2代细胞数目。<br>                                        =前一时刻细胞数目*2-前前前前一小时所有细胞数目。<br>即表达为f(n)=2*f(n-1)+f(n-4)。<br>这里再做一点强调：由于每一次分裂后，第3代细胞随即死亡，因此任意时刻所有细胞数目和就=f(n)。<br>不知道我这种解释，讲明白了吗，结论是否正确呢？","like_count":0},{"had_liked":false,"id":297871,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623827632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623827632","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":293524,"user_name":"Martine","can_delete":false,"product_type":"c1","uid":2542913,"ip_address":"","ucode":"A5D403AA8EC8E5","user_header":"https://static001.geekbang.org/account/avatar/00/26/cd/41/c324a7de.jpg","comment_is_top":false,"comment_ctime":1621417964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621417964","product_id":100017301,"comment_content":"我觉得可以分两种情况分析吧：<br>1.假设细胞是先分裂，再判断年龄分析如下：<br>最开始时间为o的时刻，只有一个细胞，此时细胞的年龄为0<br><br>时刻：0  1  2  3  4  5  6 <br>个数：1  2  4  7  13 24 44<br><br>分析下：<br>时间 0 1 2 的时候细胞都没到生命周期，所以是按照比例分裂，<br>时间是3的时候，因为是先分裂，再计算生命周期，分裂前细胞总数是4，分裂得到8个细胞，然后里边有1个细胞的年龄到了3，这个细胞死了，所以还有8-1=7个细胞。<br>时间是4的时候，因为是先分裂，再计算生命周期，分裂前细胞总数是7，分裂得到14个细胞，然后里边有1个细胞的年龄到了3，这个细胞死了，所以还有14-1=13个细胞。注意这里只有1个细胞是年龄到3的，并不是时间1的时候的2个细胞（时间4-生命周期3=时间1），因为时间1中的一个细胞是从时间0熬过来的老细胞，时间点1只有1个细胞是新生的。时间1中的老细胞在时间点4之前就都死了。<br>时间是5的时候，13个细胞先分裂得到26个细胞，然后看时间2的时候有4个细胞，但是这里不是死了4个细胞而是2个，因为在时间2的时候只有2个细胞是新生的，还有2个细胞是老细胞，所以时间点5只死了2个细胞，此时还有26-2=24个细胞<br><br>那其实可以推导出：<br>在时间点n，n-1时间点分裂结束之后的细胞总数是f(n-1),那么有f(n)=(f(n-1))*2-年龄是3的细胞数，这里的年龄是3的细胞数该怎么求解呢？<br>那么年龄是3的细胞数是不是刚好等于f(n-3)呢？仔细思考，其实并不是，因为f(n-3)里边包含不只有当时年龄是0的细胞，还有一些当时时间点n-3的时候年龄&gt;0的细胞，这些细胞在时间点n之前都死了，无法分裂，也不用计算到时间点n的死亡统计中，那么在时间点n时年龄是3的细胞肯定就等于时间点n-3当时刚刚产生的，这里再考虑下n-3时间点新分裂出来的细胞数跟分裂后的整个细胞数有什么联系？因为是先分裂再判断年龄，也就是n-3时间点新分裂出来的细胞肯定是 f(n-4)，也就是上一个时间点n-4中的所有细胞数<br>代入公式f(n)=(f(n-1))*2-年龄是3的细胞数 得到<br>f(n)=(f(n-1))*2-年龄是3的细胞数 = f(n)=f(n-1)*2-f(n-4)<br><br><br>2.假设细胞是先判断年龄，再分裂的话，分析如下：<br>最开始时间为o的时刻，只有一个细胞，此时细胞的年龄为0<br><br>时刻：0  1  2  3  4  5  6 <br>个数：1  2  4  6  10 16 26<br><br>分析下：<br>时间 0 1 2 的时候细胞都没到生命周期，所以是按照比例分裂，<br>时间是3的时候，因为是先计算生命周期，再分裂，此时细胞总数是4，然后里边有1个细胞的年龄到了3，这个细胞死了没法分裂，所以分裂的只有4-1=3个细胞，分裂得到一共6个细胞<br>时间是4的时候，因为是先计算生命周期，再分裂，此时细胞总数是6，然后里边有1个细胞的年龄到了3，这个细胞死了没法分裂。注意这里只有1个细胞是年龄到3的，并不是时间1的时候的2个细胞（时间4-生命周期3=时间1），因为时间1中的一个细胞是从时间0熬过来的老细胞，时间点1只有1个细胞是新生的。时间1中的老细胞在时间点4之前就都死了。<br><br>那其实可以推导出：<br>在时间点n，n-1时间点分裂结束之后的细胞总数是f(n-1),那么有f(n)=(f(n-1)-年龄是3的细胞数)*2，这里的年龄是3的细胞数该怎么求解呢？<br>那么年龄是3的细胞数是不是刚好等于f(n-3)呢？仔细思考，其实并不是，因为f(n-3)里边包含不只有当时年龄是0的细胞，还有一些当时时间点n-3的时候年龄&gt;0的细胞，这些细胞在时间点n之前都死了，无法分裂，也不用计算到时间点n的死亡统计中，那么在时间点n时年龄是3的细胞肯定就等于时间点n-3当时刚刚产生的，这里再考虑下n-3时间点新分裂出来的细胞数跟分裂后的整个细胞数有什么联系？因为是先判断年龄，再分裂，也就是n-3时间点新分裂出来的细胞肯定是 f(n-3)&#47;2<br>代入公式 f(n)=(f(n-1)-年龄是3的细胞数)*2 得到<br>f(n)=(f(n-1)-年龄是3的细胞数)*2 = f(n)=(f(n-1)-f(n-3)&#47;2)*2 = 2*f(n-1)-f(n-3)","like_count":0},{"had_liked":false,"id":293043,"user_name":"陈忠富","can_delete":false,"product_type":"c1","uid":1219884,"ip_address":"","ucode":"011119D7A6C19A","user_header":"https://static001.geekbang.org/account/avatar/00/12/9d/2c/7a4d2d72.jpg","comment_is_top":false,"comment_ctime":1621171025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621171025","product_id":100017301,"comment_content":"我这篇不是特别懂，然后就去找了找资料，这篇老师感觉讲的更基础一点<br>https:&#47;&#47;www.coursera.org&#47;lecture&#47;algorithms&#47;015di-gui-shu-eaGvZ","like_count":0},{"had_liked":false,"id":291240,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1620136190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620136190","product_id":100017301,"comment_content":"老师在内容中提到的全排列问题，实现的是时间复杂度比较复杂的方式，没有用到回溯法剪枝。。。。。。","like_count":0},{"had_liked":false,"id":289708,"user_name":"蓝萧","can_delete":false,"product_type":"c1","uid":1227606,"ip_address":"","ucode":"DE125B56BF7818","user_header":"https://static001.geekbang.org/account/avatar/00/12/bb/56/a506a165.jpg","comment_is_top":false,"comment_ctime":1619148554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619148554","product_id":100017301,"comment_content":"看完了点赞数很多的留言，自己的分析结果和他们都不太一样。<br>定义 f(n) 为: n时刻细胞总数<br>定义 g(n) 为: n时刻新生细胞数<br>定义 h(n) 为: n时刻老死细胞数<br>于是有公式: f(n) = f(n-1) + g(n) - h(n)<br><br>对于题目有两种情况。<br>1. 先分裂后死亡 2. 先死亡后分裂。<br><br>对于情况1. 先分裂后死亡。<br>因为在n时刻，所有n -1 时刻的细胞都会分裂一次，新生细胞总数 g(n) = f(n - 1) <br>n时刻老死细胞总数，等于 n -3 时刻新生细胞数，即 h(n) = g(n-3) = f(n-4)<br>把g(n)与h(n)放进公式 得出 f(n) = f(n - 1) + g(n) + h(n) = 2*f(n-1) - f(n-4)<br>递归终止条件为 f(0) = 1; f(1) = 2; f(2) = 4; f(3) = 7;<br><br>对于情况2.细胞先死亡 后分裂<br>f(n)除了初始情况下，始终是2的倍数， n时刻的新生细胞数 g(n) = 1&#47;2 * f(n) <br>n时刻老死细胞数，等于n-3时刻新生细胞数 h(n) = g(n-3) = 1&#47;2 * f(n - 3)<br>将g(n) h(n) 代入公式 f(n) = f(n - 1) + g(n) - h(n) = f(n - 1) + 1&#47;2* f(n) - 1&#47;2 * f(n - 3)<br>最终计算得出 f(n) = 2* f(n - 1) - f(n - 3)<br>递归终止条件为 f(0) = 1; f(1) = 2; f(2) = 4; f(3) = 6;<br><br>再来看时间复杂度，用递归树的方法分析，树从根节点到叶子节点的最大深度为n，最小深度为 n&#47;4 或者 n&#47;3, 公式的每一次计算 分为一次乘法(也可以看做移位操作)和一次加法(减法变加法)，总共2次操作，第n层最大操作次数为 2 * 2^n，根据指数求和公式，时间复杂度为O(2^n)","like_count":0},{"had_liked":false,"id":287377,"user_name":"season","can_delete":false,"product_type":"c1","uid":2054588,"ip_address":"","ucode":"BE88FEFD025FBF","user_header":"https://static001.geekbang.org/account/avatar/00/1f/59/bc/6c5ad3f0.jpg","comment_is_top":false,"comment_ctime":1617916579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617916579","product_id":100017301,"comment_content":"设f(n)为第n小时容器内细胞个数，g(n)为第n小时新生细胞个数。<br>f(0) = 1, g(0) = 1<br>f(1) = 3, g(1) = 2<br>f(2) = 7, g(2) = 4<br><br>n &gt; 2:<br>f(n) = 7 * g(n-2), g(n) = 2*g(n-1)<br><br>复杂度O(n)","like_count":0},{"had_liked":false,"id":284879,"user_name":"姬遇","can_delete":false,"product_type":"c1","uid":2527979,"ip_address":"","ucode":"4A1617750FC3A9","user_header":"https://static001.geekbang.org/account/avatar/00/26/92/eb/e530c2d0.jpg","comment_is_top":false,"comment_ctime":1616508660,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1616508660","product_id":100017301,"comment_content":"假设死去的细胞也能“繁衍”，那么n小时后活着的细胞数目就是3的n次幂减去3的（n-2)次幂，复杂度是O（n)","like_count":0},{"had_liked":false,"id":280846,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614420974,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614420974","product_id":100017301,"comment_content":"茶艺师学编程<br><br>思考题<br>应该是O（n＾2）吧","like_count":0},{"had_liked":false,"id":278024,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1612707466,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612707466","product_id":100017301,"comment_content":"递推公式的时间复杂度方法、递归树的时间复杂度方法！哈，之前我把递归树和普通的树还分不清呢！","like_count":0},{"had_liked":false,"id":274272,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1610950327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610950327","product_id":100017301,"comment_content":"我在 T(n) = 2T(n&#47;2) + n 最后推导等于 nlogn,时候纠结了很多次。最后搜索查询后才把牛角尖转过来，在我们推导过程中，最后的公式 T(n) = 2^kT(n&#47;2^k) + kcn,需要我们去设置 2^k = n 这个条件，才会推导 =n(T(n) + clog2n) = nlogn的结果。","like_count":0},{"had_liked":false,"id":270925,"user_name":"地球不是球","can_delete":false,"product_type":"c1","uid":2047265,"ip_address":"","ucode":"B5D9F7E24C1916","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3d/21/4b5e480c.jpg","comment_is_top":false,"comment_ctime":1609319818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609319818","product_id":100017301,"comment_content":"细胞分裂（cell division）是指活细胞增殖及其数量由一个细胞分裂为两个细胞的过程。分裂前的细胞称母细胞（mother cell），分裂后形成的新细胞称子细胞（daughter cell）。<br>1h -------------&gt;2---------&gt;2^1<br>2h-------------&gt;4----------&gt;2^2<br>3h-------------&gt;8----------&gt;2^3<br>(n-2)h----------------------&gt;2^(n-2)<br>(n-1)h-----------------------&gt;2^(n-1)<br>nh---------------------------&gt;2^n <br>f(n) = 2^(n-2)+2^(n-1)+2^(n)  时间复杂度 f(O) = 2^n","like_count":0},{"had_liked":false,"id":270525,"user_name":"魔偶","can_delete":false,"product_type":"c1","uid":1024001,"ip_address":"","ucode":"6A40B6BD406D56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/01/0415fc3c.jpg","comment_is_top":false,"comment_ctime":1609150090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609150090","product_id":100017301,"comment_content":"《一文教你学会递归解题》https:&#47;&#47;juejin.cn&#47;post&#47;6844904015357018119， 这个说得有道理","like_count":0},{"had_liked":false,"id":256741,"user_name":"『芡妳☆dě緈諨』","can_delete":false,"product_type":"c1","uid":1216527,"ip_address":"","ucode":"1105FB19A03D65","user_header":"https://static001.geekbang.org/account/avatar/00/12/90/0f/a805caf3.jpg","comment_is_top":false,"comment_ctime":1603720827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603720827","product_id":100017301,"comment_content":"有一个问题，有一个多叉树，每个节点都有一个数值，如何利用递归算法层层向上累计每个父节点的总和？","like_count":0},{"had_liked":false,"id":253234,"user_name":"guoguo","can_delete":false,"product_type":"c1","uid":1852187,"ip_address":"","ucode":"878BB500710F54","user_header":"https://static001.geekbang.org/account/avatar/00/1c/43/1b/7cf10220.jpg","comment_is_top":false,"comment_ctime":1602658764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602658764","product_id":100017301,"comment_content":"全排列的代码中k==1时加上一句return比较好吧，尽管不影响最终结果，但是还会进入没有必要的for循环","like_count":0},{"had_liked":false,"id":252298,"user_name":"youyou.L","can_delete":false,"product_type":"c1","uid":1796438,"ip_address":"","ucode":"B3DB0D0700EEAC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","comment_is_top":false,"comment_ctime":1602227854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602227854","product_id":100017301,"comment_content":"思考题：<br>假设细胞先分裂再死亡，n是过了n小时，f(0) = 1, f(1)= 2, f(2) = 4, f(3) =7<br>递推公式：f(n) = 2f(n-1) - f(n-3)<br>翻译成代码：<br>int func(int n){<br>  if(n == 0)return 1; <br>  if(n == 1) return 2;<br>  if(n == 2) return 4;<br>  return 2func(n-1) - func(n-3);<br>}<br><br>时间复杂度计算：<br>  递归树高度范围：最高是每次n-1的路径，树高为n，最短是每次n-3的路径 树高为n&#47;3<br>  设减操作耗费时间为常量1<br>  递归树第一层耗费时间1，第二层2，第三层4，第k层2^(k-1)<br>  整个递归树耗费的时间就是代码的时间复杂度，耗费时间为2^k - 1<br>  时间复杂度范围为[O(2^(n&#47;3)), O(2^(n))] 是指数级别的时间复杂度非常高","like_count":0},{"had_liked":false,"id":250915,"user_name":"张名哲","can_delete":false,"product_type":"c1","uid":1260121,"ip_address":"","ucode":"0476910BC2FE81","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/59/d0f326e7.jpg","comment_is_top":false,"comment_ctime":1601280116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601280116","product_id":100017301,"comment_content":"树的层数应该是n,执行n次就有n层， 每层执行的函数为f(n) = 2*f(n-1) - f(n-3)<br>所以最后的时间复杂度为 ： f(n) = n(2*f(n-1) - f(n-3))","like_count":0},{"had_liked":false,"id":241852,"user_name":"田","can_delete":false,"product_type":"c1","uid":1669795,"ip_address":"","ucode":"2CC99CC96D59CC","user_header":"https://static001.geekbang.org/account/avatar/00/19/7a/a3/19d9bf76.jpg","comment_is_top":false,"comment_ctime":1597468722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597468722","product_id":100017301,"comment_content":"感觉前边发的帖子分析都不太对，应该是f(n)=2f(n-1)-(f(n-3)-f(n-4))<br>先不考虑临界值很小的情况，每次死亡的个数应该是f(n-3)-f(n-4)，<br>因为n-3时间的细胞分裂数，n-4的分裂数都已经死亡了，<br>实际上n-3要死亡的细胞数，f(n-3)-f(n-4)，<br>因此得到：f(n)=2f(n-1)-(f(n-3)-f(n-4))","like_count":0},{"had_liked":false,"id":240192,"user_name":"陈琦","can_delete":false,"product_type":"c1","uid":1607864,"ip_address":"","ucode":"48F974137EF0BE","user_header":"https://static001.geekbang.org/account/avatar/00/18/88/b8/7527da95.jpg","comment_is_top":false,"comment_ctime":1596784104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596784104","product_id":100017301,"comment_content":"f(n)=f(n-1)x2-f(n-4)。","like_count":0},{"had_liked":false,"id":239382,"user_name":"醉梦了红尘","can_delete":false,"product_type":"c1","uid":1889141,"ip_address":"","ucode":"DB742865BAD6B6","user_header":"","comment_is_top":false,"comment_ctime":1596518116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596518116","product_id":100017301,"comment_content":"没弄明白全排列时间复杂度最后一层n∗(n−1)∗(n−2)∗…∗2∗1 不是包含了上一层(n−1)∗(n−2)∗…∗2∗1 吗，总的时间复杂度为啥不是n！，为什么是一个个累加呢？","like_count":0},{"had_liked":false,"id":237561,"user_name":"曾经蜡笔没有小新","can_delete":false,"product_type":"c1","uid":1400168,"ip_address":"","ucode":"2D50C3A6DF8C15","user_header":"https://static001.geekbang.org/account/avatar/00/15/5d/68/98cf8ef8.jpg","comment_is_top":false,"comment_ctime":1595863411,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595863411","product_id":100017301,"comment_content":"初始条件: <br>f(-∝)=0;<br>f(0)=1;<br>递推公式:<br>需要减去 &quot;-3小时&quot; 时刻新增的细胞数量，所以f(n)=2*f(n-1)-(f(n-3)-f(n-4))。<br>f(1)=2*(f(0))-(f(-2)-f(-3))=2<br>f(2)=2*(f(1))-(f(-1)-f(-2))=4<br>f(3)=2*(f(2))-(f(0)-f(-1))=7<br>f(4)=2*(f(3))-(f(1)-f(0))=13<br>f(5)=2*(f(4))-(f(2)-f(1))=24<br>……<br>递归树是一个最大高度为n的完全三叉树（高度计算从fn递减1，直到f0；完全三叉树的不少节点都固定为f(-∝)），每层操作为3^(n-1)，求和复杂度为O(n*3^n)。","like_count":0},{"had_liked":false,"id":237407,"user_name":"渊จุ๊บ","can_delete":false,"product_type":"c1","uid":1530295,"ip_address":"","ucode":"E3A2C1E89EB576","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/b7/9db9c657.jpg","comment_is_top":false,"comment_ctime":1595821119,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1595821119","product_id":100017301,"comment_content":"按细胞寿命长状态做了三个函数（最后都归为了一个函数），如下：<br>f3(n) = f3(n-1) + f2(n-1) + f1(n-1)<br>f2(n) = f3(n-1)<br>f1(n) = f2(n-1) = f3(n-2)<br>那么f3(n) = f3(n-1) + f3(n-2) + f3(n-3)<br>设f3(1) = 1, f3(0) = 0, f3(-1) = 0<br>按斐波那契函数来看，思考题的时间复杂度介于O(3^n)小于O(3^(n&#47;3))","like_count":0,"discussions":[{"author":{"id":1260121,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/59/d0f326e7.jpg","nickname":"张名哲","note":"","ucode":"0476910BC2FE81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309399,"discussion_content":"f3 是啥意思老兄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601279063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1530295,"avatar":"https://static001.geekbang.org/account/avatar/00/17/59/b7/9db9c657.jpg","nickname":"渊จุ๊บ","note":"","ucode":"E3A2C1E89EB576","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1260121,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/59/d0f326e7.jpg","nickname":"张名哲","note":"","ucode":"0476910BC2FE81","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311182,"discussion_content":"就是寿命还有三小时的细胞总数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602245629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309399,"ip_address":""},"score":311182,"extra":""}]}]},{"had_liked":false,"id":235983,"user_name":"多选参数","can_delete":false,"product_type":"c1","uid":1248326,"ip_address":"","ucode":"B2294D80AB075F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","comment_is_top":false,"comment_ctime":1595263233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595263233","product_id":100017301,"comment_content":"通过一点一点画图，发现“纯洁的憎恶”用户的解答是正确的。乘 2 的方式都不严谨，可以通过画图的方式来进行推导。但是，这种方式我推导出来的前提是 3 小时之后不分裂，直接死亡。","like_count":0},{"had_liked":false,"id":235475,"user_name":"范奇","can_delete":false,"product_type":"c1","uid":2048731,"ip_address":"","ucode":"0E3A78347A6AAC","user_header":"https://static001.geekbang.org/account/avatar/00/1f/42/db/5945a666.jpg","comment_is_top":false,"comment_ctime":1595053823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595053823","product_id":100017301,"comment_content":"0小时:f(0) = 1,<br>1小时:f(1) = 1 * 2 = 2,<br>2小时:f(2)= 2 * 2 = 4,<br>3小时:f(3) = f(2) * 2 - 1(母细胞) = 7;<br>4小时:f(4) = f(3) * 2 - 1(第一个子细胞) = 13;<br>5小时:f(5)= f(4)*2 - 2(2小时时新产生子细胞) = 24;<br>.....<br>默认赋值<br>0小时:f(0) = 1,<br>1小时:f(1) = 2,<br>2小时:f(2) = 4,<br>从n &gt;= 3开始的算法则是<br>f(n)=f(n-1)+f(n-2)+f(n-3);","like_count":0},{"had_liked":false,"id":232794,"user_name":"庄坤","can_delete":false,"product_type":"c1","uid":1610407,"ip_address":"","ucode":"5E1C3E234BB793","user_header":"https://static001.geekbang.org/account/avatar/00/18/92/a7/b16dfff3.jpg","comment_is_top":false,"comment_ctime":1594119179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594119179","product_id":100017301,"comment_content":"推导公式为f(n)=2*f(n-1)-f(n-3)，即一小时前的数量翻倍减去3小时前的数量（3小时前的都死翘翘了）<br>时间复杂度跟层数以及每层的计算数量有关，画下图就会发现最长路径就是n n-1 n-2...1，层数就是n层，第一层的时间复杂度是2^0，那么最下面一层就是2^(n-1)，总的加起来就差不多是2的阶层（2!）","like_count":0},{"had_liked":false,"id":232558,"user_name":"性林的木木","can_delete":false,"product_type":"c1","uid":2048047,"ip_address":"","ucode":"BFB36D0B8BF66E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/40/2f/574f8de5.jpg","comment_is_top":false,"comment_ctime":1594037124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594037124","product_id":100017301,"comment_content":"与斐波那契类似:<br>公式为f(n)=2f(n--1)-f(n-3)<br>取左，即为f(n)=2f(n--1)-f(n-1)，有n层，复杂度为1+2+...+2∧n，即最大复杂度为2∧n-1<br>取右，即为f(n)=2f(n--3)-f(n-3)，有n&#47;3层，复杂度为1+2+...+2∧(n&#47;3-1)，即最小复杂度为2∧(n&#47;3)-1<br>综上，去掉尾项，其时间复杂度为2∧(n&#47;3)&lt;2∧n<br>","like_count":0},{"had_liked":false,"id":232002,"user_name":"Amaris","can_delete":false,"product_type":"c1","uid":1355564,"ip_address":"","ucode":"0C7AA376CBA36A","user_header":"https://static001.geekbang.org/account/avatar/00/14/af/2c/144d2771.jpg","comment_is_top":false,"comment_ctime":1593828766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593828766","product_id":100017301,"comment_content":"f(n)=f(n-1) - (f(n-3) - f(n-4))","like_count":0},{"had_liked":false,"id":230062,"user_name":"Swift_yong","can_delete":false,"product_type":"c1","uid":1260782,"ip_address":"","ucode":"19AE116EB7BCF0","user_header":"https://static001.geekbang.org/account/avatar/00/13/3c/ee/18f48590.jpg","comment_is_top":false,"comment_ctime":1593248878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593248878","product_id":100017301,"comment_content":"按递归树分析：2^n+1 - (2^n-2 - 1)<br>                    2^n+1 - 2^n-3<br>                    2*(2^n - 2^n-3)<br>可以分析得出， 递归时间复杂度是 O(2^n).","like_count":0},{"had_liked":false,"id":228641,"user_name":"HeRui","can_delete":false,"product_type":"c1","uid":1395092,"ip_address":"","ucode":"4B736D2FD8FB54","user_header":"https://static001.geekbang.org/account/avatar/00/15/49/94/55e70da0.jpg","comment_is_top":false,"comment_ctime":1592763748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592763748","product_id":100017301,"comment_content":"这个细胞分列的问题不知道怎么理解，每次一个变成两个，那两个都算新生的，还是只有其中一个算新生，如果两个都算新生，那么每个细胞的生命永远只有1小时，那么就永远不死了，所以应该是分裂后只有其中一个算新生才行,第三小时假设先分裂再死，那么情况如下：<br>f(0) = 1                (0h）<br>f(1)  = 2               (1h,  0h)<br>f(2) = 4                (2h,1h,  0h,0h)<br>f(3) = 8 - 1 = 7    (3h,2h,1h,1h,  0h,0h,0h,0h)<br>f(4) = 14 - 1 = 13 (3h,2h,2h,1h,1h,1h,1h,   0h,0h,0h,0h,0h,0h,0h)<br>f(5) = 26 - 2 = 24 (3h,3h,2h,2h,2h,2h,1h,1h,1h,1h,1h,1h,1h,   0h,0h,0h,0h,0h,0h,0h,0h,0h,0h,0h,0h,0h)<br>f(6) = 48 - 4 = 44<br><br>f(7) = 2f(6) - 7. = 88 - 7 = 81<br>f(8) = 2f(7) - 13 = 162 - 13 = 149<br>f(9) = 2f(8) - 24 = 298 - 26 = 274<br>...<br>f(n) = 2f(n-1) - f(n-4),  n &gt;= 4<br><br>java代码：<br>public static int f(int h) {<br>    if(h == 0) return 1;<br>    if(h == 1) return 2;<br>    if(h == 2) return 4;<br>    if(h == 3) return 7;<br><br>    return 2 * f(h - 1) - f(h - 4);<br>}<br><br>时间复杂度：<br><br>(n - 3) + (n - 4) + .. (n - n) + 1= (n - 3) * (n - 3) &#47; 2 + 1,  n &gt; 3<br><br>所以时间复杂度为O(n^2)","like_count":0},{"had_liked":false,"id":225095,"user_name":"Lawrence","can_delete":false,"product_type":"c1","uid":1986870,"ip_address":"","ucode":"6C46D1C41E94D3","user_header":"https://static001.geekbang.org/account/avatar/00/1e/51/36/a30dbbc5.jpg","comment_is_top":false,"comment_ctime":1591648998,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1591648998","product_id":100017301,"comment_content":"老师在文章里写到的计算路径，如何根据这些数字（e.g. -1 or -2就能算出来2&#47;n）就能算出来最短路径了？","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290165,"discussion_content":"等差数列第h项为1第1项为n公差d为-1，根据等差公式ah=a1+（h-1）d，所以最长路径为n，当公差为-2时最短路径为n/2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594364542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223478,"user_name":"TheStarBoys","can_delete":false,"product_type":"c1","uid":2009311,"ip_address":"","ucode":"9A6D70482F9212","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SiciaNKibn60SjA50TsTEtO09DoRA57UozylHmKckZXkJmNiaShSC0BIP6TdZC6cAphuEzmuxMHWwvpYN8P7kKb8eA/132","comment_is_top":false,"comment_ctime":1591099671,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1591099671","product_id":100017301,"comment_content":"认真的做了下思考题，欢迎批评指正。以下内容还可从这里查看：https:&#47;&#47;www.jianshu.com&#47;p&#47;f117c048af92<br>## 题目描述<br>1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。<br><br><br>## 题目分析<br>以剩余时间为 4 为例：初始情况，只有一个细胞，还未分裂。第一行中第2列到第4列的数字表示对应周期细胞的数量，剩余时间为3时，生命周期为3的有一个细胞，生命周期为2的有一个细胞。<br><br>| 剩余时间 | 1    | 2    | 3    | 存活细胞总数 | 死亡细胞总数 | 细胞总数 |<br>| -------- | ---- | ---- | ---- | ------------ | ------------ | -------- |<br>| 4        |      |      | 1    | 1            | 0            | 1        |<br>| 3        |      | 1    | 1    | 2            | 0            | 2        |<br>| 2        | 1    | 1    | 2    | 4            | 0            | 4        |<br>| 1        | 1    | 2    | 4    | 7            | 1            | 8        |<br>| 0        | 2    | 4    | 7    | 13           | 2            | 15       |<br><br>用一个函数来模拟此过程，一个函数名叫`cell`，代表了一个细胞。有两个参数，第一个参数 n 代表当前剩余的时间，第二个参数 life 代表该细胞还能存活的时间。记为 `cell(n, life)`，一个细胞的生命周期，即寿命最大值记为`maxLife = 3`<br><br>一个细胞繁殖其实就是自己寿命减少，并且繁殖出一个新的寿命为`maxLife`的细胞。这个过程可以表示为 `cell(n-1, life-1) + cell(n-1, maxLife)`，有了两个不同的细胞。当细胞死亡或者时间截止的时候，即 `n &lt;= n || life &lt;= 0`的时候，这个细胞不会再分裂，只有它自己一个细胞。<br><br>## 代码实现<br><br>```go<br>var maxLife = 3<br>func cell(n, life int) int {<br>\tif n &lt;= 0 || life &lt;= 0 {<br>\t\treturn 1<br>\t}<br>\t&#47;&#47; 一个细胞，会自己寿命减少，并分裂一个新的细胞。<br>\treturn cell(n-1, life-1) + cell(n-1, maxLife)<br>}<br>```<br><br>其实表格所展示的思想也可以转换为代码：<br><br>```go<br>func cell(n int) int {<br>\t&#47;&#47; 初始情况, 只有一个生命为3的细胞<br>\t&#47;&#47; 存放不同生命值的细胞数量，生命值-1 ==&gt; 细胞数量<br>\tcells := [3]int{2: 1}<br>\t&#47;&#47; 细胞总数，当前存活细胞总数<br>\ttotalNum, surviveNum := 1, 1<br>\tfor ; n &gt; 0; n-- {<br>\t\t&#47;&#47; 存活的细胞生命减1<br>\t\tfor i := 1; i &lt; 3; i++ {<br>\t\t\tcells[i-1] = cells[i]<br>\t\t}<br>\t\t&#47;&#47; 存活的细胞都会分化出一个新的细胞<br>\t\ttotalNum += surviveNum<br>\t\t&#47;&#47; 分化出的新细胞全为 生命为3<br>\t\tcells[2] = surviveNum<br>\t\t&#47;&#47; 更新当前存活的细胞总数<br>\t\tsurviveNum = cells[0] + cells[1] + surviveNum<br>\t}<br><br>\treturn totalNum<br>}<br>```<br><br>## 时间复杂度<br>对于第一种实现<br>在 `n &lt;= maxLife` 的时候，没有细胞死亡，所有的细胞都将一分为二，恰好是一个满二叉树。在一个节点中耗时操作为O(1)，因为只需要做加法。总体的时间复杂度取决于二叉树中节点的个数，即 `(2 ^ n) - 1`，忽略常数阶，时间复杂度为 `O(2^n)`。<br>在 `n &gt; maxLife` 的时候，节点个数会小于 `(2 ^ n) - 1`，但仍然是指数级的。<br><br>对于第二种实现<br>表面上是循环嵌套，时间复杂度为 `O(n^2)`，实际上内层循环次数并不随数据规模 `n` 的增大而增大，所以依旧是常数级的。其时间复杂度应该为 `O(n)`。","like_count":0,"discussions":[{"author":{"id":2009311,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/SiciaNKibn60SjA50TsTEtO09DoRA57UozylHmKckZXkJmNiaShSC0BIP6TdZC6cAphuEzmuxMHWwvpYN8P7kKb8eA/132","nickname":"TheStarBoys","note":"","ucode":"9A6D70482F9212","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277732,"discussion_content":"哎，自己打自己脸。我求成了容器内分裂出的所有细胞了，题意应该是求当时还存活的细胞。递归的错完了，迭代的解法返回值换成surviveNum应该就是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591101726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223453,"user_name":"多多摩⚽️","can_delete":false,"product_type":"c1","uid":1465491,"ip_address":"","ucode":"45DB1BE586F5AA","user_header":"https://static001.geekbang.org/account/avatar/00/16/5c/93/288018a7.jpg","comment_is_top":false,"comment_ctime":1591093069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591093069","product_id":100017301,"comment_content":"假设细胞到了第三个小时是先分裂完再死亡<br>设：<br>函数 f(n) 表示 n小时数后细胞总数 <br>函数 F(n) 表示 n小时数后是由(n-1)小时后细胞分裂得到的细胞的总数<br><br>则有函数关系  F(n) = f(n-1)<br>此时 F(n) 即表示n小时后 细胞生命值为0小时的数量<br>那么就有  n小时后 细胞生命值为1小时的数量 F(n-1) = f(n-2)  <br>n小时后 细胞生命值为2小时的数量 F(n-2) = f(n-3)  <br><br>因为任何小时后的细胞数量都等于 生命值为别为 0 1 2 小时的细胞的总数<br>即 f(n) = F(n) + F(n-1) + F(n-2) = f(n-1) + f(n-2) + f(n-3)<br><br>递推公式就应该是: f(n) = f(n-1) + f(n-2) + f(n-3)","like_count":0},{"had_liked":false,"id":222309,"user_name":"山鬼谣","can_delete":false,"product_type":"c1","uid":1543162,"ip_address":"","ucode":"E25F498B85A01B","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/fa/103e6900.jpg","comment_is_top":false,"comment_ctime":1590743149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590743149","product_id":100017301,"comment_content":"正确的公式，f(n)=f(n-1)x2-f(n-4)，<br>画个图，自己推算就行了","like_count":0},{"had_liked":false,"id":221950,"user_name":"王木公","can_delete":false,"product_type":"c1","uid":1014550,"ip_address":"","ucode":"F049AEBFA0338D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","comment_is_top":false,"comment_ctime":1590640037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590640037","product_id":100017301,"comment_content":"我记得排序那一节说，在极端情况下，比如已经排好序情况下，进行快排，时间复杂度是O(n^2)啊，那已经排好序的情况，和这里的1:9的分配比例是否是类似的呢，为什么这里计算出仍是O(nlogn)？","like_count":0},{"had_liked":false,"id":221784,"user_name":"Geek_de85cb","can_delete":false,"product_type":"c1","uid":2000370,"ip_address":"","ucode":"C12AAE9FFA8DD2","user_header":"","comment_is_top":false,"comment_ctime":1590591102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590591102","product_id":100017301,"comment_content":"直接想到了大三角（所有细胞）减去小三角（当前已经死的细胞），他们之间差三层…","like_count":0},{"had_liked":false,"id":218573,"user_name":"你在不远的未来","can_delete":false,"product_type":"c1","uid":1318404,"ip_address":"","ucode":"5B34C8BD03B71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/04/f902047e.jpg","comment_is_top":false,"comment_ctime":1589819448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589819448","product_id":100017301,"comment_content":"时间t（h）<br>细胞分裂为：f(t) = Math.pow(2, t - 1)<br>细胞死亡为：d(t) = f(t - 3)   &#47;&#47;死亡数量为3小时分新增数<br>细胞死亡总数：s(t)<br><br>t &lt; 3， s(t) = f(t) <br>t &gt;= 3，s(t) = f(t) - f(t - 3)","like_count":0},{"had_liked":false,"id":216926,"user_name":"GX_Alanxx","can_delete":false,"product_type":"c1","uid":1294911,"ip_address":"","ucode":"C5EB08AAE77E49","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3f/4f802365.jpg","comment_is_top":false,"comment_ctime":1589370475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589370475","product_id":100017301,"comment_content":"2^n","like_count":0},{"had_liked":false,"id":216594,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1589292409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589292409","product_id":100017301,"comment_content":"时间复杂度分析，要抓主要矛盾，忽略次要的。","like_count":0},{"had_liked":false,"id":216402,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1589252731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589252731","product_id":100017301,"comment_content":"学习笔记:<br>时间复杂度分析的递归树法<br>1. 分析每一步核心操作的时间复杂度<br>2. 分析树高：最大树高和最小树高<br>3. 计算每层复杂度，全加起来<br>实战1:快速排序<br>1. 分割算法是O(n)<br>2,树高最大最小都是 logn，所以O(logn)<br>实战2：斐波那契数列:<br>1. 加和算法1<br>2. 节点数为倍增。 通项为2^h<br>3. 高度最高n，最低n&#47;2.相当于求等比数列前n项和。所以结果2^n,指数级<br>实战3:全排列<br>1. 核心为将每一项交换到最后一个位置，O（n）<br>2. 每层树枝-1，所以每层通项是n*n-1*n-2...n-h。<br>3.最后一层为一个，所以是n！。求和不好求但是知道该算法大于n！<br>思考题：<br>模型描述：我认为争议点第一个细胞在第三个小时，即将死亡时，还能不能产出1个。我认为不能，生孩子很累的。所以模型为( ‘|’右边表示新分裂的，-1表示死亡，数字大小表示寿命)<br>0   0                       1<br>1   1  |0                    2<br>2   2  1 |0  0              4<br>3   -1 2  1  1 |0  0  0     6(注意上代寿命为2的直接死亡，不再分裂)<br>4   -1 -1 2  2  1  1  1 |0  0  0  0  0   10<br>5   (10 - 2) * 2 = 16<br>6    (16 - 3) * 2 = 26   16-3不是4？？<br>本以为是上一代的数量减去上四代的数量(即将死亡的数量)，再乘以2就好了，但是到了第六步发现问题，因为，因为即将死亡的数量不是上四代的4而是3其中有一个寿命为2不分裂。然后头要炸了。<br>但是大致按照f(n) = 2 x [ (f(n-1) - f(n-4) ]来分析时间复杂度的话，应该类似斐波那契数列，为指数级。<br>当然这是废话，细胞指数分裂谁还不知道是指数级啊，我还知道略小于指数级呢，因为会死亡。","like_count":0},{"had_liked":false,"id":214809,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1588822809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588822809","product_id":100017301,"comment_content":"27 | 递归树：如何借助树来求解递归算法的时间复杂度？<br>递归树与时间复杂度分析<br>递归树：就是将大问题化成小问题的过程 f(n) = f(n-1) + f(n-2)的过程<br>每一层操作消耗的时间记作n，树的高度 h，我们就可以得到总的时间复杂度 O(n*h)，满二叉树的高度是log2n，所以归并排序实现的时间复杂度就是nlogn。<br>实战一：分析快速排序的时间复杂度<br>推导时间复杂度一脸懵逼；<br>遍历数据的个数总和就介于 nlog10​n 和 nlog910​​n 之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn，所以，当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 O(nlogn)。所以不管k取多少，最终的结果都是O(nlogn)。<br>实战二：分析斐波那契数列的时间复杂度<br>f(n) 分解为 f(n−1) 和 f(n−2)<br>树每一层分解都是成倍增加，这个算法的时间复杂度就介于 O(2n) 和 O(22n​) 之间<br>实战三：分析全排列的时间复杂度<br>两脸懵逼<br><br>课后思考：<br>n小时<br>1        <br>1         1h   2^0<br>1 1        2h    2^1<br>1 1 1      3h   第一个死掉<br>5          4h  第二个死掉<br>...  nh     2*f(n-1) + f(n-3)<br>f(n) = 2*f(n-1) + f(n-3)  这只是递归公式出来了。时间复杂度不会分析。","like_count":0},{"had_liked":false,"id":214055,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1588646449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588646449","product_id":100017301,"comment_content":"斐波那契递归，用数组存储已经计算过的f（n）的值，这样每层只需要计算2个f(n)值就行了，复杂度可以降到o(n)。","like_count":0},{"had_liked":false,"id":209014,"user_name":"石*远","can_delete":false,"product_type":"c1","uid":1947613,"ip_address":"","ucode":"500BEC11AFC7FF","user_header":"https://static001.geekbang.org/account/avatar/00/1d/b7/dd/bd99be05.jpg","comment_is_top":false,"comment_ctime":1587480663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587480663","product_id":100017301,"comment_content":" 结论：f(n)=2f(n-1)-f(n-4)。<br>下面括号内数字代表已存在时间，即1（3）表示1个细胞已存在3小时,2（0）表示2个细胞活了0小时，即刚出生。<br>0：1(0)<br>1：1(0)+1(1)=2<br>2：2（0）+1（1）+1（2）=4<br>3：4（0）+2（1）+1（2）+1（3）=7【1（3）即1个存在了3小时，应该死亡了，所以不计数】<br>4：7（0）+4（1）+2（2）+1（3）= 13【1个存活3小时，要减去】<br>5：13（0）+7（1）+4（2）+2（3）=24【2个存活3小时，要减去】<br>6：24（0）+13（1）+7（2）+4（3）=44【4个存活3小时，要减去】<br>假设n=6,此时f(6)=2f(6-1)-f(6-4)可见每次都是删除满了3小时的，即f(n-4)要被减去","like_count":0},{"had_liked":false,"id":208834,"user_name":"百晓风","can_delete":false,"product_type":"c1","uid":1049682,"ip_address":"","ucode":"E837666B79F01A","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/52/97a81657.jpg","comment_is_top":false,"comment_ctime":1587445956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587445956","product_id":100017301,"comment_content":"按我的理解，我是这样子推导的，假设细胞到了第三个小时是先分裂完再死亡，那么递推公式是：<br>f(n) = 3 * f(n-1) - f(n-3)<br><br>例如：<br>n 从第 0 个小时开始，<br>n = 0，f(0) = 1<br><br>n = 1，f(1) = 2*f(0) + f(0) = 2 + 1 = 3<br><br>n = 2，f(2) = 2*f(1) + f(1) = 6 + 3 = 9<br><br>n = 3，f(3) = 2*f(2)  + f(2) - f(0)  = 18 + 9 - 1 = 26，减去存活了三个小时的细胞个数。<br><br>n = 4，f(4) = 2*f(3)  + f(3) - f(1)，减去存活了三个小时的细胞个数。<br><br>以此类推：<br><br>f(n) = 3*f(n-1) - f(n-3)，减去存活了三个小时的细胞个数。","like_count":0},{"had_liked":false,"id":208663,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1587396945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587396945","product_id":100017301,"comment_content":"第N个小时细胞数量f(n)=2f(n-1)-f(n-3)。<br>f(0)=2^0，f(1)=2^1，f(2)=2^2，f(3)=2^3 - 2^0，f(4)=2^4-2^1  …  f(n)=2^n-2^(n-3)  时间复杂度为2^(3n-3)","like_count":0},{"had_liked":false,"id":207498,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1587094600,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587094600","product_id":100017301,"comment_content":"function(n) {<br>    var deadNum = 0<br>    if (n - 3 &lt; 0)<br>        deadNum = 0<br>    else<br>        deadNum = f(n - 3)<br>    if (n == 1)<br>        return 2^0<br>    return 2*f(n - 1) - deadNum<br>}","like_count":0},{"had_liked":false,"id":206841,"user_name":"🐬🐬🐬","can_delete":false,"product_type":"c1","uid":1155214,"ip_address":"","ucode":"6585F8B8ADC43E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/8e/919dee01.jpg","comment_is_top":false,"comment_ctime":1586944070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586944070","product_id":100017301,"comment_content":"按照细胞先分裂再死亡的逻辑：<br>第0小时，细胞为一个 f(0) = 1<br>第1小时，细胞分裂一次后变为2个，包含原来的1个，总共3个 f(1) = 1*2 + 1<br>第2小时，上次的总数再分裂即6个，包含原来的3个，总共9个 f(2) = 2*3 + 3<br>第3小时，同理分裂后18个，包含原来的9个 减去第0小时的1个 总共26个 f(3) = 2*9 + 9 - 1<br>第4小时，同理分裂后52个，包含原来的26个 减去第1小时的3个 总共75个 f(4) = 2*26 + 26 - 3<br>……<br>所以 f(n) = 2*f(n-1)+f(n-1)-f(n-3) = 3*f(n-1)-f(n-3)","like_count":0},{"had_liked":false,"id":202471,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585993437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585993437","product_id":100017301,"comment_content":"&lt;?php<br>&#47;&#47;1 个细胞的生命周期是 3 小时，<br>&#47;&#47; 1 小时分裂一次。求 n 小时后，容器内有多少细胞？<br>&#47;&#47; 请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度<br><br>function cellsDivision($n) {<br>\tif ($n&lt;0) {<br>\t\techo &quot;输入数据不合法&quot;;<br>\t\treturn 0;<br>\t}<br>\tif($n==0) {<br>\t\treturn 1;<br>\t} elseif ($n==1) {<br>\t\treturn 2;<br>\t} elseif ($n==2) {<br>\t\treturn 4;<br>\t} elseif ($n==3) {<br>\t\treturn 7;<br>\t}<br>\t<br>\t$totalCount = 2*cellsDivision($n-1)-cellsDivision($n-3);<br>\treturn $totalCount;<br>}<br><br>echo cellsDivision(4);<br><br>echo &quot;&lt;br&gt;&quot;;<br>echo cellsDivision(5);","like_count":0},{"had_liked":false,"id":201147,"user_name":"Nullptr","can_delete":false,"product_type":"c1","uid":1911665,"ip_address":"","ucode":"8EC72438680F8D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLpCwvSDHKuwJklN3gosIbJh0AX97ULSXw4cgopjU28eQHR7DxcCWDFSBv7ZQJElBuCFu58xoWaTg/132","comment_is_top":false,"comment_ctime":1585723126,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585723126","product_id":100017301,"comment_content":"不是很明白，递归后面的交换是为了什么","like_count":0,"discussions":[{"author":{"id":1985779,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/4c/f3/6d6def2a.jpg","nickname":"张斌辉","note":"","ucode":"D8D2E278F86F15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380646,"discussion_content":"1234 先把 1 换到最后，递归，相当于把最后一位是1 的处理好了。然后要把1换回来，又变成1234 ，再把2换到最后一位，再递归，再换回来。以此类推。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624615296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199293,"user_name":"Wisdom","can_delete":false,"product_type":"c1","uid":1098980,"ip_address":"","ucode":"0787F954B66E93","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/e4/81ee2d8f.jpg","comment_is_top":false,"comment_ctime":1585485947,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585485947","product_id":100017301,"comment_content":"重温一下，又有了一点点新的收获。学习就是是个升级打怪的过程，停下来就可能升不了级","like_count":0},{"had_liked":false,"id":199033,"user_name":"zhimin","can_delete":false,"product_type":"c1","uid":1312130,"ip_address":"","ucode":"DF6DFBEF6FA297","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/82/51cd0a50.jpg","comment_is_top":false,"comment_ctime":1585477038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585477038","product_id":100017301,"comment_content":"怎么这一题老师没有给最佳答案呢。 <br>f(n) = f(n-1) * 2 - f(n-4)  推导的过程应该想减掉的是3小时前新增的细胞，原来的细胞已经死亡了。 所以减掉的应该是f(n-4)。<br>按照上面的推导。 每一层的复杂度是 2 ，层高是n ， 答案应该是 O(2^n) ","like_count":0},{"had_liked":false,"id":197193,"user_name":"Geek_35fa41","can_delete":false,"product_type":"c1","uid":1159037,"ip_address":"","ucode":"72239E0D1B3344","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/7d/4d8542a3.jpg","comment_is_top":false,"comment_ctime":1585362696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585362696","product_id":100017301,"comment_content":"f(n)=2^(n-2)+2^(n-1)+2^n. n&gt;=3","like_count":0},{"had_liked":false,"id":196623,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1585297848,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585297848","product_id":100017301,"comment_content":"打卡，第3个例子的代码没有看懂。。难过。。。我再多研究一下。感觉有点难度了","like_count":0},{"had_liked":false,"id":196280,"user_name":"CDz","can_delete":false,"product_type":"c1","uid":1114779,"ip_address":"","ucode":"A23BEE1C4A5922","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9b/b1a3c60d.jpg","comment_is_top":false,"comment_ctime":1585269343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585269343","product_id":100017301,"comment_content":"假设到点后 先分裂后死亡<br><br>f(n)=2f(n-1)-(f(n-3)-f(n-4))<br><br>时间复杂度O(2^n)","like_count":0},{"had_liked":false,"id":194773,"user_name":"习兮习兮","can_delete":false,"product_type":"c1","uid":1367043,"ip_address":"","ucode":"E616E924188CBA","user_header":"https://static001.geekbang.org/account/avatar/00/14/dc/03/ad9574b3.jpg","comment_is_top":false,"comment_ctime":1585104875,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585104875","product_id":100017301,"comment_content":"看留言思考题似乎都是使用递归公式来进行计算的；这章的主题不是递归树么？分享下个人的理解，看是否正确：<br>分裂这个情况个人觉得会是一个满二叉树；<br>最终的值应该是 count = f(h) - f(h-3), h为树的深度； 而对于满二叉树明显有：f(n) = 2^n；<br>故 count(n) = 2^n - 2^(n-3) = 7*2^(n-3);<br>忽略系数，所以时间复杂度为 O(2^n);","like_count":0},{"had_liked":false,"id":189574,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1584530098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584530098","product_id":100017301,"comment_content":"我觉得很奇怪，细胞一直在分裂，既然一直在分裂，不就是每次都是新细胞么，那么，前一个小时的那个细胞不就变成两个新细胞了么，细胞就一直不会死啊，如果你说他的周期是三小时，那三小时前那个细胞去哪了，他不是已经死了么，变成2个细胞了","like_count":0},{"had_liked":false,"id":189427,"user_name":"问心","can_delete":false,"product_type":"c1","uid":1250775,"ip_address":"","ucode":"6808568D61CE36","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/d7/96e77edd.jpg","comment_is_top":false,"comment_ctime":1584515146,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584515146","product_id":100017301,"comment_content":"f(0) = 1<br>f(1) = 2<br>f(2) = 2*f(1)<br>f(3) = 2*f(2) - f(0)<br>f(4) = 2*f(3) - [f(1) - f(0)]<br>f(5) = 2*f(4) - [f(2) - f1(1)]","like_count":0},{"had_liked":false,"id":189406,"user_name":"獨自去遠方","can_delete":false,"product_type":"c1","uid":1503941,"ip_address":"","ucode":"E246B33F397441","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/c5/2a441c27.jpg","comment_is_top":false,"comment_ctime":1584512964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584512964","product_id":100017301,"comment_content":"递归树<br>\t将递归过程分解画成树<br><br>\t归并排序<br>\t\t分解操作：代价低<br>\t\t归并操作：<br>\t\t\t每层操作时间相同，都是n<br>\t\t\t树的高度是log2n<br>            所以归并排序的时间复杂度：nlgn<br><br>    快速排序<br>        最好情况：每次都一分为二 T(n)=2T(n&#47;2)+n,时间复杂度为：O(nlogn)<br>        假设每次分区比例为1:9<br>            T(n)=T(n&#47;10)+T(9n&#47;10)+n<br>            每层操作遍历的所有数据为n，最长路径为log（10&#47;9）n, <br>            最短路径为log10 n,遍历数据总和在nlog（10&#47;9）n和nlog10 n之间<br><br><br>    斐波那契数列<br>        每次走1或2，最短路径为n&#47;2, 最长路径为n<br>        路径长度都为1，总和为2^n-1<br>        路径长度都为2，总和为2^(n&#47;2)-1<br><br>    全排列<br>        路径表示为：n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1<br>        O(n!)&lt;T(n)&lt;O(n*n!)<br>","like_count":0},{"had_liked":false,"id":189091,"user_name":"chenzesam","can_delete":false,"product_type":"c1","uid":1045011,"ip_address":"","ucode":"34E76BB9C7618D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/13/3ee5a9b4.jpg","comment_is_top":false,"comment_ctime":1584455125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584455125","product_id":100017301,"comment_content":"方法论真好","like_count":0},{"had_liked":false,"id":184723,"user_name":"孙思强","can_delete":false,"product_type":"c1","uid":1813790,"ip_address":"","ucode":"6E3F01DDFC1310","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ad/1e/aeb8d6f3.jpg","comment_is_top":false,"comment_ctime":1583391386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583391386","product_id":100017301,"comment_content":"f（0）=1；f（1）=2；f（2）=4；f（n）=2f（n-1）-f（n-3）；；","like_count":0},{"had_liked":false,"id":183718,"user_name":"佳娃","can_delete":false,"product_type":"c1","uid":1806618,"ip_address":"","ucode":"47004C40CBE019","user_header":"https://static001.geekbang.org/account/avatar/00/1b/91/1a/c51b24f4.jpg","comment_is_top":false,"comment_ctime":1583119884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583119884","product_id":100017301,"comment_content":"留言少又不等于没人学了，底子弱，我就默默做笔记，看有价值的留言。<br>这一章提到的快排，归并排序，我又回去复习了一遍😌。","like_count":0},{"had_liked":false,"id":183611,"user_name":"社会你强哥","can_delete":false,"product_type":"c1","uid":1243570,"ip_address":"","ucode":"325B9005588D9B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","comment_is_top":false,"comment_ctime":1583077372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583077372","product_id":100017301,"comment_content":"说实话，快排递推树，不一定每层都有n次运算，每层运算在1和n之间，最好复杂度才是nlogn，平均复杂度作者求出来的也是nlogn,真不理解，我建议写成区间形式吧。","like_count":0},{"had_liked":false,"id":173847,"user_name":"抱小星","can_delete":false,"product_type":"c1","uid":1504652,"ip_address":"","ucode":"BA7B0DAFDA4AF5","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/8c/82fb5890.jpg","comment_is_top":false,"comment_ctime":1579738540,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1579738540","product_id":100017301,"comment_content":"可以这么想，n时刻新生细胞是fnew（n），那么总细胞f（n）=fnew（n+1），因为下一时刻会分裂。<br>然后 fnew（n）=fnew（n-1）+fnew（n-2）+fnew（n-3），因为只有前三个小时的细胞活着，会分裂。<br><br>递推化简消去fnew可得，f（n）=2*f（n-1）-f（n-4）","like_count":0},{"had_liked":false,"id":169511,"user_name":"全麦小面包","can_delete":false,"product_type":"c1","uid":1086413,"ip_address":"","ucode":"823C65BF366097","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/cd/dbafc7d1.jpg","comment_is_top":false,"comment_ctime":1578367201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578367201","product_id":100017301,"comment_content":"全排列的递归代码中,for循环里的后面的数据交换“tmp = data[i];    data[i] = data[k-1];    data[k-1] = tmp;”不是很理解。虽然通过断点知道，这个数据交换是有必要的，但这是怎么想出来的呢？有没有什么可以让人理解的总结？","like_count":0},{"had_liked":false,"id":167064,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1577681027,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577681027","product_id":100017301,"comment_content":"借助递归树来分析递归算法的时间复杂度<br><br>一：递归树与时间复杂度分析<br><br>\t1，递归思想就是将大问题分解为小问题来求解，然后在将小问题分解为小小问题，将问题一层一层地分解，直到问题的数据规模被分解得足够小，不要继递归分解为止。<br><br>\t2，用递归树来求解归并排序的时间复杂度<br>\t <br>\t①：每次分解是一分为二，所以代价很低，将时间上的消耗记作常量1。<br>\t②：归并算法中比较耗时的归并操作，也就是把两个子数组合并为大数组<br>\t③：每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关，将每层归并操作消耗的时间记作n。<br>\t④：我们只需要知道这颗树的高度h,用高度乘以每层的时间消耗n,就可以得到总的时间复杂度O(n*h)。<br>\t⑤：从归并排序的原理和递归树，可知归并排序递归树是一颗满二叉树，满二叉树的高度大约为log2n，所以归并排序递归实现的时间复杂度就是O(nlogn)。<br><br>二：分析快速排序的时间复杂度<br>\t①：快速排序在最好情况下，每次分区都能一份为二，这个时候用递归公式T(n)=2T(n&#47;2)+n，可以推导出时间复杂度是O(nlogn)。<br>\t②：但并不是总能非常平均的分区，所以通过公式推导时间复杂度会非常复杂。<br>\t③：快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是n。只要求出递归树的高度h，这个快排过程遍历的数据个数就是h*n，即时间复杂度就是O(h*n)。<br>\t④：因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。<br>\t⑤：因为快速排序结束的条件是待排序的小区间，大小为1，即叶子节点里的数据规模是1。<br>\t⑥：从根节点n到叶子节点1，递归树中最短的一个路径每次都乘以1&#47;10，最长的一个路径每次都乘以9&#47;10。<br>\t⑦：通过计算，从根节点到叶子点最短路径是log10n,最长的路径是log10&#47;9 n。<br> <br><br>\t⑧：遍历数据的个数总和就介于nlog10n和nlog10&#47;9 n之间。根据复杂度O表示法规则，当分区大小比例是1:9时，快速排序的时间复杂度仍然是O(nlogn)。<br>\t<br>三：斐波那契数列的时间复杂度<br> <br><br>\t①：f(n)分解为f(n-1)和f(n-2)，每次数据规模都是-1或-2，叶子节点的数据规模是1或2。所以从根节点走到叶子节点，每条路径是长短不一的。<br>\t②：如果每次都是-1，那最长路径大约就是n；如果每次都是-2，那最短路径大约就是n&#47;2。<br>\t③：第k层的时间消耗是2(^k-1)，总时间消耗之和是2^n -1<br><br>四：分析全排列的时间复杂度<br><br>n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1<br>","like_count":0},{"had_liked":false,"id":166614,"user_name":"Geek_8c5f9c","can_delete":false,"product_type":"c1","uid":1596047,"ip_address":"","ucode":"70CD441EAF490F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","comment_is_top":false,"comment_ctime":1577519610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577519610","product_id":100017301,"comment_content":"如果细胞不会死亡，递归树为<br>f(n) = 2f(n-1) = 2^2f(n-2) = 2^3f(n-3) = .... 2^(h-1) f(1) = 2^ (h) f(1)<br>其中h 为树的层树，也为分裂的次数。n天意味着分裂n次，所以 <br>第n天时的活着的细胞数量为2^n + 2^(n-1)+2^(n-2).<br><br><br><br>时间复杂度应该是在O(2^n)量级的<br>","like_count":0},{"had_liked":false,"id":164856,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1577100861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577100861","product_id":100017301,"comment_content":"细胞分裂: f(0)=1, f(1)=2f(0)=2, f(2)=2f(1)=4, f(3)=2f(2) - f(0)=7, f(4)=2f(3) - f(0)=13, f(n)=2f(n-1) - f(n-4)","like_count":0},{"had_liked":false,"id":163795,"user_name":"zzh","can_delete":false,"product_type":"c1","uid":1174510,"ip_address":"","ucode":"0FC6BD729E5801","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJmcPTvjtSbhBNic4wb61Pj77nIHcLG64MnAXicsHBrMWvjCQPoiaHTtYmbnlVSkSWZEnN2QlicekqLhg/132","comment_is_top":false,"comment_ctime":1576803920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576803920","product_id":100017301,"comment_content":"printPermutations(data, n, k - 1);<br>老师，我认为这里的n也应该减一吧。<br>否则第二层 变成了 用{1 2 3 4} 进行3位数的全排列？   好像不对了吧","like_count":0},{"had_liked":false,"id":162815,"user_name":"haleli","can_delete":false,"product_type":"c1","uid":1329407,"ip_address":"","ucode":"A07143F6E2125B","user_header":"https://static001.geekbang.org/account/avatar/00/14/48/ff/17e4c732.jpg","comment_is_top":false,"comment_ctime":1576594137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576594137","product_id":100017301,"comment_content":"看了评论，不是很认同，最终容器内有多少细胞，难道不是分裂后的数量加分裂前的再减去死亡的吗。<br>假设先分裂，后死亡<br>n=0  f(0)=1<br>n=1   f(1)=2*f(0)+f(0)=3f(0)=3<br>n=2  f(2)=2f(1)+f(1)=3f(1)=9<br>n=3  f(3)=2f(2)+f(2)-f(0)=26<br>所以递归为：f(n)=3f(n-1)-f(n-3)  ,f(0)=1,f(1)=3,f(2)=9<br>","like_count":0},{"had_liked":false,"id":162326,"user_name":"分清云淡","can_delete":false,"product_type":"c1","uid":1269873,"ip_address":"","ucode":"7045AE6BF72D31","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","comment_is_top":false,"comment_ctime":1576500441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576500441","product_id":100017301,"comment_content":"思考题：<br>按照此处分析斐波那数列的方法 这个时间复杂度 是 2^2&#47;n 到 2^n 不论 推到式 fn = fn_1 - fn_4<br>但是 这个斐波那 和这个细胞题 都可以 使用空间 换成 线性的复杂度吧","like_count":0},{"had_liked":false,"id":162125,"user_name":"Panda🐟","can_delete":false,"product_type":"c1","uid":1002401,"ip_address":"","ucode":"C6007A3192516A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/a1/c2719a5a.jpg","comment_is_top":false,"comment_ctime":1576464035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576464035","product_id":100017301,"comment_content":" 递归树<br> <br> 计算次数:二叉树节点         -时间&#47;<br> 1: 1                     -0<br> 2: 2-2                   -1<br> 4: 3-3 3-3               -2<br> 8 + 1: 4-4 4-4 4-4 4-4   -3<br> 16 + 4: ...<br> ...<br> <br> 求和<br> 1+2+4+8..+2n + 1+2+..2(n-3) = 2^n-1 + 2^(n-3)-1 = O(2^n)","like_count":0},{"had_liked":false,"id":158662,"user_name":"777","can_delete":false,"product_type":"c1","uid":1284303,"ip_address":"","ucode":"F080BFCB9A87C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/98/cf/7cd3b8e3.jpg","comment_is_top":false,"comment_ctime":1575429202,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575429202","product_id":100017301,"comment_content":"1个细胞，每1小时分裂成2个，分裂3次之后，本体会死掉。n个小时之后，有多少个细胞？<br>比如0小时的时候，培养皿中放入1个细胞，1小时的时候分裂成2个，2小时的时候分裂成4个，3小时本来分裂成8个，但是最先的1个本体已经分裂了3次，它死掉，最终剩下7个。下面是列举的时间以及对应的细胞数：<br>0 1 2 3<br>1 2 4 7<br><br>将n个小时的细胞数定义为f(n)，像这种知道f(0)，f(1)，f(2)...，要你推算f(n)的题目，是面试的时候经常遇到的一类题目。f(n)的结果与前面已知的f(n-1)或者f(n-2)...f(n-k)有关，重点是要找出f(n)的递推公式，有了递推公式之后，可以很容易用递归来实现，就像斐波拉契数列f(n)=f(n-1)+f(n-2)用递归来实现类似。<br><br>回到这一题，细胞分裂分成两个步骤，先分裂，再死亡。比如第4小时，先从3小时的7个细胞分裂即乘2为14个，然后计算死亡的细胞，直观上来说我们会认为第1小时的细胞此时分裂了3次，会死掉，最终是7x2-2=12个细胞，得到公式f(n)=f(n-1)x2-f(n-3)。<br><br>但这是错误的，因为第1小时的2个细胞中有一个已经在第3小时死掉了，因此第4小时只会死1个细胞，正确答案是14-1=13。<br><br>从上面的分析来看第二个步骤中死亡的细胞数计算，死掉的细胞数并不是前3小时的细胞总数f(n-3)，因为这里面包含n-3时刻新生的细胞和老细胞，很显然老细胞在n时刻之前就已经死完了。此时死掉的细胞数应该是n-3时刻新生的细胞数，而n-3时刻新生的细胞数正是前一时刻分裂而来的即f(n-4)，因此正确的计算公式是f(n)=f(n-1)x2-f(n-4)。","like_count":0,"discussions":[{"author":{"id":1109640,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/88/a890b41e.jpg","nickname":"chris","note":"","ucode":"6663E3E09457E3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209570,"discussion_content":"分析得很棒！👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584637286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158220,"user_name":"倡印","can_delete":false,"product_type":"c1","uid":1455958,"ip_address":"","ucode":"4F53AA5D017D89","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","comment_is_top":false,"comment_ctime":1575353019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575353019","product_id":100017301,"comment_content":"f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 2n​。<br><br>关于这段刚开始看有个疑问🤔️啥是 “-1” “-2”。这个只有自己画个图就能明白到底说了个啥。只要把递归树f（n-2）统一画在左子树，f（n-1）统一画在右子树就能看出到底是什么关系。很明显是个歪脖子树-1的就是这个树的最长路径，-2的就是最短路径。","like_count":0},{"had_liked":false,"id":155701,"user_name":"握不住手中沙","can_delete":false,"product_type":"c1","uid":1097132,"ip_address":"","ucode":"F194E47C4D42C9","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/ac/49494ed8.jpg","comment_is_top":false,"comment_ctime":1574738752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574738752","product_id":100017301,"comment_content":"思考题：<br>1、递推公式：f(n) = f(n-1)*2 - f(n-3)，最高树有N层，最短的是N&#47;3层，每层操作呈指数增长，时间复杂度为O(2^n)","like_count":0},{"had_liked":false,"id":151560,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1573740186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573740186","product_id":100017301,"comment_content":"其实这个也是错的，因为n时刻死掉的，并不是f(n-4)因为f(n-4)中部分早在fn之前死了，所以应该减去2^(n-3)<br>答案是f(n)  = 2 * f(n-1)- 2^(n-3)","like_count":0},{"had_liked":false,"id":151385,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1573711701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573711701","product_id":100017301,"comment_content":"思考题有一个疑惑点，细胞分裂后，两个细胞都是一样的新细胞，生命周期应该又从零开始。所以一个细胞不等三小时就获得了新生，所以n小时后细胞的总数就是 2^n。而题目中的细胞能活3小时，是指一个细胞如果停止分裂后，能活三小时。读懂题目很关键。","like_count":0},{"had_liked":false,"id":150645,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1573573580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573573580","product_id":100017301,"comment_content":"现在好多lambda表达式，lambda表达式怎么分析时间复杂度？","like_count":0},{"had_liked":false,"id":149607,"user_name":"anker","can_delete":false,"product_type":"c1","uid":1218937,"ip_address":"","ucode":"6EDF1FB9D45238","user_header":"https://static001.geekbang.org/account/avatar/00/12/99/79/74d4f24f.jpg","comment_is_top":false,"comment_ctime":1573289294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573289294","product_id":100017301,"comment_content":"function f(time,i0,i1,i2){<br>    i0 = i0 || 1;<br>    i1 = i1 || 0;<br>    i2 = i2 || 0;<br>    <br>    if(time == 0){<br>        return  i0 + i1 + i2;<br>    }<br>    <br>    return f(time - 1, (i1 + i2) &lt;&lt; 1,i0,i1);<br>}","like_count":0},{"had_liked":false,"id":140299,"user_name":"Joiner","can_delete":false,"product_type":"c1","uid":1071941,"ip_address":"","ucode":"7F67D4C325E71F","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","comment_is_top":false,"comment_ctime":1570872985,"is_pvip":false,"replies":[{"id":"54239","content":"那得具体问题具体分析了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570916479,"ip_address":"","comment_id":140299,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570872985","product_id":100017301,"comment_content":"老师，对于两种递归代码的时间复杂度分析方法都不适用的递归代码，还有其他的方法吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470335,"discussion_content":"那得具体问题具体分析了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570916479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135620,"user_name":"junjun","can_delete":false,"product_type":"c1","uid":1547322,"ip_address":"","ucode":"1F7EE146B9BE04","user_header":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","comment_is_top":false,"comment_ctime":1569230209,"is_pvip":false,"replies":[{"id":"52765","content":"存在的，到期才死亡的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1569710403,"ip_address":"","comment_id":135620,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569230209","product_id":100017301,"comment_content":"我没明白一个细胞分裂为两个之后，自身还存在不，如果不存在，那怎么会死亡呢？只有不存在的时候，才是f（n） = 2 * f（n-1） - f（n-3）","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468274,"discussion_content":"存在的，到期才死亡的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569710403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135595,"user_name":"Hwan","can_delete":false,"product_type":"c1","uid":1205627,"ip_address":"","ucode":"A728C6790511BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","comment_is_top":false,"comment_ctime":1569224423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569224423","product_id":100017301,"comment_content":"代码示例：(假设n=1时为初始时候，此时有一个细胞，如果按照n=0开始也可以)<br>def all_cell2(n: int) -&gt; int:<br>    if n == 1:<br>        return 1<br>    elif n == 2:<br>        return 2<br>    elif n == 3:<br>        return 4<br>    elif n == 4:<br>        return 7<br>    else:<br>        return 2 * all_cell2(n-1) - all_cell2(n-4)<br>除了找规律和不完全推导的方法，自己解释下为啥是n-4，而不是n-3,假设此时n=6,那么我们应该减掉这个先分裂然后死亡的那部分细胞，<br>但是这部分细胞其实是n=2到n=3这一波分裂的细胞，不能减去f(n-3)，因为f(n-3)里面有部分细胞在之前已经死亡了","like_count":0},{"had_liked":false,"id":134924,"user_name":"ITACHI","can_delete":false,"product_type":"c1","uid":1260500,"ip_address":"","ucode":"4EE419128ED9E8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/d4/e4bfb25f.jpg","comment_is_top":false,"comment_ctime":1568955074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568955074","product_id":100017301,"comment_content":"1.老师，求全排列那个是在if（k==1）那个判断做完后return吧？<br>2.思考题我看评论区主要有两种观点在争论，2f(n-1)-f(n-3)和2f(n-1)-f(n-4)，哪个是对的啊？好像后者？","like_count":0},{"had_liked":false,"id":133873,"user_name":"Never too late","can_delete":false,"product_type":"c1","uid":1250748,"ip_address":"","ucode":"A6ECC0D3907181","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/bc/20ffd8d1.jpg","comment_is_top":false,"comment_ctime":1568688483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568688483","product_id":100017301,"comment_content":"推算方法为：<br>\tpublic static int countNumByTime(int n)<br>\t{<br>\t\tif (n &lt;0 ) {<br>\t\t\treturn 0;<br>\t\t}<br>\t\telse if (n == 0) {<br>\t\t\treturn 1;<br>\t\t}<br>\t\telse<br>\t\t{<br>\t\t\treturn 2*(countNumByTime(n-1) - countNumByTime(n-3));<br>\t\t}<br>\t}<br><br>时间复杂度为：<br>2^n - 2^(n-4) = 2^(n-4) * (16 - 1) = 2^(n-4) * 15 = 2^(n-4) = 2^n;","like_count":0},{"had_liked":false,"id":126840,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1566487899,"is_pvip":false,"replies":[{"id":"47240","content":"你是指的哪个问题呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566773502,"ip_address":"","comment_id":126840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566487899","product_id":100017301,"comment_content":"到底哪个是正确的方法？？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464195,"discussion_content":"你是指的哪个问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566773502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122428,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1565364184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565364184","product_id":100017301,"comment_content":"老师太伟大了！那个计算 permutation 的方法真的好清晰易懂！！！<br>建议大家也可以去尝试一下 leetcode 46 题在学完 backtracking 之后！然后尝试着自己分析一下时间复杂度！","like_count":0},{"had_liked":false,"id":121271,"user_name":"Geek_86533a","can_delete":false,"product_type":"c1","uid":1610333,"ip_address":"","ucode":"6961C429E8953A","user_header":"","comment_is_top":false,"comment_ctime":1565091717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565091717","product_id":100017301,"comment_content":"感谢老师！明白了很多之前不愿意去深入想的东西。","like_count":0},{"had_liked":false,"id":120351,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1564840312,"is_pvip":false,"replies":[{"id":"44224","content":"参考斐波那契数列的那个推导","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564959947,"ip_address":"","comment_id":120351,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564840312","product_id":100017301,"comment_content":"思考题：根据题意，初始细胞数1个，1小时后分裂为2个，2小时后，2个细胞分裂为4个，3小时后，最早的那个细胞死亡，剩下的三个细胞各自分裂出一个细胞，总数为6个，自3小时后，<br>每经过一小时，都会有一个细胞死亡，因此，递归表达式：f(n) = (f(n-1)-1) * 2，递归终止条件：f(3) = 6，根据递归表达式画出递归树：<br><br>递归树：<br>f(n)<br>|<br>|<br>(f(n-1)-1) * 2<br>|<br>|<br>(f(n-2)-1) * 2<br>|<br>|<br>....<br>|<br>|<br>f(3) = 6<br><br>树的高度为：h = n-3，每一层的运算次数只有一次，因此时间复杂度O(h) = O(n-3) = O(n)<br><br>以上理解不知是否正确，请老师指正。<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461298,"discussion_content":"参考斐波那契数列的那个推导","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564959947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109173,"user_name":"Geek_18b741","can_delete":false,"product_type":"c1","uid":1368496,"ip_address":"","ucode":"097BA0C2F44150","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlztvlBgajZMEph8AvkP2pfoqNCGtYSalIKgrCbCg0MWDZJgJwqVRfWA6cgIoZicL6dKibfK0zjsWg/132","comment_is_top":false,"comment_ctime":1561974830,"is_pvip":false,"replies":[{"id":"39584","content":"你说都没错，并不是一颗很规则的树，是一个斜着的歪歪的树，所以我们在分析复杂度的时候，提到了最短路径、最长路径。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562024496,"ip_address":"","comment_id":109173,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561974830","product_id":100017301,"comment_content":"关于斐波那契数列的复杂度问题，我有疑问。文章说每层计算量是2^(k-1)，是逐渐增加的，可是我画了一个f(6)的树，计算量分别是1、2、2、1。一开始确实是增加的，但是到了后面，因为有些路径很早就结束了，所以不是越来越多呀。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456281,"discussion_content":"你说都没错，并不是一颗很规则的树，是一个斜着的歪歪的树，所以我们在分析复杂度的时候，提到了最短路径、最长路径。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562024496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109047,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561952406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561952406","product_id":100017301,"comment_content":"求解时间复杂度：递推公式 &amp; 递归树<br>递归树求解时间复杂度的技巧：将每层调用关系树形化，通过计算树的高度和每层的时间复杂度得到整体的时间复杂度或时间复杂度区间","like_count":0},{"had_liked":false,"id":102250,"user_name":"amither","can_delete":false,"product_type":"c1","uid":1486268,"ip_address":"","ucode":"2F13956D35B752","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SKmvhbNe9LMPQ0ib8ZqbJEYQdkHs9B4icOsU9mcbDh0XpeEibC1zXIq0q7ZS12dRzv32hOdzpubUKLFgAeIKQYZgg/132","comment_is_top":false,"comment_ctime":1560170304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560170304","product_id":100017301,"comment_content":"相当于只有最下面3层的2叉树，O(2^n)","like_count":0},{"had_liked":false,"id":102156,"user_name":"꧁花间一壶酒꧂","can_delete":false,"product_type":"c1","uid":1542238,"ip_address":"","ucode":"71CBBCFC4A926E","user_header":"https://static001.geekbang.org/account/avatar/00/17/88/5e/e9a8417d.jpg","comment_is_top":false,"comment_ctime":1560153463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560153463","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":97972,"user_name":"Tom","can_delete":false,"product_type":"c1","uid":1074968,"ip_address":"","ucode":"5940DF3B4782DC","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/18/79167fa2.jpg","comment_is_top":false,"comment_ctime":1558857189,"is_pvip":false,"replies":[{"id":"35625","content":"排列组合的，你可以网上搜下如何写。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559176013,"ip_address":"","comment_id":97972,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558857189","product_id":100017301,"comment_content":"第三个案例的递归代码看了几遍没看懂，老师能否再详细分解描述一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451498,"discussion_content":"排列组合的，你可以网上搜下如何写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559176013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95944,"user_name":"瑜儿游~","can_delete":false,"product_type":"c1","uid":1535382,"ip_address":"","ucode":"9CEA9CD02E2608","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKpQVnf7ibib5NibF28Te8wlqOVL3XpMvGWpOr99rsYwtcEOyBggIsibleu8Odh9MdQ2ic19EWbDBwDkTA/132","comment_is_top":false,"comment_ctime":1558267223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558267223","product_id":100017301,"comment_content":"n = 0，f(0) = 1<br><br>n = 1，f(1) = 2*f(1)<br><br>n = 2，f(2) = 2*f(1)<br><br>n&gt;=3, f(n)= 2*f(n-1)-f(n-3)<br><br>用递归树来分析复杂度，从根节点到叶子结点最长路径为n,最短路径n&#47;3<br>时间复杂度在O(2^n)-O(2^n&#47;3)之间<br>","like_count":0},{"had_liked":false,"id":94746,"user_name":"宋群豪Joe","can_delete":false,"product_type":"c1","uid":1005644,"ip_address":"","ucode":"640B8CAEE57391","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/4c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1557888506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557888506","product_id":100017301,"comment_content":"我觉得递推公式是这样的：<br>f(firstGen, secondGen, thirdGen, n) =<br>      f(firstGen + secondGen + thirdGen, firstGen, secondGen, n - 1)<br>用三个参数来表示每一代细胞的数量，一开始是1，0，0。n等于0的时候返回三代所有细胞数的总和。根据我下面的实现的话时间复杂度是O(n)。不知道最终能不能简化成一个公司直接用O(1)的复杂度推出来。有两种特殊情况应该都是能用一个公式推导出来的：细胞不会死、细胞一个小时就死。<br>def f(firstGen: Int, secondGen: Int, thirdGen: Int, n: Int): Int = {<br>      if (n == 0) {<br>        firstGen + secondGen + thirdGen<br>      } else {<br>        val newBorn = firstGen + secondGen + thirdGen<br>        f(newBorn, firstGen, secondGen, n - 1)<br>      }<br>    }","like_count":0},{"had_liked":false,"id":94526,"user_name":"Shawn","can_delete":false,"product_type":"c1","uid":1014729,"ip_address":"","ucode":"B95D7B54465DE4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/c9/75c9002e.jpg","comment_is_top":false,"comment_ctime":1557833966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557833966","product_id":100017301,"comment_content":"细胞到达三个小时，直接死亡，不分裂","like_count":0},{"had_liked":false,"id":94525,"user_name":"Shawn","can_delete":false,"product_type":"c1","uid":1014729,"ip_address":"","ucode":"B95D7B54465DE4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/c9/75c9002e.jpg","comment_is_top":false,"comment_ctime":1557833800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557833800","product_id":100017301,"comment_content":"第N小时新生成的细胞数为第N-1小时的存在细胞数。<br>第N小时细胞数等于第N-1小时细胞数翻倍后减去第N-3小时新生成细胞数。<br>第N-3小时新生成细胞数为第N-4小时细胞数。<br><br>f(0) = 1<br>f(1) = 2<br>f(2) = 4<br>f(3) = 7<br>f(n) = 2 * f(n-1) - f(n - 4)<br>","like_count":0},{"had_liked":false,"id":91918,"user_name":"箭指流云","can_delete":false,"product_type":"c1","uid":1367877,"ip_address":"","ucode":"21571A7D60B10D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/VqgchrJWswwSLmxf1ict6icDDlZG5wChBEiaiblnJAQEdu1nYtB4EZq07mibUurOSDFr16dho6DhGyOpIW4eib57lK8Q/132","comment_is_top":false,"comment_ctime":1557134197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557134197","product_id":100017301,"comment_content":"真的是有点看不动了，开头没立flag,现在立一个，坚持认真看完","like_count":0},{"had_liked":false,"id":90215,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1158747,"ip_address":"","ucode":"AF27064128CA95","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/5b/a401a20c.jpg","comment_is_top":false,"comment_ctime":1556449783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556449783","product_id":100017301,"comment_content":"一个细胞分裂为两个细胞后，新的细胞各占原有细胞的1&#47;2，那这两个新细胞寿命是新的3小时，还是说都只有2小时的寿命呢，表示这个例子逻辑没太懂？","like_count":0},{"had_liked":false,"id":88000,"user_name":"小高","can_delete":false,"product_type":"c1","uid":1283052,"ip_address":"","ucode":"FCD422249F7355","user_header":"https://static001.geekbang.org/account/avatar/00/13/93/ec/985675c8.jpg","comment_is_top":false,"comment_ctime":1555807038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555807038","product_id":100017301,"comment_content":"在技术的道路上持续付出，加油！","like_count":0},{"had_liked":false,"id":86899,"user_name":"yshnb!","can_delete":false,"product_type":"c1","uid":1488301,"ip_address":"","ucode":"E93A9132532492","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/ad/587a45dc.jpg","comment_is_top":false,"comment_ctime":1555472389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555472389","product_id":100017301,"comment_content":"跟着走下来，对思考题已经能有一定思路了，收获很大","like_count":0},{"had_liked":false,"id":81307,"user_name":"杨伟","can_delete":false,"product_type":"c1","uid":1239937,"ip_address":"","ucode":"D5B521A0688E02","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/81/43f4b52c.jpg","comment_is_top":false,"comment_ctime":1553854536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553854536","product_id":100017301,"comment_content":"新思路","like_count":0},{"had_liked":false,"id":79295,"user_name":"好雨当春","can_delete":false,"product_type":"c1","uid":1241934,"ip_address":"","ucode":"64B1C92911B898","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/4e/bcb436aa.jpg","comment_is_top":false,"comment_ctime":1553426883,"is_pvip":false,"replies":[{"id":"28966","content":"没有太看懂你说的呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553477257,"ip_address":"","comment_id":79295,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553426883","product_id":100017301,"comment_content":"既然原递归问题等价于子递归问题，那就应该直接跳到最后的叶子递归问题求时间复杂度就好了吧，叶子结点以前的时间应该不再计算了吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444437,"discussion_content":"没有太看懂你说的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553477257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77609,"user_name":"曾田 💬","can_delete":false,"product_type":"c1","uid":1114080,"ip_address":"","ucode":"FC87BEE84A9B8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/e0/9a29757e.jpg","comment_is_top":false,"comment_ctime":1552971728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552971728","product_id":100017301,"comment_content":"每一层 = 前一个小时的细胞数乘以2 再减去前3个小时的细胞数<br>所以 f(n)=2*f(n-1) - f(n-3)<br>最长路径是n：每一次都减1<br>最短路径是n&#47;3：每一次都减3<br>每一层的时间消耗为 2^(n-1)<br>最长路径总和为：1+2+4+...+2^(n-1)<br>最短路径总和为：1+2+4+...+2^(n&#47;3-1)<br>所以时间复杂度介于 O(2^(n&#47;3)) 和 O(2^n) 之间<br>","like_count":0},{"had_liked":false,"id":69550,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1550763244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550763244","product_id":100017301,"comment_content":"打卡，使用递归树的思想来分析时间复杂度！","like_count":0},{"had_liked":false,"id":66873,"user_name":"Bryce","can_delete":false,"product_type":"c1","uid":1286669,"ip_address":"","ucode":"E504AB8F2CA1A1","user_header":"https://static001.geekbang.org/account/avatar/00/13/a2/0d/e72f5e75.jpg","comment_is_top":false,"comment_ctime":1550033535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550033535","product_id":100017301,"comment_content":"复杂度的分析根据递推式 f(n) = 2 * f(n - 1) - f(n - 4) 以及老师对斐波那契的分析，<br>在细胞分裂里，最短路径是 n &#47; 4，最长路径是 n，<br>如果路径长度都为 n &#47; 4，那么总时间消耗为：1 + 2 + 2^2 + ..... + 2^(n&#47;4 - 1) = 2^(n&#47;4) - 1<br>路径长度为 n 时和斐波那契一致，即 2^n - 1<br>所以时间复杂度介于 O(2^n) 和 O(2^(n&#47;4)) 之间<br>","like_count":0},{"had_liked":false,"id":66275,"user_name":"Linger","can_delete":false,"product_type":"c1","uid":1139997,"ip_address":"","ucode":"029D4F06410197","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/1d/ee50f6f1.jpg","comment_is_top":false,"comment_ctime":1549901815,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1549901815","product_id":100017301,"comment_content":"以细胞分裂之后再死亡的前提下:<br>第一小时:2<br>第二小时:4<br>第三小时:7<br>第四小时:13<br>第五小时:24<br>第六小时:44<br>第七小时:82<br>公式f(n)=2f(n-1)-(f(n-3)-f(n-4))<br>这里解释一下为什么是(f(n-3)-f(n-4))，现有细胞数是由一小时前的细胞分裂过来的，因此在分裂完成之后三小时前的细胞要死亡，而在分裂进行n小时后，三小时前的细胞数应该是(f(n-3)-f(n-4))而不是f(n-3),这是因为f(n-3)的细胞群是由f(n-4)分裂而来，而f(n-4)已经在一小时前死亡。","like_count":0,"discussions":[{"author":{"id":1042208,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e7/20/70a95f94.jpg","nickname":"潮汐","note":"","ucode":"F5E4F6DF9CEA9E","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53561,"discussion_content":"你这样思路，应该是第六45，第七84吧？\n我也是这样思考的f(n)=2*f(n-1)-f(n-3)+f(n-4)\n跟热评第一条的区别应该是考不考虑分裂完旧的细胞算不算全新细胞。\n热评第一条还是把思想说的很浅显明了的，大道至简应该是这样的状态吧😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574175971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66086,"user_name":"winter","can_delete":false,"product_type":"c1","uid":1111819,"ip_address":"","ucode":"3EBE0427602B18","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/0b/888ab243.jpg","comment_is_top":false,"comment_ctime":1549874999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549874999","product_id":100017301,"comment_content":"思考题这样理解可好？分两步：<br>1: 假设细胞不会死亡，n小时后的细胞总数：f(n)=2*f(n-1);<br>2: 细胞的生命周期是 3 小时，这就意味着，每 3 小时前的细胞都会死亡，n小时后死亡总数：f(m)=f(n-3)；<br><br>结论：<br>n小时后容器的细胞数: f(n)-f(m) =&gt; f(n)=2*f(n-1)-f(n-3)<br>","like_count":0},{"had_liked":false,"id":63303,"user_name":"周小可","can_delete":false,"product_type":"c1","uid":1114628,"ip_address":"","ucode":"A18CF81637B4CD","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/04/312ca35d.jpg","comment_is_top":false,"comment_ctime":1548319773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548319773","product_id":100017301,"comment_content":"@farFlight<br><br>假设细胞到了第三个小时是先分裂完再死亡，那么递推公式就应该是：<br>f(n) = f(n-1)*2 - f(n-3)<br>一次乘法和一次减法一起看作一次基本操作消耗，那么情况和斐波那契数列很像。<br>最高的树应该有n层， 最短的是n&#47;3层，每层操作数都是指数增长。<br>那么时间复杂度应该是在O(2^n)量级的。<br><br>----------------------------------<br>我觉得这个递推公式是对的，但是复杂度的推算不对。因为递推公式可以转化为下面这种形式<br>f(n) = f(n-1) + f(n-1) - f(n-3)<br>这样以来虽然第一级看成是 1 次基本操作，但是第二级就是 3 次基本操作，接着是 9 次...<br>因此最终计算出来的复杂度是 O(3^n)量级。","like_count":0},{"had_liked":false,"id":63254,"user_name":"Rise","can_delete":false,"product_type":"c1","uid":1121445,"ip_address":"","ucode":"647FE51DDDF456","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/a5/06722fd3.jpg","comment_is_top":false,"comment_ctime":1548311991,"is_pvip":false,"replies":[{"id":"22475","content":"你这不是抬杠吗：）不适合的意思不是绝对绝对绝对不可以。就是分析起来比较麻烦。换个思路分析不好吗？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1548404727,"ip_address":"","comment_id":63254,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548311991","product_id":100017301,"comment_content":"看完后，对时间复杂度有了很大的疑惑，为什么树的遍历时间复杂度是O(n)，树的遍历也是用的递归，既然公式和递归树都不适合，该怎么推导，既然都是递归，为什么公式和递归树都不适合推导树的遍历？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437522,"discussion_content":"你这不是抬杠吗：）不适合的意思不是绝对绝对绝对不可以。就是分析起来比较麻烦。换个思路分析不好吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548404727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56933,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1546583250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546583250","product_id":100017301,"comment_content":"留言少是因为好多同学还没跟上进度吧","like_count":0},{"had_liked":false,"id":56931,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1546583183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546583183","product_id":100017301,"comment_content":"红黑树后面树的课程都好难啊","like_count":0},{"had_liked":false,"id":55231,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1546070752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546070752","product_id":100017301,"comment_content":"递归树<br><br>递归思想就是大问题化成小问题来思考。因此可以给递归画成一颗树，每一层的数据归并操作的时间小号都是n。以此来思考快速排序的时间复杂度，得出快排的平均时间复杂度为O（nlogn）。<br><br>分析斐波那契数列的时间复杂度：同样利用递归树来分析。再这个递归中，递归层数最大时n，最小是n&#47;2，那整个算法的时间复杂度就是所有层数的时间消耗之和。如果最大路径是n，那么总和就是2^n-1，如果最大路径是n&#47;2，那么总和就是2^(n&#47;2)-1，不管那种情况，复杂度都是指数级的，非常高。<br><br>分析全排列的时间复杂度：分析思想上 也是用递归树来分析，但是由于每一层的时间消耗不同，所以比斐波那契数列分析要复杂一点，但同样能够分析出大概的时间复杂度范围，可以看出全排列的递归的时间复杂度是非常高的。<br><br>到现在为止学到了两种时间复杂度的分析方法，一种是这次的递归树分析。另一种是排序章节讲到的递推公式的时间复杂度。不同代码可能适合不同的时间复杂度分析方法，有的可能两个都不适合（比如二叉树的递归前中后序遍历）。","like_count":0},{"had_liked":false,"id":55222,"user_name":"Yakmoz","can_delete":false,"product_type":"c1","uid":1257502,"ip_address":"","ucode":"1FA18A711457A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/1e/0b05530d.jpg","comment_is_top":false,"comment_ctime":1546069450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546069450","product_id":100017301,"comment_content":"第一小时1个细胞，第二小时3个，依此类推 1 3 6 12....<br>递归公式<br>int cacl(int n) {<br>  if (n &lt;=1)<br>    return 1;<br>  if (n == 2)<br>    return 3;<br>  return Math.pow(2, n - 1) + cacl(n - 1) - Math.pow(2, n - 3);<br>}<br>假如每次加法减法计算都是1个时间复杂度，则树的深度只与n有关，因此我觉得时间复杂度应该是O(n)","like_count":0},{"had_liked":false,"id":52311,"user_name":"crazyone","can_delete":false,"product_type":"c1","uid":1115042,"ip_address":"","ucode":"705E34642E41F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a2/ceb37046.jpg","comment_is_top":false,"comment_ctime":1545361245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545361245","product_id":100017301,"comment_content":"f(0)=1<br>f(1)=2<br>f(2)=6<br>f(n)=[f(n-1)+f(n-2)+f(n-3)]*2-f(n-3)","like_count":0},{"had_liked":false,"id":52204,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1545351706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545351706","product_id":100017301,"comment_content":"如果是先分裂再死亡f(n)=2*f(n-1)-f(n-3) 如果先分裂再死亡f(n)=2*(f(n-1)-f(n-3))时间复杂度都是指数级","like_count":0},{"had_liked":false,"id":51304,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1545150386,"is_pvip":false,"replies":[{"id":"18548","content":"因为不好表示递归树中的每个节点状态","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545184670,"ip_address":"","comment_id":51304,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545150386","product_id":100017301,"comment_content":"而有些可能两个都不怎么适合使用，比如二叉树的递归前中后序遍历。<br><br>请问这个为何不适用递归树分析    衡量适合递归树和不适合递归树的边界是什么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433397,"discussion_content":"因为不好表示递归树中的每个节点状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545184670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50025,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1544842821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544842821","product_id":100017301,"comment_content":"老师，斐波那契数列每个函数还需要执行2个if的比较操作，所以每个函数2个比较，用最长路径n考虑则比较时间为2^1,2^2,2^3,...，2^n，比较的时间总和为2^(n+1)-2,这些时间是可以忽略吗还是经验性取舍？","like_count":0},{"had_liked":false,"id":49182,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1544618421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544618421","product_id":100017301,"comment_content":"递推公式为 f（n） = 2f(n - 1) - f(n-3) = 2^(n) - 2^(n-3)<br>所以时间复杂度为O(2^n)<br>","like_count":0},{"had_liked":false,"id":48681,"user_name":"haleli","can_delete":false,"product_type":"c1","uid":1329407,"ip_address":"","ucode":"A07143F6E2125B","user_header":"https://static001.geekbang.org/account/avatar/00/14/48/ff/17e4c732.jpg","comment_is_top":false,"comment_ctime":1544514100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544514100","product_id":100017301,"comment_content":"f(1)=1<br>f(2)=2*1+1=3<br>f(3)=2*3+3=9<br>f(4)=2*9+9=27<br>...<br>f(n)=2f(n-1)+f(n-1)=3f(n-1)","like_count":0},{"had_liked":false,"id":47925,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1544258122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544258122","product_id":100017301,"comment_content":"全排列这里是不是可以换个思路，先全排列前n-1个元素（可能需要存在list中），最后将最后一位元素放在每个全排列结果的不同位置，比如 1,2,3  先全排列1,2 -&gt; (1,2) (2,1) -&gt;再把3放到每个结果的不同位置(3,1,2) (1,3,2) (1,2,3) 以及 (3,2,1) (2,3,1) (2,1,3)","like_count":0},{"had_liked":false,"id":47071,"user_name":"Laughing_Lz","can_delete":false,"product_type":"c1","uid":1251342,"ip_address":"","ucode":"7A7445E96F2978","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg","comment_is_top":false,"comment_ctime":1544029054,"is_pvip":false,"replies":[{"id":"16931","content":"如何交换两个变量的值。你自己网上搜下吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544148996,"ip_address":"","comment_id":47071,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544029054","product_id":100017301,"comment_content":"请问老师能否对第一个交换解释下，学生这里看不懂···<br>\t\t\tint tmp = data[i];<br>\t\t\tdata[i] = data[k - 1];<br>\t\t\tdata[k - 1] = tmp;<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431654,"discussion_content":"如何交换两个变量的值。你自己网上搜下吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544148996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46900,"user_name":"肖小强","can_delete":false,"product_type":"c1","uid":1245065,"ip_address":"","ucode":"A929A8D1DAD3C4","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/89/32e3f682.jpg","comment_is_top":false,"comment_ctime":1543999193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543999193","product_id":100017301,"comment_content":"看了评论区的留言，没能找到想要的答案。下面是我自己的思路:首先假设细胞不死亡，则n小时候总数为2^n;再求死亡的细胞总数，需要用到递归树的知识。首先树的高度为n&#47;3，第一层中只有1个细胞死亡，第二层有2个，类推下去，总死亡数为1+2+2^2+...+2^(n&#47;3)。<br>大概思路就是这样，希望老师给看看。","like_count":0},{"had_liked":false,"id":46875,"user_name":"D→_→M","can_delete":false,"product_type":"c1","uid":1184017,"ip_address":"","ucode":"5EFDE9E2ED2C8B","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/11/52a78856.jpg","comment_is_top":false,"comment_ctime":1543995445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543995445","product_id":100017301,"comment_content":"纠结在了全排列的代码实现，看了半天没搞懂。😂","like_count":0},{"had_liked":false,"id":46860,"user_name":"蓝艺","can_delete":false,"product_type":"c1","uid":1239640,"ip_address":"","ucode":"FC81CC63C8F245","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/58/2aa56c18.jpg","comment_is_top":false,"comment_ctime":1543993185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543993185","product_id":100017301,"comment_content":"从第三代开始就变成斐波那契数列，也可以从时间维度来看，第n小时总的细胞数量肯定就等于在第n-1分裂的新细胞数加上第n-2小时分裂的新细胞数（注意是新）的2倍，a(n)=a(n-1) +a(n-2) ,f(n)=2*a(n)=f(n-1)+f(n-2),点赞第一的是什么鬼？","like_count":0},{"had_liked":false,"id":45348,"user_name":"gesanri","can_delete":false,"product_type":"c1","uid":1121174,"ip_address":"","ucode":"AE3B97DC3ED668","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELtOO0HKrj5SI5JSlmwiaCvaF6GLiaTmf5NX88OZaO3HymTAGTeIoicBUjqzmMF6sF5raPFjuqLFibrrw/132","comment_is_top":false,"comment_ctime":1543593243,"is_pvip":false,"replies":[{"id":"16373","content":"是估算的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543802987,"ip_address":"","comment_id":45348,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543593243","product_id":100017301,"comment_content":"前两个例子这个递归的时间复杂度用树分析这块有点疑问，既然存在最短和最长路径，那说明树不是满二叉树，中间会有不少层都有空的地方，比如最短路径下面的层会空的越来越多，那计算每层的时间复杂度就不能按照满的来算了吧?比如斐波那契数列，就不能严格按照1 2 4 8 16这样来计算每层的时间来了吧?还是说这里只是估算","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430994,"discussion_content":"是估算的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543802987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":44272,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1543397614,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543397614","product_id":100017301,"comment_content":"我的习惯是先用代码尝试实现，先上代码。<br>static int divsion(int n, int i, int num) {<br>&#47;&#47;    System.out.println(n+&quot;,&quot;+i+&quot;,&quot;+num);<br>    if (n &lt;= 0) {<br>      return num;<br>    }<br>    n--;<br>    i++;<br>    num = num * 2;<br>    if (i &gt;= 3) {<br>      num = (int) (num - (Math.pow(2, (i - 3))));<br>    }<br>    return divsion(n, i, num);<br>  }<br>n代表剩余小时数，i代表经过小时数，num代表目前细胞总数。<br>每次调用，都将细胞总数翻倍，然后减去 2*经过时间-3次幂（死亡的细胞）<br>这样计算的话时间复杂度应该是 O（n）;<br><br>但是感觉如果这样得出结论，其实并没有用到递归树。但是个人认为，完全没有必要用到递归树来做，因为时间是递增的，剩余时间是递减的。细胞总数是成倍递增，跟n并没有直接的关系。<br><br>如果有合理的递归树或者，递归公式，还是希望能学习一下的。但是目前的留言区感觉都不能算正确啊，自认为。<br><br><br>","like_count":0},{"had_liked":false,"id":43927,"user_name":"Mr.M","can_delete":false,"product_type":"c1","uid":1243730,"ip_address":"","ucode":"C32AE0A9CD6EEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/52/4781da3f.jpg","comment_is_top":false,"comment_ctime":1543327030,"is_pvip":false,"replies":[{"id":"15781","content":"根节点数据规模是n 叶子节点是1。每经过一条边 数据规模就减1。那从根节点到叶子节点的路径多长？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543404412,"ip_address":"","comment_id":43927,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543327030","product_id":100017301,"comment_content":"如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 n&#47;2。是怎么来的啊？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430554,"discussion_content":"根节点数据规模是n 叶子节点是1。每经过一条边 数据规模就减1。那从根节点到叶子节点的路径多长？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543404412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43494,"user_name":"喜欢吃鱼","can_delete":false,"product_type":"c1","uid":1250205,"ip_address":"","ucode":"02F41572F53E3C","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/9d/d91dc762.jpg","comment_is_top":false,"comment_ctime":1543233759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543233759","product_id":100017301,"comment_content":"n个小时后细胞的总个数为Sum：<br>n = 1时：sum = 3;<br>n = 2时：sum = 7;<br>n&gt;=3时：Sum = 2^(n-2)+2^(n-1)+2^(n)-2^(n-3)<br><br>","like_count":0},{"had_liked":false,"id":43067,"user_name":"Mr.M","can_delete":false,"product_type":"c1","uid":1243730,"ip_address":"","ucode":"C32AE0A9CD6EEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/52/4781da3f.jpg","comment_is_top":false,"comment_ctime":1543154264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543154264","product_id":100017301,"comment_content":"是3的n次方减去3的n减1次方吗？","like_count":0},{"had_liked":false,"id":42779,"user_name":"乘风","can_delete":false,"product_type":"c1","uid":1246998,"ip_address":"","ucode":"BA94098E8D6C95","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/16/73494479.jpg","comment_is_top":false,"comment_ctime":1543042889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543042889","product_id":100017301,"comment_content":"写的数学公式 是在小程序里展示不出来吗","like_count":0},{"had_liked":false,"id":42553,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1542968691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542968691","product_id":100017301,"comment_content":"我的求解思路是这样子<br>1，先求得在第N个小时的小时，盘子的里细胞数，如果小时数为n,，在细胞大于3小时后，可得到求解第n小时的细胞个数的为：2^(n-1)-2^(n-2)<br>2，当前盘子的细胞数，可理解为前所有小时的累加之和，即可求解<br><br><br>然后再说说时间复杂度的问题<br>如果每次计算记作常量1的时间消耗，<br>那第一小时的时间消耗为1，第二小时为2的一次方，第三小时为2的2次方，这样第n小时的到2的(n-1)次方，<br>整个消耗即为时间的复杂度<br>1+2+....+2^(n-1)=2^n-1<br>使用O时间复杂度表示法即为(2的n次方) O(2^n) <br><br><br>  public static int count(int hour) {<br>    if (hour &lt;= 1) {<br>      return 1;<br>    } else if (hour == 2) {<br>      return 2;<br>    }<br>    return (int) Math.pow(2, hour - 1) - (int) Math.pow(2, hour - 3);<br>  }<br><br>  public static int fn(int hour) {<br>    int value = 1;<br>    for (int i = 1; i &lt; hour; i++) {<br>      int currValue = count(hour);<br>      value = fn(hour - 1) + currValue;<br>    }<br><br>    return value;<br>  }<br><br>  public static void main(String[] args) {<br>    System.out.println(fn(5));<br>  }<br><br>老师，不知道我理解的是否正确？希望得到您的指正，谢谢","like_count":0},{"had_liked":false,"id":42487,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1542961246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542961246","product_id":100017301,"comment_content":"当n大于3的时候，递归的公式应该为f(n)=2*f(n-1)-f(n-3)由此如果画出递归树，n要不一层减1要不一层减2所以最终时间复杂度应该是o(2^n)。我在处理递归问题复杂度的时候喜欢画递归树比较直观，主方法公式，认真推导过，也记得过很不幸，后来又忘了😣","like_count":0},{"had_liked":false,"id":41915,"user_name":"ALAN","can_delete":false,"product_type":"c1","uid":1240164,"ip_address":"","ucode":"70E3B1C730E63F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/64/7403c694.jpg","comment_is_top":false,"comment_ctime":1542872017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542872017","product_id":100017301,"comment_content":"可用递归树分析求解。<br>设f(n)为n小时后总细胞数目，设f(n)=a2(n)+a1(n)+a0(n),a2(n)为n小时后，寿命为2小时的细胞个数,a1(n)为n小时后，寿命为1小时的细胞个数,a0(n)为n小时后，寿命为0小时的细胞个数.<br>由分析知：<br>    a2(n)=a1(n-1),a1(n)=a0(n-1),a0(n)=a2(n - 1) + a1(n - 1) + a0(n - 1)<br>可知：<br>    树有n层，第一层需要2次加法，第二次需要4次加法，操作次数随层数以2的幂指数增加<br>，到第n层需要2的n次方加法，故总时间复杂度为O(2**n)","like_count":0},{"had_liked":false,"id":41909,"user_name":"ALAN","can_delete":false,"product_type":"c1","uid":1240164,"ip_address":"","ucode":"70E3B1C730E63F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/64/7403c694.jpg","comment_is_top":false,"comment_ctime":1542871349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542871349","product_id":100017301,"comment_content":"时间复杂度是2的n+1次方。<br>如下是计算n小时后，细胞个数num(n).a2(n)为n小时后，寿命为2小时的细胞个数，a1(n)为n小时后，寿命为1小时的细胞个数，a0(n)为n小时后，寿命为0小时的细胞个数<br>static int num(int n) {<br>\t\tint m = a2(n) + a1(n) + a0(n);<br>\t\treturn m;<br>\t}<br><br>\tstatic int a2(int n) {<br>\t\tif (n &gt;= 1)<br>\t\t\treturn a1(n - 1);<br>\t\telse<br>\t\t\treturn 0;<br>\t}<br><br>\tstatic int a1(int n) {<br>\t\tif (n &gt;= 1)<br>\t\t\treturn a0(n - 1);<br>\t\telse<br>\t\t\treturn 0;<br>\t}<br><br>\tstatic int a0(int n) {<br>\t\tif (n &gt;= 1)<br>\t\t\treturn a2(n - 1) + a1(n - 1) + a0(n - 1);<br>\t\telse<br>\t\t\treturn 1;<br>\t}","like_count":0},{"had_liked":false,"id":41901,"user_name":"马上想好","can_delete":false,"product_type":"c1","uid":1193316,"ip_address":"","ucode":"053C41AE647E30","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/64/1ad5530d.jpg","comment_is_top":false,"comment_ctime":1542869851,"is_pvip":false,"replies":[{"id":"15060","content":"是的 先把递归练好再来看这一课吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542884954,"ip_address":"","comment_id":41901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542869851","product_id":100017301,"comment_content":"感觉有点难。。递归有点抽象","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429938,"discussion_content":"是的 先把递归练好再来看这一课吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542884954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41808,"user_name":"杨伟","can_delete":false,"product_type":"c1","uid":1239937,"ip_address":"","ucode":"D5B521A0688E02","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/81/43f4b52c.jpg","comment_is_top":false,"comment_ctime":1542853732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542853732","product_id":100017301,"comment_content":"这个题目有意思","like_count":0},{"had_liked":false,"id":41678,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1542820324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542820324","product_id":100017301,"comment_content":"f(n)=f(n-1)+f(n-2)<br>计算方法如下:<br>f(n)=2*f(n-1)-f(n-3)<br>f(n-1)=2*f(n-2)-f(n-4)<br>.........<br>f(3)=2*f(2)-f(0)<br>然后所有等式合并即可。","like_count":0},{"had_liked":false,"id":41600,"user_name":"小蘑菇丢丢","can_delete":false,"product_type":"c1","uid":1246341,"ip_address":"","ucode":"E88BE7E07D7A0E","user_header":"","comment_is_top":false,"comment_ctime":1542810807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542810807","product_id":100017301,"comment_content":"全排列的代码能不能解释下，那个k到底是啥。。。还有交换的操作看不懂","like_count":0},{"had_liked":false,"id":41399,"user_name":"煦暖","can_delete":false,"product_type":"c1","uid":1245418,"ip_address":"","ucode":"96D0B236C4148A","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg","comment_is_top":false,"comment_ctime":1542772897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542772897","product_id":100017301,"comment_content":"老师，对于这样的等比数列：n,n&#47;10,n&#47;(10^2),n&#47;(10^3)...1 一直没弄明白怎么求和，套用等比数列求和公式：a1*((1-q^n)&#47;(1-q)) 后 n*((1-(1&#47;10)^n)&#47;(1-(1&#47;10))) 计算结果和您的不一样，能帮我讲解一下吗，谢谢。","like_count":0},{"had_liked":false,"id":41392,"user_name":"H-double-J","can_delete":false,"product_type":"c1","uid":1181420,"ip_address":"","ucode":"407377D04F746C","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/ec/6907230f.jpg","comment_is_top":false,"comment_ctime":1542772309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542772309","product_id":100017301,"comment_content":"f(0)={1,0,0}<br>f(1)={1,1,0}<br>f(2)={2,1,1}<br>f(n)=f(n-1)数组求和+f(n-1)[0]+f(n-1)[1]","like_count":0},{"had_liked":false,"id":41388,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1542772004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542772004","product_id":100017301,"comment_content":"tmp = data[i];<br>data[i] = data[k-1];<br>data[k-1] = tmp;<br>全排列的代码实现中，请问老师我看上面这三行代码看起来是重复了，但是去掉后就得到结果，请问老师这后面重复的这三行代码起到什么作用？可否详细解释下，看的一脸懵逼","like_count":0},{"had_liked":false,"id":41300,"user_name":"Aruen","can_delete":false,"product_type":"c1","uid":1235654,"ip_address":"","ucode":"BCEECC5684EE36","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/c6/e1b2797b.jpg","comment_is_top":false,"comment_ctime":1542764854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542764854","product_id":100017301,"comment_content":"经过n个小时后细胞的个数f(n):<br>n=1时f(1)=3<br>n&gt;1时，f(n)=2^(n-2)+2^(n-1)+2^n;<br>f(1)=3<br>f(2)=7<br>f(3)=2f(2)<br>f(4)=2f(3)<br>...<br>f(n)=2f(n-1)=2^(n-2)f(2)<br>时间复杂度为O(2^n)","like_count":0},{"had_liked":false,"id":41282,"user_name":"跬行","can_delete":false,"product_type":"c1","uid":1238874,"ip_address":"","ucode":"0BB846566571A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/5a/24ad29c8.jpg","comment_is_top":false,"comment_ctime":1542763785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542763785","product_id":100017301,"comment_content":"f(0) = 1;  <br>f(1) = 1*2;  <br>f(2)=2*f(1);<br>f(3)=2*f(2)-f(0)；<br>f(n)= 2*f(n-1) - f(n-3)；<br><br>与f(n)= f(n-1)+f(n-2) 很像<br>但是O(2^n) 和 O(2^(n&#47;2) 之间还是O(3^n) 和 O(3^(n&#47;2)呢？<br>","like_count":0},{"had_liked":false,"id":41275,"user_name":"Aruen","can_delete":false,"product_type":"c1","uid":1235654,"ip_address":"","ucode":"BCEECC5684EE36","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/c6/e1b2797b.jpg","comment_is_top":false,"comment_ctime":1542763481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542763481","product_id":100017301,"comment_content":"当n&lt;3时，容器内细胞为f(n)=2^(n+1)-1<br>当n&gt;=3时，容器内细胞为f(n)=2^0+2^1+...+2^n-(2^0+2^1+2^2+...2^(n-3))<br>                                             =2^(n-2)+2^(n-1)+2^n<br>时间复杂度应该在O(2^n).","like_count":0},{"had_liked":false,"id":41271,"user_name":"蒋礼锐","can_delete":false,"product_type":"c1","uid":1248897,"ip_address":"","ucode":"25E042066A1427","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gM1ibHKPkrs5DSIp4aIuQ9jnYtNicc2tdG244PbaSvKw5jO9DWrhWghcVM1Y5Iq2QSpzLBUeWZQLhARst51z35mA/132","comment_is_top":false,"comment_ctime":1542763294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542763294","product_id":100017301,"comment_content":"老师，如果对斐波那契数列进行已计算数据存储的话复杂度是不是会下降很多？这种情况的复杂度又该如何分析？按照递归树的分析，n-1和n-2是同时进行分叉的，这样就无法使用已求得数据了。","like_count":0},{"had_liked":false,"id":41238,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1542761821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542761821","product_id":100017301,"comment_content":"细胞分裂就相当于等比公式最后一项的值，a1 * x^(n-1)，能很明显看出时间复杂度是指数阶的。","like_count":0},{"had_liked":false,"id":41199,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1542759567,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1542759567","product_id":100017301,"comment_content":"首先列出递归公式，然后估算出递归树的深度取值范围，再估算出每一层递归的分解与归并时间复杂度，最后逐级累加每层时间复杂度得出整体时间复杂度的取值范围。","like_count":0},{"had_liked":false,"id":41195,"user_name":"代码之美","can_delete":false,"product_type":"c1","uid":1242326,"ip_address":"","ucode":"7086778359AE92","user_header":"","comment_is_top":false,"comment_ctime":1542759139,"is_pvip":false,"replies":[{"id":"15070","content":"可以看看java的treemap<br>","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542885680,"ip_address":"","comment_id":41195,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542759139","product_id":100017301,"comment_content":"有没有源码？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429729,"discussion_content":"可以看看java的treemap\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542885680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}