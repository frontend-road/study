{"id":473193,"title":"34 | 编译原理（下）：编译原理给我们带来了什么？","content":"<p>你好，我是大圣。</p><p>上一讲我们深入研究了 Vue 里的 compiler-dom 和 compiler-core 的流程，相信学完之后，你已经对编译原理的基础知识很熟悉了。</p><p>这时候你肯定会有一个疑问，AST、transform、generate这些概念以前工作中也没遇见过，难道学了这个就只能面试用吗？ 当然不是，编译原理作为计算机世界的一个重要的学科，除了探究原理和源码之外，我们工作中也有很多地方可以用到。</p><p>从宏观视角来看，编译原理实现的功能就是代码之间的转换。哪怕我们只是掌握了入门知识，也能可以实现Vue中 template到render函数转化这样的功能。</p><p>现在的前端发展，很大程度上离不开编译原理在前端圈的落地实践，只要是我们想做自动化代码转化的地方，都可以看到编译的身影。</p><p>举个例子，Babel把ES6中的新语法转换成低版本浏览器支持的语法，我们才能在项目中愉快地使用箭头函数等特性，把浏览器的兼容性交给Babel来处理，甚至现在社区内还出现了gogocode这种把Vue 2代码转换成Vue 3代码的工具。</p><p>在工作中我们可以借助Babel和vite提供给我们的能力，parse，transform，generate等代码都不需要我们自己实现，只需要考虑代码转换的逻辑就可以了，下面我给你举几个小例子。</p><!-- [[[read_end]]] --><h2>vite 插件</h2><p>首先我们在项目中使用了script setup来组织我们的代码，虽然组件引入之后有了自动注册的功能，但是每一个组件内部都肯定要用到ref、computed等Vue提供的API。我们还想要多一步，项目大了只引入ref的语句就写了几百行，就会非常地繁琐，这时候就可以使用编译的思想来解决这个问题。</p><p>首先ref、computed、watch等Vue提供的API，我们在后面的代码调用可以通过正则匹配的方式，完全可以分析出来当前组件依赖的API有哪些。这样，我们就可以在组件执行之前自动导入这些API。</p><p>我们在weiyouyi项目中使用vite插件的形式来完成这个工作。社区内已经有可用的 <a href=\"https://github.com/antfu/unplugin-auto-import\">auto-imput</a> 插件了，不过这里为了加深对技术的理解，咱们还是自己来实现一个。</p><p>首先我们进入到根目录下的vite.config.js文件中，导入autoPlugin插件后，配置在vite的plugins插件中。</p><pre><code class=\"language-javascript\">import vue from '@vitejs/plugin-vue'\nimport autoPlgin from './src/auto-import'\nexport default defineConfig({\n  plugins: [vue(),autoPlgin()]\n})\n\n</code></pre><p>然后我们来实现autoPlugin函数，vite的插件开发文档你可以在<a href=\"https://cn.vitejs.dev/guide/api-plugin.html\">官网中</a>查询，这里就不赘述了。</p><p>我们直接看代码，我们先定义了Vue 3提供的API数组，有ref、computed等等。然后，autoImportPlugin函数对外导出一个对象，transform函数就是核心要实现的逻辑。</p><p>这里的helper和我们在32讲中的工具函数实现逻辑一致，通过new Regexp创建每个函数匹配的正则。如果匹配到对应的API，就把API的名字加入到helper集合中，最后在script setup的最上方加入一行import语句。</p><pre><code class=\"language-javascript\">\nconst vue3 = [\n  'ref',\n  'computed',\n  'reactive',\n  'onMounted',\n  'watchEffect',\n  'watch'\n] // 还有很多....\n\nexport default function autoImportPlugin() {\n  return {\n    name: 'vite-plugin-auto-import', // 必须的，将会在 warning 和 error 中显示\n    enforce:'pre',\n    transform(code,id){\n      vueReg = /\\.vue$/\n      if(vueReg.test(id)){\n        const helpers = new Set()\n        vue3.forEach(api=&gt;{\n          const reg = new RegExp(api+\"(.*)\")\n          if(reg.test(code)){\n            helpers.add(api)\n          }\n        })\n        return code.replace('&lt;script setup&gt;',`&lt;script setup&gt;\n\nimport {${[...helpers].join(',')}} from 'vue' //俺是自动导入的        \n`)\n      }\n      return code\n    }\n  }\n}\n</code></pre><p>接着，我们在项目的src目录下新建App.vue。下面的代码实现了一个简易的累加器，并且还会在onMount之后打印一条信息，这里的ref、computed和onMounted都是没有导入的。我们在浏览器就能看到页面可以正常显示，这时我们在浏览器调试窗口的sources页面中，就可以看到App.vue的代码已经自动加上了import语句。</p><pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;div @click=\"add\"&gt;\n    {{num}} * 2 = {{double}}\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nlet num = ref(1)\nlet double = computed(()=&gt;num.value*2)\n\nfunction add(){\n  num.value++\n}\nonMounted(()=&gt;{\n  console.log('mounted')\n})\n\n&lt;/script&gt;\n</code></pre><h2><img src=\"https://static001.geekbang.org/resource/image/77/fd/77db83e745d7345a146f03364d93cbfd.png?wh=1662x790\" alt=\"图片\"></h2><p>这里的代码都是硬编码实现的，逻辑也比较简单。不过，实际场景中判断ref等API调用的正则和导入import的方式，都不会这么简单。如果我们自己每次都写一个parse模块比较麻烦，所以我们实际开发中会借助现有的工具对代码进行解析，而代码转换的场景下最成熟的工具就是Babel。</p><h2>Babel</h2><p>我们在项目中异步的任务有很多，经常使用async+ await的语法执行异步任务，比如网络数据的获取。但<strong> await是异步任务</strong>，如果报错，我们需要使用try catch语句进行错误处理，每个catch语句都是一个打印语句会让代码变得冗余，但我们有了代码转化的思路后，这一步就能用编译的思路自动来完成。</p><p>首先我们在根目录的src/main.js中新增下面代码，我们使用delyError函数模拟异步的任务报错，在代码中使用await来模拟异步任务。</p><p>这里我们希望每个await都能跟着一个try代码，在catch中能够打印错误消息提示的同时，还能够使用调用错误监控的函数，把当前错误信息发给后端服务器进行报警，当然也可以打印一个自动去stackoverflow查询的链接。</p><pre><code class=\"language-javascript\">function delyError(message){\n  return new Promise((resolve,reject)=&gt;{\n    setTimeout(()=&gt;{\n      reject({message})\n    },1000)\n  })\n}\nasync function test(){\n    await delyError('ref is not defined')\n}\n// 我们期望的代码\nasync function test(){\n  try{\n        await delyError('ref is not defined')\n  }catche(e){\n    console.error(e.message)\n    _errorTrack(e.message,location.pathname)\n     console.log('https://stackoverflow.com/search?q=[js]+'+encodeURI(e.message))\n  }\n\n}\ntest()\n</code></pre><p>页面中await语句变多了之后，手动替换的成本就比较高，我们可以继续使用vite的插件来实现。这次我们就是用Babel提供好的代码解析能力对代码进行转换。Babel都提供了哪些API，你可以在<a href=\"https://babel.docschina.org/docs/en/babel-parser\">Babel的官网</a>进行深入学习。</p><p>Babel提供了完整的编译代码的功能后函数，包括AST的解析、语义分析、代码生成等，我们可以通过下面的函数去实现自己的插件。</p><ul>\n<li>@babel/parser提供了代码解析的能力，能够把js代码解析成AST，代码就从字符串变成了树形结构，方便我们进行操作；</li>\n<li>@babel/traverse提供了遍历AST的能力，我们可以从travser中获取每一个节点的信息后去修改它；</li>\n<li>@babe/types提供了类型判断的函数，我们可以很方便的判断每个节点的类型；</li>\n<li>@babel/core提供了代码转化的能力。</li>\n</ul><p>下面的代码中我们实现了vite-plugin-auto-try插件，由babel/parer解析成为AST，通过travser遍历整个AST节点，配置的AwaitExpression会识别出AST中的await调用语句，再用isTryStatement判断await外层是否已经包裹了try语句。如果没有try语句的话，就使用tryStatement函数生成新的AST节点。</p><p>这个AST包裹当前的节点，并且我们在内部加上了stackoverflow链接的打印。最后，使用babel/core提供的transformFromAstSync函数，把优化后的AST生成新的JavaScript代码，自动新增try代码的插件就实现了。</p><pre><code class=\"language-javascript\">\n\nimport { parse } from '@babel/parser'\nimport traverse from '@babel/traverse'\nimport {\n  isTryStatement,\n  tryStatement,\n  isBlockStatement,\n  catchClause,\n  identifier,\n  blockStatement,\n} from '@babel/types'\nimport { transformFromAstSync } from '@babel/core'\n\nconst catchStatement = parse(`\n  console.error(err)\n  console.log('https://stackoverflow.com/search?q=[js]+'+encodeURI(err.message))\n`).program.body\n\nexport default function autoImportPlugin() {\n  return {\n    name: 'vite-plugin-auto-try', // 必须的，将会在 warning 和 error 中显示\n    enforce:'pre',\n    transform(code,id){\n        fileReg = /\\.js$/\n        if(fileReg.test(id)){\n        const ast = parse(code, {\n          sourceType: 'module'\n        })\n        traverse(ast, {\n          AwaitExpression(path){\n            console.log(path)\n            if (path.findParent((path) =&gt; isTryStatement(path.node))) {\n              // 已经有try了\n              return \n            }\n            // isBlockStatement 是否函数体\n            const blockParentPath = path.findParent((path) =&gt; isBlockStatement(path.node))\n            const tryCatchAst  = tryStatement(\n              blockParentPath.node,\n              // ast中新增try的ast\n              catchClause(\n                identifier('err'),\n                blockStatement(catchStatement),\n              )\n            )\n            // 使用有try的ast替换之前的ast\n            blockParentPath.replaceWithMultiple([tryCatchAst])\n\n          }\n        })\n        // 生成代码，generate\n        code = transformFromAstSync(ast,\"\",{\n          configFile:false\n        }).code\n\n        return code\n      }\n      return code\n    }\n  }\n}\n</code></pre><p>然后，我们在根目录下的src/main.js中写入下面的代码。两个await语句一个使用try包裹，一个没有使用try包裹。</p><p>接着我们启动项目后，就来到了浏览器的调试窗口中的source页面，可以看到下图中解析后的main.js代码，现在没有try的await语句已经自动加上了try语句。</p><p>你看，<strong>这次我们基于babel来实现，就省去了我们写正则的开发成本</strong>。Babel提供了一整套关于JavaScirpt中语句的转化函数，有兴趣的同学可以去Babel官网了解。</p><pre><code class=\"language-javascript\">import { createApp } from \"vue\";\nimport App from './App.vue'\n\ncreateApp(App)\n  .mount('#app')\n\nasync function test(){\n  await delyError('ref is not defined')\n}\n\nasync function test2(){\n  try{\n    await delyError('reactive is not defined')\n  }catch(e){\n    console.error(e)\n  }\n}\ntest()\nfunction delyError(message){\n  return new Promise((resolve,reject)=&gt;{\n    setTimeout(()=&gt;{\n      reject({message})\n    },1000)\n  })\n}\n\n</code></pre><h2><img src=\"https://static001.geekbang.org/resource/image/0a/f9/0a00c01yyfdf020eec114fc5a70344f9.png?wh=1920x1056\" alt=\"图片\"></h2><p>有了Babel提供的能力之后，我们可以只关注于代码中需要转换的逻辑，比如我们可以使用Babel实现国际化，把每种语言在编译的时候自动替换语言，打包成独立的项目；也可以实现页面的自动化监控，在一些操作函数里面加入监控的代码逻辑。你可以自行发挥想象力，使用编译的思想来提高日常的开发效率。</p><p>最后我们回顾一下Vue中的compiler。Vue中的compiler-dom提供了compile函数，具体的compile逻辑我们在上一讲中已经详细学习了。其实我们也可以手动导入compiler-dom包之后，自己实现对vue template的解析。另外，Vue中还提供了@vue/compiler-sfc包，用来实现单文件组件.vue的解析，还有@vue/compiler-ssr包，它实现了服务端渲染的解析。</p><p>下一讲我们一起来手写vite的代码内容，我们就需要在nodejs中实现对Vue单文件组件的解析工作，实现浏览器中直接导入单文件组件的功能，敬请期待。</p><h2>总结</h2><p>最后我们总结一下今天学到的内容。</p><p>我们把Vue内部的compiler原理融会贯通之后，今天尝试把template到render转化过程的思想应用到实际项目中。Vue中的compiler在转化的过程中还做了静态标记的优化，我们在实际开发中可以借鉴编译的思路，提高开发的效率。</p><p>我们一起回顾一下代码自动导入的操作思路。首先我们可以实现页面中ref、computed的API的自动化导入，在vite插件的transform函数中获取到待转换的代码，通过对代码的内容进行正则匹配，实现如果出现了ref，computed等函数的调用，我们可以把这些依赖的函数收集在helper中。最终在script setup标签之前新增import语句来导入依赖的API，最终就可以实现代码的自动导入。</p><p><strong>实际开发中，我们可以把使用到的组件库Element3，工具函数vueuse等框架都进行语法的解析，实现函数和组件的自动化导入和按需加载。这样能在提高开发效率的同时，也提高我们书写vite插件的能力</strong>。</p><h2>思考题</h2><p>最后留一个思考题吧，你觉得在工作项目中有哪里需要用到代码转化的思路呢？欢迎在评论区分享你的答案，也欢迎你把这一讲的内容分享给你的同事和朋友们，我们下一讲再见！</p>","comments":[{"had_liked":false,"id":329990,"user_name":"费城的二鹏","can_delete":false,"product_type":"c1","uid":1101293,"ip_address":"","ucode":"DE768A0CC3053D","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/ed/825d84ee.jpg","comment_is_top":false,"comment_ctime":1641716399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10231650991","product_id":100094401,"comment_content":"很多魔板代码都可以通过代码转化的方式实现，我们的网络请求代码非常固定，打算试试用这种方式减少模板代码","like_count":2},{"had_liked":false,"id":329903,"user_name":"SjmBreadrain","can_delete":false,"product_type":"c1","uid":2709219,"ip_address":"","ucode":"6C2F29CF146F50","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ruxj2Ko6lpWdmf4ePtUCjZU0LpicbVUuTicWaSDRkGHGMB78b3vQNNbfhlqMWlibxCLX6V0IfueFxUyxs5BlryzVQ/132","comment_is_top":false,"comment_ctime":1641635390,"is_pvip":false,"replies":[{"id":"120221","content":"课程介绍页有个微信群","user_name":"作者回复","comment_id":329903,"uid":"1003715","ip_address":"","utype":1,"ctime":1641774219,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"10231569982","product_id":100094401,"comment_content":"除了留言之外还有别的互动方式不？","like_count":2,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544895,"discussion_content":"课程介绍页有个微信群","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641774219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1673990,"avatar":"https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg","nickname":"TableBear","note":"","ucode":"A2C0562EEA2725","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547232,"discussion_content":"朋友，有找到互动微信群吗，求分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642592430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1027167,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/5f/894761f8.jpg","nickname":"十八哥","note":"","ucode":"C0130252F97814","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1673990,"avatar":"https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg","nickname":"TableBear","note":"","ucode":"A2C0562EEA2725","race_medal":5,"user_type":1,"is_pvip":true},"discussion":{"id":588601,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663895037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547232,"ip_address":"北京"},"score":588601,"extra":""}]}]},{"had_liked":false,"id":346335,"user_name":"陈坚泓","can_delete":false,"product_type":"c1","uid":2461961,"ip_address":"","ucode":"75258EE1BF1C2A","user_header":"https://static001.geekbang.org/account/avatar/00/25/91/09/6f0b987a.jpg","comment_is_top":false,"comment_ctime":1653032861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5948000157","product_id":100094401,"comment_content":"这节不错 非常实用 可以减少很多重复性操作 ","like_count":1},{"had_liked":false,"id":330047,"user_name":"海阔天空","can_delete":false,"product_type":"c1","uid":1327016,"ip_address":"","ucode":"16C87A0052A08B","user_header":"https://static001.geekbang.org/account/avatar/00/14/3f/a8/8da58e53.jpg","comment_is_top":false,"comment_ctime":1641771600,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5936738896","product_id":100094401,"comment_content":"厉害厉害，以前用得比较多的就是css的编译，less 函数的编译处理兼容性问题等。部分用到登录信息的处理。","like_count":1},{"had_liked":false,"id":329922,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1641647779,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5936615075","product_id":100094401,"comment_content":"不错不错","like_count":1},{"had_liked":false,"id":329721,"user_name":"Johnson","can_delete":false,"product_type":"c1","uid":1326108,"ip_address":"","ucode":"C6B6FF9EA4CC60","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/1c/47e5b7aa.jpg","comment_is_top":false,"comment_ctime":1641512335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5936479631","product_id":100094401,"comment_content":"很实用。😁","like_count":1},{"had_liked":false,"id":356531,"user_name":"烛火星光","can_delete":false,"product_type":"c1","uid":1480933,"ip_address":"江苏","ucode":"0CF72A5C4EDBCB","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/e5/46c5235b.jpg","comment_is_top":false,"comment_ctime":1662385059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662385059","product_id":100094401,"comment_content":"比如我们可以使用 Babel 实现国际化<br><br>想问一下，这玩意怎么实现，能给一个简单示例么","like_count":1},{"had_liked":false,"id":351500,"user_name":"Johnson","can_delete":false,"product_type":"c1","uid":1326108,"ip_address":"","ucode":"C6B6FF9EA4CC60","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/1c/47e5b7aa.jpg","comment_is_top":false,"comment_ctime":1657853109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657853109","product_id":100094401,"comment_content":"试了一下，下面的代码放在main.js时会自动增加try...catch，但是代码放在组件中无法自动增加，这个要怎么解决处理呢？<br>async function test() {<br>  await delayError(&quot;ref is not defined&quot;);<br>}","like_count":0},{"had_liked":false,"id":350610,"user_name":"henry","can_delete":false,"product_type":"c1","uid":1256109,"ip_address":"","ucode":"55009E8CCC914F","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/ad/5ea1a719.jpg","comment_is_top":false,"comment_ctime":1657036307,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657036307","product_id":100094401,"comment_content":"工具库自动导入如何跟ts的类型系统一起用呢？ts类型检查和类型提示应该不能正常工作了...","like_count":0},{"had_liked":false,"id":344339,"user_name":"Rocky","can_delete":false,"product_type":"c1","uid":1483150,"ip_address":"","ucode":"5FCF390BECDF9D","user_header":"https://static001.geekbang.org/account/avatar/00/16/a1/8e/03aeb9df.jpg","comment_is_top":false,"comment_ctime":1651479732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651479732","product_id":100094401,"comment_content":"高","like_count":0}]}