{"id":168945,"title":"03丨Java虚拟机原理：JVM为什么被称为机器（machine）？","content":"<p>人们常说，Java是一种跨平台的语言，这意味着Java开发出来的程序经过编译后，可以在Linux上运行，也可以在Windows上运行；可以在PC、服务器上运行，也可以在手机上运行；可以在X86的CPU上运行，也可以在ARM的CPU上运行。</p><p>因为不同操作系统，特别是不同CPU架构，是不可能执行相同的指令的。而Java之所以有这种神奇的特性，就是因为Java编译的字节码文件不是直接在底层的系统平台上运行的，而是在Java虚拟机JVM上运行，JVM屏蔽了底层系统的不同，为Java字节码文件构造了一个统一的运行环境。JVM本质上也是一个应用程序，启动以后加载执行Java字节码文件。JVM的全称是Java Virtual Machine，你有没有想过，这样一个程序为什么被称为机器（Machine）呢？</p><p>其实，如果回答了这个问题，也就了解了JVM的底层构造了。这样在进行Java开发的时候，如果遇到各种问题，都可以思考一下在JVM层面是如何的？然后进一步查找资料、分析问题，直至真正地解决问题。</p><h2>JVM的组成构造</h2><p>要想知道这个问题的答案，我们首先需要了解JVM的构造。JVM主要由类加载器、运行时数据区、执行引擎三个部分组成。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/62/0a/62faabeecafe565cbd806022b2aa9c0a.jpg?wh=575*682\" alt=\"\"><br>\n运行时数据区主要包括方法区、堆、Java栈、程序计数寄存器。</p><p>方法区主要存放从磁盘加载进来的类字节码，而在程序运行过程中创建的类实例则存放在堆里。程序运行的时候，实际上是以线程为单位运行的，当JVM进入启动类的main方法的时候，就会为应用程序创建一个主线程，main方法里的代码就会被这个主线程执行，每个线程有自己的Java栈，栈里存放着方法运行期的局部变量。而当前线程执行到哪一行字节码指令，这个信息则被存放在程序计数寄存器。</p><p>一个典型的Java程序运行过程是下面这样的。</p><p>通过Java命令启动JVM，JVM的类加载器根据Java命令的参数到指定的路径加载.class类文件，类文件被加载到内存后，存放在专门的方法区。然后JVM创建一个主线程执行这个类文件的main方法，main方法的输入参数和方法内定义的变量被压入Java栈。如果在方法内创建了一个对象实例，这个对象实例信息将会被存放到堆里，而对象实例的引用，也就是对象实例在堆中的地址信息则会被记录在栈里。堆中记录的对象实例信息主要是成员变量信息，因为类方法内的可执行代码存放在方法区，而方法内的局部变量存放在线程的栈里。</p><p>程序计数寄存器一开始存放的是main方法的第一行代码位置，JVM的执行引擎根据这个位置去方法区的对应位置加载这行代码指令，将其解释为自身所在平台的CPU指令后交给CPU执行。如果在main方法里调用了其他方法，那么在进入其他方法的时候，会在Java栈中为这个方法创建一个新的栈帧，当线程在这个方法内执行的时候，方法内的局部变量都存放在这个栈帧里。当这个方法执行完毕退出的时候，就把这个栈帧从Java栈中出栈，这样当前栈帧，也就是堆栈的栈顶就又回到了main方法的栈帧，使用这个栈帧里的变量，继续执行main方法。这样，即使main方法和f方法都定义相同的变量，JVM也不会弄错。这部分内容我们在第一篇已经讨论过，JVM作为一个machine，和操作系统的处理线程栈的的方法是一样的。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/d9/a3de9184bfbd97546c291067d3106cd9.png?wh=1510*400\" alt=\"\"><br>\nJava的线程安全常常让人困惑，你可以试着从Java栈的角度去理解，所有在方法内定义的基本类型变量，都会被每个运行这个方法的线程放入自己的栈中，线程的栈彼此隔离，所以这些变量一定是线程安全的。如果在方法里创建了一个对象实例，这个对象实例如果没有被方法返回或者放入某些外部的对象容器中的话，也就是说这个对象的引用没有离开这个方法，虽然这个对象被放置在堆中，但是这个对象不会被其他线程访问到，也是线程安全的。</p><p>相反，像Servlet这样的类，在Web容器中创建以后，会被传递给每个访问Web应用的用户线程执行，这个类就不是线程安全的。但这并不意味着一定会引发线程安全问题，如果Servlet类里没有成员变量，即使多线程同时执行这个Servlet实例的方法，也不会造成成员变量冲突。这种对象被称作无状态对象，也就是说对象不记录状态，执行这个对象的任何方法都不会改变对象的状态，也就不会有线程安全问题了。事实上，Web开发实践中，常见的Service类、DAO类，都被设计成无状态对象，所以虽然我们开发的Web应用都是多线程的应用，因为Web容器一定会创建多线程来执行我们的代码，但是我们开发中却可以很少考虑线程安全的问题。</p><p>我们再回过头看JVM，它封装了一组自定义的字节码指令集，有自己的程序计数器和执行引擎，像CPU一样，可以执行运算指令。它还像操作系统一样有自己的程序装载与运行机制，内存管理机制，线程及栈管理机制，看起来就像是一台完整的计算机，这就是JVM被称作machine（机器）的原因。</p><h2>JVM的垃圾回收</h2><p>事实上，JVM比操作系统更进一步，它不但可以管理内存，还可以对内存进行自动垃圾回收。所谓自动垃圾回收就是将JVM堆中的已经不再被使用的对象清理掉，释放宝贵的内存资源。那么要想进行垃圾回收，首先一个问题就是如何知道哪些对象是不再被使用的，可以清理的呢？</p><p>JVM通过一种可达性分析算法进行垃圾对象的识别，具体过程是：从线程栈帧中的局部变量，或者是方法区的静态变量出发，将这些变量引用的对象进行标记，然后看这些被标记的对象是否引用了其他对象，继续进行标记，所有被标记过的对象都是被使用的对象，而那些没有被标记的对象就是可回收的垃圾对象了。所以你可以看出来，可达性分析算法其实是一个引用标记算法。</p><p>进行完标记以后，JVM就会对垃圾对象占用的内存进行回收，回收主要有三种方法。</p><p><strong>第一种方式是清理</strong>：将垃圾对象占据的内存清理掉，其实JVM并不会真的将这些垃圾内存进行清理，而是将这些垃圾对象占用的内存空间标记为空闲，记录在一个空闲列表里，当应用程序需要创建新对象的时候，就从空闲列表中找一段空闲内存分配给这个新对象。</p><p>但这样做有一个很明显的缺陷，由于垃圾对象是散落在内存空间各处的，所以标记出来的空闲空间也是不连续的，当应用程序创建一个数组需要申请一段连续的大内存空间时，即使堆空间中有足够的空闲空间，也无法为应用程序分配内存。</p><p><strong>第二种方式是压缩</strong>：从堆空间的头部开始，将存活的对象拷贝放在一段连续的内存空间中，那么其余的空间就是连续的空闲空间。</p><p><strong>第三种方法是复制</strong>：将堆空间分成两部分，只在其中一部分创建对象，当这个部分空间用完的时候，将标记过的可用对象复制到另一个空间中。JVM将这两个空间分别命名为from区域和to区域。当对象从from区域复制到to区域后，两个区域交换名称引用，继续在from区域创建对象，直到from区域满。</p><p>下面这系列图可以让你直观地了解JVM三种不同的垃圾回收机制。</p><p>回收前：</p><p><img src=\"https://static001.geekbang.org/resource/image/91/f7/91e9bd4f5370fc22ec90ea7e093f3bf7.png?wh=1488*304\" alt=\"\"><br>\n清理：</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/03/fc259afcfb7bce6276c04656d4da8203.png?wh=1452*180\" alt=\"\"><br>\n压缩：</p><p><img src=\"https://static001.geekbang.org/resource/image/70/20/7040ed39531687afcb17f6b444101420.png?wh=1452*146\" alt=\"\"><br>\n复制：</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/94/7b6a99a9bd7f9941ea4ae19a738cde94.png?wh=1414*126\" alt=\"\"><br>\nJVM在具体进行垃圾回收的时候，会进行分代回收。绝大多数的Java对象存活时间都非常短，很多时候就是在一个方法内创建对象，对象引用放在栈中，当方法调用结束，栈帧出栈的时候，这个对象就失去引用了，成为垃圾。针对这种情况，JVM将堆空间分成新生代（young）和老年代（old）两个区域，创建对象的时候，只在新生代创建，当新生代空间不足的时候，只对新生代进行垃圾回收，这样需要处理的内存空间就比较小，垃圾回收速度就比较快。</p><p>新生代又分为Eden区、From区和To区三个区域，每次垃圾回收都是扫描Eden区和From区，将存活对象复制到To区，然后交换From区和To区的名称引用，下次垃圾回收的时候继续将存活对象从From区复制到To区。当一个对象经过几次新生代垃圾回收，也就是几次从From区复制到To区以后，依然存活，那么这个对象就会被复制到老年代区域。</p><p>当老年代空间已满，也就是无法将新生代中多次复制后依然存活的对象复制进去的时候，就会对新生代和老年代的内存空间进行一次全量垃圾回收，即Full GC。所以根据应用程序的对象存活时间，合理设置老年代和新生代的空间比例对JVM垃圾回收的性能有很大影响，JVM设置老年代新生代比例的参数是-XX:NewRatio。</p><p><img src=\"https://static001.geekbang.org/resource/image/a5/f4/a5c3dbd6e992822d253f4d16b05555f4.png?wh=610*430\" alt=\"\"><br>\nJVM中，具体执行垃圾回收的垃圾回收器有四种。</p><p><strong>第一种是Serial 串行垃圾回收器</strong>，这是JVM早期的垃圾回收器，只有一个线程执行垃圾回收。</p><p><strong>第二种是Parallel 并行垃圾回收器</strong>，它启动多线程执行垃圾回收。如果JVM运行在多核CPU上，那么显然并行垃圾回收要比串行垃圾回收效率高。</p><p>在串行和并行垃圾回收过程中，当垃圾回收线程工作的时候，必须要停止用户线程的工作，否则可能会导致对象的引用标记错乱，因此垃圾回收过程也被称为stop the world，在用户视角看来，所有的程序都不再执行，整个世界都停止了。</p><p><strong>第三种CMS 并发垃圾回收器</strong>，在垃圾回收的某些阶段，垃圾回收线程和用户线程可以并发运行，因此对用户线程的影响较小。Web应用这类对用户响应时间比较敏感的场景，适用CMS垃圾回收器。</p><p><strong>最后一种是G1 垃圾回收器</strong>，它将整个堆空间分成多个子区域，然后在这些子区域上各自独立进行垃圾回收，在回收过程中垃圾回收线程和用户线程也是并发运行。G1综合了以前几种垃圾回收器的优势，适用于各种场景，是未来主要的垃圾回收器。</p><p><img src=\"https://static001.geekbang.org/resource/image/49/34/492f81e739aba5664ebaf0e08b467134.png?wh=941*512\" alt=\"\"></p><h2>小结</h2><p>我们为什么需要了解JVM呢？JVM有很多配置参数，Java开发过程中也可能会遇到各种问题，了解了JVM的基本构造，就可以帮助我们从原理上去解决问题。</p><p>比如遇到OutOfMemoryError，我们就知道是堆空间不足了，可能是JVM分配的内存空间不足以让程序正常运行，这时候我们需要通过调整-Xmx参数增加内存空间。也可能是程序存在内存泄漏，比如一些对象被放入List或者Map等容器对象中，虽然这些对象程序已经不再使用了，但是这些对象依然被容器对象引用，无法进行垃圾回收，导致内存溢出，这时候可以通过jmap命令查看堆中的对象情况，分析是否有内存泄漏。</p><p>如果遇到StackOverflowError，我们就知道是线程栈空间不足，栈空间不足通常是因为方法调用的层次太多，导致栈帧太多。我们可以先通过栈异常信息观察是否存在错误的递归调用，因为每次递归都会使嵌套方法调用更深入一层。如果调用是正常的，可以尝试调整-Xss参数增加栈空间大小。</p><p>如果程序运行卡顿，部分请求响应延迟比较厉害，那么可以通过jstat命令查看垃圾回收器的运行状况，是否存在较长时间的FullGC，然后调整垃圾回收器的相关参数，使垃圾回收对程序运行的影响尽可能小。</p><p>执行引擎在执行字节码指令的时候，是解释执行的，也就是每个字节码指令都会被解释成一个底层的CPU指令，但是这样的解释执行效率比较差，JVM对此进行了优化，将频繁执行的代码编译为底层CPU指令存储起来，后面再执行的时候，直接执行编译好的指令，不再解释执行，这就是JVM的即时编译JIT。Web应用程序通常是长时间运行的，使用JIT会有很好的优化效果，可以通过-server参数打开JIT的C2编译器进行优化。</p><p>总之，如果你理解了JVM的构造，在进行Java开发的时候，遇到各种问题，都可以思考一下，这在JVM层面是如何的？然后进一步查找资料、分析问题，这样就会真正解决问题，而且经过这样不断地思考分析，你对Java，对JVM，甚至对整个计算机的原理体系以及设计理念都会有更多认识和领悟。</p><h2>思考题</h2><p>你在Java开发过程中遇到过什么样的问题？这些问题和JVM底层原理是怎样的关系？</p><p>你有想过这些问题吗？你可以把你的疑惑或者想法写在评论区里，集思广益。也欢迎你把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","comments":[{"had_liked":false,"id":154191,"user_name":"幸福来敲门","can_delete":false,"product_type":"c1","uid":1670147,"ip_address":"","ucode":"A9CF2FDA8315A5","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/03/2941dea7.jpg","comment_is_top":false,"comment_ctime":1574389762,"is_pvip":false,"replies":[{"id":"59178","content":"内存溢出是说程序需要申请的内存超过了JVM当前可以分配的最大内存，溢出。<br><br>内存泄漏是说期望被回收的内存对象没有被回收，泄漏。<br><br>内存泄漏持续发生，很可能引起内存溢出。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574391323,"ip_address":"","comment_id":154191,"utype":1}],"discussion_count":2,"race_medal":0,"score":"246387525634","product_id":100040201,"comment_content":"老师，内存溢出和内存泄漏有什么区别，以java为例？？","like_count":57,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475402,"discussion_content":"内存溢出是说程序需要申请的内存超过了JVM当前可以分配的最大内存，溢出。\n\n内存泄漏是说期望被回收的内存对象没有被回收，泄漏。\n\n内存泄漏持续发生，很可能引起内存溢出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574391323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1328689,"avatar":"https://static001.geekbang.org/account/avatar/00/14/46/31/cb061c09.jpg","nickname":"陈小龙 Cheney","note":"","ucode":"4B721FE4DDB2F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78009,"discussion_content":"内存溢出和内存泄漏这些词语都是直接生硬翻译的... 你可以理解成是内存爆满报警, 内存垃圾漏回收报警.","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1575965844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154350,"user_name":"[耶]友超","can_delete":false,"product_type":"c1","uid":1400962,"ip_address":"","ucode":"890572F77C3670","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","comment_is_top":false,"comment_ctime":1574412905,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"48819053161","product_id":100040201,"comment_content":"老师，好强大的内功","like_count":11,"discussions":[{"author":{"id":1747968,"avatar":"","nickname":"Geek_e6b178","note":"","ucode":"92F7A5C46F6423","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56938,"discussion_content":"三种收集算法也没标准叫法是标记清楚，复制，标记整理，比文中的更直观","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574526998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154305,"user_name":"KL3","can_delete":false,"product_type":"c1","uid":1537889,"ip_address":"","ucode":"866F01619D295F","user_header":"https://static001.geekbang.org/account/avatar/00/17/77/61/adf1c799.jpg","comment_is_top":false,"comment_ctime":1574406920,"is_pvip":false,"replies":[{"id":"59627","content":"可执行的代码都在方法区。<br><br>对象是类的实例，实例变量在堆中，同一个类的所有对象实例的方法只有一份，在方法区。<br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574687437,"ip_address":"","comment_id":154305,"utype":1}],"discussion_count":4,"race_medal":0,"score":"31639177992","product_id":100040201,"comment_content":"请问老师，关于类加载，对象方法和类方法都是放在方法区吗？ ","like_count":7,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475432,"discussion_content":"可执行的代码都在方法区。\n\n对象是类的实例，实例变量在堆中，同一个类的所有对象实例的方法只有一份，在方法区。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574687437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1537889,"avatar":"https://static001.geekbang.org/account/avatar/00/17/77/61/adf1c799.jpg","nickname":"KL3","note":"","ucode":"866F01619D295F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60006,"discussion_content":"谢谢老师~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574696023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56101,"discussion_content":"类方法指的就是静态方法吧？除了这个之外还有个构造方法？是不是也在方法区呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574432163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1328689,"avatar":"https://static001.geekbang.org/account/avatar/00/14/46/31/cb061c09.jpg","nickname":"陈小龙 Cheney","note":"","ucode":"4B721FE4DDB2F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78010,"discussion_content":"static还是非static的方法都应该是在方法区. 一个对象 = 数据 + 代码. 因为同一个类的所有对象的代码都长一模一样, 所以统一放在方法区, 而每个对象的数据都不一样, 所以放在分配出来的堆空间里.","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575965965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":56101,"ip_address":""},"score":78010,"extra":""}]}]},{"had_liked":false,"id":183614,"user_name":"好好先生","can_delete":false,"product_type":"c1","uid":1528286,"ip_address":"","ucode":"794650E28C633A","user_header":"https://static001.geekbang.org/account/avatar/00/17/51/de/990fd4f2.jpg","comment_is_top":false,"comment_ctime":1583077773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23057914253","product_id":100040201,"comment_content":"老师，你讲的真清晰，我背了面试题以后，很多地方一知半解，你这个专栏给了我补充说明，真是太强了","like_count":5},{"had_liked":false,"id":154438,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1574430905,"is_pvip":false,"replies":[{"id":"59614","content":"内存空间只需要标记是空闲就可以，交换以后To区就已经是空白的了。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574686630,"ip_address":"","comment_id":154438,"utype":1}],"discussion_count":4,"race_medal":0,"score":"23049267385","product_id":100040201,"comment_content":"存活对象从From区复制到To区之后，在交换名称之前，是不是要把From区的那些不存活对象全部回收？（保证交换名字之后，To区永远是空白的）","like_count":5,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475469,"discussion_content":"内存空间只需要标记是空闲就可以，交换以后To区就已经是空白的了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574686630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2367637,"avatar":"https://static001.geekbang.org/account/avatar/00/24/20/95/89bd2c38.jpg","nickname":"pcz","note":"","ucode":"D528F5CFF4A5C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350322,"discussion_content":"为啥交换之后to区还是空白的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613810850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2367637,"avatar":"https://static001.geekbang.org/account/avatar/00/24/20/95/89bd2c38.jpg","nickname":"pcz","note":"","ucode":"D528F5CFF4A5C9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380720,"discussion_content":"To这个名字，每次都给清空后的那个区，有时是s0有时是s1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624669692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350322,"ip_address":""},"score":380720,"extra":""}]},{"author":{"id":1625006,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cb/ae/738a29d4.jpg","nickname":"Leona","note":"","ucode":"979CCCECE2DFCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214261,"discussion_content":"数据覆盖吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585152925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154389,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1574421226,"is_pvip":false,"replies":[{"id":"59619","content":"每个线程有自己的线程栈，用来管理方法的局部变量。而线程本身的管理不需要用栈。<br><br>事实上，线程是使用线程池管理的，请求到来，就到线程池中申请分配一个空闲线程，请求处理完，线程放回到空闲线程池中。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574686803,"ip_address":"","comment_id":154389,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23049257706","product_id":100040201,"comment_content":"操作系统处理线程栈这个场景是不是可以想象成，高并发场景下，每一个请求都要压入操作系统的线程栈，请求返回后，执行这个请求的线程才能从操作系统的线程栈中出栈？","like_count":5,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475451,"discussion_content":"每个线程有自己的线程栈，用来管理方法的局部变量。而线程本身的管理不需要用栈。\n\n事实上，线程是使用线程池管理的，请求到来，就到线程池中申请分配一个空闲线程，请求处理完，线程放回到空闲线程池中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574686803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154225,"user_name":"老男孩","can_delete":false,"product_type":"c1","uid":1134514,"ip_address":"","ucode":"CEC6D47412F620","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/b2/1e8b5616.jpg","comment_is_top":false,"comment_ctime":1574393373,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"23049229853","product_id":100040201,"comment_content":"虽然之前学习过相关的知识，老师讲的不敢说是最全面的，但是非常易于理解，我对jvm相关知识又有了新的认识！受益匪浅！<br>1）如果能把类加载机制说的更详细一点就更好了。因为以前我遇到过一个问题，就是tomcat启动后无法访问，一看日志报了一个PermGen空间不足的error，后来重新设置了一下就好了。原因可能是加了很多依赖jar包导致PermGen空间不足了。当时没有再多想。加载类信息以及静态常量是启动的时候一把加载进来？还是执行的过程中用到哪个类的时候再加载？如果不是一把加载进来，为什么tomcat启动后就报空间不足？<br>2）关于集合容器中元素导致的内存泄露问题，看了老师的文章我觉得如果map在方法中定义应该问题不大，但如果map是类的属性或者是一个静态属性的话就要小心了。不用元素一定要记得remove，或者可以使用弱引用的集合容器。","like_count":5,"discussions":[{"author":{"id":1109389,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ed/8d/377c106a.jpg","nickname":"KW💤","note":"","ucode":"290DD7016F4EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387873,"discussion_content":"当然springboot condition这个例子可能不太恰当，因为这是运行期的内容，只是做个类比，就是jit优化可能需要根据依赖库作一定调整","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628483046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109389,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ed/8d/377c106a.jpg","nickname":"KW💤","note":"","ucode":"290DD7016F4EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387872,"discussion_content":"我说一下我的理解，jit可能混合了装入时动态编译链接和运行时编译链接，就是说编译链接时还是要载入依赖库进行一定处理，当然具体实现是怎样就不甚明了了，像springboot condition也有基于类路径下是否有相应类文件而自动配置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628482739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339248,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQYrMibtrPKLn0XTXueA0Giazydea4iaBOAM444BKTpm4fhZ8CaWlSybAtCGT5sjrKfTvz1ibWWgXNdg/132","nickname":"五谷丰登","note":"","ucode":"F83DC34B35573B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204478,"discussion_content":"1问题增加永久代大小即可，也可以尝试升级到jdk1.8，借助替代方法区的元数据区，默认使用了堆外内存保存类信息来解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584178059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2088626,"avatar":"","nickname":"志江","note":"","ucode":"8A07D53769B3C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339248,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQYrMibtrPKLn0XTXueA0Giazydea4iaBOAM444BKTpm4fhZ8CaWlSybAtCGT5sjrKfTvz1ibWWgXNdg/132","nickname":"五谷丰登","note":"","ucode":"F83DC34B35573B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304638,"discussion_content":"方法区是持久代么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599632134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204478,"ip_address":""},"score":304638,"extra":""},{"author":{"id":1358797,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bb/cd/6e74b954.jpg","nickname":"转折点","note":"","ucode":"DE1EEEF7A5569A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2088626,"avatar":"","nickname":"志江","note":"","ucode":"8A07D53769B3C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340403,"discussion_content":"永久带是hotspot虚拟机对虚拟机规范中的方法区实现的一种叫法 7及之前叫做永久带 8开始后叫做元空间","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609995308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304638,"ip_address":""},"score":340403,"extra":""},{"author":{"id":1109389,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ed/8d/377c106a.jpg","nickname":"KW💤","note":"","ucode":"290DD7016F4EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339248,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQYrMibtrPKLn0XTXueA0Giazydea4iaBOAM444BKTpm4fhZ8CaWlSybAtCGT5sjrKfTvz1ibWWgXNdg/132","nickname":"五谷丰登","note":"","ucode":"F83DC34B35573B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387871,"discussion_content":"堆外内存也有限制大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628482301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204478,"ip_address":""},"score":387871,"extra":""}]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80063,"discussion_content":"1.一般我们开发的web项目会在启动时加载很多对象在web容器中，这些对象是常驻容器的，如果这部分对象依赖的类加载过多，肯定会导致永久代空间不足\n2.这个情况我在近期就在项目上同样遇到了，一个同步数据的程序，每次大概同步几百万的量，由于使用缓存不规范，导致堆内存空间直接爆掉，本来意图是想用redis外部缓存来存储的，结果由于同事的粗心，导致使用ConcurentHashMap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576142841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240975,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1597136371,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"18777005555","product_id":100040201,"comment_content":"我记得刚工作的时候，写了一个ConcurrentHashMap 去缓存东西。结果最后去了数据没有显式的去清除，导致内存占用率越来越大，最终导致OOM。还好在测试的时候发现了问题。我想这就是一个内存泄漏的例子吧。从那以后，遇到类似缓存问题，我首先想到的就是会不会导致内存泄漏，尽量不写全局的集合，尽量少new对象，尽量使用有淘汰策略的缓存机制。<br><br>这篇我看了将近两天，画了JVM知识体系的思维导图，还是有很多细节的东西需要自己补充。","like_count":4,"discussions":[{"author":{"id":1109389,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ed/8d/377c106a.jpg","nickname":"KW💤","note":"","ucode":"290DD7016F4EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387874,"discussion_content":"缓存一般用WeakHashMap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628483358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012416,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/72/c0/b09911a0.jpg","nickname":"meijing0114","note":"","ucode":"B349D33E2F3ECC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329910,"discussion_content":"自己做实习生的第一次上线也是因为没有使用ConcurrentHashmap，导致出现并发问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606480166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154684,"user_name":"VenFox","can_delete":false,"product_type":"c1","uid":1002112,"ip_address":"","ucode":"11F08AD5685505","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/80/b1862ca3.jpg","comment_is_top":false,"comment_ctime":1574510495,"is_pvip":true,"replies":[{"id":"59632","content":"1 因为一个对象在from和to之间多次拷贝，然后才会放入老年代。<br>2 每个线程有自己的线程栈。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574687799,"ip_address":"","comment_id":154684,"utype":1}],"discussion_count":7,"race_medal":0,"score":"18754379679","product_id":100040201,"comment_content":"老师你好<br>1.为什么新生代要设置3个区域呢？只有from和to不行吗？<br>2.多线程执行的时候，栈帧在栈上如何分配空间的，是分多个java栈吗？","like_count":4,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475549,"discussion_content":"1 因为一个对象在from和to之间多次拷贝，然后才会放入老年代。\n2 每个线程有自己的线程栈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574687799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1759325,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","nickname":"杯莫停","note":"","ucode":"4FA1D5CBBEF702","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297745,"discussion_content":"之所以有eden区的存在而且跟from、to的比例是8：1：1 是因为，大多数对象都是随着线程朝生夕死的，这个大部分肯定要分配更多的内存去存放。第一轮GC后会带走一大波。这样有利于节省内存空间。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597044920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002112,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/80/b1862ca3.jpg","nickname":"VenFox","note":"","ucode":"11F08AD5685505","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60037,"discussion_content":"老师，我第一个问题的意思是新生代为什么分成eden，from和to区域？我大概想了下，是因为经过一次minor gc以后，存活的对象比较少。如果去掉eden区域，那from和to区域分别是对半的话，那么内存的利用率就不高，所以分成三块区域，而且默认是8:1:1，是提高内存的利用率，这样理解对吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574696456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1002112,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/80/b1862ca3.jpg","nickname":"VenFox","note":"","ucode":"11F08AD5685505","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":66449,"discussion_content":"没有eden，对象没办法在from和to之间来回拷贝。或者说需要用你提出的from，to对半分的办法，这样效率低","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575071422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60037,"ip_address":""},"score":66449,"extra":""},{"author":{"id":2088626,"avatar":"","nickname":"志江","note":"","ucode":"8A07D53769B3C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":304637,"discussion_content":"老师, 如果eden+from垃圾回收之后放到to空间不足了, 那么这会会报OutOfMemoryError么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599632004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":66449,"ip_address":""},"score":304637,"extra":""},{"author":{"id":2070530,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ZrPfqw4AbHd2F4VzplicZiatLg4AgibVhEVZH4qQoia9fx9MVG4IiaWjFlibXVibFibnmTfhibyBmG40NgeJAZey7j0ZvFg/132","nickname":"冰点","note":"","ucode":"06DCC1FF869988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2088626,"avatar":"","nickname":"志江","note":"","ucode":"8A07D53769B3C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318130,"discussion_content":"我之前看到的解释是这样的，不知道对不对，感觉很合理，eden区无法回收的大对象是直接放入老年代，我觉得对于大对象直接进入老年代，实际上也是为了保证Eden区具有充足的空间可用的一种策略。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603643182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304637,"ip_address":""},"score":318130,"extra":""}]}]},{"had_liked":false,"id":154068,"user_name":"我爱布丁","can_delete":false,"product_type":"c1","uid":1575522,"ip_address":"","ucode":"660B495D34CD39","user_header":"","comment_is_top":false,"comment_ctime":1574375339,"is_pvip":false,"replies":[{"id":"59179","content":"虚拟机内部的堆和栈不会map到操作系统的堆和栈，这样才能跨平台。<br><br>操作系统看JVM就是一个普通进程。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574391476,"ip_address":"","comment_id":154068,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18754244523","product_id":100040201,"comment_content":"老师，第一讲中谈到当操作系统载入编译后程序时，会在内存中建立进程，划分代码段，堆，栈等。那么当操作系统运行JAVA虚拟机加载类文件时，在虚拟机中的Java堆，栈是否会直接map到JAVA虚拟机进程的堆，栈呢？从操作系统看一个JAVA虚拟机进程，和一个普通的编译后程序进程结构上有区别吗？","like_count":4,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475370,"discussion_content":"虚拟机内部的堆和栈不会map到操作系统的堆和栈，这样才能跨平台。\n\n操作系统看JVM就是一个普通进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574391476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55587,"discussion_content":"你这些问题非常好\n1、JVM与其他的操作系统上的应用程序没有区别。\n2、JVM给JAVA代码分配的堆啊，栈啊最终使用的JVM启动申请的内存空间而已。JVM不可能自己凭空产生出内存。\n3、我还想提醒一点，JAVA中的所谓的堆外就是绕过虚拟机直接向操作系统申请内存，他有好处也有坏处。好处是省去了内存拷贝来拷贝去的开销，同时大小不受虚拟机限制。坏处是得你自己进行回收管理，很容易出现内存泄露。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574385059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1759325,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","nickname":"杯莫停","note":"","ucode":"4FA1D5CBBEF702","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297743,"discussion_content":"那么JVM中的线程和操作系统的线程又有哪些关系呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597044587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747915,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ab/cb/b96998c7.jpg","nickname":"BrokenSea1023","note":"","ucode":"D8119EA39F6C69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57241,"discussion_content":"受益匪浅受益匪浅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574585261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249284,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1600568660,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"10190503252","product_id":100040201,"comment_content":"想要真的搞懂 JVM 虚拟机原理，那么估计还是得去看周志明的《深入理解 Java 虚拟机》（2019 年出到第 3 版），或者是隔壁的专栏《深入拆解 Java 虚拟机》。<br><br>不过李老师的这篇应该也算是深入浅出，典型 Java 程序的运行过程讲的很清楚，和整个专栏的风格比较搭。<br><br>Java 用的不够多，所以没怎么遇到与 JVM 底层相关的问题。<br><br>不过关于 OutOfMemoryError、StackOverflowError 和程序运行卡顿响应延迟较大的调试策略，对我来说很有启发。","like_count":2},{"had_liked":false,"id":322425,"user_name":"皮卡卡","can_delete":false,"product_type":"c1","uid":2715554,"ip_address":"","ucode":"52B3F234550E7F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBHy0D2KUZwOGHRG8qloicx2V4E4mImsPIiavPfr12BZB6QyUlHNdmOohC3EbsgnM2QNBeoqu82Grw/132","comment_is_top":false,"comment_ctime":1637380310,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5932347606","product_id":100040201,"comment_content":"讲的真的好顺畅啊，佩服","like_count":1},{"had_liked":false,"id":241579,"user_name":"Geek_100ec2","can_delete":false,"product_type":"c1","uid":2061693,"ip_address":"","ucode":"5B18F238F14352","user_header":"https://static001.geekbang.org/account/avatar/00/1f/75/7d/1283991d.jpg","comment_is_top":false,"comment_ctime":1597363179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892330475","product_id":100040201,"comment_content":"无论什么样的垃圾收集器应该都有stw吧，而不只是串行和并行收集器","like_count":1},{"had_liked":false,"id":240709,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1597041911,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5892009207","product_id":100040201,"comment_content":"方法区存放的是类的元数据，类加载过程可知，字节码通过类加载器变成byte[]，加载到方法区，然后在堆中开辟一个对应的Class对象。<br>栈里面放的是执行方法的数据，局部变量，引用变量，入参，返回地址等。调用一个方法生成一个栈帧压栈，等线程结束执行，会出栈。栈是线程所有的，一个萝卜一个坑，互不影响，所以不会有数据安全问题。当然如果方法内有对静态成员操作的情况除外。<br>另外程序计数器寄存器存放的是指令执行行号，一个线程执行到方法的某一行，让出了CPU，下次继续运行的时候就要访问该寄存器了。","like_count":1},{"had_liked":false,"id":240642,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1597025438,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5891992734","product_id":100040201,"comment_content":"关于三种回收算法：<br>标记清除：查找到垃圾对象，进行标记，然后进行清除。缺点是会产生内存碎片，导致内存浪费。<br>复制：将堆内存分为两块，即文章中提到的From和To区（还有别的叫法），优点是不会产生内存碎片。缺点是分两块势必会有一半的内存空间是空着的，比较浪费空间。一般用于年轻代GC。<br>压缩：或者也叫标记整理算法，事实上会分两步，标记和整理。先将垃圾标记，然后将存活对象整理移动到一端，再将标记的垃圾对象清除。特点是不会产生内存碎片，缺点是比较耗时。一般用在老年带的垃圾回收。","like_count":1},{"had_liked":false,"id":161758,"user_name":"Caliven","can_delete":false,"product_type":"c1","uid":1003139,"ip_address":"","ucode":"8C5DACDF30EF03","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/83/88151c5f.jpg","comment_is_top":false,"comment_ctime":1576317332,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5871284628","product_id":100040201,"comment_content":"看完第一节在看这一节有种恍然大悟的感觉","like_count":1},{"had_liked":false,"id":159085,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575536076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870503372","product_id":100040201,"comment_content":"Java虚拟机是操作系统之上的操作系统：<br>操作系统是加载可执行文件执行，JVM是加载class文件执行。操作系统可以调度进程和线程，JVM主要调度线程。操作系统有堆栈作为存储，JVM也有堆栈，而且还可以回收堆中的内存。另外一个角度讲操作系统是jvm的基础，jvm是操作系统运行的众多进程之一，jvm屏蔽了操作系统的底层细节，才得以跨平台的","like_count":1},{"had_liked":false,"id":154439,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1574431101,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869398397","product_id":100040201,"comment_content":"老师能多讲讲类加载吗，这儿只知道jvm加载class字节码，在深入就不懂了，谢谢老师。","like_count":1,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159295,"discussion_content":"想深入了解JVM，周志明的《深入浅出Java虚拟机》是不二之选","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580660101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154386,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1574420722,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869388018","product_id":100040201,"comment_content":"老师好，有关JVM运行前的编译过程，请问HotSpot编译器和IDEA编译器的区别是什么？","like_count":1,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159298,"discussion_content":"JVM运行前不就只需要jdk将java代码编译成字节码吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580660199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358275,"user_name":"路在哪","can_delete":false,"product_type":"c1","uid":1816609,"ip_address":"四川","ucode":"A4822AD07AD102","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b8/21/f692bdb0.jpg","comment_is_top":false,"comment_ctime":1664162616,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1664162616","product_id":100040201,"comment_content":"实用！","like_count":0},{"had_liked":false,"id":299442,"user_name":"米兰的小铁匠","can_delete":false,"product_type":"c1","uid":1146923,"ip_address":"","ucode":"E52E05954BF39D","user_header":"https://static001.geekbang.org/account/avatar/00/11/80/2b/ef1581b5.jpg","comment_is_top":false,"comment_ctime":1624629101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624629101","product_id":100040201,"comment_content":"思考总结：本篇主要介绍了JVM<br>1、Jvm构造：程序计数器、虚拟机栈、堆、方法区、运行时常量池、本地方法栈<br>2、垃圾回收：<br>划分：新生代（Eden、from、to）、老年代<br>算法：复制（from-to）、标记-清除、标记-整理（压缩应该一致吧）（老年代）<br>垃圾收集器：Serial（串行）、Parallel（并行）、CMS（并发）、G1","like_count":0},{"had_liked":false,"id":283446,"user_name":"李怡尚","can_delete":false,"product_type":"c1","uid":2041832,"ip_address":"","ucode":"7DBF963206893D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/27/e8/f4a29498.jpg","comment_is_top":false,"comment_ctime":1615785798,"is_pvip":false,"replies":[{"id":"102937","content":"方法区是堆的一部分<br>栈是线程私有的，不需要回收","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1615885784,"ip_address":"","comment_id":283446,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1615785798","product_id":100040201,"comment_content":"文中垃圾回收只说了堆内存的回收，没有说方法区和栈内存的回收？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517044,"discussion_content":"方法区是堆的一部分\n栈是线程私有的，不需要回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615885784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369793,"discussion_content":"栈用完就弹出了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619158772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281894,"user_name":"曹翔","can_delete":false,"product_type":"c1","uid":1114878,"ip_address":"","ucode":"B4D8B42DFB535C","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/fe/d539b96b.jpg","comment_is_top":false,"comment_ctime":1614937893,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614937893","product_id":100040201,"comment_content":"jvm不仅仅是java专属，java只是语言，jvm上可以跑kotlin,Scala,JRuby,Jython等等语言","like_count":0},{"had_liked":false,"id":279610,"user_name":"花不不","can_delete":false,"product_type":"c1","uid":2438420,"ip_address":"","ucode":"052F24A9DE2543","user_header":"https://static001.geekbang.org/account/avatar/00/25/35/14/901812fe.jpg","comment_is_top":false,"comment_ctime":1613868487,"is_pvip":false,"replies":[{"id":"101703","content":"可以粗暴理解：有专门机制记录新旧地址。<br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1614044397,"ip_address":"","comment_id":279610,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613868487","product_id":100040201,"comment_content":"如果在方法内创建了一个对象实例，这个对象实例信息将会被存放到堆里，而对象实例的引用，也就是对象实例在堆中的地址信息则会被记录在栈里。<br>- - - -<br>堆里面存储的对象实例在复制的过程中地址信息不会变化吗？如果变化了怎么通知到java栈呢","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515796,"discussion_content":"可以粗暴理解：有专门机制记录新旧地址。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614044397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279099,"user_name":"席席","can_delete":false,"product_type":"c1","uid":1591399,"ip_address":"","ucode":"656377E29D4F76","user_header":"https://static001.geekbang.org/account/avatar/00/18/48/67/128eda8f.jpg","comment_is_top":false,"comment_ctime":1613620419,"is_pvip":false,"replies":[{"id":"101429","content":"实现类。<br>成员变量也是无状态的，递归无状态~","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1613634358,"ip_address":"","comment_id":279099,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613620419","product_id":100040201,"comment_content":"老师，你说Service和Dao都被设计成无成员变量，所以线程安全，这里的Service和Dao指的是接口还是实现类，如果是实现类那么必然会有成员变量呀，有点疑惑🤔","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515623,"discussion_content":"实现类。\n成员变量也是无状态的，递归无状态~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613634358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251587,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1601705702,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601705702","product_id":100040201,"comment_content":"回收阶段比较耗时，因为涉及到复制，标记阶段的优化没怎么讲","like_count":0},{"had_liked":false,"id":251586,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1601705374,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601705374","product_id":100040201,"comment_content":"标记还会stop all world吧？","like_count":0},{"had_liked":false,"id":249199,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1600500249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600500249","product_id":100040201,"comment_content":"做Java开发的时候有一个问题非常烦人那就是报ClassNotFound Exception。有时候在开发工具里运行是可以的,但打成一个Jar包独立运行就出问题,请问老师怎么看一个Jar包的类路径是什么？","like_count":0},{"had_liked":false,"id":240223,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1596793636,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596793636","product_id":100040201,"comment_content":"看了第一部分 栈，我就想，为什么学JVM困难，大概是因为我们的思维方式是跟设计者反着来的。我们学习之初大概很少有人一开始就站在设计者的角度思考，如果让我来设计这样一个线程执行模型，该怎样去做，该选哪种数据结构。而我们最开始学虚拟机大概都是先从虚拟机结构开始的，然后知道里面用到栈了，最后才知道这个栈是用来做什么的。然后再出来一个堆，完蛋了，好复杂。<br>认识了Java栈的使用之后，才意识到，这个设计巧妙的应用了栈这种数据结构先进后出的特点。以后开发中很可能会遇到类似的场景，是不是就可以用栈来解决了。","like_count":0},{"had_liked":false,"id":204720,"user_name":"LH","can_delete":false,"product_type":"c1","uid":1211178,"ip_address":"","ucode":"819B9B2409E834","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/2a/7d8b5943.jpg","comment_is_top":false,"comment_ctime":1586445127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586445127","product_id":100040201,"comment_content":"满满的干货","like_count":0},{"had_liked":false,"id":192903,"user_name":"Cryhard","can_delete":false,"product_type":"c1","uid":1589593,"ip_address":"","ucode":"E0BF4548B502CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/59/78042964.jpg","comment_is_top":false,"comment_ctime":1584878009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584878009","product_id":100040201,"comment_content":"G1GC确实在新版本JVM上面表现不错！","like_count":0},{"had_liked":false,"id":187352,"user_name":"wlarein","can_delete":false,"product_type":"c1","uid":1619882,"ip_address":"","ucode":"81A6B217700403","user_header":"https://static001.geekbang.org/account/avatar/00/18/b7/aa/6427f4d8.jpg","comment_is_top":false,"comment_ctime":1584089570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584089570","product_id":100040201,"comment_content":"这篇文章讲的太🐮🍺了 佩服","like_count":0},{"had_liked":false,"id":157660,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1575244273,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575244273","product_id":100040201,"comment_content":"老师，那老年代和年轻代各自用什么样的垃圾回收算法和垃圾回收器？","like_count":0,"discussions":[{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80074,"discussion_content":"1.因为新生代的特点是对象存活率低，所以收集算法用的是复制算法，把新生代存活对象复制到老年代，复制的内容不多，性能较好。一般使用复制算法的收集器有：Serial、ParNew、Parallel Scavenge等收集器\n2.因为老年代里面对象的存活率高，如果依旧是用复制算法，需要复制的内容较多，性能较差。并且在极端情况下，当存活为100%时，没有办法用复制算法。所以需要用Mark-Compact或者Mark-Sweep，以有效地避免这些问题。一般使用此算法的收集器有：Serial Old、Parallel Old、CMS等收集器\n3.最新的垃圾收集器一般都适用于上述新生代与老年代两种情况，一般有现在使用比较的G1以及未来更加高效的ZGC","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576143596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157622,"user_name":"vega","can_delete":false,"product_type":"c1","uid":1748242,"ip_address":"","ucode":"5872FDA0974091","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJPNsfvnqsB8eTbKgzwIOhcKkzCTUSoAyujl8MtiazpP07zUfboOaWJaZK2jfRVH6S2ibXEc7WIibufA/132","comment_is_top":false,"comment_ctime":1575214729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575214729","product_id":100040201,"comment_content":"1.8之后好像xms参数不能用了。似乎g1之后还有一两个新的垃圾回收器吧","like_count":0},{"had_liked":false,"id":154481,"user_name":"miracle","can_delete":false,"product_type":"c1","uid":1276137,"ip_address":"","ucode":"FD7074F1062AE9","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/e9/9d807269.jpg","comment_is_top":false,"comment_ctime":1574439205,"is_pvip":false,"replies":[{"id":"59631","content":"每个线程都可以访问这个方法，如果在这个方法内创建一个对象，那么就意味着“每个”线程都会“自己”创建一个对象。线程之间不会访问彼此的对象。<br><br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574687729,"ip_address":"","comment_id":154481,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1574439205","product_id":100040201,"comment_content":"虽然这个对象被放置在堆中，但是这个对象不会被其他线程访问到，也是线程安全的。<br><br>请问下，多个线程都可以访问这个方法，进而可以操作堆中的对象，为什么是线程安全的","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475484,"discussion_content":"每个线程都可以访问这个方法，如果在这个方法内创建一个对象，那么就意味着“每个”线程都会“自己”创建一个对象。线程之间不会访问彼此的对象。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574687729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1358797,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bb/cd/6e74b954.jpg","nickname":"转折点","note":"","ucode":"DE1EEEF7A5569A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56342,"discussion_content":"有前提的 只要这个对象的引用没有离开过这个方法即可","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574475467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1276137,"avatar":"https://static001.geekbang.org/account/avatar/00/13/78/e9/9d807269.jpg","nickname":"miracle","note":"","ucode":"FD7074F1062AE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1358797,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bb/cd/6e74b954.jpg","nickname":"转折点","note":"","ucode":"DE1EEEF7A5569A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57280,"discussion_content":"多个线程执行这个方法应该也不会线程安全吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574590955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":56342,"ip_address":""},"score":57280,"extra":""},{"author":{"id":1358797,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bb/cd/6e74b954.jpg","nickname":"转折点","note":"","ucode":"DE1EEEF7A5569A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1276137,"avatar":"https://static001.geekbang.org/account/avatar/00/13/78/e9/9d807269.jpg","nickname":"miracle","note":"","ucode":"FD7074F1062AE9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62651,"discussion_content":"线程安全呀 因为每个线程操作的对象都是new出来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574856671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57280,"ip_address":""},"score":62651,"extra":""}]}]},{"had_liked":false,"id":154206,"user_name":"尹宗昌","can_delete":false,"product_type":"c1","uid":1215099,"ip_address":"","ucode":"C409D28F324193","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/7b/c8123a88.jpg","comment_is_top":false,"comment_ctime":1574390750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574390750","product_id":100040201,"comment_content":"老师，之前看到，MySQL connector-j 驱动在特定模式下（useCompression=true）的内存泄漏问题。能简单提个思路，这样也能循序渐进","like_count":0}]}