{"id":627994,"title":"27｜开发互不干扰，如何实现自动多环境管理？","content":"<p>你好，我是王炜。</p><p>从这节课开始，我们开始学习 GitOps 的多环境管理和安全方面的内容。</p><p>聊起多环境，你可能会立即想到下面几个常见的环境：</p><ul>\n<li>开发环境</li>\n<li>测试环境</li>\n<li>预发布环境</li>\n<li>生产环境</li>\n</ul><p>为了让不同职责的人员在不同的环境下独立工作，我们一般会将不同环境隔离。通常，开发环境主要用于开发人员的日常开发，测试环境则是为测试团队而准备的，预发布是正式发布到生产环境之前的最后一道防线，除了数据以外，应该尽量和生产环境保持一致。</p><p>当然，对有些团队来说，他们可能还希望开发人员之间相互隔离，也就是为每一个开发者分配一个独立的开发环境，使他们互不干扰。</p><p>在非云原生技术架构体系下，环境一般是由特定的团队人工维护的。所以，要想得到一个新的环境，由于文档和技术方面的原因，过程并不简单。但是，在云原生的业务架构体系下，应用是通过标准的 Kubernetes 对象被“定义”出来的。所以，在这种情况下，得到一个新的环境就变得非常容易了。</p><p>在之前介绍的 GitOps 工作流中，我们都是以部署单个环境作为例子的。那么，如果我希望为同一个应用创建新的环境，甚至是为不同的开发者创建隔离的开发环境，怎么做才最合适呢？除了手动创建重复的 ArgoCD 应用，还有没有更好的技术方案？</p><!-- [[[read_end]]] --><p>这节课，我们来看看如何使用 ArgoCD ApplicationSet 来实现 GitOps 自动多环境管理，并通过 ArgoCD Generator 来达到<strong>“代码即环境”</strong>的效果。</p><p>在开始之前，你需要在本地的 Kind 集群安装下面两个组件。</p><ul>\n<li>安装 ArgoCD。</li>\n<li>安装 Ingress-Nginx。</li>\n</ul><p>此外，你还需要克隆<a href=\"https://github.com/lyzhang1999/kubernetes-example\">示例仓库</a>，并将它推送到你的 Git 仓库中。</p><h2>自动多环境管理概述</h2><p>在正式进入实战之前，我们先来了解一下使用 ArgoCD ApplicationSet 来实现自动多环境管理的整体架构，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/42/d433a1023d1eb239cc21a4baf8f4a342.jpg?wh=1920x1606\" alt=\"图片\"></p><p>在这张架构图中，我们会创建一个 ApplicationSet 对象，它是一个 Application 集合。它可以生成 Application CRD 资源，进而自动创建多个 ArgoCD 应用。不同应用实际上就对应了不同的环境。</p><p>那么，ApplicationSet 怎么知道要创建几个 Application 对象呢？这就需要用到 ApplicationSet Generators 了。</p><p>ApplicationSet Generators 是一个可以自动生成 Application 对象的生成器，它可以通过遍历 Git 仓库中的目录来决定生成几个 Application 对象。这么说有点抽象，你可以结合下面这张图来进一步理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/75/5b/75d5b27fc07dcd5192e2e118d51b3f5b.jpg?wh=1920x1227\" alt=\"图片\"></p><p>假设我们现在有一个 Helm 应用的 Git 仓库，env 目录下存放了不同环境的 values.yaml 配置文件，那么，ApplicationSet Generators 就可以遍历这些目录，并且自动创建不同环境的 Application 对象，这样就实现了目录和环境的映射关系。也就是说，当我们需要创建一个新的环境时，<strong>只需要创建一个目录以及配置文件 values.yaml 就可以了！</strong></p><p>这样，不管是为同一个应用创建不同的环境，还是为不同的开发者创建隔离的开发环境，都可以把创建环境等同于创建目录，实现了<strong>“代码即环境”</strong>。</p><h2>自动多环境管理实战</h2><p>在实际创建 ApplicationSet 对象之前，我们先来看一下<a href=\"https://github.com/lyzhang1999/kubernetes-example\">示例仓库</a>。你需要注意的是，这节课所需要用到的示例应用在 helm-env 目录下。</p><h3>示例应用简介</h3><p>在将示例应用克隆到本地之后，进入 helm-env 目录，它的目录结构是下面这样的。</p><pre><code class=\"language-yaml\">.\n├── Chart.yaml\n├── applicationset.yaml\n├── env\n│&nbsp; &nbsp;├── dev\n│&nbsp; &nbsp;│&nbsp; &nbsp;└── values.yaml\n│&nbsp; &nbsp;├── prod\n│&nbsp; &nbsp;│&nbsp; &nbsp;└── values.yaml\n│&nbsp; &nbsp;└── test\n│&nbsp; &nbsp; &nbsp; &nbsp;└── values.yaml\n└── templates\n&nbsp; &nbsp; ├── frontend.yaml\n&nbsp; &nbsp; └── ingress.yaml\n</code></pre><p>从它的目录结构可以看出，它由 Chart.yaml、applicationset.yaml、env 目录和 templates 目录组成，熟悉 Helm 的同学应该一眼就能看出，其实它是一个 Helm Chart。不同的是，Helm 的配置文件 values.yaml 并没有放在 Chart 的根目录，而是放在了 env 目录下。</p><p>templates 目录存放着示例应用的 Kubernetes 对象，为了简化演示过程，这节课我们只部署前端相关的对象，也就是 frontend.yaml。</p><p>此外，在这个示例应用中，ingress.yaml 会用来部署 Ingress 对象，它的内容如下。</p><pre><code class=\"language-yaml\">apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: frontend\n  annotations:\n    kubernetes.io/ingress.class: nginx\nspec:\n  rules:\n    - host: {{ .Release.Namespace }}.env.my\n      http:\n        paths:\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: frontend-service\n                port:\n                  number: 3000\n</code></pre><p>需要注意的是，我在 Ingress 对象中使用了 Helm 的内置变量，也就是 Release.Namespace，它实际上指的是 Helm Chart 部署的命名空间，我把它和域名做了拼接。在这节课的例子中，不同的环境将会被部署到独立的命名空间下，这样也就使不同的环境具备了独立的访问域名，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/ac/d01250f01e623e91e0a5db1cb68a23ac.jpg?wh=1920x1302\" alt=\"图片\"></p><h3>ApplicationSet 简介</h3><p>我们再来看下ApplicationSet。ApplicationSet 是这节课介绍的重点，它可以自动生成多个 Application 对象，不同的 Application 对象实际上对应了不同的环境。</p><p>示例应用目录下有一个名为 applicationset.yaml 的文件，它定义了 ApplicationSet 的内容。</p><pre><code class=\"language-yaml\">apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: frontend\n  namespace: argocd\nspec:\n  generators:\n  - git:\n      repoURL: \"https://github.com/lyzhang1999/kubernetes-example.git\"\n      revision: HEAD\n      files:\n      - path: \"helm-env/env/*/values.yaml\"\n  template:\n    metadata:\n      name: \"{{path.basename}}\"\n    spec:\n      project: default\n      source:\n        repoURL: \"https://github.com/lyzhang1999/kubernetes-example.git\"\n        targetRevision: HEAD\n        path: \"helm-env\"\n        helm:\n          valueFiles:\n          - \"env/{{path.basename}}/values.yaml\"\n      destination:\n        server: 'https://kubernetes.default.svc'\n        namespace: '{{path.basename}}'\n      syncPolicy:\n        automated: {}\n        syncOptions:\n          - CreateNamespace=true\n</code></pre><p>这里我们分成两部分来介绍，第一部分是 spec.generators，第二部分是 spec.template。</p><p>Generators 指的是生成器。这里，我们使用 Git 生成器，并指定了 Helm Chart 仓库地址。请注意，<strong>你需要将这个地址替换为自己的仓库地址</strong>，如果仓库为私有权限，那么还需要在 ArgoCD 控制台配置仓库的凭据信息，具体你可以参考<a href=\"https://time.geekbang.org/column/article/624572\">第 22 讲</a>的内容。</p><p>revision 的值的 HEAD，指的是远端最新修改的版本。files 字段是配置的重点，它通过通配符“*”号来匹配 env 目录下的 values.yaml 文件，并为 template 字段下的 path 变量提供值。</p><p>接下来我们继续看 template 字段。你可以简单地理解为，template 实际上就是在为 Application 配置模板，结合生成器，它能够动态生成 Application 对象。例如，metadata.name 字段配置了每一个 Application 的名称，在这个例子中，path.basename 变量对应三个值，分别是 env 下子目录的名称，也就是 dev、test 和 prod。</p><p>source.repoURL 字段表示 Helm Chart 的来源仓库，<strong>你也需要将它替换为你的仓库地址</strong>。</p><p>此外，在 helm.valueFiles 里同样也用到了这个变量，在这里，我们为不同的环境指定了不同的 values.yaml，这样就实现了环境隔离。</p><p>最后，destination.namespace 字段也使用了变量，它配置了部署应用的命名空间。</p><p>最终，在这个例子中，ApplicationSet 会根据目录结构生成<strong>三个 Application 对象</strong>，而 Application 对象又会在不同的命名空间下部署示例应用，它们分别对应 dev、test 和 prod 环境。</p><h3>部署 ApplicationSet</h3><p>现在，我们尝试部署 ApplicationSet 对象。</p><p>你可以使用 kubectl apply 命令来部署它。</p><pre><code class=\"language-yaml\">$ kubectl apply -f applicationset.yaml&nbsp;\napplicationset.argoproj.io/frontend created\n</code></pre><p>部署完成后，打开 ArgoCD 控制台，你会看到 ApplicationSet 创建了三个应用，名称分别为 dev、test 和 prod，并且它们分别被部署在了不同的命名空间下，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/03/b6/03cd75b21a01ed44yy6d88fb75dbd1b6.png?wh=1920x1041\" alt=\"图片\"></p><p>还要注意的是，在进入 ArgoCD 控制台之前，你需要进行端口转发操作，并获取 ArgoCD admin 登陆密码，具体操作你可以参考<a href=\"https://time.geekbang.org/column/article/624572\">第 22 讲</a>。</p><p>到这里，ApplicationSet 就已经创建成功了。</p><h3>访问多环境</h3><p>接下来，我们尝试访问这三个环境。</p><p>在访问之前，你需要配置下面这三个 Hosts。</p><pre><code class=\"language-yaml\">127.0.0.1 dev.env.my\n127.0.0.1 test.env.my\n127.0.0.1 prod.env.my\n</code></pre><p>具体的配置方法你可以参考<a href=\"https://time.geekbang.org/column/article/625912\">第 24 讲</a>的内容。</p><p>Hosts 配置完成后，接下来我们尝试访问<strong>开发环境</strong>。打开浏览器访问 <a href=\"http://dev.env.my\">http://dev.env.my</a> ，你应该能看到下图所示的界面。</p><p><img src=\"https://static001.geekbang.org/resource/image/bb/3e/bb72afa9eb288c138318b28559dcyy3e.png?wh=1920x1041\" alt=\"图片\"></p><p>然后，你还可以访问<strong>测试环境。</strong>访问链接为 <a href=\"http://test.env.my\">http://test.env.my</a> ，同样地，你能看到相同的应用界面，只不过返回的内容中命名空间来源产生了变化，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/84/61294eacd82773b6d36a4f1a0596e484.png?wh=1920x1041\" alt=\"图片\"></p><p>到这里，我们就成功使用 ApplicationSet 创建了多个隔离环境。当我们需要对不同的环境进行更新时，只需要更新 env 目录下对应环境的 values.yaml 文件，就可以触发 ArgoCD 自动同步了，不同环境之间互不影响。</p><p>此外，当我们需要创建新的环境时，只需要在 env 目录下增加一个目录和 values.yaml 文件就可以了，ArgoCD 会根据配置自动创建新的环境。</p><h2>创建新环境实验</h2><p>接下来，我们尝试创建一个新的环境。</p><p>首先，在 env 目录下创建 staging 目录，表示预发布环境。你可以通过下面的命令来创建它。</p><pre><code class=\"language-yaml\">cd helm-env/env\nmkdir staging\n</code></pre><p>然后，将 dev 目录下的 values.yaml 复制到 staging 目录下。</p><pre><code class=\"language-yaml\">$ cp dev/values.yaml staging\n</code></pre><p>接下来，将修改提交到远端仓库。</p><pre><code class=\"language-yaml\">$ git add .\n$ git commit -m 'add stagign'\n$ git push origin main\n</code></pre><p>稍等几分钟，ArgoCD 将自动同步，并为我们创建新的 staging 环境，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/e1/7b/e130e7a9yyc0e862b7915e822db9907b.png?wh=1920x1041\" alt=\"图片\"></p><p>到这里，我们就完成了一次创建新环境的全过程。怎么样？创建环境是不是瞬间变得非常简单？</p><h2>总结</h2><p>这节课，我们学习了如何通过 ApplicationSet 来创建和管理多环境。在实际的业务场景中，我们通常会有多环境的业务需求，相比较传统的创建环境的方式，使用 ApplicationSet 大大简化了拉起一个新环境的过程。</p><p>“代码即环境”听起来虽然比较抽象，但实现起来并没有这么困难。借助应用定义，结合 Git 仓库，我们很容易就可以实现多环境管理。需要注意的是，在众多 GitOps 多环境管理的方案中，你可能还会看到另一种在这节课没有介绍的方案：<strong>通过分支来管理多环境</strong>。</p><p>我也为你简单对比一下这两种方式。就我的经验来看，采用多分支来管理 GitOps 中的多环境并不能够很好地同时解决可维护性和唯一可信源的问题。首先，分支管理模型会使我们面临差异和合并的问题，这对长期维护来说成本较高，并且在更新环境时，需要切换到不同的分支去操作，这更容易导致人为的错误。其次，分支的管理方式没有目录管理方式来得直观。</p><p>所以，<strong>在实际的项目中，我推荐你按照这节课的讲解以目录的方式来管理不同的环境。</strong></p><p>多环境除了可以用来区分开发环境、测试环境和生产环境之外，还可以很方便地为每一位开发者提供独立的开发环境。</p><p>在这节课的例子中，由于所有环境都共用 Helm Chart 的 Template 目录，所以对于应用而言，我们只需要维护 Template 目录就可以间接管理所有的环境了。而对于不同的环境，我们可以使用环境目录下的 values.yaml 文件进行差异化的配置。这样就同时兼顾了可维护性和环境的差异化配置。</p><h2>思考题</h2><p>最后，给你留一道思考题吧。</p><p>在实际的项目中，我们一般会将环境进行硬隔离，并将它们部署到不同的集群中。请你尝试修改 ApplicationSet，让每个环境在不同的集群中运行。</p><p>提示：你需要为 ArgoCD 添加集群，并将 destination 字段配置为集群名称 name 来代替 server，通过目录名和集群名的映射来实现最终目标。</p><p>欢迎你给我留言交流讨论，你也可以把这节课分享给更多的朋友一起阅读。我们下节课见。</p>","neighbors":{"left":{"article_title":"26｜生产稳定的秘密武器：如何实施自动化渐进式交付？","id":627364},"right":{"article_title":"28｜安全提升：GitOps 在哪些环节需要关注安全问题？","id":628572}},"comments":[{"had_liked":false,"id":371505,"user_name":"邵涵","can_delete":false,"product_type":"c1","uid":1069135,"ip_address":"北京","ucode":"43A16551A82F2F","user_header":"","comment_is_top":false,"comment_ctime":1679994516,"is_pvip":false,"replies":[{"id":135570,"content":"👍🏻正确，看来已经掌握了 list gennerators 类型了，赞！","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1679999685,"ip_address":"广东","comment_id":371505,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"思考题，将一套应用定义部署在多个集群中，ApplicationSet定义示例\napiVersion: argoproj.io&#47;v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: echo-server\nspec:\n  generators:\n  - list:\n      elements:\n      - cluster: production\n        url: https:&#47;&#47;47.91.XX.XX:6443\n      - cluster: staging\n        url: https:&#47;&#47;47.111.XX.XX:6443\n  template:\n    metadata:\n      name: &#39;{{cluster}}-echo-server&#39;\n    spec:\n      project: default\n      source:\n        repoURL: https:&#47;&#47;code.aliyun.com&#47;shuwei.hsw&#47;echo-server.git\n        targetRevision: main\n        path: manifests&#47;directory&#47;{{cluster}}\n      destination:\n        server: &#39;{{url}}&#39;\n        namespace: multi-echo-server","like_count":2,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611264,"discussion_content":"👍🏻正确，看来已经掌握了 list gennerators 类型了，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679999685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371410,"user_name":"邵涵","can_delete":false,"product_type":"c1","uid":1069135,"ip_address":"北京","ucode":"43A16551A82F2F","user_header":"","comment_is_top":false,"comment_ctime":1679908124,"is_pvip":false,"replies":[{"id":135567,"content":"非常好的问题。\n两个问题都能实现，applicationset 可以为 Deployment 工作负载定义 Annotations 字段，你只需要把 Image updater 相关的字段定义好就能满足。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1679987305,"ip_address":"广东","comment_id":371410,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"几个问题：\n1. applicationset.yaml 中可以使用 values.yaml 中定义的变量吗？\n2. applicationset.yaml 中定义的 application 模板，是否可以像23讲介绍的那样使用 ArgoCD Image Updater？换句话说，能在发现符合allow-tags过滤条件的新版本的镜像之后，更新工作负载并回写各个环境的values.yaml吗？\n3. 如果上边两个问题都是“可以”的话，个人认为应该是可以实现“dev、test、prod环境分别使用从不同的源码分支构建的镜像”这种需求的，但如果上边两个问题是“不可以”的话，要如何实现这个需求呢？为每个环境创建独立的git仓库保存该环境对应的应用定义，进而为每个环境单独创建Application对象，而不使用ApplicationSet？","like_count":1,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611234,"discussion_content":"非常好的问题。\n两个问题都能实现，applicationset 可以为 Deployment 工作负载定义 Annotations 字段，你只需要把 Image updater 相关的字段定义好就能满足。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679987305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370788,"user_name":"","can_delete":false,"product_type":"c1","uid":1054966,"ip_address":"北京","ucode":"7C1566DF59C99A","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/f6/aeed67fc.jpg","comment_is_top":false,"comment_ctime":1679277149,"is_pvip":true,"replies":[{"id":135286,"content":"几十个微服务其实也还好，结合合理的 resource request 和 limit 可以实现资源超卖。不过对于大型的服务来说，共用一套基础服务的方式也是一个不错的方案。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1679279334,"ip_address":"广东","comment_id":370788,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"这种方式感觉比较适合独立开发测试的服务，如果有比较多关联的上下游服务的话，感觉就会直接拉起一套很庞大的环境，这种情况是不是就不适合这么搞了。","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609880,"discussion_content":"几十个微服务其实也还好，结合合理的 resource request 和 limit 可以实现资源超卖。不过对于大型的服务来说，共用一套基础服务的方式也是一个不错的方案。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679279334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369331,"user_name":"po","can_delete":false,"product_type":"c1","uid":1023905,"ip_address":"上海","ucode":"7DB36C278F34D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/a1/d75219ee.jpg","comment_is_top":false,"comment_ctime":1677415294,"is_pvip":true,"replies":[{"id":134591,"content":"是的，感谢指正。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1677465895,"ip_address":"广东","comment_id":369331,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"首先，「不用分支」会使我们面临差异和合并的问题，这对长期维护来说成本较高，并且在更新环境时，需要切换到不同的分支去操作，这更容易导致人为的错误。其次，分支的管理方式没有目录管理方式来得直观。\n==============================\n看上下文内容，这里应该是 不用分支 --&gt; 用分支?","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606858,"discussion_content":"是的，感谢指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677465895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368849,"user_name":"橙汁","can_delete":false,"product_type":"c1","uid":1332257,"ip_address":"北京","ucode":"EC3FF10D708C9D","user_header":"https://static001.geekbang.org/account/avatar/00/14/54/21/0bac2254.jpg","comment_is_top":false,"comment_ctime":1676804856,"is_pvip":false,"replies":[{"id":134338,"content":"第二种方案是可行的。\n第一种方案值得实践一下。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1676810579,"ip_address":"广东","comment_id":368849,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"有种实际场景借助applicationset在不同集群中创建了各自的环境，接下来想进行镜像更新想到两种实现方案。\n1. 借助images updater插件，根据23章内容来看是修改application资源，当前application是自动创建不确定修改后是否会有问题。\n2. 将打包成功后镜像的tag更新到helm仓库中，也就是value.yaml文件。假设代码和部署是两个仓库，就需要在ci最后阶段更新helm仓库的value.yaml。\n希望老师能指正下思路是否正确。","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605640,"discussion_content":"第二种方案是可行的。\n第一种方案值得实践一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676810579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1332257,"avatar":"https://static001.geekbang.org/account/avatar/00/14/54/21/0bac2254.jpg","nickname":"橙汁","note":"","ucode":"EC3FF10D708C9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":605642,"discussion_content":"好的 感谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676810633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":605640,"ip_address":"北京","group_id":0},"score":605642,"extra":""}]}]},{"had_liked":false,"id":394120,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1057843,"ip_address":"新加坡","ucode":"BC93175B70E05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","comment_is_top":false,"comment_ctime":1725876251,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"真实研发流程复杂的地方在于需要每个开发人员一个环境，每个版本一个环境，环境中的应用还需要齐套，不是简单的dev、sit、uat、prod各一个环境。这个不知道老师有什么好的实践和建议。","like_count":1},{"had_liked":false,"id":369890,"user_name":"ghostwritten","can_delete":false,"product_type":"c1","uid":1308196,"ip_address":"北京","ucode":"AE512F2E24A1A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/24/547439f1.jpg","comment_is_top":false,"comment_ctime":1678100647,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":2,"product_id":100312001,"comment_content":"总结：\nGit &amp; k8s &amp; argocd &amp; ApplationSet\n1.安装 kind\n2. 安装argo\n3. 安装 ingress\n4. 下载 kubernetes-example\n5. 明确helm-env名录\n6. 定义 template 的ingress.yaml、fronted.yaml变量，例如：命名空间、镜像名称版本\n7. 重点理解applationset.yaml的参数定义\n\n扩展：https:&#47;&#47;argo-cd.readthedocs.io&#47;en&#47;stable&#47;\nArgocd ApplationSet有以下Generator：\n- List Generator （实现多集群）\n- Cluster Generator\n- Git Generator\n- Matrix generator\n玩法多多\n\n问题：\nArgoCD + ApplationSet VS ArgoCD +kustomize 多环境（多集群多空间）谁更出色？","like_count":1},{"had_liked":false,"id":383706,"user_name":"bingo","can_delete":false,"product_type":"c1","uid":1880434,"ip_address":"吉林","ucode":"B78AEBC15F9456","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/0yFVUquLaq9HdHr0qjegD612UqJqLmCCekDGQDWJF3a7kbYWicLIJ6QLViaZqqKprekfDXsZX0qYgBX7JVDxPwoic9DGrHTBZaUtE3j6Y4MznM/132","comment_is_top":false,"comment_ctime":1699499107,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"老师您好，请问如何在gitops流程中引入制品晋级的机制，比如不同环境的发布需要先在开发环境验证过再发测试，测试验证过再发生产环境？","like_count":0}]}