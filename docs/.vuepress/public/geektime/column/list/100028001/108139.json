{"id":108139,"title":"24 | 如何优化JVM内存分配？","content":"<p>你好，我是刘超。</p><p>JVM调优是一个系统而又复杂的过程，但我们知道，在大多数情况下，我们基本不用去调整JVM内存分配，因为一些初始化的参数已经可以保证应用服务正常稳定地工作了。</p><p>但所有的调优都是有目标性的，JVM内存分配调优也一样。没有性能问题的时候，我们自然不会随意改变JVM内存分配的参数。那有了问题呢？<span class=\"orange\">有了什么样的性能问题我们需要对其进行调优呢？又该如何调优呢？</span>这就是我今天要分享的内容。</p><h2>JVM内存分配性能问题</h2><p>谈到JVM内存表现出的性能问题时，你可能会想到一些线上的JVM内存溢出事故。但这方面的事故往往是应用程序创建对象导致的内存回收对象难，一般属于代码编程问题。</p><p>但其实很多时候，在应用服务的特定场景下，JVM内存分配不合理带来的性能表现并不会像内存溢出问题这么突出。可以说如果你没有深入到各项性能指标中去，是很难发现其中隐藏的性能损耗。</p><p>JVM内存分配不合理最直接的表现就是频繁的GC，这会导致上下文切换等性能问题，从而降低系统的吞吐量、增加系统的响应时间。因此，<span class=\"orange\">如果你在线上环境或性能测试时，发现频繁的GC，且是正常的对象创建和回收，这个时候就需要考虑调整JVM内存分配了，</span>从而减少GC所带来的性能开销。</p><!-- [[[read_end]]] --><h2>对象在堆中的生存周期</h2><p>了解了性能问题，那需要做的势必就是调优了。但先别急，在了解JVM内存分配的调优过程之前，我们先来看看一个新创建的对象在堆内存中的生存周期，为后面的学习打下基础。</p><p>在<a href=\"https://time.geekbang.org/column/article/106203\">第20讲</a>中，我讲过JVM内存模型。我们知道，在JVM内存模型的堆中，堆被划分为新生代和老年代，新生代又被进一步划分为Eden区和Survivor区，最后Survivor由From Survivor和To Survivor组成。</p><p>当我们新建一个对象时，对象会被优先分配到新生代的Eden区中，这时虚拟机会给对象定义一个对象年龄计数器（通过参数-XX:MaxTenuringThreshold设置）。</p><p>同时，也有另外一种情况，当Eden空间不足时，虚拟机将会执行一个新生代的垃圾回收（Minor GC）。这时JVM会把存活的对象转移到Survivor中，并给对象的年龄+1。对象在Survivor中同样也会经历MinorGC，每经过一次MinorGC，对象的年龄将会+1。</p><p>当然了，内存空间也是有设置阈值的，可以通过参数-XX:PetenureSizeThreshold设置直接被分配到老年代的最大对象，这时如果分配的对象超过了设置的阀值，对象就会直接被分配到老年代，这样做的好处就是可以减少新生代的垃圾回收。</p><h2>查看JVM堆内存分配</h2><p>我们知道了一个对象从创建至回收到堆中的过程，接下来我们再来了解下JVM堆内存是如何分配的。在默认不配置JVM堆内存大小的情况下，JVM根据默认值来配置当前内存大小。我们可以通过以下命令来查看堆内存配置的默认值：</p><pre><code>java -XX:+PrintFlagsFinal -version | grep HeapSize \njmap -heap 17284\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/43/d5/436338cc5251291eeb6dbb57467443d5.png?wh=803*118\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/59/de/59941c65600fe4a11e5bc6b8304fe0de.png?wh=704*675\" alt=\"\"></p><p>通过命令，我们可以获得在这台机器上启动的JVM默认最大堆内存为1953MB，初始化大小为124MB。</p><p>在JDK1.7中，默认情况下年轻代和老年代的比例是1:2，我们可以通过–XX:NewRatio重置该配置项。年轻代中的Eden和To Survivor、From Survivor的比例是8:1:1，我们可以通过-XX:SurvivorRatio重置该配置项。</p><p>在JDK1.7中如果开启了-XX:+UseAdaptiveSizePolicy配置项，JVM将会动态调整Java堆中各个区域的大小以及进入老年代的年龄，–XX:NewRatio和-XX:SurvivorRatio将会失效，而JDK1.8是默认开启-XX:+UseAdaptiveSizePolicy配置项的。</p><p>还有，在JDK1.8中，不要随便关闭UseAdaptiveSizePolicy配置项，除非你已经对初始化堆内存/最大堆内存、年轻代/老年代以及Eden区/Survivor区有非常明确的规划了。否则JVM将会分配最小堆内存，年轻代和老年代按照默认比例1:2进行分配，年轻代中的Eden和Survivor则按照默认比例8:2进行分配。这个内存分配未必是应用服务的最佳配置，因此可能会给应用服务带来严重的性能问题。</p><h2>JVM内存分配的调优过程</h2><p>我们先使用JVM的默认配置，观察应用服务的运行情况，下面我将结合一个实际案例来讲述。现模拟一个抢购接口，假设需要满足一个5W的并发请求，且每次请求会产生20KB对象，我们可以通过千级并发创建一个1MB对象的接口来模拟万级并发请求产生大量对象的场景，具体代码如下：</p><pre><code>\t\n\t@RequestMapping(value = &quot;/test1&quot;)\n\tpublic String test1(HttpServletRequest request) {\n\t\tList&lt;Byte[]&gt; temp = new ArrayList&lt;Byte[]&gt;();\n\t\t\n\t\tByte[] b = new Byte[1024*1024];\n\t\ttemp.add(b);\n\t\t\n\t\treturn &quot;success&quot;;\n\t}\n</code></pre><h3>AB压测</h3><p>分别对应用服务进行压力测试，以下是请求接口的吞吐量和响应时间在不同并发用户数下的变化情况：</p><p><img src=\"https://static001.geekbang.org/resource/image/8b/26/8b67579af661a666dff89d16ab2e2f26.jpg?wh=980*607\" alt=\"\"></p><p>可以看到，当并发数量到了一定值时，吞吐量就上不去了，响应时间也迅速增加。那么，在JVM内部运行又是怎样的呢？</p><h3>分析GC日志</h3><p>此时我们可以通过GC日志查看具体的回收日志。我们可以通过设置VM配置参数，将运行期间的GC日志 dump下来，具体配置参数如下：</p><pre><code> -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/log/heapTest.log\n</code></pre><p>以下是各个配置项的说明：</p><ul>\n<li>-XX:PrintGCTimeStamps：打印GC具体时间；</li>\n<li>-XX:PrintGCDetails ：打印出GC详细日志；</li>\n<li>-Xloggc: path：GC日志生成路径。</li>\n</ul><p>收集到GC日志后，我们就可以使用<a href=\"https://time.geekbang.org/column/article/107396\">第22讲</a>中介绍过的GCViewer工具打开它，进而查看到具体的GC日志如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/bf/d1/bffd496963f6bbd345092c1454524dd1.jpeg?wh=1112*705\" alt=\"\"></p><p>主页面显示FullGC发生了13次，右下角显示年轻代和老年代的内存使用率几乎达到了100%。而FullGC会导致stop-the-world的发生，从而严重影响到应用服务的性能。此时，我们需要调整堆内存的大小来减少FullGC的发生。</p><h3>参考指标</h3><p>我们可以将某些指标的预期值作为参考指标，上面的GC频率就是其中之一，那么还有哪些指标可以为我们提供一些具体的调优方向呢？</p><p><strong>GC频率：</strong>高频的FullGC会给系统带来非常大的性能消耗，虽然MinorGC相对FullGC来说好了许多，但过多的MinorGC仍会给系统带来压力。</p><p><strong>内存：</strong>这里的内存指的是堆内存大小，堆内存又分为年轻代内存和老年代内存。首先我们要分析堆内存大小是否合适，其实是分析年轻代和老年代的比例是否合适。如果内存不足或分配不均匀，会增加FullGC，严重的将导致CPU持续爆满，影响系统性能。</p><p><strong>吞吐量：</strong>频繁的FullGC将会引起线程的上下文切换，增加系统的性能开销，从而影响每次处理的线程请求，最终导致系统的吞吐量下降。</p><p><strong>延时：</strong>JVM的GC持续时间也会影响到每次请求的响应时间。</p><h3>具体调优方法</h3><p><strong>调整堆内存空间减少FullGC：</strong>通过日志分析，堆内存基本被用完了，而且存在大量FullGC，这意味着我们的堆内存严重不足，这个时候我们需要调大堆内存空间。</p><pre><code>java -jar -Xms4g -Xmx4g heapTest-0.0.1-SNAPSHOT.jar\n</code></pre><p>以下是各个配置项的说明：</p><ul>\n<li>-Xms：堆初始大小；</li>\n<li>-Xmx：堆最大值。</li>\n</ul><p>调大堆内存之后，我们再来测试下性能情况，发现吞吐量提高了40%左右，响应时间也降低了将近50%。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/af/5fd7c3f198018cf5e789c25bd4f14caf.png?wh=686*389\" alt=\"\"></p><p>再查看GC日志，发现FullGC频率降低了，老年代的使用率只有16%了。</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/2e/b924a13d8cb4e383b94e82d34125002e.jpeg?wh=1118*707\" alt=\"\"></p><p><strong>调整年轻代减少MinorGC：</strong>通过调整堆内存大小，我们已经提升了整体的吞吐量，降低了响应时间。那还有优化空间吗？我们还可以将年轻代设置得大一些，从而减少一些MinorGC（<a href=\"https://time.geekbang.org/column/article/107396\">第22讲</a>有通过降低Minor GC频率来提高系统性能的详解）。</p><pre><code>java -jar -Xms4g -Xmx4g -Xmn3g heapTest-0.0.1-SNAPSHOT.jar\n</code></pre><p>再进行AB压测，发现吞吐量上去了。</p><p><img src=\"https://static001.geekbang.org/resource/image/55/04/55de34ab7eccaf9ad83bac846d0cbf04.png?wh=643*424\" alt=\"\"></p><p>再查看GC日志，发现MinorGC也明显降低了，GC花费的总时间也减少了。</p><p><img src=\"https://static001.geekbang.org/resource/image/75/5d/75f84993ba0c52d6d338d19dd4db1a5d.jpeg?wh=1113*707\" alt=\"\"></p><p><strong>设置Eden、Survivor区比例：</strong>在JVM中，如果开启 AdaptiveSizePolicy，则每次 GC 后都会重新计算 Eden、From Survivor和 To Survivor区的大小，计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量。这个时候SurvivorRatio默认设置的比例会失效。</p><p>在JDK1.8中，默认是开启AdaptiveSizePolicy的，我们可以通过-XX:-UseAdaptiveSizePolicy关闭该项配置，或显示运行-XX:SurvivorRatio=8将Eden、Survivor的比例设置为8:2。大部分新对象都是在Eden区创建的，我们可以固定Eden区的占用比例，来调优JVM的内存分配性能。</p><p>再进行AB性能测试，我们可以看到吞吐量提升了，响应时间降低了。</p><p><img src=\"https://static001.geekbang.org/resource/image/91/c2/91eb734ea45dc8a24b7938401eafb7c2.png?wh=598*417\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/cf/fd/cfaef71dbc8ba4f149a6e134482370fd.jpeg?wh=1131*704\" alt=\"\"></p><h2>总结</h2><p><span class=\"orange\">JVM内存调优通常和GC调优是互补的，</span>基于以上调优，我们可以继续对年轻代和堆内存的垃圾回收算法进行调优。这里可以结合上一讲的内容，一起完成JVM调优。</p><p>虽然分享了一些JVM内存分配调优的常用方法，但我还是建议你在进行性能压测后如果没有发现突出的性能瓶颈，就继续使用JVM默认参数，起码在大部分的场景下，默认配置已经可以满足我们的需求了。但满足不了也不要慌张，结合今天所学的内容去实践一下，相信你会有新的收获。</p><h2>思考题</h2><p>以上我们都是基于堆内存分配来优化系统性能的，但在NIO的Socket通信中，其实还使用到了堆外内存来减少内存拷贝，实现Socket通信优化。<span class=\"orange\">你知道堆外内存是如何创建和回收的吗？</span></p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","neighbors":{"left":{"article_title":"23 | 如何优化垃圾回收机制？","id":107396},"right":{"article_title":"25 | 内存持续上升，我该如何排查问题？","id":108582}},"comments":[{"had_liked":false,"id":116116,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1563789195,"is_pvip":false,"replies":[{"id":"42707","content":"回答很全面，赞！","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563932356,"ip_address":"","comment_id":116116,"utype":1}],"discussion_count":4,"race_medal":0,"score":"254966859659","product_id":100028001,"comment_content":"堆外内存创建有两种方式:1.使用ByteBuffer.allocateDirect()得到一个DirectByteBuffer对象,初始化堆外内存大小,里面会创建Cleaner对象,绑定当前this.DirectByteBuffer的回收,通过put,get传递进去Byte数组,或者序列化对象,Cleaner对象实现一个虚引用(当内存被回收时,会受到一个系统通知)当Full GC的时候,如果DirectByteBuffer标记为垃圾被回收,则Cleaner会收到通知调用clean()方法,回收改堆外内存DirectByteBuffer","like_count":60,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459391,"discussion_content":"回答很全面，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563932356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338265,"discussion_content":"我想问问...这里是不是只是说了一种方式啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609227233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385365,"discussion_content":"原来虚引用是这个作用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627015310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344281,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","nickname":"Evan","note":"","ucode":"B877ABD0CF4661","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210991,"discussion_content":"Full GC 时会回收到   堆外内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584797014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115028,"user_name":"迎风劲草","can_delete":false,"product_type":"c1","uid":1511787,"ip_address":"","ucode":"66EDA6C0B12A44","user_header":"https://static001.geekbang.org/account/avatar/00/17/11/6b/8034959a.jpg","comment_is_top":false,"comment_ctime":1563457082,"is_pvip":false,"replies":[{"id":"42356","content":"也不是越大越好，因为新生代过大，会导致minor gc的停顿时间过长。<br><br>我们知道，如果新生代很快就满了，会以担保的方式将新增的对象直接分配到老年代，这样增加了老年代回收的成本，这个成本跟具体的垃圾收集器相关。所以我们需要适当的调大年轻代，将对象尽量留在年轻代回收。<br><br>如果调整太大，我们知道每次Minor GC分为对象标记和复制两个阶段，并且都是STW的，如果对象过于庞大，有可能标记时间要大于复制时间，这样反而适得其反。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563760673,"ip_address":"","comment_id":115028,"utype":1}],"discussion_count":1,"race_medal":1,"score":"91757770298","product_id":100028001,"comment_content":"老师，你的这个抢购场景下我理解是不是新生代越大越好，因为对象都是生命周期较短的对象。尽量在新生代中被回收掉。","like_count":22,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458934,"discussion_content":"也不是越大越好，因为新生代过大，会导致minor gc的停顿时间过长。\n\n我们知道，如果新生代很快就满了，会以担保的方式将新增的对象直接分配到老年代，这样增加了老年代回收的成本，这个成本跟具体的垃圾收集器相关。所以我们需要适当的调大年轻代，将对象尽量留在年轻代回收。\n\n如果调整太大，我们知道每次Minor GC分为对象标记和复制两个阶段，并且都是STW的，如果对象过于庞大，有可能标记时间要大于复制时间，这样反而适得其反。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563760673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168750,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1578149962,"is_pvip":false,"replies":[{"id":"65923","content":"线上正常情况下FullGC出现的频率是非常低的，几天一次，一般FullGC如果出现一天超过一次，就已经算频繁了。<br><br>做性能压测的时候，FullGC的频率会高一些，但也是仅限于个位数。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1578483469,"ip_address":"","comment_id":168750,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74592593994","product_id":100028001,"comment_content":"如果你在线上环境或性能测试时，发现频繁的 GC，且是正常的对象创建和回收，这个时候就需要考虑调整 JVM 内存分配了。。有个问题，这个频率多久算频繁呢？","like_count":18,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480320,"discussion_content":"线上正常情况下FullGC出现的频率是非常低的，几天一次，一般FullGC如果出现一天超过一次，就已经算频繁了。\n\n做性能压测的时候，FullGC的频率会高一些，但也是仅限于个位数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578483469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385366,"discussion_content":"也就是基本没有fgc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627015480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114387,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1563288562,"is_pvip":false,"replies":[{"id":"41771","content":"对的。合理设置堆内存大小，根据实际业务调整，不宜过大，也不宜过小。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563326294,"ip_address":"","comment_id":114387,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40217994226","product_id":100028001,"comment_content":"盲目增大堆内存可能会让吞吐量不增反减，堆内存大了，每次gc扫描对象也就越多也越需要花费时间，反而会适得其反","like_count":10,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458638,"discussion_content":"对的。合理设置堆内存大小，根据实际业务调整，不宜过大，也不宜过小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563326294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132763,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568215071,"is_pvip":false,"replies":[{"id":"51113","content":"优化传输性能，例如使用特定的数据结构序列化与反序列化传输数据（protobuff序列化），并且提高单台服务并行处理能力。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568535752,"ip_address":"","comment_id":132763,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27338018847","product_id":100028001,"comment_content":"课后思考及问题<br>1：JVM 内存分配不合理最直接的表现就是频繁的 GC，这会导致上下文切换等性能问题，从而降低系统的吞吐量、增加系统的响应时间。<br>频繁的GC，GC线程和应用线程会频繁的切入切出，所以，降低了系统的性能。<br>2：老师好，现在有这么一个问题，我们有一个定时任务跑一次大概会有2亿条数据一条数据大概40kb大小，一次大概7.4TB多的数据，分布式任务50台机器需要刷新2个多小时，我们需要持久化，为了提高性能做了异步发送MQ到另外的机器来持久化，不过MQ积压严重，数据跑一次耗时太长，有什么建议的优化思路嘛？拆分消息会加剧业务处理的复杂度，目前我能想到的是加机器加带宽。请老师给个优化的思考？<br>","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467112,"discussion_content":"优化传输性能，例如使用特定的数据结构序列化与反序列化传输数据（protobuff序列化），并且提高单台服务并行处理能力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568535752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1620182,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUibBvL6DicGNCHmyaxrZut4lQPEs8dULBRAkdCbQaiaESFT4vfkWMp4emPbib5Cba6BvzSXMwz8JAFw/132","nickname":"Geek_7be80f","note":"","ucode":"65EBB513F383CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411055,"discussion_content":"如果持久化用的是数据库,可以考虑批量存储。如果硬盘，也可以用试着用缓冲写入的方式，尽量减少io次数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635838991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2664121,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a6/b9/6bdaf8ce.jpg","nickname":"rich_li","note":"","ucode":"B82495DDC942DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407587,"discussion_content":"一般不考虑优化内部代码的情况下，加机器是比较简单的了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635067847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114234,"user_name":"我又不乱来","can_delete":false,"product_type":"c1","uid":1221356,"ip_address":"","ucode":"737405E2339A8D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/ec/205fd50c.jpg","comment_is_top":false,"comment_ctime":1563259115,"is_pvip":false,"replies":[{"id":"41778","content":"对的，细节把握的很好！<br><br>前提是老年代有容量这些对象的空间，才会进行分配担保。如果老年代剩余空间小于每次minor gc晋升到老年代的平均值，则会发起一次Full GC。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563328327,"ip_address":"","comment_id":114234,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27333062891","product_id":100028001,"comment_content":"超哥，有两个疑问。<br>当第一次创建对象的时候 eden 空间不足会进行一次minor gc把存活的对象放到from s区。如果这个时候from s放不下。会发生一次担保进入老年代吗？<br>当一次创建对象的时候eden空间不足进入from s区。当第二次创建对象的时候eden空间又不足了，这个时候会把，eden和第一次存在from s 区的对象进行gc 存活的放在 to s区，to s区空间不足，进行担保放入老年代？这样的理解对吗。<br>","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458572,"discussion_content":"对的，细节把握的很好！\n\n前提是老年代有容量这些对象的空间，才会进行分配担保。如果老年代剩余空间小于每次minor gc晋升到老年代的平均值，则会发起一次Full GC。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563328327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114358,"user_name":"恰饭哒","can_delete":false,"product_type":"c1","uid":1014023,"ip_address":"","ucode":"0395069A050057","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/07/2f418316.jpg","comment_is_top":false,"comment_ctime":1563281686,"is_pvip":true,"replies":[{"id":"41773","content":"你好，某一时间段高峰值的访问可能会有这种情况，JVM会最大可能进行对象的回收，防止内存溢出异常的发生。如果不是内存泄漏，或者瞬时并发量大大超过预期并发量的情况，几乎很少发生内存溢出异常。<br><br>建议结合内存持续占用率以及Full GC发生的频率来分析调优。<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563326772,"ip_address":"","comment_id":114358,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18743150870","product_id":100028001,"comment_content":"超哥好，我们经常发现生产环境内存使用超过90％持续3分钟，没有outofmer,<br>dump下来堆没有发现问题，这种情况每不确定几小时就会一次，求解答","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458622,"discussion_content":"你好，某一时间段高峰值的访问可能会有这种情况，JVM会最大可能进行对象的回收，防止内存溢出异常的发生。如果不是内存泄漏，或者瞬时并发量大大超过预期并发量的情况，几乎很少发生内存溢出异常。\n\n建议结合内存持续占用率以及Full GC发生的频率来分析调优。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563326772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014023,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/07/2f418316.jpg","nickname":"恰饭哒","note":"","ucode":"0395069A050057","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2226,"discussion_content":"对的，我思考了下是正常的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563369420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150971,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1573636662,"is_pvip":false,"replies":[{"id":"72193","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584016917,"ip_address":"","comment_id":150971,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14458538550","product_id":100028001,"comment_content":"根据老师的教程，在测试项目中，将年轻代的大小调整为3g，发现的确性能提升了，Mirror GC的次数也大大减少，但是Full GC的次数也明显多了几倍，这个是因为年轻代的空间过大，压缩了老年代的内存大小吗？<br>java -jar -Xms4g -Xmx4g -Xmn3g heapTest-0.0.1-SNAPSHOT.jar","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474331,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584016917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437292,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/6c/246fa0d1.jpg","nickname":"Mr.差不多","note":"","ucode":"946555FCAE710B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117792,"discussion_content":"我觉得你这样调整得不偿失啊，减少了Mirror GC 但是增加了Full GC，堆一共就4个G，给新生代多了必然给老年代就少了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578140057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132257,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1568074354,"is_pvip":false,"replies":[{"id":"50583","content":"打开分配担保机制，是为了避免Full GC过于频繁。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568079836,"ip_address":"","comment_id":132257,"utype":1}],"discussion_count":1,"race_medal":1,"score":"14452976242","product_id":100028001,"comment_content":"老师，如果允许分配担保机制失败。那即使老年代的空间不足以吃下年轻代的对象。jvm也会冒险进行minor gc的。gc之后，如果老年代还是吃不下对象，这个时候才会Full GC。那关闭这个分配担保机制，感觉好一点啊，反正有Full GC兜底呢😃","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466844,"discussion_content":"打开分配担保机制，是为了避免Full GC过于频繁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568079836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114107,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1563238769,"is_pvip":false,"replies":[{"id":"41781","content":"这个会根据我们的内存创建大小合理分配内存，并不仅仅考虑对象晋升的问题，还会综合考虑回收停顿时间等因素。<br><br>针对某些特殊场景，我们可以手动来配置调优。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563329306,"ip_address":"","comment_id":114107,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14448140657","product_id":100028001,"comment_content":"老师好!堆外缓存实在FGC的时候回收的吧。<br>AdaptiveSizePolicy这个参数是不是不太智能啊?我项目4G内存默认开启的AdaptiveSizePolicy。发现只给年轻代分配了136M内存。平时运行到没啥问题，没到定时任务的点就频繁FGC。每次定时任务执行完，都会往老年代推40多M，一天会堆300多M到老年代，也不见它把年轻代调大。用的parNew+CMS。后来把年轻代调整到1G(单次YGC耗时从20ms增加到了40ms)，每天老年代内存涨20M左右。","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458520,"discussion_content":"这个会根据我们的内存创建大小合理分配内存，并不仅仅考虑对象晋升的问题，还会综合考虑回收停顿时间等因素。\n\n针对某些特殊场景，我们可以手动来配置调优。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563329306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274952,"user_name":"刘梦春","can_delete":false,"product_type":"c1","uid":2208033,"ip_address":"","ucode":"D79C1246196A58","user_header":"","comment_is_top":false,"comment_ctime":1611229805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5906197101","product_id":100028001,"comment_content":"堆内存最多4g  年轻代3g   1g的老年代怎么给年轻代做担保？","like_count":1},{"had_liked":false,"id":158787,"user_name":"Levvy","can_delete":false,"product_type":"c1","uid":1432884,"ip_address":"","ucode":"27A6A6134DCB4A","user_header":"https://static001.geekbang.org/account/avatar/00/15/dd/34/d8f198c8.jpg","comment_is_top":false,"comment_ctime":1575451172,"is_pvip":false,"replies":[{"id":"60852","content":"在jmap -heap pid运行之后，有一个MaxHeapSize，这个就是1953M，还有一个是NewSize以及OldSize，加起来就是初始化的124M大小。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1575537778,"ip_address":"","comment_id":158787,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5870418468","product_id":100028001,"comment_content":"最大堆内存1593M  还有124M 这俩数字是在哪看的，我怎么找不到","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476847,"discussion_content":"在jmap -heap pid运行之后，有一个MaxHeapSize，这个就是1953M，还有一个是NewSize以及OldSize，加起来就是初始化的124M大小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575537778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105148,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dc/fc/5c3ad841.jpg","nickname":"asura","note":"","ucode":"4AF66C19B4AE65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":151149,"discussion_content":"MaxHeapSize 是1956M","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579859663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134045,"user_name":"小笨蛋","can_delete":false,"product_type":"c1","uid":1118331,"ip_address":"","ucode":"7065FB157C4B70","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/7b/eed9d6d6.jpg","comment_is_top":false,"comment_ctime":1568728594,"is_pvip":true,"replies":[{"id":"51445","content":"需要根据自己的项目来具体做配置，如果不清除具体需要的配置大小，使用默认配置就可以了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568772937,"ip_address":"","comment_id":134045,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863695890","product_id":100028001,"comment_content":"请问堆内存的分配有没有一个大概的标准😭既然都提到了不能太大也不能太小","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467597,"discussion_content":"需要根据自己的项目来具体做配置，如果不清除具体需要的配置大小，使用默认配置就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568772937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129028,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1567010289,"is_pvip":false,"replies":[{"id":"48623","content":"嗯，在后面的答疑课堂中讲到了，有问题欢迎提出","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567425345,"ip_address":"","comment_id":129028,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861977585","product_id":100028001,"comment_content":"你好，请问G1调优能不能也讲讲。主要应该注意些什么和cms这种调优的差异","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465231,"discussion_content":"嗯，在后面的答疑课堂中讲到了，有问题欢迎提出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567425345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322780,"user_name":"披荆斩棘","can_delete":false,"product_type":"c1","uid":1629174,"ip_address":"","ucode":"FC8A0AFA16A1AC","user_header":"https://static001.geekbang.org/account/avatar/00/18/db/f6/eac83ef4.jpg","comment_is_top":false,"comment_ctime":1637583522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637583522","product_id":100028001,"comment_content":"超哥，我最近在学并行编程过程中，学master- work并行程序设计模式，运行书中给的示例，就是“用线程计算1到10000的3次方和”，我的电脑是8核20g内存，用一个线程和用5个线程去跑，跑出来时间差不多，非常疑惑，按道理时间是1线程跑的1&#47;5吧","like_count":0},{"had_liked":false,"id":285012,"user_name":"aroll","can_delete":false,"product_type":"c1","uid":1023524,"ip_address":"","ucode":"3A1A1267C88CC3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/24/0d6a7987.jpg","comment_is_top":false,"comment_ctime":1616579023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616579023","product_id":100028001,"comment_content":"netty4通过引用计数，来处理缓冲区的复用与回收","like_count":0},{"had_liked":false,"id":281525,"user_name":"李飞","can_delete":false,"product_type":"c1","uid":1179622,"ip_address":"","ucode":"4B23FF72AA4BA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/e6/4b0ddfcf.jpg","comment_is_top":false,"comment_ctime":1614774499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614774499","product_id":100028001,"comment_content":"老师，MinorGC频率多少比较合适呢？","like_count":0},{"had_liked":false,"id":269376,"user_name":"猪大强","can_delete":false,"product_type":"c1","uid":1542577,"ip_address":"","ucode":"2DD393D247798C","user_header":"https://static001.geekbang.org/account/avatar/00/17/89/b1/9f9cfc19.jpg","comment_is_top":false,"comment_ctime":1608628190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608628190","product_id":100028001,"comment_content":"过分的调大堆内存，会增加MinorGC扫描的时间的，在高并发的情况下如何解决呢？","like_count":0},{"had_liked":false,"id":230957,"user_name":"slofish","can_delete":false,"product_type":"c1","uid":2014596,"ip_address":"","ucode":"97A9EC8433DA64","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/84/06654c88.jpg","comment_is_top":false,"comment_ctime":1593530923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593530923","product_id":100028001,"comment_content":"实战项目中真的发生大量gc. 增大内存也不能根本解决问题，应该明确什么原因导致这些对象不被回收，而不是盲目增加，指标不治本","like_count":1},{"had_liked":false,"id":218817,"user_name":"Geek_323c91","can_delete":false,"product_type":"c1","uid":1732683,"ip_address":"","ucode":"AE946A94605456","user_header":"","comment_is_top":false,"comment_ctime":1589880071,"is_pvip":false,"replies":[{"id":"82342","content":"-n表示请求次数  -c表示并发数，-c 1000 -n 100000表示总的请求100000次，且并发用户数为1000。-c 100000 和-n 10000表示总的请求10000次，并发用户数为100000。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1591101330,"ip_address":"","comment_id":218817,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589880071","product_id":100028001,"comment_content":"不知道能不能收到回复,我有个以为,网上查了很多资料 也没得到一个答案,-c 1000 -n 100000 和 -c 100000 和-n 10000的区别是什么 自己压测 怎么调整这2个值","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495585,"discussion_content":"-n表示请求次数  -c表示并发数，-c 1000 -n 100000表示总的请求100000次，且并发用户数为1000。-c 100000 和-n 10000表示总的请求10000次，并发用户数为100000。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591101330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192532,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1584858027,"is_pvip":false,"replies":[{"id":"74169","content":"老年代阈值设置低有好也有坏，一般是在发生concurrent mode failure比较多的情况下会调低，好处就是提前触发CMS GC，保证老年代有足够的空间，坏处则是可能导致发生full gc更为频繁，具体要结合业务场景来分析。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585136713,"ip_address":"","comment_id":192532,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584858027","product_id":100028001,"comment_content":"老师，调整发起老年代堆引起full gc的阈值可以起到优化的效果么？一个老项目把这个阈值设成50%存在的原因会是什么？<br>","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488416,"discussion_content":"老年代阈值设置低有好也有坏，一般是在发生concurrent mode failure比较多的情况下会调低，好处就是提前触发CMS GC，保证老年代有足够的空间，坏处则是可能导致发生full gc更为频繁，具体要结合业务场景来分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585136713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183992,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1583198721,"is_pvip":false,"replies":[{"id":"71235","content":"ps aux只是显示已使用内存占比，而不是被分配的内存大小，我看GCViewer中显示的userage的大小跟ps aux计算出的大小也差不多（在动态变化，有略微差距正常）","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1583219734,"ip_address":"","comment_id":183992,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1583198721","product_id":100028001,"comment_content":"老师，接着昨天提的一个问题，如果我设置了-Xms512m -Xmx512m，但因为机器跑的进程多，实际给这个进程分配的内存只有260M（通过ps aux看的），但我看GCViewer中Memory里面Total heap(usage&#47;alloc. max) 194.1M(38.7%)&#47;502M；Tenured heap(usage&#47;alloc. max) 45.3M(13.3%)&#47;341.5M；Young heap(usage&#47;alloc. max) 156.2M(97.3%)&#47;160.5M。不太懂，谢谢老师。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485844,"discussion_content":"ps aux只是显示已使用内存占比，而不是被分配的内存大小，我看GCViewer中显示的userage的大小跟ps aux计算出的大小也差不多（在动态变化，有略微差距正常）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583219734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180771,"user_name":"啊不多","can_delete":false,"product_type":"c1","uid":1539926,"ip_address":"","ucode":"A38DE3C564B748","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUBia0Aevb2CyMNPvuzTkVvlcoDpdFELFav5Bcic90wxehZibo0VglM7aRZLMo93Ful7v5TFlKfEYyg/132","comment_is_top":false,"comment_ctime":1582384175,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1582384175","product_id":100028001,"comment_content":"老师好，有个面试问题是，创建一个100M的大对象，程序OOM，分析日志查看，此时堆内存大于100M，这是由于什么原因造成的？","like_count":0,"discussions":[{"author":{"id":1026039,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a7/f7/9e5409d0.jpg","nickname":"wanan","note":"","ucode":"C3957AFAC024F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215072,"discussion_content":"没有连续的内存存放100M吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585280481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1539926,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUBia0Aevb2CyMNPvuzTkVvlcoDpdFELFav5Bcic90wxehZibo0VglM7aRZLMo93Ful7v5TFlKfEYyg/132","nickname":"啊不多","note":"","ucode":"A38DE3C564B748","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026039,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a7/f7/9e5409d0.jpg","nickname":"wanan","note":"","ucode":"C3957AFAC024F2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236446,"discussion_content":"是的 应该是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587094967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215072,"ip_address":""},"score":236446,"extra":""}]}]},{"had_liked":false,"id":176948,"user_name":"千年不变，万年如一🎾","can_delete":false,"product_type":"c1","uid":1689301,"ip_address":"","ucode":"ADE7F61C4E2B62","user_header":"https://static001.geekbang.org/account/avatar/00/19/c6/d5/69491af8.jpg","comment_is_top":false,"comment_ctime":1581234175,"is_pvip":false,"replies":[{"id":"69013","content":"问下你的JDK版本是多少，以及JVM设置参数是什么？","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1581506833,"ip_address":"","comment_id":176948,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1581234175","product_id":100028001,"comment_content":"超哥，为什么 jmap -heap 出来的 Eden Space小于 From Space 和 To Space ？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483257,"discussion_content":"问下你的JDK版本是多少，以及JVM设置参数是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581506833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1689301,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c6/d5/69491af8.jpg","nickname":"千年不变，万年如一🎾","note":"","ucode":"ADE7F61C4E2B62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167586,"discussion_content":"jdk1.8.0_111, 简单的启动命令 java vm.HeapOOM\n机器32GB内存，当执行 list.add(new OOMObject()); 后就开始出现这情况，下面是源码\n\npackage vm;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n * 深入理解Java虚拟机-JVM高级特性与最佳实践.pdf\n * 2.4.1 Java堆溢出\n * VM args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError\n * -verbose:gc -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:SurvivorRatio=8\n * @author quan\n *\n */\npublic class HeapOOM {\n static class OOMObject{\n  \n }\n public static void main(String[] args) { \n  System.out.println(&#34;****&#34;);\n  try {\n   System.in.read();\n  } catch (IOException e) {\n   // TODO 自动生成的 catch 块\n   e.printStackTrace();\n  }\n  System.out.println(&#34;bye&#34;);\n  \n  List<OOMObject> list = new ArrayList<OOMObject>();\n  System.out.println(&#34;====&#34;);\n  int i =0;\n  while(i==0){\n   list.add(new OOMObject());\n  }\n }\n\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581512260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140469,"user_name":"殷传宁","can_delete":false,"product_type":"c1","uid":1509189,"ip_address":"","ucode":"A75ED78B979616","user_header":"https://static001.geekbang.org/account/avatar/00/17/07/45/d5cdf38e.jpg","comment_is_top":false,"comment_ctime":1570953913,"is_pvip":false,"replies":[{"id":"55143","content":"使用AB工具运行后会自动打印出这些信息，回顾下加餐篇《加餐 | 推荐几款常用的性能测试工具》","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1571472678,"ip_address":"","comment_id":140469,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570953913","product_id":100028001,"comment_content":"吞吐量那个图是怎么查看的？方法能说一下吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470403,"discussion_content":"使用AB工具运行后会自动打印出这些信息，回顾下加餐篇《加餐 | 推荐几款常用的性能测试工具》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571472678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137639,"user_name":"没有小名的曲儿","can_delete":false,"product_type":"c1","uid":1434711,"ip_address":"","ucode":"0148681C0BAA7A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOn7k48KXia5nvt5VO0x0Fh7SN5MHrbglBAEUVicdRBFpFU3icvNmpjVXDaUVjY0vvic9OrTV5mBRqVQ/132","comment_is_top":false,"comment_ctime":1569810738,"is_pvip":false,"replies":[{"id":"53043","content":"如果内存一直没有释放，我想跟内存设置比例没有关系，可能是引用没有释放，尝试在传完之后手动释放内存试试","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569977601,"ip_address":"","comment_id":137639,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1569810738","product_id":100028001,"comment_content":"超哥好，我们线上的的服务器经常会进行图片处理，内存15G，堆内存设置的-Xms与-Xmx都是10G，经常在进行图片处理时，用top查看java进程，占用率高达79.1%。<br>等传完之后，观察内存一直都是这么多。jmap也看了，是正常回收的。并且各个代free率很高，但是top查看java进程内存一直占用79.1%。<br>是不是因为设置了-Xms为10G，尽管GC了，也不会降低占用整个分配的物理内存呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469187,"discussion_content":"如果内存一直没有释放，我想跟内存设置比例没有关系，可能是引用没有释放，尝试在传完之后手动释放内存试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569977601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369274,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIibTOfGG73q7PH87icicZ3mFh2rt1OicNDSxTHaticNcD5D5AJte5tO7lDoBXlCl5CmfoHlicIbKPuspWQ/132","nickname":"hust_wsh","note":"","ucode":"82080596CA66B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111039,"discussion_content":"top查看到的内存占用率指的是java进程的内存占据整个物理内存的比例，跟JVM里面的内存划分没有关系","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577774632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136523,"user_name":"SDL","can_delete":false,"product_type":"c1","uid":1438734,"ip_address":"","ucode":"AC46F5A8B4B704","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/0e/e200dd34.jpg","comment_is_top":false,"comment_ctime":1569464426,"is_pvip":false,"replies":[{"id":"53065","content":"java -X可以查看部分JVM参数信息","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569980289,"ip_address":"","comment_id":136523,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569464426","product_id":100028001,"comment_content":"老师 为什么我用这个java -XX查看某个参数都没有相关信息输出的？就只有版本号那些信息呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468684,"discussion_content":"java -X可以查看部分JVM参数信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569980289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130616,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1567495232,"is_pvip":false,"replies":[{"id":"49145","content":"是一种简单的压力测试工具，可以网上查询下资料","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567596693,"ip_address":"","comment_id":130616,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567495232","product_id":100028001,"comment_content":"ab压测是什么工具的","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466032,"discussion_content":"是一种简单的压力测试工具，可以网上查询下资料","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567596693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117399,"user_name":"高鑫","can_delete":false,"product_type":"c1","uid":1096052,"ip_address":"","ucode":"752385A515C5A5","user_header":"https://static001.geekbang.org/account/avatar/00/10/b9/74/de434e5f.jpg","comment_is_top":false,"comment_ctime":1564040141,"is_pvip":true,"replies":[{"id":"71184","content":"会的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1583158803,"ip_address":"","comment_id":117399,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1564040141","product_id":100028001,"comment_content":"大大，有个问题请教。如果survivor区不能容纳eden区的活跃对象，那么这些对象会直接晋升到oldgen么？能否详述一下对象晋升的流程🥰","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459948,"discussion_content":"会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583158803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242455,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","nickname":"天天向上","note":"","ucode":"0CCCA6F4DCC480","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119046,"discussion_content":"我觉得不会，这时候应该会Minor GC","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578211872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114579,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1563344268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563344268","product_id":100028001,"comment_content":"可以通过directBuffer创建堆外内存，full gc可以对堆外内存进行回收","like_count":0},{"had_liked":false,"id":114576,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1563343937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563343937","product_id":100028001,"comment_content":"full gc会对堆外内存进行回收","like_count":0},{"had_liked":false,"id":114551,"user_name":"歪曲丶","can_delete":false,"product_type":"c1","uid":1182880,"ip_address":"","ucode":"5D3DDAAFFE2C7D","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/a0/a7a87f96.jpg","comment_is_top":false,"comment_ctime":1563333526,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1563333526","product_id":100028001,"comment_content":"Unsafe DirectByteBuffer都可以直接开辟堆外内存 啥时候回收 可以在full gc的时候回收 难的是堆外的阈值设定 监控堆外内存 jmx好像取不到堆外的大小了吧 之前看到R大在1.7的时候粗略的算下的 有种可能是老年代引用堆外的引用 但是old gc或者full gc迟迟不gc 那堆外就有可能oom","like_count":0},{"had_liked":false,"id":114220,"user_name":"LW","can_delete":false,"product_type":"c1","uid":1325297,"ip_address":"","ucode":"89820332658E98","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg","comment_is_top":false,"comment_ctime":1563254503,"is_pvip":false,"replies":[{"id":"41775","content":"Excel","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563327864,"ip_address":"","comment_id":114220,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563254503","product_id":100028001,"comment_content":"老师的压测结果图形化是用什么工具做的？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458563,"discussion_content":"Excel","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563327864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114139,"user_name":"杨俊","can_delete":false,"product_type":"c1","uid":1158214,"ip_address":"","ucode":"3CAE634618D924","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/46/7e24bad6.jpg","comment_is_top":false,"comment_ctime":1563241943,"is_pvip":true,"replies":[{"id":"41779","content":"对的，可以手动回收掉，如果不手动回收，则会通过FullGC来回收。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563328903,"ip_address":"","comment_id":114139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563241943","product_id":100028001,"comment_content":"印象中本地内存分配堆外内存，c语言用到的内存就是这样，回收是通过GC自动扫描directbytebuffer对象回收","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458529,"discussion_content":"对的，可以手动回收掉，如果不手动回收，则会通过FullGC来回收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563328903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114098,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1563237974,"is_pvip":false,"replies":[{"id":"41785","content":"对的，G1在上一讲中提到了优化JVM的垃圾回收，后面问答题会详细讲解G1收集器。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563329529,"ip_address":"","comment_id":114098,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563237974","product_id":100028001,"comment_content":"堆外内存一般是通过幻像引用的队列通知机制进行手动回收<br><br>另外去，G1如何调优呢？本篇文章的调优策略不适合G1吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458515,"discussion_content":"对的，G1在上一讲中提到了优化JVM的垃圾回收，后面问答题会详细讲解G1收集器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563329529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114072,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1563235949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563235949","product_id":100028001,"comment_content":"设置了supervivor的值以后，吞吐量提升了，而minor gc确增加了，实际业务里面这么平衡 吞吐量和 minor gc的关系","like_count":0}]}