{"id":93711,"title":"17 | 调度（下）：抢占式调度是如何发生的？","content":"<p>上一节，我们讲了主动调度，就是进程运行到一半，因为等待I/O等操作而主动让出CPU，然后就进入了我们的“进程调度第一定律”。所有进程的调用最终都会走__schedule函数。那这个定律在这一节还是要继续起作用。</p><h2>抢占式调度</h2><p>上一节我们讲的主动调度是第一种方式，第二种方式，就是抢占式调度。什么情况下会发生抢占呢？</p><p>最常见的现象就是<strong>一个进程执行时间太长了，是时候切换到另一个进程了</strong>。那怎么衡量一个进程的运行时间呢？在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统，时间又过去一个时钟周期，这是个很好的方式，可以查看是否是需要抢占的时间点。</p><p>时钟中断处理函数会调用scheduler_tick()，它的代码如下：</p><pre><code>void scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq-&gt;curr;\n......\n\tcurr-&gt;sched_class-&gt;task_tick(rq, curr, 0);\n\tcpu_load_update_active(rq);\n\tcalc_global_load_tick(rq);\n......\n}\n</code></pre><p>这个函数先取出当前CPU的运行队列，然后得到这个队列上当前正在运行中的进程的task_struct，然后调用这个task_struct的调度类的task_tick函数，顾名思义这个函数就是来处理时钟事件的。</p><p>如果当前运行的进程是普通进程，调度类为fair_sched_class，调用的处理时钟的函数为task_tick_fair。我们来看一下它的实现。</p><pre><code>static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued)\n{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &amp;curr-&gt;se;\n\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tentity_tick(cfs_rq, se, queued);\n\t}\n......\n}\n</code></pre><!-- [[[read_end]]] --><p>根据当前进程的task_struct，找到对应的调度实体sched_entity和cfs_rq队列，调用entity_tick。</p><pre><code>static void\nentity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued)\n{\n\tupdate_curr(cfs_rq);\n\tupdate_load_avg(curr, UPDATE_TG);\n\tupdate_cfs_shares(curr);\n.....\n\tif (cfs_rq-&gt;nr_running &gt; 1)\n\t\tcheck_preempt_tick(cfs_rq, curr);\n}\n</code></pre><p>在entity_tick里面，我们又见到了熟悉的update_curr。它会更新当前进程的vruntime，然后调用check_preempt_tick。顾名思义就是，检查是否是时候被抢占了。</p><pre><code>static void\ncheck_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)\n{\n\tunsigned long ideal_runtime, delta_exec;\n\tstruct sched_entity *se;\n\ts64 delta;\n\n\n\tideal_runtime = sched_slice(cfs_rq, curr);\n\tdelta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;\n\tif (delta_exec &gt; ideal_runtime) {\n\t\tresched_curr(rq_of(cfs_rq));\n\t\treturn;\n\t}\n......\n\tse = __pick_first_entity(cfs_rq);\n\tdelta = curr-&gt;vruntime - se-&gt;vruntime;\n\tif (delta &lt; 0)\n\t\treturn;\n\tif (delta &gt; ideal_runtime)\n\t\tresched_curr(rq_of(cfs_rq));\n}\n</code></pre><p>check_preempt_tick先是调用sched_slice函数计算出的ideal_runtime。ideal_runtime是一个调度周期中，该进程运行的实际时间。</p><p>sum_exec_runtime指进程总共执行的实际时间，prev_sum_exec_runtime指上次该进程被调度时已经占用的实际时间。每次在调度一个新的进程时都会把它的se-&gt;prev_sum_exec_runtime = se-&gt;sum_exec_runtime，所以sum_exec_runtime-prev_sum_exec_runtime就是这次调度占用实际时间。如果这个时间大于ideal_runtime，则应该被抢占了。</p><p>除了这个条件之外，还会通过__pick_first_entity取出红黑树中最小的进程。如果当前进程的vruntime大于红黑树中最小的进程的vruntime，且差值大于ideal_runtime，也应该被抢占了。</p><p>当发现当前进程应该被抢占，不能直接把它踢下来，而是把它标记为应该被抢占。为什么呢？因为进程调度第一定律呀，一定要等待正在运行的进程调用__schedule才行啊，所以这里只能先标记一下。</p><p>标记一个进程应该被抢占，都是调用resched_curr，它会调用set_tsk_need_resched，标记进程应该被抢占，但是此时此刻，并不真的抢占，而是打上一个标签TIF_NEED_RESCHED。</p><pre><code>static inline void set_tsk_need_resched(struct task_struct *tsk)\n{\n\tset_tsk_thread_flag(tsk,TIF_NEED_RESCHED);\n}\n</code></pre><p>另外一个可能抢占的场景是<strong>当一个进程被唤醒的时候</strong>。</p><p>我们前面说过，当一个进程在等待一个I/O的时候，会主动放弃CPU。但是当I/O到来的时候，进程往往会被唤醒。这个时候是一个时机。当被唤醒的进程优先级高于CPU上的当前进程，就会触发抢占。try_to_wake_up()调用ttwu_queue将这个唤醒的任务添加到队列当中。ttwu_queue再调用ttwu_do_activate激活这个任务。ttwu_do_activate调用ttwu_do_wakeup。这里面调用了check_preempt_curr检查是否应该发生抢占。如果应该发生抢占，也不是直接踢走当前进程，而是将当前进程标记为应该被抢占。</p><pre><code>static void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t\t   struct rq_flags *rf)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp-&gt;state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n</code></pre><p>到这里，你会发现，抢占问题只做完了一半。就是标识当前运行中的进程应该被抢占了，但是真正的抢占动作并没有发生。</p><h2>抢占的时机</h2><p>真正的抢占还需要时机，也就是需要那么一个时刻，让正在运行中的进程有机会调用一下__schedule。</p><p>你可以想象，不可能某个进程代码运行着，突然要去调用__schedule，代码里面不可能这么写，所以一定要规划几个时机，这个时机分为用户态和内核态。</p><h3>用户态的抢占时机</h3><p>对于用户态的进程来讲，从系统调用中返回的那个时刻，是一个被抢占的时机。</p><p>前面讲系统调用的时候，64位的系统调用的链路位do_syscall_64-&gt;syscall_return_slowpath-&gt;prepare_exit_to_usermode-&gt;exit_to_usermode_loop，当时我们还没关注exit_to_usermode_loop这个函数，现在我们来看一下。</p><pre><code>static void exit_to_usermode_loop(struct pt_regs *regs, u32 cached_flags)\n{\n\twhile (true) {\n\t\t/* We have work to do. */\n\t\tlocal_irq_enable();\n\n\n\t\tif (cached_flags &amp; _TIF_NEED_RESCHED)\n\t\t\tschedule();\n......\n\t}\n}\n</code></pre><p>现在我们看到在exit_to_usermode_loop函数中，上面打的标记起了作用，如果被打了_TIF_NEED_RESCHED，调用schedule进行调度，调用的过程和上一节解析的一样，会选择一个进程让出CPU，做上下文切换。</p><p>对于用户态的进程来讲，从中断中返回的那个时刻，也是一个被抢占的时机。</p><p>在arch/x86/entry/entry_64.S中有中断的处理过程。又是一段汇编语言代码，你重点领会它的意思就行，不要纠结每一行都看懂。</p><pre><code>common_interrupt:\n        ASM_CLAC\n        addq    $-0x80, (%rsp) \n        interrupt do_IRQ\nret_from_intr:\n        popq    %rsp\n        testb   $3, CS(%rsp)\n        jz      retint_kernel\n/* Interrupt came from user space */\nGLOBAL(retint_user)\n        mov     %rsp,%rdi\n        call    prepare_exit_to_usermode\n        TRACE_IRQS_IRETQ\n        SWAPGS\n        jmp     restore_regs_and_iret\n/* Returning to kernel space */\nretint_kernel:\n#ifdef CONFIG_PREEMPT\n        bt      $9, EFLAGS(%rsp)  \n        jnc     1f\n0:      cmpl    $0, PER_CPU_VAR(__preempt_count)\n        jnz     1f\n        call    preempt_schedule_irq\n        jmp     0b\n</code></pre><p>中断处理调用的是do_IRQ函数，中断完毕后分为两种情况，一个是返回用户态，一个是返回内核态。这个通过注释也能看出来。</p><p>咱们先来看返回用户态这一部分，先不管返回内核态的那部分代码，retint_user会调用prepare_exit_to_usermode，最终调用exit_to_usermode_loop，和上面的逻辑一样，发现有标记则调用schedule()。</p><h3>内核态的抢占时机</h3><p>用户态的抢占时机讲完了，接下来我们看内核态的抢占时机。</p><p>对内核态的执行中，被抢占的时机一般发生在preempt_enable()中。</p><p>在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用preempt_disable()关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。</p><p>就像下面代码中展示的一样，preempt_enable()会调用preempt_count_dec_and_test()，判断preempt_count和TIF_NEED_RESCHED是否可以被抢占。如果可以，就调用preempt_schedule-&gt;preempt_schedule_common-&gt;__schedule进行调度。还是满足进程调度第一定律的。</p><pre><code>#define preempt_enable() \\\ndo { \\\n\tif (unlikely(preempt_count_dec_and_test())) \\\n\t\t__preempt_schedule(); \\\n} while (0)\n\n\n#define preempt_count_dec_and_test() \\\n\t({ preempt_count_sub(1); should_resched(0); })\n\n\nstatic __always_inline bool should_resched(int preempt_offset)\n{\n\treturn unlikely(preempt_count() == preempt_offset &amp;&amp;\n\t\t\ttif_need_resched());\n}\n\n\n#define tif_need_resched() test_thread_flag(TIF_NEED_RESCHED)\n\n\nstatic void __sched notrace preempt_schedule_common(void)\n{\n\tdo {\n......\n\t\t__schedule(true);\n......\n\t} while (need_resched())\n</code></pre><p>在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这个时候也是一个执行抢占的时机，现在我们再来上面中断返回的代码中返回内核的那部分代码，调用的是preempt_schedule_irq。</p><pre><code>asmlinkage __visible void __sched preempt_schedule_irq(void)\n{\n......\n\tdo {\n\t\tpreempt_disable();\n\t\tlocal_irq_enable();\n\t\t__schedule(true);\n\t\tlocal_irq_disable();\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n......\n}\n</code></pre><p>preempt_schedule_irq调用__schedule进行调度。还是满足进程调度第一定律的。</p><h2>总结时刻</h2><p>好了，抢占式调度就讲到这里了。我这里画了一张脑图，将整个进程的调度体系都放在里面。</p><p>这个脑图里面第一条就是总结了进程调度第一定律的核心函数__schedule的执行过程，这是上一节讲的，因为要切换的东西比较多，需要你详细了解每一部分是如何切换的。</p><p>第二条总结了标记为可抢占的场景，第三条是所有的抢占发生的时机，这里是真正验证了进程调度第一定律的。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/7f/93588d71abd7f007397979f0ba7def7f.png?wh=2719*1259\" alt=\"\"></p><h2>课堂练习</h2><p>通过对于内核中进程调度的分析，我们知道，时间对于调度是很重要的，你知道Linux内核是如何管理和度量时间的吗？</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，<span class=\"orange\">反复研读</span>。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","comments":[{"had_liked":false,"id":93477,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1557478206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"194831006526","product_id":100024701,"comment_content":"- 抢占式调度<br>- 两种情况: 执行太久, 需切换到另一进程; 另一个高优先级进程被唤醒<br>    - 执行太久: 由时钟中断触发检测, 中断处理调用 scheduler_tick <br>        - 取当前进程  task_struct-&gt;task_tick_fair()-&gt;取 sched_entity cfs_rq 调用 entity_tick()<br>        - entity_tick() 调用 update_curr 更新当前进程 vruntime, 调用 check_preempt_tick 检测是否需要被抢占<br>        - check_preempt_tick 中计算 ideal_runtime(一个调度周期中应该运行的实际时间), 若进程本次调度运行时间 &gt; ideal_runtime, 则应该被抢占<br>        - 要被抢占, 则调用 resched_curr, 设置 TIF_NEED_RESCHED, 将其标记为应被抢占进程(因为要等待当前进程运行 `__schedule`)<br>    - 另一个高优先级进程被唤醒: 当 I&#47;O 完成, 进程被唤醒, 若优先级高于当前进程则触发抢占<br>        - try_to_wake_up()-&gt;ttwu_queue() 将唤醒任务加入队列 调用 ttwu_do_activate 激活任务<br>        - 调用 tt_do_wakeup()-&gt;check_preempt_curr() 检查是否应该抢占, 若需抢占则标记<br>- 抢占时机: 让进程调用 `__schedule`, 分为用户态和内核态<br>    - 用户态进程<br>        - 时机-1: 从系统调用中返回, 返回过程中会调用 exit_to_usermode_loop, 检查 `_TIF_NEED_RESCHED`, 若打了标记, 则调用 schedule()<br>        - 时机-2: 从中断中返回, 中断返回分为返回用户态和内核态(汇编代码: arch&#47;x86&#47;entry&#47;entry_64.S), 返回用户态过程中会调用 exit_to_usermode_loop()-&gt;shcedule()<br>    - 内核态进程<br>        - 时机-1: 发生在 preempt_enable() 中, 内核态进程有的操作不能被中断, 会调用 preempt_disable(), 在开启时(调用 preempt_enable) 时是一个抢占时机, 会调用 preempt_count_dec_and_test(), 检测 preempt_count 和标记, 若可抢占则最终调用 `__schedule`<br>        - 时机-2: 发生在中断返回, 也会调用 `__schedule`<br>","like_count":46},{"had_liked":false,"id":120687,"user_name":"garlic","can_delete":false,"product_type":"c1","uid":1019579,"ip_address":"","ucode":"FEB147EDB5774E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg","comment_is_top":false,"comment_ctime":1564974668,"is_pvip":true,"replies":[{"id":"46361","content":"赞，很牛","user_name":"作者回复","comment_id":120687,"uid":"1001590","ip_address":"","utype":1,"ctime":1566297089,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":1,"score":"117529091660","product_id":100024701,"comment_content":"linux内核依靠硬件定时电路特定时钟频率，tick rate，触发时钟中断，通过中断处理，实现系统时间更新， 定时器设置，延时处理， 学习笔记 https:&#47;&#47;garlicspace.com&#47;2019&#47;08&#47;04&#47;linux如何管理和度量时间&#47;","like_count":28,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461435,"discussion_content":"赞，很牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566297089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99430,"user_name":"兴文","can_delete":false,"product_type":"c1","uid":1197541,"ip_address":"","ucode":"A9F7F7E51E86B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/e5/163228b7.jpg","comment_is_top":false,"comment_ctime":1559212381,"is_pvip":false,"replies":[{"id":"49227","content":"tick会中断他的","user_name":"作者回复","comment_id":99430,"uid":"1001590","ip_address":"","utype":1,"ctime":1567604603,"user_name_real":"刘超@网易云"}],"discussion_count":3,"race_medal":0,"score":"91753525597","product_id":100024701,"comment_content":"如果用户进程一直在用户态执行，没有发生系统调用和中断，就不会触发scheduler操作，那这个进程是不是一直占有CPU啊？","like_count":22,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452106,"discussion_content":"tick会中断他的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567604603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1000076,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/8c/373d4027.jpg","nickname":"龍蝦","note":"","ucode":"BE1D500833F070","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543948,"discussion_content":"老师，这个问题好像没有解释清楚。tick中断它，指的是上面提到的中断处理程序返回用户态调用 scheduler() ?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641366452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":452106,"ip_address":""},"score":543948,"extra":""},{"author":{"id":2749565,"avatar":"https://static001.geekbang.org/account/avatar/00/29/f4/7d/9601abeb.jpg","nickname":"Shuyi Zhou","note":"","ucode":"0443B65D92868D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000076,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/8c/373d4027.jpg","nickname":"龍蝦","note":"","ucode":"BE1D500833F070","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":564351,"discussion_content":"时钟中断scheduler_tick()，这个会一直发生","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650218102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":543948,"ip_address":""},"score":564351,"extra":""}]}]},{"had_liked":false,"id":221164,"user_name":"多选参数","can_delete":false,"product_type":"c1","uid":1248326,"ip_address":"","ucode":"B2294D80AB075F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","comment_is_top":false,"comment_ctime":1590419406,"is_pvip":false,"replies":[{"id":"83065","content":"对的","user_name":"作者回复","comment_id":221164,"uid":"1001590","ip_address":"","utype":1,"ctime":1591784956,"user_name_real":"刘超@网易云"}],"discussion_count":7,"race_medal":0,"score":"74604863438","product_id":100024701,"comment_content":"针对大部分留言说假如没有系统调用等，那岂不是会死循环这类问题。简单来说就是如果发生了中断，那么当前进程肯定会陷入内核态。所以可能会有标记步骤和真正的抢占步骤。详细点来说，当一个进程正在 CPU 上运行，如果发生时钟中断，那么需要去处理这个时钟中断，也就是会调用相应的中断处理函数，而相应的中断处理函数需要在内核态下执行，所以当前进程会陷入内核态，然后保存用户态的情况，然后判断是否需要进行标记。然后中断函数处理完之后，会返回用户态，这个时候又会发生抢占。","like_count":18,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496363,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591784956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2604257,"avatar":"https://static001.geekbang.org/account/avatar/00/27/bc/e1/7a39d6be.jpg","nickname":"超超超给力","note":"","ucode":"05FAA4361FAF63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552142,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645322748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272730,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/9a/786b1ed8.jpg","nickname":"果粒橙","note":"","ucode":"000B15E28C68B6","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398960,"discussion_content":"解答了我的疑惑，感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632880626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517457,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkzrezV2dOBAgickt9DLzabz3dNFYyDEVXENMQ5ibrWhFbFqXIOia3ZaR21pozvB7UfoxJx4Ar688sA/132","nickname":"开心","note":"","ucode":"C8E08E8724C7CE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379303,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623820507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547763,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/f3/3f6dd32b.jpg","nickname":"叶紫真","note":"","ucode":"9CD7567FDB7F1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376103,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621956165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1262271,"avatar":"https://static001.geekbang.org/account/avatar/00/13/42/bf/8d366dd4.jpg","nickname":"波斯码","note":"","ucode":"F8607AC2B1A37A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375310,"discussion_content":"请问为什么要先标记，中断返回时一次性处理不香吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621570784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1547763,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/f3/3f6dd32b.jpg","nickname":"叶紫真","note":"","ucode":"9CD7567FDB7F1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1262271,"avatar":"https://static001.geekbang.org/account/avatar/00/13/42/bf/8d366dd4.jpg","nickname":"波斯码","note":"","ucode":"F8607AC2B1A37A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376105,"discussion_content":"小哥，代码要分层，任务要分清楚，一个是任务的发布者，另一个是任务的消费者（执行者），写代码要考虑很多东西，反正你说的那种方式一定是很差劲的","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1621956256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375310,"ip_address":""},"score":376105,"extra":""}]}]},{"had_liked":false,"id":108935,"user_name":"卫江","can_delete":false,"product_type":"c1","uid":1101226,"ip_address":"","ucode":"DE2F7A6916F1A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/aa/33d48789.jpg","comment_is_top":false,"comment_ctime":1561940019,"is_pvip":false,"replies":[{"id":"39606","content":"后面有专门的节讲中断，到时候回来看，就对上了。中断的处理是在内核里面的，用不到进程的用户栈。当cpu收到中断的时候，就会停止当然指令的运行，去调用内核中的中断处理函数。应用再怎么死循环，内核里面说把他拿下来，不就拿下来了吗。","user_name":"作者回复","comment_id":108935,"uid":"1001590","ip_address":"","utype":1,"ctime":1562031550,"user_name_real":"刘超@网易云"}],"discussion_count":3,"race_medal":0,"score":"65986449459","product_id":100024701,"comment_content":"老师，想问一下，中断处理程序到底是由谁调用的，而且一切函数调用肯定需要栈，那中断在哪个栈上面执行，如果在一个单核的计算机上面，有一个进程处于用户态死循环，没有调用系统调用，如果这个时候发生了时间中断，内核是怎么处理的，怎么打断当前的进程，从而可能影响调度？","like_count":16,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456173,"discussion_content":"后面有专门的节讲中断，到时候回来看，就对上了。中断的处理是在内核里面的，用不到进程的用户栈。当cpu收到中断的时候，就会停止当然指令的运行，去调用内核中的中断处理函数。应用再怎么死循环，内核里面说把他拿下来，不就拿下来了吗。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562031550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1067570,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/32/23db38ab.jpg","nickname":"Sunny","note":"","ucode":"FE57B69A9CF91D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379497,"discussion_content":"刚想到这个问题，就找到答案了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623929966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/6c/0c2a26c7.jpg","nickname":"clip","note":"","ucode":"D0E142605A5BD5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1067570,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/32/23db38ab.jpg","nickname":"Sunny","note":"","ucode":"FE57B69A9CF91D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548389,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643175442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379497,"ip_address":""},"score":548389,"extra":""}]}]},{"had_liked":false,"id":105322,"user_name":"zhouzg","can_delete":false,"product_type":"c1","uid":1060614,"ip_address":"","ucode":"40C8A4E115A5AE","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/06/aabd37b4.jpg","comment_is_top":false,"comment_ctime":1560969106,"is_pvip":false,"replies":[{"id":"49007","content":"牛","user_name":"作者回复","comment_id":105322,"uid":"1001590","ip_address":"","utype":1,"ctime":1567579492,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"48805609362","product_id":100024701,"comment_content":"看《计算器是怎样跑起来的》书中有Z80的电路图，里面有介绍时钟发生器，它会把电流信号切割成单位，这样就可以度量和管理时钟了吧？","like_count":12,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454633,"discussion_content":"牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567579492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92105,"user_name":"焰火","can_delete":false,"product_type":"c1","uid":1244606,"ip_address":"","ucode":"D3353B386DE3B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg","comment_is_top":false,"comment_ctime":1557189107,"is_pvip":true,"replies":[{"id":"49463","content":"不能把调度系统想象成一个进程，他是管家，不是干活的。不存在他和别人一起竞争的事情，他想把谁从cpu上拿下来，就能拿下来，他只要一改指令指针寄存器，就能拿下来","user_name":"作者回复","comment_id":92105,"uid":"1001590","ip_address":"","utype":1,"ctime":1567672129,"user_name_real":"刘超@网易云"}],"discussion_count":3,"race_medal":0,"score":"31621960179","product_id":100024701,"comment_content":"进程调度第一定律总结的太棒了。   <br><br>另外有个问题想问下老师：我把整个调度系统想成一个进程，这个调度进程来实现task调度？ 如果是这样的，Linux如果跑在单CPU上，多进程是怎么调度的呢？","like_count":8,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449149,"discussion_content":"不能把调度系统想象成一个进程，他是管家，不是干活的。不存在他和别人一起竞争的事情，他想把谁从cpu上拿下来，就能拿下来，他只要一改指令指针寄存器，就能拿下来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567672129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004183,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/97/4593cda8.jpg","nickname":"MC","note":"","ucode":"AA0035C9C43516","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159590,"discussion_content":"关键在于计算机中断机制的存在。操作系统可以注册中断处理程序，当硬件时钟触发中断时，CPU会去执行操作系统注册的特定程序。可以理解为操作系统通过这种方式取回CPU资源一会会用来调度程序。不知道我的理解是否有误？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580711259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131300,"avatar":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","nickname":"zixuan","note":"","ucode":"C72920DD05B074","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587870,"discussion_content":"是的，相当于有外部干预来强制保障","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663327839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206979,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1586967612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23061804092","product_id":100024701,"comment_content":"刘老师：<br>您在文中提到：<br>检查是否是时候被抢占的函数调用：check_preempt_tick，其中说到：<br>“ideal_runtime 是一个调度周期中，该进程运行的实际时间。“<br>从字面意思看似乎名实不符。我查到的一些资料多解释为“typical time slice&quot;或者“target effort”。<br>我也粗略浏览了一下sched_slice方法的实现，似乎是通过rq.load,entity.load等参数计算出来一个预期的工作时长。<br>您看是不是应该改成：“ideal_runtime 是一个调度周期中，该进程预期的运行分配时间”为宜？","like_count":6},{"had_liked":false,"id":137504,"user_name":"JT","can_delete":false,"product_type":"c1","uid":1489942,"ip_address":"","ucode":"36D71949F34FD9","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/16/5ce59343.jpg","comment_is_top":false,"comment_ctime":1569755804,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18749624988","product_id":100024701,"comment_content":"老师你讲得太好了，清楚易懂，我自己看了《Linux内核设计与实现》，然后接着看《深入Linux内核》，前前后后尝试看了几遍，但发现怎么也啃不下。看你的课，然后总结，有了总体思路后，再自己阅读内核代码，收获真的是太大了","like_count":4,"discussions":[{"author":{"id":1299347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/93/c3fb8566.jpg","nickname":"ProcessIsTheKey","note":"","ucode":"BE02EFD75F7D98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375933,"discussion_content":"佩服你们这些能看懂的，呜呜呜","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1621872730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2423785,"avatar":"https://static001.geekbang.org/account/avatar/00/24/fb/e9/5445da3e.jpg","nickname":"hello，world","note":"","ucode":"0106B9567CD1C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352030,"discussion_content":"老师的课程提纲挈领的总结比较多，其他那些书细枝末节实现代码比较多","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614579742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273217,"discussion_content":"感觉老师这门课细节上不太多，但是有点就是能让我们串起来，特别是看过其他书籍之后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590419769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91998,"user_name":"二星球","can_delete":false,"product_type":"c1","uid":1111552,"ip_address":"","ucode":"89EC5FEB98E7CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/00/2a248fd8.jpg","comment_is_top":false,"comment_ctime":1557151246,"is_pvip":false,"replies":[{"id":"49467","content":"有的，看后面实践环节","user_name":"作者回复","comment_id":91998,"uid":"1001590","ip_address":"","utype":1,"ctime":1567672193,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"18737020430","product_id":100024701,"comment_content":"老师您好，我喜欢边调试边阅读代码，代码是死的但是跑起来是活的变的，linux内核代码有没有好的调试方式，或者添加打印日志的方式；另外时钟中断是怎么触发的呢，我记得cpu里面没有时钟这个物理设备的，应该有类似单片机晶振这个东西去无限循环执行指令的，这个也不会有时钟中断呀","like_count":5,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449106,"discussion_content":"有的，看后面实践环节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567672193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226523,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592128007,"is_pvip":false,"replies":[{"id":"83453","content":"融会贯通","user_name":"作者回复","comment_id":226523,"uid":"1001590","ip_address":"","utype":1,"ctime":1592185755,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"14477029895","product_id":100024701,"comment_content":"“进程调度第一定律”，以及在内核中进程和线程统一用task_struct表示，让我想起了一个设计模式：组合模式（Composite Design Pattern）","like_count":4,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498275,"discussion_content":"融会贯通","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592185755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224651,"user_name":"liu-dan","can_delete":false,"product_type":"c1","uid":1238826,"ip_address":"","ucode":"8CBDF8A2D9E2F9","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/2a/7d9ecf15.jpg","comment_is_top":false,"comment_ctime":1591497368,"is_pvip":false,"replies":[{"id":"83000","content":"一句更容易理解胜过千言万语，谢谢","user_name":"作者回复","comment_id":224651,"uid":"1001590","ip_address":"","utype":1,"ctime":1591752639,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10181431960","product_id":100024701,"comment_content":"看了好几遍，感觉慢慢能串联起来，虽然不如经典的kernel书籍严谨和全面，但是更容易理解，讲的确实很不错，很受用，感谢老师！","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497554,"discussion_content":"一句更容易理解胜过千言万语，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591752639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91817,"user_name":"MARK","can_delete":false,"product_type":"c1","uid":1126900,"ip_address":"","ucode":"9F429C9C5FEE6A","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/f4/467cf5d7.jpg","comment_is_top":false,"comment_ctime":1557114041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10147048633","product_id":100024701,"comment_content":"Linux内核通过时钟中断管理和度量时间.<br>Linux在初始化时会使用一个init_IRQ()函数设定定时周期(IRQ:Interrupt Request)，time_init()中调用setup_irq()设置时间中断向量irq 0；中断服务程序是timer_interrupt()，会调用另一个函数do_timer_interrupt(),do_timer_interrupt还会调用do_timer更新系统时间。do_timer中的工作包括，让全局变量jiffies增加1，并且调用update_process_times来更新进程的时间片以及修改进程的动态优先级...<br>搜索的一点信息，期待老师的详细讲解^_^","like_count":2},{"had_liked":false,"id":241879,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1597485008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892452304","product_id":100024701,"comment_content":"抢占式调度<br>在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统，时间又过去一个时钟周期，这是个很好的方式，可以查看是否是需要抢占的时间点<br>一、时钟中断处理函数会调用 scheduler_tick()<br>---这个函数取出当前 CPU 的运行队列，然后得到这个队列上当前正在运行中的进程的 task_struct，然后调用这个 task_struct 的调度类的 task_tick 函数；<br>---如果为普通进程，调度类为 fair_sched_class，调用的处理时钟的函数为 task_tick_fair<br>---根据他当前task_struct，找到对应的调度实体 sched_entity 和 cfs_rq 队列，调用 entity_tick<br>---entity_tick 里面，更新当前进程的 vruntime，然后调用 check_preempt_tick，检查是否是时候被抢占了<br>---抢占的两个条件：<br>1、所以 sum_exec_runtime-prev_sum_exec_runtime 就是这次调度占用实际时间。如果这个时间大于 ideal_runtime，则应该被抢占了；<br>2、还会通过 __pick_first_entity 取出红黑树中最小的进程。如果当前进程的 vruntime 大于红黑树中最小的进程的 vruntime，且差值大于 ideal_runtime，也应该被抢占了；<br>---现当前进程应该被抢占，不能直接把它踢下来，而是把它标记为应该被抢占，而是打上一个标签 TIF_NEED_RESCHED<br>二、一个可能抢占的场景是当一个进程被唤醒的时候<br>---但是当 I&#47;O 到来的时候，进程往往会被唤醒。这个时候是一个时机。当被唤醒的进程优先级高于 CPU 上的当前进程，就会触发抢占<br>---try_to_wake_up() 调用 ttwu_queue 将这个唤醒的任务添加到队列当中。ttwu_queue 再调用 ttwu_do_activate 激活这个任务。ttwu_do_activate 调用 ttwu_do_wakeup。这里面调用了 check_preempt_curr 检查是否应该发生抢占。如果应该发生抢占，也不是直接踢走当前进程，而是将当前进程标记为应该被抢占<br><br><br>抢占的时机：<br>用户态的抢占时机：<br>---从系统调用中返回的那个时刻，是一个被抢占的时机；<br>do_syscall_64-&gt;syscall_return_slowpath-&gt;prepare_exit_to_usermode-&gt;exit_to_usermode_loop<br> if (cached_flags &amp; _TIF_NEED_RESCHED)      schedule();<br>---从中断中返回的那个时刻，也是一个被抢占的时机<br>中断处理调用的是 do_IRQ 函数，中断完毕后分为两种情况，一个是返回用户态，一个是返回内核态,retint_user 会调用 prepare_exit_to_usermode，最终调用 exit_to_usermode_loop,之后就和系统调用一样<br>内核态的抢占时机：<br>---在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用 preempt_disable() 关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会；<br>eempt_enable() 会调用 preempt_count_dec_and_test()，判断 preempt_count 和 TIF_NEED_RESCHED 是否可以被抢占。如果可以，就调用 preempt_schedule-&gt;preempt_schedule_common-&gt;__schedule 进行调度<br>---在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。","like_count":1},{"had_liked":false,"id":191958,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1584805856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879773152","product_id":100024701,"comment_content":"标记-清理。jvm回收内存的方法之一。看来都是相通的","like_count":1},{"had_liked":false,"id":160134,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1575876826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870844122","product_id":100024701,"comment_content":"操作系统内核，最简化之后，其实就是一个大循环，通过各种中断，尤其是时钟的中断来推动内核的运行，直到收到退出信号为止。<br><br>今天对于“抢占式调度”，有了进一步的理解：“抢占”仍然是内核帮各个进程抢，而不是想获取CPU时间的进程自己抢的，想获取CPU时间的进程，只能采取把自己的进程优先级调高的方式，让自己排队靠前而已。说白了，内核只是用了一种更合理的方式，来更好的安排CPU运行时间，防止饥饿和霸占CPU资源。而这一切都是在内核里完成的，用户进程想获取CPU和让渡CPU都是要靠内核态。","like_count":2},{"had_liked":false,"id":94908,"user_name":"wwj","can_delete":false,"product_type":"c1","uid":1053787,"ip_address":"","ucode":"B98AE5F5D85A87","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzvaL724GwtzZ5mcldUnlicicSlI8BXL9icRZbUOB10qjRMlmog7UTvwxSBHXagnPGGR1BYdjWcGGSg/132","comment_is_top":false,"comment_ctime":1557919933,"is_pvip":false,"replies":[{"id":"34100","content":"物理内存的管理程序也是程序，也分代码部分和数据部分，代码部分当然在内核代码段里面了，系统启动的时候就加载了。数据部分大部分分配在直接映射区，也会分配页表，页表在哪里呢？页表的根在代码段的那个区域里面。","user_name":"作者回复","comment_id":94908,"uid":"1001590","ip_address":"","utype":1,"ctime":1558068041,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5852887229","product_id":100024701,"comment_content":"物理内存统一管理 本身也是程序 他的内存如何管理","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450256,"discussion_content":"物理内存的管理程序也是程序，也分代码部分和数据部分，代码部分当然在内核代码段里面了，系统启动的时候就加载了。数据部分大部分分配在直接映射区，也会分配页表，页表在哪里呢？页表的根在代码段的那个区域里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558068041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336637,"user_name":"白雲城主","can_delete":false,"product_type":"c1","uid":2929240,"ip_address":"","ucode":"5A339657AC7A25","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b2/58/e842dbd9.jpg","comment_is_top":false,"comment_ctime":1646269951,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646269951","product_id":100024701,"comment_content":"老师，咨询一个问题，比如我的TICK 配置的250，也就是每 4ms 调用一次 task_tick_fair，双核CPU 创建了4个用户进程一直在跑，此时应该无论 min_granularity_ns 是多少 ，每个进程至少running 4ms以上，但是用trace-cmd抓的有低于4ms 的情况，这是如何发生的 ？","like_count":0},{"had_liked":false,"id":336541,"user_name":"白雲城主","can_delete":false,"product_type":"c1","uid":2929240,"ip_address":"","ucode":"5A339657AC7A25","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b2/58/e842dbd9.jpg","comment_is_top":false,"comment_ctime":1646206824,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646206824","product_id":100024701,"comment_content":"双核CPU ，最小时间片为1.5ms，调度周期为12ms，起了6个进程，照理说应该每个进程至少运行1.5ms 才被抢占，还不考虑tick time 的情况，但是抓的 schedule trace  event 看到的每个进程大概只运行了1.5us就被抢占了，这个是啥问题额 ？<br><br>sysctl_sched<br>  .sysctl_sched_latency                    : 12.000000<br>  .sysctl_sched_min_granularity            : 1.500000","like_count":0},{"had_liked":false,"id":333077,"user_name":"凉凉","can_delete":false,"product_type":"c1","uid":1325256,"ip_address":"","ucode":"FCCF976E41EF71","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/c8/972a5024.jpg","comment_is_top":false,"comment_ctime":1644049108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644049108","product_id":100024701,"comment_content":"老师 我想问一下 在有多个cpu 的情况下或者是多核的情况，进程运行过程中cpu被抢占了 这时候能不能把这个进程调度到其他 cpu 或者 cpu 其他核运行","like_count":0},{"had_liked":false,"id":288942,"user_name":"林啸乾","can_delete":false,"product_type":"c1","uid":1994745,"ip_address":"","ucode":"74C5980337D205","user_header":"https://static001.geekbang.org/account/avatar/00/1e/6f/f9/6b5410c5.jpg","comment_is_top":false,"comment_ctime":1618795222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618795222","product_id":100024701,"comment_content":"老师，做io处理完成后打标记的操作是由哪里做的<br>","like_count":0},{"had_liked":false,"id":277156,"user_name":"Xuan Enzo","can_delete":false,"product_type":"c1","uid":1806265,"ip_address":"","ucode":"B45983FB42CDB7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8f/b9/ea858151.jpg","comment_is_top":false,"comment_ctime":1612278075,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1612278075","product_id":100024701,"comment_content":"刘老师您好，有个问题请教一下：线程到了内核也是task，内核不做区分，一样切换。是不是说线程切换和进程切换流程都是一样的。如果新切换进来的线程和旧的线程同属于一个进程，那就是进程间的线程切换；如果新的线程和旧的线程不属于一个进程，那就是进程切换？","like_count":0,"discussions":[{"author":{"id":1547763,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/f3/3f6dd32b.jpg","nickname":"叶紫真","note":"","ucode":"9CD7567FDB7F1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376109,"discussion_content":"1.不管是线程还是进程，在内核中都是一个task；\n2.你这么理解就对了，你所说的进程是一个主线程；\n3.你把进程会运行的这种事彻底抛弃，能运行的永远是线程，而进程是一个资源，进程里面有一个可以运行的主线程，而进程中的其他线程是主线程创建的；\n4.永远要记住，进程是一个资源，不是一个可以在CPU上面跑的东西；","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621956624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246467,"user_name":"禾田日成","can_delete":false,"product_type":"c1","uid":1450722,"ip_address":"","ucode":"4BBC18778FDF88","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/e2/4ca2d6d1.jpg","comment_is_top":false,"comment_ctime":1599363139,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599363139","product_id":100024701,"comment_content":"您好，想问一下，按照文章讲的，抢占式调度只有在上述抢占时机才能进行调度的话，那么如果一个程序一直在死循环的话，那么就不会进行调度了吗","like_count":0,"discussions":[{"author":{"id":1262271,"avatar":"https://static001.geekbang.org/account/avatar/00/13/42/bf/8d366dd4.jpg","nickname":"波斯码","note":"","ucode":"F8607AC2B1A37A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375311,"discussion_content":"时钟中断会把他打断的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621571089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240519,"user_name":"Jemmy","can_delete":false,"product_type":"c1","uid":1007330,"ip_address":"","ucode":"A979F4A5210225","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/e2/1fad3052.jpg","comment_is_top":false,"comment_ctime":1596957933,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596957933","product_id":100024701,"comment_content":"有一个困惑： 比如 一个 task 在 cfs rq，它没有运行，现在要 try_to_wake_up 它，为什么还会调用 p-&gt;sched_class-&gt;enqueue_task(rq, p, flags); 去做 enqueue；它不是已经在了吗，没有运行时难道它不在 cfs rq 吗？","like_count":0},{"had_liked":false,"id":229154,"user_name":"李圣悦","can_delete":false,"product_type":"c1","uid":1638427,"ip_address":"","ucode":"C1786C98824E50","user_header":"https://static001.geekbang.org/account/avatar/00/19/00/1b/eee13196.jpg","comment_is_top":false,"comment_ctime":1592910254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592910254","product_id":100024701,"comment_content":"老师，后面有进程cpu切换的原理不？调度实体怎么挂到合适的分支上？","like_count":0},{"had_liked":false,"id":226098,"user_name":"羽","can_delete":false,"product_type":"c1","uid":1316367,"ip_address":"","ucode":"7E329FECE728E4","user_header":"https://static001.geekbang.org/account/avatar/00/14/16/0f/ebdcc4b7.jpg","comment_is_top":false,"comment_ctime":1591950933,"is_pvip":false,"replies":[{"id":"83461","content":"对于操作系统看来，每个核是一个cpu","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1592186010,"ip_address":"","comment_id":226098,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1591950933","product_id":100024701,"comment_content":"超哥 请教一个问题  对于单核看着上面的调度是灭有问题的 但是多核似乎有问题啊  这个多核cpu如何同步这个线程是否有调度呢？ 如果多核使用同一个调度队列他们是如何同步的呢","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498103,"discussion_content":"对于操作系统看来，每个核是一个cpu","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592186010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180460,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/2c/33ba4d12.jpg","nickname":"山中无老虎 😪","note":"","ucode":"594247C3A976DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361555,"discussion_content":"https://blog.csdn.net/z1026544682/article/details/105714542 这个可以看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616686925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316367,"avatar":"https://static001.geekbang.org/account/avatar/00/14/16/0f/ebdcc4b7.jpg","nickname":"羽","note":"","ucode":"7E329FECE728E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283111,"discussion_content":" 超哥  多个cpu是通过什么进行同步的呢 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592186443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1500593,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicibkDiceIZd7R3y57L7WIVFpVWU6ebp40G3ZNLFtlUWb7d4O5BpyxKQSd81FXo4rQFbQoUWu35jJg/132","nickname":"zhuxuxu","note":"","ucode":"DCD8E5D7F6F8A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316367,"avatar":"https://static001.geekbang.org/account/avatar/00/14/16/0f/ebdcc4b7.jpg","nickname":"羽","note":"","ucode":"7E329FECE728E4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334244,"discussion_content":"一般多核任务调度算法有全局队列调度和局部队列调度。前者是指操作系统维护一个全局的任务等待队列，当系统中有一个CPU核心空闲时，操作系统就从全局任务等待队列中选取就绪任务开始在此核心上执行。这种方法的优点是CPU核心利用率较高。后者是指操作系统为每个CPU内核维护一个局部的任务等待队列，当系统中有一个CPU内核空闲时，便从该核心的任务等待队列中选取恰当的任务执行，这种方法的优点是任务基本上无需在多个CPU核心间切换，有利于提高CPU核心局部Cache命中率。目前多数多核CPU操作系统采用的是基于全局队列的任务调度算法。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607778436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283111,"ip_address":""},"score":334244,"extra":""}]}]},{"had_liked":false,"id":200597,"user_name":"honnkyou","can_delete":false,"product_type":"c1","uid":1026608,"ip_address":"","ucode":"FD5EC4120EE803","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/30/acc91f01.jpg","comment_is_top":false,"comment_ctime":1585622246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585622246","product_id":100024701,"comment_content":"优先级高的进程被唤醒时是把正在运行的进程标记为&quot;可以被抢占&quot;是吗？<br>想问一下是谁标记的呢？调度器吗？","like_count":0},{"had_liked":false,"id":200238,"user_name":"honnkyou","can_delete":false,"product_type":"c1","uid":1026608,"ip_address":"","ucode":"FD5EC4120EE803","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/30/acc91f01.jpg","comment_is_top":false,"comment_ctime":1585561803,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585561803","product_id":100024701,"comment_content":"老师，ideal_runtime 是指这段时间片内应该运行的时间吗？delta_exec 是实际的运行时间。","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387384,"discussion_content":"是的，ideal_runtime是理论上应该运行的时间/ 运行时间阈值；delta_exec大于等于理论值之后，就需要进行进程调度了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628146322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193333,"user_name":"Geek_b8928e","can_delete":false,"product_type":"c1","uid":1926597,"ip_address":"","ucode":"96E4ABE3F2F145","user_header":"","comment_is_top":false,"comment_ctime":1584890122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584890122","product_id":100024701,"comment_content":"Linux中的两种调度：主动调度和抢占式调度","like_count":0},{"had_liked":false,"id":192643,"user_name":"OOK","can_delete":false,"product_type":"c1","uid":1342712,"ip_address":"","ucode":"BE6220D4E922E9","user_header":"https://static001.geekbang.org/account/avatar/00/14/7c/f8/1183f1ac.jpg","comment_is_top":false,"comment_ctime":1584865075,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584865075","product_id":100024701,"comment_content":"如果分配给一个进程的时间片用完了，从而调度其他程序，这个也是非抢占式调度吧，抢占式调度是进程正在使用分配给他的时间片，如果这时候被中断，这是抢占式调度吧。主动调度和被动调度对应，非抢占式调度和抢占式调度对应吧。有点疑惑？","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387385,"discussion_content":"调度就两种哦，一种等IO的主动让贤；一种是时间到了被迫下线。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628146402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186872,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1583942077,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583942077","product_id":100024701,"comment_content":"Golang 里面的抢占式调度也有类似之处，之前遇到一个问题，单线程情况下，主线程里面的一个 for 循环，里面什么也不做，开始认为调度系统会切换到另外的协程继续执行，现在理解了，由于 for 循环里面什么都没做，即没有系统调用、I&#47;O 中断之类，那么这个线程就无法被抢占。<br>了解了系统底层的实现原理，才能解释一些看起来诡异的现象，感谢老师！","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387386,"discussion_content":"如果有优先级更高的线程还是会被抢占的，你看到没有被抢占，可能已经被抢占N次，只不过你没有感知而已，因为线程有抢占回来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628146516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182258,"user_name":"皮皮侠","can_delete":false,"product_type":"c1","uid":1258402,"ip_address":"","ucode":"04205990C1DE1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","comment_is_top":false,"comment_ctime":1582737400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582737400","product_id":100024701,"comment_content":"问下老师，从2.6版本linux时钟从低粒度切换到高粒度，对整个内核代码影响是不是很大？当我们在嵌入式系统中修剪linux内核时，对这样的改变需要注意哪些问题呢？","like_count":0},{"had_liked":false,"id":160872,"user_name":"Geek_mgk","can_delete":false,"product_type":"c1","uid":1756673,"ip_address":"","ucode":"61F5CB403F4D39","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ce/01/0b862dd3.jpg","comment_is_top":false,"comment_ctime":1576051333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576051333","product_id":100024701,"comment_content":"进程切换调度是不是意味着多个进程不能在多cpu上并行执行，只能单个进程的多线程并行执行？？还是说，线程作为调度的最小单位，使得不同进程的不同线程并行执行达到进程并行的目的？个人理解还不够到位。","like_count":0},{"had_liked":false,"id":155309,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1574677002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574677002","product_id":100024701,"comment_content":"认识到：抢占，也是有原因、有时机限制的！","like_count":0},{"had_liked":false,"id":150341,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1573520984,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573520984","product_id":100024701,"comment_content":"看这个文章是不是先看一下 linux 相关的书籍啊，感觉大脑没有一个大概的 linux得运行过程图谱","like_count":0},{"had_liked":false,"id":137116,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1569628262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569628262","product_id":100024701,"comment_content":"个人观点:cfs 不应该讲一讲如何计算时间片么(进程应该运行的时间)","like_count":0},{"had_liked":false,"id":120560,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1564929241,"is_pvip":false,"replies":[{"id":"46362","content":"谢谢夸奖，不敢不敢","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566297116,"ip_address":"","comment_id":120560,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564929241","product_id":100024701,"comment_content":"又读了好几遍 终于看懂了调度，手里的资料lkd&#47;uld都是讲2.6内核的，也在对着4.4的代码看，老师很厉害，感觉这个系列可以叫ulk 4.4 vertion了……<br>简单来说，调度就是解决什么时间调度，选哪个任务调度，怎么调度，换句话就是说CPU什么时候跑哪个任务，后两个问题对应老师导图的第一条，第一个对应老师导图的后两条，先得标记一下resched,然后在合适的时候进行调度","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461384,"discussion_content":"谢谢夸奖，不敢不敢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566297116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116374,"user_name":"小虾米","can_delete":false,"product_type":"c1","uid":1005528,"ip_address":"","ucode":"F543987A7FAB20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/d8/425e1b0a.jpg","comment_is_top":false,"comment_ctime":1563844706,"is_pvip":false,"replies":[{"id":"46428","content":"会，弄个高优先级的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566300014,"ip_address":"","comment_id":116374,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1563844706","product_id":100024701,"comment_content":"请教一下，写一个死循环，循环里什么都不做，这个进程会被调度出去吗","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459510,"discussion_content":"会，弄个高优先级的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566300014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1450722,"avatar":"https://static001.geekbang.org/account/avatar/00/16/22/e2/4ca2d6d1.jpg","nickname":"禾田日成","note":"","ucode":"4BBC18778FDF88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303729,"discussion_content":"咦，想问一下，这种抢占式调度不是一定要处于抢占时机才可以完成的吗，死循环应该没有处于那些时机中吧\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599363321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1450722,"avatar":"https://static001.geekbang.org/account/avatar/00/16/22/e2/4ca2d6d1.jpg","nickname":"禾田日成","note":"","ucode":"4BBC18778FDF88","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313215,"discussion_content":"别的评论里有答案拉，时间中断会中断它呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603004345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303729,"ip_address":""},"score":313215,"extra":""}]}]},{"had_liked":false,"id":112525,"user_name":"CN....","can_delete":false,"product_type":"c1","uid":1228489,"ip_address":"","ucode":"2C265A33D4C642","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/c9/505bfb99.jpg","comment_is_top":false,"comment_ctime":1562751606,"is_pvip":false,"replies":[{"id":"46716","content":"会呀","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566386134,"ip_address":"","comment_id":112525,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562751606","product_id":100024701,"comment_content":"老师好,如果一个进程开启特别多线程,线程执行内容都是死循环 循环体中执行sleep(3秒),如果内存足够大,会随着线程数增加,导致cpu使用率增加吗","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457779,"discussion_content":"会呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566386134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108458,"user_name":"Amark","can_delete":false,"product_type":"c1","uid":1121326,"ip_address":"","ucode":"E5F48633654002","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/2e/93812642.jpg","comment_is_top":false,"comment_ctime":1561777102,"is_pvip":false,"replies":[{"id":"48828","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567499979,"ip_address":"","comment_id":108458,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561777102","product_id":100024701,"comment_content":"老师 发生调度就两种情况吗，主动让出，与被动调度?","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455987,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567499979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104857,"user_name":"杨领well","can_delete":false,"product_type":"c1","uid":1145650,"ip_address":"","ucode":"3974A03855168C","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/32/60089a62.jpg","comment_is_top":false,"comment_ctime":1560857007,"is_pvip":false,"replies":[{"id":"49021","content":"会有单独的一节讲中断","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567580064,"ip_address":"","comment_id":104857,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560857007","product_id":100024701,"comment_content":"老师能否讲解一下中断的实现，虽然这里有提到，但是对于中断的实现过程还是有点懵","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454455,"discussion_content":"会有单独的一节讲中断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567580064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97441,"user_name":"如是","can_delete":false,"product_type":"c1","uid":1133500,"ip_address":"","ucode":"78F7D2402483C4","user_header":"https://static001.geekbang.org/account/avatar/00/11/4b/bc/86a9ac70.jpg","comment_is_top":false,"comment_ctime":1558669792,"is_pvip":false,"replies":[{"id":"34854","content":"会用cpu的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1558680677,"ip_address":"","comment_id":97441,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1558669792","product_id":100024701,"comment_content":"老师中断是怎么处理的，难道不会用到cpu吗？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451282,"discussion_content":"会用cpu的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558680677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177797,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/c5/6d38f3e3.jpg","nickname":"黑微狗‮‮","note":"","ucode":"D44505E7E97BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186551,"discussion_content":"那cpu已经在处理某个进程了 还怎么处理中断呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582691087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95117,"user_name":"周平","can_delete":false,"product_type":"c1","uid":1047936,"ip_address":"","ucode":"CA1869B139A4F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/80/52763d62.jpg","comment_is_top":false,"comment_ctime":1557970346,"is_pvip":false,"replies":[{"id":"49344","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567650469,"ip_address":"","comment_id":95117,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557970346","product_id":100024701,"comment_content":"管理的时间或者说度量的时间是否就是系统时钟，就像MCU中的时钟源一样呢？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450335,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567650469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92001,"user_name":"tiankonghewo","can_delete":false,"product_type":"c1","uid":1476427,"ip_address":"","ucode":"7A55A9C17DD9DF","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/4b/16ea3997.jpg","comment_is_top":false,"comment_ctime":1557151666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557151666","product_id":100024701,"comment_content":"学习了","like_count":0},{"had_liked":false,"id":91711,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1557098512,"is_pvip":false,"replies":[{"id":"32850","content":"这样夸奖","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1557154457,"ip_address":"","comment_id":91711,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557098512","product_id":100024701,"comment_content":"task_struct中有指向调度类的指针，第15课调度（上）还有疑问不知道这个指针有什么用，在这一节找到了答案。<br><br>老师讲的比那些内核书上讲的好太多了。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448998,"discussion_content":"这样夸奖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557154457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}