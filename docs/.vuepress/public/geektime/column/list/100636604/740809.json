{"id":740809,"title":"第 9 章 结构体","content":"\n<blockquote>\n<p>很久以前，当牧羊人想要了解两个羊群是否相似时，会挨个对它们进行比对。</p>\n<p style=\"text-align: right\">——John C. Baez，James Dolan，“Categorification”</p>\n</blockquote>\n<p>&nbsp;</p>\n<p>Rust 中的结构体（struct/structure）类似于 C 和 C++ 中的 <code>struct</code> 类型、Python 中的类和 JavaScript 中的对象。结构体会将多个不同类型的值组合成一个单一的值，以便你能把它们作为一个单元来处理。给定一个结构体，你可以读取和修改它的各个组件。结构体也可以具有关联的方法，以对其组件进行操作。</p>\n<p>Rust 有 3 种结构体类型：<strong>具名字段型结构体</strong>、<strong>元组型结构体</strong>和<strong>单元型结构体</strong>。这 3 种结构体在引用组件的方式上有所不同：具名字段型结构体会为每个组件命名；元组型结构体会按组件出现的顺序标识它们；单元型结构体则根本没有组件。单元型结构体虽然不常见，但它们比你想象的更有用。</p>\n<p>本章将详细解释每种类型并展示它们在内存中的样子；介绍如何向它们添加方法、如何定义适用于不同组件类型的泛型结构体类型，以及如何让 Rust 为你的结构体生成常见的便捷特型的实现。</p>\n<h2 id=\"nav_point_153\">9.1　具名字段型结构体</h2>\n<p>具名字段型结构体的定义如下所示：</p>\n<pre class=\"code-rows\"><code>/// 由8位灰度像素组成的矩形\nstruct GrayscaleMap {\n    pixels: Vec&lt;u8&gt;,\n    size: (usize, usize)\n}</code></pre>\n<p>它声明了一个 <code>GrayscaleMap</code> 类型，其中包含两个给定类型的字段，分别名为 <code>pixels</code> 和 <code>size</code>。Rust 中的约定是，所有类型（包括结构体）的名称都将每个单词的第一个字母大写（如 <code>GrayscaleMap</code>），这称为<strong>大驼峰格式</strong>（CamelCase 或 PascalCase）。字段和方法是小写的，单词之间用下划线分隔，这称为<strong>蛇形格式</strong>（snake_case）。</p><!-- [[[read_end]]] -->\n<p>你可以使用<strong>结构体表达式</strong>构造出此类型的值，如下所示：</p>\n<pre class=\"code-rows\"><code>let width = 1024;\nlet height = 576;\nlet image = GrayscaleMap {\n    pixels: vec![0; width * height],\n    size: (width, height)\n};</code></pre>\n<p>结构体表达式以类型名称（<code>GrayscaleMap</code>）开头，后跟一对花括号，其中列出了每个字段的名称和值。还有用来从与字段同名的局部变量或参数填充字段的简写形式：</p>\n<pre class=\"code-rows\"><code>fn new_map(size: (usize, usize), pixels: Vec&lt;u8&gt;) -&gt; GrayscaleMap {\n    assert_eq!(pixels.len(), size.0 * size.1);\n    GrayscaleMap { pixels, size }\n}</code></pre>\n<p>结构体表达式 <code>GrayscaleMap { pixels, size }</code> 是 <code>GrayscaleMap { pixels: pixels, size: size }</code> 的简写形式。你可以对某些字段使用 <code>key: value</code> 语法，而对同一结构体表达式中的其他字段使用简写语法。</p>\n<p>要访问结构体的字段，请使用我们熟悉的 <code>.</code> 运算符：</p>\n<pre class=\"code-rows\"><code>assert_eq!(image.size, (1024, 576));\nassert_eq!(image.pixels.len(), 1024 * 576);</code></pre>\n<p>与所有其他语法项一样，结构体默认情况下是私有的，仅在声明它们的模块及其子模块中可见。你可以通过在结构体的定义前加上 <code>pub</code> 来使结构体在其模块外部可见。结构体中的每个字段默认情况下也是私有的：</p>\n<pre class=\"code-rows\"><code>/// 由8位灰度像素组成的矩形\npub struct GrayscaleMap {\n    pub pixels: Vec&lt;u8&gt;,\n    pub size: (usize, usize)\n}</code></pre>\n<p>即使一个结构体声明为 <code>pub</code>，它的字段也可以是私有的：</p>\n<pre class=\"code-rows\"><code>/// 由8位灰度像素组成的矩形\npub struct GrayscaleMap {\n    pixels: Vec&lt;u8&gt;,\n    size: (usize, usize)\n}</code></pre>\n<p>其他模块可以使用此结构体及其任何公共的关联函数，但不能按名称访问私有字段或使用结构体表达式来创建新的 <code>GrayscaleMap</code> 值。也就是说，要创建结构体型的值，就需要结构体的所有字段都可见。这就是为什么你不能编写结构体表达式来创建新的 <code>String</code> 或 <code>Vec</code>。这些标准类型都是结构体，但它们的所有字段都是私有的。如果想创建一个值，就必须使用公共的类型关联函数，比如 <code>Vec::new()</code>。</p>\n<p>创建具名字段结构体的值时，可以使用另一个相同类型的结构体为省略的那些字段提供值。在结构体表达式中，如果具名字段后面跟着 <code>.. EXPR</code>，则任何未提及的字段都会从 <code>EXPR</code>（必须是相同结构体类型的另一个值）中获取它们的值。假设我们有一个代表游戏中怪物的结构体：</p>\n<pre class=\"code-rows\"><code>// 在这个游戏中，怪物是一些扫帚。你会看到：\nstruct Broom {\n    name: String,\n    height: u32,\n    health: u32,\n    position: (f32, f32, f32),\n    intent: BroomIntent\n}\n\n/// `Broom`可以支持的两种用途\n#[derive(Copy, Clone)]\nenum BroomIntent { FetchWater, DumpWater }</code></pre>\n<p>对程序员来说，最好的童话故事是 <em>The Sorcerer</em>'<em>s Apprentice</em>（《<strong>魔法师的学徒</strong>》）：一个新手魔法师对一把扫帚施了魔法，让它为自己工作，但工作完成后不知道如何让它停下来。于是，他用斧头将扫帚砍成了两半，结果一把扫帚变成了两把，虽然每把扫帚的大小只有原始扫帚的一半，但仍然具有和原始扫帚一样的“工作热情”。</p>\n<pre class=\"code-rows\"><code>// 按值接收输入的Broom（扫帚），并获得所有权\nfn chop(b: Broom) -&gt; (Broom, Broom) {\n    // 主要从`b`初始化`broom1`，只修改`height`。由于`String`\n    // 不是`Copy`类型，因此`broom1`获得了`b`中`name`的所有权\n    let mut broom1 = Broom { height: b.height / 2, .. b };\n\n    // 主要从`broom1`初始化`broom2`。由于`String`不是`Copy`类型，\n    // 因此我们显式克隆了`name`\n    let mut broom2 = Broom { name: broom1.name.clone(), .. broom1 };\n\n    // 为每一半扫帚分别起一个名字\n    broom1.name.push_str(\" I\");\n    broom2.name.push_str(\" II\");\n\n    (broom1, broom2)\n}</code></pre>\n<p>有了这个定义，我们就可以制作一把扫帚，把它一分为二，然后看看会得到什么：</p>\n<pre class=\"code-rows\"><code>let hokey = Broom {\n    name: \"Hokey\".to_string(),\n    height: 60,\n    health: 100,\n    position: (100.0, 200.0, 0.0),\n    intent: BroomIntent::FetchWater\n};\n\nlet (hokey1, hokey2) = chop(hokey);\nassert_eq!(hokey1.name, \"Hokey I\");\nassert_eq!(hokey1.height, 30);\nassert_eq!(hokey1.health, 100);\n\nassert_eq!(hokey2.name, \"Hokey II\");\nassert_eq!(hokey2.height, 30);\nassert_eq!(hokey2.health, 100);</code></pre>\n<p>新的扫帚 <code>hokey1</code> 和 <code>hokey2</code> 获得了修改后的名字，长度只有原来的一半，但生命值都跟原始扫帚一样。</p>\n<h2 id=\"nav_point_154\">9.2　元组型结构体</h2>\n<p>第二种结构体类型称为<strong>元组型结构体</strong>，因为它类似于元组：</p>\n<pre class=\"code-rows\"><code>struct Bounds(usize, usize);</code></pre>\n<p>构造此类型的值与构造元组非常相似，只是必须包含结构体名称：</p>\n<pre class=\"code-rows\"><code>let image_bounds = Bounds(1024, 768);</code></pre>\n<p>元组型结构体保存的值称为<strong>元素</strong>，就像元组的值一样。你可以像访问元组一样访问它们：</p>\n<pre class=\"code-rows\"><code>assert_eq!(image_bounds.0 * image_bounds.1, 786432);</code></pre>\n<p>元组型结构体的单个元素可以是公共的，也可以不是：</p>\n<pre class=\"code-rows\"><code>pub struct Bounds(pub usize, pub usize);</code></pre>\n<p>表达式 <code>Bounds(1024, 768)</code> 看起来像一个函数调用，实际上它确实是，即定义这种类型时也隐式定义了一个函数：</p>\n<pre class=\"code-rows\"><code>fn Bounds(elem0: usize, elem1: usize) -&gt; Bounds { ... }</code></pre>\n<p>在最基本的层面上，具名字段型结构体和元组型结构体非常相似。选择使用哪一个需要考虑易读性、无歧义性和简洁性。如果你喜欢用 <code>.</code> 运算符来获取值的各个组件，那么用名称来标识字段就能为读者提供更多信息，并且更容易防范拼写错误。如果你通常使用模式匹配来查找这些元素，那么元组型结构体会更好用。</p>\n<p>元组型结构体适用于创造<strong>新类型</strong>（newtype），即建立一个只包含单组件的结构体，以获得更严格的类型检查。如果你正在使用纯 ASCII 文本，那么可以像下面这样定义一个新类型：</p>\n<pre class=\"code-rows\"><code>struct Ascii(Vec&lt;u8&gt;);</code></pre>\n<p>将此类型用于 ASCII 字符串比简单地传递 <code>Vec&lt;u8&gt;</code> 缓冲区并在注释中解释它们的内容要好得多。在将其他类型的字节缓冲区传给需要 ASCII 文本的函数时，这种新类型能帮 Rust 捕获错误。我们会在第 22 章中给出一个使用新类型进行高效类型转换的例子。</p>\n<h2 id=\"nav_point_155\">9.3　单元型结构体</h2>\n<p>第三种结构体有点儿晦涩难懂，因为它声明了一个根本没有元素的结构体类型：</p>\n<pre class=\"code-rows\"><code>struct Onesuch;</code></pre>\n<p>这种类型的值不占用内存，很像单元类型 <code>()</code>。Rust 既不会在内存中实际存储单元型结构体的值，也不会生成代码来对它们进行操作，因为仅通过值的类型它就能知道关于值的所有信息。但从逻辑上讲，空结构体是一种可以像其他任何类型一样有值的类型。或者更准确地说，空结构体是一种只有一个值的类型：</p>\n<pre class=\"code-rows\"><code>let o = Onesuch;</code></pre>\n<p>在阅读 6.10 节中有关 <code>..</code> 范围运算符的内容时，你已经遇到过单元型结构体。像 <code>3..5</code> 这样的表达式是结构体值 <code>Range { start: 3, end: 5 }</code> 的简写形式，而表达式 <code>..</code>（一个省略两个端点的范围）是单元型结构体值 <code>RangeFull</code> 的简写形式。</p>\n<p>单元型结构体在处理特型时也很有用，第 11 章会对此进行描述。</p>\n<h2 id=\"nav_point_156\">9.4　结构体布局</h2>\n<p>在内存中，具名字段型结构体和元组型结构体是一样的：值（可能是混合类型）的集合以特定方式在内存中布局。例如，在本章前面我们定义了下面这个结构体：</p>\n<pre class=\"code-rows\"><code>struct GrayscaleMap {\n    pixels: Vec&lt;u8&gt;,\n    size: (usize, usize)\n}</code></pre>\n<p><code>GrayscaleMap</code> 值在内存中的布局如图 9-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00848.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-1：内存中的 <code>GrayscaleMap</code> 结构体</strong></p>\n<p>与 C 和 C++ 不同，Rust 没有具体承诺它将如何在内存中对结构体的字段或元素进行排序，图 9-1 仅展示了一种可能的安排。然而，Rust 确实承诺会将字段的值直接存储在结构体本身的内存块中。JavaScript、Python 和 Java 会将 <code>pixels</code> 值和 <code>size</code> 值分别放在它们自己的分配在堆上的块中，并让 <code>GrayscaleMap</code> 的字段指向它们，而 Rust 会将 <code>pixels</code> 值和 <code>size</code> 值直接嵌入 <code>GrayscaleMap</code> 值中。只有由 <code>pixels</code> 向量拥有的在堆上分配的缓冲区才会留在它自己的块中。</p>\n<p>你可以使用 <code>#[repr(C)]</code> 属性要求 Rust 以兼容 C 和 C++ 的方式对结构体进行布局，第 23 章会对此进行详细介绍。</p>\n<h2 id=\"nav_point_157\">9.5　用 <code>impl</code> 定义方法</h2>\n<p>在本书中，我们一直在对各种值调用方法，比如使用 <code>v.push(e)</code> 将元素推送到向量上、使用 <code>v.len()</code> 获取向量的长度、使用 <code>r.expect(\"msg\")</code> 检查 <code>Result</code> 值是否有错误，等等。你也可以在自己的结构体类型上定义方法。Rust 方法不会像 C++ 或 Java 中的方法那样出现在结构体定义中，而是会出现在单独的 <code>impl</code> 块中。</p>\n<p><code>impl</code> 块只是 <code>fn</code> 定义的集合，每个定义都会成为块顶部命名的结构体类型上的一个方法。例如，这里我们定义了一个公共的 <code>Queue</code> 结构体，然后为它定义了 <code>push</code> 和 <code>pop</code> 这两个公共方法：</p>\n<pre class=\"code-rows\"><code>/// 字符的先入先出队列\npub struct Queue {\n    older: Vec&lt;char&gt;,   // 较旧的元素，最早进来的在后面\n    younger: Vec&lt;char&gt;  // 较新的元素，最后进来的在后面\n}\n\nimpl Queue {\n    /// 把字符推入队列的最后\n    pub fn push(&amp;mut self, c: char) {\n        self.younger.push(c);\n    }\n\n    /// 从队列的前面弹出一个字符。如果确实有要弹出的字符，\n    /// 就返回`Some(c)`；如果队列为空，则返回`None`\n    pub fn pop(&amp;mut self) -&gt; Option&lt;char&gt; {\n        if self.older.is_empty() {\n            if self.younger.is_empty() {\n                return None;\n            }\n\n            // 将younger中的元素移到older中，并按照所承诺的顺序排列它们\n            use std::mem::swap;\n            swap(&amp;mut self.older, &amp;mut self.younger);\n            self.older.reverse();\n        }\n\n        // 现在older能保证有值了。Vec的pop方法已经\n        // 返回一个Option，所以可以放心使用了\n        self.older.pop()\n    }\n}</code></pre>\n<p>在 <code>impl</code> 块中定义的函数称为<strong>关联函数</strong>，因为它们是与特定类型相关联的。与关联函数相对的是<strong>自由函数</strong>，它是未定义在 <code>impl</code> 块中的语法项。</p>\n<p>Rust 会将调用关联函数的结构体值作为第一个参数传给方法，该参数必须具有特殊名称 <code>self</code>。由于 <code>self</code> 的类型显然就是在 <code>impl</code> 块顶部命名的类型或对该类型的引用，因此 Rust 允许你省略类型，并以 <code>self</code>、<code>&amp;self</code> 或 <code>&amp;mut self</code> 作为 <code>self: Queue</code>、<code>self: &amp;Queue</code> 或 <code>self: &amp;mut Queue</code> 的简写形式。如果你愿意，也可以使用完整形式，但如前所述，几乎所有 Rust 代码都会使用简写形式。</p>\n<p>在我们的示例中，<code>push</code> 方法和 <code>pop</code> 方法会通过 <code>self.older</code> 和 <code>self.younger</code> 来引用 <code>Queue</code> 的字段。在 C++ 和 Java 中，<code>\"this\"</code> 对象的成员可以在方法主体中直接可见，不用加 <code>this.</code> 限定符，而 Rust 方法中则必须显式使用 <code>self</code> 来引用调用此方法的结构体值，这类似于 Python 方法中使用 <code>self</code> 以及 JavaScript 方法中使用 <code>this</code> 的方式。</p>\n<p>由于 <code>push</code> 和 <code>pop</code> 需要修改 <code>Queue</code>，因此它们都接受 <code>&amp;mut self</code> 参数。然而，当调用一个方法时，你不需要自己借用可变引用，常规的方法调用语法就已经隐式处理了这一点。因此，有了这些定义，你就可以像下面这样使用 <code>Queue</code> 了：</p>\n<pre class=\"code-rows\"><code>let mut q = Queue { older: Vec::new(), younger: Vec::new() };\n\nq.push('0');\nq.push('1');\nassert_eq!(q.pop(), Some('0'));\n\nq.push('∞');\nassert_eq!(q.pop(), Some('1'));\nassert_eq!(q.pop(), Some('∞'));\nassert_eq!(q.pop(), None);</code></pre>\n<p>只需编写 <code>q.push(...)</code> 就可以借入对 <code>q</code> 的可变引用，就好像你写的是 <code>(&amp;mut q).push(...)</code> 一样，因为这是 <code>push</code> 方法的 <code>self</code> 参数所要求的。</p>\n<p>如果一个方法不需要修改 <code>self</code>，那么可以将其定义为接受共享引用：</p>\n<pre class=\"code-rows\"><code>impl Queue {\n    pub fn is_empty(&amp;self) -&gt; bool {\n        self.older.is_empty() &amp;&amp; self.younger.is_empty()\n    }\n}</code></pre>\n<p>同样，方法调用表达式知道要借用哪种引用：</p>\n<pre class=\"code-rows\"><code>assert!(q.is_empty());\nq.push('⊙');\nassert!(!q.is_empty());</code></pre>\n<p>或者，如果一个方法想要获取 <code>self</code> 的所有权，就可以通过值来获取 <code>self</code>：</p>\n<pre class=\"code-rows\"><code>impl Queue {\n    pub fn split(self) -&gt; (Vec&lt;char&gt;, Vec&lt;char&gt;) {\n        (self.older, self.younger)\n    }\n}</code></pre>\n<p>调用这个 <code>split</code> 方法看上去和调用其他方法是一样的：</p>\n<pre class=\"code-rows\"><code>let mut q = Queue { older: Vec::new(), younger: Vec::new() };\n\nq.push('P');\nq.push('D');\nassert_eq!(q.pop(), Some('P'));\nq.push('X');\n\nlet (older, younger) = q.split();\n\n// q现在是未初始化状态\nassert_eq!(older, vec!['D']);\nassert_eq!(younger, vec!['X']);</code></pre>\n<p>但请注意，由于 <code>split</code> 通过值获取 <code>self</code>，因此这会将 <code>Queue</code> 从 <code>q</code> 中<strong>移动</strong>出去，使 <code>q</code> 变成未初始化状态。由于 <code>split</code> 的 <code>self</code> 现在拥有此队列，因此它能够将这些单独的向量移出队列并返回给调用者。</p>\n<p>有时，像这样通过值或引用获取 <code>self</code> 还是不够的，因此 Rust 还允许通过智能指针类型传递 <code>self</code>。</p>\n<h3 id=\"nav_point_158\">9.5.1　以 <code>Box</code>、<code>Rc</code> 或 <code>Arc</code> 形式传入 <code>self</code></h3>\n<p>方法的 <code>self</code> 参数也可以是 <code>Box&lt;Self&gt;</code> 类型、<code>Rc&lt;Self&gt;</code> 类型或 <code>Arc&lt;Self&gt;</code> 类型。这种方法只能在给定的指针类型值上调用。调用该方法会将指针的所有权传给它。</p>\n<p>你通常不需要这么做。如果一个方法期望通过引用接受 <code>self</code>，那它在任何指针类型上调用时都可以正常工作：</p>\n<pre class=\"code-rows\"><code>let mut bq = Box::new(Queue::new());\n\n// `Queue::push`需要一个`&amp;mut Queue`，但`bq`是一个`Box&lt;Queue&gt;`\n// 这没问题：Rust在调用期间从`Box`借入了`&amp;mut Queue`\nbq.push('■');</code></pre>\n<p>对于方法调用和字段访问，Rust 会自动从 <code>Box</code>、<code>Rc</code>、<code>Arc</code> 等指针类型中借入引用，因此 <code>&amp;self</code> 和 <code>&amp;mut self</code> 几乎总是（偶尔也会用一下 <code>self</code>）方法签名里的正确选择。</p>\n<p>但是如果某些方法确实需要获取指向 <code>Self</code> 的指针的所有权，并且其调用者手头恰好有这样一个指针，那么 Rust 也允许你将它作为方法的 <code>self</code> 参数传入。为此，你必须明确写出 <code>self</code> 的类型，就好像它是普通参数一样。</p>\n<pre class=\"code-rows\"><code>impl Node {\n    fn append_to(self: Rc&lt;Self&gt;, parent: &amp;mut Node) {\n        parent.children.push(self);\n    }\n}</code></pre>\n<h3 id=\"nav_point_159\">9.5.2　类型关联函数</h3>\n<p>给定类型的 <code>impl</code> 块还可以定义根本不以 <code>self</code> 为参数的函数。这些函数仍然是关联函数，因为它们在 <code>impl</code> 块中，但它们不是方法，因为它们不接受 <code>self</code> 参数。为了将它们与方法区分开来，我们称其为<strong>类型关联函数</strong>。</p>\n<p>它们通常用于提供构造函数，如下所示：</p>\n<pre class=\"code-rows\"><code>impl Queue {\n    pub fn new() -&gt; Queue {\n        Queue { older: Vec::new(), younger: Vec::new() }\n    }\n}</code></pre>\n<p>要使用此函数，需要写成 <code>Queue::new</code>，即类型名称 + 双冒号 + 函数名称。现在我们的示例代码简洁一点儿了：</p>\n<pre class=\"code-rows\"><code>let mut q = Queue::new();\n\nq.push('*');\n...</code></pre>\n<p>在 Rust 中，构造函数通常按惯例命名为 <code>new</code>，我们已经见过 <code>Vec::new</code>、<code>Box::new</code>、<code>HashMap::new</code> 等。但是 <code>new</code> 这个名字并没有什么特别之处，它不是关键字。类型通常还有其他关联函数作为构造函数，比如 <code>Vec::with_capacity</code>。</p>\n<p>虽然对于一个类型可以有许多独立的 <code>impl</code> 块，但它们必须都在定义该类型的同一个 crate 中。不过，Rust 确实允许你将自己的方法附加到其他类型中，第 11 章会解释具体做法。</p>\n<p>如果你习惯了用 C++ 或 Java，那么将类型的方法与其定义分开可能看起来很不寻常，但这样做有几个优点。</p>\n<ul>\n<li>找出一个类型的数据成员总是很容易。在大型 C++ 类定义中，你可能需要浏览数百行成员函数的定义才能确保没有遗漏该类的任何数据成员，而在 Rust 中，它们都在同一个地方。</li>\n<li>尽管可以把方法放到具名字段型结构体中，但对元组型结构体和单元型结构体来说这看上去不那么简洁。将方法提取到一个 <code>impl</code> 块中可以让所有这 3 种结构体使用同一套语法。事实上，Rust 还使用相同的语法在根本不是结构体的类型（比如 <code>enum</code> 类型和像 <code>i32</code> 这样的原始类型）上定义方法。（任何类型都可以有方法，这是 Rust 很少使用<strong>对象</strong>这个术语的原因之一，它更喜欢将所有东西都称为<strong>值</strong>。）</li>\n<li>同样的 <code>impl</code> 语法也可以巧妙地用于实现特型，第 11 章会对此进行介绍。</li>\n</ul>\n<h2 id=\"nav_point_160\">9.6　关联常量</h2>\n<p>Rust 在其类型系统中的另一个特性也采用了类似于 C# 和 Java 的思想，有些值是与类型而不是该类型的特定实例关联起来的。在 Rust 中，这些叫作<strong>关联常量</strong>。</p>\n<p>顾名思义，关联常量是常量值。它们通常用于表示指定类型下的常用值。例如，你可以定义一个用于线性代数的二维向量和一个关联的单位向量：</p>\n<pre class=\"code-rows\"><code>pub struct Vector2 {\n    x: f32,\n    y: f32,\n}\n\nimpl Vector2 {\n    const ZERO: Vector2 = Vector2 { x: 0.0, y: 0.0 };\n    const UNIT: Vector2 = Vector2 { x: 1.0, y: 0.0 };\n}</code></pre>\n<p>这些值是和类型本身相关联的，你可以在不必引用 <code>Vector2</code> 的任一实例的情况下使用它们。这与关联函数非常相似，使用的名字是与其关联的类型名，后面跟着它们自己的名字：</p>\n<pre class=\"code-rows\"><code>let scaled = Vector2::UNIT.scaled_by(2.0);</code></pre>\n<p>关联常量的类型不必是其所关联的类型，我们可以使用此特性为类型添加 ID 或名称。如果有多种类似于 <code>Vector2</code> 的类型需要写入文件然后加载到内存中，则可以使用关联常量来添加名称或数值 ID，这些名称或数值 ID 可以写在数据旁边以标识其类型。</p>\n<pre class=\"code-rows\"><code>impl Vector2 {\n    const NAME: &amp;'static str = \"Vector2\";\n    const ID: u32 = 18;\n}</code></pre>\n<h2 id=\"nav_point_161\">9.7　泛型结构体</h2>\n<p>前面对 <code>Queue</code> 的定义并不令人满意：它是为存储字符而写的，但是它的结构体或方法根本没有任何专门针对字符的内容。如果我们要定义另一个包含 <code>String</code> 值的结构体，那么除了将 <code>char</code> 替换为 <code>String</code> 外，其余代码可以完全相同。这纯属浪费时间。</p>\n<p>幸运的是，Rust 结构体可以是<strong>泛型</strong>的，这意味着它们的定义是一个模板，你可以在其中插入任何自己喜欢的类型。例如，下面是 <code>Queue</code> 的定义，它可以保存任意类型的值：</p>\n<pre class=\"code-rows\"><code>pub struct Queue&lt;T&gt; {\n    older: Vec&lt;T&gt;,\n    younger: Vec&lt;T&gt;\n}</code></pre>\n<p>你可以把 <code>Queue&lt;T&gt;</code> 中的 <code>&lt;T&gt;</code> 读作“对于任意元素类型 <code>T</code>……”。所以上面的定义可以这样解读：“对于任意元素类型 <code>T</code>，<code>Queue&lt;T&gt;</code> 有两个 <code>Vec&lt;T&gt;</code> 类型的字段。”例如，在 <code>Queue&lt;String&gt;</code> 中，<code>T</code> 是 <code>String</code>，所以 <code>older</code> 和 <code>younger</code> 的类型都是 <code>Vec&lt;String&gt;</code>。而在 <code>Queue&lt;char&gt;</code> 中，<code>T</code> 是 <code>char</code>，我们最终得到的结构体与最初那个针对 <code>char</code> 定义的结构体是一样的。事实上，<code>Vec</code> 本身也是一个泛型结构体，它就是这样定义的。</p>\n<p>在泛型结构体定义中，尖括号（<code>&lt;&gt;</code>）中的类型名称叫作<strong>类型参数</strong>。泛型结构体的 <code>impl</code> 块如下所示：</p>\n<pre class=\"code-rows\"><code>impl&lt;T&gt; Queue&lt;T&gt; {\n    pub fn new() -&gt; Queue&lt;T&gt; {\n        Queue { older: Vec::new(), younger: Vec::new() }\n    }\n\n    pub fn push(&amp;mut self, t: T) {\n        self.younger.push(t);\n    }\n\n    pub fn is_empty(&amp;self) -&gt; bool {\n        self.older.is_empty() &amp;&amp; self.younger.is_empty()\n    }\n\n    ...\n}</code></pre>\n<p>你可以将 <code>impl&lt;T&gt; Queue&lt;T&gt;</code> 这一行解读为“对于任意元素类型 <code>T</code>，这里有一些在 <code>Queue&lt;T&gt;</code> 上可用的关联函数。”然后，你可以使用类型参数 <code>T</code> 作为关联函数定义中的类型。</p>\n<p>语法可能看起来有点儿累赘，但 <code>impl&lt;T&gt;</code> 可以清楚地表明 <code>impl</code> 块能涵盖任意类型 <code>T</code>，这便能将它与为某种特定类型的 <code>Queue</code> 编写的 <code>impl</code> 块区分开来，如下所示：</p>\n<pre class=\"code-rows\"><code>impl Queue&lt;f64&gt; {\n    fn sum(&amp;self) -&gt; f64 {\n        ...\n    }\n}</code></pre>\n<p>这个 <code>impl</code> 块标头表明“这里有一些专门用于 <code>Queue&lt;f64&gt;</code> 的关联函数”。这为 <code>Queue&lt;f64&gt;</code> 提供了一个 <code>sum</code> 方法，不过该方法在其他类型的 <code>Queue</code> 上不可用。</p>\n<p>我们在前面的代码中使用了 Rust 的 <code>self</code> 参数简写形式，如果到处都写成 <code>Queue&lt;T&gt;</code>，则让人觉得拗口且容易分心。作为另一种简写形式，每个 <code>impl</code> 块，无论是不是泛型，都会将特殊类型的参数 <code>Self</code>（注意这里是大驼峰 <code>CamelCase</code>）定义为我们要为其添加方法的任意类型。对前面的代码来说，<code>Self</code> 就应该是 <code>Queue&lt;T&gt;</code>，因此我们可以进一步缩写 <code>Queue::new</code> 的定义：</p>\n<pre class=\"code-rows\"><code>pub fn new() -&gt; Self {\n    Queue { older: Vec::new(), younger: Vec::new() }\n}</code></pre>\n<p>你可能注意到了，在 <code>new</code> 的函数体中，不需要在构造表达式中写入类型参数，简单地写 <code>Queue { ... }</code> 就足够了。这是 Rust 的类型推断在起作用：由于只有一种类型适用于该函数的返回值（<code>Queue&lt;T&gt;</code>），因此 Rust 为我们补齐了该类型参数。但是，你始终都要在函数签名和类型定义中提供类型参数。Rust 不会推断这些，相反，它会以这些显式类型为基础，推断函数体内的类型。</p>\n<p><code>Self</code> 也可以这样使用，我们可以改写成 <code>Self { ... }</code>。你觉得哪种写法最容易理解就写成哪种。</p>\n<p>在调用关联函数时，可以使用 <code>::&lt;&gt;</code>（比目鱼）表示法显式地提供类型参数：</p>\n<pre class=\"code-rows\"><code>let mut q = Queue::&lt;char&gt;::new();</code></pre>\n<p>但实际上，通常可以让 Rust 帮你推断出来：</p>\n<pre class=\"code-rows\"><code>let mut q = Queue::new();\nlet mut r = Queue::new();\n\nq.push(\"CAD\");  // 显然是Queue&lt;&amp;'static str&gt;\nr.push(0.74);   // 显然是Queue&lt;f64&gt;\n\nq.push(\"BTC\");   // 2019年6月一比特币值多少美元\nr.push(13764.0); // Rust可没能力检测出非理性繁荣</code></pre>\n<p>事实上，我们在本书中经常这样使用另一种泛型结构体类型 <code>Vec</code>。</p>\n<p>不仅结构体可以是泛型的，枚举同样可以接受类型参数，而且语法也非常相似。10.1 节会详细介绍“枚举”。</p>\n<h2 id=\"nav_point_162\">9.8　带生命周期参数的泛型结构体</h2>\n<p>正如我们在 5.3.5 节中讨论的那样，如果结构体类型包含引用，则必须为这些引用的生命周期命名。例如，下面这个结构体可能包含对某个切片的最大元素和最小元素的引用：</p>\n<pre class=\"code-rows\"><code>struct Extrema&lt;'elt&gt; {\n    greatest: &amp;'elt i32,\n    least: &amp;'elt i32\n}</code></pre>\n<p>早些时候，我们建议你把像 <code>struct Queue&lt;T&gt;</code> 这样的声明理解为：给定任意类型 <code>T</code>，都可以创建一个持有该类型的 <code>Queue&lt;T&gt;</code>。同样，可以将 <code>struct Extrema&lt;'elt&gt;</code> 理解为：给定任意生命周期 <code>'elt</code>，都可以创建一个 <code>Extrema&lt;'elt&gt;</code> 来持有对该生命周期的引用。</p>\n<p>下面这个函数会扫描切片并返回一个 <code>Extrema</code> 值，这个值的各个字段会引用其中的元素：</p>\n<pre class=\"code-rows\"><code>fn find_extrema&lt;'s&gt;(slice: &amp;'s [i32]) -&gt; Extrema&lt;'s&gt; {\n    let mut greatest = &amp;slice[0];\n    let mut least = &amp;slice[0];\n\n    for i in 1..slice.len() {\n        if slice[i] &lt; *least    { least    = &amp;slice[i]; }\n        if slice[i] &gt; *greatest { greatest = &amp;slice[i]; }\n    }\n    Extrema { greatest, least }\n}</code></pre>\n<p>在这里，由于 <code>find_extrema</code> 借用了 <code>slice</code> 的元素，而 <code>slice</code> 有生命周期 <code>'s</code>，因此我们返回的 <code>Extrema</code> 结构体也使用了 <code>'s</code> 作为其引用的生命周期。Rust 总会为各种调用推断其生命周期参数，所以调用 <code>find_extrema</code> 时不需要提及它们：</p>\n<pre class=\"code-rows\"><code>let a = [0, -3, 0, 15, 48];\nlet e = find_extrema(&amp;a);\nassert_eq!(*e.least, -3);\nassert_eq!(*e.greatest, 48);</code></pre>\n<p>因为返回类型的生命周期与参数的生命周期相同是很常见的情况，所以如果有一个显而易见的候选者，那么 Rust 就允许我们省略生命周期。因此也可以把 <code>find_extrema</code> 的签名写成如下形式，意思不变：</p>\n<pre class=\"code-rows\"><code>fn find_extrema(slice: &amp;[i32]) -&gt; Extrema {\n    ...\n}</code></pre>\n<p>当然，我们的意思<strong>也可能</strong>是 <code>Extrema&lt;'static&gt;</code>，但这很不寻常。Rust 只为最常见的情况提供了简写形式。</p>\n<h2 id=\"nav_point_163\">9.9　带常量参数的泛型结构体</h2>\n<p>泛型结构体也可以接受常量值作为参数。例如，你可以定义一个表示任意次数多项式的类型，如下所示：</p>\n<pre>\n/// N - 1次多项式\nstruct Polynomial&lt;const N: usize&gt; {\n    /// 多项式的系数\n    ///\n    /// 对于多项式a + bx + cx<sup>2</sup> + ... + zx<sup>n-1</sup>，其第`i`个元素是x<sup>i</sup>的系数\n    coefficients: [f64; N]\n}\n</pre>\n\n<p>例如，根据这个定义，<code>Polynomial&lt;3&gt;</code> 是一个二次多项式。这里的 <code>&lt;const N: usize&gt;</code> 子句表示 <code>Polynomial</code> 类型需要一个 <code>usize</code> 值作为它的泛型参数，以此来决定要存储多少个系数。</p>\n<p>与通过字段保存长度和容量而将元素存储在堆中的 <code>Vec</code> 不同，<code>Polynomial</code> 会将其系数（<code>coefficients</code>）直接存储在值中，再无其他字段。长度直接由类型给出。（这里不需要容量的概念，因为 <code>Polynomial</code> 不能动态增长。）</p>\n<p>也可以在类型的关联函数中使用参数 <code>N</code>：</p>\n<pre>\nimpl&lt;const N: usize&gt; Polynomial&lt;N&gt; {\n    fn new(coefficients: [f64; N]) -&gt; Polynomial&lt;N&gt; {\n        Polynomial { coefficients }\n    }\n\n    /// 计算`x`处的多项式的值\n    fn eval(&amp;self, x: f64) -&gt; f64 {\n        // 秦九韶算法在数值计算上稳定、高效且简单：\n        // c<sub>0</sub> + x(c<sub>1</sub> + x(c<sub>2</sub> + x(c<sub>3</sub> + ... x(c[n-1] + x c[n]))))\n        let mut sum = 0.0;\n        for i in (0..N).rev() {\n            sum = self.coefficients[i] + x * sum;\n        }\n\n        sum\n    }\n}\n</pre>\n\n<p>这里，<code>new</code> 函数会接受一个长度为 <code>N</code> 的数组，并将其元素作为新 <code>Polynomial</code> 值的系数。<code>eval</code> 方法将在 <code>0..N</code> 范围内迭代以找到给定点 <code>x</code> 处的多项式值。</p>\n<p>与类型参数和生命周期参数一样，Rust 通常也能为常量参数推断出正确的值：</p>\n<pre>\nuse std::f64::consts::FRAC_PI_2;   // π/2\n\n// 用近似法对`sin`函数求值：sin x ≅ x - 1/6 x³ + 1/120 x<sup>5</sup>\n// 误差几乎为0，相当精确！\nlet sine_poly = Polynomial::new([0.0, 1.0, 0.0, -1.0/6.0, 0.0,\n                                 1.0/120.0]);\nassert_eq!(sine_poly.eval(0.0), 0.0);\nassert!((sine_poly.eval(FRAC_PI_2) - 1.).abs() &lt; 0.005);\n</pre>\n\n<p>由于我们向 <code>Polynomial::new</code> 传递了一个包含 6 个元素的数组，因此 Rust 知道必须构造出一个 <code>Polynomial&lt;6&gt;</code>。<code>eval</code> 方法仅通过查询其 <code>Self</code> 类型就知道 <code>for</code> 循环应该运行多少次迭代。由于长度在编译期是已知的，因此编译器可能会用一些顺序执行的代码完全替换循环。</p>\n<p>常量泛型参数可以是任意整数类型、<code>char</code> 或 <code>bool</code>。不允许使用浮点数、枚举和其他类型。</p>\n<p>如果结构体还接受其他种类的泛型参数，则生命周期参数必须排在第一位，然后是类型，接下来是任何 <code>const</code> 值。例如，一个包含引用数组的类型可以这样声明：</p>\n<pre class=\"code-rows\"><code>struct LumpOfReferences&lt;'a, T, const N: usize&gt; {\n    the_lump: [&amp;'a T; N]\n}</code></pre>\n<p>常量泛型参数是 Rust 的一个相对较新的功能，目前它们的使用受到了一定的限制。例如，像下面这样定义 <code>Polynomial</code> 显然更好：</p>\n<pre class=\"code-rows\"><code>/// 一个N次多项式\nstruct Polynomial&lt;const N: usize&gt; {\n    coefficients: [f64; N + 1]\n}</code></pre>\n<p>然而，Rust 会拒绝这个定义：</p>\n<pre class=\"code-rows\"><code>error: generic parameters may not be used in const operations\n  |\n6 |     coefficients: [f64; N + 1]\n  |                         ^ cannot perform const operation using `N`\n  |\n  = help: const parameters may only be used as standalone arguments, i.e. `N`</code></pre>\n<p>虽然 <code>[f64; N]</code> 没问题，但像 <code>[f64; N + 1]</code> 这样的类型显然对 Rust 来说太过激进了。所以 Rust 暂时施加了这个限制，以避免遇到像下面这样的问题：</p>\n<pre class=\"code-rows\"><code>struct Ketchup&lt;const N: usize&gt; {\n    tomayto: [i32; N &amp; !31],\n    tomahto: [i32; N - (N % 32)],\n}</code></pre>\n<p>通过计算可知，不管 <code>N</code> 取何值，<code>N &amp; !31</code> 和 <code>N - (N % 32)</code> 总是相等的，因此 <code>tomayto</code> 和 <code>tomahto</code> 始终具有相同的类型。例如，应该允许将任何一个赋值给另一个。但是，如果想让 Rust 的类型检查器识别这种位运算，就需要把一些令人困惑的极端情况引入这种本已相当复杂的语言中，而这会带来复杂度失控的风险。当然，支持像 <code>N + 1</code> 这样的简单表达式是没问题的，并且也确实已经有人在努力教 Rust 顺利处理这些问题。</p>\n<p>由于此处关注的是类型检查器的行为，因此这种限制仅适用于出现在类型中的常量参数，比如数组的长度。在普通表达式中，可以随意使用 <code>N</code>：像 <code>N + 1</code> 和 <code>N &amp; !31</code> 这样的写法是完全可以的。</p>\n<p>如果要为 <code>const</code> 泛型参数提供的值不仅仅是字面量或单个标识符，那么就必须将其括在花括号中，就像 <code>Polynomial&lt;&gt;</code> 这样。此规则能让 Rust 更准确地报告语法错误。</p>\n<h2 id=\"nav_point_164\">9.10　让结构体类型派生自某些公共特型</h2>\n<p>结构体很容易编写：</p>\n<pre class=\"code-rows\"><code>struct Point {\n    x: f64,\n    y: f64\n}</code></pre>\n<p>但是，如果你要开始使用这种 <code>Point</code> 类型，很快就会发现它有点儿难用。像这样写的话，<code>Point</code> 不可复制或克隆，不能用 <code>println!(\"{:?}\", point);</code> 打印，而且不支持 <code>==</code> 运算符和 <code>!=</code> 运算符。</p>\n<p>这些特性中的每一个在 Rust 中都有名称——<code>Copy</code>、<code>Clone</code>、<code>Debug</code> 和 <code>PartialEq</code>，它们被称为<strong>特型</strong>。第 11 章会展示如何为自己的结构体手动实现特型。但是对于这些标准特型和其他一些特型，无须手动实现，除非你想要某种自定义行为。Rust 可以自动为你实现它们，而且结果准确无误。只需将 <code>#[derive]</code> 属性添加到结构体上即可：</p>\n<pre class=\"code-rows\"><code>#[derive(Copy, Clone, Debug, PartialEq)]\nstruct Point {\n    x: f64,\n    y: f64\n}</code></pre>\n<p>这些特型中的每一个都可以为结构体自动实现特型，但前提是结构体的每个字段都实现了该特型。我们可以要求 Rust 为 <code>Point</code> 派生 <code>PartialEq</code>，因为它的两个字段都是 <code>f64</code> 类型，而 <code>f64</code> 类型已经实现了 <code>PartialEq</code>。</p>\n<p>Rust 还可以派生 <code>PartialOrd</code>，这将增加对比较运算符 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code> 的支持。我们在这里并没有这样做，因为比较两个点以了解一个点是否“小于”另一个点是一件很奇怪的事情。毕竟点和点之间并没有任何常规意义上的顺序可言。所以我们选择不让 <code>Point</code> 值支持这些运算符。这种特例就是 Rust 让我们自己编写 <code>#[derive]</code> 属性而不会自动为它派生每一个可能特型的原因之一。而另一个原因是，只要实现某个特型就会自动让它成为公共特性，因此可复制性、可克隆性等都会成为该结构体的公共 API 的一部分，应该慎重选择。</p>\n<p>第 13 章会详细描述 Rust 的标准特型并解释哪些可用于 <code>#[derive]</code>。</p>\n<h2 id=\"nav_point_165\">9.11　内部可变性</h2>\n<p>可变性与其他任何事物一样：过犹不及，而你通常只需要一点点就够了。假设你的蜘蛛机器人控制系统有一个中心结构体 <code>SpiderRobot</code>，其中包含一些设置和 I/O 句柄。该结构体会在机器人启动时设置好，并且值永不改变：</p>\n<pre class=\"code-rows\"><code>pub struct SpiderRobot {\n    species: String,\n    web_enabled: bool,\n    leg_devices: [fd::FileDesc; 8],\n    ...\n}</code></pre>\n<p>机器人的每个主要系统由不同的结构体处理，它们都有一个指向 <code>SpiderRobot</code> 的指针：</p>\n<pre class=\"code-rows\"><code>use std::rc::Rc;\n\npub struct SpiderSenses {\n    robot: Rc&lt;SpiderRobot&gt;,  // &lt;--指向设置和I/O的指针\n    eyes: [Camera; 32],\n    motion: Accelerometer,\n    ...\n}</code></pre>\n<p>织网、捕食、毒液流量控制等结构体也都有一个 <code>Rc&lt;SpiderRobot&gt;</code> 智能指针。回想一下，<code>Rc</code> 代表引用计数（reference counting），并且 <code>Rc</code> 指向的值始终是共享的，因此将始终不可变。</p>\n<p>现在假设你要使用标准 <code>File</code> 类型向 <code>SpiderRobot</code> 结构体添加一点儿日志记录。但有一个问题：<code>File</code> 必须是可变的。所有用于写入的方法都需要一个可变引用。</p>\n<p>这种情况经常发生。我们需要一个不可变值（<code>SpiderRobot</code> 结构体）中的一丁点儿可变数据（一个 <code>File</code>）。这称为<strong>内部可变性</strong>。Rust 提供了多种可选方案，本节将讨论两种最直观的类型，即 <code>Cell&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code>，它们都在 <code>std::cell</code> 模块中。<span class=\"comment-number\">1</span></p>\n\n<p><code>Cell&lt;T&gt;</code> 是一个包含类型 <code>T</code> 的单个私有值的结构体。<code>Cell</code> 唯一的特殊之处在于，即使你对 <code>Cell</code> 本身没有 <code>mut</code> 访问权限，也可以获取和设置这个私有值字段。</p>\n<blockquote>\n<p><code>Cell::new(value)</code>（新建）</p>\n</blockquote>\n<p>创建一个新的 <code>Cell</code>，将给定的 <code>value</code> 移动进去。</p>\n<blockquote>\n<p><code>cell.get()</code>（获取）</p>\n</blockquote>\n<p>返回 <code>cell</code> 中值的副本。</p>\n<blockquote>\n<p><code>cell.set(value)</code>（设置）</p>\n</blockquote>\n<p>将给定的 <code>value</code> 存储在 <code>cell</code> 中，丢弃先前存储的值。</p>\n<p>此方法接受一个不可变引用型的 <code>self</code>。</p>\n<pre class=\"code-rows\"><code>fn set(&amp;self, value: T)    // 注意：不是`&amp;mut self`</code></pre>\n<p>当然，这对名为 <code>set</code> 的方法来说是相当不寻常的。迄今为止，Rust 一直在告诉我们如果想更改数据，就需要 <code>mut</code> 型访问。但出于同样的原因，这个不寻常的细节正是 <code>Cell</code> 的全部意义所在。<code>Cell</code> 只是改变不变性规则的一种安全方式——一丝不多，一毫不少。</p>\n<p><code>cell</code> 还有其他一些方法，你可以查阅其文档进行了解。</p>\n<p>如果你想在 <code>SpiderRobot</code> 中添加一个简单的计数器，那么 <code>Cell</code> 是一个不错的工具。可以写成如下形式：</p>\n<pre class=\"code-rows\"><code>use std::cell::Cell;\n\npub struct SpiderRobot {\n    ...\n    hardware_error_count: Cell&lt;u32&gt;,\n    ...\n}</code></pre>\n<p>然后，即使 <code>SpiderRobot</code> 中的非 <code>mut</code> 方法也可以使用 <code>.get()</code> 方法和 <code>.set()</code> 方法访问 <code>u32</code>：</p>\n<pre class=\"code-rows\"><code>impl SpiderRobot {\n    /// 把错误计数递增1\n    pub fn add_hardware_error(&amp;self) {\n        let n = self.hardware_error_count.get();\n        self.hardware_error_count.set(n + 1);\n    }\n\n    /// 如果报告过任何硬件错误，则为true\n    pub fn has_hardware_errors(&amp;self) -&gt; bool {\n        self.hardware_error_count.get() &gt; 0\n    }\n}</code></pre>\n<p>这很容易，但它无法解决我们的日志记录问题。<code>Cell</code> <strong>不允许</strong>在共享值上调用 <code>mut</code> 方法。<code>.get()</code> 方法会返回 <code>Cell</code> 中值的副本，因此它仅在 <code>T</code> 实现了 <code>Copy</code> 特型时才有效。对于日志记录，我们需要一个可变的 <code>File</code>，但 <code>File</code> 不是 <code>Copy</code> 类型。</p>\n<p>在这种情况下，正确的工具是 <code>RefCell</code>。与 <code>Cell&lt;T&gt;</code> 一样，<code>RefCell&lt;T&gt;</code> 也是一种泛型类型，它包含类型 <code>T</code> 的单个值。但与 <code>Cell</code> 不同，<code>RefCell</code> 支持借用对其 <code>T</code> 值的引用。</p>\n<blockquote>\n<p><code>RefCell::new(value)</code>（新建）</p>\n</blockquote>\n<p>创建一个新的 <code>RefCell</code>，将 <code>value</code> 移动进去。</p>\n<blockquote>\n<p><code>ref_cell.borrow()</code>（借用）</p>\n</blockquote>\n<p>返回一个 <code>Ref&lt;T&gt;</code>，它本质上只是对存储在 <code>ref_cell</code> 中值的共享引用。</p>\n<p>如果该值已被以可变的方式借出，则此方法会 panic，详细信息稍后会解释。</p>\n<blockquote>\n<p><code>ref_cell.borrow_mut()</code>（可变借用）</p>\n</blockquote>\n<p>返回一个 <code>RefMut&lt;T&gt;</code>，它本质上是对 <code>ref_cell</code> 中值的可变引用。</p>\n<p>如果该值已被借出，则此方法会 panic，详细信息稍后会解释。</p>\n<blockquote>\n<p><code>ref_cell.try_borrow()</code>（尝试借用）和 <code>ref_cell.try_borrow_mut()</code>（尝试可变借用）</p>\n</blockquote>\n<p>行为与 <code>borrow()</code> 和 <code>borrow_mut()</code> 一样，但会返回一个 <code>Result</code>。如果该值已被以可变的方式借出，那么这两个方法不会 panic，而是返回一个 <code>Err</code> 值。</p>\n<p>同样，<code>RefCell</code> 也有一些其他的方法，你可以在其文档中进行查找。</p>\n<p>仅当你试图打破“可变引用必须独占”的 Rust 规则时，这两个 <code>borrow</code> 方法才会 panic。例如，以下代码会引起 panic：</p>\n<pre class=\"code-rows\"><code>use std::cell::RefCell;\n\nlet ref_cell: RefCell&lt;String&gt; = RefCell::new(\"hello\".to_string());\n\nlet r = ref_cell.borrow();      // 正确，返回Ref&lt;String&gt;\nlet count = r.len();            // 正确，返回\"hello\".len()\nassert_eq!(count, 5);\n\nlet mut w = ref_cell.borrow_mut();  // panic：已被借出\nw.push_str(\" world\");</code></pre>\n<p>为避免 panic，可以将这两个借用放入不同的块中。这样，在你尝试借用 <code>w</code> 之前，<code>r</code> 已经被丢弃了。</p>\n<p>这很像普通引用的工作方式。唯一的区别是，通常情况下，当你借用一个变量的引用时，Rust 会<strong>在编译期</strong>进行检查，以确保你在安全地使用该引用。如果检查失败，则会出现编译错误。<code>RefCell</code> 会使用运行期检查强制执行相同的规则。因此，如果你违反了规则，就会收到 panic（对于 <code>try_borrow</code> 和 <code>try_borrow_mut</code> 则会显示 <code>Err</code>）。</p>\n<p>现在我们已经准备好把 <code>RefCell</code> 用在 <code>SpiderRobot</code> 类型中了：</p>\n<pre class=\"code-rows\"><code>pub struct SpiderRobot {\n    ...\n    log_file: RefCell&lt;File&gt;,\n    ...\n}\n\nimpl SpiderRobot {\n    /// 往日志文件中写一行消息\n    pub fn log(&amp;self, message: &amp;str) {\n        let mut file = self.log_file.borrow_mut();\n        // `writeln!`很像`println!`，但会把输出发送到给定的文件中\n        writeln!(file, \"{}\", message).unwrap();\n    }\n}</code></pre>\n<p>变量 <code>file</code> 的类型为 <code>RefMut&lt;File&gt;</code>，我们可以像使用 <code>File</code> 的可变引用一样使用它。有关写入文件的详细信息，请参阅第 18 章。</p>\n<p><code>Cell</code> 很容易使用。虽然不得不调用 <code>.get()</code> 和 <code>.set()</code> 或 <code>.borrow()</code> 和 <code>.borrow_mut()</code> 略显尴尬，但这就是我们为违反规则而付出的代价。还有一个缺点虽不太明显但更严重：<code>Cell</code> 以及包含它的任意类型都不是线程安全的。因此 Rust 不允许多个线程同时访问它们。第 19 章会讲解内部可变性的线程安全风格，届时我们会讨论“<code>Mutex&lt;T&gt;</code>”（参见 19.3.2 节）、“原子化类型”（参见 19.3.10 节）和“全局变量”（参见 19.3.11 节）这几项技术。</p>\n<p>无论一个结构体是具名字段型的还是元组型的，它都是其他值的聚合：如果我有一个 <code>SpiderSenses</code> 结构体，那么就有了指向共享 <code>SpiderRobot</code> 结构体的 <code>Rc</code> 指针、有了眼睛、有了陀螺仪，等等。所以结构体的本质是“和”这个字：我有 <code>X</code> <strong>和</strong> <code>Y</code>。但是如果围绕“或”这个字构建另一种类型呢？也就是说，当你拥有这种类型的值时，你就拥有了 <code>X</code> <strong>或</strong> <code>Y</code>。这种类型也非常有用，在 Rust 中无处不在，它们是第 10 章的主题。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 8 章 crate 与模块(2)","id":740808},"right":{"article_title":"第 10 章 枚举与模式","id":740810}},"comments":[{"had_liked":false,"id":394513,"user_name":"PeiXy","can_delete":false,"product_type":"c1","uid":1595503,"ip_address":"浙江","ucode":"0C6A212B0B140D","user_header":"https://static001.geekbang.org/account/avatar/00/18/58/6f/4acc5b43.jpg","comment_is_top":false,"comment_ctime":1727017836,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636604,"comment_content":"pub struct Vector2 {\n    x: f32,\n    y: f32,\n}\n\nimpl Vector2 {\n    const ZERO: Vector2 = Vector2 { x: 0.0, y: 0.0 };\n    const UNIT: Vector2 = Vector2 { x: 1.0, y: 0.0 };\n}\n\n需要改为\n\nimpl Vector2 {\n pub   const ZERO: Vector2 = Vector2 { x: 0.0, y: 0.0 };\n pub    const UNIT: Vector2 = Vector2 { x: 1.0, y: 0.0 };\n}\n否则在下面方法无法被调用","like_count":0},{"had_liked":false,"id":391359,"user_name":"波罗","can_delete":false,"product_type":"c1","uid":1297000,"ip_address":"江苏","ucode":"C7F32FAEBAC2CA","user_header":"https://static001.geekbang.org/account/avatar/00/13/ca/68/161971d5.jpg","comment_is_top":false,"comment_ctime":1718098428,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636604,"comment_content":"struct GrayscaleMap {\n    pixels: Vec&lt;u32&gt;,\n    size: (usize, usize),\n}\n\nlet width = 1024;\nlet height = 576;\nlet image = GrayscaleMap {\n    pixels: vec![0; width * height],\n    size: (width, height)\n};\n\nassert_eq!(image.size, (1024, 576));\nassert_eq!(image.pixels.len(), 1024 * 576);\n这些是故意书写错误的吗？","like_count":0}]}