{"id":621012,"title":"15｜聚合的实现（上）：怎样对聚合进行封装？","content":"<p>你好，我是钟敬。</p><p><a href=\"https://time.geekbang.org/column/article/620047\">上节课</a>我们通过为员工技能、工作经验等实体建立领域模型，学习了聚合的概念。接下来三节课，我们会以员工聚合为例，学习聚合的实现。</p><p>上节课我们讲过，聚合的一个主要特征是具有不变规则。而维护不变规则的前提是要做好对聚合的封装，否则，外部的对象就可能无意间破坏聚合内部的规则。</p><p>在上个迭代，我们已经通过<strong>组织（Org）<strong>对象学习了对单个对象的封装。而</strong>聚合</strong>是一组对象，那么封装的方法又有什么不同之处呢？这就是我们这一节课的重点。</p><p>下面，我们通过<strong>新增员工聚合</strong>的功能来讨论对聚合的封装。</p><h2>数据库设计</h2><p>我们先为员工聚合中新增的实体设计数据库表。回忆一下领域模型，如下图。<br>\n<img src=\"https://static001.geekbang.org/resource/image/a9/4f/a9a49747b1b3e7f39939da1e24e4bd4f.jpg?wh=2807x2260\" alt=\"\"></p><p>根据上个迭代学过的知识，我们不难设计出数据库表，如下图。<br>\n<img src=\"https://static001.geekbang.org/resource/image/b4/9a/b41cef8571242be3ce1010c6a16c6b9a.jpg?wh=3733x2260\" alt=\"\"></p><p>其中 <strong>skill_type、skill <strong>和 <strong>work_experience</strong> 就是为</strong>技能类别</strong>、<strong>技能</strong>和<strong>工作经验</strong>新增的三个表。</p><h2>实现关联的两种方法</h2><p>在正式开始编码之前，我们有必要先聊一下在代码中怎样实现领域对象之间的关联。这一点在上个迭代还没有仔细谈。</p><p>实现关联主要有两种方式，一种是<strong>对象关联</strong>，另一种是 <strong>ID关联</strong>。我们用下面这个简化的组织和员工的领域模型来说明问题。<br>\n<img src=\"https://static001.geekbang.org/resource/image/e5/03/e57fa5d4a0882f74340fd7dd79f60703.jpg?wh=3008x2150\" alt=\"\"></p><h3>对象关联</h3><p>如果采用<strong>对象关联</strong>的话，这两个类的代码骨架是下面这样的。</p><!-- [[[read_end]]] --><pre><code class=\"language-java\">public class Org{\n    private List&lt;Emp&gt; members;\n    // other fields ...\n    // getters and setters ...\n}\n</code></pre><pre><code class=\"language-java\">public class Emp{\n    private Org org;\n    // other fields ...\n    // getters and setters ...\n}\n</code></pre><p>在这上面的实现中，<strong>组织（Org）</strong> 类里有<strong>员工（Emp）</strong>类的 List。</p><p>因此，我们可以从一个<strong>组织</strong>对象直接找到所有员工，反之，也可以从员工对象直接找到所属的组织。所以这是一个<strong>双向</strong>的对象关联。我们可以用下面的类图来表示这种代码设计。<br>\n<img src=\"https://static001.geekbang.org/resource/image/2f/13/2fb5dfae671bf4fe47423f4830ca9f13.jpg?wh=3008x2150\" alt=\"\"></p><p>注意，这个图虽然也是UML的类图，但是和上面的领域模型图的性质不一样。领域模型表示的是业务概念，是业务人员能够理解的。而这个图是实现层面的，只对开发人员有意义，业务人员不需要理解。</p><p>这种图在传统上叫<strong>设计模型图</strong>，不过为了避免混淆，我们这里把它称为<strong>实现模型图</strong>，以便和领域模型图区别。如果你觉得这里的实现模型和领域模型的差别还不够明显，那么我们再看一下另一种<strong>对象关联</strong>的实现模型。<br>\n<img src=\"https://static001.geekbang.org/resource/image/93/8e/934c6978e5d8b31b7ec1ec56e7a5ae8e.jpg?wh=3008x2150\" alt=\"\"></p><p>这个图里有一个由组织对象指向员工对象的箭头，说明这是一个单向关联，相应的代码是下面这样。</p><pre><code class=\"language-java\">public class Org{\n    private List&lt;Emp&gt; members;\n    // other fields ...\n    // getters and setters ...\n}\n</code></pre><pre><code class=\"language-java\">public class Emp{\n    // private Org org; 由于是单向关联，所以从Emp不能直接导航到Org\n    // other fields ...\n    // getters and setters ...\n}\n</code></pre><p>在上面的代码中，只能由<strong>组织</strong>直接通过<strong>对象关联</strong>找到<strong>员工</strong>，从<strong>员工</strong>不能直接找到<strong>组织</strong>。如果把关联换一个方向就成了下面这样。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ba/fc/baf4a9edffd6763c20fd50907de66dfc.jpg?wh=3008x2150\" alt=\"\"></p><pre><code class=\"language-java\">public class Org{\n    // private List&lt;Emp&gt; members; 单向关联，所以从Org不能导航到 members\n    // other fields ...\n    // getters and setters ...\n}\n</code></pre><pre><code class=\"language-java\">public class Emp{\n    private Org org; \n    // other fields ...\n    // getters and setters ...\n}\n</code></pre><h3>ID关联</h3><p>前面说了对象关联，而ID关联就更简单了。下面是代码。</p><pre><code class=\"language-java\">public class Org{\n    // fields ...\n    // getters and setters ...\n}\n</code></pre><pre><code class=\"language-java\">public class Emp{\n    private Long OrgId;       // 员工所属组织的ID\n    // other fields ...\n    // getters and setters ...\n}\n</code></pre><p>这是由<strong>员工</strong>到<strong>组织</strong>的单向关联，只不过员工对象里只存了组织ID，由组织ID找到组织对象的工作只能留给<strong>领域服务</strong>或<strong>应用服务</strong>了。相应的实现模型图是下面的样子。<br>\n<img src=\"https://static001.geekbang.org/resource/image/b0/fb/b0015fd637717fcd0acf5078a56c62fb.jpg?wh=3008x2150\" alt=\"\"></p><p>尽管从领域模型的角度，组织和员工之间是存在双向关联的，但在实现层面，由于两者之间没有对象关联，所以我们没有在图上画出表示关联的实线。</p><p>另外，orgId 前面的减号（-）表示这是一个私有（private）属性。在UML里还有其他几种表示权限的修饰符：加号（+）表示公有（public）权限；井号（#）表示保护（protected）权限；波浪号（~）表示包级私有（package private）权限。</p><p>在领域模型里，所用属性都可以看作公有的，所以没有必要加权限修饰符。但实现模型是直接和代码对应的，一般要说明属性和方法的权限。这也是领域模型和实现模型的一个区别。</p><p>不论是对象关联还是ID关联，这几种方式都是同一个领域模型的不同实现。对于同一个领域模型，具体采用哪种实现关联的策略，取决于开发者的权衡，与业务人员没有直接关系。</p><p>领域模型和实现模型图的区别，实际上反映的是我们思维的两个不同层面，一个是概念层面（或者叫领域层面），另一个是实现层面。这种思维方式对正确实践 DDD 很重要。</p><p>在 DDD 的实践中，领域模型图是必需的，而实现模型图则是可选的，一般只在逻辑比较复杂或者开发者还不熟练的时候才要画出来。熟练以后，通常在脑子里过一下，直接根据领域模型写代码就可以了。而在课程中，为了清晰，我们还是会把实现模型画出来。</p><h3>两种关联方式的比较</h3><p>那么在这几种方式中该怎么选择呢？我们把领域模型图和 4 种实现方式放在一起来看看。<br>\n<img src=\"https://static001.geekbang.org/resource/image/36/65/363cba474339f53162e61bfb49938f65.jpg?wh=3008x1671\" alt=\"\"></p><p>基于对象的关联是传统面向对象编程的标准姿势。在这种方式下，对象之间通过自由地导航，共同完成任务。使用这种方式，大部分领域逻辑都可以在领域对象自身中完成，因此，只有少数情况才需要用到领域服务。</p><p>我们在上个迭代说过，传统的面向对象编程的基本假设是大部分对象都装入了内存，只有这样才能实现对象之间的自由导航。不过这种假设和企业应用是不符合的，因为企业应用的大部分数据都在数据库里，如果频繁地将数据库中大量的数据装入内存，必然引起性能问题。</p><p>要在企业应用里大量使用对象关联，必须采用<strong>懒加载方式（也叫延迟加载）</strong>。也就是说，把一个对象从数据库中装入内存时，不装入关联的对象。只有当这个对象要用到某个关联对象的时候，才“透明地”把关联的对象装入内存。</p><p>懒加载一般要用到缓存、代理甚至字节码增强等技术，手动实现起来比较繁琐。好在实现了 JPA 的“全自动”的 ORM 框架（例如Hibernate）已经提供了成熟的实现，采用这些框架，就可以基于对象导航，实现传统的面向对象编程。</p><p>然而这是有代价的。由于 Hibernate 这样的框架背着程序员“偷偷地”做了很多事情，因此程序员就要对框架的原理有比较深入的理解，否则有可能带来意想不到的性能问题，而且有时也不容易进行精细化的性能调优。所以国内多数开发团队并不采用全自动的 ORM 框架，而是用MyBatis 这样的半自动框架，这样就只能以ID导航为主了。</p><p>使用ID导航的时候，由于领域对象之间难以通过导航来协作，所以对象内部能实现的领域逻辑就很有限了，大量的逻辑就要在领域服务中实现。所以这种方式下，多数聚合都至少要搭配一个自己的领域服务。这样，编程风格就只能是偏过程式的了。</p><p>另一方面，ID导航的优点在于简单直白，容易掌握，不容易出现隐蔽的问题。如果使用得当，同样可以一定程度上实现封装、继承等面向对象的特征，并实现整洁代码。</p><p>有趣的是，使用 JPA 的程序员在国内虽然是少数，在国外却是多数。其实，这两种方式都各有利弊，并没有绝对的对错，而且在实践中有时也会结合使用。</p><p>考虑到国内的现状，我们的代码总体上采用偏过程的风格。对于导航的设计来说，我们采用一种折衷的方式：<strong>在聚合内部使用对象导航，跨聚合则使用ID导航</strong>。</p><h2>聚合代码的封装</h2><p>好，下面我们开始为“添加员工”的功能编码了。</p><p>DDD 要求，代码和模型一定要保持一致。所以，在实践中，咱们通常一边打开领域模型图，一边打开 IDE，对着模型来写代码。下面是和员工有关的部分的领域模型。<br>\n<img src=\"https://static001.geekbang.org/resource/image/0f/ba/0fc24eb04b2583e722a90163d348dbba.jpg?wh=2807x2260\" alt=\"\"></p><p>我们把实现模型也画出来。<br>\n<img src=\"https://static001.geekbang.org/resource/image/d7/bd/d75f0ba017101948bbae79cee2e4d3bd.jpg?wh=2807x2260\" alt=\"\"></p><p>在实现模型里面，聚合内部，<strong>员工</strong>和<strong>技能</strong>、<strong>工作经验</strong>之间是单向的<strong>对象关联</strong>；在聚合之间，<strong>技能</strong>对象通过 skillTypeId 实现到<strong>技能类别</strong>的 <strong>ID关联</strong>； <strong>员工</strong>对象通过 orgId 实现到<strong>组织</strong>对象的 <strong>ID关联</strong>，通过 postCodes（一个包含岗位代码的List）实现到<strong>岗位</strong>的 <strong>ID关联</strong>。</p><h3>对非聚合根的封装</h3><p>下面我们从封装的角度，完成聚合的基本代码。先看一下<strong>技能（Skill）</strong>类：</p><pre><code class=\"language-plain\">package chapter15.unjuanable.domain.orgmng.emp;\n// imports ...\n\npublic class Skill extends AuditableEntity {\n    private Long id;            // 只读\n    private Long tenantId;      // 只读\n    private Long skillTypeId;   // 只读，表示到技能类型的ID关联\n    SkillLevel level;           // 读写\n    private int duration;       // 读写\n\n    // 包级私有权限\n    Skill(Long tenantId, Long skillTypeId, LocalDateTime createdAt, Long createdBy) {\n        super(createdAt, createdBy);\n        this.tenantId = tenantId;\n        this.skillTypeId = skillTypeId;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public Long getSkillTypeId() {\n        return skillTypeId;\n    }\n\n    public SkillLevel getLevel() {\n        return level;\n    }\n\n    // 包级私有权限\n    void setLevel(SkillLevel level) {\n        this.level = level;\n    }\n\n    public int getDuration() {\n        return duration;\n    }\n\n    // 包级私有权限\n    void setDuration(int duration) {\n        this.duration = duration;\n    }\n}\n</code></pre><p>这个类比较简单，不过还是有几个微妙的地方要注意。</p><p>我们先分析哪些属性是只读的，哪些可以修改。和上个迭代的组织类一样，Id 和 tenantId 是只读的。那为什么 skillTypeId 也设计成只读呢？</p><p>我们在上节课说过，非聚合根对象有局部标识。由于在业务规则上，一个人同一个类别的技能不能出现两遍，所以我们就可以把技能类别当作技能对象的局部标识。</p><p>既然是标识，就不要变了。也就是说，如果张三有Java技能，那么可以把Java技能的等级由初级改成高级。但是不能把Java技能本身改成C#，如果一定要改，应该把Java技能删除，再新建 C# 技能。</p><p>对于这个类的所有属性，都有 public 的 getter，而只有可写的 2 个属性才有 setter。注意，这两个 setter 既不是 public的，也不是 private 的，在方法签名前面什么修饰符都没有。这种权限叫做“包级私有权限”（package private），后面我们都简称为“包级权限”。它的意思是，只有同一个包内的其他对象才能访问，出了包就不能访问了。为什么要这样做呢？</p><p>因为聚合的<strong>不变规则</strong>往往不是单个对象能够处理的。比如说，“同一技能不能录入两次”这个规则，通过查看单独的技能对象是无法验证的，必须查看员工的全部技能，才能判断一条新技能是否重复。所以这种规则必须由<strong>聚合根</strong>或者相应的<strong>领域服务</strong>负责验证。</p><p>因此，为了保证不绕过规则的校验，非聚合根对象就不能由外界直接创建或修改。这就得出了聚合编程的一个重要原则：<strong>聚合外部对象对非聚合根对象只能读，不能写，必须通过聚合根才能对非根对象进行访问</strong>。</p><p>由于每个聚合都在同一个包里，把<strong>技能</strong>的 setter 设置成包级权限，就保证了只有在聚合内部的聚合根、领域服务、工厂等才能对他进行修改，外界只能读取。同样，<strong>技能</strong>对象的构造器也是包级权限，这样，就只有聚合内部才能创建<strong>技能</strong>对象了。</p><p>工作经验（WorkExperience）的代码是类似的。</p><pre><code class=\"language-plain\">package chapter15.unjuanable.domain.orgmng.emp;\n// imports ...\n\npublic class WorkExperience extends AuditableEntity {\n    private Long id;              // 只读\n    private Long tenantId;        // 只读\n    private LocalDate startDate;  // 只读\n    private LocalDate endDate;    // 只读\n    private String company;       // 读写\n\n    // 包级私有权限\n    WorkExperience(Long tenantId, LocalDate startDate, LocalDate endDate\n            ,LocalDateTime createdAt, Long createdBy) {\n\n        super(createdAt, createdBy);\n        this.tenantId = tenantId;\n        this.startDate = startDate;\n        this.endDate = endDate;\n    }\n    \n    // setters and getters ...\n   \n    // 包级私有权限\n    void setCompany(String company) {\n        this.company = company;\n    }\n\n}\n</code></pre><p>由于工作经验的时间段不能重叠，所以我们可以把时间段，也就是开始时间和结束时间，作为局部标识。</p><h3>对聚合根的封装</h3><p>聊完了非聚合根，我们下面再来看看聚合根，也就是员工（Emp）类的代码：</p><pre><code class=\"language-java\">package chapter15.unjuanable.domain.orgmng.emp;\n// imports ...\n\npublic class Emp extends AuditableEntity {\n    private Long id;          // 只读\n    private Long tenantId;    // 只读\n    private Long orgId;        // 读写\n    private String num;       // 读写，员工编号\n    private String idNum;     // 读写，身份证号\n    private Gender Gender;    // 读写\n    private LocalDate dob;    // 读写\n    private EmpStatus status; // 读写\n\n    private List&lt;Skill&gt; skills;              // 读写\n    private List&lt;WorkExperience&gt; experiences;// 读写\n    private List&lt;String&gt; postCodes;          // 读写，岗位代码\n\n    public Emp(Long tenantId, LocalDateTime createdAt, Long createdBy) {\n        super(createdAt, createdBy);\n        this.tenantId = tenantId;\n    }\n\n    // other getters and setters ...\n\n    public EmpStatus getStatus() {\n        return status;\n    }\n\n    public void becomeRegular() {\n        status = EmpStatus.REGULAR;\n    }\n\n    public void terminate() {\n        status = EmpStatus.TERMINATED;\n    }\n\n    // 对 skills、experiences 和 postCodes 的操作 ...\n}\n</code></pre><p>对于<strong>状态（status）</strong>属性，我们没有写 setStatus() 方法，而是用 becomeRegular()（转正）和teminate() （终止）这两个方法来切换状态。这和上个迭代中对组织状态的封装是类似的。而且在下一节课里我们还会看到，这种封装更便于业务规则的实现。</p><p>下面我们重点看一看聚合根对非聚合根的封装。</p><pre><code class=\"language-java\">package chapter15.unjuanable.domain.orgmng.emp;\n// imports ...\n\npublic class Emp extends AuditableEntity {\n    // other fields ...\n    \n    private List&lt;Skill&gt; skills;              // 读写\n    private List&lt;WorkExperience&gt; experiences;// 读写\n    private List&lt;String&gt; postCodes;          // 读写，岗位代码\n\n    // constructors and other getters and setters ...\n\n    public Optional&lt;Skill&gt; getSkill(Long skillTypeId) {\n        return skills.stream()\n                .filter(s -&gt; s.getSkillTypeId() == skillTypeId)\n                .findAny();\n    }\n    \n    public List&lt;Skill&gt; getSkills() {\n        return Collections.unmodifiableList(skills);\n    }\n    \n    void addSkill(Long skillTypeId, SkillLevel level\n                  , int duration, Long userId) {\n        Skill newSkill = new Skill(tenantId, skillTypeId\n                  , LocalDateTime.now(), userId);\n        newSkill.setLevel(level);\n        newSkill.setDuration(duration);\n\n        skills.add(newSkill);\n    }\n\n    // 对 experiences、postCodes 进行类似的处理 ...\n    \n}\n</code></pre><p>技能、工作经验和岗位的处理是类似的，我们只看<strong>技能</strong>就可以了。</p><p>用来查询技能对象的方法有两个，一个查询单个技能，另一个查询整个技能列表。查询单个技能对象的方法 getSkill(Long skillTypeId) 用技能类别ID作为查询条件，这是因为技能类别是技能的局部标识。这个方法的其他部分没有什么特殊之处，不过要强调一点，由于已经用包级权限对技能对象进行了封装，所以在聚合以外无法修改技能对象。</p><p>再看一下查询技能列表的 getSkills() 方法。我们过去可能会像下面这样写：</p><pre><code class=\"language-java\">    public List&lt;Skill&gt; getSkills() {\n        return skills;\n    }\n</code></pre><p>这种写法直接把包含Skill的List返回给外界。这样，尽管外界不能修改单独的技能对象，但可以对列表进行增删，这样还是有可能破坏业务规则。</p><p>所以我们可以用下面的技巧，把员工对象内部的技能列表转换成一个只读列表后再返回。这样，外界就只能读这个列表，不能进行增删了，从而对<strong>技能</strong>实现了完全的封装。</p><pre><code class=\"language-plain\">Collections.unmodifiableList(experiences);\n</code></pre><p>另外，我们用 addSkill() 方法来增加技能。这样，外界就不是直接创建技能对象，而是把创建技能对象的“素材”作为参数传递给 addSkill() 方法，从而在聚合根内部创建技能对象。对修改功能的封装也类似，我们会在后面的课程里讲。</p><h2>总结</h2><p>今天我们谈的重点是聚合的封装。</p><p>我们首先讨论了实现关联的两种方式，一种是<strong>对象关联</strong>，另一种是<strong>ID关联</strong>。无论哪种方式，领域模型都是一样的，区别只是实现策略。对象关联是传统面向对象编程的常规方式，但在企业应用的场景下，通常需要可以实现懒加载的ORM框架的支持。ID关联比较简单，但导致偏过程式的编程。我们的课程采用了折衷的方式，在聚合内部用对象关联，聚合之间用ID关联。</p><p>我们还介绍了两个层面类图的区别，一个是领域层面，一个是实现层面。这反映了思维的两个层次。这种区别是理解DDD的一个重点。</p><p>接着，我们以<strong>员工</strong>聚合为例，分别实现了对非聚合根和聚合根对象的封装。为了确保不变规则不被破坏，总的原则是：<strong>聚合外部对象对非聚合根对象只能读，不能写，必须通过聚合根才能对非根对象进行访问。</strong>用到的具体技术包括用包级私权限封装构造器和方法，返回不可变列表，用聚合根创建和访问非根对象等。</p><h2>思考题</h2><p>最后是两道思考题。</p><p>1.在面向对象编程中，对象是类的实例。那么，你认为聚合是对象之间的关系还是类之间的关系？</p><p>2.课程里的程序在聚合内部使用对象导航，聚合间则使用ID导航。可否分析一下这么做背后的权衡思路呢？</p><p>好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们继续聊不变规则的实现和聚合的持久化。</p>","neighbors":{"left":{"article_title":"14｜聚合的概念：怎样保护业务规则？","id":620047},"right":{"article_title":"16｜聚合的实现（中）：怎样实现不变规则？","id":621713}},"comments":[{"had_liked":false,"id":367220,"user_name":"邓西","can_delete":false,"product_type":"c1","uid":2977417,"ip_address":"四川","ucode":"DC84CD4CDF4021","user_header":"","comment_is_top":false,"comment_ctime":1675047888,"is_pvip":false,"replies":[{"id":135201,"content":"回答得很好。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678979666,"ip_address":"广东","comment_id":367220,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1. 对象间的关系。前文已经给到：聚合是一组对象的封装。\n2. 个人理解，是对运行效率（考虑io开销）和有限内存的balance，聚合内部各对象互访频繁（也算是一种局部性原理）直接加载至内存中提升运算效率；而聚合间使用id则可以利用DB的索引提升查询效率。","like_count":12,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609469,"discussion_content":"回答得很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678979666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366112,"user_name":"燃","can_delete":false,"product_type":"c1","uid":1337002,"ip_address":"浙江","ucode":"3F4AB00C8B93E7","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/aa/639a276f.jpg","comment_is_top":false,"comment_ctime":1673407495,"is_pvip":false,"replies":[{"id":133659,"content":"大对象本身就是问题，最好尽量把大对象拆成若干小对象。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674447236,"ip_address":"广东","comment_id":366112,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1对象之间的关系\n2都可以封装成对象关系当然好，但是会遇到对象膨胀的问题，用id关联可以控制对象膨胀。我这里提个问题，业务中多个流程都修改同一个大对象，如果大对象数据有问题排查异常困难，这种问题如何解决","like_count":6,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600484,"discussion_content":"大对象本身就是问题，最好尽量把大对象拆成若干小对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674447236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365890,"user_name":"Geek_8ac303","can_delete":false,"product_type":"c1","uid":1888721,"ip_address":"广东","ucode":"64A176DE7F498E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIERY97h7dmXbtur6rhZWA9Jb3TtSsJh7icDdFjdLmruTXC22qibOVTmW2a04TxMhxqtNJibYL1iaU7yQ/132","comment_is_top":false,"comment_ctime":1673183531,"is_pvip":false,"replies":[{"id":133292,"content":"确实有这个问题。会在第三迭代的CQRS解决。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673230808,"ip_address":"广东","comment_id":365890,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"针对思考题2有个疑问：\n课程里的程序在聚合内部使用对象导航，会存在一个性能问题，就是技能和工作经验，在员工详情页是必须显示的，但是在列表页一般都不显示，即使用了jpa的懒加载还存在无法批量查询，性能下降的问题。在国内的数据量级OneToOne、ManyToMany这种自动化获取关联数据用法并不常用","like_count":3,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598934,"discussion_content":"确实有这个问题。会在第三迭代的CQRS解决。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673230808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365801,"user_name":"张强","can_delete":false,"product_type":"c1","uid":1273361,"ip_address":"广东","ucode":"A017F014BABD30","user_header":"https://static001.geekbang.org/account/avatar/00/13/6e/11/65e668c0.jpg","comment_is_top":false,"comment_ctime":1673053200,"is_pvip":false,"replies":[{"id":133267,"content":"差不多。第二点主要是性能和方便性的权衡。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673091107,"ip_address":"广东","comment_id":365801,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1. 聚合是对象之间的关系。\n2.能够想到的是性能。 如果聚合间也是用对象导航，就要把所有关联说一句查出来，会涉及很多表。有可能一次操作根本没有另一个聚合什么事，而需要把它查出来，就好多余的操作。","like_count":3,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598798,"discussion_content":"差不多。第二点主要是性能和方便性的权衡。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673091108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366307,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"山东","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1673572589,"is_pvip":false,"replies":[{"id":133675,"content":"第一段讲到不是判断逻辑放在领域服务还是应用层，而是放在领域服务还是领域对象。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674451808,"ip_address":"广东","comment_id":366307,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"由于领域对象之间难以通过导航来协作，所以对象内部能实现的领域逻辑就很有限了，大量的逻辑就要在领域服务中实现。所以这种方式下，多数聚合都至少要搭配一个自己的领域服务。\n\n这块理解差异很大。 虽然我们判断一段逻辑放领域服务还是应用层确实会参考是单聚合根实例的操作还是多聚合根实例。 但是本质上领域服务还是来自业务专家的认知，比如拼车功能，合包逻辑等等。它与聚合根是平级对等的。在领域建模时，我们会省掉那些复杂关系和注释 规则。但领域服务和关键领域事件是记录的。 因为这个图是与业务沟通的桥梁，你必然会有些功能不属于任何聚合根，无法仅用聚合根就承接住它们。那么你就需要这些模型来和业务方达成一致。","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600502,"discussion_content":"第一段讲到不是判断逻辑放在领域服务还是应用层，而是放在领域服务还是领域对象。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1674451808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367902,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"北京","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1675732759,"is_pvip":false,"replies":[{"id":133997,"content":"1 主要权衡的是另一个层面的空值问题。数据库里有整型空字段的话，正好可以和程序里包装类型的null对应。如果用基本类型，就要用一个特殊值代表空值。这么做的代价是略微影响性能。这只是我的习惯，你也可以不这么做。\n2 我的程序里有用==吗？麻烦指出是哪一处，可能我疏忽了。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675831551,"ip_address":"广东","comment_id":367902,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"这里有 2 个代码问题请教\n1. 为什么方法参数用包装类型，不担心传 null 的问题吗？是否用基本类型更好一点，这里有什么权衡吗？\n2. 方法参数用包装类型，代码里判断相等用 == 隐患可能较高，比如在 Emp 类里","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602647,"discussion_content":"1 主要权衡的是另一个层面的空值问题。数据库里有整型空字段的话，正好可以和程序里包装类型的null对应。如果用基本类型，就要用一个特殊值代表空值。这么做的代价是略微影响性能。这只是我的习惯，你也可以不这么做。\n2 我的程序里有用==吗？麻烦指出是哪一处，可能我疏忽了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675831552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1703256,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","nickname":"6点无痛早起学习的和尚","note":"","ucode":"33A8A1CDA103F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":602741,"discussion_content":"问题2，在emp类的方法getSkill，return skills.stream() .filter(s -&gt; s.getSkillTypeId() == skillTypeId) .findAny();","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675840453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":602647,"ip_address":"北京","group_id":0},"score":602741,"extra":""}]}]},{"had_liked":false,"id":365982,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1673275143,"is_pvip":false,"replies":[{"id":133765,"content":"1. 没有特殊原因，是个笔误，谢谢捉虫，我回头改过来 ：）\n2. 这一步先在内存操作，后面课程会进一步把内存中的数据保存到数据库。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674957726,"ip_address":"广东","comment_id":365982,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"两个疑问：\n\n1. skill 表中 Level 首字母是大写，是有特殊原因吗（没有见到其他的大写字母）？\n\n2. 聚合根对非聚合根的封装示例代码中操作 skills 相关的 3 个方法（getSkill、getSkills、addSkill）都是操作内存数据，\n不会持久化到数据库，服务一重启，所有员工的技能都没了，这里只是展示一下“对象关联”的写法吗？\n\n```java\npublic class Emp extends AuditableEntity {\n    &#47;&#47; other fields ...\n    \n    private List&lt;Skill&gt; skills;              &#47;&#47; 读写\n\n    &#47;&#47; constructors and other getters and setters ...\n\n    public Optional&lt;Skill&gt; getSkill(Long skillTypeId) {\n        return skills.stream()\n                .filter(s -&gt; s.getSkillTypeId() == skillTypeId)\n                .findAny();\n    }\n    \n    public List&lt;Skill&gt; getSkills() {\n        return Collections.unmodifiableList(skills);\n    }\n    \n    void addSkill(Long skillTypeId, SkillLevel level\n                  , int duration, Long userId) {\n        Skill newSkill = new Skill(tenantId, skillTypeId\n                  , LocalDateTime.now(), userId);\n        newSkill.setLevel(level);\n        newSkill.setDuration(duration);\n\n        skills.add(newSkill);\n    }\n\n    &#47;&#47; 对 experiences、postCodes 进行类似的处理 ...\n    \n}\n```","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600908,"discussion_content":"1. 没有特殊原因，是个笔误，谢谢捉虫，我回头改过来 ：）\n2. 这一步先在内存操作，后面课程会进一步把内存中的数据保存到数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674957726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":600922,"discussion_content":"理解了，谢谢钟老师！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674961238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":600908,"ip_address":"浙江","group_id":0},"score":600922,"extra":""}]},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600923,"discussion_content":"aoe同学，第一个问题已经修改了，谢谢反馈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674961681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"discussion":{"id":601052,"discussion_content":"哈哈，不客气","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675030290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":600923,"ip_address":"浙江","group_id":0},"score":601052,"extra":""}]}]},{"had_liked":false,"id":365913,"user_name":"bin","can_delete":false,"product_type":"c1","uid":1047442,"ip_address":"广东","ucode":"F540DADF3AAD87","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/92/4de0c05c.jpg","comment_is_top":false,"comment_ctime":1673226716,"is_pvip":false,"replies":[{"id":133296,"content":"这里没有把skill和experience建模为值对象，因为允许修改。另一方面，值对象也是可以而且应该有业务规则，等下一部分详细讲值对象的时候，再细聊。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673238721,"ip_address":"广东","comment_id":365913,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"对于Emp这个聚合根来说，skills和experiences是实体还是值对象？看着像值对象，但是它们又有各自的业务规则。","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598955,"discussion_content":"这里没有把skill和experience建模为值对象，因为允许修改。另一方面，值对象也是可以而且应该有业务规则，等下一部分详细讲值对象的时候，再细聊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673238721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365808,"user_name":"小鱼儿吐泡泡","can_delete":false,"product_type":"c1","uid":1031710,"ip_address":"广东","ucode":"2B4AA532B2B066","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/1e/94886200.jpg","comment_is_top":false,"comment_ctime":1673062640,"is_pvip":false,"replies":[{"id":133269,"content":"关于您的第一个问题，答案是CQRS，将在第三个迭代讨论。\n关于您的第二个问题，在后面的课程里有一个方法对差异进行持久化，确实会增加些工作量。在性能不太敏感的场景，全部持久化也可以考虑。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673091357,"ip_address":"广东","comment_id":365808,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1. 我理解是类对象之间的关系； =》 之前文中提到UML图， 表示就是类之间关系\n2.  性能\n\n对于思考题2，我有个疑问？\n1. 假设现在有个界面，需要查询所有的员工列表，那么需要加载出整个页相关的员工聚合吗？ 这会涉及很多表的读写，是否真的有必要？一定要符合DDD的模式？或者有什么更好的方式吗？\n\n2.  对于聚合来讲，这个是事务操作的基本单位； 比如说我要添加技能，持久化时\n- 全部持久化； 性能较差\n- 仅持久化差异【技能】； ==》 性能较好，但是需要增加很多工作量\n\n希望老师帮忙解答下？ 实际落地中怎么取舍？\n感觉实际DDD落地时，对于非JAVA项目，落地需要很多额外的工具支持，或者特定化开发","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598800,"discussion_content":"关于您的第一个问题，答案是CQRS，将在第三个迭代讨论。\n关于您的第二个问题，在后面的课程里有一个方法对差异进行持久化，确实会增加些工作量。在性能不太敏感的场景，全部持久化也可以考虑。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1673091358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074736,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/30/ce2cc535.jpg","nickname":"小5","note":"","ucode":"F99936F37D04E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598773,"discussion_content":"对于这个问题，《如何落地业务建模》的04节课有专门分析，可以参考下。我的理解就是使用关联对象（接口或抽象）去更好更贴切表达领域概念， 而具体的实现则是灵活多变的。文中举例说明了分页的问题怎么处理，原文有代码示例，更容易理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1673085083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1887261,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/cc/1d/3c0272a1.jpg","nickname":"abc🙂","note":"","ucode":"FCF2B9091D161B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1074736,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/30/ce2cc535.jpg","nickname":"小5","note":"","ucode":"F99936F37D04E4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598910,"discussion_content":"徐老师提出的关联对象，简直完美解决此类顾虑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673203817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598773,"ip_address":"福建","group_id":0},"score":598910,"extra":""}]}]},{"had_liked":false,"id":392895,"user_name":"樱花","can_delete":false,"product_type":"c1","uid":1057456,"ip_address":"广东","ucode":"432F43127D847A","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/b0/050676f5.jpg","comment_is_top":false,"comment_ctime":1722080576,"is_pvip":false,"replies":[{"id":143642,"content":"几个好处：\n1. 在概念上，非聚合根对象是聚合的一部分，聚合根则代表了这个聚合，用聚合根（所在的包）来封装创建的逻辑比较“自然”。\n2. 聚合所在的包封装创建逻辑，一方面对外界隐藏创建逻辑的复杂性，另一方面，切断了一切其他胡乱创建非聚合根对象的可能\n3. 如果在包外创建非聚合根对象，可能需要访问聚合根内部的某些属性，而这些属性本来应该是隐藏的。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731405811,"ip_address":"广东","comment_id":392895,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"理论上，封装不可变性只要堵住非聚合根的写接口即可，为啥整个非聚合根的对象在包外都不能创建呢？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653719,"discussion_content":"几个好处：\n1. 在概念上，非聚合根对象是聚合的一部分，聚合根则代表了这个聚合，用聚合根（所在的包）来封装创建的逻辑比较“自然”。\n2. 聚合所在的包封装创建逻辑，一方面对外界隐藏创建逻辑的复杂性，另一方面，切断了一切其他胡乱创建非聚合根对象的可能\n3. 如果在包外创建非聚合根对象，可能需要访问聚合根内部的某些属性，而这些属性本来应该是隐藏的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731405811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392412,"user_name":"Geek_0052b7","can_delete":false,"product_type":"c1","uid":3906776,"ip_address":"重庆","ucode":"47D3222FD6F6B4","user_header":"","comment_is_top":false,"comment_ctime":1720855432,"is_pvip":false,"replies":[{"id":143660,"content":"笔误，应该是public, 由application service 调用。感谢发现错误！","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731484553,"ip_address":"广东","comment_id":392412,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"addSkill 这个方法，你写成包访问权限，这个谁来调用？领域服务嘛？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653856,"discussion_content":"笔误，应该是public, 由application service 调用。感谢发现错误！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731484554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384237,"user_name":"打码的土豆","can_delete":false,"product_type":"c1","uid":1395211,"ip_address":"浙江","ucode":"33B8ED2BFE0752","user_header":"https://static001.geekbang.org/account/avatar/00/15/4a/0b/775b0a98.jpg","comment_is_top":false,"comment_ctime":1700568265,"is_pvip":false,"replies":[{"id":140485,"content":"您说的pill输入skill列表具体指什么？","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1702803170,"ip_address":"广东","comment_id":384237,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"这里的skill的构造方法和setter方法都是包级别私有，那如果需要批量输入skill列表，emp里需要怎么处理","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633927,"discussion_content":"您说的pill输入skill列表具体指什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702803170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384109,"user_name":"打码的土豆","can_delete":false,"product_type":"c1","uid":1395211,"ip_address":"浙江","ucode":"33B8ED2BFE0752","user_header":"https://static001.geekbang.org/account/avatar/00/15/4a/0b/775b0a98.jpg","comment_is_top":false,"comment_ctime":1700309043,"is_pvip":false,"replies":[{"id":140484,"content":"如果是包级，应用层就无法修改emp了","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1702803089,"ip_address":"广东","comment_id":384109,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"为什么emp对象的set方法是public，不应该也是包级别吗","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633926,"discussion_content":"如果是包级，应用层就无法修改emp了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702803089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382843,"user_name":"Geek1560","can_delete":false,"product_type":"c1","uid":2028949,"ip_address":"上海","ucode":"5F27A28B8002E6","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/95/a362f01b.jpg","comment_is_top":false,"comment_ctime":1698114590,"is_pvip":false,"replies":[{"id":139708,"content":"可以这样： anEmp.getSkill(skillTypeId).getName(). 这时并没有对skill.getName()封装，但还是通过了聚合根。但在有必要的时候，也可以封装。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1699079140,"ip_address":"广东","comment_id":382843,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"聚合外部的对象对聚合内对象的读也必须通过聚合根来访问么？这样会不会比较繁琐，比如要读Skill的名字，也必须在聚合根中写一个方法getSkillName，然后封装skill.getName方法么","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630937,"discussion_content":"可以这样： anEmp.getSkill(skillTypeId).getName(). 这时并没有对skill.getName()封装，但还是通过了聚合根。但在有必要的时候，也可以封装。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699079140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371884,"user_name":"黄旗锋_APP小程序H5开发","can_delete":false,"product_type":"c1","uid":2949144,"ip_address":"浙江","ucode":"0B5B88A345F236","user_header":"https://static001.geekbang.org/account/avatar/00/2d/00/18/0a611c6b.jpg","comment_is_top":false,"comment_ctime":1680487121,"is_pvip":false,"replies":[{"id":135700,"content":"是这个道理。你这个“黑科技”的说法有意思 ：）","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1680533678,"ip_address":"广东","comment_id":371884,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"当然，直接通过技能对象，也能对一条新技能是否重复做校验，就是通过员工ID查找他的所有技能，然后做判断。但是从面向对象的角度来说，这是违反我们的认知的，因为这样的行为，在现实的生活中是不存在的。现实的世界中，我们可以通过一份档案去记录某个人的技能，判断这个人的技能是否重复的时候，肯定是去翻看一下他的文档，再做判断，而不可能在大量的文档中只看技能这一栏，找到所有的技能后，再看是不是某个人的，再做大量的分析。虽然机器能比较轻松地为我们做到（其实有些也不用轻松，当数据大特别大的时候），但是却完全违反了常识，有点像使用黑科技手段，我们的软件的混乱，就是因为大量地使用了黑科技。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612148,"discussion_content":"是这个道理。你这个“黑科技”的说法有意思 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680533678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2038027,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/19/0b/1c4ebf1e.jpg","nickname":"金山💰","note":"","ucode":"1FFBC100873EED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621909,"discussion_content":"现实的世界中，我们可以通过一份档案去记录某个人的技能，判断这个人的技能是否重复的时候，肯定是去翻看一下他的文档，再做判断，而不可能在大量的文档中只看技能这一栏，找到所有的技能后，再看是不是某个人的，再做大量的分析。虽然机器能比较轻松地为我们做到（其实有些也不用轻松，当数据大特别大的时候）\n\n我有点好奇，因为其实不管是不是用DDD我们都是用这样去设计我们的数据库表结构的，我就算不是用DDD，我平常也是通过员工的ID去查该员工对应的技能，不是吗？\n\n然后钟老师，关于技能不能重复这个业务规则，我觉得用技术的手段就可以解决啊，加上一个empID，skillTypeID 的组合唯一索引，就不可能会重复。不是吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687765427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369888,"user_name":"Marx","can_delete":false,"product_type":"c1","uid":1029143,"ip_address":"上海","ucode":"1506FEA531551E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/17/0b5aad57.jpg","comment_is_top":false,"comment_ctime":1678098172,"is_pvip":false,"replies":[{"id":134845,"content":"后面的课会讲","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678119093,"ip_address":"广东","comment_id":369888,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"addSkill()怎么持久化？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607820,"discussion_content":"后面的课会讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678119094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1094478,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/4e/5f22b09d.jpg","nickname":"marker","note":"","ucode":"DDBF1CD83665C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618830,"discussion_content":"抽象到持久层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684594721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369129,"user_name":"zenk","can_delete":false,"product_type":"c1","uid":1013669,"ip_address":"上海","ucode":"B235D5EBCF49BC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/a5/c5ae871d.jpg","comment_is_top":false,"comment_ctime":1677131649,"is_pvip":false,"replies":[{"id":134800,"content":"不错","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677939864,"ip_address":"广东","comment_id":369129,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"第一题：类表示的是很多类似的对象，如果是类，就变成了聚合很多类似的对象，所以是对象\n第二题：性能和与领域模型一致之间取平衡","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607563,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677939864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368550,"user_name":"py","can_delete":false,"product_type":"c1","uid":1496577,"ip_address":"上海","ucode":"2372522D715419","user_header":"https://static001.geekbang.org/account/avatar/00/16/d6/01/2448b4a9.jpg","comment_is_top":false,"comment_ctime":1676442925,"is_pvip":false,"replies":[{"id":134252,"content":"第一题，其实聚合是对象之间的关系，你再想想？第二题没问题。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1676509024,"ip_address":"广东","comment_id":368550,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"1. 类的关系\n2. 为了考虑性能，所以在小范围内 尽量用对象","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604928,"discussion_content":"第一题，其实聚合是对象之间的关系，你再想想？第二题没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676509024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367253,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"北京","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1675071274,"is_pvip":true,"replies":[{"id":135199,"content":"是的，这里的聚合(aggregate)指的是DDD中的一种模式，和UML中说的聚合（aggregation）不完全是一个概念。您看一下《DDD》原书的目录，凡是讲模式的，标题都有“模式：”的字样。英文版中，模式的章节标题都是全大写的，其他标题是大小写混合的。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678979518,"ip_address":"广东","comment_id":367253,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"领域模型给业务人员看用中文，实现模型给开发人员参考用英文。\n\n看到了那个 AuditableEntity 的类，这个以后可以在自己的项目中使用。\n\n”聚合外部对象对非聚合根对象只能读，不能写，必须通过聚合根才能对非根对象进行访问“\n\n对于思考题，\n\n1. 我认为聚合是类之间的关系，比如员工和经验，新员工可以没有经验。\n2. 聚合内部使用对象导航，因为聚合内部的调用相对频繁；而聚合间的调用相对少一些，可以采用 ID 导航加上懒加载的方式（其实如果数据量比较小的情况，也可以都放到内存里面）。\n\n看了留言，聚合应该是对象之间的关系，感觉主要是指只有对象之间的聚合才有实际意义。\n\n另外，这里的”聚合“说的是一种模式 ？An AGGREGATES is a cluster of associated objects that we treat as a unit for the purpose of data changes.","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609467,"discussion_content":"是的，这里的聚合(aggregate)指的是DDD中的一种模式，和UML中说的聚合（aggregation）不完全是一个概念。您看一下《DDD》原书的目录，凡是讲模式的，标题都有“模式：”的字样。英文版中，模式的章节标题都是全大写的，其他标题是大小写混合的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678979518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365819,"user_name":"阿昕","can_delete":false,"product_type":"c1","uid":1012906,"ip_address":"广东","ucode":"F3AD093B68E074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","comment_is_top":false,"comment_ctime":1673081199,"is_pvip":false,"replies":[{"id":133272,"content":"两个问题都答得不错，谢谢抓虫👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673138526,"ip_address":"广东","comment_id":365819,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"1.我认为聚合是对象之间的关系，从对象行为、属性来确定聚合关系更为合理；\n2.聚合内部使用对象导航，是因为大部分业务场景需要使用到关联属性，这样更为方便；聚合之间由应用层编排的时候，根据ID导航获取即可；\n\nPS，发现一个小问题，Emp类中属性orgId的类型应该是Long","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598834,"discussion_content":"两个问题都答得不错，谢谢抓虫👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673138526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598966,"discussion_content":"感谢阿昕同学反馈，代码指正问题已修复，刷新可见。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673241490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365804,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"广东","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1673059339,"is_pvip":true,"replies":[{"id":133270,"content":"聚合应该是对象之间的关系，您可以再想想。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673091430,"ip_address":"广东","comment_id":365804,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"1.类之间的关系。聚合根本身维护对象之间的关系，而聚合内对象的访问控制通过包级私有权限控制，需要通过将类分包进行实现\n\n2.单体架构-&gt;微服务架构的演变时，聚合是最小粒度的服务，后续拆分时避免与其他服务实体对象直接耦合，也能够快速过度实现服务间Rpc的调用","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598801,"discussion_content":"聚合应该是对象之间的关系，您可以再想想。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673091430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365802,"user_name":"FiRerOUNd","can_delete":false,"product_type":"c1","uid":1315438,"ip_address":"广东","ucode":"571CB6565F9713","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/6e/3a0b4930.jpg","comment_is_top":false,"comment_ctime":1673054851,"is_pvip":false,"replies":[{"id":133268,"content":"所以，聚合到底是类之间的关系还是对象之间的关系呢？","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673091165,"ip_address":"广东","comment_id":365802,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"回答一下第一个问题。聚合的目的是为了保护业务规则，是一个逻辑边界。例如，员工A和员工B的工作经验B并不能构成一个聚合。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598799,"discussion_content":"所以，聚合到底是类之间的关系还是对象之间的关系呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673091165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1315438,"avatar":"https://static001.geekbang.org/account/avatar/00/14/12/6e/3a0b4930.jpg","nickname":"FiRerOUNd","note":"","ucode":"571CB6565F9713","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":598970,"discussion_content":"对象间的关系","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1673247205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598799,"ip_address":"北京","group_id":0},"score":598970,"extra":""}]}]},{"had_liked":false,"id":365830,"user_name":"Geek_73d5d0","can_delete":false,"product_type":"c1","uid":3293530,"ip_address":"四川","ucode":"C6315DE63FCC85","user_header":"","comment_is_top":false,"comment_ctime":1673097192,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"好的","like_count":0}]}