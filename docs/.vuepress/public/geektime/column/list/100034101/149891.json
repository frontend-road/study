{"id":149891,"title":"加餐 | 汇编代码编程与栈帧管理","content":"<p>在<a href=\"https://time.geekbang.org/column/article/147854\">22讲</a>中，我们侧重讲解了汇编语言的基础知识，包括构成元素、汇编指令和汇编语言中常用的寄存器。学习完基础知识之后，你要做的就是多加练习，和汇编语言“混熟”。小窍门是查看编译器所生成的汇编代码，跟着学习体会。</p><p>不过，可能你是初次使用汇编语言，对很多知识点还会存在疑问，比如：</p><ul>\n<li>在汇编语言里调用函数（过程）时，传参和返回值是怎么实现的呢？</li>\n<li><a href=\"https://time.geekbang.org/column/article/146635\">21讲</a>中运行期机制所讲的栈帧，如何通过汇编语言实现？</li>\n<li>条件语句和循环语句如何实现？</li>\n<li>……</li>\n</ul><p>为此，我策划了一期加餐，针对性地讲解这样几个实际场景，希望帮你加深对汇编语言的理解。</p><h2>示例1：过程调用和栈帧</h2><p>这个例子涉及了一个过程调用（相当于C语言的函数调用）。过程调用是汇编程序中的基础结构，它涉及到<strong>栈帧的管理、参数的传递</strong>这两个很重要的知识点。</p><p>假设我们要写一个汇编程序，实现下面C语言的功能：</p><pre><code>/*function-call1.c */\n#include &lt;stdio.h&gt;\nint fun1(int a, int b){\n    int c = 10;\n    return a+b+c;\n}\n\nint main(int argc, char *argv[]){\n    printf(&quot;fun1: %d\\n&quot;, fun1(1,2));\n    return 0;\n} \n</code></pre><p>fun1函数接受两个整型的参数：a和b，来看看这两个参数是怎样被传递过去的，手写的汇编代码如下：</p><pre><code># function-call1-craft.s 函数调用和参数传递\n    # 文本段,纯代码\n    .section    __TEXT,__text,regular,pure_instructions\n\n_fun1:\n    # 函数调用的序曲,设置栈指针\n    pushq   %rbp           # 把调用者的栈帧底部地址保存起来   \n    movq    %rsp, %rbp     # 把调用者的栈帧顶部地址,设置为本栈帧的底部\n\n    subq    $4, %rsp       # 扩展栈\n\n    movl    $10, -4(%rbp)  # 变量c赋值为10，也可以写成 movl $10, (%rsp)\n\n    # 做加法\n    movl    %edi, %eax     # 第一个参数放进%eax\n    addl    %esi, %eax     # 把第二个参数加到%eax,%eax同时也是存放返回值的寄存器\n    addl    -4(%rbp), %eax # 加上c的值\n\n    addq    $4, %rsp       # 缩小栈\n\n    # 函数调用的尾声,恢复栈指针为原来的值\n    popq    %rbp           # 恢复调用者栈帧的底部数值\n    retq                   # 返回\n\n    .globl  _main          # .global伪指令让_main函数外部可见\n_main:                                  ## @main\n    \n    # 函数调用的序曲,设置栈指针\n    pushq   %rbp           # 把调用者的栈帧底部地址保存起来  \n    movq    %rsp, %rbp     # 把调用者的栈帧顶部地址,设置为本栈帧的底部\n    \n    # 设置第一个和第二个参数,分别为1和2\n    movl    $1, %edi\n    movl    $2, %esi\n\n    callq   _fun1                # 调用函数\n\n    # 为pritf设置参数\n    leaq    L_.str(%rip), %rdi   # 第一个参数是字符串的地址\n    movl    %eax, %esi           # 第二个参数是前一个参数的返回值\n\n    callq   _printf              # 调用函数\n\n    # 设置返回值。这句也常用 xorl %esi, %esi 这样的指令,都是置为零\n    movl    $0, %eax\n    \n    # 函数调用的尾声,恢复栈指针为原来的值\n    popq    %rbp         # 恢复调用者栈帧的底部数值\n    retq                 # 返回\n\n    # 文本段,保存字符串字面量                                  \n    .section    __TEXT,__cstring,cstring_literals\nL_.str:                                 ## @.str\n    .asciz  &quot;Hello World! :%d \\n&quot;\n</code></pre><p><strong>需要注意，</strong>手写的代码跟编译器生成的可能有所不同，但功能是等价的，代码里有详细的注释，你肯定能看明白。</p><p><strong>借用这个例子，我们讲一下栈的管理。</strong>在示例代码的两个函数里，有这样的固定结构：</p><!-- [[[read_end]]] --><pre><code> # 函数调用的序曲,设置栈指针\n    pushq\t%rbp\t     # 把调用者的栈帧底部地址保存起来  \n    movq\t%rsp, %rbp   # 把调用者的栈帧顶部地址，设置为本栈帧的底部\n\n    ...\n\n    # 函数调用的尾声,恢复栈指针为原来的值\n    popq\t%rbp         # 恢复调用者栈帧的底部数值\n</code></pre><p>在C语言生成的代码中，一般用%rbp寄存器指向栈帧的底部，而%rsp则指向栈帧的顶部。<strong>栈主要是通过push和pop这对指令来管理的：</strong>push把操作数压到栈里，并让%rsp指向新的栈顶，pop把栈顶数据取出来，同时调整%rsp指向新的栈顶。</p><p>在进入函数的时候，用pushq %rbp指令把调用者的栈帧地址存起来（根据调用约定保护起来），而把调用者的栈顶地址设置成自己的栈底地址，它等价于下面两条指令，你可以不用push指令，而是运行下面两条指令：</p><pre><code>subq $8, %rsp        #把%rsp的值减8，也就是栈增长8个字节，从高地址向低地址增长\nmovq %rbp, (%rsp)    #把%rbp的值写到当前栈顶指示的内存位置\n</code></pre><p>而在退出函数前，调用了popq %rbp指令。它恢复了之前保存的栈指针的地址，等价于下面两条指令：</p><pre><code>movq (%rsp), %rbp    #把栈顶位置的值恢复回%rbp，这是之前保存在栈里的值。\naddq $8, %rsp        #把%rsp的值加8，也就是栈减少8个字节\n</code></pre><p>上述过程画成一张直观的图，表示如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/45/df/450388ce0b3189fbf263da402bc447df.jpg?wh=1142*562\" alt=\"\"></p><p>上面每句指令执行以后，我们看看%rbp和%rsp值的变化：</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/6a/1beeb1ded99922d15cc98e7cc3359a6a.jpg?wh=1142*576\" alt=\"\"></p><p>再来看看使用局部变量的时候会发生什么：</p><pre><code>    subq    $4, %rsp       # 扩展栈\n\n    movl    $10, -4(%rbp)  # 变量c赋值为10，也可以写成 movl $10, (%rsp)\n\n    ...\n\n    addq    $4, %rsp       # 缩小栈\n</code></pre><p>我们通过减少%rsp的值，来扩展栈，然后在扩展出来的4个字节的位置上写入整数，这就是变量c的值。在返回函数前，我们通过addq $4, %rsp再把栈缩小。这个过程如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/94/4a/94cf6dbfae7169f6ef01a09e804b7c4a.jpg?wh=1142*633\" alt=\"\"></p><p>在这个例子中，我们通过移动%rsp指针来改变帧的大小。%rbp和%rsp之间的空间就是当前栈帧。而过程调用和退出过程，分别使用call指令和ret指令。“callq  _fun1”是调用_fun1过程，这个指令相当于下面两句代码，它用到了栈来保存返回地址：</p><pre><code>pushq %rip  # 保存下一条指令的地址，用于函数返回继续执行\njmp _fun1   # 跳转到函数_fun1\n</code></pre><p>_fun1函数用ret指令返回，它相当于：</p><pre><code>popq %rip   #恢复指令指针寄存器\njmp %rip\n</code></pre><p>上一讲，我提到，在X86-64架构下，新的规范让程序可以访问栈顶之外128字节的内存，所以，我们甚至不需要通过改变%rsp来分配栈空间，而是直接用栈顶之外的空间。</p><p>上面的示例程序，你可以用as命令生成可执行程序，运行一下看看，然后试着做一下修改，逐步熟悉汇编程序的编写思路。</p><h2>示例2：同时使用寄存器和栈来传参</h2><p>上一个示例中，函数传参只使用了两个参数，这时是通过两个寄存器传递参数的。这次，我们使用8个参数，来看看通过寄存器和栈传参这两种不同的机制。</p><p>在X86-64架构下，有很多的寄存器，所以程序调用约定中规定尽量通过寄存器来传递参数，而且，只要参数不超过6个，都可以通过寄存器来传参，使用的寄存器如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/53/4d066afb9834f2a602bca2010e6edb53.jpg?wh=1142*509\" alt=\"\"></p><p>超过6个的参数的话，我们要再加上栈来传参：</p><p><img src=\"https://static001.geekbang.org/resource/image/45/89/45587ab64c83ea52f9d1fd3fedc6b189.jpg?wh=1142*594\" alt=\"\"></p><p>根据程序调用约定的规定，参数1～6是放在寄存器里的，参数7和8是放到栈里的，先放参数8，再放参数7。</p><p>在23讲，我会带你为下面的一段playscript程序生成汇编代码：</p><pre><code>//asm.play\nint fun1(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8){\n    int c = 10; \n    return x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + c;\n}\n\nprintln(&quot;fun1:&quot; + fun1(1,2,3,4,5,6,7,8));\n</code></pre><p>现在，我们可以按照调用约定，先手工编写一段实现相同功能的汇编代码：</p><pre><code># function-call2-craft.s 函数调用和参数传递\n    # 文本段,纯代码\n    .section    __TEXT,__text,regular,pure_instructions\n\n_fun1:\n    # 函数调用的序曲,设置栈指针\n    pushq   %rbp           # 把调用者的栈帧底部地址保存起来   \n    movq    %rsp, %rbp     # 把调用者的栈帧顶部地址,设置为本栈帧的底部\n\n    movl    $10, -4(%rbp)  # 变量c赋值为10,也可以写成 movl $10, (%rsp)\n\n    # 做加法\n    movl    %edi, %eax     # 第一个参数放进%eax\n    addl    %esi, %eax     # 加参数2\n    addl    %edx, %eax     # 加参数3\n    addl    %ecx, %eax     # 加参数4\n    addl    %r8d, %eax     # 加参数5\n    addl    %r9d, %eax     # 加参数6\n    addl    16(%rbp), %eax  # 加参数7\n    addl    24(%rbp), %eax  # 加参数8\n    \n    addl    -4(%rbp), %eax # 加上c的值\n\n    # 函数调用的尾声,恢复栈指针为原来的值\n    popq    %rbp           # 恢复调用者栈帧的底部数值\n    retq                   # 返回\n\n    .globl  _main          # .global伪指令让_main函数外部可见\n_main:                                  ## @main\n    \n    # 函数调用的序曲,设置栈指针\n    pushq   %rbp           # 把调用者的栈帧底部地址保存起来  \n    movq    %rsp, %rbp     # 把调用者的栈帧顶部地址,设置为本栈帧的底部\n    \n    subq    $16, %rsp      # 这里是为了让栈帧16字节对齐，实际使用可以更少\n\n    # 设置参数\n    movl    $1, %edi     # 参数1\n    movl    $2, %esi     # 参数2\n    movl    $3, %edx     # 参数3\n    movl    $4, %ecx     # 参数4\n    movl    $5, %r8d     # 参数5\n    movl    $6, %r9d     # 参数6\n    movl    $7, (%rsp)   # 参数7\n    movl    $8, 8(%rsp)  # 参数8\n\n    callq   _fun1                # 调用函数\n\n    # 为pritf设置参数\n    leaq    L_.str(%rip), %rdi   # 第一个参数是字符串的地址\n    movl    %eax, %esi           # 第二个参数是前一个参数的返回值\n\n    callq   _printf              # 调用函数\n\n    # 设置返回值。这句也常用 xorl %esi, %esi 这样的指令,都是置为零\n    movl    $0, %eax\n\n    addq    $16, %rsp    # 缩小栈\n    \n    # 函数调用的尾声,恢复栈指针为原来的值\n    popq    %rbp         # 恢复调用者栈帧的底部数值\n    retq                 # 返回\n\n    # 文本段,保存字符串字面量                                  \n    .section    __TEXT,__cstring,cstring_literals\nL_.str:                                 ## @.str\n    .asciz  &quot;fun1 :%d \\n&quot;\n</code></pre><p>用as命令，把这段汇编代码生成可执行文件，运行后会输出结果：“fun1: 46”。</p><pre><code>as functio-call2-craft.s -o function-call2\n./function-call2\n</code></pre><p>这段程序虽然有点儿长，但思路很清晰，比如，每个函数（过程）都有固定的结构。7～10行，我叫做序曲，是设置栈帧的指针；25~26行，我叫做尾声，是恢复栈底指针并返回；13~22行是做一些计算，还要为本地变量在栈里分配一些空间。</p><p><strong>我建议你读代码的时候，</strong>对照着每行代码的注释，弄清楚这条代码所做的操作，以及相关的寄存器和内存中值的变化，脑海里有栈帧和寄存器的直观的结构，就很容易理解清楚这段代码了。</p><p>除了函数调用以外，我们在编程时经常使用循环语句和if语句，它们转换成汇编是什么样子呢？我们来研究一下，首先看看while循环语句。</p><h2>示例3：循环语句的汇编码解析</h2><p>看看下面这个C语言的语句：</p><pre><code>void fun1(int a){\n    while (a &lt; 10){\n        a++;\n    }\n}\n</code></pre><p>我们要使用\"gcc -S ifstmt.c -o ifstmt.s\"命令，把它转换成汇编语句（注意不要带优化参数）：</p><pre><code> .section    __TEXT,__text,regular,pure_instructions\n    .macosx_version_min 10, 15\n    .globl  _fun1                   ## -- Begin function fun1\n    .p2align    4, 0x90\n_fun1:                                  ## @fun1\n    .cfi_startproc\n## %bb.0:\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset %rbp, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register %rbp\n    movl    %edi, -4(%rbp)   #把参数a放到栈里\nLBB0_1:                      ## =&gt;This Inner Loop Header: Depth=1\n    cmpl    $10, -4(%rbp)    #比较参数1和立即数10,设置eflags寄存器\n    jge LBB0_3               #如果大于等于，则跳转到LBB0_3基本块\n## %bb.2:                    ##   in Loop: Header=BB0_1 Depth=1\n    movl    -4(%rbp), %eax   #这2行，是给a加1\n    addl    $1, %eax\n    movl    %eax, -4(%rbp)\n    jmp LBB0_1\nLBB0_3:\n    popq    %rbp\n    retq\n    .cfi_endproc\n                                        ## -- End function\n\n.subsections_via_symbols\n</code></pre><p>这段代码的15、16、21行是关键，我解释一下：</p><ul>\n<li>第15行，用cmpl指令，将%edi寄存器中的参数1（即C代码中的参数a）和立即数10做比较，比较的结果会设置EFLAGS寄存器中的相关位。</li>\n</ul><p>EFLAGS中有很多位，下图是<a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel公司手册</a>中对各个位的解释，有的指令会影响这些位的设置，比如cmp指令，有的指令会从中读取信息，比如16行的jge指令：</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/46/d79cff3bef9e77f825ed9866c5dd1146.jpg?wh=1142*892\" alt=\"\"></p><ul>\n<li>\n<p>第16行，jge指令。jge是“jump if greater or equal”的缩写，也就是当大于或等于的时候就跳转。大于等于是从哪知道的呢？就是根据EFLAGS中的某些位计算出来的。</p>\n</li>\n<li>\n<p>第21行，跳转到循环的开始。</p>\n</li>\n</ul><p>在这个示例中，我们看到了jmp（无条件跳转指令）和jge（条件跳转指令）两个跳转指令。条件跳转指令很多，它们分别是基于EFLAGS的状态位做不同的计算，判断是否满足跳转条件，看看下面这张表格：</p><p><img src=\"https://static001.geekbang.org/resource/image/ce/d5/ce52ac9632428550896ce20f958651d5.jpg?wh=1142*559\" alt=\"\"></p><p>表格中的跳转指令，是基于有符号的整数进行判断的，对于无符号整数、浮点数，还有很多其他的跳转指令。现在你应该体会到，汇编指令为什么这么多了。<strong>好在其助记符都是有规律的，可以看做英文缩写，所以还比较容易理解其含义。</strong></p><p><strong>另外我再强调一下，</strong>刚刚我让你生成汇编时，不要带优化参数，那是因为优化算法很“聪明”，它知道这个循环语句对函数最终的计算结果没什么用，就优化掉了。后面学优化算法时，你会理解这种优化机制。</p><p>不过这样做，也会有一个不好的影响，就是代码不够优化。比如这段代码把参数1拷贝到了栈里，在栈里做运算，而不是直接基于寄存器做运算，这样性能会低很多，这是没有做寄存器优化的结果。</p><h2>示例4：if语句的汇编码解析</h2><p>循环语句看过了，if语句如何用汇编代码实现呢？</p><p>看看下面这段代码：</p><pre><code>int fun1(int a){\n    if (a &gt; 10){\n        return 4;\n    }\n    else{\n        return 8;\n    }\n}\n</code></pre><p>把上面的C语言代码转换成汇编代码如下：</p><pre><code>   .section    __TEXT,__text,regular,pure_instructions\n    .macosx_version_min 10, 15\n    .globl  _fun1                   ## -- Begin function fun1\n    .p2align    4, 0x90\n_fun1:                                  ## @fun1\n    .cfi_startproc\n## %bb.0:\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset %rbp, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register %rbp\n    movl    %edi, -8(%rbp)\n    cmpl    $10, -8(%rbp)  #将参数a与10做比较\n    jle LBB0_2             #小于等于的话就调转到LBB0_2基本块\n## %bb.1:\n    movl    $4, -4(%rbp)   #否则就给a赋值为4\n    jmp LBB0_3\nLBB0_2:\n    movl    $8, -4(%rbp)   #给a赋值为8\nLBB0_3:\n    movl    -4(%rbp), %eax #设置返回值\n    popq    %rbp\n    retq\n    .cfi_endproc\n                                        ## -- End function\n\n.subsections_via_symbols\n</code></pre><p>了解了条件跳转指令以后，再理解上面的代码容易了很多。还是先做比较，设置EFLAGS中的位，然后做跳转。</p><h2>示例5：浮点数的使用</h2><p>之前我们用的例子都是采用整数，现在使用浮点数来做运算，看看会有什么不同。</p><p>看看下面这段代码：</p><pre><code>float fun1(float a, float b){\n    float c = 2.0;\n    return a + b + c;\n}\n</code></pre><p>使用-O2参数，把C语言的程序编译成汇编代码如下：</p><pre><code>  .section    __TEXT,__text,regular,pure_instructions\n    .macosx_version_min 10, 15\n    .section    __TEXT,__literal4,4byte_literals\n    .p2align    2               ## -- Begin function fun1\nLCPI0_0:\n    .long   1073741824              ## float 2 常量\n    .section    __TEXT,__text,regular,pure_instructions\n    .globl  _fun1\n    .p2align    4, 0x90\n_fun1:                                  ## @fun1\n    .cfi_startproc\n## %bb.0:\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset %rbp, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register %rbp\n    addss   %xmm1, %xmm0    #浮点数传参用XMM寄存器，加法用addss指令\n    addss   LCPI0_0(%rip), %xmm0  #把常量2.0加到xmm0上，xmm0保存返回值\n    popq    %rbp\n    retq\n    .cfi_endproc\n                                        ## -- End function\n\n.subsections_via_symbols\n</code></pre><p>这个代码的结构你应该熟悉了，栈帧的管理方式都是一样的，都要维护%rbp和%rsp。不一样的地方，有几个地方：</p><ul>\n<li>\n<p>传参。给函数传递浮点型参数，是要使用XMM寄存器。</p>\n</li>\n<li>\n<p>指令。浮点数的加法运算，使用的是addss指令，它用于对单精度的标量浮点数做加法计算，这是一个SSE1指令。SSE1是一组指令，主要是对单精度浮点数(比如C或Java语言中的float)进行运算的，而SSE2则包含了一些双精度浮点数（比如C或Java语言中的double）的运算指令。</p>\n</li>\n<li>\n<p>返回值。整型返回值是放在%eax寄存器中，而浮点数返回值是放在xmm0寄存器中的。调用者可以从这里取出来使用。</p>\n</li>\n</ul><h2>课程小结</h2><p>利用本节课的加餐，我带你把编程中常见的一些场景，所对应的汇编代码做了一些分析。你需要记住的要点如下：</p><ul>\n<li>\n<p>函数调用时，会使用寄存器传参，超过6个参数时，还要再加上栈，这都是遵守了调用约定。</p>\n</li>\n<li>\n<p>通过push、pop指令来使用栈，栈与%rbp和%rsp这两个指针有关。你可以图形化地记住栈的增长和回缩的过程。需要注意的是，是从高地址向低地址走，所以访问栈里的变量，都是基于%rbp来减某个值。使用%rbp前，要先保护起来，别破坏了调用者放在里面的值。</p>\n</li>\n<li>\n<p>循环语句和if语句的秘密在于比较指令和有条件跳转指令，它们都用到了EFLAGS寄存器。</p>\n</li>\n<li>\n<p>浮点数的计算要用到MMX寄存器，指令也有所不同。</p>\n</li>\n</ul><p>通过这次加餐，你会更加直观地了解汇编语言，接下来的课程中，我会带你尝试通过翻译AST自动生成这些汇编代码，让你直观理解编译器生成汇编码的过程。</p><h2>一课一思</h2><p>你了解到哪些地方会使用汇编语言编程？有没有一些比较有意思的场景？是否实现了一些普通高级语言难以实现的结果？欢迎在留言区分享你的经验。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":180581,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1582341495,"is_pvip":true,"replies":[{"id":"74177","content":"你总结得很细，很清晰。都可以画出一张脑图了！<br>这些技术细节，可以找到相应的技术规格文档去阅读，并获得更多你感兴趣的内容。课程里讲的，主要是Unix家族的系统约定。Windows系统可能会不同。但你总能找到相应的技术文档来找到这些约定。<br>进一步，你可以再寻找下面几个问题的答案：<br>1.为什么只要移动栈指针就能分配内存。应用程序的内存都是操作系统虚拟出来的，操作系统必须在你使用内存的时候，给你准备好真实的物理内存。对这个问题的回答就涉及一点操作系统的知识，我相信你能查到。<br>2.在栈里申请内存，相比在堆里相比内存，哪个更快？哪个容易导致内存碎片？哪个更有利于局部性？这两种内存申请方式各自的使用场景是什么？像Python这样的动态语言有可能使用栈吗？像Java这样的语言，在new一个对象的时候，有可能使用栈吗？<br>希望你能在寻找这些问题答案的时候，获得更多的收获。<br><br>或者，可能我会在第二季多少涉及这些内容。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585138236,"ip_address":"","comment_id":180581,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27352145271","product_id":100034101,"comment_content":"老师，通过今天学习有以下总结：<br>1. pushq 和 popq 虽然是单“参数”指令，但一个隐藏的“参数”就是 %rsp。<br>2. 通过移动 %rsp 指针来改变帧的大小。%rbp 和 %rsp 之间的空间就是当前栈帧。<br>3. 栈帧先进后出 （一个函数的相关 信息占用一帧）。或者栈帧二字 重点在帧上。%rbp 在函数调用时一次移动 一个栈帧的大小，**%rbp在整个函数执行期间是不变的**。<br>4. 函数内部访问 栈帧 可以使用 `-4(%rbp)`表示地址，表示%rbp 寄存器存储的地址减去4的地址。说白了，**栈帧内可以基于 (%rbp) 随机访问**，`+4(%rsp)`效果类似。<br>5. **%rsp并不总是指向真实的栈顶**：在 X86-64 架构下，新的规范让程序可以访问栈顶之外 128 字节的内存，所以，我们甚至不需要通过改变 %rsp 来分配栈空间，而是直接用栈顶之外的空间。比如栈帧大小是16，即·`(%rbp)-(%rsp) = 16`，可以在代码中直接使用 内存地址`-32(%rbp)`。但如果函数内 还会调用 其它函数，为了pushq&#47;popq 指令的正确性，编译器会为%rsp 设置正确的值使其 指向栈顶。<br>6. 除了callq&#47;pushq&#47;popq&#47;retq  指令操作%rsp外，函数执行期间，可以mov (%rsp)使其指向栈顶一步到位，(%rsp)也可以和(%rbp)挨着一步不动，\b也可以随着变量的分配慢慢移动。","like_count":6,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484721,"discussion_content":"你总结得很细，很清晰。都可以画出一张脑图了！\n这些技术细节，可以找到相应的技术规格文档去阅读，并获得更多你感兴趣的内容。课程里讲的，主要是Unix家族的系统约定。Windows系统可能会不同。但你总能找到相应的技术文档来找到这些约定。\n进一步，你可以再寻找下面几个问题的答案：\n1.为什么只要移动栈指针就能分配内存。应用程序的内存都是操作系统虚拟出来的，操作系统必须在你使用内存的时候，给你准备好真实的物理内存。对这个问题的回答就涉及一点操作系统的知识，我相信你能查到。\n2.在栈里申请内存，相比在堆里相比内存，哪个更快？哪个容易导致内存碎片？哪个更有利于局部性？这两种内存申请方式各自的使用场景是什么？像Python这样的动态语言有可能使用栈吗？像Java这样的语言，在new一个对象的时候，有可能使用栈吗？\n希望你能在寻找这些问题答案的时候，获得更多的收获。\n\n或者，可能我会在第二季多少涉及这些内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585138236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2718510,"avatar":"","nickname":"jack123","note":"","ucode":"873D0046EF39D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400770,"discussion_content":"1.在使用时，操作系统会把虚拟地址翻译成物理地址，一般是使用MMU，它是一个硬件，用于转换地址的\n2.栈比堆申请更快，因为栈在编译器期间就申请了，而堆是运行时malloc去分配的，还要管理垃圾回收。栈分配的物理空间是连续的，数据之间存在局部性，而堆未必，查询堆的链表可能花费更多的时间，但因为栈空间总是连续的，所以不可能有一个内存块从栈中弹出，而频繁malloc，free不同的空间大小，会造成内存空间的不连续，产生大量碎片\n3.栈主要用于存储方法内部的局部变量，比如基本的类型的变量数据和对象的引用，堆存放new出来的对象和全局变量比如static变量和，常量池比如字符串常量和const基本类型常量等\n4.Java的函数在传递new出来的引用时，可以使用栈，因为只是存储一个指针的值，Python动态语言的特性只是导致难以优化，但是栈空间依然是可以使用，比如Python每创建一个线程，会分配一部分栈空间，用于保存局部变量和返回值以及上下文。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633419105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1167046,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg","nickname":"sugar","note":"","ucode":"454538FF253B5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256422,"discussion_content":"这条评论和老师的回复太棒了，简直相当于又加了一小顿餐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588479190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147239,"user_name":"zKerry","can_delete":false,"product_type":"c1","uid":1497740,"ip_address":"","ucode":"9FB006D1A38D3F","user_header":"","comment_is_top":false,"comment_ctime":1572851081,"is_pvip":false,"replies":[{"id":"57524","content":"因为栈是从高地址向低地址延伸的。所以地址减的话，才是栈的增长。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573301230,"ip_address":"","comment_id":147239,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23047687561","product_id":100034101,"comment_content":"栈的扩大和缩小有点反直觉啊，为啥扩大是减，缩小是加","like_count":6,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473215,"discussion_content":"因为栈是从高地址向低地址延伸的。所以地址减的话，才是栈的增长。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573301230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142560,"user_name":"初心丶可曾記","can_delete":false,"product_type":"c1","uid":1140481,"ip_address":"","ucode":"232DBFB8C3AC00","user_header":"https://static001.geekbang.org/account/avatar/00/11/67/01/a5bb9c92.jpg","comment_is_top":false,"comment_ctime":1571395810,"is_pvip":false,"replies":[{"id":"57601","content":"回头我更新一版图，让图中的箭头指向格子而不是线，这样更加没有歧义。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573378142,"ip_address":"","comment_id":142560,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18751264994","product_id":100034101,"comment_content":"图中的%rbp应该是指向【上一帧的%rbp的值】的下方红线部位，不应该是【返回地址】的下方红线","like_count":5,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471176,"discussion_content":"回头我更新一版图，让图中的箭头指向格子而不是线，这样更加没有歧义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573378142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812721,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ZutpibYYahKIaIwuc84oBD30CZ7ZGLXHwZjm4zHG6ynaGxKqIzqrTGMQVr3CauAOcOic5MnzXnR0CYiaicP7bqkFicg/132","nickname":"thomas1994","note":"","ucode":"F94DBBFF6D785F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217263,"discussion_content":"%rbp 和%rsp不用改指向同一个地方吧？  哪位能帮忙说明下，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585534407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317325,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1634741173,"is_pvip":false,"replies":[{"id":"115154","content":"昵称很赞！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1634903031,"ip_address":"","comment_id":317325,"utype":1}],"discussion_count":2,"race_medal":4,"score":"5929708469","product_id":100034101,"comment_content":"不错，有收获","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528765,"discussion_content":"昵称很赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634903031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407064,"discussion_content":"🐕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634903700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180202,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1582208684,"is_pvip":true,"replies":[{"id":"74207","content":"对的。栈顶指针重新赋值了，栈顶外的内存就抛弃了。这就是一种很自动的内存管理机制，比在堆里申请和释放内存要简单。<br>所以说在栈里声明的本地变量，它的生存期跟作用域是一致的（闭包除外）。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585146531,"ip_address":"","comment_id":180202,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877175980","product_id":100034101,"comment_content":"有个疑惑点：函数调用返回时，一个函数的栈帧是作为一整个单位被丢弃掉嘛？","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484562,"discussion_content":"对的。栈顶指针重新赋值了，栈顶外的内存就抛弃了。这就是一种很自动的内存管理机制，比在堆里申请和释放内存要简单。\n所以说在栈里声明的本地变量，它的生存期跟作用域是一致的（闭包除外）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585146531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147902,"user_name":"风","can_delete":false,"product_type":"c1","uid":1444483,"ip_address":"","ucode":"E1CE0825AAF805","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","comment_is_top":false,"comment_ctime":1572918163,"is_pvip":false,"replies":[{"id":"57521","content":"没错。用两个寄存器来标记栈桢，确实有点浪费。实际上是可以优化掉的。<br>如果你用gcc编译的话，可以使用-fomit-frame-pointer参数来生成汇编，会把下面三行代码都去掉。<br>pushq %rbp<br>movq %rsp, %rbp<br>popq %rbp<br><br>我在34讲的一个例子中，手工去掉了这三行代码，生成的机器码可以少5个字节，还少两次内存访问，其中有一次是写操作，高速缓存都帮不上忙。对于追求极致性能的程序来说，这个优化是必要的。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573300181,"ip_address":"","comment_id":147902,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867885459","product_id":100034101,"comment_content":"局部变量的访问，既可以用rbp-的方式，也可以用rsp+的方式，文中实例里，都是rbp-的方式，所以需要管理好rbp这个寄存器。<br>如果采用rsp+的方式，是不是根本就不需要rbp这个寄存器了，这样效率不就更高了？<br>我看到的一些ARM核，里面只有rsp寄存器，没有rbp寄存器，这样是不是更好呢？","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473330,"discussion_content":"没错。用两个寄存器来标记栈桢，确实有点浪费。实际上是可以优化掉的。\n如果你用gcc编译的话，可以使用-fomit-frame-pointer参数来生成汇编，会把下面三行代码都去掉。\npushq %rbp\nmovq %rsp, %rbp\npopq %rbp\n\n我在34讲的一个例子中，手工去掉了这三行代码，生成的机器码可以少5个字节，还少两次内存访问，其中有一次是写操作，高速缓存都帮不上忙。对于追求极致性能的程序来说，这个优化是必要的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573300181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142437,"user_name":"阿鼎","can_delete":false,"product_type":"c1","uid":1042634,"ip_address":"","ucode":"EE763513563F50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/ca/2a7cc193.jpg","comment_is_top":false,"comment_ctime":1571368612,"is_pvip":false,"replies":[{"id":"57697","content":"非io当然可以用协程。比如迭代器、状态机用协程来写就很优雅。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573444495,"ip_address":"","comment_id":142437,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5866335908","product_id":100034101,"comment_content":"协程的切换，用户态代码要复制堆栈寄存器信息。也想请教老师，协程调度是否只能在io线程呢？非io线程能否用协程呢？","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471126,"discussion_content":"非io当然可以用协程。比如迭代器、状态机用协程来写就很优雅。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573444495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042634,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/ca/2a7cc193.jpg","nickname":"阿鼎","note":"","ucode":"EE763513563F50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388335,"discussion_content":"可能是我表述的问题。我的意思是，协程的实现，协程调度的实现。io线程中可以用epoll等切换协程，非io线程中协程何时切换，难道要把操作系统的机制实现在用户态吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628699344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050269,"avatar":"","nickname":"minghu6","note":"","ucode":"F44058E21B14C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376693,"discussion_content":"作者这是把协程和生成器的概念混淆了吧, 协程本质上只是编程机制上支持的一种用户线程轮寻的简单写法, 它只是用到了生成器.  非IO领域比如状态机需要IO吗, 那么用携程的意义何在? 拖累性能?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622279563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140703,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1571034969,"is_pvip":false,"replies":[{"id":"54412","content":"鼓励你用c语言，使用malloc和free来申请和释放内存，看看生成的汇编是怎样的。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1571044398,"ip_address":"","comment_id":140703,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5866002265","product_id":100034101,"comment_content":"老师在课中讲了不少“栈”的操作，那编程语言对于&quot;堆&quot;又是用什么指令操作的呢？","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470517,"discussion_content":"鼓励你用c语言，使用malloc和free来申请和释放内存，看看生成的汇编是怎样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571044398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1444483,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","nickname":"风","note":"","ucode":"E1CE0825AAF805","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43935,"discussion_content":"堆不是用汇编指令操作的，它只是一个内存管理的算法，并将其封装成malloc和free函数，供用户调用。\n堆实际上就是一片静态内存，但是用户不能通过地址直接访问，必须通过malloc和free函数访问。\n你可以随便百度一个malloc和free的C函数源码，看懂它就行了，代码量很少的。\n内存管理有很多策略，虽然用户看起来都是malloc和free函数，但内部可以用不同的算法实现，重点是如何避免内存碎片的产生和回收内存碎片。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572917756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177315,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","nickname":"沉淀的梦想","note":"","ucode":"BCB7C26F9D214B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33409,"discussion_content":"就看到生成的汇编代码里调用了一下malloc和free  テ_デ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571121421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140631,"user_name":"pebble","can_delete":false,"product_type":"c1","uid":1022021,"ip_address":"","ucode":"871930CB227C68","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/45/318ba48a.jpg","comment_is_top":false,"comment_ctime":1571018770,"is_pvip":false,"replies":[{"id":"54363","content":"不是。<br>rbp，指向栈底。这个值在整合函数执行期间是不变的。<br>rsp，指向栈顶。这个值会在某些情况下改变：<br>(1)push和pop命令可以改变rsp。<br>(2)call指令，因为要把返回地址压栈，实际也改变了rsp。<br>(3)在使用本地变量时，手工改变rsp的值。<br>rsp如果指向下次要保存数据的位置，相当于栈里总有一个空单元。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1571023417,"ip_address":"","comment_id":140631,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5865986066","product_id":100034101,"comment_content":"例一的俩栈帧图里，rbp跟rsp，是否应该都指向再下一个位置呢，rsp指向的，应该是下次要保存数据的位置吧","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470481,"discussion_content":"不是。\nrbp，指向栈底。这个值在整合函数执行期间是不变的。\nrsp，指向栈顶。这个值会在某些情况下改变：\n(1)push和pop命令可以改变rsp。\n(2)call指令，因为要把返回地址压栈，实际也改变了rsp。\n(3)在使用本地变量时，手工改变rsp的值。\nrsp如果指向下次要保存数据的位置，相当于栈里总有一个空单元。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571023417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022021,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/98/45/318ba48a.jpg","nickname":"pebble","note":"","ucode":"871930CB227C68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32345,"discussion_content":"对rsp确实理解错了，函数设置完栈帧后，应该跟rsp一样吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571026550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341139,"user_name":"程序员班吉","can_delete":false,"product_type":"c1","uid":1478098,"ip_address":"","ucode":"BD48CF7649609A","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/d2/8a6be8d8.jpg","comment_is_top":false,"comment_ctime":1649386891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649386891","product_id":100034101,"comment_content":"扩展栈和缩小栈，使用的是一个立即数，这个立即数表示的是将地址向上或者向下移动多少吗？","like_count":0},{"had_liked":false,"id":316494,"user_name":"Geek_656245","can_delete":false,"product_type":"c1","uid":2810125,"ip_address":"","ucode":"2B358A704E5891","user_header":"","comment_is_top":false,"comment_ctime":1634355440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634355440","product_id":100034101,"comment_content":"视屏流，音频流在汇编和机器码中又是什么样子的呢？<br>","like_count":0},{"had_liked":false,"id":316493,"user_name":"Geek_656245","can_delete":false,"product_type":"c1","uid":2810125,"ip_address":"","ucode":"2B358A704E5891","user_header":"","comment_is_top":false,"comment_ctime":1634355394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634355394","product_id":100034101,"comment_content":"汇编转化成机器码又是什么样子的呢？","like_count":0},{"had_liked":false,"id":295199,"user_name":"minghu6","can_delete":false,"product_type":"c1","uid":1050269,"ip_address":"","ucode":"F44058E21B14C9","user_header":"","comment_is_top":false,"comment_ctime":1622294699,"is_pvip":false,"replies":[{"id":"107369","content":"是，与汇编有关的工作，工程性更强一些。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1622551262,"ip_address":"","comment_id":295199,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622294699","product_id":100034101,"comment_content":"看一些汇编代码的例子总是觉得腰背酸痛,  原理性不多, 就是些具体规定而且高度平台特定,  纯搬砖, 给平台打工, 看了真不带劲儿<br>","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520987,"discussion_content":"是，与汇编有关的工作，工程性更强一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622551262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266733,"user_name":"favoorr","can_delete":false,"product_type":"c1","uid":1056192,"ip_address":"","ucode":"E83A360B332BCC","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/c0/ab9b24d8.jpg","comment_is_top":false,"comment_ctime":1607475791,"is_pvip":true,"replies":[{"id":"98488","content":"你讲的很对。最好善用GDB、LLDB这些调试工具，这样很多抽象的知识就变得可视化了！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1609738588,"ip_address":"","comment_id":266733,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607475791","product_id":100034101,"comment_content":"这个第一次学的时候还真很难一次明白，最好是用 GDB  来单步，观察寄存器的值，一边单步，一边拿自己小本本记，来加深理解","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511367,"discussion_content":"你讲的很对。最好善用GDB、LLDB这些调试工具，这样很多抽象的知识就变得可视化了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609738588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255507,"user_name":"__Unsafe","can_delete":false,"product_type":"c1","uid":1237779,"ip_address":"","ucode":"7D9975396A3194","user_header":"https://static001.geekbang.org/account/avatar/00/12/e3/13/feaf21e4.jpg","comment_is_top":false,"comment_ctime":1603360414,"is_pvip":false,"replies":[{"id":"94529","content":"只要是等价的，就可以。<br>只不过，这种代码通常都是由编译器机械的生成的，它会按照一个固定的套路来生成代码。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1604999673,"ip_address":"","comment_id":255507,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603360414","product_id":100034101,"comment_content":"_fun1:    # 函数调用的序曲,设置栈指针    <br>pushq   %rbp           # 把调用者的栈帧底部地址保存起来       <br>movq    %rsp, %rbp     # 把调用者的栈帧顶部地址,设置为本栈帧的底部    <br>movl    $10, -4(%rbp)  # 变量c赋值为10,也可以写成 movl $10, (%rsp)<br>这里不能写成movl $10, (%rsp)吧，上一步movq %rsp %rbp已经把%rbp的值设为%rsp一样了","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507737,"discussion_content":"只要是等价的，就可以。\n只不过，这种代码通常都是由编译器机械的生成的，它会按照一个固定的套路来生成代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604999673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180573,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1582339910,"is_pvip":true,"replies":[{"id":"74198","content":"必须是叶子函数才可以。<br>下面是https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;X86_calling_conventions<br>中摘的一段，介绍System V AMD64 ABI的内容，你可以看看：<br>For leaf-node functions (functions which do not call any other function(s)), a 128-byte space is stored just beneath the stack pointer of the function. The space is called red-zone. This zone will not be clobbered by any signal or interrupt handlers. Compilers can thus utilize this zone to save local variables. Compilers may omit some instructions at the starting of the function (adjustment of RSP, RBP) by utilizing this zone. However, other functions may clobber this zone. Therefore, this zone should only be used for leaf-node functions. gcc and clang offer the -mno-red-zone flag to disable red-zone optimizations.","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585140029,"ip_address":"","comment_id":180573,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582339910","product_id":100034101,"comment_content":"在“同时使用寄存器和栈来传参”那一些小节，且%rsp 并未指向栈真实的最顶部，那么当在fun里再调用其它方法时，其它方法 执行pushq %rbp，会不会覆盖掉 -4(%rbp)的值，进而出错？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484719,"discussion_content":"必须是叶子函数才可以。\n下面是https://en.wikipedia.org/wiki/X86_calling_conventions\n中摘的一段，介绍System V AMD64 ABI的内容，你可以看看：\nFor leaf-node functions (functions which do not call any other function(s)), a 128-byte space is stored just beneath the stack pointer of the function. The space is called red-zone. This zone will not be clobbered by any signal or interrupt handlers. Compilers can thus utilize this zone to save local variables. Compilers may omit some instructions at the starting of the function (adjustment of RSP, RBP) by utilizing this zone. However, other functions may clobber this zone. Therefore, this zone should only be used for leaf-node functions. gcc and clang offer the -mno-red-zone flag to disable red-zone optimizations.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585140029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140705,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1571035066,"is_pvip":false,"replies":[{"id":"54410","content":"macOS操作系统，gnu汇编器。<br>Linux上生成的汇编码应该也差不多，有些系统调用是不同的。<br>windows上，你就要安装一下相关的环境了和工具了，比如MinGW。或者装一个Linux虚拟机。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1571044315,"ip_address":"","comment_id":140705,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1571035066","product_id":100034101,"comment_content":"老师的as用的什么版本，为什么我用as汇编文稿中的代码会出错（注释删了也一样会出错）：<br><br>function-call2-craft.s: Assembler messages:<br>function-call2-craft.s:2: Error: no such instruction: `n-call2-craft.s 函数调用和参数传递&#39;<br>function-call2-craft.s:4: Error: character following name is not &#39;#&#39;<br>function-call2-craft.s:66: Error: character following name is not &#39;#&#39;<br>","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470519,"discussion_content":"macOS操作系统，gnu汇编器。\nLinux上生成的汇编码应该也差不多，有些系统调用是不同的。\nwindows上，你就要安装一下相关的环境了和工具了，比如MinGW。或者装一个Linux虚拟机。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571044315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1565396,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e2/d4/ef86ea64.jpg","nickname":"Front","note":"","ucode":"35593EA52F2EA6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341641,"discussion_content":"各个Linux版本之间可能会有些差异。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610469078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1565396,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e2/d4/ef86ea64.jpg","nickname":"Front","note":"","ucode":"35593EA52F2EA6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341640,"discussion_content":"我在Ubuntu18.04上也碰到同样的问题。解决的办法是参考由hello.c生成的汇编代码微调，也只改了section部分那个printf函数：\n        .file   &#34;function-call2-craft.c&#34;\n        .text\n        .global _fun1\n        .type _fun1, @function\n\n_fun1:\n\n    pushq   %rbp\n    movq    %rsp, %rbp\n\n    movl    $10, -4(%rbp)\n\n\n    movl    %edi, %eax\n    addl    %esi, %eax\n    addl    %edx, %eax\n    addl    %ecx, %eax\n    addl    %r8d, %eax\n    addl    %r9d, %eax\n    addl    16(%rbp), %eax\n    addl    24(%rbp), %eax\n\n    addl    -4(%rbp), %eax\n\n\n    popq    %rbp\n    retq\n\n    .globl  main\n    .type main, @function\nmain:\n\n\n    pushq   %rbp\n    movq    %rsp, %rbp\n\n    subq    $16, %rsp\n\n\n    movl    $1, %edi\n    movl    $2, %esi\n    movl    $3, %edx\n    movl    $4, %ecx\n    movl    $5, %r8d\n    movl    $6, %r9d\n    movl    $7, (%rsp)\n    movl    $8, 8(%rsp)\n\n    callq   _fun1\n\n\n    leaq    L_.str(%rip), %rdi\n    movl    %eax, %esi\n\n    callq   printf@PLT\n\n\n    movl    $0, %eax\n\n    addq    $16, %rsp\n\n\n    popq    %rbp\n    retq\n\n\nL_.str:\n    .asciz  &#34;fun1 :%d \\n&#34;\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610468958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}