{"id":667908,"title":"24｜数据库应用（四）：如何在项目中灵活应用数据库操作","content":"<p>你好，我是Barry。</p><p>在我们项目开发过程中，为了实现各式各样的开发需求，离不开对数据的管理。而数据管理就需要操作数据库来实现。通过前面课程的学习，我们对数据库操作建立了基本认识，但并没有真正在项目里应用起来。</p><p>说到数据库操作，我们都知道它的核心就是对数据库中的数据实现增、删、改、查这些操作。你会发现万变不离其宗，所有的业务需求都是通过单一的操作或者组合操作来实现的，所以我们一定要非常熟悉数据库每种操作方法的实现方式，未来才能应对更复杂的需求场景。</p><p>今天是一节实操练习课，耐心跟着我的思路和操作步骤学完今天的内容，你就可以独立实现数据库里的所有操作，真正做到学以致用。</p><h2>数据库新增（create）</h2><p>数据库实操之旅的第一站，我们先来完成数据库的新增操作。你可以对照文稿里具体执行方法的代码，听我讲解。</p><pre><code class=\"language-python\">db.session.add()\ndb.session.commit()\n</code></pre><p>这段代码的作用很容易理解，db.session是 SQLAlchemy 框架中的一个抽象概念，是一个可以注册所有数据库操作的上下文管理器。它的作用就是连接数据源并持续跟踪所有数据库操作，这样我们就能更清晰地把握数据库里发生的各种操作了。</p><p>为了帮你加深理解，我们结合案例来练习一下。当我们想要通过编写代码添加一个新的数据库记录时，就可以操作 ‘db.session.add()’ 将数据添加到会话中，并通过 ‘db.session.commit()’ 将更改提交到数据库。语句db.session.add()当中传入的参数，就表示UserInfo的一个实例化对象。</p><!-- [[[read_end]]] --><p>如果我们想要增添一条信息，完整语句应该是后面这样。</p><pre><code class=\"language-python\">new_user = UserInfo(nickname=\"new_user\", mobile=\"13812341234\", sex='1')\ndb.session.add(new_user)\ndb.session.commit()\n</code></pre><p>这里我们要注意UserInfo中的参数，除了有默认值的字段外，其余字段都需要设置。为了让我们后续的工作更轻松高效，对于这类重复性的操作，我们可以在模型基类中提前添加上共用的操作，我们依次来看看都有哪些操作。</p><p>首先，我们要在base.py文件中定义的模型基类BaseModel类中添加操作。注意在这里不要额外设置查询函数，因为每个查询方式和查询条件可能都不一样，无法统一定义。</p><pre><code class=\"language-python\">def add(self, obj):\n    db.session.add(obj)\n    return session_commit()\ndef update(self):\n    return session_commit()\ndef delete(self):\n    self.status = 0\n    return session_commit()\n</code></pre><p>我还给你准备了完整的base.py的代码，你可以参考一下。</p><pre><code class=\"language-python\">from datetime import datetime\nfrom api import db\nfrom api.libs.db_utils import session_commit\nclass BaseModels:\n&nbsp; &nbsp; \"\"\"模型基类\"\"\"\n&nbsp; &nbsp; # 创建时间\n&nbsp; &nbsp; create_time = db.Column(db.DateTime, default=datetime.now)\n&nbsp; &nbsp; # 记录你的更新时间\n&nbsp; &nbsp; update_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)\n&nbsp; &nbsp; # 记录存活状态\n&nbsp; &nbsp; status = db.Column(db.SmallInteger, default=1)\n&nbsp; &nbsp; def add(self, obj):\n&nbsp; &nbsp; &nbsp; &nbsp; db.session.add(obj)\n&nbsp; &nbsp; &nbsp; &nbsp; return session_commit()\n&nbsp; &nbsp; def update(self):\n&nbsp; &nbsp; &nbsp; &nbsp; return session_commit()\n&nbsp; &nbsp; def delete(self):\n&nbsp; &nbsp; &nbsp; &nbsp; self.status = 0\n&nbsp; &nbsp; &nbsp; &nbsp; return session_commit()\n</code></pre><p>同时，我们再学习一个优化精简代码的实用方法——把session_commit()函数单独管理起来。我们可以把这个函数放在api文件夹下的libs中，然后新建db_utils.py文件，具体的代码是后面这样。</p><pre><code class=\"language-python\">from sqlalchemy.exc import SQLAlchemyError\nfrom api import db\ndef session_commit():\n&nbsp; &nbsp; try:\n&nbsp; &nbsp; &nbsp; &nbsp; db.session.commit()\n&nbsp; &nbsp; except SQLAlchemyError as e:\n&nbsp; &nbsp; &nbsp; &nbsp; db.session.rollback()\n&nbsp; &nbsp; &nbsp; &nbsp; reason = str(e)\n&nbsp; &nbsp; &nbsp; &nbsp; return reason\n</code></pre><p>这里我想提醒你的是，别忘了全面考虑，做好程序的异常处理。如果无异常就正常执行，提交请求；如果出现异常，则要使用db.session.rollback()实现回滚操作，并且以字符形式返回异常类型。</p><p>接下来，我们就一起实现在数据库里添加数据。在app.py文件中的具体执行代码我放在了后面。</p><pre><code class=\"language-python\">@app.route('/add')\ndef add_data():\n&nbsp; &nbsp; u = UserInfo()\n&nbsp; &nbsp; new_user1 = UserInfo(nickname='flask_test1', mobile='13323456789', signature='理想', create_time=datetime.now(), role_id=1)\n&nbsp; &nbsp; new_user2 = UserInfo(nickname='flask_test2', mobile='13312345678', signature='梦想', create_time=datetime.now(), role_id=2)\n    new_user1 = UserInfo(nickname='flask_test3', mobile='13311223344', signature='理想', create_time=datetime.now(), role_id=3)\n    new_user2 = UserInfo(nickname='flask_test4', mobile='13333445566', signature='梦想', create_time=datetime.now(), role_id=4)\n    u.add(new_user1)\n    u.add(new_user2)\n    u.add(new_user3)\n    u.add(new_user4)\n</code></pre><p>接下来，我们要在pycharm终端运行后面这条命令。</p><pre><code class=\"language-python\">python app.py runserver\n</code></pre><p>这条命令执行后会启动一个本地服务器，让你的 Python 应用程序可以在一个本地端口上运行打开浏览器。之后我们还要浏览器输入 127.0.0.1:5000/add，这样我们就实现了新增操作。后面是具体的命令执行图和浏览器效果图，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/c6/265183da20daf07dfc8377c021bbedc6.jpg?wh=2900x859\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/70/0a/70a5e276700743e72c9b8d77455e440a.jpg?wh=2900x801\" alt=\"\"></p><p>进行到这里，你会发现界面中会显示服务器错误，这是怎么回事儿呢？别担心，这是因为我们现在只是操作了数据库，并没有进行任何与服务器相关的操作。</p><p>完成了添加操作以后，这时候你打开Navicat，就会看到数据库表中我们已经添加了这四条记录。到这里，我们就成功实现了对数据库的新增操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/58/7f/584e70d83509b7bd418455a421f95c7f.jpg?wh=2900x859\" alt=\"\"></p><h2>数据库查询（query）</h2><p>我们已经知道了如何向数据库里添加记录，那么如何从数据库里取回数据呢？</p><p>我们通过使用模型类提供的query属性，附加调用各种过滤方法及查询方法就可以完成这个任务。</p><p>一般来说，一个完整的查询遵循下面的模式。</p><pre><code class=\"language-python\">&lt;模型类&gt;.query.&lt;过滤&gt;.&lt;查询&gt;\n</code></pre><p>SQLAlchemy提供了许多查询方法，我用表格梳理了其中用来获取数据的方法。虽然方法不少，但不要紧张，表里的内容你也不用刻意记，随用随取，多加练习即可。</p><p><img src=\"https://static001.geekbang.org/resource/image/7d/a3/7d1864aea4fa373e5ded20e32dd388a3.jpg?wh=2979x2346\" alt=\"\"></p><p>看到这里估计你还有疑问，我们具体该如何使用这些方法呢？</p><p>我们这就结合案例来继续学习。我们从all()开始说起。这里我们使用UserInfo模型基类query属性的all()方法，就能够查询到用户表里的所有信息。</p><pre><code class=\"language-python\">user_list = UserInfo.query.all()\nprint(user_list)\n</code></pre><p>其他的方法大同小异，你可以参考我提供的形式自己尝试一下，相信练习后你就能非常熟练地掌握这些查询方法了。</p><p>接下来，我们来挑战一个综合性的应用实践——加上自定义的路由来尝试执行不同的查询方式。完整代码是后面这样。</p><pre><code class=\"language-python\">@app.route('/query1')\ndef query_data1():\n    user_list = UserInfo.query.all()\n    result = []\n    for user in user_list:\n        result.append(user.to_dict())\n    return {'users': result}\n@app.route('/query2')\ndef query_data2():\n    user = UserInfo.query.get(3)\n    return {'users': user.to_dict()}\n@app.route('/query3')\ndef query_data3():\n    first_user = UserInfo.query.first()\n    return {'users': first_user.to_dict()}\n@app.route('/query4')\ndef query_data4():\n    user_list = UserInfo.query.filter(UserInfo.signature == '理想').all()\n    result = []\n    for user in user_list:\n        result.append(user.to_dict())\n    return {'users': result}\n@app.route('/query5')\ndef query_data5():\n    user_list = UserInfo.query.filter_by(signature='理想').all()\n    result = []\n    for user in user_list:\n        result.append(user.to_dict())\n    return {'users': result}\n</code></pre><p>加上了路由后，我们需要在模型基类中使用方法to_dict，目的是将数据变成在前端能响应的JSON格式。这时候。你直接执行运行命令就能看到效果了。我们在浏览器中分别输入下面的路由。</p><pre><code class=\"language-python\">127.0.0.1：5000/query1\n127.0.0.1：5000/query2\n127.0.0.1：5000/query3\n127.0.0.1：5000/query4\n127.0.0.1：5000/query5\n</code></pre><p>到这里，我们就完成了对数据库数据查询的操作。</p><h2>数据库删除（Delete）</h2><p>学完了数据库新增和查询操作，下面我们来看看删除操作。</p><p>对于删除操作，我们同样需要使用session这个对象来实现，我们还是结合具体的实现方法代码来理解。</p><pre><code class=\"language-python\">db.session.delete(delete_user)\ndb.session.commit()\n</code></pre><p>可以看到，这里和添加操作不同的地方是db.session.add()方法变成了db.session.delete()方法，但同样需要传入一个参数。删除时，delete_user需要通过查询语句先完成查询操作，找到要删除的记录，然后再执行删除操作。</p><p>例如我们想要删除id为4的用户信息，就可以像后面这样操作。</p><pre><code class=\"language-python\">@app.route('/delete')\ndef delete_data():\n    delete_user = UserInfo.query.get(4)\n    db.session.delete(delete_user)\n    db.session.commit()\n</code></pre><p>运行程序之后，我们需要在浏览器中输入下面的路由。</p><pre><code class=\"language-python\">127.0.0.1：5000/delete\n</code></pre><p>这时候，我们在数据库中就会发现id为4的记录已经删除了，你可以参考后面的截图看一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/a9/9c70f95ef9889e0606b6bd14cc66dca9.jpg?wh=2861x875\" alt=\"\"></p><p>刚才讲的这种删除方式，效果是永久删除这条记录，但是实际情况可能存在误删，那我们怎么应对才更好呢？</p><p>这就需要我们在模型基类中自定义删除方法，将status存活状态设置为0。</p><pre><code class=\"language-python\">@app.route('/delete')\ndef delete_data():\n    delete_user = UserInfo.query.get(3)\n    delete_user.delete()\n</code></pre><p>同样运行程序之后，我们还要在浏览器中输入下面的域名，随后你就会在数据库中看到对应执行的效果了。</p><pre><code class=\"language-python\">127.0.0.1：5000/delete\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/ed/7b/edf68d03f5318640e76d56e26393757b.jpg?wh=2861x875\" alt=\"\"><br>\n可以看到，这时记录还在，但是存活状态为0。这样一来，我们在写业务逻辑部分的时候，使用satus即可判断数据的状态。</p><h2>数据库更新（Update）</h2><p>数据库更新操作，其实就是数据库修改操作，它在项目开发里的使用频率也非常高。比方说修改用户信息、修改视频信息都会用得上。</p><p>跟之前的删除操作思路一样，更新操作也要先查询信息。而不同的地方是，我们不再借助session这个对象传递数据，只需要使用语句db.session.commit()方法提交修改的信息即可。</p><p>为了帮你更直观地理解，我们结合例子来看看。现在我们希望把前面修改过的第三条记录撤销掉，也就是把这条记录的存活状态设置回来，那具体的实现方法就是后面这样。</p><pre><code class=\"language-python\">@app.route('/update')\ndef update_data():\n    u = UserInfo()\n    update_user = u.query.get(3)\n    update_user.status = 1\n    u.update()\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/19/15/19f73334daf7e787f6d78af253730b15.jpg?wh=2861x875\" alt=\"\"></p><p>看过代码和效果图之后，是不是感觉一通百通了呢？到这里我们就完成了数据库的所有操作。当然，我们在项目开发过程中结合实际业务需求，也会出现组合使用的情况，例如在项目中想要修改个人信息，我们需要先查询个人信息，获取到数据之后再修改。不过不用担心，我们掌握了每一项基本操作的方法，组合起来应用也难不倒你。</p><h2>总结</h2><p>又到了课程的尾声，让我们梳理总结一下今天的内容重点。</p><p>今天的实操练习当中，我们通过代码案例分别实现了数据库的增、删、改、更新，进一步强化了我们的数据库操作技能。</p><p>项目开发里离不开数据库的数据管理，无论是调整、更新视频信息，还是管理用户的信息表，都需要用到数据库里增、删、改、查这些操作。另外，实现的过程中我们多次用到db.session，它是 SQLAlchemy 框架中的一个抽象概念，用来连接数据源并持续跟踪所有数据库操作。</p><p>其实在项目里完成数据库操作其实并不复杂，<strong>你也应该感受到了，真正落地的时候仍然需要你具备灵活处理的思维和扎实的代码功底</strong>。课程里我为你详细梳理了各个操作的代码实现逻辑，不过还是建议你课后多练习巩固，这样才能熟练掌握这些技巧。</p><h2>思考题</h2><p>除了在视图函数中完成增、删、改、查操作以外，在Flask shell的交互式命令行里还可以进行哪些操作呢？</p><p>欢迎你在留言区和我交流互动，也推荐你把这节课分享给身边更多朋友。</p>","neighbors":{"left":{"article_title":"23｜数据库应用（三）：项目数据库配置实战","id":667101},"right":{"article_title":"25｜Blueprint与Redprint：如何让程序进行模块化处理？","id":668408}},"comments":[{"had_liked":false,"id":383430,"user_name":"Aegean Sea","can_delete":false,"product_type":"c1","uid":3688848,"ip_address":"广东","ucode":"0C6F23AEAC6E07","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELrxUK36wj3AesBNLK4tPibu7URiaI48cMWho2t8bfZOyfYDnQwQu2TTXibIbGVZ8DkPhNXDGr7VTfOJv1R1ccw1KBv5qfbq1bYvDhL1MtAVjISA/132","comment_is_top":false,"comment_ctime":1699012903,"is_pvip":false,"replies":[{"id":140263,"content":"当你执行python app.py runserver后，Flask应用程序会启动并在本地的特定端口上运行。但是，并不意味着你的数据库会立即更新或添加新的表。你这个情况需要检查一下你的代码和配置，并确保你的Flask应用程序与数据库能够连接交互。排除一下，如果找不到问题，你可以直接把hub上的代码clone下来，进行比对。\n\n\n","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1700999878,"ip_address":"北京","comment_id":383430,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100546501,"comment_content":"为什么我执行控制台输入python app.py runserver后，Navicat里面数据库没有新增falsk_test1-flask_test4","like_count":0,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632573,"discussion_content":"当你执行python app.py runserver后，Flask应用程序会启动并在本地的特定端口上运行。但是，并不意味着你的数据库会立即更新或添加新的表。你这个情况需要检查一下你的代码和配置，并确保你的Flask应用程序与数据库能够连接交互。排除一下，如果找不到问题，你可以直接把hub上的代码clone下来，进行比对。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700999878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376504,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1686877444,"is_pvip":false,"replies":[{"id":137513,"content":"1、在数据库连接中，session 可以理解为一种会话或上下文，它提供了一种在应用程序和数据库之间进行交互的方式。在某些情况下，可以将数据库的 session 理解为与 TCP 连接相对应，但并不是所有数据库系统或应用程序框架都采用这种一对一的映射关系。\n2、是的，&quot;python app.py runserver&quot; 命令通常用于启动一个服务器，该服务器是 Python 库中自带的一个简单的开发服务器。\n3、在这段代码中，使用了 u.update() 方法来更新数据库中的数据，而不需要显式地使用 commit() 方法提交修改信息。这是因为在 SQLAlchemy 中，u.update() 方法会自动进行事务管理，并在调用该方法时自动提交修改的信息到数据库中。\n\n\n","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1688398518,"ip_address":"北京","comment_id":376504,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100546501,"comment_content":"Q1：数据库连接的session怎么理解？\n对于数据库的session，感觉一直理解不到位。一个用户连到数据库，从建立连接到中断连接，这整个过程是一个session吗？另外，session是对应于TCP连接吗？ 即session = TCP连接，可以这么理解吗？\nQ2：runserver是指什么？\n“python app.py runserver”，其中的runserver是一个命令，关键字，不是一个server的名字吧。 这个命令会启动一个server吗？哪里的server？是python库里自带的一个server吗？\nQ3：update并没有用session.\nUpdate部分，有一句“不同的地方是，我们不再借助 session 这个对象传递数据，只需要使用语句 db.session.commit() 方法提交修改的信息即可”，提到了用session.commit，但是代码中并没有session.commit:\ndef update_data():\n    u = UserInfo()\n    update_user = u.query.get(3)\n    update_user.status = 1\n    u.update()","like_count":0,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622557,"discussion_content":"1、在数据库连接中，session 可以理解为一种会话或上下文，它提供了一种在应用程序和数据库之间进行交互的方式。在某些情况下，可以将数据库的 session 理解为与 TCP 连接相对应，但并不是所有数据库系统或应用程序框架都采用这种一对一的映射关系。\n2、是的，&#34;python app.py runserver&#34; 命令通常用于启动一个服务器，该服务器是 Python 库中自带的一个简单的开发服务器。\n3、在这段代码中，使用了 u.update() 方法来更新数据库中的数据，而不需要显式地使用 commit() 方法提交修改信息。这是因为在 SQLAlchemy 中，u.update() 方法会自动进行事务管理，并在调用该方法时自动提交修改的信息到数据库中。\n\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1688398518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2923811,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/faia2nIq0NUsUkJqe8FVT8XdSKRyL6bX939dG2abBKDGV9pfcbTzYeZrqOguvbJ4Dc6qeBnib0aqrCqXumnE5Veg/132","nickname":"Geek_6209d3","note":"","ucode":"873FC5123D343D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621802,"discussion_content":"update函数里有commit","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1687660503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}