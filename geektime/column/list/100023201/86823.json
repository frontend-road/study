{"id":86823,"title":"（小实验）理解编译原理：一个四则运算的解释器","content":"<p>你好，我是winter。</p><p>在前面的课程中，我在JavaScript和CSS的部分，多次提到了编译原理相关的知识。这一部分的知识，如果我们从编译原理“龙书”等正规的资料中学习，就会耗费掉不少的时间，所以我在这里设计了一个小实验，帮助你快速理解编译原理相关的知识。</p><p>今天的内容比较特殊，我们来做一段详细的代码实验，详细的代码我放在了文章里，如果你正在收听音频，可以点击文章查看详情。</p><h2>分析</h2><p>按照编译原理相关的知识，我们来设计一下工作，这里我们分成几个步骤。</p><ul>\n<li>定义四则运算：产出四则运算的词法定义和语法定义。</li>\n<li>词法分析：把输入的字符串流变成token。</li>\n<li>语法分析：把token变成抽象语法树AST。</li>\n<li>解释执行：后序遍历AST，执行得出结果。</li>\n</ul><h2>定义四则运算</h2><p>四则运算就是加减乘除四种运算，例如：</p><pre><code>1 + 2 * 3\n</code></pre><p>首先我们来定义词法，四则运算里面只有数字和运算符，所以定义很简单，但是我们还要注意空格和换行符，所以词法定义大概是下面这样的。</p><ul>\n<li>Token\n<ul>\n<li>Number: <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code> <code>9</code> <code>0</code> 的组合</li>\n<li>Operator: <code>+</code> 、<code>-</code>、 <code>*</code>、 <code>/</code> 之一</li>\n</ul>\n</li>\n<li>Whitespace: <code>&lt;sp&gt;</code></li>\n<li>LineTerminator：<code>&lt;LF&gt;</code> <code>&lt;CR&gt;</code></li>\n</ul><p>这里我们对空白和换行符没有任何的处理，所以词法分析阶段会直接丢弃。</p><!-- [[[read_end]]] --><p>接下来我们来定义语法，语法定义多数采用BNF，但是其实大家写起来都是乱写的，比如JavaScript标准里面就是一种跟BNF类似的自创语法。</p><p>不过语法定义的核心思想不会变，都是几种结构的组合产生一个新的结构，所以语法定义也叫语法产生式。</p><p>因为加减乘除有优先级，所以我们可以认为加法是由若干个乘法再由加号或者减号连接成的：</p><pre><code>&lt;Expression&gt; ::= \n    &lt;AdditiveExpression&gt;&lt;EOF&gt;\n\n&lt;AdditiveExpression&gt; ::= \n    &lt;MultiplicativeExpression&gt;\n    |&lt;AdditiveExpression&gt;&lt;+&gt;&lt;MultiplicativeExpression&gt;\n    |&lt;AdditiveExpression&gt;&lt;-&gt;&lt;MultiplicativeExpression&gt;\n</code></pre><p>这种BNF的写法类似递归的原理，你可以理解一下，它表示一个列表。为了方便，我们把普通数字也得当成乘法的一种特例了。</p><pre><code>&lt;MultiplicativeExpression&gt; ::= \n    &lt;Number&gt;\n    |&lt;MultiplicativeExpression&gt;&lt;*&gt;&lt;Number&gt;\n    |&lt;MultiplicativeExpression&gt;&lt;/&gt;&lt;Number&gt;\n</code></pre><p>好了，这就是四则运算的定义了。</p><h2>词法分析：状态机</h2><p>词法分析部分，我们把字符流变成token流。词法分析有两种方案，一种是状态机，一种是正则表达式，它们是等效的，选择你喜欢的就好，这里我都会你介绍一下状态机。</p><p>根据分析，我们可能产生四种输入元素，其中只有两种token，我们状态机的第一个状态就是根据第一个输入字符来判断进入了哪种状态：</p><pre><code class=\"language-JavaScript\">var token = [];\nconst start = char =&gt; {\n    if(char === '1' \n        || char === '2'\n        || char === '3'\n        || char === '4'\n        || char === '5'\n        || char === '6'\n        || char === '7'\n        || char === '8'\n        || char === '9'\n        || char === '0'\n    ) {\n        token.push(char);\n        return inNumber;   \n    }\n    if(char === '+' \n        || char === '-'\n        || char === '*'\n        || char === '/'\n    ) {\n        emmitToken(char, char);\n        return start\n    }\n    if(char === ' ') {\n        return start;\n    }\n    if(char === '\\r' \n        || char === '\\n'\n    ) {\n        return start;\n    }\n}\nconst inNumber = char =&gt; {\n    if(char === '1' \n        || char === '2'\n        || char === '3'\n        || char === '4'\n        || char === '5'\n        || char === '6'\n        || char === '7'\n        || char === '8'\n        || char === '9'\n        || char === '0'\n    ) {\n        token.push(char);\n        return inNumber;\n    } else {\n        emmitToken(\"Number\", token.join(\"\"));\n        token = [];\n        return start(char); // put back char\n    }\n}\n</code></pre><p>这个状态机非常简单，它只有两个状态，因为我们只有Number不是单字符的token。</p><p>这里我的状态机实现是非常经典的方式：用函数表示状态，用if表示状态的迁移关系，用return值表示下一个状态。</p><p>下面我们来运行一下这个状态机试试看：</p><pre><code class=\"language-JavaScript\">\nfunction emmitToken(type, value) {\n    console.log(value);\n}\n\nvar input = \"1024 + 2 * 256\"\n\nvar state = start;\n\nfor(var c of input.split(''))\n    state = state(c);\n\nstate(Symbol('EOF'))\n\n</code></pre><p>运行后我们发现输出如下：</p><pre><code>1024\n+\n2\n*\n256\n</code></pre><p>这是我们想要的答案。</p><h2>语法分析：LL</h2><p>做完了词法分析，我们开始进行语法分析，LL语法分析根据每一个产生式来写一个函数，首先我们来写好函数名：</p><pre><code>function AdditiveExpression( ){\n\n\n}\nfunction MultiplicativeExpression(){\n    \n\n}\n</code></pre><p>为了便于理解，我们就不做流式处理了，实际上一般编译代码都应该支持流式处理。</p><p>所以我们假设token已经都拿到了：</p><pre><code class=\"language-JavaScript\">var tokens = [{\n    type:\"Number\",\n    value: \"1024\"\n}, {\n    type:\"+\"\n    value: \"+\"\n}, {\n    type:\"Number\",\n    value: \"2\"\n}, {\n    type:\"*\"\n    value: \"*\"\n}, {\n    type:\"Number\",\n    value: \"256\"\n}, {\n    type:\"EOF\"\n}];\n</code></pre><p>每个产生式对应着一个函数，例如：根据产生式，我们的AdditiveExpression需要处理三种情况：</p><pre><code class=\"language-BNF\">&lt;AdditiveExpression&gt; ::= \n    &lt;MultiplicativeExpression&gt;\n    |&lt;AdditiveExpression&gt;&lt;+&gt;&lt;MultiplicativeExpression&gt;\n    |&lt;AdditiveExpression&gt;&lt;-&gt;&lt;MultiplicativeExpression&gt;\n</code></pre><p>那么AddititveExpression中就要写三个if分支，来处理三种情况。</p><p>AdditiveExpression的写法是根传入的节点，利用产生式合成新的节点</p><pre><code class=\"language-JavaScript\">function AdditiveExpression(source){\n    if(source[0].type === \"MultiplicativeExpression\") {\n        let node = {\n            type:\"AdditiveExpression\",\n            children:[source[0]]\n        }\n        source[0] = node;\n        return node;\n    } \n    if(source[0].type === \"AdditiveExpression\" &amp;&amp; source[1].type === \"+\") {\n        let node = {\n            type:\"AdditiveExpression\",\n            operator:\"+\",\n            children:[source.shift(), source.shift(), MultiplicativeExpression(source)]\n        }\n        source.unshift(node);\n    }\n    if(source[0].type === \"AdditiveExpression\" &amp;&amp; source[1].type === \"-\") {\n        let node = {\n            type:\"AdditiveExpression\",\n            operator:\"-\",\n            children:[source.shift(), source.shift(), MultiplicativeExpression(source)]\n        }\n        source.unshift(node);\n    }\n}\n</code></pre><p>那么下一步我们就把解析好的token传给我们的顶层处理函数Expression。</p><pre><code>Expression(tokens);\n</code></pre><p>接下来，我们看Expression该怎么处理它。</p><p>我们Expression收到第一个token，是个Number，这个时候，Expression就傻了，这是因为产生式只告诉我们，收到了 AdditiveExpression 怎么办。</p><p>这个时候，我们就需要对产生式的首项层层展开，根据所有可能性调用相应的处理函数，这个过程在编译原理中称为求“closure”。</p><pre><code class=\"language-JavaScript\">function Expression(source){\n    if(source[0].type === \"AdditiveExpression\" &amp;&amp; source[1] &amp;&amp; source[1].type === \"EOF\" ) {\n        let node = {\n            type:\"Expression\",\n            children:[source.shift(), source.shift()]\n        }\n        source.unshift(node);\n        return node;\n    }\n    AdditiveExpression(source);\n    return Expression(source);\n}\nfunction AdditiveExpression(source){\n    if(source[0].type === \"MultiplicativeExpression\") {\n        let node = {\n            type:\"AdditiveExpression\",\n            children:[source[0]]\n        }\n        source[0] = node;\n        return AdditiveExpression(source);\n    } \n    if(source[0].type === \"AdditiveExpression\" &amp;&amp; source[1] &amp;&amp; source[1].type === \"+\") {\n        let node = {\n            type:\"AdditiveExpression\",\n            operator:\"+\",\n            children:[]\n        }\n        node.children.push(source.shift());\n        node.children.push(source.shift());\n        MultiplicativeExpression(source);\n        node.children.push(source.shift());\n        source.unshift(node);\n        return AdditiveExpression(source);\n    }\n    if(source[0].type === \"AdditiveExpression\" &amp;&amp; source[1] &amp;&amp; source[1].type === \"-\") {\n        let node = {\n            type:\"AdditiveExpression\",\n            operator:\"-\",\n            children:[]\n        }\n        node.children.push(source.shift());\n        node.children.push(source.shift());\n        MultiplicativeExpression(source);\n        node.children.push(source.shift());\n        source.unshift(node);\n        return AdditiveExpression(source);\n    }\n    if(source[0].type === \"AdditiveExpression\")\n        return source[0];\n    MultiplicativeExpression(source);\n    return AdditiveExpression(source);\n}\nfunction MultiplicativeExpression(source){\n    if(source[0].type === \"Number\") {\n        let node = {\n            type:\"MultiplicativeExpression\",\n            children:[source[0]]\n        }\n        source[0] = node;\n        return MultiplicativeExpression(source);\n    } \n    if(source[0].type === \"MultiplicativeExpression\" &amp;&amp; source[1] &amp;&amp; source[1].type === \"*\") {\n        let node = {\n            type:\"MultiplicativeExpression\",\n            operator:\"*\",\n            children:[]\n        }\n        node.children.push(source.shift());\n        node.children.push(source.shift());\n        node.children.push(source.shift());\n        source.unshift(node);\n        return MultiplicativeExpression(source);\n    }\n    if(source[0].type === \"MultiplicativeExpression\"&amp;&amp; source[1] &amp;&amp; source[1].type === \"/\") {\n        let node = {\n            type:\"MultiplicativeExpression\",\n            operator:\"/\",\n            children:[]\n        }\n        node.children.push(source.shift());\n        node.children.push(source.shift());\n        node.children.push(source.shift());\n        source.unshift(node);\n        return MultiplicativeExpression(source);\n    }\n    if(source[0].type === \"MultiplicativeExpression\")\n        return source[0];\n\n    return MultiplicativeExpression(source);\n};\n\nvar source = [{\n    type:\"Number\",\n    value: \"3\"\n}, {\n    type:\"*\",\n    value: \"*\"\n}, {\n    type:\"Number\",\n    value: \"300\"\n}, {\n    type:\"+\",\n    value: \"+\"\n}, {\n    type:\"Number\",\n    value: \"2\"\n}, {\n    type:\"*\",\n    value: \"*\"\n}, {\n    type:\"Number\",\n    value: \"256\"\n}, {\n    type:\"EOF\"\n}];\nvar ast = Expression(source);\n\nconsole.log(ast);\n</code></pre><h2>解释执行</h2><p>得到了AST之后，最困难的一步我们已经解决了。这里我们就不对这颗树做任何的优化和精简了，那么接下来，直接进入执行阶段。我们只需要对这个树做遍历操作执行即可。</p><p>我们根据不同的节点类型和其它信息，写if分别处理即可：</p><pre><code class=\"language-JavaScript\">\nfunction evaluate(node) {\n    if(node.type === \"Expression\") {\n        return evaluate(node.children[0])\n    }\n    if(node.type === \"AdditiveExpression\") {\n        if(node.operator === '-') {\n            return evaluate(node.children[0]) - evaluate(node.children[2]);\n        }\n        if(node.operator === '+') {\n            return evaluate(node.children[0]) + evaluate(node.children[2]);\n        }\n        return evaluate(node.children[0])\n    }\n    if(node.type === \"MultiplicativeExpression\") {\n        if(node.operator === '*') {\n            return evaluate(node.children[0]) * evaluate(node.children[2]);\n        }\n        if(node.operator === '/') {\n            return evaluate(node.children[0]) / evaluate(node.children[2]);\n        }\n        return evaluate(node.children[0])\n    }\n    if(node.type === \"Number\") {\n        return Number(node.value);\n    }\n}\n</code></pre><h2>总结</h2><p>在这个小实验中，我们通过一个小实验学习了编译原理的基本知识，小实验的目的是帮助你理解JavaScript课程中涉及到的编译原理基本概念，它离真正的编译原理学习还有很大的差距。</p><p>通过实验，我们了解了产生式、词法分析、语法分析和解释执行的过程。</p><p>最后留给你一些挑战，你可以根据自己的水平选择：</p><ul>\n<li>补全emmitToken，使得我们的代码能完整工作起来。</li>\n<li>为四则运算加入小数。</li>\n<li>引入负数。</li>\n<li>添加括号功能。</li>\n</ul><p>欢迎写好的同学留言给我。</p><p></p>","comments":[{"had_liked":false,"id":79870,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1553566311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"126107617895","product_id":100023201,"comment_content":"* 以前我只大概了解一般的做法是消除文法中的左递归，这一课让我知道原来还可以通过“层层展开”去处理。<br>* 词法分析我尝试了正则的方式<br>* 括号的处理费了些时间，这里我是修改了文法（感觉我的 Expression 产生式[在源码注释里]怪怪的，希望 winter 老师有时间的话可以指点一下），另一种做法是，先把中缀表达式变成前缀表达式<br>* 学习一些编译原理的知识还是很有必要也很有趣的，可以去写一些webpack的loader啊，插件啊，vscode的插件等等<br>https:&#47;&#47;github.com&#47;aimergenge&#47;arithmetic-executor","like_count":29},{"had_liked":false,"id":111839,"user_name":"北天魔狼","can_delete":false,"product_type":"c1","uid":1188144,"ip_address":"","ucode":"C22623ECEB8DBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/30/8ecce1e1.jpg","comment_is_top":false,"comment_ctime":1562629674,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"70282106410","product_id":100023201,"comment_content":"感觉每一篇都需要看三遍，才能看懂一点写的是啥。后端入行，大前端，全栈，架构师。路还很长，楼上的：日拱一卒，共勉","like_count":17,"discussions":[{"author":{"id":2189600,"avatar":"https://static001.geekbang.org/account/avatar/00/21/69/20/5cba0aa5.jpg","nickname":"静坐常思己过，闲谈莫论人非","note":"","ucode":"01D40CD71BD51C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306954,"discussion_content":"枯了三遍也不一定能懂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600430347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314538,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0e/ea/16291abc.jpg","nickname":"better man","note":"","ucode":"89E50F6762822F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3715,"discussion_content":"同卒","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564730791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/12/b1/3a112b27.jpg","nickname":"段帅帅","note":"","ucode":"2675BC0BE154E8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563956,"discussion_content":"卷起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650118159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79329,"user_name":"Bojack","can_delete":false,"product_type":"c1","uid":1251080,"ip_address":"","ucode":"A57E552845DB28","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoLw2qjwoaVCDq8BqCcXOibyTG3rxiaJlDy2lt62IkiaDrrHeVwq4Pe8RpBbYJTIiadyicZ7InBCLCjJtQ/132","comment_is_top":false,"comment_ctime":1553436018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31618207090","product_id":100023201,"comment_content":"实现了小数与负数的编译器 https:&#47;&#47;gist.github.com&#47;OPY-bbt&#47;8ee387122550326f60592b94b7908d19","like_count":7},{"had_liked":false,"id":78690,"user_name":"翰弟","can_delete":false,"product_type":"c1","uid":1144772,"ip_address":"","ucode":"42149ACC75AA08","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/EJZoM46wR6QqTeibhPZsO5wJTeUia4RndGicWfDZLw153WibjsnJXqEtGZICxAa8icb36pDkficTic3FViaySd1z9HmQBw/132","comment_is_top":false,"comment_ctime":1553218741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31617989813","product_id":100023201,"comment_content":"日拱一卒","like_count":7},{"had_liked":false,"id":159568,"user_name":"缺个豆饼吗","can_delete":false,"product_type":"c1","uid":1390212,"ip_address":"","ucode":"EF050C820E4E17","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/84/e19b05dd.jpg","comment_is_top":false,"comment_ctime":1575687395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23050523875","product_id":100023201,"comment_content":"之前写了一个JS的编译器的词法和语法分析。可以处理变量声明，加减乘除运算及赋值运算。<br>https:&#47;&#47;github.com&#47;yuguomin&#47;my-compiler","like_count":5},{"had_liked":false,"id":78381,"user_name":"一条不会挣扎的咸鱼🐟","can_delete":false,"product_type":"c1","uid":1374267,"ip_address":"","ucode":"AE37E9FAD55F33","user_header":"https://static001.geekbang.org/account/avatar/00/14/f8/3b/a338f925.jpg","comment_is_top":false,"comment_ctime":1553136160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23027972640","product_id":100023201,"comment_content":"想问下老师有没有推荐的国外论坛|YouTube作者|个人博客","like_count":5},{"had_liked":false,"id":123749,"user_name":"chang.xu","can_delete":false,"product_type":"c1","uid":1244613,"ip_address":"","ucode":"51C230B833A214","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/c5/1f13bed2.jpg","comment_is_top":false,"comment_ctime":1565750935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18745620119","product_id":100023201,"comment_content":"标记，需要基础再回来","like_count":4},{"had_liked":false,"id":104822,"user_name":"Rango","can_delete":false,"product_type":"c1","uid":1158889,"ip_address":"","ucode":"78D05A106F049E","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/e9/48703ee9.jpg","comment_is_top":false,"comment_ctime":1560848214,"is_pvip":false,"replies":[{"id":"58943","content":"怎么解析呢 难道不是跟语法分析一样？","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1574222272,"ip_address":"","comment_id":104822,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18740717398","product_id":100023201,"comment_content":"这边把中缀表达式解析成后缀表达式会不会更容易理解一点？","like_count":4,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454440,"discussion_content":"怎么解析呢 难道不是跟语法分析一样？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574222272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140750,"user_name":"Glee","can_delete":false,"product_type":"c1","uid":1388875,"ip_address":"","ucode":"AA0D428E34D29E","user_header":"https://static001.geekbang.org/account/avatar/00/15/31/4b/0f5b3a0a.jpg","comment_is_top":false,"comment_ctime":1571042277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14455944165","product_id":100023201,"comment_content":"日拱一卒","like_count":3},{"had_liked":false,"id":80515,"user_name":"爱的神","can_delete":false,"product_type":"c1","uid":1373857,"ip_address":"","ucode":"780400297FB83A","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/a1/debef255.jpg","comment_is_top":false,"comment_ctime":1553673706,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14438575594","product_id":100023201,"comment_content":"大三正在学习编译原理，目前仅能看懂词法分析那些，后面还不能看懂。补全了emmitToken函数。<br>var tokens = []<br>emmitToken(type，value){<br>   tokens.push({<br>      type :  type，<br>      value:  value<br>   })<br>}<br>不知道对不对🤔","like_count":3,"discussions":[{"author":{"id":1645413,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/OWO43KiahibaWnZWkEzXfNQCAqAvVNia44HLxzaNbPKZxiaic3ameJ72dLros26ibxuCL1B5pl7MRlOVrqutNsTOXegQ/132","nickname":"JY","note":"","ucode":"54DF39E40C0F20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7959,"discussion_content":"还有EOF要处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567740389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78856,"user_name":"leslee","can_delete":false,"product_type":"c1","uid":1384326,"ip_address":"","ucode":"DB1CBF9F8D16BF","user_header":"https://static001.geekbang.org/account/avatar/00/15/1f/86/3a7eeac4.jpg","comment_is_top":false,"comment_ctime":1553258807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14438160695","product_id":100023201,"comment_content":"BNF 那里有没有详细一点的资料呢 或者有没有更加通俗的写法？ 看不懂了……","like_count":3},{"had_liked":false,"id":78301,"user_name":"Huayra","can_delete":false,"product_type":"c1","uid":1031596,"ip_address":"","ucode":"5F8F6EF2783C1B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bd/ac/c9154dfe.jpg","comment_is_top":false,"comment_ctime":1553128066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10143062658","product_id":100023201,"comment_content":"硬啃龙书，对编程语言的理解更上一层楼","like_count":2},{"had_liked":false,"id":267915,"user_name":"Geek_e6f5a9","can_delete":false,"product_type":"c1","uid":2360854,"ip_address":"","ucode":"028C9559ACC63D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BWDhMILusuficY2zo10KiaetDPjW08aBJ5sn7cLy2VV91hicacriaibDoqDAexLc0Mr4fnwpbllOLZ0BEFib3tic5WtHA/132","comment_is_top":false,"comment_ctime":1607995819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5902963115","product_id":100023201,"comment_content":"感觉像在看天书😭，特别是解析Expression求closure那部分代码，请问winter老师学习这个的意义是什么？怎样才能看懂？","like_count":1},{"had_liked":false,"id":265422,"user_name":"从新开始","can_delete":false,"product_type":"c1","uid":1736797,"ip_address":"","ucode":"9BDA8C16C24321","user_header":"https://static001.geekbang.org/account/avatar/00/1a/80/5d/b870bb08.jpg","comment_is_top":false,"comment_ctime":1606894284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5901861580","product_id":100023201,"comment_content":"日拱一卒","like_count":1},{"had_liked":false,"id":164195,"user_name":"多多","can_delete":false,"product_type":"c1","uid":1344516,"ip_address":"","ucode":"4040EDA251F971","user_header":"https://static001.geekbang.org/account/avatar/00/14/84/04/4607749e.jpg","comment_is_top":false,"comment_ctime":1576907646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871874942","product_id":100023201,"comment_content":"通过Symbol(&#39;EOF&#39;)怎么拿到&#39;EOF&#39;？是不是应该用Symbol.for(&#39;EOF&#39;)？","like_count":1},{"had_liked":false,"id":78592,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1553180589,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5848147885","product_id":100023201,"comment_content":"老师，做后端的感觉越到后面越看不到，请问该怎么做，求解","like_count":1,"discussions":[{"author":{"id":1610726,"avatar":"https://static001.geekbang.org/account/avatar/00/18/93/e6/fd94c378.jpg","nickname":"545龙哥哥","note":"","ucode":"3B74276B771817","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212232,"discussion_content":"没事，前端同学表示也看不懂QAQ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584949282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353917,"user_name":"kkk丶kk","can_delete":false,"product_type":"c1","uid":3078538,"ip_address":"云南","ucode":"0FA99C7B85C867","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/oltXBXuibxC3rVKOLn9NweNETjP510mItykNdS0daSZs1qyTRjzDXGtWNzUYwe0iaRRXsOZygk8d9x3HLqUXZffA/132","comment_is_top":false,"comment_ctime":1659925959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659925959","product_id":100023201,"comment_content":"感觉和前端的模板引擎差不多，都是从字符串解析到token，最后再解析token","like_count":0},{"had_liked":false,"id":333578,"user_name":"木子李李","can_delete":false,"product_type":"c1","uid":2852517,"ip_address":"","ucode":"F8EF397893AA4E","user_header":"","comment_is_top":false,"comment_ctime":1644411283,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644411283","product_id":100023201,"comment_content":"一篇更比一篇难","like_count":0},{"had_liked":false,"id":251318,"user_name":"zly","can_delete":false,"product_type":"c1","uid":2175260,"ip_address":"","ucode":"BBBCA6CD16FFBF","user_header":"https://static001.geekbang.org/account/avatar/00/21/31/1c/51f4d08e.jpg","comment_is_top":false,"comment_ctime":1601459772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601459772","product_id":100023201,"comment_content":"<br>&#47;**<br> * number转MultiplicativeExpression对象后，判断是否有乘除，有就合成新的MultiplicativeExpression<br> * @param {Token[]} tokenList<br> *&#47;<br>function MultiplicativeExpression(tokenList: Token[]): Token {<br>  let first = tokenList[0];<br>  let second = tokenList[1];<br>  if (first.type == &quot;number&quot;) {<br>    let newToken: Token = {<br>      type: &quot;MultiplicativeExpression&quot;,<br>      children: [first],<br>    };<br>    tokenList[0] = newToken;<br>  } else if (<br>    first.type == &quot;MultiplicativeExpression&quot; &amp;&amp;<br>    second &amp;&amp;<br>    (second.type == &quot;&#47;&quot; || second.type == &quot;*&quot;)<br>  ) {<br>    let newToken: Token = {<br>      type: &quot;MultiplicativeExpression&quot;,<br>      operating: second.type,<br>      children: [],<br>    };<br>    newToken.children.push(tokenList.shift());<br>    tokenList.shift();<br>    newToken.children.push(tokenList.shift());<br>    tokenList.unshift(newToken);<br>  } else if (first.type == &quot;MultiplicativeExpression&quot;) {<br>    return first;<br>  }<br>  return MultiplicativeExpression(tokenList);<br>}<br><br>&#47;**<br> * 根据ast语法树进行计算并返回结果<br> * @param {Token[]} tokenList<br> *&#47;<br>function executeTree(token: Token): number {<br>  if (token.type == &quot;number&quot;) {<br>    return Number(token.value);<br>  }<br>  let first = token.children[0];<br>  let second = token.children[1];<br>  if (token.type == &quot;AdditiveExpression&quot;) {<br>    if (token.operating) {<br>      let firstResult = executeTree(first);<br>      let secondResult = second ? executeTree(second) : 0;<br>      return firstResult + (token.operating == &quot;-&quot; ? -1 : 1) * secondResult;<br>    } else {<br>      return executeTree(first);<br>    }<br>  }<br>  if (token.type == &quot;MultiplicativeExpression&quot;) {<br>    let firstResult = executeTree(first);<br>    if (token.operating == &quot;&#47;&quot;) {<br>      return firstResult &#47; (second ? executeTree(second) : 1);<br>    } else if (token.operating == &quot;*&quot;) {<br>      return firstResult * (second ? executeTree(second) : 1);<br>    } else {<br>      return firstResult;<br>    }<br>  }<br>  if (token.type == &quot;Expression&quot;) {<br>    return executeTree(first);<br>  }<br>}<br><br>&#47;&#47;test code<br>let result = arithmeticEval(&quot;1.4+2.2*3+3&#47;3&quot;);<br>&#47;&#47;expected value<br>console.log(result);<br>9;<br>","like_count":0},{"had_liked":false,"id":251317,"user_name":"zly","can_delete":false,"product_type":"c1","uid":2175260,"ip_address":"","ucode":"BBBCA6CD16FFBF","user_header":"https://static001.geekbang.org/account/avatar/00/21/31/1c/51f4d08e.jpg","comment_is_top":false,"comment_ctime":1601459762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601459762","product_id":100023201,"comment_content":"&#47;**<br> * MultiplicativeExpression对象转AdditiveExpression对象后，判断是否有加减，有加减就合成新的AdditiveExpression<br> * @param {Token[]} tokenList<br> *&#47;<br>function AdditiveExpression(tokenList: Token[]): Token {<br>  let first = tokenList[0];<br>  let second = tokenList[1];<br>  if (first.type == &quot;MultiplicativeExpression&quot;) {<br>    let newToken: Token = {<br>      type: &quot;AdditiveExpression&quot;,<br>      children: [first],<br>    };<br>    tokenList[0] = newToken;<br>  } else if (<br>    first.type == &quot;AdditiveExpression&quot; &amp;&amp;<br>    second &amp;&amp;<br>    (second.type == &quot;+&quot; || second.type == &quot;-&quot;)<br>  ) {<br>    let newToken: Token = {<br>      type: &quot;AdditiveExpression&quot;,<br>      operating: second.type,<br>      children: [],<br>    };<br>    newToken.children.push(tokenList.shift());<br>    tokenList.shift();<br>    MultiplicativeExpression(tokenList);<br>    newToken.children.push(tokenList.shift());<br>    tokenList.unshift(newToken);<br>  } else if (first.type == &quot;AdditiveExpression&quot;) {<br>    return first;<br>  } else {<br>    MultiplicativeExpression(tokenList);<br>  }<br>  return AdditiveExpression(tokenList);<br>}","like_count":0},{"had_liked":false,"id":251316,"user_name":"zly","can_delete":false,"product_type":"c1","uid":2175260,"ip_address":"","ucode":"BBBCA6CD16FFBF","user_header":"https://static001.geekbang.org/account/avatar/00/21/31/1c/51f4d08e.jpg","comment_is_top":false,"comment_ctime":1601459732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601459732","product_id":100023201,"comment_content":"&#47;&#47;初步目标：不带括号的加减乘除的四则运算执行器<br>type Operating = &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;&#47;&quot;;<br><br>type TokenType =<br>  | &quot;number&quot;<br>  | &quot;EOF&quot;<br>  | &quot;MultiplicativeExpression&quot;<br>  | &quot;AdditiveExpression&quot;<br>  | &quot;Expression&quot;<br>  | Operating;<br><br>interface Token {<br>  type: TokenType;<br>  value?: string;<br>  children?: Token[];<br>  operating?: Operating;<br>}<br>&#47;&#47;token数<br>let tokenList: Token[] = [];<br>let numberToken = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;0&quot;, &quot;.&quot;];<br>let operatingToken: string[] = [&quot;+&quot;, &quot;-&quot;, &quot;&#47;&quot;, &quot;*&quot;];<br>&#47;**<br> * 自己实现四则运算的一个eval执行器<br> *<br> * @param {string} str<br> *&#47;<br>function arithmeticEval(str: string): number {<br>  tokenList = [];<br>  let tokenStateMachine = new TokenStateMachine(str);<br>  tokenStateMachine.lexicalAnalysis();<br>  tokenList.push({ type: &quot;EOF&quot; });<br>  let tree = Expression(tokenList);<br>  let result = executeTree(tree);<br>  return result;<br>}<br><br>&#47;**<br> * token状态机<br> * @class TokenStateMachine<br> *&#47;<br>class TokenStateMachine {<br>  state: () =&gt; void;<br>  index: number = 0;<br>  str: string;<br>  numberStr = &quot;&quot;;<br>  constructor(str: string) {<br>    this.str = str;<br>    this.index = 0;<br>    this.state = this.start;<br>  }<br>  &#47;**<br>   *  词法分析<br>   * @memberof TokenStateMachine<br>   *&#47;<br>  lexicalAnalysis() {<br>    while (this.index &lt;= this.str.length) {<br>      this.state();<br>    }<br>  }<br>  start() {<br>    let key = this.str[this.index];<br>    if (numberToken.includes(key)) {<br>      this.numberStr = &quot;&quot;;<br>      this.numberStr += key;<br>      this.state = this.number;<br>    } else if (operatingToken.includes(key)) {<br>      emitToken(key as TokenType, key);<br>    }<br>    this.index += 1;<br>  }<br>  number() {<br>    let key = this.str[this.index];<br>    if (numberToken.includes(key)) {<br>      this.numberStr += key;<br>      this.index += 1;<br>    } else {<br>      emitToken(&quot;number&quot;, this.numberStr);<br>      this.state = this.start;<br>    }<br>  }<br>}<br>&#47;**<br> * 触发token，增加token到token树中<br> * @param {TokenType} tokenType<br> * @param {string} key<br> *&#47;<br>function emitToken(tokenType: TokenType, key: string) {<br>  tokenList.push({<br>    type: tokenType,<br>    value: key,<br>  });<br>}","like_count":0},{"had_liked":false,"id":205228,"user_name":"三皮","can_delete":false,"product_type":"c1","uid":1353061,"ip_address":"","ucode":"D0087B34A24387","user_header":"https://static001.geekbang.org/account/avatar/00/14/a5/65/ca607ded.jpg","comment_is_top":false,"comment_ctime":1586574069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586574069","product_id":100023201,"comment_content":"稍后再看","like_count":0},{"had_liked":false,"id":188525,"user_name":"高宝军","can_delete":false,"product_type":"c1","uid":1353773,"ip_address":"","ucode":"B4B3EBE191659A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xpAsb3hl87UbMPCkYhgdvC3pSx2WYaic9vu8qibksibttGveDbibohibsicxk0AQayNriciaeV3HYrCEd0dQkp4Q83nTqQ/132","comment_is_top":false,"comment_ctime":1584364581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584364581","product_id":100023201,"comment_content":"留的挑战是不是只有最后一个添加括号的需要在closure里处理，小数和负数的在词法分析里就可以？","like_count":0},{"had_liked":false,"id":91919,"user_name":"芬芬颜","can_delete":false,"product_type":"c1","uid":1474173,"ip_address":"","ucode":"AA88E3951519E7","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/7d/d3345d7f.jpg","comment_is_top":false,"comment_ctime":1557134272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557134272","product_id":100023201,"comment_content":"产生式如下<br>Expr = Add &lt;EOF&gt;<br>Add = Multiply | Add + Multiply | Add - Multiply<br>Multiply = Num | Multiply * Multiply | Multiply &#47; Multiply | ( Add )<br>Num = 有理数<br><br>对于括号的处理，关键在MultiplicativeExpression方法中判断运算符左右两侧的变量是否为(Add)<br>function MultiplicativeExpression(source) {<br>  if (source[0].type === &quot;Number&quot;) {<br>    let node = {<br>      type: &quot;MultiplicativeExpression&quot;,<br>      children: [source[0]]<br>    }<br>    source[0] = node;<br>    return MultiplicativeExpression(source);<br>  }<br>  if (source[0].type === &quot;parentness&quot;) {<br>    let addExpr = [];<br>    let i = 0;<br>    while (i++ &lt; source.length &amp;&amp; source[i].type !== &quot;parenthese&quot;) {<br>      addExpr.push(source[i]);<br>    }<br>    source.splice(0, addExpr.length + 2, AdditiveExpression([...addExpr]));<br>    source[0].type = &quot;MultiplicativeExpression&quot;;<br>  }<br>  if (source[2] &amp;&amp; source[2].type === &quot;parenthese&quot;) {<br>    let addExpr = [];<br>    let i = 2;<br>    while (i++ &lt; source.length &amp;&amp; source[i].type !== &quot;parenthese&quot;) {<br>      addExpr.push(source[i]);<br>    }<br>    source.splice(2, addExpr.length + 2, AdditiveExpression([...addExpr]));<br>    source[2].type = &quot;MultiplicativeExpression&quot;;<br>  }<br>...<br>","like_count":0},{"had_liked":false,"id":79283,"user_name":"疯二中","can_delete":false,"product_type":"c1","uid":1058296,"ip_address":"","ucode":"51DE889B3C2413","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/f8/4a6062b1.jpg","comment_is_top":false,"comment_ctime":1553424444,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553424444","product_id":100023201,"comment_content":"涨知识了，BNF和LL真是精妙","like_count":0}]}