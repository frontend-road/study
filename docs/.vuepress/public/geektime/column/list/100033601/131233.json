{"id":131233,"title":"13 | 垃圾回收：垃圾数据是如何自动回收的？","content":"<p>在<a href=\"https://time.geekbang.org/column/article/129596\">上一篇文章</a>中，我们提到了JavaScript中的数据是如何存储的，并通过例子分析了<strong>原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的</strong>。通过这种分配方式，我们解决了数据的内存分配的问题。</p><p>不过有些数据被使用之后，可能就不再需要了，我们把这种数据称为<strong>垃圾数据</strong>。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要<strong>对这些垃圾数据进行回收，以释放有限的内存空间</strong>。</p><h2>不同语言的垃圾回收策略</h2><p>通常情况下，垃圾数据回收分为<strong>手动回收</strong>和<strong>自动回收</strong>两种策略。</p><p>如C/C++就是使用手动回收策略，<strong>何时分配内存、何时销毁内存都是由代码控制的</strong>，你可以参考下面这段C代码：</p><pre><code>//在堆中分配内存\nchar* p =  (char*)malloc(2048);  //在堆空间中分配2048字节的空间，并将分配后的引用地址保存到p中\n \n //使用p指向的内存\n {\n   //....\n }\n \n//使用结束后，销毁这段内存\nfree(p)；\np = NULL；\n</code></pre><p>从上面这段C代码可以看出来，要使用堆中的一块空间，我们需要先调用mallco函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用free函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用free函数来销毁，那么这种情况就被称为<strong>内存泄漏</strong>。</p><p>另外一种使用的是自动垃圾回收的策略，如JavaScript、Java、Python等语言，<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p><!-- [[[read_end]]] --><p>对于JavaScript而言，也正是这个“自动”释放资源的特性带来了很多困惑，也让一些JavaScript开发者误以为可以不关心内存管理，这是一个很大的误解。</p><p>那么在本文，我们将围绕“JavaScript的数据是如何回收的”这个话题来展开探讨。因为数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍“栈中的垃圾数据”和“堆中的垃圾数据”是如何回收的。</p><h2>调用栈中的数据是如何回收的</h2><p>首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p><pre><code>function foo(){\n    var a = 1\n    var b = {name:&quot;极客邦&quot;}\n    function showName(){\n      var c = 2\n      var d = {name:&quot;极客时间&quot;}\n    }\n    showName()\n}\nfoo()\n</code></pre><p>当执行到第6行代码时，其调用栈和堆空间状态图如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/b0/d807ca19c2c8853ef5a38dca0fb79ab0.jpg?wh=6818*4327\" alt=\"\"></p><center><span class=\"reference\">执行到showName函数时的内存模型</span></center><p>从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当foo函数执行结束之后，foo函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。</p><p>在<a href=\"https://time.geekbang.org/column/article/129596\">上篇文章</a>中，我们简单介绍过了，如果执行到showName函数时，那么JavaScript引擎会创建showName函数的执行上下文，并将showName函数的执行上下文压入到调用栈中，最终执行到showName函数时，其调用栈就如上图所示。与此同时，还有一个<strong>记录当前执行状态的指针（称为ESP）</strong>，指向调用栈中showName函数的执行上下文，表示当前正在执行showName函数。</p><p>接着，当showName函数执行完成之后，函数执行流程就进入了foo函数，那这时就需要销毁showName函数的执行上下文了。ESP这时候就帮上忙了，JavaScript会将ESP下移到foo函数的执行上下文，<strong>这个下移操作就是销毁showName函数执行上下文的过程</strong>。</p><p>你可能会有点懵，ESP指针向下移动怎么就能把showName的执行上下文销毁了呢？具体你可以看下面这张移动ESP前后的对比图：</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/f3/b899cb27c0d92c31f9377db59939aaf3.jpg?wh=8000*4320\" alt=\"\"></p><center><span class=\"reference\">从栈中回收showName执行上下文</span></center><p>从图中可以看出，当showName函数执行结束之后，ESP向下移动到foo函数的执行上下文中，上面showName的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当foo函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p><p>所以说，当一个函数执行结束之后，<strong>JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文</strong>。</p><h2>堆中的数据是如何回收的</h2><p>通过上面的讲解，我想现在你应该已经知道，当上面那段代码的foo函数执行结束之后，ESP应该是指向全局执行上下文的，那这样的话，showName函数和foo函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/8c/e80ff553417572f77973b08256b6928c.png?wh=1142*773\" alt=\"\"></p><center><span class=\"reference\">foo函数执行结束后的内存状态</span></center><p>从图中可以看出，1003和1050这两块内存依然被占用。<strong>要回收堆中的垃圾数据，就需要用到JavaScript中的垃圾回收器了</strong>。</p><p>所以，接下来我们就来通过Chrome的JavaScript引擎V8来分析下堆中的垃圾数据是如何回收的。</p><h3>代际假说和分代收集</h3><p>不过在正式介绍V8是如何实现回收之前，你需要先学习下<strong>代际假说（The Generational Hypothesis）</strong>的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</p><p><strong>代际假说</strong>有以下两个特点：</p><ul>\n<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>\n<li>第二个是不死的对象，会活得更久。</li>\n</ul><p>其实这两个特点不仅仅适用于JavaScript，同样适用于大多数的动态语言，如Java、Python等。</p><p>有了代际假说的基础，我们就可以来探讨V8是如何实现垃圾回收的了。</p><p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p><p>所以，在V8中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p><p>新生区通常只支持1～8M的容量，而老生区支持的容量就大很多了。对于这两块区域，V8分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p><ul>\n<li><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></li>\n<li><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></li>\n</ul><h3>垃圾回收器的工作流程</h3><p>现在你知道了V8把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实<strong>不论什么类型的垃圾回收器，它们都有一套共同的执行流程</strong>。</p><p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p><p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p><p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p><p>那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。</p><h3>副垃圾回收器</h3><p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p><p>新生代中用<strong>Scavenge算法</strong>来处理。所谓Scavenge算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png?wh=1142*550\" alt=\"\"></p><center><span class=\"reference\">新生区要划分为对象区域和空闲区域</span></center><p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p><p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p><p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p><p>由于新生代中采用的Scavenge算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong>。</p><p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p><h3>主垃圾回收器</h3><p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p><p>由于老生区的对象比较大，若要在老生区中使用Scavenge算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用<strong>标记-清除（Mark-Sweep）</strong>的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p><p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p><p>比如最开始的那段代码，当showName函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/69/6c8361d3e52c1c37a06699ed94652e69.png?wh=1142*550\" alt=\"\"></p><center><span class=\"reference\">标记过程</span></center><p>从上图你可以大致看到垃圾数据的标记过程，当showName函数执行结束之后，ESP向下移动，指向了foo函数的执行上下文，这时候如果遍历调用栈，是不会找到引用1003地址的变量，也就意味着1003这块数据为垃圾数据，被标记为红色。由于1050这块数据被变量b引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</p><p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/85/d015db8ad0df7f0ccb1bdb8e31f96e85.png?wh=1142*564\" alt=\"\"></p><center><span class=\"reference\">标记清除过程</span></center><p>上面的标记过程和清除过程就是标记-清除算法，不过对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<strong>标记-整理（Mark-Compact）</strong>，这个标记过程仍然与标记-清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/65/8c/652bd2df726d0aa5e67fe8489f39a18c.png?wh=1142*441\" alt=\"\"></p><center><span class=\"reference\">标记整理过程</span></center><h3>全停顿</h3><p>现在你知道了V8是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于JavaScript是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p><p>比如堆中的数据有1.5GB，V8实现一次完整的垃圾回收需要1秒以上的时间，这也是由于垃圾回收而引起JavaScript线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/98/0c/9898646a08b46bce4f12f918f3c1e60c.png?wh=1142*332\" alt=\"\"></p><center><span class=\"reference\">全停顿</span></center><p>在V8新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了200毫秒，在这200毫秒内，主线程是不能做其他事情的。比如页面正在执行一个JavaScript动画，因为垃圾回收器在工作，就会导致这个动画在这200毫秒内无法执行的，这将会造成页面的卡顿现象。</p><p>为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/de/e7/de117fc96ae425ed90366e9060aa14e7.png?wh=1142*366\" alt=\"\"></p><center><span class=\"reference\">增量标记</span></center><p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的JavaScript任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p><h2>总结</h2><p>好了，今天就讲到这里，下面我们就来总结下今天的主要内容。</p><p>首先我们介绍了不同语言的垃圾回收策略，然后又说明了栈中的数据是如何回收的，最后重点讲解了JavaScript中的垃圾回收器是如何工作的。</p><p>从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</p><p>其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。</p><p>生活中处理事情的原则也与之类似，古人很早就说过“两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。</p><h2>思考时间</h2><p>今天留给你的思考题是：你是如何判断JavaScript中内存泄漏的？可以结合一些你在工作中避免内存泄漏的方法。</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>","comments":[{"had_liked":false,"id":130433,"user_name":"mfist","can_delete":false,"product_type":"c1","uid":1373624,"ip_address":"","ucode":"4F99F422C23FB4","user_header":"https://static001.geekbang.org/account/avatar/00/14/f5/b8/9f165f4b.jpg","comment_is_top":false,"comment_ctime":1567466086,"is_pvip":false,"replies":[{"id":"48956","content":"总结很好，还可以通过Chrome开发者工具中的Performance来观察。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567523996,"ip_address":"","comment_id":130433,"utype":1}],"discussion_count":1,"race_medal":0,"score":"443949097574","product_id":100033601,"comment_content":"1. 如何判断内存泄漏的？一般是感官上的长时间运行页面卡顿，猜可能会有内存泄漏。通过DynaTrace（IE）profiles等工具一段时间收集数据，观察对象的使用情况。然后判断是否存在内存泄漏。修改后验证<br>2. 工作中避免内存泄漏方法：确定不使用的临时变量置为null，当前es6普及场景下少使用闭包也是一种方法。<br><br>今日总结<br>垃圾回收策略一般分为手动回收和自动回收，java python JavaScript等高级预言为了减轻程序员负担和出错概率采用了自动回收策略。JavaScript的原始类型数据和引用数据是分别存储在栈和椎中的，由于栈和堆分配空间大小差异，垃圾回收方式也不一样。栈中分配空间通过ESP的向下移动销毁保存在栈中数据；堆中垃圾回收主要通过副垃圾回收器（新生代）和主垃圾回收器（老生代）负责的，副垃圾回收器采用scavenge算法将区域分为对象区域和空闲区域，通过两个区域的反转让新生代区域无限使用下去。主垃圾回收器采用Mark-Sweep（Mark-Compact Incremental Marking解决不同场景下问题的算法改进）算法进行空间回收的。无论是主副垃圾回收器的策略都是标记-清除-整理三个大的步骤。另外还有新生代的晋升策略（两次未清除的），大对象直接分配在老生代。","like_count":103,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465951,"discussion_content":"总结很好，还可以通过Chrome开发者工具中的Performance来观察。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567523996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198926,"user_name":"dellyoung","can_delete":false,"product_type":"c1","uid":1133028,"ip_address":"","ucode":"3672FF1D1F8EFD","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/e4/fb47bfcd.jpg","comment_is_top":false,"comment_ctime":1585473655,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"285053315191","product_id":100033601,"comment_content":"栈和堆<br><br>栈垃圾回收<br>当函数执行结束，JS引擎通过向下移动ESP指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。<br><br>堆垃圾回收<br>一、代际假说<br>1、大部分对象存活时间很短<br>2、不被销毁的对象，会活的更久<br><br>二、分类<br>V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。<br><br>三、新生代<br>算法：Scavenge 算法<br>原理：<br>1、把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。<br>2、新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。<br>3、先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中<br>4、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。<br>对象晋升策略：<br>经过两次垃圾回收依然还存活的对象，会被移动到老生区中。<br><br>四、老生代<br>算法：标记 - 清除（Mark-Sweep）算法<br>原理：<br>1、标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。<br>2、清除：将垃圾数据进行清除。<br>碎片：<br>对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。<br><br>算法：标记 - 整理（Mark-Compact）算法<br>原理：<br>1、标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。<br>2、整理：让所有存活的对象都向内存的一端移动<br>3、清除：清理掉端边界以外的内存<br><br>优化算法：增量标记（Incremental Marking）算法<br>原理：<br>1、为了降低老生代的垃圾回收而造成的卡顿<br>2、V8把一个完整的垃圾回收任务拆分为很多小的任务<br>1、让垃圾回收标记和 JavaScript 应用逻辑交替进行<br>","like_count":67,"discussions":[{"author":{"id":1531784,"avatar":"https://static001.geekbang.org/account/avatar/00/17/5f/88/ed9acee8.jpg","nickname":"大掌柜〈海棠依旧〉","note":"","ucode":"023DF965D55B7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557373,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647779771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1902607,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/08/0f/9ed70716.jpg","nickname":"非洲小白狼","note":"","ucode":"5F22AC9981C8C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307835,"discussion_content":"真课代表!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600768588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130851,"user_name":"忘忧草的约定","can_delete":false,"product_type":"c1","uid":1114753,"ip_address":"","ucode":"F99D2F5D179B2A","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/81/489e1cd4.jpg","comment_is_top":false,"comment_ctime":1567560075,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"108941742475","product_id":100033601,"comment_content":"老师请问：经过内存整理之后活动对象在堆中的内存地址就变化了，主线程还处于垃圾回收阶段，此时内存变化是如何更新到相应执行上下文中的呢","like_count":25,"discussions":[{"author":{"id":1630111,"avatar":"https://static001.geekbang.org/account/avatar/00/18/df/9f/6db75dff.jpg","nickname":"Random","note":"","ucode":"4E164C8CF487FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384921,"discussion_content":"实际上V8对堆中对象的引用是通过叫句柄的对象进行管理的，地址变化会主动在句柄上体现","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1626793596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623567,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/0f/3937645e.jpg","nickname":"NBE01","note":"","ucode":"DF0D22D4495D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23498,"discussion_content":"要更新 内存中的地址的， 地址更换后 你就是新的了，比方说前面的半空间算法，进行复制新的到另外的空间中，这个时候你变量的引用地址也要同时更新到这个新的空间中的，那个复制的对象的地址上。之后销毁半空间中的所有数据。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1569826675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1114753,"avatar":"https://static001.geekbang.org/account/avatar/00/11/02/81/489e1cd4.jpg","nickname":"忘忧草的约定","note":"","ucode":"F99D2F5D179B2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1623567,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/0f/3937645e.jpg","nickname":"NBE01","note":"","ucode":"DF0D22D4495D54","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36754,"discussion_content":"哦谢谢指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571414336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":23498,"ip_address":""},"score":36754,"extra":""}]},{"author":{"id":1200020,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4f/94/05044c31.jpg","nickname":"踢车牛","note":"","ucode":"D6D793EF5314A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53732,"discussion_content":"@老师帮忙看下吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574212187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200020,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4f/94/05044c31.jpg","nickname":"踢车牛","note":"","ucode":"D6D793EF5314A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53730,"discussion_content":"其实我觉的通过句柄的方式找到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574212138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130873,"user_name":"ytd","can_delete":false,"product_type":"c1","uid":1038790,"ip_address":"","ucode":"C6AEA2D19E447A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d9/c6/8be8664d.jpg","comment_is_top":false,"comment_ctime":1567563021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104646778125","product_id":100033601,"comment_content":"做了这么长时间的前端开发，第一次关注内存泄漏的问题，以后得多关注这方面了。通过chrome的Perfomance面板记录页面的活动，然后在页面上进行各种交互操作，过一段时间后（时间越长越好），停止记录，生成统计数据，然后看timeline下部的内存变化趋势图，如果是有规律的周期平稳变化，则不存在内存泄漏，如果整体趋势上涨则说明存在内存泄漏。另外，想问下老师，这个内存变化趋势只是js堆内存的变化吗？因为我发现在统计图表下部分了几类：JS Heap、Documents、Nodes、Listeners、GPU Memory，JS Heap是占用最多的，其次是Nodes，再次是Listeners。","like_count":24},{"had_liked":true,"id":130721,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1567519031,"is_pvip":true,"replies":[{"id":"48949","content":"是的 栈中的过期数据直接通过esp给抹掉，效率非常高。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567522652,"ip_address":"","comment_id":130721,"utype":1}],"discussion_count":3,"race_medal":1,"score":"87466864951","product_id":100033601,"comment_content":"对于栈中的垃圾回收，是通过移动 ESP 指针来实现的，是不需要通过V8的垃圾回收机制的吗？","like_count":20,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466088,"discussion_content":"是的 栈中的过期数据直接通过esp给抹掉，效率非常高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567522652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1167767,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d1/97/3abdd9cd.jpg","nickname":"stanny","note":"","ucode":"DD2BB91548A881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370319,"discussion_content":"之前说的栈顶弹出也是这个意思吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619360966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1192961,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/01/30ca98e6.jpg","nickname":"arronK","note":"","ucode":"58DC6FBF2CF0C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1167767,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d1/97/3abdd9cd.jpg","nickname":"stanny","note":"","ucode":"DD2BB91548A881","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559023,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648566898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":370319,"ip_address":""},"score":559023,"extra":""}]}]},{"had_liked":false,"id":130629,"user_name":"Hurry","can_delete":false,"product_type":"c1","uid":1138560,"ip_address":"","ucode":"12FEE2A50CC667","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/80/51269d88.jpg","comment_is_top":false,"comment_ctime":1567497365,"is_pvip":false,"replies":[{"id":"48951","content":"这是一个很好的方法","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567523125,"ip_address":"","comment_id":130629,"utype":1}],"discussion_count":3,"race_medal":0,"score":"87466843285","product_id":100033601,"comment_content":"使用 chrome 的 Performance 面板，观察内存变化 如何多次垃圾回收后，整体趋势是向上，就存在内部泄漏的可能！","like_count":20,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466040,"discussion_content":"这是一个很好的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567523125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1406834,"avatar":"https://static001.geekbang.org/account/avatar/00/15/77/72/ad7056f9.jpg","nickname":"hb","note":"","ucode":"DCFA6CECF64E37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384796,"discussion_content":"怎么看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626753821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2462505,"avatar":"https://static001.geekbang.org/account/avatar/00/25/93/29/8459b21e.jpg","nickname":"常想一二","note":"","ucode":"6C3A59156D2212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1406834,"avatar":"https://static001.geekbang.org/account/avatar/00/15/77/72/ad7056f9.jpg","nickname":"hb","note":"","ucode":"DCFA6CECF64E37","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580098,"discussion_content":"我也想知道怎么看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657871846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384796,"ip_address":""},"score":580098,"extra":""}]}]},{"had_liked":false,"id":148528,"user_name":"芒果","can_delete":false,"product_type":"c1","uid":1124278,"ip_address":"","ucode":"5AD71E7F9FC738","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/b6/e53c17ee.jpg","comment_is_top":false,"comment_ctime":1573025476,"is_pvip":false,"replies":[{"id":"58468","content":"现代虚拟机都是抄来抄去的","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1573878889,"ip_address":"","comment_id":148528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70292502212","product_id":100033601,"comment_content":"大道至简，看完了浏览器的垃圾回收，让我联想到了jvm的垃圾回收，发现2者思想上基本都差不多。","like_count":16,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473520,"discussion_content":"现代虚拟机都是抄来抄去的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573878889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130722,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1567519325,"is_pvip":true,"replies":[{"id":"48957","content":"新生区和老生区标记过程是同一个过程，之后新生代把存活的数据移动到空闲区，老生代把死去的对象加到空闲列表中。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567524451,"ip_address":"","comment_id":130722,"utype":1}],"discussion_count":1,"race_medal":1,"score":"70286996061","product_id":100033601,"comment_content":"对于新生代，副垃圾回收器是怎么进行标记的，文章也就一句话带过了，是和老生代标记算法一样吗？从一组跟元素开始，然后开始遍历的","like_count":16,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466089,"discussion_content":"新生区和老生区标记过程是同一个过程，之后新生代把存活的数据移动到空闲区，老生代把死去的对象加到空闲列表中。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567524451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159337,"user_name":"屈悦微","can_delete":false,"product_type":"c1","uid":1466274,"ip_address":"","ucode":"1A21649CA29325","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqVpvvnZ5icr0YdOCdxlhz5xUf1YqNzyjfYJS0ibRibmON4Via0GTV7e2ZBiaEoOxXCDVB0SNTeWCibI6og/132","comment_is_top":false,"comment_ctime":1575601228,"is_pvip":false,"replies":[{"id":"60905","content":"引用计数有问题，会导致内存泄漏，所以现在流行的垃圾回收器都没有采用引用计数的方式！","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1575603505,"ip_address":"","comment_id":159337,"utype":1}],"discussion_count":1,"race_medal":0,"score":"66000110668","product_id":100033601,"comment_content":"这篇文章写得很有深度，反复看了几遍，收获颇多，但是仍有一个问题，望作者百忙之中能解答<br> 在本篇中作者介绍了的垃圾回收机制是，标记对象的机制<br> 但在《javascript高级程序设计》中还介绍了引用计数的机制<br>我产生以下两个疑问<br>1.v8有没有使用引用计数的机制？<br>2.如果有，何时使用引用计数，何时使用标记对象？","like_count":15,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477016,"discussion_content":"引用计数有问题，会导致内存泄漏，所以现在流行的垃圾回收器都没有采用引用计数的方式！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575603505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":130510,"user_name":"郝仁杰","can_delete":false,"product_type":"c1","uid":1596933,"ip_address":"","ucode":"C6A78E9D5DB359","user_header":"https://static001.geekbang.org/account/avatar/00/18/5e/05/0d8a5b8e.jpg","comment_is_top":false,"comment_ctime":1567475767,"is_pvip":false,"replies":[{"id":"48953","content":"JavaScript中的原始字符串是不可变的（immutable），也就是说，一旦一个字符串创建了，它在内存中的值就不可能改变，这和其他语言是有区别的。<br><br>所以当你调用trim方法后，v8引擎返回给你的是一个新字符串，并不是之前的字符串了。<br>","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567523751,"ip_address":"","comment_id":130510,"utype":1}],"discussion_count":7,"race_medal":0,"score":"61697017911","product_id":100033601,"comment_content":"trim之后，数据在堆上的地址发生变化，v8是如何更新对应栈上的引用的","like_count":14,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465988,"discussion_content":"JavaScript中的原始字符串是不可变的（immutable），也就是说，一旦一个字符串创建了，它在内存中的值就不可能改变，这和其他语言是有区别的。\n\n所以当你调用trim方法后，v8引擎返回给你的是一个新字符串，并不是之前的字符串了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567523751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596933,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5e/05/0d8a5b8e.jpg","nickname":"郝仁杰","note":"","ucode":"C6A78E9D5DB359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7516,"discussion_content":"除了字符串外，其它的引用对象呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567524828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596933,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5e/05/0d8a5b8e.jpg","nickname":"郝仁杰","note":"","ucode":"C6A78E9D5DB359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7515,"discussion_content":"除了字符串外，其它的引用对象呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567524828,"is_liked":false,"can_delete":false,"is_complain":true,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1020746,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/4a/de82f373.jpg","nickname":"AICC","note":"","ucode":"C1D18B1E8B2DCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1596933,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5e/05/0d8a5b8e.jpg","nickname":"郝仁杰","note":"","ucode":"C6A78E9D5DB359","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7892,"discussion_content":"我觉得老师这里的意思是说，对于对象的引用，对象被存放在堆空间，是通过在栈空间中的引用地址访问到具体对象，然后再trim之后，栈空间中的这个引用地址会被替换为V8引擎新返回的字符串地址，这样就完成了更新对应栈上的引用","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567699590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7515,"ip_address":""},"score":7892,"extra":""},{"author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020746,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/4a/de82f373.jpg","nickname":"AICC","note":"","ucode":"C1D18B1E8B2DCE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221113,"discussion_content":"我咋觉得老师的回复是以为他问的是字符串.trim 方法的调用。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585977678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7892,"ip_address":""},"score":221113,"extra":""},{"author":{"id":1698735,"avatar":"https://static001.geekbang.org/account/avatar/00/19/eb/af/e49af9a8.jpg","nickname":"JC.彦","note":"","ucode":"E87C1420B140F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020746,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/4a/de82f373.jpg","nickname":"AICC","note":"","ucode":"C1D18B1E8B2DCE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227231,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586479674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7892,"ip_address":""},"score":227231,"extra":""}]}]},{"had_liked":false,"id":171203,"user_name":"咖飞的白","can_delete":false,"product_type":"c1","uid":1119855,"ip_address":"","ucode":"D1DA248C22320D","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/6f/9f30a9e0.jpg","comment_is_top":false,"comment_ctime":1578880608,"is_pvip":false,"replies":[{"id":"66380","content":"声明变量是在编译阶段完成的，这时赋值语句还没执行！<br><br>比如 var a = 6<br><br>首先编译阶段确定有变量a了，并给a赋值undefined；<br><br>接下来执行代码，在执行过程中，会将6赋给a，这时候a等于6！<br><br>由于6是原生类型，通常情况下，会在栈上分配该变量！<br><br>如果 var a = Object<br><br>将对象赋给a时，在编译阶段 a依然等于undefined，在执行过程中，会在堆中创建一块内存，存放Object的值，然后栈中有个指向堆中Object地址的指针","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1578887505,"ip_address":"","comment_id":171203,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57413455456","product_id":100033601,"comment_content":"请教老师几个问题：<br>1. JS 执行代码时是在执行声明语句时就分配内存还是赋值时分配？若是执行声明语句时就分配，那如何知道是大对象(存储在老生代)还是新对象(存储在新生代)？","like_count":13,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481260,"discussion_content":"声明变量是在编译阶段完成的，这时赋值语句还没执行！\n\n比如 var a = 6\n\n首先编译阶段确定有变量a了，并给a赋值undefined；\n\n接下来执行代码，在执行过程中，会将6赋给a，这时候a等于6！\n\n由于6是原生类型，通常情况下，会在栈上分配该变量！\n\n如果 var a = Object\n\n将对象赋给a时，在编译阶段 a依然等于undefined，在执行过程中，会在堆中创建一块内存，存放Object的值，然后栈中有个指向堆中Object地址的指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578887505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169101,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1578274532,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48822914788","product_id":100033601,"comment_content":"学Java虚拟机的垃圾回收机制，再来看这篇文章，可谓是：“天下垃圾一样收”！<br><br>Java虚拟机垃圾回收使用的也是分代收集的策略，主要也是新生代和老年代。而分代收集的思想依据是二八原则：80%的对象即生即死。","like_count":11,"discussions":[{"author":{"id":1147347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/81/d3/f0a88806.jpg","nickname":"🍐 🍾 🔆","note":"","ucode":"1B7C90800AD4D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277247,"discussion_content":"这里也能看到银银大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591020911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":130693,"user_name":"tick","can_delete":false,"product_type":"c1","uid":1106123,"ip_address":"","ucode":"D2C864306C06CB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOASyV1lpdkW6It8WQltNGj9021PTibqOwRUTccaSUEM1GmQThOTIRp9Eu7XNZZFfGGNveLbUSw9Q/132","comment_is_top":false,"comment_ctime":1567511812,"is_pvip":false,"replies":[{"id":"48950","content":"比如全局window对象看成是一个树状结构，垃圾回收时，V8会先遍历这颗树，能遍历到的元素说明还存活的，标记为活动对象！没有被标记到的说明已经没有被引用了。<br><br>同时V8还维护了一个空闲列表，也就是没有被使用的空闲空间列表，垃圾清理过程就是把没有标记的添加到空闲列表中！<br><br>这样就完成了“标记-清除”操作","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567523062,"ip_address":"","comment_id":130693,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48812152068","product_id":100033601,"comment_content":"标记的过程具体是什么样的呢？我理解老师讲的是，一个指针指向堆里，每次移动一块内存，一个指针遍历栈中，然后看栈中是否引用这块堆中的内存，但感觉这样效率很低","like_count":11,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466071,"discussion_content":"比如全局window对象看成是一个树状结构，垃圾回收时，V8会先遍历这颗树，能遍历到的元素说明还存活的，标记为活动对象！没有被标记到的说明已经没有被引用了。\n\n同时V8还维护了一个空闲列表，也就是没有被使用的空闲空间列表，垃圾清理过程就是把没有标记的添加到空闲列表中！\n\n这样就完成了“标记-清除”操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567523062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2136469,"avatar":"https://static001.geekbang.org/account/avatar/00/20/99/95/1e332315.jpg","nickname":"Geek_2014ce","note":"","ucode":"167B4CCDA4D5BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361897,"discussion_content":"新生代是等待 对象区域 的空间满的时候执行清理，那老时代的清理时机是什么时候呢？期待老师解答","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616774158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131180,"user_name":"YBB","can_delete":false,"product_type":"c1","uid":1585967,"ip_address":"","ucode":"1507DBFE008715","user_header":"https://static001.geekbang.org/account/avatar/00/18/33/2f/84f7d587.jpg","comment_is_top":false,"comment_ctime":1567663441,"is_pvip":false,"replies":[{"id":"49454","content":"会的，副垃圾回收器执行速度快，而且容易满，所以回收频率会比主垃圾回收器高。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567669779,"ip_address":"","comment_id":131180,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44517336401","product_id":100033601,"comment_content":"有个问题想请教下，副回收器的触发频率会高于主回收器吗？还是两者是同步触发的？","like_count":10,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466324,"discussion_content":"会的，副垃圾回收器执行速度快，而且容易满，所以回收频率会比主垃圾回收器高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567669779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131653,"user_name":"于你","can_delete":false,"product_type":"c1","uid":1626759,"ip_address":"","ucode":"6A3F8C38874410","user_header":"https://static001.geekbang.org/account/avatar/00/18/d2/87/e5f78961.jpg","comment_is_top":false,"comment_ctime":1567837189,"is_pvip":false,"replies":[{"id":"50406","content":"对，没有被引用的闭包会被自动回收，不过如果没用的闭包还保存在全局变量中，依然会内存泄漏！","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567984617,"ip_address":"","comment_id":131653,"utype":1}],"discussion_count":5,"race_medal":0,"score":"40222542853","product_id":100033601,"comment_content":"老师，我最近听了一门课，那个老师说现代的浏览器用闭包不会造成内存泄漏，因为垃圾回收是用的标记清除","like_count":9,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466559,"discussion_content":"对，没有被引用的闭包会被自动回收，不过如果没用的闭包还保存在全局变量中，依然会内存泄漏！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567984617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1626759,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d2/87/e5f78961.jpg","nickname":"于你","note":"","ucode":"6A3F8C38874410","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8218,"discussion_content":"我现在有点懵了，按您的意思是闭包会造成内存泄漏，可以解释一下吗。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567837333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1147347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/81/d3/f0a88806.jpg","nickname":"🍐 🍾 🔆","note":"","ucode":"1B7C90800AD4D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1626759,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d2/87/e5f78961.jpg","nickname":"于你","note":"","ucode":"6A3F8C38874410","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64536,"discussion_content":"意思就是闭包没被赋值给某个全局变量 就会被回收","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574950166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8218,"ip_address":""},"score":64536,"extra":""},{"author":{"id":1687802,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/fa/61f78abd.jpg","nickname":"Geek_012295","note":"","ucode":"41721DD2144F77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1147347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/81/d3/f0a88806.jpg","nickname":"🍐 🍾 🔆","note":"","ucode":"1B7C90800AD4D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299739,"discussion_content":"那下次取这个闭包内的变量岂不是取不到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597803363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":64536,"ip_address":""},"score":299739,"extra":""},{"author":{"id":1344810,"avatar":"https://static001.geekbang.org/account/avatar/00/14/85/2a/376dd985.jpg","nickname":"uccs","note":"","ucode":"93DF5B81AB170E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1687802,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/fa/61f78abd.jpg","nickname":"Geek_012295","note":"","ucode":"41721DD2144F77","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301979,"discussion_content":"回收之后，再次使用，会生成一块新的内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598746152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299739,"ip_address":""},"score":301979,"extra":""}]}]},{"had_liked":false,"id":283290,"user_name":"heora","can_delete":false,"product_type":"c1","uid":1224780,"ip_address":"","ucode":"7FB43646223C6A","user_header":"https://static001.geekbang.org/account/avatar/00/12/b0/4c/0f5aac14.jpg","comment_is_top":false,"comment_ctime":1615692920,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"35975431288","product_id":100033601,"comment_content":"老师，问一个问题，WeakMap 和 WeakSet 是如何被回收的？最近面试被问到这个问题，面试官说它不计入垃圾回收机制，但是不应该是都是自动进行垃圾回收的嘛？","like_count":8,"discussions":[{"author":{"id":2208091,"avatar":"","nickname":"杨梦圆","note":"","ucode":"55603CD633E076","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550490,"discussion_content":"WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用， 不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值 对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。 --- 红宝书","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644567141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2759091,"avatar":"","nickname":"Geek_fdab77","note":"","ucode":"4A553123A217C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407882,"discussion_content":"对象应该被GC回收时不会阻止GC的回收行为，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。WeakSet结构有助于防止内存泄漏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635143976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1224780,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b0/4c/0f5aac14.jpg","nickname":"heora","note":"","ucode":"7FB43646223C6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2759091,"avatar":"","nickname":"Geek_fdab77","note":"","ucode":"4A553123A217C2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542625,"discussion_content":"我的意思是 weakmap 和 weakset 是如何回收的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640817090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":407882,"ip_address":""},"score":542625,"extra":""}]}]},{"had_liked":false,"id":205771,"user_name":"JC.彦","can_delete":false,"product_type":"c1","uid":1698735,"ip_address":"","ucode":"E87C1420B140F4","user_header":"https://static001.geekbang.org/account/avatar/00/19/eb/af/e49af9a8.jpg","comment_is_top":false,"comment_ctime":1586737596,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"27356541372","product_id":100033601,"comment_content":"既然v8有自动垃圾回收机制，为啥还会有内存泄露，只是闭包引起的吗？如何解决内存泄露问题？<br>数组占用内存过高就说明代码写的不好，这是什么原因？","like_count":6,"discussions":[{"author":{"id":1406834,"avatar":"https://static001.geekbang.org/account/avatar/00/15/77/72/ad7056f9.jpg","nickname":"hb","note":"","ucode":"DCFA6CECF64E37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298562,"discussion_content":"垃圾回收机制都是回收没有被引用的对象，如果一个对象被变量引用了的话，那么它就不是垃圾对象了，从而不会被回收。比如有时候一个对象只是在一个函数中使用，但是由于不小心定义成了全局变量，当函数执行完成，这个对象由于还有变量引用而不被回收，就常见的垃圾对象","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1597327623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283537,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/d1/7d3834ef.jpg","nickname":"笑若海","note":"","ucode":"A10EF247EE4B5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":247869,"discussion_content":"我想到两个场景，可能导致内存无法回收，或者回收缓慢：\n1. 函数调用层次很深，调用栈回收后，基于调用栈中的变量引用，标记阶段可能不及时，如果要清除的对象又很多的话，可能导致回收时间较长；再者，如果上述情况是用户操作导致的，用户又频繁操作，那么可能在内存回收前，又产生大量新的垃圾数据需要回收，此时垃圾回收器就不堪重负了。\n2.有些数据绑定在DOM节点上，如果创建的DOM节点使用完没有从document移出，只是不可见，此时跟DOM绑定的数据永远不会回收，如通过dataset绑定的JS对象、createObjectURL创建绑定图片等。\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1587826822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1406834,"avatar":"https://static001.geekbang.org/account/avatar/00/15/77/72/ad7056f9.jpg","nickname":"hb","note":"","ucode":"DCFA6CECF64E37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298564,"discussion_content":"常见的内存泄露","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597327670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239114,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587274455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160717,"user_name":"江霖","can_delete":false,"product_type":"c1","uid":1051487,"ip_address":"","ucode":"D197B3FD012944","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLHOZjqhVkWgUrUibLnXkiaFkhJdfWT2BZP3LldE3tArIoHASlhTSp8tiatiamLbQOjKeMcYHkAexoyCg/132","comment_is_top":false,"comment_ctime":1576025439,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"23050861919","product_id":100033601,"comment_content":"老师我有个问题，副垃圾回收器的回收机制是对象区域满的时候，那么主垃圾回收器呢？<br>代码空间占用的内存什么时间回收呢","like_count":5,"discussions":[{"author":{"id":2740364,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d0/8c/d18d1309.jpg","nickname":"不凉","note":"","ucode":"3A57D3845F921C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559351,"discussion_content":"这个各位有结果了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648714184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2136469,"avatar":"https://static001.geekbang.org/account/avatar/00/20/99/95/1e332315.jpg","nickname":"Geek_2014ce","note":"","ucode":"167B4CCDA4D5BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361901,"discussion_content":"同问，望老师解答，还有 递归遍历 整棵数进行标记之后，还要遍历整个堆空间查看那些对象没被标记进行回收吗？  标记-整理 还是会存在新生代中对象复制的问题，具体怎么整理解决这问题的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616774713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050196,"avatar":"https://static001.geekbang.org/account/avatar/00/10/06/54/16bb64d0.jpg","nickname":"蛋黄酱","note":"","ucode":"2351562F282B68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336887,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608725224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047114,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/4a/23f480f5.jpg","nickname":"海一剑","note":"","ucode":"8F18D06C631EA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268488,"discussion_content":"@老师，同问，什么时候会触发主垃圾回收器呢？是定时还是有什么策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589789442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131415,"user_name":"韦恩先生","can_delete":false,"product_type":"c1","uid":1400808,"ip_address":"","ucode":"9625534C5D186D","user_header":"https://static001.geekbang.org/account/avatar/00/15/5f/e8/1b43bfae.jpg","comment_is_top":false,"comment_ctime":1567743450,"is_pvip":false,"replies":[{"id":"49833","content":"不全没关系，新产生的垃圾下次再回收，分配内存使用空闲列表里面的。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567751851,"ip_address":"","comment_id":131415,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18747612634","product_id":100033601,"comment_content":"增量标记会受到中间穿插的js应用逻辑影响么？会造成标记结果不全或者错误么？","like_count":4,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466440,"discussion_content":"不全没关系，新产生的垃圾下次再回收，分配内存使用空闲列表里面的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567751851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130555,"user_name":"Lx","can_delete":false,"product_type":"c1","uid":1632217,"ip_address":"","ucode":"90F4EEE985A9B0","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/d9/83d1346c.jpg","comment_is_top":false,"comment_ctime":1567482405,"is_pvip":false,"replies":[{"id":"48952","content":"标记清除和标记整理可以看成是垃圾回收的两个阶段吧，v8在实现垃圾回收过程中，两种算法都用上了。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567523395,"ip_address":"","comment_id":130555,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18747351589","product_id":100033601,"comment_content":"我想问下，标记清除和标记整理是两个同等级的算法策略吗？目前v8使用的是两者结合，还是只有一种？","like_count":4,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466011,"discussion_content":"标记清除和标记整理可以看成是垃圾回收的两个阶段吧，v8在实现垃圾回收过程中，两种算法都用上了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567523395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623282,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erMrXia5kb1AXUJoiccmIQxSQ7ib5SkibsQqd9FZInQcwYeNbZXp7CCtMibtg0RLHoza1NVo8A5M3uIluA/132","nickname":"Geek_8476da","note":"","ucode":"9AE358E5F160AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588147,"discussion_content":"老生代垃圾回收是使用两者结合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663575127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1216699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/90/bb/c29f0f99.jpg","nickname":"谢海涛","note":"","ucode":"9408053AF26876","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7398,"discussion_content":"老生带垃圾回收v8是使用两者结合的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567504214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130508,"user_name":"不将就","can_delete":false,"product_type":"c1","uid":1462422,"ip_address":"","ucode":"20A1EFAB085B0F","user_header":"https://static001.geekbang.org/account/avatar/00/16/50/96/dd23dcb0.jpg","comment_is_top":false,"comment_ctime":1567475127,"is_pvip":false,"replies":[{"id":"48954","content":"看对象大小，小对象一开始会丢到新生代中去，当GC执行多次后，会被移动到老生代中。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567523826,"ip_address":"","comment_id":130508,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18747344311","product_id":100033601,"comment_content":"闭包形成的对象刚开始是属于新生代还是老生代？","like_count":4,"discussions":[{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7501,"discussion_content":"闭包形成的对象 开始的时候是属于新生代，闭包的对象一般来说都是很小的，经过2轮新生代垃圾回收还存活的话，就会移动到老生代区","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567519478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465986,"discussion_content":"看对象大小，小对象一开始会丢到新生代中去，当GC执行多次后，会被移动到老生代中。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567523826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327659,"user_name":"hao-kuai","can_delete":false,"product_type":"c1","uid":1272354,"ip_address":"","ucode":"DFDFDDDBA4503C","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/22/527904b2.jpg","comment_is_top":false,"comment_ctime":1640223895,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14525125783","product_id":100033601,"comment_content":"1. 这篇文章很细致形象的讲清楚了垃圾回收的原理<br>2. 储存区域分栈和堆<br>3. 基本类型放栈，复杂类型放堆<br>4. 栈就是调用栈，基本类型占用小直接值存储，出栈后，数据自动释放，自动管理<br>5. 为了切换入栈出栈效率， 复杂数据占用空间大，存放在堆中，变量进行引用存储<br>6. 垃圾回收指的就是堆空间管理，垃圾回收算法也不能覆盖全场景，v8又分为新生代和老生代两个区，各自执行不同的策略算法，甚至还有新生代的晋升策略<br>7. JS 的尽头是 C++，垃圾回收算法在新生高级语言中是高级知识，在古老的语言中是常规操作<br>8. React 新版本基于 fiber 的调度的实现和老生代的增量标记执行策略如出一辙","like_count":3},{"had_liked":false,"id":229899,"user_name":"渡","can_delete":false,"product_type":"c1","uid":1397140,"ip_address":"","ucode":"55C09E9A495BAC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/94/d667294c.jpg","comment_is_top":false,"comment_ctime":1593181415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14478083303","product_id":100033601,"comment_content":"老师，我对Scavenge 算法有个疑问。标记完之后，为啥不采用双指针的方案来复制存活对象呢，这样就不必将内存一分为二了","like_count":3},{"had_liked":false,"id":241707,"user_name":"Emma","can_delete":false,"product_type":"c1","uid":1930698,"ip_address":"","ucode":"C2D31142AF7288","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/ca/4c127da3.jpg","comment_is_top":false,"comment_ctime":1597396016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10187330608","product_id":100033601,"comment_content":"老生代区域的垃圾回收机制是什么时候出触发的，能讲下吗？直接一笔带过了","like_count":2},{"had_liked":false,"id":218433,"user_name":"小玲子ida","can_delete":false,"product_type":"c1","uid":1177005,"ip_address":"","ucode":"A447EF847D375E","user_header":"https://static001.geekbang.org/account/avatar/00/11/f5/ad/2f7d5e50.jpg","comment_is_top":false,"comment_ctime":1589801663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10179736255","product_id":100033601,"comment_content":"今日总结：栈中数据通过移动esp指向下一个执行上下文来回收上一个执行上下文；堆区间数据通过副垃圾回收器和主垃圾回收器进行回收，副垃圾回收器分为对象区域和空闲区域，通过scavenger算法，垃圾对象会在对象区域中进行清除，存活的对象会复制到空闲区域，这时候对象区域和空闲区域进行转换，无限使用副垃圾回收器，两次回收还是存活对象会分配到老生代；老生代，对象占用空间大都会通过老生代进行回收：主垃圾回收器通过标记-清理-整理算法进行回收，由于js执行在主线程上，回收占用空间大的对象时，会卡住主线程，因此通过增量标记算法，将垃圾标记分为几个小任务穿插在每个js任务中，直到标记完所有垃圾对象，最后一起清理整理；","like_count":2},{"had_liked":false,"id":131707,"user_name":"钟钟","can_delete":false,"product_type":"c1","uid":1499343,"ip_address":"","ucode":"D1A11CC3EB7137","user_header":"https://static001.geekbang.org/account/avatar/00/16/e0/cf/08b04e00.jpg","comment_is_top":false,"comment_ctime":1567858736,"is_pvip":false,"replies":[{"id":"50345","content":"没有引用的对象是不会重新被使用的了，能使用的都是能查到的","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567865205,"ip_address":"","comment_id":131707,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157793328","product_id":100033601,"comment_content":"增量标记的时候，比如我标记了一个对象是没有引用的，可以清除，然后又执行一段代码，重新引用了这个对象，这个是可能的吧，这个情况怎么处理呢","like_count":2,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466584,"discussion_content":"没有引用的对象是不会重新被使用的了，能使用的都是能查到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567865205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336529,"user_name":"freemind1992","can_delete":false,"product_type":"c1","uid":2878390,"ip_address":"","ucode":"1076EDB222D95D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/HCeXc20SSFyyGZibOrHF2W5secwia93CJQvzZMkCMFIytEyzjuBn4CHObIPZH1yV0JgyHqDn1KJMficx2G6RKhW2Q/132","comment_is_top":false,"comment_ctime":1646204012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5941171308","product_id":100033601,"comment_content":"关于新生代垃圾回收，下面这段表述会更清晰<br>在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体<br>实现中，主要采用了Cheney算法，该算法由C.J.Cheney于1970年首次发表在ACM论文上。<br>Cheney算法是<br>一 种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二,每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。<br>Scavenge的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。<br>由于Scavenge是典型的辆牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收中。但可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰<br>适合这个算法","like_count":1},{"had_liked":false,"id":303249,"user_name":"哎呦先生","can_delete":false,"product_type":"c1","uid":1200430,"ip_address":"","ucode":"24076486C75030","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/2e/6f7b0e7c.jpg","comment_is_top":false,"comment_ctime":1626686521,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5921653817","product_id":100033601,"comment_content":"栈中存放的数据变量，当函数或者上下文代码执行完毕是，ESP指针就退出了该作用栈，栈中保存的数据就被销毁了。但是注意此时上下文声明的引用类型变量还在堆中存放着，等待着垃圾回收来执行回收。","like_count":1},{"had_liked":false,"id":238123,"user_name":"GeekYa","can_delete":false,"product_type":"c1","uid":1127115,"ip_address":"","ucode":"4B30219E8E7A97","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/cb/cece03fc.jpg","comment_is_top":false,"comment_ctime":1596074155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5891041451","product_id":100033601,"comment_content":"所看过的最深入浅出的讲解~赞！","like_count":1},{"had_liked":false,"id":203698,"user_name":"mimof9","can_delete":false,"product_type":"c1","uid":1391354,"ip_address":"","ucode":"C83B3E2CD62BBD","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/fa/21f64eaa.jpg","comment_is_top":false,"comment_ctime":1586255950,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5881223246","product_id":100033601,"comment_content":"老师，我看到这篇突然有好多疑问：<br>1. 栈内存释放的ESP移动，它如何确定上一个执行上下文的位置?<br>2. GC完成之后，变量在堆中的地址改变，该怎么同步到栈中的引用去？<br>3. GC什么时候会促发呢？<br><br>最后关于增量标记有一些思考，麻烦老师您看下是否正确。因为js代码在持续执行，伴随着执行上下文退栈，会出现少标记垃圾的情况，但是不碍事，下次执行GC的时候再回收。麻烦的是多标记垃圾这种情况，如果出现了多标记的情况，说明把有用的数据清除了，是致命的，但是根据call stack的原理，无论是入栈一个新的执行上下文，还是退栈，都不会存在前面标记为垃圾的数据，在后面执行的时候又被标记为有用的情况。","like_count":1,"discussions":[{"author":{"id":1050196,"avatar":"https://static001.geekbang.org/account/avatar/00/10/06/54/16bb64d0.jpg","nickname":"蛋黄酱","note":"","ucode":"2351562F282B68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336890,"discussion_content":"回答1，堆栈不是当前这个用完了去掉，下个在最上面可取用的就是外面一层执行上下文么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608725663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167535,"user_name":"-_-|||","can_delete":false,"product_type":"c1","uid":1328142,"ip_address":"","ucode":"94B21594658BF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/0e/ce14b7d3.jpg","comment_is_top":false,"comment_ctime":1577849950,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"5872817246","product_id":100033601,"comment_content":"文中”其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。”java是动态语言吗？动态语言应该是申明时并不需要确认数据类型的语言，而java声明变量有int,float,string之类很多。","like_count":1,"discussions":[{"author":{"id":2002226,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8d/32/898c922e.jpg","nickname":"佐伯楽","note":"","ucode":"B6EC6B0B441752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281024,"discussion_content":"我没怎么用过 Java，但是听说过 Java 有个 var 关键字可以自动进行类型推断而省略类型语法？这样的话，也许是 Java 本身是有能力可以动态推断类型的，只是语法上选择了强制写明类型的方式吧。就像 TypeScript 最后是要编译到 JavaScript 运行，但是 tsc 编译的时候还是会警告你要为变量注明类型，即便它最后运行在一个动态语言的环境中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591664159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138115,"user_name":"Cris","can_delete":false,"product_type":"c1","uid":1473520,"ip_address":"","ucode":"F8A287134F1078","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/f0/269139d5.jpg","comment_is_top":false,"comment_ctime":1570027778,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5864995074","product_id":100033601,"comment_content":"一个对象是放在新生区还是老生区是v8引擎自动判断的吗？判断大概是以什么为依据？","like_count":1,"discussions":[{"author":{"id":1662955,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5f/eb/b07245b7.jpg","nickname":"大坏猪","note":"","ucode":"326EC6BEEAE4FF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377171,"discussion_content":"恩 一样得疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622537009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047114,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/4a/23f480f5.jpg","nickname":"海一剑","note":"","ucode":"8F18D06C631EA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268487,"discussion_content":"同问，小对象放在新生区，那么多小算小呢？几K？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589789367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130752,"user_name":"tokey","can_delete":false,"product_type":"c1","uid":1337746,"ip_address":"","ucode":"5278487F37D4EC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJS0jwYKhjm1hq96go05J4R7XDd5FFXXaoyIfX9TgoI3mLURAu2ET72SvYGM2iaET7IV3WDvMibAVfw/132","comment_is_top":false,"comment_ctime":1567524804,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5862492100","product_id":100033601,"comment_content":"老师！针对”从栈中回收 showName 执行上下文“这张图，您之前在”5讲“的章节中讲的执行栈是出栈、入栈的操作，那这张图上说”新的执行上下文会覆盖这块的内存“，我按之前的理解是直接出栈了，那这块怎么还在栈里（您打了个x号）等其他执行上下文覆盖？","like_count":1,"discussions":[{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239115,"discussion_content":"这里的所谓出栈就是指指针下移","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587274570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130467,"user_name":"张峰","can_delete":false,"product_type":"c1","uid":1097820,"ip_address":"","ucode":"7015E9A9137521","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/5c/10111544.jpg","comment_is_top":false,"comment_ctime":1567470798,"is_pvip":false,"replies":[{"id":"48955","content":"v8虽然借鉴了Java的垃圾回收器，但是v8新生代只有两个区，幸存对象会被打上标记！","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567523900,"ip_address":"","comment_id":130467,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862438094","product_id":100033601,"comment_content":"v8 新生代 没有eden，s0，s1的划分吗","like_count":1,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465967,"discussion_content":"v8虽然借鉴了Java的垃圾回收器，但是v8新生代只有两个区，幸存对象会被打上标记！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567523900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357705,"user_name":"Geek_8476da","can_delete":false,"product_type":"c1","uid":1623282,"ip_address":"广东","ucode":"9AE358E5F160AE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erMrXia5kb1AXUJoiccmIQxSQ7ib5SkibsQqd9FZInQcwYeNbZXp7CCtMibtg0RLHoza1NVo8A5M3uIluA/132","comment_is_top":false,"comment_ctime":1663575289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663575289","product_id":100033601,"comment_content":"垃圾回收有那些应用呢","like_count":0},{"had_liked":false,"id":353541,"user_name":"谢宝瑞","can_delete":false,"product_type":"c1","uid":2991120,"ip_address":"广东","ucode":"046AB1BE5C6D8A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ibkP4RGoxicFDicfAmib5tRTVaemWRY8WlRR7NO2dLjticct8waCv3rse1Mtj8lIJvKzzDp1xZL947hTWNQ9tFEAqOQ/132","comment_is_top":false,"comment_ctime":1659528407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659528407","product_id":100033601,"comment_content":"增量标记算法的补充：将标记过程分为一个个的子标记过程后，每次暂停标记后怎么恢复呢？如果在暂停后执行的脚本里改变了已经标记好的对象引用关系该怎么办？<br>1. 三个标记法（暂停与恢复）<br>2. 写屏障（增量中修改引用）","like_count":0},{"had_liked":false,"id":353540,"user_name":"谢宝瑞","can_delete":false,"product_type":"c1","uid":2991120,"ip_address":"广东","ucode":"046AB1BE5C6D8A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ibkP4RGoxicFDicfAmib5tRTVaemWRY8WlRR7NO2dLjticct8waCv3rse1Mtj8lIJvKzzDp1xZL947hTWNQ9tFEAqOQ/132","comment_is_top":false,"comment_ctime":1659528163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659528163","product_id":100033601,"comment_content":"关于增量标记算法的补充：如果将标记过程分为一个个的子标记过程，每次暂停标记后怎么恢复到上一次标记的位置呢？如果在暂停后执行的脚本里改变了已经标记好的对象引用关系该怎么办？<br>1. 三色标记法(暂停与恢复)","like_count":0},{"had_liked":false,"id":346661,"user_name":"何江涛","can_delete":false,"product_type":"c1","uid":1938247,"ip_address":"","ucode":"844470733623BF","user_header":"https://static001.geekbang.org/account/avatar/00/1d/93/47/ef2c3c4e.jpg","comment_is_top":false,"comment_ctime":1653326870,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653326870","product_id":100033601,"comment_content":"我们需要清理垃圾，先要理解对象特性。<br>对象特性-&gt;代际假说。所以我们将堆分为新生代(小)，老年代(大)。<br>垃圾回收大致3步，1.标记  2.清理  3.整理。<br>新生代老年代垃圾回收第一步差不多。<br><br>新生代垃圾回收频繁，容量太大会导致一次垃圾回收时间过长，所以容量只有1-8M。新生代常常需要整理，所以采用空间对半的垃圾回收算法。回收时左右复制。<br><br>老年代采用标记清理，或者标记整理的方法。因为它容量大，垃圾回收时间长，容易霸占线程。所以采用增量标记算法，均摊回收时长。","like_count":0},{"had_liked":false,"id":344235,"user_name":"LYNN🍉","can_delete":false,"product_type":"c1","uid":2976160,"ip_address":"","ucode":"C6EF3B80F2BA4F","user_header":"https://static001.geekbang.org/account/avatar/00/2d/69/a0/1434f1f3.jpg","comment_is_top":false,"comment_ctime":1651386152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651386152","product_id":100033601,"comment_content":"老师，请教个问题，“标记-清除”和“标记-整理”这两个算法是按先后顺序执行，还是看情况只执行其中一种呢？","like_count":0},{"had_liked":false,"id":341230,"user_name":"一七","can_delete":false,"product_type":"c1","uid":2930028,"ip_address":"","ucode":"681C7720FAB84B","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b5/6c/18c5b2ed.jpg","comment_is_top":false,"comment_ctime":1649433675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649433675","product_id":100033601,"comment_content":"对栈中数据的回收那块，函数执行完之后不是应该就出栈了吗，但是文中没提出栈这回事呢","like_count":0},{"had_liked":false,"id":329745,"user_name":"Geek_cd4e2d","can_delete":false,"product_type":"c1","uid":2872600,"ip_address":"","ucode":"6CFABCA5502217","user_header":"","comment_is_top":false,"comment_ctime":1641523597,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1641523597","product_id":100033601,"comment_content":"其实关于闭包我也不是很理解为什么会导致内存泄漏，虽然闭包中引用了堆中的closure对象，但是当闭包函数执行完毕后，会从栈顶移除。等到垃圾回收时，例如标记-清除法，依然遍历栈空间，未发现closure对象对应地址，那么也会认定为非活动对象。自动清除呀","like_count":0,"discussions":[{"author":{"id":2913864,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MYShyjtRtib2GIQiaK4hV3ZP9pQ1qiaS74DA4K4YHY4SIiaFDfsCKgiaMWwm9zFsSn3bt5pawp5Kdn5MWgiaw5909nug/132","nickname":"Geek_aa1c31","note":"","ucode":"1AC14C053638AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552001,"discussion_content":"采用标记清除策略的话, 只要闭包没有被暴露到全局变量上就不会造成内存泄漏. 很早之前会说闭包会造成内存泄漏说的是引用计数的回收策略.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1645202219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322510,"user_name":"窗外明月","can_delete":false,"product_type":"c1","uid":1485706,"ip_address":"","ucode":"D4C0BA5CC496CA","user_header":"https://static001.geekbang.org/account/avatar/00/16/ab/8a/e1a8b835.jpg","comment_is_top":false,"comment_ctime":1637449826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637449826","product_id":100033601,"comment_content":"iOS14.x系统锁屏重新解锁后H5页面在我们自己的APP内会掉帧，在PC端chrome和android端不会，感觉也是内存泄漏导致的","like_count":0},{"had_liked":false,"id":321068,"user_name":"ronny","can_delete":false,"product_type":"c1","uid":2071110,"ip_address":"","ucode":"E2D3A70AAC89AA","user_header":"https://static001.geekbang.org/account/avatar/00/1f/9a/46/bb7d948e.jpg","comment_is_top":false,"comment_ctime":1636644145,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636644145","product_id":100033601,"comment_content":"老生代的垃圾回收，是什么时候触发的呢？","like_count":0},{"had_liked":false,"id":318486,"user_name":"Geek_fdab77","can_delete":false,"product_type":"c1","uid":2759091,"ip_address":"","ucode":"4A553123A217C2","user_header":"","comment_is_top":false,"comment_ctime":1635312257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635312257","product_id":100033601,"comment_content":"增量标记的图是不是有点问题，应该是先整理再清理吧","like_count":0},{"had_liked":false,"id":313870,"user_name":"Kim Yin","can_delete":false,"product_type":"c1","uid":1051165,"ip_address":"","ucode":"9BBD367E6F0569","user_header":"https://static001.geekbang.org/account/avatar/00/10/0a/1d/269a15c3.jpg","comment_is_top":false,"comment_ctime":1632724736,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632724736","product_id":100033601,"comment_content":"副垃圾回收期触发清理操作的时机是对象区域快满的时候，那主垃圾回收器触发的时机是什么呢？","like_count":0},{"had_liked":false,"id":306946,"user_name":"安权","can_delete":false,"product_type":"c1","uid":2349106,"ip_address":"","ucode":"B3E42F9CD4B9FA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlk0ZTU5Jn4Pl4Z5MB71c0RR0iayBb3wpwveBkg0G2sqm2ZiaxWc1YiblT3RhOMAK2pQEy5QNvuR3ibw/132","comment_is_top":false,"comment_ctime":1628784805,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628784805","product_id":100033601,"comment_content":"https:&#47;&#47;v8.dev&#47;blog&#47;trash-talk 结合这个看有几个地方会更清晰","like_count":0},{"had_liked":false,"id":306605,"user_name":"杜鹿鹿","can_delete":false,"product_type":"c1","uid":1952651,"ip_address":"","ucode":"1229B6719EB263","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mG8pYHVExwibqbA9UianY5ZG0BP52jhIm6Tr8VFOlzOXG4SxQmjTamUZx8PGgXEJKicXJrGltjibzUc2MKLNJlOkkA/132","comment_is_top":false,"comment_ctime":1628643493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628643493","product_id":100033601,"comment_content":"增量标记是如何实现交替执行的呢","like_count":0},{"had_liked":false,"id":295358,"user_name":"趁你还年轻233","can_delete":false,"product_type":"c1","uid":1053875,"ip_address":"","ucode":"B7CC120EF42980","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/b3/b6e1817a.jpg","comment_is_top":false,"comment_ctime":1622382374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622382374","product_id":100033601,"comment_content":"用Chrome的memory面板打快照。<br>正常快照和页面卡顿快照，选择comparation对比两次快照，分支内存分配情况","like_count":0},{"had_liked":false,"id":291057,"user_name":"General","can_delete":false,"product_type":"c1","uid":1039860,"ip_address":"","ucode":"2247DEBA9422C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er04ibpNSFnyiaPrWjPU96q7AZzgAU1Jc1MVwVvfTrqRaR2AWYJ6Z2KXohT8fS5dKSAqa31SNmicJ1mg/132","comment_is_top":false,"comment_ctime":1619996854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619996854","product_id":100033601,"comment_content":"记得之前看过，在大概 chrome 78 之后，为了尽量减少 javascript 执行线程垃圾回收时间，V8团队也在考虑通过另外一个独立线程来标记垃圾对象，在JavaScript执行线程清除垃圾对象，这块能否加进来介绍下？","like_count":0},{"had_liked":false,"id":288126,"user_name":"Margin","can_delete":false,"product_type":"c1","uid":2044091,"ip_address":"","ucode":"2AC4BE40B4222D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/30/bb/5988ecdb.jpg","comment_is_top":false,"comment_ctime":1618311334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618311334","product_id":100033601,"comment_content":"自身的属性引用自身的对象该如何清除？","like_count":0},{"had_liked":false,"id":287425,"user_name":"哈哈","can_delete":false,"product_type":"c1","uid":2557208,"ip_address":"","ucode":"108B42BC614820","user_header":"https://static001.geekbang.org/account/avatar/00/27/05/18/b7c15dab.jpg","comment_is_top":false,"comment_ctime":1617942309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617942309","product_id":100033601,"comment_content":"老师您好，我想把blink模块剥离出来独立编译，但是感觉无从下手，您能帮我指点一下吗，或者我方便加您微信吗？","like_count":0},{"had_liked":false,"id":285046,"user_name":"达芬奇","can_delete":false,"product_type":"c1","uid":1462769,"ip_address":"","ucode":"6DD8B5E5BA01D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/51/f1/ad44a386.jpg","comment_is_top":false,"comment_ctime":1616591117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616591117","product_id":100033601,"comment_content":"堆内存会进行内存整理，内存整理后对应的内存地址会发生变化，发生变化后是如何将变化后的内存地址更新到对应的执行上下文的呢","like_count":0},{"had_liked":false,"id":272345,"user_name":"耿耿","can_delete":false,"product_type":"c1","uid":1817461,"ip_address":"","ucode":"37084BB64BAA94","user_header":"https://static001.geekbang.org/account/avatar/00/1b/bb/75/a62eca9b.jpg","comment_is_top":false,"comment_ctime":1610062150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610062150","product_id":100033601,"comment_content":"新生代中的对象并不需要频繁的复制，只需要将空闲区域和对象区域进行交换使用即可，大大的提升了新生区垃圾回收的效率","like_count":0},{"had_liked":false,"id":272278,"user_name":"灵感_idea","can_delete":false,"product_type":"c1","uid":1231317,"ip_address":"","ucode":"E0DBDDFA6040F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/d5/b08a27ed.jpg","comment_is_top":false,"comment_ctime":1610014178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610014178","product_id":100033601,"comment_content":"看到这里，发现大家关注的点都好细好深，给大家点赞！~","like_count":0},{"had_liked":false,"id":269648,"user_name":"蛋黄酱","can_delete":false,"product_type":"c1","uid":1050196,"ip_address":"","ucode":"2351562F282B68","user_header":"https://static001.geekbang.org/account/avatar/00/10/06/54/16bb64d0.jpg","comment_is_top":false,"comment_ctime":1608726213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608726213","product_id":100033601,"comment_content":"求问：<br>1. Mark-sweep中提到标记后清除。我不太理解的是，既然后续会做内存整理，直接把标记存活的覆盖垃圾可以吗？清除是不是多一步操作？还是直接在标记为垃圾的同时做了清除便于后续处理？<br>2. Mark-compact中内存整理一笔带过为移到一起，但世纪想想移动操作仍旧如scavenge算法一样需要复制粘贴覆盖，很费操作时间，所以我想是不是只是用最后的碎片尽量填补前面的空缺而不是所有都往前移呢？","like_count":0},{"had_liked":false,"id":267925,"user_name":"费马","can_delete":false,"product_type":"c1","uid":1190201,"ip_address":"","ucode":"BCAAF9C16F0CC5","user_header":"https://static001.geekbang.org/account/avatar/00/12/29/39/0aec7827.jpg","comment_is_top":false,"comment_ctime":1607997858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607997858","product_id":100033601,"comment_content":"最新的垃圾回收器Oilpan（2020）的设计文档中，并未明确说明新生代和老生代相关的内容，请问老师文中所讲的GC过程是否为Orinoco（2019）的过程？","like_count":0},{"had_liked":false,"id":267862,"user_name":"邓耀龙","can_delete":false,"product_type":"c1","uid":1208891,"ip_address":"","ucode":"50788CFE5A7B17","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/3b/b479700b.jpg","comment_is_top":false,"comment_ctime":1607956272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607956272","product_id":100033601,"comment_content":"最近也是在做性能优化，发现minor gc总是伴随着object.assign出现，不明白什么时机会触发gc","like_count":0},{"had_liked":false,"id":265171,"user_name":"君自兰芳","can_delete":false,"product_type":"c1","uid":2029706,"ip_address":"","ucode":"780F3AFEEB9B73","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f8/8a/f7e7fd54.jpg","comment_is_top":false,"comment_ctime":1606803982,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606803982","product_id":100033601,"comment_content":"&quot;那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间&quot;<br><br>老师，我有个疑问<br>1. 这里说的“保存在堆中的两个对象”，应该指的就是这2个函数对吧?<br>2. 那这2个函数中的局部变量是不是也没有被清理？也跟着函数一起等着主垃圾回收器来回收？","like_count":0,"discussions":[{"author":{"id":2547859,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/93/c512e343.jpg","nickname":"云销雨霁","note":"","ucode":"0F3F5867B9EC82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386575,"discussion_content":"两个对象就是函数内两个对象，非引用类型的数据 包括你说的 局部变量 随着函数上下文已经出栈了已经被销毁了，只剩下存放在堆里的两个对象，需要用到GC来回收\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627649188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258486,"user_name":"藍。","can_delete":false,"product_type":"c1","uid":2100706,"ip_address":"","ucode":"167DC48317D575","user_header":"https://static001.geekbang.org/account/avatar/00/20/0d/e2/6278daac.jpg","comment_is_top":false,"comment_ctime":1604458851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604458851","product_id":100033601,"comment_content":"老师讲的好好  太清晰了！！！！","like_count":0},{"had_liked":false,"id":249827,"user_name":"丁丁丁丁丁大树。","can_delete":false,"product_type":"c1","uid":1351418,"ip_address":"","ucode":"9145022F723883","user_header":"https://static001.geekbang.org/account/avatar/00/14/9e/fa/8d206a46.jpg","comment_is_top":false,"comment_ctime":1600825295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600825295","product_id":100033601,"comment_content":"老师你好，想请问一下，heap里的内存清理是如何判断当前引用是否还活着的？","like_count":0},{"had_liked":false,"id":246304,"user_name":"meet  you","can_delete":false,"product_type":"c1","uid":1374232,"ip_address":"","ucode":"13FA6867EED1DB","user_header":"https://static001.geekbang.org/account/avatar/00/14/f8/18/c9cbb2f0.jpg","comment_is_top":false,"comment_ctime":1599272054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599272054","product_id":100033601,"comment_content":"请问老师：<br>垃圾回收过程中数据被移动，是不是内存地址也发生了改变呢，那在堆中引用的数据怎么拿到之后的呢？","like_count":0},{"had_liked":false,"id":244416,"user_name":"一叉树","can_delete":false,"product_type":"c1","uid":1623117,"ip_address":"","ucode":"BFC984403ACD1F","user_header":"https://static001.geekbang.org/account/avatar/00/18/c4/4d/85014aab.jpg","comment_is_top":false,"comment_ctime":1598510864,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598510864","product_id":100033601,"comment_content":"大道至简。老师的讲解没有别人的讲解字多，但能讲得更通俗易懂。","like_count":0},{"had_liked":false,"id":236286,"user_name":"划水摸鱼小能手","can_delete":false,"product_type":"c1","uid":1602279,"ip_address":"","ucode":"1B5E7CDD49AC49","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL17rDiannrcya8o5PJVfZuSqmDLrTnvuU8239MDOeTXiaLx11M4Wc9YScWajxoibUnKaUTnriaFafLsw/132","comment_is_top":false,"comment_ctime":1595384767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595384767","product_id":100033601,"comment_content":"你好，请问静态属性和变量是存在哪的？又是怎么进行垃圾回收的？也是上面这三种方式之一吗，还是其他？","like_count":0},{"had_liked":false,"id":232990,"user_name":"昵称","can_delete":false,"product_type":"c1","uid":1486529,"ip_address":"","ucode":"38C14BF83EAC1C","user_header":"https://static001.geekbang.org/account/avatar/00/16/ae/c1/76a9237f.jpg","comment_is_top":false,"comment_ctime":1594183668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594183668","product_id":100033601,"comment_content":"是先清理再整理？我看有些文章说是标记-整理-清理这样子。而且有个疑问：增量标记过程不会造成回收与js运用的资源产生冲突吗？","like_count":0},{"had_liked":false,"id":225164,"user_name":"焦糖大瓜子","can_delete":false,"product_type":"c1","uid":1378319,"ip_address":"","ucode":"03E6DA621DFD5F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJxhkqxtWKQeYrYlVYphlicHXW5KmHAvibx6hmice4NTvmn60ZEfTpLp3480umVEquqPdMfwOnecj6Aw/132","comment_is_top":false,"comment_ctime":1591670625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591670625","product_id":100033601,"comment_content":"主垃圾回收机制采用标记-清除算法，标记阶段就是从一组根元素开始，递归遍历这组根元素。这组根元素指的是什么，整个调用栈？","like_count":0},{"had_liked":false,"id":225037,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1591622714,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1591622714","product_id":100033601,"comment_content":"通过chrome的Perfomance面板记录页面的活动，然后在页面上进行各种交互操作，过一段时间后（时间越长越好），停止记录，生成统计数据，然后看timeline下部的内存变化趋势图，如果是有规律的周期平稳变化，则不存在内存泄漏，如果整体趋势上涨则说明存在内存泄漏","like_count":0},{"had_liked":false,"id":224642,"user_name":"Yan赵彦","can_delete":false,"product_type":"c1","uid":1761330,"ip_address":"","ucode":"9F866D13FF2784","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e0/32/7623ebfe.jpg","comment_is_top":false,"comment_ctime":1591494560,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591494560","product_id":100033601,"comment_content":"“从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。”<br>老师，这里写错了哇，函数的执行上下文会从栈中被销毁","like_count":0},{"had_liked":false,"id":222825,"user_name":"Yeehow Chng","can_delete":false,"product_type":"c1","uid":1335916,"ip_address":"","ucode":"3CE6072CA7BEEC","user_header":"https://static001.geekbang.org/account/avatar/00/14/62/6c/923bced2.jpg","comment_is_top":false,"comment_ctime":1590922541,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1590922541","product_id":100033601,"comment_content":"对于堆空间堆垃圾回收机制有一个疑问，在栈空间回收的时候，也即ESP指针下移时，为什么不直接遍历这部分即将出栈的空间中引用到堆地址，并直接把它们标示为失活状态呢？这样可以不需要集中处理标记堆任务，减少全停顿的时间，而且是否会比遍历整个栈空间去找到所有活对象更高效呢？","like_count":0,"discussions":[{"author":{"id":2547859,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/93/c512e343.jpg","nickname":"云销雨霁","note":"","ucode":"0F3F5867B9EC82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386576,"discussion_content":"1. 我觉得是职责分离，负责自己的工作，其他交给别人\n2. 如果存在闭包，我再当前函数上下文找不到闭包的引用，必须去整个执行栈遍历查找，时间就久了，那我还不如直接在堆里找，移动esp指针就很简单，其他交给GC\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627649553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218379,"user_name":"张萌","can_delete":false,"product_type":"c1","uid":1377299,"ip_address":"","ucode":"89C08DB3239BE5","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/13/84d35588.jpg","comment_is_top":false,"comment_ctime":1589792379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589792379","product_id":100033601,"comment_content":"在引用计数策略下，手动断开是有意义的，因为有循环引用的问题。但是采用标记-清除算法的情况下，是通过从根元素遍历是否可到达来判断是否标记为可清除的，那么还需要手动断开对象的引用吗？","like_count":0},{"had_liked":false,"id":217768,"user_name":"EmilyLucky","can_delete":false,"product_type":"c1","uid":1972343,"ip_address":"","ucode":"DBA5FE296CF473","user_header":"https://static001.geekbang.org/account/avatar/00/1e/18/77/d665f258.jpg","comment_is_top":false,"comment_ctime":1589608731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589608731","product_id":100033601,"comment_content":"老师，您好，想请教一下，为何副垃圾回收器需要分两个区域，一个对象区域和一个空闲区域呢？还有为何在清理阶段需要将对象区域里的存活对象（也就是活动对象）复制到空闲区域（复制同时还进行了有序排列，即相当于进行了内存整理）呢？<br>我的理解是，副垃圾回收器之所以分成对象区域和空闲区域，就是为了在清理阶段现将存活对象有序排列后转移到空闲区暂存起来，等到V8引擎将对象区的非活动对象清理后，再将之前转移到空闲区的存活对象再转移回来（只不过这里的操作是将两个区域的角色进行了交换来实现的）。<br>","like_count":0},{"had_liked":false,"id":212610,"user_name":"天然呆","can_delete":false,"product_type":"c1","uid":1377834,"ip_address":"","ucode":"EA738C87964EA5","user_header":"https://static001.geekbang.org/account/avatar/00/15/06/2a/3964c2a2.jpg","comment_is_top":false,"comment_ctime":1588162881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588162881","product_id":100033601,"comment_content":"老师，标记整理算法，这部分这张图，是不是应该有红色的可回收对象？还是说V8老生区垃圾回收是先进行标记-清除过程，然后再进行一次标记-整理过程","like_count":0},{"had_liked":false,"id":212577,"user_name":"烟雨任平生","can_delete":false,"product_type":"c1","uid":1287227,"ip_address":"","ucode":"DD85B01266978F","user_header":"https://static001.geekbang.org/account/avatar/00/13/a4/3b/150c9d64.jpg","comment_is_top":false,"comment_ctime":1588154585,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588154585","product_id":100033601,"comment_content":"老师，对《执行到 showName 函数时的内存模型》这张图有点儿疑惑：1、栈中先初始化到的堆中的地址编号为什么更大呢？2、在大部分的硬件环境中堆都是自下而上增长的嘛？希望老师或者知道的同学解惑。","like_count":0},{"had_liked":false,"id":209752,"user_name":"非洲大地我最凶","can_delete":false,"product_type":"c1","uid":1485254,"ip_address":"","ucode":"30CDE0B486AE26","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoaxy8ibvXITdMcXFfd5O5E7Epq8MG5z1OBhO7MQXTfbcpA0fpcsIxkCHyUZ5ZSrj3spZpAQxEC9GA/132","comment_is_top":false,"comment_ctime":1587609083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587609083","product_id":100033601,"comment_content":"老师，今天回顾了一下发现有点疑问，增量标记算法在2011年就使用了，从Chrome和Node10以后又使用了新的并发标记，您能解释一下并发标记吗","like_count":0},{"had_liked":false,"id":202226,"user_name":"Coutinho","can_delete":false,"product_type":"c1","uid":1730875,"ip_address":"","ucode":"5D52969F8FB3DA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/69/3b/7111598b.jpg","comment_is_top":false,"comment_ctime":1585926835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585926835","product_id":100033601,"comment_content":"您好，请问调用栈和堆是何时创建和销毁的？<br><br>谢谢！","like_count":0},{"had_liked":false,"id":201065,"user_name":"Emma","can_delete":false,"product_type":"c1","uid":1930698,"ip_address":"","ucode":"C2D31142AF7288","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/ca/4c127da3.jpg","comment_is_top":false,"comment_ctime":1585711453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585711453","product_id":100033601,"comment_content":"老师，请问一下，新生代中的垃圾回收是如何判断活动对象和非活动对象的?这块你好像没说呃，只说了老生代中的对象是通过遍历根元素发现有没有引用来判断的。能详细说说吗","like_count":0},{"had_liked":false,"id":194305,"user_name":"刘晓东","can_delete":false,"product_type":"c1","uid":1887520,"ip_address":"","ucode":"84F51E54CC6650","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVBIIzaXQs2Y6rcwwOK510sowo5dH4zTQ2lUuQwsEW4OeDpKgBcEDHN8RcHZ1w2WmFhozAsNFlbA/132","comment_is_top":false,"comment_ctime":1585047839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585047839","product_id":100033601,"comment_content":"@老师，垃圾回收是如何触发的呢？？是固定周期吗？还是当符合某些条件再触发呢","like_count":0},{"had_liked":false,"id":184976,"user_name":"Tim","can_delete":false,"product_type":"c1","uid":1742972,"ip_address":"","ucode":"F51593465157E4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/98/7c/07e6e7b7.jpg","comment_is_top":false,"comment_ctime":1583461274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583461274","product_id":100033601,"comment_content":"老师说的哪个地方的普通话？很魔性，刚开始接受不了，现在已经爱上了😂。","like_count":0},{"had_liked":false,"id":167529,"user_name":"-_-|||","can_delete":false,"product_type":"c1","uid":1328142,"ip_address":"","ucode":"94B21594658BF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/0e/ce14b7d3.jpg","comment_is_top":false,"comment_ctime":1577848975,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1577848975","product_id":100033601,"comment_content":"文中“当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？”执行上下文应该是从栈中被销毁吧，不是堆，虽然堆里相关变量也会被销毁，下文中介绍的都是栈","like_count":0},{"had_liked":false,"id":159986,"user_name":"Juntíng","can_delete":false,"product_type":"c1","uid":1039290,"ip_address":"","ucode":"F6A3B528D6F3FD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/ba/304a9a4a.jpg","comment_is_top":false,"comment_ctime":1575854200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575854200","product_id":100033601,"comment_content":"可以针对页面进行压测，然后结合 chrome 的开发工具的 性能工具和内存工具 针对压测片段来分析堆栈使用情况","like_count":0},{"had_liked":false,"id":158822,"user_name":"-_-|||","can_delete":false,"product_type":"c1","uid":1328142,"ip_address":"","ucode":"94B21594658BF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/0e/ce14b7d3.jpg","comment_is_top":false,"comment_ctime":1575459212,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1575459212","product_id":100033601,"comment_content":"除了‘标记清除法‘还有‘引用计数法‘，那过时的‘引用计数法‘也是发生在老分区吗？","like_count":0},{"had_liked":false,"id":145681,"user_name":"噶水库","can_delete":false,"product_type":"c1","uid":1377138,"ip_address":"","ucode":"9DEA93A8B9FE8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/03/72/5dcfd80a.jpg","comment_is_top":false,"comment_ctime":1572344112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572344112","product_id":100033601,"comment_content":"李老师：我对老生代内存整理哪里有个疑问，内存整理是将分散对数据往一端移动，清除掉碎片内存。那如果之前有一块内存存储的数组，后面我又对数组进行添加操作。那我新增的数据是如何存储呢？（整理之后当前数组内存与其他紧挨着了。。。）","like_count":0},{"had_liked":false,"id":137674,"user_name":"笨笨","can_delete":false,"product_type":"c1","uid":1005351,"ip_address":"","ucode":"6DA6DCAF6A7DCB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/27/805786be.jpg","comment_is_top":false,"comment_ctime":1569818073,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1569818073","product_id":100033601,"comment_content":"如果当前正在运行用户的某一段同步，且CPU Busy，且不断分配内存的方法（比如在一个实现菲波那切函数里不断push array内容，并且不断释放一些array的引用），那么如果过程中内存吃紧了，那么V8能中断此执行过程，执行垃圾回收么？还是不能是不是就直接等着内存崩溃了？","like_count":0},{"had_liked":false,"id":136168,"user_name":"Geek_Leon","can_delete":false,"product_type":"c1","uid":1503246,"ip_address":"","ucode":"EAC6BC158C47AF","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83erLlItp9mBJIDaKMFhJ8W183vH1ib7PuHCoZdW26qIg4ndvSMH6L76NksQcvbnvkayzJEDyq4ptQPg/132","comment_is_top":false,"comment_ctime":1569376153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569376153","product_id":100033601,"comment_content":"老师，想问一下，垃圾回收是什么时候被触发的？触发的条件是什么？","like_count":0},{"had_liked":false,"id":135436,"user_name":"Raion","can_delete":false,"product_type":"c1","uid":1518653,"ip_address":"","ucode":"1FCAF205B1A647","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SsrfN68wK9gq8bzfubEdONfX0WnGPeTxcJQ5ckedJ6SpDYqzKqQAibN27Q41g7EIhgMBfuFksty5BrNr9EzxFeQ/132","comment_is_top":false,"comment_ctime":1569159997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569159997","product_id":100033601,"comment_content":"如果对象使用了循环引用，比如person = { id: 1, name: &#39;John&#39;, myself: person  }, 是不是垃圾回收器就无法回收。","like_count":0},{"had_liked":false,"id":132835,"user_name":"渴望做梦","can_delete":false,"product_type":"c1","uid":1398219,"ip_address":"","ucode":"9EB47530A69C91","user_header":"https://static001.geekbang.org/account/avatar/00/15/55/cb/1efe460a.jpg","comment_is_top":false,"comment_ctime":1568248968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568248968","product_id":100033601,"comment_content":"老师，为啥只是将标记分段处理，删除和整理还是一起处理呢？","like_count":0},{"had_liked":false,"id":131706,"user_name":"钟钟","can_delete":false,"product_type":"c1","uid":1499343,"ip_address":"","ucode":"D1A11CC3EB7137","user_header":"https://static001.geekbang.org/account/avatar/00/16/e0/cf/08b04e00.jpg","comment_is_top":false,"comment_ctime":1567858597,"is_pvip":false,"replies":[{"id":"50346","content":"这些优秀的策略都是相互借鉴","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1567865242,"ip_address":"","comment_id":131706,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567858597","product_id":100033601,"comment_content":"跟Java里面的一样的处理方式，Java里面有s1和s2，老年代也是用来存大对象和存活很久的对象的","like_count":0,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466583,"discussion_content":"这些优秀的策略都是相互借鉴","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567865242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}