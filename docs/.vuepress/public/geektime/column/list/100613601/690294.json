{"id":690294,"title":"03｜工作台：JVM运行时数据区的内部机制是怎样的？","content":"<p>你好，我是康杨。今天这节课我们来聊聊JVM的运行时数据区。了解JVM的方法执行内存模型，掌握更多提升Java程序性能的技巧。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/39/2c18969c0cbf8dd84f3be6fbfa421939.png?wh=1920x890\" alt=\"图片\"></p><p>运行时数据区（Runtime Data Area）用于提供JVM运行时的内存空间的数据。以线程的视角出发，这个区域又分成线程共享区域和线程独享区域。</p><p>线程的独享区域由<strong>程序计数器、虚拟机栈（VM栈）和本地方法栈</strong>构成，它们的使用寿命与线程的运行时间相同，因此可以有效避免垃圾回收的麻烦，并且可以根据线程的不断发展进行相应的调整。</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/83/b542607579b27a9d1424e80985dee383.png?wh=1920x944\" alt=\"图片\"></p><p>线程共享区域包括堆和方法区，方法区用于存储类的结构信息，堆用于存储对象实例等。这节课我们将聚焦在线程独享区域，方法区和堆的介绍我将在类加载器和GC的部分为你详细介绍。</p><h2>程序计数器</h2><p>程序计数器属于线程私有资源，每个线程都有一个唯一的属于自己的程序计数器，指定线程所执行的字节码指令的行号。执行Java方法时，这个地方记录的是线程正在执行的字节码的指令地址，如果执行本地方法，这个地方的值为空。</p><h3>应用场景</h3><p>程序计数器是字节码解释器的核心，它可以根据程序计数器的数值，为下一步的字节码操作提供准确的指引，从而使程序更加高效地完成任务。</p><p>在实际的流程控制中，循环、跳转、分支等基础功能的运作也依赖于程序计数器。在涉及多线程的环境下，程序计数器保存了当前线程运行的位置，这样在线程再次被调用时，可以了解到这个线程之前运行到了什么地方。</p><!-- [[[read_end]]] --><h3>硬件本质</h3><p>程序计数器是JVM对底层硬件中程序计数器和寄存器两个组件的模拟。</p><p>当操作系统决定将CPU的处理对象从一个线程转向另一个线程的时候，需要保留当前线程的状态并复原待执行线程的状态。这个状态就包括程序计数器的值，它存储了当前线程正执行到哪里；还有寄存器的值，存储了当前线程正在进行的计算信息。<strong>保存这些信息并在需要的时候恢复是实现线程切换的关键步骤。</strong>可以说，程序计数器和寄存器在线程切换过程中发挥着至关重要的作用。</p><p>JVM的程序计数器使原生平台和Java之间的线程切换都变得更加流畅了。有趣的是，正因为程序计数器中改变的只是行号，不会像Java的其他内存区域那样，因为程序运行的需要请求更大的空间，所以它是JVM规范中唯一一个没有规定任何 OutOfMemory Error 情况的区域。</p><h2>虚拟机栈</h2><p>我们通常所说的栈就是指的这个区域，它也是JVM中方法执行的内存模型，负责存储当前正在被处理的方法所需的数据、堆上的地址和指令。</p><h3>方法执行内存模型</h3><p>每个线程都有自己独立的栈空间。在触发方法的时候会创建一个<strong>栈帧</strong>结构，这个结构将保存所有与方法关联的信息，包括但不限于局部变量、操作数栈、动态链接以及返回地址。然而栈帧的深度是有限制的，一旦超过这个界限，就会出现 StackOverflowError 异常。每个方法从开始被调用都会有一个栈帧的压栈和出栈操作，这个过程可以一直追溯到VM栈的初始状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/bb/5b3e76d691da9e21d10d1da56f4745bb.png?wh=1902x1148\" alt=\"图片\"></p><p>栈的生命周期和线程相同，所以它是线程私有的。也就是说，不同线程的栈是相互独立的，不会互相干扰。这种设计能有效地隔离各个线程的运行环境，并且在多线程编程中允许每个线程有它自己的局部变量表、操作数栈等资源，有利于提高程序的并发性能。</p><p>Java虚拟机栈在Java运行时内存里占据着重要的地位，主要用来支持Java程序的运行。在一个Java程序中，每一个线程的运行都对应着一个虚拟机栈。</p><p>下面我们就来详细介绍下它的内部构成。</p><h3>局部变量表（Local Variables Table）</h3><p>方法内部定义的局部变量主要放在局部变量表里储存，这些局部变量包括方法的形式参数和方法内部确定的局部变量。每个变量都有一个独立的存储空间，这个空间被称为变量槽（slot）。每个槽都有一个索引号，索引值的范围为0到max_locals-1，其中max_locals表示局部变量表的最大容量。</p><p>一个变量插槽能够储存32位或更少位数的数据类型，包括 boolean 和 char。对比之下，对于64位的数据型如 long 或 double，虚拟机会提供两个紧邻的变量插槽。</p><p><img src=\"https://static001.geekbang.org/resource/image/37/84/37ec91a3db3747d8d2d472bd780b4184.png?wh=1920x980\" alt=\"图片\"></p><h4>存储内容</h4><p>在局部变量表中，retureAddress指向字节码指令，reference则指向堆内存里的对象，8种基本数据类型包括boolean、byte、char、short、int、long、float和double，它们构成了一个完整的局部变量表，可以满足多种需求。</p><h4>两大特性</h4><ol>\n<li>容量确定性</li>\n</ol><p>在把Java程序编译为Class文件的过程中，局部变量表的大小已经被精确地设置好了，并且这个值被存储在方法Code属性的max_locals字段里。因此每次调用一个方法，它对应的局部变量表的大小是确定的，并且在运行期间也不会调整。</p><ol start=\"2\">\n<li>复用性</li>\n</ol><p>为了充分利用空间，局部变量表里的变量槽可以被多次重复使用。比如函数里一个循环内的局部变量，它的作用域只在当前循环中，这时候后面的变量可以占用这个变量的slot。</p><pre><code class=\"language-java\">public class LocalVariableTableExample {\n public static void main(String[] args) {\n   int a = 10;\n   int b = 20;\n   int sum = add(a, b);\n   System.out.println(\"Sum: \" + sum);\n }\n public static int add(int x, int y) {\n   int result = x + y;\n   return result;\n }\n}\n</code></pre><p>上面代码的main方法中声明了三个局部变量 a、b、sum，还调用了 add 方法。add 方法中也有一个局部变量 result。这些局部变量在JVM的局部变量表里占据了槽位。你可以看一下对应的字节码。</p><pre><code class=\"language-java\">public class LocalVariableTableExample {\npublic static void main(java.lang.String[]);\ndescriptor: ([Ljava/lang/String;)V\nflags: ACC_PUBLIC, ACC_STATIC\nCode:\nstack=2, locals=4, args_size=1\n0: bipush 10\n2: istore_1 // 将10存储到局部变量表槽1\n3: bipush 20\n5: istore_2 // 将20存储到局部变量表槽2\n6: iload_1 // 将局部变量表槽1中的值加载到栈顶\n7: iload_2 // 将局部变量表槽2中的值加载到栈顶\n8: invokestatic #2 // 调用add方法\n11: istore_3 // 将返回值存储到局部变量表槽3\n12: getstatic #3 // 获取静态字段System.out\n15: new #4 // 创建一个StringBuilder对象\n18: dup\n19: ldc #5 // 加载字符串 \"Sum: \"\n21: invokespecial #6 // 调用StringBuilder的构造函数\n24: iload_3 // 将局部变量表槽3中的值加载到栈顶\n25: invokevirtual #7 // 调用StringBuilder的append方法\n28: invokevirtual #8 // 调用StringBuilder的toString方法\n31: invokevirtual #9 // 调用PrintStream的println方法\n34: return\n}\n</code></pre><p>通过 istore_x 和 iload_x，可以把字节码里的值存储到局部变量表槽中，并把它加载到栈顶，其中 x 代表槽位的索引。</p><p>在main方法里，a和b分别存储在局部变量表槽位1和2中。这些变量在调用 add 方法之前是不需要的，因此在调用 add 方法之前，它们的值会被加载到栈顶。</p><p>add 方法中的 x 和 y 参数分别存储在局部变量表槽3和4中，而 result 变量存储在槽5中。在方法内部将 x 和 y 相加后，把结果存储在 result 里，并返回结果。</p><p>JVM使用局部变量表来存储方法中的局部变量以及方法参数，这些局部变量表槽位的替代性允许在不同阶段使用相同的槽位来存储不同的变量，从而提高内存的利用效率。在示例中，a 和 b 的槽位在调用 add 方法之前被重用，而 result 的槽位在add方法执行完毕后被重新用来存储 sum 的值。这就提醒我们，尽可能地减小每个变量的作用域，这样就为虚拟机提供了更多可能性去优化局部变量表，重用槽位，从而减少了内存占用。</p><h4>其他用途</h4><p>局部变量表是 GC Root 的一部分，当slot里存放的数据类型是reference的时候，它关联的对象就是GC里的 “可达对象”。关于JVM定位可达对象的详细信息，在课程的第13讲我会详细介绍。</p><h3>操作数栈</h3><p>Java虚拟机的执行引擎采用的是“基于栈”的方式，这里所说的栈指的就是操作数栈。操作数栈按字长进行组织，通过压栈（push）和出栈等方式访问。一个命令可以将一个数值推入操作数栈，而另一个命令则可以把数值从里面取出来，从而实现对数据的快速访问。值得注意的是，当数据类型，比如byte、short和char，被写入操作数栈的时候，它们会被转换成int类型。</p><p>在了解了这些基础信息后，我们可以把操作数栈看作Java虚拟机的工作空间。因为大多数指令都从操作数栈弹出数据进行计算，然后把结果压回操作数栈。</p><pre><code class=\"language-java\">public class OperandStack{\n&nbsp;&nbsp;&nbsp; public static void main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = add(1, 2);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(result);\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; public static int add(int a, int b) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c = a + b;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return c;\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>字节码使用 <code>javap -c OperandStack</code> 命令可以得到。</p><pre><code class=\"language-java\">public class OperandStack {\n&nbsp;&nbsp;&nbsp; public static void main(java.lang.String[]);\n&nbsp;&nbsp;&nbsp; Code:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0: iconst_1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1: iconst_2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2: invokestatic&nbsp; #2&nbsp;// Method add:(II)I\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5: istore_1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6: getstatic&nbsp;&nbsp;&nbsp;&nbsp; #3&nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9: iload_1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10: invokevirtual #4 // Method java/io/PrintStream.println:(I)V\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13: return\n&nbsp;\n&nbsp;&nbsp;&nbsp; public static int add(int, int);\n&nbsp;&nbsp;&nbsp; Code:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  0: iload_0\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1: iload_1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2: iadd\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3: istore_2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4: iload_2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5: ireturn\n}\n</code></pre><p>对于 add 方法，字节码的工作方式是这样的：</p><ul>\n<li>iload_0 和 iload_1 把参数a、b分别压入操作数栈。</li>\n<li>iadd 指令弹出栈顶的两个元素，也就是参数a和b，执行加法操作，并把结果变量c压回栈顶。</li>\n<li>将栈顶元素保存到局部变量表的第二个位置，也就是变量c所在的位置，是istore_2的操作。</li>\n<li>iload_2的工作是把局部变量表中第二个位置的元素，也就是变量c的值，重新放回栈顶。</li>\n<li>ireturn 是把栈顶元素（变量c的值）作为返回值返回。</li>\n</ul><p>通过这个过程我们可以观察到，JVM是如何利用操作数栈进行数据的传递和计算的。在使用JVM操作数栈的时候，一般无需进行额外的操作或优化，因为这些都已经由JVM自动管理了。但了解其中的工作原理，能帮助我们更好地理解Java程序运行的过程。</p><h3>动态链接（Dynamic Linking）</h3><p>动态链接会在程序运行时通过链接到运行时常量池的引用，来找到与每个栈帧相关的方法。这让我们在实现方法调用的时候能够进行动态链接。</p><p>在类文件的常量池里，含有大量的符号引用，这些都是方法调用指令的参数，这些参数在字节码中表现为指向方法的符号引用。无论是在类加载的阶段还是第一次使用的时候，一部分符号引用会被转换为直接引用，这种转换过程被我们叫做静态解析。另一部分符号引用则会在每次运行时都转化为直接引用，也就是所谓的动态链接。</p><pre><code class=\"language-java\">public class DynamicLinking {\n&nbsp;&nbsp;&nbsp; public void methodA(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"---------start methodA-------------\");\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>执行指令：</p><pre><code class=\"language-java\">javap -verbose -p DynamicLinking\n</code></pre><p>得到对应的字节码。</p><pre><code class=\"language-java\">public void methodA();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp; descriptor: ()V\n&nbsp; flags: ACC_PUBLIC\n&nbsp; Code:\n&nbsp; &nbsp;stack=2, locals=1, args_size=1\n&nbsp; &nbsp;0: getstatic&nbsp;&nbsp;&nbsp;&nbsp; #3&nbsp;&nbsp;&nbsp; //使用动态链接，指向Field out:Ljava/io/PrintStream;\n&nbsp;&nbsp;&nbsp;3: ldc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #4&nbsp;&nbsp;&nbsp;&nbsp;//使用动态链接，引用String \"---------start methodA-------------\"\n&nbsp;&nbsp;&nbsp;5: invokevirtual #5&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;LineNumberTable:\n&nbsp; &nbsp;line 7: 0\n&nbsp;&nbsp;&nbsp;line 8: 8\n&nbsp; LocalVariableTable:\n&nbsp; &nbsp; Start&nbsp; Length&nbsp; Slot&nbsp; Name&nbsp;&nbsp; Signature\n&nbsp; &nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; this&nbsp;&nbsp; Lcom/future/DynamicLinking;&nbsp;\n</code></pre><h4>主要作用</h4><ol>\n<li>决定方法如何调用</li>\n</ol><p>在JVM里，调用指令主要分为两种，一种是执行已经确定的静态方法，而另一种是调用在运行过程中的方法。动态链接负责替换这些需要在运行时才能确定的方法的符号引用。</p><ol start=\"2\">\n<li>提高性能</li>\n</ol><p>静态编译可能会生成大量的目标代码，而动态链接只在实际需要的时候才进行链接，能够大大减少链接的工作量，提高性能。</p><h4>最佳实践</h4><p>在实际编程中，动态链接展现在Java的多态特性中，通常在面向对象的编程中，我们会利用虚函数或者接口来实现多态。这个过程实际上就是动态链接的应用。我们需要根据实际的运行状态来决定调用哪个方法，这种需要在运行时才能确定的链接过程就是动态链接。</p><h3>返回地址</h3><p>栈帧的返回地址用于方法执行结束后，返回到方法被调用的位置。</p><p>方法执行结束的方式有两种：正常结束和异常结束。正常结束是方法内部处理完成，异常结束则是方法内部无法处理异常而导致的退出。</p><p>对于正常结束，栈帧将保存程序计数器的数值作为返回地址。当方法正常退出后，这个数值可以指示程序继续处理的位置。另外，如果方法有返回值，那么这个值会被放到调动者的栈帧里。对于异常结束，返回地址需要通过异常处理器表来获取，因为异常退出的方法不会向调用者返回任何值，所以栈帧通常不会有这部分信息。</p><p>任何情况下，当方法退出后都要回到最初的方法调用位置，来恢复并继续程序的执行。针对每个栈帧，我们还需要提供一个引用，以此在运行时常量池内可以识别出对应的方法，且在方法被调用的过程中能实现动态链接。</p><p>无论是正常退出还是异常退出，方法的返回地址都很关键，可以帮助程序恢复并继续执行。对于正常退出，返回地址一般来自PC计数器；对于异常退出，则来自异常处理器表。</p><h2>本地方法栈</h2><p>本地方法栈与虚拟机栈在功能上有很多相似之处，但是它们之间还是有一些区别的。虚拟机栈主要用于执行Java方法，也就是字节码，而本地方法栈主要负责执行由非Java语言（如C、C++）编写的Native方法。</p><p>每个线程都拥有一个和它生命周期相同的私有本地方法栈。虚拟机没有对本地方法栈使用的编程语言、实现方式和数据结构做严格限制，这意味着不同的虚拟机可以根据自己的需求实现本地方法栈。例如，Sun HotSpot虚拟机就直接把本地方法栈和虚拟机栈合并为一个。</p><p>和虚拟机栈一样，本地方法栈也可能在栈深度超过虚拟机允许的范围时，抛出StackOverflowError，在虚拟机栈动态扩展无法申请到足够内存时，抛出OutOfMemoryError。本地方法栈不仅关系到Java与其他语言的互通，而且对程序性能也有很大影响。随着JDK不断发展，本地方法栈也在逐步优化。</p><h2>重点回顾</h2><p>这节课我们学习了JVM运行时数据区的内部构成和应用场景。其中，虚拟机栈是JVM方法执行内存模型的载体，程序计数器则是将JVM中的线程与底层硬件平台线程平滑切换的关键组件。局部变量表通过槽位共用的方式提高了内存效率，同时动态链接也是提高Java程序性能的重要手段。通过学习这些内容，我们更深入地理解了JVM运行时数据区的实现原理和优化策略。</p><p>所以我们要尽可能地减小每个变量的作用域，为虚拟机提供了更多的可能性去优化局部变量表，重用槽位，从而减少了内存占用。知己知彼，百战不殆，越熟悉每天陪伴我们的工具，越有利于我们写出更优雅的Java程序。希望你学完这节课的内容之后，再去检查下自己写的代码，看看还有哪些可优化的空间。</p><h2>思考题</h2><ul>\n<li>JVM中方法执行的内存模型对应的是运行时数据区的那个区域？</li>\n<li>这节课你学到了哪些提升程序性能的技巧？</li>\n</ul><p>欢迎你把思考后的结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p><h2>💡 点亮你的知识框架图</h2><p><img src=\"https://static001.geekbang.org/resource/image/19/09/19c29335cba7e247081d41cfb18da609.jpg?wh=8489x6347\" alt=\"\"></p>","comments":[{"had_liked":false,"id":380161,"user_name":"Levi","can_delete":false,"product_type":"c1","uid":2221236,"ip_address":"北京","ucode":"F804879872BB76","user_header":"https://static001.geekbang.org/account/avatar/00/21/e4/b4/889954ca.jpg","comment_is_top":false,"comment_ctime":1693123032,"is_pvip":false,"replies":[{"id":139138,"content":"在JVM中，Slot（插槽）是用来存储局部变量的数据结构。当一个方法被调用时，JVM会在栈帧中为这个方法分配一个局部变量表，以存放该方法的所有局部变量。而每一个局部变量，在这个局部变量表中就占用一个或者多个Slot。所以，对于你提到的情况，变量a的值2会被保存在Slot中，而变量a本身，也就是变量名，不会存储在Slot中。在Java中，变量名只是在编译阶段存在，用来帮助开发者理解和操作数据。一旦编译结束，变量名就不再需要了，因为JVM在运行时，只关心数据，而不关心这个数据是通过什么变量名得到的。所以说，变量a本身会在编译结束后被丢弃，只有它的值2会被保存在Slot中。","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1696515831,"ip_address":"北京","comment_id":380161,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"老师请教一个问题，Slot只保存局部变量的值吗，比如a=2，slot中保存的是2这个数据值，那a这个变量被保存在哪里呢？","like_count":3,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629022,"discussion_content":"在JVM中，Slot（插槽）是用来存储局部变量的数据结构。当一个方法被调用时，JVM会在栈帧中为这个方法分配一个局部变量表，以存放该方法的所有局部变量。而每一个局部变量，在这个局部变量表中就占用一个或者多个Slot。所以，对于你提到的情况，变量a的值2会被保存在Slot中，而变量a本身，也就是变量名，不会存储在Slot中。在Java中，变量名只是在编译阶段存在，用来帮助开发者理解和操作数据。一旦编译结束，变量名就不再需要了，因为JVM在运行时，只关心数据，而不关心这个数据是通过什么变量名得到的。所以说，变量a本身会在编译结束后被丢弃，只有它的值2会被保存在Slot中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696515831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381453,"user_name":"记得晚睡","can_delete":false,"product_type":"c1","uid":3720824,"ip_address":"北京","ucode":"C3DA9EDA2DBDB7","user_header":"https://static001.geekbang.org/account/avatar/00/38/c6/78/dc201b84.jpg","comment_is_top":false,"comment_ctime":1695220895,"is_pvip":false,"replies":[{"id":139130,"content":"坚持学习就会觉得越来越简单，加油💪🏻💪🏻💪🏻💪🏻","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1696514487,"ip_address":"北京","comment_id":381453,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"好难啊😭😭😭","like_count":2,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629013,"discussion_content":"坚持学习就会觉得越来越简单，加油💪🏻💪🏻💪🏻💪🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696514488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1270449,"avatar":"https://static001.geekbang.org/account/avatar/00/13/62/b1/3d1fc497.jpg","nickname":"三万棵树","note":"","ucode":"EB361BB4E09AE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640852,"discussion_content":"没啥办法呀，学起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711940606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380830,"user_name":"funnyx","can_delete":false,"product_type":"c1","uid":1115049,"ip_address":"浙江","ucode":"A9B8E27919AE4D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoZqcVJzUjfu5noOW6OPAh6ibrBicibLmicibnVyVLHdf7GwAzf2th5s1oQ9pUbLpmq2mlVBauUZn8QUnw/132","comment_is_top":false,"comment_ctime":1694250963,"is_pvip":false,"replies":[{"id":139126,"content":"Java提供了一种机制，叫做动态类加载，可以在JVM运行时将新的Java类(.class文件)添加到正在运行的应用程序中","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1696514002,"ip_address":"北京","comment_id":380830,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"请问老师，有没有什么方法在jvm运行时，向其中添加class文件让其加载。","like_count":1,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629007,"discussion_content":"Java提供了一种机制，叫做动态类加载，可以在JVM运行时将新的Java类(.class文件)添加到正在运行的应用程序中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696514002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380080,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"重庆","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1692934534,"is_pvip":false,"replies":[{"id":138446,"content":"当进行CPU时间片切换时，Java虚拟机需要恢复本地方法的执行上下文，确保从切换中恢复过来后能够继续执行本地方法。为了实现上下文的恢复，Java虚拟机会利用操作系统的调度机制，将本地方法的执行状态保存在与本地方法相对应的线程栈帧中。当线程被重新调度执行时，会从保存的栈帧中恢复本地方法的执行上下文，继续执行本地方法。\n需要注意的是，由于本地方法的执行过程是在本地库中进行的，具体的上下文恢复过程是与操作系统和本地库相关的，并且可能因不同的操作系统或本地库而有所不同。 Java虚拟机只负责协助操作系统进行本地方法与Java线程的切换，并确保上下文的正确恢复。","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1693117556,"ip_address":"北京","comment_id":380080,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"程序计数器是记录程序正在执行字节码的指令地址，但是执行本地方法，为空。\n请问一下老师，执行本地方，程序计数器记录的指令地址为空，在cpu时间片切换时，怎么再次恢复本地方法的执行上下文？","like_count":1,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626561,"discussion_content":"当进行CPU时间片切换时，Java虚拟机需要恢复本地方法的执行上下文，确保从切换中恢复过来后能够继续执行本地方法。为了实现上下文的恢复，Java虚拟机会利用操作系统的调度机制，将本地方法的执行状态保存在与本地方法相对应的线程栈帧中。当线程被重新调度执行时，会从保存的栈帧中恢复本地方法的执行上下文，继续执行本地方法。\n需要注意的是，由于本地方法的执行过程是在本地库中进行的，具体的上下文恢复过程是与操作系统和本地库相关的，并且可能因不同的操作系统或本地库而有所不同。 Java虚拟机只负责协助操作系统进行本地方法与Java线程的切换，并确保上下文的正确恢复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693117556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380077,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"广东","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1692930336,"is_pvip":false,"replies":[{"id":138439,"content":"我在后面几节马上就好讲这个了，应该下周就能看到了，你可以先看下，有问题我们随时沟通","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1693116583,"ip_address":"北京","comment_id":380077,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"大佬好：\n请问下“运行时常量池”包括哪些东西，在运行时数据区的哪个位呢置（本文好像没说？）？\n与“字符串常量池”有什么区别，为什么还需要特意再分出来多一个常量池呢？","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626553,"discussion_content":"我在后面几节马上就好讲这个了，应该下周就能看到了，你可以先看下，有问题我们随时沟通","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693116583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381190,"user_name":"Geek1254","can_delete":false,"product_type":"c1","uid":2028941,"ip_address":"北京","ucode":"BC2F7756A0676D","user_header":"","comment_is_top":false,"comment_ctime":1694768479,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"看了两节，感觉讲的东西太浅，不适合工作多年的老鸟。要硬干货","like_count":5},{"had_liked":false,"id":380171,"user_name":"临风","can_delete":false,"product_type":"c1","uid":1145430,"ip_address":"广东","ucode":"59A7F3DDD94D76","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/56/29877cb9.jpg","comment_is_top":false,"comment_ctime":1693141577,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"1、JVM 中方法执行的内存模型对应的是运行时数据区的那个区域？\n运行时数据区包括程序计数器、虚拟机栈、本地方法栈、方法区、堆区。一个执行方法对应虚拟机栈的一个栈帧，栈帧会保存局部变量表、操作数栈、动态链接、返回地址等。\n\n2、这节课你学到了哪些提升程序性能的技巧？\n一是不要定义多余的变量；二是方法不要过长。这两个都是编程规范要求的，之前以为仅仅只是为了可读性，还是为了避免局部变量表空间的浪费。","like_count":1},{"had_liked":false,"id":387903,"user_name":"Geek_0e0559","can_delete":false,"product_type":"c1","uid":2570732,"ip_address":"黑龙江","ucode":"9CEE48B4E2BE85","user_header":"","comment_is_top":false,"comment_ctime":1708906855,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"针对每个栈帧，我们还需要提供一个引用，以此在运行时常量池内可以识别出对应的方法，且在方法被调用的过程中能实现动态链接。-- 这句话没看明白","like_count":0},{"had_liked":false,"id":380113,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"河北","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1693012518,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"请教老师几个问题：\nQ1：动态链接部分的methodA方法的疑问：\n--- 此函数没有参数，为什么args_size是1？\n--- 此函数没有局部变量，为什么locals是1？\n--- stack=2是什么意思？\nQ2：sun hotpot将两个栈合并，虚拟机栈是执行Java代码的，那么本地方法还能执行C或C++代码吗？\nQ3：本课所说的“动态链接”，主要是指“动态绑定”，即多态，不是指“动态链接库”一类的内容，对吗？ \nQ4：Java程序可以使用C或C++的DLL吗？","like_count":0,"discussions":[{"author":{"id":1044639,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f0/9f/46d8f49a.jpg","nickname":"华伦","note":"","ucode":"A4F27CC1C38D3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627636,"discussion_content":"合并这两种栈并不意味着HotSpot不能执行本地（C或C++）代码。实际上，Java通过Java本地接口（JNI，Java Native Interface）可以与本地代码（通常是C或C++代码）交互。当Java程序调用一个本地方法时，控制权会转移到本地方法栈中的一个帧（在HotSpot中，这与Java虚拟机栈是同一个栈）。\n\n在这个本地方法栈帧中，可能会有一个指向C或C++函数的指针。执行这个函数时，实际上是在本地方法栈中进行的，尽管这个栈和Java虚拟机栈在HotSpot中是合并的。这样，本地代码就可以与Java代码共享数据、状态和控制流，尽管它们是用不同的编程语言编写的。\n\n虽然HotSpot把Java虚拟机栈和本地方法栈合并为一个，但这并不妨碍它执行本地C或C++代码。这主要是通过JNI来实现的，JNI允许Java代码和本地代码互相调用和数据共享。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694403190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}