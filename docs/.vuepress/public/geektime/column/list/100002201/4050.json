{"id":4050,"title":"44 | 弹力设计篇之“幂等性设计”","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p><p>所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。用数学的语言来表达就是：f(x)  = f(f(x))。</p><p>比如，求绝对值的函数，abs(x) = abs(abs(x))。</p><p>为什么我们需要这样的操作？说白了，就是在我们把系统解耦隔离后，服务间的调用可能会有三个状态，一个是成功（Success），一个是失败（Failed），一个是超时（Timeout）。前两者都是明确的状态，而超时则是完全不知道是什么状态。</p><p>比如，超时原因是网络传输丢包的问题，可能是请求时就没有请求到，也有可能是请求到了，返回结果时没有正常返回等等情况。于是我们完全不知道下游系统是否收到了请求，而收到了请求是否处理了，成功/失败的状态在返回时是否遇到了网络问题。总之，请求方完全不知道是怎么回事。</p><p>举几个例子：</p><ul>\n<li>\n<p>订单创建接口，第一次调用超时了，然后调用方重试了一次。是否会多创建一笔订单？</p>\n</li>\n<li>\n<p>订单创建时，我们需要去扣减库存，这时接口发生了超时，调用方重试了一次。是否会多扣一次库存？</p>\n</li>\n<li>\n<p>当这笔订单开始支付，在支付请求发出之后，在服务端发生了扣钱操作，接口响应超时了，调用方重试了一次。是否会多扣一次钱？</p>\n</li>\n</ul><p>因为系统超时，而调用方重试一下，会给我们的系统带来不一致的副作用。</p><!-- [[[read_end]]] --><p>在这种情况下，一般有两种处理方式。</p><ul>\n<li>\n<p>一种是需要下游系统提供相应的查询接口。上游系统在timeout后去查询一下。如果查到了，就表明已经做了，成功了就不用做了，失败了就走失败流程。</p>\n</li>\n<li>\n<p>另一种是通过幂等性的方式。也就是说，把这个查询操作交给下游系统，我上游系统只管重试，下游系统保证一次和多次的请求结果是一样的。</p>\n</li>\n</ul><p>对于第一种方式，需要对方提供一个查询接口来做配合。而第二种方式则需要下游的系统提供支持幂等性的交易接口。</p><h1>全局ID</h1><p>要做到幂等性的交易接口，需要有一个唯一的标识，来标志交易是同一笔交易。而这个交易ID由谁来分配是一件比较头疼的事。因为这个标识要能做到全局唯一。</p><p>如果由一个中心系统来分配，那么每一次交易都需要找那个中心系统来。 这样增加了程序的性能开销。如果由上游系统来分配，则可能会出现ID分配重复的问题。因为上游系统可能会是一个集群，它们同时承担相同的工作。</p><p>为了解决分配冲突的问题，我们需要使用一个不会冲突的算法，比如使用UUID这样冲突非常小的算法。但UUID的问题是，它的字符串占用的空间比较大，索引的效率非常低，生成的ID太过于随机，完全不是人读的，而且没有递增，如果要按前后顺序排序的话，基本不可能。</p><p>在全局唯一ID的算法中，这里介绍一个Twitter 的开源项目 Snowflake。它是一个分布式ID的生成算法。它的核心思想是，产生一个long型的ID，其中：</p><ul>\n<li>41bits作为毫秒数。大概可以用69.7年。</li>\n<li>10bits作为机器编号（5bits是数据中心，5bits的机器ID），支持1024个实例。</li>\n<li>12bits作为毫秒内的序列号。一毫秒可以生成4096个序号。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/2f/38/2f637bc4789b00cdb4bb05f510cefd38.jpg?wh=2286x1083\" alt=\"\"><br>\n其他的像Redis或MongoDB的全局ID生成都和这个算法大同小异。我在这里就不多说了。你可以根据实际情况加上业务的编号。</p><h1>处理流程</h1><p>对于幂等性的处理流程来说，说白了就是要过滤一下已经收到的交易。要做到这个事，我们需要一个存储来记录收到的交易。</p><p>于是，当收到交易请求的时候，我们就会到这个存储中去查询。如果查找到了，那么就不再做查询了，并把上次做的结果返回。如果没有查到，那么我们就记录下来。</p><p><img src=\"https://static001.geekbang.org/resource/image/9b/c5/9b7d271c8a25fd0bd626b0cb7d9f24c5.jpg?wh=1587x1809\" alt=\"\"><br>\n但是，上面这个流程有个问题。因为绝大多数请求应该都不会是重新发过来的，所以让100%的请求都到这个存储里去查一下，这会导致处理流程变得很慢。</p><p>所以，最好是当这个存储出现冲突的时候会报错。也就是说，我们收到交易请求后，直接去存储里记录这个ID（相对于数据的Insert操作），如果出现ID冲突了的异常，那么我们就知道这个之前已经有人发过来了，所以就不用再做了。比如，数据库中你可以使用 <code>insert into … values … on DUPLICATE KEY UPDATE … </code> 这样的操作。</p><p>对于更新的场景来说，如果只是状态更新，可以使用如下的方式。如果出错，要么是非法操作，要么是已被更新，要么是状态不对，总之多次调用是不会有副作用的。</p><p><code>update table set status = “paid” where id = xxx and status = “unpaid”;</code></p><p>当然，网上还有MVCC通过使用版本号等其他方式，我觉得这些都不标准，我们希望我们有一个标准的方式来做这个事，所以，最好还是用一个ID。</p><p>因为我们的幂等性服务也是分布式的，所以，需要这个存储也是共享的。这样每个服务就变成没有状态的了。但是，这个存储就成了一个非常关键的依赖，其扩展性和可用性也成了非常关键的指标。</p><p>你可以使用关系型数据库，或是key-value的NoSQL（如MongoDB）来构建这个存储系统。</p><h1>HTTP的幂等性</h1><p><strong> HTTP GET方法用于获取资源，不应有副作用，所以是幂等的</strong>。比如：GET <code>http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET <code>http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</p><p><strong>HTTP HEAD 和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息，不应有副作用，也是幂等的</strong>。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。也就是说，HEAD方法可以用来做探活使用。</p><p><strong>HTTP OPTIONS 主要用于获取当前URL所支持的方法，所以也是幂等的</strong>。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p><p><strong>HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性</strong>。比如：DELETE <code>http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉ID为4231的帖子。因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p><p><strong>HTTP POST方法用于创建资源，所对应的URI并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性</strong>。比如：POST <code>http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</p><p><strong>HTTP PUT方法用于创建或更新操作，所对应的URI是要创建或更新的资源本身，有副作用，它应该满足幂等性</strong>。比如：PUT <code>http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p><p>所以，对于POST的方式，很可能会出现多次提交的问题，就好比，我们在论坛中发帖时，有时候因为网络有问题，可能会对同一篇贴子出现多次提交的情况。对此，一般的幂等性的设计如下。</p><ul>\n<li>\n<p>首先，在表单中需要隐藏一个token，这个token可以是前端生成的一个唯一的ID。用于防止用户多次点击了表单提交按钮，而导致后端收到了多次请求，却不能分辨是否是重复的提交。这个token是表单的唯一标识。（这种情况其实是通过前端生成ID把POST变成了PUT。）</p>\n</li>\n<li>\n<p>然后，当用户点击提交后，后端会把用户提交的数据和这个token保存在数据库中。如果有重复提交，那么数据库中的token会做排它限制，从而做到幂等性。</p>\n</li>\n<li>\n<p>当然，更为稳妥的做法是，后端成功后向前端返回302跳转，把用户的前端页跳转到GET请求，把刚刚POST的数据给展示出来。如果是Web上的最好还把之前的表单设置成过期，这样用户不能通过浏览器后退按钮来重新提交。这个模式又叫做 <a href=\"https://en.wikipedia.org/wiki/Post/Redirect/Get\">PRG模式</a>（Post/Redirect/Get）。</p>\n</li>\n</ul><h1>小结</h1><p>好了，我们来总结一下今天分享的主要内容。首先，幂等性的含义是，一个调用被发送多次所产生的副作用和被发送一次所产生的副作用是一样的。而服务调用有三种结果：成功、失败和超时，其中超时是我们需要解决的问题。</p><p>解决手段可以是超时后查询调用结果，也可以是在被调用的服务中实现幂等性。为了在分布式系统中实现幂等性，我们需要实现全局ID。Twitter的Snowflake就是一个比较好用的全局ID实现。最后，我给出了幂等性接口的处理流程。</p><p>下节课，我们讲述服务的状态。希望对你有帮助。</p><p>也欢迎你分享一下你的分布式服务中所有交易接口是否都实现了幂等性？你所使用的全局ID算法又是什么呢？</p><p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。</p><ul>\n<li>弹力设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/3912\">认识故障和弹力设计</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/3917\">隔离设计Bulkheads</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/3926\">异步通讯设计Asynchronous</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4050\">幂等性设计Idempotency</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4086\">服务的状态State</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4087\">补偿事务Compensating Transaction</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4121\">重试设计Retry</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4241\">熔断设计Circuit Breaker</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4245\">限流设计Throttle</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4252\">降级设计degradation</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4253\">弹力设计总结</a></li>\n</ul>\n</li>\n<li>管理设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/5175\">分布式锁Distributed Lock</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5819\">配置中心Configuration Management</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5909\">边车模式Sidecar</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5920\">服务网格Service Mesh</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/6086\">网关模式Gateway</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/6283\">部署升级策略</a></li>\n</ul>\n</li>\n<li>性能设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/6282\">缓存Cache</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7036\">异步处理Asynchronous</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7045\">数据库扩展</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7047\">秒杀Flash Sales</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7086\">边缘计算Edge Computing</a></li>\n</ul>\n</li>\n</ul>","comments":[{"had_liked":false,"id":3821,"user_name":"halfamonk","can_delete":false,"product_type":"c1","uid":1063082,"ip_address":"","ucode":"DAAF0B37940214","user_header":"https://static001.geekbang.org/account/avatar/00/10/38/aa/52645d93.jpg","comment_is_top":false,"comment_ctime":1520734825,"is_pvip":false,"replies":[{"id":"801","content":"谢谢回复，我理解你的意思。不过数学上的幂等的确是这样描述的。参看：https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Idempotence","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1520776244,"ip_address":"","comment_id":3821,"utype":1}],"discussion_count":5,"race_medal":0,"score":"91715048041","product_id":100002201,"comment_content":"私以为f(x) = f(f(x)) 这个数学公式表达幂等性不太对。因为f(f(x))应该是代表把f(x)的“结果”当作参数重新传入f()。这和文字的表述还是有区别的","like_count":21,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":416069,"discussion_content":"谢谢回复，我理解你的意思。不过数学上的幂等的确是这样描述的。参看：https://en.wikipedia.org/wiki/Idempotence","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1520776244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2283151,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d6/8f/6ae4af20.jpg","nickname":"思考重组","note":"","ucode":"2992588647CF79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324148,"discussion_content":"这是因为，只有符合这个条件的公式才冥等，比如abs符合但是取反就不符合。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605061921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052994,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/226NabDEu1IGMN7Om1gQqG22hk2dZKojpB0KDpAK0vtujQLdlgZsVaPbIc4ymcib0NdH3Syh8YibRuL7Lv5kVCkg/132","nickname":"果子","note":"","ucode":"D7B288A3E722F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407952,"discussion_content":"我一开始也有这个困惑，数学是严谨的，如果出现矛盾那就是我们理解错了。主要问题就出在对f(x)的理解，一般人会把x理解为函数调用的参数，f(x)就是函数本身，如果这样定义域和值域不一定相同，因而就无法复合。x的真正含义应该是系统的状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635155980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2547238,"avatar":"https://static001.geekbang.org/account/avatar/00/26/de/26/f51798b4.jpg","nickname":"Lynn","note":"","ucode":"1890F48F83D1F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400775,"discussion_content":"他的意思是相同的处理计算作用在了同一个地方，x表示的并不是方法的入参，而是f()所会影响到的地方","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633420578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309597,"discussion_content":"我也觉得好奇怪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601363508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3545,"user_name":"macworks","can_delete":false,"product_type":"c1","uid":1010461,"ip_address":"","ucode":"DA876F75C0790B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1d/3f99f2a5.jpg","comment_is_top":false,"comment_ctime":1519867465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61649409609","product_id":100002201,"comment_content":"等幂性讲的很清楚","like_count":15},{"had_liked":false,"id":12916,"user_name":"study","can_delete":false,"product_type":"c1","uid":1156976,"ip_address":"","ucode":"C94CC291DDCEDD","user_header":"https://static001.geekbang.org/account/avatar/00/11/a7/70/e9d07225.jpg","comment_is_top":false,"comment_ctime":1529132120,"is_pvip":false,"discussion_count":14,"race_medal":0,"score":"31593903192","product_id":100002201,"comment_content":"没有理解，感觉应该用业务内容做id，比如参数，要不然下游超时，上游再次发送请求，生成的id是不同的","like_count":8,"discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102607,"discussion_content":"我的理解是这样的，这个ID是上游系统放进去的，因此当上游系统发送给下游系统后，返回超时，此时上游系统是需要再次发送的，这时候下游系统拿到的ID和上次是一样的","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1577356706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1855461,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqeDhtia1hn5zFEuWfLc5MTBJlicic9FVF87qcpK3z0AhaXVgKEkgWoS2gplHtFPqhIicviaRISK67PXIg/132","nickname":"fesine","note":"","ucode":"CD1B4F52E04B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271484,"discussion_content":"所以很多平台设计会有统一的业务跟踪号，由入口生成，传入下游系统，下游系统即使生成了自己的id，但业务上是由上游生成传过来的，当上游没有传入业务跟踪号时，才使用自己生成的id。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1590146321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1439953,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f8/d1/45800380.jpg","nickname":"Glory_Jin","note":"","ucode":"8E2386906B5863","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1855461,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqeDhtia1hn5zFEuWfLc5MTBJlicic9FVF87qcpK3z0AhaXVgKEkgWoS2gplHtFPqhIicviaRISK67PXIg/132","nickname":"fesine","note":"","ucode":"CD1B4F52E04B14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288744,"discussion_content":"在理，我们系统中，起的很多分布式事务，就是这种方式，上游调用的，会统一使用上游生成的事务id，只有是自己起的，才新生成事务id，跟这个类似","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593857784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":271484,"ip_address":""},"score":288744,"extra":""}]},{"author":{"id":1125104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","nickname":"Citizen Z","note":"","ucode":"9CA547640A8629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":130129,"discussion_content":"可以这样理解，重试和幂等设计属于“程序控制”范畴的行为，而 ID 属于“业务逻辑”范畴，对于“控制”程序来说，程序（后端服务）只关心你是不是进行了非法操作（重复执行了具有副作用的接口），所以不论你的控制程序用什么唯一标识（不管是前端生成的 token 还是先前生成的业务 ID 还是直接把提交内容散列计算了一下），都可以被“控制”程序用来进行判重的依据。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578751700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446418,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zdK3dSkFwicZHtx5CLAKFJRORRibq2YqvHOP0tySLxVx0X1oD9AJanan2wia2hHaswgxdrCzEEGyVgFTVZ8sElTzQ/132","nickname":"Geek_fbfc4f","note":"","ucode":"7010B242A3F474","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371641,"discussion_content":"调用时应该有重试的，都是用同一参数值发送请求的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619881387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102831,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d3/ef/9c5e695b.jpg","nickname":"oops","note":"","ucode":"1DEC23A503F8A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294451,"discussion_content":"提前生成好，跟业务唯一标示一一对应，并且落表","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595897403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272996,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6c/a4/7f7c1955.jpg","nickname":"死磕郎一世","note":"","ucode":"86C1197C3FB2A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549051,"discussion_content":"我的理解是这样的，上游系统如果是重试，不应该重新拿id，就用原来的请求再发一次，所有内容都不应该改变，否则是一个新的请求了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643531715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052994,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/226NabDEu1IGMN7Om1gQqG22hk2dZKojpB0KDpAK0vtujQLdlgZsVaPbIc4ymcib0NdH3Syh8YibRuL7Lv5kVCkg/132","nickname":"果子","note":"","ucode":"D7B288A3E722F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407955,"discussion_content":"虽然时间很久了我也来讨论下。读操作本身是幂等的，因为它不会改变系统状态。更新操作大部分是不幂等的，为了实现幂等，也就是让重复操作只生效一次，本质上就是防重，要防重就得唯一标识每次操作，唯一标识最自然的办法就是每个操作或者请求绑定一个ID，这个ID可以有业务含义，也可以没有业务含义，只要能起到唯一标识的作用就行。比如创建订单，订单ID本身就可以起到防重的作用，用它实现幂等自然也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635156654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1093541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/af/a5/afa1d7d7.jpg","nickname":"hasWhere","note":"","ucode":"2C2B2988107489","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165656,"discussion_content":"有道理，不过用业务id感觉也不太合适，比如一笔订单第一次支付失败，再次支付","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581310906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1656848,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fy2rpUzbSEeIAQHfbt0EkYkMIIuEPhWO6GFkjJNmLy5gbRp2UnNlrLh1fAAU52bQKfiahl17ZTOjhbYiatmrNibDg/132","nickname":"杨小曹","note":"","ucode":"D266D0A11BC573","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1093541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/af/a5/afa1d7d7.jpg","nickname":"hasWhere","note":"","ucode":"2C2B2988107489","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314359,"discussion_content":"同样疑惑，如果第一次支付因为余额不足失败了，充钱之后，再次以同样业务Id发起支付，这时候下游系统会重新尝试支付还是直接返回上次失败了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603153325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165656,"ip_address":""},"score":314359,"extra":""},{"author":{"id":1238185,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/a9/117fe480.jpg","nickname":"我的心里只有工作","note":"","ucode":"488DD6F9590EB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1656848,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fy2rpUzbSEeIAQHfbt0EkYkMIIuEPhWO6GFkjJNmLy5gbRp2UnNlrLh1fAAU52bQKfiahl17ZTOjhbYiatmrNibDg/132","nickname":"杨小曹","note":"","ucode":"D266D0A11BC573","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314797,"discussion_content":"肯定有支付流水号的吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603197469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":314359,"ip_address":""},"score":314797,"extra":""},{"author":{"id":1716794,"avatar":"","nickname":"_菜小菜","note":"","ucode":"E5641B5EE95521","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1656848,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fy2rpUzbSEeIAQHfbt0EkYkMIIuEPhWO6GFkjJNmLy5gbRp2UnNlrLh1fAAU52bQKfiahl17ZTOjhbYiatmrNibDg/132","nickname":"杨小曹","note":"","ucode":"D266D0A11BC573","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321723,"discussion_content":"第一次如果已经失败这是完成一次通讯了吧，而且有失败状态了。第二次发起应该算新的了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604626699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":314359,"ip_address":""},"score":321723,"extra":""}]},{"author":{"id":1462449,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLfrbMvhKQYhxP6ziaHaj4KUNRzst8u7BZsWUsazK8oTLXcNH6sDGITl6icy3IiaGFe9Iiae12LuTrF1g/132","nickname":"天下行走","note":"","ucode":"73A4CD8BB91235","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12792,"discussion_content":"同没理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568596474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122,"discussion_content":"是的，我也是这个疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561121844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":5582,"user_name":"刘波3S","can_delete":false,"product_type":"c1","uid":1063313,"ip_address":"","ucode":"94C3F11ECC92BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/91/16122ee6.jpg","comment_is_top":false,"comment_ctime":1523576547,"is_pvip":false,"replies":[{"id":"1626","content":"谢谢","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1524105302,"ip_address":"","comment_id":5582,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27293380323","product_id":100002201,"comment_content":"这篇文章ID生成的讲解，解开了我一个长久的疑问，就这一段，付费199我也是愿意的。","like_count":6,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":416780,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1524105302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246178,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/e2/5768d26e.jpg","nickname":"inrtyx","note":"","ucode":"81CD18FF34ABAB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543518,"discussion_content":"什么疑问？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641192739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":4314,"user_name":"酱了个油","can_delete":false,"product_type":"c1","uid":1059627,"ip_address":"","ucode":"5A13CA4EAACB81","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/2b/bebf6eed.jpg","comment_is_top":false,"comment_ctime":1521989366,"is_pvip":false,"replies":[{"id":"1117","content":"你什么集群？1024个不够？如果实在不够加几个bit给机器id吧","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1522160506,"ip_address":"","comment_id":4314,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27291793142","product_id":100002201,"comment_content":"皓哥，由客户端如何生存唯一id呀，感觉twitter的算法适合服务器，有1024个服务器限制，可以给点提示吗","like_count":6,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":416295,"discussion_content":"你什么集群？1024个不够？如果实在不够加几个bit给机器id吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1522160506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102608,"discussion_content":"可以参考美团的leaf分布式唯一ID","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577356761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272996,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6c/a4/7f7c1955.jpg","nickname":"死磕郎一世","note":"","ucode":"86C1197C3FB2A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549048,"discussion_content":"我也有同样疑问，这里的客户端应该不是指浏览器或手机app吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643531255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3884,"user_name":"MC","can_delete":false,"product_type":"c1","uid":1004183,"ip_address":"","ucode":"AA0035C9C43516","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/97/4593cda8.jpg","comment_is_top":false,"comment_ctime":1520910418,"is_pvip":false,"replies":[{"id":"951","content":"有可能是我用错了。我的“上游”偏请求方，“下游”偏响应方。","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1521703366,"ip_address":"","comment_id":3884,"utype":1}],"discussion_count":8,"race_medal":0,"score":"27290714194","product_id":100002201,"comment_content":"问题：上游（upstream）和下游（downstream）两个词是不是用反了？如果不是，这两个术语的在这篇文章上下文中的具体意思是什么？","like_count":6,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":416094,"discussion_content":"有可能是我用错了。我的“上游”偏请求方，“下游”偏响应方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1521703366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052994,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/226NabDEu1IGMN7Om1gQqG22hk2dZKojpB0KDpAK0vtujQLdlgZsVaPbIc4ymcib0NdH3Syh8YibRuL7Lv5kVCkg/132","nickname":"果子","note":"","ucode":"D7B288A3E722F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407957,"discussion_content":"从流动的方向来看，上游靠近起点，下游靠近终点。从依赖关系来看，下游依赖上游。从功能形态来看，上游是服务提供者，下游是服务消费者。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635157216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","nickname":"Citizen Z","note":"","ucode":"9CA547640A8629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":130133,"discussion_content":"我也隐约有这种感觉，上游通常指的是被依赖方啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578751790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591892,"discussion_content":"这完全看你的视角。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666920372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1587802,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3a/5a/d779f336.jpg","nickname":"cwj","note":"","ucode":"58FE235BC3A540","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530634,"discussion_content":"不同场景的上下游不一样的，评论中，果子说的是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637114206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446418,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zdK3dSkFwicZHtx5CLAKFJRORRibq2YqvHOP0tySLxVx0X1oD9AJanan2wia2hHaswgxdrCzEEGyVgFTVZ8sElTzQ/132","nickname":"Geek_fbfc4f","note":"","ucode":"7010B242A3F474","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371640,"discussion_content":"下游请求方，下游响应方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619881204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2791739,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/99/3b/acbc0986.jpg","nickname":"记忆不寒凉","note":"","ucode":"AC1D0AA0740803","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2446418,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zdK3dSkFwicZHtx5CLAKFJRORRibq2YqvHOP0tySLxVx0X1oD9AJanan2wia2hHaswgxdrCzEEGyVgFTVZ8sElTzQ/132","nickname":"Geek_fbfc4f","note":"","ucode":"7010B242A3F474","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400983,"discussion_content":"你搁这搁这呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633511329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371640,"ip_address":""},"score":400983,"extra":""}]},{"author":{"id":1402127,"avatar":"https://static001.geekbang.org/account/avatar/00/15/65/0f/770eba2d.jpg","nickname":"Kay","note":"","ucode":"A5A6E3655FEC2D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338842,"discussion_content":"我也感觉上游应该是响应方，下游应该是请求方","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609399721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3649,"user_name":"Sam_Deep_Thinking","can_delete":false,"product_type":"c1","uid":1001152,"ip_address":"","ucode":"8E4EF6F24B821B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/c0/bf880bda.jpg","comment_is_top":false,"comment_ctime":1520223230,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27290027006","product_id":100002201,"comment_content":"皓哥，这个专题能顺便说下分布式锁吗？我最近刚用db实现一个分布式锁。感觉不太满意。能否大概介绍一下这个主题？","like_count":7},{"had_liked":false,"id":6547,"user_name":"邓呵呵","can_delete":false,"product_type":"c1","uid":1104040,"ip_address":"","ucode":"ACE06D60E04642","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/a8/ac0bd149.jpg","comment_is_top":false,"comment_ctime":1524819597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"22999656077","product_id":100002201,"comment_content":"以前对重复提交总觉得应该放前端实现，原来后端处理就是幂等性，受教了","like_count":6},{"had_liked":false,"id":166108,"user_name":"Sdylan","can_delete":false,"product_type":"c1","uid":1008503,"ip_address":"","ucode":"4589D0D0FA9275","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/77/423345ab.jpg","comment_is_top":false,"comment_ctime":1577405932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14462307820","product_id":100002201,"comment_content":"## 什么是幂等性<br>一次和多次请求某一个资源应该具有同样的副作用（对资源变更带来连锁反应或影响）：f(x)  = f(f(x))。<br><br>## 为什么要幂等性设计<br>系统解耦后，系统间服务调用存在三种状态：<br>\t* 成功<br>\t* 失败<br>\t* 超时（中间状态）<br>前面两种是明确的，超时是不知道什么状态，一般引起原因:<br>\t* 请求没有到达服务方（网络延时或丢失）<br>\t* 请求达到了服务方，服务方处理超时<br>\t* 请求到达了服务方并且处理完返回结果，但接收方没有收到<br>相关例子：订单创建、库存扣减、订单支付<br>## 怎么做幂等性设计<br>* 下游提供查询接口，上游对于状态疑异订单进行查询<br>* 下游系统坐幂等性设计：确保不会重复<br>\t* 全局ID：Twitter的Snowflake算法&#47;UUID<br>\t* 存储冲突来解决（唯一约束）<br>\t\t* 插入重复无效，`insert into … values … on DUPLICATE KEY UPDATE …`<br>\t\t* 更新状态：`update table set status = “paid” where id = xxx and status = “unpaid”;`<br>- HTTP幂等性<br>\t- 只有POST需要特殊处理，其他都具有幂等性：<br>\t\t- 前端生成token，后端存（唯一约束）<br>\t\t- PRG模式","like_count":3},{"had_liked":false,"id":8480,"user_name":"一黑到底","can_delete":false,"product_type":"c1","uid":1046195,"ip_address":"","ucode":"229EC6311458DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/b3/a4f2e4ec.jpg","comment_is_top":false,"comment_ctime":1526259433,"is_pvip":false,"replies":[{"id":"2513","content":"重试的时候不用重新获取新的id，用上次的就好了。","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1526274669,"ip_address":"","comment_id":8480,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14411161321","product_id":100002201,"comment_content":"请问一下，第一次请求因超时失败了，然后再次请求，怎么做到全局id是一样的？因为两次请求的时间点变化了。","like_count":3,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417742,"discussion_content":"重试的时候不用重新获取新的id，用上次的就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526274669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/fd/6b0e58fe.jpg","nickname":"文刂 氵共 超","note":"","ucode":"C2CE1512D23012","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96791,"discussion_content":"你可以理解为：上游发送请求时，获取了全局 ID，重复发送时 全局 ID 是一样的；只有当请求的内容改变时，才重新获取全局 ID ，此时 下游收到的全局 ID 才不一样","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577093022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063945,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7e/49/2efce374.jpg","nickname":"开到荼蘼","note":"","ucode":"EB5C016D0AA830","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585281,"discussion_content":"怎么判断是使用上次的还是重新获取id呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661439252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199656,"user_name":"PCMD","can_delete":false,"product_type":"c1","uid":1842844,"ip_address":"","ucode":"76A1106F42AEAC","user_header":"https://static001.geekbang.org/account/avatar/00/1c/1e/9c/39f5ff2a.jpg","comment_is_top":false,"comment_ctime":1585493314,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10175427906","product_id":100002201,"comment_content":"服务中采取的幂等操作，在于库存的交互处理中，由业务的id 加 uuid来实现，在唯一的基础上，在带一定的反解性，并通过订阅消息，和接口反查，来做一次反向ack机制，确保无资源占用处理","like_count":2},{"had_liked":false,"id":81854,"user_name":"灯火可亲","can_delete":false,"product_type":"c1","uid":1241170,"ip_address":"","ucode":"BBC0FBD8BD4FA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/52/2afffb1f.jpg","comment_is_top":false,"comment_ctime":1554056902,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10143991494","product_id":100002201,"comment_content":"请问全局ID生成策略是什么了 怎么让下游系统判断发过来的请求是同一个请求了","like_count":2,"discussions":[{"author":{"id":1282813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/fd/6b0e58fe.jpg","nickname":"文刂 氵共 超","note":"","ucode":"C2CE1512D23012","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96787,"discussion_content":"你可以理解为：上游发送请求时，获取了全局 ID，重复发送时 全局 ID 是一样的；只有当请求的内容改变时，才重新获取全局 ID ，此时 下游收到的全局 ID 才不一样","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577092918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251835,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oiboHpgukqib2ASXeU0H7W1ibgRMqyrNE5KaWicicPEDy0ia8YdoneZAtvW0EFIiaqZJp2OS4dnweOgXaJ5EjJicicEqic5A/132","nickname":"覃钰栋","note":"","ucode":"19080C463658EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354975,"discussion_content":"上游生成一个唯一ID保存在redis缓存，下游请求前先来获取。发送请求时带过来，校验是否存在，存在则删除，处理业务。不存在则说明重复.\nhttps://www.jianshu.com/p/9ece87b38477","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615370841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13373,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1529563667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10119498259","product_id":100002201,"comment_content":"说到全局id的必要性，感触很深，比如皓哥在本文章里说到的幂等性；比如有了全局id，就能很便利的监控数据流向；再比如有了全局id，查看数据日志和排错会很方便，没有的话排错就很难。<br><br>在实际业务中，遇到了很多客户端重复提交的问题，造成的问题其实也很大。举一个很极端的例子，在一个项目中我们的系统替换另一个厂商的系统，新旧两个系统同时在线，有服务不断从旧系统搬数据到新系统。有一天系统性能下降比较严重，新系统变慢，用户就做了一件事情，把同一批数据，同时上传到了新系统和旧系统中，然后新系统提交的时候，产生了很多数据库提交主键冲突的问题，最终导致了丢失了一些数据，搞了一个通宵才完全恢复。然后才有精力开始排查性能下降的问题。<br><br>现在回头看一下，虽然问题比较极端，很多环节上出现了不该出现的操作，但当时我们的设计从来没有考虑去应对过这种极端情况，问题真的很大。","like_count":2},{"had_liked":false,"id":8005,"user_name":"起司猫","can_delete":false,"product_type":"c1","uid":1018670,"ip_address":"","ucode":"D86EF6FBA10EAC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/2e/df74d56a.jpg","comment_is_top":false,"comment_ctime":1525843261,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10115777853","product_id":100002201,"comment_content":"我们现在的系统设计的时候都没考虑到这些😂比如做幂等性接口的时候，下游每次收到订单都先查询一次，的确有点慢了。果然需要学习的地方还有很多呀。付费学习是值得的。","like_count":2,"discussions":[{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123,"discussion_content":"高并发场景下 先查询 没有办法保证幂等性， 查询时候 状态可能就变了 可能造成重复插入 无法保证幂等性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561122005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1656848,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fy2rpUzbSEeIAQHfbt0EkYkMIIuEPhWO6GFkjJNmLy5gbRp2UnNlrLh1fAAU52bQKfiahl17ZTOjhbYiatmrNibDg/132","nickname":"杨小曹","note":"","ucode":"D266D0A11BC573","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306180,"discussion_content":"对同一笔业务，比如创建id=123的订单，还会高并发吗？不就防止前端重复调用最多就几次？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600213998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":123,"ip_address":""},"score":306180,"extra":""}]}]},{"had_liked":false,"id":3611,"user_name":"fishcat","can_delete":false,"product_type":"c1","uid":1055761,"ip_address":"","ucode":"44D3EB54C0D4BD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/11/86d1f82d.jpg","comment_is_top":false,"comment_ctime":1520070973,"is_pvip":false,"replies":[{"id":"758","content":"所谓副作用，就是对这个资源<br>的变更所带来的连锁反应和影响。","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1520471577,"ip_address":"","comment_id":3611,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10110005565","product_id":100002201,"comment_content":"一次和多次请求某一个资源应该具有同样的副作用<br>这里说的副作用是什么意思？","like_count":3,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415967,"discussion_content":"所谓副作用，就是对这个资源\n的变更所带来的连锁反应和影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1520471577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212186,"user_name":"SourciantC","can_delete":false,"product_type":"c1","uid":1234754,"ip_address":"","ucode":"79C4C9366B455A","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/42/ccd94ba6.jpg","comment_is_top":false,"comment_ctime":1588072604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883039900","product_id":100002201,"comment_content":"在很多时候，初始设计系统的时候并没有考虑幂等性，这就导致网络卡顿的时候，用户插入数据会无响应或者插入错误，引以为戒","like_count":1},{"had_liked":false,"id":168185,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1578030263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872997559","product_id":100002201,"comment_content":"实现幂等性的两种方式:1 服务提供方提供查询接口供调用方使用，2使用全局性唯一ID检验来实现幂等性。页面防止重复提交使用token其实就是方式二。我们在消费消息时，是用组合业务属性唯一来实现幂等的。","like_count":1},{"had_liked":false,"id":164986,"user_name":"天问","can_delete":false,"product_type":"c1","uid":1018250,"ip_address":"","ucode":"15BCF0359340E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/8a/7e6bd87a.jpg","comment_is_top":false,"comment_ctime":1577128873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872096169","product_id":100002201,"comment_content":"请问皓叔，处理流程-“要做到这个事，我们需要一个存储来记录收到的交易。”这个存储，指的是一个独立于业务存储的存储服务吗？是不是还得保证业务存储与幂等服务的存储事务一致性？","like_count":1},{"had_liked":false,"id":164797,"user_name":"文刂 氵共 超","can_delete":false,"product_type":"c1","uid":1282813,"ip_address":"","ucode":"C2CE1512D23012","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/fd/6b0e58fe.jpg","comment_is_top":false,"comment_ctime":1577092733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872060029","product_id":100002201,"comment_content":"学习笔记 https:&#47;&#47;mubu.com&#47;colla&#47;Nj0F5l5PUM","like_count":1},{"had_liked":false,"id":35665,"user_name":"陈杨","can_delete":false,"product_type":"c1","uid":1099732,"ip_address":"","ucode":"DF68F55DA7D068","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/d4/c83c200e.jpg","comment_is_top":false,"comment_ctime":1540734446,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5835701742","product_id":100002201,"comment_content":"皓哥，在保存的地方，假设db保存，一个表可以使用数据库唯一索引来报错，但是在分库分表后，数据库唯一索引就不能工作了，只有把同一个这样的请求路由到同一个库，才可以，但是这样可能跟分库分表的依据冲突，这样情况下怎么让他报错？","like_count":1,"discussions":[{"author":{"id":1103602,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d6/f2/0601a60e.jpg","nickname":"顾海","note":"","ucode":"13F4E0A21975CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":247802,"discussion_content":"接口需要幂等一般是由于被调用的接口超时，调用放发起重视，在这种情况下不存在你说的两个问题\n1.可以不用唯一索引，只需要在接口进来是去查询是否存在就可以\n2.这个问题本身和分库分表没关系。如果分库分表，你每次的路由策略是一样的，服务同一个id，每次都是路由到同一个库或表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587825278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11401,"user_name":"Winter","can_delete":false,"product_type":"c1","uid":1148147,"ip_address":"","ucode":"C1ED53D3DE71D0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eruToIjINciaLuUIHxmlibHwC9v3MUibPKxAt9c6c6OdEZGMbmApKxfP3kZ2WRLHW3iciaxIKPWc99YERw/132","comment_is_top":false,"comment_ctime":1528115405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5823082701","product_id":100002201,"comment_content":"皓哥请教一下，对于创建 (create) 一类的动作 ，如果server侧发现资源已经存在，在幂等 性的设计里，是返回异常，还是正常返回已创 建资源的信息通常有特殊考虑么。有个例子是 上游已知订单号，要给订单创建一个关联的支 付交易(transaction)，交易可过期，可被替换。这种场景感觉总是返回当前可用的transaction信息对上游比较方便一点，不管这个transaction是本次请求创建的，还是之前已存在的未过期的。<br>","like_count":1},{"had_liked":false,"id":3693,"user_name":"YY","can_delete":false,"product_type":"c1","uid":1061856,"ip_address":"","ucode":"15A5AAB83A2A65","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/e0/ddf997d9.jpg","comment_is_top":false,"comment_ctime":1520314818,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5815282114","product_id":100002201,"comment_content":"重复交易过来后，返回上次交易信息，这个上次交易信息是不是需要存储起来，这个返回信息怎样存储比较好，是否有必要把所有的返回信息都存储起来","like_count":1,"discussions":[{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124,"discussion_content":"同问，大数据结果集怎么存得下，网络传输效率会高？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561122120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3647,"user_name":"北极点","can_delete":false,"product_type":"c1","uid":1042842,"ip_address":"","ucode":"476820AE0AAA6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/9a/1d9e1d9a.jpg","comment_is_top":false,"comment_ctime":1520218234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5815185530","product_id":100002201,"comment_content":"HTTP的幂等设计讲的非常清楚，我之前一直分不清put 和 post方法的区别！在项目中一直就没用put方法！","like_count":1},{"had_liked":false,"id":3578,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1519945085,"is_pvip":true,"replies":[{"id":"695","content":"你问的是哪句话的“副作用”？","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1519958813,"ip_address":"","comment_id":3578,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5814912381","product_id":100002201,"comment_content":"你这里说的副作用是指什么？","like_count":1,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415950,"discussion_content":"你问的是哪句话的“副作用”？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1519958813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","nickname":"Citizen Z","note":"","ucode":"9CA547640A8629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":130139,"discussion_content":"副作用可以理解为对于上下文中共享数据的变更，不过 HTTP 这里，我之前接触的资料中叫做“安全性”，副作用就是不安全操作，和耗叔稳重的“副作用”应该是同义词，而且从定义来看也差不多，可能语境不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578752015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3541,"user_name":"特约嘉宾","can_delete":false,"product_type":"c1","uid":1043804,"ip_address":"","ucode":"C57E47907C4D46","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/5c/2c8b4e18.jpg","comment_is_top":false,"comment_ctime":1519865053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5814832349","product_id":100002201,"comment_content":"受教了，🙏","like_count":1},{"had_liked":false,"id":346543,"user_name":"tiny🌾","can_delete":false,"product_type":"c1","uid":1119851,"ip_address":"","ucode":"7A4DE00381D1F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/6b/af7c7745.jpg","comment_is_top":false,"comment_ctime":1653222011,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653222011","product_id":100002201,"comment_content":"想问一下：这里雪花算法是做成sdk放到服务里调用，还是单独做成一个ID生成服务比较好了？","like_count":0},{"had_liked":false,"id":341140,"user_name":"Hikari","can_delete":false,"product_type":"c1","uid":1602695,"ip_address":"","ucode":"109A63F6B3E01F","user_header":"https://static001.geekbang.org/account/avatar/00/18/74/87/ee6ec225.jpg","comment_is_top":false,"comment_ctime":1649387401,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649387401","product_id":100002201,"comment_content":"【比如，数据库中你可以使用 insert into … values … on DUPLICATE KEY UPDATE …  这样的操作。】文中这个说法不太理解，这里应该是要如果全局存在需要插入报异常的，如果用这个方式存在会执行update那怎么区分是不是全局id已存在","like_count":0},{"had_liked":false,"id":332737,"user_name":"死磕郎一世","can_delete":false,"product_type":"c1","uid":1272996,"ip_address":"","ucode":"86C1197C3FB2A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/6c/a4/7f7c1955.jpg","comment_is_top":false,"comment_ctime":1643531456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643531456","product_id":100002201,"comment_content":"浩哥，网上很多人说用分布式锁解决幂等性，我看了半天就是想不明白，请指点一下，分布式锁到底能不能解决幂等性问题","like_count":0},{"had_liked":false,"id":318216,"user_name":"方勇(gopher)","can_delete":false,"product_type":"c1","uid":1290625,"ip_address":"","ucode":"D199911C4CFEF5","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/81/13f23d1e.jpg","comment_is_top":false,"comment_ctime":1635209453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635209453","product_id":100002201,"comment_content":"我们在消息中间件消费侧实现了幂等，但rpc请求未在框架里集成幂等！幂等采用共享锁基于redis实现！","like_count":0},{"had_liked":false,"id":261900,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1605574283,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1605574283","product_id":100002201,"comment_content":"前端生成token也有个问题，如果截取api接口，通过模拟发送相同的数据但token不同，那么是不是不能防止幂等性","like_count":0,"discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387173,"discussion_content":"这就是两笔业务，比如你先买了一瓶水，结完账后觉得不够，又买了一瓶水","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628038422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255064,"user_name":"FollowFlow","can_delete":false,"product_type":"c1","uid":1001212,"ip_address":"","ucode":"267D684C54AF42","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/fc/cd337487.jpg","comment_is_top":false,"comment_ctime":1603261742,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603261742","product_id":100002201,"comment_content":"请教两个问题<br>1. 对于 HTTP method 的幂等性，在实际项目中，PUT 和 POST 接口都应该设计为具有幂等性的接口 是么？<br>2. 在实际的分布式项目中，因为存在三态，是不是所有服务 (Service) 的所有的接口都应该设计为具有幂等性？","like_count":0,"discussions":[{"author":{"id":1103091,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","nickname":"李二木","note":"","ucode":"30E03BB84ADB27","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326276,"discussion_content":"不是的，get请求是幂等。一般都是新增、更新、删除之内操作。对于核心数据操作可以增加幂等验证。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605574726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230969,"user_name":"borefo","can_delete":false,"product_type":"c1","uid":1111352,"ip_address":"","ucode":"67A3F20D1AAAFE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUFIOBnowQQbDZSr7ZcPrbnN6vmD3T0UZ4YrYmgljwlx5OTfqh9BibEqSvba0cuMzicjkkaHadeysQ/132","comment_is_top":false,"comment_ctime":1593535111,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1593535111","product_id":100002201,"comment_content":"我们收到交易请求后，直接去存储里记录这个 ID（相对于数据的 Insert 操作），如果出现 ID 冲突了的异常，那么我们就知道这个之前已经有人发过来了，所以就不用再做了。<br>===============<br>这样做有个问题，假如储存id成功的那个处理流程处理交易失败，那么，这笔交易再也无法处理。","like_count":0,"discussions":[{"author":{"id":1015768,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/d8/35500774.jpg","nickname":"Ray","note":"","ucode":"BC72E2D6FE82F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290448,"discussion_content":"失败了更应该根据出错原因重新发起","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594473570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1111352,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUFIOBnowQQbDZSr7ZcPrbnN6vmD3T0UZ4YrYmgljwlx5OTfqh9BibEqSvba0cuMzicjkkaHadeysQ/132","nickname":"borefo","note":"","ucode":"67A3F20D1AAAFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015768,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/d8/35500774.jpg","nickname":"Ray","note":"","ucode":"BC72E2D6FE82F1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291743,"discussion_content":"即使重新发起请求，因为id被记录了，流程是不会再做一次的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594944108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290448,"ip_address":""},"score":291743,"extra":""}]}]},{"had_liked":false,"id":226389,"user_name":"迷途书童","can_delete":false,"product_type":"c1","uid":1090142,"ip_address":"","ucode":"462BE64D3373DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/a2/5e/3871ff79.jpg","comment_is_top":false,"comment_ctime":1592059685,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1592059685","product_id":100002201,"comment_content":"幂等性是一个正确性问题，个人感觉不应该放在弹性设计这个Topic下面","like_count":0,"discussions":[{"author":{"id":2016408,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","nickname":"罗杰.菲の樂","note":"","ucode":"63590706846EEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290727,"discussion_content":"这个是 resilience 的基石吧，如果 idempotent 实现不了，各种retry pattern就无从谈起了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594585417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223062,"user_name":"几度嘟嘟","can_delete":false,"product_type":"c1","uid":1524256,"ip_address":"","ucode":"54DEE1C7252D09","user_header":"https://static001.geekbang.org/account/avatar/00/17/42/20/d195a6db.jpg","comment_is_top":false,"comment_ctime":1590992355,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1590992355","product_id":100002201,"comment_content":"        阅读本文后最大的收获是了解了HTTP的幂等性，于是在设计接收方服务接口时，重要是要保证POST请求执行后的幂等性，同时收获了新的网页开发设计模式——PRG模式。<br>        比较不解的是文章中“处理流程”部分，这里是建议对收到的交易使用关系型数据库存储吗？“因为绝大多数请求应该都不会是重新发过来的，所以让 100% 的请求都到这个存储里去查一下，这会导致处理流程变得很慢。”和“所以，最好是当这个存储出现冲突的时候会报错。也就是说，我们收到交易请求后，直接去存储里记录这个 ID……”这两个方式有什么不同呢，我感觉读起都在做的是同样的操作？想请读懂的大牛们，帮忙解释一下~","like_count":0,"discussions":[{"author":{"id":1015768,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/d8/35500774.jpg","nickname":"Ray","note":"","ucode":"BC72E2D6FE82F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290449,"discussion_content":"意思是减少了一个操作？先查询+插入 对比 直接插入","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594473735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211375,"user_name":"刘清斌","can_delete":false,"product_type":"c1","uid":1123103,"ip_address":"","ucode":"775B053AF87B53","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/1f/6452b2e8.jpg","comment_is_top":false,"comment_ctime":1587954454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587954454","product_id":100002201,"comment_content":"学习记录：<br>幂等性设计：一次和多次请求某一个资源应该具有同样的副作用。（或者说，一次和多次请求的响应结果是一样的）<br><br>实现幂等性的交易接口，需要一个全局唯一的ID进行标识。<br><br>处理流程则根据交易ID进行判断操作。<br><br>HTTP的幂等性：<br><br>- GET方法<br>- HEAD方法<br>- OPTIONS方法<br>- DELETE方法<br>- PUT方法：更新操作","like_count":0},{"had_liked":false,"id":210810,"user_name":"顾海","can_delete":false,"product_type":"c1","uid":1103602,"ip_address":"","ucode":"13F4E0A21975CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/f2/0601a60e.jpg","comment_is_top":false,"comment_ctime":1587828013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587828013","product_id":100002201,"comment_content":"1..同一个请求被重复调用一般发生在接口调用超时的情况下。<br>2所谓幂等指的是调用一次和多次对被调用方的影响是一样的，并不是指调用方每次都能得到同样的响应。<br>3.类似于http PUT的场景可以使用分布式锁，防止对于同一个资源的并发修改，这也是幂等的一种手段。","like_count":0},{"had_liked":false,"id":176058,"user_name":"1994","can_delete":false,"product_type":"c1","uid":1274865,"ip_address":"","ucode":"78EFAE2781A5CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/f1/fc6019f9.jpg","comment_is_top":false,"comment_ctime":1580925518,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580925518","product_id":100002201,"comment_content":"如果这个接口是提供给前端或者是第三方使用的，是不是就要提供一个获取全局ID的接口出来？","like_count":0,"discussions":[{"author":{"id":1103602,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d6/f2/0601a60e.jpg","nickname":"顾海","note":"","ucode":"13F4E0A21975CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":247821,"discussion_content":"视场景。1可以使用业务id，比如前端对一个订单进行操作，就使用订单id。2使用流水号。比如支付的场景，我们调用微信的支付接口时，首先调用的是预支付，他会给我们返回一个唯一的流水号，我们需要把这个流水号存起来。微信那边支付成功时，回调我们的接口，会传入支付流水号。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587825742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174340,"user_name":"slark","can_delete":false,"product_type":"c1","uid":1143574,"ip_address":"","ucode":"7E8DE962AA23A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/73/16/595b0342.jpg","comment_is_top":false,"comment_ctime":1580171549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580171549","product_id":100002201,"comment_content":"冥等性，从字面意思很好理解，在前面也有类似概念。函数是无副作用，函数是无状态的，请求都依赖外部参数。<br>从这个角度放大到业务请求，就是一个请求是无副作用或者多次调用副作用一致。<br>请求可以有成功，失败，超时三种。<br>POST请求通常无法保持冥等。<br>要确保请求的冥等，需要通过一些手段来记录，追踪请求。通过一个全局的ID是比较合理的。该ID可通过算法生成，可以在不同阶段生成，但要全局唯一且足够高效，用中间的生成器不合理。<br>可以采用分布式的long类型生成算法，以时间，机器号，进程号，生成编号等方式生成。<br>最后，要保障存储id系统是可靠的，避免后续追踪查询问题","like_count":0},{"had_liked":false,"id":169481,"user_name":"Geek_Heiko","can_delete":false,"product_type":"c1","uid":1469881,"ip_address":"","ucode":"54B0D22008F7EC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/VfE7OiboMc7SKwOiczAJDWo3T4WJn0dVW8yPEpVRUFtk6ib0DUicN1eDfpel1UAgp8ia4kqEjXSVXOVHcoZKXhq7k4w/132","comment_is_top":false,"comment_ctime":1578362757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578362757","product_id":100002201,"comment_content":"&quot;幂等性设计&quot;产生的大背景是: 服务请求方相对于被请求方的等待超(不明确请求结果)而多次发送同一个请求，从而导致返回多个不同的处理结果，而实际的多个请求只为返回一个明确处理结果的情况。由此，我们导出幂等设计的含义是，使得服务被调用方对于多个相同的请求能够返回一个相同的处理结果。但本文中很巧妙地使用：”副作用“这个词汇，即文中的含义是：&quot;一个服务被多次调用和第一次调用所产生的副作用是一样的&quot;。这里，我个人的理解是，幂等设计原本就是针对于不正常的服务调用(等待超时)的一种预防手段，一般正常情况下，这种&quot;手段&quot;是要带来一定的&quot;副作用&quot;的，如，为了判定多次请求的是同一个目的，我们得在系统中额外添加一个能够产生全局唯一 id 的功能，每个相同的请求都得附上该 id，然后，服务被调用方的服务相应每次都得获得该 id，根据处理情况对应地进行结果返回或丢弃等，为了防止每次服务被调用都需要查询该 id 的操作，文中推荐使用的存储冲突报错的机制，及通过多次存储同一个 id 报错的方式实现服务的高效幂等性设计。<br>以上，可以推出幂等性设计的关键技术要点是：生成全局唯一 id 及其存储(读写)。这里的若是分布式系统中服务，由于其要求系统中的服务要设计成&quot;无状态&quot;的，所以，其幂等设计也得是&quot;分布式&quot;的。关于全局 id 的生成，这里推荐使用的是Twitter 的开源项目 Snowflake，其设计初衷就是面向分布式的唯一 id 生成算法;关于全局 id 的存储，这里给出的参考方案是采用关系性数据库或key-value的 NoSQL(MongoDB)。","like_count":0},{"had_liked":false,"id":168179,"user_name":"shengjk1","can_delete":false,"product_type":"c1","uid":1104955,"ip_address":"","ucode":"63EDA4404B9F83","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/3b/ce892c68.jpg","comment_is_top":false,"comment_ctime":1578027922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578027922","product_id":100002201,"comment_content":"很棒","like_count":0},{"had_liked":false,"id":159596,"user_name":"前面等你","can_delete":false,"product_type":"c1","uid":1100678,"ip_address":"","ucode":"B52C308C6A7CF9","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/86/41d8d8f2.jpg","comment_is_top":false,"comment_ctime":1575701092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575701092","product_id":100002201,"comment_content":"在超时处理上，第一种方式是使用查询，会有问题；假如你的请求已经成功被对方接收，只是对方还没来得及处理或正在处理中或处理失败对方补偿中，这时你查询得到状态和调用前是一样的，重试一次对方系统可能就会产生副作用，所以还是要用第二种让对方支持幂等安全点<br><br>原文：一种是需要下游系统提供相应的查询接口。上游系统在 timeout 后去查询一下。如果查到了，就表明已经做了，成功了就不用做了，失败了就走失败流程。","like_count":0},{"had_liked":false,"id":129699,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1567222494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567222494","product_id":100002201,"comment_content":"1、HTTP请求端：用户提交表单时，生成唯一标识作为改次提交的表单id，然后后台保存该唯一标识到数据库。<br>2、消费MQ的幂等性：通过数据的insert..on duplicate或着update set status where status = xxx<br>3、采用分布式锁，对同一用户操作进行限制，比如同一时间不能同时调用下单接口。（但是这里有可能会导致前一个任务未处理完，redis已失效的问题）","like_count":0},{"had_liked":false,"id":110137,"user_name":"edisonhuang","can_delete":false,"product_type":"c1","uid":1530167,"ip_address":"","ucode":"BB2F639A779F96","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg","comment_is_top":false,"comment_ctime":1562200461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562200461","product_id":100002201,"comment_content":"分布式服务的设计应该满足幂等性，幂等性的含义是，一个调用被发送多次所产生的副作用和被发送一次所产生的副作用是一样的。<br>由于每次服务的调用有三种状态，成功失败或是超时，幂等性是要解决超时的问题，当某处调用超时，如何保证重复调用而逻辑不会出错","like_count":0},{"had_liked":false,"id":105987,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1561121440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561121440","product_id":100002201,"comment_content":"有几个问题想请教下：<br>1、幂等性中的 【副作用】 是否 可以理解成对 资源or数据状态的改变？<br>2、Snowflake 生成的全局id 放到被调用端生成 每次请求都会生成一个唯一的di, 但是 这东西没有业务含义 怎么能判断 调用端 的每次请求是否是唯一的？ 需要再定义一个全局的 业务key?<br> 3、全局ID 中 分布式存储 服务比如redis 存储分布式全局id，然后每次请求时还是去查询有没有这个全局id没有才查询? 每次都去分布式存储中查询全局id是不是性能也会比较低？","like_count":0},{"had_liked":false,"id":84628,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1554887613,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554887613","product_id":100002201,"comment_content":"幂等性，例子举的例子很实际，扣库存同一订单多次的提交。之前只是想一下对应的办法，比如说设置按钮一段时间只能触发一次的，没有考虑过这些问题的特征共性以及解决方案思路以及那些需要注意。基本是发现一个相关异常就填一个坑。<br>幂等性，就是对同一资源一次和多次具有同样的副作用，类似于扣库存一次扣一次，重试多次同一订单也应该是同样的，毕竟是同一个订单同一个商品。","like_count":0,"discussions":[{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":125,"discussion_content":"个人感觉其实这里面应该是要有一些对 &#34;对同一资源&#34; 业务规则判别的定义的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561122280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80979,"user_name":"With Lin","can_delete":false,"product_type":"c1","uid":1237181,"ip_address":"","ucode":"F8E1B0B6EE9ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/bd/e32bdd43.jpg","comment_is_top":false,"comment_ctime":1553768469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553768469","product_id":100002201,"comment_content":"不错","like_count":0},{"had_liked":false,"id":63978,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1548635564,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1548635564","product_id":100002201,"comment_content":"我们的接口貌似没有幂等性，是根据当前系统时间来计算的。","like_count":0,"discussions":[{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126,"discussion_content":"支付类接口必须要有幂等性处理，遥记当年客户自动打款 2笔重复1000w自动转出去了，线上重大事故","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561122362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58113,"user_name":"周萱萱","can_delete":false,"product_type":"c1","uid":1185181,"ip_address":"","ucode":"65499DDEB634C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/9d/1efd064d.jpg","comment_is_top":false,"comment_ctime":1546998869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546998869","product_id":100002201,"comment_content":"讲解透彻，很受用。","like_count":0},{"had_liked":false,"id":15469,"user_name":"tiger","can_delete":false,"product_type":"c1","uid":1047291,"ip_address":"","ucode":"C15AC14AA33F40","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/fb/ef99d6ca.jpg","comment_is_top":false,"comment_ctime":1531202659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1531202659","product_id":100002201,"comment_content":"我使用的幂等性ID是业务的组合键，类似数据库的联合唯一索引","like_count":0},{"had_liked":false,"id":13241,"user_name":"Jeff","can_delete":false,"product_type":"c1","uid":1061394,"ip_address":"","ucode":"7F320F4D50A499","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/12/81e45592.jpg","comment_is_top":false,"comment_ctime":1529464040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1529464040","product_id":100002201,"comment_content":"我们系统中公众号发布文章，就出现过幂等性的问题：运营人员在后台页面发布文章后，没有收到被调用方的回应，随后点击按钮发布了几次，结果客户端收到了几条同样的文章。后来是通过提前产生一个全局id，避免重复请求，来达成幂等性","like_count":0},{"had_liked":false,"id":12044,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1528530972,"is_pvip":false,"replies":[{"id":"4009","content":"一方面，你需要一个控制系统（这个系统是跑不掉的（想想CMDB），可以由它来分配），另一方面，可以用一些机器标识，如Mac地址，lP地址什么的。","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1528649034,"ip_address":"","comment_id":12044,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528530972","product_id":100002201,"comment_content":"使用snowflake 的话要配置machine id ，那如果用auto scale 的时候怎么自动配置呢？","like_count":0,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419092,"discussion_content":"一方面，你需要一个控制系统（这个系统是跑不掉的（想想CMDB），可以由它来分配），另一方面，可以用一些机器标识，如Mac地址，lP地址什么的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528649034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9266,"user_name":"Spring coming","can_delete":false,"product_type":"c1","uid":1116196,"ip_address":"","ucode":"9E01F2D987D08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/24/1d3bafaf.jpg","comment_is_top":false,"comment_ctime":1526716036,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1526716036","product_id":100002201,"comment_content":"有两个疑问，希望皓哥解答，1 前边说道“100% 的请求都到这个存储里去查一下，这会导致处理流程可能会很慢。” 后边说的标准的处理方式还是要存一个全局的id，这样的话每个请求还是要去查一下这个id是不是已经存在啊。  <br>2  因为是下游服务存的全局id，当上游第一次提交超时，第二次再次提交的时候下游怎么判断是不是重复提交？ 第一次超时也不能够返回上游啊","like_count":0,"discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387176,"discussion_content":"1、直接存，不查，通过唯一约束保证不会重复写入；\n2、调用方重试时，携带首次生成的唯一标识，而不是再生成一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628038669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8737,"user_name":"小鱼儿","can_delete":false,"product_type":"c1","uid":1053492,"ip_address":"","ucode":"989EC453936B91","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/34/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1526394456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526394456","product_id":100002201,"comment_content":"有些疑惑，被调接口做幂等性处理，接口是不是要做aop包裹？","like_count":0},{"had_liked":false,"id":6204,"user_name":"Hua","can_delete":false,"product_type":"c1","uid":1083851,"ip_address":"","ucode":"6076250DDE7E30","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/cb/d7f80b87.jpg","comment_is_top":false,"comment_ctime":1524537088,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1524537088","product_id":100002201,"comment_content":"get不应有副作用所以幂等。我可以理解为因为没有副作用所以幂等。相当于有副作用所以不幂等？和你的delete和put解释有抵触。希望解答一下。看了文章还是没搞懂副作用和幂等的关系，或者说他们没有关系？","like_count":0,"discussions":[{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309598,"discussion_content":"这个真的看每个人的理解力了，get到了，大家在一起会很happy","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601363908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005824,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/00/6d14972a.jpg","nickname":"Arthur.Li","note":"","ucode":"EC2436A5136C13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103514,"discussion_content":"可以理解为多次请求造成的“影响”一样就是幂等了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577374731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":4014,"user_name":"Alan","can_delete":false,"product_type":"c1","uid":1061340,"ip_address":"","ucode":"15C718CA868099","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/dc/af9c4356.jpg","comment_is_top":false,"comment_ctime":1521207861,"is_pvip":false,"replies":[{"id":"944","content":"有点没看懂","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1521703020,"ip_address":"","comment_id":4014,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1521207861","product_id":100002201,"comment_content":"处理流程那节我觉得有问题，首先你插曲如果存在报错，只能说明你收到了，并不能说明处理成功了，那如果出现存在，但是处理未成功，返回丢失了，你下次重试的时候怎么判断状态呢","like_count":0,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":416167,"discussion_content":"有点没看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1521703020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1502735,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL06DePazHRU24iaGubbg5XOhvYQTkHRrItic9AvbZ24cjgFqfy620u9pOIoGu8FlK61oicEh8cGfHCw/132","nickname":"lazytortoise","note":"","ucode":"F597FB1F7C089C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300400,"discussion_content":"没有成功处理，删除掉这个全局id，调用方下次重试的时候就不受影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598082013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3702,"user_name":"Sdylan","can_delete":false,"product_type":"c1","uid":1008503,"ip_address":"","ucode":"4589D0D0FA9275","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/77/423345ab.jpg","comment_is_top":false,"comment_ctime":1520340658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1520340658","product_id":100002201,"comment_content":"之前碰到过类似的问题：前端多次调用后端接口。导致第一次是入库更新操作成功，后面几次由于前一次将调上游系统成功之后清除redis缓存了，导致后续的请求再次操失败。给用户提示不是很好，优化就是：不删除缓存，设置一个时效，用ID查，有则直接返回结果；否则继续后续的步骤。","like_count":0},{"had_liked":false,"id":3613,"user_name":"曹林华","can_delete":false,"product_type":"c1","uid":1001381,"ip_address":"","ucode":"6F33D21DF07423","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/a5/f0bdd6dc.jpg","comment_is_top":false,"comment_ctime":1520077163,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1520077163","product_id":100002201,"comment_content":"如果进行重试请求，刚好上一次请求正在处理。我们的重试请求就会被丢弃掉，但是刚好上一次请求处理过程中遇到异常没有处理成功，请问还有什么补偿机制吗？","like_count":0,"discussions":[{"author":{"id":1156155,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a4/3b/d1e3677a.jpg","nickname":"Walkb","note":"","ucode":"F6BFF555B277F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37973,"discussion_content":"请求段端需要设置后端创建成功返回的状态的，只要没收到成功状态就继续重试，所以重试不会是一次的。你的问题应该转译成怎样设计一个好的重试机制，尽管这样，最重最复杂的活儿应该还是要放在后端的，后端需要完成一致性api的设计和实现，这可以引申到另一个话题，分布式事务的一致性问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571707738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3595,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1520007485,"is_pvip":false,"replies":[{"id":"759","content":"上游防重，那需要在请求超时后做查询了。文章中也讲了这种情况","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1520471650,"ip_address":"","comment_id":3595,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1520007485","product_id":100002201,"comment_content":"抱歉，我理解有误。我们的做法是相当于在上游防止重复提交。","like_count":0,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415957,"discussion_content":"上游防重，那需要在请求超时后做查询了。文章中也讲了这种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1520471650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3574,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1519920434,"is_pvip":false,"replies":[{"id":"693","content":"不太清楚你说的拦截器是什么东西？另外，如果不记录，怎么知道做没做？","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1519958493,"ip_address":"","comment_id":3574,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1519920434","product_id":100002201,"comment_content":"通过请求头中带token和拦截器做防重，token不用存数据库","like_count":0,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415948,"discussion_content":"不太清楚你说的拦截器是什么东西？另外，如果不记录，怎么知道做没做？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1519958493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3568,"user_name":"姚利虎","can_delete":false,"product_type":"c1","uid":1060158,"ip_address":"","ucode":"B67965F7050F04","user_header":"https://static001.geekbang.org/account/avatar/00/10/2d/3e/c889dfee.jpg","comment_is_top":false,"comment_ctime":1519910520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1519910520","product_id":100002201,"comment_content":"平时设计的时候很难会对一个服务考虑到这么细致，领教了！","like_count":0}]}