{"id":510503,"title":"22｜DI Container（10）：怎样将大粒度的测试重构为等效的小粒度测试代码？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code>ContextConfig.java:\n\npackage geektime.tdd.di;\n\nimport java.util.*;\nimport static java.util.List.of;\n\npublic class ContextConfig {\n    private Map&lt;Class&lt;?&gt;, ComponentProvider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n    \n    public &lt;Type&gt; void bind(Class&lt;Type&gt; type, Type instance) {\n        providers.put(type, new ComponentProvider&lt;Type&gt;() {\n            @Override\n            public Type get(Context context) {\n                return instance;\n            }\n            @Override\n            public List&lt;Class&lt;?&gt;&gt; getDependencies() {\n                return of();\n            }\n        });\n    }\n    \n    public &lt;Type, Implementation extends Type&gt;\n    void bind(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation) {\n        providers.put(type, new ConstructorInjectionProvider&lt;&gt;(implementation));\n    }\n    \n    public Context getContext() {\n        providers.keySet().forEach(component -&gt; checkDependencies(component, new Stack&lt;&gt;()));\n        return new Context() {\n            @Override\n            public &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type) {\n                return Optional.ofNullable(providers.get(type)).map(provider -&gt; (Type) provider.get(this));\n            }\n        };\n    }\n    \n    private void checkDependencies(Class&lt;?&gt; component, Stack&lt;Class&lt;?&gt;&gt; visiting) {\n        for (Class&lt;?&gt; dependency: providers.get(component).getDependencies()) {\n            if (!providers.containsKey(dependency)) throw new DependencyNotFoundException(component, dependency);\n            if (visiting.contains(dependency)) throw new CyclicDependenciesFoundException(visiting);\n            visiting.push(dependency);\n            checkDependencies(dependency, visiting);\n            visiting.pop();\n        }\n    }\n    \n    interface ComponentProvider&lt;T&gt; {\n        T get(Context context);\n        List&lt;Class&lt;?&gt;&gt; getDependencies();\n    }\n}\n\nConstructorInjectionProvider.java:\n\npackage geektime.tdd.di;\n\nimport jakarta.inject.Inject;\nimport java.lang.reflect.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Stream.concat;\n\nclass ConstructorInjectionProvider&lt;T&gt; implements ContextConfig.ComponentProvider&lt;T&gt; {\n\n    private Constructor&lt;T&gt; injectConstructor;\n    private List&lt;Field&gt; injectFields;\n    private List&lt;Method&gt; injectMethods;\n    \n    public ConstructorInjectionProvider(Class&lt;T&gt; component) {\n        if (Modifier.isAbstract(component.getModifiers())) throw new IllegalComponentException();\n        this.injectConstructor = getInjectConstructor(component);\n        this.injectFields = getInjectFields(component);\n        this.injectMethods = getInjectMethods(component);\n        if (injectFields.stream().anyMatch(f -&gt; Modifier.isFinal(f.getModifiers()))) throw new IllegalComponentException();\n        if (injectMethods.stream().anyMatch(m -&gt; m.getTypeParameters().length != 0)) throw new IllegalComponentException();\n    }\n\n    @Override\n    public T get(Context context) {\n        try {\n            Object[] dependencies = stream(injectConstructor.getParameters())\n                    .map(p -&gt; context.get(p.getType()).get())\n                    .toArray(Object[]::new);\n            T instance = injectConstructor.newInstance(dependencies);\n            for (Field field : injectFields)\n                field.set(instance, context.get(field.getType()).get());\n            for (Method method : injectMethods)\n                method.invoke(instance, stream(method.getParameterTypes()).map(t -&gt; context.get(t).get())\n                        .toArray(Object[]::new));\n            return instance;\n        } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public List&lt;Class&lt;?&gt;&gt; getDependencies() {\n        return concat(concat(stream(injectConstructor.getParameters()).map(Parameter::getType),\n                        injectFields.stream().map(Field::getType)),\n                injectMethods.stream().flatMap(m -&gt; stream(m.getParameterTypes()))\n        ).toList();\n    }\n    \n    private static &lt;T&gt; List&lt;Method&gt; getInjectMethods(Class&lt;T&gt; component) {\n        List&lt;Method&gt; injectMethods = new ArrayList&lt;&gt;();\n        Class&lt;?&gt; current = component;\n        while (current != Object.class) {\n            injectMethods.addAll(stream(current.getDeclaredMethods()).filter(m -&gt; m.isAnnotationPresent(Inject.class))\n                    .filter(m -&gt; injectMethods.stream().noneMatch(o -&gt; o.getName().equals(m.getName()) &amp;&amp;\n                            Arrays.equals(o.getParameterTypes(), m.getParameterTypes())))\n                    .filter(m -&gt; stream(component.getDeclaredMethods()).filter(m1 -&gt; !m1.isAnnotationPresent(Inject.class))\n                            .noneMatch(o -&gt; o.getName().equals(m.getName()) &amp;&amp;\n                                    Arrays.equals(o.getParameterTypes(), m.getParameterTypes())))\n                    .toList());\n            current = current.getSuperclass();\n        }\n        Collections.reverse(injectMethods);\n        return injectMethods;\n    }\n\n    private static &lt;T&gt; List&lt;Field&gt; getInjectFields(Class&lt;T&gt; component) {\n        List&lt;Field&gt; injectFields = new ArrayList&lt;&gt;();\n        Class&lt;?&gt; current = component;\n        while (current != Object.class) {\n            injectFields.addAll(stream(current.getDeclaredFields()).filter(f -&gt; f.isAnnotationPresent(Inject.class))\n                    .toList());\n            current = current.getSuperclass();\n        }\n        return injectFields;\n    }\n    \n    private static &lt;Type&gt; Constructor&lt;Type&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n        List&lt;Constructor&lt;?&gt;&gt; injectConstructors = stream(implementation.getConstructors())\n                .filter(c -&gt; c.isAnnotationPresent(Inject.class)).collect(Collectors.toList());\n        if (injectConstructors.size() &gt; 1) throw new IllegalComponentException();\n        return (Constructor&lt;Type&gt;) injectConstructors.stream().findFirst().orElseGet(() -&gt; {\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new IllegalComponentException();\n            }\n        });\n    }\n}\n\nContext.java:\npackage geektime.tdd.di;\n\n\nimport java.util.Optional;\n\n\npublic interface Context {\n    &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type);\n}\n</code></pre><p>任务列表状态为：</p><ul>\n<li>\n<p><s>无需构造的组件——组件实例</s></p>\n</li>\n<li>\n<p><s>如果注册的组件不可实例化，则抛出异常</s></p>\n<ul>\n<li><s>抽象类</s></li>\n<li><s>接口</s></li>\n</ul>\n</li>\n<li>\n<p><s>构造函数注入</s></p>\n<ul>\n<li><s>无依赖的组件应该通过默认构造函数生成组件实例</s></li>\n<li><s>有依赖的组件，通过Inject标注的构造函数生成组件实例</s></li>\n<li><s>如果所依赖的组件也存在依赖，那么需要对所依赖的组件也完成依赖注入</s></li>\n<li><s>如果组件有多于一个Inject标注的构造函数，则抛出异常</s></li>\n<li><s>如果组件没有Inject标注的构造函数，也没有默认构造函数（新增任务）</s></li>\n<li><s>如果组件需要的依赖不存在，则抛出异常</s></li>\n<li><s>如果组件间存在循环依赖，则抛出异常</s></li>\n</ul>\n</li>\n<li>\n<p><s>字段注入</s></p>\n<ul>\n<li><s>通过Inject标注将字段声明为依赖组件</s></li>\n<li><s>如果字段为final则抛出异常</s></li>\n<li><s>依赖中应包含Inject Field声明的依赖</s></li>\n</ul>\n</li>\n<li>\n<p><s>方法注入</s></p>\n<ul>\n<li><s>通过Inject标注的方法，其参数为依赖组件</s></li>\n<li><s>通过Inject标注的无参数方法，会被调用</s></li>\n<li><s>按照子类中的规则，覆盖父类中的Inject方法</s></li>\n<li><s>如果方法定义类型参数，则抛出异常</s></li>\n<li><s>依赖中应包含Inject Method声明的依赖</s></li>\n</ul>\n</li>\n<li>\n<p>对Provider类型的依赖</p>\n<ul>\n<li>注入构造函数中可以声明对于Provider的依赖</li>\n<li>注入字段中可以声明对于Provider的依赖</li>\n<li>注入方法中可声明对于Provider的依赖</li>\n</ul>\n</li>\n<li>\n<p>自定义Qualifier的依赖</p>\n<ul>\n<li>注册组件时，可额外指定Qualifier</li>\n<li>注册组件时，可从类对象上提取Qualifier</li>\n<li>寻找依赖时，需同时满足类型与自定义Qualifier标注</li>\n<li>支持默认Qualifier——Named</li>\n</ul>\n</li>\n<li>\n<p>Singleton生命周期</p>\n<ul>\n<li>注册组件时，可额外指定是否为Singleton</li>\n<li>注册组件时，可从类对象上提取Singleton标注</li>\n<li>对于包含Singleton标注的组件，在容器范围内提供唯一实例</li>\n<li>容器组件默认不是Single生命周期</li>\n</ul>\n</li>\n<li>\n<p>自定义Scope标注</p>\n<ul>\n<li>可向容器注册自定义Scope标注的回调</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><h2>视频演示</h2><p>让我们进入今天的部分：</p><p><video poster=\"https://media001.geekbang.org/e9c0a2ef9705460884797a2a5d1cd2af/snapshots/5f506af31a5e42358a3138fd7a9c212c-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/33e4f2c7-180600d96c5-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/311edf18aabc4c038370cd7795127002/a9da7e09f9474d1cbe857c9a681f9e6e-eb82d50e6e51f7685db828cf0bc0c628-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>在进入下节课之前，希望你能认真思考如下两个问题，并选择最有感触的一道进行回答。</p><ol>\n<li>你是怎么发现坏味道的？在重构的过程中，都使用了哪些重构手法呢？</li>\n<li>如果要对ContainerTest进行文档化改造，你会怎么做呢？</li>\n</ol><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码的链接分享出来。相信经过你的思考与实操，学习效果会更好！</p>","neighbors":{"left":{"article_title":"21｜DI Container（9）：怎样重构测试代码？","id":510495},"right":{"article_title":"23｜DI Container（11）：如何对ContainerTest进行文档化改造？","id":510518}},"comments":[{"had_liked":false,"id":344110,"user_name":"张铁林","can_delete":false,"product_type":"c1","uid":1108258,"ip_address":"","ucode":"4AB8BC6CDAC0A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/22/7606c6ba.jpg","comment_is_top":true,"comment_ctime":1651247514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233720385060004e+18","product_id":100109401,"comment_content":"https:&#47;&#47;github.com&#47;vfbiby&#47;tdd-di-container&#47;tree&#47;main&#47;doc<br>在这下面有每一章的“心法”，照着练，就不用看视频了，全程尽量跟着老师的步骤来。","like_count":0},{"had_liked":false,"id":347649,"user_name":"奇小易","can_delete":false,"product_type":"c1","uid":1171151,"ip_address":"","ucode":"E06B4DFB5352BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/de/cf/ef2e0501.jpg","comment_is_top":false,"comment_ctime":1654248622,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654248622","product_id":100109401,"comment_content":"Q: 如何发现坏味道？<br>本文出现两个坏味道，<br>一个是一个测试类的上下文中存在粒度(测试范围)不同的测试。<br>另一个是测试本身不具有文档的性质，不好理解。<br>据此可知，好的测试需要具备文档化的特点，好的测试需要在同一上下文保持一致的粒度，保持一致的命名思路。<br>这些良好测试的特点就是用于识别坏味道的指导方针。","like_count":0},{"had_liked":false,"id":346806,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1653446528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653446528","product_id":100109401,"comment_content":"老師可否講講測試粒度的選擇、組織？TDD適不適合測試金字塔各個層？<br>縱然大粒度測試應該少，但前提是大粒度測試的低效（如難維護的依賴，易出錯等）。如果像本項目這樣的純內存裡的測試，大粒度不是更合適嗎？更有利於內部的重構。","like_count":0},{"had_liked":false,"id":344607,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1651666700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651666700","product_id":100109401,"comment_content":"测试变文档<br><br>- 从文档角度优化测试<br>- 使用 @Nested 将功能分组<br>- 测试天然不是文档，而是你实现过程的记录<br>- 对测试进行足够提取和刻意的组织后才能变成真正的文档","like_count":0},{"had_liked":false,"id":344381,"user_name":"临风","can_delete":false,"product_type":"c1","uid":1145430,"ip_address":"","ucode":"59A7F3DDD94D76","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/56/29877cb9.jpg","comment_is_top":false,"comment_ctime":1651500566,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1651500566","product_id":100109401,"comment_content":"代码坏味道就是你看了代码觉得不好理解的地方，本质就是为了提高代码的可维护性和可读性。之前我写代码的时候容易考虑很多，导致代码过度设计。后面学习代码重构手法之后，配合上TDD的使用，就有充足信心，减少甚至不考虑未来的拓展性问题。因为将来代码改动时，你可以通过重构的手法，使其适应改动的方向，再进行代码功能的增添，使代码能一直保持很高的可读性。<br>另外对于测试代码的重构，老师的“测试天然表现的是开发实现的逻辑，测试天然不是文档”的观点让我印象深刻。之前也听过，你不要让别人通过逐行看代码来理解代码逻辑，而是要通过测试用例来告诉别人你的代码逻辑和功能，直到完成测试的重构才彻底明白了这一观点的由来。<br>上次作业完成的时候，和老师的实现略有不同，经过老师的提示后，进行了重构。期间充分体会到TDD的好处，由于测试的充分覆盖，你的每个功能点都不用害怕代码的重构会不小心改坏了。看着简洁的代码，竟莫名有点小成就感。<br>最后有个问题想问老师，这个container是因为只有自己一个人写，可以随心所欲。实际项目中，如何才能在缺少测试用例的情况下进行一定的代码重构呢？老师会建议直接复用代码，还是有其它好的方法呢？<br>https:&#47;&#47;github.com&#47;lenwind&#47;TDD-Learn","like_count":0},{"had_liked":false,"id":344109,"user_name":"张铁林","can_delete":false,"product_type":"c1","uid":1108258,"ip_address":"","ucode":"4AB8BC6CDAC0A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/22/7606c6ba.jpg","comment_is_top":false,"comment_ctime":1651246612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651246612","product_id":100109401,"comment_content":"https:&#47;&#47;github.com&#47;vfbiby&#47;tdd-di-container<br>我来贴一下代码，没有每一步小的做提交，主要是为了方便回滚到上一课，再来练习。","like_count":0}]}