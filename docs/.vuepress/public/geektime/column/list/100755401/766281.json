{"id":766281,"title":"16｜任务划分与测试驱动AI开发","content":"<p>你好，我是徐昊，今天我们来继续学习AI时代的软件工程。</p><p>上一节课，我们展示了直接使用大语言模型（Large Language Model，LLM）辅助进行软件开发的例子，我们看到虽然在速度上LLM有惊人的提高，但是质量堪忧。而且在与LLM一起开发的时候，我们的关注点更多集中在测试上，<strong>通过测试提炼需要给予LLM的反馈，而不是编码。</strong></p><p>可能有同学会说，<strong>那是因为你擅长测试驱动开发（Test Driven Development，TDD），有路径依赖</strong>。那么今天这节课，我们就从根本上讲一讲，使用LLM辅助软件开发的核心思路。</p><h2>从任务划分开始</h2><p>我们都知道，LLM存在技术限制，每一次LLM只能处理有限数量的token以及产生有限数量token的结果。因而LLM能够理解的上下文规模，以及能够生成的应用规模都是有限的。对于大型系统，我们无法一次性将上下文传递给LLM，也无法从LLM中一次性获取整个应用。</p><p>那么使用LLM辅助软件交付的关键就在于<strong>将需求分解成足够小的任务，然后将这个任务转化为LLM的提示词</strong>，交由LLM处理，最后我们再将LLM的生成结果组合成生产或测试代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/78/e3d80d0bc473767fe42851a1df582a78.jpg?wh=1475x940\" alt=\"\"></p><p><strong>那么如何把任务划分成LLM易于处理的形式，就成为了使用LLM辅助软件开发的关键。<strong>而对于任务的划分，通常需要考虑两个维度，即</strong>软件的架构</strong>与<strong>测试策略</strong>。</p><!-- [[[read_end]]] --><p>软件架构是指在设计和构建软件系统时所选择的<strong>组件（Component）以及组件间的交互方式</strong>。它涉及到软件系统的各个部分之间的关系、组件的功能划分、数据流程以及整体系统的性能和可维护性等方方面面的决策。软件架构在整个软件开发过程中起着关键的指导作用，它是我们划分任务的重要依据。</p><p>比如，我们使用分层架构（Layered architecture）构造一个微服务系统，架构分成三层：接入层负责处理HTTP请求，业务层处理核心逻辑，数据访问层负责读取数据。</p><p>那么当我们处理业务需求时，业务需求总会被分解为针对这三层的某种任务。比如，我们要增加一个新的API，那么我们需要在接入层增加处理新的HTTP的请求，需要在业务层增加相应的逻辑代码，需要在数据访问层增加对于数据的访问。</p><p><strong>任务总是以架构为基准划分的，架构最大的作用，也是指导每日工作的任务划分。当任务划分与架构规划不一致时，架构就会开始腐化。</strong></p><p><strong>测试策略</strong>是软件测试计划的一部分，它是为了确保软件项目的测试活动能够达到预期目标而定义的一组指导性原则和方法。测试策略通常在项目的早期制定，并为整个测试过程提供一个框架，以确保测试活动能够有效地进行、有组织地执行，并产生可靠的测试结果。</p><p>对于使用LLM辅助软件交付来说，<strong>测试策略非常重要</strong>。请回想之前在业务知识管理的部分，我们讨论为什么无法通过直接构造快速反馈构造软件的时候，提到过<strong>反馈循环的瓶颈是我们如何验证LLM生成的系统是正确且有效的</strong>。比如<a href=\"https://time.geekbang.org/column/article/765541\">上一节课</a>，我们与LLM交互的过程中，大量的时间都花费在了验证和测试上。</p><p>这是因为LLM生成的回答是基于其在训练数据中学到的模式和信息。模型的目标是根据输入提供有用和合理的文本，但并不能真正理解问题的含义。有时候，模型可能会生成看似合理但事实上不正确或不准确的答案。</p><p>由于我们不可能在每一次LLM根据我们的反馈提供新的答案时都进行<strong>全量回归测试（Full regression test）</strong>。因而，选择恰当的测试策略，快速有效地验证LLM给出的结果，就成了利用LLM辅助软件开发的关键。</p><p>那么使用LLM辅助软件交付的核心方法已经呼之欲出了。没错，就是<strong>测试驱动开发。</strong></p><h2><strong>测试驱动AI开发</strong></h2><p>测试驱动开发是一种软件开发方法，其核心思想是在编写实际代码之前先编写测试。TDD的基本循环通常被称为“红-绿-重构”：</p><ol>\n<li><strong>红（Red）</strong>： 开发者首先编写一个失败的测试用例，该测试用例通常反映了新功能或修改的期望行为。在这个阶段，测试会失败，因为尚未编写与之相匹配的实际代码。</li>\n<li><strong>绿（Green）</strong>：开发者接着编写足够的代码以满足测试用例。目标是使测试用例通过，即使这意味着编写简单且基本的代码，只是足够满足当前测试的要求。</li>\n<li><strong>重构（Refactor）</strong>： 一旦测试用例通过，开发者可以对代码进行重构，改进其设计、性能或可读性，而不改变其行为。在这个过程中，开发者可以保持测试通过的状态。</li>\n</ol><p>这个循环不断重复，每次都添加新的测试用例，然后编写足够的代码以满足这些测试用例，最后进行重构。关于测试驱动开发的详细内容，可以参看我<a href=\"https://time.geekbang.org/column/intro/100109401\">另外一个专栏</a>。</p><p>当我们使用LLM辅助软件开发时，我们应该遵循一样的规则，按照测试策略，为LLM编写的代码提供对应的测试。当然，这个测试可以是手动测试，也可以是自动化测试。鉴于通常我们需要与LLM交互迭代多次，才能得到最终的代码，自动化测试的投资回报率和效率要高得多。</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/df/4b6ebb68faf5644d698beec132ea1bdf.jpg?wh=1788x988\" alt=\"\"></p><p>然而我们容易忽略的一个事实是，<strong>测试驱动开发通常需要配合结对编程（Pair Programming）一起应用</strong>。</p><p>使用结对编程时，两名程序员共同在同一台计算机上工作，共同完成一个编码任务。在结对编程中，两名程序员分别扮演<strong>“司机”（Driver）</strong>和 <strong>“导航员”（Navigator）</strong>的角色，通过不断交流和协作来完成编码工作。</p><p>所谓司机是当前掌握键盘和鼠标的人，负责实际的编码工作；导航员是司机的搭档，负责审查代码、提出改进意见、思考问题，并与司机共同制定解决方案。导航员通常专注于更高层次的设计。</p><p>在同时使用结对编程和测试驱动开发时，结对的两个人轮流扮演司机和导航员的角色。只不过这种角色转换的依据，<strong>是正在编写的代码是测试代码还是生产代码</strong>。其中一个人作为测试代码的司机，编写测试代码，然后交给另一个人扮演生产代码的司机，编写生产代码。</p><p>当我们使用LLM辅助软件开发时，显然LLM在绝大多数的时间里扮演的是“司机”的角色。因而，我们需要按照测试驱动开发“红-绿-重构”的节奏，分别扮演测试代码的导航员和生产代码的导航员，与LLM一起完成编码的工作。</p><p><img src=\"https://static001.geekbang.org/resource/image/34/36/343a33d0c6319f1b401ec319a7yy3f36.jpg?wh=1785x1003\" alt=\"\"></p><p>请再一次回想我们上节课所展示的例子：</p><ul>\n<li>在初始环节，我们扮演的是<strong>生产代码的导航员</strong>，通过将需求改造为提示词模板，让LLM扮演了<strong>生产代码的司机</strong>，生成了生产代码；</li>\n<li>然后，我们扮演的是<strong>测试代码的导航员</strong>，提出需求，让LLM扮演了<strong>测试代码的司机</strong>，生产了测试代码；</li>\n<li>在第一次调试的时候，我们又成了<strong>生产代码的导航员</strong>，此时我们处在TDD“红-绿-重构”的红这一阶段。将错误信息提供给了LLM，LLM扮演了<strong>生产代码的司机</strong>，修改了生产代码；</li>\n<li>第二次调试的时候，我们还是<strong>生产代码的导航员</strong>，我们快速地通过了测试（如果切分为更小粒度的话，是一个独立测试）。此时我们处在TDD“红-绿-重构”的绿这一阶段。但是我们发现了设计问题，给出了设计修改的建议，进入了“TDD\"红-绿-重构”的重构这一阶段，LLM再次扮演了<strong>生产代码的司机</strong>，修改了生产代码；</li>\n<li>第三次调试与第二次调试类似，只不过我们通过设计建议，完成了TDD“红-绿-重构”中由红到绿的过程。</li>\n</ul><p>所以，哪怕我们没有刻意使用TDD和结对编程，当我们使用LLM辅助开发时，还是会不自觉地，进入这个步调。</p><h2>总结</h2><p>通过前面的讲解我们可以发现，使用LLM辅助软件开发的核心思路是<strong>使用测试驱动的方法与LLM进行结对编程</strong>。这一方面解决了我们验证LLM生成结果是否正确的需要，满足了质量诉求，另一个方面最大化了使用LLM的效用。</p><p>如果是辅助个人开发，那么按照前面讲的这个思路就已经足够了。而如果是对于使用LLM辅助团队开发的场景，我们还可以更进一步，将任务分解的部分也交给LLM辅助。由于任务分解属于庞杂认知模式（Complicated），我们可以通过思维链（Chain of Thought，CoT）交由LLM辅助。</p><p>道理我们之前已经讲过很多次了，对个人而言，利用LLM庞杂模式提效不明显，需要在团队中通过提高不可言说传递的效率，才能带来效率的提升。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/b8/6b1c1e7d496d0df75a78f66853f0b1b8.jpg?wh=2031x1080\" alt=\"\"></p><p>在这样的图景中，我们不难发现不同的LLM所需要管理的知识：</p><ol>\n<li>对于任务分解的LLM而言，它需要了解架构和测试策略的知识，并将这些知识形成对应的思维链。</li>\n<li>对于扮演测试Driver的LLM而言，它需要知道测试策略的知识以及测试技术栈的知识。</li>\n<li>对于扮演生产代码Driver的LLM而言，它需要知道架构的知识以及技术栈的知识。</li>\n</ol><p>那么后续的课程，我们就将围绕如何整理归纳这些知识，讲述如何利用LLM辅助软件交付。</p><h2>思考题</h2><p>根据前面的提示，构造一个用于测试Driver的提示词模板。</p><p>欢迎你在留言区分享自己的思考或疑惑，我们会把精彩内容置顶供大家学习讨论。</p>","neighbors":{"left":{"article_title":"15｜使用LLM生成代码和测试","id":765541},"right":{"article_title":"17｜如何与LLM结对编程？","id":766721}},"comments":[{"had_liked":false,"id":389554,"user_name":"术子米德","can_delete":false,"product_type":"c1","uid":1898023,"ip_address":"日本","ucode":"382EA7E2AF0B56","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","comment_is_top":false,"comment_ctime":1712877057,"is_pvip":true,"replies":[{"id":141727,"content":"实际上 llm并不能保证在大context下的准确推理 目前（2024）来看 给的context越多 llm的推理准确度是下降的","user_name":"作者回复","user_name_real":"编辑","uid":2537798,"ctime":1712886577,"ip_address":"浙江","comment_id":389554,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"🤔☕️🤔☕️🤔\n【R】限制：LLM每次能处理的输入与输出token数量。\n关键：从架构设计和测试策略两个维度，将需求分解到足够小的任务。\nLLM：任务分解 + 测试代码 + 生产代码。\n架构：指导每日工作的任务划分。\n测试：TDD + PP with LLM。\nPP = Pair Programming\n【.I.】LLM的Context Token数量，似乎是它的缺点，看到那个谁已经整得很大，眼看着能把整个代码仓扔进去，貌似很好的样子。可是，我倒认为，这样的限制，实际上可以利用起来，发挥出局部性的聚焦优势。无论我在多大的代码仓里干活，我实际要做的事情，越是在局部，越是能够做得干净利落，越是跟其它耦合，那就拖泥带水踩坑前行。\n【.I.】架构，这个词写出来，总有点看似高级又不明所言感。实际上，还不是手头有怎样的兵，就会演化出怎样的架构，无论写在纸上还是落进代码仓里。如今，LLM作为新兵入队，自然会变成影响演化的力量，差别在于，LLM凭自己的生命力，见空就座，还是听话就座，我猜测是前者，而且我相信我的猜测是对的，LLM的力量在于，只要坐下来，就会黏住。\n【Q】团队是否也有Clear、Complica、Complex的认知状态？如果有的话，怎么能判断出来当下团队整体处于什么样的认知状态？\n—  by 术子米德@2024年4月12日","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641685,"discussion_content":"实际上 llm并不能保证在大context下的准确推理 目前（2024）来看 给的context越多 llm的推理准确度是下降的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712886577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389899,"user_name":"范飞扬","can_delete":false,"product_type":"c1","uid":2721761,"ip_address":"广东","ucode":"A665DF46833A81","user_header":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","comment_is_top":false,"comment_ctime":1713835162,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"原文\n====\n对于扮演测试 Driver 的 LLM 而言，它需要知道测试策略的知识以及测试技术栈的知识。\n\n思考\n====\n这里老师少说了一点：测试 Driver 也需要架构的知识。因为在 20 讲，老师的prompt就是这么写的[1]。\n\n注释：\n[1] 20讲 的 prompt 如下：\n架构描述\n=======\n(略）\n\n功能需求\n=======\n{functionalities} \n\n任务\n====\n上面功能需求描述的场景，在 Persistent 层中需要哪些组件（目标组件）；\n列出需求描述的场景使用到目标组件的功能（目标功能）；\n列出目标功能需要测试的场景。描述场景，并给出相关的测试数据。\n","like_count":0}]}