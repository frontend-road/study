{"id":624444,"title":"06｜Concepts实战：写个向量计算模板库","content":"<p>你好，我是卢誉声。</p><p>Concept之于C++泛型编程，正如class之于C++面向对象。在传统的C++面向对象编程中，开发者在写代码之前，要思考好如何设计“类”，同样地，在C++20及其后续演进标准之后，我们编写基于模板技术的泛型代码时，必须先思考如何设计好“concept”。</p><p>具体如何设计呢？今天我们就来实战体验一下，使用C++模板，编写一个简单的向量计算模板库。</p><p>在开发过程中，我们会大量使用Concepts和约束等C++20以及后续演进标准中的特性，重点展示如何基于模板设计与开发接口（计算上如何通过SIMD等指令进行性能优化不是关注的重心）。</p><p>完成整个代码实现后，我们会基于今天的开发体验，对Concepts进行归纳总结，进一步深入理解（课程配套代码，点击<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>即可获取）。</p><p>好，话不多说，我们直接开始。</p><h2>模块组织方式</h2><p>对于向量计算模板库这样一个项目，我们首先要考虑的就是如何组织代码。</p><p>刚刚学的C++ Modules正好可以派上用场，作为工程的模块组织方式。后面是项目的具体结构。<br>\n<img src=\"https://static001.geekbang.org/resource/image/2d/7f/2d7767067160c57b811b567423576e7f.jpg?wh=3820x2866\" alt=\"\"></p><p>实现向量计算库的接口时，我们会部分模仿Python著名的函数库NumPy。因此，向量库的模块命名为numcpp，namespace也会使用numcpp。</p><!-- [[[read_end]]] --><p>先梳理一下每个模块的功能。</p><ul>\n<li>main：系统主模块，调用numcpp模块完成向量计算；</li>\n<li>numcpp：工程主模块，负责导入其他分区并重新导出；</li>\n<li>numcpp:creation：向量创建模块，提供了基于NDArray类的向量创建接口；</li>\n<li>numcpp:algorithm：计算模块，负责导入各类算法子模块；</li>\n<li>numcpp:algorithm.aggregate：聚合计算模块，负责提供各类聚合计算函数。比如sum、max和min等聚合统计函数；</li>\n<li>numcpp:algorithm.basic：基础计算模块，负责提供各类基础计算函数。比如加法、减法和点积等聚合统计函数；</li>\n<li>numcpp:algorithm.universal：通用计算模块，负责提供各类通用计算函数。比如reduce和binaryMap等向量通用计算接口，aggregate和basic中部分函数就会基于该模块实现。</li>\n</ul><p>有了清晰的模块划分，我们先从接口开始编写，再使用Concepts来约束设计的模板，这将是今天的学习重点。</p><h2>接口设计</h2><p>首先，我们来设计numcpp模块的接口模块numcpp.cpp。</p><pre><code class=\"language-c++\">export module numcpp;\n\nexport import :array;\nexport import :array.view;\nexport import :creation;\nexport import :algorithm;\n</code></pre><p>在这段代码中，我们使用export module定义模块numcpp，然后使用export import导入几个需要导出的子分区，包括array、array.view、creation和algorithm。</p><p>接下来，还要创建向量的相关接口。</p><pre><code class=\"language-c++\">auto arr1 = numcpp::zeros&lt;int32_t&gt;({1, 2, 3});\nauto arr2 = numcpp::array({1, 2, 3});\nauto arr3 = numcpp::array&lt;std::initializer_list&lt;std::initializer_list&lt;int32_t&gt;&gt;&gt;({ {1, 2}, {3, 4} });\nauto arr4 = numcpp::array&lt;std::vector&lt;std::vector&lt;std::vector&lt;int32_t&gt;&gt;&gt;&gt;({\n&nbsp;&nbsp;&nbsp; {{1, 2}, {3, 4}},\n&nbsp;&nbsp;&nbsp; {{5, 6}, {7, 8}} \n});\nauto arr5 = numcpp::ones&lt;int32_t&gt;({ 1, 2, 3, 4, 5 });\n</code></pre><p>在这段代码中：</p><ul>\n<li>第1行，通过zeros生成三维向量，初始化列表中的参数{1, 2, 3}表示这个向量的shape。其中，三个维度的项目数分别为1、2和3，而zeros表示生成的向量元素初始值都是0。</li>\n<li>第2行，通过array创建了一维向量，初始化列表中的参数{1, 2, 3}表示这个向量的元素为1、2和3。</li>\n<li>第3行，通过array创建了二维向量，初始化列表中的参数{{1, 2}, {3, 4}}表示这个向量是一个2行2列的向量，第一行的值为1和2，第二行的值为3和4。</li>\n<li>第4行，通过array创建了三维向量。初始化列表中的参数表示这个向量是一个2<em>2</em>2的向量。一共八个元素，按照排列顺序分别是1、2、3、4、5、6、7和8。</li>\n<li>第8行，通过ones创建了五维向量，初始化列表中的参数{1, 2, 3, 4, 5}表示这个向量的shape。</li>\n</ul><p>接下来，是索引接口——用于从数组中获取到特定的值。</p><pre><code class=\"language-c++\">int32_t value = arr1[{0, 1, 2}];\nstd::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; std::endl;\n</code></pre><p>这一小段代码中，通过[]来获取特定位置的元素，在{}中需要给定位置的准确索引。那么，这行代码的意思就是，获取arr1中三个维度分别为0、1、2位置的元素。</p><p>从功能上讲，numcpp也支持为多维数组创建视图，所谓视图就是一个多维数组的一个切片，但是数据依然直接引用原本的数组，创建视图的方法是这样的。</p><pre><code class=\"language-c++\">auto view1 = arr1.view(\n&nbsp;&nbsp;&nbsp; {0, 2}\n);\n\nauto view2 = arr3.view({\n&nbsp;&nbsp;&nbsp; {0, 1},\n&nbsp;&nbsp;&nbsp; {1, 2}\n});\n</code></pre><p>这段代码中：</p><ul>\n<li>第1行，调用view函数，在数组arr1中创建了一个子视图，从第一个维度切出了0到2这个区间，注意这里的区间是左闭右开。</li>\n<li>第5行，类似地，调用view函数，在数组arr3中创建了一个子视图，第一个维度切出了0到1，第二个维度切出了1到2。由于arr3是一个2 × 2的向量，因此最后得到的视图是一个2 × 1的向量。</li>\n</ul><p>现在，我们继续为接口添加“基础计算”功能。</p><pre><code class=\"language-c++\">auto arr6 = numcpp::array&lt;std::vector&lt;std::vector&lt;int32_t&gt;&gt;&gt;({ { 1, 2, 3 }, { 4, 5, 6} });\nprintArray(arr6);\nauto arr7 = numcpp::array&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;({ { 3.5, 3.5, 3.5 }, { 3.5, 3.5, 3.5 } });\nprintArray(arr7);\n\nauto arr8 = arr6 + arr7;\nprintArray(arr8);\nauto arr9 = arr6 - arr7;\nprintArray(arr9);\nauto arr10 = numcpp::dot(arr6, arr7);\nprintArray(arr10);\n</code></pre><p>在这段代码中，分别在第6、78、10行调用了向量基本运算符——向量加法、减法和点积。它们的计算结果分别是返回两个向量所有相同位置元素和、差和乘积，并生成一个新的向量。</p><p>需要注意的是，这里用dot而非重载operator*来实现向量点积。这是因为向量之间的乘法不止一种。我在这里定义一个dot函数是为了避免引起误解，也减少用户的记忆负担。</p><p>这些基础计算接口都要求两个输入向量的shape完全一致，如果不同会直接抛出参数异常。</p><p>接着，我们为接口添加“聚合计算”功能。</p><pre><code class=\"language-c++\">double sum = numcpp::sum(arr10);\nstd::cout &lt;&lt; \"Array10 sum: \" &lt;&lt; sum &lt;&lt; std::endl;\n\ndouble maxElement = numcpp::max(arr10);\nstd::cout &lt;&lt; \"Array10 max: \" &lt;&lt; maxElement &lt;&lt; std::endl;\n\ndouble minElement = numcpp::min(arr10);\nstd::cout &lt;&lt; \"Array10 min: \" &lt;&lt; minElement &lt;&lt; std::endl;\n</code></pre><p>在这段代码中，我们分别在第1行、第4行和第7行调用了sum、max、min函数，计算向量中所有元素的和、最大值和最小值。由于这几个函数都是聚合计算，只会返回一个简单的浮点数。</p><p>现在，numcpp的接口已经定义得差不多了。接下来，我们进入numcpp的内部实现细节，这将会涉及到重要的C++ Modules和Concepts的具体应用。</p><h2>Concepts设计</h2><p>根据前面的接口定义，我们先来考虑有哪些Concepts需要被应用到实现部分的代码中，也就是concepts.cpp的编写，这是今天最关键的部分。</p><p>看这里的代码，我定义了所有为该工程服务的通用concept。</p><pre><code class=\"language-c++\">export module numcpp:concepts;\n\nimport &lt;concepts&gt;;\nimport &lt;type_traits&gt;;\n\nnamespace numcpp {\n    // 直接使用type_traits中的is_integral_v进行类型判断\n    template &lt;class T&gt;\n    concept Integral = std::is_integral_v&lt;T&gt;;\n\n    // 直接使用type_traits中的is_floating_v进行类型判断\n    template &lt;class T&gt;\n    concept FloatingPoint = std::is_floating_point_v&lt;T&gt;;\n\n    // 约束表达式为Integral和FloatingPoint的析取式\n    template &lt;class T&gt;\n    concept Number = Integral&lt;T&gt; || FloatingPoint&lt;T&gt;;\n\n    // 预先定义了IteratorMemberFunction这个类型，表示一个返回值为T::iterator，参数列表为空的成员函数\n    template &lt;class T&gt;\n    using IteratorMemberFunction = T::iterator(T::*)();\n\n    // 用IteratorMemberFunction&lt;T&gt;(&amp;T::begin)从T中获取成员函数的函数指针，\n    // 使用decltype获取类型，判断该类型是否为一个成员函数\n    template &lt;class T&gt;\n    concept HasBegin = std::is_member_function_pointer_v&lt;\n        decltype(\n            IteratorMemberFunction&lt;T&gt;(&amp;T::begin)\n            )\n    &gt;;\n\n    // 使用IteratorMemberFunction&lt;T&gt;(&amp;T::end)从T中获取成员函数的函数指针，\n    // 使用decltype获取类型，判断该类型是否为一个成员函数。\n    // 如果类型不包含end成员函数，或者end函数的函数签名不同，都会违反这个约束\n    template &lt;class T&gt;\n    concept HasEnd = std::is_member_function_pointer_v&lt;\n        decltype(\n            IteratorMemberFunction&lt;T&gt;(&amp;T::end)\n            )\n    &gt;;\n\n    // 约束表达式为HasBegin和HasEnd的合取式\n    template &lt;class T&gt;\n    concept IsIterable = HasBegin&lt;T&gt; &amp;&amp; HasEnd&lt;T&gt;;\n\n    // 首先使用IsIterable&lt;T&gt;约束类型必须可遍历，\n    // 再使用Number&lt;typename T::value_type&gt;约束类型的value_type，\n    // 嵌套类型必须符合Number这个概念的约束，\n    // 因此，约束表达式也是一个合取式\n    template &lt;class T&gt;\n    concept IsNumberIterable = IsIterable&lt;T&gt; &amp;&amp; Number&lt;typename T::value_type&gt;;\n\n    // 使用了requires表达式，采用std::common_type_t判断From和To是否有相同的类型，如果存在相同类型返回true，否则返回false\n    template &lt;class From, class To&gt;\n    concept AnyConvertible = requires {\n      typename std::common_type_t&lt;From, To&gt;;\n    }\n}\n</code></pre><p>这段代码不多，但至关重要，演示了如何在工程代码中合适地使用Concepts。我们定义了几个核心concept。</p><ul>\n<li>Integral：约束类型必须为整型。</li>\n<li>FloatingPoint：约束类型必须为浮点型。</li>\n<li>Number：约束类型必须为数字型，接受整型或浮点型的输入。</li>\n<li>HasBegin：约束类型必须存在begin这一成员函数。如果类型不包含begin成员函数，或者begin函数的函数签名不同，都会违反这个约束。</li>\n<li>HasEnd：约束类型必须存在end成员函数。</li>\n<li>IsIterable：约束类型是一个可以遍历的类型。</li>\n<li>IsNumberIterable：约束类型是一个可以遍历的类型，并且其值类型必须为数值类型。</li>\n<li>AnyConvertible：约束两个类型任一方向可以隐式转换。</li>\n</ul><p>好了，现在我们有了接口定义和Concepts定义。准备工作结束，接下来就是根据这些定义来实现具体的功能。我们会涵盖向量模块、构建模块、视图模块和计算模块。这些模块都是C++20标准后定义的标准Modules，让我们先从向量模块的实现开始。</p><p>再说明一下，模块本身的功能不是今天的重点，所以我们只会在涉及到Concepts和C++20及其后续演进标准的部分着重讲解。</p><h2>向量模块</h2><p>向量模块是这个库的主要模块，主要定义了多维数组类型，而这个类型又使用了一些通用类型和通用工具函数，分别定义在types和utils分区中，所以，我们接下来就分别看看这些实现。</p><p>首先，我们在types.cpp中定义了部分基础类型。</p><pre><code class=\"language-c++\">export module numcpp:types;\n\nimport &lt;vector&gt;;\nimport &lt;cstdint&gt;;\nimport &lt;tuple&gt;;\n\nnamespace numcpp {\n&nbsp;&nbsp;&nbsp; export using Shape = std::vector&lt;size_t&gt;;\n\n&nbsp;&nbsp;&nbsp; export class SliceItem {\n&nbsp;&nbsp;&nbsp; public:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SliceItem(): _isPlaceholder(true) {}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SliceItem(int32_t value) : _value(value) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t getValue() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _value;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isPlaceholder() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _isPlaceholder;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::tuple&lt;int32_t, bool&gt; getValidValue(size_t maxSize, bool isStart) const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t signedMaxSize = static_cast&lt;int32_t&gt;(maxSize);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_isPlaceholder) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::make_tuple(isStart ? 0 : signedMaxSize, true);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_value &gt; signedMaxSize) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::make_tuple(signedMaxSize, true);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_value &lt; 0) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t actualValue = maxSize + _value;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::make_tuple(actualValue, actualValue &gt;= 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::make_tuple(_value, true);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; private:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t _value = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool _isPlaceholder = false;\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; export const SliceItem SLICE_PLACEHOLDER;\n}\n</code></pre><p>在这段代码中，第8行定义了Shape类型，该类型是std::vector&lt;size_t&gt;的类型别名，用于描述多维数组每个维度的元素数量，vector的长度也就是多维数组的维度数量。</p><p>接着，我们又定义了SliceItem类型，用于描述视图切片区间的元素，具体功能实现与Python中的类似。</p><p>接着是一个简单的工具utils.cpp的实现。</p><pre><code class=\"language-c++\">export module numcpp:utils;\n\nimport :types;\n\nnamespace numcpp {\n&nbsp;&nbsp;&nbsp; export size_t calcShapeSize(const Shape&amp; shape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!shape.size()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size = 1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t axis : shape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size *= axis;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return size;\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>这个模块非常简单，目前只包含calcShapeSize函数，用于计算一个shape的实际元素总数，其数字为shape中所有维度元素数量之乘积。</p><p>有了基本工具后，我们必须先实现多维数组——这是向量计算的基本单位，并将其放入在array模块分区（源代码在array.cpp中）</p><pre><code class=\"language-c++\">export module numcpp:array;\nimport &lt;cstdint&gt;;\nimport &lt;cstring&gt;;\nimport &lt;vector&gt;;\nimport &lt;memory&gt;;\nimport &lt;algorithm&gt;;\nimport &lt;stdexcept&gt;;\nimport &lt;tuple&gt;;\nimport &lt;array&gt;;\nimport :concepts;\nimport :types;\nimport :array.view;\nimport :utils;\n\nnamespace numcpp {\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType&gt;\n&nbsp;&nbsp;&nbsp; class NDArray {\n&nbsp;&nbsp;&nbsp; public:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using dtype = DType;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDArray(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Shape&amp; shape,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DType* buffer = nullptr,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t offset = 0\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) : _shape(shape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t shapeSize = calcShapeSize(shape);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _data = std::make_shared&lt;DType[]&gt;(shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!buffer) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(_data.get(), buffer + offset, shapeSize * sizeof(DType));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDArray(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Shape&amp; shape,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::vector&lt;DType&gt;&amp; buffer,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t offset = 0\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) : _shape(shape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t shapeSize = calcShapeSize(shape);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _data = std::make_shared&lt;DType[]&gt;(shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!buffer) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (offset &gt;= buffer.size()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t actualCopySize = std::min(buffer.size() - offset, shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(_data.get(), buffer.data() + offset, actualCopySize * sizeof(DType));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDArray(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Shape&amp; shape,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DType initialValue\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) : _shape(shape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t shapeSize = calcShapeSize(shape);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _data = std::make_shared&lt;DType[]&gt;(shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::fill(_data.get(), _data.get() + shapeSize, initialValue);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDArray(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Shape&amp; shape,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType[]&gt; data\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) : _data(data), _shape(shape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Shape&amp; getShape() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _shape;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t getShapeSize() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return calcShapeSize(_shape);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDArray&lt;DType&gt; reshape(const Shape&amp; newShape) const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t originalShapeSize = calcShapeSize(_shape);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t newShapeSize = calcShapeSize(newShape);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (originalShapeSize != newShapeSize) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArray(newShape, _data);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DType&amp; operator[](std::initializer_list&lt;size_t&gt; indexes) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (indexes.size() != _shape.size()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw std::out_of_range(\"Indexes size must equal to shape size of array\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t flattenIndex = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t currentRowSize = 1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto shapeDimIterator = _shape.cend();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto indexIterator = indexes.end();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indexIterator != indexes.begin();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --indexIterator) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentIndex = *(indexIterator - 1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flattenIndex += currentIndex * currentRowSize;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentDimSize = *(shapeDimIterator - 1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRowSize *= currentDimSize;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- shapeDimIterator;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _data.get()[flattenIndex];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DType operator[](std::initializer_list&lt;size_t&gt; indexes) const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (indexes.size() != _shape.size()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw std::out_of_range(\"Indexes size must equal to shape size of array\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t flattenIndex = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t currentRowSize = 1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto shapeDimIterator = _shape.cend();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto indexIterator = indexes.end();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indexIterator != indexes.begin();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --indexIterator) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentIndex = *(indexIterator - 1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flattenIndex += currentIndex * currentRowSize;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentDimSize = *(shapeDimIterator - 1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRowSize *= currentDimSize;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --shapeDimIterator;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _data.get()[flattenIndex];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDArrayView&lt;DType&gt; view(std::tuple&lt;SliceItem, SliceItem&gt; slice) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArrayView&lt;DType&gt;(_data, _shape, { slice });\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDArrayView&lt;DType&gt; view(std::initializer_list&lt;std::tuple&lt;SliceItem, SliceItem&gt;&gt; slices) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArrayView&lt;DType&gt;(_data, _shape, slices);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDArrayView&lt;DType&gt; view(std::initializer_list&lt;std::tuple&lt;SliceItem, SliceItem&gt;&gt; slices) const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArrayView&lt;DType&gt;(_data, _shape, slices);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::shared_ptr&lt;DType[]&gt;&amp; getData() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _data;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType[]&gt;&amp; getData() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _data;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDArray&lt;DType&gt; clone() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t shapeSize = calcShapeSize(_shape);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType[]&gt; newData = std::make_shared&lt;DType[]&gt;(shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(newData.get(), _data.get(), shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArray&lt;DType&gt;(_shape, newData);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; private:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType[]&gt; _data;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape _shape;\n&nbsp;&nbsp;&nbsp; };\n}\n</code></pre><p>从这段代码开始，开始使用前面定义的concept，我们重点看。</p><p>第16行，定义了NDArray类型。这个类型是一个类模板，<strong>模板参数DType使用了名为Number的concept</strong>。NDArray包含两个属性。</p><ul>\n<li>_data，其类型为shared_ptr智能指针，通过引用计数来避免执行多维数组之间的拷贝，几乎没有性能损耗。如果真的想要复制一份新的数据，需要调用一百四十行的clone成员函数生成一个真正的拷贝。</li>\n<li>_shape，其类型为我们在之前定义的Shape，用于描述多维数组每个维度的元素数量。</li>\n</ul><p>第148行，我们定义了一个类型为DType[]的智能指针，这是从C++20开始支持的一个新特性。<br>\n<img src=\"https://static001.geekbang.org/resource/image/af/4c/af8fa87c42a4bef0ca38c2bd527dcd4c.jpg?wh=1980x948\" alt=\"\"></p><h2>构建模块</h2><p>实现了向量模块之后，我们来看构建模块的具体实现。</p><p>构建模块实现在:creation分区中，creation.cpp中的代码如下所示。</p><pre><code class=\"language-c++\">export module numcpp:creation;\nimport :array;\nimport :concepts;\n\nimport &lt;cstring&gt;;\nimport &lt;memory&gt;;\n\nnamespace numcpp {\n    // 使用了名为IsNumberIterable的concept，用于获取不包含子数组的数组的元素数量\n&nbsp;&nbsp;&nbsp; export template &lt;IsNumberIterable ContainerType&gt;\n&nbsp;&nbsp;&nbsp; void makeContainerShape(Shape&amp; shape, const ContainerType&amp; container) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shape.push_back(container.size());\n&nbsp;&nbsp;&nbsp; }\n\n    // 使用了名为IsIterable的concept，用于获取不满足IsNumberIterable约束的数组的元素数量，并递归调用makeContainerShape函数获取该数组的第一个子数组的长度，直到容器不包含子数组为止\n&nbsp;&nbsp;&nbsp; export template &lt;IsIterable ContainerType&gt;\n&nbsp;&nbsp;&nbsp; void makeContainerShape(Shape&amp; shape, const ContainerType&amp; container) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shape.push_back(container.size());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeContainerShape(shape, *(container.begin()));\n&nbsp;&nbsp;&nbsp; }\n\n    /*\n     * 用于帮助调用者获取一个多维容器类型的实际元素类型\n     * 该结构体定义也是一个递归定义\n     */\n    \n    // 如果第34行或第40行都不匹配，编译器会选用这一默认版本\n&nbsp;&nbsp;&nbsp; export template &lt;typename&gt;\n&nbsp;&nbsp;&nbsp; struct ContainerValueTypeHelper {\n&nbsp;&nbsp;&nbsp; };\n\n    // 当模板参数类型符合IsNumberIterable这一concept的时候会选用这一版本\n&nbsp;&nbsp;&nbsp; export template &lt;IsNumberIterable ContainerType&gt;\n&nbsp;&nbsp;&nbsp; struct ContainerValueTypeHelper&lt;ContainerType&gt; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using ValueType = ContainerType::value_type;\n&nbsp;&nbsp;&nbsp; };\n\n    // 当模板参数类型符合IsIterable这一concept的时候会选用这一版本\n&nbsp;&nbsp;&nbsp; export template &lt;IsIterable ContainerType&gt;\n&nbsp;&nbsp;&nbsp; struct ContainerValueTypeHelper&lt;ContainerType&gt; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using ValueType = ContainerValueTypeHelper&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typename ContainerType::value_type\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;::ValueType;\n&nbsp;&nbsp;&nbsp; };\n\n\n    /*\n     * fillContainerBuffer成员函数\n     * 该成员函数有两个重载版本，\n     * 负责将多维容器中的数据拷贝到多维数组对象的数据缓冲区中\n     */\n     \n    // 通过IsNumberIterable这一concept来约束调用该版本的参数必须是元素类型为Number的可迭代容器，用于处理一维容器\n&nbsp;&nbsp;&nbsp; export template &lt;IsNumberIterable ContainerType&gt;\n&nbsp;&nbsp;&nbsp; typename ContainerType::value_type* fillContainerBuffer(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typename ContainerType::value_type* dataBuffer,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ContainerType&amp; container\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using DType = ContainerType::value_type;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DType* nextDataBuffer = dataBuffer;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto it = container.begin();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it != container.end();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++it) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *nextDataBuffer = *it;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++nextDataBuffer;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextDataBuffer;\n&nbsp;&nbsp;&nbsp; }\n\n    // 通过IsIterable这一concept来约束调用该版本的参数必须是可迭代容器\n    // 由于存在IsNumberIterable的版本，因此如果容器元素类型为Number，则不会匹配该版本\n&nbsp;&nbsp;&nbsp; export template &lt;IsIterable ContainerType&gt;\n&nbsp;&nbsp;&nbsp; typename ContainerValueTypeHelper&lt;ContainerType&gt;::ValueType* fillContainerBuffer(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typename ContainerValueTypeHelper&lt;ContainerType&gt;::ValueType* dataBuffer,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ContainerType&amp; container\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using DType = ContainerValueTypeHelper&lt;ContainerType&gt;::ValueType;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DType* nextDataBuffer = dataBuffer;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; element : container) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextDataBuffer = fillContainerBuffer(nextDataBuffer, element);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nextDataBuffer;\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; export template &lt;IsIterable ContainerType&gt;\n&nbsp;&nbsp;&nbsp; NDArray&lt;typename ContainerValueTypeHelper&lt;ContainerType&gt;::ValueType&gt; array(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ContainerType&amp; container\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape shape;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeContainerShape(shape, container);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t shapeSize = calcShapeSize(shape);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using DType = ContainerValueTypeHelper&lt;ContainerType&gt;::ValueType;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto dataBuffer = std::make_shared&lt;DType[]&gt;(shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fillContainerBuffer(dataBuffer.get(), container);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArray&lt;DType&gt;(shape, dataBuffer);\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType&gt;\n&nbsp;&nbsp;&nbsp; NDArray&lt;DType&gt; array(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::initializer_list&lt;DType&gt;&amp; container\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape shape;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeContainerShape(shape, container);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t shapeSize = calcShapeSize(shape);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using ContainerType = std::initializer_list&lt;DType&gt;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto dataBuffer = std::make_shared&lt;DType[]&gt;(shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fillContainerBuffer(dataBuffer.get(), container);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArray&lt;DType&gt;(shape, dataBuffer.get());\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType&gt;\n&nbsp;&nbsp;&nbsp; NDArray&lt;DType&gt; zeros(const Shape&amp; shape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArray&lt;DType&gt;(shape, 0);\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType&gt;\n&nbsp;&nbsp;&nbsp; NDArray&lt;DType&gt; ones(const Shape&amp; shape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArray&lt;DType&gt;(shape, 1);\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>这段代码中，你可以重点关注第17行，我们利用了模板约束的偏序特性，实现了一个递归的makeContainerShape函数，并定义了函数的终止条件。这也是C++模板元编程中递归函数的常见实现方式。只不过，相比传统的SAFINE方式，concept为我们提供了更清晰简洁的实现方式。</p><h2>视图模块</h2><p>构建模块实现完后，我们来看视图模块的具体实现。</p><p>对于一个向量计算库来说，很多时候都需要从多维数组中进行灵活地切片，并生成多维数组的视图。这个时候，就需要数组视图的功能，这里我们在array_view.cpp中实现了array.view模块，代码如下所示。</p><pre><code class=\"language-c++\">export module numcpp:array.view;\n\nimport &lt;memory&gt;;\nimport &lt;stdexcept&gt;;\nimport &lt;iostream&gt;;\nimport &lt;algorithm&gt;;\nimport :concepts;\nimport :types;\n\nnamespace numcpp {\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType&gt;\n&nbsp;&nbsp;&nbsp; class NDArrayView {\n&nbsp;&nbsp;&nbsp; public:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDArrayView(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType[]&gt; data,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape originalShape,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;std::tuple&lt;SliceItem, SliceItem&gt;&gt; slices\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) : _data(data), _originalShape(originalShape), _slices(slices) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;generateShape();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType[]&gt; getData() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _data;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DType&amp; operator[](std::initializer_list&lt;size_t&gt; indexes) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (indexes.size() != _shape.size()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw std::out_of_range(\"Indexes size must equal to shape size of array\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t flattenIndex = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t currentRowSize = 1;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto shapeDimIterator = _shape.cend();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto originalShapeDimIterator = _originalShape.cend();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto indexIterator = indexes.end();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indexIterator != indexes.begin();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --indexIterator) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentIndex = *(indexIterator - 1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentDimOffset = *(originalShapeDimIterator - 1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flattenIndex += (currentDimOffset + currentIndex) * currentRowSize;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto currentDimSize = *(shapeDimIterator - 1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRowSize *= currentDimSize;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --shapeDimIterator;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _data.get()[flattenIndex];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isValid() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _isValid;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Shape&amp; getShape() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _shape;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; private:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void generateShape() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _isValid = true;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _shape.clear();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _starts.clear();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto originalShapeDimIterator = _originalShape.begin();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const std::tuple&lt;SliceItem, SliceItem&gt;&amp; slice : _slices) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto originalShapeDim = *originalShapeDimIterator;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SliceItem start = std::get&lt;0&gt;(slice);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SliceItem end = std::get&lt;1&gt;(slice);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto [actualStart, startValid ] = start.getValidValue(originalShapeDim, true);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto [actualEnd, endValid] = end.getValidValue(originalShapeDim, false);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((!startValid &amp;&amp; !endValid) ||\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; actualStart &gt; actualEnd\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _isValid = false;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (actualStart &lt; 0) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; actualStart = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _shape.push_back(static_cast&lt;size_t&gt;(actualEnd - actualStart));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _starts.push_back(static_cast&lt;size_t&gt;(actualStart));\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++originalShapeDimIterator;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; private:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType[]&gt; _data;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape _originalShape;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;std::tuple&lt;SliceItem, SliceItem&gt;&gt; _slices;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape _shape;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;size_t&gt; _starts;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool _isValid = false;\n&nbsp;&nbsp;&nbsp; };\n}\n</code></pre><p>这段代码没有使用concept，但使用了Modules，理解它对理解视图很有帮助，因此我们简单看下。</p><p>类成员函数_data和_originalShape分别来源于原数组的数据指针和Shape，这样在原数组的数据发生变化时，视图依然可以引用相关数据，毕竟视图的本质就是数组的引用，所以存储数据的引用也是合情合理的。_slices用于生成该视图的切片数据。_shape、_starts是根据多维数组原始shape和切片综合计算得到的新视图的shape，以及视图相对于原数组在各个维度上的起始索引。</p><h2>计算模块</h2><p>了解了向量模块、构建模块和视图模块的实现，我们最后讲解一下计算模块。</p><p>计算模块中主要实现了各类算法，算法分为基础算法、聚合算法和通用算法，模块的接口代码实现在algorithm/algorithm.cpp，主要导入并重新导出了所有的子模块。因此，我们有了如下所示的模块设计。</p><pre><code class=\"language-c++\">export module numcpp:algorithm;\n\nexport import :algorithm.basic;\nexport import :algorithm.aggregate;\nexport import :algorithm.universal;\n</code></pre><h4>基础计算</h4><p>首先，我们看一下基础算法的实现，基础算法的实现在algorithm/basic.cpp中。后面是具体代码。</p><pre><code class=\"language-c++\">export module numcpp:algorithm.basic;\n\nimport &lt;memory&gt;;\nimport &lt;stdexcept&gt;;\nimport &lt;type_traits&gt;;\n\nimport :types;\nimport :concepts;\nimport :array;\nimport :utils;\n\nnamespace numcpp {\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType1, Number DType2&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (AnyConvertible&lt;DType1, DType2&gt;)\n&nbsp;&nbsp;&nbsp; NDArray&lt;std::common_type_t&lt;DType1, DType2&gt;&gt; operator+(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const NDArray&lt;DType1&gt;&amp; lhs,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const NDArray&lt;DType2&gt;&amp; rhs\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using ResultDType = std::common_type_t&lt;DType1, DType2&gt;;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType1[]&gt; lhsData = lhs.getData();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape lhsShape = lhs.getShape();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType2[]&gt; rhsData = rhs.getData();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape rhsShape = rhs.getShape();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lhsShape != rhsShape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw std::invalid_argument(\"Lhs and rhs of operator+ must have the same shape\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t shapeSize = calcShapeSize(lhsShape);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ResultDType[]&gt; resultData = std::make_shared&lt;ResultDType[]&gt;(shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultDType* resultDataPtr = resultData.get();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DType1* lhsDataPtr = lhsData.get();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DType2* rhsDataPtr = rhsData.get();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t datumIndex = 0; datumIndex != shapeSize; ++datumIndex) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultDataPtr[datumIndex] = lhsDataPtr[datumIndex] + rhsDataPtr[datumIndex];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArray(lhsShape, resultData);\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType1, Number DType2&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (AnyConvertible&lt;DType1, DType2&gt;)\n&nbsp;&nbsp;&nbsp; NDArray&lt;std::common_type_t&lt;DType1, DType2&gt;&gt; operator-(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const NDArray&lt;DType1&gt;&amp; lhs,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const NDArray&lt;DType2&gt;&amp; rhs\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using ResultDType = std::common_type_t&lt;DType1, DType2&gt;;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType1[]&gt; lhsData = lhs.getData();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape lhsShape = lhs.getShape();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType2[]&gt; rhsData = rhs.getData();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape rhsShape = rhs.getShape();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lhsShape != rhsShape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw std::invalid_argument(\"Lhs and rhs of operator+ must have the same shape\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t shapeSize = calcShapeSize(lhsShape);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ResultDType[]&gt; resultData = std::make_shared&lt;ResultDType[]&gt;(shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultDType* resultDataPtr = resultData.get();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DType1* lhsDataPtr = lhsData.get();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DType2* rhsDataPtr = rhsData.get();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t datumIndex = 0; datumIndex != shapeSize; ++datumIndex) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultDataPtr[datumIndex] = lhsDataPtr[datumIndex] - rhsDataPtr[datumIndex];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArray(lhsShape, resultData);\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>我们在代码中实现了向量加法和向量减法。仔细观察两个函数的声明，你会发现，我们除了在模板参数列表中使用Number来限定T1和T2的基本类型，<strong>还在参数列表后使用了requires子句</strong>——要求T1和T2必须是可以相互转换的数值类型，才能进行算术运算。</p><h4>聚合计算</h4><p>接下来，我们来看一下聚合算法的实现，聚合算法实现在algorithm/aggreagte.cpp中。该模块实现了sum和max函数，分别用于求一个向量中所有元素的和，以及一个向量中所有元素的最大值。</p><p>由于并不涉及有关concept的代码逻辑，为了让你聚焦主线，代码实现部分我们省略一下，这部分你可以参考完整的项目代码。</p><h4>通用函数</h4><p>通用函数是为用户对向量执行计算提供一个计算框架。在基础计算和聚合计算中我们看到了两类通用的计算需求。</p><p>1.基础计算中对两个向量的元素逐个计算转换，生成新的计算结果并生成新的向量，新向量的shape和输入向量是保持一致的，我们将这种计算需求称之为binaryMap（二元映射）。</p><p>2.聚合计算中对一个向量中的元素逐个计算，处理各个元素的时候还需要考虑前面几个元素的处理结果，最后返回聚合计算的结果，这种计算需求我们称之为reduce。</p><p>对这两个通用函数的实现在algorithms/universal.cpp中。</p><pre><code class=\"language-c++\">export module numcpp:algorithm.universal;\n\nimport &lt;functional&gt;;\nimport &lt;numeric&gt;;\nimport :types;\nimport :concepts;\nimport :array;\nimport :utils;\n\nnamespace numcpp {\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType&gt;\n&nbsp;&nbsp;&nbsp; using ReduceOp = std::function&lt;DType(DType current, DType prev)&gt;;\n\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType&gt;\n&nbsp;&nbsp;&nbsp; DType reduce(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const NDArray&lt;DType&gt;&amp; ndarray,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReduceOp&lt;DType&gt; op,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DType init = static_cast&lt;DType&gt;(0)\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using ResultDType = DType;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType[]&gt; data = ndarray.getData();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape shape = ndarray.getShape();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DType* dataPtr = data.get();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t shapeSize = calcShapeSize(shape);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::reduce(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataPtr,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataPtr + shapeSize,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; op\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType1, Number DType2&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (AnyConvertible&lt;DType1, DType2&gt;)\n&nbsp;&nbsp;&nbsp; using BinaryMapOp = std::function&lt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::common_type_t&lt;DType1, DType2&gt;(DType1 current, DType2 prev)\n&nbsp;&nbsp;&nbsp; &gt;;\n\n&nbsp;&nbsp;&nbsp; export template &lt;Number DType1, Number DType2&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires (AnyConvertible&lt;DType1, DType2&gt;)\n&nbsp;&nbsp;&nbsp; NDArray&lt;std::common_type_t&lt;DType1, DType2&gt;&gt; binaryMap(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const NDArray&lt;DType1&gt;&amp; lhs,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const NDArray&lt;DType2&gt;&amp; rhs,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BinaryMapOp&lt;DType1, DType2&gt; op\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using ResultDType = std::common_type_t&lt;DType1, DType2&gt;;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType1[]&gt; lhsData = lhs.getData();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape lhsShape = lhs.getShape();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;DType2[]&gt; rhsData = rhs.getData();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape rhsShape = rhs.getShape();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lhsShape != rhsShape) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw std::invalid_argument(\"Lhs and rhs of operator+ must have the same shape\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t shapeSize = calcShapeSize(lhsShape);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr&lt;ResultDType[]&gt; resultData = std::make_shared&lt;ResultDType[]&gt;(shapeSize);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultDType* resultDataPtr = resultData.get();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DType1* lhsDataPtr = lhsData.get();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DType2* rhsDataPtr = rhsData.get();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t datumIndex = 0; datumIndex != shapeSize; ++datumIndex) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultDataPtr[datumIndex] = op(lhsDataPtr[datumIndex], rhsDataPtr[datumIndex]);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NDArray(lhsShape, resultData);\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>在这段代码中，第36行定义了BinaryMap操作所需的函数类型，BinaryMap函数需要的是两个序列相同位置的两个元素，并计算返回一个数值。在这里，我们<strong>通过requires (AnyConvertible&lt;DType1, DType2&gt;)这一约束表达式</strong>进行约束。</p><p>第42行定义了binaryMap函数。这个函数的内部实现和基础计算模块中的加法减法是一样的，只不过最后加减法改成了调用op而已。这里我们用跟第36行一样的约束表达式对函数进行约束。</p><h2>深入理解Concepts</h2><p>好的concept设计可以从根本上，解决C++泛型编程中缺乏好的接口定义的问题。因此，在学习了实际工程中设计和使用了Concepts的方法后，我们有必要探讨一下，什么才是好的concept设计？</p><p>对比有助于我们加深理解，先看看我们所熟悉的面向对象编程的情况。在类的设计中，我们经常会提到三个基本特性：封装、继承与多态。在C++中使用面向对象的思想设计类时，需要考虑如何通过组合或继承的方式来提升类的复用性，同时通过继承和函数重载实现面向对象的“多态”特性。</p><p>而这些问题和思想在Concepts和泛型编程中也同样存在。</p><p>首先，我们需要考虑<strong>通过组合来提升concept的复用性</strong>。在这一讲中，我们先定义了Integral和FloatingPoint这两个基本concept，然后通过组合定义了Number这一concept。</p><p>作为类比，考虑面向对象的思路设计类时，我们可能也会先设计一个Number类，然后设计继承Number类的Integral和FloatingPoint类。也就是说，在面向对象思想中，公有继承包含了is-a这个隐喻。</p><p>那么在泛型编程的concept组合中，我们不也包含了is-a的隐喻？只不过是倒过来的，Integral is a Number, FloatingPoint is a Number，同理于IsNumberIterable和IsIterable。所以，组合与继承并非面向对象的“专利”——我们可以在泛型编程中，使用组合与继承来实现面向模板的类型，也就是Concepts。</p><p>其次，concept的设计也使得泛型编程能够<strong>更好地具备“多态”的特性</strong>。</p><p>作为类比，考虑面向对象的思路设计类时，对一个Integral的print函数和一个Number类的print函数，我们可以通过继承与覆盖（C++中的虚函数）实现“多态”。</p><p>这一讲中，我们定义creation模块时用到的fillContainerBuffer、makeContainerShape和ContainerValueTypeHelper这些约束表达式，就利用了concept的“原子约束”特性选择不同的模版版本，实现了泛型编程中的“多态”特性。<br>\n<img src=\"https://static001.geekbang.org/resource/image/e8/15/e81a3021370c10d9f7b423df7a4d4d15.jpg?wh=1900x1084\" alt=\"\"></p><p>到这里，我们应该就可以理解，为什么说Concepts与约束是C++20以及后续演进标准之后，实现泛型编程的复用和“多态”特性的重要基石了。</p><p>此外，Concepts还<strong>给模板元编程带来了巨大提升</strong>。</p><p>模板元编程已经成为现代C++不可或缺的一部分，因此学习和掌握模板元编程的基本概念变得越来越重要。模板元编程的本质就是<strong>以C++模板为语言，以编译期常量表达式为计算定义，以编译期常量（包括普通常量与类型的编译期元数据）为数据，最终实现在编译时完成所有的运算（包括类型运算与数值运算）</strong>。<br>\n<img src=\"https://static001.geekbang.org/resource/image/82/52/827d700282e89caede7be6bb35beb152.jpg?wh=2742x898\" alt=\"\"></p><p>虽然C++11提供了很多模板元编程的基础设施，但缺乏一种标准的抽象手段来描述模板参数的约束，这也使得模板元编程中，各个模板之间缺乏描述调用关系的简单手段。尤其是递归计算的定义令人更加头痛。</p><p>对于代码中的ContainerValueTypeHelper的实现来说，在使用concept后，代码更加简洁易懂，这就是concept为模板元编程带来的重要提升。</p><p>我们知道，SFINAE是自模板技术诞生以来就存在的一个规则。该规则让开发者可以通过一些方式，让编译器根据模板参数类型，选择合适的模板函数与模板类。但是，在C++11标准中加入了type_traits后，我们就可以在模板中通过标准库获取静态元数据，并决定模板类与函数的匹配与调用路径。</p><p>不过，这种在模板参数或函数参数列表中填充type_traits的方式，会让开发者的代码变得难以维护，而且用户更是难以阅读调用时的错误消息，这让type_traitis冲突时的偏序规则难以捉摸。而Concepts与约束的提出，正好完美地解决了这些问题。由此，C++20就成了继C++11后让模板元编程脱胎换骨的一个标准。</p><h2>总结</h2><p>在C++20及其后续演进标准中，提供了使用编译期常量表达式编写模板参数约束的能力，并通过Concepts提供了为约束表达式起名的能力。</p><p>设计Concepts是一件非常重要的事情。我们通过实战案例展示了如何利用concept这一核心语言特性变更，实现了编译时模板匹配和版本选择时的SFINAE原则，并通过“原子约束”的特性实现了根据不同的约束选择不同的模板版本。</p><p>通过这三讲的内容相信你也感受到了，我们在现代C++时代绕不开泛型编程。掌握C++模板元编程的基础知识，并将这些新特性应用到编写的代码中来改善编程体验和编译性能，对一名C++开发者来说至关重要。</p><h2>课后思考</h2><p>从我们已经讲解的现代C++特性中可以了解到，所有特性都是为C++编译时计算提供服务的，这也再次印证了C++设计哲学——“不为任何抽象付出不可接受的多余运行时性能损耗”。事实上，编译时计算变得越来越重要了。那么，根据经验来说，你觉得哪些代码或功能可以开始向编译时计算开始迁移？</p><p>不妨在这里分享你的见解，我们一同交流。下一讲见！</p>","neighbors":{"left":{"article_title":"05｜Concepts：解决模板接口的类型与约束定义难题","id":624435},"right":{"article_title":"07｜Coroutines背景：异步I/O的复杂性","id":624911}},"comments":[{"had_liked":false,"id":367197,"user_name":"黄骏","can_delete":false,"product_type":"c1","uid":1849733,"ip_address":"湖北","ucode":"3C41D02F4F712C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/39/85/c6110f83.jpg","comment_is_top":false,"comment_ctime":1675006541,"is_pvip":false,"replies":[{"id":133866,"content":"是的，应该把begin换成end。\n已进行修正。 🥰","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1675349726,"ip_address":"江苏","comment_id":367197,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"内容太干了。哈哈。\nnits：concepts.cpp的line 38应该是IteratorMemberFunction(&amp;T::end)吧？","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601692,"discussion_content":"是的，应该把begin换成end。\n已进行修正。 🥰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675349727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380953,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"广东","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1694504342,"is_pvip":false,"replies":[{"id":138835,"content":"就目前来说，编译器对 modules 的支持还非常非常初级，以至于很多标准都没有能实现。但是总的来说，modules 作为诸多现代语言的特性，在C++中也能彻底解决符号隔离问题，而且对产品分发来说也大有益处。\n\n当然，这都需要建立在编译器对 modules 的完善支持的基础上，就目前来说，还不行。需要等待C++23、C++26的推出，以及主流编译器跟进的速度，如clang、gcc和 VC。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1694708074,"ip_address":"上海","comment_id":380953,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"我觉得concepts确实比modules有用多了。。。前者能改变编程思想，后者在我看来只是换汤不换药的语法糖，反而让语法看起来更复杂","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627970,"discussion_content":"就目前来说，编译器对 modules 的支持还非常非常初级，以至于很多标准都没有能实现。但是总的来说，modules 作为诸多现代语言的特性，在C++中也能彻底解决符号隔离问题，而且对产品分发来说也大有益处。\n\n当然，这都需要建立在编译器对 modules 的完善支持的基础上，就目前来说，还不行。需要等待C++23、C++26的推出，以及主流编译器跟进的速度，如clang、gcc和 VC。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694708074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379569,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"北京","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1692111740,"is_pvip":false,"replies":[{"id":138291,"content":"多态也就是针对不同的输入类型提供统一的接口。\nConcepts正给我们提供了这种能力，而且更细粒度地为不同的类型提供不同的实现。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1692276267,"ip_address":"上海","comment_id":379569,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"定义 creation 模块时用到的 fillContainerBuffer、makeContainerShape 和 ContainerValueTypeHelper 这些约束表达式，就利用了 concept 的“原子约束”特性选择不同的模版版本，实现了泛型编程中的“多态”特性。\n\n没看懂哪里体现了泛型编程的多态","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625878,"discussion_content":"多态也就是针对不同的输入类型提供统一的接口。\nConcepts正给我们提供了这种能力，而且更细粒度地为不同的类型提供不同的实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692276267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367299,"user_name":"Geek_7c0961","can_delete":false,"product_type":"c1","uid":2277181,"ip_address":"美国","ucode":"B1482E64FF9E4E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8aLz0tWdsZuMiaNUAd0dicSD9M6A77seMGFdHgvsQwOzN8ztYPiaJSo53DcbjQWUQpw4pf4rI2f7vg/132","comment_is_top":false,"comment_ctime":1675126411,"is_pvip":true,"replies":[{"id":133867,"content":"Concepts的确是非常重要的feature，让C++编译时静态化编码整体提升了一个档次。现代C++演进有一种“Rust化”的趋势，当然了，C++还是有着独特的气质，而且对向前兼容性方面几乎是无敌的。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1675349783,"ip_address":"江苏","comment_id":367299,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"concepts 这个feature太强了, 让我想起了rust中的traits 和 traits objects.","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601693,"discussion_content":"Concepts的确是非常重要的feature，让C++编译时静态化编码整体提升了一个档次。现代C++演进有一种“Rust化”的趋势，当然了，C++还是有着独特的气质，而且对向前兼容性方面几乎是无敌的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675349783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366989,"user_name":"Geek_e04349","can_delete":false,"product_type":"c1","uid":1683630,"ip_address":"云南","ucode":"8615FE30736130","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqDjaVmMr3nEFicazTso4spiae7icg4WjHTb8E2Y3n71PaGiaPqmCU3JsasmpAXB6dcIoXwy8LTn1aADQ/132","comment_is_top":false,"comment_ctime":1674773978,"is_pvip":true,"replies":[{"id":133865,"content":"这里的确是可以使用std::optional。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1675349696,"ip_address":"江苏","comment_id":366989,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"感觉 SliceItem 的 getValidValue 使用 optional 返回会更符合其语义","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601691,"discussion_content":"这里的确是可以使用std::optional。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675349696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}