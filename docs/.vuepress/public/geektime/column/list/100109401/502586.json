{"id":502586,"title":"15｜DI Container（3）：如何重构已有的代码？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式来实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code>package geektime.tdd.di;\n\nimport jakarta.inject.Inject;\nimport jakarta.inject.Provider;\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n \nimport static java.util.Arrays.stream;\npublic class Context {\n    private Map&lt;Class&lt;?&gt;, Provider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n    \n    public &lt;Type&gt; void bind(Class&lt;Type&gt; type, Type instance) {\n        providers.put(type, (Provider&lt;Type&gt;) () -&gt; instance);\n    }\n    \n    public &lt;Type, Implementation extends Type&gt;\n    void bind(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation) {\n        Constructor&lt;?&gt;[] injectConstructors = stream(implementation.getConstructors()).filter(c -&gt; c.isAnnotationPresent(Inject.class))\n                .toArray(Constructor&lt;?&gt;[]::new);\n        if (injectConstructors.length &gt; 1) throw new IllegalComponentException();\n        if (injectConstructors.length == 0 &amp;&amp; stream(implementation.getConstructors())\n                .filter(c -&gt; c.getParameters().length == 0).findFirst().map(c -&gt; false).orElse(true))\n            throw new IllegalComponentException();\n        providers.put(type, (Provider&lt;Type&gt;) () -&gt; {\n            try {\n                Constructor&lt;Implementation&gt; injectConstructor = getInjectConstructor(implementation);\n                Object[] dependencies = stream(injectConstructor.getParameters())\n                        .map(p -&gt; get(p.getType()))\n                        .toArray(Object[]::new);\n                return injectConstructor.newInstance(dependencies);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n    \n    private &lt;Type&gt; Constructor&lt;Type&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n        return (Constructor&lt;Type&gt;) stream(implementation.getConstructors())\n                .filter(c -&gt; c.isAnnotationPresent(Inject.class)).findFirst().orElseGet(() -&gt; {\n                    try {\n                        return implementation.getConstructor();\n                    } catch (NoSuchMethodException e) {\n                        throw new RuntimeException(e);\n                    }\n                });\n    }\n    \n    public &lt;Type&gt; Type get(Class&lt;Type&gt; type) {\n        return (Type) providers.get(type).get();\n    }\n}\n</code></pre><p>任务列表状态为：</p><ul>\n<li>\n<p><s>无需构造的组件——组件实例</s></p>\n</li>\n<li>\n<p>如果注册的组件不可实例化，则抛出异常</p>\n<ul>\n<li>抽象类</li>\n<li>接口</li>\n</ul>\n</li>\n<li>\n<p>构造函数注入</p>\n<ul>\n<li><s>无依赖的组件应该通过默认构造函数生成组件实例</s></li>\n<li><s>有依赖的组件，通过Inject标注的构造函数生成组件实例</s></li>\n<li><s>如果所依赖的组件也存在依赖，那么需要对所依赖的组件也完成依赖注入</s></li>\n<li><s>如果组件有多于一个Inject标注的构造函数，则抛出异常</s></li>\n<li><s>如果组件没有Inject标注的构造函数，也没有默认构造函数（新增任务）</s></li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>字段注入</p>\n<ul>\n<li>通过Inject标注将字段声明为依赖组件</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果字段为final则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>方法注入</p>\n<ul>\n<li>通过Inject标注的方法，其参数为依赖组件</li>\n<li>通过Inject标注的无参数方法，会被调用</li>\n<li>按照子类中的规则，覆盖父类中的Inject方法</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果方法定义类型参数，则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>对Provider类型的依赖</p>\n<ul>\n<li>注入构造函数中可以声明对于Provider的依赖</li>\n<li>注入字段中可以声明对于Provider的依赖</li>\n<li>注入方法中可声明对于Provider的依赖</li>\n</ul>\n</li>\n<li>\n<p>自定义Qualifier的依赖</p>\n<ul>\n<li>注册组件时，可额外指定Qualifier</li>\n<li>注册组件时，可从类对象上提取Qualifier</li>\n<li>寻找依赖时，需同时满足类型与自定义Qualifier标注</li>\n<li>支持默认Qualifier——Named</li>\n</ul>\n</li>\n<li>\n<p>Singleton生命周期</p>\n<ul>\n<li>注册组件时，可额外指定是否为Singleton</li>\n<li>注册组件时，可从类对象上提取Singleton标注</li>\n<li>对于包含Singleton标注的组件，在容器范围内提供唯一实例</li>\n<li>容器组件默认不是Single生命周期</li>\n</ul>\n</li>\n<li>\n<p>自定义Scope标注</p>\n<ul>\n<li>可向容器注册自定义Scope标注的回调</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><h2>视频演示</h2><p>让我们进入今天的部分：</p><p><video poster=\"https://media001.geekbang.org/a10578303c9c407089a65d9dac2774bd/snapshots/dddba613ac254022880642204c2ce806-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/2d5c01f-1801774d135-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/aff9887d76224d15a577771ceb36415d/ca57439af4a44f7c9b3fe8970e88e1b3-e2d94f42f820fbec156b6434aa48cf07-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p><video poster=\"https://media001.geekbang.org/acc1c91ea132441596a3381a4faf871e/snapshots/0fee02cd3d024dda8b65af9d8ad29564-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/31b7c07a-18017749d49-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/f8174a17263048958686eebc866e92b4/8650c818ae544a17af83d939b0c86162-bbe96b61fe114121aefc9c19387f8a1e-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p><video poster=\"https://media001.geekbang.org/0079c1cd8a6e4081bac10112759c7bf9/snapshots/6ef3003295b04a5d9f9dc6a836266dc1-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/8c5abb0-18017749839-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/dbea76af85594e47af8f49d774ddf4c2/2761bb9bb4794413b95c20ba8c0d18fc-1f29eae105e954aecadec337218a4b0c-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>如何实现循环依赖的检测？</p><p>欢迎把你的思考和想法分享在留言区，也欢迎你扫描详情页的二维码加入读者交流群。我们下节课再见！</p>","neighbors":{"left":{"article_title":"14｜DI Container（2）：如何通过Sad Path为容器增加功能？","id":502584},"right":{"article_title":"16｜DI Container（4）：如何实现对循环依赖的处理？","id":508841}},"comments":[{"had_liked":false,"id":358210,"user_name":"小5","can_delete":false,"product_type":"c1","uid":1074736,"ip_address":"广东","ucode":"F99936F37D04E4","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/30/ce2cc535.jpg","comment_is_top":true,"comment_ctime":1664041722,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"学习了这节课的内容，想到了之前章节的一段话：\n\nKent Beck 作为极限编程（Exetreme Programming）的创始人，将勇气（Courage）作为极限编程的第一原则，提出编程的第一大敌是恐惧（Fear），实在是有非凡的洞见。同时，他也花了极大的篇幅，说明为什么 TDD 可以让我们免于恐惧：重构使得我们在实现功能时，不恐惧于烂代码；测试使得我们在重构时，不恐惧于功能破坏。\n\n我们平时常说：代码看不懂、改不动、不敢改。\n看不懂是指认知负载太高，导致代码很难改，改了一个地方影响很多地方，甚至不知道影响多少地方，也就自然不敢改了，改出问题了谁负责，改一个bug改出多了几个新bug，以前公司老人常说千万不要在现有的代码上改，要把方法copy一份，然后再改，调用新的方法😂，多么痛的领悟。\n\n在做练习的重构过程中明白了因为对所有的代码都有测试，改了代码跑一下如果有错误就很容易发现，所以给了我们改代码的勇气。","like_count":4},{"had_liked":false,"id":343866,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":true,"comment_ctime":1651105429,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"进入到第二阶段的课程之后，给出的代码相对比较详细，虽然实现的功能比起前面要复杂一些，但是跟上节奏就不那么困难了。\n\n这个专栏的门槛还是挺高的。\n\n实现循环依赖检测，比较容易想到的就是在每个依赖添加一个标志位，但是这个似乎不那么容易实现；那么另一个方式，就是增加一个记录依赖的列表，每次都去判断是否存在循环依赖。\n\n代码不太会写，只能先想一下。\n\n本课的代码链接：https:&#47;&#47;github.com&#47;escray&#47;TDDCourse&#47;tree&#47;ch15","like_count":4},{"had_liked":false,"id":343468,"user_name":"汗香","can_delete":false,"product_type":"c1","uid":1807921,"ip_address":"","ucode":"8F2C8A595F888A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/31/91cc9c3c.jpg","comment_is_top":false,"comment_ctime":1650864145,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"获取一个依赖前，先从已有依赖获取，\n    若获取结果不为空则获取成功，\n    若获取结果为空，先将被获取依赖类型放入一个待创建集合中，并判断当前组件本身是否在集合中，若在，说明有循环依赖\n","like_count":3},{"had_liked":false,"id":358121,"user_name":"努力努力再努力","can_delete":false,"product_type":"c1","uid":1493907,"ip_address":"广东","ucode":"0C6EEA28FCE8C7","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/93/124d8cd8.jpg","comment_is_top":false,"comment_ctime":1663920524,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"哭了，上一个留言发现有问题，自己实现的时候才发现单纯一个 set 集合记录正在创建的bean还不行，得利用 TLS（https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;93745） 模式做线程隔离，否则多线程的测试用例下，就会出现明明没有循环依赖而报错的问题。","like_count":1},{"had_liked":false,"id":358096,"user_name":"努力努力再努力","can_delete":false,"product_type":"c1","uid":1493907,"ip_address":"广东","ucode":"0C6EEA28FCE8C7","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/93/124d8cd8.jpg","comment_is_top":false,"comment_ctime":1663907549,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"循环依赖，可以加一个 bean 在创建中的标识，当 bean 被创建完之后，就把标识去掉，这样如果创建过程中发现这个 bean 正在创建中，就可以认为是发生循环依赖了","like_count":1},{"had_liked":false,"id":354427,"user_name":"蝴蝶","can_delete":false,"product_type":"c1","uid":1193167,"ip_address":"广东","ucode":"8019924D99182F","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","comment_is_top":false,"comment_ctime":1660380801,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"@Inject注解的构造方法如果没有参数，那肯定是有问题的，这次看明白了。","like_count":0},{"had_liked":false,"id":346783,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1653434621,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"get() 重構受啟發！雖然看過《重構》了解其中的方法，但平時如果get()設計變化我通常還是直接改。這回直觀感受引入get_()的好處。","like_count":0}]}