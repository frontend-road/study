{"id":740842,"title":"第 5 章 异常与错误处理","content":"\n<p>多年前刚开始使用 Python 编程时，我一度非常讨厌“异常”（exception）。原因很简单，因为程序每次抛出异常，就代表肯定发生了什么意料之外的“坏事”。</p>\n<p>比如，程序本应该调用远程 API 获取数据，却因为网络不好，调用失败了，这时我们就会看到大量的 <code>HTTPRequestException</code> 异常。又比如，程序本应把用户输入的内容存入数据库，却因为内容太长，保存失败，我们又会看到一大堆 <code>DatabaseFieldError</code> 异常。</p>\n<p>为了让程序不至于被这些异常搞崩溃，我不得不在代码里加上许多 <code>try</code>/<code>except</code> 来捕获这些异常。所以，那时的异常处理对于我来说，就是一些不想做却又不得不做的琐事，少有乐趣可言。</p>\n<p>但慢慢地，在写了越来越多的 Python 代码后，我发现不能简单地把异常和“意料之外的坏事”画上等号。异常实际上是 Python 这门编程语言里许多核心机制的基础，它在 Python 里无处不在。</p>\n<p>比如，每当你按下 Ctrl + C 快捷键中断脚本执行时，Python 解释器就会抛出一个 <code>Keyboard- Interrupt</code> 异常；每当你用 <code>for</code> 循环完整遍历一个列表时，就有一个 <code>StopIteration</code> 异常被捕获。代码如下所示：</p>\n<pre class=\"code-rows\"><code># 使用 Ctrl + C 快捷键中断 Python 脚本执行\n$ python keyboard_int.py\nInput a string: ^C\n\n# 解释器打印的异常信息\nTraceback (most recent call last):\n  File \"keyboard_int.py\", line 4, in &lt;module&gt;\n    s = input('Input a string: ')\nKeyboardInterrupt</code></pre>\n<p>同时我开始认识到，错误处理不是什么编程的额外负担，它和所有其他工作一样重要。如果能善用异常机制优雅地处理好程序里的错误，我们就能用更少、更清晰的代码，写出更健壮的程序。</p><!-- [[[read_end]]] -->\n<p>在本章中，我将分享自己对于异常和错误处理的一些经验。</p>\n<h2 id=\"nav_point_87\">5.1　基础知识</h2>\n<h3 id=\"nav_point_88\">5.1.1　优先使用异常捕获</h3>\n<p>假设我想写一个简单的函数，它接收一个整数参数，返回对它加 <code>1</code> 后的结果。为了让这个函数更通用，我希望当它接收到一个字符串类型的整数时，也能正常完成计算。</p>\n<p>下面是我写好的 <code>incr_by_one()</code> 函数代码：</p>\n<pre class=\"code-rows\"><code>def incr_by_one(value):\n    \"\"\"对输入整数加1，返回新的值\n\n    :param value: 整型，或者可以转成整型的字符串\n    :return: 整型结果\n    \"\"\"\n    if isinstance(value, int):\n        return value + 1\n    elif isinstance(value, str) and value.isdigit():\n        return int(value) + 1\n    else:\n        print(f'Unable to perform incr for value: \"\"')</code></pre>\n<p>它的执行结果如下：</p>\n<pre class=\"code-rows\"><code># 整数\n&gt;&gt;&gt; incr_by_one(5)\n6\n\n# 整数字符串\n&gt;&gt;&gt; incr_by_one('73')\n74\n\n# 其他无法转换为整数的参数\n&gt;&gt;&gt; incr_by_one('not_a_number')\nUnable to perform incr for value: \"not_a_number\"\n&gt;&gt;&gt; incr_by_one(object())\nUnable to perform incr for value: \"&lt;object object at 0x10e420cb0&gt;\"</code></pre>\n<p>在 <code>incr_by_one()</code> 函数里，因为参数 <code>value</code> 可能是任意类型，所以我写了两个条件分支来避免程序报错：</p>\n<p>(1) 判断仅当类型是 <code>int</code> 时才执行加法操作；</p>\n<p>(2) 判断仅当类型是 <code>str</code>，同时满足 <code>.isdigit()</code> 方法时才进行操作。</p>\n<p>这几行代码看似简单，但其实代表了一种通用的编程风格：LBYL（look before you leap）。LBYL 常被翻译成“三思而后行”。通俗点儿说，就是在执行一个可能会出错的操作时，先做一些关键的条件判断，仅当条件满足时才进行操作。</p>\n<p>LBYL 是一种本能式的思考结果，它的逻辑就像“如果天气预报说会下雨，那么我就不出门”一样直接。</p>\n<p>而在 LBYL 之外，还有另一种与之形成鲜明对比的风格：EAFP（easier to ask for forgiveness than permission），可直译为“获取原谅比许可简单”。</p>\n<h4>获取原谅比许可简单</h4>\n<p>EAFP“获取原谅比许可简单”是一种和 LBYL“三思而后行”截然不同的编程风格。</p>\n<p>在 Python 世界里，EAFP 指不做任何事前检查，直接执行操作，但在外层用 <code>try</code> 来捕获可能发生的异常。如果还用下雨举例，这种做法类似于“出门前不看天气预报，如果淋雨了，就回家后洗澡吃感冒药”。</p>\n<p>如果遵循 EAFP 风格，<code>incr_by_one()</code> 函数可以改成下面这样：</p>\n<pre class=\"code-rows\"><code>def incr_by_one(value):\n    \"\"\"对输入整数加1，返回新的值\n\n    :param value: 整型，或者可以转成整型的字符串\n    :return: 整型结果\n    \"\"\"\n    try:\n        return int(value) + 1\n    except (TypeError, ValueError) as e:\n        print(f'Unable to perform incr for value: \"\", error: ')</code></pre>\n<p>和 LBYL 相比，EAFP 编程风格更为简单直接，它总是直奔主流程而去，把意外情况都放在异常处理 <code>try</code>/<code>except</code> 块内消化掉。</p>\n<p>如果你问我：这两种编程风格哪个更好？我只能说，整个 Python 社区明显偏爱基于异常捕获的 EAFP 风格。这里面的原因很多。</p>\n<p>一个显而易见的原因是，EAFP 风格的代码通常会更精简。因为它不要求开发者用分支完全覆盖各种可能出错的情况，只需要捕获可能发生的异常即可。另外，EAFP 风格的代码通常性能也更好。比如在这个例子里，假如你每次都用字符串 <code>'73'</code> 来调用函数，这两种风格的代码在操作流程上会有如下区别。</p>\n<p>(1) LBYL：每次调用都要先进行额外的 <code>isinstance</code> 和 <code>isdigit</code> 判断。</p>\n<p>(2) EAFP：每次调用直接执行转换，返回结果。</p>\n<p>另外，和许多其他编程语言不同，在 Python 里抛出和捕获异常是很轻量的操作，即使大量抛出、捕获异常，也不会给程序带来过多额外负担。</p>\n<p>所以，每当直觉驱使你写下 <code>if</code>/<code>else</code> 来进行错误分支判断时，请先把这份冲动放一边，考虑用 <code>try</code> 来捕获异常是不是更合适。毕竟，Pythonista<span class=\"comment-number\">1</span> 们喜欢“吃感冒药”胜过“看天气预报”。</p>\n\n<h3 id=\"nav_point_89\">5.1.2　<code>try</code> 语句常用知识</h3>\n<p>在实践 EAFP 编程风格时，需要大量用到异常处理语句：<code>try</code>/<code>except</code> 结构。它的基础语法如下：</p>\n<pre class=\"code-rows\"><code>def safe_int(value):\n    \"\"\"尝试把输入转换为整数\"\"\"\n    try:\n        return int(value)\n    except TypeError:\n        # 当某类异常被抛出时，将会执行对应 except 下的语句\n        print(f'type error:  is invalid')\n    except ValueError:\n        # 你可以在一个 try 语句块下写多个 except\n        print(f'value error:  is invalid')\n    finally:\n        # finally 里的语句，无论如何都会被执行，哪怕已经执行了 return\n        print('function completed')</code></pre>\n<p>函数执行效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; safe_int(None)\ntype error: &lt;class 'NoneType'&gt; is invalid\nfunction completed</code></pre>\n<p>在编写 <code>try</code>/<code>except</code> 语句时，有几个常用的知识点。</p>\n<ol>\n<li><p><strong>把更精确的 <code>except</code> 语句放在前面</strong></p>\n<p>当你在代码中写下 <code>except SomeError:</code> 后，如果程序抛出了 <code>SomeError</code> 类型的异常，便会被这条 <code>except</code> 语句所捕获。但是，这条语句能捕获的其实不止 <code>SomeError</code>，它还会捕获 <code>SomeError</code> 类型的所有派生类。</p>\n<p>而 Python 的内置异常类之间存在许多继承关系，举个例子：</p>\n<pre class=\"code-rows\"><code># BaseException 是一切异常类的父类，甚至包括 KeyboardInterrupt 异常\n&gt;&gt;&gt; issubclass(Exception, BaseException)\nTrue\n&gt;&gt;&gt; issubclass(LookupError, Exception)\nTrue\n&gt;&gt;&gt; issubclass(KeyError, LookupError)\nTrue</code></pre>\n<p>上面的代码展示了一条异常类派生关系：<code>BaseException</code> → <code>Exception</code> → <code>LookupError</code> → <code>KeyError</code>。</p>\n<p>如果一个 <code>try</code> 代码块里包含多条 <code>except</code>，异常匹配会按照从上而下的顺序进行。这时，假如你不小心把一个比较模糊的父类异常放在前面，就会导致在下面的 <code>except</code> 永远不会被触发。</p>\n<p>比如在下面这段代码里，<code>except KeyError:</code> 分支下的内容永远不会被执行：</p>\n<pre class=\"code-rows\"><code>def incr_by_key(d, key):\n    try:\n        d[key] += 1\n    except Exception as e: ➊\n        print(f'Unknown error: ')\n    except KeyError:\n        print(f'key  does not exists')</code></pre>\n<blockquote>\n<p>❶ 任何异常都会被它捕获</p>\n</blockquote>\n<p>要修复这个问题，我们得调换两个 <code>except</code> 的顺序，把更精确的异常放在前面：</p>\n<pre class=\"code-rows\"><code>def incr_by_key(d, key):\n    try:\n        d[key] += 1\n    except KeyError:\n        print(f'key  does not exists')\n    except Exception as e:\n        print(f'Unknown error: ')</code></pre>\n<p>这样调整后，<code>KeyError</code> 异常就能被第一条 <code>except</code> 语句正常捕获了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 <code>else</code> 分支</strong></p>\n<p>在用 <code>try</code> 捕获异常时，有时程序需要仅在一切正常时做某件事。为了做到这一点，我们常常需要在代码里设置一个专用的标记变量。</p>\n<p>举个简单的例子：</p>\n<pre class=\"code-rows\"><code># 同步用户资料到外部系统，仅当同步成功时发送通知消息\nsync_succeeded = False\ntry:\n    sync_profile(user.profile, to_external=True)\n    sync_succeeded = True\nexcept Exception as e:\n    print(\"Error while syncing user profile\")\n\nif sync_succeeded:\n    send_notification(user, 'profile sync succeeded')</code></pre>\n<p>在上面这段代码里，我期望只有当 <code>sync_profile()</code> 执行成功时，才继续调用 <code>send_notification()</code> 发送通知消息。为此，我定义了一个额外变量 <code>sync_succeeded</code> 来作为标记。</p>\n<p>如果使用 <code>try</code> 语句块里的 <code>else</code> 分支，代码可以变得更简单：</p>\n<pre class=\"code-rows\"><code>try:\n    sync_profile(user.profile, to_external=True)\nexcept Exception as e:\n    print(\"Error while syncing user profile\")\nelse:\n    send_notification(user, 'profile sync succeeded')</code></pre>\n<p>上面的 <code>else</code> 和条件分支语句里的 <code>else</code> 虽然是同一个词，但含义不太一样。</p>\n<p>异常捕获语句里的 <code>else</code> 表示：仅当 <code>try</code> 语句块里没抛出任何异常时，才执行 <code>else</code> 分支下的内容，效果就像在 <code>try</code> 最后增加一个标记变量一样。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　和 <code>finally</code> 语句不同，假如程序在执行 <code>try</code> 代码块时碰到了 <code>return</code> 或 <code>break</code> 等跳转语句，中断了本次异常捕获，那么即便代码没抛出任何异常，<code>else</code> 分支内的逻辑也<strong>不会</strong>被执行。</p>\n</blockquote>\n<p>&nbsp;</p>\n<blockquote>\n<p><strong>难理解的 <code>else</code> 关键字</strong></p>\n<p>虽然异常语句里的 <code>else</code> 关键字我平时用的不少，但不得不承认，此处的 <code>else</code> 并不像其他 Python 语法一样那么直观、容易理解。</p>\n<p><code>else</code> 这个词，字面意义是“否则”，但当它紧随着 <code>try</code> 和 <code>except</code> 出现时，你其实很难分辨它到底代表哪一种“否则”——到底是有异常时的“否则”，还是没异常时的“否则”。因此，有些开发者认为，异常捕获里的 <code>else</code> 关键字，应当调整为 <code>then</code>：表示“没有异常后，接着做某件事”的意思。</p>\n<p>但木已成舟，在可预见的未来，异常捕获里的 <code>else</code> 应该会继续存在下去。这点儿因不恰当的关键字带来的理解成本，只能由我们默默承受了。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用空 <code>raise</code> 语句</strong></p>\n<p>在处理异常时，有时我们可能仅仅想记录下某个异常，然后把它重新抛出，交由上层处理。这时，不带任何参数的 <code>raise</code> 语句可以派上用场：</p>\n<pre class=\"code-rows\"><code>def incr_by_key(d, key):\n    try:\n        d[key] += 1\n    except KeyError:\n        print(f'key  does not exists, re-raise the exception')\n        raise</code></pre>\n<p>当一个空 <code>raise</code> 语句出现在 <code>except</code> 块里时，它会原封不动地重新抛出当前异常。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_90\">5.1.3　抛出异常，而不是返回错误</h3>\n<p>我们知道，Python 里的函数可以一次返回多个值（通过返回一个元组实现）。所以，当我们要表明函数执行出错时，可以让它同时返回结果与错误信息。</p>\n<p>下面的 <code>create_item()</code> 函数就利用了这个特性：</p>\n<pre class=\"code-rows\"><code>def create_item(name):\n    \"\"\"接收名称，创建 Item 对象\n\n    :return: (对象, 错误信息)，成功时错误信息为 ''\n    \"\"\"\n    if len(name) &gt; MAX_LENGTH_OF_NAME:\n        return None, 'name of item is too long'\n    if len(get_current_items()) &gt; MAX_ITEMS_QUOTA:\n        return None, 'items is full'\n    return Item(name=name), ''\n\n\ndef create_from_input():\n    name = input()\n    item, err_msg = create_item(name)\n    if err_msg:\n        print(f'create item failed: ')\n    else:\n        print('item&lt;&gt; created')</code></pre>\n<p>在这段代码里，<code>create_item()</code> 函数的功能是创建新的 <code>Item</code> 对象。</p>\n<p>当上层调用 <code>create_item()</code> 函数时，如果执行失败，函数会把错误原因放到第二个结果中返回。而当函数执行成功时，为了保持返回值结构统一，函数同样会返回错误原因，只是内容为空字符串 <code>''</code>。</p>\n<p>乍看上去，这种做法似乎很自然，对那些有 Go 语言编程经验的人来说更是如此。但在 Python 世界里，返回错误并非解决此类问题的最佳办法。这是因为这种做法会增加调用方处理错误的成本，尤其是当许多函数遵循这个规范，并且有很多层调用关系时。</p>\n<p>Python 有完善的异常机制，并且在某种程度上鼓励我们使用异常（见 5.1.1 节）。所以，用异常来进行错误处理才是更地道的做法。</p>\n<p>通过引入自定义异常类，上面的代码可以改写成下面这样：</p>\n<pre class=\"code-rows\"><code>class CreateItemError(Exception):\n    \"\"\"创建 Item 失败\"\"\"\n\n\ndef create_item(name):\n    \"\"\"创建一个新的 Item\n\n    :raises: 当无法创建时抛出 CreateItemError\n    \"\"\"\n    if len(name) &gt; MAX_LENGTH_OF_NAME:\n        raise CreateItemError('name of item is too long')\n    if len(get_current_items()) &gt; MAX_ITEMS_QUOTA:\n        raise CreateItemError('items is full')\n    return Item(name=name), ''\n\n\ndef create_from_input():\n    name = input()\n    try:\n        item = create_item(name)\n    except CreateItemError as e:\n        print(f'create item failed: ')\n    else:\n        print(f'item&lt;&gt; created')</code></pre>\n<p>用抛出异常替代返回错误后，整个代码结构乍看上去变化不大，但细节上的改变其实非常多。</p>\n<ul>\n<li>新函数拥有更稳定的返回值类型，它永远只会返回 <code>Item</code> 类型或是抛出异常。</li>\n<li>虽然我们鼓励使用异常，但异常总是会不可避免地让人“感到惊讶”，所以，最好在函数文档里说明可能抛出的异常类型。</li>\n<li>不同于返回值，异常在被捕获前会不断往调用栈上层汇报。因此 <code>create_item()</code> 的直接调用方也可以完全不处理 <code>CreateItemError</code>，而交由更上层处理。异常的这个特点给了我们更多灵活性，但同时也带来了更大的风险。具体来说，假如程序缺少一个顶级的统一异常处理逻辑，那么某个被所有人忽视了的异常可能会层层上报，最终弄垮整个程序。</li>\n</ul>\n<blockquote>\n<p><strong>处理异常的题外话</strong></p>\n<p>如何在编程语言里处理错误，是一个至今仍然存在争议的话题。比如像上面不推荐的多返回值方式，正是缺乏异常的 Go 语言中的核心错误处理机制。另外，即使是异常机制本身，在不同编程语言之间也存在差别。比如 Java 的异常机制就和 Python 里的很不一样。</p>\n<p>异常，或是不异常，都是由编程语言设计者进行多方取舍后的结果，更多时候不存在绝对的优劣之分。但单就 Python 而言，使用异常来表达错误无疑更符合 Python 哲学，更应该受到推崇。</p>\n</blockquote>\n<h3 id=\"nav_point_91\">5.1.4　使用上下文管理器</h3>\n<p>当 Python 程序员们谈到异常处理时，第一个想到的往往是 <code>try</code> 语句。但除了 <code>try</code> 以外，还有一个关键字和异常处理也有着密切的关系，它就是 <code>with</code>。</p>\n<p>你可能早就用过 <code>with</code> 了，比如用它来打开一个文件：</p>\n<pre class=\"code-rows\"><code># 使用 with 打开文件，文件描述符会在作用域结束后自动被释放\nwith open('foo.txt') as fp:\n    content = fp.read()</code></pre>\n<p><code>with</code> 是一个神奇的关键字，它可以在代码中开辟一段由它管理的上下文，并控制程序在进入和退出这段上下文时的行为。比如在上面的代码里，这段上下文所附加的主要行为就是：进入时打开某个文件并返回文件对象，退出时关闭该文件对象。</p>\n<p>并非所有对象都能像 <code>open('foo.txt')</code> 一样配合 <code>with</code> 使用，只有满足<strong>上下文管理器</strong>（context manager）协议的对象才行。</p>\n<p>上下文管理器是一种定义了“进入”和“退出”动作的特殊对象。要创建一个上下文管理器，只要实现 <code>__enter__</code> 和 <code>__exit__</code> 两个魔法方法即可。</p>\n<p>下面这段代码实现了一个简单的上下文管理器：</p>\n<pre class=\"code-rows\"><code>class DummyContext:\n    def __init__(self, name):\n        self.name = name\n\n    def __enter__(self):\n        # __enter__ 会在进入管理器时被调用，同时可以返回结果\n        # 这个结果可以通过 as 关键字被调用方获取\n        #\n        # 此处返回一个增加了随机后缀的 name\n        return f'-'\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # __exit__ 会在退出管理器时被调用\n        print('Exiting DummyContext')\n        return False</code></pre>\n<p>它的执行效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; with DummyContext('foo') as name:\n...     print(f'Name: ')\n...\nName: foo-0.021691996029607252\nExiting DummyContext</code></pre>\n<p>上下文管理器功能强大、用处很多，其中最常见的用处之一，就是简化异常处理工作。</p>\n<ol>\n<li><p><strong>用于替代 <code>finally</code> 语句清理资源</strong></p>\n<p>在编写 <code>try</code> 语句时，<code>finally</code> 关键字经常用来做一些资源清理类工作，比如关闭已创建的网络连接：</p>\n<pre class=\"code-rows\"><code>conn = create_conn(host, port, timeout=None)\ntry:\n    conn.send_text('Hello, world!')\nexcept Exception as e:\n    print(f'Unable to use connection: ')\nfinally:\n    conn.close()</code></pre>\n<p>上面这种写法虽然经典，却有些烦琐。如果使用上下文管理器，这类资源回收代码可以变得更简单。</p>\n<p>当程序使用 <code>with</code> 进入一段上下文后，不论里面发生了什么，它在退出这段上下文代码块时，<strong>必定</strong>会调用上下文管理器的 <code>__exit__</code> 方法，就和 <code>finally</code> 语句的行为一样。</p>\n<p>因此，我们完全可以用上下文管理器来替代 <code>finally</code> 语句。做起来很简单，只要在 <code>__exit__</code> 里增加需要的回收语句即可：</p>\n<pre class=\"code-rows\"><code>class create_conn_obj:\n    \"\"\"创建连接对象，并在退出上下文时自动关闭\"\"\"\n\n    def __init__(self, host, port, timeout=None):\n        self.conn = create_conn(host, port, timeout=timeout)\n\n    def __enter__(self):\n        return self.conn\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        # __exit__ 会在管理器退出时调用\n        self.conn.close()\n        return False</code></pre>\n<p>使用 <code>create_conn_obj</code> 可以创建会自动关闭的连接对象：</p>\n<pre class=\"code-rows\"><code># 使用上下文管理器创建连接\nwith create_conn_obj(host, port, timeout=None) as conn:\n    try:\n        conn.send_text('Hello, world!')\n    except Exception as e:\n        print(f'Unable to use connection: ')</code></pre>\n<p>除了回收资源外，你还可以用 <code>__exit__</code> 方法做许多其他事情，比如对异常进行二次处理后重新抛出，又比如忽略某种异常，等等。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>用于忽略异常</strong></p>\n<p>在执行某些操作时，有时程序会抛出一些<strong>不影响正常执行逻辑</strong>的异常。</p>\n<p>打个比方，当你在关闭某个连接时，假如它已经是关闭状态了，解释器就会抛出 <code>AlreadyClosedError</code> 异常。这时，为了让程序正常运行下去，你必须用 <code>try</code> 语句来捕获并忽略这个异常：</p>\n<pre class=\"code-rows\"><code>try:\n    close_conn(conn)\nexcept AlreadyClosedError:\n    pass</code></pre>\n<p>虽然这样的代码很简单，但没法复用。当项目中有很多地方要忽略这类异常时，这些 <code>try</code>/<code>except</code> 语句就会分布在各个角落，看上去非常凌乱。</p>\n<p>如果使用上下文管理器，我们可以很方便地实现可复用的“忽略异常”功能——只要在 <code>__exit__</code> 方法里稍微写几行代码就行：</p>\n<pre class=\"code-rows\"><code>class ignore_closed:\n    \"\"\"忽略已经关闭的连接\"\"\"\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_type == AlreadyClosedError:\n            return True\n        return False</code></pre>\n<p>当你想忽略 <code>AlreadyClosedError</code> 异常时，只要把代码用 <code>with</code> 语句包裹起来即可：</p>\n<pre class=\"code-rows\"><code>with ignore_closed():\n    close_conn(conn)</code></pre>\n<p>通过 <code>with</code> 实现的“忽略异常”功能，主要利用了上下文管理器的 <code>__exit__</code> 方法。</p>\n<p><code>__exit__</code> 接收三个参数：<code>exc_type</code>、<code>exc_value</code> 和 <code>traceback</code>。</p>\n<p>在代码执行时，假如 <code>with</code> 管辖的上下文内没有抛出任何异常，那么当解释器触发 <code>__exit__</code> 方法时，上面的三个参数值都是 <code>None</code>；但如果有异常抛出，这三个参数就会变成该异常的具体内容。</p>\n<p>(1) <code>exc_type</code>：异常的类型。</p>\n<p>(2) <code>exc_value</code>：异常对象。</p>\n<p>(3) <code>traceback</code>：错误的堆栈对象。</p>\n<p>此时，程序的行为取决于 <code>__exit__</code> 方法的返回值。如果 <code>__exit__</code> 返回了 <code>True</code>，那么这个异常就会被当前的 <code>with</code> 语句压制住，不再继续抛出，达到“忽略异常”的效果；如果 <code>__exit__</code> 返回了 <code>False</code>，那这个异常就会被正常抛出，交由调用方处理。</p>\n<p>因此，在上面的 <code>ignore_closed</code> 上下文管理器里，任何 <code>AlreadyClosedError</code> 类型的异常都会被忽略，而其他异常会被正常抛出。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　如果你在真实项目中要忽略某类异常，可以直接使用标准库模块 <code>contextlib</code> 里的 <code>suppress</code> 函数，它提供了现成的“忽略异常”功能。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 <code>contextmanager</code> 装饰器</strong></p>\n<p>虽然上下文管理器很好用，但定义一个符合协议的管理器对象其实挺麻烦的——得首先创建一个类，然后实现好几个魔法方法。为了简化这部分工作，Python 提供了一个非常好用的工具：<code>@contextmanager</code> 装饰器。</p>\n<p><code>@contextmanager</code> 位于内置模块 <code>contextlib</code> 下，它可以把任何一个生成器函数直接转换为一个上下文管理器。</p>\n<p>举个例子，我在前面实现的自动关闭连接的 <code>create_conn_obj</code> 上下文管理器，假如用函数来改写，可以简化成下面这样：</p>\n<pre class=\"code-rows\"><code>from contextlib import contextmanager\n\n@contextmanager\ndef create_conn_obj(host, port, timeout=None):\n    \"\"\"创建连接对象，并在退出上下文时自动关闭\"\"\"\n    conn = create_conn(host, port, timeout=timeout)\n    try:\n        yield conn ➊\n    finally: ➋\n        conn.close()</code></pre>\n<blockquote>\n<p>❶ 以 <code>yield</code> 关键字为界，<code>yield</code> 前的逻辑会在进入管理器时执行（类似于 <code>__enter__</code>），<code>yield</code> 后的逻辑会在退出管理器时执行（类似于 <code>__exit__</code>）</p>\n<p>❷ 如果要在上下文管理器内处理异常，必须用 <code>try</code> 语句块包裹 <code>yield</code> 语句</p>\n</blockquote>\n<p>在日常工作中，我们用到的大多数上下文管理器，可以直接通过“生成器函数 + <code>@contextmanager</code>”的方式来定义，这比创建一个符合协议的类要简单得多。</p>\n</li>\n</ol>\n<h2 id=\"nav_point_92\">5.2　案例故事</h2>\n<p>假如你和几年前的我一样，简单地认为异常是一种会让程序崩溃的“坏家伙”，就难免会产生这种想法：“好的程序就应该尽量捕获所有异常，让一切都平稳运行。”</p>\n<p>但讽刺的是，假如你真的带着这种想法去写代码，反而容易给自己带来一些意料之外的麻烦。下面小 R 的这个故事就是一个例子。</p>\n<h3 id=\"nav_point_93\">5.2.1　提前崩溃也挺好</h3>\n<p>小 R 是一位刚接触 Python 不久的程序员。因为工作需要，他要写一个简单的程序来抓取特定网页的标题，并将其保存在本地文件中。</p>\n<p>在学习了 <code>requests</code> 模块和 <code>re</code> 模块后，他很快写出了脚本，如代码清单 5-1 所示。</p>\n<blockquote>\n<p><strong>代码清单 5-1</strong>　抓取网页标题脚本</p>\n</blockquote>\n<pre class=\"code-rows\"><code>import requests\nimport re\n\n\ndef save_website_title(url, filename):\n    \"\"\"获取某个地址的网页标题，然后将其写入文件中\n\n    :return: 如果成功保存，返回 True；否则打印错误，返回 False\n    \"\"\"\n    try:\n        resp = requests.get(url)\n        obj = re.search(r'&lt;title&gt;(.*)&lt;/title&gt;', resp.text)\n        if not obj:\n            print('save failed: title tag not found in page content')\n            return False\n\n        title = obj.grop(1)\n        with open(filename, 'w') as fp:\n            fp.write(title)\n            return True\n    except Exception:\n        print(f'save failed: unable to save title of  to ')\n        return False\n\n\ndef main():\n    save_website_title('https://www.qq.com', 'qq_title.txt')\n\n\nif __name__ == '__main__':\n    main()</code></pre>\n<p>脚本里的 <code>save_website_title()</code> 函数做了好几件事情。它首先通过 <code>requests</code> 模块获取网页内容，然后用正则表达式提取网页标题，最后将标题写在本地文件里。</p>\n<p>而小 R 认为，整个过程中有两个步骤很容易出错：<strong>网络请求</strong>与<strong>本地文件操作</strong>。所以在写代码时，他用一个庞大的 <code>try</code>/<code>except</code> 语句块，把这几个步骤全都包在了里面——毕竟安全第一。</p>\n<p>那么，小 R 写的这段代码到底藏着什么问题呢？</p>\n<ol>\n<li><p><strong>小 R 的无心之失</strong></p>\n<p>如果你旁边刚好有一台装了 Python 的电脑，那么可以试着运行一遍上面的脚本。你会发现，无论怎么修改网址和目标文件参数，这段程序都不能正常运行，而会报错：<code>save failed: unable to ...</code>。这是为什么呢？</p>\n<p>问题就藏在这个庞大的 <code>try</code>/<code>except</code> 代码块里。如果你非常仔细地逐行检查这段代码，就会发现在编写函数时，小 R 犯了一个<strong>小错误</strong>：他把获取正则匹配串的方法错打成了 <code>obj.grop(1)</code>——少了一个字母 <code>u</code>（正确写法：<code>obj.group(1)</code>）。</p>\n<p>但因为那段异常捕获范围过大、过于含糊，所以这个本该被抛出的 <code>AttibuteError</code> 异常被吞噬了，函数的 debug 过程变得难上加难：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; obj.grop(1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 're.Match' object has no attribute 'grop'</code></pre>\n<p>这个 <code>obj.grop(1)</code> 可能只是小 R 的一次无心之失。但我们可以透过它窥见一个新问题，那就是：“我们为什么要捕获异常？”</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>为什么要捕获异常</strong></p>\n<p>“为什么要捕获异常？”这个问题看上似乎有点儿小儿科。捕获异常，不就是为了避免程序崩溃吗？但如果这就是正确答案，为什么小 R 写的程序没崩溃，却反而比崩溃更糟糕呢？</p>\n<p>在代码中捕获异常，表面上是避免程序因为异常发生而直接崩溃，但它的核心，其实是编码者对处于程序主流程之外的、已知或未知情况的一种妥当处置。而<strong>妥当</strong>这个词正是异常处理的关键。</p>\n<p>异常捕获不是在拿着捕虫网玩捕虫游戏，谁捕的虫子多谁就获胜。弄一个庞大的 <code>try</code> 语句，把所有可能出错、不可能出错的代码，一股脑儿地全部用 <code>except Exception</code>：包起来，显然是不妥当的。</p>\n<p>如果坚持做最精准的异常捕获，小 R 脚本里的问题根本就不会发生，精准捕获包括：</p>\n<ul>\n<li>永远只捕获那些可能会抛出异常的语句块；</li>\n<li>尽量只捕获精确的异常类型，而不是模糊的 <code>Exception</code>；</li>\n<li>如果出现了预期外的异常，让程序早点儿崩溃也未必是件坏事。依照这些原则，小 R 的代码应该改成代码清单 5-2 这样。</li>\n</ul>\n<blockquote>\n<p><strong>代码清单 5-2</strong>　抓取网页标题脚本（精确捕获异常）</p>\n</blockquote>\n<pre class=\"code-rows\"><code>import re\nfrom requests.exceptions import RequestException\n　\n　\ndef save_website_title(url, filename):\n    # 抓取网页\n    try:\n        resp = requests.get(url)\n    except RequestException as e:\n        print(f'save failed: unable to get page content: ')\n        return False\n\n    # 获取标题\n    obj = re.search(r'&lt;title&gt;(.*)&lt;/title&gt;', resp.text)\n    if not obj:\n        print('save failed: title tag not found in page content')\n        return False\n    title = obj.group(1)\n\n    # 保存文件\n    try:\n        with open(filename, 'w') as fp:\n            fp.write(title)\n    except IOError as e:\n        print(f'save failed: unable to write to file : ')\n        return False\n    else:\n        return True</code></pre>\n<p>和旧代码相比，新代码去掉了大块的 <code>try</code>，拆分出了两段更精确的异常捕获语句。</p>\n<p>对于用正则获取标题那段代码来说，它本来就不应该抛出任何异常，所以我们没必要使用 <code>try</code> 语句包裹它。如果将 <code>group</code> 误写成了 <code>grop</code>，也没关系，程序马上就会通过 <code>AttributeError</code> 来告诉我们。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_94\">5.2.2　异常与抽象一致性</h3>\n<p>下面这个故事来自我的亲身经历。</p>\n<p>在若干年前，当时我正在参与某移动应用程序的后端 API 开发。如果你也开发过后端 API，肯定知道经常需要制定一套“API 错误码规范”，来为客户端处理错误提供方便。</p>\n<p>当时我们制定的错误码响应大概如下所示：</p>\n<pre class=\"code-rows\"><code>// HTTP Status Code: 400\n// Content-Type: application/json\n{\n    \"code\": \"UNABLE_TO_UPVOTE_YOUR_OWN_REPLY\",\n    \"detail\": \"你不能推荐自己的回复\"\n}</code></pre>\n<p>制定好规范后，接下来的任务就是决定如何实现它。项目当时用的是 Django 框架，而 Django 的错误页面正是利用异常机制实现的。</p>\n<p>举个例子，如果你想让一个请求返回 404 错误页面，那么只需要在该请求过程中执行 <code>raise Http404</code> 抛出异常即可。</p>\n<p>所以，我们很自然地从 Django 那儿获得了灵感。我们在项目内定义了错误码异常类：<code>APIErrorCode</code>，然后写了很多继承该类的错误码异常。当需要返回错误信息给用户时，只需要做一次 <code>raise</code> 就能搞定：</p>\n<pre class=\"code-rows\"><code>raise error_codes.UNABLE_TO_UPVOTE\nraise error_codes.USER_HAS_BEEN_BANNED\n... ...</code></pre>\n<p>毫不意外，所有人都很喜欢用这种方式来返回错误码。因为它用起来非常方便：无论当前调用栈有多深，只要你想给用户返回错误码，直接调用 <code>raise error_codes.ANY_THING</code> 就行。</p>\n<ol>\n<li><p><strong>无法复用的 <code>process_image()</code> 函数</strong></p>\n<p>随着产品的不断演进，项目规模变得越来越庞大。某日，当我正准备复用一个底层图片处理函数时，突然看到一段让我非常纠结的代码，如代码清单 5-3 所示。</p>\n<blockquote>\n<p><strong>代码清单 5-3</strong>　某个图像处理模块内部：/util/image/processor.py</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def process_image(...):\n    try:\n        image = Image.open(fp)\n    except Exception:\n        raise error_codes.INVALID_IMAGE_UPLOADED\n    ...</code></pre>\n<p><code>process_image()</code> 函数会尝试打开一个文件对象。假如该文件不是有效的图片格式，就抛出 <code>error_codes.INVALID_IMAGE_UPLOADED</code> 异常。该异常会被 Django 中间件捕获，最终给用户返回“INVALID_IMAGE_UPLOADED”（上传的图片格式有误）错误码响应。</p>\n<p>这段代码为什么让我纠结？下面我从头理理这件事。</p>\n<p>最初编写 <code>process_image()</code> 时，调用这个函数的就只有“处理用户上传图片的 POST 请求”而已。所以为了偷懒，我让该函数直接抛出 <code>APIErrorCode</code> 异常来完成错误处理工作。</p>\n<p>再回到问题本身，当时我需要写一个在后台运行的图片批处理脚本，而它刚好可以复用 <code>process_image()</code> 函数所实现的功能。</p>\n<p>但这时事情开始变得不对劲起来，如果我想复用该函数，那么：</p>\n<ul>\n<li>必须引入 <code>APIErrorCode</code> 异常类依赖来捕获异常——哪怕脚本和 Django API 根本没有任何关系；</li>\n<li>必须捕获 <code>INVALID_IMAGE_UPLOADED</code> 异常——哪怕图片根本就不是由用户上传的。</li>\n</ul>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>避免抛出抽象级别高于当前模块的异常</strong></p>\n<p>这就是异常类与模块抽象级别不一致导致的结果。<code>APIErrorCode</code> 异常类的意义在于，表达一种能直接被终端用户（人）识别并消费的“错误代码”。它是整个项目中最高层的抽象之一。</p>\n<p>但是出于方便，我在一个底层图像处理模块里抛出了它。这打破了 <code>process_image()</code> 函数的抽象一致性，导致我无法在后台脚本里复用它。</p>\n<p>这类情况属于模块抛出了高于所属抽象级别的异常。避免这类错误需要注意以下两点：</p>\n<ul>\n<li>让模块只抛出与当前抽象级别一致的异常；</li>\n<li>在必要的地方进行异常包装与转换。</li>\n</ul>\n<p>为了满足这两点，我需要对代码做一些调整：</p>\n<ul>\n<li><code>image.processer</code> 模块应该抛出自己封装的 <code>ImageOpenError</code> 异常；</li>\n<li>在贴近高层抽象（视图 View 函数）的地方，将图像处理模块的低级异常 <code>ImageOpenError</code> 包装为高级异常 <code>APIErrorCode</code>。</li>\n</ul>\n<p>修改后的代码如代码清单 5-4 和代码清单 5-5 所示。</p>\n<blockquote>\n<p><strong>代码清单 5-4</strong>　图像处理模块：/util/image/processor.py</p>\n</blockquote>\n<pre class=\"code-rows\"><code>class ImageOpenError(Exception):\n    \"\"\"图像打开错误异常类\n\n    :param exc: 原始异常\n    \"\"\"\n\n    def __init__(self, exc):\n        self.exc = exc\n        # 调用异常父类方法，初始化错误信息\n        super().__init__(f'Image open error: ')\n\ndef process_image(...):\n    try:\n        image = Image.open(fp)\n    except Exception as e:\n        raise ImageOpenError(exc=e)\n    ... ...</code></pre>\n<blockquote>\n<p><strong>代码清单 5-5</strong>　API 视图模块：/app/views.py</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def foo_view_function(request):\n    try:\n        process_image(fp)\n    except ImageOpenError:\n        raise error_codes.INVALID_IMAGE_UPLOADED</code></pre>\n<p>这样调整以后，我就能愉快地在后台脚本里复用 <code>process_image()</code> 函数了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>包装抽象级别低于当前模块的异常</strong></p>\n<p>除了应该避免抛出高于当前抽象级别的异常外，我们同样应该避免泄露低于当前抽象级别的异常。</p>\n<p>如果你使用过第三方 HTTP 工具库 <code>requests</code>，可能已经发现它在请求出错时所抛出的异常，并不是它在底层所使用的 <code>urllib3</code> 模块的原始异常，而是经过 <code>requests.exceptions</code> 包装过的异常：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; try:\n...     requests.get('https://www.invalid-host-foo.com')\n... except Exception as e:\n...     print(type(e))\n...\n&lt;class 'requests.exceptions.ConnectionError'&gt;</code></pre>\n<p>这样做同样是为了保证异常类的抽象一致性。</p>\n<p><code>urllib3</code> 模块是 <code>requests</code> 依赖的低层实现细节，而这个细节在未来是有可能变动的。当某天 <code>requests</code> 真的要修改低层实现时，这些包装过的异常类，就可以避免对用户侧的错误处理逻辑产生不良影响。</p>\n</li>\n</ol>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　有关函数与抽象级别的话题，你可以在 7.3.2 节找到更多相关内容。</p>\n</blockquote>\n<h2 id=\"nav_point_95\">5.3　编程建议</h2>\n<h3 id=\"nav_point_96\">5.3.1　不要随意忽略异常</h3>\n<p>在 5.1.4 节中，我介绍了如何使用上下文管理器来忽略某种异常。但必须要补充的是，在实际工作中，直接忽略异常其实非常少见，因为这么做风险很高。</p>\n<p>当编码者决定让自己的代码抛出异常时，他肯定不是临时起意，而一定是希望调用自己代码的人对这个异常做点儿什么。面对异常，调用方可以：</p>\n<ul>\n<li>在 <code>except</code> 语句里捕获并处理它，继续执行后面的代码；</li>\n<li>在 <code>except</code> 语句里捕获它，将错误通知给终端用户，中断执行；</li>\n<li>不捕获异常，让异常继续往堆栈上层走，最终可能导致程序崩溃。</li>\n</ul>\n<p>无论选择哪种方案，都比下面这样直接忽略异常更好：</p>\n<pre class=\"code-rows\"><code>try:\n    send_sms_notification(user, message)\nexcept RequestError:\n    pass</code></pre>\n<p>假如 <code>send_sms_notification()</code> 执行失败，抛出了 <code>RequestError</code> 异常，它会直接被 <code>except</code> 忽略，就好像异常从未发生过一样。</p>\n<p>当然，代码肯定不是平白无故写成这样的。编码者会说：“这个短信通知根本不重要，即使失败了也没关系。”但即便这样，通过日志记录下这个异常总会更好：</p>\n<pre class=\"code-rows\"><code>try:\n    send_sms_notification(user, message)\nexcept RequestError:\n    logger.warning('RequestError while sending SMS notification to %s', user.username)</code></pre>\n<p>有了错误日志后，假如某个用户反馈自己没收到通知，我们可以马上从日志里查到是否有失败记录，不至于无计可施。此外，这些日志还可以用来做许多有趣的事情，比如统计所有短信的发送失败比例，等等。</p>\n<p>综上所述，除了极少数情况外，不要直接忽略异常。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　“Python 之禅”里也提到了这个建议：“除非有意静默，否则不要无故忽视异常。”（Errors should never pass silently. Unless explicitly silenced.）</p>\n</blockquote>\n<h3 id=\"nav_point_97\">5.3.2　不要手动做数据校验</h3>\n<p>在日常编码时，很大比例的错误处理工作和用户输入有关。当程序里的某些数据直接来自用户输入时，我们必须先校验这些输入值，再进行之后的处理，否则就会出现难以预料的错误。</p>\n<p>举个例子，我在写一个命令行小程序，它要求用户输入一个 0～100 范围的数字。假如用户输入的内容无效，就要求其重新输入。</p>\n<p>小程序的代码如代码清单 5-6 所示。</p>\n<blockquote>\n<p><strong>代码清单 5-6</strong>　要求用户输入数字的脚本（手动校验）</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def input_a_number():\n    \"\"\"要求用户输入一个 0～100 的数字，如果无效则重新输入\"\"\"\n    while True:\n        number = input('Please input a number (0-100): ')\n\n        # 下面的三条 if 语句都是对输入值的校验代码\n        if not number:\n            print('Input can not be empty!')\n            continue\n        if not number.isdigit():\n            print('Your input is not a valid number!')\n            continue\n        if not (0 &lt;= int(number) &lt;= 100):\n            print('Please input a number between 0 and 100!')\n            continue\n\n        number = int(number)\n        break\n\n    print(f'Your number is ')</code></pre>\n<p>执行效果如下：</p>\n<pre class=\"code-rows\"><code>Please input a number (0-100):\nInput can not be empty!\nPlease input a number (0-100): foo\nYour input is not a valid number!\nPlease input a number (0-100): 65\nYour number is 65</code></pre>\n<p>这个函数共包含 14 行有效代码，其中有 9 行 <code>if</code> 都在校验数据。也许你觉得这样的代码结构很正常，但请想象一下，假如我们需要校验的输入不止一个，校验逻辑也比这个复杂怎么办？</p>\n<p>那样的话，这些数据校验代码就会变得又臭又长，占满整个函数。</p>\n<p>如何改进这段代码呢？假如把数据校验代码抽成一个独立函数，和核心逻辑隔离开，代码肯定会变得更清晰。不过比这更重要的是，我们要把“输入数据校验”当作一个独立的领域，挑选更适合的模块来完成这项工作。</p>\n<p>在数据校验这块，<code>pydantic</code> 模块是一个不错的选择。如果用它来做校验，上面的代码可以改写成代码清单 5-7。</p>\n<blockquote>\n<p><strong>代码清单 5-7</strong>　要求用户输入数字的脚本（使用 <code>pydantic</code> 库）</p>\n</blockquote>\n<pre class=\"code-rows\"><code>from pydantic import BaseModel, conint, ValidationError\nclass NumberInput(BaseModel):\n    # 使用类型注解 conint 定义 number 属性的取值范围\n    number: conint(ge=0, le=100)\n\n\ndef input_a_number_with_pydantic():\n    while True:\n        number = input('Please input a number (0-100): ')\n\n        # 实例化为 pydantic 模型，捕获校验错误异常\n        try:\n            number_input = NumberInput(number=number)\n        except ValidationError as e:\n            print(e)\n            continue\n\n        number = number_input.number\n        break\n\n    print(f'Your number is ')</code></pre>\n<p>使用专业的数据校验模块后，整段代码变得简单了许多。</p>\n<p>在编写代码时，我们应当尽量避免手动校验任何数据。因为数据校验任务独立性很强，所以应该引入合适的第三方校验模块（或者自己实现），让它们来处理这部分专业工作。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00373.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　假如你在开发 Web 应用，数据校验工作通常来说比较容易。比如 Django 框架就有自己的表单验证模块，Flask 也可以使用 WTForms 模块来进行数据校验。</p>\n</blockquote>\n<h3 id=\"nav_point_98\">5.3.3　抛出可区分的异常</h3>\n<p>当开发者编写自定义异常类时，似乎不需要遵循太多原则。常见的几条是：要继承 <code>Exception</code> 而不是 <code>BaseException</code>；异常类名最好以 <code>Error</code> 或 <code>Exception</code> 结尾等。但除了这些以外，设计异常的人其实还需要考虑一个重要指标——调用方是否能清晰区分各种异常。</p>\n<p>以 5.1.3 节的代码为例，在调用 <code>create_item()</code> 函数时，程序可能会抛出 <code>CreateItemError</code> 异常。所以调用方得用 <code>try</code> 来捕获该异常：</p>\n<pre class=\"code-rows\"><code>def create_from_input():\n    name = input()\n    try:\n        item = create_item(name)\n    except CreateItemError as e:\n        print(f'create item failed: ')\n    else:\n        print(f'item&lt;&gt; created')</code></pre>\n<p>假如调用方只需要像上面这样，简单判断创建过程有没有出错，现在的异常设计可以说已经足够了。</p>\n<p>但是，如果调用方想针对“<code>items</code> 已满”这类错误增加一些特殊逻辑，比如清空所有 <code>items</code>，我们就得把上面的代码改成下面这样：</p>\n<pre class=\"code-rows\"><code>def create_from_input():\n    name = input()\n    try:\n        item = create_item(name)\n    except CreateItemError as e:\n        # 如果已满，清空所有 items\n        if str(e) == 'items is full':\n            clear_all_items()\n\n        print(f'create item failed: ')\n    else:\n        print(f'item&lt;&gt; created')</code></pre>\n<p>虽然这段代码通过对比错误字符串实现了需求，但这种做法其实非常脆弱。假如 <code>create_item()</code> 未来稍微调整了一下异常错误信息，代码逻辑就会崩坏。</p>\n<p>为了解决这个问题，我们可以利用异常间的继承关系，设计一些更精准的异常子类：</p>\n<pre class=\"code-rows\"><code>class CreateItemError(Exception):\n    \"\"\"创建 Item 失败\"\"\"\n\n\nclass CreateErrorItemsFull(CreateItemError):\n    \"\"\"当前的 Item 容器已满\"\"\"\n\n\ndef create_item(name):\n    if len(name) &gt; MAX_LENGTH_OF_NAME:\n        raise CreateItemError('name of item is too long')\n    if len(get_current_items()) &gt; MAX_ITEMS_QUOTA:\n        raise CreateErrorItemsFull('items is full')\n    return Item(name=name)</code></pre>\n<p>这样做以后，调用方就能用额外的 <code>except</code> 子句来单独处理“<code>items</code> 已满”异常了，如下所示：</p>\n<pre class=\"code-rows\"><code>def create_from_input():\n    name = input()\n    try:\n        item = create_item(name)\n    except CreateErrorItemsFull as e:\n        clear_all_items()\n        print(f'create item failed: ')\n    except CreateItemError as e:\n        print(f'create item failed: ')\n    else:\n        print(f'item&lt;&gt; created')</code></pre>\n<p>除了设计更精确的异常子类外，你还可以创建一些包含额外属性的异常类，比如包含“错误代码”（<code>error_code</code>）的 <code>CreateItemError</code> 类：</p>\n<pre class=\"code-rows\"><code>class CreateItemError(Exception):\n    \"\"\"创建 Item 失败\n\n    :param error_code: 错误代码\n    :param message: 错误信息\n    \"\"\"\n\n    def __init__(self, error_code, message):\n        self.error_code = error_code\n        self.message = message\n        super().__init__(f' - ')\n\n\n# 抛出异常时指定 error_code\nraise CreateItemError('name_too_long', 'name of item is too long')\nraise CreateItemError('items_full', 'items is full')</code></pre>\n<p>这样调用方在捕获异常后，也能根据异常对象的 <code>error_code</code> 来精确分辨异常类型。</p>\n<h3 id=\"nav_point_99\">5.3.4　不要使用 <code>assert</code> 来检查参数合法性</h3>\n<p><code>assert</code> 是 Python 中用来编写断言语句的关键字，它可以用来测试某个表达式是否成立。比如：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; value = 10\n&gt;&gt;&gt; assert value &gt; 100\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAssertionError</code></pre>\n<p>当 <code>assert</code> 后面的表达式运行结果为 <code>False</code> 时，断言语句会马上抛出 <code>AssertionError</code> 异常。因此，有人可能会想着拿它来检查函数参数是否合法，就像下面这样：</p>\n<pre class=\"code-rows\"><code>def print_string(s):\n    assert isinstance(s, str), 's must be string'\n    print(s)</code></pre>\n<p>但这样做其实并不对。<code>assert</code> 是一个专供开发者调试程序的关键字。它所提供的断言检查，可以在执行 Python 时使用 <code>-O</code> 选项直接跳过：</p>\n<pre class=\"code-rows\"><code>$ python -O\n# -O 选项表示让所有 assert 断言语句无效化\n# 开启该选项后，下面的 assert 语句不会抛出任何异常\n&gt;&gt;&gt; assert False</code></pre>\n<p>因此，请不要拿 <code>assert</code> 来做参数校验，用 <code>raise</code> 语句来替代它吧：</p>\n<pre class=\"code-rows\"><code>def print_string(s):\n    if not isinstance(s, str):\n        raise TypeError('s must be string')\n    print(s)</code></pre>\n<h3 id=\"nav_point_100\">5.3.5　无须处理是最好的错误处理</h3>\n<p>虽然我们学习了许多错误处理技巧，但无论如何，对于所有编写代码的程序员来说，错误处理永远是一种在代码主流程之外的额外负担。</p>\n<p>假如在一个理想的环境里，我们的程序根本不需要处理任何错误，那该有多好。你别说，在 <em>A Philosophy of Software Design</em> 一书中，作者 John Ousterhout 分享过一个与之相关的有趣故事。</p>\n<p>在设计 Tcl 编程语言时，作者直言自己曾犯过一个大错误。在 Tcl 语言中，有一个用来删除某个变量的 <code>unset</code> 命令。在设计这个命令时，作者认为当人们用 <code>unset</code> 删除一个不存在的变量时，一定是不正常的，程序自然应该抛出一个错误。</p>\n<p>但在 Tcl 语言发布之后，作者惊奇地发现，当人们调用 <code>unset</code> 时，其实常常处在一种模棱两可的程序状态中——不确定变量是否存在。这时，<code>unset</code> 的设计就会让它用起来非常尴尬。大部分人在使用 <code>unset</code> 时，几乎都需要编写额外的代码来捕获 <code>unset</code> 可能抛出的错误。</p>\n<p>John Ousterhout 直言，如果可以重新设计 <code>unset</code> 命令，他会对它的职责做一些调整：不再把 <code>unset</code> 当成一种可能会失败的<strong>删除变量行为</strong>，而是把它当作一种<strong>确保某变量不存在</strong>的命令。当 <code>unset</code> 的职责改变后，即使变量不存在，它也可以不抛出任何错误，直接返回就好。</p>\n<p><code>unset</code> 命令的例子体现出了一种程序设计技巧：在设计 API 时，如果稍微调整一下思考问题的角度，修改 API 的抽象定义，那么那些原本需要处理的错误，也许就会神奇地消失。假如 API 不抛出错误，调用方也就不需要处理错误，这会大大减轻大家的心智负担。</p>\n<p>除了在设计 API 时考虑减少错误以外，“空对象模式”也是一个通过转换观念来避免错误处理的好例子。</p>\n<h4>空对象模式</h4>\n<p>Martin Fowler 在他的经典著作《重构》中，用一章详细说明了“空对象模式”（null object pattern）。简单来说，“空对象模式”就是本该返回 <code>None</code> 值或抛出异常时，返回一个符合正常结果接口的特制“空类型对象”来代替，以此免去调用方的错误处理工作。</p>\n<p>我们来看一个例子。现在有多份问卷调查的得分记录，全部为字符串格式，存放在一个列表中：</p>\n<pre class=\"code-rows\"><code>data = ['piglei 96', 'joe 100', 'invalid-data', 'roland $invalid_points', ...]</code></pre>\n<p>正常的得分记录是 <code> </code> 格式，但你会发现，有些数据明显不符合规范（比如 <code>invalid-data</code>）。现在我想写一个脚本，统计合格（大于等于 80）的得分记录总数，如代码清单 5-8 所示。</p>\n<blockquote>\n<p><strong>代码清单 5-8</strong>　统计合格的得分记录总数</p>\n</blockquote>\n<pre class=\"code-rows\"><code>QUALIFIED_POINTS = 80\n\nclass CreateUserPointError(Exception):\n    \"\"\"创建得分纪录失败时抛出\"\"\"\n\nclass UserPoint:\n    \"\"\"用户得分记录\"\"\"\n\n    def __init__(self, username, points):\n        self.username = username\n        self.points = points\n\n    def is_qualified(self):\n        \"\"\"返回得分是否合格\"\"\"\n        return self.points &gt;= QUALIFIED_POINTS\n\ndef make_userpoint(point_string):\n    \"\"\"从字符串初始化一条得分记录\n\n    :param point_string: 形如 piglei 1 的表示得分记录的字符串\n    :return: UserPoint 对象\n    :raises: 当输入数据不合法时返回 CreateUserPointError\n    \"\"\"\n    try:\n        username, points = point_string.split()\n        points = int(points)\n    except ValueError:\n        raise CreateUserPointError(\n            'input must follow pattern \" \"'\n        )\n\n    if points &lt; 0:\n        raise CreateUserPointError('points can not be negative')\n    return UserPoint(username=username, points=points)\n\ndef count_qualified(points_data):\n    \"\"\"计算得分合格的总人数\n\n    :param points_data: 字符串格式的用户得分列表\n    \"\"\"\n    result = 0\n    for point_string in points_data:\n        try:\n            point_obj = make_userpoint(point_string)\n        except CreateUserPointError:\n            pass\n        else:\n            result += point_obj.is_qualified()\n    return result\n\ndata = [\n    'piglei 96',\n    'nobody 61',\n    'cotton 83',\n    'invalid_data',\n    'roland $invalid_points',\n    'alfred -3',\n]\n\nprint(count_qualified(data))\n# 输出结果：\n# 2</code></pre>\n<p>在上面的代码里，因为输入数据可能不符合要求，所以 <code>make_userpoint()</code> 方法在解析输入数据、创建 <code>UserPoint</code> 对象的过程中，可能会抛出 <code>CreateUserPointError</code> 异常来通知调用方。</p>\n<p>因此，每当调用方使用 <code>make_userpoint()</code> 时，都必须加上 <code>try</code>/<code>except</code> 语句来捕获异常。</p>\n<p>假如引入“空对象模式”，上面的异常处理逻辑可以完全消失，如代码清单 5-9 所示。</p>\n<blockquote>\n<p><strong>代码清单 5-9</strong>　统计合格的得分记录总数（空对象模式）</p>\n</blockquote>\n<pre class=\"code-rows\"><code>QUALIFIED_POINTS = 80\n\nclass UserPoint:\n    \"\"\"用户得分记录\"\"\"\n\n    def __init__(self, username, points):\n        self.username = username\n        self.points = points\n\n    def is_qualified(self):\n        \"\"\"返回得分是否合格\"\"\"\n        return self.points &gt;= QUALIFIED_POINTS\n\nclass NullUserPoint:\n    \"\"\"一个空的用户得分记录\"\"\"\n\n    username = ''\n    points = 0\n\n    def is_qualified(self):\n    return False\n\ndef make_userpoint(point_string):\n    \"\"\"从字符串初始化一条得分记录\n\n    :param point_string: 形如 piglei 1 的表示得分记录的字符串\n    :return: 如果输入合法，返回 UserPoint 对象，否则返回 NullUserPoint\n    \"\"\"\n    try:\n        username, points = point_string.split()\n        points = int(points)\n    except ValueError:\n        return NullUserPoint()\n\n    if points &lt; 0:\n        return NullUserPoint()\n    return UserPoint(username=username, points=points)</code></pre>\n<p>在新版代码里，我定义了一个代表“空得分记录”的新类型：<code>NullUserPoint</code>，每当 <code>make_userpoint()</code> 接收到无效的输入，执行失败时，就会返回一个 <code>NullUserPoint</code> 对象。</p>\n<p>这样修改后，<code>count_qualified()</code> 就不再需要处理任何异常了：</p>\n<pre class=\"code-rows\"><code>def count_qualified(points_data):\n    \"\"\"计算得分合格的总人数\n\n    :param points_data: 字符串格式的用户得分列表\n    \"\"\"\n    return sum(make_userpoint(s).is_qualified() for s in points_data) ➊</code></pre>\n<blockquote>\n<p>❶ 这里的 <code>make_userpoint()</code> 总是会返回一个符合要求的对象（<code>UserPoint()</code> 或 <code>NullUserPoint()</code>）</p>\n</blockquote>\n<p>同前面 <code>unset</code> 命令的故事一样，“空对象模式”也是一种转换设计观念以避免错误处理的技巧。当函数进入边界情况时，“空对象模式”不再抛出错误，而是让其返回一个类似于正常结果的特殊对象，因此使用方自然就不必处理任何错误，人们写起代码来也会更轻松。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00372.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　在 Python 世界中，“空对象模式”并不少见，比如大名鼎鼎的 Django 框架里的 <code>AnonymousUser</code> 设计就应用了这个模式。</p>\n</blockquote>\n<h2 id=\"nav_point_101\">5.4　总结</h2>\n<p>在本章中，我们学习了在 Python 中使用异常和处理错误的一些经验和技巧。基础知识部分简单介绍了 LBYL 和 EAFP 两种编程风格。编写代码时，Pythonista 更倾向于使用基于异常捕获的 EAFP 风格。</p>\n<p>虽然 Python 函数允许我们同时返回结果和错误信息，但更地道的做法是抛出自定义异常。除了 <code>try</code> 语句外，<code>with</code> 语句也经常用来处理异常，自定义上下文管理器可以有效复用异常处理逻辑。</p>\n<p>在捕获异常时，过于模糊是不可取的，精确的异常捕获有助于我们写出更健壮的代码。有时，让程序提前崩溃也不一定是什么坏事。</p>\n<p>以下是本章要点知识总结。</p>\n<p>(1) 基础知识</p>\n<ul>\n<li>一个 <code>try</code> 语句支持多个 <code>except</code> 子句，但请记得把更精确的异常类放在前面</li>\n<li><code>try</code> 语句的 <code>else</code> 分支会在没有异常时执行，因此它可用来替代标记变量</li>\n<li>不带任何参数的 <code>raise</code> 语句会重复抛出当前异常</li>\n<li>上下文管理器经常用来处理异常，它最常见的用途是替代 <code>finally</code> 子句</li>\n<li>上下文管理器可以用来忽略某段代码里的异常</li>\n<li>使用 <code>@contextmanager</code> 装饰器可以轻松定义上下文管理器</li>\n</ul>\n<p>(2) 错误处理与参数校验</p>\n<ul>\n<li>当你可以选择编写条件判断或异常捕获时，优先选异常捕获（EAFP）</li>\n<li>不要让函数返回错误信息，直接抛出自定义异常吧</li>\n<li>手动校验数据合法性非常烦琐，尽量使用专业模块来做这件事</li>\n<li>不要使用 <code>assert</code> 来做参数校验，用 <code>raise</code> 替代它</li>\n<li>处理错误需要付出额外成本，假如能通过设计避免它就再好不过了</li>\n<li>在设计 API 时，需要慎重考虑是否真的有必要抛出错误</li>\n<li>使用“空对象模式”能免去一些针对边界情况的错误处理工作</li>\n</ul>\n<p>(3) 当你捕获异常时：</p>\n<ul>\n<li>过于模糊和宽泛的异常捕获可能会让程序免于崩溃，但也可能会带来更大的麻烦</li>\n<li>异常捕获贵在精确，只捕获可能抛出异常的语句，只捕获可能的异常类型</li>\n<li>有时候，让程序提早崩溃未必是什么坏事</li>\n<li>完全忽略异常是风险非常高的行为，大多数情况下，至少记录一条错误日志</li>\n</ul>\n<p>(4) 当你抛出异常时：</p>\n<ul>\n<li>保证模块内抛出的异常与模块自身的抽象级别一致</li>\n<li>如果异常的抽象级别过高，把它替换为更低级的新异常</li>\n<li>如果异常的抽象级别过低，把它包装成更高级的异常，然后重新抛出</li>\n<li>不要让调用方用字符串匹配来判断异常种类，尽量提供可区分的异常</li>\n</ul>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 4 章 条件分支控制流","id":740841},"right":{"article_title":"第 6 章 循环与可迭代对象","id":740843}},"comments":[]}