{"id":574783,"title":"04 | 如何通过组合、管道和reducer让函数抽象化？","content":"<p>你好，我是石川。</p><p>上节课我们讲到，通过部分应用和柯里化，我们做到了从抽象到具象化。那么，今天我们要讲的组合和管道，就是反过来帮助我们把函数<strong>从具象化变到抽象化</strong>的过程。它相当于是系统化地把不同的组件函数，封装在了只有一个入口和出口的函数当中。</p><p>其实，我们在上节课讲处理函数输入问题的时候，在介绍unary的相关例子中，已经看到了组合的雏形。在函数式编程里，组合（Composition）的概念就是把组件函数组合起来，形成一个新的函数。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/a0/5087972778481dd701518185a2866fa0.jpg?wh=1920x944\" alt=\"图片\"></p><p>我们可以先来看个简单的组合函数例子，比如要创建一个“判断一个数是否为奇数”的isOdd函数，可以先写一个“计算目标数值除以2的余数”的函数，然后再写一个“看结果是不是等于1”的函数。这样，isOdd函数就是建立在两个组件函数的基础上。</p><pre><code class=\"language-javascript\">var isOdd = compose(equalsToOne, remainderOfTwo);\n</code></pre><p>不过，你会看到这个组合的顺序是反直觉的，因为如果按照正常的顺序，应该是先把remainderByTwo放在前面来计算余数，然后再执行后面的equalsToOne， 看结果是不是等于1。</p><p>那么，这里为什么会有一个反直觉的设计呢？今天这节课，我们就通过回答这个问题，来看看组合和管道要如何做到抽象化，而reducer又是如何在一系列的操作中，提高针对值的处理性能的。</p><!-- [[[read_end]]] --><h2>组合Compose</h2><p>在讲组合前，我想先带你来看看Point-Free和函数组件。这里，我们还是用刚刚提到的“判断一个值是不是奇数”的isOdd函数，来一步步看下它的实现。</p><h3>Point-Free</h3><p>那么首先，什么是Point-Free呢？实际上，Point-Pree是函数式编程中的一种编程风格，其中的Point是指参数，free是指没有。加在一起，Point-Free的意思就是<strong>没有参数的函数</strong>。</p><p>而这样做的目的是什么呢？其实通过这种方式，就可以将一个函数和另外一个函数结合起来，形成一个新函数。比如，为了要创建isOdd函数，通过这种方式，我们就可以把这两个函数“组合”在一起，得到isOdd。</p><pre><code class=\"language-javascript\">var isOdd = (x) =&gt; equalsToOne(remainderOfTwo(x));\n</code></pre><h3>函数组件</h3><p>接着，我们再来看函数组件。</p><p>在以下的代码示例当中，我们先定义了两个函数：第一个是dividedBy，它的作用是计算x除以y的余数；第二个是equalsTo，它是用来看余数是否等于1。</p><p>这两个函数其实就是我们用到的组件函数。你可以发现，这两个组件的特点都是努力专注做好一件小事。</p><pre><code class=\"language-javascript\">var dividedBy = (y) =&gt; {\n    return function forX(x) {\n        return x % y;\n    }\n}\nvar equalsTo = (y) =&gt; {\n    return function forX(x) {\n        return x === y;\n    }\n}\n</code></pre><p>然后，在dividedBy和equalsToOne的基础上，我们就可以创建两个Point-Free的函数，remainderOfTwo和equalsToOne。</p><pre><code class=\"language-javascript\">var remainderOfTwo = dividedBy(2);\nvar equalsToOne = equalsTo(1);\n</code></pre><p>最后，我们只需要传入参数 x，就可以计算相应的isOdd的结果了。</p><pre><code class=\"language-javascript\">var isOdd = (x) =&gt; equalsToOne(remainderOfTwo(x));\n</code></pre><p>好了，现在我们知道了，函数是可以通过写成组件来应用的。这里其实就是用到了函数式编程<strong>声明式</strong>的思想，equalsToOne和remainderByTwo，不仅把过程进行了封装，而且把参数也去掉了，暴露给使用者的就是<strong>功能本身</strong>。所以，我们只需要把这两个函数组件的功能结合起来，就可以实现isOdd函数了。</p><h3>独立的组合函数</h3><p>下面我们再来看看独立的组合函数。</p><p>其实从上面的例子里，我们已经看到了组合的影子。那么更进一步地，我们就可以把组合抽象成一个独立的函数，如下所示：</p><pre><code class=\"language-javascript\">function compose(...fns) {\n&nbsp; &nbsp; return fns.reverse().reduce( function reducer(fn1,fn2){\n&nbsp; &nbsp; &nbsp; &nbsp; return function composed(...args){\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return fn2( fn1( ...args ) );\n&nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; } );\n}\n</code></pre><p>也就是说，基于这里抽象出来的compose功能，我们可以把之前的组件函数组合起来。</p><pre><code class=\"language-javascript\">var isOdd = compose(equalsToOne, remainderOfTwo);\n</code></pre><p>所以，回到课程一开始提到的问题：为什么组合是反直觉的？因为它是按照<strong>传参顺序</strong>来排列的。</p><p>前面讲的这个组合，其实就是 <code>equalsToOne(remainderOfTwo(x))</code>。在数学中，组合写成 <code>fog</code>，意思就是一个函数接收一个参数x，并返回成一个 <code>f(g(x))</code>。</p><p>好，不过看到这里，你可能还是觉得，即使自己理解了它的概念，但是仍然觉得它反直觉，因此想要一种更直观的顺序来完成一系列操作。这个也有相应的解决方案，那就是用函数式编程中的<strong>管道</strong>。</p><h2>管道Pipeline</h2><p>函数式编程中的管道，是另外一种函数的创建方式。这样创建出来的函数的特点是：<strong>一个函数的输出会作为下一个函数的输入，然后按顺序执行</strong>。</p><p>所以，管道就是以组合反过来的方式来处理的。</p><h3>Unix/Linux中的管道</h3><p>其实管道的概念最早是源于Unix/Linux，这个概念的创始人道格拉斯·麦克罗伊（Douglas McIlroy）在贝尔实验室的文章中，曾经提到过两个很重要的点：</p><ul>\n<li>一是让每个程序只专注做好一件事。如果有其它新的任务，那么应该重新构建，而不是通过添加新功能使旧程序复杂化。</li>\n<li>二是让每个程序的输出，可以成为另一个程序的输入。</li>\n</ul><p><span class=\"reference\">感兴趣的话你也可以读一下<a href=\"http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf\">这篇杂志文章</a>，虽然这是1978年的文章，但是它的设计思想到现在都不算过时。</span></p><p><img src=\"https://static001.geekbang.org/resource/image/41/43/413491e226569ec2b52ed3f1e397b543.jpg?wh=1920x355\" alt=\"图片\"></p><p>好，那么现在，我们就来看一个简单的管道例子，在这个例子里，我们可以找到当前目录下面所有的JavaScript文件。</p><pre><code class=\"language-powershell\">$ ls -1 | grep \"js$\" | wc -l\n</code></pre><p>你能发现，这个管道有竖线“ | ”隔开的三个部分。第一个部分 <code>ls -1</code>，列出并返回了当前目录下所有的文件，这个结果作为了第二步 <code>grep \"js$\"</code> 的输入；第二个部分会过滤出所有的以 <code>js</code> 结尾的文件；然后第二步的结果会作为第三部分的输入，在第三步，我们会看到最后计算的结果。</p><h3>JavaScript中的管道</h3><p>回到JavaScript中，我们也可以用isOdd的例子，来看看同样的功能要如何通过管道来实现。</p><p>其实也很简单，我们只需要通过一个reverseArgs函数，将compose中接收参数的顺序反过来即可。</p><p>你可能会想到我们在上节课讲unary的时候，是把函数的输入参数减少到1，而这里是<strong>把参数做倒序处理，生成一个新的函数</strong>。在函数式编程中，这算是一个比较经典的高阶函数的例子。</p><pre><code class=\"language-javascript\">function reverseArgs(fn) {\n&nbsp; &nbsp; return function argsReversed(...args){\n&nbsp; &nbsp; &nbsp; &nbsp; return fn( ...args.reverse() );\n&nbsp; &nbsp; };\n}\n\nvar pipe = reverseArgs( compose );\n</code></pre><p>然后我们可以测试下管道是否“畅通”。这次，我们把remainderOfTwo和equalsToOne按照比较直观的方式进行排序。</p><p>可以看到，isOdd(1)返回的结果是true，isOdd(2)返回的结果是false，和我们预期的结果是一样的。</p><pre><code class=\"language-javascript\">const isOdd = pipe(remainderOfTwo, equalsToOne);\n\nisOdd(1); // 返回 true\nisOdd(2); // 返回 false\n</code></pre><h2>Transduction</h2><p>讲完了组合和管道之后，还有一个地方想再跟你强调下。</p><p>我一再说过，函数式编程中的很多概念，都来自于对复杂、动力系统研究与控制等领域。而通过组合和管道，我们可以再延伸来看一下转导（transducing）。</p><p><strong>转导主要用于控制系统</strong>（Control System），比如声波作为输入，通过麦克风进入到一个功放，然后功放进行能量转换，最后通过喇叭传出声音的这样一个系统，就可以成为转导。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/c4/ccf13111a8c165e93da865dcdf1b44c4.jpg?wh=1920x614\" alt=\"图片\"></p><p>当然，单独看这个词，你或许并没有什么印象，但是如果说React.js，你应该知道这是一个很著名的前端框架。在这里面的reducer的概念，就用到了transducing。</p><p>在后面的课程中，我们讲到响应式编程和观察者模式的时候，还会更深入了解reducer。这里，我们就先来看看transduce和reducer的作用以及原理。</p><p>那么，<strong>reducer是做什么用的呢？</strong>它最主要的作用其实是解决在使用多个map、filter、reduce操作大型数组时，可能会发生的性能问题。</p><p>而通过使用transducer和reducer，我们就可以优化一系列map、filter、reduce操作，使得输入数组只被处理一次并直接产生输出结果，而不需要创建任何中间数组。</p><p>可能我这么讲，你还是不太好理解，这里我们先来举一个不用tansducer或reducer例子吧。</p><pre><code class=\"language-javascript\">var oldArray = [36, 29, 18, 7, 46, 53];\nvar newArray = oldArray\n  .filter(isEven)\n  .map(double)\n  .filter(passSixty)\n  .map(addFive);\n  \nconsole.log (newArray); // 返回：[77,97]\n</code></pre><p>在这个例子里，我们对一组数组进行了一系列的操作，先是筛选出奇数，再乘以二，之后筛出大于六十的值，最后加上五。在这个过程中，会不断生成中间数组。</p><p>这个实际发生的过程如下图左半部分所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/45/aa5dbd1ff55485d4c596e77801759545.jpg?wh=1920x1080\" alt=\"图片\"></p><p>而如果使用reducer的话，我们对每个值只需要操作一次，就可产出最终的结果。如上图的右半部分所示。</p><p>那么它是如何实现的呢？在这里，我们是先将一个函数，比如isEven作为输入，放到了一个transducer里，然后作为输出，我们得到的是一个isEvenR的reducer函数。</p><p>是的，这里的transducer其实也是一个经典的高阶函数（即输入一个函数，得到一个新的函数）的例子！</p><p>实际上，像 <strong>double和addFive都具有映射类的功能</strong>，所以我们可以通过一个类似mapReducer这样的一个transducer，来把它们转换成reducer。而像 <strong>isEven和passSixty都是筛选类的功能</strong>，所以我们可以通过一个类似filterReducer这样的一个transducer，来把它们转换成 reducer。</p><p>如果我们抽象化来看，其代码大致如下。它的具体实现这里我卖个关子，你可以先自己思考下，我们下节课再探讨。</p><pre><code class=\"language-javascript\">var oldArray = [36, 29, 18, 7, 46, 53];\n\nvar newArray = composeReducer(oldArray, [\n  filterTR(isEven),\n  mapTR(double),\n  filterTR(passSixty),\n  mapTR(addFive),\n]); \n\nconsole.log (newArray); // 返回：[77,97]\n</code></pre><p>总而言之，从上面的例子中，我们可以看出来composeReducer用的就是一个类似组合的功能。</p><h2>总结</h2><p>这节课通过对组合和管道的了解，相信你可以看出来，它们和上节课我们讲到的部分应用和柯里化正好相反，一个是从具象走向抽象，一个是从抽象走向具象。</p><p>不过，虽然说它们的方向是相反的，但有一条原则是一致的，那就是<strong>每个函数尽量有一个单一职责，只专注做好一件事</strong>。</p><p>值得注意的是，这里的方向不同，并不是指我们要用抽象取代具象，或者是用具象取代抽象。而是说它们都是为了<strong>单一职责函数</strong>的原则，相辅相成地去具象化或抽象化。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/16/691043e9f3cayy8fc8c03934b4daaf16.jpg?wh=1920x807\" alt=\"图片\"></p><p>另外，通过reducer的例子，我们也知道了如何通过reducer的组合，做到普通的组合达不到的<strong>性能提升</strong>。</p><p>在这节课里，我们是先从一个抽象层面理解了reducer，不过你可能仍然对map、filter、reduce等概念和具体实现感到有些陌生。不用担心，下节课我就带你来进一步了解这一系列针对值的操作工具的机制，以及functor和monad。</p><h2>思考题</h2><p>我们讲到reduce可以用来实现map和filter ，那么你知道这背后的原理吗？欢迎在留言区分享你的答案，或者你如果对此并不十分了解，也希望你能找找资料，作为下节课的预习内容。</p><p>当然，你也可以在评论区交流下自己的疑问，我们一起讨论、共同进步。</p>","neighbors":{"left":{"article_title":"03 | 如何通过部分应用和柯里化让函数具象化？","id":574132},"right":{"article_title":"05｜map、reduce和monad如何围绕值进行操作？","id":576500}},"comments":[{"had_liked":false,"id":358418,"user_name":"鐘","can_delete":false,"product_type":"c1","uid":1518535,"ip_address":"北京","ucode":"0106652D5F7BD9","user_header":"https://static001.geekbang.org/account/avatar/00/17/2b/c7/9c8647c8.jpg","comment_is_top":false,"comment_ctime":1664281466,"is_pvip":false,"replies":[{"id":130636,"content":"帥！！","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1665327380,"ip_address":"北京","comment_id":358418,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"靜下心來重看一次, 好像看懂了, 以下是我對於 composeReducer 的實作：\n\n```\nconst { filterTR, mapTR, composeReducer } = (() =&gt; {\n\tfunction applyTypeForFunction(fn, type) {\n\t\tfn.type = type;\n\t\treturn fn;\n\t}\n\n\tfunction filterTR(fn) {\n\t\treturn applyTypeForFunction(fn, &quot;filter&quot;);\n\t}\n\n\tfunction mapTR(fn) {\n\t\treturn applyTypeForFunction(fn, &quot;map&quot;);\n\t}\n\n\tfunction composeReducer(inputArray, fnArray) {\n\t\treturn inputArray.reduce((sum, element) =&gt; {\n\t\t\tlet tmpVal = element;\n\t\t\tlet tmpFn;\n\n\t\t\tfor (let i = 0; i &lt; fnArray.length; i++) {\n\t\t\t\ttmpFn = fnArray[i];\n\t\t\t\tif (tmpFn.type === &quot;filter&quot; &amp;&amp; tmpFn(tmpVal) === false) {\n\t\t\t\t\tconsole.log(`failed to pass filter: ${element} `);\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t\tif (tmpFn.type === &quot;map&quot;) {\n\t\t\t\t\ttmpVal = tmpFn(tmpVal);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log(`${element} pass, result = ${tmpVal}`);\n\t\t\tsum.push(tmpVal);\n\n\t\t\treturn sum;\n\t\t}, []);\n\t}\n\n\treturn {\n\t\tfilterTR,\n\t\tmapTR,\n\t\tcomposeReducer\n\t};\n})();\n\nconst isEven = (v) =&gt; v % 2 === 0;\nconst passSixty = (v) =&gt; v &gt; 60;\nconst double = (v) =&gt; 2 * v;\nconst addFive = (v) =&gt; v + 5;\n\nvar oldArray = [36, 29, 18, 7, 46, 53];\nvar newArray = composeReducer(oldArray, [\n\tfilterTR(isEven),\n\tmapTR(double),\n\tfilterTR(passSixty),\n\tmapTR(addFive)\n]);\n\nconsole.log(newArray);\n```","like_count":10,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589823,"discussion_content":"帥！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665327380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2641149,"avatar":"https://static001.geekbang.org/account/avatar/00/28/4c/fd/2e4cd48f.jpg","nickname":"见字如晤","note":"","ucode":"2CBA86D3254B85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617170,"discussion_content":"有大问题，applyTypeForFunction接受一个函数，并给这个函数赋予一个type，但函数是引用类型，也就是说，composeReducer中的第二个参数数组中同一个函数，不能以不同的type使用两次，因为第二次的type会覆盖掉第一次的，导致计算错误。此处只存在filter和map两种type，能同时应用于两种type的函数可能还少，但如果再加一种filterReverse的type用于保留未通过测试函数的所有元素，类型冲突就更容易产生了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1683360048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1518535,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2b/c7/9c8647c8.jpg","nickname":"鐘","note":"","ucode":"0106652D5F7BD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2641149,"avatar":"https://static001.geekbang.org/account/avatar/00/28/4c/fd/2e4cd48f.jpg","nickname":"见字如晤","note":"","ucode":"2CBA86D3254B85","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654681,"discussion_content":"改了一版, 用物件存就可以解決您說的問題了\n```\nconst { filterTR, mapTR, composeReducer } = (() =&gt; {\n\tconst applyTypeForFunction = (fn, type) =&gt; ({ type, fn });\n\tconst filterTR = (fn) =&gt; {\n\t\treturn applyTypeForFunction(fn, &#34;filter&#34;);\n\t};\n\tconst mapTR = (fn) =&gt; {\n\t\treturn applyTypeForFunction(fn, &#34;map&#34;);\n\t};\n\n\tconst composeReducer = (inputs, fns) =&gt; {\n\t\treturn inputs.reduce((sum, input) =&gt; {\n\t\t\tconst result = fns.reduce(\n\t\t\t\t(acc, { type, fn }) =&gt; {\n\t\t\t\t\tif (acc.passed === false) return acc;\n\t\t\t\t\tif (type === &#34;filter&#34;) {\n          \t\tacc.passed = fn(acc.val)  \n\t\t\t\t\t\t\treturn acc\n\t\t\t\t\t}\n\t\t\t\t\tif (type === &#34;map&#34;) {\n\t\t\t\t\t\tacc.val = fn(acc.val)\n            return acc\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{ passed: true, val: input }\n\t\t\t);\n\n\t\t\tif (result.passed === true) sum.push(result.val);\n\t\t\treturn sum;\n\t\t}, []);\n\t};\n\n\treturn {\n\t\tfilterTR,\n\t\tmapTR,\n\t\tcomposeReducer\n\t};\n})();\n\nconst isEven = (v) =&gt; v % 2 === 0;\nconst isAboveSixty = (v) =&gt; v &gt; 60;\nconst double = (v) =&gt; 2 * v;\nconst addFive = (v) =&gt; v + 5;\nconst oldArray = [32, 15, 40, 2];\n\nconst newArray = composeReducer(oldArray, [\n\tfilterTR(isEven),\n\tmapTR(double),\n\tfilterTR(isAboveSixty),\n\tmapTR(addFive)\n]);\n\nconsole.log(newArray); // 返回：[69.85]\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733233405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":617170,"ip_address":"中国台湾","group_id":0},"score":654681,"extra":""}]}]},{"had_liked":false,"id":358366,"user_name":"卡卡","can_delete":false,"product_type":"c1","uid":1379414,"ip_address":"北京","ucode":"C50FF72A04F742","user_header":"https://static001.geekbang.org/account/avatar/00/15/0c/56/9b2bca2f.jpg","comment_is_top":false,"comment_ctime":1664248635,"is_pvip":false,"replies":[{"id":130434,"content":"是的，这里利用了reduce的第二个参数的初始值可以是一个“空数组”，映射或过滤后，放入“新数组”。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1664354742,"ip_address":"北京","comment_id":358366,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"我的理解是：reduce可以对原集合的每个元素使用map回调函数进行映射或者使用filter回调函数进行过滤，然后将新值放入新的集合\n\nmapReduce的实现：\nArray.prototype.mapReduce = function (cb, initValue) {\n  return this.reduce(function (mappedArray, curValue, curIndex, array) {\n    mappedArray[curIndex] = cb.call(initValue, curValue, curIndex, array);\n    return mappedArray;\n  }, []);\n};\n\nfilterReduce的实现：\nArray.prototype.filterReduce = function (cb, initValue) {\n  return this.reduce(function (mappedArray, curValue, curIndex, array) {\n    if (cb.call(initValue, curValue, curIndex, array)) {\n      mappedArray.push(curValue);\n    }\n    return mappedArray;\n  }, []);\n};","like_count":5,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589033,"discussion_content":"是的，这里利用了reduce的第二个参数的初始值可以是一个“空数组”，映射或过滤后，放入“新数组”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664354742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361934,"user_name":"雨中送陈萍萍","can_delete":false,"product_type":"c1","uid":1457879,"ip_address":"北京","ucode":"409FA76EEED669","user_header":"https://static001.geekbang.org/account/avatar/00/16/3e/d7/399d2ba5.jpg","comment_is_top":false,"comment_ctime":1667983838,"is_pvip":false,"replies":[{"id":132381,"content":"对，compose就是天然的pointfree。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1670656438,"ip_address":"北京","comment_id":361934,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"看了下阮老师对PointFree风格的描述(https:&#47;&#47;www.ruanyifeng.com&#47;blog&#47;2017&#47;03&#47;pointfree.html)，可以直接简单理解成对多个运算过程的合成，不涉及到具体值的处理，所以compose和pipeline就是这种风格.","like_count":2,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596097,"discussion_content":"对，compose就是天然的pointfree。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670656438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2100301,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0c/4d/90ab20d8.jpg","nickname":"Nuvole Bianche","note":"","ucode":"3C059A454C16C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599955,"discussion_content":"感谢分享扫盲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673917231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358475,"user_name":"I keep my ideals💤","can_delete":false,"product_type":"c1","uid":1483413,"ip_address":"北京","ucode":"38E68A0BCABA01","user_header":"https://static001.geekbang.org/account/avatar/00/16/a2/95/8f34237c.jpg","comment_is_top":false,"comment_ctime":1664346657,"is_pvip":false,"replies":[{"id":130501,"content":"1. 异步可以考虑结合CPS的promise&#47;then，或 async&#47;await来解决。\n2. 没有返回值，可以考虑用Just和Nothing组成Maybe monad。\n3. 多条件分支的情况下可以考虑在Maybe monad中创建orElse的方法。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1664691370,"ip_address":"北京","comment_id":358475,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"想请教一下老师compose组合的新函数里面如果有某一个是异步函数，或者没有返回值的情况下该怎么处理呢。还有多条件分支的情况下又该如何处理呢","like_count":2,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589321,"discussion_content":"1. 异步可以考虑结合CPS的promise/then，或 async/await来解决。\n2. 没有返回值，可以考虑用Just和Nothing组成Maybe monad。\n3. 多条件分支的情况下可以考虑在Maybe monad中创建orElse的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664691370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363654,"user_name":"程序员一土","can_delete":false,"product_type":"c1","uid":3202470,"ip_address":"北京","ucode":"A7EDE9DAB229B7","user_header":"https://static001.geekbang.org/account/avatar/00/30/dd/a6/4d0c9ee6.jpg","comment_is_top":false,"comment_ctime":1669944906,"is_pvip":false,"replies":[{"id":132382,"content":"在采用某种风格的时候，还是要掌握一个度","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1670657029,"ip_address":"北京","comment_id":363654,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"业务上函数拆这么细会被打吧","like_count":1,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596099,"discussion_content":"在采用某种风格的时候，还是要掌握一个度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670657029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358653,"user_name":"深山何处钟","can_delete":false,"product_type":"c1","uid":1100117,"ip_address":"北京","ucode":"5D42024E40D751","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/55/3b2526ce.jpg","comment_is_top":false,"comment_ctime":1664518859,"is_pvip":false,"replies":[{"id":130634,"content":"如果不用reverseArgs，pipe是可以简单理解成这样的： \nvar pipe = (...fns) =&gt; (x) =&gt; fns.reduce((v, f) =&gt; f(v), x);","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1665312905,"ip_address":"北京","comment_id":358653,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"请问老师，compose那个函数，直接fns后不接reverse，是不是就是pipe的效果呢？","like_count":1,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589805,"discussion_content":"如果不用reverseArgs，pipe是可以简单理解成这样的： \nvar pipe = (...fns) =&gt; (x) =&gt; fns.reduce((v, f) =&gt; f(v), x);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665312905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358362,"user_name":"天择","can_delete":false,"product_type":"c1","uid":2166878,"ip_address":"北京","ucode":"ED2B08DB2F2B38","user_header":"https://static001.geekbang.org/account/avatar/00/21/10/5e/42f4faf7.jpg","comment_is_top":false,"comment_ctime":1664246063,"is_pvip":true,"replies":[{"id":130425,"content":"嗯嗯，是这样的，无论具象还是抽象，目的都是学以致用","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1664331079,"ip_address":"北京","comment_id":358362,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"最近两篇文章的知识常在框架和库的代码里面见到，也会给我们阅读源码提供帮助。\n具体和抽象都是为使用目标服务的，不管是柯里化还是函数组件，都是给使用者提供某种场景下的便利性，只不过有的需要具体的手段，有的需要抽象的手段。","like_count":1,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589006,"discussion_content":"嗯嗯，是这样的，无论具象还是抽象，目的都是学以致用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1664331079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358359,"user_name":"天择","can_delete":false,"product_type":"c1","uid":2166878,"ip_address":"北京","ucode":"ED2B08DB2F2B38","user_header":"https://static001.geekbang.org/account/avatar/00/21/10/5e/42f4faf7.jpg","comment_is_top":false,"comment_ctime":1664245753,"is_pvip":true,"replies":[{"id":130426,"content":"是这样的","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1664332206,"ip_address":"北京","comment_id":358359,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"point free的理解：把参数去掉，是指参数的含义已经体现在函数声明（名字）里面了，比如equalsToOne，那就是说传入的值是否等于1，如果是equalsToA，那么这个A就得传为参数，加上要比较的x就是两个参数了。这就是所谓“暴露给使用者的就是功能本身”。","like_count":1,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589008,"discussion_content":"是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664332206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364707,"user_name":"WGH丶","can_delete":false,"product_type":"c1","uid":1922568,"ip_address":"海南","ucode":"02E43256770C62","user_header":"https://static001.geekbang.org/account/avatar/00/1d/56/08/bd75f114.jpg","comment_is_top":false,"comment_ctime":1671363841,"is_pvip":false,"replies":[{"id":133029,"content":"这样做的目的就是从右往左reduce哈，另外一种方式就是用reduceRight，这样就不需要reverse了。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1672277941,"ip_address":"海南","comment_id":364707,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"function compose(...fns) {\n    return fns.reverse().reduce( function reducer(fn1,fn2){\n        return function composed(...args){\n            return fn2( fn1( ...args ) );\n        };\n    } );\n}\n\n\n老师好，请教下：这里如果不用reverse，且交换下fn1，fn2的执行顺序能达到同样的效果。之所以使用reverse，是为了保证fn1先于fn2执行吗，还是别的原因？","like_count":0,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597842,"discussion_content":"这样做的目的就是从右往左reduce哈，另外一种方式就是用reduceRight，这样就不需要reverse了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672277942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"海南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361964,"user_name":"23568","can_delete":false,"product_type":"c1","uid":3209019,"ip_address":"海南","ucode":"B0CD476488A689","user_header":"https://static001.geekbang.org/account/avatar/00/30/f7/3b/b94f06bb.jpg","comment_is_top":false,"comment_ctime":1668009362,"is_pvip":false,"replies":[{"id":133052,"content":"一开始筛的是偶数：\n第1次筛出来的偶数是 [36, 18, 46];\n第2次乘以2的数值是 [72, 36, 92];\n第3次筛大于60的是 [72, 92];\n第4次加上5的数值是 [77, 97]。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1672313944,"ip_address":"海南","comment_id":361964,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"\nvar oldArray = [36, 29, 18, 7, 46, 53];\n\nvar newArray = composeReducer(oldArray, [\n  filterTR(isEven),\n  mapTR(double),\n  filterTR(passSixty),\n  mapTR(addfive),\n]); \n\nconsole.log (newArray); &#47;&#47; 返回：[77,97]\n\n“在这个例子里，我们对一组数组进行了一系列的操作，先是筛选出奇数，再乘以二，之后筛出大于六十的值，最后加上五。在这个过程中，会不断生成中间数组。”\n看返回结果是 [77, 97] ，这里好像筛选出来的是奇数吧老师\n","like_count":0,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597908,"discussion_content":"一开始筛的是偶数：\n第1次筛出来的偶数是 [36, 18, 46];\n第2次乘以2的数值是 [72, 36, 92];\n第3次筛大于60的是 [72, 92];\n第4次加上5的数值是 [77, 97]。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672313944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"海南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360620,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"北京","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1666692807,"is_pvip":true,"replies":[{"id":131625,"content":"好建议，我先记一下，看看后面有没有机会说到。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1667957365,"ip_address":"北京","comment_id":360620,"utype":1}],"discussion_count":1,"race_medal":1,"score":3,"product_id":100122101,"comment_content":"经常写函数式代码的时候函数套函数，不知道如何高效调试，不知道老师后面有没有经验分享。","like_count":0,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":593101,"discussion_content":"好建议，我先记一下，看看后面有没有机会说到。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667957365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359819,"user_name":"laoergege","can_delete":false,"product_type":"c1","uid":1288733,"ip_address":"北京","ucode":"559CCF36805A04","user_header":"https://static001.geekbang.org/account/avatar/00/13/aa/1d/b8fdd622.jpg","comment_is_top":false,"comment_ctime":1665933320,"is_pvip":false,"replies":[{"id":131018,"content":"因为这里是compose，不是pipeline，所以需要reverse。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1666316219,"ip_address":"北京","comment_id":359819,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100122101,"comment_content":"```js\n\nfunction compose(...fns) {\n    return fns.reverse().reduce( function reducer(fn1,fn2){\n        return function composed(...args){\n            return fn2( fn1( ...args ) );\n        };\n    } );\n}\n```\n这里 reverse 是不是多余了。。","like_count":0,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591131,"discussion_content":"因为这里是compose，不是pipeline，所以需要reverse。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666316219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359721,"user_name":"CondorHero","can_delete":false,"product_type":"c1","uid":1528334,"ip_address":"北京","ucode":"BD850FE812D22F","user_header":"https://static001.geekbang.org/account/avatar/00/17/52/0e/c5ff46d2.jpg","comment_is_top":false,"comment_ctime":1665803010,"is_pvip":false,"replies":[{"id":131017,"content":"这里是说remainderOfTwo和equalsToOne是point-free。isOdd是传参的，所以它不算是point-free。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1666316111,"ip_address":"北京","comment_id":359721,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100122101,"comment_content":"Point-Free 这个例子是不是不对，毕竟 x 参数被显示定义了。\n&#47;&#47; Not point-free - `x` is an explicit argument\nvar isOdd = (x) =&gt; equalsToOne(remainderOfTwo(x));\n\nPointe-Free Style\n\n定义函数时，不显式地指出函数所带参数。这种风格通常需要柯里化或者高阶函数。也叫 Tacit programming。\n\n&#47;&#47; 已知：\nconst map = (fn) =&gt; (list) =&gt; list.map(fn)\nconst add = (a) =&gt; (b) =&gt; a + b\n\n&#47;&#47; 所以：\n\n&#47;&#47; 非Points-Free —— number 是显式参数\nconst incrementAll = (numbers) =&gt; map(add(1))(numbers)\n\n&#47;&#47; Points-Free —— list 是隐式参数\nconst incrementAll2 = map(add(1))\n\nincrementAll 识别并且使用了 numbers 参数，因此它不是 Point-Free 风格的。 incrementAll2 仅连接函数与值，并不提及它所使用的参数，因为它是 Point-Free 风格的。\n\nPoint-Free 风格的函数就像平常的赋值，不使用 function 或者 =&gt;。","like_count":0,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591130,"discussion_content":"这里是说remainderOfTwo和equalsToOne是point-free。isOdd是传参的，所以它不算是point-free。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1666316111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358463,"user_name":"灯火阑珊","can_delete":false,"product_type":"c1","uid":1289991,"ip_address":"北京","ucode":"D07A1D2101B9A9","user_header":"https://static001.geekbang.org/account/avatar/00/13/af/07/a32e3f4e.jpg","comment_is_top":false,"comment_ctime":1664335230,"is_pvip":false,"replies":[{"id":130489,"content":"是的，说明生活中的例子无处不在。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1664678319,"ip_address":"北京","comment_id":358463,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100122101,"comment_content":"我是从制造业转行的，对pipe和流水线有天然的接受度，上个工序的半成品就是下个工序的入参。","like_count":0,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589303,"discussion_content":"是的，说明生活中的例子无处不在。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664678320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380747,"user_name":"晴空万里","can_delete":false,"product_type":"c1","uid":1181835,"ip_address":"广东","ucode":"6470D4B84A4D8E","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/8b/1b7d0463.jpg","comment_is_top":false,"comment_ctime":1694083590,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100122101,"comment_content":"从第二节开始作为一个初学者感觉很费劲是不是得补充点基础课？","like_count":0},{"had_liked":false,"id":366226,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"北京","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1673492886,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100122101,"comment_content":"我理解使用composeReducer或者管道计算步骤没有变（因为每个函数还是单一功能），区别是composeReducer将计算过程在内部组装好了，并且计算的中间值也是由composeReducer内部进行传递，所以从封装角度来看文章中的案例，composeReducer的封装程度要高于管道。\n\n附上我的composeReducer版本：\n\nconst filterTR = (condition) =&gt; (value) =&gt; value.filter(condition);\n\nconst mapTR = (mapValue) =&gt; (value) =&gt; value.map(mapValue);\n\nfunction composeReducer(val, reducerlist) {\n  return reducerlist.reduce((total, cur) =&gt; cur(total), val);\n}\n\nfunction isEven(val) {\n  return val % 2 === 0;\n}\n\nfunction double(val) {\n  return val * 2;\n}\n\nfunction passSixty(val) {\n  return val &gt; 60;\n}\n\nfunction addFive(val) {\n  return val + 5;\n}\n\nvar oldArray = [36, 29, 18, 7, 46, 53];\nvar newArray = composeReducer(oldArray, [filterTR(isEven), mapTR(double), filterTR(passSixty), mapTR(addFive)]);\nconsole.log(newArray); &#47;&#47; 返回：[77,97]","like_count":0}]}