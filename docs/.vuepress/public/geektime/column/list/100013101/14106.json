{"id":14106,"title":"07 | 数组和切片","content":"<p>从本篇文章开始，我们正式进入了模块2的学习。在这之前，我们已经聊了很多的Go语言和编程方面的基础知识，相信你已经对Go语言的开发环境配置、常用源码文件写法，以及程序实体（尤其是变量）及其相关的各种概念和编程技巧（比如类型推断、变量重声明、可重名变量、类型断言、类型转换、别名类型和潜在类型等）都有了一定的理解。</p><p>它们都是我认为的Go语言编程基础中比较重要的部分，同时也是后续文章的基石。如果你在后面的学习过程中感觉有些吃力，那可能是基础仍未牢固，可以再回去复习一下。</p><hr><p>我们这次主要讨论Go语言的数组（array）类型和切片（slice）类型。数组和切片有时候会让初学者感到困惑。</p><p>它们的共同点是都属于集合类的类型，并且，它们的值也都可以用来存储某一种类型的值（或者说元素）。</p><p>不过，它们最重要的不同是：<strong>数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。</strong></p><p>数组的长度在声明它的时候就必须给定，并且之后不会再改变。可以说，数组的长度是其类型的一部分。比如，<code>[1]string</code>和<code>[2]string</code>就是两个不同的数组类型。</p><p>而切片的类型字面量中只有元素的类型，而没有长度。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/ed/6c/edb5acaf595673e083cdcf1ea7bb966c.png?wh=1018*454\" alt=\"\"></p><p>（数组与切片的字面量）</p><p>我们其实可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。</p><blockquote>\n<p><span class=\"reference\">也正因为如此，Go语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；而Go语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。</span></p>\n<p><span class=\"reference\">注意，Go语言里不存在像Java等编程语言中令人困惑的“传值或传引用”问题。在Go语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。</span></p>\n<p><span class=\"reference\">如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。</span></p>\n<p><span class=\"reference\">我们在数组和切片之上都可以应用索引表达式，得到的都会是某个元素。我们在它们之上也都可以应用切片表达式，也都会得到一个新的切片。</span></p>\n</blockquote><p>我们通过调用内建函数<code>len</code>，得到数组和切片的长度。通过调用内建函数<code>cap</code>，我们可以得到它们的容量。</p><p>但要注意，数组的容量永远等于其长度，都是不可变的。切片的容量却不是这样，并且它的变化是有规律可寻的。</p><p>下面我们就通过一道题来了解一下。<strong>我们今天的问题就是：怎样正确估算切片的长度和容量？</strong></p><p>为此，我编写了一个简单的命令源码文件demo15.go。</p><pre><code>package main\n\nimport &quot;fmt&quot;\n\nfunc main() {\n\t// 示例1。\n\ts1 := make([]int, 5)\n\tfmt.Printf(&quot;The length of s1: %d\\n&quot;, len(s1))\n\tfmt.Printf(&quot;The capacity of s1: %d\\n&quot;, cap(s1))\n\tfmt.Printf(&quot;The value of s1: %d\\n&quot;, s1)\n\ts2 := make([]int, 5, 8)\n\tfmt.Printf(&quot;The length of s2: %d\\n&quot;, len(s2))\n\tfmt.Printf(&quot;The capacity of s2: %d\\n&quot;, cap(s2))\n\tfmt.Printf(&quot;The value of s2: %d\\n&quot;, s2)\n}\n</code></pre><p>我描述一下它所做的事情。</p><p>首先，我用内建函数<code>make</code>声明了一个<code>[]int</code>类型的变量<code>s1</code>。我传给<code>make</code>函数的第二个参数是<code>5</code>，从而指明了该切片的长度。我用几乎同样的方式声明了切片<code>s2</code>，只不过多传入了一个参数<code>8</code>以指明该切片的容量。</p><p>现在，具体的问题是：切片<code>s1</code>和<code>s2</code>的容量都是多少？</p><p>这道题的典型回答：切片<code>s1</code>和<code>s2</code>的容量分别是<code>5</code>和<code>8</code>。</p><h2>问题解析</h2><p>解析一下这道题。<code>s1</code>的容量为什么是<code>5</code>呢？因为我在声明<code>s1</code>的时候把它的长度设置成了<code>5</code>。当我们用<code>make</code>函数初始化切片时，如果不指明其容量，那么它就会和长度一致。如果在初始化时指明了容量，那么切片的实际容量也就是它了。这也正是<code>s2</code>的容量是<code>8</code>的原因。</p><p>我们顺便通过<code>s2</code>再来明确下长度、容量以及它们的关系。我在初始化<code>s2</code>代表的切片时，同时也指定了它的长度和容量。</p><p>我在刚才说过，可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。</p><p>在这种情况下，切片的容量实际上代表了它的底层数组的长度，这里是<code>8</code>。（注意，切片的底层数组等同于我们前面讲到的数组，其长度不可变。）</p><p>现在你需要跟着我一起想象：<strong>有一个窗口，你可以通过这个窗口看到一个数组，但是不一定能看到该数组中的所有元素，有时候只能看到连续的一部分元素。</strong></p><p>现在，这个数组就是切片<code>s2</code>的底层数组，而这个窗口就是切片<code>s2</code>本身。<code>s2</code>的长度实际上指明的就是这个窗口的宽度，决定了你透过<code>s2</code>，可以看到其底层数组中的哪几个连续的元素。</p><p>由于<code>s2</code>的长度是<code>5</code>，所以你可以看到底层数组中的第1个元素到第5个元素，对应的底层数组的索引范围是[0, 4]。</p><p>切片代表的窗口也会被划分成一个一个的小格子，就像我们家里的窗户那样。每个小格子都对应着其底层数组中的某一个元素。</p><p>我们继续拿<code>s2</code>为例，这个窗口最左边的那个小格子对应的正好是其底层数组中的第一个元素，即索引为<code>0</code>的那个元素。因此可以说，<code>s2</code>中的索引从<code>0</code>到<code>4</code>所指向的元素恰恰就是其底层数组中索引从<code>0</code>到<code>4</code>代表的那5个元素。</p><p>请记住，当我们用<code>make</code>函数或切片值字面量（比如<code>[]int{1, 2, 3}</code>）初始化一个切片时，该窗口最左边的那个小格子总是会对应其底层数组中的第1个元素。</p><p>但是当我们通过切片表达式基于某个数组或切片生成新切片的时候，情况就变得复杂起来了。</p><p><strong>我们再来看一个例子：</strong></p><pre><code>s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}\ns4 := s3[3:6]\nfmt.Printf(&quot;The length of s4: %d\\n&quot;, len(s4))\nfmt.Printf(&quot;The capacity of s4: %d\\n&quot;, cap(s4))\nfmt.Printf(&quot;The value of s4: %d\\n&quot;, s4)\n</code></pre><p>切片<code>s3</code>中有8个元素，分别是从<code>1</code>到<code>8</code>的整数。<code>s3</code>的长度和容量都是<code>8</code>。然后，我用切片表达式<code>s3[3:6]</code>初始化了切片<code>s4</code>。问题是，这个<code>s4</code>的长度和容量分别是多少？</p><p>这并不难，用减法就可以搞定。首先你要知道，切片表达式中的方括号里的那两个整数都代表什么。我换一种表达方式你也许就清楚了，即：[3, 6)。</p><p>这是数学中的区间表示法，常用于表示取值范围，我其实已经在本专栏用过好几次了。由此可知，<code>[3:6]</code>要表达的就是透过新窗口能看到的<code>s3</code>中元素的索引范围是从<code>3</code>到<code>5</code>（注意，不包括<code>6</code>）。</p><p>这里的<code>3</code>可被称为起始索引，<code>6</code>可被称为结束索引。那么<code>s4</code>的长度就是<code>6</code>减去<code>3</code>，即<code>3</code>。因此可以说，<code>s4</code>中的索引从<code>0</code>到<code>2</code>指向的元素对应的是<code>s3</code>及其底层数组中索引从<code>3</code>到<code>5</code>的那3个元素。</p><p><img src=\"https://static001.geekbang.org/resource/image/96/55/96e2c7129793ee5e73a574ef8f3ad755.png?wh=1364*783\" alt=\"\"></p><p>（切片与数组的关系）</p><p>再来看容量。我在前面说过，切片的容量代表了它的底层数组的长度，但这仅限于使用<code>make</code>函数或者切片值字面量初始化切片的情况。</p><p>更通用的规则是：一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。</p><p>由于<code>s4</code>是通过在<code>s3</code>上施加切片操作得来的，所以<code>s3</code>的底层数组就是<code>s4</code>的底层数组。</p><p>又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。</p><p>所以，<code>s4</code>的容量就是其底层数组的长度<code>8</code>,减去上述切片表达式中的那个起始索引<code>3</code>，即<code>5</code>。</p><p>注意，切片代表的窗口是无法向左扩展的。也就是说，我们永远无法透过<code>s4</code>看到<code>s3</code>中最左边的那3个元素。</p><p>最后，顺便提一下把切片的窗口向右扩展到最大的方法。对于<code>s4</code>来说，切片表达式<code>s4[0:cap(s4)]</code>就可以做到。我想你应该能看懂。该表达式的结果值（即一个新的切片）会是<code>[]int{4, 5, 6, 7, 8}</code>，其长度和容量都是<code>5</code>。</p><h2>知识扩展</h2><p><strong>问题1：怎样估算切片容量的增长？</strong></p><p>一旦一个切片无法容纳更多的元素，Go语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的2倍。</p><p>但是，当原切片的长度（以下简称原长度）大于或等于<code>1024</code>时，Go语言将会以原容量的<code>1.25</code>倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与<code>1.25</code>相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。</p><p>另外，如果我们一次追加的元素过多，以至于使新长度比原容量的2倍还要大，那么新容量就会以新长度为基准。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些。更多细节可参见<code>runtime</code>包中slice.go文件里的<code>growslice</code>及相关函数的具体实现。</p><p>我把展示上述扩容策略的一些例子都放到了demo16.go文件中。你可以去试运行看看。</p><p><strong>问题 2：切片的底层数组什么时候会被替换？</strong></p><p>确切地说，一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候Go语言一定会生成新的底层数组，但是它也同时生成了新的切片。</p><p>它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。</p><p>请记住，在无需扩容时，<code>append</code>函数返回的是指向原底层数组的原切片，而在需要扩容时，<code>append</code>函数返回的是指向新底层数组的新切片。所以，严格来讲，“扩容”这个词用在这里虽然形象但并不合适。不过鉴于这种称呼已经用得很广泛了，我们也没必要另找新词了。</p><p>顺便说一下，只要新长度不会超过切片的原容量，那么使用<code>append</code>函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。你可以运行demo17.go文件以增强对这些知识的理解。</p><p><strong>总结</strong></p><p>总结一下，我们今天一起探讨了数组和切片以及它们之间的关系。切片是基于数组的，可变长的，并且非常轻快。一个切片的容量总是固定的，而且一个切片也只会与某一个底层数组绑定在一起。</p><p>此外，切片的容量总会是在切片长度和底层数组长度之间的某一个值，并且还与切片窗口最左边对应的元素在底层数组中的位置有关系。那两个分别用减法计算切片长度和容量的方法你一定要记住。</p><p>另外，如果新的长度比原有切片的容量还要大，那么底层数组就一定会是新的，而且<code>append</code>函数也会返回一个新的切片。还有，你其实不必太在意切片“扩容”策略中的一些细节，只要能够理解它的基本规律并可以进行近似的估算就可以了。</p><p><strong>思考题</strong></p><p>这里仍然是聚焦于切片的问题。</p><ol>\n<li>如果有多个切片指向了同一个底层数组，那么你认为应该注意些什么？</li>\n<li>怎样沿用“扩容”的思想对切片进行“缩容”？请写出代码。</li>\n</ol><p>这两个问题都是开放性的，你需要认真思考一下。最好在动脑的同时动动手。</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p>","neighbors":{"left":{"article_title":"06 | 程序实体的那些事儿 （下）","id":13601},"right":{"article_title":"08 | container包中的那些容器","id":14117}},"comments":[{"had_liked":false,"id":69673,"user_name":"Nuzar","can_delete":false,"product_type":"c1","uid":1152232,"ip_address":"","ucode":"7F6EC8ECEB8900","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/e8/207b5fa1.jpg","comment_is_top":true,"comment_ctime":1550805841,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"9.223372214499201e+18","product_id":100013101,"comment_content":"老师的行文用字非常好，不用改！","like_count":42,"discussions":[{"author":{"id":1014615,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/57/18b61282.jpg","nickname":"dullduck","note":"","ucode":"25293558309704","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1468,"discussion_content":"确实，要认真读！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1562643687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114352,"avatar":"https://static001.geekbang.org/account/avatar/00/11/00/f0/fe94061e.jpg","nickname":"假装在养🐷","note":"","ucode":"D0AB9CD03E0D5B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572545,"discussion_content":"技术出身吧，确实挺啰嗦的，但是内容挺丰富，就是读取来费劲","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652845609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22206,"user_name":"清风徐来","can_delete":false,"product_type":"c1","uid":1202697,"ip_address":"","ucode":"2AAA5B8DE30DF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/09/afa3e112.jpg","comment_is_top":false,"comment_ctime":1535553621,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1083867312213","product_id":100013101,"comment_content":"语言描述有点啰嗦太学术化，和我当时看go并发编程第二版开头几章同样的感觉，希望能更加精简一些，直接突出重点要好很多。","like_count":253,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328699,"discussion_content":"还要考虑到基础不好的同学和小白同学啊。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1606212445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1058015,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","nickname":"Yayu","note":"","ucode":"5E7842458D8229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365834,"discussion_content":"我之前也觉得老师的表述有些啰嗦，尤其是听语音的场景下。不过经过日常几次与同事沟通细节问题，发展口语表述技术概念真的不得不严谨一些，否则会带来很多额外的问题。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1617889758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142265,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/f9/7431e82e.jpg","nickname":"24小菜鸟","note":"","ucode":"02D6127A2DE3C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369041,"discussion_content":"大师的水平，菜鸟的表述","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618910473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1288985,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcFhGY0NV4kFzOSXWDHR2lrI2UbUP4Y016GOnpTH7dqSbicqJarX0pHxMsfLopRiacKEPXLx7IHHqg/132","nickname":"一路前行","note":"","ucode":"32D3C715690783","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1142265,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/f9/7431e82e.jpg","nickname":"24小菜鸟","note":"","ucode":"02D6127A2DE3C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385733,"discussion_content":"书是个菜鸟看的，不是给大师读的，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627251797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":369041,"ip_address":""},"score":385733,"extra":""}]}]},{"had_liked":false,"id":21795,"user_name":"melon","can_delete":false,"product_type":"c1","uid":1023773,"ip_address":"","ucode":"7A80C20EBCAAA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/1d/ec173090.jpg","comment_is_top":false,"comment_ctime":1535339305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"641485466409","product_id":100013101,"comment_content":"初始时两个切片引用同一个底层数组，在后续操作中对某个切片的操作超出底层数组的容量时，这两个切片引用的就不是同一个数组了，比如下面这个例子:<br>s1 := []int {1,2,3,4,5}<br>s2 := s1[0:5]<br><br>s2 = append(s2, 6)<br>s1[3] = 30<br><br>此时s1[3]的值为30, s2[3]的值仍然为4，因为s2的底层数组已是扩容后的新数组了。","like_count":150},{"had_liked":false,"id":22190,"user_name":"小小笑儿","can_delete":false,"product_type":"c1","uid":1040354,"ip_address":"","ucode":"CA63CC50DC2091","user_header":"https://static001.geekbang.org/account/avatar/00/0f/df/e2/823a04b4.jpg","comment_is_top":false,"comment_ctime":1535543101,"is_pvip":false,"replies":[{"id":"8112","content":"没错","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535803025,"ip_address":"","comment_id":22190,"utype":1}],"discussion_count":1,"race_medal":0,"score":"254938613565","product_id":100013101,"comment_content":"切片缩容之后还是会引用底层的原数组，这有时候会造成大量缩容之后的多余内容没有被垃圾回收。可以使用新建一个数组然后copy的方式。","like_count":60,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423036,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535803025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128915,"user_name":"许大","can_delete":false,"product_type":"c1","uid":1047183,"ip_address":"","ucode":"8C56D0BE30D276","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/8f/82415ad5.jpg","comment_is_top":false,"comment_ctime":1566983133,"is_pvip":false,"replies":[{"id":"48040","content":"make 是专门用来创建 slice、map、channel 的值的。它返回的是被创建的值，并且立即可用。<br><br>new 是申请一小块内存并标记它是用来存放某个值的。它返回的是指向这块内存的指针，而且这块内存并不会被初始化。或者说，对于一个引用类型的值，那块内存虽然已经有了，但还没法用（因为里面没有针对那个值的数据结构）。<br><br>所以，对于引用类型的值，不要用 new，能用 make 就用 make，不能用 make 就用复合字面量来创建。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1567047180,"ip_address":"","comment_id":128915,"utype":1}],"discussion_count":5,"race_medal":0,"score":"242085151709","product_id":100013101,"comment_content":"老师 go中 make和new 有什么区别","like_count":57,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465173,"discussion_content":"make 是专门用来创建 slice、map、channel 的值的。它返回的是被创建的值，并且立即可用。\n\nnew 是申请一小块内存并标记它是用来存放某个值的。它返回的是指向这块内存的指针，而且这块内存并不会被初始化。或者说，对于一个引用类型的值，那块内存虽然已经有了，但还没法用（因为里面没有针对那个值的数据结构）。\n\n所以，对于引用类型的值，不要用 new，能用 make 就用 make，不能用 make 就用复合字面量来创建。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567047180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362270,"discussion_content":"关于 new 我的理解是：new 返回的是一个指针（地址，用于存储某种类型值的内层地址）。比如 ptr := new(myType)，其中 ptr 变量的类型是 *myType，其值就是用来存放 myType 类型值的内存地址。当然 ptr 作为一个变量，也是占用了内层的一段区域的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1616903824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2687948,"avatar":"https://static001.geekbang.org/account/avatar/00/29/03/cc/e58dac56.jpg","nickname":"xyg","note":"","ucode":"1F9A252515690A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":566890,"discussion_content":"么毛病","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650791061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":362270,"ip_address":""},"score":566890,"extra":""}]},{"author":{"id":1350838,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9c/b6/c75d9845.jpg","nickname":"lee","note":"","ucode":"287F0EDB647007","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535891,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638593565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409254,"discussion_content":"make new。 Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635403550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24452,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1082187,"ip_address":"","ucode":"FC323371453C97","user_header":"https://static001.geekbang.org/account/avatar/00/10/83/4b/0e96fcae.jpg","comment_is_top":false,"comment_ctime":1537016006,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"100321263814","product_id":100013101,"comment_content":"老师您好！我对源码demo16中示例1、3实际运行结果与预期结果表示ok，但唯独示例2的运行结果觉得没有什么规则可供参考，为何不是下面我预期的结果呢，对于实际的运行结果表示不理解，还烦请老师有空帮忙解答下，感谢！<br><br>代码如下：<br>&#47;&#47; 示例2<br>\ts7 := make([]int, 1024)<br>\tfmt.Printf(&quot;The capacity of s7: %d\\n&quot;, cap(s7))<br>\ts7e1 := append(s7, make([]int, 200)...)<br>\tfmt.Printf(&quot;s7e1: len: %d, cap: %d\\n&quot;, len(s7e1), cap(s7e1))<br>\ts7e2 := append(s7, make([]int, 400)...)<br>\tfmt.Printf(&quot;s7e2: len: %d, cap: %d\\n&quot;, len(s7e2), cap(s7e2))<br>\ts7e3 := append(s7, make([]int, 600)...)<br>\tfmt.Printf(&quot;s7e3: len: %d, cap: %d\\n&quot;, len(s7e3), cap(s7e3))<br>\tfmt.Println()<br>实际运行结果：<br>The capacity of s7: 1024<br>s7e1: len: 1224, cap: 1280<br>s7e2: len: 1424, cap: 1696<br>s7e3: len: 1624, cap: 2048<br><br>预期运行结果：<br>The capacity of s7: 1024<br>s7e1: len: 1224, cap: 1280<br>s7e2: len: 1424, cap: 1600<br>s7e3: len: 1624, cap: 2000","like_count":24,"discussions":[{"author":{"id":1677568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eopibicYcibaNGZvicTEMyYroXQGpP1WicRxI0SBobVJVYtml6K6bQhtgR3bLZJkFZMSDV4SuxdjZRgXUw/132","nickname":"宇智波悟天","note":"","ucode":"C6945990FE33C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32380,"discussion_content":"我也是很困惑啊，上网查了下。给大家一个参考：\n向 slice 追加元素的时候，若容量不够，会调用 growslice 函数\nfunc growslice(et *_type, old slice, cap int) slice {\n    // ……\n    newcap := old.cap\n    doublecap := newcap + newcap\n    if cap > doublecap {\n        newcap = cap\n    } else {\n        if old.len < 1024 {\n            newcap = doublecap\n        } else {\n            for newcap < cap {\n                newcap += newcap / 4\n            }\n        }\n    }\n    // ……\n    capmem = roundupsize(uintptr(newcap) * ptrSize)\n    newcap = int(capmem / ptrSize)\n\n重点看最后两行代码。\n对 newcap 作了一个内存对齐，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于 老 slice 容量的 2倍或者1.25倍的。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1571029158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1352152,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELcM4karUTtLlszX1FPaYKcbsfsthZiahTpYlnFgQIS3PcJStvKTCE9OqbJfgxxzfrg1t0CpuspHCQ/132","nickname":"will","note":"","ucode":"57980692086041","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46536,"discussion_content":"内存对齐在c++数组里面也经常有这种情况，看来编写操作系统亲和的程序很重要呀！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1573178706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2860954,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/wfRD8vz9zQDYgxwSqW6jnpIcQ3guZUE6EQuVXM5Wribtp9wDlJLO8SG76CCPEdmDviaTK99iarvTYLxJw71bKdeXw/132","nickname":"CheerJia","note":"","ucode":"5A2E4A956816C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539946,"discussion_content":"跟go内存分配相关，可以看看这个文章https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639889725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2052670,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/52/3e/f74da7bd.jpg","nickname":"初学者","note":"","ucode":"5E404009761B90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381430,"discussion_content":"示例2和示例3都有点出入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625048430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1312493,"avatar":"https://static001.geekbang.org/account/avatar/00/14/06/ed/5a167dda.jpg","nickname":"niceshot","note":"","ucode":"2C2BBC07A6E02D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376737,"discussion_content":"capmem = roundupsize(capmem)\nroundupsize中return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]])\n则是1600->1696的原因 至于为什么这样做能够为什么内存对齐 就没研究了。\n在run_time包中的growslice函数里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622300586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211086,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7a/ce/b07ed069.jpg","nickname":"Gary","note":"","ucode":"9D17B0A72E5148","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2182,"discussion_content":"最终，新容量往往会比新长度大一些，当然，相等也是可能的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563333200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014615,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/57/18b61282.jpg","nickname":"dullduck","note":"","ucode":"25293558309704","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1469,"discussion_content":"同问。同时示例3的cap，好像也没有规律可言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562643865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1198956,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4b/6c/f09b085d.jpg","nickname":"青峰","note":"","ucode":"922E9EC8A96127","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561207386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184013,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583205186,"is_pvip":false,"replies":[{"id":"71243","content":"赞！<br><br>就第2个问题我可以接着问你：弄新切片的话，那旧切片应该怎么处理？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1583229803,"ip_address":"","comment_id":184013,"utype":1}],"discussion_count":4,"race_medal":0,"score":"83187583810","product_id":100013101,"comment_content":"首先总结今天课程内容<br>1. 数组和切片的区别与联系<br> 1.1数组是有长度的并且长度是类型的组成部分之一 所以[1]string!=[2]string 长度固定不可变<br> 1.2切片实际上是对底层数组的一层封装，通过切片的容量和长度 我们可以访问到底层数组中对应的元素,<br> 1.2.1如果切片是从底层数组下标为0处开始引用 那个切片的第一个元素(下标为0时)引用的是数组下标为0的元素<br> 1.2.2如果切片是从底层数组下标为3处开始引用那么切片的第一个元素(下标为0时)引用的是数组下标为3的元素<br>2. 数组和切片的共同点<br>   它们都是集合类型<br>3. 值传递和引用传递<br>   如果实参是值类型 就是值传递  如果实参为引用类型则是引用传递 一般来说引用传递更快更好<br>   go语言中值类型 : 数组，和内置的数据类型 以及结构体<br>   go语言中引用类型: 切片(slice) 字典(map) 通道(channel) 函数(func) 是引用类型 引用类型一般使用make创建和初始化<br>4. 关于切片长度和容量的计算<br>   切片长度一般是对底层数组的引用范围 比如s1=s2[3:6] [3,6)引用范围为3-5所以长度为6-3=3，但是切片可以向右扩展而不能向左扩展 所以 s1的容量就 = s2的容量-3 3是对数组引用的起始下标 6是对数组引用的结束下标<br>5. 关于append和切片扩容<br>一般使用append对切片进行追加元素  分为以下两种情况<br>1. 追加过后元素长度小于容量<br>    append返回原切片<br>2. 追加过后元素长度超过了容量<br>   2.1 如果长度小于1024 <br>        则扩容机制为  新切片容量 = 原切片容量*2<br>        返回新切片地址<br>   2.2 如果长度大于1024<br>        则扩容机制为 新切片容量 = 原切片容量*1.25<br>        返回 新切片地址 <br>    2.3 如果要追加的元素过多 比切片容量的两倍还多<br>         则再进行前面 2.1 2.2的操作<br>    重点 因为切片必定引用一个底层数组  所以数组也不会是原来的数组了<br>5. 切片的缩容<br>    回答到思考题当中<br>思考题答案<br>1. 如果多个切片引用到同一个数组应该注意什么<br>    这个问题 就像并发问题  多个线程同时操作一块内存区域 所以要注意的是 读写顺序 及读写过后的更新问题 避免本来想读老数据 却被另外一个切片给写入数据了<br>2. 切片缩容问题<br>   其实可以反向思考 扩容问题 <br>   当切片的容量小于等于一定比例后 有大量的空间被浪费  所以新弄一个新切片 容量为原切片按比列缩小<br>   并返回新的切片<br>代码 等有空了再补上","like_count":19,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485853,"discussion_content":"赞！\n\n就第2个问题我可以接着问你：弄新切片的话，那旧切片应该怎么处理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583229803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2625171,"avatar":"","nickname":"Geek_f19e14","note":"","ucode":"55A4A1C1F0C2E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374333,"discussion_content":"旧切片应当置nil，无引用时会被自动垃圾回收","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621141771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2171114,"avatar":"https://static001.geekbang.org/account/avatar/00/21/20/ea/e20422e5.jpg","nickname":"云彩飞扬","note":"","ucode":"7C598009B94EA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305292,"discussion_content":"1. 追加过后元素长度小于容量\n    append返回原切片\n------------------------\n这里有误吧，append文章中说的返回都是新的切片","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599841100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385879,"discussion_content":" 所以 s1的容量就 = s2的容量-3 3是对数组引用的起始下标 6是对数组引用的结束下标 这句话错了吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627311727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21841,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1535371879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74549815911","product_id":100013101,"comment_content":"1.当两个长度不一的切片使用同一个底层数组，并且两切片的长度均小于数组的容量时，对其中长度较小的一个切片进行append操作，但不超过底层数组容量，这时会影响长度较长切片中原来比较小切片多看到的值，因为底层数组被修改了。<br>2. 可以截取切片的部分数据，然后创建新数组来缩容","like_count":17},{"had_liked":false,"id":140685,"user_name":"宇智波悟天","can_delete":false,"product_type":"c1","uid":1677568,"ip_address":"","ucode":"C6945990FE33C7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eopibicYcibaNGZvicTEMyYroXQGpP1WicRxI0SBobVJVYtml6K6bQhtgR3bLZJkFZMSDV4SuxdjZRgXUw/132","comment_is_top":false,"comment_ctime":1571029303,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"57405604151","product_id":100013101,"comment_content":"关于老 slice 容量大于等于 1024 时，没有严格按照1.25倍增长的问题，和大家一样有些困惑，上网查了下。给大家一个参考：<br>向 slice 追加元素的时候，若容量不够，会调用 growslice 函数<br>func growslice(et *_type, old slice, cap int) slice {<br>    &#47;&#47; ……<br>    newcap := old.cap<br>    doublecap := newcap + newcap<br>    if cap &gt; doublecap {<br>        newcap = cap<br>    } else {<br>        if old.len &lt; 1024 {<br>            newcap = doublecap<br>        } else {<br>            for newcap &lt; cap {<br>                newcap += newcap &#47; 4<br>            }<br>        }<br>    }<br>    &#47;&#47; ……<br>    capmem = roundupsize(uintptr(newcap) * ptrSize)<br>    newcap = int(capmem &#47; ptrSize)<br><br>重点看最后两行代码。<br>对 newcap 作了一个内存对齐，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于 老 slice 容量的 2倍或者1.25倍的。","like_count":14,"discussions":[{"author":{"id":1245619,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/b3/948252af.jpg","nickname":"abeizn","note":"","ucode":"092ED0F7669843","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578476,"discussion_content":"这真是正解啊，牛逼了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656811938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184128,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583230051,"is_pvip":false,"replies":[{"id":"71328","content":"如果仍然存在与老切片有关的变量，别忘了置 nil。GC 回收老切片有一个必要条件，那就是：已经没有任何代码引用它了。<br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1583307138,"ip_address":"","comment_id":184128,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48827870307","product_id":100013101,"comment_content":"回答追问，旧的切片，无论是扩容或者缩容都会有老的切片释放出来，这个时候应该是被回收了！不然肯定会内存泄露的","like_count":11,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485899,"discussion_content":"如果仍然存在与老切片有关的变量，别忘了置 nil。GC 回收老切片有一个必要条件，那就是：已经没有任何代码引用它了。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583307138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409255,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635403680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21832,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1535367746,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44485040706","product_id":100013101,"comment_content":"谢谢老师，今天这篇文才让我意识到以前对切片的认知是不全面的。但也带来一个新问题，大部分语言里，类似切片的数据结构的实质就是可变数组，他们都没有窗口这个设计，golang是为啥设计了窗口这个功能呢？这个功能在实际开发中能如何应用呢？我想golang这种极简设计思想的语言，绝不会搞多余设计，必然是有某种场景，不用切片的窗口就搞不定。但是我想不出是什么","like_count":10,"discussions":[{"author":{"id":1053361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/12/b1/ceb974f5.jpg","nickname":"darksword","note":"","ucode":"1D72665FA61349","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213866,"discussion_content":"c++的vector也是有这个概念的。预分配可以减少malloc的次数，空间换时间。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585129693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23250,"user_name":"徐宁","can_delete":false,"product_type":"c1","uid":1208822,"ip_address":"","ucode":"5B38BF576B1749","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/f6/ad0ad3df.jpg","comment_is_top":false,"comment_ctime":1536233054,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35895971422","product_id":100013101,"comment_content":"能不能少用点前者后者这类语言，很容易困惑又回头去看","like_count":8,"discussions":[{"author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389260,"discussion_content":"那写递归脑袋岂不是会冒烟。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629194493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265192,"user_name":"Wei Yongchao","can_delete":false,"product_type":"c1","uid":1043806,"ip_address":"","ucode":"5C7CECA73A684C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/5e/0e2d7fe9.jpg","comment_is_top":false,"comment_ctime":1606810302,"is_pvip":false,"replies":[{"id":"96433","content":"可能新版本里又有优化了吧。<br><br>我看了下最新的源码，确实是“无须扩容时会返回原切片”。<br><br>因此，文中需要改动两处：<br><br>1. 请记住，在无需扩容时，append 函数返回的是指向原底层数组的原切片，而在需要扩容时，append 函数返回的是指向新底层数组的新切片。<br>2. 另外，如果新的长度比原有切片的容量还要大，那么底层数组就一定会是新的，而且 append 函数也会返回一个新的切片。<br><br>我已经提交给极客时间的编辑了。如果未能及时更新，你就以我上面写的这两句话为准吧。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1606879340,"ip_address":"","comment_id":265192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31671581374","product_id":100013101,"comment_content":"我的这段代码：<br>s := make([]int, 0)<br>\tfmt.Printf(&quot;len(s) = %d, cap(s)=%d, addr=%p\\n&quot;, len(s), cap(s), s)<br>\tfor i := 1; i &lt;= 10; i++{<br>\t\ts = append(s, 1)<br><br>\t\tfmt.Printf(&quot;i:%d, len(s) = %d, cap(s)=%d, addr=%p\\n&quot;, i, len(s), cap(s), s)<br>\t}<br>输出如下：<br>len(s) = 0, cap(s)=0, addr=0x6d0e70<br>i:1, len(s) = 1, cap(s)=1, addr=0xc00000a0d0<br>i:2, len(s) = 2, cap(s)=2, addr=0xc00000a0e0<br>i:3, len(s) = 3, cap(s)=4, addr=0xc0000103a0<br>i:4, len(s) = 4, cap(s)=4, addr=0xc0000103a0<br>i:5, len(s) = 5, cap(s)=8, addr=0xc00000e2c0<br>i:6, len(s) = 6, cap(s)=8, addr=0xc00000e2c0<br>i:7, len(s) = 7, cap(s)=8, addr=0xc00000e2c0<br>i:8, len(s) = 8, cap(s)=8, addr=0xc00000e2c0<br>i:9, len(s) = 9, cap(s)=16, addr=0xc000078000<br>i:10, len(s) = 10, cap(s)=16, addr=0xc000078000<br><br>他在i=3, 4和i=5, 6, 7, 8的时候没有扩容。但，看样子返回的还是以前的切片？","like_count":7,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510828,"discussion_content":"可能新版本里又有优化了吧。\n\n我看了下最新的源码，确实是“无须扩容时会返回原切片”。\n\n因此，文中需要改动两处：\n\n1. 请记住，在无需扩容时，append 函数返回的是指向原底层数组的原切片，而在需要扩容时，append 函数返回的是指向新底层数组的新切片。\n2. 另外，如果新的长度比原有切片的容量还要大，那么底层数组就一定会是新的，而且 append 函数也会返回一个新的切片。\n\n我已经提交给极客时间的编辑了。如果未能及时更新，你就以我上面写的这两句话为准吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606879340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22365,"user_name":"Geek_b5a317","can_delete":false,"product_type":"c1","uid":1214501,"ip_address":"","ucode":"6A0923891C3EBC","user_header":"","comment_is_top":false,"comment_ctime":1535632393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31600403465","product_id":100013101,"comment_content":"老师可以多些图表在文章里，方便阅读","like_count":7},{"had_liked":false,"id":21772,"user_name":"余泽锋","can_delete":false,"product_type":"c1","uid":1003207,"ip_address":"","ucode":"5AB1499746C003","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/c7/8c2d0a3d.jpg","comment_is_top":false,"comment_ctime":1535331150,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"31600102222","product_id":100013101,"comment_content":"1.底层数组的变动会影响多个切片<br>2.每一次缩容都需要生成新的切片","like_count":7},{"had_liked":false,"id":22040,"user_name":"wjq310","can_delete":false,"product_type":"c1","uid":1102514,"ip_address":"","ucode":"BAF72D40CC91F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/b2/2f19b0ad.jpg","comment_is_top":false,"comment_ctime":1535458568,"is_pvip":false,"replies":[{"id":"7962","content":"每次发现容量不够都会翻一倍，你可以从头算一下。另外，一旦超过1024每次只会增大1.25倍。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535515857,"ip_address":"","comment_id":22040,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27305262344","product_id":100013101,"comment_content":"老师，请问下demo16.go的示例三的几个cap值是怎么来的？看这后面的值，不像是2的指数倍。更奇怪的是，我在不同的地方运行（比如把代码贴到https:&#47;&#47;golang.org&#47;go）得到的结果还不一样，不知道为什么，麻烦帮忙解答一下，感谢了","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422975,"discussion_content":"每次发现容量不够都会翻一倍，你可以从头算一下。另外，一旦超过1024每次只会增大1.25倍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535515857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28363,"user_name":"mrly","can_delete":false,"product_type":"c1","uid":1117961,"ip_address":"","ucode":"90380A0169CF0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/09/0e28e1e1.jpg","comment_is_top":false,"comment_ctime":1538061345,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23012897825","product_id":100013101,"comment_content":"老师，我对demo16的运行结果有疑惑，按1024*1.25*1.25*1.25来说，结果应该是这样：<br>实际运行结果：<br>The capacity of s7: 1024<br>s7e1: len: 1224, cap: 1280<br>s7e2: len: 1424, cap: 1696<br>s7e3: len: 1624, cap: 2048<br><br>预期运行结果：<br>The capacity of s7: 1024<br>s7e1: len: 1224, cap: 1280=1024*1.25<br>s7e2: len: 1424, cap: 1600=1024*1.25*1.25<br>s7e3: len: 1624, cap: 2000=1024*1.25*1.25*1.25<br><br>为什么结果不一样呢？","like_count":5,"discussions":[{"author":{"id":1208981,"avatar":"https://static001.geekbang.org/account/avatar/00/12/72/95/5f83598c.jpg","nickname":"Hello World","note":"","ucode":"368D87D53DC58F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337454,"discussion_content":"对齐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608909134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":27795,"user_name":"Empty","can_delete":false,"product_type":"c1","uid":1237261,"ip_address":"","ucode":"AD6C95A503B991","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/0d/ecf81935.jpg","comment_is_top":false,"comment_ctime":1537945370,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23012781850","product_id":100013101,"comment_content":"王老师，能解释一下demo16里面的第三个示例么","like_count":5},{"had_liked":false,"id":115623,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1563677289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18743546473","product_id":100013101,"comment_content":"总结一下:<br>如果不扩容，新切片和所有基于该底层数组的切片，都对同一个数组进行操作，会相互影响。<br>如果扩容，新切片的底层数组会新生成一个，因切片对该数组的操作不会影响原来的数组(原来数组没有引用可能已经被回收了)","like_count":4},{"had_liked":false,"id":22391,"user_name":"mateye","can_delete":false,"product_type":"c1","uid":1176599,"ip_address":"","ucode":"C402E6E4590F72","user_header":"https://static001.geekbang.org/account/avatar/00/11/f4/17/fb769d42.jpg","comment_is_top":false,"comment_ctime":1535644017,"is_pvip":false,"replies":[{"id":"8107","content":"可以用copy函数，或者自己深拷贝。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535802271,"ip_address":"","comment_id":22391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18715513201","product_id":100013101,"comment_content":"\r老师您好，就像您说的，切片赋值的话会，如果完全赋值，会指向相同的底层数组，\r    s1 :=[]int{1,2,3,4}\r    s2 := s1[0:4]\r    就像这样，这样的话改变s2会影响s1，如何消除这种影响呢","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423099,"discussion_content":"可以用copy函数，或者自己深拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535802271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22015,"user_name":"Spike","can_delete":false,"product_type":"c1","uid":1200587,"ip_address":"","ucode":"9548DF1596CF9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/cb/c8b42257.jpg","comment_is_top":false,"comment_ctime":1535442311,"is_pvip":false,"replies":[{"id":"7959","content":"Dave Cheney 又不是Go语言团队中的人。我原创文章中的所有内容都只遵从Go语言官方文档和Go语言源码。你可以再好好看看Go语言规范。再说一遍slice是引用类型之一。另外他的这句话你就没理解对。Go语言里不会传引用，这我也多次强调过。但是，內建数据类型中会有值类型和引用类型之分。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535515195,"ip_address":"","comment_id":22015,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18715311495","product_id":100013101,"comment_content":"slices are not passed by reference, nothing is passed by reference in go. Everything is a copy, every assignment, every parameter to a function, there are no exceptions to this rule.  这是Dave Cheney的原话 slice不是指针也不是引用 希望作者参考下https:&#47;&#47;dave.cheney.net&#47;2018&#47;07&#47;12&#47;slices-from-the-ground-up 这篇博文","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422962,"discussion_content":"Dave Cheney 又不是Go语言团队中的人。我原创文章中的所有内容都只遵从Go语言官方文档和Go语言源码。你可以再好好看看Go语言规范。再说一遍slice是引用类型之一。另外他的这句话你就没理解对。Go语言里不会传引用，这我也多次强调过。但是，內建数据类型中会有值类型和引用类型之分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535515195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350066,"discussion_content":"传引用和引用类型是两个概念。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613696394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284152,"user_name":"Bruce Lee","can_delete":false,"product_type":"c1","uid":1340746,"ip_address":"","ucode":"E51A47BB74DEA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/75/4a/eb2f4f64.jpg","comment_is_top":false,"comment_ctime":1616083032,"is_pvip":false,"replies":[{"id":"103099","content":"其实计算之后新的cap确实是89，但之后编译器又对此进行了优化，变为了96。这是一种关于内存对齐的优化。<br><br>详见源码：src&#47;runtime&#47;slice.go 中的函数 growslice，具体的逻辑在这个函数后半部分的 switch 语句中。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1616143489,"ip_address":"","comment_id":284152,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14500984920","product_id":100013101,"comment_content":"老师您好<br>demo16的例子<br><br>s8b := append(s8a, make([]int, 23)...)<br>fmt.Printf(&quot;s8b: len: %d, cap: %d\\n&quot;, len(s8b), cap(s8b))<br>s8c := append(s8b, make([]int, 45)...)<br>fmt.Printf(&quot;s8c: len: %d, cap: %d\\n&quot;, len(s8c), cap(s8c))<br><br>根据分析应该输出<br>s8b: len: 44, cap: 44<br>s8c: len: 89, cap: 89<br><br>实际输出<br>s8b: len: 44, cap: 44<br>s8c: len: 89, cap: 96<br><br>没有明白 希望老师能解答<br>```","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517254,"discussion_content":"其实计算之后新的cap确实是89，但之后编译器又对此进行了优化，变为了96。这是一种关于内存对齐的优化。\n\n详见源码：src/runtime/slice.go 中的函数 growslice，具体的逻辑在这个函数后半部分的 switch 语句中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616143489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1058015,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","nickname":"Yayu","note":"","ucode":"5E7842458D8229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365830,"discussion_content":"太棒了，老师又给我们指出一个知识点，内存对齐！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617889182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92035,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1557158749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14442060637","product_id":100013101,"comment_content":"第三次看了，老师加了好多图，感激不尽","like_count":3},{"had_liked":false,"id":53445,"user_name":"轻轻的飞 ོ","can_delete":false,"product_type":"c1","uid":1189495,"ip_address":"","ucode":"52AE1243876FB6","user_header":"https://static001.geekbang.org/account/avatar/00/12/26/77/b655559a.jpg","comment_is_top":false,"comment_ctime":1545645620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14430547508","product_id":100013101,"comment_content":"今天看了 SliceHeader 才终于理解老师说的知识。append操作每次其实都返回了一个新的 SliceHeader，只不过里面的Data数组可能是原来，也可能是新的（由是否扩容决定），这是新旧slice之间可能的惟一关联。所以append操作后的新slice一定要保存好，因为append操作对原来的slice没有任何影响。","like_count":3},{"had_liked":false,"id":32170,"user_name":"陈悬高","can_delete":false,"product_type":"c1","uid":1065981,"ip_address":"","ucode":"457213A8351202","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/fd/908706cc.jpg","comment_is_top":false,"comment_ctime":1539456692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14424358580","product_id":100013101,"comment_content":"虽然 slice 间接引用了底层数组的元素，但是其指针、长度和容量却是它自己的属性。要更新一个 slice 的指针、长度或容量必须使用显式的赋值。从这个角度看，slice 并不是“纯粹”的引用类型，而是像下面这种聚合类型：<br><br>```<br>type IntSlice struct {<br>\tptr *int<br>\tlen, cap int<br>}<br>```<br><br>所以，不仅是在调用 `append` 函数时需要更新 slice 变量。另外，对于任何函数，只要有可能改变 slice 的长度或者容量，或者使得 slice 指向不同的底层数组，都需要更新 slice 变量。","like_count":3},{"had_liked":false,"id":21895,"user_name":"许森森","can_delete":false,"product_type":"c1","uid":1105360,"ip_address":"","ucode":"7C46D56DD8366B","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/d0/36b6eaf7.jpg","comment_is_top":false,"comment_ctime":1535388911,"is_pvip":false,"replies":[{"id":"7963","content":"嗯对，一切都从底层数组上找答案。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535515912,"ip_address":"","comment_id":21895,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14420290799","product_id":100013101,"comment_content":"1 改了一个切片的元素，其他的可能都受影响。如果扩容超过容量，底层会指向新的数组。从而不受影响。<br><br>2生成新的slice<br><br>func main() {<br>\ts1 := []int{1,2,3,4,5}<br>\tprintSlice(&quot;s1&quot;, s1)<br>\t<br>\ts1 = shrinkSlice(s1)<br>\t<br>\tprintSlice(&quot;s1&quot;, s1)<br>}<br><br>func shrinkSlice(x []int) []int{<br>\tif( cap(x) &gt; 0 ) {<br>\t\tx = x[0:cap(x)-1]<br>\t}<br>\treturn x<br>}<br><br>func printSlice(s string, x []int) {<br>\tfmt.Printf(&quot;%s len=%d cap=%d %v\\n&quot;,<br>\t\ts, len(x), cap(x), x)<br>}<br><br>输出结果<br>s1 len=5 cap=5 [1 2 3 4 5]<br>s1 len=4 cap=5 [1 2 3 4]","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422911,"discussion_content":"嗯对，一切都从底层数组上找答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535515912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1347664,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZZZzKAbLpj2qZwic2brxJ9laAcFFkjN0k8qib0UuXCwFuL472KCcDic1VeTpQ1oUxSu1TK9pPyiaRIQ/132","nickname":"爱看书的小女神","note":"","ucode":"5E21F5A1161054","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363368,"discussion_content":"不是缩容吗？但是这个cap的大小并没有发生变化啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617181690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291170,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1620096061,"is_pvip":true,"discussion_count":1,"race_medal":2,"score":"10210030653","product_id":100013101,"comment_content":"留言人数创新高，看来很多同学都和我一样对数组 array 和 切片 slice 有兴趣，其实本篇主要讲的是切片，当然数组是切片的基础。<br><br>面试的时候，随便问一下数组和切片，就可以聊的风生水起了。<br><br>An array is a numbered sequence of elements of a single type... Array types are always one-dimensional but may be composed to form multi-dimensional types.<br><br>A slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array.<br><br>数组和切片都属于集合类的类型，都有 len 和 cap 方法，那么时候可以用统一的方式打印出来呢？类似于<br><br>```<br>fmt.Printf(&quot;len: %d, cap: %d\\n&quot;, len(slice), cap(slice))<br>```<br><br>每个切片的底层数据结构中，一定包含一个数组，切片的容量可以看做是透过这个窗口最多可以看到的底层数组中元素的个数。<br><br>老师的“窗口”说，实在是太形象了，特别是<br><br>```<br>s4[0:cap(s4)+1]<br>```<br><br>会在运行时报错：<br><br>```<br>panic: runtime error: slice bounds out of range [:6] with capacity 5<br>```<br><br>抄一段 growslice 中的代码<br><br>```<br>newcap := old.cap<br>doublecap := newcap + newcap<br>if cap &gt; doublecap {<br>    newcap = cap<br>} else {<br>    if old.len &lt; 1024 {<br>        newcap = doublecap<br>    } else {<br>        &#47;&#47; Check 0 &lt; newcap to detect overflow<br>        &#47;&#47; and prevent an infinite loop.<br>        for 0 &lt; newcap &amp;&amp; newcap &lt; cap {<br>            newcap += newcap &#47; 4<br>        }<br>        &#47;&#47; Set newcap to the requested cap when<br>        &#47;&#47; the newcap calculation overflowed.<br>        if newcap &lt;= 0 {<br>            newcap = cap<br>        }<br>    }<br>}<br>```<br><br>append 函数返回的是原底层数组的原切片还是新底层数组的新切片，也很 tricky<br><br>对于思考题：<br><br>1. 如果有多个切片指向同一个底层数组，那么应该要小心不要被“别人”的修改影响<br><br>2. 照猫画虎的缩容代码<br><br>```<br>newcap := old.cap<br>halfcap := old.cap &#47; 2<br><br>if cap &lt; halfcap {<br>    newcap := cap<br>} else {<br>    if old.len &lt; 1024 {<br>        newcap = halfcap<br>    } else {<br>        for 0 &lt; newcap &amp;&amp; newcap &lt; cap {<br>            newcap -= newcap &#47; 5<br>        }<br>        if newcap &lt;= 0 {<br>            newcap = cap<br>        }<br>    }<br>}<br>```<br><br>slice.go 的源码中没有提供缩容代码，按照留言中的提示，缩容会引用底层的原始数组，影响垃圾回收，不如新建数组，然后 copy。<br><br>另外看到留言里面有同学“暴力”缩容，估计效果不错<br><br>```<br>func shrinkSlice(x []int) []int{<br>    if( cap(x) &gt; 0 ) {<br>        x = x[0:cap(x)-1]<br>    }<br>    return x<br>}<br>```<br><br>看了置顶的两条评论，其实有一个根本的问题就是：是老师适应学生，还是学生适应老师。我觉得在学习阶段，应该还是学生更主动一些。即使是同事之间的探讨，可能也需要去适应对方的说话风格和习惯，而不是希望对方改变。","like_count":2,"discussions":[{"author":{"id":1603571,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKgNge1sNXIWCFeUOa53cU5Glfw24sjxibBxTiaTb45LmU9bRDlDgBib9goFZXmoKwXTOJ4JMvVHHbiaA/132","nickname":"潘林林","note":"","ucode":"31576141FE4A1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403549,"discussion_content":"if cap < halfcap {\n    newcap := cap\n} else { //进入else的话说明cap >=halfcap\n    if old.len < 1024 {\n        newcap = halfcap //这里怎么能把newcap设置成halfcap呢？\n    }\n.....\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634106635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124312,"user_name":"cameron","can_delete":false,"product_type":"c1","uid":1016803,"ip_address":"","ucode":"EF0241A97EBB22","user_header":"","comment_is_top":false,"comment_ctime":1565858120,"is_pvip":false,"replies":[{"id":"45650","content":"不是","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1565877555,"ip_address":"","comment_id":124312,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10155792712","product_id":100013101,"comment_content":"数组是集合类型吗","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463110,"discussion_content":"不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565877555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748964,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/af/e4/cbfb57af.jpg","nickname":"star","note":"","ucode":"CFA2987EB62579","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312061,"discussion_content":"文中不是说是集合类的类型吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602577404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118581,"user_name":"Conan","can_delete":false,"product_type":"c1","uid":1205010,"ip_address":"","ucode":"9AF94D6E4BE4F5","user_header":"https://static001.geekbang.org/account/avatar/00/12/63/12/adbc3696.jpg","comment_is_top":false,"comment_ctime":1564391751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10154326343","product_id":100013101,"comment_content":"这篇专栏刚出来时，我只读了一节，就不想看了，跟那位说的一样“有点啰嗦太学术化”。现在重新看，语言精练些了。<br>不过，内容非常好。例子非常好。还新加了图。点赞","like_count":2},{"had_liked":false,"id":36558,"user_name":"Action","can_delete":false,"product_type":"c1","uid":1152692,"ip_address":"","ucode":"19EB7FA5F899DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/96/b4/19daa7cc.jpg","comment_is_top":false,"comment_ctime":1541150031,"is_pvip":false,"replies":[{"id":"13296","content":"容量很少会是1600这种，因为基本上都是以2为底的。文章中的切片扩容策略你可以再好好看一下。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541480845,"ip_address":"","comment_id":36558,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10131084623","product_id":100013101,"comment_content":"老师您好！我对源码demo16中示例1、3实际运行结果与预期结果表示ok，但唯独示例2的运行结果觉得没有什么规则可供参考，为何不是下面我预期的结果呢，对于实际的运行结果表示不理解，还烦请老师有空帮忙解答下，感谢！<br><br>代码如下：<br>&#47;&#47; 示例2<br>s7 := make([]int, 1024)<br>fmt.Printf(&quot;The capacity of s7: %d\\n&quot;, cap(s7))<br>s7e1 := append(s7, make([]int, 200)...)<br>fmt.Printf(&quot;s7e1: len: %d, cap: %d\\n&quot;, len(s7e1), cap(s7e1))<br>s7e2 := append(s7, make([]int, 400)...)<br>fmt.Printf(&quot;s7e2: len: %d, cap: %d\\n&quot;, len(s7e2), cap(s7e2))<br>s7e3 := append(s7, make([]int, 600)...)<br>fmt.Printf(&quot;s7e3: len: %d, cap: %d\\n&quot;, len(s7e3), cap(s7e3))<br>fmt.Println()<br>实际运行结果：<br>The capacity of s7: 1024<br>s7e1: len: 1224, cap: 1280<br>s7e2: len: 1424, cap: 1696<br>s7e3: len: 1624, cap: 2048<br><br>预期运行结果：<br>The capacity of s7: 1024<br>s7e1: len: 1224, cap: 1280<br>s7e2: len: 1424, cap: 1600<br>s7e3: len: 1624, cap: 2000","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427911,"discussion_content":"容量很少会是1600这种，因为基本上都是以2为底的。文章中的切片扩容策略你可以再好好看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541480845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1563985,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","nickname":"Geek_a8be59","note":"","ucode":"BEC0F57B51DC44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299,"discussion_content":"这个写的很清楚 https://www.cnblogs.com/qcrao-2018/p/10631989.html","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1561435573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625690,"avatar":"","nickname":"InfoQ_ad0a52af1586","note":"","ucode":"8ACD132E908038","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15008,"discussion_content":"哈哈，老师就是想我们探索下....简言之，超过1024时乘以1.25的基础上有个内存对齐的过程，也就是说有这么个过程：2^(n)>=1024*m*1.25。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568795134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":26585,"user_name":"Spike","can_delete":false,"product_type":"c1","uid":1200587,"ip_address":"","ucode":"9548DF1596CF9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/cb/c8b42257.jpg","comment_is_top":false,"comment_ctime":1537684434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10127619026","product_id":100013101,"comment_content":"我觉得叫指针结构的包装，比叫引用类型更严谨。我查阅了官方文档，没有说slice是引用类型。https:&#47;&#47;github.com&#47;golang&#47;go&#47;commit&#47;b34f0551387fcf043d65cd7d96a0214956578f94<br>在go的注释里去掉了slice是引用类型的语句","like_count":2},{"had_liked":false,"id":21821,"user_name":"qiujingzhe","can_delete":false,"product_type":"c1","uid":1203767,"ip_address":"","ucode":"5ACAFD56959D8F","user_header":"https://static001.geekbang.org/account/avatar/00/12/5e/37/1ab64338.jpg","comment_is_top":false,"comment_ctime":1535363978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10125298570","product_id":100013101,"comment_content":"循序渐进，由浅入深，让我这个新手也能跟得上了。","like_count":2},{"had_liked":false,"id":310704,"user_name":"咸鱼三月°","can_delete":false,"product_type":"c1","uid":2662227,"ip_address":"","ucode":"A4FBF948CA0C55","user_header":"https://static001.geekbang.org/account/avatar/00/28/9f/53/f5cbccfa.jpg","comment_is_top":false,"comment_ctime":1630848756,"is_pvip":false,"replies":[{"id":"112586","content":"这是Go语言的语言规范中规定的（详见：https:&#47;&#47;golang.google.cn&#47;ref&#47;spec#Slice_expressions）。切片本身就是引用类型了，你无需再生成它的指针，这个指针没什么意义。数组是值类型，它的指针是有意义的（传递的时候可以保证指向同一个数组）。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1630899954,"ip_address":"","comment_id":310704,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5925816052","product_id":100013101,"comment_content":"老师你好我在自己练手的时候有一些疑惑<br>&#47;&#47;BubbleSort 示例1 传数组的指针类型<br>&#47;**<br>冒泡排序<br>*&#47;<br>func BubbleSort(arr *[10]int) {<br>\ta:=arr<br>\tfor i := 0; i &lt; len(a)-1; i++ {<br>\t\tfor j := 0; j &lt; len(a)-i-1; j++ {<br>\t\t\tif a[j] &gt; a[j+1] {<br>\t\t\t\ttem:= a[j]<br>\t\t\t\ta[j]=a[j+1]<br>\t\t\t\ta[j+1]=tem<br>\t\t\t}<br>\t\t}<br>\t}<br>\tfmt.Println(arr)<br>}<br><br>&#47;&#47;BubbleSort 示例2 传切片的指针类型<br>&#47;**<br>冒泡排序<br>*&#47;<br>func BubbleSort(arr *[]int) {<br>\ta:=arr<br>\tfor i := 0; i &lt; len(a)-1; i++ {<br>\t\tfor j := 0; j &lt; len(a)-i-1; j++ {<br>\t\t\tif a[j] &gt; a[j+1] {<br>\t\t\t\ttem:= a[j]<br>\t\t\t\ta[j]=a[j+1]<br>\t\t\t\ta[j+1]=tem<br>\t\t\t}<br>\t\t}<br>\t}<br>\tfmt.Println(arr)<br>}<br><br>为什么切片的指针类型取下标时编译器会提示语法错误呢，但是数组的指针类型取下标并不会提示语法错误，这一款让我感到疑惑 希望老师能够帮忙解答一下","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526314,"discussion_content":"这是Go语言的语言规范中规定的（详见：https://golang.google.cn/ref/spec#Slice_expressions）。切片本身就是引用类型了，你无需再生成它的指针，这个指针没什么意义。数组是值类型，它的指针是有意义的（传递的时候可以保证指向同一个数组）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630899954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409256,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635403813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288617,"user_name":"郑川","can_delete":false,"product_type":"c1","uid":1986345,"ip_address":"","ucode":"10A088829AFC3F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4f/29/20340b35.jpg","comment_is_top":false,"comment_ctime":1618562937,"is_pvip":false,"replies":[{"id":"104784","content":"是的！给你个赞👍","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1618660689,"ip_address":"","comment_id":288617,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5913530233","product_id":100013101,"comment_content":"append单个元素或者少量(double之后能容下)多个元素会走1024以下双倍,超过1024的1.25倍扩容,<br>append多个元素(double后不能容下)会 直接使用预估的容量,<br>此外在得到新的容量会乘以slice元素的类型size，算出新的容量需要的内存capmem向上取整(sizeclasses.go文件，在这个文件的开头，给出了golang对象大小表)得到新的所需内存,再除以size,作为最终的容量，专业名词叫内存对齐。","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518684,"discussion_content":"是的！给你个赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618660689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409259,"discussion_content":"内存对齐！Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635403890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248413,"user_name":"Geek_adf04b","can_delete":false,"product_type":"c1","uid":2032790,"ip_address":"","ucode":"CD709E278D979B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/9o4qQVZB2FjiaDxwLYZhL3E7HpvRIvETvZKGtF7Wiasc3jNIvTODQ6utnbQFQDYzzicqfwGM2MjNOblIBLLUmWFMQ/132","comment_is_top":false,"comment_ctime":1600154080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895121376","product_id":100013101,"comment_content":"相比自己看书学习，听高人讲课学习效率是真高，之前绕半天的问题，这里一张图片就讲明白了，课程买晚了。","like_count":1},{"had_liked":false,"id":243581,"user_name":"Bruce Lee","can_delete":false,"product_type":"c1","uid":1340746,"ip_address":"","ucode":"E51A47BB74DEA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/75/4a/eb2f4f64.jpg","comment_is_top":false,"comment_ctime":1598195856,"is_pvip":false,"replies":[{"id":"89782","content":"在 src&#47;runtime&#47;slice.go 文件的 growslice 函数中有这么一段代码：<br><br>```<br>\tnewcap := old.cap<br>\tdoublecap := newcap + newcap<br>\tif cap &gt; doublecap {<br>\t\tnewcap = cap<br>\t} else {<br>\t\tif old.len &lt; 1024 {<br>\t\t\tnewcap = doublecap<br>\t\t} else {<br>\t\t\t&#47;&#47; Check 0 &lt; newcap to detect overflow<br>\t\t\t&#47;&#47; and prevent an infinite loop.<br>\t\t\tfor 0 &lt; newcap &amp;&amp; newcap &lt; cap {<br>\t\t\t\tnewcap += newcap &#47; 4<br>\t\t\t}<br>\t\t\t&#47;&#47; Set newcap to the requested cap when<br>\t\t\t&#47;&#47; the newcap calculation overflowed.<br>\t\t\tif newcap &lt;= 0 {<br>\t\t\t\tnewcap = cap<br>\t\t\t}<br>\t\t}<br>\t}<br>```<br><br>你看完这段是不是就明白了？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1598237799,"ip_address":"","comment_id":243581,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5893163152","product_id":100013101,"comment_content":"&#47;&#47; 示例3。<br>s8 := make([]int, 10)<br>fmt.Printf(&quot;The capacity of s8: %d\\n&quot;, cap(s8))<br>s8a := append(s8, make([]int, 11)...) <br>fmt.Printf(&quot;s8a: len: %d, cap: %d\\n&quot;, len(s8a), cap(s8a))<br><br>预期：<br>The capacity of s8: 10<br>s8a: len: 21, cap: 40 <br><br>实际：<br>The capacity of s8: 10<br>s8a: len: 21, cap: 22<br><br>如果我们一次追加的元素过多，以至于使新长度比原容量的 2 倍还要大，那么新容量就会以新长度为基准<br>是不是这句话理解的原因 导致 预期 与实际不符<br>麻烦老师解答下<br>","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504332,"discussion_content":"在 src/runtime/slice.go 文件的 growslice 函数中有这么一段代码：\n\n```\n\tnewcap := old.cap\n\tdoublecap := newcap + newcap\n\tif cap &amp;gt; doublecap {\n\t\tnewcap = cap\n\t} else {\n\t\tif old.len &amp;lt; 1024 {\n\t\t\tnewcap = doublecap\n\t\t} else {\n\t\t\t// Check 0 &amp;lt; newcap to detect overflow\n\t\t\t// and prevent an infinite loop.\n\t\t\tfor 0 &amp;lt; newcap &amp;amp;&amp;amp; newcap &amp;lt; cap {\n\t\t\t\tnewcap += newcap / 4\n\t\t\t}\n\t\t\t// Set newcap to the requested cap when\n\t\t\t// the newcap calculation overflowed.\n\t\t\tif newcap &amp;lt;= 0 {\n\t\t\t\tnewcap = cap\n\t\t\t}\n\t\t}\n\t}\n```\n\n你看完这段是不是就明白了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598237799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200167,"user_name":"王掌柜","can_delete":false,"product_type":"c1","uid":1141406,"ip_address":"","ucode":"70AD0DF9B261BD","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/9e/37bcc853.jpg","comment_is_top":false,"comment_ctime":1585552281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880519577","product_id":100013101,"comment_content":"文章中那段「有一个窗口，你可以通过这个窗口看到一个数组，但是不一定能看到该数组中的所有元素，有时候只能看到连续的一部分元素」非常妙，一下子就搞明白了。","like_count":1},{"had_liked":false,"id":85743,"user_name":"stefen","can_delete":false,"product_type":"c1","uid":1202047,"ip_address":"","ucode":"7C9AAE829E7802","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/oib0a89lqtOhJL1UvfUp4uTsRLrDbhoGk9jLiciazxMu0COibJsFCZDypK1ZFcHEJc9d9qgbjvgR41ImL6FNPoVlWA/132","comment_is_top":false,"comment_ctime":1555218444,"is_pvip":false,"replies":[{"id":"30828","content":"仔细看文章中的描述，我应该已经讲得比较清楚了。s2 := s1[0:3] 只是基于同一个底层数组生成了一个新的切片（或者说窗口）。而 make 出来的 s2 是有自己的底层数组的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1555228942,"ip_address":"","comment_id":85743,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850185740","product_id":100013101,"comment_content":"package main<br><br>import &quot;fmt&quot;<br><br>func main() {<br>\ts1 := []int{1, 2, 3, 4, 5}<br>\ts2 := s1[0:3]<br>\t&#47;&#47; s2 := make([]int, 3)<br>\tcopy(s2, s1)<br>\ts2 = append(s2, 40)<br>\ts1[2] = 30<br><br>\tfmt.Printf(&quot;The length of s1: %d\\n&quot;, len(s1))<br>\tfmt.Printf(&quot;The capacity of s1: %d\\n&quot;, cap(s1))<br>\tfmt.Printf(&quot;The value of s1: %d\\n&quot;, s1)<br><br>\tfmt.Printf(&quot;The length of s2: %d\\n&quot;, len(s2))<br>\tfmt.Printf(&quot;The capacity of s2: %d\\n&quot;, cap(s2))<br>\tfmt.Printf(&quot;The value of s2: %d\\n&quot;, s2)<br>}<br><br>为啥这种copy赋值后, 还是会受底层数组s1的影响，用make初始化s2这种方式就可以不受s1值的影响","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446787,"discussion_content":"仔细看文章中的描述，我应该已经讲得比较清楚了。s2 := s1[0:3] 只是基于同一个底层数组生成了一个新的切片（或者说窗口）。而 make 出来的 s2 是有自己的底层数组的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555228942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74010,"user_name":"kkgo","can_delete":false,"product_type":"c1","uid":1199356,"ip_address":"","ucode":"AFCCBFD96CFA21","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/fc/0e887697.jpg","comment_is_top":false,"comment_ctime":1552059467,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5847026763","product_id":100013101,"comment_content":"a:=[...]int{1,2,3}这种当时数组赋值也没有指定长度","like_count":1},{"had_liked":false,"id":33521,"user_name":"🄽🄸🅇🅄🅂","can_delete":false,"product_type":"c1","uid":1000060,"ip_address":"","ucode":"853763C229A5AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","comment_is_top":false,"comment_ctime":1539821054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834788350","product_id":100013101,"comment_content":"内容很棒！知识拓展中的数组扩容，好像只讲了一半。看growslice中的源码，好像是只讲了一半，switch的这部分，应该是造成扩容时，没有严格按照2倍 或 1.25倍的罪魁祸首！还没弄明白……自己需要多努力了！<br>谢谢老师，祝您早日康复！","like_count":1},{"had_liked":false,"id":24345,"user_name":"Beau Zhang","can_delete":false,"product_type":"c1","uid":1200944,"ip_address":"","ucode":"7600A3F8592CA6","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/30/e0930b07.jpg","comment_is_top":false,"comment_ctime":1536913668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5831880964","product_id":100013101,"comment_content":"s9 := make([]int,  44)<br>fmt.Printf(&quot;The capacity of s9: %d\\n&quot;, cap(s9))<br> s9a := append(s9, make([]int, 45)...)<br>fmt.Printf(&quot;s9a: len: %d, cap: %d\\n&quot;, len(s9a), cap(s9a))<br>下面是输出结果<br>The capacity of s9: 44<br>s9a: len: 89, cap: 96<br>按照扩容的规则cap = 90才对啊<br>这是怎么回事？","like_count":1},{"had_liked":false,"id":21752,"user_name":"V","can_delete":false,"product_type":"c1","uid":1198130,"ip_address":"","ucode":"78CABAFF10DE8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/32/834b3020.jpg","comment_is_top":false,"comment_ctime":1535307565,"is_pvip":true,"replies":[{"id":"7794","content":"关于这两个函数的用法和相应规则，Go语言规范里都说的很清楚了。你可以去 golang.google.cn&#47;doc&#47;spec 看一下，描述得很清晰。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535342483,"ip_address":"","comment_id":21752,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5830274861","product_id":100013101,"comment_content":"老师可以详细讲一下内置函数make()和new()的却别吗","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422843,"discussion_content":"关于这两个函数的用法和相应规则，Go语言规范里都说的很清楚了。你可以去 golang.google.cn/doc/spec 看一下，描述得很清晰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535342483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351485,"user_name":"于潇","can_delete":false,"product_type":"c1","uid":2288300,"ip_address":"","ucode":"7774B89FBDA8A0","user_header":"https://static001.geekbang.org/account/avatar/00/22/ea/ac/cbb360a1.jpg","comment_is_top":false,"comment_ctime":1657846783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657846783","product_id":100013101,"comment_content":"真痛苦啊，买了小10个课，就这个读的真是痛苦啊，我这还是写过golang一年的。","like_count":0},{"had_liked":false,"id":332757,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1643554042,"is_pvip":true,"replies":[{"id":"121714","content":"用一句话说，当一个切片的底层数组的剩余长度（也叫这个切片的容量）不足以容纳新元素的时候。要注意，这里的剩余长度指的是，从在这个切片所代表的窗口之中能够看到的（底层数组的）索引最小的那个槽位直到（底层数组的）最后一个槽位的索引差。所以，处在这个切片窗口左边的那些底层数组槽位都不会算在这个切片的容量内，比如对于你说的这个例子，s3 中的索引值为 0、1、2 的那几个槽位就不会被算在 s4 的容量内。我们说的切片扩展都是单向的，即向切片的右边（索引更大的那一边）扩展，如果底层数组还够用那就接着用，如果不够用了那就换一个底层数组。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1644043992,"ip_address":"","comment_id":332757,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643554042","product_id":100013101,"comment_content":"缩容的思想就是把需要使用的数据拷贝到新的数组后，再去释放原来的数组。节省空间。<br>另外实验中观察到一个很有趣的现象，就是\ts4 := s3[3:6]，在S4上append一个新元素后，就会创建一个新的数组。不知道这个新数组创建的时机是什么时候？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549514,"discussion_content":"用一句话说，当一个切片的底层数组的剩余长度（也叫这个切片的容量）不足以容纳新元素的时候。要注意，这里的剩余长度指的是，从在这个切片所代表的窗口之中能够看到的（底层数组的）索引最小的那个槽位直到（底层数组的）最后一个槽位的索引差。所以，处在这个切片窗口左边的那些底层数组槽位都不会算在这个切片的容量内，比如对于你说的这个例子，s3 中的索引值为 0、1、2 的那几个槽位就不会被算在 s4 的容量内。我们说的切片扩展都是单向的，即向切片的右边（索引更大的那一边）扩展，如果底层数组还够用那就接着用，如果不够用了那就换一个底层数组。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644043992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328101,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1640530419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640530419","product_id":100013101,"comment_content":"切片emmmm  咋说呢 感觉就是针对java list换了个名字。只不过多了外面的窗口，可以从某个点看到最后。","like_count":0},{"had_liked":false,"id":322452,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1637395546,"is_pvip":false,"replies":[{"id":"117152","content":"我不知道你代码里的 a9 是什么","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1637562126,"ip_address":"","comment_id":322452,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637395546","product_id":100013101,"comment_content":"请问，我在demo17中加了2个打印：<br>fmt.Printf(&quot;s9 zero copy value: %v\\n&quot;, (*(*[12]int)(unsafe.Pointer(&amp;a9))))<br>结果中为什么没有打印出a9的切片的内容，这个打印中的内容代表的是什么含义<br>s9 zero copy value: [824633868480 8 12 0 4261297 4400150 0 824633901056 824634042152 4215685 824633892960 0]","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532240,"discussion_content":"我不知道你代码里的 a9 是什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637562126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311171,"user_name":"Geek_08d3be","can_delete":false,"product_type":"c1","uid":2759900,"ip_address":"","ucode":"59587F5FBE972A","user_header":"","comment_is_top":false,"comment_ctime":1631093604,"is_pvip":false,"replies":[{"id":"112813","content":"不包含。广义来讲，空指针不指向任何东西。<br><br>但 slice 中不只有指向底层数组的指针，还记录有“窗口”的宽度（即len），以及它潜在的最大宽度（即cap）。<br><br>var slice []int 只会搞出一个未初始化的切片，当然这时其中的那个指针也是不可用的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1631164054,"ip_address":"","comment_id":311171,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631093604","product_id":100013101,"comment_content":"【在每个切片的底层数据结构中，一定会包含一个数组】，如果是nil切片(var slice []int)，数组指针指向的是一个nil，这时候应该不包含数组？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526505,"discussion_content":"不包含。广义来讲，空指针不指向任何东西。\n\n但 slice 中不只有指向底层数组的指针，还记录有“窗口”的宽度（即len），以及它潜在的最大宽度（即cap）。\n\nvar slice []int 只会搞出一个未初始化的切片，当然这时其中的那个指针也是不可用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631164054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286375,"user_name":".","can_delete":false,"product_type":"c1","uid":1439873,"ip_address":"","ucode":"5D8B1D54979A11","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/81/6980afb7.jpg","comment_is_top":false,"comment_ctime":1617272871,"is_pvip":false,"replies":[{"id":"104056","content":"怎么打不开了？说具体一点。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1617328359,"ip_address":"","comment_id":286375,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617272871","product_id":100013101,"comment_content":"老师demo源码怎么打不开了","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517962,"discussion_content":"怎么打不开了？说具体一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617328359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281560,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1614786441,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614786441","product_id":100013101,"comment_content":"好奇为什么要选择1024作为边界","like_count":0},{"had_liked":false,"id":266569,"user_name":"wangkaiyuan","can_delete":false,"product_type":"c1","uid":1626276,"ip_address":"","ucode":"FB975EB1DB53F0","user_header":"https://static001.geekbang.org/account/avatar/00/18/d0/a4/9f8978dc.jpg","comment_is_top":false,"comment_ctime":1607396481,"is_pvip":false,"replies":[{"id":"96847","content":"是的","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1607481326,"ip_address":"","comment_id":266569,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607396481","product_id":100013101,"comment_content":"多个切片指向了同一个底层数组，每个切片如果都有一个goroutine去修改切片中第一个值，是不是就会有并发的问题","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511316,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607481326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263654,"user_name":"无为","can_delete":false,"product_type":"c1","uid":1252164,"ip_address":"","ucode":"81D7AF5E1FDD30","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/44/82acaafc.jpg","comment_is_top":false,"comment_ctime":1606208234,"is_pvip":true,"replies":[{"id":"95638","content":"1. 是这样的。所以要注意并发操作的问题。<br>2. 是有可能，但是在程序运行的过程中不好做判断。所以还是不要做假设。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1606212334,"ip_address":"","comment_id":263654,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606208234","product_id":100013101,"comment_content":"思考1<br><br>1. 修改的时候会可能互相影响<br>2. 扩容后, 有可能底层数组不是同一个数组了","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510258,"discussion_content":"1. 是这样的。所以要注意并发操作的问题。\n2. 是有可能，但是在程序运行的过程中不好做判断。所以还是不要做假设。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606212334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242751,"user_name":"郭星","can_delete":false,"product_type":"c1","uid":1182219,"ip_address":"","ucode":"8A0F5DF80E0C61","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/0b/985d3800.jpg","comment_is_top":false,"comment_ctime":1597831048,"is_pvip":false,"replies":[{"id":"89556","content":"当然有啊！<br><br>自己去看：src&#47;runtime&#47;slice.go 里的 func growslice<br><br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1597891967,"ip_address":"","comment_id":242751,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597831048","product_id":100013101,"comment_content":"&quot;append函数总会返回新的切片&quot; 这个有源码可以查看吗?","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504088,"discussion_content":"当然有啊！\n\n自己去看：src/runtime/slice.go 里的 func growslice\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597891967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240949,"user_name":"不明飞行人","can_delete":false,"product_type":"c1","uid":1070367,"ip_address":"","ucode":"12957770574703","user_header":"https://static001.geekbang.org/account/avatar/00/10/55/1f/ba15e095.jpg","comment_is_top":false,"comment_ctime":1597130823,"is_pvip":false,"replies":[{"id":"89070","content":"你的 %p 中的 p 是一个变量对吧？变量是同一个变量，指针当然也相同了。看源码，得真知。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1597137289,"ip_address":"","comment_id":240949,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1597130823","product_id":100013101,"comment_content":"本讲的最后总结部分 “另外，append函数总会返回新的切片，而且如果新切片的容量比原切片的容量更大那么就意味着底层数组也是新的了。”中的 “另外，append函数总会返回新的切片”这一句怎么理解？<br>我用实际代码验证（以%p的格式打印append函数返回的切片），好像在没发生扩容的情况下返回的还是原来的切片，并没有像文章中说的“append函数总会返回新的切片”。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503604,"discussion_content":"你的 %p 中的 p 是一个变量对吧？变量是同一个变量，指针当然也相同了。看源码，得真知。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597137289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363197,"discussion_content":"原因是p打印切片时，返回的是底层数组中第一个元素的地址。并不是引用slice结构体的实际内存地址。append总是返回新的切片，因为append后，原切片的长度，容量，底层数组都可能发生变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617127002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229029,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":2005742,"ip_address":"","ucode":"CB7AC741E0E4B7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","comment_is_top":false,"comment_ctime":1592882292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592882292","product_id":100013101,"comment_content":"其实有点类似与 C++ STL容器中的 vector","like_count":0},{"had_liked":false,"id":228063,"user_name":"benying","can_delete":false,"product_type":"c1","uid":1247522,"ip_address":"","ucode":"DEBAB485F381CC","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/22/22c0c4fa.jpg","comment_is_top":false,"comment_ctime":1592547111,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592547111","product_id":100013101,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":212011,"user_name":"咸鱼不想翻身","can_delete":false,"product_type":"c1","uid":1447584,"ip_address":"","ucode":"F662980A82DC18","user_header":"https://static001.geekbang.org/account/avatar/00/16/16/a0/88c17929.jpg","comment_is_top":false,"comment_ctime":1588046147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588046147","product_id":100013101,"comment_content":"package main<br><br>import &quot;fmt&quot;<br><br>func main() {<br>\tl1 := [5]int{0, 1, 2, 3, 4}<br>\ts1 := l1[0:]<br>\ts2 := l1[2:4]<br>\tfmt.Printf(&quot;The l1 value: %v; &quot; +<br>\t\t&quot;The s1 value: %v; &quot; +<br>\t\t&quot;The s2 value: %v\\n&quot;, l1, s1, s2)<br><br>\tfor i := 1; i &lt;= 5; i++ {<br>\t\ts2 = append(s2, i)<br>\t\tfmt.Printf(&quot;The s2 value: %v; The l1 value: %v\\n&quot;, s2, l1)<br>\t}<br>}<br><br>从以上代码得出，多个切片指向同一个底层数组时，当某个切片扩容时，其指向的底层数组将不再是同一个。","like_count":0},{"had_liked":false,"id":198064,"user_name":"john-jy","can_delete":false,"product_type":"c1","uid":1116514,"ip_address":"","ucode":"6B5884409B52C9","user_header":"","comment_is_top":false,"comment_ctime":1585408108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585408108","product_id":100013101,"comment_content":"如果有多个切片指向了同一个底层数组，那么在进行切片操作的时候，要注意对底层数组数据的修改，有可能会影响其他切片","like_count":0},{"had_liked":false,"id":194384,"user_name":"starj","can_delete":false,"product_type":"c1","uid":1108791,"ip_address":"","ucode":"3546E42F1340B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/37/a2f4c9f8.jpg","comment_is_top":false,"comment_ctime":1585056421,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585056421","product_id":100013101,"comment_content":"好像基本都用切片就可以了，不会用到数组","like_count":0},{"had_liked":false,"id":185640,"user_name":"西边一抹残阳","can_delete":false,"product_type":"c1","uid":1197178,"ip_address":"","ucode":"6836AB08783DC5","user_header":"https://static001.geekbang.org/account/avatar/00/12/44/7a/d27c1ed3.jpg","comment_is_top":false,"comment_ctime":1583652595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583652595","product_id":100013101,"comment_content":"1、如果多个切片共同指向某一个底层数组，使用时要注意数组下标是否发生越界吧，因为可能某一个切片会进行扩容操作","like_count":0},{"had_liked":false,"id":180618,"user_name":"mrlay","can_delete":false,"product_type":"c1","uid":1041640,"ip_address":"","ucode":"385A1954ED3317","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","comment_is_top":false,"comment_ctime":1582352396,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582352396","product_id":100013101,"comment_content":"问题一： 因为用的是同一个底层的数组，需要注意的是交叉踩踏的问题，扩容其实是有限制的（只有起始地址在底层数组最右边的那个切片才可以qppend一个新的切片）","like_count":0,"discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385889,"discussion_content":"只有起始地址在底层数组最右边的那个切片才可以qppend一个新的切片 \n\n同学，没明白你这句话。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627315335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175189,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1580608201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580608201","product_id":100013101,"comment_content":"对于数组，只能更新元素不能追加和删除元素。<br>对于切片，更新操作更新的是底层数组，追加操作如果不超底层数组的右界则也是更新底层数组，如果超了则新建一个容量更大的底层数组。<br>","like_count":0},{"had_liked":false,"id":166904,"user_name":"海盗船长","can_delete":false,"product_type":"c1","uid":1363634,"ip_address":"","ucode":"ECB28BA21A4113","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/b2/1f914527.jpg","comment_is_top":false,"comment_ctime":1577627984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577627984","product_id":100013101,"comment_content":"“在 Go 语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。<br>如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。” 这段描述大家没有疑问吗","like_count":0},{"had_liked":false,"id":163659,"user_name":"lixiaofeng","can_delete":false,"product_type":"c1","uid":1100200,"ip_address":"","ucode":"0D6710D95B6FFB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/a8/98507423.jpg","comment_is_top":false,"comment_ctime":1576762650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576762650","product_id":100013101,"comment_content":"多个分片指向同一个底层数组，当改变其中一个切片的值时，另一个切片也会改变。<br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>)<br><br>func main(){<br>\t&#47;&#47; make 函数生成切片<br>\t&#47;&#47;s1 := make([]int, 5)<br>\ts1 := []int{1,2,3,4,5,6,7,8}<br>\ts2 := s1[2:6]<br>\ts3 := s1[3:6]<br>\tprintln(&quot;begin&quot;)<br>\tprintln(s2[2])<br>\tprintln(s3[1])<br>\tprintln(&quot;change s2&quot;)<br>\ts2[2] =100<br><br>\tprintln(s2[2])<br>\tprintln(s3[1])<br>\tprintln(&quot;end&quot;)<br>\tfmt.Println(&quot;ok&quot;)<br>}","like_count":0},{"had_liked":false,"id":163293,"user_name":"水先生","can_delete":false,"product_type":"c1","uid":1249714,"ip_address":"","ucode":"362A71DF511E3E","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/b2/dd0606b2.jpg","comment_is_top":false,"comment_ctime":1576681144,"is_pvip":false,"replies":[{"id":"62118","content":"如果没有其他代码引用原切片的话，会被回收。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1576726043,"ip_address":"","comment_id":163293,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576681144","product_id":100013101,"comment_content":"请问扩容之后，原数组会被 回收么？ 不然新数组拷贝了旧数组的数据之后，旧数组不就占着空间了么？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478334,"discussion_content":"如果没有其他代码引用原切片的话，会被回收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576726043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139411,"user_name":"蜉蝣","can_delete":false,"product_type":"c1","uid":1229070,"ip_address":"","ucode":"77CF92496855D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","comment_is_top":false,"comment_ctime":1570628367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570628367","product_id":100013101,"comment_content":"老师的文字有些地方是得多读几遍才行，可这完全不是缺点啊。我认为是很不错的学术风，常常能让我静下心来阅读与理解。","like_count":0},{"had_liked":false,"id":136757,"user_name":"arronK","can_delete":false,"product_type":"c1","uid":1192961,"ip_address":"","ucode":"58DC6FBF2CF0C1","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/01/30ca98e6.jpg","comment_is_top":false,"comment_ctime":1569503692,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1569503692","product_id":100013101,"comment_content":"多个切片指向同一数组，他们在切片上对元素的改动都会影响到这个底层数组。<br>所以对于需要单独有所改动进行使用的地方，可以复制一份自己使用，避免对底层数组造成影响。","like_count":0},{"had_liked":false,"id":127079,"user_name":"mrlay","can_delete":false,"product_type":"c1","uid":1041640,"ip_address":"","ucode":"385A1954ED3317","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","comment_is_top":false,"comment_ctime":1566550711,"is_pvip":false,"replies":[{"id":"47088","content":"只是 PowerPoint 而已。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1566627469,"ip_address":"","comment_id":127079,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566550711","product_id":100013101,"comment_content":"你们的图片是用什么工具画的，感觉很特别","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464312,"discussion_content":"只是 PowerPoint 而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566627469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112900,"user_name":"andy1855","can_delete":false,"product_type":"c1","uid":1588760,"ip_address":"","ucode":"C1426CDCD143CA","user_header":"https://static001.geekbang.org/account/avatar/00/18/3e/18/4085ae5a.jpg","comment_is_top":false,"comment_ctime":1562839241,"is_pvip":false,"replies":[{"id":"41185","content":"因为得用反射啊，不拿到指针就没法反射。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1562907573,"ip_address":"","comment_id":112900,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562839241","product_id":100013101,"comment_content":"老师您好，请教一个问题，就是我理解的是切片其实是指向底层数组的指针，当切片作为参数时只需要传切片本身就可以；<br>不过我遇到一个解析json的问题，下面的代码中err = json.Unmarshal(data, &amp;labels)的第二个参数为什么要传指针呢？<br><br>package main<br><br>import (<br>\t. &quot;algorithms&#47;zeus&quot;<br>\t&quot;encoding&#47;json&quot;<br>\t&quot;fmt&quot;<br>\t&quot;io&#47;ioutil&quot;<br>\t&quot;strconv&quot;<br>)<br><br><br>func main() {<br>\tvar labels []Label<br><br>\tdata, err := ioutil.ReadFile(&quot;&#47;Users&#47;gyuan&#47;Documents&#47;andy&#47;dna_label&#47;dna_label_0711.json&quot;)<br>\tif err != nil {<br>\t\tfmt.Println(err.Error())<br>\t\treturn<br>\t}<br><br>\terr = json.Unmarshal(data, &amp;labels)<br>\tif err != nil {<br>\t\tfmt.Println(err.Error())<br>\t\treturn<br>\t}<br><br>\tfor _, label := range labels {<br>\t\tfmt.Printf(&quot;%v\\n&quot;, label)<br>\t}<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457950,"discussion_content":"因为得用反射啊，不拿到指针就没法反射。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562907573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95066,"user_name":"天涯囧侠","can_delete":false,"product_type":"c1","uid":1021753,"ip_address":"","ucode":"92E895114DD762","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/39/60d6a10d.jpg","comment_is_top":false,"comment_ctime":1557965647,"is_pvip":false,"replies":[{"id":"33998","content":"创建 slice 的开销很小。不过执行 append 有可能（注意，不是每次）会造成内存的申请和元素值的拷贝。这属于不可忽视的开销。<br><br>所以，对于一些可以预知容量的 slice，我还是建议在 make 的时候就留出足够的量，以免后续再 append。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1557990318,"ip_address":"","comment_id":95066,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557965647","product_id":100013101,"comment_content":"每次执行append会产生一个新的切片，这个对性能自己资源占用会不会有较大的影响？<br>有没有最佳实践。<br>就像JAVA里的字符串拼接建议适用stringbuilder一样。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450317,"discussion_content":"创建 slice 的开销很小。不过执行 append 有可能（注意，不是每次）会造成内存的申请和元素值的拷贝。这属于不可忽视的开销。\n\n所以，对于一些可以预知容量的 slice，我还是建议在 make 的时候就留出足够的量，以免后续再 append。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557990318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90757,"user_name":"小样","can_delete":false,"product_type":"c1","uid":1075443,"ip_address":"","ucode":"0D05E1D31150F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/f3/22481a37.jpg","comment_is_top":false,"comment_ctime":1556627725,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1556627725","product_id":100013101,"comment_content":"窗口的比喻非常贴切，看懂了","like_count":0},{"had_liked":false,"id":88561,"user_name":"张sir","can_delete":false,"product_type":"c1","uid":1209431,"ip_address":"","ucode":"52958DF6705208","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/57/7b828263.jpg","comment_is_top":false,"comment_ctime":1555942505,"is_pvip":false,"replies":[{"id":"31781","content":"由于Go语言的泛型目前还不支持协变，所以暂时只能用 for 循环来做。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1555984579,"ip_address":"","comment_id":88561,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555942505","product_id":100013101,"comment_content":"老师，我遇到一个问题，如何将一个字符串切片转换成接口类型的切片呢，比如这样的，args的类型是[]string,想换成[]interface{}类型，我用的这种办法是不可行的：interface{}(args).([]interface{})","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447829,"discussion_content":"由于Go语言的泛型目前还不支持协变，所以暂时只能用 for 循环来做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555984579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79700,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1553523137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553523137","product_id":100013101,"comment_content":"Slice 和 Java 的ArrayList 十分相似！","like_count":0},{"had_liked":false,"id":79699,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1553523097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553523097","product_id":100013101,"comment_content":"多个切片指向同一个数组就要考虑线程安全的问题了，其实在读本篇文章的过程中就一直在想 golang 如何控制切片的线程并发情况","like_count":0},{"had_liked":false,"id":74958,"user_name":"ican_只会0到9","can_delete":false,"product_type":"c1","uid":1029473,"ip_address":"","ucode":"9EE33C42EE519D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/61/9802a552.jpg","comment_is_top":false,"comment_ctime":1552322324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552322324","product_id":100013101,"comment_content":"1.如果多个切片指向同一底层数组，需要注意对底层数组的修改，引用相同片段的底层数组会因为其中一个切片的改变影响整个底层数组因此需要特别注意；<br>##################################<br>func arraySlice() {<br>\t&#47;&#47; 底层数组<br>\ts2 := [4]int{10, 20, 30, 40}<br><br>\ts3 := s2[:3]<br>\ts4 := s2[2:]<br><br>\tfmt.Printf(&quot;s3:%d\\n&quot;, s3)<br>\tfmt.Printf(&quot;s4:%d\\n&quot;, s4)<br>\tfmt.Println()<br><br>\t&#47;&#47; 修改其中一个切片<br>\ts4[0] = 60<br>\tfmt.Printf(&quot;s3:%d\\n&quot;, s3)<br>\tfmt.Printf(&quot;s4:%d\\n&quot;, s4)<br>}<br>结果如下：<br>&#47;&#47; s3:[10 20 30]<br>&#47;&#47; s4:[30 40]<br>&#47;&#47; <br>&#47;&#47; s3:[10 20 60]<br>&#47;&#47; s4:[60 40]<br><br>2.缩容：就是切片的切片<br>s5:=s3[1:]","like_count":0},{"had_liked":false,"id":70702,"user_name":"Jonathan Dai","can_delete":false,"product_type":"c1","uid":1358431,"ip_address":"","ucode":"0B39500675C63D","user_header":"https://static001.geekbang.org/account/avatar/00/14/ba/5f/feb02882.jpg","comment_is_top":false,"comment_ctime":1551167269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551167269","product_id":100013101,"comment_content":"长度：当前切片实际使用的量<br>容量：内存的分配量，当前切片可用的内存量","like_count":0},{"had_liked":false,"id":58134,"user_name":"辉仔lovers","can_delete":false,"product_type":"c1","uid":1210219,"ip_address":"","ucode":"3DC5B0CD0B8E71","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVhJRVwJ0eVlC7zjNfWP6PP7VmUkF1X2m6qfh7Wic3NhAOz2fSGibF6LXLcJ59zOz7nBpCcByvtFjw/132","comment_is_top":false,"comment_ctime":1547001099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547001099","product_id":100013101,"comment_content":"亲手实践了下，确实如老师所讲 ，<br>arr := []int{11,22,33}  这种方式 append的时候 cap 容量变成2倍，并且查看了 splice.go 的 growslice（）源码，源码如下，arr2 := arr1[1:3]  这种方式 当底层数组容量足够的时候，是不会扩容的。<br>newcap := old.cap<br>\tdoublecap := newcap + newcap<br>\tif cap &gt; doublecap {<br>\t\tnewcap = cap<br>\t} else {<br>\t\tif old.len &lt; 1024 {<br>\t\t\tnewcap = doublecap<br>\t\t} else {<br>\t\t\t&#47;&#47; Check 0 &lt; newcap to detect overflow<br>\t\t\t&#47;&#47; and prevent an infinite loop.<br>\t\t\tfor 0 &lt; newcap &amp;&amp; newcap &lt; cap {<br>\t\t\t\tnewcap += newcap &#47; 4<br>\t\t\t}<br>\t\t\t&#47;&#47; Set newcap to the requested cap when<br>\t\t\t&#47;&#47; the newcap calculation overflowed.<br>\t\t\tif newcap &lt;= 0 {<br>\t\t\t\tnewcap = cap<br>\t\t\t}<br>\t\t}<br>\t}","like_count":0},{"had_liked":false,"id":45332,"user_name":"Cutler","can_delete":false,"product_type":"c1","uid":1228136,"ip_address":"","ucode":"2EDECFE039845B","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/68/3fd6428d.jpg","comment_is_top":false,"comment_ctime":1543589146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543589146","product_id":100013101,"comment_content":"package main<br><br>import &quot;fmt&quot;<br><br>func main()  {<br>\ts1 := make([]int, 10)<br>\tfor i := 0; i &lt; 10 ; i++ {<br>\t\ts2 := append([]int{}, s1[i:]...)<br>\t\tfmt.Printf(&quot;s(%d): len: %d, cap: %d\\n&quot;, i, len(s2), cap(s2))<br>\t}<br>}","like_count":0},{"had_liked":false,"id":36315,"user_name":"liangjf","can_delete":false,"product_type":"c1","uid":1058812,"ip_address":"","ucode":"681A6CCF098F55","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg","comment_is_top":false,"comment_ctime":1541035745,"is_pvip":false,"replies":[{"id":"13300","content":"是的，源码之前了无秘密。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541481065,"ip_address":"","comment_id":36315,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541035745","product_id":100013101,"comment_content":"一直看到这里，这章收获是比较大的，看来深层次的还是要去看源码","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427826,"discussion_content":"是的，源码之前了无秘密。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541481065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34428,"user_name":"Err","can_delete":false,"product_type":"c1","uid":1210276,"ip_address":"","ucode":"BA952C73EE6753","user_header":"https://static001.geekbang.org/account/avatar/00/12/77/a4/e57f2014.jpg","comment_is_top":false,"comment_ctime":1540170404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540170404","product_id":100013101,"comment_content":"@sky我理解是因为对齐导致的，第一个你看下增加了256不是200","like_count":0},{"had_liked":false,"id":32630,"user_name":"张sir","can_delete":false,"product_type":"c1","uid":1209431,"ip_address":"","ucode":"52958DF6705208","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/57/7b828263.jpg","comment_is_top":false,"comment_ctime":1539652640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539652640","product_id":100013101,"comment_content":"请问老师，切片是数组的底层数组吗？这个前者和后者分别指什么","like_count":0},{"had_liked":false,"id":31818,"user_name":"顾骨","can_delete":false,"product_type":"c1","uid":1131165,"ip_address":"","ucode":"3F6BA592AB7723","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/9d/c36b7ef7.jpg","comment_is_top":false,"comment_ctime":1539306927,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539306927","product_id":100013101,"comment_content":"\ta := []int{1, 2, 3, 4, 5, 6, 7, 8}<br>\tb := a[3:6]<br>\tfmt.Printf(&quot;%x\\n&quot;, *(*int)((unsafe.Pointer)((uintptr)(unsafe.Pointer(&amp;b[0])) - 0x8)))<br><br>输出结果为a[2]的值，也就是3，这样不就通过b看到a的前面3个元素了吗","like_count":0},{"had_liked":false,"id":31087,"user_name":"liyuan35023","can_delete":false,"product_type":"c1","uid":1201851,"ip_address":"","ucode":"B92B230790E2CE","user_header":"https://static001.geekbang.org/account/avatar/00/12/56/bb/a346cd89.jpg","comment_is_top":false,"comment_ctime":1539085871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539085871","product_id":100013101,"comment_content":"s := make([]int, 2, 3)<br>fmt.Printf(&quot;%p\\n&quot;, s)<br>s = append(s, 2)<br>fmt.Printf(&quot;%p&quot;, s)<br>使用append，如果没有扩容，那么并不会返回一个新的切片啊，我用的golang 1.11<br>和版本有关么？？<br>","like_count":0},{"had_liked":false,"id":30082,"user_name":"Cyberpunk","can_delete":false,"product_type":"c1","uid":1259947,"ip_address":"","ucode":"02F6C967C970C5","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/ab/127e06d8.jpg","comment_is_top":false,"comment_ctime":1538649712,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1538649712","product_id":100013101,"comment_content":"func main() {<br>\ts9 := make([]int, 100)<br>\tfmt.Printf(&quot;len:%d, The capacity of s9: %d\\n&quot;, len(s9),cap(s9))<br>\ts9a := append(s9, make([]int, 100)...)<br>\tfmt.Printf(&quot;s9a: len: %d, cap: %d\\n&quot;, len(s9a), cap(s9a))<br>\tfmt.Println(s9a[:223][222])<br>\treturn<br>}<br><br>100,100并不是200，而是224为啥呢？<br><br>len:100, The capacity of s9: 100<br>s9a: len: 200, cap: 224<br>0","like_count":0},{"had_liked":false,"id":27516,"user_name":"ricktian","can_delete":false,"product_type":"c1","uid":1030928,"ip_address":"","ucode":"06F90004164C64","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/10/f01eafe4.jpg","comment_is_top":false,"comment_ctime":1537918296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537918296","product_id":100013101,"comment_content":"[3,5)这个好记～ 不错，脑补了好多细节","like_count":0},{"had_liked":false,"id":23012,"user_name":"拖鞋村长","can_delete":false,"product_type":"c1","uid":1197985,"ip_address":"","ucode":"7081F699E66135","user_header":"https://static001.geekbang.org/account/avatar/00/12/47/a1/ed748246.jpg","comment_is_top":false,"comment_ctime":1536110182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536110182","product_id":100013101,"comment_content":"java没有引用传递，误认为的引用传递也是复制了一个引用，针对这个引用本身还是值传递","like_count":0},{"had_liked":false,"id":22941,"user_name":"Mr.Liu","can_delete":false,"product_type":"c1","uid":1199948,"ip_address":"","ucode":"371B7F2C35DE02","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/4c/088371bd.jpg","comment_is_top":false,"comment_ctime":1536058278,"is_pvip":false,"replies":[{"id":"8281","content":"我记得是没有，你可以再算一下，或者直接去看源码。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536061433,"ip_address":"","comment_id":22941,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1536058278","product_id":100013101,"comment_content":"每次发现容量不够都会翻一倍，你可以从头算一下。另外，一旦超过1024每次只会增大1.25倍。运行了下示例，发现有的结果符合这个规律，有的不符合。这个和go版本有关系吗？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423334,"discussion_content":"我记得是没有，你可以再算一下，或者直接去看源码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536061433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22380,"user_name":"jacke","can_delete":false,"product_type":"c1","uid":1161209,"ip_address":"","ucode":"05F355E1FF88C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/f9/a8f26b10.jpg","comment_is_top":false,"comment_ctime":1535637645,"is_pvip":false,"replies":[{"id":"8109","content":"新的slice是指新的slice数据结构，和之前的不同，内存地址也不同。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535802470,"ip_address":"","comment_id":22380,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535637645","product_id":100013101,"comment_content":"不太明白append返回的都是新的slice、所谓新的只什么？新的内存地址对于的新对象？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423090,"discussion_content":"新的slice是指新的slice数据结构，和之前的不同，内存地址也不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535802470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22188,"user_name":"yfdream","can_delete":false,"product_type":"c1","uid":1161187,"ip_address":"","ucode":"48351861BDFEC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/e3/2cded5c9.jpg","comment_is_top":false,"comment_ctime":1535542188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535542188","product_id":100013101,"comment_content":"用数组为基础进行切片，会把原来数组当做底层数组吗？还是拷贝个新的当底层数组？","like_count":0},{"had_liked":false,"id":21991,"user_name":"王宏达达达","can_delete":false,"product_type":"c1","uid":1021829,"ip_address":"","ucode":"F6D2348EE216DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/85/219709fd.jpg","comment_is_top":false,"comment_ctime":1535430305,"is_pvip":false,"replies":[{"id":"7960","content":"《Go并发编程实战》第一版就可以。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1535515238,"ip_address":"","comment_id":21991,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535430305","product_id":100013101,"comment_content":"请问老师，golang入门的书籍是否有推荐？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422956,"discussion_content":"《Go并发编程实战》第一版就可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535515238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21800,"user_name":"Kyle Liu","can_delete":false,"product_type":"c1","uid":1109324,"ip_address":"","ucode":"21EBDE63DE30A0","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/4c/4f645bda.jpg","comment_is_top":false,"comment_ctime":1535343955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535343955","product_id":100013101,"comment_content":"老师厉害，以前的疑惑一下就明白了","like_count":0}]}