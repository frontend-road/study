{"id":181636,"title":"14 | SFINAE：不是错误的替换失败是怎么回事?","content":"<p>你好，我是吴咏炜。</p><p>我们已经连续讲了两讲模板和编译期编程了。今天我们还是继续这个话题，讲的内容是模板里的一个特殊概念——替换失败非错（substitution failure is not an error），英文简称为 SFINAE。</p><h2>函数模板的重载决议</h2><p>我们之前已经讨论了不少模板特化。我们今天来着重看一个函数模板的情况。当一个函数名称和某个函数模板名称匹配时，重载决议过程大致如下：</p><ul>\n<li>根据名称找出所有适用的函数和函数模板</li>\n<li>对于适用的函数模板，要根据实际情况对模板形参进行替换；替换过程中如果发生错误，这个模板会被丢弃</li>\n<li>在上面两步生成的可行函数集合中，编译器会寻找一个最佳匹配，产生对该函数的调用</li>\n<li>如果没有找到最佳匹配，或者找到多个匹配程度相当的函数，则编译器需要报错</li>\n</ul><p>我们还是来看一个具体的例子（改编自参考资料 <span class=\"orange\">[1]</span>）。虽然这例子不那么实用，但还是比较简单，能够初步说明一下。</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n\nstruct Test {\n  typedef int foo;\n};\n\ntemplate &lt;typename T&gt;\nvoid f(typename T::foo)\n{\n  puts(\"1\");\n}\n\ntemplate &lt;typename T&gt;\nvoid f(T)\n{\n  puts(\"2\");\n}\n\nint main()\n{\n  f&lt;Test&gt;(10);\n  f&lt;int&gt;(10);\n}\n</code></pre><!-- [[[read_end]]] --><p>输出为：</p><blockquote>\n<p><code>1</code><br>\n<code>2</code></p>\n</blockquote><p>我们来分析一下。首先看 <code>f&lt;Test&gt;(10);</code> 的情况：</p><ul>\n<li>我们有两个模板符合名字 <code>f</code></li>\n<li>替换结果为 <code>f(Test::foo)</code> 和 <code>f(Test)</code></li>\n<li>使用参数 <code>10</code> 去匹配，只有前者参数可以匹配，因而第一个模板被选择</li>\n</ul><p>再看一下 <code>f&lt;int&gt;(10)</code> 的情况：</p><ul>\n<li>还是两个模板符合名字 <code>f</code></li>\n<li>替换结果为 <code>f(int::foo)</code> 和 <code>f(int)</code>；显然前者不是个合法的类型，被抛弃</li>\n<li>使用参数 <code>10</code> 去匹配 <code>f(int)</code>，没有问题，那就使用这个模板实例了</li>\n</ul><p>在这儿，体现的是 SFINAE 设计的最初用法：如果模板实例化中发生了失败，没有理由编译就此出错终止，因为还是可能有其他可用的函数重载的。</p><p>这儿的失败仅指函数模板的原型声明，即参数和返回值。函数体内的失败不考虑在内。如果重载决议选择了某个函数模板，而函数体在实例化的过程中出错，那我们仍然会得到一个编译错误。</p><h2>编译期成员检测</h2><p>不过，很快人们就发现 SFINAE 可以用于其他用途。比如，根据某个实例化的成功或失败来在编译期检测类的特性。下面这个模板，就可以检测一个类是否有一个名叫 <code>reserve</code>、参数类型为 <code>size_t</code> 的成员函数：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nstruct has_reserve {\n  struct good { char dummy; };\n  struct bad { char dummy[2]; };\n  template &lt;class U,\n            void (U::*)(size_t)&gt;\n  struct SFINAE {};\n  template &lt;class U&gt;\n  static good\n  reserve(SFINAE&lt;U, &amp;U::reserve&gt;*);\n  template &lt;class U&gt;\n  static bad reserve(...);\n  static const bool value =\n    sizeof(reserve&lt;T&gt;(nullptr))\n    == sizeof(good);\n};\n</code></pre><p>在这个模板里：</p><ul>\n<li>我们首先定义了两个结构 <code>good</code> 和 <code>bad</code>；它们的内容不重要，我们只关心它们的大小必须不一样。</li>\n<li>然后我们定义了一个 <code>SFINAE</code> 模板，内容也同样不重要，但模板的第二个参数需要是第一个参数的成员函数指针，并且参数类型是 <code>size_t</code>，返回值是 <code>void</code>。</li>\n<li>随后，我们定义了一个要求 <code>SFINAE*</code> 类型的 <code>reserve</code> 成员函数模板，返回值是 <code>good</code>；再定义了一个对参数类型无要求的 <code>reserve</code> 成员函数模板（不熟悉 <code>...</code> 语法的，可以看参考资料 <span class=\"orange\">[2]</span>），返回值是 <code>bad</code>。</li>\n<li>最后，我们定义常整型布尔值 <code>value</code>，结果是 <code>true</code> 还是 <code>false</code>，取决于 <code>nullptr</code> 能不能和 <code>SFINAE*</code> 匹配成功，而这又取决于模板参数 <code>T</code> 有没有返回类型是 <code>void</code>、接受一个参数并且类型为 <code>size_t</code> 的成员函数 <code>reserve</code>。</li>\n</ul><p>那这样的模板有什么用处呢？我们继续往下看。</p><h2>SFINAE 模板技巧</h2><h3>enable_if</h3><p>C++11 开始，标准库里有了一个叫 <code>enable_if</code> 的模板（定义在 &lt;type_traits&gt; 里），可以用它来选择性地启用某个函数的重载。</p><p>假设我们有一个函数，用来往一个容器尾部追加元素。我们希望原型是这个样子的：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr,\n            size_t size);\n</code></pre><p>显然，<code>container</code> 有没有 <code>reserve</code> 成员函数，是对性能有影响的——如果有的话，我们通常应该预留好内存空间，以免产生不必要的对象移动甚至拷贝操作。利用 <code>enable_if</code> 和上面的 <code>has_reserve</code> 模板，我们就可以这么写：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nenable_if_t&lt;has_reserve&lt;C&gt;::value,\n            void&gt;\nappend(C&amp; container, T* ptr,\n       size_t size)\n{\n  container.reserve(\n    container.size() + size);\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n\ntemplate &lt;typename C, typename T&gt;\nenable_if_t&lt;!has_reserve&lt;C&gt;::value,\n            void&gt;\nappend(C&amp; container, T* ptr,\n       size_t size)\n{\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n</code></pre><p>要记得之前我说过，对于某个 type trait，添加 <code>_t</code> 的后缀等价于其 <code>type</code> 成员类型。因而，我们可以用 <code>enable_if_t</code> 来取到结果的类型。<code>enable_if_t&lt;has_reserve&lt;C&gt;::value, void&gt;</code> 的意思可以理解成：如果类型 <code>C</code> 有 <code>reserve</code> 成员的话，那我们启用下面的成员函数，它的返回类型为 <code>void</code>。</p><p><code>enable_if</code> 的定义（其实非常简单）和它的进一步说明，请查看参考资料 <span class=\"orange\">[3]</span>。参考资料里同时展示了一个通用技巧，可以用在构造函数（无返回值）或不想手写返回值类型的情况下。但那个写法更绕一些，不是必需要用的话，就采用上面那个写出返回值类型的写法吧。</p><h3>decltype 返回值</h3><p>如果只需要在某个操作有效的情况下启用某个函数，而不需要考虑相反的情况的话，有另外一个技巧可以用。对于上面的 <code>append</code> 的情况，如果我们想限制只有具有 <code>reserve</code> 成员函数的类可以使用这个重载，我们可以把代码简化成：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nauto append(C&amp; container, T* ptr,\n            size_t size)\n  -&gt; decltype(\n    declval&lt;C&amp;&gt;().reserve(1U),\n    void())\n{\n  container.reserve(\n    container.size() + size);\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n</code></pre><p>这是我们第一次用到 <code>declval</code> <span class=\"orange\">[4]</span>，需要简单介绍一下。这个模板用来声明一个某个类型的参数，但这个参数只是用来参加模板的匹配，不允许实际使用。使用这个模板，我们可以在某类型没有默认构造函数的情况下，假想出一个该类的对象来进行类型推导。<code>declval&lt;C&amp;&gt;().reserve(1U)</code> 用来测试 <code>C&amp;</code> 类型的对象是不是可以拿 <code>1U</code> 作为参数来调用 <code>reserve</code> 成员函数。此外，我们需要记得，C++ 里的逗号表达式的意思是按顺序逐个估值，并返回最后一项。所以，上面这个函数的返回值类型是 <code>void</code>。</p><p>这个方式和 <code>enable_if</code> 不同，很难表示否定的条件。如果要提供一个专门给<strong>没有</strong> <code>reserve</code> 成员函数的 <code>C</code> 类型的 <code>append</code> 重载，这种方式就不太方便了。因而，这种方式的主要用途是避免错误的重载。</p><h3>void_t</h3><p><code>void_t</code> 是 C++17 新引入的一个模板 <span class=\"orange\">[5]</span>。它的定义简单得令人吃惊：</p><pre><code class=\"language-c++\">template &lt;typename...&gt;\nusing void_t = void;\n</code></pre><p>换句话说，这个类型模板会把任意类型映射到 <code>void</code>。它的特殊性在于，在这个看似无聊的过程中，编译器会检查那个“任意类型”的有效性。利用 <code>decltype</code>、<code>declval</code> 和模板特化，我们可以把 <code>has_reserve</code> 的定义大大简化：</p><pre><code class=\"language-c++\">template &lt;typename T,\n          typename = void_t&lt;&gt;&gt;\nstruct has_reserve : false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_reserve&lt;\n  T, void_t&lt;decltype(\n       declval&lt;T&amp;&gt;().reserve(1U))&gt;&gt;\n  : true_type {};\n</code></pre><p>这里第二个 <code>has_reserve</code> 模板的定义实际上是一个偏特化 <span class=\"orange\">[6]</span>。偏特化是类模板的特有功能，跟函数重载有些相似。编译器会找出所有的可用模板，然后选择其中最“特别”的一个。像上面的例子，所有类型都能满足第一个模板，但不是所有的类型都能满足第二个模板，所以第二个更特别。当第二个模板能被满足时，编译器就会选择第二个特化的模板；而只有第二个模板不能被满足时，才会回到第一个模板的通用情况。</p><p>有了这个 <code>has_reserve</code> 模板，我们就可以继续使用其他的技巧，如 <code>enable_if</code> 和下面的标签分发，来对重载进行限制。</p><h3>标签分发</h3><p>在上一讲，我们提到了用 <code>true_type</code> 和 <code>false_type</code> 来选择合适的重载。这种技巧有个专门的名字，叫标签分发（tag dispatch）。我们的 <code>append</code> 也可以用标签分发来实现：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nvoid _append(C&amp; container, T* ptr,\n             size_t size,\n             true_type)\n{\n  container.reserve(\n    container.size() + size);\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n\ntemplate &lt;typename C, typename T&gt;\nvoid _append(C&amp; container, T* ptr,\n             size_t size,\n             false_type)\n{\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n\ntemplate &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr,\n            size_t size)\n{\n  _append(\n    container, ptr, size,\n    integral_constant&lt;\n      bool,\n      has_reserve&lt;C&gt;::value&gt;{});\n}\n</code></pre><p>回想起上一讲里 <code>true_type</code> 和 <code>false_type</code> 的定义，你应该很容易看出这个代码跟使用 <code>enable_if</code> 是等价的。当然，在这个例子，标签分发并没有使用 <code>enable_if</code> 显得方便。作为一种可以替代 <code>enable_if</code> 的通用惯用法，你还是需要了解一下。</p><p>另外，如果我们用 <code>void_t</code> 那个版本的 <code>has_reserve</code> 模板的话，由于模板的实例会继承 <code>false_type</code> 或 <code>true_type</code> 之一，代码可以进一步简化为：</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr,\n            size_t size)\n{\n  _append(\n    container, ptr, size,\n    has_reserve&lt;C&gt;{});\n}\n</code></pre><h3>静态多态的限制？</h3><p>看到这儿，你可能会怀疑，为什么我们不能像在 Python 之类的语言里一样，直接写下面这样的代码呢？</p><pre><code class=\"language-c++\">template &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr,\n            size_t size)\n{\n  if (has_reserve&lt;C&gt;::value) {\n    container.reserve(\n      container.size() + size);\n  }\n  for (size_t i = 0; i &lt; size;\n       ++i) {\n    container.push_back(ptr[i]);\n  }\n}\n</code></pre><p>如果你试验一下，就会发现，在 <code>C</code> 类型没有 <code>reserve</code> 成员函数的情况下，编译是不能通过的，会报错。这是因为 C++ 是静态类型的语言，所有的函数、名字必须在编译时被成功解析、确定。在动态类型的语言里，只要语法没问题，缺成员函数要执行到那一行上才会被发现。这赋予了动态类型语言相当大的灵活性；只不过，不能在编译时检查错误，同样也是很多人对动态类型语言的抱怨所在……</p><p>那在 C++ 里，我们有没有更好的办法呢？实际上是有的。具体方法，下回分解。</p><h2>内容小结</h2><p>今天我们介绍了 SFINAE 和它的一些主要惯用法。虽然随着 C++ 的演化，SFINAE 的重要性有降低的趋势，但我们仍需掌握其基本概念，才能理解使用了这一技巧的模板代码。</p><h2>课后思考</h2><p>这一讲的内容应该仍然是很烧脑的。请你务必试验一下文中的代码，加深对这些概念的理解。同样，有任何问题和想法，可以留言与我交流。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Substitution failure is not an error”. <a href=\"https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\">https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “Variadic functions”. <a href=\"https://en.cppreference.com/w/c/variadic\">https://en.cppreference.com/w/c/variadic</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “变参数函数”. <a href=\"https://zh.cppreference.com/w/c/variadic\">https://zh.cppreference.com/w/c/variadic</a> </span></p><p><span class=\"reference\">[3] cppreference.com, “std::enable_if”. <a href=\"https://en.cppreference.com/w/cpp/types/enable_if\">https://en.cppreference.com/w/cpp/types/enable_if</a> </span></p><p><span class=\"reference\">[3a] cppreference.com, “std::enable_if”. <a href=\"https://zh.cppreference.com/w/cpp/types/enable_if\">https://zh.cppreference.com/w/cpp/types/enable_if</a> </span></p><p><span class=\"reference\">[4] cppreference.com, “std::declval”. <a href=\"https://en.cppreference.com/w/cpp/utility/declval\">https://en.cppreference.com/w/cpp/utility/declval</a> </span></p><p><span class=\"reference\">[4a] cppreference.com, “std::declval”. <a href=\"https://zh.cppreference.com/w/cpp/utility/declval\">https://zh.cppreference.com/w/cpp/utility/declval</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “std::void_t”. <a href=\"https://en.cppreference.com/w/cpp/types/void_t\">https://en.cppreference.com/w/cpp/types/void_t</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “std::void_t”. <a href=\"https://zh.cppreference.com/w/cpp/types/void_t\">https://zh.cppreference.com/w/cpp/types/void_t</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “Partial template specialization”. <a href=\"https://en.cppreference.com/w/cpp/language/partial_specialization\">https://en.cppreference.com/w/cpp/language/partial_specialization</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “部分模板特化”. <a href=\"https://zh.cppreference.com/w/cpp/language/partial_specialization\">https://zh.cppreference.com/w/cpp/language/partial_specialization</a> </span></p>","neighbors":{"left":{"article_title":"13 | 编译期能做些什么？一个完整的计算世界","id":181608},"right":{"article_title":"15 | constexpr：一个常态的世界","id":182902}},"comments":[{"had_liked":false,"id":167109,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1577693193,"is_pvip":false,"replies":[{"id":64990,"content":"我喜欢这样的留言。哈哈，写专栏就是希望能给大家帮助的。😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577800738,"ip_address":"","comment_id":167109,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"emmmm....\n这一节内容如果是半年前看到，应该能节省我好多时间去写序列化，真是我实实在在的需求啊！\n我自己在写数据序列化为json文本的时候，就遇到了这样头疼的问题：如何根据类型，去调用对应的函数。\n如果是简单的int，bool，float，直接特化就好了。\n如果是自定义的结构体呢？我的做法就是判断自定义结构体中是否有serializable和deserializable函数，就用到了文中最开始的方法判断。\n然而那会儿我写得还是太简单粗暴，在代码中用的是if去判断，对于不支持的类型，直接报错，并不能做到忽略。\n看了本文之后，真是受益颇多啊！留言于此，告诉大家，别以为用不到这些内容，都是实实在在的干货！","like_count":37},{"had_liked":false,"id":166116,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1577406577,"is_pvip":false,"replies":[{"id":63322,"content":"新发现一个工具，可以展示实例化的过程。你可以去看一下：\n\nhttps:&#47;&#47;cppinsights.io&#47;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577407868,"ip_address":"","comment_id":166116,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问有编译器本身什么工具或者日志模式，可以显示模版实例化的过程？","like_count":16,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479404,"discussion_content":"新发现一个工具，可以展示实例化的过程。你可以去看一下：\n\nhttps://cppinsights.io/","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577407868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2105908,"avatar":"","nickname":"Geek_bc99a2","note":"","ucode":"B820CDFF4370D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547756,"discussion_content":"cppinsights对于复杂点的工程还是好多搞不定，cevelop也不太灵光，看起来还是templight强大些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642855016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204459,"user_name":"_呱太_","can_delete":false,"product_type":"c1","uid":1739226,"ip_address":"","ucode":"6B96DC7CF66094","user_header":"https://static001.geekbang.org/account/avatar/00/1a/89/da/e86b9932.jpg","comment_is_top":false,"comment_ctime":1586402731,"is_pvip":false,"replies":[{"id":76498,"content":"欢迎走上一个台阶。学习无止境……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586437263,"ip_address":"","comment_id":204459,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"刚更新的时候看得头晕目眩，发现基础不够。回头抽空撸完了 STL 标准库 和 effective modern C++，回过头来看豁然开朗，真实受益匪浅","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479404,"discussion_content":"新发现一个工具，可以展示实例化的过程。你可以去看一下：\n\nhttps://cppinsights.io/","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577407868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2105908,"avatar":"","nickname":"Geek_bc99a2","note":"","ucode":"B820CDFF4370D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547756,"discussion_content":"cppinsights对于复杂点的工程还是好多搞不定，cevelop也不太灵光，看起来还是templight强大些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642855016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172523,"user_name":"好好虚度时光","can_delete":false,"product_type":"c1","uid":1359941,"ip_address":"","ucode":"8079C01665C63F","user_header":"https://static001.geekbang.org/account/avatar/00/14/c0/45/069cd477.jpg","comment_is_top":false,"comment_ctime":1579218813,"is_pvip":false,"replies":[{"id":66931,"content":"这个网站也许可以帮你：\n\nhttps:&#47;&#47;cppinsights.io&#47;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579238415,"ip_address":"","comment_id":172523,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"表示真的太烧脑了","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481766,"discussion_content":"这个网站也许可以帮你：\n\nhttps://cppinsights.io/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579238415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289211,"discussion_content":"这个网址很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594027113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315987,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1634095655,"is_pvip":false,"replies":[{"id":114480,"content":"看看下面的例子，是不是可以了？\n\nintegral_constant&lt;int, 1&gt;::value == 1\nintegral_constant&lt;int, 2&gt;::value == 2\ntrue_type::value == integral_constant&lt;bool, true&gt;::value == true","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634101969,"ip_address":"","comment_id":315987,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"标签分发那里的：\ntemplate void append(C&amp; container, T* ptr, size_t size)\n{ _append( container, ptr, size, integral_constant&lt; bool, has_reserve&lt;C&gt;::value&gt;{});}\n这个integral_constant&lt; bool, has_reserve&lt;C&gt;::value&gt;{}看不明白\nintegral_constant是上一讲的\ntemplate &lt;class T, T v&gt;\nstruct integral_constant {\n  static const T value = v;\n  typedef T value_type;\n  typedef integral_constant type;\n};\n吧？\nhas_reserve&lt;C&gt;::value的::value是啥意思？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481766,"discussion_content":"这个网站也许可以帮你：\n\nhttps://cppinsights.io/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579238415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289211,"discussion_content":"这个网址很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594027113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217675,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1589580350,"is_pvip":false,"replies":[{"id":80556,"content":"在合适的地方使用，记住目标是简化最终代码就行。模板代码容易让人脑袋疼是事实，限制主要用在底层的支持代码里。上层的使用代码一定要简单为好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589640568,"ip_address":"","comment_id":217675,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看完了两课之后，正儿八经的想把各种 type_traits 用起来了。","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495215,"discussion_content":"在合适的地方使用，记住目标是简化最终代码就行。模板代码容易让人脑袋疼是事实，限制主要用在底层的支持代码里。上层的使用代码一定要简单为好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589640568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282313,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1615194216,"is_pvip":false,"replies":[{"id":102536,"content":"不是所有类型都能满足第二个模板。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615216550,"ip_address":"","comment_id":282313,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，\ntemplate &lt;typename T,\n          typename = void_t&lt;&gt;&gt;\nstruct has_reserve : false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_reserve&lt;\n  T, void_t&lt;decltype(\n       declval&lt;T&amp;&gt;().reserve(1U))&gt;&gt;\n  : true_type {};\n第二个是一个类特化，但我理解，第二个中void的模板参数的推导结果和第一个是一样的。那此处 更特殊 这个意思是体现在 void的模板参数推导过程（无错）吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495215,"discussion_content":"在合适的地方使用，记住目标是简化最终代码就行。模板代码容易让人脑袋疼是事实，限制主要用在底层的支持代码里。上层的使用代码一定要简单为好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589640568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353267,"user_name":"Simon","can_delete":false,"product_type":"c1","uid":1914504,"ip_address":"广东","ucode":"A8A2E3E57BD029","user_header":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","comment_is_top":false,"comment_ctime":1659323916,"is_pvip":false,"replies":[{"id":128553,"content":"等效于 typename = void。类型参数名不重要。这样，特化的版本和通用的版本，后一项都是 void，不用调用者提供。\n\n通用模板形式的第二个参数如果不是 void，那特化形式就永远不能匹配成功了，除非调用者手工提供第二项 void（第二项 void_t 的结果仍是 void）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1659539807,"ip_address":"广东","comment_id":353267,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"typename = void_t&lt;&gt; 这个写法是什么意思？类型名是不重要的？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582627,"discussion_content":"等效于 typename = void。类型参数名不重要。这样，特化的版本和通用的版本，后一项都是 void，不用调用者提供。\n\n通用模板形式的第二个参数如果不是 void，那特化形式就永远不能匹配成功了，除非调用者手工提供第二项 void（第二项 void_t 的结果仍是 void）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659539807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167026,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1577672603,"is_pvip":false,"replies":[{"id":64980,"content":"继承啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577791316,"ip_address":"","comment_id":167026,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"\ntemplate &lt;typename T,\n          typename = void_t&lt;&gt;&gt;\nstruct has_reserve : false_type {};\n这里的冒号是什么语法？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479719,"discussion_content":"继承啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577791316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1331396,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/c4/71d9745f.jpg","nickname":"飏","note":"","ucode":"48701F74729E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109327,"discussion_content":"这里是继承了false_type","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577684029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388372,"user_name":"。","can_delete":false,"product_type":"c1","uid":2270504,"ip_address":"北京","ucode":"90D4F0497629E0","user_header":"https://static001.geekbang.org/account/avatar/00/22/a5/28/125b172a.jpg","comment_is_top":false,"comment_ctime":1710056361,"is_pvip":false,"replies":[{"id":141510,"content":"看你关心什么了。我不关心&#47;要求 reserve 没有返回值。\n\n另外，不要使用 __void_t。这不是标准的一部分（是某些编译器私用的）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1710822855,"ip_address":"上海","comment_id":388372,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"用 void_t 实现的 has_reserve 函数有一些问题，它没法判断类型的reserve 方法的返回值是否是 void，所以可以修改一下：\n\ntemplate &lt;typename T, typename = void&gt;\nstruct has_reserve : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_reserve&lt;T, std::__void_t&lt;decltype(std::declval&lt;T&amp;&gt;().reserve(1U))&gt;&gt;\n    : std::is_void&lt;decltype(std::declval&lt;T&amp;&gt;().reserve(1U))&gt; {};","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479719,"discussion_content":"继承啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577791316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1331396,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/c4/71d9745f.jpg","nickname":"飏","note":"","ucode":"48701F74729E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109327,"discussion_content":"这里是继承了false_type","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577684029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167109,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1577693193,"is_pvip":false,"replies":[{"id":64990,"content":"我喜欢这样的留言。哈哈，写专栏就是希望能给大家帮助的。😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577800738,"ip_address":"","comment_id":167109,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"emmmm....\n这一节内容如果是半年前看到，应该能节省我好多时间去写序列化，真是我实实在在的需求啊！\n我自己在写数据序列化为json文本的时候，就遇到了这样头疼的问题：如何根据类型，去调用对应的函数。\n如果是简单的int，bool，float，直接特化就好了。\n如果是自定义的结构体呢？我的做法就是判断自定义结构体中是否有serializable和deserializable函数，就用到了文中最开始的方法判断。\n然而那会儿我写得还是太简单粗暴，在代码中用的是if去判断，对于不支持的类型，直接报错，并不能做到忽略。\n看了本文之后，真是受益颇多啊！留言于此，告诉大家，别以为用不到这些内容，都是实实在在的干货！","like_count":37,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479748,"discussion_content":"我喜欢这样的留言。哈哈，写专栏就是希望能给大家帮助的。😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577800738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166116,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1577406577,"is_pvip":false,"replies":[{"id":63322,"content":"新发现一个工具，可以展示实例化的过程。你可以去看一下：\n\nhttps:&#47;&#47;cppinsights.io&#47;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577407868,"ip_address":"","comment_id":166116,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问有编译器本身什么工具或者日志模式，可以显示模版实例化的过程？","like_count":16,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479748,"discussion_content":"我喜欢这样的留言。哈哈，写专栏就是希望能给大家帮助的。😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577800738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204459,"user_name":"_呱太_","can_delete":false,"product_type":"c1","uid":1739226,"ip_address":"","ucode":"6B96DC7CF66094","user_header":"https://static001.geekbang.org/account/avatar/00/1a/89/da/e86b9932.jpg","comment_is_top":false,"comment_ctime":1586402731,"is_pvip":false,"replies":[{"id":76498,"content":"欢迎走上一个台阶。学习无止境……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586437263,"ip_address":"","comment_id":204459,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"刚更新的时候看得头晕目眩，发现基础不够。回头抽空撸完了 STL 标准库 和 effective modern C++，回过头来看豁然开朗，真实受益匪浅","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491188,"discussion_content":"欢迎走上一个台阶。学习无止境……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586437263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172523,"user_name":"好好虚度时光","can_delete":false,"product_type":"c1","uid":1359941,"ip_address":"","ucode":"8079C01665C63F","user_header":"https://static001.geekbang.org/account/avatar/00/14/c0/45/069cd477.jpg","comment_is_top":false,"comment_ctime":1579218813,"is_pvip":false,"replies":[{"id":66931,"content":"这个网站也许可以帮你：\n\nhttps:&#47;&#47;cppinsights.io&#47;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579238415,"ip_address":"","comment_id":172523,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"表示真的太烧脑了","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491188,"discussion_content":"欢迎走上一个台阶。学习无止境……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586437263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315987,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1634095655,"is_pvip":false,"replies":[{"id":114480,"content":"看看下面的例子，是不是可以了？\n\nintegral_constant&lt;int, 1&gt;::value == 1\nintegral_constant&lt;int, 2&gt;::value == 2\ntrue_type::value == integral_constant&lt;bool, true&gt;::value == true","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634101969,"ip_address":"","comment_id":315987,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"标签分发那里的：\ntemplate void append(C&amp; container, T* ptr, size_t size)\n{ _append( container, ptr, size, integral_constant&lt; bool, has_reserve&lt;C&gt;::value&gt;{});}\n这个integral_constant&lt; bool, has_reserve&lt;C&gt;::value&gt;{}看不明白\nintegral_constant是上一讲的\ntemplate &lt;class T, T v&gt;\nstruct integral_constant {\n  static const T value = v;\n  typedef T value_type;\n  typedef integral_constant type;\n};\n吧？\nhas_reserve&lt;C&gt;::value的::value是啥意思？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528226,"discussion_content":"看看下面的例子，是不是可以了？\n\nintegral_constant&amp;lt;int, 1&amp;gt;::value == 1\nintegral_constant&amp;lt;int, 2&amp;gt;::value == 2\ntrue_type::value == integral_constant&amp;lt;bool, true&amp;gt;::value == true","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634101969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217675,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1589580350,"is_pvip":false,"replies":[{"id":80556,"content":"在合适的地方使用，记住目标是简化最终代码就行。模板代码容易让人脑袋疼是事实，限制主要用在底层的支持代码里。上层的使用代码一定要简单为好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589640568,"ip_address":"","comment_id":217675,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看完了两课之后，正儿八经的想把各种 type_traits 用起来了。","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528226,"discussion_content":"看看下面的例子，是不是可以了？\n\nintegral_constant&amp;lt;int, 1&amp;gt;::value == 1\nintegral_constant&amp;lt;int, 2&amp;gt;::value == 2\ntrue_type::value == integral_constant&amp;lt;bool, true&amp;gt;::value == true","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634101969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282313,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1615194216,"is_pvip":false,"replies":[{"id":102536,"content":"不是所有类型都能满足第二个模板。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615216550,"ip_address":"","comment_id":282313,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，\ntemplate &lt;typename T,\n          typename = void_t&lt;&gt;&gt;\nstruct has_reserve : false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_reserve&lt;\n  T, void_t&lt;decltype(\n       declval&lt;T&amp;&gt;().reserve(1U))&gt;&gt;\n  : true_type {};\n第二个是一个类特化，但我理解，第二个中void的模板参数的推导结果和第一个是一样的。那此处 更特殊 这个意思是体现在 void的模板参数推导过程（无错）吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516697,"discussion_content":"不是所有类型都能满足第二个模板。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615216550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353267,"user_name":"Simon","can_delete":false,"product_type":"c1","uid":1914504,"ip_address":"广东","ucode":"A8A2E3E57BD029","user_header":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","comment_is_top":false,"comment_ctime":1659323916,"is_pvip":false,"replies":[{"id":128553,"content":"等效于 typename = void。类型参数名不重要。这样，特化的版本和通用的版本，后一项都是 void，不用调用者提供。\n\n通用模板形式的第二个参数如果不是 void，那特化形式就永远不能匹配成功了，除非调用者手工提供第二项 void（第二项 void_t 的结果仍是 void）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1659539807,"ip_address":"广东","comment_id":353267,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"typename = void_t&lt;&gt; 这个写法是什么意思？类型名是不重要的？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516697,"discussion_content":"不是所有类型都能满足第二个模板。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615216550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167026,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1577672603,"is_pvip":false,"replies":[{"id":64980,"content":"继承啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577791316,"ip_address":"","comment_id":167026,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"\ntemplate &lt;typename T,\n          typename = void_t&lt;&gt;&gt;\nstruct has_reserve : false_type {};\n这里的冒号是什么语法？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582627,"discussion_content":"等效于 typename = void。类型参数名不重要。这样，特化的版本和通用的版本，后一项都是 void，不用调用者提供。\n\n通用模板形式的第二个参数如果不是 void，那特化形式就永远不能匹配成功了，除非调用者手工提供第二项 void（第二项 void_t 的结果仍是 void）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659539807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388372,"user_name":"。","can_delete":false,"product_type":"c1","uid":2270504,"ip_address":"北京","ucode":"90D4F0497629E0","user_header":"https://static001.geekbang.org/account/avatar/00/22/a5/28/125b172a.jpg","comment_is_top":false,"comment_ctime":1710056361,"is_pvip":false,"replies":[{"id":141510,"content":"看你关心什么了。我不关心&#47;要求 reserve 没有返回值。\n\n另外，不要使用 __void_t。这不是标准的一部分（是某些编译器私用的）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1710822855,"ip_address":"上海","comment_id":388372,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"用 void_t 实现的 has_reserve 函数有一些问题，它没法判断类型的reserve 方法的返回值是否是 void，所以可以修改一下：\n\ntemplate &lt;typename T, typename = void&gt;\nstruct has_reserve : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_reserve&lt;T, std::__void_t&lt;decltype(std::declval&lt;T&amp;&gt;().reserve(1U))&gt;&gt;\n    : std::is_void&lt;decltype(std::declval&lt;T&amp;&gt;().reserve(1U))&gt; {};","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639672,"discussion_content":"看你关心什么了。我不关心/要求 reserve 没有返回值。\n\n另外，不要使用 __void_t。这不是标准的一部分（是某些编译器私用的）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710822855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379041,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"北京","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1691202633,"is_pvip":false,"replies":[{"id":138155,"content":"当你写下 has_reserve&lt;vector&lt;int&gt;&gt;，编译器首先按照主模板的默认模板参数形式，补为 has_reserve&lt;vector&lt;int&gt;, void_t&lt;&gt;&gt;。void_t&lt;&gt; 只是 void 的另外一种写法（当时这么写是为了跟下面的特化看起来更对称）。\n\n如果 vector 没有 reserve 成员函数，那编译器会在尝试另一个偏特化时替换失败，这样就只有主模板可以用，得到 false_type 的子类。如果 vector 有 reserve 成员函数，那编译器尝试偏特化就会成功，完美匹配：替换成功，且隐式提供的第二个模板参数跟 void_t&lt;…&gt; 也能匹配。因此编译器使用了这第二个更特别的特化形式。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1691473486,"ip_address":"广东","comment_id":379041,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"void_t代码例子后边没有解释void_t的作用，或者没有typename=void_t&lt;&gt;这部分 为什么不行。\n另外typename=void_t&lt;&gt;这个是什么神仙语法？","like_count":0},{"had_liked":false,"id":376550,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"上海","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1686910476,"is_pvip":false,"replies":[{"id":137274,"content":"这是模拟真实的场景，用左值引用去调用函数。在目前的情况下不造成实际区别。\n\n一个成员函数是可以有左值引用&#47;右值引用版本的，也可以有const版本，还可以组合。尽量模拟实际调用的场景最不容易出问题。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1687010565,"ip_address":"广东","comment_id":376550,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"请问，为什么 ‘declval&lt;T&amp;&gt;().reserve(1U)’中为什么要使用T&amp;而不是T？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621268,"discussion_content":"这是模拟真实的场景，用左值引用去调用函数。在目前的情况下不造成实际区别。\n\n一个成员函数是可以有左值引用/右值引用版本的，也可以有const版本，还可以组合。尽量模拟实际调用的场景最不容易出问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687010566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","nickname":"yuchen","note":"","ucode":"D4B55B57D218CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621437,"discussion_content":"您好，老师。const成员函数版本和非const 成员函数版本我能理解，但左值引用版本和右值引用版本是什么意思呢？难道存在一些成员函数只能左值引用调用，而右值引用不能调用吗？可否举个例子呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687229926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1605025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","nickname":"yuchen","note":"","ucode":"D4B55B57D218CB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621619,"discussion_content":"是啊。有一种推荐的方式定义拷贝赋值运算符这么写：\n\nObj operator=(const Obj&amp;) &amp;\n{ ... }\n\n结尾的 &amp; 就表示 = 左侧必须是个左值（是的，大部分我们的类的右值对象是可以放等号左侧的😂）。\n\n请搜索 member functions with ref-qualifier。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1687352681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":621437,"ip_address":"广东","group_id":0},"score":621619,"extra":""}]}]},{"had_liked":false,"id":358603,"user_name":"Roblaboy","can_delete":false,"product_type":"c1","uid":2979544,"ip_address":"江苏","ucode":"801AB12DBE521B","user_header":"","comment_is_top":false,"comment_ctime":1664461717,"is_pvip":false,"replies":[{"id":130660,"content":"请给出详细的错误代码、编译命令行和错误信息。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1665379010,"ip_address":"江苏","comment_id":358603,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"我这边提示 enable_if_t 不是模板C&#47;C++(864) 是为什么，我这边用的是C++17","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621268,"discussion_content":"这是模拟真实的场景，用左值引用去调用函数。在目前的情况下不造成实际区别。\n\n一个成员函数是可以有左值引用/右值引用版本的，也可以有const版本，还可以组合。尽量模拟实际调用的场景最不容易出问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687010566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","nickname":"yuchen","note":"","ucode":"D4B55B57D218CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621437,"discussion_content":"您好，老师。const成员函数版本和非const 成员函数版本我能理解，但左值引用版本和右值引用版本是什么意思呢？难道存在一些成员函数只能左值引用调用，而右值引用不能调用吗？可否举个例子呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687229926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1605025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","nickname":"yuchen","note":"","ucode":"D4B55B57D218CB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621619,"discussion_content":"是啊。有一种推荐的方式定义拷贝赋值运算符这么写：\n\nObj operator=(const Obj&amp;) &amp;\n{ ... }\n\n结尾的 &amp; 就表示 = 左侧必须是个左值（是的，大部分我们的类的右值对象是可以放等号左侧的😂）。\n\n请搜索 member functions with ref-qualifier。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1687352681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":621437,"ip_address":"广东","group_id":0},"score":621619,"extra":""}]}]},{"had_liked":false,"id":358499,"user_name":"Geek_fa7226","can_delete":false,"product_type":"c1","uid":3184848,"ip_address":"江苏","ucode":"B7780A449FAC27","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK418DKQ4eFh00D6vwqE7nJEX1Ou9DWDHKV2Zj21lq00qK6RzpY6SP3ic0I1hMnbvxQBQSCzzOomNg/132","comment_is_top":false,"comment_ctime":1664364470,"is_pvip":false,"replies":[{"id":130659,"content":"后置返回值声明。此处主要是利用原型的 SFINAE（函数体中的内容不参与SFINAE，失败了会真编译失败，而不是跳过当前函数）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1665378971,"ip_address":"江苏","comment_id":358499,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"auto append(C&amp; container, T* ptr, size_t size) -&gt; decltype（...）中的-&gt;是什么语法？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589873,"discussion_content":"后置返回值声明。此处主要是利用原型的 SFINAE（函数体中的内容不参与SFINAE，失败了会真编译失败，而不是跳过当前函数）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665378972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350062,"user_name":"Geek_fd78c0","can_delete":false,"product_type":"c1","uid":1126540,"ip_address":"","ucode":"8C95427F348352","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/JWoFanyWDk7lWL7g8rLYI0icH1XOVoCyjR9HoMzliauxggPSWWeYVleqKwiaUnBEChfIctoFzVoBqqVT3Lot18Srg/132","comment_is_top":false,"comment_ctime":1656551924,"is_pvip":false,"replies":[{"id":127428,"content":"参见 https:&#47;&#47;zh.cppreference.com&#47;w&#47;cpp&#47;language&#47;function\n\n「尾随返回类型\t-\t(C++11 起) 尾随返回类型，当返回类型取决于实参名时，例如 template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);，或当返回类型复杂时，例如在 auto fpif(int)-&gt;int(*)(int) 中，尾随返回类型很有用」","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1656814809,"ip_address":"","comment_id":350062,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"\n\n请问老师这个-&gt;是什么意思，不太懂这个语法？\ntemplate &lt;typename C, typename T&gt;\nauto append(C&amp; container, T* ptr,\n            size_t size)\n  -&gt; decltype(\n    declval&lt;C&amp;&gt;().reserve(1U),\n    void())\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589873,"discussion_content":"后置返回值声明。此处主要是利用原型的 SFINAE（函数体中的内容不参与SFINAE，失败了会真编译失败，而不是跳过当前函数）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665378972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325598,"user_name":"Geek_7ce030","can_delete":false,"product_type":"c1","uid":2848838,"ip_address":"","ucode":"EFABCA83ECE8E6","user_header":"","comment_is_top":false,"comment_ctime":1639035722,"is_pvip":false,"replies":[{"id":118174,"content":"没人严肃地提出这样的提案。你的想法中的复杂性恐怕你也没有认真考虑。今天就更没有意义了——因为我们可以用C++的传统方式写编译期计算的代码。继续往下看constexpr。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1639132007,"ip_address":"","comment_id":325598,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"模板本身图灵完备但是语法极其晦涩丑陋，既然如此，为何不用Python语法代替现有模板语法，本质上是暴露编译期接口，当前用模板暴露，也可以用正常的语言暴露，让用户更轻松地控制编译过程。可能是积重难返吧。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578480,"discussion_content":"参见 https://zh.cppreference.com/w/cpp/language/function\n\n「尾随返回类型\t-\t(C++11 起) 尾随返回类型，当返回类型取决于实参名时，例如 template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);，或当返回类型复杂时，例如在 auto fpif(int)-&gt;int(*)(int) 中，尾随返回类型很有用」","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656814809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317262,"user_name":"ano","can_delete":false,"product_type":"c1","uid":1783342,"ip_address":"","ucode":"7DE64BDFA78550","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","comment_is_top":false,"comment_ctime":1634725898,"is_pvip":false,"replies":[{"id":115162,"content":"函数中的普通代码总会被编译，哪怕这个条件执行不到。\n\n同时参考下一讲的内容。😎","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634909419,"ip_address":"","comment_id":317262,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我有个疑问，关于这一句\n静态多态的限制？\n“在 C 类型没有 reserve 成员函数的情况下，编译是不能通过的，会报错。这是因为 C++ 是静态类型的语言，所有的函数、名字必须在编译时被成功解析、确定”\nif (has_reserve&lt;C&gt;::value)\n\n我的理解是，在编译时，if 语句中的 has_reserve 进行模板匹配，决议，发现那个特化的 true_type has_reserve, 产生 substitution failure, 然后就会回到那个 false_type 的 has_reserve, 最终实例化成 false_type 的 has_reserve，然后 value 是 false, 所以这个 if 语句中始终为 false，但是不应该会编译错误呀。\n不知道我哪里理解的不对？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537661,"discussion_content":"没人严肃地提出这样的提案。你的想法中的复杂性恐怕你也没有认真考虑。今天就更没有意义了——因为我们可以用C++的传统方式写编译期计算的代码。继续往下看constexpr。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639132008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1370959,"avatar":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","nickname":"猪小擎","note":"","ucode":"D9552746AE3327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584888,"discussion_content":"建议多看看cppcon，整个机器机体系都是建立在c，cpp之上，设计错误都只能继续保留那个错误，无法修改，你的修改让一些老项目无法编译，那是不能接受的，还能改语法？当是java或者go呢？c，cpp的历史包袱难以想象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661183472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296425,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1622968778,"is_pvip":false,"replies":[{"id":107755,"content":"又测了一遍，用下面的语句可以输出 1，应该没问题：\n\ncout &lt;&lt; has_reserve&lt;vector&lt;int&gt;&gt;::value;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623114898,"ip_address":"","comment_id":296425,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"\ntemplate &lt;typename T&gt;\nstruct has_reserve {\n  struct good { char dummy; };\n  struct bad { char dummy[2]; };\n  template &lt;class U,\n            void (U::*)(size_t)&gt;\n  struct SFINAE {};\n  template &lt;class U&gt;\n  static good\n  reserve(SFINAE&lt;U, &amp;U::reserve&gt;*);\n  template &lt;class U&gt;\n  static bad reserve(...);\n  static const bool value =\n    sizeof(reserve&lt;T&gt;(nullptr))\n    == sizeof(good);\n};\n\n这个貌似对标准库的vector无效？因为参数类型不匹配？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528740,"discussion_content":"函数中的普通代码总会被编译，哪怕这个条件执行不到。\n\n同时参考下一讲的内容。😎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634909419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289900,"user_name":"乐意至极","can_delete":false,"product_type":"c1","uid":2340308,"ip_address":"","ucode":"7AC6778D854482","user_header":"https://static001.geekbang.org/account/avatar/00/23/b5/d4/147abdaa.jpg","comment_is_top":false,"comment_ctime":1619256713,"is_pvip":false,"replies":[{"id":105164,"content":"哦，原因实际很简单，外面（包括 has_reserve）访问不到 GoodClass::reserve——你没有标 public。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1619342741,"ip_address":"","comment_id":289900,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"class GoodClass {\n    void reserve(size_t x);\n};\n\nclass BadClass {\n};\n\n    std::cout &lt;&lt; has_reserve&lt;BadClass&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; has_reserve&lt;GoodClass&gt;::value &lt;&lt; std::endl;\n\n\ntemplate &lt;typename T&gt;\nstruct has_reserve {\n  struct good { char dummy; };\n  struct bad { char dummy[2]; };\n  template &lt;class U,\n            void (U::*)(size_t)&gt;\n  struct SFINAE {};\n  template &lt;class U&gt;\n  static good\n  reserve(SFINAE&lt;U, &amp;U::reserve&gt;*);\n  template &lt;class U&gt;\n  static bad reserve(...);\n  static const bool value =\n    sizeof(reserve&lt;T&gt;(nullptr))\n    == sizeof(good);\n};\n\n老师，请问has_reserve该怎么用呢？两者输出都是0啊","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521437,"discussion_content":"又测了一遍，用下面的语句可以输出 1，应该没问题：\n\ncout &amp;lt;&amp;lt; has_reserve&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;::value;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623114898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2596026,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","nickname":"chang","note":"","ucode":"594EF8CB4477BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378295,"discussion_content":"另外还有个疑问：为什么 static good\n  reserve(SFINAE<U, &amp;U::reserve>*);  不定义函数体也行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623152783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2596026,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","nickname":"chang","note":"","ucode":"594EF8CB4477BD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378338,"discussion_content":"因为没人调用它们。我只利用了它们的原型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623165465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378295,"ip_address":"","group_id":0},"score":378338,"extra":""}]},{"author":{"id":2596026,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","nickname":"chang","note":"","ucode":"594EF8CB4477BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378294,"discussion_content":"惭愧，自己把static good\n  reserve(SFINAE<U, &amp;U::reserve>*); 中的&amp;U误写成*U了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623152664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230484,"user_name":"AlphaCat","can_delete":false,"product_type":"c1","uid":1059159,"ip_address":"","ucode":"69538BE935B32C","user_header":"https://static001.geekbang.org/account/avatar/00/10/29/57/aaa8612e.jpg","comment_is_top":false,"comment_ctime":1593398755,"is_pvip":false,"replies":[{"id":85132,"content":"嗯，谢谢。已经联系编辑。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1593437875,"ip_address":"","comment_id":230484,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，替换失败非错（substituion failure is not an error）， &quot;substituion&quot; 掉了一个 t，应该是 Substitution ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519049,"discussion_content":"哦，原因实际很简单，外面（包括 has_reserve）访问不到 GoodClass::reserve——你没有标 public。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619342741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2340308,"avatar":"https://static001.geekbang.org/account/avatar/00/23/b5/d4/147abdaa.jpg","nickname":"乐意至极","note":"","ucode":"7AC6778D854482","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370243,"discussion_content":"。。。学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619343474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379041,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"北京","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1691202633,"is_pvip":false,"replies":[{"id":138155,"content":"当你写下 has_reserve&lt;vector&lt;int&gt;&gt;，编译器首先按照主模板的默认模板参数形式，补为 has_reserve&lt;vector&lt;int&gt;, void_t&lt;&gt;&gt;。void_t&lt;&gt; 只是 void 的另外一种写法（当时这么写是为了跟下面的特化看起来更对称）。\n\n如果 vector 没有 reserve 成员函数，那编译器会在尝试另一个偏特化时替换失败，这样就只有主模板可以用，得到 false_type 的子类。如果 vector 有 reserve 成员函数，那编译器尝试偏特化就会成功，完美匹配：替换成功，且隐式提供的第二个模板参数跟 void_t&lt;…&gt; 也能匹配。因此编译器使用了这第二个更特别的特化形式。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1691473486,"ip_address":"广东","comment_id":379041,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"void_t代码例子后边没有解释void_t的作用，或者没有typename=void_t&lt;&gt;这部分 为什么不行。\n另外typename=void_t&lt;&gt;这个是什么神仙语法？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625231,"discussion_content":"当你写下 has_reserve&lt;vector&lt;int&gt;&gt;，编译器首先按照主模板的默认模板参数形式，补为 has_reserve&lt;vector&lt;int&gt;, void_t&lt;&gt;&gt;。void_t&lt;&gt; 只是 void 的另外一种写法（当时这么写是为了跟下面的特化看起来更对称）。\n\n如果 vector 没有 reserve 成员函数，那编译器会在尝试另一个偏特化时替换失败，这样就只有主模板可以用，得到 false_type 的子类。如果 vector 有 reserve 成员函数，那编译器尝试偏特化就会成功，完美匹配：替换成功，且隐式提供的第二个模板参数跟 void_t&lt;…&gt; 也能匹配。因此编译器使用了这第二个更特别的特化形式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691473486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1242483,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","nickname":"！null","note":"","ucode":"4E5B7922980397","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":625253,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691489293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":625231,"ip_address":"北京","group_id":0},"score":625253,"extra":""}]}]},{"had_liked":false,"id":376550,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"上海","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1686910476,"is_pvip":false,"replies":[{"id":137274,"content":"这是模拟真实的场景，用左值引用去调用函数。在目前的情况下不造成实际区别。\n\n一个成员函数是可以有左值引用&#47;右值引用版本的，也可以有const版本，还可以组合。尽量模拟实际调用的场景最不容易出问题。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1687010565,"ip_address":"广东","comment_id":376550,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"请问，为什么 ‘declval&lt;T&amp;&gt;().reserve(1U)’中为什么要使用T&amp;而不是T？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625231,"discussion_content":"当你写下 has_reserve&lt;vector&lt;int&gt;&gt;，编译器首先按照主模板的默认模板参数形式，补为 has_reserve&lt;vector&lt;int&gt;, void_t&lt;&gt;&gt;。void_t&lt;&gt; 只是 void 的另外一种写法（当时这么写是为了跟下面的特化看起来更对称）。\n\n如果 vector 没有 reserve 成员函数，那编译器会在尝试另一个偏特化时替换失败，这样就只有主模板可以用，得到 false_type 的子类。如果 vector 有 reserve 成员函数，那编译器尝试偏特化就会成功，完美匹配：替换成功，且隐式提供的第二个模板参数跟 void_t&lt;…&gt; 也能匹配。因此编译器使用了这第二个更特别的特化形式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691473486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1242483,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","nickname":"！null","note":"","ucode":"4E5B7922980397","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":625253,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691489293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":625231,"ip_address":"北京","group_id":0},"score":625253,"extra":""}]}]},{"had_liked":false,"id":358603,"user_name":"Roblaboy","can_delete":false,"product_type":"c1","uid":2979544,"ip_address":"江苏","ucode":"801AB12DBE521B","user_header":"","comment_is_top":false,"comment_ctime":1664461717,"is_pvip":false,"replies":[{"id":130660,"content":"请给出详细的错误代码、编译命令行和错误信息。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1665379010,"ip_address":"江苏","comment_id":358603,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"我这边提示 enable_if_t 不是模板C&#47;C++(864) 是为什么，我这边用的是C++17","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589874,"discussion_content":"请给出详细的错误代码、编译命令行和错误信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665379010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358499,"user_name":"Geek_fa7226","can_delete":false,"product_type":"c1","uid":3184848,"ip_address":"江苏","ucode":"B7780A449FAC27","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK418DKQ4eFh00D6vwqE7nJEX1Ou9DWDHKV2Zj21lq00qK6RzpY6SP3ic0I1hMnbvxQBQSCzzOomNg/132","comment_is_top":false,"comment_ctime":1664364470,"is_pvip":false,"replies":[{"id":130659,"content":"后置返回值声明。此处主要是利用原型的 SFINAE（函数体中的内容不参与SFINAE，失败了会真编译失败，而不是跳过当前函数）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1665378971,"ip_address":"江苏","comment_id":358499,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"auto append(C&amp; container, T* ptr, size_t size) -&gt; decltype（...）中的-&gt;是什么语法？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589874,"discussion_content":"请给出详细的错误代码、编译命令行和错误信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665379010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350062,"user_name":"Geek_fd78c0","can_delete":false,"product_type":"c1","uid":1126540,"ip_address":"","ucode":"8C95427F348352","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/JWoFanyWDk7lWL7g8rLYI0icH1XOVoCyjR9HoMzliauxggPSWWeYVleqKwiaUnBEChfIctoFzVoBqqVT3Lot18Srg/132","comment_is_top":false,"comment_ctime":1656551924,"is_pvip":false,"replies":[{"id":127428,"content":"参见 https:&#47;&#47;zh.cppreference.com&#47;w&#47;cpp&#47;language&#47;function\n\n「尾随返回类型\t-\t(C++11 起) 尾随返回类型，当返回类型取决于实参名时，例如 template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);，或当返回类型复杂时，例如在 auto fpif(int)-&gt;int(*)(int) 中，尾随返回类型很有用」","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1656814809,"ip_address":"","comment_id":350062,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"\n\n请问老师这个-&gt;是什么意思，不太懂这个语法？\ntemplate &lt;typename C, typename T&gt;\nauto append(C&amp; container, T* ptr,\n            size_t size)\n  -&gt; decltype(\n    declval&lt;C&amp;&gt;().reserve(1U),\n    void())\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578480,"discussion_content":"参见 https://zh.cppreference.com/w/cpp/language/function\n\n「尾随返回类型\t-\t(C++11 起) 尾随返回类型，当返回类型取决于实参名时，例如 template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);，或当返回类型复杂时，例如在 auto fpif(int)-&gt;int(*)(int) 中，尾随返回类型很有用」","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656814809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325598,"user_name":"Geek_7ce030","can_delete":false,"product_type":"c1","uid":2848838,"ip_address":"","ucode":"EFABCA83ECE8E6","user_header":"","comment_is_top":false,"comment_ctime":1639035722,"is_pvip":false,"replies":[{"id":118174,"content":"没人严肃地提出这样的提案。你的想法中的复杂性恐怕你也没有认真考虑。今天就更没有意义了——因为我们可以用C++的传统方式写编译期计算的代码。继续往下看constexpr。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1639132007,"ip_address":"","comment_id":325598,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"模板本身图灵完备但是语法极其晦涩丑陋，既然如此，为何不用Python语法代替现有模板语法，本质上是暴露编译期接口，当前用模板暴露，也可以用正常的语言暴露，让用户更轻松地控制编译过程。可能是积重难返吧。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537661,"discussion_content":"没人严肃地提出这样的提案。你的想法中的复杂性恐怕你也没有认真考虑。今天就更没有意义了——因为我们可以用C++的传统方式写编译期计算的代码。继续往下看constexpr。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639132008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1370959,"avatar":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","nickname":"猪小擎","note":"","ucode":"D9552746AE3327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584888,"discussion_content":"建议多看看cppcon，整个机器机体系都是建立在c，cpp之上，设计错误都只能继续保留那个错误，无法修改，你的修改让一些老项目无法编译，那是不能接受的，还能改语法？当是java或者go呢？c，cpp的历史包袱难以想象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661183472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317262,"user_name":"ano","can_delete":false,"product_type":"c1","uid":1783342,"ip_address":"","ucode":"7DE64BDFA78550","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","comment_is_top":false,"comment_ctime":1634725898,"is_pvip":false,"replies":[{"id":115162,"content":"函数中的普通代码总会被编译，哪怕这个条件执行不到。\n\n同时参考下一讲的内容。😎","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634909419,"ip_address":"","comment_id":317262,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我有个疑问，关于这一句\n静态多态的限制？\n“在 C 类型没有 reserve 成员函数的情况下，编译是不能通过的，会报错。这是因为 C++ 是静态类型的语言，所有的函数、名字必须在编译时被成功解析、确定”\nif (has_reserve&lt;C&gt;::value)\n\n我的理解是，在编译时，if 语句中的 has_reserve 进行模板匹配，决议，发现那个特化的 true_type has_reserve, 产生 substitution failure, 然后就会回到那个 false_type 的 has_reserve, 最终实例化成 false_type 的 has_reserve，然后 value 是 false, 所以这个 if 语句中始终为 false，但是不应该会编译错误呀。\n不知道我哪里理解的不对？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528740,"discussion_content":"函数中的普通代码总会被编译，哪怕这个条件执行不到。\n\n同时参考下一讲的内容。😎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634909419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296425,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1622968778,"is_pvip":false,"replies":[{"id":107755,"content":"又测了一遍，用下面的语句可以输出 1，应该没问题：\n\ncout &lt;&lt; has_reserve&lt;vector&lt;int&gt;&gt;::value;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623114898,"ip_address":"","comment_id":296425,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"\ntemplate &lt;typename T&gt;\nstruct has_reserve {\n  struct good { char dummy; };\n  struct bad { char dummy[2]; };\n  template &lt;class U,\n            void (U::*)(size_t)&gt;\n  struct SFINAE {};\n  template &lt;class U&gt;\n  static good\n  reserve(SFINAE&lt;U, &amp;U::reserve&gt;*);\n  template &lt;class U&gt;\n  static bad reserve(...);\n  static const bool value =\n    sizeof(reserve&lt;T&gt;(nullptr))\n    == sizeof(good);\n};\n\n这个貌似对标准库的vector无效？因为参数类型不匹配？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521437,"discussion_content":"又测了一遍，用下面的语句可以输出 1，应该没问题：\n\ncout &amp;lt;&amp;lt; has_reserve&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;::value;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623114898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2596026,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","nickname":"chang","note":"","ucode":"594EF8CB4477BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378295,"discussion_content":"另外还有个疑问：为什么 static good\n  reserve(SFINAE<U, &amp;U::reserve>*);  不定义函数体也行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623152783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2596026,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","nickname":"chang","note":"","ucode":"594EF8CB4477BD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378338,"discussion_content":"因为没人调用它们。我只利用了它们的原型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623165465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378295,"ip_address":"","group_id":0},"score":378338,"extra":""}]},{"author":{"id":2596026,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","nickname":"chang","note":"","ucode":"594EF8CB4477BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378294,"discussion_content":"惭愧，自己把static good\n  reserve(SFINAE<U, &amp;U::reserve>*); 中的&amp;U误写成*U了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623152664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289900,"user_name":"乐意至极","can_delete":false,"product_type":"c1","uid":2340308,"ip_address":"","ucode":"7AC6778D854482","user_header":"https://static001.geekbang.org/account/avatar/00/23/b5/d4/147abdaa.jpg","comment_is_top":false,"comment_ctime":1619256713,"is_pvip":false,"replies":[{"id":105164,"content":"哦，原因实际很简单，外面（包括 has_reserve）访问不到 GoodClass::reserve——你没有标 public。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1619342741,"ip_address":"","comment_id":289900,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"class GoodClass {\n    void reserve(size_t x);\n};\n\nclass BadClass {\n};\n\n    std::cout &lt;&lt; has_reserve&lt;BadClass&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; has_reserve&lt;GoodClass&gt;::value &lt;&lt; std::endl;\n\n\ntemplate &lt;typename T&gt;\nstruct has_reserve {\n  struct good { char dummy; };\n  struct bad { char dummy[2]; };\n  template &lt;class U,\n            void (U::*)(size_t)&gt;\n  struct SFINAE {};\n  template &lt;class U&gt;\n  static good\n  reserve(SFINAE&lt;U, &amp;U::reserve&gt;*);\n  template &lt;class U&gt;\n  static bad reserve(...);\n  static const bool value =\n    sizeof(reserve&lt;T&gt;(nullptr))\n    == sizeof(good);\n};\n\n老师，请问has_reserve该怎么用呢？两者输出都是0啊","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519049,"discussion_content":"哦，原因实际很简单，外面（包括 has_reserve）访问不到 GoodClass::reserve——你没有标 public。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619342741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2340308,"avatar":"https://static001.geekbang.org/account/avatar/00/23/b5/d4/147abdaa.jpg","nickname":"乐意至极","note":"","ucode":"7AC6778D854482","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370243,"discussion_content":"。。。学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619343474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230484,"user_name":"AlphaCat","can_delete":false,"product_type":"c1","uid":1059159,"ip_address":"","ucode":"69538BE935B32C","user_header":"https://static001.geekbang.org/account/avatar/00/10/29/57/aaa8612e.jpg","comment_is_top":false,"comment_ctime":1593398755,"is_pvip":false,"replies":[{"id":85132,"content":"嗯，谢谢。已经联系编辑。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1593437875,"ip_address":"","comment_id":230484,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，替换失败非错（substituion failure is not an error）， &quot;substituion&quot; 掉了一个 t，应该是 Substitution ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499909,"discussion_content":"嗯，谢谢。已经联系编辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593437875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217900,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1589641192,"is_pvip":false,"replies":[{"id":80760,"content":"看起来你对模板推导有点误解，第二个式子完全没有用处。你没有在任何地方提供第二个参数。\n\n如果 get 会导致模板推导失败的话，那这个例子里就可以使用类似于课中 void_t 的方法了。不过，对不存在的成员进行 get 虽然会产生编译失败，这个失败不是推导失败，而是静态断言。因而 void_t 也解决不了问题。\n\n至于你说的逗号表达式，我看不出解决了什么问题。我试验下来也没看到非 1 的结果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589806442,"ip_address":"","comment_id":217900,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"利用 variant 的 std::get 方法，写一个 sfine 用于判断一个 variant 类型里是否联合了 float. 代码和问题如下：\ntemplate &lt;typename T, typename ...&gt;\nstruct CheckVariant {\n    static constexpr int value =  1;\n};\ntemplate &lt;typename T&gt;\nstruct CheckVariant&lt;T,\n    decltype(get&lt;float&gt;( declval&lt;T&gt;() ))\n    &gt;\n{\n    static constexpr int value = 2;\n};\n...\n    if constexpr (CheckVariant&lt;decltype(v)&gt;::value == 1) {\n        cout &lt;&lt; get&lt;float&gt;(v) &lt;&lt; endl;\n    }\n...\n\n可是发现这样的 SFINAE 不起作用，把模板特化代码改为利用 逗号表达式，让 decltype 取值就可以了：\n\ntemplate &lt;typename T&gt;\nstruct CheckVariant&lt;T,\n    decltype((get&lt;float&gt;( declval&lt;T&gt;() ), void()))\n    &gt;\n{\n    static constexpr int value = 2;\n};\n\n这是为什么呢？  \n","like_count":0},{"had_liked":false,"id":178964,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1581864279,"is_pvip":false,"replies":[{"id":69503,"content":"我觉得应该这么理解：\n\n你给出的表达式是\n\ntypename std::enable_if&lt;std::is_same&lt;T, int&gt;::value&gt;::type\n\n估值后得到\n\ntypename std::enable_if&lt;true&gt;::type\n\n实例化时，编译器看到没有提供第二个参数，加上缺省参数按 std::enable_if&lt;true, void&gt; 实例化，再偏特化得到\n\ntemplate&lt;&gt;\nstruct enable_if&lt;true, void&gt;\n{\n  typedef void type;\n};\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581918448,"ip_address":"","comment_id":178964,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"https:&#47;&#47;en.cppreference.com&#47;w&#47;cpp&#47;types&#47;enable_if\n&quot;\nPossible implementation\ntemplate&lt;bool B, class T = void&gt;\nstruct enable_if {};\n \ntemplate&lt;class T&gt;\nstruct enable_if&lt;true, T&gt; { typedef T type; };\n&quot;\n\n下列的测试代码可以编译，运行\n&quot;\n#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename X, typename T, typename Y&gt;\ntypename std::enable_if&lt;std::is_same&lt;T, int&gt;::value&gt;::type update(X x, T t, Y y)\n{\n    std::cout &lt;&lt; &quot;int&quot; &lt;&lt; std::endl;\n}\n\nint main () {\n    float a = 1.4;\n    int b = 1;\n    double c =2.2;\n    update(a, b, c);\n}\n&quot;\n\n其中我用的是std::enable_if&lt;std::is_same&lt;T, int&gt;::value&gt;， 并没有提供参数来推导T，\n这是不是意味着对于true这种情况的偏特化implementation是\ntemplate&lt;class T = void&gt;\nstruct enable_if&lt;true, T&gt; { typedef T type; };\n\n而不是\n\ntemplate&lt;class T&gt;\nstruct enable_if&lt;true, T&gt; { typedef T type; };\n\n谢谢！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484040,"discussion_content":"我觉得应该这么理解：\n\n你给出的表达式是\n\ntypename std::enable_if&amp;lt;std::is_same&amp;lt;T, int&amp;gt;::value&amp;gt;::type\n\n估值后得到\n\ntypename std::enable_if&amp;lt;true&amp;gt;::type\n\n实例化时，编译器看到没有提供第二个参数，加上缺省参数按 std::enable_if&amp;lt;true, void&amp;gt; 实例化，再偏特化得到\n\ntemplate&amp;lt;&amp;gt;\nstruct enable_if&amp;lt;true, void&amp;gt;\n{\n  typedef void type;\n};\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581918448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175245,"discussion_content":"有意思。\n我原以为实例化的过程，只会选择一个模版进行。\n这个实例化的过程，\n\n先是用了第一个模版，\ntemplate<bool B, class T = void>\nstruct enable_if {};\n \n\n然后再用了第二个偏特化的模版。\ntemplate<class T>\nstruct enable_if<true, T> { typedef T type; };\n\n多谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581952468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178429,"user_name":"贾陆华","can_delete":false,"product_type":"c1","uid":1321408,"ip_address":"","ucode":"2722C422077EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","comment_is_top":false,"comment_ctime":1581688048,"is_pvip":false,"replies":[{"id":69240,"content":"模板绝对是 C++ 的一大特点。虽说有些技巧会过时（SFINAE 到 C++20 也会变得有点过时；看完全部你就知道了），但模板和静态鸭子类型这样的用法在目前的其他主流语言里是没有的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581733086,"ip_address":"","comment_id":178429,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"吴老师，写的满满干货，之前模板并没有深入学习，才知道模板可以这么花，用途可以这么多","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483817,"discussion_content":"模板绝对是 C++ 的一大特点。虽说有些技巧会过时（SFINAE 到 C++20 也会变得有点过时；看完全部你就知道了），但模板和静态鸭子类型这样的用法在目前的其他主流语言里是没有的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581733086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169492,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1578365325,"is_pvip":false,"replies":[{"id":65782,"content":"你的问题不那么清楚啊。\n\nU::* 不是完整类型，void (U::*)() 才是一个类型。U::foo 是一个具体的函数，&amp;U::foo 是函数指针。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578391640,"ip_address":"","comment_id":169492,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"假设U是一个Class,内部有foo方法与bar方法，那么U::*表示的是所有成员函数的指针吧，而U::foo*是foo成员函数指针，还请老师指点。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480581,"discussion_content":"你的问题不那么清楚啊。\n\nU::* 不是完整类型，void (U::*)() 才是一个类型。U::foo 是一个具体的函数，&amp;amp;U::foo 是函数指针。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578391640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167717,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1577922493,"is_pvip":false,"replies":[{"id":65176,"content":"写这一讲时，我自己也觉得很舒心——正好把相关的技巧整理一遍。这部分还是挺复杂的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577962638,"ip_address":"","comment_id":167717,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"没看这几篇文章前，以为理解模板了，现在才知道模板博大精深👍","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480581,"discussion_content":"你的问题不那么清楚啊。\n\nU::* 不是完整类型，void (U::*)() 才是一个类型。U::foo 是一个具体的函数，&amp;amp;U::foo 是函数指针。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578391640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166868,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577618983,"is_pvip":false,"replies":[{"id":64869,"content":"1. 一个函数没有真正被调用，代码里就不会产生对它的引用，链接没有也就不会出问题。\n\n2. 不是特化，而是自动推断后进行自动实例化。特化是需要有能看得到的特化定义的。\n\n3. 主要是和下面的定义对称。因为这儿的类型不实际使用，写任何的合法类型都是可以的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577674533,"ip_address":"","comment_id":166868,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"吴老师，关于这一课，有 3 个问题\n1，在最开始定义 has_reserve 类时，两个 reserve 模板函数实际上只是声明了，但是并没有真正的函数体，而最后的 value 成员实际上是用 nullptr 调用了 reserve 函数，这就相当于调用一个没有只有声明没有定义的函数，为什么没有报错？\n2，关于模板函数的调用\n假设有如下模板\ntemplate &lt;typename T1, typename T2&gt;\nint add(T1 a, T2 b);\n既可以add&lt;int, double&gt;(1, 2.5)调用，也可以add(1, 2.5)调用，两者的差别是不是第一种方式相当于先声明了一个特化版本，在用这个特化版本来调用，后一种方式是编译器自行推断？但若是没有定义对应的特化版本，第一种方式和第二种方式是不是完全没有区别？\n3，在 void_t 的部分，模板定义时，第二个参数是这样写的：typename = void_t&lt;&gt;， 我试了一下，直接写成 typename = void，也是可以的，你采用这种写法是有什么特殊考虑吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479659,"discussion_content":"1. 一个函数没有真正被调用，代码里就不会产生对它的引用，链接没有也就不会出问题。\n\n2. 不是特化，而是自动推断后进行自动实例化。特化是需要有能看得到的特化定义的。\n\n3. 主要是和下面的定义对称。因为这儿的类型不实际使用，写任何的合法类型都是可以的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577674533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096781,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","nickname":"湖海散人","note":"","ucode":"74C0C825D74CC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217466,"discussion_content":"对于问题1，我也有疑惑，按照老师的答复，也就是说这个没有产生真正的调用？ 这是为啥呀，不是对函数调用后的返回值取了sizeof ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585562583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166273,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1577430232,"is_pvip":false,"replies":[{"id":63432,"content":"不是说了吗，把任意类型映射到void。任意类型哦……只要表达式合法就行。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577454475,"ip_address":"","comment_id":166273,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"“\ntemplate &lt;typename T, typename = void_t&lt;&gt;&gt;\nstruct has_reserve : false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_reserve&lt;T, void_t&lt;decltype(declval&lt;T&amp;&gt;().reserve(1U))&gt;&gt; : true_type {};\n\ndeclval().reserve(1U) 用来测试 C&amp; 类型的对象是不是可以拿 1U 作为参数来调用 reserve 成员函数\n“\n请问\n- 如果是, decltype(declval&lt;T&amp;&gt;().reserve(1U))&gt; 返回的是void，这个好理解，因为void_t会把任何数目（包括零个）的类型转换为类型void\n- 如果不是, 编译器看到decltype(declval&lt;T&amp;&gt;().reserve(1U))&gt; 会做什么？\n                  然后编译器看到void_t&lt;decltype(declval&lt;T&amp;&gt;().reserve(1U))&gt; 又会做什么？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479659,"discussion_content":"1. 一个函数没有真正被调用，代码里就不会产生对它的引用，链接没有也就不会出问题。\n\n2. 不是特化，而是自动推断后进行自动实例化。特化是需要有能看得到的特化定义的。\n\n3. 主要是和下面的定义对称。因为这儿的类型不实际使用，写任何的合法类型都是可以的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577674533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096781,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","nickname":"湖海散人","note":"","ucode":"74C0C825D74CC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217466,"discussion_content":"对于问题1，我也有疑惑，按照老师的答复，也就是说这个没有产生真正的调用？ 这是为啥呀，不是对函数调用后的返回值取了sizeof ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585562583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370415,"user_name":"🐶的巴普洛夫","can_delete":false,"product_type":"c1","uid":3542569,"ip_address":"北京","ucode":"1213DD5A056674","user_header":"https://static001.geekbang.org/account/avatar/00/36/0e/29/fa3601d3.jpg","comment_is_top":false,"comment_ctime":1678796374,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"人生苦短，我不会用C++","like_count":0},{"had_liked":false,"id":355137,"user_name":"HI","can_delete":false,"product_type":"c1","uid":1238921,"ip_address":"广东","ucode":"C65218113883E6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/89/207cc841.jpg","comment_is_top":false,"comment_ctime":1661132040,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"666","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479470,"discussion_content":"不是说了吗，把任意类型映射到void。任意类型哦……只要表达式合法就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577454475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105793,"discussion_content":"哈哈，不用回答了，找到答案了。\n\n“它的特殊性在于，在这个看似无聊的过程中，编译器会检查那个“任意类型”的有效性。”\n\n“这里第二个 has_reserve 模板的定义实际上是一个偏特化 [6]。偏特化是类模板的特有功能，跟函数重载有些相似。编译器会找出所有的可用模板，然后选择其中最“特别”的一个。像上面的例子，所有类型都能满足第一个模板，但不是所有的类型都能满足第二个模板，所以第二个更特别。当第二个模板能被满足时，编译器就会选择第二个特化的模板；而只有第二个模板不能被满足时，才会回到第一个模板的通用情况。”\n\n\n“当第二个模板能被满足时，编译器就会选择第二个特化的模板”\n——> “编译器会检查那个“任意类型”的有效性”\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577489583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105442,"discussion_content":"嗯，转换成void看明白了。\n我之前的的问题有点模糊。\n\n我的问题是，既然是和不是，都转成了void，编译器为什么能正确选择第二个类模版（继承true_type那个）进行特化？\n\n谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577461069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217900,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1589641192,"is_pvip":false,"replies":[{"id":80760,"content":"看起来你对模板推导有点误解，第二个式子完全没有用处。你没有在任何地方提供第二个参数。\n\n如果 get 会导致模板推导失败的话，那这个例子里就可以使用类似于课中 void_t 的方法了。不过，对不存在的成员进行 get 虽然会产生编译失败，这个失败不是推导失败，而是静态断言。因而 void_t 也解决不了问题。\n\n至于你说的逗号表达式，我看不出解决了什么问题。我试验下来也没看到非 1 的结果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589806442,"ip_address":"","comment_id":217900,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"利用 variant 的 std::get 方法，写一个 sfine 用于判断一个 variant 类型里是否联合了 float. 代码和问题如下：\ntemplate &lt;typename T, typename ...&gt;\nstruct CheckVariant {\n    static constexpr int value =  1;\n};\ntemplate &lt;typename T&gt;\nstruct CheckVariant&lt;T,\n    decltype(get&lt;float&gt;( declval&lt;T&gt;() ))\n    &gt;\n{\n    static constexpr int value = 2;\n};\n...\n    if constexpr (CheckVariant&lt;decltype(v)&gt;::value == 1) {\n        cout &lt;&lt; get&lt;float&gt;(v) &lt;&lt; endl;\n    }\n...\n\n可是发现这样的 SFINAE 不起作用，把模板特化代码改为利用 逗号表达式，让 decltype 取值就可以了：\n\ntemplate &lt;typename T&gt;\nstruct CheckVariant&lt;T,\n    decltype((get&lt;float&gt;( declval&lt;T&gt;() ), void()))\n    &gt;\n{\n    static constexpr int value = 2;\n};\n\n这是为什么呢？  \n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495285,"discussion_content":"看起来你对模板推导有点误解，第二个式子完全没有用处。你没有在任何地方提供第二个参数。\n\n如果 get 会导致模板推导失败的话，那这个例子里就可以使用类似于课中 void_t 的方法了。不过，对不存在的成员进行 get 虽然会产生编译失败，这个失败不是推导失败，而是静态断言。因而 void_t 也解决不了问题。\n\n至于你说的逗号表达式，我看不出解决了什么问题。我试验下来也没看到非 1 的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589806442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144416,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","nickname":"西加加","note":"","ucode":"727238758A7F3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267727,"discussion_content":"更新一下，在 decltype 中使用 逗号表达式依然不起作用。昨天应该是看错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589681465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178964,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1581864279,"is_pvip":false,"replies":[{"id":69503,"content":"我觉得应该这么理解：\n\n你给出的表达式是\n\ntypename std::enable_if&lt;std::is_same&lt;T, int&gt;::value&gt;::type\n\n估值后得到\n\ntypename std::enable_if&lt;true&gt;::type\n\n实例化时，编译器看到没有提供第二个参数，加上缺省参数按 std::enable_if&lt;true, void&gt; 实例化，再偏特化得到\n\ntemplate&lt;&gt;\nstruct enable_if&lt;true, void&gt;\n{\n  typedef void type;\n};\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581918448,"ip_address":"","comment_id":178964,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"https:&#47;&#47;en.cppreference.com&#47;w&#47;cpp&#47;types&#47;enable_if\n&quot;\nPossible implementation\ntemplate&lt;bool B, class T = void&gt;\nstruct enable_if {};\n \ntemplate&lt;class T&gt;\nstruct enable_if&lt;true, T&gt; { typedef T type; };\n&quot;\n\n下列的测试代码可以编译，运行\n&quot;\n#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename X, typename T, typename Y&gt;\ntypename std::enable_if&lt;std::is_same&lt;T, int&gt;::value&gt;::type update(X x, T t, Y y)\n{\n    std::cout &lt;&lt; &quot;int&quot; &lt;&lt; std::endl;\n}\n\nint main () {\n    float a = 1.4;\n    int b = 1;\n    double c =2.2;\n    update(a, b, c);\n}\n&quot;\n\n其中我用的是std::enable_if&lt;std::is_same&lt;T, int&gt;::value&gt;， 并没有提供参数来推导T，\n这是不是意味着对于true这种情况的偏特化implementation是\ntemplate&lt;class T = void&gt;\nstruct enable_if&lt;true, T&gt; { typedef T type; };\n\n而不是\n\ntemplate&lt;class T&gt;\nstruct enable_if&lt;true, T&gt; { typedef T type; };\n\n谢谢！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495285,"discussion_content":"看起来你对模板推导有点误解，第二个式子完全没有用处。你没有在任何地方提供第二个参数。\n\n如果 get 会导致模板推导失败的话，那这个例子里就可以使用类似于课中 void_t 的方法了。不过，对不存在的成员进行 get 虽然会产生编译失败，这个失败不是推导失败，而是静态断言。因而 void_t 也解决不了问题。\n\n至于你说的逗号表达式，我看不出解决了什么问题。我试验下来也没看到非 1 的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589806442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144416,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","nickname":"西加加","note":"","ucode":"727238758A7F3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267727,"discussion_content":"更新一下，在 decltype 中使用 逗号表达式依然不起作用。昨天应该是看错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589681465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178429,"user_name":"贾陆华","can_delete":false,"product_type":"c1","uid":1321408,"ip_address":"","ucode":"2722C422077EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","comment_is_top":false,"comment_ctime":1581688048,"is_pvip":false,"replies":[{"id":69240,"content":"模板绝对是 C++ 的一大特点。虽说有些技巧会过时（SFINAE 到 C++20 也会变得有点过时；看完全部你就知道了），但模板和静态鸭子类型这样的用法在目前的其他主流语言里是没有的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581733086,"ip_address":"","comment_id":178429,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"吴老师，写的满满干货，之前模板并没有深入学习，才知道模板可以这么花，用途可以这么多","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484040,"discussion_content":"我觉得应该这么理解：\n\n你给出的表达式是\n\ntypename std::enable_if&amp;lt;std::is_same&amp;lt;T, int&amp;gt;::value&amp;gt;::type\n\n估值后得到\n\ntypename std::enable_if&amp;lt;true&amp;gt;::type\n\n实例化时，编译器看到没有提供第二个参数，加上缺省参数按 std::enable_if&amp;lt;true, void&amp;gt; 实例化，再偏特化得到\n\ntemplate&amp;lt;&amp;gt;\nstruct enable_if&amp;lt;true, void&amp;gt;\n{\n  typedef void type;\n};\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581918448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175245,"discussion_content":"有意思。\n我原以为实例化的过程，只会选择一个模版进行。\n这个实例化的过程，\n\n先是用了第一个模版，\ntemplate<bool B, class T = void>\nstruct enable_if {};\n \n\n然后再用了第二个偏特化的模版。\ntemplate<class T>\nstruct enable_if<true, T> { typedef T type; };\n\n多谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581952468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169492,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1578365325,"is_pvip":false,"replies":[{"id":65782,"content":"你的问题不那么清楚啊。\n\nU::* 不是完整类型，void (U::*)() 才是一个类型。U::foo 是一个具体的函数，&amp;U::foo 是函数指针。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578391640,"ip_address":"","comment_id":169492,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"假设U是一个Class,内部有foo方法与bar方法，那么U::*表示的是所有成员函数的指针吧，而U::foo*是foo成员函数指针，还请老师指点。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483817,"discussion_content":"模板绝对是 C++ 的一大特点。虽说有些技巧会过时（SFINAE 到 C++20 也会变得有点过时；看完全部你就知道了），但模板和静态鸭子类型这样的用法在目前的其他主流语言里是没有的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581733086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167717,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1577922493,"is_pvip":false,"replies":[{"id":65176,"content":"写这一讲时，我自己也觉得很舒心——正好把相关的技巧整理一遍。这部分还是挺复杂的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577962638,"ip_address":"","comment_id":167717,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"没看这几篇文章前，以为理解模板了，现在才知道模板博大精深👍","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479960,"discussion_content":"写这一讲时，我自己也觉得很舒心——正好把相关的技巧整理一遍。这部分还是挺复杂的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577962638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166868,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577618983,"is_pvip":false,"replies":[{"id":64869,"content":"1. 一个函数没有真正被调用，代码里就不会产生对它的引用，链接没有也就不会出问题。\n\n2. 不是特化，而是自动推断后进行自动实例化。特化是需要有能看得到的特化定义的。\n\n3. 主要是和下面的定义对称。因为这儿的类型不实际使用，写任何的合法类型都是可以的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577674533,"ip_address":"","comment_id":166868,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"吴老师，关于这一课，有 3 个问题\n1，在最开始定义 has_reserve 类时，两个 reserve 模板函数实际上只是声明了，但是并没有真正的函数体，而最后的 value 成员实际上是用 nullptr 调用了 reserve 函数，这就相当于调用一个没有只有声明没有定义的函数，为什么没有报错？\n2，关于模板函数的调用\n假设有如下模板\ntemplate &lt;typename T1, typename T2&gt;\nint add(T1 a, T2 b);\n既可以add&lt;int, double&gt;(1, 2.5)调用，也可以add(1, 2.5)调用，两者的差别是不是第一种方式相当于先声明了一个特化版本，在用这个特化版本来调用，后一种方式是编译器自行推断？但若是没有定义对应的特化版本，第一种方式和第二种方式是不是完全没有区别？\n3，在 void_t 的部分，模板定义时，第二个参数是这样写的：typename = void_t&lt;&gt;， 我试了一下，直接写成 typename = void，也是可以的，你采用这种写法是有什么特殊考虑吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479960,"discussion_content":"写这一讲时，我自己也觉得很舒心——正好把相关的技巧整理一遍。这部分还是挺复杂的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577962638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166273,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1577430232,"is_pvip":false,"replies":[{"id":63432,"content":"不是说了吗，把任意类型映射到void。任意类型哦……只要表达式合法就行。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577454475,"ip_address":"","comment_id":166273,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"“\ntemplate &lt;typename T, typename = void_t&lt;&gt;&gt;\nstruct has_reserve : false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_reserve&lt;T, void_t&lt;decltype(declval&lt;T&amp;&gt;().reserve(1U))&gt;&gt; : true_type {};\n\ndeclval().reserve(1U) 用来测试 C&amp; 类型的对象是不是可以拿 1U 作为参数来调用 reserve 成员函数\n“\n请问\n- 如果是, decltype(declval&lt;T&amp;&gt;().reserve(1U))&gt; 返回的是void，这个好理解，因为void_t会把任何数目（包括零个）的类型转换为类型void\n- 如果不是, 编译器看到decltype(declval&lt;T&amp;&gt;().reserve(1U))&gt; 会做什么？\n                  然后编译器看到void_t&lt;decltype(declval&lt;T&amp;&gt;().reserve(1U))&gt; 又会做什么？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479470,"discussion_content":"不是说了吗，把任意类型映射到void。任意类型哦……只要表达式合法就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577454475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105793,"discussion_content":"哈哈，不用回答了，找到答案了。\n\n“它的特殊性在于，在这个看似无聊的过程中，编译器会检查那个“任意类型”的有效性。”\n\n“这里第二个 has_reserve 模板的定义实际上是一个偏特化 [6]。偏特化是类模板的特有功能，跟函数重载有些相似。编译器会找出所有的可用模板，然后选择其中最“特别”的一个。像上面的例子，所有类型都能满足第一个模板，但不是所有的类型都能满足第二个模板，所以第二个更特别。当第二个模板能被满足时，编译器就会选择第二个特化的模板；而只有第二个模板不能被满足时，才会回到第一个模板的通用情况。”\n\n\n“当第二个模板能被满足时，编译器就会选择第二个特化的模板”\n——> “编译器会检查那个“任意类型”的有效性”\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577489583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105442,"discussion_content":"嗯，转换成void看明白了。\n我之前的的问题有点模糊。\n\n我的问题是，既然是和不是，都转成了void，编译器为什么能正确选择第二个类模版（继承true_type那个）进行特化？\n\n谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577461069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370415,"user_name":"🐶的巴普洛夫","can_delete":false,"product_type":"c1","uid":3542569,"ip_address":"北京","ucode":"1213DD5A056674","user_header":"https://static001.geekbang.org/account/avatar/00/36/0e/29/fa3601d3.jpg","comment_is_top":false,"comment_ctime":1678796374,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"人生苦短，我不会用C++","like_count":0},{"had_liked":false,"id":355137,"user_name":"HI","can_delete":false,"product_type":"c1","uid":1238921,"ip_address":"广东","ucode":"C65218113883E6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/89/207cc841.jpg","comment_is_top":false,"comment_ctime":1661132040,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"666","like_count":0}]}