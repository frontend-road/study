{"id":86695,"title":"11 | Java线程（下）：为什么局部变量是线程安全的？","content":"<p>我们一遍一遍重复再重复地讲到，多个线程同时访问共享变量的时候，会导致并发问题。那在Java语言里，是不是所有变量都是共享变量呢？工作中我发现不少同学会给方法里面的局部变量设置同步，显然这些同学并没有把共享变量搞清楚。那Java方法里面的局部变量是否存在并发问题呢？下面我们就先结合一个例子剖析下这个问题。</p><p>比如，下面代码里的 fibonacci() 这个方法，会根据传入的参数 n ，返回 1 到 n 的斐波那契数列，斐波那契数列类似这样： 1、1、2、3、5、8、13、21、34……第1项和第2项是1，从第3项开始，每一项都等于前两项之和。在这个方法里面，有个局部变量：数组 r 用来保存数列的结果，每次计算完一项，都会更新数组 r 对应位置中的值。你可以思考这样一个问题，当多个线程调用 fibonacci() 这个方法的时候，数组 r 是否存在数据竞争（Data Race）呢？</p><pre><code>// 返回斐波那契数列\nint[] fibonacci(int n) {\n  // 创建结果数组\n  int[] r = new int[n];\n  // 初始化第一、第二个数\n  r[0] = r[1] = 1;  // ①\n  // 计算2..n\n  for(int i = 2; i &lt; n; i++) {\n      r[i] = r[i-2] + r[i-1];\n  }\n  return r;\n}\n</code></pre><p>你自己可以在大脑里模拟一下多个线程调用 fibonacci() 方法的情景，假设多个线程执行到 ① 处，多个线程都要对数组r的第1项和第2项赋值，这里看上去感觉是存在数据竞争的，不过感觉再次欺骗了你。</p><p>其实很多人也是知道局部变量不存在数据竞争的，但是至于原因嘛，就说不清楚了。</p><!-- [[[read_end]]] --><p>那它背后的原因到底是怎样的呢？要弄清楚这个，你需要一点编译原理的知识。你知道在CPU层面，是没有方法概念的，CPU的眼里，只有一条条的指令。编译程序，负责把高级语言里的方法转换成一条条的指令。所以你可以站在编译器实现者的角度来思考“怎么完成方法到指令的转换”。</p><h2>方法是如何被执行的</h2><p>高级语言里的普通语句，例如上面的<code>r[i] = r[i-2] + r[i-1];</code>翻译成CPU的指令相对简单，可方法的调用就比较复杂了。例如下面这三行代码：第1行，声明一个int变量a；第2行，调用方法 fibonacci(a)；第3行，将b赋值给c。</p><pre><code>int a = 7；\nint[] b = fibonacci(a);\nint[] c = b;\n</code></pre><p>当你调用fibonacci(a)的时候，CPU要先找到方法 fibonacci() 的地址，然后跳转到这个地址去执行代码，最后CPU执行完方法  fibonacci() 之后，要能够返回。首先找到调用方法的下一条语句的地址：也就是<code>int[] c=b;</code>的地址，再跳转到这个地址去执行。 你可以参考下面这个图再加深一下理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/9b/1f/9bd881b545e1c67142486f6594dc9d1f.png?wh=1142*741\" alt=\"\"></p><center><span class=\"reference\">方法的调用过程</span></center><p>到这里，方法调用的过程想必你已经清楚了，但是还有一个很重要的问题，“CPU去哪里找到调用方法的参数和返回地址？”如果你熟悉CPU的工作原理，你应该会立刻想到：<strong>通过CPU的堆栈寄存器</strong>。CPU支持一种栈结构，栈你一定很熟悉了，就像手枪的弹夹，先入后出。因为这个栈是和方法调用相关的，因此经常被称为<strong>调用栈</strong>。</p><p>例如，有三个方法A、B、C，他们的调用关系是A-&gt;B-&gt;C（A调用B，B调用C），在运行时，会构建出下面这样的调用栈。每个方法在调用栈里都有自己的独立空间，称为<strong>栈帧</strong>，每个栈帧里都有对应方法需要的参数和返回地址。当调用方法时，会创建新的栈帧，并压入调用栈；当方法返回时，对应的栈帧就会被自动弹出。也就是说，<strong>栈帧和方法是同生共死的</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/67/c7/674bb47feccbf55cf0b6acc5c92e4fc7.png?wh=1142*571\" alt=\"\"></p><center><span class=\"reference\">调用栈结构</span></center><p>利用栈结构来支持方法调用这个方案非常普遍，以至于CPU里内置了栈寄存器。虽然各家编程语言定义的方法千奇百怪，但是方法的内部执行原理却是出奇的一致：都是<strong>靠栈结构解决</strong>的。Java语言虽然是靠虚拟机解释执行的，但是方法的调用也是利用栈结构解决的。</p><h2>局部变量存哪里？</h2><p>我们已经知道了方法间的调用在CPU眼里是怎么执行的，但还有一个关键问题：方法内的局部变量存哪里？</p><p>局部变量的作用域是方法内部，也就是说当方法执行完，局部变量就没用了，局部变量应该和方法同生共死。此时你应该会想到调用栈的栈帧，调用栈的栈帧就是和方法同生共死的，所以局部变量放到调用栈里那儿是相当的合理。事实上，的确是这样的，<strong>局部变量就是放到了调用栈里</strong>。于是调用栈的结构就变成了下图这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/ec/9c/ece8c32d23e4777c370f594c97762a9c.png?wh=1142*571\" alt=\"\"></p><center><span class=\"reference\">保护局部变量的调用栈结构</span></center><p>这个结论相信很多人都知道，因为学Java语言的时候，基本所有的教材都会告诉你 new 出来的对象是在堆里，局部变量是在栈里，只不过很多人并不清楚堆和栈的区别，以及为什么要区分堆和栈。现在你应该很清楚了，局部变量是和方法同生共死的，一个变量如果想跨越方法的边界，就必须创建在堆里。</p><h2>调用栈与线程</h2><p>两个线程可以同时用不同的参数调用相同的方法，那调用栈和线程之间是什么关系呢？答案是：<strong>每个线程都有自己独立的调用栈</strong>。因为如果不是这样，那两个线程就互相干扰了。如下面这幅图所示，线程A、B、C每个线程都有自己独立的调用栈。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/1a/840cb955e521bd51776dbcdad3dba11a.png?wh=1142*571\" alt=\"\"></p><center><span class=\"reference\">线程与调用栈的关系图</span></center><p>现在，让我们回过头来再看篇首的问题：Java方法里面的局部变量是否存在并发问题？现在你应该很清楚了，一点问题都没有。因为每个线程都有自己的调用栈，局部变量保存在线程各自的调用栈里面，不会共享，所以自然也就没有并发问题。再次重申一遍：没有共享，就没有伤害。</p><h2>线程封闭</h2><p>方法里的局部变量，因为不会和其他线程共享，所以没有并发问题，这个思路很好，已经成为解决并发问题的一个重要技术，同时还有个响当当的名字叫做<strong>线程封闭</strong>，比较官方的解释是：<strong>仅在单线程内访问数据</strong>。由于不存在共享，所以即便不同步也不会有并发问题，性能杠杠的。</p><p>采用线程封闭技术的案例非常多，例如从数据库连接池里获取的连接Connection，在JDBC规范里并没有要求这个Connection必须是线程安全的。数据库连接池通过线程封闭技术，保证一个Connection一旦被一个线程获取之后，在这个线程关闭Connection之前的这段时间里，不会再分配给其他线程，从而保证了Connection不会有并发问题。</p><h2>总结</h2><p>调用栈是一个通用的计算机概念，所有的编程语言都会涉及到，Java调用栈相关的知识，我并没有花费很大的力气去深究，但是靠着那点C语言的知识，稍微思考一下，基本上也就推断出来了。工作了十几年，我发现最近几年和前些年最大的区别是：很多技术的实现原理我都是靠推断，然后看源码验证，而不是像以前一样纯粹靠看源码来总结了。</p><p>建议你也多研究原理性的东西、通用的东西，有这些东西之后再学具体的技术就快多了。</p><h2>课后思考</h2><p>常听人说，递归调用太深，可能导致栈溢出。你思考一下原因是什么？有哪些解决方案呢？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"10 | Java线程（中）：创建多少线程才是合适的？","id":86666},"right":{"article_title":"12 | 如何用面向对象思想写好并发程序？","id":87365}},"comments":[{"had_liked":false,"id":78947,"user_name":"uyong","can_delete":false,"product_type":"c1","uid":1024665,"ip_address":"","ucode":"FA08C838F2A0F3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKTAKspiaW6t3GY9Ht5aWqoJartZYqA3ROTlJgBKK41icia7a5BrcvKnILzzRk4cVBg0DRPhiacl7BgPQ/132","comment_is_top":false,"comment_ctime":1553306059,"is_pvip":false,"replies":[{"id":"28809","content":"很全面了。所有的递归算法都可以用非递归算法实现，大学老师好像还出过这样一道题......","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553340369,"ip_address":"","comment_id":78947,"utype":1}],"discussion_count":15,"race_medal":2,"score":"950741078475","product_id":100023901,"comment_content":"栈溢出原因：<br>因为每调用一个方法就会在栈上创建一个栈帧，方法调用结束后就会弹出该栈帧，而栈的大小不是无限的，所以递归调用次数过多的话就会导致栈溢出。而递归调用的特点是每递归一次，就要创建一个新的栈帧，而且还要保留之前的环境（栈帧），直到遇到结束条件。所以递归调用一定要明确好结束条件，不要出现死循环，而且要避免栈太深。<br>解决方法：<br>1. 简单粗暴，不要使用递归，使用循环替代。缺点：代码逻辑不够清晰；<br>2. 限制递归次数；<br>3. 使用尾递归，尾递归是指在方法返回时只调用自己本身，且不能包含表达式。编译器或解释器会把尾递归做优化，使递归方法不论调用多少次，都只占用一个栈帧，所以不会出现栈溢出。然鹅，Java没有尾递归优化。","like_count":222,"discussions":[{"author":{"id":1239293,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","nickname":"Sharry","note":"","ucode":"045DDB864659F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8827,"discussion_content":"递归一般是回溯算法, 改成 for 循环可能就变成动态规划了, 不仅减少栈帧数, 而且算法改进后可以提升性能呢","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1568078225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1014146,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/82/c3cccc38.jpg","nickname":"IT生涯路漫漫","note":"","ucode":"4954D1CBEB4E44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1239293,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","nickname":"Sharry","note":"","ucode":"045DDB864659F6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303677,"discussion_content":"如果要读取一个目录及其子目录下的所有文件，请教一下不用递归改用循环怎么做？因为你不知道这个目录下有多少层子目录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599347227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8827,"ip_address":""},"score":303677,"extra":""},{"author":{"id":1283530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/ca/00c1b1ef.jpg","nickname":"moka","note":"","ucode":"BAD5F1EB775C58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1014146,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/82/c3cccc38.jpg","nickname":"IT生涯路漫漫","note":"","ucode":"4954D1CBEB4E44","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333087,"discussion_content":"while(!queue.empty) {\n   var list = getDirList();\n   queue.add(list);\n}","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1607430235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303677,"ip_address":""},"score":333087,"extra":""},{"author":{"id":1367043,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/03/ad9574b3.jpg","nickname":"习兮习兮","note":"","ucode":"E616E924188CBA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1014146,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/82/c3cccc38.jpg","nickname":"IT生涯路漫漫","note":"","ucode":"4954D1CBEB4E44","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365997,"discussion_content":"BFS算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617937807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303677,"ip_address":""},"score":365997,"extra":""}]},{"author":{"id":1115302,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","nickname":"Airsaid","note":"","ucode":"5B90BC0044F376","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196081,"discussion_content":"将递归改为循环，并没有任何实质性的变化。因为将递归改为循环，其实堆栈还是依然存在的，只不过是从 stack 换到了 heap 中自己来管理。heap 和 stack 没有任何本质上的区别，都是内存。Java 对栈调用有限制，因此才会抛出溢出异常，我们只要通过 JVM 的 \n-Xss 参数调整 stack 的大小即可。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1583329606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1115302,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","nickname":"Airsaid","note":"","ucode":"5B90BC0044F376","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560507,"discussion_content":"665","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649348382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":196081,"ip_address":""},"score":560507,"extra":""}]},{"author":{"id":1785016,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","nickname":"鱼丸粗面","note":"","ucode":"B2F3F75B0D1422","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208737,"discussion_content":"java有尾递归","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584579158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330333,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4c/9d/601b1949.jpg","nickname":"huguo","note":"","ucode":"418B04E2AB13EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174127,"discussion_content":"kotlin 有尾递归优化，kotlin YES!","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581870303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444300,"discussion_content":"很全面了。所有的递归算法都可以用非递归算法实现，大学老师好像还出过这样一道题......","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1553340369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538204,"discussion_content":"优化点：\n1.使用迭代（循环）\n2.使用尾递归\n3.使用fork - join\n4.改进算法 弃用递归 ——我觉得第四点最难","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639366612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1565085,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e1/9d/3ec0adec.jpg","nickname":"喃寻","note":"","ucode":"E31B3660726671","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337302,"discussion_content":"java是有尾递归，编译器也会进行优化，使得计算仅占常量栈空间（Stack Space）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608866310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257422,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/ce/c72d4c67.jpg","nickname":"movesan","note":"","ucode":"29CDF0F2B604C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185190,"discussion_content":"借楼有个疑问：\n我的理解是 JVM 也是内存中规划出来的结构吧，也是属于内存的一部分，所以说 JVM 中的调用栈应该都是存在于内存中；但是最终都会被编译成计算机指令，CPU 调用的时候是依赖于自己寄存器中的栈结构，请问老师，我这样理解对吗？如果对的话，方法参数和局部变量也会被编译到寄存器中吗，那这样应该放不下吧，CPU 寄存器中的栈和 JVM 中的方法栈是否有联系呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582601662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1257422,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/ce/c72d4c67.jpg","nickname":"movesan","note":"","ucode":"29CDF0F2B604C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560508,"discussion_content":"都是存放地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649348418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":185190,"ip_address":""},"score":560508,"extra":""}]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6141,"discussion_content":"学习学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566722992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79714,"user_name":"suynan","can_delete":false,"product_type":"c1","uid":1023214,"ip_address":"","ucode":"0AAD1BA9D22D2C","user_header":"","comment_is_top":false,"comment_ctime":1553525087,"is_pvip":false,"replies":[{"id":"29082","content":"是的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553559507,"ip_address":"","comment_id":79714,"utype":1}],"discussion_count":11,"race_medal":0,"score":"302201235807","product_id":100023901,"comment_content":"对于这句话：“ new 出来的对象是在堆里，局部变量在栈里”<br>我觉得应该是对象在堆里，引用（句柄）在栈里","like_count":71,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444591,"discussion_content":"是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553559507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2708370,"avatar":"https://static001.geekbang.org/account/avatar/00/29/53/92/21c78176.jpg","nickname":"小黄鸭","note":"","ucode":"2800E3A723AEBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":537232,"discussion_content":"老师，如果是这样的话，多个线程操作中使用对象引用，不是相当于共享变量了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639009007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":444591,"ip_address":""},"score":537232,"extra":""},{"author":{"id":1462645,"avatar":"https://static001.geekbang.org/account/avatar/00/16/51/75/6997e91a.jpg","nickname":"Sean 🍓","note":"","ucode":"652F4C2A8D93A1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2708370,"avatar":"https://static001.geekbang.org/account/avatar/00/29/53/92/21c78176.jpg","nickname":"小黄鸭","note":"","ucode":"2800E3A723AEBD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572433,"discussion_content":"如果你的对象是在方法内部，那方法外的就无法访问，就不是共享变量。如果对象是方法外面传进来的，那对于方法来说肯定算共享变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652781215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537232,"ip_address":""},"score":572433,"extra":""}]},{"author":{"id":1145246,"avatar":"https://static001.geekbang.org/account/avatar/00/11/79/9e/cb58102f.jpg","nickname":"心安。","note":"","ucode":"9DF230F4CFB475","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5559,"discussion_content":"句柄不在栈内存中吧，句柄是句柄，引用是引用，句柄应该是在句柄池中，也就是堆区。很简单的推断就是句柄应该适合对象的生命周期相同的，所以不能再栈中。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1566353895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1131027,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/13/860e176a.jpg","nickname":"外国肉夹馍","note":"","ucode":"00BADDCFEA92B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1145246,"avatar":"https://static001.geekbang.org/account/avatar/00/11/79/9e/cb58102f.jpg","nickname":"心安。","note":"","ucode":"9DF230F4CFB475","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337697,"discussion_content":"句柄和引用的区别是啥？单就jvm领域","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609049421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5559,"ip_address":""},"score":337697,"extra":""},{"author":{"id":1089385,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9f/69/bb533bad.jpg","nickname":"lee","note":"","ucode":"47E318CD6A0471","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1131027,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/13/860e176a.jpg","nickname":"外国肉夹馍","note":"","ucode":"00BADDCFEA92B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369366,"discussion_content":"可以看看jvm虚拟机栈里的局部变量表（局部变量表里面存储基本数据类型和reference，这个reference可以是指向对象的地址或者代表对象的句柄（这个句柄在堆中）；指向对象的地址就是指向堆中的对象实例数据和指向方法区对象类型数据的指针；而代表对象的句柄保存的就是稳定的指针（分别指向堆区域实例数据的指针和指向方法区对象类型数据的指针））[java 程序就是通过栈上的reference数据去操作堆中的具体实例对象，就是句柄和指针都是访问对象的方式]","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619012498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337697,"ip_address":""},"score":369366,"extra":""},{"author":{"id":2593255,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2msSWvJs8A6icPvUzyRs9DEqltYh0edy699wJz9BmCRoJj1bZHhBHhp4yY9Nic9oc2q8OdsVGwtmBRhKtw00Jj6Q/132","nickname":"Geek_c139e0","note":"","ucode":"87C7E07E98354B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1131027,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/13/860e176a.jpg","nickname":"外国肉夹馍","note":"","ucode":"00BADDCFEA92B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536390,"discussion_content":"据我在think in java中所看到的，句柄和引用是一个概念两个说法（引用说的会比较多），句柄在英文版原文中就是reference，但是句柄和指针确实不是一个概念。句柄是对指针的再封装，句柄中存放了对象堆地址也就是指针。使用reference是在栈中去访问堆中的句柄池，句柄池中的句柄再存放了对象具体的数据地址(指针)，实际也就是jvm帮你维护了指针的地址，而你只需要用引用，就可以无缝访问可能被GC移动过的对象数据了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638776555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337697,"ip_address":""},"score":536390,"extra":""}]},{"author":{"id":1126649,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/f9/c0d1af4f.jpg","nickname":"三好码农","note":"","ucode":"1C118F2234F345","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292568,"discussion_content":"要看对象有没有逃逸，没有逃逸可能会被优化在栈上分配，虚拟机参数可以配置","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595256391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1183424,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0e/c0/95fa2666.jpg","nickname":"山楂树","note":"","ucode":"1D59FC0C560BCD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6508,"discussion_content":"深入理解java虚拟机，第48页，java堆中会划分出一块内存来作为句柄池。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566951911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2403622,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ad/26/d46f4394.jpg","nickname":"Owen","note":"","ucode":"FDE0D574B8ED5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347898,"discussion_content":"那全局变量在哪里？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612357988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278734,"discussion_content":"以为两者是一个概念","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591231522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78910,"user_name":"西西弗与卡夫卡","can_delete":false,"product_type":"c1","uid":1001710,"ip_address":"","ucode":"B4C27B8335B76A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/ee/872ad07e.jpg","comment_is_top":false,"comment_ctime":1553290575,"is_pvip":true,"replies":[{"id":"28893","content":"没怎么听说Java尾递归优化的事情，不太确定。最好不要依赖这个","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553403201,"ip_address":"","comment_id":78910,"utype":1}],"discussion_count":1,"race_medal":0,"score":"108927472975","product_id":100023901,"comment_content":"因为调用方法时局部变量会进线程的栈帧，线程的栈内存是有限的，而递归没控制好容易造成太多层次调用，最终栈溢出。<br><br>解决思路一是开源节流，即减少多余的局部变量或扩大栈内存大小设置，减少调用层次涉及具体业务逻辑，优化空间有限；二是改弦更张，即想办法消除递归，比如说能否改造成尾递归（Java会优化掉尾递归）","like_count":25,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444283,"discussion_content":"没怎么听说Java尾递归优化的事情，不太确定。最好不要依赖这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553403201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79233,"user_name":"Geek_cc0a3b","can_delete":false,"product_type":"c1","uid":1442156,"ip_address":"","ucode":"8D6C16AC4A9ED0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6ADlY3IFt3Rs1aVDyrTO2BiaV8wiabypPwbXhbPcyqicCvnTV9lUYHULVqUab7ww4taX5QbmFyatLQ/132","comment_is_top":false,"comment_ctime":1553411394,"is_pvip":false,"replies":[{"id":"28912","content":"对象堆里，但是指针在栈里<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553418181,"ip_address":"","comment_id":79233,"utype":1}],"discussion_count":9,"race_medal":0,"score":"100337659202","product_id":100023901,"comment_content":"new 出来的对象是在堆里，局部变量是在栈里，那方法中new出来的对象属于局部变量，是保存在堆里还是在栈里呢？","like_count":23,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444409,"discussion_content":"对象堆里，但是指针在栈里\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553418181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014573,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","nickname":"SharpBB","note":"","ucode":"D30C5B798B8E8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406620,"discussion_content":"理论上来说局部变量应该在栈上分配 但是hotspot没有实现 所以对象无脑放在堆中 这里涉及到逃逸分析 局部变量没有逃逸出方法 所以对象会被标量替换成最小的不可分解的结构 相当于把对象拆分了 也就不会在堆上创建对象了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634807568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2403622,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ad/26/d46f4394.jpg","nickname":"Owen","note":"","ucode":"FDE0D574B8ED5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347899,"discussion_content":"那全局变量在哪里？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612358007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1258455,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/d7/739e2f6d.jpg","nickname":"Utah","note":"","ucode":"AD5EEFE68706A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2403622,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ad/26/d46f4394.jpg","nickname":"Owen","note":"","ucode":"FDE0D574B8ED5A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402491,"discussion_content":"全局变量在堆里，常量在方法区","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1633881996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":347899,"ip_address":""},"score":402491,"extra":""}]},{"author":{"id":1099706,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/ba/4c449be2.jpg","nickname":"zhaozp","note":"","ucode":"BF390F5ED762CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300365,"discussion_content":"局部变量是指在方法里引用的方法外的变量，还是说局部变量只是指在方法内new的方法呢~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598065019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099706,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/ba/4c449be2.jpg","nickname":"zhaozp","note":"","ucode":"BF390F5ED762CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300363,"discussion_content":"那2个线程同时修改这个被引用的对象 不是就有并发安全问题了吗，但是文中说局部变量是线程安全的？老师请问下，这里感觉有些混淆~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598064949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1507783,"avatar":"https://static001.geekbang.org/account/avatar/00/17/01/c7/549b5616.jpg","nickname":"夜涛","note":"","ucode":"672CC53663710B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1099706,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/ba/4c449be2.jpg","nickname":"zhaozp","note":"","ucode":"BF390F5ED762CD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309697,"discussion_content":"每个方法new出来的引用不一样，调用几次这个方法就会new几次，每次的引用都不一样，每个线程都是不同的引用，怎么会有并发问题？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1601390720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300363,"ip_address":""},"score":309697,"extra":""},{"author":{"id":1367048,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","nickname":"陈斌","note":"","ucode":"B639AB5F6AA03D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1099706,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/ba/4c449be2.jpg","nickname":"zhaozp","note":"","ucode":"BF390F5ED762CD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344102,"discussion_content":"new 两次 就不是同一个对象了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611291400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300363,"ip_address":""},"score":344102,"extra":""},{"author":{"id":1367043,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/03/ad9574b3.jpg","nickname":"习兮习兮","note":"","ucode":"E616E924188CBA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1099706,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/ba/4c449be2.jpg","nickname":"zhaozp","note":"","ucode":"BF390F5ED762CD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366000,"discussion_content":"多个线程中new一个对象时，他们new出来的对象都存在于堆中，但是对象的指针都存储在各自线程的栈中；线程之间是获取不到各自new出来对象的指针的，因此并不能操作到其他线程的对象；除非将对象赋值给一个成员变量，这样的话又变成了成员变量共享的问题","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1617938236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300363,"ip_address":""},"score":366000,"extra":""}]}]},{"had_liked":false,"id":80272,"user_name":"Xiao","can_delete":false,"product_type":"c1","uid":1179212,"ip_address":"","ucode":"71FFCCEEDE09E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/4c/46eb517a.jpg","comment_is_top":false,"comment_ctime":1553646402,"is_pvip":true,"replies":[{"id":"29232","content":"你看看编译器允不允许这样做吧<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553646943,"ip_address":"","comment_id":80272,"utype":1}],"discussion_count":11,"race_medal":0,"score":"83158025026","product_id":100023901,"comment_content":"如果方法内部又有多线程，那方法内部的局部变量是不是也不是线程安全。","like_count":19,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444807,"discussion_content":"你看看编译器允不允许这样做吧\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553646943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1657429,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwTZdUafC5YM7bCASt8icUnoyYfV4hUHulexibDI7B4eaokTxYXHFtoic97DBlCAU9j5Jw4QUuGhyZQ/132","nickname":"Carisy","note":"","ucode":"67E887967347BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19488,"discussion_content":"方法内部的局部变量传到线程里要是final修饰的，不会有这种问题","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1569201802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39419,"discussion_content":"这样就成 final","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1571923291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131027,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/13/860e176a.jpg","nickname":"外国肉夹馍","note":"","ucode":"00BADDCFEA92B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337700,"discussion_content":"我觉得题主说的没毛病。比如在一个方法里。new一个map。然后创建几个线程。把这个map传递给这几个线程。此时还是会有线程安全问题。尽管map被修饰为了final。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609050100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448974,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/0e/42b357cd.jpg","nickname":"Xiky","note":"","ucode":"C9E8D8C7024CA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261,"discussion_content":"这当然会，所以有些在方法里面用线程池做一些异步操作又要收集操作结果的，要用线程安全的对象去处理。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561366549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572101,"discussion_content":"老师讲的是多个线程压栈 栈里的数据是没有问题的，你这个说的是一个栈里，多个线程去对一个变量操作，需要看这个变量是否是线程安全的，比如map 肯定会有问题，此时就需要对map做安全同步了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652602772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138700,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/0c/1230e604.jpg","nickname":"杨迪","note":"","ucode":"7499998692000C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571571,"discussion_content":"  试了下不安全；\npublic static void main(String[] args) throws InterruptedException {\n\n        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();\n        Thread t1 = new Thread(() -&gt; {\n            for (int i=0; i&lt;10000; i++) {\n               map.put(&#34;a&#34;+i, String.valueOf(i));\n            }\n        });\n        t1.start();\n\n        Thread t2 = new Thread(() -&gt; {\n            for (int i=0; i&lt;10000; i++) {\n                map.put(&#34;b&#34;+i, String.valueOf(i));\n            }\n        });\n        t2.start();\n\n        t1.join();\n        t2.join();\n        System.out.println(map.size());\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652273818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1145759,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7b/9f/da374651.jpg","nickname":"zero","note":"","ucode":"D8A22815D8987C","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":1138700,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/0c/1230e604.jpg","nickname":"杨迪","note":"","ucode":"7499998692000C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571905,"discussion_content":"你这个map还是算共享变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652456989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":571571,"ip_address":""},"score":571905,"extra":""}]},{"author":{"id":1304195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtlEYuHnR8VdRkNPcmkIqTM9DKahpcpicDdBvcmBWMIAAhBrd0QNWvl09slqrzB5TibryVcIfPmb7Q/132","nickname":"raisecomer","note":"","ucode":"32EA488E46471F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305417,"discussion_content":"在Java中局部变量是线程安全的，无论线程是否在方法内部，因为Java中参数传递时只有传值，没有传址，局部变量作为参数传递时，只能按值传递，也就是它的副本被传递到了其它线程中，是不会让局部变量从方法作用域中逸出的，但在c/c++中局部变量不一定线程安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599917103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1961072,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/ec/70/50af6724.jpg","nickname":"张咘咘","note":"","ucode":"4AA6E0DF112CF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1304195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtlEYuHnR8VdRkNPcmkIqTM9DKahpcpicDdBvcmBWMIAAhBrd0QNWvl09slqrzB5TibryVcIfPmb7Q/132","nickname":"raisecomer","note":"","ucode":"32EA488E46471F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542794,"discussion_content":"你让我怀疑了人生","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640847127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305417,"ip_address":""},"score":542794,"extra":""},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1304195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtlEYuHnR8VdRkNPcmkIqTM9DKahpcpicDdBvcmBWMIAAhBrd0QNWvl09slqrzB5TibryVcIfPmb7Q/132","nickname":"raisecomer","note":"","ucode":"32EA488E46471F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560509,"discussion_content":"你让我怀疑了人生","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649348546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305417,"ip_address":""},"score":560509,"extra":""}]}]},{"had_liked":false,"id":78945,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1553305585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70272782321","product_id":100023901,"comment_content":"如果是jvm栈空间太小了导致的栈溢出，可以通过-Xss增大栈空间大小。并且递归方法一定要有终止的return条件","like_count":16},{"had_liked":false,"id":78919,"user_name":"bing","can_delete":false,"product_type":"c1","uid":1067589,"ip_address":"","ucode":"6ADAA36B2B732C","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/45/04a13bf9.jpg","comment_is_top":false,"comment_ctime":1553300427,"is_pvip":false,"replies":[{"id":"28810","content":"全面！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553340428,"ip_address":"","comment_id":78919,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61682842571","product_id":100023901,"comment_content":"当遇到递归时，可能出现栈空间不足，出现栈溢出，再申请资源扩大栈空间，如果空间还是不足会出现内存溢出oom。<br>合理的设置栈空间大小；<br>写递归方法注意判断层次；<br>能用递归的地方大多数能改写成非递归方式。","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444289,"discussion_content":"全面！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553340428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127755,"user_name":"Thong2018","can_delete":false,"product_type":"c1","uid":1625515,"ip_address":"","ucode":"DA05A3B08D1DEA","user_header":"","comment_is_top":false,"comment_ctime":1566788463,"is_pvip":false,"replies":[{"id":"47363","content":"过奖了😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566794444,"ip_address":"","comment_id":127755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31631559535","product_id":100023901,"comment_content":"看老师讲Java并发编程的知识，让我明白了很多之前在大学里没有学明白的知识点。要是大学的专业课本也能像老师这样讲得通俗易懂而又不失深度就好了，用“大道至简”来形容老师的授课风格再好不过了","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464639,"discussion_content":"过奖了😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566794444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93152,"user_name":"crudBoy","can_delete":false,"product_type":"c1","uid":1442091,"ip_address":"","ucode":"D2C94247152ADE","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/2b/2bc4f35b.jpg","comment_is_top":false,"comment_ctime":1557408425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31622179497","product_id":100023901,"comment_content":"其实就是并发调用方法而产生的局部变量指向的内存地址都是不同的。 所以同一时刻只会有一个线程去操作这些局部变量指向的内存。","like_count":7},{"had_liked":false,"id":87749,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1555678836,"is_pvip":false,"replies":[{"id":"31567","content":"存在","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555685735,"ip_address":"","comment_id":87749,"utype":1}],"discussion_count":7,"race_medal":0,"score":"31620449908","product_id":100023901,"comment_content":"老师我有个问题：有一个方法的参数是引用类型，方法内定义了一个局部变量，在方法内将引用类型的参数赋值给该局部变量，然后再操作该局部变量会不会存在线程安全问题？比如：<br>void test(account a){<br>    account b = a;<br>    b.addMoney(100);<br>}","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447585,"discussion_content":"存在","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555685735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1468298,"avatar":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","nickname":"锦","note":"","ucode":"CB0EB4B68C468B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43463,"discussion_content":"引用类型的参数传递的是指针，所以在方法内将a赋值给b并不能解除这种引用关系，addmoney里修改的还是a引用的内存数据。\n你也可以理解成方法栈内保存的是指针，实际内存数据并没有存在栈中，所以线程不安全。\n要解决这个问题需要深度拷贝数据，并在内存中重新开辟一块空间存储拷贝后的数据。这样就互不干预了。","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1572875843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357343,"discussion_content":"感觉这个问题很好，可以继续讨论一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615789863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128084,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/94/5aecb0ef.jpg","nickname":"y3","note":"","ucode":"C93F8EC2AAACF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290663,"discussion_content":"我觉得你怎么做，应该是a对象逃逸了，所以线程不安全。不知道这样理解对不对？还请高手指教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594559927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1584787,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2e/93/029eee99.jpg","nickname":"阿维","note":"","ucode":"84CBFDBD016806","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43400,"discussion_content":"这个没看明白怎么存在线程安全的？引用参数的值赋值给局部变量后没做任何操作。多线程环境下修改的都是线程栈里面的数据。求解答？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572872093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1584787,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2e/93/029eee99.jpg","nickname":"阿维","note":"","ucode":"84CBFDBD016806","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178878,"discussion_content":"Account引用a, b 是方法内的局部变量，对引用变量a 和 b的操作是线程安全的，比如将 a引用的值赋值给 b引用，这里对a 和 b 的操作是修改这个局部引用变量的引用值，并涉及对 引用变量指向的对象进行操作。\n比如 b变量开始指向 对象1，对b赋值使b指向对象2，引用变量b的引用值发生了变化，引用的对象从对象1变成了对象2。但是对象1 本身没有任何变化。\n\n两个并发线程同时调用test()方法，请求参数为执行同一个对象X，\n虽然两个线程各自的栈帧里各有一个b变量，线程一.b 和 线程2.b。\n但是因为请求参数相同，都为对象X，所以两个线程各自的栈帧里的b变量都指向同一个Account对象，即对象X。\n线程1 执行 b.addMoney()语句，调用对象X的addMoney()方法。\n线程2 执行b.addMoney()语句，也是调用对象X的addMoney()方法。\n","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1582202413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43400,"ip_address":""},"score":178878,"extra":""},{"author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1584787,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2e/93/029eee99.jpg","nickname":"阿维","note":"","ucode":"84CBFDBD016806","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357346,"discussion_content":"因为引用类型的对象是保存在堆里的，而堆内存又是线程共享的。所以从外部传过来的引用类型确实是线程不安全的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615790127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43400,"ip_address":""},"score":357346,"extra":""}]}]},{"had_liked":false,"id":78994,"user_name":"卡西米","can_delete":false,"product_type":"c1","uid":1091178,"ip_address":"","ucode":"0E7436B2CE9BE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/a6/6a/d5cbc4e9.jpg","comment_is_top":false,"comment_ctime":1553314421,"is_pvip":false,"replies":[{"id":"28784","content":"没关系，只是原理类似","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553326049,"ip_address":"","comment_id":78994,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31618085493","product_id":100023901,"comment_content":"请教一个问题JAVA的栈跟cpu的栈有什么关系？","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444314,"discussion_content":"没关系，只是原理类似","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553326049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159417,"user_name":"文兄","can_delete":false,"product_type":"c1","uid":1529849,"ip_address":"","ucode":"596BD7DFBB9120","user_header":"https://static001.geekbang.org/account/avatar/00/17/57/f9/3eadb0fd.jpg","comment_is_top":false,"comment_ctime":1575618457,"is_pvip":false,"replies":[{"id":"62406","content":"粗略的结论是，引用传递不安全，值传递安全","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1576911027,"ip_address":"","comment_id":159417,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23050454937","product_id":100023901,"comment_content":"局部变量是线程安全的<br>对于这句话我的理解是，在方法内创建的变量是线程安全的<br>那么方法的入参，是否是线程安全的呢<br>方法的入参是对象的情况下还是否是线程安全的呢<br><br>希望有大手子答疑","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477048,"discussion_content":"粗略的结论是，引用传递不安全，值传递安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576911027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357348,"discussion_content":"Java应该可以理解为都是值传递","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615790296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113873,"user_name":"邢宇超","can_delete":false,"product_type":"c1","uid":1105246,"ip_address":"","ucode":"3113F55E60ADE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/5e/ddbdde5a.jpg","comment_is_top":false,"comment_ctime":1563177262,"is_pvip":false,"replies":[{"id":"41488","content":"堆栈寄存器指向栈顶内存地址","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1563179024,"ip_address":"","comment_id":113873,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18743046446","product_id":100023901,"comment_content":"CPU 的堆栈寄存器和栈帧什么关系  老师  求你回答一下我一个问题吧  我的问题你都没回答过","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458417,"discussion_content":"堆栈寄存器指向栈顶内存地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563179024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1304195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtlEYuHnR8VdRkNPcmkIqTM9DKahpcpicDdBvcmBWMIAAhBrd0QNWvl09slqrzB5TibryVcIfPmb7Q/132","nickname":"raisecomer","note":"","ucode":"32EA488E46471F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305419,"discussion_content":"堆栈寄存器始终指向堆栈的栈顶位置，也就是当前栈帧的栈顶位置，同时还有一个基址寄存器指向当前栈帧的栈底位置","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1599917932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2758140,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/HguBibUfNnibtGa0ibia0AX9YQSXfpSQMTicFCaHn2CUuyvACib3YdMV0pEMVwtn80uQyPfUTzmSR7qmdmNicG201Q2nA/132","nickname":"Geek_01a8d1","note":"","ucode":"2B22E43426290D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395917,"discussion_content":"大二下，汇编语言的知识！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632363686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161252,"user_name":"闲人","can_delete":false,"product_type":"c1","uid":1768152,"ip_address":"","ucode":"9A8F33260A44E1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/fa/d8/7c2b6c0b.jpg","comment_is_top":false,"comment_ctime":1576157559,"is_pvip":false,"replies":[{"id":"61608","content":"1. 不是一回事<br>2. 会<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1576318389,"ip_address":"","comment_id":161252,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14461059447","product_id":100023901,"comment_content":"老师，有两个疑问求解答：<br>1.程序计数器和CPU栈寄存器是一回事吗？<br>2.线程切换会导致CPU堆栈寄存器来回刷新吗？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477661,"discussion_content":"1. 不是一回事\n2. 会\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576318389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108084,"user_name":"杨鹏程baci","can_delete":false,"product_type":"c1","uid":1205949,"ip_address":"","ucode":"3D22F6B74340A8","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/bd/bd5d503e.jpg","comment_is_top":false,"comment_ctime":1561680861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14446582749","product_id":100023901,"comment_content":"老师好，我理解一下，您绿的例子里面线程池获取一个线程在方法体里面赋给了一个局部变量，但是从线程池获取线程的过程还是要用到锁吧，只是后面这个线程也不会被重复分配了，所以不需要加锁","like_count":3},{"had_liked":false,"id":87747,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1555678450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14440580338","product_id":100023901,"comment_content":"递归函数中的递会调用函数，递归的太深可能会引起栈溢出；<br>解决方案：<br>1、限制递归深度，超过则退出，缺点是不能确定栈的剩余空间；<br>2、使用hashmap保存重复子问题的值，以减少递归次数；<br>","like_count":3},{"had_liked":false,"id":79773,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1553556501,"is_pvip":false,"replies":[{"id":"29117","content":"局部变量线程安全，静态方法没有隐藏的this参数，执行机制和正常方法没区别<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553572277,"ip_address":"","comment_id":79773,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14438458389","product_id":100023901,"comment_content":"请教一下老师, 在静态方法中的局部变量是线程安全的吗, 静态方法的执行机制能不能也讲一下, 这里不是很理解.","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444617,"discussion_content":"局部变量线程安全，静态方法没有隐藏的this参数，执行机制和正常方法没区别\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553572277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78970,"user_name":"CCC","can_delete":false,"product_type":"c1","uid":1003738,"ip_address":"","ucode":"2E254444098267","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/da/ed4803cb.jpg","comment_is_top":false,"comment_ctime":1553311330,"is_pvip":false,"replies":[{"id":"28892","content":"你说的对，但是局部变量创建的对象，其他线程是访问不到的，因为拿不到对象的引用","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553402970,"ip_address":"","comment_id":78970,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14438213218","product_id":100023901,"comment_content":"参数和局部变量一样都是线程私有的吧，我有点不理解如果引用类型的参数被传入时，多线程同时修改这个引用类型的参数不就直接对这个参数引用的堆内存对象并发修改了嘛？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444306,"discussion_content":"你说的对，但是局部变量创建的对象，其他线程是访问不到的，因为拿不到对象的引用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553402970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326060,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3b/ec/69848c5a.jpg","nickname":"醉歌","note":"","ucode":"6789093C19A633","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587781,"discussion_content":"不是外界传入的，自身创建的，别人拿不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663292301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国台湾"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127386,"user_name":"早起的鸟儿","can_delete":false,"product_type":"c1","uid":1083332,"ip_address":"","ucode":"EDB4C51C379EE0","user_header":"https://static001.geekbang.org/account/avatar/00/10/87/c4/50c8a490.jpg","comment_is_top":false,"comment_ctime":1566691624,"is_pvip":false,"replies":[{"id":"47168","content":"局部变量安全，指向的全局变量不安全","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566712128,"ip_address":"","comment_id":127386,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10156626216","product_id":100023901,"comment_content":"老师请问如果一个局部变量的引用是指向一个全局容器里面的某个可变对象，那么该局部变量还是线程安全的吗？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464469,"discussion_content":"局部变量安全，指向的全局变量不安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566712128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79926,"user_name":"灰灰灰","can_delete":false,"product_type":"c1","uid":1042164,"ip_address":"","ucode":"519DB0429C4A80","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BDxD1k4ibAUPcljPLwgsnobjTfk2TxPTzCLps2uoGbD3HGIiaUF7XGLUnBArTyAySJzia0R6GRhroYwfyVwniaiaibzg/132","comment_is_top":false,"comment_ctime":1553575620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10143510212","product_id":100023901,"comment_content":"还是不大懂怎么定义共享变量。或者说不懂线程怎么争夺一个共享变量。","like_count":2},{"had_liked":false,"id":79412,"user_name":"Tuberose","can_delete":false,"product_type":"c1","uid":1320479,"ip_address":"","ucode":"8902B0A7FCF841","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/1f/91f980cc.jpg","comment_is_top":false,"comment_ctime":1553477875,"is_pvip":false,"replies":[{"id":"28976","content":"不安全","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553484765,"ip_address":"","comment_id":79412,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10143412467","product_id":100023901,"comment_content":"还有一点就是 静态方法是否是线程安全的？j","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444488,"discussion_content":"不安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553484765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128084,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/94/5aecb0ef.jpg","nickname":"y3","note":"","ucode":"C93F8EC2AAACF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290692,"discussion_content":"如果在静态方法中，不去写类的成员变量，应该就是线程安全的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594565798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1649057,"avatar":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","nickname":"hello","note":"","ucode":"4F42DAA5DB5C38","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1128084,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/94/5aecb0ef.jpg","nickname":"y3","note":"","ucode":"C93F8EC2AAACF6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345190,"discussion_content":"但是静态方法不应该是全局的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611678912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290692,"ip_address":""},"score":345190,"extra":""}]}]},{"had_liked":false,"id":191125,"user_name":"wkq2786130","can_delete":false,"product_type":"c1","uid":1256821,"ip_address":"","ucode":"0F3A9DF9928C67","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/75/e7c29de4.jpg","comment_is_top":false,"comment_ctime":1584747031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879714327","product_id":100023901,"comment_content":"全局变量会在栈帧里读取吗？","like_count":1},{"had_liked":false,"id":181639,"user_name":"movesan","can_delete":false,"product_type":"c1","uid":1257422,"ip_address":"","ucode":"29CDF0F2B604C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ce/c72d4c67.jpg","comment_is_top":false,"comment_ctime":1582601600,"is_pvip":false,"replies":[{"id":"71266","content":"方法参数和局部变量都是在栈里，CPU和jvm的栈你可以类比原理，没有直接关系，jvm有自己的指令集和执行器","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1583236514,"ip_address":"","comment_id":181639,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877568896","product_id":100023901,"comment_content":"我的理解是 JVM 也是内存中规划出来的结构吧，也是属于内存的一部分，所以说 JVM 中的调用栈应该都是存在于内存中；<br>但是最终都会被编译成计算机指令，CPU 调用的时候是依赖于自己寄存器中的栈结构。<br>请问老师，我这样理解对吗？如果对的话，方法参数和局部变量也会被编译到寄存器中吗，那这样应该放不下吧，CPU 寄存器中的栈和 JVM 中的方法栈是否有联系呢？感谢老师回答","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485062,"discussion_content":"方法参数和局部变量都是在栈里，CPU和jvm的栈你可以类比原理，没有直接关系，jvm有自己的指令集和执行器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583236514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150060,"user_name":"朕爱吾妃","can_delete":false,"product_type":"c1","uid":1733692,"ip_address":"","ucode":"B10EB69934F9E2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/74/3c/da79d2a1.jpg","comment_is_top":false,"comment_ctime":1573456192,"is_pvip":false,"replies":[{"id":"57782","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573477557,"ip_address":"","comment_id":150060,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868423488","product_id":100023901,"comment_content":"每一次递归到一个方法上时，就会在有一个入栈的操作，当方法执行结束，就会有出栈，当递归过多的时候，就会有很多入栈的操作而没有出栈的操作，造成栈容量越来越大，而栈内每一个变量引用都是需要占用内存的，也就说明栈是有大小的，所以，当超出了栈最大容量的时候，就会造成栈溢出的情况的，这就是原因所在。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474053,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573477557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148112,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1572943015,"is_pvip":false,"replies":[{"id":"57078","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1572955130,"ip_address":"","comment_id":148112,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5867910311","product_id":100023901,"comment_content":"递归调用如果没有结束条件，或者结束条件永远达不到，则会造成永久循环调用，而每次递归调用都是创建一个新的栈帧，会造成栈帧数超过系统最大值，造成栈溢出。在Java中会抛出以下错误：Exception in thread &quot;main&quot; java.lang.StackOverflowError","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473400,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572955130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1507783,"avatar":"https://static001.geekbang.org/account/avatar/00/17/01/c7/549b5616.jpg","nickname":"夜涛","note":"","ucode":"672CC53663710B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309699,"discussion_content":"java.lang.StackOverflowError这个错误和oom总是混淆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601390982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110052,"user_name":"000","can_delete":false,"product_type":"c1","uid":1052192,"ip_address":"","ucode":"98A810FA164106","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/20/4a8eb862.jpg","comment_is_top":false,"comment_ctime":1562160951,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5857128247","product_id":100023901,"comment_content":"每次递归就创建一个栈桢，没控制好结束，会导致栈空间溢出","like_count":1},{"had_liked":false,"id":87689,"user_name":"JensonYao","can_delete":false,"product_type":"c1","uid":1499730,"ip_address":"","ucode":"D4A9765F1112BD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erQ5LXNgaZ3ReArPrY4YeT5mNVtBpiazFEQzNuUXxzdLOWtMliaGicNCpjaOezRISARHXPibkA4ACgib1g/132","comment_is_top":false,"comment_ctime":1555660893,"is_pvip":false,"replies":[{"id":"31544","content":"你有收获也是对我最大的鼓励😃<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555675349,"ip_address":"","comment_id":87689,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850628189","product_id":100023901,"comment_content":"非常形象的解释了堆和栈的区别，又带着复习了一遍基础知识，每一次看都有不一样的认知！谢谢老师！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447562,"discussion_content":"你有收获也是对我最大的鼓励😃\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555675349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81576,"user_name":"易水寒","can_delete":false,"product_type":"c1","uid":1238961,"ip_address":"","ucode":"F5D8127ED4754E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/b1/5c63be67.jpg","comment_is_top":false,"comment_ctime":1553951835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848919131","product_id":100023901,"comment_content":"递归可能导致栈溢出，基本上都知道原因，这里说下个人对于如何避免的浅见：<br>1.递归基本上都可改写成循环方式<br>2.限制递归层次<br>3.其实和1是一个道理，模拟栈结构","like_count":1},{"had_liked":false,"id":79176,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1553395849,"is_pvip":false,"replies":[{"id":"28894","content":"放到threadlocal里说这个事情吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553403284,"ip_address":"","comment_id":79176,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848363145","product_id":100023901,"comment_content":"线程封闭：jdbcConnection 如何保证线程封闭这块方便老师具体讲解下吗~","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444383,"discussion_content":"放到threadlocal里说这个事情吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553403284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79139,"user_name":"senekis","can_delete":false,"product_type":"c1","uid":1446025,"ip_address":"","ucode":"CD88681F0278FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erTlRJ6skf7iawAeqNfIT1PPgjD7swUdRIRkX1iczjj97GNrxnsnn3QuOhkVbCLgFYAm7sMZficNTSbA/132","comment_is_top":false,"comment_ctime":1553380163,"is_pvip":true,"replies":[{"id":"28855","content":"我也跟你一样曾经有那么多疑问<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553388213,"ip_address":"","comment_id":79139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848347459","product_id":100023901,"comment_content":"感动！老师讲的太好了，每次的新文章，都解答了我在以前学习中所留下的许多疑问！<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444369,"discussion_content":"我也跟你一样曾经有那么多疑问\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553388213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78997,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1553315292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848282588","product_id":100023901,"comment_content":"老师抛砖引玉的学习方法我觉得非常好，十分清楚的弄懂了本文全部内容，而且十分易懂。<br>课后问题：递归调用太深会在创建过多的调用栈，也就是会创建过多栈帧，导致栈溢出，但是递归方法写起来简单，但会出现以上问题，解决办法可以改成非递归写法，自己手动维护个栈","like_count":1},{"had_liked":false,"id":348612,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1655255314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655255314","product_id":100023901,"comment_content":"1.栈溢出发生在方法调用<br>如果是单线程，每个方法中变量过多，每个栈帧占用内存过大，能分配的栈帧数也就有限，当递归深度过大，自然就出现溢出。<br>2.多线程创建<br>每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。也会栈溢出。<br><br>解决方法：<br>一种可以通过jvm参数调大非堆内存，JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1&#47;64；由-XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1&#47;4<br>-Xss1024k ：设置每个线程的堆栈大小为1024K。<br>","like_count":0},{"had_liked":false,"id":347716,"user_name":"Geek5530","can_delete":false,"product_type":"c1","uid":2961314,"ip_address":"","ucode":"D6E6C15F6C5531","user_header":"","comment_is_top":false,"comment_ctime":1654342066,"is_pvip":false,"replies":[{"id":"126843","content":"不区分","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1654748273,"ip_address":"","comment_id":347716,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1654342066","product_id":100023901,"comment_content":"老师，有个问题请教下，这里的局部变量是不是不区分是基本数据类型还是引用型","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575325,"discussion_content":"不区分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654748273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341036,"user_name":"龙行天下","can_delete":false,"product_type":"c1","uid":1231302,"ip_address":"","ucode":"90BEED7A164ADE","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/c6/16136ab3.jpg","comment_is_top":false,"comment_ctime":1649305319,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649305319","product_id":100023901,"comment_content":"局部变量逃逸后也不安全","like_count":0},{"had_liked":false,"id":337627,"user_name":"蝴蝶","can_delete":false,"product_type":"c1","uid":1193167,"ip_address":"","ucode":"8019924D99182F","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","comment_is_top":false,"comment_ctime":1646921456,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646921456","product_id":100023901,"comment_content":"我是这样理解的：局部变量（指的引用对象）安全的原因是，它虽然指向堆里面的对象，但是它仅仅是在栈帧中使用，外部线程没有使用，所以安全。","like_count":1},{"had_liked":false,"id":326541,"user_name":"helloWorld","can_delete":false,"product_type":"c1","uid":2793822,"ip_address":"","ucode":"E7D28A9F456959","user_header":"https://static001.geekbang.org/account/avatar/00/2a/a1/5e/4c53cb49.jpg","comment_is_top":false,"comment_ctime":1639556560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639556560","product_id":100023901,"comment_content":"递归即不断的调用方法，调用方法就必定要不断将栈帧压入调用栈，栈有空间限制，如果递归太深就会栈溢出","like_count":0},{"had_liked":false,"id":326080,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1639366828,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639366828","product_id":100023901,"comment_content":"线程在执行方法时，本身会创建一个栈帧用于存放局部变量、动态链接、返回地址等数据结构。而递归调用通常不会指定执行次数 只会指定递归出口。那么问题就来了 <br>1.首先栈帧因为是紧贴本函数执行地址 所以会在其下方创建栈帧并塞入栈寄存器<br>2.无故创建过多栈帧（函数调用专用数据结构） 会导致线程栈空间迅速耗尽，最后导致栈溢出","like_count":0},{"had_liked":false,"id":315178,"user_name":"官宝儿","can_delete":false,"product_type":"c1","uid":2110827,"ip_address":"","ucode":"03B4312475A984","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5eicXFWltiaF9ibsEh2nNC80OYoHibhhE0X1hPHZ5KuAtY4Yxp5dQ4LsciaDxUHFBPlJM7kgQwkspzsQ/132","comment_is_top":false,"comment_ctime":1633742665,"is_pvip":false,"replies":[{"id":"114500","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1634123269,"ip_address":"","comment_id":315178,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633742665","product_id":100023901,"comment_content":"又看完一章老老实实回答问题，分享所得，老师文章所述，程序运行中在jvm内部会有方法调用栈，在方法被调用时会创建栈帧，递归的过程中会不停的调用方法，不停的递归以为这栈帧不停的增长，达到栈的上限时，就会发生堆栈溢出异常了。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527891,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634123269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313861,"user_name":"蒋波","can_delete":false,"product_type":"c1","uid":1526325,"ip_address":"","ucode":"611A1F0629F08E","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/35/16861bf8.jpg","comment_is_top":false,"comment_ctime":1632720891,"is_pvip":false,"replies":[{"id":"113646","content":"指向的对象如果不是局部变量，就要考虑并发问题。获取，修改都要考虑并发问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1632744925,"ip_address":"","comment_id":313861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632720891","product_id":100023901,"comment_content":"徐老师您好，局部变量都是线程私有，但是变量指向的数据是同一条数据，或者对象是同一个对象，我们应该怎么思考这个问题呢？我是不是也应该考虑并发问题，但是应该在获取这个数据或者对象阶段考虑并发问题，是吗，希望老师给指点迷津，没有共享就没有并发问题，这句话具体落到实处应该怎么思考太迷惑了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527495,"discussion_content":"指向的对象如果不是局部变量，就要考虑并发问题。获取，修改都要考虑并发问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632744925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311292,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1631157336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631157336","product_id":100023901,"comment_content":"<br><br>1 为保证方法的调用次序，方法的执行过程用到了 栈结构，方法的参数和返回地址都在相应的栈帧里。<br>2 每个线程都有自己的栈帧，所以局部变量不会出现并发问题。","like_count":0},{"had_liked":false,"id":310038,"user_name":"xuwen_chen","can_delete":false,"product_type":"c1","uid":1840097,"ip_address":"","ucode":"03C766DEA69DF1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJq1QledRhFicNMRYDJ1ibCveUqlrtIYhDCvAicOmmnia3GPrjjepDZhibXMJ0iabTsibVC2KMZtoIG4A9icg/132","comment_is_top":false,"comment_ctime":1630464524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630464524","product_id":100023901,"comment_content":"因为栈空间是线程独立的，每个线程都有自己的线程栈，一次方法调用的过程就对应栈桢压入和弹出的过程，每个栈桢都维护了当前方法的局部变量表，确保了变量只在当前线程使用，不共享","like_count":0},{"had_liked":false,"id":287457,"user_name":"RoccoLee","can_delete":false,"product_type":"c1","uid":2508667,"ip_address":"","ucode":"C55AD67FF8C2D7","user_header":"https://static001.geekbang.org/account/avatar/00/26/47/7b/c5ec018c.jpg","comment_is_top":false,"comment_ctime":1617957742,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1617957742","product_id":100023901,"comment_content":"课后思考：栈溢出的原因两种：一种是线程请求的栈深度大于栈的要求的深度；还有一种是局部变量太多，导致栈帧太大，大于栈空间的内存，无法被入栈。<br>解决：1.可以减少堆或方法区的内存大小；2.代码设好递归终止条件，减少请求栈的深度","like_count":0},{"had_liked":false,"id":287351,"user_name":"飞白","can_delete":false,"product_type":"c1","uid":1926642,"ip_address":"","ucode":"2586407256F3B3","user_header":"https://static001.geekbang.org/account/avatar/00/1d/65/f2/24e48aae.jpg","comment_is_top":false,"comment_ctime":1617895900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617895900","product_id":100023901,"comment_content":"想请教老师一个问题，JVM中的虚拟机栈，跟CPU堆栈寄存器的关系是什么样的。虚拟机栈通过-Xss指定大小，那理解上也是属于主内存区域吧？所以JVM是通过内存模拟堆栈寄存器的功能？","like_count":0},{"had_liked":false,"id":285574,"user_name":"时光守护者-基兰","can_delete":false,"product_type":"c1","uid":1554995,"ip_address":"","ucode":"F0B0887B1979D2","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","comment_is_top":false,"comment_ctime":1616903276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616903276","product_id":100023901,"comment_content":"1.限制递归次数<br>2.有些场景可以使用哈希表，比如请求参数一样返回结果一样时不需要重复调用","like_count":0},{"had_liked":false,"id":284650,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1616403114,"is_pvip":false,"replies":[{"id":"103330","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1616499573,"ip_address":"","comment_id":284650,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616403114","product_id":100023901,"comment_content":"递归创建的调用栈太多的原因，尤其递归方法内有大量内部变量时。一方面，尽量减少栈内部的变量占用；另一方面，对调用递归的条件作出限制，防止无限递归或太多层次的递归。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517418,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616499573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280376,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1614172755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614172755","product_id":100023901,"comment_content":"递归调用太深，栈溢出的原因还是在于方法调用栈的栈帧，每个栈帧的存在都占用一定的内存空间，调用太深后，栈中就会有很多栈帧存在，内存大小又是有限的，所以就会导致栈溢出。最好的解决方案就是在递归调用时，一定要有终止条件和返回值，一般通过返回值来判断其是否需要终止，还可以使用非递归实现","like_count":0},{"had_liked":false,"id":280158,"user_name":"马文龙","can_delete":false,"product_type":"c1","uid":1068432,"ip_address":"","ucode":"679B0F0AB402C7","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/90/25b6f544.jpg","comment_is_top":false,"comment_ctime":1614099031,"is_pvip":true,"replies":[{"id":"101950","content":"Threadlocal，后面有介绍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1614422531,"ip_address":"","comment_id":280158,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1614099031","product_id":100023901,"comment_content":"王老师，您好！<br>数据库连接池通过线程封闭技术，保证一个 Connection 一旦被一个线程获取之后，在这个线程关闭 Connection 之前的这段时间里，不会再分配给其他线程，从而保证了 Connection 不会有并发问题<br>用什么技术实现的，代码示例能举例吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516001,"discussion_content":"Threadlocal，后面有介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614422531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272203,"user_name":"耶low","can_delete":false,"product_type":"c1","uid":1992059,"ip_address":"","ucode":"4CCEB741583544","user_header":"https://static001.geekbang.org/account/avatar/00/1e/65/7b/058d17f3.jpg","comment_is_top":false,"comment_ctime":1609988569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609988569","product_id":100023901,"comment_content":"总结部分值得学习，也许这就是大佬的境界吧。融会贯通，举一反三😂","like_count":0},{"had_liked":false,"id":251183,"user_name":"夜涛","can_delete":false,"product_type":"c1","uid":1507783,"ip_address":"","ucode":"672CC53663710B","user_header":"https://static001.geekbang.org/account/avatar/00/17/01/c7/549b5616.jpg","comment_is_top":false,"comment_ctime":1601390567,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601390567","product_id":100023901,"comment_content":"我觉得这篇应该结合JVM的内存模型一起来讲，这样深度可以解释下虚拟机栈为啥是线程私有，还有局部变量在调用栈里也不完全对，局部变量在Java中有基本类型和对象，对象只有引用放在调用栈，new xx还是在堆里，不然栈一下就爆了。回答下思考题：递归方法如没有出口，一直递归会导致栈大小使用完，直接溢出，这种情况可以用一个变量跟随调用一次+1，限制调用深度，之前一个问题就是这样改进。","like_count":0},{"had_liked":false,"id":249643,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1600738945,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1600738945","product_id":100023901,"comment_content":"1、为什么局部变量是线程安全的：方法的执行是通过jvm堆栈来实现，方法执行会创建一个栈帧压入栈中，而每个线程有自己的调用堆栈，多线程之间相互独立，局部变量是属于方法内部的，也就是在栈帧里面，自然就不会有线程安全问题了。<br>2、递归调用，每次递归调用都新建栈帧后压入栈，老的栈帧还在，而栈的大小又是有限制的，递归层次深了自然就栈溢出了。解决方法可以很多，限制递归调用深度，或通过其它算法实现","like_count":0},{"had_liked":false,"id":242071,"user_name":"prepared","can_delete":false,"product_type":"c1","uid":1194853,"ip_address":"","ucode":"00E54A5C7CDCBE","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","comment_is_top":false,"comment_ctime":1597583454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597583454","product_id":100023901,"comment_content":"参数和局部变量都需要入栈，递归调用，递归深入越深，栈内参数、局部变量等越多，就可能会导致栈溢出","like_count":0},{"had_liked":false,"id":236209,"user_name":"idea","can_delete":false,"product_type":"c1","uid":1252848,"ip_address":"","ucode":"621921030982C0","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/f0/59702429.jpg","comment_is_top":false,"comment_ctime":1595345548,"is_pvip":false,"replies":[{"id":"94097","content":"非常正确","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1604407155,"ip_address":"","comment_id":236209,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595345548","product_id":100023901,"comment_content":"调用层数过深，会导致我们创建栈一直在增加而没有弹出释放，每个线程所分配的栈空间都是有限的，当调用次数超过瓶颈的时候就会爆出栈溢出的问题。而且同理可以推断，当我们的参数变量过多的时候，栈帧的空间会不足而出现异常。 老师我的这个理解正确吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501983,"discussion_content":"非常正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604407155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224344,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1591348879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591348879","product_id":100023901,"comment_content":"递归太深栈溢出：<br>类加载后，方法需要栈深度就确定了，是在编译阶段确定的，当线程请求的栈深度(递归调用太深)大于虚拟机所允许的深度，就会导致栈溢出。虽然jvm对栈的深度支持动态扩展，当扩展时无法申请到足够的内存时，就会内存溢出而不是栈溢出；","like_count":0},{"had_liked":false,"id":223926,"user_name":"Autom","can_delete":false,"product_type":"c1","uid":1309819,"ip_address":"","ucode":"AFEA394264CDAC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcZh2daicchElHxuLLZrQ6gZKY5ErPg8NDzXLGHicxnWQAolgPAZLKbp48Kv2VfGw9Z5It6K6ZZqlA/132","comment_is_top":false,"comment_ctime":1591233332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591233332","product_id":100023901,"comment_content":"数据库连接池通过线程封闭技术，保证一个 Connection 一旦被一个线程获取之后，在这个线程关闭 Connection 之前的这段时间里，不会再分配给其他线程。<br>不太理解这段话的意思，连接池和线程封闭又有什么关系呢？","like_count":0},{"had_liked":false,"id":209826,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1587620984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587620984","product_id":100023901,"comment_content":"原因：栈就像弹夹，总有装满的时候，当装满了子弹继续往里装就报栈内存溢出了<br>解决：尽量不适用递归，且递归效率极低的","like_count":0},{"had_liked":false,"id":208490,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1587369410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587369410","product_id":100023901,"comment_content":"思考题，1通过设置调大栈帧内存，2添加递归深度判断，超过深度，抛出异常","like_count":0},{"had_liked":false,"id":207157,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1587018209,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587018209","product_id":100023901,"comment_content":"在一个方法内的创建的新对象(new Object&#47;array) A ,  虽然这个对象保存在java 堆中, 但它的引用仅仅保存在这个线程的栈帧中, 其他线程不能获取到这个对象 A 的引用, 就不存在变量的共享了, 自然就 &quot;安全&quot; 了<br>说一个局部变量线程安全, 总感觉怪怪的,  线程安全一般应当指函数&#47;方法, 而不是指局部变量<br>可以参考 jvm 规范, 每个thread 都有一个 stack , 这个 stack 中保存着 栈帧 frames <br>https:&#47;&#47;docs.oracle.com&#47;javase&#47;specs&#47;jvms&#47;se8&#47;html&#47;jvms-2.html#jvms-2.5.2","like_count":0},{"had_liked":false,"id":204088,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1586331121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586331121","product_id":100023901,"comment_content":"由于每个线程的占空间大小都是固定的，比较小。如果递归调用层次比较深，则可能出现栈溢出的问题。解决方法就是少递归，即使递归也可以考虑提前结束递归的“尾递归”。","like_count":0},{"had_liked":false,"id":191642,"user_name":"zhangchao","can_delete":false,"product_type":"c1","uid":1508339,"ip_address":"","ucode":"E665D153A85DE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/f3/0bd094ad.jpg","comment_is_top":false,"comment_ctime":1584786402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584786402","product_id":100023901,"comment_content":"深入浅出","like_count":0},{"had_liked":false,"id":186493,"user_name":"Daiver","can_delete":false,"product_type":"c1","uid":1466447,"ip_address":"","ucode":"9B1A03AFBC79BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","comment_is_top":false,"comment_ctime":1583853168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583853168","product_id":100023901,"comment_content":"变递归为伪递归","like_count":0},{"had_liked":false,"id":175721,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1580807752,"is_pvip":false,"replies":[{"id":"68299","content":"方法结束变量能回收就没问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1580820656,"ip_address":"","comment_id":175721,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580807752","product_id":100023901,"comment_content":"老师问个问题 您说new出来的对象在堆里  但是在方法里new 出来的变量  应该是在堆里 但是应该不会产生线程安全问题吧  ","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482870,"discussion_content":"方法结束变量能回收就没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580820656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166591,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1577511374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577511374","product_id":100023901,"comment_content":"老师你的推断一般指的是什么推断呢？能否举个例子","like_count":0},{"had_liked":false,"id":150473,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1573542210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573542210","product_id":100023901,"comment_content":"老师的讲解行云流水，重剑无锋，享受","like_count":0},{"had_liked":false,"id":134595,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1568876050,"is_pvip":true,"replies":[{"id":"51654","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568896026,"ip_address":"","comment_id":134595,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568876050","product_id":100023901,"comment_content":"栈溢出的原因是没限制最大深度，在一个有限大小的栈空间中，每次就算申请微小的栈帧，早晚也会爆炸，解决思路有两个吧：<br>1、治标：预防溢出，可以限制深度，备忘录等<br>2、治本：用非递归的代码来实现递归的思路<br>最后有个问题，局部变量不存在并发问题，好像和Fork&#47;Join思路蛮相似的，都是在无关共享资源的前提下实现并发，没用共享，也就没用太多的问题了。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467821,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568896026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130640,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1567499447,"is_pvip":false,"replies":[{"id":"48864","content":"操作系统会占用1～2G的地址空间","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567501621,"ip_address":"","comment_id":130640,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567499447","product_id":100023901,"comment_content":"jvm有个参数，-Xss来表示一个栈的默认大小, 对于32位的jvm大约是0.5mb；而地址空间是有限的，比如32位的，最多就是2^32 =4g；这两个除一下 4g&#47;0.5mb=2^13，也就是最多有8192个递归调用。<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466044,"discussion_content":"操作系统会占用1～2G的地址空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567501621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1097836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","nickname":"随心而至","note":"","ucode":"31866865255101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7370,"discussion_content":"嗯嗯，这边计算的是最大理论值～～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567501799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114992,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1563445309,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1563445309","product_id":100023901,"comment_content":"老师 一个小问题 就是每个线程都有自己的调用栈 那这些调用栈是不是都存放在jvm运行时数据区的java栈空间里？","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380282,"discussion_content":"是的，在java虚拟机栈中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624425878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108191,"user_name":"古夜","can_delete":false,"product_type":"c1","uid":1341612,"ip_address":"","ucode":"0A82D3CFCEDF07","user_header":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","comment_is_top":false,"comment_ctime":1561693115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561693115","product_id":100023901,"comment_content":"请教一下老师<br>JAVA中StringBuilder实体打印，重写tostring时使用new stringbuilder，据说也是线程不安全的，那是否需要实现线程安全呢？","like_count":0},{"had_liked":false,"id":102564,"user_name":"zws","can_delete":false,"product_type":"c1","uid":1240091,"ip_address":"","ucode":"18EC6E85F3431E","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/1b/650e3dbe.jpg","comment_is_top":false,"comment_ctime":1560252944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560252944","product_id":100023901,"comment_content":"volatie 一般和 cas配合可以实现自旋锁","like_count":0},{"had_liked":false,"id":96119,"user_name":"0928","can_delete":false,"product_type":"c1","uid":1240990,"ip_address":"","ucode":"03221745CF8141","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/9e/78420b67.jpg","comment_is_top":false,"comment_ctime":1558336652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558336652","product_id":100023901,"comment_content":"只要不存在共享变量，不论是普通方法、静态方法、单例模式中的方法都是线程安全的。","like_count":0},{"had_liked":false,"id":86137,"user_name":"悠哉小二儿","can_delete":false,"product_type":"c1","uid":1060386,"ip_address":"","ucode":"BBF857A9021E42","user_header":"https://static001.geekbang.org/account/avatar/00/10/2e/22/75814530.jpg","comment_is_top":false,"comment_ctime":1555313428,"is_pvip":false,"replies":[{"id":"30919","content":"安全，都是局部变量<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555324235,"ip_address":"","comment_id":86137,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555313428","product_id":100023901,"comment_content":"老师test06被多线程执行。list06是否安全。<br>    public void test06(Long id) {<br>        &#47;&#47;去计算<br>        List list06 = test06_1(id);<br>        <br>        &#47;&#47;返回结果。list06是否安全?<br><br>    }<br><br>    private List test06_1(Long id) {<br>        List list06_1 = new ArrayList();<br>        &#47;&#47;业务执行。。。。<br>        return test06_2(list06_1);<br>    }<br><br>    private List test06_2(List list06_1) {<br>        List list = new ArrayList();<br>        &#47;&#47;业务执行。。。。<br>        list.addAll(list06_1);<br><br>        return list;<br>    }<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446894,"discussion_content":"安全，都是局部变量\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555324235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84039,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1316843,"ip_address":"","ucode":"7D440AFAA78678","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/eb/8bfd69b0.jpg","comment_is_top":false,"comment_ctime":1554772625,"is_pvip":false,"replies":[{"id":"30396","content":"就是解释为什么它不会共享😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554820666,"ip_address":"","comment_id":84039,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554772625","product_id":100023901,"comment_content":"老师用的例子每个线程调用该方法时都会new一个数组，所以每个线程都会访问不同的数组并不会共享数组啊。是不是可以换个例子呢🙈","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446226,"discussion_content":"就是解释为什么它不会共享😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554820666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80188,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1553615666,"is_pvip":false,"replies":[{"id":"29223","content":"java是解释执行的，所以java的栈和cpu的栈不是一回事，他们没有直接关系，仅仅是原理相通<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553645294,"ip_address":"","comment_id":80188,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553615666","product_id":100023901,"comment_content":"老师，有些疑惑的点，cpu是通过堆栈寄存器来调用方法，我们以java语言的调用来说，方法调用也是基于堆栈，一个方法在线程中的调用，就会将其方法的栈帧（参数，局部变量，返回地址）入栈，然后这些栈是在java虚拟机中，然后将其栈写到cpu堆栈寄存器调用吗？整体的流程不是很清楚，老师帮忙解答下哦","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444778,"discussion_content":"java是解释执行的，所以java的栈和cpu的栈不是一回事，他们没有直接关系，仅仅是原理相通\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553645294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79845,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1553563537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553563537","product_id":100023901,"comment_content":"解决递归调用太深:记录递归调用次数，达到某一深度后直接返回，退出递归。","like_count":0},{"had_liked":false,"id":79839,"user_name":"alias cd=rm -rf","can_delete":false,"product_type":"c1","uid":1318325,"ip_address":"","ucode":"E7B27D76305B75","user_header":"https://static001.geekbang.org/account/avatar/00/14/1d/b5/971261fd.jpg","comment_is_top":false,"comment_ctime":1553562514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553562514","product_id":100023901,"comment_content":"思考题<br>原因是递归方法在遇到递归结果之前，会一直把方法作为栈贞压入线程的调用栈。最终导致栈溢出。<br>解决方法<br>增加递归深度的限制。","like_count":0},{"had_liked":false,"id":79438,"user_name":"悟空","can_delete":false,"product_type":"c1","uid":1451125,"ip_address":"","ucode":"F9DFBA74B35B40","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/75/808ac160.jpg","comment_is_top":false,"comment_ctime":1553483921,"is_pvip":false,"replies":[{"id":"29002","content":"我是想让大家能推演程序的执行过程😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553516165,"ip_address":"","comment_id":79438,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553483921","product_id":100023901,"comment_content":"思考为什么讲这章，分析因为本节中带过了一种解决互斥的办法。不共享去解决互斥。这种也会有个问题。线程多，资源多，需要及时销毁。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444499,"discussion_content":"我是想让大家能推演程序的执行过程😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553516165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79432,"user_name":"悟空","can_delete":false,"product_type":"c1","uid":1451125,"ip_address":"","ucode":"F9DFBA74B35B40","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/75/808ac160.jpg","comment_is_top":false,"comment_ctime":1553483679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553483679","product_id":100023901,"comment_content":"首先，递归是单线程执行，所以引起的空间变化实在单线程的堆栈里发生的。<br>其次，因为递归会不断调用方法，每次调用方法会重新在当前堆栈开辟新的地址。所以堆栈地址会越来越多。<br><br>递归是我一直没想明白的一种思考方式。查看网上说。用数学验证，第一次成功，那么说明第n次成功，如果能验证出n+1次也成功。说明正确。递归也是基于这个原理思考。<br><br>那实际哪些问题能抽象成递归，能用递归解决？如何写代码？是我困惑的","like_count":0},{"had_liked":false,"id":79426,"user_name":"Vickygu","can_delete":false,"product_type":"c1","uid":1371330,"ip_address":"","ucode":"85E3C158EF6B6F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLUdGtTfe4kBzS6EwvyNkqBGZpKE0vpic8zgZXgoJE3pgHfa2iaulictROn3NsICbZOjz1ELybdf5P6g/132","comment_is_top":false,"comment_ctime":1553482415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553482415","product_id":100023901,"comment_content":"递归回造成栈溢出，是因为递归在不停的反复调用函数，即创建栈帧，栈帧数量过大就会导致栈溢出。<br>解决方法：<br>在设计递归的时候先要估算一个下大约的调用次数，以此来设置栈的大小，并设置递归的一个防溢出阈值来作为最后的手段。","like_count":0},{"had_liked":false,"id":79409,"user_name":"影子传说","can_delete":false,"product_type":"c1","uid":1031636,"ip_address":"","ucode":"371B72BB5CCB5E","user_header":"","comment_is_top":false,"comment_ctime":1553477368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553477368","product_id":100023901,"comment_content":"栈溢出是因为函数递归调用会不听的压栈，导致栈膨胀。而栈的内存是有限的。解决办法:将递归改为循环，或者改造成尾递归。","like_count":0},{"had_liked":false,"id":79391,"user_name":"果然如此","can_delete":false,"product_type":"c1","uid":1210003,"ip_address":"","ucode":"C7543BD0A67505","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","comment_is_top":false,"comment_ctime":1553473999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553473999","product_id":100023901,"comment_content":"由于递归对内存可能溢出，我一直对递归有辩证的看法。数据库中的表索引算法应该不是递归吧？","like_count":0},{"had_liked":false,"id":79315,"user_name":"codefire","can_delete":false,"product_type":"c1","uid":1066247,"ip_address":"","ucode":"8022698D62AB53","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/07/69e486e1.jpg","comment_is_top":false,"comment_ctime":1553433976,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1553433976","product_id":100023901,"comment_content":"Scala项目中经常使用尾递归，解决递归深度问题。","like_count":0},{"had_liked":false,"id":79274,"user_name":"乐凡","can_delete":false,"product_type":"c1","uid":1239260,"ip_address":"","ucode":"918C9997EB6537","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/dc/32e78f02.jpg","comment_is_top":false,"comment_ctime":1553422276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553422276","product_id":100023901,"comment_content":"因为递归就是调用方法中调用本身方法，一次方法调用在调用栈中生成一个栈帧，当调用次数过多，栈帧过多导致栈溢出。解决办法是设置一个全局变量标识作为临界值，每次调用前判断是否到了临界值，到了就退出，否则就加1并往下递归。","like_count":0},{"had_liked":false,"id":79146,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1553386342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553386342","product_id":100023901,"comment_content":"这个问题，刚好再看jvm的时候提到过。每个栈都有自己的大小，可以在启动的时候自己配置。而jvm运行的空间，就是堆，方法区，栈，本地方法栈。栈的总空间就是。总空间-堆-方法区。如果栈的空间设置过大，还没有入栈几次，很快就溢出了。","like_count":0},{"had_liked":false,"id":79128,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1553360205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553360205","product_id":100023901,"comment_content":"这个点来打卡，看的似懂非懂，明天继续看，栈、调用栈、栈帧这些概念之前都学过，在耗子叔的专栏也学过，甚至看了他给出的好多链接的英文资料，现在又忘了，感觉基础差了什么都学不好。","like_count":0},{"had_liked":false,"id":79077,"user_name":"龙哥","can_delete":false,"product_type":"c1","uid":1451669,"ip_address":"","ucode":"E7ED2E7DF759A1","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/95/a4e0f7ab.jpg","comment_is_top":false,"comment_ctime":1553344840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553344840","product_id":100023901,"comment_content":"递归每次调用都将方法压入调用栈中，也就是说如果递归调用了n次，调用栈里就有n个元素，所以容易造成溢出。<br>建议有以下优化方案:<br>1.改递归为循环，这样就在一个栈帧内执行。<br>2.一般采用递归都有规律可寻，可以采用数学归纳法，进行算法优化。<br>3.如果万不得已，设置递归的边界，如超出设定的边界则不允许调用。<br><br>一般采取前两个方案。不知还有没有新的方案。","like_count":0},{"had_liked":false,"id":79073,"user_name":"橘子","can_delete":false,"product_type":"c1","uid":1368522,"ip_address":"","ucode":"EDF6145878F897","user_header":"https://static001.geekbang.org/account/avatar/00/14/e1/ca/d8b0835f.jpg","comment_is_top":false,"comment_ctime":1553343784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553343784","product_id":100023901,"comment_content":"无状态的一定是线程安全的。<br><br>斐波那契这样的其实可以用缓存<br>因为这个有太多的重复计算<br>其实大多数应该都可以，<br>如果要封闭在当前线程中，可以使用ThreadLocal这个类来实现缓存的线程封闭<br>","like_count":0},{"had_liked":false,"id":79067,"user_name":"___","can_delete":false,"product_type":"c1","uid":1229519,"ip_address":"","ucode":"B0BA5A1413798C","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/cf/573a0fdc.jpg","comment_is_top":false,"comment_ctime":1553340038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553340038","product_id":100023901,"comment_content":"cpu的堆栈寄存器大小有限，递归通过重复调用自身函数，是入栈操作，没达到递归结束条件，不会有出栈操作，导致寄存器没有更多空间来存放下一个栈帧，程序奔溃。<br><br>如何解决<br>看了评论，尾递归不是很清楚，暂时放弃~~~<br>1. 递归改循环，这样只占用一个栈帧","like_count":0},{"had_liked":false,"id":79060,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1553335453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553335453","product_id":100023901,"comment_content":"快更","like_count":0},{"had_liked":false,"id":79051,"user_name":"小黄","can_delete":false,"product_type":"c1","uid":1049839,"ip_address":"","ucode":"519BF8191D3A6B","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/ef/fea0fdbd.jpg","comment_is_top":false,"comment_ctime":1553332557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553332557","product_id":100023901,"comment_content":"调大线程内存ss ，减少单个线程内存开销，就能增加深度。但每个操作系统对线程开销也不一致","like_count":0},{"had_liked":false,"id":79037,"user_name":"那就这样吧","can_delete":false,"product_type":"c1","uid":1327343,"ip_address":"","ucode":"A1315C5EAF2917","user_header":"https://static001.geekbang.org/account/avatar/00/14/40/ef/52bbadb9.jpg","comment_is_top":false,"comment_ctime":1553328797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553328797","product_id":100023901,"comment_content":"有种触类旁通的感觉，通过老师的讲解，可以联想到Java虚拟机栈，又加深了理解。<br>思考题：每个方法分配的栈空间是有限的，当递归调用太深，自然会导致栈空间不足，溢出。<br>所以解决方法就是控制递归次数。","like_count":0},{"had_liked":false,"id":78995,"user_name":"aksonic","can_delete":false,"product_type":"c1","uid":1003633,"ip_address":"","ucode":"B6F3348F6714DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/71/e8229703.jpg","comment_is_top":false,"comment_ctime":1553314747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553314747","product_id":100023901,"comment_content":"通过代码限制递归调用深度<br><br>&#47;&#47; 全局变量，表示递归的深度。<br>int depth = 0;<br><br>int f(int n) {<br>  ++depth；<br>  if (depth &gt; 1000) throw exception;<br>  <br>  if (n == 1) return 1;<br>  return f(n-1) + 1;<br>}<br>","like_count":0},{"had_liked":false,"id":78987,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1553313302,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1553313302","product_id":100023901,"comment_content":"1.栈的大小没记错的话是在jvm启动时就确定的，递归调用太深也就是方法调用次数太多，每次方法调用都是一次压栈，超过栈内存限制就会Stack Overflow<br>2.限制递归深度，业务场景上来看，调用次数太多本身就可能是处理不当或者实现上有缺陷，可以考虑换种实现方式或者优化实现","like_count":0},{"had_liked":false,"id":78979,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1299615,"ip_address":"","ucode":"528DD5C8399AEC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKlwpFM3tkeG15YqyJTYWkfqkdmro9POq6SicYm57TaEFDOUZCXjoe0Z0Iz6UibGQqic3icJRsHdFzibtw/132","comment_is_top":false,"comment_ctime":1553312736,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1553312736","product_id":100023901,"comment_content":"1、java线程栈大小时由限制，可以通过-Xss改变线程栈的大小<br>2、每次递归调用相当于对Java线程栈做压栈操作，所以方法递归调用层次太深会导致java线程栈内存溢出。","like_count":0},{"had_liked":false,"id":78967,"user_name":"crazypokerk","can_delete":false,"product_type":"c1","uid":1158383,"ip_address":"","ucode":"9AAD5D9726E503","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/ef/494f56c3.jpg","comment_is_top":false,"comment_ctime":1553310722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553310722","product_id":100023901,"comment_content":"还有一种治标不治本的办法：在能预测栈深度的前提下，预先设置递归深度的大小，超过即退出递归。","like_count":0},{"had_liked":false,"id":78962,"user_name":"天涯煮酒","can_delete":false,"product_type":"c1","uid":1241127,"ip_address":"","ucode":"EF9516EC878E4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/27/8b72141c.jpg","comment_is_top":false,"comment_ctime":1553309406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553309406","product_id":100023901,"comment_content":"可以设置一个变量n来记录递归次数，每次递归时先判断n是否小于我们允许的最大递归次数，如果小于继续执行，否则抛一个自定义异常","like_count":0},{"had_liked":false,"id":78950,"user_name":"aksonic","can_delete":false,"product_type":"c1","uid":1003633,"ip_address":"","ucode":"B6F3348F6714DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/71/e8229703.jpg","comment_is_top":false,"comment_ctime":1553306584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553306584","product_id":100023901,"comment_content":"今天这个主题很好，把非共享变量为什么线程安全讲清楚了。嘿嘿<br>思考题：<br>因为栈有固定大小，可以通过JVM参数设置，至于解决办法，我觉得应该减少递归，因为从王争老师的算法课程来看，递归一般都不是最好时间复杂度算法，往往只是因为写法便捷而选择。","like_count":0},{"had_liked":false,"id":78939,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1553304136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553304136","product_id":100023901,"comment_content":"每一次调用都会产生对应的栈帧，多了就爆了。<br>c语言还可以靠大数组撑爆它。","like_count":0},{"had_liked":false,"id":78920,"user_name":"狂战俄洛伊","can_delete":false,"product_type":"c1","uid":1213269,"ip_address":"","ucode":"F6EACA321E6180","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUzv6S9wroydkGP6m3OsQ8QuI4jAibv21tNkm7KVGPffJibj8Y29yIdKl4qkDGd3iaGJCSGVarfxoibQ/132","comment_is_top":false,"comment_ctime":1553300552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553300552","product_id":100023901,"comment_content":"假设递归深度为10，最少需要有10个栈贞入栈。每个栈贞都有自己的局部变量和参数。递归深度越大，栈贞就会越多，占的栈空间就越多，以致超过了虚拟机给线程分配的栈内存，导致溢出。优化的话，一方面增加栈内存的分配。另一方面尽量减少递归方法里面的参数和局部定义。至于优化递归深度和将递归改造为循环，那是业务层的事儿了","like_count":0}]}