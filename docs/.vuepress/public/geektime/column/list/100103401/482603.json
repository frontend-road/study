{"id":482603,"title":"加餐二 | 什么是“表达式思维”？","content":"<p>你好，我是朱涛。</p><p>在<a href=\"https://time.geekbang.org/column/article/472129\">开篇词</a>当中，我曾经说过，学好Kotlin的关键在于<strong>思维的转变</strong>。在上一次<a href=\"https://time.geekbang.org/column/article/478106\">加餐课程</a>当中，我给你介绍了Kotlin的函数式编程思想，相信你对Kotlin的“函数思维”已经有了一定的体会。那么今天这节课，我们就来聊聊Kotlin的<strong>表达式思维</strong>。</p><p>所谓编程思维，其实是一种非常抽象的概念，很多时候是只可意会不可言传的。不过，从某种程度上看，学习编程思维，比学习编程语法还要重要。因为<strong>编程思维决定着我们的代码整体的架构与风格</strong>，而具体的某个语法反而没那么大的影响力。当然，如果对Kotlin的语法没有一个全面的认识，编程思维也只会是空中楼阁。</p><p>所以，准确地来说，掌握Kotlin的编程思维，是在掌握了Kotlin语法基础上的一次升华。这就好比是，我们学会了基础的汉字以后开始写作文一样。学了汉字以后，如果不懂得写作的技巧，是写不出优美的文章的。同理，如果学了Kotlin语法，却没有掌握它的编程思维，也是写不出优雅的Kotlin代码的。</p><p>好，那么接下来，我们就来看看Kotlin的表达式思维。</p><h2>表达式思维</h2><p>在正式开始学习表达式思维之前，我们先来看一段简单的Kotlin代码。</p><pre><code class=\"language-plain\">var i = 0\nif (data != null) {\n    i = data\n}\n\nvar j = 0\nif (data != null) {\n    j = data\n} else {\n    j = getDefault()\n    println(j)\n}\n\nvar k = 0\nif (data != null) {\n    k = data\n} else {\n    throw NullPointerException()\n}\n\nvar x = 0\nwhen (data) {\n    is Int -&gt; x = data\n    else -&gt; x = 0\n}\n\nvar y = 0\ntry {\n    y = \"Kotlin\".toInt()\n} catch (e: NumberFormatException) {\n    println(e)\n    y = 0\n}\n</code></pre><!-- [[[read_end]]] --><p>这些代码，如果我们用Java的思维来分析的话，是挑不出太多毛病的。但是站在Kotlin的角度，就完全不一样了。</p><p>利用Kotlin的语法，我们完全可以将代码写得更加简洁，就像下面这样：</p><pre><code class=\"language-plain\">val i = data ?: 0\nval j = data ?: getDefault().also { println(it) }\n\nval k = data?: throw NullPointerException()\n\n\n\nval x = when (data) {\n    is Int -&gt; data\n    else -&gt; 0\n}\n\nval y = try {\n    \"Kotlin\".toInt()\n} catch (e: NumberFormatException) {\n    println(e)\n    0\n}\n</code></pre><p>这段代码看起来就简洁了不少，但如果你有Java经验，你在写代码的时候，脑子里第一时间想到的一定不是这样的代码模式。这个，也是我们需要格外注意培养表达式思维的原因。</p><p>不过，现在你心里可能已经出现了一个疑问：<strong>Kotlin凭什么就能用这样的方式写代码呢？<strong>其实这是因为：if、when、throw、try-catch这些语法，在Kotlin当中都是</strong>表达式</strong>。</p><p>那么，这个“表达式”到底是什么呢？其实，与<a href=\"https://kotlinlang.org/spec/expressions.html#expressions\">表达式</a>（Expression）对应的，还有另一个概念，我们叫做<a href=\"https://kotlinlang.org/spec/statements.html#statements\">语句</a>（Statement）。这两者的准确定义其实很复杂，你可以点击我这里给出的链接去看看它们之间区别。</p><p>不过我们可以先简单来概括一下：<strong>表达式，是一段可以产生值的代码；而语句，则是一句不产生值的代码。</strong>这样解释还是有些抽象，我们来看一些例子：</p><pre><code class=\"language-plain\">val a = 1    // statement\nprintln(a)   // statement\n\n// statement\nvar i = 0\nif (data != null) {\n    i = data\n}\n\n// 1 + 2 是一个表达式，但是对b的赋值行为是statement\nval b = 1 + 2\n\n// if else 整体是一个表达式\n// a &gt; b是一个表达式\n// a - b是一个表达式\n// b - a是一个表达式。\nfun minus(a: Int, b: Int) = if (a &gt; b) a - b else b - a\n\n// throw NotImplementedError() 是一个表达式\nfun calculate(): Int = throw NotImplementedError()\n</code></pre><p>这段代码是描述了常见的Kotlin代码模式，从它的注释当中，我们其实可以总结出这样几个规律：</p><ul>\n<li>赋值语句，就是典型的statement；</li>\n<li>if语法，既可以作为语句，也可以作为表达式；</li>\n<li>语句与表达式，它们可能会出现在同一行代码中，比如val b = 1 + 2；</li>\n<li>表达式还可能包含“子表达式”，就比如这里的minus方法；</li>\n<li>throw语句，也可以作为表达式。</li>\n</ul><p>但是看到这里，你的心中应该还是有一个疑问没有解开，那就是：<strong>calculate()这个函数难道不会引起编译器报错吗？</strong></p><pre><code class=\"language-plain\">//       函数返回值类型是Int，实际上却抛出了异常，没有返回Int\n//                ↓       ↓\nfun calculate(): Int = throw NotImplementedError()\n</code></pre><p>确实，在刚开始接触Kotlin的时候，我也无法理解这样的代码。直到我弄清楚Kotlin整个类型系统以后，我才真正找到答案。</p><p>所以，为了让你能真正理解Kotlin表达式背后的原理，接下来，我们就来系统学习一下Kotlin的类型系统吧。</p><h2>类型系统</h2><p>在课程的<a href=\"https://time.geekbang.org/column/article/472154\">第1讲</a>我们就学过，在Kotlin当中，Any是所有类型的父类，我们可以称之为<strong>根类型</strong>。同时，我们也学过，Kotlin的类型还分为<strong>可空类型</strong>和<strong>不可空类型</strong>。举个例子，对于字符串类型，就有String、String?，它们两者分别代表了不为空的字符串、可能为空的字符串。</p><p>在这个基础上，我们很容易就能推测出，Kotlin的类型体系应该是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/18/40/1873d04968cd8aca90381b9f84651f40.jpg?wh=2000x979\" alt=\"\"></p><p>也就是，Any是所有非空类型的根类型；而Any?是所有可空类型的根类型。那么现在，你可能会想到这样的一个问题：<strong>Any与Any?之间是什么关系呢？</strong></p><h3>Any与Any?与Object</h3><p>从表面上看，这两个确实没有继承关系。不过，它们之间其实是存在一些微妙的联系的。</p><p>在Kotlin当中，我们可以把“子类型”赋值给“父类型”，就像下面的代码一样：</p><pre><code class=\"language-plain\">val s: String = \"\"\nval any: Any = s\n</code></pre><p>由于String是Any的子类型，因此，我们可以将String类型赋值给Any类型。而实际上，Any和“Any?”之间也是类似的，我们可以将Any类型赋值给“Any？”类型，反之则不行。</p><pre><code class=\"language-plain\">val a: Any = \"\"\nval b: Any? = a // 通过\n\nval c: Any = b  // 报错\n</code></pre><p>类似的，String类型可以赋值给“String？”类型，反之也不行。你可能会想这是为什么呢？<br>\n其实，<strong>任何类型，当它被“?”修饰，变成可空类型以后，它就变成原本类型的父类了。<strong>所以，从某种程度上讲，我们可以认为“Any？”是所有Kotlin类型的</strong>根类型</strong>。它的具体关系如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d9/dd/d904d1ed5df67211058yya5098868cdd.jpg?wh=2000x1044\" alt=\"\"></p><p>因此，我们可以说：虽然Any与Any？之间没有继承的关系，但是我们可以将Any看作是Any？的子类；String类型可以看作是String？的子类。</p><p>而由于Any与“Any？”之间并没有明确的继承关系，但它们又存在父子类型的关系，所以在上面的示意图中，我们用虚线来表示。</p><p>所以到这里，我们就弄明白了一个问题：<strong>Kotlin的Any与Java的Object之间是什么关系？</strong></p><p>那么，答案也是显而易见的，Java当中的Object类型，对应Kotlin的“Any？”类型。但两者并<strong>不完全等价</strong>，因为Kotlin的Any可以没有wait()、notify()之类的方法。因此，我们只能说Kotlin的“Any？”与Java的Object是大致对应的。Intellij有一个功能，可以将Java代码转换成Kotlin代码，我们可以借此印证。</p><p>这是一段Java代码，它有三个方法，分别是可为空的Object类型、不可为空的Object类型，以及无注解的Object类型。</p><pre><code class=\"language-java\">public class TestType {\n\n    @Nullable  // 可空注解\n    public Object test() { return null; }\n\n    public Object test1() { return null; }\n\n    @NotNull  // 不可空注解\n    public Object test2() { return 1; }\n}\n</code></pre><p>上面的代码转换成Kotlin以后，会变成这样：</p><pre><code class=\"language-plain\">class TestType {\n    fun test(): Any? { return null }\n\n    fun test1(): Any? { return null }\n\n    fun test2(): Any { return 1 }\n}\n</code></pre><p>由此可见，在没有注解标明可空信息的时候，Object类型是会被当作“Any？”来看待的。而在有了注解修饰以后，Kotlin就能够识别出到底是Any，还是“Any？”。</p><h3>Unit与Void与void</h3><p>在Kotlin当中，除了普通的Any、String的类型之外，还有一个特殊的类型，叫做<strong>Unit</strong>。而Unit这个类型，经常会被拿来和Java的Void、void来对比。</p><p>那么在这里，你首先需要知道的是：在Java当中，Void和void不是一回事（注意大小写），前者是一个Java的类，后者是一个用于修饰方法的关键字。如下所示：</p><pre><code class=\"language-plain\">public final class Void {\n\n    public static final Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass(\"void\");\n\n    private Void() {}\n}\n</code></pre><p>从语法含义上来讲，Kotlin的Unit与Java的void更加接近，但Unit远不止于此。在Kotlin当中，Unit也是一个类，这点跟Void又有点像。比如，在下面的代码中，Unit是一个类型的同时，还是一个单例：</p><pre><code class=\"language-plain\">public object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n</code></pre><p>所以，我们就可以用Unit写出很灵活的代码。就像下面这样：</p><pre><code class=\"language-plain\">fun funUnit(): Unit { }\n\nfun funUnit1(): Unit { return Unit }\n</code></pre><p>可以看到，当返回值类型是Unit的时候，我们既可以选择不写return，也可以选择return一个Unit的单例对象。</p><p>另外，在使用泛型编程的时候，当T类型作为返回值类型的时候，我们传入Unit以后，就不再需要写return了。</p><pre><code class=\"language-plain\">interface Task&lt;T&gt; {\n    fun excute(any: Any): T\n}\n\nclass PrintTask: Task&lt;Unit&gt; {\n    override fun excute(any: Any) {\n        println(any)\n        // 这里写不写return都可以\n    }\n}\n</code></pre><p>更重要的是，Unit还有助于我们实现函数类型。</p><pre><code class=\"language-plain\">val f: () -&gt; Unit = {}\n</code></pre><p>所以，Kotlin的Unit与Java的Void或者void并不存在等价的关系，但它们之间确实存在一些概念上的相似性。至此，我们也可以更新一下前面那个类型系统关系图了：</p><p><img src=\"https://static001.geekbang.org/resource/image/74/7f/74e9ea7a804e30bc0e49982ce12f547f.jpg?wh=2000x1036\" alt=\"\"></p><p>可见，Unit其实和String类型一样，就是一个普通的类。只是因为Kotlin编译器会特殊对待它，当Unit作为返回值类型的时候，可以不需要return。</p><p>好了，接着，我们再来看看Kotlin当中经常被提到的Nothing类型。</p><h3>Nothing</h3><p>在有了前面的基础以后呢，Nothing就很容易理解了。其实，<strong>Nothing就是Kotlin所有类型的子类型</strong>。</p><p>Nothing的概念与“Any?”恰好相反。“Any?”是所有的Kotlin类型的父类，Nothing则是所有类型的子类。如果用一张图来概括，大概会是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/35/3a/35dd00d1acyyd43b7b72dc4cf84d3c3a.jpg?wh=2000x1125\" alt=\"\"></p><p>事实上，像Nothing这样的概念，在函数式编程当中，也被叫做<strong>底类型</strong>（Bottom Type），因为它位于整个类型体系的最底部。</p><p>而了解了Kotlin的Nothing类型以后，我们其实就可以尝试着来解答前面例子中留下来的疑问了：</p><pre><code class=\"language-plain\">//       函数返回值类型是Int，实际上却抛出了异常，没有返回Int\n//                ↓       ↓\nfun calculate(): Int = throw NotImplementedError() // 不会报错\n\n//       函数返回值类型是Any，实际上却抛出了异常，没有返回Any\n//                ↓       ↓\nfun calculate1(): Any = throw Exception() // 不会报错\n\n//       函数返回值类型是Unit，实际上却抛出了异常，没有返回Unit\n//                 ↓       ↓\nfun calculate2(): Unit = throw Exception() // 不会报错\n</code></pre><p>根据这段代码可以发现，不管函数的返回值类型是什么，我们都可以使用抛出异常的方式来实现它的功能。这样我们其实就可以推测出一个结论：<strong>throw这个表达式的返回值是Nothing类型。</strong>而既然Nothing是所有类型的子类型，那么它当然是可以赋值给任意其他类型的。</p><p>可是，我们如何才能印证这个结论是否正确呢？很简单，我们可以把两个函数的返回值类型都改成Nothing，然后看看编译器会不会报错：</p><pre><code class=\"language-plain\">// 不会报错\nfun calculate(): Nothing = throw NotImplementedError() \n\n// 不会报错\nfun calculate1(): Nothing = throw Exception() \n\n// Nothing构造函数是私有的，因此我们无法构造它的实例\npublic class Nothing private constructor()\n</code></pre><p>可见，编译器仍然不会报错。这也就印证了我们前面的猜测：throw表达式的返回值类型是Nothing。</p><p>另外，我们应该也注意到了Nothing类的构造函数是私有的，因此我们无法构造出它的实例。而当Nothing类型作为函数参数的时候，一个有趣的现象就出现了：</p><pre><code class=\"language-plain\">// 这是一个无法调用的函数，因为找不到合适的参数\nfun show(msg: Nothing) {\n}\n\nshow(null) // 报错\nshow(throw Exception()) // 虽然不报错，但方法仍然不会调用\n</code></pre><p>这里我们定义的这个show方法，它的参数类型是Nothing，而由于Nothing的构造函数是私有的，这就导致我们将无法调用show这个函数，除非我们抛出异常，但这没有意义。这个概念在泛型星投影的时候是有应用的，具体你可以点击<a href=\"https://kotlinlang.org/docs/generics.html#star-projections\">这个链接</a>去查看详情。</p><p>而除此之外，Nothing还有助于编译器进行代码流程的推断。比如说，当一个表达式的返回值是Nothing的时候，就往往意味着它后面的语句不再有机会被执行。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/33/5a/3365f67ab5f828ef23af65484d317a5a.png?wh=676x371\" alt=\"图片\"></p><p>在了解了Unit与Nothing这两个不可空的类型以后，我们再来看看它们对应的可空类型。</p><h3>Unit?与Nothing?</h3><p>也许你也注意到了，Unit对应的还有一个“Unit?”类型，那么这个类型有什么意义吗？</p><p>我们可以看看下面的代码：</p><pre><code class=\"language-plain\">fun f1(): Unit? { return null } // 通过\n\nfun f2(): Unit? { return Unit } // 通过\n\nfun f3(): Unit? { throw Exception() } // 通过\n\nfun f4(): Unit? { } // 报错，缺少return\n</code></pre><p>可见，Kotlin编译器只会把Unit类型当作无需返回值的类型，而Unit?则不行。</p><p>所以，Unit?这个类型其实没有什么广泛的应用场景，因为它失去了原本的编译器特权后，就只能有3种实现方式，即null、Unit单例、Nothing。也就是说，当Unit?作为返回值的时候，我们的函数必须要return一个值了，它返回值的类型可以是null、Unit单例、Nothing这三种情况。</p><p>好，接下来我们再来看看“Nothing?”这个类型。</p><pre><code class=\"language-plain\">fun calculate1(): Nothing? = null\nfun calculate2(): Nothing? = throw Exception()\n</code></pre><p>由以上代码示例可知，当Nothing?作为返回值类型的时候，我们可以返回null，或者是抛出异常。这一切都符合预期，而当它作为函数参数的时候，也会有一些有趣的变化。</p><pre><code class=\"language-plain\">//               变化在这里\n//                   ↓\nfun show(msg: Nothing?) {\n}\n\nshow(null) // 通过\nshow(throw Exception()) // 虽然不报错，但方法仍然不会调用\n</code></pre><p>可以看到，当参数类型是Nothing?的时候，我们的函数仍然是可以调用的。这其实就能进一步说明一个问题：<strong>Nothing才是底类型，而“Nothing?”则不是底类型。</strong><br>\n这一点其实在前面的类型关系图中就有体现，现在你就可以真正理解了：</p><p><img src=\"https://static001.geekbang.org/resource/image/35/3a/35dd00d1acyyd43b7b72dc4cf84d3c3a.jpg?wh=2000x1125\" alt=\"\"></p><p>到这里相信你也明白了，“Unit?”“Nothing?”这两个类型，其实并没有太多实际的应用场景，不过由于它们是Kotlin类型系统当中特殊的类型，因此我们也应该对它们有个清晰的认识。</p><p>这样，在系统学习了Kotlin的类型系统以后，我们对表达式理解就可以更上一层楼了。</p><h2>表达式的本质</h2><p>我们再来看看表达式的定义：<strong>表达式，是一段可以产生值的代码；而语句，则是一句不产生值的代码。</strong></p><p>也许你听说过这样一句话：在Kotlin当中，一切都是表达式。<strong>注意！这句话其实是错的。</strong>因为Kotlin当中还是存在语句的，比如while循环、for循环，等等。</p><p>不过，如果我们换个说法：<strong>在Kotlin当中，大部分代码都是表达式。</strong>这句话就对了。Kotlin的类型系统当中的Unit和Nothing，让很多原本无法产生返回值的语句，变成了表达式。</p><p>我们来举个例子：</p><pre><code class=\"language-plain\">// statement\nprintln(\"Hello World.\")\n\n// println(\"Hello World.\") 变成了表达式\nval a = println(\"Hello World.\")\n\n// statement\nthrow Exception()\n\n// throw 变成了表达式\nfun test1() = throw Exception() \n</code></pre><p>从上面的代码案例中，我们可以总结出两个规律。</p><ul>\n<li>由于Kotlin存在Unit这个类型，因此println(“Hello World.”)这行代码也可以变成表达式，它所产生的值就是Unit这个单例。</li>\n<li>由于Kotlin存在Nothing这个类型，因此throw也可以作为表达式，它所产生的值就是Nothing类型。</li>\n</ul><p>注意，因为Java当中不存在Unit、Nothing这样的类型，所以Java里返回值为void的函数是无法成为表达式的，另外，throw这样的语句也是无法成为表达式的。而也正是因为Kotlin这样的类型系统，才让大部分的语句都摇身一变成为了表达式。因为Unit、Nothing在Kotlin编译器看来，也是所有类型当中的一种。</p><p>可以说，Unit和Nothing填补了原本Java当中的类型系统，让Kotlin的类型系统更加全面。也正因为如此，Kotlin才可以拥有真正的函数类型，比如：</p><pre><code class=\"language-plain\">val f: (String) -&gt; Unit = ::println\n</code></pre><p>可以看到，如果不存在Unit这个类型，我们是无法描述println这个函数的类型的。正因为println函数的返回值类型为Unit，我们才可以用“(String) -&gt; Unit”来描述它。</p><p>换句话说就是：<strong>Kotlin的类型系统让大部分的语句都变成了表达式，同时也让无返回值的函数有了类型。</strong></p><p>而所谓的表达式思维，其实就是要求我们开发者在编程的时候，<strong>时刻记住Kotlin大部分的语句都是可以作为表达式的</strong>，并且由于表达式都是有返回值的，这也就让我们可以用一种全新的思维来写代码。这在很多时候，都可以大大简化我们的代码逻辑。</p><p>那么现在，我们再回过头看之前的代码，就会觉得很顺眼了：</p><pre><code class=\"language-plain\">val i = data ?: 0\nval j = data ?: getDefault().also { println(it) }\n\nval k = data?: throw NullPointerException()\n\n\nval x = when (data) {\n    is Int -&gt; data\n    else -&gt; 0\n}\n\nval y = try {\n    \"Kotlin\".toInt()\n} catch (e: NumberFormatException) {\n    0\n}\n</code></pre><h2>小结</h2><p>好，今天这节加餐，到这里就接近尾声了，我们来做个简单的总结。</p><ul>\n<li>所谓的<strong>表达式思维</strong>，就是要时刻记住：Kotlin大部分的语句都是表达式，它是可以产生返回值的。利用这种思维，往往可以大大简化代码逻辑。</li>\n<li>Any是所有非空类型的根类型，而“Any?”才是所有类型的<strong>根类型</strong>。</li>\n<li>Unit与Java的void类型，代表一个函数不需要返回值；而“Unit?”这个类型则没有太多实际的意义。</li>\n<li>当Nothing作为函数返回值的时候，意味着这个函数永远不会返回结果，而且还会截断程序的后续流程。Kotlin编译器也会根据这一点，进行流程分析。</li>\n<li>当Nothing作为函数参数的时候，就意味着这个函数永远无法被正常调用。这在泛型星投影的时候是有一定应用的。</li>\n<li>另外，Nothing可以看作是“Nothing?”子类型，因此，Nothing可以看作是Kotlin所有类型的<strong>底类型</strong>。</li>\n<li>正是因为Kotlin在类型系统当中，加入了Unit、Nothing这两个类型，才让大部分无法产生值的语句摇身一变，成为了表达式。这也是“Kotlin大部分的语句都是表达式”的根本原因。</li>\n</ul><h2>思考题</h2><p>这节课，我们学习了表达式思维，请问，你觉得它和我们前面学到的“函数式编程”有联系吗？为什么？欢迎在留言区分享你的答案和思考，也欢迎你把今天的内容分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"12 | 实战：用Kotlin实现一个网络请求框架KtHttp","id":481787},"right":{"article_title":"加餐三 | 什么是“不变性思维”？","id":484631}},"comments":[{"had_liked":false,"id":338774,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1647722890,"is_pvip":false,"replies":[{"id":"124028","content":"很棒的答案，推荐给大家！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648031966,"ip_address":"","comment_id":338774,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40302428554","product_id":100103401,"comment_content":"函数式编程要求函数是一等公民，如果某些函数不能用类型描述（例如Java中的返回为void 函数），后续的赋值，参数传递就很困难，成为一等公民就成为泡影！Kotlin中Nothing，Unit 和 Any?让所有函数的返回都有固定类型，为函数式编程奠定基础。函数的返回值必然来自于某个表达式，这也要求表达式都有固定类型。表达式是函数编程的组成模块，是串联各个函数的纽带，也是决定函数返回值的重要一环。<br>","like_count":10,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557974,"discussion_content":"很棒的答案，推荐给大家！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648031966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332364,"user_name":"20220106","can_delete":false,"product_type":"c1","uid":2884743,"ip_address":"","ucode":"DC9E91125B21C6","user_header":"","comment_is_top":false,"comment_ctime":1643187173,"is_pvip":false,"replies":[{"id":"121445","content":"嗯，确实表达的不够到位。我本意是想表达：鲁迅、莫言之类的文学作家，他们和我们都一样只是学了汉字，那他们为什么可以写出那么好的文章呢？他们和普通人的差异肯定不只是“写作技巧”那么简单，但如果我将其称为“写作思维”呢好像又有点奇怪。<br><br>也许“文学素养”更合适吧。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643253864,"ip_address":"","comment_id":332364,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18823056357","product_id":100103401,"comment_content":"学了汉字以后，如果不懂得写作的技巧，是写不出优美的文章的。<br>——理解作者想表达什么，但是写作技巧和文章优美与否不直接挂钩，除非把模板的文字当作优美。","like_count":5,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548552,"discussion_content":"嗯，确实表达的不够到位。我本意是想表达：鲁迅、莫言之类的文学作家，他们和我们都一样只是学了汉字，那他们为什么可以写出那么好的文章呢？他们和普通人的差异肯定不只是“写作技巧”那么简单，但如果我将其称为“写作思维”呢好像又有点奇怪。\n\n也许“文学素养”更合适吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643253864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332346,"user_name":"better","can_delete":false,"product_type":"c1","uid":1169063,"ip_address":"","ucode":"AF1DB566EBB8A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","comment_is_top":false,"comment_ctime":1643184321,"is_pvip":false,"replies":[{"id":"121446","content":"“相互补充”这四个字总结很到位，赞！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643253962,"ip_address":"","comment_id":332346,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14528086209","product_id":100103401,"comment_content":"函数式，关注的是计算的输入输出，而表达式可以有输出，2者可以结合起来；也就类似：<br>函数式(函数式(表达式)表达式)，某些情况，反过来也可以<br>表达式=函数式(表达式)<br>实现相互补充，不知道这样理解是否 ok","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548553,"discussion_content":"“相互补充”这四个字总结很到位，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643253962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332565,"user_name":"PoPlus","can_delete":false,"product_type":"c1","uid":1574765,"ip_address":"","ucode":"5F0927921317F2","user_header":"https://static001.geekbang.org/account/avatar/00/18/07/6d/4c1909be.jpg","comment_is_top":false,"comment_ctime":1643344259,"is_pvip":false,"replies":[{"id":"121532","content":"是的，理解Unit并不难，难的是理解它背后的设计意图。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643433518,"ip_address":"","comment_id":332565,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5938311555","product_id":100103401,"comment_content":"这节很受用，原来 Unit 类是 Kotlin 实现「表达式思维」的重要支撑。之前一直觉得 Unit 只不过是 void 的 Kotlin 版本罢了，没想那么多。","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548882,"discussion_content":"是的，理解Unit并不难，难的是理解它背后的设计意图。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643433518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332270,"user_name":"dadada","can_delete":false,"product_type":"c1","uid":2897145,"ip_address":"","ucode":"DC9151FAEEEA2F","user_header":"https://static001.geekbang.org/account/avatar/00/2c/34/f9/4b02a45a.jpg","comment_is_top":false,"comment_ctime":1643131483,"is_pvip":false,"replies":[{"id":"121401","content":"放心，协程部分肯定是跑不掉的哈，先容我把基础部分讲明白，照顾一下基础不好的同学。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643166041,"ip_address":"","comment_id":332270,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5938098779","product_id":100103401,"comment_content":"能不能快点更新呀？主要为的就是协程及后面的东西，等了这么久了协程还没有更新。。","like_count":1,"discussions":[{"author":{"id":2885349,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/06/e5/51ef9735.jpg","nickname":"A Lonely Cat","note":"","ucode":"382EBFDD8E5115","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548396,"discussion_content":"巧了  我也是在等协程和Flow","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1643182021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2897145,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/34/f9/4b02a45a.jpg","nickname":"dadada","note":"","ucode":"DC9151FAEEEA2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548500,"discussion_content":"是的  协程感觉比较难懂 看目录感觉这个课程非常不错哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1643217284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2621394,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ff/d2/204edd23.jpg","nickname":"WWWarmFly","note":"","ucode":"DBACC196FADE65","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548468,"discussion_content":"买课就是想看协程","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1643204641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548372,"discussion_content":"放心，协程部分肯定是跑不掉的哈，先容我把基础部分讲明白，照顾一下基础不好的同学。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1643166041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358945,"user_name":"Psyduck","can_delete":false,"product_type":"c1","uid":1668732,"ip_address":"浙江","ucode":"0B06ADBB3A5F30","user_header":"https://static001.geekbang.org/account/avatar/00/19/76/7c/e1d9a256.jpg","comment_is_top":false,"comment_ctime":1665049295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665049295","product_id":100103401,"comment_content":"读完了整个系列的 50%，感觉老师讲的还是很不错的。我们团队就是用 kotlin 进行开发的后端团队，自己用 kotlin 因为已经一年多了，但满满发现很多时候 kotlin 都被用成了 java。这次系统性的学习了一下，感觉收获还是很多的。","like_count":1},{"had_liked":false,"id":343402,"user_name":"vox","can_delete":false,"product_type":"c1","uid":2466331,"ip_address":"","ucode":"0A433DF2BC1D5F","user_header":"https://static001.geekbang.org/account/avatar/00/25/a2/1b/0a4f9177.jpg","comment_is_top":false,"comment_ctime":1650817861,"is_pvip":false,"replies":[{"id":"125651","content":"加油~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651247103,"ip_address":"","comment_id":343402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650817861","product_id":100103401,"comment_content":"这一章很棒","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568907,"discussion_content":"加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651247104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340210,"user_name":"Shanks-王冲","can_delete":false,"product_type":"c1","uid":1042983,"ip_address":"","ucode":"C4B90A17850E20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","comment_is_top":false,"comment_ctime":1648658748,"is_pvip":false,"replies":[{"id":"124473","content":"可以这么理解的，毕竟“子类”与“继承”并非等价。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648813460,"ip_address":"","comment_id":340210,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648658748","product_id":100103401,"comment_content":"涛哥，我分享一个疑惑：Any与Any?描述成「虽是子类，但没有继承关系」，可以描述成Any是Any?的子类型（sub type）嘛？当然，这很容易让人联想到泛型；不过「子类型」与「继承」，在我学习Java时，有时候让人觉得很微妙：）","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559545,"discussion_content":"可以这么理解的，毕竟“子类”与“继承”并非等价。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648813461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340206,"user_name":"Shanks-王冲","can_delete":false,"product_type":"c1","uid":1042983,"ip_address":"","ucode":"C4B90A17850E20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","comment_is_top":false,"comment_ctime":1648653239,"is_pvip":false,"replies":[{"id":"124476","content":"没错","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648813974,"ip_address":"","comment_id":340206,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648653239","product_id":100103401,"comment_content":"思考题<br><br>1. 正如文中提到Kotlin引入Unit和Nothing类型，丰富了Kotlin的expressions，一方面，Unit也为函数式编程提供了基础，即有了`(noParam_orParams) -&gt; Unit`类型","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559549,"discussion_content":"没错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648813974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338775,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1647724481,"is_pvip":false,"replies":[{"id":"124021","content":"就我所知，Kotlin 官方非常推崇简洁语法，不希望引入过多复杂的语法进来。也许是这个原因吧。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648031434,"ip_address":"","comment_id":338775,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647724481","product_id":100103401,"comment_content":"Kotlin能转成表达式语句基本都做了表达式版本，但是赋值语句照理说应该很容易转成表达式的，在某些情况也能起到简化的作用，例如把赋值表达式传给if，在if里面使用赋值创建的变量，但是Kotlin没有做，请问老师，这背后有什么考量吗?多谢","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557967,"discussion_content":"就我所知，Kotlin 官方非常推崇简洁语法，不希望引入过多复杂的语法进来。也许是这个原因吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648031434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338726,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1647686551,"is_pvip":true,"replies":[{"id":"124307","content":"我在图里用的代码字体一般是：Courier，你可以试试看。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648522504,"ip_address":"","comment_id":338726,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647686551","product_id":100103401,"comment_content":"@朱涛 你这个代码字体看着非常舒服，是什么字体？哪里可以下载吗？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558918,"discussion_content":"我在图里用的代码字体一般是：Courier，你可以试试看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648522504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336574,"user_name":"Barry","can_delete":false,"product_type":"c1","uid":1134793,"ip_address":"","ucode":"1715EC3977A1D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/c9/1bec2c98.jpg","comment_is_top":false,"comment_ctime":1646220353,"is_pvip":true,"replies":[{"id":"123013","content":"很棒！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646271095,"ip_address":"","comment_id":336574,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646220353","product_id":100103401,"comment_content":"我理解kotlin建立的类型系统，才能实现表达式编程方式，进而可以实现函数式编程，确实提升了编程效率","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554206,"discussion_content":"很棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646271095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333566,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1644407220,"is_pvip":false,"replies":[{"id":"121885","content":"Nothing和“Nothing?”不一样哈，所以确实找不到反例的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644460441,"ip_address":"","comment_id":333566,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1644407220","product_id":100103401,"comment_content":"当一个表达式的返回值是 Nothing 的时候，就往往意味着它后面的语句不再有机会被执行。<br>---------<br>这个结论会不会不准确？会不会是案例中是 throw exception 才导致后面的语句不再被执行，而像下面这种就没问题<br><br>fun main() {<br>    test()<br>    print(&quot;111&quot;)<br>}<br><br>fun test(): Nothing? = null &#47;&#47; 当然这里是 Nothing? 而不是 Nothing，因为我确实找不到例子","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550255,"discussion_content":"Nothing和“Nothing?”不一样哈，所以确实找不到反例的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644460441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192938,"avatar":"https://static001.geekbang.org/account/avatar/00/12/33/ea/373d8e6b.jpg","nickname":"夜班同志","note":"","ucode":"19941F1537EB7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551275,"discussion_content":"觉得表面现象是这样，但没有实际因果关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644972535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333374,"user_name":"Renext","can_delete":false,"product_type":"c1","uid":1020838,"ip_address":"","ucode":"3C4418F7E86CD6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","comment_is_top":false,"comment_ctime":1644313608,"is_pvip":false,"replies":[{"id":"121865","content":"这个目前没有计划，这个问题我会先记下来，看看后续实战课中能不能应用进来，但不敢保证哈。<br><br>其实，这一点Kotlin官方文档已经介绍的比较清楚了，只要你理解了Nothing，剩下的应该就不难的。<br><br>参考这里：https:&#47;&#47;kotlinlang.org&#47;docs&#47;generics.html#star-projections","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644391803,"ip_address":"","comment_id":333374,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644313608","product_id":100103401,"comment_content":"Nothing泛型星投影的时候的应用，后面会有讲解吗","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550130,"discussion_content":"这个目前没有计划，这个问题我会先记下来，看看后续实战课中能不能应用进来，但不敢保证哈。\n\n其实，这一点Kotlin官方文档已经介绍的比较清楚了，只要你理解了Nothing，剩下的应该就不难的。\n\n参考这里：https://kotlinlang.org/docs/generics.html#star-projections","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644391803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332550,"user_name":"Android攻城狮","can_delete":false,"product_type":"c1","uid":2879107,"ip_address":"","ucode":"9F5031EAAFB94D","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/83/a843a848.jpg","comment_is_top":false,"comment_ctime":1643337074,"is_pvip":false,"replies":[{"id":"121489","content":"这样一来，我们没有办法调用Nothing的构造函数了，也就无法创建Nothing的对象了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643341086,"ip_address":"","comment_id":332550,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1643337074","product_id":100103401,"comment_content":"这里我们定义的这个 show 方法，它的参数类型是 Nothing，而由于 Nothing 的构造函数是私有的，这就导致我们将无法调用 show 这个函数<br>- 不理解这句话，为什么因为Nothing 的构造函数是私有的，就无法调用show这个函数","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548723,"discussion_content":"这样一来，我们没有办法调用Nothing的构造函数了，也就无法创建Nothing的对象了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643341086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339841,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","nickname":"白乾涛","note":"","ucode":"0C704B0B90C8D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550184,"discussion_content":"因为我们没法构造一个 Nothing ，我们所有能构造的都是 Nothing 的父类对象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644409378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125548,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2c/ac/551b6936.jpg","nickname":"ShaneMao","note":"","ucode":"48B5944B95DEE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554112,"discussion_content":"老师， 如果使用反射，构造出一个Nothing对象，是不是就能调用了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646217807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339841,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","nickname":"白乾涛","note":"","ucode":"0C704B0B90C8D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550186,"discussion_content":"我也有二个问题：\n\n1、为啥会出现&#34;虽然不报错，但方法仍然不会调用&#34;的现象？\n2、虽然编译时不报错，但是运行时会报错呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644410003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}