{"id":99828,"title":"14 | 答疑（一）：列表和元组的内部实现是怎样的？","content":"<p>你好，我是景霄。</p><p>转眼间，专栏上线已经一个月了，而我们也在不知不觉中完成了第一大章基础篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。</p><p>大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很典型的问题，我专门摘录了出来，作为今天的答疑内容，集中回复。</p><h2>问题一：列表和元组的内部实现</h2><p>第一个问题，是胡峣同学提出的，有关列表（list）和元组（tuple）的内部实现，想知道里边是linked list 或array，还是把array linked一下这样的方式？</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/a2/8fb9cf6bf14357104c88454eefaaeca2.png?wh=1404*162\" alt=\"\"></p><p>关于这个问题，我们可以分别从源码来看。</p><p>先来看 Python 3.7 的list源码。你可以先自己阅读下面两个链接里的内容。</p><p>listobject.h：<a href=\"https://github.com/python/cpython/blob/949fe976d5c62ae63ed505ecf729f815d0baccfc/Include/listobject.h#L23\">https://github.com/python/cpython/blob/949fe976d5c62ae63ed505ecf729f815d0baccfc/Include/listobject.h#L23</a></p><p>listobject.c: <a href=\"https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/listobject.c#L33\">https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/listobject.c#L33</a></p><!-- [[[read_end]]] --><p>我把 list的具体结构放在了下面：</p><p><img src=\"https://static001.geekbang.org/resource/image/99/e0/99e356ee9b00e645004879b9837c3ee0.png?wh=1320*728\" alt=\"\"></p><p>可以看到，list本质上是一个over-allocate的array。其中，ob_item是一个指针列表，里面的每一个指针都指向列表的元素。而 allocated则存储了这个列表已经被分配的空间大小。</p><p>需要注意的是，allocated 与列表实际空间大小的区别。列表实际空间大小，是指len(list)返回的结果，即上述代码注释中的ob_size，表示这个列表总共存储了多少个元素。实际情况下，为了优化存储结构，避免每次增加元素都要重新分配内存，列表预分配的空间allocated往往会大于ob_size（详见正文中的例子）。</p><p>所以，它们的关系为：<code>allocated &gt;= len(list) = ob_size</code>。</p><p>如果当前列表分配的空间已满（即allocated == len(list)），则会向系统请求更大的内存空间，并把原来的元素全部拷贝过去。列表每次分配空间的大小，遵循下面的模式：</p><pre><code>0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...\n</code></pre><p>我们再来分析元组。下面是Python 3.7 的tuple源码，同样的，你可以先自己阅读一下。</p><p>tupleobject.h： <a href=\"https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Include/tupleobject.h#L25\">https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Include/tupleobject.h#L25</a></p><p>tupleobject.c：<a href=\"https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/tupleobject.c#L16\">https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/tupleobject.c#L16</a></p><p>同样的，下面为tuple的具体结构：</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/d2/5b038b1819ee122b6309b5c5bae456d2.png?wh=1372*446\" alt=\"\"></p><p>你可以看到，它和list相似，本质也是一个array，但是空间大小固定。不同于一般array，Python的tuple做了许多优化，来提升在程序中的效率。</p><p>举个例子，当tuple的大小不超过20时，Python就会把它缓存在内部的一个free list中。这样，如果你以后需要再去创建同样的tuple，Python就可以直接从缓存中载入，提高了程序运行效率。</p><h2>问题二：为什么在旧哈希表中，元素会越来越稀疏？</h2><p>第二个问题，是Hoo同学提出的，为什么在旧哈希表中，元素会越来越稀疏？</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/6b/cf241621f373b0e3712f3e0fcc71896b.png?wh=1072*256\" alt=\"\"></p><p>我们可以先来看旧哈希表的示意图：</p><pre><code>--+-------------------------------+\n  | 哈希值 (hash)  键 (key)  值 (value)\n--+-------------------------------+\n0 |    hash0      key0    value0\n--+-------------------------------+\n1 |    hash1      key1    value1\n--+-------------------------------+\n2 |    hash2      key2    value2\n--+-------------------------------+\n. |           ...\n__+_______________________________+\n</code></pre><p>你会发现，它是一个over-allocate的array，根据元素键（key）的哈希值，来计算其应该被插入位置的索引。</p><p>因此，假设我有下面这样一个字典：</p><pre><code>{'name': 'mike', 'dob': '1999-01-01', 'gender': 'male'}\n</code></pre><p>那么这个字典便会存储为类似下面的形式：</p><pre><code>entries = [\n['--', '--', '--']\n[-230273521, 'dob', '1999-01-01'],\n['--', '--', '--'],\n['--', '--', '--'],\n[1231236123, 'name', 'mike'],\n['--', '--', '--'],\n[9371539127, 'gender', 'male']\n]\n</code></pre><p>这里的<code>’---‘</code>，表示这个位置没有元素，但是已经分配了内存。</p><p>我们知道，当哈希表剩余空间小于1/3时，为了保证相关操作的高效性并避免哈希冲突，就会重新分配更大的内存。所以，当哈希表中的元素越来越多时，分配了内存但里面没有元素的位置，也会变得越来越多。这样一来，哈希表便会越来越稀疏。</p><p>而新哈希表的结构，改变了这一点，也大大提高了空间的利用率。新哈希表的结构如下所示：</p><pre><code>Indices\n----------------------------------------------------\nNone | index | None | None | index | None | index ...\n----------------------------------------------------\n\n\nEntries\n--------------------\nhash0   key0  value0\n---------------------\nhash1   key1  value1\n---------------------\nhash2   key2  value2\n---------------------\n        ...\n---------------------\n</code></pre><p>你可以看到，它把存储结构分成了Indices和Entries这两个array，而<code>’None‘</code>代表这个位置分配了内存但没有元素。</p><p>我们同样还用上面这个例子，它在新哈希表中的存储模式，就会变为下面这样：</p><pre><code>indices = [None, 1, None, None, 0, None, 2]\nentries = [\n[1231236123, 'name', 'mike'],\n[-230273521, 'dob', '1999-01-01'],\n[9371539127, 'gender', 'male']\n]\n</code></pre><p>其中，Indices中元素的值，对应entries中相应的索引。比如<code>indices</code>中的<code>1</code>，就对应着<code>entries[1]</code>，即<code>’'dob': '1999-01-01'‘</code>。</p><p>对比之下，我们会清晰感受到，新哈希表中的空间利用率，相比于旧哈希表有大大的提升。</p><h2>问题三：有关异常的困扰</h2><p>第三个问题，是“不瘦到140不改名”同学提出的，对“NameError”异常的困惑。这是很常见的一个错误，我在这里也解释一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/6e/48c46d4a66e5c002ce392d79deee436e.png?wh=1094*530\" alt=\"\"></p><p>这个问题其实有点tricky，如果你查阅<a href=\"https://docs.python.org/3/reference/compound_stmts.html#the-try-statement\">官方文档</a>，会看到这么一句话”When an exception has been assigned using as target, it is cleared at the end of the except clause. ”</p><p>这句话意思是，如果你在异常处理的except block中，把异常赋予了一个变量，那么这个变量会在except block执行结束时被删除，相当于下面这样的表示：</p><pre><code>e = 1\ntry:\n    1 / 0\nexcept ZeroDivisionError as e:\n    try:\n        pass\n    finally:\n        del e\n</code></pre><p>这里的e一开始指向整数1，但是在except block结束时被删除了（del e），所以程序执行就会抛出“NameError”的异常。</p><p>因此，这里提醒我们，在平时写代码时，一定要保证except中异常赋予的变量，在之后的语句中不再被用到。</p><h2>问题四：关于多态和全局变量的修改</h2><p>最后的问题来自于farFlight同学，他提了两个问题：</p><ol>\n<li>Python自己判断类型的多态和子类继承的多态Polymorphism是否相同？</li>\n<li>函数内部不能直接用+=等修改全局变量，但是对于list全局变量，却可以使用append、extend之类修改，这是为什么呢?</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/aa/0c/aa20a535ce703ef0fe0f1291877f960c.png?wh=1474*460\" alt=\"\"></p><p>我们分别来看这两个问题。对于第一个问题，要搞清楚多态的概念，多态是指有多种不同的形式。因此，判断类型的多态和子类继承的多态，在本质上都是一样的，只不过你可以把它们理解为多态的两种不同表现。</p><p>再来看第二个问题。当全局变量指向的对象不可变时，比如是整型、字符串等等，如果你尝试在函数内部改变它的值，却不加关键字global，就会抛出异常：</p><pre><code>x = 1\n\ndef func():\n    x += 1\nfunc()\nx\n\n## 输出\nUnboundLocalError: local variable 'x' referenced before assignment\n</code></pre><p>这是因为，程序默认函数内部的x是局部变量，而你没有为其赋值就直接引用，显然是不可行。</p><p>不过，如果全局变量指向的对象是可变的，比如是列表、字典等等，你就可以在函数内部修改它了：</p><pre><code>x = [1]\n\ndef func():\n    x.append(2)\nfunc()\nx\n\n## 输出\n[1, 2]\n</code></pre><p>当然，需要注意的是，这里的<code>x.append(2)</code>，并没有改变变量x，x依然指向原来的列表。事实上，这句话的意思是，访问x指向的列表，并在这个列表的末尾增加2。</p><p>今天主要回答这些问题，同时也欢迎你继续在留言区写下疑问和感想，我会持续不断地解答。希望每一次的留言和答疑，都能给你带来新的收获和价值。</p><p></p>","neighbors":{"left":{"article_title":"13 | 搭建积木：Python 模块化","id":99275},"right":{"article_title":"15 | Python对象的比较、拷贝","id":100105}},"comments":[{"had_liked":false,"id":102209,"user_name":"夜路破晓","can_delete":false,"product_type":"c1","uid":1353577,"ip_address":"","ucode":"9B875F94B759B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3hZfficKPGCq2kjFBu9SgaMjibJTEl7iaW1ta6pZNyiaWP8XEsNpunlnsiaOtBpWTXfT5BvRP3qNByml6p9rtBvqewg/132","comment_is_top":false,"comment_ctime":1560160639,"is_pvip":false,"replies":[{"id":"37815","content":"根据需求，首先了解每一个block，每一个函数的大概意思，然后看下去，不懂的多去google一下，看多了你的水平自然就提高了","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1560754491,"ip_address":"","comment_id":102209,"utype":1}],"discussion_count":5,"race_medal":0,"score":"306502838655","product_id":100026901,"comment_content":"个人认知：感觉会看源码的人都很牛！我也想成人牛人，那么问题来了：<br>如何学习看源码？","like_count":72,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453297,"discussion_content":"根据需求，首先了解每一个block，每一个函数的大概意思，然后看下去，不懂的多去google一下，看多了你的水平自然就提高了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560754491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1044785,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f1/31/5001390b.jpg","nickname":"Lonely绿豆蛙","note":"","ucode":"0862179B614974","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156411,"discussion_content":"自顶向下地解剖一个项目，先了解整体架构，阅读注释，暂时不要（或者没必要）深入到内部的实现逻辑。代码都是人写的，要自信看懂一部分并不难。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580360111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1895499,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ec/4b/442dd5f1.jpg","nickname":"及時行樂","note":"","ucode":"2FD0E0BB8327DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253419,"discussion_content":"个人认知：我觉得老师说去了解每个源码的意思，然后坚持看下去，不懂多去Google一下，那么问题来了：大陆如何Google一下，（手动狗头，哈哈哈）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588232983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1995257,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/71/f9/85329b42.jpg","nickname":"做一个可靠的UDP","note":"","ucode":"2428ED20AD3398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1895499,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ec/4b/442dd5f1.jpg","nickname":"及時行樂","note":"","ucode":"2FD0E0BB8327DE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263399,"discussion_content":"这个必须会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589204702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":253419,"ip_address":""},"score":263399,"extra":""}]},{"author":{"id":2064044,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7e/ac/4303e8ef.jpg","nickname":"Geek_b692f5","note":"","ucode":"C2826604F71C36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299542,"discussion_content":"调试代码才是程序员成长的最快的方式","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597730907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102102,"user_name":"SCAR","can_delete":false,"product_type":"c1","uid":1031209,"ip_address":"","ucode":"38C0927FA3C5FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/29/022905e6.jpg","comment_is_top":false,"comment_ctime":1560136747,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"246373272619","product_id":100026901,"comment_content":"对于问题四的2而言，是因为python是动态语言，不要求声明变量，但是约定在函数体中赋值的变量是局部变量，所以需要理解的是“赋值”这个动作，不管是常规的完整赋值或是增强赋值，只有函数体内初次出现赋值就认为定义了局部变量。这样你就很好理解了，老师的例子中x+=1，出现了赋值，那么这个x就是局部变量了，而x+=1这个增强赋值的第二步会去找函数体内x的引用，于是就出现了找不到的错误。如果把x+=1改成print(x),则是打印出1，因为函数体没出现赋值，那么这个x是最上面赋值的x，它是全局的。","like_count":58,"discussions":[{"author":{"id":1118976,"avatar":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","nickname":"Michael","note":"","ucode":"35F4FFAC4A4B15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":681,"discussion_content":"你这个理解太棒了。根本原因不是变量类型的问题，而是在修改这个变量前有没有在相应的命名空间内找到这个变量的声明。\n\n如果 x = []，我们可以在函数内通过 x.append(1) 修改x，是因为按照 Python 的变量命名查找规则（LEGB），它最终会在 global 命名空间内找到这个变量，然后就地修改。如果这里修改x的语句改为：x += [1]，也会报下面的这个错误。\n\n当 x = 1，在函数内通过 x += 1 修改x时，由于赋值语句的规则限制，Python 会在当前函数的局部命名空间内查找这个 x 应用，发现不存在，所以才会报错：UnboundLocalError: local variable &#39;x&#39; referenced before assignment。","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1561955531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1228290,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/02/43202976.jpg","nickname":"w 🍍","note":"","ucode":"F2386C971EC58B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1118976,"avatar":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","nickname":"Michael","note":"","ucode":"35F4FFAC4A4B15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3590,"discussion_content":"删除了什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564622920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":681,"ip_address":""},"score":3590,"extra":""},{"author":{"id":2538092,"avatar":"","nickname":"懒猫","note":"","ucode":"094F30C802C0F6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1118976,"avatar":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","nickname":"Michael","note":"","ucode":"35F4FFAC4A4B15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377448,"discussion_content":"x += 1 的时候，在当前函数的局部命名空间内查找这个 x 应用，发现不存在之后，为什么不继续到 global 命名空间内去找呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622645959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":681,"ip_address":""},"score":377448,"extra":""},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2538092,"avatar":"","nickname":"懒猫","note":"","ucode":"094F30C802C0F6","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":412561,"discussion_content":"赋值语句比较特殊，需要额外声明global才可以访问全局变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636208670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377448,"ip_address":""},"score":412561,"extra":""}]},{"author":{"id":2538092,"avatar":"","nickname":"懒猫","note":"","ucode":"094F30C802C0F6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377449,"discussion_content":"x+=1这个增强赋值的第二步会去找函数体内x的引用，如果找不到，为什么不继续到 函数体外去找呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622646055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2538092,"avatar":"","nickname":"懒猫","note":"","ucode":"094F30C802C0F6","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":412562,"discussion_content":"赋值语句比较特殊，需要额外声明global才可以访问全局变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636208713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377449,"ip_address":""},"score":412562,"extra":""}]},{"author":{"id":2369413,"avatar":"https://static001.geekbang.org/account/avatar/00/24/27/85/ddeeaf30.jpg","nickname":"dived","note":"","ucode":"141916A3BAF5A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374147,"discussion_content":"理解确实到位，老师地解释虽然没错，但是这个兄弟地解释才是根本，就是不能直接在函数内部直接对全局变量进行赋值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621042193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3934,"discussion_content":"这个理解很赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564988990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102067,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1560128198,"is_pvip":false,"replies":[{"id":"36795","content":"会分配比实际元素多的空间，比如一个array实际有5个元素，但是如果是over-allocate的array，可能会分配10个元素的空间大小","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1560130379,"ip_address":"","comment_id":102067,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74574572230","product_id":100026901,"comment_content":"over-allocate是什么意思","like_count":17,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453244,"discussion_content":"会分配比实际元素多的空间，比如一个array实际有5个元素，但是如果是over-allocate的array，可能会分配10个元素的空间大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560130379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252728,"discussion_content":"超配","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588174748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102018,"user_name":"yshan","can_delete":false,"product_type":"c1","uid":1136788,"ip_address":"","ucode":"A2ECDCDA52B8EE","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/94/c8bc2b59.jpg","comment_is_top":false,"comment_ctime":1560105180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44509778140","product_id":100026901,"comment_content":"重新查了下理解了下多态：多态就是多种形态。 有了继承，才有多态了。 继承了就具有父类的方法，然后子类就能够覆写父类方法，子类就能够调用该方法实现自己的需求。","like_count":10},{"had_liked":false,"id":103455,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1560439030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40215144694","product_id":100026901,"comment_content":"1.细看了over-allocated分配空间大小的增长规律，4 4 8 9 10 11 12...不知道这样设计的缘由。<br>2.&quot;当tuple的大小不超过20时，Python会把它缓存在内部的一个free list中。&quot;这句话突然让我想起了小整数池。<br>小整数池的概念：Python提前建立好范围在[-5, 256]的整数对象，且不会被垃圾回收。无论这个整数处于LEGB中的哪个位置，所有位于这个范围内的整数使用的都是同一个对象。<br>主要目的是为了避免频繁申请和销毁小整数的内存空间，提高程序的运行效率。<br>3.说一下我所理解的新哈希表的设计思想：<br>indice下标，entry入口。用下标去寻找对应元素。<br>维护一个数据量较小的结构，去访问一个数据量较大的结构。<br>同理，也被运用于函数：<br>函数的本质是在堆Heap中放置的对象；<br>函数名的本质是放在栈Stack中的地址，指向堆中放置的对象。<br><br>以上，思维比较发散，说得不对还望指出。","like_count":9},{"had_liked":false,"id":102500,"user_name":"18646333118","can_delete":false,"product_type":"c1","uid":1202411,"ip_address":"","ucode":"35576AC4E5ADDD","user_header":"https://static001.geekbang.org/account/avatar/00/12/58/eb/cf3608bd.jpg","comment_is_top":false,"comment_ctime":1560238058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23035074538","product_id":100026901,"comment_content":"辛苦老师，希望能用更通俗的语言或者例子来帮助我们这帮菜鸟理解哈哈，有的时候感觉老师明白，但是编辑成文字总是差一点 哈","like_count":5},{"had_liked":false,"id":112741,"user_name":"xavier","can_delete":false,"product_type":"c1","uid":1243128,"ip_address":"","ucode":"2F7918EA37ED9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/f8/3c0a6854.jpg","comment_is_top":false,"comment_ctime":1562812569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14447714457","product_id":100026901,"comment_content":"对于我这种野生程序员来说，收获颇多。每一篇都是从基础开始，然后循序渐进。感谢老师！","like_count":3},{"had_liked":false,"id":102140,"user_name":"Geek_d848f7","can_delete":false,"product_type":"c1","uid":1524021,"ip_address":"","ucode":"F24BC59B6E9E6B","user_header":"","comment_is_top":false,"comment_ctime":1560150190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14445052078","product_id":100026901,"comment_content":" 老师，原谅我还是不太理解这2点吧\r   1. 列表分配大小时，遵循下面模式：0、4、8…，我看源代码的确这样，但是怎么算都对不上，求指导；\r   2. 哈希的存储怎么知道是如图形式呢？尤其是无元素位置，这个位置为啥要分配呢？","like_count":3},{"had_liked":false,"id":126904,"user_name":"隰有荷","can_delete":false,"product_type":"c1","uid":1357944,"ip_address":"","ucode":"2BE9A32AB28963","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/78/2828195b.jpg","comment_is_top":false,"comment_ctime":1566520136,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10156454728","product_id":100026901,"comment_content":"不太明白为什么新哈希表的结构是<br>Indices<br>None | index | None | None | index | None |<br><br>Entries         这种形式?<br><br>None和index的排列有什么规则吗？为什么会有None? ","like_count":2,"discussions":[{"author":{"id":1710643,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/vwv0qiaibQzcTP6yIDJXOJLdh64CnBSaOceFFuWArVHQcwicIsebwYbKJ69OSJrxeXJyawtNIINcjo3V3hgg5BW1A/132","nickname":"MuBo","note":"","ucode":"46402B9B7D7B1E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328456,"discussion_content":"None表示hash值和某个值与运算之后还没有填充到的内存位置","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606142547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1786819,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/43/c3/2c53acd7.jpg","nickname":"雄鹰","note":"","ucode":"67E0C4BDE7F6F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291627,"discussion_content":"我是不明白为什么中间多了一个None","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594891501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111629,"user_name":"瞳梦","can_delete":false,"product_type":"c1","uid":1596386,"ip_address":"","ucode":"A86FC44F6321BD","user_header":"","comment_is_top":false,"comment_ctime":1562575488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10152510080","product_id":100026901,"comment_content":"list的append()并不是一个赋值操作，不会去定义新的变量。而是会根据LEGB规则去寻找list这个变量。","like_count":2},{"had_liked":false,"id":102199,"user_name":"KaitoShy","can_delete":false,"product_type":"c1","uid":1038415,"ip_address":"","ucode":"E2E2E9BD3F5048","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","comment_is_top":false,"comment_ctime":1560159573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855126869","product_id":100026901,"comment_content":"怎么得上面的存储方式的？和hash存储有关么？还是python实现的造成的？","like_count":1},{"had_liked":false,"id":102167,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1560155629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855122925","product_id":100026901,"comment_content":"想问一下Mr King，问题3我在pycharm中执行了一下没报错啊？","like_count":1},{"had_liked":false,"id":357238,"user_name":"me","can_delete":false,"product_type":"c1","uid":2662659,"ip_address":"四川","ucode":"205E44AFEDFFFC","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/03/dff6bc2f.jpg","comment_is_top":false,"comment_ctime":1663081606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663081606","product_id":100026901,"comment_content":"x = 1<br>def func():<br>    x += 1<br>func()<br>报错,分析原因: (从两个角度分析)<br>1&gt; 从右往左<br>先要明白赋值操作的一个概念, 被赋值=被引用；<br>再来看函数体内的 x += 1, 本质上就是x = x + 1 (扩展一下,若x是列表 x+=[1] 等同于 x.extend() 原地改变, 但放在此处依旧会报错, 报错原因于 x+=1同理) <br>继续分析, x = x + 1，右边的x变量在函数体里没有找到(在函数体里没有定义此变量),就去全局作用域里找, 找到啦, 右边的值最终为2.. <br>重点来了, 记住python在作用域里对变量的赋值操作规则, 在函数体内,若对某一变量未定义,对其赋值视为在函数体里定义了该变量;  在函数体内,若对某一变量已经定义,对其赋值视为修改该变量的值; <br>这里左边的x变量在函数体里未定义,那么按照规则会定义一个局部变量x,但右边的x是全局变量... 冲突了. <br>2&gt; 从左往右<br>根据报错的角度分析 是因为函数体里无x变量,赋值操作是定义该x变量,而赋值语句中又有还没有定义好的x变量)","like_count":0},{"had_liked":false,"id":343492,"user_name":"Geek_145846","can_delete":false,"product_type":"c1","uid":2530478,"ip_address":"","ucode":"1DA77D13A8F19E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoAlkIjytYG8MqOtDf7n7pF3rXJnoMNL9ebRXluPvGh2e2A9TxyMoQxPyYQ1dInAFIeltwo8zuvhg/132","comment_is_top":false,"comment_ctime":1650874644,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650874644","product_id":100026901,"comment_content":"想学学Python 没想到还要重新拾起 C ++，学海无涯苦作舟的感觉 哭","like_count":0},{"had_liked":false,"id":335357,"user_name":"独一无二","can_delete":false,"product_type":"c1","uid":1692320,"ip_address":"","ucode":"A7DE0EA2BD8FE3","user_header":"https://static001.geekbang.org/account/avatar/00/19/d2/a0/c8714628.jpg","comment_is_top":false,"comment_ctime":1645483581,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645483581","product_id":100026901,"comment_content":"如果当前列表分配的空间已满（即 allocated == len(list)），则会向系统请求更大的内存空间，并把原来的元素全部拷贝过去。<br><br><br>这里有个疑问？给列表分配的内存是一块连续的内存空间吗？","like_count":0},{"had_liked":false,"id":293255,"user_name":"Jaden~お張嘉楽","can_delete":false,"product_type":"c1","uid":1803215,"ip_address":"","ucode":"FA2737D6A1D2C9","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/cf/1f3b5b17.jpg","comment_is_top":false,"comment_ctime":1621307308,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1621307308","product_id":100026901,"comment_content":"总结一下刚才那个问题答案：<br>１．a = 1  a为不可变数据类型　函数体里　a+=1　此时的a  为局部变量，而此时执行 a +=1 时，重新复制给新a  但是新a， 找不到所在内存中的位置，所以报错了<br>２．b = []  b为可变的数据类型　函数体内　b.append(1)  　此时b为全局的[] 所有执行函数体内append 是可以的","like_count":0,"discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412563,"discussion_content":"不太准确。关键在于赋值语句和调用变量方法之间的差异","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636208919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290777,"user_name":"lcqbug","can_delete":false,"product_type":"c1","uid":1268609,"ip_address":"","ucode":"08FA17F21BCEC5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbyHPGNLu9sDQOs1V6brMcDwia55pyIlP9n62oO6IYS6kIFDnOSON4ugSeBSy6WhDUnYyJC6vtnHQ/132","comment_is_top":false,"comment_ctime":1619749724,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1619749724","product_id":100026901,"comment_content":"t1 = (1,2)<br>t2 = (1,2)<br>print(t1 is t2)<br><br>在cmd黑窗口中结尾为False<br>在pycharm中为True<br>这是为什么呢","like_count":0,"discussions":[{"author":{"id":1159983,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b3/2f/d08a1363.jpg","nickname":"聪少 Jeff","note":"","ucode":"C791ACA9B47679","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534576,"discussion_content":"由于pycham将程序每一行的变量存储到内存同一地方，只要上下文内容匹配一致就输出True，然而在交互方式下，每行命令是单独编译的，每个变量是存储不一同地方，id地址就会不同，所以返回False。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638235459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041435,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/26/5b/30281476.jpg","nickname":"落雨","note":"","ucode":"5B3B09E72211B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371833,"discussion_content":"你可以用id()这个函数去看一下t1 t2的值。我试了一下在pycharm中，这两个是相等的。也就是说t1和t2都指向了同一个对象。在cmd中，这两个值是不相等的。我怀疑pycharm应该是做了某种优化。具体原因，希望其他大佬解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620011909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154123,"user_name":"Alery","can_delete":false,"product_type":"c1","uid":1156557,"ip_address":"","ucode":"08F3F49181E67B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/cd/3aff5d57.jpg","comment_is_top":false,"comment_ctime":1574383090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574383090","product_id":100026901,"comment_content":"问题四的第二个问题，全局列表x之所以可以在函数中x.append是因为，x指向的列表不变，但是如果列表中的元素超过了列表预留的空间就会重新开启一个更大的列表x指向这个新的列表，这个时候x不也变了吗？为什么还能在函数中使用？","like_count":0},{"had_liked":false,"id":145048,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1572169991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572169991","product_id":100026901,"comment_content":"Example 1:<br><br>Input: 121<br>Output: true<br>Example 2:<br><br>Input: -121<br>Output: false<br>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.<br>class Solution:<br>    def isPalindrome(self, x: int) -&gt; bool:<br>        if (x&gt;=0):<br>            return x==int(str(x)[::-1])<br>        else :<br>            return False<br>                <br>                    <br>               <br>   老师  int(str(x)[::-1])  这一行可以解释下具体意思吗   从后向前读取元素  最后要把string类型转为int类型  吗？       <br>        ","like_count":0},{"had_liked":false,"id":145043,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1572168804,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1572168804","product_id":100026901,"comment_content":"class Solution:<br>    def isPalindrome(self, x: int) -&gt; bool:<br>        return str(x) == str(x)[::-1]<br><br>老师：str(x) == str(x)[::-1] 两个::是什么意思<br>","like_count":0,"discussions":[{"author":{"id":1018685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/3d/0c3a2fd4.jpg","nickname":"偶尔复活下","note":"","ucode":"18B1D525CD50D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295750,"discussion_content":"表示从末尾开始读，即字符串的反转","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596332424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1720364,"avatar":"","nickname":"源猿袁","note":"","ucode":"A20661F5704F79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52301,"discussion_content":"切片，三个参数，(start,end,step)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574037794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122762,"user_name":"静艺","can_delete":false,"product_type":"c1","uid":1605624,"ip_address":"","ucode":"24A98F5FA2A34B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4Uw7lDxq4ArDemWcxIZBAS7q0nDyvyDiboWxODeFF3CfGhjgVj1LFeVibokFKZPPj7yUoichnqGbcT5DBFFunc25g/132","comment_is_top":false,"comment_ctime":1565514842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565514842","product_id":100026901,"comment_content":"每节的配图都很有feel哈哈","like_count":0},{"had_liked":false,"id":102448,"user_name":"catshitfive","can_delete":false,"product_type":"c1","uid":1542973,"ip_address":"","ucode":"E030B61F3D0811","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/3d/2a3b67f8.jpg","comment_is_top":false,"comment_ctime":1560222239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560222239","product_id":100026901,"comment_content":"有几个地方不是很懂请老师能否说明一下：<br>(1)python中的list数据结构本质上是array,但是list多用来进行增删改的操作，岂不是没有链表结构时间复杂度低？还是说有什么优化？(2)list中存储的是指针(存储每个不可变元素对象的地址)，我用id()查看了每个指针内存储的地址，发现是连续的，但是地址都相差32，如何理解32个这个数字，是32bytes? list除了存储的是指针，那么它的空间内还存储了指针指向的那些元素吗？(3)指针本身是一块内存，那么指针对应自己本身的地址如何知晓？","like_count":0},{"had_liked":false,"id":102120,"user_name":"","can_delete":false,"product_type":"c1","uid":1322330,"ip_address":"","ucode":"FA2983C5AD320C","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/5a/cc637589.jpg","comment_is_top":false,"comment_ctime":1560141267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560141267","product_id":100026901,"comment_content":"关于面向对象，看老师有没有机会讲下思路或技巧，我感觉我写面向对象还是有点带面向过程。","like_count":0},{"had_liked":false,"id":102062,"user_name":"Hoo-Ah","can_delete":false,"product_type":"c1","uid":1306913,"ip_address":"","ucode":"823093A6C7DEE7","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/21/52e8267b.jpg","comment_is_top":false,"comment_ctime":1560127892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560127892","product_id":100026901,"comment_content":"我理解的多态是同一种行为，不同的表现形式。","like_count":0}]}