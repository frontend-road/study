{"id":230708,"title":"77 | 开源实战一（下）：通过剖析Java JDK源码学习灵活应用设计模式","content":"<p>上一节课，我们讲解了工厂模式、建造者模式、装饰器模式、适配器模式在Java JDK中的应用，其中，Calendar类用到了工厂模式和建造者模式，Collections类用到了装饰器模式、适配器模式。学习的重点是让你了解，在真实的项目中模式的实现和应用更加灵活、多变，会根据具体的场景做实现或者设计上的调整。</p><p>今天，我们继续延续这个话题，再重点讲一下模板模式、观察者模式这两个模式在JDK中的应用。除此之外，我还会对在理论部分已经讲过的一些模式在JDK中的应用做一个汇总，带你一块回忆复习一下。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>模板模式在Collections类中的应用</h2><p>我们前面提到，策略、模板、职责链三个模式常用在框架的设计中，提供框架的扩展点，让框架使用者，在不修改框架源码的情况下，基于扩展点定制化框架的功能。Java中的Collections类的sort()函数就是利用了模板模式的这个扩展特性。</p><p>首先，我们看下Collections.sort()函数是如何使用的。我写了一个示例代码，如下所示。这个代码实现了按照不同的排序方式（按照年龄从小到大、按照名字字母序从小到大、按照成绩从大到小）对students数组进行排序。</p><!-- [[[read_end]]] --><pre><code>public class Demo {\n  public static void main(String[] args) {\n    List&lt;Student&gt; students = new ArrayList&lt;&gt;();\n    students.add(new Student(&quot;Alice&quot;, 19, 89.0f));\n    students.add(new Student(&quot;Peter&quot;, 20, 78.0f));\n    students.add(new Student(&quot;Leo&quot;, 18, 99.0f));\n\n    Collections.sort(students, new AgeAscComparator());\n    print(students);\n    \n    Collections.sort(students, new NameAscComparator());\n    print(students);\n    \n    Collections.sort(students, new ScoreDescComparator());\n    print(students);\n  }\n\n  public static void print(List&lt;Student&gt; students) {\n    for (Student s : students) {\n      System.out.println(s.getName() + &quot; &quot; + s.getAge() + &quot; &quot; + s.getScore());\n    }\n  }\n\n  public static class AgeAscComparator implements Comparator&lt;Student&gt; {\n    @Override\n    public int compare(Student o1, Student o2) {\n      return o1.getAge() - o2.getAge();\n    }\n  }\n\n  public static class NameAscComparator implements Comparator&lt;Student&gt; {\n    @Override\n    public int compare(Student o1, Student o2) {\n      return o1.getName().compareTo(o2.getName());\n    }\n  }\n\n  public static class ScoreDescComparator implements Comparator&lt;Student&gt; {\n    @Override\n    public int compare(Student o1, Student o2) {\n      if (Math.abs(o1.getScore() - o2.getScore()) &lt; 0.001) {\n        return 0;\n      } else if (o1.getScore() &lt; o2.getScore()) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n  }\n}\n</code></pre><p>结合刚刚这个例子，我们再来看下，为什么说Collections.sort()函数用到了模板模式？</p><p>Collections.sort()实现了对集合的排序。为了扩展性，它将其中“比较大小”这部分逻辑，委派给用户来实现。如果我们把比较大小这部分逻辑看作整个排序逻辑的其中一个步骤，那我们就可以把它看作模板模式。不过，从代码实现的角度来看，它看起来有点类似之前讲过的JdbcTemplate，并不是模板模式的经典代码实现，而是基于Callback回调机制来实现的。</p><p>不过，在其他资料中，我还看到有人说，Collections.sort()使用的是策略模式。这样的说法也不是没有道理的。如果我们并不把“比较大小”看作排序逻辑中的一个步骤，而是看作一种算法或者策略，那我们就可以把它看作一种策略模式的应用。</p><p>不过，这也不是典型的策略模式，我们前面讲到，在典型的策略模式中，策略模式分为策略的定义、创建、使用这三部分。策略通过工厂模式来创建，并且在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。而在Collections.sort()函数中，策略的创建并非通过工厂模式，策略的使用也非动态确定。</p><h2>观察者模式在JDK中的应用</h2><p>在讲到观察者模式的时候，我们重点讲解了Google Guava的EventBus框架，它提供了观察者模式的骨架代码。使用EventBus，我们不需要从零开始开发观察者模式。实际上，Java JDK也提供了观察者模式的简单框架实现。在平时的开发中，如果我们不希望引入Google Guava开发库，可以直接使用Java语言本身提供的这个框架类。</p><p>不过，它比EventBus要简单多了，只包含两个类：java.util.Observable和java.util.Observer。前者是被观察者，后者是观察者。它们的代码实现也非常简单，为了方便你查看，我直接copy-paste到了这里。</p><pre><code>public interface Observer {\n    void update(Observable o, Object arg);\n}\n\npublic class Observable {\n    private boolean changed = false;\n    private Vector&lt;Observer&gt; obs;\n\n    public Observable() {\n        obs = new Vector&lt;&gt;();\n    }\n\n    public synchronized void addObserver(Observer o) {\n        if (o == null)\n            throw new NullPointerException();\n        if (!obs.contains(o)) {\n            obs.addElement(o);\n        }\n    }\n\n    public synchronized void deleteObserver(Observer o) {\n        obs.removeElement(o);\n    }\n\n    public void notifyObservers() {\n        notifyObservers(null);\n    }\n\n    public void notifyObservers(Object arg) {\n        Object[] arrLocal;\n\n        synchronized (this) {\n            if (!changed)\n                return;\n            arrLocal = obs.toArray();\n            clearChanged();\n        }\n\n        for (int i = arrLocal.length-1; i&gt;=0; i--)\n            ((Observer)arrLocal[i]).update(this, arg);\n    }\n\n    public synchronized void deleteObservers() {\n        obs.removeAllElements();\n    }\n\n    protected synchronized void setChanged() {\n        changed = true;\n    }\n\n    protected synchronized void clearChanged() {\n        changed = false;\n    }\n}\n</code></pre><p>对于Observable、Observer的代码实现，大部分都很好理解，我们重点来看其中的两个地方。一个是changed成员变量，另一个是notifyObservers()函数。</p><p><strong>我们先来看changed成员变量。</strong></p><p>它用来表明被观察者（Observable）有没有状态更新。当有状态更新时，我们需要手动调用setChanged()函数，将changed变量设置为true，这样才能在调用notifyObservers()函数的时候，真正触发观察者（Observer）执行update()函数。否则，即便你调用了notifyObservers()函数，观察者的update()函数也不会被执行。</p><p>也就是说，当通知观察者被观察者状态更新的时候，我们需要依次调用setChanged()和notifyObservers()两个函数，单独调用notifyObservers()函数是不起作用的。你觉得这样的设计是不是多此一举呢？这个问题留给你思考，你可以在留言区说说你的看法。</p><p><strong>我们再来看notifyObservers()函数。</strong></p><p>为了保证在多线程环境下，添加、移除、通知观察者三个操作之间不发生冲突，Observable类中的大部分函数都通过synchronized加了锁，不过，也有特例，notifyObservers()这函数就没有加synchronized锁。这是为什么呢？在JDK的代码实现中，notifyObservers()函数是如何保证跟其他函数操作不冲突的呢？这种加锁方法是否存在问题？又存在什么问题呢？</p><p>notifyObservers()函数之所以没有像其他函数那样，一把大锁加在整个函数上，主要还是出于性能的考虑。<br>\nnotifyObservers()函数依次执行每个观察者的update()函数，每个update()函数执行的逻辑提前未知，有可能会很耗时。如果在notifyObservers()函数上加synchronized锁，notifyObservers()函数持有锁的时间就有可能会很长，这就会导致其他线程迟迟获取不到锁，影响整个Observable类的并发性能。</p><p>我们知道，Vector类不是线程安全的，在多线程环境下，同时添加、删除、遍历Vector类对象中的元素，会出现不可预期的结果。所以，在JDK的代码实现中，为了避免直接给notifyObservers()函数加锁而出现性能问题，JDK采用了一种折中的方案。这个方案有点类似于我们之前讲过的让迭代器支持”快照“的解决方案。</p><p>在notifyObservers()函数中，我们先拷贝一份观察者列表，赋值给函数的局部变量，我们知道，局部变量是线程私有的，并不在线程间共享。这个拷贝出来的线程私有的观察者列表就相当于一个快照。我们遍历快照，逐一执行每个观察者的update()函数。而这个遍历执行的过程是在快照这个局部变量上操作的，不存在线程安全问题，不需要加锁。所以，我们只需要对拷贝创建快照的过程加锁，加锁的范围减少了很多，并发性能提高了。</p><p>为什么说这是一种折中的方案呢？这是因为，这种加锁方法实际上是存在一些问题的。在创建好快照之后，添加、删除观察者都不会更新快照，新加入的观察者就不会被通知到，新删除的观察者仍然会被通知到。这种权衡是否能接受完全看你的业务场景。实际上，这种处理方式也是多线程编程中减小锁粒度、提高并发性能的常用方法。</p><h2>单例模式在Runtime类中的应用</h2><p>JDK中java.lang.Runtime类就是一个单例类。这个类你有没有比较眼熟呢？是的，我们之前讲到Callback回调的时候，添加shutdown hook就是通过这个类来实现的。</p><p>每个Java应用在运行时会启动一个JVM进程，每个JVM进程都只对应一个Runtime实例，用于查看JVM状态以及控制JVM行为。进程内唯一，所以比较适合设计为单例。在编程的时候，我们不能自己去实例化一个Runtime对象，只能通过getRuntime()静态方法来获得。</p><p>Runtime类的的代码实现如下所示。这里面只包含部分相关代码，其他代码做了省略。从代码中，我们也可以看出，它使用了最简单的饿汉式的单例实现方式。</p><pre><code>/**\n * Every Java application has a single instance of class\n * &lt;code&gt;Runtime&lt;/code&gt; that allows the application to interface with\n * the environment in which the application is running. The current\n * runtime can be obtained from the &lt;code&gt;getRuntime&lt;/code&gt; method.\n * &lt;p&gt;\n * An application cannot create its own instance of this class.\n *\n * @author  unascribed\n * @see     java.lang.Runtime#getRuntime()\n * @since   JDK1.0\n */\npublic class Runtime {\n  private static Runtime currentRuntime = new Runtime();\n\n  public static Runtime getRuntime() {\n    return currentRuntime;\n  }\n  \n  /** Don't let anyone else instantiate this class */\n  private Runtime() {}\n  \n  //....\n  public void addShutdownHook(Thread hook) {\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n       sm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));\n    }\n    ApplicationShutdownHooks.add(hook);\n  }\n  //...\n}\n</code></pre><h2>其他模式在JDK中的应用汇总</h2><p>实际上，我们在讲解理论部分的时候，已经讲过很多模式在Java JDK中的应用了。这里我们一块再回顾一下，如果你对哪一部分有所遗忘，可以再回过头去看下。</p><p>在讲到模板模式的时候，我们结合Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList四个例子，来具体讲解了它的两个作用：扩展性和复用性。<br>\n在讲到享元模式的时候，我们讲到Integer类中的-128~127之间的整型对象是可以复用的，还讲到String类型中的常量字符串也是可以复用的。这些都是享元模式的经典应用。</p><p>在讲到职责链模式的时候，我们讲到\bJava Servlet中的Filter就是通过职责链来实现的，同时还对比了Spring中的interceptor。实际上，拦截器、过滤器这些功能绝大部分都是采用职责链模式来实现的。</p><p>在讲到的迭代器模式的时候，我们重点剖析了Java中Iterator迭代器的实现，手把手带你实现了一个针对线性数据结构的迭代器。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>这两节课主要剖析了JDK中用到的几个经典设计模式，其中重点剖析的有：工厂模式、建造者模式、装饰器模式、适配器模式、模板模式、观察者模式，除此之外，我们还汇总了其他模式在JDK中的应用，比如：单例模式、享元模式、职责链模式、迭代器模式。</p><p>实际上，源码都很简单，理解起来都不难，都没有跳出我们之前讲解的理论知识的范畴。学习的重点并不是表面上去理解、记忆某某类用了某某设计模式，而是让你了解我反复强调的一点，也是标题中突出的一点，在真实的项目开发中，如何灵活应用设计模式，做到活学活用，能够根据具体的场景、需求，做灵活的设计和实现上的调整。这也是模式新手和老手的最大区别。</p><h2>课堂讨论</h2><p>针对Java JDK中观察者模式的代码实现，我有两个问题请你思考。</p><ol>\n<li>每个函数都加一把synchronized大锁，会不会影响并发性能？有没有优化的方法？</li>\n<li>changed成员变量是否多此一举？</li>\n</ol><p>欢迎留言和我分享你的想法，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"76 |  开源实战一（上）：通过剖析Java JDK源码学习灵活应用设计模式","id":229996},"right":{"article_title":"78 | 开源实战二（上）：从Unix开源开发学习应对大型复杂项目开发","id":232061}},"comments":[{"had_liked":false,"id":212686,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1588175370,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"263581180426","product_id":100039001,"comment_content":"1、肯定会影响性能，但是因为保存观察者对象的必须是线程安全的，所以是不可避免，根据实际业务场景，如果很少被修改，可以使用CopyOnWriteArrayList来实现，但是如果修改频繁，CopyOnWriteArrayList 本质是写时复制，所以比较消耗内存，不建议使用，可以使用别的，比如ConcurrentSkipListSet等；<br>2、change是必须的，有些场景下（比如报警），状态发生变化其实是不报警，持续一定的时间菜报警，所以，把被观察者的对象是否发生变化独立出来，是可以做很多自己业务的事情；可以接单的理解为对变化抽象，提高可扩展性。","like_count":62,"discussions":[{"author":{"id":1348692,"avatar":"","nickname":"InfoQ_dda0bea0fe7a","note":"","ucode":"FBFA0EF9479004","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555274,"discussion_content":"但是会存在线程之间覆盖通知的场景吧？本来需要通知两次的情况，可能最后只通知了一次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646829593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212511,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1588139593,"is_pvip":false,"discussion_count":5,"race_medal":1,"score":"74602583625","product_id":100039001,"comment_content":"思考题：<br>1. 每个函数加一把Synchronized锁，在并发激烈的时候是会影响性能的，优化的方式的话确实是可以使用CopyOnWriteList，copyOnWriteList是个并发安全的List，并且它不是基于锁实现的，而且又因为Oberser 中的List很少被修改经常被遍历的特点，所以使用CopyOnWriteList性能会提升。<br>2. changed成员变量还是必须的，这么做的好处是可以将“跟踪变化”和“通知观察者”两步分开，处理一些复杂的逻辑，","like_count":18},{"had_liked":false,"id":212538,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1588144145,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"61717686289","product_id":100039001,"comment_content":"1、方案一：使用性能更好的线程安全的容器，来替换vector；方案二：如果没有多线程添加、删除观察者的操作，而是在程序启动时就定义好了观察者，以后也不会变更的话，就不用给相关函数加锁了。              <br>2、changed成员不是多此一举，如果没有这个成员，notifyObservers()函数在多线程场景下，会出现重复通知观察者的情况。","like_count":15,"discussions":[{"author":{"id":1173894,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e9/86/d34800a4.jpg","nickname":"heyman","note":"","ucode":"92EF9EF1B1B1B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211588,"discussion_content":"我个人觉得第一种和第三种是类似的，第三种积分系统把营销系统也包进来而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584867908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212414,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1588121128,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40242826792","product_id":100039001,"comment_content":"思考题<br><br>1，是否能用异步观察者模式，减少并发压力。<br><br>2，change必须，如果没有change，那在notifyObservers同步拷贝观察者对象进行通知时，如果这时候有新的变更，那被观察者又会被通知一次。","like_count":9,"discussions":[{"author":{"id":1116630,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","nickname":"码农Kevin亮","note":"","ucode":"D34562461CA0A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103887,"discussion_content":"具体的模式就像招式，学武功不能急着学招式。招式是死的，不懂招式的逻辑与思想就不懂变通，学好内功便能无招胜有招","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577405345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213862,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1588579296,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"31653350368","product_id":100039001,"comment_content":"notifyObservers()这个方法写的巧妙呀！在高并发环境提高性能可以选择“折中“方案，控制锁的粒度。不禁感慨，人生面临的各种选择也是这样，也是各种妥协和折中。<br><br>使用cow遍历性能高，是因为不需要“复制”，它把复制的空间和时间开销，挪到了add之类的操作上，这也是一种折中。<br>","like_count":7,"discussions":[{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284742,"discussion_content":"升华到人生的思考了，给力给力","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1592623840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212507,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1588139145,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23062975625","product_id":100039001,"comment_content":"1.会，写多场景可以采用分治思想降低锁冲突，数据量不大且写少场景就采用cow拿空间换时间。<br><br>2.有这个change字段可能导致丢失通知的情况。并发多个线程发送通知，保障至少一个线程发送通知的场景可以用。","like_count":5,"discussions":[{"author":{"id":1622696,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","nickname":"一格状语","note":"","ucode":"EBA9ED5F97416D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532696,"discussion_content":"如果在sy处等待的线程B，setChanged()，true，线程A先进入执行clearChanged()，将change = false，释放this锁，线程B进入if处为！false = true，直接返回了。是这么回事吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637668437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212485,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1588131808,"is_pvip":false,"replies":[{"id":"86632","content":"这个你上网搜搜吧，一堆讲这个问题的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594785845,"ip_address":"","comment_id":212485,"utype":1}],"discussion_count":8,"race_medal":0,"score":"18768000992","product_id":100039001,"comment_content":"为什么说Vector不是线程安全的类呢？？ Vector的方法不都加了synchronize关键字实现串行化并发安全了吗，应该是线程安全的类啊。","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493519,"discussion_content":"这个你上网搜搜吧，一堆讲这个问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594785845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252075,"discussion_content":"线程安全分五个级别,\n     不可变:不会变化的类自然不会出现线程安全问题\n     绝对安全:不管怎样调用都不会出现线程安全问题(只要对象会变,那么就会有线程安全问题,很难保障绝对安全)\n     相对安全:对这个对象的单次操作时线程安全的,在调用的时候不需要额外的保障(我们所说的CurrentHashMap,HashTable,Vector都属于这个级别)\n     线程兼容:对象本身不是线程安全的,但是我们可以在调用时通过同步手段保证对象的安全使用.平常说的线程不安全,就是这种情况(HashMap,ArrayList)\n    线程对立:不管调用端是否采取同步措施,都无法在多线程下并发使用(Thread的suspend()和resume(),System.setIn(),System.setOut())\n     另外,线程安全比较标准的定义是:\n     当多个线程同时访问一个对象时,如果不用考虑线程运行时的调度和轮转,也不需要额外的同步或者调用方做任何其他协调操作,调用这个对象都可以得到正确的结构,那么就称这个对象为线程安全的对象","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1588139746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1177921,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/41/411b1753.jpg","nickname":"石仔","note":"","ucode":"974E4604CE2213","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":258828,"discussion_content":"单次操作谁都安全;相同方法的多线程操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588731327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252075,"ip_address":""},"score":258828,"extra":""},{"author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1177921,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/41/411b1753.jpg","nickname":"石仔","note":"","ucode":"974E4604CE2213","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260873,"discussion_content":"并不是，举个例子，你用hashmap或者concurrenthashmap去并发插入，循环\n1000次，也就是创建1000条线程，插到同一个key下面，value值为当前循环的index，最后你得到的值到不了1000，百度一下 concurrenthashmap是不是线程安全的，能搜出很多这样的demo，你可以尝试一下","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588909498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":258828,"ip_address":""},"score":260873,"extra":""}]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252051,"discussion_content":"栏主的描述不是很准确。他应该是要表达vector在复合操作下无法保证原子性，所以做不到线程安全。vector单方法级别确实加锁同步，线程安全。但vector实例的应用场景不止单方法调用的。你可以说vector是线程安全的，但其线程安全是有局限性的。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1588137478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361753,"discussion_content":"是这样的，单方法的确是线程安全的。只是在复合操作下，是线程不安全的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616745793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252051,"ip_address":""},"score":361753,"extra":""}]},{"author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252078,"discussion_content":"&#34;相对安全&#34;级别的容器,在多线程环境下单一的增,或者删,或者查的情况下是可以保证线程安全的,但如果同时进行增,删,查操作,还是会出现问题,判断线程安全问题是否会发生,不是基于时间上的先后,而是基于&#34;先发先行原则&#34;,满足此原则即可判断为线程安全","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588140037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575126,"discussion_content":"好奇，有什么是绝对安全，又不是不可变的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654603868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221833,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1590601896,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14475503784","product_id":100039001,"comment_content":"课后思考<br>1. 使用 CopyOnWriteArrayList snapshot 方式提高性能<br>2. changed 变量是多此一举，在共享同一个 Observable 对象时，并发情况下甚至会出现通知丢失，这是因为 setChanged() 和 notifyObservers(args) 并不具备原子性，所以多个线程在 setChanged() 后都会被阻塞在 notifyObservers() 方法内，最终所有阻塞的线程都会全部通知失效。很多时候，像注册后通知就必须要能够通知到注册者，因此也不能容忍通知丢失的情况。","like_count":3},{"had_liked":false,"id":212482,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1588131563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14473033451","product_id":100039001,"comment_content":"<br>1.肯定降低了性能,而通常优化的手段,是更小粒度的锁或者使用乐观锁,在这个方法中已经将notifyObservers方法原本的大锁,利用一个复制技术缩小到一小点了,也是一种版本控制的方式,这里先给出一个尝试优化,使用原子类Boolean来替换setChanged这个大锁,并且使用copyonwriteArrayList来替换我们的数组<br>2.如果没有多并发的任何情况,changed的设计就是多此一举了,但是如果出现了高并发,那么直接去尝试直接执行更新操作可能会是一个非常漫长的等待,于是利用一个简单的标识位,并加上了锁来进行了修改,在高并发的情况下,无可厚非","like_count":3},{"had_liked":false,"id":212468,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1588129440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14473031328","product_id":100039001,"comment_content":"1.会影响，如果要优化，可以使用CopyOnWriteArrayList；<br>2.有必要，如果没有change，则需要观察者知道被观测者什么时候会有状态改变。","like_count":3},{"had_liked":false,"id":231079,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1593576712,"is_pvip":false,"replies":[{"id":"86367","content":"这个问题你可以搜下，很多文章有讲解。我摘抄了一段：<br><br>vector的使用主要有如下两种场景：<br>（1）vector所谓的多线程安全，只是针对单纯地调用某个方法它是有同步机制的。如add，多个线程都在对同一个容器add元素，vector能够保证最后总数是正确的，而ArrayList没有同步机制，就无法保证。<br>（2）vector的多线程安全，在组合操作时不是线程安全的。比如一个线程先调用vector的size方法得到有10个元素，再调用get(9)方法获取最后一个元素，而另一个线程调用remove(9)方法正好删除了这个元素，那第一个线程就会抛越界异常。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594599248,"ip_address":"","comment_id":231079,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10183511304","product_id":100039001,"comment_content":"文章中说Vector不是线程安全的，但是addElement和removeElement都是加了synchronized的呀，为什么不是线程安全的呢","like_count":2,"discussions":[{"author":{"id":1039475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dc/73/9ab38243.jpg","nickname":"xiaoxionga","note":"","ucode":"2BB02B54C31EBF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100230,"discussion_content":"个人经历。上班后觉得啥都不会，然后缺啥补啥，最后发现有些缺的大学本该都学过。所以你懂得。。。比如数据结构与算法，计算机网络等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577243666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1609964,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","nickname":"拂尘","note":"","ucode":"9563C002E4B06A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1039475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dc/73/9ab38243.jpg","nickname":"xiaoxionga","note":"","ucode":"2BB02B54C31EBF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101672,"discussion_content":"谢谢师兄（可以这样叫 吧），大二就认识了这些基础学科的重要性了咯。网络操作系统之类的学的还可以吧，等寒假可以买本书在好好积累积累。算法哪个，唉慢慢练。只是前进的路上还是会有迷茫吧，因为很多事情都是道听途说，然后再加上一些自己的猜测。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577289096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100230,"ip_address":""},"score":101672,"extra":""}]}]},{"had_liked":false,"id":216220,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1589206526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10179141118","product_id":100039001,"comment_content":"change是必须的，控制开关，并发控制。必须要锁啊，有并发，而且现在锁不是优化了么，偏向锁，自旋锁。真的影响很大么","like_count":2},{"had_liked":false,"id":214362,"user_name":"steve","can_delete":false,"product_type":"c1","uid":1354489,"ip_address":"","ucode":"AB6D3E9FF8E77C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJETibDh9wrP19gj9VdlLRmppuG1FibI7nyUGldEXCnoqKibKIB18UMxyEHBkZNlf5vibLNeofiaN5U6Hw/132","comment_is_top":false,"comment_ctime":1588731019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178665611","product_id":100039001,"comment_content":"2、changed 是在高并发的情况下减少重复通知的概率吧，不过也没法完全避免，是这样吗？","like_count":2},{"had_liked":false,"id":212470,"user_name":"不能忍的地精","can_delete":false,"product_type":"c1","uid":1754913,"ip_address":"","ucode":"66A921C0BC8102","user_header":"","comment_is_top":false,"comment_ctime":1588129552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178064144","product_id":100039001,"comment_content":"1. 加同步关键字的方法操作内容简单,都是对容器进行操作和更改状态,所以影响有限,优化的方法可以是线程隔离.避免多线程操作共享变量的问题<br><br>2. changed变量不是多此一举,存在一种情况,就是被观察者行动了,但是条件不满足,但是不需要通知观察者的情况","like_count":2},{"had_liked":false,"id":212452,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1588126078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178060670","product_id":100039001,"comment_content":"1、会影响并发性能,synchronized主要保证Vector线程安全，高并发下会影响加入集合的速度，可以使用并发性好的无锁化容器<br>2、当多个线程同时发起notifyObservers时保证只通知Observer一次","like_count":2},{"had_liked":false,"id":212408,"user_name":"超威丶","can_delete":false,"product_type":"c1","uid":1180753,"ip_address":"","ucode":"1A18DE885D3C44","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/51/da465a93.jpg","comment_is_top":false,"comment_ctime":1588119972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178054564","product_id":100039001,"comment_content":"先解决好并发问题，后续影响性能再做优化，没必要一上来就优化，优化也是对于锁的粒度优化","like_count":2},{"had_liked":false,"id":212771,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1588208942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883176238","product_id":100039001,"comment_content":"1.每个函数加synchronized，肯定会有性能影响的，尤其是高并发的情况下，会有大量现场阻塞在入口等待队列。对于非线程安全的操作，加锁不一定要在方法级别，可以在变量级别加锁，也可以用并发包下的一些安全类来取代synchronized<br>2.changed变量主要好处就是当通知的时候如果没有改变这个变量值，可以直接return。但是我觉得如果通知的时候，忘了set这个变量的值，那不是就相当于通知失败了吗？去掉changed我觉得也可以，保证被观察这在通知的时候，确实是有新消息到来或者有真实事件发生","like_count":1},{"had_liked":false,"id":212672,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1588172627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883139923","product_id":100039001,"comment_content":"课后习题：<br>1. 大量并发的时候会影响，但是在少量的并发的时候，其他影响会比较小，毕竟优化后的synchronized不是默认就是重量级锁。优化方案：更换为一些线程安全的集合类，changed 也可以更换为线程安全的AtomicBoolean，简单一句话，就是缩小锁的范围。<br>2. changed 算一个巧妙的设置吧，可能会存在需求暂时屏蔽某些主播（Observable）。<br>","like_count":1},{"had_liked":false,"id":212438,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1588123790,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5883091086","product_id":100039001,"comment_content":"1. 每个函数都加一把 synchronized 大锁，会不会影响并发性能？有没有优化的方法？<br>---查询资料，vector是jdk很早之前就有的，实现了线程安全，但性能很差，我觉得可以换成CopyOnWriteArrayList会好些，毕竟读多，写少一些。<br><br>2. changed 成员变量是否多此一举<br>---没想明白，不知道是不是防止滥用notifyObservers()方法，必须先设置标志位，然后再通知？看到有hasChanged()方法，难道是让Observer可以主动来检测数据是否变化了？","like_count":1},{"had_liked":false,"id":300435,"user_name":"xxs","can_delete":false,"product_type":"c1","uid":1817409,"ip_address":"","ucode":"C306FFA609C1F1","user_header":"https://static001.geekbang.org/account/avatar/00/1b/bb/41/2bcfff91.jpg","comment_is_top":false,"comment_ctime":1625153071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625153071","product_id":100039001,"comment_content":"看了下源码注释，感觉changed的设计直观来说是为了防止观察者可以触发通知的问题，从结果上看实现了延迟通知的功能。<br>1. notify()的时候将被观察者的对象传给了观察者，而notify是一个public方法，被观察者有权限调用，但若没有changed就会陷入死循环。<br>2. 相对应的setChange()是protected方法，被观察者没有权限调用。<br>3. notify()如果被设计成protected就不会有这个问题，但这样子灵活性就大幅降低，无法从外部主动发起notify()，例如定时通知。","like_count":0},{"had_liked":false,"id":300421,"user_name":"xxs","can_delete":false,"product_type":"c1","uid":1817409,"ip_address":"","ucode":"C306FFA609C1F1","user_header":"https://static001.geekbang.org/account/avatar/00/1b/bb/41/2bcfff91.jpg","comment_is_top":false,"comment_ctime":1625150053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625150053","product_id":100039001,"comment_content":"没看明白，changed有什么用，甚至感觉造成了消息丢失。<br>评论区有很多说有必要的，主要基于两个原因:<br>1. 有些变动不需要通知。这个逻辑就很奇怪，不需要通知就不要调用notice，为什么反而变成不调用change<br>2. 解决高并发下的重复通知。这个我对java不熟悉，可能理解不到位，没看出来哪里重复了。假设两个线程同时调用两个notice，那说明有两个事件需要通知，没有changed这个变量是正常的通知两个，有了changed变量反而因为原子性会有漏发一次的可能。<br>求大神解惑。","like_count":0},{"had_liked":false,"id":289528,"user_name":"橙粒","can_delete":false,"product_type":"c1","uid":2547823,"ip_address":"","ucode":"4D06952EDB0033","user_header":"https://static001.geekbang.org/account/avatar/00/26/e0/6f/7bd611db.jpg","comment_is_top":false,"comment_ctime":1619062606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619062606","product_id":100039001,"comment_content":"Observable 类的33-34行能否移到synchronized 外面？  我理解只是对changed变量的读，并不存在线程安全问题。","like_count":0},{"had_liked":false,"id":260724,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1605089059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605089059","product_id":100039001,"comment_content":"1、可以将锁的范围缩小或者用快照的方式减小持有锁的时间；<br>2、多了一个change字段提供了状态变化而不通知的能力。当然也可以通过子类的控制实现，但是子类的代码就复杂了起来。所以，acceptable.","like_count":0},{"had_liked":false,"id":251185,"user_name":"Geek_bcac93","can_delete":false,"product_type":"c1","uid":2175146,"ip_address":"","ucode":"B8C15B0FB80643","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK16hm4B3sbF0fbTTXrn0DhibaTOTLtygYFAcCmO8hdgz75jbSLjNk38AADIH6grmNzEaeGye0FiclA/132","comment_is_top":false,"comment_ctime":1601392452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601392452","product_id":100039001,"comment_content":"既然对vector的add，remove等操作在外层都加了锁，为啥还要用vector这种重量容器，直接用array list这种轻量容器不就好了吗","like_count":0},{"had_liked":false,"id":247854,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1599894025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599894025","product_id":100039001,"comment_content":"1、使用乐观锁替代如;cas算法，或者减小锁的粒度只有当使用或访问共享变量时加锁<br>2、changed成员变量是控制notifyObservers函数的开关，在并发条件下程序的执行的结果是可变的，加入开关变量可以控制并发问题。","like_count":0},{"had_liked":false,"id":231739,"user_name":"翠羽香凝","can_delete":false,"product_type":"c1","uid":1119933,"ip_address":"","ucode":"54F3762F0E545F","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/bd/e14ba493.jpg","comment_is_top":false,"comment_ctime":1593762183,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1593762183","product_id":100039001,"comment_content":"问题2：这里设置了一个change，实际上是为了多线程而设计的；<br><br>多线程模式下，最简单的方式是整个notifyObservers()函数加锁；<br>但是出于性能考虑，JDK采用了细粒度锁这种方式，仅仅对其中的一个代码块进行上锁；<br><br>当出现多个线程同时访问的时候，第一个线程在synchronized模块中，将change设置为false，然后后续的线程就不会再执行后面的update了。","like_count":0,"discussions":[{"author":{"id":2343086,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","nickname":"徐志超-Klaus","note":"","ucode":"CF26B39965F2A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557652,"discussion_content":"那两个 notifyObservers() 的参数如果不一样呢？那是不是会出现业务上的bug ?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647917644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222484,"user_name":"feihui","can_delete":false,"product_type":"c1","uid":1007294,"ip_address":"","ucode":"13F1D4A82BC650","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","comment_is_top":false,"comment_ctime":1590817270,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590817270","product_id":100039001,"comment_content":"用不用change，还得看应用场景","like_count":0}]}