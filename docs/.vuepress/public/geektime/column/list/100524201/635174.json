{"id":635174,"title":"08｜栈：如何实现数据的后进先出？","content":"<p>你好，我是王健伟。</p><p>从“链表”毕业之后，我们就要进入“栈”的学习了。作为一种耳熟能详的数据结构，“栈”到底是个什么东西呢？</p><p>还记得我们之前提到过的线性表吗？没错，栈仍旧是一种线性表。不过它只能在一端进行插入和删除操作，先入栈的数据只能后出来，而后入栈的数据只能先出来。所以栈具有先进后出或者后进先出的特性。通常来说，我们可以把栈理解为一种<strong>受限的线性表</strong>。</p><p>如果我们把栈比成一个类似木桶这样的容器，栈有两端，把允许进行插入和删除操作的一端称为<strong>栈顶</strong><span class=\"reference\">（top）</span>也就是桶口，或者称为线性表的表尾，而另一端称为<strong>栈底</strong><span class=\"reference\">（bottom）</span>也就是桶底，或者称为线性表的表头。不包含任何数据的栈，叫做空栈<span class=\"reference\">（空线性表）</span>。</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/ca/e9d6300166dfbf16cbf2c5f9171eyyca.jpg?wh=1920x504\" alt=\"图片\"></p><p>整体结构理清之后，我们再说相关的操作。向栈中插入元素，可以叫做<strong>入栈</strong>或进栈，从栈中删除元素，就叫<strong>出栈</strong>。除了能够在表尾插入和删除数据外，对于栈这种数据结构，在任何其他位置插入和删除数据都不应该被允许。你只能提供符合这个规定的操作接口，否则实现的就不是栈了。</p><p>栈也被称为<strong>后进先出（Last In First Out：LIFO）的线性表</strong>，这意味着最后放入到栈里的数据<span class=\"reference\">（插入数据）</span>只能最先被从栈中拿出来<span class=\"reference\">（删除数据）</span>。</p><p>其实，我们生活中满足栈这种后进先出的情形非常多，比如往抽屉里放东西，先放进去的肯定会被堆到最里面，所以只能最后取出，而最后放入的物品往往在最前面或者最上面，所以会被最先取出。</p><!-- [[[read_end]]] --><p>如果用示意图表示用栈存取数据的过程，就会像图1一样：</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/24/bc2cf73fc30c42f7byy5829a93303c24.jpg?wh=2284x756\" alt=\"\" title=\"图1&nbsp; 栈存取数据示意图\"></p><p>在图1中，如果分别将数据a1、a2、a3、a4、a5存入栈中，那么在将数据出栈的时候，顺序就应该是a5、a4、a3、a2、a1（与入栈顺序正好相反）。</p><p>我们刚刚说过，栈是<strong>受限的线性表</strong>，比如因为只能在栈顶进行元素的插入和删除操作，所以也无法指定插入和删除操作的位置，所以，栈所支持的操作，可以理解为线性表操作的<strong>子集</strong>，一般包括栈的创建、入栈<span class=\"reference\">（增加数据）</span>、出栈<span class=\"reference\">（删除数据）</span>、获取栈顶元素<span class=\"reference\">（查找数据）</span>、判断栈是否为空或者是否已满等操作。</p><h2>栈的顺序存储（顺序栈）</h2><p>所谓顺序栈，就是顺序存储<span class=\"reference\">（用一段连续的内存空间依次存储）</span>栈中的数据。前面我们在学习顺序表的时候就提出过2种保存数据的方案同样适合顺序栈。</p><ol>\n<li>通过为一维数组<strong>静态</strong>分配内存的方式来保存数据。</li>\n<li>通过为一维数组<strong>动态</strong>分配内存的方式来保存数据。</li>\n</ol><p>为了顺序栈中数据存满时可以对栈进行扩容，在这里，我会采用第2种保存数据的方案来编写顺序栈的实现代码。</p><p>此外，为了考虑到元素存取的便利性，将数组下标为0的一端作为栈底最合适。</p><h3>顺序栈的类定义、初始化和释放操作</h3><p>我们还是和之前的讲解一样，先说类定义、初始化以及释放操作。</p><pre><code class=\"language-plain\">#define InitSize 10&nbsp; &nbsp;//动态数组的初始尺寸\n#define IncSize&nbsp; 5&nbsp; &nbsp; //当动态数组存满数据后每次扩容所能多保存的数据元素数量\n\t\ntemplate &lt;typename T&gt; //T代表数组中元素的类型\nclass SeqStack\n{\npublic:\n\tSeqStack(int length = InitSize);&nbsp; &nbsp; &nbsp;//构造函数，参数可以有默认值\n\t~SeqStack();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//析构函数\n\npublic:\n\tbool Push(const T&amp; e); //入栈（增加数据）\n\tbool Pop(T&amp; e);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//出栈（删除数据），也就是删除栈顶数据\n\tbool GetTop(T&amp; e);&nbsp; //读取栈顶元素，但该元素并没有出栈而是依旧在栈中\n\t\n\tvoid DispList();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//输出顺序栈中的所有元素\n\tint&nbsp; ListLength();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//获取顺序栈的长度（实际拥有的元素数量）\n\t\t\n\tbool IsEmpty();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //判断顺序栈是否为空\n\tbool IsFull();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//判断顺序栈是否已满\n\t\t\nprivate:\n\tvoid IncreaseSize();&nbsp; &nbsp;//当顺序栈存满数据后可以调用此函数为顺序栈扩容\n\t\nprivate:\n\tT*&nbsp; m_data;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //存放顺序栈中的元素\t\t\n\tint m_maxsize;&nbsp; &nbsp; &nbsp;//动态数组最大容量\n\tint m_top;&nbsp; &nbsp; &nbsp; //栈顶指针(用作数组下标)，指向栈顶元素，该值为-1表示空栈\n};\n\t\n//通过构造函数对顺序栈进行初始化\ntemplate &lt;typename T&gt;\nSeqStack&lt;T&gt;::SeqStack(int length)\n{\n\tm_data = new T[length];&nbsp; //为一维数组动态分配内存，该值和算法空间复杂度无关，空间复杂度一般指算法额外需要的存储空间。\n\tm_maxsize = length;&nbsp; &nbsp; &nbsp; //顺序栈最多可以存储m_maxsize个数据元素\n\tm_top = -1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //空栈\n}\n\t\n//通过析构函数对顺序栈进行资源释放\ntemplate &lt;typename T&gt;\nSeqStack&lt;T&gt;::~SeqStack()\n{\n\tdelete[] m_data;\n}\n</code></pre><p>在main主函数中，加入代码创建一个初始大小为10的顺序栈对象。</p><pre><code class=\"language-plain\">SeqStack&lt;int&gt; seqobj(10);\n</code></pre><p>在利用上面的代码创建seqobj对象之后，顺序栈看起来就会是图2的样子，此时是一个空栈：</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/65/a047d1c8b80e941cd9161337fc40a965.jpg?wh=2284x756\" alt=\"\" title=\"图2&nbsp; 能保存10个元素的顺序栈（空栈）\"></p><h3>顺序栈的入栈、出栈、获取栈顶元素、显示元素等操作</h3><p>首先是入栈以及扩容的相关操作。在阅读代码的同时，不要忘了在心里思考一下算法对应的时间复杂度。</p><pre><code class=\"language-plain\">//入栈（增加数据），通常时间复杂度为O(1)，但一旦需要扩容，时间复杂度就会变成O(n)了\ntemplate &lt;typename T&gt;\nbool SeqStack&lt;T&gt;::Push(const T&amp; e)\n{\n\tif (IsFull() == true)\n\t{\n\t\t//cout &lt;&lt; \"顺序栈已满，不能再进行入栈操作了!\" &lt;&lt; endl;\n\t\t//return false;\n\t\tIncreaseSize(); //扩容\n\t}\n\n\tm_top++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//栈顶指针向后走\n\tm_data[m_top] = e; //本行和上一行可以合并写成一行代码：m_data[++m_top] = e;\n\treturn true;\n}\n\t\n//当顺序栈存满数据后可以调用此函数为顺序栈扩容，时间复杂度为O(n)\ntemplate&lt;class T&gt;\nvoid SeqStack&lt;T&gt;::IncreaseSize()\n{\n\tT* p = m_data;\n\tm_data = new T[m_maxsize + IncSize]; //重新为顺序栈分配更大的内存空间\t\n\tfor (int i = 0; i &lt;= m_top; i++)\n\t{\n\t\tm_data[i] = p[i];&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //将数据复制到新区域\n\t}\n\tm_maxsize = m_maxsize + IncSize;&nbsp; &nbsp; &nbsp;//顺序栈最大长度增加IncSize\n\tdelete[] p;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //释放原来的内存空间\n}\n</code></pre><p>其次，就是相应的出栈、读取栈顶元素代码。</p><pre><code class=\"language-plain\">//出栈（删除数据），也就是删除栈顶数据，时间复杂度为O(1)\ntemplate &lt;typename T&gt;\nbool SeqStack&lt;T&gt;::Pop(T&amp; e)\n{\n\tif (IsEmpty() == true)\n\t{\n\t\tcout &lt;&lt; \"当前顺序栈为空，不能进行出栈操作!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\n\te = m_data[m_top];  //栈顶元素值返回到e中。有的实现版本不会在Pop()成员函数中返回栈顶元素，此时要取得栈顶元素需要用到GetTop()成员函数。\n\tm_top--;            //本行和上一行可以合并写成一行代码：e = m_data[m_top--];\n\treturn true;  \n}\n\t\n//读取栈顶元素，但该元素并没有出栈而是依旧在栈顶中，因此m_top值不会发生改变，时间复杂度为O(1)\ntemplate &lt;typename T&gt;\nbool SeqStack&lt;T&gt;::GetTop(T&amp; e)\n{\n\tif (IsEmpty() == true)\n\t{\n\t\tcout &lt;&lt; \"当前顺序栈为空，不能读取栈顶元素!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\n\te = m_data[m_top];  //栈顶元素返回到e中。\n\treturn true;\n}\n</code></pre><p>最后，是一些顺序栈的常用操作，比如输出所有元素、获取长度、判断是否为空、是否已满。</p><pre><code class=\"language-plain\">//输出顺序栈中的所有元素，时间复杂度为O(n)\ntemplate&lt;class T&gt;\nvoid SeqStack&lt;T&gt;::DispList()\n{\n\t//按照从栈顶到栈底的顺序来显示数据\n\tfor (int i = m_top; i &gt;= 0; --i)\n\t{\n\t\tcout &lt;&lt; m_data[i] &lt;&lt; \" \";  //每个数据之间以空格分隔\n\t}\t\n\tcout &lt;&lt; endl; //换行\n}\n\t\n//获取顺序栈的长度（实际拥有的元素数量），时间复杂度为O(1)\ntemplate&lt;class T&gt;\nint SeqStack&lt;T&gt;::ListLength()\n{\t\t\n\treturn m_top+1;\n}\n\n//判断顺序栈是否为空，时间复杂度为O(1)\ntemplate&lt;class T&gt;\nbool SeqStack&lt;T&gt;::IsEmpty()\n{\n\tif (m_top == -1)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\t\n//判断顺序栈是否已满，时间复杂度为O(1)\ntemplate&lt;class T&gt;\nbool SeqStack&lt;T&gt;::IsFull()\n{\n\tif (m_top &gt;= m_maxsize - 1)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n</code></pre><p>在main主函数中，继续增加下面的代码。</p><pre><code class=\"language-plain\">seqobj.Push(150);\nseqobj.Push(200);\nseqobj.Push(300);\nseqobj.Push(400);\t\nseqobj.DispList();\nint eval = 0;\nseqobj.Pop(eval);\nseqobj.Pop(eval);\ncout &lt;&lt; \"---------\" &lt;&lt; endl;\nseqobj.DispList();\n</code></pre><p>执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/82/5a/82dfe42608fed0568085cfa8d1bcc25a.jpg?wh=1234x170\" alt=\"\"></p><p>从结果可以看到，程序是先把150、200、300、400进行了入栈操作，此时顺序栈中的数据如图3(a)所示，最先进去的150是在最下面的。然后又将栈顶的两个元素出栈，此时顺序栈中的数据如图3(b)所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/1d/ab30585e0c24087f3d1a4b49b854921d.jpg?wh=2284x883\" alt=\"\" title=\"图3&nbsp; 先入栈4个元素再出栈2个元素的顺序栈示意图\"></p><p>在图3中，先入栈了4个元素，而后又出栈了2个元素，出栈时虽然只修改了m_top栈顶指针，并没有把对应的元素值<span class=\"reference\">（m_data[2]和m_data[3]）</span>抹除，但这些值已经没有用处了，下次再进行入栈操作的时候会被入栈的新值覆盖。你可以在mian主函数中继续添加下面的代码并跟踪调试看看。</p><pre><code class=\"language-plain\">seqobj.Push(8100);\n</code></pre><p>在有的实现栈的范例代码中，会让m_top的初始值等于0<span class=\"reference\">（指向0的位置）</span>，那么判断栈是否为空的代码<span class=\"reference\">（IsEmpty函数）</span>也就是判断m_top是否等于0，而判断栈满<span class=\"reference\">（IsFull函数）</span>的条件也应该变成if (m_top &gt;= m_maxsize)。这种实现方式，实际就是让m_top代表下一个可以放入栈中的元素的下标，当数据入栈<span class=\"reference\">（Push函数）</span>时，代码行m_top++;和代码行m_data[m_top] = e;的执行就需要互换顺序，而当数据出栈<span class=\"reference\">（Pop函数）</span>时，代码行e = m_data[m_top];和代码行m_top--;的执行也需要互换顺序。</p><h3>共享栈</h3><p>除了刚才我们提到的常用操作外，这里再补充一个“共享栈”，也就是<strong>两个顺序栈</strong>共享存储空间。</p><p>为什么会提出这个概念呢？之前我们提到的顺序栈，一个比较大的缺点是保存数据的空间初始尺寸不好确定，如果太大，就会浪费空间，如果太小，那么存满数据后再入栈新数据就需要扩容，而扩容就又需要开辟一整块更大的新区域并将原有数据复制到新区域，操作起来比较耗费性能。</p><p>不过，我们可以设想一下。假设有两个相同数据类型的顺序栈，如果分别为他们开辟了保存数据的空间，那是不是就可能出现，第一个栈的数据已经存满了而另一个栈中还有很多存储空间的情形呢？那么，如果开辟出来一块保存数据的空间后，让这两个栈同时使用，也就是共享这块空间，是不是也许就能达到最大限度利用这块空间、减少浪费的目的呢？这就是共享栈的含义。</p><p>具体如何做到呢？我们还是先从代码层理解一下。</p><pre><code class=\"language-plain\">//共享栈\ntemplate &lt;typename T&gt; //T代表数组中元素的类型\nclass ShareStack\n{\npublic:\n\tShareStack(int length = InitSize)&nbsp; &nbsp; //构造函数，参数可以有默认值\n\t{\n\t\tm_data = new T[length];&nbsp; //为一维数组动态分配内存\n\t\tm_maxsize = length;&nbsp; &nbsp; &nbsp; //共享栈最多可以存储m_maxsize个数据元素\n\t\tm_top1 = -1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//顺序栈1的栈顶指针为-1，表示空栈\n\t\tm_top2 = length;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//顺序栈2的栈顶指针为length，表示空栈\n\t}\n\t~ShareStack()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //析构函数\n\t{\n\t\tdelete[] m_data;\n\t}\n\t\npublic:\n\tbool IsFull()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //判断共享栈是否已满\n\t{\n\t\tif (m_top1 + 1 == m_top2)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\t\n\tbool Push(int stackNum,const T&amp; e) //入栈（增加数据）,参数stackNum用于标识栈1还是栈2\n\t{\n\t\tif (IsFull() == true)\n\t\t{\n\t\t\t//共享栈满了，你也可以自行增加代码来支持动态增加共享栈的容量，这里简单处理，直接返回false\n\t\t\tcout &lt;&lt; \"共享栈已满，不能再进行入栈操作了!\" &lt;&lt; endl;\n\t\t\treturn false;\n\t\t}\n\t\tif (stackNum == 1)\n\t\t{\n\t\t\t//要入的是顺序栈1\n\t\t\tm_top1++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//栈顶指针向后走\n\t\t\tm_data[m_top1] = e;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//要入的是顺序栈2\n\t\t\tm_top2--;\n\t\t\tm_data[m_top2] = e;\n\t\t}\n\t\treturn true;\n\t}\n\t\t\n\tbool Pop(int stackNum, T&amp; e)&nbsp; //出栈（删除数据），也就是删除栈顶数据\n\t{\n\t\tif (stackNum == 1)\n\t\t{\n\t\t\t//要从顺序栈1出栈\n\t\t\tif (m_top1 == -1)\n\t\t\t{\n\t\t\t\tcout &lt;&lt; \"当前顺序栈1为空，不能进行出栈操作!\" &lt;&lt; endl;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\te = m_data[m_top1];&nbsp; //栈顶元素值返回到e中\n\t\t\tm_top1--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//要从顺序栈2出栈\n\t\t\tif (m_top2 == m_maxsize)\n\t\t\t{\n\t\t\t\tcout &lt;&lt; \"当前顺序栈2为空，不能进行出栈操作!\" &lt;&lt; endl;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\te = m_data[m_top2];\n\t\t\tm_top2++;\n\t\t}\n\t\treturn true;\n\t}\n\t\nprivate:\n\tT*&nbsp; m_data;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //存放共享栈中的元素\n\tint m_maxsize;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//动态数组最大容量\n\tint m_top1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //顺序栈1的栈顶指针\n\tint m_top2;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //顺序栈2的栈顶指针&nbsp; &nbsp;&nbsp;\n};\n</code></pre><p>从代码中可以看到，既然是两个顺序栈共享同一块内存空间，那么就需要引入两个栈顶指针<span class=\"reference\">（m_top1、m_top2）</span>来分别标识这两个顺序栈的栈顶位置。顺序栈1的栈底位置在最下面，而顺序栈2的栈底位置在最上面。</p><p>同时，注意阅读判断共享栈是否已满的代码<span class=\"reference\">（IsFull）</span>以及入栈和出栈<span class=\"reference\">（Push、Pop）</span>的代码。如果对顺序栈1进行入栈操作，则m_top1要递增，数据要从下向上存储。如果对顺序栈2进行入栈操作，则m_top2要递减，数据从上向下存储。这样的话，从逻辑上看，实现的是两个栈，但这两个栈又是共享着同一块物理内存的，从而提高内存利用率。把它转换成示意图，就会是图4的样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/49/8e/49c30d12031e2ee47ec69602958f918e.jpg?wh=2284x883\" alt=\"\" title=\"图4&nbsp; 共享栈存储数据示意图\"></p><p>一般来讲，对两个顺序栈的存储空间需求正好相反时，将这两个顺序栈放在一起当作共享栈使用意义才比较大。这里的需求相反，指的就是当一个栈进行入栈操作时，另一个栈同时在进行出栈操作，也就是此消彼长的情况。所以，你也可以把共享栈看成是一种顺序栈的实现技巧。</p><p>可以在main主函数中增加下面的代码来测试共享栈。</p><pre><code class=\"language-plain\">ShareStack&lt;int&gt; sharesobj(10);\nsharesobj.Push(1, 150);\nsharesobj.Push(2, 200);\nint eval2;\nsharesobj.Pop(1, eval2);\nsharesobj.Pop(1, eval2);\n</code></pre><h2>栈的链式存储（链式栈/链栈）</h2><p>所谓链式栈，就是链式存储方式来实现的栈。回忆前面讲过单链表的插入操作ListInsert方法，其第一个参数用于指定元素要插入的位置，如果把该参数值设置为1，就是链式栈的入栈操作。对于单链表的删除操作ListDelete方法，其参数用于指定要删除的元素位置，如果把该参数值也设置为1，就是链式栈的出栈操作。</p><p>可以看到，链式栈其实就是一个单链表，只不过人为的规定只能在单链表的第一个位置进行插入<span class=\"reference\">（入栈）</span>和删除<span class=\"reference\">（出栈）</span>操作，即链表头这一端是栈顶。</p><p>链式栈的实现代码和单链表的实现代码非常类似，可以把链式栈理解成受限的单链表。在讲解单链表时，可以带头结点也可以不带头节点，但对于链式栈来讲，考虑到只在链表头位置插入数据，所以链式栈一般不需要带头节点。</p><p>看一看链式栈的类定义以及常用操作。</p><pre><code class=\"language-plain\">//链式栈中每个节点的定义\ntemplate &lt;typename T&gt; //T代表数据元素的类型\nstruct StackNode\n{\n\tT&nbsp; &nbsp; &nbsp; &nbsp; data;&nbsp; //数据域，存放数据元素\n\tStackNode&lt;T&gt;* next;&nbsp; //指针域，指向下一个同类型（和本节点类型相同）节点\n};\n\t\n//链式栈的定义\ntemplate &lt;typename T&gt;\nclass LinkStack\n{\npublic:\n\tLinkStack();&nbsp; &nbsp; &nbsp; //构造函数\n\t~LinkStack();&nbsp; &nbsp; &nbsp;//析构函数\n\npublic:\n\tbool Push(const T&amp; e); //入栈元素e\n\tbool Pop(T&amp; e);&nbsp; &nbsp; &nbsp; &nbsp; //出栈（删除数据），也就是删除栈顶数据\n\tbool GetTop(T&amp; e);&nbsp; &nbsp; &nbsp;//读取栈顶元素，但该元素并没有出栈而是依旧在栈中\n\t\t\n\tvoid DispList();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//输出链式栈中的所有元素\n\tint&nbsp; ListLength();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//获取链式栈的长度\n\tbool Empty();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //判断链式栈是否为空\n\t\nprivate:\n\tStackNode&lt;T&gt;*&nbsp; &nbsp; &nbsp;m_top;&nbsp; &nbsp;//栈顶指针\n\tint&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m_length;//链式栈当前长度\n};\n\t\n//通过构造函数对链式栈进行初始化\ntemplate &lt;typename T&gt;\nLinkStack&lt;T&gt;::LinkStack()\n{\t\t\n\tm_top = nullptr;\n\tm_length = 0;&nbsp;&nbsp;\n}\n</code></pre><pre><code class=\"language-plain\">//入栈元素e，时间复杂度为O(1)\ntemplate &lt;typename T&gt;\nbool LinkStack&lt;T&gt;::Push(const T&amp; e)\n{\n\tStackNode&lt;T&gt;* node = new StackNode&lt;T&gt;;\n\tnode-&gt;data = e;\n\tnode-&gt;next = m_top;\n\tm_top = node;\t\t\n\tm_length++;\n\treturn true;\n}\n\t\n//出栈（删除数据），也就是删除栈顶数据，时间复杂度为O(1)\ntemplate &lt;typename T&gt;\nbool LinkStack&lt;T&gt;::Pop(T&amp; e)\n{\n\tif (Empty() == true) //链式栈为空\n\t\treturn false;\n\t\n\tStackNode&lt;T&gt;* p_willdel = m_top;\n\tm_top = m_top-&gt;next;\n\tm_length--; \n\te = p_willdel-&gt;data;\n\tdelete p_willdel;\n\treturn true;\n}\n\t\n//读取栈顶元素，但该元素并没有出栈而是依旧在栈中\ntemplate &lt;typename T&gt;\nbool LinkStack&lt;T&gt;::GetTop(T&amp; e)\n{\n\tif (Empty() == true) //链式栈为空\n\t\treturn false;\n\n\te = m_top-&gt;data;\n\treturn true;\n}\n</code></pre><pre><code class=\"language-plain\">//输出链式栈中的所有元素，时间复杂度为O(n)\ntemplate&lt;class T&gt;\nvoid LinkStack&lt;T&gt;::DispList()\n{\n\tif (Empty() == true) //链式栈为空\n\t\treturn;\n\t\t\n\tStackNode&lt;T&gt;* p = m_top;\n\twhile (p != nullptr)\n\t{\n\t\tcout &lt;&lt; p-&gt;data &lt;&lt; \" \";  //每个数据之间以空格分隔\n\t\tp = p-&gt;next;\n\t}\n\tcout &lt;&lt; endl; //换行\n}\n\t\n//获取链式栈的长度，时间复杂度为O(1)\ntemplate&lt;class T&gt;\nint  LinkStack&lt;T&gt;::ListLength()\n{\n\treturn m_length;\n}\n\t\n//判断链式栈是否为空，时间复杂度为O(1)\ntemplate&lt;class T&gt;\nbool LinkStack&lt;T&gt;::Empty()\n{\n\tif (m_top == nullptr) //链式栈为空\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\t\n//通过析构函数对链式栈进行资源释放\ntemplate &lt;typename T&gt;\nLinkStack&lt;T&gt;::~LinkStack()\n{\n\tT tmpnousevalue = {0};\n\twhile (Pop(tmpnousevalue) == true) {}//把栈顶元素删光，while循环也就退出了，此时也就是空栈了\n}\n</code></pre><p>在main主函数中，可以加入如下代码进行测试：</p><pre><code class=\"language-plain\">LinkStack&lt;int&gt; slinkobj;\nslinkobj.Push(12);\nslinkobj.Push(24);\nslinkobj.Push(48);\nslinkobj.Push(100);\nslinkobj.DispList();\n\t\nint eval3 = 0;\nslinkobj.Pop(eval3);\nslinkobj.DispList();\n</code></pre><p>与顺序栈相比，链式栈没有长度限制，不存在内存空间的浪费问题。但对于数据的入栈和出栈这些需要对数据进行定位的操作，顺序栈更加方便，而链式栈中的每个数据节点都需要额外的指针域以指向下一个数据节点，这会略微降低数据的存储效率，当然也会多占用一些内存。所以，如果要存储的数据数量无法提前预估，一般考虑使用链式栈，而如果数据的数量比较固定，可以考虑使用顺序栈。</p><p>在前面的讲解中，我们实现了顺序表<span class=\"reference\">（以数组的方式）</span>，又实现了各种各样的链表。在这节课，我们也通过数组的方式实现了顺序栈，通过单链表实现了链式栈。所以，把顺序栈看成是<strong>功能受限的数组</strong>，或把链式栈看成是功能受限的单链表，都是没有问题的。</p><p>可能你会认为，既然已经存在数组和单链表，直接使用不是更方便，为什么又创造出功能受限的栈来呢？你可以理解为，因为功能受限，所以使用起来也更加简单，错用误用的概率比数组、单链表等更低。</p><p>栈有很多应用，比如很多人都知道的在函数调用期间需要用栈来保存临时的参数信息、函数内局部变量信息、函数调用返回地址信息等。网上也有很多小例子演示栈的简单应用，比如利用栈来进行括号匹配的检验，利用栈来计算表达式结果等。有兴趣的话，你可以通过搜索引擎自行搜索了解。在后续的课程中，我也会用栈来实现诸如树的非递归遍历、记录节点路径信息等操作，相信那时你会对栈的应用有更深刻的理解。</p><h2>小结</h2><p>这节课，我们讲解了栈这种常用的数据结构，分别用代码实现了顺序栈<span class=\"reference\">（包括共享栈）</span>和链栈，同时针对栈的应用举了几个小例子。</p><p>栈的应用场合其实很多，上面也只是列举了几个范例进行简单演示，更多的案例需要你在实践中学习和体会。在实际应用中，有时为达到简化计算步骤的目的，还可以根据算法的需要引入两个甚至更多的栈来参与计算，每个栈都有各自的目的和分工，这都很平常，也不必觉得奇怪。后面的课程中，我们也会经常用到栈这种数据结构，届时你对栈的应用也会有更深层次的理解。</p><p>通过今天这一讲，你会发现，“在某一个事物的进行中需要保存一些数据，而将来又会以相反的顺序取回”这样的场合里，总会有“栈”的身影。</p><p>在STL<span class=\"reference\">（标准模板库）</span>中，提供了一个名字叫做stack的容器，该容器其实是一个类模板，这个类模板实现的就是栈的功能，所以通常情况下不需要你自己写栈的实现代码，用这个现成的即可。而这节课的内容，就可以让你对栈的理解更深入，从而更好地使用stack容器。</p><h2>课后思考</h2><p>在这节课的最后，我也给你留了几道思考题，可以想一想。</p><ol>\n<li>回忆一下你曾经在哪些场合使用过栈或遇到过对栈的应用，试着列举出一二。</li>\n<li>如果你有兴趣可以对stack容器的源码做适当的研究，当然，其源码比较繁琐和复杂，需要你有比较好的模板与泛型编程基础才能读懂。</li>\n<li>这节课讲的<strong>栈</strong>是一种数据结构。但从操作系统层面，也有栈这个概念，只不过操作系统层面所指的栈和我们这里所讲的栈不是同一个意思。有兴趣了解的话，可以在搜索引擎中输入“堆和栈的区别”这样的关键词来了解操作系统层面的栈指的是什么意思。</li>\n</ol><p>欢迎你在留言区和我互动。如果觉得有所收获，也可以把课程分享给更多的同学一起交流学习，我们下节课见！</p>","neighbors":{"left":{"article_title":"07｜静态链表：用一维数组表达的链表","id":634220},"right":{"article_title":"09｜队列：如何实现数据的先进先出？","id":636039}},"comments":[{"had_liked":false,"id":369641,"user_name":"徐石头","can_delete":false,"product_type":"c1","uid":1035885,"ip_address":"湖南","ucode":"D8FA8A64FB7E33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/6d/530df0dd.jpg","comment_is_top":false,"comment_ctime":1677746943,"is_pvip":true,"replies":[{"id":134697,"content":"👏👏😂😂","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1677770894,"ip_address":"广东","comment_id":369641,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"1. 操作系统调用栈，浏览器前进后退功能\n3. 内存中的堆栈和数据结构堆栈不是一个概念，内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。\n操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈，符合先进后出的特性。\n从调用函数进入被调用函数，对于数据来说，变化的是作用域。所以只要能保证每进入一个新的函数，都要是一个新的作用域。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。\n用Go实现的数组栈和链表栈  https:&#47;&#47;github.com&#47;xushuhui&#47;algorithm-and-data-structure&#47;tree&#47;master&#47;datastructure&#47;stack","like_count":2,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607332,"discussion_content":"👏👏😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677770894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370589,"user_name":"Yj.yolo","can_delete":false,"product_type":"c1","uid":2814082,"ip_address":"中国台湾","ucode":"0ED1B41F124061","user_header":"https://static001.geekbang.org/account/avatar/00/2a/f0/82/f235d91d.jpg","comment_is_top":false,"comment_ctime":1678987725,"is_pvip":false,"replies":[{"id":135222,"content":"👏👏👏👏","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1679014175,"ip_address":"广东","comment_id":370589,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"1、操作系统中的调用栈：在操作系统中，每个进程都有一个独立的调用栈，用于存储函数调用的返回地址和参数。当程序执行一个函数时，它的参数和返回地址被压入该进程的调用栈中。当函数返回时，这些参数和返回地址被弹出栈。\n2、网络协议中的数据包处理：在网络协议中，数据包处理通常采用栈的方式进行，以确保数据包能够正确地路由。数据包处理时，每个网络层都会将自己的头部信息入栈，并在发送时逆序弹出栈，以保证数据包的正确传输。\n3、数据库系统中的事务处理：在数据库系统中，事务处理可以采用栈来实现。每次进行事务操作时，会将操作入栈，以便回滚时能够按照相反的顺序执行操作。（事务的实现可能会有所不同。除了使用栈来管理事务操作序列外，还可以使用其他数据结构，如链表、数组等来实现事务。此外，不同的数据库系统还可能会采用不同的事务模型和隔离级别，以满足不同的应用需求。）\n4、操作系统中的中断处理：在操作系统中，中断处理也可以采用栈来实现。当系统发生中断时，将当前程序的状态入栈，然后转到中断处理程序。当中断处理程序执行完毕后，将保存的程序状态弹出栈，恢复原来的程序执行。\n6、撤销操作：在编辑器中，撤销操作通常也可以使用栈来实现，将每次编辑的操作记录在栈中，撤销时将最近的操作出栈并撤销。","like_count":1,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609522,"discussion_content":"👏👏👏👏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679014175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392955,"user_name":"Fang","can_delete":false,"product_type":"c1","uid":3540228,"ip_address":"上海","ucode":"6F026565387364","user_header":"https://static001.geekbang.org/account/avatar/00/36/05/04/8deca125.jpg","comment_is_top":false,"comment_ctime":1722311122,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"学完就忘， ","like_count":0}]}