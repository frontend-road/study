{"id":93014,"title":"14 | 进程数据结构（下）：项目多了就需要项目管理系统","content":"<p>上两节，我们解读了task_struct的大部分的成员变量。这样一个任务执行的方方面面，都可以很好地管理起来，但是其中有一个问题我们没有谈。在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。那如何将用户态的执行和内核态的执行串起来呢？</p><p>这就需要以下两个重要的成员变量：</p><pre><code>struct thread_info\t\tthread_info;\nvoid  *stack;\n</code></pre><h2>用户态函数栈</h2><p>在用户态中，程序的执行往往是一个函数调用另一个函数。函数调用都是通过栈来进行的。我们前面大致讲过函数栈的原理，今天我们仔细分析一下。</p><p>函数调用其实也很简单。如果你去看汇编语言的代码，其实就是指令跳转，从代码的一个地方跳到另外一个地方。这里比较棘手的问题是，参数和返回地址应该怎么传递过去呢？</p><p>我们看函数的调用过程，A调用B、调用C、调用D，然后返回C、返回B、返回A，这是一个后进先出的过程。有没有觉得这个过程很熟悉？没错，咱们数据结构里学的栈，也是后进先出的，所以用栈保存这些最合适。</p><p>在进程的内存空间里面，栈是一个从高地址到低地址，往下增长的结构，也就是上面是栈底，下面是栈顶，入栈和出栈的操作都是从下面的栈顶开始的。</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/2e/aec865abccf0308155f4138cc905972e.jpg?wh=1846*1619\" alt=\"\"></p><p>我们先来看32位操作系统的情况。在CPU里，<strong>ESP</strong>（Extended Stack Pointer）是栈顶指针寄存器，入栈操作Push和出栈操作Pop指令，会自动调整ESP的值。另外有一个寄存器<strong>EBP</strong>（Extended Base Pointer），是栈基地址指针寄存器，指向当前栈帧的最底部。</p><!-- [[[read_end]]] --><p>例如，A调用B，A的栈里面包含A函数的局部变量，然后是调用B的时候要传给它的参数，然后返回A的地址，这个地址也应该入栈，这就形成了A的栈帧。接下来就是B的栈帧部分了，先保存的是A栈帧的栈底位置，也就是EBP。因为在B函数里面获取A传进来的参数，就是通过这个指针获取的，接下来保存的是B的局部变量等等。</p><p>当B返回的时候，返回值会保存在EAX寄存器中，从栈中弹出返回地址，将指令跳转回去，参数也从栈中弹出，然后继续执行A。</p><p>对于64位操作系统，模式多少有些不一样。因为64位操作系统的寄存器数目比较多。rax用于保存函数调用的返回结果。栈顶指针寄存器变成了rsp，指向栈顶位置。堆栈的Pop和Push操作会自动调整rsp，栈基指针寄存器变成了rbp，指向当前栈帧的起始位置。</p><p>改变比较多的是参数传递。rdi、rsi、rdx、rcx、r8、r9这6个寄存器，用于传递存储函数调用时的6个参数。如果超过6的时候，还是需要放到栈里面。</p><p>然而，前6个参数有时候需要进行寻址，但是如果在寄存器里面，是没有地址的，因而还是会放到栈里面，只不过放到栈里面的操作是被调用函数做的。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/c0/770b0036a8b2695463cd95869f5adec0.jpg?wh=1840*1973\" alt=\"\"></p><p>以上的栈操作，都是在进程的内存空间里面进行的。</p><h2>内核态函数栈</h2><p>接下来，我们通过系统调用，从进程的内存空间到内核中了。内核中也有各种各样的函数调用来调用去的，也需要这样一个机制，这该怎么办呢？</p><p>这时候，上面的成员变量stack，也就是内核栈，就派上了用场。</p><p>Linux给每个task都分配了内核栈。在32位系统上arch/x86/include/asm/page_32_types.h，是这样定义的：一个PAGE_SIZE是4K，左移一位就是乘以2，也就是8K。</p><pre><code>#define THREAD_SIZE_ORDER\t1\n#define THREAD_SIZE\t\t(PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)\n</code></pre><p>内核栈在64位系统上arch/x86/include/asm/page_64_types.h，是这样定义的：在PAGE_SIZE的基础上左移两位，也即16K，并且要求起始地址必须是8192的整数倍。</p><pre><code>#ifdef CONFIG_KASAN\n#define KASAN_STACK_ORDER 1\n#else\n#define KASAN_STACK_ORDER 0\n#endif\n\n\n#define THREAD_SIZE_ORDER\t(2 + KASAN_STACK_ORDER)\n#define THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)\n</code></pre><p>内核栈是一个非常特殊的结构，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/31/2d/31d15bcd2a053235b5590977d12ffa2d.jpeg?wh=2126*1553\" alt=\"\"></p><p>这段空间的最低位置，是一个thread_info结构。这个结构是对task_struct结构的补充。因为task_struct结构庞大但是通用，不同的体系结构就需要保存不同的东西，所以往往与体系结构有关的，都放在thread_info里面。</p><p>在内核代码里面有这样一个union，将thread_info和stack放在一起，在include/linux/sched.h文件中就有。</p><pre><code>union thread_union {\n#ifndef CONFIG_THREAD_INFO_IN_TASK\n\tstruct thread_info thread_info;\n#endif\n\tunsigned long stack[THREAD_SIZE/sizeof(long)];\n};\n</code></pre><p>这个union就是这样定义的，开头是thread_info，后面是stack。</p><p>在内核栈的最高地址端，存放的是另一个结构pt_regs，定义如下。其中，32位和64位的定义不一样。</p><pre><code>#ifdef __i386__\nstruct pt_regs {\n\tunsigned long bx;\n\tunsigned long cx;\n\tunsigned long dx;\n\tunsigned long si;\n\tunsigned long di;\n\tunsigned long bp;\n\tunsigned long ax;\n\tunsigned long ds;\n\tunsigned long es;\n\tunsigned long fs;\n\tunsigned long gs;\n\tunsigned long orig_ax;\n\tunsigned long ip;\n\tunsigned long cs;\n\tunsigned long flags;\n\tunsigned long sp;\n\tunsigned long ss;\n};\n#else \nstruct pt_regs {\n\tunsigned long r15;\n\tunsigned long r14;\n\tunsigned long r13;\n\tunsigned long r12;\n\tunsigned long bp;\n\tunsigned long bx;\n\tunsigned long r11;\n\tunsigned long r10;\n\tunsigned long r9;\n\tunsigned long r8;\n\tunsigned long ax;\n\tunsigned long cx;\n\tunsigned long dx;\n\tunsigned long si;\n\tunsigned long di;\n\tunsigned long orig_ax;\n\tunsigned long ip;\n\tunsigned long cs;\n\tunsigned long flags;\n\tunsigned long sp;\n\tunsigned long ss;\n/* top of stack page */\n};\n#endif \n</code></pre><p>看到这个是不是很熟悉？咱们在讲系统调用的时候，已经多次见过这个结构。当系统调用从用户态到内核态的时候，首先要做的第一件事情，就是将用户态运行过程中的CPU上下文保存起来，其实主要就是保存在这个结构的寄存器变量里。这样当从内核系统调用返回的时候，才能让进程在刚才的地方接着运行下去。</p><p>如果我们对比系统调用那一节的内容，你会发现系统调用的时候，压栈的值的顺序和struct pt_regs中寄存器定义的顺序是一样的。</p><p>在内核中，CPU的寄存器ESP或者RSP，已经指向内核栈的栈顶，在内核态里的调用都有和用户态相似的过程。</p><h2>通过task_struct找内核栈</h2><p>如果有一个task_struct的stack指针在手，你可以通过下面的函数找到这个线程内核栈：</p><pre><code>static inline void *task_stack_page(const struct task_struct *task)\n{\n\treturn task-&gt;stack;\n}\n</code></pre><p>从task_struct如何得到相应的pt_regs呢？我们可以通过下面的函数：</p><pre><code>/*\n * TOP_OF_KERNEL_STACK_PADDING reserves 8 bytes on top of the ring0 stack.\n * This is necessary to guarantee that the entire &quot;struct pt_regs&quot;\n * is accessible even if the CPU haven't stored the SS/ESP registers\n * on the stack (interrupt gate does not save these registers\n * when switching to the same priv ring).\n * Therefore beware: accessing the ss/esp fields of the\n * &quot;struct pt_regs&quot; is possible, but they may contain the\n * completely wrong values.\n */\n#define task_pt_regs(task) \\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned long __ptr = (unsigned long)task_stack_page(task);\t\\\n\t__ptr += THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING;\t\t\\\n\t((struct pt_regs *)__ptr) - 1;\t\t\t\t\t\\\n})\n</code></pre><p>你会发现，这是先从task_struct找到内核栈的开始位置。然后这个位置加上THREAD_SIZE就到了最后的位置，然后转换为struct pt_regs，再减一，就相当于减少了一个pt_regs的位置，就到了这个结构的首地址。</p><p>这里面有一个TOP_OF_KERNEL_STACK_PADDING，这个的定义如下：</p><pre><code>#ifdef CONFIG_X86_32\n# ifdef CONFIG_VM86\n#  define TOP_OF_KERNEL_STACK_PADDING 16\n# else\n#  define TOP_OF_KERNEL_STACK_PADDING 8\n# endif\n#else\n# define TOP_OF_KERNEL_STACK_PADDING 0\n#endif\n</code></pre><p>也就是说，32位机器上是8，其他是0。这是为什么呢？因为压栈pt_regs有两种情况。我们知道，CPU用ring来区分权限，从而Linux可以区分内核态和用户态。</p><p>因此，第一种情况，我们拿涉及从用户态到内核态的变化的系统调用来说。因为涉及权限的改变，会压栈保存SS、ESP寄存器的，这两个寄存器共占用8个byte。</p><p>另一种情况是，不涉及权限的变化，就不会压栈这8个byte。这样就会使得两种情况不兼容。如果没有压栈还访问，就会报错，所以还不如预留在这里，保证安全。在64位上，修改了这个问题，变成了定长的。</p><p>好了，现在如果你task_struct在手，就能够轻松得到内核栈和内核寄存器。</p><h2>通过内核栈找task_struct</h2><p>那如果一个当前在某个CPU上执行的进程，想知道自己的task_struct在哪里，又该怎么办呢？</p><p>这个艰巨的任务要交给thread_info这个结构。</p><pre><code>struct thread_info {\n\tstruct task_struct\t*task;\t\t/* main task structure */\n\t__u32\t\t\tflags;\t\t/* low level flags */\n\t__u32\t\t\tstatus;\t\t/* thread synchronous flags */\n\t__u32\t\t\tcpu;\t\t/* current CPU */\n\tmm_segment_t\t\taddr_limit;\n\tunsigned int\t\tsig_on_uaccess_error:1;\n\tunsigned int\t\tuaccess_err:1;\t/* uaccess failed */\n};\n</code></pre><p>这里面有个成员变量task指向task_struct，所以我们常用current_thread_info()-&gt;task来获取task_struct。</p><pre><code>static inline struct thread_info *current_thread_info(void)\n{\n\treturn (struct thread_info *)(current_top_of_stack() - THREAD_SIZE);\n}\n</code></pre><p>而thread_info的位置就是内核栈的最高位置，减去THREAD_SIZE，就到了thread_info的起始地址。</p><p>但是现在变成这样了，只剩下一个flags。</p><pre><code>struct thread_info {\n        unsigned long           flags;          /* low level flags */\n};\n</code></pre><p>那这时候怎么获取当前运行中的task_struct呢？current_thread_info有了新的实现方式。</p><p>在include/linux/thread_info.h中定义了current_thread_info。</p><pre><code>#include &lt;asm/current.h&gt;\n#define current_thread_info() ((struct thread_info *)current)\n#endif\n</code></pre><p>那current又是什么呢？在arch/x86/include/asm/current.h中定义了。</p><pre><code>struct task_struct;\n\n\nDECLARE_PER_CPU(struct task_struct *, current_task);\n\n\nstatic __always_inline struct task_struct *get_current(void)\n{\n\treturn this_cpu_read_stable(current_task);\n}\n\n\n#define current get_current\n</code></pre><p>到这里，你会发现，新的机制里面，每个CPU运行的task_struct不通过thread_info获取了，而是直接放在Per CPU 变量里面了。</p><p>多核情况下，CPU是同时运行的，但是它们共同使用其他的硬件资源的时候，我们需要解决多个CPU之间的同步问题。</p><p>Per CPU变量是内核中一种重要的同步机制。顾名思义，Per CPU变量就是为每个CPU构造一个变量的副本，这样多个CPU各自操作自己的副本，互不干涉。比如，当前进程的变量current_task就被声明为Per CPU变量。</p><p>要使用Per CPU变量，首先要声明这个变量，在arch/x86/include/asm/current.h中有：</p><pre><code>DECLARE_PER_CPU(struct task_struct *, current_task);\n</code></pre><p>然后是定义这个变量，在arch/x86/kernel/cpu/common.c中有：</p><pre><code>DEFINE_PER_CPU(struct task_struct *, current_task) = &amp;init_task;\n</code></pre><p>也就是说，系统刚刚初始化的时候，current_task都指向init_task。</p><p>当某个CPU上的进程进行切换的时候，current_task被修改为将要切换到的目标进程。例如，进程切换函数__switch_to就会改变current_task。</p><pre><code>__visible __notrace_funcgraph struct task_struct *\n__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n......\nthis_cpu_write(current_task, next_p);\n......\nreturn prev_p;\n}\n</code></pre><p>当要获取当前的运行中的task_struct的时候，就需要调用this_cpu_read_stable进行读取。</p><pre><code>#define this_cpu_read_stable(var)       percpu_stable_op(&quot;mov&quot;, var)\n</code></pre><p>好了，现在如果你是一个进程，正在某个CPU上运行，就能够轻松得到task_struct了。</p><h2>总结时刻</h2><p>这一节虽然只介绍了内核栈，但是内容更加重要。如果说task_struct的其他成员变量都是和进程管理有关的，内核栈是和进程运行有关系的。</p><p>我这里画了一张图总结一下32位和64位的工作模式，左边是32位的，右边是64位的。</p><ul>\n<li>\n<p>在用户态，应用程序进行了至少一次函数调用。32位和64的传递参数的方式稍有不同，32位的就是用函数栈，64位的前6个参数用寄存器，其他的用函数栈。</p>\n</li>\n<li>\n<p>在内核态，32位和64位都使用内核栈，格式也稍有不同，主要集中在pt_regs结构上。</p>\n</li>\n<li>\n<p>在内核态，32位和64位的内核栈和task_struct的关联关系不同。32位主要靠thread_info，64位主要靠Per-CPU变量。</p>\n</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/82/5c/82ba663aad4f6bd946d48424196e515c.jpeg?wh=3811*2824\" alt=\"\"></p><h2>课堂练习</h2><p>这一节讲函数调用的时候，我们讲了函数栈的工作模式。请你写一个程序，然后编译为汇编语言，打开看一下，函数栈是如何起作用的。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，<span class=\"orange\">反复研读</span>。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","comments":[{"had_liked":false,"id":90710,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1556614457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"276434521401","product_id":100024701,"comment_content":"- 用户态&#47;内核态切换执行如何串起来<br>- 用户态函数栈; 通过 JMP + 参数 + 返回地址 调用函数<br>    - 栈内存空间从高到低增长<br>    - 32位栈结构: 栈帧包含 前一个帧的 EBP + 局部变量 + N个参数 + 返回地址<br>        - ESP: 栈顶指针; EBP: 栈基址(栈帧最底部, 局部变量起始)<br>        - 返回值保存在 EAX 中<br>    - 64位栈结构: 结构类似<br>        - rax 保存返回结果; rsp 栈顶指针; rbp 栈基指针<br>        - 参数传递时, 前 6个放寄存器中(再由被调用函数 push 进自己的栈, 用以寻址), 参数超过 6个压入栈中<br>- 内核栈结构: <br>    - Linux 为每个 task 分配了内核栈, 32位(8K), 64位(16K)<br>    - 栈结构: [预留8字节 +] pt_regs + 内核栈 + 头部 thread_info<br>    - thread_info 是 task_struct 的补充, 存储于体系结构有关的内容<br>    - pt_regs 用以保存用户运行上下文, 通过 push 寄存器到栈中保存<br>    - 通过 task_struct 找到内核栈<br>        - 直接由 task_struct 内的 stack 直接得到指向 thread_info 的指针<br>    - 通过内核栈找到 task_struct<br>        - 32位 直接由 thread_info 中的指针得到<br>        - 64位 每个 CPU 当前运行进程的 task_struct 的指针存放到 Per CPU 变量 current_task 中; 可调用 this_cpu_read_stable 进行读取","like_count":65},{"had_liked":false,"id":90417,"user_name":"第九天魔王","can_delete":false,"product_type":"c1","uid":1135246,"ip_address":"","ucode":"E98DDC3E5125CB","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/8e/07db8450.jpg","comment_is_top":false,"comment_ctime":1556514920,"is_pvip":false,"replies":[{"id":"32637","content":"谢谢鼓励","user_name":"作者回复","comment_id":90417,"uid":"1001590","ip_address":"","utype":1,"ctime":1556812243,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"164765272168","product_id":100024701,"comment_content":"从网络协议课学到这里，满满的干货啊。特别是配图，太用心了，一看就是非常有心才能做出来的。谢谢刘老师！","like_count":39,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448513,"discussion_content":"谢谢鼓励","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556812243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90419,"user_name":"青石","can_delete":false,"product_type":"c1","uid":1215531,"ip_address":"","ucode":"B0056AD6453322","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg","comment_is_top":false,"comment_ctime":1556515565,"is_pvip":false,"replies":[{"id":"49507","content":"赞，推荐这种查资料的方式，这样学到的东西就多多了","user_name":"作者回复","comment_id":90419,"uid":"1001590","ip_address":"","utype":1,"ctime":1567676988,"user_name_real":"刘超@网易云"}],"discussion_count":3,"race_medal":0,"score":"53096123117","product_id":100024701,"comment_content":"看这篇内容时，查了几篇资料。<br><br>在汇编代码中，函数调用的参数传递是通过把参数依次放在靠近调用者的栈的顶部来实现的。调用者获取参数时，只要相对于当前帧指针的向上偏移即可取到参数。即取调用者函数参数时执行movl 8(%ebp), %edx。","like_count":13,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448515,"discussion_content":"赞，推荐这种查资料的方式，这样学到的东西就多多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567676988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2365071,"avatar":"https://static001.geekbang.org/account/avatar/00/24/16/8f/c1baee96.jpg","nickname":"muse","note":"","ucode":"43B0C82639E39F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368781,"discussion_content":"这样的话，老师文中画的图就不对了是吗，因为图中显示的是在调用附近把参数压栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618831168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2365071,"avatar":"https://static001.geekbang.org/account/avatar/00/24/16/8f/c1baee96.jpg","nickname":"muse","note":"","ucode":"43B0C82639E39F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390094,"discussion_content":"图没错，但是根据A的EBP来计算有问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629648894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368781,"ip_address":""},"score":390094,"extra":""}]}]},{"had_liked":false,"id":90415,"user_name":"hua168","can_delete":false,"product_type":"c1","uid":1065255,"ip_address":"","ucode":"CFF9A7E86EBA48","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/27/3ff1a1d6.jpg","comment_is_top":false,"comment_ctime":1556514783,"is_pvip":false,"replies":[{"id":"32638","content":"啊，好的，看来应该给英文名加作者的","user_name":"作者回复","comment_id":90415,"uid":"1001590","ip_address":"","utype":1,"ctime":1556812292,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"27326318559","product_id":100024701,"comment_content":"老师，我求您了，能不能把您讲的专栏中涉及的书名加个豆瓣之类的链接😂😂，有些都重名，作者不同，😭😭不带这样玩的😭😭😭","like_count":6,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448512,"discussion_content":"啊，好的，看来应该给英文名加作者的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556812292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131953,"user_name":"ZYecho","can_delete":false,"product_type":"c1","uid":1356589,"ip_address":"","ucode":"9D156DD30C581E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLh73kPzAKhz7YxUribqF6QKFiahhVAbwpgVLSRicA68c6ZFA7vUBJY1ves3LVvibrypROyI7awv47eSA/132","comment_is_top":false,"comment_ctime":1567991867,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"18747861051","product_id":100024701,"comment_content":"为什么32位的处理器还需要单独压ss和esp呢？ pt_regs结构体中不是已经含有这两个寄存器了么？谢谢老师","like_count":4,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386451,"discussion_content":"ss以及esp寄存器只能存放当前线程的信息；当切换线程的时候，寄存器内容需要进行保存；32bit系统是将这些寄存器内容直接保存到物理内存结构中；64bit系统则是放置到了其他寄存器中，机制不一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627599155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312074,"discussion_content":" pt_regs结构体位于内核栈中，它的ss esp flags cs ip 在触发中断时由CPU控制单元帮忙完成入栈。剩余内容由SAVE_ALL使用push入栈。注意这里还涉及到由用户栈切换到内核栈的过程，即更新ss esp寄存器，这部分内容也是由CPU控制单元完成的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602579028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039256,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/98/60ced4c8.jpg","nickname":"涛涛","note":"","ucode":"4C47A3FB33EEFE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283965,"discussion_content":"https://www.cnblogs.com/chaozhu/p/6283495.html 可以看看","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592407619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2766280,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/JHzZynEKL2CibTaxCZV3XOs1bJJFqbmwhmibd4U5njlaNVWPrbre1Qha2XUx1dcQ99iaYFl13PyjlYQ0rcl9N5vEg/132","nickname":"wsxzei","note":"","ucode":"8527ED444BFC73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1039256,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/98/60ced4c8.jpg","nickname":"涛涛","note":"","ucode":"4C47A3FB33EEFE","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":579890,"discussion_content":"谢谢，这篇文章写得很清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657758081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283965,"ip_address":""},"score":579890,"extra":""}]}]},{"had_liked":false,"id":131493,"user_name":"ZYecho","can_delete":false,"product_type":"c1","uid":1356589,"ip_address":"","ucode":"9D156DD30C581E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLh73kPzAKhz7YxUribqF6QKFiahhVAbwpgVLSRicA68c6ZFA7vUBJY1ves3LVvibrypROyI7awv47eSA/132","comment_is_top":false,"comment_ctime":1567767348,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18747636532","product_id":100024701,"comment_content":"老师您好，在 64 位上，修改了这个问题，变成了定长的。这句话怎么理解呢？<br>具体在64位上是如何进行操作的呢？","like_count":4,"discussions":[{"author":{"id":1114753,"avatar":"https://static001.geekbang.org/account/avatar/00/11/02/81/489e1cd4.jpg","nickname":"忘忧草的约定","note":"","ucode":"F99D2F5D179B2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382469,"discussion_content":"应该是当权限没有变化的时候，也保留一定长度的地址位吧，以保证寻址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625583766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143672,"user_name":"希夷","can_delete":false,"product_type":"c1","uid":1028673,"ip_address":"","ucode":"2E3E86AC7A19EC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b2/41/d9dcc7ef.jpg","comment_is_top":false,"comment_ctime":1571754238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14456656126","product_id":100024701,"comment_content":"内核栈这个图里边预留8个字节下边的pg_regs，应该是pt_regs吧？","like_count":3},{"had_liked":false,"id":98529,"user_name":"嘉木","can_delete":false,"product_type":"c1","uid":1317999,"ip_address":"","ucode":"AF4877693782C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/1c/6f/3ea2a599.jpg","comment_is_top":false,"comment_ctime":1559018223,"is_pvip":false,"replies":[{"id":"35376","content":"后面讲切换的时候会讲，用户栈相关寄存器在pt_regs中，用户栈的内存在虚拟地址空间，不会冲突","user_name":"作者回复","comment_id":98529,"uid":"1001590","ip_address":"","utype":1,"ctime":1559100335,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"14443920111","product_id":100024701,"comment_content":"有个疑问，两个进程切换时，用户栈的上下文保存在哪？","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451722,"discussion_content":"后面讲切换的时候会讲，用户栈相关寄存器在pt_regs中，用户栈的内存在虚拟地址空间，不会冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559100335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96858,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1558524199,"is_pvip":true,"replies":[{"id":"49265","content":"mm里面有的","user_name":"作者回复","comment_id":96858,"uid":"1001590","ip_address":"","utype":1,"ctime":1567608475,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"14443426087","product_id":100024701,"comment_content":"为什么用户态的栈不需要 task_struct 维护一个类似 *stack 的指针呢？","like_count":4,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451036,"discussion_content":"mm里面有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567608475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90291,"user_name":"Liber","can_delete":false,"product_type":"c1","uid":1244231,"ip_address":"","ucode":"A5CBFDB15A7745","user_header":"https://static001.geekbang.org/account/avatar/00/12/fc/47/a4be64d8.jpg","comment_is_top":false,"comment_ctime":1556467368,"is_pvip":false,"replies":[{"id":"49511","content":"是的，是的，是自动发的。","user_name":"作者回复","comment_id":90291,"uid":"1001590","ip_address":"","utype":1,"ctime":1567677068,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"14441369256","product_id":100024701,"comment_content":"0点自动发，应该是自动发布的吧","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448456,"discussion_content":"是的，是的，是自动发的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567677068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117453,"user_name":"k先生","can_delete":false,"product_type":"c1","uid":1221532,"ip_address":"","ucode":"76D292DC62B52D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/9c/8a14b7db.jpg","comment_is_top":false,"comment_ctime":1564050902,"is_pvip":false,"replies":[{"id":"46413","content":"不是的，对着图可以看的比较清楚","user_name":"作者回复","comment_id":117453,"uid":"1001590","ip_address":"","utype":1,"ctime":1566299248,"user_name_real":"刘超@网易云"}],"discussion_count":6,"race_medal":0,"score":"10153985494","product_id":100024701,"comment_content":"老师，有个问题能否解答？<br>task_struct找内核栈过程理解了，但是反过来找，这句“而 thread_info 的位置就是内核栈的最高位置，减去 THREAD_SIZE，就到了 thread_info 的起始地址。”没懂，烦请解答一下<br><br>这里说的最高位置应该是栈顶，到了栈顶就是thread_info最低地址，那不就直接找到了吗","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459978,"discussion_content":"不是的，对着图可以看的比较清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566299248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1576512,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0e/40/49a71ed8.jpg","nickname":"八戒","note":"","ucode":"3F262A99492A65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353639,"discussion_content":"还是没看懂，这里的最高位置是栈顶还是栈底还是其他？\n还有，看图所示thread_info不就在栈顶位置吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615182984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312077,"discussion_content":"这里说的是栈内存空间的最顶部，不是栈顶，它比实际栈顶的位置的地址小，除非满了，他们相等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602579236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030816,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/a0/f03d20cd.jpg","nickname":"likun","note":"","ucode":"9145ED059CCC6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202820,"discussion_content":"这里说的最高位追是栈底的内存地址，对于栈的push操作是从高地址位向低地址位推进的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583949347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1519189,"avatar":"","nickname":"Geek_00711d","note":"","ucode":"2B0B98853D4CCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5097,"discussion_content":"栈底","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565943039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1296815,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoqEsRcQ5icwkgTDBX9JA8iaqohBdIGhxMXLFDSevEXqm5sAarw3hKeEHzxkoEJ5sx7plibcRPqmicAlQ/132","nickname":"ROY","note":"","ucode":"FB99E4456D2E5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3378,"discussion_content":"同问\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564447824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136073,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1569339001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5864306297","product_id":100024701,"comment_content":"看懂这章,需要知道进程的内存分布图","like_count":1},{"had_liked":false,"id":123737,"user_name":"...","can_delete":false,"product_type":"c1","uid":1142098,"ip_address":"","ucode":"9D73E00133C236","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/52/404912c3.jpg","comment_is_top":false,"comment_ctime":1565749080,"is_pvip":false,"replies":[{"id":"46290","content":"上面是栈的底部","user_name":"作者回复","comment_id":123737,"uid":"1001590","ip_address":"","utype":1,"ctime":1566282087,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"5860716376","product_id":100024701,"comment_content":"老师有个疑问 A调用B B应该是被调用者吧 是不是应该放在图上面部分","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462792,"discussion_content":"上面是栈的底部","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566282087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043293,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/5d/2467ad6c.jpg","nickname":"木心","note":"","ucode":"538A3B9B214BF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177723,"discussion_content":"调用者和被调用者搞反了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582119931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90452,"user_name":"青石","can_delete":false,"product_type":"c1","uid":1215531,"ip_address":"","ucode":"B0056AD6453322","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg","comment_is_top":false,"comment_ctime":1556522918,"is_pvip":false,"replies":[{"id":"32636","content":"不仅仅切换这个变量，要切换的还挺多的","user_name":"作者回复","comment_id":90452,"uid":"1001590","ip_address":"","utype":1,"ctime":1556812210,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"5851490214","product_id":100024701,"comment_content":"在12节里面提到“Linux的任务管理由统一的结构task_struct进行管理”。那么多核CPU的任务切换时，是不是就是将current_task切换到另一个task_struct呢？<br><br>THREAD_SIZE是固定的大小，32位系统中是8K（页大小左移一位），64位系统是16K（页大小左移二位）。TOP_OF_KERNEL_STACK_PADDING就是图“内核栈是一个非常特殊的结构”中的“预留8个字节”。<br><br>通过task_struct找内核栈的过程：<br>1. task_struct找内核栈是通过stack指针，直接找到内核线程栈，stack指针记录的是内核栈的首地址。<br>2. task_struck找内核寄存器是通过 内核栈的首地址（1中的stack指针） + (THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING)定位到pt_regs的最高位地址，再减一得到pt_regs的最低位地址（首地址）。","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448531,"discussion_content":"不仅仅切换这个变量，要切换的还挺多的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556812210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1440772,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","nickname":"Kevin⚡️Zhou","note":"","ucode":"C0FC2673705212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25323,"discussion_content":"这个减1得到的不是pt_regs的最低为地址, 在栈中其实是ss的起始地址,也就是图上栈靠近顶部的位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570501523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90306,"user_name":"石维康","can_delete":false,"product_type":"c1","uid":1067564,"ip_address":"","ucode":"E39ED8416B2C01","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","comment_is_top":false,"comment_ctime":1556471409,"is_pvip":false,"replies":[{"id":"49510","content":"能的。","user_name":"作者回复","comment_id":90306,"uid":"1001590","ip_address":"","utype":1,"ctime":1567677050,"user_name_real":"刘超@网易云"}],"discussion_count":3,"race_medal":0,"score":"5851438705","product_id":100024701,"comment_content":"文中说“接下来就是 B 的栈帧部分了，先保存的是 A 栈帧的栈底位置,也就是 EBP。因为在 B 函数里面获取 A 传进来的参数，就是通过这个指针获取的，”感觉主流编译器还是直接能通过当前 RBP 或者 RSP 来进行偏移定位到传进来的参数了吧？保存这个 A 栈底位置更多的是为了回复 A 的现场吧？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448461,"discussion_content":"能的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567677050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165971,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ca/93/181b8e65.jpg","nickname":"sinfool","note":"","ucode":"AEA84CCBB2D89D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31587,"discussion_content":"同感！我也在这里疑惑了好一会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570937730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1470635,"avatar":"https://static001.geekbang.org/account/avatar/00/16/70/ab/7a7399a7.jpg","nickname":"tj.•","note":"","ucode":"078D80A68491E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8913,"discussion_content":"这句话，我看着很懵。老师能不能解释一下啊。听不懂啊，为什么能获取到参数呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568099124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347514,"user_name":"NeverSeeYouAgainBUG","can_delete":false,"product_type":"c1","uid":2930836,"ip_address":"","ucode":"1B0E8CA284C181","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b8/94/d20583ef.jpg","comment_is_top":false,"comment_ctime":1654096422,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654096422","product_id":100024701,"comment_content":"哇，老师您真是巨佬啊，巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨巨佬","like_count":0},{"had_liked":false,"id":346061,"user_name":"乔克叔叔","can_delete":false,"product_type":"c1","uid":2350246,"ip_address":"","ucode":"31F524DC1E1498","user_header":"https://static001.geekbang.org/account/avatar/00/23/dc/a6/6c2728b9.jpg","comment_is_top":false,"comment_ctime":1652797519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652797519","product_id":100024701,"comment_content":"面试问到max（int a，int b）怎么压栈出栈，是想问汇编？","like_count":0},{"had_liked":false,"id":337061,"user_name":"勿忘初心🍃","can_delete":false,"product_type":"c1","uid":1341504,"ip_address":"","ucode":"02A5D0C357ADE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/78/40/7ca70d5d.jpg","comment_is_top":false,"comment_ctime":1646578063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646578063","product_id":100024701,"comment_content":"32位的代码编译，栈帧里的局部变量和下一跳函数参数之间有4B的空余是为啥啊？","like_count":0},{"had_liked":false,"id":309664,"user_name":"LeviHou","can_delete":false,"product_type":"c1","uid":1930622,"ip_address":"","ucode":"5695713F9062BA","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/7e/16f45c25.jpg","comment_is_top":false,"comment_ctime":1630294909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630294909","product_id":100024701,"comment_content":"学习了，之前看过嵌入式实时操作系统ucos的内核切换。理解起来稍微顺一点，但是复杂度比ucos大很多！","like_count":0},{"had_liked":false,"id":309267,"user_name":"Geek_e08c40","can_delete":false,"product_type":"c1","uid":2666373,"ip_address":"","ucode":"8B4A3AC18EFD93","user_header":"","comment_is_top":false,"comment_ctime":1630027453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630027453","product_id":100024701,"comment_content":"老师per CPU是按缓存行加载变量副本的吗一个缓存行可能会有多个变量？，然后放到L 1-到L3的cache了","like_count":0},{"had_liked":false,"id":308470,"user_name":"兔嘟嘟","can_delete":false,"product_type":"c1","uid":2028811,"ip_address":"","ucode":"5A9042B4C7670C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","comment_is_top":false,"comment_ctime":1629635392,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629635392","product_id":100024701,"comment_content":"通过task_struct内的 stack指针，得到thread_info的地址（最低地址），加上THREAD_SIZE，到了最高的地址，再减pt_regs的大小，就到了pt_regs的起始地址。<br>这里要注意，之所以下面是起始地址，是因为Linux遵循小端模式，低地址是存储变量的起始位置。","like_count":0,"discussions":[{"author":{"id":2309990,"avatar":"","nickname":"Geek_93217e","note":"","ucode":"DC70FDB8AD83EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535937,"discussion_content":"应该不是这个原因，因为参照图和文字“在内核中，CPU 的寄存器 ESP 或者 RSP，已经指向内核栈的栈顶，在内核态里的调用都有和用户态相似的过程。”栈顶地址最小，pt_regs是在靠近栈底的位置，所以才有那样的计算过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638612308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304548,"user_name":"马振","can_delete":false,"product_type":"c1","uid":1136329,"ip_address":"","ucode":"94234F533219C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/c9/7b3cd3e0.jpg","comment_is_top":false,"comment_ctime":1627475018,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1627475018","product_id":100024701,"comment_content":"内核栈中的thread_info和task_struct中的thread_info是什么关系呢？是同一个东西吗","like_count":0,"discussions":[{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390096,"discussion_content":"就是同一个东西……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629649025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265957,"user_name":"吃饭睡觉打酱油","can_delete":false,"product_type":"c1","uid":1071668,"ip_address":"","ucode":"95EC98C2B5045B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5a/34/4cbadca6.jpg","comment_is_top":false,"comment_ctime":1607076314,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1607076314","product_id":100024701,"comment_content":"老师，之前介绍CPU和内存是怎么配合的，那里面看到是cpu的各个单元和内存的中代码段、数据段直接关联，现在这个函数栈和代码段、数据段是有关联的么？","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386452,"discussion_content":"你说的是ELF文件格式吧，里面有代码段，数据段；那个是要进程加载进内存的数据内容；函数栈本质只是存储局部变量和参数，这些都是运行时指定的；和ELF里面保存的代码，全局/静态变量不是一回事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627599757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253053,"user_name":"AlexS","can_delete":false,"product_type":"c1","uid":1472051,"ip_address":"","ucode":"3DA81A613CE645","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","comment_is_top":false,"comment_ctime":1602580014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602580014","product_id":100024701,"comment_content":"内容超棒der! 这个学费交得值。期待后面的内容。","like_count":0},{"had_liked":false,"id":224744,"user_name":"Bryant.C","can_delete":false,"product_type":"c1","uid":1172363,"ip_address":"","ucode":"0DF832373CFA97","user_header":"https://static001.geekbang.org/account/avatar/00/11/e3/8b/27f875ba.jpg","comment_is_top":false,"comment_ctime":1591526519,"is_pvip":false,"replies":[{"id":"82998","content":"拼错了哈","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1591752529,"ip_address":"","comment_id":224744,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591526519","product_id":100024701,"comment_content":"老师，最后总结时刻那张图内核栈栈底的文字是否应该是pt_regs呢？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497593,"discussion_content":"拼错了哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591752529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199163,"user_name":"honnkyou","can_delete":false,"product_type":"c1","uid":1026608,"ip_address":"","ucode":"FD5EC4120EE803","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/30/acc91f01.jpg","comment_is_top":false,"comment_ctime":1585480940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585480940","product_id":100024701,"comment_content":"DEFINE_PER_CPU(struct task_struct *, current_task) = &amp;init_task;<br>老师这个语句怎么理解？","like_count":0},{"had_liked":false,"id":193237,"user_name":"Geek_b8928e","can_delete":false,"product_type":"c1","uid":1926597,"ip_address":"","ucode":"96E4ABE3F2F145","user_header":"","comment_is_top":false,"comment_ctime":1584886620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584886620","product_id":100024701,"comment_content":"Per CPU 变量是内核中一种重要的同步机制。顾名思义，Per CPU 变量就是为每个 CPU 构造一个变量的副本，这样多个 CPU 各自操作自己的副本，互不干涉。","like_count":0},{"had_liked":false,"id":177949,"user_name":"起而行","can_delete":false,"product_type":"c1","uid":1131399,"ip_address":"","ucode":"4F116B0B740776","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/87/7604d7a4.jpg","comment_is_top":false,"comment_ctime":1581558844,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581558844","product_id":100024701,"comment_content":"day13进程在用户态与内核态的运行的确是难点，per CPU的设计思想很奇妙，能保证各个CPU之间不冲突。<br>课下运行程序，看一下汇编语言下栈的调用","like_count":0},{"had_liked":false,"id":175716,"user_name":"salmonl","can_delete":false,"product_type":"c1","uid":1010160,"ip_address":"","ucode":"0F85E5AD2C52B2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/69/f0/714c2f83.jpg","comment_is_top":false,"comment_ctime":1580805704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580805704","product_id":100024701,"comment_content":"看完了进程数据结构，了解到了很多。请教老师一个问题：每个进程都有自己独立的虚拟地址空间，空间布局包括代码段、数据段、BSS段、堆、栈。那么进程的数据具体是怎么存储的，具体存储在进程自己虚拟地址空间中那个段。望老师看到，并解惑。多谢。","like_count":0},{"had_liked":false,"id":174286,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1580120344,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580120344","product_id":100024701,"comment_content":"请问老师，task_struct是表示内存中进程的结构体，是不是这样将用户态和内核态串起来的：<br>1.用户态才会有task_struct<br>2.用户态可以通过task_struct的stack找到内核态的空间（比如寄存器pt_regs以及内存中的内核栈）<br>3.内核态可以通过内核态空间中的thread_info找到内存中进程的task_struct<br>4.在系统调用过程中，会填充上面的中介数据（stack和thread_info）<br><br>如果简单粗略的理解，就是用户态的内存中包含了内核态的地址（stack），内核态的内存空间中（寄存器和内存）包含了用户态的地址（thread_info）<br><br>上面的理解正确吗？","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386608,"discussion_content":"task_structure是内核态的结构","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627686095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155702,"user_name":"珠闪闪","can_delete":false,"product_type":"c1","uid":1300447,"ip_address":"","ucode":"45BE0D586A3839","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eov38ZkwCyNoBdr5drgX0cp2eOGCv7ibkhUIqCvcnFk8FyUIS6K4gHXIXh0fu7TB67jaictdDlic4OwQ/132","comment_is_top":false,"comment_ctime":1574738905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574738905","product_id":100024701,"comment_content":"刘老师，请教一下，什么时候用内核栈找task_struct?什么时候又反过来找？","like_count":0},{"had_liked":false,"id":155301,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1574676267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574676267","product_id":100024701,"comment_content":"摘抄：如果说 task_struct 的其他成员变量都是和进程管理有关的，内核栈是和进程运行有关系的。","like_count":0},{"had_liked":false,"id":153084,"user_name":"Doubleuhy","can_delete":false,"product_type":"c1","uid":1259681,"ip_address":"","ucode":"33004DBF105277","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/66KHl74Hghp6pb2FLKoLbhmz2hnA9iasxxJl0uN88RBicI06y8Fkiatuu6YFEwFuR94ia02dmmDqYnnfugka32EyCQ/132","comment_is_top":false,"comment_ctime":1574155100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574155100","product_id":100024701,"comment_content":"老师 64位架构函数调用栈 图中是不是有错鸭   第1-6个参数应该是由caller存入寄存器中 在callee中使用参数是通过mov指令来使用 没有用到push指令 所以rsp寄存器的值应该和rbp值一样才对 应该指向同一个地址","like_count":0},{"had_liked":false,"id":140824,"user_name":"小橙子","can_delete":false,"product_type":"c1","uid":1244724,"ip_address":"","ucode":"7E3DD87C3DE6F9","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/34/67c1ed1e.jpg","comment_is_top":false,"comment_ctime":1571053868,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571053868","product_id":100024701,"comment_content":"而 thread_info 的位置就是内核栈的最高位置，减去...<br><br>极客时间版权所有: https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;93014<br><br>这句话怎么理解？","like_count":0,"discussions":[{"author":{"id":1313806,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0c/0e/1aaaf652.jpg","nickname":"十大金刚","note":"","ucode":"23EE8DFE9C43D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216525,"discussion_content":"个人理解，首先看您问的这句话上面的代码，current_top_of_stack() 应该是指图中（文中的栈图）最高位置的地址，然后减去整个栈的大小THREAD_SIZE,就得到图最下面的地址，最下面开头的就是thread_info，所以也就是它的起始地址啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585460728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131496,"user_name":"ZYecho","can_delete":false,"product_type":"c1","uid":1356589,"ip_address":"","ucode":"9D156DD30C581E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLh73kPzAKhz7YxUribqF6QKFiahhVAbwpgVLSRicA68c6ZFA7vUBJY1ves3LVvibrypROyI7awv47eSA/132","comment_is_top":false,"comment_ctime":1567767995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567767995","product_id":100024701,"comment_content":"老师你好，文中说涉及权限的改变，会压栈保存 SS、ESP 寄存器，我有个疑问是这个地方为什么只单独push这两个寄存器呢？ cs、ip以及eflags寄存器呢？<br>","like_count":0},{"had_liked":false,"id":113308,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1396862,"ip_address":"","ucode":"62890F03EC78AF","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/7e/be0d09ea.jpg","comment_is_top":false,"comment_ctime":1562942486,"is_pvip":false,"replies":[{"id":"46675","content":"本来入栈就是一个副本了，不是原来的变量了","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566379006,"ip_address":"","comment_id":113308,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1562942486","product_id":100024701,"comment_content":"被调用函数通过栈指针获取入参内容，那函数调用的参数副本怎么理解？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458161,"discussion_content":"本来入栈就是一个副本了，不是原来的变量了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566379006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2401422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","nickname":"geek","note":"","ucode":"FF0845140D72A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363282,"discussion_content":"参数副本是指修改新的一份内存中的值，和原变量没有关系，如果还是通过偏移获得操作对象的话，那么修改的有可能是原变量，和pass by value矛盾。我感觉这块是个问题，得对照汇编看看。pass by value与pass by refrence的区别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617161592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111917,"user_name":"garlic","can_delete":false,"product_type":"c1","uid":1019579,"ip_address":"","ucode":"FEB147EDB5774E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg","comment_is_top":false,"comment_ctime":1562636915,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"1562636915","product_id":100024701,"comment_content":"X86_64 调用函数时避免调整栈指针的位置，存在一个128byte的red zone， 另外在实验过程中 与另外与专栏里讲到的不太一样的的是， 传递参数大于6个的，会被单独的放入栈顶，不过这个操作是调用函数做的。环境centos7  gcc： gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC)， 这是我的课堂作业笔记","like_count":0,"discussions":[{"author":{"id":1019579,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg","nickname":"garlic","note":"","ucode":"FEB147EDB5774E","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1857,"discussion_content":"当传递参数大于6个的时候， 前六个参数是被调用函数通过寄存器传递放入自己的栈中，大于6个的参数由调用函数压栈。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563002756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92934,"user_name":"周平","can_delete":false,"product_type":"c1","uid":1047936,"ip_address":"","ucode":"CA1869B139A4F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/80/52763d62.jpg","comment_is_top":false,"comment_ctime":1557365426,"is_pvip":false,"replies":[{"id":"49409","content":"赞，再看一遍","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567656944,"ip_address":"","comment_id":92934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557365426","product_id":100024701,"comment_content":"虽然还有些迷糊，但是感觉自己的理解在加深了","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449429,"discussion_content":"赞，再看一遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567656944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91507,"user_name":"川云","can_delete":false,"product_type":"c1","uid":1265438,"ip_address":"","ucode":"3D56399A7C5BDF","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/1e/e2b7a9ba.jpg","comment_is_top":false,"comment_ctime":1557044939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557044939","product_id":100024701,"comment_content":"讲的真好，把之前用户态切内核态不明白的地方都捋清了","like_count":0},{"had_liked":false,"id":90555,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1556554696,"is_pvip":false,"replies":[{"id":"32634","content":"不会访问，但是访问到是错的，也比越界好。这样统一处理会方便很多。当然一路if else也是可以的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556812111,"ip_address":"","comment_id":90555,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556554696","product_id":100024701,"comment_content":"内核栈的最高地址的那8个字节没看懂，如果没压入ss,sp，那为什么还要访问呢？从源码注释看，加了8个字节保留，如果没有压入ss,sp,这时候访问也是没有意义的，既然没有意义，程序为什么还要访问他啊？一个在程序中不能控制吗？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448565,"discussion_content":"不会访问，但是访问到是错的，也比越界好。这样统一处理会方便很多。当然一路if else也是可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556812111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}