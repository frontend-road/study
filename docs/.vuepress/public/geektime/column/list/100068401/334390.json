{"id":334390,"title":"09 | 可变的数据：不要让你的代码“失控”","content":"<p>你好，我是郑晔。</p><p>最近几讲，我们讨论的坏味道挑战了很多人的编程习惯，明明很习惯的编码方式，如今却成了坏味道。这一讲，我们再来说一类这样的坏味道：可变的数据。</p><p>对于程序，最朴素的一种认知是“程序=数据结构+算法”，所以，数据几乎是软件开发最核心的一个组成部分。在一些人的认知中，所谓做软件，就是一系列的 CRUD 操作，也就是对数据进行增删改查。再具体一点，写代码就把各种数据拿来，然后改来改去。我们学习编程时，首先学会的，也是给变量赋值，写出类似 <code>a = b + 1</code>之类的代码。</p><p>改数据，几乎已经成了很多程序员写代码的标准做法。然而，这种做法也带来了很多的问题。这一讲，我们还是从一段问题代码开始。</p><h2>满天飞的 Setter</h2><p>还记得我们在<a href=\"https://time.geekbang.org/column/article/325538\">开篇词</a>里提到过的一个坏味道吗？我们复习一下：</p><pre><code>public void approve(final long bookId) {\n  ...\n  book.setReviewStatus(ReviewStatus.APPROVED);\n  ...\n}\n</code></pre><p>这是一段对作品进行审核的代码，通过 bookId，找到对应的作品，接下来，将审核状态设置成了审核通过。</p><p>我当时之所以注意到这段代码，就是因为这里用了 setter。setter 往往是缺乏封装的一种做法。对于缺乏封装的坏味道，我们上节课已经用了一讲的篇幅在说，我提到，很多人在写代码时，写完字段就会利用 IDE 生成 getter，实际情况往往是，生成 getter 的同时，setter 也生成了出来。setter 同 getter 一样，反映的都是对细节的暴露。</p><!-- [[[read_end]]] --><p>这就意味着，你不仅可以读到一个对象的数据，还可以修改一个对象的数据。<strong>相比于读数据，修改是一个更危险的操作</strong>。</p><p>我在《<a href=\"https://time.geekbang.org/column/intro/100052601\">软件设计之美</a>》专栏里讲函数式编程的不变性时，曾经专门讨论过可变的数据会带来许多问题，简言之，你不知道数据会在哪里被何人以什么方式修改，造成的结果是，别人的修改会让你的代码崩溃。与之相伴的还有各种衍生出来的问题，最常见的就是我们常说的并发问题。</p><p>可变的数据是可怕，但是，<strong>比可变的数据更可怕的是，不可控的变化</strong>，而暴露 setter 就是这种不可控的变化。把各种实现细节完全交给对这个类不了解的使用者去修改，没有人会知道他会怎么改，所以，这种修改完全是不可控的。</p><p><strong>缺乏封装再加上不可控的变化，在我个人心目中，setter 几乎是排名第一的坏味道</strong>。</p><p>在开篇词里，我们针对代码给出的调整方案是，用一个函数替代了 setter，也就是把它用行为封装了起来：</p><pre><code>public void approve(final long bookId) {\n  ...\n  book.approve();\n  ...\n}\n</code></pre><p>通过在 Book 类里引入了一个 approve 函数，我们将审核状态封装了起来。</p><pre><code>class Book {\n  public void approve() {\n    this.reviewStatus = ReviewStatus.APPROVED;\n  }\n}\n</code></pre><p>作为这个类的使用者，你并不需要知道这个类到底是怎么实现的。更重要的是，这里的变化变得可控了。虽然审核状态这个字段还是会修改，但你所有的修改都要通过几个函数作为入口。有任何业务上的调整，都会发生在类的内部，只要保证接口行为不变，就不会影响到其它的代码。</p><p>setter 破坏了封装，相信你对这点已经有了一定的理解。不过，有时候你会说，我这个 setter 只是用在初始化过程中，而并不需要在使用的过程去调用，就像下面这样：</p><pre><code>Book book = new Book();\nbook.setBookId(bookId);\nbook.setTitle(title);\nbook.setIntroduction(introduction);\n</code></pre><p>实际上，对于这种只在初始化中使用的代码，压根没有必要以 setter 的形式存在，真正需要的是一个有参数的构造函数：</p><pre><code>Book book = new Book(bookId, title, introduction);\n</code></pre><p>消除 setter ，有一种专门的重构手法，叫做<strong>移除设值函数（Remove Setting Method）</strong>。总而言之，setter 是完全没有必要存在的。</p><p>在今天的软件开发中，人们为了简化代码的编写做出了各种努力，用 IDE 生成的代码是一种，还有一种常见的做法就是，通过工具和框架生成相应代码的。在 Java 世界中，Lombok 就是这样的一种程序库，它可以在编译的过程中生成相应的代码，而我们需要做的，只是在代码上加上对应的 Annotation。它最大的优点是不碍眼，也就是不会产生大量可以看见的代码。因为它的代码是在编译阶段生成的，所以，那些生成的代码在源码级别上是不存在的。下面就是一个例子：</p><pre><code>@Getter\n@Setter\nclass Book {\n  private BookId bookId;\n  private String title;\n  private String introduction;\n}\n</code></pre><p>这里的@Getter 表示为这个类的字段生成 getter，相应地，@Setter 表示生成 setter。也是因为这些 Annotation 的存在，让代码看上去清爽了不少。所以，像 Lombok 这样的程序库赢得了许多人的喜爱。</p><p>不过，我想说的是，不写 setter 的代码并不代表没有 setter。因为@Setter的存在，其它代码还是可以调用这个类的 setter，存在的问题并不会改变。所以，一个更好的做法是禁用@Setter。下面是 lombok.config 的配置，通过它，我们就可以禁用@Setter了：</p><pre><code>lombok.setter.flagUsage = error\nlombok.data.flagUsage = error\n</code></pre><p>你或许注意到了，这里除了@Setter，我还禁用了@Data，这是 Lombok 中另外一个 Annotation，表示的是同时生成 getter 和 setter。既然我们禁用@Setter 是为了防止生成 setter，当然也要禁用@Data了。</p><h2>可变的数据</h2><p>我们反对使用 setter，一个重要的原因就是它暴露了数据，我们前面说过，暴露数据造成的问题就在于数据的修改，进而导致出现难以预料的 Bug。在上面的代码中，我们把 setter 封装成一个个的函数，实际上是把不可控的修改限制在一个有限的范围内。</p><p>那么，这个思路再进一步的话，如果我们的数据压根不让修改，犯下各种低级错误的机会就进一步降低了。没错，在这种思路下，<strong>可变数据（Mutable Data）就成了一种坏味道</strong>，这是 Martin Fowler 在新版《<a href=\"https://book.douban.com/subject/30468597/\">重构</a>》里增加的坏味道，它反映着整个行业对于编程的新理解。</p><p>这种想法源自函数式编程这种编程范式。在函数式编程中，数据是建立在不改变的基础上的，如果需要更新，就产生一份新的数据副本，而旧有的数据保持不变。随着函数式编程在软件开发领域中的地位不断提高，人们对于不变性的理解也越发深刻，不变性有效地解决了可变数据产生的各种问题。</p><p>所以，Martin Fowler 在《重构》第二版里新增了可变数据作为一种坏味道，这其实反映了行业的理解也是在逐渐推进的。不过，Martin Fowler 对于可变数据给出的解决方案，基本上是限制对于数据的更新，降低其风险，这与我们前面提到的对 setter 的封装如出一辙。</p><p><strong>解决可变数据，还有一个解决方案是编写不变类。</strong></p><p>我在《<a href=\"https://time.geekbang.org/column/intro/100052601\">软件设计之美</a>》专栏中已经讲过函数式编程的不变性，其中的关键点就是设计不变类。Java 中的 String 类就是一个不变类，比如，如果我们把字符串中的一个字符替换成另一个字符，String 类给出的函数签名是这样的：</p><pre><code>String replace(char oldChar, char newChar);\n</code></pre><p>其含义是，这里的替换并不是在原有字符串上进行修改，而是产生了一个新的字符串。</p><p>那么，在实际工作中，我们怎么设计不变类呢？要做到以下三点：</p><ul>\n<li>所有的字段只在构造函数中初始化；</li>\n<li>所有的方法都是纯函数；</li>\n<li>如果需要有改变，返回一个新的对象，而不是修改已有字段。</li>\n</ul><p>回过头来看我们之前改动的“用构造函数消除 setter”的代码，其实就是朝着这个方向在迈进。如果按照这个思路改造我们前面提到的 approve 函数，同样也可以：</p><pre><code>class Book {\n  public Book approve() {\n    return new Book(..., ReviewStatus.APPROVED, ...);\n  }\n}\n</code></pre><p>这里，我们创建出了一个“其它参数和原有 book 对象一模一样，只是审核状态变成了 APPROVED ”的对象。</p><p>在 JDK 的演化中，我们可以看到一个很明显的趋势，新增的类越来越多地采用了不变类的设计，比如，用来表示时间的类。原来的 Date 类里面还有各种 setter，而新增的 LocalDateTime 则一旦初始化就不会再修改了。如果要操作这个对象，则会产生一个新的对象：</p><pre><code>LocalDateTime twoDaysLater = now.plusDays(2);\n</code></pre><p>就目前的开发状态而言，想要完全消除可变数据是很难做到的，但我们可以尽可能地编写一些不变类。</p><p>一个更实用的做法是，<strong>区分类的性质</strong>。我《<a href=\"https://time.geekbang.org/column/intro/100052601\">软件设计之美</a>》中讲 DDD 的战术设计时提到过，我们最核心要识别的对象分成两种，实体和值对象。<strong>实体对象要限制数据变化，而值对象就要设计成不变类</strong>。</p><p>如果你还想进一步提升自己对于不变性的理解，我们可以回到函数式编程这个编程范式的本质，它其实是对程序中的赋值进行了约束。基于这样的理解，<strong>连赋值本身其实都会被归入到坏味道的提示，这才是真正挑战很多人编程习惯的一点</strong>。</p><p>不过，我们现在看到，越来越多的语言中开始引入值类型，也就是初始化之后便不再改变的值，比如，Java 的 <a href=\"https://openjdk.java.net/projects/valhalla/\">Valhalla 项目</a>，更有甚者，像 Rust 这样的语言中，缺省都是值类型，而如果你需要一个可以赋值的变量，反而要去专门的声明。</p><p>Martin Fowler 在《重构》中还提到一个与数据相关的坏味道：<strong>全局数据（Global Data）</strong>。如果你能够理解可变数据是一种坏味道，全局数据也就很容易理解了，它们处理手法基本上是类似的，这里我就不再做过多的阐述了。</p><h2>总结时刻</h2><p>今天我们又讲了一类与很多人编程习惯不符的坏味道：可变的数据。</p><p>可变数据最直白的体现就是各种 setter。setter 一方面破坏了封装，另一方面它会带来不可控的修改，给代码增添许多问题。解决它的一种方式就是<strong>移除设值函数（Remove Setting Method）</strong>，将变化限制在一定的范围之内。</p><p>可变数据是《重构》第二版新增的坏味道，这其实反映了软件开发行业的一种进步，它背后的思想是函数式编程所体现的不变性。解决可变数据，一种方式是限制其变化，另一种方式是编写不变类。</p><p>在实践中，完全消除可变数据是很有挑战的。所以，一个实际的做法是，区分类的性质。值对象就要设计成不变类，实体类则要限制数据变化。</p><p>函数式编程的本质是对于赋值进行了约束，我们甚至可以把赋值作为一种坏味道的提示。很多编程语言都引入了值类型，而让变量成为次优选项。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>限制可变的数据</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/18/48f0b0666569522fc97b74cc27ded418.jpg?wh=2284*3156\" alt=\"\"></p><h2>思考题</h2><p>这一讲我们讲了可变的数据，你在实际工作遇到过因为数据变动而产生的问题吗？或者你设计过不变类吗？欢迎在留言区分享你的经验。</p><p><span class=\"reference\">参考资料：</span></p><p><a href=\"https://time.geekbang.org/column/article/258214\">19 | 函数式编程之不变性：怎样保证我的代码不会被别人破坏？</a></p><p><a href=\"https://time.geekbang.org/column/article/267843\">29 | 战术设计：如何像写故事一样找出模型？</a></p>","neighbors":{"left":{"article_title":"08 | 缺乏封装：如何应对火车代码和基本类型偏执问题？","id":333135},"right":{"article_title":"10 | 变量声明与赋值分离：普通的变量声明，怎么也有坏味道？","id":334992}},"comments":[{"had_liked":false,"id":274487,"user_name":"陈文昕","can_delete":false,"product_type":"c1","uid":1168700,"ip_address":"","ucode":"1BD88938427777","user_header":"https://static001.geekbang.org/account/avatar/00/11/d5/3c/861e0c86.jpg","comment_is_top":false,"comment_ctime":1611036489,"is_pvip":false,"replies":[{"id":"99681","content":"正解","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611146631,"ip_address":"","comment_id":274487,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48855676745","product_id":100068401,"comment_content":"对象如果需要构造的参数太多了怎么办？<br>我能想到的就是用builder模式来重构","like_count":12,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514032,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611146631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281007,"user_name":"crtmsvc","can_delete":false,"product_type":"c1","uid":2201323,"ip_address":"","ucode":"A00D3FB17CB614","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/CV9kk5M26pdxvFhbrkicjZa4avHTfWWPJCKCIrkhgws8WN9RJAJ5D4oGAPgAOVXmDk9gKEQ9nbrhia9Qjsqk4DyA/132","comment_is_top":false,"comment_ctime":1614523833,"is_pvip":false,"replies":[{"id":"102125","content":"多谢分享","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1614658115,"ip_address":"","comment_id":281007,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40269229497","product_id":100068401,"comment_content":"https:&#47;&#47;immutables.github.io&#47;<br>Java 用這個，好用 :)","like_count":10,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516274,"discussion_content":"多谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614658115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274426,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1611019610,"is_pvip":false,"replies":[{"id":"99707","content":"那种痛，经历过才懂。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611188946,"ip_address":"","comment_id":274426,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31675790682","product_id":100068401,"comment_content":"前段时间，领导交代了一个任务。任务是将某某前端传进来的字段，存储到数据库里面。当时领导说这么简单的一个功能，就给你一天的时间解决。我足足花了两天时间。我后来复盘了一下，任务延期的原因就是可变的数据，失控的代码，需要修改的代码点里面逻辑，而且充斥着各种set,当我在我自以为某个地方set了该字段之后，发现在代码的后面又有一个地方set了，在往后面又有地方set，那种感觉，真的酸爽。<br>学习了这篇文章之后，我自己后面一定要避免这种问题，如果不改，说不定后面坑到的还是我自己。","like_count":8,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514015,"discussion_content":"那种痛，经历过才懂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611188946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1666025,"avatar":"https://static001.geekbang.org/account/avatar/00/19/6b/e9/7620ae7e.jpg","nickname":"雨落～紫竹","note":"","ucode":"33CED2F34E708F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577057,"discussion_content":"不应该是case和经验不够吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655904529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552943,"discussion_content":"也有可能是数据库updatebyid 这种更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645665161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280434,"user_name":"源泉","can_delete":false,"product_type":"c1","uid":2096693,"ip_address":"","ucode":"41704DD46CBB5E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/fe/35/335b89fb.jpg","comment_is_top":false,"comment_ctime":1614216481,"is_pvip":false,"replies":[{"id":"101810","content":"你说得对，贫血模型本来就不是一个好的设计，只算把数据放到一起，谈不上封装。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1614219664,"ip_address":"","comment_id":280434,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18794085665","product_id":100068401,"comment_content":"这些算是基于充血模型的吗？可我做过的项目全是类似贫血模型","like_count":5,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516096,"discussion_content":"你说得对，贫血模型本来就不是一个好的设计，只算把数据放到一起，谈不上封装。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614219664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536312,"discussion_content":"原来封装后的对象就是充血模型啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638756959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275359,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1611488146,"is_pvip":false,"replies":[{"id":"100408","content":"用了 setter，习惯 setter，setter 才是去不掉的。<br><br>程序库中优秀的地方也许就是潜在的语言特性，这在《软件设计之美》讲程序库的时候提到过：程序库设计就是语言设计，语言设计就是程序库设计。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1612091445,"ip_address":"","comment_id":275359,"utype":1}],"discussion_count":6,"race_medal":0,"score":"18791357330","product_id":100068401,"comment_content":"1.现实情况下,@Setter这个我去不掉啊。毕竟很多框架（dozer,mapstruct）都是基于生成set方法操作数据的。去掉的话，兼容性会受影响，开发工作量和风险也会增加(需要手动去维护新增字段的初始化)。<br><br>2.基于idea，我声明的变量都会带上final。这一度倍受挑战，因为带上final代码自然就变长了，可读性算是变差了吧，毕竟有时因为多个final就得换行；包括jdk函数库在内，大部分好demo的代码部分都不会带上final，所以当小伙伴拿这些例子质疑时挺无奈。<br>3.为什么声明要带上final，因为我也认为缺省变量应该是不可变的。只是受限于java语法特性，所以采用这种曲线的方式。<br>4.提到final就谈谈不可变对象。一个对象一旦声明，内部的数值结构就不可变，任何对内部值的变更操作都会生成新的对象。这个其实我一直在想，如果语言层面提供一个备忘录模式或许会挺好的。使用者做变更时不用手动新建对象，回退时也可以基于his版本对象无需重新创建。并且我们也有回滚到变更前一个状态或者前多个状态的诉求，也会有打印出所有变更操作的诉求。","like_count":5,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514322,"discussion_content":"用了 setter，习惯 setter，setter 才是去不掉的。\n\n程序库中优秀的地方也许就是潜在的语言特性，这在《软件设计之美》讲程序库的时候提到过：程序库设计就是语言设计，语言设计就是程序库设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612091445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346885,"discussion_content":"框架基于setter实现参数copy。这是一个很头疼的点。包裹基于get做参数获取的框架。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612091703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1362235,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c9/3b/ead87c38.jpg","nickname":"Seed2009","note":"","ucode":"E21E429D3D1F8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347076,"discussion_content":"mapstruct返回值可以用builder构建，或者在mapper中用default method手动实现也可以避免setter","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612147439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":346885,"ip_address":""},"score":347076,"extra":""},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1362235,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c9/3b/ead87c38.jpg","nickname":"Seed2009","note":"","ucode":"E21E429D3D1F8F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347154,"discussion_content":"1.builder方式老版本好像不生效。有链接吗，给个研究下，感谢。\n2.用def的方式感觉就没用用mapstruct的必要了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612165958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":347076,"ip_address":""},"score":347154,"extra":""}]},{"author":{"id":2028948,"avatar":"","nickname":"Geek2808","note":"","ucode":"835C9691723163","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346774,"discussion_content":"“提到final就谈谈不可变对象。一个对象一旦声明，内部的数值结构就不可变，任何对内部值的变更操作都会生成新的对象。”你这个说法是错的，final 声明的对象不可变是指参数引用的对象不可变，也就是你不可以new 一个对象给被final声明的对象，但是你依然可以通过对象自带的set方法修改对象内部数据，修改也是在原有对象上修改的，修改不吹生成新的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612061233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028948,"avatar":"","nickname":"Geek2808","note":"","ucode":"835C9691723163","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346805,"discussion_content":"首先，你说的这后半部分是对的。但请好好阅读上下文，我谈的是不可变对象的定义。并不是你理解的这些。至于你所描述的这些，这是很基础的东西，你认为java开发会有人不懂？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612067939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":346774,"ip_address":""},"score":346805,"extra":""}]}]},{"had_liked":false,"id":309034,"user_name":"yinhaixiang","can_delete":false,"product_type":"c1","uid":1030997,"ip_address":"","ucode":"73CF9B99536BF7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKRY1B4TFo8CTKQl6LzDxETpUQXcH9hXwkuPxJSh9qxXFxQYyJNMsbNlhpe2wgICRkAbZSe4DyFWA/132","comment_is_top":false,"comment_ctime":1629900556,"is_pvip":false,"replies":[{"id":"111863","content":"针对代码生成工具，如果它生成的是一个算法，比如编译器生成器，我可以去用，因为我只要关注接口，不需要关注细节。如果生成的是模型，我倾向于不用它，因为我要关注其中的细节。如果封装它，可能就失去了代码生成的意义。<br><br>我常常说到软件设计的品位，生成大量 setter 代码的工具，本身就是设计品位不佳的体现。基于一个品位不佳的工具谈改进，这可能不是我关注的方向。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1629936288,"ip_address":"","comment_id":309034,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14514802444","product_id":100068401,"comment_content":"我们项目用mybatis-plus, 由mybatis-plus-generator生成model, 原则上自动生成的代码不应手动修改, 但是按此文讲的要去除setter方法, 那自动生成的model基本都要大改了, 这个悖论该怎么解决呢","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525722,"discussion_content":"针对代码生成工具，如果它生成的是一个算法，比如编译器生成器，我可以去用，因为我只要关注接口，不需要关注细节。如果生成的是模型，我倾向于不用它，因为我要关注其中的细节。如果封装它，可能就失去了代码生成的意义。\n\n我常常说到软件设计的品位，生成大量 setter 代码的工具，本身就是设计品位不佳的体现。基于一个品位不佳的工具谈改进，这可能不是我关注的方向。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629936288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1759325,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","nickname":"杯莫停","note":"","ucode":"4FA1D5CBBEF702","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578394,"discussion_content":"mybatis-plus本身就是中畸形的产物，就像是开手动挡的车，Mybatis就像是你自己挂挡而mybatis-plus就是在副驾驶安排个人给你挂挡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656696083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276042,"user_name":"孙隽璐","can_delete":false,"product_type":"c1","uid":2397035,"ip_address":"","ucode":"C1A45BD1F8A926","user_header":"https://static001.geekbang.org/account/avatar/00/24/93/6b/6cd6be47.jpg","comment_is_top":false,"comment_ctime":1611755954,"is_pvip":false,"replies":[{"id":"100275","content":"其实，C 语言也是可以把代码写得很好的，我在《软件设计之美》中用过一个 Linux 文件系统的例子。只不过，花的精力比较多，很多人不愿意这么做而已。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611843600,"ip_address":"","comment_id":276042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14496657842","product_id":100068401,"comment_content":"嵌入式C程序员表示眼馋这些其他语言直接提供的封装方法……","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514576,"discussion_content":"其实，C 语言也是可以把代码写得很好的，我在《软件设计之美》中用过一个 Linux 文件系统的例子。只不过，花的精力比较多，很多人不愿意这么做而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611843600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274405,"user_name":"桃子-夏勇杰","can_delete":false,"product_type":"c1","uid":1158436,"ip_address":"","ucode":"5D5F38AABA980F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/24/c6b763b4.jpg","comment_is_top":false,"comment_ctime":1611014333,"is_pvip":true,"replies":[{"id":"99618","content":"难道数据不存回去，只在内存里吗？那就得考虑事务性内存了。😄","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611037102,"ip_address":"","comment_id":274405,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10200948925","product_id":100068401,"comment_content":"我的理解使用不变性限制了大家一起改同一份数据的混乱，但同时又会引发多份副本数据的混乱，郑老师见过这样的情况么？","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514008,"discussion_content":"难道数据不存回去，只在内存里吗？那就得考虑事务性内存了。😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611037102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328447,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":2425556,"ip_address":"","ucode":"5E57A0FE948966","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/d4/1e0bb504.jpg","comment_is_top":false,"comment_ctime":1640742620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5935709916","product_id":100068401,"comment_content":"实体对象要限制数据变化，而值对象就要设计成不变类～这里有些不是很理解，什么才称为实体对象，什么才称为值对象","like_count":1},{"had_liked":false,"id":301597,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":2425556,"ip_address":"","ucode":"5E57A0FE948966","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/d4/1e0bb504.jpg","comment_is_top":false,"comment_ctime":1625755957,"is_pvip":false,"replies":[{"id":"109201","content":"这个 reviewStatus 就是可以保存不同的状态啊，使用 setter 的话，就等于你把实现细节暴露给其他人了，人家想怎么用就怎么用，而封装了之后，别人必须把自己的意图告诉你，比如这里，他必须说，我要审核通过。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1625810510,"ip_address":"","comment_id":301597,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5920723253","product_id":100068401,"comment_content":"<br>class Book {<br>  public void approve() {<br>    this.reviewStatus = ReviewStatus.APPROVED;<br>  }<br>}<br>有一个小小的疑问 就是采用这种方式this.reviewStatus = ReviewStatus.APPROVED; 有点像写死hardcode的感觉，万一这个reviewStatus可以存在其他状态，那不是又要增加一个设置函数了，反倒使用setter就不会有这种问题，不知道是不是我没有领悟这个方法的精髓，希望老师指点下","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523038,"discussion_content":"这个 reviewStatus 就是可以保存不同的状态啊，使用 setter 的话，就等于你把实现细节暴露给其他人了，人家想怎么用就怎么用，而封装了之后，别人必须把自己的意图告诉你，比如这里，他必须说，我要审核通过。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625810510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552951,"discussion_content":"需要修改多少状态，要给每个枚举类写个这个函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645665743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301574,"user_name":"晴天了","can_delete":false,"product_type":"c1","uid":1359669,"ip_address":"","ucode":"5310E02F8DF1F0","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/35/0e3a92a7.jpg","comment_is_top":false,"comment_ctime":1625745288,"is_pvip":false,"replies":[{"id":"109196","content":"火车残骸的代码和流畅（Fluent）代码的重要差别是，火车残骸描述的具体怎么做，而流畅（Fluent）代码描述的是做什么，是声明式的。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1625810197,"ip_address":"","comment_id":301574,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5920712584","product_id":100068401,"comment_content":"不变类. 在调用中同样是链式调用的.  这种情况不属于火车残害坏味道吗","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523030,"discussion_content":"火车残骸的代码和流畅（Fluent）代码的重要差别是，火车残骸描述的具体怎么做，而流畅（Fluent）代码描述的是做什么，是声明式的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625810197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274814,"user_name":"adang","can_delete":false,"product_type":"c1","uid":1143712,"ip_address":"","ucode":"0F2ECF8B92D46B","user_header":"https://static001.geekbang.org/account/avatar/00/11/73/a0/7dcc9212.jpg","comment_is_top":false,"comment_ctime":1611186613,"is_pvip":false,"replies":[{"id":"99719","content":"所有权机制，目的不是这个吧？","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611193049,"ip_address":"","comment_id":274814,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5906153909","product_id":100068401,"comment_content":"在 Rust 中变量默认是不可变的，要想使其可变，需要在变量名前加 mut 关键字。这样不仅可以改变变量的值，而且也在告诉阅读代码的人，这个值在某个地方会被改变。<br>另外，它的所有权机制和对可变引用的规则限制，会减少很多可变的数据这种坏味道的发生。对 Rust 理解的不深，不知道这样的理解对不对。","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514133,"discussion_content":"所有权机制，目的不是这个吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611193049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1143712,"avatar":"https://static001.geekbang.org/account/avatar/00/11/73/a0/7dcc9212.jpg","nickname":"adang","note":"","ucode":"0F2ECF8B92D46B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343843,"discussion_content":"嗯嗯，所有权机制不是为了这个，我理解错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611194548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347267,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1653888361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653888361","product_id":100068401,"comment_content":"限制可变的数据--记下来","like_count":0},{"had_liked":false,"id":346994,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1653609225,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1653609225","product_id":100068401,"comment_content":"JDK有一个新特性record，可以用来编写不可变类。","like_count":0,"discussions":[{"author":{"id":1666025,"avatar":"https://static001.geekbang.org/account/avatar/00/19/6b/e9/7620ae7e.jpg","nickname":"雨落～紫竹","note":"","ucode":"33CED2F34E708F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577058,"discussion_content":"现在谁能用那个版本\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655904610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316382,"user_name":"独孤九剑","can_delete":false,"product_type":"c1","uid":2230909,"ip_address":"","ucode":"6C1253E2B8C1D4","user_header":"https://static001.geekbang.org/account/avatar/00/22/0a/7d/ac715471.jpg","comment_is_top":false,"comment_ctime":1634292657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634292657","product_id":100068401,"comment_content":"“版本化”管理是个好东东","like_count":0},{"had_liked":false,"id":283178,"user_name":"李文彬","can_delete":false,"product_type":"c1","uid":2251534,"ip_address":"","ucode":"4CD326DC443028","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia4qBUs5bFs5tU3yVCcBapIcnVftM60nrJ73eu30YDMbDNvjhvnibct3pMYlj62G1c7nH8jSBaiaLw/132","comment_is_top":false,"comment_ctime":1615608460,"is_pvip":false,"replies":[{"id":"102942","content":"流行其实是有道理的","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1615900940,"ip_address":"","comment_id":283178,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615608460","product_id":100068401,"comment_content":"不可变对象在前端倒是很流行，一些状态管理甚至是基于这个前提的","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516953,"discussion_content":"流行其实是有道理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615900940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276634,"user_name":"Geek2808","can_delete":false,"product_type":"c1","uid":2028948,"ip_address":"","ucode":"835C9691723163","user_header":"","comment_is_top":false,"comment_ctime":1612060234,"is_pvip":false,"replies":[{"id":"100399","content":"这是一个编写“不变对象”的示例，这种做法确实不多见，你可以看看 String 类的实现。关于不变性的分析，可以参考《软件设计之美》。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1612090220,"ip_address":"","comment_id":276634,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1612060234","product_id":100068401,"comment_content":"public void approve() { <br>     return new Book(..., ReviewStatus.APPROVED, ...); <br>}<br>作者，这个方法返回的应该是Book对象。还有个疑惑，这种修改对象状态并返回一个新对象的方式是主流的方式吗？我在我们的项目中还没见过有写过。","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514779,"discussion_content":"这是一个编写“不变对象”的示例，这种做法确实不多见，你可以看看 String 类的实现。关于不变性的分析，可以参考《软件设计之美》。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612090220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373757,"discussion_content":"层主说的是方法返回值，void应为Book。编辑应该改一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620866918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}