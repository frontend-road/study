{"id":809937,"title":"06｜数据存储：如何实现单机持久化的存储服务？","content":"<blockquote>\n<p><span class=\"reference\">本课程为精品小课，不标配音频</span></p>\n</blockquote><p>你好，我是文强。</p><p>上节课我们完成了 Server 模块的开发，接下来我们来实现元数据存储服务中的单机存储层。首先，我们需要来看一下单机存储层的技术方案如何选型。</p><h2>存储层实现设计考量</h2><p>如下图所示，我们知道了元数据存储服务的核心是 KV 模型数据的存储。</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/6e/6c452105ff951bc5d1860bb21272b06e.png?wh=1139x641\" alt=\"图片\"><br>\n那如何来实现这个存储层呢？从技术上来看，一般有三个思路：</p><ol>\n<li>\n<p>基于文件系统从头实现数据存储。</p>\n</li>\n<li>\n<p>基于现有成熟的分布式存储引擎完成数据的存储，比如 ZooKeeper、etcd等。</p>\n</li>\n<li>\n<p>基于现有成熟的嵌入式键值数据库实现，比如 RocksDB、LevelDB 等。</p>\n</li>\n</ol><p>第一种方案很直观，可能也是我们在选型时首先想到的思路，但是<strong>这种方案是最不推荐的</strong>。因为从零开始写一个生产级别的存储层是非常困难的，周期很长，稳定性差。比如需要处理硬件和操作系统随时都有可能丢失或损坏数据的情况，另外写入性能优化需要大量时间投入，还得处理代码 Bug 等情况。</p><p>第二种方案是常用的方案，依赖成熟的分布式存储引擎存储数据，是比较快速且稳定的方案。但是这种方案的缺点是需要依赖外部系统，会导致架构复杂，长期运维成本高，另外外部依赖组件的稳定性也会影响主系统的稳定。因为我们要实现的消息队列其中一个设计目标就是：<strong>高内聚和弱外部依赖</strong>。如果选择这种方案，就破坏了这个目标，长期来看，不太合理。</p><!-- [[[read_end]]] --><p>第三种方案从某种角度看和第一种是同一个思路。区别是存储层不是自己实现的，而是依赖现有的成熟、可靠、高性能的嵌入式键值存储来实现存储层。这种方案的开发成本低，性能和可靠性也有保证。目前业界主要的嵌入式键值存储有 RocksDB、LevelDB 等。目前使用较多的是 RocksDB，业界很多知名公司和开源项目都在使用它。比如 TiKV、CRDB都是基于 RocksDB 来实现的。</p><p>所以，从实现难度、稳定性、性能等三个方面考虑，我们选择了第三种方案。从元数据存储服务(Placement Center) 的功能需求和业界嵌入式键值数据库的功能、稳定性、项目成熟度、社区活跃度来看，我认为 RocksDB 非常适合来当存储层。</p><p>接下来我们从功能和架构上简单介绍一下 RocksDB。</p><h2>RocksDB 简介</h2><p>从功能层面来看，RocksDB 它是一个嵌入式的键值存储引擎，它提供了下面几个主要的功能函数调用：</p><ul>\n<li>\n<p><strong>Put(Key, Value)</strong>：插入新的Key-Value对或更新现有 Key 的值。</p>\n</li>\n<li>\n<p><strong>Get(Key)</strong>：获取特定 Key 的值。</p>\n</li>\n<li>\n<p><strong>Delete(Key)</strong>：删除特定 Key 的值。</p>\n</li>\n<li>\n<p><strong>Merge(Key, Value)</strong>：将新值与给定 Key 的现有值合并。</p>\n</li>\n<li>\n<p><strong>Seek(key_prefix)</strong>：匹配指定 Key 的前缀或大于 Key 的前缀。</p>\n</li>\n</ul><p>从这几个函数来看，它是标准 KV 模型的存储，即 set/get/delete/search 类型的方法。</p><p>从代码层面来看，<strong>RocksDB 就一个 Lib，不是一个 Server</strong>，是一个被项目引用的库。也就是说它没有独立的进程运行，是和主进程共享内存空间。比如在 Java 中它是 Maven 的 Package，在 Rust 中，它是一个 crate 上的 Lib，在 Go 中它是一个 Module。</p><p>从底层存储的角度来看，RocksDB 的数据是<strong>存储在单机本地硬盘的文件中的</strong>，也就是说它是本地存储的。即通过 Put 函数写入的数据，都是存储在本机的文件中的。RocksDB 的本地文件存储结构如下，会包含 sst、log 等等信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/19/7a/19492a9925df38f2f5b2c7acec7a437a.png?wh=1148x460\" alt=\"图片\"></p><p>从底层原理来看，它是基于 <strong>LSM-Tree（Log-Structured Merge Tree）</strong>实现的一种本地存储引擎。如果对存储系统有了解的人，对 LSM 应该不会陌生。如果你希望对存储系统了解更多，建议你去研究一下 LSM，它是一种基于日志结构的数据结构，能够高效地存储和更新键值数据。LSM 这块的资料特别多，就不展开细讲了。</p><p>因为接下来我们会用到 RocksDB 中的列簇（ColumnFamily） 的概念，所以我们先来了解一下它是什么。</p><p>ColumnFamily 是 RocksDB 中的一个逻辑概念，它的功能是<strong>用于 Key 的组织。</strong>比如一部分的 key 存储在 A ColumnFamily，另外一部分 key 存储在 B ColumnFamily。ColumnFamily 和 key 的关系，有点像 MySQL 中 Database 和 table 的关系。Database 用于 table 的逻辑组织，table 一定要属于某个 Database。默认情况下，RocksDB 中所有的 key 都在一个默认的 ColumnFamily 中。</p><p>了解了 RocksDB，接下来我们来看一下在元数据存储服务中，如何基于 RocksDB 实现存储层。</p><h2>Rust Rocksdb 入门</h2><p>在 Rust 中，需要通过 Rust 库<a href=\"https://docs.rs/rocksdb/0.22.0/rocksdb/\">《rocksdb》</a>来使用 RocksDB。从代码实现的层面看，主要包含下面七个部分：</p><ul>\n<li>\n<p>构建 RocksDB 配置</p>\n</li>\n<li>\n<p>初始化 RocksDB 实例</p>\n</li>\n<li>\n<p>写数据（Write）</p>\n</li>\n<li>\n<p>根据 Key 读取数据（Get）</p>\n</li>\n<li>\n<p>根据 Key 删除数据（Delete）</p>\n</li>\n<li>\n<p>判断 Key 是否存在（Exists）</p>\n</li>\n<li>\n<p>根据前缀读取数据（read_prefix）</p>\n</li>\n</ul><p>接下来我们主要跟随代码实现来一个一个讲解。</p><ol>\n<li>构建 RocksDB 配置</li>\n</ol><p>构建配置的主要工作是设置 RocksDB 实例的配置选项（Options）。代码实现很简单，难点在于：<strong>要理解 RocksDB 的运行原理</strong><strong>，</strong><strong>每个配置项的意义，然后根据自己的场景和要求进行配置优化</strong>，这个是和语言无关的。</p><p>配置初始化代码如下：</p><pre><code class=\"language-plain\"> fn open_db_opts(config: &amp;PlacementCenterConfig) -&gt; Options {\n        let mut opts = Options::default();\n        opts.create_if_missing(true);\n        opts.create_missing_column_families(true);\n        opts.set_max_open_files(1000);\n        opts.set_use_fsync(false);\n        opts.set_bytes_per_sync(8388608);\n        opts.optimize_for_point_lookup(1024);\n        opts.set_table_cache_num_shard_bits(6);\n        opts.set_max_write_buffer_number(32);\n        opts.set_write_buffer_size(536870912);\n        opts.set_target_file_size_base(1073741824);\n        opts.set_min_write_buffer_number_to_merge(4);\n        opts.set_level_zero_stop_writes_trigger(2000);\n        opts.set_level_zero_slowdown_writes_trigger(0);\n        opts.set_compaction_style(DBCompactionStyle::Universal);\n        opts.set_disable_auto_compactions(true);\n        let transform = SliceTransform::create_fixed_prefix(10);\n        opts.set_prefix_extractor(transform);\n        opts.set_memtable_prefix_bloom_ratio(0.2);\n        return opts;\n    }\n\n\n</code></pre><p>这段代码很简单，直接看这个<a href=\"https://docs.rs/rocksdb/0.22.0/rocksdb/struct.Options.html\">《Rust RocksDB Options》</a>文档即可。默认情况下，使用 Options::default() 可得到默认配置，这些配置可以满足大部分场景。</p><p>因为 RocksDB 的配置优化是一个很大和很复杂的话题，如果要进行针对性的配置调优，你就需要去看一下这个文档<a href=\"https://github.com/facebook/rocksdb/wiki/RocksDB-Overview\">《RocksDB 官方 wiki》</a>，去对 RocksDB 的底层运行原理（主要是LSM-Tree）、配置项所表达的意义有更多的了解，才能找到最适合自己场景的配置项。</p><ol start=\"2\">\n<li>初始化 RocksDB 实例</li>\n</ol><p>这一步的目的是<strong>初始化一个可以操作 RocksDB 的对象实例</strong>。主要流程是构建配置，判断是否已经初始化过 RocksDB，如果没有就初始化 DB，然后打开需要操作的列簇（ColumnFamily）即可。</p><pre><code class=\"language-plain\">// 初始化RocksDB 配置\nlet opts: Options = Self::open_db_opts(config);\n\n\n// 配置 RocksDB 的数据目录\nlet db_path = format!(\"{}/{}\", config.data_path, \"_storage_rocksdb\");\n\n\n// 判断 RocksDB 是否初始化成功，否则进行初始化。\nif !Path::new(&amp;db_path).exists() {\n  DB::open(&amp;opts, db_path.clone()).unwrap();\n}\n\n\n// 初始化 RocksDB 中的列簇。\nlet cf_list = rocksdb::DB::list_cf(&amp;opts, &amp;db_path).unwrap();\nlet mut instance = DB::open_cf(&amp;opts, db_path.clone(), &amp;cf_list).unwrap();\n</code></pre><p>上面这段代码需要关注的点是：<strong>初始化后的 instance 全局只能有一个。即一个 RocksDB 目录只能同时被一个实例持有，不能多次 Open 一个 Rock<strong><strong>s</strong></strong>DB 目录，否则就会报下面的错误</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/f2/3fc756d1b737bd6a66c530f0dyy209f2.png?wh=1580x292\" alt=\"图片\"></p><p>所以在实际使用中，需要<strong>通过 Arc 在多线程之间共享 RocksDB instance</strong>，即 <strong>Arc<instance></instance></strong>，代码如下：</p><pre><code class=\"language-plain\">let rocksdb_engine_handler: Arc&lt;RocksDBEngine&gt; = Arc::new(RocksDBEngine::new(&amp;config));\n</code></pre><p>在这里，你就会用到智能指针的 Arc ，通过它可以让同一个 RocksDBEngine 在多个线程中共享。</p><ol start=\"3\">\n<li>写数据（Write）</li>\n</ol><p>写数据代码实现比较简单。流程是先选择ColumnFamily，通过 serde_json 序列化数据，最后通过 put_cf 方法将数据写入到 RocksDB 中。</p><pre><code class=\"language-plain\">  pub fn write&lt;T: Serialize + std::fmt::Debug&gt;(\n        &amp;self,\n        cf: &amp;ColumnFamily,\n        key: &amp;str,\n        value: &amp;T,\n    ) -&gt; Result&lt;(), String&gt; {\n        match serde_json::to_string(&amp;value) {\n            Ok(serialized) =&gt; self\n                .db\n                .put_cf(cf, key, serialized.into_bytes())\n                .map_err(|err| format!(\"Failed to put to ColumnFamily:{:?}\", err)),\n            Err(err) =&gt; Err(format!(\n                \"Failed to serialize to String. T: {:?}, err: {:?}\",\n                value, err\n            )),\n        }\n    }\n\n\n</code></pre><p>上面这段代码需要注意的是，写入数据必须选择ColumnFamily，原因是<strong>作为元数据服务，它需要存储不同类型的数据，并且长期可能有较大的数据量。为了长期扩容、拆分、隔离的方便，就需要将数据进行逻辑拆分</strong>。</p><ol start=\"4\">\n<li>读（Get）/ 删除（Delete）数据，并判断数据是否存在（Exists）</li>\n</ol><p>读数据是通过RocksDB 的 get_cf 方法来获取到数据，Decord 后返回即可。</p><p>删除和判断数据是否存在是通过 delete、key_may_exist_cf 函数来完成功能。</p><pre><code class=\"language-plain\">// Read data from the RocksDB\npub fn read&lt;T: DeserializeOwned&gt;(\n        &amp;self,\n        cf: &amp;ColumnFamily,\n        key: &amp;str,\n    ) -&gt; Result&lt;Option&lt;T&gt;, String&gt; {\n        match self.db.get_cf(cf, key) {\n            Ok(opt) =&gt; match opt {\n                Some(found) =&gt; match String::from_utf8(found) {\n                    Ok(s) =&gt; match serde_json::from_str::&lt;T&gt;(&amp;s) {\n                        Ok(t) =&gt; Ok(Some(t)),\n                        Err(err) =&gt; Err(format!(\"Failed to deserialize: {:?}\", err)),\n                    },\n                    Err(err) =&gt; Err(format!(\"Failed to deserialize: {:?}\", err)),\n                },\n                None =&gt; Ok(None),\n            },\n            Err(err) =&gt; Err(format!(\"Failed to get from ColumnFamily: {:?}\", err)),\n        }\n    }\n   \n// 根据 key 删除数据\npub fn delete(&amp;self, cf: &amp;ColumnFamily, key: &amp;str) -&gt; Result&lt;(), RobustMQError&gt; {\n     return Ok(self.db.delete_cf(cf, key)?);\n}\n\n\n// 判断 key 是否存在\npub fn exist(&amp;self, cf: &amp;ColumnFamily, key: &amp;str) -&gt; bool {\n    self.db.key_may_exist_cf(cf, key)\n}\n\n\n</code></pre><ol start=\"5\">\n<li>根据前缀读取数据（read_prefix）</li>\n</ol><p>在实际项目中，除了 Set 和 Get 的需求，还有一个需求你经常会用到，就是<strong>前缀搜索</strong>。即根据某个 Key 的前缀来获取这个 Key 对应的所有数据。</p><p>比如我们需要存储集群中的 User，每个 User 的 key 如下：</p><pre><code class=\"language-plain\">pub fn storage_key_mqtt_user(cluster_name: &amp;String, user_name: &amp;String) -&gt; String {\n    return format!(\"/mqtt/user/{}/{}\", cluster_name, user_name);\n}\n</code></pre><p>如果要获取集群中所有的用户列表，肯定不能找一个地方存储所有的客户信息，然后 foreach 循环一个一个去获取。此时就可以用前缀搜索，前缀搜索的 key 如下：</p><pre><code class=\"language-plain\">pub fn storage_key_mqtt_user_cluster_prefix(cluster_name: &amp;String) -&gt; String {\n    return format!(\"/mqtt/user/{}\", cluster_name);\n}\n\n\n</code></pre><p>接下来，我们来看一下如何实现前缀搜索。</p><p>RocksDB 中提供了前缀搜索的功能。因为 RocksDB 底层存储数据时是根据 Key 排序存储的，所以前缀搜索的底层逻辑是：<strong>先通过 seek 方法找到该前缀对应的第一个 Key，再通过next 方法一个一个往后获取数据，从而得到该前缀对应的所有Key</strong>。</p><pre><code class=\"language-plain\">   // Search data by prefix\n    pub fn read_prefix(\n        &amp;self,\n        cf: &amp;ColumnFamily,\n        search_key: &amp;str,\n    ) -&gt; Vec&lt;HashMap&lt;String, Vec&lt;u8&gt;&gt;&gt; {\n        // 获取 ColumnFamily 的迭代器\n        let mut iter = self.db.raw_iterator_cf(cf);\n        \n        // 搜索到第一个匹配这个前缀的 key\n        iter.seek(search_key);\n\n\n        let mut result = Vec::new();\n\n\n        // 获取下一个 key 的值\n        while iter.valid() {\n            let key = iter.key();\n            let value = iter.value();\n\n\n            let mut raw = HashMap::new();\n            \n            // 如果 key 和 value 都为空，则退出循环\n            if key == None || value == None {\n                 break;\n            }\n            \n            let result_key = match String::from_utf8(key.unwrap().to_vec()) {\n                Ok(s) =&gt; s,\n                Err(_) =&gt; continue,\n            };\n\n\n            // 如果key 不匹配前缀，说明已经获取到所有这个前缀的 key，则退出循环。\n            if !result_key.starts_with(search_key) {\n                break;\n            }\n            raw.insert(result_key, value.unwrap().to_vec());\n            result.push(raw);\n            iter.next();\n        }\n        return result;\n    }\n\n\n</code></pre><p>这里，不知道你是否注意到下面这几行代码，代码的语意是：<strong>判断获取到的数据的Key 是否是搜索的前缀，否则，退出循环</strong>。</p><pre><code class=\"language-plain\"> if !result_key.starts_with(search_key) {\n    break;\n}\n</code></pre><p>这段代码非常重要，也是前缀搜索的核心。前面说到 RocksDB 的底层数据是根据 Key 顺序存储的，所以先通过 seek 定位到匹配前缀的第一个 key，然后往后逐个获取。</p><p>但是需要注意的是：<strong>next 方法不会判断数据的 Key 是否匹配这个前缀</strong>。如果不加这个判断，则会从 seek 到的 key 开始一直往后获取到整个 RocksDB 的所有数据。</p><p>所以每一次拿到数据后，就需要判断 Key 是否匹配我们需要的前缀，如果不匹配，就说明已经获取到同一个前缀的所有数据了，就可以退出循环。</p><p>到这里，我们就完成了 RocksDB 基础库的集成使用。从某种意义上来说，我们也就完成了单机存储层的开发。</p><p>比想象中简单非常多是吧，<strong>这就是使用现成的嵌入式键值库的好处</strong>，也是开源项目 RocksDB、LevelDB 设计的初衷，大大地简化高性能高可靠单机存储层的开发。</p><p>接下来我们来完成我们需要的功能：<strong>KV 型的数据存储</strong>。</p><h2>使用 RocksDB 存储 KV 数据</h2><p>我先来问一个问题，我们要存储一个 KV 数据，即 name= “mq”，此时底层应该怎么存储数据呢？</p><p>直观来讲，以 name 为 Key，mq 为 Value 存储就可以了。但是扩展一下：<strong>我们是不是需要知道数据的写入时间</strong><strong>、</strong><strong>数据来源（即来源 IP）等等信息</strong>。因此我们在底层存储数据时，就需要对数据进行包装，存储一些通用的数据，比如创建时间。</p><p>所以我们在底层存储数据的时候，是通过数据结构 StorageDataWrap 来包装保存数据的。</p><pre><code class=\"language-plain\">#[derive(Serialize, Deserialize, Debug)]\npub struct StorageDataWrap {\n    pub data: Vec&lt;u8&gt;,\n    pub create_time: u64,\n}\n\n\nimpl StorageDataWrap {\n    pub fn new(data: Vec&lt;u8&gt;) -&gt; Self {\n        return StorageDataWrap {\n            data,\n            create_time: now_second(),\n        };\n    }\n}\n</code></pre><p>接下来我们以保存数据为例，来看一下我们是如何完成 KV 模型数据存储的。来看下面的代码：</p><pre><code class=\"language-plain\">fn engine_save&lt;T&gt;(\n    rocksdb_engine_handler: Arc&lt;RocksDBEngine&gt;,\n    rocksdb_cluster: &amp;str,\n    key_name: String,\n    value: T,\n) -&gt; Result&lt;(), RobustMQError&gt;\nwhere\n    T: Serialize,\n{\n    let cf = if rocksdb_cluster.to_string() == DB_COLUMN_FAMILY_CLUSTER.to_string() {\n        rocksdb_engine_handler.cf_cluster()\n    } else {\n        return Err(RobustMQError::ClusterNoAvailableNode);\n    };\n\n\n    let content = match serde_json::to_vec(&amp;value) {\n        Ok(data) =&gt; data,\n        Err(e) =&gt; return Err(RobustMQError::CommmonError(e.to_string())),\n    };\n\n\n    let data = StorageDataWrap::new(content);\n    match rocksdb_engine_handler.write(cf, &amp;key_name, &amp;data) {\n        Ok(_) =&gt; {\n            return Ok(());\n        }\n        Err(e) =&gt; {\n            return Err(RobustMQError::CommmonError(e));\n        }\n    }\n}\n\n\n</code></pre><p>这里有 4 个关注点：</p><ol>\n<li>\n<p>RocksDBEngine 是封装了 RocksDB 读写的一个Struct，里面封装了对RocksDB的打开、读、写等操作。</p>\n</li>\n<li>\n<p>rocksdb_engine_handler: Arc<rocksdbengine>：你会发现这是通过智能指针 Arc 在多线程之间共享 RocksDBEngine。原因就是我们上面提到的，一个 RocksDB 只能由一个RocksDB对象持有，故需要在进程启动时，通过RocksDB 提供的DB::open_cf打开 RocksDB，然后通过智能指针 Arc 在多个线程中共享使用 RocksDBEngine。</rocksdbengine></p>\n</li>\n<li>\n<p>为了后续的拆分隔离方便，数据默认是写入到名为 cluster 的 ColumnFamily。</p>\n</li>\n<li>\n<p>数据值 Value 是一个泛型，它可以接收任何类型的数据，然后持久化存储。泛型 T 需要通过 Where 关键字限制 Value 必须实现 Serialize Trait。因为只有实现 Trait，它才能进行序列化。</p>\n</li>\n</ol><blockquote>\n<p>tips：在这部分，你就需要去复习泛型、Arc、Where 的语法，从实际编码角度来看，这三种语法的应用非常广泛。</p>\n</blockquote><p>这里留一个思考题： <strong>我们在</strong> <strong>engine_save</strong> <strong>和 write 方法中都有使用</strong> <strong>serde_json</strong> <strong>执行序列化，是不是重复了？是不是可以简化代码</strong><strong>？</strong></p><p>接下来我们可以封装一个 Struct 来根据 Key 保存数据。来看下面的代码：</p><pre><code class=\"language-plain\">pub struct KvStorage {\n    rocksdb_engine_handler: Arc&lt;RocksDBEngine&gt;,\n}\n\n\nimpl KvStorage {\n    pub fn new(rocksdb_engine_handler: Arc&lt;RocksDBEngine&gt;) -&gt; Self {\n        KvStorage {\n            rocksdb_engine_handler,\n        }\n    }\n\n\n    pub fn set(&amp;self, key: String, value: String) -&gt; Result&lt;(), RobustMQError&gt; {\n        return engine_save_by_cluster(self.rocksdb_engine_handler.clone(), key, value);\n    }\n}\n</code></pre><p>这段代码比较简单，Key 和 Value 都是 String 类型，直接调用engine_save_by_cluster保存即可。</p><p>在业务逻辑上，保存数据直接用 KvStorage 即可，如下所示：</p><pre><code class=\"language-plain\">pub fn set(&amp;self, value: Vec&lt;u8&gt;) -&gt; Result&lt;(), CommonError&gt; {\n    let req: SetRequest = SetRequest::decode(value.as_ref())?;\n    let kv_storage = KvStorage::new(rocksdb_engine_handler.clone());\n    return kv_storage.set(req.key, req.value);\n}\n</code></pre><p>其他 Get、Delete、List、Exists 方法，思路都是类似的，就不展开了，你可以查看 Demo 中的代码，了解更多。</p><h2>总结</h2><blockquote>\n<p>tips：每节课的代码都能在项目 <a href=\"https://github.com/robustmq/robustmq-geek\">https://github.com/robustmq/robustmq-geek</a> 中找到源码，有兴趣的同学可以下载源码来看。</p>\n</blockquote><p>这节课我们从选型考量开始讲起，讨论了为什么要选择 RocksDB，Rust RocksDB 的使用细节，以及如何使用 RocksDB 来存储 KV 型数据，进而实现了元数据存储服务的单机存储层。</p><p>从技术上来看，我们需要去重点理解为什么要用 RocksDB，有没有其他的选项。因为这个思路是通用的，我们实现其他存储系统的时候都可以借鉴。</p><p>在业界，使用 RocksDB 来实现单机存储层，是一个应用非常广泛的方案，如果你有类似的需求，建议优先考虑 RocksDB。</p><p>从 Rust 语法方面，泛型、序列化、智能指针等语法都会用到，需要你继续加深对这些语法的理解。</p><h2>思考题</h2><p>这里是本节课推荐的相关 issue 的任务列表，请点击查看<a href=\"http://www.robustmq.com/docs/robustmq-tutorial-cn/%e8%b4%a1%e7%8c%ae%e6%8c%87%e5%8d%97/good-first-issue/\">《Good First Issue》</a>，任务列表会不间断地更新。欢迎给我的项目 <a href=\"https://github.com/robustmq/robustmq\">https://github.com/robustmq/robustmq</a> 点个 Star 啊！</p>","neighbors":{"left":{"article_title":"05｜逻辑功能开发：网络层Server端如何选型？","id":809901},"right":{"article_title":"07｜基于Raft协议构建分布式集群（一）","id":810640}},"comments":[{"had_liked":false,"id":394851,"user_name":"Joe Black","can_delete":false,"product_type":"c1","uid":1052528,"ip_address":"北京","ucode":"21FE222A286445","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/70/cdef7a3d.jpg","comment_is_top":false,"comment_ctime":1728548930,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":2,"product_id":100818701,"comment_content":"读写rocksdb不需要mutex保护吗？只用了Arc","like_count":0,"discussions":[{"author":{"id":3981476,"avatar":"https://static001.geekbang.org/account/avatar/00/3c/c0/a4/9e403efd.jpg","nickname":"方","note":"","ucode":"37EAC097995CC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653544,"discussion_content":"rocksdb内部应该保证了多个线程操作同一个db的线程安全性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731078979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235903,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/bf/d990f851.jpg","nickname":"雪无痕","note":"","ucode":"261357711A568E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652312,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728659690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}