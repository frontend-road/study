{"id":224240,"title":"16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑","content":"<p>你好，我是朱晔。今天，我来和你说说恼人的时间错乱问题。</p><p>在Java 8之前，我们处理日期时间需求时，使用Date、Calender和SimpleDateFormat，来声明时间戳、使用日历处理日期和格式化解析日期时间。但是，这些类的API的缺点比较明显，比如可读性差、易用性差、使用起来冗余繁琐，还有线程安全问题。</p><p>因此，Java 8推出了新的日期时间类。每一个类功能明确清晰、类之间协作简单、API定义清晰不踩坑，API功能强大无需借助外部工具类即可完成操作，并且线程安全。</p><p>但是，Java 8刚推出的时候，诸如序列化、数据访问等类库都还不支持Java 8的日期时间类型，需要在新老类中来回转换。比如，在业务逻辑层使用LocalDateTime，存入数据库或者返回前端的时候还要切换回Date。因此，很多同学还是选择使用老的日期时间类。</p><p>现在几年时间过去了，几乎所有的类库都支持了新日期时间类型，使用起来也不会有来回切换等问题了。但，很多代码中因为还是用的遗留的日期时间类，因此出现了很多时间错乱的错误实践。比如，试图通过随意修改时区，使读取到的数据匹配当前时钟；再比如，试图直接对读取到的数据做加、减几个小时的操作，来“修正数据”。</p><!-- [[[read_end]]] --><p>今天，我就重点与你分析下时间错乱问题背后的原因，看看使用遗留的日期时间类，来处理日期时间初始化、格式化、解析、计算等可能会遇到的问题，以及如何使用新日期时间类来解决。</p><h2>初始化日期时间</h2><p>我们先从日期时间的初始化看起。如果要初始化一个2019年12月31日11点12分13秒这样的时间，可以使用下面的两行代码吗？</p><pre><code>Date date = new Date(2019, 12, 31, 11, 12, 13);\nSystem.out.println(date);\n</code></pre><p>可以看到，输出的时间是3029年1月31日11点12分13秒：</p><pre><code>Sat Jan 31 11:12:13 CST 3920\n</code></pre><p>相信看到这里，你会说这是新手才会犯的低级错误：年应该是和1900的差值，月应该是从0到11而不是从1到12。</p><pre><code>Date date = new Date(2019 - 1900, 11, 31, 11, 12, 13);\n</code></pre><p>你说的没错，但更重要的问题是，当有国际化需求时，需要使用Calendar类来初始化时间。</p><p>使用Calendar改造之后，初始化时年参数直接使用当前年即可，不过月需要注意是从0到11。当然，你也可以直接使用Calendar.DECEMBER来初始化月份，更不容易犯错。为了说明时区的问题，我分别使用当前时区和纽约时区初始化了两次相同的日期：</p><pre><code>Calendar calendar = Calendar.getInstance();\ncalendar.set(2019, 11, 31, 11, 12, 13);\nSystem.out.println(calendar.getTime());\nCalendar calendar2 = Calendar.getInstance(TimeZone.getTimeZone(&quot;America/New_York&quot;));\ncalendar2.set(2019, Calendar.DECEMBER, 31, 11, 12, 13);\nSystem.out.println(calendar2.getTime());\n</code></pre><p>输出显示了两个时间，说明时区产生了作用。但，我们更习惯年/月/日 时:分:秒这样的日期时间格式，对现在输出的日期格式还不满意：</p><pre><code>Tue Dec 31 11:12:13 CST 2019\nWed Jan 01 00:12:13 CST 2020\n</code></pre><p>那，时区的问题是怎么回事，又怎么格式化需要输出的日期时间呢？接下来，我就与你逐一分析下这两个问题。</p><h2>“恼人”的时区问题</h2><p>我们知道，全球有24个时区，同一个时刻不同时区（比如中国上海和美国纽约）的时间是不一样的。对于需要全球化的项目，如果初始化时间时没有提供时区，那就不是一个真正意义上的时间，只能认为是我看到的当前时间的一个表示。</p><p>关于Date类，我们要有两点认识：</p><ul>\n<li>一是，Date并无时区问题，世界上任何一台计算机使用new Date()初始化得到的时间都一样。因为，Date中保存的是UTC时间，UTC是以原子钟为基础的统一时间，不以太阳参照计时，并无时区划分。</li>\n<li>二是，Date中保存的是一个时间戳，代表的是从1970年1月1日0点（Epoch时间）到现在的毫秒数。尝试输出Date(0)：</li>\n</ul><pre><code>System.out.println(new Date(0));\nSystem.out.println(TimeZone.getDefault().getID() + &quot;:&quot; + TimeZone.getDefault().getRawOffset()/3600000);\n</code></pre><p>我得到的是1970年1月1日8点。因为我机器当前的时区是中国上海，相比UTC时差+8小时：</p><pre><code>Thu Jan 01 08:00:00 CST 1970\nAsia/Shanghai:8\n</code></pre><p>对于国际化（世界各国的人都在使用）的项目，处理好时间和时区问题首先就是要正确保存日期时间。这里有两种保存方式：</p><ul>\n<li>方式一，以UTC保存，保存的时间没有时区属性，是不涉及时区时间差问题的世界统一时间。我们通常说的时间戳，或Java中的Date类就是用的这种方式，这也是推荐的方式。</li>\n<li>方式二，以字面量保存，比如年/月/日 时:分:秒，一定要同时保存时区信息。只有有了时区信息，我们才能知道这个字面量时间真正的时间点，否则它只是一个给人看的时间表示，只在当前时区有意义。Calendar是有时区概念的，所以我们通过不同的时区初始化Calendar，得到了不同的时间。</li>\n</ul><p>正确保存日期时间之后，就是正确展示，即我们要使用正确的时区，把时间点展示为符合当前时区的时间表示。到这里，我们就能理解为什么会有所谓的“时间错乱”问题了。接下来，我再通过实际案例分析一下，从字面量解析成时间和从时间格式化为字面量这两类问题。</p><p><strong>第一类是</strong>，对于同一个时间表示，比如2020-01-02 22:00:00，不同时区的人转换成Date会得到不同的时间（时间戳）：</p><pre><code>String stringDate = &quot;2020-01-02 22:00:00&quot;;\nSimpleDateFormat inputFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n//默认时区解析时间表示\nDate date1 = inputFormat.parse(stringDate);\nSystem.out.println(date1 + &quot;:&quot; + date1.getTime());\n//纽约时区解析时间表示\ninputFormat.setTimeZone(TimeZone.getTimeZone(&quot;America/New_York&quot;));\nDate date2 = inputFormat.parse(stringDate);\nSystem.out.println(date2 + &quot;:&quot; + date2.getTime());\n</code></pre><p>可以看到，把2020-01-02 22:00:00这样的时间表示，对于当前的上海时区和纽约时区，转化为UTC时间戳是不同的时间：</p><pre><code>Thu Jan 02 22:00:00 CST 2020:1577973600000\nFri Jan 03 11:00:00 CST 2020:1578020400000\n</code></pre><p>这正是UTC的意义，并不是时间错乱。对于同一个本地时间的表示，不同时区的人解析得到的UTC时间一定是不同的，反过来不同的本地时间可能对应同一个UTC。</p><p><strong>第二类问题是</strong>，格式化后出现的错乱，即同一个Date，在不同的时区下格式化得到不同的时间表示。比如，在我的当前时区和纽约时区格式化2020-01-02 22:00:00：</p><pre><code>String stringDate = &quot;2020-01-02 22:00:00&quot;;\nSimpleDateFormat inputFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n//同一Date\nDate date = inputFormat.parse(stringDate);\n//默认时区格式化输出：\nSystem.out.println(new SimpleDateFormat(&quot;[yyyy-MM-dd HH:mm:ss Z]&quot;).format(date));\n//纽约时区格式化输出\nTimeZone.setDefault(TimeZone.getTimeZone(&quot;America/New_York&quot;));\nSystem.out.println(new SimpleDateFormat(&quot;[yyyy-MM-dd HH:mm:ss Z]&quot;).format(date));\n</code></pre><p>输出如下，我当前时区的Offset（时差）是+8小时，对于-5小时的纽约，晚上10点对应早上9点：</p><pre><code>[2020-01-02 22:00:00 +0800]\n[2020-01-02 09:00:00 -0500]\n</code></pre><p>因此，有些时候数据库中相同的时间，由于服务器的时区设置不同，读取到的时间表示不同。这，不是时间错乱，正是时区发挥了作用，因为UTC时间需要根据当前时区解析为正确的本地时间。</p><p>所以，<strong>要正确处理时区，在于存进去和读出来两方面</strong>：存的时候，需要使用正确的当前时区来保存，这样UTC时间才会正确；读的时候，也只有正确设置本地时区，才能把UTC时间转换为正确的当地时间。</p><p>Java 8推出了新的时间日期类ZoneId、ZoneOffset、LocalDateTime、ZonedDateTime和DateTimeFormatter，处理时区问题更简单清晰。我们再用这些类配合一个完整的例子，来理解一下时间的解析和展示：</p><ul>\n<li>首先初始化上海、纽约和东京三个时区。我们可以使用ZoneId.of来初始化一个标准的时区，也可以使用ZoneOffset.ofHours通过一个offset，来初始化一个具有指定时间差的自定义时区。</li>\n<li>对于日期时间表示，LocalDateTime不带有时区属性，所以命名为本地时区的日期时间；而ZonedDateTime=LocalDateTime+ZoneId，具有时区属性。因此，LocalDateTime只能认为是一个时间表示，ZonedDateTime才是一个有效的时间。在这里我们把2020-01-02 22:00:00这个时间表示，使用东京时区来解析得到一个ZonedDateTime。</li>\n<li>使用DateTimeFormatter格式化时间的时候，可以直接通过withZone方法直接设置格式化使用的时区。最后，分别以上海、纽约和东京三个时区来格式化这个时间输出：</li>\n</ul><pre><code>//一个时间表示\nString stringDate = &quot;2020-01-02 22:00:00&quot;;\n//初始化三个时区\nZoneId timeZoneSH = ZoneId.of(&quot;Asia/Shanghai&quot;);\nZoneId timeZoneNY = ZoneId.of(&quot;America/New_York&quot;);\nZoneId timeZoneJST = ZoneOffset.ofHours(9);\n//格式化器\nDateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);\nZonedDateTime date = ZonedDateTime.of(LocalDateTime.parse(stringDate, dateTimeFormatter), timeZoneJST);\n//使用DateTimeFormatter格式化时间，可以通过withZone方法直接设置格式化使用的时区\nDateTimeFormatter outputFormat = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss Z&quot;);\nSystem.out.println(timeZoneSH.getId() + outputFormat.withZone(timeZoneSH).format(date));\nSystem.out.println(timeZoneNY.getId() + outputFormat.withZone(timeZoneNY).format(date));\nSystem.out.println(timeZoneJST.getId() + outputFormat.withZone(timeZoneJST).format(date));\n</code></pre><p>可以看到，相同的时区，经过解析存进去和读出来的时间表示是一样的（比如最后一行）；而对于不同的时区，比如上海和纽约，最后输出的本地时间不同。+9小时时区的晚上10点，对于上海是+8小时，所以上海本地时间是晚上9点；而对于纽约是-5小时，差14小时，所以是早上8点：</p><pre><code>Asia/Shanghai2020-01-02 21:00:00 +0800\nAmerica/New_York2020-01-02 08:00:00 -0500\n+09:002020-01-02 22:00:00 +0900\n</code></pre><p>到这里，我来小结下。要正确处理国际化时间问题，我推荐使用Java 8的日期时间类，即使用ZonedDateTime保存时间，然后使用设置了ZoneId的DateTimeFormatter配合ZonedDateTime进行时间格式化得到本地时间表示。这样的划分十分清晰、细化，也不容易出错。</p><p>接下来，我们继续看看对于日期时间的格式化和解析，使用遗留的SimpleDateFormat，会遇到哪些问题。</p><h2>日期时间格式化和解析</h2><p>每到年底，就有很多开发同学踩时间格式化的坑，比如“这明明是一个2019年的日期，<strong>怎么使用SimpleDateFormat格式化后就提前跨年了</strong>”。我们来重现一下这个问题。</p><p>初始化一个Calendar，设置日期时间为2019年12月29日，使用大写的YYYY来初始化SimpleDateFormat：</p><pre><code>Locale.setDefault(Locale.SIMPLIFIED_CHINESE);\nSystem.out.println(&quot;defaultLocale:&quot; + Locale.getDefault());\nCalendar calendar = Calendar.getInstance();\ncalendar.set(2019, Calendar.DECEMBER, 29,0,0,0);\nSimpleDateFormat YYYY = new SimpleDateFormat(&quot;YYYY-MM-dd&quot;);\nSystem.out.println(&quot;格式化: &quot; + YYYY.format(calendar.getTime()));\nSystem.out.println(&quot;weekYear:&quot; + calendar.getWeekYear());\nSystem.out.println(&quot;firstDayOfWeek:&quot; + calendar.getFirstDayOfWeek());\nSystem.out.println(&quot;minimalDaysInFirstWeek:&quot; + calendar.getMinimalDaysInFirstWeek());\n</code></pre><p>得到的输出却是2020年12月29日：</p><pre><code>defaultLocale:zh_CN\n格式化: 2020-12-29\nweekYear:2020\nfirstDayOfWeek:1\nminimalDaysInFirstWeek:1\n</code></pre><p>出现这个问题的原因在于，这位同学混淆了SimpleDateFormat的各种格式化模式。JDK的<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html\">文档</a>中有说明：小写y是年，而大写Y是week year，也就是所在的周属于哪一年。</p><p>一年第一周的判断方式是，从getFirstDayOfWeek()开始，完整的7天，并且包含那一年至少getMinimalDaysInFirstWeek()天。这个计算方式和区域相关，对于当前zh_CN区域来说，2020年第一周的条件是，从周日开始的完整7天，2020年包含1天即可。显然，2019年12月29日周日到2020年1月4日周六是2020年第一周，得出的week year就是2020年。</p><p>如果把区域改为法国：</p><pre><code>Locale.setDefault(Locale.FRANCE);\n</code></pre><p>那么week yeay就还是2019年，因为一周的第一天从周一开始算，2020年的第一周是2019年12月30日周一开始，29日还是属于去年：</p><pre><code>defaultLocale:fr_FR\n格式化: 2019-12-29\nweekYear:2019\nfirstDayOfWeek:2\nminimalDaysInFirstWeek:4\n</code></pre><p>这个案例告诉我们，没有特殊需求，针对年份的日期格式化，应该一律使用 “y” 而非 “Y”。</p><p>除了格式化表达式容易踩坑外，SimpleDateFormat还有两个著名的坑。</p><p>第一个坑是，<strong>定义的static的SimpleDateFormat可能会出现线程安全问题。</strong>比如像这样，使用一个100线程的线程池，循环20次把时间格式化任务提交到线程池处理，每个任务中又循环10次解析2020-01-01 11:12:13这样一个时间表示：</p><pre><code>ExecutorService threadPool = Executors.newFixedThreadPool(100);\nfor (int i = 0; i &lt; 20; i++) {\n    //提交20个并发解析时间的任务到线程池，模拟并发环境\n    threadPool.execute(() -&gt; {\n        for (int j = 0; j &lt; 10; j++) {\n            try {\n                System.out.println(simpleDateFormat.parse(&quot;2020-01-01 11:12:13&quot;));\n            } catch (ParseException e) {\n                e.printStackTrace();\n            }\n        }\n    });\n}\nthreadPool.shutdown();\nthreadPool.awaitTermination(1, TimeUnit.HOURS);\n</code></pre><p>运行程序后大量报错，且没有报错的输出结果也不正常，比如2020年解析成了1212年：</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/27/3ee2e923b3cf4e13722b7b0773de1b27.png?wh=3040*1530\" alt=\"\"></p><p>SimpleDateFormat的作用是定义解析和格式化日期时间的模式。这，看起来这是一次性的工作，应该复用，但它的解析和格式化操作是非线程安全的。我们来分析一下相关源码：</p><ul>\n<li>SimpleDateFormat继承了DateFormat，DateFormat有一个字段Calendar；</li>\n<li>SimpleDateFormat的parse方法调用CalendarBuilder的establish方法，来构建Calendar；</li>\n<li>establish方法内部先清空Calendar再构建Calendar，整个操作没有加锁。</li>\n</ul><p>显然，如果多线程池调用parse方法，也就意味着多线程在并发操作一个Calendar，可能会产生一个线程还没来得及处理Calendar就被另一个线程清空了的情况：</p><pre><code>public abstract class DateFormat extends Format {\n    protected Calendar calendar;\n}\npublic class SimpleDateFormat extends DateFormat {\n    @Override\n    public Date parse(String text, ParsePosition pos)\n    {\n        CalendarBuilder calb = new CalendarBuilder();\n\t\tparsedDate = calb.establish(calendar).getTime();\n        return parsedDate;\n    }\n}\n\nclass CalendarBuilder {\n\tCalendar establish(Calendar cal) {\n       \t...\n        cal.clear();//清空\n        \n        for (int stamp = MINIMUM_USER_STAMP; stamp &lt; nextStamp; stamp++) {\n            for (int index = 0; index &lt;= maxFieldIndex; index++) {\n                if (field[index] == stamp) {\n                    cal.set(index, field[MAX_FIELD + index]);//构建\n                    break;\n                }\n            }\n        }\n        return cal;\n    }\n}\n</code></pre><p>format方法也类似，你可以自己分析。因此只能在同一个线程复用SimpleDateFormat，比较好的解决方式是，通过ThreadLocal来存放SimpleDateFormat：</p><pre><code>private static ThreadLocal&lt;SimpleDateFormat&gt; threadSafeSimpleDateFormat = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));\n</code></pre><p>第二个坑是，<strong>当需要解析的字符串和格式不匹配的时候，SimpleDateFormat表现得很宽容</strong>，还是能得到结果。比如，我们期望使用yyyyMM来解析20160901字符串：</p><pre><code>String dateString = &quot;20160901&quot;;\nSimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyyMM&quot;);\nSystem.out.println(&quot;result:&quot; + dateFormat.parse(dateString));\n</code></pre><p>居然输出了2091年1月1日，原因是把0901当成了月份，相当于75年：</p><pre><code>result:Mon Jan 01 00:00:00 CST 2091\n</code></pre><p>对于SimpleDateFormat的这三个坑，我们使用Java 8中的DateTimeFormatter就可以避过去。首先，使用DateTimeFormatterBuilder来定义格式化字符串，不用去记忆使用大写的Y还是小写的Y，大写的M还是小写的m：</p><pre><code>private static DateTimeFormatter dateTimeFormatter = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR) //年\n        .appendLiteral(&quot;/&quot;)\n        .appendValue(ChronoField.MONTH_OF_YEAR) //月\n        .appendLiteral(&quot;/&quot;)\n        .appendValue(ChronoField.DAY_OF_MONTH) //日\n        .appendLiteral(&quot; &quot;)\n        .appendValue(ChronoField.HOUR_OF_DAY) //时\n        .appendLiteral(&quot;:&quot;)\n        .appendValue(ChronoField.MINUTE_OF_HOUR) //分\n        .appendLiteral(&quot;:&quot;)\n        .appendValue(ChronoField.SECOND_OF_MINUTE) //秒\n        .appendLiteral(&quot;.&quot;)\n        .appendValue(ChronoField.MILLI_OF_SECOND) //毫秒\n        .toFormatter();\n</code></pre><p>其次，DateTimeFormatter是线程安全的，可以定义为static使用；最后，DateTimeFormatter的解析比较严格，需要解析的字符串和格式不匹配时，会直接报错，而不会把0901解析为月份。我们测试一下：</p><pre><code>//使用刚才定义的DateTimeFormatterBuilder构建的DateTimeFormatter来解析这个时间\nLocalDateTime localDateTime = LocalDateTime.parse(&quot;2020/1/2 12:34:56.789&quot;, dateTimeFormatter);\n//解析成功\nSystem.out.println(localDateTime.format(dateTimeFormatter));\n//使用yyyyMM格式解析20160901是否可以成功呢？\nString dt = &quot;20160901&quot;;\nDateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyyMM&quot;);\nSystem.out.println(&quot;result:&quot; + dateTimeFormatter.parse(dt));\n</code></pre><p>输出日志如下：</p><pre><code>2020/1/2 12:34:56.789\nException in thread &quot;main&quot; java.time.format.DateTimeParseException: Text '20160901' could not be parsed at index 0\n\tat java.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:1949)\n\tat java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:1777)\n\tat org.geekbang.time.commonmistakes.datetime.dateformat.CommonMistakesApplication.better(CommonMistakesApplication.java:80)\n\tat org.geekbang.time.commonmistakes.datetime.dateformat.CommonMistakesApplication.main(CommonMistakesApplication.java:41)\n</code></pre><p>到这里我们可以发现，使用Java 8中的DateTimeFormatter进行日期时间的格式化和解析，显然更让人放心。那么，对于日期时间的运算，使用Java 8中的日期时间类会不会更简单呢？</p><h2>日期时间的计算</h2><p>关于日期时间的计算，我先和你说一个常踩的坑。有些同学喜欢直接使用时间戳进行时间计算，比如希望得到当前时间之后30天的时间，会这么写代码：直接把new Date().getTime方法得到的时间戳加30天对应的毫秒数，也就是30天*1000毫秒*3600秒*24小时：</p><pre><code>Date today = new Date();\nDate nextMonth = new Date(today.getTime() + 30 * 1000 * 60 * 60 * 24);\nSystem.out.println(today);\nSystem.out.println(nextMonth);\n</code></pre><p>得到的日期居然比当前日期还要早，根本不是晚30天的时间：</p><pre><code>Sat Feb 01 14:17:41 CST 2020\nSun Jan 12 21:14:54 CST 2020\n</code></pre><p>出现这个问题，<strong>其实是因为int发生了溢出</strong>。修复方式就是把30改为30L，让其成为一个long：</p><pre><code>Date today = new Date();\nDate nextMonth = new Date(today.getTime() + 30L * 1000 * 60 * 60 * 24);\nSystem.out.println(today);\nSystem.out.println(nextMonth);\n</code></pre><p>这样就可以得到正确结果了：</p><pre><code>Sat Feb 01 14:17:41 CST 2020\nMon Mar 02 14:17:41 CST 2020\n</code></pre><p>不难发现，手动在时间戳上进行计算操作的方式非常容易出错。对于Java 8之前的代码，我更建议使用Calendar：</p><pre><code>Calendar c = Calendar.getInstance();\nc.setTime(new Date());\nc.add(Calendar.DAY_OF_MONTH, 30);\nSystem.out.println(c.getTime());\n</code></pre><p>使用Java 8的日期时间类型，可以直接进行各种计算，更加简洁和方便：</p><pre><code>LocalDateTime localDateTime = LocalDateTime.now();\nSystem.out.println(localDateTime.plusDays(30));\n</code></pre><p>并且，<strong>对日期时间做计算操作，Java 8日期时间API会比Calendar功能强大很多</strong>。</p><p>第一，可以使用各种minus和plus方法直接对日期进行加减操作，比如如下代码实现了减一天和加一天，以及减一个月和加一个月：</p><pre><code>System.out.println(&quot;//测试操作日期&quot;);\nSystem.out.println(LocalDate.now()\n        .minus(Period.ofDays(1))\n        .plus(1, ChronoUnit.DAYS)\n        .minusMonths(1)\n        .plus(Period.ofMonths(1)));\n</code></pre><p>可以得到：</p><pre><code>//测试操作日期\n2020-02-01\n</code></pre><p>第二，还可以通过with方法进行快捷时间调节，比如：</p><ul>\n<li>使用TemporalAdjusters.firstDayOfMonth得到当前月的第一天；</li>\n<li>使用TemporalAdjusters.firstDayOfYear()得到当前年的第一天；</li>\n<li>使用TemporalAdjusters.previous(DayOfWeek.SATURDAY)得到上一个周六；</li>\n<li>使用TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY)得到本月最后一个周五。</li>\n</ul><pre><code>System.out.println(&quot;//本月的第一天&quot;);\nSystem.out.println(LocalDate.now().with(TemporalAdjusters.firstDayOfMonth()));\n\nSystem.out.println(&quot;//今年的程序员日&quot;);\nSystem.out.println(LocalDate.now().with(TemporalAdjusters.firstDayOfYear()).plusDays(255));\n\nSystem.out.println(&quot;//今天之前的一个周六&quot;);\nSystem.out.println(LocalDate.now().with(TemporalAdjusters.previous(DayOfWeek.SATURDAY)));\n\nSystem.out.println(&quot;//本月最后一个工作日&quot;);\nSystem.out.println(LocalDate.now().with(TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY)));\n</code></pre><p>输出如下：</p><pre><code>//本月的第一天\n2020-02-01\n//今年的程序员日\n2020-09-12\n//今天之前的一个周六\n2020-01-25\n//本月最后一个工作日\n2020-02-28\n</code></pre><p>第三，可以直接使用lambda表达式进行自定义的时间调整。比如，为当前时间增加100天以内的随机天数：</p><pre><code>System.out.println(LocalDate.now().with(temporal -&gt; temporal.plus(ThreadLocalRandom.current().nextInt(100), ChronoUnit.DAYS)));\n</code></pre><p>得到：</p><pre><code>2020-03-15\n</code></pre><p>除了计算外，还可以判断日期是否符合某个条件。比如，自定义函数，判断指定日期是否是家庭成员的生日：</p><pre><code>public static Boolean isFamilyBirthday(TemporalAccessor date) {\n    int month = date.get(MONTH_OF_YEAR);\n    int day = date.get(DAY_OF_MONTH);\n    if (month == Month.FEBRUARY.getValue() &amp;&amp; day == 17)\n        return Boolean.TRUE;\n    if (month == Month.SEPTEMBER.getValue() &amp;&amp; day == 21)\n        return Boolean.TRUE;\n    if (month == Month.MAY.getValue() &amp;&amp; day == 22)\n        return Boolean.TRUE;\n    return Boolean.FALSE;\n}\n</code></pre><p>然后，使用query方法查询是否匹配条件：</p><pre><code>System.out.println(&quot;//查询是否是今天要举办生日&quot;);\nSystem.out.println(LocalDate.now().query(CommonMistakesApplication::isFamilyBirthday));\n</code></pre><p>使用Java 8操作和计算日期时间虽然方便，但计算两个日期差时可能会踩坑：<strong>Java 8中有一个专门的类Period定义了日期间隔，通过Period.between得到了两个LocalDate的差，返回的是两个日期差几年零几月零几天。如果希望得知两个日期之间差几天，直接调用Period的getDays()方法得到的只是最后的“零几天”，而不是算总的间隔天数</strong>。</p><p>比如，计算2019年12月12日和2019年10月1日的日期间隔，很明显日期差是2个月零11天，但获取getDays方法得到的结果只是11天，而不是72天：</p><pre><code>System.out.println(&quot;//计算日期差&quot;);\nLocalDate today = LocalDate.of(2019, 12, 12);\nLocalDate specifyDate = LocalDate.of(2019, 10, 1);\nSystem.out.println(Period.between(specifyDate, today).getDays());\nSystem.out.println(Period.between(specifyDate, today));\nSystem.out.println(ChronoUnit.DAYS.between(specifyDate, today));\n</code></pre><p>可以使用ChronoUnit.DAYS.between解决这个问题：</p><pre><code>//计算日期差\n11\nP2M11D\n72\n</code></pre><p>从日期时间的时区到格式化再到计算，你是不是体会到Java 8日期时间类的强大了呢？</p><h2>重点回顾</h2><p>今天，我和你一起看了日期时间的初始化、时区、格式化、解析和计算的问题。我们看到，使用Java 8中的日期时间包Java.time的类进行各种操作，会比使用遗留的Date、Calender和SimpleDateFormat更简单、清晰，功能也更丰富、坑也比较少。</p><p>如果有条件的话，我还是建议全面改为使用Java 8的日期时间类型。我把Java 8前后的日期时间类型，汇总到了一张思维导图上，图中箭头代表的是新老类型在概念上等价的类型：</p><p><img src=\"https://static001.geekbang.org/resource/image/22/33/225d00087f500dbdf5e666e58ead1433.png?wh=1740*970\" alt=\"\"></p><p>这里有个误区是，认为java.util.Date类似于新API中的LocalDateTime。其实不是，虽然它们都没有时区概念，但java.util.Date类是因为使用UTC表示，所以没有时区概念，其本质是时间戳；而LocalDateTime，严格上可以认为是一个日期时间的表示，而不是一个时间点。</p><p>因此，在把Date转换为LocalDateTime的时候，需要通过Date的toInstant方法得到一个UTC时间戳进行转换，并需要提供当前的时区，这样才能把UTC时间转换为本地日期时间（的表示）。反过来，把LocalDateTime的时间表示转换为Date时，也需要提供时区，用于指定是哪个时区的时间表示，也就是先通过atZone方法把LocalDateTime转换为ZonedDateTime，然后才能获得UTC时间戳：</p><pre><code>Date in = new Date();\nLocalDateTime ldt = LocalDateTime.ofInstant(in.toInstant(), ZoneId.systemDefault());\nDate out = Date.from(ldt.atZone(ZoneId.systemDefault()).toInstant());\n</code></pre><p>很多同学说使用新API很麻烦，还需要考虑时区的概念，一点都不简洁。但我通过这篇文章要和你说的是，并不是因为API需要设计得这么繁琐，而是UTC时间要变为当地时间，必须考虑时区。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>我今天多次强调Date是一个时间戳，是UTC时间、没有时区概念，为什么调用其toString方法会输出类似CST之类的时区字样呢？</li>\n<li>日期时间数据始终要保存到数据库中，MySQL中有两种数据类型datetime和timestamp可以用来保存日期时间。你能说说它们的区别吗，它们是否包含时区信息呢？</li>\n</ol><p>对于日期和时间，你还遇到过什么坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"15 | 序列化：一来一回你还是原来的你吗？","id":223111},"right":{"article_title":"17 | 别以为“自动挡”就不可能出现OOM","id":224784}},"comments":[{"had_liked":false,"id":207146,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1587016117,"is_pvip":true,"replies":[{"id":"77390","content":"很全面","user_name":"作者回复","comment_id":207146,"uid":"1001470","ip_address":"","utype":1,"ctime":1587017254,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"199155511733","product_id":100047701,"comment_content":"试着回到下问题：<br>第一个：<br>Date的toString()方法处理的，同String中有BaseCalendar.Date date = normalize();<br>而normalize中进行这样处理cdate = (BaseCalendar.Date) cal.getCalendarDate(fastTime,TimeZone.getDefaultRef()；<br>因此其实是获取当前的默认时区的。<br>第二个：<br>从下面几个维度进行区分：<br>占用空间：datetime：8字节。timestamp 4字节<br>表示范围：datetime\t&#39;1000-01-01 00:00:00.000000&#39; to &#39;9999-12-31 23:59:59.999999&#39;<br>\t\ttimestamp\t&#39;1970-01-01 00:00:01.000000&#39; to &#39;2038-01-19 03:14:07.999999&#39;<br>时区：timestamp 只占 4 个字节，而且是以utc的格式储存， 它会自动检索当前时区并进行转换。<br>\tdatetime以 8 个字节储存，不会进行时区的检索.<br>\t也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。<br>更新：timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP；<br>\t这个特性是自动初始化和自动更新（Automatic Initialization and Updating）。<br>\t自动更新指的是如果修改了其它字段，则该字段的值将自动更新为当前系统时间。<br>\t它与“explicit_defaults_for_timestamp”参数有关。<br><br>\tBy default, the first TIMESTAMP column has both DEFAULT CURRENT_TIMESTAMP and ON UPDATE CURRENT_TIMESTAMP if neither is specified explicitly。<br>\t很多时候，这并不是我们想要的，如何禁用呢？<br>\t\t1. 将“explicit_defaults_for_timestamp”的值设置为ON。<br>\t\t2. “explicit_defaults_for_timestamp”的值依旧是OFF，也有两种方法可以禁用<br>     \t\t1&gt; 用DEFAULT子句该该列指定一个默认值<br>     \t\t2&gt; 为该列指定NULL属性。<br><br><br>    在MySQL 5.6.5版本之前，Automatic Initialization and Updating只适用于TIMESTAMP，而且一张表中，最多允许一个TIMESTAMP字段采用该特性。从MySQL 5.6.5开始，Automatic Initialization and Updating同时适用于TIMESTAMP和DATETIME，且不限制数量。","like_count":47,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492024,"discussion_content":"很全面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587017254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438157,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/cd/210d3c74.jpg","nickname":"dongdong5820","note":"","ucode":"272431574E123E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567725,"discussion_content":"课代表就是牛🐮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650982480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294066,"discussion_content":"课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595773304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207065,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1587001996,"is_pvip":false,"replies":[{"id":"77381","content":"保存和传输用时间戳的确比较方便，用带有时区的字面量时间表示字符串，还有格式不统一的问题","user_name":"作者回复","comment_id":207065,"uid":"1001470","ip_address":"","utype":1,"ctime":1587012759,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"78896413324","product_id":100047701,"comment_content":"对于时间，我个人的理解和目前的使用经验是——能用时间戳就用时间戳。<br>时间戳有几个优势：<br>1，便于比较和排序，无论数据库还是后台业务中都是如此。<br>2，也比较便于计算，虽然文中提到了Long的问题，但是，我认为L的问题的根本在于Long类型的理解，不是时间戳这个业务的问题。对Long的基础比较好了之后，也就足以应对计算中的问题了。<br>3，多端统一，现在提供给前端的很多服务都采用直接转换好年月日的字符串了，但是有时候，前端需要对时间进行比较的时候还是需要额外转化，会很麻烦。而且不利于格式化。时间戳的话就避免了这个问题，自己进行计算，自己格式化。前端自己随便玩。<br>","like_count":18,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491997,"discussion_content":"保存和传输用时间戳的确比较方便，用带有时区的字面量时间表示字符串，还有格式不统一的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587012759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239242,"discussion_content":"现在我们出接口的时候，前端都要求我们给时间格式的时候都是转好的字符串，都是统一这种格式：\nyyyy-MM-dd HH:mm:ss\n前端拿来直接展示，最多自己拼接下，他们的理由的是格式化这种操作特别耗费性能，而且后台给出的格式均应该统一，不能出现五花八门的时间格式，yyyy-MM-dd HH:mm:ss这种格式要么直接展示，要么截取下。\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587286698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b4/f6/e39d5af1.jpg","nickname":"钱米","note":"","ucode":"07AA44C6A40D34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390722,"discussion_content":"那这个时间戳在数据库中是指什么，代码中指什么？（数据库timestamp&amp;代码Date）or（数据库bigint&amp;代码Long）？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629988540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207027,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1586998149,"is_pvip":false,"replies":[{"id":"77347","content":"是","user_name":"作者回复","comment_id":207027,"uid":"1001470","ip_address":"","utype":1,"ctime":1587005089,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"57421572997","product_id":100047701,"comment_content":"第一个问题，虽然 Date 本质是一个时间戳没有时区的概念，但是在 toString 的时候为了可读性会推测当前时区，如果得不到就会使用 GMT。","like_count":13,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491985,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587005089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207062,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1587001364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48831641620","product_id":100047701,"comment_content":"思考题1:<br>根本原因在于toString的源代码：<br>sb.append(zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US)); &#47;&#47; zzz 这一行。<br>Date的toString实际上，是新建一个StringBuilder，然后根据Date对象里的年月日周，将其格式化。<br>格式化过程中，似乎会获取系统默认的时区，如果取不到系统默认时区，就使用GMT。<br>为了测试我的猜想，我尝试更改本机时区，结果输出：<br>Wed Apr 15 21:40:10 EDT 2020<br>相比较正常自动时区<br>Thu Apr 16 09:41:31 CST 2020<br>基本与我的猜测一致。<br><br><br><br>","like_count":11},{"had_liked":false,"id":207076,"user_name":"俊柱","can_delete":false,"product_type":"c1","uid":1439043,"ip_address":"","ucode":"7067F256DAFF9B","user_header":"https://static001.geekbang.org/account/avatar/00/15/f5/43/b882ab43.jpg","comment_is_top":false,"comment_ctime":1587003189,"is_pvip":false,"replies":[{"id":"77372","content":"大多数时候项目没有全球化需求映射到本地时区即可，可以使用LocalDateTime。<br><br>不过我们说datetime不包含时区，是固定的时间表示仅仅是指MySQL本身。使用timestamp，需要考虑Java进程的时区和MySQL连接的时区。而使用datetime类型，则只需要考虑Java进程的时区（因为MySQL datetime没有时区信息了，JDBC时间戳转换成MySQL datetime，会根据MySQL的serverTimezone做一次转换）<br><br>具体你可能需要自己多做一些实验来理解，几个层面<br>1、mysql本身对于datetime和timestamp的区别<br>2、java应用和mysql交互时的关系","user_name":"作者回复","comment_id":207076,"uid":"1001470","ip_address":"","utype":1,"ctime":1587009562,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"18766872373","product_id":100047701,"comment_content":"老师，映射表的bean，若数据库字段为 Timestamp，那 java 的字段应该设为 ZonedDateTime 最为合理吗？ 因为我看网上很多人都是用 LocalDateTime 进行映射","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492001,"discussion_content":"大多数时候项目没有全球化需求映射到本地时区即可，可以使用LocalDateTime。\n\n不过我们说datetime不包含时区，是固定的时间表示仅仅是指MySQL本身。使用timestamp，需要考虑Java进程的时区和MySQL连接的时区。而使用datetime类型，则只需要考虑Java进程的时区（因为MySQL datetime没有时区信息了，JDBC时间戳转换成MySQL datetime，会根据MySQL的serverTimezone做一次转换）\n\n具体你可能需要自己多做一些实验来理解，几个层面\n1、mysql本身对于datetime和timestamp的区别\n2、java应用和mysql交互时的关系","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587009562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223797,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1591182848,"is_pvip":false,"replies":[{"id":"82416","content":"好吧，不过ThreadLocal可以用的","user_name":"作者回复","comment_id":223797,"uid":"1001470","ip_address":"","utype":1,"ctime":1591187675,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"14476084736","product_id":100047701,"comment_content":"今天踩坑private static simpledateformat，高并发下出现numberformatexception错误。单笔数据重放没有问题。初看到这个异常一脸懵，完全联系不到是simpledateformat的坑。<br>后面突然想起老师这篇文章。。。完全是坑二的重现。因为是jdk6所以选择了去掉static解决，每次都会新建一个对象","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497243,"discussion_content":"好吧，不过ThreadLocal可以用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591187675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215988,"user_name":"lee","can_delete":false,"product_type":"c1","uid":1019937,"ip_address":"","ucode":"1FA130A398A06D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/21/bb289d5e.jpg","comment_is_top":false,"comment_ctime":1589163907,"is_pvip":false,"replies":[{"id":"79923","content":"       夏令时的关系，有关夏令时你可以网上搜索一些资料<br><br>System.out.println(TimeZone.getDefault().inDaylightTime(date));<br>","user_name":"作者回复","comment_id":215988,"uid":"1001470","ip_address":"","utype":1,"ctime":1589165848,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"14474065795","product_id":100047701,"comment_content":"老师好，上海时区和纽约时区下，格式化同一个时间串得到的当前时差有时候是12小时，有时候是13小时呢，把stringDate改成2020-05-02 22:00:00得到的相差12小时<br>String stringDate = &quot;2020-05-02 22:00:00&quot;;<br>SimpleDateFormat inputFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);<br>&#47;&#47;同一Date<br>Date date = inputFormat.parse(stringDate);<br>&#47;&#47;默认时区格式化输出：<br>System.out.println(new SimpleDateFormat(&quot;[yyyy-MM-dd HH:mm:ss Z]&quot;).format(date));<br>&#47;&#47;纽约时区格式化输出<br>TimeZone.setDefault(TimeZone.getTimeZone(&quot;America&#47;New_York&quot;));<br>System.out.println(new SimpleDateFormat(&quot;[yyyy-MM-dd HH:mm:ss Z]&quot;).format(date));","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494631,"discussion_content":"       夏令时的关系，有关夏令时你可以网上搜索一些资料\n\nSystem.out.println(TimeZone.getDefault().inDaylightTime(date));\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589165848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207127,"user_name":"eazonshaw","can_delete":false,"product_type":"c1","uid":1493784,"ip_address":"","ucode":"423952F7CEF475","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/18/4877c08b.jpg","comment_is_top":false,"comment_ctime":1587011648,"is_pvip":false,"replies":[{"id":"77382","content":"TIMESTAMP保存的时候根据当前时区转换为UTC，查询的时候再根据当前时区从UTC转回来，而DATETIME就是一个死的字符串时间（仅仅对MySQL本身而言）表示。有关mysql时间类型可以详细看一下这个ppt<br>http:&#47;&#47;cdn.oreillystatic.com&#47;en&#47;assets&#47;1&#47;event&#47;36&#47;Time%20Zones%20and%20MySQL%20Presentation.pdf<br><br>如果你的项目有国际化需求，推荐使用时间戳，并且需要确保你的应用服务器和数据库服务器设置了正确的匹配当地时区的时区配置（其实，即便你的项目没有国际化需求，设置正确的需求，至少是应用服务器和数据库服务器设置一致的时区，也是需要的）<br><br>","user_name":"作者回复","comment_id":207127,"uid":"1001470","ip_address":"","utype":1,"ctime":1587013286,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"14471913536","product_id":100047701,"comment_content":"问题二：<br>首先，为了让docker容器的时间格式和宿主机一致，可以在environment中添加TZ: Asia&#47;Shanghai。<br>实验发现，切换mysql的TIME_ZONE到“america&#47;new_york”后，发现datetime格式字段不发生变化，而timestamp格式会换算成纽约时区时间，所以timestamp格式的日期保存了时区信息，而datetime没有。<br>感觉在业务场景中，有可能出现服务器或容器系统时间并未设置时区，导致保存的数据并不是我们想要的。因此，是不是更推荐使用timestamp格式来保存日期，避免这种情况发生呢？","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492016,"discussion_content":"TIMESTAMP保存的时候根据当前时区转换为UTC，查询的时候再根据当前时区从UTC转回来，而DATETIME就是一个死的字符串时间（仅仅对MySQL本身而言）表示。有关mysql时间类型可以详细看一下这个ppt\nhttp://cdn.oreillystatic.com/en/assets/1/event/36/Time%20Zones%20and%20MySQL%20Presentation.pdf\n\n如果你的项目有国际化需求，推荐使用时间戳，并且需要确保你的应用服务器和数据库服务器设置了正确的匹配当地时区的时区配置（其实，即便你的项目没有国际化需求，设置正确的需求，至少是应用服务器和数据库服务器设置一致的时区，也是需要的）\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587013286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207063,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1587001555,"is_pvip":false,"replies":[{"id":"77380","content":"https:&#47;&#47;dev.mysql.com&#47;doc&#47;refman&#47;5.6&#47;en&#47;timestamp-initialization.html<br><br>你说的应该是『As of MySQL 5.6.5, TIMESTAMP and DATETIME columns can be automatically initializated and updated to the current date and time (that is, the current timestamp). Before 5.6.5, this is true only for TIMESTAMP, and for at most one TIMESTAMP column per table. The following notes first describe automatic initialization and updating for MySQL 5.6.5 and up, then the differences for versions preceding 5.6.5.』这个问题，其实并不是指只能有一个TIMESTAMP 列，而是只能有一个TIMESTAMP列使用CURRENT_TIMESTAMP来初始化或自动更新时间戳","user_name":"作者回复","comment_id":207063,"uid":"1001470","ip_address":"","utype":1,"ctime":1587012613,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"14471903443","product_id":100047701,"comment_content":"思考题2:<br>说实话，数据库相关知识是我的弱项。<br>查了一下，大概是TIMESTAMP包含了时区信息，而DATETIME不包含。另外有一个是，我印象中5.7之后的mysql版本，最多只能有一个TIMESTAMP的字段。这也算是个区别吧。","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491996,"discussion_content":"https://dev.mysql.com/doc/refman/5.6/en/timestamp-initialization.html\n\n你说的应该是『As of MySQL 5.6.5, TIMESTAMP and DATETIME columns can be automatically initializated and updated to the current date and time (that is, the current timestamp). Before 5.6.5, this is true only for TIMESTAMP, and for at most one TIMESTAMP column per table. The following notes first describe automatic initialization and updating for MySQL 5.6.5 and up, then the differences for versions preceding 5.6.5.』这个问题，其实并不是指只能有一个TIMESTAMP 列，而是只能有一个TIMESTAMP列使用CURRENT_TIMESTAMP来初始化或自动更新时间戳","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587012613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209443,"user_name":"俊柱","can_delete":false,"product_type":"c1","uid":1439043,"ip_address":"","ucode":"7067F256DAFF9B","user_header":"https://static001.geekbang.org/account/avatar/00/15/f5/43/b882ab43.jpg","comment_is_top":false,"comment_ctime":1587549947,"is_pvip":false,"replies":[{"id":"78205","content":"当然可以使用Instant映射，参考https:&#47;&#47;i.stack.imgur.com&#47;idLPT.png","user_name":"作者回复","comment_id":209443,"uid":"1001470","ip_address":"","utype":1,"ctime":1587561179,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10177484539","product_id":100047701,"comment_content":"老师，我有一个问题困扰已久，希望能够解答一下，目前我们对外输出的 API ，时间都是时间戳的形式， 内部系统的交互，时间也是时间戳的形式。 那我用 Instant 去映射数据库的 Timestamp&#47;DateTime 字段，会不会更好？ 否则的话，需要在多处都要注意 LocalDateTime 和 时间戳的相互转换 （比如 redis 的序列化反序列化，json 的序列化、反序列化）","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492799,"discussion_content":"当然可以使用Instant映射，参考https://i.stack.imgur.com/idLPT.png","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587561179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207141,"user_name":"大大大熊myeh","can_delete":false,"product_type":"c1","uid":1139413,"ip_address":"","ucode":"4832C2E7CEB151","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","comment_is_top":false,"comment_ctime":1587014431,"is_pvip":false,"replies":[{"id":"77389","content":"👍🏻","user_name":"作者回复","comment_id":207141,"uid":"1001470","ip_address":"","utype":1,"ctime":1587016906,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10176949023","product_id":100047701,"comment_content":"我虽然现在用的是jdk1.8，但对于日期的操作一般还是习惯于用Date或long，以后可以尝试用LocalDateTime等类。<br><br>思考题1<br>Date#toString方法中，会将当前时间转化为BaseCalendar.Date类，这个类有一个Zone属性，在toString的时候会被追加到字符串中（默认是GMT）<br><br>思考题2<br>datetime占用8字节，不受时区影响，表示范围&#39;1000-01-01 00:00:00&#39; to &#39;9999-12-31 23:59:59&#39;<br>timestamp占用4字节，受时区影响，表示范围&#39;1970-01-01 00:00:01&#39; to &#39;2038-01-19 03:14:07&#39;，若插入null会自动转化为当前时间","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492021,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587016906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207028,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1586998279,"is_pvip":false,"replies":[{"id":"77342","content":"大方向对，可以再考虑一下我们如何选择","user_name":"作者回复","comment_id":207028,"uid":"1001470","ip_address":"","utype":1,"ctime":1587004236,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10176932871","product_id":100047701,"comment_content":"第二个问题，timestamp 会把传入的时间转化为 UTC 即时间戳进行存储，而 datetime 也直接将传入的时间存储。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491986,"discussion_content":"大方向对，可以再考虑一下我们如何选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587004236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243107,"user_name":"VIC","can_delete":false,"product_type":"c1","uid":1114064,"ip_address":"","ucode":"3B3E6D344488B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/d0/402be1e9.jpg","comment_is_top":false,"comment_ctime":1597969241,"is_pvip":false,"replies":[{"id":"89641","content":"SimpleDateFormat用ThreadLocal包一下，搜索一下解决SimpleDateFormat线程安全问题，网上文章一大堆","user_name":"作者回复","comment_id":243107,"uid":"1001470","ip_address":"","utype":1,"ctime":1597988244,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5892936537","product_id":100047701,"comment_content":"threadlocal simpledateformat，有完整例子吗","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504182,"discussion_content":"SimpleDateFormat用ThreadLocal包一下，搜索一下解决SimpleDateFormat线程安全问题，网上文章一大堆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597988244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236358,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1595398865,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5890366161","product_id":100047701,"comment_content":"学习这个专栏的前几篇的时候，就发现需要有很强的Java 8功底，作为一名Javaer，我买了本《Java 实战》来更好的学习Java 8的新特性，也能跟上课程的节奏。","like_count":1},{"had_liked":false,"id":228092,"user_name":"senekis","can_delete":false,"product_type":"c1","uid":1446025,"ip_address":"","ucode":"CD88681F0278FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erTlRJ6skf7iawAeqNfIT1PPgjD7swUdRIRkX1iczjj97GNrxnsnn3QuOhkVbCLgFYAm7sMZficNTSbA/132","comment_is_top":false,"comment_ctime":1592552842,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5887520138","product_id":100047701,"comment_content":"1. 时区问题的原因<br><br>Date和Instant都可以根据时间戳来创建，其中并不包含时区信息，因此并不会出现所谓的时间错误。<br>因此在保存数据时，都可以通过Long型来保存时间戳信息。<br>当需要实现日期格式化时，通过将时间戳转换为对应的时区的时间进行显示。<br><br><br>2. 测试Demo<br><br>public class DateTest {<br><br>    @Test<br>    public void timeStampTest() {<br><br>        Date date = new Date();<br>        Instant instant = date.toInstant();<br>        assertEquals(date.getTime(), instant.toEpochMilli());<br><br>        ZoneId shZoneId = ZoneId.of(&quot;Asia&#47;Shanghai&quot;);<br>        ZoneId cgZoneId = ZoneId.of(&quot;America&#47;Chicago&quot;);<br>        LocalDateTime shLocalDateTime =  LocalDateTime.ofInstant(instant, shZoneId);<br>        LocalDateTime cgLocalDateTime = LocalDateTime.ofInstant(instant, cgZoneId);<br>        assertEquals(shLocalDateTime.getSecond(), cgLocalDateTime.getSecond());<br>        assertEquals(Math.abs(shLocalDateTime.getHour() - cgLocalDateTime.getHour()), 13);<br><br>        ZonedDateTime shZonedDateTime = ZonedDateTime.of(shLocalDateTime, shZoneId);<br>        ZonedDateTime cgZonedDateTime = ZonedDateTime.of(cgLocalDateTime, cgZoneId);<br>        assertEquals(shLocalDateTime.getSecond(), cgZonedDateTime.getSecond());<br><br>        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);<br>        String shDateTimeStr = dateTimeFormatter.format(shZonedDateTime);<br>        String cgDateTimeStr = dateTimeFormatter.format(cgZonedDateTime);<br>        assertFalse(shDateTimeStr.equals(cgDateTimeStr));<br><br>    }<br><br>}","like_count":1},{"had_liked":false,"id":208159,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1587286442,"is_pvip":true,"replies":[{"id":"77693","content":"不太明白啥意思，代码中没有贴出获取本周日截止时间的方法，获取到下周一-1s即可","user_name":"作者回复","comment_id":208159,"uid":"1001470","ip_address":"","utype":1,"ctime":1587291208,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"5882253738","product_id":100047701,"comment_content":"private static final DateTimeFormatter df = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);<br><br>**<br>     * 获取本周一开始时间<br>     * @return<br>     *&#47;<br>    public static String getFirstTimeByWeek() {<br>        LocalDateTime currentTime = LocalDateTime.now();<br>        LocalDateTime weekStartTime = currentTime.with(TemporalAdjusters.previous(DayOfWeek.SUNDAY)).plusDays(1).truncatedTo(ChronoUnit.DAYS);<br>        &#47;&#47;求出这个日期所在周的星期一<br>        return weekStartTime.format(df);<br>    }<br><br><br>    &#47;**<br>     * 获取本周一截止时间<br>     * @return<br>     *&#47;<br>    public static String getLastTimeByWeek() {<br>        LocalDateTime currentTime = LocalDateTime.now();<br>        LocalDateTime weekEndTime = currentTime.with(TemporalAdjusters.next(DayOfWeek.MONDAY)).minusDays(1);<br>        &#47;&#47;求出这个日期所在周的星期一<br>        return weekEndTime.format(df);<br>    }<br><br><br>    &#47;**<br>     * 获取当月第一天其实时间<br>     * @return<br>     *&#47;<br>    public static String getFirstTimeByMonth() {<br>        LocalDateTime currentTime = LocalDateTime.now();<br>        LocalDateTime monthStartDate = currentTime.withDayOfMonth(1).truncatedTo(ChronoUnit.DAYS);<br>        return monthStartDate.format(df);<br>    }<br><br>    &#47;**<br>     * 获取当月最后一天截止时间<br>     * @return<br>     *&#47;<br>    public static String getLastTimeByMonth() {<br>        LocalDateTime currentTime = LocalDateTime.now();<br>        LocalDateTime monthEndDate = currentTime.plusMonths(1L).withDayOfMonth(1).truncatedTo(ChronoUnit.DAYS).plus(-1L, ChronoUnit.MILLIS);<br>        return monthEndDate.format(df);<br>    }<br><br>获取本周日截止时间的时候总是获取不到时分秒的那部分:23:59:59","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492361,"discussion_content":"不太明白啥意思，代码中没有贴出获取本周日截止时间的方法，获取到下周一-1s即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587291208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239338,"discussion_content":"/**\n     * 获取本周日截止时间\n     * @return\n     */\n    public static String getLastTimeByWeek() {\n        LocalDateTime currentTime = LocalDateTime.now();\n        LocalDateTime weekEndTime = currentTime.with(TemporalAdjusters.next(DayOfWeek.MONDAY)).minusDays(1).truncatedTo(ChronoUnit.DAYS);\n        //求出这个日期所在周的星期一\n        return weekEndTime.format(df);\n    }\n\n无法得到2020-04-19 23:59:59，只能得到2020-04-19 00:00:00","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587294725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":267820,"discussion_content":"减了一天","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589695408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":239338,"ip_address":""},"score":267820,"extra":""}]}]},{"had_liked":false,"id":207898,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":false,"comment_ctime":1587210794,"is_pvip":false,"replies":[{"id":"77588","content":"处理数据的时候要面对各种不带时区的string或datetime。。。这显然是会有问题的","user_name":"作者回复","comment_id":207898,"uid":"1001470","ip_address":"","utype":1,"ctime":1587215369,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5882178090","product_id":100047701,"comment_content":"我在外企，公司大部分数据用的洛杉矶时间（带了夏令时），处理数据的时候要面对各种不带时区的string或datetime，无比酸爽","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492274,"discussion_content":"处理数据的时候要面对各种不带时区的string或datetime。。。这显然是会有问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587215369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360089,"user_name":"奔跑","can_delete":false,"product_type":"c1","uid":1361556,"ip_address":"北京","ucode":"A64A0DCA50D9FA","user_header":"https://static001.geekbang.org/account/avatar/00/14/c6/94/48ca3281.jpg","comment_is_top":false,"comment_ctime":1666170133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666170133","product_id":100047701,"comment_content":"映射数据库时，Date用什么替换呢，LocalDateTime还是Instant？<br>JDK8的LocalDate和joda.time的LocalDate哪个更适合用在项目里？","like_count":0},{"had_liked":false,"id":332698,"user_name":"车鸿韡","can_delete":false,"product_type":"c1","uid":2843289,"ip_address":"","ucode":"7A5B69B3F0A830","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBru6Qa44qibaOnbEQprP1SOhBq0YWHCsjBAvNKmSu7DxKNSmtbiaZ1nQGf56m2gMDicsjiasnzI5VAw/132","comment_is_top":false,"comment_ctime":1643501676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643501676","product_id":100047701,"comment_content":"MySQL时间戳有范围限制，那么date时间戳有范围限制吗？","like_count":0},{"had_liked":false,"id":301459,"user_name":"walle斌","can_delete":false,"product_type":"c1","uid":1062848,"ip_address":"","ucode":"0DB3243004951F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","comment_is_top":false,"comment_ctime":1625706700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625706700","product_id":100047701,"comment_content":"我选择用joda-time 的 DateTime 而且绝大部分新老项目都是这个。。连贯性很好。。中间计算绝对时间也是方便的很。。 ","like_count":0},{"had_liked":false,"id":278171,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1612784667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612784667","product_id":100047701,"comment_content":"老师，java里面有接受字符串参数，然后返回日期对象的API吗？类似于java.util.Date里面的构造函数public Date(String s) ，但这个构造函数是Deprecated。","like_count":0},{"had_liked":false,"id":263748,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1606261843,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1606261843","product_id":100047701,"comment_content":"我用springboot2.2.x在POJO中分别使用LocalDateTime, Instant, ZonedDateTime中插入字段到mongodb中，其中ZonedDateTime不能直接插入，需要额外增加Convert进行转换。针对国际业务，用Instant可能会更方便些，然后使用带ZoneId的DateTimeFormatter进行格式化。如果只是国内业务，我觉得使用LocalDateTime就够用了。请老师及小伙伴们指正。","like_count":0},{"had_liked":false,"id":227305,"user_name":"李松","can_delete":false,"product_type":"c1","uid":2039388,"ip_address":"","ucode":"28572BCFD696E5","user_header":"","comment_is_top":false,"comment_ctime":1592355617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592355617","product_id":100047701,"comment_content":"我开发中一般使用优秀的开源工具包，Apache commons  , joda","like_count":0},{"had_liked":false,"id":212823,"user_name":"grandcool","can_delete":false,"product_type":"c1","uid":1000037,"ip_address":"","ucode":"7545E76CE3FEFC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/65/f444ea39.jpg","comment_is_top":false,"comment_ctime":1588216566,"is_pvip":false,"replies":[{"id":"79051","content":"因为不同时区的人都可以有自己的本地&#47;当地时间，对应UTC是一个","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588229100,"ip_address":"","comment_id":212823,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588216566","product_id":100047701,"comment_content":"老师，为啥“不同的本地时间可能对应同一个 UTC”啊？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493621,"discussion_content":"因为不同时区的人都可以有自己的本地/当地时间，对应UTC是一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588229100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207869,"user_name":"wang","can_delete":false,"product_type":"c1","uid":1161200,"ip_address":"","ucode":"5D569805C6A923","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/f0/a570f68a.jpg","comment_is_top":false,"comment_ctime":1587201049,"is_pvip":false,"replies":[{"id":"77589","content":"它就是一个时间表示，没有保存时区，理解为存了当前时区的ZonedDateTime不太准确<br>","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587215961,"ip_address":"","comment_id":207869,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587201049","product_id":100047701,"comment_content":"感觉LocalDateTime像是存了当前时区的zoneddatetime？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492265,"discussion_content":"它就是一个时间表示，没有保存时区，理解为存了当前时区的ZonedDateTime不太准确\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587215961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207207,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1587024158,"is_pvip":false,"replies":[{"id":"77402","content":"是","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587030083,"ip_address":"","comment_id":207207,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587024158","product_id":100047701,"comment_content":"思考题1.是toString 方法里面if (zi != null) {<br>            sb.append(zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US)); &#47;&#47; zzz<br>        } else {<br>            sb.append(&quot;GMT&quot;);<br>        }<br>加了这个输出结果<br><br>","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492039,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587030083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207203,"user_name":"Jerry Wu","can_delete":false,"product_type":"c1","uid":1203567,"ip_address":"","ucode":"AD29B6942AAAA6","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/6f/42494dcf.jpg","comment_is_top":false,"comment_ctime":1587023396,"is_pvip":false,"replies":[{"id":"77404","content":"没关系没踩坑是好事情，先了解一下","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587031261,"ip_address":"","comment_id":207203,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587023396","product_id":100047701,"comment_content":"在日期上，我没踩过坑。<br><br>首先，我做的都是国内项目，不会出现时区的问题；<br>其次，对时间的应用真不多，就是时间的保存、格式化、比较；<br><br>看来我还是太狭隘了，最近三节课说到的坑都没见过。周末得多跑几遍老师的代码，加深感受才行。","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492038,"discussion_content":"没关系没踩坑是好事情，先了解一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587031261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}