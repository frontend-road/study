[{"article_id":499434,"article_title":"开篇词｜为什么要选择 React Native 做你的跨端方案？","article_content":"<p>你好，我是蒋宏伟。我目前在58同城担任前端架构师，也是 58RN 框架的负责人。</p><p>六年来，我一直在围绕着 React Native 搞开发、搞基建、搞探索。从最初一线的 React Native 业务开发，到后来开始负责 58RN 的基础设施建设，再到 2021 年，我开始冲在最前沿做 React Native 新架构的调研，我用了 6 年的时间，朝着同一个方向一步一步地往前行。</p><p>在这期间，也得益于我所在的58用价中台的大前端团队，我接触到了各式各样的大前端技术。除了 React Native 之外，我直接负责过的跨端技术还有 Hybrid、小程序、Cocos 游戏，而且我也经常和 iOS、Android，以及 Flutter 的同学进行交流。</p><p><strong>我深刻地知道，没有完美的跨端技术，只有适合的场景。脱离适用场景去谈跨端技术没有什么意义。</strong></p><p>那么， React Native 适合哪些场景呢？</p><p><strong>第一，业务更新迭代较快的团队与出海团队。</strong></p><p>React Native 上手成本较低。对前端同学来说，React Native 和前端技术生态重合度很高，学习成本很低；对客户端同学来说，React Native 省去了大量的编译耗时，并且自带跨端光环， 一份源码可以同时编译成 Android 和 iOS 原生应用，并发布到安卓和苹果应用商店上。</p><!-- [[[read_end]]] --><p>所以，在一些业务迭代快的团队中，使用React Native 跨端方案不仅能够节约开发成本，还能带来接近原生的体验和性能。比如，现在大火的直播、短视频赛道中，React Native 能够通过集成声网提供原生 SDK，快速开发出一个直播、短视频应用。</p><p>而且，据我所知，一些出海团队也在使用 React Native 进行开发。针对于出海应用， React Native 有一套 Expo 方案，Expo 提供了一整套 React Native 的技术基础建设，极大地降低了开发一个新应用的成本，这就能帮助这些出海 App 用最低的成本、最快的速度获取海外用户。</p><p><strong>第二，既要支持动态更新，又要支持复杂业务的场景。</strong></p><p>在国内，无论大公司、小公司都钟情于应用的动态更新。因为动态更新能降低产品的试错成本。如果产品策略有调整，可以立马上线，线上有小问题也可以快速修复。但能够既满足动态更新，又能跨端，还能满足复杂业务需求的只有 JavaScript 语言。</p><p>目前几个主流的跨端框架，除了React Native之外，还有小程序、Weex、Flutter。但小程序只能让你的应用运行在别人的 App 上，Weex最终未能大规模流行起来，而Flutter使用的语言是Dart而非JavaScript，并不能很好支持动态更新。</p><p>换句话说，除了基于 JavaScript 的自研框架外，<strong>目前能够既支持动态更新，又支持复杂业务的主流移动跨端框架只有使用 JavaScript 开发的 React Native。</strong></p><h2>为什么你应该学习 React Native ？</h2><p><strong>首先，React Native 是一个非常流行的跨端框架，开发者认可度很高。</strong></p><p>根据权威网站数据，现在使用 React Native 的开发者已经越来越多了。在 <a href=\"https://www.npmtrends.com/react-native\"> npm trends</a> 网站上你可以看到，react-native 框架每周的下载次数，已经从5年前的不到10万次，到现在超过了 80 万次，5 年时间翻了 8 倍之多。</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/50/d75660fb448113ba4279962f88bc7b50.png?wh=1920x760\" alt=\"图片\"></p><p>这意味着，React Native 有一个繁荣和不断迭代的生态。</p><p>对于个人而言，强大的生态意味着很多功能都不用自己写，从社区拿来用就行，这极大地降低了开发成本。你可以在社区中选择最适合你业务的技术工具，比如状态管理、路由、动画、工具库和原生扩展等等。对于企业来说，使用 React Native 这类成熟框架开发移动应用成本更低，风险也更低，企业也更愿意招聘相关开发者。</p><p><strong>其次，React Native 是一个跨领域的融合技术，它是你现有技术的自然延伸。</strong></p><p>React Native 的生态和 JavaScript、React、iOS、Android 甚至 Node.js 的生态都有很大的交集。在 React Native 生态中，有来自各种技术领域的思想碰撞。相信你学习 React Native 时，这种感受会非常明显。</p><p>如果你是一个前端工程师，已经掌握 JavaScript、React 的相关技术，那么对 React Native 的学习，可以让你了解到那些独属于 Android 和 iOS 原生平台的特性。</p><p>比如，你可以亲手尝试使用 WebView 容器来加载 Web 页面，甚至你还可以用 WebView 中的 JavaScript 去调用 React Native 中的 JavaScript，把 Native 暴露给 React Native 的支付能力再暴露给 Web，这样你能更加深刻地体会到 Hybrid 的实现原理。</p><p>如果你是客户端工程师，已经掌握Android 或 iOS 的这些技术了，那你只需要学习一下 JavaScript 和 React 这些流行的前端技术即可，相信你能从中体会到热重载、热更新和跨端带来的乐趣。</p><p>而且，React Native 这门融合技术还有另一个好处，它能让前端和客户端更加紧密的协作。日常开发中，前端和客户端经常需要协作，比如很多公司就专门设立了大前端部门，为的就是方便前端和客户端一起做事。要更好地共事，就需要学会站在对方角度思考问题，通过学习 React Native 你就能了解对方技术栈的特点，就更容易换位思考，而这也能帮助你快速成长。</p><p><strong>更关键的是，React Native 新架构已经确定会在今年正式发布。</strong></p><p>2022 年，对于 React Native 来说是一个大年，因为重构已久的 React Native 新架构已经确定会在今年正式推出，目前的 0.68 版本已经出了新架构的测试版。根据业内已有的报告和我们团队的调研结果，相对于老架构，新架构在最关键的性能问题上有了非常大的提升，这将会为 React Native 开启一个全新的阶段。</p><h2>期待已久的新架构会带来什么？</h2><p>React Native 是 2013 年在 Facebook 一个内部的黑客马拉松项目中诞生的，到今年 2022 年新架构出来，已经整整十年了。</p><p>它诞生于移动互联网大爆发时代，当时国内外各大互联网公司都相继提出了“Mobile First”、“All in 无线”之类的口号。但后来，React Native 也因为性能等问题，让类似 Airbnb 这样的团队选择了放弃。</p><p>但技术的车轮还是滚滚向前，并不会停下它的脚步。</p><p>2021 年 7 月，经历 4 年漫长的等待，当我得知 React Native 新架构已经在 Facebook 落地的消息时，真是万分激动，期待已久的 <a href=\"https://www.infoq.cn/article/txsiq1wogk6il4bnqmja\">React Native 新架构终于要来了</a>，于是我马上开始了新架构的调研。</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/de/b8f55be43f5243a91de6aea7a00575de.png?wh=1920x1104\" alt=\"图片\"></p><p>到今天，经历过大半年的调研，我也大概摸清楚了 React Native 新架构的技术底层原理和发展方向，目前来看它至少会有这几个值得期待的亮点：</p><p><strong>首先，React Native 新架构的启动性能会有 2 倍左右的提升。</strong></p><p>React Native 新架构默认用的 JavaScript 引擎是 Hermes 引擎。Hermes 是一款专为移动端打造的 JavaScript 引擎，它支持 JavaScript 的 AOT 预编译。</p><p>一般而言，要执行一段 JavaScript 代码，首先要将 JavaScript 代码编译为字节码，再把字节码编译为二进制的机器码，才能被 CPU 等硬件执行。而 AOT 预编译技术可以让你在本地提前将 JavaScript 编译成字节码。这样一来，在启动 React Native 应用时，相对于老架构 JSCore 引擎的就少了一个步骤，因此 React Native 新架构的启动性能会有很大的提升。</p><p><strong>其次，React Native 新架构的通信性能会有 3 倍左右的提升。</strong></p><p>React Native 老架构通信用的是 JS Bridge，JS Bridge 的通信方式是“发送消息”。React Native 新架构通信的是 JSI（JavaScript Interface），JSI 把很多底层的 C++ 接口都直接暴露给了 JavaScript。有了 JSI 后，React Native 中的 JavaScript 就直接调用 C++了，就像 node.js 使用 addon 调用 C++ 、 Flutter 用 FFI 调用 C++ ，以及 Java 使用 JNI 调用 C++ 一样。</p><p>所以，使用 JSI 意味着不用发送消息，而是直接调用，没有序列化和反序列。少了这些多余的步骤，操作指令的传递效率就会高很多。</p><p><strong>第三，React Native 新架构的渲染流水有了很大的变化，这会带来更好的用户体验。</strong></p><p>在老架构中，React Native 只有异步渲染这一种方式。而我们知道原生视图的渲染是同步的，这时如果把 React Native 渲染到原生视图中，就可能导致布局抖动问题。而新架构提供了同步的渲染能力，这就提供了一种新的可能：一方面我们可以在原生页面中嵌套 React Native 视图，另一方面 React Native 应用也能更方便地引入一些需要同步 API 的原生组件。</p><p>另外，还有一个我非常关注的方向，就是 React Native 团队正在基于 React Native 新架构研究服务端渲染方案。React Native 的 SSR 和 Airbnb 的自行研发<a href=\"https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab\">服务端渲染框架</a>原理非常类似。国内的<a href=\"https://ppt.infoq.cn/slide/show?cid=94&pid=3696\">美团团队也在 React Native 老架构之上实现了 SSR</a>，据说美团的<strong>页面渲染速度最快能达到50ms</strong>。</p><p>希望在不远的将来，React Native SSR 能出一个类似于 Web 服务端渲染的 Next.js 的通用方案，用更低成本解决性能痛点。</p><p>总之我们有理由相信，React Native 新架构会给我们带来巨大的惊喜。</p><h2>这门课是怎么设计的？</h2><p>在调研新架构的过程中，我发现 React Native 本身的迭代非常快，现在并没有比较适合初学者和进阶者系统学习 React Native 的课程。我当时想等 React Native 新架构出来后，再出一个基于 React Native 新架构的课程，也算是回馈社区了。</p><p>但后来我决定采用<strong>动态专栏</strong>的形式和你见面。因为我发现，面对一个前沿技术，如果我们真要等它完全成熟了再来研究，可能就晚了。更重要的是，只有<strong>先坐上 React Native 新架构的这趟列车，才能享受到前沿技术变革带来的红利</strong>。</p><p>但技术的实时性和课程的完整性又应该如何兼顾呢？</p><p>于是，我想到一个办法，先用 24 讲把 React Native 完整地给你介绍一遍，再用一年的时间，用12 讲的内容和你一起跟进 React Native 新架构最前沿的变化和进展。</p><p><img src=\"https://static001.geekbang.org/resource/image/c8/2b/c816a5fa34106a6b5073af7fbb15c72b.jpg?wh=1357x1323\" alt=\"图片\"></p><p><strong>第一部分是核心基础篇。</strong>这里我们主要是把基础打牢，带你深入学习 React和React Native 的基础知识，包括状态和组件的使用，及其背后的设计原理，还有开发 UI 和调试代码的经验技巧。在这个阶段，我们的目标是要让你能够搭建一个 React Native 页面，我希望通过实践的方式，让你收获搭建 React Native 页面的能力，而不仅仅只是知识。</p><p><strong>第二部分是社区生态篇。</strong>这一部分中，我们的首要目的是帮你开阔眼界，让你知道社区有哪些成熟方案，需要时能够拿来即用，同时也让你能够借助 React Native 生态中最常用的几个工具，搭建一个完整的 React Native 应用。搭建一个完整应用是很有挑战的一件事情，我会把我搭建好的一个简易电商应用放在 GitHub 给你参考，希望能让你在代码层面，而不仅仅只是文字层面有所收获。</p><p><strong>第三部分是基础设施建设篇。</strong>这里我们会从技术应用层面，给你介绍从构建 React Native 混合应用到热更新，再到性能调优的全过程，让你能为团队搭建基础设施建设出谋献策，进一步提升你的架构能力。</p><p>而且，我还邀请了和我一起共事多年的两位老搭档况众文和朴惠姝，他们是 58RN Native 方向的负责人，我们会共同地把多年搭建 React Native 基础设施的心得和你分享。</p><p>后面动态更新的 12 讲，我会采用<strong>每个月 1 篇</strong>的更新形式，帮你跟踪 React Native 新架构的最新进展，并和你聊聊和 React Native 新架构相关的最前沿的新技术，包括且不限于 Hermes、Fabric、JSI、React Native Skia、React Native SSR ，等等。</p><p>具体你可以看看下面的目录：</p><p><img src=\"https://static001.geekbang.org/resource/image/45/d0/45c912f5bdcdea16fb9a9d344b85efd0.jpg?wh=1563x5680\" alt=\"\"></p><p>最后，我希望这门课程能够帮到那些曾经和我一样对 React Native 跨端技术充满好奇的人，那些想弄明白如何搭建一套跨端基础设施的人，以及那些希望自己能够冲在技术最前沿的探索和创新的人。</p><p><strong>技术的世界如此精彩，我们当然不应该躺平，愿你的好奇、勇敢和行动能得到相应的回报。</strong></p>","neighbors":{"left":[],"right":{"article_title":"01｜学习 React Native，你需要掌握哪些知识？","id":499446}}},{"article_id":499446,"article_title":"01｜学习 React Native，你需要掌握哪些知识？","article_content":"<p>你好，我是蒋宏伟。</p><p>在专栏的第一讲，我们先打个“基础”，让你对即将要学习的 React Native 核心基础知识有个心理准备。</p><p>这些年，我经常活跃于公司内外的交流群中，和大家讨论一些问题，比如：状态管理该怎么选，长列表的性能问题该怎么解决，遇到紧急的线上 BUG 该怎么处理，等等。</p><p>这些我们都是日常开发时经常会遇到的问题，出现这些问题的其中一个原因，就是对 React Native 的基础知识掌握得不够牢固。</p><p>当然，这些问题在我们的核心基础篇中都会有答案。不过在第一讲中，我不打算和你说这些细节，而是带你看看 React Native 基础知识的地图，让你知道自己该学什么、要学什么，让你对基础知识有一个整体的认知。</p><h2>基础知识</h2><p>那所谓的基础知识是什么呢？<strong>我认为能够满足开发业务的最小知识集合都是基础。</strong>比如，语言、框架和一些编程的必备工具，还有 React Native 框架和社区提供的核心组件、核心 API，再有就是熟悉工作流包括搭建环境、开发流程、上线流程，这些都是 React Native 的基础知识。</p><p>不过，每个人的技术背景不一样、工作年限也不一样，新手可能对大部分的基础知识都不太熟悉。而已经有过多年 React Native 开发经验的老手，对有些基础知识的使用方法都已经掌握得差不多了，千人千面。</p><!-- [[[read_end]]] --><p>但我认为，无论是新手还是老手，你都应该系统地、有深度地再学习一遍，把基础打扎实了。我相信，核心基础篇能给你带来更深刻、更系统的认知。</p><p>那些需要深层理解的知识，我会把它给你讲清楚、讲透彻，让你弄明白它是怎么来的，又有哪些使用技巧，底层原理又是什么。</p><p>在广度上，为了能让你对基础知识有个系统的了解，我为你准备了一张知识地图。即便有些知识，我们没有进行深层的讲解，你也可以根据知识地图和补充材料中的提示，自己搜索。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/17/9396e0ecf7d24b0a7eb84be5445f4017.jpg?wh=1920x1869\" alt=\"图片\"></p><p>其中，蓝色背景和蓝色文字的内容就是我们专栏核心基础篇中的重点内容，那些灰色背景、灰色文字的内容就是你需要自己学习和掌握的基础知识。如果灰色部分中有不是很了解的知识点，你可以根据知识地图自学一下，遇到了任何问题，都欢迎你给我留言。</p><p>你可以看到，在这张知识地图中，我把知识分为了三类。</p><p>第一类是开发语言、React 框架、开发必备工具这些预备知识。虽然这些预备知识，并不是 React Native 本身的重点内容，但这些都是你在开发之前需要掌握的。如果你对 JavaScript 不了解，你可以参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript\">MDN JS 教程</a> 自行学下一下，其中  npm 等工具使用起来会比较简单，你可以参考 <a href=\"https://www.npmjs.cn\">npm 中文文档</a> 自行摸索学习。但考虑到有些小伙伴对 React 可能没有那么熟悉，所以这方面的预备知识，我还会用三讲的内容进行讲解。</p><p>第二类知识是 React Native 本身的知识。组件是这类知识中的重点，包括框架提供的组件和社区提供的组件，这方面我会重点讲解。但 API 类的知识，本身比较简单，所以我只挑选了样式内容和你进行讲解。至于其他 API 知识，你在用的时候，查查 <a href=\"https://reactnative.cn\">React Native 官方文档</a>就能很快学会了。</p><p>第三类知识是工作流中的实操知识。学习实操类知识最好的方法，其实是根据手册一步一步操作，所以这一块我不会细讲。但其中有些能帮你节约自己独立探索时间的经验类的知识，比如 UI 开发技巧和逻辑调试思路，我也会和你分享。</p><p>专栏的核心基础篇分为 12 讲，它是一个总分总的结构，今天这一讲就是对基础知识的整体认知，第 11 讲、第 12 讲就是对基础知识的项目实战，那中间的几讲就是我为你挑选的几个最重要的基础知识点。我希望通过知识地图和实战案例，把这基础知识点给你串起来，让这些知识能够真正为你所用。接下来，我就给你简要介绍下核心基础篇的这几类知识点。</p><h2>第一部分：React框架</h2><p>我们刚才说，学习 React Native 要掌握的第一类知识，包含了 React 框架。众所周知，React Native 是一个基于 React 的原生应用框架。那学习 React 最关键的就是，理解<strong>React 是一个基于组件的、声明式的 UI 框架</strong>，我把这句话拆开和你解释。</p><p>先来看 React 的第一个特点：<strong>基于组件（Component-Based）</strong>。</p><p>最开始 React 只能用来写 Web 应用，它是在 2013 年正式开始开源的。在此之前，业内的大多数 Web 框架都是 MVC 框架。 MVC 框架解决了代码大杂烩的问题，它把代码分成了职责分明的三层，M 指的是数据模型 Modal，V 指的视图模板 View，C 指的是控制器 Controller。MVC 强调的是数据、视图和逻辑之间松耦合，其文件结构也是按这三类分门别类地组织起来的。</p><p>但 React 不一样，React 强调的是组件的可组合型。在 React 中，颗粒度最小的是浏览器提供的 HTML 标签，或者是 React Native 框架提供的组件。这些颗粒度最小的基础标签、基础组件可以相互嵌套、拼装成一个颗粒度稍大一些的自定义组件。小的自定义组件可以拼装成大的自定义组件，大的自定义组件又可以拼装成页面和应用。</p><p>从代码大杂烩，到 MCV 三层架构，再到 React 的自定义组件，代码组织形式经历很大的变化。React 基于组件的代码组织形式，也经历住了时间的考验，证明了它的优秀。</p><p>React Native 应用也继承了“基于组件的”特性，它可以让我们将一个大的 UI 页面，拆分成若干个颗粒度更小的自定义组件，这能让我们的应用更容易扩展和维护。</p><p>接着我们再来看 React 的第二个特点：<strong>声明式（Declarative）</strong>。</p><p>声明式是什么呢？所谓的“声明式的”就是，你只需要告诉程序“做什么”（What），程序会自动帮你解决“怎么做”（How）的问题，这让我们创建复杂的交互应用变得轻而易举。</p><p>你使用过的 HTML 也算一种“声明式”的语言。不同的是， HTML 功能太简单了，而且它也不是图灵完备的语言。但 React 不一样，它使用的是 JavaScript 来描述 UI 页面的结构，并且在 JavaScript 中创建了一种类似 HTML 的方言，也就是JSX 语法扩展。</p><p>JSX 语法既保留了 JavaScript 的灵活、强大和图灵完备特性，也保留了 HTML 这类“声明式”语言易写、易读的特点。</p><p>还值得多说一句的是，“声明式”是一种编程范式，它与“命令式”编程范式相对立的，它们之间是“是什么”（What）和“怎么做”（How）的对立关系。“命令式”就好像你自己开车，你得自己控制方向盘。而“声明式”就好像完全自动驾驶的汽车，你告诉它要去哪儿，它就会自己开到哪。</p><p>声明式编程是一个大的概念，除了我们前面提到了 HTML 所属的领域专属语言（DSL）之外，还有函数式编程等子编程范式。熟悉 React 的同学可能就知道了，React 借鉴了大量的函数式编程的思想。核心基础篇中的函数组件、hook，还有我们后面要讲的状态管理工具 Redux 和新架构原理，都大量使用了函数式编程的思想。</p><p>好了，现在你知道了，React Native 的基础是 React，而 React 又是一个基于组件的、声明式的 UI 框架，因此后面我会花两讲的内容和你介绍，这两个特点背后的基础知识：组件 Component 和状态 State。</p><h2>第二部分：核心组件和样式</h2><p>第二类你需要掌握的基础知识是 React Native 的核心组件和样式。</p><p>先说样式。<strong>样式决定了页面的“颜值”</strong>，它可以控制组件的颜色、字形、排列、大小，等等。有意思的是，Web 中的 CSS 是一门博大精深的学问，要学很久，但 React Native 中的样式内容却很少，它核心声明文件也就 600 多行代码。而且根据我的调研，大家也很少使用 React Native 样式工具、样式库来辅助开发，大部分时候使用默认的样式表 StyleSheet 的 “CSS In JS”写法就够用了。</p><p>那为什么 React Native 能用这么少的样式，来满足复杂的 UI 开发呢？</p><p>关键原因就是，React Native 的组件非常丰富，组件提供的属性满足了那些复杂“颜值”需求。比如，Web CSS 中的粘性定位   <code>position:sticky</code>，就可以用 React  Native 中滚动组件 ScrollView 的粘性头部 <code>StickyHeaderComponent</code> 属性来满足，而且 React  Native 的功能还更强大一些。</p><p>因此，我会花很大的篇幅和你重点讲讲 React Native 中的组件，包括图片组件 Image、点按组件 Pressable、输入组件 TextInput、列表组件 RecyclerListView。选择这 4 个组件来讲，不仅仅是因为它们用的频率高，我们要学习它的使用方法，<strong>我们也要去研究它的原理，希望它们背后的设计思想能够为我所用。</strong></p><p>学习这 4 种组件，其实各有侧重。学习图片组件时，我们最应该关注的是<strong>加载性能和开发的便捷性应该如何取舍</strong>。比如，内置图片性能是好，但会增加包体积，而且加上容易删掉难；远程图片加载慢了点，但只需要管理远程地址，更新也是非常方便；又比如 Base64 会导致图片体积增加 1/4，但是它在热更新的情况下，能让图片第一时间展示出来。这些方案应该怎么选？又有没有自动化的、工程化的方法帮忙我们管理图片，进一步降低我们选择成本呢？</p><p>学习点按组件、输入组件时，我们最应该关注的是<strong>交互体验</strong>。点按按钮很简单，但做好交互体验这件事不简单。一个 App 的体验好不好，PM、UI、UX 设计得好与不好是一方面，但最终还是得靠工程师来实现。比如微信右上角的 + 号按钮，在屏幕上面不是那么好点，微信工程师就把它的可点击范围扩大了一些，让大家容易点中，这些都是值得我们学习的。</p><p>学习列表组件时，我们最应该关注的是 <strong>FPS 流畅度，</strong>也就是滚动性能。React Native 老版本提供的 FlatList 的滚动性能不是很好，在低端机器上会有点卡，但是社区中提供了性能更好的 RecyclerListView，我们得学会用起来。</p><h2>第三部分：实践经验和实战练习</h2><p>然后，在项目实战练习之前，我还会和你讲讲有哪些高效开发 UI 的技巧，和调试疑难杂症的实践经验，帮你少走弯路。</p><p>核心基础篇的最后，就是项目的实战练习了。整个核心基础篇的目的，是希望能让你搭建一个简易的电商首页。我始终相信，只有实战才能将学到的知识变现为自己能力。</p><p>搭建一个电商首页，我们要解决两个问题。第一个问题是，现在电商首页大都是瀑布流形式的，在 React Native 如何实现一个高性能的瀑布流组件呢？社区中并没有现成答案，但是我们可以基于社区组件自己动手进行改造，我会带你一步一步实现一个高性能的瀑布流组件。</p><p>要解决的第二个问题是，搭建项目的最佳实践是什么？如果你是项目的负责人，你会怎么思考，来保障项目的可扩展性和可维护性？根据我的个人经验和业内的最佳实践，我总结出了一套适合我自己的方案，在《页面实战》这一讲中，我也会把它分享给你。</p><p>但我明白，你要把这些知识都学好，还得靠自己在实战中动手、摸索，因此我还会给你留作业，特别是 React Native 新手，请你一定要重视作业的重要性。</p><h2>小结</h2><p>好了，介绍到这里相信你已经知道学习 React Native 要掌握那些基础知识了，这些知识分为三类：</p><ol>\n<li>React 类知识。React 是一个基于组件的、声明式的 UI 框架，而用好 React 的关键是用好自定义组件和状态，这也是你学好这门专栏必要的前提条件；</li>\n<li>React Native 本身的知识。这是核心基础篇的重点内容，它不仅包括 UI 怎么写、组件怎么用，你还去了解它们背后的原理，去提高页面的加载性能、交互体验、FPS 流畅度；</li>\n<li>实践类知识。这里主要是开发 UI 和调试代码的一些经验技巧，并且我也给你留了一个搭建简易电商网页的任务，我希望你以此实战为你学习核心基础篇的目标，同时也通过这个项目实战检验自己的学习成果，将知识内化为自己的能力。</li>\n</ol><p>相信你通过核心基础篇 12 讲的学习，咱们一步一个脚印前进，一定能把基础打扎实了，轻松应对业务开发中的各种挑战。</p><h2>作业</h2><ol>\n<li>如果你是新手，你可以参考 <a href=\"https://reactnative.dev/docs/0.65/environment-setup\">React Native 官网</a> 和 <a href=\"https://reactnative.cn/docs/0.63/environment-setup\">React Native 中文网</a> 搭建一套原生环境。搭建环境是学习的第一步，iOS 或 Android 环境你可以任选其一，先把 React Native 在你的电脑里跑起来。</li>\n<li>如果你是有经验的 React Native 开发者，你可以看一下<a href=\"https://docs.qq.com/sheet/DQWdsZ0RORkpFQmVj?tab=BB08J2\">《大家开发 RN 都用什么？》</a>这份调查表单，看看其他开发者都在用什么，也欢迎你给我留言告诉我，你开发 React Native 都用的是什么。</li>\n</ol><p>欢迎在留言区留言，分享你和 React Native 的故事。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"开篇词｜为什么要选择 React Native 做你的跨端方案？","id":499434},"right":{"article_title":"02｜Component：搭建静态页面的正确思路是什么？","id":500633}}},{"article_id":500633,"article_title":"02｜Component：搭建静态页面的正确思路是什么？","article_content":"<p>你好，我是蒋宏伟。</p><p>上一讲我们说到，React/React Native 开启了“基于组件”构建应用的潮流。</p><p>在工作中，特别是业务类的开发需求，绝大多数都是写页面。写页面分为两步，第一步是搭建静态页面，第二步是给静态页面添加交互让它动起来。这第一步至关重要，它决定了 UI 设计稿要拆分成哪些组件，这些组件又是如何组织起来的，这些都会影响程序的可扩展性和可维护性，甚至还有团队的合作方法。</p><p>我们这一讲的目的，就是让你有一个正确的基于组件搭建静态页面的思路，不让第一步走偏。要知道，如果后面再去纠正，要花费的成本就大了去了。</p><h2>组件：可组合、可复用的“拆稿”方式</h2><p>在开始使用组件这种方式构建静态页面之前，请你先思考一个问题，为什么 React/React Native 选择了基于组件的架构方式呢？</p><p>理论上，除了组件这种方式外，常见的构建应用方式还有：类似 HTML/CSS/JavaScript 这种的分层架构、基于 MVC 的分层架构。那为什么 React/React Native 没有选择这两种架构方式呢？</p><p><strong>这是因为，基于组件的架构模式，或许是现在重展示、重交互应用的最好选择。</strong></p><p>记得我 2015 年刚入门的时候，还有一种岗位叫做网页重构工程师，我还面过这种岗位。那个时候，架构模式就是把 UI 设计稿拆成 3 层：HTML、CSS、JavaScript。网页重构工程师负责 HTML、CSS 部分，前端工程师负责 JavaScript 部分。但是后来我发现网页重构工程师这种岗位越来越少了，也庆幸自己没有上错车。</p><!-- [[[read_end]]] --><p>现在，相信你也看到了，把 UI 设计稿拆成完全独立的 HTML/CSS/JavaScript三个部分的这种架构已经不是主流了；2010 年开源的、代表 MVC 架构模式的 AngularJS也被 Angular（v2 及更高版本）这种基于组件的架构模式所代替了；现在 iOS、Android 应用也有很多是基于组件开发的。</p><p>为什么会有这种现象呢？我先给你看一张架构对比图，你先可以体会一下它们之间的区别，找找原因：</p><p><img src=\"https://static001.geekbang.org/resource/image/00/b6/00e902a0949ecfa5a8748ef66df420b6.jpg?wh=1920x524\" alt=\"图片\"></p><p>现代应用都很复杂，而且非常重交互、重展示。如果 React Native 选择的是类似 HTML/CSS/JavaScript 的模板、样式、逻辑分离的分层架构，那可想而知，我们的三层代码都会非常臃肿。</p><p>如果 React Native 选择的是 MVC 架构，把逻辑控制、数据模型和视图进行分层，对程序横向分层纵向打通，这样代码颗粒度是会变小。但在重交互的前提下，层和层之间、列和列之间的数据流向却更复杂了。流动的方向不止是 MVC 架构图中画 “3+3” 的 6 个方向，而是层和层之间的 “3<em>3</em>2” 个方向，列和列之间的 “3<em>3</em>2” 个方向，非常复杂。</p><p>React/React Native 选择的是基于组件的架构模式，它有三个好处：</p><ul>\n<li>第一，组件是内聚的，组件内既有逻辑，又有状态，还有视图，一个组件可以独立完成一件事情，这也使得 UI 模块复用变得简单；</li>\n<li>第二，组件之间是可以组合的，一个页面可以拆分成若干个大组件，大组件也可以拆分成小组件，当某个组件变大变臃肿时也可以进一步地拆分；</li>\n<li>第三，组件和组件之间的数据流向永远是确定，永远是从上往下流动的，简单明了。</li>\n</ul><p><strong>组件可组合、可复用的特性，和组件之间单向数据流的模式</strong>，在现代应用重交互重展示的情况下，显然更吃香，这也是 React/React Native 选择基于组件来构建应用的原因。</p><h2>单一责任原则</h2><p>现在我们回到第一步，基于组件搭建静态页面。</p><p>我们直接来看一个具体的例子。这里我放了一个简易商品列表页的 UI 设计稿，你可以先停下来思考一下，想一想你会把它拆成那些组件？你这么拆的原因又是什么？</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/23/d4264b371fee1038da912e7737afce23.png?wh=1000x802\" alt=\"图片\"></p><p>我们直接来揭晓答案，拆组件要准守一个原则，<strong>单一责任原则</strong>。</p><p>这也是 React 官方倡导的原则，这个原则的意思是<strong>每个组件都应该只有一个单一的功能，并且这个组件和其他组件没有相互依赖</strong>。当然，完全没有相互依赖是不可能的，但这种思路具有很高的指导价值，一个组件的依赖越少，设计得越好。</p><p>给你举个例子，一个组件你引用的依赖越多，这些依赖就像陌生的英语单词，你得去其他文件中去查词典，才能知道这些依赖的意思。依赖越多，越难读懂，也越难维护。</p><p>因此，为了可读性、可维护性、可测试性，就要减少组件的外部依赖，这就是单一责任原则的指导价值。</p><p>这样说来，在拆分简易商品列表页的 UI 设计稿时，我们就要尽可能地拆的更细一些，保证每个组件的责任单一，因为涉及到 UI 稿建议你打开文稿查看一下，那我们拆分结果如图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/94/e22a8ff50c7bbdb637ed6eb42892dd94.png?wh=1000x594\" alt=\"图片\"></p><p>你可以看到，这个简易商品列表已经被拆分了 3 个组件，具体如下：</p><ol>\n<li>ProductTable（紫色）：它是商品列表组件，显示商品列表和表头；</li>\n<li>Category（青色）：它是类别组件，显示一类商品的种类；</li>\n<li>Product（黄色）：它是商品组件，显示某个具体的商品名称和价格。</li>\n</ol><h2>宿主组件：生产基础视图的工厂</h2><p>当你有了怎么把 UI 设计稿拆分成组件的思路后，接下来就要构建静态页面了。</p><p>要构建静态页面，就要有基础的视图材料。在 React Native 中那些最基础、不可再拆的视图材料，大都是由 React Native 框架提供的<strong>宿主视图</strong>。</p><p>比如，UI 设计稿中的水果名称：“苹果”、“火龙果”，价格：“￥1”、“￥2”，还有最顶部的搜索框，这些都是宿主视图。</p><p>而生产宿主视图的工厂，就是宿主组件（Host Components）。这些<strong>宿主组件通常是 React Native 框架提供的组件，它们和你用 JavaScript 自定义的组件不同，宿主组件是直接由 iOS/Android 原生平台实现的。</strong></p><p>除了 React Native 框架提供的宿主组件外，一些社区库也提供了宿主组件，甚至你自己也可以创建宿主组件。</p><p>它们共同的特点是，这些宿主组件上层是 JavaScript 部分，底层是 Native 部分，这两部分是通过 React Native 框架联系起来的。也就是说，你调用宿主组件时，底层直接渲染的是 Native 视图。</p><p>那么，我们这个简易商品列表页的 UI 设计稿中，用到了那些宿主组件呢？其实有三种：</p><ul>\n<li>容器组件 View：顾名思义它就是一个容器，可以用来包裹其他的组件，类似于 Web 中用于嵌套的 div；</li>\n<li>文字组件 Text：设计稿中的文字，比如水果名字“苹果”、“梨子”，价格“1元”、“3元”等等，这些类似于 Web 中装载文字的 span。</li>\n<li>安全区域组件 SafeAreaView：它是最外层的容器组件，用于适配 iPhoneX等的刘海儿屏。</li>\n</ul><p>宿主组件就是一个生产基础视图的工厂，你可以用 Text 组件实例化不同的文字视图。比如，我们可以实例化一个“苹果”文字，也可以再实例化另一个“火龙果”文字，代码如下：</p><pre><code class=\"language-plain\">import {Text} from 'react-native';\n\nconst element1 = &lt;Text&gt;苹果&lt;/Text&gt; // JSX \nconst element2 = &lt;Text&gt;火龙果&lt;/Text&gt; // JSX \n</code></pre><p>你看啊，在这段用 JavaScript 书写的代码中，使用了<strong>类似 HTML 的声明式语法，JSX</strong>。我们先从 react-native 框架中引入了 Text 组件，然后通过 JSX 语法，用一对单闭合标签将 Text 组件进行实例化，生成 Text 元素 element1。当 element1 这个元素渲染到手机屏幕上，就是文字“苹果”了，element2 就是文字“火龙果”。</p><h2>复合组件：纯 JavaScript 函数</h2><p>现在，你已经有了构建静态页面的宿主组件了，接下来你需要用这些宿主组件，搭建你自己事先拆好的自定义组件了，包括：</p><ul>\n<li>ProductTable 商品列表组件\n<ul>\n<li>Category 类别组件</li>\n<li>Product 商品组件</li>\n</ul>\n</li>\n</ul><p>要创建自定义的宿主组件，你必须写 Native 代码。但上面 3 个自定义组件，<strong>你可以直接用 JavaScript 创建，不用写 Native 代码，这类组件也叫复合组件（Composite Components）</strong>。这些复合组件是基于宿主组件或其他复合组件搭建而成的。</p><p>现在我们来创建第一个自定义的复合组件：Product 商品组件，它的示例代码如下：</p><pre><code class=\"language-plain\">export default function Product({product = {name: '苹果', price: '1元'} }) {\n  return (\n    &lt;View style={{flexDirection: 'row', marginTop: 5}}&gt;\n      &lt;Text style={{flex: 1}}&gt;{product.name}&lt;/Text&gt;\n      &lt;Text style={{width: 50}}&gt;{product.price}&lt;/Text&gt;\n    &lt;/View&gt;\n  );\n}\n</code></pre><p>这段代码，对于一些新手来说可能有点长，我分四步和你解释：<br>\n第一步，导出组件。还记得单一责任原则吗？一个组件的责任要单一，一个文件的责任也要单一。因此通常一个文件中只有一个组件，用<code>export default</code>就可以将它导出，让其他文件<code>import</code>引入使用。</p><p>第二步，定义函数。组件是一种特殊的函数。组件名字的首字母一定是大写的，示例中的<code>Product</code>是组件，因此它的 <code>P</code>是大写的（当然，还有类组件，但用得会越来越少，这里我们不探讨，你可以自己额外搜些资料）。</p><p>第三步，接收入参。组件能从其父组件中接参数，而且组件是函数，因此该参数就是函数的入参，通常命名为属性 <code>props</code>。<code>props</code> 是一个对象，因此也可以直接对它进行解构，直接获取对象中的值。</p><p>示例代码中用的就是用解构的方式来获取参数的，它直接获取了<code>product</code>参数，这里的<code>product</code> 是数据因此<code>p</code>是小写的。</p><p>第四步，返回 JSX。组件的返回值就是 JSX，我们前面也提到过，它是用来描述 UI 页面的，JSX 最终生成的是视图元素、文字元素。这里我们初始化了一个<code>&lt;View/&gt;</code>元素，和两个<code>&lt;Text/&gt;</code>元素。</p><p>我们概括一下，自定义复合组件就是一个纯粹的 JavaScript 函数，谁调用它，谁就可以给它传入参数，同样它调用谁，它就可以给谁传入参数，而 JSX 闭合标签就是调用函数的语法糖。</p><h2>静态页面的最终实现</h2><p>现在你知道了 Product 商品组件如何定义，那么 Category 类别组件、ProductTable 商品列表组件对你来说，也就很容易了。</p><p>最后我们来看下，静态页的最终实现，完整代码有点长，我就不都贴出来了，你可以看看文末补充材料中的链接，现在我们只看下它整体长什么样子：</p><pre><code class=\"language-plain\">// index.js\nAppRegistry.registerComponent('appName', () =&gt; App);\n\n\n\n// App.js\nconst PRODUCTS = [\n  {category: '水果', price: '￥1', name: 'PingGuo'},\n];\n\nexport default function App() {\n  return (\n    &lt;SafeAreaView style={{marginHorizontal: 30}}&gt;\n      &lt;ProductTable products={PRODUCTS} /&gt;\n    &lt;/SafeAreaView&gt;\n  );\n}\n\n// ProductTable.js\nimport Category from './Category';\nimport Product from './Product';\n\nexport default function ProductTable({products}){\n  // ...\n  &lt;Category category={products[i].category}\n  // ...\n  &lt;Product product={products[i]} \n  // ...  \n}\n\n// Category.js\nexport default function Category({category}){}\n\n// ProductTable.js\nexport default function Product({product}) {}\n</code></pre><p>这里我定义了五个文件，每个文件中都最多有一个的组件。</p><ul>\n<li>index.js 文件：它是根文件，在该文件中<code>registerComponent</code>方法，会调用根组件 App，然后开始逐级调用，渲染应用；</li>\n<li>App 组件：在 App 组件中，用于表示商品信息的数据变量 <code>PRODUCTS</code>，在被调用时会通过 ProductTable 组件的 <code>products</code> 属性传递下去；</li>\n<li>ProductTable 组件：它被 App 组件调用后，它的调用入参就是 <code>products</code>。<code>products</code> 是一个数组，数组中的每一项就是 <code>Product</code>组件的入参<code>product</code>。每一项中的分类，就是<code>Category</code> 组件的入参 <code>category</code>。还是一样，组件首字母是大写的，属性、入参的首字母是小写的；</li>\n<li>Category 组件：它会被 ProductTable 组件调用两次，第一次调用接收的入参<code>category</code>是“水果”，第二次是“蔬菜”；</li>\n<li>Product 组件：它会被 ProductTable 组件调用 6 次，生成 6 个不同的商品元素，展示在手机屏幕上。</li>\n</ul><p><strong>简而言之，组件间的数据是单向流动的，是逐层往下传递的。</strong>调用是从根组件开始的，根组件会调用其子组件，子组件会调用子子组件，以此类推。调用过程中，数据会被当做组件的属性，层层传递下去。</p><h2>总结</h2><p>前面我们说了，React/React Native 之所以选择基于组件的方式来构建应用，原因就在于组件更能够满足现代应用重交互重展示的特点。</p><p>搭建 React Native 静态页面的核心就是搭建组件。它的整体思路是，从上往下拆出组件，从下往上把拆出来的组件进行逐一实现和拼装。</p><p>在这一讲中，我们搭建的静态页是一个无交互的、轻展示的应用，但 React/React Native 也表现得很好。只要我们遵循单一责任原则，对 UI 设计稿进行拆分，我们就能设计出一个可扩展的、可维护的应用。</p><p>即使后续这个应用有了复杂的交互、有了复杂的展示形式，它也能很好地扩展。我们只需把那些复杂的组件，那些不再符合单一责任原则的组件，进行拆分就可以了。</p><p>最后，请你牢牢记住，宿主组件是最基础的材料，所有我们自定义的复合组件都基于宿主组件搭建出来的，而复合组件又能搭建出更上层的复合组件，这样一步一步，我们才能把静态页面搭建完成。</p><h2>补充材料</h2><ul>\n<li>学习 React 最好的地方就是 <a href=\"https://beta.reactjs.org/\">React 官网</a>。我给的官网地址是新官方地址，目前还是 beta 版本，但不妨碍它是学习 React 最好的地方。这一讲中商品列表静态页的案例，也是参考的 React 新官网改编的；</li>\n<li>这节课里完整的商品列表静态页代码，我放在了 <a href=\"https://github.com/jiangleo/react-native-classroom.git\">GitHub</a> 上；</li>\n<li>关于 React 为什么选择基于组件的架构方式，而不是 MVC，在 2013 年的<a href=\"https://zh-hans.reactjs.org/blog/2013/06/05/why-react.html\">《我们为什么要构建 React?》</a>这篇文章汇中，React 团队给出了答案。</li>\n</ul><h2>思考题</h2><p>静态页面很难体现组件架构相对其他架构的优势。我再找了一个带交互的页面，这个页面可以搜索商品和过滤无库存的商品。请你思考一下，当我们按照搜索、过滤、列表、种类、商品五个维度，用 MVC 方式来架构页面时，它的数据流向是什么样的？它相对于组件架构的优点缺点又是什么？</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/7c/c10647a47d8b2ed5ff0a07cbacb40d7c.png?wh=730x1000\" alt=\"图片\"></p><p>欢迎你在评论区分享你的观点，我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"01｜学习 React Native，你需要掌握哪些知识？","id":499446},"right":{"article_title":"03｜Style：关于样式你需要知道的三件事","id":501650}}},{"article_id":501650,"article_title":"03｜Style：关于样式你需要知道的三件事","article_content":"<p>你好，我是蒋宏伟。</p><p>上一讲我们说到，搭建页面的第一步是搭建静态页面，拿到设计稿后要从上往下拆成组件，再从下往上把组件进行实现。</p><p>但组件只是页面的架子。如果你不使用任何样式，组件只能遵循默认的布局规则、默认字号颜色，铺在屏幕上，看起来就像调试的 log 信息一样，也没有什么体验可言。</p><p>俗话说人靠衣装、佛靠金装，页面体验要好就离不开样式的帮助。大家对 App 的第一印象，就是对页面样式的第一印象。虽说样式设计上是由设计师负责，但最终落地还得靠代码。如何把设计师给的设计稿在不同大小的机型上还原实现，通过验收，是工作中实实在在要面对的考验。</p><p>还原设计稿还只是最基本的要求，作为开发者，你还得要关心开发成本、可维护性、布局性能等事情。比如，有哪些样式库可以节约开发成本？代码量大了需求有变动，样式怎么改起来更方便？React Native 的布局性能究竟怎样，多层嵌套的复杂布局会不会导致性能问题？</p><p>所以今天，围绕着上面这些话题，我和你一起聊聊，关于样式你需要知道的三件事：</p><ul>\n<li>React Native 组件样式都有哪些？</li>\n<li>React Native 的 Flex 布局有哪些特点？</li>\n<li>React Native 样式代码如何管理？</li>\n</ul><h2>组件样式 = 通用样式 + “私有”样式</h2><!-- [[[read_end]]] --><p>我们先来说说，React Native 组件样式都有哪些。</p><p>还原设计稿离不开样式的支持，样式决定了组件在屏幕中的样子。大部分 React Native 提供的框架组件都有样式属性，也就是 style 属性。比如，你要改变文字的颜色，就需要给 Text 组件的 style 属性传一个 <code>{color: 'red'}</code> 对象。如果要设置文字一个圆角边框，那就要稍微复杂一点了，需要三个样式值：边框颜色 borderColor、边框宽度 borderWidth、边框半径 borderRadius，比如这段示例代码：</p><pre><code class=\"language-plain\">// 文字颜色\n&lt;Text style={{color:'red'}}&gt;\n// 圆角边框 \n&lt;Text style={{borderColor:'green', borderWidth: 1, borderRadius: 5}}&gt;  \n</code></pre><p>不过，不同组件的支持的样式可能会有些不同。比如，上面这段代码中，文字颜色 color 只有 Text 和 TextInput 组件有，图片组件  Image 没有文字也不需要 color 样式。而边框样式 border*（比如 borderColor、borderWidth、boderRadius 等等），容器组件 View、文字组件 Text、图片组件 Image 都有。</p><p>那我们怎么知道哪个组件都有哪些样式？要死记硬背吗？当然不用。</p><p>一方面，通过 TypeScript 声明文件，编辑器会提醒你某个组件都有哪些样式。另一方面，React Native 的组件样式是有规则的，你只需要把那些高频样式用会就可以了，其他低频样式，等要用到的时候再翻文档也不迟。</p><p>组件样式是有继承关系的，可以分为三层：</p><ul>\n<li>第一层是通用样式；</li>\n<li>第二层是 View 组件样式；</li>\n<li>第三层是 Text、Image 等其他组件样式。</li>\n</ul><p>我把组件样式的三层继承规则整理成了一张图片，相信你看完之后会有更深刻的理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/9c/2d0dbe2764f676b3bac28330b7ba969c.jpg?wh=1920x1047\" alt=\"图片\"></p><p>通用样式包括布局 Layout、变换 Transform 和阴影 Shadow。容器组件要不要展示归布局 Layout 管，位置确定后要往左边挪点还是旋转个角度归变换 Transform 管，要立体感要加个阴影归 Shadow 管。</p><p>View 组件样式继承了所有通用样式，包括布局 Layout、变换 Transform、阴影 Shadow，除此之外，还有自己的“私有”样式，比如背景颜色 backgroundColor、透明度 opacity、背面可见 backfaceVisibility。另外，Android API 28 以下用的阴影属性 elevation 也是 View 的“私有”样式，为了记忆方便，你也可以将其归类到阴影 Shadow 上。</p><p>大部分组件，比如 Text、Image 组件，都继承了 View 组件样式。因此 View 组件的背景色 backgroundColor、Android 低版本阴影 elevation 等“私有”样式，其实也可以算作通用样式。</p><p>但 Text 组件、Image 组件的“私有”样式，就不能相互通用了。文字颜色 color、字体大小 fontSize、文字行高 lineHeight，这些是文字组件独有的，图片组件就不能用。图片大小模型样式 resizeMode 是图片独有的，文字组件也不能用。</p><p>简而言之，组件样式 = 通用样式 + “私有”样式，View 组件样式可以算作通用样式，而Text 和 Image 组件各有各的“私有”样式。</p><h2>Flex：跨平台、高性能、易上手</h2><p>在所有样式中，你用的最多一定是布局样式（Layout），而布局样式中大部分都是 Flex 相关的弹性布局。</p><p>React Native 在 2015 年诞生之初，就选择使用 Flex 作为默认的布局方式，到现在为止也仅仅只支持了 Flex 弹性盒子布局和 Absolute 绝对定位这两种布局方法。而 Flex 这种布局方式，也经受住了时间的考验，得到更多开发者的认同。</p><p>Flex 布局有三个特点：<strong>跨平台</strong>、<strong>高性能</strong>、<strong>易上手</strong>。</p><p>首先 Flex 布局是跨平台的，这里说的跨平台有两层含义。第一层含义是 Flex 布局并不是 React Native 所独有的，在 Web、Android、iOS 平台也都在用，Flex 布局知识的可迁移性很强。无论是前端开发还是客户端开发，你在你当前领域掌握的 Flex 知识，可以直接拿到 React Native 上用，反之亦然。</p><p>跨平台的第二层含义是，React Native 的布局引擎 Yoga 是 Android、iOS 通用的。你给组件写的 Flex 布局代码，最终都会被 Yoga 引擎计算为精确的坐标系，然后按照计算后的坐标系把组件渲染到屏幕上，这个布局计算在双端是一致。</p><p>有些同学写代码的时候，可能一开始就担心，“这么写是不是会嵌套太深了，会不会引起布局性能问题？”，“设计师给的布局太复杂了，性能会不会不好啊？”。其实这些性能问题大可不必担心，正常写就行，Flex 布局用的 Yoga 引擎性能很好。</p><p>我这里放了一张布局引擎性能对比图，图片来源于 Github 开源仓库<a href=\"https://github.com/layoutBox/LayoutFrameworkBenchmark\"> 《Layout Framework Benchmark》</a>。核心代码贡献者 Luc Dion 是一位 iOS 开发工程，他用 100 次 UICollectionView 布局耗时作为基准，横向对比了多款 iOS 布局引擎性能。其中就包括由苹果官方提供了 UIStackViews 和 Auto layout 布局引擎，还有使用 Yoga 实现 FlexLayout 布局引擎。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/f7/612209db97553841a1d49bf207e7eef7.png?wh=1000x736\" alt=\"图片\"></p><p>在图中你可以看出，虽然 iPhone 每代的性能越来越好，100 次 UICollectionView 的布局耗时越来越少。但从框架性能角度看，<strong>使用 Yoga 实现的FlexLayout 布局引擎比苹果官方提供了 UIStackViews 和 Auto layout 布局引擎，耗时减少了将近一个量级。</strong></p><p>这样看来，React Native 中的 Flex 布局确实是挺好的，那上手难不难？不难，易学易用，上手就会。</p><p>前面我们也提到过，Flex 其实是一种通用的布局方式，它引入了弹性布局的概念，这个概念在各平台都是一样的。但在具体的写法上，各个平台可能会有一些差异。</p><p>我用最常见三种布局给你举些例子，它们包括从上往下排列布局、左图右文布局、文字居中布局。你可以感受一下，React Native 的 Flex 布局，和你在其他平台使用过的 Flex 布局有什么差异。</p><p><strong>第一个例子，从上往下排列布局。</strong></p><p>在同一个父容器中，放三个子容器 View，父容器不写任何的样式，子容器只给一个固定高度，三个子容器就是从上往下排列的。</p><p>这里强调一下，父容器 VIew 的默认样式是<code>{display: \"flex\",flexDirection:'column'}</code>。也就是说，父容器是弹性盒子，且主轴是纵轴，子元素会沿着纵轴（主轴）方向排列，因此在父元素不写任何样式时，子元素是从上往下排列的。</p><p>示例代码如下：</p><pre><code class=\"language-plain\">&lt;View&gt;\n  &lt;View style={{height: 50, backgroundColor: 'powderblue'}} /&gt;\n  &lt;View style={{height: 50, backgroundColor: 'skyblue'}} /&gt;\n  &lt;View style={{height: 50, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n</code></pre><p><strong>第二个例子，左图右文布局。</strong></p><p>在同一个父容器中，放一个 Image 和一个 Text。为了让图片文字左右排列，我们需要给父容器设置布局样式<code>{flexDirection: 'row'}</code>。为了让图片不拉伸变形，我们需要给图片 Image 设置一个固定宽高。为了让文字将剩余宽度铺满，我们需要给文字 Text 设置 <code>{flex: 1}</code>。这时，父容器的主轴是横轴，子元素会沿着横轴（主轴）方向排列，整体布局是左图右文。具体的代码如下：</p><pre><code class=\"language-plain\">&lt;View style={{flexDirection: 'row'}}&gt;\n  &lt;Image\n    style={{width: 100, height: 100}}\n    source={{\n    uri: 'https://placeimg.com/640/480/cats',\n  }}\n  /&gt;\n  &lt;Text style={{flex: 1,fontSize: 18}}&gt;我是文字&lt;/Text&gt;\n&lt;/View&gt;\n</code></pre><p><strong>第三个例子，文字居中布局。</strong></p><p>曾经有一道经典的面试题，“父容器高度确定，使其子元素 Text 水平垂直方向居中”，不过自从有了 flex 后，这道题的难度降低了很多，问的频率也变低了。</p><p>我们通过 alignItems 和  justifyContent 的配合，很容易实现水平垂直方向的居中布局，示例代码如下：</p><pre><code class=\"language-plain\">&lt;View\n    style={{\n      alignItems: 'center',\n      justifyContent: 'center',\n      // 高度确定\n      height: 60,\n      borderWidth: 1,\n    }}&gt;\n    &lt;Text\n      style={{\n        fontSize: 18,\n        // 文字默认内边距，会导致垂直居中偏下\n        includeFontPadding: false,\n        // 文字默认基于基线对齐，会导致垂直居中偏下\n        textAlignVertical: 'center',\n      }}&gt;\n    我是文字1\n    &lt;/Text&gt;\n&lt;/View&gt;\n</code></pre><p>在这段代码中，你只需要给父容器设置<code>{justifyContent: 'center',alignItems: 'center'}</code>，使子元素分别在主轴（纵轴）和副轴（横轴）方向居中就可以了。这里有个小细节，Android 文字默认会有内边距且基于基线对齐，这会导致文字垂直居中时偏下。<strong>因此垂直居中时，最好把内边距关掉，并把文字放在中线而不是基线上。</strong></p><p>当然，文字水平垂直方向居中，除了 Flex 方案，还有行高方案，感兴趣的同学也可以自己研究一下，这里就不再介绍了。</p><p>讲完这三个例子后，你是否发现 React Native 与你所熟悉的其他平台，在 Flex 布局上的不同点了呢？你可以在心里对照一下，这样做能帮你学得更快。</p><h2>StyleSheet：分离、复用、性能好</h2><p>在前面的几个例子中，我们写样式用的都是内联的方式。内联样式就是直接在 JSX 的元素属性中写样式，这样写起来是很方便，但是却把 JSX 的元素结构和样式混在一起了。</p><p>既然样式属性可以内联，那事件属性也可以内联，甚至所有的属性都可以内联。而且现在 JSX 模板既要声明元素结构，又要写样式、事件、属性逻辑，整一个大杂烩。写起来是很爽，但维护起来就很“酸爽”了。</p><p>此外，内联样式还存在不能复用，性能损耗的问题。首先，即便两个文字组件的样式是一样的，内联样式也不能重复使用，必须在两个组件中各写一套。其次，每次执行自定义组件函数生成元素时，或实例化元素时，样式对象都要重复创建，这导致了性能损耗。你可以看看这段示例代码感受一下：</p><pre><code class=\"language-plain\">// 各种内联，导致 JSX 结构不清楚。\n&lt;View\n      // 普通属性\n      hitSlop={\n      top: 10,\n      bottom: 10,\n      left: 0,\n      right: 0\n    }\n      // 事件属性\n      onLayout={() =&gt; {\n      // 事件逻辑\n      }}\n      // 样式属性\n    style={{\n      alignItems: 'center',\n      justifyContent: 'center',\n      height: 60,\n      borderWidth: 1,\n    }}&gt;\n    &lt;Text\n      style={{\n        fontSize: 18,\n        includeFontPadding: false,\n        textAlignVertical: 'center',\n      }}&gt;\n    我是文字1\n    &lt;/Text&gt;\n    &lt;Text\n      style={{\n        fontSize: 18,\n        includeFontPadding: false,\n        textAlignVertical: 'center',\n      }}&gt;\n    我是文字2\n    &lt;/Text&gt;\n&lt;/View&gt;\n</code></pre><p>所以，我推荐你使用样式表 StyleSheet 来写样式，而不是内联的方式。使用样式表 StyleSheet 有三个好处：</p><ul>\n<li>元素结构和样式分离，可维护性更好；</li>\n<li>样式对象可以复用，能减少重复代码；</li>\n<li>样式对象只创建一次，也减少性能的损耗。</li>\n</ul><p>比如，面对上面这种大杂烩的代码，你可以试着把内联样式等属性抽离出来，没有了冗余的样式和属性，我们一眼就能看出原本的 JSX 结构：</p><pre><code class=\"language-plain\">// JSX 结构\n&lt;View\n      hitSlop={hitSlop}\n      onLayout={handleLayout}\n    style={styles.container}&gt;\n    &lt;Text style={styles.texts}&gt;我是文字1&lt;/Text&gt;\n    &lt;Text style={styles.texts}&gt;我是文字2&lt;/Text&gt;\n&lt;/View&gt;\n\n// 样式表\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: 'center',\n    justifyContent: 'center',\n    height: 60,\n    borderWidth: 1,\n  },\n  texts: {\n    fontSize: 18,\n    includeFontPadding: false,\n    textAlignVertical: 'center',\n  }\n});\n</code></pre><p>你看，这是一个容器组件 View 嵌套了两个文字组件 Text。样式结构分离后，逻辑也更加清晰，维护起来也会容易很多。</p><p>而且，在这段代码中，两个 Text 组件使用了同一个样式对象 <code>styles.texts</code>，也实现了复用。样式对象在代码初始化时就创建好了，每次执行就不用再创建了，这样减少了性能损耗。</p><h2>课程小结</h2><p>我们前面说了，样式决定了页面的“颜值”，关于样式你需要知道这三件事：</p><ol>\n<li>大部分框架提供的组件都有自己的样式属性 style，包括通用样式和“私有”样式。其中 View 组件样式可以看做通用样式，而 Text 组件、Image 组件各有各的“私有”样式；</li>\n<li>在所有样式中，最常用的是 Flex 布局，也是你的学习重点。React Native 的 Flex 布局和其他平台的 Flex 布局模型基本相同，如果你有过 Flex 的使用经验，只需结合示例掌握 React Native 中的那些不同点就能快学会；</li>\n<li>内联样式写 Demo 是没有问题的，但在实际的生产中我更加推荐你使用样式表 StyleSheet 来进行样式管理。</li>\n</ol><p>React Native 的样式大都是从 Web 中借鉴过来的，并且还进行了“CSS in JS”的改良，相信你学起来会非常快。</p><p>如果你问我学习样式还有什么技巧，那我会告诉你，无他，唯手熟尔。只要多多练习就能学好。学习样式不需要严格的推理逻辑，需要的只有勤加实践，当初我入门的时候，就是通过模仿国内电商的官网，把样式给打通关的，你也赶紧试试吧。</p><h2>补充材料</h2><p><strong>样式学习材料：</strong>React Native 的样式其实很简单，所有的核心样式在的源码中只有 1 份声明文件<a href=\"https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/StyleSheet/StyleSheetTypes.js\">StyleSheetTypes</a>。这一份声明文件对应的是官网的 6 篇文档：<a href=\"https://reactnative.dev/docs/view-style-props\">View Style Props</a>、<a href=\"https://reactnative.dev/docs/text-style-props\">Text Style Props</a>、<a href=\"https://reactnative.dev/docs/image-style-props\">Image Style Props</a>、<a href=\"https://reactnative.dev/docs/layout-props\">Layout Props</a>、<a href=\"https://reactnative.dev/docs/shadow-props\">Shadow Props</a>、<a href=\"https://reactnative.dev/docs/transforms\">Transforms</a>。</p><p><strong>Flex 学习材料</strong>：Yoga 官网提供了 Flex 弹性盒子布局的在线试用应用 <a href=\"https://yogalayout.com/playground\">Playground</a>，你可以动手把玩一下。React Native 官网也为你提供了沙盒环境的相关 <a href=\"https://reactnative.dev/docs/flexbox\">Demo</a>。</p><p><strong>样式管理资料</strong>：今天只介绍了<a href=\"https://reactnative.dev/docs/stylesheet\">样式表 StyleSheet</a>这种最基础的样式管理方案。业内主流的方案还有<a href=\"https://styled-components.com/\">带样式的组件 styledComponent</a> 和<a href=\"https://tailwindcss.com/\">样式简写方案 tailwind</a>，它们虽然是源自浏览器的 CSS 管理方案，但也可以在 React Native 中使用。在推特上也有关于样式管理方案的<a href=\"https://twitter.com/mrousavy/status/1474135375555743750\">讨论</a>，你可以看看大家的看法是什么。业务代码的样式管理没有银弹，选择适合你的就好了。</p><p><a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/03_StyleSheet\">今天的 Demo 在这里！</a></p><h2>作业</h2><ol>\n<li>请你使用 View、Text、Image 组件实现一个简易版的瀑布流布局，类似于京东、淘宝首页瀑布流列表，不要求能够无限滚动只要能实现左右等宽、不等高的布局即可。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/36/88/361a7df40bc2a671336fcf44ca560388.png?wh=1170x1140\" alt=\"图片\"></p><ol start=\"2\">\n<li>如果你要给 Text 组件设置全局的默认样式，比如字体，你会怎么设置？</li>\n</ol><p>欢迎在评论区写下你的想法。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"02｜Component：搭建静态页面的正确思路是什么？","id":500633},"right":{"article_title":"04｜State：如何让页面“动”起来？","id":503115}}},{"article_id":503115,"article_title":"04｜State：如何让页面“动”起来？","article_content":"<p>你好，我是蒋宏伟。</p><p>那么这一讲，我们来讲搭建页面的第二步，让页面“动”起来，这里的“动”说的是在不同场景下，让页面展示出不同的内容。</p><p>怎么让页面“动”起来呢？这就要用到状态 State 了。</p><p>一个页面也好，一个应用也好，只有把状态设计清楚了，程序才能写得好。讲到状态，有些人可能会说，状态不就是页面中那些会“动”的数据吗？这很简单，还有什么好讲的。</p><p>这没错，状态确实是页面中会“动”的数据，但是要把状态用好不容易，有时候容易把状态设计复杂了，不仅代码要写得更多，还容易导致程序维护起来更麻烦。</p><p>这次，我会以搭建一个会“动”的简易购物车页面为例，和你分享下我在这方面的经验。简易购物车页面是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/9e/dd69765bb8fcb1f9dffyy2df4d2b789e.png?wh=1000x784\" alt=\"图片\"></p><p>它比上一讲的商品表单页多了一些交互，它的所有数据都是从网络请求过来的，这些数据包括商品名称、商品价格、商品数量，数据从网络请求回来后会展示在页面上。你可以点击页面中的加号或减号，来添加数量或减少商品数量，底部的结算总价会随着商品数量的变化而变化。</p><p>要实现这个简易购物车的静态很简单，它只包括两个组件，商品表单组件 ProductTable 和商品组件  ProductRow。完成静态页面的搭建后，接下来就<strong>要让页面“动”起来了</strong>，我把这个过程分成了 4 步来实现，状态初选、状态确定、状态声明、状态更新。</p><!-- [[[read_end]]] --><h2>第一步：状态初选</h2><p>状态初选说的是，先看看页面那些数据是会变化的，这些会变化的数据都可能是状态，我们先把它们找出来。</p><p>程序本身的事件和用户操作都有可能导致页面发生变化，因此我们从这两个方向来进行初选。</p><p>程序本身的事件，比如网络请求、 setTimeout，都可能导致页面发生变化。在购物车页面中，商品列表的数据是从服务端请求过来，在列表数据从服务端回来之前，页面是空白的，在请求过程中会有加载提示，请求成功后购物车页面就会展示出来，当然还要把请求失败的情况考虑进去。</p><p>所以，我圈选出来的第一条动态数据是请求过程，第二条是可能的请求失败情况；第三条是商品表单本身，第四条是所有商品的结算总价。</p><p>用户操作，比如点击、滑动、缩放，也可能导致页面发生变化。在购物车页面中，用户点击加号购物车中的商品数量会增加，点击减号数量会减少。反映商品数量的数据，就是第五条的动态数据。</p><p>现在，我已经把这 5 个初选的状态给你在图中标出来了：</p><p><img src=\"https://static001.geekbang.org/resource/image/43/f3/43bc848544fb40b449c097e6054ac0f3.png?wh=1920x1541\" alt=\"图片\"></p><h2>第二步：状态确定</h2><p>有些人完成状态初选这一步后，就直接写起代码来了，一口气声明了 5 个状态，然后想办法去操作这 5 个状态如何变化。</p><p>但我的经验是，状态初选完成后，不能急着写代码，要先确定一下这些初选状态中那些是真正的状态，把其中无用的状态剔除掉，然后再去写代码。这样代码写得少、写得快，代码逻辑也会更简单一些，也更难出 BUG 一些。</p><p>这些都是我们要在状态确定这一步要做的，我总结了三条经验：</p><p><strong>首先，一件事情一个状态。</strong>我发现有些同学写代码的时候，在定义请求状态时，喜欢用布尔值 isLoading 来表示空闲状态或请求中的状态，用 isError 来表示成功状态或失败状态，明明就是网络请求这一件事，却用了两个状态来表示，这就有点多余了，甚至在一些不好测试的边界条件下可能还会留坑。</p><p>这时其实只需要定义一个状态 ，代码示例如下：</p><pre><code class=\"language-plain\">const requestStatus = {\n  IDLE : 'IDLE',\n  PENDING : 'PENDING',\n  SUCCESS : 'SUCCESS',\n  ERROR : 'ERROR',\n}\n</code></pre><p>这里，我定义的是一个枚举对象 requestStatus，用它来表示请求状态。这个对象有 4 个值，包括请求空闲IDLE、请求中PENDING、请求成功SUCCESS、请求失败ERROR。你看，用一个状态是不是比用两个状态更加贴合请求的实际情况呢？</p><p><strong>第二，重复状态不是状态。</strong>商品组件 ProductRow 中的这个商品数量确实是一个状态，但它却和从网络请求中回来的商品表单状态重复了。从代码层面上，我们确实有办法同时保留两个状态，但这样做就绕弯子了。</p><p>更好的做法是，把这两个在不同组件之间的重复状态进行合并，去掉底层组件的重复状态，只保留顶层组件中的商品数量作为唯一的状态。</p><p><strong>最后，可计算出来的状态不是状态。</strong>一个状态必须不能通过其他状态、属性或变量直接计算出来，能通过其他值计算出来的状态，都不是状态。比如，在购物车页面中，结算总价这个动态数据，是可以通过对所有商品的单价和数量的积进行求和得出来的，所以它不是状态。</p><pre><code class=\"language-plain\">结算总价 = ∑(商品的单价 * 数量)\n</code></pre><p>初选的状态经过以上三步筛选之后，合并了①请求中和②请求失败，避免了重复数据③商品列表和⑤商品数量，根据已有状态推导出了④结算总价。初选状态一共 5 个，最终确定下来就只剩下网络请求状态和商品列表这两个状态了。</p><p>只有确定状态这一步做好了，你声明状态和改变状态，才会变得容易。</p><h2>第三步：状态声明</h2><p>React 提供了 useState 状态声明函数，你可以用它来管理函数组件的状态。</p><p>使用 useState 声明状态时，状态和组件是绑定的关系，useState 在哪个组件中使用，它生成的状态就属于那个组件。由于单向数据流的原因，React 把父组件的状态传给子组件只需要传一次，传给子子组件需要传递两次。</p><p>因此，你在定义状态的时候，一定要先考虑好把状态绑定到哪个组件上。我建议你用<strong>就近原则</strong>来绑定状态，就近原则的意思是哪个组件用上了状态，就优先考虑将状态绑定到该组件上，如果有多个组件使用了同一个状态，则将其绑定到最近的父组件上。这样做能让使用 props 传递状态的次数最少。</p><p>在我们的购物车案例里，你使用就近原则判断一下，<s>你</s>就可以确定购物车页面的两个状态，其实放在 ProductTable 组件中比较合适。</p><p>那接下来的问题是，状态声明代码应该如何写？</p><p>首先，我需要和你强调的是，在 React/React Native 中，所有使用 use 开头的函数，比如接下来要用到 useState 函数，它们都叫<strong>钩子函数（hook function）</strong>。和普通函数不同，你不能把钩子函数写在 if 条件判断中、事件循环中、嵌套的函数中，这些都会导致报错。</p><p>钩子函数类似于 JavaScript 的 <code>import</code> ，你最好在函数组件的顶部使用它们。</p><p>具体声明商品表单状态 products 和请求状态 requestStatus 代码是这样的：</p><pre><code class=\"language-plain\">import React, {useState} from 'react';\n\nexport default function ProductTable() {\n  const [products, setProducts] = useState([]);\n  const [requestStatus, setRequestStatus] = useState('IDLE');\n  // ...\n}\n</code></pre><p>在文件的第一行代码中，我们从 React 中引入 useState 函数，然后在函数组件 ProductTable 的顶部使用了 useState 声明了两个状态。</p><p>useState 函数的入参是状态的默认值，函数的返回值是状态和更新该状态的函数。第一次调用 useState 函数后，就生成了默认值是空数组<code>[]</code> 的商品表单状态 <code>products</code> ，以及设置该状态的函数<code>setProducts</code>。第二次调用 useState 函数后生成了默认值是字符串<code>'IDLE'</code> 的请求状态 requestStatus ，以及设置该状态的函数叫做<code>setRequestStatus</code>。</p><p>如果在 if 中使用了任何的钩子函数，就会报错：</p><pre><code class=\"language-plain\">import React, {useState, useEffect} from 'react';\n\n// 错误\nexport default function ProductTable() {\n  const [requestStatus, setRequestStatus] = useState('IDLE');\n  // ...\n  if(requestStatus === 'ERROR') return &lt;Text&gt;网络出错了&lt;/Text&gt;\n\n  // 在 else 分支中，使用任何 use 开头的钩子函数，都会报错\n  const [products, setProducts] = useState([]);\n  useEffect(() =&gt; {})\n  \n  return &lt;Text&gt;购物车页面&lt;/Text&gt;\n}\n</code></pre><p>在这个错误示例中，我们先使用了 <code>if(requestStatus === 'ERROR')</code> 判断了网络请求状态。如果请求失败，则提示用户“网络出错了”，否则就返回真正的购物车页面。但 <code>if return</code> 后面的代码，就相当于<code>else</code>分支，在分支中使用了钩子函数，比如 useState、useEffect，代码就会报错。</p><p>出现这种报错，是因为 if 破坏了 React 的 <a href=\"https://zh-hans.reactjs.org/docs/hooks-rules.html\">Hook 规则</a>。在 React 的 Hook 机制中，是把 Hook 的调用顺序作为索引，用它把 React 框架内部 state 和其函数组件的 useState 返回值中的 state 给关联起来了。当你使用了 if 的时候，就容易破坏 Hook 的调用顺序，导致 React 不能正确地将框架内部 state 与函数组件 useState 的返回值关联起来，因此 React 在执行的时候就会报错。</p><p>有时候一个函数组件很长，写到后面了，前面的一些逻辑就记不那么清楚了，如果代码写到哪就在哪儿声明一个新状态，一不小心就可能会踩坑。因此，你应该把 use 开头的钩子函数都写在组件的顶部，把 JSX 都写在函数组件的最后面，并使用 <a href=\"https://www.npmjs.com/package/eslint-plugin-react-hooks\">eslint-plugin-react-hooks</a> 插件来保障 Hook 规则的会被正确执行。</p><h2>第四步：状态更新</h2><p>现在，到了最后一步了。不过，这一步中涉及购物车页面业务实现逻辑的部分，我就不一一介绍了，具体实现代码我放到了附加材料中，这里我想重点和你强调的是如何更新对象类型的状态。</p><p>在 JavaScript 中的数据类型可以分为两类，对象数据类型（Objects）和原始数据类型（Primitive values），对象数据类型包括对象（Object）、数组（Array），原始数据类型有 7 种，比如数字（number）、字符串（string）等等。</p><p>在 React/React Native 中，使用这两类数据类型作为状态都是可以的，但是更新这两类状态的方法不一样，如果你没有理解清楚二者的区别，就容易出现一些低级的 BUG。</p><p>我们先来看原始数据类型的状态如何更新。</p><p>在购物车页面中，商品数量可以通过点击加号进行加一，通过点击减号减一。我们用原始数据类型数字来表示商品数量状态，其代码实现如下：</p><pre><code class=\"language-plain\">export default function Count() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &lt;View&gt;\n      &lt;Text&gt;{count}&lt;/Text&gt;\n      &lt;Button title=\"+\" onPress={() =&gt; setCount(count + 1)} /&gt;\n      &lt;Button title=\"-\" onPress={() =&gt; setCount(count - 1 &gt;=0? count - 1: 0)} /&gt;\n    &lt;/View&gt;\n)};\n</code></pre><p>你可以看到，我们使用 useState 声明了商品数量状态 count 和更新状态的函数 setCount。<br>\n组件初始化时，也就是组件函数第一次调用时，商品数量状态 count 的默认值是 0，页面展示的数字就是 0.</p><p>当你点击页面中的加号（“+”）时，就会触发加号（“+”）点按组件（Button）的点击事件（onPress），此时会调用 setCount 函数更新状态。</p><p>setCount 函数的入参是 count + 1，其中 count 取的是组件第一次调用的默认值 0，0 + 1 = 1，因此新状态就是 1，之后 React/ React Native 会再调用一次组件函数，这一次调用时 useState 声明的状态 count 的值就是新状态的值 1，此时 Text 组件收到的值也是 1，最后页面刷新展示新状态 1。</p><p>第二次点击加号时，也是先更新 React/ React Native 内部的<s>新</s>状态，将它更新到 2，然后再执行一次组件函数，将内部的新状态同步给 count，最后刷新页面展示新状态 2。</p><p>以此类推，<strong>对于原始数据类型而言，调用 setCount 更新原始数据类型状态的值，页面就会发生更新。</strong></p><p>那对象和数组类型的状态如何更新呢？</p><p>我们先声明一个对象状态和一个数组状态，代码如下：</p><pre><code class=\"language-plain\">const [countObject, setCountObject] = useState({num: 0});\nconst [countArray, setCountArray] = useState([0]);\n</code></pre><p>这段代码中，调用了两次 useState，声明一个对象状态 countObject 和一个数组状态 countArray，以及对应的状态更新函数。</p><p>理论上，你可以直接改变对象状态或数组状态的值，再调用状态更新函数，代码如下：</p><pre><code class=\"language-plain\">countObject.num++;\nsetCountObject(countObject)\n\ncountArray[0]++;\nsetCountArray(countArray)\n</code></pre><p>但是你试过后会发现，调用状态更新函数后，页面什么变化都没有，这是为什么呢？<br>\n弄清楚了对象数据类型（Objects）和原始数据类型的区别后，你就明白了。我给你举个例子：</p><pre><code class=\"language-plain\">const countObject = {num: 0}\ncountObject.num++;\n\ncountObject.num === countObject.num // false\ncountObject === countObject // true\nsetCountObject(countObject) // 不更新\n</code></pre><p>你看，当你更新 countObject.num 时，countObject.num 确实更新了，但是 countObject 的引用并没有更新，所以调用 setCountObject 更新状态时，页面没有任何变化。</p><p>这是因为，对象它是一种复合数据类型，它内部的值是可变的（mutable），但它的引用是不可变了（immutable），你更新了对象的内部值后，它的引用并没有发生变化。</p><p>那状态是对象或数组时，应该怎么更新呢？</p><p>业内也有形似 mutable 的更新方案 useImmer，可以通过直接修改变量的值来更新状态。但其底层原理也是，新建一个对象或数组传给状态更新函数，让状态更新函数知道对象或数组确实发生了变化，这时 React/React Native 框架才会帮你更新页面。</p><p>这里，我用的也是直接新建对象、新建数组的方式，代码如下：</p><pre><code class=\"language-plain\">setCountObject({...countObject, num: countObject.num+1});\n\nconst newCountArray = [...newCountArray]\nnewCountArray[0]++;\nsetCountArray(newCountArray)\n</code></pre><p>你可以看到，对于对象状态的更新我是这么处理的，我先创建了一个新对象<code>{}</code>，然后用<code>...</code>的解构的方式将老对象 countObject 的内部值重新赋值给了新对象<code>{}</code>，再指定<code>num</code>属性进行了复写。对于数组状态的更新也是类似的，你可以自己试试。</p><h2>总结</h2><p>这一讲，我们完成搭建页面的第二步：让页面“动”起来。让页面“动”起来，就要用到状态，我们这一讲的具体实现分为 4 个步骤，状态初选、状态确定、状态声明、状态更新。</p><ul>\n<li>状态初选，就是把设计稿中的那些会“动”的数据先选出来；</li>\n<li>状态确定，就是合并同类状态、删除无用状态和衍生状态；</li>\n<li>状态声明，在当前的初学阶段，只需要学会使用 useState 来声明组件状态即可；</li>\n<li>状态更新是最后一步。交互事件和程序事件会触发状态的更新，但状态更新函数并不会帮我们自动合并上一个状态，因此在处理对象状态和数组状态时，每次更新时必须新建一个完整的对象或数组。</li>\n</ul><p>行军作战是兵马未动粮草先行，讲究的是谋而后动。搭建页面、开发组件也是如此，我们也要<strong>代码未动构思先行</strong>，先把组件状态设计好了，简单即美，要是没想清楚弄复杂了，后面填坑成本会很高。</p><h2>附加材料</h2><ol>\n<li>再次强调，学习 React 最好的材料就是 React 新官网，我推荐你去读一读<a href=\"https://beta.reactjs.org/learn/reacting-to-input-with-state\">《如何使用状态响应用户的输入时间》</a>、<a href=\"https://beta.reactjs.org/learn/updating-objects-in-state\">《更新状态对象》</a>和<a href=\"https://beta.reactjs.org/learn/updating-arrays-in-state\">《更新状态数组》</a>。</li>\n<li>实现购物车页面的完整代码，我放在了<a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/04_State\">GitHub</a>上。</li>\n</ol><h2>作业</h2><ol>\n<li>请你实现一个井字棋。井字棋的规则和五子棋类似，两人在 3 * 3 格子上进行连珠游戏，任意 3 个标记形成一条直线，则为获胜。在写之前，推荐你先玩一下这个井字棋，了解一下<a href=\"https://codepen.io/gaearon/pen/aWWQOG?editors=0010\">井字棋的最终效果</a>。</li>\n<li>请你思考一下实现一个井字棋，最少需要声明几个状态？</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/59/e0/599257d6cc84ceda0fc5ebe8174af7e0.png?wh=474x347\" alt=\"图片\"></p><p>欢迎在留言区分享你的想法。下一节课我们将来讨论React Native中图片组件的用法和最佳实践，你可以做些准备。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"03｜Style：关于样式你需要知道的三件事","id":501650},"right":{"article_title":"05｜Image：选择适合你的图片加载方式","id":503636}}},{"article_id":503636,"article_title":"05｜Image：选择适合你的图片加载方式","article_content":"<p>你好，我是蒋宏伟。</p><p>今天我们来讲解 React Native 框架中的 Image 组件。顾名思义，图片组件 Image 就是用来加载和展示图片的。</p><p>你可能会觉得，图片组件的基础用法非常简单呀，学起来也很容易上手，这有什么好讲的呢？没错，正因为它很简单，有时候，我们可能会忽视对这些基础知识的琢磨。在日常开发中，图片是影响用户体验的关键因素之一，它很常见，基本上哪里都有它。而且相对于文字，图片也更容易抓住用户的眼球。图片组件很重要，但要用好却不那么容易。</p><p>React Native 的 Image 组件一共支持 4 种加载图片的方法：</p><ul>\n<li>静态图片资源；</li>\n<li>网络图片；</li>\n<li>宿主应用图片；</li>\n<li>Base64 图片。</li>\n</ul><p>这4种方案给我们业务提供了更灵活的选择空间，但同时也让不少同学犯了选择困难症，不同情况下我该怎么选呢？今天，我们就来深度剖析这 4 种方案分别的适用场景是什么，并给你介绍一下我推荐的最佳实践。</p><h2>静态图片资源</h2><p>静态图片资源（Static Image Resources）是一种<strong>使用内置图片</strong>的方法。静态图片资源中的“静态”指的是每次访问时都不会变化的图片资源。站在用户的视角看，App 的 logo 图片就是不会变化的静态图片资源，而每次访问新闻网站的新闻配图就是动态变化的图片。</p><!-- [[[read_end]]] --><p>如果图片每次都不会变化，那么你就可以把这张图片作为静态图片资源，内置在 App 中。这样，用户在打开你的 App 时，图片是从本地直接读取的，直接读取图片的速度比走网络请求先下载再加载的速度要快上很多。一张网络图片从下载到展示的耗时通常需要 100ms 以上，而一张内置图片从读取到展示的耗时通常只有几 ms，甚至更低，二者耗时相差了两个数量级。</p><p>因此，在一些高性能场景下，你应该选择把这些不经常变动的静态图片资源内置到 App 中。当用户打开 App 时，这些图片就能够立刻展示出来了。</p><p>那我们具体是怎么使用静态图片资源的呢？这里我们可以分为 3 步。首先，把图片放到 React Native 的代码仓库中，然后通过 require 的方式引入图片，最后把图片的引用值传给 source 属性。Image.source 属性是用来设置图片加载来源的。</p><p>这里我们需要注意的是，require 函数的入参必须是字面常量，而不能是变量。你可以看下这段代码：</p><pre><code class=\"language-plain\">// 方案一：正确\nconst dianxinIcon = require('./dianxin.jpg')\n&lt;Image source={dianxinIcon}/&gt;\n\n// 方案二：错误\nconst path = './dianxin.jpg'\nconst dianxinIcon = require(path)\n&lt;Image source={dianxinIcon}/&gt;\n</code></pre><p>在这段代码中，方案一是静态图片资源正确的使用方式，方案二是错误的。方案一用的是图片相对路径的字面常量，也就是<code>'./dianxin.jpg'</code>。而方案二，用的是图片相对路径的变量，也就是 <code>path</code> 。</p><p>你是不是很好奇，为什么使用 require 函数引入静态图片资源时，require 入参，也就是图片的相对路径，必须用字面常量表示，而不能用变量表示？静态图片资源的加载原理又是什么呢？我们接下来继续分析。</p><h3>静态图片资源的加载原理</h3><p>我们还是用加载点心图片（dianxin.jpg）为例，从编译时到运行时，剖析加载静态资源图片的全过程，一共分为三步。</p><p><strong>第一步编译</strong>：在编译过程中，图片资源本身是独立于代码文件之外的文件，图片资源本身是不能编译到代码中的，所以，我们需要把图片资源的路径、宽高、格式等信息记录到代码中，方便后面能从代码中读取到图片。</p><p>你可以选一张你喜欢吃的点心的图片，命名为 dianxin.jpg，并把点心图片和 index.js 文件放在同一层级目录下。然后在 index.js 中通过 require 方法把点心图片引入进来，交由 Image 组件使用。</p><p>我在这一讲末尾的补充材料中，为你留了示例代码，课后你可以参考示例代码，一步步地自己动手操作。现在，你应该把注意力放在理解静态图片资源的编译、构建和加载的流程上，具体的执行细节可以后续再了解。</p><p>在你引入静态图片资源完成后，可以先本地试试图片是否能正常展示。如果展示没有问题，直接运行<code>react-native bundle</code>的打包命令，开始打包编译：</p><pre><code class=\"language-plain\">npx react-native bundle --entry-file index.tsx --dev false --minify false --bundle-output ./build/index.bundle --assets-dest ./build\n</code></pre><p>这段打包（bundle）命令的意思是，以根目录的 index.tsx 文件为入口（entry file），产出 release（dev=false）环境的包，这个包不用压缩（minify=false），并将这个包命名为 ./build/index.bundle，同时将静态资源编译产物放到 ./build 目录。这个 build 目录结构如下：</p><pre><code class=\"language-plain\">./build\n├── assets\n│ &nbsp; └── src\n│ &nbsp; &nbsp; &nbsp; └── Lesson3Image\n│ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; └── dianxin.jpg\n└── index.bundle\n</code></pre><p>编译后的产物会都存在 build 目录中，这个目录需要你提前创建好，否则会有报错提示。编译完成后，你可以在 build 目录中找到 index.bundle 文件，它是编译后的 JavaScript 代码。另外， build 目录中还有一个 assets 目录，assets 目录放的是编译后的图片 dianxin.jpg。</p><p>然后我们再打开 index.bundle 文件，搜索 dianxin 关键字。我们可以找到一个和 dianxin 关键字相关的独立模块，这个模块的作用就是将静态图片资源的路径、宽高、格式等信息，注册到一个全局管理静态图片资源中心。这个独立模块的代码如下：</p><pre><code class=\"language-plain\">  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({\n    \"__packager_asset\": true,\n    \"httpServerLocation\": \"/assets/src/Lesson3Image\",\n    \"width\": 190,\n    \"height\": 190,\n    \"scales\": [1],\n    \"hash\": \"0d4ac32eb69529cf90a7b248fee00592\",\n    \"name\": \"dianxin\",\n    \"type\": \"jpg\"\n  });\n</code></pre><p>它主要包括该图片的注册函数 registerAsset 和其注册信息。其中图片的注册信息包括，目录信息（/assets/src/Lesson3Image）、宽高信息 （width 和 height）、图片哈希值（hash）、图片名字（dianxin）、图片格式（jpg）等等。</p><p>很明显，这个静态图片资源的注册函数和相关的图片信息代码，并不是你写的。那这段代码是怎么来的呢？它是由打包工具根据字面常量<code>'./dianxin.jpg'</code>，找到真正的点心静态图片资源后，读取图片信息自动生成的。</p><p>这里敲一下黑板，在使用 require 函数引入静态图片资源时，图片的相对路径必须用字面常量表示的原因是，<strong>字面常量</strong><code>'./dianxin.jpg'</code><strong>提供的是一个直接的明确的图片相对路径</strong>，打包工具很容易根据字面常量<code>'./dianxin.jpg'</code> 找到真正的图片，提取图片信息。而变量<code>path</code> 提供的是一个间接的可变化的图片路径，你光看<code>require(path)</code> 这段代码是不知道真正的图片放在哪的，打包工具也一样，更别提自动提取图片信息了。</p><p>这里还需要注意一下，我们第一步“编译时”生成的图片注册函数和其注册的信息，我们在后面的第三步“运行时”还会用到。</p><p><strong>第二步构建</strong>：编译后的 Bundle 和静态图片资源，会在构建时内置到 App 中。</p><p>如果你搭建的是 iOS 原生环境，那么你应该运行 <code>react-native run-ios</code> 构建 iOS 应用。如果你搭建的是 Android 原生环境，那么你应该运行  <code>react-native run-android</code> 构建 Android 应用。</p><p>不过，默认构建的是调试包，而我们想要的是正式包，因此我们还需要在命令后面加一行配置<code>--configuration Release</code>。这样就能在你的真机或者模拟器上，构建出一个 React Native 应用了，具体命令如下：</p><pre><code class=\"language-plain\">$ npx react-native run-ios --configuration Release\n</code></pre><p>在这一步，编译后的 Bundle，包括 Bundle 中的静态图片资源信息，和真正的静态图片资源都已经内置到 App 中了。现在你可以关闭网络，然后打开 App试试，如果这时页面和图片依旧能正常展示，那就证明图片确实内置成功了。</p><p>实际上，上面的命令 <code>react-native run-ios</code> 既包括第一步的编译 <code>react-native bundle</code>又包括第二步的构建。在真正编译和构建内置时候，你只需要运行 <code>react-native run-ios</code>  即可。</p><p><strong>第三步运行</strong>：在运行时，require 引入的并不是静态图片资源本身，而是静态图片资源的信息。Image 元素要在获取到图片路径等信息后，才会按配置的规则加载和展示图片。</p><p>还记得吗？我们第一步“编译时”，生成了图片注册函数和其注册的信息，在第二步“构建时”，我们将真正图片内到了 App 中。那在第三步“运行时”，我们怎么拿到这些图片信息，并加载和展示真正的内置图片呢？</p><p>首先，你可以通过 Image.resolveAssetSource 方法来获取图片信息。具体的示例代码如下：</p><pre><code class=\"language-plain\">const dianxinIcon = require('./dianxin.jpg')\n\nalert(JSON.stringify(Image.resolveAssetSource(dianxinIcon)))\n\n// 弹出的信息如下：\n{\n    \"__packager_asset\": true,\n    \"httpServerLocation\": \"/assets/src/Lesson3Image\",\n    \"width\": 190,\n    \"height\": 190,\n    \"scales\": [1],\n    \"hash\": \"0d4ac32eb69529cf90a7b248fee00592\",\n    \"name\": \"dianxin\",\n    \"type\": \"jpg\"\n}\n</code></pre><p>这段代码很简单，关键代码只有两行，第一行是通过 require 引入点心图片，并将其赋值给变量 dianxinIcon。第二行是通过调用 Image.resolveAssetSource 方法，并传入点心图片变量 dianxinIcon，获取我们在编译时生成的图片信息。你可以通过 alert 字符串的方式，将它打印在屏幕上，现在你就可以在运行时，看到编译时自动生成的静态图片资源的信息了。</p><p>在 Image 组件底层，使用的就是 Image.resolveAssetSource 来获取图片信息的，包括图片目录（httpServerLocation）、宽高信息 （width 和 height）、图片哈希值（hash）、图片名字（dianxin）、图片格式（jpg），等等。然后，再根据这些图片信息，找到“构建时”内置在 App 中的静态图片资源，并将图片加载和显示的。这就是静态图片资源的加载原理。</p><p>正是因为静态图片资源加载方式，它在“编译时”提前获取了图片宽高等信息，在“构建时”内置了静态图片资源，因此在“运行时”，程序可以提前获取图片宽高和真正的图片资源。相对于我们后面要介绍的网络图片等加载方式，使用静态图片资源加载，即使不设置图片宽高，也有一个默认宽高来进行展示，而且加载速度更快。</p><h2>网络图片</h2><p>静态图片资源虽好，但它只适用于“静态不变的”图片资源，对于那些“动态变化的”和不方便内置的业务场景，那就要用到网络图片了。</p><p>网络图片（Network Images）指的是<strong>使用 http/https 网络请求</strong>加载远程图片的方式。</p><p>在使用网络图片时，我建议你<strong>将宽高属性作为一个必填项</strong>来处理。为什么呢？和前面介绍的静态图片资源不同的是，网络图片下载下来之前，React Native 是没法知道图片的宽高的，所以它只能用默认的 0 作为宽高。这个时候，如果你没有填写宽高属性，初始化默认宽高是 0，网络图片就展示不了。</p><p>具体的代码是这样：</p><pre><code class=\"language-plain\">// 建议\n&lt;Image source={{uri: 'https://reactjs.org/logo-og.png'}}\n       style={{width: 400, height: 400}} /&gt;\n\n// 不建议\n&lt;Image source={{uri: 'https://reactjs.org/logo-og.png'}} /&gt;\n</code></pre><h3>缓存与预加载</h3><p>不过，网络图片虽然指的是走网络请求下载的图片，但也并不用每次都走网络下载，只要有缓存就能直接从本地加载。所以这里我们也简单介绍一下 React Native 的缓存和预加载机制。</p><p>React Native Android 用的是 Fresco 第三方图片加载组件的缓存机制，iOS 用的是 NSURLCache 系统提供的缓存机制。</p><p>Android 和 iOS 的缓存设置方式和实现原理虽然有所不同，但整体上采用了内存和磁盘的综合缓存机制。第一次访问时，网络图片是先加载到内存中，然后再落盘存在磁盘中的。后续如果我们需要再次访问，图片就会从缓存中直接加载，除非超出了最大缓存的大小限制。</p><p>例如，iOS 的 NSURLCache 遵循的是 HTTP 的 Cache-Control 缓存策略，同时当 CDN 图片默认都已经设置了 Cache-Control 时，iOS 图片就是有缓存的。</p><p>而 NSURLCache 的默认最大内存缓存为 512kb，最大磁盘缓存为 10MB，如果缓存图片的体积超出了最大缓存的大小限制，那么一些老的缓存图片就会被删除。</p><p>图片缓存机制有什么用呢？</p><p><strong>通过图片缓存机制和预加载机制的配合，我们可以合理地利用缓存来提高图片加载速度，这能进一步地提升用户体验。</strong></p><p>使用图片预加载机制，可以提前把网络图片缓存到本地。对于用户来说，提前缓存的图片是第一次看到的，但对于系统缓存来说图片是第二次加载，它的加载速度是毫秒级的甚至亚秒级的。这就是预加载机制，提升图片加载性能的原理。</p><p>举个例子，你打算买个机械键盘，打开了个购物 App，滑动手机翻页选购，键盘图片和介绍都能马上地呈现出来。你没有感受丝毫的等待和卡顿，你可能就会直接下单买了。相反，如果你选购的过程中图片加载很慢，翻页还要等待很久，你就可能会考虑换个购物 App。</p><p>在这种无限滚动的长列表场景中，图片预加载就非常适合了。React Native 也提供了非常方便的图片预加载接口 Image.prefetch：</p><pre><code class=\"language-plain\">Image.prefetch(url);\n</code></pre><p>也就是说，函数 Image.prefetch 接收一个参数 url，也就是图片的远程地址，函数调用后，React Native 会帮你在后台进行下载和缓存图片。这样，你下拉加载的图片时，网络图片是从本地缓存中加载的，就感受不到网络加载的耗时过程了。</p><h2>宿主应用图片</h2><p>宿主应用图片（Images From Hybrid App’s Resources​）指的是 React Native 使用 <strong>Android/iOS 宿主应用的图片</strong>进行加载的方式。在 React Native 和 Android/iOS 混合应用中，也就是一部分是原生代码开发，一部分是 React Native 代码开发的情况下，你可能会用到这种加载方式。</p><p>使用 Android drawable 或 iOS asset 文件目录中的图片资源时，我们可以直接通过统一资源名称 URN（Uniform Resource Name）进行加载。不过，使用 Android asset 文件目录中图片资源时，我们需要在指定它的统一资源定位符 URL（Uniform Resource Locator）。</p><p>这里插个小知识，在 React Native 中，我们为什么要用 URI ，比如 <code>{ uri: 'app_icon' }</code>  ，来代表图片，而不是用更常用的 URL，比如 <code>{ url: 'app_icon' }</code> ， 代表图片呢？</p><p>这是因为，URI 代表的含义更广泛，它既包括 URN 这种用名称代表图片的方式，也包括用 URL 这种地址代表图片的方式。以 iOS 和 Android 宿主图片为例，代码如下：</p><pre><code class=\"language-plain\">// Android drawable 文件目录\n// iOS asset 文件目录\n&lt;Image source={{ uri: 'app_icon' }} /&gt;\n\n// Android asset 文件目录\n&lt;Image source={{ uri: 'asset:/app_icon.png' }} /&gt;\n</code></pre><p>你可以看到，iOS 宿主图片用的是图片名称 app_icon，是 URN。而 Android 宿主图片用的是图片位置 asset:/app_icon.png，是 URL。而 URI 的所代表的含义更广，既包括图片名称 URN，又包括图片位置 URL ，所以 Image 组件的 source 属性中，代表图片名称或地址的键名是 URI。</p><p>在我们国内，绝大多数的 React Native 应用都是混合应用，都是把 React Native 当做一个支持动态更新的跨端框架来使用的。那这种情况下，我们在 React Native 中直接用宿主应用图片资源不是更好吗？</p><p>你看，React Native 静态图片资源也是内置，Android/iOS 自身图片也要内置，搞一套图片管理机制不更简单一些嘛？而且部分图片还可以跨 React Native 和 Android/iOS 两个技术栈复用，减少一些 App 体积，这听起来很不错啊。</p><p><strong>但在实际工作中，我不推荐你在 React Native 中使用宿主应用图片资源。</strong>首先，这种加载图片的方法没有任何的安全检查，一不小心就容易引起线上报错。第二，大多数 React Native 是动态更新的，最新代码是跨多个版本运行的，而 Native 应用是发版更新的，应用的最新代码只在最新版本运行，这就导致 React Native 需要确切知道 Native 图片到底内置在哪些版本中，才能安全地使用，这对图片管理要求太高了，实现起来太麻烦了。</p><p>最后，开发 React Native 的团队，和开发 Android/iOS 的团队很可能不是一个团队，甚至可能跨部门。复用的收益抵不上复用带来的安全风险、维护成本和沟通成本，因此我并不推荐你使用。</p><h2>Base64 图片</h2><p>最后一类常见的 React Native 图片加载方式是 Base64 图片。</p><p>Base64 指的是一种基于 64 个可见字符表示二进制数据的方式，Base64 图片指的是<strong>使用 Base64 编码</strong>加载图片的方法，它适用于那些图片体积小的场景。</p><p>Base64 图片的示例代码，如下：</p><pre><code class=\"language-plain\">&lt;Image\n  source={{\n    uri: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg=='\n  }}\n/&gt;\n</code></pre><p>你可以看到 Base64 图片并不是图片地址，而是以一大长串的以 data:image/png; base64 开头的文本。</p><p>通常我们看的图片资源 .jpg、.png 都是二进制格式的，二进制格式的图片是以独立文件存在的。而当二进制图片 Base64 化后，就变成了一段由字母、数字和符号组成的字符串。</p><p>通常我们看的图片资源 .jpg、.png 都是二进制格式的，二进制格式的图片是以独立文件存在的。而 Base64 图片并不是单独图片文件，而是以文本形式存在 .js 文件中的。</p><p>字符串是可以嵌套到 .js 文件中的，因此 Base64 图片也可以嵌入到 .js 文件中。在线上，Base64 图片是嵌套在 Bundle 文件中的，在加载 React Native 页面的同时，Base64 字符串也能很快地解析成真正的图片，并展示出来。</p><p><strong>由于 Base64 图片是嵌套在 Bundle 文件中的，所以 Base64 图片的优点是无需额外的网络请求展示快，缺点是它会增大 Bundle 的体积。</strong> 在动态更新的 React Native 应用中，Base64 图片展示快是以 React Native 页面整体加载慢为代价的。原因就是它会增加 Bundle 的体积，增加 Bundle 的下载耗时，从而导致 React Native 页面展示变慢。</p><p>即便是相同的图片，Base64 字符串的体积也要比二进制字节码的体积要大 1/3，这又进一步增加 Bundle 的大小。那为什么 Base64 转换后的体积，会比二进制的字节码的体积还要大 1/3呢？这就要看下 Base64 图片的转换原理了。</p><p>我这里放了一张二进制图片转 Base64 图片的原理示意图，我们根据这张原理示意图来解释图片 Base64 后体积增加的原因。</p><p><img src=\"https://static001.geekbang.org/resource/image/40/5d/40301519cfd873a7779953c7e1e2d65d.jpg?wh=2008x488\" alt=\"\"></p><p>首先，我们要树立两个基本认知。一是二进制图片不能直接以字符串形式存在 .js 文件中，因为直接用 ASCII （美国信息交换标准代码）表示的二进制字符串太大了。一个二进制 “00000000”，占 8 比特大小，也就是 1 个字节的大小。一个直接用 ASCII 表示的字符串 “00000000”，占 8*8 比特大小，也就是 8 个字节的大小，是二进制大小的 8 倍。</p><p>二是，二进制图片不能直接以 ASCII 的格式转换为字符串，这是因为ASCII 字符集不仅存在可见字符，还存在不可见字符。例如，二进制 “00000000” 对应的 ASCII 字符是“空字符（Null）”，空字符是不可见字符。</p><p>但是，二进制图片可以借助 Base64 进行转换。Base64 从 ASCII 256 个字符中选取了 64 个可见字符作为基础，这样就二进制就能以 Base64 的格式转换为 ASCII 字符串了。例如，二进制 00000000 对应的 Base64 字符是 A，是可见字符，可见字符 A 是可以存在在 .js 文件中的。</p><p>需要注意的是，ASCII 256 个字符需要 8 个比特来表示（2^8=256），Base64 的 64 个字符只需要 6 个比特位来表示（2^6=64）。但实际上，Base64 字符也是以 ASCII 码的形式存在，因此这里就有 2 个比特的浪费（8-6=2）。</p><p>你可以再仔细观察一下前面我提供的 Base64 转换的原理示意图，相信你一下就能明白其中原理。Base64 以 3 个字节作为一组，一共是 24 比特。将这 24 个比特分成 4 个单元，每个单元 6 个比特。每个单元前面加 2 个 0 作为补位，一共 8 个比特，凑整 1 个字符。转换后原来的 24 比特，就变成了 32 比特，因此转换后的体积就大了 1/3（ 1/3 = 1 - 24/32）。</p><p>鉴于这样的情况，我的建议是 <strong>Base64 图片只适合用在体积小的图片或关键的图片上。</strong></p><h2>最佳实践</h2><p>看到这里，想必现在你已经对 4 类图片的使用场景，有一定的了解了。但是在具体实践中，我们应该怎么用呢？</p><p>现在我给你分享一下我的最佳实践，这套方案我也是在实践中，摸索了很久才得出的。这套最佳实践，适用于那些<strong>将 React Native 当做一个动态更新框架来使用的应用</strong>中。</p><p>首先是静态图片资源。如果你使用的是自研的热更新平台，就需要注意图片资源一定要先于 bundle 或和 bundle 一起下发，因为在执行 bundle 时，图片资源是必须已经存在的。</p><p>接着是网络图片和 Base64 图片。这两类图片之所以放在一起说，是因为它们单独管理起来都不方便，一张张手动上传网络图片不方便，一张张手动把图片  Base64 化也不方便，所以我们需要一个自动化的工具来管理它们。</p><p>比如，你可以把需要上传到网络的图片放在代码仓库的 assets/network 目录，把需要 Base64 化的图片放在 assets/base64 目录。</p><p>你在本地开发的时候，可以通过使用 require 静态图片资源的形式，引入 assets/network 或 assets/base64 目录中的图片来进行本地调试。在代码编译打包的时候，通过工具将 assets/network 目录中的图片上传到 CDN 上，将 assets/base64 目录中的图片都 Base64 化，并将 require 形式的静态图片资源代码转换为网络图片或 Base64 图片的代码。使用自动化工具来管理图片，代替人工手动管理，可以提高你的开发效率。</p><p>最后是宿主应用图片，这种加载图片的方式我不建议你使用，具体的原因我们前面已经分析过了。</p><p>我把这节课讲的这四种图片的使用总结成了这张图，你可以看看，加深一下印象：</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/2f/1ea50c116cf01334b75bc9a4cfd9162f.png?wh=1188x492\" alt=\"图片\"></p><h2>总结</h2><p>今天的课程到这里就结束了，这里我再给你总结一下。</p><p>今天我们学习 React Native 中的图片组件 Image，了解了 4 种图片加载的方式和其最佳实践。</p><p>首先，发版更新的 React Native 应用，使用内置图片的最佳方式是静态图片资源，但对于动态更新的 React Native 应用而言，需要注意静态图片资源并不是真正的“内置”，而是必须和 Bundle 执行文件“同步”的加载。</p><p>然后，我推荐你自研一个图片管理工具，把设计师给你的图片管理起来，并按照指定的配置规则转换为 Base64 图片或网络图片，这样可以提高你的开发效率。</p><p>不过，React Native 复用宿主应用图片的这种方式，不推荐你使用。它有加载失败的风险，而且有较高的维护成本和沟通成本。</p><h2>补充材料</h2><ol>\n<li>各类图片使用区别的 <a href=\"https://reactnative.cn/docs/0.63/images\">React Native 中文网连接在这儿</a>，你可以点击查看一下。</li>\n<li>React Native 框架对图片的默认缓存处理并不是最优的方案，社区中提供了替代方案 <a href=\"https://github.com/DylanVann/react-native-fast-image\">FastImage</a>，它是基于 SDWebImage (iOS) 和 Glide (Android) 实现的性能和效果会更好一些。</li>\n<li>这节课的示例代码，我放在了<a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/05_Image\"> GitHub </a>上，你可以参考一下。</li>\n</ol><h2>作业</h2><ol>\n<li>请你分别实现一下静态图片资源、网络图片和Base64 图片这三类图片。体会一下，是否有资源管理上改进空间？</li>\n<li>如果要你来实现图片管理工具，你会怎么实现？</li>\n</ol><p>欢迎在留言区分享你的想法。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"04｜State：如何让页面“动”起来？","id":503115},"right":{"article_title":"06｜Pressable：如何实现一个体验好的点按组件？","id":504527}}},{"article_id":504527,"article_title":"06｜Pressable：如何实现一个体验好的点按组件？","article_content":"<p>你好，我是蒋宏伟。</p><p>点按组件的设计与我们的用户体验息息相关。有人会因为机械键盘的敲击感好，不买百来块的薄膜键盘，而花上贵十倍的价格去买 HHKB、Filco，也有人会因为某个应用的点按体验不好，而转投竞品应用。</p><p>如果你仔细观察过世界上那些流行的、口碑很好 App，比如微信，你会看到它们在点按组件的体验的细节上都做得特别好。</p><p>比如，微信的点按组件都是有交互反馈的，无论是背景颜色的加深，还是那些舒服的震动，又或者是动画。又比如，微信顶部右上角的加号按钮是很容易点击的，它的点击区域是比显示图标大上那么一丢丢，而且点到后，即使把手指挪开图标的位置再松开也是能触发点击的。</p><p>所有的这些设计都是“懂”用户的。担心你因为网络卡、机器卡不知道有没有自己点中，在你点完后给你视觉或触觉上的反馈；担心你走路的时候想点点不到，把事件的“可触发区域”、“可保留区域 ”设置得比视觉上的“可见区域”大上那么一些。</p><p>作为直接和用户打交道的工程师，<strong>我们也得“懂”用户，</strong>也得去优化我们负责的 App、页面的体验，<strong>还得在技术上搞懂点按组件使用方法和背后的原理，把这种最常用的人机交互体验给做到及格，做到优秀。</strong></p><p>所以，今天这节课，我会以三个问题为脉络进行讲解：</p><!-- [[[read_end]]] --><ul>\n<li>点按组件是要简单易用还是要功能丰富，如何取舍？</li>\n<li>点按组件是如何知道它是被点击了，还是被长按了？</li>\n<li>点按组件为什么还要支持用户中途取消点击？</li>\n</ul><p>通过这三个问题，你不仅能明白如何在 React Native 中实现一个体验好的点按组件，同时也能借助它背后的设计原理，更“懂”用户，提升产品的用户体验。</p><h2>要简单易用还是功能丰富？</h2><p>首先，点按组件是设计给你我这样的开发者来使用的，它功能越简单开发者用起来就越简单，它功能越复杂就能满足更多的需求场景。那是让开发者简单易用好，还是用丰富的功能去满足用户，有没有两全其美之计？</p><p>实际上，React Native 的点按组件经历了三个版本的迭代，才找到了两全其美的答案。等你了解了这个三个版本的迭代思路后，你就能很好明白优秀通用组件应该如何设计，才能同时在用户体验 UX 和开发者体验 DX 上找到平衡。</p><p>我先给你从第一代点按组件开始讲起。</p><h3>第一代 Touchable 组件</h3><p>第一代点按组件想要解决的核心问题是，<strong>提过多种反馈风格</strong>。</p><p>一个体验好的点按组件，需要在用户点按后进行实时地反馈，通过视觉变化等形式，告诉用户点到了什么，现在的点击状态又是什么。</p><p>但不同的原生平台，有不同的风格，反馈样式也不同。Android 按钮点击后会有涟漪，iOS 按钮点击后会降低透明度或者加深背景色。React Native 是跨平台的，那它应该如何支持多种平台的多种反馈风格呢？</p><p>第一代 Touchable 点按组件的设计思路是，提供多种原生平台的反馈风格给开发者自己选择。框架提供了 1 个基类和 4 个扩展类，它们分别是：</p><ul>\n<li>TouchableWithoutFeedback：用于响应用户的点按操作，但不给出任何点按反馈效果。反馈效果由 4 个扩展类实现；</li>\n<li>TouchableNativeFeedback：给出当前原生平台的点按反馈效果，在 Android 中是涟漪（ripple）效果，就是从点击处散开水波纹的效果；</li>\n<li>TouchableOpacity：短暂地改变组件的透明度；</li>\n<li>TouchableHighlight：短暂地加深组件的背景色；</li>\n<li>TouchableBounce：有 bounce 回弹动画的响应效果。</li>\n</ul><p>Touchable 点按组件提供了 5 个类，选择起来也很麻烦。有经验的开发者可能知道如何进行选择，但新手却要花上很长时间，去了解不同组件之间的区别。所以说，Touchable 点按组件在提供多样性的功能支持的同时，也带来了额外的学习成本。</p><p>为了降低学习成本，React Native 团队又开发了第二代点按组件，Button。</p><h3>第二代 Button 组件</h3><p>第二代 Button 组件的实质是<strong>对 Touchable 组件的封装。</strong>在 Android 上是 TouchableNativeFeedback 组件，在 iOS 上是 TouchableOpacity 组件。</p><p>Button 组件的设计思想就是，别让开发者纠结选啥组件了，框架已经选好了，点按反馈的样式就和原生平台的自身风格保持统一就好了。</p><p>但我的经验告诉我，要让大多数开发者都选择同一个默认的 UI 样式真是太难了，萝卜白菜各有所爱。另外，用户的审美也在慢慢地变化，涟漪风格也好，降低透明风格也好，背景高亮风格也好，或许几年后就不会再流行了。甚至连 Button 这个概念本身，都在慢慢地变化，现在的 App 中几乎只要是个图片或者文字都能点按，不再局限于只有四四方方的色块才能点按了。</p><p>Button 组件虽然降低了开发者选择成本，但是想在 UI 风格上让大家选择都原生平台自身的风格，这太难了。因此，React Native 团队又开发了第三代点按组件 Pressable。</p><h3>第三代 Pressable 组件</h3><p>第三代 Pressable 点按组件，不再是 Touchable 组件的封装，而是<strong>一个全新重构的点按组件，</strong>它的反馈效果可由开发者自行配置。</p><p>但是，点按组件通常是有点击和未点击两种状态的，这两种状态对应着两种点按样式，一种样式是未点击时的基础样式，一种是点按后的反馈样式。这两种样式怎么写？又该怎么切换？</p><p>Pressable 组件的 API 设计得很是巧妙，扩展起来非常方便。Pressable 的样式 style 属性同时支持固定样式，和函数返回的“动态样式”：</p><pre><code class=\"language-typescript\">type PressableStyle = ViewStyle | (({ pressed: boolean }) =&gt; ViewStyle)\n</code></pre><p>其一，固定样式，也就是<code>type PressableStyle = ViewStyle</code> 的意思是，Pressable 组件的支持样式类型和 View 组件的支持样式类型是一样的，具体 <code>ViewStyle</code> 都包括那些“通用”样式和“私有”样式，我们在<a href=\"https://time.geekbang.org/column/article/501650\">《Style》</a>中已经学过了，相信你能很快回想起来。</p><p>其二，动态样式，也就是<code>type PressableStyle = (({ pressed: boolean }) =&gt; ViewStyle)</code> 的意思是，在用户没有点击时 pressed 值为 false，在用户点击时 pressed 值为 true，你可以根据两种点按状态，为按钮定制不同的样式。</p><p>具体怎么实现呢？我们先来看固定样式。固定样式，顾名思义，就是按钮组件的样式是“固定”的，比如你可以看下这段代码：</p><pre><code class=\"language-plain\">// 固定的基础样式\nconst baseStyle = { width: 50, height: 50, backgroundColor: 'red'}\n\n&lt;Pressable\n  onPress={handlePress}\n  style={baseStyle} &gt;\n  &lt;Text&gt;按钮&lt;/Text&gt;\n&lt;/Pressable&gt;\n</code></pre><p>这段示例代码就是一个最简单的固定样式按钮的代码片段。我们在 Pressable 元素中嵌套了一个文字是“按钮”的 Text 元素，并给 Pressable 元素添加了一个固定的基础样式，宽高各位 50 像素，且背景颜色为红色。</p><p>那如果我们需要实现动态样式，应该怎么实现呢？比如，你想在所有平台都实现降低透明度的点击反馈，那你可以定义一个基础样式 baseStyle，然后通过点按状态 pressed ，管理透明度 opacity 的切换。具体的代码示例如下：</p><pre><code class=\"language-plain\">// 固定的基础样式\nconst baseStyle = { width: 50, height: 50, backgroundColor: 'red'}\n\n&lt;Pressable\n  onPress={handlePress}\n  style={({ pressed }) =&gt; [ /* 动态样式 */\n    baseStyle,\n    { opacity: pressed ? 0.5 : 1} \n  ]} &gt;\n  &lt;Text&gt;按钮&lt;/Text&gt;\n&lt;/Pressable&gt;\n</code></pre><p>这段示例代码用的就是 Pressable 的动态样式。首次渲染时，React Native 会先调用一次 Pressable 的 style 属性的回调函数，这时点按状态 pressed 是 false，透明度为 1。在你触碰到“按钮”时，就会触发点击事件 onPress，与此同时，React Native 会再调用一次 style 属性的回调函数，此时点按状态 pressed 是 true，透明度为 0.5。在你松开“按钮”后，透明度会重新变为 1。</p><p>你可以看到，使用动态样式来实现降低透明度的点击反馈是非常方便的。除了改变透明度，你还可以选择改变背景色，改变按钮的宽高，甚至还可以把“按钮”的文字改了。你看，动态样式是不是非常灵活？</p><p>除了这两点，你可能还会问，如果我想实现 Android 平台特有的涟漪效果，Pressable 组件也能实现吗？可以，你可以使用android_ripple和android_disableSound 属性进行配置。</p><ul>\n<li>android_ripple：用于配置 Android 特有的涟漪效果 <a href=\"https://reactnative.dev/docs/next/pressable#rippleconfig\">RippleConfig</a> ；</li>\n<li>android_disableSound：禁用 Android 系统的点击音效，默认 false 不禁用。</li>\n</ul><p>其实，目前这三代点按组件是同时存在于 React Native 的官方组件库中的，那开发时我们该怎么选呢？我认为：</p><ul>\n<li>第一代点按组件 Touchable，功能丰富但学习成本太高；</li>\n<li>第二代点按组件 Button，简单易用但带了默认样式和反馈效果，通用性太差；</li>\n<li>第三代点按组件 Pressable，同时满足了简单易用和复杂效果可扩展的特性。</li>\n</ul><p>因此，在实现自定义的业务按钮组件时，我更加推荐你使用第三代点按组件 Pressable。而且，Pressable 组件的动态 style 的设计思路，也是非常值得我们学习的。</p><h2>如何知道是点击，还是长按？</h2><p>我们再来看第二个问题：点按组件 Pressable 是如何知道它是被点击了，还是被长按了？</p><p>整个点按事件的响应过程是硬件和软件相互配合的过程。 Pressable 组件响应的整体流程，是从触摸屏识别物理手势开始，到系统和框架 Native 部分把物理手势转换为 JavaScript 手势事件，再到框架 JavaScript 部分确定响应手势的组件，最后到 Pressable 组件确定是点击还是长按。</p><p>你看，一个 App 要识别是点击还是长按，并没有那么容易吧？庆幸的是，这些复杂的识别工作都由手机硬件、操作系统、React Native 框架帮我们实现了。作为开发者，大部分时候我们只需要知道怎么使用和了解基本原理就可以了。今天我们把焦点放在最后一步，Pressable 组件是怎么确定用户是点击还是长按的。</p><p>我们知道，开始响应事件和结束响应事件是两个最基础的手势事件，在 Android、iOS 或者 Web 中都有类似的事件。在 React Native 中它们是：</p><ul>\n<li>onResponderGrant：开始响应事件，用户手指接触屏幕，且该手势被当前组件锁定后触发；</li>\n<li>onResponderRelease：结束响应事件，用户手指离开屏幕时触发。</li>\n</ul><p>基于开始响应事件 onResponderGrant 和结束响应事件 onResponderRelease，Pressable 组件可以很容易地封装出开始点按事件 onPressIn 和结束点按事件 onPressOut。</p><p>你可以在 Pressable 组件中，使用 onPressIn 来响应开始点按事件，使用 onPressOut 来响应结束点按事件。示例代码如下：</p><pre><code class=\"language-plain\">&lt;Pressable \n  onPressIn={handlePressIn}\n  onPressOut={handlePressOut}\n  &gt;\n  &lt;Text&gt;按钮&lt;/Text&gt;\n&lt;/Pressable&gt;\n</code></pre><p>当你触碰到“按钮”开始点按时，React Native 框架就会帮你调用 handlePressIn 处理函数，当你手指离开“按钮”结束点按时，就会调用 handlePressOut 处理函数。</p><p>基于开始点按事件 onPressIn 和结束点按事件 onPressOut，我们自己是否可以封装出“自定义”的点击事件 onPress 和长按事件 onLongPress呢？你可以短暂的按一下暂停键，思考一下如果要要你来实现你会怎么做，然后再去看 React Native 框架提供的答案。</p><p>这个方案也很简单，你只需要判断 onPressIn 事件和 onPressOut 事件之间触发间隔耗时就可以了：</p><ul>\n<li>如果间隔耗时 &lt; 500ms 属于点击。用户的点按动作会先触发 onPressIn，再触发 onPressOut，在 onPressOut 事件中可以触发我们 “自定义的”点击事件 onPress；</li>\n<li>如果间隔耗时 &gt;= 500ms 属于长按。用户的点按动作会先触发 onPressIn，这个时候你可以埋下一个定时器，并在第 500ms 时通过定时器触发我们 “自定义的” onLongPress，最后在用户松手的时候触发 onPressOut。</li>\n</ul><p>实际上，React Native 框架就是这么设计的。</p><p>在你同时监听了 onPress 和 onLongPress 两个事件时，如果点按耗时小于 500ms，在你松手时触发的是点击事件 onPress；如果点按耗时大于 500ms，大致会在第 500ms 先触发长按事件 onLongPress，那这时即使你再松手也不会触发 onPress 事件了。也就是说，<strong>点击事件 onPress 和长按事件 onLongPress 是互斥的，触发了一个就不会再触发另一个了</strong>。</p><p>关于 Pressable 组件的 4 个响应事件，onPressIn、onPressOut 、onPress 和 onLongPress的触发方式，我放了一张官方提供的示意图，相信你看后会有更深的理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/69/5b058a1a8ac8f14ff3b8f6b726a28669.png?wh=1920x1272\" alt=\"图片\"></p><h2>为什么支持中途取消？</h2><p>现在，你对 Pressable 组件的点按事件的工作原理已经有所了解了。讲到这里，我们开头提出的三个问题，只剩最后一个：点按组件为什么还要支持用户中途取消点击？</p><p>要讲清楚这个问题，我们需要深入到事件区域模型，也就是点按操作手势的可用范围的概念下进行讲解。</p><p>点按操作手势的可用范围包括盒模型区域、可触发区域 HitRect 和可保留区域 PressRect ，接下来我们一个个讲解。</p><h3>盒模型区域</h3><p>还记得吗？在我们介绍<a href=\"https://time.geekbang.org/column/article/501650\">《Style》</a>的布局属性时，我们有提到过宽度 width、高度 height，这两个属性就决定了盒模型（Box Modal）中的内容 content 大小。除此之外，盒模型中还有内边距 padding、边框 border、外边距 margin。</p><p>这些内容、边框、边距之间关系是什么呢？其实，React Native 中的盒模型概念来自于 Web 领域的 W3C 规范，我把规范中的盒模型示意图放在了下面：</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/7e/c2a39b421c9f21bfd34ff0def3494f7e.jpg?wh=455x340\" alt=\"\"></p><p>你可以看到，最里面的是内容 Content，然后再是 Padding 和 Border，最外面的才是 Margin。请你注意了，Content、Padding、Border 默认是不透明度的，但 Margin 是天生透明的，并且不可以设置透明度、设置颜色。</p><p>你猜，点按事件的默认触发区域是盒模型中的哪几部分？答案就是，盒模型中的默认不透明的部分。这些用户看得见的部分，包括 content、padding 和 border 部分。可以看得见才可以点击，这样的设计是非常合理的。</p><p>我给你贴出了点按事件的默认触发区域的测试代码，你也可以自己点一点、试一试，体会一下：</p><pre><code class=\"language-plain\">&lt;Pressable style={{\n    margin: 10,\n    borderWidth: 10,\n    borderColor: 'red',\n    padding: 10,\n    width: 100,\n    height: 100,\n    backgroundColor: 'orange',\n  }}&gt;\n  &lt;Text&gt;点我&lt;/Text&gt;\n&lt;/Pressable&gt;\n</code></pre><p>在上面的示例代码中，我们特意给了 100 像素的宽高，这是很容易点中的，但在日常我们使用 App 时，并不会有这么大按钮。你也许遇到过类似的情景，单手把持手机的时候左上角的返回键老点不中，勾选用户同意事项的时候老勾不中，等等。人的手指并不是什么精密仪器，不能保证任何情况下都能正确地点按到指定区域。那这种情况该怎么处理呢？</p><p>我们可以直接修改宽高、边框、内边距的值，通过扩大盒模型的范围，提高点中的成功率。但是，修改盒模型成本较高，它可能会导致原有 UI 布局发生变化。</p><p><strong>更好的方案是，不修改影响布局的盒模型，直接修改可触发区域的范围，提高点中的成功率。</strong></p><h3>可触发区域 HitRect</h3><p>Pressable 组件有一个可触发区域 HitRect，默认情况下，可触发区域 HitRect 就是盒模型中的不透明的可见区域。你可以通过修改 hitSlop 的值，直接扩大可触发区域。</p><p>HitSlop 类型的定义如下：</p><pre><code class=\"language-typescript\">type Rect = {\n    top?: number;\n    bottom?: number;\n    left?: number;\n    right?: number;\n}\n\ntype HitSlop = Rect | number\n</code></pre><p>HitSlop 接收两种类型的参数，一种是 number 类型，以原有盒模型中的 border 为边界，将可触发区域向外扩大一段距离。另一种是 Rect 类型，你可以更加精准地定义，要扩大的上下左右的距离。</p><p>在老点不中、老勾不中的场景中，你可以在不改变布局的前提下，设置 Pressable 组件的可触发区域 HitSlop，让可点击区域多个 10 像素、20 像素，让用户的更容易点中。</p><h3>可保留区域 PressRect</h3><p>前面我讲到，用户的手势可能会有一定误差。不仅如此，用户的行为本身就很复杂，用户的意愿也可能会在很短的时间内发生改变的。其实，这里也是在回答开头我们提出的最后一个问题，用户行为的复杂性，就导致了我们在设计点按组件需要有更多的思考。</p><p>比如，用户已经点到购买按钮了，突然犹豫，又不想买了，于是将手指从按钮区域移开了。这时你得让用户能够反悔，能够取消即将触发的点击操作。</p><p>这里我们就要引入一个新的概念：可保留区域 PressRect。点按事件可保留区域的偏移量（Press Retention Offset）默认是 0，也就是说默认情况下可见区域就是可保留区域。你可以通过设置 pressRetentionOffset 属性，来扩大可保留区域 PressRect。pressRetentionOffset 属性的类型如下：</p><pre><code class=\"language-typescript\">type PressRetentionOffset  = Rect | number\n</code></pre><p>你可以看到，pressRetentionOffset 和 HitSlop 一样，接收两种类型的参数，一种是 number 类型，另一种是 Rect 类型。Rect类型设置后，会以原有可触发区域为基准，将可保留区域向外扩大一段距离。</p><p>在你后悔点下购买按钮的情况下，你可以把已经按下的手指从可保留区域挪开，然后再松手，这就不会再继续触发点击事件了。</p><p>当然，还有更复杂的情况，你已经点到购买按钮了，突然犹豫，开始进行心理博弈，想点又不想点。手指从按钮上挪开了，又挪了进去，然后又挪开了，如此反复。这时还要不要触发点击事件呢？要不要触发，其实是根据你手指松开的位置来判断的，如果你松手的位置在可保留区域内那就要触发，如果不是那就不触发。</p><p>我将盒模型区域的可见区域、可触发区域 HitRect 和可保留区域 PressRect 的关系画了一张图，你也可以打开文稿看看，加深一下理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/27/a916a2b7ba515895ce76097b04c73727.png?wh=1920x1102\" alt=\"图片\"></p><h2>课程小结</h2><p>以上就是我们这一讲的全部内容，现在我来给你总结一下今天这一讲的要点。如何实现一个体验好的点按组件呢？我建议你记住下面这三点：</p><p>首先，一个好的点按组件应该让先让开发者用来很方便。React Native 的点按组件经历了三次迭代，每次迭代都在开发者体验（DX）上有所进步，我更推荐你使用第三代点按组件 Pressable。</p><p>其次，一个好的点按组件应该要满足各种用户、各种场景的可扩展性。Pressable 组件支持四种基础点按事件，onPressIn、onPressOut、onPress、onLongPress。其中，点击事件 onPress 和长按事件 onLongPress 是互斥的，触发了一个就不会再触发另一个了。</p><p>最后，一个优秀的工程师应该要“懂”用户，要把自己负责的 App、页面的用户体验（UX）提上去。任何的物理按钮都是有点击反馈的，我们的虚拟按钮也得有，这是最基本体验要求。然后，要让用户想点能点得到，要理解盒模型区域、可触发区域 HitRect、可保留区域 PressRect 的区别，并且进行合理设置。</p><h2>补充材料</h2><p><strong>官方文档：</strong></p><ul>\n<li>TouchableHighlight：<a href=\"https://reactnative.dev/docs/next/touchablehighlight\">https://reactnative.dev/docs/next/touchablehighlight</a></li>\n<li>Button：<a href=\"https://reactnative.dev/docs/next/button\">https://reactnative.dev/docs/next/button</a></li>\n<li>Pressable：<a href=\"https://reactnative.dev/docs/next/pressable\">https://reactnative.dev/docs/next/pressable</a></li>\n</ul><p><strong>源码阅读：</strong></p><ul>\n<li>要读懂点按组件 Pressable 的核心设计原理，首先要读懂 Pressable 设计者的设计思想，<a href=\"https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/Pressability/Pressability.js#L322-L366\">它放在了 Pressability.js  文件中。</a></li>\n<li>点按组件 Pressable 的 4 种基础响应事件是基于<a href=\"https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/Pressability/Pressability.js#L444-L544\">手势系统</a>实现的，其中 <a href=\"https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/Pressability/Pressability.js#L692-L702\">onPress 和 onLongPress 是互斥的。</a></li>\n</ul><h2>作业</h2><ol>\n<li>请你模仿实现一下微信顶部右上角的加号按钮。</li>\n<li>在较老版本的手机浏览器中，点击事件存在 350ms 延迟；在微信聊天框中，点击对方的微信头像比点击右上角三个点的更多按钮，打开页面的速度慢一些；双击事件是常见的点按事件之一，Pressable 组件却没有提供；这三个现象涉及到了 Web、Android、iOS 和 React Native 这四个技术领域，但这三个现象其实都指向同一个答案。欢迎你把你的答案分享给大家。</li>\n</ol><p>我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"05｜Image：选择适合你的图片加载方式","id":503636},"right":{"article_title":"07｜TextInput：如何实现一个体验好的输入框？","id":505780}}},{"article_id":505780,"article_title":"07｜TextInput：如何实现一个体验好的输入框？","article_content":"<p>你好，我是蒋宏伟。</p><p>上一讲，我们介绍了如何去打磨点按组件的体验细节，这一讲我们就开始介绍如何打磨一个文本输入组件 TextInput 的体验细节。</p><p>作为一个优秀工程师，要想优化页面的用户体验，只知道打磨点按组件是远远不够的，而且，相对于点按组件组件来说，要把文本输入组件 TextInput 的细节体验弄好，要更难一些。</p><p>这个难点主要有两方面。首先，TextInput 组件是自带状态的宿主组件。TextInput 输入框中的文字状态、光标状态、焦点状态在 React Native 的 JavaScript 框架层的框架层有一份，在 Native 的还有一份，有时候业务代码中还有一份。那多份状态到底以谁为主呢？这件事我们得搞清楚。</p><p>其次，TextInput 组件和键盘是联动的，在处理好 TextInput 组件的同时，我们还得关心一下键盘。当然键盘本身是有 <code>Keyboard</code> API 的，但是键盘类型是“普通键盘”还是“纯数字键盘”，或者键盘右下角的按钮文字是“确定”还是“搜索”，都是由 TextInput 组件控制的。</p><p>这一讲，我将以如何实现一个体验好的输入框为线索，和你介绍使用 TextInput 组件应该知道的三件事。</p><h2>输入框的文字</h2><p>第一件事，你得知道如何处理输入框的文字。</p><!-- [[[read_end]]] --><p>关于如何处理输入框的文字，网上有两种说法。有些人倾向于使用非受控组件来处理，他们认为“不应该使用 useState 去控制 TextInput 的文字状态”，因为 ref 方案更加简单；有些人倾向于使用受控组件来处理，这些人认为“直接使用 ref 去操作宿主组件这太黑科技了”。这两种说法是相互矛盾的，究竟哪种是正确的呢？</p><p>我们先从最简单的<strong>非受控（Uncontrolled）组件</strong>说起。</p><p>非受控的意思就是不使用 state，直接对从宿主组件上将文本的值同步到 JavaScript。一个非受控的 UncontrolledTextInput 组件示例如下：</p><pre><code class=\"language-plain\">const UncontrolledTextInput = () =&gt; &lt;TextInput /&gt; \n</code></pre><p>只要这一行代码，用户就可以输入文字了。在 UncontrolledTextInput  组件中， TextInput 元素是不受 state 控制，但在 JavaScript 代码中却并不知道用户输入的是什么，因此还要一个变量来存储用户输入的值。</p><p>用什么变量呢？首先在组件中声明局部变量是不行的，我们知道 render 就是组件函数的执行，每次执行局部变量也会重新赋值，局部变量保存的值不能跨越两次 render。其次，用全局变量或文件作用域的变量也是不行的，组件销毁时这些全局变量是不会销毁的，有内存泄露的风险。再者，用 state 也是不行的，用了 state 就成了受控组件了。</p><p>对于非受控组件来说，存储跨域两次 render 的可行方案是 ref。<strong>ref 的值不会因为组件刷新而重新声明，它是专门用来存储组件级别的信息的。</strong><a href=\"https://beta.reactjs.org/learn/referencing-values-with-refs#when-to-use-refs\">React 官方推荐</a>有三种场景我们可以用它：</p><ul>\n<li>存储 setTimeout/setInterval 的 ID；</li>\n<li>存储和操作宿主组件（在 Web 中是 DOM 元素）；</li>\n<li>存储其他不会参与 JSX 计算的对象。</li>\n</ul><p>我们使用 ref 保存非受控输入框的值，就属于第三种场景，示例代码如下：</p><pre><code class=\"language-plain\">function UncontrolledTextInput2() {\n  const textRef = React.useRef('');\n  return &lt;TextInput onChangeText={text =&gt; textRef.current = text}/&gt;\n}\n</code></pre><p>你看，首先我们使用 <code>useRef</code> 创建了一个用于保存用户输入的文字的对象 <code>textRef</code>。每当用户输入文字的时候，会触发 TextInput 的<code>onChangeText</code>事件，在该事件的回调中，我们将最新的<code>text</code>赋值给了<code>textRef.current</code>进行保存。这时，每次获取文字就都是最新的文字了。</p><p>非受控组件的原理是最简单的，用户输入的“文本原件”是存在宿主组件上的，JavaScript 中的只是用<code>textRef</code>复制了一份 “文本的副本”而已。</p><p>但正是因为非受控组件使用的是副本，一些复杂的操作是做不了的，比如将用户输入的字母由大写强制改为小写，等等。在新架构 Fabric 之前，React Native 还提供了直接修改宿主组件属性的<code>setNativeProps</code>方法，但是 Fabric 之后（包括 Fabric 预览版），<code>setNativeProps</code> 就不能用了。</p><p>因此我们要操作文本原件，必须得用<strong>受控（Controlled）组件</strong>。</p><p>受控的意思说的是使用 JavaScript 中的 state 去控制宿主组件中的值。一个受控的 ControlledTextInput 组件示例如下：</p><pre><code class=\"language-plain\">function ControlledTextInput() {\n  const [text, setText] = React.useState('');\n  return  &lt;TextInput value={text} onChangeText={setText} /&gt;\n}\n</code></pre><p>在这个示例中，我们先使用了 <code>useState</code> 创建了一个状态 <code>text</code> 和状态更新函数<code>setText</code>，并将状态<code>text</code>赋值给了 TextInput 的属性 <code>value</code>，<code>value</code> 是控制 TextInput 宿主组件展示的值用的。在用户输入文字后，会触发 onChangeText 事件，这时就会调用 <code>setText</code>，将状态 <code>text</code> 更新为用户最新输入的值。</p><p>那受控组件和非受控组件有什么区别呢？我把它们之间的实现原理画了一张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/76/a9/7621791793d0d73030124e472f9117a9.png?wh=1920x672\" alt=\"图片\"></p><p>你看，对于非受控组件来说，用户输入文字和文字展示到屏幕的过程，全部都是在宿主应用层面进行的，JavaScript 业务代码是没有参与的。</p><p>然而，对于受控组件来说，用户输入文字和文字展示这两步，依旧是在宿主应用层面进行的。但后续 JavaScript 业务代码也参与进去了，业务代码依次执行了 onChangeText 函数、setText 函数、controlledTextInput 函数，并且再次更新了展示值。</p><p>也就是说，受控组件更新了两次展示的值，只是因为两次展示的值是一样的，用户看不出来而已。对于受控组件而言，即便存在系统或 Native 修改文本的情况，在 TextInput 的底层，也会将其强制更新为当前 TextInput 的 value 属性值。所以对于受控组件来说，输入框的文字始终是由 state 驱动的。</p><p>更新两次的好处在于，可以更加自由地控制输入的文本，比如语音输入文字、通过地图定位填写详细地址。这些复杂场景下，用户既可以自由输入文字，也可以引入程序参与进来。而非受控组件只适用于用户自由输入的场景。</p><p>不过，你可能会对更新两次有性能上的担忧。我也写了两个极限情况下的 demo，模拟了文字改变事件中需要处理 1s 任务，并且分别试了 onChangeText 的异步更新，和新架构提供的 unstable_onChangeSync 同步更新：</p><pre><code class=\"language-plain\">&lt;TextInput\n  onChangeText={text =&gt; {\n    const time = Date.now();\n    while (Date.now() - time &lt;= 1000) {}\n    setText(text);\n  }}\n/&gt;\n&lt;TextInput\n  unstable_onChangeSync={event =&gt; {\n    const text = event.nativeEvent.text;\n    const time = Date.now();\n    while (Date.now() - time &lt;= 1000) {}\n    setText(text);\n  }}\n/&gt;\n</code></pre><p>异步更新情况下，JavaScript 线程和 UI 主线程是独立运行的，此时即便 JavaScript 线程卡了 1s，主线程依旧可以正常输入文字。但同步更新的情况下，从输入文字到展示文字会有 1s 的延迟， JavaScript 线程有 1s 的阻塞，UI 主线程也会卡死 1s。</p><p>当然，大多数情况下处理文字改变事件肯定用不了 1s，甚至用不了 1ms。模拟极限情况，只是为了说明新架构的同步和异步是可选的，如果你担心性能问题，用异步就好了。</p><p>现在如果要我给个处理输入框的文本建议，那我的建议就是<strong>使用受控组件，并且使用异步的文字改变事件</strong>，这也符合大部分人的代码习惯。</p><h2>输入框的焦点</h2><p>你需要关注的第二件事是，如何控制输入框的焦点。通常光标放置在哪个输入框上，那个输入框就是页面的唯一焦点。</p><p>有些场景下，输入框的焦点是程序自动控制的，无需开发者处理。比如用户点击手机屏幕上的输入框，此时焦点和光标都会移到输入框上。</p><p>有些场景下，是需要代码介入控制焦点的。比如你购物搜索商品，从首页跳到搜索页时，搜索页的焦点就是用代码控制的。或者你在填写收货地址时，为了让你少点几次输入框，当你按下键盘的下一项按钮时，焦点就会从当前输入框自动转移到下一个输入框。</p><p>我们先来看怎么实现自动“对焦”，以搜索页的搜索输入框自动对焦为例，示例代码如下：</p><pre><code class=\"language-plain\">&lt;TextInput autoFocus/&gt;\n</code></pre><p>TextInput 的 autoFocus 属性，就是用于控制自动对焦用的，其默认值是 false。也就是说，所有的 TextInput 元素默认都不会自动的对焦，而我们将 TextInput 的 autoFocus 属性设置为 true 时，框架会在 TextInput 元素挂载后，自动帮我们进行对焦。</p><p>搜索页面只有一个搜索框的场景下 ，autoFocus 是好用的。但当一个页面有多个输入框时，autoFocus 就没法实现焦点的转移了。</p><p>比如，在购物 App 中填写收货地址时，你每完成一项填写，点击键盘中的下一项按钮，焦点就会自动转移一次，从姓名到电话再到地址。我们以前讲过，React/React Native 是声明式的，但是在操作自带状态的宿主属性时，比如焦点转移，声明式就不管用了，还得用给宿主组件下命令。</p><p>那怎么下命令呢？我们先从最简单的控制 TextInput 焦点讲起，示例代码如下：</p><pre><code class=\"language-plain\">function AutoNextFocusTextInputs() {\n  const ref1 = React.useRef&lt;TextInput&gt;(null);\n\n  useEffect(()=&gt;{\n    ref1.current?.focus()\n  },[])\n\n  return  (\n    &lt;TextInput ref={ref1}  /&gt;\n    )\n}\n</code></pre><p>在这段代码中，先声明了一个 <code>ref1</code> 用于保存 TextInput 宿主组件。在该宿主组件上封装了 Native/C++ 层暴露给 JavaScript 的命令，比如对焦<code>focus()</code>、失焦<code>blur()</code>、控制选中文字的光标<code>setSelection</code>。</p><p><code>AutoNextFocusTextInputs</code>组件在挂载完成后，程序会调用<code>ref1.current.focus()</code>，将焦点对到 TextInput 元素上，这就是使用<code>focus()</code>实现对焦的原理。</p><p>使用 <code>focus()</code>命令对焦和使用<code>autoFocus</code>属性对焦，在原生应用层面的实现原理是一样的，只不过在 JavaScript 层面，前者是命令式的，后者是声明式的。对自带状态的宿主组件而言，命令式的方法能够进行更复杂的操作。</p><p>那要实现每点一次键盘的“下一项”按钮，将焦点对到下一个 TextInput 元素上，怎么实现呢？具体的示例代码如下：</p><pre><code class=\"language-plain\">function AutoNextFocusTextInputs() {\n  const ref1 = React.useRef&lt;TextInput&gt;(null);\n  const ref2 = React.useRef&lt;TextInput&gt;(null);\n  const ref3 = React.useRef&lt;TextInput&gt;(null);\n\n  return (\n    &lt;&gt;\n      &lt;TextInput ref={ref1} onSubmitEditing={ref2.current?.focus} /&gt; // 姓名输入框\n      &lt;TextInput ref={ref2} onSubmitEditing={ref3.current?.focus} /&gt; // 电话输入框\n      &lt;TextInput ref={ref3} /&gt; // 地址输入框\n    &lt;/&gt;\n  );\n}\n</code></pre><p>首先，我们得声明 3 个 <code>ref</code> 用于保存 3 个 TextInput 元素。其次，实现这三个元素，它们依次是姓名输入框、电话输入框、地址输入框。最后，需要监听点击键盘完成按钮的提交事件<code>onSubmitEditing</code>，在<code>onSubmitEditing</code>的回调中，将焦点通过<code>ref.focus()</code>转移到下一个 TextInput 元素上。</p><p>这里再多说一句，为了简单起见，我们把三个 TextInput 元素都封装到了同一个组件中。在真实的项目中，这三个输入框往往不是封装成同一个组件中的，姓名输入框、电话输入框、地址输入框每个都是一个独立的组件，然后再有一个大的复合组件将它们组合在一起的。</p><p>那么这时，如何获取到 TextInput 元素 <code>ref</code> 呢？如果你遇到了这个问题，你可以查一下<a href=\"https://zh-hans.reactjs.org/docs/forwarding-refs.html\">React 文档</a>中，关于使用 <code>React.forwardRef</code>转发 <code>ref</code>的具体用法，这里我就不展开了。</p><h2>联动键盘的体验</h2><p>你需要关注的第三件事是，输入键盘的体验细节。</p><p>我们前面提到过，输入框和键盘是联动的，键盘的很多属性都可以用 TextInput 组件来设置。因此，除了输入框的值、输入框的焦点，我们还需要关心如何控制键盘。我们一起来看看那些优秀的 App 都是怎么处理这个细节的。</p><p>先来看第一个体验细节，iOS 微信搜索框的键盘右下角按钮有一个<strong>“置灰置蓝”</strong>的功能。默认情况下，键盘右下角的按钮显示的是置灰的“搜索”二字，当你在搜索框输入文字后，置灰的“搜索”按钮会变成蓝色背景的“搜索”二字。</p><p>置灰的作用是提示用户，没有输入文字不能进行搜索，按钮变蓝提示的是有内容了，可以搜索了。</p><p>控制键盘右下角按钮置灰置蓝的，是 TextInput 的<code>enablesReturnKeyAutomatically</code>属性，这个属性是 iOS 独有的属性，默认是<code>false</code>，也就是任何使用键盘右下角的按钮，都可以点击。你也可以通过将其设置为 <code>true</code>，使其在输入框中没有文字时置灰。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/58/de5c8eb7862fd38405b1caba07eaf258.png?wh=1018x222\" alt=\"图片\"></p><p>第二个体验细节是，键盘右下角按钮的文案是可以变化的，你可以根据不同的业务场景进行设置。</p><p>有两个属性可以设置这些文案，包括 iOS/Android 通用的<a href=\"https://reactnative.dev/docs/next/textinput#returnkeytype\"> returnKeyType </a>和 Android 独有的 <a href=\"https://reactnative.dev/docs/next/textinput#returnkeylabel-android\">returnKeyLabel</a>。全部的属性你可以查一下文档，我这里只说一下通用属性：</p><ul>\n<li><code>default</code>：显示的文案是换行；</li>\n<li><code>done</code>：显示的文案是“完成”，它适合作为最后一个输入框的提示文案；</li>\n<li><code>go</code>：显示的文案是“前往”，它适合作为浏览器网站输入框或页面跳出的提示文案；</li>\n<li><code>next</code>：显示的文案是“下一项”，它适合作为转移焦点的提示文案；</li>\n<li><code>search</code>：显示的文案是“搜索”，它适合作为搜索框的提示文案；</li>\n<li><code>send</code>：显示的文案是“发送”，它比较适合聊天输入框的提示文案。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/dy/fd/dyyda94cdbb8d899c9852225d7e6f4fd.png?wh=1576x224\" alt=\"图片\"></p><p>比如，在用户填写收货地址表单的场景中，你可以在用户完成填写时，将键盘按钮文案设置成“下一项”，并在用户点击“下一项”时，把当前输入框的焦点聚焦到一下个输入框上。</p><p>第三个体验细节是，登录页面的自动填写账号密码功能。虽然现在有了二维码登录，但传统的账号密码登录场景还是非常多的。每次登录的时候，要输入一遍账号密码，就很麻烦了。</p><p>无论是 iOS 还是 Android，它们都有系统层面的记住账号密码的功能，帮助用户快速完成账号密码的填写。完成快速填写功能的 TextInput 属性，在 iOS 上叫做<code>textContentType</code>，在 Android 上叫做<code>autoComplete</code>。</p><p>你可以将账号输入框的快速填写属性设置为<code>username</code>，将密码输入框的快速填写属性设置为<code>password</code>，帮助用户节约一些时间，提高一下整体的成功率。除此之外，一些姓名、电话、地址信息也可以快速填写。</p><p><img src=\"https://static001.geekbang.org/resource/image/aa/6c/aa7378ddf3c2c193832f76b90323316c.png?wh=828x384\" alt=\"图片\"></p><p>还有一些键盘的体验细节，比如<code>keyboardType</code>可以控制键盘类型，可以让用户更方便地输入电话号码<code>phone-pad</code>、邮箱地址<code>email-address</code>等等。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/6f/6decc25dc3b45cc03e19ea533f15dc6f.png?wh=828x876\" alt=\"图片\"></p><p>当你知道这些键盘细节后，你就可以利用这些系统的特性，帮你的 App 体验变得更好。现在，我们回过头，再来改善一下，我们之前实现的自动聚焦组件 <code>AutoNextFocusTextInputs</code>吧。示例代码如下：</p><pre><code class=\"language-plain\">function AutoNextFocusTextInputs() {\n  const ref1,ref2,ref3 ...\n\n  return (\n    &lt;&gt;\n      &lt;TextInput ref={ref1} placeholder=\"姓名\" textContentType=\"name\" returnKeyType=\"next\" onSubmitEditing={ref2.current?.focus}/&gt;\n      &lt;TextInput ref={ref2} placeholder=\"电话\"  keyboardType=\"phone-pad\" returnKeyType=\"done\" onSubmitEditing={ref3.current?.focus}\n      /&gt;\n      &lt;TextInput  ref={ref3}  placeholder=\"地址\"  returnKeyType=\"done\" /&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre><p>在这段代码中，我们使用了<code>placeholder</code>来提醒用户该输入框应该输入什么，使用了 <code>textContentType=\"name\"</code> 来辅助用户填写姓名，使用了 <code>keyboardType=\"phone-pad\"</code> 来指定键盘只用于输入电话号码，使用<code>returnKeyType=\"next\" 或 \"done\"</code>来提示用户当前操作的含义，当然还有<code>ref.current.focus()</code>的自动聚焦功能。</p><h2>总结</h2><p>这一讲，我们还是围绕着交互体验这个角度来讲组件，从交互体验这个角度看 TextInput 组件，我们需要注意三件事：</p><ol>\n<li>学会处理输入框的文字。有两种处理方式受控组件和非受控组件，受控组件更强大一些，也更符合大多数 React/React Native 开发者的习惯；</li>\n<li>学会处理输入框的焦点。处理焦点有两种方式：一种是声明式的<code>autoFocus</code>属性，另一种是命令式的<code>ref.current.focus()</code>方法，前者适用场景有限，后者适用场景更多；</li>\n<li>学会处理与输入框联动的键盘，包括键盘右下角的按钮、键盘提示文案、键盘类型等等。</li>\n</ol><p>日常工作中，用到 TextInput 输入框的场景非常多，有聊天框、搜索框、信息表单等等，相信学完这一讲后，你能更好地处理 TextInput 体验细节。</p><h2>附加材料</h2><ol>\n<li>iOS 模拟器上，点击 TextInput 元素并没有键盘弹窗，必须使用真机进行测试。iOS 如何在真机上进行打包请参考<a href=\"https://www.jianshu.com/p/f31116a76ea9\">《iOS个人证书真机调试及报错》</a>。</li>\n<li>0.68 之后，新架构预览版已经能在本地跑起来了。如果你想跑 iOS RNTest App（Android 版哪位朋友帮忙提供一下？），也就是官方用于测试的 React Native App，你可以按照如下步骤进行操作：</li>\n</ol><pre><code class=\"language-plain\">$ git clone https://github.com/facebook/react-native.git\n$ cd react-native\n$ yarn\n$ cd packages/react-native-codegen\n$ yarn build\n$ cd ../rn-tester\n$ yarn\n$ USE_CODEGEN_DISCOVERY=1  RCT_NEW_ARCH_ENABLE=1 pod install\n$ xed .\n\n=&gt; 打开 xcode 后，点击构建模拟器 App\n=&gt; 真机构建参考，附加材料 1\n=&gt; 真机构建遇到 Undefined symbol:folly 报错，试着注释掉 packages/rn-tester/Podfile 文件中的如下代码：\n  # if !USE_FRAMEWORKS\n  #   use_flipper!\n  # end\n</code></pre><p>3、今天的Demo我依然放在了<a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/07_TextInput\">GitHub</a>上，你可以自己动手试试。</p><h2>作业</h2><ol>\n<li>\n<p>请你实现一个如图所示的用于填写验证码的输入框组件：<br>\n<img src=\"https://static001.geekbang.org/resource/image/ce/96/ce50be3a09dcd4b531d14d9a733f1f96.png?wh=828x468\" alt=\"图片\"></p>\n</li>\n<li>\n<p>请你思考一下 TextInput 的异步 onChange 和同步 onChangeSync 的区别是什么？Fabric 的同步特性将给 React Native 带来什么变化？</p>\n</li>\n</ol><p>欢迎在评论区留言。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"06｜Pressable：如何实现一个体验好的点按组件？","id":504527},"right":{"article_title":"08｜List：如何实现高性能的无限列表？","id":506825}}},{"article_id":506825,"article_title":"08｜List：如何实现高性能的无限列表？","article_content":"<p>你好，我是蒋宏伟。今天我们学习的重点是列表组件 RecyclerListView。</p><p>如果你熟悉 React Native ，那你可能会问了：“React Native 中的列表组件不是 FlatList 吗？”</p><p>没错。React Native 官方提供的列表组件确实是 FlatList，但是我推荐你优先使用开源社区提供的列表组件 RecyclerListView。因为，开源社区提供的 RecyclerListView 性能更好。</p><p>对于列表组件来说，我们最应该关心的就是性能。这里我给你分享下我的个人经历。2016~2018 年，我参与了一个用 React Native 搭建的信息流项目。信息流这种无限列表页是非常常见的业务场景，比如你使用的京东首页、抖音视频、微信朋友圈都属于信息流页面。你看完一页，还有下一页，看完下一页还有下下页，无穷无尽。这时就要用到我们马上要探讨的列表组件了，而且必须是高性能的列表组件，不能翻着翻着就卡起来了。</p><p>2016 年，没有 RecyclerListView，也没有 FlatList，我们用的是第一版的 ListView 组件。ListView 组件性能很差，没有内存回收机制，翻一页内存就涨一点，再翻一页内存又再涨一点。前 5 页滚动非常流畅，第 10 页开始就感觉到卡顿了，到 50 页的时候，基本就滑不动了。卡顿的原因就是无限列表太吃内存了。如果手机的可使用内存不够了，卡顿就会发生。这也是 React Native 刚出来时被吐槽得最多的地方。</p><!-- [[[read_end]]] --><p>2017 年，官方的第二代列表组件 FlatList 出来后，第一代列表组件 ListView 就被废弃了，这时候无限列表性能变得好一些了。虽然FlatList 在 iOS 端表现很好，但在 Android 低端机还是能感觉到卡顿。</p><p>2018 年，随着业务越来越复杂，FlatList 的性能表现变得更加糟糕了。经过调研，我们找到了性能更好的列表组件 RecyclerListView。通常评判列表卡顿的指标是 UI 线程的帧率和 JavaScript 线程的帧率。</p><p>但业内有人实验过，在已经渲染完成的页面中，通过死循环把 JavaScript 线程卡死，页面依旧能够滚动。这是因为滚动本身是在 UI 线程进行的，和 JavaScript 线程无关。但当用户下滑，需要渲染新的列表项时，就需要JavaScript 线程参与进来了。如果这时候 JavaScript 掉帧了，新的列表项就渲染不出来，即便能滚动，用户看到也是空白项，一样影响用户体验。</p><p>因此，我们当时是把 JavaScript 帧率作为客观指标，再加上团队同学主观体验，进行综合评估。采集 JavaScript 帧率用的手机是 OPPO R9，现在看来是妥妥的低端机了，结果显示，FlatList  JavaScript 帧率小于 20 帧的占比有 16%，而 RecyclerListView 占比只有 3%。主观体验上，团队同学拿自己的手机进行测试，使用暴力滑动的测试方法，测评了 20 来款机型。在低端机上 FlatList 多被标记为一般卡，而 RecyclerListView 大多标记是流畅，只有少量的轻微卡顿。</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/bd/5ed5ba1e8a756d1065f1c70e14083abd.png?wh=1001x386\" alt=\"图片\"></p><p>即使现在新架构马上要出来了，在这个时间点上，我最推荐你用的还是 RecyclerListView。因为从原理上 RecyclerListView 比 FlatList 强上不少。</p><p>作为一个开发者，你总有需要手动优化的时候，不是所有场景都有现成的组件，都有自动化的解决方案。如果你现在没有遇到，兴许只是因为开发年头太少了，你可以问问你身边那些开发年头多的同学，他们在这方面应该是有很深的体会。学习 FlatList、RecyclerListView 的优化原理，对自己的动手优化是非常有帮助的。当你以后遇到列表性能问题时，你可以有现成的优化思路借鉴，不会毫无头绪。</p><p>那么，为什么开源社区的 RecyclerListView 比官方的 FlatList 性能更好？FlatList、RecyclerListView 的优化原理是什么？FlatList 和 RecyclerListView 的底层实现都是滚动组件 ScrollView，所以我们先从 ScrollView 聊起。</p><h2>ScrollView：渲染所有内容的滚动组件</h2><p>ScrollView 是一个支持横向或竖向的滚动组件，几乎所有页面都会用到。</p><p>ScrollView 组件类似于 Web 中的 <code>&lt;html/&gt;</code> 或 <code>&lt;body/&gt;</code> 标签，浏览器中的页面之所以能上下滚动，就是因为 html 或 body 标签默认有一个 overflow-y: scroll 的属性，如果你把标签的属性设置为 overflow-y: hidden，页面就不能滚动了。</p><p>React Native 的 ScrollView 组件在 Android 的底层实现用的是 ScrollView 和 HorizontalScrollView，在 iOS 的底层实现用的是 UIScrollView。</p><p>所谓的滚动，解决的是在有限高度的屏幕内浏览无限高度的内容的问题。有限高度的容器是 ScrollView，无限高度，或者说高度不确定的内容是 ScrollView 的 children。</p><p>使用 ScrollView 组件时，我们通常并不直接给 ScrollView 设置固定高度或宽度，而是给其父组件设置固定高度或宽度。</p><p>一般而言，我们会使用安全区域组件 SafeAreaView 组件作为 ScrollView 的父组件，并给 SafeAreaView 组件设置布局属性 flex:1，让内容自动撑高 SafeAreaView。使用 SafeAreaView 作为最外层组件的好处是，它可以帮我们适配 iPhone 的刘海屏，节约我们的适配成本，示例代码如下：</p><pre><code class=\"language-plain\">&lt;SafeAreaView style={{flex: 1}}&gt;\n  &lt;ScrollView&gt;\n    &lt;Text&gt;1&lt;/Text&gt;\n  &lt;ScrollView/&gt;\n&lt;/SafeAreaView&gt;    \n</code></pre><p>了解完 ScrollView 组件的基本使用方法后，我们再来看下 ScrollView 的性能，看看如果使用 ScrollView 来实现无限列表会怎么样。</p><p>你可以看看下面这段代码：</p><pre><code class=\"language-plain\">// 10 个 item 就能填满整个屏幕，渲染很快\n// 1000 个 item 相当于 100+ 个屏幕的高度，渲染很慢\nconst NUM_ITEMS = 1000; \n\nconst makeContent = (nItems: number, styles: any) =&gt; {\n  return Array(nItems)\n    .fill(1)\n    .map((_, i) =&gt; (\n      &lt;Pressable\n        key={i}\n        style={styles}&gt;\n        &lt;Text&gt;{'Item ' + i}&lt;/Text&gt;\n      &lt;/Pressable&gt;\n    ));\n};\n\nconst App = () =&gt; {\n  return (\n    &lt;SafeAreaView style={{flex: 1}}&gt;\n      &lt;ScrollView&gt;{makeContent(NUM_ITEMS, styles.itemWrapper)}&lt;/ScrollView&gt;\n    &lt;/SafeAreaView&gt;\n  );\n};\n</code></pre><p>上面这段代码，说的就是使用 ScrollView 组件一次性直接渲染 1000 个子视图，这里没有做任何懒加载优化。</p><p>以信息流业务为例，用户进入页面后第一眼看到的只有屏幕中的信息，一般不超过 10 条。一次性渲染 10 条信息，其实很快，就是一眨眼的功夫。但如果是 1000 条呢？算力乘以 100，内存乘以 100，耗时也乘以 100，渲染速度就慢下来了。大量的计算和内存浪费在了用户看不到的地方。</p><p>使用 ScrollView 组件时，ScrollView 的所有内容都会在首次刷新时进行渲染。内容很少的情况下当然无所谓，内容多起来了，速度也就慢下来了。</p><p>那有什么优化方案吗？你肯定想到了一些优化方案，比如按需渲染。</p><p>我参加过一个使用 React Native 开发的、类似抖音的视频流页面，用的就是按需渲染。用户始终只会看到当前屏幕显示的视频、下一个视频和上一个视频，我们只需要用 ScrollView 渲染 3 个视频就能满足用户的所有操作。这样做，无论用户怎么翻页，内存中就只有 3 个视频，当然也不会卡了。</p><p>刚刚说的视频流按需加载，做起来是相对容易一些的，因为只用控制 3 个视频就可以了。但类似微信朋友圈、京东首页这种一屏有多条信息内容的复杂列表页，手动按需加载就麻烦很多。那有没有“自动\"的按需加载方案呢？有。</p><h2>FlatList：按需渲染的列表组件</h2><p>FlatList 列表组件就是 “自动”按需渲染的。</p><p>FlatList 是 React Native 官方提供的第二代列表组件。FlatList 组件底层使用的是虚拟列表 VirtualizedList，VirtualizedList 底层组件使用的是 ScrollView 组件。因此 VirtualizedList 和  ScrollView 组件中的大部分属性，FlatList 组件也可以使用。关于 FlatList 更具体的使用方法，你可以查看<a href=\"https://reactnative.dev/docs/flatlist\">官方文档</a>。现在，我们还是回到 FlatList 的原理，先从理论层面上理解 FlatList 为什么可以自动按需渲染。</p><p>我们要知道，列表组件和滚动组件的关键区别是，列表组件把其内部子组件看做由一个个列表项组成的集合，每一个列表项都可以单独渲染或者卸载。而滚动组件是把其内部子组件看做一个整体，只能整体渲染。而自动按需渲染的前提就是每个列表项可以独立渲染或卸载。</p><p>简单地讲，FlatList 性能比 ScrollView 好的原因是， FlatList 列表组件利用按需渲染机制减少了首次渲染的视图，利用空视图的占位机制回收了原有视图的内存，你可以对比一下二者的区别：</p><pre><code>// 从上到下滚动时的渲染方式\n// SrcollView 渲染方式：一次渲染所有视图\nSrcollView0_9  = [{👁},{ },{ },{ }]  // 浏览0~9条列表项\nSrcollView10_19 = [{ },{👁},{ },{ }] // 浏览10~19条列表项\nSrcollView20_29 = [{ },{ },{👁},{ }] // 浏览20~29条列表项\nSrcollView30_39 = [{ },{ },{ },{👁}] // 浏览30~39条列表项\n\n// FlatList 渲染方式：按需渲染，看不见的地方用 $empty 占位\nFlatList0_9  = [{👁},{ }]               // 浏览0~9条列表项\nFlatList10_19 = [{ },{👁},{ }]          // 浏览10~19条列表项\nFlatList20_29 = [$empty,{},{👁},{}]     // 浏览20~29条列表项\nFlatList30_39 = [$empty,$empty,{ },{👁}]// 浏览30~39条列表项\n</code></pre><p>在上面的示例中，同样是渲染 40 条列表。ScrollView 一次性渲染了 40 条列表，无论你滚动到哪儿，所有的列表项都是渲染好的。</p><p>但FlatList 在你浏览 0~9 条列表项时，只渲染了0~19条列表，剩余的20~39条列表项是没有渲染的。在你浏览滚动到第 10~19 条时，FlatList 把 20~29 条列表项提前加载出来了，这就是按需渲染加载机制.当你继续滚动到 20~29 条列表项时，FlatList 会把第 0~9 条列表项回收，用空元素 <span dollar=\"\">$</span>empty 代替，当你再滚动到 30~39 条列表项时，同理 10~19 条列表项也会被空元素 <span dollar=\"\">$</span>empty，这就是内存回收。</p><p>40 条列表只是一个假设的例子，实现 FlatList自动按需渲染的思路具体可以分为三步：</p><ol>\n<li>通过滚动事件的回调参数，计算需要按需渲染的区域；</li>\n<li>通过需要按需渲染的区域，计算需要按需渲染的列表项索引；</li>\n<li>只渲染需要按需渲染列表项，不需要渲染的列表项用空视图代替。</li>\n</ol><p>第一步，计算按需渲染区域。具体地说，每次你滚动页面，都会触发滚动组件 ScrollView 组件的一个“异步”回调 onScroll 事件。</p><p>在 onScroll 事件中，我们可以获取到当前滚动的偏移量 offset 等信息。以当前滚动的偏移量为基础，默认向上数 10 个屏幕的高度，向下数 10 个屏幕的高度，这一共 21 个屏幕的内容就是需要按需渲染的区域，其他区域都是无需渲染的区域。这样，即便是异步渲染，我们也不能保证所有 JavaScript 执行的渲染任务都实时地交由 UI 线程处理，立刻展示出来。但因为有这 10 个屏幕的内容作为缓冲，用户无论是向上滚动还是向下滚动，都不至于一滚动就看到白屏。</p><p>现在我们知道了按需渲染的区域，接着要计算的就是按需渲染列表项的索引。FlatList 内部实现就是通过 setState 改变按需渲染区域第一个索引和最后一个索引的值，来实现按需渲染的 。</p><p>怎么计算按需渲染列表项的索引呢？接着我们继续看第二步。这里我们分两种情况，第一种是列表项的高度是确定的情况，另外一种是列表项的高度是不确定的情况。</p><p>如果设计师给的列表项的高度是确定的，那么我们在写代码的时候，就可以通过获取列表项布局属性 getItemLayout 告诉 FlastList。在列表项高度确定，且知道按需渲染区域的情况下，“求按需渲染列表项的索引”就是一个简单的四则运算的问题，程序能够准确地计算出来。</p><p>如果设计师给的 UI 稿中是不定高的列表项，也就是高度是由渲染内容决定的。你就没有办法在写代码的时候把列表项的高度告诉 FlastList 了，那么 FlastList 就要先把列表项渲染出来才能获取高度。对于高度未知的情况，FlastList 会启用列表项的布局回调函数 onLayout，在 onLayout 中会有大量的动态测量高度的计算，包括每个列表项的准确高度和整体的平均高度。</p><p>在这种列表项高度不确定，而且给定按需渲染区域的情况下，我们可以通过列表项的平均高度，把按需渲染列表项的索引大致估算出来了。即便有误差，比如预计按需渲染区域为上下 10 个屏幕，实际渲染时只有上下 7、8 个屏幕也是能接受的，大部分情况下用户是感知不到的屏幕外内容渲染的。</p><p>但是，实际生产中，如果你不填 getItemLayout 属性，不把列表项的高度提前告诉 FlastList，让 FlastList 通过 onLayout 的布局回调动态计算，用户是可以感觉到滑动变卡的。因此，如果你使用 FlastList，又提前知道列表项的高度，我建议你把 getItemLayout 属性填上。</p><p>第三步，渲染需要按需渲染列表项。有了索引后，渲染列表项就变得很简单，用 setState 即可。</p><p>假设 1 个屏幕高度的内容由 10 个列表项组成。在首次渲染的时候，按需渲染的列表项索引是 0~110，这时会渲染 11 个屏幕高度的内容。当用户滑到第 11 个屏幕时，索引就是 0~210，这时再在后面渲染 10 个屏幕高度的内容。当用户滑到第 21 个屏幕时，索引是 100~310，又会再在后面渲染 10 个屏幕高度的内容，同时把前面 10 个屏幕高的内容用空视图代替。当然这个过程是顺滑的，列表项是一个个渲染的，而不是 1 个屏幕或 10 个屏幕渲染的。</p><h2>RecyclerListView：可复用的列表组件</h2><p>聊完 FlastList，我们再来看下 RecyclerListView。</p><p>RecyclerListView 是开源社区提供的列表组件，它的底层实现和 FlatList 一样也是 ScrollView，它也要求开发者必须将内容整体分割成一个个列表项。</p><p>在首次渲染时，RecyclerListView 只会渲染首屏内容和用户即将看到的内容，所以它的首次渲染速度很快。在滚动渲染时，只会渲染屏幕内的和屏幕附近 250 像素的内容，距离屏幕太远的内容是空的。</p><p>React Native 的 RecyclerListView 复用灵感来源于 Native 的可复用列表组件。</p><p>在 iOS 中，表单视图 UITableView，实际就是可以上下滚动、左右滚动的可复用列表组件。它可以通过复用唯一标识符 reuseIdentifier，标记表单中的复用单元 cell，实现单元 cell 的复用。</p><p>在 Android 上，动态列表 RecyclerView 在列表项视图滚出屏幕时，不会将其销毁，相反会把滚动到屏幕外的元素，复用到滚动到屏幕内的新的列表项上。这种复用方法可以显著提高性能，改善应用响应能力，并降低功耗。</p><p>如果你只开发过 Web，你可以这样理解复用：原来你要销毁一个浏览器中 DOM，再重新创建一个新的 DOM，现在你只改变了原有 DOM 的属性，并把原有的 DOM 挪到新的位置上。</p><p>RecyclerListView 的复用机制是这样的，你可以把列表比作数组 list，把列表项类比成数组的元素。用户移动 ScrollView 时，相当于往数组 list 后面 push 新的元素对象，而 RecyclerListView 相当于把 list 的第一项挪到了最后一项中。挪动对象位置用到的计算资源少，也不用在内存中开辟一个新的空间。而创建新的对象，占用计算资源多，同时占用新的内存空间。</p><p>简而言之，RecyclerListView 在滚动时复用了列表项，而不是创建新的列表项，因此性能好。</p><h2>从使用方式看底层原理</h2><p>接下来，我们从 RecyclerListView 使用方式的角度，进一步地剖析其底层原理。</p><p>RecyclerListView 有三个必填参数：</p><ul>\n<li>列表数据：dataProvider(dp)；</li>\n<li>列表项的布局方法：layoutProvider；</li>\n<li>列表项的渲染函数：rowRenderer。</li>\n</ul><p>先来看<strong>第一个必填参数列表数据 dataProvider（dp）</strong>。为了区分列表数据 dataProvider（第一个字母小写）和列表数据类 DataProvider（第一个字母大写），后面我会用缩写 dp 来代替列表数据，其使用方法如下：</p><pre><code class=\"language-plain\">const listData = Array(300).fill(1).map( (_,i) =&gt; i)\n\nconst dp = new DataProvider((r1, r2) =&gt; {\n   return r1 !== r2;\n});\n\nthis.state = {\n    dataProvider: dp.cloneWithRows(listData),\n};\n\nthis.setState({\n  dataProvider: dp.cloneWithRows(newListData),\n})\n</code></pre><p>在上面代码中，我们首先通过 Array(300) 创建了一个长度为 300 的数组 listData，其内容是 0~299 的数字，我们通过它来模拟 300 条信息数据。</p><p>接着，dp 是列表数据类 DataProvider new 出来的对象，它是一个存放 listData 的数据容器。它有一个必填参数，就是对比函数。在列表项复用时，对比函数会频繁地调用，因此我们只推荐对更新数据进行 r1 !== r2 的浅对比，不推荐深对比。</p><p>第三部分代码，是我们调用 dp.cloneWithRow 方法，该方法接收 listData 数组作为参数，这时我们正式把 listData 装到了 dp 容器中。其返回值 dataProvider，就是 React 的列表状态。</p><p>第四部分代码，是我们调用 setState 方法，该方法接收 dp.cloneWithRows()  的返回的 dp 对象作为参数，dp 列表数据对象更新了，整个列表也就更新了。</p><p>接下来是<strong>第二个必填参数，列表项的布局方法 layoutProvider。</strong></p><pre><code class=\"language-plain\">const _layoutProvider = new LayoutProvider(\n  index =&gt; {\n    if (index % 3 === 0) {\n      return ViewTypes.FULL;\n    } else {\n      return ViewTypes.HALF_RIGHT;\n    }\n  },\n  (type, dimension) =&gt; {\n    switch (type) {\n      case ViewTypes.HALF_RIGHT:\n        dimension.width = width / 2;\n        dimension.height = 160;\n        break;\n      case ViewTypes.FULL:\n        dimension.width = width;\n        dimension.height = 140;\n        break;\n    }\n  },\n);\n</code></pre><p>layoutProvider 类初始化时，有两个函数入参。第一个入参函数是通过索引 index 获取类型 type，对应的是类型可枚举。第二个入参函数是通过类型 type 和布局尺寸 dimension 获取每个类型的宽高 width 和 height，对应的是确定宽高。</p><p>用起来很简单，但这两个入参为什么要这么设计，它们有什么用？</p><p>使用列表组件 RecyclerListView 有两个前提：首先是列表项的宽高必须是确定的，或者是大致确定的；第二是列表项的类型必须是可枚举的。这两个前提，都体现在了列表项的布局方法 layoutProvider 中了。</p><p>先来看第一个前提，宽高必须确定。RecyclerListView 用的是 position:absolute 的绝对定位布局，所有的列表项的宽度 width、高度 height、顶部偏移量 top、左边偏移量 left 都得在布局之前计算出来。</p><p>但实际上布局方法 layoutProvider，只需要知道列表项的宽（width）、高（height）就可以了，偏移量 top、left 可以根据宽高推算出来。比如，第 N 个列表项的偏移量 top 值，实际等于前面 N - 1 个列表项的高度之和。</p><p>如果宽高不确定呢？分两种情况，一种就是不确定的，另一种是不确定但可以转换为大致确定的。对于就是不确定的情况，RecyclerListView 是无解的；对于大致确定的情况，我们可以开启 forceNonDeterministicRendering 小幅修正布局位置。</p><p>比如，信息流的标题文字少的时候是一行布局，文字多的时候是两行布局，一行两行的高度偏差不大，可以在渲染后让框架帮忙进行小幅修正。通常在用户看到之前，这种小幅修正就已经完成了，用户感知不到列表的偏移。</p><p>但如果是信息流的内容高度不确定，相差百来个像素，这种大幅修正可能会让用户察觉到，不适合使用 RecyclerListView 。</p><p>再来看第二个前提，类型可枚举。可枚举很好理解，两个列表项的底层 UI 视图必须一样或者大致相似，才能只改列表数据复用列表视图。如果每个列表项的 JSX 结构完全不一样，就不存在复用的可能性。一般来说，一个类型对应一个自定义组件。</p><p>理解了确定宽高和类型可枚举两个前提后，你再来看布局方法 layoutProvider 需要的两个函数入参，就能清楚它的原因了。</p><p>最后是<strong>第三个必填参数，列表项的渲染函数：rowRenderer。</strong></p><p>有了数据、布局，还得有组件进行承载。列表内容被分割成了一个个的列表项，每一个列表项展示都是独立的内容信息，而可枚举的列表项组件用于承载每条信息的载体。列表项的渲染函数 rowRenderer 的作用就是根据类型和数据，返回对应的自定义列表项组件。这块逻辑比较简单，我就不做过多讲解了。</p><p>rowRenderer 的对应代码，我也放在了这里，你可以对照查看：</p><pre><code class=\"language-plain\">//Given type and data return the view component\n  _rowRenderer(type, data) {\n    //You can return any view here, CellContainer has no special significance\n    switch (type) {\n      case ViewTypes.HALF_RIGHT:\n        return (\n          &lt;CellContainer style={styles.containerGridRight}&gt;\n            &lt;Text&gt;Data: {data}&lt;/Text&gt;\n          &lt;/CellContainer&gt;\n        );\n      case ViewTypes.FULL:\n        return (\n          &lt;CellContainer style={styles.container}&gt;\n            &lt;Text&gt;Data: {data}&lt;/Text&gt;\n          &lt;/CellContainer&gt;\n        );\n      default:\n        return null;\n    }\n  }\n</code></pre><h2>PK：ScrollView、FlatList、RecyclerListView</h2><p>到这里，我相信你已经对 ScrollView、FlatList 和 RecyclerListView 底层原理有了一定的了解。现在，我们再横向对比一下这三个组件，帮你加深理解。</p><p>从底层原理看：</p><ul>\n<li>ScrollView 内容的布局方式是从上到下依次排列的，你给多少内容，ScrollView 就会渲染多少内容；</li>\n<li>FlatList 内容的布局方式还是从上到下依次排列的，它通过更新第一个和最后一个列表项的索引控制渲染区域，默认渲染当前屏幕和上下 10 屏幕高度的内容，其他地方用空白视图进行占位；</li>\n<li>RecyclerListView 性能最好，你应该优先使用它，但使用它的前提是列表项类型可枚举且高度确定或大致确定。</li>\n</ul><p>理解了底层原理，FlatList 和 RecyclerListView 孰强孰弱，相信你已经有了答案。</p><p>内存上，FlatList  要管理 21 个屏幕高度的内容，而 RecyclerListView 只要管理大概 1 个多点屏幕高度的内容，RecyclerListView 使用的内存肯定少。计算量上，FlatList  要实时地销毁新建 Native 的 UI 视图，RecyclerListView 只是改变 UI 视图的内容和位置，RecyclerListView 在 UI 主线程计算量肯定少。</p><p>你也可以自己实际的体验、看看性能指标或者 Debug 一下，来佐证你的结论。</p><p>理解了底层原理，ScrollView、FlatList 和 RecyclerListView 使用场景，估计你也能基本把握住了：</p><ul>\n<li>ScrollView 适合内容少的页面，只有几个屏幕高页面是适合的；</li>\n<li>FlatList 性能还过得去，但我不推荐你优先使用它，只有在你的列表项内容高度不能事先确定，或者不可枚举的情况下使用它；</li>\n<li>RecyclerListView 性能最好，你应该优先使用它，但使用它的前提是可枚举且高度确定或大致确定。</li>\n</ul><p>这里我也总结成了两张图表，你可以看看：</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/71/e9572yy831332ba1fb8baf0a48bc7e71.png?wh=1920x1050\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/e6/a0/e6cb77f6425810e752abbeb643dbb9a0.png?wh=1870x964\" alt=\"图片\"></p><h2>总结</h2><p>最后，我们总结一下今天这节课所讲的重点：</p><ol>\n<li>滚动组件 ScrollView 是列表组件 FlastList 和 RecyclerListView 的底层实现，ScrollView 的绝大部分属性在 FlastList 和 RecyclerListView 上都有；</li>\n<li>从按需渲染的可视区域的大小和对底层 UI 视图的操作方式上分析，RecyclerListView 比 FlastList 的内存更少，在 UI 线程的计算量也更少；</li>\n<li>为了让你的无限列表性能更好，我推荐你优先使用 RecyclerListView，然后才是 FlastList。</li>\n</ol><p>列表是一个很大的话题，牵涉到的性能优化细节和实践内容很多，这一讲可以算作列表的一个入门。</p><p>受限于手机性能，无限列表是经常出现性能问题的重灾区，我也参与和优化过一些非常复杂的无限列表场景，包括 Hybrid、小程序 和 React Native，有过非常多的实践。在后面的篇章中，我会基于这些入门知识，和你讲讲具体业务中的实践操作，还有一些新架构中无限列表的变化。</p><p>在这一讲中，我希望你能把基础打好，自己动手实践一下 ScrollView、FlastList 和 RecyclerListView。同样，今天我也给你留了补充材料和作业。</p><h2>补充材料</h2><h3>使用文档：</h3><ul>\n<li><a href=\"https://reactnative.dev/docs/scrollview\">ScrollView</a> 和 <a href=\"https://reactnative.dev/docs/flatlist\">FlatList</a> 你可以参考官方文档，进一步学习它们的具体使用。</li>\n<li>RecyclerListView 你可以在 Github 上找到它的<a href=\"https://github.com/Flipkart/recyclerlistview\">文档</a>，在作者的博客<a href=\"https://medium.com/@naqvitalha/recyclerlistview-high-performance-listview-for-react-native-and-web-e368d6f0d7ef\">《RecyclerListView: High performance ListView for React Native and Web》</a>了解它的诞生背景。</li>\n</ul><h3>实战指南：</h3><ul>\n<li>RecyclerListView 的内部状态是 renderStack 用于确定哪些视图应该渲染，<a href=\"https://github.com/Flipkart/recyclerlistview/blob/c80825fabe510a48ced722e2e6e9dc1b50e8e273/src/core/VirtualRenderer.ts#L213-L222\">它的复用机制是通过列表项的类型 type 找到要被回收列表项 renderStack[key]，然后用新列表项索引 index 替换被回收的列表项索引 oldIndex</a>。</li>\n<li>RecyclerListView 是可以实现高度不确定的无限列表的。图片的高度可以通过服务端事先传过来，文字的高度可以按照我在<a href=\"https://mp.weixin.qq.com/s/kN4MxfEkvICq3JneUvM56w\">《React Native 无限列表的优化与实践》</a>一文中提供的算法提前算出来，再开启高度动态修正。</li>\n<li>RecyclerListView 也是可以实现瀑布流布局的。RecyclerListView 其实就是绝对定位(x,y,width,height)，但不支持双列，你可以用 <a href=\"https://github.com/ds300/patch-package\">patch-package</a> ，把底层计算 layout 用的 <a href=\"https://github.com/Flipkart/recyclerlistview/blob/782e6ebb0ed944a653e8c83eac9329cfa243410c/src/core/layoutmanager/LayoutManager.ts#L99-L105\">“relayoutFromIndex” 和 “this._layouts” </a>改了。</li>\n<li>它们的 Demo 我放在了 <a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/08_List\">GitHub</a> 上，你可以动手把玩一下。</li>\n</ul><h2>作业</h2><ol>\n<li>请你使用 React Hook 的语法实现一个 RecyclerListView 无限列表。</li>\n<li>你遇到过那些列表性能问题又是怎么解决的，能不能和我们分享一下你的心得？</li>\n</ol><p>欢迎在留言区分享你的见解。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"07｜TextInput：如何实现一个体验好的输入框？","id":505780},"right":{"article_title":"09｜Fast Refresh：提高 UI 调试效率神器","id":507846}}},{"article_id":507846,"article_title":"09｜Fast Refresh：提高 UI 调试效率神器","article_content":"<p>你好，我是蒋宏伟。今天我们来讲一讲提高 UI 调试效率的方法。</p><p>在开发 UI 时，大家一般都是一边看设计稿，一边写代码，一边调试，三种行为交替进行的。谁的大脑都不是一台编译机，也不能安装真正的 React Native 环境。即使已经思考得很完备了，我们也不能保写完的一段代码里面没有任何 Bug，每次写完的代码都能完美符合我们预期的设计。所以，我们离不开 UI 调试。</p><p>那UI 调试效率重要吗？非常重要。你可以回想一下，是不是我们大部分的业务开发都会涉及到 UI 的开发。而在 UI 开发的过程中，你是不是会花费很多时间在调试代码上，甚至调试时间可能比真正写代码的时间还要多？正是如此，我们才更应该花点时间学一下调试技巧，把 UI 开发整体效率给提上去。</p><p>今天这节课，我会先从 React Native 快速刷新的使用讲起，然后再深入核心原理，帮你理解如何更好地使用快速刷新，提高你的 UI 开发效率。</p><h2>使用快速刷新</h2><p>React Native <a href=\"https://reactnative.dev/blog/2019/09/18/version-0.61#fast-refresh\">快速刷新（Fast Refresh）</a>是默认开启的，你不用做任何额外的配置，就能立刻体验到。</p><p>快速刷新提效的本质是<strong>及时反馈</strong>。也就是说，你写下代码后就能看到 UI，没有其他任何多余步骤。代码完成了，UI 就更新了，这就是及时反馈。</p><!-- [[[read_end]]] --><p>假设，你正在开发一个商品列表页面。UI 稿中图片左边距为 30px ，你在 Image 的样式中增加了一行 <code>marginLeft: 30</code> 的代码。当你按下快捷键<code>cmd + s</code>保存代码时，不到 1s 的时间，你就看到你屏幕右侧模拟器中，所有商品图片都移到正确的位置上了。</p><p>你能在心中快速验证一下，是对的，然后你又添加一行上下居中的代码，又是不到 1s 的时间，商品图片又位移了一下。嗯，完美居中。每一次的 UI 调试都是，所码即所见，无与伦比的开发体验，让你沉浸在这开发的心流中。</p><p>这实际上就是我日常使用 React Native 快速刷新能力开发 UI 界面的感受。</p><p>在使用快速刷新时，你应该知道一个提升开发效率的小技巧。我日常开发时习惯把模拟器放在代码编辑器右边，并且会把模拟器勾选<code>window =&gt; stay on top</code>选项，在把模拟器置顶在编辑器上方。</p><p>这样，我们就能在写代码和调试的同时，立刻看到模拟器中的效果。相比真机调试或者多屏来回切换，置顶模拟器可以减少手离开键盘和视野来回切换的次数，提高你的开发效率。</p><p><img src=\"https://static001.geekbang.org/resource/image/57/f4/57463070f313cb6e0e1425ee3930e8f4.png?wh=1825x1080\" alt=\"图片\"></p><p>看到这里，你是不是很好奇，快速刷新带来的“所码即所见”能力的原理究竟是什么样的？</p><h2>基础原理：模块热替换</h2><p>React Native 的快速刷新功能的最早期版本，叫做热重载 Hot Reload，是基于 Webpack 的模块热替换<a href=\"https://webpack.js.org/guides/hot-module-replacement\">（Hot Module Replacement）</a>的原理开发的。我们写 React Native 之前，都会运行一个 <code>react-native start</code> 命令，启动一个 Metro 服务，而 Metro 服务就实现了模块热替换的功能。</p><p>Metro 服务会把更新的代码打包发送给 React Native 应用，让应用能够及时更新，那这个过程大概是怎么样的呢？</p><p>首先，Metro 服务会监听代码文件的变化，当你修改完代码（①），保存文件时（②），Metro 服务就会收到通知。在你保存好后，Metro 就会编译涉及到的更新文件（③），编译完成后再生成一个用于更新的 bundle。</p><p>而 Metro 的模块热替换服务和 React Native 应用中的模块热替换客户端（HMR Client），在启动时其实已经建立好了 socket 连接。</p><p>所以，当新 bundle 生成时，模块热替换服务会通过 socket 通知块热替换客户端，热替换客户端实际就是运行在 React Native 应用中的一段 JavaScript 代码，它一开始就执行了一个 socket 监听事件（④）。</p><p>React Native 收到通知后，就会向请求 bundle 服务发起请求。然后，bundle 服务会返回一个用于更新的 bundle（⑤），并使用 JavaScript 引擎，在原来 React Native 应用的 JavaScript 上下文中执行用于更新的 bundle。</p><p>这个bundle 是由多个模块组成的，你修改代码文件对应的模块及其依赖模块都是新模块，新模块会把原先的旧模块替换掉。⑥</p><p>这就是整个模块热替换的全部过程，这里我放了一张流程图，你可以参考一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/15/2fd3716c54b10fe645b9a3d4301cdb15.jpg?wh=1980x711\" alt=\"\"></p><p>但是这里会有一个问题，仅仅只是用新模块替换旧模块，会导致原生视图重新渲染，并且丢失原有状态。</p><p>这是因为，新模块的重新执行就意味着，每个新模块中的组件，无论是类组件或者函数组件，都会被重新创建。而 React 在判断是否要更新的时候，会判断更新前后的两个组件是否相等。这样一来，即便新旧组件的代码完全一样，React 也会认为你销毁了原有组件，又创建了一个新的组件。而组件所对应的原生视图，也会发生销毁和重建。</p><p>这就好比，你先创建了一个旧的空对象，然后又创建了一个新的空对象。虽然代码完全一样，都是空对象，但是你用全等去判断时，因为对象是引用类型，创建了一个新对象就创建了一个新的引用，新的引用又不等于旧的引用，所以新对象是不等于旧对象的：</p><pre><code class=\"language-plain\">// 新的空对象 ≠ 旧的空对象\n{} !== {}\n</code></pre><p>同理，当你保存 List 组件时，即便你没有对 List 组件中的代码做任何修改，模块热替换后，React 也会认为，你保存之前的是旧组件，保存之后的是新组件。而新组件不等于旧组件，那它就会帮你销毁旧的原生视图，并重新创建新的原生视图。这个时候，原有组件状态 state 和原生列表的滚动位置都会丢失：</p><pre><code class=\"language-plain\">// 保存前：oldList.js\nexport default function List {}\n// 保存后：newList.js\nexport default function List {}\n// 渲染的都是 List 组件\nrender(){ &lt;List /&gt; }\n// 但是，因为 newList ≠ oldList\nrequire('newList').default !== require('oldList').default\n// 所以，React 会销毁旧的 List 原生视图，创建新的 List 原生视图\n</code></pre><p>也就是说，基础的模块热替换功能只能实现组件级别的强制刷新，而组件状态的丢失，会导致开发效率的降低。</p><p>你想啊，当你要在商品列表页面中开发一个弹窗时，你修改了弹窗组件，一保存，弹窗组件强制刷新了，然后就消失了。你要又点开弹窗，重来一次。弹窗还稍微好点，如果是层级更新的组件，你要多次操作才能使用，如此反复操作，开发效率会变得很低。</p><h2>进阶能力：复用组件及其状态</h2><p>那么，React Native 的快速刷新功能，是如何实现组件状态不丢失，原生视图不重建的呢？</p><p>快速刷新功能复用组件和状态的原理分为两个步骤：</p><ol>\n<li>在编译时，修改组件的注册方式；</li>\n<li>在运行时，用“代理”的方式管理新旧组件的切换。</li>\n</ol><p>在编译时， 快速刷新的 babel 插件 <a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-refresh/src/ReactFreshBabelPlugin.js\">ReactFreshBabelPlugin</a> 修改你的代码，将你的组件转换成可被代理的组件。快速刷新 babel 插件和其他 babel 插件一样，它的功能都是对代码进行转换。正如你使用 babel 可以把 JSX 转换为 JavaScript 一样，快速刷新 babel 插件也可以在你组件源代码中插入一些代码，实现组件的“代理”。</p><p>打一个比方，如果我们要对一个自定义的 Counter 函数组件实现代理。那我们要怎么做呢？首先，在 metro 打包时，快速刷新 babel 插件，找到文件中要导出的 Counter 组件；然后，通过它的函数名、文件名生成一个全局唯一的 ID，例如 ‘Counter.js#Counter’ ；最后，生成一行注册代码。这行代码的作用是，将 ID 作为一个不变的对象标识，用这个不变的对象去“代理”，因模块热替换而变化 Counter 组件，具体你可以看下这里：</p><pre><code class=\"language-plain\">// 源代码\nexport function Counter() {\n  const [count, setCount] = useState(0);\n  const handlePress = () =&gt; setCount(count + 1)\n  return &lt;Text onPress={handlePress}&gt;times:{count}&lt;/Text&gt;\n}\n\nconst __exports_default = Counter\nexport default __exports_default\n\n// 由快速刷新 babel 生成\n// 将组件注册到组件管理中心\nregister('Counter.js#Counter', Counter)\n</code></pre><p>有了编译时插入的注册代码，在运行时，我们就可以用“代理”的方式，管理新旧组件的切换了。</p><p>无论是初次加载的 Count 组件，还是后续模块热替换不断新建的 Counter 组件，都会放在组件注册中心。而“代理”只会在 Count 组件初次加载时创建，创建之后就作为一个不变的对象放在“代理”注册中心。</p><p>在代码保存后，模块热替换会将新的组件代码运行，在新组件被创建的同时，新组件的注册函数就会被执行了。通过唯一的 ID，找到对应的不变“代理”，并将代理的 current 引用，切换到新组件上，完成新旧组件的切换。</p><pre><code>// ReactFreshRuntime.js\n// “代理”注册中心\nconst allFamiliesByID = {}\n\n// 组件注册中心\nconst allFamiliesByType = {}\n\nfunction register(id, componentType) {\n    let family = allFamiliesByID[id];\n\n    if (family === undefined) {\n      family = {current: componentType};\n      // 将不变的“代理”放入“代理”注册中心\n      allFamiliesByID[id] = family\n    } else {\n      // 用不变的“代理”，管理新旧组件的切换\n      const prevType = family.current;\n      family.current = componentType;\n    }\n    // 将所有组件都放入组件注册中心\n    allFamiliesByType[componentType] = family;\n}\n</code></pre><p>这就在保证组件不变的情况下，完成了新旧组件的切换。</p><p>因为代理组件是存在全局对象上的，所以当你保存代码引起模块系统更新时，代理组件的引用也不会发生改变。接着，页面开始更新，此时调用的是代理组件的 render 方法，然后代理组件调用的更新后的新模块组件的 render 方法。你每保存一次代码，模块系统都更新一次，代理组件实际 render 也会进行一次切换，但是只要你的代码没有变化，React 也不会重新创建原生视图。React Native 组件级别的快速刷新，就是通过<strong>代理组件</strong>实现的。</p><p>那究竟是如何实现复用组件及其状态的呢？</p><p>我们先来说状态复用。在我们前面的示例中，我们把 Counter 函数组件，放在了 Counter.js 的文件中，一个文件就是一个模块，如果里面只有一个函数组件的话，我们就可以把它叫做一个函数组件模块。模块代码是执行在该模块的上下文中的，上下文中有着各种变量，其中就包括状态。通过“代理”组件的方式，就可以实现在同一个组件模块的上下文中，执行不同的函数组件。无论是新函数组件，还是旧函数组件，用的都是相同的状态，这就是状态复用。</p><p>那么组件所代表的原始视图的复用又指的是什么呢？</p><p>我们同样打个比方，假设现在你改动的组件要开始渲染 render 了。我们前面提到过，render 时判断是否要重新创建原生视图，是通过浅对比算法 shallowCompare 实现的。如果新旧组件的类型相等就走 re-update 的逻辑不创建，如果新旧组件的类型相等就走 re-mount 的逻辑重新创建。现在，新旧组件的“代理”是就是同一个对象，状态也不会发生改变，浅对比算法判断肯定相等，所以原生视图不会重新创建，从而实现了原生视图的复用。</p><p><strong>简而言之，React Native 的快速刷新功能，就是通过“代理”组件的方式，实现了组件状态不丢失，原生视图不重建。</strong></p><p>这里我放了快速刷新 babel 编译后的复用模型，可以帮助你理解复用的实现原理：</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/a9/6eb61b9eb4d62b0519aed1a2a23e22a9.jpg?wh=1980x711\" alt=\"\"></p><p><strong>当然，并不是所有情况都会复用状态和原生视图。</strong></p><p>这又从何说起呢？我从组件类型的角度来给你解释。组件有两种类型：函数组件和类组件。</p><p>对于函数组件来说，hooks 的顺序非常重要，相同的状态下，不同的顺序会有不同的结果。如果你修改了 hooks 的顺序，快速刷新时就会重新初始化状态。在其他情况下，函数组件的快速刷新都会为你保留状态。</p><p>对于类组件来说，只要是类组件的代码发生更新，组件的内部状态都要重新初始化。关于这点，快速刷新功能的作者 Dan 在博客中解释到，“（保留类组件的状态）热重载是非常不可靠的，最大原因就是类组件的方法是可以被动态替换的。是的，在实例原型链上替换它们很简单，但是根据我的经验，有太多边缘情况了，它根本没有办法可靠地工作”。</p><blockquote>\n<p><a href=\"https://overreacted.io/my-wishlist-for-hot-reloading\">The simple answer is “replace them on the prototype” but even with Proxies, in my experience there are too many gnarly edge cases for this to work reliably.</a></p>\n</blockquote><p>所以，我给你的建议是，<strong>尽可能地拥抱函数组件，放弃类组件</strong>。这样你在 UI 调试的时候，就能更多的享受函数组件带来的状态保留好处。特别是一些入口很深的组件，需要多次操作后才能调试，一旦导航、蒙层、滚动之类的组件状态丢失了，整个操作就要重新再来一遍，才能重新进行调试。拥抱函数组件，你的调试效率才会更高。</p><p>当然，如果项目中已经用到了很多类组件，又要调试一些入口很深的组件，怎么办？方法也很简单，你应该把你要调试的组件，单独拎出来调试。如果拎出来的组件和其他组件有依赖关系，也可以通过 mock 数据的形式对其依赖进行解耦，实现快速调试。</p><p>想象你已经理解快速刷新的基本原理，接下来我们会站在一个更高的视角，看一下快速刷新的完整策略。</p><h2>整体策略：逐步降级</h2><p>在编程调试时，有各式各样的代码，有函数组件、类组件、工具函数和常量等等。那么，是什么样的策略，能让你尽可能地快看到调试结果呢？</p><p>快速刷新的整体策略就是<strong>逐步降级</strong>。如果颗粒度最小的更新不能使用，就换成颗粒度大一些的更新：</p><ul>\n<li>代码块：如果你只修改了函数组件中的一些代码块，并且没有改动 hooks 的顺序。快速刷新在复用状态和原生视图的同时，你对该文件的所有修改都会生效，包括样式、渲染逻辑、事件处理、甚至一些副作用；</li>\n<li>组件：如果你修改了类组件中的任意代码，快速刷新会使用新的类组件进行重新渲染，原来的状态和原生视图都会被销毁；</li>\n<li>模块：如果你修改的模块导出的东西不只是 React 组件，快速刷新将重新执行该模块以及所有依赖它的模块；</li>\n<li>React Native 应用：如果你修改的文件被 React 组件树之外的模块引用了，快速刷新将重新渲染整个 React Native 应用。</li>\n</ul><p>可以看到，快速刷新的逐步降级策略是，<strong>从更新颗粒度最小代码块开始的，然后是组件、模块，最后是大颗粒度的 React Native 应用</strong>。越小颗粒度的更新，为我们保留了越多原来的状态和环境，我们的开发调试效率也更高。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/05/a3a4d0e37df1a44e1b3fb74b491c3d05.jpg?wh=1222x1080\" alt=\"\"></p><p>在调试的过程中，还会有奇奇怪怪的报错发生，比如语法错误、运行时错误和错误边界，这些错误快速刷新都帮你捕获到了。因此，快速刷新还有很强的鲁棒性。</p><h2>总结</h2><p>现在，再回到我们最初的话题，如何提高 UI 调试效率？我相信现在你已经有了答案。</p><p>调试 UI 最重要的是即使反馈和所码即所见。React Native 的快速刷新能力，会把我们的代码修改，尽可能快地展示出来。</p><p>能够实现快速刷新原因是，快速刷新能够通过模块热替换的方式，用我们修改后的新模块替换原来的旧模块。如果，该模块导出的是组件，那么“代理”组件就会将引用从旧组件切到新组件上，实现组件级别的刷新。如果，函数组件且 hooks 顺序没有发生改变，快速刷新时原有的组件状态也会保留。快速刷新时，越小颗粒度的更新，速度越快，调试效率更高。</p><p>要用好快速刷新功能，还有三个小技巧：</p><ol>\n<li>同屏预览。将模拟器置顶在编辑器上方，减少你视野来回切换频率；</li>\n<li>拥抱函数组件。函数组件能保留原有组件状态，减少你操作交互的次数；</li>\n<li>单独拎出来调试。单独拎出来先开发独立组件再集成，可能会比在层层嵌套的代码结构中开发效率更高。</li>\n</ol><h2>思考题</h2><p>今天这一讲介绍的主要介绍的是理论知识，我就不给你留作业了，请你思考一下为什么快速刷新功能的作者 Dan 认为，保留类组件的热重载非常不可靠的，但函数组件却是可行的？</p><p>欢迎在留言区写下你的想法。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"08｜List：如何实现高性能的无限列表？","id":506825},"right":{"article_title":"10｜Debug：解决 BUG 思路有哪些？","id":508776}}},{"article_id":508776,"article_title":"10｜Debug：解决 BUG 思路有哪些？","article_content":"<p>你好，我是蒋宏伟。</p><p>传说中，比尔盖茨在飞机上顺手撸一个 BASIC  解释器，不 Debug 就能直接跑起来。虽然比尔盖茨是“传说级”的程序员，但他写代码也是需要调试的。我们可以在维基百科的 <a href=\"https://www.quora.com/Are-there-programmers-who-write-virtually-bug-free-code\">Altair BASIC </a>词条看到：</p><blockquote>\n<p>盖茨和艾伦从波士顿的分时租赁服务中购买了电脑上机时间来完成 BASIC 程序的调试。</p>\n</blockquote><p>但现实中，我们大部分情况都很难做到不 Debug，不调试就能把代码顺利上线，更多情况下，我们都需要和 Bug 做一番搏斗。</p><p>从搭建环境时 Gitlab 拉下来的代码跑不起来，到开发过程修改一段代码逻辑总是报错，再到产品上线后也时不时地有产品、测试、老板找过来反馈线上问题。无论是已经存在的、还是潜在的 Bug，这些都需要我们去发现和解决。不是有调侃的话么？我们程序员“不是在解决 Bug 的路上，就是在写 Bug 的路上”。</p><p>这话虽然只是一句调侃，但是这也侧面印证了两点：一方面是，我们会遇到很多 Bug，也会花很多时间去解决 Bug；另一方面是，我们直接裸写的代码可能存在较多的潜藏 Bug，我们得花精力把这些潜藏的 Bug 给找出来。那面对这些 Bug，有没有什么通用的解决思路呢？</p><p>这正是今天我要和你介绍的，我把它概括为“1+2+3”，也就是一个模型，两个原则，三条思路。</p><!-- [[[read_end]]] --><h2>一个模型：发现问题、找到原因、修复 Bug</h2><p>那么，一个模型是什么呢？</p><p>一个模型指的是，<strong>发现问题</strong>、<strong>找到原因</strong>、<strong>修复 Bug</strong> 的三步模型。其实这就是我们日常解决 Bug 的常规步骤，我只不过把它划分归类了一下，接着你就会看到划分的好处了。</p><p>虽然我们遇到的 Bug 形形色色、各不相同，但当你把解决问题划分为三步之后，我们就可以针对不同的步骤给出不同的解题思路了。每个 Bug 都有每个 Bug 修复的思路，但大部分的 Bug 在发现问题和找到原因这两步，是可以找到一些通用方法的。而我接下来要讲的“两个原则”，说的就是发现问题这一步的两个原则，“三条思路”说的就是找到原因这一步的三个思路，这些原则和思路都是通用的。</p><p>在发现问题和找到原因这两步中，我们也离不开团队成员的相互协作，以及各种调试工具支持。因此，在讲原则和思路的过程中，我也会和你介绍流程该怎么走，工具该怎么用。</p><p>另外，这里还需要你注意，狭义和广义调试是有所不同的。狭义的调试，指的是代码运行时打日志、打断点；但广义的调试，指的是发现问题和解决问题的过程（Debugging is the process of finding and resolving bug）。</p><p>任何能够帮助我们发现和解决问题的工具，都可以归类为广义的调试工具，甚至上线流程也是可以为调试服务的。当你把视野打开之后，思路也变广一些，这可以让你可以更快地、更容易地发现问题和解决问题。</p><p>我给你画了一张调试的全貌示意图，把调试的三步模型、上线流程和广义上的调试工具都画上去了。你先停下来看一下，接下来我也会进行更详细的介绍。</p><p><img src=\"https://static001.geekbang.org/resource/image/83/c0/8326a0d730d4ac2fd526ec02dc7125c0.png?wh=1504x1504\" alt=\"图片\"></p><h2>两个原则：不带上线原则和本地复现原则</h2><p>我先和你介绍发现问题这一步的两个原则：不带上线原则和本地复现原则。</p><ol>\n<li>不带上线原则：要尽可能早地在本地开发时发现问题，提前发现问题是不带 Bug 上线的必要条件；</li>\n<li>本地复现原则：如果 Bug 已经被带上线了，我们要尽快发现它，还要尽可能多地收集线上信息，让它能更容易地在自己的手机或本地复现。</li>\n</ol><p>不带上线原则怎么实践呢？首先，我们要清楚，没有任何的线上 Bug 是不可能的，但我们可以减少带上线的风险，比如团队成员之间可以通过合作建立一套完善的上线流程，依靠流程和机制来减少风险。其次，在这套流程和机制下，我们自己可以选择合适的工具来减少风险。</p><p>那么，一个理想的上线流程和配套工具是什么样的呢？我认为 GitHub 社区其实已经为我们提供了一种答案。</p><p>GitHub 社区中那些流行的仓库都有一套完整的上线流程，比如 React、React Native 仓库，一般都有<strong>自动化的本地校验和线上校验，还有项目成员的 Code Review</strong>。这套流程经历了上千人的校验，我认为是非常有学习和实践价值的。</p><p>在本地开发时，需要针对开发的新增的模块写一个新的单元测试。在提交代码的时候，有 git hook 的自动脚本来执行我们的 Jest 单元测试，并校验 TypeScript、ESLint 是否通过，只有校验通过之后才能提交。在提交到远程仓库后，还有机器人再校验一次，并且只有在机器人校验和项目成员的 Code Review 通过后才能把代码合到主分支。</p><p>而理想上线流程的另一套答案，其实也是大部分团队都在实践的答案。</p><p>当我们把新功能推到的代码仓库的主分支中，我们还需要把主分支中的代码进行上线。在上线过程中，我们需要靠 UI 验收、靠 QA 测试、靠 PM 体验，靠团队的力量来尽早发现 Bug。必要的时候，还可以在上线平台上下功夫，比如只有 QA 拥有上线权限，又比如做 A/B 测试、灰度测试等。</p><p>但即便如此，也难免会将一些本地 Bug 带上线，因此我们还需要快速发现线上 Bug。</p><p>大部分时候，那些线上的、偶现的、没有报错信息的 Bug，比本地的、必现的、有报错信息的 Bug，更加缺乏有效信息，也更难发现。对于线上 Bug 而言，<strong>快速发现线上 Bug关键是对线上数据的收集，并通过收集的数据来进行分析，使其能在本地复现</strong>。线上 Bug 本地复现之后，剩下的修复思路就和本地 Bug 的修复思路是一样的了。</p><p>这个时候，我们有两种工具可以利用，一种是监控系统，另一种是用户反馈系统。</p><p>在技术层面接入一套监控系统，比如腾讯出品的常用于原生应用监控的 Bugly，或者开源领域的 Sentry，又或者是自研的监控平台，这些都是可以的。在产品层面上，我们需要有一套用户反馈机制，它们的核心作用是发现那些本地难以复现、又缺乏线上报错数据的 Bug。</p><p>实际上，每个团队、每个项目的情况都不一样，你可以根据自己项目的情况进行选择。</p><h2>三条思路：一推理、二分法、三问人</h2><p>发现问题之后，接着就要寻找问题的原因。寻找问题的原因有哪些思路呢？我有 三条思路供你参考：“一推理”、“二分法”、“三问人”。</p><p>所谓的“一推理”，它指的是，我们遇到问题首先要做的是<strong>冷静地思考、分析和推理</strong>，要搞清楚问题是什么，知道问题是什么了，能直接解决的就自己直接解决，不要一开始就去网上搜答案。网上答案很多，但搜索正确答案成本很高，而且别人的答案不一定能解决你的问题。</p><p>你不妨先从红屏报错中提炼有用信息，再检查代码逻辑是否有明显错误并得出初步判断，然后打日志、打断点，再重新跑一次代码，验证你的判断。如果遇到的是复杂代码，可以从代码模块的出口入口着手来判断，然后再分析代码内部细节。在分析阶段中，我们也离不开（狭义）调试工具的支持。</p><ul>\n<li><strong>红屏信息：</strong><br>\n对于那些本地的、必现的、有红屏报错的 Bug 而言，红屏信息有时候能帮你直接指出是你的代码哪里有问题。</li>\n</ul><p>即便是那些没有提供具体报错代码的红屏报错，也会提供一些有用信息，只是这些有用信息需要你想一下才能分析出来。有些人在遇到红屏报错时，只是稍微看了一眼红屏信息，并不会去仔细地研究红屏信息内容，就直接动手开始改起代码了。这就相当于，有一份地图你不用，就直接闯起了迷宫。</p><p><strong>当你遇到红屏时，应该先认真读一遍红屏中的报错信息，第一遍没读懂没关系再多读几遍</strong>，英文不熟也不要紧，可以翻译一下，看看有什么关键字，再仔细想一下。很多时候，当你真的这么做了就找到原因了，不用后面那些分析步骤了。</p><ul>\n<li>\n<p><strong>检查逻辑：</strong><br>\n有时候呢，我们可以根据红屏提供的执行结果，猜出大致的问题范围。这时候呢，你可以先在脑袋里面过一遍代码执行过程，先检查一下自己是不是有拼写错误、API 的使用方法对不对、一些边际条件有没有考虑到等等。检查一遍之后，即便没有找到原因，心里多多少少会有一些判断。</p>\n</li>\n<li>\n<p><strong>执行代码：</strong><br>\n在你有这些判断后，你就可以通过打日志、打断点等方式来验证你的判断，找到到底是哪个变量或者是哪段逻辑有问题了。</p>\n</li>\n</ul><p>这里需要和你强调的是，不要一上来毫无头绪就开始打日志、打断点，这样做效率很低。<strong>一定要先检查代码、先判断原因，再去打日志、打断点去验证你的判断，这样你的调试能力、逻辑能力才会慢慢变强，调试速度才能慢慢提高。</strong></p><ul>\n<li><strong>出口入口：</strong><br>\n有时候代码太复杂了，代码内部执行的步骤太多了，要寻找是具体是哪段逻辑有问题就太难了。这时候，你可以先对代码的入口或出口的数据进行分析。比如，函数组件可能有问题，你可以通过工具查看元素树的结构和具体元素属性；又比如，前后端交互的请求可能有问题，你可以抓包看请求内容；再比如，本地磁盘存储结果有问题，你可以去查看存储结果。</li>\n</ul><p>从出口和入口开始分析先得出结论，再打日志、打断点定位问题原因，有时候可能比直接分析复杂代码的内部逻辑得出结论，要更快一些。</p><ul>\n<li><strong>分析工具：</strong><br>\n在分析阶段，必不可少的就是（狭义）调试工具，像打日志、打断点、抓包请求、查看存储这些功能都需要调试工具的支持。我给你画了一张调试工具功能图，涵盖了各类调试工具的支持程度：</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/ca/5c/ca825d7cdyy4d0513f8244bac454c45c.png?wh=1724x810\" alt=\"图片\"></p><p>我们简单分析下这几个工具。首先是弹窗 alert，它的好处是依赖任何环境，但一个弹窗能展示的内容太少了，只有在线上环境我才会用到它。</p><p>接着是终端 Terminal，你在本地通过 Terminal 启动打包工具 Metro 的服务时，你的调试代码就和 Terminal 建立了连接，你通过 console.log 打印的日志，都会在 Terminal 显示。使用它时，你不必单独下载其他任何的调试工具。据我所知，很多人排查问题只靠 Terminal 打日志，但实际上还有其他更好用的工具。</p><p>比如 Facebook 出品的移动应用调试工具 Flipper 就不错，但你需要单独进行下载。它的功能很强大，打日志、打断点、查看元素树、抓包请求、查看存储它都支持，而且支持扩展插件。</p><p>比较流行的调试工具还有 React Native Debugger、Reactotron，如果涉及原生代码，你还可用  Android Studio、Xcode 进行调试。</p><p>这些工具你不必每个都要学会怎么使用，选择几个你顺手的即可。工具只是辅助，关键是分析本身，调试工具只要够用就行。我平时用得比较多的是 Terminal 和 Flipper。</p><p>看完第一招，我们再来看第二招：“二分法”。</p><p>在你遇到不知道是什么原因引起的 Bug 时，你可以试试这招。<strong>所谓的“二分法”，</strong>说的是在我们不能确定问题原因的时候，<strong>把所有潜在的问题都用类似“数组二分查找”的方式把代码遍历一遍，</strong>不断缩小问题的范围，最终找到问题原因。</p><p>“二分法”怎么分呢？一个排除疑难杂症的通用思路是这样的，我们的代码是运行在环境中的，代码本身也有多个版本的、同一个版本中代码也是分多个模块的。那我们就可以从环境、版本、模块入手排查。</p><p>我们先把环境和代码分开，先排查环境原因，如果别人的电脑、手机都没有问题，我的有问题，那就可以判断是我的电脑、手机的环境有问题，否则就是代码问题。</p><p>如果是代码问题，我们再排查上一个上线版本有没有问题，上一次 commit 的代码有没有问题，如果上一次也有问题就是历史遗留问题，否则就是新引入的问题。</p><p>如果是新引入的问题，再从根组件开始排查，一个 React Native 应用（或页面）只有一个 Root 组件，一个 Root 组件有若干个子组件，子组件又有自己的子子组件，这就组成了一个组件树，你只要顺着 Root 组件一步一步地进行二分判断，看哪一边的子树是有问题的，哪一边的子树是没有问题的，最终就能确定问题代码的范围了。</p><p>“二分法”的思路是从整体到局部，它还有一个变种就是“多分法”。比如首屏性能问题，用户从点击、到请求、再到渲染的过程是一个整体，你可以把这个整体中各个阶段中的关键节点都埋上性能统计埋点，找到那些优化收益率高的、做起来容易的地方去优化。只有从整体的视角出发，分析出每个局部的优化空间有多少，你才能判断各个技术方案的投入产出比（ROI），做出全局最优的决定。</p><p>如果前面两招用完，还解决不了问题呢？不用着急，我们还有<strong>第三招：三问人。</strong></p><p><strong>所谓的“三问人”，说的是我们借鉴别人的经验来解决自己的问题，别人可以是同事、朋友、微信群，也可以是搜索引擎。</strong></p><p>搜索引擎相信你也经常用，所以我只和你重点说一下我的使用技巧和经验。</p><p>首先，Google 搜到的资料更全一些有博客、论坛、GitHub、学习型网站，百度搜到的大多是国内开发者的博客。另一类就是专业的技术网站，比如 GitHub 和 Stack Overflow，这类专业技术提供的搜索引擎的搜索效率，有时候比 Google 还要更高一些。有时候我在 Google 搜索出的内容不是我想要的，我就会跑到 GitHub 的 React Native 仓库的 Issues 中和 Stack Overflow 上直接搜索，它们推荐的内容就会更加精准一些。</p><p>有些英语差的同学可以会觉得，使用 Google、GitHub 这类以英文为主的网站，语言是个门槛。我的建议是你多用翻译引擎，使用工具来打破这个语言门槛。你不着急的时候，英语文章可以一个词地一个词地慢慢看，这也能提升自己的英语水平，但工作中毕竟是以效率优先，我推荐你使用 DeepL 翻译引擎，在 DeepL 的宣传资料中，它的中英互译的准确性比 Google 等翻译引擎要强上 5 倍，我的实际使用感受也确实是准确很多。</p><h2>课程小结</h2><p>广义上讲，调试就是发现问题和解决问题。那如何调试呢？我有 “一个模型、两个原则、三条思路”和你分享。</p><ul>\n<li>一个模型：这个模型包括，调试的三个步骤发现问题、找到原因、修复 Bug，还包括配套的广义调试工具、团队上线流程。这个广义的调试模型，相对于狭义上的调试，它的意义在于能帮我们扩宽解决 Bug 的思路；</li>\n<li>两个原则：这两个原则是不带上线原则和本地复现原则。不带上线原则强调的是，调试不仅仅是解决问题，更是提前发现问题减少线上 Bug；本地复现原则强调的是，解决线上 Bug 的关键是能在本地复现问题，而复现问题很依赖监控系统和反馈系统；</li>\n<li>三条思路：你可以先用“一推理”，再用“二分法”、最后是“三问人”来解决具体 Bug 。</li>\n</ul><h2>补充材料</h2><p><strong>自带工具：</strong></p><ul>\n<li><a href=\"https://reactnative.dev/blog/2019/11/18/react-native-doctor\">react-native doctor</a>：可以帮忙检查本地环境是否搭建是否有问题。</li>\n<li><a href=\"https://reactnative.dev/docs/debugging#performance-monitor\">Perf Monitor</a>：调试情况下摇一摇手机，就会有一个弹窗，其中 Perf Monitor 功能可以帮你查看本地的 JavaScript FPS  和 Native FPS。</li>\n<li><a href=\"https://reactnative.dev/docs/debugging#inspecting-component-instances\">Inspect</a>：摇一摇中的 Inspect 功能，可以帮我们查看组件树的结构。</li>\n</ul><p><strong>搜索工具：</strong></p><ul>\n<li>翻译：<a href=\"https://www.deepl.com/translator\">DeepL</a>、谷歌翻译  百度翻译。DeepL 还有客户端，配合快捷键使用更方便。</li>\n<li>搜索：谷歌搜索、百度搜索</li>\n<li>专业网站：<a href=\"https://github.com/facebook/react-native/search?type=issues\">React Native GitHub Issues</a>、<a href=\"https://stackoverflow.com/\">Stack Overflow</a></li>\n</ul><p><strong>第三方工具：</strong></p><ul>\n<li><strong>（推荐）Facebook 推出的移动应用调试工具</strong><a href=\"https://fbflipper.com/\">Flipper</a>；</li>\n<li>（不推荐）微软推出的 VSCode 插件 <a href=\"https://marketplace.visualstudio.com/items?itemName=msjsdiag.vscode-react-native\">React Native Tools</a>；</li>\n<li>（不推荐）Infinitered 推出的 <a href=\"https://github.com/infinitered/reactotron\">Reactotron</a>；</li>\n<li>（不推荐）<a href=\"https://github.com/jhen0409/react-native-debugger\">React Native Debugger</a>。</li>\n</ul><h2>作业</h2><ul>\n<li>平时你用的调试工具是什么？你为什么选择它？</li>\n<li>结合这一讲提供的  “一个模型、两个原则、三条思路”，思考一下，你遇到过那些疑难杂症，最终你是怎么解决它的？</li>\n</ul><p>欢迎在评论区写下你的思考和想法。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"09｜Fast Refresh：提高 UI 调试效率神器","id":507846},"right":{"article_title":"11｜组件实战：如何实现瀑布流？","id":509753}}},{"article_id":509753,"article_title":"11｜组件实战：如何实现瀑布流？","article_content":"<p>你好，我是蒋宏伟。</p><p>现在，国内购物 App 的首页大都采用了双列瀑布流的布局，假如你的产品经理也想实现同样的瀑布流效果，你在网上找了很多的 React Native 列表组件，但都满足不了需求，你会怎么办？你会选择改让产品改方案，还是自己再研究研究？</p><p>大概是 2019 年的时候，我们的产品也提了同样的需求，使用 React Native 实现瀑布流效果。当时我们有个同事试了很多方案，比如双 List、多层嵌套 List，性能都很差效果不好，后来我们开会的时候提到了这个问题，我也参与了讨论。</p><p>当时我提出了一种思路：改 RecyclerListView 的源码。我说，RecyclerListView 的布局原理是绝对定位，每个 item 的 x、y 轴坐标是根据传入的 height、width 值算出来的，现在它的布局算法是单列的，我们只要把单列布局算法改成双列布局算法，这件事情应该能成。</p><p>后来我们团队的另一个大牛把它落地实现了，实现了一个 React Native 瀑布流页面。</p><p>在准备写实战案例的时候，我又想起了当初的这个事情。使用瀑布流的业务场景很多，却没有直接能用的开源方案，但它的实现原理其实并不复杂，应该是一个很好的实战案例。于是我就基于 RecyclerListView 最新的版本，又实现了一版。</p><!-- [[[read_end]]] --><p>我今天就和你讲讲，我是如何通过修改 RecyclerListView 组件的源码，实现瀑布流效果的。希望你能通过这次实战，把我们以前学的知识和技巧都用起来。也只有通过实战才能<strong>把知识变成能力</strong>，快和我一起动手试试吧。</p><h2>准备开发调试环境</h2><p>关于 RecyclerListView 的基础用法，我在《List》一讲中已经介绍，它主要是通过列表数据 dataProvider 来驱动列表项的渲染 rowRenderer，并且指定为列表项指定了布局方式 layoutProvider。</p><p>现在，你需要做的是准备开发调试环境。准备开发调试环境永远是第一步，而且现在我们要调试的是放在 node_modeuls 目录下的第三方组件 RecyclerListView，所以现在我们要准备<strong>第三方依赖包的开发调试环境</strong>，这怎么准备呢？</p><p>在 React Native 中，我们是通过 import 导入第三方模块 RecyclerListView 的：</p><pre><code class=\"language-plain\">import {RecyclerListView, DataProvider, LayoutProvider} from 'recyclerlistview';\n</code></pre><p>这段代码的意思是从<code>recyclerlistview</code>模块中导入 RecyclerListView 组件、DataProvider 列表数据类、LayoutProvider 布局方式类。</p><p>那<code>recyclerlistview</code>模块到底在哪呢？通常情况下，该模块是<code>node_modules/recyclerlistview</code>目录下的 <code>index.js</code>文件<code>export</code>导出的模块。不过第三方库，也可以通过<code>package.json</code>中的<code>main</code>字段进行配置。<code>recyclerlistview</code>采用的就是这种配置方法：</p><pre><code class=\"language-plain\">// node_modules/recyclerlistview/package.json\n{\n  \"name\": \"recyclerlistview\",\n  \"main\": \"dist/reactnative/index.js\",\n  ...\n}\n</code></pre><p>你看，在<code>recyclerlistview</code>的<code>package.json</code>文件中，它通过<code>main</code>参数指定了模块路径<code>dist/reactnative/index.js</code>。</p><p>但你再看下 <code>recyclerlistview</code> 的目录：</p><pre><code class=\"language-plain\">node_modules/recyclerlistview/\n├── dist\n│   └── reactnative\n│       ├── core\n│       └── index.js\n├── src\n│   ├── core\n│   └── index.ts\n└── package.json\n</code></pre><p>你会发现，<code>dist</code>目录下放的是编译后的 .js 文件。也就是说，如果我们直接跑项目，只能调试编译后的 .js 文件，不能调试放在 <code>src</code> 目录中的 .ts 源码。</p><p>那怎样才能调试 .ts 的源码文件呢？有一招很简单，修改 <code>recyclerlistview</code> 的导出模块的配置：</p><pre><code class=\"language-plain\">// node_modules/recyclerlistview/package.json\n\n- \"main\": \"dist/reactnative/index.js\"\n+ \"main\": \"src/index.ts\"\n</code></pre><p>你只需把<code>recyclerlistview/package.json</code>的 <code>main</code>参数改为<code>src/index.ts</code>即可，React Native 会在编译时通过 babel 将 .ts、.tsx 文件编译为 .js 文件再执行。</p><p>改完之后，你再重新跑一次<code>yarn start</code> ，会遇到一个报错：</p><pre><code class=\"language-plain\">error: node_modules/recyclerlistview/src/core/RecyclerListView.tsx: \n\n`import debounce = require('lodash.debounce')` is not supported by @babel/plugin-transform-typescript\n\nPlease consider using `import debounce from 'lodash.debounce';` alongside Typescript's --allowSyntheticDefaultImports option.\n\n&gt; 21 | import debounce = require('lodash.debounce');\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n</code></pre><p>现在我们来分析这个报错信息。你还记得解决具体 BUG 的顺序吗？“一推理”、“二分法”、“三问人”。</p><p>遇到报错先不用着急去网上搜，先看看红屏的报错提示。第一行报错，说的是<code>core/RecyclerListView.tsx</code>文件中有报错。第二行，说的是 <code>@babel/plugin-transform-typescript</code> 插件不支持 <code>import = require()</code> 的导入语法。第三行，直接把建议答案告诉你了，你可以用<code>import from</code>的语法进行导入。第四行，提示了具体是哪行代码报错了。</p><p>你看，这类报错信息都把答案都告诉我们了，我们只要认真读一下就行，我们的“一推理”刚刚开始，就把这个 BUG 解决了，都用不着后面的“二分法”和“三问人”。</p><p>在你把代码跑起来后，还需要准备一下调试工具 Flipper 和 React Native Tool。</p><p>Flipper 调试工具，你只需要下载一下就行，它的功能很强大：</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/d1/e4e1f3a26e124dd4c582342ayy70b7d1.png?wh=1726x3472\" alt=\"图片\"></p><p>这张长截图显示了 Flipper 的功能，从上到下依次是打印日志 Logs、组件树 Components、性能火焰图 Profiler、宿主组件树和布局 Layout、网络请求 Network。它还有一个功能是支持 Hermes 引擎 Debugger，它和浏览器的 Debugger 类似，这里我没有进行截图了。</p><p>现在 RecyclerListView 源码已经跑起来了，调试环境也已经准备完成，接着下一步就是找到控制布局的关键源码。</p><h2>找到关键源码</h2><p>要找到关键源码，我们得先从整体上理解源码。很多人读源码没有方法，不知道从哪里入手，甚至有些程序员从来没有读过别人的源码。其实写代码和读代码，就像写文章和读文章的关系一样，<strong>没有大量的阅读积累，怎<strong><strong>么</strong></strong>能写出好的代码呢？</strong></p><p>理解 RecyclerListView 这类复合组件的源码，我有一个技巧，就是从复合组件 JSX 部分开始切入。</p><p>这时我们能直接观察到的是 UI 视图，以 UI 视图为锚点，去理解 JSX 文件就很容易了。在你了解  JSX 之后，再根据状态 <code>state</code> 和属性<code>props</code>去推断组件的内部逻辑 <code>f</code> ，会容易很多。一个页面，无非也就是由这几个部分组成：</p><pre><code class=\"language-plain\">UI/JSX = f(state, props)\n</code></pre><p>了解了基本方法，现在我们开始分析RecyclerListView组件的源码，请你先<strong>在本地打开</strong> <a href=\"https://github.com/Flipkart/recyclerlistview/blob/master/src/core/RecyclerListView.tsx\">RecyclerListView 的源码文件</a>。下面是我从 RecyclerListView 类组件摘出来的 3 个和 JSX 相关的方法：</p><pre><code class=\"language-plain\">// node_modules/recyclerlistview/src/core/RecyclerListView.tsx\npublic renderCompat() { // 先调用 render 后调用它\n  return (\n    &lt;ScrollComponent&gt;\n      {this._generateRenderStack()}\n    &lt;/ScrollComponent&gt;\n  );    \n}\n\nprivate _generateRenderStack(){\n  for(const key in this.state.renderStack){\n    renderedItems.push(this._renderRowUsingMeta(this.state.renderStack[key]))      \n  }\n  return renderedItems\n}\n\nprivate _renderRowUsingMeta() {return &lt;ViewRenderer/&gt;}\n</code></pre><p>它们分别是：</p><ul>\n<li><code>renderCompat</code> 方法：实际就是类组件的 <code>render</code>方法，它最外层是一个滚动组件<code>ScrollComponent</code> ；</li>\n<li><code>_generateRenderStack</code>方法：循环了状态 <code>state.renderStack</code>，生成了若干个<code>renderedItems</code>；</li>\n<li><code>_renderRowUsingMeta</code> 方法：返回的是具体的<code>renderedItems</code> ，也就是<code>ViewRenderer</code>容器元素。</li>\n</ul><p>当你把 UI 视图和 JSX 部分联系在一起时你就明白了，RecyclerListView 渲染出的 UI 页面，是由一个滚动容器和若干个<code>ViewRenderer</code>容器组成的。</p><p>我们还是回到最基础的 UI 公式：</p><pre><code class=\"language-plain\">UI/JSX = f(state, props)\n</code></pre><p>现在我们已知 <strong>JSX</strong> 是 ScrollView + View，已知 <strong>state</strong> 是用 <code>for...in</code>循环的对象 renderStack，还已知 RecyclerListView 的三个必传 <strong>props</strong>：列表数据 dataProvider(dp)、列表项的布局方法 layoutProvider、列表项的渲染函数 rowRenderer。</p><p>这时虽然你还不知道组件内部逻辑 <code>f</code> 具体是什么，但是你应该已经把握住了函数的“入口”和“出口”，你知道放进去的入参是什么，能够产出的 UI 又是什么。知道了“入口”“出口”的特点后，再从两端往中间推理，理解组件内部逻辑 <code>f</code>就会变得简单很多。</p><p>这时候，你可能会有一些关于内部逻辑<code>f</code>的问题，你或许想问<code>state.renderStack</code>和三个 props 是怎么控制 JSX 的？</p><p>那我们就要再仔细读一下<code>_renderRowUsingMeta</code>中的代码了：</p><pre><code class=\"language-plain\">private _renderRowUsingMeta(itemMeta: RenderStackItem): JSX.Element | null {\n  const dataIndex = itemMeta.dataIndex;\n  const data = this.props.dataProvider.getDataForIndex(dataIndex);\n  const type = this.props.layoutProvider.getLayoutTypeForIndex(dataIndex);\n  return (\n    &lt;ViewRenderer\n      data={data}\n      layoutType={type}\n      index={dataIndex}\n      layoutProvider={this.props.layoutProvider}\n      childRenderer={this.props.rowRenderer}\n    /&gt;\n  );\n}\n</code></pre><p>在这段源码中，我只标记出了 state、props 和 ViewRenderer 三个部分，即便只有这些代码片段，你可以猜出它的大致逻辑。</p><p>状态 <code>state.renderStack[key]</code> 就是 <code>itemMeta</code>，每个 <code>itemMeta</code> 的 <code>dataIndex</code> 是不一样的，通过 <code>dataIndex</code> 从列表数据 dataProvider  和布局方法 layoutProvider 中，选取了对应项的数据 <code>data</code> 和布局类型 <code>type</code> ，并将这些值和列表项的渲染函数 rowRenderer 都赋值给了 <code>ViewRenderer</code>的<code>childRenderer</code>属性。</p><p>读完这段源码片段，你大概能够补全此段代码的内部逻辑<code>f</code>。<code>ViewRenderer</code> 是一个容器，内部装的是你传给它的渲染函数 rowRenderer 方法，并且按照你指定的数据<code>data</code>、类型<code>type</code> 进行渲染。</p><p>因为<code>ViewRenderer</code>是你指定的列表项<code>rowRenderer</code>的父容器，父容器的位置决定了你列表项的位置。这时候，你再读一遍<code>_renderRowUsingMeta</code>的源码：</p><pre><code class=\"language-plain\">  private _renderRowUsingMeta(itemMeta: RenderStackItem): JSX.Element | null {\n    const dataSize = this.props.dataProvider.getSize();\n    const dataIndex = itemMeta.dataIndex;\n    const itemRect = (\n    this._virtualRenderer.getLayoutManager() as LayoutManager\n    ).getLayouts()[dataIndex];\n    return (\n      &lt;ViewRenderer\n        key={key}\n        data={data}\n        x={itemRect.x}\n        y={itemRect.y}\n        layoutType={type}\n        index={dataIndex}\n        layoutProvider={this.props.layoutProvider}\n        onSizeChanged={this._onViewContainerSizeChange}\n        childRenderer={this.props.rowRenderer}\n        height={itemRect.height}\n        width={itemRect.width}\n      /&gt;\n    );\n  }\n</code></pre><p>在这个源码片段中，这些由<code>LayoutManager</code>类的<code>getLayouts</code>方法生成的 x/y/width/height 属性，就是决定你列表项布局方式的关键源码。</p><p>但 <code>getLayouts</code> 到底是什么呢？请你打开 <code>LayoutManager</code> 类的源码：</p><pre><code class=\"language-plain\">// node_modules/recyclerlistview/src/core/layoutmanager/LayoutManager.ts   \n   public getLayouts(): Layout[] {\n        return this._layouts;\n   }\n\n    public relayoutFromIndex(): void {\n        let startX = 0;\n        let startY = 0;\n        let maxBound = 0;\n\n        for () {\n            oldLayout = this._layouts[i];\n            if () {\n                itemDim.height = oldLayout.height;\n                itemDim.width = oldLayout.width;\n                maxBound = 0;\n            }\n            while () {\n                startX = 0;\n                startY += maxBound;\n            }\n\n            maxBound = Math.max(maxBound, itemDim.height);\n            this._layouts.push({ x: startX, y: startY, height: itemDim.height, width: itemDim.width, type: layoutType });\n\n        }\n    }\n</code></pre><p>上述的代码片段是 <code>getLayouts</code> 方法和设置<code>this._layouts</code>的<code>relayoutFromIndex</code>方法。大致扫一眼，你就能明白<code>relayoutFromIndex</code>方法通过一堆计算，计算出了实现单列布局的 x/y/height/width 值，然后把它们作为对象 push 到了 <code>this._layouts</code>。</p><p>而 ViewRenderer 根据 <code>this._layouts</code> 把你的列表项，渲染到了指定的位置上。因此，我们要想实现双列瀑布流布局，就得理解和修改 <code>relayoutFromIndex</code> 方法。</p><h2>修改源码</h2><p>在“找到关键源码”这一步，我们读源码其实只要有宏观上的理解就行了，但要“修改别人源码”就需要更微观上的理解了。</p><p>我说的宏观上理解源码，讲究的是速度，大致理解就行，细节上有点小偏差也不要紧。但微观上理解源码，讲究的是准确，我们要改别人的源码，理解要是不准确，改起来肯定容易出问题。</p><p>在提高理解的准确性上，我是这么做的。首先我会使用断点工具，一行一行地执行代码，并对上下文中的变量进行一些“终极拷问”：“变量从哪来”、“变量用到哪里去”、“变量的意义是什么”，再把自己的理解马上备注起来，不然容易忘。</p><p>在微观理解上，我们也要找到切入点。比如，在理解 <code>relayoutFromIndex</code> 方法时，我找的切入点就是设置列表项的 x/y。设置 x/y 的核心代码如下：</p><pre><code class=\"language-plain\">  public relayoutFromIndex(itemCount: number): void {\n    // 新 item x y 坐标\n    let startX = 0;\n    let startY = 0;\n    // 记录当前一行最高元素的高度\n    let maxBound = 0;\n\n    for (let i = 0; i &lt; itemCount; i++) {\n\n      // 如果当前多个 item 宽度之和超过屏幕宽度就换行\n      while (!this._checkBounds(startX, startY, this._layouts[i])) {\n        // 将实际 x 坐标设置为 0\n        startX = 0;\n        // 将实际 y 坐标设置增加上一行最高 item 的高度\n        startY += maxBound;\n        maxBound = 0;\n      }\n\n      // 设置新的宽高\n      this._layouts.push({ x: startX, y: startY, height: itemDim.height, width: itemDim.width, type: layoutType });\n\n      // 记录当前一行最高 item 的高度\n      maxBound =  Math.max(maxBound, this._layouts[i].height);\n      // 默认情况下：下一个 item 的初始化的 x 坐标\n      startX += itemDim.width;\n    }\n  }\n  private _checkBounds(\n    itemX: number,\n    itemY: number,\n    itemDim: Dimension,\n  ): boolean {\n    return itemX + itemDim.width &lt;= this._window.width;\n  }\n</code></pre><p>虽然我已经把代码精简并写了备注，但理解起来可能还是有点难度，所以我还给你配了单列布局的原理示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/c0/a8/c03b10ea793948d7f280072a857964a8.png?wh=1920x556\" alt=\"图片\"></p><p>单列布局的原理是什么呢？</p><p>从代码层面看，它对你传入的列表项进行<code>for</code>循环遍历，并通过 <code>_checkBounds</code>方法来判断。如果当前遍历的列表项宽度和当前一列已有列表项的宽度之和，不超过屏幕宽度，也就是<code>itemX + itemDim.width &lt;= this._window.width</code>，那么就跳过 <code>while</code> 循环，直接使用同一行前几个列表项的宽度之和<code>startX += itemDim.width</code> ，作为当前列表项的 x(startX) 坐标。也就是情况一：<strong>宽度足够，放到同一行。</strong></p><p>如果<code>_checkBounds</code>判断，同一行剩余宽度不够了，那么就进入  <code>while</code> 循环，将当前列表项的 x(startX) 坐标设置为 0，y 坐标设置增加上一行最高 item 的高度<code>maxBound</code>。也就是情况二：<strong>宽度不够，放到下一行。</strong></p><p>我还在图中给你画了一个单列布局的例子。第一行 A、B 列表项宽度正好占满整个屏幕宽度，所以列表项 C 得再起一行，其 x 坐标为 0，其 y 坐标为 A 的 y 坐标和 B 的高度 height 之和。列表项 C 横向独占了一行，所以 D、E 就只能放到下一行了。整体上看，RecyclerListView 实现的还是一种单列布局，只不过同一行中可以放置多个列表项。</p><p>理解完 RecyclerListView 的单列布局源码后，接下来就要设计我们自己的双列瀑布流布局了。我给你画了一张瀑布流的示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/93/9c/938fbe382fc3438c4ee41ed01c8eab9c.png?wh=1920x548\" alt=\"图片\"></p><p>双列瀑布流布局只有两种情况，第一种情况是如果左边已有列表项的高度之和  <code>startLeftY</code> 大于右边已有列表项的高度之和 <code>startRightY</code>，那么下一个列表项就要放右边。第二种情况则刚好相反，我们需要把下一个列表项放在左边。简单来说就是，<strong>左高放右、右高放左。</strong></p><p>我同样给你举了一个例子，你可以对照双列瀑布流布局的图片看一下。起始时左右两边一样高，所以先是左 A，再是右 B。接下来，由于左边比右边高，所以再是右 C，最后是左 D。如果是单列布局，C 应该放在左边，D 应该放在右边，这就是双列瀑布流布局和单列布局不同之处。</p><p>双列瀑布流实现的核心代码如下：</p><pre><code class=\"language-plain\">  public relayoutFromIndex(startIndex: number, itemCount: number): void {\n\n    // 假设: 每个 item 的宽度为 1/2*window.width 两种情况\n    const halfWindowWidth = this._window.width / 2;\n\n    let startLeftY = 0; // 左边所有 item 的高度之和\n    let startRightY = 0; // 右边所有 item 的高度之和\n\n    let startX = 0; // 新增 item 的 X\n    let startY = 0; // 新增 item 的 Y\n\n    for (let i = startIndex; i &lt; itemCount; i++) {\n      itemDim.height = oldLayout.height;\n      itemDim.width = halfWindowWidth;\n\n      // 保证一行中所有的 item 宽度之和不超过屏幕宽度，超过就换行\n      if (startLeftY &gt; startRightY) {\n        startX = halfWindowWidth;\n        startY = startRightY;\n        startRightY += itemDim.height;\n      } else {\n        startX = 0;\n        startY = startLeftY;\n        startLeftY += itemDim.height;\n      }\n\n      // 如果是 item 是新增的，在添加新的 layout\n      this._layouts.push({x: startX, y: startY, height: itemDim.height, width: itemDim.width, type: layoutType,});\n  }\n</code></pre><p>首先，双列瀑布流有一个假设，假设每个列表项的宽度为屏幕的一半。其次，我们还需要记录左边的高度之和<code>startLeftY</code>和右边的高度之和<code>startRightY</code>。在<code>for</code>遍历列表项时，如果左边高 <code>startLeftY &gt; startRightY</code>，那么当前列表项放右边<code>startX = halfWindowWidth</code>，否则当前列表项放左边<code>startX = 0</code>，同时记录最新的左边/右边高度之和。最后把当前列表项 push 到 <code>this._layouts</code> 中。</p><p>将单列布局改为双列瀑布流布局，改动的代码量很少，你可以现在就动手试一试。我也将我改动的代码前后对比图，放在了下面，你可以参考一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/b1/3b0cbcb54e6e06fd52b7fe0d5d1f35b1.png?wh=1920x3413\" alt=\"图片\"></p><h2>保存修改</h2><p>现在，我们来到了最后一步保存修改的源码。</p><p>在修改完 node_modules 中的源码后，如果不进行保存，很有可能就会丢失。并且，有时候我们需要和同事进行合作，同事也需要我们修改后的代码，又或者是在使用上线平台进行打包时，也需要将修改后的 node_modules 源码同步给上线平台一份。本地修改 node_modules 源码后，不保存、不同步肯定会出线上问题。</p><p>怎么把修改好的 node_modules 代码保存呢？有三种思路：</p><p>第一种<strong>直接复制源码</strong>。但复制源码后续想要升级 RecyclerListview 的版本会非常困难，每次升级可能面临的是一次重新改造。</p><p>第二种<strong>在运行时进行修改</strong>。这种方法对源码的侵入性小，但每次升级前我们还是需要手动检查一下的，不然相关代码逻辑有变化，我们的修改就会受到影响。</p><p>我在这次实战中，采用的就是在运行时进行修改的方案。我观察了一下 RecyclerListview 的代码，它的代码风格是面向对象的编程风格，几乎把所有的内部类都暴露出来了。</p><p>但由于它 LayoutManager 类的所有属性是私有属性，我没办法通过继承的方式读取到 LayoutManager 的私有属性。</p><p>因此我复制了 <code>LayoutManager</code> 和 <code>layoutProvider</code> 类，并将其重写为 <code>WaterfallLayoutManager</code> 和 <code>WaterfallLayoutProvider</code>。</p><p>当你的列表是单列布局时，就应该使用<code>layoutProvider</code>类 ，当你的列表是双列瀑布流布局时，就可以使用我创建的<code>WaterfallLayoutProvider</code>类。</p><p>第三种<strong>在编译时修改</strong>。这里利用的是 <code>patch-package</code> 即时修复第三方 npm 包的能力，它的原理是先对你的修改进行保存，然后在你每次安装 npm 包的时候把你原先的修改给注入进去，也就是 patch package。它是侵入式的修改方式，步骤如下：</p><p>在修改完 node_modules 目录下的 RecyclerListview 文件后，你直接运行如下命令：</p><pre><code class=\"language-plain\">$ npx patch-package some-package\n</code></pre><p>这时你修改的代码就会以 patch 文件的形式进行保存，patch 文件的示例代码如下：</p><pre><code class=\"language-plain\">diff --git a/node_modules/recyclerlistview/src/core/layoutmanager/LayoutManager.ts b/node_modules/recyclerlistview/src/core/layoutmanager/LayoutManager.ts\nindex e9454a4..3168330 100644\n\n--- a/node_modules/recyclerlistview/src/core/layoutmanager/LayoutManager.ts\n+++ b/node_modules/recyclerlistview/src/core/layoutmanager/LayoutManager.ts\n\n@@ -95,75 +95,113 @@ export class WrapGridLayoutManager extends LayoutManager {\n         }\n     }\n\n-    public relayoutFromIndex(startIndex: number, itemCount: number): void {\n\n+  // startIndex：从第几个 item 开始有了更新，从这个 item 开始算，目的是为了减少计算量。默认：0\n+  // itemCount: 一共多个 item。\n+  // 以下注释只考虑垂直滚动，水平滚动同理。\n+  public relayoutFromIndex(startIndex: number, itemCount: number): void {\n\n     private _pointDimensionsToRect(itemRect: Layout): void {\n         if (this._isHorizontal) {\n</code></pre><p>那如果别人想用你瀑布流版本的 RecyclerListview 怎么办呢？首先，你需要修改 package.json 文件：</p><pre><code class=\"language-plain\"> // package.json\n \"scripts\": {\n+  \"postinstall\": \"patch-package\"\n }\n</code></pre><p>然后将修改后的 package.json 和前面自动生成的 patch 文件用 Gitlab/GitHub 保存起来。</p><p>这样，你同事下载最新代码，再执行 <code>npm install</code> 或 <code>yarn</code> 命令后，就会自动触发 <code>patch-package</code> 命令。 <code>patch-package</code> 命令会利用你生成的 patch 文件，将官方的 RecyclerListview 修改成你的瀑布流版本的 RecyclerListview。</p><p>一般来说，无论是快速修改第三方组件源码，还是修改 React Native 的 JavaScript 层的源码，我都不建议使用第一种直接复制源码的方式。我会<strong>优先考虑在运行时的修改方法</strong>，通常该方案改动最小、侵入性也最小。<strong>如果运行时方案改不了，我才会考虑有侵入性的编译时的</strong><code>patch-package</code><strong>方案。</strong></p><h2>总结</h2><p>在前面的课程中，我讲的大多是概念性的知识，要消化这些概念性的知识就必须要有练习，所以我在每节课中都给你留了一道实操的练习题，目的就是帮你把知识内化为能力。这一讲中，我准备的实战案例也是为了让你把前几讲中学习到的知识灵活运用起来。</p><p>首先你需要提前准备好写代码时会用到调试工具 Flipper ，并灵活运行“一推理”、“二分法”、“三问人”的思路来解决过程中遇到的问题。</p><p>在理解别人的组件代码时，利用 <code>UI/JSX = f(state, props)</code> 这个最基本 React/React Native 原理，先找到实现 UI 的 JSX 部分，再找到 state、props，然后再理解逻辑 <code>f</code> 的部分。</p><p>在修改别人的逻辑代码时，先通过调试工具来理解各个变量上下文含义，理清楚别人的逻辑后，再根据自己目的进行修改。</p><p>最后要意识到，你修改的是别人的源码，你可以通过运行时、编译时两种方案把其保存下来。</p><h2>附加材料</h2><ol>\n<li><a href=\"https://github.com/ds300/patch-package\">patch-package</a> 可以帮你保存对第三方模块的问题修复。</li>\n<li>本节课的源码，我放在了<a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/11_Waterfall\">GitHub</a>中。</li>\n</ol><h2>作业</h2><ol>\n<li>请你根据这节课的资料，实现一个三列瀑布流布局。</li>\n<li>你觉得阅读源码，有什么意义？</li>\n</ol><p>欢迎在评论区写下你的想法。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"10｜Debug：解决 BUG 思路有哪些？","id":508776},"right":{"article_title":"12｜页面实战：如何搭建一个电商首页？","id":510659}}},{"article_id":510659,"article_title":"12｜页面实战：如何搭建一个电商首页？","article_content":"<p>你好，我是蒋宏伟。</p><p>今天这一讲就是基础篇中的最后一讲了，还记得我在基础篇的第一讲中和你说的吗？刚刚开始学习的时候，不要一头扎进技术的细节中去学习，应该拿起 React Native 的知识地图先看看，知道自己学习的方向并给自己树立一个学习目标。</p><p>现在，我们的基础篇一个月的学习已经接近尾声了，是时候给自己做一个阶段性的总结了！回头看看，自己当初的学习目标有没有达成，又有哪些知识掌握得好，还有哪些知识还需要补足。</p><p>俗话说，实践是检验真理的唯一标准。还记得我们在<a href=\"https://time.geekbang.org/column/article/499446\">01讲</a>中制定的学习目标吗？当初我们的学习计划，就是能够使用 React Native 搭建一个简易的电商首页。因此，基础篇的大作业就是“搭建一个简易的电商首页”，希望你能够认真完成这次大作业，好好检查一下自己都学到了什么。</p><p>这一讲，我不会讲具体的代码实现，主要讲的是我在“搭建一个简易的电商首页”时的技术设计思路，希望我的思路能够对你的实现基础篇的大作业有所帮助。</p><p>建议你在学完这一讲后，先参考这一讲的思路自己实现一遍，然后再去看 <a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/12_HomePage\">GitHub</a> 上的参考答案。</p><h2>简易电商首页</h2><p>为了让开发这个简易电商首页显得更有意思一些，我先从产品角度给你讲讲它的背景。</p><p>故事是这样的，你的老板最近赶上了 NFT（非同质化代币，Non-Fungible Token）的风口，现在卖 JPG 也能赚大钱了，老板靠着这个点子融来了一笔钱，准备大干一场。你的老板让产品和 UI 同学参考业内的电商 App，做出了一个设计原型，接着就轮到你上场了。</p><!-- [[[read_end]]] --><p>你作为团队中的核心成员，分配到的任务是<strong>搭建 App 的首页</strong>，App 的其他部分由其他同事负责。考虑到要快速上线，你技术领导准备<strong>用 React Native 来实现</strong>，现在是你大展身手的时候了。</p><p>团队的设计同学，这时候把首页设计稿交付到你了，设计稿如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/55/ec/55a408bf485f7c829c124880de81b5ec.png?wh=1568x2136\" alt=\"图片\"></p><p>你可以看到，App 首页的主要功能包括三个部分：顶栏、金刚位、瀑布流。</p><p>顶栏是固定在首页中的，它的主要功能是用于切换首页和关注页，其中关注页不是你负责，因此顶栏你只需要注意两点，第一能够支持点击切换，第二顶栏要始终保持在顶部，页面滚动的时候需要保持不动。</p><p>金刚位是其他功能页的核心入口，它横跨两个屏幕，每屏幕两行，每行 5 个图标。金刚位的特点是，它自身支持左右滑动切换，并且在页面滚动时金刚位也要跟随着一起滚动。</p><p>瀑布流是 JPG 的核心展示区，它由若干个高度不确定的卡片组成，每一批卡片 20 个，卡片数据是从后端请求过来的，并且需要支持无限滚动。</p><p>你可以先停下来，思考一下这个项目你会怎么设计，你会怎么写代码。好了，接下来我会把我的设计思路告诉你。</p><h2>项目结构</h2><p>我以前和你介绍过，搭建页面讲究的是代码未动构思先行。动手开发，我一般会从三个技术维度进行思考，<strong>项目维度、页面维度和单个组件维度</strong>，主要围绕技术选型、可行性、可扩展性、可维护性这些方向进行。</p><p>遇到大的需求，我还会专门先写技术文档，内容包括核心技术选型、组件拆分方式、组件之间的关系、状态的数据结构和流程图，等等。写文档的过程也就是把模糊的构思变成清晰的文字的过程，在这个过程中，我会找出一些以前没有思考到的要点，把风险提前暴露出来，同时写文档也能帮我把设计思路变得更有条理一些。</p><p>回到 NFT 电商项目，在项目维度我们先围绕技术选型、可行性、可扩展性、可维护性这些方面思考一下。</p><p>首先，在开发语言的选择上，后续这肯定是大型项目，直接选 TypeScript。说实话，在用习惯 TypeScript 之后，要我换回 JavaScript，我估计我自己的开发效率会变得更低，代码 BUG 也会更多。TypeScript 静态类型检查真的很好用，推荐给你，即使你现在不会，也请你把 TypeScript 列到你的必学清单中。</p><p>第二，在状态管理的技术选型上，页面级别的，我们使用 useState 就够了，只有大型应用中，我才会考虑使用  Redux，现在直接用 Redux 有点重了，后面再引进来也不迟。</p><p>接下来就是列表组件的技术选型，现在这个时间点，我还是会用 RecyclerListView。当然这有个难点，怎么实现金刚位和瀑布流的混合列表，以及怎么在瀑布流中实现不定高布局呢？这些实现细节我们可以后面再思考。可能有些人觉得这非常难，如果是工作中，就需要专门安排人进行技术攻关了，当然这也是可以的。</p><p>我认为在项目维度上，更值得和你探讨的问题是：<strong>项目目录应该如何设计，才能支撑后续项目变大的可扩展性和可维护性？</strong>从单个 NFT 首页本身来讲，我的设计思路是这样的，你可以参考一下：</p><pre><code class=\"language-plain\">.\n├── api\n│   └── homeAPI.tsx\n├── components\n│   ├── Grid\n│   └── RecyclerListView\n├── utils\n├── features\n│   ├── Icons\n│   ├── List\n│   ├── TopBar\n│   └── WaterFallCard\n└── index.tsx\n</code></pre><p>整体设计思路是把通用代码放到最外面的 api、components、utils 目录，把纯业务相关的功能代码收拢在 features 目录中。这些目录的具体作用如下：</p><ul>\n<li>api：后端约定好的接口地址不容易变，因此我把请求后端接口的函数都放到了 homeAPI.tsx 的文件中了；</li>\n<li>components：开发页面中能够沉淀下来，后续可能复用的组件，我会放到 components 文件夹中。比如，金刚位中 2 * 5 的图标，它的布局方式就是网格布局，那就可以抽离一个通用的网格布局组件 Grid；</li>\n<li>utils：通用工具函数；</li>\n<li>features：业务组件和其后端接口数据的处理逻辑部分，它们是最容易变动的，而且关联性很强，因此我把它们看作一个功能，有时候代码行数不多我也会偷懒不拆，直接把这组件和组件的后端数据处理逻辑放到同一个文件中。按功能 feature 拆分而不是按组件本身进行拆分的思路，我是从 <a href=\"http://cn.redux.js.org/style-guide/style-guide#structure-files-as-feature-folders-with-single-file-logic\">Redux 的最佳实践</a>中学来的。</li>\n</ul><blockquote>\n<p>“Structure Files as Feature Folders with Single-File Logic”，相同 feature 的文件，都放在同一个文件夹下。</p>\n</blockquote><ul>\n<li>index.tsx：页面的根组件，用 index.tsx 的原因是引用起来更加方便，可以少写一层引用路径。</li>\n</ul><p>这时你可能会问，这种项目的结构设计，可扩展性怎样？开发页面用这个项目结构是可以，但咱们不是要开发 NFT 的 App 嘛。</p><p>其实，这就是个套娃的过程了，当然里面也有一些技巧，如果你后续要开发一个完整的 App，我的扩展设计思路如下：</p><pre><code class=\"language-plain\">.\n├── api\n├── components\n├── packages\n├── utils\n├── features\n├── screen\n│  ├── Home\n│  │    ├── api\n│  │  ├── components\n│  │  └── ...\n│  └── Follow\n└── index.tsx\n</code></pre><p>在上面的项目结构中，首页 Home 的页面结构也是 api、components、features、utils、index.tsx 的结构，只不过用 Home 目录包裹起来了，并将其放到了 screen 目录中。一个文件具体放哪儿一层，按照通用程度来划分：</p><ul>\n<li>页面级别的共享：我会放在 <code>./screen/Home/api</code>、<code>./screen/Home/components</code> 等目录下；</li>\n<li>应用级别的共享：一个应用中有多个页面，多个页面之间的共享我会放在 <code>./api</code>、<code>./components</code>等目录下；</li>\n<li>项目级别的共享：有时候项目和项目之间的代码也是会共用的，这部分代码我会放在 packages 目录下，并通过 npm 的方式进行分发。这个思路，我参考的是业内的  <a href=\"https://en.wikipedia.org/wiki/Monorepo\">monorepo</a> 实践，我们团队内部也在用。</li>\n</ul><h2>页面拆分</h2><p>项目维度弄清楚后，接下来我重点思考的问题是如何“拆稿”，也就是把 UI 设计稿拆成组件，特别是要把组件状态确认好。</p><p>我拿到 UI 设计稿后，发现了两个我熟悉的通用组件，这些通用组件是我以前写代码时沉淀下来的一些应用级别的共享代码。虽然这些 UI 组件在每个 App 上都长得不一样，很难做成多项目通用、业内通用的组件，但自己做项目时直接拿过来改改，还是非常好用的。你看，<strong>以前通用组件、通用工具的积累，现在派上用场了吧</strong>。</p><p>这两个通用组件是网格布局组件 Grid，和瀑布流版的 RecyclerListView，我把它们放到了 components 目录下：</p><pre><code class=\"language-plain\">├── components\n   ├── Grid\n   └── RecyclerListView\n</code></pre><p>有了上面两个通用组件后，我就只需要专注于页面的开发即可。Grid 组件对应金刚区图标的 2*5 的网格布局。不过，瀑布流版的 RecyclerListView，也不是拿来就能用的，比如金刚位和瀑布流的混合列表，我是上一讲的基础上改了改代码才实现的。</p><p>要开发页面，就要先把它拆成组件。在<a href=\"https://time.geekbang.org/column/article/500633\">02</a><a href=\"https://time.geekbang.org/column/article/500633\">讲</a>中，我提到过拆组件原则是单一职责原则，一个组件只做一件事，我还在<a href=\"https://time.geekbang.org/column/article/503115\">04讲</a>说过，组件的状态根据就近原则进行放置，我们应该先考虑放在该组件上，再去考虑父组件。</p><p><strong>根据单一职责原则和就近原则</strong>，NFT 首页的设计稿我是这么拆的：</p><p><img src=\"https://static001.geekbang.org/resource/image/91/10/91535f384f06d19b9f016fc2d88a4f10.png?wh=1646x1898\" alt=\"图片\"></p><p>我们先来具体分析一下 TopBar 。</p><p>顶栏就是 TopBar 组件，咱们基础篇先不考虑动画、手势，因此 TopBar 组件使用最简单 View 和 Text 就能实现。其中有个麻烦的地方，页面切换的状态应该放在哪里？</p><p>我是这么思考的，根据就近原则我先把页面切换的状态放到了 TopBar 组件上面：</p><pre><code class=\"language-plain\">- App(应用)\n  - Home(首页)\n     - TopBar(顶栏) &lt;- 页面切换的状态\n  - Follow(关注页)    \n</code></pre><p>但实际上，你可以看到页面切换的状态其实并不属于 TopBar 组件，也不属于它的 Home 父组件。它是 App 组件用来控制 Home 组件和 Follow 组件切换的状态，因此它应该属于 App 组件。而这次我负责开发的是首页，所以我先把暂时放在了 TopBar 组件上，后续我和负责 App 开发同学联调的时候，再把状态抽到 App 组件的全局状态上。</p><p>接着是List 的实现。无限列表  List，底层直接使用瀑布流版的 RecyclerListView 实现就可以了。</p><p>而且，无限列表的加载状态，我们也在<a href=\"https://time.geekbang.org/column/article/503115\">04讲</a>中提到过，所有的 isLoading、isError、isSuccess 都可以合并成一个状态 ：</p><pre><code class=\"language-plain\">enum RequestStatus {\n  IDLE = 'IDLE',\n  PENDING = 'PENDING',\n  SUCCESS = 'SUCCESS',\n  ERROR = 'ERROR',\n}\n</code></pre><p>除了 RequestStatus 这种枚举类型的方案外，当然还有更简单的方案，在单个组件的分析维度，我会再和你介绍。</p><p>再接着是 Icons。</p><p>金刚位 Icons，我用我自己开发的网格组件 Grid 和滚动组件 ScrollView 就能实现。ScrollView 组件我们也在<a href=\"https://time.geekbang.org/column/article/506825\">08讲</a>中介绍过，我打算用它的横向滚动、分页能力和滚动结束事件，来实现金刚位的支持左右滑动切换、双屏切换的功能。</p><p>接下来我们还会用到这些 <a href=\"https://reactnative.dev/docs/next/scrollview\">ScrollView</a> 属性：</p><pre><code class=\"language-plain\">- horizontal\n- pagingEnabled\n- onMomentumScrollEnd\n- showsHorizontalScrollIndicator\n</code></pre><p>这里我们再简单解释下这几个属性：</p><ul>\n<li>horizontal 默认为 false，是竖向滚动的，将其设置为 true 时，即可开启横向滚动；</li>\n<li>pagingEnabled 默认为 false，是滚动交互是平滑的，将其设置为 true 时，每滚动一次就翻一页。horizontal  和 pagingEnabled 同时开启的效果类似轮播图；</li>\n<li>onMomentumScrollEnd 是滚动结束事件，当滚动停下来时会触发一次。金刚位的滑动翻页时，有一个长一点的小红条和一个短一点的小灰条，用来表示当前显示的那一屏。使用 onMomentumScrollEnd  就可以控制滑动切换状态了；</li>\n<li>showsHorizontalScrollIndicator 默认为 true，代表默认显示横向滚动条，金刚位的轮播图效果不需要滚动条，因此我准备把它关了。</li>\n</ul><p>金刚位有两个状态，滑动状态和图标内容状态。滑动状态我刚刚也提到过，只有 Icons 本身在用，因此我们直接放到 Icons 组件上即可。而图标内容状态，因为 RecyclerListView 不像 ScrollView，RecyclerListView 的 dataProvider 是统一维护的，所以我打算把图标内容状态移到 Icons 的父组件 List 上。</p><p>最后是 WaterFallCard 。</p><p>前面我们提到过 NFT 首页是由金刚位和瀑布流组成的混合列表，我们不能用 RecyclerListView  嵌套 RecyclerListView来实现混合列表。这里我敲一个重点，RecyclerListView 是继承自 ScrollView 的，同一个方向也就是垂直方向或水平方向，我们尽量只使用一个 ScrollView/RecyclerListView  组件来进行响应。</p><p>那为什么我选择只用一个 ScrollView/RecyclerListView 呢？</p><p>你这样想，同方向的双 ScrollView 有两种响应方式，同时响应或只响应一个。只响应一个的时候，双 ScrollView 和单 ScrollView 是一样的。第二种情况是双 ScrollView 同时手势响应，你可以想象一下，在你用鼠标往上滚动页面时，还有一个调皮的小朋友用你的键盘控制页面往上滚动。第二个 ScrollView 组件，就像那个调皮的小朋友，你在动的同时他也在响应你的手势，结果滚动速度就变成双份的了，格外奇怪。</p><p>而且，同方向的双 ScrollView 并不能实现金刚位和瀑布流的混合列表，因此我选择了采用改 RecyclerListView 的源码，让它同时支持单列布局和双列瀑布流布局，这就要一些技术攻坚了。怎么改第三方库的 JavaScript 源码，我们也在<a href=\"https://time.geekbang.org/column/article/509753\">11讲</a>中学习过。</p><p>正是因为，瀑布流实际不是列表，它只是无限列表 List 组件中的卡片，因此我将其命名为 WaterFallCard。实现 WaterFallCard 组件，需要用到 View、Text、Image、Pressable 组件，此外还要用到 <a href=\"https://time.geekbang.org/column/article/501650\">03讲 Style 样式</a>的知识，这一部分实现起来会比较简单。</p><h2>单个组件</h2><p>当我把 NFT 页面拆成 2 + 4 个组件后，我的实现思路就清晰很多了。两个通用组件，不需要什么改动，工作量很小，4 个业务组件只有列表 List 组件状态管理比较麻烦，这时候我就把重点放到了 List 组件上。如果你想了解 4 个业务组件的具体实现，也可以看下我放在 <a href=\"https://github.com/jiangleo/react-native-classroom\">GitHub</a> 上的代码。</p><p>如果做过无限列表，你就知道，处理里面的逻辑还挺麻烦的，需要处理首次请求成功、首次请求失败、更多数据加载成功/失败、后端没有数据等等情况，如果考虑性能优化的话，还要做预加载、要管理数据缓存的逻辑，要写很多代码。</p><p>这时候，我想起了以前在技术群里有朋友推荐过的 React Query，说是处理请求状态非常简单，以前就简单看过一下 API，它的 Demo 代码如下：</p><pre><code class=\"language-plain\"> import { QueryClient, QueryClientProvider, useQuery } from 'react-query'\n\n const queryClient = new QueryClient()\n\n export default function App() {\n   return (\n     &lt;QueryClientProvider client={queryClient}&gt;\n       &lt;Example /&gt;\n     &lt;/QueryClientProvider&gt;\n   )\n }\n\n\n\nfunction Example() {\n   const { isLoading, error, data } = useQuery('repoData', () =&gt;\n     fetch('https://api.github.com/repos/tannerlinsley/react-query').then(res =&gt;\n       res.json()\n     )\n   )\n\n   if (isLoading) return 'Loading...'\n\n   if (error) return 'An error has occurred: ' + error.message\n\n   return (\n     &lt;div&gt;\n       &lt;h1&gt;{data.name}&lt;/h1&gt;\n       &lt;p&gt;{data.description}&lt;/p&gt;\n       &lt;strong&gt;👀 {data.subscribers_count}&lt;/strong&gt;{' '}\n       &lt;strong&gt;✨ {data.stargazers_count}&lt;/strong&gt;{' '}\n       &lt;strong&gt;🍴 {data.forks_count}&lt;/strong&gt;\n     &lt;/div&gt;\n   )\n }\n</code></pre><p>代码行数不多，虽然是 Web 代码，但我相信你也能很容易看懂。QueryClient 和 QueryClientProvider 让我感觉和 Redux 状态管理库似曾相识，应该是管理全局状态用的。但 useQuery 这段代码非常简洁，把网络请求状态统一封装了，加载中是 isLoading，加载报错是 error，请求数据是 data ，能够省去很多模板代码。看完后，当时我心里就想，这代码抽象得真好。</p><p>这次写文章时，我又想起了 React Query，于是又去仔细研究了一下，第一个惊喜是它的竞品 SWR 的代码，竟然比 React Query 还要简单，你可以看下 SWR 提供的 demo：</p><pre><code class=\"language-plain\">import useSWR from 'swr'\n\nfunction Profile () {\n  const { data, error } = useSWR('/api/user/123', fetcher)\n\n  if (error) return &lt;div&gt;failed to load&lt;/div&gt;\n  if (!data) return &lt;div&gt;loading...&lt;/div&gt;\n\n  // render data\n  return &lt;div&gt;hello {data.name}!&lt;/div&gt;\n}\n</code></pre><p>默认没有全局配置的 Client 和 Provider 的配置，只用了一行 useSWR，就把请求逻辑处理完成了，并且只提供了两个状态数据 data 和 error，isLoading 和 !data 是等价的，于是又把 isLoading 状态省掉了。作者真是高手，后来我一看是 Next.js 团队开发的，心里好感又增加了一些。</p><p>第二个惊喜是 React Query 和 SWR 竟然针对无限列表这种场景，做了通用的封装，这又能进一步把 List 组件的状态管理逻辑降低。以 React Query 为例，示例代码如下：</p><pre><code class=\"language-plain\"> const {\n   fetchNextPage,\n   fetchPreviousPage,\n   hasNextPage,\n   hasPreviousPage,\n   isFetchingNextPage,\n   isFetchingPreviousPage,\n   ...result\n } = useInfiniteQuery(queryKey, ({ pageParam = 1 }) =&gt; fetchPage(pageParam), {\n   ...options,\n   getNextPageParam: (lastPage, allPages) =&gt; lastPage.nextCursor,\n   getPreviousPageParam: (firstPage, allPages) =&gt; firstPage.prevCursor,\n })\n</code></pre><p>不过，我这里要先和你坦个白，<a href=\"https://react-query.tanstack.com/reference/useInfiniteQuery\">查文档</a>看这段代码的时候，我也没有看得太懂，状态太多了，还有个配置项，我其实是在真正用的时候，才用明白的。</p><p>我从文档中大概能够理解，useInfiniteQuery 是专门用来控制无限列表请求的状态的，里面状态很多，控制状态的函数也很多。fetchNextPage 从名字看是获取下一页，hasNextPage 是是否有下一页的意思，isFetchingNextPage 是是否正在请求下一页的意思，但 getNextPageParam 和 getPreviousPageParam 完全没有看懂，特别是 nextCursor 属性是什么、干什么用的，也没有搞明白。</p><p>同样，在 SWR 的中文文档中，处理无限数据列表的 useSWRInfinite 函数我也看了一遍，汉字都认识，代码单词都认识，就是不理解。</p><p>或许你曾经也遇到过和我类似的问题，看别人的文章、文档懂了个大概，但心里还是困惑很多。这个时候，抽象的文字要和能跑得起来的代码结合起来读，读完 useInfiniteQuery/useSWRInfinite  <a href=\"https://github.com/tannerlinsley/react-query/tree/master/examples/load-more-infinite-scroll\">示例代码</a>后，我自己写了一个 React Native 的版本之后，我才真正算会用了。</p><p>但在当时，我要解决的核心问题不是怎么把 useInfiniteQuery/useSWRInfinite 学会，我的计划是在 1 天的周末时间把简易电商首页搭建出来，所以了解完 React Query 和 SWR 的核心功能后，我得快速决策 List 组件怎么技术选型。</p><p>在当时我是这么决策的，React Query 和 SWR 都支持 React Native，在 React Query 官方出的和 SWR 的<a href=\"https://react-query.tanstack.com/comparison#_top\">对比分析文章中</a>，React Query 似乎更强大一些，但多出的功能我并不会用到，在功能方面二者打了个平手。</p><p>然后我又分析了一下文档，SWR 官方支持中文，React Query 只能找到英文文档，但 React Query 功能丰富度比 SWR 更强大一些，我又对比了一下 <a href=\"https://www.npmtrends.com/react-query-vs-swr\">npm trends</a>，发现大家更喜欢 React Query 一些，从趋势图中你可以看出 React Query 在 2021 年的下载量反超了 SWR。</p><p><img src=\"https://static001.geekbang.org/resource/image/42/64/42168e6ddf025f6dc13ff194a57b6864.png?wh=1920x1086\" alt=\"图片\"></p><p>中文英文文档我没有什么偏好，但文档详细度、Demo 数量和 React Query 的下载量，实打实是 React Query 更优秀，因此我快速做出了决定，选 React Query。</p><h2>总结</h2><p>好了到现在为止，从项目维度、页面维度和单个组件维度，我把一些关键点都分析完了，排除难点有了思路后，接下来就是写代码了，都是体力活了。</p><p>代码如何写，细节是什么，我就不和你详细介绍了，因为写这篇文章的目的其实是为了让你通过搭建一个电商首页，检验自己学到了多少知识。老师教了多少不重要，你学到了多少才是最重要的。</p><p>这篇文章也是我对自己一次自我剖析，在这篇文章中，你也能看出我的整体思路，是把“如何搭建一个电商首页？”这个大问题，分解为“如何搭建项目”，又进而分解为“如何拆分页面”，最后分解为“如何攻克单个复杂的组件实现”，在不同思考层面宏观、中观、微观，利用自己的经验和从优秀开源库中学到的实践，来解决不同层面的问题。</p><p>但老师也有他的技术盲区，有些业内已经解决的问题，我以前都没有意识到这是个问题，还在用着我以前复杂的解决方案，比如 React Query 我真是今年才听过，这次写代码的时候才用上的。</p><p>但因为以前这种电商首页写过很多个，无限列表组件也封装过，看到 React Query 就明白它大致解决的问题是什么，能解决我以前的哪些问题，也就可以现学现卖了。</p><p>这也让我更加深刻地意识到，知识本身不重要，要把知识内化成自己的能力才重要。只有以前真正思考过、实践过才能在遇到类似问题时，遇到更好解决方案时，快速学习、决策和解决。</p><h2>作业</h2><p>这一讲的作业，就是搭建一个卖 JPG 的电商首页。</p><p>这次作业是对技术篇所学知识的一种巩固，技术篇中没有用到的技术，比如动画、页面跳转，你可以先忽略，后面我们还会继续完善这个电商 App。有些绕不开的技术，如果你以前不会，我也没有教过，你可以试着自己查查资料，一边看文档和代码案例，一边自己动手试试，相信你也能很快掌握。</p><p>这次没有搭建专门的后端服务，所有的数据、图片用的都是 mockapi.io 的假数据，这些假数据接口如下：</p><pre><code class=\"language-plain\">const animalsUrl = 'https://61c48e65f1af4a0017d9966d.mockapi.io/animals';\nconst catsUrl = 'https://61c48e65f1af4a0017d9966d.mockapi.io/cats';\nconst iconsUrl = 'https://61c48e65f1af4a0017d9966d.mockapi.io/icons';\n</code></pre><p>第一个 animalsUrl 是动物的图片数据，第二个 catsUrl 是猫猫的图片数据，你可以任选其一作为瀑布流的展示数据，第三个 iconsUrl 是金刚位的图标数据。</p><p>请你使用上面三个接口，实现如下 UI 设计稿：</p><p><img src=\"https://static001.geekbang.org/resource/image/55/ec/55a408bf485f7c829c124880de81b5ec.png?wh=1568x2136\" alt=\"图片\"></p><p>如果你在实现过程中遇到了问题，花了大量时间也没有想明白的时候，你可以参考一下我放在 <a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/12_HomePage\">GitHub</a> 上的代码，希望它能对你有所帮助。如果还有其他问题，也欢迎你给我留言。我是蒋宏伟，咱们下一讲见。</p>","neighbors":{"left":{"article_title":"11｜组件实战：如何实现瀑布流？","id":509753},"right":{"article_title":"直播加餐｜七年，我的跨端实践和探索","id":512075}}},{"article_id":512075,"article_title":"直播加餐｜七年，我的跨端实践和探索","article_content":"<blockquote>\n<p>小编说：<br>\n以下内容均来自蒋宏伟老师3月29日晚的直播，相关直播回放见<a href=\"https://www.bilibili.com/video/BV1XL4y177Nx?spm_id_from=333.999.0.0\">bilibili极客时间频道</a>。</p>\n</blockquote><p>你好，我是蒋宏伟。今天我想和你分享一下我这七年的跨端实践和探索，希望我的过往经验和想法，能对你的工作有所帮助。</p><p>这七年大体上可以分为<strong>学习、实践和探索的三个阶段</strong>：</p><p><strong>第一个阶段是 2015～2016 年。</strong>2015 年，我转行开始做前端工程师，而且我大学学的也不是计算机相关的专业，技术底子很薄。因为刚刚入行，对很多东西都不懂，只能天天学习。幸好当时遇到了很好的 leader，入职了 58 同城。58 的培养机制还是很好的，有小师傅、有小组长，还有技术大牛，而且他们都很“乐于助我”。</p><p>那个时候，我主要负责的是 H5 和 React Native 的业务开发。在业务开发过程中，遇到简单的问题自己翻翻书、查查资料就能搞定了，遇到自己搞不定的事情，就去请教同事，技术成长也很快。</p><p><strong>第二个阶段是 2017~2019 年的时候。</strong>那个时候我参与了很多 58RN 基建的开发，并且在 18 年成为了 58RN 项目的负责人。但开发业务和做技术基础设施建设是不一样的，开发业务有产品提需求，有 PMO 把握进度。搞基建呢，你自己得有想法，你得会把业内方案和业务场景进行结合，你还得组织小伙伴，让小伙伴来支持你落地。</p><!-- [[[read_end]]] --><p>这几年，我看了大量的业内方案，也有了大量的落地实践，所以对很多技术原理层面东西有了更深的认知。</p><p><strong>第三个阶段是 2020 年到现在</strong>。2020 年，我开始负责一个 9 人的前端团队。带团队和单兵作战很不一样，单从技术层面讲，遇到技术难题你要能扛得住，定技术方向时你要对得起大家，别把大家带错路了，因此对前沿技术的探索也是团队leader的必修课。</p><p><img src=\"https://static001.geekbang.org/resource/image/04/62/044468e1a271048407e61a4bf563cb62.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>这七年无论是 H5、React Native 还是小程序等等，我都在围绕着跨端这个方向，学习、探索和实践。接下来，我想通过几个小故事和你聊一下我的心路历程。</p><h2>过去：既做业务又做基建最幸福</h2><p>我要讲的第一个故事是《学以致用的故事》。</p><p>我刚入职前几年解决的就是些小问题。这是可以预见的，你刚刚工作一两年，没有太多的积累，公司不可能一上来就让你负责一个很牛逼的项目，人都是慢慢积累的。</p><p>因此我们要先学习，把那些常见的小问题给解决好，等大家认可你的技术能力的时候，你才会有更好的机会。</p><p>我举个例子，2015 年，我学 H5 的时候，从《移动 Web 手册》这本书上学到了一个很有用的、开发移动应用的小知识。它说的是我们用的 CSS 像素（px）并不是手机屏幕中物理像素。我们都知道，一个物理像素，就是屏幕上最小的发光点，那 CSS 像素究竟和设备的物理像素有什么关系呢？</p><p>揭开这个谜团之前，我们还要了解一个非常重要的概念，叫做 DPR（Device Pixel Ratio），也就是设备像素比。现在我们的手机都是视网膜屏，大部分手机的设备像素比都是 2 或 3。</p><p>如果设备像素比等于 2 的话，那么 1 个 CSS 像素点的宽度，就是两个物理像素的宽度。既然都是物理像素了，理论上我们拿一个精度很高的尺子，就能把这个物理像素的宽度度量出来。或者查一下、量一下手机宽度，再查一下它宽度上有多个像素，也能大致估算出来。</p><p><strong>这样一个非常抽象的 CSS 像素，就和现实世界中的毫米给挂钩上了。</strong></p><pre><code class=\"language-plain\">单个物理像素宽度= 71.5 毫米/1170 物理像素 = 0.06 毫米（iPhone12）\n1CSS 像素 = 3DPR * 0.06 毫米 = 0.18 毫米\n</code></pre><p>这种把未知的抽象概念和已知具象概念挂钩的学习方案，我经常用，对提升学习效率有非常大的帮助。</p><p>但是你知道吗？你在写 React Native 的时候，React Native 的宽度 width 是没有单位的。</p><p>当时我就糊涂了，你传个数字 100 给 React Native，这个 100 到底是多宽？是 100 毫米？还是 100 的 CSS 像素的宽度？我没法把 React Native 中的单位，和我当时认知体系中的单位挂上钩。咱写代码总不能稀里糊涂写吧？总得这个最基本的概念给搞明白吧？</p><p>后来我就查资料，自己写代码验证，终于搞清楚了，原来 React Native 中的默认单位就是 Web 中的 CSS 像素。当时，我还了解到，在 Android 开发的眼中，他们把 CSS 像素叫做 dp。原来同一个东西，在不同开发者口中，还有不同的叫法，我当时也是大呼神奇。</p><p>但你要知道，<strong>你光知道 CSS 像素、dp 和毫米的关系是没有用的，你得学以致用。</strong></p><p>实际上，UI 稿也有自己的像素单位，那个时候我们 UI 稿的宽度是 640 像素，这个 UI 像素既不是 CSS 像素、也不是物理像素，你还得把 UI 像素和 CSS 像素挂上钩。</p><p>那个时候，前端很流行自适应布局，UI 给的设计稿等比缩小或放大到手机、平板上。于是，我就写了一个 uipxToDp 的函数，专门用来做这种转换：</p><pre><code class=\"language-plain\">import {Dimensions} from 'react-native';\n\n// 58 app 只有竖屏模式，所以可以只获取一次 width\nconst deviceWidthDp = Dimensions.get('window').width;\n// UI 默认给图是 640 像素\nconst uiWidthPx = 640;\n\nfunction uiToDp(uiElementPx) {\n   return uiElementPx *  deviceWidthDp / uiWidthPx;\n}\n\nexport default uipxToDp;\n</code></pre><p>使用 uipxToDp，你可以直接使用 UI 给的像素单位先在手机上把布局弄好，然后在不同机型上 uipxToDp 函数会自动把 UI 像素转换成对应的 dp，这样就能等比例放到任意机型上了。</p><p>这就是我在刚刚入门的时候解决的一个小问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/af/46/af19026bab3b75380a360e5d6b9ebc46.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>我要讲的第二个故事是《理论指导实践的故事》。</p><p>我平时除了前端技术、跨端技术，也爱了解一些最前沿的技术。当时，因为机缘巧合，参与了一个由物理学家张首晟投资的项目的白皮书翻译，后来我又读到张首晟教授在国内的一篇演讲稿。这篇演讲稿给了我很大的震撼，对我影响很大。</p><p>其中有句话是这么说的：</p><blockquote>\n<p>张首晟教授 ：科学有两大方向，一是把各种形态的物质，分解到最基本的组成部分；二是用这些最基本的组成部分，构造出物质不同的态。</p>\n</blockquote><p>我是这么理解的，科学搞研究是先从上往下把事物分解，再从下往上构建出一个全新的物质出来。</p><p>那我们搞技术也可以沿用这个思路。后来，我看问题的时候，就喜欢先把问题拆解、拆解、再拆解，然后再想尽办法重组、重组、再重组。我给你举个例子，比如用户打开页面的时候，他眼中的页面加载就是白屏或者转圈。</p><p>但在我眼中页面加载，是先有版本请求、资源请求，把 JavaScript 静态资源请求回来，然后Native 的 React Native 代码要初始化，下一步才是执行 JavaScript。首次执行 JavaScript 代码的时候，渲染的是一个空页面，这时候我们要先发送业务请求，在业务数据回来之后，真正的业务页面才渲染完成。</p><p><strong>用户的眼中，页面加载只有一步，我眼中页面加载是六步，如果需要的话我还可以细分成更多步骤。</strong></p><p>拆分加载页面的过程有什么用呢？是告诉用户，我们页面加载这么慢是因为它有六个步骤，你要耐心等等吗？</p><p>当然不是，用户不需要关心你的加载页面的过程是什么，他关心的是页面为什么这么慢，我们程序员不就是“用户第一”嘛，用户说慢，怎么办？我们程序员就得想办法解决，而不是给老板、给用户讲道理。</p><p>我和我的小伙伴前前后后用了 2～3 年的时间，方案也是改了又改，做了好几个优化项目，才把我们的一个耗时 2s 多的页面，降低到了  1s 以内，首屏平均耗时一共降低了 57%。并且，这个方案也是一个通用方案，任何 58RN 业务都能用。</p><p>这里我们卖个关子，理论上一个 React Native 页面的首屏渲染耗时可以控制在 100ms 以内，也就是用户点击跳转的动画还没有完成，这个页面就能渲染出来，也就是页面直出。从 1s 降低到 100ms，这也是未来 2~3 年，我们要继续做的事情。</p><p>我在入职 58 的 3~5 年之间，很多基建工作都是围绕着性能优化来做的，这件事给我的启发就是干事情，<strong>不仅要向业内去学，还得有方法论，才能做出最贴合自己业务的方案。</strong></p><p>这就是我第二个《理论指导实践的故事》。</p><p><img src=\"https://static001.geekbang.org/resource/image/99/dc/9945457b5cc15956c1e19f3db58da1dc.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>我要讲的第三个故事是《从技术深度到技术广度的故事》。我有个观点，就是“既做业务又做基建最幸福”，为什么呢？</p><p>因为你做业务的时候，你会用自己开发的产品、也能感受到产品中的问题，甚至你还能从用户、产品、老板那里收到类似反馈。这个时候，你是很容易发现业务中存在的问题的。</p><p>当初我在做 React Native 业务的时候，就花了很多时间来解决线上 BUG，有时候就是一个截图，连报错信息都没有，你说解决起来多痛苦。后来在做 58RN 基建的时候，我就在考虑要不要做一个 React Native 的监控系统。</p><p>2020 年的时候，正好有一个机会，我和我的 leader 提出要搞一个 React Native 的监控系统，他答应了。后来，我们决定先做 Web 监控，再做的 React Native 监控，因为 Web 的体量更大。</p><p>但是，当你做一个完整的大型项目的时候，“I 型”技术深度是远远不够的，你得在“I”上加一横，让你的技术能力由“I”型，变为“T”型。<strong>这一横，我认为就是产品能力和架构能力。</strong></p><p>在做这个监控系统的时候，我学起了 PM 的那套，做了各种调研，甚至我还掌握了写产品文档、画产品原型图这些技能。</p><p>产品文档、产品原型图实际就是个大体架子，架子分几层、用什么材料、搭建步骤又是什么，这些产品不会管。产品不管归谁管？架子的施工步骤归架构师管。</p><p>这时候，你还得去充当架构师的角色。你得写技术文档，画架构图，还得把这些产品、技术实现细节给小伙伴讲清楚。</p><p>后来当我参与搭建大前端监控系统的时候，就做了大量的产品和架构的活。做这些活的目的是把大家连接在一起，让大伙知道我们为什么要做，又怎么做，接着才能干好活。</p><p>当然，代码还是要写的，这一方面我重点负责的是 React Native 、ES/Duird、Node.js 部分。我记得当初完成大前端监控系统二期的时候，我还统计过一次 commit 的数量，当时我的 commit 的数量是第一的，那时候的成就感还是满满的。</p><p>搭建大前端监控系统这件事，让我从原来专精 React Native 方向的程序员，变成了一个产品、架构、前端、后端都懂一点点的全能战士。这种全能战士的能力，让我<strong>能站在对方角度思考问题，交流起来障碍就小，也更容易把人和人连接在一起，项目推进起来也会更有效率。</strong></p><p>这就是我《从技术深度到技术广度的故事》。</p><p><img src=\"https://static001.geekbang.org/resource/image/4a/b5/4a697180584552387b104090cf4143b5.jpeg?wh=1920x1080\" alt=\"图片\"></p><h2>现在：既要与时俱进也要接地气</h2><p>当然，过去的已经过去，人不能永远躺在过去的功劳簿上，还是得与时俱进跟上时代的步伐。因此，我来给你讲讲我这半年多做的探索，以及我对 React Native 新架构落地的思考，这一部分有点长，我慢慢给你展开。</p><p><strong>2022 年，对于 React Native 是一个大年，因为 React Native 团队官宣新架构会在今年正式发布。</strong></p><p>React Native 的新架构要出来了，你得升级吧？总不能让团队小伙伴，一直用老架构开发吧？我有过好几次升级经验，但每次升级牵涉面都很广，非常痛苦。</p><p>升级成本高的原因，是因为有些 React Native 业务，是同时运行在几个 App 上。只升级一个 App 还不行，需要把所有关联的 App 都同时升级，不然这些 React Native 业务要同时维护多个版本，成本也是很高的。</p><p>但 2022 年新架构出来后，即便成本很高，我也想把它升上去。因为我经过调研发现，新架构的潜在收益非常大，我认为新架构的收益是能够覆盖我们升级所付出的成本的，因此等今年新架构出来后，我会继续推进升级。</p><p>熟悉 React Native 的朋友肯定知道，2018 年之前 React Native 的核心能力是支持跨端、支持热更新，而且是背靠 JavaScript/TypeScript 生态的。</p><p>从 2018 年到现在，React Native 又推出了好几个非常吸引我的功能，主要是 2020 年 React Native 支持了 React Hooks，还有今年即将推出的 React Native 新架构。</p><p>现在 React Native 新架构的预览版已经出来了，我也第一时间进行了调研，主要有两个功能非常吸引我。<strong>第一个是新架构会默认使用的 Hermes 引擎，第二个是新架构的 Fabric 渲染流水线。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/df/10/dfe6e181a081a48d355077ba265b5c10.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>先说说 Hermes 引擎为什么吸引我。<strong>简单地讲，就是新架构默认集成的 Hermes 引擎性能更好。</strong></p><p>性能好的核心原因是，相对于 React Native 老架构采用的 JavaScript Core 引擎，Hermes 引擎是专门为移动端打造的。</p><p>在 PC 时代，我们会说电脑的性能有点过剩，但移动端时代，因为手机体积有限，性能其实是吃紧的，这个问题在一些低端机上体现得更加明显。</p><p>现在虽然我们听说的 V8 引擎、JavaScriptCore 引擎都专门为移动端做了架构升级，但由于这些引擎早在 PC 时代就诞生了，考虑很多历史限制条件，也不可能为 React Native 做专门的定制。但 Hermes 没有这些历史包袱，可以专门为移动端来定制开发。</p><p>而React Native 的老架构默认用的是 JavaScriptCore。JavaScriptCore 也叫做 JSC，它采用的是 JIT 的即时编译方案。什么叫 JIT 即时编译呢？</p><p>我用一段最简单的代码给你举个例子：</p><pre><code class=\"language-plain\">const a = 1;\nconsole.log(a);\n</code></pre><p>这里，你本地的 JavaScript 代码会先经过 Babel 的编译，把新语法编译为用户手机里 JavaScript 引擎支持的语法，然后下发到用户手机里去执行。</p><p>这里注意一下，<strong>我们使用 JSC 这类 JIT 即时编译引擎，下发的依旧是 JavaScript 代码</strong>。</p><p>但用户手机里的硬件只能执行由 0101 组成的机械码，硬件是不能直接执行 JavaScript 代码的，那怎么办呢？这时候，JSC 这类 JIT 即时编译引擎，现在主流的做法是先将 JavaScript 代码编译为字节码，然后再编译为机器码。</p><p>因为 JSC 引擎执行代码的过程是编译一段执行一段，再编译一段再执行一段，这种一边编译一边执行的方式就叫做 JIT 即时编译。</p><p>但是，在初始化时， JSC 引擎还需要把整个 JavaScript 代码都编译和执行一次。那你可能就想到了，是不是有办法先提前编译成机械码，然后把由 0101 组成的机械码下发到用户手机上，这样 JavaScript 引擎就不需要编译，只执行机器码就行了，这样 App 的初始化速度不就快了吗？</p><p>这个在本地提前把 JavaScript 代码编译为 0101 机器码的思路很好，但是由于 0101 的机械码体积很大，是 JavaScript 的 10 倍以上，那网络耗时就上去了。那么，既然提前编译为 0101 机械码不可行，我们能不能退一步编译为字节码呢？这样也能节约一部分编译时间啊。</p><p><strong>Hermes 引擎就是这个思路，它在本地先将 JavaScript 编译为字节码，然后再下发字节码。</strong></p><p>Hermes 引擎下发的字节码的体积和 JSC 引擎下发的 JavaScript 代码是一样大的，但 <strong>Hermes 引擎执行字节码的首屏性能，却是 JSC 引擎执行 JavaScript 首屏性能的 2 倍以上。</strong></p><p>这就是Hermes 引擎为什么这么吸引我的原因。</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/ed/3cc9ecb857d4099cb7812e2688dc9fed.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>React Native 新架构第二个吸引我的原因是 Fabric 渲染器。什么是 Fabric 渲染器呢？</p><p>Fabric 渲染器中的通信层，相信你肯定很熟悉，但是通信层只是 Fabric 渲染器的一部分。很多人以为老架构升级到新架构，就是改改 JavaScript 和 C++ 之间通信的 JSBridge 就行了，<strong>其实 JSBridge 这部分的优化在  0.62 版本，也就是 2020 年的版本中已经完成得差不多了。</strong></p><p>JSBridge 的作用是通过消息通知的形式，实现 JavaScript 和 C++ 之间的相互调用。消息通知形式中的消息，其实是一个字符串数组，这个字符串数组中包含了一系列的操作命令和操作参数。但字符串数组不能直接生成、也不能直接用，它有个序列化和反序列的过程，这个过程既浪费了时间、也浪费了内存。</p><p><strong>新架构中已经把 JSBridge 这种消息通知形式改为 JSI（JavaScript Interface）。</strong>有了 JSI 后，React Native 中的 JavaScript 就直接调用 C++了，就像 node.js 使用 addon 调用 C++ 、Flutter 用 FFI 调用 C++ ，以及 Java 使用 JNI 调用 C++ 一样。</p><p>但是，JSI 只是 Fabric 渲染器的一部分。如果你看过 React Native 新老版本源码的话，你会发现新架构在兼容老架构的基础上，几乎把整个底层全给重构了。</p><p>不知道你有没看过我翻译的 <a href=\"https://reactnative.cn/docs/architecture-overview\">React Native 架构</a> ，我把这篇文章也放在了 React Native 中文网上，简单说有这几点：</p><ul>\n<li>它涉及上层 React 改动，包括 Fiber 节点、Concurrent 并发模型等等；</li>\n<li>上层 React Native 的 JavaScript 部分的改动，包括 nativeFabricUIManager 渲染管理器、ScrollView 组件等等的改动；</li>\n<li>在 C++ 层涉及 Shadow Tree、线程模型、视图拍平等的改动和优化；</li>\n<li>在 Java/OC 层面把绝大部分的 Native 组件都给重写了，而且为了兼容还保留了新老架构两套逻辑。</li>\n</ul><p>其中改动的细节，我们暂且不聊，我这里只想和你分享一下，Fabric 渲染器三个吸引我的点。</p><ul>\n<li>第一个点，我已经讲过了，Fabric 渲染器和新架构的 API 共用了通信层，<strong>在 JavaScript 和 C++ 通信这一层的性能也是提升了 3 倍左右。</strong></li>\n<li>第二个点是**更容易保持跨平台一致性，毕竟 C++ 这块代码都是公用的。**原来的 Shadow Tree、布局逻辑、视图拍平都是在各个平台单独实现的，现在新架构把这些用 Java/OC 代码实现的逻辑放到了 C++ 层。</li>\n<li>第三个点，是<strong>拥有优先处理紧急任务的能力。</strong>新架构会集成 React18 的 Concurrent 并发模型，有些同学可能对 React18 Concurrent 并发模型有所了解，并发模型可以让优先级更高的渲染任务先执行，优先级低的渲染任务可以中断或批量渲染。</li>\n</ul><p>这里我们简单讲讲 Concurrent 并发模型。这有点类似我们日常处理工作，同一时刻我们一般只能处理一件事，要是同时来了几件事情怎么办？工作中我们会把事情按重要性和紧急程度分级， Concurrent 并发模型就是把渲染任务按重要性和紧急程度分级处理的策略。</p><p>对于并发模型的优化效果，我们很难拿出个数据指标说优化了 10%、20%，但从原理上，我相信是可以提高用户交互的体验的。</p><p><img src=\"https://static001.geekbang.org/resource/image/63/58/630421a5d8faa52af0a1a7d505089b58.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>看到新架构的 Hermes 引擎和 Fabric 渲染器性能确实好，你可能想赶紧用上，但别着急。</p><p><strong>React Native 新架构目前还是预览版，这也意味着新架构还没有经过大规模的应用，如果贸然用到业务中去，可能会有风险。</strong></p><p>我们这些搞技术的人，热爱前沿技术是一件好事，但用什么技术得根据自己业务的实际情况来。换句话说，我们既要与时俱进，也要接地气，不能飘着，这样才更容易推动技术落地。</p><p>技术要想落地至少分为三步，首先得确定收益，对业务没有收益的事情就不考虑了。其次是确定成本和风险，最关键的控制风险，新技术线上出了大规模故障我们是要担责任的。无论通过业务试点、灰度、降级，还是其他别的方案，我们要把风险控制好，新技术才能进入大规模应用阶段。</p><p>但任何技术内部的技术点都是存在生命周期的，这就像生物体内的细胞存在新陈代谢一样，新的技术点会慢慢地替代老的技术点，而老的技术点会被慢慢淘汰。</p><p>我在和用到 Hermes 的同学聊的时候，他们的反馈都很不错，告诉我线上很稳定，而且对低端机的长列表性能有提升。可以预见的是， Hermes 这个技术点，会慢慢把 JSC 淘汰掉。</p><p>而 Fabric 这个技术点，还处于技术生命周期中的预研期，目前看来收益不错，接下来就是想办法排除风险，然后大规模应用。</p><p>关于 React Native 新架构这件事情，<strong>我的判断是 React Native 新架构在未来 1~2 年会得到大规模应用。</strong>为什么要 1~2 年这么长的时间呢？一方面，现在新架构还是预览版，正式版可能会在今年下半年发；另外一方面，大规模应用要排除风险，排除风险也是需要一段时间的。</p><p>那这新架构普及的 1~2 年的时间差对个人的意义在哪呢？</p><p>我认为，一个技术人越是走在业内前面，你就越是能把握住技术红利，而这对于个人成长和职级晋升都是有好处的，因此这 1~2 年的时间就是你研究新架构的最好时间。</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/3a/9abdc4115727645eaa46a75e037a323a.jpeg?wh=1920x1080\" alt=\"图片\"></p><h2>未来：前进，探索未知的新大陆</h2><p>像 React Native 新架构在 1~2 年内得到大规模应用这种事情还是比较好预测的，但我还想看到更远的未来。比如：</p><ul>\n<li>未来 2~3 年像 React Native 这类新架构会是怎么样的？</li>\n<li><strong>在更遥远的未来，比如 5~10 年后，手机没有性能问题了，H5 会不会替代跨端技术？</strong></li>\n<li>如果跨端技术未来都不存在了，那我死磕跨端技术是不是浪费了青春？</li>\n</ul><p>对待这些问题，我内心是恐惧又兴奋，恐惧的是未来的不确定性，兴奋的是我可能问到了跨端技术的本质，恐惧和兴奋同时驱使着我去寻找这些问题的答案。</p><p>我的解题思路是这样的：</p><ul>\n<li>未来是未知的，但过去是已知，我可以从历史经验中寻找答案；</li>\n<li>历史上的跨端技术的终局是什么样的？又是哪些因素导致了当前的跨端格局的形成？</li>\n<li>那未来这些因素还会不会继续存在？如果这些因素还会继续存在，那么跨端技术是不是会继续存在？如果不存在跨端技术又会被什么技术代替？</li>\n</ul><p>我们先来看历史。</p><p>我们当前所处的时代还是移动互联网时代，我们现在所聊的跨端技术，大都指的是跨 Android、iOS 两端。历史上对类似“跨端”的技术，有个更通用的叫法，叫做跨平台（Cross Platform）。</p><p><strong>任何跨平台、跨端软件的共性都是屏蔽底层差异，抽象统一接口，减少开发者的适配成本。</strong>而跨平台中的平台二字，通常指的是硬件平台和软件平台，软件平台又包括操作系统平台和软件程序环境。</p><p>硬件平台中最重要的是 CPU，你可能知道目前 CPU 分为两个派系，一个是 ARM 精简指令集，另一个是 X86 复杂指令集，而且每个派系之间还有不同的硬件生产商，有 Intel、AMD、高通、苹果、华为等等。</p><p>操作系统是跨硬件平台的。操作系统平台是运行在硬件平台之上，电脑上常用的操作系统包括，Windows、macOS、Linux，手机上就是 Android、iOS。操作系统中有一类特殊的程序，叫驱动程序，驱动程序是硬件厂商根据操作系统编写的配置文件，可以说，没有驱动程序，计算机中的硬件就无法工作。类似的还有苹果的 macOS 操作系统，它也通过 Rosetta 屏蔽了 ARM 和 X86 的差异。</p><p>无论是操作系统提供的驱动程序适配，还是类似 Rosetta 二进制编译器，都是操作系统为跨硬件平台所做的努力。</p><p>程序执行环境是跨操作系统平台的。在操作系统之上直接创建的应用，我们叫做原生应用。原生应用只能在一个平台运行，比如 Android 应用只能运行在 Android 操作系统上。但哪个开发者不想省事啊？历史上 Java 提过“Write once, Run anywhere”，还有服务端同学熟悉的 Docker 镜像，以及前端同学熟悉的 Chrome 浏览器，都是类似的思想。</p><p>Java、Docker、Chrome、跨端框架都是在操作系统之上的程序环境 ，它们会屏蔽不同操作系统之间的差异性，并向开发者提供了统一的抽象接口，让开发者可以只写一次代码，并运行在多个操作系统之上。</p><p><strong>历史的经验告诉我们，无论是硬件平台、操作系统平台、还是程序环境平台，没有哪个平台是一家独大、独霸整个市场的。同一个维度的平台之间，没有赢家通吃的垄断，只有少数几个寡头之间的竞争，寡头竞争的格局产生了跨平台的需求。</strong></p><p>从历史和行业视角来看，无论是能源、汽车、金融、软件和现在的互联网行业，都是从原子式的竞争格局走向寡头竞争的格局的。因此，我认为无论未来的商业格局怎么变化，未来的操作系统、未来的程序环境也不会一家独大。</p><p>所以跨端、跨平台的不是伪命题。只要还存在多个寡头并存的平台竞争格局，跨端的需求就会一直存在。认识到这点之后，我对跨端技术未来的担忧也就消失了。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/05/2c5f88f06d3ea1ddaa86750c3e3a5f05.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>虽然跨端方向是一个很好的技术方向，但跨端的技术很多，有小程序、Flutter、React Native、H5/Hybrid，具体到每个技术上又有细分。一个人的精力是有限的，多嚼不烂，我应该选择那个方向重点研究呢？</p><p>目前我自己规划的重点研究方向是 React Native SSR。为什么我最终决定选择 React Native SSR 作为重点研究方向呢？有三个原因：</p><p><strong>1、“Native SSR” 的市场很大。</strong></p><p>目前绝大多数的 Native 应用采用的还是客户端渲染 CSR 方案，没有成熟的服务端渲染 SSR 方案。</p><p>不过我们也能看到，在 Native 应用中，大厂都有自研自己的<a href=\"https://juejin.cn/post/7046299455397560350\">布局动态化、逻辑动态化</a>的方案，说明这块的需求还是很强的。Native 服务端渲染的 “SSR ” 方案主要的优势在于，业务可以随时上线、可减少包体积，还有跨端优势。</p><p>比如我们58同城推出的 Flutter 模板动态化方案 <a href=\"https://github.com/wuba/fair\">Fair</a> 、字节跳动的 Android/iOS 跨端动态化方案 <a href=\"https://github.com/hxxft/lynx-native\">Lynx</a> ，还有美团的 Flutter 跨端动态化方案 <a href=\"https://tech.meituan.com/2020/06/23/meituan-flutter-flap.html\">Flap</a> ，Airbnb 的 <a href=\"https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab\">Server-driven rendering</a> 方案等。</p><p>但是各家都是自造轮子，市面上并没有出现一个得到大规模应用的 SSR 框架，说明这类动态化技术方案还处于早期探索阶段。</p><p><strong>2、目前看来，“Native SSR” 要成还得依赖 JavaScript 生态。</strong></p><p>为什么这么说呢？因为目前的 Native 应用中用的大部分是 CSR 渲染。虽然也有服务端下发 DSL 渲染静态页面的解决方案，但处理复杂的业务逻辑上，DSL 完全不够。</p><p>DSL 是什么呢？比如 HTML、JSON 这种非图灵完备的语言就是 DSL，非图灵完备就决定了，它只能解决特定领域的问题，不能解决普适性的问题，复杂业务更是没法处理。</p><p>而且，由于苹果公司的政策，只有特定的 JavaScript 程序才能够动态更新，因此能够同时满足跨端、图灵完备和动态更新的特点的语言只有 JavaScript。</p><p>但现有的 “Native SSR” 也有采用 JavaScript 方案的呀，为什么没有大规模应用呢？因为现有的  “Native SSR” 还要解决第二个问题，也就是同构问题。</p><p>Web SSR 也是解决了同构问题之后才大规模铺开的，也就是一套代码既可以在本地跑起来，又可以在服务端跑起来。即使 SSR 方案在服务端扛不住了，还有 CSR 方案在客户端帮忙兜底，开发 SSR 的适配成本很低，这才能流行起来。</p><p>如果你要是让开发者，在Android 写一套代码，在iOS 写一套代码，SSR 写一套代码，CSR 又写另一套代码，开发者就会说，“你这方案再牛逼，我也不想用”，成本太高了。</p><p><strong>3、“Native SSR”  借助 React Native将有机会得到大规模应用。</strong></p><p>首先你可能会问，为什么 “Native SSR” 得借助 React Native 来实现呢？</p><p>在大规模应用 “Native SSR” 必须使用 JavaScript 方案和解决同构问题的双重前提下，目前我能想到的只有 React Native 了。但光有 React Native 还不够，还得有个 React Native 版的服务端渲染框架，类似于 Web 中 Next.js。</p><p>目前 Web SSR 的方案大致是，开发者先在本地实现一个 React 应用，然后把本地实现的 React 程序跑在 node.js 服务端上，要跑在服务端就得借助 Next.js 框架了。Next.js 把服务端渲染、路由方案都给配置好了，我们的 React 程序直接拿来用就行了。</p><p>然后 Next.js 框架执行 React 程序代码生成 HTML，HTML 下发到浏览器就能把 Web 页面首屏直接渲染出来了。</p><p>那同样的，React Native 要大规模实现 SSR，就得造一个 Next.js 的轮子。让 React Native 能同时在本地和服务端运行起来。首先开发者在本地，能通过 “类 Next.js” 的框架使用客户端渲染 CSR 的方式，开发 React Native 应用，然后在服务端能通过服务端渲染 SSR  的方式，执行 React Native 代码，输出一个序列化 Tree。这个序列化的 Tree 描述的就是 React Native 的静态布局结构。</p><p>接着服务端把序列化的 Tree 下发到 iOS/Android 应用上，Native 应用对 Tree 进行反序列化后，直接通过 C++ 层的 <a href=\"https://reactnative.cn/docs/render-pipeline\">Fabric 渲染器</a> ，执行布局、提交和挂载操作，生成 Native 页面。</p><p>这就是借助 React Native 实现 “Native SSR”  的基本原理。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/c9/41334efa780c78a08bfa776b8a1f8cc9.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>有些小伙伴可能会问，原来的 React Native 不是有热更新吗？热更新不是也可以实现动态化吗？</p><p>那 React Native 的热更新和 React Native SSR 有什么区别呢？</p><p>React Native 热更新的本质还是客户端渲染 CSR 方案，首屏渲染速度要比服务端渲染 SSR 方案慢上不少。根据我的性能优化经验，一个复杂的 React Native 应用，采用热更新方案渲染耗时在 2000ms 左右，如果做到极限可能在 700ms 左右。当然，一般达不到极限，因为越是极限，要满足的条件越苛刻，业务的应用范围越小。</p><p>CSR 渲染的渲染步骤分为 6 步：</p><ol>\n<li>请求服务端获取最新的 Bundle 资源地址；</li>\n<li>通过返回的资源地址，下载 Bundle 资源，也就是 JavaScript 代码；</li>\n<li>初始化 JavaScript 引擎和 Native 模块；</li>\n<li>执行 JavaScript 代码，生成空页面；</li>\n<li>与此同时发起业务请求，请求最新的业务数据；</li>\n<li>业务数据回来后重新渲染，生成最终的页面。</li>\n</ol><p>SSR 渲染其实是对 CSR 渲染的步骤的重组，整体也是 6 步：</p><ol>\n<li>并行请求 Tree，和最新的 Bundle 资源地址；</li>\n<li>初始化 Native 模块，同时开启后台线程并行请求 Bundle 资源；</li>\n<li>使用 Tree 文件，通过 Fabric 渲染器渲染首屏页面。这里画个重点，此时用户已经可以看到业务页面了；</li>\n<li>然后再初始化 JavaScript 引擎，开始执行 JavaScript 代码；</li>\n<li>这一步有个专有名词叫做 Hyration。大致的意思原来通过 Tree 生成的页面是不可交互的“静态”页面，这时需要通过执行 JavaScript，生成一个有交互的“动态”页面，把原来的“静态”页面替换掉；</li>\n<li>替换后的页面，就是可以交互“动态”页面了。</li>\n</ol><p>使用 SSR 配合预请求，理论上实现 100ms 以内的首屏渲染是没有问题的。比如，美团就实现了 <a href=\"https://ppt.infoq.cn/slide/show?cid=94&pid=3696\">React Native SSR </a>，据说页面渲染最快可以达到 50ms 。</p><p>当然，要大规模应用，一方面要依赖 React Native 团队提供更友好的接口，另一方面还得有类似 Next.js 的框架，来大幅降低开发者的适配成本。</p><p><img src=\"https://static001.geekbang.org/resource/image/20/28/20ca18b97ffa5116d1a497200yya3828.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>好了，这就是我跨端的故事，希望我过往经验和观点能对你的工作有所帮助。</p>","neighbors":{"left":{"article_title":"12｜页面实战：如何搭建一个电商首页？","id":510659},"right":{"article_title":"13｜生态：React Native Awesome","id":512920}}},{"article_id":512920,"article_title":"13｜生态：React Native Awesome","article_content":"<p>你好，我是蒋宏伟。</p><p>上一个模块我和你介绍的是 React Native 的基础知识，通过核心基础篇 12 讲的学习，你现在是否达成学习目标，可以搭建一个简单的 React Native 页面了呢？</p><p>接下来，在社区生态篇这个模块中，我们将要再进一步，学习搭建一个完整的 React Native 应用。但在搭建 React Native 应用的过程中，除了 React Native 本身的知识，我们还需要用到很多 React Native 生态中的知识和工具。</p><p>不过，React Native 生态是一个非常庞大的概念，我没有办法只用六讲，就把其中所有的知识点都讲透彻。但用更多的篇幅去讲，效果也不一定好，很多知识是用到的时候才需要去深入学习的，在此之前你只需要知道这些知识大概是干什么用的就可以了。真正用到的时候，一边实践一边学习的效果会更好。</p><p>因此，这一讲的目的不是告诉你，你还要学什么，而是告诉你，你可能会用到什么。只要在你需要的时候，你还能想到，还有这样一个技术能够解决你的问题，那今天这一讲的目的就达到了。</p><p>另外，我们这一讲采用的是 GitHub 社区 Awesome 的形式，为你推荐一些我精选的参考资料。参考资料中，有很多都是英文的，我知道你会觉得很难啃，但相信我，这些一手的英语资料能给你带来更大的帮助。</p><!-- [[[read_end]]] --><p>所有的推荐资料，我都帮你打上标签了，有入门类、实践类、课程类、开源库等等，你也可以把这一讲当作一个手册来用，这些标签能够方便你按需查找。</p><h2>语言和框架</h2><p>学习 React Native，我们首先需要建立起对 React Native 的整体认知，然后才是学习开发语言 JavaScript/Typescript ，以及开发框架 React。我们接下来就这个逻辑进行推荐。</p><p><strong>第一类：React Native 快速入门。</strong></p><p>首先，我们必须清楚这样一个事实，互联网行业的竞争非常激烈，技术迭代也很快，一篇技术博客发出来，你三四年后再回头看可能就过时了。我在给你挑选学习 React Native 类资料时，就面临这个问题，除了官网和一些收费网课外，能选择的太少。最后我选择了下面这几类：</p><ul>\n<li>&lt;入门-英文&gt; <a href=\"https://www.youtube.com/watch?v=0-S5a0eXPoc\">React Native Tutorial for Beginners - Build a React Native App [2020]</a>：虽然这是两年前的资料了，但绝大部分内容直到现在也没有过时，而且视频的形式，也能带着新手一步一步操作学习，效率很高；</li>\n<li>&lt;网站-英文&gt;<a href=\"https://www.reactnative.express\"> React Native Express </a>：适合想快速了解 React Native 中各种概念的新人；</li>\n<li>&lt;课程-英文&gt; <a href=\"https://www.udemy.com/course/the-complete-react-native-and-redux-course/\">The Complete React Native + Hooks Course</a>：这是优达学院最受欢迎的 React Native 视频课程。它是基于 React Native 0.62 版本开发的付费课程，内容详细而且完整，包括入门、React、Hooks、样式、导航、状态、布局、请求，以及搭建一个简易 React Native 应用，也是非常适合新手的入门课程。</li>\n</ul><p><strong>分类二：学习 JavaScript。</strong></p><p>如果你以前从事的是客户端开发，没有 JavaScript 开发经验，你可以参考如下资料：</p><ul>\n<li>&lt;入门-中英&gt;<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript\">MDN JavaScript 教程</a>：MDN 是前端同学必备的网站，它的内容非常权威，如果你有编程基础，通过这一篇文章你就能快速掌握 JavaScript；</li>\n<li>&lt;电子书-中文&gt;<a href=\"https://es6.ruanyifeng.com/\">ES6 入门教程</a>：ES6 相当于 JavaScript 的一个“版本号”。ECMAScript 规范每年都会更新一个版本，ES6 对应的是 ECMAScript 2015 的版本，今年的最新版本是 ECMAScript 2022。但由于 ES6 对于 JavaScript 有划时代的意义，所以也是最广为人知的版本，你既可以它当作入门书籍一步步学习，也可以把它当作手册进行查询；</li>\n<li>&lt;练习-英文&gt;<a href=\"https://learnjavascript.online/\">Learn JavaScript 网站</a>：如果你觉得光看资料很难学好 JavaScript，你也可以用这个网站边学边练。它提供了学习 JavaScript 的思维导图，把 JavaScript 的知识分为了 13 个部分。其中的 DOM 部分虽说是浏览器的专属，但 React Native 新架构底层操作 Shadow Node 也是用的类似的 API，这一部分了解即可，不需要深入学习。你可以根据思维导图，看看自己还需要学习哪些部分。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/94/2f/94641698af229e54db92584b1bd9452f.png?wh=1920x1780\" alt=\"图片\"></p><p><strong>分类三：学习 TypeScript。</strong></p><p>如果你真要写业务项目的话，无论这个项目是大是小，我都推荐你用 TypeScript 而不是 JavaScript。TypeScript 的静态类型检查功能，不仅能减少潜在的线上 Bug，还能提高项目的可维护性，这些对于业务都至关重要。这部分的资料我推荐：</p><ul>\n<li>&lt;入门-中文&gt;<a href=\"https://juejin.cn/post/6844904182843965453\">1.2W字 | 了不起的 TypeScript 入门教程</a>：这是掘金最受欢迎的 TypeScript 入门课程，作者将 TypeScript 的入门知识分为了十四个知识点，一步步带你学习，同时作者还给了一个 TypeScript 思维导图，我把它放在了下面；</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/1f/54/1f411eac983d3c28b7028e565685b654.png?wh=1000x844\" alt=\"图片\"></p><ul>\n<li>&lt;练习-中英&gt;<a href=\"https://github.com/type-challenges/type-challenges\">Type Challenges</a>：如果你觉得光看文字不过瘾，你可以结合 Type Challenges 和 TypeScript 官网提供在线编辑器一起练习；</li>\n<li>&lt;实用-英文&gt;<a href=\"https://github.com/typescript-cheatsheets/react\">React+TypeScript Cheatsheets</a>：真正开发的时候，TypeScript 和 React 是结合起来一起用的，React 自定义了很多 Type 类型，使用这个小抄本能帮你快速掌握 TypeScript 和 React 结合使用的最佳实践。</li>\n</ul><p><strong>分类四：学习 React。</strong></p><p>对于 React 的学习，我唯一推荐的资料是 <a href=\"https://beta.reactjs.org/\">React 新官方</a>，里面的每一篇文章我都认真读过，每一篇都是经典。可惜的是，它还是 Beta 版本，官方分为两部分：</p><ul>\n<li>&lt;教程-英语&gt;<a href=\"https://beta.reactjs.org/learn\">Learn React</a>：这部分既有初学者入门的教程，也有深入学习的教程，同时还有配套的示例和练习材料。目前 Learn React 部分完成了 70%，但对于入门和进阶来说，已完成的 Learn React 部分已经完全够用了；</li>\n<li>&lt;手册-英语&gt; <a href=\"https://beta.reactjs.org/apis\">API Reference</a>：这部分是 React 的 API 手册，目前这部分只完成了 5%，所以你要查询 API 只能到 <a href=\"https://zh-hans.reactjs.org/\">React 老官网</a>上去查询了。</li>\n</ul><p>另外，我还为你附上了 React 核心知识的学习路径图，这张图来源于 <a href=\"https://roadmap.sh\">roadmap.sh</a>，它是一个专门创建学习路线图的社区。因为你只需要学习 React 的基础知识和进阶知识，所以其中的Web 内容我去掉了，可以对照 React RoadMap 看下自己哪些已经掌握了，哪些还要进一步的学习：</p><p><img src=\"https://static001.geekbang.org/resource/image/40/2f/40f83f368e0f5b7e5b9fc159c9497f2f.png?wh=1920x1251\" alt=\"图片\"></p><h2>项目工程</h2><p>上一部分主要是打基础，接下来创建项目之前，我们还要考虑用项目中的技术选型，包括脚手架、包管理、状态管理、自动化测试，等等。</p><p><strong>第一部分：脚手架。</strong></p><p>在脚手架的选择上，每个团队都会有自己的偏好，创建项目的选择也不一样，你可以根据自己团队的情况四选一：</p><ul>\n<li>&lt;脚手架-中文&gt;<a href=\"https://reactnative.dev/docs/next/environment-setup\">react-native init</a>：首先 React Native 官方提供了 react native init 命令，它属于脚手架的基础款；</li>\n<li>&lt;基础设施-英文&gt;<a href=\"https://docs.expo.dev/\">Expo</a>：它帮你集成了一系列的原生工具和能力，还能帮你构建和部署，并同时支持 Android、iOS 和 Web。Expo 不仅仅是一个脚手架，更是一套 React Native 的基础设施。在国内，主要是出海的应用在用；</li>\n<li>&lt;功能模块-英文&gt;<a href=\"https://docs.expo.dev/bare/installing-expo-modules/\">Expo modules</a>：如果你团队开发的应用，用户群主要在国内，而且需要用户自己独立构建和部署，Expo 提供的原生工具和能力也可以单独按需使用；</li>\n<li>&lt;脚手架-英文&gt;<a href=\"https://github.com/infinitered/ignite\">Ignite</a>：这是由一群美国的开发人员和设计师组成的组织 Infinite Red 开发的，这个脚手架会帮你做包管理、状态管理、自动化测试等方面技术选型，所以你不需要做这些选型和配置工作了，开箱即用就行。</li>\n</ul><p><strong>第二部分：包管理。</strong></p><p>在第三方包的管理上，业内常见的方案有三种。它们之间的差别并不大，但根据我的经验，我更加推荐你用 yarn。它们主要的区别在这：</p><ul>\n<li>&lt;推荐-中文&gt;<a href=\"https://yarn.bootcss.com/\">yarn</a>：yarn是 Meta 团队开源的包管理工具，在安装包的速度上和功能上，都比 npm 更强一些。需要注意的是，你用 Yarn 的 classic 版本就可以了，yarn 的 v2、v3 版本相对 classic 版本变化太大，用的人也较少；</li>\n<li>&lt;自带-中文&gt;<a href=\"https://www.npmjs.cn/\">npm</a>：这是 node.js 自带的包管理工具，你在搭建 React Native 环境时就已经安装了 node.js，因此 npm 直接可以用；</li>\n<li>&lt;更快-中文&gt;<a href=\"https://www.pnpm.cn/\">pnpm</a>：它是比 npm 和 yarn 速度更快的包管理工具，Ignite 脚手架就是在用 pnpm 管理包。但我在使用 pnpm 搭建 React Native 的 monorepo 项目时，碰到了和打包工具  metro 的兼容问题，后续就放弃使用了。</li>\n</ul><p><strong>第三部分：状态管理。</strong></p><p>状态管理是一个很复杂的话题，我们这里简单介绍一下，React/React Native 的状态管理可以分为四类：</p><ul>\n<li><strong>React 自带</strong>：包括 <a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate\">useState</a>、<a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer\">useReducer</a> 和 <a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext\">useContext</a>。当你准备用 useContext 的时候，你可能就需要使用社区状态管理工具了，因为 useContext 需要大量的手动性能优化，不适合大规模使用；</li>\n<li><strong>第三方库</strong>：常用的方案有 <a href=\"https://redux-toolkit.js.org/\">Redux + Redux Toolkit</a>、单独的 <a href=\"http://cn.redux.js.org/\">Redux</a>、<a href=\"https://cn.mobx.js.org/\">Mobx</a> 和 <a href=\"https://github.com/pmndrs/zustand\">Zustand</a>，在我以前做的<a href=\"https://docs.qq.com/sheet/DQWdsZ0RORkpFQmVj?tab=BB08J2\">《大家开发 RN 都用什么？》</a>调研报告中，我发现大家用的最多的还是 Redux，但是 Redux 单独使用起来成本高，因此我建议你配合 Redux Toolkit 一起使用；</li>\n<li><strong>hooks 工具</strong>：hook 是一种抽象和复用组件状态逻辑的机制，因此 hooks 类工具很多，常用的、能帮我们管理部分状态 hooks 工具主要是这几类。<a href=\"https://react-query.tanstack.com/\">react query</a> 和 <a href=\"https://github.com/vercel/swr\">SWR</a> 可以帮我们管理请求，<a href=\"https://github.com/react-hook-form/react-hook-form\">react-hook-form</a> 和 <a href=\"https://github.com/jaredpalmer/formik\">formik</a> 可以帮忙管理表单；</li>\n<li><strong>GraphQL</strong>：现在后端接口大多是采用(类) RESTful 架构，我们用的 GET、POST 请求就是这种架构。相对于 RESTful 架构，GraphQL 提供了一种更加灵活的请求后端接口的方案。GraphQL 是一种架构模式、是一种规范，业内有两种具体的实现，一种是开源社区常用的 <a href=\"https://apollographqlcn.github.io/react-docs-cn/\">Appolo</a> 方案，另一种是 Meta 团队开源的 <a href=\"https://relay.dev/\">Relay</a> 方案。</li>\n</ul><p>这四类状态管理工具，不同类别之间可以灵活搭配使用，我在下面的状态管理表单图中，用绿点给你标注了我的推荐，蓝框中的工具是同一类工具，二选一即可：</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/a3/f05e2c114ffb27651cf98a967dee5ea3.png?wh=1920x996\" alt=\"图片\"></p><p><strong>第四部分：自动化测试。</strong></p><p>国内业务类的测试主要还是以 QA 测试为主，但一些由技术主导的通用组件和通用工具，有时候不一定有 QA 资源帮忙测试，这时候自动化测试就能派上用场了。我这里也给出了一些推荐：</p><ul>\n<li>&lt;单元测试-中文&gt;<a href=\"https://jestjs.io/zh-Hans/\">Jest</a>：这是 Meta 团队开发的一款 JavaScript 单元测试框架，单元测试中的单元指的是最小可测试粒度的函数单元。</li>\n<li>&lt;组件测试-英文&gt;<a href=\"https://github.com/callstack/react-native-testing-library\">react-native-testing-library</a>：这是专门用来测试 React Native 组件的。比如，它提供了 render 方法可以专门测试组件渲染是否正确，fireEvent 方法可以专门用来测试事件返回值是否正确；</li>\n<li><a href=\"https://github.com/wix/Detox\">Detox</a>：它可以帮你在真机/模拟器运行测试代码，更符合真实环境。</li>\n</ul><h2>样式和组件</h2><p>脚手架搭建好之后，就到具体开发环节了。在这个环节中，最重要的就是组件和样式的学习。</p><h3>样式</h3><p>样式分为两类，一类是写样式的工具函数，另一类是自带风格样式的组件库，我们这里简单介绍一下，先来看看样式工具。</p><p>样式工具可以分为三小类：</p><ul>\n<li>第一类是 React Native 自带了 “CSS In JS” 的 <a href=\"https://reactnative.cn/docs/next/stylesheet\">StyleSheet</a> 接口；</li>\n<li>第二类是 <a href=\"https://styled-components.com/\">StyledComponent</a> 这种方案，如果你喜欢纯正的 CSS 语法，可以选用这种；</li>\n<li>第三类是 CSS 的“简拼”方案 <a href=\"https://www.tailwindcss.cn/\">Tailwind</a>，它和 CSS 的区别类似我们打字时全拼和简拼区别，能让你敲击键盘的次数更少一些，但你需要记住它的“简拼”规则，而且还有一定的性能损耗。</li>\n</ul><p>我认为在 React Native 中使用 StyleSheet 方案就够了，StyledComponent 和 Tailwind 并不是我的菜。</p><p>然后我们再来看看组件库。类似于 Web 中最流行的 AntDesign 组件库，React Native 也有很多自带风格样式的组件库。</p><p>虽然，移动端的 toC 应用大多都有 UI 帮忙出设计稿，开发同学需要根据设计稿定制开发，所以toC 应用基本是不用组件库的。但移动应用也有很多 toB 应用，这些应用使用组件库开发，能够解决很大一部分的开发成本。</p><p>我最推荐的是近两年最活跃的组件库 <a href=\"https://nativebase.io/\">Native Base</a>，你也可以根据你们团队的喜好选择其他风格的组件库，其他常用的还有 <a href=\"https://reactnativeelements.com/\">React Native Elements</a>、<a href=\"https://reactnativepaper.com/\">React Native Paper</a>、<a href=\"https://akveo.github.io/react-native-ui-kitten/\">UI Kitten</a>。</p><h3>组件</h3><p>组件包括核心组件和一些我们国内常用的组件。所谓的核心组件是我们开发 React Native 应用时使用频率很高的组件，包括路由、手势、动画，这些组件我也会在生态篇进行更详细地介绍，今天你可以先简单了解一下。</p><p>我们先来看看路由这方面有什么解决方案。其实，React Native 本身并没有提供路由解决方案，但社区提供了一些解决方案，包括<a href=\"https://reactnavigation.org/\">React Navigation</a>、<a href=\"https://wix.github.io/react-native-navigation/docs/before-you-start/\">React Native Navigation</a>这两种。这两个库的名字很相似，也都是路由库，但你千万不要搞错了。目前业内主流的选择是 React Navigation，而不是 React Native Navigation，前者的下载量是后者的 20 倍之多，因此我推荐你直接使用 <a href=\"https://reactnavigation.org/\">React Navigation</a> 方案就可以了。</p><p>那手势这边有啥呢？React Native 本身提供了手势事件 PanResponder。PanResponder 是模仿 Web 的手势事件开发的，是命令式的手势事件，它的替代方式是社区开发的 react-native-gesture-handler。react-native-gesture-handler 是声明式的组件，会更符合我们的开发习惯。</p><p>最后再来看看动画的解决方案。动画常用的方案有这三种：</p><ul>\n<li>第一种是 React Native 本身提供的 <a href=\"https://reactnative.cn/docs/animated\">Animated</a> API；</li>\n<li>第二种是社区提供的 <a href=\"https://docs.swmansion.com/react-native-reanimated/\">Reanimated</a> 组件；</li>\n<li>第三种是直接接入设计师使用的 AE 输出的 <a href=\"https://github.com/lottie-react-native/lottie-react-native\">Lottie</a> 动画。</li>\n</ul><p>那这三个方案怎么来进行选择呢？你可以根据具体的业务情况来选择：如果是轻量级的动画，你不想多集成一个库，那你可以直接使用 Animated；如果你对性能要求高又要大规模使用， 那Reanimated 是你最好的选择；最后 <a href=\"https://github.com/lottie-react-native/lottie-react-native\">Lottie</a> 的方案，适合那种没有人机交互的、由 UI 直接提供动画配置文件的动画形式。</p><p>除了前面说的核心组件之外，我们还得关注一些国内常用的组件。因为我们国内客户端生态和国外生态差别很大，很多国外的东西我们不能直接拿来用，而且国内社区的同学也封装了一些我们自己的解决方案。我把一些常用的都列出来了，你可以关注一下：</p><ul>\n<li>&lt;流媒体-中英&gt;<a href=\"https://github.com/AgoraIO-Community/react-native-agora/blob/master/README.zh.md\">react-native-agora</a>：国内做语音、视频、直播很多用的都是<a href=\"https://www.agora.io/cn\">声网</a>的解决方案，该组件是由声网官方维护的 React Native 组件库；</li>\n<li>&lt;HarmonyOS-英文&gt;<a href=\"https://github.com/HMS-Core/hms-react-native-plugin\">hms-react-native-plugin</a>：华为HarmonyOS系统为 React Native 开发的插件，由华为HarmonyOS官方开发维护；</li>\n<li>&lt;推送-中文&gt;<a href=\"https://github.com/jpush/jpush-react-native\">jpush-react-native</a>：JPush 也就是极光推送，是国内客户端的推送解决方案了；</li>\n<li>&lt;地图-中文&gt;<a href=\"https://github.com/lovebing/react-native-baidu-map\">react-native-baidu-map</a>：是社区基于百度地图 Native SDK 封装的 React Native 组件，不过这个已经很久没有更新了，需要自己动手改改才能用。</li>\n</ul><h2>总结</h2><p>这一讲和往常的内容有点不一样，以前讲的内容是技术的深度，这一讲讲的是技术的广度。</p><p>知识输入决定技术输出，我推荐的技术资料大多都是英文资料，如果你放弃了英语类的技术资料，技术的深度和广度提升的速度都会比别人慢一些。这个道理是我从刘毅老师那里学来的，刘毅老师是中国的第一批 Java 程序员，现在是章鱼网络创始人，和刘毅老师交流和学习的时候，经常感叹他为什么对技术研究得这么深刻。</p><p>有一次我就问刘毅老师我说，“您在技术上这么厉害，最关键的原因是什么呢？”刘毅老师告诉我，是英语。他和我解释说最厉害那批程序员大多数都是用英语交流的，他经常去看这些论坛、博客，这样能接触到最前沿知识。</p><p>要想提高自己的技术广度，要想接触到最前沿的知识，这些英文资料肯定少不了。我再给你举个例子，比如 @reduxjs/toolkit 这个状态管理工具已经出来两年了，而且迭代速度很快，但是并没有中文官网。如果你只看中文资料，接触到可能是中文资料作者理解“二手”内容，或者是一年前写的、已经被淘汰的知识。</p><p>因此，在学习 React Native 生态时，我强烈建议你不要对“中文”、“英文”资料有语言偏好，只看中文资料，不看英文资料。我建议你要对“权威的”、“二手的”资料有偏好，并不是说“二手”资料没有价值，而是“权威”资料可以帮你建立一个正确的基准。有了这个基准后，你就有了分辨对错、分辨好坏的能力，再去读“二手”资料就能知道别人讲得好不好、对你有没有价值了，没有这个基准就容易被带偏。</p><p>所以你也能看到，我在给你推荐资料时，多推荐的是“权威”的资料，为的就是帮你建立一个基准认知。我们今天这一讲相当于一个介绍 React Native 生态的手册，目的就是帮你正确地提高技术广度，当你对其中某个内容感兴趣的时候，你可以点击我推荐给你的链接进行更详细地学习。遇到英文材料也不要害怕，你也借助翻译软件 DeepL，边学技术边提升英语能力。相信我，这样你的技术能力会突破得更快。</p><h2>思考题</h2><p>我这一讲中根据我的偏好做了一个精选推荐，你有哪些自己喜欢的学习资料、工具、组件、资源和大家推荐的呢？</p><p>欢迎在评论区和我们分享。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"直播加餐｜七年，我的跨端实践和探索","id":512075},"right":{"article_title":"14｜Reanimated：如何让动画变得更流畅？","id":513844}}},{"article_id":513844,"article_title":"14｜Reanimated：如何让动画变得更流畅？","article_content":"<p>你好，我是蒋宏伟。</p><p>今天我们来聊一聊React Native中动画的原理。在开始之前，我想请你思考一下：动画的本质到底是什么？</p><p>你可能知道，与真实世界中连续运动的事物不同，我们在手机、电脑、电影院的屏幕中看到的动画，实际是由一张张快速切换图片组成的。看动画时，我们的眼睛接收到的是一张张并不连续的静态图片，但我们的大脑把这些不连续的图片“想象”成了一系列连续事件，这就是动画的基本原理。</p><p>而手机动画要想流畅，一般而言需要保证每 1 秒渲染 60 帧的速度。这里的每一帧都是一张静态图片，也就是说 1 秒钟需要渲染出 60 个静态图片。这也意味着手机处理每一帧动画的耗时，需要保证在 16.6ms（=1000/60）以内，如果处理一帧的耗时超过 16.6ms ，就会掉帧。掉帧多了，我们的大脑就会感觉到动画中的不连续性，也就是常说的卡顿。</p><p>动画对渲染性能的要求很高。理论上，你可以使用 setInterval 每 16.6ms 执行一次 setState 改变状态，渲染新的视图，来实现动画。但实际上，setState 是一种耗时比较长的更新页面的方法，特别是在复杂页面、复杂交互的情况下，setInterval  + setState 的方案并不适合用来实现动画。</p><!-- [[[read_end]]] --><p>所以，为了保障动画的流畅性，在涉及动画的业务场景中，<strong>我们还需要引入动画库</strong>。</p><p>在上一讲中，我给你介绍了 React Native 中常用的三种动画工具，包括：适合轻量级动画场景使用的 React Native 自带的 <a href=\"https://reactnative.cn/docs/animated\">Animated</a> 动画；适合无交互场景的、能找 UI 设计师帮忙自动生成的 <a href=\"https://github.com/lottie-react-native/lottie-react-native\">Lottie</a> 动画；以及我今天重点要和你聊的、适用于可交互场景的 <a href=\"https://docs.swmansion.com/react-native-reanimated/\">Reanimated</a> 动画。</p><h2>初学 Reanimated</h2><p>Reanimated 的名字来源于它的那句口号：</p><blockquote>\n<p>React Native’s Animated library reimplemented.</p>\n</blockquote><p>Reanimated 名字中的 Re 就是 Reimplemented 重新实现的意思，Animated 代表就是 React Native 自带的动画库 Animated，加起来就是重新实现的 Animated 动画库的意思。它的潜台词好像就是：如果你觉得 React Native 自带的 Animated 动画库不好用，就来试试我吧，我把 React Native 官方的动画库给重新实现了。</p><p>我们先用<strong>“切换宽度的动画”</strong>的例子，看看 Reanimated 到底应该如何使用。</p><p>这个例子是这样的：现在你有一个视图和一个按钮，视图的高度是固定的，视图的宽度可以用动画来控制，你每点一下切换宽度的文字，视图宽度都会随机改变。示意图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/05/69/05ae457ac9eba406300aafa246549069.png?wh=1920x886\" alt=\"图片\"></p><p>你可以看到，在页面中蓝色视图初始化的宽度是 10 像素，当你点击切换宽度的文字后，蓝色视图的宽度会在 0~350 像素之间随机变化。因为是动画，所以蓝色视图的宽度并不是一下就变宽的，而是连续改变的。在 1s 内，先增长几像素，然后再增长几像素，依次类推直到目标长度，因为刷新的帧率很快，因此人的肉眼看起来就是宽度就是连续变化的。</p><p>那我们怎么用Reanimated实现这个动画效果呢？</p><p>别急，为了帮你更好地吃透这个新知识，我们引入之前学过的State，对比着来学习。那么，使用 Reanimated 实现视图“动画”和使用 State 实现视图“变化”有什么相似之处呢？你可以看下它们的更新步骤的对比：</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/7e/b4653520a9bd29e348671f19b439317e.png?wh=1920x970\" alt=\"图片\"></p><p>你可以看到，无论是用 State 更新页面，还是用 Reanimated 更新动画，都需要 4 步。具体它们有什么相似之处呢？我们直接来分析 Reanimated中的这4个概念：</p><p>第一个概念：共享值（SharedValue）。<strong>Reanimated中共享值这个概念类似于 React 中的状态 State</strong>，我们简单对比下它们各自的代码，先看看State的：</p><pre><code class=\"language-plain\">// State 示例代码\nimport { useState } from 'react';\nconst [randomWidth, setRandomWidth] = useState(10);\n// randomWidth === 10\n</code></pre><p>在 State 示例代码中，驱动视图变化的最初因子是状态。用于初始化状态的钩子函数 useState 是从 react 中引入的，然后在组件中使用 useState 创建出一个随机宽度状态 randomWidth，以及一个改变该状态的函数 setRandomWidth。其中，初始化出来的 randomWidth 是一个默认赋值数字10。</p><p>接着我们看看Reanimated的代码：</p><pre><code class=\"language-plain\">// Reanimated 示例代码\nimport { useSharedValue} from 'react-native-reanimated';\nconst randomWidth = useSharedValue(10);\n// randomWidth.value === 10\n</code></pre><p>在 Reanimated 的示例代码中，驱动动画的最初因子是共享值（ShareValue）。用于初始化共享值的钩子函数 useSharedValue 是从 react-native-reanimated 中引入的。然后使用 useSharedValue 创建出一个对象 randomWidth，randomWidth 的 value 属性是一个默认赋值数字 10。</p><p>第二个概念：衍生值（DerivedValue）。<strong>Reanimated 的衍生值（DerivedValue）这个概念类似于 React 中的状态衍生值</strong>。我们同样先来看State的示例代码：</p><pre><code class=\"language-plain\">// State 示例代码\nconst style = {\n  width: randomWidth\n}\n</code></pre><p>在 State 示例代码中，你可以在组件函数中的任意位置直接使用状态 randomWidth，或者将状态 randomWidth 封装到样式对象 style 中。</p><p>然后是Reanimated的示例代码：</p><pre><code class=\"language-plain\">// Reanimated 示例代码\nimport { useAnimatedStyle } from 'react-native-reanimated';\n\n// 错误示范\nconst style = {\n  width: randomWidth.value\n}\n\n// 正确示范\nconst style = useAnimatedStyle(() =&gt; {\n  return {\n    width: randomWidth.value,\n  };\n});\n</code></pre><p>但在 Reanimated 示例代码中，如果你直接将  <code>const style = {width: randomWidth.value}</code> 组成的样式对象赋值给 JSX 元素，控制视图宽度改变的动画是不生效的。这是 Reanimated 驱动动画和 State 驱动视图的机制不一样导致的。</p><p>这时你需要从 react-native-reanimated 中引入钩子函数 useAnimatedStyle，这个钩子函数是专门用来处理动画样式的衍生值的，它的第一个入参函数的返回值就是动画组件的样式值。</p><p>第三个概念，动画组件（AnimatedComponent）。<strong>Reanimated 的动画组件和 React/React Native 中的组件（Component）概念是类似的</strong>。我们同样先看 State 示例代码：</p><pre><code class=\"language-plain\">// State 示例代码\nimport { View } from 'react-native';\n\n&lt;View style={[{ width: 100}, style]} /&gt;\n</code></pre><p>在 State 示例代码中，你要从 react-native 库中引入 View 组件，并将组件 View 实例化为 JSX 元素。</p><p>然后再看Reanimated的示例代码：</p><pre><code class=\"language-plain\">// Reanimated 示例代码\nimport Animated from 'react-native-reanimated';\n\n&lt;Animated.View style={[{ width: 100}, style]} /&gt;\n</code></pre><p>你可以看到，在 Reanimated 示例代码中，你需要从 react-native-reanimated 引入 Animated 对象，在该对象上挂了常用的 react-native 组件，比如示例代码中的 <code>Animated.View</code>，还有 <code>Animated.Text</code>、 <code>Animated.FlatList</code>等等。</p><p>这些由 Reanimated 包装好的动画组件，比如 <code>Animated.View</code> 等等，使用方式和 <code>View</code> 基本类似。不同的是共享值（ShareValue）和衍生值（DerivedValue）是专门给动画组件（AnimatedComponent）用的，普通组件（Component）用不了。</p><p>第四个概念，更新共享值。<strong>Reanimated 的更新共享值的方式和 React/React Native 更新状态的方式方式是不一样的。</strong></p><p>State的示例代码如下：</p><pre><code class=\"language-plain\">// State 示例代码\nconst [randomWidth, setRandomWidth] = useState(10);\nsetRandomWidth(Math.random() * 350)\n</code></pre><p>在 State 示例代码中，你是通过钩子函数 useState 生成的状态更新函数 setRandomWidth 来更新状态的。</p><p>然后是Reanimated的示例代码：</p><pre><code class=\"language-plain\">// Reanimated 示例代码\nconst randomWidth = useSharedValue(10);\n// 不带动画的更新\nrandomWidth.value = Math.random() * 350;\n// 带动画的更新\nrandomWidth.value = withTiming(Math.random() * 350);\n</code></pre><p>我们可以看到，在 Reanimated 示例代码中，没有共享值的更新函数，它只生成了一个共享值对象，其真正的值是挂在 value 属性下的。你可以直接通过等号 <code>=</code> 把最新的视图宽度 <code>Math.random() * 350</code> 赋值给<code>randomWidth.value</code>。</p><p>事实上，Reanimated 有两种更新方式，一种是不带动画曲线的更新方式，另一种是带<strong>动画曲线</strong>的更新方式。</p><p>你直接把视图宽度 <code>Math.random() * 350</code> 赋值给<code>randomWidth.value</code>，就是通过指定一个最终共享值的方式进行更新的，比如从 10 像素宽度直接变为 100 像素宽度。这种更新方式是一步到位的，没有动画曲线。</p><p>真正的动画是从 10 像素宽度，增长到 11 像素，然后增长到 12 像素，以此类推，通过连续的方式增长到 100 像素宽度的。具体地说，控制每一帧增长多少像素、减少多少像素，是通过类似 <code>withTiming</code> 的动画曲线实现的。<code>withTiming</code> 动画曲线的意思是，启动一个基于时间的动画，在每个单位时间内增长或减少的像素是相等的。</p><p>使用 <code>withTiming(100)</code> 更新共享值时，就会启动基于时间的动画曲线，其默认的持续时间是 300ms。理论上，在这 300ms 内，视图的宽度会从 10 像素开始，以每一帧增加一个固定的宽度的速度，增加到 100 像素。</p><p>切换宽度动画的完整示例代码如下：</p><pre><code class=\"language-plain\">import Animated, {\n  useSharedValue,\n  withTiming,\n  useAnimatedStyle,\n  Easing,\n} from 'react-native-reanimated';\nimport { View, Button } from 'react-native';\nimport React from 'react';\n\nfunction AnimatedStyleUpdateExample(): React.ReactElement {\n  const randomWidth = useSharedValue(10);\n\n  const style = useAnimatedStyle(() =&gt; {\n    console.log('==Animated==')\n    return {\n      width: withTiming(randomWidth.value),\n    };\n  });\n\n  console.log('==render==')\n\n  return (\n    &lt;View&gt;\n      &lt;Animated.View\n        style={[\n          { width: 100, height: 30, backgroundColor: 'cornflowerblue'},\n          style,\n        ]}\n      /&gt;\n      &lt;Button\n        title=\"切换宽度\"\n        onPress={() =&gt; {\n          randomWidth.value = Math.random() * 350;\n        }}\n      /&gt;\n    &lt;/View&gt;\n  );\n}\n</code></pre><p>从上面的代码你可以看出，使用 Reanimated 更新动画的方式和使用 State 更新页面的方式，有很多相似之处。</p><p>其中，还有一点是你需要注意的，就是 <strong>Reanimated 和 State 的更新机制并不一样</strong>。</p><p>在使用 Reanimated 改变共享值触发动画更新时，只会触发示例代码中 useAnimatedStyle 的入参函数的执行，而不会触发 AnimatedStyleUpdateExample 组件函数的执行。也就是说，动画更新是不会打印 “==render==” 日志的，只会打印“==Animated==”日志。</p><p>但整体上讲，二者都是通过数据来驱动视图变化。Reanimated 是专门用来处理动画形式的视图更新的，而 State 是专门用来处理组件、页面渲染的视图更新的。</p><h2>Reanimated 的原理</h2><p>关于 Reanimated 的入门概念，我们先介绍到这里，相信通过 Reanimated 和 State 的类比学习，你已经能把 Reanimated 用起来了。</p><p>但这种学习方式难免可能让你对概念掌握得不够准确，甚至出现一些理解偏差。所以接下来我们要再进一步，了解Reanimated 工作原理，把其中的基础概念弄扎实了，把一些理解有误的地方纠正回来。</p><p>在开发过程中，我们的动画代码和状态代码都是用 JavaScript 写在同一个文件中的，你可能会认为你写的动画部分的 JavaScript 和状态部分的 JavaScript 都是运行在同一个线程中的，但其实并不是这样的。</p><p>听到这个结论，你可能会很惊讶：<strong>为什么动画代码和状态代码都放在同一个JavaScript 文件中，但动画部分代码却由另一个线程来执行呢？</strong></p><p>答案就是：把动画代码放到 UI 主线程来执行性能会更好，动画不容易卡顿。</p><p>你可能知道， React Native 有两个常用的线程：一个是 React Native 的 JavaScript 线程，另一个是 UI 主线程。</p><p>一方面，JavaScript 线程和 UI 主线程是异步通信的，这也意味着，如果是由 JavaScript 线程发起动画的执行，UI 线程并不能同步地收到该命令并且立刻执行，UI 线程至少要处理完成当前一帧的渲染任务后，才会执行 JavaScript 线程的动画命令。也就是说异步通讯会导致动画至少延迟 1 帧。</p><p>另一方面，JavaScript 线程处理的事件很多，包括所有的业务逻辑、React Diff、事件响应等等，容易抢占动画的执行资源。</p><p><strong>正因为 JavaScript 线程非常繁忙，所以如果我们把动画代码交由 JavaScript 线程执行，它就会更加繁忙。</strong>前面我们也讲过，处理 1 帧动画的耗时需要控制在 16.6ms 以内，如果超过 16.6ms 就会导致动画掉帧，掉帧严重的时候，用户就会感觉到卡顿。</p><p>好，既然动画部分的 JavaScript 代码放在  JavaScript 线程中执行，存在至少1帧的延迟，并且容易导致卡顿。那我们的解决方案是什么呢？</p><p>有两种思路。</p><p><strong>第一种思路就是React Native 自带的 Animated 动画库用的思路</strong>。它是在组件初始化时，把动画的初始值、动画的形式、动画的结束值等配置都传给 UI 主线程。开发者有个开启 UI 主线程执行动画任务的开关 useNativeDriver，当开发者开启 useNativeDriver 这个开关后，动画就是在 UI 主线程执行了。</p><p>但是 Animated 动画库的缺陷也很明显，它传给 UI 主线程的是动画配置。配置只是单纯的数据，它不具备图灵完备的特性，不能配置复杂的逻辑。所以React Native 官方也指出了：Animated 不能用来改变元素宽度、高度等布局属性，不能处理除了 ScrollView 组件的 onScroll 事件外的其他手势事件。</p><p>换句话说，在保障性能的前提下，简单的动画、无交互的动画，我们可以用自带的 Animated 动画库来处理；如果是逻辑稍微复杂点的、带交互的动画，自带的 Animated 动画库就干不了了。</p><p>那 Reanimated 动画库能够处理复杂动画、有交互的动画吗？它是怎么做到的呢？</p><p>可以。Reanimated 动画库采用了另一种思路，它把动画相关的 JavaScript 函数及其上下文传给了 UI 主线程。不过，UI 主线程并没有能运行 JavaScript 函数的虚拟机，于是 Reanimated 又创建了一个 JavaScript 虚拟机来运行传过来的 JavaScript 函数。</p><p>换句话说，在使用 Reanimated 之前，React Native 只会在 JavaScript 线程创建一个 JavaScript 虚拟机，来运行 JavaScript 代码。而使用 Reanimated 之后，Reanimated 会在 UI 主线程中创建另一个 JavaScript 虚拟机来运行动画部分相关的代码。</p><p>我给你画了一张 Reanimated 的原理图，你可以看下，加深一下理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/70/76/70de3bd8fa6af059a0abe3c7a1db2376.png?wh=1920x944\" alt=\"图片\"></p><p>在这张原理图中，你会看到有两个线程：JavaScript 线程和 UI 线程。</p><p>在 JavaScript 线程中包括了三个动画相关的函数或值，<a href=\"https://github.com/software-mansion/react-native-reanimated/blob/65a31e473b4e9fa4bee83de01e807039f71b7666/src/reanimated2/hook/useSharedValue.ts#L16\">useSharedValue</a>（其底层会调用 <a href=\"https://github.com/software-mansion/react-native-reanimated/blob/65a31e473b4e9fa4bee83de01e807039f71b7666/src/reanimated2/animation/util.ts#L264-L268\">cancelAnimation</a> ）、<a href=\"https://github.com/software-mansion/react-native-reanimated/blob/65a31e473b4e9fa4bee83de01e807039f71b7666/src/reanimated2/hook/useAnimatedStyle.ts#L456-L467\">useAnimatedStyle</a> 和 <a href=\"https://github.com/software-mansion/react-native-reanimated/blob/65a31e473b4e9fa4bee83de01e807039f71b7666/src/reanimated2/hook/useAnimatedGestureHandler.ts#L54-L98\">useAnimatedGestureHandler</a>。这三部分的代码会在其底层，将相关的回调函数标记为“worklet” ，被标记的“worklet” 函数或值会被放在一个由 Reanimated 创建的 JavaScript 虚拟机中执行。</p><p>而这个由 Reanimated 创建的 JavaScript 虚拟机，会在 UI 线程中执行传过来的“worklet” 函数，并且执行的函数还可以同步地操作 UI。</p><p><strong>那 JavaScript 线程和 UI主线程是怎么配合工作的呢？</strong></p><p>我们结合宽度切换动画的代码示例，来看下原理图中的各个部分是怎么运行的：</p><pre><code class=\"language-plain\">const randomWidth = useSharedValue(10);\nconst style = useAnimatedStyle(()=&gt;({width: randomWidth.value});\n\n// 运行在 JS 线程的点击事件\nconst handlePress = () =&gt; {\n  randomWidth.value = Math.random() * 350;\n}\n</code></pre><p>在 JavaScript 代码初始化时，先执行的是 useSharedValue 函数，它会生成一个共享值对象 randomWidth。randomWidth 对象上挂了一个 value 属性。这个 value 属性既可以在 JavaScript 线程获取和修改，也可以在 UI 线程中的 JavaScript 虚拟机中获取和修改。</p><p>然后执行的是 useAnimatedStyle 函数。useAnimatedStyle 的入参也是一个函数，Reanimated 会将 useAnimatedStyle 的入参函数和与它相关的上下文都放到 UI 线程中的 JavaScript 虚拟机中。</p><p>最后就是处理点击事件了。但由于这一讲，我们还没有接触到手势 React Native Gesture Handler，所以我先用普通的事件处理函数 handlePress 来处理点击事件了。使用普通的事件处理函数有一个弊端：它是在 JavaScript 线程中触发的。所以，如果要生成的是某种对事件的响应速度有要求的动画，比如拖拽类的动画，就容易导致卡顿。</p><p>解决方案就是把处理点击事件的函数，也放到 UI 线程中，让独立的 JavaScript 虚拟机来执行。这时候，我们就需要用 useAnimatedGestureHandler 将其包装起来，示例代码如下：</p><pre><code class=\"language-plain\">// 运行 UI 线程的点击事件\nconst handleAnimatedPress = useAnimatedGestureHandler({\n    onEnd: (_) =&gt; {\n      randomWidth.value = Math.random() * 350;\n    },\n})\n</code></pre><p>不过，代码中的动画手势处理函数 handleAnimatedPress，需要结合 React Native Gesture Handler 的手势组件一起使用，具体如何结合使用，我们下一讲再讲。</p><p>在这一讲，你只需要知道，我们使用 Reanimated 生成动画的时候，只有在 JavaScript 代码初始化时，相关的动画代码会在 JavaScript 线程执行。初始化完成后，useSharedValue 生成的共享值是在 JavaScript 线程和 UI 线程的 JavaScript 虚拟机中共享的。</p><p>并且，在初始化完成后，useAnimatedStyle 的样式入参函数和 useAnimatedGestureHandler 的手势函数，以及相关的上下文都会放到 UI 线程中的 JavaScript 虚拟机中去。</p><p>简而言之，Reanimated 动画性能好的原因就在于，React Native 的 JavaScript 线程是性能瓶颈点，而 UI 线程不是，<strong>在 Reanimated 真正执行动画时，你已经把所有与动画相关 JavaScript 函数都放到了 UI 线程中独立的 JavaScript 虚拟机中了，并不会和 JavaScript 线程抢占硬件资源，因此 Reanimated 执行动画的性能会更好。</strong></p><h2>附加材料</h2><ol>\n<li>官方的几个入门视频都是 1 个小时以上的，我为你选了一个 17 分钟入门的视频<a href=\"https://www.youtube.com/watch?v=yz9E10Dq8Bg\">《Introduction to React Native Reanimated 2》</a>，可以帮你快速入门。</li>\n<li>入门之后，建议你再看看官方的文章，它会帮你更好的理解 Reanimated2 的 <a href=\"https://docs.swmansion.com/react-native-reanimated/docs/\">原理</a>。</li>\n<li>除了 <a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedStyle\">useAnimatedStyle</a> 、<a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedStyle\">useAnimatedStyle</a> 和 <a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedGestureHandler\">useAnimatedGestureHandler</a> 之外，还有一些钩子函数也可以把它的入参函数放到 UI 线程中执行，包括 <a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useDerivedValue\">useDerivedValue</a>、<a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedScrollHandler\">useAnimatedScrollHandler</a>、<a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedReaction\">useAnimatedReaction</a> 和 <a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/hooks/useAnimatedProps\">useAnimatedProps</a>，当然你也可以通过把 <a href=\"https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/worklets\">“worklet”</a>  字面量放到函数顶部，这样  Reanimated 就会把该函数放到 UI 线程中执行了。</li>\n<li>常见的动画曲线有 <a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/animations/withTiming\">withTiming</a>、<a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/animations/withSpring\">withSpring</a>、<a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/animations/withDecay\">withDecay</a> 和 <a href=\"https://docs.swmansion.com/react-native-reanimated/docs/api/animations/withDelay\">withDelay</a>，甚至你还可以使用 <a href=\"https://docs.swmansion.com/react-native-reanimated/docs/2.2.0/animations/#timing\">Easing.bezier</a> 自定义动画曲线。</li>\n<li>这节课中的 Demo，我也放到了 <a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/14_Animated\">GitHub</a> 上。</li>\n</ol><h2>总结</h2><p>对于交互类的动画，我们有两种选择，一种是 React Native 自带的 Animated 动画库，另一种是社区的 Reanimated 动画库。</p><p>为了实现流畅的动画效果，二者都把原本来 JavaScript 线程执行的动画任务，放到了 UI 线程中来执行。不同的是，官方动画库采用的是传递动画配置的形式，社区动画库采用的是传递 JavaScript 函数的形式，因此 Reanimated  动画库的应用场景更加广泛。</p><p>在今天这一讲中，我也帮你也搭起了两座知识的桥：一座桥是连接的是 Reanimated  和 State 两个知识点，这座桥的目的是帮你快速学习 Reanimated；另一座桥连接的是 Reanimated 和 React Native 架构，这座桥的目的是帮你弄清楚 Reanimated 的底层原理。</p><p>除了学习 Reanimated 本身知识外，我也希望你能掌握这种“搭桥修路”式的学习方法。你掌握的知识点越多，你搭的桥、修的路就越多，下次你碰到新的知识时，你学习的速度也就越快，进步也就越快。</p><h2>作业</h2><ol>\n<li>这节课，我们通过点击事件来设置视图的宽度。请你使用 <code>Animated.ScrollView</code> 和 <code>useAnimatedScrollHandler</code> 实现通过滚动控制视图大小的动画。</li>\n<li>能说说你在工作中的哪些场景中用到了动画吗？希望你能和我们分享一下你使用动画的心得。</li>\n</ol><p>欢迎在留言区写下你的想法。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"13｜生态：React Native Awesome","id":512920},"right":{"article_title":"15｜Gesture（上）：如何实现一个拖拽动效？","id":514589}}},{"article_id":514589,"article_title":"15｜Gesture（上）：如何实现一个拖拽动效？","article_content":"<p>你好，我是蒋宏伟。</p><p>我刚开始做 React Native 开发的时候，曾经被手势问题困扰过好几次。</p><p>第一次，我想在 Android 上实现类似 iOS 的下拉刷新效果。你可能知道，iOS 的 ScrollView 组件是有回弹属性 <a href=\"https://reactnative.cn/docs/scrollview\">bounces</a> 的。当开启回弹效果时，ScrollView 的内容区顶到头还可以继续往下拉，但 Android 的 ScrollView 组件就没有 bounces 属性，实现不了这种带回弹的下拉刷新效果。</p><p>第二次，我是想实现类似抖音评论区的手势动效。这个手势动效在上下方向存在三个手势，分别是最外层视频区域的上下切换动画、评论框的上下拖拽动画和评论内容的上下滚动动画。这种多视图、多手势的动效，本身就非常复杂，而且当时 React Native 框架自带的手势动画模块的能力太弱，也实现不了。</p><p>第三次，我想实现类似淘宝首页的手势动效。淘宝首页头部区域是由轮播图、金刚区等组成的固定内容区域，底部区域是由多 Tab 、多长列表组成的可左右切换、可上下滚动的区域，实现难度非常高。</p><p>我提到的这三个手势动效的需求，都需要手势和动画搭配在一起才能实现。</p><p>但当初我用的是 React Native 的 0.44 版本，因为社区的Gesture 手势库 <a href=\"https://docs.swmansion.com/react-native-gesture-handler/\">react-native-gesture-handler</a> 和Reanimated 动画库 <a href=\"https://docs.swmansion.com/\">react-native-reanimated</a> 都还不太成熟，所以我选择了 React  Native 框架自带的手势模块 <a href=\"https://reactnative.cn/docs/panresponder\">PanResponder</a> 和动画模块 <a href=\"https://reactnative.cn/docs/animated\">Animated</a> 进行开发。但是仅仅只是如何解决手势冲突这个问题，就把我拦住了，只能降级处理。</p><!-- [[[read_end]]] --><p>但今时不如往日，在现在的React Native 的 0.68 版本，也就是新架构预览版中，社区的 Gesture v2 手势库和 Reanimated v2 动画库都已提前适配，这几个曾经困扰我的难题都可以实现出来了。</p><p>要解决这三个问题，最重要的就是要<strong>解决手势冲突的问题</strong>。这一次，我们就围绕着这个核心，带你由浅到深，吃透手势的使用及其原理，日后你再遇到这些复杂的需求就都能迎刃而解了。</p><p>不过，由于要讲的内容比较多，我会分成三讲，也就是通过三个关卡带你逐级突破手势难题。今天的第一关就是：手势的基础原理以及如何进行基本手势，比如拖拽动效的开发。</p><h2>手势基础</h2><p>学习手势，我们当然要先了解手势的基本原理。</p><p>Pressable 点按手势就是最基础的手势。还记得我在 Pressable 一讲中，和你提到的点按手势的基本原理吗？响应 Pressable 手势要经过如下过程：</p><blockquote>\n<p>整个点按事件的响应过程是硬件和软件相互配合的过程。 Pressable 组件响应的整体流程，是从触摸屏识别物理手势开始，到系统和框架 Native 部分把物理手势转换为 JavaScript 手势事件，再到框架 JavaScript 部分确定响应手势的组件，最后到 Pressable 组件确定是点击还是长按。</p>\n</blockquote><p>这里，框架的 JavaScript 部分指的就是 React Native 自带的 PanResponder 手势系统，它是运行在 JavaScript 线程的。</p><p>而今天我要和你介绍的手势库 Gesture，虽然在声明的初始化过程是运行在 JavaScript 线程中的，但声明之后的手势回调函数的执行都是默认运行在 UI 线程的，并且它和 Reanimated 可以很好地结合起来，一起使用。因此手势动效的全过程都是可以运行在 UI 线程的，不受 JavaScript 线程性能瓶颈的约束。</p><p>Gesture 手势库实现人机交互的原理图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/3a/5a3187dea427914627cac18b10880b3a.png?wh=1920x1270\" alt=\"图片\" title=\"图标来源于 www.flaticon.com\"></p><p>你可以看到，使用 <strong>Gesture 手势库进行人机交互的基础流程</strong>一共分为 4 步：</p><ol>\n<li>Gesture 手势库收到系统手势事件；</li>\n<li>Gesture 手势库确定需要响应哪些组件；</li>\n<li>Gesture 手势库触发相关手势回调函数；</li>\n<li>通过 Gesture 回调函数返回 event 参数，使用回调返回值 event 可以更新共享值或状态，执行动画或渲染。</li>\n</ol><p>原理讲起来可能会比较抽象，下面我把原理和最基础的轻按手势结合起来，用实际案例帮你弄明白它的原理。</p><h2>轻按手势</h2><p>在 Gesture 手势库接收到系统的手势后，它需要判断页面中有没有哪个视图需要响应该手势，如果没有任何组视图需要响应该手势，那么什么都不会发生。</p><p>因此，你需要先告诉 Gesture 手势库，你有个视图需要响应手势。这一步是通过 GestureDetector 组件来实现的，代码如下：</p><pre><code class=\"language-plain\">import { GestureDetector } from 'react-native-gesture-handler';\n\n&lt;GestureDetector gesture={singleTap}&gt;\n  &lt;View /&gt;\n&lt;/GestureDetector&gt;\n</code></pre><p>在这段代码中，GestureDetector 组件的作用是将单击手势 singleTap 绑定到 View 视图上。</p><p>GestureDetector 组件是从 react-native-gesture-handler 库中导出的复合组件。<strong>GestureDetector 复合组件并不会真正渲染到屏幕上，它的作用是将配置好的手势绑定宿主组件视图上</strong>，这个宿主组件是 GestureDetector 组件内部第一个会真正渲染到屏幕上的视图。</p><p>那示例中的 singleTap 手势是什么呢？创建 singleTap 手势的代码如下：</p><pre><code class=\"language-plain\">import { Gesture } from 'react-native-gesture-handler';\n\nconst singleTap = Gesture.Tap()\n  .onStart(() =&gt; console.log('开始触发轻按事件'))\n</code></pre><p>如代码所示，<strong>Gesture 对象是 react-native-gesture-handler 手势库提供的手势对象</strong>，在 Gesture 对象下，有一个 Tap 方法，调用该方法就可以生成一个轻按手势 singleTap。</p><p>并且它还支持链式调用，你可以用 .onStart  把触发轻按回调函数绑定上去，并在该回调中打印相关日志。你对屏幕中 View 视图点击一次，就会触发 onStart 的回调函数，并打印“开始触发轻按事件”的日志。</p><p>但是，前面我们说过，Gesture 手势库是跑在 UI 线程中的，因此 console.log 实际上是在 Reanimated 创建的 JavaScript 虚拟机中执行的，日志是从 UI 线程中打印出来的。</p><p>虽然我们可以在 UI 线程中打印 console 日志，但是并不能在 UI 线程调用 setState 的渲染方法，如果调用就会报错。触发报错的示例代码如下：</p><pre><code class=\"language-plain\">const [logs, setLogs] = useState&lt;string[]&gt;([]);\n\nconst singleTap = Gesture.Tap()\n  .onStart(() =&gt; setLogs(logs.concat('开始触发轻按事件')))\n\n// 报错\nTried to synchronously call function {setLogs} from a different thread.\n</code></pre><p>这段代码中，我们先定义了日志状态 logs 及其更新函数 setLogs，然后在 onStart 的回调函数中调用了 setLogs 更新日志状态。当你点击触发 onStart 的回调函数后，就会出现一个报错，报错的内容是你尝试在另一个线程，也就是 UI 线程，同步调用 setLogs 更新函数。</p><p>这是因为，渲染过程是跑在 JavaScript 线程中的，而 UI 线程的 JavaScript 虚拟机和 JavaScript 线程的 JavaScript 虚拟机的上下文是隔离的，UI 线程拿不到渲染相关的上下文。因此，如果你在 onStart 的回调函数中调用 setState ，就会报错。</p><p>既然 setState 相关函数放到 UI 线程执行会报错，那我们就放回 JavaScript 线程执行呗？</p><p>确实可以。修改后的方案如下：</p><pre><code class=\"language-javascript\">import {runOnJS} from 'react-native-reanimated';\n\nconst [logs, setLogs] = useState&lt;string[]&gt;([]);\nconst singleTap = Gesture.Tap()\n  .onStart(() =&gt; runOnJS(setLogs)(logs.concat('开始触发轻按事件')))\n</code></pre><p>在该方案中，onStart 的回调函数依旧是在 UI 线程执行的，但是从 react-native-reanimated 动画库中引入的 runOnJS 方法，可以把 setLogs 方法放回 JavaScript 线程执行。</p><p>具体方法是这样的：runOnJS 是一个<a href=\"https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96\">柯里化的</a>函数，它接收的第一个参数是要放回 JavaScript 线程调用的函数，这里是 setLogs 函数；它接收到的第二个入参是 <code>logs.concat('开始触发轻按事件')</code> 执行后的返回值，这个返回值是一个数组，把相关函数及其入参放回 JavaScript 线程后，接着就会在 JavaScript 线程执行调用。</p><p>因此，<strong>在学习 Gesture 手势库的时候，你需要注意区分 UI 线程和 JavaScript 线程。</strong>Gesture 手势库和 Reanimated 动画库搭配使用时，Gesture 的手势回调函数是在 Reanimated 动画库创建的 UI 线程的 JavaScript 虚拟机中执行的。</p><p>但 UI 线程的 JavaScript 虚拟机和 JavaScript 线程的 JavaScript 虚拟机是两个不同的虚拟机。UI 线程的 JavaScript 虚拟机只有执行相关动画、手势回调函数的上下文，而 JavaScript 线程的 JavaScript 虚拟机拥有的是执行页面渲染的上下文，因此手势回调函数必须调用  runOnJS 回到 JavaScript 线程的 JavaScript 虚拟机中执行 setState 渲染页面。</p><p>我把使用 Gesture 手势库实现轻按手势的完整示例代码放在这里了，你可以仔细看下：</p><pre><code class=\"language-plain\">import React, {useState} from 'react';\nimport { Text, View,  SafeAreaView} from 'react-native';\nimport {runOnJS} from 'react-native-reanimated';\nimport {Gesture, GestureDetector} from 'react-native-gesture-handler';\n\nexport default function App() {\n  const [logs, setLogs] = useState&lt;string[]&gt;([]);\n\n  const singleTap = Gesture.Tap()\n    // 渲染\n    .onStart(() =&gt; runOnJS(setLogs)(logs.concat('开始触发轻按事件')));\n    // 动画或日志\n    // .onStart(() =&gt; console.log('开始触发轻按事件'));\n\n  return (\n    &lt;SafeAreaView&gt;\n      &lt;GestureDetector gesture={singleTap}&gt;\n        &lt;View style={[{width: 100,height: 100,backgroundColor: 'red'}]} /&gt;\n      &lt;/GestureDetector&gt;\n      {logs.map((log, index) =&gt; (\n          &lt;Text key={index}&gt;{log}&lt;/Text&gt;\n        ))}\n    &lt;/SafeAreaView&gt;\n  );\n}\n</code></pre><h2>拖拽动效</h2><p>刚才的轻按手势只是小试牛刀，其实这种基础的轻按手势，我们使用 Pressable 组件也可以实现。Gesture 手势库真正厉害的地方，在于能和 Reanimated 动画库配合着一起使用，它们二者一结合，就能玩出 React Native 老版本玩不出来的手势动画效果。</p><p>接着，我们再来看第二个案例，拖拽动效。通过拖拽案例，你可以学会如何将 Gesture 和 Reanimated 搭配在一起使用。</p><p>现在，你要实现的拖拽动效是这样的：你可以拖动屏幕上的一个圆形视图，让跟随你的手指一起移动。并且，在你触碰到该圆形视图时，圆形视图是蓝色的，当你手指离开该圆形视图时，圆形视图是灰色的。</p><p>拖拽动效的示意图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/12/efa8ffd8aefffd4416c4b913873f5d12.png?wh=1920x961\" alt=\"图片\" title=\"图标来源于 www.flaticon.com\"></p><p><strong>那我们应该如何实现这样的拖拽动效呢？</strong></p><p>通过Gesture 手势库进行人机交互一共分为 4 步，除了第 1 步只需 Gesture 手势库底层参与外，其他 3 步都涉及代码，那我就分 3 步来实现拖拽动效。</p><p><strong>第一步是，将拖拽手势绑定到动画组件上，示例代码如下：</strong></p><pre><code class=\"language-plain\">import Animated from 'react-native-reanimated';\nimport {Gesture, GestureDetector} from 'react-native-gesture-handler';\n\nconst dragGesture = Gesture.Pan()\n\n&lt;GestureDetector gesture={dragGesture}&gt;\n  &lt;Animated.View style={[{\n    width: 100,\n    height: 100,\n    borderRadius: 100,\n  }, animatedStyles]}/&gt;\n&lt;/GestureDetector&gt;\n</code></pre><p>因为涉及动画，所以我们需要使用动画视图，也就是 Animated.View 视图。该 View 视图的样式属性，包括一个固定的圆形样式和一个动画样式 animatedStyles。</p><p>其中，animatedStyles 的具体实现代码如下：</p><pre><code class=\"language-plain\">const isPressed = useSharedValue(false);\nconst offset = useSharedValue({ x: 0, y: 0 });\n\nconst animatedStyles = useAnimatedStyle(() =&gt; {\n  return {\n    transform: [\n      { translateX: offset.value.x },\n      { translateY: offset.value.y },\n    ],\n    backgroundColor: isPressed.value ? 'blue' : '#ccc',\n  };\n});\n</code></pre><p>这段代码中主要用到了两个共享值：一个是 isPressed，它用来判断圆形视图是否被点击了；另一个是 offset ，用来确定圆形视图的 x/y 坐标。默认情况下，圆形视图未被点击，则 isPressed 为 false，且在 x=0 y=0 的坐标点上。</p><p>而具体的动画样式 animatedStyles 是使用 isPressed 和 offset 衍生得到的，默认情况下它的 translateX=0 translateY=0，且 backgroundColor 为 #ccc 灰色。</p><p>到这里，我们就完成了第一步，也就是将拖拽手势绑定到动画组件上。</p><p><strong>接下来的第二步是，实现拖拽手势 dragGesture 和其手势回调。</strong></p><p>前面我和你介绍了轻按手势 Gesture.Tap 和相关的 onStart 回调。现在，我要用到的是拖拽手势 Gesture.Pan 及其相关的三个回调 onBegin、onChange 和 onFinalize。</p><p>你可能会问：轻按手势是 Gesture.Tap，拖拽手势 Gesture.Pan ，但 onStart、 onBegin、onChange 和 onFinalize 这 4 个手势回调之间有什么关系啊？为什么实现拖拽动效需要的是 onBegin、onChange 和 onFinalize 这三个手势回调呢？除了这 4 个手势回调，还有什么其他手势回调吗？</p><p>这些问题很有价值，轻按手势和拖拽手势虽然有所不同，但是对应的手势回调大体上都是相同的，因此我用拖拽手势回调进行讲解，其中细节差异你可以查一下<a href=\"https://docs.swmansion.com/react-native-gesture-handler/docs/api/gestures/pan-gesture\">相关文档</a>。</p><p>拖拽手势相关的回调一共 10 个，示例代码如下：</p><pre><code class=\"language-plain\">const dragGesture = Gesture.Pan()\n    .onBegin(() =&gt; console.log('onBegin'))\n    .onTouchesDown(() =&gt; console.log('onTouchesDown'))\n    .onTouchesMove(() =&gt; console.log('onTouchesMove'))\n    .onStart(() =&gt; console.log('onStart'))\n    .onUpdate(() =&gt; console.log('onUpdate'))\n    .onChange(() =&gt; console.log('onChange'))\n    .onTouchesUp(() =&gt; console.log('onTouchesUp'))\n    .onEnd(() =&gt; console.log('onEnd'))\n    .onTouchesCancelled(() =&gt; console.log('onTouchesCancelled'))\n    .onFinalize(() =&gt; console.log('onFinalize'))\n</code></pre><p>这些手势回调是按顺序从上到下依次触发的：</p><ul>\n<li>onBegin：开始识别到手势，但此时拖拽并未发生。也就是说，这时你的手指是触碰到 View 视图，不过手指并未移动；</li>\n<li>onTouchesDown：手指按下触摸到视图时会触发。你可以理解为在手指触摸到视图时，先触发了 onBegin ，紧接着就触发了 onTouchesDown；</li>\n<li>onTouchesMove：手指移动后会触发；</li>\n<li>onStart：当手指移动距离超过 Float.MIN_VALUE 的阈值时，也就是精度为 0.000000 的距离时，就会触发该回调，此时<strong>拖拽事件正式触发</strong>；</li>\n<li>onUpdate：在手指移动的过程中 x/y 坐标系等参数会更新，参数更新后 onUpdate 回调就会触发；</li>\n<li>onChange：在手指移动的过程中 x/y 坐标系等参数会更新，参数更新后 onChange 回调会紧接着 onUpdate 触发。onChange 和 onUpdate 的区别是，onChange 的参数是以上一次回调的参数作为基准进行更新的，而 onUpdate 是以手势触发 onStart 时的参数为基准进行更新的；</li>\n<li>onTouchesUp：当手指离开屏幕时，触发 onTouchesUp 回调；</li>\n<li>onEnd：当手指离开屏幕时，会先触发 onTouchesUp 回调，然后紧接着触发 onEnd 回调。需要注意的是， onEnd 回调是和 onStart 配套出现的，如果没有触发 onStart 回调，那也不会触发 onEnd 回调；</li>\n<li>onTouchesCancelled：一般是在系统弹窗中断手势的情况下触发，较为少见；</li>\n<li>onFinalize：只要手势结束，最终都会触发 onFinalize 回调。</li>\n</ul><p>这 10 个手势回调，可能稍微有点难记，我建议你自己亲自动手试试，我也给你画了一张示意图，帮你加深理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/57/7f/57be0b86600a6827f5a9ab66760e607f.png?wh=1920x933\" alt=\"图片\" title=\"图标来源于 www.flaticon.com\"></p><p>回到我们要实现的拖拽动效，它的一个功能是手指触碰到视图，视图变蓝，手指离开视图，视图变灰，另一个功能是手指移动时视图跟随着手指一起移动。</p><p>手指触碰和离开视图时是不会触发 onStart 和 onEnd 回调的，只会触发 onBegin 和 onFinalize 回调，因此我选择了 onBegin 和 onFinalize 来处理手指触碰和手指离开这两个事件。</p><p>我们再来看视图跟随手指移动的功能。onUpdate 返回的是以 onStart 触发位置为基准的参数，而 onChange 返回的参数不仅包括 onUpdate 参数，还多了以上一次 onChange 触发位置为基准的偏移量 <code>changeX</code> 和 <code>changeY</code>，我需要根据上一次手势的偏移量 <code>changeX</code> 和 <code>changeY</code>来计算视图新的偏移量，因此我选择使用 onChange 而不是 onUpdate 。</p><p><strong>实现拖拽动效的最后一步是，更新动画的共享值。</strong></p><p>因为，Animated.View 视图的衍生样式值已经设置好了，只要动画的共享值一更新，衍生样式值就会更新，Animated.View 就会跟着手指动起来。</p><p>更新动画共享值的代码如下：</p><pre><code class=\"language-plain\">  const dragGesture = Gesture.Pan()\n    .onBegin(() =&gt; {\n      isPressed.value = true;\n    })\n    .onChange((e) =&gt; {\n      offset.value = {\n        x: e.changeX + offset.value.x,\n        y: e.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() =&gt; {\n      isPressed.value = false;\n    });\n</code></pre><p>这段代码比较简单，在 onBegin 回调中将 isPressed.value 标记为 true，在 onFinalize 回调中将 isPressed.value 标记为 false，这就实现了手指触碰视图置蓝，离开视图置灰的效果。<br>\n然后在 onChange 回调中，获取上一次 Animated.View 视图的偏移位置 offset.value.x 和 offset.value.y，并将其分别和相对上一次位置的偏移量 e.changeX 和 e.changeY 进行相加，就能计算出当前 Animated.View 的偏移位置 offset.value。当 offset.value 共享值更新时，Animated.View 的衍生样式值  <code>translateX</code> 和 <code>translateY</code>也会随之更新，该视图在屏幕上的位置也会发生相应地移动。</p><p>到这里，我们就把拖拽动效实现了。这里我们再整合下实现拖拽动效的主要代码，你可以仔细看看以加深印象：</p><pre><code class=\"language-plain\">function Ball() {\n  const isPressed = useSharedValue(false);\n  const offset = useSharedValue({ x: 0, y: 0 });\n\n  const animatedStyles = useAnimatedStyle(() =&gt; {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n      backgroundColor: isPressed.value ? 'blue' : '#ccc',\n    };\n  });\n\n  const dragGesture = Gesture.Pan()\n    .onBegin(() =&gt; {\n      isPressed.value = true;\n    })\n    .onChange((e) =&gt; {\n      offset.value = {\n        x: e.changeX + offset.value.x,\n        y: e.changeY + offset.value.y,\n      };\n    })\n    .onFinalize(() =&gt; {\n      isPressed.value = false;\n    });\n\n  return (\n    &lt;GestureDetector gesture={dragGesture}&gt;\n      &lt;Animated.View style={[styles.ball, animatedStyles]} /&gt;\n    &lt;/GestureDetector&gt;\n  );\n}\n\nexport default function Example() {\n  return (\n    &lt;View style={styles.container}&gt;\n      &lt;Ball /&gt;\n    &lt;/View&gt;\n  );\n}\n</code></pre><h2>总结</h2><p>今天这一讲，我们将 Gesture 手势库和 Reanimated 动画库搭配一起使用，实现一个最基础的拖拽动效。</p><p>实现一个拖拽动效主要分为三步：</p><ul>\n<li>第一步，创建 Gesture.Pan 手势并将拖拽手势绑定到动画组件上；</li>\n<li>第二步，在 Gesture.Pan 拖拽手势的 10 个手势回调中，选择 onBegin 和 onFinalize 手势回调响应拖拽开始和拖拽完成，选择 onChange 响应拖拽移动；</li>\n<li>第三步，在相应的拖拽回调中同步更新动画组件的共享值，也就是  x、y 轴坐标，实现基础的拖拽动效。</li>\n</ul><p>手势相关的问题是我们很容易遇到的，而且学习曲线很陡峭，所以我把手势分为了上中下三篇。今天的内容还是相对基础的，在了解了手势基础的原理和使用后，下一讲我们将在此基础上，继续讲解手势进阶的内容，特别是如何解决手势冲突的问题。</p><h2>作业</h2><ol>\n<li>请你实现一个类似微信消息的左滑删除的功能；</li>\n<li>请你聊一下，你遇到过哪些需要手势和动画配合才能实现的功能，你是原来都是怎么实现的？</li>\n</ol><p>欢迎在评论区和我探讨。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"14｜Reanimated：如何让动画变得更流畅？","id":513844},"right":{"article_title":"16｜Gesture（中）：如何解决单视图多手势的冲突问题？","id":514905}}},{"article_id":514905,"article_title":"16｜Gesture（中）：如何解决单视图多手势的冲突问题？","article_content":"<p>你好，我是蒋宏伟。</p><p>通过上节课对轻按手势和拖拽动效这两个基础手势案例的学习，相信你现在已经能够完成一些基本手势需求的开发了。今天这节课，我们就再进一步，聊下怎么解决更进阶的手势问题。</p><p>在手势基础的学习中，我们给到的手势案例都是围绕着一个视图、一个手势展开的，处理起来很简单。但在真实的工作中，情况会更加复杂。比如说，我们会有稍微难一点的情况，也就是一个视图同时存在多个手势。还有更复杂的，就是同时有多个视图、多个手势，并且这些视图和手势环环相扣。</p><p>当然你也不用担心，这两种复杂的情况，我们的 Gesture 手势库都提供了相关的解决方案。不过俗语也有说，“一口吃不成大胖子。”所以今天这一讲，我们先来聊聊一个视图多个手势如何处理，下一讲再聊聊多个视图、多个手势如何处理。</p><p>但在展开讲解手势冲突问题之前，我需要带你补全 Gesture 手势的一些进阶知识。</p><h2>手势进阶</h2><p>我们要研究多个手势冲突的问题，大体上得遵循这样的流程：</p><ul>\n<li>首先你得知道 Gesture 手势库都能识别哪些手势；</li>\n<li>然后手势实际是一系列连续的动作，而这一系列动作大致可以分为几个阶段，比如开始、进行中、完成和中途取消，Gesture 手势库又提供了哪些手势回调来识别手势的不同阶段；</li>\n<li>最后，不同阶段的回调又都能提供什么参数，能让开发者来使用。</li>\n</ul><!-- [[[read_end]]] --><p>我们来看第一个问题， Gesture 手势库都能识别哪些手势呢？</p><p>Gesture 手势库一共支持“1 + 8”个手势，我画了一张示意图，你可以先看一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/96/43/9660a5bde58537ca92db522298d9e843.png?wh=1920x1271\" alt=\"图片\" title=\"图标来源于 www.flaticon.com\"></p><p>“1 + 8” 中的 “1”指的是 1 种原始手势，“8”指的是 8 种封装手势，它们都是：</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/a4/9eef81df746022aed26c1256yye7cfa4.png?wh=1776x1582\" alt=\"图片\"></p><p>接着你需要知道的是，<strong>Gesture 手势库的各个手势都支持哪些手势回调？</strong></p><p>刚才我和你介绍的 7 种新手势，虽然和之前学的 Tap、 Pan 手势的触发条件不同，但整体上它们的手势回调还是 Pan 手势的那 10 种。这 10 种手势回调，也可以进一步分为三类。</p><p><strong>第一类是通用回调</strong>，包括：</p><ul>\n<li>onBegin；</li>\n<li>onTouchesDown；</li>\n<li>onTouchesMove；</li>\n<li>onTouchesUp；</li>\n<li>onFinalize。</li>\n</ul><p>无论哪种手势都会有以上回调，只要用户和相关视图发生了交互行为，即便该手势并未真正触发，但也会触发相关的通用回调。这是什么意思呢？</p><p>举个例子，比如拖拽手势 Pan，你点击相关视图的交互，只是手指按下、手指抬起，中间过程中手指不移动，这时拖拽手势不算触发吧？你得真正移动了手指拖拽手势才算触发，对不对？</p><p>这时拖拽手势并未真正触发，但却会触发 onBegin、onTouchesDown、onTouchesUp、onFinalize 这些通用回调事件。</p><p>又比如，用户两个手指触碰到了屏幕，但此时用户手指并未旋转，而且接着又离开了屏幕，因此不会触发旋转手势。但会依次触发 onBegin、onTouchesDown、onTouchesUp 回调和 onFinalize 回调。这就是“手势并未真正触发，但也会触发通用回调”的意思。</p><p>第二类是激活（ACTIVE）回调，包括：</p><ul>\n<li>onStart；</li>\n<li>onUpdate；</li>\n<li>onChange；</li>\n<li>onEnd。</li>\n</ul><p>激活（ACTIVE）是手势内部的一种状态，它代表某个手势真正被触发了。</p><p>我们还是以 Rotation 手势为例分析一下。只有当用户两个手指触碰到屏幕且发生了旋转时，Rotation 手势内部状态才会变为 ACTIVE，此时才会触发 onStart、onUpdate、onChange。当 ACTIVE 被触发后，用户手指离开时，Rotation 手势的内部状态会由 ACTIVE 变为 END，此时才会触发 onEnd 回调。</p><p>注意，只有先变为 ACTIVE 状态，再由 ACTIVE 状态变为 END 状态的这一种情况，会触发 onEnd 回调。</p><p>第三类是系统取消回调，它是一个特例，只有一种，就是onTouchesCancelled。</p><p>当触发 onTouchesCancelled 回调时，通常是操作系统把手势打断了。比如，你在旋转图片时，突然来了个电话，此时 Rotation 手势被打断，内部状态会从 ACTIVE 变为 CANCELLED，这时就不会触发 onEnd 回调了，而是触发 onTouchesCancelled 回调。</p><p>因此，即便手势触发成功，但当手势结束时不一定会调用 onEnd 回调，因为还有 onTouchesCancelled  回调这种情况，所以如果你想保证无论发生什么情况都有结束回调，你应该使用 onFinalize 回调代替 onEnd 回调。</p><p>关于手势进阶，你需要知道的第三个知识点是，<strong>Gesture 手势库的手势回调都返回哪些参数？</strong></p><p>在学习 Pan 手势时，通过 onChange 回调返回的 changeX/changeY 只是手势回调返回参数的一种。实际上，不同的手势、不同的回调返回的值都有所区别，这类知识点非常零散。为了让你更好地记忆，我把它分为两类，分别是常用类回调参数和场景类回调参数。</p><p><strong>常用类回调参数：</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/13/e5/13e32ae01675d43f31b58856607ea9e5.png?wh=1920x1231\" alt=\"图片\"></p><p>x/y、absoluteX/Y 和 changedX/Y 这三个坐标位置比较容易搞混，我给你画了一张示意图，你看一眼就会明白：</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/1b/6dfef53c9cc7d519d4b61d322889731b.png?wh=1920x1204\" alt=\"图片\" title=\"图标来源于 www.flaticon.com\"></p><p><strong>场景类回调参数：</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/cd/f0/cd9a807b7b205ef2b75b96a043a16ef0.png?wh=1920x1116\" alt=\"图片\"></p><p>这些场景类的回调参数，可能归纳得不全，但经常用的，我都帮你归类出来了。这 9 种手势事件、10 种回调函数、两类回调参数，都是基于 Gesture 手势 v2 版本来讲的，v1 版本太旧了，我这里就不展开了。学习到这里，你应该对手势库有了一个大概的了解。</p><p>有了这些基础，你再来理解我们接下来要解决的手势冲突的问题，就会变得更简单了。</p><h2>常规手势冲突解决方案：捕获冒泡机制</h2><p>上一讲的开头，我和你列举了三个案例：Android 下拉刷新、类抖音的评论区拖拽效果、类淘宝首页的带头部的多 Tab 长列表效果。其实这些案例要解决本质问题都是<strong>手势冲突</strong>。要实现这些效果，我们要解决的是如何在多个视图之间处理多个手势，特别是 ScrollView 的滚动手势。</p><p>冒泡机制是一种常规的手势识别和分配机制，我们先来看看它是怎么处理手势冲突问题的。无论是在 Android、iOS 还是 Web 中，都有事件冒泡机制，事件冒泡机制是站在“事件视角”给不同视图分配不同的手势事件。</p><p>我画了一张<strong>事件冒泡机制解决手势冲突</strong>示意图，你可以看一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/ce/b5/ce25148b574fec8e0830b203829090b5.png?wh=1920x1204\" alt=\"图片\"></p><p>在“事件视角”的图中，如果用户点了屏幕上的某个点，站在底层框架视角看，用户屏幕中的视图，实际是由一棵视图树组成的，用户想点的既有可能是叶子视图 B，也有可能是叶子视图的父视图 A，还可以一层层继续往上找的父视图，直到找到根视图 Root。</p><p>那用户点的这一下，究竟想点的是哪个视图呢？底层框架本身并不知道。</p><p>底层框架不知道，它就需要一个个地问，“我这个框架收到了用户的一个点击手势，你这个视图是否需要处理它？”</p><p>那么，框架提问的顺序又是怎么样的呢？</p><p>框架它会先根视图 Root 往下一直问到叶子视图  B，然后再从叶子视图 B 往上一直问到根视图 Root。从上往下问叫做捕获，从下往上再问一次叫做冒泡。</p><p>但为什么要先从上往下问一次，又从下往上再问一次呢？</p><p>根本原因是，框架不知道哪个视图处理事件优先级更高。比如框架它先问了叶子视图 B ，如果这时它就直接把事件分发给叶子视图B处理了，等它问到根视图 Root 时，结果 Root 根视图告诉框架，这个事件应该由它Root 根视图处理。</p><p>但这时候，手势事件已经被叶子视图 B 处理完了，Root 根视图就处理不了了，这就出现了优先级问题。</p><p>因此，框架和视图之间就约定，正常情况下，所有的视图都是在冒泡的流程中确定是否响应事件，如果有哪个视图想要拦截其他视图的事件，就可以在捕获流程中提前拦截。</p><p>React Native 框架自带的手势事件用的就是捕获冒泡机制。但是这套机制有两个弊端，一是理解起来费劲，需要开发者理解视图树和捕获冒泡的传导机制；二是它没办法处理一个事件要在两个组件上同时响应的情况。</p><p>所以，Gesture 手势库提供了另外两种解决手势冲突的视角：一个是从单个视图的视角出发，来解决单视图、多手势之间的冲突问题，另一个是从单个手势的视角来解决多视图、多手势之间的冲突问题。这一讲中，我们从单个视图视角出发，看看如何解决单视图、多个手势之间的冲突。</p><h2>单视图多手势冲突问题</h2><p>首先，我们来分析下如何<strong>从单个视图视角出发解决多个手势之间的冲突。</strong></p><p>Gesture 手势库，提供了 3 种解决单视图多手势冲突问题的 API，你先看下这张示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/77/0e/77098e1cdc2d8807b8296d2e86dc3f0e.png?wh=1486x477\" alt=\"图片\"></p><p>示意图中的第一个例子是，<strong>通过 Gesture.Race 函数让同一个组件中的多个手势之间进行竞争。</strong>谁先触发就响应谁，通过竞争的方式解决了手势冲突的问题，示例代码如下：</p><pre><code class=\"language-plain\">function RaceDemo() {\n  const pan = Gesture.Pan()\n  const longPress = Gesture.LongPress()\n\n  return (\n    &lt;GestureDetector gesture={Gesture.Race(pan, longPress)}&gt;\n      &lt;View/&gt;\n    &lt;/GestureDetector&gt;\n  );\n}\n</code></pre><p>在上述代码中，我使用了手势竞争函数  Gesture.Race，Gesture.Race 函数接收了两个手势：Pan 拖拽手势和 LongPress 长按手势。</p><p>此时，如果你手指按下的时间超过 500ms，就会触发长按事件。一旦触发了长按事件，即便你再移动手指也不会再触发拖拽事件了。反之，如果你按下的时间小于 500ms，这时你移动了手指，就会触发拖拽事件，即便后续你按下的时间超过了 500ms，也不会再触发长按事件了。</p><p>其中，起关键作用的就是 Gesture.Race 函数。Gesture.Race 函数可以接收若干个手势事件，这些手势事件只要触发了一个，其他的手势事件都不会再触发。</p><p>示意图中的第二个例子是，<strong>通过 Gesture.Simultaneous 函数让同一个组件中的多个手势同时响应。</strong>多个手势可以同时响应，就没有手势冲突的问题了，示例代码如下：</p><pre><code class=\"language-plain\">function SimultaneousDemo() {\n  const pinch = Gesture.Pinch()\n  const rotation = Gesture.Rotation()\n\n  return (\n    &lt;GestureDetector gesture={Gesture.Simultaneous(pinch, rotation)}&gt;\n      &lt;View/&gt;\n    &lt;/GestureDetector&gt;\n  );\n}\n</code></pre><p>在上述代码中，我使用了手势同时响应函数  Gesture.Simultaneous。Gesture.Simultaneous 函数接收了两个手势： Pinch 缩放手势和 Rotation 旋转手势。<br>\n此时，你既可以使用两个手指旋转视图，也可以使用两个手指对视图进行缩放。其中，起作用的就是 Gesture.Simultaneous 函数。Gesture.Simultaneous 函数可以接收若干个手势事件，并且这些手势事件会同时触发。</p><p>示意图中的第三个例子是，<strong>通过 Gesture.Exclusive 函数让组件决定多个手势的响应优先级。</strong>它解决的是响应优先级的问题，示例代码如下：</p><pre><code class=\"language-plain\">function ExclusiveDemo() {\n  const singleTap = Gesture.Tap()\n  const doubleTap = Gesture.Tap().numberOfTaps(2)\n\n  return (\n    &lt;GestureDetector gesture={Gesture.Exclusive(doubleTap, singleTap)}&gt;\n      &lt;View/&gt;\n    &lt;/GestureDetector&gt;\n  );\n}\n</code></pre><p>在上述代码中，我使用了 Gesture.Tap() 创建了单击手势，使用 Gesture.Tap().numberOfTaps(2) 创建了双击手势，并且使用了 Gesture.Exclusive(doubleTap, singleTap) 把双击手势的优先级设置在了单击手势之前。<br>\n这样做的原因是：如果这两个手势使用的是 Race 竞争机制，那么单击手势永远会先响应，而双击手势永远不会响应；如果它们使用的是 Simultaneous 共存机制，那么短时间内有第二次点击，会同时触发单击手势和双击手势，不符合预期。</p><p>这里的解决方案就是，我们可以使用 Gesture.Exclusive 设置优先级。如果 500ms 内只有一次点击，那么会在 501ms 触发单击事件；如果 500ms 内有两次点击，那么会在第二次点击完成时触发双击事件。</p><p>其中， Gesture.Exclusive 函数的作用就是给它接收到的若干个手势事件排个优先级：第一个参数的手势事件大于第二个手势事件，第二个参数的手势事件大于第三个手势事件，以此类推。</p><p>还记得我在 Pressable 一讲中给你留了个作业吗？那个作业问的也是单击手势和双击手势之间的优先级的问题，那一讲的作业是：</p><blockquote>\n<p>在较老版本的手机浏览器中，点击事件存在 350ms 延迟；在微信聊天框中，点击对方的微信头像比点击右上角三个点的更多按钮，打开页面的速度慢一些；双击事件是常见的点按事件之一，Pressable 组件却没有提供；这三个现象涉及 Web、Android、iOS 和 React Native 这四个技术领域，但这三个现象其实都指向同一个答案。</p>\n</blockquote><p>这个答案就是，在较老版本的手机浏览器中，浏览器本身提供了双击放大页面的手势，而点击页面按钮是单击手势，因此页面按钮的单击需要等 350ms 才能响应；微信头像既有单击手势，也有双击手势，因此单击微信头像跳转页面的速度会变慢。</p><p>而 Pressable 组件不提供双击手势的原因，是因为当某个组件要同时处理双击手势和单击手势时，组件要优先响应双击事件再延长响应单击事件，这会导致单击手势的响应会变慢。既然会导致变慢，那么 Pressable 组件为了保证单击事件的优先响应，干脆就不提供了双击事件了。</p><p>概括而言，<strong>在单个视图中响应不同手势时会有冲突，Gesture 组件库提供了 3 种处理冲突的方式，分别是竞争 Gesture.Race、同时 Gesture.Simultaneous、排他 Gesture.Exclusive。</strong>在遇到单视图、多手势冲突问题时，你需要根据不同情况选择不同的处理方案。</p><h2>总结</h2><p>这一讲，我们介绍了如何解决单视图多手势的冲突问题，为此我们介绍了 Gesture 手势库的 9 个手势、3 类回调事件和 3 种手势冲突的解决方案。</p><p>9 个手势分别是：1 个最底层原始手势 Manual，以及 8 个封装好的上层手势。这8个手势包括轻按手势 Tap、长按手势 LongPress、拖拽手势 Pan、旋转手势 Rotation、缩放手势 Pinch、快滑手势 Fling、重按手势 ForceTouch、原生手势 Native。</p><p>3 类回调分别是：第一类上述 9 类手势都有的通用回调，包括 onBegin、onTouchesDown、onTouchesMove、onTouchesUp 和 onFinalize；第二类是满足各自触发条件时会触发的激活回调，包括 onStart、onUpdate、onChange 和 onEnd；第三类是系统取消回调 onTouchesCancelled。</p><p>3 种单视图多手势冲突的解决方案是：竞争 Gesture.Race、同时 Gesture.Simultaneous、排他 Gesture.Exclusive。</p><p>这一讲的知识点比较多，但它们都是处理复杂手势的基础，下一讲我会给你介绍更高阶的多视图多手势冲突问题的解决方案。</p><h2>作业</h2><p>1、请你实现一个同时支持单击、长按、拖拽、缩放和旋转的图片组件。</p><p>有啥问题欢迎在评论区留言。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"15｜Gesture（上）：如何实现一个拖拽动效？","id":514589},"right":{"article_title":"17｜Gesture（下）：如何解决多视图多手势的冲突问题？","id":515347}}},{"article_id":515347,"article_title":"17｜Gesture（下）：如何解决多视图多手势的冲突问题？","article_content":"<p>你好，我是蒋宏伟。</p><p>前一节课，我们讲解了手势进阶的一些内容，也分析了如何解决单视图多手势冲突的问题，但这个 Demo 其实挺基础的。今天我们要再深入一点，看一个稍微复杂点的案例，就是 Android 的回弹下拉刷新。</p><p>在Gesture的第一篇中我提到过，实现 Android 回弹下拉刷新的难点在于Android 的 ScrollView 组件就没有滚动回弹属性 bounces。而 iOS 的 ScrollView 组件是有滚动回弹属性 bounces 的，而且是默认开启的。</p><p>在 Android 回弹下拉刷新案例中，会用到 Gesture 上中下三篇中的所有知识点，包括如何将手势库 Gesture 和动画库 Reanimated 搭配一起使用，如何解决单视图多手势的冲突问题，如何解决多视图多手势的冲突问题。</p><p>今天这一讲，一方面我会重点和你介绍如何解决多视图多手势的冲突问题，另一方面我会把 Gesture 上中下三篇的内容给你串起来，帮你实现 Android 回弹下拉刷新的效果。</p><h2>Android 回弹下拉刷新</h2><p>在真实的业务开发中，实现双端下拉刷新的正确逻辑是：<strong>iOS 基于 bounces 实现，Android 基于手势实现</strong>。不过，为了方便，我在写 Demo 的时候，直接把 iOS 的 bounces 效果关了，双端统一使用手势实现，省去了 if else 的代码，这样你看代码会容易一些。</p><!-- [[[read_end]]] --><p>那我们又应该从哪里开始进行实现回弹下拉刷新？</p><p>要实现回弹下拉刷新，首先要理解 Android 回弹滚动的原理，我们先来看一下<strong>Android 回弹滚动的结构示意图</strong>：</p><p><img src=\"https://static001.geekbang.org/resource/image/0f/61/0f11873068f746e96f08ac16478e4b61.png?wh=1920x982\" alt=\"图片\"></p><p>你可以看到，Android 回弹滚动涉及的结构一共有 5 种，最外层是手机屏幕，手机屏幕内有一个比屏幕高一些的 Animated.View。Animated.View 比屏幕高出来的部分，正好等于 Loading 视图的高度，Loading 视图这里我直接用 Text 元素代替了。Animated.View 和屏幕同高的部分是 ScrollView 视图。在 ScrollView 视图的内部，ScrollView 的内容 Content 部分是比 ScrollView 容器更高的，这样内容才能滚动。</p><p>如果我们从 ScrollView 内容的最底部开始，一直往上滚，滚到内容的最顶部。在没有 bounces 回弹效果的容器中，内容的顶部和手机屏幕的顶部是平齐的。如果支持 bounces 回弹或手势回弹，那么内容还可以继续往下拉，内容的顶部可以低于手机屏幕顶部。</p><p>这里有个小细节。你可能注意到了，我并没有使用 absolute 绝对定位将 Text 定位到手机屏幕上方的位置，而是增加了其父容器 Animated.View 的高度。这是因为，我以前遇到过 Android 手机子视图超出父容器后不显示的问题。为了避免超出不显示，在Animated.View  的子视图这里，我采用的是从上到下的默认布局方式，把子视图都包裹在 Animated.View 视图内部，而不是让子视图 Loading 浮在 Animated.View 视图的外面。</p><p>那上述回弹下拉刷新的 JSX 实现是什么样的呢？</p><p>JSX 部分的核心代码如下：</p><pre><code class=\"language-plain\">const LOADING_HEIGHT = 30\nconst {height: windowHeight} = useWindowDimensions()\nconst wrapperHeight = windowHeight + LOADING_HEIGHT\n// ...\nreturn (\n  &lt;Animated.View style={[{ height: wrapperHeight }, animatedStyle]}&gt;\n    &lt;Text style={{height: LOADING_HEIGHT}}&gt;loading...&lt;/Text&gt;\n    &lt;GestureDetector gesture={Gesture.Simultaneous(scrollGesture, panGesture)}&gt;\n      &lt;Animated.ScrollView bounces={false} onScroll={scrollHandler}/&gt;\n    &lt;/GestureDetector&gt;\n  &lt;/Animated.View&gt;\n)\n</code></pre><p>在上述结构代码中，我给 ScrollView 添加了两个可以同时执行的手势：一个是 ScrollView 自身的滚动手势 scrollGesture；另一个是拖拽手势 panGesture。同时我还给 Animated.View 添加了一个动画样式 animatedStyle。</p><p>这样做的目的是，我们可以通过滚动手势、拖拽手势和动画的配合，实现 Android 回弹下拉效果。</p><p>了解完 JSX 结构后，我们再来看驱动拖拽动画的共享值。<strong>回弹下拉一共涉及了两个共享值，也就是 scrollY 和 refreshY。</strong></p><ul>\n<li>scrollY：ScrollView 滚动偏移量，相关代码如下：</li>\n</ul><pre><code class=\"language-plain\">const scrollY = useSharedValue(0);\n\nconst scrollHandler = useAnimatedScrollHandler({\n  onScroll: e =&gt; {\n    // 记录偏移量，只读不写\n    scrollY.value = e.contentOffset.y;\n  },\n});\n\n// ...\n&lt;Animated.ScrollView  onScroll={scrollHandler} scrollEventThrottle={1}/&gt;\n</code></pre><p>由于 ScrollView 的滚动偏移量是由原生平台控制的，Animated 动画库和 Gesture 手势库都控制不了，<strong>因此 scrollY 只可读、不可写</strong>。读取 scrollY 靠的是 ScrollView 的 onScroll 回调和 Reanimated 的 useAnimatedScrollHandler 的配合，整个过程在 UI 线程中进行。另外，我们也通过 scrollEventThrottle 属性，将两次 onScroll 回调的执行间隔设置为 1ms，以此来保证获取 scrollY 的时效性。</p><ul>\n<li>refreshY：Animated.View 拖拽偏移量，示例代码如下：</li>\n</ul><pre><code class=\"language-plain\">const LOADING_HEIGHT = 30\nconst refreshY = useSharedValue(-LOADING_HEIGHT);\nconst {height: windowHeight} = useWindowDimensions()\nconst wrapperHeight = windowHeight + LOADING_HEIGHT\n\nconst animatedStyle = useAnimatedStyle(() =&gt; {\n  return {\n    transform: [{translateY: refreshY.value}],\n  };\n});\n\nreturn (\n  &lt;Animated.View style={[{height: wrapperHeight}, animatedStyle]}&gt;\n    {/* ... */}\n  &lt;/Animated.View&gt;\n);\n</code></pre><p>拖拽偏移量是用来控制整体视图 Animated.View 的纵轴偏移量的，包括 ScrollView 和 Loading。默认 refreshY 的值为 -30，也就是 LOADING_HEIGHT 的负值，此时正好把 Loading  隐藏在屏幕外。</p><p>和 scrollY 只读不写不同，<strong>refreshY 的值会跟着拖拽手势的变化而变化</strong>。当你拖拽下拉时， refreshY 的值从 -30 逐渐变大；当 refreshY 的值变为 0 时， Loading 字样会完全出现；继续向下拖拽， refreshY  会继续变大，页面继续下移，松手时，重新变为 -30。</p><p><strong>了解了整体的 JSX 结构和共享值后，接下来我们面临的难题就是，回弹滚动究竟如何实现呢？</strong></p><p>一图胜千言，我还画一张原理示意图，相信你看一下就能明白：</p><p><img src=\"https://static001.geekbang.org/resource/image/82/44/82c626b4681a0623156dba963bbb6a44.png?wh=1920x2269\" alt=\"图片\"></p><p>示意图一共分为 6 步，有两种可能结果。</p><p>首先，在初始化时，你先将 ScrollView 内容滚动到最底部，然后手势向下往内容的最顶部方向滚动。此时，因为你的手是一直放在 ScrollView 视图上的，所以 ScrollView  视图会同时响应滚动手势和拖拽手势。但是滚动手势也就意味着触发了滚动动画，而拖拽手势只是触发了拖拽回调 onChange，但回调中并未改变共享值 refreshY，也未执行拖拽动画。</p><p>绑定手势的相关代码如下：</p><pre><code class=\"language-plain\">const scrollGesture = Gesture.Native()\nconst panGesture = Gesture.Pan()\n  .onChange(e =&gt; { \n    // 拖拽动画\n    if (scrollY.value === 0 || refreshY.value !== -LOADING_HEIGHT) {\n      refreshY.value =  Math.max(-LOADING_HEIGHT,refreshY.value + e.changeY) ;\n    }\n  })\n  .onEnd(() =&gt; {})\n\nconst animatedStyle = useAnimatedStyle(() =&gt; {\n  return {\n    transform: [{translateY: refreshY.value}],\n  };\n});\n\nreturn (\n  &lt;GestureDetector gesture={Gesture.Simultaneous(scrollGesture, panGesture)}&gt;\n    &lt;Animated.ScrollView /&gt;            \n  &lt;/GestureDetector&gt;\n）\n</code></pre><p>接着，你继续不松手地向下滚动 ScrollView 的内容，直到内容滚动到了最顶部。此时 scrollY 的值正好为 0，refreshY 的值也正好为 -LOADING_HEIGHT，此时拖拽动画处于还未触发但即将触发的临界点。</p><p>然后你再继续不松手地向下滚动和拖拽。这时你要注意一下 ScrollView 的滚动条，你会发现滚动条是一直显示的，但没有位置和长度的变化了，这代表 ScrollView 内容触顶了，并且不能回弹滚动了。而这时拖拽手势改变了共享值 refreshY， 并开始执行拖拽动画。拖拽动画让外层容器 Animated.View 改变了它的 translateY 偏移量，所以 Animated.View 和其内部的 Loading 文字会一起往下移，于是你就在手机屏幕上看到了 Loading 文字。</p><p>接下来你会有两种选择，A 选择是松手刷新页面，B 选择是往反方向滚动取消刷新。</p><p>我们先来看选择了A会怎么样。如果你选择了松手刷新页面，那么拖拽手势和滚动手势会同时结束，此时只需要在手势结束回调中将 Animated.View 的 translateY 偏移量设置为默认值即可。这样所有视图都会恢复默认的位置，而 Loading 文字也会消失在屏幕中。</p><p>松手触发拖拽手势 onEnd 回调的代码如下：</p><pre><code class=\"language-plain\">  const panGesture = Gesture.Pan()\n    // ...\n    .onEnd(() =&gt; {\n      // 松手时，如果容器整体偏离正常位置\n      if (refreshY.value !== -LOADING_HEIGHT) {\n        // 则使用弹性动画 withSpring，回弹至原位置\n        refreshY.value = withSpring(-LOADING_HEIGHT, {\n          stiffness:300,\n          overshootClamping: true\n        })\n      }\n    })\n</code></pre><p>你可以看到，在你松手时，panGesture 手势的内部状态会由 ACTIVE 变为 END，并触发 onEnd 回调。在 onEed 回调中，只有容器整体偏离正常位置，也就是 refreshY 的值不等于 -LOADING_HEIGHT，才会使用弹性动画 withSpring 将 refreshY 重置为  -LOADING_HEIGHT。</p><p>其中，弹性动画的 stiffness 指的是“弹簧硬度”，硬度越大弹簧弹的速度越快，“弹簧硬度”默认是 100，这里设置成了 300 的意思是希望回弹的速度快一点。弹性动画的 overshootClamping 指的是“夹住过冲”，默认 overshootClamping 的值是 false，这时弹簧会沿着它的默认形变的中心线来回反复地弹。我这里将它设置为了 true，也就是说，弹簧在回到默认形变的中心线的时候就会停下来，整体容器的松手动画会直接停在屏幕上边缘。</p><p>那如果你的选择是 B 方案呢？</p><p>如果你选择了往反方向滚取消刷新，那么滚动手势和拖拽手势还会同时响应，并且拖拽动画还会继续执行，拖拽动画向反方向改变 Animated.View 的 translateY 偏移量。具体代码你可以看下这里：</p><pre><code class=\"language-plain\">// 拖拽动画\nif (scrollY.value === 0 || refreshY.value !== -LOADING_HEIGHT) {\n  refreshY.value =  Math.max(-LOADING_HEIGHT, refreshY.value + e.changeY) ;\n}\n</code></pre><p>这里你可以注意下执行拖拽动画的判断条件。因为我设置了只要 scrollY 的值为 0 或者 refreshY 的值不为 -LOADING_HEIGHT 时，也就是 ScrollView 内容顶到头或者整体视图不在正确的位置上，就可以触发拖拽手势，因此这时我们是可以反方向向上拖拽的。</p><p>但这里有个坑，向上拖拽时 ScrollView 内容也是可以向上滚动的，但我们这里并没有禁止 ScrollView 内容的滚动。这个坑怎么处理呢？我们后面再聊，我们先接着看最后一步。</p><p>如果你继续不松手的向上滚动，滚动手势和拖拽手势还会同时响应，但因为整体视图回到默认位置了所以拖拽动画不会执行了，而是滚动动画开始执行，ScrollView 的内容开始向上滚动。</p><p><strong>整个回弹下拉刷新的手势动效是连贯的，整个过程中都不需要通过松手来切换拖拽动画和滚动动画，这就是 Gesture 手势库和 Reanimated 动画库的强大之处。</strong></p><p>实现 Android 回弹下拉的核心代码，我放到这里，你可以仔细看看：</p><pre><code class=\"language-plain\">const LOADING_HEIGHT = 30\n\nfunction PanAndScrollView() {\n  const refreshY = useSharedValue(-LOADING_HEIGHT);\n  const scrollY = useSharedValue(0);\n  const {height: windowHeight} = useWindowDimensions()\n  const wrapperHeight = windowHeight + LOADING_HEIGHT\n\n  const scrollGesture = Gesture.Native()\n\n  const panGesture = Gesture.Pan()\n    .onChange(e =&gt; {\n      // 滚动到顶部或者容器整体偏离正常位置时，可触发手势动画\n      if (scrollY.value === 0 || refreshY.value !== -LOADING_HEIGHT) {\n        refreshY.value =  Math.max(-LOADING_HEIGHT,refreshY.value + e.changeY) ;\n      }\n    })\n    .onEnd(() =&gt; {\n      // 松手时，如果容器整体偏离正常位置\n      if (refreshY.value !== -LOADING_HEIGHT) {\n        // 则使用弹性动画 withSpring，回弹至原位置\n        refreshY.value = withSpring(-LOADING_HEIGHT, {\n          stiffness:300,\n          overshootClamping: true\n        })\n      }\n    })\n\n  const animatedStyle = useAnimatedStyle(() =&gt; {\n    return {\n      transform: [{translateY: refreshY.value}],\n    };\n  });\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: e =&gt; {\n      // 记录偏移量，只读不写\n      scrollY.value = e.contentOffset.y;\n    },\n  });\n\n  return (\n        &lt;Animated.View style={[{height: wrapperHeight}, animatedStyle]}&gt;\n          &lt;Text style={{height: LOADING_HEIGHT }}&gt;loading...&lt;/Text&gt;\n          &lt;GestureDetector gesture={Gesture.Simultaneous(scrollGesture, panGesture)}&gt;\n            &lt;Animated.ScrollView \n              bounces={false}\n              onScroll={scrollHandler}\n              scrollEventThrottle={1}&gt;\n              {Array(100).fill(1).map((_, index) =&gt; (&lt;Text key={index}&gt;{index}&lt;/Text&gt;))}\n            &lt;/Animated.ScrollView&gt;\n          &lt;/GestureDetector&gt;\n        &lt;/Animated.View&gt;\n  );\n}\n</code></pre><h2>多视图多手势的冲突问题</h2><p>刚刚我们实现的 Android 回弹下拉刷新功能，大体上是能用的，但是它还有两个小的体验问题。</p><p><strong>首先是 Loading 本身不能不响应拖拽手势</strong>，这就限制了回弹下拉刷新功能的通用性。如果你想把 Loading 替换成类似淘宝二楼的效果，用刚刚我们实现的下拉刷新组件来做就会有 Bug。要知道，二楼视图的高度可要比只有 30 像素的 Loading 高很多，用户很容易拖拽到二楼视图，如果用户拖拽后发现没有反应，肯定会感觉到很奇怪。</p><p>另外一个体验方面的问题是，在B方案中，也就是<strong>不松手而是反向滚动或拖拽这个步骤</strong>时，滚动动画和拖拽动画都没有禁止，二者可能会同时触发，这会导致出现两个叠加视图偏移问题。</p><p>要让 ScrollView 视图和 Loading 视图同时监听滚动和拖拽手势，要让执行拖拽动画时不能执行滚动动画，就涉及多视图多手势的冲突问题了。</p><p>那么，多视图多手势冲突问题该怎么解决？</p><p>解决多视图多手势的冲突问题，我们首先要学会站在单个手势的视角来解决这个问题，我给你画了一个示意图，你先看看：</p><p><img src=\"https://static001.geekbang.org/resource/image/66/72/6684e3312f30fc2630c47090e7c5d872.png?wh=1920x901\" alt=\"图片\"></p><p>示意图中左边的部分，就是站在拖拽手势的视角来解决冲突问题的。拖拽手势是这么想的：既然你想在响应我拖拽手势的同时响应轻按、滚动手势，那我可以提供一个方法函数，你把轻按、滚动手势都告诉我吧。</p><p>咦？这里多了个轻按手势，它是用来干嘛的呢？我们先保留一个悬念，你一会就知道了。</p><p>然后我们再看示意图中右边的部分，这是站在滚动手势的视角来解决冲突问题的。滚动手势是这么想的：你想让我滚动手势和拖拽手势同时响应，但不想让滚动动画和拖拽动画同时执行，但我滚动手势并不知道拖拽动画是否能执行呀！</p><p>那么这要怎么办呢？</p><p>我们可以换个思路。我滚动手势虽然不知道动画逻辑是什么时候执行的，但能够知道其他手势什么时候执行完成呀。要不这样？你先创建一个假的轻按手势，当拖拽动画不可执行时，你就主动把轻按手势结束。这样我收到轻按手势结束的通知时，就知道拖拽动画不可执行了，这时我再把滚动动画由不可执行的状态变为可执行的状态。</p><p>以上就是我们站在手势的视角，解决两个下拉刷新体验问题的核心思路，这也是为什么前面的示意图中会多一个轻按手势的原因。</p><p>那具体怎么实现呢？</p><p>我先带你看下新的 JSX 结构的实现，代码如下：</p><pre><code class=\"language-plain\">&lt;GestureDetector gesture={panGesture}&gt;\n  &lt;Animated.View style={[{height: wrapperHeight}, animatedStyle]}&gt;\n    &lt;Text&gt;loading...&lt;/Text&gt;\n    &lt;GestureDetector gesture={Gesture.Simultaneous(scrollGesture, tapGesture)}&gt;\n      &lt;Animated.ScrollView/&gt;\n    &lt;/GestureDetector&gt;\n  &lt;/Animated.View&gt;\n&lt;/GestureDetector&gt;\n</code></pre><p>这段代码就是站在视图的视角，把手势和视图绑定在一起了。这里有三个手势，分别是 panGesture、scrollGesture、tapGesture。当你手指触碰到外层容器 Animated.View 时，panGesture 就会响应。这样无论你是触碰到它的子容器 Text，还是 ScrollView ，都能触发 panGesture 手势。</p><p>而 <strong>scrollGesture 手势只能在触碰到 ScrollView 视图时进行响应，而且我还配了一个控制滚动动画是否执行的 tapGesture 手势。</strong></p><p>接下来的代码，就是站在 panGesture 手势的视角，让它支持和 scrollGestur、tapGesture 这两个手势同时响应，示例代码如下：</p><pre><code class=\"language-plain\">const tapGesture = Gesture.Tap()\nconst scrollGesture = Gesture.Native()\nconst panGesture = Gesture.Pan()\n    .simultaneousWithExternalGesture(scrollGesture, tapGesture)\n</code></pre><p>上述代码中，panGesture 手势调用了 simultaneousWithExternalGesture 方法，方法入参是 scrollGesture, tapGesture。这段代码的意思是，在响应我 panGesture 手势时，可以同时响应 scrollGesture、tapGesture 手势。</p><p><strong>Gesture 手势库中的 9 个手势，每个手势对象上都有 simultaneousWithExternalGesture 方法，该方法接收若干个其他手势作为参数，作用是让该手势能和若干个其他手势同时进行响应。</strong></p><p>然后我们再站在 scrollGesture 手势的视角，让它在整体视图没有回归到正常位置的时候，不执行滚动动画，示例代码如下：</p><pre><code class=\"language-plain\">// hack: 使用 tapGesture 手势作为控制 scrollGesture 是否执行动画的开关\n// 并不是真正的要响应 Tap 手势\nconst tapGesture = Gesture.Tap()\n  .onTouchesMove((_, manager) =&gt; {\n      // 如果 ScrollView 容器没有顶到屏幕顶部\n    if (LOADING_HEIGHT + refreshY.value === 0) {\n        // 则设置 Tap 手势内部状态为 FAILED\n      manager.fail();\n    } else {\n        // 其他情况则设置 Tap 手势内部状态为 ACTIVE\n        // 因为 Tap 手势实际触发了，所以内部也会调用\n        // 这里又显式调用了一次，为的是让大家看得更明白一些。\n      manager.activate();\n    }\n  })\n  .maxDuration(1000000);\n\n  const scrollGesture = Gesture.Native()\n    // 当 Tap 手势内部状态为 ACTIVE 时，滚动动画不执行\n    // 当 Tap 手势内部状态为 FAILED 时，滚动动画执行\n    .requireExternalGestureToFail(tapGesture);\n</code></pre><p>这段代码虽然很简单，但其实是一种 hack 方法，为了让你看得更明白一些，我又加了很多注释。</p><p>代码中先创建了一个 tapGesture 手势，在手势的 onTouchesMove 回调中执行了控制其内部状态的逻辑，只有当外层容器的偏移量 refreshY 和 LOADING_HEIGHT 的高度抵消时，整体视图才回归到正常位置，此时将 tapGesture 内部状态设置为 FAILED。</p><p>并且，我还调用了 tapGesture 的 maxDuration 方法，这个值的默认值只有 500ms。我将其最大响应时间设置为 1000000ms，大概是 16 分钟。在这 16 分钟内，Gesture 手势库不会直接结束 Tap 事件，只有在我主动调用 FAILED时，或者手指离开屏幕时才会主动结束，这样就保证了我的 hack 逻辑正常执行了。</p><p>接着我又在 scrollGesture 手势中调用了 requireExternalGestureToFail 方法，该方法的入参是 tapGesture，其作用是当 tapGesture 手势的内部状态置为 FAILED 时，开始执行滚动动画。</p><p><strong>其中，requireExternalGestureToFail 方法在 Gesture 手势库中的 9 个手势对象上都能调用。该方法接收若干个其他手势作为参数，只有在其他若干个手势都失败后，该手势才会变为 ACTIVE 响应，在滚动手势上表现为执行滚动动画。</strong></p><p>这样我就通过 hack 的手段，解决了滚动动画和手势动画叠加导致的视图异常偏移的潜在问题。</p><p>优化后的 Android 回弹滚动示例代码如下：</p><pre><code class=\"language-plain\">const LOADING_HEIGHT = 200;\n\nfunction PanAndScrollView() {\n  const refreshY = useSharedValue(-LOADING_HEIGHT);\n  const scrollY = useSharedValue(0);\n  const {height: windowHeight} = useWindowDimensions();\n  const wrapperHeight = windowHeight + LOADING_HEIGHT;\n\n  const tapGesture = Gesture.Tap()\n    .onTouchesMove((_, manager) =&gt; {\n      if (LOADING_HEIGHT + refreshY.value === 0) {\n        manager.fail();\n      } else {\n        manager.activate();\n      }\n    })\n    .maxDuration(1000000);\n\n  const scrollGesture = Gesture.Native()\n    .requireExternalGestureToFail(tapGesture);\n\n  const panGesture = Gesture.Pan()\n    .onChange(e =&gt; {\n      if (scrollY.value === 0 || refreshY.value !== -LOADING_HEIGHT) {\n        refreshY.value = Math.max(-LOADING_HEIGHT, refreshY.value + e.changeY);\n      }\n    })\n    .onEnd(() =&gt; {\n      if (refreshY.value !== -LOADING_HEIGHT) {\n        refreshY.value = withSpring(-LOADING_HEIGHT, {\n          stiffness: 300,\n          overshootClamping: true,\n        });\n      }\n    })\n    .simultaneousWithExternalGesture(scrollGesture, tapGesture);\n\n  const animatedStyle = useAnimatedStyle(() =&gt; {\n    return {\n      transform: [{translateY: refreshY.value}],\n    };\n  });\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: e =&gt; {\n      scrollY.value = e.contentOffset.y;\n    },\n  });\n\n  return (\n    &lt;GestureDetector gesture={panGesture}&gt;\n      &lt;Animated.View style={[{height: wrapperHeight}, animatedStyle]}&gt;\n        &lt;Text style={{height: LOADING_HEIGHT,}}&gt;\n          loading...\n        &lt;/Text&gt;\n        &lt;GestureDetector\n          gesture={Gesture.Simultaneous(scrollGesture, tapGesture)}&gt;\n          &lt;Animated.ScrollView  onScroll={scrollHandler} scrollEventThrottle={1}&gt;\n             {Array(100).fill(1).map((_, index) =&gt; (&lt;Text key={index}&gt;{index}&lt;/Text&gt;))}\n          &lt;/Animated.ScrollView&gt;\n        &lt;/GestureDetector&gt;\n      &lt;/Animated.View&gt;\n    &lt;/GestureDetector&gt;\n  );\n}\n</code></pre><p>到这里，我们就通过站在单个手势的视角拆解问题，解决了多视图多手势的冲突。我们现在再回到Gesture第一讲中我提到的 3 个曾经困扰过我的问题：Android 回弹下拉刷新、类似抖音评论区的手势动效、类似淘宝首页的手势动效。</p><p>通过这三讲的学习，相信你已经知道怎么去解决第一个问题了。剩下的两个问题，我也找到了类似的解决方案，你可以看下我<a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/17_Gesture\"> GitHub</a> 上的代码。有什么问题，请在评论区给我留言。</p><ul>\n<li><a href=\"https://github.com/jiangleo/react-native-classroom/blob/main/src/17_Gesture/4_BetterPanAndScrollView.tsx\">Android 回弹下拉刷新（本节课案例）</a>；</li>\n<li><a href=\"https://github.com/jiangleo/react-native-classroom/blob/main/src/17_Gesture/5_NestBottomSheet.tsx\">类似抖音评论区的手势动效</a>（改自 Gesture 手势库提供的 bottom_sheet 示例）；</li>\n<li><a href=\"ttps://github.com/jiangleo/react-native-classroom/blob/main/src/17_Gesture/6_HeadTabs.tsx\">类似淘宝首页的手势动效</a>（找到一个开源库，但用的是 Reanimated v2 + Gesture v1 实现的）。</li>\n</ul><p>如果你觉得光有图片，没有视频，入门比较费劲，你可以搭配<a href=\"https://www.youtube.com/watch?v=xpT2shjX790\">《Introduction to Gesture Handler 2 (React Native)》</a>视频教程一起学习。</p><h2>总结</h2><p>在平时和大家交流的时候，我发现不仅仅是我遇到了 React Native 的手势冲突问题，大家也经常遇到手势冲突的问题，但不知道怎么解决。</p><p>从技术上，解决思路有三个要点：</p><p>首先，手势动画不分家，将 Reanimated v2 + Gesture v2 搭配起来用，它俩的回调都是放在 UI 线程同步执行的，性能和体验上会更好。</p><p>其次，Gesture 手势库提供可扩展性强的、功能丰富的 “1 + 8” 种手势，1 是给你自定义的原始手势，8 是已经封装好的 8 种常用的手势。</p><p>最后，Gesture 手势库创新地站在组件角度、站在手势角度给出了手势冲突的解决方案，这两种解决方案完全可以替代 React Native 框架原有的、站在事件角度的捕获冒泡方案，而且解决了多视图多手势冲突的问题。</p><p>另外，我觉得当你遇到业内已有类似解决方案的问题时，不妨多看看 Github 社区上的代码，很多社区库在 Github 上都提供了 Example 示例，这些示例非常有价值，我实现 Android 回弹下拉刷新和类似抖音评论区的手势动效这两个 demo，都是从 Gesture 手势库的 <a href=\"https://github.com/software-mansion/react-native-gesture-handler/tree/main/example\">Example 示例</a>中找到的灵感。</p><p>有空的时候，你也可以多看看这些优秀开源库的示例，相信这对你的成长会特别有帮助。</p><h2>作业</h2><ol>\n<li>请你参考这一讲中的 Android 下拉刷新 Demo，实现一个类似淘宝二楼的手势效果。</li>\n<li>请你说说你在开发 React Native 时遇到过哪些手势动效问题？学完这三讲后你有没有新的解决思路？</li>\n</ol><p>欢迎在评论区写下你的观点和想法。我是蒋宏伟，咱们下节课见。</p>","neighbors":{"left":{"article_title":"16｜Gesture（中）：如何解决单视图多手势的冲突问题？","id":514905},"right":{"article_title":"18｜Navigation：页面之间怎么跳转？","id":516300}}},{"article_id":516300,"article_title":"18｜Navigation：页面之间怎么跳转？","article_content":"<p>你好，我是蒋宏伟。今天我要给你介绍的是导航。</p><p>导航是用来管理页面之间的链接的。你平时用的 App，比如微信、抖音、京东，都有很多个页面，这些页面之间会有跳转、返回、切换等链接操作，这些链接操作就是导航。我们开发 React Native App 也一样，需要使用导航来链接各个页面。</p><p>尽管导航是开发 React Native App 必不可少的工具之一，但 React Native 框架并未将其内置，需要开发者自己进行集成。在 2018 年之前，业内用得比较多的导航是 React Native Navigation，在 2018 年之后大家用得更多的是 React Navigation。它们的名字很相似，不过你可千万不要搞混了，<strong>目前官方推荐的、主流的导航是 React Navigation，而不是 React Native Navigation。</strong></p><p>你可以看一下，<a href=\"https://reactnavigation.org/\">React Navigation</a>、<a href=\"https://wix.github.io/react-native-navigation/docs/before-you-start/\">React Native Navigation</a> 和 React Native 三个库的 npm 下载量：</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/71/ab4b904ec634cacd2c7ffe7341788771.png?wh=1920x764\" alt=\"图片\"></p><p>这张图中，蓝色线条代表的是 React Navigation，绿色线条代表的是 React Native Navigation，橙色线条代表的是 React Native。从三个库的下载量中你可以看出，目前 React Navigation 导航已经成为主流，把 React Native Navigation 导航远远地甩在了后面，并且每十次 React Native 框架的下载，有七到八次都会下载 React Navigation 导航，由此可见，React Navigation 确实是非常受欢迎的。</p><!-- [[[read_end]]] --><p>所以今天，我们就来看看怎么用 React Navigation 导航把各个页面链接起来。</p><h2>导航基础</h2><p>我们先从最常见的导航形式跳转开始。要实现一个基础的跳转导航，一共需要三步：</p><ol>\n<li>创建“导航地图”；</li>\n<li>携带参数跳转页面；</li>\n<li>页面接收和解析参数。</li>\n</ol><p>接下来，我们一起实现一个最基础的导航功能，包括导航跳转和导航返回，示意图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/57/8e80cbf23563e99a9c359f59cce6ec57.png?wh=1751x1059\" alt=\"图片\"></p><p>图中的第一个页面是 Discover 页面，第二个页面是 Detail 页面。Discover 页面包括 3 个列表项目：小猫、小狗和狮子。点击小狗列表项时，就会跳转到 Detail 页面，Detail 页面显示了小狗的详细介绍，这只小狗叫做“旺财”。点击 Detail 页面左上角的返回键时，就会返回到 Discover 页面。</p><p>假设现在由你来创建发现页 Discover 和另外一个详情页 Detail，并实现跳转和返回的导航，你应该怎么做呢？</p><p>在跟着我具体实现时，需要你先集成 React Navigation，这里的具体步骤你可以参考 <a href=\"https://reactnavigation.org/docs/getting-started\">React Navigation 官方文档</a>自行集成。接着，你就可以跟着我，按照创建“导航地图”、携带参数跳转页面、页面接收和解析参数这三步来实现应用的跳转。</p><p><strong>第一步就是创建“导航地图”。</strong></p><p>这点和我们日常生活中是一样的。日常生活中，我们要实现地点和地点之间的连接，前提是要有包含这两个地点的地图，比如你可以借助景区地图帮你导航到你想去的地方。App 中的页面导航也是如此，要实现页面和页面之间的链接，前提是要有包含该 App 所有页面的“导航地图”。</p><p>在 React/React Native 中，所有的页面都是由组件创建出来的，因此首先你需要创建两个组件，一个是 Discover 组件，另一个是 Detail 组件，组件内容比较简单，我就用伪代码代替了：</p><pre><code class=\"language-plain\">function Discover() {\n  return &lt;Text&gt;发现视图&lt;/Text&gt;\n}\nfunction Detail() {\n  return &lt;Text&gt;详情视图&lt;/Text&gt;\n}\n</code></pre><p>有了组件后，如何使用组件创建页面，又如何把这些页面链接成“导航地图”呢？</p><p>这时候你就需要使用到 React Navigation 提供的容器组件 NavigationContainer ，以及创建导航的方法 createNativeStackNavigator，示例代码如下：</p><pre><code class=\"language-plain\">import { NavigationContainer } from '@react-navigation/native';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst Stack = createNativeStackNavigator();\n\nfunction App() {\n  return (\n    &lt;NavigationContainer&gt;\n      &lt;Stack.Navigator initialRouteName=\"Discover\"&gt;\n        &lt;Stack.Screen name=\"Discover\" component={Discover} /&gt;\n        &lt;Stack.Screen name=\"Detail\" component={Detail} /&gt;\n      &lt;/Stack.Navigator&gt;\n    &lt;/NavigationContainer&gt;\n  );\n}\n</code></pre><p>React Navigation 导航分了好几个子库。要创建页面，我们首先要从 @react-navigation/native 库中引入NavigationContainer 容器组件，并将其放在最外层包裹住整个 App 的 JSX 元素。然后从 @react-navigation/native-stack 库中引入 createNativeStackNavigator 方法，并使用它来创建原生堆栈导航 Stack。</p><p><strong>原生堆栈导航 Stack，是用来创建页面和收集该导航下有哪些页面的。创建页面用的是 Stack.Screen 组件，收集页面用的是 Stack.Navigator 组件。</strong></p><p>在上述代码中，我们使用 Stack.Screen 创建了两个页面，名字是“Discover”的页面是由 Discover 组件创建的，名字是“Detail”的页面是由 Detail 组件所创建的。虽然页面和组件的名字叫法相同，比如都叫 Discover 或 Detail，但是它们的数据类型不同。页面的名字是字符串类型，创建页面的组件是函数类型。</p><p>又因为这里两个 Stack.Screen 页面都是 Stack.Navigator 元素的子元素，这就相对于告诉了  Stack.Navigator，它有两个页面，分别是 Discover 页面和 Detail 页面。并且我将 Stack.Navigator 的 initialRouteName 设置成了 Discover，目的是告诉导航展示的默认页面是 Discover 页面。</p><p><strong>完成页面的创建和页面的声明后，你的 App 才算点亮了“导航地图”。</strong></p><p>需要提醒你的是，在上述示例中，页面名字和函数组件名字用的叫法是一样的，这只是为了好理解，实际上页面名字和组件名字可以取不同的名字，甚至你可以通过同一个组件来创建多个页面。示例代码如下：</p><pre><code class=\"language-plain\">&lt;Stack.Navigator initialRouteName=\"Discover1\"&gt;\n  &lt;Stack.Screen name=\"Discover1\" component={Discover} /&gt;\n  &lt;Stack.Screen name=\"Discover2\" component={Discover} /&gt;\n  &lt;Stack.Screen name=\"Discover3\" component={Discover} /&gt;\n&lt;/Stack.Navigator&gt;\n</code></pre><p>如上所示，你可以使用 Discover 函数组件同时创建三个不同名字的页面 Discover1、Discover2、Discover3。</p><p><strong>在有了导航地图后，要做的第二步是携带参数跳转页面。</strong></p><p>首先我们要思考的是：如何从一个页面跳转到另外一个页面呢？</p><p>实现页面之间跳转，最常用的方法就是使用 navigation.navigate 函数，示例代码如下：</p><pre><code class=\"language-plain\">// 函数组件默认是没有 navigation 对象的\n// 当函数组件通过 Stack.Screen 生成页面时，才会有 navigation 对象\nfunction Discover({navigation}) {\n  return (\n       &lt;Pressable onPress={()=&gt; {\n               navigation.navigate('Detail');\n       }}&gt;\n          &lt;Image source={require('./images/dog.png')} /&gt;\n      &lt;/Pressable&gt;\n  );\n}\n\nfunction Detail() {  \n  return (\n    &lt;View&gt;\n      &lt;Text&gt;旺财旺财旺财~&lt;/Text&gt;\n      &lt;Image source={require('./images/dog.png')} /&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre><p>在上述代码中，在点击按钮后会执行回调函数，回调函数中会执行跳转代码 navigation.navigate(‘Detail’)，从而实现了从 Discover 页面到 Detail 页面的跳转。<br>\n其中的关键是 navigation 对象，这个 navigation 对象是从哪里来的呢？在你将 Discover 组件绑定到 Stack.Screen 组件的 component 参数上执行后，该函数组件 Discover 就自动获取到导航对象 navigation 了，该对象的 navigate 方法可以实现从一个页面到另一个页面的跳转。</p><p>在这个示例中，Detail 页面的参数是完全写死的，详情页的文案是“旺财”，图片也是小狗的图片，而实际上我们要的详情页会有不同的参数，可能是小狗旺财，也可能是小猫 Kitty，还可能是狮子辛巴。</p><p>这也意味着，Detail 页面的数据是动态的，这些动态的数据需要上一个页面 Discover 给它带过来。</p><p><strong>接下来的第三步就是，携带自定义参数跳转和接收自定义参数。</strong></p><p>在两个页面之间运转参数的载体是路由 route。所以接下来，我们就修改一下上面的跳转示例，看下 route 是如何帮助我们携带自定义参数跳转的。</p><pre><code class=\"language-plain\">const ALL_NTF = [\n  {/* ... */},\n  {\n    describe: '旺财旺财旺财~',\n    image: require('./images/dog.png'),\n  },\n  {/* ... */},\n];\n\nfunction Discover({navigation}) {\n  return (\n    {/* ... */}\n       &lt;Pressable onPress={()=&gt; {\n               navigation.navigate('Detail', ALL_NTF[1]);\n       }}&gt;\n          &lt;Image source={ALL_NTF[1].image} /&gt;\n      &lt;/Pressable&gt;\n    {/* ... */}\n  );\n}\n\nfunction Detail({route}) {\n  const { describe, image }  = route.params\n  return (\n    &lt;View&gt;\n      &lt;Text&gt;{describe}&lt;/Text&gt;\n      &lt;Image source={image} /&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre><p>你可以看到，这里有一份自定义数据和当前页面 Discover，还有要跳转的页面 Detail。在当前页面 Discover 上，navigation 对象上的 navigate 方法接受的第一个参数是要跳转的页面名字，第二个参数是跳转时要携带的自定义参数。在这里，要跳转的页面是 Detail 页面，要携带的自定义参数是“旺财”的相关对象。</p><p>“旺财”对象会被挂在 route 的 params 属性上，因此你可以在 Detail 页面使用  route.params 来获取“旺财”对象。</p><p>route 对象和 navigation 对象类似，函数组件默认是没有这两个对象的。<strong>当你使用 Stack.Screen 创建页面时，用来创建页面的函数组件就会同时获取到 navigation 对象和 route 对象。</strong>其中 navigation 对象的主要作用是跳转，route 对象的主要作用是携带自定义参数。</p><p>那如何从 Detail 页面返回到 Discover 页面呢？</p><p>返回的相关工作，React Navigation 会帮你处理，它会给页面创建导航栏，并帮助页面处理返回相关手势动画。在导航栏中会有个回退到上一个页面的返回按钮，除此之外，它还支持 iOS 侧滑手势返回上个页面，以及 Android 点击底部虚拟回退按钮返回上级页面。</p><p>通过创建“导航地图”、携带参数跳转页面、页面接收和解析参数这三步，你就能够实现最基础的页面跳转和返回了。</p><p>不过，如果你要更好地用好 React Navigation ，其中的关键是要理解它的两个配置项和导航路由对象。接下来我们就从它的两个配置项开始讲起。</p><h2>自定义参数 params</h2><p>使用 React Navigation 创建出来的页面，有两类属性值比较常用，它们是：</p><ul>\n<li>params：它是开发者自定义参数，通常用来渲染页面主体的数据，它是挂在 route 上的对象；</li>\n<li>options：它是导航相关的配置属性，包括手机顶部的状态栏、页面的标题栏、导航相关手势等等。</li>\n</ul><p>虽然 params 和 options 一个是自定义数据，一个是导航属性，但它们在使用方法上有很多相似之处，所以接下来我们会一起对比着学习。</p><p>它们既可以在全局的“导航地图”中进行配置，也可以在当前页面调用相关方法进行重置，示意图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/00/aa/0007a8b6e57a8a88525af79747b00daa.png?wh=1920x1293\" alt=\"图片\"></p><p>从上图中你可以看到，当你调用 navigation.navigate 方法时，就相当于告诉导航你“目的地”的名字 name 和要携带参数 params。这时导航框架会在它内部的“导航地图”中，也就是 <code>&lt;Stack.Navigator&gt;{/* ... */}&lt;/Stack.Navigator&gt;</code> 中，寻找名字是 name 的页面，然后继续找到相关的组件 component，并配合导航配置项 options 和初始化自定义参数 initParams，一起把页面渲染出来。</p><p>在一些场景下，params 和 options 并不是固定的，当前页面也可以根据实际情况使用 setParams 和 setOptions 方法，对二者进行重新设置。我们这里分析的过程就是页面的 params 和 options 参数的配置和重置的全过程。</p><p><strong>那么，现在我们来看一下 params 配置和重置的方法。</strong></p><p>params 的配置方法比较简单，在 Stack.Screen 上有一个配置属性 initialParams，示例代码如下：</p><pre><code class=\"language-plain\">// 数据\nconst ALL_NTF = [\n  {title: 'Kitty',...},\n  {title: '旺财', ...},\n  {title: 'Simba', ...},\n];\n\n// 页面声明\n&lt;Stack.Screen name=\"Detail\" initialParams={ALL_NTF[0]} component={Detail} /&gt;\n\n// （1）跳转页面，携带 Params\nnavigation.navigate('Detail', ALL_NTF[1]);\n// （2）跳转页面，不携带 Params，使用默认的 initialParams\nnavigation.navigate('Detail');\n</code></pre><p>在这里的示例代码中，我们演示了两种跳转情况：第一种情况是携带“旺财”相关的 params 参数进行跳转；第二种情况是没有携带任何 params 参数，直接跳转到了 Detail 页面。第一种情况，展示的当然是“旺财”页面。不过，第二种没有携带任何参数跳转时，我们需要一个默认参数来渲染 Detail 页面，没有参数就会报错。</p><p>那要如何设置默认的 params 参数呢？在页面声明时，我给 Stack.Screen 元素设置了默认属性 initialParams，initialParams 的值是“小猫 Kitty”，所以，即便遇到不携带任何自定义参数跳转的情况，也会展示“小猫 Kitty” 而不会报错。</p><p>在页面跳转的过程中，initialParams 对象和 params 对象会进行对象合并，而不是覆盖，演示代码如下：</p><pre><code class=\"language-plain\">// 对象合并 \n跳转时： params {price: 99.9 }\n配置的： initialParams {symbol: '$'}\n获取后： route.params {symbol: '$', price: 99.9 }\n</code></pre><p>在该示例中，跳转时传入的参数是价格 99.9，这个价格没有任何货币单位。我们可以在 initialParams 中配置它的默认单位 <span dollar=\"\">$</span>，这样在组件函数中获取到的 route.params 就既包括了价格 99.9 也包括了货币单位 <span dollar=\"\">$</span> 。</p><p>因此，<strong>initialParams 属性的作用是，给页面设置默认的且可覆盖的 params 自定义参数</strong>。</p><p>我们再假设一种情况，如果在用户选择点击“切换成￥”按钮时，要把 <code>$99.9</code> 按 6.3 的汇率换算成改成 <code>￥629</code>，我们应该如何重置 params 呢？这里重置 params 参数，用到的是 navigation.setParams 方法，示例代码如下：</p><pre><code class=\"language-plain\">// 初始化 params：{symbol: '$', price: 99.9, image: 'dog.png' }\n// 重置后 params：{symbol: '￥', price: 629.37, image: 'dog.png' }\nfunction Detail({route, navigation}) {  \n  const { price, symbol, image} = route.params \n  return (\n      &lt;&gt;\n        &lt;Image source={image} /&gt;\n      &lt;Text&gt;{symbol}{price}&lt;/Text&gt;\n      &lt;Text onPress={() =&gt;{\n        if (symbol === '￥') return \n        navigation.setParams({\n          symbol:'￥',\n          price: price * 6.3 \n        })  \n      }}&gt;切换成￥&lt;/Text&gt;\n    &lt;/&gt;\n     )\n}\n</code></pre><p>在上述代码中，我们使用 route.params 参数将当前页面渲染了出来，包括图片、金额和“切换成￥”的按钮。在你点击“切换成￥”的按钮的按钮时，会调用 navigation.setParams 方法，将现金符号 symbol 和现金价格 price 重新设置一次。</p><p>初始化时，页面显示的现金符号是 $，现金价格是 99.9，图片是“小狗旺财”的图片；重新设置后，现金符号是 ￥，现金价格是 629，但图片 image 的参数是不变的，它还显示的是“小狗旺财”的图片。</p><p>由此可以看出，<strong>使用 navigation.setParams 重置自定义 params 参数时，会将新旧 params 对象进行合并，并使用合并后的 params 重新渲染页面。</strong></p><h2>导航配置 options</h2><p>导航页面中，第二类比较常用的是导航配置属性 options。</p><p>options 具体的配置非常多，如果你有配置的需要，最好查查<a href=\"https://reactnavigation.org/docs/native-stack-navigator#options\">文档</a>。不过为了让你对 options 有个整体的了解，我把一些常用的配置项都列了出来，分成了 3 类：</p><p><strong>header 类：</strong></p><ul>\n<li>title：它是字符串，用于设置导航标题；</li>\n<li>headerBackTitleVisible：它是布尔值，用于决定返回按钮是否显示回退页面的名字。默认是 true 显示，大多数应用是不显示，因此最好设置为 false（iOS专属）；</li>\n<li>headerShown：它是布尔值，用于决定是否隐藏导航头部标题栏；</li>\n<li>header：它接收一个返回 React 元素的函数作为参数，返回的 React 元素就是新的导航标题栏。</li>\n</ul><p><strong>status 类：</strong></p><p>控制屏幕顶部状态栏用的，也可使用 React Native 框架提供的 <code>&lt;StatusBar /&gt;</code> 组件进行代替。</p><ul>\n<li>statusBarHidden：它是布尔值，它决定了屏幕顶部状态栏是否隐藏。</li>\n</ul><p><strong>手势动画类：</strong></p><ul>\n<li>gestureEnabled：它是布尔值，它决定了是否可用侧滑手势关闭当前页面（iOS专属）；</li>\n<li>fullScreenGestureEnabled：它是布尔值，它决定了是否使用全屏滑动手势关闭当前页面（iOS专属）；</li>\n<li>animation：它是字符串枚举值，它控制了打开或关闭 Stack 页面的动画形式，默认“default”是页面从右到左地推入动画，也可以设置成其他类型的动画，比如“slide_from_bottom”是页面从下到上的推入动画和从上到下的推出动画；</li>\n<li>presentation：它是字符串枚举值，它控制了页面的展现形式，其主要作用是设置页面弹窗。常用的配置值是 “transparentModal”  它会将页面展示为一个透明弹窗。</li>\n</ul><p>那么，这些 options 配置项具体怎么用呢？</p><p>我给你举个例子，比如你想让详情页的图片展示更加有沉浸感，你就可以把详情页的 header 给隐藏了，并让它支持全屏返回。示例代码如下：</p><pre><code class=\"language-plain\">&lt;Stack.Screen name=\"Detail\" component={Detail} options={{\n  headerShown: false,\n  fullScreenGestureEnabled: true\n}} /&gt;\n</code></pre><p>如上所示，Stack.Screen 元素提供了 options 参数，该 options 参数可以控制页面导航属性。这里我先是使用了 headerShown 隐藏了标题栏，并且使用了 fullScreenGestureEnabled 属性使其支持全屏返回。</p><p>options 参数既可以配置，也可以动态设置。比如，点击某个按钮动态更新 title 标题的文案。又比如，有时候在大团队中一个人只负责一个部分，负责该页面的同学不方便修改其他团队维护的全局配置，就可以在当前页面初始化时动态设置 options 参数。</p><p>以上是通过配置设置 options 参数的过程，那如何在当前页面修改 options 配置呢？在当前页面重置 options 参数用的方法就是 setOptions，示例代码如下：</p><pre><code class=\"language-plain\">function Detail({ navigation}) {\n\n  // React.useEffect() 异步副作用回调，执行 setOptions 会导致闪屏，不推荐使用。\n\n  // 页面初始化时，同步设置\n  React.useLayoutEffect(() =&gt; {\n    navigation.setOptions({\n      headerShown: false,\n      fullScreenGestureEnabled: true,\n    });\n  }, [navigation])\n\n  // 点击按钮后，异步设置\n  const handlePress = () =&gt; {\n    navigation.setOptions({\n      title: '新标题',\n    });\n  }\n\n  return (\n    &lt;Text onPress={handlePress}&gt;设置新标题&lt;/Text&gt;\n  );\n}\n</code></pre><p>你可以看到，使用 navigation.setOptions 设置导航相关属性有两种形式，一种是同步设置，另一种是异步设置。</p><p><strong>在初始化时，为了页面不抖动，我们必须使用同步的方法渲染页面。</strong>比如要隐藏头部和设置全局返回手势，如果是放在 React.useEffect 这种在页面渲染完成后再异步执行的副作用函数中，就会导致先渲染一次有头部的页面，然后再渲染一次没有头部的页面，头部的消失就会影响到整体页面的高度的变化，这时页面看起来就是抖动的。</p><p>React 提供了同步执行的副作用函数 React.useLayoutEffect，把 navigation.setOptions 放在这里面执行，页面初始化的时候会同步地把头部隐藏起来，这样就不会出现页面抖动的现象了。</p><p><strong>而异步设置 options 参数的场景，多用在有交互的场景</strong>，比如点击某个按钮，改变标题的文案。如示例代码所示，在你点击“设置新标题”的按钮后，就会调用 navigation.setOptions 将标题文案重新设置。</p><h2>各类导航</h2><p>在上述导航示例中，我用的例子都是大家用得最多的 Native Stack Navigator。而实际上，除了 Native Stack Navigator 这类导航之外，还有 5 类导航：</p><ul>\n<li>Stack Navigator：Stack Navigator 和 Native Stack Navigator 都属于<strong>堆栈导航</strong>，也就是每跳转一次在堆栈的最上面增加一个新页面，每回退一次在堆栈的最上面减少一个老页面。不同的是，Stack Navigator 底层使用的是 Gesture 手势库和 Reanimated 动画库实现的堆栈导航，而 Native Stack Navigator 使用的是 iOS 原生 UINavigationController 和 Android 原生 Fragment 实现的堆栈导航。<strong>一般情况下，我不推荐你使用 Stack Navigator，Native Stack Navigator 的功能更多，性能也更强大</strong>，<a href=\"https://reactnavigation.org/docs/stack-navigator\">具体见文档和动图</a>。</li>\n<li>Drawer Navigator：<strong>抽屉导航</strong>，也就是从侧边栏推出的导航页面。底层也是用的 Gesture 手势库和 Reanimated 动画库实现的，类似微信首页侧滑查看收起的小程序或公众号文章，这就属于抽屉导航，<a href=\"https://reactnavigation.org/docs/drawer-navigator\">具体见文档和动图</a>。</li>\n<li>Bottom Tabs Navigator：<strong>底部标签导航</strong>。基本上每个 App 底部有好几个 Tab，这种多 Tab 的页面切换的效果在 React Native 中就可以用它来实现，<a href=\"https://reactnavigation.org/docs/bottom-tab-navigator\">具体见文档和动图</a>。</li>\n<li>Material Bottom Tabs Navigator：带 Material 样式的底部标签导航，<a href=\"https://reactnavigation.org/docs/material-bottom-tab-navigator\">具体见文档和动图</a>。</li>\n<li>Material Top Tabs Navigator：<strong>带 Material 样式的顶部标签导航</strong>，它是基于 <code>react-native-tab-view</code> 实现的，你可以把 Material 样式换成你自己的样式，常见的多列表 Tabs 就可以用它来实现，<a href=\"https://reactnavigation.org/docs/material-top-tab-navigator\">具体见文档和动图</a>。</li>\n</ul><p>虽然，各类导航实现的效果各不相同，但是它们的使用方法都是大同小异的，都包括创建“导航地图”、携带参数跳转页面、页面接收和解析参数这三步，它们最常用的参数也是 params 和 options。</p><p>那这些导航具体怎么用呢？我用简单电商 App 为例，讲讲常见导航的单个用法和搭配用法，其中涉及了三类导航：Material Top Tabs Navigator、 Native Stack Navigator 和 Material Top Tabs Navigator。你先看下这张示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/e2/6f9e15aab9fab467502e214edcd5aae2.png?wh=1920x1261\" alt=\"图片\"></p><p>你可以看到，这里我们一共用了 4 个导航，从上到下依次是两个顶部标签导航 Material Top Tabs Navigator、堆栈导航 Native Stack Navigator 和底部标签导航 Material Bottom Tabs Navigator。</p><p>页面顶部用的标签导航是可以左右滑动切换页面的，而且需要支持双层顶部标签切换。也就是说，我们需要优先切换第二层标签页，如果第二层标签页顶到头了，就切换第一层标签页。比如推荐标签页在第二层标签页中的最左边已经顶到头了，但是在第一层标签页中，它的左边还有关注标签页，因此你还可以滑向左边的页面，左滑看到就是关注标签页了。</p><p>页面主题用的是堆栈导航，中间的三个图标是可以点击跳转到详情页的。页面底部用的是底部标签导航，底部标签页只支持点击切换，不支持左右滑动。</p><p>那如何使用 React Navigation 实现这个 App 呢？答案就是使用<strong>导航嵌套</strong>来实现。</p><p>现在我先用底部标签导航和堆栈导航示范一下如何实现导航嵌套，示例代码如下：</p><pre><code class=\"language-plain\">import { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\n\nconst Stack = createNativeStackNavigator();\nconst Tab = createBottomTabNavigator();\n\n\n\nfunction App() {\n  return (\n    &lt;NavigationContainer&gt;\n      &lt;Stack.Navigator initialRouteName=\"TabHome\"&gt;\n        &lt;Stack.Screen name=\"TabHome\" component={TabHome}  /&gt;\n      &lt;/Stack.Navigator&gt;\n    &lt;/NavigationContainer&gt;\n  );\n}\n\nfunction TabHome() {\n  return (\n    &lt;Tab.Navigator initialRouteName=\"Home\" &gt;\n      &lt;Tab.Screen name=\"Home\" component={Home} /&gt;\n    &lt;/Tab.Navigator&gt;\n  );\n}\n\nfunction Home() {return &lt;Text&gt;我是首页&lt;/Text&gt;}\n</code></pre><p>你可以看到，首先我分别使用 createNativeStackNavigator 和 createBottomTabNavigator 导航创建函数，创建了堆栈导航 Stack 和底部导航 Tab。接着又创建了“堆栈导航地图” App 、“底部导航地图” TabHome、首页组件 Home，这三个函数组件对应的元素关系如下所示：</p><pre><code class=\"language-plain\">- App(\"导航地图\")\n  - TabHome(\"导航地图\")\n    - Home(真正的页面)\n</code></pre><p>“堆栈导航地图” App 是根视图，该根视图下面只有一个页面就是“底部导航地图” TabHome，而 TabHome 视图中的子视图只有 Home 视图。</p><p>无论是 Stack.Screen 还是 Tab.Screen，这些“导航地图”中的 Screen 的 component 属性既接受普通页面函数作为参数，也可以接受“导航地图”函数作为参数。<strong>“导航地图”的 Screen 接收“导航地图”作为 component 参数，就是实现导航嵌套的方法，唯一需要保证的是嵌套的最内层必须是普通页面。</strong></p><p>当然，上述示例只有一个 Home 的标签页面，你还可以继续在“导航地图”上进行扩展，多加几个标签页面和堆栈页面，添加完成时候示意结构如下：</p><pre><code class=\"language-plain\">- App(\"导航地图\")\n  - TabHome(\"导航地图\")\n    - Home(标签页面)\n    - Message (标签页面)\n    - My(标签页面)\n  - Page1(堆栈页面)\n  - Page2(堆栈页面)\n  - ...(堆栈页面)\n</code></pre><p>如上所示，添加的 Message 和 My 标签页面会在原来的 Home 标签页组成有三个底部 Tab 的 App，这个 App 中还有若干个可以使用 navigation.navigate 方法进行跳转的堆栈页面。</p><p><strong>我认为，以上这种使用堆栈“导航地图”  Stack 作为根元素，使用底部标签“导航地图”  Tab 作为子元素的嵌套方案是实现类似微信、淘宝这种多底部标签 App 的最佳实践。</strong></p><p>你可能会问，既然“导航地图”可以相互嵌套，那为什么不使用底部标签“导航地图”  Tab 作为根元素，来嵌套堆栈“导航地图” Stack，而是反过来呢？</p><p>我们还是以微信、淘宝，这类多底部标签的 App 为例分析一下。这几个App都有好几个底部标签页，每个标签页中都有可继续跳转的子页面。如果我们使用 Tab “导航地图”作为根元素，那么这几个 Tab “导航地图”的子元素必须是 Stack “导航地图”，示意图如下：</p><pre><code class=\"language-plain\">- App(\"Tab 导航地图\")\n  - Home(\"Stack 导航地图\")\n        - Page1\n      - Page2\n  - Message(\"Stack 导航地图\")\n      - Page3\n      - Page4\n</code></pre><p>在这个方案中，App“Tab 导航地图”有两个子标签 Home 和 Message，这两个子标签都是“Stack 导航地图”。在 Home 子标签下有两个普通页面 Page1 和 Page2，在 Message 子标签下另外两个普通页面 Page3 和 Page4。</p><p>这就是使用“Tab 导航地图”嵌套“Stack 导航地图”的方案，你可以先思考一下，这个方案有没有什么问题？</p><p>第一个问题是，它有两个“Stack 导航地图”，管理起来比较麻烦，我们声明页面之前需要考虑该页面应该在哪个 Tab 中打开。</p><p>第二个问题更严重，如果想从 Home 的 Page1 页面跳转到 Message 的 Page3 下面，用户必须点开过 Message 标签页，不然就会出现报错。因为在进入 Message 标签页之前，它下面的 Page3 、Page4 页面是没有初始化声明过的，直接跳过去会出现报错。</p><p>鉴于以上两个问题的存在，我推荐你使用 Stack 作为根导航，来嵌套其他 Tab 类型的导航。</p><p>我们要实现的简易电商 App 的架子，也就是两个顶部标签导航、一个底部标签导航和一个堆栈导航的 App，它的具体实现思路和最终实现的截屏，我都放在了下面。你对照着看下，理解一下它的实现思路：</p><pre><code class=\"language-plain\">- App(\"Stack 导航地图\")\n  - BottomTabHome(\"Bottom Tab 导航地图\")\n      - TopTabHome(\"Top Tab 导航地图\")\n          - 关注\n          - TopTabDiscover(\"Top Tab 导航地图\")\n              - 推荐\n              - 猫猫\n              - 狗狗\n      - 附近\n  - 消息\n  - 我\n- Page1\n- Page2\n- PageN...\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/4f/d9/4f4906ed4f9eabea6264f184911796d9.png?wh=1920x1417\" alt=\"图片\"></p><h2>附加材料</h2><p>最终的代码有点长，我就不贴出来了，你可以在 GitHub 上查到。</p><ul>\n<li>最新资料以 <a href=\"https://reactnavigation.org/\">React Navigation 官网</a>的 V6 版本为准，它的中文网的示例有点老，我就不推荐了。</li>\n<li>React Navigator 也提供了 10+ 个<a href=\"https://github.com/react-navigation/react-navigation/tree/main/example\">官方 Demo</a>，你也可以参考着学一下。</li>\n<li>本文的示例代码见 <a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/18_Navigation\">GitHub</a>。</li>\n</ul><h2>总结</h2><p>今天这一讲，我们介绍了搭建 React Native App 必备的工具 React Navigator。</p><p>在 React Navigator 之中，最常用的导航是原生堆栈导航 Native Stack Navigator，通常情况下都是使用它作为最外层的导航，来包裹其他的底部标签导航和顶部标签导航，实现常见 App 的多标签导航效果。</p><p>用好 React Navigator 的关键是，<strong>理解它的两个配置项和导航路由对象</strong>。</p><p>在声明页面时，你可以通过配置的方式填写默认的自定义参数 params  和配置项 options。而在你进入页面后，可以通过导航对象 navigation 和路由对象 route 来控制页面。导航对象提供的主要功能有跳转回退、监听页面的生命周期和 setParams、setOptions 功能；路由对象上主要是页面名字 name、自定义参数 params。</p><h2>作业</h2><ol>\n<li>请你使用 Native Stack Navigator 实现一个通用的弹窗功能。该弹窗样式包括一个可自定义的标题和一个可自定义的按钮，它可以在任意页面中调用显示，且当用户点击按钮或半透明背景时，该弹窗整体消失。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/22/e2/22507dc46d5022d45148e015742db7e2.png?wh=1920x911\" alt=\"图片\"></p><ol start=\"2\">\n<li>React Navigation 目前已经更新到 v6 版本了，你在使用老版本的 React Navigation 时遇到过哪些问题呢？欢迎留言，我们大家一起讨论。</li>\n</ol>","neighbors":{"left":{"article_title":"17｜Gesture（下）：如何解决多视图多手势的冲突问题？","id":515347},"right":{"article_title":"19｜Redux：大型应用应该如何管理状态？","id":517172}}},{"article_id":517172,"article_title":"19｜Redux：大型应用应该如何管理状态？","article_content":"<p>你好，我是蒋宏伟。</p><p>今天这一讲，我要和你聊的是，如何使用 Redux 来管理复杂的、大型的应用状态。</p><p>有人认为，在 React 出了 hooks 之后，官方提供的 useReducer 和 useContext 的组合，已近似能够代替 Redux 了，所以，现在是时候抛弃 Redux，直接用 useReducer 和 useContext 对大型应用进行状态管理了。</p><p>也有人认为，虽然 Redux 解决了状态管理的问题，但是 Redux 模板代码太多，应该抛弃 Redux，改用 Mobx 或 Zustand 这类写起来更简单的工具。</p><p>但我认为，从目前来看，Redux 依旧是我们开发大型项目时，应该最优先考虑的状态管理工具。为什么呢？</p><p>一方面，大型项目的状态管理复杂度很高，useContext 并不是状态管理工具，它只是一个提供了跨层级传递状态的工具而已。真要拿 useReducer 和 useContext 来写大型项目，你需要写更多的模板代码，而且更难维护。</p><p>另一方面，开发大型项目需要考虑团队成员的协作成本，目前来看，无论是 <a href=\"https://www.npmtrends.com/mobx-vs-redux-vs-zustand\">npm trends 上的下载量</a>，还是我对 React Native 开发者的<a href=\"https://segmentfault.com/a/1190000041324009\">调研报告</a>都显示，Redux 的流行程度远超于其他状态管理工具。团队招一个新人，新人熟悉 Redux 概率远比熟悉 Mobx、Zustand 的概率更高，学习成本、协作成本也是最低的。</p><!-- [[[read_end]]] --><p>至于以前被大家吐槽最多的，Redux 模板代码多的问题，现在也可以使用 Redux Toolkit 来解决一部分了。Redux 官方是这么说的：</p><blockquote>\n<p>We want <em>all</em> Redux users to write their Redux code with Redux Toolkit, because it simplifies your code <em>and</em> eliminates many common Redux mistakes and bugs!<br>\n我们希望所有的 Redux 开发者都能用 Redux Toolkit 来写代码，因为它能简化代码，减少 BUG 和消除常见的对 Redux 的误解。</p>\n</blockquote><p>所以，今天这节课，我们就一起探究 Redux/Redux Toolkit 到底何时用、怎么用。</p><h2>Redux 什么时候用？</h2><p>首先，我们需要明确的是：一个应用的状态管理要复杂到什么程度才需要引入 Redux？一个最好的判断标准是，<strong>当你觉得状态管理是你研发痛点的时候，你才需要开始着手解决</strong>。</p><p>举个例子，在一个大型项目中，我们经常遇到的问题就是，全局状态管理的问题，示意图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/4f/d4fe606ec6fb8891dbafe1f0aee94f4f.gif?wh=550x475\" alt=\"图片\"></p><p>这张图来自 <a href=\"https://medium.com/dailyjs/when-do-i-know-im-ready-for-redux-f34da253c85f\">《When do I know I’m ready for Redux？》</a>，图中描述的就是一个全局状态更新的难题。在一个 App 中，它有一个全局状态被多个组件使用了，因此它将该全局状态放在了 Root 组件中。当其中一个组件，触发了该全局的状态更新操作后，Root 的新状态会逐层传递到整个应用上。</p><p>虽然将全局状态挂在 Root 组件上，并通过将状态和状态更新函数逐层传递到各个组件上，能解决跨组件更新的难题。但是这个方案却带来了性能损耗和维护成本高等问题。</p><p>所以当你在使用 useState、useReducer 管理状态时，如果会遇到性能问题和维护性问题时，你就可以考虑使用 Redux 了。</p><p>你看，Redux 通过 Store 存储了全局状态，它不仅解决了状态需要逐层传递的问题，还避免了整个应用的 re-render，不容易出现相关的性能问题。</p><p>这时候，我们再来看什么时候需要 Redux，什么时候不需要 Redux 这个问题，相信你已经有了答案。</p><p>当你有大量的全局状态需要管理时，当应用状态频繁更新遇到性能瓶颈时，当管理状态的逻辑复杂到需要代码分治时，当多人协作开发需要遵守同一套最佳实践时，就是你考虑使用 Redux 的时候了。</p><h2>Redux 的工作原理</h2><p>没有接触过 Redux 的同学可能会问，“听说 Redux 特别复杂，我以前没有学过，能用一句话介绍一下 Redux 的工作原理吗？”</p><p>Redux 的核心原理，我们用一句话概括就是：<strong>State 驱动 View 更新，用户操作 View 触发 Action ，再通过 Action 来更新 State。</strong></p><p>如何理解这句话中的 State、View 和 Action 呢？</p><p>我用一个最简单的计数组件来给你举例子，示例代码如下：</p><pre><code class=\"language-plain\">function Counter() {\n  // State 状态\n  const [counter, setCounter] = useState(0)\n\n  // “Action ” 指令\n  const increment = () =&gt; {\n    setCounter(prevCounter =&gt; prevCounter + 1)\n  }\n\n  // View 视图\n  return (\n    &lt;View&gt;\n        &lt;Text&gt;Value: {counter} &lt;/Text&gt;\n        &lt;Text onPress={increment}&gt;+1&lt;/Text&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre><p><strong>使用 useState 管理应用状态时，有三个部分：State、View 和所谓的  “Action”。</strong>State、View 部分你已经非常熟悉了，State 是状态，View 是 JSX 创建的视图，但所谓的 \"Action \" 是什么呢？</p><p>“Action”并不难理解，在计数应用中，increment 函数可以理解为“函数形式的”状态更新指令。increment  函数内部调用的是状态更新函数 setCounter，用于更新视图 View。</p><p><strong>使用 Redux 管理应用状态时，也有三部分：State、View 和 Action。</strong> State 是状态，View 是视图，Action 是更新指令。</p><p>不同的是，useState 管理的是组件状态，Redux 管理的是全局状态。</p><p><strong>在 Redux 中，State 是一个存储在全局中的对象，用于描述整个应用的状态：</strong></p><pre><code class=\"language-plain\">{\n    counter: 0\n}\n</code></pre><p>是的，没错。Redux 状态只是一个普通对象。如果你用 Redux 来实现计数应用，那么它的状态就是 counter，状态的默认值是 0。</p><p>Redux 的全局状态可以只有一个，也可以有多个，状态的值既可以是原始数据类型 number、string 等，也可以是更复杂的 object、array 数据类型。</p><p>我们再来看一个 Todo 应用的状态例子，它就有两个状态，并且状态的数据类型也更复杂：</p><pre><code class=\"language-json\">{\n  todos: [{\n    text: 'Eat food',\n    completed: true\n  }, {\n    text: 'Exercise',\n    completed: false\n  }],\n  visibilityFilter: 'SHOW_COMPLETED'\n}\n</code></pre><p>Todo 应用的两个全局状态分别是todos 和 visibilityFilter。todos 状态是 array 嵌套 object 的复合数据类型，而 visibilityFilter 是 string 的基本数据类型。</p><p>Redux 中的 View 也就是 JSX 视图，我就不给你举例了。接着我们再来了解 Redux 中 Action 究竟是什么。</p><p><strong>在 Redux 中，Action 是一个包含 type 字段的对象，用来描述“发生了什么事情”。</strong>我们以计数应用状态的 Action 为例：</p><pre><code class=\"language-plain\">{ type: 'COUNT_INCREMENT'}\n</code></pre><p>这里，计数应用 “+1” 的操作，被抽象成了一个 type 等于 COUNT_INCREMENT 的字符串指令。</p><p>但如果是一个更复杂的 Todo 应用，Todo 应用就要增加一个待办事项。待办事项的内容是用户输入的，这要怎么实现呢？Redux 是如何知道用户输入是 “10点买菜” ，还是 “12点做饭” 的待办事项呢？</p><p>这就需要一个另外的字段来承载待办事项的信息了，一个 TODO 应用的 Action 示例如下：</p><pre><code class=\"language-plain\">{ type: 'ADD_TODO', text: '10点买菜' }\n{ type: 'ADD_TODO', text: '12点做饭' }\n{ type: 'TOGGLE_TODO', index: 1 }\n</code></pre><p>你看，这个示例中有 3 个 Action ，前两个 Action 的 type 是 ADD_TODO，就是增加待办事项，text 是你自定义的参数名，其内容分别是用户输入的内容“10点买菜”和“12点做饭”。第三个 Action 就是标记待办事项是否完成的 Action，它的 type 是 TOGGLE_TODO，它的自定义参数名是 index，自定义参数值是数字 1。</p><p>像 text、index 这样字段，开发者可以自己定义。但有一些工具，比如后面要介绍的 Redux Toolkit，会统一将其定义为 payload 字段，省去了字段名不确定的麻烦事。</p><p>那当 Redux 收到 Action 通知后，如何更新全局状态呢？这就要用到 Reducer 了。</p><p><strong>Reducer 就是一个普通的状态更新函数。Redux 会将当前应用的状态 State 和指令 Action 作为参数，传给 Reducer 函数，并接收一个 Reducer 返回的 newState 作为新全局状态。</strong>函数示意如下：</p><pre><code class=\"language-plain\">const reducer = (state, action ) =&gt; newState\n</code></pre><p>在一个简单的计数应用中，Reducer 可以这样写：</p><pre><code class=\"language-plain\">function increment(state = 0, action) {\n    return state+1\n}\n\nfunction counterApp(state = {}, action) {\n  return {\n    counter: increment(state.counter, action),\n  }\n}\n</code></pre><p>在上述代码中，counterApp 就是 Redux <strong>管理所有全局状态的函数</strong>，increment 函数就是你<strong>处理分片状态的 Reducer 函数</strong>。counterApp 函数接收当前状态 state 和发出的指令 action 作为参数，并且将这些参数传给 increment，由 increment 更新函数来更新状态。</p><p>看到这儿，你可能会想，为什么Redux 处理状态时，既要有管理所有全局状态的函数。又有处理分片状态的 Reducer 函数，搞这么麻烦干嘛，直接用一个函数来处理不行吗？</p><p>不行，因为在大型应用中，用一个函数处理不过来。我们来看一个较为复杂的 TODO 应用的示例，你就明白了：</p><pre><code class=\"language-plain\">function filter(state = 'SHOW_ALL', action) {\n  if (action.type === 'SET_VISIBILITY_FILTER') {\n    return action.filter\n  } else {\n    return state\n  }\n}\n\nfunction todos(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return state.concat([{ text: action.text, completed: false }])\n    case 'TOGGLE_TODO':\n      return state.map((todo, index) =&gt;\n        action.index === index\n          ? { text: todo.text, completed: !todo.completed }\n          : todo\n      )\n    default:\n      return state\n  }\n}\n\nfunction todoApp(state = {}, action) {\n  return {\n    todosState: todos(state.todos, action),\n    filterState: filter(state.visibilityFilter, action)\n  }\n}\n</code></pre><p>这部分代码，包含三个函数，其中 todoApp 是 Redux <strong>管理所有全局状态的函数</strong>，它管理了 todosState 和 filterState 两个全局状态。另外两个<strong>处理分片状态的 Reducer 函数</strong> filter、todos 分别处理了 todosState  和 filterState 全局状态的操作逻辑。</p><p>你看，在计数应用中全局状态只有一个，用一个函数来管理所有全局状态，用另一个 reduer 来管理分片状态，显得有点多余。但是在 TodoApp 中，有两个状态，而且它的状态处理逻辑比较复杂。</p><p>一个应用越复杂，管理状态的逻辑也就越复杂，代码量可不止几行、十几行，上百行、上千行也是可能的，用一个函数来处理所有状态是不现实的。所以我们既需要一个管理所有全局状态的函数，又需要若干个能够处理分片状态的 Reducer 函数。</p><p>这就是 Redux 既有管理所有全局状态的函数，又有处理不同分片状态的 Reducer 函数的原因。</p><p>完整的流程是，<strong>在初始化时，Redux 通过 Reducer 来初始化 State，State 驱动 View 渲染。在更新状态时，用户操作 View  触发 Action，Action 和当前 State 会被分发给处理分片状态的 Reducer 函数，由 Reducer 函数来执行更新逻辑和返回新的 State，并最终刷新 View。</strong>这些就是 Redux 的核心原理。</p><h2>Redux 的最佳实践</h2><p>在了解完 Redux 的核心原理后，我们再学习 Redux 的最佳实践，就会轻松很多。</p><p>目前，Redux 社区和官方团队，经历多年的探索，慢慢摸索了一套最佳实践，并且把这套最佳实践封装到了 Redux Toolkit 工具集中。使用 Redux Toolkit 这套最佳实践，不仅能够避免常见的 Redux 使用误区，还能少写很多代码。</p><p>比如，在使用 <a href=\"https://redux-toolkit.js.org/\">Redux Toolkit</a> 之后，Redux 官方提供的 Todo App 的代码中的 todosSlice.js 文件的代码行数，就由 <a href=\"https://github.com/reduxjs/redux-fundamentals-example-app/blob/897f4e1efe124c939239e7d9e7a16bef3c42897c/src/features/todos/todosSlice.js\">196 行</a>减少到 <a href=\"https://github.com/reduxjs/redux-fundamentals-example-app/blob/3ac8804e3d16ddf50cf35d87ded6c10e49c56d44/src/features/todos/todosSlice.js\">131 行</a>，代码量减少了 33%。</p><p>Redux Toolkit 的本质是提供了一些<strong>工具函数</strong>，简化纯手写 Redux 代码的冗余逻辑，其中最重要的两个工具函数是：</p><ul>\n<li>configureStore：管理所有全局状态的函数，它的返回值是一个 Store 对象；</li>\n<li>createSlice：管理分片全局状态的函数，其返回值是一个分片对象，该对象上最重要的两个属性是：\n<ul>\n<li>actions：创建分片 action 的函数集合；</li>\n<li>reducer：已经创建好的分片 reducer。</li>\n</ul>\n</li>\n</ul><p>另外，Redux 还有一个专门的 <a href=\"https://react-redux.js.org/api/hooks\">React Redux 库</a> ，这个库主要为 React/React Native 应用提供了 1 个组件和 2 个常用的钩子函数：</p><ul>\n<li>Provider：Provider 是一个组件，该组件接收存储所有全局状态的 Store 对象作为参数。Provider 组件底层用的是 useContext，它为整个应用的其他组件提供获取 Store 对象的能力；</li>\n<li>useSelector：从 Store 中获取当前组件需要用到的状态；</li>\n<li>useDispatch：用于发送指令的钩子函数，其返回值是 dispatch 函数，而 dispatch 函数的入参是 action。</li>\n</ul><p><strong>目前，使用 Redux 开发 React Native 应用的最佳实践，就是同时使用 Redux Toolkit 和 React Redux，实现全局状态管理。</strong></p><p>接下来，我们还是以计数应用和 Todo 应用为例，学习如何使用 Redux Toolkit 和 React Redux。</p><p>首先，我们要引入相关的工具函数，示例代码如下：</p><pre><code class=\"language-plain\">import {configureStore, createSlice } from '@reduxjs/toolkit';\nimport {Provider, useSelector, useDispatch } from 'react-redux';\n</code></pre><p>这里，我们分别从 ‘@reduxjs/toolkit’ 和 ‘react-redux’ 中引入了configureStore、createSlice、Provider、useSelector、useDispatch。<br>\n那如何使用它们来管理应用状态呢？整个过程大致分为 5 步：</p><ol>\n<li>使用 Provider 组件向应用的其他组件提供获取 Store 的能力；</li>\n<li>使用 configureStore 函数创建 Store；</li>\n<li>使用 createSlice 函数创建分片；</li>\n<li>使用 useSelector 获取分片 State；</li>\n<li>使用 useDispatch 生成的 dispatch 来发送 action。</li>\n</ol><p><strong>首先我们来看如何使用 Provider 组件向其他组件提供获取 Store 的能力。</strong></p><p>一般而言，Provider 组件通常是最顶层的组件，它包裹住了整个应用。以计数应用为例，示例代码如下：</p><pre><code class=\"language-plain\">const store = ...\n\n// 计数应用\nfunction CounterApp(){}\n\n// 根组件\nexport default function Root() {\n  return (\n    &lt;Provider store={store}&gt;\n      &lt;CounterApp /&gt;\n    &lt;/Provider&gt;\n  );\n}\n\nAppRegistry.registerComponent('App', () =&gt; Root);\n</code></pre><p>你看，Root 是整个应用的根组件，这个组件使用了 Provider 包裹住代表计数应用的 CounterApp 组件，并且 Provider  接收了 store 作为参数，因此 CounterApp 组件及其所有的子组件都能从 store 中获取任意的全局状态。</p><p>那存储全局状态的对象 store 是如何创造的呢？<strong>这就到了第二步，创建 store 用到的函数是 configureStore。</strong></p><p>使用 configureStore 函数创建 store 的方法如下：</p><pre><code class=\"language-plain\">const counterSlice = ...\n\nconst store = configureStore({\n  reducer: {\n    counter: counterSlice.reducer,\n  }\n});\n\nconsole.log(store.getState()) // { counter }\n</code></pre><p>在这段代码中，我使用了 configureStore 函数来创建 store 对象。configureStore 函数的入参中最关键的对象属性是 reducer 属性。在计数应用中，configureStore 入参的 reducer 的结构是 { counter }，那么 configureStore 返回值 store 对象的结构也是  { counter }。</p><p>也就是说，计数应用存在一个全局状态 counter。</p><p>你也可以根据不同的情况，创建不同的 store 对象。比如 Todo 应用你可以这么创建：</p><pre><code class=\"language-plain\">const todosSlice  = ...\nconst filtersSlice = ...\n\nconst store = configureStore({\n  reducer: {\n    todosState: todosSlice.reducer,\n    filterState: filtersSlice.reducer,\n  },\n})\n\nconsole.log(store.getState()) // { todos, filters }\n</code></pre><p>在 Todo 应用中，configureStore 入参的 reducer 的结构是 { todos, filters }，那么 store 对象的结构也是 { todos, filters }，也就是说，Todo 应用存在两个全局状态，分别是 todos 和 filters。</p><p>在 Redux 中，分片 state 是通过分片 reducer 生成的。在计数应用中，分片是 counterSlice，分片状态 counter 是通过 counterSlice.reducer 创建的；在 Todo 应用中，分片是 todosSlice 和 filtersSlice，分片状态 todosState 和 filterState 是通过 todosSlice.reducer 和 filtersSlice.reducer 创建的。</p><p>因此，接下来你需要关注的是如何创建分片。那么如何创建分片呢？<strong>这就是第三步的任务，创建分片用到的函数是 createSlice。</strong></p><p>使用 createSlice 函数创建分片的示例代码如下：</p><pre><code class=\"language-plain\">const initialState = {\n  value: 0,\n};\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  reducers: {\n    increment: (state, action) =&gt; {\n      // 可以直接修改的“状态”\n      state.value += action.payload;\n    },\n  },\n});\n\nconsole.log(counterSlice.actions.increment(1)) \n// {\"payload\": 1, \"type\": \"counter/increment\"}\n\nconsole.log(counterSlice.reducer) \n/*\nfunction reducer(state, action) {\n  if (!_reducer) _reducer = buildReducer();\n  return _reducer(state, action);\n}\n*/\n</code></pre><p>创建分片需要三个参数：</p><ul>\n<li>name：分片的名字，字符串类型。示例中是 “counter” 字符串；</li>\n<li>initialState：分片的初始化状态。示例中是 { value: 0 } 的对象；</li>\n<li>reducers：对象类型，用于创建分片 action 和分片 reducer。</li>\n</ul><p><strong>createSlice 函数会自动生成分片 action creators 和分片 reducer，</strong> 并将这两个自动生成的值挂在其返回对象 counterSlice 的 actions 属性和 reducer 属性上。</p><p>那怎样验证createSlice 函数确实帮你创建了分片 action creators 和分片 reducer 呢？</p><p>你可以打印 counterSlice.actions.increment(1)来检验。actions.increment 是创建 increment action 的函数，打印的结果是  { “type”: “counter/increment”, “payload”: 1}。其中，“type” 字段是分片 action 的必传字段，“type” 的值由分片名字 “counter” 和 reducers 对象的键名 “increment” 共同组成。“payload” 字段是专门用于传参的字段，其参数来源于 actions.increment 创建函数的第一个入参，也就是数字 1。</p><p>你也可以打印 counterSlice.reducer，它内部是一个由 Redux 帮我们生成的 _reducer 函数。</p><p>在完成以上三步后，应用中的组件就能够使用分片 State 和分片 Action 来展示和改变 UI 视图了。</p><p><strong>那接着新的问题就来了：组件该如何获取和使用分片 State 和分片 Action 呢？</strong></p><p>这就是最后第四步和第五步的任务，这两步都是在具体组件中进行的，我们放在一起看就好，组件的示例代码如下：</p><pre><code class=\"language-plain\">function CounterApp() {\n  const counter = useSelector((state) =&gt; state.counter.value);\n\n  const dispatch = useDispatch();\n\n  const handlePress = () =&gt; {\n    dispatch(counterSlice.actions.increment(10));\n  };\n\n  return (\n      &lt;View style={styles.box}&gt;\n        &lt;Text&gt;{counter}&lt;/Text&gt;\n        &lt;Text onPress={handlePress}&gt;+10&lt;/Text&gt;\n      &lt;/View&gt;\n  );\n}\n</code></pre><p>在 CounterApp 组件中，我们首先使用 useSelector 获取状态，然后再使用 useDispatch 获取 dispatch 函数，并且在对应时机调用 dispatch(action) 发送指令。</p><p>其中，<strong>useSelector 的主要作用是按需获取状态。</strong>虽然，你也可以直接使用 store.getState() 获取所有状态，但获取所有全局状态会有一个弊端，那就是只要任何一个全局状态发生了改变，该组件就会 re-render，这容易导致应用性能变差。因此，你需要 useSelector 帮你从 store 中按需获取状态。</p><p>useSelector 的入参是一个函数，你可以通过这个函数从所有 state 中选择该组件中用到的 state。在这个计数组件中，只用到了 state.counter.value，因此这个函数只用返回 state.counter.value 作为状态就可以了。</p><p>因此，在上述计数应用的初始化时，默认的计数值是 0，每当你点击一次 “+10” 按钮时，就会触发 action 指令，将计数值 “+10”。</p><p>我把完整的代码放在了这里，你可以仔细看下：</p><pre><code class=\"language-plain\">import React  from 'react';\nimport {View, Text, StyleSheet} from 'react-native';\nimport {\n  useSelector,\n  useDispatch,\n  Provider,\n  TypedUseSelectorHook,\n} from 'react-redux';\nimport {configureStore, createSlice, PayloadAction} from '@reduxjs/toolkit';\n\ninterface CounterState {\n  value: number;\n}\n\nconst initialState: CounterState = {\n  value: 0,\n};\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  // Reducer\n  reducers: {\n    increment: (state, action) =&gt; {\n      state.value += action.payload;\n    },\n  },\n});\n\n// Store\nconst store = configureStore({\n  reducer: {\n    counter: counterSlice.reducer,\n  },\n});\n\nfunction CounterApp() {\n  // State\n  const counter = useSelector((state) =&gt; state.counter.value);\n\n  const dispatch = useDispatch();\n\n  // Event Hanlder\n  const handlePress = () =&gt; {\n    // Action\n    const action = counterSlice.actions.increment(10);\n    // dispatch\n    dispatch(action);\n  };\n\n  // View/UI\n  return (\n      &lt;View &gt;\n        &lt;Text&gt;{counter}&lt;/Text&gt;\n        {/* click event: deposit */}\n        &lt;Text onPress={handlePress}&gt;+10&lt;/Text&gt;\n      &lt;/View&gt;\n  );\n}\n\nexport default function Root() {\n  return (\n    &lt;Provider store={store}&gt;\n      &lt;CounterApp /&gt;\n    &lt;/Provider&gt;\n  );\n}\n</code></pre><p>在这段完整代码中，我帮你把 Redux 中的关键概念都标记出来了。Redux 中的概念比较多，包括 Store、Reducer、State、UI、Event Handle、Dispatch、Action。在看计数应用的实现代码的同时，你也可以结合 Redux 官方提供的原理图，把使用 Redux 的最佳实现和原理结合在一起理解：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c9/c4/c98922b5a476e12b853576324f12f5c4.gif?wh=1440x1080\" alt=\"图片\"></p><h2>附加材料</h2><ul>\n<li>三个官网：<a href=\"https://redux.js.org/\">Redux</a>、<a href=\"https://redux-toolkit.js.org/\">Redux Toolkit</a>、<a href=\"https://react-redux.js.org/\">React Redux</a>。</li>\n<li>这一讲提供的是简版的最佳实践，官网完整的最佳实践见 <a href=\"https://redux.js.org/style-guide/\">《Redux Style Guide》</a>。</li>\n<li>简版最佳实现的计数应用 <a href=\"https://github.com/jiangleo/react-native-classroom/blob/main/src/19_Redux/03_ToolkitCounter/index.tsx\">Demo</a>。</li>\n<li>完整最佳实践的计数应用 <a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/19_Redux/04_CounterApp\">Demo</a>。</li>\n<li>完整最佳实践的 Todo 应用 <a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/19_Redux/05_TodoApp\">Demo</a>。</li>\n</ul><h2>总结</h2><p>这一讲，我和你介绍了三个重点，分别是 Redux 什么时候用、Redux 的工作原理和 Redux 的最佳实践。</p><p>不过，Redux 并不是万能药，它只适合复杂或大型应用的全局状态管理，在简单或小型应用中使用 Redux，就像大炮打苍蝇大材小用。</p><p>虽然使用 Redux 来管理状态需要 5 个步骤，比使用 useState 的  3 个步骤多了两个步骤。但使用 Redux 来管理全局状态有很多好处，比如它能提高你应用的可测试性和可维护性，而这些特性正是复杂项目、大型项目所需要的。</p><p>但对于一个大型项目而言，Redux 并不是唯一状态管理方案，通常我还会将 Redux 和 useState、ReactQuery 搭配起来使用。我更喜欢使用 useState 来管理组件状态，使用 Redux 来管理全局状态，使用 ReactQuery 来管理异步状态。</p><h2>作业</h2><p>React/React Native 生态中，状态管理工具可谓是百家争鸣，那你选择的方案是什么呢？欢迎在评论区和我分享你的答案。我们下一讲见。</p>","neighbors":{"left":{"article_title":"18｜Navigation：页面之间怎么跳转？","id":516300},"right":{"article_title":"20｜Sentry：线上错误与性能监控怎么处理？","id":518009}}},{"article_id":518009,"article_title":"20｜Sentry：线上错误与性能监控怎么处理？","article_content":"<p>你好，我是蒋宏伟。</p><p>今天这一讲是我们社区生态篇的最后一讲，我们来聊聊 App 上线之后，如果遇到线上异常，或者是线上性能问题应该怎么处理。</p><p>这是我们每个人都会遇到的问题。即便我们的代码在本地测试时没有问题，也有各种上线流程的保障，但由于线上环境的复杂性，也难免遇到各种奇奇怪怪的线上 Bug。我们既然不能完全避免线上 Bug，那么就需要尽可能地减少线上 Bug 对用户的影响，这就要用到线上监控系统了。</p><p>我曾经遇到过好几次老板甩来的 Bug，那时候我开发的 React Native 应用也没有接入线上监控，遇到问题只能绞尽脑汁在本地复现和解决。经历过那几次痛苦的 Debug 后，我就打算搞个 React Native 监控系统，从 2020 年开始至今，我一直在参与 58 大前端监控系统的设计和研发，其中 React Native 的监控也是由我负责的。</p><p>但是，从头搭建和迭代一个监控系统的成本非常高。如果你有线上错误和性能的监控需求，但公司内部没有现成的监控系统，那我的建议是直接用 Sentry。Sentry 提供了一个<a href=\"https://try.sentry-demo.com/organizations/massive-stallion/projects/\">演示 Demo</a>，你可以直接打开看看它具体都有哪些功能。</p><p>而且 Sentry 的代码是开源的，它既支持你自己搭建，也支持付费直接使用。</p><p>如果想自己搭建的话，Sentry 后端服务是基于 Python 和 ClickHouse 创建的，需要自己使用物理机进行搭建，我们的兄弟团队，<a href=\"https://juejin.cn/post/6844904088866390024\">转转团队</a>就是这么做的。如果想付费使用的话，可以参考 <a href=\"https://docs.sentry.io/\">Sentry 官方文档</a>先试用一下，如果老板也觉得不错，愿意付费使用，那就省去了自己搭建和维护 Python 服务的麻烦事了。</p><!-- [[[read_end]]] --><p>我也参考了 Sentry 官方文档，把我放在 Github 的实战课 Demo 也接入试用了一下，发现 Sentry 的接入过程很简单，文档也非常详细。如果你有接入需求，可以看看 <a href=\"https://docs.sentry.io/platforms/react-native/\">Sentry 的接入文档</a>。</p><p>因此这一讲，我不会和你介绍 Sentry 接入和使用方法，我想深入 Sentry 的底层和你聊聊实现线上错误和性能监控的原理。</p><p>这样，无论是你打算直接使用 Sentry ，还是打算自研线上监控，都能有所收获。</p><h2>基本信息的收集</h2><p>首先，我们要明确的是，解决线上问题和解决本地问题的思路是不一样的。</p><p>在解决本地问题时，你不仅可以不断修改代码，反复尝试寻找解决方案，你还可以使用调试工具，比如 Flipper，它有打日志、打断点、查看性能火焰图等功能。然而在解决线上问题时，我们并不能反复尝试和使用调试工具。</p><p>你能借助的只有类似 Sentry 这样的线上监控工具。这些线上监控工具帮你记录了用户是谁，用户又是在什么情况下，出现了什么问题。你有了这些线上信息之后，才能确定问题的影响范围和紧急程度，也能更方便修复线上问题。</p><p>如果我们深入 Sentry 线上监控 SDK 的底层原理，你会发现它主要收集了三类线上数据：</p><ul>\n<li>用户是谁；</li>\n<li>用户报错；</li>\n<li>用户性能。</li>\n</ul><p><strong>而深入学习原理的最好方式就是自己写一个简易版本。</strong>所以接下来，我们要先一起实现一个简易监控 SDK，把这些信息都收集上去，这样你就能够明白 Sentry 线上监控 SDK 的底层原理了。</p><p>当然，以上信息的收集必须遵守网信办的 <a href=\"http://www.cac.gov.cn/2021-11/14/c_1638501991577898.htm\">《网络数据安全管理条例（征求意见稿）》</a>，像设备唯一标示 IMEI、用户地理位置、运营商编号这些信息，我们是不能收集的。</p><p>你可能会问，不能收集设备唯一标示 IMEI，那我们怎么知道用户是谁啊？替代 IMEI 方案就是 <strong>UUID</strong>。</p><p>UUID 的全称是 Universally Unique Identifier，翻译过来就是通用唯一识别码，它是通过一个随机算法生成的 128 位的标识。生成两个重复 UUID 概率接近零，可以忽略不计，因此我们可以使用 UUID 代替与用户设备绑定的 IMEI 作为唯一标示符，该方法也是业内的通用方案之一。</p><p>在这一讲要实现的简易监控 SDK 中，你可以使用 UUID 算法配合 AsyncStorage 或 MMKV 生成一个用户 ID，具体实现方法如下：</p><pre><code class=\"language-plain\">import uuid from 'react-native-uuid';\nimport { MMKV } from 'react-native-mmkv'\n\n// 用户唯一标示\nlet userId = ''\n\nconst storage = new MMKV()\nconst hasUserId = storage.contains('userId')\n\n// 用户曾经打开过 App\nif(hasUserId) {\n  userId = storage.get('userId')\n} else {\n  // 用户第一次打开 App\n  userId = uuid.v4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'\n    storage.set('userId', userId)\n}\n</code></pre><p>如上代码中的 react-native-uuid 是 UUID 算法的 React Native 版本。react-native-mmkv 是持久化键值存储工具，MMKV 的性能比 AsyncStorage 更好，所以我这里就用它代替了 AsyncStorage。</p><p>生成用户唯一标示 userId 的思路是这样的。每次开打 App 时，先使用 storage.contains(‘userId’) ，判断一下在 MMKV  持久化键值存储中心是否存在 userId。如果 userId 的键值对不存在，那么该用户是第一次打开 App，这时使用 uuid.v4 算法生成一个 uuid 作为用户的唯一标示，并使用 userId 作为键名，调用 storage.get 方法将该键值对存在 MMKV 中。</p><p>如果存在 userId 的键值对，那么该用户是就不是第一次打开 App 了，这时直接使用 userId 这个键名，将第一次打开 App 生成的用户唯一标示，从 MMKV 中读出来就可以了。</p><p>有了 userId 这个用户唯一标示后，后台分析收集上来的线上信息时，就可以把线上报错、性能等信息和某个具体的用户挂上钩了，比如你可以通过对 userId 字段进行去重，来确定它影响了多少用户。</p><p>那么，有了 userId 就算解决了“用户是谁”这个问题了吗？</p><p>还不够，光有 userId，用户画像还是不够清晰，你还得知道他设备信息，这样用户画像才更立体。在 React Native 中，你可以通过 react-native-device-info 来获取设备信息，示例代码如下：</p><pre><code class=\"language-plain\">import DeviceInfo from 'react-native-device-info';\n\n// API 提供了获取的能力，但根据 《网络数据安全管理条例（征求意见稿）》 是不能上报的，所以推荐使用 uuid 代替。\n\nconst androidIdPromise = DeviceInfo.getAndroidId()\n\n// 将设备信息收集到一个 deviceInfo 对象中，统一上报。\nconst deviceInfo = {}\ndeviceInfo.systemName = DeviceInfo.getSystemName(); // iOS: \"iOS\" Android: \"Android\"\ndeviceInfo.systemVersion = DeviceInfo.getSystemVersion(); // iOS: \"11.0\" Android: \"7.1.1\"\ndeviceInfo.brand = getBrand(); // iOS: \"Apple\" Android: \"xiaomi\"\ndeviceInfo.appName = DeviceInfo.getApplicationName(); // AwesomeApp\ndeviceInfo.appVersion = DeviceInfo.getVersion(); // iOS: \"1.0\" Android: \"1.0\"\n</code></pre><p>在这个示例中，我使用了 react-native-device-info 库来获取设备信息，包括系统名字 systemName、系统版本 systemVersion、手机品牌 brand、应用名字 appName、应用版本 appVersion，并将它们放到了 deviceInfo 对象上，方便统一上报。</p><p>有了这些设备信息后，你定位特定机型、特定版本的问题就会容易很多。</p><h2>普通 JavaScript 报错的收集</h2><p>在回答完“用户是谁”这个问题后，下一个要回答的问题是“用户报了什么错”。用户应用报错了，报错信息我们是直接看不到的，要通过监控 SDK 收集上来才能看到。</p><p>那监控 SDK 如何收集这些报错信息呢？主要有三种方案：</p><ul>\n<li>ErrorUtils.setGlobalHandler；</li>\n<li>PromiseRejectionTracking；</li>\n<li>Error Boundaries。</li>\n</ul><p>我们先来看 ErrorUtils.setGlobalHandler，它是用来处理 JavaScript 的全局异常的。如果某个 JavaScript 函数报错，并且该报错没有被捕获，该报错就会抛到全局中，示例代码如下：</p><pre><code class=\"language-plain\">function throwError(errorName){\n    thow new Error(errorName)\n}\n\n// 1.被捕获的错误\ntry {\n    throwError('该错误会被 try catch 捕获')\n} catch(){}\n\n// 2.未被捕获的错误\nthrowError('该错误没有捕获，会抛到全局')\n</code></pre><p>在这个示例中，第一个错误是被 try catch 捕获的错误，由于开发者已经对错误进行了处理，错误就不会再往外抛了，本地调试时也不会有红屏。第二个错误，开发者并没有 try catch 处理，该错误就会一层层往外抛，最终抛向全局作用域。</p><p>本地调试时，如果一个报错抛到了全局作用域，就会出现红屏。</p><p>本地调试的红屏其实是，React Native 框架在内部使用 ErrorUtils.setGlobalHandler 捕获到全局错误后，调用 LogBox 显示的红屏。红屏报错逻辑涉及框架源码的两个文件，分别是 <a href=\"https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/Core/setUpErrorHandling.js#L32\">setUpErrorHandling.js</a> 和 <a href=\"https://github.com/facebook/react-native/blob/b633cc130533f0731b2577123282c4530e4f0abe/Libraries/Core/ExceptionsManager.js#L98-L103\">ExceptionsManager.js</a>，我省去了其中的处理细节，关键示例代码如下：</p><pre><code class=\"language-plain\">ErrorUtils.setGlobalHandler( (error: Error, isFatal?: boolean) =&gt; {\n  if (__DEV__) {\n    const LogBox = require('../LogBox/LogBox');\n    LogBox.addException({\n        message: error.message,\n        name: error.name,\n        componentStack: error.componentStack,\n        stack: error.stack,\n        isFatal\n    });\n  }\n});\n</code></pre><p>从这段代码可以看出，没有被 try catch 住的报错，会触发 setGlobalHandler 的回调，在该回调中会判断，如果是 DEV 环境，那么就用 LogBox 组件把报错的 message、name、componentStack、stack、isFatal 等信息展示出来，这样一来就可以在本地报错时，看到红屏的报错信息了。</p><p>看到这儿，你可能会问：既然React Native 框架在本地调试时使用的是 ErrorUtils.setGlobalHandler，那么是否可以把这段逻辑<s>改</s>改用于线上错误监控呢？</p><p>这条思路很好。沿着这条思路想下去，我们有两个方案可以实现线上全局错误信息的上报，一种是使用  <a href=\"https://github.com/ds300/patch-package\">patch-package</a>  修改 React Native 源码，另一种使用 ErrorUtils.setGlobalHandler 重写回调函数。显然，重写回调函数比直接修改源码侵入性更小，更利于后续维护，因此我选择了重写回调函数的方式，重写回调函数的示例代码如下：</p><pre><code class=\"language-plain\">const defaultHandler =  ErrorUtils.getGlobalHandler &amp;&amp; ErrorUtils.getGlobalHandler();\n\nErrorUtils.setGlobalHandler( (error: Error, isFatal?: boolean) =&gt; {\n    console.log(\n      `Global Error Handled: ${JSON.stringify(\n          {\n            isFatal,\n            errorName: error.name,\n            errorMessage: error.message,\n            componentStack: error.componentStack,\n            errorStack: error.stack,\n          },\n          null,\n          2,\n      )}`,\n    );\n\n    defaultHandler(error, isFatal);\n});\n</code></pre><p>在这段代码中，React Native 框架的代码会比我的代码先执行，所以它会先调用一次 ErrorUtils.setGlobalHandler 设置回调函数，而我的代码会在 React Native 框架代码执行之后再执行，并通过 ErrorUtils.getGlobalHandler 获取 React Native 框架设置的回调函数 defaultHandler ，也就是在上个示例中演示的红屏报错的函数代码。</p><p>接着，我再次调用 ErrorUtils.setGlobalHandler 重新设置回调函数。在重置的回调函数中，我可以先处理自己的错误上报逻辑，这里用的是 console.log 代替的，然后再调用 React Native 框架的 defaultHandler 处理红屏报错。</p><h2>Promise 报错的收集</h2><p>以上是普通 JavaScript 报错的处理逻辑，但 Promise 报错的逻辑不一样。普通 JavaScript 错误，可以使用 try catch 捕获，但 promise 错误， try catch 是捕获不到的，需要用 promise.catch 来捕获。因此，二者全局的捕获机制也不一样。</p><p>React Native 提供了两种 Promise 捕获机制，一种是由新架构的 Hermes 引擎提供的捕获机制，另一种是老架构非 Hermes 引擎提供的捕获机制。这两种捕获机制，你都可以在 React Native 源码中找到，它涉及 <a href=\"https://github.com/facebook/react-native/blob/35800962c16a33eb8e9ff1adfd428cf00bb670d3/Libraries/Core/polyfillPromise.js#L29-L36\">polyfillPromise.js</a>、<a href=\"https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/Promise.js#L18-L22\">Promise.js</a> 、<a href=\"https://github.com/facebook/react-native/blob/8bd3edec88148d0ab1f225d2119435681fbbba33/Libraries/promiseRejectionTrackingOptions.js\">promiseRejectionTrackingOptions.js</a> 三个文件，我把其中关键代码摘出来了：</p><pre><code class=\"language-plain\">const defualtRejectionTrackingOptions = {\n  allRejections: true,\n  onUnhandled: (id: string, error: Error) =&gt; {},\n  onHandled : (id: string) =&gt; {}\n}\n\nif (global?.HermesInternal?.hasPromise?.()) {\n  if (__DEV__) {\n    global.HermesInternal?.enablePromiseRejectionTracker?.(\n      defualtRejectionTrackingOptions,\n    );\n  }\n} else {\n  if (__DEV__) {\n    require('promise/setimmediate/rejection-tracking').enable(\n      defualtRejectionTrackingOptions,\n    );\n  }\n}\n</code></pre><p>在上面这个示例中，我们先声明了一个配置项  defualtRejectionTrackingOptions。这个配置项中最重要的就是 onUnhandled 回调函数，该回调函数是专门用来处理未被 catch 的 Promise 错误的。</p><p>接着我们再通过 HermesInternal.hasPromise 判断该 React Native 应用是否用的是 Hermes 引擎，如果返回 true 则为 Hermes 引擎，否则为其他引擎。如果是 Hermes 引擎，我们就使用 Hermes 引擎提供的 <a href=\"https://github.com/facebook/hermes/blob/dc73202f8ac30f11191e44c47c68f6b89509937d/lib/VM/JSLib/HermesInternal.cpp#L803-L817\">enablePromiseRejectionTracker</a> 方法来捕获未被 catch 的 Promise 错误，如果不是 Hermes 引擎，则使用<a href=\"https://www.npmjs.com/package/promise\">第三方 promise 库</a>中 rejection-tracking 文件暴露的 enable 方法来捕获未被 catch 的 Promise 错误。</p><p>以上，就是 React Native 内部处理 Promise 的逻辑。</p><p>那么，如何将未被捕获的 Promise 错误上报呢？</p><p>答案就是再调用上一次 Hermes 引擎提供的 enablePromiseRejectionTracker 方法，或者再调用一次 rejection-tracking 文件暴露的 enable 方法，将框架的默认处理逻辑覆盖。示例代码如下：</p><pre><code class=\"language-plain\">const cusotomtRejectionTrackingOptions = {\n  allRejections: true,\n  onUnhandled: (id: string, error: Error) =&gt; {\n    console.log(\n      `Possible Unhandled Promise Rejection: ${JSON.stringify({\n        id,\n        errorMessage: error.message,\n        errorStack: error.stack,\n      },null,2)}`,\n  },\n  onHandled : (id: string) =&gt; {}\n}\n\nif (global?.HermesInternal?.hasPromise?.()) {\n  if (__DEV__) {\n    global.HermesInternal?.enablePromiseRejectionTracker?.(\n      cusotomtRejectionTrackingOptions,\n    );\n  }\n} else {\n  if (__DEV__) {\n    require('promise/setimmediate/rejection-tracking').enable(\n      cusotomtRejectionTrackingOptions,\n    );\n  }\n}\n</code></pre><p>开发者自定义的未捕获的 Promise 报错处理逻辑就是这样，和 React Native 框架内部的调用方法几乎一样。唯一不同的是，开发者可以在 onUnhandled 和 onHandled 回调中自定义错误的上报方法。在上述代码中，我用 console 代替了错误上报的逻辑。</p><h2>组件 render 报错的收集</h2><p>在 React/React Native 应用中，除了全局 JavaScript 报错和未捕获的 Promise 报错以外，还有一类报错可以统一处理，就是 React/React Native 的 render 报错。</p><p>在类组件中，render 报错指的是类的 render 方法执行报错；在函数组件中，render 报错指的就是函数本身执行报错了。</p><p>这里我展示了两类组件的报错形式，你可以看下：</p><pre><code class=\"language-plain\">function FunctionComponent() {\n  const [renderError, setRenderError ] = useState(false)\n\n  if(renderError) throw Error('render 报错')\n\n  return &lt;View&gt;&lt;/View&gt;\n}\n\nfunction ClassComponent() {\n  state = {\n    renderError: false\n  }\n\n     render(){\n      return (\n          &lt;View&gt;\n            {this.state.renderError &amp;&amp; &lt;span&gt;&lt;/span&gt;}\n          &lt;/View&gt;\n      )\n  }\n}\n</code></pre><p>你可以看到，第一个 FunctionComponent 示例是，当 renderError 状态由 false 变为 true 时，函数组件执行了到一半就会被 throw Error  报错打断。第二个 ClassComponent 示例是，当 this.state.renderError 状态由 false 变为 true 时，render 方法执行时发现了一个 React Native 中不存在的组件 span，整个渲染过程被中断。</p><p>类似这两种组件的 render 执行报错，在本地会抛红屏，在线上可能就是没有任何反应或者白屏。</p><p>那如何解决整个页面无响应或者白屏的问题呢？React/React Native 也提供了类似 try catch 的方法，叫做 Error Boundaries。Error Boundaries 是专门用于捕获组件 render 错误的。</p><p>不过，React/React Native 只提供了类组件捕获 render 错误的方法，如果是函数组件，必须将其嵌套在类组件中才能捕获其 render 错误。业内通常的做法是将其封装成一个通用方法给其他组件使用，比如 Sentry 就提供了 <a href=\"https://github.com/getsentry/sentry-javascript/blob/master/packages/react/src/errorboundary.tsx#L183\">ErrorBoundary 组件和 withErrorBoundary 方法</a>来帮助其他类组件或函数组件捕获 render 错误。</p><p>这里我提供了一个简易的 ErrorBoundary 组件的示例代码，你可以看看：</p><pre><code class=\"language-plain\">class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染能够显示降级后的 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 你同样可以将错误日志上报给服务器\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以自定义降级后的 UI 并渲染\n      return &lt;View&gt;404页面&lt;/View&gt;;\n    }\n\n    return this.props.children; \n  }\n}\n// 使用方法\n&lt;ErrorBoundary&gt;\n    &lt;App/&gt;\n&lt;/ErrorBoundary&gt;\n</code></pre><p>这段代码中的ErrorBoundary 是用于捕获 App 组件 render 执行报错的组件。</p><p>如果 App 组件 render 没有报错，那么会走 return this.props.children 的逻辑正常渲染；如果 App 组件 render 报错了，那么会触发 getDerivedStateFromError 回调，在 getDerivedStateFromError 回调中将控制是否有报错的开关状态 hasError 打开，并重新执行 render 渲染降级后的 404 页面，同时还会触发 componentDidCatch 回调。你可以在 componentDidCatch 回调中将组件的 render 错误上报。</p><p>在这个示例中，我用 ErrorBoundary 包裹的是 App 组件，也就是通常意义上的根组件，只要页面中出现任意组件的 render 错误，就会渲染一个“404页面”。实际上，你也可以使用 ErrorBoundary 包裹局部组件，当某个局部组件出现错误时，使用其他局部组件将其替换。</p><p>到此，JavaScript 全局错误、Promise 未捕获错误和 React Native 组件的 render 错误，就都收集完成了。接下来我们开始进行性能收集。</p><h2>性能收集</h2><p>相对于错误收集，性能收集的优先级会低一些，因为错误影响的是能不能操作的问题，性能影响的是操作快点或慢点的体验问题。</p><p>早期的 Sentry 也是只收集错误不收集性能的，但现在也开始重视性能收集了。Sentry 主要收集的性能包括：</p><ul>\n<li>App 启动耗时；</li>\n<li>页面跳转耗时；</li>\n<li>请求耗时。</li>\n</ul><p>像 App 启动耗时、页面跳转耗时和请求耗时这些耗时类的统计原理，都是通过两个时间点的间隔计算出来的，原理示意如下：</p><pre><code class=\"language-plain\">开始时间点 = Date.now()\n结束时间点 = Date.now()\n总耗时 = 结束时间点 - 起始时间点\n</code></pre><p>在原理示例中，<strong>总耗时等于结束时间点减去开始时间点的差值</strong>，开始时间和结束时间点都是通过 Date.now() 获取的当前系统时间，单位是 ms。</p><p>因此，<strong>耗时类统计的关键是找准开始时间点和结束时间点。</strong>对于 App 启动耗时、页面跳转耗时和请求耗时的时间点，我画了一张示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/74/3f1bc89707321d9912b7f638f06f1c74.png?wh=1211x431\" alt=\"图片\"></p><p>首先我们来看 <strong>App 启动耗时。</strong>App 启动的开始时间点是在 Native 组件的生命周期里面的。例如，在 Android 上就是 Fragment 所在的 Activity 启动完成后的 <a href=\"https://github.com/getsentry/sentry-java/blob/3c3597e2ce071951111934ae1e808db4b57edd8a/sentry-android-core/src/main/java/io/sentry/android/core/ActivityLifecycleIntegration.java#L246\">onActivityCreated</a> 回调发生的时间点。App 启动的结束时间点是在 React/React Native 应用的生命周期里，也就是组件挂载完成 <a href=\"https://github.com/getsentry/sentry-react-native/blob/f916f2b3afbb9884f9037b8486539ca6cc8b327c/src/js/tracing/reactnativeprofiler.tsx#L22\">componentDidMount</a> 回调发生的时间点。</p><p>虽然 App 只有一个，但页面、请求有很多个。统计 App 启动耗时可以在 Native 根组件或 React 根组件的生命周期里面统计，只需统计一次就行。但你不可能在每个页面的开始挂载和结束挂载的生命周期回调里面添加统计，也不可能在每个请求开始之前和回来之后添加统计。</p><p>那么，我们如何统计 App 中所有的页面跳转和请求耗时呢？</p><p>我们先来看<strong>页面跳转耗时</strong>怎么统计。如果你使用的是 React Navigation，那在每次页面跳转之前都需要下达跳转命令。在下达跳转命令的时候会触发 <code>__unsafe_action__</code> 事件，你可以在 <code>__unsafe_action__</code> 事件的回调中添加页面跳转耗时的开始时间点。在页面跳转完成后，页面的状态会发生改变，此时会触发 state 改变事件，此时添加结束时间点。</p><p>示例代码如下：</p><pre><code class=\"language-plain\">function App({navigation}) {\n\n  useEffect(()=&gt;{\n    let startTime = 0\n\n    navigation.addListener('__unsafe_action__', (e) =&gt; {\n      startTime = Date.now()\n    });\n\n    navigation.addListener('state', (e) =&gt; {\n      const totalTime = Date.now() - startTime\n      console.log(`totalTime:${totalTime}`)\n    });\n  },[])\n\n  return &lt;&gt;&lt;/&gt;\n}\n</code></pre><p>从代码中你可以看到，我们无须在每个组件的声明周期里面都添加回调，只用在 App 根组件挂载后，直接监听导航命令触发的 <code>__unsafe_action__</code> 和<code>state</code> 事件就可以完成页面跳转耗时的统计。</p><p>当然上面的示例代码只是列举了原理，还有些边界情况没有考虑到，如果你对其中细节感兴趣你可以查看一下 <a href=\"https://github.com/getsentry/sentry-react-native/blob/f916f2b3afbb9884f9037b8486539ca6cc8b327c/src/js/tracing/reactnavigation.ts\">Sentry 的 ReactNavigation 部分的源码</a>。</p><p>最后，我们再一起来看下<strong>请求耗时</strong>如何统计，示例代码如下：</p><pre><code class=\"language-plain\">let startTime = 0\n\nconst originalOpen = XMLHttpRequest.prototype.open\n\nXMLHttpRequest.prototype.open(function(...args){\n    startTime = Date.now()\n  const xhr = this;\n\n    const originalOnready = xhr.prototype.onreadystatechange\n\n    xhr.prototype.onreadystatechange = function(...readyStateArgs) {\n        if (xhr.readyState === 4) {\n            const totalTime = Date.now() - startTime\n      console.log(`totalTime:${totalTime}`)\n        }\n    originalOnready(...readyStateArgs)\n    }\n\n    originalOpen.apply(xhr, args)\n})\n</code></pre><p>因为 React Native 中的 fetch 或 axios 请求都是基于 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a> 包装的，所以要统计请求耗时，就要监听 XMLHttpRequest 的 open 事件，以及其实例 xhr 的 onreadystatechange 事件。在 open 事件中，记录请求开始的时间点，在 onreadystatechange 事件触发时且 xhr.readyState 等于 4 时记录请求的结束时间点。这里 xhr.readyState 等于 4 就代表下载操作已完成。<br>\n为了不破坏请求默认的 open 和 onreadystatechange 事件，我又保留了这些事件的默认回调，并在相应事件中继续调用和传参。</p><p>在我刚刚做前端开发时，如何使用 XMLHttpRequest 实现 ajax 异步请求是一道必考题，后来随着 fetch 和 axios 这些上层的 API 的普及，就很少有人直接操作底层的 XMLHttpRequest了。但如果你想实现一些稍微底层的库，比如这一讲的线上监控，你就必须深入底层，把这些底层的 API 搞懂才行。</p><h2>总结</h2><p>今天这一讲，我和你介绍了实现一个简易监控 SDK 的思路。</p><p>你需要先知道用户是谁，在计算机的视角它会用一个唯一标识符 uuid 来代表用户，并且会记录该用户的设备信息。</p><p>能够统一收集的线上报错主要分为三类，JavaScript 全局报错、Promise 未捕获报错、组件 Render 报错，这些报错信息会和 uuid、设备信息一起上报到服务端。</p><p>同样，App 启动耗时、页面跳转耗时、请求耗时这类性能信息也会和 uuid、设备信息一起上报到服务端。</p><p>当服务端接收到这些从用户手机发来的错误和性能数据后，它会将这些数据进行处理、存储和展示，这就是线上监控的基本原理。</p><h2>作业</h2><ol>\n<li>\n<p>我在 GitHub 上的 <a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/20_Sentry\">Demo</a> 中实现了一个简易的线上错误监控 SDK。请你根据这一讲中的性能监控的代码片段，为该简易 SDK 添加性能监控能力；</p>\n</li>\n<li>\n<p>如果要你来实现一个监控 SDK，除了文中提到了设备信息、报错信息、性能信息，你还会收集哪些维度的信息来帮助你排查问题？这些收集上来的信息，你又会通过什么方式将它们用起来呢？</p>\n</li>\n</ol><p>欢迎在评论区和我们分享你的想法。我是蒋宏伟，咱们下一讲见。</p>","neighbors":{"left":{"article_title":"19｜Redux：大型应用应该如何管理状态？","id":517172},"right":{"article_title":"21｜混合应用：如何从零开始集成 React Native？","id":518965}}},{"article_id":518965,"article_title":"21｜混合应用：如何从零开始集成 React Native？","article_content":"<p>你好，我是蒋宏伟。</p><p>从今天开始，我们将进入 React Native 基础设施建设篇的学习。我也特地邀请了多年以来和我一起做 58RN 基建的两位老搭档：58RN Android 负责人况众文和58RN iOS 负责人朴惠姝一起来讲解。</p><p>在基础设施建设篇中，众文老师、惠姝老师会和我一起为你详细介绍怎么搭建 React Native 混合应用、怎么创建新架构的自定义组件，以及怎么自研热更新平台，又怎么进行性能优化。</p><p>无论你是 FE、Android 还是 iOS，相信基建篇的内容都能让你大有收获，甚至帮助你在公司中晋级。好了，下面我们正式开启基建篇的学习。</p><hr><p>你好，我是况众文，是 58RN 负责Android 端的同学。接下来基础设施建设篇中移动端相关的几讲，将由我和我的同事，负责iOS 端的同学朴惠姝一起来讲解。</p><p>这几讲是《混合应用：如何从零开始集成 React Native？》、《自定义组件：如何满足业务的个性化需求？》，以及《客户端优化：如何把性能提升到极致？》。在这三讲中，我们将结合自己在 React Native 开发的实际经验，以及真实的业务案例，和你一起循序渐进地走入混合开发的世界。</p><p>而且，我们这几讲将使用 React Native 最新框架来讲解，你也可以借此了解 Fabric、TurboModules、CodeGen、JSI、Hermes 等新概念。</p><!-- [[[read_end]]] --><p>但在正式开始讲解怎么做混合开发之前，想先用一些篇幅，简单跟你介绍一下什么是混合应用与混合开发，以及我们什么时候需要用到混合开发。</p><h2>App 混合开发指的是什么？</h2><p>App 混合开发，指的是<strong>一个 App 部分功能用 Native 构建，部分功能用跨端框架构建</strong>。目前比较流行的跨端框架有 H5、React Native、Flutter、布局动态化等。当然我们这门课主要是围绕着React Native来进行讲解。</p><p><img src=\"https://static001.geekbang.org/resource/image/be/24/bed77cfbc69b490ae759a3166fb88b24.png?wh=1854x594\" alt=\"\"></p><p>以 Native 与 React Native 混合开发为例，在同一个 App 中，通常存在以下几种形态：</p><p><img src=\"https://static001.geekbang.org/resource/image/db/fc/db3e0383979b499652d6dfef81a051fc.jpg?wh=1755x818\" alt=\"图片\"></p><p>那么，Native 与 React Native 混合开发一般会用在哪儿呢？</p><p>首先是一些大型App中，比如美团、携程、京东、58等。这些大型 App 一般都非常复杂，整个框架需要包含模块化、组件化、插件化、跨端等能力。相比纯 React Native 工程，大型App的实际业务开发还需要考虑如何在已有原生项目中引入 React Native，作为原生框架的扩展能力。比如，部分业务可能对开发效率、多端一致性、动态更新能力有较强要求，就可以使用 React Native 来实现。</p><p>除了大型 App 外，如果你要对已上线的项目引入 React Native 也需要使用混合模式。因为原生改造成 React Native 并不是那么简单的事情，毕竟开发语言、页面管理、模块管理完全是另一套东西，而且一些原生页面，如启动页、首页等，出于性能考虑，大都还是会选择原生来实现。</p><p>当然一些新开发的轻量级 App，建议你选择纯 React Native 模式。因为新开发的 App 没有技术债，可以从0到1享受 React Native 跨端的优势，比如项目最关心的开发成本。</p><p>那么混合开发又有什么优点呢？简单说有这几点：</p><ul>\n<li>开发效率高，一套代码可以在 Android、iOS 上运行；</li>\n<li>更新部署方便，无须依赖应用市场发版，迭代更新速度快；</li>\n<li>具备动态更新能力，特别是国内 App，以 Android 为例，受限于 Google Play，无法使用 Android App bundle，而插件化框架又存在稳定性问题。而业务快速迭代、Bug 响应速度都对动态更新能力有强烈的需求。</li>\n</ul><p>但混合开发也不是万能的，它也有一些缺点，你要特别注意：</p><ul>\n<li><strong>性能不佳</strong>。H5 渲染链路长；React Native 依托于 JS bridge 交互 （指旧版，最新架构使用 JSI）；虽然 Flutter 绘制流程直接使用 Skia，但依赖于原生的能力仍需异步交互；</li>\n<li><strong>兼容性差</strong>。Android、iOS 各版本都存在各种兼容性问题，特别是 Android 碎片化严重；</li>\n<li><strong>问题排查成本高</strong>。跨端框架一般涉及 Native、FE、Server，中间做了大量的桥接转换，排查链路比纯 Native 长；</li>\n<li><strong>动态化能力受限</strong>。相比纯原生的插件化，跨端框架动态更新的业务如果涉及 Native 部分的组件更新，需要依赖 App 发版。</li>\n</ul><p>现在一般大型 App 都是多套跨端框架并存的，比如 H5 + React Native + 布局动态化，或 H5 + Flutter，具体选型主要以业务场景、包大小、性能、运行内存、动态更新能力为标准进行。但这一讲我们会从 React Native视角带你一步步构建混合应用。</p><p>在React Native的混合开发中，我们需要关注下面这几个主要问题和流程：</p><ul>\n<li>如何从 0～1 进行环境配置；</li>\n<li>通用的 React Native 载体页如何设计，需要包含哪些能力；</li>\n<li>如何调试打包发布；</li>\n<li>遇到混合开发的 bug 如何进行排查与修复。</li>\n</ul><p>这些问题和流程，我们将从 Android &amp; iOS 两端逐步讲解。</p><h2>环境配置</h2><p>我们先从 Native 环境配置开始，先看看如何在 Android 端进行混合工程下的 React Native 环境配置。</p><h3>Android</h3><h4>第一步：创建本地工程</h4><p>我们使用 Android Studio 创建一个新的 App 项目，如果你已经有了本地项目，可以跳过此步骤。填写完项目名称、包名、项目本地路径后，点击 “Finish” 按钮。你可以把这个项目名称取名为 “GeekTimeRNAndroid”。</p><p><img src=\"https://static001.geekbang.org/resource/image/00/78/00693ac394ea2b67f8b99913fc51fd78.jpg?wh=1792x1338\" alt=\"图片\"></p><p>创建好的工程目录如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/da/7fe5fe8662cce3e513ed0b89e2aa78da.jpg?wh=954x902\" alt=\"图片\"></p><h4>第二步：添加依赖</h4><p>创建好本地工程后，我们就要给它添加依赖。其实，React Native官方对集成到现有的原生应用提供了相应的<a href=\"https://reactnative.cn/docs/integration-with-existing-apps\">文档</a>，你可以看看。</p><p>文档提示，我们需要“创建一个空目录用于存放 React Native 项目，然后在其中创建一个 /android 子目录，把你现有的 Android 项目拷贝到 /android 子目录中”。</p><p>当然，官方提供的方式是非常不错的，它更偏向于 React Native 的工程管理模式。而我们在实际开发中，特别是已经上线的项目里面，React Native 功能和其他业务功能一样，一般会被当成原生工程的子模块来管理，所以我们这边选择<strong>偏向混合工程管理方式</strong>来集成。</p><p>这里，给你画了一张几种模式的对比图，你可以看看：</p><p><img src=\"https://static001.geekbang.org/resource/image/13/af/13e5c0527c254bc75a48ffb031ea36af.png?wh=766x1218\" alt=\"图片\"></p><p>对比官方模式，我们采用混合工程模式，是基于以下几点考虑的：</p><ul>\n<li>可以不侵入现有工程结构，React Native 模块会作为现有工程的一部分进行组织管理。</li>\n<li>不会影响代码仓库管理，不用把Android、iOS 放在同一代码仓库下进行管理。</li>\n<li>混合模式方便我们进行组件功能复用，你可以将 React Native 模块独立成组件，提供给其他 App 平台使用。</li>\n</ul><p>那么，基于混合工程模式集成 React Native 模块需要哪些依赖项呢？我们结合<a href=\"https://reactnative.cn/docs/integration-with-existing-apps\">文档</a>来看下，主要是：</p><ul>\n<li><strong>react-native</strong>：React Native 的核心框架；</li>\n<li><strong>JavaScript 引擎</strong>：可选 JSC、Hermes，用于执行 JavaScript。<br>\n接下来，我们参考文档进行如下操作：</li>\n</ul><pre><code class=\"language-plain\"># 切换到刚刚新建好的工程目录\ncd /Users/kuangzhongwen/Desktop/project/GeekTimeRNAndroid\n\n# 执行添加 react-native 命令，yarn 或 npm 都可以\nyarn add react-native\n</code></pre><p>执行 yarn add react-native 命令后，默认会安装最新版本的 React Native 包。</p><p>因为我们这个专栏主要是围绕 React Native 新架构讲解的，所以这边我们选择 React Native 0.68.0-rc3 版本。因此，我们指定 0.68.0-rc3 这个版本，执行如下命令：(<a href=\"https://github.com/facebook/react-native/tags\">这里</a>可查看 react-native 版本)：</p><pre><code class=\"language-plain\">yarn add react-native@0.68.0-rc3\n</code></pre><p>执行以上命令成功之后，我们会发现 GeekTimeRNAndroid 工程下多了一个 node_modules 目录，里面不仅有 react-native 框架，还有 JavaScript 引擎编译好的产物，包括 aar 和 pom 依赖文件。接下来，我们可以参考官方提供的方式，将 node_modules 目录配置为 repository，然后在工程中引入相关依赖。</p><p>不过，这种方式并不太推荐，其实我们只需要 react-native 和 JavaScript 引擎这两个产物就可以了。获取这两个产物后，在 Android 自己进行二次封装，然后发布到公司的远程仓库，就不用忍受一大堆无用的文件存放在项目中了 （虽然可以用 git ignore 忽略）。</p><p>目前node_modules 目录里有这几个内容：</p><ol>\n<li>\n<p>…/GeekTimeRNAndroid/node_modules/react-native（本地安装好的 node_module 中的 react-native 框架编译产物）：<br>\n<img src=\"https://static001.geekbang.org/resource/image/07/95/07fc4f77e3e9beef92d3bbd3a5b51e95.png?wh=904x1008\" alt=\"图片\"></p>\n</li>\n<li>\n<p>…/GeekTimeRNAndroid/node_modules/JavaScriptc-android（本地安装好的 node_module 中的 JSC 引擎编译产物）：<br>\n<img src=\"https://static001.geekbang.org/resource/image/94/a5/943210c6d1ea945e04eb736ca0826ba5.png?wh=792x996\" alt=\"图片\"></p>\n</li>\n<li>\n<p>…/GeekTimeRNAndroid/node_modules/hermes-engine（本地安装好的 node_module 中的 Hermes 引擎编译产物）：<br>\n<img src=\"https://static001.geekbang.org/resource/image/yy/1f/yy5e3402386d417d0ebe39de48f8fa1f.png?wh=708x480\" alt=\"图片\"></p>\n</li>\n</ol><p>其中只有 react-native 框架是必需的，而具体选择 JSC 引擎还是 Hermes 引擎，你可以参考以下几个点：</p><ul>\n<li>在启动性能上，Hermes 比 JSC 更快。Hermes 采用的是 AOT 提前编译的方案，它支持字节码文件，相比于 JSC，Hermes 不用先将 JavaScript 文本编译为字节码，节约了编译字节码的耗时，自然启动性能更好。</li>\n<li>在运行性能上，JSC 比 Herems 更快。JSC 使用的是 JIT 即时编译方案，该方案支持动态缓存热点代码，因此运行性能上更快。</li>\n</ul><p>但整体而言，由于 Hermes 引擎是专门为移动端定制的，<a href=\"https://www.callstack.com/blog/hermes-performance-on-ios\">在引擎大小、启动速度、运行内存、通信性能等方面都优于 JSC</a>。如果你的是新项目，没有历史负担，建议你直接使用 Hermes 引擎。如果是之前已使用 JSC 引擎上线的项目，可以往 Hermes 引擎进行升级。</p><p>接下来，我们来给 GeekTimeRNAndroid 工程添加 react native 相关的依赖，包括：</p><ol>\n<li>react-native.arr 文件；</li>\n<li>react-native.aar 依赖的第三方库；</li>\n<li>JavaScript 引擎 aar 文件。</li>\n</ol><p>首先我们先来添加 react-native.arr 文件。我们将 …/GeekTimeRNAndroid/node_modules/react-native/ 目录下的 react-native-0.68.0-rc.3.aar 拷贝放置到 GeekTimeRNAndroid/libs 目录。注意，Android 引入本地 aar 文件需要在工程根目录 build.gradle 添加 flatDir 配置：</p><pre><code class=\"language-plain\">allprojects {\n    repositories {\n        google()\n        jcenter()\n        // 添加 flatDir 配置\n        flatDir {\n            dirs 'libs'\n        }\n    }\n}\n</code></pre><p>然后在 GeekTimeRNAndroid/app 模块下的 build.gradle 添加依赖：</p><pre><code class=\"language-plain\">implementation(name:'react-native-0.68.0-rc.3', ext:'aar')\n</code></pre><p>接着，我们再将 …/GeekTimeRNAndroid/node_modules/react-native/ 目录下的 react-native-0.68.0-rc.3.pom 中的依赖库，按照 android gradle 依赖的方式进行添加，这些依赖主要是 react-native aar 本身远程依赖的第三方库。添加好的 app build.gradle 如下：</p><pre><code class=\"language-plain\">dependencies {\n    implementation(name:'react-native-0.68.0-rc.3', ext:'aar')\n    \n    implementation 'com.facebook.infer.annotation:infer-annotation:0.18.0'\n    implementation 'javax.inject:javax.inject:1'\n    implementation 'androidx.appcompat:appcompat:1.0.2'\n    implementation 'com.facebook.fresco:imagepipeline-okhttp3:2.5.0'\n    implementation 'com.facebook.fresco:fresco:2.5.0'\n    implementation 'com.facebook.soloader:soloader:0.10.3'\n    implementation 'com.google.code.findbugs:jsr305:3.0.2'\n    implementation 'com.squareup.okhttp3:okhttp:4.9.2'\n    implementation 'com.squareup.okhttp3:okhttp-urlconnection:4.9.2'\n    implementation 'com.squareup.okio:okio:2.9.0'\n}\n</code></pre><p>最后，我们添加下 JavaScript 引擎 aar 就可以了。这边我们使用 JSC 引擎 (Hermes 引擎则是将 …/GeekTimeRNAndroid/node_modules/hermes-engine 下的 hermes-cppruntime-release.aar &amp; hermes-release.aar 拷贝到 libs 目录，并在 build.gradle 中添加依赖)。<br>\nJSC aar 位于 …/GeekTimeRNAndroid/node_modules/jsc-android 目录下，主要是 jsc 的 so 动态库，将 android-jsc-r250230.aar 拷贝到 GeekTimeRNAndroid/libs 目录：</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/82/e718eaea509be293b4070e343a478282.png?wh=654x276\" alt=\"图片\"></p><p>完整的 GeekTimeRNAndroid/app/build.gradle 依赖配置如下：</p><pre><code class=\"language-plain\">dependencies {\n    implementation(name:'react-native-0.68.0-rc.3', ext:'aar')\n    implementation(name:'android-jsc-r250230', ext:'aar')\n\n    implementation 'com.facebook.infer.annotation:infer-annotation:0.18.0'\n    implementation 'javax.inject:javax.inject:1'\n    implementation 'androidx.appcompat:appcompat:1.0.2'\n    implementation 'com.facebook.fresco:imagepipeline-okhttp3:2.5.0'\n    implementation 'com.facebook.fresco:fresco:2.5.0'\n    implementation 'com.facebook.soloader:soloader:0.10.3'\n    implementation 'com.google.code.findbugs:jsr305:3.0.2'\n    implementation 'com.squareup.okhttp3:okhttp:4.9.2'\n    implementation 'com.squareup.okhttp3:okhttp-urlconnection:4.9.2'\n    implementation 'com.squareup.okio:okio:2.9.0'\n}\n</code></pre><p>到这里，React Native 相关的依赖配置已经完成，这时候你可以将 GeekTimeRNAndroid/node_modules 删除了。</p><h4>第三步：配置权限</h4><p>配置好相关的依赖库后，我们需要来添加下权限和清单配置。这个很简单，我们只需要在 GeekTimeRNAndroid/app 的 AndroidManifest.xml 清单文件中声明网络权限就好了：</p><pre><code class=\"language-plain\">&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n</code></pre><p>不过，如果你还需要访问开发者菜单界面，就需要在 AndroidManifest.xml 中声明：</p><pre><code class=\"language-plain\">&lt;activity android:name=\"com.facebook.react.devsupport.DevSettingsActivity\" /&gt;\n</code></pre><p>至此，Android 混合工程中的 React Native 环境配置就已经完成了。接下来我们再看看，如何在 iOS 中进行 React Native 环境配置。</p><h3>iOS</h3><h4>第一步：创建本地工程</h4><p>首先，我们需要跟着 React Native 官方文档，在本地创建一个对应版本的 React Native 工程，这里我们假设项目需要 0.68.1 版本：</p><pre><code class=\"language-plain\"># 首先安装 react-native-cli, 否则无法使用 react-native 命令\nsudo npm install -g react-native-cli\n\n# projectName 为工程名称\nreact-native init projectName --version 0.68.1\n</code></pre><p>创建好后，我们再打开工程，在工程 node_modules/react-native/template/ 目录下执行 npm install，然后进入 /ios/ 目录下执行 pod install，结束后再打开 react native workspace 工程：</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/48/c3288c994c5a9d63e4a92c79452de648.png?wh=1568x1344\" alt=\"图片\"></p><p>这就是iOS中创建一个新的工程，接入React Native功能的方案。那我们如何在已有的iOS工程中接入React Native呢？其实也比较简单。</p><p>首先，你需要将以下三个React Native源码引入到iOS工程中，这三个源码分别为Libraries、React，以及React Common：</p><p><img src=\"https://static001.geekbang.org/resource/image/04/f9/04aa50941fyy62c76cd48de5585a1cf9.png?wh=241x419\" alt=\"图片\"></p><p>然后你将这三个部分作为React Native功能模块，直接参考官方提供的podspec（三个不同模块的podspec请参考<a href=\"https://github.com/facebook/react-native\">https://github.com/facebook/react-native</a>），并结合自己工程，选择合理的接入方案，集成到iOS工程中就可以了：</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/f6/8a278d85112d0b0c9d721b6d5369d0f6.png?wh=304x100\" alt=\"图片\"></p><h4>第二步：添加iOS端依赖的库</h4><p>接下来，我们需要修改Podfile，来引用其他依赖的第三方库，包括DoubleConverison、glog、RCT_Folly、libevent，等等。podspec配置文件则直接使用官方提供的文件：</p><p><img src=\"https://static001.geekbang.org/resource/image/a6/33/a62d416f3497493d23b2605dc32b4133.png?wh=1268x274\" alt=\"图片\"></p><p>之后，我们再执行pod install并构建工程文件xcworkspace，并打开工程文件，进行编译就可以了。</p><p>对比两端的操作，你可以看到，Android 与 iOS 中 React Native 混合应用的工程组织结构是一样的。与 React Native 新项目不同，在已有 Android 和 iOS 项目中接入 React Native，都是把 React Native 当成子模块进行引入的。</p><p>不过，环境配置流程中，Android 侧重于依赖 React Native 的框架 aar，以及 JavaScript 引擎 aar，而 iOS 则是使用源码方式集成 React Native 相关的依赖库。两方的核心都是依赖 React Native 框架、JavaScript 引擎，以及框架本身依赖的其他库。</p><h2>载体页设计</h2><p>搭建好工程环境配置后，我们就要来设计一个 React Native 载体页了。载体页是加载渲染 React Native 的容器，在 Android 中为 Activity/Fragment，在 iOS 中为 ViewController。</p><p>按照官方的<a href=\"https://reactnative.cn/docs/integration-with-existing-apps\">文档</a>，一个简单的载体页只需要初始化、加载渲染、生命周期管理、组件注册能力即可。以 Android 为例，搭建一个 Activity，构建 ReactRootView，初始化 ReactInstanceManager 就可以加载本地的 bundle 文件了。你可以按照官方文档，快速搭建一个 React Native 载体页试试。</p><p>但在实际开发中，我们使用 React Native，除了看中它跨平台的优势外，还需要它的热更新能力。并且，为了进行Bug调试和分析，需要具备错误处理、上报能力，以及复杂业务中，Native & JavaScript 通信还需要提供通信能力。甚至，根据业务需求，还需要提供一些通用内置组件、组件注册能力，等等。</p><p>所以<strong>一个可用于商业上线的载体页</strong>，需要提供初始化、加载渲染 React Native 页面、热更新、缓存管理、生命周期管理、Native & JavaScript 通信、错误处理、错误上报、内置基础组件、组件注册等能力。所以接下来，我们就基于此来进行载体页的整体设计。</p><h3>载体页整体设计</h3><p>这里，直接根据上述要求设计好了一个载体页，你先整体看一看：</p><p><img src=\"https://static001.geekbang.org/resource/image/53/79/53d89b657d6532f86563c19e7a7a0e79.jpg?wh=1482x1116\" alt=\"图片\"></p><p>你可以看到，一个完整的载体页设计，应该包含下面几个部分：</p><ul>\n<li><strong>UI 结构</strong>：在混合开发中，React Native 大部分以独立页面存在，载体页可以包含通用标题栏和 React Native 容器。当然也可以直接暴露容器视图，由使用方动态进行添加；</li>\n<li><strong>对外能力</strong>：包含生命周期管理、Native 与 JavaScript 通信能力、内置的基础业务组件、组件注册能力、异常回调、错误上报等，同时还需要提供热更新、加载 bundle 的能力；</li>\n<li><strong>热更新</strong>：请求远程服务器获取对应 bundle 是否有最新版本。有最新版本则下载并进行缓存，无最新版本则使用缓存进行加载 (无缓存则先下载)，其中包含预加载、异步更新等业务策略提升加载性能。</li>\n<li><strong>缓存管理</strong>：通常 bundle 包随着业务体量增加，体积会越来越大。针对这种情况，我们的常用策略是拆包、按需加载，bundle 包在传输过程中会进行 zip 压缩、加密，下载成功后进行解压、校验。每个 bundle 文件都有对应的 id、版本号、content hash；</li>\n<li><strong>bundle 加载</strong>：JavaScript 引擎读取 bundle 文件，常用引擎包括 JSC、Hermes；</li>\n<li><strong>React Native 运行环境</strong>：整个 React Native 运行环境包含负责渲染的 RootView，框架内置核心组件、业务定制组件，执行脚本的 JavaScript 引擎，负责 Native 与 JavaScript 交互的 bridge/JSI。</li>\n</ul><h3>如何初始化载体页？</h3><p>讲完了载体页设计后，我们来看看如何对载体页进行初始化。这里我们说的初始化，除了自身业务封装的初始化外，核心还是 React Native 框架本身的初始化。接下来我们依然分成 Android、iOS 两端来分析。</p><h4>Android</h4><p>我们来看下 Android 端的初始化。不过为了方便后续代码的讲解，需要先带你了解下 React Native Android 中几个常用类的作用：</p><ul>\n<li><strong>ReactContext</strong>：继承于 ContextWrapper，是 React Native 应用的上下文，管理着 CatalystInstance 以及三大线程 （UIThread、NativeModulesThread、JSThread）；</li>\n<li><strong>ReactInstanceManager</strong>：总的管理类，管理 ReactPackage、ReactContext、ReactRootView、控制生命周期，同时还可以设置 JavaScript 引擎；</li>\n<li><strong>ReactRootView</strong>：React Native 渲染的原生容器，继承于 FrameLayout；</li>\n<li><strong>CatalystInstance</strong>：Java 层、C++ 层、JavaScript 层通信的总管理类，管理着 Java 层、JavaScript 层 Module 映射表与回调，是三端通信的桥梁。实现类为 CatalystInstanceImpl，支持向 JavaScript 注入全局变量、动态加载脚本文件、获取 NativeModules &amp; JSModules；</li>\n<li><strong>JavaScriptModule</strong>：JS Module，负责 JavaScript 到 Java 的映射调用格式声明，由CatalystInstance 统一管理；</li>\n<li><strong>NativeModule</strong>：Java Module，负责 Java 到 JavaScript 的映射调用格式声明，由CatalystInstance 统一管理；</li>\n<li><strong>UIManager</strong>: 处理 UI 的渲染，JavaScript 层通过 C++ 层把创建 View 的请求发送给 Java 层的UIManagerModule。</li>\n</ul><p>初始化的核心是通过 ReactInstanceManagerBuilder 构建 ReactInstanceManager，<a href=\"https://reactnative.cn/docs/integration-with-existing-apps\">官方</a>提供了对 ReactInstanceManager 的构建说明。我们直接来看一段 Demo：</p><pre><code class=\"language-plain\">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder();\n// 设置 application 上下文\nbuilder.setApplication((Application) context.getApplicationContext());\n\n// 添加包，一个 package 由多个组件构成，上述代码中的 MainReactPackage 是 RN 内置的 package \nbuilder.addPackage(new MainReactPackage());\n\n// JS 异常回调处理实现，在这个实现中我们可以打印 JS 异常日志，上报错误\nbuilder.setRedBoxHandler(mRedBoxHandler); \n\n// native module 异常回调处理实现，在这个实现中我们可以打印 native module 异常日志，上报错误\nbuilder.setNativeModuleCallExceptionHandler(mNativeModuleExceptionHandler);\n\n// JS bundle 中主入口的文件名，demo 中 \"index\" 表示入口文件名为 index.js\nbuilder.setJSMainModulePath(\"index\");\n\n// 是否开启 dev 模式\nbuilder.setUseDeveloperSupport(true);\n\n// 设置创建时机\nbuilder.setInitialLifecycleState(LifecycleState.BEFORE_CREATE); \n\n// 设置 JS 引擎，如果想使用 Hermes 引擎，可以这样设置，需要引入 Hermes 相关的 so 库\n// builder.setJavaScriptExecutorFactory(new HermesExecutorFactory());\n\nReactInstanceManager reactInstanceManager = builder.build();\n</code></pre><p>然后我们要获取 ReactContext，ReactContext 在后续加载渲染过程中会用到：</p><pre><code class=\"language-plain\">reactInstanceManager.addReactInstanceEventListener(new ReactInstanceManager.ReactInstanceEventListener() {\n    @Override\n    public void onReactContextInitialized(ReactContext reactContext) {\n       mReactContext = reactContext;\n    }\n});\n</code></pre><p>至此，Android 端的初始化工作就完成了，接着我们来看下 iOS 端的初始化逻辑。</p><h4>iOS</h4><p>iOS 端初始化载体页比较简单，只需要下面几个步骤。</p><p>首先，我们要创建一个 Bridge。在 React Native 中，通过 Bridge 实现了 JavaScript 与原生框架之间的通信，调用 React Native 提供的 API ，就相当于通过 Bridge 调用原生的API。因此，我们需要创建一个 Bridge，与载体页一对一绑定。</p><pre><code class=\"language-plain\">&nbsp;RCTBridge *carrierBridge = [[RCTBridge alloc] initWithDelegate:self \n                                               launchOptions:nil];\n</code></pre><p>接下来，我们需要创建一个 RCTRootView，用于展示 React Native 视图的组件RCTRootView，在 JavaScript 代码中 render() 部分的 UI 组件均会渲染到该 View 中，创建方式如下：</p><pre><code class=\"language-plain\">&nbsp;RCTRootView *rctView = [[RCTRootView alloc] initWithBridge:bridge \n                                             moduleName:moduleName \n                                             initialProperties:nil];\n [self.view addSubview:rctView];\n</code></pre><p>到此， iOS 端初始化准备过程就完成了。你看，确实比较简单吧？</p><p>那么接下来，我们就需要获取 React Native 代码包，也就是 JS Bundle 资源。那么我们要怎么动态下载 JS Bundle资源呢？</p><p>我们可以采用热更新策略，动态下载 JS bundle 资源。每个不同的 JS bundle包都有它自己的标识 id，我们可以根据该 id 从服务器中获取该 JS bundle 资源对应的最新版本号，以及最新资源下载地址。</p><p>在获取 JS Bundle 的最新版本号后，如果用户之前浏览过当前 React Native 页面，还存在缓存，那么我们就可以检测缓存版本号是否与最新版本号相同。如果是相同的，就不需要重复下载了；如果不相同，那你还要根据最新资源下载地址，下载最新的资源包，并缓存到本地。</p><p>要是用户之前并没有浏览过当前 React Native 页面，或者缓存已被清空，你可以直接根据最新资源下载地址，下载最新的资源包，并缓存到本地。</p><p>你可以看一下这张整体流程图加深理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/24/49/24560021a3f881746b0b2d76aa71bb49.jpg?wh=1052x874\" alt=\"图片\"></p><h3>加载渲染</h3><p>通过以上步骤，我们就能创建好载体页并成功下载 JS bundle了，那么现在就可以准备开始执行 JavaScript 代码并渲染 React Native 页面了。我们先来看下 Android 端是如何加载 JS bundle 文件的。</p><h4>加载JS bundle（Android）</h4><p>Android 端通过 ReactContext 获取 CatalystInstance 对象，CatalystInstance 实现类为 CatalystInstanceImp。CatalystInstanceImpl 有一个非 public 方法 loadScriptFromFile()，我们通过这个方法就可以动态加载本地的 bundle 文件了。不过，由于 loadScriptFromFile() 为非 public，所以需要反射获取调用：</p><pre><code class=\"language-plain\">CatalystInstance catalystInstance = mReactContext.getCatalystInstance();\nMethod loadScripFromFileMethod = CatalystInstanceImpl.class.getDeclaredMethod(\"loadScriptFromFile\", String.class, String.class, boolean.class);\nloadScripFromFileMethod.setAccessible(true);\n// fileName 和 sourceURL 传入本地缓存的 bundle 路径，loadSynchronously 为是否同步加载\nloadScripFromFileMethod.invoke(catalystInstance, fileName, sourceURL, loadSynchronously);\n</code></pre><p>接着，我们再调用 ReactRootView startReactApplication 就可以开始加载渲染 React Native 页面了。这里要注意，startReactApplication() 中的参数 moduleName 必须对应 “index.js” 中的 “AppRegistry.registerComponent()” 的第一个参数：</p><pre><code class=\"language-plain\">reactRootView.startReactApplication(reactInstanceManager, moduleName, launchOption);\n</code></pre><p>我们还可以使用 catalystInstance.setGlobalVariable() 设置全局变量。设置好后，JavaScript 运行时可获取到这些全局变量了：</p><pre><code class=\"language-plain\">catalystInstance.setGlobalVariable(\"xxx\", xxx)\n</code></pre><p>到这里，Android 端动态加载 bundle 就讲完了，我们继续来看 iOS 加载 bundle 的流程。</p><h4>加载JS bundle（iOS）</h4><p>其实，iOS 端可以在包下载完成后初始化 Bridge（注： Bridge 在源码中是 JS Bridge 或者 JSI 的统称）。Bridge初始化后，我们就可以开始加载下载好的 JavaScript 包了。</p><p>整体的流程是这样的：</p><ul>\n<li>在初始化Bridge时，在 setup 的过程中，首先会调用 bridge 的代理方法 (NSURL *)sourceURLForBridge : (RCTBridge *)bridge 方法，指定获取 JS bundle 的路径：</li>\n</ul><pre><code class=\"language-plain\">&nbsp;-(NSURL *)sourceURLForBridge:(RCTBridge *)bridge{\n    NSString *bundlePath = [self getCurrentBundlePath:bundleid];\n    return bundlePath;\n}\n</code></pre><ul>\n<li>确定 URL 之后，bridge 会调用 start 方法，开始加载 JS bundle 并调用以下方法：</li>\n</ul><pre><code class=\"language-plain\">&nbsp;[self loadSource:^(NSError *error, RCTSource *source) {\n&nbsp; &nbsp; if (error) {\n&nbsp; &nbsp; &nbsp; [weakSelf handleError:error];\n&nbsp; &nbsp; }\n    ...\n ]\n</code></pre><ul>\n<li>接下来会调用 bridge 的代理方法，我们可以在该方法中手动注入一些业务参数：</li>\n</ul><pre><code class=\"language-plain\">- (void)loadSourceForBridge:(RCTBridge *)bridge\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; onProgress:(RCTSourceLoadProgressBlock)onProgress\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; onComplete:(RCTSourceLoadBlock)loadCallback{\n  [RCTJavaScriptLoader loadBundleAtURL:bridge.bundleURL onProgress:onProgress onComplete:^(NSError *error, RCTSource *source) {\n      //手动注入一些业务参数\n     &nbsp;NSString *string = \";this.__xxx___ = 'yyy';\"\n      NSData *stringData = [string dataUsingEncoding:NSUTF8StringEncoding];\n      \n      NSMutableData *newData = [NSMutableData dataWithData:stringData];\n      [newData appendData:source.data];\n      \n      //生成新的Source去加载\n      RCTSource * newSource = [RCTJavaScriptLoader getNewRCTSourceURL:source.url data:newData];\n&nbsp; &nbsp; &nbsp; loadCallback(error,newSource);\n  }];\n}\n</code></pre><p>之后，bridge 会负责执行该 newSource，执行 JavaScript 代码并渲染出页面。</p><h2>React Native 问题排查与框架 Bug 修复</h2><p>React Native 涉及 Native、FE、Server 三端，中间经过 JavaScript 环境、Server 数据、Native 环境的转换，如果出现了问题，排查链路很长。</p><p>而且，React Native 框架的不同版本在 Android、iOS 端都存在兼容性 bug，特别是用于混合工程时这个问题会更加明显。因为，React Native 的许多设计都是以纯 React Native 工程为出发点的，混合工程中随着业务越来越复杂，内存占用、兼容问题、多线程问题都会暴露出来。</p><p>接下来，我们就来看下在 Android、iOS 端分别要怎么进行 React Native 问题排查与框架 Bug 修复。</p><h3>Android 问题排查与框架 bug 修复</h3><p>我们的问题排查思路很简单：只要有足够多的日志，就能帮我们足够快地定位问题。</p><p>所以我们首先要<strong>添加日志输出</strong>。我们可以通过 ReactInstanceManagerBuilder 获取 JavaScript、native 运行错误：</p><pre><code class=\"language-plain\">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder();\nbuilder.setApplication((Application) context.getApplicationContext())\n       .setRedBoxHandler(mExceptionHandler)\n       .setNativeModuleCallExceptionHandler(mExceptionHandler);\n        \nprivate static class ExceptionHandler implements NativeModuleCallExceptionHandler, RedBoxHandler {\n\n  @Override\n  public void handleException(Exception e) {\n    // 处理 Native 异常\n  }\n\n  @Override\n  public void handleRedbox(String s, StackFrame[] stackFrames, ErrorType errorType) {\n    // 处理 JS 异常\n  }\n  \n  @Override\n  public boolean isReportEnabled() {\n    return false;\n  }\n  \n  @Override\n  public void reportRedbox(Context context, String s, StackFrame[] stackFrames, String s1, ReportCompletedListener reportCompletedListener) {\n  }\n}\n</code></pre><p>接着，用 AOP 切片的方式拦截 ReactNative JavaMethodWrapper 调用，并使用 AspectJ 在编译期对 ReactNative 框架字节码进行插桩：</p><pre><code class=\"language-plain\">@Aspect\npublic class NativeModuleMethodInvokeAspect extends BaseAspect&lt;INativeModuleMethodInvokePointcut&gt; {\n\n    // 对 JavaMethodWrapper.invoke 方法调用进行插桩\n    @Around(\"execution (* com.facebook.react.bridge.JavaMethodWrapper.invoke(..))\")\n    public Object invokeNativeModuleMethod(ProceedingJoinPoint joinPoint) throws Throwable {\n        INativeModuleMethodInvokePointcut pointcut = getPointcut();\n        if(pointcut == null){\n            return joinPoint.proceed(joinPoint.getArgs());\n        }\n        return pointcut.pointcut(joinPoint);\n    }\n}\n</code></pre><p>下面这段代码是针对 Native Module 的调用做代码插桩，捕获 JavaScript 调用 Native Module 的异常：</p><pre><code>public class ModuleMethodInvokePointcut implements INativeModuleMethodInvokePointcut {\n    @Override\n    public Object pointcut(ProceedingJoinPoint proceedingJoinPoint) {\n        Object object;\n        Object target = proceedingJoinPoint.getTarget();\n        try {\n            object = proceedingJoinPoint.proceed();\n        } catch (Throwable throwable) {\n            // 异常时，通过 target 反射获取对应的 module 名称和方法\n            throwable.printStackTrace();\n            return null;\n        }\n        return object;\n    }\n}\n</code></pre><p>然后我们就可以通过下面这两个命令查看 React Native 运行日志了：</p><pre><code class=\"language-plain\">adb logcat | grep React\n</code></pre><p>最后，如果有异常日志就会上报到后台，日志信息会包含系统、机型、运行环境，以及业务标识等。有了异常日志给我们提供的这些信息，你就可以通过线下、线上手段，快速排查 React Native 相关的 bug 了。</p><p>那么接下来，我们对React Native框架的Bug进行修复呢？</p><p>在 Android 混合工程中，React Native 是以 aar 方式引入的。所以建议你对它进行包装，自行发布 aar 管理。不过源码编译方式复杂，你可以通过编译期插桩的方式对 React Native aar 进行插桩，来修复 bug。</p><p>常用的插桩方式包括 ASM、Javasist、AspectJ 这几种。我们通常可以用 AspectJ 匹配具体类的具体方法进行插桩，实现 bug 修复。选择 AspectJ 的原因是，通常我们只需要对 React Native 的一些异常方法做切片，并不需要修改里面的逻辑，它足以满足我们修改 React Native 框架问题的需要。并且， AspectJ 在易用性、可读性上比 ASM、Javasist 都更优。</p><p>以上就是 Android 端进行 React Native 的问题排查与框架 Bug 修复的常用手段，接下来我们再看看 iOS 端的。</p><h3>iOS 问题排查</h3><p>在iOS中，如果 React Native 页面在加载过程中或者运行过程中出现了异常，我们可以统一通过 typedef void (^RCTFatalHandler)(NSError *error); 来进行拦截。</p><p>首先我们要对原生的 RCTFatalHandler 中 error 参数进行改造，让 error 中带上 bridge 信息。具体改造代码如下：</p><pre><code class=\"language-plain\">- (void)error{\n    //改造error中带有bridge\n   &nbsp;NSError *newError = [self getWBErrorBridge:error];\n&nbsp; &nbsp; RCTFatal(newError);\n}\n\n//error信息里带上Bridge\n- (NSError *)getWBErrorBridge:(NSError *)error{\n&nbsp; &nbsp; NSMutableDictionary *errorDic = [NSMutableDictionary dictionaryWithDictionary:error.userInfo];\n&nbsp; &nbsp; [errorDic setObject:self-&gt;_parentBridge forKey:@\"ErrorBridgeTag\"];\n&nbsp; &nbsp; NSError *newErr = [[NSError alloc]initWithDomain:error.domain code:error.code userInfo:errorDic];\n&nbsp; &nbsp; return newErr;\n}\n</code></pre><p>出现异常后，我们要从 Error 中获取 bridge ，并找出发生异常的载体页信息，获取对应的 JS Bundle 的 ID ，以确定到底哪一个页面出现了异常：</p><pre><code class=\"language-plain\">&nbsp;RCTSetFatalHandler(^(NSError *error) {\n&nbsp; &nbsp; dispatch_async(dispatch_get_main_queue(), ^{\n        RNViewController *rnVC = nil;\n        RCTBridge *bridge = (RCTBridge *)error.userInfo[@\"ErrorBridgeTag\"];\n        if (bridge) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;carrierVC = (RNViewController *)bridge.delegate;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n        NSString *descriptions = error.localizedDescription;\n        NSLog(@\"error --- %@ --- %@\", rnVC.rnModel.bundleID, descriptions);\n    }\n}\n</code></pre><p>这样，我们就可以在拦截异常后，对页面进行展示错误页面、自动修复、清空异常的 JS bundle 缓存等一系列操作了。</p><h2>总结</h2><p>今天的这一讲，我们系统地讲解了混合开发的全流程。你可以根据官方文档快速搭建起 React Native 混合工程。我们这一讲是在官方教程的基础上，结合真实项目中的实战开发经验，从环境搭建、载体页设计、调试打包发布、问题排查与框架 Bug 修复几个方面来进行讲解的。这里我们再简单复习下几个重要知识点。</p><p>关于纯 React Native 工程和混合工程分别在哪些场景使用，我们在接入 React Native 时如何进行选择的问题，核心还是在于<strong>项目有没有历史包袱</strong>。</p><p>如果是一个新的项目，需要做到快速提效，并且不需要复杂的架构，这个时候你可以选择纯 React Native 模式。如果是已上线项目来接入 React Native，架构复杂，或者需要将 React Native 当成一种基础能力提供给其他业务/App 使用，就需要使用混合模式。</p><p>遇到问题时如何快速排查定位，是我们实际开发过程中经常遇到的问题。由于 React Native 的链路比较长、涉及客户端、前端、后端，且 React Native 框架输出的日志不够多，排查问题比较困难。这个时候我们可以通过捕获 React Native 运行异常、在 React Native 框架内加入足够的日志，帮助我们来快速定位问题。</p><p>其实混合开发并没有那么难，只要理解了以上的一些关键点，就足以让你应对日常的 React Native 混合开发需求了。</p><h2>作业</h2><ol>\n<li>设计一个简单的载体页，包含初始化、加载本地 bundle 文件、异常处理逻辑。</li>\n</ol><p>欢迎在评论区分享你的想法和经验，我们下一讲再见。</p>","neighbors":{"left":{"article_title":"20｜Sentry：线上错误与性能监控怎么处理？","id":518009},"right":{"article_title":"22｜自定义组件：如何满足业务的个性化需求？","id":519819}}},{"article_id":519819,"article_title":"22｜自定义组件：如何满足业务的个性化需求？","article_content":"<p>你好，我是众文，这一讲还是由我和惠姝来讲解。</p><p>上一讲，我们讲了如何构建混合应用。当环境配置、载体页、调试打包都 OK 后，我们就要开始复杂业务的开发了。在实际开发中，除了负责 React Native 框架本身的维护迭代外，另一个重要的工作就是配合前端业务，开发对应的 Native 组件。</p><p>那么什么时候用这些自定义的 Native 组件呢？</p><p>比如，有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块包装；或者你需要复用公司内的一些用 Java/OC 写的通用组件，而不是用 JavaScript 重新实现一遍；又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库，或者各种高级扩展等。</p><p>当然，你可以通过官方文档（<a href=\"https://reactnative.cn/docs/native-modules-android\">Android</a>/<a href=\"https://reactnative.cn/docs/native-modules-ios\">iOS</a>），快速访问你的原生模块。但官方文档提供的主要是简单的 Demo 和步骤，在实际开发中，你可能还需要自定义组件的方方面面，包括新架构定义组件的全流程，以及实际业务中的踩坑指南等。</p><p>今天这一讲，我们会先带你补齐组件的相关基础知识，包括组件的生命周期、组件传输数据类型，并以新架构的TurboModule 和 Fabric 为案例，带你了解自定义组件的方方面面。你也能借此对React Native新架构建立起初步认识。接下来让我们先了解下期待已久的 React Native 新架构。</p><!-- [[[read_end]]] --><h2>新架构介绍</h2><p>我们现在先通过下面这张图简单对比下新老架构：</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/31/3eb92714433185cd0a095yy2e1a36331.jpg?wh=1920x932\" alt=\"图片\"></p><p>新架构变更点主要在下面这几个方面：</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/8d/4df0702732be0a4922444d575980828d.png?wh=1894x1216\" alt=\"图片\"></p><p>前面也说了，我们一讲将以 TurboModule 和 Fabric 为案例对自定义组件进行讲解。所以你现在需要对新架构有一个初步的认识，特别是要注意，TurboModule 和 Fabric 对比旧版的 Native Module 和 UIManager 有哪些差异和优势。</p><p>如果你还想了解新架构的更多信息，你可以参考<a href=\"https://reactnative.dev/docs/new-architecture-intro\">官方文档</a>。这里包括了新架构介绍、如何在 Android、iOS 上开启新架构、如何在 Android、iOS 上开启使用 TurboModule 和 Fabric等。你也可以根据官方文档试着编译运行新架构。</p><p>而且，<a href=\"https://github.com/software-mansion/react-native-screens\">react-native-screens</a>、<a href=\"https://github.com/software-mansion/react-native-gesture-handler\">react-native-gesture-handler</a> 等知名 React Native 库的新版都已适配了新架构，感兴趣的话，你可以去了解下。</p><p>好的，现在我们进入这一讲的正题，先来了解一下组件的生命周期。</p><h2>组件的生命周期</h2><p>组件的生命周期，指的是在组件创建、更新、销毁的过程中伴随的各种各样的函数执行。这些在组件特定的时期被触发的函数，统称为组件的生命周期。</p><p>让组件拥有生命周期，我们就可以更好地管理组件的状态、内存，跟随载体页的生命周期做相应的处理。</p><h3>Android</h3><p>在Android端，一个 Module 组件的生命周期包括：</p><pre><code class=\"language-plain\">构造 -&gt; 初始化 -&gt; onHostResume() -&gt; onHostPause() -&gt; onHostDestroy()\n</code></pre><p>这几个生命周期的意思是：</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/1b/1bdfff7c48055490ce06ab49eff5f01b.png?wh=1824x1110\" alt=\"图片\"></p><p>如果你不熟悉 Android Activity/Fragment 生命周期，那你可以看下<a href=\"https://www.jianshu.com/p/1b3f829810a1\">这篇文章</a>加深下理解。</p><p>那么如何让 Native Module 具备生命周期呢？</p><p>React Native 给我们提供了一个接口：com.facebook.react.bridge.LifecycleEventListener。我们只需要在组件中添加这个接口的注册和取消注册，就可以让组件具备生命周期了。这里要注意，不要忘记在 onHostDestroy() 中移除注册，否则会造成内存泄漏。示例代码如下：</p><pre><code class=\"language-plain\">public class TestJavaModule extends ReactContextBaseJavaModule \n implements LifecycleEventListener, ReactModuleWithSpec, TurboModule {\n    public TestJavaModule(ReactApplicationContext reactContext) {\n       super(reactContext.real());\n       reactContext.addLifecycleEventListener(this);\n    }\n\n    @Override\n    public String getName() {\n       return getClass().getSimpleName();\n    }\n\n    @Override\n    public void onHostResume() {\n    }\n\n    @Override\n    public void onHostPause() {\n    }\n\n    @Override\n    public void onHostDestroy() {\n       getReactApplicationContext().removeLifecycleEventListener(this); \n    }\n}\n</code></pre><p>其实组件的生命周期原理很简单，就是观察者模式。当载体页触发自身的生命周期回调时，调用 ReactInstanceManager 的 onHostXXX() 方法，ReactInstanceManager 进而调用 ReactContext 的对应回调。</p><p>比如载体页调用 onResume() 时，最终会调用 ReactContext 的 onHostResume()，内部会遍历注册的事件进行回调：</p><pre><code class=\"language-plain\">public void onHostResume(@Nullable Activity activity) {\n    Iterator iterator = this.mLifecycleEventListeners.iterator();\n    while(iterator.hasNext()) {\n        LifecycleEventListener listener = (LifecycleEventListener) iterator.next();\n        // 观察者模式，载体页时调用已注册组件的生命周期回调\n        listener.onHostResume();\n    }\n}\n</code></pre><p>以上就是 Android 端组件生命周期的讲解，我们再来看看 iOS 端。</p><h3>iOS</h3><p>iOS中 NativeModules 组件的创建销毁时机，与bridge的创建销毁时机完全一致：</p><ul>\n<li>alloc：创建当前组件；</li>\n<li>dealloc：销毁当前组件。</li>\n</ul><p>创建一个组件TestNativeModule，通过RCT_EXPORT_MODULE() 声明组件，默认会根据类名声明组件名，当然也可以通过在参数中传入其他字符串作为组件的名。</p><pre><code class=\"language-plain\">@implementation TestNativeModule\nRCT_EXPORT_MODULE()\n\n- (instancetype)init{\n&nbsp; self = [super init];\n&nbsp; return self;\n}\n- (void)dealloc{\n  NSLog(@\"dealloc\");\n}\n</code></pre><p>而 <strong>TurboModule</strong> 组件的生命周期却与 NativeModule 不同。TurboModule 采用懒加载模式，在 Bridge 创建后页面中第一次 import 当前TurboModule ，也就是 JavaScript 端通过 <strong>TurboModuleRegistry.getEnforcing</strong>方法加载组件时， Native 会创建对应的 TurboModule 并进行缓存。如果 JS 端没有加载当前自定义组件，该组件就不会进行初始化。</p><p>JS 端加载组件方式如下：</p><pre><code class=\"language-plain\">export default (TurboModuleRegistry.getEnforcing&lt;Spec&gt;(\n   'TestTurboModule')\n  : Spec);\n</code></pre><p>而TurboModule 的销毁时机与 Bridge 的销毁时机一致。 Bridge 进行销毁时会发送一个 RCTBridgeDidInvalidateModulesNotification 通知，TurboModuleManager会监听该事件，依次对所有已创建的 TurboModule 进行销毁。示例代码如下：</p><pre><code class=\"language-plain\">- (void)bridgeDidInvalidateModules:(NSNotification *)notification\n{\n&nbsp; RCTBridge *bridge = notification.userInfo[@\"bridge\"];\n&nbsp; if (bridge != _bridge) {\n&nbsp; &nbsp; return;\n&nbsp; }\n&nbsp; [self _invalidateModules];//销毁所有TurboModules\n}\n</code></pre><p>了解完了组件的生命周期，我们再来看下组件的传输数据类型。在组件运行过程中，Native 与 JavaScript 不可避免地需要进行数据交互，如 JavaScript 调用组件方法传入数据，Native 向 JavaScript 回传结果，而 React Native 也帮我们封装好了对应的数据类型。</p><h2>组件传输数据类型</h2><p>在 Native 与 JavaScript 通信的过程中，组件需要获取输入参数、回传结果，对此 React Native 给我们包装了相应的数据类型，方便快速操作，我们通过一个Demo来简单了解下。</p><p>现在，我们让JavaScript端调用 TestModule 的 testMethod 方法，传入参数 type 和 message，接收 native 回传数据：</p><pre><code class=\"language-plain\">NativeModules.TestModule.testMethod({type: 1, message: \"fromJS\"}, (result)=&gt;{\n    console.info(result);\n  }\n);\n</code></pre><p>然后我们来看TestModule 在 Android、iOS 侧的实现。先来看 Android 端是怎么做的。</p><p>不过，在实现 TestModule 之前，我们需要先了解下 Android 端的组件传输数据类型：</p><p><img src=\"https://static001.geekbang.org/resource/image/61/87/615f0162574e42c30557a1356472ee87.png?wh=744x924\" alt=\"图片\"></p><p>这里你要注意，数字类型有点特殊。因为 JavaScript 不支持 long 64 位长类型，只支持 int (32)和double，所以对于长数字，JavaScript端统一用 double 表示。那么 Android 端如何转换成自己需要的数据类型呢？</p><p>我们以 long 为例，可以这样参考<a href=\"https://github.com/facebook/react-native/issues/12506\">官方issue</a>这样处理：</p><pre><code class=\"language-plain\">double value = readableMap.getDouble(key);\ntry {\n    // 判断是否为 long 的范围: 超过了 int 的最大值且为整数\n    if (value &gt; Integer.MAX_VALUE &amp;&amp; value % 1 == 0) {\n        long cv = (long) value;\n        // 转换成 long 型返回\n    }\n} catch (Exception e) {\n    // 异常时，仍使用 double\n}\n</code></pre><p>这段代码中，我们先将 JavaScript 传入的数值统一以双精度浮点数 double 来获取。获取完后，判断这个值是否超出了整数的最大值且不为小数，条件符合就将它转换成长整数 long，否则还是以 double 来返回。</p><p>了解完 Android 端的组件数据传输类型后，我们就可以来实现上文中的 TestModule了：</p><pre><code class=\"language-plain\">public class TestModule extends ReactContextBaseJavaModule implements ReactModuleWithSpec, TurboModule {\n   public TestModule(ReactApplicationContext reactContext) {\n      super(reactContext.real());\n   }\n\n   @Override\n   public String getName() {\n      return getClass().getSimpleName();\n   }\n   \n   @ReactMethod\n   public void testMethod(ReadableMap data, Callback callback) {\n      // 获取 JS 的调用输入参数\n      int type = data.getInt(\"type\");\n      String message = data.getString(\"message\");\n      // 回传数据给 JS\n      WritableMap resultMap = new WritableNativeMap();\n      map.putInt(\"code\", 1);\n      map.putString(\"message\", \"success\");\n      callback.invoke(resultMap);\n   }\n}\n</code></pre><p>上面代码中，我们定义了 Native 组件 TestModule，内部实现了 JavaScript 需要调用的 testMethod 方法。此方法包含两个参数：ReadableMap 和 Callback。ReadableMap 为 JavaScript 传入参数的字典，我们可以通过对应的 key 获取到 JavaScript 的入参值，而 Callback 是在 Native 回传数据时需要使用的，后面我们还有对通信方式这部分的讲解，这里我们只需要了解一下就好。</p><p>具体实现上，我们是首先获取 JavaScript 调用传入的 type 和 message，然后再通过 WritableMap 写入数据，最后通过 callback 回传给 JavaScript。</p><p>以上就是 Android 端的 React Native 读写数据类型，我们再来看下 iOS 端。</p><p>iOS端也是一样，在实现前面这个 demo 前，我们需要先看下 iOS 端支持的传入数据类型：</p><p><img src=\"https://static001.geekbang.org/resource/image/af/f8/afbea1f2yyfa12fec0df7248913d97f8.png?wh=772x956\" alt=\"图片\"></p><p>那么，iOS端中是如何实现上文中的TestModule的呢？我们可以在Module中进行callback，然后通过NSArray来返回，如下：</p><pre><code class=\"language-plain\">RCT_EXPORT_METHOD(getValueWithCallback : (RCTResponseSenderBlock)callback){\n&nbsp; if (!callback) {\n&nbsp; &nbsp; return;\n&nbsp; }\n&nbsp; callback(@[ @\"value from callback!\" ]);\n}\n\n</code></pre><p>不过，我们这个组件案例，只是演示了 Native 可以通过 callback 向 JavaScript 回传数据。那么除了 callback，React Native 与原生还有什么通信方式呢？</p><h2>React Native 与原生的通信方式</h2><p>总体来说，native 向 JavaScript 传递数据的方式分成以下三种：</p><ul>\n<li>Callback：由 JavaScript 主导触发，Native 进行回传，一次触发只能传递一次；</li>\n<li>Promise：由 JavaScript 主导触发，Native 进行回传，一次触发只能传递一次。Promise 是 ES6 的新特性，类似 RXJava 的链式调用。Promise 有三种状态，分别是pending (进行时)、resolve (已完成)、reject (已失败)；</li>\n<li>发送事件：由 Native 主导触发，可传递多次，类似 Android 的广播和 iOS 的通知中心。</li>\n</ul><p>Callback 在上面的例子中已经出现过了，我们通过 callback.invoke(xx) 就可以将数据回传给 JavaScript，使用起来比较简单，这边我们就不再赘述了。现在我们主要来看下 Promise 和发送事件的示例，以便更好地了解 React Native 和原生之间是如何进行通信的。</p><p><strong>首先我们来看下Promise 示例</strong>，我们从 JavaScript 如何触发、Native 如何回传数据两方面来进行讲解。</p><p>首先，JavaScript 端调用客户端定义的 SystemPropsModule 的 getSystemModel 来获取手机的设备类型，获取结果的方式使用 Promise 方式 （then… catch…）：</p><pre><code class=\"language-plain\">NativeModules.SystemPropsModule.getSystemModel().then(result=&gt; {\n  console.log(result);\n}).catch(error=&gt; {\n   console.log(error);\n});\n</code></pre><p>然后，Native 端定义 SystemPropsModule，实现 getSystemModel 方法，内部使用 promise 获取手机的 model 数据。使用 promise.reolve(xx) 为成功，promise.reject(xx) 为失败：</p><pre><code class=\"language-plain\">SystemPropsModule：\n...\n@ReactMethod\npublic void getSystemModel(Promise promise) {\n    // 回传成功，使用 resolve\n    promise.resolve(Build.MODEL);\n}\n...\n</code></pre><p><strong>接下来看发送事件示例</strong>，我们从 JavaScript 如何监听 Native 事件、Native 如何发送事件这两方面来进行讲解。</p><p>首先，JavaScript 端使用 EventEmitterManager 来注册 Native 的事件监听。通过 NativeModules 获取 EventEmitterManager，随后使用它构建出 NativeEventEmitter，最后通过 NativeEventEmitter 注册监听：</p><pre><code class=\"language-plain\">componentWillMount(){\n   // 拿到原生模块\n   var eventEmitterManager = NativeModules.EventEmitterManager;\n   const nativeEventEmitter = new NativeEventEmitter(eventEmitterManager);\n   const eventEmitterManagerEvent = EventEmitterManager.EventEmitterManagerEvent;\n   // 监听 Native 发送的通知\n   this.listener = nativeEventEmitter.addListener(eventEmitterManagerEvent, (data) =&gt; \n       console.log(\"Receive native event: \" + data);\n   );\n}\n\ncomponentWillUnmount(){\n   // 移除监听\n   this.listener.remove();\n}\n</code></pre><p>在 Native 端的使用则很简单。我们获取 RCTDeviceEventEmitter 这个 JSModule，使用 emit 方法就可以向 JavaScript 发送事件了：</p><pre><code class=\"language-plain\">reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n  .emit(\"msg\", \"say hello\");\n</code></pre><p>自定义组件相关的知识点，我们先介绍到这里。接下来进入实战阶段，我们将分别以一个数据存取 TurboModule 和视频播放 Fabric component 的案例，加深你对自定义组件的理解。我们先来看TurboModule。</p><h2>TurboModule：数据存取</h2><p>TurboModule 采用懒加载模式，在运行时第一次 import 该 TurboModule 时， Native 会创建对应的 TurboModule 并进行缓存。而旧版本的 NativeModule 都是在创建环境时统一进行构造的，会对 React Native 的启动性能有比较大的影响。</p><p>接下来我们以一个实际的案例来带你了解 TurboModule。当你需要使用 native 数据存取相关能力，如跨进程存取、偏好存取、加密存取等，而 React Native 自带的数据存储 module 满足不了你的需求，你可以通过自定义数据存储的 TurboMoudle 来实现。我们先来看下 JavaScript 侧。</p><h3>JavaScript</h3><p>在 Spec 中定义方法，定义好存和取的方法后，再导出 StorageModule：</p><pre><code class=\"language-plain\">export interface Spec extends TurboModule {\n+save: (key: string, value: string, callback: (value: Object) =&gt; void) =&gt; void;\n+get: (key: string, callback: (value: Object) =&gt; void) =&gt; void;\n}\n// 导出 StorageModule\nexport default (TurboModuleRegistry.getEnforcing&lt;Spec&gt;(\n'StorageModule',\n): Spec);\n</code></pre><p>调用：</p><pre><code class=\"language-plain\">NativeModules.StorageModule.save(\"testKey\", \"testValue\", (result)=&gt;{\n    console.info(result);\n  }\n);\nNativeModules.StorageModule.get(\"testKey\", (result)=&gt;{\n    console.info(result);\n  }\n);\n</code></pre><p>接下来我们再看看 Android 端和 iOS 端的实现。</p><h3>Android</h3><p>在实现 StorageModule 之前，我们需要在混合工程中，将 React Native 新架构的运行配置搭建好，这套配置可以运行 TurboModule、Fabric，后面的 Fabric 案例也是基于此配置来运行的。</p><p>而且，上一讲在我们已经讲解了如何基于 React Native 最新版本（0.68.0）搭建混合应用，我们再这个基础上开启新架构配置就好了。</p><p><strong>第一步，我们要做些准备工作，也就是获取 newarchitecture 的模版代码。</strong></p><p>我们以 0.68.0 版本创建一个 React Native 工程，来获取新架构的模版代码，我们把这个工程名叫做ReactNativeNewArch：</p><pre><code class=\"language-plain\">npx react-native init ReactNativeNewArch --version 0.68.0\n</code></pre><p>创建好后，你将看到如下工程代码，包含 Java 和 C++：</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/3a/f64e5f3da0730b6a6a8928dc9736ea3a.png?wh=1164x1394\" alt=\"图片\"></p><p>这些工程代码主要是新架构的 JSI、Fabric、TurboModule 的注册和加载代码，内部逻辑非常复杂，这一讲我们就不做过多分析了，先专注于实操部分。</p><p>如果我们想基于这个 Demo 去运行新架构，可以做如下操作：</p><pre><code class=\"language-plain\">1. 修改 android 目录下的 gradle.properties:\n# 开启新架构\nnewArchEnabled=true\n# 配置 java home 为 JDK 11\norg.gradle.java.home=/Library/Java/JavaVirtualMachines/jdk-11.0.2.jdk/Contents/Home\n\n2. 运行\nyarn react-native run-android\n</code></pre><p><strong>第二步，拷贝 newarchitecture 的模版代码到我们之前的混合工程。</strong></p><p>这一步中，我们需要将 Java 层和 C++ 层代码拷贝到混合工程中，需要拷贝的相关代码如下：</p><pre><code class=\"language-plain\">Java 层：\n- MainComponentsRegistry.java\n- MainApplicationTurboModuleManagerDelegate.java\n\nC++ 层：\n- jni 目录\n</code></pre><p>拷贝完的效果是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/73/b51022154e4d1831428ced687c224173.png?wh=880x1076\" alt=\"图片\"></p><p><strong>第三步是修改拷贝的代码，主要是下面这四点。</strong></p><p><strong>1.MainApplicationTurboModuleManagerDelegate.java：</strong></p><p>修改 so 库名称为我们自定义名称 geektime_new_arch。</p><pre><code class=\"language-plain\">@Override\nprotected synchronized void maybeLoadOtherSoLibraries() {\n  if (!sIsSoLibraryLoaded) {\n    SoLoader.loadLibrary(\"geektime_new_arch\");\n    sIsSoLibraryLoaded = true;\n  }\n}\n</code></pre><p><strong>2.jni/Android.mk：</strong>修改 Android.mk 中的 so 库名称为上面的 geektime_new_arch。</p><pre><code class=\"language-plain\"># You can customize the name of your application .so file here.\nLOCAL_MODULE := geektime_new_arch\n</code></pre><p><strong>3.jni/MainApplicationTurboModuleManagerDelegate.h：</strong>修改 MainApplicationTurboModuleManagerDelegate 对应的 Java 类路径，截图中拷贝好的 MainApplicationTurboModuleManagerDelegate.java 路径为 com/reactnativenewarch/newarchitecture/modules。</p><pre><code class=\"language-plain\">static constexpr auto kJavaDescriptor =\n    \"Lcom/reactnativenewarch/newarchitecture/modules/MainApplicationTurboModuleManagerDelegate;\";\n</code></pre><p><strong>4.jni/MainComponentsRegistry.h：</strong>修改 MainComponentsRegistry 对应的 Java 类路径，截图中拷贝好的 MainComponentsRegistry.java 路径为 com/reactnativenewarch/newarchitecture/components。</p><pre><code class=\"language-plain\">constexpr static auto kJavaDescriptor =\n    \"Lcom/reactnativenewarch/newarchitecture/components/MainComponentsRegistry;\";\n</code></pre><p><strong>做完后，最后一步就是修改 React Native 初始化代码了。</strong></p><p>这里有两处要修改。第一处是设置 ReactPackageTurboModuleManagerDelegateBuilder 为上面的 MainApplicationTurboModuleManagerDelegate（TurboModule 用）；第二处是设置 setJSIModulesPackage（Fabric 用，JSI 实现）：</p><pre><code class=\"language-plain\">public void initRN() {\n    ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()\n        .setApplication((Application) getApplicationContext())\n        .addPackage(new MainReactPackage())\n        .setJSMainModulePath(\"index.android\")\n        .setInitialLifecycleState(LifecycleState.BEFORE_CREATE)\n        .setReactPackageTurboModuleManagerDelegateBuilder(new MainApplicationTurboModuleManagerDelegate.Builder())\n        .setJSIModulesPackage(getJSIModulePackage());\n\n    ReactInstanceManager reactInstanceManager = builder.build();\n}\n</code></pre><p>其中 getJSIModulePackage() 我特意摘出来放在了下面。这段代码实现需要从模版代码的 MainApplicationReactNativeHost 的 getJSIModulePackage 拷贝，内部调用了上面的 MainComponentsRegistry 进行注册：</p><pre><code class=\"language-plain\">static JSIModulePackage getJSIModulePackage() {\n  return new JSIModulePackage() {\n    @Override\n    public List&lt;JSIModuleSpec&gt; getJSIModules(\n      final ReactApplicationContext reactApplicationContext,\n      final JavaScriptContextHolder jsContext) {\n      final List&lt;JSIModuleSpec&gt; specs = new ArrayList&lt;&gt;();\n      specs.add(\n          new JSIModuleSpec() {\n            @Override\n            public JSIModuleType getJSIModuleType() {\n              return JSIModuleType.UIManager;\n            }\n\n            @Override\n            public JSIModuleProvider&lt;UIManager&gt; getJSIModuleProvider() {\n              final ComponentFactory componentFactory = new ComponentFactory();\n              CoreComponentsRegistry.register(componentFactory);\n              MainComponentsRegistry.register(componentFactory);\n\n              List&lt;ViewManager&gt; viewManagers = new ArrayList&lt;&gt;();\n              ViewManagerRegistry viewManagerRegistry = new ViewManagerRegistry(viewManagers);\n              return new FabricJSIModuleProvider(\n                  reactApplicationContext,\n                  componentFactory,\n                  new EmptyReactNativeConfig(),\n                  viewManagerRegistry);\n            }\n          });\n      return specs;\n    }\n  };\n}\n</code></pre><p>至此，我们新架构的运行环境就配置好了。由于目前新架构文章非常少，几乎没有混合工程运行新架构的方案，上面这些主要是我们用了大量的时间去调研和测试的结果，你可以参考一下。</p><p>好了，回到正题。在混合工程中，新架构的运行环境搭建好后，我们就可以简单快速地来写 TurboModule 和 Fabric 了。</p><p>我们继续来进行数据存储的 Demo 在 Java 层定义并实现  StorageModule。Android 端我们使用 SharedPreferences 来实现轻量级偏好存取。这里要注意，你需要继承 ReactModuleWithSpec和TurboModule，具体代码如下：</p><pre><code class=\"language-plain\">// 1. 定义 StorageModule，继承 ReactContextBaseJavaModule 类\n// 实现 ReactModuleWithSpec &amp; TurboModule 接口\npublic class StorageModule extends ReactContextBaseJavaModule\n    implements ReactModuleWithSpec, TurboModule {\n    // native 存储的 sp 文件名称\n    private static final String SP_NAME = \"rn_storage\";\n    // 返回给 JS 的结果码\n    private static final int CODE_SUCCESS = 1;\n    private static final int CODE_ERROR = 2;\n\n    public StorageModule(ReactApplicationContextWrapper reactContext) {\n       super(reactContext);\n    }\n\n    // 返回 module 名称，一般以类名作为 module 名称\n    @Override\n    public String getName() {\n       return StorageModule.class.getSimpleName();\n    }\n  \n    // 定义供 JS 调用的存储数据方法，isBlockingSynchronousMethod 表示是否同步执行\n    @ReactMethod(isBlockingSynchronousMethod = true)\n    public void save(String key, String value, Callback callback) {\n       WritableMap result = new WritableNativeMap();\n       // 如果 js 传入的 key 为空，则回传失败码和信息\n       if (TextUtils.isEmpty(key)) {\n           result.putInt(\"code\", CODE_ERROR);\n           result.putString(\"msg\", \"key is empty or null\");\n           callback.invoke(result);\n           return;\n       }\n       // 调用 native 的 sp 进行数据存储\n       SharedPreferences sp = getReactApplicationContext().getSharedPreferences(SP_NAME, Context.MODE_PRIVATE);\n       sp.edit().putString(key, value).apply();\n       result.putInt(\"code\", CODE_SUCCESS);\n       result.putString(\"msg\", \"save success\");\n       // 回传 js 告知存储成功\n       callback.invoke(result);\n   }\n\n    // 定义供 JS 调用的获取数据方法，isBlockingSynchronousMethod 表示是否同步执行\n   @ReactMethod(isBlockingSynchronousMethod = true)\n   public void get(String key, Callback callback) {\n      // 如果 js 传入的 key 为空，则回传失败码和信息\n      WritableMap result = new WritableNativeMap();\n      if (TextUtils.isEmpty(key)) {\n         result.putInt(\"code\", CODE_ERROR);\n         result.putString(\"msg\", \"key is empty or null\");\n         callback.invoke(result);\n         return;\n      }\n      // 调用 native 的 sp 获取 key 对应的 value 值\n      SharedPreferences sp = getReactApplicationContext().getSharedPreferences(SP_NAME, Context.MODE_PRIVATE);\n      String value = sp.getString(key, \"\");\n      result.putInt(\"code\", CODE_SUCCESS);\n      result.putString(\"data\", value);\n      // 将结果回传给 js\n      callback.invoke(result);\n  }\n}\n</code></pre><p>然后是注册组件，注意 Package 需要继承 TurboReactPackage：</p><pre><code class=\"language-plain\">public class MyTurboModulePackage extends TurboReactPackage {\n    @Override\n    public NativeModule getModule(String name, ReactApplicationContext reactContext) {\n        switch(name) {\n           case \"StorageModule\":\n              return new StorageModule(reactContext);\n              break;\n           default:\n              return null;\n        }\n    }\n    \n    @Override\n    public ReactModuleInfoProvider getReactModuleInfoProvider() {\n      //...\n    }\n}\n</code></pre><p>接下来注册到 ReactInstanceManager （使用 reactInstanceManagerBuilder注册）：</p><pre><code class=\"language-plain\">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()\n   .addPackage(new MyTurboModulePackage());\n... // 其他 RN 初始化配置\nReactInstanceManager reactInstanceManager = builder.build();\n</code></pre><p>然后我们利用新架构提供的 Codegen，生成新架构需要的 native 代码。不过，在使用 codegen 之前，我们需要在项目中应用相关的插件：</p><p>(1) 在工程根目录安装 react-native-gradle-plugin。</p><pre><code class=\"language-plain\">yarn add react-native-gradle-plugin\n</code></pre><p>(2) 在工程根目路的 settings.gradle 中配置 react-native-gradle-plugin，使用复合构建引入。</p><pre><code class=\"language-plain\">include ':app'\nrootProject.name = \"GeekTimeRNAndroid\"\nincludeBuild('./node_modules/react-native-gradle-plugin')\n</code></pre><p>(3) 在 app/build.gradle 中应用插件。</p><pre><code class=\"language-plain\">apply plugin: \"com.facebook.react\"\n</code></pre><p>这样做后，工程的 gradle 任务中就会出现 generateCodegenArtifactsFromSchema task。</p><pre><code class=\"language-plain\">配置好后，我们以后就可以使用 codegen 能力了，然后执行 generateCodegenArtifactsFromSchema，最后运行App就可以了。\n../gradlew generateCodegenArtifactsFromSchema\n</code></pre><p>Android端的就是这样，现在我们看iOS端需要怎么做。</p><h3>iOS</h3><p>在iOS端中，首先我们要创建一个类并遵循一个协议 spec ，协议中包含注册的API声明。而且，该协议需要遵循 RCTBridgeModule 协议和 RCTTurboModule 协议，并且创建一个JSI。示例代码如下：</p><pre><code class=\"language-plain\">//定义一个Spec协议\n@protocol DataStorageTurboModuleSpec &lt;RCTBridgeModule, RCTTurboModule&gt;\n- (NSString *)getString:(NSString *)string;\n@end\n\n//JSI实现\nnamespace facebook {\nnamespace react {\nclass JSI_EXPORT DataStorageTurboModuleSpecJSI : public ObjCTurboModule {\n&nbsp;  public:\n&nbsp;   DataStorageTurboModuleSpecJSI(const ObjCTurboModule::InitParams &amp;params);\n  };\n} // namespace react\n} // namespace facebook\n\n//定义一些方法\nnamespace facebook {\n&nbsp; namespace react {\n&nbsp; &nbsp;&nbsp;static facebook::jsi::Value __hostFunction_DataStorageTurboModuleSpecJSI_getString(\n&nbsp; &nbsp; facebook::jsi::Runtime &amp;rt,\n&nbsp; &nbsp; TurboModule &amp;turboModule,\n&nbsp; &nbsp; const facebook::jsi::Value *args,\n&nbsp; &nbsp; size_t count){\n&nbsp;   return static_cast&lt;ObjCTurboModule &amp;&gt;(turboModule)\n&nbsp; &nbsp; &nbsp; .invokeObjCMethod(rt, VoidKind, \"getString\", @selector(getString:), args, count);\n  }\n&nbsp;&nbsp; DataStorageTurboModuleSpecJSI::NativeSampleTurboModuleSpecJSI(const ObjCTurboModule::InitParams &amp;params)\n&nbsp; &nbsp; : ObjCTurboModule(params)\n&nbsp; {\n    //MethodMetadata 第一个参数为0代表该方法有一个参数\n&nbsp; &nbsp; methodMap_[\"getString\"] = MethodMetadata{1, __hostFunction_DataStorageTurboModuleSpecJSI_getString};\n&nbsp; }\n}\n}\n\n//TurboModule遵循Spec协议\n@interface DataStorageTurboModule : NSObject &lt;DataStorageTurboModuleSpec&gt;\n\n@end\n</code></pre><p>之后，我们要在该类中注册组件名和API：</p><pre><code class=\"language-plain\">//DataStorageTurboModule.mm\n@implementation DataStorageTurboModule\nRCT_EXPORT_MODULE()\n\n- (std::shared_ptr&lt;facebook::react::TurboModule&gt;)getTurboModule:\n&nbsp; &nbsp; (const facebook::react::ObjCTurboModule::InitParams &amp;)params{\n  //指定JSI\n&nbsp; return std::make_shared&lt;DataStorageTurboModuleSpecJSI&gt;(params);\n}\n\nRCT_EXPORT_METHOD(getString:(NSString *)string){\n  NSLog(@\"\");\n}\n@end\n</code></pre><p>以上便是自定义一个 TurboModule的流程。其实定义 TurboModule 并不复杂，而且 Facebook 也提供了代码生成工具 codegen，比较复杂的是在混合工程中搭建新架构的运行环境。前面我们花了不少内容讲述如何在客户端开启新架构，接下来的 Fabric 组件介绍也将在新架构环境基础上进行讲解，接下来我们继续来看Fabric 自定义组件。</p><h2>Fabric：视频播放</h2><p>Fabric 对标旧框架的 UIManager。FabricUIManager 可以和 C++ 层直接进行通讯，解除了原有的 UIManager 依赖单个 bridge 的问题。有了 JSI 后，以前批量依赖 bridge 的 UI 操作，都可以同步执行到 C++ 层，性能得到大幅提升，特别是在列表快速滑动、复杂动画交互方面提升更加明显。</p><p>现在，我们以一个视频播放组件为例，讲讲如何定义 Fabric 组件。我们先来看下 JavaScript 端的实现。</p><h3>JavaScipt</h3><p>JavaScript需要定义属性以及 API，并 export 组件。示例代码如下：</p><pre><code class=\"language-plain\">type NativeProps = $ReadOnly&lt;{|\n  ...ViewProps,\n  url?: string\n|}&gt;; // 定义视频播放的属性，url 为视频地址\n\nexport type VideoViewType = HostComponent&lt;NativeProps&gt;;\n\n// 定义视频播放的方法，包括开始播放、停止播放、暂停播放\ninterface NativeCommands {\n  +callNativeMethodToPlayVideo: (\n  ) =&gt; void;\n  +callNativeMethodToStopVideo: (\n  ) =&gt; void;\n  +callNativeMethodToPauseVideo: (\n  ) =&gt; void;\n}\n\n//导出外部调用的命令，包括开始播放、停止播放、暂停播放\nexport const Commands: NativeCommands = codegenNativeCommands&lt;NativeCommands&gt;({\n  supportedCommands: ['callNativeMethodToPlayVideo'],\n  supportedCommands: ['callNativeMethodToStopVideo'],\n  supportedCommands: ['callNativeMethodToPauseVideo'],\n});\n\n// 导出包装好的组件，其中 VideoView 为引入 Native 的组件\nexport default (codegenNativeComponent&lt;NativeProps&gt;(\n  'VideoView',\n): VideoViewType);\n\n</code></pre><p>JavaScript 端使用该组件：</p><pre><code class=\"language-plain\">// 导入 ViewView 组件和工具\nimport VideoView, {\n  Commands as VideoViewCommands,\n} from './VideoNativeComponent';\n\n// 外部调用此方法即可调用 ViewView 视频播放能力\nexport default function MyView(props: {}): React.Node {\n  return (\n     &lt;View&gt;\n         &lt;VideoView url={\"url\"} style={{flex: 1}} /&gt;\n         &lt;Button title=\"play\" onPress={()=&gt;{\n             VideoViewCommands.callNativeMethodToPlayVideo();\n           }\n         }\n     &lt;/View&gt;\n  )\n}\n</code></pre><p>接下来我们再看看 Android 端和 iOS 端的实现。</p><h3>Android</h3><p>由于在前面 TurboModule 的部分，我们已经讲解了如何在混合工程中开启新架构运行模式，我么这里就不再重复了。前面的方法同样适用于 Fabric，我们只需要搭建一次就好了。所以现在要在 Android 端实现 Fabric 组件也非常简单，我们来看下具体实现。</p><p><strong>第一步，定义视频播放接口。</strong></p><p>这里我们要定义 VideoViewManagerInterface，其中包含三个方法：播放视频、停止播放、暂停播放：</p><pre><code class=\"language-plain\">public interface VideoViewManagerInterface&lt;T extends View&gt; {\n   void playVideo(T view, String url);\n   void stopVideo(T view);\n   void pauseVideo(T view);\n}\n</code></pre><p><strong>第二步，定义视频播放 View。</strong></p><p>这一步中，我们要实现视频播放的 View。在 View 中，我们需要实现视频的播放、停止和暂停功能。但播放能力的实现并不是我们讲解的重点，我们这一讲侧重于新架构中 Frabic 组件的实现流程，所以我们这边使用伪代码：</p><pre><code class=\"language-plain\">public class MyVideoView extends View {\n   // ...\n     \n   public void playVideo(String url) {\n       // 播放视频实现\n   }\n     \n   public void stopVideo() {\n      // 停止视频播放实现\n   }\n\n   public void pauseVideo() {\n      // 暂停视频播放实现\n   }\n}\n</code></pre><p><strong>第三步，定义 ViewManager。</strong></p><p>在这一步中，我们要实现暴露给 React Native 调用的能力，包括视频播放、停止，以及暂停，内部会转发到上面我们定义的视频播放 View 的实现中。示例代码如下：</p><pre><code class=\"language-plain\">@ReactModule(name = VideoViewManager.REACT_CLASS)\npublic class VideoViewManager: ViewGroupManager&lt;VideoView&gt;(), VideoViewManagerInterface&lt;VideoView&gt; {\n     private static final String REACT_CLASS = \"VideoView\";\n     \n     public VideoViewManager() {\n     }\n\n     override\n     public String getName() {\n        return REACT_CLASS;\n     }\n     \n     override\n     public VideoView createViewInstance(ThemedReactContext reactContext) {\n        return new MyVideoView(reactContext);\n     }\n     \n     @ReactProp(name = \"url\")\n     override \n     public void playVideo(VideoView view, String url) {\n        view.playVideo(url);\n     }\n     \n     override \n     public void stopVideo(VideoView view) {\n        view.stopVideo();\n     }\n\n     override \n     public void pauseVideo(VideoView view) {\n        view.pauseVideo();\n     }\n}\n</code></pre><p><strong>最后一步就是注册 ViewManager。</strong>我们在 ReactInstanceManager 的 JSIModulesPackage 中注册 VideoViewManager：</p><pre><code class=\"language-plain\">List&lt;ViewManager&gt; viewManagers = new ArrayList&lt;&gt;();\nviewManagers.add(new VideoViewManager())\nViewManagerRegistry viewManagerRegistry = new ViewManagerRegistry(viewManagers);\n\nreturn new FabricJSIModuleProvider(\n    reactApplicationContext,\n    componentFactory,\n    new EmptyReactNativeConfig(),\n    viewManagerRegistry);\n</code></pre><p>然后我们利用新架构提供的 Codegen，调用 gradlew generateCodegenArtifactsFromSchema 生成代码 Native 代码：</p><pre><code class=\"language-plain\">../gradlew generateCodegenArtifactsFromSchema\n</code></pre><p>最后，运行即可。Android 端的实现就是这样，接下来我们再看下 iOS 端。</p><h3>iOS</h3><p>在iOS端汇总，首先我们要创建一个继承于RCTViewComponentView 的一个类作为视频组件，如下：</p><pre><code class=\"language-plain\">@interface VideoComponentView : RCTViewComponentView\n//声明播放器组件的一些方法\n//播放视频\n- (void)playVideo;\n//停止视频\n- (void)stopVideo;\n//暂停视频\n- (void)pauseVideo;\n@end\n</code></pre><p>之后，该类需要遵循一个协议，协议中需要声明执行Command的方法名，示例代码如下：</p><pre><code class=\"language-plain\">@protocol VideoComponentViewProtocol &lt;NSObject&gt;\n- (void)callNativeMethodToPlayVideo;\n- (void)callNativeMethodToStopyVideo;\n- (void)callNativeMethodToPauseVideo;\n@end\n\nRCT_EXTERN inline void VideoComponentCommand(\n        id&lt;VideoComponentViewProtocol&gt; componentView,\n&nbsp;       NSString const *commandName,\n&nbsp;       NSArray const *args)\n\n    if([commandName isEqualToString:@\"callNativeMethodToPlayVideo\"]){\n        [componentView callNativeMethodToPlayVideo];\n        return;\n    }\n    \n    if(![commandName isEqualToString:@\"callNativeMethodToStopVideo\"]){\n        [componentView callNativeMethodToStopVideo];\n        return;\n    }\n    \n    if(![commandName isEqualToString:@\"callNativeMethodToPauseVideo\"]){\n        [componentView callNativeMethodToPauseVideo];    \n        return;\n    }\n    return;\n)\n</code></pre><p>接下来，ComponentView需要遵循该Protocol协议，并在执行common时调用对应的方法。此外，我们还可以设置组件的属性：</p><pre><code class=\"language-plain\">using namespace facebook::react;\n\n@interface VideoComponentView() &lt;VideoComponentViewProtocol&gt;\n@end\n\n@implementation VideoComponentView{\n  VideoPlayer *_videoPlayer;\n}\n\n#pragma mark - Native Commands\n- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args{\n&nbsp; VideoComponentCommand(self, commandName, args);\n}\n\n- (void)callNativeMethodToPlayVideo{\n&nbsp; //实现视频播放功能\n  [_videoPlayer startPlay];\n}\n\n- (void)callNativeMethodToStopVideo{\n  //实现视频停止功能\n  [_videoPlayer stopPlay];\n}\n\n- (void)callNativeMethodToPauseVideo{\n  //实现视频暂停功能\n  [_videoPlayer pausePlay];\n}\n\n#pragma mark - Props\n//遵循descriptor协议\n+ (ComponentDescriptorProvider)componentDescriptorProvider{\n&nbsp; return concreteComponentDescriptorProvider&lt;VideoComponentDescriptor&gt;();\n}\n\n- (instancetype)initWithFrame:(CGRect)frame{\n&nbsp; if (self = [super initWithFrame:frame]) {\n&nbsp; &nbsp; static const auto defaultProps = std::make_shared&lt;const ComponentViewProps&gt;();\n&nbsp; &nbsp; _props = defaultProps;\n\n&nbsp; &nbsp; _videoPlayer = [[VideoPlayer alloc] init];\n&nbsp; &nbsp; self.contentView = _videoPlayer;\n&nbsp; }\n&nbsp; return self;\n}\n\n- (void)updateProps:(Props::Shared const &amp;)props oldProps:(Props::Shared const &amp;)oldProps{\n&nbsp; [super updateProps:props oldProps:oldProps];\n}\n\n- (void)onChange:(UIView *)sender{\n&nbsp; // No-op\n&nbsp; //&nbsp; std::dynamic_pointer_cast&lt;const ViewEventEmitter&gt;(_eventEmitter)\n&nbsp; //&nbsp; &nbsp; &nbsp; -&gt;onChange(ViewEventEmitter::OnChange{.value = static_cast&lt;bool&gt;(sender.on)});\n}\n\n@end\n\nClass&lt;RCTComponentViewProtocol&gt; VideoViewCls(void){\n&nbsp; return VideoComponentView.class;\n}\n</code></pre><p>接着，注册属性遵循VideoComponentDescriptor，并且需要指定该组件的名字：</p><pre><code class=\"language-plain\">namespace facebook {\nnamespace react {\nusing VideoComponentDescriptor = ConcreteComponentDescriptor&lt;VideoViewShadowNode&gt;;\n} // namespace react\n} // namespace facebook\n\nnamespace facebook {\nnamespace react {\n    extern const char VideoViewComponentName[];\n    using VideoViewShadowNode = ConcreteViewShadowNode&lt;\n&nbsp; &nbsp;      VideoViewComponentName,//组件名\n&nbsp; &nbsp;      VideoViewProps&gt;;//注册属性\n} // namespace react\n} // namespace facebook\n\nnamespace facebook {\nnamespace react {\nextern const char VideoViewComponentName[] = \"VideoView\";//组件名\n} // namespace react\n} // namespace facebook\n\nnamespace facebook {\nnamespace react {\n//属性定义\nclass VideoViewProps final : public ViewProps {\n&nbsp;public:\n&nbsp; VideoViewProps() = default;\n&nbsp; VideoViewProps(const PropsParserContext&amp; context, const VideoViewProps &amp;sourceProps, const RawProps &amp;rawProps);\n\n  #pragma mark - Props\n  std::string url{\"\"};//视频url\n};\n} // namespace react\n} // namespace facebook\n\n</code></pre><p>这样，我们就创建好了一个 React Native 的 Fabric 组件、定义属性以及 API 的方法。<br>\n以上便是如何使用 Fabric 自定义视频播放组件，在混合工程中搭建好新架构的运行环境后，只需要遵守 Fabric 的组件定义方式，进行接口定义、功能实现和组件注册即可。关于一些复杂的 Fabric 组件，可以查看 <a href=\"https://github.com/software-mansion/react-native-gesture-handler/tree/main/FabricExample\">https://github.com/software-mansion/react-native-gesture-handler/tree/main/FabricExample</a>，<a href=\"https://github.com/software-mansion/react-native-reanimated/tree/main/FabricExample\">https://github.com/software-mansion/react-native-reanimated/tree/main/FabricExample</a>，目前 react-native-gesture-handler、react-native-reanimated 都已经适配了新架构，感兴趣的同学可以去学习下。</p><h2>总结</h2><p>这一讲，我们系统讲解了个性化组件的使用场景、生命周期、传输类型，以及通信方式，并通过两个实际案例讲解了如何在新架构下定制个性化的 TurboModules 与 Fabric。而且，我们也简单介绍了一下React Native新架构，你可以通过官方文档进行新架构的体验。</p><p>这一讲是我们 Native 相关的三讲中花的时间最长的，也是最“伤肝”的，我们前前后后加调研花了两个月的时间。但我们相信，新架构在未来会有很好的发展，这是可以预见的。因为它解决了 React Native 几个最痛的点，包括启动速度、运行时性能等。如果新架构还能在易用性上继续优化，将会大大拓展 React Native 的用户群体。</p><p>因为目前新架构还处于未发布的状态，网上相关的文章大都是对官方纯 React Native 模式 Demo 和介绍，少数几篇会深挖原理，但讲混合模式的新架构运行文章几乎没有。我们这一讲中对 TurboModule 和 Fabric 的讲解，更侧重于如何在混合工程中开启并运行。如果有对 TurboModule、Fabric、JSI 的原理感兴趣的同学，后面有机会我们再来分享。</p><h2>作业</h2><ol>\n<li>设计一个打印 Native 日志的 TurboModule，以及一个 Native 加载进度条的 Fabric 组件。</li>\n</ol><p>欢迎在评论区写下你的想法和经验，和我们多多交流。我们下一讲见。</p>","neighbors":{"left":{"article_title":"21｜混合应用：如何从零开始集成 React Native？","id":518965},"right":{"article_title":"23｜热更新：如何搭建一个热更新平台？","id":520647}}},{"article_id":520647,"article_title":"23｜热更新：如何搭建一个热更新平台？","article_content":"<p>你好，我是蒋宏伟。</p><p>在第21讲中，众文和惠姝两位老师站在客户端的角度，介绍了自研 React Native 热更新需要做什么。今天，我会站在服务端的角度，聊聊如何搭建一个热更新平台。</p><p>React Native 的热更新实际上包括两部分：一部分是客户端逻辑，另一部分就是热更新平台。客户端部分需要 iOS、Android 方向同学的配合，热更新平台部分需要 Web、Node.js，甚至是 Java 方向同学的配合。</p><p>当然，只用一讲的内容，是很难把热更新平台讲透的。因此，我会先从整体上为你讲解热更新的原理和业内常见方案，当业内方案满足不了你的业务需求时，这时你就可以选择进行自研了。这一讲中我也给你准备了两套自研方案，你既可以选择无成本的 CDN 方案，也可以选择高可靠性的版本方案。</p><p>无论你的热更新需求是什么样的，总有一套方案是适合你的。</p><h2>什么是热更新？</h2><p>有些同学可能还对 React Native 热更新不太熟悉，我先简单介绍一下什么是热更新。</p><p>热更新，也叫做动态更新，它是一种类似 Web 的更新方式。相对于 App 的发版更新而言，热更新能提升业务的迭代效率。我们都知道，互联网业务讲究兵贵神速，如果业务能够通过热更新来快速发版和迭代，这就相当于在产品和用户之间搭建了一座能够随时通行的桥梁，代替了原来好几周才有一趟的渡轮。</p><!-- [[[read_end]]] --><p>那么，热更新和发版更新有什么不同呢？为什么热更新比发版更新快这么多呢？我给你画了这两种更新方式的原理对比图，你可以先看下：</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/02/4d1730d2b6a7e7yyf669e7f2f418e502.png?wh=1920x839\" alt=\"图片\"></p><p>发版更新，指的是你把 React Native App，当作 Android App 和 iOS App，按照 Android、iOS 上架流程，通过各自的应用商店进行更新。通常每个 Native App 都会有一个自己的上架节奏，可能是两周，也可能是 4 周。此外，从提交应用商店到审核通过，也需要等上几天时间。甚至，即便新版本上架了，用户更新到最新版本也需要一个过程，可能需要一个月的时间，新版本才能覆盖到 90% 的用户。</p><p>所以说，如果你的 React Native App 选择发版更新，就会受到发版节奏、审核耗时和版本覆盖耗时的影响，这些都会导致业务迭代速度变慢。</p><p>不过，React Native 的热更新就可以绕过应用商店直接进行更新。只要你的是集成热更新功能的 React Native App，在应用商店上架过一次之后，后续你的业务都可以走你自己的热更新流程，再也不用依赖应用商店发版。这样你的业务就能随时上线，随时更新了。</p><p>也因为这个原因，热更新在国内也是大受欢迎。</p><h2>热更新方案</h2><p>既然热更新这么好用，那怎么把热更新用起来呢？业内都有哪些方案呢？当前，业内的主流方案有四种：<a href=\"https://docs.microsoft.com/zh-cn/appcenter/distribution/codepush/rn-overview#store-guideline-compliance\">Code Push</a>、<a href=\"https://pushy.reactnative.cn/\">Pushy</a>、<a href=\"https://docs.expo.dev/distribution/hosting-your-app/\">Expo</a> 和自研。</p><p>但由于国内网络环境的原因，访问国外的云服务速度比较慢，所以我不太推荐你直接使用 Code Push 和 Expo。Code push 是微软 App Center 的服务之一，它底层用的是微软自家的 Azure 云服务；Expo 使用的是亚马逊的 AWS 和 Google Cloud 云服务。</p><p>如果你不嫌麻烦，可以基于 Code Push 或 Expo 自行搭建。基于 Code Push 自行搭建的方案我其实不太熟悉，不清楚基于 Code Push 自行搭建需要多少成本。这里我就引用群友“问题本人”的回答，他说：</p><blockquote>\n<p>Code Push 可以自己搭建一套，哪怕你不是后端，前端自己去搭建，耗费个三两天就可以了。</p>\n</blockquote><p>如果你想使用 Expo 替换云服务商的方案，可以参考一下<a href=\"https://docs.expo.dev/distribution/hosting-your-app/\">官方文档</a>。</p><p>如果你嫌自己搭建太麻烦，你也可以看看 React Native 中文网提供的 <a href=\"https://pushy.reactnative.cn/\">Pushy</a> 热更新方案。它使用的是国内的阿里云服务，且有比前两者更省流量的差量更新方案，应该是国内目前市面上唯一可以直接使用的开源热更新方案了。</p><p>不过，我最熟悉的热更新方案，还是自研方案。所以接下来，我就基于自研方案，和你介绍一下热更新的原理，帮你搞清楚热更新究竟是怎么一回事，自研热更新平台又需要注意些什么。</p><h2>热更新平台的原理</h2><p>说到自研热更新平台，如果你没有接触过，可能会认为很难，但真实情况真是如此吗？</p><p>其实，自研热更新平台的难度主要体现在<strong>如何大规模应用</strong>上。对于规模小的应用来说，搭建一个自研热更新平台并不难。</p><p>一个自研热更新平台，主要包括这两个部分：</p><ul>\n<li>打包服务：Bundle Server；</li>\n<li>静态资源服务：Static Server。</li>\n</ul><p>所谓的打包服务，是将 React Native 项目中的所有 JavaScript 代码打包成一个 Bundle 文件的服务。而所谓的静态资源服务，是将 Bundle 文件分发给客户端的服务；当客户端拿到 Bundle 代码后，执行 Bundle 文件，就能渲染 React Native 应用/页面了。</p><p>这个流程有没有让你想起启动项目时的 npm start？ 是的，理论上，你在本地通过 npm start 启动的 Metro 服务时，Metro 服务就同时具备了打包和静态资源下发两种功能，再配合框架默认的代码加载功能，也能完成热更新。</p><p>也就是说，你找台服务器把 React Native 代码放上去，运行 npm start 命令，然后在客户端配置对应的 ip 和端口号，并把相关的调试开关给关了，这时访问 npm start 服务客户端也能把 React Native 页面渲染出来。然后你再用 npm start 启动的 Metro 服务，就具备了“热更新平台”最基础的两个功能了。</p><p>当然，这个最简单的热更新流程是不能跑在线上的，毕竟 npm start 的本意是用于调试的，它的首次加载耗时太长，扛不住高并发，而且服务可用性也是问题。</p><h2>CDN 热更新方案</h2><p>既然，npm start 的热更新方案不太靠谱，那有没有靠谱点的热更新方案呢？有，接下来我要给你介绍的 CDN 热更新方案就是既简单又实用。</p><p>我给你画了一张 npm start 方案和 CDN 方案的对比图，你看一下就能明白它们之间的区别了：</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/4d/3ec5299804022c564fbdba036fd3a94d.png?wh=1920x830\" alt=\"图片\"></p><p>在 npm start 方案中，Metor Server 提供了代码打包和 Bundle 下发的功能。而在 CDN 方案中，代码打包是通过 react-native&nbsp;bundle 命令提供的，Bundle 下发的能力是通过 CDN 提供的。</p><p>那么CDN方案到底是怎样的呢？我们简单看下它的操作流程。</p><p><strong>首先，你可以通过 react-native bundle 命令，提前把 JavaScript 代码打包成一个 Bundle 文件</strong>，命令如下：</p><pre><code class=\"language-plain\">npx react-native bundle --entry-file index.tsx --dev false --minify false --bundle-output ./build/index.bundle --assets-dest ./build\n</code></pre><p>通过上述命令打包出来的是 index.bundle 文件，本质是一个可执行的 JavaScript 文件。</p><p>如果你使用的是 Hermes，那么你还需要把 JavaScript 文件转成相应的字节码文件。Hermes 提供了把 JavaScript 文件转成字节码文件的方案，你可以先按照 <a href=\"https://github.com/facebook/hermes/blob/main/doc/BuildingAndRunning.md\">文档</a> 搭建 Hermes 环境，然后执行如下命令进行转换：</p><pre><code class=\"language-plain\">hermes -emit-binary -out ./build/index.hbc ./build/index.bundle\n</code></pre><p>转换完成后，你就有了一个 .hbc 的字节码包了，其中 .hbc 的意思是 Hermes Bytecode。</p><p><strong>完成打包之后的第二步，就是将包上传到 CDN 上。</strong>这里你可以选择阿里云、腾讯云或者是你们公司内部的提供的 OSS 和 CDN 服务。</p><p>我们以阿里云为例。在第一次使用时，你可以先<a href=\"https://help.aliyun.com/document_detail/31886.html\">将包文件上传到 OSS</a>，然后<a href=\"https://help.aliyun.com/document_detail/123227.html\">开启 CDN 加速</a>。这两步和你选择的 CDN 服务商有关系，你参考相关文档操作即可。</p><p>完成文件上传 CDN 这一步后，你会得到一个 CDN 地址，你可以用该地址来访问你的文件，例如：</p><pre><code class=\"language-plain\">https://static001.geekbang.org/resource/rn/index.bundle\n</code></pre><p>拿到包地址后，热更新最后一步是，在客户端请求和加载该地址的 .bundle 文件或 .hbc 文件，这样就完成热更新的整个流程了。</p><p>以上就是第一次热更新的流程。我们第一次把包上传到 CDN时，CDN 文件是新创建的，但如果代码再次更新了，要怎么更新 CDN 上的包文件呢？</p><p>更新版本的方案就是<strong>用新包把老包给覆盖掉</strong>。</p><p>在 CDN 方案中，CDN 地址是固定不变的，老包用的地址是 /resource/rn/index.bundle，那么新包用的地址也得是 /resource/rn/index.bundle。例如，你可以使用阿里云提供的 <a href=\"https://help.aliyun.com/document_detail/27140.html\">CDN 刷新</a> 功能，用新包把老包给覆盖掉。</p><p><strong>CDN 方案非常适合小流量的业务。</strong>而且它解决了 npm start 方案存在的三个问题，包括首次加载耗时长的问题、扛不住高并发的问题和服务可用性低的问题。</p><p>这是因为，热更新包是提前打好并放到 CDN 上的，无需像 npm start 一样，在首次加载时需要长时间的等待打包。其次，CDN 通过上千台分布在全国各地的机器，解决了高并发的问题，即便同一秒钟有上万的用户并发访问， CDN 都完全能抗住。并且，你不需要使用 Java 或者 node.js 去搭建高可用的热更新后台，像阿里云、腾讯云这种大家都用的 CDN 服务，它们的可用性比我们自己搭建的服务可高太多了。</p><p>而且，类似阿里云这样的云服务提供商，还贴心地提供了 <a href=\"https://help.aliyun.com/document_detail/69709.html\">自定义脚本发布静态资源</a> 的功能，这又进一步降低了部署的成本。</p><p>因此，如果你的业务流量不是很大，你完全可以依托于阿里云、腾讯云这样的 CDN 服务，零成本自建热更新平台。</p><h2>纯 CDN 方案的弊端</h2><p>但是对于大流量业务，我并不推荐你用纯 CDN 方案，为什么呢？</p><p>因为纯 CDN 方案，会存在<strong>几分钟的更新延迟</strong>的问题。在小流量业务中，这种几分钟的更新延迟不是什么问题，但是对于大流量业务来说，如果线上出现了一个重大 BUG，需要等几分钟才能完全回滚，那么对用户或者收入的影响会很大。</p><p>为什么纯 CDN 方案会存在几分钟的更新延迟问题呢？我们来看下一下 CDN 方案的时序图：</p><p><img src=\"https://static001.geekbang.org/resource/image/08/f9/08a5db1cacb4ee073f48d334afb9d2f9.png?wh=1920x1956\" alt=\"图片\"></p><p>上述时序图中，涉及 React Native App、CDN 边缘节点和 OSS 源站，以及 index.bundle 包文件的两个版本。旧版本包是绿色的，新版包是蓝色的。</p><p>将旧版本更新为新版本的本质是：删除 CDN 中缓存的旧版资源，当 CDN 中没有缓存了，这时来自用户的请求才不会命中 CDN 中的缓存，而是到 OSS 上拉取最新的资源，返回给 React Native App。</p><p>然而，我们都知道 CDN 指的并不是某一台具体的机器，它指的是上千个分布在全国各地的节点网络。当我们使用 CDN 的刷新能力时，实际上是删除上千个节点中的缓存。一位负责 CDN 的同学告诉我，要把这上千个节点的缓存都删除干净的时间，最长可能需要个 5 分钟吧，而且还不敢保证 5 分钟的时效性。</p><p>因此，在这 5 分钟内，会存在三种情况：情况一，命中老版缓存；情况二，未命中缓存重新拉取新版资源；情况三，命中新版缓存；</p><p><strong>这也意味着，在你享用 CDN 的低成本热更新方案的同时，你的业务得能够接受 5 分钟的渐进式的更新延迟，或者说 5 分钟的渐进式的修复 BUG 的延迟。</strong></p><h2>版本方案</h2><p>CDN 方案有最长 5 分钟延迟，那有没有解决办法呢？</p><p>解决方案就是<strong>多发一次版本请求</strong>。解决思路是这样的，既然上千个节点 CDN 更新有延迟，那么就自己搭建一个版本服务，资源依旧上传 CDN，但用版本服务来控制更新。我们不妨把该方案叫做版本方案。</p><p>版本方案的时序图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/13/19/13a3b5569c2fbe100e392416cff6fb19.png?wh=1920x1539\" alt=\"图片\"></p><p>增加一个版本服务后，你可以看到整体流程发生了一些变化。纯 CDN 方案的更新方式采用的是覆盖更新，版本服务方案采用的是<strong>告知更新</strong>。</p><p>所谓的“告知更新”是什么？我们一步一步把它讲清楚。</p><p><strong>第一步，上传 Bundle 到源站，也就是 OSS</strong>。先在将本地打包好 Bundle 文件，并将文件命名为 “MD5”.bundle 上传到 OSS 源站。此时理论上，只要 Bundle 内容发生了变化，那么生成  MD5 值就是不一样的，用 MD5 作为文件的命名能保证文件的唯一性：</p><pre><code class=\"language-plain\">// ①以 MD5 作为文件名\na1dc...d055.bundle\n</code></pre><p><strong>第二步，正式发版上线</strong>。当你要正式上线时，点击上线按钮，告诉版本服务最新的线上 Bundle 的名字，比如 a1dc…d055.bundle，这时版本服务会在内部通过 mysql 或 redis 把线上最新文件名给记录下来：</p><pre><code class=\"language-plain\">// ②记录线上版本\nonline = \"a1dc...d055.bundle\"\n</code></pre><p><strong>第三步，React Native App 发起版本请求</strong>。由于只有一个版本服务，不会存在 CDN 上千个节点在某一时刻不同步的问题，版本服务会直接把最新的 Bundle 名字告诉 React Native 应用：</p><pre><code class=\"language-plain\">// ③下发版本名字或 CDN 地址\n{uri: \"a1dc...d055.bundle\"}\n</code></pre><p><strong>第四步，React Native 发起 CDN 资源请求。</strong>资源请求会先询问某个 CDN 的边缘节点，如果该边缘节点没有缓存，则会去源站拉取 a1dc…d055.bundle；如果该边缘节点有缓存，则直接返回：</p><pre><code class=\"language-plain\">// ④请求 CDN 资源\nhttps://static001.geekbang.org/resource/rn/a1dc...d055.bundle\n</code></pre><p>然后的第⑤⑥⑦⑧步，其实和①②③④步是一样的，唯一不同的是 Bundle 文件的名字变了。整个流程如下：</p><pre><code class=\"language-plain\">// ⑤新包的 MD5 名字\na1dc...d055.bundle\n// ⑥更新最新包名\nonline = \"a1dc...d055.bundle\"\n// ⑦下发新版本名字或 CDN 地址\n{uri: \"a1dc...d055.bundle\"}\n// ⑧请求新版 CDN 资源\nhttps://static001.geekbang.org/resource/rn/8f55...d7125.bundle\n</code></pre><p>由于①②③④步的包名和⑤⑥⑦⑧步的 CDN 包名不一样，新包和旧包是同时存在于 CDN 上的，所以也就不存在要把上千个 CDN 节点的资源在同一时刻进行更新的问题了。</p><p>不过，虽然版本方案解决了更新延迟的问题，但它也不是没有弊端的。</p><p>首先，页面加载耗时会增加 200ms 左右，这是因为更新的流程多了一个版本请求。一个版本请求平均耗时大概 200ms，所以页面整体耗时也就增加了大概 200ms。其次，热更新平台的开发复杂度会高很多，你得提供高可用的热更新服务，并且能够抗住业务的高并发。</p><h2>热更新平台全貌</h2><p>无论是 CDN 热更新方案，还是版本方案，它们都不是完整的自研热更新方案，只是如何更新资源的一个切面，这个切面只解决了最基础的资源更新问题。</p><p>从我这些年来负责热更新平台的经验来看，自研热更新平台的核心难点在于，它需要你对前端、node.js、React Native，甚至 Java 都有所了解，特别是偏后端领域的知识。因为你需要解决以下问题，包括：</p><ul>\n<li>如何支持多人的并行打包；</li>\n<li>如何支持多人的并行测试；</li>\n<li>如何保障 CDN 资源更新成功；</li>\n<li>如何保障版本服务的高并发、高可用。</li>\n</ul><p>为了解决以上问题，我也根据我的经验，帮你设计了一张热更新平台的全貌图：</p><p><img src=\"https://static001.geekbang.org/resource/image/66/26/666ac2cf60675242c7bca2b50a9a2826.png?wh=1478x1796\" alt=\"图片\"></p><p>你可以看到，热更新平台整体上包括以下几个部分：</p><ul>\n<li>热更新平台后台服务：一般两台机器就行，它提供打包、测试、上线、权限管理和相应的前端页面展示等能力。</li>\n<li>MySQL、Redis：MySQL 提供持久化存储能力，Redis 用于缓存用来抗高并发，这里推荐用成熟的相关服务就行，不要自行搭建。</li>\n<li>打包集群：独立集群，至少两台机器，具体看情况而定，用于支持多人的并行打包。把它独立出来的原因是，打包是非常消耗 CPU、内存资源的任务，和其他服务混在一起容易导致其他服务卡顿。</li>\n<li>版本服务集群：独立集群，用于提供能支持高并发的版本服务。如果你有 node.js 抗高并发的经验，你可以用 node.js 来做，或者你可以找 Java 同学帮忙一起负责实现。</li>\n</ul><p>当然，有了热更新全貌图之后，你还需要把它搭建起来。搭建热更新平台，我推荐的关键技术栈有：</p><ul>\n<li><a href=\"https://nestjs.com/\">NestJS</a> ：它是一个 Node.js 框架 ，它能提供高效、可靠和可扩展的后端服务。</li>\n<li><a href=\"https://github.com/OptimalBits/bull\">Bull</a>：它一个任务队列库，它能帮你解决热更新平台后台集群如何向打包集群发布打包任务的难题，让你的平台可以支持多人并行打包。</li>\n</ul><p>我知道，仅仅凭借热更新平台全貌图和核心技术，很难让你复刻出一个热更新平台来。但有了这些关键的设计思路，至少能够保证你在自研热更新平台时，不会在主要的设计方向上跑偏。</p><h2>总结</h2><p>要实现 React Native 热更新功能，有四种思路 <a href=\"https://docs.microsoft.com/zh-cn/appcenter/distribution/codepush/rn-overview#store-guideline-compliance\">Code Push</a>、<a href=\"https://pushy.reactnative.cn/\">Pushy</a>、<a href=\"https://docs.expo.dev/distribution/hosting-your-app/\">Expo</a> 和自研。</p><p>如果你选择自研 React Native 热更新功能，这就需要 React Native 热更新平台和 Native 热更新模块的紧密配合了。</p><p>自研 React Native 热更新功能，并不一定需要搭建一个热更新平台，你也可以采用纯 CDN 方案，比如你可以利用阿里云提供的静态资源部署能力和对应的 CDN 服务。</p><p>如果决心要完全自研一个热更新平台，那么你最好找一个对后端技术比较了解同学一起来设计，我也为你提供了一个热更新平台的全貌图，你可以用它来帮你进行整体设计。</p><p>你或许发现了，学到这一讲时，所谓的 React Native 知识，并不是局限在 React Native 本身，它还包括了客户端知识、前端知识和后端知识。虽然在一个大团队中大家各自分工协作，负责好自己擅长的技术领域即可，但也需要一个各方面都懂一些人同学，能把大家给组织起来。</p><p>能牵头把自研热更新平台落地，是一个非常考验技术架构能力和产品设计能力事情，如果你有机会能够主导，相信会对你的技术能力会有极大提高。</p><h2>作业</h2><p>很多人担心使用 React Native 热更新会导致苹果审核不通过，你有没有遇到过这类问题呢？在热更新技术方案的设计上，又应该如何规避审核风险呢？</p><p>欢迎在评论区分享，咱们下一讲见。</p>","neighbors":{"left":{"article_title":"22｜自定义组件：如何满足业务的个性化需求？","id":519819},"right":{"article_title":"24｜拆包：Metro 拆包的工作原理是什么？","id":521254}}},{"article_id":521254,"article_title":"24｜拆包：Metro 拆包的工作原理是什么？","article_content":"<p>你好，我是蒋宏伟。</p><p>在上一讲我们聊了热更新，今天这一讲我们聊聊热更新中的拆包环节。</p><p>热更新和拆包都是大家聊得比较多的话题，通常一个聊得比较多的技术话题都会有一套成熟的技术方案，比如热更新平台就有 CodePush 这样的成熟方案，但拆包却没有一套大家都公认成熟的方案，这也是很奇怪。</p><p>业内没有方案，换作以前大家就只能自己“造轮子”了，但去年我们开源了 58RN 的拆包工具  <a href=\"https://github.com/wuba/metro-code-split\">metro-code-split</a>，你可以直接拿去用。</p><p>metro-code-split 是我们团队的赵琦同学写的一个基于 Metro 的拆包工具，它能帮你实现 React Native 的拆包工作。</p><p>要知道，无论我们是运行 npm start 启动本地调试，还是运行 npm run-ios 构建应用，底层都会用到 Metro 打包工具。</p><p>然而，Facebook 开源的 Metro 打包工具，本身并没有拆包功能。它只能将 JavaScript 代码，打包成一个 Bundle 文件，而且 Metro 也不支持第三方插件，所以社区也没有第三方拆包插件。但当初，我们在阅读 Metro 源码的时候，发现了一个可配置的函数 <a href=\"https://github.com/facebook/metro/blob/779e724885ec439a317edd7eb4356d01fe8d55a2/packages/metro/src/Server.js#L218-L224\">customSerializer</a>，从而找到了不入侵 Metro 源码，通过<a href=\"https://github.com/wuba/metro-code-split/blob/fce8183629d07bf34978c0f246c0a91a842ec4e9/src/config/craeteMustConfig.js#L33-L47\">配置的方式</a>给 Metro 写第三方插件的方法。</p><!-- [[[read_end]]] --><p>有了 Metro 的  customSerializer 方法后，现在我们也可以给 Metro 来写插件了，通过插件来提供单独拆包能力。metro-code-split 就是我们为 Metro 写的拆包插件。下面我们就来分析下这个插件的原理和使用。</p><h2>拆包原理</h2><p>我们开源的 metro-code-split 拆包工具，是<strong>基于模块</strong>来拆包的，它相对于基于文本的拆包方式，加载速度会更快一些。</p><p>为什么基于模块的拆包，要比基于文本的拆包加载速度更快一些呢？这是因为，基于模块的拆包方式能够独立运行。</p><p>在 2018 之前，我们使用的是文本拆包方案，在 2018 之后，我们改成了模块拆包方案。因为拆出来的包能够独立运行，即便热更新文件没有下载完成，内置在 App 中的公共文件也能提前运行。理论上，模块拆包配合框架初始化预执行，在 Android 上实测平均能快 310 ms，而且还支持文件的再次拆分，实现类似 Web 中的 Dynamic Import 的效果。</p><p><strong>那为什么基于模块的拆包方式，能够独立运行，而基于文本的拆包方式不能独立运行呢？</strong></p><p>我们先来看基于文本的拆包方式。假设我们采用的是多 Bundle 的基于文本的拆包方式。多个 Bundle 之间的公共代码部分是 “react”和“react-native”库，这里我用 console.log(“react”)、console.log(“react-native”) 来代替。多个 Bundle 之间不同的代码部分是业务代码，这里用 console.log(“Foo”)，来代替某个具体业务代码。</p><p>基于文本的拆包，我们以前采用的是 Google 开源的 <a href=\"https://github.com/google/diff-match-patch\">diff-match-patch</a> 算法，它也提供了在线计算网站，你可以自己把玩一下，我也把计算热更新包的示意图放在了下面：</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/yy/d29d9de67ba8f730107e0ca4004ee1yy.png?wh=1868x1018\" alt=\"图片\"></p><p>在基于文本计算热更新包的示意图中，我们会把 Old Version 的字符串文件进行内置。这部分代码除了升级 React Native 版本之外不会轻易改动。而 New Version 的字符串是本次热更新的目标代码，也就是完整的 Bundle 文件，但开发者并不需要下载完整的 Bundle 文件，因为 Old Version 已经内置到 App 中了，我们只需要下发 Patch 热更新包即可。</p><p>客户端接收到 Patch 热更新包后，会和 Old Version 代表的内置包进行合并，合并的结果就是 New Version 代表的完整 Bundle。</p><p>以上这些，就是基于文本拆包与合包的原理。但你可以看到，<strong>Patch 热更新包是一段记录修改位置、修改内容的文本，而不是可独立执行的代码</strong>，会导致内置包没法提前执行，只能等到下载完成，再完成合并，生成完整的 Bundle 文件，最后才能整体执行。这就是为什么基于文本拆包方式不可独立执行的原因。</p><p>但基于模块的拆包方式，内置包和热更新包就可以分别独立执行。</p><p>同样，还是以多 Bundle 模式的 Foo 业务热更新为例，我也弄了基于模块拆包示意图，你可以对比一下基于文本和基于模块拆包的区别：</p><p><img src=\"https://static001.geekbang.org/resource/image/32/ca/329b52434bb0d474f3efd442e684c7ca.png?wh=1852x1002\" alt=\"图片\"></p><p>你可以看到，<strong>基于模块拆包方案，拆出来的热更新包是代表 Foo 业务代码的 console.log(“Foo”)，这部分代码是可以独立运行的。</strong></p><p>因此，你可以在客户端先运行内置包，然后并行下载热更新包，等热更新包下载完成，再接着运行热更新包。</p><p>以上这种把包拆成两份，分两次执行的效果，在功能上是等效于一次性运行完整的 Bundle 包的，但在性能上会更快一些，因为内置包提前运行了。而且它还能支持类似于 Web 一样的 Dynamic Import 功能，该功能还支持非首屏代码延迟加载，这又能进一步减少首屏代码的下载量，提高首屏代码的执行速度。</p><p>因此，我们开源的 metro-code-split 选用的是基于模块的拆包方案。</p><h2>metro-code-split 的配置</h2><p>那 metro-code-split 具体如何使用呢？我们先来看它的基础配置方法。</p><p>首先，在你的项目中安装 metro-code-split 插件：</p><pre><code class=\"language-plain\">npm i metro-code-split -D | yarn add metro-code-split -D\n</code></pre><p>第二步是修改你的 package.json 文件：</p><pre><code class=\"language-plain\">\"scripts\": {\n  \"start\": \"mcs-scripts start -p 8081\",\n  \"build:dllJson\": \"mcs-scripts build -t dllJson -od public/dll\",\n  \"build:dll\": \"mcs-scripts build -t dll -od public/dll\",\n  \"build\": \"mcs-scripts build -t busine -e index.js\"\n}\n</code></pre><p>其命令含义如下：</p><ul>\n<li>start：启动本地调试服务；</li>\n<li>build:dllJson：构建公共包的模块文件；</li>\n<li>build:dll：构建公共包；</li>\n<li>build：构建业务包和按需加载包。</li>\n</ul><p>关于公共包、公共包的模块文件、业务包和按需加载包这四类包的区别，后面我们还有更详细的介绍。</p><p>第三步是修改 metro.config.js 配置：</p><pre><code class=\"language-plain\">const Mcs = require('metro-code-split')\n\n// 拆包的配置\nconst mcs = new Mcs({\n  output: {\n    // 配置你的 CDN 的 BaseURL \n    publicPath: 'https://static001.geekbang.org/resource/rn',\n  },\n  dll: {\n    entry: ['react-native', 'react'], // 要内置的 npm 库\n    referenceDir: './public/dll', // 拆包的路径\n  },\n  dynamicImports: {}, // dynamic import 是默认开启的\n})\n\n// 业务的 metro 配置\nconst busineConfig = {\n  transformer: {\n    getTransformOptions: async () =&gt; ({\n      transform: {\n        experimentalImportSupport: false,\n        inlineRequires: true,\n      },\n    }),\n  },\n}\n\n// Dynamic Import 在本地和线上环境的实现是不同的\nmodule.exports = process.env.NODE_ENV === 'production' ? mcs.mergeTo(busineConfig) : busineConfig\n</code></pre><p>这里有两个拆包的参数需要你注意。第一个是<strong>publicPath</strong>，它是用于配置线上环境中，按需加载包的根路径的。</p><p>比如，你的热更新包的地址为：</p><pre><code class=\"language-plain\">https://static001.geekbang.org/resource/rn/a1dc...d055.bundle\n</code></pre><p>那么 publicPath 就应该配置为：</p><pre><code class=\"language-plain\">https://static001.geekbang.org/resource/rn\n</code></pre><p>而包名<code>a1dc...d055.bundle</code> 是通过 Bundle 内容的 MD5 值生成的。</p><p>第二个要注意的参数是<strong>dll</strong>，它用于配置需要内置 npm 库。</p><p>通常在一个混合开发的 React Native 应用中，“react”和 “react-native” 这两个包基本上不会变动，所以你可以把这两个 npm 库拆到一个公共包中，这个公共包只能跟随 App 发版更新。而其他的业务代码或者第三方库，比如 “reanimated”，这些代码变动相对频繁，就可以都跟着进行业务包进行集成，方便动态更新。</p><p>如果是你维护的是一个纯 React Native 应用，或者是一个小型的 React Native 应用，那么你还可以多内置一些 npm 库。你可以按一个发版周期来估计哪些需要内置，哪些不需要内置。比如，某个第三方库在一个发版周期内完全没有改动的可能性，那么你就可以考虑内置，如果某个第三方库会进行改动，那么就走热更新流程。</p><p>完成以上三步后，你 metro-code-split 拆包插件也就配置完成了。</p><h2>metro-code-split 的使用</h2><p>那么，配置完成 metro-code-split 之后，如何使用 metro-code-split 进行拆包呢？</p><p>metro-code-split 支持三类包的拆分，包括公共包、业务包和按需加载包。接下来，我按这三类拆包方式和你进行讲解。</p><p><strong>我们先来看公共包。</strong></p><p>当你在 dll 配置项中填写了 “react”和 “react-native”之后，每次打包时， “react”和 “react-native”都会被当作公共包来处理：</p><pre><code class=\"language-plain\">  dll: {\n    entry: ['react-native', 'react'], // 要内置的 npm 库\n    referenceDir: './public/dll', // 拆包的路径\n  },\n</code></pre><p>你可以直接运行如下命令，把公共包拆出来：</p><pre><code class=\"language-plain\">$ yarn build:dll\n</code></pre><p>运行完成后，你再查看<code>public/dll</code>目录，你会发现该目录下面多了两个文件，分别是_dll.android.bundle 和 _dll.ios.bundle，这两个文件就是集成了“react”和“react-native”所有代码的公共包。</p><p>你也可以运行如下命令，查看公共包中包含的模块：</p><pre><code class=\"language-plain\">$ yarn build:dllJson\n</code></pre><p>运行上述命令后，你可以找到 _dll.android.json 和 _dll.ios.json 两个文件，这两个包含了 “react”和“react-native”依赖的所有模块，摘要示例如下：</p><pre><code class=\"language-plain\">[\n  \"__prelude__\", // 框架预制模块\n  \"require-node_modules/react-native/Libraries/Core/InitializeCore.js\", // react-native 初始化模块\n  \"node_modules/@babel/runtime/helpers/createClass.js\", // babel 的类模块\n  \"node_modules/react-native/index.js\", // react-native 入口模块\n  \"node_modules/metro-runtime/src/polyfills/require.js\", // require 运行时模块 \n  \"node_modules/react/index.js\" // react 模块\n]\n</code></pre><p><code>_dll.json</code> 记录了所有的公共模块，<code>_dll.bundle</code> 包含所有公共模块代码，比如管理 React Native 全局变量的框架预制模块 <code>__prelude__</code>、管理初始化的 <code>InitializeCore</code> 模块、管理 <code>babel</code>、<code>require</code> 的模块，以及 <code>react</code> 和 <code>react-native</code> 框架的入口模块。<br>\n一般情况下，你不需要对 <code>_dll.json</code>  文件进行任何处理，你只需关注 <code>_dll.bundle</code> 文件即可， <code>_dll.bundle</code>  文件才是内置到客户端的公共包。</p><p><strong>然后我们再看业务包和按需加载包。</strong></p><p>当你拿到内置包后，除了“react”和“react-native”的内置代码以外，其他所有代码都归属于业务包，但有一类文件例外，就是按需加载模块。</p><p>不过因为业务包和按需加载包的耦合性很强，按需加载包没办法脱离业务包进行独立打包，所以接下来我会把业务包和按需加载包一起介绍。</p><p>通常，你引入普通业务模块，使用的是  <code>import * from \"xxx\"</code> ，那么该模块的代码都会直接打到业务包中。但在引入按需加载业务模块时，使用的是 <code>import(\"xxx\")</code> 引入的，那么该模块代码会直接打到按需加载包中。</p><p>示例代码如下：</p><pre><code class=\"language-plain\">import React, {lazy, Suspense} from 'react';\nimport {\n  Text,\n} from 'react-native';\nimport {NavigationContainer} from '@react-navigation/native';\nimport {\n  createNativeStackNavigator,\n} from '@react-navigation/native-stack';\nimport {Views, RootStackParamList} from './types';\nimport Main from './component/Main';\n\nconst Stack = createNativeStackNavigator&lt;RootStackParamList&gt;();\n\nconst Foo = lazy(() =&gt; import('./component/Foo'));\nconst Bar = lazy(() =&gt; import('./component/Bar'));\n\nexport default function App() {\n  return (\n    &lt;Suspense fallback={&lt;Text&gt;Loading...&lt;/Text&gt;}&gt;\n      &lt;NavigationContainer&gt;\n        &lt;Stack.Navigator initialRouteName={Views.Main}&gt;\n          &lt;Stack.Screen name={Views.Main} component={Main} /&gt;\n          &lt;Stack.Screen name={Views.Foo} component={Foo} /&gt;\n          &lt;Stack.Screen name={Views.Bar} component={Bar} /&gt;\n        &lt;/Stack.Navigator&gt;\n      &lt;/NavigationContainer&gt;\n    &lt;/Suspense&gt;\n  );\n}\n</code></pre><p>你可以看到，Main 组件是通过  <code>import * from \"xxx\"</code>  引入的，它属于普通的业务模块；而 Foo 组件和 Bar 组件是通过 <code>import(\"xxx\")</code>  引入的，它们属于按需加载的业务模块。</p><p>简单地讲，所有通过  <code>import * from \"xxx\"</code>  引入的普通业务模块都会打到业务包中，而使用  <code>import(\"xxx\")</code>  引入的按需加载业务模块，每个模块都会打成一个独立的按需加载包。而且按需加载模块中的子模块的情况比较复杂，它们既有可能打在业务包中，也有可能打在按需加载包中，实际算法非常复杂。你可以参考我在 GMTC 中关于 Dynamic Import 的<a href=\"https://segmentfault.com/a/1190000040319692\">分享</a>，这里就不展开介绍了。</p><p>当你完成代码的编写后，再使用如下命令，就可以生成业务包和按需加载包了：</p><pre><code class=\"language-plain\">$ yarn build\n</code></pre><p>构建完成后，业务包和按需加载包会放在 dist 目录下，其中 buz.android.bundle 和 buz.ios.bundle 就是业务包，chunks 目录下以 MD5 值开头的包就是按需加载包：</p><pre><code class=\"language-plain\">dist\n├── buz.android.bundle\n├── buz.ios.bundle\n└── chunks\n    ├── 22b3a0e5af84f7184abd.bundle\n    └── 479c3b2dc4e8fef12a34.bundle\n</code></pre><p>通过 <code>yarn build:dll</code> 和 <code>yarn build</code>，我们就完成了公共包、业务包、按需加载包的构建。</p><h2>热更新与拆包</h2><p>那么，接下来的问题就是，如何将生成好的公共包、业务包、按需加载包与热更新流程配合一起使用呢？</p><p>我为你画了一张拆包方案的热更新示意图，你可以看下：</p><p><img src=\"https://static001.geekbang.org/resource/image/90/d9/906cf0e44c5ca919daf2d7f03bdee3d9.png?wh=1920x1210\" alt=\"图片\"></p><p>这张示意图，我们以自研热更新流程为例，简单介绍了这三类包的作用和使用方法。</p><p>因为我们采用的是模块拆包方案，虽然理论上每个包都是可以独立运行的，但实际上模块和模块之间是有依赖关系的，整体上讲，按需加载包会依赖业务包中的模块，业务包会依赖公共包中的模块。因此，需要先执行公共包、再执行业务包，最后执行按需加载包。</p><p>当然每个独立的按需加载包之间也会有依赖关系，不过这些加载的依赖关系，metro-code-split 都已经帮你考虑到了，你直接用就行了。</p><p><strong>对于首页是 Native 页面，而其他页面是 React Native 页面的多 Bundle 混合应用而言，整体加载流程如下：</strong></p><p>首先，在启动 App 之后，找一个空闲时间，把 React Native “环境预创建” 好，然后把 “拆出来的公共包”  进行预加载。具体客户端实现，你可以参考后面众文和惠姝老师的《客户端优化》一讲中的相关讲解。</p><p>然后，在用户点击进入 React Native 页面时，在相关跳转协议中传入 React Native 页面的唯一标识符或者 CDN 地址，下载业务包并进行页面加载：</p><pre><code class=\"language-plain\">https://static001.geekbang.org/resource/rn/id999.buz.android.bundle\n</code></pre><p>不过，对于一些复杂业务来说，页面内容会比较多，把一些非首屏的代码放在业务包中会拖慢首屏的加载速度，因此更好的方案是，把这些代码放在按需加载包中进行加载。当用户点击某个按钮或者下拉时，会再触发相关的按需加载逻辑。</p><p>此时，metro-code-split 会根据 import(‘xxx’) 中的参数路径，找到对应的 CDN 地址，比如 Foo.js 模块对应的就是如下 CDN 地址：</p><pre><code class=\"language-plain\">// import(\"./Foo.js\") 对应\nhttps://static001.geekbang.org/resource/rn/03ad61906ed0e1ec92c2.bundle\n</code></pre><p>然后，再根据该 CDN 地址请求按需加载包，并通过 <code>new Function(code)</code> 的方式执行下载回来的代码，把 Foo 组件加载到当前 JavaScript 的上下文中，并进行最终的渲染。</p><p>以上方案适合首页是 Native 页面的混合应用，如果首页也是 React Native 页面怎么办呢？</p><p><strong>如果首页是 React Native 页面，而且采用的是多 Bundle 策略。</strong></p><p>那么，公共包依旧需要内置，并且首页业务包也需要内置。此时，首页业务包采用静默更新策略，也就是当次下载、下次生效的策略。这样每次启动时首页，首页的业务包是从本地加载的，不走网络请求，首页的启动速度就会变快。其他页面的业务包或按需加载包继续采用，当次生效的动态下发形式进行更新。</p><p>当次生效的方式，大概多了 300ms~500ms 的 Bundle 下载时间，但带来的好处是业务能够随时更新、Bug能够随时修复，不用等到用户下次进入页面再生效。</p><p><strong>如果首页是 React Native 页面，但采用的是单 Bundle 策略，比如 CodePush。</strong></p><p>那么，公共包和业务包需要分别内置，其中公共包走发版更新流程，业务包走 CodePush 静默更新流程。相对于纯 CodePush 方案，通过拆包的方式，能够节约 CodePush 更新的下载量体积。如果你还同时使用了按需加载包，那么还能节约非首屏代码的执行时间。</p><p>如果遇到紧急 Bug，CodePush 也支持当次生效。但由于 CodePush 底层机制的原理，它不仅需要下载热更新 Bundle，还需要重新加载整个 JavaScript 环境，耗时比较长，因此不建议你把它用作默认的更新方式。</p><p>今天的 Demo 我也放到了<a href=\"https://github.com/jiangleo/react-native-classroom/tree/main/src/23_CodeSplit\"> GitHub</a> 上，你可参考一下。</p><h2>总结</h2><p>今天我们介绍了 React Native 热更新流程中，一种最常见的性能优化手段，拆包。</p><p>我们的开源拆包工具 metro-code-split能够很方便地帮你把整个 Bundle 包拆分成公共包、业务包和按需加载包。你只需要下载、配置和执行命令，就可以完成拆包操作了。</p><p>本地拆包只是热更新流程中的一个环节，因此你需要配合你的热更新流程一起使用。根据业务的不同，应用可大致分为三种形态，包括单 Bundle 的纯 React Native 应用、多 Bundle 的纯 React Native 以及多 Bundle 的混合应用，每种不同的形态的应用采用的热更新方式和拆包策略都有所区别，你需要结合具体的场景进行分析。</p><p>虽然使用 metro-code-split 进行拆包很简单，但要实现 metro-code-split 并不容易，在编译时、运行时有大量的工作需要处理，你还得把所有模块的正向依赖、逆向依赖给理清楚，才能合理的进行拆包。幸运地是，在 Web 领域的 Webpack 其实已经给出了 Web 领域的“拆包”解决方案，开源 metro-code-split 也算是我们回馈社区的一种形式。</p><p>希望我们开源的 metro-code-split 你能喜欢。</p><h2>作业</h2><ol>\n<li>请你参考 metro-code-split 的<a href=\"https://github.com/wuba/metro-code-split/tree/master/Example\">示例</a>，完成在本地完成拆包和按需加载的调试。</li>\n</ol><p>如果遇到了什么问题，欢迎在评论区留言，咱们下一讲见。</p>","neighbors":{"left":{"article_title":"23｜热更新：如何搭建一个热更新平台？","id":520647},"right":{"article_title":"25｜性能优化：如何设计一个合适的性能优化方案？","id":521843}}},{"article_id":521843,"article_title":"25｜性能优化：如何设计一个合适的性能优化方案？","article_content":"<p>你好，我是蒋宏伟。</p><p>性能问题是我们程序员绕不过的问题。有些人一遇到性能问题，首先想到的就是去网上寻找解决方案。看到别人做了拆包提升了性能，就认为拆包是解决性能问题的银弹；看到别人做了预加载提升了性能，就认为预加载能解决自己 App 的性能问题。</p><p>但其实，<strong>比技术方案更重要的是技术思路</strong>。</p><p>如果你没有性能优化的思路，不能结合自己业务的实际情况分析，而是随便在网上找个方案，直接生搬硬套放在自己的 App 上，很容易吃力不讨好。</p><p>网上性能优化方案五花八门，各大厂之间也并不完全相同，就我所知，除了我们上一讲介绍的拆包方案之外，其他性能优化方案还有内置、Push、预加载、并行加载、热点资源定期拉取、按需加载等，这些方案都可以减少网络请求的耗时。</p><p>再比如，环境提前初始化、 Bundle 预执行、Hermes 字节码、inlineRequire 等方案，也可以减少执行耗时。</p><p>难道这么多性能优化方案，我们都要上吗？应该根据什么标准来确定呢？先做哪个性能优化方案，后做哪个性能优化方案？你把性能优化上线后，又怎么和老板汇报自己的成绩呢？</p><h2>以终为始的设计思路</h2><p>我们以终为始的思路，先来看下应该怎么和老板汇报自己的成绩，然后再根据汇报目的决定性能优化的方案。</p><!-- [[[read_end]]] --><p>在一个公司中，性能优化是一个非常好出成绩的点，因为性能优化能够产出可量化的指标。</p><p>在晋级的时候，如果你能拿出“将 A 业务的首屏耗时由 2s 优化到 1s，性能提升了 100%” 这样的量化指标，比“花费 3 个月，完成 A 业务”这样不好量化的指标更容易出成绩。</p><p>但很多技术同学汇报的时候，就只是汇报到优化了多少秒，这是不够的。你的评委很难将多少秒的优化和对业务产生的影响联系起来，如果不能性能优化和转化率、销售额挂钩，是不好确定成绩的。</p><p>那我们应该怎么汇报呢？你可以这样汇报，比如：</p><ul>\n<li>将首屏时间降低了 1s，访问转化率提高了 6.9%（数据来源，<a href=\"https://segmentfault.com/a/1190000040319692\">58同城4个RN业务的统计</a>）；</li>\n<li>将主页性能提高了 60%，用户注册转换率提高了40%（数据来源，<a href=\"https://medium.com/pinterest-engineering/driving-user-growth-with-performance-improvements-cfc50dafadd7\">Pinterest</a>）；</li>\n<li>将页面延迟降低了 100ms，销售额增加了 1%（数据来源，<a href=\"https://www.gigaspaces.com/blog/amazon-found-every-100ms-of-latency-cost-them-1-in-sales\">亚马逊</a>）。</li>\n</ul><p>你看，把性能和业务指标挂钩后，这样汇报起来是不是更有说服力呢？</p><p>那么，既然在性能优化项目的最后，我们要汇报性能指标和业务指标。那么性能优化项目开始之前，我们最好能提前把性能埋点和业务关键指标埋点给埋上。这样一方面，在性能优化项目结束后，我们能够确定项目收益；另一方面，提前埋点也能帮助我们找到现有的性能瓶颈。</p><h2>立项之前的指标统计</h2><p>接下来，我以性能对页面到达率的影响为例，介绍一下我的统计方案：</p><p><img src=\"https://static001.geekbang.org/resource/image/01/56/01c808d7fd7e77e5eeba2025ayy51b56.png?wh=1920x94\" alt=\"图片\"></p><p>在开始性能优化项目立项之前，我首先会统计当前业务的性能瓶颈和到达率。在本地确定各个关键时间点后，我会在这些关键点上埋上统计埋点。</p><p>以 React Native 混合应用为例，一个未优化的页面的主要加载流程包括：版本请求、Bundle 请求、React Native 框架 Native 部分的初始化、React Native 框架 JavaScript 公共包的初始化、业务的数据请求，以及最终的业务渲染。</p><p>当然，其中零散的耗时，由于耗时非常短，这里就进行了简化处理。比如用户点击业务入口，获取跳转协议开始路由的执行耗时就非常短，通常只有几毫秒，这些不关键耗时我这里就简化了。</p><p>那么，我们具体怎么统计耗时和到达率呢？我以版本请求阶段的耗时统计和到达率为例，和你介绍一下：</p><pre><code class=\"language-plain\">// 版本请求开始\n{ timestamp: 1652976000000, point: \"version_request_start\", uuid: \"123e4567-e89b-12d3-a456-426655440000\"}\n// 版本请求结束\n{ timestamp: 1652976000200, point: \"version_request_end\", uuid: \"123e4567-e89b-12d3-a456-426655440000\" }\n</code></pre><p>你就可以在发版本请求之前，也就是 version_request_start 时间点，还有版本请求回来之后，也就是 version_request_end 时间点，进行埋点。</p><p>版本请求存在两种情况，一种请求是用户请求成功，另一种情况是用户请求失败。请求失败的原因可能有很多，有些情况可能是，网络请求速度慢，用户不想等了，中途退出了；有些情况是，用户误点了，直接中途点击 back 按钮取消跳转了，销毁了载体页，不再发送统计埋点了；还有可能是超时、报错等失败情况。</p><p>成功的情况下，版本请求开始埋点和版本请求结束埋点都发送成功，此时用户为“达到用户”；而在失败的情况下，版本请求开始埋点会发送成功，版本请求结束埋点会发送失败，此时用户为“未达到用户”。</p><p>从统计学的意义上讲，达到用户的占比，就是到达率，计算公式如下：</p><pre><code class=\"language-plain\">到达率 = count(version_request_end)/count(version_request_start) * 100%\n</code></pre><p>另一方面，性能指标，也就是版本请求平均耗时的计算公式如下：</p><pre><code class=\"language-plain\">平均版本请求耗时 =  SUM(MAX((version_request_end - version_request_start), 0)) / count(version_request_end)\n</code></pre><p>写 SQL 来统计版本请求平均耗时，还是稍微麻烦的，这里我就简化了一下。平均版本请求耗时就是到达用户的总耗时除以到达用户总数。</p><p>当你理解了版本请求到达率、耗时计算的统计原理后，Bundle请求、React Native 框架 Native 部分的初始化、React Native 框架 JavaScript 公共包的初始化、业务的数据请求、业务渲染，这些的耗时、到达率统计方案也是类似，我就不啰嗦了。</p><p>计算完成后，你会得到一个平均耗时与流失率的关系图，如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/88/48/886358ecceac93fa059f8e03e9897448.png?wh=1920x202\" alt=\"图片\"></p><p>以上是一个业务的平均耗时与流失率的关系数据。当你多统计几个业务的数据之后，并将这些业务数据使用  Excel/Number 的趋势线进行拟合后，你会得到一个趋势线，示例如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/70/92/7097f4cefb66ae964cf79a9f8b219392.png?wh=1920x899\" alt=\"图片\"></p><p>有了趋势线，就有了预期收益指标。这张图的大致意思是，<a href=\"https://segmentfault.com/a/1190000040319692\">首屏耗时超过 1s 后，每增加 1s，用户到达率会降低 6.9%</a>。</p><p>当然，每个业务都有自己的特点，性能与到达率的关系不一定就是 6.9% 这个值，但是这个统计思路你是可以借鉴的。</p><p>在性能优化项目立项之前，完成统计耗时与到达率的指标统计的目的，不仅是找到项目的性能瓶颈，更重要的是，它能帮你确定项目的预期成本和收益，比如采用 X 手段，将性能耗时降低 Y，用户到达率能够提高 Z。</p><p>在立项之前，完成预期成本和收益估算的作用是，它能帮你在项目前期和老板争取资源，或者项目后期让你的汇报、晋升更有说服力。</p><h2>优化方案的确定</h2><p>不过，当项目准备立项之前，你还有一项最重要的事情要做，就是选择优化方案。</p><p>你可以结合业务实际情况、业务的性能瓶颈数据，然后参考业内方案进行选择。能够参考的方案，除了各大厂 React Native 本身的优化方案外，你还可以参考业内的 Web、小程序、Native 这些领域中的成熟优化方案。</p><p>业务层的优化方案，我们就不介绍了。我们主要看看搞基建要做的底层优化方案，<strong>第一类是网络请求类优化，第二类是执行耗时优化</strong>。</p><p>网络请求类优化包括版本请求、 Bundle 请求、业务请求的优化，主流的方向如下：</p><ul>\n<li><a href=\"https://cloud.tencent.com/developer/news/571603\">HTTP</a>：编码效率优化、信道利用率优化、传输路径优化、信息安全优化；</li>\n<li><a href=\"https://developer.chrome.com/docs/workbox/caching-strategies-overview/\">加载策略</a>：NetWork Only、Cache  First、Network First、Stale While Revalidate（当次更新，下次生效）；</li>\n<li>拆包策略：patch拆包/模块拆包、内置包、增量更新；</li>\n<li>预请求策略：首页预请求、上个页面预请求、热点资源定时更新、并行版本请求和业务请求的策略；</li>\n<li>延后请求策略：Dynamic Import；</li>\n<li>视觉策略：跳转动画、骨架屏。</li>\n</ul><p>第二类常用的执行耗时优化，包括 React Native 的 Native 代码初始化、JavaScript 代码初始化、业务渲染的优化方案如下：</p><ul>\n<li>引擎优化：JSC 引擎、Hermes 引擎、V8 引擎；</li>\n<li>代码预执行：Native 环境预创建、JavaScript 公共代码预执行、React Native SSR；</li>\n<li>代码懒执行：新架构、inlineRequire、Dynamic Import。</li>\n</ul><p>那么，以上这么多优化方案该怎么选呢？</p><p>简单来说，就是什么方案性价比最高，就优先选择什么方案。一般来说，能够直接复用业内开源工具的方案，实现成本更低，比如 Hermes 引擎、模块拆包、Dynamic Import、inlineRequire。这些方案基本上拿来直接适配一下就能用，你选一个预期成本低、收益高的方案做就行。</p><p>而比如自研加载策略、预请求策略、代码预执行、HTTP 优化、SSR这些方面，业内只提供了思路，没有开源方案，开发成本很高，你可以后面再做。</p><h2>整体加载策略</h2><p>接下来，我以最关键版本请求、Bundle 请求的方案设计为例，帮你打开方案设计的思路。</p><p>我在设计 58RN 整体加载策略上，影响我最深的是 <a href=\"https://developer.chrome.com/docs/workbox/caching-strategies-overview/\">Service Worker 的加载策略</a>。</p><p>Service Worker 和 React Native 混合应用很相似。Service Worker 的本质是充当 Web 应用程序与服务端之间的代理服务，Service Worker 代理服务会拦截 Web 应用的请求，并决定请求返回值是来自本地，还是来自服务端。</p><p>而 React Native 混合应用也是类似的。Native 充当了 React Native 应用与服务端之间的代理服务，Native 代理服务帮助 React Native 应用进行版本请求、资源请求，并决定版本请求、资源请求的返回值是来自本地，还是来自服务端。</p><p>你看，Native 在版本请求、资源请求上的作用，是不是和 Service Worker 非常类似？不同的是，Native 的版本请求、资源请求是定制的，而 Service Worker 的请求是可自定义的。</p><p>因此，当初我的思路是定制几个常用的请求方式，然后业务可以根据具体情况进行配置。</p><p>那 Service Worker 有哪些常用的策略可以参考呢？主要包括 4 种：</p><ul>\n<li>NetWork Only；</li>\n<li>Cache  First；</li>\n<li>Network First；</li>\n<li>Stale While Revalidate。</li>\n</ul><p>我们先来介绍下 NetWork Only 加载策略。这个方案中，页面请求只是过了一下 Service Worker 代理，然后直接请求服务端：</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/ed/a3458a14996796be3f878e0d36ea1eed.png?wh=1014x345\" alt=\"图片\"></p><p>然后再来看 Cache  First 策略。页面请求到 Service Worker 代理，然后优先读取 Cache 值返回。如果 Cache 不存在，或则 Cache 读取失败，则接着请求网络，返回相应值：</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/44/dd528ba46f98a3dcb1c562793df32844.png?wh=1004x496\" alt=\"图片\"></p><p>第三种是Network First 加载策略。不同于 Cache First和Network First 加载策略，这个策略会优先从服务端请求返回值，只有服务端请求失败时才会从 Cache 中读取返回值：</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/a3/f445c1278dd615262608fb5ac16739a3.png?wh=1014x492\" alt=\"图片\"></p><p>第四个策略是 Stale While Revalidate 加载策略。这个策略会稍微复杂一点，我会解释得详细一些。在第一次请求时，没有 Cache，会先从服务端请求返回值，并将资源存放在 Cache 中。在第二次有 Cache 时，会先读取 Cache 并进行返回，在读取 Cache 的同时，会发起一个异步请求去更新 Cache。</p><p>Stale While Revalidate 不是很好翻译，我们内部常用的翻译有静默更新、异步更新，它的返回值是当次更新，下次使用的。示意图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/5c/dd9968f0eaf8deed498c1a8a6d8fa45c.png?wh=1014x492\" alt=\"图片\"></p><p>好了，Service Worker 的介绍就到这里。接下来我们的关键是怎么把 Service Worker 的思路用到 React Native 的版本请求、Bundle 请求中来。</p><p>我们第一版的设计思路是，版本请求用 Stale While Revalidate 策略，Bundle 请求用 Cache  First 策略。该方案的优势是，只要用户访问过一次，那他下次访问时版本请求和 Bundle 请求都走的是 Cache。</p><p>但这样的话，由于用户每次都使用的是上次缓存的资源，而不是线上最新的资源，就会存在一种风险，如果一个带严重 Bug 的版本被用户缓存下来了，那这个 Bug 是不能即使得到更新的，因为任何访问过的用户永远使用的是 Cache 资源。</p><p>因此，我们接着又设计了第二版方案。第二版本方案，版本请求用 Network Only 策略，Bundle 请求依旧用的是 Cache First 策略。这样，在用户每次进入 React Native 页面时，都会发起一个版本请求，因此用户永远获取到的是最新版，彻底避免的缓存严重 Bug 风险。</p><p>第二版方案也不是没有缺陷，第二版方案的缺陷就是性能较差，因为每次都有会网络请求。</p><p>为了解决性能较差的问题，我们又设计了第三版方案，也就是Bundle 预加载方案。由于首页是 Native 页面，因此可以在首页加载完成的空闲时间，把 Tab 页面的 Bundle 资源给提前下载并缓存了。然后再把 Tab 页面的 Stale While Revalidate 策略开启，这样用户在进入 Tab 页面的时候就能够直接使用 Cache 的 Bundle 进行加载了。</p><p>当然，并不是所有的 Bundle 资源都适合预加载，你需要在页面性能提升和用户流量浪费之间做取舍，每个页面请求都不一样，没办法统一处理，只能 Case By Case 地、一个个地配置预加载功能。</p><h2>总结</h2><p>今天，我们介绍了如何设计一个合适的性能优化方案的基本思路。</p><p>性能优化项目这类技术类项目有着明确的、可量化的技术指标和业务指标，因此在立项之初，我们就应该以用户为出发点，评估项目的成本和收益。有了明确的预期数据后，无论是在立项还是总结汇报时，都会有很大的优势。</p><p>接着，在项目设计环节，不要立刻着手开始开发，应该结合业务实际的性能瓶颈，调研业内的成熟方案，然后产出适合自己的技术方案进行落地。</p><p>性能优化要做的事情很多，对于热更新 React Native 应用而言，最关键的优化环节是版本请求和 Bundle 请求。你可以参考四种常用 Service Worker 策略，包括 NetWork Only、Cache  First、Network First、Stale While Revalidate，进行设计，产出适合你热更新策略。</p><h2>作业</h2><p>请你思考一下，针对业务请求的性能瓶颈，应该怎么设计性能优化方案？</p><p>欢迎在评论区留言分享，咱们下一节课见。</p>","neighbors":{"left":{"article_title":"24｜拆包：Metro 拆包的工作原理是什么？","id":521254},"right":{"article_title":"26｜客户端优化：如何把性能提升到极致？","id":522549}}},{"article_id":522549,"article_title":"26｜客户端优化：如何把性能提升到极致？","article_content":"<p>你好，我是众文，这一讲继续由我和惠姝来讲解。第22讲中我们讲解了如何用自定义组件满足业务的个性化需求，除了这一点之外，在 React Native 的应用中，还有一点是大家探讨得比较多的，就是性能优化这部分。</p><p>和原生开发相比，React Native 比较明显的不足在于页面加载速度，比如秒开率、页面加载的时长等。但在我们实际的落地过程中，React Native 页面达到了秒开的级别，我们是如何做到的呢？</p><p>其实，一个未经优化的、比较复杂的、动态更新的 React Native 应用，从大体上讲，可以分为 3 个瓶颈（以下数据来自我们的实际业务案例）：</p><p><img src=\"https://static001.geekbang.org/resource/image/0c/yy/0cd583fae8ef9fe0d4fcb1b939ac09yy.png?wh=1204x482\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/72/b7/72637b200c229ea2429636ffc2acecb7.png?wh=1920x749\" alt=\"图片\"></p><p>当然，其中还涉及 JavaScript 侧的优化。今天我们主要站从客户端角度，讲述React Native 如何在客户端侧将性能优化到极致，带你开启 React Native 的秒开世界。</p><h2>环境预创建</h2><p>在 React Native 最新架构中，Turbo Module 是按需加载，而不是像旧框架一般，一股脑初始化所有的 Native Modules，同时 Hermes 引擎放弃了 JIT，在启动速度方面也有明显提升。</p><p>那么，抛开这两个新版本的优化，在启动速度方面，客户端还能做些什么呢？有的，那就是 <strong>React Native 环境预创建</strong>。</p><!-- [[[read_end]]] --><p>在混合工程中，React Native 环境与加载页面的关系如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/cb/ce/cb6be36c212515883353714ff1ab83ce.png?wh=954x770\" alt=\"图片\"></p><p>从上图中可以看到，在混合应用中，独立的 React Native 载体页都拥有自己的执行环境。Native 域包括 React View、Native Modules；JavaScript 域包括 JavaScript 引擎、JS Modules、业务代码；中间通信使用 Bridge/JSI。</p><p>当然，业内也有多个页面复用一个引擎的优化。但是多页面复用一个引擎存在一些问题，比如JavaScript 上下文隔离、多页面渲染错乱、JavaScript 引擎不可逆异常，等等。而且复用的性能不稳定，考虑到投入产出比、维护成本等方面，通常在混合开发中，采用的是一个载体页一个引擎。</p><p>一个 React Native 页面加载渲染逻辑，可以大致分为以下几步：</p><pre><code class=\"language-plain\">React Native 环境初始化 -&gt; 下载/加载 bundle -&gt; 执行 JavaScript 代码\n</code></pre><p>环境初始化这一步包含创建 JavaScript 引擎、Bridge、加载 Native Modules（旧版）。根据我们的测试，初始化这一步，特别是在 Android 环境中，比较耗时。</p><p>那么，如何进行 React Native 环境初始化耗时优化呢？我们可以提前将 React Native 环境创建好，流程如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/87/1b/874951373fe72a395086ddcd6yyef21b.png?wh=728x752\" alt=\"图片\"></p><p>具体的代码如下 （Java）：</p><pre><code class=\"language-plain\">public class RNFactory {\n    // 单例\n    private static class Holder {\n        private static RNFactory INSTANCE = new RNFactory();\n    }\n\n    public static RNFactory getInstance() {\n        return Holder.INSTANCE;\n    }\n\n    private RNFactory() {\n    }\n\n    private RNEnv mRNEnv;\n    \n    // App 启动时调用 init 方法，提前创建一个 RN 环境\n    public void init(Context context) {\n        mRNEnv = new RNEnv(context);\n    }\n    \n    // 获取 RN 环境对象\n    public RNEnv getRNEnv(Context context) {\n        RNEnv rnEnv = mRNEnv;\n        mRNEnv = createRNEnv(context);\n        return rnEnv;\n    }\n}\n</code></pre><p>RNEnv.java：</p><pre><code class=\"language-plain\">public class RNEnv {\n   private ReactInstanceManager mReactInstanceManager;\n   private ReactContext mReactContext;\n   \n   public RNEnv(Context context) {\n       // 构建 ReactInstanceManager\n       buildReactInstanceManager(context);\n       // 其他初始化\n       ...\n   }\n   \n   private void buildReactInstanceManager(Context context) {\n      // ...\n      mReactInstanceManager = ...\n   }\n   \n   public void startLoadBundle(ReactRootView reactRootView, String moduleName, String bundleid) {\n      // ...\n   }\n}\n</code></pre><p>在做预创建时，我们需要注意<strong>线程同步</strong>问题。在混合应用中，React Native 由应用级变成页面级使用，所以在线程安全这方面有不少的问题，预创建时会并发创建多个 React Native 环境，而 React Native 环境内部构建存在异步处理，一些全局的变量，如 ViewManagersPropertyCache：</p><pre><code class=\"language-plain\">class ViewManagersPropertyCache {\n    private static final Map&lt;Class, Map&lt;String, ViewManagersPropertyCache.PropSetter&gt;&gt; CLASS_PROPS_CACHE;\n    private static final Map&lt;String, ViewManagersPropertyCache.PropSetter&gt; EMPTY_PROPS_MAP;\n\n    ViewManagersPropertyCache() {\n    }\n    ...\n}\n</code></pre><p>内部的 CLASS_PROPS_CACHE、EMPTY_PROPS_MAP 都是非线程安全的数据结构，并发时可能会存在 Map 扩容转换问题 （HashMap Node 转红黑树结构），又比如 DynmicFromMap也有此问题：<br>\n<img src=\"https://static001.geekbang.org/resource/image/61/02/613fea41d575817922bdcb9ecc636c02.png?wh=1920x1005\" alt=\"图片\"></p><p>那么，这个问题如何解决呢？你可以参考<a href=\"https://time.geekbang.org/column/article/518965\">《混合应用：如何从零开始集成 React Native？》</a>框架 Bug 修复部分，对同步的地方进行处理。</p><h2>异步更新</h2><p>原先我们进入 React Native 载体页后需要先下载最新的 JavaScript 代码包版本，若有更新，就要下载最新的包并加载。在这个过程中，我们会经历两次网络请求。如果用户网络比较差，那他从进入页面到渲染页面内容需要等待较长时间。</p><p>所以我们针对部分特殊的页面，采取了异步更新的策略。这里所说的特殊页面可以由业务来指定，比如更新频率相对比较低的页面、页面进入路径较短的页面，等等。</p><p>异步更新策略的主要思路为在进入页面之前选择性地提前下载 JavaScript 代码包，进入载体页后再看 JavaScript 代码包是否有缓存，如果有，我们就优先加载缓存并渲染；然后再异步检测是否有最新版本的 JavaScript 代码包，如果有，下载到本地并进行缓存，再等下次进入载体页时生效。</p><p>我们先看一下从一个页面进入到一个 React Native 载体页后需要哪些流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/92/2b/92aac7a2015029fd091799a8fd0b7e2b.png?wh=531x361\" alt=\"图片\"></p><p>流程图中可以看出，我们从进入载体页到渲染页面，需要两次网络请求，不管网速快还是慢，这个流程算是比较漫长的，但在进行异步更新后，我们的流程就会变成下图这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/8e/f8b52bd6babd2686e1004cf22dc1608e.png?wh=531x411\" alt=\"图片\"></p><p>在业务页面中，我们可以对 JavaScript 代码包进行提前下载并缓存，在用户跳转到 React Native 页面后，检测是否有缓存的 JavaScript 代码包，如果有我们就直接渲染页面。这样就不需要等待版本号检测网络接口以及下载最新包的网络接口，也不依赖于用户的网络情况，减少了用户等待时间。</p><p>在渲染页面的同时，我们通过异步检测 JavaScript 代码包的版本，若有新版本就进行更新并缓存，下次生效。当然，业务也可以选择更新完最新包之后，提示用户有新版本页面，以及是否选择刷新并加载最新页面。</p><h2>接口预缓存</h2><p>对 React Native 环境初始化、bundle 加载流程进行优化后，我们的React Native 页面就可以达到秒开级别了。不过，React Native 页面加载后，进入 JavaScript 业务执行区间，大部分业务都不可避免地会进行网络交互，请求服务器数据进行渲染，这部分其实也有很大的优化空间。我们现在就来分析分析。</p><p>我们先来看下具备热更新能力的 React Native 加载流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/44/46/440119a0899e5914f35e86efd25e9646.png?wh=1504x1034\" alt=\"图片\"></p><p>你可以看到，整个流程是从 React Native 环境初始化到热更新 ，再到JavaScript 业务代码执行，最后到业务界面展示。链路比较长，而且每一个步骤都依赖前一个步骤的结果。特别是热更新流程，最长可涉及两次网络调用，分别是检测是否需要更新与下载最新 bundle 文件。</p><p>那么这个时候，我们就想到，在等待网络返回的过程中，Native 能不能把闲置的 CPU 资源利用起来呢？</p><p>我们都知道，目前手机性能越来越强大，多核、4G/5G 使我们的“冲浪”体验越来越好。而且，Native 具备先天的多线程能力。在纯客户端开发中，我们经常使用接口数据缓存策略来提升用户体验，在最新数据返回前，先使用缓存数据进行页面渲染。那么在 React Native 中，我们也可以参考这一思路，对整个流程进行优化：</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/b9/f8fb64dc07f20ddf88e5708a53f42ab9.png?wh=918x1120\" alt=\"图片\"></p><p>具体代码，我也放在了下面 (Java)。</p><ul>\n<li>首先是预请求实体类：</li>\n</ul><pre><code class=\"language-plain\">public class PrefetchBean {\n   public String url; // 预加载的接口\n   public String method; // 请求方式：GET/POST...\n   public Map&lt;String, String&gt; headers; // 请求头\n   public Map&lt;String, String&gt; params; // 请求参数\n}\n</code></pre><ul>\n<li>打开载体页时，解析对应 bundle 缓存中的预请求接口配置数据，发起请求缓存数据：</li>\n</ul><pre><code class=\"language-plain\">public class RNApiPreloadUtils {\n    public static void preloadData(String bundleId) {\n       // 根据 bundle id 解析对应的预请求接口配置，可存在多个接口\n       List&lt;PrefetchBean&gt; prefetchBeans = parsePrefetchBeans(bundleId);\n       // 请求接口，成功后缓存到本地存储\n       requestDatas(prefetchBeans);\n    }\n    \n    public static String prefetchData(String url) {\n       // 从本地缓存中，根据 url 获取对应的接口数据\n    }\n}\n</code></pre><ul>\n<li>获取接口缓存数据的 Module:</li>\n</ul><pre><code class=\"language-plain\">public class PreFetchBusinessModule extends ReactContextBaseJavaModule \n    implements ReactModuleWithSpec, TurboModule {\n    public PreFetchBusinessModule(ReactApplicationContext reactContext) {\n       super(reactContext.real());\n    }\n\n    @ReactMethod\n    public void prefetchData(String url, Callback callback) {\n        String data = RNApiPreloadUtils.prefetchData(url);\n        // 回传数据给 JS\n        WritableMap resultMap = new WritableNativeMap();\n        map.putInt(\"code\", 1);\n        map.putString(\"data\", data);\n        callback.invoke(resultMap);\n    }\n}\n</code></pre><ul>\n<li>JavaScript 调用：</li>\n</ul><pre><code class=\"language-plain\">NativeModules.PreFetchBusinessModule.prefetchData(url, (result)=&gt;{\n    // 获取到结果后，判断是否为空，不为空解析数据，渲染页面\n    console.info(result);\n  }\n);\n</code></pre><h2>拆包</h2><p>前面也提到了，React Native 页面的 JavaScript 代码包是热更新平台根据版本号进行下发的，每次有业务改动，我们都需要通过网络请求更新代码包。</p><p>不过，其实只要 React Native 官方版本没有发生变化，JavaScript 代码包中 React Native 源码相关的部分是不会发生变化的，所以我们不需要在每次业务包更新的时候都进行下发，在工程中内置一份就好了。</p><p>因此，我们可以将一个 JavaScript 代码包拆分成两个部分：一个是 Common 部分，也就是 React Native 源码部分，这一部分除非React Native官方版本进行升级，几乎不会发生变化；另一个是业务代码部分，也就是我们需要动态下载的部分。</p><p><img src=\"https://static001.geekbang.org/resource/image/06/b7/06b66a591c76d37fb1c60e58fa0426b7.png?wh=688x486\" alt=\"图片\"></p><p>我们在打包时，对 React Native 代码包进行处理，拆分成 Common 包和业务代码包。Common包内置到工程中（至少为几百kb的大小），业务代码包进行动态下载。然后我们利用 JSContext 环境，在进入载体页后在环境中先加载 Common包，再加载业务代码包就可以完整的渲染出 React Native 页面：</p><pre><code class=\"language-plain\">//载体页\n- (void)loadSourceForBridge:(RCTBridge *)bridge\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; onProgress:(RCTSourceLoadProgressBlock)onProgress\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; onComplete:(RCTSourceLoadBlock)loadCallback{\n    if (!bridge.bundleURL) return;//加载新资源\n    //开始加载bundle，先执行common bundle\n    [RCTJavaScriptLoader loadCommonBundleOnComplete:^(NSError *error, RCTSource *source){\n        loadCallback(error,newSource);\n    }];\n}\n\n//common执行完毕\n+ (void)commonBundleFinished{\n    //开始执行buz bundle代码\n     [RCTJavaScriptLoader loadBuzBundle:self.bridge.bundleURL onComplete:^(NSError *error, RCTSource *source){\n        loadCallback(error,newSource);\n    }];\n}\n\n//RCTJavaScriptLoader.mm\n+ (void)loadBuzBundle:(NSURL *)buzURL\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; onComplete:(WBSourceLoadBlock)onComplete{\n    //执行buz包代码\n    [self executeSource:buzURL onComplete:^(NSError *error){\n        onComplete(error);//执行完毕\n    }];\n}\n</code></pre><p>在这里要注意，Common包和业务代码包必须要成对进行加载，否则页面无法展示。</p><h2>按需加载</h2><p>其实我们通过前面拆包的方案，已经减少了动态下载的业务代码包的大小。但是还会存在部分业务非常庞大，拆包后业务代码包的大小依然很大的情况，依然会导致下载速度较慢，并且还会受网络情况的影响。</p><p>因此，我们可以再次针对业务代码包进行拆分，<strong>将一个业务代码包拆分为一个主包和多个子包的方式</strong>。在进入页面后优先请求主包的 JavaScript 代码资源，能够快速地渲染首屏页面，紧接着用户点击某一个模块时，再继续下载对应模块的代码包并进行渲染，就能再进一步减少加载时间。示例如图：</p><p><img src=\"https://static001.geekbang.org/resource/image/7c/3c/7c961a3a314ab265a78ede03a187233c.png?wh=1002x544\" alt=\"图片\"></p><p>那么，什么时候需要把业务代码包拆分成一个主包和多个子包呢？把什么模块作为主包，什么模块作为子包比较合适呢？我举一个简单的例子给你解释一下。</p><p>其实在简单的业务中，我们并不需要对业务代码包进行拆分，但是在交互较为复杂的页面中，可能需要进行拆包。下面我们看一下这个包含Tab的业务页面：</p><p><img src=\"https://static001.geekbang.org/resource/image/70/4f/70ffeaccdcda8e40bf47dc2a6d955b4f.png?wh=301x541\" alt=\"图片\"></p><p>这个页面中包含三个Tab，也就是Tab1、Tab2和Tab3。如果这三个Tab中的内容相似，我们当然就不需要对业务代码包进行拆分了。但是如果这三个Tab中的内容差异化较大，页面模版完全不相同，我们就可以对业务代码包进行拆分。</p><p>比如三个Tab页面中，A页面是列表布局，B页面是瀑布流布局，C页面是视频页面，这几个页面之间的布局、样式、方案均无法统一管理。我们就对这三个不同的页面进行拆分，当用户选择某一个页面时，加载对应页面的样式以及布局。</p><p>我们可以将头部title、subtitle部分以及三个tab作为主包优先进行渲染，其次Tab1、Tab2、Tab3部分再分别打成子包，然后再根据用户选中的Tab，将对应的代码包下载下来并渲染。这样我们可以就减少每次下载的代码包的大小，加快渲染速度</p><p>不过，在 React Native 移动端的性能优化中，除了 React Native 环境创建、bundle 文件、接口数据等方面的优化外，还有一个大的优化点，就是<strong>React Native 运行时优化</strong>。</p><p>React Native 旧版本的运行效率有两大痛点：一是 JSC 引擎解释执行 JavaScript 代码效率低，引擎启动速度慢；二是 JavaScript 与 Native 通信效率低，特别是涉及批量地 UI 交互，如列表时更是如此。</p><p>针对于第二点，在<a href=\"https://time.geekbang.org/column/article/519819\">《自定义组件：如何满足业务的个性化需求？》</a>中，我们讲解了 React Native 新架构采用了 JSI 进行通信，替换了 JSBridge，无异步地序列化与反序列化操作、无内存拷贝，可以做到同步通信。</p><p>而除了 JSI 之外，React Native 0.60 以后的版本开始支持 <a href=\"https://www.react-native.cn/docs/hermes\">Hermes 引擎</a>。对比 JSC 引擎，Hermes 引擎在启动速度、代码执行效率上都有大幅提升，所以接下来我们就来重点讲解 Hermes 引擎的特点、它的优化手段以及如何在移动端启用。</p><h2>Hermes 引擎</h2><p>Facebook 在 ChainReact 2019 大会上正式推出了新一代 JavaScript 执行引擎 Hermes。Hermes 是个轻量级的 JavaScript 引擎，专门对移动端上运行 ReactNative 进行了优化，Hermes 可执行字节码，也可以执行 JavaScript。</p><p><img src=\"https://static001.geekbang.org/resource/image/36/cc/3699ac99c8cc113a17ab3271230843cc.png?wh=622x484\" alt=\"图片\"></p><p>在分析性能数据时，Facebook 团队发现 JavaScript 引擎是影响启动性能和应用包体积的重要因素。JavaScriptCore 最初是为桌面浏览器端设计，相较于桌面端，移动端能力有太多的限制。所以，为了能从底层对移动端进行性能优化，Facebook 团队选择自建 JavaScript 引擎，设计了Hermes。</p><p>那新设计的 Hermes 引擎能带来怎样的提升呢？Chain React 大会上官方给出了 Hermes 引擎一组数据：</p><ul>\n<li>从页面启动到用户可操作的时间长短（Time To Interact：TTI），从 4.3s 减少到 2.01s；</li>\n<li>App 的下载大小，从 41MB 减少到 22MB；</li>\n<li>内存占用，从 185MB 减少到 136MB。</li>\n</ul><p>Hermes 的优化主要体现在<strong>字节码预编译</strong>和<strong>放弃JIT</strong>这两点上。</p><p>首先来看下字节码预编译。现代主流的JavaScript引执行一段JavaScript代码的大概流程是：</p><pre><code class=\"language-plain\">读取源码文件 -&gt; 解析转换成字节码 -&gt; 执行\n</code></pre><p>不过，在运行时解析源码转换字节码是一种时间浪费，所以 Hermes 选择预编译的方式在编译期间生成字节码。这样做，一方面避免了不必要的转换时间；另一方面，多出的时间可以用来优化字节码，从而提高执行效率。相关示意图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/9e/6d704ce81c62d6aa3dd3307e14008d9e.png?wh=1920x943\" alt=\"图片\"></p><p>第二点是放弃了JIT。为了加快执行效率，现在主流的 JavaScript 引擎都会使用一个 JIT 编译器，在运行时通过转换成机器码的方式优化 JavaScript 代码。Faceback 团队认为 JIT 编译器主要有两个问题：</p><ul>\n<li>要在启动时候预热，对启动时间有影响；</li>\n<li>会增加引擎 size 大小和运行时内存消耗。</li>\n</ul><p>但是这里需要注意，放弃了JIT，纯文本 JavaScript 代码执行效率会降低。放弃 JIT，是指放弃运行时 Hermes 引擎对纯文本 JavaScript 代码的编译优化。</p><p>当然了，Hermes 也会带来一些问题，首先就是Hermes 编译的字节码文件比纯文本 JavaScript 文件增大不少，第二点就是执行纯文本 JavaScript 耗时长。</p><p>那么，我们要如何开启 Hermes呢？除了可以参考<a href=\"https://reactnative.dev/docs/hermes\">官方文档</a>快速开启Hermes，下面我会也会给你介绍如何在混合工程中开启 Hermes引擎，我们以 Android 为例进行讲解。</p><p>第一步，获取 hermes.aar 文件 （node_modules/hermes-engine）：</p><p><img src=\"https://static001.geekbang.org/resource/image/23/8b/23e27d4dc66ff7074290f0503da4078b.jpeg?wh=838x464\" alt=\"图片\"></p><p>第二步，将 hermes-cppruntime-release.aar 与 hermes-release.aar 放到工程的 libs 目录总，然后在模块的 build.gradle 中添加依赖，这两个 aar 中主要是 hermes 和 libc++_shared so 文件：</p><pre><code class=\"language-plain\">dependencies {\n    implementation(name:'hermes-cppruntime-release', ext:'aar')\n    implementation(name:'hermes-release', ext:'aar')\n}\n</code></pre><p>第三步，设置 JavaScript 引擎：</p><pre><code class=\"language-plain\">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()\n    .setApplication((Application) context.getApplicationContext())\n    .addPackage(new MainReactPackage()) \n    .setRedBoxHandler(mExceptionHandler)\n    .setUseDeveloperSupport(RNDebugSwitcher.getInstance().isDebug())\n    .setInitialLifecycleState(LifecycleState.BEFORE_CREATE)\n    .setJavaScriptExecutorFactory(new HermesExecutorFactory()); // 设置为 hermes\n</code></pre><p>最后，运行 hermes 编译出的字节码 bundle 文件就可以了。这一步又分为了几个小步骤，你参照下面步骤即可：</p><ul>\n<li>将 JavaScript 打包成 bundle 文件。</li>\n</ul><pre><code class=\"language-plain\">react-native bundle --platform android --entry-file index.android.js \n--bundle-output ./bundles/index.android.bundle --assets-dest ./bundles \n--dev false\n</code></pre><ul>\n<li>使用 hermes-engine 将 bundle 文件转换成字节码文件。下载 hermes-engine，使用 hermesc 命名进行转换。</li>\n</ul><pre><code class=\"language-plain\">./hermesc -emit-binary -out index.android.bundle.hbc \nxxx/react-native/app/bundles/index.android.bundle\n</code></pre><ul>\n<li>重命名 bundle 文件。<br>\n这里要将之前 bundle 目录下的 index.android.bundle 删掉，将当前的 index.android.bundle.hbc 重命名为 index.android.bundle</li>\n</ul><p>讲完了 Hermes 引擎，我们最后再来了解下引擎的复用优化。Hermes 引擎是运行时执行效率的优化，而引擎复用是 React Native 创建引擎成本的优化。</p><h2>引擎复用</h2><p>在混合应用中，React Native 由应用级的使用变更为页面级，每一个页面都使用一个 React Native 引擎(包括 JSC/Hermes、Bridge/JSI)，除了内存占用高以外，React Native 引擎的创建耗时也是比较严重的。前面我们讲了环境预创建，就是对于引擎创建成本的优化。在这一块儿，除了预创建外，我们还可以进行<strong>引擎复用优化</strong>。</p><p>以 Android 为例，React Native 引擎的直接表现就是 ReactInstanceManager，内部会初始化 React Native 相关的环境。而在混合应用中，一般会配合热更新策略进行页面加载，所以使用的是 JSC/Hermes 动态加载脚本的能力。从这个场景来看，似乎一个引擎可以运行不同的 bundle 文件，即可达到复用的目的。</p><p>但是引擎复用的坑也非常多，目前我们并未直接落地使用：</p><ol>\n<li>创建和复用引擎的成本可能会导致不少页面，第一次进入和后续进入的速度，表现不一致，因此这类体验问题还需要专项排查并优化；</li>\n<li>在多页面同时在前台的状态下，比如首页 TAB 不同页面使用的都是 React Native 页面，会存在莫名的同步问题；</li>\n<li>复用 React Native 容器内容时，会保持上一次会话的全局变量，容易造成业务逻辑错误。同一个引擎加载不同 bundle，JavaScript上下文与新加载进去的代码能否实现 100% 隔离无污染可能是未知数。同时多页面 JavaScript 上下文隔离。目前引起复用的一大坑其实来源于 JavaScript 上下文多个页面混在一起，容易出错；</li>\n<li>JSC/Hermes 随时有可能发生不可逆转的异常，因此引擎维护的过程中异常状态识别也是一个问题。</li>\n</ol><p>如果你有什么好的解决思路和想法，也欢迎在评论区留言，我们一起讨论。</p><h2>总结</h2><p>今天我们学习了如何在客户端将 React Native 性能优化到极致，包括环境预创建、异步更新、接口预缓存、拆包、按需加载、Hermes 引擎、引擎复用等。这些手段在实际业务中非常实用，当然 React Native 框架也在从自身上不断优化、迭代，追求性能的更高水平。</p><p>接下来我们回顾下今天讲过的几个重点：</p><ul>\n<li>在优化 React Native 环境创建的耗时方面，我们可以使用环境预创建和引擎复用的方式进行优化。环境预创建更容易落地，而且坑更少。引擎复用在内存占用这块比环境预创建方式好，但是需要解决的问题更多；</li>\n<li>在热更新流程优化上，我们可以使用异步更新和预加载 bundle 的方式，优先使用 bundle 缓存进行加载，同时 JavaScript 业务可控制新版本更新策略；</li>\n<li>另外，如何在初始化-&gt;热更新-&gt;bundle下载-&gt;加载JavaScript-&gt;JavaScript业务接口请求的链路中，利用客户端多线程的优势，接口预缓存是不错的选择。</li>\n<li>如果bundle 过大，你可以拆分 common 包和业务包。为进一步提高加载速度，你还可以利用 JavaScript 引擎动态加载脚本的能力，按需加载子 bundle。</li>\n<li>最后，你也可以多关注最新的 Hermes 引擎，看看它的优缺点，以及它是如何实现优化的。</li>\n</ul><p>至此，Native 相关的三讲就告一段落了，后续我和惠姝还会参与 React Native 新框架原理篇的编写。</p><h2>作业</h2><ol>\n<li>运行 Hermes 引擎 demo，并实现环境预创建功能。</li>\n</ol><p>如果有什么问题，欢迎在评论区留言，咱们下一讲见。</p>","neighbors":{"left":{"article_title":"25｜性能优化：如何设计一个合适的性能优化方案？","id":521843},"right":{"article_title":"阶段测试｜React Native的这些核心知识，你都掌握了吗？","id":523145}}},{"article_id":523145,"article_title":"阶段测试｜React Native的这些核心知识，你都掌握了吗？","article_content":"<p>你好，我是蒋宏伟。</p><p>时间过得真快，不知不觉间我们常规更新阶段的26讲就全部更新完毕了。首先要恭喜你一路坚持到了这里，可以说，我们已经来到“半山腰”了，离最终的顺利已经不远了！</p><p>趁此机会，我们不如先休整一下，做一个小测试，看看自己前面的知识点是不是都掌握好了。基础打好了，我们才能更好地继续接下来的学习。</p><p>所以今天，我给你准备了20道选择题，满分100分，范围囊括了我们这门课常规更新阶段的众多核心知识，一起来挑战一下吧！</p><p><a href=\"http://time.geekbang.org/quiz/intro?act_id=3747&exam_id=9554\"><img src=\"https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png?wh=1142x201\" alt=\"\"></a></p><p>如果你有什么不明白的内容，欢迎直接在留言区提问，多交流、多“碰撞”才会产生更多思维的火花。</p><p>另外，我还给你准备了一份<a href=\"https://jinshuju.net/f/L6gPf2\">调查问卷</a>，想听一下你对我这门课的看法和建议，以及对之后动态更新阶段内容的建议。题目不多，两分钟就可以填完，非常希望能看到你的反馈。</p><!-- [[[read_end]]] -->","neighbors":{"left":{"article_title":"26｜客户端优化：如何把性能提升到极致？","id":522549},"right":{"article_title":"总结与展望｜新架构探索之旅，马上开始","id":523767}}},{"article_id":523767,"article_title":"总结与展望｜新架构探索之旅，马上开始","article_content":"<p>你好，我是蒋宏伟。</p><p>历经两个多月，恭喜你已经完成了核心基础篇、社区生态篇和基础设施建设篇的学习。</p><p>在这三部分中，我们不仅学习了入门必备的 React 基础、 React Native 应用的样式布局、核心组件和本地调试，并通过 React Native NTF 首页的开发实战帮你把这些知识给用了起来。</p><p>我们还学习了搭建 React Native 应用必备的导航、动画、手势、状态管理和线上监控，在搭建大型的线上应用时，这些从来自 React Native 生态的第三方工具和最佳实践，能帮上你不少忙。</p><p>而且，我们还学习了搭建 React Native 基础设施的关键要点，包括如何搭建 React Native 混合应用、热更新、拆包和性能优化，相信这些偏基建的知识能够帮你在团队中大放异彩。</p><p>掌握好这些知识之后，你就已经具备应对日常开发业务和团队基建的能力了。</p><p>不过，如果把这个课程的学习比喻成游戏里的升级打怪，那你已经度过了新手村，也熬过了应用实战的难关，来到了一片全新的大陆面前。</p><p>如果你还想在React Native上持续精进、走得更远，那我建议你继续跟随我们这门课的“步伐”，以新架构为核心，继续探索React Native的底层原理和前沿应用。</p><h2>用“新架构”打造你的“技术长板”</h2><!-- [[[read_end]]] --><p>为什么要这么做呢？因为<strong>我们要打造自己的“技术长板”</strong>。</p><p>现代知识体系就是一棵茂密的大树，没有人能够窥其全貌。技术领域也是如此，不同领域之间的知识，差别很大，没有人能同时精通前端、后端和算法。即便在同一个岗位上，大家要掌握的技能也是差距也是很大，toB 和 toC 要求不一样，做业务和做基建的要求也不一样。</p><p>在职业生涯中，我们不需要像学生时代一般，要求自己样样精通，你只需要专注一个方向，并在这个方向上打造一块足够长的长板，弥补所在团队的短板，就可以创造更大的价值。</p><p>我举个我自己的例子。我在极客时间学习了很多课程，除了前端领域的课程外，我学习过 iOS、浏览器、Linux 的课程，还学习过 Redis、MySQL、ElasticSearch、分布式技术、数学算法等等。相对于专攻这些领域的老师而言，我只能算学了个皮毛，这些技术领域都是我的短板。我学习的目的，并不是要成为这些方面的专家，也不是为了补全我的技术短板，而是为了工作中能更好地和小伙伴们合作。</p><p>在非前端领域，我会找团队中的这些领域的高手帮忙。而在前端领域，特别是 React Native 领域，大家遇到相关问题，大家就会找我帮忙，因为前端领域和 React Native 领域是我的技术长板。所以，你也可以把 React Native 领域打造成你的技术长板，成为你团队中最擅长 React Native 的人。</p><p><strong>而打造技术长板的秘诀，要么是你能解决别人解决不了的问题，要么就是你能把业内的技术前沿引入团队应用起来。</strong></p><p>解决别人解决不了的问题，考验的是你的<strong>技术深度</strong>。日常工作中，我们遇到大部分问题，都可以通过搜索引擎直接搜到答案，但总有一些问题是没有直接答案的，这就要求你必须对相关技术的原理有所了解，并加以分析。</p><p>我们拿 React Native 瀑布流举例，你用搜索引擎就能搜到一些可以直接使用的 ScrollView 瀑布流方案。在一些对性能要求不高、非无限列表的场景中，业内的方案就是你要的答案。但是，对于高性能的无限列表，搜索引擎是给不了你答案的，这时候怎么办？你必须要了解瀑布流的原理，然后基于原理对业内方案进行改造，才能解决问题。</p><p>这时候，高性能瀑布流，就是你能解决，而别人不能解决的问题。</p><p>另一个方面，把技术前沿在团队落地应用，考验的是你<strong>对技术的敏感度</strong>。雷军有句话说，“站在风口上，猪都能飞起来”，你只有时刻关注着技术的前沿，才能发现技术的风口。在现在这个时间点上，React Native 新架构本身就是一个技术前沿，现在新架构还处于预览版，除了 Facebook，几乎没有团队有新架构的应用落地，能提前把新架构落地应用起来，就很厉害了。</p><p>除此之外，React Native Skia 自绘引擎、React Native SSR 服务端渲染、React Native WishList 原生高性能列表等前沿技术，也是我重点关注的方向。这些前沿方向是不是技术风口，能否得到大规模应用，现在下结论还太早。但我知道，如果不去提前了解，等到大家都用上你才开始用，你就永远赶不上风口，也很难抓住技术红利带来的机会。</p><h2>新架构的学习具体怎么安排？</h2><p>正如我在开篇词和你承诺的一样，在接下来的<strong>1年</strong>里，我还会以<strong>每月一更</strong>的频率，带你持续跟踪 React Native 新架构的最新进展，这12篇的内容主要分为React Native新架构的原理解析和最新应用两大模块。</p><p><strong>在React Native 新架构原理篇中，我们会聚焦技术的深度</strong>，包括：</p><ul>\n<li>React Native 架构与 Flutter、小程序架构的区别；</li>\n<li>React Native 中 JavaScript 是如何与 Native 进行通信的；</li>\n<li>React18 带来的 Concurrent 是如何做到“可中断”渲染的；</li>\n<li>新架构中的 Fabric 组件、TurboModule 接口又是如何工作的；</li>\n<li>阅读 React Native 新架构的源码应该如何入手。</li>\n</ul><p><strong>在React Native 新架构应用篇中，我们会聚焦技术应用的前沿</strong>，包括：</p><ul>\n<li>React Native Skia 自绘引擎的最近进展与应用；</li>\n<li>React Native SSR 服务端渲染方案究竟是否可行；</li>\n<li>React Native WishList 原生高性能列表的工作原理；</li>\n<li>React Native 新架构的升级迁移有哪些注意事项。</li>\n</ul><p>不过，此时此刻，动态更新的内容还没完全定型，我们可以一起来设计剩余的内容。<strong>欢迎你把想要学习的内容写在评论区、<a href=\"https://jinshuju.net/f/Yd5WEw\">交流群</a>，或者<a href=\"https://jinshuju.net/f/L6gPf2\">这个调查问卷</a>中，我们一起来设计剩下的内容</strong>。常规更新阶段的结束并不是我们学习的终点，衷心邀请你和我一起完成这场“长跑”，在接下来的学习中，深入探索 React Native 新架构的新技术和新应用，抓住技术红利！</p><p>这里先预告一下，接下来动态更新阶段的第一篇文章将在<strong>7月1日</strong>更新，我们会通过对比学习的方法，介绍 React Native 新架构和 Flutter、小程序架构的区别，一定要记得回来学习呀，我也会在<a href=\"https://jinshuju.net/f/Yd5WEw\">交流群</a>里通知你的！</p>","neighbors":{"left":{"article_title":"阶段测试｜React Native的这些核心知识，你都掌握了吗？","id":523145},"right":{"article_title":"27｜跨端的机遇：小程序、Flutter和React Native原理对比","id":534580}}},{"article_id":534580,"article_title":"27｜跨端的机遇：小程序、Flutter和React Native原理对比","article_content":"<p>你好，我是蒋宏伟。从今天起，我们进入了一个新的篇章，新架构原理篇。</p><p>在此之前，我们所学的核心基础篇、社区生态篇、基础设施建设篇都是贴近应用层面的知识，而在新架构原理篇中，我们会重点学习偏底层的纯技术类知识。</p><p>看到这儿你可能会问了：“我们在日常工作中很难用得到框架原理呀，学习这个到底有什么意义呢？”</p><p>这个问题问得非常好，其实我们换个角度来看就豁然开朗了：“如果只学那些日常会用到的、别人也会知识点，我的职业竞争力在哪里？”</p><p>掌握那些大家都会的应用层面的知识只是及格，要想更进一步，我们就要有更高的技术追求。我认为学习底层框架的意义不在于“内卷”，也不在于为了面试去背八股文，<strong>为的是解决别人解决不了的问题，为的是“创新”</strong>。</p><p>“人无我有，人有我优”，才是你的核心竞争力。</p><p>不过，在深入学习 React Native 新架构的原理细节之前，我想先带你对比下小程序、Flutter、React Native之间的架构，让你先从宏观上理解各大框架的架构差异，为后续深入原理打下基础。</p><h2>小程序</h2><p>我们先来看小程序。</p><p><strong>从技术上说，小程序是在一个应用程序中再嵌入另一个应用程序，</strong>也就是说微信本身就是一个应用程序，而小程序就是微信应用程序之上的程序，这在国内独有现象，国外是没有的。</p><!-- [[[read_end]]] --><p><strong>从商业角度讲，这进一步把微信应用，打造成了一个操作系统平台之上的平台</strong>，或者 AppStore 之上的 AppStore。相对于自己开发原生应用而言，由于微信等超级 App 在国内的普及程度非常高，开发者不仅可以使用这些超级 App 提供的技术能力和触达用户的渠道，还能轻易地实现跨端，节约成本。</p><p>小程序虽好，但它是一个闭源软件，而不是一个开源软件，我们没办法直接抄作业，只能从官方的文章中借鉴和分析。</p><p>以微信小程序为例，在<a href=\"https://mp.weixin.qq.com/s/V-H3pF9ytfXRhZG0PGIKsw\">《基于小程序技术栈的微信客户端跨平台实践》</a>这篇文章中，微信技术团队分享了微信小程序在各个技术方向的跨端探索，包括基于 WebView 的、基于 RN-like 的、基于 Flutter 的，这三种跨端思路。</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/20/f7fabf4ceb2bb64cb6bcfe3cbafb0320.png?wh=1392x922\" alt=\"图片\"></p><p><strong>第一种是基于 WebView 实现跨端的思路。</strong></p><p>但在基于这种思路开发时，微信团队遇到了 WebView 渲染和原生渲染体验不一致的问题。</p><p>他们举了两个例子。一个是两个技术方案渲染出来的字体不一致：在 Android 平台上，WebView 没办法和  Android 系统的字体保持一致，体验上有“较为明显的割裂感”。</p><p>第二个例子是，在图片和视频混排的场景下，Android 中低端机会出现掉帧的现象。</p><p>既然纯 WebView 会存在字体不一致和掉帧的问题，那我们能不能把原生字体、原生组件引进来，把 WebView 中有问题的字体和组件替换掉呢？</p><p><strong>这就是第二种思路，使用部分原生组件代替部分 WebView 组件的方案。</strong></p><p>因为这套思路，受到的是 React Native 这类框架的启发，因此他们内部也叫做 RN-like 方案。</p><p>我们简单说一下这个方案的原理。首先微信小程序提供了自己的一套开发框架和语言，包括用于描述页面基础组件的 WXML（WeiXin Markup Language），以及用于描述页面样式的 WXSS （WeiXin Style Sheets）。</p><p>当 WXML/WXSS 发生改变，也就是 UI 页面发生改变的时候，小程序前端公共库（WXA Framework）会进行一些内部运算，以操作指令的形式将变化结果提交给 C++，具体的布局计算、CSS 样式更新和 DOM 结构变化都是由 C++ 这一层实现的。C++ 计算完成后，再决定是调用 WebView 渲染组件，还是调用原生视图渲染组件。</p><p>此外，在微信推出的<a href=\"https://xn--udr14aljn7ylh69jeuvipap78bmgoe8p\">同层渲染</a>方案中，就是用原生组件把 video、map、camera、textarea、input 等 WebView 标签替代了。</p><p>除了以上两种方案之外，微信还尝试了第三种思路。<strong>第三种思路就是，用 Flutter 完全代替 WebView。</strong></p><p>Flutter 版的小程序的原理大致是，前面部分和 RN-like 方案很像，用小程序前端公共库（WXA）计算 WXML/WXSS 的变化，并将这些变化描述成指令传给 C++ 层。和RN-like 方案不同的是，C++ 层完成布局计算后，调用的是 Dart2C++ 接口，并将渲染命令传给 Flutter，由 Flutter 进行绘制。</p><p>讲完这三种实现思路后，微信技术团队也给出了<a href=\"https://mp.weixin.qq.com/s/V-H3pF9ytfXRhZG0PGIKsw\">三种技术路线的性能对比</a>：</p><p><img src=\"https://static001.geekbang.org/resource/image/65/c5/65f1879cd70c2a38e2dae261e2b6a4c5.png?wh=1080x361\" alt=\"图片\" title=\"图源微信团队\"></p><p>你可以看到，相比原始的 WebView 方案，使用 RN-like 和 Flutter 渲染方案后，内存都有所下降，FPS 也都有所提升。</p><p>但微信团队综合对比下来，认为目前 RN-like 方案，也就是使用 WebView 加上部分原生组件渲染页面的方案，有极大的灵活性和前端兼容性，并不会用 Flutter 方案将其代替。</p><h2>Flutter</h2><p>聊完小程序，接着我们再来聊一下 Flutter。</p><p>有些 React Native 开发者可能认为，跨端框架了解一个就够了，会 React Native 了就不用再会 Flutter 了。</p><p>并不是这样的。即便只开发 React Native，你也应该对竞品框架有所了解，特别是在深入底层原理学习的时候，如果你能把各个框架之间原理对比着学习，会更容易看到它们的相同之处和不同之处，也更容易从宏观层面对它们进行抽象理解。</p><p>回到Flutter框架本身。<strong>谷歌对 Flutter 的投入力度非常大，因为它不仅是一个跨端框架，还是开发 Fuchsia 操作系统的 UI 界面的工具。</strong></p><p>在移动互联网爆发后，Chrome 不仅要支持桌面应用，还要支持移动应用。Flutter 的创始人 Eric Seidel 对 Chrome 进行了拆分，去掉桌面应用的历史包袱后，发现一些核心指标比原来快上了 20 倍，于是就有了后来 Flutter 的故事。</p><p>Flutter 现在的定位是一个跨平台 UI 开发工具（UI tookit），但当你剖析它的原理时，你会发现 Flutter 和浏览器有很多相似之处，你可以相互对照着进行理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/cb/0e/cb72a2c707f3ce5b09d915cba4d0380e.png?wh=1498x922\" alt=\"图片\"></p><p>我们不考虑架构细节，只从最基本的原理上观察，你会发现<strong>Flutter 和浏览器的架构非常相似</strong>。</p><p>首先，Flutter 和浏览器都是跨平台的，而且它们主要用的渲染引擎都是 Skia。</p><p>其次，在语言层面上，Flutter 业务层的语言采用的是 Dart，浏览器用的是 JavaScript。Dart 语言和 JavaScript 非常类似，因为 Dart 诞生之初的目标就是想替代 JavaScript。而在框架底层，二者都是用 C++。</p><p>第三，在和原生应用通讯上，Flutter 提供了两套通信机制，消息通道（EventChannel ）和接口通道（MethodChannel ）。消息通道的原理类似于 Hybrid 应用或 React Native 老架构的“bridge”，跨语言通讯的消息都需要进行序列化和反序列化。接口通道的原理类似 JavaScript 直接调用 C++，利用的是引擎提供的脚本语言和 C++ 之间调用能力。</p><p>举个例子，如果Flutter 要调用原生能力，比如微信支付能力，实际上它还是通过 Dart 调用消息通道和接口通道，再间接地调用 Java/OC，由 Java/OC 再调用微信提供的原生 SDK。在这种混合应用场景中，Flutter 也没办法避免通信带来的性能折损。</p><p>当然，Flutter 和浏览器也有很多不同之处：</p><ul>\n<li>Flutter 没有历史包袱。它不需要支持那些不常用功能和布局能力；</li>\n<li>Flutter 用的是 Dart，浏览器用的是 HTML/CSS/JavaScript；</li>\n<li>Flutter 为了保证 UI 组件（Widgets）的灵活性，使用的是 Dart 来实现的，而浏览器标签提供的 UI 组件能力是由 C++ 实现的，等等。</li>\n</ul><p><strong>我认为，Flutter 的优势在于它的纯 Flutter 应用的渲染路径很短。</strong></p><p>纯 Flutter 的渲染只涉及独立渲染进程，从业务语言 Dart 的调用，到 C++ 层的渲染和布局，再到调用使用 C++ 写的 Skia 渲染引擎，由 Skia 将计算出来的向量图，栅格化为手机屏幕能够显示位图，也就是我们看到的页面。</p><p><strong>而Flutter 的主要槽点是 Dart。</strong></p><p>虽然 Dart 语法和 JavaScript 语法很像，但终归是两门语言，增加了很多学习成本和开发成本。Dart 发明之初是为下一代 Web 应用准备的，也有各种 JavaScript 和 Dart 的对比文章在吹捧 Dart，甚至把 Dart 称为 “JavaScript 杀手”。但最终，开发者还是用脚投票选择了 JavaScript 而不是 Dart，导致 Chrome 团队内置 Dart 虚拟机的计划腹死胎中。</p><p>其次，由于苹果政策的限制，Dart 语言是不能热更新的。虽然业内也有很多 Flutter 热更新的动态化框架，但这些都是以牺牲 Flutter 性能为基础的。苹果政策规定只有使用 JavaScriptCore 作为引擎的应用才能动态更新，因此 Flutter 的热更新要先执行 JavaScript，再调用 Java/OC，然后才开始执行 Dart，这样 Flutter 的调用栈就变长、变复杂了。</p><h2>React Native</h2><p>最后就是我们的主角 React Native 了。</p><p>和小程序、Flutter 一样，React Native 也是移动浪潮下的产物，不同的是它走的技术路线是 React + Native 的组合路线，这让 Web 开发者上手非常快。</p><p>对于 React Native 框架的整体原理，相信你已经有所了解了，因此我们来综合对比一下。</p><p>先来看看 React Native 和 Flutter 的相似之处和不同之处：</p><p><img src=\"https://static001.geekbang.org/resource/image/c8/93/c843b1354e028603bf63bf41c9582393.png?wh=1526x962\" alt=\"图片\"></p><p><strong>二者的相似之处有三点。</strong></p><p>首先， <a href=\"https://flutter.cn/docs/resources/architectural-overview#reactive-user-interfaces\">“Flutter 模型架构的灵感来自 Facebook 的 React 框架”</a>，它们都是组件化的、（伪）声明式的。</p><p>其次，两个跨端框架对原生开发都有很高的依赖，只要稍微复杂点，都离不开原生的支持，比如电商交易离不开微信支付，在线直播离不开<a href=\"https://www.agora.io/cn\">声网</a>等。</p><p>第三点，也是最关键的一点，在混合应用中，由于二者都高度依赖原生开发，因此它们常常需要使用原生应用或操作系统本身提供的组件或 API。咱们不看具体的细节，只从宏观角度看，你会发现无论是 React Native 还是 Flutter，它们使用原生组件或 API 的调用路径是一样的。</p><p>上图的左边是 React Native 的渲染路径图，从图中你可以看出来，React Native 最上层的业务语言是 JavaScript，下一层是 C++。C++ 的核心功能主要是布局计算，并且起到了黏合剂的作用，连接了 JavaScript（JS VM） 和 Java（JNI）/OC。通过  Java 和 OC 对操作系统提供的原生组件进行增删改查，最后由操作系统调用渲染引擎将原生组件渲染出来。</p><p>上图的右边是 Flutter 使用原生组件时的渲染路径图，你可以看到，Flutter 最上层的业务语言是 Dart，下一层也是 C++。C++ 的核心功能也是布局计算和黏合剂，由于是原生组件所以不会使用 Skia 渲染引擎，而是继续调用 Java/OC，最后也是由系统调用渲染引擎才能渲染原生组件。</p><p><strong>说完相同之处，再来说说二者的不同之处，不同之处我主要介绍两点。</strong></p><p>我们再看一次上面这张图。第一个不同点，React Native 用的是 JavaScript，Flutter 用的是 Dart。</p><p>第二点，二者的渲染引擎不一样。React Native 用的是操作系统提供渲染引擎，渲染引擎只有一个。但Flutter 用了两个渲染引擎，分别是 Skia 渲染引擎和操作系统提供渲染引擎，那两个渲染引擎应该怎么合作，渲染出同一个页面呢？</p><p>还记得微信小程序中的 RN-like 方案吗？我们前面说微信小程序中同时使用了 WebView 和 Native 视图，并且将 WebView 和 Native 视图渲染到了同一个层级，而 WebView 常用的渲染引擎就是 Skia。</p><p>你可以看下下面<a href=\"https://github.com/lionvoom/WeAppTongCeng\">这张图</a>：</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/5d/e99b331a7564fbd19995245db0e8b55d.png?wh=1920x1564\" alt=\"图片\" title=\"图源https://github.com/lionvoom/WeAppTongCeng\"></p><p>要将 Flutter 的 Skia 渲染引擎和系统渲染引擎绘制在同一个页面，和小程序将 WebView 和 Native 视图渲染到同一个页面的原理是相似的。Flutter 官方给出的原话是：</p><blockquote>\n<p>Hybrid composition appends the native <code>android.view.View</code> to the view hierarchy.<br>\n混合集成模式会将原生的 <code>android.view.View</code> 附加到视图层次结构中。</p>\n</blockquote><p>用大白话说就是，在 Flutter 同时使用两个渲染引擎时，会将系统引擎渲染出来的原生视图放到 Skia 渲染出来的视图层级之中。而且 Flutter 官方也承认，使用<a href=\"https://flutter.cn/docs/development/platform-integration/platform-views\">混合集成模式渲染原生视图</a>时，会有线程竞争、显存会被复制两次、浪费显存和绘图性能等问题。</p><p>由于 React Native 只使用系统渲染引擎，就不存在混合集成模式这种说法，所有的视图都是原生视图，这就简单很多了。</p><h2>总结</h2><p>时代在发展，技术也会跟着时代脉搏同时演进，而那些卓越创造者们，无一不从前人的经验中吸取着养分。</p><p>在移动浪潮之下，诞生了小程序、Flutter、React Native 等非常多的优秀的跨端框架，是它们给我们大前端开发者带来了便利，也是它们给用户带来了更好体验。</p><p>小程序的 XWML 和 WXSS 类似于裁剪的 HTML/CSS，同时它的底层架构又参考了很多 PWA 和 React Native 的思想。更有意思的是，小程序不仅是一个跨端框架，还是一个取得巨大成功的商业平台，把用户和我们这些开发者连接得更紧密了。</p><p>Flutter 的创始人本身就是从 Chrome 团队出来的，你也可以从 Flutter 的架构思想上看到它与 Chrome 的很多相似之处，Flutter 不仅是成功的跨端框架，还是为 Fuchsia OS 铺平道路的技术创新。</p><p>而React Native 是一个纯粹的技术框架，它采取了更加社区化的运作方式，微软、Expo、Callstack 都参与了 React Native 的共建。更关键的是，它把 Web 很多规范、编程思想带到了移动端，并且在技术上掀起了一波又一波的移动跨端的探索。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/c7/4fbc6438847e048a5ede715328yy79c7.png?wh=1058x758\" alt=\"图片\"></p><p>对于我们个人而言，没有什么比直接吸取前人经验能带给我们更好的成长了。技术的浪潮一波接着一波，大的浪潮是大的机遇，小浪潮是小的机遇，我们应该尝试去抓住那一拨属于自己的机遇。</p><p>创新往大了说，可以是为业内独立开辟一条新道路跨端框架，比如说小程序、React Native、Flutter 那样有巨大的影响力框架。</p><p>也可以是一套内部公司的跨端框架，能够解决公司业务的实际痛点的跨端框架，比如 58RN、MFlutter；还可以是屏蔽平台差异性的开源框架，让所有开源社区受益的 Taro、UniApp 等等。</p><p>创新往小了说，可以是利用框架原理解决一个其他同事解决不了的问题；可以帮助团队其他成员提升效率的工具；也可以是 Github 上一个百赞的开源仓库。</p><p><strong>但不懂技术原理，只懂如何使用，是没办法抓住技术带来的机遇的。</strong>因此，让我们期待接下来 React Native 新架构原理篇的学习吧。</p><h2>思考题</h2><p>请你从业务技术选型的角度，分析一下小程序、Flutter、React Native 各自的优缺点。欢迎在留言区分享，我们下一讲见。</p>","neighbors":{"left":{"article_title":"总结与展望｜新架构探索之旅，马上开始","id":523767},"right":[]}}]