{"id":740951,"title":"5.0.2 字母表","content":"\n<p>一些应用程序可能会对字符串的字母表作出限制。在这些应用中，可能常常会需要一个 API 如表 5.0.2 所示的 <code>Alphabet</code> 类。</p>\n<p><strong>表 5.0.2　字母表的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td><code>public class <b>Alphabet</b></code></td><td></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alphabet(String s)</code></td><td>根据 <code>s</code> 中的字符创建一张新的字母表</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char toChar(int index)</code></td><td>获取字母表中索引位置的字符</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int toIndex(char c)</code></td><td>获取 <code>c</code> 的索引，在 0 到 ![R-1](https://private.codecogs.com/gif.latex?R-1) 之间</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean contains(char c)</code></td><td><code>c</code> 在字母表之中吗</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int R()</code></td><td>表示一个索引所需的比特数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int lgR()</code></td><td>将 <code>s</code> 转换为 ![R](https://private.codecogs.com/gif.latex?R) 进制的整数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int[] toIndices(String s)</code></td><td>将 ![R](https://private.codecogs.com/gif.latex?R) 进制的整数转换为基于该字母表的字符串</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String toChars(int[] indices)</code></td><td></td></tr>\n</table>\n\n<p>这份 API 定义了一个构造函数，它用一个含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01027.gif\" alt=\"R\" inline-img=\"true\" /> 个字符的字符串参数指定了字母表。API 定义了 <code>toChar()</code> 方法和 <code>toIndex()</code> 方法来在字符和 0 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01624.gif\" alt=\"R-1\" inline-img=\"true\" /> 之间的整型值进行转换（常数时间）。它还包含了 <code>contains()</code> 方法来检查给定的字符是否存在于字母表中。方法 <code>R()</code> 和 <code>lgR()</code> 用来获取字母表中的字符数以及表示它们所需的比特数。<code>toIndices()</code> 方法和 <code>toChars()</code> 方法能够将由字母表中的字符组成的字符串与 <code>int</code> 数组相互转换。方便起见，下面的表格显示了各种内置的字母表，你可以通过类似 <code>Alphabet.UNICODE16</code> 的方式来访问它们。<code>Alphabet</code> 的实现很简单，我们将它留作练习（请见 5.1.12）。我们会在表 5.0.3 后面的框注“<code>Alphabet</code> 类的典型用例”来展示一个它的用例。</p>\n<p><strong>表 5.0.3　标准字母表</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>名称</p></th>\n<th><p><code>R()</code></p></th>\n<th><p><code>lgR()</code></p></th>\n<th><p>字符集</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>BINARY</code></p></td>\n<td><p>2</p></td>\n<td><p>1</p></td>\n<td><p><code>01</code></p></td>\n</tr>\n<tr>\n<td><p><code>DNA</code></p></td>\n<td><p>4</p></td>\n<td><p>2</p></td>\n<td><p><code>ACTG</code></p></td>\n</tr>\n<tr>\n<td><p><code>OCTAL</code></p></td>\n<td><p>8</p></td>\n<td><p>3</p></td>\n<td><p><code>01234567</code></p></td>\n</tr>\n<tr>\n<td><p><code>DECIMAL</code></p></td>\n<td><p>10</p></td>\n<td><p>4</p></td>\n<td><p><code>0123456789</code></p></td>\n</tr>\n<tr>\n<td><p><code>HEXADECIMAL</code></p></td>\n<td><p>16</p></td>\n<td><p>4</p></td>\n<td><p><code>0123456789ABCDEF</code></p></td>\n</tr>\n<tr>\n<td><p><code>PROTEIN</code></p></td>\n<td><p>20</p></td>\n<td><p>5</p></td>\n<td><p><code>ACDEFGHIKLMNPQRSTVWY</code></p></td>\n</tr>\n<tr>\n<td><p><code>LOWERCASE</code></p></td>\n<td><p>26</p></td>\n<td><p>5</p></td>\n<td><p><code>abcdefghijklmnopqrstuvwxyz</code></p></td>\n</tr>\n<tr>\n<td><p><code>UPPPERCASE</code></p></td>\n<td><p>26</p></td>\n<td><p>5</p></td>\n<td><p><code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></p></td>\n</tr>\n<tr>\n<td><p><code>BASE64</code></p></td>\n<td><p>64</p></td>\n<td><p>6</p></td>\n<td><p><code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxz0123456789+/</code></p></td>\n</tr>\n<tr>\n<td><p><code>ASCII</code></p></td>\n<td><p>128</p></td>\n<td><p>7</p></td>\n<td><p>ASCII 字符集</p></td>\n</tr>\n<tr>\n<td><p>EXTENDED_ASCII</p></td>\n<td><p>256</p></td>\n<td><p>8</p></td>\n<td><p>扩展 ASCII 字符集</p></td>\n</tr>\n<tr>\n<td><p>UNICODE16</p></td>\n<td><p>65 536</p></td>\n<td><p>16</p></td>\n<td><p>Unicode 字符集</p></td>\n</tr>\n</tbody>\n</table>\n<pre class=\"code-rows\"><code>public class Count\n{\n   public static void main(String[] args)\n   {\n      Alphabet alpha = new Alphabet(args[0]);\n      int R = alpha.R();\n      int[] count = new int[R];\n\n      String s = StdIn.readAll();\n      int N = s.length();\n      for (int i = 0; i &lt; N;  i++)\n         if (alpha.contains(s.charAt(i)))\n            count[alpha.toIndex(s.charAt(i))]++;\n\n      for (int c = 0; c &lt; R; c++)\n         StdOut.println(alpha.toChar(c)\n                             + \" \" + count[c]);\n\n   }\n}</code></pre>\n<p style=\"text-align: center\">Alphabet 类的典型用例</p>\n<pre class=\"code-rows\"><code>% more abra.txt\nABRACADABRA!\n\n% java Count ABCDR &lt; abra.txt\nA 5\nB 2\nC 1\nD 1\nR 2</code></pre>\n<p><strong>字符索引数组</strong>。我们使用 <code>Alphabet</code> 类的一个最重要的原因是字符索引的数组能够提高算法的效率。在这个数组中，用字符作为索引来获取与之相关联的信息。如果要使用 Java 的 <code>String</code> 类，那就必须使用一个大小为 65 536 的数组；有了 <code>Alphabet</code> 类，则只需要使用一个字母表大小的数组即可。我们将要学习的一些算法能够产生大量的此类数组。在这种情况下，大小为 65 536 的数组是不可接受的。例如前面框注中的 <code>Count</code> 类，它从命令行接受一个字符串并打印出从标准输入获得的每个字符的出现频率。<code>Count</code> 中用来保存出现频率的 <code>count[]</code> 数组就是一个字符索引数组的示例。你可能会认为数组的计算有些繁琐，但实际上它是 5.1 节介绍的一系列快速排序算法的基础。</p><!-- [[[read_end]]] -->\n<p><strong>数字</strong>。你可以从几个标准的 <code>Alphabet</code> 类的示例中看到，我们经常要处理字符串形式的数字。<code>toIndices()</code> 方法能够将任意基于给定的 <code>Alphabet</code> 类的 <code>String</code> 转换为一个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01027.gif\" alt=\"R\" inline-img=\"true\" /> 进制的数字，用一个元素均在 0 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01624.gif\" alt=\"R-1\" inline-img=\"true\" /> 之间的 <code>int[]</code> 数组表示。在某些情况下，一开始就进行这样的转换可以使代码更简洁，因为任意数字都能作为一个字符串索引数组中的索引。例如，如果我们已知输入中仅含有字母表中的字母，那就可以将 <code>Count</code> 中的内循环替换为下面这段更加简洁的代码：</p>\n<pre class=\"code-rows\"><code>int[] a = alpha.toIndices(s);\nfor (int i = 0; i &lt; N; i++)\n   count[a[i]]++;</code></pre>\n<p>其中，我们将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01027.gif\" alt=\"R\" inline-img=\"true\" /> 称为<strong>基数</strong>，即进制数。我们介绍的几种算法也常常被称为“基数”方法，因为它们一次只处理一位数。</p>\n<pre class=\"code-rows\"><code>% more pi.txt\n3141592653\n5897932384\n6264338327\n9502884197\n... [π的100 000位]\n\n% java Count 0123456789 &lt; pi.txt\n0 9999\n1 10137\n2 9908\n3 10026\n4 9971\n5 10026\n6 10028\n7 10025\n8 9978\n9 9902</code></pre>\n<p>尽管使用 <code>Alphabet</code> 这样的数据类型能够为字符串处理算法带来许多好处（特别是对于较小的字母表），但是本书中并没有实现基于通用字母表 <code>Alphabet</code> 类得到的字符串类型，这是因为：</p>\n<ul>\n<li>大多数程序使用的都是 <code>String</code> 类型；</li>\n<li>将字符串转化为索引或是由索引得到字符串常常会落入内循环中，这会大幅降低实现的性能；</li>\n<li>这会使代码更加复杂，也更加难以理解。</li>\n</ul>\n<p>因此我们仍然会使用 <code>String</code> 类，在代码中使用常数 R = 256 并在分析中将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01027.gif\" alt=\"R\" inline-img=\"true\" /> 作为参数。在适当的时候我们会讨论通用字母表的性能。本书的网站提供了基于 <code>Alphabet</code> 类的各种算法的完整实现。</p>\n","comments":[]}