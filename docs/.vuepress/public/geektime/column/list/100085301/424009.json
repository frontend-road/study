{"id":424009,"title":"19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？","content":"<p>你好，我是陈天。</p><p>在现代编程语言中，闭包是一个很重要的工具，可以让我们很方便地以函数式编程的方式来撰写代码。因为闭包可以作为参数传递给函数，可以作为返回值被函数返回，也可以为它实现某个 trait，使其能表现出其他行为，而不仅仅是作为函数被调用。</p><p>这些都是怎么做到的？这就和 Rust 里闭包的本质有关了，我们今天就来学习基础篇的最后一个知识点：闭包。</p><h3>闭包的定义</h3><p>之前介绍了闭包的基本概念和一个非常简单的例子：</p><blockquote>\n<p>闭包是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分（<a href=\"https://time.geekbang.org/column/article/410038\">第二讲</a>）。</p>\n</blockquote><p>闭包会根据内部的使用情况，捕获环境中的自由变量。在 Rust 里，闭包可以用  <code>|args| {code}</code> 来表述，图中闭包 c 捕获了上下文中的 a 和 b，并通过引用来使用这两个自由变量：<br>\n<img src=\"https://static001.geekbang.org/resource/image/60/93/6060b99f222ef6e435c9fe7c83f46593.jpg?wh=2935x1544\" alt=\"\"></p><p>除了用引用来捕获自由变量之外，还有另外一个方法使用 move 关键字  <code>move |args| {code}</code> 。</p><p>之前的课程中，多次见到了创建新线程的 thread::spawn，它的参数就是一个闭包：</p><pre><code class=\"language-rust\">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; \nwhere\n    F: FnOnce() -&gt; T,\n    F: Send + 'static,\n    T: Send + 'static,\n</code></pre><!-- [[[read_end]]] --><p>仔细看这个接口：</p><ol>\n<li>F: FnOnce() → T，表明 F 是一个接受 0 个参数、返回 T 的闭包。FnOnce 我们稍后再说。</li>\n<li>F: Send + 'static，说明闭包 F 这个数据结构，需要静态生命周期或者拥有所有权，并且它还能被发送给另一个线程。</li>\n<li>T: Send + 'static，说明闭包 F 返回的数据结构 T，需要静态生命周期或者拥有所有权，并且它还能被发送给另一个线程。</li>\n</ol><p>1 和 3 都很好理解，2 就有些费解了。一个闭包，它不就是一段代码 + 被捕获的变量么？需要静态生命周期或者拥有所有权是什么意思？</p><p>拆开看。代码自然是静态生命周期了，那么是不是意味着被捕获的变量，需要静态生命周期或者拥有所有权？</p><p>的确如此。在使用 thread::spawn 时，我们需要使用 move 关键字，把变量的所有权从当前作用域移动到闭包的作用域，让 thread::spawn 可以正常编译通过：</p><pre><code class=\"language-rust\">use std::thread;\n\nfn main() {\n    let s = String::from(\"hello world\");\n\n    let handle = thread::spawn(move || {\n        println!(\"moved: {:?}\", s);\n    });\n\n    handle.join().unwrap();\n}\n</code></pre><p>但你有没有好奇过，加 move 和不加 move，这两种闭包有什么本质上的不同？闭包究竟是一种什么样的数据类型，让编译器可以判断它是否满足 Send + 'static 呢？我们从闭包的本质下手来尝试回答这两个问题。</p><h3>闭包本质上是什么？</h3><p>在官方的 Rust reference 中，有这样的<a href=\"https://doc.rust-lang.org/reference/types/closure.html\">定义</a>：</p><blockquote>\n<p>A closure expression produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables.</p>\n</blockquote><p>闭包是一种匿名类型，<strong>一旦声明，就会产生一个新的类型</strong>，但这个类型无法被其它地方使用。<strong>这个类型就像一个结构体，会包含所有捕获的变量</strong>。</p><p>所以闭包类似一个特殊的结构体？</p><p>为了搞明白这一点，我们得写段代码探索一下，建议你跟着敲一遍认真思考（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b68b60542c9bda8dbcbc4a63915a7590\">代码</a>）：</p><pre><code class=\"language-rust\">use std::{collections::HashMap, mem::size_of_val};\nfn main() {\n    // 长度为 0\n    let c1 = || println!(\"hello world!\");\n    // 和参数无关，长度也为 0\n    let c2 = |i: i32| println!(\"hello: {}\", i);\n    let name = String::from(\"tyr\");\n    let name1 = name.clone();\n    let mut table = HashMap::new();\n    table.insert(\"hello\", \"world\");\n    // 如果捕获一个引用，长度为 8\n    let c3 = || println!(\"hello: {}\", name);\n    // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72\n    let c4 = move || println!(\"hello: {}, {:?}\", name1, table);\n    let name2 = name.clone();\n    // 和局部变量无关，捕获了一个 String name2，closure 长度 24\n    let c5 = move || {\n        let x = 1;\n        let name3 = String::from(\"lindsey\");\n        println!(\"hello: {}, {:?}, {:?}\", x, name2, name3);\n    };\n\n\t\tprintln!(\n        \"c1: {}, c2: {}, c3: {}, c4: {}, c5: {}, main: {}\",\n        size_of_val(&amp;c1),\n        size_of_val(&amp;c2),\n        size_of_val(&amp;c3),\n        size_of_val(&amp;c4),\n        size_of_val(&amp;c5),\n        size_of_val(&amp;main),\n    )\n}\n</code></pre><p>分别生成了 5 个闭包：</p><ul>\n<li>c1 没有参数，也没捕获任何变量，从代码输出可以看到，c1 长度为 0；</li>\n<li>c2 有一个 i32 作为参数，没有捕获任何变量，长度也为 0，可以看出参数跟闭包的大小无关；</li>\n<li>c3 捕获了一个对变量 name 的引用，这个引用是 &amp;String，长度为 8。而 c3 的长度也是 8；</li>\n<li>c4 捕获了变量 name1 和 table，由于用了 move，它们的所有权移动到了 c4 中。c4 长度是 72，恰好等于 String 的 24 字节，加上 HashMap 的 48 字节。</li>\n<li>c5 捕获了 name2，name2 的所有权移动到了 c5，虽然 c5 有局部变量，但它的大小和局部变量也无关，c5 的大小等于 String 的 24 字节。</li>\n</ul><p>学到这里，前面的第一个问题就解决了，可以看到，不带 move 时，闭包捕获的是对应自由变量的引用；带 move 时，对应自由变量的所有权会被移动到闭包结构中。</p><p>继续分析这段代码的运行结果。</p><p>还知道了，<strong>闭包的大小跟参数、局部变量都无关，只跟捕获的变量有关</strong>。如果你回顾<a href=\"https://time.geekbang.org/column/article/408409\">第一讲</a>函数调用，参数和局部变量在栈中如何存放的图，就很清楚了：因为它们是在调用的时刻才在栈上产生的内存分配，说到底和闭包类型本身是无关的，所以闭包的大小跟它们自然无关。<br>\n<img src=\"https://static001.geekbang.org/resource/image/56/8f/568023dcb61859029aa0eb48c5eb1c8f.jpg?wh=2059x2601\" alt=\"\"></p><p>那一个闭包类型在内存中究竟是如何排布的，和结构体有什么区别？我们要再次结合 rust-gdb 探索，看看上面的代码在运行结束前，几个长度不为 0 闭包内存里都放了什么：<br>\n<img src=\"https://static001.geekbang.org/resource/image/40/dd/404f3a30a4150a774b8310ab105c3fdd.png?wh=3514x2449\" alt=\"\"></p><p>可以看到，c3 的确是一个引用，把它指向的内存地址的 24 个字节打出来，是 (ptr | cap | len) 的标准结构。如果打印 ptr 对应的堆内存的 3 个字节，是 ‘t’ ‘y’ ‘r’。</p><p>而 c4 捕获的 name 和 table，内存结构和下面的结构体一模一样：</p><pre><code class=\"language-rust\">struct Closure4 {\n    name: String,  // (ptr|cap|len)=24字节\n    table: HashMap&lt;&amp;str, &amp;str&gt; // (RandomState(16)|mask|ctrl|left|len)=48字节\n}\n</code></pre><p>不过，对于 closure 类型来说，编译器知道像函数一样调用闭包 c4() 是合法的，并且知道执行 c4() 时，代码应该跳转到什么地址来执行。在执行过程中，如果遇到 name、table，可以从自己的数据结构中获取。</p><p>那么多想一步，闭包捕获变量的顺序，和其内存结构的顺序是一致的么？的确如此，如果我们调整闭包里使用 name1 和 table 的顺序：</p><pre><code class=\"language-rust\">let c4 = move || println!(\"hello: {:?}, {}\", table, name1);\n</code></pre><p>其数据的位置是相反的，类似于：</p><pre><code class=\"language-rust\">struct Closure4 {\n    table: HashMap&lt;&amp;str, &amp;str&gt; // (RandomState(16)|mask|ctrl|left|len)=48字节\n    name: String,  // (ptr|cap|len)=24字节\n}\n</code></pre><p>从 gdb 中也可以看到同样的结果：<br>\n<img src=\"https://static001.geekbang.org/resource/image/f2/02/f216f8bb700965f9ac3b79b71196ea02.png?wh=2668x1149\" alt=\"\"></p><p>不过这只是逻辑上的位置，如果你还记得<a href=\"https://time.geekbang.org/column/article/418235\">第 11 讲</a> struct 在内存的排布，Rust 编译器会重排内存，让数据能够以最小的代价对齐，所以有些情况下，内存中数据的顺序可能和 struct 定义不一致。</p><p>所以回到刚才闭包和结构体的比较。在 Rust 里，闭包产生的匿名数据类型，格式和 struct 是一样的。看图中 gdb 的输出，<strong>闭包是存储在栈上，并且除了捕获的数据外，闭包本身不包含任何额外函数指针指向闭包的代码</strong>。如果你理解了 c3 / c4 这两个闭包，c5 是如何构造的就很好理解了。</p><p>现在，你是不是可以回答为什么 thread::spawn 对传入的闭包约束是 Send + 'static 了？究竟什么样的闭包满足它呢？很明显，使用了 move 且 move 到闭包内的数据结构满足 Send，因为此时，闭包的数据结构拥有所有数据的所有权，它的生命周期是 'static。</p><p>看完Rust闭包的内存结构，你是不是想说“就这”，没啥独特之处吧？但是对比其他语言，结合接下来我的解释，你再仔细想想就会有一种“这怎么可能”的惊讶。</p><h3>不同语言的闭包设计</h3><p>闭包最大的问题是变量的多重引用导致生命周期不明确，所以你先想，其它支持闭包的语言（lambda 也是闭包），它们的闭包会放在哪里？</p><p>栈上么？是，又好像不是。</p><p>因为闭包这玩意，从当前上下文中捕获了些变量，变得有点不伦不类，不像函数那样清楚，尤其是这些被捕获的变量，它们的归属和生命周期处理起来很麻烦。所以，大部分编程语言的闭包很多时候无法放在栈上，需要额外的堆分配。你可以看这个 <a href=\"https://github.com/golang/go/issues/43210\">Golang 的例子</a>。</p><p>不光 Golang，Java / Swift / Python / JavaScript 等语言都是如此，这也是为什么大多数编程语言闭包的性能要远低于函数调用。因为使用闭包就意味着：额外的堆内存分配、潜在的动态分派（很多语言会把闭包处理成函数指针）、额外的内存回收。</p><p>在性能上，唯有 C++ 的 lambda 和 Rust 闭包类似，不过 C++ 的闭包还有<a href=\"http://www.elbeno.com/blog/?p=1068\">一些场景</a>会触发堆内存分配。如果你还记得 16 讲的 Rust / Swift / Kotlin iterator 函数式编程的性能测试：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c1/d4/c1e1c1909b761cfa3348115bb417d4d4.png?wh=1430x1072\" alt=\"\"></p><p>Kotlin 运行超时，Swift 很慢，Rust 的性能却和使用命令式编程的 C 几乎一样，除了编译器优化的效果，也因为 Rust 闭包的性能和函数差不多。</p><p>为什么 Rust 可以做到这样呢？这又跟 Rust 从根本上使用所有权和借用，解决了内存归属问题有关。</p><p>在其他语言中，闭包变量因为多重引用导致生命周期不明确，但 Rust 从一开始就消灭了这个问题：</p><ul>\n<li>如果不使用 move 转移所有权，闭包会引用上下文中的变量，<strong>这个引用受借用规则的约束</strong>，所以只要编译通过，那么闭包对变量的引用就不会超过变量的生命周期，没有内存安全问题。</li>\n<li>如果使用 move 转移所有权，上下文中的变量在转移后就无法访问，<strong>闭包完全接管这些变量</strong>，它们的生命周期和闭包一致，所以也不会有内存安全问题。</li>\n</ul><p>而 Rust 为每个闭包生成一个新的类型，又使得<strong>调用闭包时可以直接和代码对应</strong>，省去了使用函数指针再转一道手的额外消耗。</p><p>所以还是那句话，当回归到最初的本原，你解决的不是单个问题，而是由此引发的所有问题。我们不必为堆内存管理设计 GC、不必为其它资源的回收提供 defer 关键字、不必为并发安全进行诸多限制、也不必为闭包挖空心思搞优化。</p><h2>Rust的闭包类型</h2><p>现在我们搞明白了闭包究竟是个什么东西，在内存中怎么表示，接下来我们看看 FnOnce / FnMut / Fn 这三种闭包类型有什么区别。</p><p>在声明闭包的时候，我们并不需要指定闭包要满足的约束，但是当闭包作为函数的参数或者数据结构的一个域时，我们需要告诉调用者，对闭包的约束。还以 thread::spawn 为例，它要求传入的闭包满足 FnOnce trait。</p><h3>FnOnce</h3><p>先来看 FnOnce。它的<a href=\"https://doc.rust-lang.org/std/ops/trait.FnOnce.html\">定义</a>如下：</p><pre><code class=\"language-rust\">pub trait FnOnce&lt;Args&gt; {\n    type Output;\n    extern \"rust-call\" fn call_once(self, args: Args) -&gt; Self::Output;\n}\n</code></pre><p>FnOnce 有一个关联类型 Output，显然，它是闭包返回值的类型；还有一个方法 call_once，要注意的是 call_once 第一个参数是 self，它会转移 self 的所有权到 call_once 函数中。</p><p>这也是为什么 FnOnce 被称作 Once ：<strong>它只能被调用一次</strong>。再次调用，编译器就会报变量已经被 move 这样的常见所有权错误了。</p><p>至于 FnOnce 的参数，是一个叫 Args 的泛型参数，它并没有任何约束。如果你对这个感兴趣可以看文末的参考资料。</p><p>看一个隐式的 FnOnce 的例子：</p><pre><code class=\"language-rust\">fn main() {\n    let name = String::from(\"Tyr\");\n    // 这个闭包啥也不干，只是把捕获的参数返回去\n    let c = move |greeting: String| (greeting, name);\n\n    let result = c(\"hello\".to_string());\n\n    println!(\"result: {:?}\", result);\n\n    // 无法再次调用\n    let result = c(\"hi\".to_string());\n}\n</code></pre><p>这个闭包 c，啥也没做，只是把捕获的参数返回。就像一个结构体里，某个字段被转移走之后，就不能再访问一样，闭包内部的数据一旦被转移，这个闭包就不完整了，也就无法再次使用，所以它是一个 FnOnce 的闭包。</p><p>如果一个闭包并不转移自己的内部数据，那么它就不是 FnOnce，然而，一旦它被当做 FnOnce 调用，自己会被转移到 call_once 函数的作用域中，之后就无法再次调用了，我们看个例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d35767cd6cc747d21a57592088aa5854\">代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let name = String::from(\"Tyr\");\n\n    // 这个闭包会 clone 内部的数据返回，所以它不是 FnOnce\n    let c = move |greeting: String| (greeting, name.clone());\n\n    // 所以 c1 可以被调用多次\n\n    println!(\"c1 call once: {:?}\", c(\"qiao\".into()));\n    println!(\"c1 call twice: {:?}\", c(\"bonjour\".into()));\n\n    // 然而一旦它被当成 FnOnce 被调用，就无法被再次调用\n    println!(\"result: {:?}\", call_once(\"hi\".into(), c));\n\n    // 无法再次调用\n    // let result = c(\"hi\".to_string());\n\n    // Fn 也可以被当成 FnOnce 调用，只要接口一致就可以\n    println!(\"result: {:?}\", call_once(\"hola\".into(), not_closure));\n}\n\nfn call_once(arg: String, c: impl FnOnce(String) -&gt; (String, String)) -&gt; (String, String) {\n    c(arg)\n}\n\nfn not_closure(arg: String) -&gt; (String, String) {\n    (arg, \"Rosie\".into())\n}\n</code></pre><h3>FnMut</h3><p>理解了 FnOnce，我们再来看 FnMut，它的<a href=\"https://doc.rust-lang.org/std/ops/trait.FnMut.html\">定义</a>如下：</p><pre><code class=\"language-rust\">pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {\n    extern \"rust-call\" fn call_mut(\n        &amp;mut self, \n        args: Args\n    ) -&gt; Self::Output;\n}\n</code></pre><p>首先，FnMut “继承”了 FnOnce，或者说 FnOnce 是 FnMut 的 super trait。所以FnMut也拥有 Output 这个关联类型和 call_once 这个方法。此外，它还有一个 call_mut() 方法。<strong>注意 call_mut() 传入 &amp;mut self，它不移动 self，所以 FnMut 可以被多次调用</strong>。</p><p>因为 FnOnce 是 FnMut 的 super trait，所以，一个 FnMut 闭包，可以被传给一个需要 FnOnce 的上下文，此时调用闭包相当于调用了 call_once()。</p><p>如果你理解了前面讲的闭包的内存组织结构，那么 FnMut 就不难理解，就像结构体如果想改变数据需要用 let mut 声明一样，如果你想改变闭包捕获的数据结构，那么就需要 FnMut。我们看个例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=979173c2269312cb63a73bb439a5b3b8\">代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let mut name = String::from(\"hello\");\n    let mut name1 = String::from(\"hola\");\n\n    // 捕获 &amp;mut name\n    let mut c = || {\n        name.push_str(\" Tyr\");\n        println!(\"c: {}\", name);\n    };\n\n    // 捕获 mut name1，注意 name1 需要声明成 mut\n    let mut c1 = move || {\n        name1.push_str(\"!\");\n        println!(\"c1: {}\", name1);\n    };\n\n    c();\n    c1();\n\n    call_mut(&amp;mut c);\n    call_mut(&amp;mut c1);\n\n    call_once(c);\n    call_once(c1);\n}\n\n// 在作为参数时，FnMut 也要显式地使用 mut，或者 &amp;mut\nfn call_mut(c: &amp;mut impl FnMut()) {\n    c();\n}\n\n// 想想看，为啥 call_once 不需要 mut？\nfn call_once(c: impl FnOnce()) {\n    c();\n}\n</code></pre><p>在声明的闭包 c 和 c1 里，我们修改了捕获的 name 和 name1。不同的是 name 使用了引用，而 name1 移动了所有权，这两种情况和其它代码一样，也需要遵循所有权和借用有关的规则。所以，如果在闭包 c 里借用了 name，你就不能把 name 移动给另一个闭包 c1。</p><p>这里也展示了，c 和 c1 这两个符合 FnMut 的闭包，能作为 FnOnce 来调用。我们在代码中也确认了，FnMut 可以被多次调用，这是因为 call_mut() 使用的是 &amp;mut self，不移动所有权。</p><h3>Fn</h3><p>最后我们来看看 Fn trait。它的<a href=\"https://doc.rust-lang.org/std/ops/trait.Fn.html\">定义</a>如下：</p><pre><code class=\"language-rust\">pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {\n    extern \"rust-call\" fn call(&amp;self, args: Args) -&gt; Self::Output;\n}\n</code></pre><p>可以看到，它“继承”了 FnMut，或者说 FnMut 是 Fn 的 super trait。这也就意味着<strong>任何需要 FnOnce 或者 FnMut 的场合，都可以传入满足 Fn 的闭包</strong>。我们继续看例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e00f0e9009d0991f7d7e7ec48e9d93d5\">代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let v = vec![0u8; 1024];\n    let v1 = vec![0u8; 1023];\n\n    // Fn，不移动所有权\n    let mut c = |x: u64| v.len() as u64 * x;\n    // Fn，移动所有权\n    let mut c1 = move |x: u64| v1.len() as u64 * x;\n\n    println!(\"direct call: {}\", c(2));\n    println!(\"direct call: {}\", c1(2));\n\n    println!(\"call: {}\", call(3, &amp;c));\n    println!(\"call: {}\", call(3, &amp;c1));\n\n    println!(\"call_mut: {}\", call_mut(4, &amp;mut c));\n    println!(\"call_mut: {}\", call_mut(4, &amp;mut c1));\n\n    println!(\"call_once: {}\", call_once(5, c));\n    println!(\"call_once: {}\", call_once(5, c1));\n}\n\nfn call(arg: u64, c: &amp;impl Fn(u64) -&gt; u64) -&gt; u64 {\n    c(arg)\n}\n\nfn call_mut(arg: u64, c: &amp;mut impl FnMut(u64) -&gt; u64) -&gt; u64 {\n    c(arg)\n}\n\nfn call_once(arg: u64, c: impl FnOnce(u64) -&gt; u64) -&gt; u64 {\n    c(arg)\n}\n</code></pre><h2>闭包的使用场景</h2><p>在讲完Rust的三个闭包类型之后，最后来看看闭包的使用场景。虽然今天才开始讲闭包，但其实之前隐晦地使用了很多闭包。</p><p>thread::spawn 自不必说，我们熟悉的 Iterator trait 里面大部分函数都接受一个闭包，比如 <a href=\"https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#682-685\">map</a>：</p><pre><code class=\"language-rust\">fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;\nwhere\n\t\tSelf: Sized,\n\t  F: FnMut(Self::Item) -&gt; B,\n{\n\t\tMap::new(self, f)\n}\n</code></pre><p>可以看到，Iterator 的 map() 方法接受一个 FnMut，它的参数是 Self::Item，返回值是没有约束的泛型参数 B。Self::Item 是 Iterator::next() 方法吐出来的数据，被 map 之后，可以得到另一个结果。</p><p>所以在函数的参数中使用闭包，是闭包一种非常典型的用法。另外闭包也可以作为函数的返回值，举个简单的例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=92a031385725865cc8d11bd3d56bdd69\">代码</a>）：</p><pre><code class=\"language-rust\">use std::ops::Mul;\n\nfn main() {\n    let c1 = curry(5);\n    println!(\"5 multiply 2 is: {}\", c1(2));\n\n    let adder2 = curry(3.14);\n    println!(\"pi multiply 4^2 is: {}\", adder2(4. * 4.));\n}\n\nfn curry&lt;T&gt;(x: T) -&gt; impl Fn(T) -&gt; T\nwhere\n    T: Mul&lt;Output = T&gt; + Copy,\n{\n    move |y| x * y\n}\n</code></pre><p>最后，闭包还有一种并不少见，但可能不太容易理解的用法：<strong>为它实现某个 trait</strong>，使其也能表现出其他行为，而不仅仅是作为函数被调用。比如说有些接口既可以传入一个结构体，又可以传入一个函数或者闭包。</p><p>我们看一个 <a href=\"https://github.com/hyperium/tonic\">tonic</a>（Rust 下的 gRPC 库）的<a href=\"https://docs.rs/tonic/0.5.2/src/tonic/service/interceptor.rs.html#41-53\">例子</a>：</p><pre><code class=\"language-rust\">pub trait Interceptor {\n    /// Intercept a request before it is sent, optionally cancelling it.\n    fn call(&amp;mut self, request: crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt;;\n}\n\nimpl&lt;F&gt; Interceptor for F\nwhere\n    F: FnMut(crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt;,\n{\n    fn call(&amp;mut self, request: crate::Request&lt;()&gt;) -&gt; Result&lt;crate::Request&lt;()&gt;, Status&gt; {\n        self(request)\n    }\n}\n</code></pre><p>在这个例子里，Interceptor 有一个 call 方法，它可以让 gRPC Request 被发送出去之前被修改，一般是添加各种头，比如 Authorization 头。</p><p>我们可以创建一个结构体，为它实现 Interceptor，不过大部分时候 Interceptor 可以直接通过一个闭包函数完成。为了让传入的闭包也能通过 Interceptor::call() 来统一调用，可以为符合某个接口的闭包实现 Interceptor trait。掌握了这种用法，我们就可以通过某些 trait 把特定的结构体和闭包统一起来调用，是不是很神奇。</p><h2>小结</h2><p>Rust 闭包的效率非常高。首先闭包捕获的变量，都储存在栈上，没有堆内存分配。其次因为闭包在创建时会隐式地创建自己的类型，每个闭包都是一个新的类型。通过闭包自己唯一的类型，Rust 不需要额外的函数指针来运行闭包，所以<strong>闭包的调用效率和函数调用几乎一致</strong>。</p><p>Rust 支持三种不同的闭包 trait：FnOnce、FnMut 和 Fn。FnOnce 是 FnMut 的 super trait，而 FnMut 又是 Fn 的 super trait。从这些 trait 的接口可以看出，</p><ul>\n<li>FnOnce 只能调用一次；</li>\n<li>FnMut 允许在执行时修改闭包的内部数据，可以执行多次；</li>\n<li>Fn 不允许修改闭包的内部数据，也可以执行多次。</li>\n</ul><p>总结一下三种闭包使用的情况以及它们之间的关系：<img src=\"https://static001.geekbang.org/resource/image/cb/25/cba964802787a05f173099b13d210b25.jpg?wh=2256x1296\" alt=\"\"></p><h3>思考题</h3><ol>\n<li>下面的代码，闭包 c 相当于一个什么样的结构体？它的长度多大？代码的最后，main() 函数还能访问变量 name 么？为什么？</li>\n</ol><pre><code class=\"language-rust\">fn main() {\n    let name = String::from(\"Tyr\");\n    let vec = vec![\"Rust\", \"Elixir\", \"Javascript\"];\n    let v = &amp;vec[..];\n    let data = (1, 2, 3, 4);\n    let c = move || {\n        println!(\"data: {:?}\", data);\n        println!(\"v: {:?}, name: {:?}\", v, name.clone());\n    };\n    c();\n\n    // 请问在这里，还能访问 name 么？为什么？\n}\n</code></pre><ol start=\"2\">\n<li>在讲到 FnMut 时，我们放了一段代码，在那段代码里，我问了一个问题：为啥 call_once 不需要 c 是 mut 呢？就像下面这样：</li>\n</ol><pre><code class=\"language-rust\">// 想想看，为啥 call_once 不需要 mut？\nfn call_once(mut c: impl FnOnce()) {\n    c();\n}\n</code></pre><ol start=\"3\">\n<li>为下面的代码添加实现，使其能够正常工作（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f29ebd99613bc9da1d358e0f5b758fd6\">代码</a>）：</li>\n</ol><pre><code class=\"language-rust\">pub trait Executor {\n    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;'static str&gt;;\n}\n\nstruct BashExecutor {\n    env: String,\n}\n\nimpl Executor for BashExecutor {\n    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;'static str&gt; {\n        Ok(format!(\n            \"fake bash execute: env: {}, cmd: {}\",\n            self.env, cmd\n        ))\n    }\n}\n\n// 看看我给的 tonic 的例子，想想怎么实现让 27 行可以正常执行\n\nfn main() {\n    let env = \"PATH=/usr/bin\".to_string();\n\n    let cmd = \"cat /etc/passwd\";\n    let r1 = execute(cmd, BashExecutor { env: env.clone() });\n    println!(\"{:?}\", r1);\n\n    let r2 = execute(cmd, |cmd: &amp;str| {\n        Ok(format!(\"fake fish execute: env: {}, cmd: {}\", env, cmd))\n    });\n    println!(\"{:?}\", r2);\n}\n\nfn execute(cmd: &amp;str, exec: impl Executor) -&gt; Result&lt;String, &amp;'static str&gt; {\n    exec.execute(cmd)\n}\n</code></pre><p>你已经完成Rust学习的第19次打卡。如果你觉得有收获，也欢迎你分享给身边的朋友，邀TA一起讨论。我们下节课见～</p><h2>参考资料</h2><p>怎么理解 FnOnce 的 Args 泛型参数呢？Args 又是怎么和 FnOnce 的约束，比如 FnOnce(String) 这样的参数匹配呢？感兴趣的同学可以看下面的例子，它（不完全）模拟了 FnOnce 中闭包的使用（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=424352c0be4e143b284a0223a4a8bff5\">代码</a>）：</p><pre><code class=\"language-rust\">struct ClosureOnce&lt;Captured, Args, Output&gt; {\n    // 捕获的数据\n    captured: Captured,\n    // closure 的执行代码\n    func: fn(Args, Captured) -&gt; Output,\n}\n\nimpl&lt;Captured, Args, Output&gt; ClosureOnce&lt;Captured, Args, Output&gt; {\n    // 模拟 FnOnce 的 call_once，直接消耗 self\n    fn call_once(self, greeting: Args) -&gt; Output {\n        (self.func)(greeting, self.captured)\n    }\n}\n\n// 类似 greeting 闭包的函数体\nfn greeting_code1(args: (String,), captured: (String,)) -&gt; (String, String) {\n    (args.0, captured.0)\n}\n\nfn greeting_code2(args: (String, String), captured: (String, u8)) -&gt; (String, String, String, u8) {\n    (args.0, args.1, captured.0, captured.1)\n}\n\nfn main() {\n    let name = \"Tyr\".into();\n    // 模拟变量捕捉\n    let c = ClosureOnce {\n        captured: (name,),\n        func: greeting_code1,\n    };\n\n    // 模拟闭包调用，这里和 FnOnce 不完全一样，传入的是一个 tuple 来匹配 Args 参数\n    println!(\"{:?}\", c.call_once((\"hola\".into(),)));\n    // 调用一次后无法继续调用\n    // println!(\"{:?}\", clo.call_once(\"hola\".into()));\n\n    // 更复杂一些的复杂的闭包\n    let c1 = ClosureOnce {\n        captured: (\"Tyr\".into(), 18),\n        func: greeting_code2,\n    };\n\n    println!(\"{:?}\", c1.call_once((\"hola\".into(), \"hallo\".into())));\n}\n</code></pre><h3></h3>","neighbors":{"left":{"article_title":"18｜错误处理：为什么Rust的错误处理与众不同？","id":424002},"right":{"article_title":"20｜4 Steps ：如何更好地阅读Rust源码？","id":424017}},"comments":[{"had_liked":false,"id":314821,"user_name":"D. D","can_delete":false,"product_type":"c1","uid":2186992,"ip_address":"","ucode":"C416E5602C8814","user_header":"https://static001.geekbang.org/account/avatar/00/21/5e/f0/62d8cf9e.jpg","comment_is_top":false,"comment_ctime":1633468174,"is_pvip":true,"replies":[{"id":"114172","content":"赞！非常好！<br><br>","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633813535,"ip_address":"","comment_id":314821,"utype":1}],"discussion_count":1,"race_medal":0,"score":"91827781390","product_id":100085301,"comment_content":"1. 相当于：<br>struct Closure&lt;&#39;a, &#39;b: &#39;a&gt; {<br>    data: (i32, i32, i32, i32),<br>    v: &amp;&#39;a [&amp;&#39;b str],<br>    name: String,<br>}<br><br>它的长度等于 4*4(4个i32) + 2*8(ptr, len) + 3*8(ptr, len, cap) = 56字节。<br>代码的最后不能访问name了，因为已经使用了move关键字将name的所有权移至闭包c中了。<br><br>2. 从定义可以看出，调用FnOnce的call_once方法会取得闭包的所有权。因此对于闭包c和c1来说，即使在声明时不使用mut关键字，也可以在其call_once方法中使用所捕获的变量的可变借用。<br><br>3.<br>impl&lt;F&gt; Executor for F<br>where<br>    F: Fn(&amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt;,<br>{<br>    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt; {<br>        self(cmd)<br>    }<br>}","like_count":22,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527802,"discussion_content":"赞！非常好！\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633813535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314877,"user_name":"f","can_delete":false,"product_type":"c1","uid":2741015,"ip_address":"","ucode":"D37A8E76DB782C","user_header":"https://static001.geekbang.org/account/avatar/00/29/d3/17/22c36063.jpg","comment_is_top":false,"comment_ctime":1633524226,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70353000962","product_id":100085301,"comment_content":"发现了老师文中的一个错误结论。当闭包不使用move时，是推断着判断如何去捕获变量的，先尝试不可变引用，然后尝试可变引用，最后尝试Move&#47;Copy，一旦尝试成功，将不再尝试。当使用move时，是强制Move&#47;Copy，而不是一步一步地去推断尝试。<br><br>在the rust reference: https:&#47;&#47;doc.rust-lang.org&#47;reference&#47;expressions&#47;closure-expr.html里有说明：<br>```<br>Without the move keyword, the closure expression infers how it captures each variable from its environment, preferring to capture by shared reference, effectively borrowing all outer variables mentioned inside the closure&#39;s body. If needed the compiler will infer that instead mutable references should be taken, or that the values should be moved or copied (depending on their type) from the environment. A closure can be forced to capture its environment by copying or moving values by prefixing it with the move keyword. This is often used to ensure that the closure&#39;s lifetime is &#39;static.<br>```<br>代码验证：<br>```rust<br>fn main() {<br>    let mut name = String::from(&quot;hello&quot;);<br><br>    &#47;&#47; 1.不可变引用，&amp;name被存储在闭包c1里<br>    let c1 = || &amp;name;<br>    &#47;&#47; 可使用所有者变量name，且可多次调用闭包<br>    println!(&quot;{}, {:?}, {:?}&quot;, name, c1(), c1());<br><br>    &#47;&#47; 2.可变引用，&amp;mut name被存储在闭包c2里，调用c2的时候要修改这个字段，<br>    &#47;&#47; 因此c2也要设置为mut c2<br>    let mut c2 = || {<br>        name.push_str(&quot; world &quot;);<br>    };<br>    &#47;&#47; 可多次调用c2闭包<br>    &#47;&#47; 但不能调用c2之前再使用name或引用name，因为&amp;mut name已经存入c2里了<br>    &#47;&#47; println!(&quot;{}&quot;, name);  &#47;&#47; 取消注释将报错<br>    &#47;&#47; println!(&quot;{}&quot;, &amp;name); &#47;&#47; 取消注释将报错<br>    c2();<br>    c2();<br><br>    &#47;&#47; 3.Move&#47;Copy，将name移入到闭包c3中<br>    let c3 = || {<br>        let x = name;<br>        &#47;&#47; let y = name;  &#47;&#47; 取消注释见报错，use of moved value<br>    };<br>    &#47;&#47; println!(&quot;{}&quot;, name);  &#47;&#47;取消注释将报错<br>}<br>```<br><br>","like_count":17,"discussions":[{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582019,"discussion_content":"印象里有些情况编译器会提示加上move关键字，这是为什么。从文档和代码来看，编译器会自己判断，什么时候需要强制进行move呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659139005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345265,"user_name":"flyflypeng","can_delete":false,"product_type":"c1","uid":1224113,"ip_address":"","ucode":"7A40FC08D8ACC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/ad/b1/2e96794c.jpg","comment_is_top":false,"comment_ctime":1652163735,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14537065623","product_id":100085301,"comment_content":"有个疑问，闭包中捕获的上下文变量是被存储在栈中，那么闭包中的代码块编译后是存放在哪里？通过什么方式指向这块代码区域呢？","like_count":4},{"had_liked":false,"id":314858,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1633508011,"is_pvip":false,"replies":[{"id":"114170","content":":)","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633813416,"ip_address":"","comment_id":314858,"utype":1}],"discussion_count":1,"race_medal":2,"score":"14518409899","product_id":100085301,"comment_content":"Rust 闭包，看这一篇真的就够了","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527814,"discussion_content":":)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633813416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317821,"user_name":"InfoQ_31da8ff7fcb1","can_delete":false,"product_type":"c1","uid":1485279,"ip_address":"","ucode":"AEF58B6E4F9E59","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzVGyhMctYa2jumzLicZVLia0UCTqrWfiaY8pY4c3AbGH2tH5TxONcbicoXGdE3ia43TpXxbZWPZoS6Jg/132","comment_is_top":false,"comment_ctime":1634980960,"is_pvip":false,"replies":[{"id":"115227","content":"fn  和 Fn &#47; FnMut &#47; FnOnce 不是一回事，fn 是一个 function pointer，不是闭包","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635121326,"ip_address":"","comment_id":317821,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5929948256","product_id":100085301,"comment_content":"关于第三题有个问题，如果我把<br>impl&lt;F&gt; Executor for F<br>where<br>    F: Fn(&amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt;<br>写成：<br>impl Executor for fn(&amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt; <br><br>会报错：<br>the trait `Executor` is not implemented for<br>应该是没对闭包实现Executor这个trait<br><br>那我的那个声明是给哪个谁实现了Executor这个trait了呢？","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528990,"discussion_content":"fn  和 Fn / FnMut / FnOnce 不是一回事，fn 是一个 function pointer，不是闭包","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635121326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","nickname":"Shanks-王冲","note":"","ucode":"C4B90A17850E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584076,"discussion_content":"你是写快了嘛，把 Fn 写成了 fn，老师直接理解了呢？我也直接 impl Executor for Fn... 报错了，改成 impl&lt;F&gt; ... 就没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660621416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343048,"user_name":"CyNevis","can_delete":false,"product_type":"c1","uid":2271650,"ip_address":"","ucode":"0BF0B6F8D540EB","user_header":"","comment_is_top":false,"comment_ctime":1650609521,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650609521","product_id":100085301,"comment_content":"&#47;&#47; 为Fn实现Executor trait<br>    impl &lt;F&gt; Executor for F<br>    where<br>        F: Fn(&amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt;<br>    {<br>        fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt; {<br>            self(cmd)<br>        }<br>    }","like_count":0},{"had_liked":false,"id":341857,"user_name":"小奶精","can_delete":false,"product_type":"c1","uid":2412264,"ip_address":"","ucode":"EB264B3ADC20AE","user_header":"https://static001.geekbang.org/account/avatar/00/24/ce/e8/8b3126d0.jpg","comment_is_top":false,"comment_ctime":1649863789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649863789","product_id":100085301,"comment_content":"老师，感觉rust闭包与C#的委托，lambda表达式异曲同工呢","like_count":0},{"had_liked":false,"id":336956,"user_name":"sea","can_delete":false,"product_type":"c1","uid":1220057,"ip_address":"","ucode":"F420664683697E","user_header":"","comment_is_top":false,"comment_ctime":1646489931,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646489931","product_id":100085301,"comment_content":"impl&lt;F&gt; Executor for F<br>where<br>    F: Fn(&amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt;<br>{<br>    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt; {<br>        self(cmd)<br>    }<br>}","like_count":0},{"had_liked":false,"id":332349,"user_name":"腾达","can_delete":false,"product_type":"c1","uid":1079876,"ip_address":"","ucode":"72F9CFBA44FDEE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9hlAIKQ1sGDu16oWLOHyCSicr18XibygQSMLMjuDvKk73deDlH9aMphFsj41WYJh121aniaqBLiaMNg/132","comment_is_top":false,"comment_ctime":1643184635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643184635","product_id":100085301,"comment_content":"`move |y| x * y` 这里能不能再多解释一下？ 我一开始没有 加 Copy 约束 和 move 出现编译错误，一步步把这2个加上，看每一步的编译错误，最后一点不是特别明白，Copy加上了，为什么还要加 move？ 不加 move，编译器报：the parameter type `T` may not live long enough，help: consider adding an explicit lifetime bound `T: &#39;static`...","like_count":0},{"had_liked":false,"id":321067,"user_name":"TheLudlows","can_delete":false,"product_type":"c1","uid":1069346,"ip_address":"","ucode":"64895727505014","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/22/d12f7a72.jpg","comment_is_top":false,"comment_ctime":1636644087,"is_pvip":false,"replies":[{"id":"118938","content":"谢谢！","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639853883,"ip_address":"","comment_id":321067,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636644087","product_id":100085301,"comment_content":"思路清晰，深入浅出，佩服陈天老师👍","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539899,"discussion_content":"谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639853883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319835,"user_name":"Geek_b52974","can_delete":false,"product_type":"c1","uid":1298252,"ip_address":"","ucode":"59884399646620","user_header":"","comment_is_top":false,"comment_ctime":1635956535,"is_pvip":true,"replies":[{"id":"116395","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636556936,"ip_address":"","comment_id":319835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635956535","product_id":100085301,"comment_content":"1. 56<br>2. 傳入 FnOnce 的時候是執行 fn call_once(self, args: Args) -&gt; Self::Output; 是傳入 self, 而非 &amp;mut self 所以不需要 mut 關鍵字<br>3. <br>impl&lt;F&gt; Executor for F where <br>    F: Fn(&amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt;,<br>{<br>    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt; {<br>        self(cmd)<br>    }<br>}<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529786,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636556936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315835,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1634015982,"is_pvip":false,"replies":[{"id":"115287","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635132585,"ip_address":"","comment_id":315835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634015982","product_id":100085301,"comment_content":"两点思考, 请老师指正<br><br>1. std::function可能类似于dyn Fn()之类的trait object...可能会涉及到额外的vtable (http:&#47;&#47;www.elbeno.com&#47;blog&#47;?p=1068 提到的optimization也可能优化掉vtable);<br><br>不过重点是rust的trait object可以被lifetime 限制. 而cpp不行, 所以std::function需要在heap上得到一个pointer做type erasure<br><br>2. 例子中&amp;main的size是0...从Cpp过来的人表示很奇怪...查了一下:<br><br>main不是function pointer; 而是和closure有点相似的function item的instance (类似于一个zero sized struct, 不过包含了function name, args, lifetimes)<br><br>```<br>    &#47;&#47; found `fn() {main}` -&gt; closure has unique id, so does main<br>    &#47;&#47; it also has a struct for it<br>    &#47;&#47; https:&#47;&#47;github.com&#47;rust-lang&#47;rust&#47;issues&#47;62440<br>    &#47;&#47; size_of_val(main),<br>    size_of_val(&amp;main),<br>```<br><br>https:&#47;&#47;github.com&#47;rust-lang&#47;rust&#47;issues&#47;62440<br><br>&gt; This is the compiler&#39;s way of representing the unique zero sized type that corresponds to the function.<br>&gt; <br>&gt; This is akin to how closures also create a unique type (but in that case, the size may be &gt;= 0 depending on the captured environment).<br><br>function item需要被显式coerce到function pointer (https:&#47;&#47;doc.rust-lang.org&#47;nightly&#47;reference&#47;types&#47;function-item.html)<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528179,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635132585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314975,"user_name":"linuxfish","can_delete":false,"product_type":"c1","uid":1078927,"ip_address":"","ucode":"557F21A1CC7EAD","user_header":"","comment_is_top":false,"comment_ctime":1633619373,"is_pvip":false,"replies":[{"id":"114164","content":"这是因为你传了引用啊，这就不是以 FnOnce 来使用，而是以 Fn 来使用（Fn 实现了 FnOnce 所以 call_once 函数依旧可以工作）。在我的实例代码中 c 本身是一个 Fn。你可以把 name.clone() 那个 clone() 去掉，使其成为 FnOnce，就会发现如果你用 &amp;c 来调用会发生编译错误：<br><br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ddaea49ed76de9c9dd856a4c7bcebfe3<br>","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633813120,"ip_address":"","comment_id":314975,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1633619373","product_id":100085301,"comment_content":"“然而，一旦它被当做 FnOnce 调用，自己会被转移到 call_once 函数的作用域中，之后就无法再次调用了”<br><br>老师，实际调试了一下你的代码，发现只要在`call_once`中传入闭包的引用，后续是可以继续使用闭包的，具体请看：<br><br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=27cd35717d166f01a4045846721cf989","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527846,"discussion_content":"这是因为你传了引用啊，这就不是以 FnOnce 来使用，而是以 Fn 来使用（Fn 实现了 FnOnce 所以 call_once 函数依旧可以工作）。在我的实例代码中 c 本身是一个 Fn。你可以把 name.clone() 那个 clone() 去掉，使其成为 FnOnce，就会发现如果你用 &amp;amp;c 来调用会发生编译错误：\n\nhttps://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=ddaea49ed76de9c9dd856a4c7bcebfe3\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633813120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2186992,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5e/f0/62d8cf9e.jpg","nickname":"D. D","note":"","ucode":"C416E5602C8814","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401547,"discussion_content":"闭包c实现了Fn，所以在call_once中传入闭包的引用后，在main中依然可以使用。\n老师的例子确实有点问题，因为c在call_once后不能使用的原因是c的所有权被移动到了call_once中，并不是被当作FnOnce调用。\n你可以在call_once函数内部进行多次调用试试看。\n\nhttps://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=55a9ea67a75c9a948301b491ad250a02\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633690585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079876,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9hlAIKQ1sGDu16oWLOHyCSicr18XibygQSMLMjuDvKk73deDlH9aMphFsj41WYJh121aniaqBLiaMNg/132","nickname":"腾达","note":"","ucode":"72F9CFBA44FDEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548408,"discussion_content":"这就不是以 FnOnce 来使用，而是以 Fn 来使用（Fn 实现了 FnOnce 所以 call_once 函数依旧可以工作）----当用父里的call_once来执行的时候，它的所有权会被父里的call_once拿到吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643185885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401863,"discussion_content":"传&amp;c，c没被转移，&amp;c作为FnOnce调用（不知道发生了什么？），显然c也没转移，那c当然还能使用。FnOnce才会默认调用call_once，FnMut默认调用call_mut","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633752571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314864,"user_name":"亚伦碎语","can_delete":false,"product_type":"c1","uid":1014505,"ip_address":"","ucode":"F32E5E1B63CC90","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/e9/da5c0203.jpg","comment_is_top":false,"comment_ctime":1633510844,"is_pvip":false,"replies":[{"id":"114169","content":"👍 非常好","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633813410,"ip_address":"","comment_id":314864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633510844","product_id":100085301,"comment_content":"<br>pub trait Executor {<br>    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt;;<br>}<br><br>struct BashExecutor {<br>    env: String,<br>}<br><br>impl&lt;F&gt; Executor for F<br>where<br>    F: Fn(&amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt;,<br>{<br>    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt; {<br>        self(cmd)<br>    }<br>}<br><br>impl Executor for BashExecutor {<br>    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;&#39;static str&gt; {<br>        Ok(format!(<br>            &quot;fake bash execute: env: {}, cmd: {}&quot;,<br>            self.env, cmd<br>        ))<br>    }<br>}<br><br>&#47;&#47; 看看我给的 tonic 的例子，想想怎么实现让 27 行可以正常执行<br><br>fn main() {<br>    let env = &quot;PATH=&#47;usr&#47;bin&quot;.to_string();<br><br>    let cmd = &quot;cat &#47;etc&#47;passwd&quot;;<br>    let r1 = execute(cmd, BashExecutor { env: env.clone() });<br>    println!(&quot;{:?}&quot;, r1);<br><br>    let r2 = execute(cmd, |cmd: &amp;str| {<br>        Ok(format!(&quot;fake fish execute: env: {}, cmd: {}&quot;, env, cmd))<br>    });<br>    println!(&quot;{:?}&quot;, r2);<br>}<br><br>fn execute(cmd: &amp;str, exec: impl Executor) -&gt; Result&lt;String, &amp;&#39;static str&gt; {<br>    exec.execute(cmd)<br>}","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527818,"discussion_content":"👍 非常好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633813410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314831,"user_name":"记事本","can_delete":false,"product_type":"c1","uid":1401568,"ip_address":"","ucode":"FA942636EE0CC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","comment_is_top":false,"comment_ctime":1633490220,"is_pvip":false,"replies":[{"id":"114171","content":"👍非常好！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633813435,"ip_address":"","comment_id":314831,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1633490220","product_id":100085301,"comment_content":"1、不能访问，name变量的所有权已经被移动闭包里面去了，move强制导致的<br>3、pub trait Executor{<br>    fn execute(&amp;self,cmd:&amp;str) -&gt;Result&lt;String,&amp;&#39;static str&gt;;<br>}<br><br>struct BashExecutor{<br>    env:String<br>}<br><br>impl Executor for BashExecutor{<br>    fn execute(&amp;self, cmd:&amp;str) -&gt;Result&lt;String,&amp;&#39;static str&gt; {<br>       Ok(format!(<br>            &quot;fake bash execute:env:{},cmd :{}&quot;,self.env,cmd<br>       )) <br>    }<br>}<br><br>impl &lt;F&gt; Executor for F <br>where F:Fn(&amp;str) -&gt;Result&lt;String,&amp;&#39;static str&gt;<br>{<br><br>    fn execute(&amp;self, cmd:&amp;str) -&gt;Result&lt;String,&amp;&#39;static str&gt; {<br>        self(cmd)<br>    }<br>    <br>}<br><br><br>fn execute(cmd:&amp;str,exec:impl Executor) -&gt; Result&lt;String,&amp;&#39;static str&gt;{<br>    exec.execute(cmd)<br>}<br><br>pub fn test(){<br>    let env = &quot;PATH=&#47;usr&#47;bin&quot;.to_string();<br><br>    let cmd = &quot;cat &#47;etc&#47;passwd&quot;;<br><br>    let r1 = execute(cmd, BashExecutor{env:env.clone()});<br>    println!(&quot;{:?}&quot;,r1);<br><br><br>    let r2 = execute(cmd, |cmd :&amp;str|{<br>        Ok(format!(&quot;fake fish execute: env: {}, cmd: {}&quot;, env, cmd))<br>    });<br>    println!(&quot;{:?}&quot;,r2);<br><br>}<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527805,"discussion_content":"👍非常好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633813435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141192,"avatar":"https://static001.geekbang.org/account/avatar/00/11/69/c8/d6f00a46.jpg","nickname":"wowotuo","note":"","ucode":"D87BCBD3EA61A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537642,"discussion_content":"闭包的数据都在栈上，那么\nfn main() {\n    let mut vec = vec![&#34;Rust&#34;, &#34;Elixir&#34;, &#34;Javascript&#34;];\n    let mut c = move || {\n        vec.push(&#34;julia&#34;); \n        println!(&#34;v: {:?}&#34;, vec);\n    };\n    c();\n}\n闭包捕获vec后，vec也存放在栈上？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639127575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}