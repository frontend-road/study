{"id":196785,"title":"30 | Coroutines：协作式的交叉调度执行","content":"<p>你好，我是吴咏炜。</p><p>今天是我们未来篇的最后一讲，也是这个专栏正文内容的最后一篇了。我们讨论 C++20 里的又一个非常重要的新功能——协程 Coroutines。</p><h2>什么是协程？</h2><p>协程是一个很早就被提出的编程概念。根据高德纳的描述，协程的概念在 1958 年就被提出了。不过，它在主流编程语言中得到的支持不那么好，因而你很可能对它并不熟悉吧。</p><p>如果查阅维基百科，你可以看到下面这样的定义 <span class=\"orange\">[1]</span>：</p><blockquote>\n<p>协程是计算机程序的⼀类组件，推⼴了协作式多任务的⼦程序，允许执⾏被挂起与被恢复。相对⼦例程⽽⾔，协程更为⼀般和灵活……</p>\n</blockquote><p>等学完了这一讲，也许你可以明白这段话的意思。但对不了解协程的人来说，估计只能吐槽一句了，这是什么鬼？</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/f9/4d4fb4a1c16edb1087d934cd1bb7eef9.png?wh=1142*293\" alt=\"\" title=\"图片源自网络\"></p><p>很遗憾，在 C++ 里的标准协程有点小复杂。我们还是从……Python 开始。</p><pre><code class=\"language-python\">def fibonacci():\n    a = 0\n    b = 1\n    while True:\n        yield b\n        a, b = b, a + b\n</code></pre><p>即使你没学过 Python，上面这个生成斐波那契数列的代码应该也不难理解。唯一看起来让人会觉得有点奇怪的应该就是那个 <code>yield</code> 了。这种写法在 Python 里叫做“生成器”（generator），返回的是一个可迭代的对象，每次迭代就能得到一个 yield 出来的结果。这就是一种很常见的协程形式了。</p><!-- [[[read_end]]] --><p>如何使用这个生成器，请看下面的代码：</p><pre><code class=\"language-python\"># 打印头 20 项\nfor i in islice(fibonacci(), 20):\n    print(i)\n\n# 打印小于 10000 的数列项\nfor i in takewhile(\n        lambda x: x &lt; 10000,\n        fibonacci()):\n    print(i)\n</code></pre><p>这些代码很容易理解：<code>islice</code> 相当于<a href=\"https://time.geekbang.org/column/article/195553\">[第 29 讲]</a> 中的 <code>take</code>，取一个范围的头若干项；<code>takewhile</code> 则在范围中逐项取出内容，直到第一个参数的条件不能被满足。两个函数的结果都可以被看作是 C++ 中的视图。</p><p>我们唯一需要提的是，在代码的执行过程中，<code>fibonacci</code> 和它的调用代码是交叉执行的。下面我们用代码行加注释的方式标一下：</p><pre><code class=\"language-python\">a = 0  # fibonacci()\nb = 0  # fibonacci()\nyield b  # fibonacci()\nprint(i)  # 调用者\na, b = 1, 0 + 1  # fibonacci()\nyield b  # fibonacci()\nprint(i)  # 调用者\na, b = 1, 1 + 1  # fibonacci()\nyield b  # fibonacci()\nprint(i)  # 调用者\na, b = 2, 1 + 2  # fibonacci()\nyield b  # fibonacci()\nprint(i)  # 调用者\n…\n</code></pre><p>学到这儿的同学应该都知道我们在 C++ 里怎么完成类似的功能吧？我就不讲解了，直接给出可工作的代码。这是对应的 <code>fibonacci</code> 的定义：</p><pre><code class=\"language-c++\">#include &lt;iterator&gt;\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n\nclass fibonacci {\npublic:\n  class sentinel;\n  class iterator;\n  iterator begin() noexcept;\n  sentinel end() noexcept;\n};\n\nclass fibonacci::sentinel {};\n\nclass fibonacci::iterator {\npublic:\n  // Required to satisfy iterator\n  // concept\n  typedef ptrdiff_t difference_type;\n  typedef uint64_t value_type;\n  typedef const uint64_t* pointer;\n  typedef const uint64_t&amp; reference;\n  typedef std::input_iterator_tag\n    iterator_category;\n\n  value_type operator*() const\n  {\n    return b_;\n  }\n  pointer operator-&gt;() const\n  {\n    return &amp;b_;\n  }\n  iterator&amp; operator++()\n  {\n    auto tmp = a_;\n    a_ = b_;\n    b_ += tmp;\n    return *this;\n  }\n  iterator operator++(int)\n  {\n    auto tmp = *this;\n    ++*this;\n    return tmp;\n  }\n  bool\n  operator==(const sentinel&amp;) const\n  {\n    return false;\n  }\n  bool\n  operator!=(const sentinel&amp;) const\n  {\n    return true;\n  }\n\nprivate:\n  uint64_t a_{0};\n  uint64_t b_{1};\n};\n\n// sentinel needs to be\n// equality_comparable_with iterator\nbool operator==(\n  const fibonacci::sentinel&amp; lhs,\n  const fibonacci::iterator&amp; rhs)\n{\n  return rhs == lhs;\n}\nbool operator!=(\n  const fibonacci::sentinel&amp; lhs,\n  const fibonacci::iterator&amp; rhs)\n{\n  return rhs != lhs;\n}\n\ninline fibonacci::iterator\nfibonacci::begin() noexcept\n{\n  return iterator();\n}\n\ninline fibonacci::sentinel\nfibonacci::end() noexcept\n{\n  return sentinel();\n}\n</code></pre><p>调用代码跟 Python 的相似：</p><pre><code class=\"language-c++\">// 打印头 20 项\nfor (auto i :\n     fibonacci() | take(20)) {\n  cout &lt;&lt; i &lt;&lt; endl;\n}\n\n// 打印小于 10000 的数列项\nfor (auto i :\n     fibonacci() |\n       take_while([](uint64_t x) {\n         return x &lt; 10000;\n       })) {\n  cout &lt;&lt; i &lt;&lt; endl;\n}\n</code></pre><p>这似乎还行。但 <code>fibonacci</code> 的定义差异就大了：在 Python 里是 6 行有效代码，在 C++ 里是 53 行。C++ 的生产率似乎有点低啊……</p><h2>C++20 协程</h2><p>C++20 协程的基础是微软提出的 Coroutines TS（可查看工作草案 <span class=\"orange\">[2]</span>），它在 2019 年 7 月被批准加入到 C++20 草案中。目前，MSVC 和 Clang 已经支持协程。不过，需要提一下的是，目前被标准化的只是协程的底层语言支持，而不是上层的高级封装；稍后，我们会回到这个话题。</p><p>协程可以有很多不同的用途，下面列举了几种常见情况：</p><ul>\n<li>生成器</li>\n<li>异步 I/O</li>\n<li>惰性求值</li>\n<li>事件驱动应用</li>\n</ul><p>这一讲中，我们主要还是沿用生成器的例子，向你展示协程的基本用法。异步 I/O 应当在协程得到广泛采用之后，成为最能有明显收益的使用场景；但目前，就我看到的，只有 Windows 平台上有较好的支持——微软目前还是做了很多努力的。</p><p>回到 Coroutines。我们今天采用 Coroutines TS 中的写法，包括 <code>std::experimental</code> 名空间，以确保你可以在 MSVC 和 Clang 下编译代码。首先，我们看一下协程相关的新关键字，有下面三个：</p><ul>\n<li><code>co_await</code></li>\n<li><code>co_yield</code></li>\n<li><code>co_return</code></li>\n</ul><p>这三个关键字最初是没有 <code>co_</code> 前缀的，但考虑到 <code>await</code>、<code>yield</code> 已经在很多代码里出现，就改成了目前这个样子。同时，<code>return</code> 和 <code>co_return</code> 也作出了明确的区分：一个协程里只能使用 <code>co_return</code>，不能使用 <code>return</code>。这三个关键字只要有一个出现在函数中，这个函数就是一个协程了——从外部则看不出来，没有用其他语言常用的 <code>async</code> 关键字来标记（<code>async</code> 也已经有其他用途了，见<a href=\"https://time.geekbang.org/column/article/186689\">[第 19 讲]</a>）。C++ 认为一个函数是否是一个协程是一个实现细节，不是对外接口的一部分。</p><p>我们看一下用协程实现的 <code>fibonacci</code> 长什么样子：</p><pre><code class=\"language-c++\">uint64_resumable fibonacci()\n{\n  uint64_t a = 0;\n  uint64_t b = 1;\n  while (true) {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\n</code></pre><p>这个形式跟 Python 的非常相似了吧，也非常简洁。我们稍后再讨论 <code>uint64_resumable</code> 的定义，先看一下调用代码的样子：</p><pre><code class=\"language-c++\">auto res = fibonacci();\nwhile (res.resume()) {\n  auto i = res.get();\n  if (i &gt;= 10000) {\n    break;\n  }\n  cout &lt;&lt; i &lt;&lt; endl;\n}\n</code></pre><p>这个代码也非常简单，但我们需要留意 <code>resume</code> 和 <code>get</code> 两个函数调用——这就是我们的 <code>uint64_resumable</code> 类型需要提供的接口了。</p><h3>co_await、co_yield、co_return 和协程控制</h3><p>在讨论该如何定义 <code>uint64_resumable</code> 之前，我们需要先讨论一下协程的这三个新关键字。</p><p>首先是 <code>co_await</code>。对于下面这样一个表达式：</p><pre><code class=\"language-c++\">auto result = co_await 表达式;\n</code></pre><p>编译器会把它理解为：</p><pre><code class=\"language-c++\">auto&amp;&amp; __a = 表达式;\nif (!__a.await_ready()) {\n  __a.await_suspend(协程句柄);\n  // 挂起/恢复点\n}\nauto result = __a.await_resume();\n</code></pre><p>也就是说，“表达式”需要支持 <code>await_ready</code>、<code>await_suspend</code> 和 <code>await_resume</code> 三个接口。如果 <code>await_ready()</code> 返回真，就代表不需要真正挂起，直接返回后面的结果就可以；否则，执行 <code>await_suspend</code> 之后即挂起协程，等待协程被唤醒之后再返回 <code>await_resume()</code> 的结果。这样一个表达式被称作是个 awaitable。</p><p>标准里定义了两个 awaitable，如下所示：</p><pre><code class=\"language-c++\">struct suspend_always {\n  bool await_ready() const noexcept\n  {\n    return false;\n  }\n  void await_suspend(\n    coroutine_handle&lt;&gt;)\n    const noexcept {}\n  void await_resume()\n    const noexcept {}\n};\n\nstruct suspend_never {\n  bool await_ready() const noexcept\n  {\n    return true;\n  }\n  void await_suspend(\n    coroutine_handle&lt;&gt;)\n    const noexcept {}\n  void await_resume()\n    const noexcept {}\n};\n</code></pre><p>也就是说，<code>suspend_always</code> 永远告诉调用者需要挂起，而 <code>suspend_never</code> 则永远告诉调用者不需要挂起。两者的 <code>await_suspend</code> 和 <code>await_resume</code> 都是平凡实现，不做任何实际的事情。一个 awaitable 可以自行实现这些接口，以定制挂起之前和恢复之后需要执行的操作。</p><p>上面的 <code>coroutine_handle</code> 是 C++ 标准库提供的类模板。这个类是用户代码跟系统协程调度真正交互的地方，有下面这些成员函数我们等会就会用到：</p><ul>\n<li><code>destroy</code>：销毁协程</li>\n<li><code>done</code>：判断协程是否已经执行完成</li>\n<li><code>resume</code>：让协程恢复执行</li>\n<li><code>promise</code>：获得协程相关的 promise 对象（和<a href=\"https://time.geekbang.org/column/article/186689\">[第 19 讲]</a> 中的“承诺量”有点相似，是协程和调用者的主要交互对象；一般类型名称为 <code>promise_type</code>）</li>\n<li><code>from_promise</code>（静态）：通过 promise 对象的引用来生成一个协程句柄</li>\n</ul><p>协程的执行过程大致是这个样子的：</p><ol>\n<li>为协程调用分配一个协程帧，含协程调用的参数、变量、状态、promise 对象等所需的空间。</li>\n<li>调用 <code>promise.get_return_object()</code>，返回值会在协程第一次挂起时返回给协程的调用者。</li>\n<li>执行 <code>co_await promise.initial_suspsend()</code>；根据上面对 <code>co_await</code> 语义的描述，协程可能在此第一次挂起（但也可能此时不挂起，在后面的协程体执行过程中挂起）。</li>\n<li>执行协程体中的语句，中间可能有挂起和恢复；如果期间发生异常没有在协程体中处理，则调用 <code>promise.unhandled_exception()</code>。</li>\n<li>当协程执行到底，或者执行到 <code>co_return</code> 语句时，会根据是否有非 void 的返回值，调用 <code>promise.return_value(…)</code> 或 <code>promise.return_void()</code>，然后执行 <code>co_await promise.final_suspsend()</code>。</li>\n</ol><p>用代码可以大致表示如下：</p><pre><code class=\"language-c++\">  frame = operator new(…);\n  promise_type&amp; promise =\n    frame-&gt;promise;\n\n  // 在初次挂起时返回给调用者\n  auto return_value =\n    promise.get_return_object();\n\n  co_await promise\n    .initial_suspsend();\n  try {\n    执行协程体;\n    可能被 co_wait、co_yield 挂起;\n    恢复后继续执行，直到 co_return;\n  }\n  catch (...) {\n    promise.unhandled_exception();\n  }\n\nfinal_suspend:\n  co_await promise.final_suspsend();\n</code></pre><p>上面描述了 <code>co_await</code> 和 <code>co_return</code>，那 <code>co_yield</code> 呢？也很简单，<code>co_yield 表达式</code> 等价于：</p><pre><code class=\"language-c++\">co_await promise.yield_value(表达式);\n</code></pre><h3>定义 <code>uint64_resumable</code></h3><p>了解了上述知识之后，我们就可以展示一下 <code>uint64_resumable</code> 的定义了：</p><pre><code class=\"language-c++\">class uint64_resumable {\npublic:\n  struct promise_type {…};\n\n  using coro_handle =\n    coroutine_handle&lt;promise_type&gt;;\n  explicit uint64_resumable(\n    coro_handle handle)\n    : handle_(handle)\n  {\n  }\n  ~uint64_resumable()\n  {\n    handle_.destroy();\n  }\n  uint64_resumable(\n    const uint64_resumable&amp;) =\n    delete;\n  uint64_resumable(\n    uint64_resumable&amp;&amp;) = default;\n  bool resume();\n  uint64_t get();\n\nprivate:\n  coro_handle handle_;\n};\n</code></pre><p>这个代码相当简单，我们的结构内部有个 <code>promise_type</code>（下面会定义），而私有成员只有一个协程句柄。协程构造需要一个协程句柄，析构时将使用协程句柄来销毁协程；为简单起见，我们允许结构被移动，但不可复制（以免重复调用 <code>handle_.destroy()</code>）。除此之外，我们这个结构只提供了调用者需要的 <code>resume</code> 和 <code>get</code> 成员函数，分别定义如下：</p><pre><code class=\"language-c++\">bool uint64_resumable::resume()\n{\n  if (!handle_.done()) {\n    handle_.resume();\n  }\n  return !handle_.done();\n}\n\nuint64_t uint64_resumable::get()\n{\n  return handle_.promise().value_;\n}\n</code></pre><p>也就是说，<code>resume</code> 会判断协程是否已经结束，没结束就恢复协程的执行；当协程再次挂起时（调用者恢复执行），返回协程是否仍在执行中的状态。而 <code>get</code> 简单地返回存储在 promise 对象中的数值。</p><p>现在我们需要看一下 promise 类型了，它里面有很多协程的定制点，可以修改协程的行为：</p><pre><code class=\"language-c++\">struct promise_type {\n  uint64_t value_;\n  using coro_handle =\n    coroutine_handle&lt;promise_type&gt;;\n  auto get_return_object()\n  {\n    return uint64_resumable{\n      coro_handle::from_promise(\n        *this)};\n  }\n  constexpr auto initial_suspend()\n  {\n    return suspend_always();\n  }\n  constexpr auto final_suspend()\n  {\n    return suspend_always();\n  }\n  auto yield_value(uint64_t value)\n  {\n    value_ = value;\n    return suspend_always();\n  }\n  void return_void() {}\n  void unhandled_exception()\n  {\n    std::terminate();\n  }\n};\n</code></pre><p>简单解说一下：</p><ul>\n<li>结构里面只有一个数据成员 <code>value_</code>，存放供 <code>uint64_resumable::get</code> 取用的数值。</li>\n<li><code>get_return_object</code> 是第一个定制点。我们前面提到过，调用协程的返回值就是 <code>get_return_object()</code> 的结果。我们这儿就是使用 promise 对象来构造一个 <code>uint64_resumable</code>。</li>\n<li><code>initial_suspend</code> 是第二个定制点。我们此处返回 <code>suspend_always()</code>，即协程立即挂起，调用者马上得到 <code>get_return_object()</code> 的结果。</li>\n<li><code>final_suspend</code> 是第三个定制点。我们此处返回 <code>suspend_always()</code>，即使执行到了 <code>co_return</code> 语句，协程仍处于挂起状态。如果我们返回 <code>suspend_never()</code> 的话，那一旦执行了 <code>co_return</code> 或执行到协程结束，协程就会被销毁，连同已初始化的本地变量和 promise，并释放协程帧内存。</li>\n<li><code>yield_value</code> 是第四个定制点。我们这儿仅对 <code>value_</code> 进行赋值，然后让协程挂起（执行控制回到调用者）。</li>\n<li><code>return_void</code> 是第五个定制点。我们的代码永不返回，这儿无事可做。</li>\n<li><code>unhandled_exception</code> 是第六个定制点。我们这儿也不应该发生任何异常，所以我们简单地调用 <code>terminate</code> 来终结程序的执行。</li>\n</ul><p>好了，这样，我们就完成了协程相关的所有定义。有没有觉得轻松点？</p><hr><p>没有？那就对了。正如我在这一节开头说的，C++20 标准化的只是协程的底层语言支持（我上面还并不是一个非常完整的描述）。要用这些底层直接写应用代码，那是非常痛苦的事。这些接口的目标用户实际上也不是普通开发者，而是库的作者。</p><p>幸好，我们并不是没有任何高层抽象，虽然这些实现不“标准”。</p><h2>C++20 协程的高层抽象</h2><h3>cppcoro</h3><p>我们首先看一下跨平台的 cppcoro 库 <span class=\"orange\">[3]</span>，它提供的高层接口就包含了 <code>generator</code>。如果使用 cppcoro，我们的 <code>fibonacci</code> 协程可以这样实现：</p><pre><code class=\"language-c++\">#include &lt;cppcoro/generator.hpp&gt;\nusing cppcoro::generator;\n\ngenerator&lt;uint64_t&gt; fibonacci()\n{\n  uint64_t a = 0;\n  uint64_t b = 1;\n  while (true) {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\n</code></pre><p>使用 <code>fibonacci</code> 也比刚才的代码要方便：</p><pre><code class=\"language-c++\">for (auto i : fibonacci()) {\n  if (i &gt;= 10000) {\n    break;\n  }\n  cout &lt;&lt; i &lt;&lt; endl;\n}\n</code></pre><p>除了生成器，cppcoro 还支持异步任务和异步 I/O——遗憾的是，异步 I/O 目前只有 Windows 平台上有，还没人实现 Linux 或 macOS 上的支持。</p><h3>MSVC</h3><p>作为协程的先行者和 Coroutines TS 的提出者，微软在协程上做了很多工作。生成器当然也在其中：</p><pre><code class=\"language-c++\">#include &lt;experimental/generator&gt;\nusing std::experimental::generator;\n\ngenerator&lt;uint64_t&gt; fibonacci()\n{\n  uint64_t a = 0;\n  uint64_t b = 1;\n  while (true) {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\n</code></pre><p>微软还有一些有趣的私有扩展。比如，MSVC 把标准 C++ 的 <code>future</code> 改造成了 awaitable。下面的代码在 MSVC 下可以编译通过，简单地展示了基本用法：</p><pre><code class=\"language-c++\">future&lt;int&gt; compute_value()\n{\n  int result = co_await async([] {\n    this_thread::sleep_for(1s);\n    return 42;\n  });\n  co_return result;\n}\n\nint main()\n{\n  auto value = compute_value();\n  cout &lt;&lt; value.get() &lt;&lt; endl;\n}\n</code></pre><p>代码中有一个地方我需要提醒一下：虽然上面 <code>async</code> 返回的是 <code>future&lt;int&gt;</code>，但 <code>compute_value</code> 的调用者得到的并不是这个 <code>future</code>——它得到的是另外一个独立的 <code>future</code>，并最终由 <code>co_return</code> 把结果数值填充了进去。</p><h2>有栈协程和无栈协程</h2><p>我们最后需要说一下有栈（stackful）协程和无栈（stackless）协程的区别。C++ 里很早就有了有栈的协程，概念上来讲，有栈的协程跟纤程、goroutines 基本是一个概念，都是由用户自行调度的、操作系统之外的运行单元。每个这样的运行单元都有自己独立的栈空间，缺点当然就是栈的空间占用和切换栈的开销了。而无栈的协程自己没有独立的栈空间，每个协程只需要一个很小的栈帧，空间占用小，也没有栈的切换开销。</p><p>C++20 的协程是无栈的。部分原因是有栈的协程可以使用纯库方式实现，而无栈的协程需要一点编译器魔法帮忙。毕竟，协程里面的变量都是要放到堆上而不是栈上的。</p><p>一个简单的无栈协程调用的内存布局如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/66/e35d2b262c741acf40d69eedc6a5ad66.png?wh=1032*824\" alt=\"\"></p><p>可以看到，协程 C 本身的本地变量不占用栈，但当它调用其他函数时，它会使用线程原先的栈空间。在上面的函数 D 的执行过程中，协程是不可以挂起的——如果控制回到 B 继续，B 可能会使用目前已经被 D 使用的栈空间！</p><p>因此，无栈的协程牺牲了一定的灵活性，换来了空间的节省和性能。有栈的协程你可能起几千个就占用不少内存空间，而无栈的协程可以轻轻松松起到亿级——毕竟，维持基本状态的开销我实测下来只有一百字节左右。</p><p>反过来，如果无栈的协程不满足需要——比如，你的协程里需要有递归调用，并在深层挂起——你就不得不寻找一个有栈的协程的解决方案。目前已经有一些成熟的方案，比如 Boost.Coroutine2 <span class=\"orange\">[4]</span>。下面的代码展示如何在 Boost.Coroutine2 里实现 <code>fibonacci</code>，让你感受一点点小区别：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;stdint.h&gt;\n#include &lt;boost/coroutine2/all.hpp&gt;\n\ntypedef boost::coroutines2::\n  coroutine&lt;const uint64_t&gt;\n    coro_t;\n\nvoid fibonacci(\n  coro_t::push_type&amp; yield)\n{\n  uint64_t a = 0;\n  uint64_t b = 1;\n  while (true) {\n    yield(b);\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\n\nint main()\n{\n  for (auto i : coro_t::pull_type(\n         boost::coroutines2::\n           fixedsize_stack(),\n         fibonacci)) {\n    if (i &gt;= 10000) {\n      break;\n    }\n    std::cout &lt;&lt; i &lt;&lt; std::endl;\n  }\n}\n</code></pre><h2>编译器支持</h2><p>前面提到了，MSVC 和 Clang 目前支持协程。不过，它们都需要特殊的命令行选项来开启协程支持：</p><ul>\n<li>MSVC 需要 <code>/await</code> 命令行选项</li>\n<li>Clang 需要 <code>-fcoroutines-ts</code> 命令行选项</li>\n</ul><p>为了满足使用 CMake 的同学的要求，也为了方便大家编译，我把示例代码放到了 GitHub 上：<a href=\"https://github.com/adah1972/geek_time_cpp\">https://github.com/adah1972/geek_time_cpp</a></p><h2>内容小结</h2><p>本讲讨论了 C++20 里的第三个重要特性：协程。协程仍然很新，但它的重要性是毋庸置疑的——尤其在生成器和异步 I/O 上。</p><h2>课后思考</h2><p>请仔细比较第一个 <code>fibonacci</code> 的 C++ 实现和最后使用 <code>generator</code> 的 <code>fibonacci</code> 的实现，体会协程代码如果自行用状态机的方式来实现，是一件多麻烦的事情。</p><p>如果你对协程有兴趣，可以查看参考资料 <span class=\"orange\">[5]</span>，里面提供了一些较为深入的原理介绍。</p><h2><span class=\"reference\">参考资料 </span></h2><p><span class=\"reference\">[1] 维基百科, “协程”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%8D%8F%E7%A8%8B\">https://zh.wikipedia.org/zh-cn/协程</a> </span></p><p><span class=\"reference\">[2] Gor Nishanov, “Working draft, C++ extensions for coroutines”. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf</a> </span></p><p><span class=\"reference\">[3] Lewis Baker, CppCoro. <a href=\"https://github.com/lewissbaker/cppcoro\">https://github.com/lewissbaker/cppcoro</a> </span></p><p><span class=\"reference\">[4] Oliver Kowalke, Boost.Coroutine2. <a href=\"https://www.boost.org/doc/libs/release/libs/coroutine2/doc/html/index.html\">https://www.boost.org/doc/libs/release/libs/coroutine2/doc/html/index.html</a> </span></p><p><span class=\"reference\">[5] Dawid Pilarski, “Coroutines introduction”. <a href=\"https://blog.panicsoftware.com/coroutines-introduction/\">https://blog.panicsoftware.com/coroutines-introduction/</a> </span></p>","neighbors":{"left":{"article_title":"29 | Ranges：无迭代器的迭代和更方便的组合","id":195553},"right":{"article_title":"结束语 | 终点已达，行程还要继续","id":198531}},"comments":[{"had_liked":false,"id":337612,"user_name":"吴咏炜","can_delete":false,"product_type":"c1","uid":1645639,"ip_address":"","ucode":"8C24C10AEC779F","user_header":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","comment_is_top":true,"comment_ctime":1646914064,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"参考资料 [3] 的 cppcoro 目前看起来已经不再维护了，跟新版编译器的兼容性问题一直无人解决。目前比较好的复刻在下面这个链接：\n\nhttps:&#47;&#47;github.com&#47;andreasbuhr&#47;cppcoro","like_count":2},{"had_liked":false,"id":230150,"user_name":"易轻尘","can_delete":false,"product_type":"c1","uid":1136684,"ip_address":"","ucode":"0D0CB9D6D45A70","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","comment_is_top":false,"comment_ctime":1593281868,"is_pvip":false,"replies":[{"id":84988,"content":"「计算机看到的是线程，调度的也是线程。」\n\n把「计算机」改成「操作系统」，你的评论就没问题了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1593313267,"ip_address":"","comment_id":230150,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"个人对协程的理解，可能不太准确：\n不可以混淆线程和协程两个概念。计算机看到的是线程，调度的也是线程。一个线程中可以有很多个协程，这些协程的执行顺序由程序员自己来调度。比较明显的好处是，1. 同一个线程中的协程不需要考虑数据的竞争问题，因为这些协程的执行顺序是固定的；2. 协程能够很方便的保存执行状态，使复杂状态机的实现变得简单；","like_count":7},{"had_liked":false,"id":292858,"user_name":"Fireplusplus","can_delete":false,"product_type":"c1","uid":1999021,"ip_address":"","ucode":"E19CBAECD7AA21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqAEFC6klazFO4gurkagZqjPb4BCv1VbnqHiaA0WVX9uINI7Jd9BBh3rJN2ljRFqicZxLjpHodIicPUw/132","comment_is_top":false,"comment_ctime":1621039762,"is_pvip":false,"replies":[{"id":106055,"content":"无栈协程在进入协程时仍会使用原先的栈帧，所有的本地变量则固定分配在堆上的一块内存里。有栈协程在执行时会启用一个自己的独立栈帧，后面挂起和恢复执行时也都需要切换栈帧，因而开销比无栈的要大。\n\n对具体细节感兴趣的话，网上这篇文章说得还比较细：\n\nhttps:&#47;&#47;mthli.xyz&#47;stackful-stackless&#47;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1621076582,"ip_address":"","comment_id":292858,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"无栈协程的内存布局可以明白函数D调用结束后，应该是通过编译器处理后的方式返回到协程C的堆上空间，协程c挂起之后堆仍然是保留的，但是一个有栈协程的内存布局应该是什么样子的，协程挂起之后不是要出栈才能回到调用者的栈桢吗？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519985,"discussion_content":"无栈协程在进入协程时仍会使用原先的栈帧，所有的本地变量则固定分配在堆上的一块内存里。有栈协程在执行时会启用一个自己的独立栈帧，后面挂起和恢复执行时也都需要切换栈帧，因而开销比无栈的要大。\n\n对具体细节感兴趣的话，网上这篇文章说得还比较细：\n\nhttps://mthli.xyz/stackful-stackless/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621076582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177879,"user_name":"谦谦君子","can_delete":false,"product_type":"c1","uid":1014684,"ip_address":"","ucode":"5A5B97B1CA7B73","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/9c/ffc2a5d9.jpg","comment_is_top":false,"comment_ctime":1581520284,"is_pvip":false,"replies":[{"id":69118,"content":"在栈里是一个明确的压栈顺序的（x86或类似平台上不管什么编译器实现都差不多）。而协程的数据放在堆里，并没有类似的顺序惯例，实际实现的顺序可能完全不一样。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581609013,"ip_address":"","comment_id":177879,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师， 图左边“调用X的参数”在“返回Y的地址”下面， 而右边“调用X的参数”在“返回Y的地址”上面， 是画错了么， 还是协成里面就是跟栈上函数调用是反的呢？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483581,"discussion_content":"在栈里是一个明确的压栈顺序的（x86或类似平台上不管什么编译器实现都差不多）。而协程的数据放在堆里，并没有类似的顺序惯例，实际实现的顺序可能完全不一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581609013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383555,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1699263559,"is_pvip":false,"replies":[{"id":140076,"content":"有co_的其中之一就是协程了。协程的第一次“返回”不是返回语句。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1699941615,"ip_address":"广东","comment_id":383555,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师下面的这个函数体内没有写co_return，为什么函数的返回值就可以写uint64_resumable ? \nuint64_resumable fibonacci()\n{\n  uint64_t a = 0;\n  uint64_t b = 1;\n  while (true) {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483581,"discussion_content":"在栈里是一个明确的压栈顺序的（x86或类似平台上不管什么编译器实现都差不多）。而协程的数据放在堆里，并没有类似的顺序惯例，实际实现的顺序可能完全不一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581609013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198538,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1585455798,"is_pvip":false,"replies":[{"id":74770,"content":"最基本协程和线程的区别就是，协程是程序自己调度的，线程是操作系统调度的。操作系统干的事情，开销自然大一些。反过来，协程的优势，性能就是很重要的一块了。\n\n协程在哪个线程运行，是你的代码决定的。你从哪个线程去调用协程或去 co_await&#47;co_yield 了，协程就在那个线程执行。像生成器那样的用法，完全只有一个线程，也不适合用多线程来改造。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585497005,"ip_address":"","comment_id":198538,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，请教两个问题：\n1。coroutine的能力是不是比线程弱？我们可以用线程的 mutex+condition-variable 或 primise+future 模拟coroutine。但coroutine究竟哪些方面弱于线程呢？\n2。coroutine的底层实现究竟是什么？它有cpu的上下文切换吗？还是所有coroutine都运行在同一个线程里，coroutine只是fibonacci c++实现那样的一种代码组织形式？\n谢谢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631763,"discussion_content":"有co_的其中之一就是协程了。协程的第一次“返回”不是返回语句。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1699941615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180179,"user_name":"Gallen","can_delete":false,"product_type":"c1","uid":1821566,"ip_address":"","ucode":"CFB50D4E8170F0","user_header":"https://static001.geekbang.org/account/avatar/00/1b/cb/7e/dd9258dd.jpg","comment_is_top":false,"comment_ctime":1582205727,"is_pvip":false,"replies":[{"id":69990,"content":"有事情先发我邮件好了。应该不会找不到吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582245332,"ip_address":"","comment_id":180179,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"您好，吴老师，之前在2018年cpp开发者大会上听过您讲string view和range，还巧妙的使用|管道符进行函数间对象传递，能否有幸添加一下您的微信？谢谢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484554,"discussion_content":"有事情先发我邮件好了。应该不会找不到吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582245332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1821566,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/cb/7e/dd9258dd.jpg","nickname":"Gallen","note":"","ucode":"CFB50D4E8170F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179651,"discussion_content":"好的老师，找得到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582246532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177362,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1581358814,"is_pvip":false,"replies":[{"id":68878,"content":"先说是不是，然后才谈得上为什么。\n\n在大部分情况下都没有必要那么做。我从来没在代码里写过 malloc_trim。\n\n在有虚拟内存的世界里，我看不出调用 malloc_trim 的必要性。操作系统自己能管好。\n\n如果嵌入式开发，没有虚拟内存，你用 malloc_trim 也不见得有用。因为一旦堆的尾部有分配，你并不能释放内存回操作系统。\n\n而且，你为什么要还内存给操作系统？以后你不用了吗？是程序要退出了吗？如果程序要退出，本来占用的资源就会被释放掉。如果程序不退出，进程管好自己的事，下次分配能不麻烦操作系统就不麻烦操作系统，应该反而更好。\n\n我的个人见解，谁告诉你这句话的，基本上并不真懂应用开发，只是学了点 Linux 的知识，在瞎卖弄而已。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581399512,"ip_address":"","comment_id":177362,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，map&lt;int, int&gt;().swap(map1);\n这个语句为什么不能达到真正释放map1内存的效果呢？必须得用malloc_trim","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483400,"discussion_content":"先说是不是，然后才谈得上为什么。\n\n在大部分情况下都没有必要那么做。我从来没在代码里写过 malloc_trim。\n\n在有虚拟内存的世界里，我看不出调用 malloc_trim 的必要性。操作系统自己能管好。\n\n如果嵌入式开发，没有虚拟内存，你用 malloc_trim 也不见得有用。因为一旦堆的尾部有分配，你并不能释放内存回操作系统。\n\n而且，你为什么要还内存给操作系统？以后你不用了吗？是程序要退出了吗？如果程序要退出，本来占用的资源就会被释放掉。如果程序不退出，进程管好自己的事，下次分配能不麻烦操作系统就不麻烦操作系统，应该反而更好。\n\n我的个人见解，谁告诉你这句话的，基本上并不真懂应用开发，只是学了点 Linux 的知识，在瞎卖弄而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581399512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177127,"user_name":"Vackine","can_delete":false,"product_type":"c1","uid":1139588,"ip_address":"","ucode":"8E412EE82D3B59","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/84/f45c4af9.jpg","comment_is_top":false,"comment_ctime":1581298887,"is_pvip":false,"replies":[{"id":68828,"content":"编程魔法和性能提升有矛盾么？🤪\n\n严肃点，协程不是为了提高代码性能，而是为了提高程序员的生产率。从这点上来说，协程仍然是一种编译器的黑魔法。\n\n跟手写比起来，没有性能的提升。就如同除了极少数的情况（比如泛型允许内联导致C++的排序比C的qsort快），C++代码不会比C代码性能更高。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581335925,"ip_address":"","comment_id":177127,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"感觉跟python里面的async的新的标准库好像，是真的有性能上的提升么，还是只是编程魔法？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483314,"discussion_content":"编程魔法和性能提升有矛盾么？🤪\n\n严肃点，协程不是为了提高代码性能，而是为了提高程序员的生产率。从这点上来说，协程仍然是一种编译器的黑魔法。\n\n跟手写比起来，没有性能的提升。就如同除了极少数的情况（比如泛型允许内联导致C++的排序比C的qsort快），C++代码不会比C代码性能更高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581335925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369208,"user_name":"徐","can_delete":false,"product_type":"c1","uid":1045869,"ip_address":"广东","ucode":"4EE8B126738A29","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/6d/fa3ab44d.jpg","comment_is_top":false,"comment_ctime":1677222986,"is_pvip":false,"replies":[{"id":134573,"content":"现在著名的异步框架 Asio 也支持协程了。阿里也有个协程库 PhotonLib。小而美的可以研究一下 netcan&#47;asyncio。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1677414295,"ip_address":"江苏","comment_id":369208,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"很早了解过协程的概念，说是用户级线程，在用户态调度，避免线程的内核态切换，性能更高；\n后来在一个 C++ 服务框架上也使用过，再后来切到 Go，用起了 goroutine；\n简单来说，协程用起来是真爽，避免了恶心的异步 IO 的 callback 写法，自我感觉也算是理解并熟练使用协程了。\n\n直到看了 C++ 20 的协程，完了惊掉下巴玩脑袋问号，这什么玩意儿，这是协程吗？\n查各种资料和书，都跟以前理解的不一样，特别是看到有人所谓的用几行代码实现协程，那更是不知所以。\n\n最后终于在这里解开了我的疑惑，原来以前理解和使用的协程，和 C++ 20 里的协程，一个是有栈协程，一个是无栈协程，有巨大差异，为啥在那些讲现代 C++ 的书里，都不提这个点，这个很关键呐，真是困扰我很久。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606801,"discussion_content":"现在著名的异步框架 Asio 也支持协程了。阿里也有个协程库 PhotonLib。小而美的可以研究一下 netcan/asyncio。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677414295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337612,"user_name":"吴咏炜","can_delete":false,"product_type":"c1","uid":1645639,"ip_address":"","ucode":"8C24C10AEC779F","user_header":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","comment_is_top":true,"comment_ctime":1646914064,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"参考资料 [3] 的 cppcoro 目前看起来已经不再维护了，跟新版编译器的兼容性问题一直无人解决。目前比较好的复刻在下面这个链接：\n\nhttps:&#47;&#47;github.com&#47;andreasbuhr&#47;cppcoro","like_count":2},{"had_liked":false,"id":230150,"user_name":"易轻尘","can_delete":false,"product_type":"c1","uid":1136684,"ip_address":"","ucode":"0D0CB9D6D45A70","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","comment_is_top":false,"comment_ctime":1593281868,"is_pvip":false,"replies":[{"id":84988,"content":"「计算机看到的是线程，调度的也是线程。」\n\n把「计算机」改成「操作系统」，你的评论就没问题了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1593313267,"ip_address":"","comment_id":230150,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"个人对协程的理解，可能不太准确：\n不可以混淆线程和协程两个概念。计算机看到的是线程，调度的也是线程。一个线程中可以有很多个协程，这些协程的执行顺序由程序员自己来调度。比较明显的好处是，1. 同一个线程中的协程不需要考虑数据的竞争问题，因为这些协程的执行顺序是固定的；2. 协程能够很方便的保存执行状态，使复杂状态机的实现变得简单；","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499784,"discussion_content":"「计算机看到的是线程，调度的也是线程。」\n\n把「计算机」改成「操作系统」，你的评论就没问题了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593313267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172429,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e3/cd/82829bf9.jpg","nickname":"Gerry","note":"","ucode":"C3A8BC33F2A25A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611337,"discussion_content":"严谨👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680049666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136684,"avatar":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","nickname":"易轻尘","note":"","ucode":"0D0CB9D6D45A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286894,"discussion_content":"谢谢老师指出，粗心大意了🙈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593320991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292858,"user_name":"Fireplusplus","can_delete":false,"product_type":"c1","uid":1999021,"ip_address":"","ucode":"E19CBAECD7AA21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqAEFC6klazFO4gurkagZqjPb4BCv1VbnqHiaA0WVX9uINI7Jd9BBh3rJN2ljRFqicZxLjpHodIicPUw/132","comment_is_top":false,"comment_ctime":1621039762,"is_pvip":false,"replies":[{"id":106055,"content":"无栈协程在进入协程时仍会使用原先的栈帧，所有的本地变量则固定分配在堆上的一块内存里。有栈协程在执行时会启用一个自己的独立栈帧，后面挂起和恢复执行时也都需要切换栈帧，因而开销比无栈的要大。\n\n对具体细节感兴趣的话，网上这篇文章说得还比较细：\n\nhttps:&#47;&#47;mthli.xyz&#47;stackful-stackless&#47;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1621076582,"ip_address":"","comment_id":292858,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"无栈协程的内存布局可以明白函数D调用结束后，应该是通过编译器处理后的方式返回到协程C的堆上空间，协程c挂起之后堆仍然是保留的，但是一个有栈协程的内存布局应该是什么样子的，协程挂起之后不是要出栈才能回到调用者的栈桢吗？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499784,"discussion_content":"「计算机看到的是线程，调度的也是线程。」\n\n把「计算机」改成「操作系统」，你的评论就没问题了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593313267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172429,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e3/cd/82829bf9.jpg","nickname":"Gerry","note":"","ucode":"C3A8BC33F2A25A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611337,"discussion_content":"严谨👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680049666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136684,"avatar":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","nickname":"易轻尘","note":"","ucode":"0D0CB9D6D45A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286894,"discussion_content":"谢谢老师指出，粗心大意了🙈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593320991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177879,"user_name":"谦谦君子","can_delete":false,"product_type":"c1","uid":1014684,"ip_address":"","ucode":"5A5B97B1CA7B73","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/9c/ffc2a5d9.jpg","comment_is_top":false,"comment_ctime":1581520284,"is_pvip":false,"replies":[{"id":69118,"content":"在栈里是一个明确的压栈顺序的（x86或类似平台上不管什么编译器实现都差不多）。而协程的数据放在堆里，并没有类似的顺序惯例，实际实现的顺序可能完全不一样。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581609013,"ip_address":"","comment_id":177879,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师， 图左边“调用X的参数”在“返回Y的地址”下面， 而右边“调用X的参数”在“返回Y的地址”上面， 是画错了么， 还是协成里面就是跟栈上函数调用是反的呢？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519985,"discussion_content":"无栈协程在进入协程时仍会使用原先的栈帧，所有的本地变量则固定分配在堆上的一块内存里。有栈协程在执行时会启用一个自己的独立栈帧，后面挂起和恢复执行时也都需要切换栈帧，因而开销比无栈的要大。\n\n对具体细节感兴趣的话，网上这篇文章说得还比较细：\n\nhttps://mthli.xyz/stackful-stackless/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621076582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383555,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1699263559,"is_pvip":false,"replies":[{"id":140076,"content":"有co_的其中之一就是协程了。协程的第一次“返回”不是返回语句。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1699941615,"ip_address":"广东","comment_id":383555,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师下面的这个函数体内没有写co_return，为什么函数的返回值就可以写uint64_resumable ? \nuint64_resumable fibonacci()\n{\n  uint64_t a = 0;\n  uint64_t b = 1;\n  while (true) {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631763,"discussion_content":"有co_的其中之一就是协程了。协程的第一次“返回”不是返回语句。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1699941615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198538,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1585455798,"is_pvip":false,"replies":[{"id":74770,"content":"最基本协程和线程的区别就是，协程是程序自己调度的，线程是操作系统调度的。操作系统干的事情，开销自然大一些。反过来，协程的优势，性能就是很重要的一块了。\n\n协程在哪个线程运行，是你的代码决定的。你从哪个线程去调用协程或去 co_await&#47;co_yield 了，协程就在那个线程执行。像生成器那样的用法，完全只有一个线程，也不适合用多线程来改造。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585497005,"ip_address":"","comment_id":198538,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，请教两个问题：\n1。coroutine的能力是不是比线程弱？我们可以用线程的 mutex+condition-variable 或 primise+future 模拟coroutine。但coroutine究竟哪些方面弱于线程呢？\n2。coroutine的底层实现究竟是什么？它有cpu的上下文切换吗？还是所有coroutine都运行在同一个线程里，coroutine只是fibonacci c++实现那样的一种代码组织形式？\n谢谢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489721,"discussion_content":"最基本协程和线程的区别就是，协程是程序自己调度的，线程是操作系统调度的。操作系统干的事情，开销自然大一些。反过来，协程的优势，性能就是很重要的一块了。\n\n协程在哪个线程运行，是你的代码决定的。你从哪个线程去调用协程或去 co_await/co_yield 了，协程就在那个线程执行。像生成器那样的用法，完全只有一个线程，也不适合用多线程来改造。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585497005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180179,"user_name":"Gallen","can_delete":false,"product_type":"c1","uid":1821566,"ip_address":"","ucode":"CFB50D4E8170F0","user_header":"https://static001.geekbang.org/account/avatar/00/1b/cb/7e/dd9258dd.jpg","comment_is_top":false,"comment_ctime":1582205727,"is_pvip":false,"replies":[{"id":69990,"content":"有事情先发我邮件好了。应该不会找不到吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582245332,"ip_address":"","comment_id":180179,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"您好，吴老师，之前在2018年cpp开发者大会上听过您讲string view和range，还巧妙的使用|管道符进行函数间对象传递，能否有幸添加一下您的微信？谢谢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489721,"discussion_content":"最基本协程和线程的区别就是，协程是程序自己调度的，线程是操作系统调度的。操作系统干的事情，开销自然大一些。反过来，协程的优势，性能就是很重要的一块了。\n\n协程在哪个线程运行，是你的代码决定的。你从哪个线程去调用协程或去 co_await/co_yield 了，协程就在那个线程执行。像生成器那样的用法，完全只有一个线程，也不适合用多线程来改造。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585497005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177362,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1581358814,"is_pvip":false,"replies":[{"id":68878,"content":"先说是不是，然后才谈得上为什么。\n\n在大部分情况下都没有必要那么做。我从来没在代码里写过 malloc_trim。\n\n在有虚拟内存的世界里，我看不出调用 malloc_trim 的必要性。操作系统自己能管好。\n\n如果嵌入式开发，没有虚拟内存，你用 malloc_trim 也不见得有用。因为一旦堆的尾部有分配，你并不能释放内存回操作系统。\n\n而且，你为什么要还内存给操作系统？以后你不用了吗？是程序要退出了吗？如果程序要退出，本来占用的资源就会被释放掉。如果程序不退出，进程管好自己的事，下次分配能不麻烦操作系统就不麻烦操作系统，应该反而更好。\n\n我的个人见解，谁告诉你这句话的，基本上并不真懂应用开发，只是学了点 Linux 的知识，在瞎卖弄而已。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581399512,"ip_address":"","comment_id":177362,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，map&lt;int, int&gt;().swap(map1);\n这个语句为什么不能达到真正释放map1内存的效果呢？必须得用malloc_trim","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484554,"discussion_content":"有事情先发我邮件好了。应该不会找不到吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582245332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1821566,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/cb/7e/dd9258dd.jpg","nickname":"Gallen","note":"","ucode":"CFB50D4E8170F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179651,"discussion_content":"好的老师，找得到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582246532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177127,"user_name":"Vackine","can_delete":false,"product_type":"c1","uid":1139588,"ip_address":"","ucode":"8E412EE82D3B59","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/84/f45c4af9.jpg","comment_is_top":false,"comment_ctime":1581298887,"is_pvip":false,"replies":[{"id":68828,"content":"编程魔法和性能提升有矛盾么？🤪\n\n严肃点，协程不是为了提高代码性能，而是为了提高程序员的生产率。从这点上来说，协程仍然是一种编译器的黑魔法。\n\n跟手写比起来，没有性能的提升。就如同除了极少数的情况（比如泛型允许内联导致C++的排序比C的qsort快），C++代码不会比C代码性能更高。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581335925,"ip_address":"","comment_id":177127,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"感觉跟python里面的async的新的标准库好像，是真的有性能上的提升么，还是只是编程魔法？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483400,"discussion_content":"先说是不是，然后才谈得上为什么。\n\n在大部分情况下都没有必要那么做。我从来没在代码里写过 malloc_trim。\n\n在有虚拟内存的世界里，我看不出调用 malloc_trim 的必要性。操作系统自己能管好。\n\n如果嵌入式开发，没有虚拟内存，你用 malloc_trim 也不见得有用。因为一旦堆的尾部有分配，你并不能释放内存回操作系统。\n\n而且，你为什么要还内存给操作系统？以后你不用了吗？是程序要退出了吗？如果程序要退出，本来占用的资源就会被释放掉。如果程序不退出，进程管好自己的事，下次分配能不麻烦操作系统就不麻烦操作系统，应该反而更好。\n\n我的个人见解，谁告诉你这句话的，基本上并不真懂应用开发，只是学了点 Linux 的知识，在瞎卖弄而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581399512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369208,"user_name":"徐","can_delete":false,"product_type":"c1","uid":1045869,"ip_address":"广东","ucode":"4EE8B126738A29","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/6d/fa3ab44d.jpg","comment_is_top":false,"comment_ctime":1677222986,"is_pvip":false,"replies":[{"id":134573,"content":"现在著名的异步框架 Asio 也支持协程了。阿里也有个协程库 PhotonLib。小而美的可以研究一下 netcan&#47;asyncio。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1677414295,"ip_address":"江苏","comment_id":369208,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"很早了解过协程的概念，说是用户级线程，在用户态调度，避免线程的内核态切换，性能更高；\n后来在一个 C++ 服务框架上也使用过，再后来切到 Go，用起了 goroutine；\n简单来说，协程用起来是真爽，避免了恶心的异步 IO 的 callback 写法，自我感觉也算是理解并熟练使用协程了。\n\n直到看了 C++ 20 的协程，完了惊掉下巴玩脑袋问号，这什么玩意儿，这是协程吗？\n查各种资料和书，都跟以前理解的不一样，特别是看到有人所谓的用几行代码实现协程，那更是不知所以。\n\n最后终于在这里解开了我的疑惑，原来以前理解和使用的协程，和 C++ 20 里的协程，一个是有栈协程，一个是无栈协程，有巨大差异，为啥在那些讲现代 C++ 的书里，都不提这个点，这个很关键呐，真是困扰我很久。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483314,"discussion_content":"编程魔法和性能提升有矛盾么？🤪\n\n严肃点，协程不是为了提高代码性能，而是为了提高程序员的生产率。从这点上来说，协程仍然是一种编译器的黑魔法。\n\n跟手写比起来，没有性能的提升。就如同除了极少数的情况（比如泛型允许内联导致C++的排序比C的qsort快），C++代码不会比C代码性能更高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581335925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297227,"user_name":"百年","can_delete":false,"product_type":"c1","uid":1526311,"ip_address":"","ucode":"6D41E3D3282255","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/27/2702206d.jpg","comment_is_top":false,"comment_ctime":1623385491,"is_pvip":false,"replies":[{"id":107987,"content":"这个方向应该不太会考虑……目前的工作全部是在 C++ 上了。😂","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623479662,"ip_address":"","comment_id":297227,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师结课有一年多了，什么时候开个C++与python联合编程的课啊。","like_count":0},{"had_liked":false,"id":297227,"user_name":"百年","can_delete":false,"product_type":"c1","uid":1526311,"ip_address":"","ucode":"6D41E3D3282255","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/27/2702206d.jpg","comment_is_top":false,"comment_ctime":1623385491,"is_pvip":false,"replies":[{"id":107987,"content":"这个方向应该不太会考虑……目前的工作全部是在 C++ 上了。😂","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623479662,"ip_address":"","comment_id":297227,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师结课有一年多了，什么时候开个C++与python联合编程的课啊。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521765,"discussion_content":"这个方向应该不太会考虑……目前的工作全部是在 C++ 上了。😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623479662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}