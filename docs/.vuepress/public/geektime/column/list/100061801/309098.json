{"id":309098,"title":"17 | SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？","content":"<p>你好，我是鸟窝。</p><p>这节课，我来给你介绍两个非常重要的扩展并发原语：SingleFlight和CyclicBarrier。SingleFlight的作用是将并发请求合并成一个请求，以减少对下层服务的压力；而CyclicBarrier是一个可重用的栅栏并发原语，用来控制一组请求同时执行的数据结构。</p><p>其实，它们两个并没有直接的关系，只是内容相对来说比较少，所以我打算用最短的时间带你掌握它们。一节课就能掌握两个“武器”，是不是很高效？</p><h1>请求合并SingleFlight</h1><p>SingleFlight是Go开发组提供的一个扩展并发原语。它的作用是，在处理多个goroutine同时调用同一个函数的时候，只让一个goroutine去调用这个函数，等到这个goroutine返回结果的时候，再把结果返回给这几个同时调用的goroutine，这样可以减少并发调用的数量。</p><p>这里我想先回答一个问题：标准库中的sync.Once也可以保证并发的goroutine只会执行一次函数f，那么，SingleFlight和sync.Once有什么区别呢？</p><p>其实，sync.Once不是只在并发的时候保证只有一个goroutine执行函数f，而是会保证永远只执行一次，而SingleFlight是每次调用都重新执行，并且在多个请求同时调用的时候只有一个执行。它们两个面对的场景是不同的，<strong>sync.Once主要是用在单次初始化场景中，而SingleFlight主要用在合并并发请求的场景中</strong>，尤其是缓存场景。</p><!-- [[[read_end]]] --><p>如果你学会了SingleFlight，在面对秒杀等大并发请求的场景，而且这些请求都是读请求时，你就可以把这些请求合并为一个请求，这样，你就可以将后端服务的压力从n降到1。尤其是在面对后端是数据库这样的服务的时候，采用 SingleFlight可以极大地提高性能。那么，话不多说，就让我们开始学习SingleFlight吧。</p><h2>实现原理</h2><p>SingleFlight使用互斥锁Mutex和Map来实现。Mutex提供并发时的读写保护，Map用来保存同一个key的正在处理（in flight）的请求。</p><p>SingleFlight的数据结构是Group，它提供了三个方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/da/2a260ccce4e06ea1be2cf3f7abbe84da.png?wh=1000*123\" alt=\"\"></p><ul>\n<li>Do：这个方法执行一个函数，并返回函数执行的结果。你需要提供一个key，对于同一个key，在同一时间只有一个在执行，同一个key并发的请求会等待。第一个执行的请求返回的结果，就是它的返回结果。函数fn是一个无参的函数，返回一个结果或者error，而Do方法会返回函数执行的结果或者是error，shared会指示v是否返回给多个请求。</li>\n<li>DoChan：类似Do方法，只不过是返回一个chan，等fn函数执行完，产生了结果以后，就能从这个chan中接收这个结果。</li>\n<li>Forget：告诉Group忘记这个key。这样一来，之后这个key请求会执行f，而不是等待前一个未完成的fn函数的结果。</li>\n</ul><p>下面，我们来看具体的实现方法。</p><p>首先，SingleFlight定义一个辅助对象call，这个call就代表正在执行fn函数的请求或者是已经执行完的请求。Group代表SingleFlight。</p><pre><code>  // 代表一个正在处理的请求，或者已经处理完的请求\n  type call struct {\n\t\twg sync.WaitGroup\n\t\n\n\t\t// 这个字段代表处理完的值，在waitgroup完成之前只会写一次\n        // waitgroup完成之后就读取这个值\n\t\tval interface{}\n\t\terr error\n\t\n        // 指示当call在处理时是否要忘掉这个key\n\t\tforgotten bool\n\t\tdups  int\n\t\tchans []chan&lt;- Result\n\t}\n\t\n    // group代表一个singleflight对象\n\ttype Group struct {\n\t\tmu sync.Mutex       // protects m\n\t\tm  map[string]*call // lazily initialized\n\t}\n</code></pre><p>我们只需要查看一个Do方法，DoChan的处理方法是类似的。</p><pre><code>  func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) {\n\t\tg.mu.Lock()\n\t\tif g.m == nil {\n\t\t\tg.m = make(map[string]*call)\n\t\t}\n\t\tif c, ok := g.m[key]; ok {//如果已经存在相同的key\n\t\t\tc.dups++\n\t\t\tg.mu.Unlock()\n\t\t\tc.wg.Wait() //等待这个key的第一个请求完成\n\t\t\treturn c.val, c.err, true //使用第一个key的请求结果\n\t\t}\n\t\tc := new(call) // 第一个请求，创建一个call\n\t\tc.wg.Add(1)\n\t\tg.m[key] = c //加入到key map中\n\t\tg.mu.Unlock()\n\t\n\n\t\tg.doCall(c, key, fn) // 调用方法\n\t\treturn c.val, c.err, c.dups &gt; 0\n\t}\n</code></pre><p>doCall方法会实际调用函数fn：</p><pre><code>  func (g *Group) doCall(c *call, key string, fn func() (interface{}, error)) {\n\t\tc.val, c.err = fn()\n\t\tc.wg.Done()\n\t\n\n\t\tg.mu.Lock()\n\t\tif !c.forgotten { // 已调用完，删除这个key\n\t\t\tdelete(g.m, key)\n\t\t}\n\t\tfor _, ch := range c.chans {\n\t\t\tch &lt;- Result{c.val, c.err, c.dups &gt; 0}\n\t\t}\n\t\tg.mu.Unlock()\n\t}\n</code></pre><p>在这段代码中，你要注意下第7行。在默认情况下，forgotten==false，所以第8行默认会被调用，也就是说，第一个请求完成后，后续的同一个key的请求又重新开始新一次的fn函数的调用。</p><p>Go标准库的代码中就有一个SingleFlight的<a href=\"https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/internal/singleflight/singleflight.go\">实现</a>，而扩展库中的SingleFlight就是在标准库的代码基础上改的，逻辑几乎一模一样，我就不多说了。</p><h2>应用场景</h2><p>了解了SingleFlight的实现原理，下面我们来看看它都应用于什么场景中。</p><p>Go代码库中有两个地方用到了SingleFlight。</p><p>第一个是在<a href=\"https://github.com/golang/go/blob/b1b67841d1e229b483b0c9dd50ddcd1795b0f90f/src/net/lookup.go\">net/lookup.go</a>中，如果同时有查询同一个host的请求，lookupGroup会把这些请求merge到一起，只需要一个请求就可以了：</p><pre><code>// lookupGroup merges LookupIPAddr calls together for lookups for the same\n// host. The lookupGroup key is the LookupIPAddr.host argument.\n// The return values are ([]IPAddr, error).\nlookupGroup singleflight.Group\n</code></pre><p>第二个是Go在查询仓库版本信息时，将并发的请求合并成1个请求：</p><pre><code>func metaImportsForPrefix(importPrefix string, mod ModuleMode, security web.SecurityMode) (*urlpkg.URL, []metaImport, error) {\n        // 使用缓存保存请求结果\n\t\tsetCache := func(res fetchResult) (fetchResult, error) {\n\t\t\tfetchCacheMu.Lock()\n\t\t\tdefer fetchCacheMu.Unlock()\n\t\t\tfetchCache[importPrefix] = res\n\t\t\treturn res, nil\n\t\t\n        // 使用 SingleFlight请求\n\t\tresi, _, _ := fetchGroup.Do(importPrefix, func() (resi interface{}, err error) {\n\t\t\tfetchCacheMu.Lock()\n            // 如果缓存中有数据，那么直接从缓存中取\n\t\t\tif res, ok := fetchCache[importPrefix]; ok {\n\t\t\t\tfetchCacheMu.Unlock()\n\t\t\t\treturn res, nil\n\t\t\t}\n\t\t\tfetchCacheMu.Unlock()\n            ......\n</code></pre><p>需要注意的是，这里涉及到了缓存的问题。上面的代码会把结果放在缓存中，这也是常用的一种解决缓存击穿的例子。</p><p>设计缓存问题时，我们常常需要解决缓存穿透、缓存雪崩和缓存击穿问题。缓存击穿问题是指，在平常高并发的系统中，大量的请求同时查询一个 key 时，如果这个key正好过期失效了，就会导致大量的请求都打到数据库上。这就是缓存击穿。</p><p>用SingleFlight来解决缓存击穿问题再合适不过了。因为，这个时候，只要这些对同一个key的并发请求的其中一个到数据库中查询，就可以了，这些并发的请求可以共享同一个结果。因为是缓存查询，不用考虑幂等性问题。</p><p>事实上，在Go生态圈知名的缓存框架groupcache中，就使用了较早的Go标准库的SingleFlight实现。接下来，我就来给你介绍一下groupcache是如何使用SingleFlight解决缓存击穿问题的。</p><p>groupcache中的SingleFlight只有一个方法：</p><pre><code>func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error)\n</code></pre><p>SingleFlight的作用是，在加载一个缓存项的时候，合并对同一个key的load的并发请求：</p><pre><code>\ttype Group struct {\n\t\t。。。。。。\n\t\t// loadGroup ensures that each key is only fetched once\n\t\t// (either locally or remotely), regardless of the number of\n\t\t// concurrent callers.\n\t\tloadGroup flightGroup\n        ......\n\t}\n\n    func (g *Group) load(ctx context.Context, key string, dest Sink) (value ByteView, destPopulated bool, err error) {\n\t\tviewi, err := g.loadGroup.Do(key, func() (interface{}, error)  {\n\t\t\t// 从cache, peer, local尝试查询cache\n\t\t\treturn value, nil\n\t\t})\n\t\tif err == nil {\n\t\t\tvalue = viewi.(ByteView)\n\t\t}\n\t\treturn\n\t}\n</code></pre><p>其它的知名项目如Cockroachdb（小强数据库）、CoreDNS（DNS服务器）等都有SingleFlight应用，你可以查看这些项目的代码，加深对SingleFlight的理解。</p><p>总结来说，使用SingleFlight时，可以通过合并请求的方式降低对下游服务的并发压力，从而提高系统的性能，常常用于缓存系统中。最后，我想给你留一个思考题，你觉得，SingleFlight能不能合并并发的写操作呢？</p><h1>循环栅栏CyclicBarrier</h1><p>接下来，我再给你介绍另外一个并发原语：循环栅栏（CyclicBarrier），它常常应用于重复进行一组goroutine同时执行的场景中。</p><p><a href=\"https://github.com/marusama/cyclicbarrier\">CyclicBarrier</a>允许一组goroutine彼此等待，到达一个共同的执行点。同时，因为它可以被重复使用，所以叫循环栅栏。具体的机制是，大家都在栅栏前等待，等全部都到齐了，就抬起栅栏放行。</p><p>事实上，这个CyclicBarrier是参考<a href=\"https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/concurrent/CyclicBarrier.html\">Java CyclicBarrier</a>和<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.threading.barrier?redirectedfrom=MSDN&amp;view=netcore-3.1\">C# Barrier</a>的功能实现的。Java提供了CountDownLatch（倒计时器）和CyclicBarrier（循环栅栏）两个类似的用于保证多线程到达同一个执行点的类，只不过前者是到达0的时候放行，后者是到达某个指定的数的时候放行。C# Barrier功能也是类似的，你可以查看链接，了解它的具体用法。</p><p>你可能会觉得，CyclicBarrier和WaitGroup的功能有点类似，确实是这样。不过，CyclicBarrier更适合用在“固定数量的goroutine等待同一个执行点”的场景中，而且在放行goroutine之后，CyclicBarrier可以重复利用，不像WaitGroup重用的时候，必须小心翼翼避免panic。</p><p>处理可重用的多goroutine等待同一个执行点的场景的时候，CyclicBarrier和WaitGroup方法调用的对应关系如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/79/c2123588d4aa9f7dedec7fc35435c679.jpg?wh=2486*1633\" alt=\"\"></p><p>可以看到，如果使用WaitGroup实现的话，调用比较复杂，不像CyclicBarrier那么清爽。更重要的是，如果想重用WaitGroup，你还要保证，将WaitGroup的计数值重置到n的时候不会出现并发问题。</p><p>WaitGroup更适合用在“一个goroutine等待一组goroutine到达同一个执行点”的场景中，或者是不需要重用的场景中。</p><p>好了，了解了CyclicBarrier的应用场景和功能，下面我们来学习下它的具体实现。</p><h2>实现原理</h2><p>CyclicBarrier有两个初始化方法：</p><ol>\n<li>第一个是New方法，它只需要一个参数，来指定循环栅栏参与者的数量；</li>\n<li>第二个方法是NewWithAction，它额外提供一个函数，可以在每一次到达执行点的时候执行一次。具体的时间点是在最后一个参与者到达之后，但是其它的参与者还未被放行之前。我们可以利用它，做放行之前的一些共享状态的更新等操作。</li>\n</ol><p>这两个方法的签名如下：</p><pre><code>func New(parties int) CyclicBarrier\nfunc NewWithAction(parties int, barrierAction func() error) CyclicBarrier\n</code></pre><p>CyclicBarrier是一个接口，定义的方法如下：</p><pre><code>type CyclicBarrier interface {\n    // 等待所有的参与者到达，如果被ctx.Done()中断，会返回ErrBrokenBarrier\n    Await(ctx context.Context) error\n\n    // 重置循环栅栏到初始化状态。如果当前有等待者，那么它们会返回ErrBrokenBarrier\n    Reset()\n\n    // 返回当前等待者的数量\n    GetNumberWaiting() int\n\n    // 参与者的数量\n    GetParties() int\n\n    // 循环栅栏是否处于中断状态\n    IsBroken() bool\n}\n</code></pre><p>循环栅栏的使用也很简单。循环栅栏的参与者只需调用Await等待，等所有的参与者都到达后，再执行下一步。当执行下一步的时候，循环栅栏的状态又恢复到初始的状态了，可以迎接下一轮同样多的参与者。</p><p>有一道非常经典的并发编程的题目，非常适合使用循环栅栏，下面我们来看一下。</p><h2>并发趣题：一氧化二氢制造工厂</h2><p>题目是这样的：</p><blockquote>\n<p>有一个名叫大自然的搬运工的工厂，生产一种叫做一氧化二氢的神秘液体。这种液体的分子是由一个氧原子和两个氢原子组成的，也就是水。</p>\n</blockquote><blockquote>\n<p>这个工厂有多条生产线，每条生产线负责生产氧原子或者是氢原子，每条生产线由一个goroutine负责。</p>\n</blockquote><blockquote>\n<p>这些生产线会通过一个栅栏，只有一个氧原子生产线和两个氢原子生产线都准备好，才能生成出一个水分子，否则所有的生产线都会处于等待状态。也就是说，一个水分子必须由三个不同的生产线提供原子，而且水分子是一个一个按照顺序产生的，每生产一个水分子，就会打印出HHO、HOH、OHH三种形式的其中一种。HHH、OOH、OHO、HOO、OOO都是不允许的。</p>\n</blockquote><blockquote>\n<p>生产线中氢原子的生产线为2N条，氧原子的生产线为N条。</p>\n</blockquote><p>你可以先想一下，我们怎么来实现呢？</p><p>首先，我们来定义一个H2O辅助数据类型，它包含两个信号量的字段和一个循环栅栏。</p><ol>\n<li>semaH信号量：控制氢原子。一个水分子需要两个氢原子，所以，氢原子的空槽数资源数设置为2。</li>\n<li>semaO信号量：控制氧原子。一个水分子需要一个氧原子，所以资源数的空槽数设置为1。</li>\n<li>循环栅栏：等待两个氢原子和一个氧原子填补空槽，直到任务完成。</li>\n</ol><p>我们来看下具体的代码：</p><pre><code>package water\nimport (\n\t&quot;context&quot;\n\t&quot;github.com/marusama/cyclicbarrier&quot;\n\t&quot;golang.org/x/sync/semaphore&quot;\n)\n// 定义水分子合成的辅助数据结构\ntype H2O struct {\n\tsemaH *semaphore.Weighted // 氢原子的信号量\n\tsemaO *semaphore.Weighted // 氧原子的信号量\n\tb     cyclicbarrier.CyclicBarrier // 循环栅栏，用来控制合成\n}\nfunc New() *H2O {\n\treturn &amp;H2O{\n\t\tsemaH: semaphore.NewWeighted(2), //氢原子需要两个\n\t\tsemaO: semaphore.NewWeighted(1), // 氧原子需要一个\n\t\tb:     cyclicbarrier.New(3),  // 需要三个原子才能合成\n\t}\n}\n</code></pre><p>接下来，我们看看各条流水线的处理情况。</p><p>流水线分为氢原子处理流水线和氧原子处理流水线，首先，我们先看一下氢原子的流水线：如果有可用的空槽，氢原子的流水线的处理方法是hydrogen，hydrogen方法就会占用一个空槽（h2o.semaH.Acquire），输出一个H字符，然后等待栅栏放行。等其它的goroutine填补了氢原子的另一个空槽和氧原子的空槽之后，程序才可以继续进行。</p><pre><code>func (h2o *H2O) hydrogen(releaseHydrogen func()) {\n\th2o.semaH.Acquire(context.Background(), 1)\n\n\treleaseHydrogen() // 输出H\n\th2o.b.Await(context.Background()) //等待栅栏放行\n\th2o.semaH.Release(1) // 释放氢原子空槽\n}\n</code></pre><p>然后是氧原子的流水线。氧原子的流水线处理方法是oxygen， oxygen方法是等待氧原子的空槽，然后输出一个O，就等待栅栏放行。放行后，释放氧原子空槽位。</p><pre><code>func (h2o *H2O) oxygen(releaseOxygen func()) {\n\th2o.semaO.Acquire(context.Background(), 1)\n\n\treleaseOxygen() // 输出O\n\th2o.b.Await(context.Background()) //等待栅栏放行\n\th2o.semaO.Release(1) // 释放氢原子空槽\n}\n</code></pre><p>在栅栏放行之前，只有两个氢原子的空槽位和一个氧原子的空槽位。只有等栅栏放行之后，这些空槽位才会被释放。栅栏放行，就意味着一个水分子组成成功。</p><p>这个算法是不是正确呢？我们来编写一个单元测试检测一下。</p><pre><code>package water\n\n\nimport (\n    &quot;math/rand&quot;\n    &quot;sort&quot;\n    &quot;sync&quot;\n    &quot;testing&quot;\n    &quot;time&quot;\n)\n\n\nfunc TestWaterFactory(t *testing.T) {\n    //用来存放水分子结果的channel\n    var ch chan string\n    releaseHydrogen := func() {\n        ch &lt;- &quot;H&quot;\n    }\n    releaseOxygen := func() {\n        ch &lt;- &quot;O&quot;\n    }\n\n    // 300个原子，300个goroutine,每个goroutine并发的产生一个原子\n    var N = 100\n    ch = make(chan string, N*3)\n\n\n    h2o := New()\n\n    // 用来等待所有的goroutine完成\n    var wg sync.WaitGroup\n    wg.Add(N * 3)\n   \n    // 200个氢原子goroutine\n    for i := 0; i &lt; 2*N; i++ {\n        go func() {\n            time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n            h2o.hydrogen(releaseHydrogen)\n            wg.Done()\n        }()\n    }\n    // 100个氧原子goroutine\n    for i := 0; i &lt; N; i++ {\n        go func() {\n            time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n            h2o.oxygen(releaseOxygen)\n            wg.Done()\n        }()\n    }\n    \n    //等待所有的goroutine执行完\n    wg.Wait()\n\n    // 结果中肯定是300个原子\n    if len(ch) != N*3 {\n        t.Fatalf(&quot;expect %d atom but got %d&quot;, N*3, len(ch))\n    }\n\n    // 每三个原子一组，分别进行检查。要求这一组原子中必须包含两个氢原子和一个氧原子，这样才能正确组成一个水分子。\n    var s = make([]string, 3)\n    for i := 0; i &lt; N; i++ {\n        s[0] = &lt;-ch\n        s[1] = &lt;-ch\n        s[2] = &lt;-ch\n        sort.Strings(s)\n\n\n        water := s[0] + s[1] + s[2]\n        if water != &quot;HHO&quot; {\n            t.Fatalf(&quot;expect a water molecule but got %s&quot;, water)\n        }\n    }\n}\n</code></pre><h1>总结</h1><p>每一个并发原语都有它存在的道理，也都有它应用的场景。</p><p>如果你没有学习CyclicBarrier，你可能只会想到，用WaitGroup来实现这个水分子制造工厂的例子。</p><pre><code>type H2O struct {\n    semaH *semaphore.Weighted\n    semaO *semaphore.Weighted\n    wg    sync.WaitGroup //将循环栅栏替换成WaitGroup\n}\n\nfunc New() *H2O {\n    var wg sync.WaitGroup\n    wg.Add(3)\n\n    return &amp;H2O{\n        semaH: semaphore.NewWeighted(2),\n        semaO: semaphore.NewWeighted(1),\n        wg:    wg,\n    }\n}\n\n\nfunc (h2o *H2O) hydrogen(releaseHydrogen func()) {\n    h2o.semaH.Acquire(context.Background(), 1)\n    releaseHydrogen()\n\n    // 标记自己已达到，等待其它goroutine到达\n    h2o.wg.Done()\n    h2o.wg.Wait()\n\n    h2o.semaH.Release(1)\n}\n\nfunc (h2o *H2O) oxygen(releaseOxygen func()) {\n    h2o.semaO.Acquire(context.Background(), 1)\n    releaseOxygen()\n\n    // 标记自己已达到，等待其它goroutine到达\n    h2o.wg.Done()\n    h2o.wg.Wait()\n    //都到达后重置wg \n    h2o.wg.Add(3)\n\n    h2o.semaO.Release(1)\n}\n</code></pre><p>你一看代码就知道了，使用WaitGroup非常复杂，而且，重用和Done方法的调用有并发的问题，程序可能panic，远远没有使用循环栅栏更加简单直接。</p><p>所以，我建议你多了解一些并发原语，甚至是从其它编程语言、操作系统中学习更多的并发原语，这样可以让你的知识库更加丰富，在面对并发场景的时候，你也能更加游刃有余。</p><p><img src=\"https://static001.geekbang.org/resource/image/82/4f/826f346ac0ccd687dc5d9bcc46621d4f.jpg?wh=2250*1233\" alt=\"\"></p><h1>思考题</h1><p>如果大自然的搬运工工厂生产的液体是双氧水（双氧水分子是两个氢原子和两个氧原子），你又该怎么实现呢？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","neighbors":{"left":{"article_title":"16 | Semaphore：一篇文章搞懂信号量","id":308399},"right":{"article_title":"18 | 分组操作：处理一组子任务，该用什么并发原语？","id":310443}},"comments":[{"had_liked":false,"id":262489,"user_name":"杜鑫","can_delete":false,"product_type":"c1","uid":1332244,"ip_address":"","ucode":"D7651198B2C487","user_header":"https://static001.geekbang.org/account/avatar/00/14/54/14/84d49453.jpg","comment_is_top":false,"comment_ctime":1605750029,"is_pvip":false,"replies":[{"id":"95273","content":"加油！","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605766025,"ip_address":"","comment_id":262489,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44555422989","product_id":100061801,"comment_content":"谢谢老师的文章！第一次知道有这两种并发原语，不管之后工作能不能用到，这都是对个人眼界的开阔！<br>ps:老师的文章几乎都是一篇顶两篇，刚订阅的时候还担心课程内容太少，现在一看担心完全是多余的，这段时间读了老师的文章之后，个人对go并发知识了解更深刻了，谢谢老师！","like_count":11,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509855,"discussion_content":"加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605766025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262216,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1605666697,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"27375470473","product_id":100061801,"comment_content":"SingleFlight 能不能合并并发的写操作呢？<br>我觉得得分情况讨论，如果多个写请求是对于同一个对象相同的写操作，比如把某条记录的一个字段设置为某一个值，这样的话可以合并。<br>如果写操作是对于对象增减操作，涉及幂等行操作不太合适合并。","like_count":7},{"had_liked":false,"id":263036,"user_name":"chapin","can_delete":false,"product_type":"c1","uid":1070020,"ip_address":"","ucode":"BB1800A771A8E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/c4/dea5d7f3.jpg","comment_is_top":false,"comment_ctime":1605955764,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14490857652","product_id":100061801,"comment_content":"这一节在实际项目中都直接用到。","like_count":4,"discussions":[{"author":{"id":1198953,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4b/69/c02eac91.jpg","nickname":"大漠胡萝卜","note":"","ucode":"FBE51E4A13EF4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328226,"discussion_content":"实际上面用的少吧，应该也有其他的方式来实现吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606109895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2178501,"avatar":"https://static001.geekbang.org/account/avatar/00/21/3d/c5/f43fa619.jpg","nickname":"🍀柠檬鱼也是鱼","note":"","ucode":"DCF033636465F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1198953,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4b/69/c02eac91.jpg","nickname":"大漠胡萝卜","note":"","ucode":"FBE51E4A13EF4F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336625,"discussion_content":"singleflight还是有用到，barrier不太清楚\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608636593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328226,"ip_address":""},"score":336625,"extra":""}]}]},{"had_liked":false,"id":270480,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1609143260,"is_pvip":false,"replies":[{"id":"98143","content":"https:&#47;&#47;github.com&#47;smallnest&#47;dive-to-gosync-workshop&#47;tree&#47;master&#47;7.orchestration&#47;water","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1609202068,"ip_address":"","comment_id":270480,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5904110556","product_id":100061801,"comment_content":"老师，在你github地址 https:&#47;&#47;github.com&#47;smallnest&#47;dive-to-gosync-workshop&#47;tree&#47;master&#47;7.orchestration&#47;water中没有搜到WaitGroup版本的H2O的例子，但是按照你正文中WaitGroup版本实现H2O，有报错panic: sync: WaitGroup is reused before previous Wait has returned<br>。请问老师这应该怎么解决呢？很困惑，望老师指点。","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512642,"discussion_content":"https://github.com/smallnest/dive-to-gosync-workshop/tree/master/7.orchestration/water","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609202068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338209,"discussion_content":"老师，你说的那个例子不是用WaitGroup实现的，而是用CyclicBarrier来实现。这个我能理解。\n摘自正文内容“你一看代码就知道了，使用 WaitGroup 非常复杂，而且，重用和 Done 方法的调用有并发的问题，程序可能 panic，远远没有使用循环栅栏更加简单直接。”这个的意思是说正文那个用WaitGroup实现的H2O版本，是有问题的，对吗？\n我这边测试的话，报错信息是这个panic: sync: WaitGroup is reused before previous Wait has returned。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609213386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270061,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1608888999,"is_pvip":false,"replies":[{"id":"97878","content":"报什么错？这些例子都是我运行过的，你也可以到github上搜我的一个项目叫workshop的代码","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1608900792,"ip_address":"","comment_id":270061,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5903856295","product_id":100061801,"comment_content":"老师，感觉你上面用waitGroup实现这个H2O的例子有问题的。我这边运行都panic的。","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512503,"discussion_content":"报什么错？这些例子都是我运行过的，你也可以到github上搜我的一个项目叫workshop的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608900792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337435,"discussion_content":"``` go\n//water.go\ntype H2O struct {\n    semaH *semaphore.Weighted\n    semaO *semaphore.Weighted\n    wg    sync.WaitGroup //将循环栅栏替换成WaitGroup\n}\n\nfunc New() *H2O {\n    var wg sync.WaitGroup\n    wg.Add(3)\n\n    return &amp;H2O{\n        semaH: semaphore.NewWeighted(2),\n        semaO: semaphore.NewWeighted(1),\n        wg:    wg,\n    }\n}\n\n\nfunc (h2o *H2O) hydrogen(releaseHydrogen func()) {\n    h2o.semaH.Acquire(context.Background(), 1)\n    releaseHydrogen()\n\n    // 标记自己已达到，等待其它goroutine到达\n    h2o.wg.Done()\n    h2o.wg.Wait()\n\n    h2o.semaH.Release(1)\n}\n\nfunc (h2o *H2O) oxygen(releaseOxygen func()) {\n    h2o.semaO.Acquire(context.Background(), 1)\n    releaseOxygen()\n\n    // 标记自己已达到，等待其它goroutine到达\n    h2o.wg.Done()\n    h2o.wg.Wait()\n    //都到达后重置wg \n    h2o.wg.Add(3)\n\n    h2o.semaO.Release(1)\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608905337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337434,"discussion_content":"参考这个链接的https://github.com/smallnest/dive-to-gosync-workshop/tree/master/7.orchestration/water","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608905251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337433,"discussion_content":"老师，就是你这个链接中的代码。不过water.go这个替换成你用WaitGroup 来实现那个。\n报错信息\n\nRunning tool: /usr/local/go/bin/go test -timeout 30s -run ^TestWaterFactory$ gin-demo/water -v\n\n=== RUN   TestWaterFactory\npanic: sync: WaitGroup is reused before previous Wait has returned\n\ngoroutine 8 [running]:\nsync.(*WaitGroup).Wait(0xc00000c0f0)\n\t/usr/local/go/src/sync/waitgroup.go:132 +0xad\ndemo/water.(*H2O).hydrogen(0xc00000c0e0, 0xc00004c510)\n\t/Users/xxx/demo/water/water.go:33 +0x8b\ndemo/water.TestWaterFactory.func5(0x64, 0xc00000c0e0, 0xc00004c510, 0xc0000162c0)\n\t/Users/xxx/demo/water/water_test.go:45 +0x70\ncreated by demo/water.TestWaterFactory\n\t/Users/xxx/demo/water/water_test.go:42 +0x1fa\nFAIL demo/water\t0.507s","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608905203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263374,"user_name":"伟伟","can_delete":false,"product_type":"c1","uid":1060937,"ip_address":"","ucode":"F0B393FC6E1098","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/49/f9e37ced.jpg","comment_is_top":false,"comment_ctime":1606119185,"is_pvip":true,"replies":[{"id":"95571","content":"������������","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1606133129,"ip_address":"","comment_id":263374,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5901086481","product_id":100061801,"comment_content":"package main<br><br>import (<br>\t&quot;context&quot;<br><br>\t&quot;github.com&#47;marusama&#47;cyclicbarrier&quot;<br>\t&quot;golang.org&#47;x&#47;sync&#47;semaphore&quot;<br>)<br><br>type H2O2 struct {<br>\tsemaH *semaphore.Weighted<br>\tsemaO *semaphore.Weighted<br>\tb     cyclicbarrier.CyclicBarrier<br>}<br><br>func New() *H2O2 {<br>\treturn &amp;H2O2{<br>\t\tsemaH: semaphore.NewWeighted(2),<br>\t\tsemaO: semaphore.NewWeighted(2),<br>\t\tb:     cyclicbarrier.New(4),<br>\t}<br>}<br><br>func (h2o2 *H2O2) hydrogen(releaseHydrogen func()) {<br>\th2o2.semaH.Acquire(context.Background(), 1)<br>\treleaseHydrogen()<br>\th2o2.b.Await(context.Background())<br>\th2o2.semaH.Release(1)<br>}<br><br>func (h2o2 *H2O2) oxygen(releaseOxygen func()) {<br>\th2o2.semaO.Acquire(context.Background(), 1)<br>\treleaseOxygen()<br>\th2o2.b.Await(context.Background())<br>\th2o2.semaO.Release(1)<br>}","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510165,"discussion_content":"������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606133129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262570,"user_name":"虫子樱桃","can_delete":false,"product_type":"c1","uid":1226331,"ip_address":"","ucode":"F8244A9E9BC5A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/b6/5b/4486e4f9.jpg","comment_is_top":false,"comment_ctime":1605771399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5900738695","product_id":100061801,"comment_content":"写了singleFlight的例子辅助思考。<br>package main<br><br>import (<br>\t&quot;log&quot;<br>\t&quot;sync&quot;<br>\t&quot;sync&#47;atomic&quot;<br>\t&quot;time&quot;<br><br>\t&quot;golang.org&#47;x&#47;sync&#47;singleflight&quot;<br>)<br><br>var (<br>\tsf           = singleflight.Group{}<br>\trequestCount = int64(0)<br>\tresp         = make(chan int64, 0)<br>\twg           sync.WaitGroup<br>)<br><br>func main() {<br>\tfor i := 0; i &lt; 100; i++ {<br>\t\twg.Add(1)<br>\t\tgo func() {<br>\t\t\tdo, err, _ := sf.Do(&quot;number&quot;, Request)<br>\t\t\tif err != nil {<br>\t\t\t\tlog.Println(err)<br>\t\t\t}<br>\t\t\tlog.Println(&quot;resp&quot;, do)<br>\t\t\tdefer wg.Done()<br>\t\t}()<br>\t}<br>\ttime.Sleep(time.Second)<br>\tresp &lt;- atomic.LoadInt64(&amp;requestCount)<br>\twg.Wait()<br><br>}<br><br>func Request() (interface{}, error) {<br>\tatomic.AddInt64(&amp;requestCount, 1)<br>\treturn &lt;-resp, nil<br>}","like_count":1},{"had_liked":false,"id":338650,"user_name":"无名氏","can_delete":false,"product_type":"c1","uid":1256121,"ip_address":"","ucode":"584E697AE276AB","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/b9/2bf8cc89.jpg","comment_is_top":false,"comment_ctime":1647621457,"is_pvip":false,"replies":[{"id":"123863","content":"hho,hoh,ohh，都可以，只有保证是一个水分子","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1647823971,"ip_address":"","comment_id":338650,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1647621457","product_id":100061801,"comment_content":"CyclicBarrier 那个测试例子没有看懂，2个H，一个O顺序怎么保证是HHO😅","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557440,"discussion_content":"hho,hoh,ohh，都可以，只有保证是一个水分子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647823971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1589872,"avatar":"https://static001.geekbang.org/account/avatar/00/18/42/70/c69f9b9d.jpg","nickname":"pisces","note":"","ucode":"7189215B51D120","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559961,"discussion_content":"只能保证数量是2个H和1个O，老师做了排序，所以一定输出HHO","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649082005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336889,"user_name":"Lukia","can_delete":false,"product_type":"c1","uid":1028698,"ip_address":"","ucode":"C19472337BCCC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b2/5a/574f5bb0.jpg","comment_is_top":false,"comment_ctime":1646450031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646450031","product_id":100061801,"comment_content":"“forgotten==false，所以第 8 行默认会被调用，也就是说，第一个请求完成后，后续的同一个 key 的请求又重新开始新一次的 fn 函数的调用。”这一段逻辑可以理解 ，但是forgotten的变量命名很奇怪（感觉是名字取反了？），false的时候去删除map里的key，这个和常识相悖？","like_count":0},{"had_liked":false,"id":323750,"user_name":"Geek8956","can_delete":false,"product_type":"c1","uid":2689403,"ip_address":"","ucode":"BF7EF77F174B79","user_header":"","comment_is_top":false,"comment_ctime":1638150521,"is_pvip":false,"replies":[{"id":"118054","content":"循环栅栏的重点是循环，重用","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1638928502,"ip_address":"","comment_id":323750,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638150521","product_id":100061801,"comment_content":"老师，请问循环栏栅和cond并发原语有什么区别？他们都可以让多个协程等待某个条件满足，然后并发的开始执行。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536984,"discussion_content":"循环栅栏的重点是循环，重用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638928502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318261,"user_name":"gitxuzan","can_delete":false,"product_type":"c1","uid":1081566,"ip_address":"","ucode":"B0E20F892DA716","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/de/c6191045.jpg","comment_is_top":false,"comment_ctime":1635218649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635218649","product_id":100061801,"comment_content":"package main<br><br>import (<br>\t&quot;golang.org&#47;x&#47;sync&#47;singleflight&quot;<br>\t&quot;log&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tvar singleSetCache singleflight.Group<br><br>\tgetAndSetCache := func(requestID int, cacheKey string) (string, error) {<br>\t\tvalue, _, _ := singleSetCache.Do(cacheKey, func() (ret interface{}, err error) { &#47;&#47;do的入参key，可以直接使用缓存的key，这样同一个缓存，只有一个协程会去读DB<br>\t\t\tlog.Printf(&quot;requestid执行一次 %v &quot;, requestID)<br>\t\t\treturn &quot;VALUE&quot;, nil<br>\t\t})<br>\t\treturn value.(string), nil<br>\t}<br><br>\tcacheKey := &quot;cacheKey&quot;<br>\tfor i := 1; i &lt; 10; i++ { &#47;&#47;模拟多个协程同时请求<br>\t\tgo func(requestID int) {<br>\t\t\tvalue, _ := getAndSetCache(requestID, cacheKey)<br>\t\t\t&#47;&#47;_ = value<br>\t\t\tlog.Printf(&quot;requestID %v get 值: %v&quot;, requestID, value)<br>\t\t}(i)<br>\t}<br>\ttime.Sleep(20 * time.Second)<br>}","like_count":0},{"had_liked":false,"id":297251,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1623394456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623394456","product_id":100061801,"comment_content":"学到了     SingleFight  合并      <br>","like_count":1},{"had_liked":false,"id":290665,"user_name":"TT","can_delete":false,"product_type":"c1","uid":1466771,"ip_address":"","ucode":"2D8CE3E45DA7A4","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/93/3191eafa.jpg","comment_is_top":false,"comment_ctime":1619681033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619681033","product_id":100061801,"comment_content":"秒啊！赶紧自己写篇文章再总结一下，老师应该不介意我抄点作业吧哈哈哈，我会注明出处的","like_count":0},{"had_liked":false,"id":276332,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1611887738,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1611887738","product_id":100061801,"comment_content":"SingleFlight 这段话 “你要注意下第 7 行。在默认情况下，forgotten==false，所以第 8 行默认会被调用，也就是说，第一个请求完成后，后续的同一个 key 的请求又重新开始新一次的 fn 函数的调用”；感觉跟开头说的 SingleFlight 并发只执行一次相矛盾；<br>仔细理解源码原来是这样：比如 有100个并发k都是xxx；在SingleFlight内部doCall时，开始有20个并发了，那么会执行一次，完了会删除k（xxx）；后面又有60次并发了，会在执行一次然后删除；后面又有20次并发了就会又执行一次后删除。<br>","like_count":0,"discussions":[{"author":{"id":1392924,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rRCSdTPyqWcW6U8DO9xL55ictNPlbQ38VAcaBNgibqaAhcH7mn1W9ddxIJLlMiaA5sngBicMX02w2HP5pAWpBAJsag/132","nickname":"butterfly","note":"","ucode":"1B724973303FB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351264,"discussion_content":"结合redis缓存使用的话，第一次20次并发的时候，应该将数据设置在redis中， 第二次60次并发的时候，应该先从redis中读，读不到的时候，再用 SingleFlight访问数据库","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614219886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270479,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1609143244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609143244","product_id":100061801,"comment_content":"老师，在你github地址 https:&#47;&#47;github.com&#47;smallnest&#47;dive-to-gosync-workshop&#47;tree&#47;master&#47;7.orchestration&#47;water中没有搜到WaitGroup版本的H2O的例子，但是按照你正文中WaitGroup版本实现H2O，有报错panic: sync: WaitGroup is reused before previous Wait has returned<br>。请问老师这应该怎么解决呢？很困惑，望老师指点。","like_count":0},{"had_liked":false,"id":266614,"user_name":"老纪","can_delete":false,"product_type":"c1","uid":1227735,"ip_address":"","ucode":"BECF11D225D260","user_header":"https://static001.geekbang.org/account/avatar/00/12/bb/d7/91da132b.jpg","comment_is_top":false,"comment_ctime":1607415938,"is_pvip":false,"replies":[{"id":"96812","content":"是的","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1607421159,"ip_address":"","comment_id":266614,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607415938","product_id":100061801,"comment_content":"在CyclicBarrier中，是需要一组goroutine都执行到Await()方法后，才会都向下执行否则就会阻塞在Await()方法上吗","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511330,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607421159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262900,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1605875474,"is_pvip":false,"replies":[{"id":"95375","content":"多实践，在项目中锻炼，很快就顺手了","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605888315,"ip_address":"","comment_id":262900,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605875474","product_id":100061801,"comment_content":"感觉自已Go刚刚入门，我确实也才学习一周左右，看着挺爽，写起来还是不顺手，还得多练习，老师能否给我们这些打算转Go的新手一些建议，谢谢","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510024,"discussion_content":"多实践，在项目中锻炼，很快就顺手了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605888315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262303,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1605688467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605688467","product_id":100061801,"comment_content":"打卡。","like_count":0}]}