{"id":306614,"title":"14 | Channel：透过代码看典型的应用模式","content":"<p>你好，我是鸟窝。</p><p>前一讲，我介绍了Channel的基础知识，并且总结了几种应用场景。这一讲，我将通过实例的方式，带你逐个学习Channel解决这些问题的方法，帮你巩固和完全掌握它的用法。</p><p>在开始上课之前，我先补充一个知识点：通过反射的方式执行select语句，在处理很多的case clause，尤其是不定长的case clause的时候，非常有用。而且，在后面介绍任务编排的实现时，我也会采用这种方法，所以，我先带你具体学习下Channel的反射用法。</p><h1>使用反射操作Channel</h1><p>select语句可以处理chan的send和recv，send和recv都可以作为case clause。如果我们同时处理两个chan，就可以写成下面的样子：</p><pre><code>    select {\n    case v := &lt;-ch1:\n        fmt.Println(v)\n    case v := &lt;-ch2:\n        fmt.Println(v)\n    }\n</code></pre><p>如果需要处理三个chan，你就可以再添加一个case clause，用它来处理第三个chan。可是，如果要处理100个chan呢？一万个chan呢？</p><p>或者是，chan的数量在编译的时候是不定的，在运行的时候需要处理一个slice of chan，这个时候，也没有办法在编译前写成字面意义的select。那该怎么办？</p><p>这个时候，就要“祭”出我们的反射大法了。</p><p>通过reflect.Select函数，你可以将一组运行时的case clause传入，当作参数执行。Go的select是伪随机的，它可以在执行的case中随机选择一个case，并把选择的这个case的索引（chosen）返回，如果没有可用的case返回，会返回一个bool类型的返回值，这个返回值用来表示是否有case成功被选择。如果是recv case，还会返回接收的元素。Select的方法签名如下：</p><!-- [[[read_end]]] --><pre><code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)\n</code></pre><p>下面，我来借助一个例子，来演示一下，动态处理两个chan的情形。因为这样的方式可以动态处理case数据，所以，你可以传入几百几千几万的chan，这就解决了不能动态处理n个chan的问题。</p><p>首先，createCases函数分别为每个chan生成了recv case和send case，并返回一个reflect.SelectCase数组。</p><p>然后，通过一个循环10次的for循环执行reflect.Select，这个方法会从cases中选择一个case执行。第一次肯定是send case，因为此时chan还没有元素，recv还不可用。等chan中有了数据以后，recv case就可以被选择了。这样，你就可以处理不定数量的chan了。</p><pre><code>func main() {\n    var ch1 = make(chan int, 10)\n    var ch2 = make(chan int, 10)\n\n    // 创建SelectCase\n    var cases = createCases(ch1, ch2)\n\n    // 执行10次select\n    for i := 0; i &lt; 10; i++ {\n        chosen, recv, ok := reflect.Select(cases)\n        if recv.IsValid() { // recv case\n            fmt.Println(&quot;recv:&quot;, cases[chosen].Dir, recv, ok)\n        } else { // send case\n            fmt.Println(&quot;send:&quot;, cases[chosen].Dir, ok)\n        }\n    }\n}\n\nfunc createCases(chs ...chan int) []reflect.SelectCase {\n    var cases []reflect.SelectCase\n\n\n    // 创建recv case\n    for _, ch := range chs {\n        cases = append(cases, reflect.SelectCase{\n            Dir:  reflect.SelectRecv,\n            Chan: reflect.ValueOf(ch),\n        })\n    }\n\n    // 创建send case\n    for i, ch := range chs {\n        v := reflect.ValueOf(i)\n        cases = append(cases, reflect.SelectCase{\n            Dir:  reflect.SelectSend,\n            Chan: reflect.ValueOf(ch),\n            Send: v,\n        })\n    }\n\n    return cases\n}\n</code></pre><h1>典型的应用场景</h1><p>了解刚刚的反射用法，我们就解决了今天的基础知识问题，接下来，我就带你具体学习下Channel的应用场景。</p><p>首先来看消息交流。</p><h2>消息交流</h2><p>从chan的内部实现看，它是以一个循环队列的方式存放数据，所以，它有时候也会被当成线程安全的队列和buffer使用。一个goroutine可以安全地往Channel中塞数据，另外一个goroutine可以安全地从Channel中读取数据，goroutine就可以安全地实现信息交流了。</p><p>我们来看几个例子。</p><p>第一个例子是worker池的例子。Marcio Castilho 在 <a href=\"http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/\">使用Go每分钟处理百万请求</a>  这篇文章中，就介绍了他们应对大并发请求的设计。他们将用户的请求放在一个 chan Job 中，这个chan Job就相当于一个待处理任务队列。除此之外，还有一个chan chan Job队列，用来存放可以处理任务的worker的缓存队列。</p><p>dispatcher会把待处理任务队列中的任务放到一个可用的缓存队列中，worker会一直处理它的缓存队列。通过使用Channel，实现了一个worker池的任务处理中心，并且解耦了前端HTTP请求处理和后端任务处理的逻辑。</p><p>我在讲Pool的时候，提到了一些第三方实现的worker池，它们全部都是通过Channel实现的，这是Channel的一个常见的应用场景。worker池的生产者和消费者的消息交流都是通过Channel实现的。</p><p>第二个例子是etcd中的node节点的实现，包含大量的chan字段，比如recvc是消息处理的chan，待处理的protobuf消息都扔到这个chan中，node有一个专门的run goroutine负责处理这些消息。</p><p><img src=\"https://static001.geekbang.org/resource/image/06/a4/0643503a1yy135b476d41345d71766a4.png?wh=573*413\" alt=\"\"></p><h2>数据传递</h2><p>“击鼓传花”的游戏很多人都玩过，花从一个人手中传给另外一个人，就有点类似流水线的操作。这个花就是数据，花在游戏者之间流转，这就类似编程中的数据传递。</p><p>还记得上节课我给你留了一道任务编排的题吗？其实它就可以用数据传递的方式实现。</p><blockquote>\n<p>有4个goroutine，编号为1、2、3、4。每秒钟会有一个goroutine打印出它自己的编号，要求你编写程序，让输出的编号总是按照1、2、3、4、1、2、3、4……这个顺序打印出来。</p>\n</blockquote><p>为了实现顺序的数据传递，我们可以定义一个令牌的变量，谁得到令牌，谁就可以打印一次自己的编号，同时将令牌<strong>传递</strong>给下一个goroutine，我们尝试使用chan来实现，可以看下下面的代码。</p><pre><code>type Token struct{}\n\nfunc newWorker(id int, ch chan Token, nextCh chan Token) {\n    for {\n        token := &lt;-ch         // 取得令牌\n        fmt.Println((id + 1)) // id从1开始\n        time.Sleep(time.Second)\n        nextCh &lt;- token\n    }\n}\nfunc main() {\n    chs := []chan Token{make(chan Token), make(chan Token), make(chan Token), make(chan Token)}\n\n    // 创建4个worker\n    for i := 0; i &lt; 4; i++ {\n        go newWorker(i, chs[i], chs[(i+1)%4])\n    }\n\n    //首先把令牌交给第一个worker\n    chs[0] &lt;- struct{}{}\n  \n    select {}\n}\n</code></pre><p>我来给你具体解释下这个实现方式。</p><p>首先，我们定义一个令牌类型（Token），接着定义一个创建worker的方法，这个方法会从它自己的chan中读取令牌。哪个goroutine取得了令牌，就可以打印出自己编号，因为需要每秒打印一次数据，所以，我们让它休眠1秒后，再把令牌交给它的下家。</p><p>接着，在第16行启动每个worker的goroutine，并在第20行将令牌先交给第一个worker。</p><p>如果你运行这个程序，就会在命令行中看到每一秒就会输出一个编号，而且编号是以1、2、3、4这样的顺序输出的。</p><p>这类场景有一个特点，就是当前持有数据的goroutine都有一个信箱，信箱使用chan实现，goroutine只需要关注自己的信箱中的数据，处理完毕后，就把结果发送到下一家的信箱中。</p><h2>信号通知</h2><p>chan类型有这样一个特点：chan如果为空，那么，receiver接收数据的时候就会阻塞等待，直到chan被关闭或者有新的数据到来。利用这个机制，我们可以实现wait/notify的设计模式。</p><p>传统的并发原语Cond也能实现这个功能。但是，Cond使用起来比较复杂，容易出错，而使用chan实现wait/notify模式，就方便多了。</p><p>除了正常的业务处理时的wait/notify，我们经常碰到的一个场景，就是程序关闭的时候，我们需要在退出之前做一些清理（doCleanup方法）的动作。这个时候，我们经常要使用chan。</p><p>比如，使用chan实现程序的graceful shutdown，在退出之前执行一些连接关闭、文件close、缓存落盘等一些动作。</p><pre><code>func main() {\n\tgo func() {\n      ...... // 执行业务处理\n    }()\n\n\t// 处理CTRL+C等中断信号\n\ttermChan := make(chan os.Signal)\n\tsignal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)\n\t&lt;-termChan \n\n\t// 执行退出之前的清理动作\n    doCleanup()\n\t\n\tfmt.Println(&quot;优雅退出&quot;)\n}\n</code></pre><p>有时候，doCleanup可能是一个很耗时的操作，比如十几分钟才能完成，如果程序退出需要等待这么长时间，用户是不能接受的，所以，在实践中，我们需要设置一个最长的等待时间。只要超过了这个时间，程序就不再等待，可以直接退出。所以，退出的时候分为两个阶段：</p><ol>\n<li>closing，代表程序退出，但是清理工作还没做；</li>\n<li>closed，代表清理工作已经做完。</li>\n</ol><p>所以，上面的例子可以改写如下：</p><pre><code>func main() {\n    var closing = make(chan struct{})\n    var closed = make(chan struct{})\n\n    go func() {\n        // 模拟业务处理\n        for {\n            select {\n            case &lt;-closing:\n                return\n            default:\n                // ....... 业务计算\n                time.Sleep(100 * time.Millisecond)\n            }\n        }\n    }()\n\n    // 处理CTRL+C等中断信号\n    termChan := make(chan os.Signal)\n    signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)\n    &lt;-termChan\n\n    close(closing)\n    // 执行退出之前的清理动作\n    go doCleanup(closed)\n\n    select {\n    case &lt;-closed:\n    case &lt;-time.After(time.Second):\n        fmt.Println(&quot;清理超时，不等了&quot;)\n    }\n    fmt.Println(&quot;优雅退出&quot;)\n}\n\nfunc doCleanup(closed chan struct{}) {\n    time.Sleep((time.Minute))\n    close(closed)\n}\n</code></pre><h2>锁</h2><p>使用chan也可以实现互斥锁。</p><p>在chan的内部实现中，就有一把互斥锁保护着它的所有字段。从外在表现上，chan的发送和接收之间也存在着happens-before的关系，保证元素放进去之后，receiver才能读取到（关于happends-before的关系，是指事件发生的先后顺序关系，我会在下一讲详细介绍，这里你只需要知道它是一种描述事件先后顺序的方法）。</p><p>要想使用chan实现互斥锁，至少有两种方式。一种方式是先初始化一个capacity等于1的Channel，然后再放入一个元素。这个元素就代表锁，谁取得了这个元素，就相当于获取了这把锁。另一种方式是，先初始化一个capacity等于1的Channel，它的“空槽”代表锁，谁能成功地把元素发送到这个Channel，谁就获取了这把锁。</p><p>这是使用Channel实现锁的两种不同实现方式，我重点介绍下第一种。理解了这种实现方式，第二种方式也就很容易掌握了，我就不多说了。</p><pre><code>// 使用chan实现互斥锁\ntype Mutex struct {\n    ch chan struct{}\n}\n\n// 使用锁需要初始化\nfunc NewMutex() *Mutex {\n    mu := &amp;Mutex{make(chan struct{}, 1)}\n    mu.ch &lt;- struct{}{}\n    return mu\n}\n\n// 请求锁，直到获取到\nfunc (m *Mutex) Lock() {\n    &lt;-m.ch\n}\n\n// 解锁\nfunc (m *Mutex) Unlock() {\n    select {\n    case m.ch &lt;- struct{}{}:\n    default:\n        panic(&quot;unlock of unlocked mutex&quot;)\n    }\n}\n\n// 尝试获取锁\nfunc (m *Mutex) TryLock() bool {\n    select {\n    case &lt;-m.ch:\n        return true\n    default:\n    }\n    return false\n}\n\n// 加入一个超时的设置\nfunc (m *Mutex) LockTimeout(timeout time.Duration) bool {\n    timer := time.NewTimer(timeout)\n    select {\n    case &lt;-m.ch:\n        timer.Stop()\n        return true\n    case &lt;-timer.C:\n    }\n    return false\n}\n\n// 锁是否已被持有\nfunc (m *Mutex) IsLocked() bool {\n    return len(m.ch) == 0\n}\n\n\nfunc main() {\n    m := NewMutex()\n    ok := m.TryLock()\n    fmt.Printf(&quot;locked v %v\\n&quot;, ok)\n    ok = m.TryLock()\n    fmt.Printf(&quot;locked %v\\n&quot;, ok)\n}\n</code></pre><p>你可以用buffer等于1的chan实现互斥锁，在初始化这个锁的时候往Channel中先塞入一个元素，谁把这个元素取走，谁就获取了这把锁，把元素放回去，就是释放了锁。元素在放回到chan之前，不会有goroutine能从chan中取出元素的，这就保证了互斥性。</p><p>在这段代码中，还有一点需要我们注意下：利用select+chan的方式，很容易实现TryLock、Timeout的功能。具体来说就是，在select语句中，我们可以使用default实现TryLock，使用一个Timer来实现Timeout的功能。</p><h2>任务编排</h2><p>前面所说的消息交流的场景是一个特殊的任务编排的场景，这个“击鼓传花”的模式也被称为流水线模式。</p><p>在<a href=\"https://time.geekbang.org/column/article/298516\">第6讲</a>，我们学习了WaitGroup，我们可以利用它实现等待模式：启动一组goroutine执行任务，然后等待这些任务都完成。其实，我们也可以使用chan实现WaitGroup的功能。这个比较简单，我就不举例子了，接下来我介绍几种更复杂的编排模式。</p><p>这里的编排既指安排goroutine按照指定的顺序执行，也指多个chan按照指定的方式组合处理的方式。goroutine的编排类似“击鼓传花”的例子，我们通过编排数据在chan之间的流转，就可以控制goroutine的执行。接下来，我来重点介绍下多个chan的编排方式，总共5种，分别是Or-Done模式、扇入模式、扇出模式、Stream和map-reduce。</p><h3>Or-Done模式</h3><p>首先来看Or-Done模式。Or-Done模式是信号通知模式中更宽泛的一种模式。这里提到了“信号通知模式”，我先来解释一下。</p><p>我们会使用“信号通知”实现某个任务执行完成后的通知机制，在实现时，我们为这个任务定义一个类型为chan struct{}类型的done变量，等任务结束后，我们就可以close这个变量，然后，其它receiver就会收到这个通知。</p><p>这是有一个任务的情况，如果有多个任务，只要有任意一个任务执行完，我们就想获得这个信号，这就是Or-Done模式。</p><p>比如，你发送同一个请求到多个微服务节点，只要任意一个微服务节点返回结果，就算成功，这个时候，就可以参考下面的实现：</p><pre><code>func or(channels ...&lt;-chan interface{}) &lt;-chan interface{} {\n    // 特殊情况，只有零个或者1个chan\n    switch len(channels) {\n    case 0:\n        return nil\n    case 1:\n        return channels[0]\n    }\n\n    orDone := make(chan interface{})\n    go func() {\n        defer close(orDone)\n\n        switch len(channels) {\n        case 2: // 2个也是一种特殊情况\n            select {\n            case &lt;-channels[0]:\n            case &lt;-channels[1]:\n            }\n        default: //超过两个，二分法递归处理\n            m := len(channels) / 2\n            select {\n            case &lt;-or(channels[:m]...):\n            case &lt;-or(channels[m:]...):\n            }\n        }\n    }()\n\n    return orDone\n}\n</code></pre><p>我们可以写一个测试程序测试它：</p><pre><code>func sig(after time.Duration) &lt;-chan interface{} {\n    c := make(chan interface{})\n    go func() {\n        defer close(c)\n        time.Sleep(after)\n    }()\n    return c\n}\n\n\nfunc main() {\n    start := time.Now()\n\n    &lt;-or(\n        sig(10*time.Second),\n        sig(20*time.Second),\n        sig(30*time.Second),\n        sig(40*time.Second),\n        sig(50*time.Second),\n        sig(01*time.Minute),\n    )\n\n    fmt.Printf(&quot;done after %v&quot;, time.Since(start))\n}\n</code></pre><p>这里的实现使用了一个巧妙的方式，<strong>当chan的数量大于2时，使用递归的方式等待信号</strong>。</p><p>在chan数量比较多的情况下，递归并不是一个很好的解决方式，根据这一讲最开始介绍的反射的方法，我们也可以实现Or-Done模式：</p><pre><code>func or(channels ...&lt;-chan interface{}) &lt;-chan interface{} {\n    //特殊情况，只有0个或者1个\n    switch len(channels) {\n    case 0:\n        return nil\n    case 1:\n        return channels[0]\n    }\n\n    orDone := make(chan interface{})\n    go func() {\n        defer close(orDone)\n        // 利用反射构建SelectCase\n        var cases []reflect.SelectCase\n        for _, c := range channels {\n            cases = append(cases, reflect.SelectCase{\n                Dir:  reflect.SelectRecv,\n                Chan: reflect.ValueOf(c),\n            })\n        }\n\n        // 随机选择一个可用的case\n        reflect.Select(cases)\n    }()\n\n\n    return orDone\n}\n</code></pre><p>这是递归和反射两种方法实现Or-Done模式的代码。反射方式避免了深层递归的情况，可以处理有大量chan的情况。其实最笨的一种方法就是为每一个Channel启动一个goroutine，不过这会启动非常多的goroutine，太多的goroutine会影响性能，所以不太常用。你只要知道这种用法就行了，不用重点掌握。</p><h3>扇入模式</h3><p>扇入借鉴了数字电路的概念，它定义了单个逻辑门能够接受的数字信号输入最大量的术语。一个逻辑门可以有多个输入，一个输出。</p><p>在软件工程中，模块的扇入是指有多少个上级模块调用它。而对于我们这里的Channel扇入模式来说，就是指有多个源Channel输入、一个目的Channel输出的情况。扇入比就是源Channel数量比1。</p><p>每个源Channel的元素都会发送给目标Channel，相当于目标Channel的receiver只需要监听目标Channel，就可以接收所有发送给源Channel的数据。</p><p>扇入模式也可以使用反射、递归，或者是用最笨的每个goroutine处理一个Channel的方式来实现。</p><p>这里我列举下递归和反射的方式，帮你加深一下对这个技巧的理解。</p><p>反射的代码比较简短，易于理解，主要就是构造出SelectCase slice，然后传递给reflect.Select语句。</p><pre><code>func fanInReflect(chans ...&lt;-chan interface{}) &lt;-chan interface{} {\n    out := make(chan interface{})\n    go func() {\n        defer close(out)\n        // 构造SelectCase slice\n        var cases []reflect.SelectCase\n        for _, c := range chans {\n            cases = append(cases, reflect.SelectCase{\n                Dir:  reflect.SelectRecv,\n                Chan: reflect.ValueOf(c),\n            })\n        }\n        \n        // 循环，从cases中选择一个可用的\n        for len(cases) &gt; 0 {\n            i, v, ok := reflect.Select(cases)\n            if !ok { // 此channel已经close\n                cases = append(cases[:i], cases[i+1:]...)\n                continue\n            }\n            out &lt;- v.Interface()\n        }\n    }()\n    return out\n}\n</code></pre><p>递归模式也是在Channel大于2时，采用二分法递归merge。</p><pre><code>func fanInRec(chans ...&lt;-chan interface{}) &lt;-chan interface{} {\n    switch len(chans) {\n    case 0:\n        c := make(chan interface{})\n        close(c)\n        return c\n    case 1:\n        return chans[0]\n    case 2:\n        return mergeTwo(chans[0], chans[1])\n    default:\n        m := len(chans) / 2\n        return mergeTwo(\n            fanInRec(chans[:m]...),\n            fanInRec(chans[m:]...))\n    }\n}\n</code></pre><p>这里有一个mergeTwo的方法，是将两个Channel合并成一个Channel，是扇入形式的一种特例（只处理两个Channel）。 下面我来借助一段代码帮你理解下这个方法。</p><pre><code>func mergeTwo(a, b &lt;-chan interface{}) &lt;-chan interface{} {\n    c := make(chan interface{})\n    go func() {\n        defer close(c)\n        for a != nil || b != nil { //只要还有可读的chan\n            select {\n            case v, ok := &lt;-a:\n                if !ok { // a 已关闭，设置为nil\n                    a = nil\n                    continue\n                }\n                c &lt;- v\n            case v, ok := &lt;-b:\n                if !ok { // b 已关闭，设置为nil\n                    b = nil\n                    continue\n                }\n                c &lt;- v\n            }\n        }\n    }()\n    return c\n}\n</code></pre><h3>扇出模式</h3><p>有扇入模式，就有扇出模式，扇出模式是和扇入模式相反的。</p><p>扇出模式只有一个输入源Channel，有多个目标Channel，扇出比就是1比目标Channel数的值，经常用在设计模式中的<a href=\"https://baike.baidu.com/item/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/5881786?fr=aladdin\">观察者模式</a>中（观察者设计模式定义了对象间的一种一对多的组合关系。这样一来，一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动刷新）。在观察者模式中，数据变动后，多个观察者都会收到这个变更信号。</p><p>下面是一个扇出模式的实现。从源Channel取出一个数据后，依次发送给目标Channel。在发送给目标Channel的时候，可以同步发送，也可以异步发送：</p><pre><code>func fanOut(ch &lt;-chan interface{}, out []chan interface{}, async bool) {\n    go func() {\n        defer func() { //退出时关闭所有的输出chan\n            for i := 0; i &lt; len(out); i++ {\n                close(out[i])\n            }\n        }()\n\n        for v := range ch { // 从输入chan中读取数据\n            v := v\n            for i := 0; i &lt; len(out); i++ {\n                i := i\n                if async { //异步\n                    go func() {\n                        out[i] &lt;- v // 放入到输出chan中,异步方式\n                    }()\n                } else {\n                    out[i] &lt;- v // 放入到输出chan中，同步方式\n                }\n            }\n        }\n    }()\n}\n</code></pre><p>你也可以尝试使用反射的方式来实现，我就不列相关代码了，希望你课后可以自己思考下。</p><h3>Stream</h3><p>这里我来介绍一种把Channel当作流式管道使用的方式，也就是把Channel看作流（Stream），提供跳过几个元素，或者是只取其中的几个元素等方法。</p><p>首先，我们提供创建流的方法。这个方法把一个数据slice转换成流：</p><pre><code>func asStream(done &lt;-chan struct{}, values ...interface{}) &lt;-chan interface{} {\n    s := make(chan interface{}) //创建一个unbuffered的channel\n    go func() { // 启动一个goroutine，往s中塞数据\n        defer close(s) // 退出时关闭chan\n        for _, v := range values { // 遍历数组\n            select {\n            case &lt;-done:\n                return\n            case s &lt;- v: // 将数组元素塞入到chan中\n            }\n        }\n    }()\n    return s\n}\n</code></pre><p>流创建好以后，该咋处理呢？下面我再给你介绍下实现流的方法。</p><ol>\n<li>takeN：只取流中的前n个数据；</li>\n<li>takeFn：筛选流中的数据，只保留满足条件的数据；</li>\n<li>takeWhile：只取前面满足条件的数据，一旦不满足条件，就不再取；</li>\n<li>skipN：跳过流中前几个数据；</li>\n<li>skipFn：跳过满足条件的数据；</li>\n<li>skipWhile：跳过前面满足条件的数据，一旦不满足条件，当前这个元素和以后的元素都会输出给Channel的receiver。</li>\n</ol><p>这些方法的实现很类似，我们以takeN为例来具体解释一下。</p><pre><code>func takeN(done &lt;-chan struct{}, valueStream &lt;-chan interface{}, num int) &lt;-chan interface{} {\n    takeStream := make(chan interface{}) // 创建输出流\n    go func() {\n        defer close(takeStream)\n        for i := 0; i &lt; num; i++ { // 只读取前num个元素\n            select {\n            case &lt;-done:\n                return\n            case takeStream &lt;- &lt;-valueStream: //从输入流中读取元素\n            }\n        }\n    }()\n    return takeStream\n}\n</code></pre><h3>map-reduce</h3><p>map-reduce是一种处理数据的方式，最早是由Google公司研究提出的一种面向大规模数据处理的并行计算模型和方法，开源的版本是hadoop，前几年比较火。</p><p>不过，我要讲的并不是分布式的map-reduce，而是单机单进程的map-reduce方法。</p><p>map-reduce分为两个步骤，第一步是映射（map），处理队列中的数据，第二步是规约（reduce），把列表中的每一个元素按照一定的处理方式处理成结果，放入到结果队列中。</p><p>就像做汉堡一样，map就是单独处理每一种食材，reduce就是从每一份食材中取一部分，做成一个汉堡。</p><p>我们先来看下map函数的处理逻辑:</p><pre><code>func mapChan(in &lt;-chan interface{}, fn func(interface{}) interface{}) &lt;-chan interface{} {\n    out := make(chan interface{}) //创建一个输出chan\n    if in == nil { // 异常检查\n        close(out)\n        return out\n    }\n\n    go func() { // 启动一个goroutine,实现map的主要逻辑\n        defer close(out)\n        for v := range in { // 从输入chan读取数据，执行业务操作，也就是map操作\n            out &lt;- fn(v)\n        }\n    }()\n\n    return out\n}\n</code></pre><p>reduce函数的处理逻辑如下：</p><pre><code>func reduce(in &lt;-chan interface{}, fn func(r, v interface{}) interface{}) interface{} {\n    if in == nil { // 异常检查\n        return nil\n    }\n\n    out := &lt;-in // 先读取第一个元素\n    for v := range in { // 实现reduce的主要逻辑\n        out = fn(out, v)\n    }\n\n    return out\n}\n</code></pre><p>我们可以写一个程序，这个程序使用map-reduce模式处理一组整数，map函数就是为每个整数乘以10，reduce函数就是把map处理的结果累加起来：</p><pre><code>// 生成一个数据流\nfunc asStream(done &lt;-chan struct{}) &lt;-chan interface{} {\n    s := make(chan interface{})\n    values := []int{1, 2, 3, 4, 5}\n    go func() {\n        defer close(s)\n        for _, v := range values { // 从数组生成\n            select {\n            case &lt;-done:\n                return\n            case s &lt;- v:\n            }\n        }\n    }()\n    return s\n}\n\nfunc main() {\n    in := asStream(nil)\n\n    // map操作: 乘以10\n    mapFn := func(v interface{}) interface{} {\n        return v.(int) * 10\n    }\n\n    // reduce操作: 对map的结果进行累加\n    reduceFn := func(r, v interface{}) interface{} {\n        return r.(int) + v.(int)\n    }\n\n    sum := reduce(mapChan(in, mapFn), reduceFn) //返回累加结果\n    fmt.Println(sum)\n}\n</code></pre><h1>总结</h1><p>这节课，我借助代码示例，带你学习了Channel的应用场景和应用模式。这几种模式不是我们学习的终点，而是学习的起点。掌握了这几种模式之后，我们可以延伸出更多的模式。</p><p>虽然Channel最初是基于CSP设计的用于goroutine之间的消息传递的一种数据类型，但是，除了消息传递这个功能之外，大家居然还演化出了各式各样的应用模式。我不确定Go的创始人在设计这个类型的时候，有没有想到这一点，但是，我确实被各位大牛利用Channel的各种点子折服了，比如有人实现了一个基于TCP网络的分布式的Channel。</p><p>在使用Go开发程序的时候，你也不妨多考虑考虑是否能够使用chan类型，看看你是不是也能创造出别具一格的应用模式。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/c9/4140728d1f331beaf92e712cd34681c9.jpg?wh=2250*3290\" alt=\"\"></p><h1>思考题</h1><p>想一想，我们在利用chan实现互斥锁的时候，如果buffer设置的不是1，而是一个更大的值，会出现什么状况吗？能解决什么问题吗？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","neighbors":{"left":{"article_title":"13 | Channel：另辟蹊径，解决并发问题","id":304188},"right":{"article_title":"15 | 内存模型：Go如何保证并发读写的顺序？","id":307469}},"comments":[{"had_liked":false,"id":283241,"user_name":"du tiezheng","can_delete":false,"product_type":"c1","uid":1210215,"ip_address":"","ucode":"33D44752D306F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/77/67/180486e3.jpg","comment_is_top":false,"comment_ctime":1615640653,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"66040150093","product_id":100061801,"comment_content":"chan实现互斥锁，如果buffer大于1，可以实现令牌桶","like_count":16},{"had_liked":false,"id":261380,"user_name":"润豪","can_delete":false,"product_type":"c1","uid":1125122,"ip_address":"","ucode":"0946575790EFAF","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/02/7ef138a0.jpg","comment_is_top":false,"comment_ctime":1605315074,"is_pvip":false,"replies":[{"id":"94850","content":"对。如果不需要这些特性，我的建议是使用mutex","user_name":"作者回复","comment_id":261380,"uid":"1066613","ip_address":"","utype":1,"ctime":1605319145,"user_name_real":"鸟窝"}],"discussion_count":2,"race_medal":0,"score":"44554988034","product_id":100061801,"comment_content":"channel 来实现互斥锁，优势是 trylock，timeout 吧，因为mutex 没有这些功能。否则的话，是不是用回 mutex 呢","like_count":10,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509467,"discussion_content":"对。如果不需要这些特性，我的建议是使用mutex","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605319145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389619,"discussion_content":"timeout这个在mutex上不好扩展","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629358678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261975,"user_name":"茶澜子","can_delete":false,"product_type":"c1","uid":1024410,"ip_address":"","ucode":"2E5FC426F4953F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/9a/73c7b6c8.jpg","comment_is_top":false,"comment_ctime":1605595688,"is_pvip":true,"replies":[{"id":"95087","content":"这段代码在异步的情况下会有问题。fanout在退出时会把out全close,这时异步还在读着。很好的发现，你可以利用所学的尝试解决这个问题","user_name":"作者回复","comment_id":261975,"uid":"1066613","ip_address":"","utype":1,"ctime":1605600471,"user_name_real":"鸟窝"}],"discussion_count":4,"race_medal":0,"score":"23080432168","product_id":100061801,"comment_content":"老师好，我在测试扇出的例子的时候，在异步运行的时候出现了 panic: send on closed channel 的错误<br><br>&#47;&#47; 扇出模式 <br>func FunOut(ch &lt;-chan int, n int, async bool) []chan int {<br>\tvar outs []chan int<br>\tfor i := 0; i &lt; n; i++ {<br>\t\touts = append(outs, make(chan int))<br>\t}<br><br>\tgo func() {<br>\t\tdefer func() {<br>\t\t\tfor i := 0; i &lt; len(outs); i++ {<br>\t\t\t\tclose(outs[i])<br>\t\t\t}<br>\t\t}()<br><br>\t\tfor v := range ch {<br>\t\t\tv := v<br>\t\t\tfor i := 0; i &lt; n; i++ {<br>\t\t\t\ti := i<br>\t\t\t\tif async {<br>\t\t\t\t\tgo func() {<br>\t\t\t\t\t\touts[i] &lt;- v<br>\t\t\t\t\t}()<br>\t\t\t\t} else {<br>\t\t\t\t\touts[i] &lt;- v<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}()<br><br>\treturn outs<br>}<br><br><br>&#47;&#47; TestFunOut 异步操作 扇入模式<br>func TestFunOutAsync(t *testing.T) {<br>\tdataStreams := []int{13, 44, 56, 99, 9, 45, 67, 90, 78, 23}<br><br>\tinputChan := gen(dataStreams...) &#47;&#47; 将数据写入一个channel<br><br>\tch := sq(inputChan) &#47;&#47; 将所有的数据平方，再重新放入channel<br><br>\toutArray := FunOut(ch, 3,true)<br>\tlength := len(outArray)<br>\tt.Log(&quot;length of out channel:&quot;, length)<br>\tvar wg sync.WaitGroup<br>\twg.Add(length)<br>\tfor i := 0; i &lt; length; i++ {<br>\t\tc:=len(outArray[i])<br>\t\tfmt.Println(&quot;输入chan len&quot;, i, c)<br>\t\tgo func(in &lt;-chan int, index int) {<br>\t\t\tsum:=0<br>\t\t\tfor item:=range in{<br>\t\t\t\tfmt.Println(&quot;item&quot;, index, item)<br>\t\t\t\tsum+=item<br>\t\t\t}<br>\t\t\tfmt.Println(&quot;worker&quot;, index, sum)<br><br>\t\t\twg.Done()<br>\t\t}(outArray[i], i)<br>\t}<br>\twg.Wait()<br>}<br><br>老师，我没看明白是哪里出错了？","like_count":5,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509679,"discussion_content":"这段代码在异步的情况下会有问题。fanout在退出时会把out全close,这时异步还在读着。很好的发现，你可以利用所学的尝试解决这个问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605600471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207372,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/4c/d87bb144.jpg","nickname":"Geek_771dd0","note":"","ucode":"FC8F77F7D75EE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332214,"discussion_content":"在异步的逻辑里加个waitgroup可以解决","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607096538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1940895,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/9d/9f/fb05b5b4.jpg","nickname":"冷环星","note":"","ucode":"81629FE9340A7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343525,"discussion_content":"感觉加 WaitGroup 比较好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611067432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1229778,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c3/d2/3c3382e1.jpg","nickname":"想飞的鱼","note":"","ucode":"1BDED70ACF0505","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337202,"discussion_content":"make一个done chan，在异步中通过select的方式发送，在defer里close(done)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608821599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304715,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1627563809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10217498401","product_id":100061801,"comment_content":"令牌桶","like_count":2},{"had_liked":false,"id":260711,"user_name":"Chris","can_delete":false,"product_type":"c1","uid":2163037,"ip_address":"","ucode":"591DE29DEC367A","user_header":"https://static001.geekbang.org/account/avatar/00/21/01/5d/be118cfe.jpg","comment_is_top":false,"comment_ctime":1605087278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10195021870","product_id":100061801,"comment_content":"reflect性能是比较差的，贴一下压测结果：<br>BenchmarkFanIn-4                  382776              3255 ns&#47;op             131 B&#47;op          2 allocs&#47;op<br>BenchmarkFanInReflect-4          1000000             13168 ns&#47;op            6974 B&#47;op         90 allocs&#47;op<br>BenchmarkFanInRec-4               280599              5524 ns&#47;op            1009 B&#47;op         27 allocs&#47;op<br>","like_count":2},{"had_liked":false,"id":321509,"user_name":"斯蒂芬.赵","can_delete":false,"product_type":"c1","uid":1200179,"ip_address":"","ucode":"AA0FF2DA654418","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/33/9dcd30c4.jpg","comment_is_top":false,"comment_ctime":1636911169,"is_pvip":true,"replies":[{"id":"116823","content":"和工业化流水线一个意思。每个goroutine负责一个业务","user_name":"作者回复","comment_id":321509,"uid":"1066613","ip_address":"","utype":1,"ctime":1637034255,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"5931878465","product_id":100061801,"comment_content":"老师想问一下上面所讲的击鼓传花的案例(流水线模式)的应用场景是？感觉就是按照顺序串行的话执行某些任务逻辑，不用goroutine的话也可以吧","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530307,"discussion_content":"和工业化流水线一个意思。每个goroutine负责一个业务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637034255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261663,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1605486495,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5900453791","product_id":100061801,"comment_content":"我们在利用 chan 实现互斥锁的时候，如果 buffer 设置的不是 1，而是一个更大的值，会出现什么状况吗？能解决什么问题吗？<br><br>这样就能走多个gorouting获取到锁了，这就是一个共享锁，对于读多写少的场景，很有用。但是就是对于写锁，还是要配合buffer是1的chann。这类似于Java中的RentrantReadWriteLock","like_count":1,"discussions":[{"author":{"id":1229778,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c3/d2/3c3382e1.jpg","nickname":"想飞的鱼","note":"","ucode":"1BDED70ACF0505","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337133,"discussion_content":"读锁是共享的，不存在多少的问题，这里应该是信号量的应用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608801946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1325816,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","nickname":"君哥聊技术","note":"","ucode":"2C9A22BCE4C79E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1229778,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c3/d2/3c3382e1.jpg","nickname":"想飞的鱼","note":"","ucode":"1BDED70ACF0505","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337252,"discussion_content":"你说的对，确实是一个信号量的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608856342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337133,"ip_address":""},"score":337252,"extra":""}]}]},{"had_liked":false,"id":260532,"user_name":"myrfy","can_delete":false,"product_type":"c1","uid":1169401,"ip_address":"","ucode":"2814BAE5D70098","user_header":"","comment_is_top":false,"comment_ctime":1605056999,"is_pvip":false,"replies":[{"id":"94625","content":"我并没有benchmark结果列在这里，凭经验我们也知道反射的效率很低。Francesc Campoy有一篇文章专门做了测试，你可以搜一下。<br>analyzing the performance of go functions with benchmarks.<br>异步的方式并不是你所说的目的，而是避免一个out chan阻塞的时候影响其他out","user_name":"作者回复","comment_id":260532,"uid":"1066613","ip_address":"","utype":1,"ctime":1605078611,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"5900024295","product_id":100061801,"comment_content":"老师好，我有两个问题<br>1、关于or done或者fan in模式，我之前在sof上看到过类似的问题，其中的高赞回答是说，启动与ch数量相等的goroutine，每个goroutine监听一个ch并把读到的结果放入一个收集ch的模式效率要比反射高，并且给出了测评数据，现在手机码字，不太好找到。但想和老师确认一下是不是后面go某个版本对反射做了优化呢？<br>2、fanout模式里提到可以同步或者异步启动任务。在老师给出的示例代码中，异步启动的优势是什么呢？我猜老师想表达的是不是启动任务前可能还有一些耗时的准备操作？如果是这样的话，建议增加一个注释，否则感觉启动一个goroutine只是为了写一个ch，好像异步效率会更低","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509221,"discussion_content":"我并没有benchmark结果列在这里，凭经验我们也知道反射的效率很低。Francesc Campoy有一篇文章专门做了测试，你可以搜一下。\nanalyzing the performance of go functions with benchmarks.\n异步的方式并不是你所说的目的，而是避免一个out chan阻塞的时候影响其他out","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605078611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357163,"user_name":"A9","can_delete":false,"product_type":"c1","uid":1053211,"ip_address":"北京","ucode":"76D07F8EBE8DD0","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/1b/f62722ca.jpg","comment_is_top":false,"comment_ctime":1663001019,"is_pvip":false,"replies":[{"id":"130653","content":"https:&#47;&#47;github.com&#47;chrislusf&#47;netchan","user_name":"作者回复","comment_id":357163,"uid":"1066613","ip_address":"北京","utype":1,"ctime":1665372248,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1663001019","product_id":100061801,"comment_content":"一个基于 TCP 网络的分布式的 Channel ，请问这个有git仓库吗，想学习下","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589864,"discussion_content":"https://github.com/chrislusf/netchan","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665372248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354717,"user_name":"The brain is a good thing","can_delete":false,"product_type":"c1","uid":1710489,"ip_address":"广东","ucode":"7CE2C85BC5C092","user_header":"https://static001.geekbang.org/account/avatar/00/1a/19/99/ba3719e1.jpg","comment_is_top":false,"comment_ctime":1660708687,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660708687","product_id":100061801,"comment_content":"基于老师的channel编排小小改动，毕竟如果worker 数量多，手动去make初始化工作量就有点大了。<br>type Token struct {}<br><br>func work(id int,ch chan Token,nextCh chan Token,data chan int,exit chan struct{}) {<br>\tfor {<br>\t\ttoken := &lt;-ch<br>\t\tif v,ok := &lt;-data; ok {<br>\t\t\tfmt.Printf(&quot;groutine id:%v,val:%v \\n&quot;,id+1,v)<br>\t\t}else {<br>\t\t\texit &lt;- struct{}{}<br>\t\t\treturn<br>\t\t}<br>\t\t&#47;&#47;time.Sleep(time.Second)<br>\t\tnextCh &lt;- token<br>\t}<br>}<br><br>func main() {<br>\tworkerNum := 10<br>\tchs := make([]chan Token,workerNum)<br>\tnums := make(chan int)<br>\texit := make(chan struct{})<br>\t&#47;&#47;worker<br>\tfor i := 0; i &lt; workerNum; i++ {<br>\t\tif chs[i] == nil {<br>\t\t\tchs[i] = make(chan Token)<br>\t\t}<br>\t\tif chs[(i+1)%workerNum] == nil {<br>\t\t\tchs[(i+1)%workerNum] = make(chan Token)<br>\t\t}<br>\t\tgo work(i,chs[i],chs[(i+1)%workerNum],nums,exit)<br>\t}<br><br>\tgo func() {<br>\t\tfor i := 0; i &lt; 100; i++ {<br>\t\t\tnums &lt;- i<br>\t\t}<br>\t\tclose(nums)<br>\t}()<br>\tchs[0] &lt;- Token{}<br><br>\t&lt;- exit<br><br>}","like_count":0},{"had_liked":false,"id":353176,"user_name":"Geek_a6104e","can_delete":false,"product_type":"c1","uid":1711967,"ip_address":"北京","ucode":"29A56792216DC8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/GJXKh8OG00U5ial64plAIibbIuwkzhPc8uYic9Hibl8SbqvhnS2JImHgCD4JGvTktiaVnCjHQWbA5wicaxRUN5aTEWnQ/132","comment_is_top":false,"comment_ctime":1659236987,"is_pvip":false,"replies":[{"id":"128579","content":"可以用来主动退出","user_name":"作者回复","comment_id":353176,"uid":"1066613","ip_address":"北京","utype":1,"ctime":1659660375,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1659236987","product_id":100061801,"comment_content":"请问一下最后一段代码里面case &lt;-done: 有什么用呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582755,"discussion_content":"可以用来主动退出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659660376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335125,"user_name":"哈哈","can_delete":false,"product_type":"c1","uid":1131488,"ip_address":"","ucode":"1D828665BA95D3","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/e0/66b71c1f.jpg","comment_is_top":false,"comment_ctime":1645347178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645347178","product_id":100061801,"comment_content":"&#47;&#47; 解决异步情况，通道关闭，send数据导致panic的情况<br>func fanOut(in &lt;-chan interface{}, outs []chan interface{}, async bool) {<br>\tgo func() {<br>\t\tvar wg sync.WaitGroup<br><br>\t\tdefer func() {<br>\t\t\twg.Wait()<br><br>\t\t\tfor i := 0; i &lt; len(outs); i++ {<br>\t\t\t\tclose(outs[i])<br>\t\t\t}<br>\t\t}()<br><br>\t\tfor v := range in {<br>\t\t\tv := v<br>\t\t\tfor i := range outs {<br>\t\t\t\ti := i<br><br>\t\t\t\tif async {<br>\t\t\t\t\twg.Add(1)<br>\t\t\t\t\tgo func() {<br>\t\t\t\t\t\touts[i] &lt;- v<br>\t\t\t\t\t\twg.Done()<br>\t\t\t\t\t}()<br>\t\t\t\t} else {<br>\t\t\t\t\touts[i] &lt;- v<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}()<br>}","like_count":0},{"had_liked":false,"id":315376,"user_name":"པག་ཏོན་།","can_delete":false,"product_type":"c1","uid":1547842,"ip_address":"","ucode":"4A70B482F7BB9D","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/42/ab4f65c8.jpg","comment_is_top":false,"comment_ctime":1633868579,"is_pvip":false,"replies":[{"id":"118834","content":"我也觉得他的实现方案有问题，有点感觉是从其它语言的实现复制过来的，有点设计过度。<br>我和你的设计方案也有些不同，你的方案类似scala的actor模式。这种模式有个问题，如果某个actor处理慢了，可能会导致任务堆积在这个actor上。<br>go很常规的操作就是用一个channel实现buffer,各个goroutine都从这个buffer获取任务就好了。","user_name":"作者回复","comment_id":315376,"uid":"1066613","ip_address":"","utype":1,"ctime":1639808114,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1633868579","product_id":100061801,"comment_content":"老师您好，在看Marcio Castilho 在 使用 Go 每分钟处理百万请求的例子的时候我很困惑，我认为双层管道是没有意义的，生产者直接发送job给消费者，额定数量的消费者直接进行并发接收并处理就可以达到同样控制并发的效果。为什么非要消费者把一个管道交给生产者，生产者在把job通过管道传递给消费者。我想请问一下这个步骤的作用是什么？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539712,"discussion_content":"我也觉得他的实现方案有问题，有点感觉是从其它语言的实现复制过来的，有点设计过度。\n我和你的设计方案也有些不同，你的方案类似scala的actor模式。这种模式有个问题，如果某个actor处理慢了，可能会导致任务堆积在这个actor上。\ngo很常规的操作就是用一个channel实现buffer,各个goroutine都从这个buffer获取任务就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639808114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314875,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1633524029,"is_pvip":false,"replies":[{"id":"116825","content":"以后有机会扩充一下","user_name":"作者回复","comment_id":314875,"uid":"1066613","ip_address":"","utype":1,"ctime":1637034392,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"1633524029","product_id":100061801,"comment_content":"請問老師，channel這些模式都適合哪些塲景使用，能哪些優缺點能講講嗎","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527824,"discussion_content":"以后有机会扩充一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637034392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311028,"user_name":"Geek_5a2059","can_delete":false,"product_type":"c1","uid":2256744,"ip_address":"","ucode":"2A59A6CED90CDF","user_header":"","comment_is_top":false,"comment_ctime":1631023818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631023818","product_id":100061801,"comment_content":"Go 的 select 是伪随机的，它可以在执行的 case 中随机选择一个 case，并把选择的这个 case 的索引（chosen）返回，如果没有可用的 case 返回，会返回一个 bool 类型的返回值，这个返回值用来表示是否有 case 成功被选择。如果是 recv case，还会返回接收的元素。<br>”如果没有可用的 case 返回，会返回一个 bool 类型的返回值“ 这句话不太对吧，看源码注释，如果没有可用的 case，会一直阻塞的<br>&#47;&#47; Select executes a select operation described by the list of cases.<br>&#47;&#47; Like the Go select statement, it blocks until at least one of the cases<br>&#47;&#47; can proceed<br><br><br><br><br><br><br><br><br><br><br><br><br>","like_count":0},{"had_liked":false,"id":302670,"user_name":"Geek_a3c9f5","can_delete":false,"product_type":"c1","uid":2433816,"ip_address":"","ucode":"F99DD705D66068","user_header":"","comment_is_top":false,"comment_ctime":1626326808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626326808","product_id":100061801,"comment_content":"每个源 Channel 的元素都会发送给目标 Channel，相当于目标 Channel 的 receiver 只需要监听目标 Channel，就可以接收所有发送给源 Channel 的数据。<br>上面这句是否为笔误，下面的句子应该比较接近原意？还是我理解有误？<br>每个源Channel 的元素都会发送给目标Channel，相当于目标Channel 的receiver 只需要监听目标Channel，就可以接收所有发送给目标Channel 的数据。","like_count":0},{"had_liked":false,"id":302669,"user_name":"Geek_a3c9f5","can_delete":false,"product_type":"c1","uid":2433816,"ip_address":"","ucode":"F99DD705D66068","user_header":"","comment_is_top":false,"comment_ctime":1626326710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626326710","product_id":100061801,"comment_content":"每個源Channel 的元素都會發送給目標Channel，相當於目標Channel 的receiver 只需要監聽目標Channel，就可以接收所有發送給源Channel 的數據。<br>上面这句是否为笔误，下面的句子应该比较接近原意？还是我理解有误？<br>每个源Channel 的元素都会发送给目标Channel，相当于目标Channel 的receiver 只需要监听目标Channel，就可以接收所有发送给目标Channel 的数据。","like_count":0},{"had_liked":false,"id":293973,"user_name":"科科","can_delete":false,"product_type":"c1","uid":1647304,"ip_address":"","ucode":"7DAE6FE781172E","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","comment_is_top":false,"comment_ctime":1621662708,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1621662708","product_id":100061801,"comment_content":"这节课信息量爆炸了，没想到channel有这么多用法，学到了学到了。<br>如果buffer有多个，我觉得在业务场景当中处理发布订阅的场景很适合用，当服务端发出一个事件的时候，很多终端都会来订阅，需要限制一次同时允许访问的最大数，超过可以返回错误，告诉终端稍后重试。","like_count":0},{"had_liked":false,"id":293679,"user_name":"科科","can_delete":false,"product_type":"c1","uid":1647304,"ip_address":"","ucode":"7DAE6FE781172E","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","comment_is_top":false,"comment_ctime":1621489481,"is_pvip":false,"replies":[{"id":"110319","content":"没有重新，每一个建一个","user_name":"作者回复","comment_id":293679,"uid":"1066613","ip_address":"","utype":1,"ctime":1627731195,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":1,"score":"1621489481","product_id":100061801,"comment_content":"老师，请问下为什么在createCase函数里面，我们在创建一个SelectCase变量的时候，要使用reflect.ValueOf重新初始化一个的channel?","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520315,"discussion_content":"没有重新，每一个建一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627731195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292358,"user_name":"Le Incredible Sulk","can_delete":false,"product_type":"c1","uid":1143938,"ip_address":"","ucode":"FFFFFEA630AA32","user_header":"https://static001.geekbang.org/account/avatar/00/11/74/82/552786e8.jpg","comment_is_top":false,"comment_ctime":1620791812,"is_pvip":false,"replies":[{"id":"105811","content":"channel是线程内的，你怎么有传递大文件的需求，什么是大文件传输？channel可以传递大的byte slice,没有性能问题。要是大数组就不合适了","user_name":"作者回复","comment_id":292358,"uid":"1066613","ip_address":"","utype":1,"ctime":1620795034,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"1620791812","product_id":100061801,"comment_content":"老师，请问一下channel适不适用于传输大文件？还有就是传输大文件的性能情况是怎样的？（刚遇到的面试题）","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519794,"discussion_content":"channel是线程内的，你怎么有传递大文件的需求，什么是大文件传输？channel可以传递大的byte slice,没有性能问题。要是大数组就不合适了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620795034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291737,"user_name":"Initiative Thinker","can_delete":false,"product_type":"c1","uid":1736297,"ip_address":"","ucode":"A884396A1581EF","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9zRdkKuXMKh30ibeludlAsztmR4rD9iaiclPicOfIhbC4fWxGPz7iceb3o4hKx7qgX2dKwogYvT6VQ0g/132","comment_is_top":false,"comment_ctime":1620455364,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1620455364","product_id":100061801,"comment_content":"如果cleanup处理超时，主goroutine结束了，docleanup也会终止，但是cleanup还没有处理完，是不是会造成泄漏呢？","like_count":0},{"had_liked":false,"id":290097,"user_name":"小袁","can_delete":false,"product_type":"c1","uid":1811495,"ip_address":"","ucode":"3F5D8721F577D9","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","comment_is_top":false,"comment_ctime":1619359909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619359909","product_id":100061801,"comment_content":"拓展了我对channle应用场景的理解。","like_count":0},{"had_liked":false,"id":288987,"user_name":"AFreeCoder","can_delete":false,"product_type":"c1","uid":1235013,"ip_address":"","ucode":"4B2B22A6D84A3D","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/45/02047152.jpg","comment_is_top":false,"comment_ctime":1618810686,"is_pvip":false,"replies":[{"id":"105119","content":"这段代码有问题，正确的代码参看<br>https:&#47;&#47;github.com&#47;smallnest&#47;dive-to-gosync-workshop&#47;blob&#47;master&#47;5.channel&#47;or_channel&#47;main.go","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1619261896,"ip_address":"","comment_id":288987,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618810686","product_id":100061801,"comment_content":"orDone 模式的代码没看明白。如果channel数是一个，直接返回这个channel，如果大于等于2个，就会返回被close的orDone，两种情况下返回的channel含义不一样，这是为什么呢","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518785,"discussion_content":"这段代码有问题，正确的代码参看\nhttps://github.com/smallnest/dive-to-gosync-workshop/blob/master/5.channel/or_channel/main.go","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619261896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267035,"user_name":"大恒","can_delete":false,"product_type":"c1","uid":1330033,"ip_address":"","ucode":"B8E3E2273F74DB","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/71/591ae170.jpg","comment_is_top":false,"comment_ctime":1607577668,"is_pvip":true,"replies":[{"id":"96947","content":"可以使用回调，没有比较优劣","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1607609959,"ip_address":"","comment_id":267035,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1607577668","product_id":100061801,"comment_content":"实现观察者为何不使用类似java的接口回调、go的函数回调，而要用扇出模式呢","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511491,"discussion_content":"可以使用回调，没有比较优劣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607609959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266175,"user_name":"Nemo","can_delete":false,"product_type":"c1","uid":1005931,"ip_address":"","ucode":"6349E21E063DDA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/6b/d5467acd.jpg","comment_is_top":false,"comment_ctime":1607226254,"is_pvip":false,"replies":[{"id":"96746","content":"没有，获取到锁true","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1607328583,"ip_address":"","comment_id":266175,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607226254","product_id":100061801,"comment_content":"```go<br>&#47;&#47; 加入一个超时的设置<br>func (m *Mutex) LockTimeout(timeout time.Duration) bool {<br>    timer := time.NewTimer(timeout)    <br>      select {    <br>         case &lt;-m.ch:        <br>             timer.Stop()      <br>             return true    <br>         case &lt;-timer.C:    <br>       }    <br>       return false<br>}<br>```<br>这里是不是返回值写反了？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511169,"discussion_content":"没有，获取到锁true","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607328583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263684,"user_name":"写点啥呢","can_delete":false,"product_type":"c1","uid":1065272,"ip_address":"","ucode":"C19032CF1C41BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","comment_is_top":false,"comment_ctime":1606217556,"is_pvip":false,"replies":[{"id":"95654","content":"这和只使用一个channel没区别了，生产者往这个channel发，消费者从这个channel读","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1606223404,"ip_address":"","comment_id":263684,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606217556","product_id":100061801,"comment_content":"请问老师，扇入扇出中可不可以让所有goroutine公用一个channel呢？比如扇入中，所有调用者都向同一个channel发送，被调用的goroutine从这个公共channel接收数据后再通过另外一个out channel发出去. 这样实现有什么问题不？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510269,"discussion_content":"这和只使用一个channel没区别了，生产者往这个channel发，消费者从这个channel读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606223404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262591,"user_name":"SuperDai","can_delete":false,"product_type":"c1","uid":1289318,"ip_address":"","ucode":"0CA86D253754CA","user_header":"https://static001.geekbang.org/account/avatar/00/13/ac/66/a256008b.jpg","comment_is_top":false,"comment_ctime":1605775165,"is_pvip":false,"replies":[{"id":"95280","content":"for async &amp;&amp; finished......会空转耗cpu,可以使用waitgroup。使用goroutine不是一种好的解决方案","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605781132,"ip_address":"","comment_id":262591,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605775165","product_id":100061801,"comment_content":"func FanOut(in &lt;-chan interface{}, out []chan interface{}, async bool) {<br>\tgo func() {<br>\t\tvar finish atomic.Value<br><br>\t\tdefer func() { &#47;&#47; 退出时关闭所有的输出channel<br>\t\t\tfor async &amp;&amp; finish.Load().(int) &lt; len(out) {<br>\t\t\t}<br><br>\t\t\tfor i := 0; i &lt; len(out); i++ {<br>\t\t\t\tclose(out[i])<br>\t\t\t}<br>\t\t}()<br><br>\t\tfor v := range in {<br>\t\t\tif async {<br>\t\t\t\tfinish.Store(0)<br>\t\t\t}<br><br>\t\t\tv := v<br>\t\t\tfor i := 0; i &lt; len(out); i++ {<br>\t\t\t\ti := i<br>\t\t\t\t&#47;&#47; TODO: 异步模式下, 会出现向已关闭的channel写数据<br>\t\t\t\t&#47;&#47; Done: 利用原子计数来修复<br>\t\t\t\tif async {<br>\t\t\t\t\tgo func() {<br>\t\t\t\t\t\tout[i] &lt;- v<br>\t\t\t\t\t\tfinish.Store(finish.Load().(int) + 1)<br>\t\t\t\t\t}()<br>\t\t\t\t} else {<br>\t\t\t\t\tout[i] &lt;- v<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}()<br>}<br><br><br>老师, 这样写应该能修复FanOut的问题吧","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509890,"discussion_content":"for async &amp;amp;&amp;amp; finished......会空转耗cpu,可以使用waitgroup。使用goroutine不是一种好的解决方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605781132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262156,"user_name":"大漠胡萝卜","can_delete":false,"product_type":"c1","uid":1198953,"ip_address":"","ucode":"FBE51E4A13EF4F","user_header":"https://static001.geekbang.org/account/avatar/00/12/4b/69/c02eac91.jpg","comment_is_top":false,"comment_ctime":1605625661,"is_pvip":false,"replies":[{"id":"95147","content":"async模式下会，而且会有问题","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605673829,"ip_address":"","comment_id":262156,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605625661","product_id":100061801,"comment_content":"fanOut模式示例代码会出现向已经close的chan发送数据么？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509710,"discussion_content":"async模式下会，而且会有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605673829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261389,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1605318928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605318928","product_id":100061801,"comment_content":"反射chan第一次知道，理解起来是有点困难","like_count":0},{"had_liked":false,"id":260671,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1605081092,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605081092","product_id":100061801,"comment_content":"对channel有更深入的理解","like_count":0},{"had_liked":false,"id":260615,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1605071526,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1605071526","product_id":100061801,"comment_content":"在利用 chan 实现互斥锁的时候，如果 buffer 设置的不是 1，而是一个更大的值N<br><br>允许最多N个goroutine同时拥有锁，类似Semaphore作用","like_count":0}]}