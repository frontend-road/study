{"id":188701,"title":"06 | 作用域与对象释放行为：你知道IDisposable对象释放的时机和坑吗？","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/NET-Core\">https://gitee.com/geektime-geekbang/NET-Core</a></p>","comments":[{"had_liked":false,"id":177899,"user_name":"大风","can_delete":false,"product_type":"c3","uid":1003342,"ip_address":"","ucode":"4532DD25F852F5","user_header":"","comment_is_top":false,"comment_ctime":1581524404,"is_pvip":false,"replies":[{"id":69293,"content":"RequestService是指ASP.NET Core框架为每个HTTP请求创建的子容器，就是当前请求的容器。","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1581754589,"ip_address":"","comment_id":177899,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"能在解释下第五分钟谈到的，当前应用容器，当前请求容器？","like_count":8,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483588,"discussion_content":"RequestService是指ASP.NET Core框架为每个HTTP请求创建的子容器，就是当前请求的容器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581754589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1387349,"avatar":"","nickname":"limulimu2017","note":"","ucode":"782378CB722A75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168378,"discussion_content":"+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581577310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173524,"user_name":"季某人","can_delete":false,"product_type":"c3","uid":1809686,"ip_address":"","ucode":"1EEF2A58C3BD79","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9d/16/a2fb8136.jpg","comment_is_top":false,"comment_ctime":1579588850,"is_pvip":false,"replies":[{"id":67274,"content":"是的","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1579600062,"ip_address":"","comment_id":173524,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"老师您好，请问一下如果服务不实现IDisposable接口，那么这个服务是由GC负责释放的吗","like_count":6,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482099,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579600062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171676,"user_name":"Mr.Beethoven","can_delete":false,"product_type":"c3","uid":1588862,"ip_address":"","ucode":"199A3814A43DB7","user_header":"https://static001.geekbang.org/account/avatar/00/18/3e/7e/c06badd0.jpg","comment_is_top":false,"comment_ctime":1578990243,"is_pvip":false,"replies":[{"id":66558,"content":"对于实现了IDisposable的服务，要避免在跟容器以瞬时服务的方式获取\n\n对于没有实现IDisposable的服务，是没有关系的","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1578995473,"ip_address":"","comment_id":171676,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"老师，什么时候会用到“从根容器获取瞬时服务”这件事\n是不是不应该从根容器获取瞬时服务 ","like_count":4,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481466,"discussion_content":"对于实现了IDisposable的服务，要避免在跟容器以瞬时服务的方式获取\n\n对于没有实现IDisposable的服务，是没有关系的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578995473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103960,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d8/58/1f5f7aed.jpg","nickname":"提姆","note":"","ucode":"F2A339CC9AC594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242897,"discussion_content":"对于没有实现IDisposable的服务，是没有关系的\n=> 是因为最后会交由GC去处理吗？\n\n感谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587489736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199446,"user_name":"哇哈哈啊哈哈","can_delete":false,"product_type":"c3","uid":1357444,"ip_address":"","ucode":"089B6B76CD2C7D","user_header":"https://static001.geekbang.org/account/avatar/00/14/b6/84/2c794e70.jpg","comment_is_top":false,"comment_ctime":1585489357,"is_pvip":false,"replies":[{"id":77429,"content":"大体的理解是对的，更准确一点： \n\n1.IServiceCollection表示我们定义的服务类型、构造方式和生命周期的配置表，IServiceprovider则表示跟容器，当我们调用GetService时，它会根据IServiceCollection中的定义来决定如何构造（或者返回一个已有的）服务对象。\n\n2.容器只会管理实现了IDisposable的服务的释放（调用Dispose方法），对于未实现IDisposable的服务，容器是不管的。\n另外对象最终的回收，是由GC完成的。\n生命周期的定义，是决定了容器是返回一个新对象，还是复用之前创建的对象。\n\n3.使用IServiceprovider的扩展方法CreateScope来创建子容器。","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1587042089,"ip_address":"","comment_id":199446,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"感谢老肖的视频讲解，之前一直在看官方文档，理解的内容都是一片一片的，很容易忘记，今天看了老肖的视频，整理了一些笔记，贴出来有不对的地方，希望老肖能指正下。\n\n\n1.应用启动时IServiceCollection会创建根容器IServiceprovider。我们自定义的服务都会在configservices方法中注册(问题一:此时自定义的服务是声明在根容器中吗？)，注册时所用的生命周期也是服务在根容器中的生命周期。\n\n2.不考虑自己创建的服务并继承了释放接口的情况下。瞬时服务会在每次请求后释放，范围服务如果是定义在根容器中，则和单例服务一样，应用退出后被释放。如果范围服务定义在子容器中，则由子容器控制释放。\n\n3.除了使用requestService这个应用程序为每个请求创建的子容器，还有别的方法自己创建子容器吗？(这个问题我可以自己百度)，但还是想问下，因为现在在蹲坑整理笔记中......\n\n","like_count":3,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489835,"discussion_content":"大体的理解是对的，更准确一点： \n\n1.IServiceCollection表示我们定义的服务类型、构造方式和生命周期的配置表，IServiceprovider则表示跟容器，当我们调用GetService时，它会根据IServiceCollection中的定义来决定如何构造（或者返回一个已有的）服务对象。\n\n2.容器只会管理实现了IDisposable的服务的释放（调用Dispose方法），对于未实现IDisposable的服务，容器是不管的。\n另外对象最终的回收，是由GC完成的。\n生命周期的定义，是决定了容器是返回一个新对象，还是复用之前创建的对象。\n\n3.使用IServiceprovider的扩展方法CreateScope来创建子容器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587042089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171758,"user_name":"黄青松","can_delete":false,"product_type":"c3","uid":1606067,"ip_address":"","ucode":"577C6792C34D99","user_header":"https://static001.geekbang.org/account/avatar/00/18/81/b3/3e95b6cf.jpg","comment_is_top":false,"comment_ctime":1579007366,"is_pvip":false,"replies":[{"id":66649,"content":"根容器可以理解为由我们通过ServiceCollection Build出的容器，子容器是由容器创建出来的，其中父容器也可以是其他容器的子容器，也就是孩子的孩子，这个关系是可以一直嵌套下去的","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1579050072,"ip_address":"","comment_id":171758,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"老师，什么是根容器，什么是子容器","like_count":3,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481497,"discussion_content":"根容器可以理解为由我们通过ServiceCollection Build出的容器，子容器是由容器创建出来的，其中父容器也可以是其他容器的子容器，也就是孩子的孩子，这个关系是可以一直嵌套下去的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579050072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193447,"user_name":"爱学习的大叔","can_delete":false,"product_type":"c3","uid":1085152,"ip_address":"","ucode":"91F9ABF1EC98D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/e0/847348b1.jpg","comment_is_top":false,"comment_ctime":1584893285,"is_pvip":false,"replies":[{"id":77156,"content":"感谢支持","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1586875452,"ip_address":"","comment_id":193447,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"听了几节课，老师讲的非常棒，把依赖注入、如何使用作用域以及一些坑讲的挺好的。听完以后就知道怎么举一反三写代码。比我在其他地方看些.net core的教程好多了。","like_count":2,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488558,"discussion_content":"感谢支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586875452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186001,"user_name":"SuperSnow","can_delete":false,"product_type":"c3","uid":1065351,"ip_address":"","ucode":"84C89AA8083E6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","comment_is_top":false,"comment_ctime":1583740686,"is_pvip":false,"replies":[{"id":72476,"content":"在跟容器获取作用域服务会直接报错","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1584244275,"ip_address":"","comment_id":186001,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"避免在根容器获取实现了IDisposable接口的瞬时服务，是不是也要再加上作用域服务？因为一个请求同样也会创建服务。","like_count":2,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486576,"discussion_content":"在跟容器获取作用域服务会直接报错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584244275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2438559,"avatar":"https://static001.geekbang.org/account/avatar/00/25/35/9f/0563cc5f.jpg","nickname":"77","note":"","ucode":"8DDA45E282F6AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587512,"discussion_content":"Cannot resolve scoped service &#39;DependencyInjectionScopeAndDisposableDemo.Services.IOrderService&#39; from root provider.\n为什么不允许从根容器获取作用域服务？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663123336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172170,"user_name":"再见理想","can_delete":false,"product_type":"c3","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1579100328,"is_pvip":false,"replies":[{"id":66844,"content":"是因为请求的代码里并没有创建瞬时服务，仅仅在启动过程中使用根容器创建了瞬时服务","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1579169245,"ip_address":"","comment_id":172170,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"最后的根容器瞬时服务为什么 请求了多次 只释放了一次 不应该是每次创建都会有一个新的吗","like_count":2,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481651,"discussion_content":"是因为请求的代码里并没有创建瞬时服务，仅仅在启动过程中使用根容器创建了瞬时服务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579169245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212402,"discussion_content":"主要是在中间件里并没有创建瞬态实例，这样在每次请求的时候不会创建，只是容器启动的时候会创建一次，当根容器退出的时候，才会释放该对象。app.applicationServices.GetService只是写在configure方法中，如果将其写在某个中间件use中，那就不得了了，内存最后就崩了，因为每次请求都会创建一个瞬态实例，而且还不会释放。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584968282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217730,"user_name":"张志炜","can_delete":false,"product_type":"c3","uid":1221549,"ip_address":"","ucode":"31643B345C5B27","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/ad/79b26eea.jpg","comment_is_top":false,"comment_ctime":1589597545,"is_pvip":false,"replies":[{"id":80602,"content":"启动过程是一次性的，启动后，每次请求都会由”一个“线程作处理请求。\n\n你的理解是对的，在请求的处理中不要使用根容器，应该使用scope的容器，否则一样会有问题。","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1589684702,"ip_address":"","comment_id":217730,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"老师说的根容器，是说Startup.Configure里面么。\n这里面，好像只有站点第一次运行的时候才会执行到。\n后续每次Get都和这里无关。\n所以，就算是瞬时服务，在这里被获取了，最多是和单例一样，获取一次，不会每次Get都重新获取而不释放吧。","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495242,"discussion_content":"启动过程是一次性的，启动后，每次请求都会由”一个“线程作处理请求。\n\n你的理解是对的，在请求的处理中不要使用根容器，应该使用scope的容器，否则一样会有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589684702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217719,"user_name":"张志炜","can_delete":false,"product_type":"c3","uid":1221549,"ip_address":"","ucode":"31643B345C5B27","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/ad/79b26eea.jpg","comment_is_top":false,"comment_ctime":1589596560,"is_pvip":false,"replies":[{"id":80603,"content":"感谢建议，你的理解是对的。\n这里核心是不要在请求的代码中使用根容器，要使用requestservice 这种scope容器，否则会有问题","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1589684805,"ip_address":"","comment_id":217719,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"注册一个瞬时服务。\n然后在根容器中，去获取这个服务。\n你获取了一次，就只会获取一个服务。\n应该也不会有太严重的问题？\n因为我一开始看你介绍，还以为是每次Action的时候都会创建，那么内存持续占用而不释放。\n但如果根容器中调用了一次之后，不会再次调用，那么和单例对象没有什么区别，应该不是大问题？","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495233,"discussion_content":"感谢建议，你的理解是对的。\n这里核心是不要在请求的代码中使用根容器，要使用requestservice 这种scope容器，否则会有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589684805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2705491,"avatar":"","nickname":"Geek_Zhengyu","note":"","ucode":"FFD9E0BBEE0293","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385275,"discussion_content":"这个理解是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626962498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209099,"user_name":"提姆","can_delete":false,"product_type":"c3","uid":1103960,"ip_address":"","ucode":"F2A339CC9AC594","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/58/1f5f7aed.jpg","comment_is_top":false,"comment_ctime":1587490258,"is_pvip":false,"replies":[{"id":79645,"content":"1.根容器也可以通过构造函数注入的方式注入到你的服务里，也就是你可以通过根容器GetService得到根容器。\n2.你的理解是对的。","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1588942228,"ip_address":"","comment_id":209099,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"老师您好，请教几个问题\n1. 根容器的获取是不是只能在Startup.Configure下才能获取？\n2. 一般来说，是不是比较不会去向根容器获取服务？主要都是由ASP.NET Core所创建的子容器为主","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492712,"discussion_content":"1.根容器也可以通过构造函数注入的方式注入到你的服务里，也就是你可以通过根容器GetService得到根容器。\n2.你的理解是对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588942228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2438559,"avatar":"https://static001.geekbang.org/account/avatar/00/25/35/9f/0563cc5f.jpg","nickname":"77","note":"","ucode":"8DDA45E282F6AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":587514,"discussion_content":"public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger, IServiceProvider serviceProvider)\n        {\n            _logger = logger;\n            _serviceProvider = serviceProvider;\n        }\n\n        [HttpGet]\n        public int Get(\n        [FromServices] IOrderService orderService,\n        [FromServices] IOrderService orderService1)\n        {\n\n            var s=_serviceProvider.GetService&lt;IOrderService&gt;();\n            #region \n            Console.WriteLine(&#34;结束&#34;);\n            #endregion\n\n\n            return 1;\n        }\n\n意思是这样子吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663123784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":492712,"ip_address":"福建","group_id":0},"score":587514,"extra":""}]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243185,"discussion_content":"Configure方法只是用来构造请求管道的过程，这个阶段是使用根容器的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587527706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243173,"discussion_content":"只要是实现了IServiceProvider接口的对象，都是可以拿到根容器的。\n管道构建时所用到的服务实例都是由根容器创建的，而针对每一个请求，都会创建一个基于IServiceScope接口的对象，而其中有一个IServiceProvider的对象，也就是子容器，所以在一般具体使用时，没有特殊情况，肯定都是以子容器为主，只是这个过程由框架帮助完成了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587526568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206714,"user_name":"Geek_1281f4","can_delete":false,"product_type":"c3","uid":1816553,"ip_address":"","ucode":"7C9EB7D812473E","user_header":"","comment_is_top":false,"comment_ctime":1586919855,"is_pvip":false,"replies":[{"id":77417,"content":"你这个例子，OrderItem看起来是order的一个集合属性，它不是聚合根。\n\n另外聚合根之间的影响，是通过领域事件来驱动的","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1587040465,"ip_address":"","comment_id":206714,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"肖老师你好，有个关于仓储和工作单元的问题请教一下你。有多个Repository（如：OrderRepository-订单仓储、OrderItemRepository-订单项仓储）,现在想同时保存多个对象（如：Order-订单、OrderItem-订单项），希望对Order、OrderItem的保存在同一事务里，那么调用哪个保存方法比较合适呢？目前工作单元、SaveChangesAsync、SaveEntitiesAsync都在某一个具体的仓储类（如：OrderRepository）上，调用OrderRepository的SaveEntitiesAsync，从代码看很像是只保存了Order，如何调用让代码看起来更顺理成章一些。亦或是直接在保存的地儿直接注入EFContext，直接调用EFContext的SaveChangesAsync？ 有没有最佳实践？","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491875,"discussion_content":"你这个例子，OrderItem看起来是order的一个集合属性，它不是聚合根。\n\n另外聚合根之间的影响，是通过领域事件来驱动的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587040465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1816553,"avatar":"","nickname":"Geek_1281f4","note":"","ucode":"7C9EB7D812473E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236093,"discussion_content":"谢谢肖老师，可能我还需要深入一下DDD了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587053217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186011,"user_name":"SuperSnow","can_delete":false,"product_type":"c3","uid":1065351,"ip_address":"","ucode":"84C89AA8083E6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","comment_is_top":false,"comment_ctime":1583742206,"is_pvip":false,"replies":[{"id":72458,"content":"对于单例是没有问题的，因为只会创建一个实例。\n但对于瞬时服务，每次你请求获取它就会创建一个，如果是IDisposable的，就意味着这些实例会积累在根容器，直到应用程序退出，这种情况是可怕的。","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1584242009,"ip_address":"","comment_id":186011,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"在根容器中无非就是启动时创建了一个对象，程序停止时释放对象，也谈不上多可怕吧。除非中间件请求中创建对象，那就非常可怕了。是吧。","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486583,"discussion_content":"对于单例是没有问题的，因为只会创建一个实例。\n但对于瞬时服务，每次你请求获取它就会创建一个，如果是IDisposable的，就意味着这些实例会积累在根容器，直到应用程序退出，这种情况是可怕的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584242009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185600,"user_name":"快乐神","can_delete":false,"product_type":"c3","uid":1901362,"ip_address":"","ucode":"48C61BADB08A7A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/03/32/910bcb3e.jpg","comment_is_top":false,"comment_ctime":1583641841,"is_pvip":false,"replies":[{"id":72469,"content":"程序退出时会释放根容器中的实例","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1584243693,"ip_address":"","comment_id":185600,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"scope\\Transient 注册，在子容器中创建实例，会自动释放，那当程序退出时怎么又释放了一次？","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486433,"discussion_content":"程序退出时会释放根容器中的实例","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584243693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200925,"discussion_content":"那是在根容器中创建的，当然是程序退出时释放了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583741728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171794,"user_name":"null","can_delete":false,"product_type":"c3","uid":1274609,"ip_address":"","ucode":"F07FCCF6552F1C","user_header":"https://static001.geekbang.org/account/avatar/00/13/72/f1/3d7460bb.jpg","comment_is_top":false,"comment_ctime":1579013972,"is_pvip":false,"replies":[{"id":66725,"content":"实际上应用程序退出时，程序申请的内存会释放，但如果IDisposeable的对象未被主动调用Dispose，可能会因为一些原因，该组件某些工作未处理完成，造成异常，例如日志记录器队列里的日志可能就丢失了。\n因此对于IDisposeable的对象，一定要定义并管理好它的生命周期，让程序退出更优雅。","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1579091369,"ip_address":"","comment_id":171794,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"老师好，视频中提到，自己创建的实体，注册为单列，应用程序退出也不会释放，最后是等GC回收吗？延伸一下如果是非托管资源能否注册为单列呢？比如说日志文件流，这种是否会出现应用程序退出也不会释放，GC也不会回收的永久占用呢？","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481511,"discussion_content":"实际上应用程序退出时，程序申请的内存会释放，但如果IDisposeable的对象未被主动调用Dispose，可能会因为一些原因，该组件某些工作未处理完成，造成异常，例如日志记录器队列里的日志可能就丢失了。\n因此对于IDisposeable的对象，一定要定义并管理好它的生命周期，让程序退出更优雅。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579091369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229226,"user_name":"胡晗","can_delete":false,"product_type":"c3","uid":2043889,"ip_address":"","ucode":"47291A5D08FC5B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ZJdH4WibYqvK4fRyk2KqibJicDqlXsCsWJLcNEvQjrKmkBcLVFJWlj2IH5ZiczFFSbHm5ibydtLKngFl0RicicSL5lhg/132","comment_is_top":false,"comment_ctime":1592926594,"is_pvip":false,"replies":[{"id":86012,"content":"db一般是scope，因为它用完需要释放还给连接池，容器可以帮你释放，service、repository也是scope，因为它们依赖db\n单例模式仅在明确需要全局共享一个实例时使用","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1594223474,"ip_address":"","comment_id":229226,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"老师你好，我想问一下Singleton、Scoped、Transient三种生命周期注入的时候应该怎么选择，比如说我在注入DB的时候是使用Singleton还是Scoped，亦或是在注入service和repository是该怎么选择呢。望老师解惑","like_count":0,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499387,"discussion_content":"db一般是scope，因为它用完需要释放还给连接池，容器可以帮你释放，service、repository也是scope，因为它们依赖db\n单例模式仅在明确需要全局共享一个实例时使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594223474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224756,"user_name":"小喵喵","can_delete":false,"product_type":"c3","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1591530632,"is_pvip":false,"replies":[{"id":83291,"content":"没认真看课程吧","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1591950384,"ip_address":"","comment_id":224756,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"请教下老师：根容器，子容器，容器有什么区别呢？","like_count":0,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497598,"discussion_content":"没认真看课程吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591950384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219934,"user_name":"Geek_ee4d86","can_delete":false,"product_type":"c3","uid":2013090,"ip_address":"","ucode":"983008639F0C44","user_header":"","comment_is_top":false,"comment_ctime":1590120172,"is_pvip":false,"replies":[{"id":81333,"content":"释放的时机与注册的生命周期有关，也与使用哪个容器有关，根容器、子容器对不同生命周期，行为不同","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1590235482,"ip_address":"","comment_id":219934,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"释放的时机是不是跟注册在哪个容器相关，而不是获取服务时使用的哪个容器相关？","like_count":0,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496000,"discussion_content":"释放的时机与注册的生命周期有关，也与使用哪个容器有关，根容器、子容器对不同生命周期，行为不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590235482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217314,"user_name":"小北","can_delete":false,"product_type":"c3","uid":1636642,"ip_address":"","ucode":"6559C3F6345A70","user_header":"https://static001.geekbang.org/account/avatar/00/18/f9/22/9f7190f8.jpg","comment_is_top":false,"comment_ctime":1589463978,"is_pvip":false,"replies":[{"id":80573,"content":"将自己创建的对象丢进容器中，实指注册时直接将实例给容器，在Scoped和Transient模式下，你是不是通过工厂方法注册进去的？这种情况，容器仍然认为实例是由容器构造的","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1589681981,"ip_address":"","comment_id":217314,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"对于单例模式，如果是将自己创建的对象丢进容器中，容器是不会帮我们进行释放的。\n但是我发现，在Scoped和Transient模式下，将自己的对象丢进容器中。还是会进行释放的，这是为甚么？","like_count":0,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495108,"discussion_content":"将自己创建的对象丢进容器中，实指注册时直接将实例给容器，在Scoped和Transient模式下，你是不是通过工厂方法注册进去的？这种情况，容器仍然认为实例是由容器构造的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589681981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211156,"user_name":"三人游","can_delete":false,"product_type":"c3","uid":1323576,"ip_address":"","ucode":"0E22B9CEF99F78","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep5UuuSVCMz7ic9RyI5WHTqzYhlD0Zq8ibAwd0icHERqDTlBgSegF7RmicWtNFcibjKBSTkBpVbrC5EFqA/132","comment_is_top":false,"comment_ctime":1587906317,"is_pvip":false,"replies":[{"id":79653,"content":"当前的请求就已经结束了，那么Dbcontext会被Dispose，你新线程中savechanges的时候它的连接实际上被释放了，因此报错了","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1588942817,"ip_address":"","comment_id":211156,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"肖老师，请问下Dbcontext的生命周期为scope，在请求的方法中新建一个线程，然后在新建的线程中调用savechanges方法，抛出异常对象被释放掉，请问下具体原因","like_count":0,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493208,"discussion_content":"当前的请求就已经结束了，那么Dbcontext会被Dispose，你新线程中savechanges的时候它的连接实际上被释放了，因此报错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588942817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209643,"user_name":"提姆","can_delete":false,"product_type":"c3","uid":1103960,"ip_address":"","ucode":"F2A339CC9AC594","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/58/1f5f7aed.jpg","comment_is_top":false,"comment_ctime":1587578727,"is_pvip":false,"replies":[{"id":79642,"content":"是这样的","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1588940057,"ip_address":"","comment_id":209643,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100044601,"comment_content":"老师您好\n关于一个老师之前回覆问题的回答有提到\n&lt;对于实现了IDisposable的服务，要避免在跟容器以瞬时服务的方式获取\n对于没有实现IDisposable的服务，是没有关系的&gt;\n想请问一下，\n对于没有实现IDisposable的服务，是没有关系的=&gt;没有关系的原因是因为最后是交由GC处理吗？","like_count":0,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492846,"discussion_content":"是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588940057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190453,"user_name":"小鱼儿","can_delete":false,"product_type":"c3","uid":1198393,"ip_address":"","ucode":"4CA76D96108C0E","user_header":"https://static001.geekbang.org/account/avatar/00/12/49/39/8f1537f5.jpg","comment_is_top":false,"comment_ctime":1584662271,"is_pvip":false,"replies":[{"id":77440,"content":"感谢支持","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1587043415,"ip_address":"","comment_id":190453,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100044601,"comment_content":"对理解net core 生命周期很有帮助","like_count":0,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487984,"discussion_content":"感谢支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587043415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384875,"user_name":"一介农夫","can_delete":false,"product_type":"c3","uid":1231587,"ip_address":"浙江","ucode":"FBDEE48436A542","user_header":"https://static001.geekbang.org/account/avatar/00/12/ca/e3/7e860739.jpg","comment_is_top":false,"comment_ctime":1701709987,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100044601,"comment_content":"现在已经.NET8了，要不要更新下😁","like_count":0},{"had_liked":false,"id":347314,"user_name":"Geek_be8042","can_delete":false,"product_type":"c3","uid":1750066,"ip_address":"","ucode":"030F3FC4861CC3","user_header":"","comment_is_top":false,"comment_ctime":1653918287,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100044601,"comment_content":"老师，长期学习net core 主要看官网吗？","like_count":0},{"had_liked":false,"id":302598,"user_name":"刘超","can_delete":false,"product_type":"c3","uid":1356539,"ip_address":"","ucode":"00F953D30F0A62","user_header":"https://static001.geekbang.org/account/avatar/00/14/b2/fb/fa145af3.jpg","comment_is_top":false,"comment_ctime":1626276373,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100044601,"comment_content":"要点总结：\n1.避免在根容器中获取实现了IDisposable接口的瞬时服务\n2.避免手动创建实现了IDiaposable接口的类对象，应使用容器管理生命周期","like_count":0},{"had_liked":false,"id":290991,"user_name":"每个夜半三点","can_delete":false,"product_type":"c3","uid":2586087,"ip_address":"","ucode":"9165039732B89A","user_header":"https://static001.geekbang.org/account/avatar/00/27/75/e7/79d0e9f0.jpg","comment_is_top":false,"comment_ctime":1619923407,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100044601,"comment_content":"老师的课程很棒，巩固了很多基础，并且把当前主流技术栈拆分开来讲解的特别清楚","like_count":0},{"had_liked":false,"id":290569,"user_name":"Ilearning99","can_delete":false,"product_type":"c3","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1619622683,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100044601,"comment_content":"第一个报错 var s = app.ApplicationServices.GetService&lt;IOrderService&gt;(); 把这个注释掉就好了，这里我不太明白是在干什么","like_count":0},{"had_liked":false,"id":284446,"user_name":"Geek_042e8a","can_delete":false,"product_type":"c3","uid":1944028,"ip_address":"","ucode":"22B648001EC2C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIyNIia6IFvSwtvZLa9jMFuvTGCuyRTFiavshEmaLe0PBFZHdw8OnxibFe50HgXs1JCqFQymPUXqrJIA/132","comment_is_top":false,"comment_ctime":1616251022,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100044601,"comment_content":"托管资源是不是就不需要去继承IDisposable接口，最终都是gc去回收了。不需要手动去释放掉，非托管资源就需要继承IDisposable接口，手动释放资源，并且瞬时的时候不能在更容器去创建，不然不能dispose掉，构造函数注入的服务是属于更容器还是子容器？","like_count":0},{"had_liked":false,"id":258993,"user_name":"Hunter Gu","can_delete":false,"product_type":"c3","uid":2031301,"ip_address":"","ucode":"AE10D3B5233D13","user_header":"https://static001.geekbang.org/account/avatar/00/1e/fe/c5/95238b09.jpg","comment_is_top":false,"comment_ctime":1604591618,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100044601,"comment_content":"二刷视频，温故而知新","like_count":0},{"had_liked":false,"id":205540,"user_name":"Geek_1281f4","can_delete":false,"product_type":"c3","uid":1816553,"ip_address":"","ucode":"7C9EB7D812473E","user_header":"","comment_is_top":false,"comment_ctime":1586667175,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100044601,"comment_content":"肖老师，你好！在研究你课程里的示例遇到一个问题\npublic DomainContext(DbContextOptions options, IMediator mediator, ICapPublisher capBus) : base(options, mediator, capBus)\n示例中的DomainContext相对于默认的ef DBContext多注入了两个参数IMediator mediator, ICapPublisher capBus。\n课程示例中使用services.AddDbContext&lt;DomainContext&gt;(optionsAction) 注册DbContext参数可以正常注入；\n我改成services.AddDbContextPool&lt;DomainContext&gt;(optionsAction)注入，应用程序启动就报错了。\n错误如下：\nSystem.InvalidOperationException: The DbContext of type &#39;DomainContext&#39; cannot be pooled because it does not have a single public constructor accepting a single parameter of type DbContextOptions.\n 从表面上看貌似是AddDbContextPool不支持注入除默认参数以外的参数，不晓得老师遇到过没有，分享一下解决方法。","like_count":0,"discussions":[{"author":{"id":1816553,"avatar":"","nickname":"Geek_1281f4","note":"","ucode":"7C9EB7D812473E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233356,"discussion_content":"已找到解决方法，解决方法参考：https://www.cnblogs.com/CreateMyself/p/12694601.html","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586920020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171669,"user_name":"Mr.Beethoven","can_delete":false,"product_type":"c3","uid":1588862,"ip_address":"","ucode":"199A3814A43DB7","user_header":"https://static001.geekbang.org/account/avatar/00/18/3e/7e/c06badd0.jpg","comment_is_top":false,"comment_ctime":1578988485,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100044601,"comment_content":"666","like_count":0}]}