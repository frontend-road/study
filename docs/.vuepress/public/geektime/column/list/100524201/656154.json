{"id":656154,"title":"38｜归并排序：将多个有序序列按其中的元素值大小两两合并","content":"<p>你好，我是王健伟。</p><p>上节课我们一起学习了选择类排序，回顾前面所讲，你会发现选择类排序的特点是每次从待排序的元素中选择一个最小或最大值，依次放到已经排序的序列末尾，最终得到有序序列。</p><p>而这次，我们学习一下归并排序。归并排序自成一类，它的实现方式和选择类排序不同。</p><p>归并排序，英文名称是Merging Sort。归并排序里的“归并”，也叫合并，其实就是把两个或者多个已经有序的序列合并成一个。简而言之，归并排序采用的是一种分而治之的思想，将待排序的序列不断二分，直到每个子序列只有一个元素，然后将相邻的子序列两两归并，最终得到一个有序的序列。</p><p>下面，我们就一起看一看归并排序都涉及到哪些基本概念。</p><h2>基本概念</h2><p>图1是两个有序序列<span class=\"reference\">（数组）</span>，现在我们希望利用归并排序把这两个数组合并成一个元素按从小到大排序的数组。</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/44/3c5a39c71864f56249830566871a6a44.jpg?wh=1504x275\" alt=\"\" title=\"图1 两个待排序的有序序列（有序数组）\"></p><p>既然要合并，那么首先必然要分配一个足以容纳两个有序数组中所有元素的内存空间，也就是一个新数组，然后进行下面的操作。</p><ol>\n<li>针对每个数组都设置一个指向当前位置的指针（pi、pj、pk），初始状态时，这三根指针都指向数组的起始位置，如图2中的子图1。</li>\n<li>每一次都会对比pi和pj位置所指向的元素值到底哪个更小，把更小的元素放入到pk所指向的位置处。因为1&lt;2，所以把1放入到pk指针所指向的位置处，同时，把pk指针后移一个位置。当然，因为元素1已经被放入到了新数组中，自然pi指针也要后移一个位置，结果如图2中的子图2。</li>\n<li>重复上面第二个步骤，有那么一个时刻，有序序列1中的pi指针已经指向了最后一个元素后面的位置，这意味着有序序列1中的所有元素都被放入到了新数组中，只剩下有序序列2中还有没排好序的元素了，如图2中的子图3所示。</li>\n<li>此时，就不再需要元素大小的对比，直接把有序序列2中剩余的2个元素放入到新数组中，最终归并排序结果如图2中的子图4。</li>\n</ol><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/78/71/78b42b205c455fdaff4989e809d13271.jpg?wh=2590x1629\" alt=\"\" title=\"图2 两个待排序的有序序列进行归并排序的过程\"></p><p>图2其实是一个“2路”归并排序。因为图中是把两个有序序列合并成一个有序序列。在2路归并排序中，每次需要从两个元素中选出一个更小的元素，这只需要对比pi和pj所指向的元素就可以了。或者你可以理解为，只需要对比一次关键词。</p><p>既然有2路归并排序，那么自然可以有多路归并排序，比如3路归并排序、4路归并排序等等。这里注意，多路归并排序一般用于外部排序。图3展示的就是4路归并排序的初始状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/d1/cd17468bd5c593cb0cd252b276494dd1.jpg?wh=1890x785\" alt=\"\" title=\"图3 “4路”归并排序的初始状态\"></p><p>针对图3，如果进行4路归并排序<span class=\"reference\">（对4个有序序列进行归并排序）</span>，那么每选出一个最小元素放入新数组中需要进行3次关键字比较——比如第1次需要比较元素1和2看谁比较小，选择出较小的元素继续与元素42相比看谁比较小，再选出较小的元素与元素28相比。推而广之，对于m路归并排序，每选出一个元素需要进行m-1次关键字的对比。内部排序中通常使用的是2路归并排序。</p><p>那么，回头就要说一说如何对一个具有n个记录的初始序列进行排序了。</p><ul>\n<li>首先，把这个初始序列看成是n个有序的子序列<span class=\"reference\">（n路）</span>，每个子序列的长度为1。</li>\n<li>其次，两两合并<span class=\"reference\">（“2路”归并排序）</span>，得到⌈$\\frac{n}{2}$⌉个长度为2或1的有序子序列，然后再两两合并……直至得到一个长度为n的有序序列为止。</li>\n</ul><p>如图4所示，将16、1、45、23、99、2、18共7个数字进行归并排序：</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/05/1e9a76e38c13489db5b33486yya96e05.jpg?wh=1894x843\" alt=\"\" title=\"图4 对一个具有7个记录的初始序列进行归并排序的过程\"></p><ul>\n<li>第一趟归并排序，将相邻部分两两归并，即16和1归并，45和23归并，99和2归并，18由于只剩下自己了所以不做归并操作。经过这趟归并，得到了4个有序的子序列。</li>\n<li>第二趟归并排序，对第一趟归并排序的结果再次进行两两归并，即[1,16]和[23,45]归并，[2,99]和[18]归并。经过这趟归并，得到了两个有序的子序列。</li>\n<li>第三趟归并排序，对第二趟归并排序的结果再进行两两归并，最终得到了一个排好序的序列。</li>\n</ul><h2>实现代码</h2><p>下面是归并排序的实现代码。</p><pre><code class=\"language-plain\">//2路归并，该函数是归并排序的核心代码，用于把两个有序子序列归并成一个\n//left:指向第一个序列开头元素，mid：指向第一个序列末尾元素，right指向第二个序列末尾元素\n//通过left,mid,right指定要归并的两个子序列的范围（这两个子序列相邻）\ntemplate&lt;typename T&gt;\nvoid Merge(T myarray[], T* pResult, int left, int mid, int right,int length)&nbsp; //length纯用于显示信息目的\n{\n\tcout &lt;&lt;\"Merge()：left,mid,right=\"&lt;&lt; left &lt;&lt;\",\"&lt;&lt; mid &lt;&lt;\",\"&lt;&lt; right;\n\tcout&lt;&lt;\"|元素值begin：\";\n\tfor (int i = 0; i &lt; length; ++i) cout &lt;&lt; myarray[i] &lt;&lt;\"\";\n\t\t\n\t//把myarray指定的left到right范围内的数据先复制到pResult（临时空间）中\n\tfor (int i = left; i &lt;= right; ++i)\n\t{\n\t\tpResult[i] = myarray[i];\n\t} //end for i\n\t\t\n\tint curpos1 = left;&nbsp; &nbsp;//第一个序列的开始元素\n\tint curpos2 = mid + 1; //第二个序列的开始元素\n\tint curpos3 = left;&nbsp; //最终合并好的序列的开始元素位置\n\twhile (curpos1 &lt;= mid &amp;&amp; curpos2 &lt;= right)\n\t{\n\t\tif (pResult[curpos1] &lt;= pResult[curpos2]) //将较小值赋值给myarray，这里的比较符可以保证该算法稳定性\n\t\t{\n\t\t\tmyarray[curpos3] = pResult[curpos1];\n\t\t\tcurpos1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmyarray[curpos3] = pResult[curpos2];\n\t\t\tcurpos2++;\n\t\t}\n\t\tcurpos3++;\n\t} //end while\n\t//如果两个子序列元素数目不同，则这里要单独处理\n\twhile (curpos1 &lt;= mid) //子序列1比子序列2长\n\t{\n\t\t//把子序列1中剩余的内容放入到myarray中去\n\t\tmyarray[curpos3] = pResult[curpos1];\n\t\tcurpos1++;\n\t\tcurpos3++;\n\t}\n\twhile (curpos2 &lt;= right) //子序列2比子序列1长\n\t{\n\t\tmyarray[curpos3] = pResult[curpos2];\n\t\tcurpos2++;\n\t\tcurpos3++;\n\t}\n\t\t\n\tcout &lt;&lt;\"|元素值end：\";\n\tfor (int i = 0; i &lt; length; ++i) cout &lt;&lt; myarray[i] &lt;&lt;\"\";\n\tcout &lt;&lt; endl;\n\treturn;\n}\n\t\n//归并排序重载函数\ntemplate&lt;typename T&gt;\nvoid MergingSort(T myarray[], T* pResult, int left, int right,int length) //length用于显示信息目的\n{\n\tif (left &gt;= right)\n\t\treturn;//递归出口\n\t\n\tint mid = (left + right) / 2; //中间分开\n\tMergingSort(myarray, pResult, left, mid,length); //对左半部分归并排序\n\tMergingSort(myarray, pResult, mid+1, right,length); //对右半部分归并排序\n\t\n\t//上面因为左半部分归并排序完成，右半部分归并排序完成，所以下面是合并左半部分和右半部分了\n\t//开始真正的归并操作\n\tMerge(myarray, pResult, left, mid, right,length);&nbsp;\n}\n\t\n//归并排序入口（从小到大）\ntemplate&lt;typename T&gt;\nvoid MergingSort(T myarray[], int length)\n{\n\tT* pResult = new T[length]; //新数组，用于保存结果\n\tMergingSort(myarray, pResult, 0, length - 1,length); //调用重载函数\n\tdelete[] pResult;\n\treturn;\n}\n</code></pre><p>在main主函数中，对代码做一些调整，下面是调整后的代码。</p><pre><code class=\"language-plain\">int arr[] = { 16,1,45,23,99,2,18,67,42,10 };\nint length = sizeof(arr) / sizeof(arr[0]);&nbsp; &nbsp;//数组中元素个数\nMergingSort(arr, length);//对数组元素进行归并排序\ncout &lt;&lt;\"归并排序结果为：\";\nfor (int i = 0; i &lt; length; ++i)\n{\n\tcout &lt;&lt; arr[i] &lt;&lt;\"\";\n}\ncout &lt;&lt; endl; //换行\n</code></pre><p>代码的执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/a8/ff/a816d2cb0b98609494e9c9b9b8eae3ff.jpg?wh=1998x1346\" alt=\"\"></p><p>从上面的结果，你可以看出一共进行了多少趟归并排序，也能看出每趟归并排序针对的是哪两个序列进行排序的。</p><p>我们再试试让上面一组测试数据减少3个元素，看看归并排序过程和结果：<br>\nint arr[] = { 16,1,45,23,99,2,18 };</p><p>代码的执行结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/83/4c7db318184b81838437284b1723b083.jpg?wh=2000x922\" alt=\"\"></p><p>上述结果正是图4展示的结果。我在结果中用了不同的颜色和字体加粗来标注每趟2路归并排序比较与合并的是哪两个子序列，你可以重点关注一下。</p><p>代码中的核心2路归并函数Merge中用到了3个主要的形参，分别是left、mid、right。因为这些参数是用于进行两个子序列的2路归并，所以left用于指向第一个子序列的开头，mid用于指向第一个子序列的末尾，right用于指向第二个子序列的末尾，这两个子序列当然是紧紧相邻的，如此，通过left、mid、right这三个变量就可以把两个子序列的头尾范围准确地标注出来了，可以参考下图5：</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/02/9d595891e2635d064253f189b08e1f02.jpg?wh=1805x383\" alt=\"\" title=\"图5 归并排序源码中Merge成员函数left、mid、right形参所指向的子序列位置标示\"></p><p>源码中MergingSort重载函数实际上是对左右两半部分递归地进行归并排序。这段代码理解起来稍微有些难度，所以我在输出结果中显示了非常详尽的left、mid、right信息以辅助你理解。</p><h2>复杂度分析</h2><p>图4所示的2路归并排序过程看起来是一棵倒着的二叉树，因此又被称为“归并树”。如果要对n个元素进行排序，把二叉树的高度看成是h，则归并排序的趟数是h-1趟。而二叉树的第h层最多有$2^{h-1}$个节点。因为所有待排序列的节点都会出现在第h层，所以这也是待排序列的节点总数，即h-1 = ⌈$log_{2}^{n}$⌉。也就是说，n个元素进行2路归并排序的趟数是⌈$log_{2}^{n}$⌉。每一趟归并操作的时间复杂度是多少呢？观察一下图2、图4，不难发现是需要将所有n个元素都扫描一次并进行相应对比，所以每一趟归并操作的时间复杂度是O(n)，最后得出结论——归并排序算法的时间复杂度是O(n$log_{2}^{n}$)。</p><p>此外，从上述代码可以看到，归并排序需要额外的辅助空间，辅助空间的大小和原来保存数据的数组大小相同，所以这部分的空间复杂度是O(n)。算法中还用到了递归调用，但递归调用的深度不会超过$log_{2}^{n}$。所以归并排序算法的空间复杂度是O(n+$log_{2}^{n}$)= O(max(n,$log_{2}^{n}$))=O(n)。</p><p>归并排序算法的稳定性受编写代码的影响，上述的代码实现方式得到的归并排序算法是<strong>稳定</strong>的。</p><h2>非递归实现方式</h2><p>归并排序算法的递归实现方式虽然代码看起来简洁，但对于有些朋友可能并不是那么容易理解。在上述参与测试的数组中包含7个数据时，确实如图4所示的两两合并。但当测试数组中包含的是10个数据时，其中的输出中有诸如下面这样的结果行：</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/76/c75d410d0d64813cc1bae14c82e19d76.jpg?wh=2006x160\" alt=\"\"></p><p>上述这行结果表明代码实现中进行的是 [1,16]和[45]做归并，不是人们以为的[1,16]和[45,23]做归并。</p><p>此外，递归调用深度的加深也会引起程序执行效率的下降。也有资料会说当要排序的数据太多时可能会导致栈溢出。栈溢出并不容易，因为刚刚说过，递归调用的深度不会超过$log_{2}^{n}$。但不管怎么说，依旧可以用非递归方式来改写归并排序算法，经过这样的改写后，算法在性能上会有进一步的提高。下述是非递归实现代码：</p><pre><code class=\"language-plain\">//非递归程序编写方法\ntemplate&lt;typename T&gt;\nvoid MergingSort_noRecu(T myarray[], int length)\n{\n\tif (length &lt;= 1) //不超过1个元素的数组，没必要排序\n\t\treturn;\n\t\n\tT* pResult = new T[length]; //新数组，用于保存结果\n\t\n\t//标示两个子序列位置用\n\tint left, mid, right;\n\t\n\tint jianGe = 1;//间隔，开始时元素是紧挨着的两个比较，两个元素之间下标间隔是1\n\tint subseqTotal = length; //当前子序列数量，开始时一个元素算一个子序列\n\tint gbts = 0; //归并趟数\n\twhile (subseqTotal &gt; 1) //只要没有最终合并成1个序列，就一直循环\n\t{\t\n\t\tgbts++;\n\t\tcout &lt;&lt;\"第\"&lt;&lt; gbts &lt;&lt;\"趟归并：----------------\"&lt;&lt; endl;\n\t\t\t\n\t\tfor(int i = 0; i &lt; length; i += (jianGe*2))\n\t\t{&nbsp;\n\t\t\tleft = i;&nbsp;\n\t\t\tmid&nbsp; = left + jianGe - 1;\n\t\t\tif (mid &gt;= length)\n\t\t\t\tbreak; //不行这不合法了\n\t\t\t\t\n\t\t\tright = mid + (mid - left + 1);\n\t\t\tif (right &gt;= length) right = (length-1); //保证right合法\n\t\t\t\t\n\t\t\t//必须保证left,mid,right都是合理值\n\t\t\tif (left &lt;= mid &amp;&amp; right &gt; left &amp;&amp; right &gt; mid)&nbsp;&nbsp;\n\t\t\t{\n\t\t\t\t//肯定是两个序列，能合并\n\t\t\t\tMerge(myarray, pResult, left, mid, right, length);\n\t\t\t\tsubseqTotal--; //两个序列合并成一个，这里自然减少了1\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//不能合并，这次for循环退出\n\t\t\t\tbreak;&nbsp;\n\t\t\t}\n\t\t} //end for i\n\t\tjianGe *= 2;\n\t} //end while\n\t\t\n\tdelete[] pResult;\n\treturn;\n}\n</code></pre><p>在main主函数中，依旧用10个元素的数组做测试，代码如下：</p><pre><code class=\"language-plain\">int arr[] = { 16,1,45,23,99,2,18,67,42,10 };\nint length = sizeof(arr) / sizeof(arr[0]);&nbsp; &nbsp;//数组中元素个数\nMergingSort_noRecu(arr, length);//对数组元素进行归并排序(非递归)\ncout &lt;&lt;\"归并排序结果为：\";\nfor (int i = 0; i &lt; length; ++i)\n{\n\tcout &lt;&lt; arr[i] &lt;&lt;\"\";\n}\ncout &lt;&lt; endl; //换行\n</code></pre><p>代码的执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/25/85/2577790011a028400280a220f222be85.jpg?wh=1802x1456\" alt=\"\"></p><p>针对这个归并排序结果，用图的方式表示如图6所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/96/40/9682798c519de010e609872fd4f36b40.jpg?wh=1810x1170\" alt=\"\" title=\"图6 对一个具有10个记录的初始序列进行非递归归并排序的过程\"></p><h2>小结</h2><p>本节我带你一起学习了一种新的排序算法——归并排序。我首先向你阐述了归并排序的基本概念，然后详细阐述了利用归并排序把两个数组合并成一个元素按从小到大排序的数组所要经过的详细步骤。</p><p>2路归并排序的概念以及多路<span class=\"reference\">（包括3路、4路）</span>归并排序，是每次从两个或者三个、四个元素中选择出一个最小的元素放入排好序的数组中。之后，我也详细阐述了如何对一个具有n个记录的初始序列进行归并排序并给出了详细的实现代码。</p><p>归并排序算法的时间复杂度是O(n$log_{2}^{n}$)。空间复杂度是O(n)。归并排序算法的稳定性受编写代码的影响，我们的代码实现方式得到的归并排序算法是稳定的。</p><p>考虑到前述归并排序算法是采用递归的方式实现的，不太容易理解。所以，在本节的最后，我给出了用非递归的方式实现的归并排序算法的实现代码。</p><p>与选择类排序算法相比，归并排序算法在实现方式、时间复杂度、稳定性方面皆有不同，所以建议你在学习的时候注意比较。</p><h2>思考题</h2><p>已知数组A和数组B，长度分别为m和n，请将数组B合并到数组A中，保证合并后的数组A有序。请尝试实现代码，给出测试范例。</p><p>欢迎你在留言区和我分享成果。如果觉得有所收获，也可以把课程分享给更多的朋友一起学习。我们下节课见！</p>","comments":[]}