{"id":10192,"title":"第25讲 | 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?","content":"<p>今天，我将从内存管理的角度，进一步探索Java虚拟机（JVM）。垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</p><p>今天我要问你的问题是，<span class=\"orange\">谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError？</span></p><h2>典型回答</h2><p>通常可以把JVM内存区域分为下面几个方面，其中，有的区域是以线程为单位，而有的区域则是整个JVM进程唯一的。</p><p>首先，<strong>程序计数器</strong>（PC，Program Counter Register）。在JVM规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。</p><p>第二，<strong>Java虚拟机栈</strong>（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><!-- [[[read_end]]] --><p>前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈。</p><p>栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。</p><p>第三，<strong>堆</strong>（Heap），它是Java内存管理的核心区域，用来放置Java对象实例，几乎所有创建的Java对象实例都是被直接分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定的“Xmx”之类参数就是用来指定最大堆空间等指标。</p><p>理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</p><p>第四，<strong>方法区</strong>（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、字段、方法代码等。</p><p>由于早期的Hotspot JVM实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8中将永久代移除，同时增加了元数据区（Metaspace）。</p><p>第五，<strong>运行时常量池</strong>（Run-Time Constant Pool），这是方法区的一部分。如果仔细分析过反编译的类文件结构，你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</p><p>第六，<strong>本地方法栈</strong>（Native Method Stack）。它和Java虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在Oracle Hotspot JVM中，本地方法栈和Java虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</p><h2>考点分析</h2><p>这是个JVM领域的基础题目，我给出的答案依据的是<a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5\">JVM规范</a>中运行时数据区定义，这也和大多数书籍和资料解读的角度类似。</p><p>JVM内部的概念庞杂，对于初学者比较晦涩，我的建议是在工作之余，还是要去阅读经典书籍，比如我推荐过多次的《深入理解Java虚拟机》。</p><p>今天这一讲作为Java虚拟机内存管理的开篇，我会侧重于：</p><ul>\n<li>\n<p>分析广义上的JVM内存结构或者说Java进程内存结构。</p>\n</li>\n<li>\n<p>谈到Java内存模型，不可避免的要涉及OutOfMemory（OOM）问题，那么在Java里面存在哪些种OOM的可能性，分别对应哪个内存区域的异常状况呢？</p>\n</li>\n</ul><p>注意，具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。我在下面的分析中，还会介绍Oracle Hotspot JVM的部分设计变化。</p><h2>知识扩展</h2><p>首先，为了让你有个更加直观、清晰的印象，我画了一个简单的内存结构图，里面展示了我前面提到的堆、线程栈等区域，并从数量上说明了什么是线程私有，例如，程序计数器、Java栈等，以及什么是Java进程唯一。另外，还额外划分出了直接内存等区域。<br>\n<img src=\"https://static001.geekbang.org/resource/image/36/bc/360b8f453e016cb641208a6a8fb589bc.png?wh=706*494\" alt=\"\"></p><p>这张图反映了实际中Java进程内存占用，与规范中定义的JVM运行时数据区之间的差别，它可以看作是运行时数据区的一个超集。毕竟理论上的视角和现实中的视角是有区别的，规范侧重的是通用的、无差别的部分，而对于应用开发者来说，只要是Java进程在运行时会占用，都会影响到我们的工程实践。</p><p>我这里简要介绍两点区别：</p><ul>\n<li>\n<p>直接内存（Direct Memory）区域，它就是我在<a href=\"http://time.geekbang.org/column/article/8393\">专栏第12讲</a>中谈到的Direct Buffer所直接分配的内存，也是个容易出现问题的地方。尽管，在JVM工程师的眼中，并不认为它是JVM内部内存的一部分，也并未体现JVM内存模型中。</p>\n</li>\n<li>\n<p>JVM本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT Compiler在运行时对热点方法进行编译，就会将编译后的方法储存在Code Cache里面；GC等功能需要运行在本地线程之中，类似部分都需要占用内存空间。这些是实现JVM JIT等功能的需要，但规范中并不涉及。</p>\n</li>\n</ul><p>如果深入到JVM的实现细节，你会发现一些结论似乎有些模棱两可，比如：</p><ul>\n<li>Java对象是不是都创建在堆上的呢？</li>\n</ul><p>我注意到有一些观点，认为通过<a href=\"https://en.wikipedia.org/wiki/Escape_analysis\">逃逸分析</a>，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis\">文档</a>里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><ul>\n<li>目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，Intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，Intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</li>\n</ul><p>接下来，我们来看看什么是OOM问题，它可能在哪些内存区域发生？</p><p>首先，OOM如果通俗点儿说，就是JVM内存不够用了，javadoc中对<a href=\"https://docs.oracle.com/javase/9/docs/api/java/lang/OutOfMemoryError.html\">OutOfMemoryError</a>的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p><p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间，例如：</p><ul>\n<li>\n<p>我在<a href=\"http://time.geekbang.org/column/article/6970\">专栏第4讲</a>的引用机制分析中，已经提到了JVM会去尝试回收软引用指向的对象等。</p>\n</li>\n<li>\n<p>在<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/9f62267e79df/src/java.base/share/classes/java/nio/Bits.java\">java.nio.BIts.reserveMemory()</a> 方法中，我们能清楚的看到，System.gc()会被调用，以清理空间，这也是为什么在大量使用NIO的Direct Buffer之类时，通常建议不要加下面的参数，毕竟是个最后的尝试，有可能避免一定的内存不足问题。</p>\n</li>\n</ul><pre><code>-XX:+DisableExplicitGC\n</code></pre><p>当然，也不是在任何情况下垃圾收集器都会被触发的，比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。</p><p>从我前面分析的数据区的角度，除了程序计数器，其他区域都有可能会因为可能的空间不足发生OutOfMemoryError，简单总结如下：</p><ul>\n<li>\n<p>堆内存不足是最常见的OOM原因之一，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap space”，原因可能千奇百怪，例如，可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小；或者出现JVM处理引用不及时，导致堆积起来，内存无法释放等。</p>\n</li>\n<li>\n<p>而对于Java虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM实际会抛出StackOverFlowError；当然，如果JVM试图去扩展栈空间的的时候失败，则会抛出OutOfMemoryError。</p>\n</li>\n<li>\n<p>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似Intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”。</p>\n</li>\n<li>\n<p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutOfMemoryError: Metaspace”。</p>\n</li>\n<li>\n<p>直接内存不足，也会导致OOM，这个已经<a href=\"http://time.geekbang.org/column/article/8369\">专栏第11讲</a>介绍过。</p>\n</li>\n</ul><p>今天是JVM内存部分的第一讲，算是我们先进行了热身准备，我介绍了主要的内存区域，以及在不同版本Hotspot JVM内部的变化，并且分析了各区域是否可能产生OutOfMemoryError，以及OOME发生的典型情况。</p><h2>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，我在试图分配一个100M bytes大数组的时候发生了OOME，但是GC日志显示，明明堆上还有远不止100M的空间，你觉得可能问题的原因是什么？想要弄清楚这个问题，还需要什么信息呢？</p><p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p><p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>","comments":[{"had_liked":false,"id":14684,"user_name":"I am a psycho","can_delete":false,"product_type":"c1","uid":1103501,"ip_address":"","ucode":"0B65ECADB378C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/8d/7db04ad3.jpg","comment_is_top":false,"comment_ctime":1530596277,"is_pvip":false,"replies":[{"id":"4998","content":"非常不错的总结","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530671295,"ip_address":"","comment_id":14684,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1255661046709","product_id":100006701,"comment_content":"如果仅从jvm的角度来看，要看下新生代和老年代的垃圾回收机制是什么。如果新生代是serial，会默认使用copying算法，利用两块eden和survivor来进行处理。但是默认当遇到超大对象时，会直接将超大对象放置到老年代中，而不用走正常对象的存活次数记录。因为要放置的是一个byte数组，那么必然需要申请连续的空间，当空间不足时，会进行gc操作。这里又需要看老年代的gc机制是哪一种。如果是serial old，那么会采用mark compat，会进行整理，从而整理出连续空间，如果还不够，说明是老年代的空间不够，所谓的堆内存大于100m是新+老共同的结果。如果采用的是cms(concurrent mark sweep)，那么只会标记清理，并不会压缩，所以内存会碎片化，同时可能出现浮游垃圾。如果是cms的话，即使老年代的空间大于100m，也会出现没有连续的空间供该对象使用。","like_count":293,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420091,"discussion_content":"非常不错的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530671295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2355521,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f1/41/76c0758f.jpg","nickname":"君战","note":"","ucode":"A8619A79A5CED9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374405,"discussion_content":"CMS也可以标记整理，可以配置在N次标记清理之后来一次标记整理。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1621168076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043293,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/5d/2467ad6c.jpg","nickname":"木心","note":"","ucode":"538A3B9B214BF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374033,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620976521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14696,"user_name":"Len","can_delete":false,"product_type":"c1","uid":1022767,"ip_address":"","ucode":"53C623CE17973F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/2f/b7a3625e.jpg","comment_is_top":false,"comment_ctime":1530600846,"is_pvip":true,"replies":[{"id":"4978","content":"很好的视角，g1 region之类确实有影响，另外g1还是有年代的概念的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530664763,"ip_address":"","comment_id":14696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"156149423502","product_id":100006701,"comment_content":"从不同的垃圾收集器角度来看：<br><br>首先，数组的分配是需要连续的内存空间的（据说，有个别非主流JVM支持大数组用不连续的内存空间分配🤔）。所以：<br><br>1）对于使用年轻代和老年代来管理内存的垃圾收集器，堆大于 100M，表示的是新生代和老年代加起来总和大于100M，而新生代和老年代各自并没有大于 100M 的连续内存空间。<br><br>进一步，又由于大数组一般直接进入老年代（会跳过对对象的年龄的判断），所以，是否可以认为老年代中没有连续大于 100M 的空间呢。<br><br>2）对于 G1 这种按 region 来管理内存的垃圾收集器，可能的情况是没有多个连续的 region，它们的内存总和大于 100M。<br><br>当然，不管是哪种垃圾收集器以及收集算法，当内存空间不足时，都会触发 GC，只不过，可能 GC 之后，还是没有连续大于 100M 的内存空间，于是 OOM了。<br><br>","like_count":37,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420096,"discussion_content":"很好的视角，g1 region之类确实有影响，另外g1还是有年代的概念的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530664763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14638,"user_name":"石头狮子","can_delete":false,"product_type":"c1","uid":1118031,"ip_address":"","ucode":"3BABB93E552022","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/4f/c75c4889.jpg","comment_is_top":false,"comment_ctime":1530580910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"83134959534","product_id":100006701,"comment_content":"1，新生代大小过小。无法分配足够的内存。同时也老年代过小，导致提升失败。这时系统认为没有足够的空间存放该100M数据。<br>2，栈可以抽象的看成计算资源。堆看成存储资源。计算资源不共享，不会发生线程安全问题。堆资源共享，<br>容易发生线程安全问题。<br>3，JAVA 封装了不同系统的线程模型，结果是在 java 内部有实现了一个通用的 java线程库。所以就需要用户内存来保存线程信息。","like_count":20},{"had_liked":false,"id":60238,"user_name":"夏洛克的救赎","can_delete":false,"product_type":"c1","uid":1021334,"ip_address":"","ucode":"44453DD27A3216","user_header":"https://static001.geekbang.org/account/avatar/00/0f/95/96/0020bd67.jpg","comment_is_top":false,"comment_ctime":1547450306,"is_pvip":false,"replies":[{"id":"23326","content":"简单点处理，可以：<br>先看看永久带给了多大，如果太小，可以适当增大，使用&#39;-XX:MaxPermSize=NNNm&#39;; <br>如果没开启classunloading，可以根据GC选项做配置，例如，如果使用的CMS，可以加上“-XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled”<br><br>通常就能解决问题了，如果还是有问题，那就要看看是不是出现了classloader leak，常见做法如，取Heap dump，然后用类似Eclipse MAT这样的工具，看看有没有不回收的自定义classloader实例之类","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549812766,"ip_address":"","comment_id":60238,"utype":1}],"discussion_count":1,"race_medal":0,"score":"78856861634","product_id":100006701,"comment_content":"Tomcat运行中突然出现java.lang.OutOfMemoryError: PermGen space有什么工具可以排查原因吗？","like_count":18,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436458,"discussion_content":"简单点处理，可以：\n先看看永久带给了多大，如果太小，可以适当增大，使用&amp;#39;-XX:MaxPermSize=NNNm&amp;#39;; \n如果没开启classunloading，可以根据GC选项做配置，例如，如果使用的CMS，可以加上“-XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled”\n\n通常就能解决问题了，如果还是有问题，那就要看看是不是出现了classloader leak，常见做法如，取Heap dump，然后用类似Eclipse MAT这样的工具，看看有没有不回收的自定义classloader实例之类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549812766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18673,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1533542671,"is_pvip":false,"replies":[{"id":"6556","content":"metaspace 默认是自增的，永久带做不到","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1533567050,"ip_address":"","comment_id":18673,"utype":1}],"discussion_count":1,"race_medal":0,"score":"65958052111","product_id":100006701,"comment_content":"老师既然元数据区也存在溢出，那么为什么要用元数据区替换永久代呢，有什么好处吗？","like_count":16,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421625,"discussion_content":"metaspace 默认是自增的，永久带做不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533567050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15211,"user_name":"markin","can_delete":false,"product_type":"c1","uid":1116603,"ip_address":"","ucode":"8E723995489459","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/bb/b88b3ad6.jpg","comment_is_top":false,"comment_ctime":1531012204,"is_pvip":false,"replies":[{"id":"5320","content":"Oracle官网也提供了很多好的文档：<br>虚拟机规范 https:&#47;&#47;docs.oracle.com&#47;javase&#47;specs&#47;jvms&#47;se8&#47;html&#47;index.html<br>诊断指南 https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;technotes&#47;guides&#47;troubleshoot&#47;index.html<br>调优指南 https:&#47;&#47;docs.oracle.com&#47;javase&#47;10&#47;gctuning&#47;<br>Openjdk网站，或者那些感兴趣的邮件列表 http:&#47;&#47;mail.openjdk.java.net&#47;mailman&#47;listinfo<br>YouTube上查查javaone， JVM summit之类<br>回头有必要整理个书单之类<br><br>但这些东西太多了，自己把握一下","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1531324831,"ip_address":"","comment_id":15211,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57365587052","product_id":100006701,"comment_content":"老师，能否跟我们介绍一下您平时获取资料的渠道。比如apache的一些开源项目，官网上就有很丰富的文档。但是我们获取jvm相关文档的渠道少之又少，无非就是博客或者书籍，这些都比较繁杂，并且可能参杂着很多难以识别的错误观点。授人以鱼不如授人以渔，先谢谢老师了。","like_count":14,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420287,"discussion_content":"Oracle官网也提供了很多好的文档：\n虚拟机规范 https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\n诊断指南 https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/index.html\n调优指南 https://docs.oracle.com/javase/10/gctuning/\nOpenjdk网站，或者那些感兴趣的邮件列表 http://mail.openjdk.java.net/mailman/listinfo\nYouTube上查查javaone， JVM summit之类\n回头有必要整理个书单之类\n\n但这些东西太多了，自己把握一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531324831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14612,"user_name":"鸡肉饭饭","can_delete":false,"product_type":"c1","uid":1120632,"ip_address":"","ucode":"89A1A1B3946C2F","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/78/54005251.jpg","comment_is_top":false,"comment_ctime":1530577481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53070185033","product_id":100006701,"comment_content":"我们拿JDK7来说，有可能的原因是JVM的剩余内存有100M，但是它是分在不同年龄代的内存区域。<br><br>因此应当单独的去查看每一块eden，survivor，old的大小，(通过SurvivorRatio知道s和e的比例大小，通过MaxNewSize知道young和old的比例)看看这三块区域是否有超过100M的内存大小。如果没有，就是因为没有一个区域能够再存储一个100M的对象。<br><br>如果有，就可以通过工具查看下，每一块e s o每一块区域剩下的内存空间，如果没有一块内存大小超过100M，便是因为这个原因导致数组分配失败。","like_count":12},{"had_liked":false,"id":14720,"user_name":"爱吃芒果的董先森","can_delete":false,"product_type":"c1","uid":1120129,"ip_address":"","ucode":"19F737EFD32FC0","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/81/b7b07da7.jpg","comment_is_top":false,"comment_ctime":1530617680,"is_pvip":false,"replies":[{"id":"4997","content":"也对，最好综合考虑堆内存结构、gc区别等，后续会讲解","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530671255,"ip_address":"","comment_id":14720,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44480290640","product_id":100006701,"comment_content":"因为给数组分配的是连续地址，而显示的是总的地址，不管是不是连续的。","like_count":10,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420106,"discussion_content":"也对，最好综合考虑堆内存结构、gc区别等，后续会讲解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530671255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14745,"user_name":"tyson","can_delete":false,"product_type":"c1","uid":1110943,"ip_address":"","ucode":"E88F630B53C743","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/9f/3e4e8d46.jpg","comment_is_top":false,"comment_ctime":1530627536,"is_pvip":true,"replies":[{"id":"4977","content":"不错，可能性很多，其实和gc的选择也有关，例如g1 region比较小","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530664586,"ip_address":"","comment_id":14745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31595398608","product_id":100006701,"comment_content":"堆内存100M 包含了新生代(eden+s0+1)和老年代，大对象一般分配在老年代，那么最有可能在分配过程中老年代的空间不足。","like_count":7,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420115,"discussion_content":"不错，可能性很多，其实和gc的选择也有关，例如g1 region比较小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530664586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14664,"user_name":"鹅米豆发","can_delete":false,"product_type":"c1","uid":1017687,"ip_address":"","ucode":"98E8D911EE32DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/57/645159ee.jpg","comment_is_top":false,"comment_ctime":1530588791,"is_pvip":false,"replies":[{"id":"4982","content":"不错，下一章会有更多内存结构细节","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530664974,"ip_address":"","comment_id":14664,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31595359863","product_id":100006701,"comment_content":"可能一，新生代没有足够的连续空间，且不能直接在老年代分配。比如E+S0+S1&gt;100MB，但E&lt;100MB，S0&lt;100MB。\r<br>可能二，大对象直接进入老年代，但老年代也没有足够的连续空间。参数+XX:PretenureSizeThreshold。\r<br>可能三，线程数量太多，导致物理内存不足。\r<br>可能四，直接内存使用太多，导致物理内存不足。","like_count":7,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420083,"discussion_content":"不错，下一章会有更多内存结构细节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530664974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15425,"user_name":"代码狂徒","can_delete":false,"product_type":"c1","uid":1030100,"ip_address":"","ucode":"F5918543E90321","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b7/d4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1531185803,"is_pvip":false,"replies":[{"id":"5311","content":"不是，方法区只是个逻辑概念，永久带和元数据区是具体设计、实现的选择；<br>以前放到永久带，而且永久带内部还有类似intern字符串之类内容；<br>元数据区具体内容和永久带也有区别，文章介绍了；<br>那个图只是个简化示例，8去掉永久带就是了，具体到比较复杂的gc比如g1，就不是这个结构，请看后面讲","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1531321707,"ip_address":"","comment_id":15425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10121120395","product_id":100006701,"comment_content":"老师，您是说方法区就是有永久代？那也就是说方法区在jdk8中已经不存在了？元数据区跟方法区有什么区别呢？那您的图是jdk7的图，有8得图吗？求解","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420382,"discussion_content":"不是，方法区只是个逻辑概念，永久带和元数据区是具体设计、实现的选择；\n以前放到永久带，而且永久带内部还有类似intern字符串之类内容；\n元数据区具体内容和永久带也有区别，文章介绍了；\n那个图只是个简化示例，8去掉永久带就是了，具体到比较复杂的gc比如g1，就不是这个结构，请看后面讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531321707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14934,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1530753393,"is_pvip":true,"replies":[{"id":"5080","content":"嗯，参考我的回复，下一讲中有更多细节，具体堆内结构还是会划分，例如tlab，eden等，可以简单理解，对象分配是试图tlab，太大就eden，还不行就oldgen，所以我们需要的是相应区域有连续空闲","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530893989,"ip_address":"","comment_id":14934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10120687985","product_id":100006701,"comment_content":"老师，关于这篇文章留的问题你可以给个你的答案吗？","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420182,"discussion_content":"嗯，参考我的回复，下一讲中有更多细节，具体堆内结构还是会划分，例如tlab，eden等，可以简单理解，对象分配是试图tlab，太大就eden，还不行就oldgen，所以我们需要的是相应区域有连续空闲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530893989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14772,"user_name":"Steven⁰⁰⁸","can_delete":false,"product_type":"c1","uid":1111138,"ip_address":"","ucode":"0729C9F79B45EC","user_header":"https://static001.geekbang.org/account/avatar/00/10/f4/62/13b54c68.jpg","comment_is_top":false,"comment_ctime":1530662234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10120596826","product_id":100006701,"comment_content":"数组是连续分配的，gc表明有多余100m，但有可能满足不了连续100m的空间，故会报OOME","like_count":2},{"had_liked":false,"id":14642,"user_name":"师志强","can_delete":false,"product_type":"c1","uid":1104267,"ip_address":"","ucode":"9D30EE3BFEDB8A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/8b/76c27279.jpg","comment_is_top":false,"comment_ctime":1530581361,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10120515953","product_id":100006701,"comment_content":"100m的byte数组，一个byte对应一个引用，这样需要100m个的引用，所以需要的栈空间也不会低于100m,而对象的引用是在栈中分配的，(栈和堆加起来估计不低于200m)况且还是数组，对应的那么多引用还需要分配连续的内存空间，堆空间够的话，个人认为可能是栈空间不足造成的","like_count":3,"discussions":[{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229754,"discussion_content":"“100m的byte数组，一个byte对应一个引用，这样需要100m个的引用”，我觉得你对引用是不是有什么误解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586688423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163555,"user_name":"叫啥不行","can_delete":false,"product_type":"c1","uid":1460942,"ip_address":"","ucode":"A84B9B6594BF35","user_header":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","comment_is_top":false,"comment_ctime":1576743235,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5871710531","product_id":100006701,"comment_content":"用的jdk1.8，无论开启还是关闭逃逸分析，使用jmap，对象数量少的时候，堆里面对象数量跟我创建的数量一样。<br>创建对象多的时候，关闭逃逸分析堆内存对象与创建的一样，但是开启后，堆内对象数量就变得很少了，这个是因为什么，有没有大佬能解答一下，谢谢。","like_count":1,"discussions":[{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229738,"discussion_content":"开启了逃逸分析后，可能JIT做了标量替换的优化，具体要看你的代码如何写的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586687735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76258,"user_name":"硅谷居士","can_delete":false,"product_type":"c1","uid":1018463,"ip_address":"","ucode":"BD3D3BA142F280","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/5f/c60d0ffe.jpg","comment_is_top":false,"comment_ctime":1552560196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847527492","product_id":100006701,"comment_content":"老年代碎片化了。需要查看老年代的内存使用状况，对于 CMS 可以间接地看是否打开了每次 CMS GC 以后就立刻做一次碎片整理的开关。","like_count":1},{"had_liked":false,"id":39514,"user_name":"江南豆沙包","can_delete":false,"product_type":"c1","uid":1061596,"ip_address":"","ucode":"4B7833260F9F2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/dc/d3e3847f.jpg","comment_is_top":false,"comment_ctime":1542293759,"is_pvip":false,"replies":[{"id":"15441","content":"直接内存一般会指代 direct buffer那部分，看说话的上下文","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1543194542,"ip_address":"","comment_id":39514,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5837261055","product_id":100006701,"comment_content":"老师，你好。看了文章后查一些资料。都有这段话：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 这里说的本地内存是不是和你文中说的直接内存是一个概念？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429092,"discussion_content":"直接内存一般会指代 direct buffer那部分，看说话的上下文","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543194542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17734,"user_name":"刘p辉","can_delete":false,"product_type":"c1","uid":1114781,"ip_address":"","ucode":"84851C7419474F","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9d/902cd381.jpg","comment_is_top":false,"comment_ctime":1532915339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5827882635","product_id":100006701,"comment_content":"1.首先堆内存是分代的，总的内存超过100M，不能保证新生代，老年代都有足够的内存。<br>2.为对象，数组分配内存需要连续的内存空间，有可能堆的总内存远超过要分配内存大小，但是在即使进行过垃圾回收（标记整理）后还是不存在足够的连续内存空间就会OOM。","like_count":1},{"had_liked":false,"id":17647,"user_name":"Geek_135148","can_delete":false,"product_type":"c1","uid":1112566,"ip_address":"","ucode":"566A4AF4D79C34","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/f6/108eae01.jpg","comment_is_top":false,"comment_ctime":1532834052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5827801348","product_id":100006701,"comment_content":"请问compressed class space区域怎么理解？是metasapce的一部分吗？如果是的话，有些采集工具为何会把它占的大小单独显示出来呢？而不直接显示metaspace的大小呢","like_count":1},{"had_liked":false,"id":16335,"user_name":"一个坏人","can_delete":false,"product_type":"c1","uid":1032305,"ip_address":"","ucode":"4AF05BF008095A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/71/c83d8b15.jpg","comment_is_top":false,"comment_ctime":1531886338,"is_pvip":true,"replies":[{"id":"5677","content":"vm启动或者线程创建就会计算，但不是完全固定值，运行时可调整","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1531902527,"ip_address":"","comment_id":16335,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5826853634","product_id":100006701,"comment_content":"老师好，请教一个问题。JMM 模型中 各种内存分区 是逻辑分区的。JVM会根据参数计算每一块分区的起始地址、结束地址？如果会，什么时候执行这一操作呢？每一块区域有规定的顺序么？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420761,"discussion_content":"vm启动或者线程创建就会计算，但不是完全固定值，运行时可调整","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531902527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14710,"user_name":"boom","can_delete":false,"product_type":"c1","uid":1125117,"ip_address":"","ucode":"9DEEA4AA9DEC38","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/cjXFnTa1znSAGgibxB8ERicodQQRHzsp5hCfUcMM5tcJ111Wb4RDhxWURkcm9Sj3Go9Hba2qzsibaJicI8DUeQgrqQ/132","comment_is_top":false,"comment_ctime":1530613215,"is_pvip":false,"replies":[{"id":"4996","content":"怎么叫都有，看上下文，jsr133 jmm是解决多线程环境一致性，或者可以看做memory ordering model","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530671173,"ip_address":"","comment_id":14710,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5825580511","product_id":100006701,"comment_content":"小白请教一个不相关的问题～java 内存模型跟 jvm内存模型的区别与联系是啥呢～","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420102,"discussion_content":"怎么叫都有，看上下文，jsr133 jmm是解决多线程环境一致性，或者可以看做memory ordering model","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530671173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14662,"user_name":"三口先生","can_delete":false,"product_type":"c1","uid":1117257,"ip_address":"","ucode":"8E8672321FE510","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/49/d71e939d.jpg","comment_is_top":false,"comment_ctime":1530587983,"is_pvip":false,"replies":[{"id":"4999","content":"也对，回答比较简洁，哈哈","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530671340,"ip_address":"","comment_id":14662,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5825555279","product_id":100006701,"comment_content":"堆内存比例设置不合理","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420081,"discussion_content":"也对，回答比较简洁，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530671340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14633,"user_name":"yotsuba1022","can_delete":false,"product_type":"c1","uid":1046507,"ip_address":"","ucode":"F86379D1199F62","user_header":"","comment_is_top":false,"comment_ctime":1530580238,"is_pvip":false,"replies":[{"id":"4994","content":"有合理性，具体情况有几种可能，大对象是可能直接分配在老年代的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530670744,"ip_address":"","comment_id":14633,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5825547534","product_id":100006701,"comment_content":"關於課後練習, 由於Heap是有分代的, 所以可能當前的100M已經超過eden area的大小了, 所以儘管heap size比100M要大, 還是會無法分配內存. 這樣理解對嗎？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420070,"discussion_content":"有合理性，具体情况有几种可能，大对象是可能直接分配在老年代的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530670744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14621,"user_name":"sunlight001","can_delete":false,"product_type":"c1","uid":1126975,"ip_address":"","ucode":"A72C4274D5DE8A","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/3f/fa4ac035.jpg","comment_is_top":false,"comment_ctime":1530578734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5825546030","product_id":100006701,"comment_content":"堆上有空间的划分，新生代和老年代，有可能新生代的空间不够，看到的是老年代的空间，个人猜测😃","like_count":1},{"had_liked":false,"id":14617,"user_name":"未完的歌","can_delete":false,"product_type":"c1","uid":1120377,"ip_address":"","ucode":"828DF6505C3D41","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/79/4ef1c0f5.jpg","comment_is_top":false,"comment_ctime":1530578070,"is_pvip":false,"replies":[{"id":"4995","content":"是的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530670803,"ip_address":"","comment_id":14617,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5825545366","product_id":100006701,"comment_content":"有可能是内存碎片化问题，或者是大对象的内存分配策略问题。<br>需要了解一下积极垃圾收集算法，例如Mark Sweep就会造成内存碎片化问题，另外内存分配策略也是一个关注点。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420067,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530670803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338005,"user_name":"枫林血舞","can_delete":false,"product_type":"c1","uid":2809867,"ip_address":"","ucode":"EE7F6DA78D21EA","user_header":"https://static001.geekbang.org/account/avatar/00/2a/e0/0b/6f667b2c.jpg","comment_is_top":false,"comment_ctime":1647229111,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647229111","product_id":100006701,"comment_content":"首先，数组是需要分配连续的内存空间的，所以在分配空间是，无法分配一段连续的、大小为100MB的内存区域，也会抛OOM；堆区分为新生代、老年代（逻辑堆还包括方法区），正常的对象分配时，是优先分配到新生代的伊甸园区，如果不够，发生一次youngGC，对伊甸园区进行GC，同时对幸存者0区和1区（from区和to区）也执行GC，然后进行分配；但是对于100M这种超大对象，是直接跨过新生代而被分配到老年代的，此时发生了OOM，结果可能是因为老年代的空间也不够。","like_count":0},{"had_liked":false,"id":306377,"user_name":"Ethan New","can_delete":false,"product_type":"c1","uid":2063962,"ip_address":"","ucode":"9CA2EF39E58030","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7e/5a/da39f489.jpg","comment_is_top":false,"comment_ctime":1628519512,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1628519512","product_id":100006701,"comment_content":"关于逃逸分析的问题：从你给出的链接中已经说明了Escape analysis is supported and enabled by default in Java SE 6u23 and later.你怎么说HotSpot JVM没有使用逃逸分析呢？","like_count":0},{"had_liked":false,"id":304258,"user_name":"老友丶","can_delete":false,"product_type":"c1","uid":1196911,"ip_address":"","ucode":"A7EB7D9582BD40","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/6f/bc91f58d.jpg","comment_is_top":false,"comment_ctime":1627307979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627307979","product_id":100006701,"comment_content":"几个不明白的点，方法区和运行时常量池都有字段、方法？常量和string.intern()都是放在常量池，而这个常量池是放在运行时常量池中？","like_count":0},{"had_liked":false,"id":296228,"user_name":"Howard Allen","can_delete":false,"product_type":"c1","uid":1120203,"ip_address":"","ucode":"B68221375B9AF0","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/cb/aa3cb63f.jpg","comment_is_top":false,"comment_ctime":1622818995,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1622818995","product_id":100006701,"comment_content":"有个关于内存回收的问题请教下大佬们。<br>以下两种方式在内存的回收上是否一样，如果不一样，那种方式更好一点<br><br>第一种方式：<br>public void test1() {<br>\t\tList&lt;String&gt; testLst = new ArrayList&lt;&gt;();<br>\t\tfor (int i = 0; i &lt; 10000; i++) {<br>\t\t\t&#47;&#47;testLst = &#47;&#47;从db查询<br>\t\t\t&#47;&#47;处理<br>\t\t}<br>\t}<br><br>第二种方式<br>     public void test2() {<br>\t\tfor (int i = 0; i &lt; 10000; i++) {<br>\t\t\ttestDo(i);<br>\t\t}<br>\t}<br>\t<br>\tpublic void testDo(int idx) {<br>\t\t&#47;&#47; List&lt;String&gt; testLst = 从db查询<br>\t\t&#47;&#47;testLst = &#47;&#47;从db查询<br>\t\t&#47;&#47;处理<br>\t}<br>\t","like_count":0,"discussions":[{"author":{"id":1120203,"avatar":"https://static001.geekbang.org/account/avatar/00/11/17/cb/aa3cb63f.jpg","nickname":"Howard Allen","note":"","ucode":"B68221375B9AF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378363,"discussion_content":"大佬们，等你们讲解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623198861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294106,"user_name":"御风","can_delete":false,"product_type":"c1","uid":1812807,"ip_address":"","ucode":"51C8212BE06364","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg","comment_is_top":false,"comment_ctime":1621763397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621763397","product_id":100006701,"comment_content":"数组需要一段连续的内存空间，而链表不需要，前者更可能引发OOM","like_count":0},{"had_liked":false,"id":293719,"user_name":"时光守护者-基兰","can_delete":false,"product_type":"c1","uid":1554995,"ip_address":"","ucode":"F0B0887B1979D2","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","comment_is_top":false,"comment_ctime":1621504722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621504722","product_id":100006701,"comment_content":"老师，元数据区用的是本地内存吗，所以发生java.lang.OutOfMemoryError: Metaspace是本地内存不够了而不是JVM吗","like_count":0},{"had_liked":false,"id":285890,"user_name":"AluAlu","can_delete":false,"product_type":"c1","uid":1309974,"ip_address":"","ucode":"ACDE9CD9D7B459","user_header":"https://static001.geekbang.org/account/avatar/00/13/fd/16/719fa5c3.jpg","comment_is_top":false,"comment_ctime":1617066325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617066325","product_id":100006701,"comment_content":"数组需要100M的连续内存空间。","like_count":0},{"had_liked":false,"id":282884,"user_name":"前方的灯有点弱","can_delete":false,"product_type":"c1","uid":2058455,"ip_address":"","ucode":"5CEDBCF3DDC991","user_header":"https://static001.geekbang.org/account/avatar/00/1f/68/d7/29025f1f.jpg","comment_is_top":false,"comment_ctime":1615451979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615451979","product_id":100006701,"comment_content":"　直接内存出现OutOfMemoryError的原因是对该区域进行内存分配时，其内存与其他内存加起来超过最大物理内存限制（包括物理的和操作系统级的限制），从而导致OutOfMemoryError。另外，若我们通过参数“-XX:MaxDirectMemorySize”指定了直接内存的最大值，其超过指定的最大值时，也会抛出内存溢出异常。","like_count":0},{"had_liked":false,"id":268150,"user_name":"宋先生","can_delete":false,"product_type":"c1","uid":1642391,"ip_address":"","ucode":"664FFD7EEE2B4F","user_header":"https://static001.geekbang.org/account/avatar/00/19/0f/97/b7d333a0.jpg","comment_is_top":false,"comment_ctime":1608084777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608084777","product_id":100006701,"comment_content":"数组需要连续的空间，总量够但是连续的空间不一定够","like_count":0},{"had_liked":false,"id":264560,"user_name":"IvanYu","can_delete":false,"product_type":"c1","uid":1056236,"ip_address":"","ucode":"C6C6E412E36CB7","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/ec/62fb1270.jpg","comment_is_top":false,"comment_ctime":1606526899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606526899","product_id":100006701,"comment_content":"我在试图分配一个 100M bytes 大数组的时候发生了 OOME，但是 GC 日志显示，明明堆上还有远不止 100M 的空间，你觉得可能问题的原因是什么？<br>应该是gc日志显示的空间不是连续的。而分配空间应该是一段连续的空间。","like_count":0},{"had_liked":false,"id":242127,"user_name":"不会爬树的熊","can_delete":false,"product_type":"c1","uid":1499380,"ip_address":"","ucode":"E417D8D9D5FED2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6Xwdhayv9Jdnee7HfDYSAMTUtMAAVORMhiaN8bIM0QJibrQ5EDqB8o5pWE6FRuaqguwG86o5Gh90ruDw/132","comment_is_top":false,"comment_ctime":1597596522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597596522","product_id":100006701,"comment_content":"JVM 发生OOM的四种情况<br>https:&#47;&#47;www.cnblogs.com&#47;baizhanshi&#47;p&#47;6704731.html?utm_source=itdadao&amp;utm_medium=referral<br><br>附带在定位JVM内存问题的时候可以借助于一些辅助信息","like_count":0},{"had_liked":false,"id":242126,"user_name":"不会爬树的熊","can_delete":false,"product_type":"c1","uid":1499380,"ip_address":"","ucode":"E417D8D9D5FED2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6Xwdhayv9Jdnee7HfDYSAMTUtMAAVORMhiaN8bIM0QJibrQ5EDqB8o5pWE6FRuaqguwG86o5Gh90ruDw/132","comment_is_top":false,"comment_ctime":1597596439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597596439","product_id":100006701,"comment_content":"1、Java堆溢出：heap<br>Java堆内存OOM异常一般会有如下错误信息;<br>java.lang.OutofMemoryError:Java heap space<br>此类错误一般通过Eclipse Memory Analyzer分析OOM时dump的内存快照就能分析出来，到底是由于程序原因导致的内存泄露，还是由于没有估计好JVM内存的大小而导致的内存溢出。<br>Java堆常用的JVM参数：<br>-Xms：初始堆大小，默认值为物理内存的1&#47;64(&lt;1GB)，默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制<br>-Xmx：最大堆大小，默认值为物理内存的1&#47;4(&lt;1GB)，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制<br>-Xmn：年轻代大小(1.4or lator)，此处的大小是（eden + 2 survivor space)，与jmap -heap中显示的New gen是不同的<br> <br>2、栈溢出：stack<br>栈用来存储线程的局部变量表、操作数栈、动态链接、方法出口等信息。请求栈的深度不足时抛出的错误：<br>java.lang.StackOverflowError<br>由于每个线程占的内存大概为1M，因此线程的创建也需要内存空间。操作系统可用内存-Xmx-MaxPermSize即是栈可用的内存，如果申请创建的线程比较多超过剩余内存的时候，也会抛出如下类似错误：<br>java.lang.OutofMemoryError: unable to create new native thread<br>相关的JVM参数有：<br>-Xss: 每个线程的堆栈大小,JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K<br>在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000左右<br><br>3、运行时常量溢出constant<br>运行时常量保存在方法区，存放的主要是编译器生成的各种字面量和符号引用，但是运行期间也可能将新的常量放入池中，比如String类的intern方法<br>如果该区域OOM，错误结果会包含类似下面的信息：<br>java.lang.OutofMemoryError: PermGen space<br>相关的JVM参数有：<br>-XX:PermSize：设置持久代(perm gen)初始值，默认值为物理内存的1&#47;64<br>-XX:MaxPermSize：设置持久代最大值，默认为物理内存的1&#47;4<br><br>4、方法区溢出   directMemory<br>方法区主要存储被虚拟机加载的类信息，如类名、访问修饰符、常量池、字段描述、方法描述等。理论上在JVM启动后该区域大小应该比较稳定，但是目前很多框架，比如Spring和Hibernate等在运行过程中都会动态生成类，因此也存在OOM的风险<br>如果该区域OOM，错误结果会包含类似下面的信息：<br>java.lang.OutofMemoryError: PermGen space<br>","like_count":0},{"had_liked":false,"id":239105,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1596436817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596436817","product_id":100006701,"comment_content":"问题可能是：数组存放需要的是连续的空间，堆上剩余空间虽然大于100M，但是并不是连续的空间","like_count":0},{"had_liked":false,"id":238616,"user_name":"Cooper","can_delete":false,"product_type":"c1","uid":1607867,"ip_address":"","ucode":"D940921B53F1DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/88/bb/f569045d.jpg","comment_is_top":false,"comment_ctime":1596234734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596234734","product_id":100006701,"comment_content":"试图分配一个 100M bytes 大数组的时候发生了 OOME，但是 GC 日志显示，明明堆上还有远不止 100M 的空间，你觉得可能问题的原因是什么<br><br>the memory for Array must be a contiguous memory block. Heap size over 100M does not mean &quot;one memory block&quot; over 100M, that is amount Heap size over 100M. ","like_count":0},{"had_liked":false,"id":235959,"user_name":"Arthur","can_delete":false,"product_type":"c1","uid":1222441,"ip_address":"","ucode":"FF96EEDEBF7E3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/29/977c3280.jpg","comment_is_top":false,"comment_ctime":1595256395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595256395","product_id":100006701,"comment_content":"100M bytes 大数组，因为是个数组，所以需要【连续的】内存空间进行存放，虽然堆上的空间超过100M，但是没有足够大的【连续空间】存放数组，最终导致OOM.","like_count":0},{"had_liked":false,"id":228395,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1592656639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592656639","product_id":100006701,"comment_content":"一直有个疑惑，元数据空间和方法区是不是同一个概念？","like_count":0},{"had_liked":false,"id":227036,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1592271069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592271069","product_id":100006701,"comment_content":"数组需要连续的内存空间，而实际的内存可用空间可能不是连续的","like_count":0},{"had_liked":false,"id":216899,"user_name":"陈龙","can_delete":false,"product_type":"c1","uid":1986330,"ip_address":"","ucode":"06544C6A87EE7C","user_header":"","comment_is_top":false,"comment_ctime":1589364375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589364375","product_id":100006701,"comment_content":"遇到一个问题，我打开一个maven 项目的pom文件，就会出现oom，修改xmx等参数解决不了问题，请问这怎么解决呢","like_count":0},{"had_liked":false,"id":191275,"user_name":"妥协","can_delete":false,"product_type":"c1","uid":1249656,"ip_address":"","ucode":"7201DFE9C12669","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg","comment_is_top":false,"comment_ctime":1584760443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584760443","product_id":100006701,"comment_content":"Java虚拟机栈中的动态链接是指什么","like_count":0},{"had_liked":false,"id":187383,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1584096517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584096517","product_id":100006701,"comment_content":"在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间！不一定吧，会先计算通过回收后，空间是否够。不够的话直接抛出，不用进行回收！","like_count":0},{"had_liked":false,"id":168279,"user_name":"寒溪","can_delete":false,"product_type":"c1","uid":1001970,"ip_address":"","ucode":"67B9F1A1C15A20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/f2/25cfa472.jpg","comment_is_top":false,"comment_ctime":1578041032,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1578041032","product_id":100006701,"comment_content":"回答一下课后问题：<br>1.虽然内存空间充足，但是没有连续内存了。<br>2.数组要求连续内存，没有100M的连续内存所以OOM了<br>3.如果OOM，应该是老年代发生OOM了，大对象是直接分配在老年代的<br><br>还请老师指正，回答是否正确。","like_count":0},{"had_liked":false,"id":164422,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1576985019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576985019","product_id":100006701,"comment_content":"元空间在本地内存中分配，这里的“本地内存”指的是计算机的物理内存吗？","like_count":0},{"had_liked":false,"id":156610,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1574922880,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574922880","product_id":100006701,"comment_content":"思考题:<br>   大数组是需要连续内存空间的, 可能还存在总量够用的内存,但是并不是连续的 所以不可用. ","like_count":0},{"had_liked":false,"id":150963,"user_name":"vaccywen","can_delete":false,"product_type":"c1","uid":1115128,"ip_address":"","ucode":"077FDB50831921","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/f8/f98df0a7.jpg","comment_is_top":false,"comment_ctime":1573635643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573635643","product_id":100006701,"comment_content":"数组需要连续的内存空间，可能是堆内没有100MB连续的内存空间，Eden区放不下，大对象直接进入老年代，同样老年代也没有100MB连续的空间，导致OOM","like_count":0},{"had_liked":false,"id":75350,"user_name":"刘胜","can_delete":false,"product_type":"c1","uid":1251625,"ip_address":"","ucode":"487374D72543E3","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/29/f9490983.jpg","comment_is_top":false,"comment_ctime":1552382092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552382092","product_id":100006701,"comment_content":"不知道，无法解答。可能是超过了jvm默认可以处置的内存的大小了吧？我只能猜了。","like_count":0},{"had_liked":false,"id":68046,"user_name":"Roysatm","can_delete":false,"product_type":"c1","uid":1049199,"ip_address":"","ucode":"B9ACD64AB61861","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/6f/301b1381.jpg","comment_is_top":false,"comment_ctime":1550395880,"is_pvip":false,"replies":[{"id":"24416","content":"这个如果从实现角度，得真正的JVM专家来回答，我没见到过类似错误","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1550594206,"ip_address":"","comment_id":68046,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1550395880","product_id":100006701,"comment_content":"问一个其他问题，如果开启了逃逸分析，栈上分配会不会造成栈溢出","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439488,"discussion_content":"这个如果从实现角度，得真正的JVM专家来回答，我没见到过类似错误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550594206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229743,"discussion_content":"目前的JVM还没实现栈上分配，真要实现了栈上分配，JVM要变化很大了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586687957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58459,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1547085988,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547085988","product_id":100006701,"comment_content":"eden+ 永久代大于100M但是单独的一个不满足100M 所以无法分配足够的内存","like_count":0},{"had_liked":false,"id":28461,"user_name":"jackLee","can_delete":false,"product_type":"c1","uid":1234280,"ip_address":"","ucode":"720304AB76D9FB","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/68/af1682f1.jpg","comment_is_top":false,"comment_ctime":1538095187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538095187","product_id":100006701,"comment_content":"真好","like_count":0},{"had_liked":false,"id":22152,"user_name":"DMETAL","can_delete":false,"product_type":"c1","uid":1118821,"ip_address":"","ucode":"B2341C539BFB26","user_header":"","comment_is_top":false,"comment_ctime":1535512405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535512405","product_id":100006701,"comment_content":"看了深入理解JVM才知道老师讲的真的细致。","like_count":0},{"had_liked":false,"id":21977,"user_name":"一个坏人","can_delete":false,"product_type":"c1","uid":1032305,"ip_address":"","ucode":"4AF05BF008095A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/71/c83d8b15.jpg","comment_is_top":false,"comment_ctime":1535426040,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1535426040","product_id":100006701,"comment_content":"JDK 已经发生了很大变化，Intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，Intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配？？分配在堆上的一个新区域？？不是在新生代也不是在老年代？","like_count":0},{"had_liked":false,"id":19303,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1533773323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533773323","product_id":100006701,"comment_content":"1,堆内存100M 包含了新生代(eden+s0+1)和老年代，大对象一般分配在老年代，那么最有可能在分配过程中老年代的空间不足。<br>2,堆中内存碎片化，没有一块连续的超过100m的空间","like_count":0},{"had_liked":false,"id":18593,"user_name":"杨坤","can_delete":false,"product_type":"c1","uid":1190957,"ip_address":"","ucode":"28E1941C53963D","user_header":"https://static001.geekbang.org/account/avatar/00/12/2c/2d/6f341396.jpg","comment_is_top":false,"comment_ctime":1533475035,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1533475035","product_id":100006701,"comment_content":"堆内存大小+直接内存大小＞总共内存","like_count":0,"discussions":[{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229749,"discussion_content":"堆内存+非堆内存=JVM内存，至于直接内存是否纳入到JVM内存，要自己做实验，并且用top命令等liunx命令看了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586688242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14811,"user_name":"一凡","can_delete":false,"product_type":"c1","uid":1121965,"ip_address":"","ucode":"A9DB6A4F764BBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/ad/ccdc7868.jpg","comment_is_top":false,"comment_ctime":1530672240,"is_pvip":false,"replies":[{"id":"5017","content":"暂时没计划，也许补充一章，Java内容太多，而且据我所知国内公司使用并不多","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530755993,"ip_address":"","comment_id":14811,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1530672240","product_id":100006701,"comment_content":"老师，请问后续的章节里有对lambda的讲解么，这方面看网上的资料实在是很难理解","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420141,"discussion_content":"暂时没计划，也许补充一章，Java内容太多，而且据我所知国内公司使用并不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530755993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14651,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1530583791,"is_pvip":true,"replies":[{"id":"4992","content":"可能之一","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530670132,"ip_address":"","comment_id":14651,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1530583791","product_id":100006701,"comment_content":"我觉得是新生代的空间不足，因为新生代的实际可用大小占新生代总大小的90%，这是由于新生代有Eden+s1+s0组织，实际只用了eden + 1 个s","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420078,"discussion_content":"可能之一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530670132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14643,"user_name":"A张邦卓","can_delete":false,"product_type":"c1","uid":1118295,"ip_address":"","ucode":"9B3717518913DD","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/57/2738687f.jpg","comment_is_top":false,"comment_ctime":1530581829,"is_pvip":false,"replies":[{"id":"4984","content":"差不多，细节再思考下","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530665070,"ip_address":"","comment_id":14643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1530581829","product_id":100006701,"comment_content":"堆中没有100M的连续地址了","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420074,"discussion_content":"差不多，细节再思考下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530665070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14640,"user_name":"四阿哥","can_delete":false,"product_type":"c1","uid":1104580,"ip_address":"","ucode":"3296E89174D370","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/c4/270db3ad.jpg","comment_is_top":false,"comment_ctime":1530581121,"is_pvip":false,"replies":[{"id":"4993","content":"会","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530670671,"ip_address":"","comment_id":14640,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1530581121","product_id":100006701,"comment_content":"后续会到java内存模型吗？之前看了一下jsr133感觉晦涩难懂。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420072,"discussion_content":"会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530670671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14628,"user_name":"wgl","can_delete":false,"product_type":"c1","uid":1028841,"ip_address":"","ucode":"45153113CE108B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b2/e9/f1541957.jpg","comment_is_top":false,"comment_ctime":1530579562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530579562","product_id":100006701,"comment_content":"堆中没有物理地址连续的100M空间了。","like_count":0},{"had_liked":false,"id":14627,"user_name":"Kyle","can_delete":false,"product_type":"c1","uid":1106079,"ip_address":"","ucode":"44198A0BEC5FB2","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/9f/9259a6b9.jpg","comment_is_top":false,"comment_ctime":1530579532,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1530579532","product_id":100006701,"comment_content":"还有就是，大对象会直接分配在老年代。有没可能是老年代大小不够。","like_count":0},{"had_liked":false,"id":14626,"user_name":"Kyle","can_delete":false,"product_type":"c1","uid":1106079,"ip_address":"","ucode":"44198A0BEC5FB2","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/9f/9259a6b9.jpg","comment_is_top":false,"comment_ctime":1530579277,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1530579277","product_id":100006701,"comment_content":"堆里是存放数组实例，栈区里存放数组引用。是不是因为栈区满了。","like_count":0}]}