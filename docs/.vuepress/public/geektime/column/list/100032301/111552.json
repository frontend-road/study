{"id":111552,"title":"06 | 如何处理消费过程中的重复消息？","content":"<p>你好，我是李玥。上节课我们讲了如何确保消息不会丢失，课后我给你留了一个思考题，如果消息重复了怎么办？这节课，我们就来聊一聊如何处理重复消息的问题。</p><p>在消息传递过程中，如果出现传递失败的情况，发送方会执行重试，重试的过程中就有可能会产生重复的消息。对使用消息队列的业务系统来说，如果没有对重复消息进行处理，就有可能会导致系统的数据出现错误。</p><p>比如说，一个消费订单消息，统计下单金额的微服务，如果没有正确处理重复消息，那就会出现重复统计，导致统计结果错误。</p><p>你可能会问，如果消息队列本身能保证消息不重复，那应用程序的实现不就简单了？那有没有消息队列能保证消息不重复呢？</p><h2>消息重复的情况必然存在</h2><p>在MQTT协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：</p><ul>\n<li>\n<p><strong>At most once</strong>: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。</p>\n</li>\n<li>\n<p><strong>At least once</strong>: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。</p>\n</li>\n<li>\n<p><strong>Exactly once</strong>：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。</p>\n</li>\n</ul><!-- [[[read_end]]] --><p>这个服务质量标准不仅适用于MQTT，对所有的消息队列都是适用的。我们现在常用的绝大部分消息队列提供的服务质量都是At least once，包括RocketMQ、RabbitMQ和Kafka 都是这样。也就是说，消息队列很难保证消息不重复。</p><p>说到这儿我知道肯定有的同学会反驳我：“你说的不对，我看过Kafka的文档，Kafka是支持Exactly once的。”我在这里跟这些同学解释一下，你说的没错，Kafka的确是支持Exactly once，但是我讲的也没有问题，为什么呢？</p><p>Kafka支持的“Exactly once”和我们刚刚提到的消息传递的服务质量标准“Exactly once”是不一样的，它是Kafka提供的另外一个特性，Kafka中支持的事务也和我们通常意义理解的事务有一定的差异。在Kafka中，事务和Excactly once主要是为了配合流计算使用的特性，我们在专栏“进阶篇”这个模块中，会有专门的一节课来讲Kafka的事务和它支持的Exactly once特性。</p><p>稍微说一些题外话，Kafka的团队是一个非常善于包装和营销的团队，你看他们很巧妙地用了两个所有人都非常熟悉的概念“事务”和“Exactly once”来包装它的新的特性，实际上它实现的这个事务和Exactly once并不是我们通常理解的那两个特性，但是你深入了解Kafka的事务和Exactly once后，会发现其实它这个特性虽然和我们通常的理解不一样，但确实和事务、Exactly once有一定关系。</p><p>这一点上，我们都要学习Kafka团队。一个优秀的开发团队，不仅要能写代码，更要能写文档，能写Slide（PPT），还要能讲，会分享。对于每个程序员来说，也是一样的。</p><p>我们把话题收回来，继续来说重复消息的问题。既然消息队列无法保证消息不重复，就需要我们的消费代码能够接受“消息是可能会重复的”这一现状，然后，通过一些方法来消除重复消息对业务的影响。</p><h2>用幂等性解决重复消息问题</h2><p>一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备幂等性。</p><p><strong>幂等（Idempotence）</strong> 本来是一个数学上的概念，它是这样定义的：</p><blockquote>\n<p>如果一个函数f(x)满足：f(f(x)) = f(x)，则函数f(x)满足幂等性。</p>\n</blockquote><p>这个概念被拓展到计算机领域，被用来描述一个操作、方法或者服务。一个幂等操作的特点是，<strong>其任意多次执行所产生的影响均与一次执行的影响相同。</strong></p><p>一个幂等的方法，使用同样的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的。所以，对于幂等的方法，不用担心重复执行会对系统造成任何改变。</p><p>我们举个例子来说明一下。在不考虑并发的情况下，“将账户X的余额设置为100元”，执行一次后对系统的影响是，账户X的余额变成了100元。只要提供的参数100元不变，那即使再执行多少次，账户X的余额始终都是100元，不会变化，这个操作就是一个幂等的操作。</p><p>再举一个例子，“将账户X的余额加100元”，这个操作它就不是幂等的，每执行一次，账户余额就会增加100元，执行多次和执行一次对系统的影响（也就是账户的余额）是不一样的。</p><p>如果我们系统消费消息的业务逻辑具备幂等性，那就不用担心消息重复的问题了，因为同一条消息，消费一次和消费多次对系统的影响是完全一样的。也就可以认为，消费多次等于消费一次。</p><p>从对系统的影响结果来说：<strong>At least once + 幂等消费 = Exactly once。</strong></p><p>那么如何实现幂等操作呢？最好的方式就是，<strong>从业务逻辑设计上入手，将消费的业务逻辑设计成具备幂等性的操作。</strong>但是，不是所有的业务都能设计成天然幂等的，这里就需要一些方法和技巧来实现幂等。</p><p>下面我给你介绍几种常用的设计幂等操作的方法：</p><p><strong>1. 利用数据库的唯一约束实现幂等</strong></p><p>例如我们刚刚提到的那个不具备幂等特性的转账的例子：将账户X的余额加100元。在这个例子中，我们可以通过改造业务逻辑，让它具备幂等性。</p><p>首先，我们可以限定，对于每个转账单每个账户只可以执行一次变更操作，在分布式系统中，这个限制实现的方法非常多，最简单的是我们在数据库中建一张转账流水表，这个表有三个字段：转账单ID、账户ID和变更金额，然后给转账单ID和账户ID这两个字段联合起来创建一个唯一约束，这样对于相同的转账单ID和账户ID，表里至多只能存在一条记录。</p><p>这样，我们消费消息的逻辑可以变为：“在转账流水表中增加一条转账记录，然后再根据转账记录，异步操作更新用户余额即可。”在转账流水表增加一条转账记录这个操作中，由于我们在这个表中预先定义了“账户ID转账单ID”的唯一约束，对于同一个转账单同一个账户只能插入一条记录，后续重复的插入操作都会失败，这样就实现了一个幂等的操作。我们只要写一个SQL，正确地实现它就可以了。</p><p>基于这个思路，不光是可以使用关系型数据库，只要是支持类似“INSERT IF NOT EXIST”语义的存储类系统都可以用于实现幂等，比如，你可以用Redis的SETNX命令来替代数据库中的唯一约束，来实现幂等消费。</p><p><strong>2. 为更新的数据设置前置条件</strong></p><p>另外一种实现幂等的思路是，给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。这样，重复执行这个操作时，由于第一次更新数据的时候已经变更了前置条件中需要判断的数据，不满足前置条件，则不会重复执行更新数据操作。</p><p>比如，刚刚我们说过，“将账户X的余额增加100元”这个操作并不满足幂等性，我们可以把这个操作加上一个前置条件，变为：“如果账户X当前的余额为500元，将余额加100元”，这个操作就具备了幂等性。对应到消息队列中的使用时，可以在发消息时在消息体中带上当前的余额，在消费的时候进行判断数据库中，当前余额是否与消息中的余额相等，只有相等才执行变更操作。</p><p>但是，如果我们要更新的数据不是数值，或者我们要做一个比较复杂的更新操作怎么办？用什么作为前置判断条件呢？更加通用的方法是，给你的数据增加一个版本号属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号+1，一样可以实现幂等更新。</p><p><strong>3. 记录并检查操作</strong></p><p>如果上面提到的两种实现幂等方法都不能适用于你的场景，我们还有一种通用性最强，适用范围最广的实现幂等性方法：记录并检查操作，也称为“Token机制或者GUID（全局唯一ID）机制”，实现的思路特别简单：在执行数据更新操作之前，先检查一下是否执行过这个更新操作。</p><p>具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的ID，消费时，先根据这个ID检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。</p><p>原理和实现是不是很简单？其实一点儿都不简单，在分布式系统中，这个方法其实是非常难实现的。首先，给每个消息指定一个全局唯一的ID就是一件不那么简单的事儿，方法有很多，但都不太好同时满足简单、高可用和高性能，或多或少都要有些牺牲。更加麻烦的是，在“检查消费状态，然后更新数据并且设置消费状态”中，三个操作必须作为一组操作保证原子性，才能真正实现幂等，否则就会出现Bug。</p><p>比如说，对于同一条消息：“全局ID为8，操作为：给ID为666账户增加100元”，有可能出现这样的情况：</p><ul>\n<li>\n<p>t0时刻：Consumer A 收到条消息，检查消息执行状态，发现消息未处理过，开始执行“账户增加100元”；</p>\n</li>\n<li>\n<p>t1时刻：Consumer B 收到条消息，检查消息执行状态，发现消息未处理过，因为这个时刻，Consumer A还未来得及更新消息执行状态。</p>\n</li>\n</ul><p>这样就会导致账户被错误地增加了两次100元，这是一个在分布式系统中非常容易犯的错误，一定要引以为戒。</p><p>对于这个问题，当然我们可以用事务来实现，也可以用锁来实现，但是在分布式系统中，无论是分布式事务还是分布式锁都是比较难解决问题。</p><h2>小结</h2><p>这节课我们主要介绍了通过幂等消费来解决消息重复的问题，然后我重点讲了几种实现幂等操作的方法，你可以利用数据库的约束来防止重复更新数据，也可以为数据更新设置一次性的前置条件，来防止重复消息，如果这两种方法都不适用于你的场景，还可以用“记录并检查操作”的方式来保证幂等，这种方法适用范围最广，但是实现难度和复杂度也比较高，一般不推荐使用。</p><p>这些实现幂等的方法，不仅可以用于解决重复消息的问题，也同样适用于，在其他场景中来解决重复请求或者重复调用的问题。比如，我们可以将HTTP服务设计成幂等的，解决前端或者APP重复提交表单数据的问题；也可以将一个微服务设计成幂等的，解决RPC框架自动重试导致的重复调用问题。这些方法都是通用的，希望你能做到触类旁通，举一反三。</p><h2>思考题</h2><p>最后请你想一下，为什么大部分消息队列都选择只提供At least once的服务质量，而不是级别更高的Exactly once呢？欢迎在留言区与我分享讨论。</p><p>感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给你的朋友。</p><p></p>","comments":[{"had_liked":false,"id":120143,"user_name":"微微一笑","can_delete":false,"product_type":"c1","uid":1250327,"ip_address":"","ucode":"CFA7ABE81D0B99","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","comment_is_top":false,"comment_ctime":1564798736,"is_pvip":false,"replies":[{"id":44112,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564800103,"ip_address":"","comment_id":120143,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"解决一个问题，往往会引发别的问题。若消息队列实现了exactly once，会引发的问题有：①消费端在pull消息时，需要检测此消息是否被消费，这个检测机制无疑会拉低消息消费的速度。可以预想到，随着消息的剧增，消费性能势必会急剧下降，导致消息积压；②检查机制还需要业务端去配合实现，若一条消息长时间未返回ack，消息队列需要去回调看下消费结果（这个类似于事物消息的回查机制）。这样就会增加业务端的压力，与很多的未知因素。\n所以，消息队列不实现exactly once，而是at least once + 幂等性，这个幂等性让给我们去处理。","like_count":254},{"had_liked":false,"id":120114,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1564794385,"is_pvip":false,"replies":[{"id":44113,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564800128,"ip_address":"","comment_id":120114,"utype":1}],"discussion_count":13,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"我觉得最重要的原因是消息队列即使做到了Exactly once级别，consumer也还是要做幂等。因为在consumer从消息队列取消息这里，如果consumer消费成功，但是ack失败，consumer还是会取到重复的消息，所以消息队列花大力气做成Exactly once并不能解决业务侧消息重复的问题。","like_count":220,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461214,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564800103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120162,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1564801606,"is_pvip":false,"replies":[{"id":44178,"content":"\n第一个问题，一般来说分库分表也不会有问题，为什么？因为，使用我们的方法，对于一条具体的消息，总是会落到确定的某个库表上，它的重复消息也会落地同样的库表上，所以分库分表不是问题。\n\n第五个问题，有的消息队列会有一个特殊的队列来保存这些总是消费失败的“坏消息”，然后继续消费之后的消息，避免坏消息卡死队列。这种坏消息一般不会是因为网络原因或者消费者死掉导致的，大多都是消息数据本身有问题，消费者的业务逻辑处理不了导致的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564891142,"ip_address":"","comment_id":120162,"utype":1}],"discussion_count":9,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"学习完如何处理消费过程中的重复消息，写下自己的理解，老师有空帮忙看下哦\n1、使用数据库的唯一索引防止消息被重复消费，感觉如果业务系统存在分库分表，消费消息被路由到不同的库或表，还是会存在问题。\n2、为更新的数据设置前置条件，可以在消息中附带属性，比如当前账户的总金额，或者表中多加一个版本号字段，配合数据库行锁，类似乐观锁的概念，Java CAS，比较内存中的旧值是否和预先的旧值相等，如果是替换成新值。存在的问题和1类似。\n3、记录并检查操作，在每个消息中维护一个全局唯一的ID，根据全局唯一ID进行判断消息是否已经被消费。存在的问题，全局唯一ID的实现有一定的复杂度，需要确保检查消费状态、更新数据、以及更新消费状态三个操作原子性，解决方式涉及到分布式锁和分布式事务，并且对高性能、高并发也有一定的影响。\n4、尝试回答下课后习题①设置成Exactly once从消息队列的角度来看，为了确保消息没有被丢失或者重复，队列需采取一定的类似回查的手段，检测消费者是否有收到消息进行处理，在一定程度上会导致队列堆积等一系列问题，并且队列实现的复杂度上升。②从消费者的角度而言，因为消费者端和Broker Service端都是会各自集群，消费者端可能会存在网络抖动，导致Broker Service为了确保消息不丢失和重复，需要一直进行回查类似的操作，但是由于网络问题，导致队列堆积。\n5、有个疑问如果队列的实现是At least once，但是为了确保消息不丢失，Broker Service会进行一定的重试，但是不可能一直重试，如果一直重试失败怎么处理了？","like_count":33,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461203,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564800128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118739,"discussion_content":"但MQ想要做到消息发送Exactly Once, 只靠自己是不够的，必须要consumer的配合。比如需要consumer的ack确认消息收到没有，没收到ack也不重发直到收到ack，没有ack无法确定消息是否只发一次。所以撇开consumer谈Exactly Once是不可能的。\n反过来说，想要consumer接收消息Exactly Once，更需要consumer的确认。\n综上，无论如何，想做到何种Exactly Once都需要consumer的配合，而超时等待ack的代价太大，故At least once是MQ比较现实的实现方式，把保证结果正确的锅扔给consumer。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1578188411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297941,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ce/15/51187703.jpg","nickname":"兜兜","note":"","ucode":"9033348BEF5F5A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350494,"discussion_content":"分布式领域里，由于成功超时的存在，导致很多问题变得棘手","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1613894430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288393,"discussion_content":"ack失败我db应该会回滚数据的吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593740993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1730160,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/O3Uf8dibBnKKzibgEhvvKs9vic0dBavSJzn79fZVtH0AxcUT09bvOAYvr2f7vecmwiao7BBGgE5p8lXHSoBMdmQuBw/132","nickname":"赵","note":"","ucode":"EAC4390FD95EF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296955,"discussion_content":"如果ack在网络传输时丢失，你应该是不知道失败了吧，所以消息队列认为你还没有消费成功，还会重复拿到这条消息","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596713453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288393,"ip_address":"","group_id":0},"score":296955,"extra":""}]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5503,"discussion_content":"这个回答到根本啦","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566308905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1951729,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQtNOiboVY74YK3rI22kyqwcXZFaiaic1QMNgGiak1uSuxutkVMcicoiacuaahVkia8eDUVUdRQenvr0UTA/132","nickname":"Geek_9b9391","note":"","ucode":"621B5E752C6F74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377014,"discussion_content":"可以把消息消费和ACK放在一个事务中啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622465895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1879262,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ac/de/68f35320.jpg","nickname":"小来子","note":"","ucode":"4EDAF31E43B211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1951729,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQtNOiboVY74YK3rI22kyqwcXZFaiaic1QMNgGiak1uSuxutkVMcicoiacuaahVkia8eDUVUdRQenvr0UTA/132","nickname":"Geek_9b9391","note":"","ucode":"621B5E752C6F74","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380888,"discussion_content":"什么事务? 消息消费是业务，ACK是MQ。 消息表？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624779801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377014,"ip_address":"","group_id":0},"score":380888,"extra":""},{"author":{"id":1252813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","nickname":"徐同学呀","note":"","ucode":"03383EE820514D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1951729,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQtNOiboVY74YK3rI22kyqwcXZFaiaic1QMNgGiak1uSuxutkVMcicoiacuaahVkia8eDUVUdRQenvr0UTA/132","nickname":"Geek_9b9391","note":"","ucode":"621B5E752C6F74","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410341,"discussion_content":"消息消费和ack回应作为一个事务，要么都成功要么都失败，ack不是一个重要的环境，可以最大努力交付重试，但是要是pull时失败呢，很多环境都有可能失败，失败了mq为了保证消息不丢必须有重试机制，有重试就有可能会重复消费。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1635668221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377014,"ip_address":"","group_id":0},"score":410341,"extra":""}]},{"author":{"id":1514292,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/34/4d8c5694.jpg","nickname":"Movan","note":"","ucode":"D5A2E9E2E7A439","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367480,"discussion_content":"思路清奇，牛牛牛","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618372437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181647,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","nickname":"L.","note":"","ucode":"46A2F679C094E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257506,"discussion_content":"这个回答我喜欢\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588580075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303534,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/ee/28a60b35.jpg","nickname":"无名小辈","note":"","ucode":"F3E000D3AB119C","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4414,"discussion_content":"回答的太好了！醍醐灌顶","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565396657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","nickname":"安排","note":"","ucode":"F78CFA9624CAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238967,"discussion_content":"这个回答太好了😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587263505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121682,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1565182123,"is_pvip":false,"replies":[{"id":44753,"content":"确实这个例子解决不了ABA问题，如果要解决这个问题，只能使用版本号的方式。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565238924,"ip_address":"","comment_id":121682,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师好，想问下关于幂等的情况，像设置帐户余额为100元，或者给余额为500的加100，如果有中间状态的变更或者ABA问题，也能算是幂等操作吗？","like_count":29,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461222,"discussion_content":"\n第一个问题，一般来说分库分表也不会有问题，为什么？因为，使用我们的方法，对于一条具体的消息，总是会落到确定的某个库表上，它的重复消息也会落地同样的库表上，所以分库分表不是问题。\n\n第五个问题，有的消息队列会有一个特殊的队列来保存这些总是消费失败的“坏消息”，然后继续消费之后的消息，避免坏消息卡死队列。这种坏消息一般不会是因为网络原因或者消费者死掉导致的，大多都是消息数据本身有问题，消费者的业务逻辑处理不了导致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564891142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","nickname":"猿人谷","note":"","ucode":"85106C7FB14C43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3938,"discussion_content":"rabbitmq有死信队列，可以设置一个重试阈值（如5次），如重试次数超过5次，则可将此消息放入死信队列。一般这种重试超过5次还失败的，即使重试再多次数也不保证成功。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564994277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","nickname":"猿人谷","note":"","ucode":"85106C7FB14C43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7002,"discussion_content":"消息存入死信队列后，是需要自己手动消费重试处理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567250959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3938,"ip_address":"","group_id":0},"score":7002,"extra":""},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375681,"discussion_content":"这样的数据是有问题的，重试多少次估计都没用，应该可以存档做记录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621816103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7002,"ip_address":"","group_id":0},"score":375681,"extra":""}]},{"author":{"id":1340609,"avatar":"https://static001.geekbang.org/account/avatar/00/14/74/c1/28ef0f2d.jpg","nickname":"SHADOWFAX","note":"","ucode":"E4B0750EE09435","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3904,"discussion_content":"有序消费场景，如果前面（如第一笔）存在消费不掉的情况，该笔坏数据存储到特殊队列中，那该笔坏味道消息的后续有序消息（第二、三、四笔）到达该如何处理？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564968138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135159,"avatar":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","nickname":"Vincent","note":"","ucode":"CD8B84A57A6A0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404270,"discussion_content":"第一个问题，我觉得如果出现也是系统设计的大问题，一个消息更新操作涉及的数据在两个不同库里面？比如账户A的账户余额在A  B两个库里面都有值，你怎么保证他们的一致性呢？一般系统设计不会设计成这样子的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634274507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1658796,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4f/ac/80439ba7.jpg","nickname":"Aprelude","note":"","ucode":"840D3F7A35AEEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361020,"discussion_content":"唯一索引要不要加在删除标记上面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616581031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103802,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/ba/d657d286.jpg","nickname":"SuperH~","note":"","ucode":"21929491561C7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310585,"discussion_content":"又见面了启温哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601912142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3791,"discussion_content":"一直重试的话，rabbitmq中有个死信队列的概念，可以解决这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564812987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123958,"user_name":"年年","can_delete":false,"product_type":"c1","uid":1040847,"ip_address":"","ucode":"1B75ADD0CD457F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e1/cf/23a33fb4.jpg","comment_is_top":false,"comment_ctime":1565784517,"is_pvip":false,"replies":[{"id":45709,"content":"感谢支持！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565916406,"ip_address":"","comment_id":123958,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"这课买的太值了，是本平台最吸引我的一门课，一口气看了八篇","like_count":24,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461902,"discussion_content":"确实这个例子解决不了ABA问题，如果要解决这个问题，只能使用版本号的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565238924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1187483,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/9b/397e8fa1.jpg","nickname":"Canon","note":"","ucode":"411FF465C3A3E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601177,"discussion_content":"评论区也可以学到知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675127686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120158,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1564801192,"is_pvip":false,"replies":[{"id":44176,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564890428,"ip_address":"","comment_id":120158,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"我的理解如下：\n1、按照您给的公式：At least once + 幂等消费 = Exactly once，所以对于消息队列来讲，要做到Exactly once，其实是需消费端的共同配合（幂等消费）才可完成，消息队列基本只提供At least once的实现；\n2、从给的几种幂等消费的方案看，需要引入数据库、条件更新、分布式事务或锁等额外辅助，消息队列如果需要保障Exactly once，会导致消费端代码侵入，例如需要消费端增加消息队列用来处理幂等的client端，而消费端的形态可是太多了，兼容适配工作量巨大。故这个Exactly once留给用户自己处理，并且具有选择权，毕竟不是所有业务场景都需要Exactly once，例如老师讲的机房温度上报的案例。","like_count":19,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461219,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564890428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120082,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1564785908,"is_pvip":false,"replies":[{"id":44108,"content":"A1：主要是出于性能考虑。\n\nA2：大部分消息队列在实现的时候，都是批量收发的，但是，采用基于位置的确认机制，是可以保证顺序的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564799586,"ip_address":"","comment_id":120082,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"    对于老师说的为何都是支持At least once:是不是与以下几种情况相关；不对之处还望老师指出，因为我是刚好最近有时会有些异常数据联想到的也算是学习此课的初衷之一。\n    1.硬件异常或者系统异常导致的数据丢失：这里想咨询老师一下，消息队列为何不能做成像数据库一样的用undo log和redo log去避免硬件的这种异常。\n    2.就像为何网络协议中一样TCP和UDP的区别：消息反馈可能不是每一个反馈一次，有时是一批反馈异常，传输中可能会出现丢包或者顺序不一致。\n          最近几个刚好同时在学：刘超老师的网络协议、操作系统以及您的消息队列觉得之间有彼此的关系；能力有限，故而仅仅是猜测，只能通过不断的向各位老师学习才能不断的找出问题提升自己，不足之处还望老师提点-谢谢。","like_count":13,"discussions":[{"author":{"id":1069797,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83er77H7TocrQqc0NsfkNjY4QT9llye3XxbZkIcBuX32RWwf4nA46EFvWaUncxcYZmP8wXMicz2TnkIw/132","nickname":"sum","note":"","ucode":"5058D2F417AA82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69455,"discussion_content":"对于这个问题存疑。undo log 是为了回滚，redo log是为了做持久化。对应消息系统一般没有回滚这个概念，也就没有undo log， redo log在消息系统实现中，一般叫commit log。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575288616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461196,"discussion_content":"A1：主要是出于性能考虑。\n\nA2：大部分消息队列在实现的时候，都是批量收发的，但是，采用基于位置的确认机制，是可以保证顺序的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564799586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187089,"user_name":"李先生","can_delete":false,"product_type":"c1","uid":1237614,"ip_address":"","ucode":"D9039715F7D290","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/6e/0a300829.jpg","comment_is_top":false,"comment_ctime":1584010036,"is_pvip":false,"replies":[{"id":72239,"content":"你说的这个情况确实是这样，但10s（或者更长时间）之后再出现一个重复ID的情况是非常罕见的，所以也就无所谓的。\n\n其实，很多工程上解决问题的方法，理论上都存在缺陷。比如几乎所有一致性算法都解决不了拜占庭将军问题，很多分布式事务理论也不能保证所有情况下的数据一致性。\n\n但这些方法确实能解决实际问题，这才是我们需要关注的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1584063489,"ip_address":"","comment_id":187089,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"我有个疑问，如果使用redis来实现幂等，那么在redis中设置的唯一id肯定要设置失效时间的。比如失效时间设置为10s，在这10s之内可以保证拥有唯一id的消息只被消费一次。那么10s之后又出现一个相同的唯一id，由于redis中这个唯一id已经失效，这个消息将再次被消费。这种如何处理呢？","like_count":12,"discussions":[{"author":{"id":1069797,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83er77H7TocrQqc0NsfkNjY4QT9llye3XxbZkIcBuX32RWwf4nA46EFvWaUncxcYZmP8wXMicz2TnkIw/132","nickname":"sum","note":"","ucode":"5058D2F417AA82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69455,"discussion_content":"对于这个问题存疑。undo log 是为了回滚，redo log是为了做持久化。对应消息系统一般没有回滚这个概念，也就没有undo log， redo log在消息系统实现中，一般叫commit log。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575288616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461196,"discussion_content":"A1：主要是出于性能考虑。\n\nA2：大部分消息队列在实现的时候，都是批量收发的，但是，采用基于位置的确认机制，是可以保证顺序的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564799586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120065,"user_name":"a、","can_delete":false,"product_type":"c1","uid":1532404,"ip_address":"","ucode":"590FE8DB111492","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","comment_is_top":false,"comment_ctime":1564768354,"is_pvip":false,"replies":[{"id":44107,"content":"架构设计就是在取舍之间选择最合适的实现方式。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564799395,"ip_address":"","comment_id":120065,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"因为目前消息队列，在发送消息给客户端的时候，一般需要客户端ack之后才能确定，这条消息是不是真的被消费了。\n1.如果客户端设置的是自动ack，那么mq就能保证只发送一次，但是这样会因为客户端消费消息不成功，而导致消息丢失\n2.如果客户端都设置手动ack，这样又有一个问题，如果mq发送消息给客户端成功了，客户端也已经消费完成了，就在准备ack的时候，和mq失去了联系，这时候mq是不知道，这条消息是否真的被消费了，只能选择重发消息。\n所以我觉得:如果消息队列保证了只发一次，那么消息队列就无法保证消息由于客户端消费失败而不丢失，就好像分布式系统中的cap理论，只能保证其中的两种，而无法三个都保证。","like_count":12,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486985,"discussion_content":"你说的这个情况确实是这样，但10s（或者更长时间）之后再出现一个重复ID的情况是非常罕见的，所以也就无所谓的。\n\n其实，很多工程上解决问题的方法，理论上都存在缺陷。比如几乎所有一致性算法都解决不了拜占庭将军问题，很多分布式事务理论也不能保证所有情况下的数据一致性。\n\n但这些方法确实能解决实际问题，这才是我们需要关注的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584063489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237614,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e2/6e/0a300829.jpg","nickname":"李先生","note":"","ucode":"D9039715F7D290","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209788,"discussion_content":"谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584672489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142949,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571596185,"is_pvip":false,"replies":[{"id":55259,"content":"这个情况不需要配置多个消费组，只要主题中配置了多个分区，同一个消费组内也会出现这种情况。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571621268,"ip_address":"","comment_id":142949,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"文中有句话想跟老师确认下，如下:\n\n”t0 时刻：Consumer A 收到条消息，检查消息执行状态，发现消息未处理过，开始执行“账户增加 100 元”；\n\nt1 时刻：Consumer B 收到条消息，检查消息执行状态，发现消息未处理过，因为这个时刻，Consumer A 还未来得及更新消息执行状态。”\n\n1.这是因为每个队列配置多个消费组导致的吧？\n2.通常情况下配置多个消费组是为了提升消费能力？\n3.如果配置多个消费组是为了提升消费能力，那么为什么每个消费组配置多个消费者？反正每个消费组只有一个消费者能成功消费到消息。每个消费组只配置一个消费者不行吗？","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461189,"discussion_content":"架构设计就是在取舍之间选择最合适的实现方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564799395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7006,"discussion_content":"哈哈，谢谢你回答了我的 消息手动提交和自动提交的区别，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567251494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120143,"user_name":"微微一笑","can_delete":false,"product_type":"c1","uid":1250327,"ip_address":"","ucode":"CFA7ABE81D0B99","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","comment_is_top":false,"comment_ctime":1564798736,"is_pvip":false,"replies":[{"id":44112,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564800103,"ip_address":"","comment_id":120143,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"解决一个问题，往往会引发别的问题。若消息队列实现了exactly once，会引发的问题有：①消费端在pull消息时，需要检测此消息是否被消费，这个检测机制无疑会拉低消息消费的速度。可以预想到，随着消息的剧增，消费性能势必会急剧下降，导致消息积压；②检查机制还需要业务端去配合实现，若一条消息长时间未返回ack，消息队列需要去回调看下消费结果（这个类似于事物消息的回查机制）。这样就会增加业务端的压力，与很多的未知因素。\n所以，消息队列不实现exactly once，而是at least once + 幂等性，这个幂等性让给我们去处理。","like_count":254,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461214,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564800103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120114,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1564794385,"is_pvip":false,"replies":[{"id":44113,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564800128,"ip_address":"","comment_id":120114,"utype":1}],"discussion_count":13,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"我觉得最重要的原因是消息队列即使做到了Exactly once级别，consumer也还是要做幂等。因为在consumer从消息队列取消息这里，如果consumer消费成功，但是ack失败，consumer还是会取到重复的消息，所以消息队列花大力气做成Exactly once并不能解决业务侧消息重复的问题。","like_count":220,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461203,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564800128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118739,"discussion_content":"但MQ想要做到消息发送Exactly Once, 只靠自己是不够的，必须要consumer的配合。比如需要consumer的ack确认消息收到没有，没收到ack也不重发直到收到ack，没有ack无法确定消息是否只发一次。所以撇开consumer谈Exactly Once是不可能的。\n反过来说，想要consumer接收消息Exactly Once，更需要consumer的确认。\n综上，无论如何，想做到何种Exactly Once都需要consumer的配合，而超时等待ack的代价太大，故At least once是MQ比较现实的实现方式，把保证结果正确的锅扔给consumer。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1578188411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297941,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ce/15/51187703.jpg","nickname":"兜兜","note":"","ucode":"9033348BEF5F5A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350494,"discussion_content":"分布式领域里，由于成功超时的存在，导致很多问题变得棘手","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1613894430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288393,"discussion_content":"ack失败我db应该会回滚数据的吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593740993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1730160,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/O3Uf8dibBnKKzibgEhvvKs9vic0dBavSJzn79fZVtH0AxcUT09bvOAYvr2f7vecmwiao7BBGgE5p8lXHSoBMdmQuBw/132","nickname":"赵","note":"","ucode":"EAC4390FD95EF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296955,"discussion_content":"如果ack在网络传输时丢失，你应该是不知道失败了吧，所以消息队列认为你还没有消费成功，还会重复拿到这条消息","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596713453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288393,"ip_address":"","group_id":0},"score":296955,"extra":""}]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5503,"discussion_content":"这个回答到根本啦","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566308905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1951729,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQtNOiboVY74YK3rI22kyqwcXZFaiaic1QMNgGiak1uSuxutkVMcicoiacuaahVkia8eDUVUdRQenvr0UTA/132","nickname":"Geek_9b9391","note":"","ucode":"621B5E752C6F74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377014,"discussion_content":"可以把消息消费和ACK放在一个事务中啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622465895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1879262,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ac/de/68f35320.jpg","nickname":"小来子","note":"","ucode":"4EDAF31E43B211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1951729,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQtNOiboVY74YK3rI22kyqwcXZFaiaic1QMNgGiak1uSuxutkVMcicoiacuaahVkia8eDUVUdRQenvr0UTA/132","nickname":"Geek_9b9391","note":"","ucode":"621B5E752C6F74","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380888,"discussion_content":"什么事务? 消息消费是业务，ACK是MQ。 消息表？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624779801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377014,"ip_address":"","group_id":0},"score":380888,"extra":""},{"author":{"id":1252813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","nickname":"徐同学呀","note":"","ucode":"03383EE820514D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1951729,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQtNOiboVY74YK3rI22kyqwcXZFaiaic1QMNgGiak1uSuxutkVMcicoiacuaahVkia8eDUVUdRQenvr0UTA/132","nickname":"Geek_9b9391","note":"","ucode":"621B5E752C6F74","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410341,"discussion_content":"消息消费和ack回应作为一个事务，要么都成功要么都失败，ack不是一个重要的环境，可以最大努力交付重试，但是要是pull时失败呢，很多环境都有可能失败，失败了mq为了保证消息不丢必须有重试机制，有重试就有可能会重复消费。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1635668221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377014,"ip_address":"","group_id":0},"score":410341,"extra":""}]},{"author":{"id":1514292,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/34/4d8c5694.jpg","nickname":"Movan","note":"","ucode":"D5A2E9E2E7A439","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367480,"discussion_content":"思路清奇，牛牛牛","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618372437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181647,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","nickname":"L.","note":"","ucode":"46A2F679C094E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257506,"discussion_content":"这个回答我喜欢\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588580075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303534,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/ee/28a60b35.jpg","nickname":"无名小辈","note":"","ucode":"F3E000D3AB119C","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4414,"discussion_content":"回答的太好了！醍醐灌顶","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565396657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","nickname":"安排","note":"","ucode":"F78CFA9624CAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238967,"discussion_content":"这个回答太好了😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587263505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120162,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1564801606,"is_pvip":false,"replies":[{"id":44178,"content":"\n第一个问题，一般来说分库分表也不会有问题，为什么？因为，使用我们的方法，对于一条具体的消息，总是会落到确定的某个库表上，它的重复消息也会落地同样的库表上，所以分库分表不是问题。\n\n第五个问题，有的消息队列会有一个特殊的队列来保存这些总是消费失败的“坏消息”，然后继续消费之后的消息，避免坏消息卡死队列。这种坏消息一般不会是因为网络原因或者消费者死掉导致的，大多都是消息数据本身有问题，消费者的业务逻辑处理不了导致的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564891142,"ip_address":"","comment_id":120162,"utype":1}],"discussion_count":9,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"学习完如何处理消费过程中的重复消息，写下自己的理解，老师有空帮忙看下哦\n1、使用数据库的唯一索引防止消息被重复消费，感觉如果业务系统存在分库分表，消费消息被路由到不同的库或表，还是会存在问题。\n2、为更新的数据设置前置条件，可以在消息中附带属性，比如当前账户的总金额，或者表中多加一个版本号字段，配合数据库行锁，类似乐观锁的概念，Java CAS，比较内存中的旧值是否和预先的旧值相等，如果是替换成新值。存在的问题和1类似。\n3、记录并检查操作，在每个消息中维护一个全局唯一的ID，根据全局唯一ID进行判断消息是否已经被消费。存在的问题，全局唯一ID的实现有一定的复杂度，需要确保检查消费状态、更新数据、以及更新消费状态三个操作原子性，解决方式涉及到分布式锁和分布式事务，并且对高性能、高并发也有一定的影响。\n4、尝试回答下课后习题①设置成Exactly once从消息队列的角度来看，为了确保消息没有被丢失或者重复，队列需采取一定的类似回查的手段，检测消费者是否有收到消息进行处理，在一定程度上会导致队列堆积等一系列问题，并且队列实现的复杂度上升。②从消费者的角度而言，因为消费者端和Broker Service端都是会各自集群，消费者端可能会存在网络抖动，导致Broker Service为了确保消息不丢失和重复，需要一直进行回查类似的操作，但是由于网络问题，导致队列堆积。\n5、有个疑问如果队列的实现是At least once，但是为了确保消息不丢失，Broker Service会进行一定的重试，但是不可能一直重试，如果一直重试失败怎么处理了？","like_count":33,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461222,"discussion_content":"\n第一个问题，一般来说分库分表也不会有问题，为什么？因为，使用我们的方法，对于一条具体的消息，总是会落到确定的某个库表上，它的重复消息也会落地同样的库表上，所以分库分表不是问题。\n\n第五个问题，有的消息队列会有一个特殊的队列来保存这些总是消费失败的“坏消息”，然后继续消费之后的消息，避免坏消息卡死队列。这种坏消息一般不会是因为网络原因或者消费者死掉导致的，大多都是消息数据本身有问题，消费者的业务逻辑处理不了导致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564891142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","nickname":"猿人谷","note":"","ucode":"85106C7FB14C43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3938,"discussion_content":"rabbitmq有死信队列，可以设置一个重试阈值（如5次），如重试次数超过5次，则可将此消息放入死信队列。一般这种重试超过5次还失败的，即使重试再多次数也不保证成功。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564994277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","nickname":"猿人谷","note":"","ucode":"85106C7FB14C43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7002,"discussion_content":"消息存入死信队列后，是需要自己手动消费重试处理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567250959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3938,"ip_address":"","group_id":0},"score":7002,"extra":""},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375681,"discussion_content":"这样的数据是有问题的，重试多少次估计都没用，应该可以存档做记录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621816103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7002,"ip_address":"","group_id":0},"score":375681,"extra":""}]},{"author":{"id":1340609,"avatar":"https://static001.geekbang.org/account/avatar/00/14/74/c1/28ef0f2d.jpg","nickname":"SHADOWFAX","note":"","ucode":"E4B0750EE09435","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3904,"discussion_content":"有序消费场景，如果前面（如第一笔）存在消费不掉的情况，该笔坏数据存储到特殊队列中，那该笔坏味道消息的后续有序消息（第二、三、四笔）到达该如何处理？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564968138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135159,"avatar":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","nickname":"Vincent","note":"","ucode":"CD8B84A57A6A0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404270,"discussion_content":"第一个问题，我觉得如果出现也是系统设计的大问题，一个消息更新操作涉及的数据在两个不同库里面？比如账户A的账户余额在A  B两个库里面都有值，你怎么保证他们的一致性呢？一般系统设计不会设计成这样子的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634274507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1658796,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4f/ac/80439ba7.jpg","nickname":"Aprelude","note":"","ucode":"840D3F7A35AEEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361020,"discussion_content":"唯一索引要不要加在删除标记上面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616581031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103802,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/ba/d657d286.jpg","nickname":"SuperH~","note":"","ucode":"21929491561C7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310585,"discussion_content":"又见面了启温哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601912142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3791,"discussion_content":"一直重试的话，rabbitmq中有个死信队列的概念，可以解决这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564812987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121682,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1565182123,"is_pvip":false,"replies":[{"id":44753,"content":"确实这个例子解决不了ABA问题，如果要解决这个问题，只能使用版本号的方式。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565238924,"ip_address":"","comment_id":121682,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师好，想问下关于幂等的情况，像设置帐户余额为100元，或者给余额为500的加100，如果有中间状态的变更或者ABA问题，也能算是幂等操作吗？","like_count":29,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461902,"discussion_content":"确实这个例子解决不了ABA问题，如果要解决这个问题，只能使用版本号的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565238924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1187483,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/9b/397e8fa1.jpg","nickname":"Canon","note":"","ucode":"411FF465C3A3E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601177,"discussion_content":"评论区也可以学到知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675127686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123958,"user_name":"年年","can_delete":false,"product_type":"c1","uid":1040847,"ip_address":"","ucode":"1B75ADD0CD457F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e1/cf/23a33fb4.jpg","comment_is_top":false,"comment_ctime":1565784517,"is_pvip":false,"replies":[{"id":45709,"content":"感谢支持！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565916406,"ip_address":"","comment_id":123958,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"这课买的太值了，是本平台最吸引我的一门课，一口气看了八篇","like_count":24,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462919,"discussion_content":"感谢支持！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565916406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10908,"discussion_content":"我怎么感觉我一口气只能看一篇呢？看多了，消化不了呀，可能还是自己经验不够，参与的分布式的系统较少的原因吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568338782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/61/10/38f22d72.jpg","nickname":"。","note":"","ucode":"B45232071FECB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579232,"discussion_content":"我来回看了2遍，第三遍终于能看进去了，感觉我太菜了，以前没有接触过，一下子吸收不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657259652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109640,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/88/a890b41e.jpg","nickname":"chris","note":"","ucode":"6663E3E09457E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576927,"discussion_content":"一口气看8章，确实消化不了，最多看个两章😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655859591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155646,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132","nickname":"ppd0705","note":"","ucode":"EB63D4E3FD1E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339395,"discussion_content":"真的看了八遍吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609657757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7008,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567251951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120158,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1564801192,"is_pvip":false,"replies":[{"id":44176,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564890428,"ip_address":"","comment_id":120158,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"我的理解如下：\n1、按照您给的公式：At least once + 幂等消费 = Exactly once，所以对于消息队列来讲，要做到Exactly once，其实是需消费端的共同配合（幂等消费）才可完成，消息队列基本只提供At least once的实现；\n2、从给的几种幂等消费的方案看，需要引入数据库、条件更新、分布式事务或锁等额外辅助，消息队列如果需要保障Exactly once，会导致消费端代码侵入，例如需要消费端增加消息队列用来处理幂等的client端，而消费端的形态可是太多了，兼容适配工作量巨大。故这个Exactly once留给用户自己处理，并且具有选择权，毕竟不是所有业务场景都需要Exactly once，例如老师讲的机房温度上报的案例。","like_count":19,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462919,"discussion_content":"感谢支持！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565916406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10908,"discussion_content":"我怎么感觉我一口气只能看一篇呢？看多了，消化不了呀，可能还是自己经验不够，参与的分布式的系统较少的原因吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568338782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/61/10/38f22d72.jpg","nickname":"。","note":"","ucode":"B45232071FECB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579232,"discussion_content":"我来回看了2遍，第三遍终于能看进去了，感觉我太菜了，以前没有接触过，一下子吸收不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657259652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109640,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/88/a890b41e.jpg","nickname":"chris","note":"","ucode":"6663E3E09457E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576927,"discussion_content":"一口气看8章，确实消化不了，最多看个两章😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655859591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155646,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132","nickname":"ppd0705","note":"","ucode":"EB63D4E3FD1E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339395,"discussion_content":"真的看了八遍吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609657757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7008,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567251951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120082,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1564785908,"is_pvip":false,"replies":[{"id":44108,"content":"A1：主要是出于性能考虑。\n\nA2：大部分消息队列在实现的时候，都是批量收发的，但是，采用基于位置的确认机制，是可以保证顺序的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564799586,"ip_address":"","comment_id":120082,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"    对于老师说的为何都是支持At least once:是不是与以下几种情况相关；不对之处还望老师指出，因为我是刚好最近有时会有些异常数据联想到的也算是学习此课的初衷之一。\n    1.硬件异常或者系统异常导致的数据丢失：这里想咨询老师一下，消息队列为何不能做成像数据库一样的用undo log和redo log去避免硬件的这种异常。\n    2.就像为何网络协议中一样TCP和UDP的区别：消息反馈可能不是每一个反馈一次，有时是一批反馈异常，传输中可能会出现丢包或者顺序不一致。\n          最近几个刚好同时在学：刘超老师的网络协议、操作系统以及您的消息队列觉得之间有彼此的关系；能力有限，故而仅仅是猜测，只能通过不断的向各位老师学习才能不断的找出问题提升自己，不足之处还望老师提点-谢谢。","like_count":13,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461219,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564890428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187089,"user_name":"李先生","can_delete":false,"product_type":"c1","uid":1237614,"ip_address":"","ucode":"D9039715F7D290","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/6e/0a300829.jpg","comment_is_top":false,"comment_ctime":1584010036,"is_pvip":false,"replies":[{"id":72239,"content":"你说的这个情况确实是这样，但10s（或者更长时间）之后再出现一个重复ID的情况是非常罕见的，所以也就无所谓的。\n\n其实，很多工程上解决问题的方法，理论上都存在缺陷。比如几乎所有一致性算法都解决不了拜占庭将军问题，很多分布式事务理论也不能保证所有情况下的数据一致性。\n\n但这些方法确实能解决实际问题，这才是我们需要关注的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1584063489,"ip_address":"","comment_id":187089,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"我有个疑问，如果使用redis来实现幂等，那么在redis中设置的唯一id肯定要设置失效时间的。比如失效时间设置为10s，在这10s之内可以保证拥有唯一id的消息只被消费一次。那么10s之后又出现一个相同的唯一id，由于redis中这个唯一id已经失效，这个消息将再次被消费。这种如何处理呢？","like_count":12,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486985,"discussion_content":"你说的这个情况确实是这样，但10s（或者更长时间）之后再出现一个重复ID的情况是非常罕见的，所以也就无所谓的。\n\n其实，很多工程上解决问题的方法，理论上都存在缺陷。比如几乎所有一致性算法都解决不了拜占庭将军问题，很多分布式事务理论也不能保证所有情况下的数据一致性。\n\n但这些方法确实能解决实际问题，这才是我们需要关注的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584063489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237614,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e2/6e/0a300829.jpg","nickname":"李先生","note":"","ucode":"D9039715F7D290","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209788,"discussion_content":"谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584672489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120065,"user_name":"a、","can_delete":false,"product_type":"c1","uid":1532404,"ip_address":"","ucode":"590FE8DB111492","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","comment_is_top":false,"comment_ctime":1564768354,"is_pvip":false,"replies":[{"id":44107,"content":"架构设计就是在取舍之间选择最合适的实现方式。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564799395,"ip_address":"","comment_id":120065,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"因为目前消息队列，在发送消息给客户端的时候，一般需要客户端ack之后才能确定，这条消息是不是真的被消费了。\n1.如果客户端设置的是自动ack，那么mq就能保证只发送一次，但是这样会因为客户端消费消息不成功，而导致消息丢失\n2.如果客户端都设置手动ack，这样又有一个问题，如果mq发送消息给客户端成功了，客户端也已经消费完成了，就在准备ack的时候，和mq失去了联系，这时候mq是不知道，这条消息是否真的被消费了，只能选择重发消息。\n所以我觉得:如果消息队列保证了只发一次，那么消息队列就无法保证消息由于客户端消费失败而不丢失，就好像分布式系统中的cap理论，只能保证其中的两种，而无法三个都保证。","like_count":12,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461189,"discussion_content":"架构设计就是在取舍之间选择最合适的实现方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564799395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7006,"discussion_content":"哈哈，谢谢你回答了我的 消息手动提交和自动提交的区别，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567251494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142949,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571596185,"is_pvip":false,"replies":[{"id":55259,"content":"这个情况不需要配置多个消费组，只要主题中配置了多个分区，同一个消费组内也会出现这种情况。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571621268,"ip_address":"","comment_id":142949,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"文中有句话想跟老师确认下，如下:\n\n”t0 时刻：Consumer A 收到条消息，检查消息执行状态，发现消息未处理过，开始执行“账户增加 100 元”；\n\nt1 时刻：Consumer B 收到条消息，检查消息执行状态，发现消息未处理过，因为这个时刻，Consumer A 还未来得及更新消息执行状态。”\n\n1.这是因为每个队列配置多个消费组导致的吧？\n2.通常情况下配置多个消费组是为了提升消费能力？\n3.如果配置多个消费组是为了提升消费能力，那么为什么每个消费组配置多个消费者？反正每个消费组只有一个消费者能成功消费到消息。每个消费组只配置一个消费者不行吗？","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471337,"discussion_content":"这个情况不需要配置多个消费组，只要主题中配置了多个分区，同一个消费组内也会出现这种情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571621268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2327720,"avatar":"https://static001.geekbang.org/account/avatar/00/23/84/a8/94690be4.jpg","nickname":"一生有梦","note":"","ucode":"D20EA9A022132C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347294,"discussion_content":"我是这样理解的，个人想法，不一定正确\n1. 首先因为网络的不确定性加上Broker对于生产者发送消息的确认机制，最终导致了生产者会重复发送数据。\n2. 如果这个时候Topic配置了多个分区，相同的消息最终会被负载均衡等算法路由到不同的分区上。\n3. 一个分区的数据同一时间只能被一个Consumer消费，但是重复的消息被路由到了不同分区上。\n4. 同一时间ConsumerA和ConsumerB可能出现上述的同时消费一条数据的情况，并且因为极端情况和没有保证原子性导致检查出现bug，造成接口执行两次","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1612189320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300931,"discussion_content":"标记下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598325403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168804,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1578189325,"is_pvip":false,"replies":[{"id":65572,"content":"是的","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1578275589,"ip_address":"","comment_id":168804,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"文中有句话想跟老师确认下，如下:\n\n”t0 时刻：Consumer A 收到条消息，检查消息执行状态，发现消息未处理过，开始执行“账户增加 100 元”；\n\nt1 时刻：Consumer B 收到条消息，检查消息执行状态，发现消息未处理过，因为这个时刻，Consumer A 还未来得及更新消息执行状态。”\n\n这个情况只能在有消息重发，且重发到了不同队列上才可能发生吧，否则再怎么重发都会由相同的消费者消费。","like_count":7},{"had_liked":false,"id":183949,"user_name":"Spring coming","can_delete":false,"product_type":"c1","uid":1116196,"ip_address":"","ucode":"9E01F2D987D08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/24/1d3bafaf.jpg","comment_is_top":false,"comment_ctime":1583166501,"is_pvip":false,"replies":[{"id":71225,"content":"关于ABA的问题，我在另外一个课程《后端存储实战课》的[第一节课](https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;204673)中有详细的讲解，你可以看一下。（如果只看其中的一节课，应该是免费的）","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1583202569,"ip_address":"","comment_id":183949,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"请教老师，看到一个同学的评论:&quot;有一个疑问，为更新的数据设置前置条件 中的例子。如果账户 X 当前的余额为 500 元，将余额加 100 元。可能会有类似CAS中的ABA问题，所以还是使用版本号递增的方案的更好一些吧&quot;.  为啥可能有aba问题？ 如果有重复消息，不管这两条谁先成功，另外一条应该不会成功，因为有500这个限制条件。是不是我哪里没理解到位，希望老师解答","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485830,"discussion_content":"关于ABA的问题，我在另外一个课程《后端存储实战课》的[第一节课](https://time.geekbang.org/column/article/204673)中有详细的讲解，你可以看一下。（如果只看其中的一节课，应该是免费的）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583202569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120265,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1564816823,"is_pvip":true,"replies":[{"id":44181,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564891919,"ip_address":"","comment_id":120265,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"对于思考题，三种服务质量标准都有各自的使用场景，这就好比数据库中隔离级别的实现，Serializable隔离级别不仅可以避免脏读、不可重复读，还避免了幻读，但同时代价花费也是最高，性能很低。文中的Exactly once(恰好一次)基本类似，虽然一定程度上可以避免消息重复以及消息丢失，但其实现必然也意味着高代价、低性能。最后深深的感受到架构的设计的关键就是判断和取舍，以及针对特定场景去做特定的实现。","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461262,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564891919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168796,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1578187666,"is_pvip":false,"replies":[{"id":65571,"content":"实际上，MQ只有在异常情况下（比如Broker宕机，网络中断），才会产生重复消息，一般情况下是不会有重复消息的，所以代价和开销问题不用太考虑。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1578275551,"ip_address":"","comment_id":168796,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"李老师，我有个问题： \n    我看很多小伙伴们留言说业务端实现幂等就完全解决问题了，但我觉得幂等不是银弹，不能解决所有问题。\n    幂等只能保证消息被重复消费后的结果正确，但重复消费消息本身也是有代价的。举例，一个业务操作是写文件，执行成本是锁定文件、IO、网络传输、CPU时间片占用等，这些都是没有价值的，类似于不挂挡踩油门，听响而已。\n    个人观点，如果业务执行开销较小，那么业务幂等就够了。如果业务执行开销大，那么前置条件判断就比较好，虽然条件的判断也会有不小开销，但两害相权取其轻。如果任一种的代价都太大，那么看能否拆分业务操作，拆分后哪个代价小就用哪个。\n    另，根据老师的定义，这里的幂等“其任意多次执行所产生的影响均与一次执行的影响相同”应该不包含前置条件检查和记录并检查，因为这两个都没有“多次执行”，所以应该是与幂等并列的解决重复消息问题的实现方式。\n    有不妥处，请不吝指教。","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480339,"discussion_content":"实际上，MQ只有在异常情况下（比如Broker宕机，网络中断），才会产生重复消息，一般情况下是不会有重复消息的，所以代价和开销问题不用太考虑。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578275551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132","nickname":"尔东橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578824,"discussion_content":"问的是重复消费，不是重复消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657029909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2172669,"avatar":"https://static001.geekbang.org/account/avatar/00/21/26/fd/52189e8e.jpg","nickname":"777_yL","note":"","ucode":"0DC2B457C35254","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381908,"discussion_content":"不挂档 踩油门  ahhh\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625284149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149725,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1573354735,"is_pvip":false,"replies":[{"id":57817,"content":"正常情况下不会出现，如果有故障，比如broker故障、consumer故障或者网络连接抖动，都可能会出现重复消费，也就是一个消息被不同的consumer都消费到的情况，kafka和rocketmq都有可能会出现这种情况。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573522359,"ip_address":"","comment_id":149725,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"第三种方案，b也会收到同样消息的原因是啥，是a消费时间太长重发导致的吗？ kafka中每个consumer一个queue不会出现这种场景，而rocketmq的顺序消费也不会出现","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480339,"discussion_content":"实际上，MQ只有在异常情况下（比如Broker宕机，网络中断），才会产生重复消息，一般情况下是不会有重复消息的，所以代价和开销问题不用太考虑。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578275551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132","nickname":"尔东橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578824,"discussion_content":"问的是重复消费，不是重复消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657029909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2172669,"avatar":"https://static001.geekbang.org/account/avatar/00/21/26/fd/52189e8e.jpg","nickname":"777_yL","note":"","ucode":"0DC2B457C35254","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381908,"discussion_content":"不挂档 踩油门  ahhh\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625284149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129236,"user_name":"Geek_865595","can_delete":false,"product_type":"c1","uid":1644284,"ip_address":"","ucode":"8EEB2C9F1EBF74","user_header":"","comment_is_top":false,"comment_ctime":1567068954,"is_pvip":false,"replies":[{"id":48236,"content":"消费状态就是这条消息是否被消费过了。\n\n怎么获取和设置这个状态是由业务代码实现的，比如你可以用Redis来保存这个状态。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567139510,"ip_address":"","comment_id":129236,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。\n请问：这个消费状态是什么？怎么获取这个消息状态，然后怎么设置它的状态？","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465349,"discussion_content":"消费状态就是这条消息是否被消费过了。\n\n怎么获取和设置这个状态是由业务代码实现的，比如你可以用Redis来保存这个状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567139510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375685,"discussion_content":"这设置状态和上面说的设置版本号有区别？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621816808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168705,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d5/41/b14fe0a1.jpg","nickname":"井","note":"","ucode":"A9C800F8765658","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14858,"discussion_content":"如果用redis，或者其它的，什么时候删除这个全局的id呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568784437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211086,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1587893529,"is_pvip":false,"replies":[{"id":78783,"content":"一般来说，如果不做特殊的设置（比如按照key哈希到特定分区上），是保证不了“重复消息投递应该投到相同队列”的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1588048785,"ip_address":"","comment_id":211086,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师关于幂等性第三点有些疑问，是不是队列开启ACK模式就能避免这个情况发生呢。重复消息投递应该投到相同队列。这样就不会出现一个consumerA还未消费完返回ACK之前，另一个consumerB就去消费下一条消息。对于同一个队列来说，队列是不是保证了串行消费。这样就只需要保证业务流水号唯一就行了。希望老师解答","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493195,"discussion_content":"一般来说，如果不做特殊的设置（比如按照key哈希到特定分区上），是保证不了“重复消息投递应该投到相同队列”的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588048785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184230,"user_name":"Josey","can_delete":false,"product_type":"c1","uid":1813086,"ip_address":"","ucode":"BA461C259CC64B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/aa/5e/9be28107.jpg","comment_is_top":false,"comment_ctime":1583251410,"is_pvip":false,"replies":[{"id":71301,"content":"不用要求生产者和消费者连同一个数据库。\n\n生产者只要保证，发出去的每条转账消息都有一个唯一的转账单ID，这个“转账单 ID”可以存在生产者的数据库中，也可以不存，看业务需求。只要这个转账单ID不重复就可以了，这个很容易做到，比如我们用MySQL的Sequence就可以生成。\n\n消费者用这个转账单ID结合数据库（消费者的数据库，可以和生产者数据库不同）的唯一约束，就可以来实现消费幂等了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1583284842,"ip_address":"","comment_id":184230,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，我想问一下，假如消费者和生产者连接的不是同一个数据库，那怎么能通过数据库约束的方式实现幂等操作？还有全局ID的形式，如果这个ID的消息被消费过是要把处理状态更新到数据库中吗？如果也是连接的不同数据库，这种情况下怎么处理？忘老师回复！","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493195,"discussion_content":"一般来说，如果不做特殊的设置（比如按照key哈希到特定分区上），是保证不了“重复消息投递应该投到相同队列”的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588048785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179761,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1582093255,"is_pvip":false,"replies":[{"id":70003,"content":"是的，第一种方法没那么通用，但更容易实现。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582247509,"ip_address":"","comment_id":179761,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，看了幂等方法之后，感觉第一种方法和第三种方法非常类似，区别就是第三种方法多了一个消费状态，不知道消费状态包含哪些值? 我理解， 应该包含消费中和消费完成，并且将【全局ID+消费状态】作为数据库唯一索引，应该可以解决，重复消费问题。","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485936,"discussion_content":"不用要求生产者和消费者连同一个数据库。\n\n生产者只要保证，发出去的每条转账消息都有一个唯一的转账单ID，这个“转账单 ID”可以存在生产者的数据库中，也可以不存，看业务需求。只要这个转账单ID不重复就可以了，这个很容易做到，比如我们用MySQL的Sequence就可以生成。\n\n消费者用这个转账单ID结合数据库（消费者的数据库，可以和生产者数据库不同）的唯一约束，就可以来实现消费幂等了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583284842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175069,"user_name":"特铮","can_delete":false,"product_type":"c1","uid":1151593,"ip_address":"","ucode":"A12B3D28B796A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/92/69/b04bd4cd.jpg","comment_is_top":false,"comment_ctime":1580545644,"is_pvip":false,"replies":[{"id":68334,"content":"如果存储引擎不支持这两种原子操作，上层应用实现起来就很困难。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1580863960,"ip_address":"","comment_id":175069,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"“更新数据的同时将版本号 +1”和“记录并检查结果”比，实现难度有区别么，如果存储引擎没有原生支持的话？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482613,"discussion_content":"如果存储引擎不支持这两种原子操作，上层应用实现起来就很困难。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580863960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168804,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1578189325,"is_pvip":false,"replies":[{"id":65572,"content":"是的","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1578275589,"ip_address":"","comment_id":168804,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"文中有句话想跟老师确认下，如下:\n\n”t0 时刻：Consumer A 收到条消息，检查消息执行状态，发现消息未处理过，开始执行“账户增加 100 元”；\n\nt1 时刻：Consumer B 收到条消息，检查消息执行状态，发现消息未处理过，因为这个时刻，Consumer A 还未来得及更新消息执行状态。”\n\n这个情况只能在有消息重发，且重发到了不同队列上才可能发生吧，否则再怎么重发都会由相同的消费者消费。","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480342,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578275589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111899,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","nickname":"时隐时现","note":"","ucode":"DA4D622FF84920","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250360,"discussion_content":"不一定吧，如果consumer A锁定了q1队列，但是网络中断超时了，此时应该会释放锁，其他consumer有机会锁定q1队列并读取，此时不知道consumer A有没有成功消费了该条消息，就需要consumer端去重了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588000384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183949,"user_name":"Spring coming","can_delete":false,"product_type":"c1","uid":1116196,"ip_address":"","ucode":"9E01F2D987D08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/24/1d3bafaf.jpg","comment_is_top":false,"comment_ctime":1583166501,"is_pvip":false,"replies":[{"id":71225,"content":"关于ABA的问题，我在另外一个课程《后端存储实战课》的[第一节课](https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;204673)中有详细的讲解，你可以看一下。（如果只看其中的一节课，应该是免费的）","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1583202569,"ip_address":"","comment_id":183949,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"请教老师，看到一个同学的评论:&quot;有一个疑问，为更新的数据设置前置条件 中的例子。如果账户 X 当前的余额为 500 元，将余额加 100 元。可能会有类似CAS中的ABA问题，所以还是使用版本号递增的方案的更好一些吧&quot;.  为啥可能有aba问题？ 如果有重复消息，不管这两条谁先成功，另外一条应该不会成功，因为有500这个限制条件。是不是我哪里没理解到位，希望老师解答","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480342,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578275589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111899,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","nickname":"时隐时现","note":"","ucode":"DA4D622FF84920","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250360,"discussion_content":"不一定吧，如果consumer A锁定了q1队列，但是网络中断超时了，此时应该会释放锁，其他consumer有机会锁定q1队列并读取，此时不知道consumer A有没有成功消费了该条消息，就需要consumer端去重了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588000384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120265,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1564816823,"is_pvip":true,"replies":[{"id":44181,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564891919,"ip_address":"","comment_id":120265,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"对于思考题，三种服务质量标准都有各自的使用场景，这就好比数据库中隔离级别的实现，Serializable隔离级别不仅可以避免脏读、不可重复读，还避免了幻读，但同时代价花费也是最高，性能很低。文中的Exactly once(恰好一次)基本类似，虽然一定程度上可以避免消息重复以及消息丢失，但其实现必然也意味着高代价、低性能。最后深深的感受到架构的设计的关键就是判断和取舍，以及针对特定场景去做特定的实现。","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485830,"discussion_content":"关于ABA的问题，我在另外一个课程《后端存储实战课》的[第一节课](https://time.geekbang.org/column/article/204673)中有详细的讲解，你可以看一下。（如果只看其中的一节课，应该是免费的）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583202569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168796,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1578187666,"is_pvip":false,"replies":[{"id":65571,"content":"实际上，MQ只有在异常情况下（比如Broker宕机，网络中断），才会产生重复消息，一般情况下是不会有重复消息的，所以代价和开销问题不用太考虑。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1578275551,"ip_address":"","comment_id":168796,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"李老师，我有个问题： \n    我看很多小伙伴们留言说业务端实现幂等就完全解决问题了，但我觉得幂等不是银弹，不能解决所有问题。\n    幂等只能保证消息被重复消费后的结果正确，但重复消费消息本身也是有代价的。举例，一个业务操作是写文件，执行成本是锁定文件、IO、网络传输、CPU时间片占用等，这些都是没有价值的，类似于不挂挡踩油门，听响而已。\n    个人观点，如果业务执行开销较小，那么业务幂等就够了。如果业务执行开销大，那么前置条件判断就比较好，虽然条件的判断也会有不小开销，但两害相权取其轻。如果任一种的代价都太大，那么看能否拆分业务操作，拆分后哪个代价小就用哪个。\n    另，根据老师的定义，这里的幂等“其任意多次执行所产生的影响均与一次执行的影响相同”应该不包含前置条件检查和记录并检查，因为这两个都没有“多次执行”，所以应该是与幂等并列的解决重复消息问题的实现方式。\n    有不妥处，请不吝指教。","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461262,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564891919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149725,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1573354735,"is_pvip":false,"replies":[{"id":57817,"content":"正常情况下不会出现，如果有故障，比如broker故障、consumer故障或者网络连接抖动，都可能会出现重复消费，也就是一个消息被不同的consumer都消费到的情况，kafka和rocketmq都有可能会出现这种情况。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573522359,"ip_address":"","comment_id":149725,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"第三种方案，b也会收到同样消息的原因是啥，是a消费时间太长重发导致的吗？ kafka中每个consumer一个queue不会出现这种场景，而rocketmq的顺序消费也不会出现","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473956,"discussion_content":"正常情况下不会出现，如果有故障，比如broker故障、consumer故障或者网络连接抖动，都可能会出现重复消费，也就是一个消息被不同的consumer都消费到的情况，kafka和rocketmq都有可能会出现这种情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573522359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1574051,"avatar":"https://static001.geekbang.org/account/avatar/00/18/04/a3/95de9a19.jpg","nickname":"forever","note":"","ucode":"3EBCD4AB045880","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":556225,"discussion_content":"一条消息不是只能被一个消费者实例消费吗，即分区与消费者关系是多对一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647255649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":473956,"ip_address":"","group_id":0},"score":556225,"extra":""}]}]},{"had_liked":false,"id":129236,"user_name":"Geek_865595","can_delete":false,"product_type":"c1","uid":1644284,"ip_address":"","ucode":"8EEB2C9F1EBF74","user_header":"","comment_is_top":false,"comment_ctime":1567068954,"is_pvip":false,"replies":[{"id":48236,"content":"消费状态就是这条消息是否被消费过了。\n\n怎么获取和设置这个状态是由业务代码实现的，比如你可以用Redis来保存这个状态。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567139510,"ip_address":"","comment_id":129236,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。\n请问：这个消费状态是什么？怎么获取这个消息状态，然后怎么设置它的状态？","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473956,"discussion_content":"正常情况下不会出现，如果有故障，比如broker故障、consumer故障或者网络连接抖动，都可能会出现重复消费，也就是一个消息被不同的consumer都消费到的情况，kafka和rocketmq都有可能会出现这种情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573522359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1574051,"avatar":"https://static001.geekbang.org/account/avatar/00/18/04/a3/95de9a19.jpg","nickname":"forever","note":"","ucode":"3EBCD4AB045880","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":556225,"discussion_content":"一条消息不是只能被一个消费者实例消费吗，即分区与消费者关系是多对一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647255649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":473956,"ip_address":"","group_id":0},"score":556225,"extra":""}]}]},{"had_liked":false,"id":211086,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1587893529,"is_pvip":false,"replies":[{"id":78783,"content":"一般来说，如果不做特殊的设置（比如按照key哈希到特定分区上），是保证不了“重复消息投递应该投到相同队列”的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1588048785,"ip_address":"","comment_id":211086,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师关于幂等性第三点有些疑问，是不是队列开启ACK模式就能避免这个情况发生呢。重复消息投递应该投到相同队列。这样就不会出现一个consumerA还未消费完返回ACK之前，另一个consumerB就去消费下一条消息。对于同一个队列来说，队列是不是保证了串行消费。这样就只需要保证业务流水号唯一就行了。希望老师解答","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465349,"discussion_content":"消费状态就是这条消息是否被消费过了。\n\n怎么获取和设置这个状态是由业务代码实现的，比如你可以用Redis来保存这个状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567139510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375685,"discussion_content":"这设置状态和上面说的设置版本号有区别？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621816808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168705,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d5/41/b14fe0a1.jpg","nickname":"井","note":"","ucode":"A9C800F8765658","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14858,"discussion_content":"如果用redis，或者其它的，什么时候删除这个全局的id呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568784437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184230,"user_name":"Josey","can_delete":false,"product_type":"c1","uid":1813086,"ip_address":"","ucode":"BA461C259CC64B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/aa/5e/9be28107.jpg","comment_is_top":false,"comment_ctime":1583251410,"is_pvip":false,"replies":[{"id":71301,"content":"不用要求生产者和消费者连同一个数据库。\n\n生产者只要保证，发出去的每条转账消息都有一个唯一的转账单ID，这个“转账单 ID”可以存在生产者的数据库中，也可以不存，看业务需求。只要这个转账单ID不重复就可以了，这个很容易做到，比如我们用MySQL的Sequence就可以生成。\n\n消费者用这个转账单ID结合数据库（消费者的数据库，可以和生产者数据库不同）的唯一约束，就可以来实现消费幂等了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1583284842,"ip_address":"","comment_id":184230,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，我想问一下，假如消费者和生产者连接的不是同一个数据库，那怎么能通过数据库约束的方式实现幂等操作？还有全局ID的形式，如果这个ID的消息被消费过是要把处理状态更新到数据库中吗？如果也是连接的不同数据库，这种情况下怎么处理？忘老师回复！","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485936,"discussion_content":"不用要求生产者和消费者连同一个数据库。\n\n生产者只要保证，发出去的每条转账消息都有一个唯一的转账单ID，这个“转账单 ID”可以存在生产者的数据库中，也可以不存，看业务需求。只要这个转账单ID不重复就可以了，这个很容易做到，比如我们用MySQL的Sequence就可以生成。\n\n消费者用这个转账单ID结合数据库（消费者的数据库，可以和生产者数据库不同）的唯一约束，就可以来实现消费幂等了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583284842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179761,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1582093255,"is_pvip":false,"replies":[{"id":70003,"content":"是的，第一种方法没那么通用，但更容易实现。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582247509,"ip_address":"","comment_id":179761,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，看了幂等方法之后，感觉第一种方法和第三种方法非常类似，区别就是第三种方法多了一个消费状态，不知道消费状态包含哪些值? 我理解， 应该包含消费中和消费完成，并且将【全局ID+消费状态】作为数据库唯一索引，应该可以解决，重复消费问题。","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484384,"discussion_content":"是的，第一种方法没那么通用，但更容易实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582247509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175069,"user_name":"特铮","can_delete":false,"product_type":"c1","uid":1151593,"ip_address":"","ucode":"A12B3D28B796A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/92/69/b04bd4cd.jpg","comment_is_top":false,"comment_ctime":1580545644,"is_pvip":false,"replies":[{"id":68334,"content":"如果存储引擎不支持这两种原子操作，上层应用实现起来就很困难。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1580863960,"ip_address":"","comment_id":175069,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"“更新数据的同时将版本号 +1”和“记录并检查结果”比，实现难度有区别么，如果存储引擎没有原生支持的话？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484384,"discussion_content":"是的，第一种方法没那么通用，但更容易实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582247509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153341,"user_name":"攀攀","can_delete":false,"product_type":"c1","uid":1159647,"ip_address":"","ucode":"217AFD7620D24E","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/df/e7f5ea7f.jpg","comment_is_top":false,"comment_ctime":1574220242,"is_pvip":false,"replies":[{"id":59497,"content":"正确！\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574643173,"ip_address":"","comment_id":153341,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"kafka接收线上mysql的binlog日志来进行数据同步  在分布式消费的情况下  可能出现分布式多台机器同时消费相同数据的问题  \n如果说kafka保证了每个分区的消息顺序  那么我们只要按照主id进行hash 就可以保证相同的id 只会发往相同的机器  老师  这么说对吗 ","like_count":3},{"had_liked":false,"id":122669,"user_name":"jinny","can_delete":false,"product_type":"c1","uid":1615158,"ip_address":"","ucode":"4BEF386F77FFA4","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/36/d93c851b.jpg","comment_is_top":false,"comment_ctime":1565481081,"is_pvip":false,"replies":[{"id":45028,"content":"这种场景还要保证消息的严格顺序，具体你可以看一下08疑难解答这节课中的严格顺序消息部分。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565523419,"ip_address":"","comment_id":122669,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，关于采用消息中带上更新条件的方法，我有一个问题：就那个当余额为500时，执行加100，如果当前消息被消费前，下一条消息到来时，数据库余额还是500，这时设置更新条件也是500，这种问题怎么解决？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475128,"discussion_content":"正确！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574643173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146883,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1572686147,"is_pvip":false,"replies":[{"id":56825,"content":"1.这个问题已经不是消息队列的问题了，而是二个不同的系统同时更新一份数据的问题，一般都不会这么来设计。\n\n2. 这种方式是可行的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572831632,"ip_address":"","comment_id":146883,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"请教老师：\n1）利用前置条件防重复消费那块，如果当前消息没有被消费过，但是有中间账户有其他操作（转账、消费）使得账户的余额不再是500，这样消息会被错误的判重？\n2）全局 ID 查询消费状态的分布式问题，查询用 select * from t where id=8 for update 给这条消息加锁可以吗？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473044,"discussion_content":"1.这个问题已经不是消息队列的问题了，而是二个不同的系统同时更新一份数据的问题，一般都不会这么来设计。\n\n2. 这种方式是可行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572831632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140407,"user_name":"荆仙","can_delete":false,"product_type":"c1","uid":1064734,"ip_address":"","ucode":"8BF9D620BCA5DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/1e/8e184acb.jpg","comment_is_top":false,"comment_ctime":1570933037,"is_pvip":false,"replies":[{"id":54345,"content":"是的","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571018243,"ip_address":"","comment_id":140407,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"有一个疑问，为更新的数据设置前置条件 中的例子。如果账户 X 当前的余额为 500 元，将余额加 100 元。可能会有类似CAS中的ABA问题，所以还是使用版本号递增的方案的更好一些吧\n","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473044,"discussion_content":"1.这个问题已经不是消息队列的问题了，而是二个不同的系统同时更新一份数据的问题，一般都不会这么来设计。\n\n2. 这种方式是可行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572831632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120101,"user_name":"David Mao","can_delete":false,"product_type":"c1","uid":1307248,"ip_address":"","ucode":"217112492D0955","user_header":"https://static001.geekbang.org/account/avatar/00/13/f2/70/8159901c.jpg","comment_is_top":false,"comment_ctime":1564791968,"is_pvip":false,"replies":[{"id":44114,"content":"这个还是需要使用消息队列的用户来考虑。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564800185,"ip_address":"","comment_id":120101,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"请教一下老师，重复消息多的话可能会影响效能，消息队列有这方面的设计考量吗？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470377,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571018243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125272,"user_name":"木木木","can_delete":false,"product_type":"c1","uid":1240679,"ip_address":"","ucode":"5EBC11AB704EF2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/67/d6d9499e.jpg","comment_is_top":false,"comment_ctime":1566135082,"is_pvip":false,"replies":[{"id":46020,"content":"检查的内容不一样，前者检查余额，后者检查消息执行状态；前者更容易实现，但适用范围比较窄，后者难实现，但适用范围更广泛。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566175434,"ip_address":"","comment_id":125272,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"没明白，“如果账户 X 当前的余额为 500 元，将余额加 100 元&quot;和“检查消息执行状态，发现消息未处理过，开始执行账户增加 100”，这两者有啥区别，不都是消费端compareAndUpdate吗，都可以用普通数据库事务就能实现","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461200,"discussion_content":"这个还是需要使用消息队列的用户来考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564800185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120325,"user_name":"星帆","can_delete":false,"product_type":"c1","uid":1199415,"ip_address":"","ucode":"40BB9C3088699D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/37/d6359a78.jpg","comment_is_top":false,"comment_ctime":1564831385,"is_pvip":false,"replies":[{"id":44182,"content":"如果只是单节点的MQTT Server，找一个流行的开源的即可。\n\n如果需要支撑海量的设备，必须部署集群，据我了解，还没有开源的做的特别好的，你可能需要买一个商业产品或者自己来开发。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564892046,"ip_address":"","comment_id":120325,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"mqtt服务器有推荐的吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463505,"discussion_content":"检查的内容不一样，前者检查余额，后者检查消息执行状态；前者更容易实现，但适用范围比较窄，后者难实现，但适用范围更广泛。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566175434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1113864,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/08/7c18d8a4.jpg","nickname":"团","note":"","ucode":"D56ABBCE4E4D90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":639691,"discussion_content":"前者容易实现是不是因为执行状态检查的值和业务要修改的值在同一个表中，而后者需要先操作状态检查表，然后在操作业务表？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710843704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":463505,"ip_address":"上海","group_id":0},"score":639691,"extra":""}]}]},{"had_liked":false,"id":120209,"user_name":"Jian","can_delete":false,"product_type":"c1","uid":1023040,"ip_address":"","ucode":"358133EC2AFEB0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9c/40/6323850e.jpg","comment_is_top":false,"comment_ctime":1564807214,"is_pvip":false,"replies":[{"id":44117,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564810518,"ip_address":"","comment_id":120209,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"在分布式环境下，如果让message queue负责实现exactly once，会导致其处理极其复杂，以及性能低下——这样的产品性价比不高。在分布式环境内，借助其他组件，结合特定的业务，才是解决exactly once最具性价比的方式。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461288,"discussion_content":"如果只是单节点的MQTT Server，找一个流行的开源的即可。\n\n如果需要支撑海量的设备，必须部署集群，据我了解，还没有开源的做的特别好的，你可能需要买一个商业产品或者自己来开发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564892046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120160,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1564801235,"is_pvip":false,"replies":[{"id":44177,"content":"如果只是保证隔离性：\n\nA实例在执行“更新数据”的时候，\nB实例也收到同一条消息，来检查消费状态，那还是“未消费”。\n\n这不就重复消费了吗？","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564890716,"ip_address":"","comment_id":120160,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师你好，在“检查消费状态，然后更新数据并且设置消费状态”中，三个操作必须作为一组操作保证原子性，才能真正实现幂等，否则就会出现 Bug。\n不应该是保证隔离性吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461240,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564810518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120159,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1564801206,"is_pvip":false,"replies":[{"id":44175,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564890367,"ip_address":"","comment_id":120159,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"我觉得主要是因为在性能上对恰好一次做了取舍","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461221,"discussion_content":"如果只是保证隔离性：\n\nA实例在执行“更新数据”的时候，\nB实例也收到同一条消息，来检查消费状态，那还是“未消费”。\n\n这不就重复消费了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564890716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153341,"user_name":"攀攀","can_delete":false,"product_type":"c1","uid":1159647,"ip_address":"","ucode":"217AFD7620D24E","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/df/e7f5ea7f.jpg","comment_is_top":false,"comment_ctime":1574220242,"is_pvip":false,"replies":[{"id":59497,"content":"正确！\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574643173,"ip_address":"","comment_id":153341,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"kafka接收线上mysql的binlog日志来进行数据同步  在分布式消费的情况下  可能出现分布式多台机器同时消费相同数据的问题  \n如果说kafka保证了每个分区的消息顺序  那么我们只要按照主id进行hash 就可以保证相同的id 只会发往相同的机器  老师  这么说对吗 ","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475128,"discussion_content":"正确！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574643173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122669,"user_name":"jinny","can_delete":false,"product_type":"c1","uid":1615158,"ip_address":"","ucode":"4BEF386F77FFA4","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/36/d93c851b.jpg","comment_is_top":false,"comment_ctime":1565481081,"is_pvip":false,"replies":[{"id":45028,"content":"这种场景还要保证消息的严格顺序，具体你可以看一下08疑难解答这节课中的严格顺序消息部分。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565523419,"ip_address":"","comment_id":122669,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，关于采用消息中带上更新条件的方法，我有一个问题：就那个当余额为500时，执行加100，如果当前消息被消费前，下一条消息到来时，数据库余额还是500，这时设置更新条件也是500，这种问题怎么解决？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462352,"discussion_content":"这种场景还要保证消息的严格顺序，具体你可以看一下08疑难解答这节课中的严格顺序消息部分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565523419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146883,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1572686147,"is_pvip":false,"replies":[{"id":56825,"content":"1.这个问题已经不是消息队列的问题了，而是二个不同的系统同时更新一份数据的问题，一般都不会这么来设计。\n\n2. 这种方式是可行的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572831632,"ip_address":"","comment_id":146883,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"请教老师：\n1）利用前置条件防重复消费那块，如果当前消息没有被消费过，但是有中间账户有其他操作（转账、消费）使得账户的余额不再是500，这样消息会被错误的判重？\n2）全局 ID 查询消费状态的分布式问题，查询用 select * from t where id=8 for update 给这条消息加锁可以吗？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462352,"discussion_content":"这种场景还要保证消息的严格顺序，具体你可以看一下08疑难解答这节课中的严格顺序消息部分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565523419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140407,"user_name":"荆仙","can_delete":false,"product_type":"c1","uid":1064734,"ip_address":"","ucode":"8BF9D620BCA5DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/1e/8e184acb.jpg","comment_is_top":false,"comment_ctime":1570933037,"is_pvip":false,"replies":[{"id":54345,"content":"是的","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571018243,"ip_address":"","comment_id":140407,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"有一个疑问，为更新的数据设置前置条件 中的例子。如果账户 X 当前的余额为 500 元，将余额加 100 元。可能会有类似CAS中的ABA问题，所以还是使用版本号递增的方案的更好一些吧\n","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470377,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571018243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120101,"user_name":"David Mao","can_delete":false,"product_type":"c1","uid":1307248,"ip_address":"","ucode":"217112492D0955","user_header":"https://static001.geekbang.org/account/avatar/00/13/f2/70/8159901c.jpg","comment_is_top":false,"comment_ctime":1564791968,"is_pvip":false,"replies":[{"id":44114,"content":"这个还是需要使用消息队列的用户来考虑。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564800185,"ip_address":"","comment_id":120101,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"请教一下老师，重复消息多的话可能会影响效能，消息队列有这方面的设计考量吗？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461200,"discussion_content":"这个还是需要使用消息队列的用户来考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564800185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125272,"user_name":"木木木","can_delete":false,"product_type":"c1","uid":1240679,"ip_address":"","ucode":"5EBC11AB704EF2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/67/d6d9499e.jpg","comment_is_top":false,"comment_ctime":1566135082,"is_pvip":false,"replies":[{"id":46020,"content":"检查的内容不一样，前者检查余额，后者检查消息执行状态；前者更容易实现，但适用范围比较窄，后者难实现，但适用范围更广泛。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566175434,"ip_address":"","comment_id":125272,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"没明白，“如果账户 X 当前的余额为 500 元，将余额加 100 元&quot;和“检查消息执行状态，发现消息未处理过，开始执行账户增加 100”，这两者有啥区别，不都是消费端compareAndUpdate吗，都可以用普通数据库事务就能实现","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463505,"discussion_content":"检查的内容不一样，前者检查余额，后者检查消息执行状态；前者更容易实现，但适用范围比较窄，后者难实现，但适用范围更广泛。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566175434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1113864,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/08/7c18d8a4.jpg","nickname":"团","note":"","ucode":"D56ABBCE4E4D90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":639691,"discussion_content":"前者容易实现是不是因为执行状态检查的值和业务要修改的值在同一个表中，而后者需要先操作状态检查表，然后在操作业务表？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710843704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":463505,"ip_address":"上海","group_id":0},"score":639691,"extra":""}]}]},{"had_liked":false,"id":120325,"user_name":"星帆","can_delete":false,"product_type":"c1","uid":1199415,"ip_address":"","ucode":"40BB9C3088699D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/37/d6359a78.jpg","comment_is_top":false,"comment_ctime":1564831385,"is_pvip":false,"replies":[{"id":44182,"content":"如果只是单节点的MQTT Server，找一个流行的开源的即可。\n\n如果需要支撑海量的设备，必须部署集群，据我了解，还没有开源的做的特别好的，你可能需要买一个商业产品或者自己来开发。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564892046,"ip_address":"","comment_id":120325,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"mqtt服务器有推荐的吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461288,"discussion_content":"如果只是单节点的MQTT Server，找一个流行的开源的即可。\n\n如果需要支撑海量的设备，必须部署集群，据我了解，还没有开源的做的特别好的，你可能需要买一个商业产品或者自己来开发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564892046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120209,"user_name":"Jian","can_delete":false,"product_type":"c1","uid":1023040,"ip_address":"","ucode":"358133EC2AFEB0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9c/40/6323850e.jpg","comment_is_top":false,"comment_ctime":1564807214,"is_pvip":false,"replies":[{"id":44117,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564810518,"ip_address":"","comment_id":120209,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"在分布式环境下，如果让message queue负责实现exactly once，会导致其处理极其复杂，以及性能低下——这样的产品性价比不高。在分布式环境内，借助其他组件，结合特定的业务，才是解决exactly once最具性价比的方式。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461240,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564810518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120160,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1564801235,"is_pvip":false,"replies":[{"id":44177,"content":"如果只是保证隔离性：\n\nA实例在执行“更新数据”的时候，\nB实例也收到同一条消息，来检查消费状态，那还是“未消费”。\n\n这不就重复消费了吗？","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564890716,"ip_address":"","comment_id":120160,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师你好，在“检查消费状态，然后更新数据并且设置消费状态”中，三个操作必须作为一组操作保证原子性，才能真正实现幂等，否则就会出现 Bug。\n不应该是保证隔离性吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461221,"discussion_content":"如果只是保证隔离性：\n\nA实例在执行“更新数据”的时候，\nB实例也收到同一条消息，来检查消费状态，那还是“未消费”。\n\n这不就重复消费了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564890716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120159,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1564801206,"is_pvip":false,"replies":[{"id":44175,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564890367,"ip_address":"","comment_id":120159,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"我觉得主要是因为在性能上对恰好一次做了取舍","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461220,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564890367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218623,"user_name":"Roger宇","can_delete":false,"product_type":"c1","uid":1703222,"ip_address":"","ucode":"CBA23C01409349","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","comment_is_top":false,"comment_ctime":1589847013,"is_pvip":false,"replies":[{"id":80847,"content":"这里的版本号，对应着数据库中一个字段，同时也是消息中的一个字段。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589868609,"ip_address":"","comment_id":218623,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"想请问老师，给数据加版本号具体是怎么操作呢？版本号是消息数据的版本，还是消息数据需要更新的数据库字段的属性呢？消息中可能包含多个需要更新的字段的数据，那这时候消息体中版本号也要多个嘛？消息中的数据版本号是消息生成时查询数据库得到的吗？","like_count":0},{"had_liked":false,"id":160613,"user_name":"苏州睿威博科技有限公司","can_delete":false,"product_type":"c1","uid":1650249,"ip_address":"","ucode":"1F1CF0B7BF146B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIQOlgDnvzMqmfgRV5aVUgJgtoTASbY4NVxvARhhmZkgT6gyxAR8tHtHsL4QdmtKgbeq85dqpUyjA/132","comment_is_top":false,"comment_ctime":1575986434,"is_pvip":false,"replies":[{"id":61578,"content":"如果说考虑普适通用的情况，这个方案不能解决所有问题。比如，的业务系统宕机怎么处理？\n\n但是，在特定的场景下，这种方案，是有可能解决你的问题的，还是需要看具体的业务场景。\n\n你可以说一下你的需求和场景，我们讨论一下。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1576299707,"ip_address":"","comment_id":160613,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"针对kafka,可以在业务中记录partition +offset来判断是否幂等吗？我看网络上很少有这样的方案，是因为和业务强关联的原因吗？望解答，谢谢🙏","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477432,"discussion_content":"如果说考虑普适通用的情况，这个方案不能解决所有问题。比如，的业务系统宕机怎么处理？\n\n但是，在特定的场景下，这种方案，是有可能解决你的问题的，还是需要看具体的业务场景。\n\n你可以说一下你的需求和场景，我们讨论一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576299707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181326,"discussion_content":"理论上这个方法是可以解决重复消费的，但是前提是要保证消息在写入的时候没有重复写入，不然仅靠 partition 和 offset 解决不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582361056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145150,"user_name":"学无涯","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1572224401,"is_pvip":false,"replies":[{"id":56030,"content":"MQTT协议 定义了QOS Level 2（恰好一次） 的协议，最大程度上保证恰好一次，你可以去搜一下协议。\n\n但实现起来比较困难，很少有产品能支持QOS 2","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572242356,"ip_address":"","comment_id":145150,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，MQTT是怎么保证恰好一次服务质量的呢","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472268,"discussion_content":"MQTT协议 定义了QOS Level 2（恰好一次） 的协议，最大程度上保证恰好一次，你可以去搜一下协议。\n\n但实现起来比较困难，很少有产品能支持QOS 2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572242356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144865,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1572077963,"is_pvip":false,"replies":[{"id":55893,"content":"消息协议在各种消息队列的文档中都有，需要的话可以直接去看","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572141011,"ip_address":"","comment_id":144865,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"请问有哪里详细讲到了几种消息的协议吗","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472145,"discussion_content":"消息协议在各种消息队列的文档中都有，需要的话可以直接去看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572141011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140052,"user_name":"酱排骨","can_delete":false,"product_type":"c1","uid":1348539,"ip_address":"","ucode":"FEB012688EAB9C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqwFYNicGUHlnpUXg3lBrjuWo2SLjUoH8SeE30QibzZprxjw8SZBMY5D70q5uFJshakb0WzRaKMknQA/132","comment_is_top":false,"comment_ctime":1570796996,"is_pvip":false,"replies":[{"id":54193,"content":"第三个问题，Kafka是支持生产幂等的，具体你可以看一下《30 | 流计算与消息（二）：在流计算中使用Kafka链接计算任务》","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1570843307,"ip_address":"","comment_id":140052,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老是我对produce想的三个问题\n\nkafka 精确发送一次的三个问题\n1.produce 收到重复消息。   \n2.mysql本地事物会滚，kafka误发送。\n3.broke当时网络波动，produce已经发送消息，网络波动没有收到callback，再次发送。此时网络正常，导致该消息重复。\n\n\n1.通过账单id+账户id作为一个字段，作为唯一索引。解决\n2.通过tcc事物解决\n3.未解决","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472145,"discussion_content":"消息协议在各种消息队列的文档中都有，需要的话可以直接去看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572141011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134908,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1568949541,"is_pvip":false,"replies":[{"id":51840,"content":"一般的MQ客户端SDK在消费的时候，超时是不会给服务端回“超时响应”的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569024456,"ip_address":"","comment_id":134908,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师 谢谢您的回复! \n\n那consumer1 最后是消费成功了， 但是发送了一个超时的ack, broker会怎么处理它啊？ \n\n我用的是rabbitmq， 我下去试试。 这里的逻辑我想不清楚。 ","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470222,"discussion_content":"第三个问题，Kafka是支持生产幂等的，具体你可以看一下《30 | 流计算与消息（二）：在流计算中使用Kafka链接计算任务》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570843307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134515,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1568857389,"is_pvip":false,"replies":[{"id":51724,"content":"你说的没错啊，如果“幂等做的不好”就是有可能出现，2个consumer都消费同一条消息的情况，也就是重复消费的问题。\n\n幂等不是说不允许重复消费，而是说“重复消费和不重复消费对系统的影响是一样的”","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568942495,"ip_address":"","comment_id":134515,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师 您讲的避免重复消费 主要是通过幂等性来保证\n\n我有个疑问啊:\n\n1. consumer1 从broker的topic1下的queue1中pull到了msg1,……\n\n2. 此时，consumer2 也从topic1下的queue1中pull,发现 msg1被consumer1 正拿着呢，还没ack, 所以consumer2 什么也没pull到就走了……\n\n3. consumer1 因为处理的太慢了，按您文章中提到的就是超过broker的等待consumer1 返回ack的时间了…… 所以broker认为consumer1 并没有将topic1下的queue1中的msg1 消费成功……\n\n4. 此时 consumer2 又去pull topic1.queue1下的msg， 返回了msg1, consumer2 就拿着msg1去消费了，……，然后，consumer2 在consumer1处理时间太长的情况下，幂等性的标记位&#47;状态&#47;记录，并未现在写进去，consumer2,就接着按业务逻辑去处理了……\n\n5. 终于，consumer1 处理完了，给broker返回ack (这个时候，的broker的逻辑我不知道该怎么说了，想请老师补充一下。) ，但是就是consumer1 成功处理了，但是返回了一个超时的ack……\n\n6. consumer2 继续正常的消费着 msg1, 这里的幂等性做的不好的话，是不是也就消费成功了哇？ 这是不是就是重复消费啊。\n\n码字不易，我理解的应该不到位，想请老师看看我描述的逻辑有没有什么问题，并且帮我看看，会不会两个consuer1&#47;2 是不是可能都会消费成功哇。 如果这里幂等性做的好的话，是不是consumer2, 就不可能消费成功哇？ 盼复。 谢谢老师!\n\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467783,"discussion_content":"你说的没错啊，如果“幂等做的不好”就是有可能出现，2个consumer都消费同一条消息的情况，也就是重复消费的问题。\n\n幂等不是说不允许重复消费，而是说“重复消费和不重复消费对系统的影响是一样的”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568942495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131978,"user_name":"小祺","can_delete":false,"product_type":"c1","uid":1193548,"ip_address":"","ucode":"2819BCA9E71C9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/4c/46c43cce.jpg","comment_is_top":false,"comment_ctime":1567998002,"is_pvip":false,"replies":[{"id":50559,"content":"这个幂等一定是包含存储部分的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568077462,"ip_address":"","comment_id":131978,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，文中好像只介绍了消费端实现幂等消费，但是没提到存储端幂等，也就是如果生产端的重试导致消息发送重复而在消息队列磁盘中重复存储的情况。\n1. 消息队列能不能保证不重复存储？\n2. 消息队列有没有必要保证存储幂等？是要都交给消费端解决吗","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467783,"discussion_content":"你说的没错啊，如果“幂等做的不好”就是有可能出现，2个consumer都消费同一条消息的情况，也就是重复消费的问题。\n\n幂等不是说不允许重复消费，而是说“重复消费和不重复消费对系统的影响是一样的”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568942495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123394,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1565666956,"is_pvip":false,"replies":[{"id":45338,"content":"这种流水一般不能删除，如果数量太多影响查询消息，可以考虑按照账户ID来分表存储。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565744827,"ip_address":"","comment_id":123394,"utype":1}],"discussion_count":3,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"如何解决方案一和方案二日益增多的存储日志呀，有合适的删除策略吗","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462651,"discussion_content":"这种流水一般不能删除，如果数量太多影响查询消息，可以考虑按照账户ID来分表存储。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565744827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041790,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/27/be/b666abb4.jpg","nickname":"tongZi","note":"","ucode":"8BBAE4FA37FF79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289404,"discussion_content":"请教个问题，方案一和方案二的存储日志指的是？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594089881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041790,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/27/be/b666abb4.jpg","nickname":"tongZi","note":"","ucode":"8BBAE4FA37FF79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289405,"discussion_content":"我暂时理解，方案一和方案二，应该是业务数据吗？方案三，会存储消息日志，算是存储日志吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594089980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122673,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1565485332,"is_pvip":false,"replies":[{"id":45029,"content":"只要流水正确写入了，后续根据流水计算余额的业务逻辑可以不与写入流水在同一个事务中，即使是计算余额失败了，也可以根据流水从新计算。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565523585,"ip_address":"","comment_id":122673,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"方法一解决不了主动的重试问题吧，比如插入流水，执行业务，返回mq逻辑错误，触发重新消费，这时会发现流水已经存在了。所以这里插流水和业务逻辑也得在一个事务里啊，这跟方法三区别看来只是怎么去控制唯一性而已。忘解答，非常疑惑","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462355,"discussion_content":"只要流水正确写入了，后续根据流水计算余额的业务逻辑可以不与写入流水在同一个事务中，即使是计算余额失败了，也可以根据流水从新计算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565523585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218623,"user_name":"Roger宇","can_delete":false,"product_type":"c1","uid":1703222,"ip_address":"","ucode":"CBA23C01409349","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","comment_is_top":false,"comment_ctime":1589847013,"is_pvip":false,"replies":[{"id":80847,"content":"这里的版本号，对应着数据库中一个字段，同时也是消息中的一个字段。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589868609,"ip_address":"","comment_id":218623,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"想请问老师，给数据加版本号具体是怎么操作呢？版本号是消息数据的版本，还是消息数据需要更新的数据库字段的属性呢？消息中可能包含多个需要更新的字段的数据，那这时候消息体中版本号也要多个嘛？消息中的数据版本号是消息生成时查询数据库得到的吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495530,"discussion_content":"这里的版本号，对应着数据库中一个字段，同时也是消息中的一个字段。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589868609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1703222,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","nickname":"Roger宇","note":"","ucode":"CBA23C01409349","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269120,"discussion_content":"谢谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589868651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160613,"user_name":"苏州睿威博科技有限公司","can_delete":false,"product_type":"c1","uid":1650249,"ip_address":"","ucode":"1F1CF0B7BF146B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIQOlgDnvzMqmfgRV5aVUgJgtoTASbY4NVxvARhhmZkgT6gyxAR8tHtHsL4QdmtKgbeq85dqpUyjA/132","comment_is_top":false,"comment_ctime":1575986434,"is_pvip":false,"replies":[{"id":61578,"content":"如果说考虑普适通用的情况，这个方案不能解决所有问题。比如，的业务系统宕机怎么处理？\n\n但是，在特定的场景下，这种方案，是有可能解决你的问题的，还是需要看具体的业务场景。\n\n你可以说一下你的需求和场景，我们讨论一下。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1576299707,"ip_address":"","comment_id":160613,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"针对kafka,可以在业务中记录partition +offset来判断是否幂等吗？我看网络上很少有这样的方案，是因为和业务强关联的原因吗？望解答，谢谢🙏","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495530,"discussion_content":"这里的版本号，对应着数据库中一个字段，同时也是消息中的一个字段。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589868609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1703222,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","nickname":"Roger宇","note":"","ucode":"CBA23C01409349","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269120,"discussion_content":"谢谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589868651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145150,"user_name":"学无涯","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1572224401,"is_pvip":false,"replies":[{"id":56030,"content":"MQTT协议 定义了QOS Level 2（恰好一次） 的协议，最大程度上保证恰好一次，你可以去搜一下协议。\n\n但实现起来比较困难，很少有产品能支持QOS 2","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572242356,"ip_address":"","comment_id":145150,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，MQTT是怎么保证恰好一次服务质量的呢","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477432,"discussion_content":"如果说考虑普适通用的情况，这个方案不能解决所有问题。比如，的业务系统宕机怎么处理？\n\n但是，在特定的场景下，这种方案，是有可能解决你的问题的，还是需要看具体的业务场景。\n\n你可以说一下你的需求和场景，我们讨论一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576299707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181326,"discussion_content":"理论上这个方法是可以解决重复消费的，但是前提是要保证消息在写入的时候没有重复写入，不然仅靠 partition 和 offset 解决不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582361056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144865,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1572077963,"is_pvip":false,"replies":[{"id":55893,"content":"消息协议在各种消息队列的文档中都有，需要的话可以直接去看","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572141011,"ip_address":"","comment_id":144865,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"请问有哪里详细讲到了几种消息的协议吗","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472268,"discussion_content":"MQTT协议 定义了QOS Level 2（恰好一次） 的协议，最大程度上保证恰好一次，你可以去搜一下协议。\n\n但实现起来比较困难，很少有产品能支持QOS 2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572242356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140052,"user_name":"酱排骨","can_delete":false,"product_type":"c1","uid":1348539,"ip_address":"","ucode":"FEB012688EAB9C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqwFYNicGUHlnpUXg3lBrjuWo2SLjUoH8SeE30QibzZprxjw8SZBMY5D70q5uFJshakb0WzRaKMknQA/132","comment_is_top":false,"comment_ctime":1570796996,"is_pvip":false,"replies":[{"id":54193,"content":"第三个问题，Kafka是支持生产幂等的，具体你可以看一下《30 | 流计算与消息（二）：在流计算中使用Kafka链接计算任务》","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1570843307,"ip_address":"","comment_id":140052,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老是我对produce想的三个问题\n\nkafka 精确发送一次的三个问题\n1.produce 收到重复消息。   \n2.mysql本地事物会滚，kafka误发送。\n3.broke当时网络波动，produce已经发送消息，网络波动没有收到callback，再次发送。此时网络正常，导致该消息重复。\n\n\n1.通过账单id+账户id作为一个字段，作为唯一索引。解决\n2.通过tcc事物解决\n3.未解决","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470222,"discussion_content":"第三个问题，Kafka是支持生产幂等的，具体你可以看一下《30 | 流计算与消息（二）：在流计算中使用Kafka链接计算任务》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570843307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134908,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1568949541,"is_pvip":false,"replies":[{"id":51840,"content":"一般的MQ客户端SDK在消费的时候，超时是不会给服务端回“超时响应”的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569024456,"ip_address":"","comment_id":134908,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师 谢谢您的回复! \n\n那consumer1 最后是消费成功了， 但是发送了一个超时的ack, broker会怎么处理它啊？ \n\n我用的是rabbitmq， 我下去试试。 这里的逻辑我想不清楚。 ","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467952,"discussion_content":"一般的MQ客户端SDK在消费的时候，超时是不会给服务端回“超时响应”的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569024456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134515,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1568857389,"is_pvip":false,"replies":[{"id":51724,"content":"你说的没错啊，如果“幂等做的不好”就是有可能出现，2个consumer都消费同一条消息的情况，也就是重复消费的问题。\n\n幂等不是说不允许重复消费，而是说“重复消费和不重复消费对系统的影响是一样的”","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568942495,"ip_address":"","comment_id":134515,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师 您讲的避免重复消费 主要是通过幂等性来保证\n\n我有个疑问啊:\n\n1. consumer1 从broker的topic1下的queue1中pull到了msg1,……\n\n2. 此时，consumer2 也从topic1下的queue1中pull,发现 msg1被consumer1 正拿着呢，还没ack, 所以consumer2 什么也没pull到就走了……\n\n3. consumer1 因为处理的太慢了，按您文章中提到的就是超过broker的等待consumer1 返回ack的时间了…… 所以broker认为consumer1 并没有将topic1下的queue1中的msg1 消费成功……\n\n4. 此时 consumer2 又去pull topic1.queue1下的msg， 返回了msg1, consumer2 就拿着msg1去消费了，……，然后，consumer2 在consumer1处理时间太长的情况下，幂等性的标记位&#47;状态&#47;记录，并未现在写进去，consumer2,就接着按业务逻辑去处理了……\n\n5. 终于，consumer1 处理完了，给broker返回ack (这个时候，的broker的逻辑我不知道该怎么说了，想请老师补充一下。) ，但是就是consumer1 成功处理了，但是返回了一个超时的ack……\n\n6. consumer2 继续正常的消费着 msg1, 这里的幂等性做的不好的话，是不是也就消费成功了哇？ 这是不是就是重复消费啊。\n\n码字不易，我理解的应该不到位，想请老师看看我描述的逻辑有没有什么问题，并且帮我看看，会不会两个consuer1&#47;2 是不是可能都会消费成功哇。 如果这里幂等性做的好的话，是不是consumer2, 就不可能消费成功哇？ 盼复。 谢谢老师!\n\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467952,"discussion_content":"一般的MQ客户端SDK在消费的时候，超时是不会给服务端回“超时响应”的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569024456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131978,"user_name":"小祺","can_delete":false,"product_type":"c1","uid":1193548,"ip_address":"","ucode":"2819BCA9E71C9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/4c/46c43cce.jpg","comment_is_top":false,"comment_ctime":1567998002,"is_pvip":false,"replies":[{"id":50559,"content":"这个幂等一定是包含存储部分的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568077462,"ip_address":"","comment_id":131978,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，文中好像只介绍了消费端实现幂等消费，但是没提到存储端幂等，也就是如果生产端的重试导致消息发送重复而在消息队列磁盘中重复存储的情况。\n1. 消息队列能不能保证不重复存储？\n2. 消息队列有没有必要保证存储幂等？是要都交给消费端解决吗","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466708,"discussion_content":"这个幂等一定是包含存储部分的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568077462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123394,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1565666956,"is_pvip":false,"replies":[{"id":45338,"content":"这种流水一般不能删除，如果数量太多影响查询消息，可以考虑按照账户ID来分表存储。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565744827,"ip_address":"","comment_id":123394,"utype":1}],"discussion_count":3,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"如何解决方案一和方案二日益增多的存储日志呀，有合适的删除策略吗","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466708,"discussion_content":"这个幂等一定是包含存储部分的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568077462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122673,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1565485332,"is_pvip":false,"replies":[{"id":45029,"content":"只要流水正确写入了，后续根据流水计算余额的业务逻辑可以不与写入流水在同一个事务中，即使是计算余额失败了，也可以根据流水从新计算。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565523585,"ip_address":"","comment_id":122673,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"方法一解决不了主动的重试问题吧，比如插入流水，执行业务，返回mq逻辑错误，触发重新消费，这时会发现流水已经存在了。所以这里插流水和业务逻辑也得在一个事务里啊，这跟方法三区别看来只是怎么去控制唯一性而已。忘解答，非常疑惑","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462651,"discussion_content":"这种流水一般不能删除，如果数量太多影响查询消息，可以考虑按照账户ID来分表存储。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565744827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041790,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/27/be/b666abb4.jpg","nickname":"tongZi","note":"","ucode":"8BBAE4FA37FF79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289404,"discussion_content":"请教个问题，方案一和方案二的存储日志指的是？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594089881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041790,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/27/be/b666abb4.jpg","nickname":"tongZi","note":"","ucode":"8BBAE4FA37FF79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289405,"discussion_content":"我暂时理解，方案一和方案二，应该是业务数据吗？方案三，会存储消息日志，算是存储日志吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594089980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121086,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1125189,"ip_address":"","ucode":"0617032294DC43","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg","comment_is_top":false,"comment_ctime":1565055808,"is_pvip":false,"replies":[{"id":44634,"content":"这个条件的数据一般是从消息中带回来的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565139261,"ip_address":"","comment_id":121086,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师，幂等的代码案例后面是否可以提供呢，第二种实现幂等的方式，消费端如何保留已经消费的条件呢？","like_count":0},{"had_liked":false,"id":120938,"user_name":"谢清","can_delete":false,"product_type":"c1","uid":1069849,"ip_address":"","ucode":"31B2862A790CEB","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/19/dec74631.jpg","comment_is_top":false,"comment_ctime":1565015769,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"exactly once，实现有性能损耗，并发高时易出现消息堆积；消息队列设计初衷是解决解耦，而解耦的对象往往是高并发，对性能要求较高的，从产品需求层面讲，消息队列设计更注重性能，而非精准（exactly once）；基础架构角度来说，关注点是占比大的需求（不能不发，可以重发），占比极小的需求（敏感型，只能触发一次）可以单独抽出来另外实现。最后，请教老师有没有比较具体的业务场景，非用这种exactly once不可的","like_count":19},{"had_liked":false,"id":208887,"user_name":"Shen","can_delete":false,"product_type":"c1","uid":1182167,"ip_address":"","ucode":"CFF7609A754392","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","comment_is_top":false,"comment_ctime":1587458270,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"业务系统本身得具有幂等性，不管是前端来的http请求还是其他业务系统发来的rpc请求，都有可能重复发送，业务系统在处理涉及交易等重要的业务逻辑时，要通过业务主键ID、业务单状态等进行幂等处理。","like_count":2},{"had_liked":false,"id":121805,"user_name":"Switch","can_delete":false,"product_type":"c1","uid":1250758,"ip_address":"","ucode":"EB9FFA94D2F24B","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/c6/f5c543ef.jpg","comment_is_top":false,"comment_ctime":1565226447,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"简而言之，大部分消息队列没必要做那么高的服务质量。\n控制级别更高的Exactly once，必须要在入队的时候做检查操作，会极大的降低消息队列的性能。除此之外，大部分场景下，Exactly once级别的服务质量足够了，如果不够，还是可以通过一些业务手段规避。\n","like_count":2},{"had_liked":false,"id":120701,"user_name":"geraltlaush","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1564977904,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"之前有个止盈止损的股票平仓问题，通过消息队列发送给平仓服务去平仓，当时还没考虑到重复平仓问题，现在看来可以用全局uuid来防止这个问题，因为平仓服务是单点的，所以不用考虑分布式系统的难题，不过如果后面平行扩展了就要考虑分布式事务了","like_count":2},{"had_liked":false,"id":120063,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1564766283,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"kafka就算用事务，也不能保证没有重复消费，它有可能发生rebalance时，消费了数据没有提交","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461615,"discussion_content":"这个条件的数据一般是从消息中带回来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565139261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276351,"user_name":"Curry不会投三分球","can_delete":false,"product_type":"c1","uid":2026531,"ip_address":"","ucode":"165C57E53CC879","user_header":"https://static001.geekbang.org/account/avatar/00/1e/ec/23/c575b915.jpg","comment_is_top":false,"comment_ctime":1611892713,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"高票答案是基于消息队列实现了exactly once的前提来解答的，而没有考虑消息队列如何实现exactly once。而消息队列实现exactly once本身也需要一定成本：因为消息的唯一性是业务定义的，消息队列如果要保证exactly once，需要感知业务（本文中幂等的做法，都是在业务上给出了消息唯一性的定义），这样消息队列就与业务系统就会有耦合。消息队列作为中间件，是不应该和业务系统产生耦合的。","like_count":1},{"had_liked":false,"id":232697,"user_name":"tongZi","can_delete":false,"product_type":"c1","uid":2041790,"ip_address":"","ucode":"8BBAE4FA37FF79","user_header":"https://static001.geekbang.org/account/avatar/00/1f/27/be/b666abb4.jpg","comment_is_top":false,"comment_ctime":1594091017,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师你好，现阶段学习完，理解；和关系数据库关联实现方式\n请大家多多指点\n1、方案一：根据数据库唯一键，幂等处理；消息体中，只需要包含业务字段就好，不需要加入额外辅助字段\n2、方案二：为更新数据设置前置条件；加版本号方式，消息体和数据库，都需要加入版本号字段；完成消费，自增更新版本号，标示已经消费完成。当是有个问题，这个业务场景订阅了两个topic，都要修改数据库这条数据，是需要设置两个辅助字段吗？还是不采用这种幂等处理了？\n3、方案三：guid方式；可以说是，就会完全建立一张消息消费日志表？消费消息之前就会根据guid校验，是否已经被消费？\n谢谢\n","like_count":1,"discussions":[{"author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327145,"discussion_content":"mark一下\n我感觉方案三建立消费日志表，第一条消息进来的时候应该insert，成功继续向下走进行业务逻辑（此时状态应该是消费中），执行完业务逻辑之后更新为消费完成，然后ack，在进行ack之前如果第二条重复消息进来，判断消费日志表状态。\n消费中或者消费成功直接返回ack，消费失败状态的话继续执行。\n此时会不会有这种问题，第二次的时候如果是消费中ack返回，下一时刻变为了消费失败？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605754174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121057,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1565053374,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"无处不在的check&amp;set","like_count":1},{"had_liked":false,"id":375433,"user_name":"麟","can_delete":false,"product_type":"c1","uid":1281071,"ip_address":"广东","ucode":"54453354227566","user_header":"https://static001.geekbang.org/account/avatar/00/13/8c/2f/68045a83.jpg","comment_is_top":false,"comment_ctime":1685461076,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"第三种解决方法里面为什么说分布式锁比较难以实现，消费者A在t0时刻消费消息时加上分布式锁，然后别的消费者B在t1时刻消费是检查到锁进行丢弃或者阻塞消息不行吗","like_count":0},{"had_liked":false,"id":121086,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1125189,"ip_address":"","ucode":"0617032294DC43","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg","comment_is_top":false,"comment_ctime":1565055808,"is_pvip":false,"replies":[{"id":44634,"content":"这个条件的数据一般是从消息中带回来的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565139261,"ip_address":"","comment_id":121086,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师，幂等的代码案例后面是否可以提供呢，第二种实现幂等的方式，消费端如何保留已经消费的条件呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461615,"discussion_content":"这个条件的数据一般是从消息中带回来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565139261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120938,"user_name":"谢清","can_delete":false,"product_type":"c1","uid":1069849,"ip_address":"","ucode":"31B2862A790CEB","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/19/dec74631.jpg","comment_is_top":false,"comment_ctime":1565015769,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"exactly once，实现有性能损耗，并发高时易出现消息堆积；消息队列设计初衷是解决解耦，而解耦的对象往往是高并发，对性能要求较高的，从产品需求层面讲，消息队列设计更注重性能，而非精准（exactly once）；基础架构角度来说，关注点是占比大的需求（不能不发，可以重发），占比极小的需求（敏感型，只能触发一次）可以单独抽出来另外实现。最后，请教老师有没有比较具体的业务场景，非用这种exactly once不可的","like_count":19},{"had_liked":false,"id":208887,"user_name":"Shen","can_delete":false,"product_type":"c1","uid":1182167,"ip_address":"","ucode":"CFF7609A754392","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","comment_is_top":false,"comment_ctime":1587458270,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"业务系统本身得具有幂等性，不管是前端来的http请求还是其他业务系统发来的rpc请求，都有可能重复发送，业务系统在处理涉及交易等重要的业务逻辑时，要通过业务主键ID、业务单状态等进行幂等处理。","like_count":2},{"had_liked":false,"id":121805,"user_name":"Switch","can_delete":false,"product_type":"c1","uid":1250758,"ip_address":"","ucode":"EB9FFA94D2F24B","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/c6/f5c543ef.jpg","comment_is_top":false,"comment_ctime":1565226447,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"简而言之，大部分消息队列没必要做那么高的服务质量。\n控制级别更高的Exactly once，必须要在入队的时候做检查操作，会极大的降低消息队列的性能。除此之外，大部分场景下，Exactly once级别的服务质量足够了，如果不够，还是可以通过一些业务手段规避。\n","like_count":2},{"had_liked":false,"id":120701,"user_name":"geraltlaush","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1564977904,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"之前有个止盈止损的股票平仓问题，通过消息队列发送给平仓服务去平仓，当时还没考虑到重复平仓问题，现在看来可以用全局uuid来防止这个问题，因为平仓服务是单点的，所以不用考虑分布式系统的难题，不过如果后面平行扩展了就要考虑分布式事务了","like_count":2},{"had_liked":false,"id":120063,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1564766283,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"kafka就算用事务，也不能保证没有重复消费，它有可能发生rebalance时，消费了数据没有提交","like_count":2,"discussions":[{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7004,"discussion_content":"那这种发生rebalance时未提交的消息，在新的consumer中重新消费会造成重复commit？ 这块kafka是如何处理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567251141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276351,"user_name":"Curry不会投三分球","can_delete":false,"product_type":"c1","uid":2026531,"ip_address":"","ucode":"165C57E53CC879","user_header":"https://static001.geekbang.org/account/avatar/00/1e/ec/23/c575b915.jpg","comment_is_top":false,"comment_ctime":1611892713,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"高票答案是基于消息队列实现了exactly once的前提来解答的，而没有考虑消息队列如何实现exactly once。而消息队列实现exactly once本身也需要一定成本：因为消息的唯一性是业务定义的，消息队列如果要保证exactly once，需要感知业务（本文中幂等的做法，都是在业务上给出了消息唯一性的定义），这样消息队列就与业务系统就会有耦合。消息队列作为中间件，是不应该和业务系统产生耦合的。","like_count":1},{"had_liked":false,"id":232697,"user_name":"tongZi","can_delete":false,"product_type":"c1","uid":2041790,"ip_address":"","ucode":"8BBAE4FA37FF79","user_header":"https://static001.geekbang.org/account/avatar/00/1f/27/be/b666abb4.jpg","comment_is_top":false,"comment_ctime":1594091017,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师你好，现阶段学习完，理解；和关系数据库关联实现方式\n请大家多多指点\n1、方案一：根据数据库唯一键，幂等处理；消息体中，只需要包含业务字段就好，不需要加入额外辅助字段\n2、方案二：为更新数据设置前置条件；加版本号方式，消息体和数据库，都需要加入版本号字段；完成消费，自增更新版本号，标示已经消费完成。当是有个问题，这个业务场景订阅了两个topic，都要修改数据库这条数据，是需要设置两个辅助字段吗？还是不采用这种幂等处理了？\n3、方案三：guid方式；可以说是，就会完全建立一张消息消费日志表？消费消息之前就会根据guid校验，是否已经被消费？\n谢谢\n","like_count":1,"discussions":[{"author":{"id":1000015,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","nickname":"又双叒叕是一年啊","note":"","ucode":"E067320E537DEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7004,"discussion_content":"那这种发生rebalance时未提交的消息，在新的consumer中重新消费会造成重复commit？ 这块kafka是如何处理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567251141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121057,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1565053374,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"无处不在的check&amp;set","like_count":1},{"had_liked":false,"id":375433,"user_name":"麟","can_delete":false,"product_type":"c1","uid":1281071,"ip_address":"广东","ucode":"54453354227566","user_header":"https://static001.geekbang.org/account/avatar/00/13/8c/2f/68045a83.jpg","comment_is_top":false,"comment_ctime":1685461076,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"第三种解决方法里面为什么说分布式锁比较难以实现，消费者A在t0时刻消费消息时加上分布式锁，然后别的消费者B在t1时刻消费是检查到锁进行丢弃或者阻塞消息不行吗","like_count":0,"discussions":[{"author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327145,"discussion_content":"mark一下\n我感觉方案三建立消费日志表，第一条消息进来的时候应该insert，成功继续向下走进行业务逻辑（此时状态应该是消费中），执行完业务逻辑之后更新为消费完成，然后ack，在进行ack之前如果第二条重复消息进来，判断消费日志表状态。\n消费中或者消费成功直接返回ack，消费失败状态的话继续执行。\n此时会不会有这种问题，第二次的时候如果是消费中ack返回，下一时刻变为了消费失败？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605754174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370686,"user_name":"InfoQ_11351e216def","can_delete":false,"product_type":"c1","uid":1564099,"ip_address":"山东","ucode":"B892C80C7E5D09","user_header":"","comment_is_top":false,"comment_ctime":1679109069,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"第二点，如果两个连续的消息对于同一个数据进行修改，那这个版本号或者余额是一样的，后续的消息无法感知前面未处理消息的状态。这样后续消息都被判重了，不就出现问题了吗？比如对于一个账户余额是500，先执行+100,然后再执行+100，两条消息都处于未消费状态，那么他们的前置条件都是500，那这样不就出现问题了吗？即使是通过版本号来做，他们看到的版本号也是同一个。","like_count":0},{"had_liked":false,"id":369211,"user_name":"小红帽","can_delete":false,"product_type":"c1","uid":1135290,"ip_address":"广东","ucode":"876000FB67C980","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/ba/440c0157.jpg","comment_is_top":false,"comment_ctime":1677225835,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"为什么大部分消息队列都选择只提供 At least once 的服务质量，而不是级别更高的 Exactly once 呢？\nCAP原理，把一致性改为最终一致性就好。\n我的理解是，分布式系统的交互本来就已经够复杂了，如果把这些低概率事件全部都由消息中间件考虑，那它得要多复杂，而且也会影响性能。（最重要当靠消息中间件应该做不到exactly once ，还是要消费者做相应的配合）","like_count":0},{"had_liked":false,"id":354576,"user_name":"Geek_a642d2","can_delete":false,"product_type":"c1","uid":2365013,"ip_address":"北京","ucode":"9B72A728FC9A31","user_header":"","comment_is_top":false,"comment_ctime":1660557628,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"全局唯一的ID，一般的MQ，比如rocketmq、kafka 都有自带的msg Id 吧","like_count":0},{"had_liked":false,"id":353833,"user_name":"别看我","can_delete":false,"product_type":"c1","uid":1238707,"ip_address":"福建","ucode":"8F6F014DEB4F7D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/b3/a3ae518f.jpg","comment_is_top":false,"comment_ctime":1659852096,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"影响性能，造成消息堆积","like_count":0},{"had_liked":false,"id":346368,"user_name":"NeverSeeYouAgainBUG","can_delete":false,"product_type":"c1","uid":2930836,"ip_address":"","ucode":"1B0E8CA284C181","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b8/94/d20583ef.jpg","comment_is_top":false,"comment_ctime":1653057625,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"真的 李玥老师的讲课风格真的太合我口味了，精炼又深入浅出，我爱你李玥老师","like_count":0},{"had_liked":false,"id":342405,"user_name":"摊牌","can_delete":false,"product_type":"c1","uid":1453182,"ip_address":"","ucode":"F142596BFE4594","user_header":"https://static001.geekbang.org/account/avatar/00/16/2c/7e/f1efd18b.jpg","comment_is_top":false,"comment_ctime":1650251239,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"如果由于网络问题或者其他，导致出现broker大面积出现重复消息，消费者端一般如何处理？","like_count":0},{"had_liked":false,"id":341030,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649302878,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"为什么大部分消息队列都选择只提供 At least once 的服务质量，而不是级别更高的 Exactly once 呢？\n\n有且仅有一次的 要求服务端在收到生产者推送的时候，就先确认是不是只推送了一次，有去重操作。然后消费的时候，需要消费者消费的时候再次判断是否消费过，然后服务端也是要确认。\n如果是最少发送一次的，在生成者到服务端就不需要确认，生产者要是发送失败了直接重新发送即可。这一端就不是那么严谨。但是对于消费者消费还是需要保证幂等性的消费。","like_count":0},{"had_liked":false,"id":341029,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649302618,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"在分布式系统中，分布式事务和分布式锁都是比较难解决的问题。\n我们的系统是分布式系统，在一些场景需要确保分布式事务，比如在基础服务添加企业，需要同步到用电服务，用水服务，如何确保事务，也就是数据的一致性，这里就存在分布式事务问题。\n如何解决这里的分布式事务问题：通过消息队列通知时候，在提交失败后首先要重试机制，多次重试不成功，则报错提示或者直接回滚业务数据。也是看具体业务场景。\n\n比如用户在财务模块充值，多次充值的时候，如何确认幂等性，不多冲，也不少冲，就是分布式锁的问题。如何解决分布式锁的问题，就是在调用的入口处，增加锁的判断。","like_count":0},{"had_liked":false,"id":340810,"user_name":"lxhxmf","can_delete":false,"product_type":"c1","uid":1098049,"ip_address":"","ucode":"15BC0AADC48869","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/wicH4ZZcMl8iaavjPldak0jxkm9tc19sjLiaGKsuicUNibEPbrvluaCIZnBCHLT61LBj6uic4lLibFau6U0v1ZxC6ZAqw/132","comment_is_top":false,"comment_ctime":1649154134,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"李老师，请教一个关于RocketMQ消息消费程序的问题，如果一个系统因业务场景比较多，把业务逻辑拆分了许多个topic,但是一个消费端程序只能订阅一个topic,导致生产环境启动了许多消息消费进程，占用了大量内存资源，请问这种多topic的场景，在不改变topic数量的前提下，有没有什么办法可以减少消费程序的数量？谢谢！","like_count":0},{"had_liked":false,"id":340730,"user_name":"再见理想","can_delete":false,"product_type":"c1","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1649084476,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"消息队列消息发送质量标准的三个级别：至多一次，至少一次，恰好一次。\n由于分布式网络的原因，消息丢失与重复时有发生，为保证数据的一致性，消费者端需要保证消息处理逻辑的幂等性。\n实现幂等性可以通过状态&#47;版本号判断，消息的唯一Id等方案","like_count":0},{"had_liked":false,"id":370686,"user_name":"InfoQ_11351e216def","can_delete":false,"product_type":"c1","uid":1564099,"ip_address":"山东","ucode":"B892C80C7E5D09","user_header":"","comment_is_top":false,"comment_ctime":1679109069,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"第二点，如果两个连续的消息对于同一个数据进行修改，那这个版本号或者余额是一样的，后续的消息无法感知前面未处理消息的状态。这样后续消息都被判重了，不就出现问题了吗？比如对于一个账户余额是500，先执行+100,然后再执行+100，两条消息都处于未消费状态，那么他们的前置条件都是500，那这样不就出现问题了吗？即使是通过版本号来做，他们看到的版本号也是同一个。","like_count":0},{"had_liked":false,"id":369211,"user_name":"小红帽","can_delete":false,"product_type":"c1","uid":1135290,"ip_address":"广东","ucode":"876000FB67C980","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/ba/440c0157.jpg","comment_is_top":false,"comment_ctime":1677225835,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"为什么大部分消息队列都选择只提供 At least once 的服务质量，而不是级别更高的 Exactly once 呢？\nCAP原理，把一致性改为最终一致性就好。\n我的理解是，分布式系统的交互本来就已经够复杂了，如果把这些低概率事件全部都由消息中间件考虑，那它得要多复杂，而且也会影响性能。（最重要当靠消息中间件应该做不到exactly once ，还是要消费者做相应的配合）","like_count":0},{"had_liked":false,"id":354576,"user_name":"Geek_a642d2","can_delete":false,"product_type":"c1","uid":2365013,"ip_address":"北京","ucode":"9B72A728FC9A31","user_header":"","comment_is_top":false,"comment_ctime":1660557628,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"全局唯一的ID，一般的MQ，比如rocketmq、kafka 都有自带的msg Id 吧","like_count":0},{"had_liked":false,"id":353833,"user_name":"别看我","can_delete":false,"product_type":"c1","uid":1238707,"ip_address":"福建","ucode":"8F6F014DEB4F7D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/b3/a3ae518f.jpg","comment_is_top":false,"comment_ctime":1659852096,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"影响性能，造成消息堆积","like_count":0},{"had_liked":false,"id":346368,"user_name":"NeverSeeYouAgainBUG","can_delete":false,"product_type":"c1","uid":2930836,"ip_address":"","ucode":"1B0E8CA284C181","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b8/94/d20583ef.jpg","comment_is_top":false,"comment_ctime":1653057625,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"真的 李玥老师的讲课风格真的太合我口味了，精炼又深入浅出，我爱你李玥老师","like_count":0},{"had_liked":false,"id":342405,"user_name":"摊牌","can_delete":false,"product_type":"c1","uid":1453182,"ip_address":"","ucode":"F142596BFE4594","user_header":"https://static001.geekbang.org/account/avatar/00/16/2c/7e/f1efd18b.jpg","comment_is_top":false,"comment_ctime":1650251239,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"如果由于网络问题或者其他，导致出现broker大面积出现重复消息，消费者端一般如何处理？","like_count":0},{"had_liked":false,"id":341030,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649302878,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"为什么大部分消息队列都选择只提供 At least once 的服务质量，而不是级别更高的 Exactly once 呢？\n\n有且仅有一次的 要求服务端在收到生产者推送的时候，就先确认是不是只推送了一次，有去重操作。然后消费的时候，需要消费者消费的时候再次判断是否消费过，然后服务端也是要确认。\n如果是最少发送一次的，在生成者到服务端就不需要确认，生产者要是发送失败了直接重新发送即可。这一端就不是那么严谨。但是对于消费者消费还是需要保证幂等性的消费。","like_count":0},{"had_liked":false,"id":341029,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649302618,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"在分布式系统中，分布式事务和分布式锁都是比较难解决的问题。\n我们的系统是分布式系统，在一些场景需要确保分布式事务，比如在基础服务添加企业，需要同步到用电服务，用水服务，如何确保事务，也就是数据的一致性，这里就存在分布式事务问题。\n如何解决这里的分布式事务问题：通过消息队列通知时候，在提交失败后首先要重试机制，多次重试不成功，则报错提示或者直接回滚业务数据。也是看具体业务场景。\n\n比如用户在财务模块充值，多次充值的时候，如何确认幂等性，不多冲，也不少冲，就是分布式锁的问题。如何解决分布式锁的问题，就是在调用的入口处，增加锁的判断。","like_count":0},{"had_liked":false,"id":340810,"user_name":"lxhxmf","can_delete":false,"product_type":"c1","uid":1098049,"ip_address":"","ucode":"15BC0AADC48869","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/wicH4ZZcMl8iaavjPldak0jxkm9tc19sjLiaGKsuicUNibEPbrvluaCIZnBCHLT61LBj6uic4lLibFau6U0v1ZxC6ZAqw/132","comment_is_top":false,"comment_ctime":1649154134,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"李老师，请教一个关于RocketMQ消息消费程序的问题，如果一个系统因业务场景比较多，把业务逻辑拆分了许多个topic,但是一个消费端程序只能订阅一个topic,导致生产环境启动了许多消息消费进程，占用了大量内存资源，请问这种多topic的场景，在不改变topic数量的前提下，有没有什么办法可以减少消费程序的数量？谢谢！","like_count":0},{"had_liked":false,"id":340730,"user_name":"再见理想","can_delete":false,"product_type":"c1","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1649084476,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"消息队列消息发送质量标准的三个级别：至多一次，至少一次，恰好一次。\n由于分布式网络的原因，消息丢失与重复时有发生，为保证数据的一致性，消费者端需要保证消息处理逻辑的幂等性。\n实现幂等性可以通过状态&#47;版本号判断，消息的唯一Id等方案","like_count":0},{"had_liked":false,"id":340205,"user_name":"白","can_delete":false,"product_type":"c1","uid":1159553,"ip_address":"","ucode":"F7A7BCFCDFDEF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/81/ae0277f1.jpg","comment_is_top":false,"comment_ctime":1648652329,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"但是，如果我们要更新的数据不是数值，或者我们要做一个比较复杂的更新操作怎么办？用什么作为前置判断条件呢？更加通用的方法是，给你的数据增加一个版本号属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等更新。\n\n老师你好，请问一下，消息中的版本号是哪里来的呢？消息与数据的版本号是怎么对应的","like_count":0},{"had_liked":false,"id":340191,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1648649730,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":8,"product_id":100032301,"comment_content":"思考题：\nMQ已经花了较大力气去做消息的不丢，如果再需要保障消息的仅消费一次，最终的投入成本很高，并且和将MQ引入分布式系统的初衷（异步、解耦合）相违背：\n（1）可能会影响消费者的性能——&gt;每次pull消息的时候都需要检查下这个消息是否被其他消费者消费；（2）如果在普通消费场景也实现事务反查的机制，对于业务消费者实例也是较大的成本。\n\n反过来说，如果让业务来实现幂等逻辑，每个业务都有自己的具体逻辑来规避，这样就将复杂度分摊到了具体的业务模块上，整体来看也是比较合理的。\n","like_count":0},{"had_liked":false,"id":339325,"user_name":"郎思明","can_delete":false,"product_type":"c1","uid":2353023,"ip_address":"","ucode":"16A6DA0FBEA0E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPK6DZqNE1YZmght5wicmXS9wrB2YSPdCgs8XZhvAHCCVInGt2CcF3t5owevHomzliamkrIRrLugnw/132","comment_is_top":false,"comment_ctime":1648036985,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"消费者端进行异常重试，也会有可能会阻塞正常的消息消费，造成消息积压。","like_count":0},{"had_liked":false,"id":333891,"user_name":"邱邱邱","can_delete":false,"product_type":"c1","uid":2611827,"ip_address":"","ucode":"828318EB2316EB","user_header":"https://static001.geekbang.org/account/avatar/00/27/da/73/7e7593a7.jpg","comment_is_top":false,"comment_ctime":1644571626,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"个人认为：从中间件角度出发，消息队列无法判断重复的消息是否异常情况","like_count":0},{"had_liked":false,"id":327003,"user_name":"Geek_5561c6","can_delete":false,"product_type":"c1","uid":2611550,"ip_address":"","ucode":"788F9ABEC27232","user_header":"","comment_is_top":false,"comment_ctime":1639830138,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师问下，哪些场景存在唯一约束和版本号都不能实现的幂等？必须要用记录并检查消费状态。","like_count":0},{"had_liked":false,"id":322570,"user_name":"Sam Fu","can_delete":false,"product_type":"c1","uid":1112676,"ip_address":"","ucode":"EA285A4943271F","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","comment_is_top":false,"comment_ctime":1637484947,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师给的幂等处理的建议太有用了。尤其是分布式系统，上下游接口的幂等就更为重要了。\n老师说的给余额增加的例子也很实用，我们的系统也是使用这个方法实现的。","like_count":0},{"had_liked":false,"id":305877,"user_name":"Geek_4b528b","can_delete":false,"product_type":"c1","uid":2638508,"ip_address":"","ucode":"46D7087E668477","user_header":"","comment_is_top":false,"comment_ctime":1628216748,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"我理解的CAS是更新完之后，比较更新完的结果与预期结果是否相同。例如课程中的例子，给账户500元加100元，如果这时消息重复了，有两个线程都在消费这条消息。如果是在更改数据库前比较，两个线程都会得到500元，然后都更新，则最后的结果会变成700元。但是如果是更新后再检查的情况，如果数据库使用了默认的隔离级别，不可重复读，那么他们在自己的事务内看到的都是500，不管对方有没提交，那最后也会得到700。所以这里要怎么做呢，给数据库加锁？","like_count":0},{"had_liked":false,"id":296128,"user_name":"dyml","can_delete":false,"product_type":"c1","uid":2558263,"ip_address":"","ucode":"DC3A083E7E4D95","user_header":"https://static001.geekbang.org/account/avatar/00/27/09/37/ce0e366c.jpg","comment_is_top":false,"comment_ctime":1622772961,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"我有一个疑问，加上前置条件来满足幂等性的方法，为什么不在生产端就完成处理逻辑，比如“加上前置条件余额等于500时余额加100”，改成“余额更新为600”不是从逻辑上更简单地保证了幂等性了吗？","like_count":0},{"had_liked":false,"id":294173,"user_name":"Kyle(","can_delete":false,"product_type":"c1","uid":1640978,"ip_address":"","ucode":"0C14C4C086CAA9","user_header":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","comment_is_top":false,"comment_ctime":1621817316,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师请问设置已消费状态和设置版本号好像没什么区别啊？都要去比较查询一次。是我哪里理解不透彻吗？望指点迷津，谢谢！","like_count":0},{"had_liked":false,"id":288482,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1618488095,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"因为在实际使用中 broker实现整好一次 不代表首尾两端即生产者+消费者是正好一次的。简单的理解就是牵涉业务的代码都会天然带入一些人为的干扰 再加上网络中的重试 发版带来的不确定性 所以大部分都选择做成最少一次，宁可消息多也绝不能做成消息丢","like_count":0},{"had_liked":false,"id":340205,"user_name":"白","can_delete":false,"product_type":"c1","uid":1159553,"ip_address":"","ucode":"F7A7BCFCDFDEF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/81/ae0277f1.jpg","comment_is_top":false,"comment_ctime":1648652329,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"但是，如果我们要更新的数据不是数值，或者我们要做一个比较复杂的更新操作怎么办？用什么作为前置判断条件呢？更加通用的方法是，给你的数据增加一个版本号属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等更新。\n\n老师你好，请问一下，消息中的版本号是哪里来的呢？消息与数据的版本号是怎么对应的","like_count":0},{"had_liked":false,"id":340191,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1648649730,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":8,"product_id":100032301,"comment_content":"思考题：\nMQ已经花了较大力气去做消息的不丢，如果再需要保障消息的仅消费一次，最终的投入成本很高，并且和将MQ引入分布式系统的初衷（异步、解耦合）相违背：\n（1）可能会影响消费者的性能——&gt;每次pull消息的时候都需要检查下这个消息是否被其他消费者消费；（2）如果在普通消费场景也实现事务反查的机制，对于业务消费者实例也是较大的成本。\n\n反过来说，如果让业务来实现幂等逻辑，每个业务都有自己的具体逻辑来规避，这样就将复杂度分摊到了具体的业务模块上，整体来看也是比较合理的。\n","like_count":0},{"had_liked":false,"id":339325,"user_name":"郎思明","can_delete":false,"product_type":"c1","uid":2353023,"ip_address":"","ucode":"16A6DA0FBEA0E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPK6DZqNE1YZmght5wicmXS9wrB2YSPdCgs8XZhvAHCCVInGt2CcF3t5owevHomzliamkrIRrLugnw/132","comment_is_top":false,"comment_ctime":1648036985,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"消费者端进行异常重试，也会有可能会阻塞正常的消息消费，造成消息积压。","like_count":0},{"had_liked":false,"id":333891,"user_name":"邱邱邱","can_delete":false,"product_type":"c1","uid":2611827,"ip_address":"","ucode":"828318EB2316EB","user_header":"https://static001.geekbang.org/account/avatar/00/27/da/73/7e7593a7.jpg","comment_is_top":false,"comment_ctime":1644571626,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"个人认为：从中间件角度出发，消息队列无法判断重复的消息是否异常情况","like_count":0},{"had_liked":false,"id":327003,"user_name":"Geek_5561c6","can_delete":false,"product_type":"c1","uid":2611550,"ip_address":"","ucode":"788F9ABEC27232","user_header":"","comment_is_top":false,"comment_ctime":1639830138,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师问下，哪些场景存在唯一约束和版本号都不能实现的幂等？必须要用记录并检查消费状态。","like_count":0},{"had_liked":false,"id":322570,"user_name":"Sam Fu","can_delete":false,"product_type":"c1","uid":1112676,"ip_address":"","ucode":"EA285A4943271F","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","comment_is_top":false,"comment_ctime":1637484947,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师给的幂等处理的建议太有用了。尤其是分布式系统，上下游接口的幂等就更为重要了。\n老师说的给余额增加的例子也很实用，我们的系统也是使用这个方法实现的。","like_count":0},{"had_liked":false,"id":305877,"user_name":"Geek_4b528b","can_delete":false,"product_type":"c1","uid":2638508,"ip_address":"","ucode":"46D7087E668477","user_header":"","comment_is_top":false,"comment_ctime":1628216748,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"我理解的CAS是更新完之后，比较更新完的结果与预期结果是否相同。例如课程中的例子，给账户500元加100元，如果这时消息重复了，有两个线程都在消费这条消息。如果是在更改数据库前比较，两个线程都会得到500元，然后都更新，则最后的结果会变成700元。但是如果是更新后再检查的情况，如果数据库使用了默认的隔离级别，不可重复读，那么他们在自己的事务内看到的都是500，不管对方有没提交，那最后也会得到700。所以这里要怎么做呢，给数据库加锁？","like_count":0},{"had_liked":false,"id":296128,"user_name":"dyml","can_delete":false,"product_type":"c1","uid":2558263,"ip_address":"","ucode":"DC3A083E7E4D95","user_header":"https://static001.geekbang.org/account/avatar/00/27/09/37/ce0e366c.jpg","comment_is_top":false,"comment_ctime":1622772961,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"我有一个疑问，加上前置条件来满足幂等性的方法，为什么不在生产端就完成处理逻辑，比如“加上前置条件余额等于500时余额加100”，改成“余额更新为600”不是从逻辑上更简单地保证了幂等性了吗？","like_count":0},{"had_liked":false,"id":294173,"user_name":"Kyle(","can_delete":false,"product_type":"c1","uid":1640978,"ip_address":"","ucode":"0C14C4C086CAA9","user_header":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","comment_is_top":false,"comment_ctime":1621817316,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师请问设置已消费状态和设置版本号好像没什么区别啊？都要去比较查询一次。是我哪里理解不透彻吗？望指点迷津，谢谢！","like_count":0},{"had_liked":false,"id":288482,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1618488095,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"因为在实际使用中 broker实现整好一次 不代表首尾两端即生产者+消费者是正好一次的。简单的理解就是牵涉业务的代码都会天然带入一些人为的干扰 再加上网络中的重试 发版带来的不确定性 所以大部分都选择做成最少一次，宁可消息多也绝不能做成消息丢","like_count":0},{"had_liked":false,"id":278158,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1612778747,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"还是方案二好 成本比较低","like_count":0},{"had_liked":false,"id":276344,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1611890558,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"毕竟消息队列不应该去保证幂等性,需要保证操作幂等的是服务,不能将自己的生杀大权交给外人","like_count":0},{"had_liked":false,"id":265937,"user_name":"Javatar","can_delete":false,"product_type":"c1","uid":2032840,"ip_address":"","ucode":"E216645CDF632C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","comment_is_top":false,"comment_ctime":1607071927,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"评论中主要提到的都是做到“Exactly once”没必要。但实际上，作为一个中间件，真正想实现“Exactly once”，也很难吧。难度基本上等同mysql主从延迟要达到0。\n这根本不可能。这都是分布式系统固有的特点，也就是状态想要达到一致需要网络通信，但这需要时间。所以如果想做到只能单机。","like_count":0},{"had_liked":false,"id":257615,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1604043966,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"根据mqtt,设计的消息队列，大部分对于消息的发送要求是at least.\n要做到，上面的at least 的方法有：把消费端的业务设计成幂等性的。\n方法有：\n1 对于要更新表的操作，可以利用数据库唯一约束实现幂等性。\n2 为更新的数据设置检查条件。\n3 记录和更新操作。这个主要是在接收到消息之后，先去判断这条消息是否消费过。\n自己感觉为了实现第三条，相当于又引入了一个分布式的一致性系统，所以这个实现起来没有前两个简单。\n","like_count":0},{"had_liked":false,"id":255006,"user_name":"haijian.yang","can_delete":false,"product_type":"c1","uid":1162081,"ip_address":"","ucode":"E3D13ABA2CA347","user_header":"https://static001.geekbang.org/account/avatar/00/11/bb/61/2c2f5024.jpg","comment_is_top":false,"comment_ctime":1603249072,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"幂等还有时效性一说，比如一分钟、一天、一个月内。","like_count":0},{"had_liked":false,"id":249383,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1600617334,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"At least once 比较中庸，不极端，可通过业务代码幂等性进行扩展。","like_count":0},{"had_liked":false,"id":231767,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1593767206,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"出于系统性能方面的考虑。","like_count":0},{"had_liked":false,"id":226485,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1592119808,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"关于使用版本号做控制我有一个疑问\na. 我认为是更新前需要先获取一下版本号，然后在根据获取到的版本号跟数据库的做对比\nb. 如果两次重复消息间隔时间较长，那么很有可能第二次consumer获取到的version，是第一次consumer是我提交后的version，那这样的话，依旧可以更新成功，没有实现幂等性\n\n请老师解惑","like_count":0},{"had_liked":false,"id":223400,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1065986,"ip_address":"","ucode":"3D3D10273BED18","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/02/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1591082248,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"解决重复消息方法，1和3很类似，只不过一个1 是 先存记录 后处理，确认消息 ，方法3 先处理，存记录，确认消息，\n\n另外文中 方法1 可以异步操作余额 和使用 redis setnx 没理解是怎么保证只加100元的\n\n方法2感觉没法使用，因为需要保证发消息时，前面的消息必须已被处理了，这样version才是最新的，不然会出现二条发送的消息具有相同的version，就没法处理，感觉这种不符合异步的需求，消息队列不是并发处理\n\n我自己理解的方法1，3 如果使用事务都OK \n\n如果不使用事务，可能出现异常点\n\n情况1  记录存储了，异常，没有处理消息，这样会出现用户余额没有加\n\n情况2  处理消息，异常，没有存储记录， 其他机器将会重复消费消息，用户余额加200元\n\n需要其他办法来校正， 或者 记录和处理消息合并为一条记录 ","like_count":0},{"had_liked":false,"id":215494,"user_name":"lupguo","can_delete":false,"product_type":"c1","uid":1009098,"ip_address":"","ucode":"1B55A01DF78647","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/ca/38dcd55a.jpg","comment_is_top":false,"comment_ctime":1589001392,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"课后题，性能与可靠性的折衷，精确一次涉及检查，需要引消费者的响应结果，增加了系统耦合。同时由于映入精确推送次数，会涉及推送记录结果状态的保存，整体系统的复杂度设计提高，检查和状态存储会导致整体消息系统的吞吐量也会降低。","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376062,"discussion_content":"分布式下做到Exactly once很难，就像分布式下的数据一致性问题一样\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621947304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278158,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1612778747,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"还是方案二好 成本比较低","like_count":0},{"had_liked":false,"id":276344,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1611890558,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"毕竟消息队列不应该去保证幂等性,需要保证操作幂等的是服务,不能将自己的生杀大权交给外人","like_count":0},{"had_liked":false,"id":265937,"user_name":"Javatar","can_delete":false,"product_type":"c1","uid":2032840,"ip_address":"","ucode":"E216645CDF632C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","comment_is_top":false,"comment_ctime":1607071927,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"评论中主要提到的都是做到“Exactly once”没必要。但实际上，作为一个中间件，真正想实现“Exactly once”，也很难吧。难度基本上等同mysql主从延迟要达到0。\n这根本不可能。这都是分布式系统固有的特点，也就是状态想要达到一致需要网络通信，但这需要时间。所以如果想做到只能单机。","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376062,"discussion_content":"分布式下做到Exactly once很难，就像分布式下的数据一致性问题一样\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621947304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257615,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1604043966,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"根据mqtt,设计的消息队列，大部分对于消息的发送要求是at least.\n要做到，上面的at least 的方法有：把消费端的业务设计成幂等性的。\n方法有：\n1 对于要更新表的操作，可以利用数据库唯一约束实现幂等性。\n2 为更新的数据设置检查条件。\n3 记录和更新操作。这个主要是在接收到消息之后，先去判断这条消息是否消费过。\n自己感觉为了实现第三条，相当于又引入了一个分布式的一致性系统，所以这个实现起来没有前两个简单。\n","like_count":0},{"had_liked":false,"id":255006,"user_name":"haijian.yang","can_delete":false,"product_type":"c1","uid":1162081,"ip_address":"","ucode":"E3D13ABA2CA347","user_header":"https://static001.geekbang.org/account/avatar/00/11/bb/61/2c2f5024.jpg","comment_is_top":false,"comment_ctime":1603249072,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"幂等还有时效性一说，比如一分钟、一天、一个月内。","like_count":0},{"had_liked":false,"id":249383,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1600617334,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"At least once 比较中庸，不极端，可通过业务代码幂等性进行扩展。","like_count":0},{"had_liked":false,"id":231767,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1593767206,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"出于系统性能方面的考虑。","like_count":0},{"had_liked":false,"id":226485,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1592119808,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"关于使用版本号做控制我有一个疑问\na. 我认为是更新前需要先获取一下版本号，然后在根据获取到的版本号跟数据库的做对比\nb. 如果两次重复消息间隔时间较长，那么很有可能第二次consumer获取到的version，是第一次consumer是我提交后的version，那这样的话，依旧可以更新成功，没有实现幂等性\n\n请老师解惑","like_count":0},{"had_liked":false,"id":223400,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1065986,"ip_address":"","ucode":"3D3D10273BED18","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/02/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1591082248,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"解决重复消息方法，1和3很类似，只不过一个1 是 先存记录 后处理，确认消息 ，方法3 先处理，存记录，确认消息，\n\n另外文中 方法1 可以异步操作余额 和使用 redis setnx 没理解是怎么保证只加100元的\n\n方法2感觉没法使用，因为需要保证发消息时，前面的消息必须已被处理了，这样version才是最新的，不然会出现二条发送的消息具有相同的version，就没法处理，感觉这种不符合异步的需求，消息队列不是并发处理\n\n我自己理解的方法1，3 如果使用事务都OK \n\n如果不使用事务，可能出现异常点\n\n情况1  记录存储了，异常，没有处理消息，这样会出现用户余额没有加\n\n情况2  处理消息，异常，没有存储记录， 其他机器将会重复消费消息，用户余额加200元\n\n需要其他办法来校正， 或者 记录和处理消息合并为一条记录 ","like_count":0},{"had_liked":false,"id":215494,"user_name":"lupguo","can_delete":false,"product_type":"c1","uid":1009098,"ip_address":"","ucode":"1B55A01DF78647","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/ca/38dcd55a.jpg","comment_is_top":false,"comment_ctime":1589001392,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"课后题，性能与可靠性的折衷，精确一次涉及检查，需要引消费者的响应结果，增加了系统耦合。同时由于映入精确推送次数，会涉及推送记录结果状态的保存，整体系统的复杂度设计提高，检查和状态存储会导致整体消息系统的吞吐量也会降低。","like_count":0},{"had_liked":false,"id":208733,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1587430845,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"我觉得是因为，分布式系统中，我们无法都所有的情况做到预估，只能尽力的去优化。就拿exactly once来说，要处理的问题有很多，必然会影响到系统的性能，并且总会出现一些不可预估的情况，这样倒不如，保证消息系统的简单行和准确性，其他的事情交给下游来处理。","like_count":0},{"had_liked":false,"id":207465,"user_name":"AlfredLover","can_delete":false,"product_type":"c1","uid":1042354,"ip_address":"","ucode":"A3A998F362CC37","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/b2/334bc992.jpg","comment_is_top":false,"comment_ctime":1587089507,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"越严谨的检查，效率、性能必然会下降。","like_count":0},{"had_liked":false,"id":200250,"user_name":"陆江","can_delete":false,"product_type":"c1","uid":1918835,"ip_address":"","ucode":"0F2F8D21D4C1AC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK310IyFbYZjgYgDvaxibZOic5zbk28FpjLfccfYMSAgt11kd3jicA4Db3NbF8lLl4Cs9m6uRY7EFVWA/132","comment_is_top":false,"comment_ctime":1585563111,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"重复消息问题一多般用分布式锁解决把， 像Python里的celery异步任务队列也有这问题，后来引入进化版本的celery-once内部就是采用分布式锁解决的重复消费问题","like_count":0},{"had_liked":false,"id":161280,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1576164485,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"这节讲解的幂等性，对于所有符合消费消息模型特征的业务需求都很有意义。","like_count":0},{"had_liked":false,"id":144328,"user_name":"Geek_4e0414","can_delete":false,"product_type":"c1","uid":1610074,"ip_address":"","ucode":"F8FF198C99889E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epQmKdgQvF1Qbthe1TdKoEj9YTgVGVwatOXs8arv2Zud7Y5ibibiaiaa67gianCtibgNz3mnIAfic15dlObQ/132","comment_is_top":false,"comment_ctime":1571898425,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"首先，如果实现了exactly once ，那么MQ系统必须去实现幂等性，那么在常用的MQ部署情况来看，往往是分布式集群部署的，这个就给幂等性的实现带来了巨大的成本，也就是降低了MQ的性能\n其次，哪怕MQ实现了Exactly once，消费的业务系统也需要实现幂等，那么从整个业务流程中来看，大大降低了服务器的处理能力，得不偿失\n最后，在我看来，服务标准如果按照性能来由高到低排序的话应该是At most once》At least once》Exactly once。提供中间性能的服务，我认为是最明智的，既不影响性能，又保证了可靠性","like_count":0},{"had_liked":false,"id":135227,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1569071430,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"为什么不使用Exactly Once？我理解重复分两种：生产重复和消费重复。对于生产重复，如果想解决，我感觉需要客户端配合，比如客户端为每个消息设置全局唯一键，由消息队列检查此唯一键去重。对于消费重复，如果要实现只能取一次，则ACK失败后需要客户端提供回调让消息队列去检查是否消费，要想办法处理这些消息，也容易造成消息积压。总体来说，实现成本高，收益不大","like_count":0},{"had_liked":false,"id":134752,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1568908769,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师，恳请您解答一下我的疑问。😭😭😭","like_count":0},{"had_liked":false,"id":132894,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1568262451,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"Exactly once是不存在的吧 ....\n\n重复消息的处理手段,使用最广的应该就是CAS理论吧","like_count":0},{"had_liked":false,"id":132694,"user_name":"顶新","can_delete":false,"product_type":"c1","uid":1036566,"ip_address":"","ucode":"241D3CCCAE536B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/16/6347bbc0.jpg","comment_is_top":false,"comment_ctime":1568194960,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"消息中间件不实现 Exactly once ，是因为这个一般属于业务系统考虑的范畴，消息中间件只需要做好自己本分工作就行，同时也有基于性能方面的权衡考虑。","like_count":0},{"had_liked":false,"id":126097,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566312715,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"1：消息队列很难保证消息不重复？\n在 MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：\n1-1：At most once: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。\n1-2：At least once: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。\n1-3：Exactly once：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。\n这个服务质量标准不仅适用于 MQTT，对所有的消息队列都是适用的。我们现在常用的绝大部分消息队列提供的服务质量都是 At least once，包括 RocketMQ、RabbitMQ 和 Kafka 都是这样。也就是说，消息队列很难保证消息不重复。\n这个观点比较自然，不过之前自己也不太清楚，小记一下，加深印象。\n2：消息重复很难避免，那怎么防重？\n2-1：消费逻辑天然幂等，啥都不怕，重复就重复呗\n2-2：利用数据库唯一索引防重\n2-3：利用业务唯一标识防重\n2-4：利用前置条件防重\n2-5：利用版本号防重\n\n3：为什么消息队列不实现恰好一次的保证哪？\n3-1：不好实现，网络环境复杂\n3-2：实现也行，性能会损耗一些\n3-3：不实现也行，部分业务不需要\n","like_count":0,"discussions":[{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181327,"discussion_content":"最少一次保证了消息不会丢失，幂等消费保证了消费准确。不然即使实现了精确一次，但还是需要保证幂等消息。既然如此，那发布消息的时候可以做轻松一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582361237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208733,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1587430845,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"我觉得是因为，分布式系统中，我们无法都所有的情况做到预估，只能尽力的去优化。就拿exactly once来说，要处理的问题有很多，必然会影响到系统的性能，并且总会出现一些不可预估的情况，这样倒不如，保证消息系统的简单行和准确性，其他的事情交给下游来处理。","like_count":0},{"had_liked":false,"id":207465,"user_name":"AlfredLover","can_delete":false,"product_type":"c1","uid":1042354,"ip_address":"","ucode":"A3A998F362CC37","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/b2/334bc992.jpg","comment_is_top":false,"comment_ctime":1587089507,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"越严谨的检查，效率、性能必然会下降。","like_count":0},{"had_liked":false,"id":200250,"user_name":"陆江","can_delete":false,"product_type":"c1","uid":1918835,"ip_address":"","ucode":"0F2F8D21D4C1AC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK310IyFbYZjgYgDvaxibZOic5zbk28FpjLfccfYMSAgt11kd3jicA4Db3NbF8lLl4Cs9m6uRY7EFVWA/132","comment_is_top":false,"comment_ctime":1585563111,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"重复消息问题一多般用分布式锁解决把， 像Python里的celery异步任务队列也有这问题，后来引入进化版本的celery-once内部就是采用分布式锁解决的重复消费问题","like_count":0},{"had_liked":false,"id":161280,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1576164485,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"这节讲解的幂等性，对于所有符合消费消息模型特征的业务需求都很有意义。","like_count":0},{"had_liked":false,"id":144328,"user_name":"Geek_4e0414","can_delete":false,"product_type":"c1","uid":1610074,"ip_address":"","ucode":"F8FF198C99889E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epQmKdgQvF1Qbthe1TdKoEj9YTgVGVwatOXs8arv2Zud7Y5ibibiaiaa67gianCtibgNz3mnIAfic15dlObQ/132","comment_is_top":false,"comment_ctime":1571898425,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"首先，如果实现了exactly once ，那么MQ系统必须去实现幂等性，那么在常用的MQ部署情况来看，往往是分布式集群部署的，这个就给幂等性的实现带来了巨大的成本，也就是降低了MQ的性能\n其次，哪怕MQ实现了Exactly once，消费的业务系统也需要实现幂等，那么从整个业务流程中来看，大大降低了服务器的处理能力，得不偿失\n最后，在我看来，服务标准如果按照性能来由高到低排序的话应该是At most once》At least once》Exactly once。提供中间性能的服务，我认为是最明智的，既不影响性能，又保证了可靠性","like_count":0,"discussions":[{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181327,"discussion_content":"最少一次保证了消息不会丢失，幂等消费保证了消费准确。不然即使实现了精确一次，但还是需要保证幂等消息。既然如此，那发布消息的时候可以做轻松一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582361237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135227,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1569071430,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"为什么不使用Exactly Once？我理解重复分两种：生产重复和消费重复。对于生产重复，如果想解决，我感觉需要客户端配合，比如客户端为每个消息设置全局唯一键，由消息队列检查此唯一键去重。对于消费重复，如果要实现只能取一次，则ACK失败后需要客户端提供回调让消息队列去检查是否消费，要想办法处理这些消息，也容易造成消息积压。总体来说，实现成本高，收益不大","like_count":0},{"had_liked":false,"id":134752,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1568908769,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师，恳请您解答一下我的疑问。😭😭😭","like_count":0},{"had_liked":false,"id":132894,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1568262451,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"Exactly once是不存在的吧 ....\n\n重复消息的处理手段,使用最广的应该就是CAS理论吧","like_count":0},{"had_liked":false,"id":132694,"user_name":"顶新","can_delete":false,"product_type":"c1","uid":1036566,"ip_address":"","ucode":"241D3CCCAE536B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/16/6347bbc0.jpg","comment_is_top":false,"comment_ctime":1568194960,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"消息中间件不实现 Exactly once ，是因为这个一般属于业务系统考虑的范畴，消息中间件只需要做好自己本分工作就行，同时也有基于性能方面的权衡考虑。","like_count":0},{"had_liked":false,"id":126097,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566312715,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"1：消息队列很难保证消息不重复？\n在 MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：\n1-1：At most once: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。\n1-2：At least once: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。\n1-3：Exactly once：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。\n这个服务质量标准不仅适用于 MQTT，对所有的消息队列都是适用的。我们现在常用的绝大部分消息队列提供的服务质量都是 At least once，包括 RocketMQ、RabbitMQ 和 Kafka 都是这样。也就是说，消息队列很难保证消息不重复。\n这个观点比较自然，不过之前自己也不太清楚，小记一下，加深印象。\n2：消息重复很难避免，那怎么防重？\n2-1：消费逻辑天然幂等，啥都不怕，重复就重复呗\n2-2：利用数据库唯一索引防重\n2-3：利用业务唯一标识防重\n2-4：利用前置条件防重\n2-5：利用版本号防重\n\n3：为什么消息队列不实现恰好一次的保证哪？\n3-1：不好实现，网络环境复杂\n3-2：实现也行，性能会损耗一些\n3-3：不实现也行，部分业务不需要\n","like_count":0,"discussions":[{"author":{"id":1036566,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d1/16/6347bbc0.jpg","nickname":"顶新","note":"","ucode":"241D3CCCAE536B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9595,"discussion_content":"不实现 Exactly once ，是因为这个一般属于业务系统考虑的范畴，中间件只需要做好自己本分工作就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568194234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125983,"user_name":"dykw","can_delete":false,"product_type":"c1","uid":1412912,"ip_address":"","ucode":"513D787379E158","user_header":"https://static001.geekbang.org/account/avatar/00/15/8f/30/ae34a463.jpg","comment_is_top":false,"comment_ctime":1566289280,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"避免做重复的操作，造成资源浪费，而且就算实现了exactly once，也会引起其他的问题，消息的消费速度，消息的积压等等，索性都留着业务端自己去处理","like_count":0},{"had_liked":false,"id":125546,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1566201853,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"exactly once实现不了其实是通信的不可靠性：进程间的通信、网络的通信都有可能失败。","like_count":0},{"had_liked":false,"id":124651,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1565938039,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"服务的幂等性  ","like_count":0},{"had_liked":false,"id":122888,"user_name":"15921099784","can_delete":false,"product_type":"c1","uid":1213561,"ip_address":"","ucode":"5B7E4CE89086F4","user_header":"","comment_is_top":false,"comment_ctime":1565570374,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"打卡，实现幂等的三种方式学习了。另，如果消息语句能做成声明式而不是命令式，幂等问题就不存在了…","like_count":0},{"had_liked":false,"id":122848,"user_name":"Stenvien","can_delete":false,"product_type":"c1","uid":1083774,"ip_address":"","ucode":"8B8E33D517D1AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/7e/f41ca6b5.jpg","comment_is_top":false,"comment_ctime":1565542942,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"说下我对方法1、方法3的理解：\n\n方法1，需要消费者基于消息类型，去感知此消息类型所要处理的业务，在业务上的唯一约束，不同业务的唯一约束不一样，对消费者实现幂等不友好。\n\n方法3，由生产者将不同业务的不同唯一约束（如A业务是a+b字段须唯一，B业务是a+c字段须唯一），统一处理成对消费者友好的全局唯一ID，如A业务是md5(a+b)，B业务是md5(a+c)。生成全局唯一ID，可以是上面举例的本地md5计算，也可以是包装成服务接口，但其本身也必须是幂等的，这样一来，消费者不管处理什么业务消息，都只需要针对&quot;全局唯一ID&quot;来保证幂等即可。","like_count":0},{"had_liked":false,"id":122592,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1565430700,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"解决exactly once需要的并不是仅仅服务端的实现，还需要客户端的配合。并且是以牺牲或多或少高性能的前提。\n实际场景中高性能是必然的需求，并且exactly once是可以通过at least once加业务处理来实现。","like_count":0},{"had_liked":false,"id":122490,"user_name":"Geek_流沙","can_delete":false,"product_type":"c1","uid":1613145,"ip_address":"","ucode":"677D40F2F2D00E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI64XUGp3cKv6LnMCEicZia1DfIPiaONeV0egjPKZ3HZzHkMHv3ia3bq657Wdg8GShBvPEHIOGib6ojEwg/132","comment_is_top":false,"comment_ctime":1565406557,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"exactly one需要客户端逻辑正确实现。而消息队列又保证不了自己的客户端是如何实现的。","like_count":0},{"had_liked":false,"id":121183,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1565072682,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"打卡7\n","like_count":0},{"had_liked":false,"id":121083,"user_name":"大魔王汪汪","can_delete":false,"product_type":"c1","uid":1010680,"ip_address":"","ucode":"4B205CB52FC95F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","comment_is_top":false,"comment_ctime":1565055149,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"性能考虑，本身中间件是为了解决基础问题，不用讲一些业务逻辑强行绑定到中间件","like_count":0},{"had_liked":false,"id":120999,"user_name":"Geek_8e39fa","can_delete":false,"product_type":"c1","uid":1103471,"ip_address":"","ucode":"F7DD82492B571A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/6f/3ceb76b3.jpg","comment_is_top":false,"comment_ctime":1565048340,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"对于转账的例子，不知道我的理解是否正确，对于相同账户转账，是完全可以有相同数据存在，即转账流水一摸一样。从转账流水做法来看，都需要消息发生方提供唯一流水码来保证数据的唯一性和后续操作的幂等性。","like_count":0},{"had_liked":false,"id":125983,"user_name":"dykw","can_delete":false,"product_type":"c1","uid":1412912,"ip_address":"","ucode":"513D787379E158","user_header":"https://static001.geekbang.org/account/avatar/00/15/8f/30/ae34a463.jpg","comment_is_top":false,"comment_ctime":1566289280,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"避免做重复的操作，造成资源浪费，而且就算实现了exactly once，也会引起其他的问题，消息的消费速度，消息的积压等等，索性都留着业务端自己去处理","like_count":0},{"had_liked":false,"id":125546,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1566201853,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"exactly once实现不了其实是通信的不可靠性：进程间的通信、网络的通信都有可能失败。","like_count":0},{"had_liked":false,"id":124651,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1565938039,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"服务的幂等性  ","like_count":0},{"had_liked":false,"id":122888,"user_name":"15921099784","can_delete":false,"product_type":"c1","uid":1213561,"ip_address":"","ucode":"5B7E4CE89086F4","user_header":"","comment_is_top":false,"comment_ctime":1565570374,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"打卡，实现幂等的三种方式学习了。另，如果消息语句能做成声明式而不是命令式，幂等问题就不存在了…","like_count":0},{"had_liked":false,"id":122848,"user_name":"Stenvien","can_delete":false,"product_type":"c1","uid":1083774,"ip_address":"","ucode":"8B8E33D517D1AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/7e/f41ca6b5.jpg","comment_is_top":false,"comment_ctime":1565542942,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"说下我对方法1、方法3的理解：\n\n方法1，需要消费者基于消息类型，去感知此消息类型所要处理的业务，在业务上的唯一约束，不同业务的唯一约束不一样，对消费者实现幂等不友好。\n\n方法3，由生产者将不同业务的不同唯一约束（如A业务是a+b字段须唯一，B业务是a+c字段须唯一），统一处理成对消费者友好的全局唯一ID，如A业务是md5(a+b)，B业务是md5(a+c)。生成全局唯一ID，可以是上面举例的本地md5计算，也可以是包装成服务接口，但其本身也必须是幂等的，这样一来，消费者不管处理什么业务消息，都只需要针对&quot;全局唯一ID&quot;来保证幂等即可。","like_count":0},{"had_liked":false,"id":122592,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1565430700,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"解决exactly once需要的并不是仅仅服务端的实现，还需要客户端的配合。并且是以牺牲或多或少高性能的前提。\n实际场景中高性能是必然的需求，并且exactly once是可以通过at least once加业务处理来实现。","like_count":0},{"had_liked":false,"id":122490,"user_name":"Geek_流沙","can_delete":false,"product_type":"c1","uid":1613145,"ip_address":"","ucode":"677D40F2F2D00E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI64XUGp3cKv6LnMCEicZia1DfIPiaONeV0egjPKZ3HZzHkMHv3ia3bq657Wdg8GShBvPEHIOGib6ojEwg/132","comment_is_top":false,"comment_ctime":1565406557,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"exactly one需要客户端逻辑正确实现。而消息队列又保证不了自己的客户端是如何实现的。","like_count":0},{"had_liked":false,"id":121183,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1565072682,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"打卡7\n","like_count":0},{"had_liked":false,"id":121083,"user_name":"大魔王汪汪","can_delete":false,"product_type":"c1","uid":1010680,"ip_address":"","ucode":"4B205CB52FC95F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","comment_is_top":false,"comment_ctime":1565055149,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"性能考虑，本身中间件是为了解决基础问题，不用讲一些业务逻辑强行绑定到中间件","like_count":0},{"had_liked":false,"id":120999,"user_name":"Geek_8e39fa","can_delete":false,"product_type":"c1","uid":1103471,"ip_address":"","ucode":"F7DD82492B571A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/6f/3ceb76b3.jpg","comment_is_top":false,"comment_ctime":1565048340,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"对于转账的例子，不知道我的理解是否正确，对于相同账户转账，是完全可以有相同数据存在，即转账流水一摸一样。从转账流水做法来看，都需要消息发生方提供唯一流水码来保证数据的唯一性和后续操作的幂等性。","like_count":0},{"had_liked":false,"id":120872,"user_name":"史双龙","can_delete":false,"product_type":"c1","uid":1176417,"ip_address":"","ucode":"387D01880867AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/61/8f7fca5b.jpg","comment_is_top":false,"comment_ctime":1565007790,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"根据具体问题具体实现幂等性，这块不单单是在消息队列消费的逻辑里面提现，其他业务里面也最好都要又体现，","like_count":0},{"had_liked":false,"id":120820,"user_name":"梅云霞","can_delete":false,"product_type":"c1","uid":1400992,"ip_address":"","ucode":"01C8F85B59A202","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/a0/dc0bf77c.jpg","comment_is_top":false,"comment_ctime":1565001194,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":120769,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1564992414,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"关于思考题：从本篇的内容来看，在消息队列产品保证不丢信息的情况下，用户自己在consumer端实现幂等操作就可以处理消息重复的问题，这样既有足够的灵活性，也可以满足恰好一次的要求。这样一来At least once对于现实的应用场景来已经足够了，如果要支持Exactly once需要花费额外的分布式锁，对性能有影响，同时有可能对生产者端造成过多的耦合","like_count":0},{"had_liked":false,"id":120768,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1564992413,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"关于思考题：从本篇的内容来看，在消息队列产品保证不丢信息的情况下，用户自己在consumer端实现幂等操作就可以处理消息重复的问题，这样既有足够的灵活性，也可以满足恰好一次的要求。这样一来At least once对于现实的应用场景来已经足够了，如果要支持Exactly once需要花费额外的分布式锁，对性能有影响，同时有可能对生产者端造成过多的耦合","like_count":0},{"had_liked":false,"id":120767,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1564992413,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"关于思考题：从本篇的内容来看，在消息队列产品保证不丢信息的情况下，用户自己在consumer端实现幂等操作就可以处理消息重复的问题，这样既有足够的灵活性，也可以满足恰好一次的要求。这样一来At least once对于现实的应用场景来已经足够了，如果要支持Exactly once需要花费额外的分布式锁，对性能有影响，同时有可能对生产者端造成过多的耦合","like_count":0},{"had_liked":false,"id":120741,"user_name":"啥也不会","can_delete":false,"product_type":"c1","uid":1040584,"ip_address":"","ucode":"2E0F593B237C59","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/c8/4ad13219.jpg","comment_is_top":false,"comment_ctime":1564987574,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"打卡走一波","like_count":0},{"had_liked":false,"id":120697,"user_name":"大白给小白讲故事","can_delete":false,"product_type":"c1","uid":1258557,"ip_address":"","ucode":"4538C24B67B513","user_header":"https://static001.geekbang.org/account/avatar/00/13/34/3d/51762e76.jpg","comment_is_top":false,"comment_ctime":1564977070,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"级别更高的Exactly once实现的复杂度更高，就会远离高并发、高可用的特性","like_count":0},{"had_liked":false,"id":120663,"user_name":"陈泽坛","can_delete":false,"product_type":"c1","uid":1394861,"ip_address":"","ucode":"C81B402868E9E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/ad/8be724da.jpg","comment_is_top":false,"comment_ctime":1564968619,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"跟上，打卡。。。","like_count":0},{"had_liked":false,"id":120576,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1564931865,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"重复的消息是依次发送的，不能被两个consumer拉取到吧","like_count":0},{"had_liked":false,"id":120559,"user_name":"Mark Yao","can_delete":false,"product_type":"c1","uid":1091768,"ip_address":"","ucode":"0535CEB691F618","user_header":"https://static001.geekbang.org/account/avatar/00/10/a8/b8/73ef30ed.jpg","comment_is_top":false,"comment_ctime":1564929138,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"性能取舍，即使满足消费端也要满足","like_count":0,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":120380,"discussion_content":"你这连发三个相同的留言，是否消息重复消费呀，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578273733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120872,"user_name":"史双龙","can_delete":false,"product_type":"c1","uid":1176417,"ip_address":"","ucode":"387D01880867AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/61/8f7fca5b.jpg","comment_is_top":false,"comment_ctime":1565007790,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"根据具体问题具体实现幂等性，这块不单单是在消息队列消费的逻辑里面提现，其他业务里面也最好都要又体现，","like_count":0},{"had_liked":false,"id":120820,"user_name":"梅云霞","can_delete":false,"product_type":"c1","uid":1400992,"ip_address":"","ucode":"01C8F85B59A202","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/a0/dc0bf77c.jpg","comment_is_top":false,"comment_ctime":1565001194,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":120769,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1564992414,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"关于思考题：从本篇的内容来看，在消息队列产品保证不丢信息的情况下，用户自己在consumer端实现幂等操作就可以处理消息重复的问题，这样既有足够的灵活性，也可以满足恰好一次的要求。这样一来At least once对于现实的应用场景来已经足够了，如果要支持Exactly once需要花费额外的分布式锁，对性能有影响，同时有可能对生产者端造成过多的耦合","like_count":0},{"had_liked":false,"id":120768,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1564992413,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"关于思考题：从本篇的内容来看，在消息队列产品保证不丢信息的情况下，用户自己在consumer端实现幂等操作就可以处理消息重复的问题，这样既有足够的灵活性，也可以满足恰好一次的要求。这样一来At least once对于现实的应用场景来已经足够了，如果要支持Exactly once需要花费额外的分布式锁，对性能有影响，同时有可能对生产者端造成过多的耦合","like_count":0},{"had_liked":false,"id":120767,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1564992413,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"关于思考题：从本篇的内容来看，在消息队列产品保证不丢信息的情况下，用户自己在consumer端实现幂等操作就可以处理消息重复的问题，这样既有足够的灵活性，也可以满足恰好一次的要求。这样一来At least once对于现实的应用场景来已经足够了，如果要支持Exactly once需要花费额外的分布式锁，对性能有影响，同时有可能对生产者端造成过多的耦合","like_count":0,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":120380,"discussion_content":"你这连发三个相同的留言，是否消息重复消费呀，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578273733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120741,"user_name":"啥也不会","can_delete":false,"product_type":"c1","uid":1040584,"ip_address":"","ucode":"2E0F593B237C59","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/c8/4ad13219.jpg","comment_is_top":false,"comment_ctime":1564987574,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"打卡走一波","like_count":0},{"had_liked":false,"id":120697,"user_name":"大白给小白讲故事","can_delete":false,"product_type":"c1","uid":1258557,"ip_address":"","ucode":"4538C24B67B513","user_header":"https://static001.geekbang.org/account/avatar/00/13/34/3d/51762e76.jpg","comment_is_top":false,"comment_ctime":1564977070,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"级别更高的Exactly once实现的复杂度更高，就会远离高并发、高可用的特性","like_count":0},{"had_liked":false,"id":120663,"user_name":"陈泽坛","can_delete":false,"product_type":"c1","uid":1394861,"ip_address":"","ucode":"C81B402868E9E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/ad/8be724da.jpg","comment_is_top":false,"comment_ctime":1564968619,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"跟上，打卡。。。","like_count":0},{"had_liked":false,"id":120576,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1564931865,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"重复的消息是依次发送的，不能被两个consumer拉取到吧","like_count":0},{"had_liked":false,"id":120559,"user_name":"Mark Yao","can_delete":false,"product_type":"c1","uid":1091768,"ip_address":"","ucode":"0535CEB691F618","user_header":"https://static001.geekbang.org/account/avatar/00/10/a8/b8/73ef30ed.jpg","comment_is_top":false,"comment_ctime":1564929138,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"性能取舍，即使满足消费端也要满足","like_count":0},{"had_liked":false,"id":120446,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1564900316,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"我感觉是消息队列没有办法做到exactly once吧。原因是网络环境太复杂，底层的tcp都做不到exactly once，上层的应用更加做不到了。","like_count":0},{"had_liked":false,"id":120405,"user_name":"青舟","can_delete":false,"product_type":"c1","uid":1192732,"ip_address":"","ucode":"2651482AC0DEC6","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/1c/59a4e803.jpg","comment_is_top":false,"comment_ctime":1564884241,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"我能想到的点：\n1，生产端需要为每条消息设置唯一id，消息队列要做去重处理\n2.消息队列如何维护消息是否已经消费？针对每个消息都必须记录其消费状态，首先只能分配给一个消费者，并且需要知道消费结果，消费者拿到消息后可能还没处理就挂掉，或者处理了ack没完成就挂了，需要消息队列向消费者进行回查","like_count":0},{"had_liked":false,"id":120344,"user_name":"good葳","can_delete":false,"product_type":"c1","uid":1205263,"ip_address":"","ucode":"1A4DBFDF298A62","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/0f/520d987d.jpg","comment_is_top":false,"comment_ctime":1564839255,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"跟tcp协议一样，有ack机制，所以，所以宁可多发也不要少发，否则丢消息了，很严重。如果不管就是udp了","like_count":0},{"had_liked":false,"id":120330,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1564834201,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"exactly once的要想实现，一种选择是效仿mqtt qos2，做多次确认。这种方法理论上并不能100%避免消息重复，却使得性能大幅下降，得不偿失。另一种是mq的consumer实现框架在内部对消息id做记录，并做重复性检查，但这又引来了新问题，框架的实现无法知道一条长时间没ack的消息发生了什么，没有进行去重的依据。看来这些是还是交给应用层更合适。","like_count":0},{"had_liked":false,"id":120318,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1564829050,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"这是在黑kafka吗？😂","like_count":0},{"had_liked":false,"id":120141,"user_name":"月下独酌","can_delete":false,"product_type":"c1","uid":1612635,"ip_address":"","ucode":"E79579ACEE25DF","user_header":"https://static001.geekbang.org/account/avatar/00/18/9b/5b/eee80536.jpg","comment_is_top":false,"comment_ctime":1564798473,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"猜测下，如果要使用恰好一次的级别，大部分情况下，从业务上实现恰好一次 比直接靠消息队列实现要容易。","like_count":0},{"had_liked":false,"id":120119,"user_name":"努力奋斗的Pisces","can_delete":false,"product_type":"c1","uid":1336441,"ip_address":"","ucode":"AD4F8909CF190A","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/79/f1e1ca76.jpg","comment_is_top":false,"comment_ctime":1564795084,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"长时间都没收到消费端的ack的话会造成消息队列的阻塞，会大大影响性能","like_count":0},{"had_liked":false,"id":120083,"user_name":"邋遢的流浪剑客","can_delete":false,"product_type":"c1","uid":1260881,"ip_address":"","ucode":"32AF6F9070506D","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/51/9723276c.jpg","comment_is_top":false,"comment_ctime":1564786220,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"确保不丢消息其实已经能够满足大多数场景了，实现相对简单只要没有收到ack的时候再发送即可，可能是因为恰好一次实现相对复杂而且可能与消息队列追求的高性能相违背","like_count":0},{"had_liked":false,"id":120446,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1564900316,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"我感觉是消息队列没有办法做到exactly once吧。原因是网络环境太复杂，底层的tcp都做不到exactly once，上层的应用更加做不到了。","like_count":0},{"had_liked":false,"id":120405,"user_name":"青舟","can_delete":false,"product_type":"c1","uid":1192732,"ip_address":"","ucode":"2651482AC0DEC6","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/1c/59a4e803.jpg","comment_is_top":false,"comment_ctime":1564884241,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"我能想到的点：\n1，生产端需要为每条消息设置唯一id，消息队列要做去重处理\n2.消息队列如何维护消息是否已经消费？针对每个消息都必须记录其消费状态，首先只能分配给一个消费者，并且需要知道消费结果，消费者拿到消息后可能还没处理就挂掉，或者处理了ack没完成就挂了，需要消息队列向消费者进行回查","like_count":0},{"had_liked":false,"id":120344,"user_name":"good葳","can_delete":false,"product_type":"c1","uid":1205263,"ip_address":"","ucode":"1A4DBFDF298A62","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/0f/520d987d.jpg","comment_is_top":false,"comment_ctime":1564839255,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"跟tcp协议一样，有ack机制，所以，所以宁可多发也不要少发，否则丢消息了，很严重。如果不管就是udp了","like_count":0},{"had_liked":false,"id":120330,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1564834201,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"exactly once的要想实现，一种选择是效仿mqtt qos2，做多次确认。这种方法理论上并不能100%避免消息重复，却使得性能大幅下降，得不偿失。另一种是mq的consumer实现框架在内部对消息id做记录，并做重复性检查，但这又引来了新问题，框架的实现无法知道一条长时间没ack的消息发生了什么，没有进行去重的依据。看来这些是还是交给应用层更合适。","like_count":0},{"had_liked":false,"id":120318,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1564829050,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"这是在黑kafka吗？😂","like_count":0},{"had_liked":false,"id":120141,"user_name":"月下独酌","can_delete":false,"product_type":"c1","uid":1612635,"ip_address":"","ucode":"E79579ACEE25DF","user_header":"https://static001.geekbang.org/account/avatar/00/18/9b/5b/eee80536.jpg","comment_is_top":false,"comment_ctime":1564798473,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"猜测下，如果要使用恰好一次的级别，大部分情况下，从业务上实现恰好一次 比直接靠消息队列实现要容易。","like_count":0},{"had_liked":false,"id":120119,"user_name":"努力奋斗的Pisces","can_delete":false,"product_type":"c1","uid":1336441,"ip_address":"","ucode":"AD4F8909CF190A","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/79/f1e1ca76.jpg","comment_is_top":false,"comment_ctime":1564795084,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"长时间都没收到消费端的ack的话会造成消息队列的阻塞，会大大影响性能","like_count":0},{"had_liked":false,"id":120083,"user_name":"邋遢的流浪剑客","can_delete":false,"product_type":"c1","uid":1260881,"ip_address":"","ucode":"32AF6F9070506D","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/51/9723276c.jpg","comment_is_top":false,"comment_ctime":1564786220,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"确保不丢消息其实已经能够满足大多数场景了，实现相对简单只要没有收到ack的时候再发送即可，可能是因为恰好一次实现相对复杂而且可能与消息队列追求的高性能相违背","like_count":0}]}