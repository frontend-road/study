{"id":373476,"title":"28 | 手把手带你设计一个完整的连锁超市信息系统数据库（下）","content":"<p>你好，我是朱晓峰。</p><p>上节课，我们完成了项目的需求分析和业务流程的梳理，为设计数据库做好了准备工作，接下来我们就可以开始具体的设计了。所以，今天，我就带你来建库建表、创建外键约束、视图、存储过程和触发器，最后制定容灾和备份的策略，从而完成一个完整的连锁超市项目数据库的设计，帮助你提高设计高效可靠的数据库的能力。</p><p>首先，我们一起来创建数据库和数据表。</p><h2>如何创建数据库和数据表？</h2><p>经过上节课的分库分表操作，我们把数据库按照业务模块，拆分成了多个数据库。其中，盘点模块中的数据表分别被拆分到了营运数据库（operation）和库存数据库（inventory）中。</p><p>下面我们就按照上节课的分库策略，分别创建营运数据库和库存数据库：</p><pre><code>mysql&gt; CREATE DATABASE operation;\nQuery OK, 1 row affected (0.03 sec)\n \nmysql&gt; CREATE DATABASE inventory;\nQuery OK, 1 row affected (0.02 sec)\n</code></pre><p>接下来，我们来分别创建下这两个数据库中的表。</p><p>商户表、门店表、员工表、商品常用信息表和商品不常用信息表从属于营运数据库，我们先把这5个表创建出来。</p><p>商户表（operation.enterprice）：</p><pre><code>mysql&gt; CREATE TABLE operation.enterprice\n-&gt; (\n-&gt; groupnumber SMALLINT PRIMARY KEY,  -- 组号\n-&gt; groupname VARCHAR(100) NOT NULL,   -- 名称\n-&gt; address TEXT NOT NULL,             -- 地址\n-&gt; phone VARCHAR(20) NOT NULL,        -- 电话\n-&gt; contactor VARCHAR(50) NOT NULL     -- 联系人\n-&gt; );\nQuery OK, 0 rows affected (0.05 sec)\n</code></pre><p>门店表（operation.branch）：</p><pre><code>mysql&gt; CREATE TABLE operation.branch\n-&gt; (\n-&gt; branchid SMALLINT PRIMARY KEY,        -- 门店编号\n-&gt; groupnumber SMALLINT NOT NULL,        -- 组号\n-&gt; branchname VARCHAR(100) NOT NULL,     -- 门店名称\n-&gt; address TEXT NOT NULL,                -- 地址\n-&gt; phone VARCHAR(20) NOT NULL,           -- 电话\n-&gt; branchtype VARCHAR(20) NOT NULL,      -- 门店类别\n-&gt; CONSTRAINT fk_branch_enterprice FOREIGN KEY (groupnumber) REFERENCES operation.enterprice(groupnumber)  -- 外键约束，组号是外键\n-&gt; );\nQuery OK, 0 rows affected (0.07 sec)\n</code></pre><p>员工表（operation.employee）：</p><pre><code>mysql&gt; CREATE TABLE operation.employee\n-&gt; (\n-&gt; employeeid SMALLINT PRIMARY KEY,     -- 员工编号\n-&gt; groupnumber SMALLINT NOT NULL,       -- 组号\n-&gt; branchid SMALLINT NOT NULL,          -- 门店编号\n-&gt; workno VARCHAR(20) NOT NULL,         -- 工号\n-&gt; employeename VARCHAR(100) NOT NULL,  -- 员工名称\n-&gt; pid VARCHAR(20) NOT NULL,            -- 身份证\n-&gt; address VARCHAR(100) NOT NULL,       -- 地址\n-&gt; phone VARCHAR(20) NOT NULL,          -- 电话\n-&gt; employeeduty VARCHAR(20) NOT NULL,   -- 职责\n-&gt; CONSTRAINT fk_employee_branch FOREIGN KEY (branchid) REFERENCES operation.branch(branchid)\n-&gt; );\nQuery OK, 0 rows affected (0.07 sec)\n</code></pre><p>商品常用信息表（operation.goods_o）：</p><!-- [[[read_end]]] --><pre><code>mysql&gt; CREATE TABLE operation.goods_o\n-&gt; (\n-&gt; itemnumber MEDIUMINT ,   -- 商品编号\n-&gt; groupnumber SMALLINT NOT NULL,      -- 组号\n-&gt; barcode VARCHAR(50) NOT NULL,       -- 条码\n-&gt; goodsname TEXT NOT NULL,            -- 名称\n-&gt; salesprice DECIMAL(10,2) NOT NULL,  -- 售价\n-&gt; PRIMARY KEY (groupnumber,itemnumber)-- 主键 \n-&gt; );\nQuery OK, 0 rows affected (0.06 sec)\n</code></pre><p>商品不常用信息表（operation.goods_f）：</p><pre><code>mysql&gt; CREATE TABLE operation.goods_f\n-&gt; (\n-&gt; itemnumber MEDIUMINT,       -- 商品编号\n-&gt; groupnumber SMALLINT NOT NULL,          -- 组号\n-&gt; specification TEXT NOT NULL,            -- 规格\n-&gt; unit VARCHAR(20) NOT NULL,              -- 单位\n-&gt; PRIMARY KEY (groupnumber,itemnumber)    -- 主键\n-&gt; );\nQuery OK, 0 rows affected (0.06 sec)\n</code></pre><p>好了，现在我们来创建库存数据库中的表。仓库表、库存表、盘点单头表、盘点单明细表、盘点单头历史表和盘点单明细历史表，从属于库存数据库。</p><p>仓库表（inventory.stockmaster）：</p><pre><code>mysql&gt; CREATE TABLE inventory.stockmaster\n-&gt; (\n-&gt; stockid SMALLINT PRIMARY KEY,     -- 仓库编号\n-&gt; groupnumber SMALLINT NOT NULL,    -- 组号\n-&gt; branchid SMALLINT NOT NULL,       -- 门店编号\n-&gt; stockname VARCHAR(100) NOT NULL,  -- 仓库名称\n-&gt; stockkind VARCHAR(20) NOT NULL,   -- 仓库种类\n-&gt; CONSTRAINT fk_stock_branch FOREIGN KEY (branchid) REFERENCES operation.branch(branchid)           -- 外键约束，门店编号是外键\n-&gt; );\nQuery OK, 0 rows affected (0.07 sec)\n</code></pre><p>库存表（inventory.inventory）：</p><pre><code>mysql&gt; CREATE TABLE inventory.inventory\n-&gt; (\n-&gt; id INT PRIMARY KEY AUTO_INCREMENT,       -- 库存编号\n-&gt; groupnumber SMALLINT NOT NULL,           -- 组号\n-&gt; branchid SMALLINT NOT NULL,              -- 门店编号\n-&gt; stockid SMALLINT NOT NULL,               -- 仓库编号\n-&gt; itemnumber MEDIUMINT NOT NULL,           -- 商品编号\n-&gt; itemquantity DECIMAL(10,3) NOT NULL      -- 商品数量\n-&gt; );\nQuery OK, 0 rows affected (0.06 sec)\n</code></pre><p>盘点单头表（inventory.invcounthead）：</p><pre><code>mysql&gt; CREATE TABLE inventory.invcounthead\n-&gt; (\n-&gt; listnumber INT PRIMARY KEY,              -- 单号\n-&gt; groupnumber SMALLINT NOT NULL,           -- 组号\n-&gt; branchid SMALLINT NOT NULL,              -- 门店编号\n-&gt; stockid SMALLINT NOT NULL,               -- 仓库编号\n-&gt; recorder SMALLINT NOT NULL,              -- 录入人编号\n-&gt; recordingdate DATETIME NOT NULL          -- 录入时间\n-&gt; );\nQuery OK, 0 rows affected (0.07 sec)\n</code></pre><p>盘点单明细表（inventorry.invcountdetails）：</p><pre><code>mysql&gt; CREATE TABLE inventory.invcountdetails\n-&gt; (\n-&gt; id INT PRIMARY KEY AUTO_INCREMENT,   -- 明细编号\n-&gt; listnumber INT NOT NULL,             -- 单号\n-&gt; groupnumber SMALLINT NOT NULL,       -- 组号\n-&gt; branchid SMALLINT NOT NULL,          -- 门店编号\n-&gt; stockid SMALLINT NOT NULL,           -- 仓库编号\n-&gt; itemnumber MEDIUMINT NOT NULL,       -- 商品编号\n-&gt; accquant DECIMAL(10,3) NOT NULL,     -- 结存数量\n-&gt; invquant DECIMAL(10,3) NOT NULL,     -- 盘存数量\n-&gt; plquant DECIMAL(10,3) NOT NULL       -- 盈亏数量\n-&gt; );\n \nQuery OK, 0 rows affected (0.07 sec)\n</code></pre><p>盘点单头历史表（inventory.invcountheadhist）：</p><pre><code>mysql&gt; CREATE TABLE inventory.invcountheadhist\n-&gt; (\n-&gt; listnumber INT PRIMARY KEY,       -- 单号\n-&gt; groupnumber SMALLINT NOT NULL,    -- 组号\n-&gt; branchid SMALLINT NOT NULL,       -- 门店编号\n-&gt; stockid SMALLINT NOT NULL,        -- 仓库编号\n-&gt; recorder SMALLINT NOT NULL,       -- 录入人编号\n-&gt; recordingdate DATETIME NOT NULL,  -- 录入时间\n-&gt; confirmer SMALLINT NOT NULL,      -- 验收人编号\n-&gt; confirmationdate DATETIME NOT NULL -- 验收时间\n-&gt; );\nQuery OK, 0 rows affected (0.10 sec)\n</code></pre><p>盘点单明细历史表（inventorry.invcountdetailshist）：</p><pre><code>mysql&gt; CREATE TABLE inventory.invcountdetailshist\n-&gt; (\n-&gt; id INT PRIMARY KEY AUTO_INCREMENT,   -- 明细编号\n-&gt; listnumber INT NOT NULL,             -- 单号\n-&gt; groupnumber SMALLINT NOT NULL,       -- 组号\n-&gt; branchid SMALLINT NOT NULL,          -- 门店编号\n-&gt; stockid SMALLINT NOT NULL,           -- 仓库编号\n-&gt; itemnumber MEDIUMINT NOT NULL,       -- 商品编号\n-&gt; accquant DECIMAL(10,3) NOT NULL,     -- 结存数量\n-&gt; invquant DECIMAL(10,3) NOT NULL,     -- 盘存数量\n-&gt; plquant DECIMAL(10,3) NOT NULL       -- 盈亏数量\n-&gt; );\nQuery OK, 0 rows affected (1.62 sec)\n</code></pre><p>至此，我们完成了创建数据库和数据表的工作。为了提高查询的速度，我们还要为数据表创建索引。下面我们就来实际操作一下。</p><h3>如何创建索引？</h3><p>索引对提升数据查询的效率作用最大，没有之一。我们创建索引的策略是：</p><ol>\n<li>所有的数据表都必须创建索引；</li>\n<li>只要是有可能成为查询筛选条件的字段，都必须创建索引。</li>\n</ol><p>这样做的原因是，当数据量特别大的时候，如果没有索引，一旦出现大并发，没有索引的表很可能会成为访问的瓶颈。而且这个问题十分隐蔽，不容易察觉，系统也不会报错，但是却会消耗大量的CPU资源，导致系统事实上的崩溃。</p><p>在之前的操作中，我们一共创建了11个数据表，下面我们就来一一为这些表创建索引。</p><p>商户表中的组号字段，常被用于筛选条件。我们用商户表的组号字段为商户表创建索引，代码如下所示：</p><pre><code>mysql&gt; CREATE INDEX index_enterprice_groupname ON operation.enterprice (groupname);\nQuery OK, 0 rows affected (0.06 sec)\nRecords: 0 Duplicates: 0 Warnings: 0\n</code></pre><p>门店表的组号字段也常被用作筛选条件，所以，我们用组号字段为门店表创建索引，代码如下所示：</p><pre><code>mysql&gt; CREATE INDEX index_branch_groupnumber ON operation.branch (groupnumber);\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>除了组号字段，门店名称字段也常用在查询的筛选条件中，下面我们就用门店名称字段为门店表创建索引：</p><pre><code>mysql&gt; CREATE INDEX index_branch_branchname ON operation.branch (branchname);\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>门店类别字段也是用作筛选条件的字段之一，我们可以用门店类别字段为门店表创建索引，如下所示：</p><pre><code>mysql&gt; CREATE INDEX index_branch_branchtype ON operation.branch (branchtype);\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>在员工表中，组号、门店编号、身份证号、电话和职责字段常被用作查询的筛选条件，下面我们就分别用这几个字段为员工表创建索引。</p><p>第一步，用组号字段为员工表创建索引：</p><pre><code>mysql&gt; CREATE INDEX index_employee_groupnumer ON operation.employee (groupnumber);\nQuery OK, 0 rows affected (0.06 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>第二步，用门店编号字段为员工表创建索引：</p><pre><code>mysql&gt; CREATE INDEX index_employee_branchid ON operation.employee (branchid);\nQuery OK, 0 rows affected (0.07 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>第三步，用身份证字段为员工表创建索引：</p><pre><code>mysql&gt; CREATE INDEX index_employee_pid ON operation.employee (pid);\nQuery OK, 0 rows affected (0.04 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>第四步，用电话字段为员工表创建索引：</p><pre><code>mysql&gt; CREATE INDEX index_employee_phone ON operation.employee (phone);\nQuery OK, 0 rows affected (0.04 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>最后，我们用职责字段为员工表创建索引：</p><pre><code>mysql&gt; CREATE INDEX index_employee_duty ON operation.employee (employeeduty);\nQuery OK, 0 rows affected (0.09 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>对于商品常用信息表（operation.goods_o），我们发现，组号和售价字段常被用在查询筛选条件语句中，所以，我们分别用这两个字段为商品常用信息表创建索引。</p><p>首先，用组号字段为商品常用信息表创建索引，如下所示：</p><pre><code>mysql&gt; CREATE INDEX index_goodso_groupnumber ON operation.goods_o (groupnumber);\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>然后，用价格字段为商品常用信息表创建索引，如下所示：</p><pre><code>mysql&gt; CREATE INDEX index_goodso_salesprice ON operation.goods_o (salesprice);\nQuery OK, 0 rows affected (0.04 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>对于商品不常用信息表，只有组号字段经常用在查询的筛选条件中，所以，我们只需要用组号字段为商品不常用信息表创建索引。代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_goodsf_groupnumber ON operation.goods_f (groupnumber);\nQuery OK, 0 rows affected (0.04 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>到这里，我们就完成了为营运数据库中的表创建索引的工作，下面我们来为库存数据库中的表创建索引。</p><p>首先是仓库表。这个表中经常被用做筛选条件的字段，是组号和门店编号字段。</p><p>我们先用组号字段为仓库表创建索引，代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_stock_groupnumber ON inventory.stockmaster (groupnumber);\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>然后我们用门店编号字段为仓库表创建索引，代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_stock_branchid ON inventory.stockmaster (branchid);\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>接下来，我们为库存表创建索引。库存表中常用于筛选的字段有组号、门店编号和商品编号字段。</p><p>我们先用组号字段来创建索引，代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_inventory_groupnumber ON inventory.inventory (groupnumber);\nQuery OK, 0 rows affected (0.11 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>然后，我们用门店编号字段创建索引，代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_inventory_branchid ON inventory.inventory (branchid);\nQuery OK, 0 rows affected (0.04 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>最后用商品编号字段创建索引，代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_inventory_itemnumber ON inventory.inventory (itemnumber);\nQuery OK, 0 rows affected (0.07 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>盘点单头表也需要创建索引，常用的筛选字段是门店编号。那么，我们就用门店编号为盘点单头表创建索引，代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_invcounthead_branchid ON inventory.invcounthead (branchid);\nQuery OK, 0 rows affected (0.04 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>盘点单头明细表中常用于筛选的字段有门店编号和商品编号，我们分别用这2个字段创建索引。</p><p>首先是用门店编号字段创建索引，代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_invcountdetails_branchid ON inventory.invcountdetails (branchid);\nQuery OK, 0 rows affected (0.08 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>然后是用商品编号字段创建索引，代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_invcountdetails_itemnumber ON inventory.invcountdetails (itemnumber);\nQuery OK, 0 rows affected (0.04 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>盘点单头历史表数据量比较大，主要用于查询，常用的筛选字段有门店编号和验收时间。我们先用门店编号字段创建索引，代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_invcounthaedhist_branchid ON inventory.invcountheadhist (branchid);\nQuery OK, 0 rows affected (0.06 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>然后用验收时间字段创建索引，代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_invcounthaedhist_confirmationdate ON inventory.invcountheadhist (confirmationdate);\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>盘点单明细历史表是整个盘点模块中数据量最大的表，主要用于查询，索引对提升查询效率来说非常重要。要是忘了创建索引，很可能成为整个系统的瓶颈。</p><p>这个表中用作筛选条件的字段主要有门店编号和商品编号，我们分别用它们创建索引。首先是门店编号字段，创建索引的代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_invcountdetailshist_branchid ON inventory.invcountdetailshist (branchid);\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>然后是商品编号字段，创建索引的代码如下：</p><pre><code>mysql&gt; CREATE INDEX index_invcountdetailshist_itemnumber ON inventory.invcountdetailshist (itemnumber);\nQuery OK, 0 rows affected (0.04 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n</code></pre><p>到这里，索引就全部创建完成了。</p><p>由于我们把盘点单拆分成了单头和明细两个表，在应用中，经常要用到单头和明细的全部信息，所以，为了使代码更加简洁，查询更加方便，我们要为这两个表创建视图。</p><h3>如何创建视图？</h3><p>首先，我们为盘点单创建视图，代码如下：</p><pre><code>mysql&gt; CREATE VIEW view_invcount\n    -&gt; AS\n    -&gt; SELECT a.*,b.itemnumber,b.accquant,b.invquant,b.plquant\n    -&gt; FROM inventory.invcounthead AS a\n    -&gt; JOIN\n    -&gt; inventory.invcountdetails AS b\n    -&gt; ON (a.listnumber=b.listnumber);\nQuery OK, 0 rows affected (0.04 sec)\n</code></pre><p>然后，我们为盘点单历史表创建视图，代码如下：</p><pre><code>mysql&gt; CREATE VIEW view_invcounthist\n    -&gt; AS\n    -&gt; SELECT a.*,b.itemnumber,b.accquant,b.invquant,b.plquant\n    -&gt; FROM inventory.invcountheadhist AS a\n    -&gt; JOIN inventory.invcountdetailshist AS b\n    -&gt; ON (a.listnumber=b.listnumber);\nQuery OK, 0 rows affected (0.02 sec)\n</code></pre><h3>如何创建存储过程？</h3><p>在整个盘点模块中，有一个核心的计算模块，就是盘点单验收模块。这个计算模块，每次盘点结束都会被调用。为了提升执行效率，让代码更加模块化，使代码的可读性更好，我们可以把盘点表验收这个模块的数据处理逻辑，用存储过程的方式保存在服务器上，以方便应用程序进行调用。</p><p>下面我具体介绍存储过程的入口参数和数据处理逻辑。</p><p>存储过程的入口参数是单号和验收人的员工编号。存储过程的数据处理逻辑是：先用盈亏数量调整库存，计算方式是新库存 = 老库存 + 盈亏数量；然后把盘点单数据移到盘点单历史中去。</p><ul>\n<li>把盘点单明细表中的数据插入到盘点单明细历史表中；</li>\n<li>把盘点单头表中的数据，插入到盘点单头历史表中；</li>\n<li>删除盘点单明细表中的数据；</li>\n<li>删除盘点单头表中的数据。</li>\n</ul><p>按照这个参数定义和计算逻辑，我们就可以用下面的代码来创建存储过程了：</p><pre><code>CREATE DEFINER=`root`@`localhost` PROCEDURE `invcountconfirm`(mylistnumber INT,myconfirmer SMALLINT)\nBEGIN\nDECLARE done INT DEFAULT FALSE;\nDECLARE mybranchid INT;\nDECLARE myitemnumber INT;\nDECLARE myplquant DECIMAL(10,3);\nDECLARE cursor_invcount CURSOR FOR \nSELECT branchid,itemnumber,plquant\nFROM inventory.invcountdetails\nWHERE listnumber = mylistnumber;\nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\nDECLARE EXIT HANDLER FOR SQLEXCEPTION ROLLBACK; \n\nSTART TRANSACTION;         \n OPEN cursor_invcount; -- 打开游标\n FETCH cursor_invcount INTO mybranchid,myitemnumber,myplquant; -- 读入第一条记录\nREPEAT\n  UPDATE inventory.inventory\n  SET itemquantity = itemquantity + myplquant    -- 更新库存\n        WHERE itemnumber = myitemnumber\n        AND branchid = mybranchid; \n  FETCH cursor_invcount INTO mybranchid,myitemnumber,myplquant; -- 读入下一条记录\n UNTIL done END REPEAT;\n    \n CLOSE cursor_invcount;\n    \n  INSERT INTO inventory.invcountdetailshist \n(listnumber,groupnumber,branchid,stockid,itemnumber,accquant,invquant,plquant) \n  SELECT listnumber,groupnumber,branchid,stockid,itemnumber,accquant,invquant,plquant\n  FROM inventory.invcountdetails \n  WHERE listnumber=mylistnumber;  -- 把这一单的盘点单明细插入历史表\n\n  INSERT INTO inventory.invcountheadhist  \n(listnumber,groupnumber,branchid,stockid,recorder,recordingdate,confirmer,confirmationdate) \n  SELECT listnumber,groupnumber,branchid,stockid,recorder,recordingdate,myconfirmer,now()\n  FROM inventory.invcounthead\n  WHERE listnumber=mylistnumber;  -- 把这一单的盘点单头插入历史 \n  DELETE FROM inventory.invcountdetails WHERE listnumber = mylistnumber; -- 删除这一单的盘点单明细表数据\n DELETE FROM inventory.invcounthead WHERE listnumber = mylistnumber; -- 删除这一单的盘点单头表数据\nCOMMIT;\nEND\n</code></pre><p>具体的操作我都标注在代码里面了，你可以看一下。</p><h3>如何创建触发器？</h3><p>创建完了存储过程，我们已经完成了一大半，但是别急，还有一步工作没有做，就是创建触发器。</p><p>由于我们根据分库分表的策略，把商品信息表拆分成了商品常用信息表和商品不常用信息表，这样就很容易产生数据不一致的情况。为了确保商品常用信息表和商品不常用信息表中的数据保持一致，我们可以创建触发器，保证这2个表中删除其中一个表的一条记录的操作，自动触发删除另外一个表中对应的记录的操作。这样一来，就防止了一个表中的记录在另外一个表中不存在的情况，也就确保了数据的一致性。</p><p>创建触发器的代码如下所示：</p><pre><code>DELIMITER //\nCREATE TRIGGER operation.del_goodso BEFORE DELETE  -- 在删除前触发\nON operation.goods_o\nFOR EACH ROW                              -- 表示每删除一条记录，触发一次\nBEGIN                                     -- 开始程序体\n DELETE FROM operation.goods_f\n    WHERE groupnumber=OLD.groupnumber\n    AND itemnumber=OLD.itemnumber;\nEND\n//\nDELIMITER ;\n\nDELIMITER //\nCREATE TRIGGER operation.del_goodsf BEFORE DELETE  -- 在删除前触发\nON operation.goods_f\nFOR EACH ROW                              -- 表示每删除一条记录，触发一次\nBEGIN                                     -- 开始程序体\n DELETE FROM operation.goods_o\n    WHERE groupnumber=OLD.groupnumber\n    AND itemnumber=OLD.itemnumber;\nEND\n//\nDELIMITER ;\n</code></pre><p>到这儿呢，数据库数据表以及相关的索引、存储过程和触发器就都创建完了。可以说，我们已经完成了数据库的设计。</p><p>但是，在实际工作中，如果你只进行到这一步就打住了，那就还不能算是一个优秀的开发者。因为你考虑问题还不够全面。一个合格的系统设计者，不但要准确把握客户的需求，预见项目实施的前景，还要准备好对任何可能意外的应对方案。实际做项目时，不是纸上谈兵，什么情况都可能发生，我们需要未雨绸缪。所以，下面我们就来设计下项目的容灾和备份策略。</p><h2>如何制定容灾和备份策略？</h2><p>为了防止灾害出现，我设置了主从架构。为了方便你理解，我采用的是一主一从的架构，你也可以搭建一主多从的架构，原理都是一样的。</p><p>主从架构的核心是，从服务器实时自动同步主服务器的数据，一旦主服务器宕机，可以切换到从服务器继续使用。这样就可以把灾害损失降到最低。</p><p>下面我就和你一起，搭建一下主从服务器。</p><h3>如何搭建主从服务器？</h3><p>第一步，确保从服务器可以访问主服务器（在同一网段），例如，可以把主服务器的IP地址设置为：</p><pre><code>主服务器IP：192.168.1.100\n</code></pre><p>需要注意的是，主服务器入口方向的3306号端口需要打开，否则从服务器无法访问主服务器的MySQL服务器。</p><p>同时，我们把从服务器的IP地址设置为：</p><pre><code>从服务器IP： 192.168.1.110\n</code></pre><p>第二步，修改主从服务器的系统配置文件my.ini，使主从服务器有不同的ID编号，并且指定需要同步的数据库。</p><p>在主服务器的配置文件中，我们把主服务器的编号修改为：server-id = 1。</p><pre><code># ***** Group Replication Related *****\n# Specifies the base name to use for binary log files. With binary logging\n# enabled, the server logs all statements that change data to the binary\n# log, which is used for backup and replication.\nlog-bin=mysql-bin          -- 二进制日志名称\nbinlog-do-db = operation   -- 需要同步的数据库：营运数据库\nbinlog-do-db = inventory   -- 需要同步的数据库：库存数据库\n\n# ***** Group Replication Related *****\n# Specifies the server ID. For servers that are used in a replication topology,\n# you must specify a unique server ID for each replication server, in the\n# range from 1 to 2^32 − 1. “Unique” means that each ID must be different\n# from every other ID in use by any other source or replica.\nserver-id=1          -- 主服务器的ID设为1\n\n</code></pre><p>然后，我们来修改从服务器的配置文件my.ini，把从服务器的编号设置为server-id = 2。</p><pre><code># ***** Group Replication Related *****\n# Specifies the base name to use for binary log files. With binary logging\n# enabled, the server logs all statements that change data to the binary\n# log, which is used for backup and replication.\nlog-bin=mysql-bin              -- 二进制日志名称\nreplicate_do_db = operation    -- 需要同步过来的数据库：营运数据库\nreplicate_do_db = inventory    -- 需要同步过来的数据库：库存数据库\n\n# ***** Group Replication Related *****\n# Specifies the server ID. For servers that are used in a replication topology,\n# you must specify a unique server ID for each replication server, in the\n# range from 1 to 2^32 − 1. “Unique” means that each ID must be different\n# from every other ID in use by any other source or replica.\nserver-id=2                       -- 从服务器的编号为2\n</code></pre><p>第三步，在主从服务器上都保存配置文件，然后分别重启主从服务器上的MySQL服务器。</p><p>第四步，为了使从服务器可以访问主服务器，在主服务器上创建数据同步用户，并赋予所有权限。这样，从服务器就可以实时读取主服务器的数据了。</p><pre><code>mysql&gt; CREATE USER 'myreplica'@'%' IDENTIFIED BY 'mysql';\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql&gt; GRANT ALL ON *.* TO 'myreplica'@'%';\nQuery OK, 0 rows affected (0.99 sec)\n</code></pre><p>第五步，在从服务器上启动数据同步，开始从主服务器中同步数据。</p><pre><code>mysql&gt;change master to master_host='192.168.1.100',master_port=3306,master_user='myreplica',master_password='mysql’,master_log_file='mysql-bin.000001',master_log_pos=535;\nQuery OK, 0 rows affected (0.02 sec)\n</code></pre><p>启动同步的时候，你需要注意的是，必须指明主服务器上二进制日志中的位置master_log_pos。也就是说，你准备从主服务器的二进制日志的哪个位置开始同步数据。你可以通过在主服务器上，用SQL语句“SHOW BINLOG EVENTS IN 二进制日志名” 获取这个值。下面的代码可以启动同步：</p><pre><code>mysql&gt;start slave;\nQuery OK, 0 rows affected (0.02 sec)\n</code></pre><h3>如何制定数据备份策略？</h3><p>设置了主从服务器，也不是万无一失。</p><p>我曾经就遇到过这样一件事：我们把主从服务器搭在了某大厂几台不同的云服务器上，自以为没问题了，没想到大厂也有失手的时候，居然整个地区全部宕机，导致我们的主从服务器同时无法使用，近千家商户无法开展业务，损失惨重。</p><p>所以，无论系统的架构多么可靠，我们也不能大意。备份仍然是必不可少的步骤。我们可以在应用层面调用类似下面的命令进行备份：</p><pre><code>H:\\&gt;mysqldump -u root -p --databases\ninventory operation &gt; H:\\backup\\Monday\\mybackup.sql\n</code></pre><p>我在项目中设定的策略是，每天晚上12:00做一个自动备份，循环备份7天，创建7个文件夹，从Monday到Sunday，每个文件夹中保存对应的备份文件，新的覆盖旧的。</p><p>这个逻辑也很简单，你很容易理解，我就不多解释了，你不要忘了做这一步工作就可以了。</p><h2>总结</h2><p>今天这节课，我给你详细讲解了建库建表、创建索引、存储过程、触发器，以及容灾和备份策略。有几点你需要格外重视一下。</p><p>索引是提升查询执行速度的关键，创建的原则是：所有的数据表都要创建索引；有可能作为筛选条件的字段，都要用来创建索引。</p><p>另外，容灾和备份是数据库系统设计中必不可少的部分。因为在现实生活中，什么情况都可能发生，我们无法预见，但是可以尽量避免。在设计阶段的未雨绸缪，可以帮助我们减少很多损失。</p><p>最后我要提醒你的是，MySQL的相关知识实践性非常强，决不能停留在纸面上。我在课中演示的的代码，都是在实际环境中运行过的，你课下一定要跟着实际操作一下。毕竟，学习知识最好的办法，就是在解决实际问题中学习。</p><h2>思考题</h2><p>在今天的课程中，我演示了搭建主从服务器的过程。其中，在第四步，我专门创建了一个用来同步数据的账号“myreplica”。我想请你思考一下，我为什么要这样做？直接用“root”账号不行吗？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你把它分享给你的朋友或同事，我们下节课见。</p>","neighbors":{"left":{"article_title":"27 | 手把手带你设计一个完整的连锁超市信息系统数据库（上）","id":373020},"right":{"article_title":"特别发送（一） | 经典面试题讲解第一弹","id":358668}},"comments":[{"had_liked":false,"id":293671,"user_name":"朱晓峰","can_delete":false,"product_type":"c1","uid":2356905,"ip_address":"","ucode":"D2F84F44329C29","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","comment_is_top":true,"comment_ctime":1621482542,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"9.2233720513612001e+18","product_id":100073201,"comment_content":"你好，我是朱晓峰，下面我就来公布一下这节课思考题的答案：<br><br>这节课，我们学习了设计信息系统数据库（下）。下面是思考题的答案：<br><br>尽量不要在设置主从服务器时使用root 账号，原因主要是出于安全考虑，设置主服务器的时候，用明码方式指定root的密码，显然不够安全，而且，从服务器的同步账号也不需要修改主服务器上的数据","like_count":3,"discussions":[{"author":{"id":2267907,"avatar":"","nickname":"惠民","note":"","ucode":"8A9537F76A566A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589430,"discussion_content":"老师，文章中myreplica和root权限相同，但实际生产中，myreplica使用select就可以，对么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664894016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293669,"user_name":"朱晓峰","can_delete":false,"product_type":"c1","uid":2356905,"ip_address":"","ucode":"D2F84F44329C29","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","comment_is_top":true,"comment_ctime":1621482030,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"9.2233720427712e+18","product_id":100073201,"comment_content":"你好，我是朱晓峰，下面我就来公布一下上节课思考题的答案：<br><br>上节课，我们学习了设计信息系统数据库（上）。下面是思考题的答案：<br><br>可以考虑垂直分表：<br><br>表1：包含编号（id）、流水单号（transno）、商品编号（itemnumber）、商品名称（goodsname）、数量（quantity）、金额（actualvalue）、组号（groupnumber）、门店编号（branchnumber）<br>表2：包含流水单号（transno）、微信支付（wechatvalue）、现金支付（cashvalue）、组号（groupnumber）、门店编号（branchnumber）","like_count":1,"discussions":[{"author":{"id":1611025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","nickname":"沈康","note":"","ucode":"02AFA50738AB8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375503,"discussion_content":"老师这个垂直分表感觉解决不了问题呀，表2其实只拆出来 微信支付，和现金支付两个字段，反而新增表还多了 1、流水单号（transno）2、组号（groupnumber）、3、门店编号（branchnumber） 三个字段，实际的流水也是线性增长的，这个不考虑水平切分吗？\n\n水平切分是不是使用组号（groupnumber）更为合适呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621694420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2458510,"avatar":"","nickname":"Geek_5aa96f","note":"","ucode":"0F49D06B75EB40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1611025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","nickname":"沈康","note":"","ucode":"02AFA50738AB8E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592369,"discussion_content":"我也感觉是这样，只拆出来两个字段，水平拆分更合适把","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667358260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375503,"ip_address":"广东"},"score":592369,"extra":""}]},{"author":{"id":1701572,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f6/c4/e14686d4.jpg","nickname":"shk1230","note":"","ucode":"9E39279C23FF8F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556276,"discussion_content":"这种冗余是考虑效率问题的，总比联合查询要强啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647273886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295471,"user_name":"暮暮。","can_delete":false,"product_type":"c1","uid":1113496,"ip_address":"","ucode":"5B3707FA29CECA","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/98/85e74193.jpg","comment_is_top":false,"comment_ctime":1622442926,"is_pvip":false,"replies":[{"id":"107697","content":"存储过程有优点也有不足，企业一般都会按照自己的业务需求决定是否使用存储过程","user_name":"作者回复","user_name_real":"朱晓峰","uid":"2356905","ctime":1623058451,"ip_address":"","comment_id":295471,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5917410222","product_id":100073201,"comment_content":"现在大多数公司很少使用存储过程","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521093,"discussion_content":"存储过程有优点也有不足，企业一般都会按照自己的业务需求决定是否使用存储过程","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623058451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335278,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1645438176,"is_pvip":true,"replies":[{"id":"123505","content":"在实际工作中，用的还是比较多的","user_name":"作者回复","user_name_real":"编辑","uid":"2356905","ctime":1647076201,"ip_address":"","comment_id":335278,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1645438176","product_id":100073201,"comment_content":"这节感觉内容有些少  不够干货 因为 触发器  外键约束 视图 存储过程 之类的都不怎么用了 主要是没合我的胃口吧。。","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555822,"discussion_content":"在实际工作中，用的还是比较多的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647076201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592063,"discussion_content":"触发器，外键约束在微服务都是禁止使用的，太耦合了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667053315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327139,"user_name":"车鸿韡","can_delete":false,"product_type":"c1","uid":2843289,"ip_address":"","ucode":"7A5B69B3F0A830","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBru6Qa44qibaOnbEQprP1SOhBq0YWHCsjBAvNKmSu7DxKNSmtbiaZ1nQGf56m2gMDicsjiasnzI5VAw/132","comment_is_top":false,"comment_ctime":1639956540,"is_pvip":false,"replies":[{"id":"123511","content":"十分感谢您的仔细阅读，是我疏忽了，已经通知后台修正","user_name":"作者回复","user_name_real":"编辑","uid":"2356905","ctime":1647078633,"ip_address":"","comment_id":327139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639956540","product_id":100073201,"comment_content":"商品常用信息表（operation.goods_o）：这个表，主键定义了两次。","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555837,"discussion_content":"十分感谢您的仔细阅读，是我疏忽了，已经通知后台修正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647078633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317546,"user_name":"云浮青山散作烟","can_delete":false,"product_type":"c1","uid":2741187,"ip_address":"","ucode":"81426C3B32BCB6","user_header":"https://static001.geekbang.org/account/avatar/00/29/d3/c3/0941b96b.jpg","comment_is_top":false,"comment_ctime":1634833486,"is_pvip":true,"replies":[{"id":"116467","content":"请参考思考题答案","user_name":"作者回复","user_name_real":"朱晓峰","uid":"2356905","ctime":1636615613,"ip_address":"","comment_id":317546,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634833486","product_id":100073201,"comment_content":"mysql&gt; CREATE TABLE operation.goods_o<br>-&gt; (<br>-&gt; itemnumber MEDIUMINT PRIMARY KEY, -- 商品编号<br>-&gt; groupnumber SMALLINT NOT NULL, -- 组号<br>-&gt; barcode VARCHAR(50) NOT NULL, -- 条码<br>-&gt; goodsname TEXT NOT NULL, -- 名称<br>-&gt; salesprice DECIMAL(10,2) NOT NULL, -- 售价<br>-&gt; PRIMARY KEY (groupnumber,itemnumber)-- 主键 <br>-&gt; );<br>老师，我按照您课程中这样写，收到错误提示Multiple primary key defined.<br>itemnumber那一行的语句改成下边这样就可以，是哪里出问题了呢？<br>-&gt; itemnumber MIDDLEINT NOT NULL,","like_count":0,"discussions":[{"author":{"id":2356905,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZKoB7sooIiaCHqcdNGI97WI3ZJLJph4mibIiat1qRvrBmkicZTEYvyT5iax1vlLFFgk2xgUibmnWvkicWA/132","nickname":"朱晓峰","note":"","ucode":"D2F84F44329C29","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528857,"discussion_content":"请参考思考题答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636615613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}