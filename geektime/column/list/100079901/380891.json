{"id":380891,"title":"05｜进一步认识 Hooks ：如何正确理解函数组件的生命周期？","content":"<p>你好，我是王沛。今天我们来聊聊React组件的生命周期。</p><p>这一讲我会带你从 Hooks 的角度进一步理解 React 函数组件的生命周期。你可能会有疑问，前面几节课我们已经学习了 Hooks 的概念和内置 Hooks 的用法，那为什么还会有专门一讲来进一步介绍 Hooks 呢？</p><p>原因主要有两个。一方面，如果你已经熟悉了 Class 组件的生命周期，那么还需要一个转换编程思想到 Hooks 的过程，这样才能避免表面上用了 Hooks，却仍然用 Class 组件的方式思考问题。</p><p>另一方面，如果你是新接触 React，那么这一讲也能帮你了解原来 Class 组件的工作方式，从而如果看到或接手已有的 React 项目，也能从容应对。</p><h1>忘掉 Class组件的生命周期</h1><p>基于 Class 的组件作为 React 诞生之处就存在的机制，它的用法早已深入人心，甚至至今为止 React 的官方文档中仍然是以 Class 组件为基础的，而函数组件和 Hooks 则是作为新特性做了补充说明和解释。</p><p>这其实有两个原因：</p><ul>\n<li>一是 React 团队尽最大努力保持 API 的稳定，不希望给你造成一种 Class 组件将被废弃的感觉；</li>\n<li>二是大量的存量应用其实还都是用 Class 组件实现的，无论是对于维护者还是加入者来说，了解 Class 组件都是很有必要的。</li>\n</ul><!-- [[[read_end]]] --><p>所以尽管函数组件和 Hooks 是未来发展的趋势，但你还是应该对 Class 组件的用法有一个了解，达到至少是能看懂的程度。</p><p>Class 组件和函数组件是两种实现 React 应用的方式，虽然它们是等价的，但是开发的思想有很大不同。如果你是从 Class 组件转换到 Hooks 的方式，那么很重要的一点就是，你要学会忘掉 Class 组件中的生命周期概念，千万不要将原来习惯的 Class 组件开发方式映射到函数组。</p><p>比如如何在函数组件中实现 componentDidMount, componentDidUpdate 这样的 Class 组件才有的生命周期方法，你应该通过理解 Hooks 的方式去思考业务需求应该如何实现。</p><p>为了理解函数组件的执行过程，我们不妨思考下 React 的本质：<strong>从 Model 到 View 的映射</strong>。假设状态永远不变，那么实际上函数组件就相当于是一个模板引擎，只执行一次。但是 React 本身正是为动态的状态变化而设计的，而可能引起状态变化的原因基本只有两个：</p><ol>\n<li>用户操作产生的事件，比如点击了某个按钮。</li>\n<li>副作用产生的事件，比如发起某个请求正确返回了。</li>\n</ol><p>这两种事件本身并不会导致组件的重新渲染，但我们在这两种事件处理函数中，一定是因为改变了某个状态，这个状态可能是 State 或者 Context，从而导致了 UI 的重新渲染。</p><p>对于第一种情况，其实函数组件和 Class 组件的思路几乎完全一样：通过事件处理函数来改变某个状态；对于第二种情况，在函数组件中是通过 useEffect 这个 Hook 更加直观和语义化的方式来描述。对应到 Class 组件，则是通过手动判断 Props 或者 State 的变化来执行的。</p><p>比如对于在第三讲介绍的例子，一个用于显示博客文章的组件接收一个文章的 id 作为参数，然后根据这个 id 从服务器端获取文章的内容并显示出来。那么当 id 变化的时候，你就需要检测到这个变化，并重新发送请求，显示在界面上。在 Class 组件中，你通常要用如下的代码实现：</p><pre><code>class BlogView extends React.Component {\n  // ...\n  componentDidMount() {\n    // 组件第一次加载时去获取 Blog 数据\n    fetchBlog(this.props.id);\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.id !== this.props.id) {\n      // 当 Blog 的 id 发生变化时去获取博客文章\n      fetchBlog(this.props.id);\n    }\n  }\n  // ...\n}\n</code></pre><p>可以看到，在 Class 组件中，需要在两个生命周期方法中去实现副作用，一个是首次加载，另外一个则是每次 UI 更新后。而在函数组件中不再有生命周期的概念，而是提供了 useEffect 这样一个 Hook 专门用来执行副作用，因此，只需下面的代码即可实现同样的功能：</p><pre><code>function BlogView({ id }) {\n  useEffect(() =&gt; {\n    // 当 id 变化时重新获取博客文章\n    fetchBlog(id);\n  }, [id]); // 定义了依赖项 id\n}\n</code></pre><p>可以看到，在函数组件中你要思考的方式永远是：<strong>当某个状态发生变化时，我要做什么，</strong>而不再是在 Class 组件中的某个生命周期方法中我要做什么。</p><p>所以如果你是从 Class 组件转型到函数组件，那么你要做的就是忘掉 Class 组件的生命周期机制，去逐渐习惯函数组件的思考方式。相信这样你就能够体会到函数组件带来的直观、简洁的好处了。</p><p>当然，要一下子彻底转变是很难的，你需要在实际开发中不断练习。那具体这样才能算是用 Hooks 方式思考呢？接下来我们就一起来对比看个例子，当一个需求来的时候，基于类组件的生命周期机制是如何做的，而在函数组件中又是如何做的。</p><h1>重新思考组件的生命周期</h1><p>在传统的类组件中，有专门定义的生命周期方法用于执行不同的逻辑，那么它们在函数组件的存在的形式又是什么样的呢？接下来我就带你一起看看在函数组件中，是如何思考组件的生命周期的。</p><h2>构造函数</h2><p>在类组件中有一个专门的方法叫 constructor，也就是构造函数，在里面我们会做一些初始化的事情，比如设置 State 的初始状态，或者定义一些类的实例的成员。</p><p>而现在，函数组件只是一个函数，没有所谓的对象，或者说类的实例这样的概念，那自然也就没有构造函数的说法了。</p><p>那么在函数组件中，我们应该如何去做一些初始化的事情呢？答案是：函数组件基本上没有统一的初始化需要，因为 Hooks 自己会负责自己的初始化。比如 useState 这个 Hook，接收的参数就是定义的 State 初始值。而在过去的类组件中，你通常需要在构造函数中直接设置 this.state ，也就是设置某个值来完成初始化。</p><p>但是要注意了，我提到的“基本上没有初始化需要”，也就是并不是完全没有。严格来说，虽然需求不多，但类组件中构造函数能做的不只是初始化 State，还可能有其它的逻辑。那么如果一定要在函数组件中实现构造函数应该怎么做呢？</p><p>这时候我们不妨思考下构造函数的本质，其实就是：在所以其它代码执行之前的一次性初始化工作。在函数组件中，因为没有生命周期的机制，那么转换一下思路，其实我们要实现的是：一次性的代码执行。</p><p>虽然没有直接的机制可以做到这一点，但是利用 useRef 这个 Hook，我们可以实现一个 useSingleton 这样的一次性执行某段代码的自定义 Hook，代码如下：</p><pre><code>import { useRef } from 'react';\n\n// 创建一个自定义 Hook 用于执行一次性代码\nfunction useSingleton(callback) {\n  // 用一个 called ref 标记 callback 是否执行过\n  const called = useRef(false);\n  // 如果已经执行过，则直接返回\n  if (called.current) return;\n  // 第一次调用时直接执行\n  callBack();\n  // 设置标记为已执行过\n  called.current = true;\n}\n</code></pre><p>从而在一个函数组件中，可以调用这个自定义 Hook 来执行一些一次性的初始化逻辑：</p><pre><code>import useSingleton from './useSingleton';\n\nconst MyComp = () =&gt; {\n  // 使用自定义 Hook\n  useSingleton(() =&gt; {\n    console.log('这段代码只执行一次');\n  });\n\n  return (\n    &lt;div&gt;My Component&lt;/div&gt;\n  );\n};\n</code></pre><p>代码中可以看到，useSingleton 这个 Hook 的核心逻辑就是定义只执行一次的代码。而是否在所有代码之前执行，则取决于在哪里调用，可以说，它的功能其实是包含了构造函数的功能的。</p><p>所以你在日常开发中，是无需去将功能映射到传统的生命周期的构造函数的概念，而是要从函数的角度出发，去思考功能如何去实现。比如在这个例子中，我们需要的其实就是抓住某段代码只需要执行一次这样一个本质的需求，从而能够更自然地用 Hooks 解决问题。</p><h2>三种常用的生命周期方法</h2><p>在类组件中，componentDidMount，componentWillUnmount，和componentDidUpdate这三个生命周期方法可以说是日常开发最常用的。业务逻辑通常要分散到不同的生命周期方法中，比如说在上面的 Blog 文章的例子中，你需要同时在 componentDidMount 和 componentDidUpdate 中去获取数据。</p><p>而在函数组件中，这几个生命周期方法可以统一到 useEffect 这个 Hook，正如useEffect 的字面含义，它的作用就是触发一个副作用，即在组件每次 render 之后去执行。</p><p>在第三讲中其实你已经看到了 useEffect 的用法，下面的代码演示了这三个生命周期方法是如何用 useEffect 实现的：</p><pre><code>useEffect(() =&gt; {\n  // componentDidMount + componentDidUpdate\n  console.log('这里基本等价于 componentDidMount + componentDidUpdate');\n  return () =&gt; {\n    // componentWillUnmount\n    console.log('这里基本等价于 componentWillUnmount');\n  }\n}, [deps])\n</code></pre><p>可以看到，useEffect 接收的 callback 参数，可以返回一个用于清理资源的函数，从而在下一次同样的 Effect 被执行之前被调用。</p><p>你可能已经注意到了，在代码里我用了“基本等价于”这个说法，什么意思呢？指的就是这个写法并没有完全等价于传统的这几个生命周期方法。主要有两个原因。</p><p>一方面，useEffect(callback) 这个 Hook 接收的 callback，只有在依赖项变化时才被执行。而传统的 componentDidUpdate 则一定会执行。这样来看，Hook 的机制其实更具有语义化，因为过去在 componentDidUpdate 中，我们通常都需要手动判断某个状态是否发生变化，然后再执行特定的逻辑。</p><p>另一方面，callback 返回的函数（一般用于清理工作）在下一次依赖项发生变化以及组件销毁之前执行，而传统的 componentWillUnmount 只在组件销毁时才会执行。</p><p>第二点可能有点难理解，我们不妨继续看博客文章这个例子。假设当文章 id 发生变化时，我们不仅需要获取文章，同时还要监听某个事件，这样在有新的评论时获得通知，就能显示新的评论了。这时候的代码结构如下：</p><pre><code>import React, { useEffect } from 'react';\nimport comments from './comments';\n\nfunction BlogView({ id }) {\n  const handleCommentsChange = useCallback(() =&gt; {\n    // 处理评论变化的通知\n  }, []);\n  useEffect(() =&gt; {\n    // 获取博客内容\n    fetchBlog(id);\n    // 监听指定 id 的博客文章的评论变化通知\n    const listener = comments.addListener(id, handleCommentsChange);\n    \n    return () =&gt; {\n      // 当 id 发生变化时，移除之前的监听\n      comments.removeListener(listener);\n    };\n  }, [id, handleCommentsChange])\n}\n</code></pre><p>那么可以比较清楚地看到，useEffect 接收的返回值是一个回调函数，这个回调函数不只是会在组件销毁时执行，而且是每次 Effect 重新执行之前都会执行，用于清理上一次 Effect 的执行结果。</p><p>理解这一点非常重要。useEffect 中返回的回调函数，只是清理当前执行的 Effect 本身。这其实是更加语义化的，因此你不用将其映射到 componentWillUnmount，它也完全不等价于 componentWillUnmount。你只需记住它的作用就是用于清理上一次 Effect 的结果就行了，这样在实际的开发中才能够使用得更加自然和合理。</p><h2>其它的生命周期方法</h2><p>刚才我列举了几个 Class 组件中最为常用的生命周期方法，并介绍了对于同样的需求，在函数组件中应该如何去用 Hooks 的机制重新思考它们的实现。这已经能覆盖绝大多数的应用场景了。</p><p>但是 Class 组件中还有其它一些比较少用的方法，比如 getSnapshotBeforeUpdate, componentDidCatch, getDerivedStateFromError。比较遗憾的是目前 Hooks 还没法实现这些功能。因此如果必须用到，你的组件仍然需要用类组件去实现。</p><h1>已有应用是否应该迁移到 Hooks？</h1><p>说了这么多，你可能会觉得写 React 应用就一定非 Hooks 不可了，其实也并非绝对。比如说很多时候，你面临的可能并不是开始一个全新的项目，而是参与到一个已有的项目中。那么就很可能会遇到这样一个问题：对于已有项目中的 Class 组件，是否要重构到函数组件和 Hooks 呢？</p><p>答案其实很明确：完全没必要。</p><p>在 React 中，Class 组件和函数组件是完全可以共存的。对于新的功能，我会更推荐使用函数组件。而对于已有的功能，则维持现状就可以。除非要进行大的功能改变，可以顺便把相关的类组件进行重构，否则是没有必要进行迁移的。</p><p>因为终究来说，能正确工作的代码就是好代码。React 组件的两种写法本身就可以很好地一起工作了：</p><ol>\n<li>\n<p>类组件和函数组件可以互相引用；</p>\n</li>\n<li>\n<p>Hooks 很容易就能转换成高阶组件，并供类组件使用。</p>\n</li>\n</ol><p>总结来说，我们完全没必要为了迁移而迁移。</p><h1>小结</h1><p>这一讲我们主要学习了函数组件和类组件在思考方式上的区别，虽然 Hooks 在功能上基本可以映射到传统的 Class 组件的生命周期方法，但是它们却又不是完全等价的。在实现具体的业务功能的时候，都应该尽量从 Hooks 的语义角度出发去思考组件是如何展现和交互的，这样才能更加顺滑地切换到函数组件的开发方式。</p><h1>思考题</h1><p>今天这节课我们只描述了 componentWillUnmount 近似的实现：组件销毁和文章 id 变化时执行。那么在函数组件中如果要实现严格的 componentWillUnmount，也就是只在组件销毁时执行，应该如何实现？</p><p>欢迎把你的思考和想法分享在留言区，我会和你交流讨论。下节课再见！</p>","comments":[{"had_liked":true,"id":295987,"user_name":"Ada","can_delete":false,"product_type":"c1","uid":1565813,"ip_address":"","ucode":"C52BDD0DBF618D","user_header":"https://static001.geekbang.org/account/avatar/00/17/e4/75/57809f30.jpg","comment_is_top":false,"comment_ctime":1622693763,"is_pvip":false,"replies":[{"id":"107463","content":"因为需要在函数体执行之前执行。useEffect 是在 render 完后执行。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622727965,"ip_address":"","comment_id":295987,"utype":1}],"discussion_count":2,"race_medal":0,"score":"220666025859","product_id":100079901,"comment_content":"如果想要实现只执行一次的功能，用useEffect，依赖项传空数组，不是可以实现吗？<br>为什么要写一个自定义钩子？","like_count":52,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521290,"discussion_content":"因为需要在函数体执行之前执行。useEffect 是在 render 完后执行。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1622727965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1388657,"avatar":"https://static001.geekbang.org/account/avatar/00/15/30/71/ba69f480.jpg","nickname":"毛毛开飞机","note":"","ucode":"EC2CEBA13BF92C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377536,"discussion_content":"这个只能在首次渲染后执行一次，不能控制执行时机","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622700858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295977,"user_name":"毛毛开飞机","can_delete":false,"product_type":"c1","uid":1388657,"ip_address":"","ucode":"EC2CEBA13BF92C","user_header":"https://static001.geekbang.org/account/avatar/00/15/30/71/ba69f480.jpg","comment_is_top":false,"comment_ctime":1622688523,"is_pvip":false,"replies":[{"id":"107467","content":"正确~","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622728134,"ip_address":"","comment_id":295977,"utype":1}],"discussion_count":1,"race_medal":0,"score":"117586805515","product_id":100079901,"comment_content":"useEffect(() =&gt; {<br>  return () =&gt; {<br>    &#47;&#47; 这里只会在组件销毁前（componentWillUnmount）执行一次<br>  }<br>}, [])","like_count":28,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521284,"discussion_content":"正确~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622728134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295941,"user_name":"海洋","can_delete":false,"product_type":"c1","uid":1377447,"ip_address":"","ucode":"5CC1E17E5C455D","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/a7/ea22485a.jpg","comment_is_top":false,"comment_ctime":1622674477,"is_pvip":false,"replies":[{"id":"107461","content":"没错~ 传入空数组就可以了。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622727925,"ip_address":"","comment_id":295941,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27392478253","product_id":100079901,"comment_content":"useEffect 第二个参数传入空，就只在组件初始化时和销毁前分别执行一次","like_count":6,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521274,"discussion_content":"没错~ 传入空数组就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622727925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374337,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f8/81/bff52f91.jpg","nickname":"1830","note":"","ucode":"246FEF7C97F39C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385213,"discussion_content":"不是还要return 一个函数吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626943629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305410,"user_name":"Geek_12f953","can_delete":false,"product_type":"c1","uid":2686412,"ip_address":"","ucode":"13C8FDB4617450","user_header":"","comment_is_top":false,"comment_ctime":1627962210,"is_pvip":false,"replies":[{"id":"110627","content":"确实如此，useState 会导致多余的渲染。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1628155077,"ip_address":"","comment_id":305410,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18807831394","product_id":100079901,"comment_content":"老师，useSingleton这个Hook里面使用useRef来定义called标记而不是用useState，是因为called并不会影响UI渲染吗？我尝试了用useState好像也可以实现只执行一次的效果","like_count":4,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524377,"discussion_content":"确实如此，useState 会导致多余的渲染。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628155077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305133,"user_name":"花儿与少年","can_delete":false,"product_type":"c1","uid":1046304,"ip_address":"","ucode":"E2D685737E4F1B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/20/e2dfa9c2.jpg","comment_is_top":false,"comment_ctime":1627839759,"is_pvip":false,"replies":[{"id":"110408","content":"useEffect 接收的 callback 是在 依赖发生变化以及第一次时执行，return 的函数是在下一次 callback  执行之前执行，或者销毁时执行。这段代码的 依赖项为空，所以只会在最后组件销毁时执行。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1627890770,"ip_address":"","comment_id":305133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18807708943","product_id":100079901,"comment_content":"请教： 以下代码不是每次render后都会执行吗，return的函数在每次effect执行前执行？<br><br>useEffect(() =&gt; {<br>  return () =&gt; {<br>    &#47;&#47; 这里只会在组件销毁前（componentWillUnmount）执行一次<br>  }<br>}, [])<br>","like_count":4,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524287,"discussion_content":"useEffect 接收的 callback 是在 依赖发生变化以及第一次时执行，return 的函数是在下一次 callback  执行之前执行，或者销毁时执行。这段代码的 依赖项为空，所以只会在最后组件销毁时执行。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627890770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296874,"user_name":"Isaac","can_delete":false,"product_type":"c1","uid":1110607,"ip_address":"","ucode":"038C349AB508AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","comment_is_top":false,"comment_ctime":1623208587,"is_pvip":false,"replies":[{"id":"107977","content":"DOM 渲染后执行。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623470396,"ip_address":"","comment_id":296874,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14508110475","product_id":100079901,"comment_content":"老师，useEffect 的执行时机是 DOM 渲染完毕后执行，还是依赖发生变化，不管 DOM 有没有更新完毕就立即执行？","like_count":3,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521623,"discussion_content":"DOM 渲染后执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623470396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":296082,"user_name":"大大小小","can_delete":false,"product_type":"c1","uid":2178133,"ip_address":"","ucode":"8A21DC629A24F5","user_header":"https://static001.geekbang.org/account/avatar/00/21/3c/55/74844d08.jpg","comment_is_top":false,"comment_ctime":1622735143,"is_pvip":false,"replies":[{"id":"107738","content":"所有在 useEffect 中用到的变量都应该被作为依赖的参数，这样在 useEffect 执行的时候才会执行正确的回调函数。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623081182,"ip_address":"","comment_id":296082,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14507637031","product_id":100079901,"comment_content":"BlogView那个例子，为什么要把useCallback返回的函数作为useEffect的依赖呢？是要达到什么目的吗？","like_count":4,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521315,"discussion_content":"所有在 useEffect 中用到的变量都应该被作为依赖的参数，这样在 useEffect 执行的时候才会执行正确的回调函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623081182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1376899,"avatar":"https://static001.geekbang.org/account/avatar/00/15/02/83/8799b1f4.jpg","nickname":"chentianxin","note":"","ucode":"0B106B86360FFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378043,"discussion_content":"usecall usememo缓存的值在useeffect中使用都要添加到依赖项中","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623029262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1376899,"avatar":"https://static001.geekbang.org/account/avatar/00/15/02/83/8799b1f4.jpg","nickname":"chentianxin","note":"","ucode":"0B106B86360FFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378042,"discussion_content":"不用usecallback包裹的话，fn每次rerender都是全新的，导致useeffect一直执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623029188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296911,"user_name":"Geek_sky","can_delete":false,"product_type":"c1","uid":1733288,"ip_address":"","ucode":"BBFE6FF1193873","user_header":"https://static001.geekbang.org/account/avatar/00/1a/72/a8/c24a66a1.jpg","comment_is_top":false,"comment_ctime":1623223024,"is_pvip":false,"replies":[{"id":"107975","content":"useRef 是定义一个当前组件实例上的一个变量。所以组件重新 mount，或者多实例，是互不相关的。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623470370,"ip_address":"","comment_id":296911,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10213157616","product_id":100079901,"comment_content":"老师，我看到useRef的用法有一个疑问：例子中useSingleton包含了一个useRef的定义为false，如果我在MyComp中定义多个useSingleton，程序在启动的时候第二次及之后的调用useRef是怎么确认需要创建新的还是使用之前的？那么界面在刷新之后，useSingleton会再次被调用，那时会有多个useRef的检查，那么程序又是如何判定的？","like_count":2,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521642,"discussion_content":"useRef 是定义一个当前组件实例上的一个变量。所以组件重新 mount，或者多实例，是互不相关的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623470370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330530,"user_name":"MarkTang","can_delete":false,"product_type":"c1","uid":1165689,"ip_address":"","ucode":"58F3439A070B7E","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/79/68a73484.jpg","comment_is_top":false,"comment_ctime":1642030353,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5936997649","product_id":100079901,"comment_content":"之前买过老师的React视频课，干货非常多，看了很多遍，这次果断买了。还是期待老师以后的视频课","like_count":1},{"had_liked":false,"id":296349,"user_name":"Joseph😈","can_delete":false,"product_type":"c1","uid":1057319,"ip_address":"","ucode":"BC1621CD3DB7E0","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/27/134d9a49.jpg","comment_is_top":false,"comment_ctime":1622910456,"is_pvip":false,"replies":[{"id":"107943","content":"useEffect 是在组件 render 完后才执行的，这里的 useSingleton 可以在函数体内直接执行，而不是 render 完之后。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623387981,"ip_address":"","comment_id":296349,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5917877752","product_id":100079901,"comment_content":"请问下老师，如果只是为了做初始化工作，即只在首次render前执行一次。useSingleton这个自定义hook似乎换成useState或useEffect似乎都能做呀，跟useRef相比有没有什么优劣呢？","like_count":1,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521406,"discussion_content":"useEffect 是在组件 render 完后才执行的，这里的 useSingleton 可以在函数体内直接执行，而不是 render 完之后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623387981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378390,"discussion_content":"1. 老师是想模拟 constructor 的逻辑和实现，即 calss 组件下的 constructor 中的逻辑只执行一遍，即在组件渲染前就执行，且后面多次更新都不会再次执行。\n2. useState 是存储 state 的地方，显然不适合存放一段逻辑代码。\n3. useEffect 用来监听某个依赖，然后执行副作用。但是因为 useEffect 的执行实时机，导致并不能实现第一点的要求。\n4. 根据前面几点，所以这个时候我们只能将需要的逻辑代码写在 function 组件内，return 之前，这样就能保证在组件初始化就能执行这段逻辑。\n5. 虽然第 4 点做到了在组件渲染之前执行，但是依旧没满足只执行一次的要求，因为每次 React 更新的时候，都会去调用 function组件，也就是重新执行一遍 function，进而导致我们的逻辑每次都会执行。所以，这个时候就需要借助 useRef 来做判断了，也就是老师文章中的例子。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1623204740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1376899,"avatar":"https://static001.geekbang.org/account/avatar/00/15/02/83/8799b1f4.jpg","nickname":"chentianxin","note":"","ucode":"0B106B86360FFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378040,"discussion_content":"useSingleton相当于自定义了一个hooks，\n专事专干\n类似于useMount或者useUnmount","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623029101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353186,"user_name":"奔跑的小蚂蚁","can_delete":false,"product_type":"c1","uid":2130267,"ip_address":"广东","ucode":"BA462E6022209A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epibNpKIwo4zFXMLIaucTicJBQ4iasrPXYNwLKiaBaOCic09mrWHPtSAA7zTVFDhXJoWBz2MWQclhlzkRg/132","comment_is_top":false,"comment_ctime":1659244491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659244491","product_id":100079901,"comment_content":"这个和class组件得那个还有点不同得是，useEffect是在数据跟新后才执行得，不会阻塞ui，这里每次执行都会先去掉上一次的副作用，或者销毁的时候去掉副作用依赖项不为[]；依赖赖项为[]只执行一次effect函数；没有依赖项更新的时候每次都会执行 effect函数","like_count":0},{"had_liked":false,"id":348880,"user_name":"鲁滨逊","can_delete":false,"product_type":"c1","uid":1387826,"ip_address":"","ucode":"AD58F1115DF311","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/32/43595745.jpg","comment_is_top":false,"comment_ctime":1655490637,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655490637","product_id":100079901,"comment_content":"useSingleton(() =&gt; {}) 和 useEffect(() =&gt; {}, [])  是等价的 ？都是函数组件初始化的时候执行一次 ？","like_count":0},{"had_liked":false,"id":345701,"user_name":"Geek_fcdf7b","can_delete":false,"product_type":"c1","uid":2115742,"ip_address":"","ucode":"55A2DBA5C6DF79","user_header":"https://static001.geekbang.org/account/avatar/00/20/48/9e/9bbaa97d.jpg","comment_is_top":false,"comment_ctime":1652517459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652517459","product_id":100079901,"comment_content":"老师，什么时候出新课？","like_count":0},{"had_liked":false,"id":298547,"user_name":"河马非马","can_delete":false,"product_type":"c1","uid":1376612,"ip_address":"","ucode":"777FA1743534B7","user_header":"https://static001.geekbang.org/account/avatar/00/15/01/64/5f5e3886.jpg","comment_is_top":false,"comment_ctime":1624185736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624185736","product_id":100079901,"comment_content":"useEffect 接收的 callback 参数，可以返回一个用于清理资源的函数，从而在下一次同样的 Effect 被执行之前被调用，老师，请问这里的callback中return的函数是会在下次执行前和本次组件销毁时自动执行吗？看文档时一直没清楚他是react自动实现的规则，还是开发者自己定义的规则。","like_count":0},{"had_liked":false,"id":298265,"user_name":"Juntíng","can_delete":false,"product_type":"c1","uid":1039290,"ip_address":"","ucode":"F6A3B528D6F3FD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/ba/304a9a4a.jpg","comment_is_top":false,"comment_ctime":1623987654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623987654","product_id":100079901,"comment_content":"依据 useEffect 执行机制，deps 传递空数组，就能保证只在组件销毁时执行消除副作用","like_count":0},{"had_liked":false,"id":296494,"user_name":"亦枫丶","can_delete":false,"product_type":"c1","uid":1436276,"ip_address":"","ucode":"A8D09693C760E0","user_header":"https://static001.geekbang.org/account/avatar/00/15/ea/74/7dd9c65e.jpg","comment_is_top":false,"comment_ctime":1623006821,"is_pvip":false,"replies":[{"id":"107750","content":"不行哦，这样每次都会执行 callback()","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623082211,"ip_address":"","comment_id":296494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623006821","product_id":100079901,"comment_content":"useSingleton 是不是可以直接 `useRef(callback())`","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521461,"discussion_content":"不行哦，这样每次都会执行 callback()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623082211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295971,"user_name":"浩然","can_delete":false,"product_type":"c1","uid":1378201,"ip_address":"","ucode":"FC771E92869796","user_header":"https://static001.geekbang.org/account/avatar/00/15/07/99/2c12c56c.jpg","comment_is_top":false,"comment_ctime":1622686556,"is_pvip":false,"replies":[{"id":"107462","content":"正确！","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622727935,"ip_address":"","comment_id":295971,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622686556","product_id":100079901,"comment_content":"useEffect(() =&gt; {<br>    return () =&gt; {<br>        &#47;&#47; 组件销毁时执行<br>    }<br>}, [])","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521281,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622727935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}