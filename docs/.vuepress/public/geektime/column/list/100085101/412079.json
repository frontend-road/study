{"id":412079,"title":"11 | 集成测试：单元测试可以解决所有问题吗？","content":"<p>你好，我是郑晔！</p><p>前面我们花了大量的篇幅在讲单元测试。单元测试是所有测试类型中，运行速度最快，整体覆盖面可以达到最大的测试。因为单元测试的存在，我们甚至可以把测试覆盖率拉高到 100%。测试覆盖率都已经 100%了，是不是我们用单元测试就可以解决所有的问题了？</p><p>正如我们在上一讲强调的那样，100%的测试覆盖率并不代表代码没有问题。同样，即便是 100% 的单元测试也不能解决所有的问题。有一个重要的原因在于，我们在编写每个单元时都会假设这些单元彼此之间能够很好地协同，但这个假设是不是一定成立呢？答案是不一定。</p><p>让一个个单元正常运行，我们靠的不是美好的预期，而是单元测试。同样，各个单元能够很好地协同，我们也不能靠预期，而是要靠集成测试。这一讲，我们就来讨论一下集成测试。</p><h2>代码的集成</h2><p>在具体讨论集成测试之前，我们澄清一下概念。集成测试到底测的是什么？答案很显然是集成。问题是，集成要集成什么呢？一种是代码之间的集成，一种是代码与外部组件的集成。说白了，集成测试就是把不同的组件组合到一起，看看它们是不是能够很好地配合到一起。</p><p>我们先来看代码的集成。代码之间的集成，主要看我们编写的各个单元能否很好地彼此协作。既然集成测试是为了测试单元之间的配合，那是不是只要有单元之间的协作，我们就要为它们编写一个集成测试呢？比如按照常规的架构分层，一个 REST 服务会有一个 Resource（或者叫 Controller），一个 Service，一个 Repository，那是不是要 Service 和 Repository 的集成要写一个集成测试，Resource 和 Service 的集成测一次，Resource、Service 和 Repository 的集成再测一次呢？</p><!-- [[[read_end]]] --><p>如果我们按照前面讨论的方式来编写了单元测试，其实，这就意味着我们每个组件都已经经过了测试。所以，集成测试的重点就不再是组件之间两两协同进行测试了。一般来说，在实践中，我们可以选择的测试方式是，<strong>选择一条任务执行的路径，把路径上用到的组件集成到一起进行测试。</strong>比如在前面提到的那种情况中，我们只要把 Resource、Service 和 Repository 都组装到一起就可以了。</p><p>如果所有的代码都是我们自己编写，那么我们就编写一个个的单元，然后组装到一起进行测试，这个很好理解。但是，现在很多人都在使用框架，比如我们在实战中处理命令行时使用了 Picocli 这个框架，所有的命令解析的过程都是由这个框架完成；再比如，很多人在开发后端服务时，使用了 Spring Boot，一些路由匹配，甚至参数检查都是由框架完成的。那么我们在集成测试中，要不要把这个部分集成进来呢？</p><p>我对此的答案是，<strong>取决于你是否能够把这个框架集成进来，如果能，最好是做一个完整的集成测试。</strong>在实战中，我们已经展示过如何去集成 Picocli，因为这个框架本身比较简单，很容易找到这个框架的外部入口，我们就把它集成起来，做了一个完整的测试。</p><p>有的框架可能就没有那么简单了，就像当年 Java EE 盛行时，我们编写的代码需要部署到一个 Java EE 的容器里面才能运行。在这种情况下，如果强行把 Java EE 容器也加到集成测试里，对于大多数人来说，这是非常有难度的一件事情。换言之，像这种有单独运行时的框架，做整体的集成难度很大，我们只能退而求其次，做大部分的代码集成。</p><p>现在的很多框架替我们做了很多的事情，有些甚至是业务验收标准上的事情，比如，Spring Boot 会替我们做参数检查，利用好 Spring Boot 给我们提供的机制，我们甚至不用写什么代码，只要给字段加上一些 Annotation 就够了。这些 Annotation 加的是否正确，我们其实是需要验证的，因为它是业务验收标准的一部分。</p><p>所以我希望尽可能地去集成，如果我们能够把整个框架集成起来，这些东西也就可以验证了。从代码上来看，这种测试只是针对一个单元在测试，在某种程度上说，这种集成测试其实是一种单元测试，只不过，它必须把系统集成起来才行，所以，它兼具单元测试和集成测试的特点。</p><p>小小预告一下，Spring Boot 在测试上的支持是真的很不错，让我们可以很容易地在测试里对框架处理过程进行集成，在后面的课程里你会看到如何使用 Spring Boot 提供的测试基础设施进行测试。</p><p>你也看到了，我们希望尽可能地把框架集成进来，但市面上的各种框架层出不穷，不是所有的框架都提供了对测试很好地支持。所以，<strong>一个框架设计得好坏与否，对测试的支持程度也是一个很重要的衡量标准，这能很好地体现出框架设计者的品味。</strong></p><p>能够方便测试的框架，通常来说都是很轻量级的，这样的框架对开发非常友好，我们能够在一个普通的 IDE 里很方便地进行调试，对于定位问题也是极其友好的。而各种有运行时需要部署的框架，相对来说，就是重量级的框架，对于开发非常不友好。如果你用过一些 IDE 支持的远程调试功能，你会发现这些功能跟本地调试相比，便捷程度完全不在一个档次上。</p><p>好消息是，我们还是能看到一些框架的进步，即便重如 Java EE 这样的框架，现在也有了嵌入式容器的概念。今天，我们之所以能够很方便地使用 Spring Boot 这样的框架，嵌入式容器给我们提供了非常好的基础。</p><h2>集成外部组件</h2><p>说完了代码的集成，我们再来看看与外部组件的集成。</p><p>在真实世界的开发中，我们经常会遇到与外部组件打交道的情形，最简单是数据要写到数据库里，还有发消息可能会用到消息队列，甚至还可能会涉及与第三方系统的集成。</p><p>理想情况下，我们当然希望把所有相关的组件都集成到一起，但是，一旦牵扯到外部组件，测试的难度立刻就增大了。比如在测试中添加了 Todo 项，如果我的断言写的是先判断数据库里 Todo 项表里有唯一的一条记录，执行之前，你因为其它操作在数据库里插入了数据，这个断言就失败了。即便没有人操作，这个测试执行第一次成功了，再执行一次，可能就失败了，因为第二次执行测试又插入了一条数据。</p><p>所以，<strong>与外部组件集成，难点就在于外部组件的状态如何控制。</strong></p><p>如果能够控制外部组件的状态，在系统里集成它是没有问题的。比如拿数据库集成来说，通常的做法是一方面，我们会建立单独的数据库，保证不与其他部分冲突。比如在 MySQL 里面，我们会建立一个测试用的数据库。</p><pre><code>CREATE DATABASE todo_test;\n</code></pre><p>另一方面，我们要保证它在每个测试之后，都能够恢复到之前的状态。一种做法就是使用数据库的回滚技术，每个测试完成之后就回滚掉，保证数据的干净。后面讲到 Spring Boot 测试的时候，我们会看到具体的做法。</p><p>相对来说，数据库在测试方面的实践已经算是比较成熟了。这也让我们可以去验证 Repository，也就是数据访问层的代码实现。不管使用什么样的框架，写了 SQL 之后，我们都需要验证其正确性。只不过，很多人的选择是把整个系统跑起来，人工去验证 SQL 的正确性，这种做法一方面有些小题大做了，另一方面还是不够自动化。</p><p>有了数据库在测试上的实践，我们就可以用自动化测试的方式进行测试了。其实，从某种意义上说，这也是一种单元测试，因为它的代码只涉及到了一个单元，只不过它需要集成数据库，所以，它还是集成测试</p><p>还有一些外部组件在这方面的支持相对来说，就不那么令人满意了。比如第三方系统。即便是服务做得很完善的第三方系统，也很少有专门为测试提供支持的。</p><p>遇到这种情况，我们就要分析一下，看看有没有什么替代方案。很多第三方系统对外提供服务的方式都是 REST API，对于这种情况，我们就可以用通用的模拟服务器来代替。模拟服务器的价值就在于能够替代这样的第三方服务。</p><p>在这种情况下，我们该怎么做呢？我们需要按照我们的使用场景去访问第三方服务，把整个访问的报文记录下来，作为设置模拟服务器的参考依据。我介绍过的 Moco 甚至提供了代理（proxy）功能，你可以让你的服务去连接 Moco，然后，用 Moco 连接第三方的服务，只要查看 Console 输出，所有的报文就清清楚楚地展现在你面前了。</p><p>如果外部组件没有现成的替代方案怎么办？有两个角度看待这个问题。一个角度是，这也许是一个做新项目的机会，我在《软件设计之美》中讲过 <a href=\"https://time.geekbang.org/column/article/267856\">Moco</a> 的开发过程，其起始点就是一个没有很好解决的问题。</p><p>另一角度，估计是大多数人的选择，那就是既然这里测不了，我可以选择在集成测试里使用模拟对象，而不是真实的对象。在这样的情况下，我们的系统在测试方面其实有一个漏洞没有被测试很好地覆盖。也就是说，我们要把这个漏洞留到更上一层的测试。如果这个漏洞是一个简单的逻辑（比如一个消息队列发消息的接口），这样还好。如果里面有逻辑，我们必须把它作为一个重点的风险提示加以重视。不过，好在这种情况并不是很多，毕竟像 SQL 这种有复杂逻辑的东西，我们已经有了解决方案。</p><h2>总结时刻</h2><p>今天我们讲了集成测试，相对于单元测试只关注单元行为，集成测试关注的多个组件协同工作的表现。今天我们讨论了两类典型的集成问题，一种是代码之间的集成，一种是代码与外部组件的集成。</p><p>对代码之间的集成来说，一方面要考虑我们自己编写的各个单元如何协作；另一方面，在使用各种框架的情况下，要考虑与框架的集成。如果我们有了单元测试，这种集成主要是关心链路的通畅，所以一般来说我们只要沿着一条执行路径，把相关的代码组装到一起进行测试就可以了。</p><p>如果涉及框架，最好是能够把框架集成一起做了，设计得比较好的框架是对于测试的支持比较好的（比如像 Spring Boot），可以让我们很方便地进行测试。</p><p>对于外部组件的集成而言，难点在于如何控制外部组件的状态。数据库在这方面相对已经有比较成熟的解决方案：使用单独的数据库，以及在测试结束之后进行回滚。</p><p>但大部分系统没有这么好的解决方案，尤其是第三方的服务。这时候，我们就要看有没有合适的替代方案。对于大多数 REST API，我们可以采用模拟服务器对服务进行模拟。</p><p>通过今天的讨论你会发现，严格地说，有些代码由于基础设施的问题是不容易在自动化场景覆盖的，这也是我们为什么要强调与框架结合的代码一定要薄，让这种代码的影响尽可能少。这也是在减少用上层测试覆盖的工作量。</p><p>到这里，大部分的场景我们都已经可以用自动化测试进行覆盖了，我们对自己的系统已经有了更完整的理解。其实，测试的种类还有更多，比如系统测试，把整个系统集成起来测试；验收测试，交由业务人员或测试人员进行测试。但这些测试对于很多团队来说，已经到了测试人员的工作范畴了。作为程序员，我们能够把单元测试和集成测试做好，整个软件的质量已经是初步合格了。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>想办法将不同组件集成起来进行测试。</strong></p><h2>思考题</h2><p>今天我们讲了集成测试，你也看到了集成测试难点就在于如何集成。在实际工作中，你遇到过哪些难以在测试中集成的情况吗？欢迎在留言区分享你的经验。</p>","neighbors":{"left":{"article_title":"10 | 为什么 100% 的测试覆盖率是可以做到的？","id":411207},"right":{"article_title":"12 | 实战：将 ToDo 应用扩展为一个 REST 服务","id":412830}},"comments":[{"had_liked":false,"id":311016,"user_name":"sylan215","can_delete":false,"product_type":"c1","uid":1019029,"ip_address":"","ucode":"5A2CF31BC69F40","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/95/4544d905.jpg","comment_is_top":false,"comment_ctime":1631018223,"is_pvip":false,"replies":[{"id":"112716","content":"很清晰的总结","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1631059630,"ip_address":"","comment_id":311016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14515920111","product_id":100085101,"comment_content":"本节说的集成测试，和前一节是一个前提，都是针对自己写的代码的集成测试，而且可以分 2 种情况。<br><br>一种是使用了框架，这时最好能把框架集成进去做一个完整的集成测试，如果一个框架不好集成，也可以侧面说明这个框架可能设计的不够好。<br><br>另一种是引入了第三方服务，可以使用 Mock，也可以使用服务对应的成熟解决方案（比如数据库相关）来满足集成测试的需要。<br><br>如果从项目角度看，可以补充一种集成测试，就是不同开发代码间的联调测试，联调测试越早越好，尤其是技术评审流程缺失，接口标准不明确的时候。","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526436,"discussion_content":"很清晰的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631059630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310248,"user_name":"不二先生","can_delete":false,"product_type":"c1","uid":1359635,"ip_address":"","ucode":"60D9800369CC33","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELEVMHiad4wERgib6x90kI81JZhzIvQeXMju6WohePAlfjWD3gHibapVNX88G4R29Ujcbiap1Bfz0Efmg/132","comment_is_top":false,"comment_ctime":1630568101,"is_pvip":true,"replies":[{"id":"112445","content":"1的前一半和4，是第15讲讨论的内容。<br>3是第14讲讨论的内容。<br>1的后一半，代码什么时候评审和公司的开发流程相关，选择一条适合自己团队的做法就好。但最好把测试都跑了，保证整体的可用性。<br>2. API接口可以怎么测，可以看第14讲，在几种方案中选一下就好。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630632539,"ip_address":"","comment_id":310248,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5925535397","product_id":100085101,"comment_content":"郑老师，你好，我有几个问题想请教一下。<br>1. 单元测试和集成测试在执行时间上差异很大，那分别在开发流程中在哪个流程运行？<br>本地运行全部的单元测试和集成测试，通过之后提交MR，然后在CI环境运行单元测试和集成测试，通过之后进行 Code Review吗？<br>2. 单元测试的维度是函数，那对于 REST API 服务器的集成测试维度是 API 接口吗？<br>3. 如果数据库使用回滚来清除数据，那还需要单独创建数据库测试表吗？如果需要，是给每个表都创建对应的测试表吗？<br>4. 如果时间有限，是优先考虑集成测试吗？之后再补上单元测试？","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526171,"discussion_content":"1的前一半和4，是第15讲讨论的内容。\n3是第14讲讨论的内容。\n1的后一半，代码什么时候评审和公司的开发流程相关，选择一条适合自己团队的做法就好。但最好把测试都跑了，保证整体的可用性。\n2. API接口可以怎么测，可以看第14讲，在几种方案中选一下就好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630632539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309618,"user_name":"立麟","can_delete":false,"product_type":"c1","uid":1787344,"ip_address":"","ucode":"91D003962EBE13","user_header":"","comment_is_top":false,"comment_ctime":1630279557,"is_pvip":false,"replies":[{"id":"112181","content":"系统测试肯定是有自动化方案的，简单来说，就是把整个系统完全集成起来，然后，向它发消息。这种自动化的成熟程度是很高的，很多测试人员都有现成的方案，所以，我没有在程序员的测试课中做过多的介绍。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630334833,"ip_address":"","comment_id":309618,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5925246853","product_id":100085101,"comment_content":"系统测试，这里应该指的就是一般公司的开发全链路联调环节，这步是不是一般靠手工点，没啥自动化方案？","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525935,"discussion_content":"系统测试肯定是有自动化方案的，简单来说，就是把整个系统完全集成起来，然后，向它发消息。这种自动化的成熟程度是很高的，很多测试人员都有现成的方案，所以，我没有在程序员的测试课中做过多的介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630334833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1787344,"avatar":"","nickname":"立麟","note":"","ucode":"91D003962EBE13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391235,"discussion_content":"嗯嗯，交付测试后，测试部门是有自动化方案的。我问的不准确，应该说是开发阶段，开发人员不关注系统测试自动化，谢谢回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630364686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309392,"user_name":"Fredo","can_delete":false,"product_type":"c1","uid":1438470,"ip_address":"","ucode":"681D6692617DAB","user_header":"https://static001.geekbang.org/account/avatar/00/15/f3/06/8da1bf0c.jpg","comment_is_top":false,"comment_ctime":1630080680,"is_pvip":false,"replies":[{"id":"112029","content":"在本文的上面讲过了，就是带回滚数据库的解决方案，后面几节课，你会看到具体落实到代码上怎么做。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630115421,"ip_address":"","comment_id":309392,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5925047976","product_id":100085101,"comment_content":"“毕竟像 SQL 这种有复杂逻辑的东西，我们已经有了解决方案。” 这里的解决方案是指什么呢？","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525853,"discussion_content":"在本文的上面讲过了，就是带回滚数据库的解决方案，后面几节课，你会看到具体落实到代码上怎么做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630115421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1685222,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b6/e6/db12908c.jpg","nickname":"微笑","note":"","ucode":"C5EE55E23D2C57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548073,"discussion_content":"docker","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643020549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309317,"user_name":"grandgraph","can_delete":false,"product_type":"c1","uid":1016036,"ip_address":"","ucode":"B26060999DAA73","user_header":"","comment_is_top":false,"comment_ctime":1630044093,"is_pvip":false,"replies":[{"id":"112001","content":"它好像是系统测试","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630077061,"ip_address":"","comment_id":309317,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5925011389","product_id":100085101,"comment_content":"如果一个用例需要集成非常多的外部依赖才能做集成测试, 是不是也说明了这个用例的实现本身可能有问题, 比如非核心流程可以考虑用异步消息进行解耦, 以减少依赖?","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525825,"discussion_content":"它好像是系统测试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630077061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341687,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1649768150,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649768150","product_id":100085101,"comment_content":"老师，您说的单元测试可以理解，集成测试是否理解为对于某一条链路的全量测试，可以是http api对外的或者是mq接受的？还是说粒度只是比单元测试高一些，对其中几个单元测试串接的某一段流程进行集成测试？","like_count":1},{"had_liked":false,"id":311929,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1631533344,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1631533344","product_id":100085101,"comment_content":"请教老师，集成测试中的断言关注什么？尤其是对于集成测试，有很多接口是没有返回值的，例如一个增删改接口都没有返回值，只能调一次查接口才能拿到返回值。那么是不是每写一个测试用例，都要带一个查接口的操作呢？这是一直困惑我的地方","like_count":1,"discussions":[{"author":{"id":1146244,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7d/84/7ec46b3f.jpg","nickname":"阿庄","note":"","ucode":"F93635DE7D8293","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395434,"discussion_content":"REST API 增删改查一般都要返回操作的数据的。要是不返回数据的话，简单点就判断下status code，严谨点就掉接口或者查数据库，我是这么想的还没做操作过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632305595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}