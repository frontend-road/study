{"id":671056,"title":"29｜后端功能接口实战（一）：后端接口该如何开发？","content":"<p>你好，我是Barry。</p><p>在前面课程中，我们已经学过了后端接口开发的前置知识，并且我们也通过一些功能案例尝试了接口开发。</p><p>接下来的两节课，我们就结合直播视频平台的需求，来完成系统化的接口开发，让你掌握独立完成功能接口开发的能力。这节课我们先来梳理开发流程规范和接口需求，并通过创建passport认证模块编写登录注册相关的接口代码。</p><h2>接口开发流程规范</h2><p>我们先了解一下接口开发的流程规范，让你对项目及开发整体的流程更加熟悉。企业级的项目开发都要遵循开发规范，目的是让开发操作更规范，提高开发效率。流程规范一共有五条，我们依次来看看。</p><p><strong>一是需求明确。</strong>在开发接口之前，我们首先要明确接口的功能需求和数据需求。这包括接口需要实现的功能、需要接收的参数以及返回的数据格式。这些如果不在开发前明确，很容易导致我们后期返工。</p><p><strong>二是使用框架。</strong>使用现有的框架，比如Flask或Django这样的框架可以大大提高开发效率。这些框架已经为你处理了许多底层的细节，你只需要关注业务逻辑即可。我们在项目中使用的就是Flask框架。</p><p><strong>三是设计RESTful API。</strong>RESTful是一种常用的API设计风格，它简单易用，容易理解，也方便与前端进行交互。这一部分我们在Flask-RESTful这节课已经讲过了，也为你打好了基础。</p><!-- [[[read_end]]] --><p><strong>四就是进行接口测试。</strong>接口测试能够保证开发功能的实用性和完整性。通过这一步，我们就能在投入使用前提前检验我们的接口功能，保证功能顺利上线。具体就是使用Postman测试我们的API接口。这些工具无需等待前端的配合，用起来很方便。</p><p><strong>最后是第五点，编写接口文档</strong>，这是企业里每个研发团队必须要做的规范化管理。良好的文档可以帮助其他开发者理解和使用你的接口，方便团队管理协作，也有利于接口的后期维护。</p><h2>接口需求梳理</h2><p>明确了开发规范，我们再结合直播视频平台的功能梳理一下接口需求的梳理，为后续开发实战做好准备。</p><p>只有理顺了接口需求，我们才能更清晰数据库表设计以及接口的功能实现方式。我们这就来看看在线视频平台里最有代表性的几个必备接口，你可以参考后面的表格来看看。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/6d/bc530b11b47eb2db69b5ba5d896f5f6d.jpg?wh=3621x1851\" alt=\"\"></p><p>明确了功能接口的开发规范和需求情况，接下来就是实操环节。</p><h2>项目接口实战</h2><p>在整个后端实战课程中，我们每一个模块的学习和应用都是为了最终项目接口开发做准备。课程里我放的是核心代码，完整的代码你可以通过 <a href=\"https://gitee.com/Barry_Python_web/python_web_code/tree/master/29-%E5%90%8E%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%8E%A5%E5%8F%A3%E5%AE%9E%E6%88%98-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E5%85%A8%E6%B5%81%E7%A8%8B\">Gitee链接</a>获取。</p><h3>config配置管理</h3><p>首先需要搭建整体结构。我们在config文件中完成配置管理。后面是创建配置基类的代码实现。</p><pre><code class=\"language-python\">class Config:\n  DEBUG = True\n  LEVEL_LOG = logging.INFO\n  SECRET_KEY = 'slajfasfjkajfj'\n  SQL_HOST = '127.0.0.1'\n  SQL_USERNAME = 'root'\n  SQL_PASSWORD = 'root'\n  SQL_PORT = 3306\n  SQL_DB = 'my_project'\n  JSON_AS_ASCII = False\n  # 数据库的配置\n  SQLALCHEMY_DATABASE_URI = f\"mysql+pymysql://{SQL_USERNAME}:{SQL_PASSWORD}@{SQL_HOST}:{SQL_PORT}/{SQL_DB}\"\n  SQLALCHEMY_TRACK_MODIFICATIONS = False\n  REDIS_HOST = '127.0.0.1'\n  REDIS_PORT = 6379\n  \n\n# 指定session使用什么来存储\n  SESSION_TYPE = 'redis'\n  # 指定session数据存储在后端的位置\n  SESSION_REDIS = StrictRedis(host=REDIS_HOST, port=REDIS_PORT)\n  # 是否使用secret_key签名你的sessin\n  SESSION_USE_SIGNER = True\n  # 设置过期时间，要求'SESSION_PERMANENT', True。而默认就是31天\n  PERMANENT_SESSION_LIFETIME = 60 * 60 * 24  # 一天有效期\n</code></pre><p>完成基本配置之后，在config文件中我们还需要做不同环境的配置。配置类的作用就是提供一个分离的环境配置逻辑的机制，让我们无需修改代码，就可以在不同的环境中轻松使用不同的配置参数。这里我们需要分成测试环境、开发环境和生产环境这三种模式来设置。</p><p>首先来看测试环境配置类的具体代码。</p><pre><code class=\"language-python\">class TestConfig(Config):\n&nbsp; &nbsp; pass\n</code></pre><p>然后是开发环境配置类具体代码。</p><pre><code class=\"language-python\">class DevConfig(Config):\n&nbsp; &nbsp; pass\n</code></pre><p>最后是生产环境配置类具体代码。</p><pre><code class=\"language-python\">class ProConfig(Config):\n&nbsp; &nbsp; LEVEL_LOG = logging.ERROR\n&nbsp; &nbsp; DEBUG = False\n&nbsp; &nbsp; SQLALCHEMY_DATABASE_URI = \"mysql+pymysql://root:root@127.0.0.1:3306/aaa\"\n</code></pre><p></p><h3>主程序编写</h3><p>搞定配置管理以后就可以编写主程序了。我们先完成app对象的实例化，这一步是创建Flask应用实例的重要步骤，它包含了应用的各种属性和方法，用于构建 Web 应用程序。通过app对象，我们可以定义应用的路由、添加蓝图、初始化扩展等功能，进而构建出完整的应用程序。</p><p>具体做法就是在项目中创建接口api包目录，然后在__init__.py中创建app对象，具体代码如下所示。</p><pre><code class=\"language-python\">def create_app(config_name):\n    app = Flask(__name__)\n&nbsp; &nbsp; config = config_dict.get(config_name)\n&nbsp; &nbsp; setup_log(log_file='logs/root.log', level=config.LEVEL_LOG)\n&nbsp; &nbsp; app.config.from_object(config)\n&nbsp; &nbsp; db.init_app(app)\n    global redis_store\n&nbsp; &nbsp; redis_store = StrictRedis(host=config.REDIS_HOST, port=config.REDIS_PORT, decode_responses=True)\n    register_bp(app)\n</code></pre><p>这段代码中，我们完成了后面这四步动作。</p><ol>\n<li>工厂模式下，完成不同环境下配置信息导入。</li>\n<li>增加app日志管理。</li>\n<li>初始化数据库，并关联app对象。</li>\n<li>增加全局redis链接对象。</li>\n</ol><p>完成上面的操作之后，我们还需要增加注册蓝图方法，完成不同功能模块的管理。我以passport_blu模块为代表案例，带你看看具体的代码实现。其他模块增加蓝图注册方法和这里类似，只不过对应的模块名不一样。</p><pre><code class=\"language-python\">def register_bp(app)\n&nbsp; &nbsp; from api.modules.passport import passport_blu\n&nbsp; &nbsp; app.register_blueprint(passport_blu)\n\n</code></pre><p>到这里我们就完成了实例化app对象，完成了主程序的各个配置项，接下来我们就来完成moduels包的配置与开发。</p><h3>创建数据库表</h3><p>在这一部分我们将要完成创建passport认证模块，并且编写好登录和注册接口功能的代码。</p><p>首先我们需要在models下面的base.py文件中，创建模型基类。如何创建模型基类，我们在数据库实战<a href=\"https://time.geekbang.org/column/article/667908\">那节课</a>已经详细讲过了，这里我们直接看具体代码。</p><pre><code class=\"language-python\">class BaseModels:\n&nbsp; &nbsp; \"\"\"模型基类\"\"\"\n&nbsp; &nbsp; create_time = db.Column(db.DateTime, default=datetime.now)&nbsp; # 创建时间\n&nbsp; &nbsp; update_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)&nbsp; # 记录你的更新时间\n&nbsp; &nbsp; status = db.Column(db.SmallInteger, default=1)&nbsp; # 记录存活状态\n\n&nbsp; &nbsp; def add(self, obj):\n&nbsp; &nbsp; &nbsp; &nbsp; db.session.add(obj)\n&nbsp; &nbsp; &nbsp; &nbsp; return session_commit()\n\n&nbsp; &nbsp; def update(self):\n&nbsp; &nbsp; &nbsp; &nbsp; return session_commit()\n\n&nbsp; &nbsp; def delete(self):\n&nbsp; &nbsp; &nbsp; &nbsp; self.status = 0\n&nbsp; &nbsp; &nbsp; &nbsp; return session_commit()\n</code></pre><p>完成模型基类的创建后，我们就要创建用户登录表，同样还是在models文件下的user.py文件中创建。</p><pre><code class=\"language-plain\">class UserLogin(BaseModels, db.Model):\n    \"\"\"用户登录表\"\"\"\n    __tablename__ = \"user_login\"\n\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)  # 用户id\n    mobile = db.Column(db.String(16), unique=True, nullable=False)  # 手机号\n    password_hash = db.Column(db.String(128), nullable=False)  # 加密的密码\n    user_id = db.Column(db.Integer)  # 用户id\n    last_login = db.Column(db.DateTime, default=datetime.now)  # 最后一次登录时间\n    last_login_stamp = db.Column(db.Integer)  # 最后一次登录时间\n\n    @property\n    def password(self):\n        raise AttributeError('密码属性不能直接获取')\n\n    @password.setter\n    def password(self, value):  \n        self.password_hash = generate_password_hash(value)\n\n    # 传入的是明文，校验明文和数据库里面的hash之后密码 正确true\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n</code></pre><p>下一步是项目中的用户管理，在登录成功之后要展示用户信息。下面的UserInfo类主要用来创建用户信息表。</p><pre><code class=\"language-python\">class UserInfo(BaseModels, db.Model):\n&nbsp; &nbsp; \"\"\"用户信息表\"\"\"\n&nbsp; &nbsp; __tablename__ = \"user_info\"\n&nbsp; &nbsp; id = db.Column(db.Integer, primary_key=True, autoincrement=True)&nbsp; # 用户id\n&nbsp; &nbsp; nickname = db.Column(db.String(64), nullable=False)&nbsp; # 用户昵称\n&nbsp; &nbsp; mobile = db.Column(db.String(16))&nbsp; # 手机号\n&nbsp; &nbsp; avatar_url = db.Column(db.String(256))&nbsp; # 用户头像路径\n&nbsp; &nbsp; signature = db.Column(db.String(256))&nbsp; # 签名\n&nbsp; &nbsp; sex = db.Column(db.Enum('0', '1', '2'), default='0')&nbsp; # 1男&nbsp; 2 女 0 暂不填写\n&nbsp; &nbsp; birth_date = db.Column(db.DateTime)&nbsp; # 出生日期\n&nbsp; &nbsp; role_id = db.Column(db.Integer)&nbsp; # 角色id\n&nbsp; &nbsp; is_admin = db.Column(db.SmallInteger, default=0)\n\n&nbsp; &nbsp; last_message_read_time = db.Column(db.DateTime)\n\n&nbsp; &nbsp; def new_messages_counts(self):\n&nbsp; &nbsp; &nbsp; &nbsp; last_read_time = self.last_message_read_time or datetime(1900, 1, 1)\n&nbsp; &nbsp; &nbsp; &nbsp; return Message.query.filter_by(recipient_id=self.id).filter(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message.timestamp &gt; last_read_time).count()\n\n&nbsp; &nbsp; def to_dict(self):\n&nbsp; &nbsp; &nbsp; &nbsp; return {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'id': self.id,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'nickname': self.nickname,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'mobile': self.mobile,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'avatar_url': self.avatar_url,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'sex': self.sex,\n&nbsp; &nbsp; &nbsp; &nbsp; }\n</code></pre><h3>接口开发</h3><p>完成了模型基类和表的创建之后，我们还要实现具体的功能接口。</p><p>我们先来梳理一下注册接口的具体功能实现。用户注册的核心逻辑就是，在用户完成一系列信息的录入后，点击注册按钮，然后将用户信息提交到数据库中。</p><p>我们直接在modules文件下的view.py文件中实现注册接口。</p><pre><code class=\"language-python\">@passport_blu.route('/register', methods=['POST'])\ndef register():\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; 注册接口\n&nbsp; &nbsp; :return: code msg\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; data_dict = request.form\n&nbsp; &nbsp; mobile = data_dict.get('mobile')\n&nbsp; &nbsp; password = data_dict.get('password')\n&nbsp; &nbsp; img_code_id = data_dict.get('img_code_id')&nbsp; # cur_id\n&nbsp; &nbsp; img_code = data_dict.get('img_code')&nbsp; # 填写的code\n\n&nbsp; &nbsp; if not all([mobile, password, img_code_id, img_code]):\n&nbsp; &nbsp; &nbsp; &nbsp; return error(code=HttpCode.parmas_error, msg='注册所需参数不能为空')\n\n&nbsp; &nbsp; # 2.1验证手机号格式\n&nbsp; &nbsp; if not re.match('1[3456789]\\\\d{9}', mobile):\n&nbsp; &nbsp; &nbsp; &nbsp; return error(code=HttpCode.parmas_error, msg='手机号格式不正确')\n\n&nbsp; &nbsp; # 3.通过手机号取出redis中的验证码\n&nbsp; &nbsp; redis_img_code = None\n&nbsp; &nbsp; # 从redis取出img_code_id对应的验证码\n&nbsp; &nbsp; try:\n&nbsp; &nbsp; &nbsp; &nbsp; redis_img_code = redis_store.get(f'img_code: {img_code_id}')\n&nbsp; &nbsp; except Exception as e:\n&nbsp; &nbsp; &nbsp; &nbsp; current_app.logger.errer(e)\n\n&nbsp; &nbsp; if not redis_img_code:\n&nbsp; &nbsp; &nbsp; &nbsp; return error(HttpCode.parmas_error, 'redis图片验证码获取失败')\n\n&nbsp; &nbsp; if img_code.lower() != redis_img_code.lower():\n&nbsp; &nbsp; &nbsp; &nbsp; return error(HttpCode.parmas_error, '图片验证码不正确')\n\n&nbsp; &nbsp; user_info = UserInfo()\n&nbsp; &nbsp; user_info.mobile = mobile\n&nbsp; &nbsp; user_info.nickname = mobile\n&nbsp; &nbsp; user_info.add(user_info)\n\n&nbsp; &nbsp; user_login = UserLogin()\n&nbsp; &nbsp; user_login.mobile = mobile\n&nbsp; &nbsp; user_login.password = password\n&nbsp; &nbsp; user_login.user_id = user_info.id\n&nbsp; &nbsp; user_login.add(user_login)\n\n&nbsp; &nbsp; return success('注册成功')\n</code></pre><p>在前面这段代码中，通过request.form获取到用户信息之后，我们分别进行了表单非空验证、手机号格式认证以及图片验证码的认证。用户必须完成以上认证之后，才可以完成注册。</p><p>我们需要特别留意一下图片验证码的实现。这里我们主要借助三方包来生成简单的验证码接口。</p><pre><code class=\"language-python\">@passport_blu.route('/image_code')\ndef img_code():\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; 生成图像验证码\n&nbsp; &nbsp; :return: 图片的响应\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; # 1.获取请求参数,args是获取?后面的参数\n&nbsp; &nbsp; cur_id = request.args.get('cur_id')\n&nbsp; &nbsp; pre_id = request.args.get('pre_id')\n&nbsp; &nbsp; # 2.生成图片验证码\n&nbsp; &nbsp; name, text, img_data = captcha.captcha.generate_captcha()\n&nbsp; &nbsp; # 3.保存到redis\n&nbsp; &nbsp; try:\n&nbsp; &nbsp; &nbsp; &nbsp; redis_store.set(f'img_code: {cur_id}', text, IMAGE_CODE_REDIS_EXPIRES)\n&nbsp; &nbsp; &nbsp; &nbsp; # 判断是否有上一个uuid,如果存在则删除\n&nbsp; &nbsp; &nbsp; &nbsp; if pre_id:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; redis_store.delete(f'img_code: {pre_id}')\n&nbsp; &nbsp; except Exception as e:\n&nbsp; &nbsp; &nbsp; &nbsp; current_app.logger.error(e)\n&nbsp; &nbsp; &nbsp; &nbsp; return error(HttpCode.db_error, 'redis存储失败')\n&nbsp; &nbsp; # 4. 返回图片验证码\n&nbsp; &nbsp; response = make_response(img_data)\n&nbsp; &nbsp; response.headers[\"Content-Type\"] = \"image/jpg\"\n\n&nbsp; &nbsp; return response\n</code></pre><p>前面这段代码的作用是生成一个验证码，并将其存储在变量 name、text 和 img_data 中。通过调用captcha.captcha.generate_captcha()方法（这是一个生成验证码的函数），返回一个元组 (name, text, img_data)。其中name是验证码的名称，text是验证码的文本，img_data是验证码的图像数据。</p><p>当然，我们也不能忽略后面对应的异常处理，这样才能保证程序稳定执行。</p><p>用户注册接口的开发中，有个非常重要的功能——用户判重。</p><p>比方说，一个手机号我们不支持多次注册。这一步实现的逻辑是这样的：我们要在用户点击注册或完成手机号输入之后，就通过查询现有用户手机号来判断是否重合。如果查询到相同的则注册失败，相反直接注册成功。你可以结合后面的代码实现来加深理解。</p><pre><code class=\"language-python\">@passport_blu.route('/check_mobile', methods=['POST'])\ndef check_mobile():\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; 验证手机号\n&nbsp; &nbsp; # 请求路径: /passport/check_mobile\n&nbsp; &nbsp; # 请求方式: POST\n&nbsp; &nbsp; # 请求参数: mobile\n&nbsp; &nbsp; :return:code,msg\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; data_dict = request.form\n&nbsp; &nbsp; mobile = data_dict.get('mobile')\n\n&nbsp; &nbsp; try:\n&nbsp; &nbsp; &nbsp; &nbsp; users = UserLogin.query.all()\n&nbsp; &nbsp; except Exception as e:\n&nbsp; &nbsp; &nbsp; &nbsp; current_app.logger.error(e)\n&nbsp; &nbsp; &nbsp; &nbsp; return error(code=HttpCode.db_error, msg='查询用户信息异常')\n\n&nbsp; &nbsp; if mobile in [i.mobile for i in users]:\n&nbsp; &nbsp; &nbsp; &nbsp; return error(code=HttpCode.parmas_error, msg='手机号已存在，请重新输入')\n\n&nbsp; &nbsp; return success(msg=f'{mobile}，此手机号可以使用')\n</code></pre><p>这段代码中，最核心的部分就是在获取到mobile之后，通过UserLogin.query.all()方法查询数据，根据返回的数据来判断注册手机号。</p><p>到这里我们就完成了用户的注册功能，至于登录功能。我们上节课讲认证机制的时候已经详细说过，从生成Token到用户鉴权的全过程相信你已经非常熟悉了，完整代码你同样可以参考 <a href=\"https://gitee.com/Barry_Python_web/python_web_code/tree/master/29-%E5%90%8E%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%8E%A5%E5%8F%A3%E5%AE%9E%E6%88%98-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E5%85%A8%E6%B5%81%E7%A8%8B\">Gitee</a>。</p><h2>总结</h2><p>又到了课程的尾声，接下来我们一起对这节课学到的内容做个总结。</p><p>前面的课程中我们或多或少的都有涉及到接口实现的方法，这节课我们以用户注册的接口实现为例，更加体系化地实现了完整的功能开发。</p><p>具体实战前，我们先梳理了开发流程规范和接口需求。规范的流程不但能提高效率，也能更好地实现团队合作。接口需求能让我们明确之后要做哪些功能，为之后的实现环节做好预热。</p><p>接口开发阶段，我们从config项目配置管理到主程序编写，你必须要掌握实例化app对象的创建代码中每一项的作用。而在模型基类和用户表创建这一部分里，我们要注意<strong>提前梳理好每一模块的字段信息以及对应的字段类型。</strong>接口实现过程中一定要注意有业务逻辑实现和异常处理，只有全面考虑，才能保证程序的稳定执行。</p><p>这节课，我们以注册接口为案例带你体验了接口系统化开发的过程。用户相关的接口开发也是一样的实现方法，相信你在掌握了注册的接口实现之后，应对其他用户相关的接口实现也会非常轻松。希望你课后对照配套代码多多练习，巩固学习效果。</p><h2>思考题</h2><p>在课程中注册的时候我们做了图形验证，如果通过短信认证的方式来实现注册，你有什么好的想法分享么？</p><p>欢迎你在留言区和我交流互动，如果这节课对你有启发，别忘了分享给身边更多朋友。</p>","comments":[{"had_liked":false,"id":381296,"user_name":"胡超","can_delete":false,"product_type":"c1","uid":1259236,"ip_address":"广东","ucode":"C2C2AA341F854C","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/e4/f24efa91.jpg","comment_is_top":false,"comment_ctime":1695003676,"is_pvip":false,"replies":[{"id":138939,"content":"好的，感谢建议，可以调整一下，学习过程中的相关问题可以直接在聊天区留言。","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1695196500,"ip_address":"北京","comment_id":381296,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100546501,"comment_content":"建议在每段代码中针对需要引入的模块，import下或者form * import *下，不然有时会看点有点模糊，打个比方：name, text, img_data = captcha.captcha.generate_captcha()其中captchp引入的是哪个模块等，这样会有助于阅读代码，谢谢🙏","like_count":0,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628321,"discussion_content":"好的，感谢建议，可以调整一下，学习过程中的相关问题可以直接在聊天区留言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695196501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1259236,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/e4/f24efa91.jpg","nickname":"胡超","note":"","ucode":"C2C2AA341F854C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":630129,"discussion_content":"from api.thirdparty.captcha import captcha，请问下这个是引入的是python的哪个模块，我看源文件api的__init__文件下没有thirdparty.captcha这个的引入。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698130838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":628321,"ip_address":"","group_id":0},"score":630129,"extra":""}]},{"author":{"id":1259236,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/e4/f24efa91.jpg","nickname":"胡超","note":"","ucode":"C2C2AA341F854C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630130,"discussion_content":"补充提问，是pip3 install captcha? captcha模块吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698131079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}