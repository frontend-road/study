{"id":543888,"title":"04｜硬件语言筑基（二）: 代码是怎么生成具体电路的？","content":"<p>你好，我是LMOS。</p><p>上节课，我们学习了硬件描述语言Verilog的基础知识。今天我会带你一起用Verilog设计一个简单的电路模块。通过这节课，你不但能复习巩固上节课学到的硬件语言知识，还能在动手实践中体会代码是怎么生成具体电路的。</p><h2>Verilog代码编写</h2><p>如果你学过计算机组成原理的课程或图书，应该对ALU并不陌生。算术逻辑单元（Arithmetic&amp;logical Unit，ALU）是CPU的执行单元，是所有中央处理器的核心组成部分。</p><p>利用Verilog，我们可以设计一个包含加、减、与、或、非等功能的简单ALU模块，代码如下：</p><pre><code class=\"language-verilog\">module alu(a, b, cin, sel, y);\n&nbsp; input [7:0] a, b;\n&nbsp; input cin;\n&nbsp; input [3:0] sel;\n&nbsp; output [7:0] y;\n\n&nbsp; reg [7:0] y;\n&nbsp; reg [7:0] arithval;\n&nbsp; reg [7:0] logicval;\n\n&nbsp; // 算术执行单元\n&nbsp; always @(a or b or cin or sel) begin\n&nbsp; &nbsp; case (sel[2:0])\n&nbsp; &nbsp; &nbsp; 3'b000&nbsp; : arithval = a;\n&nbsp; &nbsp; &nbsp; 3'b001&nbsp; : arithval = a + 1;\n&nbsp; &nbsp; &nbsp; 3'b010&nbsp; : arithval = a - 1;\n&nbsp; &nbsp; &nbsp; 3'b011&nbsp; : arithval = b;\n&nbsp; &nbsp; &nbsp; 3'b100&nbsp; : arithval = b + 1;\n&nbsp; &nbsp; &nbsp; 3'b101&nbsp; : arithval = b - 1;\n&nbsp; &nbsp; &nbsp; 3'b110&nbsp; : arithval = a + b;\n&nbsp; &nbsp; &nbsp; default : arithval = a + b + cin;\n&nbsp; &nbsp; endcase\n&nbsp; end\n\n&nbsp; // 逻辑处理单元\n&nbsp; always @(a or b or sel) begin\n&nbsp; &nbsp; case (sel[2:0])\n&nbsp; &nbsp; &nbsp; 3'b000&nbsp; : logicval =&nbsp; ~a;\n&nbsp; &nbsp; &nbsp; 3'b001&nbsp; : logicval =&nbsp; ~b;\n&nbsp; &nbsp; &nbsp; 3'b010&nbsp; : logicval = a &amp; b;\n&nbsp; &nbsp; &nbsp; 3'b011&nbsp; : logicval = a | b;\n&nbsp; &nbsp; &nbsp; 3'b100&nbsp; : logicval =&nbsp; ~((a &amp; b));\n&nbsp; &nbsp; &nbsp; 3'b101&nbsp; : logicval =&nbsp; ~((a | b));\n&nbsp; &nbsp; &nbsp; 3'b110&nbsp; : logicval = a ^ b;\n&nbsp; &nbsp; &nbsp; default : logicval =&nbsp; ~(a ^ b);\n&nbsp; &nbsp; endcase\n&nbsp; end\n\n&nbsp; // 输出选择单元\n&nbsp; always @(arithval or logicval or sel) begin\n&nbsp; &nbsp; case (sel[3])\n&nbsp; &nbsp; &nbsp; 1'b0&nbsp; &nbsp; : y = arithval;\n&nbsp; &nbsp; &nbsp; default : y = logicval;\n&nbsp; &nbsp; endcase\n&nbsp; end\n\nendmodule\n</code></pre><!-- [[[read_end]]] --><p>通过上面的代码，我们实现了一个8位二进制的简单运算模块。其中，a和b是输入的两个8位二进制数，cin是a和b做加法运算时输入的进位值，4bit位宽的sel[3:0] 则是CPU中通常所说的指令操作码。</p><p>在这个ALU模块中，逻辑功能代码我们把它分成三个部分，分别是运算单元、逻辑处理单元和输出选择单元。运算单元是根据输入指令的低三位sel[2:0]，来选择执行加减等运算。同理，逻辑处理单元执行与或非门等操作。最后，根据指令的最高位sel[3]，来选择Y输出的是加减运算单元结果，还是逻辑处理的结果。</p><p>你还记得上节课的例子么？当时我们一起研究了一个4位10进制的计算器，里面用到了时钟设计。也就是说，这个计算器是通过时序逻辑实现的，所以always块中的赋值语言使用了非阻塞赋值“&lt;=”。</p><pre><code class=\"language-verilog\">always@(posedge clk or negedge reset_n) begin\n&nbsp; if(!reset_n) begin&nbsp; &nbsp; &nbsp; &nbsp; \t\t&nbsp; \t\t//复位时，计时归0\n&nbsp; &nbsp; &nbsp; cnt_r&nbsp; &nbsp; &nbsp; &nbsp; &lt;= 4'b0000 ;\n&nbsp; &nbsp; end\n</code></pre><p>而今天我们实现的ALU模块，用到的是组合逻辑，所以always块中使用阻塞赋值“=”。</p><p>怎么区分阻塞赋值和非阻塞赋值呢？阻塞赋值对应的电路结构往往与触发沿没有关系，只与输入电平的变化有关；而非阻塞赋值对应的电路结构往往与触发沿有关系，只有在触发沿时，才有可能发生赋值的情况。</p><p>另外，在前面8位二进制的代码里，算术执行单元和逻辑处理单元的两个always块是<strong>并行执行</strong>的。所以它们的运算结果几乎是同时出来，这里值得你好好理解一下。如果你没有发现两个块并行，可以暂停下来回顾一下。</p><h2>如何通过仿真验证代码</h2><p>就像我们开发软件，需要代码编译器和模拟器一样，Verilog这种硬件语言的代码，也需要运行验证。那怎么来运行验证呢？现在很多企业采用的是VCS—verilog仿真器或者是NC-verilog仿真器，这些工具都需要花重金去购买才能使用，普通人用起来成本太高了。</p><p>除了重金购买这些EDA工具之外，我们还有更节约成本、也更容易学习入门的选择。<strong>我给你推荐两个轻量级开源软件，分别是Iverilog和GTKWave。</strong>Iverilog是一个对Verilog进行编译和仿真的工具，而GTKWave是一个查看仿真数据波形的工具。</p><p>Iverilog运行于终端模式下，安装完成之后，我们就能通过Iverilog对verilog执行编译，再对生成的文件通过vvp命令执行仿真，配合GTKWave即可显示和查看图形化的波形。</p><p>在Linux系统下安装Iverilog和GTKWave非常简单。以Ubuntu为例，我们通过apt-get就可以直接安装。</p><blockquote>\n<p>安装Iverilog：sudo apt-get install iverilog<br>\n安装GTKWave：sudo apt-get install gtkwave</p>\n</blockquote><p>安装完成之后，我们需要使用which命令查看安装路径，确认是否安装成功。</p><blockquote>\n<p>which iverilog&nbsp;<br>\nwhich vvp&nbsp;<br>\nwhich gtkwave</p>\n</blockquote><p>有了软件和Verilog代码。在运行仿真前，我们还需要设计一个重要的文件，即仿真激励文件，也就是TestBench。在仿真时，要把TestBench放在所设计模块的顶层，以便对模块进行系统性的例化调用。</p><p>我们把TestBench放在设计模块的顶层，以便对模块进行系统性的例化，调用所设计的各个模块并对其进行仿真。</p><p>针对上面的ALU模块，设计了一个给ALU产生运算指令和数据的TestBench，并且把ALU的运算结果打印出来，TestBench的代码如下：</p><pre><code class=\"language-verilog\">`timescale 1 ns / 1 ns\n\nmodule alu_tb;\n&nbsp; reg[7:0] a, b;\n&nbsp; reg cin;\n&nbsp; reg[3:0] sel;\n&nbsp; wire[7:0] y;\n&nbsp; integer idx;\n\n  //对alu模块进行例化，类似于软件程序中的函数调用\n&nbsp; alu u_alu(.a(a), .b(b), .cin(cin), .sel(sel), .y(y));\n\n&nbsp; initial&nbsp;\n&nbsp; begin\n&nbsp; &nbsp; //给 a 和 b 赋初值\n&nbsp; &nbsp; a = 8'h93;\n&nbsp; &nbsp; b = 8'hA7;\n&nbsp; &nbsp; for (idx = 0;&nbsp; idx &lt;= 15;&nbsp; idx = idx + 1)&nbsp;\n&nbsp; &nbsp; begin\n&nbsp; &nbsp; &nbsp; // 循环产生运算指令 sel 的值\n&nbsp; &nbsp; &nbsp; sel = idx;\n&nbsp; &nbsp; &nbsp; // 当指令 sel = 7 时是加法操作，设定进位值cin=1\n&nbsp; &nbsp; &nbsp; if (idx == 7)\n&nbsp; &nbsp; &nbsp; &nbsp; cin = 1'b1;\n&nbsp; &nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; cin = 1'b0;\n&nbsp; &nbsp; &nbsp; //每产生一个指令延时10ns\n&nbsp; &nbsp; &nbsp; #10\n&nbsp; &nbsp; &nbsp; // 延时之后打印出运算结果\n&nbsp; &nbsp; &nbsp; $display(\"%t: a=%h, b=%h, cin=%b, sel=%h, y=%h\", $time, a, b, cin, sel, y);\n&nbsp; &nbsp; end&nbsp;\n&nbsp; end\n&nbsp;&nbsp;\ninitial\nbegin\n&nbsp; $dumpfile(\"wave.vcd\");&nbsp; &nbsp; &nbsp; &nbsp; //生成波形文件vcd的名称\n&nbsp; $dumpvars(0, alu_tb);&nbsp; &nbsp;\t\t //tb模块名称\nend\n\nendmodule\n</code></pre><p>这里我要说明一下，TestBench是不可以综合成具体电路的，只用于仿真验证，但和上一节课介绍的可综合的Verilog代码语法类似。</p><p>设计工作告一段落。我们终于可以打开终端开始跑仿真了。你需要在Verilog代码所在的文件目录下执行以下指令：</p><blockquote>\n<p>iverilog -o wave -y ./&nbsp; alu_tb.v&nbsp; alu.v&nbsp;<br>\nvvp -n wave -lxt2</p>\n</blockquote><p>可以看到，运行结果输出如下：</p><blockquote>\n<p>LXT2 info: dumpfile wave.vcd opened for output.<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10: a=93, b=a7, cin=0, sel=0, y=93\t\t//指令0：y = a;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20: a=93, b=a7, cin=0, sel=1, y=94\t\t//指令1：y = a + 1;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 30: a=93, b=a7, cin=0, sel=2, y=92\t\t//指令2：y = a - 1;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 40: a=93, b=a7, cin=0, sel=3, y=a7\t\t//指令3：y = b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 50: a=93, b=a7, cin=0, sel=4, y=a8\t\t//指令4：y = b + 1;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 60: a=93, b=a7, cin=0, sel=5, y=a6\t\t//指令5：y = b - 1;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 70: a=93, b=a7, cin=0, sel=6, y=3a\t\t//指令6：y = a + b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 80: a=93, b=a7, cin=1, sel=7, y=3b\t\t//指令7：y = a + b + cin;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 90: a=93, b=a7, cin=0, sel=8, y=6c\t\t//指令8：y = ~a;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;100: a=93, b=a7, cin=0, sel=9, y=58\t\t//指令9：y = ~b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;110: a=93, b=a7, cin=0, sel=a, y=83\t\t//指令10：y = a &amp; b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;120: a=93, b=a7, cin=0, sel=b, y=b7\t\t//指令11：y = a | b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;130: a=93, b=a7, cin=0, sel=c, y=7c\t\t//指令12：y = ~(a &amp; b);<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;140: a=93, b=a7, cin=0, sel=d, y=48\t\t//指令13：y = ~(a | b);<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;150: a=93, b=a7, cin=0, sel=e, y=34\t\t//指令14：y = a ^ b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;160: a=93, b=a7, cin=0, sel=f, y=cb\t\t//指令15：y = ~(a ^ b);</p>\n</blockquote><p>有了运行结果，我们就可以打开GTKWave查看仿真波形了，这里需要在终端执行如下指令：</p><blockquote>\n<p>gtkwave wave.vcd</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/f6/71/f621c24fcd2295dd7637d7e4920c8c71.jpg?wh=2204x1005\" alt=\"\"></p><p>从打开的波形可以到，ALU模块输出的信号Y，这是根据输入指令sel和输入的数据a、b和cin的值，经过加减运算或者逻辑运算得到的。</p><h2>代码是如何生成具体电路的？</h2><p>经过上面的仿真，从打印的结果上已经看到了我们设计的模块功能。而通过查看仿真波形，我们同样也能知道各个信号的跳变关系。</p><p>但是，你可能还有个疑惑，不是说设计的Verilog语句，基本都会对应一份电路吗？怎样才能看到Verilog对应了哪些电路呢？</p><p>别急，这就是我马上要讲的逻辑综合。通过逻辑综合，我们就能完成从Verilog代码到门级电路的转换。而逻辑综合的结果，就是把设计的Verilog代码，翻译成门级网表Netlist。</p><p>逻辑综合需要基于特定的综合库，不同的库中，门电路基本标准单元（Standard Cell）的面积、时序参数是不一样的。所以，选用的综合库不一样，综合出来的电路在时序、面积上也不同。因此，哪怕采用同样的设计，选用台湾的台积电（TSMC）工艺和上海的中芯国际（SMIC）的工艺，最后生产出来的芯片性能也是有差异的。</p><p>通常，工业界使用的逻辑综合工具有Synopsys的Design Compiler（DC），Cadence的 RTL Compiler，Synplicity的Synplify等。然而，这些EDA工具都被国外垄断了，且需要收取高昂的授权费用。</p><p>为了降低学习门槛和费用，这里我们选择Yosys，它是一个轻量级开源综合工具。虽然功能上还达不到工业级的EDA工具，但是对于我们这门课的学习已经完全够用了。</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/7b/9a5f496eb4d1afc872a64c7e28bcc97b.jpg?wh=3471x2905\" alt=\"\"><br>\n如上图所示，利用Yosys软件，可以帮助我们把RTL代码层次的设计转换为逻辑门级的电路。</p><p>好，我先大致带你了解下，这个软件怎么安装和使用。在Ubuntu中安装Yosys非常简单，在终端中依次执行以下命令即可：</p><blockquote>\n<p>sudo add-apt-repository ppa:saltmakrell/ppa<br>\nsudo apt-get update<br>\nsudo apt-get install yosys</p>\n</blockquote><p>完成了安装，我们就能使用Yosys，对上面设计的ALU模块做简单的综合了。</p><p>直接在终端输入“yosys”，启动Yosys软件。启动成功后，我们通过后面这五条指令，就能得到到ALU的逻辑电路图文件了。</p><p>第一步，在Yosys中读取Verilog文件。</p><blockquote>\n<p>read_verilog alu.v</p>\n</blockquote><p>第二步，使用后面的命令，检查模块例化结构。</p><blockquote>\n<p>hierarchy -check</p>\n</blockquote><p>接着是第三步，执行下一条命令，来完成高层次的逻辑综合。</p><blockquote>\n<p>proc; opt; opt; fsm; memory; opt</p>\n</blockquote><p>到了第四步，我们就可以用write_verilog生成网表文件。</p><blockquote>\n<p>write_verilog alu_synth.v</p>\n</blockquote><p>最后，我们再用下方的命令，输出综合后的逻辑图。</p><blockquote>\n<p>show -format dot -prefix ./alu</p>\n</blockquote><p>这一套动作完成后，我们终于迎来了收获成果的时刻。打开生成的alu.dot文件，我们就可以看到ALU模块的门级电路图了，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/8f/d06a02f93369fa342800cb593953248f.jpg?wh=1876x2043\" alt=\"\"></p><p>可以看到，这张图是由基本的and、or、not、add、sub、cmp、mux等电路单元组成。如果你还想进一步了解它们底层电路结构，可以自行查阅大学里学过的《数电》《模电》。</p><p>当然，Yosys功能还不只这些，这里我只是做个简易的演示。更多其它功能，如果你感兴趣的话可以到<a href=\"https://yosyshq.net/yosys\">官网</a>上学习。</p><p>到这里，类似于CPU里面的核心单元ALU电路，我们就设计完成了。</p><h2>总结回顾</h2><p>今天我们一起了解了怎么把Verilog代码变为具体的电路。为了实现代码编写、验证和仿真的“一站式”体验。我还向你推荐了几个开源软件。我们来回顾一下这节课的重点。</p><p>首先，我们用Verilog编写了一个类似CPU内部的ALU模块，该模块实现了加、减、与、或、非等基本运算功能。</p><p>针对上面的ALU模块，我们还设计了一个用于产生运算指令和数据的TestBench，并且把ALU的运算结果打印出来。利用这个TestBench，可以验证ALU模块的功能是否正确。</p><p>接下来，我们还用到了两个轻量级开源软件，分别是Iverilog和GTKWave。Iverilog是一个对Verilog进行编译和仿真的工具，GTKWave可以查看仿真数据波形的工具。利用这两个软件，我们完成了ALU模块的仿真和验证。</p><p>此外，我还推荐了一款轻量级开源综合工具Yosys。通过这个工具，我们把上面设计的ALU模块综合出了具体的门级电路。</p><p>感谢你耐心看到这里，我还给你准备了一张知识导图，总结今天所学的内容。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/7b/1409db9d4ee9967ff2a5f1bf3d39697b.jpg?wh=1920x1517\" alt=\"图片\"></p><h2>扩展阅读</h2><p>仅仅一两节课的内容，就想要把所有Verilog的相关知识学完是不可能的。因此，在课程之外，需要你去多搜索，多阅读，多动手编写Verilg代码，才能更好地掌握Verilog的相关知识，这里我精心为你整理了一些参考资料，供你按需取用：</p><p>1.首先是硬件描述语言Verilog HDL的语言标准文件《IEEE Standard Verilog Hardware Description Language (1364-2001)》。<br>\n2.如果你对底层的基本电路还不熟悉，不妨复习一下大学所学的教材。这里我推荐由童诗白和华成英编写的《模拟电子技术基础》第四版，以及阎石编写的《数字电子技术基础》。<br>\n3.你要是想全面学习数字集成电路的设计、仿真验证、逻辑综合等相关知识，可以看看电子工业出版社出版的《Verilog HDL高级数字设计》。<br>\n4.最后，你要是真的想学芯片设计，从更深层次去理解数字电路设计，推荐阅读这本Mohit Arora撰写、李海东等人翻译的图书——《硬件架构的艺术——数字电路的设计方法与技术》。</p><h2>思考题</h2><p>既然用Verilog很容易就可以设计出芯片的数字电路，为什么我们国家还没有完全自主可控的高端CPU呢？</p><p>期待你在留言区记录自己的学习收获或者疑问。如果这节课对你有帮助，也推荐你分享给更多朋友，我们一起来手写迷你CPU。</p>","neighbors":{"left":{"article_title":"03｜硬件语言筑基（一）：从硬件语言开启手写CPU之旅","id":543867},"right":{"article_title":"05｜指令架构：RISC-V到底在CPU设计上有哪些优势？","id":546957}},"comments":[]}