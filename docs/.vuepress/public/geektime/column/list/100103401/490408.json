{"id":490408,"title":"题目解答 | 期中考试版本参考实现","content":"<p>你好，我是朱涛。上节课我给你布置了一份考试题，你完成得怎么样了呢？这节课呢，我会来告诉你我是如何用Kotlin来做这个图片处理程序的，供你参考。</p><p>由于上节课我们已经做好了前期准备，所以这里我们直接写代码就行了。</p><h2>1.0版本</h2><p>对于图片反转和裁切的这个问题，如果一开始你就去想象一个大图片，里面有几万个像素点，那你可能会被吓到。但是，如果你将数据规模缩小，再来分析的话，你会发现这个问题其实很简单。</p><p>这里，我们就以一张4X4像素的照片为例来分析一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/20/2f31e490e0b973c9511e4aaa921f0520.jpg?wh=1498x646\" alt=\"\"></p><p>这其实就相当于一个抽象的模型，如果我们基于这张4X4的照片，继续分析翻转和裁切，就会容易很多。我们可以来画一个简单的图形：</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/8d/b6a1a1f3b70b9b1a8132c51a92660d8d.jpg?wh=2000x814\" alt=\"\"></p><p>上面这张图，从左到右分别是原图、横向翻转、纵向翻转、裁切。其中，翻转看起来是要复杂一些，而裁切是最简单的。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/c3/64001cb039dbcff66c4e9eec48dcf6c3.jpg?wh=2000x789\" alt=\"\"></p><p>我们先来处理裁切。对于裁切，其实只需要将图片当中某个部分的像素拷贝到内存，然后存储成为一张新图片就行了。</p><pre><code class=\"language-plain\">/**\n * 图片裁切\n */\nfun Image.crop(startY: Int, startX: Int, width: Int, height: Int): Image {\n    val pixels = Array(height) { y -&gt;\n        Array(width) { x -&gt;\n            getPixel(startY + y, startX + x)\n        }\n    }\n    return Image(pixels)\n}\n</code></pre><!-- [[[read_end]]] --><p>以上代码中，我们创建了一个新数组pixels，它的创建方式是通过Lambda来实现的，而Lambda当中最关键的逻辑，就是 <code>getPixel(startY + y, startX + x)</code>，也就是从原图当中取像素点。</p><p>这代码是不是比你想象中简单很多？其实，图片的翻转也是一样的。只要我们能<strong>找出坐标的对应关系</strong>，代码也非常简单。</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/c8/7aeeb78bb0a4a6f8cb4a3308e2842fc8.jpg?wh=1633x880\" alt=\"\"></p><p>可以看到，对于原图的(1, 0)这个像素点来说，它横向翻转以后就变成了(2, 0)。所以，对于(x, y)坐标来说，横向翻转以后，就应该变成(width-1-x, y)。找到这个对应关系以后，我们就直接抄代码了！</p><pre><code class=\"language-plain\">/**\n * 横向翻转图片\n */\nfun Image.flipHorizontal(): Image {\n    val pixels = Array(height()) { y -&gt;\n        Array(width()) { x -&gt;\n            getPixel(y, width() - 1 - x)\n        }\n    }\n    return Image(pixels)\n}\n</code></pre><p>可见，以上这段代码几乎跟裁切是一模一样的，只是说，裁切要限制宽高，而翻转则是跟原图保持一致。</p><p>看到这里，相信你也马上就能想明白纵向翻转的代码该如何写了！</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/1e/2e7ae2ec91856141ff2881ec2cdb441e.jpg?wh=1671x899\" alt=\"\"></p><p>我们还是以(1, 0)这个像素点为例，在纵向翻转以后就变成了(1, 3)，它们的转换规则是(x, height-1-y)。</p><pre><code class=\"language-plain\">/**\n * 纵向翻转图片\n */\nfun Image.flipVertical(): Image {\n    val pixels = Array(height()) { y -&gt;\n        Array(width()) { x -&gt;\n            getPixel(height() - 1 - y, x) // 改动这里\n        }\n    }\n    return Image(pixels)\n}\n</code></pre><p>所以说，只要我们能找到中间的转换关系，纵向翻转的代码，只需要在横向翻转的基础上，改动一行即可。</p><h3>单元测试</h3><p>其实针对图像算法的单元测试，我们最好的方式，就是准备一些现有的图片案例。比如说，我们随便找一张图，用其他的软件工具，对它进行翻转、裁切，然后存储起来。比如还是这四张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/85/d8/85f71d3914e23b7ed8664ae57f0e9fd8.png?wh=1128x424\" alt=\"图片\"></p><p>我们可以把处理后的图片保存在单元测试的文件夹下，方便我们写对应的测试用例。</p><p><img src=\"https://static001.geekbang.org/resource/image/47/d2/47ff01b7fd65dcf6e99e298be6e104d2.png?wh=478x327\" alt=\"图片\"></p><p>那么，有了这些图片之后，我想你应该就能想到要怎么办了。这时候，你只需要写一个图片像素对比的方法checkImageSame()就好办了。</p><pre><code class=\"language-plain\">private fun checkImageSame(picture: Image, expected: Image) {\n    assertEquals(picture.height(), expected.height())\n    assertEquals(picture.width(), expected.width())\n    for (row in 0 until picture.height()) {\n        for (column in 0 until picture.width()) {\n            val actualPixel = picture.getPixel(row, column)\n            val expectedPixel = expected.getPixel(row, column)\n            assertEquals(actualPixel, expectedPixel)\n        }\n    }\n}\n</code></pre><p>其实，这个函数的思路也很简单，就是逐个对比两张图片之间的像素，看看它们是不是一样的，如果两张图所有的像素都一样，那肯定就是一样的。</p><p>有了这个方法以后，我们就可以快速实现单元测试代码了。整体流程大致如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/a6/d37e162b313258fa01ed4f1a99d7d0a6.png?wh=1114x394\" alt=\"图片\"></p><pre><code class=\"language-plain\">@Test\nfun testCrop() {\n    val image = loadImage(File(\"${TEST_BASE_PATH}android.png\"))\n    val height = image.height() / 2\n    val width = image.width() / 2\n    val target = loadImage(File(\"${TEST_BASE_PATH}android_half_crop.png\"))\n\n    val crop = image.crop(0, 0, width, height)\n    checkImageSame(crop, target)\n}\n\n@Test\nfun testFlipVertical() {\n    val origin = loadImage(File(\"${TEST_BASE_PATH}android.png\"))\n    val target = loadImage(File(\"${TEST_BASE_PATH}android_up_side_down.png\"))\n    val flipped = origin.flipVertical()\n    checkImageSame(flipped, target)\n}\n\n@Test\nfun testFlipHorizontal() {\n    val origin = loadImage(File(\"${TEST_BASE_PATH}android.png\"))\n    val target = loadImage(File(\"${TEST_BASE_PATH}android_flipped.png\"))\n    val flipped = origin.flipHorizontal()\n    checkImageSame(flipped, target)\n}\n</code></pre><p>有了单元测试，我们就再也不用担心以后改代码的时候，不小心改出问题了。</p><p>好，那么到这里，1.0版本就算是完成了。我们接着来看看2.0版本。</p><h2>2.0版本</h2><p>2.0版本的任务，我们需要支持下载网络上面的图片，并且还要能够存起来。由于这是一个比较耗时的操作，我们希望它是一个挂起函数。</p><p>关于下载HTTP的图片，其实，我们借助OkHttp就可以简单实现。下面我们来看看代码。</p><blockquote>\n<p>补充：为了不偏离主题，我们不考虑HTTPS的问题。</p>\n</blockquote><pre><code class=\"language-plain\">fun downloadSync() {\n    logX(\"Download start!\")\n    val okHttpClient = OkHttpClient().newBuilder()\n        .connectTimeout(10L, TimeUnit.SECONDS)\n        .readTimeout(10L, TimeUnit.SECONDS)\n        .build()\n\n    val request = Request.Builder().url(url).build()\n    val response = okHttpClient.newCall(request).execute()\n\n    val body = response.body\n    val responseCode = response.code\n\n    if (responseCode &gt;= HttpURLConnection.HTTP_OK &amp;&amp;\n        responseCode &lt; HttpURLConnection.HTTP_MULT_CHOICE &amp;&amp;\n        body != null\n    ) {\n        // 1， 注意这里\n        body.byteStream().apply {\n            outputFile.outputStream().use { fileOut -&gt;\n                copyTo(fileOut)\n            }\n        }\n    }\n    logX(\"Download finish!\")\n}\n</code></pre><p>以上代码中，有一个地方是需要注意的，我用注释标记了。也就是当我们想要把网络流中的数据存起来的时候，我们可以借助Kotlin提供的 <strong>IO扩展函数</strong>快速实现，这样不仅方便，而且还不用担心FileOutputStream调用close()的问题。这个部分的代码，在Java当中，是要写一堆模板代码的。</p><p>下载本身的功能实现以后，挂起函数的封装也就容易了。</p><pre><code class=\"language-plain\">suspend fun downloadImage(url: String, outputFile: File): Boolean {\n    return withContext(Dispatchers.IO) {\n        try {\n            downloadSync()\n        } catch (e: Exception) {\n            println(e)\n            // return@withContext  不可省略\n            return@withContext false\n        }\n        // return@withContext 可省略\n        return@withContext true\n    }\n}\n</code></pre><p>这里，我们可以直接用 <strong>withContext</strong>，让下载的任务直接分发到IO线程。</p><p>代码写到这里，2.0版本要求的功能基本上就算是完成了。这样一来，我们就可以在main函数当中去调用它了。</p><pre><code class=\"language-plain\">fun main() = runBlocking {\n    val url = \"http://xxxx.jpg\"\n    val path = \"${BASE_PATH}downloaded.png\"\n\n    downloadImage(url, File(path))\n\n    loadImage(File(path))\n        .flipVertical()\n        .writeToFile(File(\"${BASE_PATH}download_flip_vertical.png\"))\n\n    logX(\"Done\")\n}\n\n// 将内存图片保存到硬盘\nfun Image.writeToFile(outputFile: File): Boolean {\n    return try {\n        val width = width()\n        val height = height()\n        val image = BufferedImage(width, height, BufferedImage.TYPE_INT_RGB)\n        for (x in 0 until width) {\n            for (y in 0 until height) {\n                val awtColor = getPixel(y, x)\n                image.setRGB(x, y, awtColor.rgb)\n            }\n        }\n        ImageIO.write(image, \"png\", outputFile)\n        true\n    } catch (e: Exception) {\n        println(e)\n        false\n    }\n}\n\n/*\n输出结果：\n================================\nDownload start!\nThread:DefaultDispatcher-worker-1\n================================\n================================\nDownload finish!\nThread:DefaultDispatcher-worker-1\n================================\n================================\nDone\nThread:main\n================================\n*/\n</code></pre><p>通过运行结果，我们会发现图片下载的任务，已经被分发到IO线程池了，而其他的代码仍然在主线程之上。</p><h2>小结</h2><p>其实，课程进行到这里，你就会发现，Kotlin和Java、C之类的语言的编程方式是完全不一样的。Kotlin提供了丰富的扩展函数，在很多业务场景下，Kotlin是可以大大减少代码量的。</p><p>另外，你也会发现，当你熟悉Kotlin协程以后，它的使用一点都不难。对于上面的代码，我们通过withContext(Dispatchers.IO)就能切换线程，之后，我们就可以在协程作用域当中随意调用了！</p><h2>思考题</h2><p>你觉得，我们在downloadImage()这个挂起函数内部，直接写死Dispatchers.IO的方式好吗？如果换成下面这种写法，会不会更好？为什么？</p><pre><code class=\"language-plain\">suspend fun downloadImage(\n    coroutineContext: CoroutineContext = Dispatchers.IO,\n    url: String,\n    outputFile: File\n): Boolean {\n\n    return withContext(coroutineContext) {\n        try {\n            downloadSync()\n        } catch (e: Exception) {\n            println(e)\n            return@withContext false\n        }\n        return@withContext true\n    }\n}\n</code></pre>","comments":[{"had_liked":false,"id":336201,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1127306,"ip_address":"","ucode":"3F69DAC14260DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","comment_is_top":false,"comment_ctime":1646008880,"is_pvip":false,"replies":[{"id":"122959","content":"嗯，各有利弊。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646136051,"ip_address":"","comment_id":336201,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18825878064","product_id":100103401,"comment_content":"思考题中关于调度器的使用不太好，一般的使用方式是通过暴露参数的方式让使用者来传。<br><br>通过传参的方式有两个好处： <br>1. 增加了代码的灵活性和可用性。<br>2. 有利于单元测试。","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553936,"discussion_content":"嗯，各有利弊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646136051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337005,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1646546898,"is_pvip":false,"replies":[{"id":"123149","content":"这代码改进的很不错，赞！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646580076,"ip_address":"","comment_id":337005,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10236481490","product_id":100103401,"comment_content":"class Image(private val pixels: Array&lt;Array&lt;Color&gt;&gt;) {<br>    val height: Int = pixels.size<br>    val width: Int = pixels[0].size<br>    private fun getPixel(y: Int, x: Int): Color = pixels[y][x]<br><br>    fun flipHorizontal() = changeImage { y, x -&gt; getPixel(y, width - 1 - x) } &#47;&#47;横向翻转图片<br><br>    fun flipVertical() = changeImage { y, x -&gt; getPixel(height - 1 - y, x) }  &#47;&#47;纵向翻转图片<br><br>    fun crop(startY: Int, startX: Int, width: Int, height: Int): Image =<br>        toImage(height, width) { y, x -&gt; getPixel(startY + y, startX + x) } &#47;&#47;图片裁切<br>}<br><br>fun Image.changeImage(init: (Int, Int) -&gt; Color): Image = toImage(height, width, init)<br><br>fun loadImage(imageFile: File): Image =<br>    ImageIO.read(imageFile)<br>        .let { toImage(it.height, it.width) { x, y -&gt; Color(it.getRGB(x, y)) } }<br><br>fun toImage(height: Int, width: Int, init: (Int, Int) -&gt; Color): Image =<br>    Array(height) { y -&gt; &#47;&#47; 创建一个 Array，元素类型也是 Array<br>        Array(width) { x -&gt; &#47;&#47; 创建一个 Array，元素类型是 Color<br>            init(x, y) &#47;&#47; 每个元素都是在 init() 中初始化的<br>        }<br>    }.let { Image(it) }","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554752,"discussion_content":"这代码改进的很不错，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646580076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336341,"user_name":"PoPlus","can_delete":false,"product_type":"c1","uid":1574765,"ip_address":"","ucode":"5F0927921317F2","user_header":"https://static001.geekbang.org/account/avatar/00/18/07/6d/4c1909be.jpg","comment_is_top":false,"comment_ctime":1646103294,"is_pvip":false,"replies":[{"id":"122955","content":"其实，这个问题没有标准答案。我只是提出这个问题，希望大家思考这中间的差异。因为，有的时候，更多的灵活性也并不意味着是好事。<br><br>动态传入的方式，有利有弊。利：更灵活；弊，调用方可能传错Context。<br><br>总的来说，还是要结合使用场景来分析。有些场景下，我们更加重视灵活性，就选择动态传入，有的场景下，我们都希望尽可能的不出问题。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646135893,"ip_address":"","comment_id":336341,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10236037886","product_id":100103401,"comment_content":"暂时没想到 context 动态传入有什么好处，按理说下载图片只需要 IO 就行了，希望老师能解惑。","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553932,"discussion_content":"其实，这个问题没有标准答案。我只是提出这个问题，希望大家思考这中间的差异。因为，有的时候，更多的灵活性也并不意味着是好事。\n\n动态传入的方式，有利有弊。利：更灵活；弊，调用方可能传错Context。\n\n总的来说，还是要结合使用场景来分析。有些场景下，我们更加重视灵活性，就选择动态传入，有的场景下，我们都希望尽可能的不出问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646135893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336200,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1127306,"ip_address":"","ucode":"3F69DAC14260DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","comment_is_top":false,"comment_ctime":1646008625,"is_pvip":false,"replies":[{"id":"122958","content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646136031,"ip_address":"","comment_id":336200,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10235943217","product_id":100103401,"comment_content":"这个下载图片的实现和我们普通开线程下载的主要区别就是使用同步的写法（不需要写 callback）来实现了异步的操作。","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553935,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646136031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360967,"user_name":"24隋心所欲","can_delete":false,"product_type":"c1","uid":1342000,"ip_address":"河北","ucode":"1B8B2789F68C94","user_header":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","comment_is_top":false,"comment_ctime":1667041594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1667041594","product_id":100103401,"comment_content":"使用 withContext() 的主意作用就是切换线程吗？","like_count":0},{"had_liked":false,"id":354883,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"美国","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1660857688,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1660857688","product_id":100103401,"comment_content":"InputStream应该也需要正常close吧？例如<br><br>        body.byteStream().use {<br>            outputFile.outputStream().use { fileOut -&gt;<br>                it.copyTo(fileOut)<br>            }<br>        }","like_count":0,"discussions":[{"author":{"id":2993222,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/ac/46/44deaa51.jpg","nickname":"木木","note":"","ucode":"70F488F4FEDE32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585234,"discussion_content":"请问下，为啥我调用不了outputFile.outputStream() 。没有outputFile这个API","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661411572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348119,"user_name":"Link","can_delete":false,"product_type":"c1","uid":1429351,"ip_address":"","ucode":"BD506AFA58D5AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/cf/67/f5dc357a.jpg","comment_is_top":false,"comment_ctime":1654760572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654760572","product_id":100103401,"comment_content":"有个疑惑，类似 fun Image.writeToFile（），这样的扩展多了话会不会导致其他地方在使用Image类的时候产生疑惑（过度扩展？），但函数式风格的编程似乎就必须写一堆扩展方法？望老师解惑","like_count":0},{"had_liked":false,"id":337816,"user_name":"Geek_Adr","can_delete":false,"product_type":"c1","uid":2876897,"ip_address":"","ucode":"129E17B7D3EB88","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e5/e1/a5064f88.jpg","comment_is_top":false,"comment_ctime":1647075588,"is_pvip":false,"replies":[{"id":"123587","content":"很好的思路。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1647235803,"ip_address":"","comment_id":337816,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647075588","product_id":100103401,"comment_content":"灵活会带来API难用，增加犯错的概率，但又不能把灵活丢掉<br><br>兼得的方法：先给一套默认最佳实现，满足大多数情况，使用者清晰知道默认实现不满足时再给灵活的方案<br><br>我认为可配有默认实现的方式更好","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556164,"discussion_content":"很好的思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647235803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336521,"user_name":"曾帅","can_delete":false,"product_type":"c1","uid":1234319,"ip_address":"","ucode":"322F049DA9284D","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/8f/d0874a01.jpg","comment_is_top":false,"comment_ctime":1646201390,"is_pvip":false,"replies":[{"id":"123017","content":"是的，要结合具体的场景来分析。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646271289,"ip_address":"","comment_id":336521,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646201390","product_id":100103401,"comment_content":"这个问题 或许 可以根据项目来，有些项目可能有自己的 线程池 或者一些 生命周期 的要求，就可以根据业务需求进行传参进行处理。如果没有这些需求的话，直接用 IO 也是可以的。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554210,"discussion_content":"是的，要结合具体的场景来分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646271289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336405,"user_name":"L先生","can_delete":false,"product_type":"c1","uid":2879424,"ip_address":"","ucode":"D1E567ED3377CE","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ef/c0/537b3905.jpg","comment_is_top":false,"comment_ctime":1646130275,"is_pvip":false,"replies":[{"id":"122969","content":"嗯，后者的灵活性更强。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646181597,"ip_address":"","comment_id":336405,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646130275","product_id":100103401,"comment_content":"我觉得会好点，给调用者选择的权利，并且赋予默认值，方便单元测试","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553991,"discussion_content":"嗯，后者的灵活性更强。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646181597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}