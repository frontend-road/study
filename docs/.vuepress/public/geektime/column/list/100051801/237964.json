{"id":237964,"title":"06 | auto/decltype：为什么要有自动类型推导？","content":"<p>你好，我是Chrono。</p><p>前两周我们从宏观的层面上重新认识了C++，从今天开始，我们将进入一个新的“语言特性”单元，“下沉”到微观的层面去观察C++，一起去见一些老朋友、新面孔，比如const、exception、lambda。</p><p>这次要说的，就是C++11里引入的一个很重要的语言特性：自动类型推导。</p><h2>自动类型推导</h2><p>如果你有过一些C++的编程经验，了解过C++11，那就一定听说过“<strong>自动类型推导</strong>”（auto type deduction）。</p><p>它其实是一个非常“老”的特性，C++之父Bjarne Stroustrup（B·S )早在C++诞生之初就设计并实现了它，但因为与早期C语言的语义有冲突，所以被“雪藏”了近三十年。直到C99消除了兼容性问题，C++11才让它再度登场亮相。</p><p>那为什么要重新引入这个“老特性”呢？为什么非要有“自动类型推导”呢？</p><p>我觉得，你可以先从字面上去理解，把这个词分解成三个部分：“自动”“类型”和“推导”。</p><ul>\n<li>“自动”就是让计算机去做，而不是人去做，相对的是“手动”。</li>\n<li>“类型”指的是操作目标，出来的是编译阶段的类型，而不是数值。</li>\n<li>“推导”就是演算、运算，把隐含的值给算出来。</li>\n</ul><p>好，我们来看一看“自动类型推导”之外的其他几种排列组合，通过对比的方式来帮你理解它。</p><!-- [[[read_end]]] --><p>像计算“a = 1 + 1”，你可以在写代码的时候直接填上2，这就是“手动数值推导”。你也可以“偷懒”，只写上表达式，让电脑在运行时自己算，这就是“自动数值推导”。</p><p>“数值推导”对于人和计算机来说都不算什么难事，所以手动和自动的区别不大，只有快慢的差异。但“类型推导”就不同了。</p><p>因为C++是一种静态强类型的语言，任何变量都要有一个确定的类型，否则就不能用。在“自动类型推导”出现之前，我们写代码时只能“手动推导”，也就是说，在声明变量的时候，必须要明确地给出类型。</p><p>这在变量类型简单的时候还好说，比如int、double，但在泛型编程的时候，麻烦就来了。因为泛型编程里会有很多模板参数，有的类型还有内部子类型，一下子就把C++原本简洁的类型体系给搞复杂了，这就迫使我们去和编译器“斗智斗勇”，只有写对了类型，编译器才会“放行”（编译通过）。</p><pre><code>int       i = 0;            // 整数变量，类型很容易知道\ndouble    x = 1.0;          // 浮点数变量，类型很容易知道\n\nstd::string str = &quot;hello&quot;;  // 字符串变量，有了名字空间，麻烦了一点\n\nstd::map&lt;int, std::string&gt; m = // 关联数组，名字空间加模板参数，很麻烦\n        {{1,&quot;a&quot;}, {2,&quot;b&quot;}};    // 使用初始化列表的形式\n\nstd::map&lt;int, std::string&gt;::const_iterator // 内部子类型，超级麻烦\niter = m.begin();\n\n？？？ = bind1st(std::less&lt;int&gt;(), 2);  // 根本写不出来\n</code></pre><p>虽然你可以用typedef或者using来简化类型名，部分减轻打字的负担，但关键的“手动推导”问题还是没有得到解决，还是要去翻看类型定义，找到正确的声明。这时，C++的静态强类型的优势反而成为了劣势，阻碍了程序员的工作，降低了开发效率。</p><p>其实编译器是知道（而且也必须知道）这些类型的，但它却没有办法直接告诉你，这就很尴尬了。一边是急切地想知道答案，而另一边却只给判个对错，至于怎么错了、什么是正确答案，“打死了也不说”。</p><p>但有了“自动类型推导”，问题就迎刃而解了。这就像是在编译器紧闭的大门上开了道小口子，你跟它说一声，它就递过来张小纸条，具体是什么不重要，重要的是里面存了我们想要的类型。</p><p>这个“小口子”就是关键字<strong>auto</strong>，在代码里的作用像是个“占位符”（placeholder）。写上它，你就可以让编译器去自动“填上”正确的类型，既省力又省心。</p><pre><code>auto  i = 0;          // 自动推导为int类型\nauto  x = 1.0;        // 自动推导为double类型\n\nauto  str = &quot;hello&quot;;  // 自动推导为const char [6]类型\n\nstd::map&lt;int, std::string&gt; m = {{1,&quot;a&quot;}, {2,&quot;b&quot;}};  // 自动推导不出来\n\nauto  iter = m.begin();  // 自动推导为map内部的迭代器类型\n\nauto  f = bind1st(std::less&lt;int&gt;(), 2);  // 自动推导出类型，具体是啥不知道\n</code></pre><p>不过需要注意的是，因为C++太复杂，“自动类型推导”有时候可能失效，给不出你想要的结果。比如，在上面的这段代码里，就把字符串的类型推导成了“const char [6]”而不是“std::string”。而有的时候，编译器也理解不了代码的意思，推导不出恰当的类型，还得你自己“亲力亲为”。</p><p>在这个示例里，你还可以直观感觉到auto让代码干净整齐了很多，不用去写那些复杂的模板参数了。但如果你把“自动类型推导”理解为仅仅是简化代码、少打几个字，那就实在是浪费了C++标准委员会的一番苦心。</p><p><strong>除了简化代码，auto还避免了对类型的“硬编码”</strong>，也就是说变量类型不是“写死”的，而是能够“自动”适应表达式的类型。比如，你把map改为unordered_map，那么后面的代码都不用动。这个效果和类型别名（<a href=\"https://time.geekbang.org/column/article/235301\">第5讲</a>）有点像，但你不需要写出typedef或者using，全由auto“代劳”。</p><p>另外，你还应该认识到，“自动类型推导”实际上和“attribute”一样（<a href=\"https://time.geekbang.org/column/article/235295\">第4讲</a>），是编译阶段的特殊指令，指示编译器去计算类型。所以，它在泛型编程和模板元编程里还有更多的用处，后面我会陆续讲到。</p><h2>认识auto</h2><p>刚才说了，auto有时候会不如你设想的那样工作，因此在使用的时候，有一些需要特别注意的地方，下面我就给你捋一捋。</p><p>首先，你要知道，auto的“自动推导”能力只能用在“<strong>初始化</strong>”的场合。</p><p>具体来说，就是<strong>赋值初始化</strong>或者<strong>花括号初始化</strong>（初始化列表、Initializer list），变量右边必须要有一个表达式（简单、复杂都可以）。这样你才能在左边放上auto，编译器才能找到表达式，帮你自动计算类型。</p><p>如果不是初始化的形式，只是“纯”变量声明，那就无法使用auto。因为这个时候没有表达式可以让auto去推导。</p><pre><code>auto x = 0L;    // 自动推导为long\nauto y = &amp;x;    // 自动推导为long*\nauto z {&amp;x};    // 自动推导为long* \n\nauto err;       // 错误，没有赋值表达式，不知道是什么类型\n</code></pre><p>这里还有一个特殊情况，在类成员变量初始化的时候（<a href=\"https://time.geekbang.org/column/article/235301\">第5讲</a>），目前的C++标准不允许使用auto推导类型（但我个人觉得其实没有必要，也许以后会放开吧）。所以，在类里你还是要老老实实地去“手动推导类型”。</p><pre><code>class X final\n{\n    auto a = 10;  // 错误，类里不能使用auto推导类型\n};\n</code></pre><p>知道了应用场合，你还需要了解auto的推导规则，保证它能够按照你的意思去工作。虽然标准里规定得很复杂、很细致，但我总结出了两条简单的规则，基本上够用了：</p><ul>\n<li><strong>auto总是推导出“值类型”，绝不会是“引用”；</strong></li>\n<li><strong>auto可以附加上const、volatile、*、&amp;这样的类型修饰符，得到新的类型。</strong></li>\n</ul><p>下面我举几个例子，你一看就能明白：</p><pre><code>auto        x = 10L;\t\t// auto推导为long，x是long\n\nauto&amp;       x1 = x;\t\t  // auto推导为long，x1是long&amp;\nauto*       x2 = &amp;x;\t  // auto推导为long，x2是long*\nconst auto&amp; x3 = x;\t      // auto推导为long，x3是const long&amp;\nauto        x4 = &amp;x3;\t  // auto推导为const long*，x4是const long*\n</code></pre><h2>认识decltype</h2><p>前面我都在说auto，其实，C++的“自动类型推导”还有另外一个关键字：<strong>decltype</strong>。</p><p>刚才你也看到了，auto只能用于“初始化”，而这种“<strong>向编译器索取类型</strong>”的能力非常有价值，把它限制在这么小的场合，实在是有点“屈才”了。</p><p>“自动类型推导”要求必须从表达式推导，那在没有表达式的时候，该怎么办呢？</p><p>其实解决思路也很简单，就是“自己动手，丰衣足食”，自己带上表达式，这样就走到哪里都不怕了。</p><p>decltype的形式很像函数，后面的圆括号里就是可用于计算类型的表达式（和sizeof有点类似），其他方面就和auto一样了，也能加上const、*、&amp;来修饰。</p><p>但因为它已经自带表达式，所以不需要变量后面再有表达式，也就是说可以直接声明变量。</p><pre><code>int x = 0;\t\t\t\t\t// 整型变量\n\ndecltype(x)     x1;      // 推导为int，x1是int\ndecltype(x)&amp;    x2 = x;    // 推导为int，x2是int&amp;，引用必须赋值\ndecltype(x)*    x3;      // 推导为int，x3是int*\ndecltype(&amp;x)    x4;      // 推导为int*，x4是int*\ndecltype(&amp;x)*   x5;      // 推导为int*，x5是int**\ndecltype(x2)    x6 = x2;  // 推导为int&amp;，x6是int&amp;，引用必须赋值\n</code></pre><p>把decltype和auto比较一下，简单来看，好像就是把表达式改到了左边而已，但实际上，在推导规则上，它们有一点细微且重要的区别：</p><p><strong>decltype不仅能够推导出值类型，还能够推导出引用类型，也就是表达式的“原始类型”</strong>。</p><p>在示例代码中，我们可以看到，除了加上*和&amp;修饰，decltype还可以直接从一个引用类型的变量推导出引用类型，而auto就会把引用去掉，推导出值类型。</p><p>所以，你完全可以把decltype看成是一个真正的类型名，用在变量声明、函数参数/返回值、模板参数等任何类型能出现的地方，只不过这个类型是在编译阶段通过表达式“计算”得到的。</p><p>如果不信的话，你可以用using类型别名来试一试。</p><pre><code>using int_ptr = decltype(&amp;x);    // int *\nusing int_ref = decltype(x)&amp;;    // int &amp;\n</code></pre><p>既然decltype类型推导更精确，那是不是可以替代auto了呢？</p><p>实际上，它也有个缺点，就是写起来略麻烦，特别在用于初始化的时候，表达式要重复两次（左边的类型计算，右边的初始化），把简化代码的优势完全给抵消了。</p><p>所以，C++14就又增加了一个“<strong>decltype(auto)</strong>”的形式，既可以精确推导类型，又能像auto一样方便使用。</p><pre><code>int x = 0;\t\t\t\t\t\t// 整型变量\n\ndecltype(auto)     x1 = (x);  // 推导为int&amp;，因为(expr)是引用类型\ndecltype(auto)     x2 = &amp;x;   // 推导为int*\ndecltype(auto)     x3 = x1;   // 推导为int&amp;\n</code></pre><h2>使用auto/decltype</h2><p>现在，我已经讲完了“自动类型推导”的两个关键字：auto和decltype，那么，该怎么用好它们呢？</p><p>我觉得，因为auto写法简单，推导规则也比较好理解，所以，<strong>在变量声明时应该尽量多用auto</strong>。前面已经举了不少例子，这里就不再重复了。</p><p>auto还有一个“最佳实践”，就是“<strong>range-based for</strong>”，不需要关心容器元素类型、迭代器返回值和首末位置，就能非常轻松地完成遍历操作。不过，为了保证效率，最好使用“const auto&amp;”或者“auto&amp;”。</p><pre><code> vector&lt;int&gt; v = {2,3,5,7,11};\t// vector顺序容器\n\n for(const auto&amp; i : v) {\t    // 常引用方式访问元素，避免拷贝代价\n     cout &lt;&lt; i &lt;&lt; &quot;,&quot;;          // 常引用不会改变元素的值\n }\n\n for(auto&amp; i : v) {\t        // 引用方式访问元素\n     i++;\t                    // 可以改变元素的值\n     cout &lt;&lt; i &lt;&lt; &quot;,&quot;;\n }\n</code></pre><p>在C++14里，auto还新增了一个应用场合，就是能够推导函数返回值，这样在写复杂函数的时候，比如返回一个pair、容器或者迭代器，就会很省事。</p><pre><code>auto get_a_set()              // auto作为函数返回值的占位符\n{\n    std::set&lt;int&gt; s = {1,2,3};\n    return s;\n}\n</code></pre><p>再来看decltype怎么用最合适。</p><p>它是auto的高级形式，更侧重于编译阶段的类型计算，所以常用在泛型编程里，获取各种类型，配合typedef或者using会更加方便。当你感觉“这里我需要一个特殊类型”的时候，选它就对了。</p><p>比如说，定义函数指针在C++里一直是个比较头疼的问题，因为传统的写法实在是太怪异了。但现在就简单了，你只要手里有一个函数，就可以用decltype很容易得到指针类型。</p><pre><code>// UNIX信号函数的原型，看着就让人晕，你能手写出函数指针吗？\nvoid (*signal(int signo, void (*func)(int)))(int)\n\n// 使用decltype可以轻松得到函数指针类型\nusing sig_func_ptr_t = decltype(&amp;signal) ;\n</code></pre><p>在定义类的时候，因为auto被禁用了，所以这也是decltype可以“显身手”的地方。它可以搭配别名任意定义类型，再应用到成员变量、成员函数上，变通地实现auto的功能。</p><pre><code>class DemoClass final\n{\npublic:\n    using set_type      = std::set&lt;int&gt;;  // 集合类型别名\nprivate:\n    set_type      m_set;                   // 使用别名定义成员变量\n\n    // 使用decltype计算表达式的类型，定义别名\n    using iter_type = decltype(m_set.begin());\n\n    iter_type     m_pos;                   // 类型别名定义成员变量\n};\n</code></pre><h2>小结</h2><p>好了，今天我介绍了C++里的“自动类型推导”，简单小结一下今天的内容。</p><ol>\n<li>“自动类型推导”是给编译器下的指令，让编译器去计算表达式的类型，然后返回给程序员。</li>\n<li>auto用于初始化时的类型推导，总是“值类型”，也可以加上修饰符产生新类型。它的规则比较好理解，用法也简单，应该积极使用。</li>\n<li>decltype使用类似函数调用的形式计算表达式的类型，能够用在任意场合，因为它就是一个编译阶段的类型。</li>\n<li>decltype能够推导出表达式的精确类型，但写起来比较麻烦，在初始化时可以采用decltype(auto)的简化形式。</li>\n<li>因为auto和decltype不是“硬编码”的类型，所以用好它们可以让代码更清晰，减少后期维护的成本。</li>\n</ol><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>auto和decltype虽然很方便，但用多了也确实会“隐藏”真正的类型，增加阅读时的理解难度，你觉得这算是缺点吗？是否有办法克服或者缓解？</li>\n<li>说一下你对auto和decltype的认识。你认为，两者有哪些区别呢？（推导规则、应用场合等）</li>\n</ol><p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友，我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/14/6ec0c53ee9917795c0e2a494cfe70014.png?wh=3000*2994\" alt=\"\"></p>","comments":[{"had_liked":false,"id":218672,"user_name":"Mervin","can_delete":false,"product_type":"c1","uid":1234946,"ip_address":"","ucode":"1C5E314CC19CA2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/02/198fc6d6.jpg","comment_is_top":false,"comment_ctime":1589852763,"is_pvip":false,"replies":[{"id":"80829","content":"<br>1.说的很好，所以要用好auto还是要掌握一个度。<br><br>2.auto和decltype的编译期计算类型过程是一样的，都是得出类型，不会计算表达式，只是一个从初始化里获取表达式，一个自带表达式，这个区别导致了用法的不同。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589863841,"ip_address":"","comment_id":218672,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74604296795","product_id":100051801,"comment_content":"课后题：<br>1. 给程序作者带来了一些便利，但是给读者比较大的麻烦，所以我认为尽量还是应该在比较清晰明确的地方使用，并加以明确的注释。<br>2.auto推导的是编译器计算变量初始值得到类型的，decltype也是分析表达式但是不需要计算表达式，所以它与表达式本身有很大关系。","like_count":18,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495539,"discussion_content":"\n1.说的很好，所以要用好auto还是要掌握一个度。\n\n2.auto和decltype的编译期计算类型过程是一样的，都是得出类型，不会计算表达式，只是一个从初始化里获取表达式，一个自带表达式，这个区别导致了用法的不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589863841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222945,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1413399,"ip_address":"","ucode":"FB3851E3A79C3B","user_header":"https://static001.geekbang.org/account/avatar/00/15/91/17/89c3d249.jpg","comment_is_top":false,"comment_ctime":1590972289,"is_pvip":false,"replies":[{"id":"82193","content":"这里是C++一个比较奇怪的语法，x是值类型，加上括号就变成了引用类型，算是个“坑”吧。<br><br>不建议去了解这个细节，可能会更迷惑，最好不要这么用，这里我只是为了举例。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590974949,"ip_address":"","comment_id":222945,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44540645249","product_id":100051801,"comment_content":"decltype(auto) x1 = (x); &#47;&#47; 推导为int&amp;，因为(expr)是引用类型。老师，这里为什么是引用？x不是值吗？","like_count":11,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496968,"discussion_content":"这里是C++一个比较奇怪的语法，x是值类型，加上括号就变成了引用类型，算是个“坑”吧。\n\n不建议去了解这个细节，可能会更迷惑，最好不要这么用，这里我只是为了举例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590974949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748503,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ae/17/136fead2.jpg","nickname":"さようなら","note":"","ucode":"027E0741A14B87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303722,"discussion_content":"但是如果把decltype(auto) 变为auto就不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599361375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222384,"user_name":"九三","can_delete":false,"product_type":"c1","uid":1454691,"ip_address":"","ucode":"7D093ED7273CBE","user_header":"https://static001.geekbang.org/account/avatar/00/16/32/63/fa24f92e.jpg","comment_is_top":false,"comment_ctime":1590769059,"is_pvip":false,"replies":[{"id":"82027","content":"这个是为了兼容C语言，因为C++编译生成的链接符号与C不一样，用这个就会导出与C一样规则的符号，方便外部库调用。<br><br>可以再搜一下相关的资料，看几篇就能理解了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590792139,"ip_address":"","comment_id":222384,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40245474723","product_id":100051801,"comment_content":"老师， 总是在一些c++ 源码看到extern “C” 对这个关键字理解的不是很透","like_count":10,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496772,"discussion_content":"这个是为了兼容C语言，因为C++编译生成的链接符号与C不一样，用这个就会导出与C一样规则的符号，方便外部库调用。\n\n可以再搜一下相关的资料，看几篇就能理解了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590792139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1255794,"avatar":"https://static001.geekbang.org/account/avatar/00/13/29/72/515e8867.jpg","nickname":"王厂长","note":"","ucode":"FF41279DA5A860","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582742,"discussion_content":"关键点：c编译函数funca后还是这个函数名，C++编译后会变成xxx funca，就是函数名会加上一些前缀符号。\n\n加了这个关键字，就表示编译时不加前缀。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659622664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240018,"user_name":"张飞Dear","can_delete":false,"product_type":"c1","uid":2004589,"ip_address":"","ucode":"EECEDF12DC7EB9","user_header":"https://static001.geekbang.org/account/avatar/00/1e/96/6d/85723167.jpg","comment_is_top":false,"comment_ctime":1596716291,"is_pvip":false,"replies":[{"id":"88642","content":"总结的很好。<br><br>另外说一下，如果用C++11，就应当尽量用using来定义类型别名，少用typedef。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1596761998,"ip_address":"","comment_id":240018,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27366520067","product_id":100051801,"comment_content":"1，算是一个缺点，但是就和容器、条件编译一样，尺有所短寸有所长。用的恰当就好，我现在工作用的的编译器不支持auto，只能自己实验这敲了，用auto 就不用再写那么长的迭代器名称了，很方便。还有使用decltype 来定义迭代器类型  真的是太好用，之前都是用typedef 来进行的。<br><br>2，① auto 的“自动推导”能力只能用在“初始化”的场合。不能用在类成员里面初始化。auto 总是推导出“值类型”，绝不会是“引用”。<br>② decltype 不仅能够推导出值类型，还能够推导出引用类型，也就是表达式的“原始类型”。可以定义类成员类型。","like_count":6,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503307,"discussion_content":"总结的很好。\n\n另外说一下，如果用C++11，就应当尽量用using来定义类型别名，少用typedef。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596761998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219353,"user_name":"Geek_197dc8","can_delete":false,"product_type":"c1","uid":2007820,"ip_address":"","ucode":"0792FA33B8F404","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erwjtaqgKfnSflr8zPuz6LzE1PsxYa59Cd2QsibbDE4SGxegO0UQpRrVCa4ds2Wx3DgMW1B9VOe4UQ/132","comment_is_top":false,"comment_ctime":1590013444,"is_pvip":false,"replies":[{"id":"81030","content":"注意细看，auto还是值类型，而“auto&amp;”才是引用类型。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590022193,"ip_address":"","comment_id":219353,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27359817220","product_id":100051801,"comment_content":"auto总是推导出“值类型”，但绝不会是“引用”，这句话怎么理解，难道不可以推导出引用的类型嘛？我看你的例子 auto&amp; x1＝x，不是推导出引用类型嘛。","like_count":6,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495780,"discussion_content":"注意细看，auto还是值类型，而“auto&amp;amp;”才是引用类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590022193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1914504,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","nickname":"Simon","note":"","ucode":"A8A2E3E57BD029","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282429,"discussion_content":"如果不加&amp;，就只能是值类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591971098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241866,"user_name":"hao","can_delete":false,"product_type":"c1","uid":1980191,"ip_address":"","ucode":"1FA69BBF5F624C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erCibehm9W3tbhKic1RnbTvPVCgWDmludx9YQ97BneVRhyegkr13R6vrFPYol4IYEF98s07MicgOtS0g/132","comment_is_top":false,"comment_ctime":1597475498,"is_pvip":false,"replies":[{"id":"89371","content":"不会有问题的。<br><br>对于C++11之前，会有rvo返回值优化，把vector拷贝到输出结果。C++11之后会使用转移语义。<br><br>无论怎么样，调用函数后都会得到正确的vector结果，内存被新的vector所管理。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1597627043,"ip_address":"","comment_id":241866,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18777344682","product_id":100051801,"comment_content":"罗老师，请问下，在函数内部定义了vector，push_back了很多数据，要将这些vector数据作为函数结果返回，也没释放vector，这样会不会有问题？","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503863,"discussion_content":"不会有问题的。\n\n对于C++11之前，会有rvo返回值优化，把vector拷贝到输出结果。C++11之后会使用转移语义。\n\n无论怎么样，调用函数后都会得到正确的vector结果，内存被新的vector所管理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597627043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312876,"user_name":"Geek_ca425d","can_delete":false,"product_type":"c1","uid":1706078,"ip_address":"","ucode":"CE95FD44ACCCFA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLatEq9SWSZv14dEvlhzBJmkhlxDn7iaSuTT1g28U7kRsSjpsuia95JTZQgSGSYVvWkG3ibOMu1gmIwQ/132","comment_is_top":false,"comment_ctime":1632096370,"is_pvip":false,"replies":[{"id":"113424","content":"不一样，JavaScript是弱类型，而C++是强类型，在编译时会有编译器做检查，auto只是方便了我们的代码编写工作，本质上没有对语言有任何的改变。<br><br>当然，对auto有顾虑也是正常的，会感觉少了一些对程序的掌控感，可以慢慢适应。<br><br>在现代C++中，由于类型体系越来越复杂，很多地方，不用auto可能根本就写不出来程序，比如lambda表达式。<br><br>关键还是要把握一个度，不要滥用，以人类可读、代码可维护为基本尺度。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1632273233,"ip_address":"","comment_id":312876,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14516998258","product_id":100051801,"comment_content":"JavaScript弱语言类型就是不对类型做定义，运行时推导的，但这种缺点导致开发大型项目的时候各种困难，我觉得主要就是类型不明确锅，所以后来有了typescript这种js超集。前车之鉴，auto还是要少用的。","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527143,"discussion_content":"不一样，JavaScript是弱类型，而C++是强类型，在编译时会有编译器做检查，auto只是方便了我们的代码编写工作，本质上没有对语言有任何的改变。\n\n当然，对auto有顾虑也是正常的，会感觉少了一些对程序的掌控感，可以慢慢适应。\n\n在现代C++中，由于类型体系越来越复杂，很多地方，不用auto可能根本就写不出来程序，比如lambda表达式。\n\n关键还是要把握一个度，不要滥用，以人类可读、代码可维护为基本尺度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632273233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218849,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1589886654,"is_pvip":false,"replies":[{"id":"80926","content":"如果觉得auto太多，可以先试着用它来简化复杂类型的声明，然后再慢慢扩展应用场合。<br><br>decltype在泛型编程和模板元编程里非常有用。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589936954,"ip_address":"","comment_id":218849,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14474788542","product_id":100051801,"comment_content":"我觉得auto 虽然方便了，但是代码不能都用auto吧，大量的auto反而让程序员摸不着头脑，这就像看一本书所有地方都花下划线就失去了下划线的意义。<br>auto对于减少冗赘的代码也很有用。比如：之前我们写代码是：<br>for(vector&lt;int&gt;::const_iterator itr = m_vector.begin(); itr != m_vector.end();++itr)<br>可以使用auto简化为：<br>for(auto itr = m_vector.begin(); itr != m_vector.end();++itr)这样写就简单多了。<br>所有的功能都是建立在好的方向发展的，所有的功能都是工具，工具只有利用对了才是好的，怎么能利用好这时候就看使用者的功底和经验丰富程度了。<br><br>decltype 和 auto 一起使用会更为有用。auto 变量的类型只有编译器知道，而 decltype 对于大量运用运算符重载和特化的类型的代码的表示也非常有用。<br>","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495600,"discussion_content":"如果觉得auto太多，可以先试着用它来简化复杂类型的声明，然后再慢慢扩展应用场合。\n\ndecltype在泛型编程和模板元编程里非常有用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589936954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269714,"discussion_content":"跟着老师继续学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589940895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218621,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1053390,"ip_address":"","ucode":"ABB3F1A63E102A","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","comment_is_top":false,"comment_ctime":1589846707,"is_pvip":false,"replies":[{"id":"80793","content":"对，所以auto不宜用的太多，要适当，最好能够加一下注释，说一下这个auto是什么。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589849608,"ip_address":"","comment_id":218621,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10179781299","product_id":100051801,"comment_content":"&quot;auto 和 decltype 虽然很方便，但用多了也确实会“隐藏”真正的类型，增加阅读时的理解难度。&quot;<br>我觉得这很算缺点，它们应该只用在确实很难手动推导出变量类型的地方。","like_count":2,"discussions":[{"author":{"id":1010819,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6c/83/48e528cb.jpg","nickname":"Luke","note":"","ucode":"8368A63185356D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270505,"discussion_content":"如果要另外加注释说明auto是什么，为何不直接写出推导类型呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590022224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270741,"discussion_content":"有的类型很长，甚至写不出来，在注释里可以不用写的很精确，给人看就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590046046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336292,"user_name":"X.","can_delete":false,"product_type":"c1","uid":2911323,"ip_address":"","ucode":"40B4ED2F6ACCD5","user_header":"https://static001.geekbang.org/account/avatar/00/2c/6c/5b/d9ae4fbb.jpg","comment_is_top":false,"comment_ctime":1646053847,"is_pvip":false,"replies":[{"id":"122918","content":"auto是值类型，这里就会对容器里的元素拷贝后再操作，代价就会比较高。<br><br>相当于ClassA obj = v[i]","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1646115011,"ip_address":"","comment_id":336292,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5941021143","product_id":100051801,"comment_content":"请问老师，for (const auto&amp; i : v) {...}这里，为什么说“常引用方式访问元素，避免拷贝代价”  ？为什么不考虑用 for (auto i : v) {...} 呢？","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553835,"discussion_content":"auto是值类型，这里就会对容器里的元素拷贝后再操作，代价就会比较高。\n\n相当于ClassA obj = v[i]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646115011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2911323,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6c/5b/d9ae4fbb.jpg","nickname":"X.","note":"","ucode":"40B4ED2F6ACCD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":578948,"discussion_content":"拷贝相比引用代价具体高在哪里呢？\n引用本身类似于一个无法改变指向的指针（个人理解），用引用也会消耗内存空间（有可能比拷贝消耗的内存空间还大）；时间上的话，给引用赋值（初始化）和给变量赋值（拷贝）感觉差别也不大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657097820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553835,"ip_address":""},"score":578948,"extra":""},{"author":{"id":1255794,"avatar":"https://static001.geekbang.org/account/avatar/00/13/29/72/515e8867.jpg","nickname":"王厂长","note":"","ucode":"FF41279DA5A860","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2911323,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6c/5b/d9ae4fbb.jpg","nickname":"X.","note":"","ucode":"40B4ED2F6ACCD5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582743,"discussion_content":"引用才几个字节，一般容器元素都比引用大。用引用更快更省空间，为啥不用更好的方案呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659623223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":578948,"ip_address":"北京"},"score":582743,"extra":""}]}]},{"had_liked":false,"id":218683,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1589853906,"is_pvip":false,"replies":[{"id":"80828","content":"<br>1.auto还可以用在复杂的模板类定义的时候，比如容器的迭代器。<br><br>2.delctype可不能单纯地认为是语法糖，它是编译期计算，在泛型编程和模板元编程的时候非常有用，像nullptr的类型，就是用了decltype。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589863718,"ip_address":"","comment_id":218683,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884821202","product_id":100051801,"comment_content":"1. 大量使用auto和delctype确实会有这种问题。所以产量定义和初始化的时候原类型定义还是不错的.auto其实循环展开上用比较合理。delctype在类定义里使用，不传递到外部。<br>2.auto和delctype其实更多是语法糖的效果。实际类型确定都在编译期。","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495542,"discussion_content":"\n1.auto还可以用在复杂的模板类定义的时候，比如容器的迭代器。\n\n2.delctype可不能单纯地认为是语法糖，它是编译期计算，在泛型编程和模板元编程的时候非常有用，像nullptr的类型，就是用了decltype。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589863718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347696,"user_name":"liy","can_delete":false,"product_type":"c1","uid":1322151,"ip_address":"","ucode":"ACE2C473DBA19F","user_header":"https://static001.geekbang.org/account/avatar/00/14/2c/a7/7f702c49.jpg","comment_is_top":false,"comment_ctime":1654321984,"is_pvip":true,"replies":[{"id":"126769","content":"thanks。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1654414538,"ip_address":"","comment_id":347696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1654321984","product_id":100051801,"comment_content":"听君一席话胜读十年书！！","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574866,"discussion_content":"thanks。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654414538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329691,"user_name":"孙新","can_delete":false,"product_type":"c1","uid":2875594,"ip_address":"","ucode":"A80038A479B943","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","comment_is_top":false,"comment_ctime":1641473113,"is_pvip":true,"replies":[{"id":"120273","content":"这是auto最常见的应用场景，可以试着在这个基础上再多扩展一些。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1641813900,"ip_address":"","comment_id":329691,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641473113","product_id":100051801,"comment_content":"一般用在迭代器，用在接收map查找结果，或者lambda表达式之类的比较省事，也就是临时变量用这个省事。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545049,"discussion_content":"这是auto最常见的应用场景，可以试着在这个基础上再多扩展一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641813900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327537,"user_name":"Wa7T","can_delete":false,"product_type":"c1","uid":2113511,"ip_address":"","ucode":"4D5CD7886E6595","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKRpicl9Uy2ia14qefwoibRgdv30xpWpFibJ2fia3KCHUZhXOUKoZCIU6bILyYRibCIcyibyqcXcUgWSRF2A/132","comment_is_top":false,"comment_ctime":1640164749,"is_pvip":false,"replies":[{"id":"119244","content":"可以把代码实际编译测试一下。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1640214451,"ip_address":"","comment_id":327537,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640164749","product_id":100051801,"comment_content":"C++11的标准里写auto无法带走cv操作符，所以在<br>auto        x = 10L;    &#47;&#47; auto推导为long，x是long<br>auto&amp;       x1 = x;      &#47;&#47; auto推导为long，x1是long&amp;<br>auto*       x2 = &amp;x;    &#47;&#47; auto推导为long，x2是long*<br>const auto&amp; x3 = x;        &#47;&#47; auto推导为long，x3是const long&amp;<br>auto        x4 = &amp;x3;    &#47;&#47; auto推导为const long*，x4是const long*<br>这里面，x4应该没有const属性吧？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540929,"discussion_content":"可以把代码实际编译测试一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640214451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308205,"user_name":"Geek_358817","can_delete":false,"product_type":"c1","uid":2695697,"ip_address":"","ucode":"9F499F6438FB7A","user_header":"https://static001.geekbang.org/account/avatar/00/29/22/11/cab6ca42.jpg","comment_is_top":false,"comment_ctime":1629450515,"is_pvip":false,"replies":[{"id":"111641","content":"可以先不看auto，先看x2，它应该是个指针long*。<br><br>那么再回头看auto的形式，因为auto加了一个*的修饰，那么auto就必须是long，否则最终的结果就是long**了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1629517993,"ip_address":"","comment_id":308205,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629450515","product_id":100051801,"comment_content":"auto*       x2 = &amp;x;    &#47;&#47; auto推导为long，x2是long*，<br><br>这里为什么auto推导不是long *类型，而是long类型？auto的值推导，是不管值前面的符号吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525431,"discussion_content":"可以先不看auto，先看x2，它应该是个指针long*。\n\n那么再回头看auto的形式，因为auto加了一个*的修饰，那么auto就必须是long，否则最终的结果就是long**了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629517993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303888,"user_name":"宵练2233","can_delete":false,"product_type":"c1","uid":2662996,"ip_address":"","ucode":"3EBDF8195040DA","user_header":"https://static001.geekbang.org/account/avatar/00/28/a2/54/49dfb810.jpg","comment_is_top":false,"comment_ctime":1627047550,"is_pvip":false,"replies":[{"id":"110008","content":"great。<br><br>如果有这种应用了复杂模板技巧的程序，auto推断虽然也能拿到类型，但很可能会不如我们的预想。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1627108387,"ip_address":"","comment_id":303888,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1627047550","product_id":100051801,"comment_content":"举一个不适合用auto的例子 Eigen，由于它内部大量使用了Expression Template，用auto会产生很多奇怪的bug。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523865,"discussion_content":"great。\n\n如果有这种应用了复杂模板技巧的程序，auto推断虽然也能拿到类型，但很可能会不如我们的预想。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627108387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298410,"user_name":"一个坏人","can_delete":false,"product_type":"c1","uid":1032305,"ip_address":"","ucode":"4AF05BF008095A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/71/c83d8b15.jpg","comment_is_top":false,"comment_ctime":1624088878,"is_pvip":true,"replies":[{"id":"108273","content":"auto推导的类型一定是正确的，只是可能不会符合开发者的预期，这一点要特别注意，所以如果拿不准的话就不要用auto，还是老老实实地手写类型。<br><br>C++有typeid运算符。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1624099243,"ip_address":"","comment_id":298410,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1624088878","product_id":100051801,"comment_content":"老师好，请问如何判定 auto 推导的类型对不对，有类似JS typeof 方法？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522130,"discussion_content":"auto推导的类型一定是正确的，只是可能不会符合开发者的预期，这一点要特别注意，所以如果拿不准的话就不要用auto，还是老老实实地手写类型。\n\nC++有typeid运算符。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624099243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286063,"user_name":"201201150","can_delete":false,"product_type":"c1","uid":1900995,"ip_address":"","ucode":"8F2BA255DCF314","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9X140JXPuaKOwmvYb8YFloVXpIakbBCuBBgSepO81ibibZPrFLrHpJevQMdy2hXQc0HRoA75b5u5w/132","comment_is_top":false,"comment_ctime":1617148476,"is_pvip":false,"replies":[{"id":"103858","content":"说的很好。<br><br>不过关于auto和decltype的区别，我觉得还有点不对，auto和decltype都是从表达式推导类型，但auto的偏重于是“占位”，而decltype偏重于“计算”。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1617148848,"ip_address":"","comment_id":286063,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617148476","product_id":100051801,"comment_content":"我想auto 和decltype的引入，关键还是因为C++语言有着一个完善而且强大的type system，在编译阶段就有很多信息可以确定下来。<br>泛型编程里面，auto关键字确实帮助程序员省去很多工作，这是最大的优点。但是如果auto 关键字满天飞，也会给程序的可读性带来很多问题。使用好关键还是一个度的把握。<br>auto和decltype两者最大的区别应该是，一个根据值的类型来推导出来变量类型，一个根据表达式的类型推导出来变量类型。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517862,"discussion_content":"说的很好。\n\n不过关于auto和decltype的区别，我觉得还有点不对，auto和decltype都是从表达式推导类型，但auto的偏重于是“占位”，而decltype偏重于“计算”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617148848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281758,"user_name":"超越杨超越","can_delete":false,"product_type":"c1","uid":1028887,"ip_address":"","ucode":"BB390B4B7E19D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/17/9f6d67dc.jpg","comment_is_top":false,"comment_ctime":1614871828,"is_pvip":false,"replies":[{"id":"102286","content":"当然不会了，因为编译器本来就应该推断出表达式的类型（不然你写错了编译器就查不出来了），auto就顺便让编译器帮着写出来而已。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1614907708,"ip_address":"","comment_id":281758,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1614871828","product_id":100051801,"comment_content":"请问老师，auto这种类型推断如果用的非常多，会不会影响编译效率","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516498,"discussion_content":"当然不会了，因为编译器本来就应该推断出表达式的类型（不然你写错了编译器就查不出来了），auto就顺便让编译器帮着写出来而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614907708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281530,"user_name":"企鹅君需要充电","can_delete":false,"product_type":"c1","uid":1858704,"ip_address":"","ucode":"EAD2F1C4A73363","user_header":"","comment_is_top":false,"comment_ctime":1614775508,"is_pvip":false,"replies":[{"id":"102221","content":"我个人觉得现在编程语言的大方向是尽量减少显式类型声明，脚本语言就不说了，go也是这样，所以C++也可以朝这个方向去努力。<br><br>当然了，具体到每个人，还是有自己的编程习惯，只要自己写得舒服，别人能看懂就行。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1614820602,"ip_address":"","comment_id":281530,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1614775508","product_id":100051801,"comment_content":"auto在特性开发的时候很方便，现在作为range idx&#47;迭代器是简洁明了的常见用法，但如果类型涉及自定义类，又或者只是标准库的简单类型，最好还是明确写出来，若是替代复杂类型最好加点备注。decltype很少用，函数指针用它比较常见吧，其他的引用或者指针考虑可读性我还是习惯写出来；","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516432,"discussion_content":"我个人觉得现在编程语言的大方向是尽量减少显式类型声明，脚本语言就不说了，go也是这样，所以C++也可以朝这个方向去努力。\n\n当然了，具体到每个人，还是有自己的编程习惯，只要自己写得舒服，别人能看懂就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614820602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245338,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1598919318,"is_pvip":true,"replies":[{"id":"90217","content":"<br>1.注意，变量名里一定不能包含类型，这个已经在前面变量命名的时候说过了。<br><br>2.auto用起来更简单，而decltype多用在泛型和模板元编程里。","user_name":"作者回复","comment_id":245338,"uid":"1181974","ip_address":"","utype":1,"ctime":1598921952,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1598919318","product_id":100051801,"comment_content":"auto 和 decltype 虽然很方便，但用多了也确实会“隐藏”真正的类型，增加阅读时的理解难度，你觉得这算是缺点吗？是否有办法克服或者缓解？<br>是的<br>变量的名字中包含类型<br><br><br>说一下你对 auto 和 decltype 的认识。你认为，两者有哪些区别呢？（推导规则、应用场合等）<br>auto更简单，除了类的属性等不可以用以外，一般用于变量初始化时类型的推导<br>decltype更通用，任何地方都可以使用，比如自带表达式","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504857,"discussion_content":"\n1.注意，变量名里一定不能包含类型，这个已经在前面变量命名的时候说过了。\n\n2.auto用起来更简单，而decltype多用在泛型和模板元编程里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598921952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240980,"user_name":"常丁方2","can_delete":false,"product_type":"c1","uid":2116232,"ip_address":"","ucode":"20BF769DC2AD8C","user_header":"","comment_is_top":false,"comment_ctime":1597138578,"is_pvip":false,"replies":[{"id":"89197","content":"这个说法可能比较学术一些了，我的理解是程序里所有变量都必须有明确的类型，不能随意转换，这个就是强类型的，更准确一点说应该是“静态类型”吧。<br><br>所以C&#47;C++都是强类型的语言，而Python、lua这样的就是弱类型语言。<br><br>这个我觉得没有必要特意纠结，属于孔乙己的茴字写法问题了。","user_name":"作者回复","comment_id":240980,"uid":"1181974","ip_address":"","utype":1,"ctime":1597367573,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1597138578","product_id":100051801,"comment_content":"老师, c++不是弱类型语言吗? 我在知乎上看到很多人都说c++是弱类型的<br>https:&#47;&#47;www.zhihu.com&#47;question&#47;19918532","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503612,"discussion_content":"这个说法可能比较学术一些了，我的理解是程序里所有变量都必须有明确的类型，不能随意转换，这个就是强类型的，更准确一点说应该是“静态类型”吧。\n\n所以C/C++都是强类型的语言，而Python、lua这样的就是弱类型语言。\n\n这个我觉得没有必要特意纠结，属于孔乙己的茴字写法问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597367573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224674,"user_name":"鲁滨逊","can_delete":false,"product_type":"c1","uid":1191378,"ip_address":"","ucode":"54AA764E65ADEE","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/d2/9ef1e70d.jpg","comment_is_top":false,"comment_ctime":1591502981,"is_pvip":false,"replies":[{"id":"82699","content":"注意看auto有没有修饰符。<br><br>x2是auto*，那么auto就不会再推导出指针了，而x4是auto，没有修饰，所以auto就是指针类型。","user_name":"作者回复","comment_id":224674,"uid":"1181974","ip_address":"","utype":1,"ctime":1591531475,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1591502981","product_id":100051801,"comment_content":"没看明白这里：<br>auto*       x2 = &amp;x;    &#47;&#47; auto推导为long，x2是long*<br>const auto&amp; x3 = x;        &#47;&#47; auto推导为long，x3是const long&amp;<br>auto        x4 = &amp;x3;    &#47;&#47; auto推导为const long*，x4是const long*<br>都是&amp;x，x2的auto推导为long，x4的auto却是long*呢？看到这种问题就意识到自己基础不好了","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497563,"discussion_content":"注意看auto有没有修饰符。\n\nx2是auto*，那么auto就不会再推导出指针了，而x4是auto，没有修饰，所以auto就是指针类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591531475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223859,"user_name":"陈英桂","can_delete":false,"product_type":"c1","uid":1100348,"ip_address":"","ucode":"06E8DEE42DA82E","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/3c/f6e7ebf1.jpg","comment_is_top":false,"comment_ctime":1591197573,"is_pvip":false,"replies":[{"id":"82436","content":"加上一点注释，就可以让auto对人类友好很多。","user_name":"作者回复","comment_id":223859,"uid":"1181974","ip_address":"","utype":1,"ctime":1591231750,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1591197573","product_id":100051801,"comment_content":"就像python的变量的数据类型随时可以改变，根据右值推导出来，这样代码可读性很差。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497267,"discussion_content":"加上一点注释，就可以让auto对人类友好很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591231750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223856,"user_name":"陈英桂","can_delete":false,"product_type":"c1","uid":1100348,"ip_address":"","ucode":"06E8DEE42DA82E","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/3c/f6e7ebf1.jpg","comment_is_top":false,"comment_ctime":1591197341,"is_pvip":false,"replies":[{"id":"82437","content":"这个还是看个人了，我觉得auto可以简化复杂类型的书写，比手写类型会更正确，需要在可读性和效率间取一个适当的折中。","user_name":"作者回复","comment_id":223856,"uid":"1181974","ip_address":"","utype":1,"ctime":1591231881,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1591197341","product_id":100051801,"comment_content":"用auto和decltype给写代码的带来一些便捷性，但是会降低代码的可读性，给维护者的阅读带来一些障碍。<br>对于迭代器，可以用auto来简化代码，尽量不要用在函数的返回值和入参。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497266,"discussion_content":"这个还是看个人了，我觉得auto可以简化复杂类型的书写，比手写类型会更正确，需要在可读性和效率间取一个适当的折中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591231881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221639,"user_name":"yelin","can_delete":false,"product_type":"c1","uid":1416262,"ip_address":"","ucode":"4341B2F4C513FE","user_header":"https://static001.geekbang.org/account/avatar/00/15/9c/46/a2c1a99f.jpg","comment_is_top":false,"comment_ctime":1590555226,"is_pvip":false,"replies":[{"id":"81721","content":"总结的挺好。","user_name":"作者回复","comment_id":221639,"uid":"1181974","ip_address":"","utype":1,"ctime":1590556595,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1590555226","product_id":100051801,"comment_content":"2.<br>推导规则：auto值总是值类型，decltype 不仅能够推导出值类型，还能够推导出引用类型。&amp;,*,const的属性也会被decltype取得<br>应用场景：auto除了不能在定义类时使用，还有一种不关心具体类型的目的在range-based for的场景尤其明显，在；decltype则没有义类的使用限制，decltype会尤其关心具体的类型值，推导计算得到后才会返回","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496518,"discussion_content":"总结的挺好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590556595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221636,"user_name":"yelin","can_delete":false,"product_type":"c1","uid":1416262,"ip_address":"","ucode":"4341B2F4C513FE","user_header":"https://static001.geekbang.org/account/avatar/00/15/9c/46/a2c1a99f.jpg","comment_is_top":false,"comment_ctime":1590554486,"is_pvip":false,"replies":[{"id":"81722","content":"如果是用惯了Python等动态语言，可能会对auto很适应。<br><br>但毕竟C++是强类型语言，如果不小心推导出了你不需要的类型就会很麻烦，所以为了“给人看”，对于不是那么能够一眼看出来的类型，最好还是注释说明一下。","user_name":"作者回复","comment_id":221636,"uid":"1181974","ip_address":"","utype":1,"ctime":1590556694,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"1590554486","product_id":100051801,"comment_content":"1. 类型推导用起来方便，代码里都用auto的话，那个感觉应该和python是一样的吧，所以不知道有没有好的解决方案，我在python里的习惯是在命名加前缀，还有就是注释了吧，如果是协作开发的模块，auto我一般也就是用来内部遍历&#47;range-based for之类的场景。请教下老师，还有没有更好的办法。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496517,"discussion_content":"如果是用惯了Python等动态语言，可能会对auto很适应。\n\n但毕竟C++是强类型语言，如果不小心推导出了你不需要的类型就会很麻烦，所以为了“给人看”，对于不是那么能够一眼看出来的类型，最好还是注释说明一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590556694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221157,"user_name":"湟水鱼儿","can_delete":false,"product_type":"c1","uid":1537079,"ip_address":"","ucode":"A0605168E3EDFC","user_header":"https://static001.geekbang.org/account/avatar/00/17/74/37/e5e9775b.jpg","comment_is_top":false,"comment_ctime":1590418636,"is_pvip":false,"replies":[{"id":"81581","content":"唉，这个也是没办法的事情，以前我用的环境是gcc4.4，C++11支持不完整，非常痛苦。","user_name":"作者回复","comment_id":221157,"uid":"1181974","ip_address":"","utype":1,"ctime":1590454398,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"1590418636","product_id":100051801,"comment_content":"公司编码不支持auto，只有自己私下里用一用，过一过瘾","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496358,"discussion_content":"唉，这个也是没办法的事情，以前我用的环境是gcc4.4，C++11支持不完整，非常痛苦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590454398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220372,"user_name":"汪zZ","can_delete":false,"product_type":"c1","uid":1234757,"ip_address":"","ucode":"8B93062A683902","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/45/d1621188.jpg","comment_is_top":false,"comment_ctime":1590228726,"is_pvip":true,"replies":[{"id":"81326","content":"这就是C++的哲学：自由，你怎么做都可以，总可以找到自己喜欢的风格。","user_name":"作者回复","comment_id":220372,"uid":"1181974","ip_address":"","utype":1,"ctime":1590231496,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":1,"score":"1590228726","product_id":100051801,"comment_content":"看auto的时候，省略了一下，觉得我这个初学者应该知道它存在就可以了，<br>结果发现真的，有它更开心。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496127,"discussion_content":"这就是C++的哲学：自由，你怎么做都可以，总可以找到自己喜欢的风格。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590231496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220265,"user_name":"silverhawk","can_delete":false,"product_type":"c1","uid":1018649,"ip_address":"","ucode":"BFBC8AF32868DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/19/a15d060d.jpg","comment_is_top":false,"comment_ctime":1590217618,"is_pvip":false,"replies":[{"id":"81323","content":"对，对于某些很重要的类型，用auto后最好用注释说明它是个什么，后续该怎么用，否则会导致后面的代码比较难懂。","user_name":"作者回复","comment_id":220265,"uid":"1181974","ip_address":"","utype":1,"ctime":1590231029,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"1590217618","product_id":100051801,"comment_content":"我说一个这种自动推导的隐藏代价吧，不是C++里面，C#里面的Var，有一次遇到一个Var res = func（），这个func()返回一个Ienumerable，但是这个var就掩盖了这个Ienumerable究竟是List，还是其他什么，实际上背后有个stream的实现，之后程序中多次出现foreach res，其实就是多次遍历了这个stream，凭空增加了overhead。如果能够在写的时候显示定义，可能会想的更清楚，写出性能更高的","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496105,"discussion_content":"对，对于某些很重要的类型，用auto后最好用注释说明它是个什么，后续该怎么用，否则会导致后面的代码比较难懂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590231029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219720,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1590069899,"is_pvip":false,"replies":[{"id":"81154","content":"理解的很对。<br><br>auto还是比较智能的，会自动推导出正确的类型，注意它一定是值类型，不会是引用。","user_name":"作者回复","comment_id":219720,"uid":"1181974","ip_address":"","utype":1,"ctime":1590108564,"user_name_real":"chrono"}],"discussion_count":3,"race_medal":0,"score":"1590069899","product_id":100051801,"comment_content":"int x;<br>auto * y = &amp;x; &#47;&#47; auto 被推倒成int, y的类型是int*<br>auto z = &amp;x; &#47;&#47; auto 被推倒成int *, z的类型也是int*<br><br>请问是这样吗？<br>如果是的话，是不是意味着如果我们知道右边是个指针类型,就直接用 auto w = 表达式，而不是auto * w =表达式？<br><br>谢谢","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495919,"discussion_content":"理解的很对。\n\nauto还是比较智能的，会自动推导出正确的类型，注意它一定是值类型，不会是引用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590108564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1993795,"avatar":"","nickname":"Geek_496123","note":"","ucode":"CC4DC7B00A38DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282580,"discussion_content":"那么y和z的类型都是一样的，多了一个*完全不影响吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592019162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271514,"discussion_content":"#1 值类型的变量标记的内存的内容是一个具体的对象 #2 指针类型的的变量标记的内存内容是一个指针，指向另外一块内存区域（它的内容是某个具体的对象）\n\n#3 引用类型的变量标记的内存内容是什么？感觉也是类似于指针的东西。但是肯定不相同，否则就叫指针类型了。\n\n谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590151286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219553,"user_name":"Zivon","can_delete":false,"product_type":"c1","uid":2005287,"ip_address":"","ucode":"2C7D4557C2903D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/99/27/15d2c4f5.jpg","comment_is_top":false,"comment_ctime":1590040840,"is_pvip":false,"replies":[{"id":"81076","content":"说的很好，auto配合适当的注释就比较完美了。","user_name":"作者回复","comment_id":219553,"uid":"1181974","ip_address":"","utype":1,"ctime":1590045642,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"1590040840","product_id":100051801,"comment_content":"auto 和 decltype 虽然很方便，但用多了也确实会“隐藏”真正的类型，增加阅读时的理解难度，<br>确实有这方面的影响，再看自己过去写的代码，auto会减慢阅读速度，但IDE能提供一些辅助会好些。<br> auto 和 decltype 的区别。decltype能实现精确推导，auto一定不会推导出引用类型。另，再类内auto不可使用。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495852,"discussion_content":"说的很好，auto配合适当的注释就比较完美了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590045642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219401,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1010819,"ip_address":"","ucode":"8368A63185356D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6c/83/48e528cb.jpg","comment_is_top":false,"comment_ctime":1590022703,"is_pvip":false,"replies":[{"id":"81043","content":"C++会给我们多种选择，我们也可以选择不用，这个特性在写泛型函数的时候会很方便。<br><br>另外auto还可以用在返回值类型后置的用法，有的特别的模板函数就真的只能这么写了。","user_name":"作者回复","comment_id":219401,"uid":"1181974","ip_address":"","utype":1,"ctime":1590024677,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"1590022703","product_id":100051801,"comment_content":"C++14 auto用于推到函数返回值，个人觉得是鸡肋，增加代码阅读难度，本来忘了返回值类型，看一眼函数头就行了，现在还得去看函数体具体的返回值类型到底是什么。这是为了迎合python程序员转C++么😂","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495799,"discussion_content":"C++会给我们多种选择，我们也可以选择不用，这个特性在写泛型函数的时候会很方便。\n\n另外auto还可以用在返回值类型后置的用法，有的特别的模板函数就真的只能这么写了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590024677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219213,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1589967169,"is_pvip":true,"replies":[{"id":"81035","content":"auto和decltype用得少体会不出优越性，只有写得多了，在比较复杂的泛型场景下，就会发现很多时候必须得用这两个关键字。","user_name":"作者回复","comment_id":219213,"uid":"1181974","ip_address":"","utype":1,"ctime":1590022582,"user_name_real":"chrono"}],"discussion_count":2,"race_medal":0,"score":"1589967169","product_id":100051801,"comment_content":"auto， decltype 用起来很方便， <br>说来惭愧，以前一直很烦写函数指针的声明，每次不得不写的时候都得google 一下，<br>自从用了decltype 再也不用担心了<br><br>auto 自动类型推导，我最多的应用场景就是用来声明 stl的迭代器，能少敲键盘，range-based for 实践也能简化代码， 使代码看起来更明了，文中说的 避免了类型的“硬编码”， 在实际工作中我碰到这种情况的时候比较少， 也没注意。也是个最佳实践了。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495719,"discussion_content":"auto和decltype用得少体会不出优越性，只有写得多了，在比较复杂的泛型场景下，就会发现很多时候必须得用这两个关键字。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590022582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291918,"discussion_content":"不过前提还是要清楚你要替代的类型，做到心理有数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594999675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218844,"user_name":"lckfa李钊","can_delete":false,"product_type":"c1","uid":1356899,"ip_address":"","ucode":"AD13D205104AA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/63/84960032.jpg","comment_is_top":false,"comment_ctime":1589885626,"is_pvip":false,"replies":[{"id":"80922","content":"我也比较同意，auto和using能很大程度改善代码。","user_name":"作者回复","comment_id":218844,"uid":"1181974","ip_address":"","utype":1,"ctime":1589936877,"user_name_real":"chrono"}],"discussion_count":2,"race_medal":0,"score":"1589885626","product_id":100051801,"comment_content":"我倒是觉得auto可以多用啊，隐藏的真正类型完全可以使用vscode的cpp插件或者ide工具直接查看到，不算大的缺点。如果要说C ++11让我最舒服的地方就是auto和using了。","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495598,"discussion_content":"我也比较同意，auto和using能很大程度改善代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589936877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a2/7d/674f97cc.jpg","nickname":"EastWind","note":"","ucode":"24AD259AFB6A9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542429,"discussion_content":"组合出来很复杂的类型可以用，把类型推导交给编译器，感受弱类型语言编程的轻松。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640747527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}