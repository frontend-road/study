{"id":503629,"title":"32 | 图解Flow：原来你是只纸老虎？","content":"<p>你好，我是朱涛。今天我们来研究Flow的源代码。</p><p>经过前面的学习，我们已经知道了，Channel和Flow都是数据流，Channel是“热”的，Flow则是“冷”的。这里的冷，代表着Flow不仅是“冷淡”的，而且还是“懒惰”的。</p><p>除了“冷”这个特性以外，Flow从API的角度分类，主要分为：构造器、中间操作符、终止操作符。今天这节课，我们将会从这几个角度来分析Flow的源码，来看看它的这几类API是如何实现的。</p><p>经过这节课的学习，你会发现：虽然Flow的功能看起来非常高大上，然而它的原理却非常的简单，是一只名副其实的“纸老虎”。</p><h2>Flow为什么是冷的？</h2><p>在正式开始研究Flow源代码之前，我们首先需要确定研究的对象。这里，我写了一段Demo代码，接下来我们就以这个Demo为例，来分析Flow的整个执行流程：</p><pre><code class=\"language-plain\">// 代码段1\n\nfun main() {\n    val scope = CoroutineScope(Job())\n    scope.launch {\n        testFlow()\n    }\n\n    Thread.sleep(1000L)\n\n    logX(\"end\")\n}\n\nprivate suspend fun testFlow() {\n    // 1\n    flow {\n        emit(1)\n        emit(2)\n        emit(3)\n        emit(4)\n        emit(5)\n    }.collect {      // 2\n            logX(it)\n        }\n}\n\n/**\n * 控制台输出带协程信息的log\n */\nfun logX(any: Any?) {\n    println(\n        \"\"\"\n================================\n$any\nThread:${Thread.currentThread().name}\n================================\"\"\".trimIndent()\n    )\n}\n\n/*\n输出结果\n================================\n1\nThread:DefaultDispatcher-worker-1\n================================\n================================\n2\nThread:DefaultDispatcher-worker-1\n================================\n================================\n3\nThread:DefaultDispatcher-worker-1\n================================\n================================\n4\nThread:DefaultDispatcher-worker-1\n================================\n================================\n5\nThread:DefaultDispatcher-worker-1\n================================\n================================\nend\nThread:main\n================================\n*/\n</code></pre><!-- [[[read_end]]] --><p>这段代码很简单，我们创建了一个CoroutineScope，接着使用它创建了一个新的协程，在协程当中，我们使用flow{} 这个高阶函数创建了Flow对象，接着使用了collect{} 这个终止操作符。<br>\n我们利用<a href=\"https://time.geekbang.org/column/article/491632\">第20讲</a>当中学过的内容，很容易就能想象出类似这样的一个思维模型。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/4f/e3c3bd48f715e6d26yye3bd60096fd4f.jpg?wh=2000x940\" alt=\"\"></p><p>那么下面，我们就先来看看注释1处，分析一下Flow是怎么创建出来的。</p><pre><code class=\"language-plain\">// 代码段2\n\npublic fun &lt;T&gt; flow(block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit): Flow&lt;T&gt; =\n     SafeFlow(block)\n\npublic interface Flow&lt;out T&gt; {\n    public suspend fun collect(collector: FlowCollector&lt;T&gt;)\n}\n</code></pre><p>可以看到，flow{} 是一个高阶函数，它接收的参数类型是函数类型<code>FlowCollector&lt;T&gt;.() -&gt; Unit</code>，这个类型代表了：它是FlowCollector的扩展或成员方法，没有参数，也没有返回值。flow()的返回值类型是<code>Flow&lt;T&gt;</code>，而它实际返回的类型是SafeFlow，让我们来看看它的源码定义。</p><pre><code class=\"language-plain\">// 代码段3\n\nprivate class SafeFlow&lt;T&gt;(private val block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit) : AbstractFlow&lt;T&gt;() {\n    // 1\n    override suspend fun collectSafely(collector: FlowCollector&lt;T&gt;) {\n        collector.block()\n    }\n}\n\npublic abstract class AbstractFlow&lt;T&gt; : Flow&lt;T&gt;, CancellableFlow&lt;T&gt; {\n    // 省略\n}\n\ninternal interface CancellableFlow&lt;out T&gt; : Flow&lt;T&gt;\n</code></pre><p>从上面的代码我们可以看到，SafeFlow其实是AbstractFlow的子类，而AbstractFlow则实现了Flow这个接口，所以SafeFlow算是间接实现了Flow接口。而AbstractFlow是协程当中所有Flow的抽象类，所以，它当中应该会有许多Flow通用的逻辑。</p><p>那么接下来，我们就来看看AbstractFlow当中的逻辑：</p><pre><code class=\"language-plain\">// 代码段4\n\npublic abstract class AbstractFlow&lt;T&gt; : Flow&lt;T&gt;, CancellableFlow&lt;T&gt; {\n\n    // 1\n    public final override suspend fun collect(collector: FlowCollector&lt;T&gt;) {\n        // 2\n        val safeCollector = SafeCollector(collector, coroutineContext)\n        try {\n            // 3\n            collectSafely(safeCollector)\n        } finally {\n            safeCollector.releaseIntercepted()\n        }\n    }\n\n    public abstract suspend fun collectSafely(collector: FlowCollector&lt;T&gt;)\n}\n</code></pre><p>请留意上面代码的注释1，看到这个挂起函数collect()，你是不是觉得很熟悉呢？它其实就是终止操作符collect对应的调用处。这个collect()的逻辑其实也很简单，我都用注释标记出来了，我们来看看：</p><ul>\n<li>注释2，collect()的参数类型是FlowCollector，这里只是将其重新封装了一遍，变成了SafeColletor对象。从它的名称，我们也大概可以猜出来，它肯定是会对collect当中的逻辑做一些安全检查的，SafeCollector的源码我们留到后面分析，我们接着看注释3。</li>\n<li>注释3，collectSafely()，这里其实就是调用了它的抽象方法，而它的具体实现就在代码段3里SafeFlow的collectSafely()方法，而它的逻辑也很简单，它直接调用了collector.block()，这其实就相当于触发了flow{} 当中的Lambda逻辑。换句话说，collector.block()就相当于调用了代码段1当中的5次emit()方法。</li>\n</ul><p>那么，代码分析到这里，我们其实就已经可以看出来Flow为什么是冷的了。我们都知道Channel之所以是热的，是因为它不管有没有接收方，发送方都会工作。而FLow之所以是冷的，是因为Flow的构造器，真的就只会构造一个SafeFlow对象，完全不会触发执行它内部的Lambda表达式的逻辑，<strong>只有当collect()被调用之后，flow{} 当中的Lambda逻辑才会真正被触发执行</strong>。</p><p>好，现在我们已经知道collect()是如何触发Flow执行的了，接下来，我们来看看Flow是如何将上游的数据传递给下游的。</p><h2>FlowCollector：上游与下游之间的桥梁</h2><p>经过之前的分析，我们知道flow{} 这个高阶函数会创建一个Flow对象，它具体的类型是SafeFlow，它其实间接实现了Flow接口，因此我们可以直接调用collect()这个终止操作符，从而拿到flow{} 的Lambda当中emit（发射）出来的数据。</p><p>上面整个流程分析下来，给我们的感觉是这样的：<strong>下游的collect()会触发上游的Lambda执行，上游的Lambda当中的emit()会把数据传递给下游</strong>。</p><p>那么，Flow到底是如何做到的呢？这其中的关键，还是collect()传入的参数类型：FlowCollector。</p><pre><code class=\"language-plain\">// 代码段5\n\npublic fun interface FlowCollector&lt;in T&gt; {\n    public suspend fun emit(value: T)\n}\n\npublic interface Flow&lt;out T&gt; {\n    public suspend fun collect(collector: FlowCollector&lt;T&gt;)\n}\n</code></pre><p>当我们在下游调用collect{} 的时候，其实是在调用Flow接口的collect方法，而我们之所以可以写出花括号的形式，是因为Lambda简写，这一点我们在<a href=\"https://time.geekbang.org/column/article/476637\">第7讲</a>当中有提到过。那么，为了让它们的关系更加清晰地暴露出来，我们可以换一种写法，来实现代码段1当中的逻辑。</p><pre><code class=\"language-plain\">// 代码段6\n\nprivate suspend fun testFlow() {\n\n    flow {\n        // 1\n        emit(1)\n        emit(2)\n        emit(3)\n        emit(4)\n        emit(5)\n    }\n        // 变化在这里\n        .collect(object : FlowCollector&lt;Int&gt;{ \n            // 2\n            override suspend fun emit(value: Int) {\n                logX(value)\n            }\n        })\n}\n</code></pre><p>这里代码段6和前面代码段1的逻辑其实是等价的，唯一的变化在于，这里我们使用了匿名内部类的方式，直接传入了FlowCollector，在这个匿名内部类的emit()方法，其实就充当着Flow的下游接收其中的数据流。</p><p>所以，要分析“上游与下游是如何连接的”这个问题，我们只需要看注释2处的emit()是如何被调用的即可。</p><p>那么，经过前面代码段4的分析，我们从它注释2处的代码就可以知道，collect()方法传入的FlowCollector参数，其实是被传入SafeCollector当中，被封装了起来。所以接下来，我们只要分析SafeCollector当中的逻辑就行。</p><pre><code class=\"language-plain\">// 代码段7\n\ninternal actual class SafeCollector&lt;T&gt; actual constructor(\n    // 1\n    @JvmField internal actual val collector: FlowCollector&lt;T&gt;,\n    @JvmField internal actual val collectContext: CoroutineContext\n) : FlowCollector&lt;T&gt;, ContinuationImpl(NoOpContinuation, EmptyCoroutineContext), CoroutineStackFrame {\n\n    internal actual val collectContextSize = collectContext.fold(0) { count, _ -&gt; count + 1 }\n    private var lastEmissionContext: CoroutineContext? = null\n    private var completion: Continuation&lt;Unit&gt;? = null\n\n    // ContinuationImpl\n    override val context: CoroutineContext\n        get() = completion?.context ?: EmptyCoroutineContext\n\n    // 2\n    override suspend fun emit(value: T) {\n        return suspendCoroutineUninterceptedOrReturn sc@{ uCont -&gt;\n            try {\n                // 3\n                emit(uCont, value)\n            } catch (e: Throwable) {\n                lastEmissionContext = DownstreamExceptionElement(e)\n                throw e\n            }\n        }\n    }\n\n    private fun emit(uCont: Continuation&lt;Unit&gt;, value: T): Any? {\n        val currentContext = uCont.context\n        currentContext.ensureActive()\n\n        // 4\n        val previousContext = lastEmissionContext\n        if (previousContext !== currentContext) {\n            checkContext(currentContext, previousContext, value)\n        }\n        completion = uCont\n        // 5\n        return emitFun(collector as FlowCollector&lt;Any?&gt;, value, this as Continuation&lt;Unit&gt;)\n    }\n\n}\n\n// 6\nprivate val emitFun =\n    FlowCollector&lt;Any?&gt;::emit as Function3&lt;FlowCollector&lt;Any?&gt;, Any?, Continuation&lt;Unit&gt;, Any?&gt;\n\npublic interface Function3&lt;in P1, in P2, in P3, out R&gt; : Function&lt;R&gt; {\n    public operator fun invoke(p1: P1, p2: P2, p3: P3): R\n}\n</code></pre><p>在这段SafeCollector的源码中，一共有6个地方需要我们注意，让我们来看看。</p><p>注释1，collector，它是SafeCollector的参数，通过分析代码段4的注释2处，我们可以知道，它其实就对应着代码段6里，注释1处的匿名内部类FlowCollector。之后我们需要特别留意这个collector，看看它的emit()是在哪里被调用的，因为这就意味着代码段6当中的注释2被调用。我们可以将其看作<strong>下游的emit()</strong>。</p><p>注释2，emit()，通过之前代码段4的分析，我们知道，这个emit()方法，其实就是代码段6里调用的emit()。也就是说，Flow上游发送的数据，最终会传递到这个emit()方法当中来。我们可以将其看作<strong>上游的emit()</strong>。</p><p>注释3，emit(uCont, value)，这里的suspendCoroutineUninterceptedOrReturn这个高阶函数，是把挂起函数的Continuation暴露了出来，并且将其作为参数传递给了另一个emit()方法。你需要注意的是，这行代码被try-catch包裹了，而且把其中的异常捕获以后，会被重新包装成DownstreamExceptionElement，意思就是“下游的异常”，这从侧面也能说明，这个方法即将执行下游的代码。</p><p>这里还有一个细节就是，DownstreamExceptionElement会被存储在lastEmissionContext当中，它的作用是：在下游发送异常以后，可以让上游感知到。</p><p>注释4，这里会对当前的协程上下文与之前的协程上下文做对比检查，如果它们两者不一致，就会在checkContext()当中做进一步的判断和提示。我们第20讲思考题的答案就藏在这里，为了不偏离主线，这个部分的逻辑我们暂时先放着，等我们分析完Flow的整体流程以后再来看。</p><p>注释5，<code>emitFun(collector as FlowCollector&lt;Any?&gt;, value, this as Continuation&lt;Unit&gt;)</code>，这里其实就是在调用下游的emit()，也就是代码段6当中的注释2对应的emit()方法。那么，这里的emitFun()是什么呢？我们可以在注释6处找到它的定义：<code>FlowCollector&lt;Any?&gt;::emit</code>，这是函数引用的语法，代表了它就是FlowCollector的emit()方法，它的类型是<code>Function3&lt;FlowCollector&lt;Any?&gt;, Any?, Continuation&lt;Unit&gt;, Any?&gt;</code>。</p><p>乍一看，你也许会觉得这个类型有点难以理解，其实，这个知识点我们在<a href=\"https://time.geekbang.org/column/article/477295\">第8讲</a>当中就已经介绍过，我们平时写的函数类型<code>() -&gt; Unit</code>其实就对应了Function0，也就是：没有参数的函数类型。所以，这里的Function3其实就代表了三个参数的函数类型。因此，注释5处，其实就代表了下游的emit()方法被调用了，对应的value也是这时候传进去的。</p><p>至此，上游传递数据给下游的整个流程，我们也分析完毕了，FlowCollector其实就相当于上游与下游之间的桥梁，它起到了连接上游、下游的作用。</p><p>回过头去看前面分析过的代码，你会发现，Flow的核心原理其实只牵涉到那么几十行代码，而它的核心接口也只有Flow、FlowCollector而已。为了方便你理解，这里我做了一个视频，描述Flow的整体调用流程。</p><p><video poster=\"https://media001.geekbang.org/ee3f3922229043989ff5360153d32bb3/snapshots/18583a3c35934300ba8168a9cdf3bffe-00003.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/1cde05a-17ffa4bfd9b-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/b5538bc05f124a169a9f327652c34ede/9d938a35259248e8a7d07883f4b8fd3d-9df58af0511489d2a6a939c5941037dd-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>所以，对比挂起函数的原理，不得不说，Flow真的只是一只看起来吓人的“纸老虎”。</p><h2>思考与推演</h2><p>接下来，我们基于前面的结论来进行一些思考，来尝试推演和理解一下Flow的其他功能细节，比如：中间操作符的原理、不允许使用withContext{} 的原因。</p><h3>推演：中间操作符</h3><p>请你想象一个问题：在已知Flow上游、下游传递数据的原理以后，如果让你来设计Flow的中间操作符，你会怎么设计？</p><p>要回答这个问题，其实我们只需要回想一下Flow的思维模型，让我们来更新一下代码段1对应的思维模型，将Flow的源码执行流程也融入进去：</p><p><img src=\"https://static001.geekbang.org/resource/image/98/ac/9828f4c4f874ddf4b7d1c45a5f5ab5ac.jpg?wh=2000x980\" alt=\"\"></p><p>flow{} 这个高阶函数，代表了上游，它会创建一个Flow对象，提供给下游调用Flow的collect方法。在前面的代码段2当中，我们曾经分析过，flow{} 实际上返回的是SafeFlow对象，在这个SafeFlow当中，会有一个SafeCollector对象。而整个Flow的调用过程，其实就是三个步骤：</p><ul>\n<li>第一步，上游的flow{} 创建SafeFlow的对象，下游调用Flow的collect()方法，触发flow{} 的Lambda对应的代码执行，也就是其中emit()被执行。</li>\n<li>第二步，上游调用的emit()，其实就是SafeCollector的emit()，这时候，就相当于上游将数据传递给SafeCollector。</li>\n<li>第三步，SafeCollector调用emitFun()，这里的emitFun()其实就对应了下游的emit()方法（如果你忘了，可以回过头看看代码段6的注释2）。</li>\n</ul><p>通过以上分析，我们能发现，Flow的源码执行流程，也非常符合我们之前构想出来的思维模型。那么，对于它的中间操作符，我们是不是只需要加一个“中转站”就可以了呢？答案是肯定的。</p><p>如果让你来设计Flow的中间操作符，我相信你大概率会设计出类似下面这样的结构：</p><p><img src=\"https://static001.geekbang.org/resource/image/13/eb/13acf7e1dbffdc22226f59f432658deb.jpg?wh=2000x1125\" alt=\"\"></p><p>可以看到，当Flow当中出现中间操作符的时候，上游和下游之间就会多出一个个的中转站。对于每一个“中转站”来说，它都会有上游和下游，它都会被下游触发执行，它也会触发自己的上游；同时，它会接收来自上游的数据，也会传递给自己的下游。</p><p>那么，接下来，让我们来分析一下Flow中间操作符的源代码，看看Kotlin官方的设计是否符合我们的猜想：</p><pre><code class=\"language-plain\">// 代码段8\n\n// 1\ninline fun &lt;T&gt; Flow&lt;T&gt;.filter(\n    crossinline predicate: suspend (T) -&gt; Boolean\n): Flow&lt;T&gt; = transform { value -&gt;\n    // 8\n    if (predicate(value)) return@transform emit(value)\n}\n\n// 2\ninternal inline fun &lt;T, R&gt; Flow&lt;T&gt;.unsafeTransform(\n    crossinline transform: suspend FlowCollector&lt;R&gt;.(value: T) -&gt; Unit\n): Flow&lt;R&gt; = unsafeFlow { \n    // 6\n    collect { value -&gt;\n        // 7\n        return@collect transform(value)\n    }\n}\n\n// 3\ninternal inline fun &lt;T&gt; unsafeFlow(\n    crossinline block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit\n): Flow&lt;T&gt; {\n    // 4\n    return object : Flow&lt;T&gt; {\n        // 5\n        override suspend fun collect(collector: FlowCollector&lt;T&gt;) {\n            collector.block()\n        }\n    }\n}\n</code></pre><p>上面的代码看起来有点复杂，让我们来一步步来分析：</p><ul>\n<li>注释1、2、3，请留意这几个方法的签名，它们的返回值类型都是Flow，这意味着，Flow.filter{} 的返回值类型仍然是Flow。我们站在整体的角度来分析的话，会发现：这只是一个Flow被封装的过程。我们都知道，flow{} 创建的是SafeFlow对象，当我们接着调用filter{} 之后，根据注释4处的逻辑，我们发现它会变成一个普通的Flow匿名内部类对象。</li>\n<li>注释5，对于<code>flow{}.filter{}.collect{}</code>这样的代码，最终的collect{} 调用的代码，其实就是注释5对应的collect()方法。我们看看它的方法体collector.block()，这其实就代表了注释6、7会执行。</li>\n<li>注释6，collect{}，这里是在调用上游Flow的collect{}，触发上游的Lambda执行了，也就是<code>flow{}.filter{}.collect{}</code>里的flow{} 当中的Lambda，然后注释7就会被执行。</li>\n<li>注释7，transform(value)，在前面代码段7的分析中，我们知道，这里transform(value)当中的value，其实就是上游传递下来的数据，让我们来看看transform{} 当中具体的逻辑，也就是注释8。</li>\n<li>注释8，<code>if (predicate(value))</code>，这其实就是我们filter的条件，只有符合这个条件的情况下，我们才会继续向下游传递数据，而传递的方式，就是调用emit()，这里的emit()其实就代表了下游会接收到数据了。</li>\n</ul><p>可见，filter{} 的核心思想，完全符合我们前面思维模型推演的结果。接下来，我们来看看map{}、onEach{} 之类的源码：</p><pre><code class=\"language-plain\">// 代码段9\n\npublic inline fun &lt;T, R&gt; Flow&lt;T&gt;.map(crossinline transform: suspend (value: T) -&gt; R): Flow&lt;R&gt; = transform { value -&gt;\n    return@transform emit(transform(value))\n}\n\npublic fun &lt;T&gt; Flow&lt;T&gt;.onEach(action: suspend (T) -&gt; Unit): Flow&lt;T&gt; = transform { value -&gt;\n    action(value)\n    return@transform emit(value)\n}\n</code></pre><p>当我们理解了filter以后，你会发现，map、和onEach之类的操作符就变得很简单了。前者就是在调用下游emit()的时候做了一次数据转换，而后者则是在每次向下游传递数据的时候，同时调用一下传入的Lambda表达式action()。</p><h3>思考：上下文保护</h3><p>在第20讲当中，我留过一个思考题：</p><blockquote>\n<p>课程里我曾提到过，Flow当中直接使用withContext{} 是很容易出现问题的，下面代码是其中的一种。请问你能解释其中的缘由吗？Kotlin官方为什么要这么设计？</p>\n</blockquote><pre><code class=\"language-plain\">// 代码段10\n\nfun main() = runBlocking {\n    flow {\n        withContext(Dispatchers.IO) {\n            emit(1)\n        }\n    }.map { it * 2 }\n        .collect()\n}\n\n/*\n输出结果：\n\nException in thread \"main\" java.lang.IllegalStateException: Flow invariant is violated:\n        Flow was collected in [BlockingCoroutine{Active}@6e58a46, BlockingEventLoop@2cbfb24],\n        but emission happened in [DispatchedCoroutine{Active}@500da3c0, Dispatchers.IO].\n        Please refer to 'flow' documentation or use 'flowOn' instead\n*/\n</code></pre><p>其实，课程进行到这里，我们就已经可以很简单地回答这个问题了。</p><p>在<a href=\"https://time.geekbang.org/column/article/494526\">第24讲</a>当中，我们曾经给Flow的三种API进行过分类：Flow构建器、Flow中间操作符，它们两个是不需要协程作用域的，只有Flow终止操作符需要协程作用域。</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/b7/b98d651e66309f67f16843e5d00a80b7.jpg?wh=2000x1125\" alt=\"\"></p><p>通过前面Flow的源码分析流程，我们其实就会发现，在默认情况下，Flow下游的“协程上下文”最终会成为上游的执行环境，也会变成中间操作符的执行环境。也正是这个原因，才让Flow可以天然支持协程的“结构化并发”的特性，比如说结构化取消。</p><pre><code class=\"language-plain\">// 代码段11\n\nprivate fun testFlow2() {\n    val scope = CoroutineScope(Job())\n    scope.launch {\n        flow {\n            logX(\"上游\")\n            repeat(100) {\n                emit(it)\n            }\n        }.filter {\n            logX(\"中间\")\n            it &gt; 2\n        }\n            .map { it * 2 }\n            .onCompletion {\n                logX(it)\n            }\n            .collect {\n                logX(it)\n                delay(1000L)\n            }\n    }\n\n    Thread.sleep(2000L)\n\n    scope.cancel()\n    logX(\"结束\")\n}\n\n/*\n输出结果：\n================================\n上游\nThread:DefaultDispatcher-worker-1\n================================\n================================\n中间\nThread:DefaultDispatcher-worker-1\n================================\n================================\n中间\nThread:DefaultDispatcher-worker-1\n================================\n================================\n中间\nThread:DefaultDispatcher-worker-1\n================================\n================================\n中间\nThread:DefaultDispatcher-worker-1\n================================\n================================\n6\nThread:DefaultDispatcher-worker-1\n================================\n================================\n中间\nThread:DefaultDispatcher-worker-1\n================================\n================================\n8\nThread:DefaultDispatcher-worker-1\n================================\n================================\n结束\nThread:main\n================================\n================================\nkotlinx.coroutines.JobCancellationException: Job was cancelled; job=JobImpl{Cancelling}@407d87d0\nThread:DefaultDispatcher-worker-1\n================================\n*/\n</code></pre><p>从上面的执行结果可以看到，虽然我们的上游要尝试emit()100个数据，但是由于外部的scope在2000毫秒后会取消，所以整个Flow都会响应取消。</p><p>那么反之，如果Kotlin官方允许开发者在flow{} 当中，调用withContext{} 改变协程上下文的话，<strong>Flow上游与下游的协程上下文就会不一致，它们整体的结构也会被破坏，从而导致“结构化并发”的特性也被破坏</strong>。</p><p>Flow源码中对于上下文的检测，我们称之为上下文保护（Context Preservation），它对应的检测时机在代码段7的注释4处，具体的逻辑如下：</p><pre><code class=\"language-plain\">// 代码段12\n\nprivate fun emit(uCont: Continuation&lt;Unit&gt;, value: T): Any? {\n    // 省略\n    // This check is triggered once per flow on happy path.\n    val previousContext = lastEmissionContext\n    if (previousContext !== currentContext) {\n        checkContext(currentContext, previousContext, value)\n    }\n}\n\nprivate fun checkContext(\n    currentContext: CoroutineContext,\n    previousContext: CoroutineContext?,\n    value: T\n) {\n    if (previousContext is DownstreamExceptionElement) {\n        exceptionTransparencyViolated(previousContext, value)\n    }\n    checkContext(currentContext)\n    lastEmissionContext = currentContext\n}\n\ninternal fun SafeCollector&lt;*&gt;.checkContext(currentContext: CoroutineContext) {\n    val result = currentContext.fold(0) fold@{ count, element -&gt;\n        val key = element.key\n        val collectElement = collectContext[key]\n        if (key !== Job) {\n            return@fold if (element !== collectElement) Int.MIN_VALUE\n            else count + 1\n        }\n\n        val collectJob = collectElement as Job?\n        val emissionParentJob = (element as Job).transitiveCoroutineParent(collectJob)\n\n        if (emissionParentJob !== collectJob) {\n            error(\n                \"Flow invariant is violated:\\n\" +\n                        \"\\t\\tEmission from another coroutine is detected.\\n\" +\n                        \"\\t\\tChild of $emissionParentJob, expected child of $collectJob.\\n\" +\n                        \"\\t\\tFlowCollector is not thread-safe and concurrent emissions are prohibited.\\n\" +\n                        \"\\t\\tTo mitigate this restriction please use 'channelFlow' builder instead of 'flow'\"\n            )\n        }\n\n\n        if (collectJob == null) count else count + 1\n    }\n\n    // 判断上游、下游的Context\n    if (result != collectContextSize) {\n        error(\n            \"Flow invariant is violated:\\n\" +\n                    \"\\t\\tFlow was collected in $collectContext,\\n\" +\n                    \"\\t\\tbut emission happened in $currentContext.\\n\" +\n                    \"\\t\\tPlease refer to 'flow' documentation or use 'flowOn' instead\"\n        )\n    }\n}\n</code></pre><p>所以，总的来说，Flow不允许直接使用withContext{} 的原因，是为了“结构化并发”，它并不是不允许切换线程，而是不允许随意破坏协程的上下文。Kotlin提供的操作符flowOn{}，官方已经帮我们处理好了上下文的问题，所以我们可以放心地切线程。</p><h2>小结</h2><p>这节课，我们是通过分析Flow的源码，理解了它的几类API是如何实现的。我们知道，Flow是冷数据流，可以分为上游Flow构造器、中间操作符、下游FlowCollector。那么可以说，<strong>理解了Flow、FlowCollector这两个接口，其实就理解了Flow的原理。</strong></p><p>上游Flow构造器，它实际返回的对象是SafeFlow，在SafeFlow当中有一个SafeCollector，它会接收上游的数据，并且将数据传递给下游的FlowCollector。</p><p>下游FlowCollector，在下游调用collect()的时候，实际上是调用的Flow的collect()方法，这就会触发上游的Lambda被执行。在collect()调用的时候，它会创建一个FlowCollector的匿名内部类对象，专门用于接收来自上游的数据。</p><p>中间操作符，它在整个Flow的调用流程当中，既会充当上游，也会充当下游。它会被下游触发执行，它也会触发自己的上游；同时，它会接收来自上游的数据，也会传递给自己的下游。</p><p>上下文保护，由于Flow的上游与中间操作符并不需要协程作用域，因此，它们都是共用的Flow下游的协程上下文。也正是因为Flow的这种设计，让Flow天然支持结构化并发。为此，Kotlin官方也限制了我们开发者不能随意在上游与中转站阶段，改变Flow的上下文。</p><p>其实，课程进行到这里，你会发现，Flow的原理之所以看起来很简单，完全是因为它站在了“挂起函数”“高阶函数”这两个巨人的肩膀上！如果没有它们作为基础，Flow的API设计一定会更加复杂。</p><h2>思考题</h2><p>前面我提到过，“理解了Flow、FlowCollector这两个接口，就理解了Flow的原理。”那么，你能概括出Flow、FlowCollector这两个抽象的接口之间的内在联系吗？</p><pre><code class=\"language-plain\">public interface Flow&lt;out T&gt; {\n    public suspend fun collect(collector: FlowCollector&lt;T&gt;)\n}\n\npublic fun interface FlowCollector&lt;in T&gt; {\n    public suspend fun emit(value: T)\n}\n</code></pre>","neighbors":{"left":{"article_title":"31 | 图解Channel：如何理解它的CSP通信模型？","id":502085},"right":{"article_title":"33 | Java Android开发者还会有未来吗？","id":504379}},"comments":[{"had_liked":false,"id":340856,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1649204134,"is_pvip":false,"replies":[{"id":"124724","content":"不错的答案，赞~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649435603,"ip_address":"","comment_id":340856,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31713975206","product_id":100103401,"comment_content":"Flow 接口引用了FlowCollector接口，并封装了一段调用逻辑，作为将来FlowCollector使用的来源。FlowCollector，带有emit函数的接口，统一了上游的发送方的数据输出和下游接收方的数据输入。FlowCollector的做法和通常扩展函数不太一样，通常的扩展函数是先有核心类，然后扩展函数扩充核心类的功能。FlowCollector是先在上游的构造器里构建了高阶的扩展函数，然后在下游collect里实现了带有emit的核心类。下游collect触发流程，然后上游的emit驱动下游的emit。这么设计原因应该是上游的构造器，相对复杂，而且是推迟执行的，需要给开发人员以足够的灵活性，所以采用了扩展函数的格式，下游接受数据相对固定，而且是同步执行的，采用固定的FlowCollector接口。<br>","like_count":8,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560786,"discussion_content":"不错的答案，赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649435603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340891,"user_name":"大土豆","can_delete":false,"product_type":"c1","uid":1121636,"ip_address":"","ucode":"67445DC3EC9DB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/64/52a5863b.jpg","comment_is_top":false,"comment_ctime":1649218769,"is_pvip":true,"replies":[{"id":"124722","content":"哈哈哈……Android开发的领域整体确实趋向于饱和了，不过中、高级的Android开发者还是比较稀缺的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649435500,"ip_address":"","comment_id":340891,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10239153361","product_id":100103401,"comment_content":"老师，下节课的目录得改下。。。应该是Android开发者还有未来吗？市场基本都没需求了","like_count":3,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560784,"discussion_content":"哈哈哈……Android开发的领域整体确实趋向于饱和了，不过中、高级的Android开发者还是比较稀缺的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649435500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341196,"user_name":"dawn","can_delete":false,"product_type":"c1","uid":1121701,"ip_address":"","ucode":"979CE356267183","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIpF5euTNx3GOkmf515HFh1ahAzogerLfIyLia2AspTIR9fkU6icGbo2ungo23cdM5s9dUjZGMno7ZA/132","comment_is_top":false,"comment_ctime":1649415088,"is_pvip":false,"replies":[{"id":"124976","content":"因为它的扩展接收者是Flow呀，说实话，这部分的API挺巧妙的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649954926,"ip_address":"","comment_id":341196,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5944382384","product_id":100103401,"comment_content":"@PublishedApi<br>internal inline fun &lt;T, R&gt; Flow&lt;T&gt;.unsafeTransform(<br>    @BuilderInference crossinline transform: suspend FlowCollector&lt;R&gt;.(value: T) -&gt; Unit<br>): Flow&lt;R&gt; = unsafeFlow { &#47;&#47; Note: unsafe flow is used here, because unsafeTransform is only for internal use<br>这里的作用域应该是FlowCollector，为什么可以调用collect函数<br>    collect { value -&gt;<br>        &#47;&#47; kludge, without it Unit will be returned and TCE won&#39;t kick in, KT-28938<br>        return@collect transform(value)<br>    }<br>}<br><br>@PublishedApi<br>internal inline fun &lt;T&gt; unsafeFlow(@BuilderInference crossinline block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit): Flow&lt;T&gt; {<br>    return object : Flow&lt;T&gt; {<br>        override suspend fun collect(collector: FlowCollector&lt;T&gt;) {<br>            collector.block()<br>        }<br>    }<br>}","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563259,"discussion_content":"因为它的扩展接收者是Flow呀，说实话，这部分的API挺巧妙的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649954926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":566653,"discussion_content":"这块我也没看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650726642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":563259,"ip_address":""},"score":566653,"extra":""},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":566695,"discussion_content":"老师可以讲下这部分的 api 么，绕来绕去找不到调用链","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650730181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":563259,"ip_address":""},"score":566695,"extra":""}]}]},{"had_liked":false,"id":352110,"user_name":"薄荷","can_delete":false,"product_type":"c1","uid":1136686,"ip_address":"","ucode":"EB07BD2E5FDE6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/2e/08e6ce7c.jpg","comment_is_top":false,"comment_ctime":1658388907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658388907","product_id":100103401,"comment_content":"我的理解是：<br>flow这个顶层函数生成Flow的过程其实就是携带了block块中的数据，按照我的理解我写了下面这样一个类<br>class MFlow&lt;T&gt;(vararg elements: T) {<br>    private val list: List&lt;T&gt;<br><br>    init {<br>        list = elements.asList()<br>    }<br><br>    suspend fun collect(collector: FlowCollector&lt;T&gt;) {<br>        for (element in list) {<br>            collector.emit(element)<br>        }<br>    }<br>}<br>而FlowCollector的emit方法其实是对数据的具体处理逻辑，<br>Flow的collect函数调用会传入一个FlowCollector对象，同时用具体逻辑处理之前保存的数据","like_count":0},{"had_liked":false,"id":343700,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1650988348,"is_pvip":false,"replies":[{"id":"125639","content":"答案：是 flow {}.filter {}.collect {} 中终止操作符号  collect 传入的 FlowCollector。<br><br>这里用文字描述可能比较费劲，我试着解释一下：<br><br>flow {}.filter {}.collect {}当中的 collect{} ，它传入的FlowCollector，是通过下面注释处，跟transform建立关系的。<br><br>```<br>internal inline fun &lt;T&gt; unsafeFlow(<br>    crossinline block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit<br>): Flow&lt;T&gt; {<br><br>    return object : Flow&lt;T&gt; {<br><br>        override suspend fun collect(collector: FlowCollector&lt;T&gt;) {<br>               &#47;&#47; 注意这里<br>            collector.block()<br>        }<br>    }<br>}<br>```","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651246443,"ip_address":"","comment_id":343700,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650988348","product_id":100103401,"comment_content":"&#47;&#47; 2<br>internal inline fun &lt;T, R&gt; Flow&lt;T&gt;.unsafeTransform(<br>    crossinline transform: suspend FlowCollector&lt;R&gt;.(value: T) -&gt; Unit<br>): Flow&lt;R&gt; = unsafeFlow { <br>    &#47;&#47; 6<br>    collect { value -&gt;<br>        &#47;&#47; 7<br>        return@collect transform(value)<br>    }<br>}<br><br>老师，可以解答下么：<br><br>1、transform 的接受者是哪个实例呢？是 flow {}.filter {}.collect {} 中终止操作符号  collect 传入的 FlowCollector<br><br>还是注释 6 处  collect 传入的 FlowCollector 实例呢？<br><br>按照逻辑的话，应该是终止操作符号 collect {} 传入的 FlowCollector。<br><br>但是看逻辑，注释 6 处的 collect 的参数也是个 FlowCollector 实例，那么 transform 的接受者应该是它？？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568888,"discussion_content":"答案：是 flow {}.filter {}.collect {} 中终止操作符号  collect 传入的 FlowCollector。\n\n这里用文字描述可能比较费劲，我试着解释一下：\n\nflow {}.filter {}.collect {}当中的 collect{} ，它传入的FlowCollector，是通过下面注释处，跟transform建立关系的。\n\n```\ninternal inline fun &lt;T&gt; unsafeFlow(\n    crossinline block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit\n): Flow&lt;T&gt; {\n\n    return object : Flow&lt;T&gt; {\n\n        override suspend fun collect(collector: FlowCollector&lt;T&gt;) {\n               // 注意这里\n            collector.block()\n        }\n    }\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651246443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343698,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1650987863,"is_pvip":false,"replies":[{"id":"125640","content":"在你另一个回复里解答了哈~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651246466,"ip_address":"","comment_id":343698,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650987863","product_id":100103401,"comment_content":"&#47;&#47; 2<br>internal inline fun &lt;T, R&gt; Flow&lt;T&gt;.unsafeTransform (<br>    crossinline transform: suspend FlowCollector&lt;R&gt;.(value: T) -&gt; Unit<br>): Flow&lt;R&gt; = unsafeFlow { <br>    &#47;&#47; 6<br>    collect { value -&gt;<br>        &#47;&#47; 7<br>        return@collect transform (value)<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568889,"discussion_content":"在你另一个回复里解答了哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651246466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343557,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1650909085,"is_pvip":false,"replies":[{"id":"125645","content":"答案是：是 flow{}.filter{}.collect{} 中，终止操作符传入的 FlowCollector 匿名内部类实例。<br><br>我在你另一个评论里解答了哈~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651246712,"ip_address":"","comment_id":343557,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650909085","product_id":100103401,"comment_content":"<br>&#47;&#47; 代码段8<br><br>&#47;&#47; 1<br>inline fun &lt;T&gt; Flow&lt;T&gt;.filter(<br>    crossinline predicate: suspend (T) -&gt; Boolean<br>): Flow&lt;T&gt; = transform { value -&gt;<br>    &#47;&#47; 8<br>    if (predicate(value)) return@transform emit(value)<br>}<br><br>&#47;&#47; 2<br>internal inline fun &lt;T, R&gt; Flow&lt;T&gt;.unsafeTransform(<br>    crossinline transform: suspend FlowCollector&lt;R&gt;.(value: T) -&gt; Unit<br>): Flow&lt;R&gt; = unsafeFlow { <br>    &#47;&#47; 6<br>    collect { value -&gt;<br>        &#47;&#47; 7<br>        return@collect transform(value)<br>    }<br>}<br><br>&#47;&#47; 3<br>internal inline fun &lt;T&gt; unsafeFlow(<br>    crossinline block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit<br>): Flow&lt;T&gt; {<br>    &#47;&#47; 4<br>    return object : Flow&lt;T&gt; {<br>        &#47;&#47; 5<br>        override suspend fun collect(collector: FlowCollector&lt;T&gt;) {<br>            collector.block()<br>        }<br>    }<br>}<br><br>老师好，想在问一个问题：<br> <br>unsafeTransform  中的 collect 参数是一个 FlowCollector 匿名内部类实例<br><br>那 return@collect transform(value) 中的  transform 的接收者是这个 FlowCollector 匿名内部类实例<br><br>还是 flow{}.filter{}.collect{} 中，终止操作符传入的 FlowCollector 匿名内部类实例呢？？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568895,"discussion_content":"答案是：是 flow{}.filter{}.collect{} 中，终止操作符传入的 FlowCollector 匿名内部类实例。\n\n我在你另一个评论里解答了哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651246712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343267,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1650742165,"is_pvip":false,"replies":[{"id":"125371","content":"请留意你注释2处的，扩展接收者类型，它也是Flow。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1650812313,"ip_address":"","comment_id":343267,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650742165","product_id":100103401,"comment_content":"老师好，对于 Flow 的 fliter 的源码，确实没看懂，可以详细讲下么？？<br><br>直接看源码不直观，反编译看 java 有很凌乱<br><br>&#47;&#47; unsafeTransform<br>&#47;&#47; 2<br>inline fun &lt;T&gt; Flow&lt;T&gt;.unsafeTransform(<br>    crossinline transform: suspend FlowCollector&lt;T&gt;.(value: T) -&gt; Unit &#47;&#47; FlowCollector.transform<br>): Flow&lt;T&gt; {<br>    return unsafeFlow { <br>        &#47;&#47; 这里的作用域应该是 FlowCollector，为什么可以调用 collect 函数<br>        collect(object : FlowCollector&lt;T&gt; { <br>            override suspend fun emit(value: T) {<br>                &#47;&#47; 7<br>                transform(value)<br>            }<br>        })<br>        &#47;&#47; 6<br>&#47;&#47;        collect { value -&gt;<br>&#47;&#47;            &#47;&#47; 7<br>&#47;&#47;            return@collect transform(value)<br>&#47;&#47;        }<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567014,"discussion_content":"请留意你注释2处的，扩展接收者类型，它也是Flow。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650812314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343240,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1650723752,"is_pvip":false,"replies":[{"id":"125370","content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1650812283,"ip_address":"","comment_id":343240,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1650723752","product_id":100103401,"comment_content":"难道说是因为 unsafeFlow 创建的是一个匿名内部类的实例，匿名内部类的实例是持有外部对象 SafeFlow 的引用？？？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567013,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650812283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":567407,"discussion_content":"那这个调用是编译器转换的吧，这样看确实不直观～～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650901171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":567013,"ip_address":""},"score":567407,"extra":""}]}]},{"had_liked":false,"id":343237,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1650723125,"is_pvip":false,"replies":[{"id":"125369","content":"就是你另一个评论里说的，flow会调用SafeFlow。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1650812278,"ip_address":"","comment_id":343237,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650723125","product_id":100103401,"comment_content":"filter(..）貌似是新建了一个 FLow，flow {... ... ...} 创建  SafeFlow 貌似没用到呀<br><br>老师解答下呀，谢谢。。<br><br>","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567012,"discussion_content":"就是你另一个评论里说的，flow会调用SafeFlow。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650812278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341814,"user_name":"飓风","can_delete":false,"product_type":"c1","uid":1006197,"ip_address":"","ucode":"18D4E8139CD7B7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5a/75/4e0d7419.jpg","comment_is_top":false,"comment_ctime":1649841408,"is_pvip":false,"replies":[{"id":"124956","content":"```<br>Function3&lt;FlowCollector&lt;Any?&gt;, Any?, Continuation&lt;Unit&gt;, Any?&gt;<br>```<br><br>它本质上就是一个函数类型：前面三个是参数类型，最后一个是返回值类型。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649951612,"ip_address":"","comment_id":341814,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1649841408","product_id":100103401,"comment_content":"“它的类型是Function3, Any?, Continuation, Any?&gt;” 这个怎么理解？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563227,"discussion_content":"```\nFunction3&lt;FlowCollector&lt;Any?&gt;, Any?, Continuation&lt;Unit&gt;, Any?&gt;\n```\n\n它本质上就是一个函数类型：前面三个是参数类型，最后一个是返回值类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649951612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1006197,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5a/75/4e0d7419.jpg","nickname":"飓风","note":"","ucode":"18D4E8139CD7B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":563282,"discussion_content":"emit 的函数看起来对应不上，怎么能转换呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649978789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":563227,"ip_address":""},"score":563282,"extra":""},{"author":{"id":1033848,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/78/9b1e4b15.jpg","nickname":"ZircoN","note":"","ucode":"E665DF0DBB7381","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006197,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5a/75/4e0d7419.jpg","nickname":"飓风","note":"","ucode":"18D4E8139CD7B7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564541,"discussion_content":"suspend FlowCollector.func(any: Any?) -&gt; Any? func(FlowCollector, Any?, Continuation)\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650274229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":563282,"ip_address":""},"score":564541,"extra":""}]}]},{"had_liked":false,"id":341507,"user_name":"zyaire","can_delete":false,"product_type":"c1","uid":2883802,"ip_address":"","ucode":"72BF5742A28890","user_header":"https://static001.geekbang.org/account/avatar/00/2c/00/da/790e0a76.jpg","comment_is_top":false,"comment_ctime":1649665847,"is_pvip":true,"replies":[{"id":"124969","content":"如果你在flow当中，通过withContext()改变了它其中的Job层级，Flow就无法正常响应取消了。当然，withContext{}也可能只切换线程池，并不修改协程的父子结构，但Kotlin官方目前的做法是干脆全都禁止，想要切线程，就用统一的flowOn{}。否则，flow源码当中的判断条件会更加的复杂，这是Kotlin官方不愿意看见的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649953728,"ip_address":"","comment_id":341507,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1649665847","product_id":100103401,"comment_content":"老师，“Flow 上游与下游的协程上下文就会不一致，它们整体的结构也会被破坏，从而导致“结构化并发”的特性也被破坏。”这句话不是很能理解，以代码11来说，即使在flow中调用withContext切换了上下文，当外部协程取消时，不也是会响应取消操作吗","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563250,"discussion_content":"如果你在flow当中，通过withContext()改变了它其中的Job层级，Flow就无法正常响应取消了。当然，withContext{}也可能只切换线程池，并不修改协程的父子结构，但Kotlin官方目前的做法是干脆全都禁止，想要切线程，就用统一的flowOn{}。否则，flow源码当中的判断条件会更加的复杂，这是Kotlin官方不愿意看见的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1649953728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2883802,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/00/da/790e0a76.jpg","nickname":"zyaire","note":"","ucode":"72BF5742A28890","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":564381,"discussion_content":"懂了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650242081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":563250,"ip_address":""},"score":564381,"extra":""}]}]},{"had_liked":false,"id":341219,"user_name":"再前进一点","can_delete":false,"product_type":"c1","uid":1015860,"ip_address":"","ucode":"1F4491037FEBA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/34/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1649429404,"is_pvip":false,"replies":[{"id":"124714","content":"请留意它的import，Kotlin源码中经常这么用：<br><br>```<br>import kotlinx.coroutines.flow.unsafeTransform as transform<br>```<br><br>类似的，还有：unsafeFlow as flow。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649432039,"ip_address":"","comment_id":341219,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649429404","product_id":100103401,"comment_content":"同问：为啥transform{}这方法在IDE里点击跳转到的源码是unsafeTransform这个方法呢","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560755,"discussion_content":"请留意它的import，Kotlin源码中经常这么用：\n\n```\nimport kotlinx.coroutines.flow.unsafeTransform as transform\n```\n\n类似的，还有：unsafeFlow as flow。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649432039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341104,"user_name":"ZircoN","can_delete":false,"product_type":"c1","uid":1033848,"ip_address":"","ucode":"E665DF0DBB7381","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c6/78/9b1e4b15.jpg","comment_is_top":false,"comment_ctime":1649348649,"is_pvip":false,"replies":[{"id":"124715","content":"问题1：<br>请留意它的import，Kotlin源码中经常这么用：<br><br>```<br>import kotlinx.coroutines.flow.unsafeTransform as transform<br>```<br><br>类似的，还有：unsafeFlow as flow。<br><br>问题2：<br>我会在完结以后，来一些不定期的加餐，到时候请留意哈~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649432106,"ip_address":"","comment_id":341104,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649348649","product_id":100103401,"comment_content":"1. 为啥transform{}这方法在IDE里点击跳转到的源码是unsafeTransform这个方法呢<br>2. SharedFlow等是否准备讲一下呢","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560756,"discussion_content":"问题1：\n请留意它的import，Kotlin源码中经常这么用：\n\n```\nimport kotlinx.coroutines.flow.unsafeTransform as transform\n```\n\n类似的，还有：unsafeFlow as flow。\n\n问题2：\n我会在完结以后，来一些不定期的加餐，到时候请留意哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649432106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}