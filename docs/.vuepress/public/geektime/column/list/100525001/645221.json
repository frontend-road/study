{"id":645221,"title":"23｜Android系统开发：Android系统开发的版本管理、编译与自动化测试","content":"<p>你好，我是黄俊彬。</p><p>这节课起，我们进入到扩展篇的学习。扩展篇我们将从系统角度，学习定制Android系统的一些常见问题和解决思路。一起了解定制Android系统中常见的一些开发方式、架构问题以及解耦思路。</p><p>从应用到系统开发，代码量从几十万行增长到几千万行，开发框架以及编译环境等与应用开发也不一样。所以如果要学习Android系统开发，我们需要先了解对应的开发框架及工具链。</p><p>今天，我们就来聊聊Android系统开发的版本管理、编译调试以及相关的自动化测试等实践，了解引入这些工具及实践的目的。在实践过程中用好这些工具，会大大提升开发效率。</p><h2>Repo &amp; Gerrit 代码管理</h2><p>我们先来看看代码的管理。由于Android源码的代码量庞大，采用的是多个Git仓库来管理代码。你可以通过 <a href=\"https://android.googlesource.com/?format=HTML\">GoogleSource</a> 查看对应的仓库，大约有3000个仓库。</p><p>那么，假如有一个需求开发涉及到跨多个仓库的修改，我们怎么来维护代码提交以及同步工作呢？</p><p>为了解决这个问题，<strong>官方提供了一个多Git仓代码管理的工具—— </strong><a href=\"https://gerrit.googlesource.com/git-repo/+/refs/heads/master/README.md\">Repo</a>。根据官网的介绍，Repo 不会取代 Git，目的是帮助我们在 Android 环境中更轻松地使用 Git。</p><p>Repo 将多个 Git 项目汇总到一个Manifest文件中，使用Repo命令来并发操作多个Git仓库的代码提交与代码同步很方便。我用表格梳理了一些Repo常用的命令，供你参考。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/93/14/935a266e7e3508231e617209a5b9e614.jpg?wh=3000x1271\" alt=\"\"></p><p>通常使用Repo进行Android 开发的基本工作流程如下图所示，包括创建分支、修改文件、提交暂存、提交更改以及最后上传到审核服务器。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/a0/d5d4efdf0d40d79e41e47aee15cc33a0.jpg?wh=2900x752\" alt=\"\"></p><p>另外，一般情况下，应用开发使用的代码审核工具都是类似于GitLab平台，通过临时分支拉取Merge Request提交代码审核，审核通过后，完成代码入库。针对于多仓库的代码审核，官方提供了另外一个代码审核工具—— <a href=\"https://android-review.googlesource.com/q/status:open+-is:wip\">Gerrit</a>。</p><p>Gerrit&nbsp;是一个基于网页的代码审核系统，适用于使用 Git 的项目。Google原先就是为了管理Android项目而设计了Gerrit。与Merge Request的代码审核差异是，Gerrit采用+1 +2打分的方式来控制代码的合入，你可以结合后面的截图来理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/c4/698f0d4995d1d0124d8e79d262ca1ac4.jpg?wh=2948x796\" alt=\"\" title=\"图片来源：https://android-review.googlesource.com/q/status:open+-is:wip\"></p><p>那么Gerrit是如何来关联多个仓库的代码提交记录呢？这也是和GitLab等工具不同的地方，Gerrit 提供了标准的 “commit-msg” 钩子来生成Change-Id。通过Change-Id，可以关联到多个代码仓库的提交，方便管理跨仓库的代码提交。</p><h2>Soong编译系统</h2><p>接下来，我们来看看Android系统的编译。</p><p>前面从代码仓库管理可以看到，Android系统有近3000多个仓库，如何来管理这么多代码的编译构建以及最终生成img镜像，自然是一个非常复杂的问题。</p><p>为此，Google在 Android 7.0 (Nougat) 中引入了Sooong编译系统，旨在取代 Make。它利用&nbsp;<a href=\"https://github.com/google/kati/blob/master/README.md\">Kati</a>&nbsp;GNU Make 克隆工具和&nbsp;<a href=\"https://ninja-build.org/\">Ninja</a>&nbsp;构建系统组件来加速 Android 的构建。</p><p>我画了一张示意图，帮你梳理Make、Kati、Soong、Ninja等工具的关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/b6/8cdf48e23a014bbff1d75608b1c62db6.jpg?wh=2900x2044\" alt=\"\"></p><p>Android.bp与Ninja的区别在于, Android.bp的目标对象是开发者，开发者基于bp的语法规则来编写脚本， Ninja的目标是成为汇编程序，通过将编译任务并行组织，大大提高了构建速度。</p><p>我们从上图可以看出，Soong通过Android.bp文件来定义和描述一个模块的构建。Android.bp&nbsp;文件很简单，它们不包含任何条件语句，也不包含控制流语句。</p><p>接下来，我以桌面的Android.bp文件为例，带你了解一下基本的bp语法规则，代码是后面这样。</p><pre><code class=\"language-plain\">//模块类型，定义构建产物的类型，例如这里的android_app就是定义生成APK类型\nandroid_app {\n    //应用名称\n    name: \"Launcher3\",\n    //编译所依赖的静态库\n    static_libs: [\n        \"Launcher3CommonDepsLib\",\n    ],\n    //编译源码路径\n    srcs: [\n        \"src/**/*.java\",\n        \"src/**/*.kt\",\n        \"src_shortcuts_overrides/**/*.java\",\n        \"src_shortcuts_overrides/**/*.kt\",\n        \"src_ui_overrides/**/*.java\",\n        \"src_ui_overrides/**/*.kt\",\n        \"ext_tests/src/**/*.java\",\n        \"ext_tests/src/**/*.kt\",\n    ],\n    //编译资源路径\n    resource_dirs: [\n        \"ext_tests/res\",\n    ],\n    //配置混淆\n    optimize: {\n        proguard_flags_files: [\"proguard.flags\"],\n        // Proguard is disable for testing. Derivarive prjects to keep proguard enabled\n        enabled: false,\n    },\n    //配置编译相关的SDK版本号\n    sdk_version: \"current\",\n    min_sdk_version: min_launcher3_sdk_version,\n    target_sdk_version: \"current\",\n    //... ...\n}\n</code></pre><p>那么如何来触发执行编译呢？Soong支持整机编译以及指定模块编译。</p><p>我们先来看看如何完成整机的编译。当你下载完整个AOSP的源码后，进入到AOSP的根目录，输入后面的命令即可初始化编译环境。</p><pre><code class=\"language-plain\">source build/envsetup.sh\n</code></pre><p>接下来，我们需要通过lunch命令选择要构建的目标，lunch是envsetup.sh里定义的一个命令，用来让用户选择编译目标，如下图所示，选择对应的构建目标后，就可以通过m命令触发编译。</p><p><img src=\"https://static001.geekbang.org/resource/image/66/a9/667425d613f9c37446accef7660bc1a9.jpg?wh=2900x2044\" alt=\"\"></p><p>假如我们只要编译桌面这个APP怎么办呢？前面提到Soong也支持编译单个模块，我们可以通过编译单个模块的命令触发编译，代码是后面这样。</p><pre><code class=\"language-plain\">// 进入桌面应用所在的目录\ncd packages/apps/Launcher3\n// 编译当前目录下的模块，不编译依赖模块\nmm\n</code></pre><p>另外，后面这2种方式也可以触发对一个模块的独立编译。</p><ul>\n<li>mma&nbsp;- 构建当前目录中的所有模块及其依赖项。</li>\n<li>mmma&nbsp;- 构建提供的目录中的所有模块及其依赖项。</li>\n</ul><p>特别需要注意的是，<strong>Google计划使用几年的时间将 Android 构建系统迁移到 Bazel。Bazel 将取代 AOSP 中的所有现有构建系统和 build 配置系统（Make、Kati、Soong、基于 Make 的产品配置）。</strong>对于这种明显的技术趋势，如果团队有条件，可以考虑提前做准备。</p><h2>自动化测试</h2><p>最后，我们一起来聊聊Android系统中的自动化测试。大部分的厂商都会基于Android系统扩展定制代码，为了保证厂商扩展代码后不会影响原来系统框架的功能，能够满足兼容性的要求，Google提供了CTS以及VTS测试套件。</p><p><a href=\"https://source.android.google.cn/docs/compatibility/cts\">CTS（Compatibility Test Suite）</a>中文为兼容性测试套件，主要用于测试App和framework的兼容性。<a href=\"https://source.android.com/docs/core/tests/vts\">VTS（Vendor Test Suite）</a>中文为供应商测试套件&nbsp;，主要会自动执行 HAL 和操作系统内核测试，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/71/b14405f428c88f0695a99cf9aa885071.jpg?wh=2900x2044\" alt=\"\"></p><p>以CTS为例，最新的Android 13 CTS的测试模块大概约 1068 个模块，测试用例约 269 万个。从这里可以看出，Google对自动化测试的投入还是非常大的，也侧面反映了自动化测试的重要性。</p><p>CTS的代码在AOSP源码的 <a href=\"https://cs.android.com/android/platform/superproject/+/master:cts/\">cts目录</a>下，如果你感兴趣，可以学习一下官方的测试设计与编写，CTS中的测试主要也是使用Instrumentation以及Junit Test，与前面介绍的应用测试编写类似。</p><p>在应用开发中使用Gradle，我们可以通过testDUT、testCAT等命令来触发测试。前面提到Android源码的编译系统采用的是Soong，那么如果在Android系统中的一个模块添加测试，我们应该怎么来执行测试呢？</p><p>首先，我们可以定义测试模块的android.bp配置文件。这里我们同样以桌面应用为例来看看，bp配置文件代码是后面这样。</p><pre><code class=\"language-plain\">//配置文件模块为androidTest\nandroid_test {\n//测试模块名称\n    name: \"Launcher3Tests\",\n//测试目录\n    srcs: [\n        \":launcher-tests-src\",\n    ],\n//依赖库\n    static_libs: [\"Launcher3TestLib\"],\n    libs: [\n        \"android.test.base\",\n        \"android.test.runner\",\n        \"android.test.mock\",\n    ],\n//测试Launcher3模块\n    instrumentation_for: \"Launcher3\",\n    manifest: \"AndroidManifest.xml\",\n    //... ...\n}\n\n</code></pre><p>接下来，我们就可以编写相应的测试，这与应用的编写方式一致，下面我们看看桌面测试模块里面的一个简单的测试用例。</p><pre><code class=\"language-plain\">@SmallTest\n@RunWith(AndroidJUnit4.class)\npublic class IntSetTest {\n    @Test\n    public void shouldBeEmptyInitially() {\n        IntSet set = new IntSet();\n        assertThat(set.size()).isEqualTo(0);\n    }\n\n    @Test\n    public void oneElementSet() {\n        IntSet set = new IntSet();\n        set.add(2);\n        assertThat(set.size()).isEqualTo(1);\n        assertTrue(set.contains(2));\n        assertFalse(set.contains(1));\n    }\n}\n</code></pre><p>最后要解决的问题就是怎么运行这些测试用例了。Google官方提供了一个运行测试的工具Atest，<a href=\"https://source.android.com/docs/core/tests/development/atest\">Atest</a> 是一个命令行工具，可让用户在本地构建、安装并运行 Android 测试，同时可以大大加快重新运行测试的速度。</p><p>如果我们需要运行整个桌面测试模块的用例，可以直接执行如下命令。</p><pre><code class=\"language-plain\">atest Launcher3Tests\n</code></pre><p>但如果我们只想运行模块内的单个类，可以使用Module:Class的方法，命令如下。</p><pre><code class=\"language-plain\">atest Launcher3Tests：IntSetTest \n</code></pre><p>更多关于Android系统开发的内容，如果你感兴趣可以参考官网的 <a href=\"https://developer.android.com/\">Android开源项目</a>，这个网站类似于应用开发的<a href=\"https://developer.android.com/\">官方网站</a>。</p><h2>总结</h2><p>今天我们一起了解了Android系统开发的一些基础设施工具。与应用开发相比，系统开发更加复杂。</p><p>为了解决多仓库开发的问题，官方提供了Repo及Gerrit工具。Repo帮助我们可以去批量操作多个Git仓库，这大大简化了我们跨仓修改时代码提交同步的工作量。另外，Gerrit工具也通过Change-ID的形式帮我们关联多个仓库的提交记录，方便我们做CodeReview。</p><p>另外，为了管理整机的编译以及独立模块的编译，Android引入了Soong的编译系统，Soong通过Android.bp文件来定义和描述一个模块的构建，最后转换为Ninja文件编译最终的目标产物。</p><p>关于自动化测试，Google官方设计CTS及VTS等兼容性套件，保证了框架的兼容稳定性。针对单个模块的自动化测试，也提供了Atest测试套件，帮助我们快速执行模块内的测试。</p><p>我将应用开发与系统开发使用的工具与方式总结成了一张表，供你复习参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/24/29feb709cefed2a9c199f6a727bac624.jpg?wh=2789x1011\" alt=\"\"></p><h2>思考题</h2><p>感谢你学完了今天的内容，今天的思考题是这样的：Soong的编译系统也支持单独编译一个模块，但是很多厂商依旧会选择将里面的一些模块从bp编译转换为Gradle编译，你觉得这么做的好处是什么呢？</p><p>欢迎你在留言区与我交流讨论，也欢迎你把它分享给你的同事或朋友，我们一起来高效、高质量交付软件！</p>","neighbors":{"left":{"article_title":"22｜度量，我们如何以终为始，以始为终？","id":644380},"right":{"article_title":"24｜“魔改”的Android系统：厂商定制的Android系统为什么也要解耦？","id":645699}},"comments":[{"had_liked":false,"id":371929,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1680526398,"is_pvip":false,"replies":[{"id":135787,"content":"Hi，peter。\nQ1：可以参考一下官网的介绍：https:&#47;&#47;bazel.build&#47;\nQ2：对于Android系统，我觉得有2个方向，一个是从整体的架构去学习，另一方面是深入到某个业务领域，例如多媒体、通信等等。\nQ3：正式版本一般通过应用市场（国内的众多应用市场）发布。一般内测才通过二维码这种体验下载（例如蒲公英 https:&#47;&#47;www.pgyer.com&#47;app&#47;distribution）","user_name":"作者回复","user_name_real":"编辑","uid":1179206,"ctime":1680606515,"ip_address":"广东","comment_id":371929,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100525001,"comment_content":"请教老师几个问题：\nQ1：构建系统Bazel怎么体现？是在AS的新版本中吗？或者在AS的老版本中可以设置Bazel?\nQ2：从求职的角度，安卓系统开发要重点关注哪些方面？对某一个方面，怎么学习更好？\nQ3：安卓APP开发完成后，怎么发布该APP？\n--- 在哪些应用市场发布？\n--- 可以自己放在一个地方，让用户通过二维码扫码来下载吗？","like_count":0,"discussions":[{"author":{"id":1179206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/46/033fccb2.jpg","nickname":"黄俊彬","note":"","ucode":"0DBE0CE4E7CFC9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612343,"discussion_content":"Hi，peter。\nQ1：可以参考一下官网的介绍：https://bazel.build/\nQ2：对于Android系统，我觉得有2个方向，一个是从整体的架构去学习，另一方面是深入到某个业务领域，例如多媒体、通信等等。\nQ3：正式版本一般通过应用市场（国内的众多应用市场）发布。一般内测才通过二维码这种体验下载（例如蒲公英 https://www.pgyer.com/app/distribution）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680606515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}