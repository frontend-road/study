{"id":775876,"title":"13｜类型守护与类型收窄","content":"","comments":[{"had_liked":false,"id":390852,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1716457999,"is_pvip":false,"replies":[{"id":142143,"content":"1、你的示例与你的问题没关系。方便的话，建议你回头将问题单列。\n\n2、Omit&lt;&gt;不能操作string，Omit处理的是接口而不是基础类型。因此事实上你得到的是Omit&lt;string as String, ...&gt;的结果。\n\n3、Omit&lt;&gt;操作string as String的细节要讨论到第19讲，才会籍由keyof操作来说明。——不过本课程中没有讲，只是这个问题涉及到keyof而已。^^.","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1716475501,"ip_address":"江苏","comment_id":390852,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"let o1 = { a: 1, b: &#39;a&#39; };\n\nif (&#39;k&#39; in o1) {\n  &#47;&#47; 此处 o1 的类型 发生了 &amp; 运算\n  &#47;&#47; { a: number; b: string } &amp; { k: unknown }\n  console.log(o1)\n}\n\ntype Word = string &amp; &quot;abc&quot;;\n&#47;&#47; 用户自定义类型守卫: 用于分支流程中\nfunction isString(v: any): v is string {\n  &#47;&#47; v is string 这个部分 是 类型谓词签名(type predicates signatures)\n  &#47;&#47; https:&#47;&#47;www.typescriptlang.org&#47;docs&#47;handbook&#47;2&#47;narrowing.html#using-type-predicates\n  &#47;&#47; 在后续的上下文中 v 的类型会是 typeof v &amp; string\n  return typeof v === &#39;string&#39;;\n}\n&#47;&#47; 用户自定义类型守卫函数: 用于顺序流程中 \nfunction assertIsNumber(v: any):asserts v is number {\n  &#47;&#47; asserts v is number 这个部分 是 断言签名(assertion signatures)\n  &#47;&#47; 在后续的上下文中 v 的类型会是 typeof v &amp; number\n  if (typeof v === &#39;number&#39;) {\n    return void 0;\n  }\n  throw Error(&#39;not a number&#39;)\n}\n\nlet a!: string;\nlet b!: string | number;\n\nb = &quot;a&quot;;\nif (isString(b)) {\n  type BT = typeof b;\n  &#47;&#47;    ^?\n  &#47;&#47; type BT = string\n}\n&#47;&#47; 此时 b 为 string\nassertIsNumber(b);\n&#47;&#47; 断言签名\na = b;\n\n\n&#47;&#47; 可辨识联合类型\ninterface AA {\n  id: &#39;aa&#39;\n  a: string\n}\ninterface BB {\n  id: &quot;bb&quot;\n  b: number\n}\ninterface CC {\n  id: &quot;cc&quot;\n  c: boolean\n}\ntype ABC = AA | BB | CC;\nlet abc!: ABC;\nif (abc.id === &quot;aa&quot;) {\n  type Tep = typeof abc;\n  &#47;&#47;   ^?\n  &#47;&#47; type Tep = AA\n} else if (abc.id === &quot;bb&quot;) {\n  type Tep = typeof abc;\n  &#47;&#47;   ^?\n  &#47;&#47; type Tep = BB\n} else {\n   type Tep = typeof abc;\n   &#47;&#47;   ^?\n   &#47;&#47; type Tep = CC\n}\n\n&#47;&#47; 疑问: type MyKey = Omit&lt;string, &#39;abc&#39;&gt;; 这个类型收窄的 结果为什么会是 string; 是因为 string 集合 和 移除 abc 的 string 集合 在类型系统中基本没有区别吗?","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645646,"discussion_content":"1、你的示例与你的问题没关系。方便的话，建议你回头将问题单列。\n\n2、Omit&lt;&gt;不能操作string，Omit处理的是接口而不是基础类型。因此事实上你得到的是Omit&lt;string as String, ...&gt;的结果。\n\n3、Omit&lt;&gt;操作string as String的细节要讨论到第19讲，才会籍由keyof操作来说明。——不过本课程中没有讲，只是这个问题涉及到keyof而已。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716475502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}