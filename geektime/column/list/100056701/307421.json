{"id":307421,"title":"36 | Redis支撑秒杀场景的关键技术和实践都有哪些？","content":"<p>你好，我是蒋德钧。</p><p>秒杀是一个非常典型的活动场景，比如，在双11、618等电商促销活动中，都会有秒杀场景。秒杀场景的业务特点是<strong>限时限量</strong>，业务系统要处理瞬时的大量高并发请求，而Redis就经常被用来支撑秒杀活动。</p><p>不过，秒杀场景包含了多个环节，可以分成秒杀前、秒杀中和秒杀后三个阶段，每个阶段的请求处理需求并不相同，Redis并不能支撑秒杀场景的每一个环节。</p><p>那么，Redis具体是在秒杀场景的哪个环节起到支撑作用的呢？又是如何支持的呢？清楚了这个问题，我们才能知道在秒杀场景中，如何使用Redis来支撑高并发压力，并且做好秒杀场景的应对方案。</p><p>接下来，我们先来了解下秒杀场景的负载特征。</p><h2>秒杀场景的负载特征对支撑系统的要求</h2><p>秒杀活动售卖的商品通常价格非常优惠，会吸引大量用户进行抢购。但是，商品库存量却远远小于购买该商品的用户数，而且会限定用户只能在一定的时间段内购买。这就给秒杀系统带来两个明显的负载特征，相应的，也对支撑系统提出了要求，我们来分析下。</p><p><strong>第一个特征是瞬时并发访问量非常高</strong>。</p><p>一般数据库每秒只能支撑千级别的并发请求，而Redis的并发处理能力（每秒处理请求数）能达到万级别，甚至更高。所以，<strong>当有大量并发请求涌入秒杀系统时，我们就需要使用Redis先拦截大部分请求，避免大量请求直接发送给数据库，把数据库压垮</strong>。</p><!-- [[[read_end]]] --><p><strong>第二个特征是读多写少，而且读操作是简单的查询操作</strong>。</p><p>在秒杀场景下，用户需要先查验商品是否还有库存（也就是根据商品ID查询该商品的库存还有多少），只有库存有余量时，秒杀系统才能进行库存扣减和下单操作。</p><p>库存查验操作是典型的键值对查询，而Redis对键值对查询的高效支持，正好和这个操作的要求相匹配。</p><p>不过，秒杀活动中只有少部分用户能成功下单，所以，商品库存查询操作（读操作）要远多于库存扣减和下单操作（写操作）。</p><p>当然，实际秒杀场景通常有多个环节，刚才介绍的用户查验库存只是其中的一个环节。那么，Redis具体可以在整个秒杀场景中哪些环节发挥作用呢？这就要说到秒杀活动的整体流程了，我们来分析下。</p><h2>Redis可以在秒杀场景的哪些环节发挥作用？</h2><p>我们一般可以把秒杀活动分成三个阶段。在每一个阶段，Redis所发挥的作用也不一样。</p><p>第一阶段是秒杀活动前。</p><p>在这个阶段，用户会不断刷新商品详情页，这会导致详情页的瞬时请求量剧增。这个阶段的应对方案，一般是尽量<strong>把商品详情页的页面元素静态化，然后使用CDN或是浏览器把这些静态化的元素缓存起来</strong>。这样一来，秒杀前的大量请求可以直接由CDN或是浏览器缓存服务，不会到达服务器端了，这就减轻了服务器端的压力。</p><p>在这个阶段，有CDN和浏览器缓存服务请求就足够了，我们还不需要使用Redis。</p><p>第二阶段是秒杀活动开始。</p><p>此时，大量用户点击商品详情页上的秒杀按钮，会产生大量的并发请求查询库存。一旦某个请求查询到有库存，紧接着系统就会进行库存扣减。然后，系统会生成实际订单，并进行后续处理，例如订单支付和物流服务。如果请求查不到库存，就会返回。用户通常会继续点击秒杀按钮，继续查询库存。</p><p>简单来说，这个阶段的操作就是三个：库存查验、库存扣减和订单处理。因为每个秒杀请求都会查询库存，而请求只有查到有库存余量后，后续的库存扣减和订单处理才会被执行。所以，这个阶段中最大的并发压力都在库存查验操作上。</p><p>为了支撑大量高并发的库存查验请求，我们需要在这个环节使用Redis保存库存量，这样一来，请求可以直接从Redis中读取库存并进行查验。</p><p>那么，库存扣减和订单处理是否都可以交给后端的数据库来执行呢?</p><p>其实，订单处理可以在数据库中执行，但库存扣减操作，不能交给后端数据库处理。</p><p>在数据库中处理订单的原因比较简单，我先说下。</p><p>订单处理会涉及支付、商品出库、物流等多个关联操作，这些操作本身涉及数据库中的多张数据表，要保证处理的事务性，需要在数据库中完成。而且，订单处理时的请求压力已经不大了，数据库可以支撑这些订单处理请求。</p><p>那为啥库存扣减操作不能在数据库执行呢？这是因为，一旦请求查到有库存，就意味着发送该请求的用户获得了商品的购买资格，用户就会下单了。同时，商品的库存余量也需要减少一个。如果我们把库存扣减的操作放到数据库执行，会带来两个问题。</p><ol>\n<li><strong>额外的开销</strong>。Redis中保存了库存量，而库存量的最新值又是数据库在维护，所以数据库更新后，还需要和Redis进行同步，这个过程增加了额外的操作逻辑，也带来了额外的开销。</li>\n<li><strong>下单量超过实际库存量，出现超售</strong>。由于数据库的处理速度较慢，不能及时更新库存余量，这就会导致大量库存查验的请求读取到旧的库存值，并进行下单。此时，就会出现下单数量大于实际的库存量，导致出现超售，这就不符合业务层的要求了。</li>\n</ol><p>所以，我们就需要直接在Redis中进行库存扣减。具体的操作是，当库存查验完成后，一旦库存有余量，我们就立即在Redis中扣减库存。而且，为了避免请求查询到旧的库存值，库存查验和库存扣减这两个操作需要保证原子性。</p><p>第三阶段就是秒杀活动结束后。</p><p>在这个阶段，可能还会有部分用户刷新商品详情页，尝试等待有其他用户退单。而已经成功下单的用户会刷新订单详情，跟踪订单的进展。不过，这个阶段中的用户请求量已经下降很多了，服务器端一般都能支撑，我们就不重点讨论了。</p><p>好了，我们先来总结下秒杀场景对Redis的需求。</p><p>秒杀场景分成秒杀前、秒杀中和秒杀后三个阶段。秒杀开始前后，高并发压力没有那么大，我们不需要使用Redis，但在秒杀进行中，需要查验和扣减商品库存，库存查验面临大量的高并发请求，而库存扣减又需要和库存查验一起执行，以保证原子性。这就是秒杀对Redis的需求。</p><p>下图显示了在秒杀场景中需要Redis参与的两个环节：</p><p><img src=\"https://static001.geekbang.org/resource/image/7c/1b/7c3e5def912d7c8c45bca00f955d751b.jpg?wh=2176*1582\" alt=\"\"></p><p>了解需求后，我们使用Redis来支撑秒杀场景的方法就比较清晰了。接下来，我向你介绍两种方法。</p><h2>Redis的哪些方法可以支撑秒杀场景？</h2><p>秒杀场景对Redis操作的根本要求有两个。</p><ol>\n<li><strong>支持高并发</strong><strong>。</strong>这个很简单，Redis本身高速处理请求的特性就可以支持高并发。而且，如果有多个秒杀商品，我们也可以使用切片集群，用不同的实例保存不同商品的库存，这样就避免，使用单个实例导致所有的秒杀请求都集中在一个实例上的问题了。不过，需要注意的是，当使用切片集群时，我们要先用CRC算法计算不同秒杀商品key对应的Slot，然后，我们在分配Slot和实例对应关系时，才能把不同秒杀商品对应的Slot分配到不同实例上保存。</li>\n<li><strong>保证库存查验和库存扣减原子性执行</strong>。针对这条要求，我们就可以使用Redis的原子操作或是分布式锁这两个功能特性来支撑了。</li>\n</ol><p>我们先来看下Redis是如何基于原子操作来支撑秒杀场景的。</p><h3>基于原子操作支撑秒杀场景</h3><p>在秒杀场景中，一个商品的库存对应了两个信息，分别是总库存量和已秒杀量。这种数据模型正好是一个key（商品ID）对应了两个属性（总库存量和已秒杀量），所以，我们可以使用一个Hash类型的键值对来保存库存的这两个信息，如下所示：</p><pre><code>key: itemID\nvalue: {total: N, ordered: M}\n</code></pre><p>其中，itemID是商品的编号，total是总库存量，ordered是已秒杀量。</p><p>因为库存查验和库存扣减这两个操作要保证一起执行，<strong>一个直接的方法就是使用Redis的原子操作</strong>。</p><p>我们在<a href=\"https://time.geekbang.org/column/article/299806\">第29讲</a>中学习过，原子操作可以是Redis自身提供的原子命令，也可以是Lua脚本。因为库存查验和库存扣减是两个操作，无法用一条命令来完成，所以，我们就需要使用Lua脚本原子性地执行这两个操作。</p><p>那怎么在Lua脚本中实现这两个操作呢？我给你提供一段Lua脚本写的伪代码，它显示了这两个操作的实现。</p><pre><code>#获取商品库存信息            \nlocal counts = redis.call(&quot;HMGET&quot;, KEYS[1], &quot;total&quot;, &quot;ordered&quot;);\n#将总库存转换为数值\nlocal total = tonumber(counts[1])\n#将已被秒杀的库存转换为数值\nlocal ordered = tonumber(counts[2])  \n#如果当前请求的库存量加上已被秒杀的库存量仍然小于总库存量，就可以更新库存         \nif ordered + k &lt;= total then\n    #更新已秒杀的库存量\n    redis.call(&quot;HINCRBY&quot;,KEYS[1],&quot;ordered&quot;,k)                              return k;  \nend               \nreturn 0\n</code></pre><p>有了Lua脚本后，我们就可以在Redis客户端，使用EVAL命令来执行这个脚本了。</p><p>最后，客户端会根据脚本的返回值，来确定秒杀是成功还是失败了。如果返回值是k，就是成功了；如果是0，就是失败。</p><p>到这里，我们学习了如何使用原子性的Lua脚本来实现库存查验和库存扣减。其实，要想保证库存查验和扣减这两个操作的原子性，我们还有另一种方法，就是<strong>使用分布式锁来保证多个客户端能互斥执行这两个操作</strong>。接下来，我们就来看下如何使用分布式锁来支撑秒杀场景。</p><h3>基于分布式锁来支撑秒杀场景</h3><p><strong>使用分布式锁来支撑秒杀场景的具体做法是，先让客户端向Redis申请分布式锁，只有拿到锁的客户端才能执行库存查验和库存扣减</strong>。这样一来，大量的秒杀请求就会在争夺分布式锁时被过滤掉。而且，库存查验和扣减也不用使用原子操作了，因为多个并发客户端只有一个客户端能够拿到锁，已经保证了客户端并发访问的互斥性。</p><p>你可以看下下面的伪代码，它显示了使用分布式锁来执行库存查验和扣减的过程。</p><pre><code>//使用商品ID作为key\nkey = itemID\n//使用客户端唯一标识作为value\nval = clientUniqueID\n//申请分布式锁，Timeout是超时时间\nlock =acquireLock(key, val, Timeout)\n//当拿到锁后，才能进行库存查验和扣减\nif(lock == True) {\n   //库存查验和扣减\n   availStock = DECR(key, k)\n   //库存已经扣减完了，释放锁，返回秒杀失败\n   if (availStock &lt; 0) {\n      releaseLock(key, val)\n      return error\n   }\n   //库存扣减成功，释放锁\n   else{\n     releaseLock(key, val)\n     //订单处理\n   }\n}\n//没有拿到锁，直接返回\nelse\n   return\n</code></pre><p>需要提醒你的是，在使用分布式锁时，客户端需要先向Redis请求锁，只有请求到了锁，才能进行库存查验等操作，这样一来，客户端在争抢分布式锁时，大部分秒杀请求本身就会因为抢不到锁而被拦截。</p><p>所以，我给你一个小建议，<strong>我们可以使用切片集群中的不同实例来分别保存分布式锁和商品库存信息</strong>。使用这种保存方式后，秒杀请求会首先访问保存分布式锁的实例。如果客户端没有拿到锁，这些客户端就不会查询商品库存，这就可以减轻保存库存信息的实例的压力了。</p><h2>小结</h2><p>这节课，我们学习了Redis在秒杀场景中的具体应用。秒杀场景有2个负载特征，分别是瞬时高并发请求和读多写少。Redis良好的高并发处理能力，以及高效的键值对读写特性，正好可以满足秒杀场景的需求。</p><p>在秒杀场景中，我们可以通过前端CDN和浏览器缓存拦截大量秒杀前的请求。在实际秒杀活动进行时，库存查验和库存扣减是承受巨大并发请求压力的两个操作，同时，这两个操作的执行需要保证原子性。Redis的原子操作、分布式锁这两个功能特性可以有效地来支撑秒杀场景的需求。</p><p>当然，对于秒杀场景来说，只用Redis是不够的。秒杀系统是一个系统性工程，Redis实现了对库存查验和扣减这个环节的支撑，除此之外，还有4个环节需要我们处理好。</p><ol>\n<li><strong>前端静态页面的设计</strong>。秒杀页面上能静态化处理的页面元素，我们都要尽量静态化，这样可以充分利用CDN或浏览器缓存服务秒杀开始前的请求。</li>\n<li><strong>请求拦截和流控</strong>。在秒杀系统的接入层，对恶意请求进行拦截，避免对系统的恶意攻击，例如使用黑名单禁止恶意IP进行访问。如果Redis实例的访问压力过大，为了避免实例崩溃，我们也需要在接入层进行限流，控制进入秒杀系统的请求数量。</li>\n<li><strong>库存信息过期时间处理</strong>。Redis中保存的库存信息其实是数据库的缓存，为了避免缓存击穿问题，我们不要给库存信息设置过期时间。</li>\n<li><strong>数据库订单异常处理</strong>。如果数据库没能成功处理订单，可以增加订单重试功能，保证订单最终能被成功处理。</li>\n</ol><p>最后，我也再给你一个小建议：秒杀活动带来的请求流量巨大，我们需要把秒杀商品的库存信息用单独的实例保存，而不要和日常业务系统的数据保存在同一个实例上，这样可以避免干扰业务系统的正常运行。</p><h2>每课一问</h2><p>按照惯例，我给你提个小问题，假设一个商品的库存量是800，我们使用一个包含了4个实例的切片集群来服务秒杀请求。我们让每个实例各自维护库存量200，然后，客户端的秒杀请求可以分发到不同的实例上进行处理，你觉得这是一个好方法吗？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事。我们下节课见。</p>","comments":[{"had_liked":false,"id":261107,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1605198824,"is_pvip":true,"discussion_count":22,"race_medal":0,"score":"809059050472","product_id":100056701,"comment_content":"使用多个实例的切片集群来分担秒杀请求，是否是一个好方法？<br><br>使用切片集群分担秒杀请求，可以降低每个实例的请求压力，前提是秒杀请求可以平均打到每个实例上，否则会出现秒杀请求倾斜的情况，反而会增加某个实例的压力，而且会导致商品没有全部卖出的情况。<br><br>但用切片集群分别存储库存信息，缺点是如果需要向用户展示剩余库存，要分别查询多个切片，最后聚合结果后返回给客户端。这种情况下，建议不展示剩余库存信息，直接针对秒杀请求返回是否秒杀成功即可。<br><br>秒杀系统最重要的是，把大部分请求拦截在最前面，只让很少请求能够真正进入到后端系统，降低后端服务的压力，常见的方案包括：页面静态化（推送到CDN）、网关恶意请求拦截、请求分段放行、缓存校验和扣减库存、消息队列处理订单。<br><br>另外，为了不影响其他业务系统，秒杀系统最好和业务系统隔离，主要包括应用隔离、部署隔离、数据存储隔离。","like_count":189,"discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338185,"discussion_content":"我觉得其实可以换个思路，redis 做一个限流 或者桶令牌，允许通过或者 抢道令牌的 进入 db 操作库存的操作，db成功以后 才会 认为成功。或者  不是db  而是发送mq消息，其他服务消费 做库存删减 下单 操作，成功，反推到对应前端消息说抢到了。。而不是秒杀单纯的依赖缓存。本身 如果以db 作为底层校验手段，能到db的并发基本没有，就是秒杀的商品数量，最多1.1 1.2倍而已，基本可以认为没有并发。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1609209923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1253597,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/dd/82d8eff2.jpg","nickname":"Mine","note":"","ucode":"85C3A3117FD9CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351218,"discussion_content":" 你这个思路还不如直接用redis缓存库存进行扣减（其实也可以看成限流了，库存扣减完就拒绝请求返回提示信息）。你现在的做法，mq异步处理后，订单，库存扣减都在下游操作，上游无法感知订单库存数，导致很多无用的消息（库存没了，无法下单）堆积至mq。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1614178684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338185,"ip_address":""},"score":351218,"extra":""},{"author":{"id":1022757,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/25/abb7bfe3.jpg","nickname":"淡淡的忧伤","note":"","ucode":"D4911BEB2F8434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352043,"discussion_content":"你这也就是小酒量时候，跑跑还可以满足业务功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614581838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338185,"ip_address":""},"score":352043,"extra":""},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1253597,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/dd/82d8eff2.jpg","nickname":"Mine","note":"","ucode":"85C3A3117FD9CB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354394,"discussion_content":"因为你直接做扣减是需要考虑上述的并发问题，而并发量流量桶本身只需要考虑放不放行的问题，考虑的问题本身就不一样吧？再一个本身到下游的量级非常小，基本只有实际库存量级的1.几倍，下游服务会卡顿吗？只要消费够快，可以反过来主动通知前端秒杀完了。这样驱动是由最终的订单等下游驱动的反而更安全，也不用考虑并发导致的卖多了买少的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615285936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351218,"ip_address":""},"score":354394,"extra":""}]},{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337088,"discussion_content":"这样其实会有一个问题。就是比如 A B C D 四台机器，每台机器个存200的量，但是在某个时间点，A机器的数量消耗的比较快，很快就完了；B机器的数量消耗的比较慢，还有剩余。那么一个用户经过hash之后如果只能请求到A机器，那这样就对这个用户不公平。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608794077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1022757,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/25/abb7bfe3.jpg","nickname":"淡淡的忧伤","note":"","ucode":"D4911BEB2F8434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352044,"discussion_content":"你只考虑扣减，不考虑释放下单失败加库存了吗😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614581901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337088,"ip_address":""},"score":352044,"extra":""}]},{"author":{"id":1107786,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e7/4a/4dfb565a.jpg","nickname":"凌霄","note":"","ucode":"19C4BFB0298276","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379130,"discussion_content":"专栏的老师看来工业级系统做的少了，很多优惠券秒杀可以这么实现，放到不同的实例打散处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623718211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022757,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/25/abb7bfe3.jpg","nickname":"淡淡的忧伤","note":"","ucode":"D4911BEB2F8434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352041,"discussion_content":"兄弟，拼多多，美团，橙心那种动不动万人的团购活动。你试试数据库扣库存。\n\nredis扣库存+事务消息发送成功。我理解就是秒杀系统设计里面的所说的数据隔离的实现。到这步已经认为库存扣减这个原子业务处理完了。\n后续的落库以及其他的异常处理和秒杀无关了，事务消息就要做到保证必须成功。最后实在没有办法成功时候，就只能回滚库存了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614581719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1602239,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyobcyicicCQoldZofsS36xrjA2R2hk2F89pu1hCqwjlRaRG4xKkgCicZibEVdOwpfN5rWjEchrsxicSQ/132","nickname":"Geek_e8d55e","note":"","ucode":"5F13626B0E1E45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338462,"discussion_content":"各位大佬，如果redis宕机的情况应该如何处理呢？如果使用主从的话，主从一致性感觉没法保证啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609295765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1602239,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyobcyicicCQoldZofsS36xrjA2R2hk2F89pu1hCqwjlRaRG4xKkgCicZibEVdOwpfN5rWjEchrsxicSQ/132","nickname":"Geek_e8d55e","note":"","ucode":"5F13626B0E1E45","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338673,"discussion_content":"主从本身不保证强一致。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609336029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338462,"ip_address":""},"score":338673,"extra":""},{"author":{"id":1879262,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ac/de/68f35320.jpg","nickname":"小来子","note":"","ucode":"4EDAF31E43B211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":350224,"discussion_content":"那MySQL呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613750765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338673,"ip_address":""},"score":350224,"extra":""}]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338186,"discussion_content":"所以为啥非要纠结一定要在redis做  库存类操作来？ 你库存删减完了，还需要订单 类操作来，又是2部动作，最后继续分布式的动作。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609209995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079898,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/5a/4dfb21f7.jpg","nickname":"毕成功 Antony","note":"","ucode":"32219043046F62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327355,"discussion_content":"这种分散的后端节点，剩余库存总数不显示也是业务上不太能接受的，但是有点延迟倒是可以。\n\n所以可以做个1秒1次的定时任务统计一下各节点的剩余总和，把结果缓存起来给前端读取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605799910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1022757,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/25/abb7bfe3.jpg","nickname":"淡淡的忧伤","note":"","ucode":"D4911BEB2F8434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079898,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/5a/4dfb21f7.jpg","nickname":"毕成功 Antony","note":"","ucode":"32219043046F62","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352046,"discussion_content":"这个不是一点点延迟的问题。分片越多，会导致接口rt耗时越来越大。大酒量时候会系统不稳定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614581992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327355,"ip_address":""},"score":352046,"extra":""},{"author":{"id":1079898,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/5a/4dfb21f7.jpg","nickname":"毕成功 Antony","note":"","ucode":"32219043046F62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1022757,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/25/abb7bfe3.jpg","nickname":"淡淡的忧伤","note":"","ucode":"D4911BEB2F8434","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354833,"discussion_content":"一个线程读取数据到缓存，前端查询直接读缓存。分片数据不论如何在业务上都不可能实时扫描全部分表的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615347420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352046,"ip_address":""},"score":354833,"extra":""}]},{"author":{"id":1079898,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/5a/4dfb21f7.jpg","nickname":"毕成功 Antony","note":"","ucode":"32219043046F62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327354,"discussion_content":"请求平均分流到后端这个思路不起关键作用，因为用户买不买的行为不可控，可能仅下单不支付。\n\n秒杀场景可以粗暴一点，依赖用户的重试，短时间抢购完并不能明显感知到差异。\n\n如果商品卖不快，遇到有节点售罄可以让分流轮训重试，虽然这种会让一次请求的处理扩散，但售罄基本都是读多，也算是度过了写高峰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605799709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1022757,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/25/abb7bfe3.jpg","nickname":"淡淡的忧伤","note":"","ucode":"D4911BEB2F8434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079898,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/5a/4dfb21f7.jpg","nickname":"毕成功 Antony","note":"","ucode":"32219043046F62","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352047,"discussion_content":"用到分片时候，已经说明是单节点的上限了。如果用轮训方式来，汇总数据。无畏的增加redis的压力和系统响应时间。\n\n极端的例子。1000库存，做了20个分片，并剩余1个库存，恰好需要轮训20次。这个时候rt耗时可能不只是增加20个了。\n\n分片集群。我们应该避免这样的merge行为的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1614582353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327354,"ip_address":""},"score":352047,"extra":""}]},{"author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325433,"discussion_content":"隔壁讲分布式缓存的视频课说的就是这种每个实例放置部分库存来分流，然后请求查所有实例直到能成功扣库存或者全部没有库存。想问下班长你对用数据库代替redis解决库存热点更新问题有了解吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605316622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261421,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1605330130,"is_pvip":false,"discussion_count":36,"race_medal":0,"score":"91799643346","product_id":100056701,"comment_content":"老师好，想问下，用redis扣库存直接用HINCRBY已秒杀库存量，判断返回值&gt;=总库存就是没库存，小于总库存就是扣减库存成功可以购买，这样判断有什么问题么？为什么要引入lua脚本来增加复杂度呢？","like_count":22,"discussions":[{"author":{"id":1240624,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/30/cfdd1b86.jpg","nickname":"刘浩","note":"","ucode":"81F5D6E62751C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329431,"discussion_content":"如果100人同时竞争，会造成HINCRBY已经操作了100次，虽然只有一个人能拿到，但是确实执行了，实际数据已经超出了。这时候如果有人取消订单，数据还得还回去，这时候你不好办啦","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1606382872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1287774,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a6/5e/b05254a6.jpg","nickname":"Mhy","note":"","ucode":"DE19BCAD1F856E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1240624,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/30/cfdd1b86.jpg","nickname":"刘浩","note":"","ucode":"81F5D6E62751C6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541330,"discussion_content":"同时100个人竞争，假如redis库存为99，那么一定会有一个人是100，其余99个人是大于100的，只要有线程拿到的数据大于100，那么就不进行下单操作，将库存进行回补（HINCRBY -1），那么最后库存的值一定也是100，不多会也不会少，如果说用lua的好处那就是只要有线程发现库存已经变成100了，那么就不会出现暂时101的情况，连HINCRBY的操作都省去了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640333251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329431,"ip_address":""},"score":541330,"extra":""}]},{"author":{"id":1144333,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/0d/781aa509.jpg","nickname":"路飞桑","note":"","ucode":"2EA3B61395FBA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327184,"discussion_content":"我的理解是：直接使用HINCRBY，通过返回值判断是否有库存，如果秒杀的场景不限制用户的秒杀数量或者用户的秒杀数量可以大于1，会出现实际有库存但是不能下单的问题，举例来说是如果库存是8，当前剩余库存7，A用户要下单2个，通过HINCRBY命令将已秒杀量变为9，发现超过库存下单失败，如果这个时候不恢复已秒杀量，其他用户就不能下单成功了。如果在恢复已秒杀量，这前后两个操作又会有原子性问题。还有就是感觉如果使用这种方式在秒杀结束后，查看库存量直接通过redis的数据获取的话库存量计算之后是负数，还有通过查询实际订单才能知道有没有超卖吧。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1605761838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1022757,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/25/abb7bfe3.jpg","nickname":"淡淡的忧伤","note":"","ucode":"D4911BEB2F8434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144333,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/0d/781aa509.jpg","nickname":"路飞桑","note":"","ucode":"2EA3B61395FBA7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352049,"discussion_content":"负数，做回滚就好了，也包在原子操作里面。不影响下一个人购买的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614582693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327184,"ip_address":""},"score":352049,"extra":""}]},{"author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370626,"discussion_content":"这个思路完全满足需求。我们这样做过。大家关心的恢复库存问题。库存 100。完全可以放 200 个人进来。有数据保证最终不会超卖。至于 lua 脚本。性能肯定是差于直接 incr/decr 的","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1619486187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1069583,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8BIG7fdqVH3xs2o7yDGpbr9FuT93FVN98CC4cYdojcJamJrPS6q8ObOFQwDgbxygiaYaWnuMk0cw/132","nickname":"Kkkoko","note":"","ucode":"C36729C4659F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":376889,"discussion_content":"我觉得也是，秒杀场景的用户瞬间进来的量，肯定是远远大于库存的。我就放一小部分人进来，慢慢处理就OK了。 其他的其实都是炮灰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622391918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":370626,"ip_address":""},"score":376889,"extra":""}]},{"author":{"id":1035257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","nickname":"Mr.蜜","note":"","ucode":"C911B81198B3F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332388,"discussion_content":"直接用hincrby风险很大，但都是出在边际条件上，所以在前道关卡的判断就至关重要。但如果用lua脚本，就能把前道关卡的判断和是否可以扣减库存封装成一个原子操作，提高系统可靠性。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1607177756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","nickname":"neohope","note":"","ucode":"C0268F6E7E2B6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351137,"discussion_content":"在调用hincrby前，需要判断是否还有库存，无法正确处理并发。操作步骤简化为：\n1、查询，2、判断库存大于0，3、调用hincrby修改库存\n就是在1与3之间，无法阻止多个客户端同时进入这个区间，也就无法阻止超卖。\n用Lua的话，整个脚本是一次性执行完毕的，避免了这个问题。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1614162059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1043475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","nickname":"neohope","note":"","ucode":"C0268F6E7E2B6E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370619,"discussion_content":"为何要分开步骤 1 和 3 呢，incr/decr 本身就有返回值。请求进来直接 incr。检查返回值就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619485818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351137,"ip_address":""},"score":370619,"extra":""},{"author":{"id":2107466,"avatar":"https://static001.geekbang.org/account/avatar/00/20/28/4a/36d07533.jpg","nickname":"crossover  of   AI","note":"","ucode":"8EE3289947808F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":554891,"discussion_content":"自己做个实验就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646652999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":370619,"ip_address":""},"score":554891,"extra":""},{"author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2107466,"avatar":"https://static001.geekbang.org/account/avatar/00/20/28/4a/36d07533.jpg","nickname":"crossover  of   AI","note":"","ucode":"8EE3289947808F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555003,"discussion_content":"你怎么知道我没做过，我意思没必要用 lua 脚本","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646716009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":554891,"ip_address":""},"score":555003,"extra":""}]},{"author":{"id":1112311,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/f7/2ef31d06.jpg","nickname":"灭龙君","note":"","ucode":"99832A9896FCC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340175,"discussion_content":"典型的i++并发问题啊","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1609922124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112311,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/f7/2ef31d06.jpg","nickname":"灭龙君","note":"","ucode":"99832A9896FCC9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340295,"discussion_content":"redis自增操作是原子的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609945490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340175,"ip_address":""},"score":340295,"extra":""},{"author":{"id":1022757,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/25/abb7bfe3.jpg","nickname":"淡淡的忧伤","note":"","ucode":"D4911BEB2F8434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352048,"discussion_content":"int类型数字，赋值也是原子。细品","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614582529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340295,"ip_address":""},"score":352048,"extra":""},{"author":{"id":1792875,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYLPAlGUWic46Vr5WCsSYuqgQGvgEBnicylYPcgl0Tn57RF8InuxMZDvvt0pFiaIJjJTsOvC1Ed5ZLA/132","nickname":"雨潇","note":"","ucode":"735B7E796E84EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112311,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/f7/2ef31d06.jpg","nickname":"灭龙君","note":"","ucode":"99832A9896FCC9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387351,"discussion_content":"不存在，incr和decr都是原子操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628131760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340175,"ip_address":""},"score":387351,"extra":""}]},{"author":{"id":1565219,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJSlGOyeng3NGwI3fff0PEicP83RL3rGnhghKRU3Md4WXCG6gxjXsicRtcfbQwnKUBJ68I8ibRVpq6Lw/132","nickname":"Geek_马官人","note":"","ucode":"A5D8EA65195413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547553,"discussion_content":"我觉得没问题，incr本来就是redis保证原子性的命令，而且还会返回操作后最新的值，完全可以保证库存的减少可靠，唯一讨论的点就在于incr会一直自增或自减（看你设计是0到100还是100到0），如果请求量大，退货或者取消订单回滚了1个也回不到可秒杀的状态，这个完全可以用业务去避免，一段时间后，通过补货的方式再次统一上架处理，脚本的好处就是可以写逻辑，效率略低，主要看脚本复杂度，incr就是redis原生命令，简单，效率高，各有优缺点，如果对退货补货这种及时性不敏感，我觉得incr也是可以实现的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642747302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102291,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/d3/827cdfd5.jpg","nickname":"Kai","note":"","ucode":"BE6985A02BEA7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360686,"discussion_content":"我的解法：用String数据结构存储库存，针对用户抢到一个，就incr(key, -1)，当返回值小于0时，返回已售罄。针对运营人员加库存，就increase(key, 1）。理由：incr是原子操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616505292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2086960,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d8/30/840b64fa.jpg","nickname":"Frank木风","note":"","ucode":"8DAA325F19E00E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327131,"discussion_content":"没看出有什么问题，感觉应该也可以的。不过秒杀一般还是消息队列到数据库。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605752699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2342029,"avatar":"","nickname":"Geek_f6a7c7","note":"","ucode":"3927E94C25A552","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2086960,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d8/30/840b64fa.jpg","nickname":"Frank木风","note":"","ucode":"8DAA325F19E00E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332066,"discussion_content":"有问题的，如果incrby数量没有超过总库存数还是可以，超过了总库存数就有问题。假设总库存是100，incrby到了101，超过总库存数肯定是没法下单，如果这个时候有人退单，库存数回滚还是100，还是没法下单。当然也可以在incrby超过了100的时候代码中手动回滚库存数，但是这个手动回滚又是一个原子操作，回滚之前又有人抢购下单incrby到102了，这就陷入高并发某短时间内incyby的数量超过总库存数的僵局","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1607053939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327131,"ip_address":""},"score":332066,"extra":""},{"author":{"id":1022757,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/25/abb7bfe3.jpg","nickname":"淡淡的忧伤","note":"","ucode":"D4911BEB2F8434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2342029,"avatar":"","nickname":"Geek_f6a7c7","note":"","ucode":"3927E94C25A552","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352050,"discussion_content":"101做原子回滚，就可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614582770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332066,"ip_address":""},"score":352050,"extra":""},{"author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2342029,"avatar":"","nickname":"Geek_f6a7c7","note":"","ucode":"3927E94C25A552","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370622,"discussion_content":"很简单嘛，我们换个思路。可以略微多放进来一些人。还有 db 层来保证数量。其次，秒杀场景，基本不可能有人退单。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619486012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332066,"ip_address":""},"score":370622,"extra":""}]},{"author":{"id":1943690,"avatar":"","nickname":"Geek_1b42a9","note":"","ucode":"79AF29855A53D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376653,"discussion_content":"老师给的通用的吧。要是像你这么个方式提出疑问的就更多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622257537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372287,"discussion_content":"没有人认为incr之后的比较操作存在问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620271368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1792875,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYLPAlGUWic46Vr5WCsSYuqgQGvgEBnicylYPcgl0Tn57RF8InuxMZDvvt0pFiaIJjJTsOvC1Ed5ZLA/132","nickname":"雨潇","note":"","ucode":"735B7E796E84EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387348,"discussion_content":"个人认为不存在，不管是incr还是decr，返回给你的都是Redis服务端处理后的数据，其他人操作的时候，都是基于Redis服务器中最新的值操作，所以没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628131680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372287,"ip_address":""},"score":387348,"extra":""}]},{"author":{"id":1023101,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","nickname":"study的程序员","note":"","ucode":"E5AE9037D24429","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371794,"discussion_content":"qps足够大，过一会就是一个bigkey","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619969358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1801058,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7b/62/ec94cee4.jpg","nickname":"彭文达","note":"","ucode":"8DCC27EC5AF263","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1023101,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","nickname":"study的程序员","note":"","ucode":"E5AE9037D24429","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399199,"discussion_content":"跟bigkey有什么关系，不管怎么操作都不会是bigkey","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632920735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371794,"ip_address":""},"score":399199,"extra":""},{"author":{"id":2224520,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f1/88/cca5335f.jpg","nickname":"神清气爽海波东","note":"","ucode":"E5F45675DC059F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1023101,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","nickname":"study的程序员","note":"","ucode":"E5AE9037D24429","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551274,"discussion_content":"bigkey不是这个意思吧😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644972254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371794,"ip_address":""},"score":551274,"extra":""}]},{"author":{"id":1765097,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzCZibunMDooyZ86JRibGasxZFbq8HT4WzHAPQIiaBneWnwkb6CaSkesMwAvZpxFGib2ibVA9DVP9LbhQ/132","nickname":"Geek_b43b32","note":"","ucode":"5DD112591702BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371404,"discussion_content":"我觉得可以，在退货时做原子操作就可以了，判断是否小于0，小于就设置为1，否则incr，毕竟退货不属于高并发操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619757193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2351949,"avatar":"https://static001.geekbang.org/account/avatar/00/23/e3/4d/8a26dbb2.jpg","nickname":"枫中浪子","note":"","ucode":"860BEA32059B37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358342,"discussion_content":"商家后面再补库存怎么办","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615968666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1145554,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/d2/4ba67c0c.jpg","nickname":"Sch0ng","note":"","ucode":"73F6113931B1AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2351949,"avatar":"https://static001.geekbang.org/account/avatar/00/23/e3/4d/8a26dbb2.jpg","nickname":"枫中浪子","note":"","ucode":"860BEA32059B37","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386483,"discussion_content":"1. 增加库存的lua脚本；2.分布式互斥锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627609943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":358342,"ip_address":""},"score":386483,"extra":""}]},{"author":{"id":2252928,"avatar":"","nickname":"Geek_653096","note":"","ucode":"949B213B3A4E33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326201,"discussion_content":"我的理解是 避免引入脏数据吧，redis中的库存 最终还是得同步到数据库上的。比如定时同步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605541374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2252928,"avatar":"","nickname":"Geek_653096","note":"","ucode":"949B213B3A4E33","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340176,"discussion_content":"不会定时吧 ,一般异步更新db ,用消息队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609922333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326201,"ip_address":""},"score":340176,"extra":""}]}]},{"had_liked":false,"id":266411,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1607328603,"is_pvip":false,"replies":[{"id":"97925","content":"高考的比喻很形象！","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608995008,"ip_address":"","comment_id":266411,"utype":1}],"discussion_count":3,"race_medal":0,"score":"83211707227","product_id":100056701,"comment_content":"一般秒杀场景 用redis 扣减库存，不去保证原子性，扣减后有可能超卖，再用数据库去保证最终不超卖，因为超卖的不会多，能够打到mysql的操作就是超卖+实际库存，所以mysql压力也会比较少<br><br>课后习题：  redis的 800个库存，分布到4个server上，打到哪个server上，取决于key，如果key分布不均匀，会导致 一定的不公平，就像高考一样，有的地方考生多，有的地方考生少，虽然在每个省中录取名额一样，但是也不公平","like_count":20,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511255,"discussion_content":"高考的比喻很形象！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608995008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792875,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYLPAlGUWic46Vr5WCsSYuqgQGvgEBnicylYPcgl0Tn57RF8InuxMZDvvt0pFiaIJjJTsOvC1Ed5ZLA/132","nickname":"雨潇","note":"","ucode":"735B7E796E84EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387352,"discussion_content":"Redis使用incr或decr方式判断是否卖完，为啥还要数据库保证最终不超卖呢？不是很理解这个分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628131910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1792875,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYLPAlGUWic46Vr5WCsSYuqgQGvgEBnicylYPcgl0Tn57RF8InuxMZDvvt0pFiaIJjJTsOvC1Ed5ZLA/132","nickname":"雨潇","note":"","ucode":"735B7E796E84EF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578403,"discussion_content":"他没说用incr","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656699368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":387352,"ip_address":""},"score":578403,"extra":""}]}]},{"had_liked":false,"id":265866,"user_name":"Geek_f6a7c7","can_delete":false,"product_type":"c1","uid":2342029,"ip_address":"","ucode":"3927E94C25A552","user_header":"","comment_is_top":false,"comment_ctime":1607055019,"is_pvip":false,"replies":[{"id":"97929","content":"分析的不错。使用切片后，处理逻辑要考虑分布式的数据情况了，变得复杂了。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608997149,"ip_address":"","comment_id":265866,"utype":1}],"discussion_count":2,"race_medal":0,"score":"53146662571","product_id":100056701,"comment_content":"不是一个好方案，一个商品库存数切片不同实例存储的确可以减少单个实例的压力，但是在业务上可行性有待商榷，如果当前切片实例没有库存，是不是要再请求别的切片实例？特别是库存数都被抢购完成后，后面的请求是不是都要请求4个切片节点做库存数的聚合才知道又没人退货，做库存数的聚合？","like_count":12,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511076,"discussion_content":"分析的不错。使用切片后，处理逻辑要考虑分布式的数据情况了，变得复杂了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608997149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2250114,"avatar":"https://static001.geekbang.org/account/avatar/00/22/55/82/985411a8.jpg","nickname":"xyx","note":"","ucode":"1AECC9DDAC3D11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349508,"discussion_content":"单台redis 6.0+dpdk 30w查询应该没问题…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613275971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267744,"user_name":"Geek_0879b1","can_delete":false,"product_type":"c1","uid":2354491,"ip_address":"","ucode":"57B3D7C6281DDD","user_header":"","comment_is_top":false,"comment_ctime":1607911783,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"31672682855","product_id":100056701,"comment_content":"老师，秒杀过程中，如果不论Redis采用RDB还是AOF的方式来持久化，都有可能导致库存数据的丢失。而如果不采用持久化的方式，数据丢失的风险更大。此时如果redis中的库存数据丢失，并且库存数据没有同步到关系型数据库，这种丢失的风险该如何应对？","like_count":7,"discussions":[{"author":{"id":2105175,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","nickname":"Geek_72b9a7","note":"","ucode":"4C26B79F9F15A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391329,"discussion_content":"订单信息发一份到队列中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630402147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210265,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Gswh7ibY4tubXhp0BXOmV2pXZ3XsXic1d942ZMAEgWrRSF99bDskOTsG1g172ibORXxSCWTn9HWUX5vSSUVWU5I4A/132","nickname":"奔奔奔跑","note":"","ucode":"F86EC205DCAACE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352421,"discussion_content":"缓存不需要做持久化，持久化在DB里。数据丢了就回源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614733334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2250114,"avatar":"https://static001.geekbang.org/account/avatar/00/22/55/82/985411a8.jpg","nickname":"xyx","note":"","ucode":"1AECC9DDAC3D11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349507,"discussion_content":"上pika…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613275878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622754,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/e2/c131e9d6.jpg","nickname":"灯无焰","note":"","ucode":"3FD28BBE1CDBD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348281,"discussion_content":"Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。我的想法是 appendfsync always 和 使用单例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612497487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2060546,"avatar":"","nickname":"马岳","note":"","ucode":"D2CB7AFF1EB753","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345177,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611675997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1108924,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/bc/6ccac4bb.jpg","nickname":"武文文武","note":"","ucode":"5288366646A15B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2060546,"avatar":"","nickname":"马岳","note":"","ucode":"D2CB7AFF1EB753","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566489,"discussion_content":"老师也没招，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650703730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345177,"ip_address":""},"score":566489,"extra":""}]}]},{"had_liked":false,"id":261161,"user_name":"花轮君","can_delete":false,"product_type":"c1","uid":1044639,"ip_address":"","ucode":"A4F27CC1C38D3B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f0/9f/6689d26e.jpg","comment_is_top":false,"comment_ctime":1605231819,"is_pvip":true,"replies":[{"id":"98057","content":"请求分片的均衡度会比较难控制，另外，如果按照分库顺序扣的话，那么设计四个分片期望达到的支持并发扣减库存的目标就达不到了。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609114123,"ip_address":"","comment_id":261161,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31670002891","product_id":100056701,"comment_content":"设计上是可行的，将秒杀请求也进行分片，库存的校验可以按照分库顺序扣。","like_count":7,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509397,"discussion_content":"请求分片的均衡度会比较难控制，另外，如果按照分库顺序扣的话，那么设计四个分片期望达到的支持并发扣减库存的目标就达不到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609114123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277105,"user_name":"马听","can_delete":false,"product_type":"c1","uid":1430132,"ip_address":"","ucode":"93D83CB5FAE5AD","user_header":"https://static001.geekbang.org/account/avatar/00/15/d2/74/7861f504.jpg","comment_is_top":false,"comment_ctime":1612260404,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"27382064180","product_id":100056701,"comment_content":"为啥库存扣减不能再数据库执行呢？<br>除了文中提到的额外开销和可能导致超售，另外如果数据库是 MySQL，则可能导致 MySQL 的死锁检测，导致消耗大量的 CPU 资源。具体可以参考《MySQL实战45 讲》07 节 ：行锁功过","like_count":6,"discussions":[{"author":{"id":1622022,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJia6zEsh2u119zJicmq7wApvnricZEKiawaZicice1cOzujWdFicFwPtavlHiaVpCNgCpxBtdl7ynd3y0wkQ/132","nickname":"james_xu","note":"","ucode":"12E50291F5BA89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363986,"discussion_content":"赞！刚又去回顾了这部分，发现很多都忘记了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617341721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262727,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1605833696,"is_pvip":false,"replies":[{"id":"98073","content":"这里的关键技术挑战就是：请求分发规则和库存分布式查询。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609116509,"ip_address":"","comment_id":262727,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18785702880","product_id":100056701,"comment_content":"我个人认为这个方式不是很好，因为单个sku分开后，需要对用户的请求做路由判断，假如一个用户请求本身就发出了两条，按照随机路由的方式，他有可能在两个切片中抢到商品。假如路由规则是固定的，那么会出现sku还有库存，但是用户就是抢不到的情况","like_count":4,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509945,"discussion_content":"这里的关键技术挑战就是：请求分发规则和库存分布式查询。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609116509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261620,"user_name":"Geek_9a0c9f","can_delete":false,"product_type":"c1","uid":2159835,"ip_address":"","ucode":"2A6078F740881F","user_header":"","comment_is_top":false,"comment_ctime":1605447104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18785316288","product_id":100056701,"comment_content":"老师问下，最后的订单处理是如何处理的，库存扣完成功操作，接着进行下单操作，下单操作是直接对数据库进行操作么？还是将行为打入kafka之类的消息队列，然后慢慢的去消费处理订单","like_count":4},{"had_liked":false,"id":272433,"user_name":"王云星","can_delete":false,"product_type":"c1","uid":1837246,"ip_address":"","ucode":"03236FFDC09E89","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoSMRiaMtAcqQz7oNzcNg0M2vEic2sByibGib0l9z2g5Niafo7caLhqJtACRfCCT1sdAKQQM40BHEWsdOg/132","comment_is_top":false,"comment_ctime":1610089126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14494991014","product_id":100056701,"comment_content":"使用多个实例的切片集群来分担秒杀请求，是否是一个好方法？<br>不太行，难度很大，第一个是流量需要均衡分配到每个实例，第二个是如果说一个订单需要扣减多个库存，而单个实例库存剩余不够，导致扣减库存失败，但其实总库存是够的。比如每个实例还剩1件库存，一个订单同时秒杀4件，这下就会扣减失败，实际上库存是够的","like_count":3},{"had_liked":false,"id":265668,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1606976530,"is_pvip":false,"replies":[{"id":"97931","content":"关键是这个假设不一定能实际做到。。。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608997442,"ip_address":"","comment_id":265668,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14491878418","product_id":100056701,"comment_content":"如果秒杀请求能够比较均匀的分别打到4个实例上是没有问题的。<br>这个时候不返回剩余库存，不做聚合，能大幅度提高速度。","like_count":3,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511009,"discussion_content":"关键是这个假设不一定能实际做到。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608997442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066752,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","nickname":"piboye","note":"","ucode":"7CFD8712857A85","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551958,"discussion_content":"hash(uid+cnt), 这样是不是就可以做到公平呢， 用户多次重试会到不同的实例上， 如果用实在不行，HWR hash 可以比较公平的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645189431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293681,"user_name":"JAVA初级开发工程师","can_delete":false,"product_type":"c1","uid":1876716,"ip_address":"","ucode":"F78E2F30751AC2","user_header":"http://thirdwx.qlogo.cn/mmopen/KFgDEHIEpnTUibfcckj33D1LVj9VapfrK3Yq2Gj00wnLt4nkWS7HvYy5NxvmnQcQpaysuBHVrB9MILWZ9hibUNasicPNtueYoNM/132","comment_is_top":false,"comment_ctime":1621490188,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10211424780","product_id":100056701,"comment_content":"关于秒杀场景有几个问题<br>1、redis并不保证数据的一致性 发生主备切换有可能会造成超卖这种情况怎么处理<br>2、秒杀如何处理大库存场景 如果一个商品库存对应redis一个key  这个key可能同时承受数十万的qps 这种情况redis也是扛不住的","like_count":2,"discussions":[{"author":{"id":3071902,"avatar":"","nickname":"Geek_e4114f","note":"","ucode":"265D8ADE220A72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585510,"discussion_content":"超卖可以由数据库兜底啊，重要的是让redis挡掉大部分请求流量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661614529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261288,"user_name":"Geek_f00f74","can_delete":false,"product_type":"c1","uid":2179830,"ip_address":"","ucode":"7A0E89CB0AF499","user_header":"","comment_is_top":false,"comment_ctime":1605259045,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"10195193637","product_id":100056701,"comment_content":"实际生产中能用Redis做库存校验和扣减吗？如果Redis宕机如何保证Redis库存和数据库库存一致？如果发生主从切换导致库存更新丢失呢？<br>使用分布式锁的话就是串行化了，这个性能太差了吧。","like_count":2,"discussions":[{"author":{"id":1313079,"avatar":"https://static001.geekbang.org/account/avatar/00/14/09/37/5101847e.jpg","nickname":"燕子坞","note":"","ucode":"78763F8BE2550F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338742,"discussion_content":"实际不会这样做，老师有些课程还是偏理论，没实际生产经验","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609349851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1022757,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/25/abb7bfe3.jpg","nickname":"淡淡的忧伤","note":"","ucode":"D4911BEB2F8434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1313079,"avatar":"https://static001.geekbang.org/account/avatar/00/14/09/37/5101847e.jpg","nickname":"燕子坞","note":"","ucode":"78763F8BE2550F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352055,"discussion_content":"不用redis，还有什么解决办法保证？redis宕机时候，其实秒杀也无法再继续其实，秒切主备，也难以抵消对正在进行的秒杀活动了。\n\n但是出问题时候，保证重启服务前后，一个事务的数据一致性就很重要了。个人理解。\n\n为了保证系统依旧对外是可用，比如可以加大限流，用数据库抗一下。只是用户体验差了。\n\nredis宕机的问题，就是另外一个纬度的问题要思考的。不能指望一个redis，解决所有的问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614583604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338742,"ip_address":""},"score":352055,"extra":""},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1313079,"avatar":"https://static001.geekbang.org/account/avatar/00/14/09/37/5101847e.jpg","nickname":"燕子坞","note":"","ucode":"78763F8BE2550F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387145,"discussion_content":"是啊，实际生产是怎么处理的？在 Redis 前面加个消息队列，如果 Redis 宕机，直接走数据库？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628004098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338742,"ip_address":""},"score":387145,"extra":""}]},{"author":{"id":2060546,"avatar":"","nickname":"马岳","note":"","ucode":"D2CB7AFF1EB753","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345176,"discussion_content":"我也遇到相同问题，redis扣减库存是可以支撑高并发，但redos宕机后应如何处理？首先，数据库保持和redis库存一致是不现实，如果能保持一致就没必要用redis了。如果数据库异步保持和redis额度一致，那么redis宕机时，如何处理？如果等数据一致在对外提供服务就会影响在途交易，如果不等一致就提供服务，就可能出现超卖。有没有大神解决过类似的实际问题？？？谢谢🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611675889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1287774,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a6/5e/b05254a6.jpg","nickname":"Mhy","note":"","ucode":"DE19BCAD1F856E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2060546,"avatar":"","nickname":"马岳","note":"","ucode":"D2CB7AFF1EB753","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541281,"discussion_content":"如果只用redis做库存减扣，redis宕机了，那秒杀就可以停止了，可以换个思路，如果mysql出问题了，怎么保证秒杀正常，答案是根本无法保证，能做的就是尽快恢复mysql/redis从而减少对用户的影响，如果是因为流量问题导致redis/mysql宕机，那就是压测没有做好，这是要避免的问题，所以秒杀的关键从来都是削峰减流，防止过多的流量进入到当前系统，从前端到网关到具体的库存服务，都要做好熔断降级限流策略","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640316945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345176,"ip_address":""},"score":541281,"extra":""}]}]},{"had_liked":false,"id":342554,"user_name":"Breeze","can_delete":false,"product_type":"c1","uid":2962899,"ip_address":"","ucode":"8B6711F5B9D112","user_header":"https://static001.geekbang.org/account/avatar/00/2d/35/d3/8de43dd5.jpg","comment_is_top":false,"comment_ctime":1650339799,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5945307095","product_id":100056701,"comment_content":"使用多个实例的切片集群来分担秒杀请求，是否是一个好方法?<br>如果并发量不大，或者提前做了限流策略，那么使用多个实例切片来分担压力就没有太大必要性了，主从集群就足够应对了。<br>如果并发量非常大，比如10w+请求，那么此时通过多实例来分担秒杀请求是合理的，因为并发量足够大，800库存理论上在极短的时间内会出现库存不均匀的现象，但是很快整个库存就都被消化掉，所以这个影响是可以忽略的。<br>所以整个方案取决秒杀的并发量和秒杀整个过程时长，如果并发量很大，秒杀过程很短（库存不大），那么这个方案是可行的。","like_count":1},{"had_liked":false,"id":293750,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1621520396,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5916487692","product_id":100056701,"comment_content":"客户端的秒杀请求可以分发到不同的实例上进行处理，你觉得这是一个好方法吗？<br><br>使用切片集群会将问题复杂化：<br>1.如果分片的处理能力不是均衡的，可能出现某个分片的商品在秒杀活动结束后未卖完。<br>2.前端查询总库存时，后端需要查多个分片的库存，然后进行合并，增加了网络交互。<br>3.当出现一个订单购买多件商品时，商品库存被分摊到多个分片，需要用锁占用分片资源，多个分片扣减库存成功后，才会释放分片资源，影响性能。","like_count":1},{"had_liked":false,"id":265607,"user_name":"zenk","can_delete":false,"product_type":"c1","uid":1013669,"ip_address":"","ucode":"B235D5EBCF49BC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/a5/c5ae871d.jpg","comment_is_top":false,"comment_ctime":1606960748,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5901928044","product_id":100056701,"comment_content":"多个实例，需要客户段做负载均衡，这是额外的复杂度<br><br>查询<br><br>查询的时候需要查询每个结点，因此集群并没减少每个节点的请求量<br><br>扣库存<br><br>扣库存的时候，考虑到高并发的时候很容易给每个实例分配到200个并发请求，因此只有这些请求会分散在各个节点<br><br>如果不命中，需要请求其他每个节点，而这些请求量更大，因此整体而言扣库存也没有降低节点的压力<br><br>单机情况下，假设一次扣库存操作是10us（量级不确定），800次就是8ms，200次是2ms<br><br>可靠性<br>集群高，一个挂了其他节点还能处理<br><br>结论<br>集群在命中第一个节点的时候可缓解节点压力，但是增加客户端复杂度<br><br>可靠性，秒杀集中在很短时间，减少故障概率<br><br>扣库存差6ms可以接受<br><br>所以，集群好处不明显","like_count":1},{"had_liked":false,"id":261330,"user_name":"杨逸林","can_delete":false,"product_type":"c1","uid":1167233,"ip_address":"","ucode":"4BF3CF3E2F1AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","comment_is_top":false,"comment_ctime":1605273298,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"5900240594","product_id":100056701,"comment_content":"有秒杀场景，那老师，在 Redis 中，当一个 Key 的 QPS 达到 100万时，应该如何处理呢？","like_count":1,"discussions":[{"author":{"id":1316926,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/3e/f8632713.jpg","nickname":"EveryDayIsNew","note":"","ucode":"776B81EF6830FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389757,"discussion_content":"老师前面讲的，读的话可以用新版本的本地缓存，qps肯定比Redis本身搞几个数量级，另外很多大公司也会针对热key的读做一些处理，一种类似本地缓存方案，另一种是在切片集群模式下然后多个几个散列的key到其他分片","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629424231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2116689,"avatar":"https://static001.geekbang.org/account/avatar/00/20/4c/51/61003d76.jpg","nickname":"上学威龙007","note":"","ucode":"B24D8A2E7D01F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331070,"discussion_content":"采用主从集群，让从库来分担一部分的qps是不是可以","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606781898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592126,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/3e/98447d59.jpg","nickname":"失误过人","note":"","ucode":"418A6DC9759628","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325953,"discussion_content":"先限流，超过阈值的直接返回秒杀失败","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605489443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1167233,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","nickname":"杨逸林","note":"","ucode":"4BF3CF3E2F1AC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1592126,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/3e/98447d59.jpg","nickname":"失误过人","note":"","ucode":"418A6DC9759628","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326001,"discussion_content":"不是，我没说清楚，不能限流。一个 Key 的 QPS 100w，这是个 Zoom 的面试题，要正常返回","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605497173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325953,"ip_address":""},"score":326001,"extra":""},{"author":{"id":1592126,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/3e/98447d59.jpg","nickname":"失误过人","note":"","ucode":"418A6DC9759628","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1167233,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","nickname":"杨逸林","note":"","ucode":"4BF3CF3E2F1AC7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326046,"discussion_content":"可以本地先聚合，再写redis","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605507273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326001,"ip_address":""},"score":326046,"extra":""},{"author":{"id":1167233,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","nickname":"杨逸林","note":"","ucode":"4BF3CF3E2F1AC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1592126,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/3e/98447d59.jpg","nickname":"失误过人","note":"","ucode":"418A6DC9759628","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328072,"discussion_content":"不是这个意思，就是单纯的一个 Key QPS 100w 和聚合什么关系。我看别人答的，把值放 Nginx 里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606048796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326046,"ip_address":""},"score":328072,"extra":""}]},{"author":{"id":1675882,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/6a/dd37a054.jpg","nickname":"张y .","note":"","ucode":"85918469492F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413351,"discussion_content":"一般会有本地缓存 Redis做二级缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636453666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583740,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2a/7c/0d6a87c4.jpg","nickname":"dandy","note":"","ucode":"5EE976FCBD9215","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392314,"discussion_content":"看这个key是只是查询还是需要修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630943155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349964,"user_name":"kobe","can_delete":false,"product_type":"c1","uid":1165831,"ip_address":"","ucode":"AB8B599F3D5521","user_header":"https://static001.geekbang.org/account/avatar/00/11/ca/07/22dd76bf.jpg","comment_is_top":false,"comment_ctime":1656473526,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656473526","product_id":100056701,"comment_content":"那怎么在 Lua 脚本中实现这两个操作呢？我给你提供一段 Lua 脚本写的伪代码，它显示了这两个操作的实现。#获取商品库存信息            local counts = redis.call(&quot;HMGET&quot;, KEYS[1], &quot;total&quot;, &quot;ordered&quot;);#将总库存转换为数值local total = tonumber(counts[1])#将已被秒杀的库存转换为数值local ordered = tonumber(counts[2])  #如果当前请求的库存量加上已被秒杀的库存量仍然小于总库存量，就可以更新库存         if ordered + k &lt;= total then    #更新已秒杀的库存量    redis.call(&quot;HINCRBY&quot;,KEYS[1],&quot;ordered&quot;,k)                              return k;  end               return 0有了 Lua 脚本后，我们就可以在 Redis 客户端，使用 EVAL 命令来执行这个脚本了。最后，客户端会根据脚本的返回值，来确定秒杀是成功还是失败了。如果返回值是 k，就是成功了；如果是 0，就是失败。<br>这里hincrby命令的返回值应该是ordered的新值，而不是这个增量k吧","like_count":0},{"had_liked":false,"id":344700,"user_name":"Seajunnn","can_delete":false,"product_type":"c1","uid":2459179,"ip_address":"","ucode":"41B2BA6D056F85","user_header":"https://static001.geekbang.org/account/avatar/00/25/86/2b/7f9b94d8.jpg","comment_is_top":false,"comment_ctime":1651730375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651730375","product_id":100056701,"comment_content":"基于Redis原子操作和 基于分布式锁 这两种方案 各有什么优劣呢？","like_count":0},{"had_liked":false,"id":342268,"user_name":"阿昕","can_delete":false,"product_type":"c1","uid":1012906,"ip_address":"","ucode":"F3AD093B68E074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","comment_is_top":false,"comment_ctime":1650165226,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650165226","product_id":100056701,"comment_content":"切片的目的是分隔数据，所以没必要","like_count":0},{"had_liked":false,"id":313703,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1632624169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632624169","product_id":100056701,"comment_content":"使用多个实例的切片集群来分担秒杀请求，是否是一个好方法？<br><br>我觉得是一个可行的方式，减少单台实例的压力；<br>举个例子：京东在下单的时候会显示区域是否有货，而不是全国的库存情况，此时区域可认为是库存的一部分，区域无货也可以下单，然后从别的区域扣减，如果能扣减成功，则下单成功，否则认为下单失败。","like_count":0},{"had_liked":false,"id":310243,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1630566987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630566987","product_id":100056701,"comment_content":"这会造成一些意外的操作,比如长连接导致的请求的都是一个实例,不建议这么做","like_count":0},{"had_liked":false,"id":304808,"user_name":"乐事不乐","can_delete":false,"product_type":"c1","uid":1609962,"ip_address":"","ucode":"A01121068CD244","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/ea/67f2ef29.jpg","comment_is_top":false,"comment_ctime":1627625205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627625205","product_id":100056701,"comment_content":"能否把库存直接存储在redis中，直接在redis 完成库存信息的变动？","like_count":0},{"had_liked":false,"id":298792,"user_name":"Forever♏️","can_delete":false,"product_type":"c1","uid":2302130,"ip_address":"","ucode":"688D1E8BCD0E2C","user_header":"https://static001.geekbang.org/account/avatar/00/23/20/b2/32eef1b6.jpg","comment_is_top":false,"comment_ctime":1624327018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624327018","product_id":100056701,"comment_content":"请问秒杀场景，客户端在点击秒杀按钮后，如何接收到服务器端已经秒杀成功的响应呢","like_count":0},{"had_liked":false,"id":291492,"user_name":"Tom","can_delete":false,"product_type":"c1","uid":1908926,"ip_address":"","ucode":"0BA98E780BB34C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/20/be/bf6a570f.jpg","comment_is_top":false,"comment_ctime":1620307054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620307054","product_id":100056701,"comment_content":"老师，您好，请问采用分布式锁的方式，那如何解决秒杀场景下的用户等待问题，造成用户体验不好的现状？","like_count":0},{"had_liked":false,"id":287681,"user_name":"winter","can_delete":false,"product_type":"c1","uid":1323233,"ip_address":"","ucode":"04D4DE4A60C4C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBywibUar2Q8TmCy6ZrNQk9qia7sQgosBYInmygZI118vzrWu4CfUQnbOefvP82c8Inhb6xVqymhvYw/132","comment_is_top":false,"comment_ctime":1618107879,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618107879","product_id":100056701,"comment_content":"秒杀对系统的要求<br>  秒杀场景：限时限量<br>  秒杀特征：<br>    并发访问量大<br>    读多写少<br>  秒杀环节：<br>    秒杀前：用户刷新商品详情页，通过cdn缓存静态资源或者或者浏览器缓存<br>    秒杀中：<br>      用户点击商品详情，查询库存<br>      然后库存减扣，<br>      生成订单<br>    秒杀后：<br>      流量已经很低，不在讨论<br>  注意的问题<br>    redis 用于库存查询，库存减扣，并且这两个操作必须是原子性操作<br>    mysql 用于订单处理<br>    这样设计的目的<br>        减少额外的开销，redis已经做了“查和减”的操作<br>        避免出现超售，mysql 性能比较慢，<br><br>Redis 那些方法支持秒杀场景<br>  要求<br>    支持高并发（通过切片集群，将不同商品保存在不同实例上）<br>    查和减，需要原子性操作（通过redis原子性操作，以及分布式锁来支持）<br>  其他环节主要优化<br>    前端静态页面设置：走cdn和缓存<br>    请求拦截和流控：非法请求<br>    库存信息过期：避免缓存击穿<br>    数据库订单异常：增加重试功能<br><br>缓存雪崩<br>  大量的可以失效：1）随机过期，避免大面积失效 2）永不过期<br>缓存穿透<br>  redis 和 mysql 都不存在 大量的请求落到数据库 1）设置空值 2）布隆过滤器，将数据库存在的key提前加入<br>缓存击穿  数据过期那一时刻，大量的请求落到数据上 1）加锁更新访问<br>参考：https:&#47;&#47;www.jianshu.com&#47;p&#47;b57d0773ee96<br> ","like_count":0},{"had_liked":false,"id":286582,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1617410217,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1617410217","product_id":100056701,"comment_content":"秒杀的负载特征是瞬时并发访问量大、读多写少。<br><br>秒杀前，使用 CDN 和浏览器缓存服务，不需要 Redis；<br><br>秒杀中，查询库存并发压力大，可以使用 Redis 保存库存并进行库存扣减，后台数据库处理订单操作；<br><br>秒杀后，并发量下降，不需要 Redis。<br><br>使用 Hash 数据类型，直接保存总库存量和已秒杀量，这个比较聪明，我一开始以为只保存已秒杀量即可。<br><br>使用分布式锁的方案明显更高一筹。<br><br>对于课后题，我觉得把 800 个库存分到 4 个 Redis 上不算是一个好方案，因为可能会导致有的 Redis 实例上库存没有了，而其他的还有。一个商品，800 库存，单个的 Redis 应该就能够应付了吧。<br><br>看了课后留言，分库存主要的问题一个是可能数据倾斜，另外就是对于计算剩余库存不友好。<br><br>如果采用 Codis 集群方案，那么在秒杀并发比较高的情况下，codis proxy 是否也需要扩容？<br><br>另外，出门右转，隔壁还有一个《如何设计一个秒杀系统》的专栏。","like_count":0},{"had_liked":false,"id":286057,"user_name":"heyman","can_delete":false,"product_type":"c1","uid":1173894,"ip_address":"","ucode":"92EF9EF1B1B1B3","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/86/d34800a4.jpg","comment_is_top":false,"comment_ctime":1617127771,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1617127771","product_id":100056701,"comment_content":"扣库存成功后，用户进程挂了，导致下单失败。这种情况怎么办？它们不是原子操作呀","like_count":0,"discussions":[{"author":{"id":2689921,"avatar":"","nickname":"Jack","note":"","ucode":"5002A8A4C22ABC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575216,"discussion_content":"消息队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654669126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282574,"user_name":"Sleepless","can_delete":false,"product_type":"c1","uid":2035762,"ip_address":"","ucode":"F96607B4583928","user_header":"https://static001.geekbang.org/account/avatar/00/1f/10/32/92b9f66f.jpg","comment_is_top":false,"comment_ctime":1615304826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615304826","product_id":100056701,"comment_content":"使用客户端唯一标识作为value<br>val = clientUniqueID&#47;&#47;申请分布式锁，Timeout是超时时间<br>lock =acquireLock(key, val, Timeout)，<br>在这一步中，怎么是根据客户端唯一表示做为value来获取锁呢，这是什么场景下使用的api?","like_count":0},{"had_liked":false,"id":280176,"user_name":"飞白","can_delete":false,"product_type":"c1","uid":1926642,"ip_address":"","ucode":"2586407256F3B3","user_header":"https://static001.geekbang.org/account/avatar/00/1d/65/f2/24e48aae.jpg","comment_is_top":false,"comment_ctime":1614125573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614125573","product_id":100056701,"comment_content":"使用多个实例的切片集群来分担秒杀请求，是否是一个好方法？<br>答：1.请求A、B有时间顺序。如果A请求查询切片1，发现库存不足，下单失败。后续的请求B查询切片2，发现还有库存，下单成功。这种业务实现是有问题的。<br>2. Kaito同学提到的库存总余量的情况。<br>","like_count":0},{"had_liked":false,"id":277852,"user_name":"Geek_1e8830","can_delete":false,"product_type":"c1","uid":1506574,"ip_address":"","ucode":"CD84A5AAAE6872","user_header":"","comment_is_top":false,"comment_ctime":1612621579,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1612621579","product_id":100056701,"comment_content":"老师你好，问一下秒杀场景是否可以使用List来操作，来一个请求就LPOP一下，直到list中的元素pop完为止，可以不使用lua脚本来保证原子性，并且如果有人抢到资格放弃还可以把这个名额又PUSH到list中去。","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358612,"discussion_content":"这个是限流，接入层的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615997634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277602,"user_name":"泊","can_delete":false,"product_type":"c1","uid":1557092,"ip_address":"","ucode":"3E9275288F1B0D","user_header":"https://static001.geekbang.org/account/avatar/00/17/c2/64/5cd6efa0.jpg","comment_is_top":false,"comment_ctime":1612488717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612488717","product_id":100056701,"comment_content":"800个库存平均分布到四个实例中那么key就不可以用商品id了吧，集群分片是根据key进行hash的，如果还用商品id的话不会分到不同实例上。那么这个key应该怎么处理呢？商品id+随机数吗？希望有大佬解答下。","like_count":0},{"had_liked":false,"id":277523,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1612442835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612442835","product_id":100056701,"comment_content":"秒杀场景关键在要不要实时的看到库存情况，要是允许秒杀一开始就看不到库存了，那有一万种方法...","like_count":0},{"had_liked":false,"id":275642,"user_name":"Geek_a499e7","can_delete":false,"product_type":"c1","uid":2297362,"ip_address":"","ucode":"5BF5B3248E4C64","user_header":"","comment_is_top":false,"comment_ctime":1611630055,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1611630055","product_id":100056701,"comment_content":"所以，我给你一个小建议，我们可以使用切片集群中的不同实例来分别保存分布式锁和商品库存信息。使用这种保存方式后，秒杀请求会首先访问保存分布式锁的实例<br><br>请问老师：<br>分布式锁 不是保存在 集群里超过一半的实例吗？为什么可以指定实例保存分布式锁？","like_count":0,"discussions":[{"author":{"id":2094925,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f7/4d/09554c96.jpg","nickname":"iron bo","note":"","ucode":"4BFB1331637AA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371888,"discussion_content":"你说的是主从集群，这里是切片集群","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620041012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268500,"user_name":"Anthony","can_delete":false,"product_type":"c1","uid":1309908,"ip_address":"","ucode":"9E0C98A9123365","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d4/743d3f02.jpg","comment_is_top":false,"comment_ctime":1608218830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608218830","product_id":100056701,"comment_content":"觉得没必要，redis本身作为高性能，秒杀服务压力一般也不在redis上，如果是redis有压力，可以用redis主从，但是这时候要考虑主从延迟，也比分片要好，分片的话，如果要统计次数，反而更复杂","like_count":0},{"had_liked":false,"id":267539,"user_name":"童谣","can_delete":false,"product_type":"c1","uid":1452007,"ip_address":"","ucode":"2417DC46DF959A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/M3iaJULcXSjCNya7UibVzgF0fq1H2fobO1ic7ibDzfGbic6DR6CbkUnfJo8ibbPjQRMHRbE1L8c2bTh2PhiczpE5SbPibw/132","comment_is_top":false,"comment_ctime":1607802006,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1607802006","product_id":100056701,"comment_content":"如果在Redis中扣减库存，成功后再减mysql库存，这样会有问题吗？","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340177,"discussion_content":"本身就是这样啊 , redis管理所有库存操作,异步化更新db,保证最终一致性","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609922429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1312184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","nickname":"JulyRemember","note":"","ucode":"9E3D5D60D82999","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337780,"discussion_content":"普通场景都很难保证Redis数据和MySQL数据一致性问题，数据一致性强保证开销挺大的，秒杀这种高并发情况更不会做这种保证了，很容易出现数据不对超卖的情况的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609075197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266552,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1607392301,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1607392301","product_id":100056701,"comment_content":"秒杀加分布式锁是否会有性能问题","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340178,"discussion_content":"不会, 开始就会进行一道库存校验","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609922491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264996,"user_name":"Reborn 2.0","can_delete":false,"product_type":"c1","uid":1977474,"ip_address":"","ucode":"BA506E7455D91C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/2c/82/98e2b82a.jpg","comment_is_top":false,"comment_ctime":1606730054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606730054","product_id":100056701,"comment_content":"想起之前做的redis记分, 每个用户的分数相加, 最后和redis的总分不等. 这就是原子性没有保证. <br>做好了自己认为的原子性, 还应该做定时任务把两个分数保证最终一致性. <br>这个秒杀就是按照redis是数据库来的, 我想为了保证DR, 在项目重启的时候, 还要有任务去统计订单数和配置库存, 才能恢复redis中的库存.","like_count":0},{"had_liked":false,"id":263221,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1606050359,"is_pvip":false,"replies":[{"id":"97933","content":"这是个关键因素。<br><br>而且如果某个实例上的库存扣除完了，并不代表所有库存都扣完了，这时要想判断是否还有库存，就要去其他实例查询，逻辑就复杂了。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608997887,"ip_address":"","comment_id":263221,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606050359","product_id":100056701,"comment_content":"将800个商品均分至4个实例，并不能保证客户端请求被均分至不同的实例；毕竟用户的行为是无法预测的，有可能出现某个实例的请求量比较大","like_count":0,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510124,"discussion_content":"这是个关键因素。\n\n而且如果某个实例上的库存扣除完了，并不代表所有库存都扣完了，这时要想判断是否还有库存，就要去其他实例查询，逻辑就复杂了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608997887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261680,"user_name":"@%初%@","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1605488538,"is_pvip":true,"replies":[{"id":"97934","content":"这种情况下余量查询的逻辑就比较复杂了，会增加查询请求的分发复杂度，反而可能会得不偿失。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608998474,"ip_address":"","comment_id":261680,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605488538","product_id":100056701,"comment_content":"我觉得，是可行的，主要要考虑最后的余量怎么处理，0～2个分片上有余量，而3号分片上有余量，这样怎么处理，还有，就是最后的用余量足够，而每个分片的余量不够，这个又怎么去处理，我觉得这些处理好了，分片存储可以考虑使用。","like_count":0,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509563,"discussion_content":"这种情况下余量查询的逻辑就比较复杂了，会增加查询请求的分发复杂度，反而可能会得不偿失。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608998474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261381,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1605315706,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"1605315706","product_id":100056701,"comment_content":"老师好，库存的热点更新问题我看隔壁讲秒杀的课程说的是在复杂情况下还是用db来做，并没有直接在缓存里面做扣减。还有后端存储课程讲的防止重复订单也是直接写db，用唯一索引来校验而不是先加一个分布式锁来拒绝重复的请求，那位老师说的意思是实现一个分布式锁的复杂度比直接用数据库约束来解决高，所以不用redis。我觉得这两个问题都颠覆了我以往的理解，我觉得都是用redis的场景但实际并没有用，想问下老师是怎么看这两个问题的呢？能否讲一下什么场景下反而用redis更难实现不如用数据库来抗。","like_count":0,"discussions":[{"author":{"id":1564002,"avatar":"https://static001.geekbang.org/account/avatar/00/17/dd/62/824e5e16.jpg","nickname":"沁塵","note":"","ucode":"4AD780EF50882B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330346,"discussion_content":"当redis不是你项目必须的一个组件的时候，就是还不如用数据库来扛的时候。\nMySQL 在三大主流数据库里面性能不是最好的那个，但依然可以很好应付很多场景。\n很多时候，我们项目引入一个中间件纯粹是因为书看多了，为了用而用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606574125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1564002,"avatar":"https://static001.geekbang.org/account/avatar/00/17/dd/62/824e5e16.jpg","nickname":"沁塵","note":"","ucode":"4AD780EF50882B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330726,"discussion_content":"redis现在也不是什么高门槛的技术，应用场景随处可见。而且淘宝秒杀用db抗，因为做了很多设计和优化，比如修改了mysql的内核支持排队，不代表普通的mysql就可以扛得住。很多场景下用redis都比用db要简单高效，并不是什么为了用而用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606698465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":330346,"ip_address":""},"score":330726,"extra":""},{"author":{"id":1564002,"avatar":"https://static001.geekbang.org/account/avatar/00/17/dd/62/824e5e16.jpg","nickname":"沁塵","note":"","ucode":"4AD780EF50882B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330979,"discussion_content":"我并没有否认redis各种好处。\nmysql能不能扛取决于业务场景需求。\n加多一个组件就要维护多一个组件，哪怕这个组件很容易使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606742825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":330726,"ip_address":""},"score":330979,"extra":""}]},{"author":{"id":2252928,"avatar":"","nickname":"Geek_653096","note":"","ucode":"949B213B3A4E33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326197,"discussion_content":"我觉得能用唯一索引的情况下尽量用唯一索引，redis还是可能会宕机的。另外我觉得隔壁秒杀上说库存业务单一的情况下在redis上可以。也就是说一个商品的库存可能有总库存的概念不建议使用(比如 红鞋子15双，蓝鞋子15双。总库存20双，两种鞋子售卖不能超过总库存也不能超过单个库存)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605541045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2252928,"avatar":"","nickname":"Geek_653096","note":"","ucode":"949B213B3A4E33","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326255,"discussion_content":"\nredis是有可能宕机的，但是一个大厂肯定会有各种高可用方案来解决。我是觉得一个分布式锁可以解决的，并且可以扛住更多流量，比如有恶意攻击下重复订单，肯定前置系统就拦掉了不是等最后入库用唯一索引来防止。另外隔壁mysql课程老师也说了，在业务能保证数据不会重复的情况下，优先使用非唯一索引，“由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发我建议你优先考虑非唯一索引。”优化系统的一个思路不就是尽可能少的让流量到数据库层吗。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1605572491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326197,"ip_address":""},"score":326255,"extra":""},{"author":{"id":2252928,"avatar":"","nickname":"Geek_653096","note":"","ucode":"949B213B3A4E33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326815,"discussion_content":"是的 你说的没错，只能说如果能保证redis可用度很高的情况下使用锁是一个比较好的方案。唯一索引带来的是性能上的损耗。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605682418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326255,"ip_address":""},"score":326815,"extra":""},{"author":{"id":1100648,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/68/d8a4f907.jpg","nickname":"楚天行","note":"","ucode":"B4DD986060ECD4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329401,"discussion_content":"分布式锁可以用来挡掉同一登录用户的请求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606379152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326255,"ip_address":""},"score":329401,"extra":""}]},{"author":{"id":1100648,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/68/d8a4f907.jpg","nickname":"楚天行","note":"","ucode":"B4DD986060ECD4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329400,"discussion_content":"老师讲的这个例子，没包含限购，只是讲了扣减库存。如果一个用户限制了购买数量，就不能这么玩了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606379110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2252928,"avatar":"","nickname":"Geek_653096","note":"","ucode":"949B213B3A4E33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326824,"discussion_content":"但是一般情况下 redis保证的是AP，还是较难保证一致性。一旦发生主从切换，就容易锁失效，使用红锁的话又需要保证服务器时间的强一致性。还是比较难维护","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605683303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261146,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1605229429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605229429","product_id":100056701,"comment_content":"用分片集群保存四个分库存，查询库存的时候需要四个实例查询后汇总返回，扣减库存的时候只扣减一个实例，有可能那个实例库存为空。而且要保证上游流量分发均匀（不能用轮询，只能用hash）。问题复杂化了，还不如用一个实例。","like_count":0},{"had_liked":false,"id":261138,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1605227171,"is_pvip":false,"replies":[{"id":"98056","content":"查询逻辑会变得比较复杂了。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609113953,"ip_address":"","comment_id":261138,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605227171","product_id":100056701,"comment_content":"每个实例200个库存，当某个请求在某个实例上查询不到库存时，并不是库存真的为0了，还需要去其它实例查询，这个是一个缺点。<br><br>好处时可以承受更大的流量。","like_count":0,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509386,"discussion_content":"查询逻辑会变得比较复杂了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609113953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}