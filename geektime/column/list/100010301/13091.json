{"id":13091,"title":"11 | 垃圾回收（上）","content":"<p>你应该听说过这么一句话：免费的其实是最贵的。</p>\n<p>Java虚拟机的自动内存管理，将原本需要由开发人员手动回收的内存，交给垃圾回收器来自动回收。不过既然是自动机制，肯定没法做到像手动回收那般精准高效[1] ，而且还会带来不少与垃圾回收实现相关的问题。</p>\n<p>接下来的两篇，我们会深入探索Java虚拟机中的垃圾回收器。今天这一篇，我们来回顾一下垃圾回收的基础知识。</p>\n<h2>引用计数法与可达性分析</h2>\n<p>垃圾回收，顾名思义，便是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。在Java虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。这里便涉及了一个关键的问题：如何辨别一个对象是存是亡？</p>\n<p>我们先来讲一种古老的辨别方法：引用计数法（reference counting）。它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。</p>\n<p>它的具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器+1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器-1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。</p><!-- [[[read_end]]] -->\n<p>除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。</p>\n<p>举个例子，假设对象a与b相互引用，除此之外没有其他引用指向a或者b。在这种情况下，a和b实际上已经死了，但由于它们的引用计数器皆不为0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/85/b9/8546a9b3c6660a31ae24bef0ef0a35b9.png?wh=1652*426\" alt=\"\" /></p>\n<p>目前Java虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列GC Roots作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p>\n<p>那么什么是GC Roots呢？我们可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots包括（但不限于）如下几种：</p>\n<ol>\n<li>Java方法栈桢中的局部变量；</li>\n<li>已加载类的静态变量；</li>\n<li>JNI handles；</li>\n<li>已启动且未停止的Java线程。</li>\n</ol>\n<p>可达性分析可以解决引用计数法所不能解决的循环引用问题。举例来说，即便对象a和b相互引用，只要从GC Roots出发无法到达a或者b，那么可达性分析便不会将它们加入存活对象合集之中。</p>\n<p>虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。</p>\n<p>比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为null）或者漏报（将引用设置为未被访问过的对象）。</p>\n<p>误报并没有什么伤害，Java虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致Java虚拟机崩溃。</p>\n<h2>Stop-the-world以及安全点</h2>\n<p>怎么解决这个问题呢？在Java虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。</p>\n<p>Java虚拟机中的Stop-the-world是通过安全点（safepoint）机制来实现的。当Java虚拟机收到Stop-the-world请求，它便会等待所有的线程都到达安全点，才允许请求Stop-the-world的线程进行独占的工作。</p>\n<p>这篇博客[2]还提到了一种比较另类的解释：安全词。一旦垃圾回收线程喊出了安全词，其他非垃圾回收线程便会一一停下。</p>\n<p>当然，安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。</p>\n<p>举个例子，当Java程序通过JNI执行本地代码时，如果这段代码不访问Java对象、调用Java方法或者返回至原Java方法，那么Java虚拟机的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。</p>\n<p>只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p>\n<p>由于本地代码需要通过JNI的API来完成上述三个操作，因此Java虚拟机仅需在API的入口处进行安全点检测（safepoint poll），测试是否有其他线程请求停留在安全点里，便可以在必要的时候挂起当前线程。</p>\n<p>除了执行JNI本地代码外，Java线程还有其他几种状态：解释执行字节码、执行即时编译器生成的机器码和线程阻塞。阻塞的线程由于处于Java虚拟机线程调度器的掌控之下，因此属于安全点。</p>\n<p>其他几种状态则是运行状态，需要虚拟机保证在可预见的时间内进入安全点。否则，垃圾回收线程可能长期处于等待所有线程进入安全点的状态，从而变相地提高了垃圾回收的暂停时间。</p>\n<p>对于解释执行来说，字节码与字节码之间皆可作为安全点。Java虚拟机采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。</p>\n<p>执行即时编译器生成的机器码则比较复杂。由于这些代码直接运行在底层硬件之上，不受Java虚拟机掌控，因此在生成机器码时，即时编译器需要插入安全点检测，以避免机器码长时间没有安全点检测的情况。HotSpot虚拟机的做法便是在生成代码的方法出口以及非计数循环的循环回边（back-edge）处插入安全点检测。</p>\n<p>那么为什么不在每一条机器码或者每一个机器码基本块处插入安全点检测呢？原因主要有两个。</p>\n<p>第一，安全点检测本身也有一定的开销。不过HotSpot虚拟机已经将机器码中安全点检测简化为一个内存访问操作。在有安全点请求的情况下，Java虚拟机会将安全点检测访问的内存所在的页设置为不可读，并且定义一个segfault处理器，来截获因访问该不可读内存而触发segfault的线程，并将它们挂起。</p>\n<p>第二，即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。在进入安全点时，机器码还需提供一些额外的信息，来表明哪些寄存器，或者当前栈帧上的哪些内存空间存放着指向对象的引用，以便垃圾回收器能够枚举GC Roots。</p>\n<p>由于这些信息需要不少空间来存储，因此即时编译器会尽量避免过多的安全点检测。</p>\n<p>不过，不同的即时编译器插入安全点检测的位置也可能不同。以Graal为例，除了上述位置外，它还会在计数循环的循环回边处插入安全点检测。其他的虚拟机也可能选取方法入口而非方法出口来插入安全点检测。</p>\n<p>不管如何，其目的都是在可接受的性能开销以及内存开销之内，避免机器码长时间不进入安全点的情况，间接地减少垃圾回收的暂停时间。</p>\n<p>除了垃圾回收之外，Java虚拟机其他一些对堆栈内容的一致性有要求的操作也会用到安全点这一机制。我会在涉及的时侯再进行具体的讲解。</p>\n<h2>垃圾回收的三种方式</h2>\n<p>当标记完所有的存活对象时，我们便可以进行死亡对象的回收工作了。主流的基础回收方式可分为三种。</p>\n<p>第一种是清除（sweep），即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/f2/03/f225126be24826658ca5a899fcff5003.png?wh=1668*540\" alt=\"\" /></p>\n<p>清除这种回收方式的原理及其简单，但是有两个缺点。一是会造成内存碎片。由于Java虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。</p>\n<p>另一个则是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。</p>\n<p>第二种是压缩（compact），即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/41/39/415ee8e4aef12ff076b42e41660dad39.png?wh=1676*532\" alt=\"\" /></p>\n<p>第三种则是复制（copy），即把内存区域分为两等分，分别用两个指针from和to来维护，并且只是用from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域中，并且交换from指针和to指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/47/61/4749cad235deb1542d4ca3b232ebf261.png?wh=1670*578\" alt=\"\" /></p>\n<p>当然，现代的垃圾回收器往往会综合上述几种回收方式，综合它们优点的同时规避它们的缺点。在下一篇中我们会详细介绍Java虚拟机中垃圾回收算法的具体实现。</p>\n<h2>总结与实践</h2>\n<p>今天我介绍了垃圾回收的一些基础知识。</p>\n<p>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。它从一系列GC Roots出发，边标记边探索所有被引用的对象。</p>\n<p>为了防止在标记过程中堆栈的状态发生改变，Java虚拟机采取安全点机制来实现Stop-the-world操作，暂停其他非垃圾回收线程。</p>\n<p>回收死亡对象的内存共有三种方式，分别为：会造成内存碎片的清除、性能开销较大的压缩、以及堆使用效率较低的复制。</p>\n<p>今天的实践环节，你可以体验一下无安全点检测的计数循环带来的长暂停。你可以分别测单独跑foo方法或者bar方法的时间，然后与合起来跑的时间比较一下。</p>\n<pre><code>\n// time java SafepointTestp\n/ 你还可以使用如下几个选项\n// -XX:+PrintGC\n// -XX:+PrintGCApplicationStoppedTime \n// -XX:+PrintSafepointStatistics\n// -XX:+UseCountedLoopSafepoints\npublic class SafepointTest {\n  static double sum = 0;\n\n  public static void foo() {\n    for (int i = 0; i &lt; 0x77777777; i++) {\n      sum += Math.sqrt(i);\n    }\n  }\n\n  public static void bar() {\n    for (int i = 0; i &lt; 50_000_000; i++) {\n      new Object().hashCode();\n    }\n  }\n\n  public static void main(String[] args) {\n    new Thread(SafepointTest::foo).start();\n    new Thread(SafepointTest::bar).start();\n  }\n}\n</code></pre>\n<p>[1] <a href=\"https://media.giphy.com/media/EZ8QO0myvsSk/giphy.gif\">https://media.giphy.com/media/EZ8QO0myvsSk/giphy.gif</a><br />\n[2] <a href=\"http://psy-lob-saw.blogspot.com/2015/12/safepoints.html\">http://psy-lob-saw.blogspot.com/2015/12/safepoints.html</a></p>\n<p></p>\n","comments":[{"had_liked":false,"id":20426,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":true,"comment_ctime":1534431841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233721629432996e+18","product_id":100010301,"comment_content":"非常感谢，此篇可用通俗易懂来形容，其他同学问的问题也很棒！<br><br>小结：<br><br>1:垃圾回收-核心工作就是回收垃圾，哪关键点回来了。什么是垃圾？这个垃圾需要分类嘛？怎么定位垃圾？怎么回收垃圾？回收垃圾的方法都有哪些？他们都有什么优缺点？另外，就是我们为什么要学习垃圾回收？<br><br>2:站在JVM的视角来看<br>垃圾-就是无用对象所占用的堆内存空间<br>貌似不需要垃圾分类，识别垃圾并回收就行<br>定位垃圾，是垃圾回收的关键点<br><br>晚安💤，明天继续写","like_count":30},{"had_liked":false,"id":22002,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":true,"comment_ctime":1535432878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233721071096996e+18","product_id":100010301,"comment_content":"赞，这种循序渐进的讲法，不知道了怎么工作，还知道了为啥要设计成这样，Why和what都和谐的在一起讲了","like_count":17},{"had_liked":false,"id":20447,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1534459083,"is_pvip":false,"replies":[{"id":"7445","content":"赞！","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534933774,"ip_address":"","comment_id":20447,"utype":1}],"discussion_count":6,"race_medal":0,"score":"181923085515","product_id":100010301,"comment_content":"非常感谢，此篇可用通俗易懂来形容，其他同学问的问题也很棒！<br><br>小结：<br><br>1:垃圾回收-核心工作就是回收垃圾，哪关键点回来了。什么是垃圾？这个垃圾需要分类嘛？怎么定位垃圾？怎么回收垃圾？回收垃圾的方法都有哪些？他们都有什么优缺点？另外，就是我们为什么要学习垃圾回收？<br><br>2:站在JVM的视角来看<br><br>垃圾-就是无用对象所占用的堆内存空间<br><br>垃圾分类-貌似不需要垃圾分类，识别垃圾并回收就行<br><br>定位垃圾-是垃圾回收的关键点，无用的对象占用的堆空间即是垃圾，那就需要先定位无用的对象，这里的无用是不再使用的意思，咋判断呢？文中介绍了两种方法，计数法和标记法（祥看原文）核心在于能定位出无用的对象，后出现的方法往往比早出现的更好一点，这里也一样，标记法能解决计数法，解决不了的循环引用不能回收的问题，但是也存在其他的问题，误报和漏报的问题，误报浪费点垃圾回收的机会浪费点空间，漏报在多线程并发工作时可能会死JVM的，所以，比较严重，所以，JVM采用了简单粗暴的stop-the-world的方式来对待，所以，老年代的回收有卡顿的现象<br><br>怎么回收垃圾-定位出垃圾，回收就是一个简单的事情了，当然也非常关键，把要回收的堆内存空间标记为可继续使用就行，下次有新对象能在此空间创建就行<br><br>回收垃圾的方法-文中介绍了三种，清除、压缩、复制<br><br>清除法-简单，但易产生碎片，可能总空间够但分配不了的问题<br>压缩法-能解决清除法的问题，但是复杂且耗性能<br>复制法-折衷一些，但是空间利用率低，总之，各有千秋<br><br>为什么要学-这个最容易，因为面试需要、装逼需要、升职加薪需要、人类天生好奇、还有免于被鄙视及可以鄙视其他人","like_count":43,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422250,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534933774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239365,"discussion_content":"stop the world不仅仅发生在老年代，新生代也会有的，只是时间长短不同","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587296246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227630,"discussion_content":"大佬, 我都看睡着了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586509321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293028,"discussion_content":"🐂🍺","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595416655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1097836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","nickname":"随心而至","note":"","ucode":"31866865255101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32015,"discussion_content":"“误报浪费点垃圾回收的机会浪费点空间，漏报在多线程并发工作时可能会死JVM的”， 这个是不是写反了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570978404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1357623,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJmBKrLvqOIXDDbj3ocEIJzqsQx2e5VLDBSX6LmofYtprWwKaVAmHUqU2z3mjREHX8n9eLLiavlPg/132","nickname":"wg1993","note":"","ucode":"D5112FEFDB1DF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1097836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","nickname":"随心而至","note":"","ucode":"31866865255101","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62566,"discussion_content":"live set中有A,B,C堆内存上有A,B,C,D。。。如果误报D也报上去，D无法回收。如果漏报了A，即A可能会被回收。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574852250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":32015,"ip_address":""},"score":62566,"extra":""}]}]},{"had_liked":false,"id":22463,"user_name":"Geek_488a8e","can_delete":false,"product_type":"c1","uid":1184696,"ip_address":"","ucode":"2B767F53DB902F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erozFScHpVRM5OCwMW7giaM13NE7gN5iatw9Ozwu93ibRZZjmSmcfzBLSXs8tYtwW7Q2E8eUdy9lGl5A/132","comment_is_top":false,"comment_ctime":1535688001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"173334379841","product_id":100010301,"comment_content":"误报和漏报，我觉得可惜这样理解，垃圾回收是先标记活的对象，后回收死的对象，那么如果标记好后，其它线程产生了垃圾，即将活的变死了，这种内存是不会释放的。另外，如果这时产生了新对象，由于没被标记为活的，所以被释放了，这就危险了","like_count":39},{"had_liked":false,"id":20172,"user_name":"茶底","can_delete":false,"product_type":"c1","uid":1188926,"ip_address":"","ucode":"687DD3686A84D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/3e/692a93f7.jpg","comment_is_top":false,"comment_ctime":1534297469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"138973250941","product_id":100010301,"comment_content":"老师下一期能讲一下g1算法吗。讲深一点😁","like_count":32},{"had_liked":false,"id":20448,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1534459469,"is_pvip":false,"replies":[{"id":"7455","content":"1. 采用并行GC可以减少需要STW的时间。它们会在即时编译器生成的代码中加入写屏障或者读屏障。<br><br>2. Y轴应该是时间，那毛刺就是长暂停。一般Full GC就会造成长暂停。<br><br>3. 通过调整新生代大小，使对象在其生命周期内都待在新生代中。这样一来，Minor GC时就可以收集完这些短命对象了。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534937891,"ip_address":"","comment_id":20448,"utype":1}],"discussion_count":3,"race_medal":0,"score":"113203609165","product_id":100010301,"comment_content":"疑问❓<br>1:JVM的stop-the-world机制非常不友好，有哪些解决之道？原理是什么？<br>2:压测时出现频繁的gc容易理解，但是有时出现毛刺是因为什么呢？<br>3:fullgc有卡顿，对性能很不利，怎么避免呢？","like_count":27,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422251,"discussion_content":"1. 采用并行GC可以减少需要STW的时间。它们会在即时编译器生成的代码中加入写屏障或者读屏障。\n\n2. Y轴应该是时间，那毛刺就是长暂停。一般Full GC就会造成长暂停。\n\n3. 通过调整新生代大小，使对象在其生命周期内都待在新生代中。这样一来，Minor GC时就可以收集完这些短命对象了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1534937891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54395,"discussion_content":"很好奇JVM是怎么回事，不会的太多啦😅","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574298023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1164626,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c5/52/63008fc7.jpg","nickname":"xuwei","note":"","ucode":"07268C1743839F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53865,"discussion_content":"你提的问题不错，经常看到你的评论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574226251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73212,"user_name":"suynan","can_delete":false,"product_type":"c1","uid":1023214,"ip_address":"","ucode":"0AAD1BA9D22D2C","user_header":"","comment_is_top":false,"comment_ctime":1551841075,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"96041121587","product_id":100010301,"comment_content":"安全点的这个地方，看得我是一脸懵逼","like_count":23,"discussions":[{"author":{"id":1100387,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ca/63/9be9ac89.jpg","nickname":"Allen","note":"","ucode":"5B168A03809557","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409012,"discussion_content":"需要先理解准确式gc和oopmap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635350300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23792,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1536657827,"is_pvip":false,"replies":[{"id":"8719","content":"这是C2一个诡异的地方。<br><br>for (int i=start; i&lt;limit; i++) {..}<br><br>对于int类型的循环变量i，如果满足 1) 基于该循环变量的循环出口只有一个，即i &lt; limit，2) 循环变量随着迭代的增量为常数，例子中i++即增量为1，以及循环变量的上限(当增量为负数时则是下限)为循环无关的，即limit应是循环无关，那么C2会将其判断成计数循环(counted loop)，然后默认不插入safepoint。<br><br>而对于long类型的循环变量，C2直接识别为非计数循环，需要插入safepoint。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1536680031,"ip_address":"","comment_id":23792,"utype":1}],"discussion_count":3,"race_medal":0,"score":"61666199971","product_id":100010301,"comment_content":"老师你好，例子里的foo方法中的for循环，其中i变量类型我从int型改成long型后，长暂停的现象不存在了，请问是为何？","like_count":15,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423729,"discussion_content":"这是C2一个诡异的地方。\n\nfor (int i=start; i&amp;lt;limit; i++) {..}\n\n对于int类型的循环变量i，如果满足 1) 基于该循环变量的循环出口只有一个，即i &amp;lt; limit，2) 循环变量随着迭代的增量为常数，例子中i++即增量为1，以及循环变量的上限(当增量为负数时则是下限)为循环无关的，即limit应是循环无关，那么C2会将其判断成计数循环(counted loop)，然后默认不插入safepoint。\n\n而对于long类型的循环变量，C2直接识别为非计数循环，需要插入safepoint。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1536680031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415448,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","nickname":"二饼","note":"","ucode":"48120565D135F7","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574998,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654515746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351148,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","nickname":"ppyh","note":"","ucode":"14022ADEC9B53F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390228,"discussion_content":"牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629722038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":27987,"user_name":"浪迹江湖","can_delete":false,"product_type":"c1","uid":1129422,"ip_address":"","ucode":"514459670AC242","user_header":"https://static001.geekbang.org/account/avatar/00/11/3b/ce/88bf2008.jpg","comment_is_top":false,"comment_ctime":1537973127,"is_pvip":false,"replies":[{"id":"10304","content":"赞想法！不过我认为没有达到更好的回收效率，因为垃圾回收标记的是非垃圾，剩余没有标记的对象是垃圾。用引用计数法清理后，可达性分析仍需遍历所有活着的对象。<br><br>但是可以将引用计数做成minor minor GC，只有当引用计数回收不了垃圾时，再触发可达性分析。感兴趣的话可以深入探索一下业界其他非Java runtime的垃圾回收算法。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1538117167,"ip_address":"","comment_id":27987,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44487646087","product_id":100010301,"comment_content":"突发奇想：如果 GC 将引用计数算法和可达性分析算法结合起来使用会怎样？<br><br>循环引用毕竟是少数，如果先用引用计数算法回收掉大部分对象，再对剩余的小部分对象采用可达性分析算法解决循环引用问题。可能比只使用可达性分析算法带来更好的回收效率。","like_count":11,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425106,"discussion_content":"赞想法！不过我认为没有达到更好的回收效率，因为垃圾回收标记的是非垃圾，剩余没有标记的对象是垃圾。用引用计数法清理后，可达性分析仍需遍历所有活着的对象。\n\n但是可以将引用计数做成minor minor GC，只有当引用计数回收不了垃圾时，再触发可达性分析。感兴趣的话可以深入探索一下业界其他非Java runtime的垃圾回收算法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1538117167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68106,"user_name":"jiaobuchongจุ๊บ","can_delete":false,"product_type":"c1","uid":1118938,"ip_address":"","ucode":"0AEE4E579DC3A2","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/da/a3ea305f.jpg","comment_is_top":false,"comment_ctime":1550413545,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"35910151913","product_id":100010301,"comment_content":"1、文中所说的误报和漏报是不是说反了啊，<br>     并发环境下标记完后，线程将引用改成 null，导致损失了部分垃圾回收的机会，这是属于漏报吧？<br>     已标记，然后将引用设置为未被访问过的对象，导致回收了仍被引用的内存，这个属于误报吧？<br>2、在标记的过程中，是不是只需要记录存活的对象就行，不用标记垃圾对象，后续在执行回收算法的时候，也只是在操作已经标记的存活的对象？","like_count":8,"discussions":[{"author":{"id":1181206,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","nickname":"滴答丶滴","note":"","ucode":"2093C2948B4327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389267,"discussion_content":"回收的是未被标记的对象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629197247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670763,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","nickname":"FIRE","note":"","ucode":"85861D990FB3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318411,"discussion_content":"我也这么认为的,请问你现在搞清楚了吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603726001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1181206,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","nickname":"滴答丶滴","note":"","ucode":"2093C2948B4327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1670763,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","nickname":"FIRE","note":"","ucode":"85861D990FB3AB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389266,"discussion_content":"存活的对象才需要标记，保存到live set集合\n垃圾对象，不需要标记","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629197163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318411,"ip_address":""},"score":389266,"extra":""}]}]},{"had_liked":false,"id":122287,"user_name":"　素丶　　","can_delete":false,"product_type":"c1","uid":1081535,"ip_address":"","ucode":"883B7EDBE76104","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/bf/3041138b.jpg","comment_is_top":false,"comment_ctime":1565329972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31630101044","product_id":100010301,"comment_content":"结合 Rx 的回答容易帮助理解。<br>https:&#47;&#47;www.zhihu.com&#47;question&#47;53613423&#47;answer&#47;135743258","like_count":7},{"had_liked":false,"id":49485,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1544696248,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"27314500024","product_id":100010301,"comment_content":"@茶底，这是我写的G1学习笔记：https:&#47;&#47;www.jianshu.com&#47;p&#47;a3e6a9de7a5d","like_count":6,"discussions":[{"author":{"id":1455919,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/2f/f2793fe6.jpg","nickname":"破晓","note":"","ucode":"B9504A4D36AA9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324114,"discussion_content":"404了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605058782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20536,"user_name":"WolvesLeader","can_delete":false,"product_type":"c1","uid":1103839,"ip_address":"","ucode":"33610E19CA2E96","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/df/fc0a6709.jpg","comment_is_top":false,"comment_ctime":1534514914,"is_pvip":false,"replies":[{"id":"7331","content":"目前的垃圾回收器多多少少需要stop the world，但都在朝着尽量减少STW时间发展。<br><br>完全的并发GC算法是存在的，但是在实现上一般都会在枚举GC roots时进行STW。<br><br>","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534779530,"ip_address":"","comment_id":20536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27304318690","product_id":100010301,"comment_content":"很是不明白，我的理解有没有stop the word 是和垃圾回收器有关的，看完之后怎么觉得您的意思是，不管什么垃圾回收器都会出现stop the word","like_count":7,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422291,"discussion_content":"目前的垃圾回收器多多少少需要stop the world，但都在朝着尽量减少STW时间发展。\n\n完全的并发GC算法是存在的，但是在实现上一般都会在枚举GC roots时进行STW。\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1534779530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20217,"user_name":"正是那朵玫瑰","can_delete":false,"product_type":"c1","uid":1048261,"ip_address":"","ucode":"73D630B654573F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/c5/3467cf94.jpg","comment_is_top":false,"comment_ctime":1534314702,"is_pvip":false,"replies":[{"id":"7058","content":"这里指的是，GC已经标记完成，然后其他线程进行修改的情况(也是并发GC所要解决的问题)。<br><br>当GC标记完成，还未开始回收时，你更新了其中一个引用，使之指向null，那么原来指向的对象本可以被回收的。<br><br>如果指向一个新的对象，这个对象可没有被标记为不能回收，垃圾回收器就直接给回收掉了","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534322227,"ip_address":"","comment_id":20217,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27304118478","product_id":100010301,"comment_content":"老师有几个不明白的地方，误报和漏报不太明白：<br>1、假设A引用开始指向A1对象：A------&gt;A1,按老师说的误报就是将引用A指向null：A------&gt;null，那么此时A1对象不是没有引用了，不就可以垃圾回收了么，为什么会错过垃圾回收的机会呢？<br>2、漏报，是将A引用指向一个未被访问的对象假设对象为B：A-----&gt;B,此时A引用原来指向的对象应该没有引用了吧，为什么会垃圾回收器可能会回收事实上仍被引用的对象呢？","like_count":6,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422156,"discussion_content":"这里指的是，GC已经标记完成，然后其他线程进行修改的情况(也是并发GC所要解决的问题)。\n\n当GC标记完成，还未开始回收时，你更新了其中一个引用，使之指向null，那么原来指向的对象本可以被回收的。\n\n如果指向一个新的对象，这个对象可没有被标记为不能回收，垃圾回收器就直接给回收掉了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1534322227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20252,"user_name":"彩色的沙漠","can_delete":false,"product_type":"c1","uid":1116183,"ip_address":"","ucode":"19A0975A5E69EA","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/17/e63e50f3.jpg","comment_is_top":false,"comment_ctime":1534336486,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"23009172966","product_id":100010301,"comment_content":"@正是那朵玫瑰老师有几个不明白的地方，误报和漏报不太明白：<br>1、假设A引用开始指向A1对象：A------&gt;A1,按老师说的误报就是将引用A指向null：A------&gt;null，那么此时A1对象不是没有引用了，不就可以垃圾回收了么，为什么会错过垃圾回收的机会呢？<br>2、漏报，是将A引用指向一个未被访问的对象假设对象为B：A-----&gt;B,此时A引用原来指向的对象应该没有引用了吧，为什么会垃圾回收器可能会回收事实上仍被引用的对象呢？<br><br>2018-08-15<br><br> 作者回复<br><br>这里指的是，GC已经标记完成，然后其他线程进行修改的情况(也是并发GC所要解决的问题)。<br><br>当GC标记完成，还未开始回收时，你更新了其中一个引用，使之指向null，那么原来指向的对象本可以被回收的。<br><br>如果指向一个新的对象，这个对象可没有被标记为不能回收，垃圾回收器就直接给回收掉了<br><br>老师我也有和@正是那朵玫瑰一样的问题，看了老师的讲解，还是不太明白。GC标记完成，那GC标记的是引用还是具体的堆空间对象。如果标记的具体的堆空间对象，并不会造成GC并发问题，误报和漏报，改变的是引用关系。请老师解答，谢谢！","like_count":5,"discussions":[{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260035,"discussion_content":"1、标记的是可达的对象，所以不会标记引用，因为不可达的对象是没有引用的。\n2、并发是指的工作线程，在没有stw的情况下，会造成gc标记完了，但是工作线程仍对对象作了修改，并非gc线程并发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588842326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1931692,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/VjomKNzfFiaIttqYMxbjAWTG7NL7P2UqC5fbSvg0JW80SLnoR2oH1G4U2eibmxbR4wPpoqZdDnjC8GqgShDOBRzA/132","nickname":"秦伟","note":"","ucode":"D47C1F57500FE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221194,"discussion_content":"老师表示，我也不懂哈哈！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585988187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104575,"user_name":"same old love","can_delete":false,"product_type":"c1","uid":1184899,"ip_address":"","ucode":"31D733024AA5B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/14/83/f61840e5.jpg","comment_is_top":false,"comment_ctime":1560777840,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18740647024","product_id":100010301,"comment_content":"我有个疑问，就是JVM回收掉对象以后，存活下来对象的内存地址值会不会改变","like_count":4,"discussions":[{"author":{"id":1548645,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","nickname":"Hi Young","note":"","ucode":"E1E9C88399F3C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158178,"discussion_content":"垃圾回收方式中的 标记压缩 和 复制，都涉及到内存对象的搬迁。如果对象被搬迁，对象地址一定变更，同时 引用 指向的对象地址 需要变更","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580559640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28977,"user_name":"Jussi Lee","can_delete":false,"product_type":"c1","uid":1211190,"ip_address":"","ucode":"F2F5948CCD52A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/36/fd46331c.jpg","comment_is_top":false,"comment_ctime":1538212504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18718081688","product_id":100010301,"comment_content":"一、垃圾回收算法<br>      1、引用计数法（文中已经介绍，主要的缺点是无法处理循环引用；在每次引用的产生和消除的时候，会伴随着一个加法或者减法的操作，对性能有一定的影响）<br>      2、标记清除法（从根节点出发开始所有可达的对象，未被标记的就是垃圾对象。主要缺点是产生空间碎片）<br>      3、复制算法（将原空间分为两块，每次使用其中一块，在垃圾回收时，进行复制，然后转换使用的内存空间。主要的缺点是将系统的内存折半。主要适用于存活对象少，垃圾对象多的情况下）<br>      4、标记压缩法（从根出发对所有可达对象进行一次标记，然后进行压缩。最后进行清理）<br>      5、分代算法（每一种垃圾回收算法都有其优缺点。分代算法是根据对象的特点分成几块，新建的对象放入新生代区域，当一个对象经历了几次复制后还存活则放入老年代。老年代因为对象存活率高复制算法不适用，因此采取标记清除或者标记压缩）<br>      6、分区算法（把堆空间划分为连续的不同小区间。降低了GC产生的影响）","like_count":5},{"had_liked":false,"id":20173,"user_name":"茶底","can_delete":false,"product_type":"c1","uid":1188926,"ip_address":"","ucode":"687DD3686A84D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/3e/692a93f7.jpg","comment_is_top":false,"comment_ctime":1534297470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18714166654","product_id":100010301,"comment_content":"老师下一期能讲一下g1算法吗。讲深一点😁","like_count":4},{"had_liked":false,"id":32637,"user_name":"life is short, enjoy more.","can_delete":false,"product_type":"c1","uid":1074805,"ip_address":"","ucode":"3B5F37D30790A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg","comment_is_top":false,"comment_ctime":1539655071,"is_pvip":false,"replies":[{"id":"11922","content":"确实是需要复制数据，这样起名主要是为了区分复制到同一个区域中(需要复杂的算法保证引用能够正确更新)，还是复制到另一个区域中(可以复制完后统一更新引用)。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1539681069,"ip_address":"","comment_id":32637,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14424556959","product_id":100010301,"comment_content":"老师，我心中有一个疑惑。<br>压缩算法是不是也用到了复制呢？因为我觉得在压缩的过程中，也需要把存活的内存进行转移，而转移也就是复制吧？<br>麻烦老师给回答一下~","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426844,"discussion_content":"确实是需要复制数据，这样起名主要是为了区分复制到同一个区域中(需要复杂的算法保证引用能够正确更新)，还是复制到另一个区域中(可以复制完后统一更新引用)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539681069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168543,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1578106728,"is_pvip":false,"replies":[{"id":"65410","content":"误报是指可达性分析误认为某个对象是可达的，实际不可达。漏报是指可达性分析没有发现某个对象可达。<br><br>这里需要明确，可达性分析会找出非垃圾，而其他对象通通被认为是垃圾。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1578180396,"ip_address":"","comment_id":168543,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10168041320","product_id":100010301,"comment_content":"老师，以下这段话是不是有误？ 误报和漏报反了！ 漏报应该是没有什么伤害，会让GC损失部分垃圾回收的机会。误报才比较麻烦，可能回收仍被引用的对象！！<br>“误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。”<br><br>","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480245,"discussion_content":"误报是指可达性分析误认为某个对象是可达的，实际不可达。漏报是指可达性分析没有发现某个对象可达。\n\n这里需要明确，可达性分析会找出非垃圾，而其他对象通通被认为是垃圾。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578180396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1154138,"avatar":"","nickname":"ticmy","note":"","ucode":"AD2A22DF2DBAE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389077,"discussion_content":"这个解释就很清楚了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629110059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670763,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","nickname":"FIRE","note":"","ucode":"85861D990FB3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318417,"discussion_content":"HA,终于明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603726997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118654,"discussion_content":"明白了，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578182928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20694,"user_name":"黑崽","can_delete":false,"product_type":"c1","uid":1024159,"ip_address":"","ucode":"F31A4102EE4DA8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/9f/71345740.jpg","comment_is_top":false,"comment_ctime":1534672700,"is_pvip":false,"replies":[{"id":"7460","content":"在GC时，我们需要知道哪个寄存器，以及哪个栈内存空间存放了指向对象的引用。这个信息需要记录下来。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534938940,"ip_address":"","comment_id":20694,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10124607292","product_id":100010301,"comment_content":"第二，即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。没明白这个原因。第一个原因中解释，只要去访问一个内存地址就可以知道是不是要暂停了，那我只有判断完暂停以后再去恢复寄存器中状态不就可以了？反正只有一次，这个打乱不打乱有什么区别呢？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422364,"discussion_content":"在GC时，我们需要知道哪个寄存器，以及哪个栈内存空间存放了指向对象的引用。这个信息需要记录下来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534938940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20207,"user_name":"no13bus","can_delete":false,"product_type":"c1","uid":1185046,"ip_address":"","ucode":"69FA1A719DA4F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/16/0aae41a1.jpg","comment_is_top":false,"comment_ctime":1534308973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10124243565","product_id":100010301,"comment_content":"昨天看书正好看到这章节，真的不错","like_count":2},{"had_liked":false,"id":220088,"user_name":"向南","can_delete":false,"product_type":"c1","uid":2007213,"ip_address":"","ucode":"F4D2AB9D5DDFD9","user_header":"","comment_is_top":false,"comment_ctime":1590152320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885119616","product_id":100010301,"comment_content":"循序渐进，讲的非常好，值得反复看","like_count":1},{"had_liked":false,"id":21705,"user_name":"山哥","can_delete":false,"product_type":"c1","uid":1172679,"ip_address":"","ucode":"7C8585B021CAC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/e4/c7/7f8be879.jpg","comment_is_top":false,"comment_ctime":1535260962,"is_pvip":false,"replies":[{"id":"7813","content":"这个是建立在没有stop the world，没有做好同步的前提下的，实际虚拟机并不会。<br><br>具体就是垃圾回收过程中，应用线程还在改堆里的内容，线程垃圾回收标记存活对象的结果有误。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535357448,"ip_address":"","comment_id":21705,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5830228258","product_id":100010301,"comment_content":"多线程为什么会导致误报，漏报？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422820,"discussion_content":"这个是建立在没有stop the world，没有做好同步的前提下的，实际虚拟机并不会。\n\n具体就是垃圾回收过程中，应用线程还在改堆里的内容，线程垃圾回收标记存活对象的结果有误。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535357448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20719,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1534689913,"is_pvip":false,"replies":[{"id":"7435","content":"确实。一般需要用C实现的代码逻辑都是Java层面无法实现的了，没有办法才选择牺牲平台无关性。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534932699,"ip_address":"","comment_id":20719,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5829657209","product_id":100010301,"comment_content":"老师，想问个题外题:<br>关于安全点的选择，有一处为JNI执行本地方法。那么，既然java是跨平台的语言，可是它又调用本地方法，本地方法用c实现的，这不就破坏了其平台无关性吗？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422378,"discussion_content":"确实。一般需要用C实现的代码逻辑都是Java层面无法实现的了，没有办法才选择牺牲平台无关性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534932699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239375,"discussion_content":"我倒是觉得没有牺牲平台无关性，平台无关性指的是我们开发者开发的应用代码可以做到移植方便，JNI可以看成虚拟机的一部分，每种平台不都有自己对应的虚拟机版本么","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587297099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20471,"user_name":"仰望","can_delete":false,"product_type":"c1","uid":1182995,"ip_address":"","ucode":"9EF2F2E672EAF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/0d/13/d67b2a1a.jpg","comment_is_top":false,"comment_ctime":1534467276,"is_pvip":false,"replies":[{"id":"7457","content":"就是从GC roots出发，穷举所有可达的对象，并且标记成可达的。剩下的对象就是不可达的。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534938085,"ip_address":"","comment_id":20471,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5829434572","product_id":100010301,"comment_content":"“举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 出发无法到达 a 或者 b，”<br>这个如何判断的？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422259,"discussion_content":"就是从GC roots出发，穷举所有可达的对象，并且标记成可达的。剩下的对象就是不可达的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534938085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20339,"user_name":"风动静泉","can_delete":false,"product_type":"c1","uid":1113190,"ip_address":"","ucode":"34DEF4FF06A491","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/66/d7f7ad77.jpg","comment_is_top":false,"comment_ctime":1534384249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5829351545","product_id":100010301,"comment_content":"有个内存泄露相关的问题想请教一下老师。<br>基本描述:<br>一个单线程的程序中，在其run方法中有局部变量（map  list等类型），也使用了该线程类ThreadDemo的全局变量（map），线程中会去执行ftp任务（同步）。<br><br>问题：<br>如果ftp任务由于某种原因阻塞了，调用ftp任务的线程ThreadDemo中的变量（局部变量和全局变量）会变成不可达状态吗？还是说此时线程也阻塞，会导致内存泄露？","like_count":1},{"had_liked":false,"id":20213,"user_name":"Void_seT","can_delete":false,"product_type":"c1","uid":1070863,"ip_address":"","ucode":"DD55CB0198A5CD","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/0f/1f229bf5.jpg","comment_is_top":false,"comment_ctime":1534312131,"is_pvip":false,"replies":[{"id":"7056","content":"厉害！这都看得出来！是Math.log10(i)，不过这个时间太长了，我新版本的代码是sqrt 。然后不知怎么给回滚到这个log10，而且还是乱的","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534321665,"ip_address":"","comment_id":20213,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5829279427","product_id":100010301,"comment_content":"猜一下，作业里面的应该是Math.log(10)","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422152,"discussion_content":"厉害！这都看得出来！是Math.log10(i)，不过这个时间太长了，我新版本的代码是sqrt 。然后不知怎么给回滚到这个log10，而且还是乱的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534321665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20194,"user_name":"明天更美好","can_delete":false,"product_type":"c1","uid":1180696,"ip_address":"","ucode":"F036B8718938BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/18/4b02510f.jpg","comment_is_top":false,"comment_ctime":1534303384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5829270680","product_id":100010301,"comment_content":"总算可以听的懂了","like_count":1},{"had_liked":false,"id":339271,"user_name":"כן אני אמריקאי","can_delete":false,"product_type":"c1","uid":1527429,"ip_address":"","ucode":"56C5C2B369121B","user_header":"https://static001.geekbang.org/account/avatar/00/17/4e/85/ef0108cd.jpg","comment_is_top":false,"comment_ctime":1648018595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648018595","product_id":100010301,"comment_content":"垃圾回收的目的，时间，内容，怎么判定对象死亡等等，自己做了详细的总结，欢迎大家阅读：https:&#47;&#47;juejin.cn&#47;post&#47;7074953090582970382","like_count":0},{"had_liked":false,"id":310373,"user_name":"明明如月","can_delete":false,"product_type":"c1","uid":2697683,"ip_address":"","ucode":"937488EEAA522E","user_header":"https://static001.geekbang.org/account/avatar/00/29/29/d3/b193a463.jpg","comment_is_top":false,"comment_ctime":1630634498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630634498","product_id":100010301,"comment_content":"隔离性，垃圾回收器分析JVM堆栈进行可达性分析后，不希望其他进程修改JVM堆栈的内容。安全点检查是中断信号，不让非垃圾回收线程修改JVM堆栈内容。其实相当于数据库里给这个JVM堆栈这些变量加排他锁。","like_count":0},{"had_liked":false,"id":310202,"user_name":"明明如月","can_delete":false,"product_type":"c1","uid":2697683,"ip_address":"","ucode":"937488EEAA522E","user_header":"https://static001.geekbang.org/account/avatar/00/29/29/d3/b193a463.jpg","comment_is_top":false,"comment_ctime":1630547441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630547441","product_id":100010301,"comment_content":"引用是什么？<br>","like_count":0},{"had_liked":false,"id":298380,"user_name":"Geek_169647","can_delete":false,"product_type":"c1","uid":2636193,"ip_address":"","ucode":"B3ABD13467983B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0uyg1IicbEhNzuuUz54sicQicVUKB0yibThmyl3RqXTdj3PrgdiaHEvgskThsxxnSaib9pGYXD1X2gKTQ/132","comment_is_top":false,"comment_ctime":1624070761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624070761","product_id":100010301,"comment_content":"这里没看懂，请教下。<br>原文:  [误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会] <br>问题: 误报,即将对象的引用置为null。这个时候GC ROOT 集合中，为被引用的对象，就会面临被回收。<br>        所以，误报的影响不是[损失了部分垃圾回收的机会], 而是相反被回收的危险吧。<br>","like_count":0},{"had_liked":false,"id":272254,"user_name":"coderkeep","can_delete":false,"product_type":"c1","uid":1129178,"ip_address":"","ucode":"29EE99F8F19F2E","user_header":"https://static001.geekbang.org/account/avatar/00/11/3a/da/7f9cbbd1.jpg","comment_is_top":false,"comment_ctime":1610006805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610006805","product_id":100010301,"comment_content":"看完这篇把GC的各种知识串起来了","like_count":0},{"had_liked":false,"id":238846,"user_name":"Dougleas","can_delete":false,"product_type":"c1","uid":1127312,"ip_address":"","ucode":"FF22E2E7C5BA30","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/90/900ce74c.jpg","comment_is_top":false,"comment_ctime":1596341857,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1596341857","product_id":100010301,"comment_content":"老师好，我想问下为什么堆中对象分布必须是连续的。 如果连续的话，是物理上连续还是逻辑上连续","like_count":0},{"had_liked":false,"id":217265,"user_name":"慌张而黑糖","can_delete":false,"product_type":"c1","uid":1638878,"ip_address":"","ucode":"B4416885A301C8","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","comment_is_top":false,"comment_ctime":1589451093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589451093","product_id":100010301,"comment_content":" “GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。”对于这一段有一点疑问，就是当下次做可达性分析时，是依旧使用GC Roots作为初始的存活对象合集进行可达性分析，还是说使用上次已经探索到并加入到集合中的所有对象作为这次可达性分析的初始存活对象合集","like_count":0},{"had_liked":false,"id":216961,"user_name":"javaworker","can_delete":false,"product_type":"c1","uid":1056209,"ip_address":"","ucode":"ABF9DDDBD3BDBF","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/d1/f427b83e.jpg","comment_is_top":false,"comment_ctime":1589377874,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589377874","product_id":100010301,"comment_content":"老师，请教个问题，公司用的IBM的jdk1.6，启动参数-Xms1024m -Xmx3072m，但是JVM却总是频繁的FullGC，看GC参数，堆内存只用了1024M，就是不扩容到3072M。自己写了个测试类，启动参数 -Xms4m -Xmx10m，发现测试类是会扩容堆内存的，为什么到生产上就不扩容堆内存了呐？","like_count":0},{"had_liked":false,"id":216567,"user_name":"Q罗","can_delete":false,"product_type":"c1","uid":1792098,"ip_address":"","ucode":"E797378F4DA1F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/58/62/346dd248.jpg","comment_is_top":false,"comment_ctime":1589285369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589285369","product_id":100010301,"comment_content":"这篇讲解太精彩了，之前一直搞不清楚垃圾回收机制，面试老被问倒","like_count":0},{"had_liked":false,"id":190698,"user_name":"悟空WuKong","can_delete":false,"product_type":"c1","uid":1139455,"ip_address":"","ucode":"49AFD2B048C1BA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","comment_is_top":false,"comment_ctime":1584684242,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1584684242","product_id":100010301,"comment_content":"不知道老师还能不能看到，想问您一个问题，局部变量引用的对象，什么时机回收。如果我在方法内把变量赋值为null，它原来引用的对象什么时候回收？","like_count":0,"discussions":[{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239377,"discussion_content":"这个要看GCRoots什么时候做标记了，可能最近的一次新生代GC就回收掉了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587297332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1139455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","nickname":"悟空WuKong","note":"","ucode":"49AFD2B048C1BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239548,"discussion_content":"👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587303036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":239377,"ip_address":""},"score":239548,"extra":""}]}]},{"had_liked":false,"id":182109,"user_name":"hello!","can_delete":false,"product_type":"c1","uid":1013512,"ip_address":"","ucode":"4E54993102BD98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/08/ea7f9119.jpg","comment_is_top":false,"comment_ctime":1582710665,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582710665","product_id":100010301,"comment_content":"实践环节的部分选项在 Java 9 之后已经不适用了","like_count":0},{"had_liked":false,"id":168798,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1578188628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578188628","product_id":100010301,"comment_content":"不得不说，文章的几张图“真好看”","like_count":0},{"had_liked":false,"id":168544,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1578106988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578106988","product_id":100010301,"comment_content":"老师，你提到：「在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。」<br><br>那既然有这个问题，现在的虚拟机中，使用什么样的方法呢？？","like_count":0},{"had_liked":false,"id":153375,"user_name":"xuwei","can_delete":false,"product_type":"c1","uid":1164626,"ip_address":"","ucode":"07268C1743839F","user_header":"https://static001.geekbang.org/account/avatar/00/11/c5/52/63008fc7.jpg","comment_is_top":false,"comment_ctime":1574226176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574226176","product_id":100010301,"comment_content":"看第二遍，收获更大","like_count":0},{"had_liked":false,"id":145673,"user_name":"蒋波","can_delete":false,"product_type":"c1","uid":1526325,"ip_address":"","ucode":"611A1F0629F08E","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/35/16861bf8.jpg","comment_is_top":false,"comment_ctime":1572341436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572341436","product_id":100010301,"comment_content":"郑老师，想请教一个小白的问题，麻烦帮忙解答一下:A方法调用B方法,B方法调用C方法<br>当B方法内定义的局部对象list2被赋值为C方法内定义的局部对象list3，A方法内的定义局部list1对象被赋值为B方法内的list2对象，A方法执行完后，把list1清空并赋值为了null，list2和list3会和list1一同被回收吗？","like_count":0},{"had_liked":false,"id":143280,"user_name":"杨杨杨杨、","can_delete":false,"product_type":"c1","uid":1461885,"ip_address":"","ucode":"A736A9BB3FD506","user_header":"https://static001.geekbang.org/account/avatar/00/16/4e/7d/b34f5251.jpg","comment_is_top":false,"comment_ctime":1571660518,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571660518","product_id":100010301,"comment_content":"老师你好，请问下在判断对象是否可回收的过程中会扫描GCroots,深入jvm中说不会扫描所有的GCroot，这块是怎么实现的，能否解释一下，一直没搞懂","like_count":0},{"had_liked":false,"id":132621,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1568174486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568174486","product_id":100010301,"comment_content":"---总结---<br>安全点：在JVM收到STW请求时需要等所有线程到达的一种安全状态。<br>各种线程状态达到安全点的方式：执行JNI本地代码、阻塞中的线程、解释执行中字节码与字节码的执行之间、即时编译器生成的机器码在生成代码的方法出口以及非计数循环的循环回边插入安全点检测<br><br><br>---问题---<br>1. ”JVM收到STW请求“，这里这个请求是谁给出的呢？<br>2. 多线程环境下误报和漏报没太看明白，设置为null或其他对象不是某线程正确场景下的动作吗？","like_count":0},{"had_liked":false,"id":120959,"user_name":"ward-wolf","can_delete":false,"product_type":"c1","uid":1031845,"ip_address":"","ucode":"BC41D01301263A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/a5/df917d18.jpg","comment_is_top":false,"comment_ctime":1565018716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565018716","product_id":100010301,"comment_content":"老师您好，为什么你给示例代码“无安全点检测”？你的代码上给jvm参数只是打印一些信息而已。","like_count":0},{"had_liked":false,"id":89526,"user_name":"闪客sun","can_delete":false,"product_type":"c1","uid":1029087,"ip_address":"","ucode":"3A5EA304A1EF27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/df/0fabb233.jpg","comment_is_top":false,"comment_ctime":1556196129,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1556196129","product_id":100010301,"comment_content":"老师您好，关于“在多线程环境下，其他线程可能会更新已经访问过的对象中的引用”，这句没太理解，网上查资料也没找到好答案。您可以帮我看看这块该怎么理解么？","like_count":0,"discussions":[{"author":{"id":1548645,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","nickname":"Hi Young","note":"","ucode":"E1E9C88399F3C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158204,"discussion_content":"在多线程环境下，其他工作线程 可能会更新 GC线程已经访问过的对象中的 引用。引起问题如下\n    a. GC线程误报，死亡对象 被标记为 存活，本次不回收，影响较小\n        ⅰ. GC线程 将对象A标记存活，之后 工作线程 将 对象A的引用 指向 其它值，此时 对象A没有被引用，可被回收\n    b. GC线程漏报，被引用的对象 没有被标记 为 存活，可能被进行垃圾回收，引用 访问 被回收对象 时，可能导致JVM崩溃\n        ⅰ. GC线程 未将对象A标记存活，之后 工作线程 将 引用 指向 未被访问的对象A，此时 对象A被引用，不可被回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580561219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88623,"user_name":"fcb的鱼","can_delete":false,"product_type":"c1","uid":1243901,"ip_address":"","ucode":"88667EBF09CEC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","comment_is_top":false,"comment_ctime":1555975296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555975296","product_id":100010301,"comment_content":"为啥作为GC Roots 的对象是那几种呢，这里有什么讲究吗？！","like_count":0},{"had_liked":false,"id":82075,"user_name":"NoSecondero","can_delete":false,"product_type":"c1","uid":1047471,"ip_address":"","ucode":"1153D7FAE1D671","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/af/5a9d2b58.jpg","comment_is_top":false,"comment_ctime":1554114652,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554114652","product_id":100010301,"comment_content":"正常理解，漏报是指将本来可回收对象这一次检查漏报了，而误报是将不是垃圾的对象误报成可回收对象。这样的话应该是误报的影响大才对啊。<br>这里漏报 和 误报应该说清楚，什么像什么上报什么吧？","like_count":0},{"had_liked":false,"id":75757,"user_name":"旅人","can_delete":false,"product_type":"c1","uid":1402404,"ip_address":"","ucode":"1A42A41FDF2830","user_header":"https://static001.geekbang.org/account/avatar/00/15/66/24/ba878891.jpg","comment_is_top":false,"comment_ctime":1552464680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552464680","product_id":100010301,"comment_content":"讲的非常好，感谢雨迪老师！！","like_count":0},{"had_liked":false,"id":69834,"user_name":"lee","can_delete":false,"product_type":"c1","uid":1183991,"ip_address":"","ucode":"96BD0F38A1AA61","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/f7/96302fe8.jpg","comment_is_top":false,"comment_ctime":1550881777,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1550881777","product_id":100010301,"comment_content":"请问回收方法中的压缩方法也可以看成是复制方法，只是没有分成两半，为何比复制方法效率低？这个不理解","like_count":0,"discussions":[{"author":{"id":1397031,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","nickname":"老白","note":"","ucode":"39881175152D49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74935,"discussion_content":"这个是因为复制方法有to指向的空闲内存，是连续的。而压缩算法是在原来内存区域的基础上将对象弄成连续的，性能会比复制方法低。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575708177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67544,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1550194847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550194847","product_id":100010301,"comment_content":"比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。<br><br><br>这是什么意思  没看懂","like_count":0},{"had_liked":false,"id":52671,"user_name":"未知","can_delete":false,"product_type":"c1","uid":1312918,"ip_address":"","ucode":"DB389CEBEEE9E1","user_header":"https://static001.geekbang.org/account/avatar/00/14/08/96/231fdd9e.jpg","comment_is_top":false,"comment_ctime":1545470396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545470396","product_id":100010301,"comment_content":"之前看文章，说当堆中（新生代）的一个对象被native方法引用的时候，此时发生GC（young GC）的话，是会被推迟的，然后会做补充GC。老师能讲下这个case相关的知识吗？谢谢","like_count":0},{"had_liked":false,"id":52665,"user_name":"未知","can_delete":false,"product_type":"c1","uid":1312918,"ip_address":"","ucode":"DB389CEBEEE9E1","user_header":"https://static001.geekbang.org/account/avatar/00/14/08/96/231fdd9e.jpg","comment_is_top":false,"comment_ctime":1545470023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545470023","product_id":100010301,"comment_content":"Hotspot栈的ref通过直接指针去引用堆上的对象，如果发生了old GC或者full gc而且还压缩了，这样的话对象的地址应该被改变了。此刻栈的ref引用地址是不是也变了。jvm在这块有什么优化吗？没优化的话，GC后程序继续执行怎么获取（更新）对象的地址呢？ 谢谢","like_count":0},{"had_liked":false,"id":33527,"user_name":"rsocket","can_delete":false,"product_type":"c1","uid":1255411,"ip_address":"","ucode":"F59B65445964A2","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/f3/39109e32.jpg","comment_is_top":false,"comment_ctime":1539822148,"is_pvip":false,"replies":[{"id":"12163","content":"直接翻到最后一篇有R大的推荐书单","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1539955096,"ip_address":"","comment_id":33527,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539822148","product_id":100010301,"comment_content":"郑老师，学习这个专栏前需要具备哪些知识？能否推荐下相关的书籍？以便更好地学习本专栏。谢谢！","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426982,"discussion_content":"直接翻到最后一篇有R大的推荐书单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539955096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33454,"user_name":"Mr.钧👻","can_delete":false,"product_type":"c1","uid":1249939,"ip_address":"","ucode":"D781E030E79245","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/93/3470fc43.jpg","comment_is_top":false,"comment_ctime":1539787472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539787472","product_id":100010301,"comment_content":"1.为什么需要垃圾回收？因为需要保证内存干净，简要。<br>2.什么是垃圾回收？就是GC定期清理堆内存<br>3.怎么回收垃圾？<br>   首先，把垃圾标记出来，两种方法：计数法，标记法(可达性分析)。但是标记法有可能导致漏报，引入安全点机制，需要当程序到达安全点，才进行标记。但是，安全点的到达会消耗性能，这时需要stop the world。<br><br>4.清理有三种机制<br> 1.清除，但可能产生碎片<br> 2.压缩，算法消耗性能<br> 3.复制，空间利用率低","like_count":0},{"had_liked":false,"id":32636,"user_name":"life is short, enjoy more.","can_delete":false,"product_type":"c1","uid":1074805,"ip_address":"","ucode":"3B5F37D30790A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg","comment_is_top":false,"comment_ctime":1539654760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539654760","product_id":100010301,"comment_content":"我来总结一下<br>引用计数法的缺陷<br><br>额外的空间保存引用数。频繁的更新引用数。<br><br>Stop the world的实现背景<br><br>在多线程的环境中，可达性分析可能因为多线程，产生不能清除全部垃圾，或者清除非垃圾内存的情况。前者最多导致清理不够干净，增加清理次数。但是后者可能会导致JVM崩溃。所以引入了STW。<br><br>在进行垃圾回收的时候，会暂停掉所有非垃圾回收线程，造成短暂的服务不可用。<br><br>反正因为如此，才不能随时的GC。当需要GC的STW的时候，会等到系统到达安全点(safe point 一 JVM堆栈不会发生变化的稳定时段)的时候，执行GC，进而引发STW。<br><br>todo 安全点的时候，就可以停止所有非垃圾回收线程嘛？？？<br><br>安全点<br><br>什么是安全点呢？就是程序运行稳定旳时刻，此时JVM的堆栈不会发生变化。<br><br>那什么时候是安全点呢？<br><br>比如执行JNI。<br><br><br>￼<br><br>还有阻塞的线程。<br><br>GC回收方式<br><br>清除法<br><br>会将垃圾内存的表示存储在free list中，需要进行新内存分配的时候，遍历list，寻找符合空间的内存区域，但是这样效率就很低，而且会造成内存碎片。<br><br><br>￼<br><br>2. 压缩<br><br>将垃圾内存从存活内存中剔除，保证剩余内存连续，避免碎片化。<br><br><br><br>￼<br><br>3. 复制<br><br>将内存分为两部分，用from和to指针指向。所有内存先分配到from区中，然后将from区中的存活内存，复制到to区中。但缺点也显而易见，极大的压缩了可用空间。<br><br>存疑<br><br>JNI handles<br><br>java native interface<br><br>","like_count":0},{"had_liked":false,"id":28854,"user_name":"果然如此","can_delete":false,"product_type":"c1","uid":1210003,"ip_address":"","ucode":"C7543BD0A67505","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","comment_is_top":false,"comment_ctime":1538181695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538181695","product_id":100010301,"comment_content":"垃圾回收是否可以主动一点，比如空闲时候回收，而不是等到分代内存不够了被动回收？","like_count":0},{"had_liked":false,"id":24587,"user_name":"Bin","can_delete":false,"product_type":"c1","uid":1088827,"ip_address":"","ucode":"1A298415CAD963","user_header":"https://static001.geekbang.org/account/avatar/00/10/9d/3b/bc67bfbe.jpg","comment_is_top":false,"comment_ctime":1537156153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537156153","product_id":100010301,"comment_content":"请教一个问题，gc的stw是为了可达性分析足够准确，确保这个过程在一致性的快照中进行，不能出现分析过程中引用关系还在不断变化的过程。那么假设没有stw，什么情况下已经被标记的又会被引用呢？该如何理解引用关系不断变化这句话","like_count":0},{"had_liked":false,"id":24329,"user_name":"Jeremy","can_delete":false,"product_type":"c1","uid":1181886,"ip_address":"","ucode":"CA01214E94E77C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/be/e5929b2c.jpg","comment_is_top":false,"comment_ctime":1536903345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536903345","product_id":100010301,"comment_content":"谢谢","like_count":0},{"had_liked":false,"id":22322,"user_name":"小胖爱美丽","can_delete":false,"product_type":"c1","uid":1146552,"ip_address":"","ucode":"FA8E1F5793CA19","user_header":"https://static001.geekbang.org/account/avatar/00/11/7e/b8/905f8f91.jpg","comment_is_top":false,"comment_ctime":1535600220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535600220","product_id":100010301,"comment_content":"写的通俗易懂，作为JVM小白也能看的懂，太开心了","like_count":0},{"had_liked":false,"id":21442,"user_name":"lanpay","can_delete":false,"product_type":"c1","uid":1057703,"ip_address":"","ucode":"15BE115858BEBD","user_header":"https://static001.geekbang.org/account/avatar/00/10/23/a7/3f084b33.jpg","comment_is_top":false,"comment_ctime":1535083131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535083131","product_id":100010301,"comment_content":"我自己又想了想，感觉主要是移动对象，碎片整理时需要stw防止访问错误的地址，不知道这样理解对不对，请老师指正","like_count":0},{"had_liked":false,"id":21441,"user_name":"lanpay","can_delete":false,"product_type":"c1","uid":1057703,"ip_address":"","ucode":"15BE115858BEBD","user_header":"https://static001.geekbang.org/account/avatar/00/10/23/a7/3f084b33.jpg","comment_is_top":false,"comment_ctime":1535081958,"is_pvip":false,"replies":[{"id":"8017","content":"GC标记的是活着的(能够被引用到的)对象，剩下的是垃圾。如果没有STW，其他线程在垃圾回收过程中产生了垃圾(某对象不再被引用)，那么会被漏掉。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535621312,"ip_address":"","comment_id":21441,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535081958","product_id":100010301,"comment_content":"对于为什么需要stw机制的解释还是有的困惑。假如一个对象已经被标记为垃圾了，其它线程怎么还会有机会引用它呢？就算通过stw，把它标记并回收了，那想引用它的线程重新恢复执行了会发生什么？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422677,"discussion_content":"GC标记的是活着的(能够被引用到的)对象，剩下的是垃圾。如果没有STW，其他线程在垃圾回收过程中产生了垃圾(某对象不再被引用)，那么会被漏掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535621312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21422,"user_name":"贾智文","can_delete":false,"product_type":"c1","uid":1100235,"ip_address":"","ucode":"600CF0AB215D1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/cb/7b6802cc.jpg","comment_is_top":false,"comment_ctime":1535075336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535075336","product_id":100010301,"comment_content":"请问多线程情况下如何产生漏报的呢？","like_count":0},{"had_liked":false,"id":20986,"user_name":"潇潇","can_delete":false,"product_type":"c1","uid":1105352,"ip_address":"","ucode":"ECC5745C5D3931","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/c8/fc79c128.jpg","comment_is_top":false,"comment_ctime":1534853405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534853405","product_id":100010301,"comment_content":"不太明白，什么是安全点？","like_count":0},{"had_liked":false,"id":20547,"user_name":"Shine","can_delete":false,"product_type":"c1","uid":1022568,"ip_address":"","ucode":"C8C617B87C63C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","comment_is_top":false,"comment_ctime":1534518094,"is_pvip":false,"replies":[{"id":"7332","content":"对的","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534779594,"ip_address":"","comment_id":20547,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1534518094","product_id":100010301,"comment_content":"“最终，未被探索到的对象便是死亡的，是可以回收的。”， 已经通过GC_Roots探索到所有的存活对象集。是不是整个堆空间减去存活对象集占用的空间就是空闲堆空间了？ 这样就不用具体去追究死亡对象的地址空间了？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422292,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534779594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20425,"user_name":"魔都浪子","can_delete":false,"product_type":"c1","uid":1177859,"ip_address":"","ucode":"8301440705105A","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/03/439bdb70.jpg","comment_is_top":false,"comment_ctime":1534430930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534430930","product_id":100010301,"comment_content":"能做一些源码分析吗，比如G1","like_count":0},{"had_liked":false,"id":20424,"user_name":"维维","can_delete":false,"product_type":"c1","uid":1050285,"ip_address":"","ucode":"0C0D96362B30DB","user_header":"https://static001.geekbang.org/account/avatar/00/10/06/ad/fe79da1d.jpg","comment_is_top":false,"comment_ctime":1534430923,"is_pvip":false,"replies":[{"id":"7456","content":"因为可达性分析只标记可达的，如果a和b都不可达，那么可达性分析标记不到，就当成垃圾回收了。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534938011,"ip_address":"","comment_id":20424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1534430923","product_id":100010301,"comment_content":"请教老师，可达性分析a与b互为引用，这不是死循环了吗，为什么能被回收的，这里不太明白。","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422241,"discussion_content":"因为可达性分析只标记可达的，如果a和b都不可达，那么可达性分析标记不到，就当成垃圾回收了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534938011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20265,"user_name":"Aaron_涛","can_delete":false,"product_type":"c1","uid":1180617,"ip_address":"","ucode":"067F3CBB1F036C","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/c9/9a9d82ab.jpg","comment_is_top":false,"comment_ctime":1534341174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534341174","product_id":100010301,"comment_content":"老师，特别想了解下G1的原理和机制","like_count":0},{"had_liked":false,"id":20234,"user_name":"正是那朵玫瑰","can_delete":false,"product_type":"c1","uid":1048261,"ip_address":"","ucode":"73D630B654573F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/c5/3467cf94.jpg","comment_is_top":false,"comment_ctime":1534324728,"is_pvip":false,"replies":[{"id":"7072","content":"工作线程。<br><br>你已经看出来这里的问题啦。如果工作线程还在继续工作，更新引用，那么就会引发你能想到的这些问题。传统的做法就是接下来讲的Safepoint，禁止工作线程继续更新引用。新的做法是通过一系列算法保证不会出现漏报的情况，从而支持并发回收。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534330350,"ip_address":"","comment_id":20234,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1534324728","product_id":100010301,"comment_content":"感谢老师解答，菜鸟实在还是不太明白[捂脸]，一个对象不可达了，gc才会标记为可以回收，老师所说的：“你更新了其中一个引用”，&quot;你&quot;指的是gc线程还是工作线程，引用指的是哪里的引用，GC都已经标记完成，怎么会有引用被更新？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422166,"discussion_content":"工作线程。\n\n你已经看出来这里的问题啦。如果工作线程还在继续工作，更新引用，那么就会引发你能想到的这些问题。传统的做法就是接下来讲的Safepoint，禁止工作线程继续更新引用。新的做法是通过一系列算法保证不会出现漏报的情况，从而支持并发回收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534330350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20218,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1534315329,"is_pvip":false,"replies":[{"id":"7057","content":"多谢指出，我更新一下","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534321697,"ip_address":"","comment_id":20218,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1534315329","product_id":100010301,"comment_content":"代码跑不起来啊，wrMpth.log10是什么","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422157,"discussion_content":"多谢指出，我更新一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534321697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}