{"id":164833,"title":"35 | 引入\"响应分发\"完善客户端","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geek_netty\">https://gitee.com/geektime-geekbang/geek_netty</a></p>","comments":[{"had_liked":false,"id":169410,"user_name":"javaYJL","can_delete":false,"product_type":"c3","uid":1188249,"ip_address":"","ucode":"E326EB9AFDCE32","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/99/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1578329207,"is_pvip":false,"replies":[{"id":65835,"content":"这个问题很好，说明你看的很细致还动手实践了。这里涉及到一些细节了：\n首先连接（说白了，就是TCP的三次握手）在服务器端写完下面这句话的时候：\n        ServerSocket serverSocket = new ServerSocket(8091);（注意这里没有accept）\n就已经可以连接上去了，而不是必须有accept（）的执行，那accept是做什么的？\n相当于快递的签入。如果你不签入，这个快递还是已经到了（连接已经建立好了），但是你无法对他进行后续处理（最起码，在服务器端你拿不到对应的socket channel来执行调用，更不用谈注册读写事件）。另外一个方面，如果你不accept，那中间的缓存区会满（取决于backlog大小），那很快，就无法建立新的连接了，和快递签入一个道理。你不签入，那快递都堆那个地方，最终还是存不下。\n\n所以总结起来就是，accept准确的说应该说是对连接的后续处理（签入），（但是经常在表述上包括本课程都是直接说处理连接，所以可能会让你误解，以为只有accept调用，连接才能建），至于连接本身（TCP）三次握手并不是accept这个方法做的事情。\n\n你可以写一些简单的例子验证下。很简单，几行代码，抛开netty来看，其实更容易把这些问题搞清楚，如果还有别的疑惑，欢迎继续提问，我应该说清楚这个问题了，哈哈\n\n谢谢！\n","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1578402914,"ip_address":"","comment_id":169410,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，你好！我在dubug的时候，发现服务端断点还停留在处理新连接接入；客户端addListener(future -&gt; {\n        if (future.isSuccess()) {\n            System.out.println(&quot;连接成功!&quot;);\n        } else {\n            System.err.println(&quot;连接失败，开始重连&quot;);\n            \n        }\n    });这个时候客户端已经打印出”连接成功了”","like_count":7,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480544,"discussion_content":"这个问题很好，说明你看的很细致还动手实践了。这里涉及到一些细节了：\n首先连接（说白了，就是TCP的三次握手）在服务器端写完下面这句话的时候：\n        ServerSocket serverSocket = new ServerSocket(8091);（注意这里没有accept）\n就已经可以连接上去了，而不是必须有accept（）的执行，那accept是做什么的？\n相当于快递的签入。如果你不签入，这个快递还是已经到了（连接已经建立好了），但是你无法对他进行后续处理（最起码，在服务器端你拿不到对应的socket channel来执行调用，更不用谈注册读写事件）。另外一个方面，如果你不accept，那中间的缓存区会满（取决于backlog大小），那很快，就无法建立新的连接了，和快递签入一个道理。你不签入，那快递都堆那个地方，最终还是存不下。\n\n所以总结起来就是，accept准确的说应该说是对连接的后续处理（签入），（但是经常在表述上包括本课程都是直接说处理连接，所以可能会让你误解，以为只有accept调用，连接才能建），至于连接本身（TCP）三次握手并不是accept这个方法做的事情。\n\n你可以写一些简单的例子验证下。很简单，几行代码，抛开netty来看，其实更容易把这些问题搞清楚，如果还有别的疑惑，欢迎继续提问，我应该说清楚这个问题了，哈哈\n\n谢谢！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578402914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177197,"user_name":"InfoQ_fbb8f3b4ab40","can_delete":false,"product_type":"c3","uid":1327125,"ip_address":"","ucode":"B3CF4BFCC8FFDA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/L9VVrMFqrzeT5bsQ7CYZdcHnyEVYa59apyp322eB5icysGXYgDqkeHZmH79ibiaJUShjvftoAmLeP6pxwhFff9ib8g/132","comment_is_top":false,"comment_ctime":1581319014,"is_pvip":false,"replies":[{"id":69666,"content":" 不管哪种情况下，客户端都是可以发送多个请求，比如请求A，请求B，然后服务器端处理要保证顺序的话，肯定就像你说的使用同一个线程，那这样会导致，请求A不处理完就不能处理B，明显效率不行，所以为提高效率肯定要多线程，那处理就可能结果不是按请求AB的顺序，所以才要需要一个ID来对应下，实现类似分发的效果。不过，不管怎么说，你说的本身没有问题的，因为你也可以发多个，也可以拿到响应，只是速度不会快。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1582003813,"ip_address":"","comment_id":177197,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"如果服务端io和处理是同一个线程的话，响应应该是按请求顺序一一对应的，也可以同时发多个请求，不需要做分发吧","like_count":1,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483338,"discussion_content":" 不管哪种情况下，客户端都是可以发送多个请求，比如请求A，请求B，然后服务器端处理要保证顺序的话，肯定就像你说的使用同一个线程，那这样会导致，请求A不处理完就不能处理B，明显效率不行，所以为提高效率肯定要多线程，那处理就可能结果不是按请求AB的顺序，所以才要需要一个ID来对应下，实现类似分发的效果。不过，不管怎么说，你说的本身没有问题的，因为你也可以发多个，也可以拿到响应，只是速度不会快。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582003813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160748,"user_name":"Peter","can_delete":false,"product_type":"c3","uid":1595382,"ip_address":"","ucode":"A77322C4E07B2D","user_header":"https://static001.geekbang.org/account/avatar/00/18/57/f6/2c7ac1ad.jpg","comment_is_top":false,"comment_ctime":1576028874,"is_pvip":false,"replies":[{"id":61853,"content":"不适合，因为那是encoder，从encoder里获取结果？另外，你怎么来获取响应结果？所以不适合。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1576569846,"ip_address":"","comment_id":160748,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，在ClientV1版本中我们将new RequestMessage的工作抽出去到Encoder里去实现了，但是在ClientV2版本中为了添加RequestPendingCenter我们又不得不每次都new RequestMessage，这里有没有什么办法将RequestPendingCenter#add的工作也放到Encoder里去？","like_count":1,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477465,"discussion_content":"不适合，因为那是encoder，从encoder里获取结果？另外，你怎么来获取响应结果？所以不适合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576569846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193552,"user_name":"yang","can_delete":false,"product_type":"c3","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1584926310,"is_pvip":false,"replies":[{"id":79275,"content":"是的，不然要考虑的情况远不止这些。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1588641451,"ip_address":"","comment_id":193552,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"通过 streamId 与 future 维护一个map来异步接收服务端的响应结果\n至于 客户端发送message失败，移出这种绑定关系 以及其他的复杂业务逻辑，不在我们的课程范围内。\n","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488584,"discussion_content":"是的，不然要考虑的情况远不止这些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588641451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178029,"user_name":"大大大熊myeh","can_delete":false,"product_type":"c3","uid":1139413,"ip_address":"","ucode":"4832C2E7CEB151","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","comment_is_top":false,"comment_ctime":1581574016,"is_pvip":false,"replies":[{"id":69671,"content":"不好意思，将就下吧，兄弟！有不明白的，可以留言。谢谢！","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1582004569,"ip_address":"","comment_id":178029,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"代码一个注释都没有……看着挺费劲的","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483640,"discussion_content":"不好意思，将就下吧，兄弟！有不明白的，可以留言。谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582004569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164082,"user_name":"shinee_x_X","can_delete":false,"product_type":"c3","uid":1605962,"ip_address":"","ucode":"98529C77B052AC","user_header":"https://static001.geekbang.org/account/avatar/00/18/81/4a/dcc563fb.jpg","comment_is_top":false,"comment_ctime":1576856328,"is_pvip":false,"replies":[{"id":62385,"content":"future本身就代表是异步的，而get是为了获取结果，相当于异步执行但是结果获取是阻塞同步，这两个不矛盾。\n改进的核心点在于：第一个请求和第二个请求可以异步并发了，原来的不行，因为如果并发，无法把结果一一对应起来。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1576896886,"ip_address":"","comment_id":164082,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，你这还不是开头说的第一种发送响应模式吗，客户端还是不能异步发送啊，future get的时候还是会阻色啊","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478637,"discussion_content":"future本身就代表是异步的，而get是为了获取结果，相当于异步执行但是结果获取是阻塞同步，这两个不矛盾。\n改进的核心点在于：第一个请求和第二个请求可以异步并发了，原来的不行，因为如果并发，无法把结果一一对应起来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576896886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342873,"discussion_content":"在get之前你可以发送100万个请求  异步是对请求和响应来说的   不是对main线程来说的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610860258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151741,"user_name":"13761642169","can_delete":false,"product_type":"c3","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1573783767,"is_pvip":false,"replies":[{"id":58343,"content":"但是如果他的信息传输结构定义成带关键id的，能做到的更好，就像http为什么要搞新版本一样的道理，当然原来的旧版本，现在一直在用，因为能满足需求，不够就加机器。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1573785974,"ip_address":"","comment_id":151741,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"说点题外话，kafka client 发送请求给 broker，如果 client 没有收到对应的响应，会 pending，新的请求发不出去，但 kafka 吞吐还是很大的","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474597,"discussion_content":"但是如果他的信息传输结构定义成带关键id的，能做到的更好，就像http为什么要搞新版本一样的道理，当然原来的旧版本，现在一直在用，因为能满足需求，不够就加机器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573785974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366632,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/68/502a2867.jpg","nickname":"usdjkajkl","note":"","ucode":"D8C53679C24B61","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602031,"discussion_content":"这个和响应分发的概念不一样，kafka本身会为topic维护消息的offset，而这个offset是有序递增的，所以我理解kafka的client发消息是有必要进行阻塞的,kafka大吞吐的原因有很多而不是一个简单的网络模型，最起码在client端是可以采用批发送+压缩的方式提高整体吞吐的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675615845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207294,"user_name":"xxcupid","can_delete":false,"product_type":"c3","uid":1566688,"ip_address":"","ucode":"70437984614CFC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJSgia4NAMN7qM8w8A5LNwo8bY6zLBxGfpH5ECebaf4rDEqWZdRQVadhCXibmAR971maZVLtsWBc3cA/132","comment_is_top":false,"comment_ctime":1587043333,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，你的代码稍微有点问题，在4.1.39版本是没问题的，但是其他版本netty可能有哦问题。\n你实现的DefaultPromise，它的构造函数为executor赋值为null了。这个在notifyListeners()方法调用的时候会触发NPE。老师你使用的netty是4.1.39，它的setValue0方法会先checkNotifyWaiters()如果返回true，才会notifyListeners，如果是false就不会调用该方法，而case里因为没有为promise添加任何listener，所以不会触发空指针。\n如果版本较低，比如4.1.30，它的notifyListeners不是在checkNotifyWaiters为true才调用的，只要CAS设置结果成功就会调用，这就会触发NPE。\n而且即使是4.1.39版本，如果用户通过addListener为promise添加了至少一个future之后，也会触发NPE。\n所以在这里留言提一下，防止有些同学也踩了这个坑。","like_count":9,"discussions":[{"author":{"id":2432032,"avatar":"https://static001.geekbang.org/account/avatar/00/25/1c/20/0d8fa034.jpg","nickname":"王耳总丶","note":"","ucode":"14D871CAC7ADF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394398,"discussion_content":"十分感谢🙏，解决了我的问题，只需要这么改就行了\npublic class MessagePromise extends DefaultPromise<OperationResult> {\n    public MessagePromise(EventExecutor executor) {\n        super(executor);\n    }\n}\n另外在new Promiss的时候使用MessagePromise promise = new MessagePromise(context.executor());\n添加监听的时候使用\npromise.addListener((MessagePromise future) -> {\n                    //do something\n                });\n还有一个问题请教，这么做有一个问题，就是在promiss done的时候才会执行监听，也就是setSuccess的时候，我希望在addListener的时候就开始监听，有什么办法呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631868312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240972,"user_name":"争分夺秒","can_delete":false,"product_type":"c3","uid":1615818,"ip_address":"","ucode":"A29E3BC69F196F","user_header":"https://static001.geekbang.org/account/avatar/00/18/a7/ca/f0c90475.jpg","comment_is_top":false,"comment_ctime":1597135737,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师我想问下，现在用golang语言与java 的netty互通的话，是没有go语言的ProtobufDecoder之类的的实现的是吧？这是不是要手动实现？","like_count":1,"discussions":[{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342870,"discussion_content":"需要手动实现 netty只适合JAVA  跨语言还是用grpc、thrift这种好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610859788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389700,"user_name":"mikewt","can_delete":false,"product_type":"c3","uid":1004991,"ip_address":"上海","ucode":"6219ED71B0DFA1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/bf/d442b55e.jpg","comment_is_top":false,"comment_ctime":1713265952,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"dubbo就是这么设计的","like_count":0},{"had_liked":false,"id":358330,"user_name":"Grey","can_delete":false,"product_type":"c3","uid":1663898,"ip_address":"广东","ucode":"D63D36C9A7F16B","user_header":"https://static001.geekbang.org/account/avatar/00/19/63/9a/6872c932.jpg","comment_is_top":false,"comment_ctime":1664200475,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"很精彩，谢谢老师","like_count":0},{"had_liked":false,"id":356987,"user_name":"陈志成","can_delete":false,"product_type":"c3","uid":1150083,"ip_address":"广东","ucode":"4ACAC378EA2735","user_header":"https://static001.geekbang.org/account/avatar/00/11/8c/83/1974d757.jpg","comment_is_top":false,"comment_ctime":1662798438,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"[zǔ sè] 阻塞","like_count":0},{"had_liked":false,"id":352888,"user_name":"Geek_3253ab","can_delete":false,"product_type":"c3","uid":2254994,"ip_address":"陕西","ucode":"74FA43B9C9C9E4","user_header":"","comment_is_top":false,"comment_ctime":1658995129,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"完全没弄明白 执行get 操作 是怎么和 pendingCenter 里的streamID 连接起来的","like_count":0},{"had_liked":false,"id":274114,"user_name":"poordickey","can_delete":false,"product_type":"c3","uid":1810156,"ip_address":"","ucode":"2A436EC813AF97","user_header":"","comment_is_top":false,"comment_ctime":1610860521,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"看来整个TCP请求和响应都是流式化的  客户端需要做的是怎么保证对应到哪个请求","like_count":0},{"had_liked":false,"id":247192,"user_name":"John","can_delete":false,"product_type":"c3","uid":1228424,"ip_address":"","ucode":"A46AF2906C38C1","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/88/8d15796f.jpg","comment_is_top":false,"comment_ctime":1599630273,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"http2也有这个设计","like_count":0},{"had_liked":false,"id":233831,"user_name":"故事、自己写","can_delete":false,"product_type":"c3","uid":1048419,"ip_address":"","ucode":"D3C87D6B9004D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/63/042aaa14.jpg","comment_is_top":false,"comment_ctime":1594466107,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"服务端（其他厂商）不带streamId的情况下，怎么处理？","like_count":0,"discussions":[{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342872,"discussion_content":"协议规定的数据结构已经有规范了  必须带这个  客户端和服务端都是基于这个协议做编解码的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610860088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206317,"user_name":"Geek_db3445","can_delete":false,"product_type":"c3","uid":1681857,"ip_address":"","ucode":"A1F5FB1FA9FBCA","user_header":"","comment_is_top":false,"comment_ctime":1586838571,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师,center.future,DispatchHandler,这些基础内容,可以介绍一下吗?或者通过学哪方面知识可以获得,谢谢老师","like_count":0},{"had_liked":false,"id":195279,"user_name":"NoBody","can_delete":false,"product_type":"c3","uid":1173766,"ip_address":"","ucode":"72E1B4FCDA2469","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/06/038a9cea.jpg","comment_is_top":false,"comment_ctime":1585152989,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"打卡","like_count":0}]}