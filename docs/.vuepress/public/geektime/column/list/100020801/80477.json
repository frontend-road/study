{"id":80477,"title":"37 | 什么时候会使用内部临时表？","content":"<p><span class=\"orange\">今天是大年初二，在开始我们今天的学习之前，我要先和你道一声春节快乐！</span></p><p>在<a href=\"https://time.geekbang.org/column/article/73479\">第16</a>和<a href=\"https://time.geekbang.org/column/article/79700\">第34</a>篇文章中，我分别和你介绍了sort buffer、内存临时表和join buffer。这三个数据结构都是用来存放语句执行过程中的中间数据，以辅助SQL语句的执行的。其中，我们在排序的时候用到了sort buffer，在使用join语句的时候用到了join buffer。</p><p>然后，你可能会有这样的疑问，MySQL什么时候会使用内部临时表呢？</p><p>今天这篇文章，我就先给你举两个需要用到内部临时表的例子，来看看内部临时表是怎么工作的。然后，我们再来分析，什么情况下会使用内部临时表。</p><h1>union 执行流程</h1><p>为了便于量化分析，我用下面的表t1来举例。</p><pre><code>create table t1(id int primary key, a int, b int, index(a));\ndelimiter ;;\ncreate procedure idata()\nbegin\n  declare i int;\n\n  set i=1;\n  while(i&lt;=1000)do\n    insert into t1 values(i, i, i);\n    set i=i+1;\n  end while;\nend;;\ndelimiter ;\ncall idata();\n</code></pre><p>然后，我们执行下面这条语句：</p><pre><code>(select 1000 as f) union (select id from t1 order by id desc limit 2);\n</code></pre><p>这条语句用到了union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。</p><p>下图是这个语句的explain结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/40/4e/402cbdef84eef8f1b42201c6ec4bad4e.png?wh=1509*187\" alt=\"\"></p><center><span class=\"reference\">图1 union语句explain 结果</span></center><p>可以看到：</p><ul>\n<li>第二行的key=PRIMARY，说明第二个子句用到了索引id。</li>\n<li>第三行的Extra字段，表示在对子查询的结果集做union的时候，使用了临时表(Using temporary)。</li>\n</ul><!-- [[[read_end]]] --><p>这个语句的执行流程是这样的：</p><ol>\n<li>\n<p>创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段。</p>\n</li>\n<li>\n<p>执行第一个子查询，得到1000这个值，并存入临时表中。</p>\n</li>\n<li>\n<p>执行第二个子查询：</p>\n<ul>\n<li>拿到第一行id=1000，试图插入临时表中。但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li>\n<li>取到第二行id=999，插入临时表成功。</li>\n</ul>\n</li>\n<li>\n<p>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999。</p>\n</li>\n</ol><p>这个过程的流程图如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/0e/5d038c1366d375cc997005a5d65c600e.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图 2 union 执行流程</span></center><p>可以看到，这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯一性约束，实现了union的语义。</p><p>顺便提一下，如果把上面这个语句中的union改成union all的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/6d/c1e90d1d7417b484d566b95720fe3f6d.png?wh=1409*168\" alt=\"\"></p><center><span class=\"reference\">图3 union all的explain结果</span></center><p>可以看到，第二行的Extra字段显示的是Using index，表示只使用了覆盖索引，没有用临时表了。</p><h1>group by 执行流程</h1><p>另外一个常见的使用临时表的例子是group by，我们来看一下这个语句：</p><pre><code>select id%10 as m, count(*) as c from t1 group by m;\n</code></pre><p>这个语句的逻辑是把表t1里的数据，按照 id%10 进行分组统计，并按照m的结果排序后输出。它的explain结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/98/3d1cb94589b6b3c4bb57b0bdfa385d98.png?wh=1702*143\" alt=\"\"></p><center><span class=\"reference\">图4 group by 的explain结果</span></center><p>在Extra字段里面，我们可以看到三个信息：</p><ul>\n<li>Using index，表示这个语句使用了覆盖索引，选择了索引a，不需要回表；</li>\n<li>Using temporary，表示使用了临时表；</li>\n<li>Using filesort，表示需要排序。</li>\n</ul><p>这个语句的执行流程是这样的：</p><ol>\n<li>\n<p>创建内存临时表，表里有两个字段m和c，主键是m；</p>\n</li>\n<li>\n<p>扫描表t1的索引a，依次取出叶子节点上的id值，计算id%10的结果，记为x；</p>\n<ul>\n<li>如果临时表中没有主键为x的行，就插入一个记录(x,1);</li>\n<li>如果表中有主键为x的行，就将x这一行的c值加1；</li>\n</ul>\n</li>\n<li>\n<p>遍历完成后，再根据字段m做排序，得到结果集返回给客户端。</p>\n</li>\n</ol><p>这个流程的执行图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/03/54/0399382169faf50fc1b354099af71954.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图5 group by执行流程</span></center><p>图中最后一步，对内存临时表的排序，在<a href=\"https://time.geekbang.org/column/article/73795\">第17篇文章</a>中已经有过介绍，我把图贴过来，方便你回顾。</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/68/b5168d201f5a89de3b424ede2ebf3d68.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图6 内存临时表排序流程</span></center><p>其中，临时表的排序过程就是图6中虚线框内的过程。</p><p>接下来，我们再看一下这条语句的执行结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/55/ae6a28d890efc35ee4d07f694068f455.png?wh=676*348\" alt=\"\"></p><center><span class=\"reference\">图 7 group by执行结果</span></center><p>如果你的需求并不需要对结果进行排序，那你可以在SQL语句末尾增加order by null，也就是改成：</p><pre><code>select id%10 as m, count(*) as c from t1 group by m order by null;\n</code></pre><p>这样就跳过了最后排序的阶段，直接从临时表中取数据返回。返回的结果如图8所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/03/eb/036634e53276eaf8535c3442805dfaeb.png?wh=823*376\" alt=\"\"></p><center><span class=\"reference\">图8 group + order by null 的结果（内存临时表）</span></center><p>由于表t1中的id值是从1开始的，因此返回的结果集中第一行是id=1；扫描到id=10的时候才插入m=0这一行，因此结果集里最后一行才是m=0。</p><p>这个例子里由于临时表只有10行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数tmp_table_size就是控制这个内存大小的，默认是16M。</p><p>如果我执行下面这个语句序列：</p><pre><code>set tmp_table_size=1024;\nselect id%100 as m, count(*) as c from t1 group by m order by null limit 10;\n</code></pre><p>把内存临时表的大小限制为最大1024字节，并把语句改成id % 100，这样返回结果里有100行数据。但是，这时的内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小到达了上限（1024字节）。</p><p>那么，这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB。 这时，返回的结果如图9所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/6e/a76381d0f3c947292cc28198901f9e6e.png?wh=896*332\" alt=\"\"></p><center><span class=\"reference\">图9 group + order by null 的结果（磁盘临时表）</span></center><p>如果这个表t1的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。</p><h1>group by 优化方法 --索引</h1><p>可以看到，不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个group by语句执行起来就会很慢，我们有什么优化的方法呢？</p><p>要解决group by语句的优化问题，你可以先想一下这个问题：执行group by语句为什么需要临时表？</p><p>group by的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的id%100的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p><p>那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？</p><p>假设，现在有一个类似图10的这么一个数据结构，我们来看看group by可以怎么做。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/19/5c4a581c324c1f6702f9a2c70acddd19.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图10 group by算法优化-有序输入</span></center><p>可以看到，如果可以确保输入的数据是有序的，那么计算group by的时候，就只需要从左到右，顺序扫描，依次累加。也就是下面这个过程：</p><ul>\n<li>当碰到第一个1的时候，已经知道累积了X个0，结果集里的第一行就是(0,X);</li>\n<li>当碰到第一个2的时候，已经知道累积了Y个1，结果集里的第二行就是(1,Y);</li>\n</ul><p>按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到group by的结果，不需要临时表，也不需要再额外排序。</p><p>你一定想到了，InnoDB的索引，就可以满足这个输入有序的条件。</p><p>在MySQL 5.7版本支持了generated column机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列z，然后在z列上创建一个索引（如果是MySQL 5.6及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p><pre><code>alter table t1 add column z int generated always as(id % 100), add index(z);\n</code></pre><p>这样，索引z上的数据就是类似图10这样有序的了。上面的group by语句就可以改成：</p><pre><code>select z, count(*) as c from t1 group by z;\n</code></pre><p>优化后的group by语句的explain结果，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/b9/c9f88fa42d92cf7dde78fca26c4798b9.png?wh=1349*143\" alt=\"\"></p><center><span class=\"reference\">图11 group by 优化的explain结果</span></center><p>从Extra字段可以看到，这个语句的执行不再需要临时表，也不需要排序了。</p><h1>group by优化方法 --直接排序</h1><p>所以，如果可以通过加索引来完成group by逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，我们还是要老老实实做排序的。那么，这时候的group by要怎么优化呢？</p><p>如果我们明明知道，一个group by语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就有点儿傻。</p><p>那么，我们就会想了，MySQL有没有让我们直接走磁盘临时表的方法呢？</p><p>答案是，有的。</p><p>在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p><p>MySQL的优化器一看，磁盘临时表是B+树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p><p>因此，下面这个语句</p><pre><code>select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;\n</code></pre><p>的执行流程就是这样的：</p><ol>\n<li>\n<p>初始化sort_buffer，确定放入一个整型字段，记为m；</p>\n</li>\n<li>\n<p>扫描表t1的索引a，依次取出里面的id值, 将 id%100的值存入sort_buffer中；</p>\n</li>\n<li>\n<p>扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer内存不够用，就会利用磁盘临时文件辅助排序）；</p>\n</li>\n<li>\n<p>排序完成后，就得到了一个有序数组。</p>\n</li>\n</ol><p>根据有序数组，得到数组里面的不同值，以及每个值的出现次数。这一步的逻辑，你已经从前面的图10中了解过了。</p><p>下面两张图分别是执行流程图和执行explain命令得到的结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/82/6a/8269dc6206a7ef20cb515c23df0b846a.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图12 使用 SQL_BIG_RESULT的执行流程图</span></center><p><img src=\"https://static001.geekbang.org/resource/image/83/ec/83b6cd6b3e37dfbf9699cf0ccc0f1bec.png?wh=1393*131\" alt=\"\"></p><center><span class=\"reference\">图13 使用 SQL_BIG_RESULT的explain 结果</span></center><p>从Extra字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。</p><p>基于上面的union、union all和group by语句的执行过程的分析，我们来回答文章开头的问题：MySQL什么时候会使用内部临时表？</p><ol>\n<li>\n<p>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</p>\n</li>\n<li>\n<p>join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；</p>\n</li>\n<li>\n<p>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union需要用到唯一索引约束， group by还需要用到另外一个字段来存累积计数。</p>\n</li>\n</ol><h1>小结</h1><p>通过今天这篇文章，我重点和你讲了group by的几种实现算法，从中可以总结一些使用的指导原则：</p><ol>\n<li>\n<p>如果对group by语句的结果没有排序要求，要在语句后面加 order by null；</p>\n</li>\n<li>\n<p>尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using filesort；</p>\n</li>\n<li>\n<p>如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；</p>\n</li>\n<li>\n<p>如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法得到group by的结果。</p>\n</li>\n</ol><p>最后，我给你留下一个思考题吧。</p><p>文章中图8和图9都是order by null，为什么图8的返回结果里面，0是在结果集的最后一行，而图9的结果里面，0是在结果集的第一行？</p><p>你可以把你的分析写在留言区里，我会在下一篇文章和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1>上期问题时间</h1><p>上期的问题是：为什么不能用rename修改临时表的改名。</p><p>在实现上，执行rename table语句的时候，要求按照“库名/表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的frm文件是放在tmpdir目录下的，并且文件名的规则是“#sql{进程id}_{线程id}_序列号.frm”，因此会报“找不到文件名”的错误。</p><p>评论区留言点赞板：</p><blockquote>\n<p>@poppy 同学，通过执行语句的报错现象推测了这个实现过程。</p>\n</blockquote><p></p>","comments":[{"had_liked":false,"id":65572,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1549461830,"is_pvip":false,"replies":[{"id":"23223","content":"新年好<br><br>好问题，我加到后面文章中。<br>简单说下结论，只需要去重的话，如果没有limit，是一样的；<br>有limit的话，distinct 快些。<br><br>漂亮的回答👍<br><br>","user_name":"作者回复","comment_id":65572,"uid":"1264162","ip_address":"","utype":1,"ctime":1549502743,"user_name_real":"林晓斌"}],"discussion_count":4,"race_medal":0,"score":"456815995206","product_id":100020801,"comment_content":"请教一个问题：如果只需要去重，不需要执行聚合函数，distinct 和group by那种效率高一些呢？<br><br>课后习题:<br>图8，把统计结果存内存临时表，不排序。id是从1到1000，模10的结果顺序就是1、2、3、4、5。。。<br>图9，老师把tmp_table_size改小了，内存临时表装不下，改用磁盘临时表。根据老师讲的流程，id取模的结果，排序后存入临时表，临时的数据应该是0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,2,......<br>从这个磁盘临时表读取数据汇总的结果的顺序就是0,1,2,3,4,5。。。","like_count":107,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438503,"discussion_content":"新年好\n\n好问题，我加到后面文章中。\n简单说下结论，只需要去重的话，如果没有limit，是一样的；\n有limit的话，distinct 快些。\n\n漂亮的回答👍\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549502743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037528,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/17/18/3f46df92.jpg","nickname":"张毅朋","note":"","ucode":"61C06FB231B095","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559973,"discussion_content":"临时表存的不是m和c吗？为什么您说存的是id取模后的中间数据？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649086262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1320092,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4z9WYWVvWDhMF0SicPE5ad56ME6DibyWGbRoQa0lH4U9icdsjNcv3ssRickcuRMDA01e6vMXnmOVSr9l5LVUefVxicn/132","nickname":"black_mirror","note":"","ucode":"2549C87298BF12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311094,"discussion_content":"slow log","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602219216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508329,"avatar":"https://static001.geekbang.org/account/avatar/00/17/03/e9/6358059c.jpg","nickname":"GalaxyCreater","note":"","ucode":"C79E8A088D57CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266542,"discussion_content":"怎么看默认使用的是哪种类型的临时表，测试结果出来好像不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589529575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65487,"user_name":"长杰","can_delete":false,"product_type":"c1","uid":1312212,"ip_address":"","ucode":"DD52C9494005F7","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/d4/e06bf86d.jpg","comment_is_top":false,"comment_ctime":1549413482,"is_pvip":false,"replies":[{"id":"23211","content":"👍🏿<br>春节快乐","user_name":"作者回复","comment_id":65487,"uid":"1264162","ip_address":"","utype":1,"ctime":1549427643,"user_name_real":"林晓斌"}],"discussion_count":3,"race_medal":0,"score":"302197124202","product_id":100020801,"comment_content":"图九使用的是磁盘临时表，磁盘临时表使用的引擎是innodb，innodb是索引组织表，按主键顺序存储数据，所以是按照m字段有序的。","like_count":70,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438468,"discussion_content":"👍🏿\n春节快乐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549427643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043325,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC1AlfCeW03lLnnb7mj5v35Hib8YDs66zpnVib2n2qFichFmFp2Ec4QDPR0dKh38MkBBLyD3bE4NiaanZQ/132","nickname":"龙晓","note":"","ucode":"FAF34F1C65D103","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360634,"discussion_content":"主键不是m，因为这时候的m还没统计，感觉像堆表，但innodb又不支持堆表，我已经懵了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616494432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2904077,"avatar":"","nickname":"Geek_0d6c6a","note":"","ucode":"882B752A25193A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043325,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC1AlfCeW03lLnnb7mj5v35Hib8YDs66zpnVib2n2qFichFmFp2Ec4QDPR0dKh38MkBBLyD3bE4NiaanZQ/132","nickname":"龙晓","note":"","ucode":"FAF34F1C65D103","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552242,"discussion_content":"m确实不是主键，但m不需要统计，这里应该是个为m建立的二级索引。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645367522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360634,"ip_address":""},"score":552242,"extra":""}]}]},{"had_liked":false,"id":71348,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1551324731,"is_pvip":false,"replies":[{"id":"25559","content":"👍很好的总结","user_name":"作者回复","comment_id":71348,"uid":"1264162","ip_address":"","utype":1,"ctime":1551354070,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"190529885755","product_id":100020801,"comment_content":"内部临时表，和sort buffer,join buffer一样，都用来存放语句执行过程中的中间数据，辅助语句的执行。<br>使用用法 using temporary。<br><br>使用场景：1 数据一边查询，一边直接得到结果，不需要额外内存。比如：group by 需要计算。<br><br>          2 join_buffer 是无序数组（单字段，可以重复），sort_buffer 有序数组，内部临时表是二维结构<br><br>\t  3 用到二维表的特性需要用到内部临时表，比如 distinct ，group by <br><br>优化：1 group by 字段加索引<br><br>      2 扩大临时表内存大小<br><br>      3 如果数据量比较大，直接使用磁盘临时表<br><br>      4 如果分组之后，不需要排序，手工 order by null<br><br><br><br>group by 的顺序<br><br>1 创建一个内部临时表，初始化字段 a(分组字段) b(数量)<br><br>2 扫描表，一个个的判断，a字段值在临时表不存在，则插入(2,1)，如果存在，比如（2,1），则加1，成为（2,2）<br><br>3 分组之后，默认会进行排序，如果不需要顺序，用 order by null。","like_count":45,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441117,"discussion_content":"👍很好的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551354070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71561,"user_name":"Sinyo","can_delete":false,"product_type":"c1","uid":1307297,"ip_address":"","ucode":"57B243E7AB86A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJAibnPX9jW8kqLcIfibjic8GbkQkEUYyFKJkc39hZhibVlNrqwTjdLozkqibI2IwACd5YzofYickNxFnZg/132","comment_is_top":false,"comment_ctime":1551369597,"is_pvip":false,"replies":[{"id":"25736","content":"是的，非常好的验证和思考👍<br><br>sort_buffer、join_buffer、内存临时表和磁盘临时表 都是server层的，引擎间共用","user_name":"作者回复","comment_id":71561,"uid":"1264162","ip_address":"","utype":1,"ctime":1551404286,"user_name_real":"林晓斌"}],"discussion_count":3,"race_medal":0,"score":"164760126845","product_id":100020801,"comment_content":"老师好，<br>我用infobright列式存储引擎explain出来一个group by语句，<br>发现也会用到内存临时表和文件排序、然后使用SQL_BIG_RESULT也有同样优化效果；<br>这是不是说明sort_buffer、join_buffer、内存临时表和磁盘临时表与数据库引擎类型其实是独立开的呢？","like_count":39,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441204,"discussion_content":"是的，非常好的验证和思考👍\n\nsort_buffer、join_buffer、内存临时表和磁盘临时表 都是server层的，引擎间共用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551404286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363583,"discussion_content":"内存临时表和磁盘临时表 都是server层 ，那第17篇的扫描行数为20003 怎么得来的？难道说扫描server层的表也要加1？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617239867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588348,"discussion_content":"表是基于某个引擎创建的，由server指定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663680026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363583,"ip_address":"广东"},"score":588348,"extra":""}]}]},{"had_liked":false,"id":69401,"user_name":"IceGeek17","can_delete":false,"product_type":"c1","uid":1103101,"ip_address":"","ucode":"1B42D7260449B4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/fd/43802282.jpg","comment_is_top":false,"comment_ctime":1550735671,"is_pvip":false,"replies":[{"id":"24988","content":"1. 最后的结果是“直接使用排序”<br>2. 就是认为用sort_buffer直接排序性能更好，所以就没有使用内存临时表或磁盘临时表<br>3. 没有索引的内存表可以认为就是数组； 主键不是，内存表的表结构，可以看一下38篇","user_name":"作者回复","comment_id":69401,"uid":"1264162","ip_address":"","utype":1,"ctime":1550996696,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"108924918071","product_id":100020801,"comment_content":"文中说，SQL_BIG_RESULT这个hint，用来告诉优化器直接用磁盘临时表，<br>对于文中的例子 select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;<br>则没有使用临时表，直接用了排序算法，这里有点不太明白，SQL_BIG_RESULT这个hint到底用来提示的是什么（是用磁盘临时表，还是就是直接使用排序，不用临时表）？<br><br>文中 “MySQL优化器一看，磁盘临时表B+数存储，存储效率不如数据来的高。那从磁盘空间考虑，还是直接用数组来存”，这段怎么理解？<br>是指MySQL优化器，直接忽略B+数的磁盘临时表（这里忽略的依据是什么？），并且从文中后续的分析来看，也没有用内存临时表，而是直接sort buffer排序，老师再详细解释下？<br><br>对于InnoDB的磁盘临时表，索引结构是B+数；那对于内存临时表，是不是就是数组结构？数组临时表的主键就是每个数组元素？<br><br>","like_count":26,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440101,"discussion_content":"1. 最后的结果是“直接使用排序”\n2. 就是认为用sort_buffer直接排序性能更好，所以就没有使用内存临时表或磁盘临时表\n3. 没有索引的内存表可以认为就是数组； 主键不是，内存表的表结构，可以看一下38篇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550996696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2811222,"avatar":"","nickname":"Geek4748","note":"","ucode":"D4F1A94D428CA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543678,"discussion_content":"强烈建议这个地方在文章中解释一下～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641266651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65621,"user_name":"Li Shunduo","can_delete":false,"product_type":"c1","uid":1222882,"ip_address":"","ucode":"6C5AB4129E9780","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/e2/f8e51df2.jpg","comment_is_top":false,"comment_ctime":1549513394,"is_pvip":false,"replies":[{"id":"23230","content":"因为索引c的信息也足够，而且比主键索引小，使用索引c更会好。<br><br>“如果字段a上有空值，使用索引a岂不是就不能取到所有的id值了？”，不会的","user_name":"作者回复","comment_id":65621,"uid":"1264162","ip_address":"","utype":1,"ctime":1549532056,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"57384088242","product_id":100020801,"comment_content":"请问Group By部分的第一个语句 explain select id%10 as m, count(*) as c from t1 group by m；为什么选择的是索引a，而不是primary key？如果字段a上有空值，使用索引a岂不是就不能取到所有的id值了？","like_count":13,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438524,"discussion_content":"因为索引c的信息也足够，而且比主键索引小，使用索引c更会好。\n\n“如果字段a上有空值，使用索引a岂不是就不能取到所有的id值了？”，不会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549532056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88045,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1555824305,"is_pvip":false,"replies":[{"id":"32458","content":"只要是有Using filesort就表示有排序；<br>Using index是表示使用了覆盖索引；<br><br>三个都出现就是使用了覆盖索引，但是覆盖索引的顺序扫描不能满足需求，只能排序，而排序过程用到了临时表","user_name":"作者回复","comment_id":88045,"uid":"1264162","ip_address":"","utype":1,"ctime":1556597431,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"53095431857","product_id":100020801,"comment_content":"老师您好,课课后小结 <br>2.尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；<br>这里我有个疑问,文章的例子中explain 结果里,既出现了using index ,又出现了Using temporary 和 Using filesort,好像也是使用了所以啊,如果用你这个方法判断,那到底有没有使用索引呢?","like_count":13,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447696,"discussion_content":"只要是有Using filesort就表示有排序；\nUsing index是表示使用了覆盖索引；\n\n三个都出现就是使用了覆盖索引，但是覆盖索引的顺序扫描不能满足需求，只能排序，而排序过程用到了临时表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556597431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65899,"user_name":"Long","can_delete":false,"product_type":"c1","uid":1318970,"ip_address":"","ucode":"2417242560360A","user_header":"https://static001.geekbang.org/account/avatar/00/14/20/3a/90db6a24.jpg","comment_is_top":false,"comment_ctime":1549758270,"is_pvip":false,"replies":[{"id":"25700","content":"1. 是的，我默认是用5.7做的验证，这里5.7做了优化。<br>2. 其实你已经找到原因了，就是因为5.6的默认临时表是myisam表，而myisam表是堆表，这里的堆表，跟38篇介绍的memory引擎是类似的，你看了那篇应该就能知道为什么堆表是最后显示0那行了<br>3. 好问题，不同id从大到小，相同id从上到下<br>4. 多谢你的鼓励，还没定，先休息下^_^<br><br>不好意思，你发的第一天就看到了，回复晚了😆","user_name":"作者回复","comment_id":65899,"uid":"1264162","ip_address":"","utype":1,"ctime":1551376809,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"44499431230","product_id":100020801,"comment_content":"老师，新年好！ :-)<br><br>有几个版本差异的问题：<br>（1）图1中的执行计划应该是5.7版本以后的吧，貌似没找到说在哪个环境，我在5.6和5.7分别测试了，id = 2的那个rows，在5.6版本（5.6.26）是1000，在5.7版本是2行。应该是5.7做的优化吧？<br><br>（2）图 9 group + order by null 的结果（此盘临时表），这里面mysql5.6里面执行的结果是（1，10），（2，10）...(10，10)，执行计划都是只有一样，没找到差异。<br>跟踪下了下optimizer trace，发现问题应该是在临时表空间满的的时候，mysql5.7用的是：converting_tmp_table_to_ondisk  &quot;location&quot;: &quot;disk (InnoDB)&quot;,，而mysql 5.6用的是converting_tmp_table_to_myisam &quot;location&quot;: &quot;disk (MyISAM)&quot;的原因导致的。<br>查了下参数：<br>default_tmp_storage_engine。（5.6，5.7当前值都是innodb）<br>internal_tmp_disk_storage_engine（只有5.7有这个参数，当前值是innodb），5.6应该是默认磁盘临时表就是MyISAM引擎的了，由于本地测试环境那个临时表的目录下找不到临时文件，也没法继续分析了。。。<br><br>至于为什么MySQL 5.6中结果展示m字段不是0-9而是1-10，还得请老师帮忙解答下了。<br><br><br>还有几个小问题，为了方便解答，序号统一了：<br>（3）在阅读mysql执行计划的时候，看了网上有很多说法，也参考了mysql官网对id（select_id）的解释：<br>id (JSON name: select_id)<br>The SELECT identifier. This is the sequential number of the SELECT within the query.（感觉这个读起来也有点歧义，这个sequential字面解释感觉只有顺序的号码，并咩有说执行顺序）<br>比如图1，文中解释就是从ID小的往大的执行的，网上有很多其他说法，有的是说ID从大到小执行，遇到ID一样的，就从上往下执行。有的说是从小往大顺序执行。不知道老师是否可以官方讲解下。<br><br>（4）我发现想搞懂一个原理，并且讲清楚让别人明白，真的是很有难度，非常感谢老师的分享。这次专栏结束，还会推出的新的专栏吗？ 非常期待。","like_count":10,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438633,"discussion_content":"1. 是的，我默认是用5.7做的验证，这里5.7做了优化。\n2. 其实你已经找到原因了，就是因为5.6的默认临时表是myisam表，而myisam表是堆表，这里的堆表，跟38篇介绍的memory引擎是类似的，你看了那篇应该就能知道为什么堆表是最后显示0那行了\n3. 好问题，不同id从大到小，相同id从上到下\n4. 多谢你的鼓励，还没定，先休息下^_^\n\n不好意思，你发的第一天就看到了，回复晚了😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551376809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65991,"user_name":"兔斯基","can_delete":false,"product_type":"c1","uid":1061320,"ip_address":"","ucode":"146A5FE2D8B301","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/c8/a64e4aef.jpg","comment_is_top":false,"comment_ctime":1549842952,"is_pvip":false,"replies":[{"id":"23404","content":"这三种写法语义上不一样。。<br><br>如果对返回结果没有顺序要求，那写上order by null肯定是好的。<br><br>“order by null”和“不加order by”不等价，咱们文中有说哈","user_name":"作者回复","comment_id":65991,"uid":"1264162","ip_address":"","utype":1,"ctime":1549873762,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"35909581320","product_id":100020801,"comment_content":"老师，关于排序有几个问题。<br>order by id，主键<br>order by null，<br>不加order by<br>这三种写法哪种执行效率更高一些？后面两者是不是等价的？","like_count":8,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438669,"discussion_content":"这三种写法语义上不一样。。\n\n如果对返回结果没有顺序要求，那写上order by null肯定是好的。\n\n“order by null”和“不加order by”不等价，咱们文中有说哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549873762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66099,"user_name":"梦康","can_delete":false,"product_type":"c1","uid":1069512,"ip_address":"","ucode":"8935F3C329C58E","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/c8/83852d5a.jpg","comment_is_top":false,"comment_ctime":1549877221,"is_pvip":false,"replies":[{"id":"25701","content":"看索引的名字猜测， idx_aid_day_pv 就是(adid, day,pv)这三个字段的联合索引？<br><br>这样的话，第二个语句就会顺序遍历索引，只要找到10个不同的aid就可以了，这个索引不用全部遍历；这样可以减少很多写入临时表的数据；<br><br>但是第一个语句是day开头的， 这样就必须将所有`day`&amp;gt;20190115的记录都存到临时表中，这个要写入内存表的数据行数肯定比第二个语句多的<br><br>所以核心就是这两个语句需要放入临时表的行数不同。<br><br>","user_name":"作者回复","comment_id":66099,"uid":"1264162","ip_address":"","utype":1,"ctime":1551377601,"user_name_real":"林晓斌"}],"discussion_count":6,"race_medal":0,"score":"31614648293","product_id":100020801,"comment_content":"实践发现文中描述的 group by 执行过程中解释不通。案例如下<br><br>select `aid`,sum(`pv`) as num from article_rank force index(idx_day_aid_pv)  where `day`&gt;20190115 group by aid order by num desc LIMIT 10;<br><br>内存临时表不够，需要写入磁盘<br><br>select `aid`,sum(`pv`) as num from article_rank force index(idx_aid_day_pv)  where `day`&gt;20190115 group by aid order by num desc LIMIT 10;<br><br>内存临时表足够。<br><br>选的索引不一样，但是最后筛选出来的总行应该是一样的呀，所以现在更加困惑了。","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438702,"discussion_content":"看索引的名字猜测， idx_aid_day_pv 就是(adid, day,pv)这三个字段的联合索引？\n\n这样的话，第二个语句就会顺序遍历索引，只要找到10个不同的aid就可以了，这个索引不用全部遍历；这样可以减少很多写入临时表的数据；\n\n但是第一个语句是day开头的， 这样就必须将所有`day`&amp;amp;gt;20190115的记录都存到临时表中，这个要写入内存表的数据行数肯定比第二个语句多的\n\n所以核心就是这两个语句需要放入临时表的行数不同。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551377601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2086624,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d6/e0/3ccaaa7b.jpg","nickname":"领子","note":"","ucode":"64AC4E6AB74E68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296088,"discussion_content":"由于day是范围条件，会使联合索引(idx_day_aid_pv)中的aid失效，那么分组将不走索引，就需要用到临时表，取出所有的聚合结果再limit10,联合索引(idx_aid_day_pv）满足分组走索引，条件day过滤后，就可以按索引顺序取10个不同的aid值，而不用扫描全部的结果行","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596449037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1464006,"avatar":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","nickname":"斐波那契","note":"","ucode":"85E2EBC01392B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201880,"discussion_content":"你这个问题有点意思 感觉可以复习到前面老师讲的索引章节 对于你这个问题 你看一下是不是这么个情况 就是你这张表里数据aid种类非常多 比如 表里有10万条数据 每一种aid就2 3个 这样这个表里就有4 5万种aid 如果是那我大概理解老师讲的意思 然后你在弄一张相同的表(包括索引) 里面放几种aid但是每一种aid的个数非常非常多 然后在看一下语句一 是不是也只用临时表没有写入磁盘 如果不是我说的这种情况 那只能坐等大神了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583847455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9715,"discussion_content":"老师，你的回复好像有点问题。\n第二个语句的索引还是会全部遍历的吧，因为有order by num desc需要排序，所以从索引中查找出来符合条件的数据还是会写到临时表中，只是在排序的时候，仅仅需要获取10行数据，而不用全部排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568208083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18095,"discussion_content":"为啥我看到两条语句是一个样子的。。。你那啥情况?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569021938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9715,"ip_address":""},"score":18095,"extra":""},{"author":{"id":2101988,"avatar":"https://static001.geekbang.org/account/avatar/00/20/12/e4/57ade29a.jpg","nickname":"dva","note":"","ucode":"EE27DAFCBF198D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303275,"discussion_content":"索引不一样 force index 强制用的索引","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599206845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":18095,"ip_address":""},"score":303275,"extra":""}]}]},{"had_liked":false,"id":208124,"user_name":"否极泰来","can_delete":false,"product_type":"c1","uid":1439355,"ip_address":"","ucode":"C249173266251A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","comment_is_top":false,"comment_ctime":1587281855,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23062118335","product_id":100020801,"comment_content":"请教一个问题：mysql正常一条sql的基本执行顺序是：from &gt; where &gt; group by &gt; select &gt; order by<br>select id%10 as m, count(*) as c from t1 group by m;<br>为什么这条SQL语句没有m字段能正常执行了？是因为select as 语句先于group by执行吗？？<br>感觉比较奇怪不是太理解","like_count":5,"discussions":[{"author":{"id":1147895,"avatar":"https://static001.geekbang.org/account/avatar/00/11/83/f7/a24b7242.jpg","nickname":"简单","note":"","ucode":"19A01CB4B9ED8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374521,"discussion_content":"同样有这样的问题，请问解答了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621232418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71795,"user_name":"Sinyo","can_delete":false,"product_type":"c1","uid":1307297,"ip_address":"","ucode":"57B243E7AB86A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJAibnPX9jW8kqLcIfibjic8GbkQkEUYyFKJkc39hZhibVlNrqwTjdLozkqibI2IwACd5YzofYickNxFnZg/132","comment_is_top":false,"comment_ctime":1551434498,"is_pvip":false,"replies":[{"id":"26021","content":"需要创建临时表的时候，与当前访问数据的引擎无关，都是默认创建内存临时表，内存不够了转磁盘临时表（默认是innodb 表）","user_name":"作者回复","comment_id":71795,"uid":"1264162","ip_address":"","utype":1,"ctime":1551456711,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"23026270978","product_id":100020801,"comment_content":"谢谢老师解惑，<br>再次请教老师，那其他引擎数据库在server层建的磁盘临时表是什么引擎呢？","like_count":5,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441335,"discussion_content":"需要创建临时表的时候，与当前访问数据的引擎无关，都是默认创建内存临时表，内存不够了转磁盘临时表（默认是innodb 表）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551456711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81041,"user_name":"路过","can_delete":false,"product_type":"c1","uid":1316401,"ip_address":"","ucode":"7152C19ED024CC","user_header":"https://static001.geekbang.org/account/avatar/00/14/16/31/ae8adf82.jpg","comment_is_top":false,"comment_ctime":1553783471,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10143718063","product_id":100020801,"comment_content":"请教：<br>文章中的第一个案例语句，如果把limit 2去掉，即如下：<br>(select 1000 as f) union (select id from t1 order by id desc);<br>按照我的理解，应该得到从1000到1的降序排列数据。但结果出乎意料：<br>1000<br>1<br>2<br>。。。<br>999<br>这是为何啊？<br>如果把上面的语句加上limit 1000，即：<br>(select 1000 as f) union (select id from t1 order by id desc limit 1000);<br>结果就是从1000到1的降序排列。搞不懂，请老师解惑！","like_count":2,"discussions":[{"author":{"id":1303322,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/1a/061e77b6.jpg","nickname":"亢星东","note":"","ucode":"5E4063E83B2BB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332727,"discussion_content":"order by null","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607325413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2101988,"avatar":"https://static001.geekbang.org/account/avatar/00/20/12/e4/57ade29a.jpg","nickname":"dva","note":"","ucode":"EE27DAFCBF198D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303299,"discussion_content":"查询资料发现：在mysql5.7中，如果不加limit，系统会把order by优化掉。\n我测试过加了limit就可以了\nhttps://www.cnblogs.com/zhou-pan/p/10075987.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599209433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73726,"user_name":"进阶的码农","can_delete":false,"product_type":"c1","uid":1017821,"ip_address":"","ucode":"D8991282640334","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/dd/4f53f95d.jpg","comment_is_top":false,"comment_ctime":1551964752,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10141899344","product_id":100020801,"comment_content":"select id%10 as m, count(*) as c from t1 group by m;<br>我执行这条语句 第一行是1 没有经过排序，我explain 这条语句也没有显示sort 但是显示用了临时表，可能是什么原因的，和mysql版本有关吗？还是配置？","like_count":2,"discussions":[{"author":{"id":1968721,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/unkzY52hVDjTmZJGNkrBR75tFs4XTGBoYYcOYkIcPvHlQrLibwc94aBfj1uWiawoKeEMwHbkvgThXZarfoP8Dzag/132","nickname":"她","note":"","ucode":"FAC6851866C9C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411424,"discussion_content":"版本意识很重要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635925153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475240,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/RCRZYVn8Z77iaSfIia2uhvDricTiaRngFXy79A9kvlKQwmScXNQpKnypy70l2NF0bF3Lxwia4ngQyH7zyMbS2PrXe1A/132","nickname":"啊广","note":"","ucode":"CBA6EF9EFE9BCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5758,"discussion_content":"我的也是，用的8.0.13","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566460740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1475240,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/RCRZYVn8Z77iaSfIia2uhvDricTiaRngFXy79A9kvlKQwmScXNQpKnypy70l2NF0bF3Lxwia4ngQyH7zyMbS2PrXe1A/132","nickname":"啊广","note":"","ucode":"CBA6EF9EFE9BCB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334701,"discussion_content":"8.0不排序了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607944900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5758,"ip_address":""},"score":334701,"extra":""}]}]},{"had_liked":false,"id":67601,"user_name":"黄文韬","can_delete":false,"product_type":"c1","uid":1302800,"ip_address":"","ucode":"60BE7A087E1612","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/10/6a1fe19a.jpg","comment_is_top":false,"comment_ctime":1550207529,"is_pvip":false,"replies":[{"id":"24003","content":"1. 啊 比较奇怪，你可否给一下截图，（比如发个微博，贴图at我），带上表结构哈<br>2. 好问题，其实这个是要结合下一篇文章的知识点，内存表的主键不是保证有序的","user_name":"作者回复","comment_id":67601,"uid":"1264162","ip_address":"","utype":1,"ctime":1550298718,"user_name_real":"林晓斌"}],"discussion_count":3,"race_medal":0,"score":"10140142121","product_id":100020801,"comment_content":"老师，有两个问题不是很清楚:<br>1. 图三显示union all没有使用临时表，但是我本地explain看到union all和union的执行计划是一样的，不知道为什么？是和版本有关系还是其他设置？本地版本5.6<br>2.图四 不太理解为什么会用filesort，因为我看你后面执行流程是说会创建一个临时表，主键是m，那为啥不可以直接根据m来排序，而要用到filesort外部排序，还是这个filesort是指的不是按表中索引的排序都会是filesort？？<br>感谢","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439272,"discussion_content":"1. 啊 比较奇怪，你可否给一下截图，（比如发个微博，贴图at我），带上表结构哈\n2. 好问题，其实这个是要结合下一篇文章的知识点，内存表的主键不是保证有序的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550298718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2731036,"avatar":"","nickname":"Geek_dbfa54","note":"","ucode":"4D08C03EE7F516","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400008,"discussion_content":"mysql5.7做了优化，将mysql版本切换到5.7就和老师截图效果相同了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633139199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241618,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/12/50eff143.jpg","nickname":"骋","note":"","ucode":"6FC534BA9FCE3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2223,"discussion_content":"遇到了和问题1同样的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563361944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65982,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1021017,"ip_address":"","ucode":"2002460CB3D869","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/59/ac2aa72b.jpg","comment_is_top":false,"comment_ctime":1549816203,"is_pvip":true,"replies":[{"id":"23383","content":"对的，👍🏿细致<br><br>发起勘误了，新年快乐","user_name":"作者回复","comment_id":65982,"uid":"1264162","ip_address":"","utype":1,"ctime":1549854574,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"10139750795","product_id":100020801,"comment_content":"当碰到第一个 2 的时候，已经知道累积了 Y 个 1，结果集里的第一行就是 (1,Y);<br>---- <br>应该是 结果集里的第 二 行 吧<br><br><br><br>","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438668,"discussion_content":"对的，👍🏿细致\n\n发起勘误了，新年快乐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549854574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65562,"user_name":"poppy","can_delete":false,"product_type":"c1","uid":1182792,"ip_address":"","ucode":"2ED2BDF703D0D9","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/48/ba59d28d.jpg","comment_is_top":false,"comment_ctime":1549455463,"is_pvip":false,"replies":[{"id":"23224","content":"新年好~ <br><br>👍","user_name":"作者回复","comment_id":65562,"uid":"1264162","ip_address":"","utype":1,"ctime":1549502762,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"10139390055","product_id":100020801,"comment_content":"老师，春节快乐，过年还在更新，辛苦辛苦。<br>关于思考题，我的理解是图8中的查询是使用了内存临时表，存储的顺序就是id%10的值的插入顺序，而图9中的查询，由于内存临时表大小无法满足，所以使用了磁盘临时表，对于InnoDB来说，就是对应B+树这种数据结构，这里会按照id%100(即m)的大小顺序来存储的，所以返回的结果当然也是有序的","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438500,"discussion_content":"新年好~ \n\n👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549502762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320179,"user_name":"W_波","can_delete":false,"product_type":"c1","uid":2563866,"ip_address":"","ucode":"167D3DBCDC086F","user_header":"https://static001.geekbang.org/account/avatar/00/27/1f/1a/78fc275d.jpg","comment_is_top":false,"comment_ctime":1636106647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5931073943","product_id":100020801,"comment_content":"老师你好，请问一下使用union all的时候不会产生临时表吗？","like_count":1},{"had_liked":false,"id":122266,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1565326825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860294121","product_id":100020801,"comment_content":"疑问：<br>set tmp_table_size=1024;<br>select id%100 as m, count(*) as c from t1 group by m order by null limit 10;<br><br>结果不需要排序，为什么不像第 17 章《如何正确显示随机消息》，采用优先队列排序算法。这里只需要维护一个 10 个元素的堆就可以了。<br><br>----<br><br>课后思考题：<br>使用磁盘临时表（engine=innodb），排首位的是 0，而内存临时表（engine=memory）却是 1。为何会有这种区别？<br><br>扫描计算的过程都是一样的，扫描 a 索引的时候，都是先扫描 1，再扫描 10。<br>m 字段是磁盘临时表和内存临时表的主键。<br><br>磁盘临时表是以 B+ 树存储数据，插入 m=0 时，会被动态调整到首位。而内存临时表是以数组保存数据，每次都是往数组末端添加元素，不会动态调整。因此产生了这个差异。","like_count":1},{"had_liked":false,"id":73663,"user_name":"Sinyo","can_delete":false,"product_type":"c1","uid":1307297,"ip_address":"","ucode":"57B243E7AB86A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJAibnPX9jW8kqLcIfibjic8GbkQkEUYyFKJkc39hZhibVlNrqwTjdLozkqibI2IwACd5YzofYickNxFnZg/132","comment_is_top":false,"comment_ctime":1551952746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846920042","product_id":100020801,"comment_content":"老师好，好奇怪我用infobright列式存储引擎explain一条union语句，发现是不用临时表的，测试了很多次：<br>比如：<br>EXPLAIN <br>(SELECT 111)<br>UNION <br>(SELECT 222)<br>；<br>EXPLAIN <br>(SELECT 111)<br>UNION <br>(SELECT id from aaa)<br>；<br>EXPLAIN <br>(SELECT id from bbb)<br>UNION <br>(SELECT id from aaa)<br>以上都没有用到临时表；<br>这应该说明不同引擎的逻辑层还是存在差异的把。","like_count":1},{"had_liked":false,"id":66075,"user_name":"梦康","can_delete":false,"product_type":"c1","uid":1069512,"ip_address":"","ucode":"8935F3C329C58E","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/c8/83852d5a.jpg","comment_is_top":false,"comment_ctime":1549870855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5844838151","product_id":100020801,"comment_content":"有一张表article_rank 里面有是个字段（id,aid,pv,day），都是 int 类型。现执行如下 sql<br>select `aid`,sum(`pv`) as num from article_rank where `day`&gt;20190115 group by aid order by num desc limit 10;<br><br>optimizer_trace 结果中关于执行阶段数据解读还是有些问题。<br>  {<br>    &quot;creating_tmp_table&quot;: {<br>      &quot;tmp_table_info&quot;: {<br>        &quot;table&quot;: &quot;intermediate_tmp_table&quot;,<br>        &quot;row_length&quot;: 20,<br>        &quot;key_length&quot;: 4,<br>        &quot;unique_constraint&quot;: false,<br>        &quot;location&quot;: &quot;memory (heap)&quot;,<br>        &quot;row_limit_estimate&quot;: 838860<br>      }<br>    }<br>  },<br>  {<br>    &quot;converting_tmp_table_to_ondisk&quot;: {<br>      &quot;cause&quot;: &quot;memory_table_size_exceeded&quot;,<br>      &quot;tmp_table_info&quot;: {<br>        &quot;table&quot;: &quot;intermediate_tmp_table&quot;,<br>        &quot;row_length&quot;: 20,<br>        &quot;key_length&quot;: 4,<br>        &quot;unique_constraint&quot;: false,<br>        &quot;location&quot;: &quot;disk (InnoDB)&quot;,<br>        &quot;record_format&quot;: &quot;fixed&quot;<br>      }<br>    }<br>  }<br><br>1. row_length 为什么是20呢？我 gdb 调试确认临时表里存放的是 aid，num。 aid 4个字节，num 因为是 sum 的结果是 DECIMAL 类型，所以是15个字节，不知道为什么总长度是20字节了。测试其他 sql 均发现row_length会比临时表种的字段所占长度多1字节，这是为何呢？<br>2. 创建临时表提示内存超出限制，但是根据第一步行数限制是 838860 行，实际总共符合条件的行数为 649091 通过 select count(distinct aid) from article_rank where `day`&gt;20190115 查询得到。为什么会超出内存呢？<br><br>麻烦老师帮忙解答下。谢谢啦。","like_count":1},{"had_liked":false,"id":65576,"user_name":"牛牛","can_delete":false,"product_type":"c1","uid":1194626,"ip_address":"","ucode":"CFCE68B4F92209","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg","comment_is_top":false,"comment_ctime":1549463427,"is_pvip":false,"replies":[{"id":"23222","content":"新年快乐~🤝","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549502532,"ip_address":"","comment_id":65576,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5844430723","product_id":100020801,"comment_content":"新年快乐～、感谢有您～^_^～","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438505,"discussion_content":"新年快乐~🤝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549502532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65526,"user_name":"八百","can_delete":false,"product_type":"c1","uid":1253530,"ip_address":"","ucode":"79F1F79ADF5A00","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/9a/3b1c65fd.jpg","comment_is_top":false,"comment_ctime":1549430239,"is_pvip":false,"replies":[{"id":"23215","content":"新年快乐🤝","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549441706,"ip_address":"","comment_id":65526,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5844397535","product_id":100020801,"comment_content":"春节快乐，老师。谢谢你让我学到不少知识","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438489,"discussion_content":"新年快乐🤝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549441706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65495,"user_name":"某、人","can_delete":false,"product_type":"c1","uid":1308784,"ip_address":"","ucode":"ADB42AA12A11C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/f8/70/f3a33a14.jpg","comment_is_top":false,"comment_ctime":1549418377,"is_pvip":false,"replies":[{"id":"23210","content":"春节快乐，🤝","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549427593,"ip_address":"","comment_id":65495,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5844385673","product_id":100020801,"comment_content":"老师春节快乐，辛苦了","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438473,"discussion_content":"春节快乐，🤝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549427593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358002,"user_name":"Geek_eabafe","can_delete":false,"product_type":"c1","uid":3167302,"ip_address":"北京","ucode":"4D94487320B33B","user_header":"","comment_is_top":false,"comment_ctime":1663827779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663827779","product_id":100020801,"comment_content":"老师 是不是可以这样理解<br>内存临时表就是engine=memory；<br>磁盘临时表就是 engine=innodb;","like_count":0},{"had_liked":false,"id":346359,"user_name":"鞠振泰","can_delete":false,"product_type":"c1","uid":1258930,"ip_address":"","ucode":"E7E698250DD436","user_header":"https://static001.geekbang.org/account/avatar/00/13/35/b2/a64546fb.jpg","comment_is_top":false,"comment_ctime":1653043949,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653043949","product_id":100020801,"comment_content":"老师，我这边遇到一个问题。<br>现象：从库查询如下语句，count结果不对。<br>表情况：两个表关联结果是5条，having条件指定的ordercode值对应右表5条记录（两个deliveryorder值，一个对应一条明细记录，另一个对应4条明细记录）。但将order_code放注释位置count结果是1，放最下面count结果是5，在主库上执行都是5，实际count也应该为5。是哪个系统参数能影响到吗？（不存在数据一致性问题。delivery_order_202205表120w数据，delivery_order_detail_202205表500w数据. 先不看语句性能问题，这是一个研发小伙伴发我看到的情况）<br><br>语句：<br>SELECT<br>\ta.sale_store_code,<br>\ta.channel_order_code,<br>\ta.order_code,<br>\tcount( 0 ) <br>FROM<br>\tdelivery_order_202205 a<br>\tLEFT JOIN delivery_order_detail_202205 b ON a.delivery_order_code = b.delivery_order_code <br>WHERE<br>\ta.delivery_state &lt;&gt; &#39;CANCEL&#39; <br>GROUP BY<br>\ta.sale_store_code,<br>\ta.order_code,<br>\ta.channel_order_code -- , a.order_code<br>\t<br>HAVING<br>\ta.order_code = &#39;EO2022050100019796&#39;","like_count":0},{"had_liked":false,"id":345659,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1057843,"ip_address":"","ucode":"BC93175B70E05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","comment_is_top":false,"comment_ctime":1652494984,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652494984","product_id":100020801,"comment_content":"老师，请教一下，我们一般创建用 insert into tmp_xxx (select * from xxx) 往临时表里面插入数据，但是会发现 select * from tmp_xxx 出来的结果跟 select * from xxx 顺序是不一样的。怎样才能怎么保证两者的顺序是一致的呢？","like_count":0},{"had_liked":false,"id":337014,"user_name":"。。","can_delete":false,"product_type":"c1","uid":2853618,"ip_address":"","ucode":"A52A6043D27D87","user_header":"https://static001.geekbang.org/account/avatar/00/2b/8a/f2/6c6f7886.jpg","comment_is_top":false,"comment_ctime":1646553056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646553056","product_id":100020801,"comment_content":"老师，有几个疑惑的点，<br><br>1.在 join 优化中，一个小表可能是 where 后的限定条件，但是根据sql执行顺序，join 在 where 之前执行，也就是先连接后执行 where，但是按照文中的意思有种先 where后 join 的感觉，不是很理解。limit 也是，例如 select * from t1 limit 2，是查询出所有结果再取前两条。还是取出前两条就返回呢。<br><br>2.用文中的表来操作，Q1和Q3一样，均进行了全表扫描，扫描了 1000行。Q2使用了主键索引，扫描了2行。但是我个人感觉这三个sql的语义是一样的，Q1中没有where条件之类的，没有其他索引可用，因此是在主键索引上找前两条记录，因此感觉和 Q2 中加 `order by id` 是一回事，Q2也是同样的语义。但是仅扫描了2行。最奇怪的是 Q4，我已经指定用索引a了，但是他并没有用到索引，而是走了全表扫描，扫描了 1000行，force index 不应该是强行指定了吗？<br><br>   explain select * from t1 limit 2; &#47;*Q1*&#47;<br>   explain select * from t1 order by id limit 2  &#47;*Q2*&#47;<br>   explain select * from t1 force index(primary) limit 2;  &#47;*Q3*&#47;<br>   explain select * from t1 force index(a) limit 2;   &#47;*Q4*&#47;","like_count":0},{"had_liked":false,"id":333898,"user_name":"qiushye","can_delete":false,"product_type":"c1","uid":1322164,"ip_address":"","ucode":"D005A152F8BEDC","user_header":"","comment_is_top":false,"comment_ctime":1644573331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644573331","product_id":100020801,"comment_content":"我在没加索引的时候直接explain group by，Extra里没有file sort信息是为什么呢？用SQL_BIG_RESULT后才会有","like_count":0},{"had_liked":false,"id":305332,"user_name":"老杨的杨","can_delete":false,"product_type":"c1","uid":1618247,"ip_address":"","ucode":"B744208C9E9752","user_header":"https://static001.geekbang.org/account/avatar/00/18/b1/47/05a00f4c.jpg","comment_is_top":false,"comment_ctime":1627909340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627909340","product_id":100020801,"comment_content":"MySQL 句柄数占用过多的该咋办呀 看好多都是临时表的 而且lsof看 是deleted","like_count":0},{"had_liked":false,"id":298894,"user_name":"walzzz","can_delete":false,"product_type":"c1","uid":1707393,"ip_address":"","ucode":"17D8079494189A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0d/81/ed4957e8.jpg","comment_is_top":false,"comment_ctime":1624361285,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1624361285","product_id":100020801,"comment_content":"老师您好！这里“MySQL的优化器一看，磁盘临时表是B+树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。”——意思是实际上并没有使用磁盘临时表吗？所以SQL_BIG_RESULT的意义只是给优化器一个更糟的选项，然后逼迫它最终选择直接排序吗？那什么时候才会走磁盘临时表呢？感谢回答！","like_count":0},{"had_liked":false,"id":298793,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1624327101,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1624327101","product_id":100020801,"comment_content":"这一章的内存临时表和上一章的临时表有什么区别？是一回事吗？","like_count":0,"discussions":[{"author":{"id":2222079,"avatar":"","nickname":"chen","note":"","ucode":"352E1D6548DAE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393879,"discussion_content":"不是，这一章的内存临时表是系统创建的；上一章的临时表是用户临时表，是用户主动创建的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631624955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295946,"user_name":"海","can_delete":false,"product_type":"c1","uid":2418232,"ip_address":"","ucode":"09FAF70D78668A","user_header":"https://static001.geekbang.org/account/avatar/00/24/e6/38/25e7cce5.jpg","comment_is_top":false,"comment_ctime":1622680013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622680013","product_id":100020801,"comment_content":"select id%100<br>as m, min(id) as min_id  from t group by m <br><br>这种查询语句可以用SQL_BIG_RESULT来优化吗","like_count":0},{"had_liked":false,"id":278241,"user_name":"Khirye","can_delete":false,"product_type":"c1","uid":1080985,"ip_address":"","ucode":"6C54C126FA54B8","user_header":"https://static001.geekbang.org/account/avatar/00/10/7e/99/c4302030.jpg","comment_is_top":false,"comment_ctime":1612841789,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1612841789","product_id":100020801,"comment_content":"老师你好，我在我们线上数据库随便找了个表执行“explain select id%10 as m, count(*) as c from user_receive_coupon_record group by id“,explain结果里并没有Using temporary。请问可能的原因是什么？","like_count":0,"discussions":[{"author":{"id":2603445,"avatar":"https://static001.geekbang.org/account/avatar/00/27/b9/b5/7975f3a3.jpg","nickname":"⭕️⭕️","note":"","ucode":"999231614A28A3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566877,"discussion_content":"group by错了。。。以id分组没意义。count都是1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650787522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244568,"user_name":"瑞哲","can_delete":false,"product_type":"c1","uid":1502093,"ip_address":"","ucode":"9F170728A055AD","user_header":"https://static001.geekbang.org/account/avatar/00/16/eb/8d/8ee78d3d.jpg","comment_is_top":false,"comment_ctime":1598583535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598583535","product_id":100020801,"comment_content":"回答问题：innoDB会默认取m字段作为","like_count":0},{"had_liked":false,"id":226811,"user_name":"轻松的鱼","can_delete":false,"product_type":"c1","uid":1219198,"ip_address":"","ucode":"F4FF653209C47B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEl3fX9nvzUF26ekUIicp4sgA5jZ1mGvGMhIHkwJabbjt9h5uTLw5zzU1U6JZbCSpRXBNQwuejLJg/132","comment_is_top":false,"comment_ctime":1592208514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592208514","product_id":100020801,"comment_content":"“group by 优化方法 -- 直接排序”提到的算法，在没有索引、临时结果很大会产生磁盘临时表的情况下，通过 sort_buffer 排序方法直接避免了利用临时表得到分组结果。<br><br>但是一开始介绍的 group by 执行流程，临时结果数据量小，创建“内存临时表”后还是需要排序，看起来还是比不上“直接排序”的效率，为什么不一律使用“直接排序”算法呢？","like_count":0},{"had_liked":false,"id":218069,"user_name":"复兴","can_delete":false,"product_type":"c1","uid":1363230,"ip_address":"","ucode":"C172A87873001A","user_header":"https://static001.geekbang.org/account/avatar/00/14/cd/1e/692c3313.jpg","comment_is_top":false,"comment_ctime":1589707396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589707396","product_id":100020801,"comment_content":"临时表的主键，不是主键索引吧，如果是的，那么插入的过程中，已经保证其顺序了，最后也就不需要排序了","like_count":0},{"had_liked":false,"id":207074,"user_name":"吃水不用钱","can_delete":false,"product_type":"c1","uid":1797135,"ip_address":"","ucode":"8A5D5978F0D4E5","user_header":"https://static001.geekbang.org/account/avatar/00/1b/6c/0f/7d242cc2.jpg","comment_is_top":false,"comment_ctime":1587002999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587002999","product_id":100020801,"comment_content":"请问老师，本节中的内存临时表，按上一节的分类，是内存表，还是临时表？还是兼备两者的特性？","like_count":0},{"had_liked":false,"id":204042,"user_name":"柳十三","can_delete":false,"product_type":"c1","uid":1385852,"ip_address":"","ucode":"FE50C9778914C6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/tKvmZ3Vs4t6RZ3X7cAliaW47Zatxhn1aV5PcCYT9NZ9k9WWqRrEBGHicGtRWvsG6yQqHnaWw6cGNSbicNLjZebcHA/132","comment_is_top":false,"comment_ctime":1586324054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586324054","product_id":100020801,"comment_content":"图七按查询结果中的m在排序，图八加上order by null，会走索引排序,按id进行排序,图九是先group by，结果是按照m在排序，官方说明，如果查询结果是有序的，limit与order by一起使用，会停止排序。","like_count":0},{"had_liked":false,"id":189167,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1584462587,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1584462587","product_id":100020801,"comment_content":"“order by null”和“不加order by”有什么区别啊<br>","like_count":0,"discussions":[{"author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363600,"discussion_content":"不加order by 会进行排序   order by null 不会排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617244098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/e9/f244988e.jpg","nickname":"NIRVANA","note":"","ucode":"F3A979679AA44E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283198,"discussion_content":"前者性能更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592209263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186458,"user_name":"小予","can_delete":false,"product_type":"c1","uid":1442580,"ip_address":"","ucode":"3F5EAEE1746074","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/14/e9ca2d09.jpg","comment_is_top":false,"comment_ctime":1583847495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583847495","product_id":100020801,"comment_content":"回答问题<br>图8是内存临时表，如果不排序就是按插入临时表的顺序取出来，所以0在最后一行。 图9是磁盘临时表并且使用了innoDB引擎，虽然没有排序，但是在插入innoDB表的时候会按字段m排序，再从innoDB表取出来，这是已经是按m拍排好序的了，所以0在第一行","like_count":0},{"had_liked":false,"id":181684,"user_name":"与狼共舞","can_delete":false,"product_type":"c1","uid":1391144,"ip_address":"","ucode":"02AC04B43F0194","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/28/cf707831.jpg","comment_is_top":false,"comment_ctime":1582616349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582616349","product_id":100020801,"comment_content":"generated column 机制、SQL_BIG_RESULT和 order by null 以前还真没有用过，GET到了新技能，generated column 机制貌似在 percona 里不适用。","like_count":0},{"had_liked":false,"id":179711,"user_name":"辉煌码农","can_delete":false,"product_type":"c1","uid":1332799,"ip_address":"","ucode":"09779C2E06EA52","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIy5ULaodUwsLoPuk1wd22hqXsaBbibNEqXM0kgrCTYDGKYQkZICYEyH9wMj4hyUicuQwHdDuOKRj0g/132","comment_is_top":false,"comment_ctime":1582082069,"is_pvip":false,"replies":[{"id":"69784","content":"就是使用了临时表呀","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1582086061,"ip_address":"","comment_id":179711,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1582082069","product_id":100020801,"comment_content":"老师您好，请问下，这种场景下为什么会有Using temporary呢？https:&#47;&#47;stackoverflow.com&#47;questions&#47;36143560&#47;mysql-update-query-using-a-temporary-table-when-an-equivalent-select-query-does","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484364,"discussion_content":"就是使用了临时表呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582086061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332799,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIy5ULaodUwsLoPuk1wd22hqXsaBbibNEqXM0kgrCTYDGKYQkZICYEyH9wMj4hyUicuQwHdDuOKRj0g/132","nickname":"辉煌码农","note":"","ucode":"09779C2E06EA52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178373,"discussion_content":"为什么会使用临时表呢，select没有使用，而update却使用了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582160308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146428,"user_name":"Garen","can_delete":false,"product_type":"c1","uid":1672786,"ip_address":"","ucode":"0608C88F83EF0C","user_header":"https://static001.geekbang.org/account/avatar/00/19/86/52/91c7d112.jpg","comment_is_top":false,"comment_ctime":1572520325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572520325","product_id":100020801,"comment_content":"老师您好：<br>看了文章，group by 不会使用磁盘临时表，会使用排序算法。我原以为不使用磁盘临时表是因为磁盘临时表就能获得count(*)了，如果多一些查询结果，应该会使用磁盘临时表。但是我执行下面的语句，依旧使用了排序算法。为什么会这样呢？<br><br>explain select SQL_BIG_RESULT id%100 as m, count(*) as c, max(id),min(id),id,a,b from t1 group by m;","like_count":0},{"had_liked":false,"id":146038,"user_name":"测小试","can_delete":false,"product_type":"c1","uid":1668301,"ip_address":"","ucode":"591F2D8CFBF503","user_header":"https://static001.geekbang.org/account/avatar/00/19/74/cd/158dc733.jpg","comment_is_top":false,"comment_ctime":1572422602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572422602","product_id":100020801,"comment_content":"为什么InnoDB引擎进行group by操作是默认排序的呢？","like_count":0},{"had_liked":false,"id":130632,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1567497794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567497794","product_id":100020801,"comment_content":"sort_buffer排序后形成有序临时表","like_count":0},{"had_liked":false,"id":125695,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1566227272,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566227272","product_id":100020801,"comment_content":"您好，请问下 select id%100 as m, count(*) as c from t1 group by m; 这个sql为什么会命中索引a呢，不太明白，要说他跟 id 主索引有关我还能理解点，请帮我科普下多谢了<br>","like_count":0,"discussions":[{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6889,"discussion_content":"老师在上面的问题有回答过。这个可能是Mysql 优化器的选择。如果用 primary 主键，它的叶子节点就是所有的数据。如果用索引 a ,它的叶子节点就是 主键 id。两种情况相比，用索引 a 的空间，读取的数据量会更少。而 SQL 语句中只需要 count(*) ，统计总数而已，所以，选择用索引 a 的“成本”更低。\n我也是看老师的回答，脑补的自己的理解。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567154371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125399,"user_name":"fww17612593599","can_delete":false,"product_type":"c1","uid":1589430,"ip_address":"","ucode":"ADDADDB696130F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/hBbNOLicWdz7s3TricdpGeBZcibjcvW0FkLhs88FgaicBJmRofHeIKedZvPj2ib8RTyYia7kVMED3picOcB9VBdXjJJCA/132","comment_is_top":false,"comment_ctime":1566179237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566179237","product_id":100020801,"comment_content":"老师请问一下internal_tmp_disk_storage_engine设置成mysiam还是innodb好一些，我看默认的是innodb，不知道为什么我们系统里设置的是mysiam","like_count":0},{"had_liked":false,"id":121157,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1565067559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565067559","product_id":100020801,"comment_content":"内部临时表，完全存在于内存之中，为存放查询的临时数据而生，比如：使用group by 或者 union 的场景，需要先将数据临时存储一下，然后再做下一步处理。<br>另外，使用group by 比较耗性能，文中提供了几种优化的建议。<br>1：group by 字段加索引<br>2：扩大内部临时表的大小<br>3：分组后不需要排序，加上order by null<br>4：如果数据量比较大，直接使用磁盘临时表<br>嗯，这篇也很实用，感谢老师的分享。","like_count":0},{"had_liked":false,"id":119230,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1564540061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564540061","product_id":100020801,"comment_content":"老师，请教个问题，如果tmp_table_size设置太大，比如1G，但实际使用的空间很小，那并发场景下，内存是不是会被用光，为用磁盘临时表呢？","like_count":0},{"had_liked":false,"id":117140,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1563976026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563976026","product_id":100020801,"comment_content":"set tmp_table_size=1024;<br>select id%100 as m, count(*) as c from t1 group by m order by null limit 10;<br>老师您好，有一个疑问，这个例子中为什么内存临时表够用和内存临时表不够用转成磁盘临时表，查询结果会不一样?感觉好像如果转成磁盘临时表被排序了","like_count":0},{"had_liked":false,"id":109393,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1562029468,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1562029468","product_id":100020801,"comment_content":"group by 的几种实现算法，从中可以总结一些使用的指导...<br><br>极客时间版权所有: https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;80477","like_count":0},{"had_liked":false,"id":102316,"user_name":"纸片人","can_delete":false,"product_type":"c1","uid":1358508,"ip_address":"","ucode":"84490E7CEF59A4","user_header":"https://static001.geekbang.org/account/avatar/00/14/ba/ac/b44b256a.jpg","comment_is_top":false,"comment_ctime":1560191407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560191407","product_id":100020801,"comment_content":"林老师，见字安好！<br>在将本章反复看过几遍后，我产生了诸多问题，恳请您拨冗回答。<br>1、首先，内存临时表的二维表结构是什么？从group by处理逻辑的表述来看，既要方便查重，又要更新旧值，显然内存临时表需要出色的定位能力。这方面，Hash表比二维数组更高效。所以示例中的内存临时表是以m为key，c为value的HashMap吗？<br>2、如果查询语句中有多个group字段，MySQL会创建多张内存临时表吗？还是在内存临时表上加一个字段？<br>3、计算count值是可以直接在旧值上叠加。如果计算的是arg，那么MySQL会如何处理呢？在内存表里添字段表示计数值，或先sum再count最后除，还是直接排序同时求和、计数求平均值？<br>4、我尝试将group by的处理逻辑和优化逻辑转换成伪代码，取得了以下发现。<br>&gt; group by处理逻辑：应用临时表<br>\tfor id in t1<br>\t\tm = id%10<br>\t\tincr count(m) from tmp<br>\tend<br>\tsort tmp by m<br><br>&gt; group by+索引：提高原表空间成本，将m = id%10和sort m的计算成本和分摊到插入过程中<br>\tfor m in t1<br>\t\tcount m<br>\tend<br><br>&gt; group by快排：SQL_BIG_RESULT hint<br>\tfor id in t1<br>\t\tm = id%10<br>\t\tadd m into sort_buffer<br>\tend<br>\tsort m<br>\tfor m in sort_buffer<br>\t\tcount m<br>\tend<br><br>发现1：group by需要优化的原因是tmp的构造成本太高了，已知其为(m,c)二元组。<br>发现2：m的计算过程和排序过程不可省略。正常处理逻辑中，需要incr计数值，所以对在tmp中定位m的要求比较高，sort对象是tmp，比直接对m排序多带一个属性c，所以内存占用率高。索引方案中，将大部分计算成本转换成了空间成本或平摊到记录的插入过程中了。快排方案中，sort数量等于t1行数，内存成本不太低，不确定是否小于tmp构造成本。快排最后统计的思路和索引方案时相同，都是“顺序扫描，依次累加”，所以比前二者多一次循环。总之，我的判断是索引方案的响应速度最快，快排方案和临时表方案孰优孰劣应由m的计算方式决定。比如示例中m=id%10，临时表的规模是10，而sort_buffer的规模是1000。显然，快排不一定优于临时表。<br><br>不知道我对group处理流程的“翻译”和推断是否正确？请林老师指正。","like_count":0},{"had_liked":false,"id":96647,"user_name":"HKM","can_delete":false,"product_type":"c1","uid":1155118,"ip_address":"","ucode":"48EE9F58CF8E75","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/2e/82559d5b.jpg","comment_is_top":false,"comment_ctime":1558484117,"is_pvip":false,"replies":[{"id":"34894","content":"MySQL自带的客户端","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1558708761,"ip_address":"","comment_id":96647,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558484117","product_id":100020801,"comment_content":"老师用的什么客户端呢👍","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450952,"discussion_content":"MySQL自带的客户端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558708761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86692,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1555426778,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1555426778","product_id":100020801,"comment_content":"关于图4有个疑惑，还想请老师解答一下。我记得mysql语句执行循序应该是from-&gt;where-&gt;group by-&gt;having-&gt;select-&gt;order-&gt;limit。那么为什么图四中在select语句中起的别名m可以用在group by中作为分组条件呢？按理说不应该是先走group by没有m字段报错吗？（试验了一下，确实如老师实例中那样执行，但是理论上想不通）","like_count":0,"discussions":[{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6890,"discussion_content":"可不可以理解成别名。mysql 在分析器阶段就对 SQL  的语法进行分析，知道客户端命名的各个别名信息，所以，在group by 的时候，别名和原来的名字是互通的，mysql 能理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567154778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83070,"user_name":"刀斧手何在","can_delete":false,"product_type":"c1","uid":1202572,"ip_address":"","ucode":"B99D7ECC3EE954","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/8c/ba81a832.jpg","comment_is_top":false,"comment_ctime":1554392535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554392535","product_id":100020801,"comment_content":"如果 group by 需要统计的数据量不大，尽量只使用内存临时表；<br>尽量使用内存临时表 而不加SQL_BIG_RESULT 是不是因为SQL_BIG_RESULT 不分组就排序 占用太多的sort buff 空间 从而影响同时间段内的其他MySQL 查询。<br>最近有个SQL <br>select sum（student_active），school_id from dt_school_day  goupy by school 扫描300万行 执行2s 多。然后我加上SQL_BIG_RESULT 只需要0.4s <br>想请教一下老师 为啥直接使用sort buff 就能快怎么多 不分组 直接排序 排序的数据多了，应该是时间会慢一下 。是因为数据量多时 临时表 分组时间 太久。再加上分组过程中 临时表 不够用 又改切磁盘表 这块耗时太多吗？还有就是 不推荐使用 SQL_BIG_RESULT吗，用这个有什么影响？<br>thx ","like_count":0},{"had_liked":false,"id":78550,"user_name":"王旭东","can_delete":false,"product_type":"c1","uid":1108106,"ip_address":"","ucode":"61950FD5D5BFF9","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/8a/e3032578.jpg","comment_is_top":false,"comment_ctime":1553173435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553173435","product_id":100020801,"comment_content":"请问针对group by，如何做到先对表进行order by，再在排序后的集合里进行group by分组？<br>SELECT * FROM (SELECT * FROM my_table ORDER BY custom_column DESC) t<br> GROUP BY t.group_name;不生效","like_count":0},{"had_liked":false,"id":73727,"user_name":"进阶的码农","can_delete":false,"product_type":"c1","uid":1017821,"ip_address":"","ucode":"D8991282640334","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/dd/4f53f95d.jpg","comment_is_top":false,"comment_ctime":1551964925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551964925","product_id":100020801,"comment_content":"order by range 也会使用临时表","like_count":0},{"had_liked":false,"id":66926,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1550043042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550043042","product_id":100020801,"comment_content":"过年好，老师。这周 补补落下的课","like_count":0},{"had_liked":false,"id":66900,"user_name":"Long","can_delete":false,"product_type":"c1","uid":1318970,"ip_address":"","ucode":"2417242560360A","user_header":"https://static001.geekbang.org/account/avatar/00/14/20/3a/90db6a24.jpg","comment_is_top":false,"comment_ctime":1550039315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550039315","product_id":100020801,"comment_content":"老师可能没看到，再发下。<br>老师，新年好！ :-)<br><br>有几个版本差异的问题：<br>（1）图1中的执行计划应该是5.7版本以后的吧，貌似没找到说在哪个环境，我在5.6和5.7分别测试了，id = 2的那个rows，在5.6版本（5.6.26）是1000，在5.7版本是2行。应该是5.7做的优化吧？<br><br>（2）图 9 group + order by null 的结果（此盘临时表），这里面mysql5.6里面执行的结果是（1，10），（2，10）...(10，10)，执行计划都是只有一样，没找到差异。<br>跟踪下了下optimizer trace，发现问题应该是在临时表空间满的的时候，mysql5.7用的是：converting_tmp_table_to_ondisk &quot;location&quot;: &quot;disk (InnoDB)&quot;,，而mysql 5.6用的是converting_tmp_table_to_myisam &quot;location&quot;: &quot;disk (MyISAM)&quot;的原因导致的。<br>查了下参数：<br>default_tmp_storage_engine。（5.6，5.7当前值都是innodb）<br>internal_tmp_disk_storage_engine（只有5.7有这个参数，当前值是innodb），5.6应该是默认磁盘临时表就是MyISAM引擎的了，由于本地测试环境那个临时表的目录下找不到临时文件，也没法继续分析了。。。<br><br>至于为什么MySQL 5.6中结果展示m字段不是0-9而是1-10，还得请老师帮忙解答下了。<br><br><br>还有几个小问题，为了方便解答，序号统一了：<br>（3）在阅读mysql执行计划的时候，看了网上有很多说法，也参考了mysql官网对id（select_id）的解释：<br>id (JSON name: select_id)<br>The SELECT identifier. This is the sequential number of the SELECT within the query.（感觉这个读起来也有点歧义，这个sequential字面解释感觉只有顺序的号码，并咩有说执行顺序）<br>比如图1，文中解释就是从ID小的往大的执行的，网上有很多其他说法，有的是说ID从大到小执行，遇到ID一样的，就从上往下执行。有的说是从小往大顺序执行。不知道老师是否可以官方讲解下。<br><br>（4）我发现想搞懂一个原理，并且讲清楚让别人明白，真的是很有难度，非常感谢老师的分享。这次专栏结束，还会推出的新的专栏吗？ 非常期待。","like_count":0},{"had_liked":false,"id":66524,"user_name":"还一棵树","can_delete":false,"product_type":"c1","uid":1317709,"ip_address":"","ucode":"C187F2A141D60E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eop9WylZJicLQxlvXukXUgPp39zJHyyReK5s1C9VhA6rric7GiarbfQMuWhdCCDdxdfL610Hc4cNkn9Q/132","comment_is_top":false,"comment_ctime":1549952926,"is_pvip":false,"replies":[{"id":"23577","content":"嗯 语义就是这么定义的，如果不需要排序，要手动加上 order by null 哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549978133,"ip_address":"","comment_id":66524,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1549952926","product_id":100020801,"comment_content":"group by 执行流程里面，为什么有最后排序操作，感觉这一步是多余的，扫描完最后一行数据后 ，完全可以直接从temporary表返回数据","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438821,"discussion_content":"嗯 语义就是这么定义的，如果不需要排序，要手动加上 order by null 哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549978133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1036567,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d1/17/356cc426.jpg","nickname":"归心","note":"","ucode":"985E3188A9F6FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3210,"discussion_content":"8.0版本就没有了排序操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564306405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65751,"user_name":"Laputa","can_delete":false,"product_type":"c1","uid":1079345,"ip_address":"","ucode":"64C157042CF138","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/31/c7f8d1db.jpg","comment_is_top":false,"comment_ctime":1549618575,"is_pvip":false,"replies":[{"id":"23258","content":"MySQL 语义上这么定义的… ","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549637598,"ip_address":"","comment_id":65751,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549618575","product_id":100020801,"comment_content":"老师好，文中说的不需要排序为什么不直接把orderby去掉而是写order by null","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438574,"discussion_content":"MySQL 语义上这么定义的… ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549637598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65659,"user_name":"HuaMax","can_delete":false,"product_type":"c1","uid":1118488,"ip_address":"","ucode":"2E78DE1AF098AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/11/18/8cee35f9.jpg","comment_is_top":false,"comment_ctime":1549545453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549545453","product_id":100020801,"comment_content":"课后题解答。图8是用内存临时表，文中已经提到，是按照表t1的索引a顺序取出数据，模10得0的id是最后一行；图9是用硬盘临时表，默认用innodb 的索引，主键是id%10，因此存入硬盘后再按主键树顺序取出，0就排到第一行了。","like_count":0}]}