{"id":135624,"title":"18 | 宏任务和微任务：不是所有任务都是一个待遇","content":"<p>在前面几篇文章中，我们介绍了消息队列，并结合消息队列介绍了两种典型的WebAPI——<strong>setTimeout</strong>和<strong>XMLHttpRequest</strong>，通过这两个WebAPI我们搞清楚了浏览器的消息循环系统是怎么工作的。不过随着浏览器的应用领域越来越广泛，消息队列中这种粗时间颗粒度的任务已经不能胜任部分领域的需求，所以又出现了一种新的技术——<strong>微任务</strong>。<strong>微任务可以在实时性和效率之间做一个有效的权衡</strong>。</p><p>从目前的情况来看，微任务已经被广泛地应用，基于微任务的技术有MutationObserver、Promise以及以Promise为基础开发出来的很多其他的技术。所以微任务的重要性也与日俱增，了解其底层的工作原理对于你读懂别人的代码，以及写出更高效、更具现代的代码有着决定性的作用。</p><p>有微任务，也就有宏任务，那这二者到底有什么区别？它们又是如何相互取长补短的？</p><h2>宏任务</h2><p>前面我们已经介绍过了，页面中的大部分任务都是在主线程上执行的，这些任务包括了：</p><ul>\n<li>渲染事件（如解析DOM、计算布局、绘制）；</li>\n<li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li>\n<li>JavaScript脚本执行事件；</li>\n<li>网络请求完成、文件读写完成事件。</li>\n</ul><p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为<strong>宏任务</strong>。</p><!-- [[[read_end]]] --><p>消息队列中的任务是通过事件循环系统来执行的，这里我们可以看看在<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model\">WHATWG规范</a>中是怎么定义事件循环机制的。</p><p>由于规范需要支持语义上的完备性，所以通常写得都会比较啰嗦，这里我就大致总结了下WHATWG规范定义的大致流程：</p><ul>\n<li>先从多个消息队列中选出一个最老的任务，这个任务称为oldestTask；</li>\n<li>然后循环系统记录任务开始执行的时间，并把这个oldestTask设置为当前正在执行的任务；</li>\n<li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个oldestTask；</li>\n<li>最后统计执行完成的时长等信息。</li>\n</ul><p>以上就是消息队列中宏任务的执行过程，通过前面的学习，相信你也很熟悉这套执行流程了。</p><p>宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了，下面我们就来分析下为什么宏任务难以满足对时间精度要求较高的任务。</p><p>前面我们说过，页面的渲染事件、各种IO的完成事件、执行JavaScript脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。为了直观理解，你可以看下面这段代码：</p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;div id='demo'&gt;\n            &lt;ol&gt;\n                &lt;li&gt;test&lt;/li&gt;\n            &lt;/ol&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n        function timerCallback2(){\n          console.log(2)\n        }\n        function timerCallback(){\n            console.log(1)\n            setTimeout(timerCallback2,0)\n        }\n        setTimeout(timerCallback,0)\n    &lt;/script&gt;\n&lt;/html&gt;\n</code></pre><p>在这段代码中，我的目的是想通过setTimeout来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务，因为如果这两个任务的中间插入了其他的任务，就很有可能会影响到第二个定时器的执行时间了。</p><p>但实际情况是我们不能控制的，比如在你调用setTimeout来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。你可以打开Performance工具，来记录下这段任务的执行过程，也可参考文中我记录的图片：</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/15/3c2b9b474c4df544df61ebd62a7b3715.png?wh=1142*351\" alt=\"\"></p><center><span class=\"reference\">Performance记录</span></center><p>setTimeout函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是setTimeout触发的两个定时器任务。</p><p>现在你可以重点观察上图中间浅红色区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。试想一下，如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。</p><p>所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听DOM变化的需求。</p><h2>微任务</h2><p>在理解了宏任务之后，下面我们就可以来看看什么是微任务了。在<a href=\"https://time.geekbang.org/column/article/135127\">上一篇文章</a>中，我们介绍过异步回调的概念，其主要有两种方式。</p><p><strong>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数</strong>。这种比较好理解，我们前面介绍的setTimeout和XMLHttpRequest的回调函数都是通过这种方式来实现的。</p><p><strong>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。</strong></p><p>那这里说的微任务到底是什么呢？</p><p><strong>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</strong></p><p>不过要搞清楚微任务系统是怎么运转起来的，就得站在V8引擎的层面来分析下。</p><p>我们知道当JavaScript执行一段脚本的时候，V8会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8引擎也会在内部创建一个<strong>微任务队列</strong>。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给V8引擎内部使用的，所以你是无法通过JavaScript直接访问的。</p><p>也就是说每个宏任务都关联了一个微任务队列。那么接下来，我们就需要分析两个重要的时间点——微任务产生的时机和执行微任务队列的时机。</p><p>我们先来看看微任务是怎么产生的？在现代浏览器里面，产生微任务有两种方式。</p><p>第一种方式是使用MutationObserver监控某个DOM节点，然后再通过JavaScript来修改这个节点，或者为这个节点添加、删除部分子节点，当DOM节点发生变化时，就会产生DOM变化记录的微任务。</p><p>第二种方式是使用Promise，当调用Promise.resolve()或者Promise.reject()的时候，也会产生微任务。</p><p>通过DOM节点变化产生的微任务或者使用Promise产生的微任务都会被JavaScript引擎按照顺序保存到微任务队列中。</p><p>好了，现在微任务队列中有了微任务了，那接下来就要看看微任务队列是何时被执行的。</p><p>通常情况下，在当前宏任务中的JavaScript快执行完成时，也就在JavaScript引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。<strong>WHATWG把执行微任务的时间点称为检查点</strong>。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点，不过不是太重要，这里就不做介绍了。</p><p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p><p>为了直观地理解什么是微任务，你可以参考下面我画的示意图（由于内容比较多，我将其分为了两张）：</p><p><img src=\"https://static001.geekbang.org/resource/image/83/88/839f468be3d683019c309e0acd8cd788.png?wh=1142*466\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/1d/92/1db319c879610816c0cfea22723fc492.png?wh=1142*476\" alt=\"\"></p><center><span class=\"reference\">微任务添加和执行流程示意图</span></center><p>该示意图是在执行一个ParseHTML的宏任务，在执行过程中，遇到了JavaScript脚本，那么就暂停解析流程，进入到JavaScript的执行环境。从图中可以看到，全局上下文中包含了微任务列表。</p><p>在JavaScript脚本的后续执行过程中，分别通过Promise和removeChild创建了两个微任务，并被添加到微任务列表中。接着JavaScript执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。</p><p>以上就是微任务的工作流程，从上面分析我们可以得出如下几个<strong>结论</strong>：</p><ul>\n<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>\n<li>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了100个微任务，执行每个微任务的时间是10毫秒，那么执行这100个微任务的时间就是1000毫秒，也可以说这100个微任务让宏任务的执行时间延长了1000毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。</li>\n<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>\n</ul><h2>监听DOM变化方法演变</h2><p>现在知道了微任务是怎么工作的，那接下来我们再来看看微任务是如何应用在MutationObserver中的。MutationObserver是用来监听DOM变化的一套方法，而监听DOM变化一直是前端工程师一项非常核心的需求。</p><p>比如许多Web应用都利用HTML 与 JavaScript 构建其自定义控件，与一些内置控件不同，这些控件不是固有的。为了与内置控件一起良好地工作，这些控件必须能够适应内容更改、响应事件和用户交互。因此，Web应用需要<strong>监视 DOM 变化并及时地做出响应</strong>。</p><p>虽然监听DOM的需求是如此重要，不过早期页面并没有提供对监听的支持，所以那时要观察DOM是否变化，唯一能做的就是轮询检测，比如使用setTimeout或者setInterval来定时检测DOM是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查DOM，会让页面变得低效。</p><p>直到2000年的时候引入了Mutation Event，Mutation Event采用了<strong>观察者的设计模式</strong>，当DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。</p><p>采用Mutation Event解决了实时性的问题，因为DOM一旦发生变化，就会立即调用JavaScript接口。但也正是这种实时性造成了严重的性能问题，因为每次DOM变动，渲染引擎都会去调用JavaScript，这样会产生较大的性能开销。比如利用JavaScript动态创建或动态修改50个节点内容，就会触发50次回调，而且每个回调函数都需要一定的执行时间，这里我们假设每次回调的执行时间是4毫秒，那么50次回调的执行时间就是200毫秒，若此时浏览器正在执行一个动画效果，由于Mutation Event触发回调事件，就会导致动画的卡顿。</p><p>也正是因为使用Mutation Event会导致页面性能问题，所以Mutation Event被反对使用，并逐步从Web标准事件中删除了。</p><p>为了解决了Mutation Event由于同步调用JavaScript而造成的性能问题，从DOM4开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。</p><p>那么相比较 Mutation Event，MutationObserver 到底做了哪些改进呢？</p><p>首先，MutationObserver将响应函数改成异步调用，可以不用在每次DOM变化都触发异步调用，而是等多次DOM变化后，<strong>一次触发异步调用</strong>，并且还会使用一个数据结构来记录这期间所有的DOM变化。这样即使频繁地操纵DOM，也不会对性能造成太大的影响。</p><p>我们通过异步调用和减少触发次数来缓解了性能问题，那么如何保持消息通知的及时性呢？如果采用setTimeout创建宏任务来触发回调的话，那么实时性就会大打折扣，因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。</p><p>这时候，<strong>微任务</strong>就可以上场了，在每次DOM节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8引擎就会按照顺序执行微任务了。</p><p>综上所述， MutationObserver采用了“<strong>异步+微任务</strong>”的策略。</p><ul>\n<li>通过<strong>异步</strong>操作解决了同步操作的<strong>性能问题</strong>；</li>\n<li>通过<strong>微任务</strong>解决了<strong>实时性的问题</strong>。</li>\n</ul><h2>总结</h2><p>好了，今天就介绍到这里，下面我来总结下今天的内容。</p><p>首先我们回顾了宏任务，然后在宏任务的基础之上，我们分析了异步回调函数的两种形式，其中最后一种回调的方式就是通过微任务来实现的。</p><p>接下来我们详细分析了浏览器是如何实现微任务的，包括微任务队列、检查点等概念。</p><p>最后我们介绍了监听DOM变化技术方案的演化史，从轮询到Mutation Event再到最新使用的MutationObserver。MutationObserver方案的核心就是采用了微任务机制，有效地权衡了实时性和执行效率的问题。</p><h2>思考时间</h2><p>下篇文章我会从Promise产生的动机角度来分析Promise，这需要一定的Promise基础，所以今天留给你的作业是搞清楚Promise的工作原理，弄清楚下面这段代码的输出结果，并解释其原因。</p><pre><code>function executor(resolve, reject) {\n    let rand = Math.random();\n    console.log(1)\n    console.log(rand)\n    if (rand &gt; 0.5)\n        resolve()\n    else\n        reject()\n}\nvar p0 = new Promise(executor);\n\nvar p1 = p0.then((value) =&gt; {\n    console.log(&quot;succeed-1&quot;)\n    return new Promise(executor)\n})\n\n\nvar p3 = p1.then((value) =&gt; {\n    console.log(&quot;succeed-2&quot;)\n    return new Promise(executor)\n})\n\nvar p4 = p3.then((value) =&gt; {\n    console.log(&quot;succeed-3&quot;)\n    return new Promise(executor)\n})\n\n\np4.catch((error) =&gt; {\n    console.log(&quot;error&quot;)\n})\nconsole.log(2)\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"17 | WebAPI：XMLHttpRequest是怎么实现的？","id":135127},"right":{"article_title":"19 | Promise：使用Promise，告别回调函数","id":136895}},"comments":[{"had_liked":false,"id":134031,"user_name":"阿桐","can_delete":false,"product_type":"c1","uid":1160167,"ip_address":"","ucode":"E82211BD6E9E89","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/e7/227ee616.jpg","comment_is_top":false,"comment_ctime":1568724162,"is_pvip":false,"replies":[{"id":"51448","content":"<br><br>非常高兴你能提出这些问题。<br><br>你有这两个疑问很正常，说明你看得很仔细，之所以你会感到疑惑，主要是我在写作过程中偷懒了。<br><br>我先来解答你的第一个问题：<br>第一段话是WHATWG标准定义的，在WHATWG规范，定义了在主线程的循环系统中，可以有多个消息队列，比如鼠标事件的队列，IO完成消息队列，渲染任务队列，并且可以给这些消息队列排优先级。<br><br>但是在浏览器实现的过程中，目前只有一个消息队列，和一个延迟执行队列。<br>一个是规范，一个是实现，主要我没有在文中强调这点，所以你会产生的这样的疑问。<br><br>关于第二个问题解释起来就比较复杂了，涉及到来了V8是怎么执行的了，专栏中的&quot;全局执行上下文&quot;我没有深入分析。所以我偷懒了，把两个稍微有点不同的概念都称为了“全局执行上下文”，要解释清楚这个问题还要牵涉到V8的一个底层逻辑，既然你提出来了，那我就打算在课程结束后，通过加餐的形式来开一讲，讲清楚了这个还能额外地理解 Realm 概念。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568774604,"ip_address":"","comment_id":134031,"utype":1}],"discussion_count":10,"race_medal":0,"score":"542734603458","product_id":100033601,"comment_content":"买过不少专栏，每一篇都紧跟并且会反复看的目前只有这一个。一方面懒另一方面是好的系统性的学习资料不多，所以以前很少关注偏底层原理性的东西，所以这个专栏学习起来是既收获满满有时也不乏一额头问号。<br><br>这里有 2 个问题想向老师请教，希望老师百忙之中能抽空解答一下，多谢多谢。<br><br>1、之前讲过，在循环系统的一个循环中，先从消息队列头部取出一个任务执行，该任务执行完后，再去延迟队列中找到所有的过期任务依次执行完。那前面这句话和本篇文章的这句话好像有矛盾：&quot;先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask&quot;<br><br>2、”通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。“<br>在页面生存周期内，全局执行上下文只有一份并且会一直存在调用栈中，只有当页面被关闭的时候全局执行上下文才会消失。页面都快关闭了，把全局执行上下文中的微任务队列中的任务都执行一遍，好像也没啥意义。系统应该不会做没有意义的事情，所以应该是我对全局执行上下文的某处理解有问题，但我又自查不到。","like_count":126,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467590,"discussion_content":"\n\n非常高兴你能提出这些问题。\n\n你有这两个疑问很正常，说明你看得很仔细，之所以你会感到疑惑，主要是我在写作过程中偷懒了。\n\n我先来解答你的第一个问题：\n第一段话是WHATWG标准定义的，在WHATWG规范，定义了在主线程的循环系统中，可以有多个消息队列，比如鼠标事件的队列，IO完成消息队列，渲染任务队列，并且可以给这些消息队列排优先级。\n\n但是在浏览器实现的过程中，目前只有一个消息队列，和一个延迟执行队列。\n一个是规范，一个是实现，主要我没有在文中强调这点，所以你会产生的这样的疑问。\n\n关于第二个问题解释起来就比较复杂了，涉及到来了V8是怎么执行的了，专栏中的&amp;quot;全局执行上下文&amp;quot;我没有深入分析。所以我偷懒了，把两个稍微有点不同的概念都称为了“全局执行上下文”，要解释清楚这个问题还要牵涉到V8的一个底层逻辑，既然你提出来了，那我就打算在课程结束后，通过加餐的形式来开一讲，讲清楚了这个还能额外地理解 Realm 概念。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568774604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1782777,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/33/f9/50b76abe.jpg","nickname":"AMIR","note":"","ucode":"65142D9669071B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98729,"discussion_content":"第一个问题，延时队列如果存在，那么为什么两个setTimeOut中被加入那么多其他任务，不应该是最多执行一个，然后判断延时队列是否有到期de，然后就执行嘛？怎么会添加到尾巴上","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577183715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1440735,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fb/df/8615f2d3.jpg","nickname":"kaiking","note":"","ucode":"DBE91C5855B9FD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379540,"discussion_content":"这问题问的，我连题目都看不明白😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623945182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1365541,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d6/25/a95a2064.jpg","nickname":"luwei","note":"","ucode":"0960A09F7B8D59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287358,"discussion_content":"为什么说“微任务执行时机是当前宏任务结束之前。”？好多资料说当前宏任务执行完之后，马上去清空微任务队列。到底微任务执行时机是在什么时候？在课程加餐里没找到这方面的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593423671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2273206,"avatar":"https://static001.geekbang.org/account/avatar/00/22/af/b6/e5de8ee4.jpg","nickname":"张建辉","note":"","ucode":"C52626DF995726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1365541,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d6/25/a95a2064.jpg","nickname":"luwei","note":"","ucode":"0960A09F7B8D59","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383897,"discussion_content":"微任务执行时机是在当前宏任务执行完之后，会延长宏任务的执行时间的，可以手写下代码，然后用 Performance 查看下就懂了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1626275364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287358,"ip_address":""},"score":383897,"extra":""}]},{"author":{"id":1376627,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/73/a3bbaab9.jpg","nickname":"Aiden","note":"","ucode":"3B0FA384541943","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235155,"discussion_content":"还是没搞懂这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587024584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221907,"discussion_content":"谢谢你帮我提问😜ོ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586078851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/81/d3/f0a88806.jpg","nickname":"🍐 🍾 🔆","note":"","ucode":"1B7C90800AD4D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65486,"discussion_content":"第二个我看的时候也没懂 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575005722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1230187,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c5/6b/e9d0d04a.jpg","nickname":"卡卡西","note":"","ucode":"D42A3395B13D6C","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25110,"discussion_content":"第二个问题也是我的疑惑点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570422473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1473520,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7b/f0/269139d5.jpg","nickname":"Cris","note":"","ucode":"F8A287134F1078","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24604,"discussion_content":"是系统调用栈吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570194335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133201,"user_name":"man-moonth","can_delete":false,"product_type":"c1","uid":1383156,"ip_address":"","ucode":"145EED9CFA19E4","user_header":"https://static001.geekbang.org/account/avatar/00/15/1a/f4/a40453e7.jpg","comment_is_top":false,"comment_ctime":1568442119,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"48813082375","product_id":100033601,"comment_content":"错误和缺失之处烦请老师指正：<br>1. 执行`p0 = new Promise(executor)`，立即调用`executor()`。依次打印`1`和`rand`，根据`rand &gt; 0.5`判断执行`resolve()`还是`reject()`，分别决定了p0的状态为fufilled（成功）还是rejected(失败)。<br>2. 继续往下执行`p1 = p0.then()`、`p3 = p1.then()`、`p4 = p3.then()`、`p4.catch()`，`p0.then()`、`p1.then()`、`p3.then()`、`p4.catch()`等依次推入微任务队列，p1、p3、p4的状态变为pending(初始状态)。此处p4添加了`catch()`方法，若p4也有`then()`方法，那么推入队列的就是`p4.then().catch()`。<br>3. 执行`console.log(2)`。宏任务执行完毕。<br>4. 从微任务队列中取出`p0.then()`。如果p0的状态为fufilled，那么执行`p0.then()`：打印`succeed-1`，然后执行`new Promise(executor)`，完毕后p1的状态转为fufilled&#47;rejected；如果p0的状态为rejected，则不执行`p0.then()`，p1的状态置为rejected。<br>5. 继续从微任务队列取出`p1.then()`、`p3.then()`，他们的处理方式与第3步同理。<br>6. 取出`p4.catch()`，如果p4的状态为rejected，那么执行`p4.catch()`，否则啥也不做。结束。","like_count":10,"discussions":[{"author":{"id":1938247,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/93/47/ef2c3c4e.jpg","nickname":"何江涛","note":"","ucode":"844470733623BF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574922,"discussion_content":"我记得rejected可以传递，也就是说p0p1p3任何一个拒绝，都会执行catch","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654437640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2172330,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKw8ictgYcqf6upCGib0uBXa6oeWfVJARSLL1SFXtrz3TkJiavPicesLEoBg9RL7ibRYKTtZDexsrJPjJA/132","nickname":"victorykong","note":"","ucode":"76C1BE240D53F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351754,"discussion_content":"赞，与 Promise A+ 实现是一致的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614426366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256496,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","nickname":"pyhhou","note":"","ucode":"31EF8D50CF91A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13464,"discussion_content":"赞，请教一下，第 2 步中，如果 p4 有 `then()` 方法，为什么推入队列的是 `p4.then().catch()` ? 不应该是 `p4.then()` 和 `p4.catch()` 吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568660714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141661,"user_name":"splm","can_delete":false,"product_type":"c1","uid":1338601,"ip_address":"","ucode":"2216332252CEA7","user_header":"https://static001.geekbang.org/account/avatar/00/14/6c/e9/072b33b9.jpg","comment_is_top":false,"comment_ctime":1571209027,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"35930947395","product_id":100033601,"comment_content":"前面的课程举过说过，正常任务会被放在消息队列中，延时任务会放在延时消息队列中，还举过一段代码，任务循环会不断的从消息队列中取任务，并执行，也会不断的判断延时任务是否到期需要执行。但在这节课里面却说延迟任务会追加到消息队列末尾，听说去就像普通任务和延迟任务都在一起，只是延迟任务被追加到末尾。究竟有几个消息队列，普通和延迟队列是真实存在还是只是概念区分，实际两种任务都保存在一块。","like_count":8,"discussions":[{"author":{"id":1352917,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a4/d5/d1381d9b.jpg","nickname":"咚咚咚东","note":"","ucode":"BAAF965577592B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336554,"discussion_content":"可以看上一条评论的作者回复，实现上是有两个队列，一个普通队列，一个延迟执行队列。本文写的追加到消息队列尾部是指，普通任务追加到普通队列尾部，延时任务追加到延时队列的尾部。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1608623756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1352917,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a4/d5/d1381d9b.jpg","nickname":"咚咚咚东","note":"","ucode":"BAAF965577592B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336552,"discussion_content":"可以看上一条评论的作者回复，实现上是有两个队列，一个普通队列，一个延迟执行队列。本文写的追加到消息队列尾部是指，普通任务追加到普通队列尾部，延时任务追加到延时队列的尾部。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608623700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1651132,"avatar":"https://static001.geekbang.org/account/avatar/00/19/31/bc/4e679d81.jpg","nickname":"杨越","note":"","ucode":"88B933F2096E11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306411,"discussion_content":"卧槽 说到我心坎里去了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600264614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2054146,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/58/02/d07b3c76.jpg","nickname":"hoverCow🍎🍰","note":"","ucode":"079E10A6B6FA3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290879,"discussion_content":"我也有同样的疑惑呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594632392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133889,"user_name":"花儿与少年","can_delete":false,"product_type":"c1","uid":1046304,"ip_address":"","ucode":"E2D685737E4F1B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/20/e2dfa9c2.jpg","comment_is_top":false,"comment_ctime":1568691159,"is_pvip":false,"replies":[{"id":"51510","content":"要理解这个就得讲观察者模式了，不过展开又是一篇文章，我到时候加餐的时候再来结合观察者模式来讲这个。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568810062,"ip_address":"","comment_id":133889,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31633462231","product_id":100033601,"comment_content":"提问: Mutation Event的回调 是同步的吗？如果是同步的，引擎是怎么做到的？<br>同步代码执行的时候，还能插入其他代码(mutation 回调)？","like_count":7,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467546,"discussion_content":"要理解这个就得讲观察者模式了，不过展开又是一篇文章，我到时候加餐的时候再来结合观察者模式来讲这个。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568810062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046304,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f7/20/e2dfa9c2.jpg","nickname":"花儿与少年","note":"","ucode":"E2D685737E4F1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15330,"discussion_content":"好的，观察者模式懂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568816077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133401,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1568552758,"is_pvip":true,"discussion_count":2,"race_medal":1,"score":"27338356534","product_id":100033601,"comment_content":"老师，我看文章的图展示，微任务队列只存在全局执行上下文中吗？ 如果一个微任务是在一个函数执行上下文中产生了，也会保存到全局执行上下文中的微队列中吗？","like_count":6,"discussions":[{"author":{"id":2448960,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/40/dee7906c.jpg","nickname":"张欣","note":"","ucode":"557C42848C77E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355586,"discussion_content":"微任务应该是添加在当前宏任务末尾的队列中，在遇到js的时候执行js就构建了一个宏任务。这个宏任务中所有产生的微任务异步回调都会添加到当前宏任务末尾微任务队列中，我觉得老师这边说的应该是简化了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615456089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/yicibWmBIDaSpBYI5wCBDQcYu6mxjvz3XZzBibxSNXFfqCS6OJOjvy2Nc2lyDicZfmneW9ZY4KbicA1sNgLktVSicgkw/132","nickname":"老余","note":"","ucode":"17AC6C60D0EB86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14815,"discussion_content":"当然啦。函数执行上下文的outer最终一定会指向全局上下文，在即将退出全局上下文的时候去执行微任务队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568781796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133157,"user_name":"ytd","can_delete":false,"product_type":"c1","uid":1038790,"ip_address":"","ucode":"C6AEA2D19E447A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d9/c6/8be8664d.jpg","comment_is_top":false,"comment_ctime":1568423050,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27338226826","product_id":100033601,"comment_content":"执行过程：<br>  从第10行开始：<br>  1，创建promise赋值，打印1 rand<br>  2，执行log语句，打印2<br>  3，如果rand &gt; 0.5，promise被resolve，打印success，并返回新的promse赋值<br>    然后重复类似步骤1、3、4<br>  4，否则如果rand &lt;= 0.5 promise reject，然后p1、p2、p3、p4都分别被赋值为一个新的被reject的promise，最后在p4.catch中reject状态被捕获，打印error","like_count":5,"discussions":[{"author":{"id":1499244,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e0/6c/ef405cc1.jpg","nickname":"关山楂","note":"","ucode":"C32E201FA33045","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":90327,"discussion_content":"什么算是一个任务？console.log(2)也算是和new promise中的参数执行都是宏任务吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576768695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237487,"user_name":"Jankin","can_delete":false,"product_type":"c1","uid":2067161,"ip_address":"","ucode":"16084255D43B2C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/o4jsp3yKTVthd1XfEA0ib1mXYFDULB2uUskUbLrtLbxy0AJFtuJqHAKjDSuDwiciazSAfE6fy2OfffLU8ayXmrWkg/132","comment_is_top":false,"comment_ctime":1595843848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23070680328","product_id":100033601,"comment_content":"。。。老师，记录学习的话，写博客可以引用您的话之类的吗。。会注明作者和链接的","like_count":5},{"had_liked":false,"id":222742,"user_name":"Matt","can_delete":false,"product_type":"c1","uid":2013524,"ip_address":"","ucode":"B144E65D1BD286","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b9/54/5c6fe2b0.jpg","comment_is_top":false,"comment_ctime":1590903400,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18770772584","product_id":100033601,"comment_content":"我是这样理解的，setTimeout代码被执行后，延迟队列中会添加一个延迟任务。当一个宏任务被执行完后，渲染主线程会去检查延迟队列中是否有到达触发时间的延迟任务，如果有，则将其从延迟任务队列中清除，并在宏任务队列中添加一个待执行的任务（setTimeout的回调函数）。所以两个setTimout任务中间才有可能插入其他的系统任务。","like_count":4,"discussions":[{"author":{"id":2129924,"avatar":"","nickname":"Geek_88f3f7","note":"","ucode":"957899A12C0DD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303305,"discussion_content":"setTimeout不是在宏任务队列中添加回调，是在调用栈里添加回调函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599209843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205121,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1586533796,"is_pvip":false,"replies":[{"id":"76677","content":"不会，因为没有出发js，这个微任务是v8触发的","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1586569680,"ip_address":"","comment_id":205121,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14471435684","product_id":100033601,"comment_content":"老师，通过控制面板中修改的样式是不是不会触发MutationObserver？","like_count":3,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491395,"discussion_content":"不会，因为没有出发js，这个微任务是v8触发的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586569680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164366,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1059952,"ip_address":"","ucode":"F70511D614B9F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/70/02b627a6.jpg","comment_is_top":false,"comment_ctime":1576946423,"is_pvip":false,"replies":[{"id":"62447","content":"setTimeout因为是定时任务，设定的时间间隔没有到是不会执行，由此需要一个单独的模块来保存定时器的消息，你可以通过该模块取出到期的任务，我们把这个模块叫延时队列，Chrome内部用了个hashmap保存数据，然后又写了取出到期的任务的策略！<br><br>通常情况下，是当渲染主线程在执行完一个正常的任务之后，再判断该模块中是否有到期的任务，如果有取出来执行！","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1576977184,"ip_address":"","comment_id":164366,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14461848311","product_id":100033601,"comment_content":"对于文中一处有疑虑：<br><br>“第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。”<br><br>第16讲提到了，setTimeout里的延迟任务，是存在一个延迟队列中的。我看精选留言部分老师的回答，提到这个延迟队列实际上是一个hashmap，那么setTimeout的实现还是加到队尾，等到前面的都出队，才执行到这个任务的吗？","like_count":3,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478735,"discussion_content":"setTimeout因为是定时任务，设定的时间间隔没有到是不会执行，由此需要一个单独的模块来保存定时器的消息，你可以通过该模块取出到期的任务，我们把这个模块叫延时队列，Chrome内部用了个hashmap保存数据，然后又写了取出到期的任务的策略！\n\n通常情况下，是当渲染主线程在执行完一个正常的任务之后，再判断该模块中是否有到期的任务，如果有取出来执行！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576977184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1373793,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f6/61/96fe5e93.jpg","nickname":"天白","note":"","ucode":"6F432CB06E7EFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202777,"discussion_content":"我认为延时队列是一个新的宏任务，主线程的事件循环是执行完一个宏任务之后去执行延迟队列中的任务（参加setTimeout那一篇文章中老师的实现），而微任务是在宏任务执行完之前检查执行的，因此判断延时队列中到期的任务是在微任务执行之后","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583942388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1059952,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2c/70/02b627a6.jpg","nickname":"coder","note":"","ucode":"F70511D614B9F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94815,"discussion_content":"所以判断这个模块是否有到期的任务的时机，是在微任务队列执行之前还是之后？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576991675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141895,"user_name":"locke","can_delete":false,"product_type":"c1","uid":1598828,"ip_address":"","ucode":"DD0554D06C7937","user_header":"https://static001.geekbang.org/account/avatar/00/18/65/6c/5cb98fc3.jpg","comment_is_top":false,"comment_ctime":1571246757,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10161181349","product_id":100033601,"comment_content":"文中“第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部”，setTimeout－－不是添加到消息队列尾部吧，不应该延迟队列吗？","like_count":2,"discussions":[{"author":{"id":1059952,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2c/70/02b627a6.jpg","nickname":"coder","note":"","ucode":"F70511D614B9F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79198,"discussion_content":"有同样的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576067039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141373,"user_name":"Andy Jiang","can_delete":false,"product_type":"c1","uid":1227279,"ip_address":"","ucode":"436609A0A445CF","user_header":"https://static001.geekbang.org/account/avatar/00/12/ba/0f/9789c2cc.jpg","comment_is_top":false,"comment_ctime":1571145908,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10161080500","product_id":100033601,"comment_content":"之前讲过，在循环系统的一个循环中，先从消息队列头部取出一个任务执行，该任务执行完后，再去延迟队列中找到所有的过期任务依次执行完。消息队列头部取出的任务执行完毕后，会先检查微任务队列么？检查微任务队列，然后再去延迟队列中找过期任务执行？","like_count":2,"discussions":[{"author":{"id":1782777,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/33/f9/50b76abe.jpg","nickname":"AMIR","note":"","ucode":"65142D9669071B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98763,"discussion_content":"我也有疑问，两个SetTimeOut之间怎么那么多消息任务，除非那些任务都在4ms中执行完了，要不然应该执行完一个任务，就从延迟队列中取出这个任务，进行执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577185650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225166,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1591671674,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5886638970","product_id":100033601,"comment_content":"1. 执行上下文栈（调用栈）: 全局执行上下文+函数执行上下文（executor）<br>2. new Promise中接收的参数是一个立即执行函数，属于同步任务，因此会立即执行，打印出1和随机数，如果随机数&gt;0.5，则让这个Promise变为成功态(fulfilled), 否则变为失败态(rejected),执行完成后，再依次执行下面的代码，js引擎扫描到p1、p3、p4以及p4.catch四个方法，这些都是基于前一个Promise做的状态来执行的，会产生微任务，因此会被推入到当前宏任务的微任务队列中，最后面是一句同步代码：console.log(2)，会立即执行打印2，到这里，当前宏任务的所有同步代码全部执行完，JavaScript 引擎就会检查微任务列表，发现微任务列表中有微任务(4个Promise微任务待执行)，那么接下来，依次执行这四个微任务。等微任务队列清空之后，就退出全局执行上下文。","like_count":1},{"had_liked":false,"id":218241,"user_name":"王妍","can_delete":false,"product_type":"c1","uid":1019641,"ip_address":"","ucode":"D4CCE6C7F7F1C5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/f9/8221aac3.jpg","comment_is_top":false,"comment_ctime":1589764281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884731577","product_id":100033601,"comment_content":"首先执行同步代码，<br>promise的构造函数是同步执行的，所以先执行executor。<br>打印1，<br>打印rand，<br>之后看生成的随机数是不是大于0.5。<br>这里假设每一次都大于0.5.<br>因为大于0.5，将p0的then回调加入到微任务队列中。<br>然后同步执行到console.log(2),<br>打印2<br>这是宏任务执行结束，开始执行微任务队列的内容。<br>打印“succeed-1”<br>然后同步执行executor。<br>打印1<br>打印rand<br>然后因为大于0.5，将p1的then回调加入到微任务队列中。<br>这是一个微任务执行完成，接下来执行刚刚加入的微任务。<br>打印&quot;succeed-2&quot;<br>然后同步执行executor<br>打印1<br>打印rand<br>。。。<br>如果过程中某一步产生的随机数小于0.5，则将error回调加入微任务，打印error。中止。<br>","like_count":1},{"had_liked":false,"id":162835,"user_name":"夏了夏天","can_delete":false,"product_type":"c1","uid":1235375,"ip_address":"","ucode":"F63F1CA10BF8CE","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/af/747c4d8b.jpg","comment_is_top":false,"comment_ctime":1576599939,"is_pvip":false,"replies":[{"id":"61886","content":"js只不是任务的一个过程，这里讲的都是C++层面的，所以也可以说是系统调用栈。 <br><br>具体的你可以看看加餐5","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1576626074,"ip_address":"","comment_id":162835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871567235","product_id":100033601,"comment_content":"老师，我有个疑惑，主线程读取消息队列里的任务的时机是「系统调用栈」的任务执行完毕时还是「JS的调用栈」执行完毕时？","like_count":1,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478159,"discussion_content":"js只不是任务的一个过程，这里讲的都是C++层面的，所以也可以说是系统调用栈。 \n\n具体的你可以看看加餐5","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576626074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141692,"user_name":"splm","can_delete":false,"product_type":"c1","uid":1338601,"ip_address":"","ucode":"2216332252CEA7","user_header":"https://static001.geekbang.org/account/avatar/00/14/6c/e9/072b33b9.jpg","comment_is_top":false,"comment_ctime":1571211592,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5866178888","product_id":100033601,"comment_content":"延迟任务队列是真实存在的还是只是一个定义，实际上就是追加普通宏任务队列后面或者被添加到微任务中的任务集？","like_count":1,"discussions":[{"author":{"id":1305087,"avatar":"","nickname":"randy","note":"","ucode":"4D9E37745E6111","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":89116,"discussion_content":"之前的文章有贴 chrome 的源码，可以看看，里面真的定义了一个延迟队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576750984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140887,"user_name":"任振鹏","can_delete":false,"product_type":"c1","uid":1385329,"ip_address":"","ucode":"D33DC7856947D6","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/71/57c16ecb.jpg","comment_is_top":false,"comment_ctime":1571067256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866034552","product_id":100033601,"comment_content":"调用栈：全局执行上下文 -&gt; executor函数执行上下文<br>先执行宏任务队列： <br>  先打印1， rand，返回一个promiss，executor函数执行上下文出栈，执行全局上下文的微任务队列加入pomiss在打印2<br>然后执行微任务队列：遇到reject 打印error 结束， 否则：打印succeed-1，然后executor函数执行上下文进栈，继续上面步骤。直至reject结束<br>不知道上面的分析对不对， 希望老师解答下。","like_count":1},{"had_liked":false,"id":136253,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1569397101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5864364397","product_id":100033601,"comment_content":"迟到交作业：<br>思考题的结果大致如下<br><br>1<br>rand<br>2<br>——————-分割线————————-<br>从这里开始主函数结束， 微任务队列里有一个reject或者resolve<br>如果是reject：<br>输出 error，由于微任务队列已空， 退出当前宏任务<br>如果是resolve：<br>执行then里的回掉函数<br>输出 succeed-1<br>并再一次创建一个promise， 当执行executor的时候会再一次往微任务队列里添加任务. <br><br>循环♻️<br>","like_count":1},{"had_liked":false,"id":134511,"user_name":"小智","can_delete":false,"product_type":"c1","uid":1046777,"ip_address":"","ucode":"C7940D9880CD06","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo3yW0arVaSoQiccftUPYo0LZqRHicMEbqjoBVkEVNw405S7OL5dlFDqVibdyudpPaVQkbxwcywJ1bNg/132","comment_is_top":false,"comment_ctime":1568856972,"is_pvip":false,"replies":[{"id":"51555","content":"嗯。后面有疑问正常，理论偏多，而且篇幅之间的依赖性比较强。可以把你的问题列出来，答疑的时候我会结合实际列子来分析。","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568857599,"ip_address":"","comment_id":134511,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5863824268","product_id":100033601,"comment_content":"反复读了几次，还是有很多疑问，不同于最初的几篇文章，这里的理论偏多，希望能有更多的案例结合理论分析，才能进一步验证心中理解的","like_count":1,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467780,"discussion_content":"嗯。后面有疑问正常，理论偏多，而且篇幅之间的依赖性比较强。可以把你的问题列出来，答疑的时候我会结合实际列子来分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568857599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046777,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo3yW0arVaSoQiccftUPYo0LZqRHicMEbqjoBVkEVNw405S7OL5dlFDqVibdyudpPaVQkbxwcywJ1bNg/132","nickname":"小智","note":"","ucode":"C7940D9880CD06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17059,"discussion_content":"感谢老师百忙之中解答\n原文提到，V8内部创建了一个微任务队列，每个宏任务关联了一个微任务队列。\n\n//有如下代码\nconst foo = () => (new Promise((resolve, reject) => {\n    console.log(&#39;first promise constructor&#39;)\n\n    let promise1 = new Promise((resolve, reject) => {\n        console.log(&#39;second promise constructor&#39;)\n\n        setTimeout(() => {\n            console.log(&#39;setTimeout here&#39;)\n            resolve()\n        }, 0)\n\n        resolve(&#39;promise1&#39;)\n    })\n\n    resolve(&#39;promise0&#39;)\n\n    promise1.then(arg => {\n        console.log(arg)\n    })\n}))\n\nfoo().then(arg => {\n    console.log(arg)\n})\n\n我的理解是这样，先执行同步代码，可以得出先输出 ‘first promise constructor’ 和 ‘second promise constructor’ 。然后，setTimeout回调函数进入宏任务队列，promise1.then 和 foo.then 内容，分别先后进入微任务队列。所以得出 promise1 promise0 先后输出，最后再输出 setTimeout here。判断依据是 微任务优先于宏任务。\nQ1:如果用这部分的知识详细分析这段代码，这里面的微任务和宏任务，应该是谁关联谁？宏任务关联微任务有什么样的具体案例？\nQ2:原文提到当前宏任务中的 JavaScript 快执行完成时，会去检查微任务列表，‘快执行完成’这个词感觉很困惑，一段代码如果执行过，对应的结果已经生成，为什么有快完成这种说法？ 如果一个宏任务包含微任务，是先得到微任务的结果还是宏任务的结果？如果是2个宏任务，各自包含一个微任务，应该是怎样的执行顺序。有实际的案例吗。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568944805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133691,"user_name":"liu_xm","can_delete":false,"product_type":"c1","uid":1059215,"ip_address":"","ucode":"AD252F31D5C122","user_header":"https://static001.geekbang.org/account/avatar/00/10/29/8f/a07b72bc.jpg","comment_is_top":false,"comment_ctime":1568637861,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5863605157","product_id":100033601,"comment_content":"您好，有些疑问。<br>1.微任务是在v8引擎中添加的，是不是在ie和firefox中都不存在呢？<br>2.再说dom变化多次后再出发muation observer。这个多次是如何定义和谁来控制的呀？","like_count":1,"discussions":[{"author":{"id":1046304,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f7/20/e2dfa9c2.jpg","nickname":"花儿与少年","note":"","ucode":"E2D685737E4F1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13623,"discussion_content":"问题1 不同的浏览器内置js引擎不一样，这些引擎有自己的实现，他们会按照规范实现js特性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568691274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359071,"user_name":"开开之之","can_delete":false,"product_type":"c1","uid":1152069,"ip_address":"广东","ucode":"2B7FC13D6F32C4","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/45/7ea3dd47.jpg","comment_is_top":false,"comment_ctime":1665220833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665220833","product_id":100033601,"comment_content":"思考题交作业：<br>首先，初始化promise的时候，会执行executor。<br>然后要搞清楚什么是主函数。<br>var p0 = new Promise(executor);<br>console.log(2)<br>这里是主函数，会先执行executor里面的console.log，然后根据结果把then或者catch的回调函数放入微任务队列中，然后执行console.log(2)<br>在主函数执行完后，开始执行微任务队列。那么，假设var p0 = new Promise(executor);中executor的结果是大于0.5, 那么会把p0.then回调函数放入放入微任务队列中。<br>执行p0.then的时候，同样是 new Promise(executor);：执行console.log(1), rand(), 假设这个时候结果小于0.5，就会把catch回调函数放入微任务队列中。<br>执行catch回调。结束。<br>也就是先执行完主函数 =&gt; 执行resolve&#47;reject对应的回调 =&gt; 如果是resolve, resolve对应的函数会新建微任务放入队列，有点递归的意思，执行完，放入队列，继续执行队列中的新任务， =&gt; 如果是reject，那就执行完catch对应的回调就结束。 <br><br>","like_count":0},{"had_liked":false,"id":358593,"user_name":"wilson","can_delete":false,"product_type":"c1","uid":1286793,"ip_address":"上海","ucode":"55CFA9D4AA9A19","user_header":"https://static001.geekbang.org/account/avatar/00/13/a2/89/7098b532.jpg","comment_is_top":false,"comment_ctime":1664447433,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1664447433","product_id":100033601,"comment_content":"微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。<br><br>老师，这句话里的主函数是什么呀？","like_count":0},{"had_liked":false,"id":356712,"user_name":"有一种踏实","can_delete":false,"product_type":"c1","uid":2634945,"ip_address":"上海","ucode":"CF9A6273741105","user_header":"https://static001.geekbang.org/account/avatar/00/28/34/c1/4e4917f5.jpg","comment_is_top":false,"comment_ctime":1662524159,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1662524159","product_id":100033601,"comment_content":"如何解释 Parse HTML、Paint 之类的宏任务？这个过程有涉及到 JS 调用栈吗？","like_count":0},{"had_liked":false,"id":352693,"user_name":"Geek_183f9e","can_delete":false,"product_type":"c1","uid":1576826,"ip_address":"","ucode":"70405BB513AA9E","user_header":"https://static001.geekbang.org/account/avatar/00/18/0f/7a/420b41cd.jpg","comment_is_top":false,"comment_ctime":1658885801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658885801","product_id":100033601,"comment_content":"文中指出：第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。<br><br>就我目前的认知，Promise和async&#47;await会产生微任务，具体来说就是，<br>Promise的then回调函数放入微任务消息队列，<br>async&#47;await的await下面的任务放入微任务消息队列。<br>","like_count":0},{"had_liked":false,"id":347888,"user_name":"Geek_4becf0","can_delete":false,"product_type":"c1","uid":2444747,"ip_address":"","ucode":"6A96BA0C4B3B64","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIWjdabiaIH7VxjUng9qpJssODr4b7icib0EJsuGhib7Nls1eBnUrEDAPfXXlsL5OjjfwXH84RuWyCn5w/132","comment_is_top":false,"comment_ctime":1654559060,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654559060","product_id":100033601,"comment_content":"老师每个宏任务都有自己的微任务队列吗？感觉没啥必要啊，全局一个微任务队列会不会好点，反正微任务队列在每次事件循环中都会全部执行完。","like_count":0},{"had_liked":false,"id":347675,"user_name":"莫呀嘛莫三爷@水滴","can_delete":false,"product_type":"c1","uid":2802421,"ip_address":"","ucode":"4A2EB3A1A0D352","user_header":"https://static001.geekbang.org/account/avatar/00/2a/c2/f5/30804e9e.jpg","comment_is_top":false,"comment_ctime":1654301690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654301690","product_id":100033601,"comment_content":"老师，我这边有个疑惑的<br><br>上面说到微任务是很宏任务绑定的，但是其实从图里来看每一个微任务都是放在了全局上下文那里的微任务队列。<br>那么假如settimeout创建了一个宏任务，里面包括了一个微任务（比如promise） 这个时候该微任务是会添加进全局上下文的微任务队列，还是该settimeout的宏任务的上下文的微任务队列","like_count":0},{"had_liked":false,"id":338059,"user_name":"G","can_delete":false,"product_type":"c1","uid":2330265,"ip_address":"","ucode":"F481F323D40711","user_header":"https://static001.geekbang.org/account/avatar/00/23/8e/99/44acecf1.jpg","comment_is_top":false,"comment_ctime":1647261326,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647261326","product_id":100033601,"comment_content":"老师好，看错了，忽略那个问题","like_count":0},{"had_liked":false,"id":338058,"user_name":"G","can_delete":false,"product_type":"c1","uid":2330265,"ip_address":"","ucode":"F481F323D40711","user_header":"https://static001.geekbang.org/account/avatar/00/23/8e/99/44acecf1.jpg","comment_is_top":false,"comment_ctime":1647261063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647261063","product_id":100033601,"comment_content":"老师好， 微任务示意图中，为什么mutation先加入队列，promise后加入。执行微任务的时候，为什么是promise先执行？","like_count":0},{"had_liked":false,"id":337812,"user_name":"六耳","can_delete":false,"product_type":"c1","uid":2021265,"ip_address":"","ucode":"547AD58D9F5FF7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d7/91/aa45c7a3.jpg","comment_is_top":false,"comment_ctime":1647075040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647075040","product_id":100033601,"comment_content":"老师好，有一个疑问。muationObserver是异步+微任务。您说使用微任务确保实时性，这和异步不是矛盾了么。异步天然不能保证实时性呀","like_count":0},{"had_liked":false,"id":334805,"user_name":"戡玉","can_delete":false,"product_type":"c1","uid":1162123,"ip_address":"","ucode":"398F0C0367E795","user_header":"https://static001.geekbang.org/account/avatar/00/11/bb/8b/028bbe52.jpg","comment_is_top":false,"comment_ctime":1645143960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645143960","product_id":100033601,"comment_content":"老师说的：&#39;javascript脚本执行事件&#39;是不是就是src=&#39;xx.js&#39;和script标签代码？其实之前面试也有问到，全局script代码是不是宏任务（包括scr=&#39;xx.js&#39;），面试官说仅仅是同步代码，希望老师解答下","like_count":0},{"had_liked":false,"id":332853,"user_name":"sundy","can_delete":false,"product_type":"c1","uid":1724856,"ip_address":"","ucode":"581D4B976524B6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/51/b8/f76b15a1.jpg","comment_is_top":false,"comment_ctime":1643732797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643732797","product_id":100033601,"comment_content":"JavaScript 脚本执行事件；请问指的是什么","like_count":0},{"had_liked":false,"id":316258,"user_name":"Geek_d5c147","can_delete":false,"product_type":"c1","uid":2624745,"ip_address":"","ucode":"5AA1C667338408","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QXSmwc4hDriaarz6libeAyg5juCEsWoKnyCxhIlXUw6iaEafljlkqksChHzyejJqeFBhVBIFHWrTksj6Hic47ncNrA/132","comment_is_top":false,"comment_ctime":1634226574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634226574","product_id":100033601,"comment_content":"想问一下作者，如果  Parse HTML 是宏任务，那么 performance 面板中的灰色的 Task 代表什么？","like_count":0},{"had_liked":false,"id":307015,"user_name":"光影","can_delete":false,"product_type":"c1","uid":2539250,"ip_address":"","ucode":"CE6EF591D3A7B5","user_header":"https://static001.geekbang.org/account/avatar/00/26/be/f2/60711467.jpg","comment_is_top":false,"comment_ctime":1628826222,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1628826222","product_id":100033601,"comment_content":"感觉和我理解的微任务宏任务有很多不同，为什么微任务队列是在宏任务快结束，js引擎退出全局上下文才执行？那这样，setTimeout算是宏任务嘛？那这么说岂不是太笼统了","like_count":0,"discussions":[{"author":{"id":2752142,"avatar":"https://static001.geekbang.org/account/avatar/00/29/fe/8e/895f05a2.jpg","nickname":"A LETTER","note":"","ucode":"56C82015945CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400974,"discussion_content":"setTimeout算宏任务，只不过其回调函数不会添加到消息队列中，而是添加到延时队列中的，整个js块代码的执行算一个宏任务，一个宏任务维持一个微任务队列，当这个宏任务执行将要结束后，会将微任务队列的任务全部执行直到清空，然后再从延迟队列中拿取过期的任务进行执行，由于setTimeout算宏任务，所以这个执行的任务也会维持一个微队列，所以这个宏任务结束之前又要清空一次自己的微任务队列，这也就是微任务可以插队的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633507555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298025,"user_name":"1830","can_delete":false,"product_type":"c1","uid":1374337,"ip_address":"","ucode":"246FEF7C97F39C","user_header":"https://static001.geekbang.org/account/avatar/00/14/f8/81/bff52f91.jpg","comment_is_top":false,"comment_ctime":1623893126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623893126","product_id":100033601,"comment_content":"老师本文中说了每个宏任务都会关联一个微任务，但是执行的时候又是去在全局的微任务队列中依次执行，这个不是有点矛盾吗，如果在全局执行微任务队列，浏览器是如何区分不同宏任务关联的微任务呢","like_count":0},{"had_liked":false,"id":290635,"user_name":"李文楷","can_delete":false,"product_type":"c1","uid":1925846,"ip_address":"","ucode":"A5BFEE3658AFB5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZVyciaHNnK30386OM4MibnOXqYCPUOicyriaic3rcnicw6aAGhvicgVswJWbv926QLJOMZvoCoBcWNAdA/132","comment_is_top":false,"comment_ctime":1619667782,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619667782","product_id":100033601,"comment_content":"老师，我有一个疑问，为什么下面这段代码中的4会在5之后打印呢，在我理解中，他应该在5之前打印才对，百思不得其解，请老师解释：<br><br>```js<br>Promise.resolve().then(() =&gt; {<br><br>    console.log(1)<br>    return Promise.resolve(4)<br>}).then(r =&gt; console.log(r))<br><br><br><br>Promise.resolve().then(() =&gt; {<br><br>    console.log(2)<br>    <br>}).then(() =&gt; {<br><br>    console.log(3)<br>}).then(() =&gt; {<br>    console.log(5)<br>}).then(() =&gt; {<br>    console.log(6)<br>})<br>```<br>结果是 1 2 3 5 46","like_count":0,"discussions":[{"author":{"id":2539250,"avatar":"https://static001.geekbang.org/account/avatar/00/26/be/f2/60711467.jpg","nickname":"光影","note":"","ucode":"CE6EF591D3A7B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388534,"discussion_content":"要看promise的内部机制，他如果返回了promise实例，那么实际上内部还会再包上一层异步处理，所以会再缓一步","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628826107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285156,"user_name":"小童","can_delete":false,"product_type":"c1","uid":1763395,"ip_address":"","ucode":"300444B520E79D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","comment_is_top":false,"comment_ctime":1616647265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616647265","product_id":100033601,"comment_content":"MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用。  老师我没明白为什么换成异步调用就贵减少次数的调用？","like_count":0},{"had_liked":false,"id":284537,"user_name":"张宗伟","can_delete":false,"product_type":"c1","uid":1374181,"ip_address":"","ucode":"1447A20C7A8982","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","comment_is_top":false,"comment_ctime":1616325067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616325067","product_id":100033601,"comment_content":"老师，您好！对于MutationObserver的 “异步+微任务”策略：<br>我理解这里的异步应该是 异步回调，像setTimeout&#47;XMLHttpRequest是将其添加到消息队列，作为宏任务执行，而MutationObserver是将其添加到当前宏任务的微任务队列执行。<br>所以我的疑问是 MutationObserver 中 异步回调 是如何实现的呢？还是说因为封装成了 微任务，从而实现了 异步 呢？<br>谢谢！","like_count":0},{"had_liked":false,"id":272445,"user_name":"哈哈","can_delete":false,"product_type":"c1","uid":1577110,"ip_address":"","ucode":"7228F93AF69195","user_header":"https://static001.geekbang.org/account/avatar/00/18/10/96/110e8cf7.jpg","comment_is_top":false,"comment_ctime":1610091948,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1610091948","product_id":100033601,"comment_content":"我看了些讲事件循环的博客，有的说先执行宏任务 再执行微任务，于教程上面相反老师可以解答一下吗?","like_count":0,"discussions":[{"author":{"id":2524182,"avatar":"https://static001.geekbang.org/account/avatar/00/26/84/16/e4df1c0b.jpg","nickname":"hin","note":"","ucode":"368DBF2A797D88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392780,"discussion_content":"个人理解：同步代码就是一个宏任务，所以绝对是先执行宏任务，再执行微任务。而老师上面说的：“在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行”。你可以点一下这句话上面的链接，其实意思是在一个宏任务中，再创建了一个新的宏任务和一个新的微任务，那么这个新的微任务就会添加到当前宏任务的微任务队列的队尾，而新的宏任务是添加到消息队列的队尾，当当前微任务队列清空了，才会执行消息队列中下一个宏任务，所以说微任务执行先于宏任务是这个意思","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631115096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1813484,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/ab/ec/11cce06a.jpg","nickname":"burning","note":"","ucode":"52454289244FFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566725,"discussion_content":"因为javascript本身是一个宏任务，写在script里面的宏任务和微任务中是微任务先执行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650735729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270473,"user_name":"超级读书郎","can_delete":false,"product_type":"c1","uid":1381602,"ip_address":"","ucode":"746DA51EF5FF21","user_header":"https://static001.geekbang.org/account/avatar/00/15/14/e2/e7e13e39.jpg","comment_is_top":false,"comment_ctime":1609142115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609142115","product_id":100033601,"comment_content":"请问，如果在一个微任务里面，不停的递归的创建微任务，那是不是就造成了当前宏任务的“死循环”？造成页面的“卡死”？","like_count":0},{"had_liked":false,"id":253274,"user_name":"zgy","can_delete":false,"product_type":"c1","uid":1387798,"ip_address":"","ucode":"05EA6845199250","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/16/b525a71d.jpg","comment_is_top":false,"comment_ctime":1602669770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602669770","product_id":100033601,"comment_content":"先打印1、rand、2 ，然后根据 rand &gt; 0.5 依次打印then或catch 的结果。<br>在全局上下文中，p0 首先被创建，在执行 resolve() 或reject() 时创建一个微任务，然后consolte.log(2)，p1 、 p2 、p3、p4","like_count":0},{"had_liked":false,"id":247862,"user_name":"QG","can_delete":false,"product_type":"c1","uid":1155469,"ip_address":"","ucode":"85DB7C41472C6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/8d/b6117f5c.jpg","comment_is_top":false,"comment_ctime":1599896603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599896603","product_id":100033601,"comment_content":"“当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。”这句话是不是描述有误，都已经发生变化了，还需要微任务吗？不是应该记住要发生的变化到微任务中先吗","like_count":0},{"had_liked":false,"id":245696,"user_name":"Runtime","can_delete":false,"product_type":"c1","uid":1216637,"ip_address":"","ucode":"8CCC73471BCB96","user_header":"https://static001.geekbang.org/account/avatar/00/12/90/7d/db9804be.jpg","comment_is_top":false,"comment_ctime":1599029056,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1599029056","product_id":100033601,"comment_content":"new Promise((resolve,reject)=&gt;{<br>    console.log(&quot;promise1&quot;)<br>    resolve()<br>}).then(()=&gt;{<br>    console.log(&quot;then11&quot;)<br>    new Promise((resolve,reject)=&gt;{<br>        console.log(&quot;promise2&quot;)<br>        resolve()<br>    }).then(()=&gt;{<br>        console.log(&quot;then21&quot;)<br>    }).then(()=&gt;{<br>        console.log(&quot;then23&quot;)<br>    })<br>}).then(()=&gt;{<br>    console.log(&quot;then12&quot;)<br>})<br>输出结果为: promise1,then11,promise2,then21,then12,then23<br>为什么then12会在then23之前执行？","like_count":0,"discussions":[{"author":{"id":2374581,"avatar":"https://static001.geekbang.org/account/avatar/00/24/3b/b5/c6eea696.jpg","nickname":"TyrionJ","note":"","ucode":"CBB10E57538E6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557576,"discussion_content":"上一个then执行完下一个then才会被推入队列，then23的微任务在then21执行了才会被推入队列，then11执行完后then12会被推入队列，而此时then21在队列中的微任务还没执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647868368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2374581,"avatar":"https://static001.geekbang.org/account/avatar/00/24/3b/b5/c6eea696.jpg","nickname":"TyrionJ","note":"","ucode":"CBB10E57538E6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557575,"discussion_content":"我来回答下，用console的内容代表每个then,首先输出promise1\nthen11入microTaskQueue, 输出then11和promise2,此时microTaskQueue:[then11]\n在执行then11的过程中，then21入microTaskQueue,此时microTaskQueue [then21, then11]\nthen11执行完，then12入microTaskQueue，此时microTaskQueue: [then12,then21]\n执行then21,输出then21,then23入microTaskQueue[then23,then12]\n执行then12,输出then12,microTaskQueue:[then23]\n执行then23输出then23","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647868015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244782,"user_name":"浩明啦","can_delete":false,"product_type":"c1","uid":1377422,"ip_address":"","ucode":"120ED8FC45B992","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/8e/e75ecc5e.jpg","comment_is_top":false,"comment_ctime":1598674957,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598674957","product_id":100033601,"comment_content":"老师我有个疑问 使用promise .all 去并行执行promise 数组， 浏览器内部是开启多个线程去并行执行promise的吗，然后执行完成后放到微任务对接？ 我这样理解对吗","like_count":0},{"had_liked":false,"id":243782,"user_name":"‏5102","can_delete":false,"product_type":"c1","uid":2116537,"ip_address":"","ucode":"476092AB890CF2","user_header":"https://static001.geekbang.org/account/avatar/00/20/4b/b9/2449c7b7.jpg","comment_is_top":false,"comment_ctime":1598274158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598274158","product_id":100033601,"comment_content":"老师我有疑问，看了上图的调用栈中，全局上下文底下还有parse html的任务，这说明parse html也是在v8中执行的吗？还是说老师画的那张图是渲染进程中主线程的调用栈呢？","like_count":0},{"had_liked":false,"id":240070,"user_name":"大桥2号","can_delete":false,"product_type":"c1","uid":2095749,"ip_address":"","ucode":"2BB88B211C5C8A","user_header":"https://static001.geekbang.org/account/avatar/00/1f/fa/85/1920fa21.jpg","comment_is_top":false,"comment_ctime":1596734952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596734952","product_id":100033601,"comment_content":"”因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了“   不太懂这一句， 宏任务运行的时候产生微任务队列，这个不是绝对会产生的吧？例如宏任务setTImeout 里面我只打印一个变量的话会将这个打印从宏任务队列取出执行完就没了吧，为什么还会产生微任务呢？","like_count":0},{"had_liked":false,"id":236438,"user_name":"Geek_33e8a7","can_delete":false,"product_type":"c1","uid":1721655,"ip_address":"","ucode":"0EAE7BC6FD9788","user_header":"","comment_is_top":false,"comment_ctime":1595415636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595415636","product_id":100033601,"comment_content":"如果在微任务里调用了宏任务，那么执行顺序会是怎么样的呢？比如在promise里调用XMLHttpRequest","like_count":0},{"had_liked":false,"id":230587,"user_name":"luwei","can_delete":false,"product_type":"c1","uid":1365541,"ip_address":"","ucode":"0960A09F7B8D59","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/25/a95a2064.jpg","comment_is_top":false,"comment_ctime":1593423547,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1593423547","product_id":100033601,"comment_content":"很不明白“微任务的执行时机是在主函数执行结束之后、当前宏任务结束之前。”这句话，为什么是“当前宏任务结束之前”，好多资料都说是当前宏任务执行完之后，再去清空微任务队列。烦请老师答疑。","like_count":0,"discussions":[{"author":{"id":1039904,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/de/20/03130a39.jpg","nickname":"沧海一声笑","note":"","ucode":"5297F2F4736B63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291550,"discussion_content":"你想想一个循环周期结束的判断依据是什么 在宏任务快要结束的时候 清空所有的微任务  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594866336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225903,"user_name":"傅杰","can_delete":false,"product_type":"c1","uid":2025085,"ip_address":"","ucode":"1F72CFE0917B21","user_header":"","comment_is_top":false,"comment_ctime":1591886274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591886274","product_id":100033601,"comment_content":"对这段话不太理解：<br><br>  。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。<br><br><br>如果我一个js文件是这样的<br><br>new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; {<br>        resolve(1)<br>    }, 1000)<br>}).then((res) =&gt; {<br>    console.log(res)<br>})<br><br><br>new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; {<br>        resolve(2)<br>    }, 1000)<br>}).then((res) =&gt; {<br>    console.log(res)<br>})<br><br><br>new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; {<br>        resolve(3)<br>    }, 1000)<br>}).then((res) =&gt; {<br>    console.log(res)<br>})<br><br><br>new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; {<br>        resolve(4)<br>    }, 1000)<br>}).then((res) =&gt; {<br>    console.log(res)<br>})<br><br>他会每隔一秒再打印下一个结果吗？","like_count":0},{"had_liked":false,"id":220553,"user_name":"张萌","can_delete":false,"product_type":"c1","uid":1377299,"ip_address":"","ucode":"89C08DB3239BE5","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/13/84d35588.jpg","comment_is_top":false,"comment_ctime":1590288410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590288410","product_id":100033601,"comment_content":"我们更新 DOM 的时间点，应该尽可能靠近渲染的时机。当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择","like_count":0},{"had_liked":false,"id":209261,"user_name":"Tim","can_delete":false,"product_type":"c1","uid":1742972,"ip_address":"","ucode":"F51593465157E4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/98/7c/07e6e7b7.jpg","comment_is_top":false,"comment_ctime":1587525708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587525708","product_id":100033601,"comment_content":"看到有人在纠结延迟队列去哪里了，我觉得没有必要，setTimeout又不是立刻把回调函数加入到消息队列的尾部，而是根据设置的延时时间来加入队列，所以执行顺序并不会乱掉。<br>老师讲的延迟队列我认为是Chrome的实现方式罢了，没准别的浏览器又是另一种实现方式。<br>总结一下，就是别想太多，别较真，信老师就可以了。","like_count":0},{"had_liked":false,"id":203588,"user_name":"依韵","can_delete":false,"product_type":"c1","uid":1153762,"ip_address":"","ucode":"02F5BED8BE0F6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/e2/271e0caf.jpg","comment_is_top":false,"comment_ctime":1586237428,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1586237428","product_id":100033601,"comment_content":"有一个疑问 xhr 是属于宏任务还是微任务？新的fetch又是如何？","like_count":0,"discussions":[{"author":{"id":1764805,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ed/c5/5bac4bd8.jpg","nickname":"LOG","note":"","ucode":"9587CDA4C44557","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233581,"discussion_content":"xhr的实现原理和setTimeout类似，是会进入消息队列的，所以是宏任务。fetch原先是基于Promise实现的，而Promise是微任务；虽然新的fetch不是基于Promise的，但也应该是微任务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586932230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200410,"user_name":"ihhuai","can_delete":false,"product_type":"c1","uid":1379127,"ip_address":"","ucode":"A796AF20437B8A","user_header":"https://static001.geekbang.org/account/avatar/00/15/0b/37/fd8355c4.jpg","comment_is_top":false,"comment_ctime":1585580884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585580884","product_id":100033601,"comment_content":"2 - 1  - random <br>【( random &gt; .5 )  success-1】  -  1 - random ( random &gt; .5 ) success-2 ....<br>( random &lt; .5 ) error","like_count":0},{"had_liked":false,"id":185024,"user_name":"blueBean","can_delete":false,"product_type":"c1","uid":1816697,"ip_address":"","ucode":"6A68D2414BD904","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b8/79/a4dbe9ee.jpg","comment_is_top":false,"comment_ctime":1583466891,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583466891","product_id":100033601,"comment_content":"所以微任务是存放在延迟队列里的？","like_count":0,"discussions":[{"author":{"id":2747374,"avatar":"https://static001.geekbang.org/account/avatar/00/29/eb/ee/22930bbc.jpg","nickname":"Geek_Ron","note":"","ucode":"A49296021C0F7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576106,"discussion_content":"延迟队列的任务也是宏任务，延迟队列是hashmap结构，像setTimeout定期任务，它放在延迟队列，到期了就会执行，结束才进入下一个循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655279796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179876,"user_name":"小薛菜菜子","can_delete":false,"product_type":"c1","uid":1622598,"ip_address":"","ucode":"C4E13239E84544","user_header":"https://static001.geekbang.org/account/avatar/00/18/c2/46/eca306d4.jpg","comment_is_top":false,"comment_ctime":1582115718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582115718","product_id":100033601,"comment_content":"前文曾说过：“处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。”从这段话来看，这个 ProcessDelayTask 执行的正是 setTimeout 的回调，并且是一次性全部执行完成的。<br>也就是说，setTimeout 应该实际上和微任务一样，只要到了时间，就会在【一个】普通消息队列中任务的完成之后就被执行的，而不是插入到消息队列的末尾，等待前面所有任务执行才能执行。<br>但是本章又不是这个意思。请问哪一边是准确的呢？还是我有理解上的谬误呢？<br>辛苦老师的解答了！","like_count":0},{"had_liked":false,"id":165228,"user_name":"AMIR","can_delete":false,"product_type":"c1","uid":1782777,"ip_address":"","ucode":"65142D9669071B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/33/f9/50b76abe.jpg","comment_is_top":false,"comment_ctime":1577183747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577183747","product_id":100033601,"comment_content":"老师，有个问题请教一下，第一个问题，延时队列如果存在，那么为什么两个setTimeOut中被加入那么多其他任务，不应该是最多执行一个，然后判断延时队列是否有到期de，然后就执行嘛？怎么会添加到尾巴上","like_count":0},{"had_liked":false,"id":165154,"user_name":"Chao","can_delete":false,"product_type":"c1","uid":1108745,"ip_address":"","ucode":"DD7742F5537521","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/09/ba5f0135.jpg","comment_is_top":false,"comment_ctime":1577173110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577173110","product_id":100033601,"comment_content":"宏任务并未出现在规范内。 ","like_count":0},{"had_liked":false,"id":159305,"user_name":"海之蓝心","can_delete":false,"product_type":"c1","uid":1098193,"ip_address":"","ucode":"C15210C86CDC13","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLReFZCZAq532WRg5Bjabx1WX997t0EVnsrLYcBnsNZDaDjk5jHvKDfRibjwibVjqtlm7S3eBJkwPtg/132","comment_is_top":false,"comment_ctime":1575597252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575597252","product_id":100033601,"comment_content":"老师，文中提到，微任务早于宏任务执行？<br>我的理解:当前宏任务执行完退出之前，再执行微任务列表的任务。<br>还有当前宏任务又有延迟列表任务，又有微任务，应该怎么执行？<br>求解惑？？<br>","like_count":0},{"had_liked":false,"id":146811,"user_name":"凭实力写bug","can_delete":false,"product_type":"c1","uid":1235611,"ip_address":"","ucode":"6F772551F18935","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/9b/e0ef47df.jpg","comment_is_top":false,"comment_ctime":1572663851,"is_pvip":false,"replies":[{"id":"56737","content":"后续有补充内容","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1572669623,"ip_address":"","comment_id":146811,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572663851","product_id":100033601,"comment_content":"执行流程很清楚,也知道了几个队列的关系,看完唯一迷惑的是那里算一个任务,对着performance执行流程就很清晰了","like_count":0,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473019,"discussion_content":"后续有补充内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572669623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138385,"user_name":"Cris","can_delete":false,"product_type":"c1","uid":1473520,"ip_address":"","ucode":"F8A287134F1078","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/f0/269139d5.jpg","comment_is_top":false,"comment_ctime":1570190980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570190980","product_id":100033601,"comment_content":"这篇赞","like_count":0},{"had_liked":false,"id":138359,"user_name":"Cris","can_delete":false,"product_type":"c1","uid":1473520,"ip_address":"","ucode":"F8A287134F1078","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/f0/269139d5.jpg","comment_is_top":false,"comment_ctime":1570177939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570177939","product_id":100033601,"comment_content":"先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask<br>老师一次事件循环只执行多个消息队列里最老的任务（即一次事件循环只执行一个任务）还是取每个消息列表里最老的任务（即一次事件循环会执行多个任务）？","like_count":0},{"had_liked":false,"id":138352,"user_name":"Cris","can_delete":false,"product_type":"c1","uid":1473520,"ip_address":"","ucode":"F8A287134F1078","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/f0/269139d5.jpg","comment_is_top":false,"comment_ctime":1570177009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570177009","product_id":100033601,"comment_content":"为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。老师渲染进程维护的消息队列除了延时队列和普通的消息队列是不是还有其他的队列？","like_count":0},{"had_liked":false,"id":137510,"user_name":"Djan Unchained","can_delete":false,"product_type":"c1","uid":1387997,"ip_address":"","ucode":"FB5A37B0EE3E98","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/dd/f2e79297.jpg","comment_is_top":false,"comment_ctime":1569756765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569756765","product_id":100033601,"comment_content":"addEventListener 是不是和 Mutation Event 一样也是同步回调？因为它只监听某个DOM节点，所以不会造成太大性能问题？","like_count":0},{"had_liked":false,"id":137269,"user_name":"浪里行舟","can_delete":false,"product_type":"c1","uid":1430382,"ip_address":"","ucode":"23D7E1C4DD5221","user_header":"https://static001.geekbang.org/account/avatar/00/15/d3/6e/7b6a9d91.jpg","comment_is_top":false,"comment_ctime":1569673909,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1569673909","product_id":100033601,"comment_content":"&quot;页面中的大部分任务都是在主线程上执行的&quot;,请问老师,这里的主线程是在渲染进程中还是浏览器主进程中,这个问题困扰很久,麻烦老师有空解答下<br>","like_count":0,"discussions":[{"author":{"id":1591850,"avatar":"","nickname":"王磊","note":"","ucode":"81865EEEFCB631","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190230,"discussion_content":"渲染进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582906862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1379119,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0b/2f/6efc3051.jpg","nickname":"GY","note":"","ucode":"764214512E67C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35475,"discussion_content":"渲染线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571283902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691581,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/bd/4fa01a1c.jpg","nickname":"wd2010","note":"","ucode":"E194E4EFECA013","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":27516,"discussion_content":"我觉得这里应该是渲染进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570664488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1430382,"avatar":"https://static001.geekbang.org/account/avatar/00/15/d3/6e/7b6a9d91.jpg","nickname":"浪里行舟","note":"","ucode":"23D7E1C4DD5221","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1691581,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/bd/4fa01a1c.jpg","nickname":"wd2010","note":"","ucode":"E194E4EFECA013","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29964,"discussion_content":"我也觉得，小心求证","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1570792411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":27516,"ip_address":""},"score":29964,"extra":""}]}]},{"had_liked":false,"id":136247,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1569395502,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1569395502","product_id":100033601,"comment_content":"为什么用mutation observer可以减少回掉次数呢？ 不应该Dom变化多少次就调多少次回掉函数吗？","like_count":0,"discussions":[{"author":{"id":1039904,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/de/20/03130a39.jpg","nickname":"沧海一声笑","note":"","ucode":"5297F2F4736B63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222574,"discussion_content":"类似节流防抖的操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586158322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134598,"user_name":"AYK","can_delete":false,"product_type":"c1","uid":1159960,"ip_address":"","ucode":"68E8C21A862A7A","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/18/e061e898.jpg","comment_is_top":false,"comment_ctime":1568876140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568876140","product_id":100033601,"comment_content":"new Promise(fn)是个立即执行同步任务  new 时候创建执行上下文 在将fn压栈创建fn执行上下文 再执行resolve()或者reject()创建resolve&#47;reject执行上下文, 后面的then catch进微任务，执行到console.log(2)同步任务，再执行微任务，如果前面执行的是reject()则直接console.log(&#39;error&#39;),如果是resolve()就打印console.log(&quot;succeed-1&quot;)...接着再重复（catch是可以一直onRejected退出的）","like_count":0},{"had_liked":false,"id":133618,"user_name":"Chao","can_delete":false,"product_type":"c1","uid":1108745,"ip_address":"","ucode":"DD7742F5537521","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/09/ba5f0135.jpg","comment_is_top":false,"comment_ctime":1568621859,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568621859","product_id":100033601,"comment_content":"一直理解的是 一次事件循环内 只取队头的宏任务执行和清空微任务队列。 <br>老师的讲解的 是宏任务关联微任务。","like_count":0,"discussions":[{"author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225889,"discussion_content":"你说的这两个不是一样吗。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586405148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133595,"user_name":"Geek_177f82","can_delete":false,"product_type":"c1","uid":1606961,"ip_address":"","ucode":"C1BF9B51E92995","user_header":"","comment_is_top":false,"comment_ctime":1568617816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568617816","product_id":100033601,"comment_content":"异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。setTimeout 采用的是这种方式。有个疑惑。那setTimeout的回调函数的任务是添加到异步消息队列还是普通的消息队列？那XMLHttpRequest 的回调函数任务呢？","like_count":0},{"had_liked":false,"id":133355,"user_name":"mfist","can_delete":false,"product_type":"c1","uid":1373624,"ip_address":"","ucode":"4F99F422C23FB4","user_header":"https://static001.geekbang.org/account/avatar/00/14/f5/b8/9f165f4b.jpg","comment_is_top":false,"comment_ctime":1568527492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568527492","product_id":100033601,"comment_content":"执行过程如下：（描述起来有点乱，一个流程图更好展现）<br>第10行：创建promise，输出1 随机数的值rand，如果rand&gt;0.5异步调用成功方法，否则进入失败方法<br>   32行：输入2，其他then catch方法逻辑添加到微任务队列<br>如果第10行中：rand 进入失败方法 输出error，结束<br>如果第10行中：rand进入成功方法，输出succeed-1，进入第10行逻辑。<br>如果rand一直大于0.5：则重复上面逻辑输出succeed-2 succeed-3 结束，否则从对应点跳到error逻辑，输出error结束。<br><br>今日总结：<br>随着消息队列中任务时间颗粒度要求变小引出了微任务的概念，主要应用的方面是MutationObserver、Promise及以它为基础的扩展技术。微任务执行的时机：当前主函数结束之后，宏任务的末尾去执行（可以理解为每个宏任务都对应一个微任务的队列）。然后讲了mutationObserver的演化过程","like_count":0},{"had_liked":false,"id":133291,"user_name":"Geek_b42f75","can_delete":false,"product_type":"c1","uid":1609471,"ip_address":"","ucode":"DCE04A7A714EEA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKpW6pOyXOVXF31iaLJsxAqEoPs5pa4om9icGU8fEECAaA1ZPLB21TgyNRiaibypChBiaBrSs3iaMau4qzg/132","comment_is_top":false,"comment_ctime":1568478433,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568478433","product_id":100033601,"comment_content":"您好，老师，想请教一个问题，本文主要讲解了当今浏览器产生微任务的两种方式：MutationObserver和Promise。那么对于process.nextTick和Object.observe又该如何理解呢？","like_count":0,"discussions":[{"author":{"id":1299829,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d5/75/d93f9648.jpg","nickname":"🍪","note":"","ucode":"2B6D01EA82DE97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12560,"discussion_content":"前面一个不是浏览器的标准，后面一个已经不再是标准了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568546804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133290,"user_name":"亮","can_delete":false,"product_type":"c1","uid":1234697,"ip_address":"","ucode":"E703B472ECB944","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/09/63ba546a.jpg","comment_is_top":false,"comment_ctime":1568478115,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568478115","product_id":100033601,"comment_content":"尝试在浏览器里运行下面这段代码:      <br>      let ele = document.querySelector(&#39;.test&#39;)<br>      debugger<br>      ele.remove()<br>      console.log(1)<br>调试结果是第三行运行完时页面上的节点立刻消失了，然后才打印 1，按上面图中的流程remove会添加微任务，结果应该是先打印1然后删除节点，有点晕~~","like_count":0,"discussions":[{"author":{"id":1147347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/81/d3/f0a88806.jpg","nickname":"🍐 🍾 🔆","note":"","ucode":"1B7C90800AD4D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65489,"discussion_content":"你要用MutationObserver这个API来测试呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575005975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133150,"user_name":"Geek_bca6b0","can_delete":false,"product_type":"c1","uid":1656285,"ip_address":"","ucode":"A8E2DE06BD6F1F","user_header":"","comment_is_top":false,"comment_ctime":1568420010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568420010","product_id":100033601,"comment_content":"理解是否对，首先执行这段脚本，创建一个全局执行上文，先执行p0，先打印1和rand值，再打印2，然后根据rand是否大于0.5决定将promise.resolve,或reject加入微任务的队列，然后执行微任务队列，执行resolve的回调函数，若遇到promise.resolve,再加入微任务队列，依次执行，若遇到小于0.5，就捕获错误。<br>那么，<br>  如果在promise里面嵌套setTimeout或xhr宏观任务，是否要退出当前全局上下文，等到延迟队列到了，再新建一个全局上下文，执行当前回调函数，遇到resolve，加入当前微任务队列吗?然后promise.then里再执行当前回调函数？","like_count":0}]}