{"id":776961,"title":"11｜函数的参数：赋予函数意义的关键特性","content":"<p>你好，我是海纳。</p><p>在前面的课程中，我们实现了函数的基本功能。其中第 9 节课我们讲解了如何定义一个函数对象，第 10 节课实现了调用函数的功能，但是第 10 节课的函数调用是不支持传递参数的。然而<strong>函数的最重要功能就是接收参数，进行运算并返回计算结果</strong>。上一节课我们展示了函数如何创建栈帧，进行运算并且返回计算结果。那么这一节课我们来关注如何向一个函数传递参数。</p><h2>Python 的传参机制</h2><p>Python 中传递参数的机制比很多语言都要复杂，所以我们把参数的实现放在最后来讲。和以前的方法一样，我们先写测试用例，再观察例子所对应的字节码。</p><p>创建 test_param.py：</p><pre><code class=\"language-plain\"># test_param.py\ndef add(a, b):&nbsp;\n&nbsp; &nbsp; return a + b&nbsp;\n\nprint(add(1, 2))\n</code></pre><p>然后通过 show_file 来查看它的内容。</p><pre><code class=\"language-plain\">// call function\n&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (&lt;code object add at 0x7ff9e40a0710, file \"/root/gitee/pythonvm/build/test_param.py\", line 2&gt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 ('add')\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 MAKE_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (add)\n\n&nbsp; 5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (add)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (1)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 (2)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;20 POP_TOP\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;22 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24 RETURN_VALUE\n\t\t&nbsp;\n// definition of add\n&nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_FAST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (a)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 LOAD_FAST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (b)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 BINARY_ADD\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 RETURN_VALUE\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;consts\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; None\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;names ()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;varnames ('a', 'b')\n</code></pre><!-- [[[read_end]]] --><p>在上述反编译出的字节码里，CALL_FUNCTION 都是带有参数的。</p><p>上一节课在实现 CALL_FUNCTION 的时候，我们并没有关注这个参数的值，因为当时的函数调用都没有带参数。在这一节课 add 的例子里，函数调用传递了两个参数，所以这个字节码的参数是 2（第 11 行）。print 函数则带有 1 个参数（第 12 行）。</p><p>实际上，在 CALL_FUNCTION 之前的两个字节码已经把参数送到栈上了（第 9 行和第 10 行的两个 LOAD_CONST），我们所要做的只是根据 CALL_FUNCTION 的参数，把栈上的值取出来，再传给函数栈帧就好了。</p><p>另外，add 函数中加载数据也出现了一个我们之前没有见过的字节码：<strong>LOAD_FAST</strong>。这个字节码用来访问函数的局部变量。局部变量和上一节课我们讲的 LOAD_NAME 不一样，它只依赖于位置下标，而不依赖于变量名称，所以局部变量不必使用 map 来维护，ArrayList 就足够了。</p><p>使用下标来访问变量值比使用 map 快多了，这也正是 FAST 这个名字的体现。</p><p>所以我们要在 FrameObject 里增加功能，让它可以接受参数，并且可以支持局部变量的快速访问。你可以看一下修改后的代码。</p><pre><code class=\"language-c++\">// runtime/FrameObject.cpp\nFrameObject::FrameObject (FunctionObject* func, ObjList args) {\n    _codes   = func-&gt;_func_code;\n    _consts  = _codes-&gt;_consts;\n    _names   = _codes-&gt;_names;\n\n    _locals  = new Map&lt;HiObject*, HiObject*&gt;();\n    _globals = func-&gt;_globals;\n    _fast_locals = nullptr;\n\n    if (args) {\n        _fast_locals = new ArrayList&lt;HiObject*&gt;();\n\n        for (int i = 0; i &lt; args-&gt;length(); i++) {\n            _fast_locals-&gt;set(i, args-&gt;get(i));\n        }\n    }\n\n    _stack   = new ArrayList&lt;HiObject*&gt;();\n\n    _pc      = 0;\n    _sender  = NULL;\n}\n</code></pre><p>FrameObject 里新增了一个成员变量 _fast_locals（第 9 行），用来处理函数的局部变量。</p><p>同时，我们还为 FrameObject 的构造函数增加了新的参数 args，用来表示调用函数时所使用的参数。在这个函数里，会把 args 中的值全部放到 _fast_locals 里去（第11行至第17行）。</p><p>和上述代码相匹配，CALL_FUNCTION 的实现也需要处理函数的参数。</p><pre><code class=\"language-c++\">// runtime/interpreter.cpp\nvoid Interpreter::build_frame(HiObject* callable, ObjList args) {\n    FrameObject* frame = new FrameObject((FunctionObject*) callable, args);\n    frame-&gt;set_sender(_frame);\n    _frame = frame;\n}\n\nvoid Interpreter::run(CodeObject* codes) {\n    _frame = new FrameObject(codes);\n    while (_frame-&gt;has_more_codes()) {\n\t    unsigned char op_code = _frame-&gt;get_op_code();\n        ...\n        switch (op_code) {\n\t\t...\n            case ByteCode::CALL_FUNCTION:\n                if (op_arg &gt; 0) {\n                    args = new ArrayList&lt;HiObject*&gt;(op_arg);\n                    while (op_arg--) {\n                        args-&gt;set(op_arg, POP());\n                    }\n                }\n\n                fo = static_cast&lt;FunctionObject*&gt;(POP());\n                // workaround for 'print'\n                if (fo == Universe::PrintFunc) {\n                    for (int i = 0; i &lt; args-&gt;length(); i++) {\n                        args-&gt;get(i)-&gt;print();\n                    }\n                    printf(\"\\n\");\n                    PUSH(Universe::HiNone);\n                }\n                else {\n                    build_frame(fo, args);\n                }\n\n                if (args != NULL) {\n                    delete args;\n                    args = NULL;\n                }\n                    \n                break;\n        ...\n        }\n    }\n}\n</code></pre><p>CALL_FUNCTION 总共做了三件事情。</p><p>第一，根据 op_arg 去栈里取出参数，然后放到 args 列表里（第 16 至 21 行）。第二，判断是不是 print 函数，因为我们现在还没有实现 print 函数，所以只能以一种特殊的方法把它绕过去（第 25 至 31 行）。如果不是 print 函数，就通过 build_frame 来正常地创建函数栈帧，通过这种方式，就把函数的参数传递到了 FrameObject 中（第32至34行）。最后一步，是清理临时变量（第 36 至 40 行）。</p><p>这样，我们就把函数的参数传入到函数栈帧中去了。</p><p>当函数参数被传到 _fast_locals 里以后，接着就是执行函数了。前边我们已经分析过了，add 方法的前两条字节码是 LOAD_FAST，而 LOAD_FAST 与 LOAD_GLOBAL、LOAD_CONST 一样，都是往栈上加载一个值（本质上是一个对象）。区别在于，LOAD_CONST 是从常量表里加载， LOAD_GLOBAL 是从全局变量表里加载，而 LOAD_FAST则是从栈帧的局部变量表中加载。</p><p>我们来看 LOAD_FAST 的具体实现。</p><pre><code class=\"language-c++\">void Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; _frame = new FrameObject(codes);\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::LOAD_FAST:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(_frame-&gt;fast_locals()-&gt;get(op_arg));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::STORE_FAST:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _frame-&gt;_fast_locals-&gt;set(op_arg, POP());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>添加了这些修改以后，我们就可以进行测试了，这节课刚开始的时候那个 test_param 的例子可以正常执行了。</p><p>运行以后可以正确打印出 3。到这里，我们就完成了函数调用的传参功能。</p><h2>参数默认值</h2><p>在定义函数的时候，我们可以为函数的参数指定默认值。例如：</p><pre><code class=\"language-python\"># test_default.py\ndef foo(a, b = 1, c = 2):\n&nbsp; &nbsp; return a + b + c\n\nprint(foo(10)) # 13\nprint(foo(100, 20, 30)) # 150\n</code></pre><p>在调用 foo 方法的时候，如果只传一个参数（第5行），这就意味着参数 a 的值为 10，b 的值则取默认值 1，c 取默认值 2。如果传三个参数（第6行），那么默认参数不起作用。</p><p>从这个例子可以看出，参数默认值是函数的一个属性，所以它应该是在函数定义的时候就和函数绑在了一起，也就是说，应该在 MAKE_FUNCTION 字节码处实现默认值的功能。</p><p>我们在 MAKE_FUNCTION 处创建了 FunctionObject ，所以默认值的最佳载体显然是 <strong>FunctionObject</strong>。如果你对这一点还有疑问，就跳转到<a href=\"https://time.geekbang.org/column/article/774409\">第 7 节课</a>和<a href=\"https://time.geekbang.org/column/article/774417\">第 8 节课</a>，搞清楚 CodeObject 和 FunctionObject 之间的区别和联系，再看后面的内容。</p><p>这里我们只需要把默认值记录在 FunctionObject 里，当调用的时候再加以处理就可以了。</p><p>接下来，我们就在 FunctionObject 里增加一个域，用来记录函数参数的默认值。</p><pre><code class=\"language-c++\">// runtime/functionObject.hpp\nclass FunctionObject : public HiObject {\nfriend class FunctionKlass;\nfriend class FrameObject;\n\nprivate:\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; ObjList&nbsp; &nbsp; &nbsp;_defaults;\n\npublic:\n&nbsp; &nbsp; FunctionObject(Klass* klass) {\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; _defaults&nbsp; = NULL;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; void set_default(ObjList defaults);\n&nbsp; &nbsp; ObjList defaults()&nbsp; &nbsp; &nbsp; &nbsp;{ return _defaults; }\n};\n\n// runtime/functionObject.hpp\nvoid FunctionObject::set_default(ArrayList&lt;HiObject*&gt;* defaults) {\n&nbsp; &nbsp; if (defaults == NULL) {\n&nbsp; &nbsp; &nbsp; &nbsp; _defaults = NULL;\n&nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; _defaults = new ArrayList&lt;HiObject*&gt;(defaults-&gt;length());\n&nbsp;\n&nbsp; &nbsp; for (int i = 0; i &lt; defaults-&gt;length(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; _defaults-&gt;set(i, defaults-&gt;get(i));\n&nbsp; &nbsp; }\n}\n</code></pre><p>这段代码的作用是在创建 FunctionObject 的时候，使用 set_default 方法设置好参数默认值。在这个方法中，我们创建了一个新的 ArrayList 对象，而不是把参数 defaults 的指针值直接赋给 FunctionObject 的 _defaults 域。</p><p>这样做是为了方便后面实现自动内存管理，FunctionObject 所指向的对象都在 FunctionObject 的逻辑里创建，遵循这个规则方便我们分析和实现自动内存管理机制。</p><p>在基础的数据结构功能完备以后，我们就可以考虑在 MAKE_FUNCTION 的实现中使用 set_default 方法了。</p><p>在最早实现 MAKE_FUNCTION 的时候，我们就看到了 MAKE_FUNCTION 这个字节码是带有参数的。但在一开始，我们并没有关心这个参数。实际上，它的参数正是为了指明默认参数的数量。</p><p>我们把这节课一开始的那个例子，test_default 的字节码打出来看一下。</p><pre><code class=\"language-plain\">&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 ((1, 2))\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (&lt;code object foo&gt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 ('foo')\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 MAKE_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (defaults)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (foo)\n</code></pre><p>可以看到，在这个例子里MAKE_FUNCTION 指令所带的参数就不再是 0 了，而是变成了 1。</p><p>MAKE_FUNCTION 至少使用两个数据，一个是CodeObject（第2行），一个是函数名称（第3行）。而参数默认值则是由指令参数指定的。在这个例子里，参数值为1 就代表构建的这个函数带一个默认值。也就是上述代码里的第一条字节码，第一行的那个 LOAD_CONST。这条指令把常量列表 <code>(1，2)</code> 放到了栈顶。</p><p><span class=\"reference\">这里需要注意，不同版本的Python虚拟机MAKE_FUNCTION的实现是不同的，有一些版本里，参数的默认值不是以列表传递的，而是把列表里的值展开放到栈上。栈上有多少个数据则是由MAKE_FUNCTION的指令参数指定的。这种实现和Python 3.8中的实现本质是一样的，只不过区别在于默认值是整体传入还是分别传入的。</span></p><p>经过这样的分析，我们就可以修改 MAKE_FUNCTION的实现了。</p><pre><code class=\"language-plain\">void Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; _frame = new FrameObject(codes);\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::MAKE_FUNCTION:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = POP(); // function name\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fo = new FunctionObject(v);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fo-&gt;set_globals(_frame-&gt;globals());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (op_arg == 1) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HiList* t = (HiList*)POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args = new ArrayList&lt;HiObject*&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; t-&gt;length(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args-&gt;add(t-&gt;get(i));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fo-&gt;set_default(args);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(fo);\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (args != NULL) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete args;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args = NULL;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>上述代码先根据 op_arg 的值去栈上获取默认参数，当 op_arg 为 1 的时候，默认参数是一个列表（第 13 行），我们把这个参数从栈上取出来，然后把它的内容都装到 args 数组里（第 14 至 18 行）。然后我们把默认值传递给 FunctionObject 对象（第 20、21 行）。最后再把临时变量释放掉（第23至26行）。</p><p>这样，我们就完成了 MAKE_FUNCTION 的所有工作。要让默认参数生效，还差最后一步，那就是当调用者没有传实参的时候，使用默认参数代替实参。这个工作要在函数被调用的时候进行。</p><p>传递参数的代码在 build_frame 和 FrameObject 的构造函数里，主要是通过操作_fast_locals 数据结构来传递参数。同时，默认参数也是使用 _fast_locals 传递。所以这里我们就来修改一下 FrameObject 的构造方法，让默认参数起作用。</p><pre><code class=\"language-c++\">FrameObject::FrameObject (FunctionObject* func, ObjList args) {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; _fast_locals = new ArrayList&lt;HiObject*&gt;();\n\n&nbsp; &nbsp; if (func-&gt;_defaults) {\n&nbsp; &nbsp; &nbsp; &nbsp; int dft_cnt = func-&gt;_defaults-&gt;length();\n&nbsp; &nbsp; &nbsp; &nbsp; int argcnt&nbsp; = _codes-&gt;_argcount;\n\n&nbsp; &nbsp; &nbsp; &nbsp; while (dft_cnt--) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _fast_locals-&gt;set(--argcnt, func-&gt;_defaults-&gt;get(dft_cnt));\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; if (args) {\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; args-&gt;length(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _fast_locals-&gt;set(i, args-&gt;get(i));\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; ...\n}\n</code></pre><p>这个函数做的第一件事情是设置默认参数（第 5 至 11 行）。</p><p>我们在分析二进制文件结构时，就简单介绍过 CodeObject 的 argcount 属性了，这里是我们第一次使用这个属性。这个值代表了一个函数的参数个数。请注意，我们以倒序的方式把默认参数送入到 _fast_locals 里去（第 9 至 11 行），这是因为只有位于参数列表后面的几个参数才能使用默认值。</p><p>函数做的第二件事情是处理实际传入的参数（第 14 至 18 行）。也就是说，默认参数与实际参数在这里汇合了。你可以通过我给出的示意图理解它们整合的过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/be/7fcd114022ff43149a4c34d2185fa4be.png?wh=1744x812\" alt=\"图片\"></p><p>这里你可能会有疑问，有没有其他特殊情况呢？比如默认参数可不可能在实参之前。其实这是不用担心的，因为 Python 的语法规定默认参数必须定义在非默认参数之前。比如，以下的代码是不合法的。</p><pre><code class=\"language-python\">//SyntaxError: non-default argument follows default argument\ndef foo(a = 1, b):&nbsp;\n&nbsp; &nbsp; return a + b&nbsp;\n\nfoo(2)\n</code></pre><p>Python 的编译器会对这个方法定义报错，提示无默认值参数不能出现在默认值参数之后。这样的语法保证了我们在处理默认值的时候，从后往前填入默认值的做法是绝对正确的。</p><h2>一个复杂的例子</h2><p>最后，我们来运行一个更加复杂的例子。</p><pre><code class=\"language-python\">def make_func(x):\n&nbsp; &nbsp; def add(a, b = x):&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return a + b&nbsp;\n\n&nbsp; &nbsp; return add\n\nadd5 = make_func(5)\nprint add5(10)\n</code></pre><p>在这个例子里，我们向 make_func 函数传递了参数 5，然后又在 make_func 内部定义了一个函数为 add，函数 add 可以计算两个数的和。同时，它的第二个参数是以 5 为默认值的参数，所以 add5 就可以只接受一个参数，计算这个参数与 5 的和了。执行这个例子，结果就会是 15。</p><p>在这个例子里，用了一个之前没用过的字节码：<strong>BUILD_TUPLE</strong>，它的作用是构建默认参数列表。在 test_default 例子里，默认参数列表是以常量值的方式直接加载到栈上，而这里因为 x 是变量，所以只能在运行时通过 BUILD_TUPLE 来构建。</p><p>BUILD_TUPLE 做的事情是根据 op_arg 从栈上取参数，然后构造一个 tuple，到目前为止，我们还不能支持元组（tuple），但使用列表（list）来代替也是可以的。所以我们就提供一个简单的实现，等后面完全实现了列表和元组的功能以后，再完善这里的实现。</p><p>你可以看一下BUILD_TUPLE 的代码实现。</p><pre><code class=\"language-python\">void Interpreter::run(CodeObject* codes) {\n    _frame = new FrameObject(codes);\n    while (_frame-&gt;has_more_codes()) {\n\t    unsigned char op_code = _frame-&gt;get_op_code();\n        ...\n        switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::BUILD_TUPLE:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lst = new HiList();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (op_arg--) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lst-&gt;append(POP());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(lst);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n        ...\n        }\n    }\n}\n</code></pre><p>这段代码做的事情是从栈上取多个对象（数量由op_arg决定），放入到列表中。</p><p>补齐了这个字节码以后，make_func 的例子就可以正确执行了。</p><h2>总结</h2><p>这节课我们实现了可以在调用函数时，向其传入参数的功能。在过去的两节课里，我们清晰地解释了 CodeObject、FunctionObject 和 FrameObject 之间的关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/7c/ff5646ce3251214273a64yye20361e7c.png?wh=1920x514\" alt=\"图片\"></p><p>LOAD_CONST 把 CodeObject 加载到栈顶，MAKE_FUNCTION 则负责创建 FunctionObject，所以 CodeObject 和 FunctionObject 是一对多的关系。并且，CodeObject 中记录了代码的静态信息，例如字节码、常量表等等。而 FunctionObject 则多了很多动态信息，例如参数默认值等。</p><p>CALL_FUNCTION 负责真正地执行函数，函数的动态记录是使用 FrameObject 维护的，所以 FunctionObject 与 FrameObject 也是一对多的关系。</p><p>只要把图里的关系搞清楚了，这两节课的内容就全部掌握了。</p><p>从<a href=\"https://time.geekbang.org/column/article/772694\">第 4 节课</a>开始，遇到 print 函数的时候，我们都是使用一些手段规避了，作为 Python 语言中最重要的一个函数，下节课我们将正面地实现这个函数。</p><h2>思考题</h2><p>函数的相关机制，我们已经实现了很多了。请你自己试验一下，你的虚拟机是否可以支持 Lambda 语句。欢迎你把你试验的结果分享到评论区，也欢迎你把这节课分享给其他朋友，邀他们一起学习，我们下节课再见！</p>","neighbors":{"left":{"article_title":"10｜变量的作用域：哪些复杂规则是因函数而产生的？","id":776954},"right":{"article_title":"12｜Native方法：打通底层软件与高层应用的关键","id":778919}},"comments":[{"had_liked":false,"id":395257,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1729911093,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":395123,"user_name":"冯某","can_delete":false,"product_type":"c1","uid":3889476,"ip_address":"上海","ucode":"7E78ECA53DF453","user_header":"https://static001.geekbang.org/account/avatar/00/3b/59/44/727b90a8.jpg","comment_is_top":false,"comment_ctime":1729501028,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"这里没有留言","like_count":0}]}