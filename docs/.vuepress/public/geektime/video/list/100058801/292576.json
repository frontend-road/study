{"id":292576,"title":"31 | Process Function应用","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geektime-Flink\">https://gitee.com/geektime-geekbang/geektime-Flink</a></p>","comments":[{"had_liked":false,"id":254132,"user_name":"yang","can_delete":false,"product_type":"c3","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1603070318,"is_pvip":false,"replies":[{"id":93239,"content":"删除定时器这种操作比较少，是按照给定时间来删除的，processElement 和 onTimer两个方法是在同一个线程中处理的，如果不是同步的话就会出现线程安全的问题，这样processElement()方法处理的数据就会出现不一致的情况","user_name":"作者回复","user_name_real":"张利兵","uid":1119779,"ctime":1603527066,"ip_address":"","comment_id":254132,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"在处理每个元素的时候可以注册一个计时器\n也可以在处理元素的时候通过deleteEventTimeTimer(ts)来删除当前key的计时器\n但是这个key的计时器可能已经有多个还未触发，我调用delete的时候删除的是最早创建的那个吗？\n\n我还想问一下 对于processElement 和 onTimer这两个方法的调用是同步的 \n这个应该怎么理解？","like_count":3,"discussions":[{"author":{"id":1119779,"avatar":"https://static001.geekbang.org/account/avatar/00/11/16/23/99c7ede5.jpg","nickname":"张利兵","note":"","ucode":"DBAE17970AB143","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507289,"discussion_content":"删除定时器这种操作比较少，是按照给定时间来删除的，processElement 和 onTimer两个方法是在同一个线程中处理的，如果不是同步的话就会出现线程安全的问题，这样processElement()方法处理的数据就会出现不一致的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603527066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254155,"user_name":"yang","can_delete":false,"product_type":"c3","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1603072406,"is_pvip":false,"replies":[{"id":93238,"content":"继续注册Timer，注意Timer数据都是存在JVM Heap中的，并且也是要做快照处理的。","user_name":"作者回复","user_name_real":"张利兵","uid":1119779,"ctime":1603526785,"ip_address":"","comment_id":254155,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"另外 老师我想问一下\n视频中的代码在每一次处理新元素的时候注册一个计时器\n那如果上一次注册的计时器还未触发，本次注册的计时器 是继续新注册一个计时器，还是覆盖上一次那个未触发的计时器？ ","like_count":2,"discussions":[{"author":{"id":1119779,"avatar":"https://static001.geekbang.org/account/avatar/00/11/16/23/99c7ede5.jpg","nickname":"张利兵","note":"","ucode":"DBAE17970AB143","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507299,"discussion_content":"继续注册Timer，注意Timer数据都是存在JVM Heap中的，并且也是要做快照处理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603526785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255378,"user_name":"长脖子树","can_delete":false,"product_type":"c3","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1603332183,"is_pvip":true,"replies":[{"id":93229,"content":"是的 ","user_name":"作者回复","user_name_real":"张利兵","uid":1119779,"ctime":1603524499,"ip_address":"","comment_id":255378,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"TimerService 接口中有删除定时器的接口 \nvoid deleteProcessingTimeTimer(long time);  \nvoid deleteEventTimeTimer(long time);  \n输入给定的时间, 就可以删除那个时间的定时器","like_count":1,"discussions":[{"author":{"id":1119779,"avatar":"https://static001.geekbang.org/account/avatar/00/11/16/23/99c7ede5.jpg","nickname":"张利兵","note":"","ucode":"DBAE17970AB143","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507700,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603524499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254157,"user_name":"yang","can_delete":false,"product_type":"c3","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1603072673,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"考虑一种删除计时器的场景：\n\n假设上游发送过来的key-value中的value可正可负\n我们需要在state中维护一个value的sum值，\n当这个value值变大的时候我们注册一个计时器，进行sum的输出并清除这个状态；\n当这个value值变小的时候我们取消这个计时器，不做sum的输出与清除。","like_count":3},{"had_liked":false,"id":376764,"user_name":"小菜鸟","can_delete":false,"product_type":"c3","uid":1256026,"ip_address":"内蒙古","ucode":"3210C8528E1912","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/5a/da723ac4.jpg","comment_is_top":false,"comment_ctime":1687331229,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"这个state 如果算子是多并行度 是怎么保证数据计算是正确的呢","like_count":0},{"had_liked":false,"id":369113,"user_name":"Geek_bad486","can_delete":false,"product_type":"c3","uid":3532766,"ip_address":"湖北","ucode":"52C97ECA91B1CF","user_header":"","comment_is_top":false,"comment_ctime":1677122311,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"请问注册定时器的代价是否高昂？因为这里的实例注册定时器太过于频繁了","like_count":0},{"had_liked":false,"id":340263,"user_name":"Zoro","can_delete":false,"product_type":"c3","uid":1105178,"ip_address":"","ucode":"2B4B82CEE26A72","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/1a/725b6c19.jpg","comment_is_top":false,"comment_ctime":1648707091,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"您好，我现在要对全国单量进行统计，但是如果用allwindow会影响性能，我先通过订单做一个hash 然后keyed分开计算，最后要用什么方式再合并起来","like_count":0},{"had_liked":false,"id":323166,"user_name":"Geek_246ovb","can_delete":false,"product_type":"c3","uid":1718198,"ip_address":"","ucode":"7A79D96729357C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er5oeRAIicqPS4QsOjyVkvMzaQGvgnln8XiboSuwE9UmjlichtrXnKpT7iampOKadLOWMOsl0CG9rhkpQ/132","comment_is_top":false,"comment_ctime":1637747882,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":2,"product_id":100058801,"comment_content":"可以在处理当前元素之前把上一个元素的定时器删除掉？这样就不会每个元素处理完的100ms后多要触发一次onTimer了，只有在100ms内没有来新元素把上一个元素的定时器删除掉的时候才会触发onTimer","like_count":0},{"had_liked":false,"id":281472,"user_name":"Allan","can_delete":false,"product_type":"c3","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1614759201,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"在onTimer中我们可以通过ctx拿到ctx.timerService().deleteEventTimeTimer(timestamp);进行删除。删除只是删除了定时器，感觉已经到了onTimer，删不删除已经没啥意义了吧？数据发不发下游 通过收集器控制就好了。","like_count":0},{"had_liked":false,"id":258582,"user_name":"小白","can_delete":false,"product_type":"c3","uid":1274811,"ip_address":"","ucode":"54FA90F18F4094","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOOrv7cDhjs48zvkq9Ngl90wxXCGKSIbiarmQjYlUZy2ukb0Jh7sANcLziaPWyXcCibueHxR5Mw61ibQ/132","comment_is_top":false,"comment_ctime":1604491383,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"例子中数据流里的key都是相同的值吗？如果不是，是每个key都对应一个ValueState对象吗？","like_count":0,"discussions":[{"author":{"id":1442535,"avatar":"https://static001.geekbang.org/account/avatar/00/16/02/e7/20294573.jpg","nickname":"小石头","note":"","ucode":"F72197C6F06889","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344300,"discussion_content":"因为是KeyedState，所以是每个key都对应一个ValueState","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611397942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}