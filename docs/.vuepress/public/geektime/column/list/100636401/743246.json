{"id":743246,"title":"16｜大功告成：完成MiniTomcat","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上节课我们引入了自定义的类加载器，先尝试了用系统提供的ClassLoader加载某个类，如果是delegate模式，那么父级类加载器去加载这个类，之后再试着由原本的类加载器加载类；如果不是delegate模式，使用父级类加载器加载，如果父级类加载器为空，就用系统级类加载器加载。</p><p>随后我们还进一步区分了Context、Host，对MiniTomcat进行了两层容器包装，实现解耦。</p><p>而这节课我们计划做进一步的优化调整，一是在进入Host层之前，预先装载Context，二是对Servlet访问路径支持自定义。最后通过配置文件来配置服务器，跟Tomcat一样。</p><p>现在我们一起来动手实现。</p><h2>项目结构</h2><p>这节课我们把所有的ClassLoader移到/loader目录里，随后使用server.xml和web.xml分别管理Host启动配置与Servlet加载配置，这也是我们这节课的重点，你可以看一下现在的目录结构。</p><pre><code class=\"language-plain\">MiniTomcat\n├─ conf\n│  ├─ server.xml\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ com\n│  │  │  │  ├─ minit\n│  │  │  │  │  ├─ connector\n│  │  │  │  │  │  ├─ http\n│  │  │  │  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  │  │  │  ├─ HttpConnector.java\n│  │  │  │  │  │  │  ├─ HttpHeader.java\n│  │  │  │  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  │  │  │  ├─ HttpRequestImpl.java\n│  │  │  │  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  │  │  │  ├─ HttpResponseImpl.java\n│  │  │  │  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  │  │  │  ├─ StatisResourceProcessor.java\n│  │  │  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  │  ├─ core\n│  │  │  │  │  │  ├─ ApplicationFilterChain.java\n│  │  │  │  │  │  ├─ ApplicationFilterConfig.java\n│  │  │  │  │  │  ├─ ContainerBase.java\n│  │  │  │  │  │  ├─ ContainerListenerDef.java\n│  │  │  │  │  │  ├─ FilterDef.java\n│  │  │  │  │  │  ├─ FilterMap.java\n│  │  │  │  │  │  ├─ StandardContext.java\n│  │  │  │  │  │  ├─ StandardContextValve.java\n│  │  │  │  │  │  ├─ StandardHost.java\n│  │  │  │  │  │  ├─ StandardHostValve.java\n│  │  │  │  │  │  ├─ StandardPipeline.java\n│  │  │  │  │  │  ├─ StandardWrapper.java\n│  │  │  │  │  │  ├─ StandardWrapperValve.java\n│  │  │  │  │  ├─ loader\n│  │  │  │  │  │  ├─ CommonClassLoader.java\n│  │  │  │  │  │  ├─ CommonLoader.java\n│  │  │  │  │  │  ├─ WebappClassLoader.java\n│  │  │  │  │  │  ├─ WebappLoader.java\n│  │  │  │  │  ├─ logger\n│  │  │  │  │  │  ├─ Constants.java\n│  │  │  │  │  │  ├─ FileLogger.java\n│  │  │  │  │  │  ├─ LoggerBase.java\n│  │  │  │  │  │  ├─ SystemErrLogger.java\n│  │  │  │  │  │  ├─ SystemOutLogger.java\n│  │  │  │  │  ├─ session\n│  │  │  │  │  │  ├─ StandardSession.java\n│  │  │  │  │  │  ├─ StandardSessionFacade.java\n│  │  │  │  │  ├─ startup\n│  │  │  │  │  │  ├─ BootStrap.java\n│  │  │  │  │  ├─ util\n│  │  │  │  │  │  ├─ CookieTools.java\n│  │  │  │  │  │  ├─ StringManager.java\n│  │  │  │  │  │  ├─ URLDecoder.java\n│  │  │  │  │  ├─ valves\n│  │  │  │  │  │  ├─ AccessLogValve.java\n│  │  │  │  │  │  ├─ ValveBase.java\n│  │  │  │  ├─ Connector.java\n│  │  │  │  ├─ Container.java\n│  │  │  │  ├─ ContainerEvent.java\n│  │  │  │  ├─ ContainerListener.java\n│  │  │  │  ├─ Context.java\n│  │  │  │  ├─ InstanceEvent.java\n│  │  │  │  ├─ InstanceListener.java\n│  │  │  │  ├─ Loader.java\n│  │  │  │  ├─ Logger.java\n│  │  │  │  ├─ Pipeline.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ Session.java\n│  │  │  │  ├─ SessionEvent.java\n│  │  │  │  ├─ SessionListener.java\n│  │  │  │  ├─ Valve.java\n│  │  │  │  ├─ ValveContext.java\n│  │  │  │  ├─ Wrapper.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  │  │  ├─ TestFilter.java\n│  │  │  │  ├─ TestListener.java\n│  │  │  │  ├─ TestServlet.java\n│  │  ├─ resources\n├─ webapps\n│  ├─ app1\n│  │  ├─ WEB-INF\n│  │  │  ├─ classes\n│  │  │  │  ├─ test\n│  │  │  │  │  ├─ HelloServlet.class\n│  │  │  │  │  ├─ TestFilter.class\n│  │  │  │  │  ├─ TestListener.class\n│  │  │  │  │  ├─ TestServlet.class\n│  │  │  ├─ web.xml\n│  │  ├─ hello.txt\n│  ├─ app2\n│  │  ├─ WEB-INF\n│  │  │  ├─ classes\n│  │  │  │  ├─ test\n│  │  │  │  │  ├─ HelloServlet.class\n│  │  │  │  │  ├─ TestFilter.class\n│  │  │  │  │  ├─ TestListener.class\n│  │  │  │  │  ├─ TestServlet.class\n│  │  │  ├─ web.xml\n│  │  ├─ hello.txt\n├─ pom.xml\n</code></pre><!-- [[[read_end]]] --><h2>预装载Context</h2><p>前面我们提到了，如何在调用一个Host之前知道有哪些Context呢？之前是在访问Host的时候 调用getContext()方法实现的，现在我们可以进一步改造，在Host启动时就进行识别，预先装载Context，不必每次都再调用getContext()。</p><p>我们在StandardHost类的start()方法中添加一段代码。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardHost extends ContainerBase {\n\n    //启动 Host\n    public void start(){\n        fireContainerEvent(\"Host Started\",this);\n        Logger logger = new FileLogger();\n        setLogger(logger);\n        ContainerListenerDef listenerDef = new ContainerListenerDef();\n        listenerDef.setListenerName(\"TestListener\");\n        listenerDef.setListenerClass(\"test.TestListener\");\n        addListenerDef(listenerDef);\n        listenerStart();\n        //在/webapps目录下加载所有上下文\n        File classPath = new File(System.getProperty(\"minit.base\"));\n        String dirs[] = classPath.list();\n        for (int i=0; i &lt; dirs.length; i++) {\n            getContext(dirs[i]);\n        }\n    }\n}\n</code></pre><p>相比之前，我们在start()方法里新增的就是下面这一段代码。</p><pre><code class=\"language-java\">        //在/webapps目录下加载所有上下文\n        File classPath = new File(System.getProperty(\"minit.base\"));\n        String dirs[] = classPath.list();\n        for (int i=0; i &lt; dirs.length; i++) {\n            getContext(dirs[i]);\n        }\n</code></pre><p>代码中有一个 minit.base 属性，它代表了应用的基础目录，比如webapps，我们认为它下面的每个子目录都代表了一个不同的应用。这个属性是在BootStrap里设置的，我们就先改造BootStrap。</p><p>参考Tomcat，这节课我们也要定义server.xml，虽然我们可以自己编写工具类进行XML解析，但这不是我们的重点，因而不再重复造轮子了，在开始改造BootStrap前，我们在pom.xml里引入新的依赖。</p><pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.dom4j&lt;/groupId&gt;\n    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;\n    &lt;version&gt;2.1.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><p>Server.xml文件代表了Tomcat的总体结构，启动配置都放在这个文件中。你打开一个文件，看一下它的主体部分。</p><pre><code class=\"language-plain\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt;\n&nbsp; &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt;\n\n&nbsp; &lt;Service name=\"Catalina\"&gt;\n&nbsp; &nbsp; &lt;Executor name=\"tomcatThreadPool\" namePrefix=\"catalina-exec-\"\n&nbsp; &nbsp; &nbsp; &nbsp; maxThreads=\"150\" minSpareThreads=\"4\"/&gt;\n&nbsp; &nbsp; &lt;Connector executor=\"tomcatThreadPool\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;port=\"8080\" protocol=\"HTTP/1.1\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;connectionTimeout=\"20000\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;redirectPort=\"8443\" /&gt;\n\n&nbsp; &nbsp; &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt;\n&nbsp; &nbsp; &nbsp; &lt;Host name=\"localhost\"&nbsp; appBase=\"webapps\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unpackWARs=\"true\" autoDeploy=\"true\"&gt;\n\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prefix=\"localhost_access_log\" suffix=\".txt\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt;\n\n&nbsp; &nbsp; &nbsp; &lt;/Host&gt;\n&nbsp; &nbsp; &lt;/Engine&gt;\n&nbsp; &lt;/Service&gt;\n&lt;/Server&gt;\n</code></pre><p>我们可以看到，这个Server.xml就对应了我们目前探讨的Tomcat内部的概念，Service、Engine、Host、Connector等等。在Host中还可以定义Context，不过因为现在一般都是自动部署应用，所以并不推荐它了。</p><p><img src=\"https://static001.geekbang.org/resource/image/ba/1d/ba640f25690760576964889c2144911d.png?wh=1920x1093\" alt=\"图片\"></p><ul>\n<li>顶层：<code>&lt;Server&gt;</code> 和 <code>&lt;Service&gt;</code></li>\n</ul><p><code>&lt;Server&gt;</code> 是Server.xml配置文件的根元素，<code>&lt;Service&gt;</code> 则代表一个Engine以及一组与之相连的Connector。</p><ul>\n<li>连接器：<code>&lt;Connector&gt;</code></li>\n</ul><p><code>&lt;Connector&gt;</code> 代表了客户端发送请求到特定Service的接口，如通过8080端口访问；反过来它也是外部客户端从特定Service接收响应的接口。</p><ul>\n<li>容器：<code>&lt;Engine&gt;</code>、<code>&lt;Host&gt;</code>、<code>&lt;Context&gt;</code></li>\n</ul><p>容器用来处理通过Connector进来的请求，并调用相关的Servlet产生相应的响应。Engine、Host和Context都是容器，它们是上下级关系，层层包含：Engine包含Host，Host包含Context。一个Engine组件可以处理Service中的所有请求，一个Host组件可以处理发向一个特定虚拟主机的所有请求，一个Context组件可以处理一个特定Web应用的所有请求。</p><p>接下来我们调整BootStrap类，主要涉及启动方法的调整。</p><pre><code class=\"language-java\">package com.minit.startup;\npublic class BootStrap {\n    public static final String MINIT_HOME =\n            System.getProperty(\"user.dir\");\n    public static String WEB_ROOT =\n            System.getProperty(\"user.dir\");\n    public static int PORT = 8080;\n    private static int debug = 0;\n    public static void main(String[] args) {\n        if (debug &gt;= 1)\n            log(\".... startup ....\");\n        //scan server.xml\n        //scan web.xml\n        String file = MINIT_HOME + File.separator + \"conf\" + File.separator + \"server.xml\";\n        SAXReader reader = new SAXReader();\n        Document document;\n        try {\n            document = reader.read(file);\n            Element root = document.getRootElement();\n            Element connectorelement= root.element(\"Connector\");\n            Attribute portattribute = connectorelement.attribute(\"port\");\n            PORT = Integer.parseInt(portattribute.getText());\n            Element hostelement = root.element(\"Host\");\n            Attribute appbaseattribute = hostelement.attribute(\"appBase\");\n            WEB_ROOT =  WEB_ROOT + File.separator + appbaseattribute.getText();\n        }\n        catch(Exception e) {\n        }\n        System.setProperty(\"minit.home\", MINIT_HOME);\n        System.setProperty(\"minit.base\", WEB_ROOT);\n        HttpConnector connector = new HttpConnector();\n        StandardHost container = new StandardHost();\n        Loader loader = new CommonLoader();\n        container.setLoader(loader);\n        loader.start();\n        connector.setContainer(container);\n        container.setConnector(connector);\n        container.start();\n        connector.start();\n    }\n}\n</code></pre><p>相比之前，新增了对server.xml的解析，而且解析了 <code>&lt;Connnector&gt;</code> 标签里的port参数，以及 <code>&lt;Host&gt;</code> 标签里的appBase参数，我们在项目根目录下新建/conf文件夹，并新增server.xml，参考配置如下：</p><pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Server&gt;\n    &lt;Connector port=\"8080\" /&gt;\n    &lt;Host name=\"localhost\"  appBase=\"webapps\"&gt;\n    &lt;/Host&gt;\n&lt;/Server&gt;\n\n</code></pre><p>在server.xml里我们定义服务器端口为8080，应用的根目录为/webapps，这也和我们目前的项目结构对应。</p><p>这一部分解析代码我们简化处理了，使用Dom4j读取文件在内存构造一棵Dom树。Tomcat实际上用的是Digester，这是一种基于SAX实现的模型。我们没有使用Digester，是因为它比较复杂，使用的人也比较少，而且并不关系Tomcat的核心结构。</p><p>在BootStrap的main方法解析完server.xml后，minit.base的值已经指向了项目中的/webapps目录，所以在这个目录里我们进行遍历工作，依次调用getContext方法，你可以看一下这个方法改造后的样子。</p><pre><code class=\"language-java\">public StandardContext getContext(String name){\n    StandardContext context = contextMap.get(name);\n    if ( context == null) {\n        System.out.println(\"loading context : \" + name);\n        context = new StandardContext();\n        context.setDocBase(name);\n        context.setConnector(connector);\n        Loader loader = new WebappLoader(name, this.loader.getClassLoader());\n        context.setLoader(loader);\n        loader.start();\n        context.start();\n        this.contextMap.put(name, context);\n    }\n    return context;\n}\n</code></pre><p>getContext方法和之前不一样的地方在于，新增了context.start()这一行代码，正因如此，遍历/webapps目录后会启动所有的Context，这样也就实现了在Host调用前预装载Context。</p><h2>引入web.xml</h2><p>我们总是会有这样的需求：访问的路径要简单易记，因为这是面向用户的，而代码编写时的类名则比较完整比较冗长，所以在这二者之间我们要建立映射关系。参考Tomcat，我们在这里也引入web.xml文件，通过自定义配置建立访问路径与类名之间的联系。</p><p>web.xml的参考配置如下：</p><pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app version=\"3.0\"\n         xmlns=\"http://java.sun.com/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;testfilter&lt;/filter-name&gt;\n        &lt;filter-class&gt;test.TestFilter&lt;/filter-class&gt;\n    &lt;/filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;testfilter&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;testservlet&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;test.TestServlet&lt;/servlet-class&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n    &lt;listener&gt;\n        &lt;listener-class&gt;test.TestListener&lt;/listener-class&gt;\n    &lt;/listener&gt;\n&lt;/web-app&gt;\n</code></pre><p>其中，<code>&lt;filter&gt;</code> 标签用来配置过滤器的信息；<code>&lt;filter-mapping&gt;</code> 则配置过滤器过滤的URL，<code>”/*“</code> 表示不进行任何过滤操作；<code>&lt;servlet&gt;</code> 标签用于配置Servlet的信息，<code>&lt;servlet-name&gt;</code> 就是我们提到的给Servlet配置的别名，而 <code>&lt;load-on-startup&gt;</code> 则表示Servlet加载次序，当这个值大于等于0时，启动时按照顺序依次加载Servlet，而小于0或者未定义时，就在第一次调用Servlet时加载；<code>&lt;listener&gt;</code> 标签则用于配置监听器信息。</p><p>上一部分中我们在调用的getContext方法中，调用了context.start()方法，而解析web.xml的工作就放在start方法里。你可以看一下参考代码。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardContext extends ContainerBase implements Context{\n    public void start(){\n        fireContainerEvent(\"Container Started\",this);\n        Logger logger = new FileLogger();\n        setLogger(logger);\n        //扫描 web.xml\n        String file = System.getProperty(\"minit.base\") + File.separator +\n                this.docbase + File.separator + \"WEB-INF\" + File.separator + \"web.xml\";\n        SAXReader reader = new SAXReader();\n        Document document;\n        try {\n            document = reader.read(file);\n            Element root = document.getRootElement();\n            //listeners\n            List&lt;Element&gt; listeners = root.elements(\"listener\");\n            for (Element listener : listeners) {\n                Element listenerclass = listener.element(\"listener-class\");\n                String listenerclassname = listenerclass.getText();\n                System.out.println(\"listenerclassname: \" + listenerclassname);\n                //加载 listeners\n                ContainerListenerDef listenerDef = new ContainerListenerDef();\n                listenerDef.setListenerName(listenerclassname);\n                listenerDef.setListenerClass(listenerclassname);\n                addListenerDef(listenerDef);\n            }\n            listenerStart();\n            //filters\n            List&lt;Element&gt; filters = root.elements(\"filter\");\n            for (Element filter : filters) {\n                Element filetername = filter.element(\"filter-name\");\n                String fileternamestr = filetername.getText();\n                Element fileterclass = filter.element(\"filter-class\");\n                String fileterclassstr = fileterclass.getText();\n                System.out.println(\"filter \" + fileternamestr + fileterclassstr);\n                //加载 filters\n                FilterDef filterDef = new FilterDef();\n                filterDef.setFilterName(fileternamestr);\n                filterDef.setFilterClass(fileterclassstr);\n                addFilterDef(filterDef);\n            }\n            //filter 映射\n            List&lt;Element&gt; filtermaps = root.elements(\"filter-mapping\");\n            for (Element filtermap : filtermaps) {\n                Element filetername = filtermap.element(\"filter-name\");\n                String fileternamestr = filetername.getText();\n                Element urlpattern = filtermap.element(\"url-pattern\");\n                String urlpatternstr = urlpattern.getText();\n                System.out.println(\"filter mapping \" + fileternamestr + urlpatternstr);\n                FilterMap filterMap = new FilterMap();\n                filterMap.setFilterName(fileternamestr);\n                filterMap.setURLPattern(urlpatternstr);\n                addFilterMap(filterMap);\n            }\n            filterStart();\n            //servlet\n            List&lt;Element&gt; servlets = root.elements(\"servlet\");\n            for (Element servlet : servlets) {\n                Element servletname = servlet.element(\"servlet-name\");\n                String servletnamestr = servletname.getText();\n                Element servletclass = servlet.element(\"servlet-class\");\n                String servletclassstr = servletclass.getText();\n                Element loadonstartup = servlet.element(\"load-on-startup\");\n                String loadonstartupstr = null;\n                if (loadonstartup != null) {\n                    loadonstartupstr = loadonstartup.getText();\n                }\n                System.out.println(\"servlet \" + servletnamestr + servletclassstr);\n                this.servletClsMap.put(servletnamestr, servletclassstr);\n                if (loadonstartupstr != null) {\n                    getWrapper(servletnamestr);\n                }\n            }\n        } catch (DocumentException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        System.out.println(\"Context started.........\");\n    }\n}\n</code></pre><p>上述代码和解析server.xml类似，就是把XML文件按照标签格式，一层层地抽丝剥茧，最终将我们自定义的Servlet别名和实际Servlet类建立映射关系，从而简化URL的路径请求。</p><p>这样，我们构建MiniTomcat的工作就完成了。</p><h2>测试</h2><p>有了Servlet自定义的别名和实际Servlet类的配置，用户现在在浏览器地址栏上输入 <code>http://localhost:8080/app1/servlet/testservlet?name=yale</code>，URI 里就不再是test.TestServlet这个类名，而是testservlet这个别名了。</p><h2>小结</h2><p>这节课我们进一步完善了MiniTomcat，新增Context类的预加载，在调用Host之前提前加载Context，不再像之前那样，每次调用Host的时候都临时加载Context，避免了很多重复工作。</p><p>参考Tomcat，我们还引入了server.xml和web.xml，分别对服务端和Servlet进行自定义配置，以配置的方式启动服务器，对业务开发程序员和使用方更加友好。到现在为止，我们的MiniTomcat现在已经是一个完整的小型Tomcat了。</p><p>这节课完整代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter16\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter16</a></p><h2>思考题</h2><p>学完了这节课的内容，你来思考一个问题：我们的web.xml配置文件中，并没有Servlet的mapping配置，要怎么改造程序才能支持配置Servlet的url-pattern呢？</p><p>欢迎你把你思考后的结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"15｜类加载机制的改变：如何自定义ClassLoader？","id":742667},"right":{"article_title":"17｜更大的框架：MiniSpring与MiniTomcat集成","id":743474}},"comments":[{"had_liked":false,"id":386612,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1705217365,"is_pvip":false,"replies":[{"id":140972,"content":"还有几个大的，只支持http, 不能与web server独立运行，没有embedded","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705401330,"ip_address":"澳大利亚","comment_id":386612,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"目前能想到的是 Servlet 注解或者直接增加 mapping 配置","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635955,"discussion_content":"还有几个大的，只支持http, 不能与web server独立运行，没有embedded","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705401330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386551,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1705065259,"is_pvip":false,"replies":[{"id":140995,"content":"Q1，8005是一个监听端口，专门用于SHUTDOWN来关闭Tomcat的，MiniTomcat没有实现它\nQ2，不是Tomcat还用它，而是Tomcat一开始就用它，从来没有变过。复杂但是灵活扩展，因为复杂性高一些，后面没什么人跟着学。大师们的东西经常复杂，大部分程序员学不会，因此没什么人用，另一个例子就是Spring的webflux。\nQ3，host是虚拟主机，server.xml文件中可以配置的，url中server:port这一段就表示的不同的虚拟主机，不同的虚拟主机内部就是不同的Host对象。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1705447693,"ip_address":"澳大利亚","comment_id":386551,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：server.xml中为什么配置两个端口？\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;\n  &lt;Service name=&quot;Catalina&quot;&gt;\n    &lt;Connector executor=&quot;tomcatThreadPool&quot;\n               port=&quot;8080&quot; protocol=&quot;HTTP&#47;1.1&quot;\n               connectionTimeout=&quot;20000&quot;\n               redirectPort=&quot;8443&quot; &#47;&gt;\n    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;\n    &lt;&#47;Engine&gt;\n  &lt;&#47;Service&gt;\n&lt;&#47;Server&gt;\n\n一个8005，另外一个8080，有什么区别？到底有哪一个？\n\nQ2:Tomcat为什么用Digester？\n既然Digester比较复杂，使用的人也比较少，为什么Tomcat还用它？\n\nQ3：Tomcat内部怎么表示多个Host？\n一个主机有一套处理实例吗？类似于“类”，一样的代码，但一个具体的主机就是一个实例，比如有3个主机，就有3个实例。是这样吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635992,"discussion_content":"Q1，8005是一个监听端口，专门用于SHUTDOWN来关闭Tomcat的，MiniTomcat没有实现它\nQ2，不是Tomcat还用它，而是Tomcat一开始就用它，从来没有变过。复杂但是灵活扩展，因为复杂性高一些，后面没什么人跟着学。大师们的东西经常复杂，大部分程序员学不会，因此没什么人用，另一个例子就是Spring的webflux。\nQ3，host是虚拟主机，server.xml文件中可以配置的，url中server:port这一段就表示的不同的虚拟主机，不同的虚拟主机内部就是不同的Host对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705447693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392917,"user_name":"Geek_f1f069","can_delete":false,"product_type":"c1","uid":1781434,"ip_address":"广东","ucode":"8B553307AB107C","user_header":"","comment_is_top":false,"comment_ctime":1722155431,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"课程已经学的差不多了,说一下总体的学习感受。不知道是因为老师讲的不够透彻,\n还是因为自己本身功力的不足，目前感觉理解的不够透彻，想多看代码消化理解,但感觉代码很多地方组织混乱,逻辑不清晰明了。","like_count":0}]}