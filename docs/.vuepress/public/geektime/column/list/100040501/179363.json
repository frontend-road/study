{"id":179363,"title":"12 | 编译期多态：泛型编程和模板入门","content":"<p>你好，我是吴咏炜。</p><p>相信你对多态这个面向对象的特性应该是很熟悉了。我们今天来讲一个非常 C++ 的话题，编译期多态及其相关的 C++ 概念。</p><h2>面向对象和多态</h2><p>在面向对象的开发里，最基本的一个特性就是“多态” <span class=\"orange\">[1]</span>——用相同的代码得到不同结果。以我们在<a href=\"https://time.geekbang.org/column/article/169225\">[第 1 讲]</a> 提到过的 <code>shape</code> 类为例，它可能会定义一些通用的功能，然后在子类里进行实现或覆盖：</p><pre><code class=\"language-c++\">class shape {\npublic:\n  …\n  virtual void draw(const position&amp;) = 0;\n};\n</code></pre><p>上面的类定义意味着所有的子类必须实现 <code>draw</code> 函数，所以可以认为 <code>shape</code> 是定义了一个接口（按 Java 的概念）。在面向对象的设计里，接口抽象了一些基本的行为，实现类里则去具体实现这些功能。当我们有着接口类的指针或引用时，我们实际可以唤起具体的实现类里的逻辑。比如，在一个绘图程序里，我们可以在用户选择一种形状时，把形状赋给一个 <code>shape</code> 的（智能）指针，在用户点击绘图区域时，执行 <code>draw</code> 操作。根据指针指向的形状不同，实际绘制出的可能是圆，可能是三角形，也可能是其他形状。</p><p>但这种面向对象的方式，并不是唯一一种实现多态的方式。在很多动态类型语言里，有所谓的“鸭子”类型 <span class=\"orange\">[2]</span>：</p><!-- [[[read_end]]] --><blockquote>\n<p>如果一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那么这只鸟就可以被当作鸭子。</p>\n</blockquote><p>在这样的语言里，你可以不需要继承来实现 <code>circle</code>、<code>triangle</code> 等类，然后可以直接在这个类型的变量上调用 <code>draw</code> 方法。如果这个类型的对象没有 <code>draw</code> 方法，你就会在执行到 <code>draw()</code> 语句的时候得到一个错误（或异常）。</p><p>鸭子类型使得开发者可以不使用继承体系来灵活地实现一些“约定”，尤其是使得混合不同来源、使用不同对象继承体系的代码成为可能。唯一的要求只是，这些不同的对象有“共通”的成员函数。这些成员函数应当有相同的名字和相同结构的参数（并不要求参数类型相同）。</p><p>听起来很抽象？我们来看一下 C++ 中的具体例子。</p><h2>容器类的共性</h2><p>容器类是有很多共性的。其中，一个最最普遍的共性就是，容器类都有 <code>begin</code> 和 <code>end</code> 成员函数——这使得通用地遍历一个容器成为可能。容器类不必继承一个共同的 Container 基类，而我们仍然可以写出通用的遍历容器的代码，如使用基于范围的循环。</p><p>大部分容器是有 <code>size</code> 成员函数的，在“泛型”编程中，我们同样可以取得一个容器的大小，而不要求容器继承一个叫 SizeableContainer 的基类。</p><p>很多容器具有 <code>push_back</code> 成员函数，可以在尾部插入数据。同样，我们不需要一个叫 BackPushableContainer 的基类。在这个例子里，<code>push_back</code> 函数的参数显然是都不一样的，但明显，所有的 <code>push_back</code> 函数都只接收一个参数。</p><p>我们可以清晰看到的是，虽然 C++ 的标准容器没有对象继承关系，但彼此之间有着很多的同构性。这些同构性很难用继承体系来表达，也完全不必要用继承来表达。C++ 的模板，已经足够表达这些鸭子类型。</p><p>当然，作为一种静态类型语言，C++ 是不会在运行时才报告“没找到 <code>draw</code> 方法”这类问题的。这类错误可以在编译时直接捕获，更精确地来说，是在模板实例化的过程中。</p><p>下面我们通过几个例子，来完整地看一下模板的定义、实例化和特化。</p><h2>C++ 模板</h2><h3>定义模板</h3><p>学过算法的同学应该都知道求最大公约数的辗转相除法，代码大致如下：</p><pre><code class=\"language-c++\">int my_gcd(int a, int b)\n{\n  while (b != 0) {\n    int r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\n</code></pre><p>这里只有一个小小的问题，C++ 的整数类型可不止 <code>int</code> 一种啊。为了让这个算法对像长整型这样的类型也生效，我们需要把它定义成一个模板：</p><pre><code class=\"language-c++\">template &lt;typename E&gt;\nE my_gcd(E a, E b)\n{\n  while (b != E(0)) {\n    E r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\n</code></pre><p>这个代码里，基本上就是把 <code>int</code> 替换成了模板参数 <code>E</code>，并在函数的开头添加了模板的声明。我们对于“整数”这只鸭子的要求实际上是：</p><ul>\n<li>可以通过常量 <code>0</code> 来构造</li>\n<li>可以拷贝（构造和赋值）</li>\n<li>可以作不等于的比较</li>\n<li>可以进行取余数的操作</li>\n</ul><p>对于标准的 <code>int</code>、<code>long</code>、<code>long long</code> 等类型及其对应的无符号类型，以上代码都能正常工作，并能得到正确的结果。</p><p>至于类模板的例子，我们可以直接参考<a href=\"https://time.geekbang.org/column/article/169263\">[第 2 讲]</a> 中的智能指针，这儿就不再重复了。</p><h3>实例化模板</h3><p>不管是类模板还是函数模板，编译器在看到其定义时只能做最基本的语法检查，真正的类型检查要在实例化（instantiation）的时候才能做。一般而言，这也是编译器会报错的时候。</p><p>对于我们上面 <code>my_gcd</code> 的情况，如果提供的是一般的整数类型，那是不会有问题的。但如果我们提供一些其他类型的时候，就有可能出问题了。以 CLN，一个高精度数字库为例（注：我并不是推荐大家使用这个库），如果我们使用它的 <code>cl_I</code> 高精度整数类型来调用 <code>my_gcd</code> 的话，出错信息大致如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/0a/fcc96fe6227cb35be460e73bbd6d1b0a.png?wh=1024*196\" alt=\"\"></p><p>其原因是，虽然它的整数类 <code>cl_I</code> 设计得很像普通的整数，但这个类的对象不支持 <code>%</code> 运算符。出错的第 20 行是我们调用 <code>my_gcd</code> 的位置，而第 9 行是函数模板定义中执行取余数操作的位置。</p><p>实例化失败的话，编译当然就出错退出了。如果成功的话，模板的实例就产生了。在整个的编译过程中，可能产生多个这样的（相同）实例，但最后链接时，会只剩下一个实例。这也是为什么 C++ 会有一个单一定义的规则：如果不同的编译单元看到不同的定义的话，那链接时使用哪个定义是不确定的，结果就可能会让人吃惊。</p><p>模板还可以显式实例化和外部实例化。如果我们在调用 <code>my_gcd</code> 之前进行显式实例化——即，使用 <code>template</code> 关键字并给出完整的类型来声明函数：</p><pre><code class=\"language-c++\">template cln::cl_I\n  my_gcd(cln::cl_I, cln::cl_I);\n</code></pre><p>那出错信息中的第二行就会显示要求实例化的位置。如果在显式实例化的形式之前加上 <code>extern</code> 的话，编译器就会认为这个模板已经在其他某个地方实例化，从而不再产生其定义（但代码用到的内联函数仍可能会导致实例化的发生，这个会随编译器和优化选项不同而变化）。在我们这个例子里，就意味着不会产生上面的编译错误信息了。当然，我们仍然会在链接时得到错误，因为我们并没有真正实例化这个模板。</p><p>类似的，当我们在使用 <code>vector&lt;int&gt;</code> 这样的表达式时，我们就在隐式地实例化 <code>vector&lt;int&gt;</code>。我们同样也可以选择用 <code>template class vector&lt;int&gt;;</code> 来显式实例化，或使用 <code>extern template class vector&lt;int&gt;;</code> 来告诉编译器不需要实例化。显式实例化和外部实例化通常在大型项目中可以用来集中模板的实例化，从而加速编译过程——不需要在每个用到模板的地方都进行实例化了——但这种方式有额外的管理开销，如果实例化了不必要实例化的模板的话，反而会导致可执行文件变大。因而，显式实例化和外部实例化应当谨慎使用。</p><h3>特化模板</h3><p>如果遇到像前面 CLN 那样的情况，我们需要使用的模板参数类型，不能完全满足模板的要求，应该怎么办？</p><p>我们实际上有好几个选择：</p><ul>\n<li>添加代码，让那个类型支持所需要的操作（对成员函数无效）。</li>\n<li>对于函数模板，可以直接针对那个类型进行重载。</li>\n<li>对于类模板和函数模板，可以针对那个类型进行特化。</li>\n</ul><p>对于 <code>cln::cl_I</code> 不支持 <code>%</code> 运算符这种情况，恰好上面的三种方法我们都可以用。</p><p>一、添加 <code>operator%</code> 的实现：</p><pre><code class=\"language-c++\">cln::cl_I\noperator%(const cln::cl_I&amp; lhs,\n          const cln::cl_I&amp; rhs)\n{\n  return mod(lhs, rhs);\n}\n</code></pre><p>在这个例子，这可能是最简单的解决方案了。但在很多情况下，尤其是对对象的成员函数有要求的情况下，这个方法不可行。</p><p>二、针对 <code>cl_I</code> 进行重载：</p><p>为通用起见，我不直接使用 <code>cl_I</code> 的 <code>mod</code> 函数，而用 <code>my_mod</code> 把 <code>my_gcd</code> 改造如下：</p><pre><code class=\"language-c++\">template &lt;typename E&gt;\nE my_gcd(E a, E b)\n{\n  while (b != E(0)) {\n    E r = my_mod(a, b);\n    a = b;\n    b = r;\n  }\n  return a;\n}\n</code></pre><p>然后，一般情况的 <code>my_mod</code> 显然就是：</p><pre><code class=\"language-c++\">template &lt;typename E&gt;\nE my_mod(const E&amp; lhs,\n         const E&amp; rhs)\n{\n  return lhs % rhs;\n}\n</code></pre><p>最后，针对 <code>cl_I</code> 类，我们可以重载（overload）：</p><pre><code class=\"language-c++\">cln::cl_I\nmy_mod(const cln::cl_I&amp; lhs,\n       const cln::cl_I&amp; rhs)\n{\n  return mod(lhs, rhs);\n}\n</code></pre><p>三、针对 <code>cl_I</code> 进行特化：</p><p>同二类似，但我们提供的不是一个重载，而是特化（specialization）：</p><pre><code class=\"language-c++\">template &lt;&gt;\ncln::cl_I my_mod&lt;cln::cl_I&gt;(\n  const cln::cl_I&amp; lhs,\n  const cln::cl_I&amp; rhs)\n{\n  return mod(lhs, rhs);\n}\n</code></pre><p>这个例子比较简单，特化和重载在行为上没有本质的区别。就一般而言，特化是一种更通用的技巧，最主要的原因是特化可以用在类模板和函数模板上，而重载只能用于函数。</p><p>不过，我只是展示了一种可能性而已。通用而言，Herb Sutter 给出了明确的建议：对函数使用重载，对类模板进行特化 <span class=\"orange\">[3]</span>。</p><p>展示特化的更好的例子是 C++11 之前的静态断言。使用特化技巧可以大致实现 <code>static_assert</code> 的功能：</p><pre><code class=\"language-c++\">template &lt;bool&gt;\nstruct compile_time_error;\ntemplate &lt;&gt;\nstruct compile_time_error&lt;true&gt; {};\n\n#define STATIC_ASSERT(Expr, Msg)   \\\n  {                                \\\n    compile_time_error&lt;bool(Expr)&gt; \\\n      ERROR_##_Msg;                \\\n    (void)ERROR_##_Msg;            \\\n  }\n</code></pre><p>上面首先声明了一个 struct 模板，然后仅对 <code>true</code> 的情况进行了特化，产生了一个 struct 的定义。这样。如果遇到 <code>compile_time_error&lt;false&gt;</code> 的情况——也就是下面静态断言里的 <code>Expr</code> 不为真的情况——编译就会失败报错，因为 <code>compile_time_error&lt;false&gt;</code> 从来就没有被定义过。</p><h2>“动态”多态和“静态”多态的对比</h2><p>我前面描述了面向对象的“动态”多态，也描述了 C++ 里基于泛型编程的“静态”多态。需要看到的是，两者解决的实际上是不太一样的问题。“动态”多态解决的是运行时的行为变化——就如我前面提到的，选择了一个形状之后，再选择在某个地方绘制这个形状——这个是无法在编译时确定的。“静态”多态或者“泛型”——解决的是很不同的问题，让适用于不同类型的“同构”算法可以用同一套代码来实现，实际上强调的是对代码的复用。C++ 里提供了很多标准算法，都一样只作出了基本的约定，然后对任何满足约定的类型都可以工作。以排序为例，C++ 里的标准 <code>sort</code> 算法（以两参数的重载为例）只要求：</p><ul>\n<li>参数满足随机访问迭代器的要求。</li>\n<li>迭代器指向的对象之间可以使用 <code>&lt;</code> 来比较大小，满足严格弱序关系。</li>\n<li>迭代器指向的对象可以被移动。</li>\n</ul><p>它的性能超出 C 的 <code>qsort</code>，因为编译器可以内联（inline）对象的比较操作；而在 C 里面比较只能通过一个额外的函数调用来实现。此外，C 的 <code>qsort</code> 函数要求数组指向的内容是可按比特复制的，C++ 的 <code>sort</code> 则要求迭代器指向的内容是可移动的，可适用于更广的情况。</p><p>C++ 里目前有大量这样的泛型算法。随便列举几个：</p><ul>\n<li><code>sort</code>：排序</li>\n<li><code>reverse</code>：反转</li>\n<li><code>count</code>：计数</li>\n<li><code>find</code>：查找</li>\n<li><code>max</code>：最大值</li>\n<li><code>min</code>：最小值</li>\n<li><code>minmax</code>：最小值和最大值</li>\n<li><code>next_permutation</code>：下一个排列</li>\n<li><code>gcd</code>：最大公约数</li>\n<li><code>lcm</code>：最小公倍数</li>\n<li>等等</li>\n</ul><h2>内容小结</h2><p>本讲我们对模板、泛型编程和静态多态做了最基本的描述，并和动态多态做了一定的比较。如果你不熟悉模板和泛型编程的话，应该在本讲之后已经对其有了初步的了解，我们可以在下面几讲中进行更深入的讨论。</p><h2>课后思考</h2><p>请你在课后读一下参考资料，了解一下各种不同的多态，然后想一想：</p><ul>\n<li>C++ 支持几种不同形式的多态？</li>\n<li>为什么并非所有的语言都支持这些不同的多态方式？</li>\n</ul><p>欢迎你留言与我分享你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Polymorphism”. <a href=\"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\">https://en.wikipedia.org/wiki/Polymorphism_(computer_science)</a> </span></p><p><span class=\"reference\">[1a] 维基百科, “多态”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\">https://zh.wikipedia.org/zh-cn/多型_(计算机科学)</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Duck typing”. <a href=\"https://en.wikipedia.org/wiki/Duck_typing\">https://en.wikipedia.org/wiki/Duck_typing</a> </span></p><p><span class=\"reference\">[2a] 维基百科, “鸭子类型”. <a href=\"https://zh.wikipedia.org/zh-cn/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\">https://zh.wikipedia.org/zh-cn/鸭子类型</a> </span></p><p><span class=\"reference\">[3] Herb Sutter, “Why not specialize function templates?”. <a href=\"http://www.gotw.ca/publications/mill17.htm\">http://www.gotw.ca/publications/mill17.htm</a> </span></p>","neighbors":{"left":{"article_title":"11 | Unicode：进入多文字支持的世界","id":179357},"right":{"article_title":"13 | 编译期能做些什么？一个完整的计算世界","id":181608}},"comments":[{"had_liked":false,"id":164662,"user_name":"Geek_077da0","can_delete":false,"product_type":"c1","uid":1479000,"ip_address":"","ucode":"EBA26487CB0482","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIenBesolAerbtjodfkbSsM9VFsHkr6icdZgPqkbQkx1Easl8jqRPWQubEfib3plicD1zXwnTbQ2xU1A/132","comment_is_top":false,"comment_ctime":1577068017,"is_pvip":false,"replies":[{"id":62820,"content":"可以尝试把平时用 Python、Bash 写的小工具改成用 C++。使用现代 C++，这种处理也不会太麻烦。\n\n还有就是小的网络应用、数据处理应用等等。Leetcode 是考算法的，对语言技巧是没啥帮助。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577104765,"ip_address":"","comment_id":164662,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师您好，看到这一讲想问一个一直想问的问题。我是一个在校学生，目前学完了c++的基本语法知识并且看了一些相关的书籍，但平时能自己动手写代码的机会只有刷leetcode的时候，想请问一下老师，在去公司实习之前，有没有什么项目适合初学者练练手的。不然感觉自己看了这么多理论终究只是在纸上谈兵。","like_count":13},{"had_liked":false,"id":171680,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1578990658,"is_pvip":false,"replies":[{"id":66586,"content":"是的，这是个大坑，所以Herb建议对函数用重载就行了，不会有惊讶的行为。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579001535,"ip_address":"","comment_id":171680,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，在参考资料3中，针对模板重载解析的例子\n&#47;&#47; \ntemplate &lt;class T&gt; &#47;&#47; &#47;&#47;（a）与\nvoid f（T）之前相同的旧基础模板  ；\n\ntemplate &lt;&gt; &#47;&#47; &#47;&#47;（c）显式专业化，这一次（a）\nvoid f &lt;&gt;（int *）;\n\ntemplate &lt;class T&gt; &#47;&#47; &#47;&#47;（b）第二个基本模板，重载（a） \nvoid f（T *）;\n\n&#47;&#47; ...\n\nint * p; \nf（p）;\n\n是否针对int*的全特化在(a)的后面，就是属于(a)的基础模板的全特化，在(b)后面就是(b)的全特化。所以int*全特化放置的位置不同，导致了模板裁决时，因为选取了不同的基础模板而导致了不同的结果。是这样吗？","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478852,"discussion_content":"可以尝试把平时用 Python、Bash 写的小工具改成用 C++。使用现代 C++，这种处理也不会太麻烦。\n\n还有就是小的网络应用、数据处理应用等等。Leetcode 是考算法的，对语言技巧是没啥帮助。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577104765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168863,"user_name":"panda","can_delete":false,"product_type":"c1","uid":1263797,"ip_address":"","ucode":"1CA1C732020F10","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcxz0quUK7Q06aNC3qglvvpTQKOanK3suG0qQkK00Q815zF5oiad1wABibCkm8Lk18LmX8UQoUMS5Q/132","comment_is_top":false,"comment_ctime":1578205329,"is_pvip":false,"replies":[{"id":65504,"content":"思考题有些是没有固定答案的，就是希望大家去思考一下。多态的分类也有很多种。包含多态、参数多态和重载多态都是常见的提法，但强制多态这个说法我不熟，查了一下才确定有这种说法，感觉和一般的多态这个词的理解还是有点差异的……\n\n就这第二题而言，也是希望大家去比较学习过的其他语言。这基本上取决于语言本身在类型方面的特性。\n\n以 Python 为例，它是动态类型的语言。所以它不会有真正的静态多态。但和静态类型的面向对象语言（如 Java）不同，它的运行期多态不需要继承。没有参数化多态初看是个缺陷，但由于 Python 的动态参数系统允许默认参数和可变参数，并没有什么参数化多态能做得到而 Python 做不到的事。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578225519,"ip_address":"","comment_id":168863,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第一题通过查阅资料，c++的多态性分专用多态和通用多态，专用多态又分重载多态和强制多态，通用多态又分包含多态和参数多态。\n重载多态：函数重载和操作符重载。\n强制多态：使一个变量类型加以变化让其符合函数操作的要求。\n如：double a = 1.0;\n       int b = 2;\n       double c = a + b;\n此时b会强制转换成double再进行+操作。\n包含多态：虚函数重构。\n参数多态：课程里的函数模板。\n第二题，对各语言了解太浅，需老师给出解答。","like_count":9,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480357,"discussion_content":"思考题有些是没有固定答案的，就是希望大家去思考一下。多态的分类也有很多种。包含多态、参数多态和重载多态都是常见的提法，但强制多态这个说法我不熟，查了一下才确定有这种说法，感觉和一般的多态这个词的理解还是有点差异的……\n\n就这第二题而言，也是希望大家去比较学习过的其他语言。这基本上取决于语言本身在类型方面的特性。\n\n以 Python 为例，它是动态类型的语言。所以它不会有真正的静态多态。但和静态类型的面向对象语言（如 Java）不同，它的运行期多态不需要继承。没有参数化多态初看是个缺陷，但由于 Python 的动态参数系统允许默认参数和可变参数，并没有什么参数化多态能做得到而 Python 做不到的事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578225519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282060,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1615039510,"is_pvip":false,"replies":[{"id":102507,"content":"模板参数可以是值（写出类型名）或者类型（写typename）。这个例子里参数是个bool值。\n\n临时变量不会产生一个全局的符号，在nm里都看不到的。\n\n(void)这行的作用是抑制编译器的变量未使用告警。这是常见的显式告诉编译器不要对变量未使用进行告警的方式。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615200902,"ip_address":"","comment_id":282060,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，静态断言示例中：\ntemplate &lt;bool&gt;\nstruct compile_time_error;\n此处模板参数是bool和是typename T这种有什么区别吗？\n另外 \n compile_time_error&lt;bool(Expr)&gt; \\\n ERROR_##_Msg; \\\n这里我理解在条件为真时，是不是会定义一个名字为ERROR__MSG的对象？但用nm在.o文件中没看到。\n最后\n(void)ERROR_##_Msg;这句有啥作用啊？去掉之前和之后，似乎没啥区别。","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480357,"discussion_content":"思考题有些是没有固定答案的，就是希望大家去思考一下。多态的分类也有很多种。包含多态、参数多态和重载多态都是常见的提法，但强制多态这个说法我不熟，查了一下才确定有这种说法，感觉和一般的多态这个词的理解还是有点差异的……\n\n就这第二题而言，也是希望大家去比较学习过的其他语言。这基本上取决于语言本身在类型方面的特性。\n\n以 Python 为例，它是动态类型的语言。所以它不会有真正的静态多态。但和静态类型的面向对象语言（如 Java）不同，它的运行期多态不需要继承。没有参数化多态初看是个缺陷，但由于 Python 的动态参数系统允许默认参数和可变参数，并没有什么参数化多态能做得到而 Python 做不到的事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578225519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172390,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1579167042,"is_pvip":false,"replies":[{"id":66884,"content":"decltype 得到的是编译期的类型。你需要的是运行期的类型，C++ 里挺有争议（跟异常类似）的功能——RTTI。（还是要强调一句，你应该考虑是否用虚函数可以达到你需要的功能。很多项目，如 Google 的，会禁用 RTTI。）\n\n你可以用 dynamic_cast 来转换成你需要的指针类型，如果类型不对，会得到空指针。你也可以用 typeid 直接来获取对象的实际类型。下面的代码演示一下（需要 Boost；没有安装 Boost 请自行调整，也只是不能输出友好类名而已）：\n\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;boost&#47;core&#47;demangle.hpp&gt;\n\nusing namespace std;\nusing boost::core::demangle;\n\nclass shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {\n};\n\nint main()\n{\n  shape* ptr = new circle();\n  auto&amp; type = typeid(*ptr);\n  cout &lt;&lt; type.name() &lt;&lt; endl;\n  cout &lt;&lt; demangle(type.name()) &lt;&lt; endl;\n  cout &lt;&lt; boolalpha;\n  cout &lt;&lt; (type == typeid(shape) ? &quot;is shape\\n&quot; : &quot;&quot;);\n  cout &lt;&lt; (type == typeid(circle) ? &quot;is circle\\n&quot; : &quot;&quot;);\n  delete ptr;\n}\n\n在 GCC 下的输出：\n\n6circle\ncircle\nis circle","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579186154,"ip_address":"","comment_id":172390,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，在c++的多态中，有没有一种方式可以通过基类的指针获取实际子类的类型呢？比如我定义的两个protobuf的类型里都有user_id的字段，在代码中为了通用（不想每个类型写一个函数），反射出来传递给外围都是pb的基类指针，因为要设置子类的成员就必须要强制类型转换，但是这种情况下又拿不到子类的实际类型去做转换。decltype(基类)得到的还是基类类型","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481723,"discussion_content":"decltype 得到的是编译期的类型。你需要的是运行期的类型，C++ 里挺有争议（跟异常类似）的功能——RTTI。（还是要强调一句，你应该考虑是否用虚函数可以达到你需要的功能。很多项目，如 Google 的，会禁用 RTTI。）\n\n你可以用 dynamic_cast 来转换成你需要的指针类型，如果类型不对，会得到空指针。你也可以用 typeid 直接来获取对象的实际类型。下面的代码演示一下（需要 Boost；没有安装 Boost 请自行调整，也只是不能输出友好类名而已）：\n\n#include &amp;lt;iostream&amp;gt;\n#include &amp;lt;typeinfo&amp;gt;\n#include &amp;lt;boost/core/demangle.hpp&amp;gt;\n\nusing namespace std;\nusing boost::core::demangle;\n\nclass shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {\n};\n\nint main()\n{\n  shape* ptr = new circle();\n  auto&amp;amp; type = typeid(*ptr);\n  cout &amp;lt;&amp;lt; type.name() &amp;lt;&amp;lt; endl;\n  cout &amp;lt;&amp;lt; demangle(type.name()) &amp;lt;&amp;lt; endl;\n  cout &amp;lt;&amp;lt; boolalpha;\n  cout &amp;lt;&amp;lt; (type == typeid(shape) ? &amp;quot;is shape\\n&amp;quot; : &amp;quot;&amp;quot;);\n  cout &amp;lt;&amp;lt; (type == typeid(circle) ? &amp;quot;is circle\\n&amp;quot; : &amp;quot;&amp;quot;);\n  delete ptr;\n}\n\n在 GCC 下的输出：\n\n6circle\ncircle\nis circle","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579186154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177471,"user_name":"陈舸","can_delete":false,"product_type":"c1","uid":1004482,"ip_address":"","ucode":"D8A3E88B14D5F8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/c2/13cc7e76.jpg","comment_is_top":false,"comment_ctime":1581400721,"is_pvip":false,"replies":[{"id":68896,"content":"这个可以用 SFINAE（第 14 讲）或 if constexpr（第 15 讲）做到。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581405228,"ip_address":"","comment_id":177471,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看到编译期多态，我以为会讲一讲利用模板做static_cast&lt;T*&gt;(this)-&gt;implementation()的技巧。这种方法可以在编译期决定要实际调用的函数是哪一个，就可以不用虚函数了。64位平台下对于小型的类可以节省不少空间。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481723,"discussion_content":"decltype 得到的是编译期的类型。你需要的是运行期的类型，C++ 里挺有争议（跟异常类似）的功能——RTTI。（还是要强调一句，你应该考虑是否用虚函数可以达到你需要的功能。很多项目，如 Google 的，会禁用 RTTI。）\n\n你可以用 dynamic_cast 来转换成你需要的指针类型，如果类型不对，会得到空指针。你也可以用 typeid 直接来获取对象的实际类型。下面的代码演示一下（需要 Boost；没有安装 Boost 请自行调整，也只是不能输出友好类名而已）：\n\n#include &amp;lt;iostream&amp;gt;\n#include &amp;lt;typeinfo&amp;gt;\n#include &amp;lt;boost/core/demangle.hpp&amp;gt;\n\nusing namespace std;\nusing boost::core::demangle;\n\nclass shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {\n};\n\nint main()\n{\n  shape* ptr = new circle();\n  auto&amp;amp; type = typeid(*ptr);\n  cout &amp;lt;&amp;lt; type.name() &amp;lt;&amp;lt; endl;\n  cout &amp;lt;&amp;lt; demangle(type.name()) &amp;lt;&amp;lt; endl;\n  cout &amp;lt;&amp;lt; boolalpha;\n  cout &amp;lt;&amp;lt; (type == typeid(shape) ? &amp;quot;is shape\\n&amp;quot; : &amp;quot;&amp;quot;);\n  cout &amp;lt;&amp;lt; (type == typeid(circle) ? &amp;quot;is circle\\n&amp;quot; : &amp;quot;&amp;quot;);\n  delete ptr;\n}\n\n在 GCC 下的输出：\n\n6circle\ncircle\nis circle","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579186154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168165,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1578023672,"is_pvip":false,"replies":[{"id":65327,"content":"还不够全面。可以读读参考资料。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578050036,"ip_address":"","comment_id":168165,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1.C++ 支持2种吧， 静态多态和动态多态，静态多态它在编译器，通过函数重载，用算符重载的方式被调用者使用，动态多态也叫运行时多态，它可以通过虚函数和继承来实现，实现是，编译器会将进程运行过程中动态绑定\n2.支持多态的语言一般是面向对象的语言，所以并非所有的都有。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483439,"discussion_content":"这个可以用 SFINAE（第 14 讲）或 if constexpr（第 15 讲）做到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581405228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165099,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577160347,"is_pvip":false,"replies":[{"id":62945,"content":"1. 一般而言，不应该去修改别人的类。容易出问题。所以不能添加成员函数。\n\n2. 模板参数可以是类型，也可以是常数表达式，包括整数类型常数、枚举、指针、引用。\n\n3. 重载比特化优先。一般而言，函数特化是不推荐的。具体看参考资料 3。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577182269,"ip_address":"","comment_id":165099,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，学完这一课，有 3 点疑问：\n1，你提到的方法一，“添加代码，让那个类型支持所需要的操作（对成员函数无效）”，这里说“对成员函数无效”是具体指的什么情况？\n2，实现static_assert功能时，定义 struct 模板如下: template&lt;bool&gt;  struct compile_time_error, 和常见的模板定义头部 template &lt;typename T&gt; 的格式看起来不一样，常见的这种格式中参数类型是未定的，但是compile_time_error这个模板，参数明确指定是 bool 型，这是模板的另一种形式么？\n3，我尝试做了以下实验\ntemplate &lt;typename T&gt;\nT addData(T a, T b)\n{\n    return a + b;\n}\n\ndouble addData(double a, double b)\n{\n    return (int)a + (int)b;\n}\n\ntemplate &lt;&gt;\ndouble addData(double a, double b)\n{\n    return (int)a + (int)b;\n}\n当我调用 addData(1.5, 2.5)时，发现调用的是针对double的重载函数，而不是模板针对double 的特化，这是为什么？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480158,"discussion_content":"还不够全面。可以读读参考资料。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578050036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":116011,"discussion_content":"👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578050622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386001,"user_name":"转遍世界","can_delete":false,"product_type":"c1","uid":2006194,"ip_address":"江苏","ucode":"0783BFDDE87029","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9c/b2/1a9beeb1.jpg","comment_is_top":false,"comment_ctime":1703822367,"is_pvip":false,"replies":[{"id":140703,"content":"mod 是 cln 名空间里的独立函数。因为有 ADL，编译器能找到它，而不需要我们写 cln::mod。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1703988783,"ip_address":"上海","comment_id":386001,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"还有个问题: 三、针对 cl_I 进行特化：这里全局模板类特化里调用了mod，这个mod是cln::cl_I的成员函数吗？能类外直接调用？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479025,"discussion_content":"1. 一般而言，不应该去修改别人的类。容易出问题。所以不能添加成员函数。\n\n2. 模板参数可以是类型，也可以是常数表达式，包括整数类型常数、枚举、指针、引用。\n\n3. 重载比特化优先。一般而言，函数特化是不推荐的。具体看参考资料 3。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577182269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385998,"user_name":"转遍世界","can_delete":false,"product_type":"c1","uid":2006194,"ip_address":"江苏","ucode":"0783BFDDE87029","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9c/b2/1a9beeb1.jpg","comment_is_top":false,"comment_ctime":1703822005,"is_pvip":false,"replies":[{"id":140702,"content":"对，可以的。全局函数对名空间里的对象进行重载，完全没有问题。当然，放在名空间里，用 ADL 来找到也是可以的。但修改“别人”的名空间通常不那么好。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1703988502,"ip_address":"上海","comment_id":385998,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师我有个疑问: \n二、针对 cl_I 进行重载：这里。\n类的成员函数能重载全局模板函数吗，不在同一个作用域啊。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634805,"discussion_content":"mod 是 cln 名空间里的独立函数。因为有 ADL，编译器能找到它，而不需要我们写 cln::mod。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703988783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164662,"user_name":"Geek_077da0","can_delete":false,"product_type":"c1","uid":1479000,"ip_address":"","ucode":"EBA26487CB0482","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIenBesolAerbtjodfkbSsM9VFsHkr6icdZgPqkbQkx1Easl8jqRPWQubEfib3plicD1zXwnTbQ2xU1A/132","comment_is_top":false,"comment_ctime":1577068017,"is_pvip":false,"replies":[{"id":62820,"content":"可以尝试把平时用 Python、Bash 写的小工具改成用 C++。使用现代 C++，这种处理也不会太麻烦。\n\n还有就是小的网络应用、数据处理应用等等。Leetcode 是考算法的，对语言技巧是没啥帮助。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577104765,"ip_address":"","comment_id":164662,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师您好，看到这一讲想问一个一直想问的问题。我是一个在校学生，目前学完了c++的基本语法知识并且看了一些相关的书籍，但平时能自己动手写代码的机会只有刷leetcode的时候，想请问一下老师，在去公司实习之前，有没有什么项目适合初学者练练手的。不然感觉自己看了这么多理论终究只是在纸上谈兵。","like_count":13,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478852,"discussion_content":"可以尝试把平时用 Python、Bash 写的小工具改成用 C++。使用现代 C++，这种处理也不会太麻烦。\n\n还有就是小的网络应用、数据处理应用等等。Leetcode 是考算法的，对语言技巧是没啥帮助。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577104765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171680,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1578990658,"is_pvip":false,"replies":[{"id":66586,"content":"是的，这是个大坑，所以Herb建议对函数用重载就行了，不会有惊讶的行为。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579001535,"ip_address":"","comment_id":171680,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，在参考资料3中，针对模板重载解析的例子\n&#47;&#47; \ntemplate &lt;class T&gt; &#47;&#47; &#47;&#47;（a）与\nvoid f（T）之前相同的旧基础模板  ；\n\ntemplate &lt;&gt; &#47;&#47; &#47;&#47;（c）显式专业化，这一次（a）\nvoid f &lt;&gt;（int *）;\n\ntemplate &lt;class T&gt; &#47;&#47; &#47;&#47;（b）第二个基本模板，重载（a） \nvoid f（T *）;\n\n&#47;&#47; ...\n\nint * p; \nf（p）;\n\n是否针对int*的全特化在(a)的后面，就是属于(a)的基础模板的全特化，在(b)后面就是(b)的全特化。所以int*全特化放置的位置不同，导致了模板裁决时，因为选取了不同的基础模板而导致了不同的结果。是这样吗？","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481468,"discussion_content":"是的，这是个大坑，所以Herb建议对函数用重载就行了，不会有惊讶的行为。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579001535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168863,"user_name":"panda","can_delete":false,"product_type":"c1","uid":1263797,"ip_address":"","ucode":"1CA1C732020F10","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcxz0quUK7Q06aNC3qglvvpTQKOanK3suG0qQkK00Q815zF5oiad1wABibCkm8Lk18LmX8UQoUMS5Q/132","comment_is_top":false,"comment_ctime":1578205329,"is_pvip":false,"replies":[{"id":65504,"content":"思考题有些是没有固定答案的，就是希望大家去思考一下。多态的分类也有很多种。包含多态、参数多态和重载多态都是常见的提法，但强制多态这个说法我不熟，查了一下才确定有这种说法，感觉和一般的多态这个词的理解还是有点差异的……\n\n就这第二题而言，也是希望大家去比较学习过的其他语言。这基本上取决于语言本身在类型方面的特性。\n\n以 Python 为例，它是动态类型的语言。所以它不会有真正的静态多态。但和静态类型的面向对象语言（如 Java）不同，它的运行期多态不需要继承。没有参数化多态初看是个缺陷，但由于 Python 的动态参数系统允许默认参数和可变参数，并没有什么参数化多态能做得到而 Python 做不到的事。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578225519,"ip_address":"","comment_id":168863,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第一题通过查阅资料，c++的多态性分专用多态和通用多态，专用多态又分重载多态和强制多态，通用多态又分包含多态和参数多态。\n重载多态：函数重载和操作符重载。\n强制多态：使一个变量类型加以变化让其符合函数操作的要求。\n如：double a = 1.0;\n       int b = 2;\n       double c = a + b;\n此时b会强制转换成double再进行+操作。\n包含多态：虚函数重构。\n参数多态：课程里的函数模板。\n第二题，对各语言了解太浅，需老师给出解答。","like_count":9,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481468,"discussion_content":"是的，这是个大坑，所以Herb建议对函数用重载就行了，不会有惊讶的行为。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579001535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282060,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1615039510,"is_pvip":false,"replies":[{"id":102507,"content":"模板参数可以是值（写出类型名）或者类型（写typename）。这个例子里参数是个bool值。\n\n临时变量不会产生一个全局的符号，在nm里都看不到的。\n\n(void)这行的作用是抑制编译器的变量未使用告警。这是常见的显式告诉编译器不要对变量未使用进行告警的方式。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615200902,"ip_address":"","comment_id":282060,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，静态断言示例中：\ntemplate &lt;bool&gt;\nstruct compile_time_error;\n此处模板参数是bool和是typename T这种有什么区别吗？\n另外 \n compile_time_error&lt;bool(Expr)&gt; \\\n ERROR_##_Msg; \\\n这里我理解在条件为真时，是不是会定义一个名字为ERROR__MSG的对象？但用nm在.o文件中没看到。\n最后\n(void)ERROR_##_Msg;这句有啥作用啊？去掉之前和之后，似乎没啥区别。","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516601,"discussion_content":"模板参数可以是值（写出类型名）或者类型（写typename）。这个例子里参数是个bool值。\n\n临时变量不会产生一个全局的符号，在nm里都看不到的。\n\n(void)这行的作用是抑制编译器的变量未使用告警。这是常见的显式告诉编译器不要对变量未使用进行告警的方式。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615200902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172390,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1579167042,"is_pvip":false,"replies":[{"id":66884,"content":"decltype 得到的是编译期的类型。你需要的是运行期的类型，C++ 里挺有争议（跟异常类似）的功能——RTTI。（还是要强调一句，你应该考虑是否用虚函数可以达到你需要的功能。很多项目，如 Google 的，会禁用 RTTI。）\n\n你可以用 dynamic_cast 来转换成你需要的指针类型，如果类型不对，会得到空指针。你也可以用 typeid 直接来获取对象的实际类型。下面的代码演示一下（需要 Boost；没有安装 Boost 请自行调整，也只是不能输出友好类名而已）：\n\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;boost&#47;core&#47;demangle.hpp&gt;\n\nusing namespace std;\nusing boost::core::demangle;\n\nclass shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {\n};\n\nint main()\n{\n  shape* ptr = new circle();\n  auto&amp; type = typeid(*ptr);\n  cout &lt;&lt; type.name() &lt;&lt; endl;\n  cout &lt;&lt; demangle(type.name()) &lt;&lt; endl;\n  cout &lt;&lt; boolalpha;\n  cout &lt;&lt; (type == typeid(shape) ? &quot;is shape\\n&quot; : &quot;&quot;);\n  cout &lt;&lt; (type == typeid(circle) ? &quot;is circle\\n&quot; : &quot;&quot;);\n  delete ptr;\n}\n\n在 GCC 下的输出：\n\n6circle\ncircle\nis circle","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579186154,"ip_address":"","comment_id":172390,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，在c++的多态中，有没有一种方式可以通过基类的指针获取实际子类的类型呢？比如我定义的两个protobuf的类型里都有user_id的字段，在代码中为了通用（不想每个类型写一个函数），反射出来传递给外围都是pb的基类指针，因为要设置子类的成员就必须要强制类型转换，但是这种情况下又拿不到子类的实际类型去做转换。decltype(基类)得到的还是基类类型","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516601,"discussion_content":"模板参数可以是值（写出类型名）或者类型（写typename）。这个例子里参数是个bool值。\n\n临时变量不会产生一个全局的符号，在nm里都看不到的。\n\n(void)这行的作用是抑制编译器的变量未使用告警。这是常见的显式告诉编译器不要对变量未使用进行告警的方式。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615200902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177471,"user_name":"陈舸","can_delete":false,"product_type":"c1","uid":1004482,"ip_address":"","ucode":"D8A3E88B14D5F8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/c2/13cc7e76.jpg","comment_is_top":false,"comment_ctime":1581400721,"is_pvip":false,"replies":[{"id":68896,"content":"这个可以用 SFINAE（第 14 讲）或 if constexpr（第 15 讲）做到。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581405228,"ip_address":"","comment_id":177471,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看到编译期多态，我以为会讲一讲利用模板做static_cast&lt;T*&gt;(this)-&gt;implementation()的技巧。这种方法可以在编译期决定要实际调用的函数是哪一个，就可以不用虚函数了。64位平台下对于小型的类可以节省不少空间。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483439,"discussion_content":"这个可以用 SFINAE（第 14 讲）或 if constexpr（第 15 讲）做到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581405228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168165,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1578023672,"is_pvip":false,"replies":[{"id":65327,"content":"还不够全面。可以读读参考资料。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578050036,"ip_address":"","comment_id":168165,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1.C++ 支持2种吧， 静态多态和动态多态，静态多态它在编译器，通过函数重载，用算符重载的方式被调用者使用，动态多态也叫运行时多态，它可以通过虚函数和继承来实现，实现是，编译器会将进程运行过程中动态绑定\n2.支持多态的语言一般是面向对象的语言，所以并非所有的都有。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480158,"discussion_content":"还不够全面。可以读读参考资料。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578050036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":116011,"discussion_content":"👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578050622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165099,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577160347,"is_pvip":false,"replies":[{"id":62945,"content":"1. 一般而言，不应该去修改别人的类。容易出问题。所以不能添加成员函数。\n\n2. 模板参数可以是类型，也可以是常数表达式，包括整数类型常数、枚举、指针、引用。\n\n3. 重载比特化优先。一般而言，函数特化是不推荐的。具体看参考资料 3。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577182269,"ip_address":"","comment_id":165099,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，学完这一课，有 3 点疑问：\n1，你提到的方法一，“添加代码，让那个类型支持所需要的操作（对成员函数无效）”，这里说“对成员函数无效”是具体指的什么情况？\n2，实现static_assert功能时，定义 struct 模板如下: template&lt;bool&gt;  struct compile_time_error, 和常见的模板定义头部 template &lt;typename T&gt; 的格式看起来不一样，常见的这种格式中参数类型是未定的，但是compile_time_error这个模板，参数明确指定是 bool 型，这是模板的另一种形式么？\n3，我尝试做了以下实验\ntemplate &lt;typename T&gt;\nT addData(T a, T b)\n{\n    return a + b;\n}\n\ndouble addData(double a, double b)\n{\n    return (int)a + (int)b;\n}\n\ntemplate &lt;&gt;\ndouble addData(double a, double b)\n{\n    return (int)a + (int)b;\n}\n当我调用 addData(1.5, 2.5)时，发现调用的是针对double的重载函数，而不是模板针对double 的特化，这是为什么？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479025,"discussion_content":"1. 一般而言，不应该去修改别人的类。容易出问题。所以不能添加成员函数。\n\n2. 模板参数可以是类型，也可以是常数表达式，包括整数类型常数、枚举、指针、引用。\n\n3. 重载比特化优先。一般而言，函数特化是不推荐的。具体看参考资料 3。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577182269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386001,"user_name":"转遍世界","can_delete":false,"product_type":"c1","uid":2006194,"ip_address":"江苏","ucode":"0783BFDDE87029","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9c/b2/1a9beeb1.jpg","comment_is_top":false,"comment_ctime":1703822367,"is_pvip":false,"replies":[{"id":140703,"content":"mod 是 cln 名空间里的独立函数。因为有 ADL，编译器能找到它，而不需要我们写 cln::mod。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1703988783,"ip_address":"上海","comment_id":386001,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"还有个问题: 三、针对 cl_I 进行特化：这里全局模板类特化里调用了mod，这个mod是cln::cl_I的成员函数吗？能类外直接调用？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634805,"discussion_content":"mod 是 cln 名空间里的独立函数。因为有 ADL，编译器能找到它，而不需要我们写 cln::mod。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703988783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385998,"user_name":"转遍世界","can_delete":false,"product_type":"c1","uid":2006194,"ip_address":"江苏","ucode":"0783BFDDE87029","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9c/b2/1a9beeb1.jpg","comment_is_top":false,"comment_ctime":1703822005,"is_pvip":false,"replies":[{"id":140702,"content":"对，可以的。全局函数对名空间里的对象进行重载，完全没有问题。当然，放在名空间里，用 ADL 来找到也是可以的。但修改“别人”的名空间通常不那么好。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1703988502,"ip_address":"上海","comment_id":385998,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师我有个疑问: \n二、针对 cl_I 进行重载：这里。\n类的成员函数能重载全局模板函数吗，不在同一个作用域啊。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634804,"discussion_content":"对，可以的。全局函数对名空间里的对象进行重载，完全没有问题。当然，放在名空间里，用 ADL 来找到也是可以的。但修改“别人”的名空间通常不那么好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703988502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346999,"user_name":"陈宣羽","can_delete":false,"product_type":"c1","uid":1255656,"ip_address":"","ucode":"7812AD450A2DBB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erjCdbJn7FleCuDzn9Wx9ZJKB8XyecWibxeJ1kiaKSJibxucaCF94zYNAB6rtUicxtpAtfuy0HeTBteaA/132","comment_is_top":false,"comment_ctime":1653611685,"is_pvip":false,"replies":[{"id":126530,"content":"不需要。我也没这么说过吧。\n\n另外，纯虚函数只是防止你产生没有实现该函数的类的对象而已。子类不实现纯虚函数也没什么不可以——可以放孙子类里面去。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1653629194,"ip_address":"","comment_id":346999,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"不是纯虚函数子类一定要实现吗，虚函数没这个要求吧","like_count":0},{"had_liked":false,"id":338032,"user_name":"水月","can_delete":false,"product_type":"c1","uid":2344034,"ip_address":"","ucode":"78FC68615016DB","user_header":"https://static001.geekbang.org/account/avatar/00/23/c4/62/269aae3f.jpg","comment_is_top":false,"comment_ctime":1647247496,"is_pvip":false,"replies":[{"id":123798,"content":"我一般把 Python 当作强类型的动态类型语言。类型强弱不是非黑即白，而且 Python 的类型还是相当强的，基本没有容易误导的默认转换。\n\nC++ 里也有静态成员函数，但没有直接对应于 classmethod 的东西。C++ 不是动态类型语言，类型不是运行时可以动态传递的对象。模板的参数可以模拟 classmethod，但绑定是在编译时而非运行时。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1647665741,"ip_address":"","comment_id":338032,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"Python是个弱类型的语言，而且也是动态“编译”，一些函数重载的行为好像都被包装进解释器了。继承多态倒是挺常见的，也经常override重写一些方法，或者比较懒的时候直接就给加一些长命令参数给调用脚本时区分用。Python的类有个有意思的内容是，里面除了最常用的实例方法之外，允许定义static_method和class_method，这些不进行实例化就能使用的类方法目前我还没从C++了解到，可能是其他的实现逻辑？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557112,"discussion_content":"我一般把 Python 当作强类型的动态类型语言。类型强弱不是非黑即白，而且 Python 的类型还是相当强的，基本没有容易误导的默认转换。\n\nC++ 里也有静态成员函数，但没有直接对应于 classmethod 的东西。C++ 不是动态类型语言，类型不是运行时可以动态传递的对象。模板的参数可以模拟 classmethod，但绑定是在编译时而非运行时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647665742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257966,"user_name":"miyan","can_delete":false,"product_type":"c1","uid":1347109,"ip_address":"","ucode":"D261644CB1D3EA","user_header":"https://static001.geekbang.org/account/avatar/00/14/8e/25/23d2af5d.jpg","comment_is_top":false,"comment_ctime":1604227054,"is_pvip":false,"replies":[{"id":93916,"content":"可以看第24讲。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1604276622,"ip_address":"","comment_id":257966,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师我想问个问题:用模板编程的时候，传入的类型是不定的，这时我想调试，想输出这个类型的名字，比如我传进了 circle 类，想输出“circle”字符串，如果用typeid().name()得到的不是&quot;circle&quot;字符串，这种情况该怎么实现呢","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508511,"discussion_content":"可以看第24讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604276622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238139,"user_name":"十斗簸箕","can_delete":false,"product_type":"c1","uid":1276938,"ip_address":"","ucode":"D661B1B42694FC","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/0a/8aa06f3f.jpg","comment_is_top":false,"comment_ctime":1596078707,"is_pvip":false,"replies":[{"id":88036,"content":"你的代码里有很多错误：\n\n应该是 int main()\nGetDouble 后面漏了 ()\n漏包含 &lt;string&gt;\n“T =”需要改成“result =”\n\n按你的写法，用 C++17 的 if constexpr（if 不行，不同类型的赋值会出问题）可以编译过。\n\n但是，你为什么用模板呢？似乎用重载直接就可以解决问题：\n\n    void Test(int&amp; result)\n    {\n        result = GetInt();\n    }\n    void Test(double&amp; result)\n    {\n        result = GetDouble();\n    }\n    void Test(std::string&amp; result)\n    {\n        result = GetInt();\n    }\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596125880,"ip_address":"","comment_id":238139,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师好，最近遇到个问题，还请多多指教，代码如下\n#include &lt;type_traits&gt;\n\nclass TemplateTest {\npublic:\n\ttemplate &lt;typename T&gt;\n\tvoid Test(T &amp;result) {\n\t\tif (std::is_same&lt;T, int&gt;::value)\t\t\n\t\t\tT = GetInt();\n\t\telse if (std::is_same&lt;T, double&gt;::value)\n\t\t\tT = GetDouble;\n\t\telse if (std::is_same&lt;T, std::string&gt;::value)\n\t\t\tT = GetString();\n\t}\n\nprivate:\n\tint GetInt() {\n\t\treturn 123;\n\t}\n\n\tdouble GetDouble() {\n\t\treturn 123.456;\n\t}\n\n\tstd::string GetString() {\n\t\treturn &quot;string&quot;;\n\t}\n};\n\nvoid main() {\n\tTemplateTest tt;\n\tint v1;\n\ttt.Test(v1);\n\n\tstd::string v2;\n\ttt.Test(v2);\n}\n目的是想用Test接口根据不同类型来调用内部实现函数，但在vs2015环境编译不过，不知何故？或者是我这种用法存在一些问题，如果有好的实现方式希望指正，谢谢~","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502654,"discussion_content":"你的代码里有很多错误：\n\n应该是 int main()\nGetDouble 后面漏了 ()\n漏包含 &amp;lt;string&amp;gt;\n“T =”需要改成“result =”\n\n按你的写法，用 C++17 的 if constexpr（if 不行，不同类型的赋值会出问题）可以编译过。\n\n但是，你为什么用模板呢？似乎用重载直接就可以解决问题：\n\n    void Test(int&amp;amp; result)\n    {\n        result = GetInt();\n    }\n    void Test(double&amp;amp; result)\n    {\n        result = GetDouble();\n    }\n    void Test(std::string&amp;amp; result)\n    {\n        result = GetInt();\n    }\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596125880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276938,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/0a/8aa06f3f.jpg","nickname":"十斗簸箕","note":"","ucode":"D661B1B42694FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295442,"discussion_content":"多谢老师帮忙debug，忽略语法低级错误😅。因为学了模版所以想用模版的方式实现一下，这种方式好像在C++11是编译不过的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596196761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223322,"user_name":"万林","can_delete":false,"product_type":"c1","uid":2003101,"ip_address":"","ucode":"6B7C0D041EE46C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/90/9d/51226f50.jpg","comment_is_top":false,"comment_ctime":1591061862,"is_pvip":false,"replies":[{"id":82273,"content":"模板都是有特殊性的。函数如果不inline的话，正常情况下也不能放头文件里，否则就会有多个定义；但函数模板编译器同样会特殊处理。最后链接后只有一个实例化的结果存在。\n\n不管是否inline，所有编译单元看到的定义必须是完全相同的，否则，仍然可能会有意外发生。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591066205,"ip_address":"","comment_id":223322,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师你好，我看到单例的模块定义类似下面的代码，放在一个头文件中，其他类通过继承实现单例，实现代码重用。我有一点不太明白，这个静态变量定义在头文件中，会不会在编译期就有多份定义了呢？难道是在链接的时候只选择一份吗？还有老师提倡这种单例的实现方式吗？\n\ntemplate&lt;class T&gt;\nclass CSingleton\n{\npublic:\n    static T* Instance()\n    {\n        if (!m_pInstance)\n        {\n        }\n        return m_pInstance;\n    };\n  \nprivate:\n    static T* m_pInstance;\n};\n\n&#47;&#47;静态变量定义\ntemplate&lt;class T&gt; T* CSingleton&lt;T&gt;::m_pInstance = NULL;\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497099,"discussion_content":"模板都是有特殊性的。函数如果不inline的话，正常情况下也不能放头文件里，否则就会有多个定义；但函数模板编译器同样会特殊处理。最后链接后只有一个实例化的结果存在。\n\n不管是否inline，所有编译单元看到的定义必须是完全相同的，否则，仍然可能会有意外发生。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591066205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170614,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1578644111,"is_pvip":false,"replies":[{"id":66135,"content":"可以看看其他的一些读者评论。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578667413,"ip_address":"","comment_id":170614,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"多态:\n类的话是基于虚继承衍生出来的\n函数的话是基于函数重载衍生出来的\n\n\n不支持所有的多态方式:应该和语言的设计理念和哲学相关。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481041,"discussion_content":"可以看看其他的一些读者评论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578667413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166787,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1577594954,"is_pvip":false,"replies":[{"id":64864,"content":"sort不一定是快速排序，但通用的高性能排序算法一般都要求随机访问。sort解决的是通用情况。list::sort 则解决一种不能随机访问的特殊情况。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577674208,"ip_address":"","comment_id":166787,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"参数满足随机访问迭代器的要求。\n———\n是因为sort 是个复合排序，主体是使用 快速排序，而快排貌似是有随机访问的需求吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479624,"discussion_content":"sort不一定是快速排序，但通用的高性能排序算法一般都要求随机访问。sort解决的是通用情况。list::sort 则解决一种不能随机访问的特殊情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577674208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165241,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1577186889,"is_pvip":false,"replies":[{"id":62983,"content":"想一想：\n\n为什么要继承？继承的话，能带来什么好处？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577189252,"ip_address":"","comment_id":165241,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师您好，就是我对容器共性这一块有点疑惑：\n比如老师讲的容器中的共性：begin, end等，但是又提到&quot; C++ 的标准容器没有对象继承关系&quot;；那对于不同的容器来说，vector, map, list等都得各自去实现自己的begin, end方法吗？\n那既然不同的容器有着诸多的共性，为什么C++里不用继承呢？\n谢谢老师的回复","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479090,"discussion_content":"想一想：\n\n为什么要继承？继承的话，能带来什么好处？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577189252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1081217,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7f/81/27bb3dd8.jpg","nickname":"香喷喷的小乳猪","note":"","ucode":"D57C3220CE02FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158930,"discussion_content":"个人觉得使用继承就意味着会引入虚表，那么在性能上就会有一定的损耗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580639869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100365,"discussion_content":"好处：使用继承可以提高代码的复用性；而且也可以让子类拥有像父类的一些共性，实现多态；\n1. 那容器为什么不把这些共性写到父类里呢？然后让各类容器继承。\n\n2. &#34;这些同构性很难用继承体系来表达，也完全不必要用继承来表达，C++模版已经足够表达这些鸭子类型&#34;， 老师我对这句话的理解不是很到位。\n\n谢谢老师的答复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577254486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165119,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"","comment_is_top":false,"comment_ctime":1577166084,"is_pvip":false,"replies":[{"id":62950,"content":"具体一点吧。哪一题你特别想知道又没有正确的回答？😎","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577182506,"ip_address":"","comment_id":165119,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"请问前几讲中最后的问题的答案可以公布一下吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479033,"discussion_content":"具体一点吧。哪一题你特别想知道又没有正确的回答？😎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577182506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164624,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1577062187,"is_pvip":false,"replies":[{"id":62555,"content":"静态语言的鸭子类型和动态语言还是有区别的。毕竟静态语言，如 C++，需要在编译时绑定所有的符号，否则就会出错……下面还会有例子，和 C++ 如何试图解决、改善这些问题的。编译期行为要讲上很多讲的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577065772,"ip_address":"","comment_id":164624,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"从来没有把C++的模板编程和鸭子类型联系到一起，以前一提到鸭子类型，就想到了PYTHON和JAVASCRIPT。现在想想，按照鸭子类型的定义，那么JAVA也是支持它的。\n\n一直感觉C++的模板编程就是一个静态实现的“动态类型子语言”：完全可以像写JAVASCRIPT一样写C++代码，只是需要先编译一下再运行。也许JAVASCRIPT的实现比如V8引擎应该大量使用它吧。\n\n但最后的总结，静态多态主要是用于算法复用。好像上面的想法又不太行的通了。不过，如果把类型的行为也看作一种算法的话，似乎又是一个解决办法。\n\n没看过V8这么复杂的源码，也许有一天去看看吧。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479033,"discussion_content":"具体一点吧。哪一题你特别想知道又没有正确的回答？😎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577182506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346999,"user_name":"陈宣羽","can_delete":false,"product_type":"c1","uid":1255656,"ip_address":"","ucode":"7812AD450A2DBB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erjCdbJn7FleCuDzn9Wx9ZJKB8XyecWibxeJ1kiaKSJibxucaCF94zYNAB6rtUicxtpAtfuy0HeTBteaA/132","comment_is_top":false,"comment_ctime":1653611685,"is_pvip":false,"replies":[{"id":126530,"content":"不需要。我也没这么说过吧。\n\n另外，纯虚函数只是防止你产生没有实现该函数的类的对象而已。子类不实现纯虚函数也没什么不可以——可以放孙子类里面去。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1653629194,"ip_address":"","comment_id":346999,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"不是纯虚函数子类一定要实现吗，虚函数没这个要求吧","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573755,"discussion_content":"不需要。我也没这么说过吧。\n\n另外，纯虚函数只是防止你产生没有实现该函数的类的对象而已。子类不实现纯虚函数也没什么不可以——可以放孙子类里面去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653629194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338032,"user_name":"水月","can_delete":false,"product_type":"c1","uid":2344034,"ip_address":"","ucode":"78FC68615016DB","user_header":"https://static001.geekbang.org/account/avatar/00/23/c4/62/269aae3f.jpg","comment_is_top":false,"comment_ctime":1647247496,"is_pvip":false,"replies":[{"id":123798,"content":"我一般把 Python 当作强类型的动态类型语言。类型强弱不是非黑即白，而且 Python 的类型还是相当强的，基本没有容易误导的默认转换。\n\nC++ 里也有静态成员函数，但没有直接对应于 classmethod 的东西。C++ 不是动态类型语言，类型不是运行时可以动态传递的对象。模板的参数可以模拟 classmethod，但绑定是在编译时而非运行时。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1647665741,"ip_address":"","comment_id":338032,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"Python是个弱类型的语言，而且也是动态“编译”，一些函数重载的行为好像都被包装进解释器了。继承多态倒是挺常见的，也经常override重写一些方法，或者比较懒的时候直接就给加一些长命令参数给调用脚本时区分用。Python的类有个有意思的内容是，里面除了最常用的实例方法之外，允许定义static_method和class_method，这些不进行实例化就能使用的类方法目前我还没从C++了解到，可能是其他的实现逻辑？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573755,"discussion_content":"不需要。我也没这么说过吧。\n\n另外，纯虚函数只是防止你产生没有实现该函数的类的对象而已。子类不实现纯虚函数也没什么不可以——可以放孙子类里面去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653629194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257966,"user_name":"miyan","can_delete":false,"product_type":"c1","uid":1347109,"ip_address":"","ucode":"D261644CB1D3EA","user_header":"https://static001.geekbang.org/account/avatar/00/14/8e/25/23d2af5d.jpg","comment_is_top":false,"comment_ctime":1604227054,"is_pvip":false,"replies":[{"id":93916,"content":"可以看第24讲。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1604276622,"ip_address":"","comment_id":257966,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师我想问个问题:用模板编程的时候，传入的类型是不定的，这时我想调试，想输出这个类型的名字，比如我传进了 circle 类，想输出“circle”字符串，如果用typeid().name()得到的不是&quot;circle&quot;字符串，这种情况该怎么实现呢","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557112,"discussion_content":"我一般把 Python 当作强类型的动态类型语言。类型强弱不是非黑即白，而且 Python 的类型还是相当强的，基本没有容易误导的默认转换。\n\nC++ 里也有静态成员函数，但没有直接对应于 classmethod 的东西。C++ 不是动态类型语言，类型不是运行时可以动态传递的对象。模板的参数可以模拟 classmethod，但绑定是在编译时而非运行时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647665742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238139,"user_name":"十斗簸箕","can_delete":false,"product_type":"c1","uid":1276938,"ip_address":"","ucode":"D661B1B42694FC","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/0a/8aa06f3f.jpg","comment_is_top":false,"comment_ctime":1596078707,"is_pvip":false,"replies":[{"id":88036,"content":"你的代码里有很多错误：\n\n应该是 int main()\nGetDouble 后面漏了 ()\n漏包含 &lt;string&gt;\n“T =”需要改成“result =”\n\n按你的写法，用 C++17 的 if constexpr（if 不行，不同类型的赋值会出问题）可以编译过。\n\n但是，你为什么用模板呢？似乎用重载直接就可以解决问题：\n\n    void Test(int&amp; result)\n    {\n        result = GetInt();\n    }\n    void Test(double&amp; result)\n    {\n        result = GetDouble();\n    }\n    void Test(std::string&amp; result)\n    {\n        result = GetInt();\n    }\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596125880,"ip_address":"","comment_id":238139,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师好，最近遇到个问题，还请多多指教，代码如下\n#include &lt;type_traits&gt;\n\nclass TemplateTest {\npublic:\n\ttemplate &lt;typename T&gt;\n\tvoid Test(T &amp;result) {\n\t\tif (std::is_same&lt;T, int&gt;::value)\t\t\n\t\t\tT = GetInt();\n\t\telse if (std::is_same&lt;T, double&gt;::value)\n\t\t\tT = GetDouble;\n\t\telse if (std::is_same&lt;T, std::string&gt;::value)\n\t\t\tT = GetString();\n\t}\n\nprivate:\n\tint GetInt() {\n\t\treturn 123;\n\t}\n\n\tdouble GetDouble() {\n\t\treturn 123.456;\n\t}\n\n\tstd::string GetString() {\n\t\treturn &quot;string&quot;;\n\t}\n};\n\nvoid main() {\n\tTemplateTest tt;\n\tint v1;\n\ttt.Test(v1);\n\n\tstd::string v2;\n\ttt.Test(v2);\n}\n目的是想用Test接口根据不同类型来调用内部实现函数，但在vs2015环境编译不过，不知何故？或者是我这种用法存在一些问题，如果有好的实现方式希望指正，谢谢~","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508511,"discussion_content":"可以看第24讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604276622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223322,"user_name":"万林","can_delete":false,"product_type":"c1","uid":2003101,"ip_address":"","ucode":"6B7C0D041EE46C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/90/9d/51226f50.jpg","comment_is_top":false,"comment_ctime":1591061862,"is_pvip":false,"replies":[{"id":82273,"content":"模板都是有特殊性的。函数如果不inline的话，正常情况下也不能放头文件里，否则就会有多个定义；但函数模板编译器同样会特殊处理。最后链接后只有一个实例化的结果存在。\n\n不管是否inline，所有编译单元看到的定义必须是完全相同的，否则，仍然可能会有意外发生。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591066205,"ip_address":"","comment_id":223322,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师你好，我看到单例的模块定义类似下面的代码，放在一个头文件中，其他类通过继承实现单例，实现代码重用。我有一点不太明白，这个静态变量定义在头文件中，会不会在编译期就有多份定义了呢？难道是在链接的时候只选择一份吗？还有老师提倡这种单例的实现方式吗？\n\ntemplate&lt;class T&gt;\nclass CSingleton\n{\npublic:\n    static T* Instance()\n    {\n        if (!m_pInstance)\n        {\n        }\n        return m_pInstance;\n    };\n  \nprivate:\n    static T* m_pInstance;\n};\n\n&#47;&#47;静态变量定义\ntemplate&lt;class T&gt; T* CSingleton&lt;T&gt;::m_pInstance = NULL;\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502654,"discussion_content":"你的代码里有很多错误：\n\n应该是 int main()\nGetDouble 后面漏了 ()\n漏包含 &amp;lt;string&amp;gt;\n“T =”需要改成“result =”\n\n按你的写法，用 C++17 的 if constexpr（if 不行，不同类型的赋值会出问题）可以编译过。\n\n但是，你为什么用模板呢？似乎用重载直接就可以解决问题：\n\n    void Test(int&amp;amp; result)\n    {\n        result = GetInt();\n    }\n    void Test(double&amp;amp; result)\n    {\n        result = GetDouble();\n    }\n    void Test(std::string&amp;amp; result)\n    {\n        result = GetInt();\n    }\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596125880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276938,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/0a/8aa06f3f.jpg","nickname":"十斗簸箕","note":"","ucode":"D661B1B42694FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295442,"discussion_content":"多谢老师帮忙debug，忽略语法低级错误😅。因为学了模版所以想用模版的方式实现一下，这种方式好像在C++11是编译不过的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596196761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170614,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1578644111,"is_pvip":false,"replies":[{"id":66135,"content":"可以看看其他的一些读者评论。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578667413,"ip_address":"","comment_id":170614,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"多态:\n类的话是基于虚继承衍生出来的\n函数的话是基于函数重载衍生出来的\n\n\n不支持所有的多态方式:应该和语言的设计理念和哲学相关。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497099,"discussion_content":"模板都是有特殊性的。函数如果不inline的话，正常情况下也不能放头文件里，否则就会有多个定义；但函数模板编译器同样会特殊处理。最后链接后只有一个实例化的结果存在。\n\n不管是否inline，所有编译单元看到的定义必须是完全相同的，否则，仍然可能会有意外发生。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591066205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166787,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1577594954,"is_pvip":false,"replies":[{"id":64864,"content":"sort不一定是快速排序，但通用的高性能排序算法一般都要求随机访问。sort解决的是通用情况。list::sort 则解决一种不能随机访问的特殊情况。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577674208,"ip_address":"","comment_id":166787,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"参数满足随机访问迭代器的要求。\n———\n是因为sort 是个复合排序，主体是使用 快速排序，而快排貌似是有随机访问的需求吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481041,"discussion_content":"可以看看其他的一些读者评论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578667413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165241,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1577186889,"is_pvip":false,"replies":[{"id":62983,"content":"想一想：\n\n为什么要继承？继承的话，能带来什么好处？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577189252,"ip_address":"","comment_id":165241,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师您好，就是我对容器共性这一块有点疑惑：\n比如老师讲的容器中的共性：begin, end等，但是又提到&quot; C++ 的标准容器没有对象继承关系&quot;；那对于不同的容器来说，vector, map, list等都得各自去实现自己的begin, end方法吗？\n那既然不同的容器有着诸多的共性，为什么C++里不用继承呢？\n谢谢老师的回复","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479624,"discussion_content":"sort不一定是快速排序，但通用的高性能排序算法一般都要求随机访问。sort解决的是通用情况。list::sort 则解决一种不能随机访问的特殊情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577674208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165119,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"","comment_is_top":false,"comment_ctime":1577166084,"is_pvip":false,"replies":[{"id":62950,"content":"具体一点吧。哪一题你特别想知道又没有正确的回答？😎","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577182506,"ip_address":"","comment_id":165119,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"请问前几讲中最后的问题的答案可以公布一下吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479090,"discussion_content":"想一想：\n\n为什么要继承？继承的话，能带来什么好处？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577189252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1081217,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7f/81/27bb3dd8.jpg","nickname":"香喷喷的小乳猪","note":"","ucode":"D57C3220CE02FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158930,"discussion_content":"个人觉得使用继承就意味着会引入虚表，那么在性能上就会有一定的损耗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580639869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100365,"discussion_content":"好处：使用继承可以提高代码的复用性；而且也可以让子类拥有像父类的一些共性，实现多态；\n1. 那容器为什么不把这些共性写到父类里呢？然后让各类容器继承。\n\n2. &#34;这些同构性很难用继承体系来表达，也完全不必要用继承来表达，C++模版已经足够表达这些鸭子类型&#34;， 老师我对这句话的理解不是很到位。\n\n谢谢老师的答复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577254486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164624,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1577062187,"is_pvip":false,"replies":[{"id":62555,"content":"静态语言的鸭子类型和动态语言还是有区别的。毕竟静态语言，如 C++，需要在编译时绑定所有的符号，否则就会出错……下面还会有例子，和 C++ 如何试图解决、改善这些问题的。编译期行为要讲上很多讲的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577065772,"ip_address":"","comment_id":164624,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"从来没有把C++的模板编程和鸭子类型联系到一起，以前一提到鸭子类型，就想到了PYTHON和JAVASCRIPT。现在想想，按照鸭子类型的定义，那么JAVA也是支持它的。\n\n一直感觉C++的模板编程就是一个静态实现的“动态类型子语言”：完全可以像写JAVASCRIPT一样写C++代码，只是需要先编译一下再运行。也许JAVASCRIPT的实现比如V8引擎应该大量使用它吧。\n\n但最后的总结，静态多态主要是用于算法复用。好像上面的想法又不太行的通了。不过，如果把类型的行为也看作一种算法的话，似乎又是一个解决办法。\n\n没看过V8这么复杂的源码，也许有一天去看看吧。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478843,"discussion_content":"静态语言的鸭子类型和动态语言还是有区别的。毕竟静态语言，如 C++，需要在编译时绑定所有的符号，否则就会出错……下面还会有例子，和 C++ 如何试图解决、改善这些问题的。编译期行为要讲上很多讲的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577065772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294600,"user_name":"HiganFish","can_delete":false,"product_type":"c1","uid":2091577,"ip_address":"","ucode":"DC20BD93D028AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/JoyRPCWkxccplNK490GnekjMicgaQc3GJcicBDLPBgA7IumlXTsVAR6Fb2vShntJaecOJaW53r6YVyffOaDibya9g/132","comment_is_top":false,"comment_ctime":1622014740,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"特设多态：根据参数不同实际表现不同（函数重载或运算符重载）\n参数多态：参数多态允许函数或数据类型被一般性的书写（泛型）\n子类型：（多态）\n多态-变量多态：基类型的变量（对于C++是引用或指针）可以被赋值基类型对象，也可以被赋值派生类型的对象。\n多态-函数多态：平时说的调用子类函数的多态\n","like_count":0},{"had_liked":false,"id":294600,"user_name":"HiganFish","can_delete":false,"product_type":"c1","uid":2091577,"ip_address":"","ucode":"DC20BD93D028AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/JoyRPCWkxccplNK490GnekjMicgaQc3GJcicBDLPBgA7IumlXTsVAR6Fb2vShntJaecOJaW53r6YVyffOaDibya9g/132","comment_is_top":false,"comment_ctime":1622014740,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"特设多态：根据参数不同实际表现不同（函数重载或运算符重载）\n参数多态：参数多态允许函数或数据类型被一般性的书写（泛型）\n子类型：（多态）\n多态-变量多态：基类型的变量（对于C++是引用或指针）可以被赋值基类型对象，也可以被赋值派生类型的对象。\n多态-函数多态：平时说的调用子类函数的多态\n","like_count":0}]}