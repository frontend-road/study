{"id":120355,"title":"14 | Swift字符串的常见操作","content":"<p><strong>课件地址</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/swift-course\">https://gitee.com/geektime-geekbang/swift-course</a></p>","comments":[{"had_liked":false,"id":128355,"user_name":"Geek_923968","can_delete":false,"product_type":"c3","uid":1628844,"ip_address":"","ucode":"881D269194EB70","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/63SEk2Xv2Ecjmejt460C35jjko0bA4WuRUSmpZmZibpib4WT3Yo85iaQU7BklpkibERmDmy0adnPX7uI6cCYZXxrtA/132","comment_is_top":false,"comment_ctime":1566873760,"is_pvip":false,"replies":[{"id":47685,"content":"首先，你可以在OC里面尝试下面的代码：\n NSMutableString *a = [NSMutableString new];\n    NSMutableString *b = a;\n    [b appendString:@&quot;123&quot;];\n    if (b == a) {\n        NSLog(@&quot;b == a&quot;);\n    }\n    if ([b isEqualToString:a]) {\n        NSLog(@&quot;b isEqualToString:a&quot;);\n    }\n\n其次，swift里面String是值类型，==比较的是值是否相等，并不是比较两个变量地址。 swift里面String的==比较对标OC里的isEqualToString:方法","user_name":"作者回复","user_name_real":"Geek_f72435","uid":1341726,"ctime":1566904035,"ip_address":"","comment_id":128355,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"这节讲解的有错误。用OC也不一样，涉及到字符穿的拷贝问题。赋值后实际字符串已经拷贝了，他们在栈上的指针已经不是同一个。","like_count":4,"discussions":[{"author":{"id":1341726,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLxtKhpmvzx2VB4iajicfJVFmQR3eP3xBpdpQEovpSqUfAOrNImvYwVb7P37ibI0ONziau9sbFEk8oDaA/132","nickname":"elfgate","note":"","ucode":"3C0B5F7C1F664C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464916,"discussion_content":"首先，你可以在OC里面尝试下面的代码：\n NSMutableString *a = [NSMutableString new];\n    NSMutableString *b = a;\n    [b appendString:@&amp;quot;123&amp;quot;];\n    if (b == a) {\n        NSLog(@&amp;quot;b == a&amp;quot;);\n    }\n    if ([b isEqualToString:a]) {\n        NSLog(@&amp;quot;b isEqualToString:a&amp;quot;);\n    }\n\n其次，swift里面String是值类型，==比较的是值是否相等，并不是比较两个变量地址。 swift里面String的==比较对标OC里的isEqualToString:方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566904035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271936,"discussion_content":"你可能用的是假oc😂\noc里面直接赋值就是赋值指针地址而已(完全和C++一样的效果)...和swift差别很大. \n这节课并没有说错. 建议先写个demo测试一下吧.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590223258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152441,"user_name":"Geek_jg3r26","can_delete":false,"product_type":"c3","uid":1454691,"ip_address":"","ucode":"7D093ED7273CBE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEK5icO2A4K7HYTYfQoagTz7VbtgxfS2ibBqLnKVWwQZgsePibZWFvFJEhPT8BtpQSaFx9IEodyp6c0dw/132","comment_is_top":false,"comment_ctime":1574001755,"is_pvip":false,"replies":[{"id":59108,"content":"所有语言中值类型和引用类型基本特性都是一致的。 值类型和引用类型的特性包含在名字本身，而不针对特定语言","user_name":"作者回复","user_name_real":"Geek_f72435","uid":1341726,"ctime":1574311774,"ip_address":"","comment_id":152441,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"老师，是不是所有语言的 值类型和引用类型 都是这个特性","like_count":0,"discussions":[{"author":{"id":1341726,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLxtKhpmvzx2VB4iajicfJVFmQR3eP3xBpdpQEovpSqUfAOrNImvYwVb7P37ibI0ONziau9sbFEk8oDaA/132","nickname":"elfgate","note":"","ucode":"3C0B5F7C1F664C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474818,"discussion_content":"所有语言中值类型和引用类型基本特性都是一致的。 值类型和引用类型的特性包含在名字本身，而不针对特定语言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574311774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130597,"user_name":"月巴 森","can_delete":false,"product_type":"c3","uid":1015619,"ip_address":"","ucode":"2AEED21352F28A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/43/4bfd8714.jpg","comment_is_top":false,"comment_ctime":1567491576,"is_pvip":false,"replies":[{"id":49081,"content":"对，地址打印可能会不一样，但是仍然是copy on write，可以用前面学到的swiftc命令看下汇编","user_name":"作者回复","user_name_real":"Geek_f72435","uid":1341726,"ctime":1567589237,"ip_address":"","comment_id":130597,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"OC里的mutableString是指针拷贝，swift的string的var是值拷贝。记得哪里看过说swift里面的值类型是copyOnWrite的，刚试了一下，初始赋值已经不是同一个内存地址了，不知道是不是现在做了改变?","like_count":0,"discussions":[{"author":{"id":1341726,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLxtKhpmvzx2VB4iajicfJVFmQR3eP3xBpdpQEovpSqUfAOrNImvYwVb7P37ibI0ONziau9sbFEk8oDaA/132","nickname":"elfgate","note":"","ucode":"3C0B5F7C1F664C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466023,"discussion_content":"对，地址打印可能会不一样，但是仍然是copy on write，可以用前面学到的swiftc命令看下汇编","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567589237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271939,"discussion_content":"查资料的结果. 是不同地址, 但是新变量地址上有一个映射指针, 指向原来的变量的内存上, 还有一个标记位. 这样虽然两个变量地址不一样, 但是如果标记位有效, 访问新变量会直接访问成老变量的内存, 只有修改新(旧)变量时, 才会把老变量内存上的内容复制到新变量上, 以此来分离两个变量的关联\n\n下面是资料内容:\n\n在复制一个对象的时候并不是真正的把原先的对象复制到内存的另外一个位置上，而是在新对象的内存映射表中设置一个指针，指向源对象的位置，并把那块内存的Copy-On-Write位设置为1.\n这样，在对新的对象执行读操作的时候，内存数据不发生任何变动，直接执行读操作；而在对新的对象执行写操作时，将真正的对象复制到新的内存地址中，并修改新对象的内存映射表指向这个新的位置，并在新的内存位置上执行写操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590223986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015619,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/43/4bfd8714.jpg","nickname":"月巴 森","note":"","ucode":"2AEED21352F28A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7626,"discussion_content":"如果一开始赋值已经不是同一个地址，那copyOnWrite的作用在哪？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567589440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293480,"user_name":"刘彪","can_delete":false,"product_type":"c3","uid":1381320,"ip_address":"","ucode":"F99AB6EB881FB2","user_header":"https://static001.geekbang.org/account/avatar/00/15/13/c8/c8493a33.jpg","comment_is_top":false,"comment_ctime":1621403814,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"var str: String = &quot;123&quot;\nvar str1 = str\nprint(str == str1)&#47;&#47; true\nstr1 += &quot;456&quot;\nstr += &quot;456&quot;\nprint(str == str1) &#47;&#47; true","like_count":1},{"had_liked":false,"id":132934,"user_name":"程相康","can_delete":false,"product_type":"c3","uid":1649310,"ip_address":"","ucode":"515415A535B7F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoHUPsQbvW6IaFwbFCeeOReicp6mYPXoDzibYczFsfaTKErfyxpC4NjPaNDqUMKxsZ81fIZ5LKIpibbw/132","comment_is_top":false,"comment_ctime":1568278366,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"老师可以把字符串的地址打出来。","like_count":1},{"had_liked":false,"id":127379,"user_name":"拉德姆","can_delete":false,"product_type":"c3","uid":1043757,"ip_address":"","ucode":"A813EDA3984385","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erdmsQ1lvSIk6GR6CcicQjKwXicxEJIELxfhX7J1kky08myb1UrscfFLg6nDHTwUFRAeosTKDX7WxpA/132","comment_is_top":false,"comment_ctime":1566672078,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"字符串值都不一样，比较还有什么意义？","like_count":1},{"had_liked":false,"id":345405,"user_name":"milker","can_delete":false,"product_type":"c3","uid":1513496,"ip_address":"","ucode":"F3572761BE8447","user_header":"https://static001.geekbang.org/account/avatar/00/17/18/18/74abfe03.jpg","comment_is_top":false,"comment_ctime":1652257140,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"swift中String的str==str1是判断值是否相等\n应该只会在值类型的Set，Array，Dictionary实现Copy-on-Write\nInt，String值类型在赋值的时候就拷贝了\n\n\n        &#47;&#47; copy on right\n        var num1 = 10\n        var num2 = num1\n        print(address(of: &amp;num1)) &#47;&#47;0x7ffee0c29828\n        print(address(of: &amp;num2)) &#47;&#47;0x7ffee0c29820\n         \n        var str1 = &quot;abc&quot;\n        var str2 = str1\n        print(address(of: &amp;str1)) &#47;&#47;0x7ffee0c29810\n        print(address(of: &amp;str2)) &#47;&#47;0x7ffee0c29800\n        \n        \n        var arr1 = [1,2,3,4,5]\n        var arr2 = arr1\n        print(address(of: &amp;arr1)) &#47;&#47;0x6000023b06b0\n        print(address(of: &amp;arr2)) &#47;&#47;0x6000023b06b0\n         \n        arr2[2] = 4\n        print(address(of: &amp;arr1)) &#47;&#47;0x6000023b06b0\n        print(address(of: &amp;arr2)) &#47;&#47;0x6000023b11f0","like_count":0},{"had_liked":false,"id":181008,"user_name":"o0oi1i","can_delete":false,"product_type":"c3","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1582458718,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"打卡14","like_count":0},{"had_liked":false,"id":126509,"user_name":"langzuxiaozi","can_delete":false,"product_type":"c3","uid":1228566,"ip_address":"","ucode":"16ED5AF589D766","user_header":"https://static001.geekbang.org/account/avatar/00/12/bf/16/3e4fbe53.jpg","comment_is_top":false,"comment_ctime":1566398421,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"判断字符串相等 为true，修改了另一个字符串，然后比较，为false。 你这个解释是错误的。对资源拷贝优化","like_count":0,"discussions":[{"author":{"id":1341726,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLxtKhpmvzx2VB4iajicfJVFmQR3eP3xBpdpQEovpSqUfAOrNImvYwVb7P37ibI0ONziau9sbFEk8oDaA/132","nickname":"elfgate","note":"","ucode":"3C0B5F7C1F664C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5729,"discussion_content":"这是因为string是值类型，赋值以后对第二个变量修改，修改的是赋值后的值。如果是引用，赋值之后也会指向相同的对象，你不管修改哪个变量，两个变量都会发生变化。 copy on write是swift对值类型的优化，并不会对比较操作有影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566448601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}